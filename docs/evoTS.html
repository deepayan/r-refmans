<!DOCTYPE html><html lang="en"><head><title>Help for package evoTS</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {evoTS}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#as.evoTS.multi.BW.acceldecel.fit'><p>Class for fit to evolutionary sequence (time-series) models</p></a></li>
<li><a href='#as.evoTS.multi.BW.fit'><p>Class for fit to evolutionary sequence (time-series) models</p></a></li>
<li><a href='#as.evoTS.multi.OU.fit'><p>Class for fit to evolutionary sequence (time-series) models</p></a></li>
<li><a href='#as.evoTS.multi.URW.fit'><p>Class for fit to evolutionary sequence (time-series) models</p></a></li>
<li><a href='#as.evoTS.multi.URW.shift.fit'><p>Class for fit to evolutionary sequence (time-series) models</p></a></li>
<li><a href='#as.evoTSfit.OUBM'><p>Class for fit to evolutionary sequence (time-series) models</p></a></li>
<li><a href='#diameter_S.yellowstonensis'><p>Evolutionary sequence (time-series) of phenotypic change in diameter in the lineage Stephanodiscus yellowstonensis</p></a></li>
<li><a href='#fit.all.univariate'><p>Fit all univariate models to an evolutionary sequence (time-series).</p></a></li>
<li><a href='#fit.mode.shift'><p>Fit two models to two separate segments to an evolutionary sequence (time-series).</p></a></li>
<li><a href='#fit.multivariate.OU'><p>Fit predefined multivariate Ornstein-Uhlenbeck models to multivariate evolutionary sequence (time-series) data.</p></a></li>
<li><a href='#fit.multivariate.OU.user.defined'><p>Fit user-defined multivariate Ornstein-Uhlenbeck models to multivariate evolutionary sequence (time-series) data.</p></a></li>
<li><a href='#fit.multivariate.URW'><p>Fit multivariate Unbiased Random Walk models to multivariate evolutionary sequence (time-series) data.</p></a></li>
<li><a href='#fit.multivariate.URW.shift'><p>Fit separate multivariate Unbiased Random Walk models to two different segments of a multivariate evolutionary sequence (time-series).</p></a></li>
<li><a href='#logL.joint.accel_decel'><p>Log-likelihoods for evolutionary models</p></a></li>
<li><a href='#logL.joint.accel.decel.single.R'><p>Log-likelihoods for evolutionary models</p></a></li>
<li><a href='#logL.joint.accel.decel.single.R.zero.corr'><p>Log-likelihoods for evolutionary models</p></a></li>
<li><a href='#logL.joint.multi.OUOU'><p>Log-likelihoods for evolutionary models</p></a></li>
<li><a href='#logL.joint.multi.OUOU.user'><p>Log-likelihoods for evolutionary models</p></a></li>
<li><a href='#logL.joint.multi.R'><p>Log-likelihoods for evolutionary models</p></a></li>
<li><a href='#logL.joint.OU.BM'><p>Log-likelihoods for evolutionary models</p></a></li>
<li><a href='#logL.joint.single.R'><p>Log-likelihoods for evolutionary models</p></a></li>
<li><a href='#logL.joint.single.R.zero.corr'><p>Log-likelihoods for evolutionary models</p></a></li>
<li><a href='#logL.joint.Stasis.OU'><p>Log-likelihoods for evolutionary models</p></a></li>
<li><a href='#logL.joint.URW.URW'><p>Log-likelihoods for evolutionary models</p></a></li>
<li><a href='#loglik.surface.accel'><p>Calculate the log-likelihood surface for a part of parameter space</p></a></li>
<li><a href='#loglik.surface.decel'><p>Calculate the log-likelihood surface for a part of parameter space</p></a></li>
<li><a href='#loglik.surface.GRW'><p>Calculate the log-likelihood surface for a part of parameter space</p></a></li>
<li><a href='#loglik.surface.OU'><p>Calculate the log-likelihood surface for a part of parameter space</p></a></li>
<li><a href='#loglik.surface.OUBM'><p>Calculate the log-likelihood surface for a part of parameter space</p></a></li>
<li><a href='#loglik.surface.stasis'><p>Calculate the log-likelihood surface for a part of parameter space</p></a></li>
<li><a href='#loglik.surface.URW'><p>Calculate the log-likelihood surface for a part of parameter space</p></a></li>
<li><a href='#make.multivar.evoTS'><p>Makes a multivariate data set of</p></a></li>
<li><a href='#opt.accel.single.R'><p>Fit multivariate Unbiased Random Walk with increasing (exponential accelerating) rate of change through time.</p></a></li>
<li><a href='#opt.accel.single.R.zero.corr'><p>Fit multivariate Unbiased Random Walk model with uncorrelated trait changes and with increasing (exponential accelerating) rate of change through time.</p></a></li>
<li><a href='#opt.decel.single.R'><p>Fit multivariate Unbiased Random Walk with decreasing (exponential decaying) rate of change through time.</p></a></li>
<li><a href='#opt.decel.single.R.zero.corr'><p>Fit multivariate Unbiased Random Walk model with uncorrelated trait changes and with decreasing (exponential decaying) rate of change through time.</p></a></li>
<li><a href='#opt.joint.accel'><p>Fit an Unbiased Random Walk with an accelerating rate of change through time.</p></a></li>
<li><a href='#opt.joint.decel'><p>Fit an Unbiased Random Walk with an decelerating rate of change through time.</p></a></li>
<li><a href='#opt.joint.OUBM'><p>Fit an Ornstein-Uhlenbeck model with an optimum that evolves according to a Unbiased Random Walk.</p></a></li>
<li><a href='#opt.joint.URW.Stasis'><p>Optimization and log-likelihoods for pairs of models.</p></a></li>
<li><a href='#opt.single.R'><p>Fit multivariate Unbiased Random Walk model.</p></a></li>
<li><a href='#opt.single.R.zero.corr'><p>Fit multivariate Unbiased Random Walk model with uncorrelated trait changes.</p></a></li>
<li><a href='#plotevoTS'><p>Plot a paleoTS object</p></a></li>
<li><a href='#plotevoTS.multivariate'><p>Plots multivariate evolutionary sequence (time-series) data set</p></a></li>
<li><a href='#ribs_S.yellowstonensis'><p>Evolutionary sequence (time-series) of phenotypic change in the number of ribs in the lineage Stephanodiscus yellowstonensis</p></a></li>
<li><a href='#sim.accel.decel'><p>Simulate an Unbiased Random Walk with an accelerating or decelerating rate of change through time.</p></a></li>
<li><a href='#sim.multi.OU'><p>Simulate multivariate Ornstein-Uhlenbeck evolutionary sequence data sets</p></a></li>
<li><a href='#sim.multi.URW'><p>Simulate multivariate evolutionary sequence data that evolve according to an Unbiased Random Walk</p></a></li>
<li><a href='#sim.OUBM'><p>Simulate an Ornstein-Uhlenbeck process with optimum changing according to an unbiased random walk</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Title:</td>
<td>Analyses of Evolutionary Time-Series</td>
</tr>
<tr>
<td>Version:</td>
<td>1.0.3</td>
</tr>
<tr>
<td>Description:</td>
<td>Facilitates univariate and multivariate analysis of evolutionary sequences of phenotypic change. The package extends the modeling framework available in the 'paleoTS' package. Please see <a href="https://klvoje.github.io/evoTS/index.html">https://klvoje.github.io/evoTS/index.html</a> for information about the package and the implemented models. </td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>Imports:</td>
<td>paleoTS (&ge; 0.4-4), mvtnorm, plotly, pracma, MASS, stats,
utils</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Kjetil Lysne Voje &lt;k.l.voje@nhm.uio.no&gt;</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.3.1</td>
</tr>
<tr>
<td>Suggests:</td>
<td>rmarkdown, knitr</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.5.0)</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://klvoje.github.io/evoTS/index.html">https://klvoje.github.io/evoTS/index.html</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/klvoje/evoTS/issues">https://github.com/klvoje/evoTS/issues</a></td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-06-20 09:47:43 UTC; kjetillv</td>
</tr>
<tr>
<td>Author:</td>
<td>Kjetil Lysne Voje [aut, cre]</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-06-20 10:10:03 UTC</td>
</tr>
</table>
<hr>
<h2 id='as.evoTS.multi.BW.acceldecel.fit'>Class for fit to evolutionary sequence (time-series) models</h2><span id='topic+as.evoTS.multi.BW.acceldecel.fit'></span>

<h3>Description</h3>

<p>A function that combines useful information summarizing model fit.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>as.evoTS.multi.BW.acceldecel.fit(
  converge,
  modelName,
  logL,
  ancestral.values,
  SE.anc,
  r,
  SE.r,
  R,
  SE.R,
  method,
  K,
  n,
  iter
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="as.evoTS.multi.BW.acceldecel.fit_+3A_converge">converge</code></td>
<td>
<p>info on model convergence</p>
</td></tr>
<tr><td><code id="as.evoTS.multi.BW.acceldecel.fit_+3A_modelname">modelName</code></td>
<td>
<p>description of the model.</p>
</td></tr>
<tr><td><code id="as.evoTS.multi.BW.acceldecel.fit_+3A_logl">logL</code></td>
<td>
<p>log-likelihood of model</p>
</td></tr>
<tr><td><code id="as.evoTS.multi.BW.acceldecel.fit_+3A_ancestral.values">ancestral.values</code></td>
<td>
<p>maximum-likelihood estimates of the ancestral trait values</p>
</td></tr>
<tr><td><code id="as.evoTS.multi.BW.acceldecel.fit_+3A_se.anc">SE.anc</code></td>
<td>
<p>standard errors of the estimated ancestral states</p>
</td></tr>
<tr><td><code id="as.evoTS.multi.BW.acceldecel.fit_+3A_r">r</code></td>
<td>
<p>maximum-likelihood estimates of the r parameter</p>
</td></tr>
<tr><td><code id="as.evoTS.multi.BW.acceldecel.fit_+3A_se.r">SE.r</code></td>
<td>
<p>standard error of the r parameter</p>
</td></tr>
<tr><td><code id="as.evoTS.multi.BW.acceldecel.fit_+3A_r">R</code></td>
<td>
<p>maximum-likelihood estimates of the parameters in the R matrix</p>
</td></tr>
<tr><td><code id="as.evoTS.multi.BW.acceldecel.fit_+3A_se.r">SE.R</code></td>
<td>
<p>standard errors of the parameters in the R matrix</p>
</td></tr>
<tr><td><code id="as.evoTS.multi.BW.acceldecel.fit_+3A_method">method</code></td>
<td>
<p>the parameterization used: Joint</p>
</td></tr>
<tr><td><code id="as.evoTS.multi.BW.acceldecel.fit_+3A_k">K</code></td>
<td>
<p>number of parameters in the model</p>
</td></tr>
<tr><td><code id="as.evoTS.multi.BW.acceldecel.fit_+3A_n">n</code></td>
<td>
<p>sample size</p>
</td></tr>
<tr><td><code id="as.evoTS.multi.BW.acceldecel.fit_+3A_iter">iter</code></td>
<td>
<p>the number of times the optimization method is run from different starting points. Default is NULL, meaning the optimization is run once.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is used by the model-fitting routines for the Unbiased Random Walk models with an accelerated and decelerated rate of evoluton to create standardized output
</p>


<h3>Note</h3>

<p>This function is not likely to be called directly by the user.
</p>


<h3>Author(s)</h3>

<p>Kjetil Lysne Voje
</p>

<hr>
<h2 id='as.evoTS.multi.BW.fit'>Class for fit to evolutionary sequence (time-series) models</h2><span id='topic+as.evoTS.multi.BW.fit'></span>

<h3>Description</h3>

<p>A function that combines useful information summarizing model fit.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>as.evoTS.multi.BW.fit(
  converge,
  modelName,
  logL,
  ancestral.values,
  SE.anc,
  R,
  SE.R,
  shift.point,
  method,
  K,
  n,
  iter
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="as.evoTS.multi.BW.fit_+3A_converge">converge</code></td>
<td>
<p>info on model convergence</p>
</td></tr>
<tr><td><code id="as.evoTS.multi.BW.fit_+3A_modelname">modelName</code></td>
<td>
<p>description of the model</p>
</td></tr>
<tr><td><code id="as.evoTS.multi.BW.fit_+3A_logl">logL</code></td>
<td>
<p>log-likelihood of model</p>
</td></tr>
<tr><td><code id="as.evoTS.multi.BW.fit_+3A_ancestral.values">ancestral.values</code></td>
<td>
<p>maximum-likelihood estimates of the ancestral trait values</p>
</td></tr>
<tr><td><code id="as.evoTS.multi.BW.fit_+3A_se.anc">SE.anc</code></td>
<td>
<p>standard errors of the estimated ancestral states</p>
</td></tr>
<tr><td><code id="as.evoTS.multi.BW.fit_+3A_r">R</code></td>
<td>
<p>maximum-likelihood estimates of the parameters in the R matrix</p>
</td></tr>
<tr><td><code id="as.evoTS.multi.BW.fit_+3A_se.r">SE.R</code></td>
<td>
<p>standard errors of the parameters in the R matrix</p>
</td></tr>
<tr><td><code id="as.evoTS.multi.BW.fit_+3A_shift.point">shift.point</code></td>
<td>
<p>the sample in the time series that represents the first sample in the second segment.</p>
</td></tr>
<tr><td><code id="as.evoTS.multi.BW.fit_+3A_method">method</code></td>
<td>
<p>the parameterization used: Joint</p>
</td></tr>
<tr><td><code id="as.evoTS.multi.BW.fit_+3A_k">K</code></td>
<td>
<p>number of parameters in the model</p>
</td></tr>
<tr><td><code id="as.evoTS.multi.BW.fit_+3A_n">n</code></td>
<td>
<p>sample size</p>
</td></tr>
<tr><td><code id="as.evoTS.multi.BW.fit_+3A_iter">iter</code></td>
<td>
<p>the number of times the optimization method is run from different starting points. Default is NULL, meaning the optimization is run once.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is used by the model-fitting routines for the multivariate Unbiased Random Walk models to create standardized output
</p>


<h3>Note</h3>

<p>This function is not likely to be called directly by the user.
</p>


<h3>Author(s)</h3>

<p>Kjetil Lysne Voje
</p>

<hr>
<h2 id='as.evoTS.multi.OU.fit'>Class for fit to evolutionary sequence (time-series) models</h2><span id='topic+as.evoTS.multi.OU.fit'></span>

<h3>Description</h3>

<p>A function that combines useful information summarizing model fit.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>as.evoTS.multi.OU.fit(
  converge,
  modelName,
  logL,
  ancestral.values,
  SE.anc,
  optima,
  SE.optima,
  A,
  SE.A,
  half.life,
  R,
  SE.R,
  method,
  K,
  n,
  iter
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="as.evoTS.multi.OU.fit_+3A_converge">converge</code></td>
<td>
<p>info on model convergence</p>
</td></tr>
<tr><td><code id="as.evoTS.multi.OU.fit_+3A_modelname">modelName</code></td>
<td>
<p>description of the model</p>
</td></tr>
<tr><td><code id="as.evoTS.multi.OU.fit_+3A_logl">logL</code></td>
<td>
<p>log-likelihood of model</p>
</td></tr>
<tr><td><code id="as.evoTS.multi.OU.fit_+3A_ancestral.values">ancestral.values</code></td>
<td>
<p>maximum-likelihood estimates of the ancestral trait values</p>
</td></tr>
<tr><td><code id="as.evoTS.multi.OU.fit_+3A_se.anc">SE.anc</code></td>
<td>
<p>standard errors of the estimated ancestral states</p>
</td></tr>
<tr><td><code id="as.evoTS.multi.OU.fit_+3A_optima">optima</code></td>
<td>
<p>maximum-likelihood estimates of the optima</p>
</td></tr>
<tr><td><code id="as.evoTS.multi.OU.fit_+3A_se.optima">SE.optima</code></td>
<td>
<p>standard errors of the estimated optimal trait values</p>
</td></tr>
<tr><td><code id="as.evoTS.multi.OU.fit_+3A_a">A</code></td>
<td>
<p>maximum-likelihood estimates of the parameters in the A matrix</p>
</td></tr>
<tr><td><code id="as.evoTS.multi.OU.fit_+3A_se.a">SE.A</code></td>
<td>
<p>standard errors of the estimated A matrix</p>
</td></tr>
<tr><td><code id="as.evoTS.multi.OU.fit_+3A_half.life">half.life</code></td>
<td>
<p>the calculated half-life of the evolutionary process</p>
</td></tr>
<tr><td><code id="as.evoTS.multi.OU.fit_+3A_r">R</code></td>
<td>
<p>maximum-likelihood estimates of the parameters in the R matrix</p>
</td></tr>
<tr><td><code id="as.evoTS.multi.OU.fit_+3A_se.r">SE.R</code></td>
<td>
<p>standard errors of the parameters in the R matrix</p>
</td></tr>
<tr><td><code id="as.evoTS.multi.OU.fit_+3A_method">method</code></td>
<td>
<p>the parameterization used: Joint</p>
</td></tr>
<tr><td><code id="as.evoTS.multi.OU.fit_+3A_k">K</code></td>
<td>
<p>number of parameters in the model</p>
</td></tr>
<tr><td><code id="as.evoTS.multi.OU.fit_+3A_n">n</code></td>
<td>
<p>sample size</p>
</td></tr>
<tr><td><code id="as.evoTS.multi.OU.fit_+3A_iter">iter</code></td>
<td>
<p>the number of times the optimization method is run from different starting points. Default is NULL, meaning the optimization is run once.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is used by the model-fitting routines for the multivariate Ornstein-Uhlenbeck models to create standardized output
</p>


<h3>Note</h3>

<p>This function is not likely to be called directly by the user.
</p>


<h3>Author(s)</h3>

<p>Kjetil Lysne Voje
</p>

<hr>
<h2 id='as.evoTS.multi.URW.fit'>Class for fit to evolutionary sequence (time-series) models</h2><span id='topic+as.evoTS.multi.URW.fit'></span>

<h3>Description</h3>

<p>A function that combines useful information summarizing model fit.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>as.evoTS.multi.URW.fit(
  converge,
  modelName,
  logL,
  ancestral.values,
  SE.anc,
  R,
  SE.R,
  method,
  K,
  n,
  iter
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="as.evoTS.multi.URW.fit_+3A_converge">converge</code></td>
<td>
<p>info on model convergence</p>
</td></tr>
<tr><td><code id="as.evoTS.multi.URW.fit_+3A_modelname">modelName</code></td>
<td>
<p>description of the model</p>
</td></tr>
<tr><td><code id="as.evoTS.multi.URW.fit_+3A_logl">logL</code></td>
<td>
<p>log-likelihood of model</p>
</td></tr>
<tr><td><code id="as.evoTS.multi.URW.fit_+3A_ancestral.values">ancestral.values</code></td>
<td>
<p>maximum-likelihood estimates of the ancestral trait values</p>
</td></tr>
<tr><td><code id="as.evoTS.multi.URW.fit_+3A_se.anc">SE.anc</code></td>
<td>
<p>standard errors of the estimated ancestral states</p>
</td></tr>
<tr><td><code id="as.evoTS.multi.URW.fit_+3A_r">R</code></td>
<td>
<p>maximum-likelihood estimates of the parameters in the R matrix</p>
</td></tr>
<tr><td><code id="as.evoTS.multi.URW.fit_+3A_se.r">SE.R</code></td>
<td>
<p>standard errors of the parameters in the R matrix</p>
</td></tr>
<tr><td><code id="as.evoTS.multi.URW.fit_+3A_method">method</code></td>
<td>
<p>the parameterization used: Joint</p>
</td></tr>
<tr><td><code id="as.evoTS.multi.URW.fit_+3A_k">K</code></td>
<td>
<p>number of parameters in the model</p>
</td></tr>
<tr><td><code id="as.evoTS.multi.URW.fit_+3A_n">n</code></td>
<td>
<p>sample size</p>
</td></tr>
<tr><td><code id="as.evoTS.multi.URW.fit_+3A_iter">iter</code></td>
<td>
<p>the number of times the optimization method is run from different starting points. Default is NULL, meaning the optimization is run once.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is used by the model-fitting routines for the multivariate Unbiased Random Walk models to create standardized output
</p>


<h3>Note</h3>

<p>This function is not likely to be called directly by the user.
</p>


<h3>Author(s)</h3>

<p>Kjetil Lysne Voje
</p>

<hr>
<h2 id='as.evoTS.multi.URW.shift.fit'>Class for fit to evolutionary sequence (time-series) models</h2><span id='topic+as.evoTS.multi.URW.shift.fit'></span>

<h3>Description</h3>

<p>A function that combines useful information summarizing model fit.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>as.evoTS.multi.URW.shift.fit(
  converge,
  modelName,
  logL,
  ancestral.values,
  SE.anc,
  R,
  SE.R,
  shift.point,
  method,
  K,
  n,
  iter
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="as.evoTS.multi.URW.shift.fit_+3A_converge">converge</code></td>
<td>
<p>info on model convergence</p>
</td></tr>
<tr><td><code id="as.evoTS.multi.URW.shift.fit_+3A_modelname">modelName</code></td>
<td>
<p>description of the model</p>
</td></tr>
<tr><td><code id="as.evoTS.multi.URW.shift.fit_+3A_logl">logL</code></td>
<td>
<p>log-likelihood of model</p>
</td></tr>
<tr><td><code id="as.evoTS.multi.URW.shift.fit_+3A_ancestral.values">ancestral.values</code></td>
<td>
<p>maximum-likelihood estimates of the ancestral trait values</p>
</td></tr>
<tr><td><code id="as.evoTS.multi.URW.shift.fit_+3A_se.anc">SE.anc</code></td>
<td>
<p>standard errors of the estimated ancestral states</p>
</td></tr>
<tr><td><code id="as.evoTS.multi.URW.shift.fit_+3A_r">R</code></td>
<td>
<p>maximum-likelihood estimates of the parameters in the R matrix</p>
</td></tr>
<tr><td><code id="as.evoTS.multi.URW.shift.fit_+3A_se.r">SE.R</code></td>
<td>
<p>standard errors of the parameters in the R matrix</p>
</td></tr>
<tr><td><code id="as.evoTS.multi.URW.shift.fit_+3A_shift.point">shift.point</code></td>
<td>
<p>the sample in the time series that represents the first sample in the second segment.</p>
</td></tr>
<tr><td><code id="as.evoTS.multi.URW.shift.fit_+3A_method">method</code></td>
<td>
<p>the parameterization used: Joint</p>
</td></tr>
<tr><td><code id="as.evoTS.multi.URW.shift.fit_+3A_k">K</code></td>
<td>
<p>number of parameters in the model</p>
</td></tr>
<tr><td><code id="as.evoTS.multi.URW.shift.fit_+3A_n">n</code></td>
<td>
<p>sample size</p>
</td></tr>
<tr><td><code id="as.evoTS.multi.URW.shift.fit_+3A_iter">iter</code></td>
<td>
<p>the number of times the optimization method is run from different starting points. Default is NULL, meaning the optimization is run once.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is used by the model-fitting routines for the multivariate Unbiased Random Walk models to create standardized output
</p>


<h3>Note</h3>

<p>This function is not likely to be called directly by the user.
</p>


<h3>Author(s)</h3>

<p>Kjetil Lysne Voje
</p>

<hr>
<h2 id='as.evoTSfit.OUBM'>Class for fit to evolutionary sequence (time-series) models</h2><span id='topic+as.evoTSfit.OUBM'></span>

<h3>Description</h3>

<p>A function that combines useful information summarizing model fit.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>as.evoTSfit.OUBM(logL, parameters, modelName, method, K, n, se)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="as.evoTSfit.OUBM_+3A_logl">logL</code></td>
<td>
<p>log-likelihood of model</p>
</td></tr>
<tr><td><code id="as.evoTSfit.OUBM_+3A_parameters">parameters</code></td>
<td>
<p>maximum-likelihood estimates of the parameters</p>
</td></tr>
<tr><td><code id="as.evoTSfit.OUBM_+3A_modelname">modelName</code></td>
<td>
<p>description of the model</p>
</td></tr>
<tr><td><code id="as.evoTSfit.OUBM_+3A_method">method</code></td>
<td>
<p>the parameterization used: Joint</p>
</td></tr>
<tr><td><code id="as.evoTSfit.OUBM_+3A_k">K</code></td>
<td>
<p>number of parameters in the model</p>
</td></tr>
<tr><td><code id="as.evoTSfit.OUBM_+3A_n">n</code></td>
<td>
<p>sample size</p>
</td></tr>
<tr><td><code id="as.evoTSfit.OUBM_+3A_se">se</code></td>
<td>
<p>standard errors of parameter estimates</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is used by the model-fitting routines for the univariate Ornstein-Uhlenbeck model where the optimum evolves as an Unbiased Random Walk to create standardized output
</p>


<h3>Note</h3>

<p>This function is not likely to be called directly by the user.
</p>


<h3>Author(s)</h3>

<p>Kjetil Lysne Voje
</p>

<hr>
<h2 id='diameter_S.yellowstonensis'>Evolutionary sequence (time-series) of phenotypic change in diameter in the lineage Stephanodiscus yellowstonensis</h2><span id='topic+diameter_S.yellowstonensis'></span>

<h3>Description</h3>

<p>Phenotypic data (diameter) from a centric diatom lineage Stephanodiscus yellowstonensis. The time series spans about 14 000 years.
The data set contains data on valve diameter (measured in micrometres).
The data consists of an object of class paleoTS (diameter_S.yellowstonensis). Objects of class paleoTS can be analyzed in evoTS.
The object (trait data set) contains a vector of sample means (mm), sample variances (vv), sample sizes (nn) and sample ages (tt).
The oldest sample is listed first. The data spans an interval of 13728 years.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(diameter_S.yellowstonensis)
</code></pre>


<h3>Format</h3>

<p>An object of class <code>"paleoTS"</code>.
</p>


<h3>References</h3>

<p>Theriot et al. 2006. Late Quaternary rapid morphological evolution of an endemic diatom in Yellowstone Lake, Wyoming. Paleobiology 32:38-54
</p>


<h3>Examples</h3>

<pre><code class='language-R'>ln.diameter&lt;-paleoTS::ln.paleoTS(diameter_S.yellowstonensis)
ln.diameter$tt&lt;-ln.diameter$tt/(max(ln.diameter$tt))
opt.joint.decel(ln.diameter)
</code></pre>

<hr>
<h2 id='fit.all.univariate'>Fit all univariate models to an evolutionary sequence (time-series).</h2><span id='topic+fit.all.univariate'></span>

<h3>Description</h3>

<p>Wrapper function to find maximum likelihood solutions for all univariate models (excluding models with mode shifts) to an evolutionary sequence (time-series).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fit.all.univariate(y, pool = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="fit.all.univariate_+3A_y">y</code></td>
<td>
<p>an univariate paleoTS object.</p>
</td></tr>
<tr><td><code id="fit.all.univariate_+3A_pool">pool</code></td>
<td>
<p>indicating whether to pool variances across samples</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The function returns a list of all investigated models and their highest log-likelihood (and their corresponding AICc and AICc weight).
</p>


<h3>Author(s)</h3>

<p>Kjetil Lysne Voje
</p>


<h3>References</h3>

<p>Hunt, G. 2006. Fitting and comparing models of phyletic evolution: random walks and beyond. <em>Paleobiology</em> 32:578–601
</p>
<p>Hunt, G., Bell, M. A. &amp; Travis, M. P. Evolution towards a new adaptive optimum: Phenotypic evolution in a fossil stickleback lineage. <em>Evolution</em> 62:700–710 (2008)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## ##Generate a paleoTS object.
x &lt;- paleoTS::sim.GRW(30)

## Fit univariate models to the data.
fit.all.univariate(x, pool = TRUE)

</code></pre>

<hr>
<h2 id='fit.mode.shift'>Fit two models to two separate segments to an evolutionary sequence (time-series).</h2><span id='topic+fit.mode.shift'></span>

<h3>Description</h3>

<p>Wrapper function to find maximum likelihood solutions to two models to an evolutionary sequence.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fit.mode.shift(
  y,
  model1 = c("Stasis", "URW", "GRW", "OU"),
  model2 = c("Stasis", "URW", "GRW", "OU"),
  fit.all = FALSE,
  minb = 7,
  shift.point = NULL,
  pool = TRUE,
  silent = FALSE,
  hess = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="fit.mode.shift_+3A_y">y</code></td>
<td>
<p>an univariate evoTS object.</p>
</td></tr>
<tr><td><code id="fit.mode.shift_+3A_model1">model1</code></td>
<td>
<p>the model fitted to the first segment. Options are Stasis, URW, GRW, OU.</p>
</td></tr>
<tr><td><code id="fit.mode.shift_+3A_model2">model2</code></td>
<td>
<p>the model fitted to the second segment. Options are Stasis, URW, GRW, OU.</p>
</td></tr>
<tr><td><code id="fit.mode.shift_+3A_fit.all">fit.all</code></td>
<td>
<p>logical indicating whether to fit all pairwise combinations of the four models to the evolutionary sequence (time-series).</p>
</td></tr>
<tr><td><code id="fit.mode.shift_+3A_minb">minb</code></td>
<td>
<p>the minimum number of samples within a segment to consider</p>
</td></tr>
<tr><td><code id="fit.mode.shift_+3A_shift.point">shift.point</code></td>
<td>
<p>The sample that split the time-series into two segments. The samples are passed to the argument as a vector. Default is NULL, which means all possible shift points will be assessed constrained by how minb is defined.</p>
</td></tr>
<tr><td><code id="fit.mode.shift_+3A_pool">pool</code></td>
<td>
<p>logical indicating whether to pool variances across samples</p>
</td></tr>
<tr><td><code id="fit.mode.shift_+3A_silent">silent</code></td>
<td>
<p>if TRUE, less information is printed to the screen as the model is fit</p>
</td></tr>
<tr><td><code id="fit.mode.shift_+3A_hess">hess</code></td>
<td>
<p>logical, indicating whether to calculate standard errors from the Hessian matrix.
</p>
<p>#'</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the function  returns a list of all investigated models and their highest log-likelihood (and their corresponding AICc and AICc weight).
</p>
<table role = "presentation">
<tr><td><code>logL</code></td>
<td>
<p>the log-likelihood of the optimal solution</p>
</td></tr>
<tr><td><code>AICc</code></td>
<td>
<p>AIC with a correction for small sample sizes</p>
</td></tr>
<tr><td><code>parameters</code></td>
<td>
<p>parameter estimates</p>
</td></tr>
<tr><td><code>modelName</code></td>
<td>
<p>abbreviated model name</p>
</td></tr>
<tr><td><code>method</code></td>
<td>
<p>Joint consideration of all samples</p>
</td></tr>
<tr><td><code>K</code></td>
<td>
<p>number of parameters in the model</p>
</td></tr>
<tr><td><code>n</code></td>
<td>
<p>the number of observations/samples</p>
</td></tr>
<tr><td><code>all.logl</code></td>
<td>
<p>log-likelihoods for all tested partitions of the series into segments. Will return a single value if shift points have been given</p>
</td></tr>
<tr><td><code>GG</code></td>
<td>
<p>matrix of indices of initial samples of each tested segment configuration; each column of GG corresponds to the elements of all.logl</p>
</td></tr>
</table>
<p>In addition, if fit.all=TRUE the function also returns a list of all investigated models and their highest log-likelihood (and their corresponding AICc and AICc weight).
</p>


<h3>Note</h3>

<p>The models have been implemented to be compatible with the joint parameterization routine in the package paleoTS. The optimization is therefore fit using the actual sample values, with the autocorrelation among samples accounted for in the log-likelihood function. The joint distribution of sample means is multivariate normal, with means and variance-covariances determined by evolutionary parameters and sampling errors.
</p>


<h3>Author(s)</h3>

<p>Kjetil Lysne Voje
</p>


<h3>References</h3>

<p>Hunt, G. 2006. Fitting and comparing models of phyletic evolution: random walks and beyond. <em>Paleobiology</em> 32:578–601
</p>
<p>Hunt, G., Bell, M. A. &amp; Travis, M. P. Evolution towards a new adaptive optimum: Phenotypic evolution in a fossil stickleback lineage. <em>Evolution</em> 62:700–710 (2008)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
##Generate a paleoTS object.
x &lt;- paleoTS::sim.GRW(30)

## Fit a mode-shift model without defining a shift point (the example may take &gt; 5 seconds to run)
fit.mode.shift(x, model1="URW", model2="Stasis")
</code></pre>

<hr>
<h2 id='fit.multivariate.OU'>Fit predefined multivariate Ornstein-Uhlenbeck models to multivariate evolutionary sequence (time-series) data.</h2><span id='topic+fit.multivariate.OU'></span>

<h3>Description</h3>

<p>Function to find maximum likelihood solutions to a large suite of predefined multivariate Ornstein-Uhlenbeck model fitted to multivariate evolutionary sequence (time-series) data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fit.multivariate.OU(
  yy,
  A.matrix = "diag",
  R.matrix = "symmetric",
  method = "Nelder-Mead",
  hess = FALSE,
  pool = TRUE,
  trace = FALSE,
  iterations = NULL,
  iter.sd = NULL,
  user.init.diag.A = NULL,
  user.init.diag.R = NULL,
  user.init.off.diag.A = NULL,
  user.init.off.diag.R = NULL,
  user.init.theta = NULL,
  user.init.anc = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="fit.multivariate.OU_+3A_yy">yy</code></td>
<td>
<p>a multivariate evoTS object.</p>
</td></tr>
<tr><td><code id="fit.multivariate.OU_+3A_a.matrix">A.matrix</code></td>
<td>
<p>the pull matrix. The options are &quot;diag&quot;, &quot;upper.tri&quot;, &quot;lower.tri&quot;, and &quot;full&quot;. Default is &quot;diag&quot;. See details (or vignette) for more info on what the different options mean.</p>
</td></tr>
<tr><td><code id="fit.multivariate.OU_+3A_r.matrix">R.matrix</code></td>
<td>
<p>the drift matrix. The options are &quot;diag&quot; and &quot;symmetric&quot;.</p>
</td></tr>
<tr><td><code id="fit.multivariate.OU_+3A_method">method</code></td>
<td>
<p>optimization method, passed to function optim. Default is &quot;Nelder-Mead&quot;.</p>
</td></tr>
<tr><td><code id="fit.multivariate.OU_+3A_hess">hess</code></td>
<td>
<p>logical, indicating whether to calculate standard errors from the Hessian matrix.</p>
</td></tr>
<tr><td><code id="fit.multivariate.OU_+3A_pool">pool</code></td>
<td>
<p>indicating whether to pool variances across samples</p>
</td></tr>
<tr><td><code id="fit.multivariate.OU_+3A_trace">trace</code></td>
<td>
<p>logical, indicating whether information on the progress of the optimization is printed.</p>
</td></tr>
<tr><td><code id="fit.multivariate.OU_+3A_iterations">iterations</code></td>
<td>
<p>the number of times the optimization method is run from different starting points. Default is NULL, meaning the optimization is run once.</p>
</td></tr>
<tr><td><code id="fit.multivariate.OU_+3A_iter.sd">iter.sd</code></td>
<td>
<p>defines the standard deviation of the Gaussian distribution from which starting values for the optimization routine is run. Default is 1.</p>
</td></tr>
<tr><td><code id="fit.multivariate.OU_+3A_user.init.diag.a">user.init.diag.A</code></td>
<td>
<p>starting values for the optimization routine of the diagonal elements of the A matrix. Default is NULL.</p>
</td></tr>
<tr><td><code id="fit.multivariate.OU_+3A_user.init.diag.r">user.init.diag.R</code></td>
<td>
<p>starting values for the optimization routine of the diagonal elements of the R matrix. Default is NULL.</p>
</td></tr>
<tr><td><code id="fit.multivariate.OU_+3A_user.init.off.diag.a">user.init.off.diag.A</code></td>
<td>
<p>starting values for the optimization routine of the off-diagonal elements of the A matrix. Default is NULL.</p>
</td></tr>
<tr><td><code id="fit.multivariate.OU_+3A_user.init.off.diag.r">user.init.off.diag.R</code></td>
<td>
<p>starting values for the optimization routine of the off-diagonal elements of the R matrix. Default is NULL.</p>
</td></tr>
<tr><td><code id="fit.multivariate.OU_+3A_user.init.theta">user.init.theta</code></td>
<td>
<p>starting values for the optimization routine of the optima. Default is NULL.</p>
</td></tr>
<tr><td><code id="fit.multivariate.OU_+3A_user.init.anc">user.init.anc</code></td>
<td>
<p>starting values for the optimization routine of the ancestral values. Default is NULL.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A detailed explanation of the predefined models that can be fitted using the function is given in the online vignette (https://klvoje.github.io/evoTS/index.html), but a short summary is provided here. Note that this function provides the user with fixed options for how to parameterize the A and R matrices. For full flexibility, the user is allowed to customize the parameterization of the A and R matrix in the 'fit.multivariate.OU.user.defined' function.
The type of trait dynamics is defined based on how the pull matrix (A) and drift matrix (R) are defined. The function allows testing four broad categories of models: 1 Independent evolution (A.matrix =&quot;diag&quot;, R.matrix = &quot;diag&quot;); 2 Independent adaptation (A.matrix =&quot;diag&quot;, R.matrix = &quot;symmetric&quot;); 3 Non-independent adaptation (A.matrix = &quot;upper.tri&quot;/&quot;lower.tri&quot;/full&quot;, R.matrix = &quot;diagonal&quot;); 4 Non-independent evolution (A.matrix = &quot;upper.tri&quot;/&quot;lower.tri&quot;/&quot;full&quot;, R.matrix = &quot;symmetric&quot;).
Setting the A.matrix to &quot;diagonal&quot; means the traits do not affect each others optimum (A matrix). A &quot;diagonal&quot; R matrix means the stochastic changes in the traits are assumed to be uncorrelated. A &quot;symmetric&quot; R matrix means the stochastic changes in the traits are assumed to be correlated, i.e. that they are non-independent. A &quot;full&quot; parameterization of A estimates the effect of each trait on the optima on the other traits.
The &quot;upper.tri&quot; option parameterize the model in such a way that the first layer (first trait in the data set) adapts non-independently because its optimum is affected by all other traits included in the data set, while the bottom layer (the last trait in the data set) adapts independently (as an Ornstein Uhlenbeck process). Layers in between the upper- and lower layer (not the first or last trait in the data set (if there are more than two traits in the data set)) evolve non-independently as their optimum is affected by all layers/traits below themselves. The option &quot;lower.tri&quot; defines the causality the opposite way compared to &quot;upper.tri&quot;.
It is also possible to implement a model where the bottom layer (last trait in the data set) evolve as an Unbiased random walk (akin to a Brownian motion) which affects the optima for all other traits in the data set (i.e. all layers except the bottom layer). This model can be fitted by defining A.matrix =&quot;OUBM&quot;, which will override how the R matrix is defined.
</p>
<p>The function searches - using an optimization routine - for the maximum-likelihood solution for the chosen multivariate Ornstein-Uhlenbeck model. The argument 'method' is passed to the 'optim' function and is included for the convenience of users to better control the optimization routine. Note that the the default method (Nelder-Mead) seems to work for most evolutionary sequences. The method L-BFGS-B allows box-constraints on some parameters (e.g. non-negative variance parameters) and is faster than Nelder-Mead, but is less stable than the default method (Nelder-Mead).
</p>
<p>Initial estimates to start the optimization come from maximum-likelihood estimates of the univariate Ornstein-Uhlenbeck model (from the paleoTS package) fitted to each time-series separately.
</p>
<p>It is good practice to repeat any numerical optimization procedure from different starting points. This is especially important for complex models as the log-likelihood surface might contain more than one peak. The number of iterations is controlled by the argument 'iterations'. The function will report the model parameters from the iteration with the highest log-likelihood.
</p>
<p>There is no guarantee that the likelihood can be computed with the initial parameters provided by the function. The starting values for fitting the multivariate OU model are based on maximum likelihood parameter estimates for the univariate OU model fitted to each trait separately, which seems to provide sensible (and working) initial parameter estimates for almost all tested data sets. However, the provided initial parameters may fail depending on the nature of the data. If an error message is returned saying &quot;function cannot be evaluated at initial parameters&quot;, the user can try to start the optimization procedure from other initial parameter values using &quot;user.init.diag.A&quot;, &quot;user.init.diag.R&quot;, &quot;user.init.off.diag.A&quot;, &quot;user.init.off.diag.R&quot;, &quot;user.init.theta&quot;, and &quot;user.init.anc.&quot; It is usually the initial guess of the off-diagonal elements of the A and R matrices that prevents the optimization routine to work. It is therefore recommended to only try to change these initial values before experimenting with different starting values for the diagonal of the A and R matrices.
</p>


<h3>Value</h3>

<p>First part of the output reports the log-likelihood of the model and its AICc score. The second part of the output is the maximum log-likelihood model parameters (ancestral.values, optima, A, and R). The half-life is also provided, which is the  The last part of the output gives information about the number of parameters in the model (K), number of samples in the data (n) and number of times the optimization routine was run (iter).
</p>


<h3>Note</h3>

<p>The models have been implemented to be compatible with the joint parameterization routine in the package paleoTS. The optimization is therefore fit using the actual sample values, with the autocorrelation among samples accounted for in the log-likelihood function. The joint distribution of sample means is multivariate normal, with means and variance-covariances determined by evolutionary parameters and sampling errors.
</p>


<h3>Author(s)</h3>

<p>Kjetil Lysne Voje
</p>


<h3>References</h3>

<p>Reitan, T., Schweder, T. &amp; Henderiks, J. Phenotypic evolution studied by layered stochastic differential equations. <em>Ann Appl Statistics</em> 6, 1531–1551 (2012).
</p>
<p>Bartoszek, K., Pienaar, J., Mostad, P., Andersson, S. &amp; Hansen, T. F. A phylogenetic comparative method for studying multivariate adaptation. <em>J Theor Biol</em> 314, 204–215 (2012).
</p>
<p>Clavel, J., Escarguel, G. &amp; Merceron, G. mvmorph: an r package for fitting multivariate evolutionary models to morphometric data. <em>Methods Ecol Evol 6</em>, 1311–1319 (2015).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Generate a evoTS object by simulating a multivariate dataset
x &lt;- sim.multi.OU(15)


##Fit a multivariate Ornstein-Uhlenbeck model to the data. This example will run for a long time.
fit.multivariate.OU(x, A.matrix="diag", R.matrix="symmetric")

</code></pre>

<hr>
<h2 id='fit.multivariate.OU.user.defined'>Fit user-defined multivariate Ornstein-Uhlenbeck models to multivariate evolutionary sequence (time-series) data.</h2><span id='topic+fit.multivariate.OU.user.defined'></span>

<h3>Description</h3>

<p>Function to find maximum likelihood solutions to a multivariate Ornstein-Uhlenbeck model fitted using user-defined A and R matrices.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fit.multivariate.OU.user.defined(
  yy,
  A.user = NULL,
  R.user = NULL,
  method = "Nelder-Mead",
  hess = FALSE,
  pool = TRUE,
  trace = FALSE,
  iterations = NULL,
  iter.sd = NULL,
  user.init.diag.A = NULL,
  user.init.upper.diag.A = NULL,
  user.init.lower.diag.A = NULL,
  user.init.diag.R = NULL,
  user.init.off.diag.R = NULL,
  user.init.theta = NULL,
  user.init.anc = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="fit.multivariate.OU.user.defined_+3A_yy">yy</code></td>
<td>
<p>a multivariate evoTS object.</p>
</td></tr>
<tr><td><code id="fit.multivariate.OU.user.defined_+3A_a.user">A.user</code></td>
<td>
<p>the pull matrix. A user-defined A matrix.</p>
</td></tr>
<tr><td><code id="fit.multivariate.OU.user.defined_+3A_r.user">R.user</code></td>
<td>
<p>the drift matrix. A user-defined R matrix.</p>
</td></tr>
<tr><td><code id="fit.multivariate.OU.user.defined_+3A_method">method</code></td>
<td>
<p>optimization method, passed to function optim. Default is &quot;Nelder-Mead&quot;.</p>
</td></tr>
<tr><td><code id="fit.multivariate.OU.user.defined_+3A_hess">hess</code></td>
<td>
<p>logical, indicating whether to calculate standard errors from the Hessian matrix.</p>
</td></tr>
<tr><td><code id="fit.multivariate.OU.user.defined_+3A_pool">pool</code></td>
<td>
<p>indicating whether to pool variances across samples</p>
</td></tr>
<tr><td><code id="fit.multivariate.OU.user.defined_+3A_trace">trace</code></td>
<td>
<p>logical, indicating whether information on the progress of the optimization is printed.</p>
</td></tr>
<tr><td><code id="fit.multivariate.OU.user.defined_+3A_iterations">iterations</code></td>
<td>
<p>the number of times the optimization method is run from different starting points. Default is NULL, meaning the optimization is run once.</p>
</td></tr>
<tr><td><code id="fit.multivariate.OU.user.defined_+3A_iter.sd">iter.sd</code></td>
<td>
<p>defines the standard deviation of the Gaussian distribution from which starting values for the optimization routine is run. Default is 1.</p>
</td></tr>
<tr><td><code id="fit.multivariate.OU.user.defined_+3A_user.init.diag.a">user.init.diag.A</code></td>
<td>
<p>starting values for the optimization routine of the diagonal elements of the A matrix. Default is NULL.</p>
</td></tr>
<tr><td><code id="fit.multivariate.OU.user.defined_+3A_user.init.upper.diag.a">user.init.upper.diag.A</code></td>
<td>
<p>starting values for the optimization routine of the upper diagonal elements of the A matrix. Default is NULL.</p>
</td></tr>
<tr><td><code id="fit.multivariate.OU.user.defined_+3A_user.init.lower.diag.a">user.init.lower.diag.A</code></td>
<td>
<p>starting values for the optimization routine of the lower diagonal elements of the A matrix. Default is NULL.</p>
</td></tr>
<tr><td><code id="fit.multivariate.OU.user.defined_+3A_user.init.diag.r">user.init.diag.R</code></td>
<td>
<p>starting values for the optimization routine of the diagonal elements of the R matrix. Default is NULL.</p>
</td></tr>
<tr><td><code id="fit.multivariate.OU.user.defined_+3A_user.init.off.diag.r">user.init.off.diag.R</code></td>
<td>
<p>starting values for the optimization routine of the off-diagonal elements of the R matrix. Default is NULL.</p>
</td></tr>
<tr><td><code id="fit.multivariate.OU.user.defined_+3A_user.init.theta">user.init.theta</code></td>
<td>
<p>starting values for the optimization routine of the optima. Default is NULL.</p>
</td></tr>
<tr><td><code id="fit.multivariate.OU.user.defined_+3A_user.init.anc">user.init.anc</code></td>
<td>
<p>starting values for the optimization routine of the ancestral values. Default is NULL.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function provides users the flexibility to define their own A and R matrices. The possibility to define any A matrices enable detailed investigation of specific evolutionary hypotheses. The parameters to be estimated in the matrices are indicated by the value 1. All other entries in the matrix must be 0.
</p>
<p>The function searches - using an optimization routine - for the maximum-likelihood solution for the chosen multivariate Ornstein-Uhlenbeck model. The argument 'method' is passed to the 'optim' function and is included for the convenience of users to better control the optimization routine. Note that the the default method (Nelder-Mead) seems to work for most evolutionary sequences. The method L-BFGS-B allows box-constraints on some parameters (e.g. non-negative variance parameters) and is faster than Nelder-Mead, but is less stable than the default method (Nelder-Mead).
</p>
<p>Initial estimates to start the optimization come from maximum-likelihood estimates of the univariate Ornstein-Uhlenbeck model (from the paleoTS package) fitted to each time-series separately.
</p>
<p>It is good practice to repeat any numerical optimization procedure from different starting points. This is especially important for complex models as the log-likelihood surface might contain more than one peak. The number of iterations is controlled by the argument 'iterations'. The function will report the model parameters from the iteration with the highest log-likelihood.
</p>
<p>There is no guarantee that the likelihood can be computed with the initial parameters provided by the function. The starting values for fitting the multivariate OU model are based on maximum likelihood parameter estimates for the univariate OU model fitted to each trait separately, which seems to provide sensible (and working) initial parameter estimates for almost all tested data sets. However, the provided initial parameters may fail depending on the nature of the data. If an error message is returned saying &quot;function cannot be evaluated at initial parameters&quot;, the user can try to start the optimization procedure from other initial parameter values using &quot;user.init.diag.A&quot;, &quot;user.init.upper.diag.A&quot;, &quot;user.init.lower.diag.A&quot;, &quot;user.init.diag.R&quot;, &quot;user.init.off.diag.R&quot;, &quot;user.init.theta&quot;, and &quot;user.init.anc.&quot; It is usually the initial guess of the off-diagonal elements of the A and R matrices that prevents the optimization routine to work. It is therefore recommended to only try to change these initial values before experimenting with different starting values for the diagonal of the A and R matrices.
</p>


<h3>Value</h3>

<p>First part of the output reports the log-likelihood of the model and its AICc score. The second part of the output is the maximum log-likelihood model parameters (ancestral.values, optima, A, and R). The half-life is also provided, which is the  The last part of the output gives information about the number of parameters in the model (K), number of samples in the data (n) and number of times the optimization routine was run (iter).
</p>


<h3>Note</h3>

<p>The models have been implemented to be compatible with the joint parameterization routine in the package paleoTS. The optimization is therefore fit using the actual sample values, with the autocorrelation among samples accounted for in the log-likelihood function. The joint distribution of sample means is multivariate normal, with means and variance-covariances determined by evolutionary parameters and sampling errors.
</p>


<h3>Author(s)</h3>

<p>Kjetil Lysne Voje
</p>


<h3>References</h3>

<p>Reitan, T., Schweder, T. &amp; Henderiks, J. Phenotypic evolution studied by layered stochastic differential equations. <em>Ann Appl Statistics</em> 6, 1531–1551 (2012).
</p>
<p>Bartoszek, K., Pienaar, J., Mostad, P., Andersson, S. &amp; Hansen, T. F. A phylogenetic comparative method for studying multivariate adaptation. <em>J Theor Biol</em> 314, 204–215 (2012).
</p>
<p>Clavel, J., Escarguel, G. &amp; Merceron, G. mvmorph: an r package for fitting multivariate evolutionary models to morphometric data. <em>Methods Ecol Evol 6</em>, 1311–1319 (2015).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Generate a evoTS object by simulating a multivariate dataset
x &lt;- sim.multi.OU(15)

## Define an A matrix that is lower diagonal.
A &lt;- matrix(c(1,0,1,1), nrow=2, byrow=TRUE)

## Define a diagonal R matrix.
R &lt;- matrix(c(1,0,0,1), nrow=2, byrow=TRUE)


## Fit the multivariate Ornstein-Uhlenbeck model to the data. This example will run for a long time.
fit.multivariate.OU.user.defined(x, A.user=A, R.user=R, trace=TRUE)

</code></pre>

<hr>
<h2 id='fit.multivariate.URW'>Fit multivariate Unbiased Random Walk models to multivariate evolutionary sequence (time-series) data.</h2><span id='topic+fit.multivariate.URW'></span>

<h3>Description</h3>

<p>Function to find maximum likelihood solutions to a multivariate Unbiased Random Walk model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fit.multivariate.URW(
  yy,
  R = "symmetric",
  r = "fixed",
  method = "L-BFGS-B",
  hess = FALSE,
  pool = TRUE,
  trace = FALSE,
  iterations = NULL,
  iter.sd = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="fit.multivariate.URW_+3A_yy">yy</code></td>
<td>
<p>a multivariate evoTS object.</p>
</td></tr>
<tr><td><code id="fit.multivariate.URW_+3A_r">R</code></td>
<td>
<p>the drift matrix. The options are &quot;diagonal&quot; and &quot;symmetric&quot;</p>
</td></tr>
<tr><td><code id="fit.multivariate.URW_+3A_r">r</code></td>
<td>
<p>parameter describing the exponential increase/decrease in rate across time. The options are &quot;fixed&quot;, &quot;accel&quot; and &quot;decel&quot;.</p>
</td></tr>
<tr><td><code id="fit.multivariate.URW_+3A_method">method</code></td>
<td>
<p>optimization method, passed to function optim. Default is &quot;L-BFGS-B&quot;.</p>
</td></tr>
<tr><td><code id="fit.multivariate.URW_+3A_hess">hess</code></td>
<td>
<p>logical, indicating whether to calculate standard errors from the Hessian matrix.</p>
</td></tr>
<tr><td><code id="fit.multivariate.URW_+3A_pool">pool</code></td>
<td>
<p>indicating whether to pool variances across samples</p>
</td></tr>
<tr><td><code id="fit.multivariate.URW_+3A_trace">trace</code></td>
<td>
<p>logical, indicating whether information on the progress of the optimization is printed.</p>
</td></tr>
<tr><td><code id="fit.multivariate.URW_+3A_iterations">iterations</code></td>
<td>
<p>the number of times the optimization method is run from different starting points. Default is NULL, meaning the optimization is run once.</p>
</td></tr>
<tr><td><code id="fit.multivariate.URW_+3A_iter.sd">iter.sd</code></td>
<td>
<p>defines the standard deviation of the Gaussian distribution from which starting values for the optimization routine is run. Default is 1.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function allows the users to test six variants of multivariate Unbiased Random Walk models. There are two options for the structure of the R matrix. A &quot;diagonal&quot; R matrix means the stochastic changes in the traits are assumed to be uncorrelated. A &quot;symmetric&quot; R matrix means the stochastic changes in the traits are assumed to be correlated, i.e. that they are non-independent.
</p>
<p>There are three options for the 'r' parameter. The &quot;fixed&quot; option means there is no change in the rate of change across time (r = 0). Setting r to &quot;fixed&quot; therefore fits a regular multivariate Unbiased Random Walk. The &quot;decel&quot; and &quot;accel&quot; options make the rate of change (the R matrix) decay (r &lt; 0) and increase (r &gt; 0) exponentially through time, respectively.
</p>
<p>The function searches - using an optimization routine - for the maximum-likelihood solution for the chosen multivariate Unbiased Random Walk model. The argument 'method' is passed to the 'optim' function and is included for the convenience of users to better control the optimization routine. The the default method (L-BFGS-B) seems to work for most evolutionary sequences.
</p>
<p>Initial estimates to start the optimization come from maximum-likelihood estimates of the univariate Unbiased Random Walk model (from the paleoTS package) fitted to each time-series separately.
</p>
<p>It is good practice to repeat any numerical optimization procedure from different starting points. This is especially important for complex models as the log-likelihood surface might contain more than one peak. The number of iterations is controlled by the argument 'iterations'. The function will report the model parameters from the iteration with the highest log-likelihood.
</p>


<h3>Value</h3>

<p>First part of the output reports the log-likelihood of the model and its AICc score. The second part of the output is the maximum log-likelihood model parameters (ancestral.values, R). The last part of the output gives information about the number of parameters in the model (K), number of samples in the data (n) and number of times the optimization routine was run (iter).
</p>


<h3>Note</h3>

<p>The models have been implemented to be compatible with the joint parameterization routine in the package paleoTS. The optimization is therefore fit using the actual sample values, with the autocorrelation among samples accounted for in the log-likelihood function. The joint distribution of sample means is multivariate normal, with means and variance-covariances determined by evolutionary parameters and sampling errors.
</p>


<h3>Author(s)</h3>

<p>Kjetil Lysne Voje
</p>


<h3>References</h3>

<p>Revell, L. J. &amp; Harmon, L. Testing quantitative genetic hypotheses about the evolutionary rate matrix for continuous characters. <em>Evolutionary Ecology Research</em> 10, 311–331 (2008).
</p>
<p>Voje, K. L. Testing eco‐evolutionary predictions using fossil data: Phyletic evolution following ecological opportunity. <em>Evolution</em> 74, 188–200 (2020).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Generate an evoTS object by simulating a multivariate dataset
x &lt;- sim.multi.URW(30)

## Fit a multivariate Unbiased Random Walk model to the data, allowing for correlated changes.
fit.multivariate.URW(x, R = "symmetric", r = "fixed")

</code></pre>

<hr>
<h2 id='fit.multivariate.URW.shift'>Fit separate multivariate Unbiased Random Walk models to two different segments of a multivariate evolutionary sequence (time-series).</h2><span id='topic+fit.multivariate.URW.shift'></span>

<h3>Description</h3>

<p>Function to find maximum likelihood solutions for multivariate Unbiased Random Walk models fitted to two different segments of a multivariate evolutionary sequence (time-series).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fit.multivariate.URW.shift(
  yy,
  minb = 10,
  hess = FALSE,
  pool = TRUE,
  shift.point = NULL,
  method = "L-BFGS-B",
  trace = FALSE,
  iterations = NULL,
  iter.sd = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="fit.multivariate.URW.shift_+3A_yy">yy</code></td>
<td>
<p>a multivariate evoTS object.</p>
</td></tr>
<tr><td><code id="fit.multivariate.URW.shift_+3A_minb">minb</code></td>
<td>
<p>the minimum number of samples within a segment to consider.</p>
</td></tr>
<tr><td><code id="fit.multivariate.URW.shift_+3A_hess">hess</code></td>
<td>
<p>logical, indicating whether to calculate standard errors from the Hessian matrix.</p>
</td></tr>
<tr><td><code id="fit.multivariate.URW.shift_+3A_pool">pool</code></td>
<td>
<p>indicating whether to pool variances across samples</p>
</td></tr>
<tr><td><code id="fit.multivariate.URW.shift_+3A_shift.point">shift.point</code></td>
<td>
<p>the sample in the time series that represents the first sample in the second segment.</p>
</td></tr>
<tr><td><code id="fit.multivariate.URW.shift_+3A_method">method</code></td>
<td>
<p>optimization method, passed to function optim. Default is &quot;L-BFGS-B&quot;.</p>
</td></tr>
<tr><td><code id="fit.multivariate.URW.shift_+3A_trace">trace</code></td>
<td>
<p>logical, indicating whether information on the progress of the optimization is printed.</p>
</td></tr>
<tr><td><code id="fit.multivariate.URW.shift_+3A_iterations">iterations</code></td>
<td>
<p>the number of times the optimization method is run from different starting points. Default is NULL, meaning the optimization is run once.</p>
</td></tr>
<tr><td><code id="fit.multivariate.URW.shift_+3A_iter.sd">iter.sd</code></td>
<td>
<p>defines the standard deviation of the Gaussian distribution from which starting values for the optimization routine is run. Default is 1.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function searches - using an optimization routine - for the maximum-likelihood solution for a multivariate Unbiased Random Walk model ti two non-overlapping segments in the time series.
</p>
<p>The argument 'method' is passed to the 'optim' function and is included for the convenience of users to better control the optimization routine. The the default method (L-BFGS-B) seems to work for most evolutionary sequences.
</p>
<p>Initial estimates to start the optimization come from maximum-likelihood estimates of the univariate Unbiased Random Walk model (from the paleoTS package) fitted to each time-series separately.
</p>
<p>It is good practice to repeat any numerical optimization procedure from different starting points. This is especially important for complex models as the log-likelihood surface might contain more than one peak. The number of iterations is controlled by the argument 'iterations'. The function will report the model parameters from the iteration with the highest log-likelihood.
</p>


<h3>Value</h3>

<p>First part of the output reports the log-likelihood of the model and its AICc score. The second part of the output is the maximum log-likelihood model parameters (ancestral.values, R). The last part of the output gives information about the number of parameters in the model (K), number of samples in the data (n) and number of times the optimization routine was run (iter).
</p>


<h3>Note</h3>

<p>The models have been implemented to be compatible with the joint parameterization routine in the package paleoTS. The optimization is therefore fit using the actual sample values, with the autocorrelation among samples accounted for in the log-likelihood function. The joint distribution of sample means is multivariate normal, with means and variance-covariances determined by evolutionary parameters and sampling errors.
</p>


<h3>Author(s)</h3>

<p>Kjetil Lysne Voje
</p>


<h3>References</h3>

<p>Revell, L. J. &amp; Harmon, L. Testing quantitative genetic hypotheses about the evolutionary rate matrix for continuous characters. <em>Evolutionary Ecology Research</em> 10, 311–331 (2008).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Generate an evoTS object by simulating a multivariate dataset
x &lt;- sim.multi.URW(60)

## Fit two multivariate Unbiased Random Walk models to separate parts of the time-series.
fit.multivariate.URW.shift(x, shift.point = 31)
</code></pre>

<hr>
<h2 id='logL.joint.accel_decel'>Log-likelihoods for evolutionary models</h2><span id='topic+logL.joint.accel_decel'></span>

<h3>Description</h3>

<p>Returns log-likelihood for an Unbiased Random Walk with an accelerating or decelerating rate of change through time.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>logL.joint.accel_decel(p, y)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="logL.joint.accel_decel_+3A_p">p</code></td>
<td>
<p>parameters of the model to be optimized</p>
</td></tr>
<tr><td><code id="logL.joint.accel_decel_+3A_y">y</code></td>
<td>
<p>a paleoTS object</p>
</td></tr>
</table>


<h3>Details</h3>

<p>In general, users will not be access these functions directly, but instead use the optimization functions, which use these functions to find the best-supported parameter values.
</p>


<h3>Value</h3>

<p>The log-likelihood of the parameter estimates, given the data.
</p>


<h3>Author(s)</h3>

<p>Kjetil Lysne Voje
</p>

<hr>
<h2 id='logL.joint.accel.decel.single.R'>Log-likelihoods for evolutionary models</h2><span id='topic+logL.joint.accel.decel.single.R'></span>

<h3>Description</h3>

<p>Returns log-likelihood for a multivariate Unbiased Random Walk model with accelerating or decelerating rates of evolution through time.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>logL.joint.accel.decel.single.R(init.par, y, m, n, anc.values, yy)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="logL.joint.accel.decel.single.R_+3A_init.par">init.par</code></td>
<td>
<p>initial (starting) parameters values</p>
</td></tr>
<tr><td><code id="logL.joint.accel.decel.single.R_+3A_y">y</code></td>
<td>
<p>vector containing all trait values from all traits</p>
</td></tr>
<tr><td><code id="logL.joint.accel.decel.single.R_+3A_m">m</code></td>
<td>
<p>number of traits</p>
</td></tr>
<tr><td><code id="logL.joint.accel.decel.single.R_+3A_n">n</code></td>
<td>
<p>number of populations</p>
</td></tr>
<tr><td><code id="logL.joint.accel.decel.single.R_+3A_anc.values">anc.values</code></td>
<td>
<p>initial values for the ancestral trait values</p>
</td></tr>
<tr><td><code id="logL.joint.accel.decel.single.R_+3A_yy">yy</code></td>
<td>
<p>a multivariate evoTS object</p>
</td></tr>
</table>


<h3>Details</h3>

<p>In general, users will not be access these functions directly, but instead use the optimization functions, which use these functions to find the best-supported parameter values.
</p>


<h3>Value</h3>

<p>The log-likelihood of the parameter estimates, given the data.
</p>


<h3>Author(s)</h3>

<p>Kjetil Lysne Voje
</p>

<hr>
<h2 id='logL.joint.accel.decel.single.R.zero.corr'>Log-likelihoods for evolutionary models</h2><span id='topic+logL.joint.accel.decel.single.R.zero.corr'></span>

<h3>Description</h3>

<p>Returns log-likelihood for a multivariate Unbiased Random Walk model with uncorrelated changes and with accelerating or decelerating rates of evolution through time.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>logL.joint.accel.decel.single.R.zero.corr(init.par, y, m, n, anc.values, yy)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="logL.joint.accel.decel.single.R.zero.corr_+3A_init.par">init.par</code></td>
<td>
<p>initial (starting) parameters values</p>
</td></tr>
<tr><td><code id="logL.joint.accel.decel.single.R.zero.corr_+3A_y">y</code></td>
<td>
<p>vector containing all trait values from all traits</p>
</td></tr>
<tr><td><code id="logL.joint.accel.decel.single.R.zero.corr_+3A_m">m</code></td>
<td>
<p>number of traits</p>
</td></tr>
<tr><td><code id="logL.joint.accel.decel.single.R.zero.corr_+3A_n">n</code></td>
<td>
<p>number of populations</p>
</td></tr>
<tr><td><code id="logL.joint.accel.decel.single.R.zero.corr_+3A_anc.values">anc.values</code></td>
<td>
<p>initial values for the ancestral trait values</p>
</td></tr>
<tr><td><code id="logL.joint.accel.decel.single.R.zero.corr_+3A_yy">yy</code></td>
<td>
<p>a multivariate evoTS object</p>
</td></tr>
</table>


<h3>Details</h3>

<p>In general, users will not be access these functions directly, but instead use the optimization functions, which use these functions to find the best-supported parameter values.
</p>


<h3>Value</h3>

<p>The log-likelihood of the parameter estimates, given the data.
</p>


<h3>Author(s)</h3>

<p>Kjetil Lysne Voje
</p>

<hr>
<h2 id='logL.joint.multi.OUOU'>Log-likelihoods for evolutionary models</h2><span id='topic+logL.joint.multi.OUOU'></span>

<h3>Description</h3>

<p>Returns log-likelihood for a multivariate Ornstein-Uhlenbeck model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>logL.joint.multi.OUOU(init.par, yy, A.matrix, R.matrix)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="logL.joint.multi.OUOU_+3A_init.par">init.par</code></td>
<td>
<p>initial (starting) parameters values</p>
</td></tr>
<tr><td><code id="logL.joint.multi.OUOU_+3A_yy">yy</code></td>
<td>
<p>a multivariate evoTS object</p>
</td></tr>
<tr><td><code id="logL.joint.multi.OUOU_+3A_a.matrix">A.matrix</code></td>
<td>
<p>the pull matrix.</p>
</td></tr>
<tr><td><code id="logL.joint.multi.OUOU_+3A_r.matrix">R.matrix</code></td>
<td>
<p>the drift matrix..</p>
</td></tr>
</table>


<h3>Details</h3>

<p>In general, users will not be access these functions directly, but instead use the optimization functions, which use these functions to find the best-supported parameter values.
</p>


<h3>Value</h3>

<p>The log-likelihood of the parameter estimates, given the data.
</p>


<h3>Author(s)</h3>

<p>Kjetil Lysne Voje
</p>

<hr>
<h2 id='logL.joint.multi.OUOU.user'>Log-likelihoods for evolutionary models</h2><span id='topic+logL.joint.multi.OUOU.user'></span>

<h3>Description</h3>

<p>Returns log-likelihood for a multivariate Ornstein-Uhlenbeck model with used defined A and R matrices..
</p>


<h3>Usage</h3>

<pre><code class='language-R'>logL.joint.multi.OUOU.user(
  init.par,
  yy,
  A.user,
  R.user,
  locations.A,
  location.diag.A,
  location.upper.tri.A,
  location.lower.tri.A,
  locations.R,
  location.diag.R,
  location.upper.tri.R
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="logL.joint.multi.OUOU.user_+3A_init.par">init.par</code></td>
<td>
<p>initial (starting) parameters values</p>
</td></tr>
<tr><td><code id="logL.joint.multi.OUOU.user_+3A_yy">yy</code></td>
<td>
<p>a multivariate evoTS object</p>
</td></tr>
<tr><td><code id="logL.joint.multi.OUOU.user_+3A_a.user">A.user</code></td>
<td>
<p>the pull matrix.</p>
</td></tr>
<tr><td><code id="logL.joint.multi.OUOU.user_+3A_r.user">R.user</code></td>
<td>
<p>the drift matrix.</p>
</td></tr>
<tr><td><code id="logL.joint.multi.OUOU.user_+3A_locations.a">locations.A</code></td>
<td>
<p>location (row and column) of parameters (elements) in the A matrix that is estimated</p>
</td></tr>
<tr><td><code id="logL.joint.multi.OUOU.user_+3A_location.diag.a">location.diag.A</code></td>
<td>
<p>location (row and column) of parameters (elements) in the diagonal of the A matrix that is estimated</p>
</td></tr>
<tr><td><code id="logL.joint.multi.OUOU.user_+3A_location.upper.tri.a">location.upper.tri.A</code></td>
<td>
<p>location (row and column) of parameters (elements) in the upper triangle of the A matrix that is estimated</p>
</td></tr>
<tr><td><code id="logL.joint.multi.OUOU.user_+3A_location.lower.tri.a">location.lower.tri.A</code></td>
<td>
<p>location (row and column) of parameters (elements) in the lower triangle of the A matrix that is estimated</p>
</td></tr>
<tr><td><code id="logL.joint.multi.OUOU.user_+3A_locations.r">locations.R</code></td>
<td>
<p>location (row and column) of parameters (elements) in the R matrix that is estimated</p>
</td></tr>
<tr><td><code id="logL.joint.multi.OUOU.user_+3A_location.diag.r">location.diag.R</code></td>
<td>
<p>location (row and column) of parameters (elements) in the diagonal of the R matrix that is estimated</p>
</td></tr>
<tr><td><code id="logL.joint.multi.OUOU.user_+3A_location.upper.tri.r">location.upper.tri.R</code></td>
<td>
<p>location (row and column) of parameters (elements) in the upper triangle of the R matrix that is estimated</p>
</td></tr>
</table>


<h3>Details</h3>

<p>In general, users will not be access these functions directly, but instead use the optimization functions, which use these functions to find the best-supported parameter values.
</p>


<h3>Value</h3>

<p>The log-likelihood of the parameter estimates, given the data.
</p>


<h3>Author(s)</h3>

<p>Kjetil Lysne Voje
</p>

<hr>
<h2 id='logL.joint.multi.R'>Log-likelihoods for evolutionary models</h2><span id='topic+logL.joint.multi.R'></span>

<h3>Description</h3>

<p>Returns log-likelihood for a multivariate Unbiased Random Walk model fitted to separate segments of a multivariate time series.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>logL.joint.multi.R(init.par, C, y, m, n, anc.values, yy)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="logL.joint.multi.R_+3A_init.par">init.par</code></td>
<td>
<p>initial (starting) parameters values</p>
</td></tr>
<tr><td><code id="logL.joint.multi.R_+3A_c">C</code></td>
<td>
<p>distance matrix</p>
</td></tr>
<tr><td><code id="logL.joint.multi.R_+3A_y">y</code></td>
<td>
<p>vector containing all trait values from all traits</p>
</td></tr>
<tr><td><code id="logL.joint.multi.R_+3A_m">m</code></td>
<td>
<p>number of traits</p>
</td></tr>
<tr><td><code id="logL.joint.multi.R_+3A_n">n</code></td>
<td>
<p>number of populations</p>
</td></tr>
<tr><td><code id="logL.joint.multi.R_+3A_anc.values">anc.values</code></td>
<td>
<p>initial values for the ancestral trait values</p>
</td></tr>
<tr><td><code id="logL.joint.multi.R_+3A_yy">yy</code></td>
<td>
<p>a multivariate evoTS object</p>
</td></tr>
</table>


<h3>Details</h3>

<p>In general, users will not be access these functions directly, but instead use the optimization functions, which use these functions to find the best-supported parameter values.
</p>


<h3>Value</h3>

<p>The log-likelihood of the parameter estimates, given the data.
</p>


<h3>Author(s)</h3>

<p>Kjetil Lysne Voje
</p>

<hr>
<h2 id='logL.joint.OU.BM'>Log-likelihoods for evolutionary models</h2><span id='topic+logL.joint.OU.BM'></span>

<h3>Description</h3>

<p>Returns log-likelihood for an Ornstein-Uhlenbeck model where the optimum evolves as a Unbiased Random Walk. The movement of the optimum is not parameterized based on separate data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>logL.joint.OU.BM(p, y, opt.anc)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="logL.joint.OU.BM_+3A_p">p</code></td>
<td>
<p>parameters of the model to be optimized</p>
</td></tr>
<tr><td><code id="logL.joint.OU.BM_+3A_y">y</code></td>
<td>
<p>a paleoTS object</p>
</td></tr>
<tr><td><code id="logL.joint.OU.BM_+3A_opt.anc">opt.anc</code></td>
<td>
<p>logical, indicating if the ancestral trait value is at the optimum (TRUE) or displaced from the optimum (FALSE)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>In general, users will not be access these functions directly, but instead use the optimization functions, which use these functions to find the best-supported parameter values.
</p>


<h3>Value</h3>

<p>The log-likelihood of the parameter estimates, given the data.
</p>


<h3>Author(s)</h3>

<p>Kjetil Lysne Voje
</p>


<h3>References</h3>

<p>Hansen, T. F., Pienaar, J. &amp; Orzack, S. H. A Comparative Method for Studying Adaptation to a Randomly Evolving Environment. <em>Evolution</em> 62, 1965–1977 (2008).
</p>

<hr>
<h2 id='logL.joint.single.R'>Log-likelihoods for evolutionary models</h2><span id='topic+logL.joint.single.R'></span>

<h3>Description</h3>

<p>Returns log-likelihood for a multivariate Unbiased Random Walk model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>logL.joint.single.R(init.par, C, y, m, n, anc.values, yy)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="logL.joint.single.R_+3A_init.par">init.par</code></td>
<td>
<p>initial (starting) parameters values</p>
</td></tr>
<tr><td><code id="logL.joint.single.R_+3A_c">C</code></td>
<td>
<p>distance matrix</p>
</td></tr>
<tr><td><code id="logL.joint.single.R_+3A_y">y</code></td>
<td>
<p>vector containing all trait values from all traits</p>
</td></tr>
<tr><td><code id="logL.joint.single.R_+3A_m">m</code></td>
<td>
<p>number of traits</p>
</td></tr>
<tr><td><code id="logL.joint.single.R_+3A_n">n</code></td>
<td>
<p>number of populations</p>
</td></tr>
<tr><td><code id="logL.joint.single.R_+3A_anc.values">anc.values</code></td>
<td>
<p>initial values for the ancestral trait values</p>
</td></tr>
<tr><td><code id="logL.joint.single.R_+3A_yy">yy</code></td>
<td>
<p>a multivariate evoTS object</p>
</td></tr>
</table>


<h3>Details</h3>

<p>In general, users will not be access these functions directly, but instead use the optimization functions, which use these functions to find the best-supported parameter values.
</p>


<h3>Value</h3>

<p>The log-likelihood of the parameter estimates, given the data.
</p>


<h3>Author(s)</h3>

<p>Kjetil Lysne Voje
</p>

<hr>
<h2 id='logL.joint.single.R.zero.corr'>Log-likelihoods for evolutionary models</h2><span id='topic+logL.joint.single.R.zero.corr'></span>

<h3>Description</h3>

<p>Returns log-likelihood for a multivariate Unbiased Random Walk model with uncorrelated changes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>logL.joint.single.R.zero.corr(init.par, C, y, m, n, anc.values, yy)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="logL.joint.single.R.zero.corr_+3A_init.par">init.par</code></td>
<td>
<p>initial (starting) parameters values</p>
</td></tr>
<tr><td><code id="logL.joint.single.R.zero.corr_+3A_c">C</code></td>
<td>
<p>distance matrix</p>
</td></tr>
<tr><td><code id="logL.joint.single.R.zero.corr_+3A_y">y</code></td>
<td>
<p>vector containing all trait values from all traits</p>
</td></tr>
<tr><td><code id="logL.joint.single.R.zero.corr_+3A_m">m</code></td>
<td>
<p>number of traits</p>
</td></tr>
<tr><td><code id="logL.joint.single.R.zero.corr_+3A_n">n</code></td>
<td>
<p>number of populations</p>
</td></tr>
<tr><td><code id="logL.joint.single.R.zero.corr_+3A_anc.values">anc.values</code></td>
<td>
<p>initial values for the ancestral trait values</p>
</td></tr>
<tr><td><code id="logL.joint.single.R.zero.corr_+3A_yy">yy</code></td>
<td>
<p>a multivariate evoTS object</p>
</td></tr>
</table>


<h3>Details</h3>

<p>In general, users will not be access these functions directly, but instead use the optimization functions, which use these functions to find the best-supported parameter values.
</p>


<h3>Value</h3>

<p>The log-likelihood of the parameter estimates, given the data.
</p>


<h3>Author(s)</h3>

<p>Kjetil Lysne Voje
</p>

<hr>
<h2 id='logL.joint.Stasis.OU'>Log-likelihoods for evolutionary models</h2><span id='topic+logL.joint.Stasis.OU'></span>

<h3>Description</h3>

<p>Returns log-likelihood for a model with stasis in the first segment and an Ornstein-Uhlenbeck process in the second segment. .
</p>


<h3>Usage</h3>

<pre><code class='language-R'>logL.joint.Stasis.OU(p, y, gg)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="logL.joint.Stasis.OU_+3A_p">p</code></td>
<td>
<p>parameters of the model to be optimized</p>
</td></tr>
<tr><td><code id="logL.joint.Stasis.OU_+3A_y">y</code></td>
<td>
<p>a paleoTS object</p>
</td></tr>
<tr><td><code id="logL.joint.Stasis.OU_+3A_gg">gg</code></td>
<td>
<p>numeric vector indicating membership of each sample in a segment</p>
</td></tr>
</table>


<h3>Details</h3>

<p>In general, users will not be access these functions directly, but instead use the optimization functions, which use these functions to find the best-supported parameter values.
</p>


<h3>Value</h3>

<p>The log-likelihood of the parameter estimates, given the data.
</p>


<h3>Author(s)</h3>

<p>Kjetil Lysne Voje
</p>

<hr>
<h2 id='logL.joint.URW.URW'>Log-likelihoods for evolutionary models</h2><span id='topic+logL.joint.URW.URW'></span>

<h3>Description</h3>

<p>Returns log-likelihood for a model with an Unbiased Random Walk in the first segment and an Unbiased Random Walk in the second segment.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>logL.joint.URW.URW(p, y, gg)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="logL.joint.URW.URW_+3A_p">p</code></td>
<td>
<p>parameters of the model to be optimized</p>
</td></tr>
<tr><td><code id="logL.joint.URW.URW_+3A_y">y</code></td>
<td>
<p>a paleoTS object</p>
</td></tr>
<tr><td><code id="logL.joint.URW.URW_+3A_gg">gg</code></td>
<td>
<p>numeric vector indicating membership of each sample in a segment</p>
</td></tr>
</table>


<h3>Details</h3>

<p>In general, users will not access these functions directly, but instead use the optimization functions, which use these functions to find the best-supported parameter values.
</p>


<h3>Value</h3>

<p>The log-likelihood of the parameter estimates, given the data.
</p>


<h3>Author(s)</h3>

<p>Kjetil Lysne Voje
</p>

<hr>
<h2 id='loglik.surface.accel'>Calculate the log-likelihood surface for a part of parameter space</h2><span id='topic+loglik.surface.accel'></span>

<h3>Description</h3>

<p>Function to calculate the log-likelihood surface for a part of parameter space for an Unbiased Random Walk with an accelerated rate of evolution.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>loglik.surface.accel(y, vstep.vec, r.vec, pool = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="loglik.surface.accel_+3A_y">y</code></td>
<td>
<p>an univariate paleoTS object.</p>
</td></tr>
<tr><td><code id="loglik.surface.accel_+3A_vstep.vec">vstep.vec</code></td>
<td>
<p>vector containing the parameter values of the variance parameter to be evaluated</p>
</td></tr>
<tr><td><code id="loglik.surface.accel_+3A_r.vec">r.vec</code></td>
<td>
<p>vector containing the parameter values of the r parameter to be evaluated</p>
</td></tr>
<tr><td><code id="loglik.surface.accel_+3A_pool">pool</code></td>
<td>
<p>indicating whether to pool variances across samples</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the function returns the range of parameter values that are within two log-likelihood units from the best (maximum) parameter estimate and a log-likelihood surface.
</p>


<h3>Note</h3>

<p>How fine-scaled the estimated log-likelihood surface is depends on the step size between the values in the input-vectors. The step-size therefore determines how accurate the representation of the support surface is, including the returned upper and lower estimates printed in the console. The range of the input vectors needs to be increased if the confidence interval includes the boundary of the input vector. Note also that it might be wise to include the maximum likelihood estimates as part of the input vectors. The computed support surface is conditional on the best estimates of the other model parameters that are not part of the support surface (e.g. the estimated ancestral trait value).
</p>


<h3>Author(s)</h3>

<p>Kjetil Lysne Voje
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Generate a paleoTS objects
x &lt;- sim.accel.decel(50)

## Fit the model to the data.
x1&lt;-opt.joint.accel(x)


## Create log-likelihood surface (the example may take &gt; 5 seconds to run)
loglik.surface.accel(x, vstep.vec = seq(0,4,0.005), r.vec = seq(0.15,0.25,0.005))

</code></pre>

<hr>
<h2 id='loglik.surface.decel'>Calculate the log-likelihood surface for a part of parameter space</h2><span id='topic+loglik.surface.decel'></span>

<h3>Description</h3>

<p>Function to calculate the log-likelihood surface for a part of parameter space for an Unbiased Random Walk with an decelerated rate of evolution.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>loglik.surface.decel(y, vstep.vec, r.vec, pool = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="loglik.surface.decel_+3A_y">y</code></td>
<td>
<p>an univariate paleoTS object.</p>
</td></tr>
<tr><td><code id="loglik.surface.decel_+3A_vstep.vec">vstep.vec</code></td>
<td>
<p>vector containing the parameter values of the variance parameter to be evaluated</p>
</td></tr>
<tr><td><code id="loglik.surface.decel_+3A_r.vec">r.vec</code></td>
<td>
<p>vector containing the parameter values of the r parameter to be evaluated</p>
</td></tr>
<tr><td><code id="loglik.surface.decel_+3A_pool">pool</code></td>
<td>
<p>indicating whether to pool variances across samples</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the function returns the range of parameter values that are within two log-likelihood units from the best (maximum) parameter estimate and a log-likelihood surface.
</p>


<h3>Note</h3>

<p>How fine-scaled the estimated log-likelihood surface is depends on the step size between the values in the input-vectors. The step-size therefore determines how accurate the representation of the support surface is, including the returned upper and lower estimates printed in the console. The range of the input vectors needs to be increased if the confidence interval includes the boundary of the input vector. Note also that it might be wise to include the maximum likelihood estimates as part of the input vectors. The computed support surface is conditional on the best estimates of the other model parameters that are not part of the support surface (e.g. the estimated ancestral trait value).
</p>


<h3>Author(s)</h3>

<p>Kjetil Lysne Voje
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Generate a paleoTS objects
x &lt;- sim.accel.decel(30, r=-0.5)

## Fit the model to the data.
x1&lt;-opt.joint.decel(x)


## Create log-likelihood surface (the example may take &gt; 5 seconds to run)
loglik.surface.decel(x, vstep.vec = seq(0, 5, 0.1), r.vec = seq(-1, 0, 0.01))

</code></pre>

<hr>
<h2 id='loglik.surface.GRW'>Calculate the log-likelihood surface for a part of parameter space</h2><span id='topic+loglik.surface.GRW'></span>

<h3>Description</h3>

<p>Function to calculate the log-likelihood surface for a part of parameter space for a General Random Walk.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>loglik.surface.GRW(y, mstep.vec, vstep.vec, pool = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="loglik.surface.GRW_+3A_y">y</code></td>
<td>
<p>an univariate paleoTS object.</p>
</td></tr>
<tr><td><code id="loglik.surface.GRW_+3A_mstep.vec">mstep.vec</code></td>
<td>
<p>vector containing the parameter values of the mstep parameter to be evaluated</p>
</td></tr>
<tr><td><code id="loglik.surface.GRW_+3A_vstep.vec">vstep.vec</code></td>
<td>
<p>vector containing the parameter values of the variance parameter to be evaluated</p>
</td></tr>
<tr><td><code id="loglik.surface.GRW_+3A_pool">pool</code></td>
<td>
<p>indicating whether to pool variances across samples</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the function returns the range of parameter values that are within two log-likelihood units from the best (maximum) parameter estimate and a log-likelihood surface.
</p>


<h3>Note</h3>

<p>How fine-scaled the estimated log-likelihood surface is depends on the step size between the values in the input-vectors. The step-size therefore determines how accurate the representation of the support surface is, including the returned upper and lower estimates printed in the console. The range of the input vectors needs to be increased if the confidence interval includes the boundary of the input vector. Note also that it might be wise to include the maximum likelihood estimates as part of the input vectors. The computed support surface is conditional on the best estimates of the other model parameters that are not part of the support surface (e.g. the estimated ancestral trait value).
</p>


<h3>Author(s)</h3>

<p>Kjetil Lysne Voje
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Generate a paleoTS objects
x &lt;- paleoTS::sim.GRW(30)

## Fit the the model to the data.
x1&lt;-paleoTS::opt.joint.GRW(x)


## Create log-likelihood surface (the example may take &gt; 5 seconds to run)
loglik.surface.GRW(x, mstep.vec= seq(0,0.3,0.01), vstep.vec = seq(0,0.3,0.01))

</code></pre>

<hr>
<h2 id='loglik.surface.OU'>Calculate the log-likelihood surface for a part of parameter space</h2><span id='topic+loglik.surface.OU'></span>

<h3>Description</h3>

<p>Function to calculate the log-likelihood surface for a part of parameter space for a Ornstein-Uhlenbeck model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>loglik.surface.OU(
  y,
  stat.var.vec,
  h.vec,
  anc = NULL,
  theta = NULL,
  pool = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="loglik.surface.OU_+3A_y">y</code></td>
<td>
<p>an univariate paleoTS object.</p>
</td></tr>
<tr><td><code id="loglik.surface.OU_+3A_stat.var.vec">stat.var.vec</code></td>
<td>
<p>vector containing the parameter values of the stationary variance to be evaluated</p>
</td></tr>
<tr><td><code id="loglik.surface.OU_+3A_h.vec">h.vec</code></td>
<td>
<p>vector containing the parameter values of the half life to be evaluated</p>
</td></tr>
<tr><td><code id="loglik.surface.OU_+3A_anc">anc</code></td>
<td>
<p>the ancestral state</p>
</td></tr>
<tr><td><code id="loglik.surface.OU_+3A_theta">theta</code></td>
<td>
<p>the optimum</p>
</td></tr>
<tr><td><code id="loglik.surface.OU_+3A_pool">pool</code></td>
<td>
<p>indicating whether to pool variances across samples</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the function returns the range of parameter values that are within two log-likelihood units from the best (maximum) parameter estimate and a log-likelihood surface.
</p>


<h3>Note</h3>

<p>How fine-scaled the estimated log-likelihood surface is depends on the step size between the values in the input-vectors. The step-size therefore determines how accurate the representation of the support surface is, including the returned upper and lower estimates printed in the console. The range of the input vectors needs to be increased if the confidence interval includes the boundary of the input vector. Note also that it might be wise to include the maximum likelihood estimates as part of the input vectors. The computed support surface is conditional on the best estimates of the other model parameters that are not part of the support surface (e.g. the estimated ancestral trait value).
</p>


<h3>Author(s)</h3>

<p>Kjetil Lysne Voje
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Generate a paleoTS objects
x &lt;- paleoTS::sim.OU(40)

## Fit the model to the data.
x1&lt;-paleoTS::opt.joint.OU(x)

##calculate half-life from model output
log(2)/x1$parameters[4]

##calculate stationary variance from model output
x1$parameters[2]/(2*x1$parameters[4])


## Create log-likelihood surface (the example may take &gt; 5 seconds to run)
loglik.surface.OU(x, stat.var.vec=seq(0.001,0.5,0.01), h.vec=seq(0.01,10, 0.1))

</code></pre>

<hr>
<h2 id='loglik.surface.OUBM'>Calculate the log-likelihood surface for a part of parameter space</h2><span id='topic+loglik.surface.OUBM'></span>

<h3>Description</h3>

<p>Function to calculate the log-likelihood surface for a part of parameter space for a Ornstein-Uhlenbeck model where the optimum changes according to an Unbiased Random Walk.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>loglik.surface.OUBM(
  y,
  stat.var.vec,
  h.vec,
  anc = NULL,
  theta.0 = NULL,
  vo = NULL,
  opt.anc = TRUE,
  pool = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="loglik.surface.OUBM_+3A_y">y</code></td>
<td>
<p>an univariate paleoTS object.</p>
</td></tr>
<tr><td><code id="loglik.surface.OUBM_+3A_stat.var.vec">stat.var.vec</code></td>
<td>
<p>vector containing the parameter values of the stationary variance to be evaluated</p>
</td></tr>
<tr><td><code id="loglik.surface.OUBM_+3A_h.vec">h.vec</code></td>
<td>
<p>vector containing the parameter values of the half life to be evaluated</p>
</td></tr>
<tr><td><code id="loglik.surface.OUBM_+3A_anc">anc</code></td>
<td>
<p>the ancestral state</p>
</td></tr>
<tr><td><code id="loglik.surface.OUBM_+3A_theta.0">theta.0</code></td>
<td>
<p>the optimum</p>
</td></tr>
<tr><td><code id="loglik.surface.OUBM_+3A_vo">vo</code></td>
<td>
<p>the variance (vstep) parameter for the optimum</p>
</td></tr>
<tr><td><code id="loglik.surface.OUBM_+3A_opt.anc">opt.anc</code></td>
<td>
<p>logical, indicating whether the the ancestral trait state is at the optimum.</p>
</td></tr>
<tr><td><code id="loglik.surface.OUBM_+3A_pool">pool</code></td>
<td>
<p>indicating whether to pool variances across samples</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the function returns the range of parameter values that are within two log-likelihood units from the best (maximum) parameter estimate and a log-likelihood surface.
</p>


<h3>Note</h3>

<p>How fine-scaled the estimated log-likelihood surface is depends on the step size between the values in the input-vectors. The step-size therefore determines how accurate the representation of the support surface is, including the returned upper and lower estimates printed in the console. The range of the input vectors needs to be increased if the confidence interval includes the boundary of the input vector. Note also that it might be wise to include the maximum likelihood estimates as part of the input vectors. The computed support surface is conditional on the best estimates of the other model parameters that are not part of the support surface (e.g. the estimated ancestral trait value).
</p>


<h3>Author(s)</h3>

<p>Kjetil Lysne Voje
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Generate a paleoTS objects
x &lt;- sim.OUBM(40)

## Fit the model.
x1&lt;-opt.joint.OUBM(x)

##calculate half-life from model output
log(2)/x1$parameters[3]

##calculate stationary variance from model output
x1$parameters[2]/(2*x1$parameters[3])


## Create log-likelihood surface (the example may take &gt; 5 seconds to run)
loglik.surface.OUBM(x, stat.var.vec=seq(0,4,0.01), h.vec=seq(0.0,5, 0.1))

</code></pre>

<hr>
<h2 id='loglik.surface.stasis'>Calculate the log-likelihood surface for a part of parameter space</h2><span id='topic+loglik.surface.stasis'></span>

<h3>Description</h3>

<p>Function to calculate the log-likelihood surface for a part of parameter space for the Stasis model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>loglik.surface.stasis(y, theta.vec, omega.vec, pool = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="loglik.surface.stasis_+3A_y">y</code></td>
<td>
<p>an univariate paleoTS object.</p>
</td></tr>
<tr><td><code id="loglik.surface.stasis_+3A_theta.vec">theta.vec</code></td>
<td>
<p>vector containing the parameter values of the theta parameter to be evaluated</p>
</td></tr>
<tr><td><code id="loglik.surface.stasis_+3A_omega.vec">omega.vec</code></td>
<td>
<p>vector containing the parameter values of the omega parameter to be evaluated</p>
</td></tr>
<tr><td><code id="loglik.surface.stasis_+3A_pool">pool</code></td>
<td>
<p>indicating whether to pool variances across samples</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the function returns the range of parameter values that are within two log-likelihood units from the best (maximum) parameter estimate and a log-likelihood surface.
</p>


<h3>Note</h3>

<p>How fine-scaled the estimated log-likelihood surface is depends on the step size between the values in the input-vectors. The step-size therefore determines how accurate the representation of the support surface is, including the returned upper and lower estimates printed in the console. The range of the input vectors needs to be increased if the confidence interval includes the boundary of the input vector. Note also that it might be wise to include the maximum likelihood estimates as part of the input vectors. The computed support surface is conditional on the best estimates of the other model parameters that are not part of the support surface (e.g. the estimated ancestral trait value).
</p>


<h3>Author(s)</h3>

<p>Kjetil Lysne Voje
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Generate a paleoTS objects
x &lt;- paleoTS::sim.Stasis(30)

## Fit the the model to the data.
x1&lt;-paleoTS::opt.joint.Stasis(x)


## Create log-likelihood surface (the example may take &gt; 5 seconds to run)
loglik.surface.stasis(x, theta.vec= seq(-0.15,0.1,0.001), omega.vec = seq(0,0.1,0.001))

</code></pre>

<hr>
<h2 id='loglik.surface.URW'>Calculate the log-likelihood surface for a part of parameter space</h2><span id='topic+loglik.surface.URW'></span>

<h3>Description</h3>

<p>Function to calculate the log-likelihood surface for a part of parameter space for a Unbiased Random Walk.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>loglik.surface.URW(y, vstep.vec, pool = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="loglik.surface.URW_+3A_y">y</code></td>
<td>
<p>an univariate paleoTS object.</p>
</td></tr>
<tr><td><code id="loglik.surface.URW_+3A_vstep.vec">vstep.vec</code></td>
<td>
<p>vector containing the parameter values of the variance parameter to be evaluated</p>
</td></tr>
<tr><td><code id="loglik.surface.URW_+3A_pool">pool</code></td>
<td>
<p>indicating whether to pool variances across samples</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the function returns the range of parameter values that are within two log-likelihood units from the best (maximum) parameter estimate and a log-likelihood surface.
</p>


<h3>Note</h3>

<p>How fine-scaled the estimated log-likelihood surface is depends on the step size between the values in the input-vectors. The step-size therefore determines how accurate the representation of the support surface is, including the returned upper and lower estimates printed in the console. The range of the input vectors needs to be increased if the confidence interval includes the boundary of the input vector. Note also that it might be wise to include the maximum likelihood estimates as part of the input vectors. The computed support surface is conditional on the best estimates of the other model parameters that are not part of the support surface (e.g. the estimated ancestral trait value).
</p>


<h3>Author(s)</h3>

<p>Kjetil Lysne Voje
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Generate a paleoTS objects
x &lt;- paleoTS::sim.GRW(30)

## Fit a the model to the data by defining shift points.
x1&lt;-paleoTS::opt.joint.URW(x)

## Create log-likelihood surface (the example may take &gt; 5 seconds to run)
loglik.surface.URW(x, vstep.vec = seq(0,0.5,0.001))

</code></pre>

<hr>
<h2 id='make.multivar.evoTS'>Makes a multivariate data set of</h2><span id='topic+make.multivar.evoTS'></span>

<h3>Description</h3>

<p>Function to make a multivariate data set consisting of two or more evolutionary sequences (time-series).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>make.multivar.evoTS(
  evoTS.1 = NULL,
  evoTS.2 = NULL,
  evoTS.3 = NULL,
  evoTS.4 = NULL,
  evoTS.5 = NULL,
  evoTS.6 = NULL,
  evoTS.7 = NULL,
  evoTS.8 = NULL,
  evoTS.9 = NULL,
  evoTS.10 = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="make.multivar.evoTS_+3A_evots.1">evoTS.1</code></td>
<td>
<p>an univariate evolutionary sequences (time-series) on the format used in paleoTS</p>
</td></tr>
<tr><td><code id="make.multivar.evoTS_+3A_evots.2">evoTS.2</code></td>
<td>
<p>an univariate evolutionary sequences (time-series) on the format used in paleoTS</p>
</td></tr>
<tr><td><code id="make.multivar.evoTS_+3A_evots.3">evoTS.3</code></td>
<td>
<p>an univariate evolutionary sequences (time-series) on the format used in paleoTS (optional)</p>
</td></tr>
<tr><td><code id="make.multivar.evoTS_+3A_evots.4">evoTS.4</code></td>
<td>
<p>an univariate evolutionary sequences (time-series) on the format used in paleoTS (optional)</p>
</td></tr>
<tr><td><code id="make.multivar.evoTS_+3A_evots.5">evoTS.5</code></td>
<td>
<p>an univariate evolutionary sequences (time-series) on the format used in paleoTS (optional)</p>
</td></tr>
<tr><td><code id="make.multivar.evoTS_+3A_evots.6">evoTS.6</code></td>
<td>
<p>an univariate evolutionary sequences (time-series) on the format used in paleoTS (optional)</p>
</td></tr>
<tr><td><code id="make.multivar.evoTS_+3A_evots.7">evoTS.7</code></td>
<td>
<p>an univariate evolutionary sequences (time-series) on the format used in paleoTS (optional)</p>
</td></tr>
<tr><td><code id="make.multivar.evoTS_+3A_evots.8">evoTS.8</code></td>
<td>
<p>an univariate evolutionary sequences (time-series) on the format used in paleoTS (optional)</p>
</td></tr>
<tr><td><code id="make.multivar.evoTS_+3A_evots.9">evoTS.9</code></td>
<td>
<p>an univariate evolutionary sequences (time-series) on the format used in paleoTS (optional)</p>
</td></tr>
<tr><td><code id="make.multivar.evoTS_+3A_evots.10">evoTS.10</code></td>
<td>
<p>an univariate evolutionary sequences (time-series) on the format used in paleoTS (optional)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>See the function as.paleoTS for details. See also read.paleoTS, which is often a more convenient way for getting the relevant data from text files.
</p>


<h3>Value</h3>

<p>a multivariate evoTS object that can be analysed with functions fitting multivariate models (e.g. fit.multivariate.OU, fit.multivariate.URW)
</p>


<h3>Author(s)</h3>

<p>Kjetil Lysne Voje
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Generate two evolutionary sequences (time-series)
x1 &lt;- paleoTS::sim.GRW(60)
x2 &lt;- paleoTS::sim.GRW(60)


## Make a multivariate data set
x1_x2&lt;-make.multivar.evoTS(x1, x2)

</code></pre>

<hr>
<h2 id='opt.accel.single.R'>Fit multivariate Unbiased Random Walk with increasing (exponential accelerating) rate of change through time.</h2><span id='topic+opt.accel.single.R'></span>

<h3>Description</h3>

<p>Function to find maximum likelihood solution to a multivariate Unbiased Random Walk model with increasing (exponential accelerating) rate of change through time.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>opt.accel.single.R(
  yy,
  method = "L-BFGS-B",
  hess = FALSE,
  pool = TRUE,
  trace = FALSE,
  iterations = NULL,
  iter.sd = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="opt.accel.single.R_+3A_yy">yy</code></td>
<td>
<p>a multivariate evoTS object.</p>
</td></tr>
<tr><td><code id="opt.accel.single.R_+3A_method">method</code></td>
<td>
<p>optimization method, passed to function optim. Default is &quot;L-BFGS-B&quot;.</p>
</td></tr>
<tr><td><code id="opt.accel.single.R_+3A_hess">hess</code></td>
<td>
<p>logical, indicating whether to calculate standard errors from the Hessian matrix.</p>
</td></tr>
<tr><td><code id="opt.accel.single.R_+3A_pool">pool</code></td>
<td>
<p>indicating whether to pool variances across samples</p>
</td></tr>
<tr><td><code id="opt.accel.single.R_+3A_trace">trace</code></td>
<td>
<p>logical, indicating whether information on the progress of the optimization is printed.</p>
</td></tr>
<tr><td><code id="opt.accel.single.R_+3A_iterations">iterations</code></td>
<td>
<p>the number of times the optimization method is run from different starting points. Default is NULL, meaning the optimization is run once.</p>
</td></tr>
<tr><td><code id="opt.accel.single.R_+3A_iter.sd">iter.sd</code></td>
<td>
<p>defines the standard deviation of the Gaussian distribution from which starting values for the optimization routine is run. Default is 1.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function searches - using an optimization routine - for the maximum-likelihood solution for a multivariate Unbiased Random Walk model with increasing (exponential accelerating) rate of change through time.
</p>
<p>The argument 'method' is passed to the 'optim' function and is included for the convenience of users to better control the optimization routine. The the default method (L-BFGS-B) seems to work for most evolutionary sequences.
</p>
<p>Initial estimates to start the optimization come from maximum-likelihood estimates of the univariate Unbiased Random Walk model (from the paleoTS package) fitted to each time-series separately. The starting value for r = 1.
</p>
<p>It is good practice to repeat any numerical optimization procedure from different starting points. This is especially important for complex models as the log-likelihood surface might contain more than one peak. The number of iterations is controlled by the argument 'iterations'. The function will report the model parameters from the iteration with the highest log-likelihood.
</p>


<h3>Value</h3>

<p>First part of the output reports the log-likelihood of the model and its AICc score. The second part of the output is the maximum log-likelihood model parameters (ancestral.values, R, r). The last part of the output gives information about the number of parameters in the model (K), number of samples in the data (n) and number of times the optimization routine was run (iter).
</p>


<h3>Note</h3>

<p>The models have been implemented to be compatible with the joint parameterization routine in the package paleoTS. The optimization is therefore fit using the actual sample values, with the autocorrelation among samples accounted for in the log-likelihood function. The joint distribution of sample means is multivariate normal, with means and variance-covariances determined by evolutionary parameters and sampling errors.
</p>


<h3>Author(s)</h3>

<p>Kjetil Lysne Voje
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Generate an evoTS object by simulating a multivariate dataset
indata &lt;- sim.multi.URW(60)

## Fit a multivariate Unbiased Random Walk with an increasing rate of change through time.
opt.accel.single.R(indata)

</code></pre>

<hr>
<h2 id='opt.accel.single.R.zero.corr'>Fit multivariate Unbiased Random Walk model with uncorrelated trait changes and with increasing (exponential accelerating) rate of change through time.</h2><span id='topic+opt.accel.single.R.zero.corr'></span>

<h3>Description</h3>

<p>Function to find maximum likelihood solution to a multivariate Unbiased Random Walk model with uncorrelated trait changes and with increasing (exponential accelerating) rate of change through time.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>opt.accel.single.R.zero.corr(
  yy,
  method = "L-BFGS-B",
  hess = FALSE,
  pool = TRUE,
  trace = FALSE,
  iterations = NULL,
  iter.sd = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="opt.accel.single.R.zero.corr_+3A_yy">yy</code></td>
<td>
<p>a multivariate evoTS object.</p>
</td></tr>
<tr><td><code id="opt.accel.single.R.zero.corr_+3A_method">method</code></td>
<td>
<p>optimization method, passed to function optim. Default is &quot;L-BFGS-B&quot;.</p>
</td></tr>
<tr><td><code id="opt.accel.single.R.zero.corr_+3A_hess">hess</code></td>
<td>
<p>logical, indicating whether to calculate standard errors from the Hessian matrix.</p>
</td></tr>
<tr><td><code id="opt.accel.single.R.zero.corr_+3A_pool">pool</code></td>
<td>
<p>indicating whether to pool variances across samples</p>
</td></tr>
<tr><td><code id="opt.accel.single.R.zero.corr_+3A_trace">trace</code></td>
<td>
<p>logical, indicating whether information on the progress of the optimization is printed.</p>
</td></tr>
<tr><td><code id="opt.accel.single.R.zero.corr_+3A_iterations">iterations</code></td>
<td>
<p>the number of times the optimization method is run from different starting points. Default is NULL, meaning the optimization is run once.</p>
</td></tr>
<tr><td><code id="opt.accel.single.R.zero.corr_+3A_iter.sd">iter.sd</code></td>
<td>
<p>defines the standard deviation of the Gaussian distribution from which starting values for the optimization routine is run. Default is 1.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function searches - using an optimization routine - for the maximum-likelihood solution for a multivariate Unbiased Random Walk model with uncorrelated trait changes and with increasing (exponential accelerating) rate of change through time.
</p>
<p>The argument 'method' is passed to the 'optim' function and is included for the convenience of users to better control the optimization routine. The the default method (L-BFGS-B) seems to work for most evolutionary sequences.
</p>
<p>Initial estimates to start the optimization come from maximum-likelihood estimates of the univariate Unbiased Random Walk model (from the paleoTS package) fitted to each time-series separately. The starting value for r = 1.
</p>
<p>It is good practice to repeat any numerical optimization procedure from different starting points. This is especially important for complex models as the log-likelihood surface might contain more than one peak. The number of iterations is controlled by the argument 'iterations'. The function will report the model parameters from the iteration with the highest log-likelihood.
</p>


<h3>Value</h3>

<p>First part of the output reports the log-likelihood of the model and its AICc score. The second part of the output is the maximum log-likelihood model parameters (ancestral.values, R, r). The last part of the output gives information about the number of parameters in the model (K), number of samples in the data (n) and number of times the optimization routine was run (iter).
</p>


<h3>Note</h3>

<p>The models have been implemented to be compatible with the joint parameterization routine in the package paleoTS. The optimization is therefore fit using the actual sample values, with the autocorrelation among samples accounted for in the log-likelihood function. The joint distribution of sample means is multivariate normal, with means and variance-covariances determined by evolutionary parameters and sampling errors.
</p>


<h3>Author(s)</h3>

<p>Kjetil Lysne Voje
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Generate an evoTS object by simulating a multivariate dataset
x &lt;- sim.multi.URW(30)

## Fit a multivariate Unbiased Random Walk model with an increasing rate of change through time.
opt.accel.single.R.zero.corr(x)
</code></pre>

<hr>
<h2 id='opt.decel.single.R'>Fit multivariate Unbiased Random Walk with decreasing (exponential decaying) rate of change through time.</h2><span id='topic+opt.decel.single.R'></span>

<h3>Description</h3>

<p>Function to find maximum likelihood solution to a multivariate Unbiased Random Walk model with decreasing (exponential decaying) rate of change through time.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>opt.decel.single.R(
  yy,
  method = "L-BFGS-B",
  hess = FALSE,
  pool = TRUE,
  trace = FALSE,
  iterations = NULL,
  iter.sd = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="opt.decel.single.R_+3A_yy">yy</code></td>
<td>
<p>a multivariate evoTS object.</p>
</td></tr>
<tr><td><code id="opt.decel.single.R_+3A_method">method</code></td>
<td>
<p>optimization method, passed to function optim. Default is &quot;L-BFGS-B&quot;.</p>
</td></tr>
<tr><td><code id="opt.decel.single.R_+3A_hess">hess</code></td>
<td>
<p>logical, indicating whether to calculate standard errors from the Hessian matrix.</p>
</td></tr>
<tr><td><code id="opt.decel.single.R_+3A_pool">pool</code></td>
<td>
<p>indicating whether to pool variances across samples</p>
</td></tr>
<tr><td><code id="opt.decel.single.R_+3A_trace">trace</code></td>
<td>
<p>logical, indicating whether information on the progress of the optimization is printed.</p>
</td></tr>
<tr><td><code id="opt.decel.single.R_+3A_iterations">iterations</code></td>
<td>
<p>the number of times the optimization method is run from different starting points. Default is NULL, meaning the optimization is run once.</p>
</td></tr>
<tr><td><code id="opt.decel.single.R_+3A_iter.sd">iter.sd</code></td>
<td>
<p>defines the standard deviation of the Gaussian distribution from which starting values for the optimization routine is run. Default is 1.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function searches - using an optimization routine - for the maximum-likelihood solution for a multivariate Unbiased Random Walk model with decreasing (exponential decaying) rate of change through time.
</p>
<p>The argument 'method' is passed to the 'optim' function and is included for the convenience of users to better control the optimization routine. The the default method (L-BFGS-B) seems to work for most evolutionary sequences.
</p>
<p>Initial estimates to start the optimization come from maximum-likelihood estimates of the univariate Unbiased Random Walk model (from the paleoTS package) fitted to each time-series separately. The starting value for r = -1.
</p>
<p>It is good practice to repeat any numerical optimization procedure from different starting points. This is especially important for complex models as the log-likelihood surface might contain more than one peak. The number of iterations is controlled by the argument 'iterations'. The function will report the model parameters from the iteration with the highest log-likelihood.
</p>


<h3>Value</h3>

<p>First part of the output reports the log-likelihood of the model and its AICc score. The second part of the output is the maximum log-likelihood model parameters (ancestral.values, R, r). The last part of the output gives information about the number of parameters in the model (K), number of samples in the data (n) and number of times the optimization routine was run (iter).
</p>


<h3>Note</h3>

<p>The models have been implemented to be compatible with the joint parameterization routine in the package paleoTS. The optimization is therefore fit using the actual sample values, with the autocorrelation among samples accounted for in the log-likelihood function. The joint distribution of sample means is multivariate normal, with means and variance-covariances determined by evolutionary parameters and sampling errors.
</p>


<h3>Author(s)</h3>

<p>Kjetil Lysne Voje
</p>


<h3>References</h3>

<p>Voje, K. L. 2020. Testing eco‐evolutionary predictions using fossil data: Phyletic evolution following ecological opportunity.<em>Evolution</em> 74:188–200.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Generate an evoTS object by simulating a multivariate dataset
indata &lt;- sim.multi.URW(30)

## Fit a multivariate Unbiased Random Walk model with a decreasing rate of change through time.
opt.accel.single.R(indata)

</code></pre>

<hr>
<h2 id='opt.decel.single.R.zero.corr'>Fit multivariate Unbiased Random Walk model with uncorrelated trait changes and with decreasing (exponential decaying) rate of change through time.</h2><span id='topic+opt.decel.single.R.zero.corr'></span>

<h3>Description</h3>

<p>Function to find maximum likelihood solution to a multivariate Unbiased Random Walk model with uncorrelated trait changes and with decreasing (exponential decaying) rate of change through time.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>opt.decel.single.R.zero.corr(
  yy,
  method = "L-BFGS-B",
  hess = FALSE,
  pool = TRUE,
  trace = FALSE,
  iterations = NULL,
  iter.sd = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="opt.decel.single.R.zero.corr_+3A_yy">yy</code></td>
<td>
<p>a multivariate evoTS object.</p>
</td></tr>
<tr><td><code id="opt.decel.single.R.zero.corr_+3A_method">method</code></td>
<td>
<p>optimization method, passed to function optim. Default is &quot;L-BFGS-B&quot;.</p>
</td></tr>
<tr><td><code id="opt.decel.single.R.zero.corr_+3A_hess">hess</code></td>
<td>
<p>logical, indicating whether to calculate standard errors from the Hessian matrix.</p>
</td></tr>
<tr><td><code id="opt.decel.single.R.zero.corr_+3A_pool">pool</code></td>
<td>
<p>indicating whether to pool variances across samples</p>
</td></tr>
<tr><td><code id="opt.decel.single.R.zero.corr_+3A_trace">trace</code></td>
<td>
<p>logical, indicating whether information on the progress of the optimization is printed.</p>
</td></tr>
<tr><td><code id="opt.decel.single.R.zero.corr_+3A_iterations">iterations</code></td>
<td>
<p>the number of times the optimization method is run from different starting points. Default is NULL, meaning the optimization is run once.</p>
</td></tr>
<tr><td><code id="opt.decel.single.R.zero.corr_+3A_iter.sd">iter.sd</code></td>
<td>
<p>defines the standard deviation of the Gaussian distribution from which starting values for the optimization routine is run. Default is 1.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function searches - using an optimization routine - for the maximum-likelihood solution for a multivariate Unbiased Random Walk model with uncorrelated trait changes and with increasing (exponential accelerating) rate of change through time.
</p>
<p>The argument 'method' is passed to the 'optim' function and is included for the convenience of users to better control the optimization routine. The the default method (L-BFGS-B) seems to work for most evolutionary sequences.
</p>
<p>Initial estimates to start the optimization come from maximum-likelihood estimates of the univariate Unbiased Random Walk model (from the paleoTS package) fitted to each time-series separately. The starting value for r = -1.
</p>
<p>It is good practice to repeat any numerical optimization procedure from different starting points. This is especially important for complex models as the log-likelihood surface might contain more than one peak. The number of iterations is controlled by the argument 'iterations'. The function will report the model parameters from the iteration with the highest log-likelihood.
</p>


<h3>Value</h3>

<p>First part of the output reports the log-likelihood of the model and its AICc score. The second part of the output is the maximum log-likelihood model parameters (ancestral.values, R, r). The last part of the output gives information about the number of parameters in the model (K), number of samples in the data (n) and number of times the optimization routine was run (iter).
</p>


<h3>Note</h3>

<p>The models have been implemented to be compatible with the joint parameterization routine in the package paleoTS. The optimization is therefore fit using the actual sample values, with the autocorrelation among samples accounted for in the log-likelihood function. The joint distribution of sample means is multivariate normal, with means and variance-covariances determined by evolutionary parameters and sampling errors.
</p>


<h3>Author(s)</h3>

<p>Kjetil Lysne Voje
</p>


<h3>References</h3>

<p>Voje, K. L. 2020. Testing eco‐evolutionary predictions using fossil data: Phyletic evolution following ecological opportunity.<em>Evolution</em> 74:188–200.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Generate an evoTS object by simulating a multivariate dataset.
indata &lt;- sim.multi.URW(30)

## Fit a multivariate Unbiased Random Walk model with a decreasing rate of change through time.
opt.decel.single.R.zero.corr(indata)
</code></pre>

<hr>
<h2 id='opt.joint.accel'>Fit an Unbiased Random Walk with an accelerating rate of change through time.</h2><span id='topic+opt.joint.accel'></span>

<h3>Description</h3>

<p>Function to find maximum likelihood solutions to a Unbiased Random Walk with an accelerating or decelerating rate of change through time.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>opt.joint.accel(y, pool = TRUE, meth = "L-BFGS-B", hess = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="opt.joint.accel_+3A_y">y</code></td>
<td>
<p>an univariate evoTS object.</p>
</td></tr>
<tr><td><code id="opt.joint.accel_+3A_pool">pool</code></td>
<td>
<p>logical indicating whether to pool variances across samples</p>
</td></tr>
<tr><td><code id="opt.joint.accel_+3A_meth">meth</code></td>
<td>
<p>optimization method, passed to function optim. Default is &quot;L-BFGS-B&quot;.</p>
</td></tr>
<tr><td><code id="opt.joint.accel_+3A_hess">hess</code></td>
<td>
<p>logical, indicating whether to calculate standard errors from the Hessian matrix.</p>
</td></tr>
</table>


<h3>Value</h3>

<table role = "presentation">
<tr><td><code>logL</code></td>
<td>
<p>the log-likelihood of the optimal solution</p>
</td></tr>
<tr><td><code>AICc</code></td>
<td>
<p>AIC with a correction for small sample sizes</p>
</td></tr>
<tr><td><code>parameters</code></td>
<td>
<p>parameter estimates</p>
</td></tr>
<tr><td><code>modelName</code></td>
<td>
<p>abbreviated model name</p>
</td></tr>
<tr><td><code>method</code></td>
<td>
<p>Joint consideration of all samples</p>
</td></tr>
<tr><td><code>K</code></td>
<td>
<p>number of parameters in the model</p>
</td></tr>
<tr><td><code>n</code></td>
<td>
<p>the number of observations/samples</p>
</td></tr>
</table>


<h3>Note</h3>

<p>The models have been implemented to be compatible with the joint parameterization routine in the package paleoTS. The optimization is therefore fit using the actual sample values, with the autocorrelation among samples accounted for in the log-likelihood function. The joint distribution of sample means is multivariate normal, with means and variance-covariances determined by evolutionary parameters and sampling errors.
</p>


<h3>Author(s)</h3>

<p>Kjetil Lysne Voje
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Generate a paleoTS object by simulating a univariate evolutionary sequence
y &lt;- paleoTS::sim.GRW(30)

## Fit the model
opt.joint.accel(y)

</code></pre>

<hr>
<h2 id='opt.joint.decel'>Fit an Unbiased Random Walk with an decelerating rate of change through time.</h2><span id='topic+opt.joint.decel'></span>

<h3>Description</h3>

<p>Function to find maximum likelihood solutions to a Unbiased Random Walk with an decelerating or decelerating rate of change through time.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>opt.joint.decel(y, pool = TRUE, meth = "L-BFGS-B", hess = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="opt.joint.decel_+3A_y">y</code></td>
<td>
<p>an univariate evoTS object.</p>
</td></tr>
<tr><td><code id="opt.joint.decel_+3A_pool">pool</code></td>
<td>
<p>logical indicating whether to pool variances across samples</p>
</td></tr>
<tr><td><code id="opt.joint.decel_+3A_meth">meth</code></td>
<td>
<p>optimization method, passed to function optim. Default is &quot;L-BFGS-B&quot;.</p>
</td></tr>
<tr><td><code id="opt.joint.decel_+3A_hess">hess</code></td>
<td>
<p>logical, indicating whether to calculate standard errors from the Hessian matrix.</p>
</td></tr>
</table>


<h3>Value</h3>

<table role = "presentation">
<tr><td><code>logL</code></td>
<td>
<p>the log-likelihood of the optimal solution</p>
</td></tr>
<tr><td><code>AICc</code></td>
<td>
<p>AIC with a correction for small sample sizes</p>
</td></tr>
<tr><td><code>parameters</code></td>
<td>
<p>parameter estimates</p>
</td></tr>
<tr><td><code>modelName</code></td>
<td>
<p>abbreviated model name</p>
</td></tr>
<tr><td><code>method</code></td>
<td>
<p>Joint consideration of all samples</p>
</td></tr>
<tr><td><code>K</code></td>
<td>
<p>number of parameters in the model</p>
</td></tr>
<tr><td><code>n</code></td>
<td>
<p>the number of observations/samples</p>
</td></tr>
</table>


<h3>Note</h3>

<p>The models have been implemented to be compatible with the joint parameterization routine in the package paleoTS. The optimization is therefore fit using the actual sample values, with the autocorrelation among samples accounted for in the log-likelihood function. The joint distribution of sample means is multivariate normal, with means and variance-covariances determined by evolutionary parameters and sampling errors.
</p>


<h3>Author(s)</h3>

<p>Kjetil Lysne Voje
</p>


<h3>References</h3>

<p>Voje, K. L. 2020. Testing eco‐evolutionary predictions using fossil data: Phyletic evolution following ecological opportunity.<em>Evolution</em> 74:188–200.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Generate a paleoTS object by simulating a univariate evolutionary sequence
x &lt;- paleoTS::sim.GRW(30)

## Fit the model
opt.joint.decel(x)

</code></pre>

<hr>
<h2 id='opt.joint.OUBM'>Fit an Ornstein-Uhlenbeck model with an optimum that evolves according to a Unbiased Random Walk.</h2><span id='topic+opt.joint.OUBM'></span>

<h3>Description</h3>

<p>Function to find maximum likelihood solutions to an Ornstein-Uhlenbeck model with an optimum that evolves according to a Unbiased Random Walk.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>opt.joint.OUBM(
  y,
  pool = TRUE,
  meth = "L-BFGS-B",
  hess = FALSE,
  iterations = NULL,
  iter.sd = NULL,
  opt.anc = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="opt.joint.OUBM_+3A_y">y</code></td>
<td>
<p>an univariate paleoTS object.</p>
</td></tr>
<tr><td><code id="opt.joint.OUBM_+3A_pool">pool</code></td>
<td>
<p>logical indicating whether to pool variances across samples</p>
</td></tr>
<tr><td><code id="opt.joint.OUBM_+3A_meth">meth</code></td>
<td>
<p>optimization method, passed to function optim. Default is &quot;L-BFGS-B&quot;.</p>
</td></tr>
<tr><td><code id="opt.joint.OUBM_+3A_hess">hess</code></td>
<td>
<p>logical, indicating whether to calculate standard errors from the Hessian matrix.</p>
</td></tr>
<tr><td><code id="opt.joint.OUBM_+3A_iterations">iterations</code></td>
<td>
<p>the number of times the optimization method is run from different starting points. Default is NULL, meaning the optimization is run once.</p>
</td></tr>
<tr><td><code id="opt.joint.OUBM_+3A_iter.sd">iter.sd</code></td>
<td>
<p>defines the standard deviation of the Gaussian distribution from which starting values for the optimization routine is run. Default is 1.</p>
</td></tr>
<tr><td><code id="opt.joint.OUBM_+3A_opt.anc">opt.anc</code></td>
<td>
<p>logical, indicating whether the the ancestral trait state is at the optimum.</p>
</td></tr>
</table>


<h3>Value</h3>

<table role = "presentation">
<tr><td><code>logL</code></td>
<td>
<p>the log-likelihood of the optimal solution</p>
</td></tr>
<tr><td><code>AICc</code></td>
<td>
<p>AIC with a correction for small sample sizes</p>
</td></tr>
<tr><td><code>parameters</code></td>
<td>
<p>parameter estimates</p>
</td></tr>
<tr><td><code>modelName</code></td>
<td>
<p>abbreviated model name</p>
</td></tr>
<tr><td><code>method</code></td>
<td>
<p>Joint consideration of all samples</p>
</td></tr>
<tr><td><code>K</code></td>
<td>
<p>number of parameters in the model</p>
</td></tr>
<tr><td><code>n</code></td>
<td>
<p>the number of observations/samples</p>
</td></tr>
</table>


<h3>Note</h3>

<p>The models have been implemented to be compatible with the joint parameterization routine in the package paleoTS. The optimization is therefore fit using the actual sample values, with the autocorrelation among samples accounted for in the log-likelihood function. The joint distribution of sample means is multivariate normal, with means and variance-covariances determined by evolutionary parameters and sampling errors.
</p>


<h3>Author(s)</h3>

<p>Kjetil Lysne Voje
</p>


<h3>References</h3>

<p>Hansen, T. F., Pienaar, J. &amp; Orzack, S. H. 2008. A Comparative Method for Studying Adaptation to a Randomly Evolving Environment. <em>Evolution</em> 62:1965–1977.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Generate a paleoTS object by simulating a univariate evolutionary sequence
x &lt;- paleoTS::sim.GRW(60)

## Fit the model
opt.joint.OUBM(x)

</code></pre>

<hr>
<h2 id='opt.joint.URW.Stasis'>Optimization and log-likelihoods for pairs of models.</h2><span id='topic+opt.joint.URW.Stasis'></span>

<h3>Description</h3>

<p>A collections of functions that serves the function fit.mode.shift. See fit.mode.shift for info.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>opt.joint.URW.Stasis(
  y,
  gg,
  cl = list(fnscale = -1),
  pool = TRUE,
  meth = "L-BFGS-B",
  hess = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="opt.joint.URW.Stasis_+3A_y">y</code></td>
<td>
<p>a paleoTS object.</p>
</td></tr>
<tr><td><code id="opt.joint.URW.Stasis_+3A_gg">gg</code></td>
<td>
<p>numeric vector indicating membership of each sample in segments</p>
</td></tr>
<tr><td><code id="opt.joint.URW.Stasis_+3A_cl">cl</code></td>
<td>
<p>control list to be passed to optim</p>
</td></tr>
<tr><td><code id="opt.joint.URW.Stasis_+3A_pool">pool</code></td>
<td>
<p>logical indicating whether to pool variances across samples</p>
</td></tr>
<tr><td><code id="opt.joint.URW.Stasis_+3A_meth">meth</code></td>
<td>
<p>optimization method, passed to function optim. Default is &quot;L-BFGS-B&quot;.</p>
</td></tr>
<tr><td><code id="opt.joint.URW.Stasis_+3A_hess">hess</code></td>
<td>
<p>logical, indicating whether to calculate standard errors from the Hessian matrix.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>In general, users will not be access these functions directly, but instead use the wrapper function, which use these functions to find the best-supported parameter values.
</p>


<h3>Note</h3>

<p>This function is not likely to be called directly by the user.
</p>


<h3>Author(s)</h3>

<p>Kjetil Lysne Voje
</p>

<hr>
<h2 id='opt.single.R'>Fit multivariate Unbiased Random Walk model.</h2><span id='topic+opt.single.R'></span>

<h3>Description</h3>

<p>Function to find maximum likelihood solution to a multivariate Unbiased Random Walk model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>opt.single.R(
  yy,
  method = "L-BFGS-B",
  hess = FALSE,
  pool = TRUE,
  trace = FALSE,
  iterations = NULL,
  iter.sd = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="opt.single.R_+3A_yy">yy</code></td>
<td>
<p>a multivariate evoTS object.</p>
</td></tr>
<tr><td><code id="opt.single.R_+3A_method">method</code></td>
<td>
<p>optimization method, passed to function optim. Default is &quot;L-BFGS-B&quot;.</p>
</td></tr>
<tr><td><code id="opt.single.R_+3A_hess">hess</code></td>
<td>
<p>logical, indicating whether to calculate standard errors from the Hessian matrix.</p>
</td></tr>
<tr><td><code id="opt.single.R_+3A_pool">pool</code></td>
<td>
<p>indicating whether to pool variances across samples</p>
</td></tr>
<tr><td><code id="opt.single.R_+3A_trace">trace</code></td>
<td>
<p>logical, indicating whether information on the progress of the optimization is printed.</p>
</td></tr>
<tr><td><code id="opt.single.R_+3A_iterations">iterations</code></td>
<td>
<p>the number of times the optimization method is run from different starting points. Default is NULL, meaning the optimization is run once.</p>
</td></tr>
<tr><td><code id="opt.single.R_+3A_iter.sd">iter.sd</code></td>
<td>
<p>defines the standard deviation of the Gaussian distribution from which starting values for the optimization routine is run. Default is 1.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function searches - using an optimization routine - for the maximum-likelihood solution for a multivariate Unbiased Random Walk model.
</p>
<p>The argument 'method' is passed to the 'optim' function and is included for the convenience of users to better control the optimization routine. The the default method (L-BFGS-B) seems to work for most evolutionary sequences.
</p>
<p>Initial estimates to start the optimization come from maximum-likelihood estimates of the univariate Unbiased Random Walk model (from the paleoTS package) fitted to each time-series separately.
</p>
<p>It is good practice to repeat any numerical optimization procedure from different starting points. This is especially important for complex models as the log-likelihood surface might contain more than one peak. The number of iterations is controlled by the argument 'iterations'. The function will report the model parameters from the iteration with the highest log-likelihood.
</p>


<h3>Value</h3>

<p>First part of the output reports the log-likelihood of the model and its AICc score. The second part of the output is the maximum log-likelihood model parameters (ancestral.values, R). The last part of the output gives information about the number of parameters in the model (K), number of samples in the data (n) and number of times the optimization routine was run (iter).
</p>


<h3>Note</h3>

<p>The models have been implemented to be compatible with the joint parameterization routine in the package paleoTS. The optimization is therefore fit using the actual sample values, with the autocorrelation among samples accounted for in the log-likelihood function. The joint distribution of sample means is multivariate normal, with means and variance-covariances determined by evolutionary parameters and sampling errors.
</p>


<h3>Author(s)</h3>

<p>Kjetil Lysne Voje
</p>


<h3>References</h3>

<p>Revell, L. J. &amp; Harmon, L. Testing quantitative genetic hypotheses about the evolutionary rate matrix for continuous characters. <em>Evolutionary Ecology Research</em> 10, 311–331 (2008).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Generate an evoTS objects by simulating a multivariate dataset
x &lt;- sim.multi.URW(30)

## Fit a multivariate Unbiased Random Walk model.
opt.single.R(x)
</code></pre>

<hr>
<h2 id='opt.single.R.zero.corr'>Fit multivariate Unbiased Random Walk model with uncorrelated trait changes.</h2><span id='topic+opt.single.R.zero.corr'></span>

<h3>Description</h3>

<p>Function to find maximum likelihood solution to a multivariate Unbiased Random Walk model with uncorrelated trait changes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>opt.single.R.zero.corr(
  yy,
  method = "L-BFGS-B",
  hess = FALSE,
  pool = TRUE,
  trace = FALSE,
  iterations = NULL,
  iter.sd = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="opt.single.R.zero.corr_+3A_yy">yy</code></td>
<td>
<p>a multivariate evoTS object.</p>
</td></tr>
<tr><td><code id="opt.single.R.zero.corr_+3A_method">method</code></td>
<td>
<p>optimization method, passed to function optim. Default is &quot;L-BFGS-B&quot;.</p>
</td></tr>
<tr><td><code id="opt.single.R.zero.corr_+3A_hess">hess</code></td>
<td>
<p>logical, indicating whether to calculate standard errors from the Hessian matrix.</p>
</td></tr>
<tr><td><code id="opt.single.R.zero.corr_+3A_pool">pool</code></td>
<td>
<p>indicating whether to pool variances across samples</p>
</td></tr>
<tr><td><code id="opt.single.R.zero.corr_+3A_trace">trace</code></td>
<td>
<p>logical, indicating whether information on the progress of the optimization is printed.</p>
</td></tr>
<tr><td><code id="opt.single.R.zero.corr_+3A_iterations">iterations</code></td>
<td>
<p>the number of times the optimization method is run from different starting points. Default is NULL, meaning the optimization is run once.</p>
</td></tr>
<tr><td><code id="opt.single.R.zero.corr_+3A_iter.sd">iter.sd</code></td>
<td>
<p>defines the standard deviation of the Gaussian distribution from which starting values for the optimization routine is run. Default is 1.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function searches - using an optimization routine - for the maximum-likelihood solution for a multivariate Unbiased Random Walk model with uncorrelated trait changes.
</p>
<p>The argument 'method' is passed to the 'optim' function and is included for the convenience of users to better control the optimization routine. The the default method (L-BFGS-B) seems to work for most evolutionary sequences.
</p>
<p>Initial estimates to start the optimization come from maximum-likelihood estimates of the univariate Unbiased Random Walk model (from the paleoTS package) fitted to each time-series separately.
</p>
<p>It is good practice to repeat any numerical optimization procedure from different starting points. This is especially important for complex models as the log-likelihood surface might contain more than one peak. The number of iterations is controlled by the argument 'iterations'. The function will report the model parameters from the iteration with the highest log-likelihood.
</p>


<h3>Value</h3>

<p>First part of the output reports the log-likelihood of the model and its AICc score. The second part of the output is the maximum log-likelihood model parameters (ancestral.values, R). The last part of the output gives information about the number of parameters in the model (K), number of samples in the data (n) and number of times the optimization routine was run (iter).
</p>


<h3>Note</h3>

<p>The models have been implemented to be compatible with the joint parameterization routine in the package paleoTS. The optimization is therefore fit using the actual sample values, with the autocorrelation among samples accounted for in the log-likelihood function. The joint distribution of sample means is multivariate normal, with means and variance-covariances determined by evolutionary parameters and sampling errors.
</p>


<h3>Author(s)</h3>

<p>Kjetil Lysne Voje
</p>


<h3>References</h3>

<p>Revell, L. J. &amp; Harmon, L. Testing quantitative genetic hypotheses about the evolutionary rate matrix for continuous characters. <em>Evolutionary Ecology Research</em> 10, 311–331 (2008).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Generate an evoTS object by simulating a multivariate dataset
x &lt;- sim.multi.URW(30)

## Fit a multivariate Unbiased Random Walk model with uncorrelated trait changes.
opt.single.R.zero.corr(x)
</code></pre>

<hr>
<h2 id='plotevoTS'>Plot a paleoTS object</h2><span id='topic+plotevoTS'></span>

<h3>Description</h3>

<p>Plot a paleoTS object (slightly modified version of the same function in paleoTS)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plotevoTS(
  x,
  nse = 1,
  pool = FALSE,
  add = FALSE,
  modelFit = NULL,
  pch = 19,
  lwd = 1.5,
  ylim = NULL,
  xlab = NULL,
  ylab = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plotevoTS_+3A_x">x</code></td>
<td>
<p>a paleoTS object</p>
</td></tr>
<tr><td><code id="plotevoTS_+3A_nse">nse</code></td>
<td>
<p>the number of standard errors represented by the error bars on the plot; defaults to 1</p>
</td></tr>
<tr><td><code id="plotevoTS_+3A_pool">pool</code></td>
<td>
<p>logical indicating if variances should be pooled across samples for the purposes of displaying error bars; defaults to FALSE</p>
</td></tr>
<tr><td><code id="plotevoTS_+3A_add">add</code></td>
<td>
<p>logical, if TRUE, adds to existing plot</p>
</td></tr>
<tr><td><code id="plotevoTS_+3A_modelfit">modelFit</code></td>
<td>
<p>optional model fit from fitting functions</p>
</td></tr>
<tr><td><code id="plotevoTS_+3A_pch">pch</code></td>
<td>
<p>plotting symbol, defaults to 19</p>
</td></tr>
<tr><td><code id="plotevoTS_+3A_lwd">lwd</code></td>
<td>
<p>line width, defaults to 1.5</p>
</td></tr>
<tr><td><code id="plotevoTS_+3A_ylim">ylim</code></td>
<td>
<p>optional, y-limits of the plot</p>
</td></tr>
<tr><td><code id="plotevoTS_+3A_xlab">xlab</code></td>
<td>
<p>a title for the x axis</p>
</td></tr>
<tr><td><code id="plotevoTS_+3A_ylab">ylab</code></td>
<td>
<p>a title for the y axis</p>
</td></tr>
<tr><td><code id="plotevoTS_+3A_...">...</code></td>
<td>
<p>other arguments passed to plotting functions</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The results are plotted.
</p>


<h3>Author(s)</h3>

<p>Kjetil Lysne Voje
</p>

<hr>
<h2 id='plotevoTS.multivariate'>Plots multivariate evolutionary sequence (time-series) data set</h2><span id='topic+plotevoTS.multivariate'></span>

<h3>Description</h3>

<p>Function to plot multivariate evolutionary sequence (time-series), showing trait means over time.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plotevoTS.multivariate(
  yy,
  nse = 1,
  col = NULL,
  lty = NULL,
  lwd = NULL,
  pch = NULL,
  x.label = NULL,
  y.label = NULL,
  y_min = NULL,
  y_max = NULL,
  cex.axis = NULL,
  cex.lab = NULL,
  cex.main = NULL,
  axes = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plotevoTS.multivariate_+3A_yy">yy</code></td>
<td>
<p>a multivariate evoTS object</p>
</td></tr>
<tr><td><code id="plotevoTS.multivariate_+3A_nse">nse</code></td>
<td>
<p>the number of standard errors represented by the error bars on the plot; default is 1</p>
</td></tr>
<tr><td><code id="plotevoTS.multivariate_+3A_col">col</code></td>
<td>
<p>vector indicating colors</p>
</td></tr>
<tr><td><code id="plotevoTS.multivariate_+3A_lty">lty</code></td>
<td>
<p>line type</p>
</td></tr>
<tr><td><code id="plotevoTS.multivariate_+3A_lwd">lwd</code></td>
<td>
<p>line width</p>
</td></tr>
<tr><td><code id="plotevoTS.multivariate_+3A_pch">pch</code></td>
<td>
<p>plotting symbols</p>
</td></tr>
<tr><td><code id="plotevoTS.multivariate_+3A_x.label">x.label</code></td>
<td>
<p>label on x axis</p>
</td></tr>
<tr><td><code id="plotevoTS.multivariate_+3A_y.label">y.label</code></td>
<td>
<p>label on y axis</p>
</td></tr>
<tr><td><code id="plotevoTS.multivariate_+3A_y_min">y_min</code></td>
<td>
<p>minimum value of y axis</p>
</td></tr>
<tr><td><code id="plotevoTS.multivariate_+3A_y_max">y_max</code></td>
<td>
<p>maximum value of y axis</p>
</td></tr>
<tr><td><code id="plotevoTS.multivariate_+3A_cex.axis">cex.axis</code></td>
<td>
<p>Specify the size of the tick label numbers/text</p>
</td></tr>
<tr><td><code id="plotevoTS.multivariate_+3A_cex.lab">cex.lab</code></td>
<td>
<p>specify the size of the axis label</p>
</td></tr>
<tr><td><code id="plotevoTS.multivariate_+3A_cex.main">cex.main</code></td>
<td>
<p>specify the size of the title text</p>
</td></tr>
<tr><td><code id="plotevoTS.multivariate_+3A_axes">axes</code></td>
<td>
<p>logical, whether to plot axes or not</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The results are plotted.
</p>


<h3>Author(s)</h3>

<p>Kjetil Lysne Voje
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Generate two evolutionary sequences (time-series)
x1 &lt;- paleoTS::sim.Stasis(60, vp=1)
x2 &lt;- paleoTS::sim.Stasis(60, vp=1)

## Make a multivariate data set
x1_x2&lt;-make.multivar.evoTS(x1, x2)

## Plot the data
plotevoTS.multivariate(x1_x2, y_min=-1, y_max=1)
</code></pre>

<hr>
<h2 id='ribs_S.yellowstonensis'>Evolutionary sequence (time-series) of phenotypic change in the number of ribs in the lineage Stephanodiscus yellowstonensis</h2><span id='topic+ribs_S.yellowstonensis'></span>

<h3>Description</h3>

<p>Phenotypic data (ribs) from a centric diatom lineage Stephanodiscus yellowstonensis. The time series spans about 14 000 years.
The data set contains data on the number of costae (ribs) per valve.
The data consists of an objects of class paleoTS (ribs_S.yellowstonensis). Objects of class paleoTS can be analyzed in evoTS.
The object (trait data set) contains a vector of sample means (mm), sample variances (vv), sample sizes (nn) and sample ages (tt).
The oldest sample is listed first. The data spans an interval of 13728 years.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(ribs_S.yellowstonensis)
</code></pre>


<h3>Format</h3>

<p>An object of class <code>"paleoTS"</code>.
</p>


<h3>References</h3>

<p>Theriot et al. 2006. Late Quaternary rapid morphological evolution of an endemic diatom in Yellowstone Lake, Wyoming. Paleobiology 32:38-54
</p>


<h3>Examples</h3>

<pre><code class='language-R'>ln.ribs&lt;-paleoTS::ln.paleoTS(ribs_S.yellowstonensis)
ln.ribs$tt&lt;-ln.ribs$tt/(max(ln.ribs$tt))
opt.joint.decel(ln.ribs)
</code></pre>

<hr>
<h2 id='sim.accel.decel'>Simulate an Unbiased Random Walk with an accelerating or decelerating rate of change through time.</h2><span id='topic+sim.accel.decel'></span>

<h3>Description</h3>

<p>Function to simulate an evolutionary sequence data set according to an Unbiased Random Walk with an accelerating or decelerating rate of change through time.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sim.accel.decel(
  ns = 20,
  vs = 0.5,
  r = 0.2,
  vp = 0.2,
  nn = rep(20, ns),
  tt = 0:(ns - 1)
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="sim.accel.decel_+3A_ns">ns</code></td>
<td>
<p>number of samples in time-series</p>
</td></tr>
<tr><td><code id="sim.accel.decel_+3A_vs">vs</code></td>
<td>
<p>step variance of the trait</p>
</td></tr>
<tr><td><code id="sim.accel.decel_+3A_r">r</code></td>
<td>
<p>the parameter controlling the exponential decay (if negative) or increase (if positive) of the rate (vs) through time.</p>
</td></tr>
<tr><td><code id="sim.accel.decel_+3A_vp">vp</code></td>
<td>
<p>phenotypic variance of each sample</p>
</td></tr>
<tr><td><code id="sim.accel.decel_+3A_nn">nn</code></td>
<td>
<p>vector of the number of individuals in each sample (identical sample sizes for all time-series is assumed)</p>
</td></tr>
<tr><td><code id="sim.accel.decel_+3A_tt">tt</code></td>
<td>
<p>vector of sample times (ages</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An evolutionary sequence (time-series) data set (a paleoTS object)
</p>


<h3>Author(s)</h3>

<p>Kjetil Lysne Voje
</p>


<h3>Examples</h3>

<pre><code class='language-R'>##Simulate an unbiased random walk where the rate decelerates through time.
x&lt;-sim.accel.decel(40, r=-0.5)

## Plot the data
plotevoTS(x)
</code></pre>

<hr>
<h2 id='sim.multi.OU'>Simulate multivariate Ornstein-Uhlenbeck evolutionary sequence data sets</h2><span id='topic+sim.multi.OU'></span>

<h3>Description</h3>

<p>Function to simulate a multivariate Ornstein-Uhlenbeck evolutionary sequence data set.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sim.multi.OU(
  ns = 30,
  anc = c(0, 0),
  optima = c(3, 2),
  A = matrix(c(7, 0, 0, 6), nrow = 2, byrow = TRUE),
  R = matrix(c(0.05, 0, 0, 0.05), nrow = 2, byrow = TRUE),
  vp = 0.1,
  nn = rep(30, ns),
  tt = 0:(ns - 1)
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="sim.multi.OU_+3A_ns">ns</code></td>
<td>
<p>number of samples in time-series</p>
</td></tr>
<tr><td><code id="sim.multi.OU_+3A_anc">anc</code></td>
<td>
<p>the ancestral trait values</p>
</td></tr>
<tr><td><code id="sim.multi.OU_+3A_optima">optima</code></td>
<td>
<p>the optimal trait values</p>
</td></tr>
<tr><td><code id="sim.multi.OU_+3A_a">A</code></td>
<td>
<p>the pull matrix.</p>
</td></tr>
<tr><td><code id="sim.multi.OU_+3A_r">R</code></td>
<td>
<p>the drift matrix</p>
</td></tr>
<tr><td><code id="sim.multi.OU_+3A_vp">vp</code></td>
<td>
<p>within-population trait variance</p>
</td></tr>
<tr><td><code id="sim.multi.OU_+3A_nn">nn</code></td>
<td>
<p>vector of the number of individuals in each sample (identical sample sizes for all time-series is assumed)</p>
</td></tr>
<tr><td><code id="sim.multi.OU_+3A_tt">tt</code></td>
<td>
<p>vector of sample ages, increases from oldest to youngest</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A multivariate evolutionary sequence (time-series) data set.
</p>


<h3>Note</h3>

<p>The Ornstein Uhlenbeck model is reduced to an Unbiased Random Walk when the alpha parameter is zero. It is therefore possible to let a trait evolve as an Unbiased Random Walk by setting the diagonal element for that trait to a value close to zero (e.g. 1e-07). Elements in the diagonal of A cannot be exactly zero as this will result in a singular variance-covariance matrix.
</p>


<h3>Author(s)</h3>

<p>Kjetil Lysne Voje
</p>


<h3>Examples</h3>

<pre><code class='language-R'>##Define the A and R matrices

A_matrix&lt;-matrix(c(4,-2,0,3), nrow=2, byrow = TRUE)
R_matrix&lt;-matrix(c(4,0.2,0.2,4), nrow=2, byrow = TRUE)

## Generate an evoTS object by simulating a multivariate dataset
data_set&lt;-sim.multi.OU(40, optima = c(1.5,2),A=A_matrix , R = R_matrix)

## plot the data
plotevoTS.multivariate(data_set)

</code></pre>

<hr>
<h2 id='sim.multi.URW'>Simulate multivariate evolutionary sequence data that evolve according to an Unbiased Random Walk</h2><span id='topic+sim.multi.URW'></span>

<h3>Description</h3>

<p>Function to simulate multivariate evolutionary sequence data that evolve according to an Unbiased Random Walk
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sim.multi.URW(
  ns = 30,
  anc = c(0, 0),
  R = matrix(c(0.5, 0, 0, 0.5), nrow = 2, byrow = TRUE),
  vp = 0.1,
  nn = rep(30, ns),
  tt = 0:(ns - 1)
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="sim.multi.URW_+3A_ns">ns</code></td>
<td>
<p>number of samples in time-series</p>
</td></tr>
<tr><td><code id="sim.multi.URW_+3A_anc">anc</code></td>
<td>
<p>the ancestral trait values</p>
</td></tr>
<tr><td><code id="sim.multi.URW_+3A_r">R</code></td>
<td>
<p>the drift matrix</p>
</td></tr>
<tr><td><code id="sim.multi.URW_+3A_vp">vp</code></td>
<td>
<p>within-population trait variance</p>
</td></tr>
<tr><td><code id="sim.multi.URW_+3A_nn">nn</code></td>
<td>
<p>vector of the number of individuals in each sample (identical sample sizes for all time-series is assumed)</p>
</td></tr>
<tr><td><code id="sim.multi.URW_+3A_tt">tt</code></td>
<td>
<p>vector of sample ages, increases from oldest to youngest</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A multivariate evolutionary sequence (time-series) data set.
</p>


<h3>Author(s)</h3>

<p>Kjetil Lysne Voje
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Create a multivariate dataset
data_set&lt;-sim.multi.URW(40, R = matrix(c(0.2,0.1,0.1,0.3), nrow=2, byrow = TRUE))

## plot the data
plotevoTS.multivariate(data_set)

</code></pre>

<hr>
<h2 id='sim.OUBM'>Simulate an Ornstein-Uhlenbeck process with optimum changing according to an unbiased random walk</h2><span id='topic+sim.OUBM'></span>

<h3>Description</h3>

<p>Function to simulate an Ornstein-Uhlenbeck evolutionary sequence data set with an optimum moving according to an unbiased random walk.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sim.OUBM(
  ns = 20,
  anc = 0,
  theta.0 = 1,
  alpha = 0.3,
  vstep.trait = 0.1,
  vstep.opt = 0.1,
  vp = 1,
  nn = rep(20, ns),
  tt = 0:(ns - 1)
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="sim.OUBM_+3A_ns">ns</code></td>
<td>
<p>number of samples in time-series</p>
</td></tr>
<tr><td><code id="sim.OUBM_+3A_anc">anc</code></td>
<td>
<p>the ancestral trait values</p>
</td></tr>
<tr><td><code id="sim.OUBM_+3A_theta.0">theta.0</code></td>
<td>
<p>the ancestral value for the optimum</p>
</td></tr>
<tr><td><code id="sim.OUBM_+3A_alpha">alpha</code></td>
<td>
<p>strength of attraction to the optimum</p>
</td></tr>
<tr><td><code id="sim.OUBM_+3A_vstep.trait">vstep.trait</code></td>
<td>
<p>step variance of the trait</p>
</td></tr>
<tr><td><code id="sim.OUBM_+3A_vstep.opt">vstep.opt</code></td>
<td>
<p>step variance of the optimum</p>
</td></tr>
<tr><td><code id="sim.OUBM_+3A_vp">vp</code></td>
<td>
<p>phenotypic variance of each sample</p>
</td></tr>
<tr><td><code id="sim.OUBM_+3A_nn">nn</code></td>
<td>
<p>vector of the number of individuals in each sample (identical sample sizes for all time-series is assumed)</p>
</td></tr>
<tr><td><code id="sim.OUBM_+3A_tt">tt</code></td>
<td>
<p>vector of sample times (ages</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An evolutionary sequence (time-series) data set (a paleoTS object)
</p>


<h3>Author(s)</h3>

<p>Kjetil Lysne Voje
</p>


<h3>Examples</h3>

<pre><code class='language-R'>##Create data
x&lt;-sim.OUBM(50, theta.0 = 5, alpha = 0.6, vstep.opt = 0.5)

## plot the data
plot(x)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
