<!DOCTYPE html><html><head><title>Help for package WRI</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {WRI}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#confidenceBands'><p>Confidence Bands for Wasserstein Regression</p></a></li>
<li><a href='#den2Q_qd'><p>convert density function to quantile and quantile density function</p></a></li>
<li><a href='#Exp_Map_Barycenter_Method'><p>Numerical implementation of the Exponential map</p></a></li>
<li><a href='#Exp_Map_Barycenter_Method_pw'><p>Numerical implementation of the pointwise Exponential map</p></a></li>
<li><a href='#getInnovation'><p>Calculating innovations in WAR(p) models</p></a></li>
<li><a href='#globalFstat'><p>An internal function used in bootstrap global F test</p></a></li>
<li><a href='#globalFtest'><p>global F test for Wasserstein regression</p></a></li>
<li><a href='#partialFtest'><p>partial F test for Wasserstein regression</p></a></li>
<li><a href='#predict.WARp'><p>Prediction by WAR(p) models</p></a></li>
<li><a href='#print.summary.WRI'><p>print the summary of WRI object</p></a></li>
<li><a href='#quadraticQ'><p>An internal function to do quadratic program in order to make Qfitted nondescreasing</p></a></li>
<li><a href='#quan2den_qd'><p>convert density function to quantile and quantile density function</p></a></li>
<li><a href='#Sample_ACV'><p>Function for calculating sample autocovariance</p></a></li>
<li><a href='#simulate_quantile_curves'><p>Simulate quantile curves</p></a></li>
<li><a href='#strokeCTdensity'><p>Stroke data: clinical, radiological scalar variables and density curves of the hematoma of 393 stroke patients</p></a></li>
<li><a href='#summary.WRI'><p>Summary Function of Wasserstein Regression Model</p></a></li>
<li><a href='#WARp'><p>WAR(p) models: estimation and forecast</p></a></li>
<li><a href='#WARp_acvfs'><p>Function for calculating sample Wasserstein autocovariance functions</p></a></li>
<li><a href='#WARp_forecast_tangent'><p>Forecast using WAR(p) models</p></a></li>
<li><a href='#warSim'><p>Generate simulation data</p></a></li>
<li><a href='#wass_R2'><p>Compute Wasserstein Coefficient of Determination</p></a></li>
<li><a href='#wass_regress'><p>Perform Frechet Regression with the Wasserstein Distance</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Wasserstein Regression and Inference</td>
</tr>
<tr>
<td>Version:</td>
<td>0.2.0</td>
</tr>
<tr>
<td>Author:</td>
<td>Xi Liu [aut, cre],
  Chao Zhang [aut],
  Matthew Coleman [aut],
  Alexander Petersen [aut]</td>
</tr>
<tr>
<td>Description:</td>
<td>Implementation of the methodologies described in 1) Alexander Petersen, Xi Liu and Afshin A. Divani (2021) &lt;<a href="https://doi.org/10.1214%2F20-aos1971">doi:10.1214/20-aos1971</a>&gt;, including global F tests, partial F tests, intrinsic Wasserstein-infinity bands and Wasserstein density bands, and 2) Chao Zhang, Piotr Kokoszka and Alexander Petersen (2022) &lt;<a href="https://doi.org/10.1111%2Fjtsa.12590">doi:10.1111/jtsa.12590</a>&gt;, including estimation, prediction, and inference of the Wasserstein autoregressive models.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>LazyDataCompression:</td>
<td>xz</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>Rcpp, RcppArmadillo</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.6.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>fdapace (&ge; 0.2.0), fdadensity (&ge; 0.1.2), Rfast (&ge; 1.9.8),
CVXR (&ge; 0.99.7), expm (&ge; 0.999-4), ggplot2 (&ge; 3.2.1),
gridExtra (&ge; 2.3), stats, Rcpp (&ge; 1.0.3), locfit (&ge;
1.5-9.1), mvtnorm (&ge; 1.1-0), locpol (&ge; 0.7), modeest (&ge;
2.4.0), methods, rlang, polynom</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.0</td>
</tr>
<tr>
<td>Suggests:</td>
<td>knitr, rmarkdown, testthat (&ge; 2.1.0)</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2022-07-08 22:56:17 UTC; czhang</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Xi Liu &lt;xiliu@ucsb.edu&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2022-07-08 23:30:11 UTC</td>
</tr>
</table>
<hr>
<h2 id='confidenceBands'>Confidence Bands for Wasserstein Regression</h2><span id='topic+confidenceBands'></span>

<h3>Description</h3>

<p>Confidence Bands for Wasserstein Regression
</p>


<h3>Usage</h3>

<pre><code class='language-R'>confidenceBands(
  wass_regress_res,
  Xpred_df,
  level = 0.95,
  delta = 0.01,
  type = "density",
  figure = TRUE,
  fig_num = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="confidenceBands_+3A_wass_regress_res">wass_regress_res</code></td>
<td>
<p>an object returned by the <code>wass_regress</code> function</p>
</td></tr>
<tr><td><code id="confidenceBands_+3A_xpred_df">Xpred_df</code></td>
<td>
<p>k-by-p matrix (or dataframe, or named vector) used for prediction. Note that Xpred_df should have the same column names with Xfit_df used in wass_regress_res</p>
</td></tr>
<tr><td><code id="confidenceBands_+3A_level">level</code></td>
<td>
<p>confidence level</p>
</td></tr>
<tr><td><code id="confidenceBands_+3A_delta">delta</code></td>
<td>
<p>boundary control value in density band computation. Must be a value in the interval (0, 1/2) (default: 0.01)</p>
</td></tr>
<tr><td><code id="confidenceBands_+3A_type">type</code></td>
<td>
<p>'density', 'quantile' or 'both'
</p>

<ul>
<li><p>'density': density function bands will be returned (and plotted if <code>figure = TRUE</code>) 
</p>
</li>
<li><p>'quantile': quantile function and CDF bands will be returned (and plotted if <code>figure = TRUE</code>) 
</p>
</li>
<li><p>'both': three kinds of bands, density function, quantile function and CDF bands will be returned (and plotted if <code>figure = TRUE</code>) 
</p>
</li></ul>
</td></tr>
<tr><td><code id="confidenceBands_+3A_figure">figure</code></td>
<td>
<p>logical; if TRUE, return a sampled plot (default: TRUE)</p>
</td></tr>
<tr><td><code id="confidenceBands_+3A_fig_num">fig_num</code></td>
<td>
<p>the fig_num-th row of <code>Xpred_df</code> will be used for visualization of confidence bands. If NULL, then <code>fig_num</code> is randomly chosen (default: NULL)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function computes intrinsic confidence bands for <code>Xpred_df</code> if <code>type</code> = 'quantile' and density bands if <code>type</code> = 'density', and visualizes the confidence and/or density bands when <code>figure</code> = TRUE.
</p>


<h3>Value</h3>

<p>a list containing the following lists:
</p>
<table>
<tr><td><code>den_list:</code></td>
<td>


<ul>
<li><p>fpred: k-by-m matrix, predicted density function at Xpred_df.
</p>
</li>
<li><p>f_ux: k-by-m matrix, upper bound of confidence bands of density functions.
</p>
</li>
<li><p>f_lx: k-by-m matrix, lower bound of confidence bands of density functions.
</p>
</li>
<li><p>Qpred: k-by-m matrix, f_lx[i, ], f_ux[i, ] and fpred[i, ] evaluated on Qpred[i, ] vector.
</p>
</li></ul>
</td></tr>
<tr><td><code>quan_list:</code></td>
<td>


<ul>
<li><p>Qpred: k-by-m matrix of predicted quantile functions.
</p>
</li>
<li><p>Q_ux: k-by-m matrix of upper bound of quantile functions.
</p>
</li>
<li><p>Q_lx: k-by-m matrix of lower bound of quantile functions.
</p>
</li>
<li><p>t_vec: a length m vector - common grid for all quantile functions.</p>
</li></ul>
</td></tr>
<tr><td><code>cdf_list:</code></td>
<td>


<ul>
<li><p>fpred: k-by-m matrix, predicted density function.
</p>
</li>
<li><p>Fpred: k-by-m matrix, predicted cumulative distribution functions.
</p>
</li>
<li><p>F_ux: k-by-m matrix, upper bound of cumulative distribution functions.
</p>
</li>
<li><p>F_lx: k-by-m matrix, lower bound of cumulative distribution functions.
</p>
</li>
<li><p>Fsup: k-by-m matrix, fpred[i, ], F_lx[i, ], F_ux[i, ] and Fpred[i, ] evaluated on Fsup[i, ] vector.</p>
</li></ul>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>alpha = 2
beta = 1
n = 50
x1 = runif(n)
t_vec = unique(c(seq(0, 0.05, 0.001), seq(0.05, 0.95, 0.05), seq(0.95, 1, 0.001)))
set.seed(1)
quan_obs = simulate_quantile_curves(x1, alpha, beta, t_vec)
Xfit_df = data.frame(x1 = x1)
res = wass_regress(rightside_formula = ~., Xfit_df = Xfit_df,
                   Ytype = 'quantile', Ymat = quan_obs, Sup = t_vec)
confidence_Band = confidenceBands(res, Xpred_df = data.frame(x1 = c(-0.5,0.5)),
type = 'both', fig_num = 2)

data(strokeCTdensity)
predictor = strokeCTdensity$predictors
dSup = strokeCTdensity$densitySupport
densityCurves = strokeCTdensity$densityCurve
xpred = predictor[2:3, ]

res = wass_regress(rightside_formula = ~., Xfit_df = predictor,
Ytype = 'density', Ymat = densityCurves, Sup = dSup)
confidence_Band = confidenceBands(res, Xpred_df = xpred, type = 'density', fig_num = 1)

</code></pre>

<hr>
<h2 id='den2Q_qd'>convert density function to quantile and quantile density function</h2><span id='topic+den2Q_qd'></span>

<h3>Description</h3>

<p>convert density function to quantile and quantile density function
</p>


<h3>Usage</h3>

<pre><code class='language-R'>den2Q_qd(densityCurves, dSup, t_vec)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="den2Q_qd_+3A_densitycurves">densityCurves</code></td>
<td>
<p>n-by-m matrix of density curves</p>
</td></tr>
<tr><td><code id="den2Q_qd_+3A_dsup">dSup</code></td>
<td>
<p>length m vector contains the common support grid of the density curves</p>
</td></tr>
<tr><td><code id="den2Q_qd_+3A_t_vec">t_vec</code></td>
<td>
<p>common grid for quantile functions</p>
</td></tr>
</table>

<hr>
<h2 id='Exp_Map_Barycenter_Method'>Numerical implementation of the Exponential map</h2><span id='topic+Exp_Map_Barycenter_Method'></span>

<h3>Description</h3>

<p>This function implements the Exponential map to calculate <code class="reqn">\hat{F}_t(u)</code> for all <code class="reqn">u</code> in the cdf/pdf support
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Exp_Map_Barycenter_Method(density.grid, forecast, cdf)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Exp_Map_Barycenter_Method_+3A_density.grid">density.grid</code></td>
<td>
<p>The values where the cdf <code class="reqn">\hat{F}</code> is evaluated</p>
</td></tr>
<tr><td><code id="Exp_Map_Barycenter_Method_+3A_forecast">forecast</code></td>
<td>
<p>A vector that contains the WAR(p) model forecast result</p>
</td></tr>
<tr><td><code id="Exp_Map_Barycenter_Method_+3A_cdf">cdf</code></td>
<td>
<p>The quantile grid used in forecasting</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A numeric vector that contains <code class="reqn">\hat{F}_t(u)</code> evaluated over <code>density.grid</code>
</p>


<h3>References</h3>

<p><cite>Wasserstein Autoregressive Models for Density Time Series, Chao Zhang, Piotr Kokoszka, Alexander Petersen, 2022</cite>
</p>

<hr>
<h2 id='Exp_Map_Barycenter_Method_pw'>Numerical implementation of the pointwise Exponential map</h2><span id='topic+Exp_Map_Barycenter_Method_pw'></span>

<h3>Description</h3>

<p>This function implements the Exponential map to calculate <code class="reqn">\hat{F}_t(u)</code> for a fixed <code class="reqn">u</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Exp_Map_Barycenter_Method_pw(u, forecast, cdf)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Exp_Map_Barycenter_Method_pw_+3A_u">u</code></td>
<td>
<p>The value where the cdf <code class="reqn">\hat{F}</code> is evaluated</p>
</td></tr>
<tr><td><code id="Exp_Map_Barycenter_Method_pw_+3A_forecast">forecast</code></td>
<td>
<p>A vector that contains the WAR(p) model forecast result</p>
</td></tr>
<tr><td><code id="Exp_Map_Barycenter_Method_pw_+3A_cdf">cdf</code></td>
<td>
<p>The quantile grid used in forecasting</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A numeric value <code class="reqn">\hat{F}_t(u)</code>
</p>


<h3>References</h3>

<p><cite>Wasserstein Autoregressive Models for Density Time Series, Chao Zhang, Piotr Kokoszka, Alexander Petersen, 2022</cite>
</p>

<hr>
<h2 id='getInnovation'>Calculating innovations in WAR(p) models</h2><span id='topic+getInnovation'></span>

<h3>Description</h3>

<p>This function calculates innovations in WAR(p) models
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getInnovation(quantile, quantile.grid, p)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getInnovation_+3A_quantile">quantile</code></td>
<td>
<p>A matrix containing all the available quantile functions. Columns represent time indices and rows represent evaluation grid.</p>
</td></tr>
<tr><td><code id="getInnovation_+3A_quantile.grid">quantile.grid</code></td>
<td>
<p>A numeric vector, the grid over which quantile functions are evaluated.</p>
</td></tr>
<tr><td><code id="getInnovation_+3A_p">p</code></td>
<td>
<p>A positive integer, the order of the fitted WAR(p) model.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with
</p>

<ul>
<li><p> innovation - The tangent space innovations evaluated over the quantile grid.  Fitting a WAR(p) model for <code class="reqn">n</code> observations will produce <code class="reqn">n-2p</code> innovations.
</p>
</li>
<li><p> cov.surf - The covariance surface
</p>
</li></ul>



<h3>References</h3>

<p><cite>Wasserstein Autoregressive Models for Density Time Series, Chao Zhang, Piotr Kokoszka, Alexander Petersen, 2022</cite>
</p>

<hr>
<h2 id='globalFstat'>An internal function used in bootstrap global F test</h2><span id='topic+globalFstat'></span><span id='topic+short_wass_regress'></span>

<h3>Description</h3>

<p>An internal function used in bootstrap global F test
</p>
<p>quick wasserstein regression fitting function with smoothed input
</p>


<h3>Usage</h3>

<pre><code class='language-R'>globalFstat(xfit, Qobs, t_vec)

short_wass_regress(Xfit_df, smoothY)
</code></pre>

<hr>
<h2 id='globalFtest'>global F test for Wasserstein regression</h2><span id='topic+globalFtest'></span>

<h3>Description</h3>

<p>global F test for Wasserstein regression
</p>


<h3>Usage</h3>

<pre><code class='language-R'>globalFtest(
  wass_regress_res,
  alpha = 0.05,
  permutation = FALSE,
  numPermu = 200,
  bootstrap = FALSE,
  numBoot = 200
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="globalFtest_+3A_wass_regress_res">wass_regress_res</code></td>
<td>
<p>an object returned by the <code>wass_regress</code> function</p>
</td></tr>
<tr><td><code id="globalFtest_+3A_alpha">alpha</code></td>
<td>
<p>type one error rate</p>
</td></tr>
<tr><td><code id="globalFtest_+3A_permutation">permutation</code></td>
<td>
<p>logical; perform permutation global F test (default: FALSE)</p>
</td></tr>
<tr><td><code id="globalFtest_+3A_numpermu">numPermu</code></td>
<td>
<p>number of permutation samples if permutation = TRUE</p>
</td></tr>
<tr><td><code id="globalFtest_+3A_bootstrap">bootstrap</code></td>
<td>
<p>logical; bootstrap global F test (default: FALSE)</p>
</td></tr>
<tr><td><code id="globalFtest_+3A_numboot">numBoot</code></td>
<td>
<p>number of bootstrap samples if bootstrap = TRUE</p>
</td></tr>
</table>


<h3>Details</h3>

<p>four methods used to compute p value of global F test
</p>

<ul>
<li><p>truncated: asymptotic inference,  p-value is obtained by truncating the infinite summation of eigenvalues into the first K terms, where the first K terms explain more than 99.99% of the variance.
</p>
</li>
<li><p>satterthwaite: asymptotic inference, p-value is computed using Satterthwaite's approximation method of mixtures of chi-square.
</p>
</li>
<li><p>permutation: resampling technique; Wasserstein SSR is used as the F statistic.
</p>
</li>
<li><p>bootstrap: resampling technique; Wasserstein SSR is used as the F statistic.</p>
</li></ul>



<h3>Value</h3>

<p>a list containing the following fields:
</p>
<table>
<tr><td><code>wasserstein.F_stat</code></td>
<td>
<p>the Wasserstein F statistic value in Satterthwaite method .</p>
</td></tr>
<tr><td><code>chisq_df</code></td>
<td>
<p>the degree of freedom of the null chi-square distribution.</p>
</td></tr>
<tr><td><code>summary_df</code></td>
<td>
<p>a dataframe containing the following columns:</p>
</td></tr>
</table>

<ul>
<li><p>method: methods used to compute p value, see details
</p>
</li>
<li><p>statistic: the test statistics
</p>
</li>
<li><p>critical_value: critical value
</p>
</li>
<li><p>p_value: p value of global F test</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>data(strokeCTdensity)
predictor = strokeCTdensity$predictors
dSup = strokeCTdensity$densitySupport
densityCurves = strokeCTdensity$densityCurve

res = wass_regress(rightside_formula = ~., Xfit_df = predictor,
 Ytype = 'density', Ymat = densityCurves, Sup = dSup)
globalF_res = globalFtest(res, alpha = 0.05, permutation = TRUE, numPermu = 200)
</code></pre>

<hr>
<h2 id='partialFtest'>partial F test for Wasserstein regression</h2><span id='topic+partialFtest'></span>

<h3>Description</h3>

<p>partial F test for Wasserstein regression
</p>


<h3>Usage</h3>

<pre><code class='language-R'>partialFtest(reduced_res, full_res, alpha = 0.05)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="partialFtest_+3A_reduced_res">reduced_res</code></td>
<td>
<p>a reduced model list returned by the <code>wass_regress</code> function</p>
</td></tr>
<tr><td><code id="partialFtest_+3A_full_res">full_res</code></td>
<td>
<p>a full model list returned by the <code>wass_regress</code> function</p>
</td></tr>
<tr><td><code id="partialFtest_+3A_alpha">alpha</code></td>
<td>
<p>type one error rate</p>
</td></tr>
</table>


<h3>Details</h3>

<p>two methods used to compute p value using asymptotic distribution of F statistic
</p>

<ul>
<li><p>truncated: asymptotic inference, p-value is obtained by truncating the infinite summation of eigenvalues into the first K terms, where the first K terms explain more than 99.99% of the variance.
</p>
</li>
<li><p>satterthwaite: asymptotic inference, p-value is computed using Satterthwaite approximation method of mixtures of chi-square.</p>
</li></ul>



<h3>Value</h3>

<p>a dataframe containing the following columns:
</p>
<table>
<tr><td><code>method</code></td>
<td>
<p>methods used to compute p value, see details</p>
</td></tr>
<tr><td><code>statistic</code></td>
<td>
<p>the test statistics</p>
</td></tr>
<tr><td><code>critical_value</code></td>
<td>
<p>critical value</p>
</td></tr>
<tr><td><code>p_value</code></td>
<td>
<p>p value of global F test</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>data(strokeCTdensity)
predictor = strokeCTdensity$predictors
dSup = strokeCTdensity$densitySupport
densityCurves = strokeCTdensity$densityCurve

full_res &lt;- wass_regress(rightside_formula = ~., Xfit_df = predictor,
 Ymat = densityCurves, Ytype = 'density', Sup = dSup)
reduced_res &lt;- wass_regress(~ log_b_vol + b_shapInd + midline_shift + B_TimeCT, Xfit_df = predictor,
 Ymat = densityCurves, Ytype = 'density', Sup = dSup)
partialFtable = partialFtest(reduced_res, full_res, alpha = 0.05)
</code></pre>

<hr>
<h2 id='predict.WARp'>Prediction by WAR(p) models</h2><span id='topic+predict.WARp'></span>

<h3>Description</h3>

<p>a method of the WARp class which produces a one-step ahead prediction by WAR(p) models
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'WARp'
predict(object, dSup, expSup, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="predict.WARp_+3A_object">object</code></td>
<td>
<p>A WARp object, the output of <code>WARp()</code>.</p>
</td></tr>
<tr><td><code id="predict.WARp_+3A_dsup">dSup</code></td>
<td>
<p>Optional, a numeric vector, the grid over which forecasted cdf/pdf is evaluated. Should be supplied/ignored with <code>expSup</code> together.</p>
</td></tr>
<tr><td><code id="predict.WARp_+3A_expsup">expSup</code></td>
<td>
<p>Optional, a numeric vector, the grid over the Exponential map is applied, <code>dSup</code> should cover and be denser than <code>expSup</code>.   Should be supplied/ignored with <code>dSup</code> together.</p>
</td></tr>
<tr><td><code id="predict.WARp_+3A_...">...</code></td>
<td>
<p>Further arguments passed to or from other methods.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of:
</p>
<table>
<tr><td><code>pred.cdf</code></td>
<td>
<p>predicted cdf</p>
</td></tr>
<tr><td><code>pred.pdf</code></td>
<td>
<p>predicted pdf</p>
</td></tr>
<tr><td><code>dSup</code></td>
<td>
<p>support of the predicted cdf/pdf</p>
</td></tr>
</table>


<h3>References</h3>

<p><cite>Wasserstein Autoregressive Models for Density Time Series, Chao Zhang, Piotr Kokoszka, Alexander Petersen, 2022</cite>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+WARp">WARp</a></code>
</p>

<hr>
<h2 id='print.summary.WRI'>print the summary of WRI object</h2><span id='topic+print.summary.WRI'></span>

<h3>Description</h3>

<p>print the summary of WRI object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'summary.WRI'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.summary.WRI_+3A_x">x</code></td>
<td>
<p>a 'summary.WRI' object</p>
</td></tr>
<tr><td><code id="print.summary.WRI_+3A_...">...</code></td>
<td>
<p>further arguments passed to or from other methods.</p>
</td></tr>
</table>

<hr>
<h2 id='quadraticQ'>An internal function to do quadratic program in order to make Qfitted nondescreasing</h2><span id='topic+quadraticQ'></span>

<h3>Description</h3>

<p>An internal function to do quadratic program in order to make Qfitted nondescreasing
</p>


<h3>Usage</h3>

<pre><code class='language-R'>quadraticQ(Qmat, t)
</code></pre>

<hr>
<h2 id='quan2den_qd'>convert density function to quantile and quantile density function</h2><span id='topic+quan2den_qd'></span>

<h3>Description</h3>

<p>convert density function to quantile and quantile density function
</p>


<h3>Usage</h3>

<pre><code class='language-R'>quan2den_qd(quantileCurves, t_vec)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="quan2den_qd_+3A_quantilecurves">quantileCurves</code></td>
<td>
<p>n-by-m matrix of quantile curves</p>
</td></tr>
<tr><td><code id="quan2den_qd_+3A_t_vec">t_vec</code></td>
<td>
<p>length m vector contains the common support grid of the quantile curves</p>
</td></tr>
</table>

<hr>
<h2 id='Sample_ACV'>Function for calculating sample autocovariance</h2><span id='topic+Sample_ACV'></span>

<h3>Description</h3>

<p>Calculating sample autocovariance of a specified lag for a centered time series
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Sample_ACV(ts, lag)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Sample_ACV_+3A_ts">ts</code></td>
<td>
<p>A numeric vector consisting of sequentially collected data</p>
</td></tr>
<tr><td><code id="Sample_ACV_+3A_lag">lag</code></td>
<td>
<p>A positive integer indicates the lag of the autocovariance function</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Sample autocovariance
</p>

<hr>
<h2 id='simulate_quantile_curves'>Simulate quantile curves</h2><span id='topic+simulate_quantile_curves'></span>

<h3>Description</h3>

<p>This function simulates quantile curves used as a toy example
</p>


<h3>Usage</h3>

<pre><code class='language-R'>simulate_quantile_curves(x1, alpha, beta, t_vec)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="simulate_quantile_curves_+3A_x1">x1</code></td>
<td>
<p>n-by-1 predictor vector</p>
</td></tr>
<tr><td><code id="simulate_quantile_curves_+3A_alpha">alpha</code></td>
<td>
<p>parameter in location transformation</p>
</td></tr>
<tr><td><code id="simulate_quantile_curves_+3A_beta">beta</code></td>
<td>
<p>parameter in variance transformation</p>
</td></tr>
<tr><td><code id="simulate_quantile_curves_+3A_t_vec">t_vec</code></td>
<td>
<p>a length m vector - common grid for all quantile functions</p>
</td></tr>
</table>


<h3>Value</h3>

<p>quan_obs n-by-m matrix of quantile functions
</p>


<h3>References</h3>

<p><cite>Wasserstein F-tests and confidence bands for the Frechet regression of density response curves, Alexander Petersen, Xi Liu and Afshin A. Divani, 2019</cite>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>alpha = 2
beta = 1
n = 100
x1 = runif(n)
t_vec = unique(c(seq(0, 0.05, 0.001), seq(0.05, 0.95, 0.05), seq(0.95, 1, 0.001)))
quan_obs = simulate_quantile_curves(x1, alpha, beta, t_vec)
</code></pre>

<hr>
<h2 id='strokeCTdensity'>Stroke data: clinical, radiological scalar variables and density curves of the hematoma of 393 stroke patients</h2><span id='topic+strokeCTdensity'></span>

<h3>Description</h3>

<p>Stroke data: clinical, radiological scalar variables and density curves of the hematoma of 393 stroke patients
</p>


<h3>Format</h3>

<p>a list of the following three fields:
</p>

<dl>
<dt>densityCurve:</dt><dd><p>393-by-101 head CT hematoma densities as distributional response</p>
</dd>
<dt>densitySupport:</dt><dd><p>length 101 common support vector</p>
</dd>
<dt>predictors:</dt><dd><p>393-by-9 matrix containing 9 scalar predictors</p>
</dd>
</dl>



<h3>References</h3>

<p><cite>Wasserstein F-tests and confidence bands for the Frechet regression of density response curves, Alexander Petersen, Xi Liu and Afshin A. Divani, 2019</cite>
</p>

<hr>
<h2 id='summary.WRI'>Summary Function of Wasserstein Regression Model</h2><span id='topic+summary.WRI'></span>

<h3>Description</h3>

<p>Summary Function of Wasserstein Regression Model
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'WRI'
summary(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary.WRI_+3A_object">object</code></td>
<td>
<p>an object returned by the <code>wass_regress</code> function</p>
</td></tr>
<tr><td><code id="summary.WRI_+3A_...">...</code></td>
<td>
<p>further arguments passed to or from other methods.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list containing the following fields:
</p>
<table>
<tr><td><code>call</code></td>
<td>
<p>function call of the Wasserstein regression</p>
</td></tr>
<tr><td><code>r.square</code></td>
<td>
<p>Wasserstein <code class="reqn">R^2</code>, the Wasserstein coefficient of determination</p>
</td></tr>
<tr><td><code>global_wasserstein_F_stat</code></td>
<td>
<p>Wasserstein global F test statistic from the Satterthwaite method</p>
</td></tr>
<tr><td><code>global_F_pvalue</code></td>
<td>
<p>p value of global F test</p>
</td></tr>
<tr><td><code>global_wasserstein_F_df</code></td>
<td>
<p>degrees of freedom of satterthwaite approximated sampling distribution used in global F test</p>
</td></tr>
<tr><td><code>partial_F_table</code></td>
<td>
<p>Partial F test for individual effects</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>data(strokeCTdensity)
predictor = strokeCTdensity$predictors
dSup = strokeCTdensity$densitySupport
densityCurves = strokeCTdensity$densityCurve

res &lt;- wass_regress(rightside_formula = ~., Xfit_df = predictor,
Ymat = densityCurves, Ytype = 'density', Sup = dSup)
summary(res)
</code></pre>

<hr>
<h2 id='WARp'>WAR(p) models: estimation and forecast</h2><span id='topic+WARp'></span>

<h3>Description</h3>

<p>this function produces an object of the WARp class which includes WAR(p) model parameter estimates and relevant quantities (see output list)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>WARp(quantile, quantile.grid, p)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="WARp_+3A_quantile">quantile</code></td>
<td>
<p>A matrix containing all the sample quantile functions. Columns represent time indices and rows represent evaluation grid.</p>
</td></tr>
<tr><td><code id="WARp_+3A_quantile.grid">quantile.grid</code></td>
<td>
<p>A numeric vector, the grid over which quantile functions are evaluated.</p>
</td></tr>
<tr><td><code id="WARp_+3A_p">p</code></td>
<td>
<p>A positive integer, the order of the fitted WAR(p) model.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function takes in a density time series in the form of the corresponding quantile functions as the main input. If the quantile series is not readily available, a general practice is to estimate density functions from samples, then use <code>dens2quantile</code> from the <code>fdadensity</code> package to convert density time series to quantile series.
</p>


<h3>Value</h3>

<p>A <code>WARp</code> object of:
</p>
<table>
<tr><td><code>coef</code></td>
<td>
<p>estimated AR parameters of the fitted WAR(p) model</p>
</td></tr>
<tr><td><code>coef.cov</code></td>
<td>
<p>covariance matrix of <code>coef</code></p>
</td></tr>
<tr><td><code>acvf</code></td>
<td>
<p>Wasserstein autocovariance function values</p>
</td></tr>
<tr><td><code>Wass.mean</code></td>
<td>
<p>Wasserstein mean quantile function</p>
</td></tr>
<tr><td><code>quantile</code></td>
<td>
<p>a matrix containing all the sample quantile functions (columns represent time indices and rows represent evaluation grid)</p>
</td></tr>
<tr><td><code>quantile.grid</code></td>
<td>
<p>quantile function grid that is utilized in calculation</p>
</td></tr>
<tr><td><code>order</code></td>
<td>
<p>a positive integer, the order of the fitted WAR(p) model</p>
</td></tr>
</table>


<h3>References</h3>

<p><cite>Wasserstein Autoregressive Models for Density Time Series, Chao Zhang, Piotr Kokoszka, Alexander Petersen, 2022</cite>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Simulate a density time series represented in quantile functions
# warSimData$sample.ts: A sample TS of quantile functions of length 100, taken from
#            the simulation experiments in Section 4 of Zhang et al. 2022.

# warSimData$quantile.grid: The grid over which quantile functions in sample.ts are evaluated.

warSimData &lt;- warSim()

p &lt;- 3
dSup &lt;- seq(-2, 2, 0.02)
expSup &lt;- seq(-2, 2, 0.1)

# Estimation: fit a WAR(3) model
WARp_obj &lt;- WARp(warSimData$sample.ts, warSimData$quantile.grid, p)

# Forecast: one-step-ahead forecast
forecast_1 &lt;- predict(WARp_obj)               # dSup and expSup are chosen automatically
forecast_2 &lt;- predict(WARp_obj, dSup, expSup) # dSup and expSup are chosen by user

# Plots
par(mfrow=c(1,2))

plot(forecast_1$dSup, forecast_1$pred.cdf, type="l", xlab="dSup", ylab="cdf")
plot(forecast_1$dSup, forecast_1$pred.pdf, type="l", xlab="dSup", ylab="pdf")

plot(forecast_2$dSup, forecast_2$pred.cdf, type="l", xlab="dSup", ylab="cdf")
plot(forecast_2$dSup, forecast_2$pred.pdf, type="l", xlab="dSup", ylab="pdf")


</code></pre>

<hr>
<h2 id='WARp_acvfs'>Function for calculating sample Wasserstein autocovariance functions</h2><span id='topic+WARp_acvfs'></span>

<h3>Description</h3>

<p>This function uses a time series of quantile functions to calculate the sample Wasserstein autocovariance functions from order <code class="reqn">0</code> to <code class="reqn">p</code> with a specified training window
</p>


<h3>Usage</h3>

<pre><code class='language-R'>WARp_acvfs(end.day, training.size, quantile, quantile.grid, p)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="WARp_acvfs_+3A_end.day">end.day</code></td>
<td>
<p>A positive integer, the last index of the training window.</p>
</td></tr>
<tr><td><code id="WARp_acvfs_+3A_training.size">training.size</code></td>
<td>
<p>A positive integer, the size of the training widnows.</p>
</td></tr>
<tr><td><code id="WARp_acvfs_+3A_quantile">quantile</code></td>
<td>
<p>A matrix containing all the available quantile functions. Columns represent time indices and rows represent evaluation grid.</p>
</td></tr>
<tr><td><code id="WARp_acvfs_+3A_quantile.grid">quantile.grid</code></td>
<td>
<p>A numeric vector, the grid over which quantile functions are evaluated.</p>
</td></tr>
<tr><td><code id="WARp_acvfs_+3A_p">p</code></td>
<td>
<p>A positive integer, the maximum order of the sample Wasserstein autocovariance functions.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with
</p>

<ul>
<li><p> acvfs - The sample Wasserstein autocovariance functions from order <code class="reqn">0</code> to <code class="reqn">p</code>
</p>
</li>
<li><p> barycenter - The sample average of the quantile functions in the training window
</p>
</li>
<li><p> quantile.pred - The quantile functions from <code class="reqn">end.day - p + 1</code> to <code class="reqn">end.day</code>
</p>
</li></ul>


<hr>
<h2 id='WARp_forecast_tangent'>Forecast using WAR(p) models</h2><span id='topic+WARp_forecast_tangent'></span>

<h3>Description</h3>

<p>This is a simplified function that produces the one-step ahead forecasts from WAR(p) models in the tangent space
</p>


<h3>Usage</h3>

<pre><code class='language-R'>WARp_forecast_tangent(p, acvfs)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="WARp_forecast_tangent_+3A_p">p</code></td>
<td>
<p>A positive integer, the order of the WAR(p) model.</p>
</td></tr>
<tr><td><code id="WARp_forecast_tangent_+3A_acvfs">acvfs</code></td>
<td>
<p>A list that is the output of <code>WARp_acvfs()</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>A numeric vector, the one-step ahead forecast produced by the WAR(p) model in the tangent space.
</p>


<h3>References</h3>

<p><cite>Wasserstein Autoregressive Models for Density Time Series, Chao Zhang, Piotr Kokoszka, Alexander Petersen, 2022</cite>
</p>

<hr>
<h2 id='warSim'>Generate simulation data</h2><span id='topic+warSim'></span>

<h3>Description</h3>

<p>Generate WAR(p) simulation data sets: samples simulated from a WAR(3) model similar to the specification in Section 4 of the referenced paper.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>warSim()
</code></pre>


<h3>Value</h3>

<p>A list of:
</p>
<table>
<tr><td><code>sample.ts</code></td>
<td>
<p>one simulation run chosen from <code>sample.ts.full</code></p>
</td></tr>
<tr><td><code>sample.ts.full</code></td>
<td>
<p>1000 simulation runs, each of which consists of a sample time series (of length 100) of quantile functions generated by a WAR(3) model as specified by the reference paper</p>
</td></tr>
<tr><td><code>quantile.grid</code></td>
<td>
<p>the grid over which the quantile functions in sample.ts.full are evaluated</p>
</td></tr>
</table>


<h3>References</h3>

<p><cite>Wasserstein Autoregressive Models for Density Time Series, Chao Zhang, Piotr Kokoszka, Alexander Petersen, 2022</cite>
</p>

<hr>
<h2 id='wass_R2'>Compute Wasserstein Coefficient of Determination</h2><span id='topic+wass_R2'></span>

<h3>Description</h3>

<p>Compute Wasserstein Coefficient of Determination
</p>


<h3>Usage</h3>

<pre><code class='language-R'>wass_R2(wass_regress_res)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="wass_R2_+3A_wass_regress_res">wass_regress_res</code></td>
<td>
<p>an object returned by the <code>wass_regress</code> function</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Wasserstein <code class="reqn">R^2</code>, the Wasserstein coefficient of determination
</p>


<h3>References</h3>

<p><cite>Frechet regression for random objects with Euclidean predictors, Alexander Petersen and Hans-Georg MÃ¼ller, 2019</cite>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(strokeCTdensity)
predictor = strokeCTdensity$predictors
dSup = strokeCTdensity$densitySupport
densityCurves = strokeCTdensity$densityCurve

res = wass_regress(rightside_formula = ~., Xfit_df = predictor,
Ymat = densityCurves, Ytype = 'density', Sup = dSup)
wass_r2 = wass_R2(res)
</code></pre>

<hr>
<h2 id='wass_regress'>Perform Frechet Regression with the Wasserstein Distance</h2><span id='topic+wass_regress'></span>

<h3>Description</h3>

<p>Perform Frechet Regression with the Wasserstein Distance
</p>


<h3>Usage</h3>

<pre><code class='language-R'>wass_regress(rightside_formula, Xfit_df, Ytype, Ymat, Sup = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="wass_regress_+3A_rightside_formula">rightside_formula</code></td>
<td>
<p>a right-side formula</p>
</td></tr>
<tr><td><code id="wass_regress_+3A_xfit_df">Xfit_df</code></td>
<td>
<p>n-by-p matrix (or dataframe) of predictor values for fitting (do not include a column for the intercept)</p>
</td></tr>
<tr><td><code id="wass_regress_+3A_ytype">Ytype</code></td>
<td>
<p>'quantile' or 'density'</p>
</td></tr>
<tr><td><code id="wass_regress_+3A_ymat">Ymat</code></td>
<td>
<p>one of the following matrices:
</p>

<ul>
<li><p>if Ytype = 'quantile' Ymat is an n-by-m matrix of the observed quantile functions. Ymat[i, :] is a 1-by-m vector of quantile function values on grid <code>Sup</code>.
</p>
</li>
<li><p>if Ytype = 'density' Ymat is an n-by-m matrix of the observed density functions. Ymat[i, :] is a 1-by-m vector of density function values on grid <code>Sup</code>.
</p>
</li></ul>
</td></tr>
<tr><td><code id="wass_regress_+3A_sup">Sup</code></td>
<td>
<p>one of the following vectors:
</p>

<ul>
<li><p>if Ytype = 'quantile' Sup is a length m vector - common grid for all quantile functions in Ymat (default: seq(0, 1, length.out = ncol(Ymat))).
</p>
</li>
<li><p>if Ytype = 'density' Sup is a length m vector - common grid for all density functions in Ymat (default: seq(0, 1, length.out = ncol(Ymat))).
</p>
</li></ul>
</td></tr>
</table>


<h3>Value</h3>

<p>a list containing the following objects:
</p>
<table>
<tr><td><code>call</code></td>
<td>
<p>function call</p>
</td></tr>
<tr><td><code>rformula</code></td>
<td>
<p><code>rightside_formula</code></p>
</td></tr>
<tr><td><code>predictor_names</code></td>
<td>
<p>names of predictors as the colnames given in the xfit matrix or dataframe.</p>
</td></tr>
<tr><td><code>Qfit</code></td>
<td>
<p>n-by-m matrix of fitted quantile functions.</p>
</td></tr>
<tr><td><code>xfit</code></td>
<td>
<p>design matrix in quantile fitting.</p>
</td></tr>
<tr><td><code>Xfit_df</code></td>
<td>
<p>n-by-p matrix (or dataframe) of predictor values for fitting</p>
</td></tr>
<tr><td><code>Yobs</code></td>
<td>
<p>a list containing the following matrices:
</p>

<ul>
<li><p>Qobs: n-by-m matrix of the observed quantile functions.
</p>
</li>
<li><p>qobs: n-by-m matrix of the observed quantile density functions.
</p>
</li>
<li><p>qobs_prime: n-by-m matrix of the first derivative of the observed quantile density functions.
</p>
</li>
<li><p>fobs: n-by-m matrix of the observed density functions.
</p>
</li></ul>
</td></tr>
<tr><td><code>t_vec</code></td>
<td>
<p>a length m vector - common grid for all quantile functions in Qobs.</p>
</td></tr>
</table>


<h3>References</h3>

<p><cite>Wasserstein F-tests and confidence bands for the Frechet regression of density response curves, Alexander Petersen, Xi Liu and Afshin A. Divani, 2019</cite>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(strokeCTdensity)
predictor = strokeCTdensity$predictors
dSup = strokeCTdensity$densitySupport
densityCurves = strokeCTdensity$densityCurve

res1 = wass_regress(rightside_formula = ~., Xfit_df = predictor,
 Ytype = 'density', Ymat = densityCurves, Sup = dSup)
res2 = wass_regress(rightside_formula = ~ log_b_vol * weight, Xfit_df = predictor,
 Ytype = 'density', Ymat = densityCurves, Sup = dSup)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
