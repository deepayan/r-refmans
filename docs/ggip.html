<!DOCTYPE html><html lang="en"><head><title>Help for package ggip</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {ggip}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#ggip-package'><p>ggip: Data Visualization for IP Addresses and Networks</p></a></li>
<li><a href='#coord_ip'><p>Coordinate system for IP data</p></a></li>
<li><a href='#geom_hilbert_outline'><p>Hilbert curve outline</p></a></li>
<li><a href='#ip_to_cartesian'><p>Map IP data to Cartesian coordinates</p></a></li>
<li><a href='#stat_summary_address'><p>Summarize IP addresses on a heatmap</p></a></li>
<li><a href='#theme_ip'><p>Themes for IP data</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Title:</td>
<td>Data Visualization for IP Addresses and Networks</td>
</tr>
<tr>
<td>Version:</td>
<td>0.3.2</td>
</tr>
<tr>
<td>Description:</td>
<td>A 'ggplot2' extension that enables visualization of IP
    (Internet Protocol) addresses and networks. The address space is
    mapped onto the Cartesian coordinate system using a space-filling
    curve. Offers full support for both IPv4 and IPv6 (Internet Protocol
    versions 4 and 6) address spaces.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://opensource.org/licenses/mit-license.php">MIT</a> + file LICENSE</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://davidchall.github.io/ggip/">https://davidchall.github.io/ggip/</a>,
<a href="https://github.com/davidchall/ggip">https://github.com/davidchall/ggip</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/davidchall/ggip/issues">https://github.com/davidchall/ggip/issues</a></td>
</tr>
<tr>
<td>Depends:</td>
<td>ggplot2 (&ge; 3.4.0), ipaddress (&ge; 1.0.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>cli, dplyr, Rcpp, rlang (&ge; 1.0.0), tidyr, vctrs</td>
</tr>
<tr>
<td>Suggests:</td>
<td>knitr, rmarkdown, testthat</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>ipaddress, Rcpp</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>Config/testthat/edition:</td>
<td>3</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-04-04 04:01:24 UTC; davidhall</td>
</tr>
<tr>
<td>Author:</td>
<td>David Hall <a href="https://orcid.org/0000-0002-2193-0480"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [aut,
    cre]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>David Hall &lt;david.hall.physics@gmail.com&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-04-04 04:10:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='ggip-package'>ggip: Data Visualization for IP Addresses and Networks</h2><span id='topic+ggip'></span><span id='topic+ggip-package'></span>

<h3>Description</h3>

<p><img src="../help/figures/logo.png" style='float: right' alt='logo' width='120' />
</p>
<p>A 'ggplot2' extension that enables visualization of IP (Internet Protocol) addresses and networks. The address space is mapped onto the Cartesian coordinate system using a space-filling curve. Offers full support for both IPv4 and IPv6 (Internet Protocol versions 4 and 6) address spaces.
</p>


<h3>Author(s)</h3>

<p><strong>Maintainer</strong>: David Hall <a href="mailto:david.hall.physics@gmail.com">david.hall.physics@gmail.com</a> (<a href="https://orcid.org/0000-0002-2193-0480">ORCID</a>)
</p>


<h3>See Also</h3>

<p>Useful links:
</p>

<ul>
<li> <p><a href="https://davidchall.github.io/ggip/">https://davidchall.github.io/ggip/</a>
</p>
</li>
<li> <p><a href="https://github.com/davidchall/ggip">https://github.com/davidchall/ggip</a>
</p>
</li>
<li><p> Report bugs at <a href="https://github.com/davidchall/ggip/issues">https://github.com/davidchall/ggip/issues</a>
</p>
</li></ul>


<hr>
<h2 id='coord_ip'>Coordinate system for IP data</h2><span id='topic+coord_ip'></span>

<h3>Description</h3>

<p>A ggplot2 coordinate system that maps a range of IP address space onto a
two-dimensional grid using a space-filling curve.
</p>
<p><code>coord_ip()</code> forms the foundation of any ggip plot. It translates all
<code><a href="ipaddress.html#topic+ip_address">ip_address</a></code> and <code><a href="ipaddress.html#topic+ip_network">ip_network</a></code>
vectors to Cartesian coordinates, ready for use by ggplot2 layers (see
Accessing Coordinates). This ensures all layers use a common mapping.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>coord_ip(
  canvas_network = ip_network("0.0.0.0/0"),
  pixel_prefix = 16,
  curve = c("hilbert", "morton"),
  expand = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="coord_ip_+3A_canvas_network">canvas_network</code></td>
<td>
<p>An <code><a href="ipaddress.html#topic+ip_network">ip_network</a></code> scalar that
determines the region of IP space visualized by the entire 2D grid. The
default shows the entire IPv4 address space.</p>
</td></tr>
<tr><td><code id="coord_ip_+3A_pixel_prefix">pixel_prefix</code></td>
<td>
<p>An integer scalar that sets the prefix length of the
network represented by a single pixel. The default value is 16. Increasing
this effectively improves the resolution of the plot.</p>
</td></tr>
<tr><td><code id="coord_ip_+3A_curve">curve</code></td>
<td>
<p>A string to choose the space-filling curve. Choices are
<code>"hilbert"</code> (default) and <code>"morton"</code>.</p>
</td></tr>
<tr><td><code id="coord_ip_+3A_expand">expand</code></td>
<td>
<p>If <code>TRUE</code>, adds a small expanded margin around the data grid.
The default is <code>FALSE</code>.</p>
</td></tr>
</table>


<h3>Accessing Coordinates</h3>

<p><code>coord_ip()</code> stores the result of the mapping in a nested data frame column.
This means each <code><a href="ipaddress.html#topic+ip_address">ip_address</a></code> or
<code><a href="ipaddress.html#topic+ip_network">ip_network</a></code> column in the original data set is
converted to a data frame column. When specifying ggplot2 aesthetics, you'll
need to use <code>$</code> to access the nested data (see Examples).
</p>
<p>Each <code><a href="ipaddress.html#topic+ip_address">ip_address</a></code> column will be replaced with a
data frame containing the following columns:</p>

<table>
<tr>
 <td style="text-align: left;">
   Column name </td><td style="text-align: left;"> Data type </td><td style="text-align: left;"> Description </td>
</tr>
<tr>
 <td style="text-align: left;">
   <code>ip</code> </td><td style="text-align: left;"> <code>ip_address</code> </td><td style="text-align: left;"> Original IP data </td>
</tr>
<tr>
 <td style="text-align: left;">
   <code>x</code> </td><td style="text-align: left;"> <code>integer</code> </td><td style="text-align: left;"> Pixel x </td>
</tr>
<tr>
 <td style="text-align: left;">
   <code>y</code> </td><td style="text-align: left;"> <code>integer</code> </td><td style="text-align: left;"> Pixel y </td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>

<p>Each <code><a href="ipaddress.html#topic+ip_network">ip_network</a></code> column will be replaced with a
data frame containing the following columns:</p>

<table>
<tr>
 <td style="text-align: left;">
   Column name </td><td style="text-align: left;"> Data type </td><td style="text-align: left;"> Description </td>
</tr>
<tr>
 <td style="text-align: left;">
   <code>ip</code> </td><td style="text-align: left;"> <code>ip_network</code> </td><td style="text-align: left;"> Original IP data </td>
</tr>
<tr>
 <td style="text-align: left;">
   <code>xmin</code> </td><td style="text-align: left;"> <code>integer</code> </td><td style="text-align: left;"> Bounding box xmin </td>
</tr>
<tr>
 <td style="text-align: left;">
   <code>ymin</code> </td><td style="text-align: left;"> <code>integer</code> </td><td style="text-align: left;"> Bounding box ymin </td>
</tr>
<tr>
 <td style="text-align: left;">
   <code>xmax</code> </td><td style="text-align: left;"> <code>integer</code> </td><td style="text-align: left;"> Bounding box xmax </td>
</tr>
<tr>
 <td style="text-align: left;">
   <code>ymax</code> </td><td style="text-align: left;"> <code>integer</code> </td><td style="text-align: left;"> Bounding box ymax </td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>



<h3>See Also</h3>

<p><code>vignette("visualizing-ip-data")</code> describes the mapping in more detail.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>suppressPackageStartupMessages(library(dplyr))

tibble(address = ip_address(c("0.0.0.0", "128.0.0.0", "192.168.0.1"))) %&gt;%
  ggplot(aes(x = address$x, y = address$y, label = address$ip)) +
  geom_point() +
  geom_label(nudge_x = c(10, 0, -10), nudge_y = -10) +
  coord_ip(expand = TRUE) +
  theme_ip_light()

tibble(network = ip_network(c("0.0.0.0/8", "224.0.0.0/4"))) %&gt;%
  mutate(
    start = network_address(network),
    end = broadcast_address(network)
  ) %&gt;%
  ggplot() +
  geom_point(aes(x = start$x, y = start$y), color = "blue") +
  geom_point(aes(x = end$x, y = end$y), color = "red") +
  geom_rect(
    aes(xmin = network$xmin, xmax = network$xmax, ymin = network$ymin, ymax = network$ymax),
    alpha = 0.5, fill = "grey"
  ) +
  coord_ip(curve = "morton", expand = TRUE) +
  theme_ip_light()
</code></pre>

<hr>
<h2 id='geom_hilbert_outline'>Hilbert curve outline</h2><span id='topic+geom_hilbert_outline'></span>

<h3>Description</h3>

<p>Computes and draws the outline of the Hilbert curve used to map IP data to
the Cartesian plane. By superimposing this outline on top of a ggip plot,
it guides the eye to regions that are close in IP address space.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>geom_hilbert_outline(
  mapping = NULL,
  data = NULL,
  ...,
  na.rm = FALSE,
  show.legend = NA,
  inherit.aes = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="geom_hilbert_outline_+3A_mapping">mapping</code></td>
<td>
<p>Set of aesthetic mappings created by <code><a href="ggplot2.html#topic+aes">aes()</a></code>. If specified and
<code>inherit.aes = TRUE</code> (the default), it is combined with the default mapping
at the top level of the plot. You must supply <code>mapping</code> if there is no plot
mapping.</p>
</td></tr>
<tr><td><code id="geom_hilbert_outline_+3A_data">data</code></td>
<td>
<p>The data to be displayed in this layer. There are three
options:
</p>
<p>If <code>NULL</code>, the default, the data is inherited from the plot
data as specified in the call to <code><a href="ggplot2.html#topic+ggplot">ggplot()</a></code>.
</p>
<p>A <code>data.frame</code>, or other object, will override the plot
data. All objects will be fortified to produce a data frame. See
<code><a href="ggplot2.html#topic+fortify">fortify()</a></code> for which variables will be created.
</p>
<p>A <code>function</code> will be called with a single argument,
the plot data. The return value must be a <code>data.frame</code>, and
will be used as the layer data. A <code>function</code> can be created
from a <code>formula</code> (e.g. <code>~ head(.x, 10)</code>).</p>
</td></tr>
<tr><td><code id="geom_hilbert_outline_+3A_...">...</code></td>
<td>
<p>Other arguments passed on to <code><a href="ggplot2.html#topic+layer">layer()</a></code>. These are
often aesthetics, used to set an aesthetic to a fixed value, like
<code>colour = "red"</code> or <code>size = 3</code>. They may also be parameters
to the paired geom/stat.</p>
</td></tr>
<tr><td><code id="geom_hilbert_outline_+3A_na.rm">na.rm</code></td>
<td>
<p>If <code>FALSE</code>, the default, missing values are removed with
a warning. If <code>TRUE</code>, missing values are silently removed.</p>
</td></tr>
<tr><td><code id="geom_hilbert_outline_+3A_show.legend">show.legend</code></td>
<td>
<p>logical. Should this layer be included in the legends?
<code>NA</code>, the default, includes if any aesthetics are mapped.
<code>FALSE</code> never includes, and <code>TRUE</code> always includes.
It can also be a named logical vector to finely select the aesthetics to
display.</p>
</td></tr>
<tr><td><code id="geom_hilbert_outline_+3A_inherit.aes">inherit.aes</code></td>
<td>
<p>If <code>FALSE</code>, overrides the default aesthetics,
rather than combining with them. This is most useful for helper functions
that define both data and aesthetics and shouldn't inherit behaviour from
the default plot specification, e.g. <code><a href="ggplot2.html#topic+borders">borders()</a></code>.</p>
</td></tr>
</table>


<h3>Aesthetics</h3>

<p><code>geom_curve_outline()</code> understands the following aesthetics:
</p>

<ul>
<li> <p><code>ip</code>: An <code><a href="ipaddress.html#topic+ip_network">ip_network</a></code> column. By default, the
entire Hilbert curve is shown.
</p>
</li>
<li> <p><code>curve_order</code>: How nested is the curve? (default: <code>3</code>).
</p>
</li>
<li> <p><code>closed</code>: Should the curve outline have closed ends? (default: <code>FALSE</code>).
</p>
</li>
<li> <p><code>alpha</code>
</p>
</li>
<li> <p><code>colour</code>
</p>
</li>
<li> <p><code>linetype</code>
</p>
</li>
<li> <p><code>linewidth</code>
</p>
</li></ul>



<h3>Computed variables</h3>


<dl>
<dt>x, y</dt><dd><p>The start coordinates for the segment</p>
</dd>
<dt>xend, yend</dt><dd><p>The end coordinates for the segment</p>
</dd>
</dl>



<h3>Examples</h3>

<pre><code class='language-R'>p &lt;- ggplot() + coord_ip() + theme_ip_light()

# default shows curve across entire canvas
p + geom_hilbert_outline()

# only show subnetwork
p + geom_hilbert_outline(ip = ip_network("128.0.0.0/2"))

# increased nesting
p + geom_hilbert_outline(curve_order = 4)

# show multiple networks
df &lt;- data.frame(
  ip = ip_network(c("0.0.0.0/2", "128.0.0.0/4")),
  curve_order = c(4, 5),
  closed = c(FALSE, TRUE)
)
p + geom_hilbert_outline(
  aes(ip = ip, curve_order = curve_order, closed = closed),
  data = df
)
</code></pre>

<hr>
<h2 id='ip_to_cartesian'>Map IP data to Cartesian coordinates</h2><span id='topic+ip_to_cartesian'></span><span id='topic+address_to_cartesian'></span><span id='topic+network_to_cartesian'></span>

<h3>Description</h3>

<p>These functions are used internally by <code><a href="#topic+coord_ip">coord_ip()</a></code> to map
<code><a href="ipaddress.html#topic+ip_address">ip_address</a></code> and <code><a href="ipaddress.html#topic+ip_network">ip_network</a></code>
vectors to Cartesian coordinates. They are exposed externally to support use
of these coordinates outside of ggplot2.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>address_to_cartesian(
  address,
  canvas_network = ip_network("0.0.0.0/0"),
  pixel_prefix = 16,
  curve = c("hilbert", "morton")
)

network_to_cartesian(
  network,
  canvas_network = ip_network("0.0.0.0/0"),
  pixel_prefix = 16,
  curve = c("hilbert", "morton")
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ip_to_cartesian_+3A_address">address</code></td>
<td>
<p>An <code><a href="ipaddress.html#topic+ip_address">ip_address</a></code> vector</p>
</td></tr>
<tr><td><code id="ip_to_cartesian_+3A_canvas_network">canvas_network</code></td>
<td>
<p>An <code><a href="ipaddress.html#topic+ip_network">ip_network</a></code> scalar that
determines the region of IP space visualized by the entire 2D grid. The
default shows the entire IPv4 address space.</p>
</td></tr>
<tr><td><code id="ip_to_cartesian_+3A_pixel_prefix">pixel_prefix</code></td>
<td>
<p>An integer scalar that sets the prefix length of the
network represented by a single pixel. The default value is 16. Increasing
this effectively improves the resolution of the plot.</p>
</td></tr>
<tr><td><code id="ip_to_cartesian_+3A_curve">curve</code></td>
<td>
<p>A string to choose the space-filling curve. Choices are
<code>"hilbert"</code> (default) and <code>"morton"</code>.</p>
</td></tr>
<tr><td><code id="ip_to_cartesian_+3A_network">network</code></td>
<td>
<p>An <code><a href="ipaddress.html#topic+ip_network">ip_network</a></code> vector</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data.frame containing columns:
</p>

<ul>
<li> <p><code>address_to_cartesian()</code>: <code>x</code> and <code>y</code>
</p>
</li>
<li> <p><code>network_to_cartesian()</code>: <code>xmin</code>, <code>ymin</code>, <code>xmax</code> and <code>ymax</code>
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>address_to_cartesian(ip_address("192.168.0.1"))

network_to_cartesian(ip_network("224.0.0.0/4"))
</code></pre>

<hr>
<h2 id='stat_summary_address'>Summarize IP addresses on a heatmap</h2><span id='topic+stat_summary_address'></span>

<h3>Description</h3>

<p>Addresses are grouped into networks determined by the <code>pixel_prefix</code> argument
of <code>coord_ip()</code>. Then the <code>z</code> values are summarized with summary function <code>fun</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>stat_summary_address(
  mapping = NULL,
  data = NULL,
  ...,
  fun = NULL,
  fun.args = list(),
  na.rm = FALSE,
  show.legend = NA,
  inherit.aes = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="stat_summary_address_+3A_mapping">mapping</code></td>
<td>
<p>Set of aesthetic mappings created by <code><a href="ggplot2.html#topic+aes">aes()</a></code>. If specified and
<code>inherit.aes = TRUE</code> (the default), it is combined with the default mapping
at the top level of the plot. You must supply <code>mapping</code> if there is no plot
mapping.</p>
</td></tr>
<tr><td><code id="stat_summary_address_+3A_data">data</code></td>
<td>
<p>The data to be displayed in this layer. There are three
options:
</p>
<p>If <code>NULL</code>, the default, the data is inherited from the plot
data as specified in the call to <code><a href="ggplot2.html#topic+ggplot">ggplot()</a></code>.
</p>
<p>A <code>data.frame</code>, or other object, will override the plot
data. All objects will be fortified to produce a data frame. See
<code><a href="ggplot2.html#topic+fortify">fortify()</a></code> for which variables will be created.
</p>
<p>A <code>function</code> will be called with a single argument,
the plot data. The return value must be a <code>data.frame</code>, and
will be used as the layer data. A <code>function</code> can be created
from a <code>formula</code> (e.g. <code>~ head(.x, 10)</code>).</p>
</td></tr>
<tr><td><code id="stat_summary_address_+3A_...">...</code></td>
<td>
<p>Other arguments passed on to <code><a href="ggplot2.html#topic+layer">layer()</a></code>. These are
often aesthetics, used to set an aesthetic to a fixed value, like
<code>colour = "red"</code> or <code>size = 3</code>. They may also be parameters
to the paired geom/stat.</p>
</td></tr>
<tr><td><code id="stat_summary_address_+3A_fun">fun</code></td>
<td>
<p>Summary function (see section below for details). If <code>NULL</code> (the
default), the observations are simply counted.</p>
</td></tr>
<tr><td><code id="stat_summary_address_+3A_fun.args">fun.args</code></td>
<td>
<p>A list of extra arguments to pass to <code>fun</code>.</p>
</td></tr>
<tr><td><code id="stat_summary_address_+3A_na.rm">na.rm</code></td>
<td>
<p>If <code>FALSE</code>, the default, missing values are removed with
a warning. If <code>TRUE</code>, missing values are silently removed.</p>
</td></tr>
<tr><td><code id="stat_summary_address_+3A_show.legend">show.legend</code></td>
<td>
<p>logical. Should this layer be included in the legends?
<code>NA</code>, the default, includes if any aesthetics are mapped.
<code>FALSE</code> never includes, and <code>TRUE</code> always includes.
It can also be a named logical vector to finely select the aesthetics to
display.</p>
</td></tr>
<tr><td><code id="stat_summary_address_+3A_inherit.aes">inherit.aes</code></td>
<td>
<p>If <code>FALSE</code>, overrides the default aesthetics,
rather than combining with them. This is most useful for helper functions
that define both data and aesthetics and shouldn't inherit behaviour from
the default plot specification, e.g. <code><a href="ggplot2.html#topic+borders">borders()</a></code>.</p>
</td></tr>
</table>


<h3>Aesthetics</h3>

<p><code>stat_summary_address()</code> understands the following aesthetics (required
aesthetics are in bold):
</p>

<ul>
<li> <p><strong><code>ip</code></strong>: An <code><a href="ipaddress.html#topic+ip_address">ip_address</a></code> column
</p>
</li>
<li> <p><code>z</code>: Value passed to the summary function (required if <code>fun</code> is used)
</p>
</li>
<li> <p><code>fill</code>: Default is <code>after_stat(value)</code>
</p>
</li>
<li> <p><code>alpha</code>
</p>
</li></ul>



<h3>Computed variables</h3>

<p>The following variables are available to <code><a href="ggplot2.html#topic+aes_eval">after_stat()</a></code>:
</p>

<ul>
<li> <p><code>value</code>: Value of summary statistic
</p>
</li>
<li> <p><code>count</code>: Number of observations
</p>
</li></ul>



<h3>Summary function</h3>

<p>The <code>data</code> might contain multiple rows per pixel of the heatmap, so a summary
function reduces this information to a single value to display.
This function receives the <code>data</code> column specified by the <code>z</code> aesthetic
and also receives arguments specified by <code>fun.args</code>.
</p>
<p>The <code>fun</code> argument can be specified in multiple ways:
</p>

<dl>
<dt><code>NULL</code></dt><dd><p>If no summary function is provided, the number of observations
is computed. In this case, you don't need to specify the <code>z</code> aesthetic,
and the computed variables <code>value</code> and <code>count</code> will be equal.</p>
</dd>
<dt>string</dt><dd><p>The name of an existing function (e.g. <code>fun = "mean"</code>).</p>
</dd>
<dt>function</dt><dd><p>Either provide an existing function (e.g. <code>fun = mean</code>) or
define a new function (e.g. <code>fun = function(x) sum(x^2)</code>).</p>
</dd>
<dt>formula</dt><dd><p>A function can also be created from a formula. This uses <code>.x</code>
as the summarized variable (e.g. <code>fun = ~ sum(.x^2)</code>).</p>
</dd>
</dl>



<h3>Examples</h3>

<pre><code class='language-R'>dat &lt;- data.frame(
  ip = sample_ipv4(10000),
  weight = runif(10000)
)

p &lt;- ggplot(dat, aes(ip = ip)) +
  coord_ip() +
  theme_ip_light()

# simple count of observations
p +
  stat_summary_address() +
  scale_fill_viridis_c(trans = "log2", na.value = "black", guide = "none")

# compute mean weight
p +
  stat_summary_address(aes(z = weight), fun = ~ mean(.x)) +
  scale_fill_viridis_c(na.value = "black", guide = "none")
</code></pre>

<hr>
<h2 id='theme_ip'>Themes for IP data</h2><span id='topic+theme_ip'></span><span id='topic+theme_ip_light'></span><span id='topic+theme_ip_dark'></span>

<h3>Description</h3>

<p>These set sensible defaults for plots generated by ggip.
Use <code><a href="ggplot2.html#topic+theme">ggplot2::theme()</a></code> if you want to tweak the results.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>theme_ip_light(base_size = 11, base_family = "")

theme_ip_dark(
  background_color = "black",
  text_color = "white",
  base_size = 11,
  base_family = ""
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="theme_ip_+3A_base_size">base_size</code></td>
<td>
<p>base font size, given in pts.</p>
</td></tr>
<tr><td><code id="theme_ip_+3A_base_family">base_family</code></td>
<td>
<p>base font family</p>
</td></tr>
<tr><td><code id="theme_ip_+3A_background_color">background_color</code></td>
<td>
<p>Background color</p>
</td></tr>
<tr><td><code id="theme_ip_+3A_text_color">text_color</code></td>
<td>
<p>Text color</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>p &lt;- ggplot(data.frame(ip = ip_address("128.0.0.0"))) +
  geom_point(aes(x = ip$x, y = ip$y), color = "grey") +
  coord_ip()

p + theme_ip_light()

p + theme_ip_dark()
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
