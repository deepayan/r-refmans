<!DOCTYPE html><html lang="en"><head><title>Help for package lpacf</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {lpacf}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#lpacf-package'><p>Compute localized partial autocorrelation for locally stationary wavelet time series.</p></a></li>
<li><a href='#AutoBestBW.Epan'><p>Choose a good bandwidth for smoothing of a EWS</p>
spectral estimator using the Epanechnikov kernel.</a></li>
<li><a href='#lpacf'>
<p>Calculates the lpacf (local partial autocorrelation function).</p></a></li>
<li><a href='#lpacf.Epan'>
<p>Calculates the lpacf (local partial autocorrelation function) using an Epanechnikov kernel spectral smoother.</p></a></li>
<li><a href='#lpacf.plot'>
<p>Function to produce various plots of the lpacf.</p></a></li>
<li><a href='#plot.lpacf'><p>Plot localized partial autocorrelation information in an</p>
<code>lpacf</code> object.</a></li>
<li><a href='#print.lpacf'><p>Prints a <code>lpacf</code> object.</p></a></li>
<li><a href='#summary.lpacf'><p>Print out summary information about a <code>lpacf</code> object.</p></a></li>
<li><a href='#tvar2sim'>
<p>Simulate a realization from a particular TVAR(2) model.</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Local Partial Autocorrelation Function Estimation for Locally
Stationary Wavelet Processes</td>
</tr>
<tr>
<td>Version:</td>
<td>1.0.1</td>
</tr>
<tr>
<td>Date:</td>
<td>2023-05-12</td>
</tr>
<tr>
<td>Author:</td>
<td>Rebecca Killick [aut, cre],
  Guy Nason [aut],
  Marina Knight [aut],
  Matt Nunes [aut],
  Idris Eckley [ctb]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Rebecca Killick &lt;r.killick@lancs.ac.uk&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Provides the method for computing the local partial autocorrelation function for locally stationary wavelet time series from Killick, Knight, Nason, Eckley (2020) &lt;<a href="https://doi.org/10.1214%2F20-EJS1748">doi:10.1214/20-EJS1748</a>&gt;.</td>
</tr>
<tr>
<td>Depends:</td>
<td>R(&ge; 3.0), stats, locits, wavethresh, parallel, methods</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a></td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-05-12 09:31:52 UTC; killick</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-05-12 10:00:03 UTC</td>
</tr>
</table>
<hr>
<h2 id='lpacf-package'>Compute localized partial autocorrelation for locally stationary wavelet time series.
</h2><span id='topic+lpacf-package'></span>

<h3>Description</h3>

<p>This package computes a localized partial autocorrelation of a time series assuming a locally stationary wavelet model.</p>


<h3>Details</h3>


<table>
<tr>
 <td style="text-align: left;">
Package: </td><td style="text-align: left;"> lpacf</td>
</tr>
<tr>
 <td style="text-align: left;">
Type: </td><td style="text-align: left;"> Package</td>
</tr>
<tr>
 <td style="text-align: left;">
Version: </td><td style="text-align: left;"> 1.0.1</td>
</tr>
<tr>
 <td style="text-align: left;">
Date: </td><td style="text-align: left;"> 2023-05-12</td>
</tr>
<tr>
 <td style="text-align: left;">
License: </td><td style="text-align: left;"> GPL-2</td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>

<p>The <code><a href="#topic+lpacf">lpacf</a></code> function computes the localized partial autocorrelation
of a locally stationary time series. The resultant object can be printed using
<code><a href="#topic+print.lpacf">print.lpacf</a></code> or plotted by <code><a href="#topic+plot.lpacf">plot.lpacf</a></code>.
</p>


<h3>Author(s)</h3>

<p>Rebecca Killick, Marina Knight, Guy Nason and Matt Nunes
</p>
<p>Maintainer: Rebecca Killick &lt;r.killick@lancs.ac.uk&gt;
</p>


<h3>References</h3>

<p>Killick, R., Knight, M. I., Nason, G.P. and Eckley, I. A. (2020) 
The local partial autocorrelation function and some applications. 
<em>Electron. J. Statist.</em> <b>14</b> (2), 3268-3314. 
DOI: <a href="https://www.doi.org/">10.1214/20-EJS1748</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+lpacf">lpacf</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#
# See examples in each of the functions' help pages linked above.
#
</code></pre>

<hr>
<h2 id='AutoBestBW.Epan'>Choose a good bandwidth for smoothing of a EWS
spectral estimator using the Epanechnikov kernel.
</h2><span id='topic+AutoBestBW.Epan'></span>

<h3>Description</h3>

<p>Computes Epanechnikov kernel estimator closest to wavelet estimator of
evolutionary wavelet spectrum.
The idea is to obtain a good linear bandwidth.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>AutoBestBW.Epan(x, filter.number = 1, family = "DaubExPhase",
    smooth.dev = var, AutoReflect = TRUE, tol = 0.1, maxits = 5,
    plot.it = FALSE, verbose = 0, ReturnAll = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="AutoBestBW.Epan_+3A_x">x</code></td>
<td>

<p>Time series you want to analyze.
</p>
</td></tr>
<tr><td><code id="AutoBestBW.Epan_+3A_filter.number">filter.number</code></td>
<td>

<p>The wavelet filter used to carry out smoothing operations.
</p>
</td></tr>
<tr><td><code id="AutoBestBW.Epan_+3A_family">family</code></td>
<td>

<p>The wavelet family used to carry out smoothing operations.
</p>
</td></tr>
<tr><td><code id="AutoBestBW.Epan_+3A_smooth.dev">smooth.dev</code></td>
<td>

<p>The deviance estimate used for the smoothing (see ewspec help)
</p>
</td></tr>
<tr><td><code id="AutoBestBW.Epan_+3A_autoreflect">AutoReflect</code></td>
<td>

<p>Mitigate periodic boundary conditions of wavelet transforms
by reflecting time series about RHS end before taking 
transforms (and is undone before returning the answer).	
</p>
</td></tr>
<tr><td><code id="AutoBestBW.Epan_+3A_tol">tol</code></td>
<td>

<p>Tolerance for golden section search for the best bandwidth
</p>
</td></tr>
<tr><td><code id="AutoBestBW.Epan_+3A_maxits">maxits</code></td>
<td>

<p>Maximum number of iterations for the golden section search
</p>
</td></tr>
<tr><td><code id="AutoBestBW.Epan_+3A_plot.it">plot.it</code></td>
<td>

<p>Plot the values of the bandwidth and its closeness of the
linear smooth to the wavelet smooth, if TRUE.
</p>
</td></tr>
<tr><td><code id="AutoBestBW.Epan_+3A_verbose">verbose</code></td>
<td>

<p>If nonzero prints out informative messages about the progress
of the golden section search. Higher integers produce more
messages.
</p>
</td></tr>
<tr><td><code id="AutoBestBW.Epan_+3A_returnall">ReturnAll</code></td>
<td>

<p>If TRUE then return the best bandwidth (in the ans component),
the wavelet smooth (in EWS.wavelet) and the closest linear
smooth (EWS.linear). If FALSE then just the bandwidth is returned.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Tries to find the best running mean fit to an estimated
spectrum obtained via wavelet shrinkage. The goal is to try
and find a reasonable linear bandwidth.
</p>


<h3>Value</h3>

<p>If ReturnAll argument is FALSE then the best bandwidth
is returned.
</p>


<h3>Author(s)</h3>

<p>Guy Nason.
</p>


<h3>References</h3>

<p>Nason, G.P. (2013) A test for second-order stationarity and
approximate confidence intervals for localized autocovariances
for locally stationary time series. <em>J. R. Statist. Soc.</em> B,
<b>75</b>, 879-904.</p>


<h3>See Also</h3>

<p><code><a href="locits.html#topic+AutoBestBW">AutoBestBW</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>#
# Generate synthetic data
#
x &lt;- rnorm(256)
#
# Compute best linear bandwidth
#
tmp &lt;- AutoBestBW(x=x)
#
# Printing it out in my example gives:
# tmp
# [1] 168
</code></pre>

<hr>
<h2 id='lpacf'>
Calculates the lpacf (local partial autocorrelation function).
</h2><span id='topic+lpacf'></span>

<h3>Description</h3>

<p>This calculates the local partial autocorrelation function for data <code>x</code>.  Up to <code>lag.max</code> lags are calculated.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lpacf(x, binwidth, lag.max=NULL, filter.number=10, family="DaubLeAsymm", smooth.dev=var,
    AutoReflect=TRUE, tol=0.1, maxits=5, ABBverbose=0, lapplyfn=lapply,allpoints=FALSE, 
    verbose=FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="lpacf_+3A_x">x</code></td>
<td>
<p>The time series you wish to analyze
</p>
</td></tr>
<tr><td><code id="lpacf_+3A_binwidth">binwidth</code></td>
<td>
<p>The bandwidth for the
spectral smoothing. If the argument is missing or zero then the bandwidth
is chosen automatically using the <code>AutoBestBW</code> function from the
<code>locits</code> package. The smoothing is a simple running mean.
</p>
</td></tr>
<tr><td><code id="lpacf_+3A_lag.max">lag.max</code></td>
<td>
<p>The maximum lag of pacf required. If this argument is
<code>NULL</code> then the maximum lag is computed internally to
be <code>floor(10*log10(n))</code> where n is the length of the series.
E.g. if n=512 then the <code>lag.max</code> will be set to 27.
</p>
</td></tr>
<tr><td><code id="lpacf_+3A_filter.number">filter.number</code></td>
<td>
<p>The wavelet filter number for helping choose
the smoothing <code>binwidth</code>, used only by <code>AutoBestBW</code>.
</p>
</td></tr>
<tr><td><code id="lpacf_+3A_family">family</code></td>
<td>
<p>The wavelet family for helping choose the smoothing
<code>binwidth</code>, used only by <code>AutoBestBW</code>.
</p>
</td></tr>
<tr><td><code id="lpacf_+3A_smooth.dev">smooth.dev</code></td>
<td>
<p>The type of deviance used by <code>AutoBestBW</code>
to smooth an internal wavelet spectral estimate. The usual
variance <code>var</code> is a good option, but something like a
rescaled <code>mad</code> could be an alternative.
</p>
</td></tr>
<tr><td><code id="lpacf_+3A_autoreflect">AutoReflect</code></td>
<td>

<p>Mitigate periodic boundary conditions of wavelet transforms
by reflecting time series about RHS end before taking 
transforms (and is undone before returning the answer).	
Setting this to be <code>TRUE</code> usually dramatically improves
the results as the wavelet smoothing is performed using periodic
transforms.
</p>
</td></tr>
<tr><td><code id="lpacf_+3A_tol">tol</code></td>
<td>

<p>Tolerance for golden section search for the best bandwidth used
only by <code>AutoBestBW</code>.
</p>
</td></tr>
<tr><td><code id="lpacf_+3A_maxits">maxits</code></td>
<td>

<p>Maximum number of iterations for the golden section search used by
<code>AutoBestBW</code>.
</p>
</td></tr>
<tr><td><code id="lpacf_+3A_abbverbose">ABBverbose</code></td>
<td>

<p>If nonzero prints out informative messages about the progress
of the golden section search. Higher integers produce more
messages. Setting it to zero suppresses messages.
</p>
</td></tr>
<tr><td><code id="lpacf_+3A_lapplyfn">lapplyfn</code></td>
<td>
<p>Function which applies a specified function to a vector.  lapply is default but this argument can be used to replace this by something more efficient, e.g. a parallel version such as <code>mclapply</code>. Note, if you
use <code>mclapply</code> then you should set the option <code>mc.cores</code> to something
sensible. E.g. I have a quad-core machine, so when I am using the machine
myself, alone, I set <code>options(mc.cores=4)</code>. If you have many cores on a
multicore machine, but with several users, you might want the number of
codes to be used by your code to be less than the max to be nice to others.
</p>
</td></tr>
<tr><td><code id="lpacf_+3A_allpoints">allpoints</code></td>
<td>
<p>The lpacf is calculated using a window centered on a time point, if allpoints=TRUE then the edges of the data are also estimated (where a smaller, non-centered binwidth is used). Note, if <code>allpoints=TRUE</code> you obtain
an estimator for the whole length of the series, but it will be more
variable nearer the ends.</p>
</td></tr>
<tr><td><code id="lpacf_+3A_verbose">verbose</code></td>
<td>
<p>If <code>TRUE</code> then some informative messages are printed,
otherwise they're not</p>
</td></tr>
<tr><td><code id="lpacf_+3A_...">...</code></td>
<td>
<p>Other arguments for <code><a href="locits.html#topic+AutoBestBW">AutoBestBW</a></code>.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Calculates the local partial autocorrelation function (lpacf) for 1,...,<code>lag.max</code> lags.   See paper in the references for more details.
NOTE: Often when local (windowed) estimates are created one assigns the estimated value to the central point in the window.  This is the approach we take here when calculating the lacv and lpacf.  This differs from the lpacf calculated for the <code><a href="forecastLSW.html#topic+forecastlpacf">forecastlpacf</a></code> function which assign the estimated value to the last point in the window.
</p>
<p>The function works by using the regular R <code>pacf</code> applied to carefully
chosen windows of the original series. Note: code in the
<code>forecastlpacf</code> from the <code>forecastLSW</code> package can compute a slightly different version of the
localized pacf using a wavelet method.
</p>


<h3>Value</h3>

<p>An object of class <code>lpacf</code>. This is a list with the following
components:
</p>
<table role = "presentation">
<tr><td><code>the.x</code></td>
<td>
<p>the time coordinates of the localized partial autocorrelations.
Call the length of this vector n.
These coordinates can be non-integer (usually at halves) even
if the original times are at the integers (which is assumed by
this function). You can think of these indexing the value of
the localized partial autocorrelation centred at these locations.</p>
</td></tr>
<tr><td><code>lpacf</code></td>
<td>
<p>The localized partical autocorrelations.
Matrix of dimension n x <code>lag.max</code> containing the lpacf for each time point at lags 1,...,<code>lag.max</code>.</p>
</td></tr>
<tr><td><code>the.vacc</code></td>
<td>
<p>This is <code>TRUE</code> if <code>allpoints=TRUE</code> and <code>FALSE</code>
otherwise.</p>
</td></tr>
<tr><td><code>the.x1</code></td>
<td>
<p>If <code>allpoints=TRUE</code> this vector contains the 
x coordinate (time coordinate) values of the left-hand end of
the series that are computed using increasingly reduced numbers of
data points.</p>
</td></tr>
<tr><td><code>the.x2</code></td>
<td>
<p>As for <code>the.x1</code> but for the right-hand end of the series.</p>
</td></tr>
<tr><td><code>vacc</code></td>
<td>
<p>A vector of length two containing the interval of time points for
which the localized autocovariance is computed using the largest
number of points in the calculation &mdash; ie the full binwidth.</p>
</td></tr>
<tr><td><code>binwidth</code></td>
<td>
<p>The smoothing binwidth that was used.</p>
</td></tr>
<tr><td><code>AutoBinWidth</code></td>
<td>
<p>This is <code>TRUE</code> if the binwidth was automatically
selected, and <code>FALSE</code> if it was not.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Guy Nason and Rebecca Killick
</p>


<h3>References</h3>

<p>Killick, R., Knight, M. I., Nason, G.P. and Eckley, I. A. (2020) The local partial autocorrelation function and some applications. <em>Electron. J. Statist.</em> <b>14</b> (2), 3268-3314. DOI: <a href="https://www.doi.org/">10.1214/20-EJS1748</a>. 
</p>


<h3>See Also</h3>

<p><code><a href="#topic+lpacf.plot">lpacf.plot</a></code>, <code><a href="forecastLSW.html#topic+forecastlpacf">forecastlpacf</a></code>,
<code>plot.lacf</code>, <code><a href="#topic+print.lpacf">print.lpacf</a></code>, <code><a href="#topic+summary.lpacf">summary.lpacf</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# first generate a time-varying process
set.seed(1)
x=tvar2sim()

x.lpacf &lt;- lpacf(x)

#
# There are two functions to plot lpacf class objects
#
# One is via the generic function plot which uses plot.lpacf
# the other is a bespoke function lpact.plot. We'll look at
# the generic function first which behaves similarly to the equivalent
# function in the locits package: plot.lacf
#
#
# This plot shows all of the localized partial autocovariances up to lag 27
# which is the default calculated value for this length of time series.
plot(x.lpacf)

#
# In the previous plot, maybe there were too many lags. So, let's restrict to
# five lags and colour them differently.
#
plot(x.lpacf, lags=1:5, lcol=1:5)
#
# By default, the lpacf is not computed for the whole time series range.
# Let's do it for all the points now, and replot.
#
x.lpacf.all &lt;- lpacf(x, allpoints=TRUE)
plot(x.lpacf.all, lags=1:5, lcol=1:5)
#
#
# Suppose we wanted to look at the localized partial autocorrelation at a
# particular time point, using the regular acf-like plot. We can do this by:
#
# We will choose the time point to examine the localized pacf at as 150.
#
plot(x.lpacf, type="acf", the.time=150)

# calculate the lpacf
ans&lt;-lpacf(x,lag.max=10,filter.number=2,family="DaubExPhase")

# then maybe plot it by lag
lpacf.plot(ans,atLag=1:10,atTime=150)

</code></pre>

<hr>
<h2 id='lpacf.Epan'>
Calculates the lpacf (local partial autocorrelation function) using an Epanechnikov kernel spectral smoother.
</h2><span id='topic+lpacf.Epan'></span>

<h3>Description</h3>

<p>This calculates the local partial autocorrelation function for data <code>x</code> based on spectral smoothing using the Epanechnikov kernel.  Up to <code>lag.max</code> lags are calculated.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lpacf.Epan(x, binwidth, lag.max=NULL, filter.number=10, family="DaubLeAsymm", 
    smooth.dev=var, AutoReflect=TRUE, tol=0.1, maxits=5, ABBverbose=0, lapplyfn=lapply,
    allpoints=FALSE, verbose=FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="lpacf.Epan_+3A_x">x</code></td>
<td>
<p>The time series you wish to analyze
</p>
</td></tr>
<tr><td><code id="lpacf.Epan_+3A_binwidth">binwidth</code></td>
<td>
<p>The bandwidth for the spectral smoothing. If the argument is missing or zero then the bandwidth
is chosen automatically using the <code>AutoBestBW.Epan</code> function. The smoothing is done using the Epanechnikov kernel in the <code>Epanechnikov</code> function.
</p>
</td></tr>
<tr><td><code id="lpacf.Epan_+3A_lag.max">lag.max</code></td>
<td>
<p>The maximum lag of pacf required. If this argument is
<code>NULL</code> then the maximum lag is computed internally to
be <code>floor(10*log10(n))</code> where n is the length of the series.
E.g. if n=512 then the <code>lag.max</code> will be set to 27.
</p>
</td></tr>
<tr><td><code id="lpacf.Epan_+3A_filter.number">filter.number</code></td>
<td>
<p>The wavelet filter number for helping choose
the smoothing <code>binwidth</code>, used only by <code>AutoBestBW</code>.
</p>
</td></tr>
<tr><td><code id="lpacf.Epan_+3A_family">family</code></td>
<td>
<p>The wavelet family for helping choose the smoothing
<code>binwidth</code>, used only by <code>AutoBestBW</code>.
</p>
</td></tr>
<tr><td><code id="lpacf.Epan_+3A_smooth.dev">smooth.dev</code></td>
<td>
<p>The type of deviance used by <code>AutoBestBW</code>
to smooth an internal wavelet spectral estimate. The usual
variance <code>var</code> is a good option, but something like a
rescaled <code>mad</code> could be an alternative.
</p>
</td></tr>
<tr><td><code id="lpacf.Epan_+3A_autoreflect">AutoReflect</code></td>
<td>

<p>Mitigate periodic boundary conditions of wavelet transforms
by reflecting time series about RHS end before taking 
transforms (and is undone before returning the answer).	
Setting this to be <code>TRUE</code> usually dramatically improves
the results as the wavelet smoothing is performed using periodic
transforms.
</p>
</td></tr>
<tr><td><code id="lpacf.Epan_+3A_tol">tol</code></td>
<td>

<p>Tolerance for golden section search for the best bandwidth used
only by <code>AutoBestBW</code>.
</p>
</td></tr>
<tr><td><code id="lpacf.Epan_+3A_maxits">maxits</code></td>
<td>

<p>Maximum number of iterations for the golden section search used by
<code>AutoBestBW</code>.
</p>
</td></tr>
<tr><td><code id="lpacf.Epan_+3A_abbverbose">ABBverbose</code></td>
<td>

<p>If nonzero prints out informative messages about the progress
of the golden section search. Higher integers produce more
messages. Setting it to zero suppresses messages.
</p>
</td></tr>
<tr><td><code id="lpacf.Epan_+3A_lapplyfn">lapplyfn</code></td>
<td>
<p>Function which applies a specified function to a vector.  lapply is default but this argument can be used to replace this by something more efficient, e.g. a parallel version such as <code>mclapply</code>. Note, if you
use <code>mclapply</code> then you should set the option <code>mc.cores</code> to something
sensible. E.g. I have a quad-core machine, so when I am using the machine
myself, alone, I set <code>options(mc.cores=4)</code>. If you have many cores on a
multicore machine, but with several users, you might want the number of
codes to be used by your code to be less than the max to be nice to others.
</p>
</td></tr>
<tr><td><code id="lpacf.Epan_+3A_allpoints">allpoints</code></td>
<td>
<p>The lpacf is calculated using a window centered on a time point, if allpoints=TRUE then the edges of the data are also estimated (where a smaller, non-centered binwidth is used). Note, if <code>allpoints=TRUE</code> you obtain
an estimator for the whole length of the series, but it will be more
variable nearer the ends.</p>
</td></tr>
<tr><td><code id="lpacf.Epan_+3A_verbose">verbose</code></td>
<td>
<p>If <code>TRUE</code> then some informative messages are printed,
otherwise they're not</p>
</td></tr>
<tr><td><code id="lpacf.Epan_+3A_...">...</code></td>
<td>
<p>Other arguments for <code><a href="locits.html#topic+AutoBestBW">AutoBestBW</a></code>.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Calculates the local partial autocorrelation function (lpacf) for 1,...,<code>lag.max</code> lags.   See paper in the references for more details.
NOTE: Often when local (windowed) estimates are created one assigns the estimated value to the central point in the window.  This is the approach we take here when calculating the lacv and lpacf.  This differs from the lpacf calculated for the <code><a href="forecastLSW.html#topic+forecastlpacf">forecastlpacf</a></code> function which assign the estimated value to the last point in the window.
</p>
<p>The function works by using the regular R <code>pacf</code> applied to carefully
chosen windows of the original series. Note: code in the
<code>forecastlpacf</code> from the <code>forecastLSW</code> package can compute a slightly different version of the
localized pacf using a wavelet method.
</p>


<h3>Value</h3>

<p>An object of class <code>lpacf</code>. This is a list with the following
components:
</p>
<table role = "presentation">
<tr><td><code>the.x</code></td>
<td>
<p>the time coordinates of the localized partial autocorrelations.
Call the length of this vector n.
These coordinates can be non-integer (usually at halves) even
if the original times are at the integers (which is assumed by
this function). You can think of these indexing the value of
the localized partial autocorrelation centred at these locations.</p>
</td></tr>
<tr><td><code>lpacf</code></td>
<td>
<p>The localized partical autocorrelations.
Matrix of dimension n x <code>lag.max</code> containing the lpacf for each time point at lags 1,...,<code>lag.max</code>.</p>
</td></tr>
<tr><td><code>the.vacc</code></td>
<td>
<p>This is <code>TRUE</code> if <code>allpoints=TRUE</code> and <code>FALSE</code>
otherwise.</p>
</td></tr>
<tr><td><code>the.x1</code></td>
<td>
<p>If <code>allpoints=TRUE</code> this vector contains the 
x coordinate (time coordinate) values of the left-hand end of
the series that are computed using increasingly reduced numbers of
data points.</p>
</td></tr>
<tr><td><code>the.x2</code></td>
<td>
<p>As for <code>the.x1</code> but for the right-hand end of the series.</p>
</td></tr>
<tr><td><code>vacc</code></td>
<td>
<p>A vector of length two containing the interval of time points for
which the localized autocovariance is computed using the largest
number of points in the calculation &mdash; ie the full binwidth.</p>
</td></tr>
<tr><td><code>binwidth</code></td>
<td>
<p>The smoothing binwidth that was used.</p>
</td></tr>
<tr><td><code>AutoBinWidth</code></td>
<td>
<p>This is <code>TRUE</code> if the binwidth was automatically
selected, and <code>FALSE</code> if it was not.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Guy Nason and Rebecca Killick
</p>


<h3>References</h3>

<p>Killick, R., Knight, M. I., Nason, G.P. and Eckley, I. A. (2020) The local partial autocorrelation function and some applications. <em>Electron. J. Statist.</em> <b>14</b> (2), 3268-3314. DOI: <a href="https://www.doi.org/">10.1214/20-EJS1748</a>. 
</p>


<h3>See Also</h3>

<p><code><a href="#topic+lpacf">lpacf</a></code>, <code><a href="#topic+lpacf.plot">lpacf.plot</a></code>, <code><a href="forecastLSW.html#topic+forecastlpacf">forecastlpacf</a></code>,
<code>plot.lacf</code>, <code><a href="#topic+print.lpacf">print.lpacf</a></code>, <code><a href="#topic+summary.lpacf">summary.lpacf</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# first generate a time-varying process
set.seed(1)
x=tvar2sim()

x.lpacf &lt;- lpacf(x)

#
# There are two functions to plot lpacf class objects
#
# One is via the generic function plot which uses plot.lpacf
# the other is a bespoke function lpact.plot. We'll look at
# the generic function first which behaves similarly to the equivalent
# function in the locits package: plot.lacf
#
#
# This plot shows all of the localized partial autocovariances up to lag 27
# which is the default calculated value for this length of time series.
plot(x.lpacf)

#
# In the previous plot, maybe there were too many lags. So, let's restrict to
# five lags and colour them differently.
#
plot(x.lpacf, lags=1:5, lcol=1:5)
#
# By default, the lpacf is not computed for the whole time series range.
# Let's do it for all the points now, and replot.
#
x.lpacf.all &lt;- lpacf(x, allpoints=TRUE)
plot(x.lpacf.all, lags=1:5, lcol=1:5)
#
#
# Suppose we wanted to look at the localized partial autocorrelation at a
# particular time point, using the regular acf-like plot. We can do this by:
#
# We will choose the time point to examine the localized pacf at as 150.
#
plot(x.lpacf, type="acf", the.time=150)

# calculate the lpacf
ans&lt;-lpacf.Epan(x,lag.max=10,filter.number=2,family="DaubExPhase")

# then maybe plot it by lag
lpacf.plot(ans,atLag=1:10,atTime=100)

</code></pre>

<hr>
<h2 id='lpacf.plot'>
Function to produce various plots of the lpacf.
</h2><span id='topic+lpacf.plot'></span>

<h3>Description</h3>

<p>This function can produce plots of the lpacf at specified times and/or lags.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lpacf.plot(lpacf,atTime=NULL,atLag=NULL,SaveToFile=FALSE,alpha=0.95,...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="lpacf.plot_+3A_lpacf">lpacf</code></td>
<td>
<p>An object produced by <code>lpacf</code>.
</p>
</td></tr>
<tr><td><code id="lpacf.plot_+3A_attime">atTime</code></td>
<td>
<p>Vector of the times of the <code>lpacf</code> to be plotted named according to <code>lpacf$the.x</code>.
</p>
</td></tr>
<tr><td><code id="lpacf.plot_+3A_atlag">atLag</code></td>
<td>
<p>Vector of the lags (columns) of the <code>lpacf</code> to be plotted.
</p>
</td></tr>
<tr><td><code id="lpacf.plot_+3A_savetofile">SaveToFile</code></td>
<td>
<p>If large numbers of plots are needed then set <code>SaveToFile=TRUE</code> to save them to a file.  By default this will save in the current working directory with the name <code>Rplotlpacf%03d.pdf</code>.
</p>
</td></tr>
<tr><td><code id="lpacf.plot_+3A_alpha">alpha</code></td>
<td>
<p>alpha level for the confidence intervals, default 95% confidence.
</p>
</td></tr>
<tr><td><code id="lpacf.plot_+3A_...">...</code></td>
<td>
<p>Additional arguments can be supplied which will be passed to <code>plot</code>.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Produces the desired 1-d plots of the lpacf at times and lags as specified by <code>atTime</code> and <code>atLag</code>.
</p>


<h3>Value</h3>

<p>Silently returns the desired 1-d plots of the lpacf at times and lags as specified by <code>atTime</code> and <code>atLag</code>.  If <code>SaveToFile=TRUE</code> then these are saved to a file in the current working directory rather than displayed.
</p>


<h3>Author(s)</h3>

<p>Rebecca Killick
</p>


<h3>See Also</h3>

<p><code><a href="#topic+lpacf">lpacf</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># first generate a time-varying process
set.seed(879)
x=tvar2sim()

# calculate the lpacf
ans&lt;-lpacf(x,lag.max=10,filter.number=2,family="DaubExPhase")

# then plot it at the first 10 lags at a couple of points in the data.
lpacf.plot(ans,atLag=1:10,atTime=c(150,350))
</code></pre>

<hr>
<h2 id='plot.lpacf'>Plot localized partial autocorrelation information in an
<code>lpacf</code> object. 
</h2><span id='topic+plot.lpacf'></span>

<h3>Description</h3>

<p>Plots information contained within a <code>lpacf</code> object.
Plot arrangement and options are similar to that in <code>plot.lacf</code>
in the <code>locits</code> package. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'lpacf'
plot(x, type = "line", lags = 1:min(as.integer(10 * log10(nrow(x$lpacf))),
    ncol(x$lpacf) - 1), tcex = 1, lcol = 1, llty = 1, the.time = NULL, plot.it = TRUE, 
    xlab, ylab, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot.lpacf_+3A_x">x</code></td>
<td>
<p>The <code>lpacf</code> class object you wish to plot.
</p>
</td></tr>
<tr><td><code id="plot.lpacf_+3A_type">type</code></td>
<td>
<p>The type of plot you want. This can be <code>"line"</code> where
each partial autocorrelation is plotted as a line over time, or
<code>"persp"</code> where the partial autocorrelation across time and lag
is plotted or <code>"acf"</code> where a regular-style plot is drawn,
like the one produced by the standard R <code>acf</code> function, and
this is the partial autocorrelation fixed at a given point in time.
</p>
</td></tr>
<tr><td><code id="plot.lpacf_+3A_lags">lags</code></td>
<td>
<p>A vector of integers containing the lags you wish to show.
Note that, unlike regular autocorrelation, the smallest lag is lag one.
</p>
</td></tr>
<tr><td><code id="plot.lpacf_+3A_tcex">tcex</code></td>
<td>
<p>For the <code>type="line"</code> plot integers are displayed along
the lines of their corresponding partial autocorrelations. This
parameter controls the scaling of the lag numbers.
</p>
</td></tr>
<tr><td><code id="plot.lpacf_+3A_lcol">lcol</code></td>
<td>
<p>A vector of colors, the same length as the <code>lags</code> vector
which controls the colour of each line corresponding to each partial
autocorrelation line.
</p>
</td></tr>
<tr><td><code id="plot.lpacf_+3A_llty">llty</code></td>
<td>
<p>As for <code>lcol</code> but the line types of each line.
</p>
</td></tr>
<tr><td><code id="plot.lpacf_+3A_the.time">the.time</code></td>
<td>
<p>A time has to be specified for the <code>type="acf"</code> plot,
as this argument supplies it.
</p>
</td></tr>
<tr><td><code id="plot.lpacf_+3A_plot.it">plot.it</code></td>
<td>
<p>If <code>TRUE</code> a plot is produced. If <code>FALSE</code> then
no plot is produced but the function still executes and produces
the same (invisible) output.
</p>
</td></tr>
<tr><td><code id="plot.lpacf_+3A_xlab">xlab</code></td>
<td>
<p>A label for the x-axis.
</p>
</td></tr>
<tr><td><code id="plot.lpacf_+3A_ylab">ylab</code></td>
<td>
<p>A label for the y-axis
</p>
</td></tr>
<tr><td><code id="plot.lpacf_+3A_...">...</code></td>
<td>
<p>Other arguments to plot.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Produces a graphical representation of localized
partial autocorrelation.
</p>


<h3>Value</h3>

<p>The localized partial autocorrelation values are returned. 
Essentially the ones that are, or would have been, plotted are
returned. The lags can be selected using the <code>lags</code> argument.
A matrix is returned: each row corresponds to a time point, each
column corresponds to a lag. All time points are returned.
Only the lags specified in the <code>lags</code> component are returned.
The <code>dimnames</code> component indicates which lags were returned.
</p>


<h3>Note</h3>

<p>This function was adapted from <code>plot.lacf</code> from the <code>locits</code>
package.
</p>


<h3>Author(s)</h3>

<p>Guy Nason
</p>


<h3>References</h3>

<p>Killick, R., Knight, M. I., Nason, G.P. and Eckley, I. A. (2020) The local partial autocorrelation function and some applications. <em>Electron. J. Statist.</em> <b>14</b> (2), 3268-3314. DOI: <a href="https://www.doi.org/">10.1214/20-EJS1748</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+lpacf">lpacf</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#
# Generate a test series
#
x.test &lt;- tvar2sim()
#
# Compute its localized partial autocorrelation
#
x.lpacf &lt;- lpacf(x.test)
#
# Perform a line plot of the localized partial autocorrelation of x
#	draw the lags in colours 1 thru 5
#
#
plot(x.lpacf, lags=1:5, lcol=1:5)
#
# Now produce the same plot, but omit lag 3
#
plot(x.lpacf, lags=c(1,2,4,5), lcol=c(1,2,4,5))
#
# Now plot localized autocovariance around time 175 using the regular acf
# style plot. 
#
plot(x.lpacf, type="acf", the.time=175)
</code></pre>

<hr>
<h2 id='print.lpacf'>Prints a <code>lpacf</code> object.
</h2><span id='topic+print.lpacf'></span>

<h3>Description</h3>

<p>Prints a <code>lpacf</code> object, basically telling you what's
there.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'lpacf'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="print.lpacf_+3A_x">x</code></td>
<td>
<p>The <code>lpacf</code> object to print.
</p>
</td></tr>
<tr><td><code id="print.lpacf_+3A_...">...</code></td>
<td>
<p>Other arguments
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Prints a <code>lpacf</code> object.
</p>


<h3>Value</h3>

<p>None
</p>


<h3>Author(s)</h3>

<p>Guy Nason
</p>


<h3>References</h3>

<p>Killick, R., Knight, M. I., Nason, G.P. and Eckley, I. A. (2020) The local partial autocorrelation function and some applications. <em>Electron. J. Statist.</em> <b>14</b> (2), 3268-3314. DOI: <a href="https://www.doi.org/">10.1214/20-EJS1748</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+lpacf">lpacf</a></code>, <code><a href="#topic+summary.lpacf">summary.lpacf</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#
# Simulate an example
#
x.test &lt;- tvar2sim()
#
# Compute the lpacf
#
x.lpacf &lt;- lpacf(x.test)
#
# Print it out - note, can normally just type name of object
#
print(x.lpacf)
#Class 'lpacf' : Localized Partial Autocorrelation Object:
#       ~~~~  : List with 5 components with names
#              the.x lpacf the.vacc binwidth AutoBinWidth 
#
#
#summary(.):
#----------
#Number of times:  220 
#Number of lags:  27 
#Range of times from:  147  to  366 
#Part series was analyzed (alltimes=FALSE)
#Smoothing binwidth used was:  293 
#        Binwidth was chosen automatically
</code></pre>

<hr>
<h2 id='summary.lpacf'>Print out summary information about a <code>lpacf</code> object.
</h2><span id='topic+summary.lpacf'></span>

<h3>Description</h3>

<p>Print out summary information about a <code>lpacf</code> object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'lpacf'
summary(object, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="summary.lpacf_+3A_object">object</code></td>
<td>
<p>The <code>lpacf</code> object you want to print out summary info for.
</p>
</td></tr>
<tr><td><code id="summary.lpacf_+3A_...">...</code></td>
<td>
<p>Other arguments
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Prints out number of times that we have localized partial
autocorrelation for and the number of lags computed. The localized
partial autocorrelation is computed at a number of time points that
might not be identical to the times in the original series, this
function prints out the min and max of the range of times and
an indicator of whether the whole series' localized pacf was computed.
The bandwidth associated with spectral smoothing is printed and
a note made of whether it was computed automatically or supplied
as an earlier argument.
</p>


<h3>Value</h3>

<p>None
</p>


<h3>Author(s)</h3>

<p>Guy Nason
</p>


<h3>References</h3>

<p>Killick, R., Knight, M. I., Nason, G.P. and Eckley, I. A. (2020) The local partial autocorrelation function and some applications. <em>Electron. J. Statist.</em> <b>14</b> (2), 3268-3314. DOI: <a href="https://www.doi.org/">10.1214/20-EJS1748</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+lpacf">lpacf</a></code>, <code>print.lacf</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#
# See example for print.lacf
#
</code></pre>

<hr>
<h2 id='tvar2sim'>
Simulate a realization from a particular TVAR(2) model.
</h2><span id='topic+tvar2sim'></span>

<h3>Description</h3>

<p>Simulates a realization from a TVAR(2) model where
both parameters move from -1.1 to 0.5 in equal steps
over 512 time points. The realization is of length 512.
The innovations are normally distributed with mean zero and
standard deviation of <code>sd</code>. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tvar2sim(sd = 1)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="tvar2sim_+3A_sd">sd</code></td>
<td>
<p>This is the standard deviation of the Gaussian innovation.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is easily converted into one that does the
same thing but for a different sample size.
</p>


<h3>Value</h3>

<p>A realization of the aforementioned TVAR(2) process.
</p>


<h3>Author(s)</h3>

<p>Guy Nason.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+lpacf">lpacf</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#
# Generate realization from the TVAR(2) process
#
x &lt;- tvar2sim()
#
# Maybe plot it
#
ts.plot(x)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
