<!DOCTYPE html><html><head><title>Help for package httpuv</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {httpuv}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#encodeURI'><p>URI encoding/decoding</p></a></li>
<li><a href='#getRNGState'><p>Apply the value of .Random.seed to R's internal RNG state</p></a></li>
<li><a href='#httpuv-package'><p>HTTP and WebSocket server</p></a></li>
<li><a href='#interrupt'><p>Interrupt httpuv runloop</p></a></li>
<li><a href='#ipFamily'><p>Check whether an address is IPv4 or IPv6</p></a></li>
<li><a href='#listServers'><p>List all running httpuv servers</p></a></li>
<li><a href='#logLevel'><p>Get and set logging level</p></a></li>
<li><a href='#PipeServer'><p>PipeServer class</p></a></li>
<li><a href='#randomPort'><p>Find an open TCP port</p></a></li>
<li><a href='#rawToBase64'><p>Convert raw vector to Base64-encoded string</p></a></li>
<li><a href='#runServer'><p>Run a server</p></a></li>
<li><a href='#runStaticServer'><p>Serve a directory</p></a></li>
<li><a href='#Server'><p>Server class</p></a></li>
<li><a href='#service'><p>Process requests</p></a></li>
<li><a href='#startDaemonizedServer'><p>Create an HTTP/WebSocket daemonized server (deprecated)</p></a></li>
<li><a href='#startServer'><p>Create an HTTP/WebSocket server</p></a></li>
<li><a href='#staticPath'><p>Create a staticPath object</p></a></li>
<li><a href='#staticPathOptions'><p>Create options for static paths</p></a></li>
<li><a href='#stopAllServers'><p>Stop all servers</p></a></li>
<li><a href='#stopDaemonizedServer'><p>Stop a running daemonized server in Unix environments (deprecated)</p></a></li>
<li><a href='#stopServer'><p>Stop a server</p></a></li>
<li><a href='#WebServer'><p>WebServer class</p></a></li>
<li><a href='#WebSocket'><p>WebSocket class</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>HTTP and WebSocket Server Library</td>
</tr>
<tr>
<td>Version:</td>
<td>1.6.13</td>
</tr>
<tr>
<td>Description:</td>
<td>Provides low-level socket and protocol support for handling
    HTTP and WebSocket requests directly from within R. It is primarily
    intended as a building block for other packages, rather than making it
    particularly easy to create complete web applications using httpuv
    alone.  httpuv is built on top of the libuv and http-parser C
    libraries, both of which were developed by Joyent, Inc. (See LICENSE
    file for libuv and http-parser license information.)</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> | file LICENSE [expanded from: GPL (&ge; 2) | file LICENSE]</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/rstudio/httpuv">https://github.com/rstudio/httpuv</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/rstudio/httpuv/issues">https://github.com/rstudio/httpuv/issues</a></td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 2.15.1)</td>
</tr>
<tr>
<td>Imports:</td>
<td>later (&ge; 0.8.0), promises, R6, Rcpp (&ge; 1.0.7), utils</td>
</tr>
<tr>
<td>Suggests:</td>
<td>callr, curl, testthat, websocket</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>later, Rcpp</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>SystemRequirements:</td>
<td>GNU make, zlib</td>
</tr>
<tr>
<td>Collate:</td>
<td>'RcppExports.R' 'httpuv.R' 'random_port.R' 'server.R'
'staticServer.R' 'static_paths.R' 'utils.R'</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-12-05 23:46:15 UTC; cpsievert</td>
</tr>
<tr>
<td>Author:</td>
<td>Joe Cheng [aut],
  Winston Chang [aut, cre],
  Posit, PBC fnd [cph],
  Hector Corrada Bravo [ctb],
  Jeroen Ooms [ctb],
  Andrzej Krzemienski [cph] (optional.hpp),
  libuv project contributors [cph] (libuv library, see src/libuv/AUTHORS file),
  Joyent, Inc. and other Node contributors [cph] (libuv library, see
    src/libuv/AUTHORS file; and http-parser library, see src/http-parser/AUTHORS
    file),
  Niels Provos [cph] (libuv subcomponent: tree.h),
  Internet Systems Consortium, Inc. [cph] (libuv subcomponent: inet_pton and
    inet_ntop, contained in src/libuv/src/inet.c),
  Alexander Chemeris [cph] (libuv subcomponent: stdint-msvc2008.h (from
    msinttypes)),
  Google, Inc. [cph] (libuv subcomponent: pthread-fixes.c),
  Sony Mobile Communcations AB [cph] (libuv subcomponent: pthread-fixes.c),
  Berkeley Software Design Inc. [cph] (libuv subcomponent: android-ifaddrs.h,
    android-ifaddrs.c),
  Kenneth MacKay [cph] (libuv subcomponent: android-ifaddrs.h, android-ifaddrs.c),
  Emergya (Cloud4all, FP7/2007-2013, grant agreement no 289016) [cph] (libuv
    subcomponent: android-ifaddrs.h, android-ifaddrs.c),
  Steve Reid [aut] (SHA-1 implementation),
  James Brown [aut] (SHA-1 implementation),
  Bob Trower [aut] (base64 implementation),
  Alexander Peslyak [aut] (MD5 implementation),
  Trantor Standard Systems [cph] (base64 implementation),
  Igor Sysoev [cph] (http-parser)</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Winston Chang &lt;winston@posit.co&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-12-06 09:20:02 UTC</td>
</tr>
<tr>
<td>Built:</td>
<td>R 4.4.0; x86_64-pc-linux-gnu; 2024-01-02 07:49:35 UTC; unix</td>
</tr>
</table>
<hr>
<h2 id='encodeURI'>URI encoding/decoding</h2><span id='topic+encodeURI'></span><span id='topic+encodeURIComponent'></span><span id='topic+decodeURI'></span><span id='topic+decodeURIComponent'></span>

<h3>Description</h3>

<p>Encodes/decodes strings using URI encoding/decoding in the same way that web
browsers do. The precise behaviors of these functions can be found at
developer.mozilla.org:
<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/encodeURI">encodeURI</a>,
<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/encodeURIComponent">encodeURIComponent</a>,
<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/decodeURI">decodeURI</a>,
<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/decodeURIComponent">decodeURIComponent</a>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>encodeURI(value)

encodeURIComponent(value)

decodeURI(value)

decodeURIComponent(value)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="encodeURI_+3A_value">value</code></td>
<td>
<p>Character vector to be encoded or decoded.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Intended as a faster replacement for <code><a href="utils.html#topic+URLencode">utils::URLencode()</a></code> and
<code><a href="utils.html#topic+URLencode">utils::URLdecode()</a></code>.
</p>
<p>encodeURI differs from encodeURIComponent in that the former will not encode
reserved characters: <code>;,/?:@&amp;=+$</code>
</p>
<p>decodeURI differs from decodeURIComponent in that it will refuse to decode
encoded sequences that decode to a reserved character. (If in doubt, use
decodeURIComponent.)
</p>
<p>For <code>encodeURI</code> and <code>encodeURIComponent</code>, input strings will be
converted to UTF-8 before URL-encoding.
</p>


<h3>Value</h3>

<p>Encoded or decoded character vector of the same length as the
input value. <code>decodeURI</code> and <code>decodeURIComponent</code> will return
strings that are UTF-8 encoded.
</p>

<hr>
<h2 id='getRNGState'>Apply the value of .Random.seed to R's internal RNG state</h2><span id='topic+getRNGState'></span>

<h3>Description</h3>

<p>This function is needed in unusual cases where a C++ function calls
an R function which sets the value of <code>.Random.seed</code>. This function
should be called at the end of the R function to ensure that the new value
<code>.Random.seed</code> is preserved. Otherwise, Rcpp may overwrite it with a
previous value.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getRNGState()
</code></pre>

<hr>
<h2 id='httpuv-package'>HTTP and WebSocket server</h2><span id='topic+httpuv-package'></span><span id='topic+httpuv'></span>

<h3>Description</h3>

<p>HTTP and WebSocket server
</p>


<h3>Details</h3>

<p>Allows R code to listen for and interact with HTTP and WebSocket clients, so
you can serve web traffic directly out of your R process. Implementation is
based on <a href="https://github.com/joyent/libuv">libuv</a> and
<a href="https://github.com/nodejs/http-parser">http-parser</a>.
</p>
<p>This is a low-level library that provides little more than network I/O and
implementations of the HTTP and WebSocket protocols. For an easy way to
create web applications, try <a href="https://shiny.posit.co">Shiny</a> instead.
</p>


<h3>Author(s)</h3>

<p>Joe Cheng <a href="mailto:joe@rstudio.com">joe@rstudio.com</a>
</p>


<h3>See Also</h3>

<p><a href="httpuv.html#topic+startServer">startServer</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
demo("echo", package="httpuv")

## End(Not run)

</code></pre>

<hr>
<h2 id='interrupt'>Interrupt httpuv runloop</h2><span id='topic+interrupt'></span>

<h3>Description</h3>

<p>Interrupts the currently running httpuv runloop, meaning
<code><a href="httpuv.html#topic+runServer">runServer</a></code> or <code><a href="httpuv.html#topic+service">service</a></code> will return control back to
the caller and no further tasks will be processed until those methods are
called again. Note that this may cause in-process uploads or downloads to be
interrupted in mid-request.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>interrupt()
</code></pre>

<hr>
<h2 id='ipFamily'>Check whether an address is IPv4 or IPv6</h2><span id='topic+ipFamily'></span>

<h3>Description</h3>

<p>Given an IP address, this checks whether it is an IPv4 or IPv6 address.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ipFamily(ip)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ipFamily_+3A_ip">ip</code></td>
<td>
<p>A single string representing an IP address.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>For IPv4 addresses, <code>4</code>; for IPv6 addresses, <code>6</code>. If the address is
neither, <code>-1</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>ipFamily("127.0.0.1")   # 4
ipFamily("500.0.0.500") # -1
ipFamily("500.0.0.500") # -1

ipFamily("::")          # 6
ipFamily("::1")         # 6
ipFamily("fe80::1ff:fe23:4567:890a") # 6
</code></pre>

<hr>
<h2 id='listServers'>List all running httpuv servers</h2><span id='topic+listServers'></span>

<h3>Description</h3>

<p>This returns a list of all running httpuv server applications.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>listServers()
</code></pre>

<hr>
<h2 id='logLevel'>Get and set logging level</h2><span id='topic+logLevel'></span>

<h3>Description</h3>

<p>The logging level for httpuv can be set to report differing levels of
information. Possible logging levels (from least to most information
reported) are: <code>"OFF"</code>, <code>"ERROR"</code>, <code>"WARN"</code>, <code>"INFO"</code>, or
<code>"DEBUG"</code>. The default level is <code>ERROR</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>logLevel(level = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="logLevel_+3A_level">level</code></td>
<td>
<p>The logging level. Must be one of <code>NULL</code>, <code>"OFF"</code>,
<code>"ERROR"</code>, <code>"WARN"</code>, <code>"INFO"</code>, or <code>"DEBUG"</code>. If
<code>NULL</code> (the default), then this function simply returns the current
logging level.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>If <code>level=NULL</code>, then this returns the current logging level. If
<code>level</code> is any other value, then this returns the previous logging
level, from before it is set to the new value.
</p>

<hr>
<h2 id='PipeServer'>PipeServer class</h2><span id='topic+PipeServer'></span>

<h3>Description</h3>

<p>This class represents a server running one application that listens on a
named pipe.
</p>


<h3>Methods</h3>


<dl>
<dt><code>initialize(name, mask, app)</code></dt><dd>
<p>Create a new <code>PipeServer</code> object. <code>app</code> is an httpuv application
object as described in <code><a href="httpuv.html#topic+startServer">startServer</a></code>.
</p>
</dd>
<dt><code>getName()</code></dt><dd><p>Return the value of <code>name</code> that was passed to
<code>initialize()</code>.
</p>
</dd>
<dt><code>getMask()</code></dt><dd><p>Return the value of <code>mask</code> that was passed to
<code>initialize()</code>.
</p>
</dd>
<dt><code>stop()</code></dt><dd><p>Stops a running server.</p>
</dd>
<dt><code>isRunning()</code></dt><dd><p>Returns TRUE if the server is currently running.</p>
</dd>
<dt><code>getStaticPaths()</code></dt><dd><p>Returns a list of <code><a href="httpuv.html#topic+staticPath">staticPath</a></code>
objects for the server.
</p>
</dd>
<dt><code>setStaticPath(..., .list = NULL)</code></dt><dd><p>Sets a static path for the
current server. Each static path can be given as a named argument, or as
an named item in <code>.list</code>. If there already exists a static path with
the same name, it will be replaced.
</p>
</dd>
<dt><code>removeStaticPath(path)</code></dt><dd><p>Removes a static path with the given
name.
</p>
</dd>
<dt><code>getStaticPathOptions()</code></dt><dd><p>Returns a list of default
<code>staticPathOptions</code> for the current server. Each static path will
use these options by default, but they can be overridden for each static
path.
</p>
</dd>
<dt><code>setStaticPathOption(..., .list = NULL)</code></dt><dd><p>Sets one or more
static path options. Each option can be given as a named argument, or as
a named item in <code>.list</code>.
</p>
</dd>
</dl>



<h3>Super class</h3>

<p><code><a href="#topic+Server">httpuv::Server</a></code> -&gt; <code>PipeServer</code>
</p>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-PipeServer-new"><code>PipeServer$new()</code></a>
</p>
</li>
<li> <p><a href="#method-PipeServer-getName"><code>PipeServer$getName()</code></a>
</p>
</li>
<li> <p><a href="#method-PipeServer-getMask"><code>PipeServer$getMask()</code></a>
</p>
</li></ul>



<details><summary>Inherited methods</summary>
<ul>
<li><span class="pkg-link" data-pkg="httpuv" data-topic="Server" data-id="getStaticPathOptions"><a href='../../httpuv/html/Server.html#method-Server-getStaticPathOptions'><code>httpuv::Server$getStaticPathOptions()</code></a></span></li>
<li><span class="pkg-link" data-pkg="httpuv" data-topic="Server" data-id="getStaticPaths"><a href='../../httpuv/html/Server.html#method-Server-getStaticPaths'><code>httpuv::Server$getStaticPaths()</code></a></span></li>
<li><span class="pkg-link" data-pkg="httpuv" data-topic="Server" data-id="isRunning"><a href='../../httpuv/html/Server.html#method-Server-isRunning'><code>httpuv::Server$isRunning()</code></a></span></li>
<li><span class="pkg-link" data-pkg="httpuv" data-topic="Server" data-id="removeStaticPath"><a href='../../httpuv/html/Server.html#method-Server-removeStaticPath'><code>httpuv::Server$removeStaticPath()</code></a></span></li>
<li><span class="pkg-link" data-pkg="httpuv" data-topic="Server" data-id="setStaticPath"><a href='../../httpuv/html/Server.html#method-Server-setStaticPath'><code>httpuv::Server$setStaticPath()</code></a></span></li>
<li><span class="pkg-link" data-pkg="httpuv" data-topic="Server" data-id="setStaticPathOption"><a href='../../httpuv/html/Server.html#method-Server-setStaticPathOption'><code>httpuv::Server$setStaticPathOption()</code></a></span></li>
<li><span class="pkg-link" data-pkg="httpuv" data-topic="Server" data-id="stop"><a href='../../httpuv/html/Server.html#method-Server-stop'><code>httpuv::Server$stop()</code></a></span></li>
</ul>
</details>

<hr>
<a id="method-PipeServer-new"></a>



<h4>Method <code>new()</code></h4>



<h5>Usage</h5>

<div class="r"><pre>PipeServer$new(name, mask, app, quiet = FALSE)</pre></div>


<hr>
<a id="method-PipeServer-getName"></a>



<h4>Method <code>getName()</code></h4>



<h5>Usage</h5>

<div class="r"><pre>PipeServer$getName()</pre></div>


<hr>
<a id="method-PipeServer-getMask"></a>



<h4>Method <code>getMask()</code></h4>



<h5>Usage</h5>

<div class="r"><pre>PipeServer$getMask()</pre></div>




<h3>See Also</h3>

<p><code><a href="httpuv.html#topic+Server">Server</a></code> and <code><a href="httpuv.html#topic+WebServer">WebServer</a></code>.
</p>

<hr>
<h2 id='randomPort'>Find an open TCP port</h2><span id='topic+randomPort'></span>

<h3>Description</h3>

<p>Finds a random available TCP port for listening on, within a specified range
of ports. The default range of ports to check is 1024 to 49151, which is the
set of TCP User Ports. This function automatically excludes some ports which
are considered unsafe by web browsers.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>randomPort(min = 1024L, max = 49151L, host = "127.0.0.1", n = 20)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="randomPort_+3A_min">min</code></td>
<td>
<p>Minimum port number.</p>
</td></tr>
<tr><td><code id="randomPort_+3A_max">max</code></td>
<td>
<p>Maximum port number.</p>
</td></tr>
<tr><td><code id="randomPort_+3A_host">host</code></td>
<td>
<p>A string that is a valid IPv4 or IPv6 address that is owned by
this server, which the application will listen on. <code>"0.0.0.0"</code>
represents all IPv4 addresses and <code>"::/0"</code> represents all IPv6
addresses.</p>
</td></tr>
<tr><td><code id="randomPort_+3A_n">n</code></td>
<td>
<p>Number of ports to try before giving up.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A port that is available to listen on.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
s &lt;- startServer("127.0.0.1", randomPort(), list())
browseURL(paste0("http://127.0.0.1:", s$getPort()))

s$stop()

## End(Not run)

</code></pre>

<hr>
<h2 id='rawToBase64'>Convert raw vector to Base64-encoded string</h2><span id='topic+rawToBase64'></span>

<h3>Description</h3>

<p>Converts a raw vector to its Base64 encoding as a single-element character
vector.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rawToBase64(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rawToBase64_+3A_x">x</code></td>
<td>
<p>A raw vector.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(100)
result &lt;- rawToBase64(as.raw(runif(19, min=0, max=256)))
stopifnot(identical(result, "TkGNDnd7z16LK5/hR2bDqzRbXA=="))

</code></pre>

<hr>
<h2 id='runServer'>Run a server</h2><span id='topic+runServer'></span>

<h3>Description</h3>

<p>This is a convenience function that provides a simple way to call
<code><a href="httpuv.html#topic+startServer">startServer</a></code>, <code><a href="httpuv.html#topic+service">service</a></code>, and
<code><a href="httpuv.html#topic+stopServer">stopServer</a></code> in the correct sequence. It does not return unless
interrupted or an error occurs.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>runServer(host, port, app, interruptIntervalMs = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="runServer_+3A_host">host</code></td>
<td>
<p>A string that is a valid IPv4 or IPv6 address that is owned by
this server, which the application will listen on. <code>"0.0.0.0"</code>
represents all IPv4 addresses and <code>"::/0"</code> represents all IPv6
addresses.</p>
</td></tr>
<tr><td><code id="runServer_+3A_port">port</code></td>
<td>
<p>A number or integer that indicates the server port that should be
listened on. Note that on most Unix-like systems including Linux and Mac OS
X, port numbers smaller than 1025 require root privileges.</p>
</td></tr>
<tr><td><code id="runServer_+3A_app">app</code></td>
<td>
<p>A collection of functions that define your application. See
<code><a href="httpuv.html#topic+startServer">startServer</a></code>.</p>
</td></tr>
<tr><td><code id="runServer_+3A_interruptintervalms">interruptIntervalMs</code></td>
<td>
<p>Deprecated (last used in httpuv 1.3.5).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If you have multiple hosts and/or ports to listen on, call the individual
functions instead of <code>runServer</code>.
</p>


<h3>See Also</h3>

<p><code><a href="httpuv.html#topic+startServer">startServer</a></code>, <code><a href="httpuv.html#topic+service">service</a></code>,
<code><a href="httpuv.html#topic+stopServer">stopServer</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# A very basic application
runServer("0.0.0.0", 5000,
  list(
    call = function(req) {
      list(
        status = 200L,
        headers = list(
          'Content-Type' = 'text/html'
        ),
        body = "Hello world!"
      )
    }
  )
)

## End(Not run)
</code></pre>

<hr>
<h2 id='runStaticServer'>Serve a directory</h2><span id='topic+runStaticServer'></span>

<h3>Description</h3>

<p><code>runStaticServer()</code> provides a convenient interface to start a server to host
a single static directory, either in the foreground or the background.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>runStaticServer(
  dir = getwd(),
  host = "127.0.0.1",
  port = NULL,
  ...,
  background = FALSE,
  browse = interactive()
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="runStaticServer_+3A_dir">dir</code></td>
<td>
<p>The directory to serve. Defaults to the current working directory.</p>
</td></tr>
<tr><td><code id="runStaticServer_+3A_host">host</code></td>
<td>
<p>A string that is a valid IPv4 address that is owned by this
server, or <code>"0.0.0.0"</code> to listen on all IP addresses.</p>
</td></tr>
<tr><td><code id="runStaticServer_+3A_port">port</code></td>
<td>
<p>A number or integer that indicates the server port that should be
listened on. Note that on most Unix-like systems including Linux and Mac OS
X, port numbers smaller than 1025 require root privileges.</p>
</td></tr>
<tr><td><code id="runStaticServer_+3A_...">...</code></td>
<td>

<p>Arguments passed on to <code><a href="httpuv.html#topic+staticPath">staticPath</a></code>
</p>

<dl>
<dt><code>path</code></dt><dd><p>The local path.</p>
</dd>
<dt><code>indexhtml</code></dt><dd><p>If an index.html file is present, should it be served up
when the client requests the static path or any subdirectory?</p>
</dd>
<dt><code>fallthrough</code></dt><dd><p>With the default value, <code>FALSE</code>, if a request is made
for a file that doesn't exist, then httpuv will immediately send a 404
response from the background I/O thread, without needing to call back into
the main R thread. This offers the best performance. If the value is
<code>TRUE</code>, then instead of sending a 404 response, httpuv will call the
application's <code>call</code> function, and allow it to handle the request.</p>
</dd>
<dt><code>html_charset</code></dt><dd><p>When HTML files are served, the value that will be
provided for <code>charset</code> in the Content-Type header. For example, with
the default value, <code>"utf-8"</code>, the header is <code>Content-Type:
  text/html; charset=utf-8</code>. If <code>""</code> is used, then no <code>charset</code>
will be added in the Content-Type header.</p>
</dd>
<dt><code>headers</code></dt><dd><p>Additional headers and values that will be included in the
response.</p>
</dd>
<dt><code>validation</code></dt><dd><p>An optional validation pattern. Presently, the only type of
validation supported is an exact string match of a header. For example, if
<code>validation</code> is <code>'"abc" = "xyz"'</code>, then HTTP requests must have a
header named <code>abc</code> (case-insensitive) with the value <code>xyz</code>
(case-sensitive). If a request does not have a matching header, than httpuv
will give a 403 Forbidden response. If the <code>character(0)</code> (the
default), then no validation check will be performed.</p>
</dd>
</dl>
</td></tr>
<tr><td><code id="runStaticServer_+3A_background">background</code></td>
<td>
<p>Whether to run the server in the background. By default,
the server runs in the foreground and blocks the R console. You can stop
the server by interrupting it with <code>Ctrl + C</code>.
</p>
<p>When <code>background = TRUE</code>, the server will run in the background and will
process requests when the R console is idle. To stop a background server,
call <code><a href="httpuv.html#topic+stopAllServers">stopAllServers()</a></code> or call <code><a href="httpuv.html#topic+stopServer">stopServer()</a></code> on the server object
returned (invisibly) by this function.</p>
</td></tr>
<tr><td><code id="runStaticServer_+3A_browse">browse</code></td>
<td>
<p>Whether to automatically open the served directory in a web
browser. Defaults to <code>TRUE</code> when running interactively.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Starts a server on the specified host and port. By default the
server runs in the foreground and is accessible at <code style="white-space: pre;">&#8288;http://127.0.0.1:7446&#8288;</code>.
When <code>background = TRUE</code>, the <code>server</code> object is returned invisibly.
</p>


<h3>See Also</h3>

<p><code><a href="httpuv.html#topic+runServer">runServer()</a></code> provides a similar interface for running a dynamic
app server. Both <code>runStaticServer()</code> and <code><a href="httpuv.html#topic+runServer">runServer()</a></code> are built on top of
<code><a href="httpuv.html#topic+startServer">startServer()</a></code>, <code><a href="httpuv.html#topic+service">service()</a></code> and <code><a href="httpuv.html#topic+stopServer">stopServer()</a></code>. Learn more about httpuv
servers in <code><a href="httpuv.html#topic+startServer">startServer()</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
website_dir &lt;- system.file("example-static-site", package = "httpuv")
runStaticServer(dir = website_dir)

</code></pre>

<hr>
<h2 id='Server'>Server class</h2><span id='topic+Server'></span>

<h3>Description</h3>

<p>The <code>Server</code> class is the parent class for <code><a href="httpuv.html#topic+WebServer">WebServer</a></code> and
<code><a href="httpuv.html#topic+PipeServer">PipeServer</a></code>. This class defines an interface and is not meant to
be instantiated.
</p>


<h3>Methods</h3>


<dl>
<dt><code>stop()</code></dt><dd><p>Stops a running server.</p>
</dd>
<dt><code>isRunning()</code></dt><dd><p>Returns TRUE if the server is currently running.</p>
</dd>
<dt><code>getStaticPaths()</code></dt><dd><p>Returns a list of <code><a href="httpuv.html#topic+staticPath">staticPath</a></code>
objects for the server.
</p>
</dd>
<dt><code>setStaticPath(..., .list = NULL)</code></dt><dd><p>Sets a static path for the
current server. Each static path can be given as a named argument, or as
an named item in <code>.list</code>. If there already exists a static path with
the same name, it will be replaced.
</p>
</dd>
<dt><code>removeStaticPath(path)</code></dt><dd><p>Removes a static path with the given
name.
</p>
</dd>
<dt><code>getStaticPathOptions()</code></dt><dd><p>Returns a list of default
<code>staticPathOptions</code> for the current server. Each static path will
use these options by default, but they can be overridden for each static
path.
</p>
</dd>
<dt><code>setStaticPathOption(..., .list = NULL)</code></dt><dd><p>Sets one or more
static path options. Each option can be given as a named argument, or as
a named item in <code>.list</code>.
</p>
</dd>
</dl>



<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-Server-stop"><code>Server$stop()</code></a>
</p>
</li>
<li> <p><a href="#method-Server-isRunning"><code>Server$isRunning()</code></a>
</p>
</li>
<li> <p><a href="#method-Server-getStaticPaths"><code>Server$getStaticPaths()</code></a>
</p>
</li>
<li> <p><a href="#method-Server-setStaticPath"><code>Server$setStaticPath()</code></a>
</p>
</li>
<li> <p><a href="#method-Server-removeStaticPath"><code>Server$removeStaticPath()</code></a>
</p>
</li>
<li> <p><a href="#method-Server-getStaticPathOptions"><code>Server$getStaticPathOptions()</code></a>
</p>
</li>
<li> <p><a href="#method-Server-setStaticPathOption"><code>Server$setStaticPathOption()</code></a>
</p>
</li></ul>


<hr>
<a id="method-Server-stop"></a>



<h4>Method <code>stop()</code></h4>



<h5>Usage</h5>

<div class="r"><pre>Server$stop()</pre></div>


<hr>
<a id="method-Server-isRunning"></a>



<h4>Method <code>isRunning()</code></h4>



<h5>Usage</h5>

<div class="r"><pre>Server$isRunning()</pre></div>


<hr>
<a id="method-Server-getStaticPaths"></a>



<h4>Method <code>getStaticPaths()</code></h4>



<h5>Usage</h5>

<div class="r"><pre>Server$getStaticPaths()</pre></div>


<hr>
<a id="method-Server-setStaticPath"></a>



<h4>Method <code>setStaticPath()</code></h4>



<h5>Usage</h5>

<div class="r"><pre>Server$setStaticPath(..., .list = NULL)</pre></div>


<hr>
<a id="method-Server-removeStaticPath"></a>



<h4>Method <code>removeStaticPath()</code></h4>



<h5>Usage</h5>

<div class="r"><pre>Server$removeStaticPath(path)</pre></div>


<hr>
<a id="method-Server-getStaticPathOptions"></a>



<h4>Method <code>getStaticPathOptions()</code></h4>



<h5>Usage</h5>

<div class="r"><pre>Server$getStaticPathOptions()</pre></div>


<hr>
<a id="method-Server-setStaticPathOption"></a>



<h4>Method <code>setStaticPathOption()</code></h4>



<h5>Usage</h5>

<div class="r"><pre>Server$setStaticPathOption(..., .list = NULL)</pre></div>




<h3>See Also</h3>

<p><code><a href="httpuv.html#topic+WebServer">WebServer</a></code> and <code><a href="httpuv.html#topic+PipeServer">PipeServer</a></code>.
</p>

<hr>
<h2 id='service'>Process requests</h2><span id='topic+service'></span>

<h3>Description</h3>

<p>Process HTTP requests and WebSocket messages. If there is nothing on R's call
stack &ndash; if R is sitting idle at the command prompt &ndash; it is not necessary to
call this function, because requests will be handled automatically. However,
if R is executing code, then requests will not be handled until either the
call stack is empty, or this function is called (or alternatively,
<code><a href="later.html#topic+run_now">run_now</a></code> is called).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>service(timeoutMs = ifelse(interactive(), 100, 1000))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="service_+3A_timeoutms">timeoutMs</code></td>
<td>
<p>Approximate number of milliseconds to run before returning.
It will return this duration has elapsed. If 0 or Inf, then the function
will continually process requests without returning unless an error occurs.
If NA, performs a non-blocking run without waiting.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>In previous versions of httpuv (1.3.5 and below), even if a server created by
<code><a href="httpuv.html#topic+startServer">startServer</a></code> exists, no requests were serviced unless and until
<code>service</code> was called.
</p>
<p>This function simply calls <code><a href="later.html#topic+run_now">run_now</a>()</code>, so if your
application schedules any <code><a href="later.html#topic+later">later</a></code> callbacks, they will be
invoked.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
while (TRUE) {
  service()
}

## End(Not run)

</code></pre>

<hr>
<h2 id='startDaemonizedServer'>Create an HTTP/WebSocket daemonized server (deprecated)</h2><span id='topic+startDaemonizedServer'></span>

<h3>Description</h3>

<p>This function will be removed in a future release of httpuv. It is simply a
wrapper for <code><a href="httpuv.html#topic+startServer">startServer</a></code>. In previous versions of httpuv (1.3.5
and below), <code>startServer</code> ran applications in the foreground and
<code>startDaemonizedServer</code> ran applications in the background, but now both
of them run applications in the background.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>startDaemonizedServer(host, port, app, quiet = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="startDaemonizedServer_+3A_host">host</code></td>
<td>
<p>A string that is a valid IPv4 address that is owned by this
server, or <code>"0.0.0.0"</code> to listen on all IP addresses.</p>
</td></tr>
<tr><td><code id="startDaemonizedServer_+3A_port">port</code></td>
<td>
<p>A number or integer that indicates the server port that should be
listened on. Note that on most Unix-like systems including Linux and Mac OS
X, port numbers smaller than 1025 require root privileges.</p>
</td></tr>
<tr><td><code id="startDaemonizedServer_+3A_app">app</code></td>
<td>
<p>A collection of functions that define your application. See
Details.</p>
</td></tr>
<tr><td><code id="startDaemonizedServer_+3A_quiet">quiet</code></td>
<td>
<p>If <code>TRUE</code>, suppress error messages from starting app.</p>
</td></tr>
</table>

<hr>
<h2 id='startServer'>Create an HTTP/WebSocket server</h2><span id='topic+startServer'></span><span id='topic+startPipeServer'></span>

<h3>Description</h3>

<p>Creates an HTTP/WebSocket server on the specified host and port.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>startServer(host, port, app, quiet = FALSE)

startPipeServer(name, mask, app, quiet = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="startServer_+3A_host">host</code></td>
<td>
<p>A string that is a valid IPv4 address that is owned by this
server, or <code>"0.0.0.0"</code> to listen on all IP addresses.</p>
</td></tr>
<tr><td><code id="startServer_+3A_port">port</code></td>
<td>
<p>A number or integer that indicates the server port that should be
listened on. Note that on most Unix-like systems including Linux and Mac OS
X, port numbers smaller than 1025 require root privileges.</p>
</td></tr>
<tr><td><code id="startServer_+3A_app">app</code></td>
<td>
<p>A collection of functions that define your application. See
Details.</p>
</td></tr>
<tr><td><code id="startServer_+3A_quiet">quiet</code></td>
<td>
<p>If <code>TRUE</code>, suppress error messages from starting app.</p>
</td></tr>
<tr><td><code id="startServer_+3A_name">name</code></td>
<td>
<p>A string that indicates the path for the domain socket (on
Unix-like systems) or the name of the named pipe (on Windows).</p>
</td></tr>
<tr><td><code id="startServer_+3A_mask">mask</code></td>
<td>
<p>If non-<code>NULL</code> and non-negative, this numeric value is used
to temporarily modify the process's umask while the domain socket is being
created. To ensure that only root can access the domain socket, use
<code>strtoi("777", 8)</code>; or to allow owner and group read/write access, use
<code>strtoi("117", 8)</code>. If the value is <code>NULL</code> then the process's
umask is left unchanged. (This parameter has no effect on Windows.)</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>startServer</code> binds the specified port and listens for
connections on an thread running in the background. This background thread
handles the I/O, and when it receives a HTTP request, it will schedule a
call to the user-defined R functions in <code>app</code> to handle the request.
This scheduling is done with <code><a href="later.html#topic+later">later</a>()</code>. When the R call
stack is empty &ndash; in other words, when an interactive R session is sitting
idle at the command prompt &ndash; R will automatically run the scheduled calls.
However, if the call stack is not empty &ndash; if R is evaluating other R code
&ndash; then the callbacks will not execute until either the call stack is
empty, or the <code><a href="later.html#topic+run_now">run_now</a>()</code> function is called. This
function tells R to execute any callbacks that have been scheduled by
<code><a href="later.html#topic+later">later</a>()</code>. The <code><a href="httpuv.html#topic+service">service</a>()</code> function is
essentially a wrapper for <code><a href="later.html#topic+run_now">run_now</a>()</code>.
</p>
<p>In older versions of httpuv (1.3.5 and below), it did not use a background
thread for I/O, and when this function was called, it did not accept
connections immediately. It was necessary to call <code><a href="httpuv.html#topic+service">service</a></code>
repeatedly in order to actually accept and handle connections.
</p>
<p>If the port cannot be bound (most likely due to permissions or because it
is already bound), an error is raised.
</p>
<p>The application can also specify paths on the filesystem which will be
served from the background thread, without invoking <code>$call()</code> or
<code>$onHeaders()</code>. Files served this way will be only use a C++ code,
which is faster than going through R, and will not be blocked when R code
is executing. This can greatly improve performance when serving static
assets.
</p>
<p>The <code>app</code> parameter is where your application logic will be provided
to the server. This can be a list, environment, or reference class that
contains the following methods and fields:
</p>

<dl>
<dt><code>call(req)</code></dt><dd><p>Process the given HTTP request, and return an
HTTP response (see Response Values). This method should be implemented in
accordance with the
<a href="https://github.com/jeffreyhorner/Rook/blob/a5e45f751/README.md">Rook</a>
specification. Note that httpuv augments <code>req</code> with an additional
item, <code>req$HEADERS</code>, which is a named character vector of request
headers.</p>
</dd>
<dt><code>onHeaders(req)</code></dt><dd><p>Optional. Similar to <code>call</code>, but occurs
when headers are received. Return <code>NULL</code> to continue normal
processing of the request, or a Rook response to send that response,
stop processing the request, and ask the client to close the connection.
(This can be used to implement upload size limits, for example.)</p>
</dd>
<dt><code>onWSOpen(ws)</code></dt><dd><p>Called back when a WebSocket connection is established.
The given object can be used to be notified when a message is received from
the client, to send messages to the client, etc. See <code><a href="httpuv.html#topic+WebSocket">WebSocket</a></code>.</p>
</dd>
<dt><code>staticPaths</code></dt><dd>
<p>A named list of paths that will be served without invoking
<code>call()</code> or <code>onHeaders</code>. The name of each one is the URL
path, and the value is either a string referring to a local path, or an
object created by the <code><a href="httpuv.html#topic+staticPath">staticPath</a></code> function.
</p>
</dd>
<dt><code>staticPathOptions</code></dt><dd>
<p>A set of default options to use when serving static paths. If
not set or <code>NULL</code>, then it will use the result from calling
<code><a href="httpuv.html#topic+staticPathOptions">staticPathOptions</a>()</code> with no arguments.
</p>
</dd>
</dl>

<p>The <code>startPipeServer</code> variant can be used instead of
<code>startServer</code> to listen on a Unix domain socket or named pipe rather
than a TCP socket (this is not common).
</p>


<h3>Value</h3>

<p>A handle for this server that can be passed to
<code><a href="httpuv.html#topic+stopServer">stopServer</a></code> to shut the server down.
</p>
<p>A <code><a href="httpuv.html#topic+WebServer">WebServer</a></code> or <code><a href="httpuv.html#topic+PipeServer">PipeServer</a></code> object.
</p>


<h3>Response Values</h3>

<p>The <code>call</code> function is expected to return a list containing the
following, which are converted to an HTTP response and sent to the client:
</p>

<dl>
<dt><code>status</code></dt><dd><p>A numeric HTTP status code, e.g. <code>200</code> or
<code>404L</code>.</p>
</dd>
<dt><code>headers</code></dt><dd><p>A named list of HTTP headers and their values, as
strings. This can also be missing, an empty list, or <code>NULL</code>, in which
case no headers (other than the <code>Date</code> and <code>Content-Length</code>
headers, as required) will be added.</p>
</dd>
<dt><code>body</code></dt><dd><p>A string (or <code>raw</code> vector) to be sent as the body
of the HTTP response. This can also be omitted or set to <code>NULL</code> to
avoid sending any body, which is useful for HTTP <code>1xx</code>, <code>204</code>,
and <code>304</code> responses, as well as responses to <code>HEAD</code> requests.</p>
</dd>
</dl>



<h3>See Also</h3>

<p><code><a href="httpuv.html#topic+stopServer">stopServer</a></code>, <code><a href="httpuv.html#topic+runServer">runServer</a></code>,
<code><a href="httpuv.html#topic+listServers">listServers</a></code>, <code><a href="httpuv.html#topic+stopAllServers">stopAllServers</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# A very basic application
s &lt;- startServer("0.0.0.0", 5000,
  list(
    call = function(req) {
      list(
        status = 200L,
        headers = list(
          'Content-Type' = 'text/html'
        ),
        body = "Hello world!"
      )
    }
  )
)

s$stop()


# An application that serves static assets at the URL paths /assets and /lib
s &lt;- startServer("0.0.0.0", 5000,
  list(
    call = function(req) {
      list(
        status = 200L,
        headers = list(
          'Content-Type' = 'text/html'
        ),
        body = "Hello world!"
      )
    },
    staticPaths = list(
      "/assets" = "content/assets/",
      "/lib" = staticPath(
        "content/lib",
        indexhtml = FALSE
      ),
      # This subdirectory of /lib should always be handled by the R code path
      "/lib/dynamic" = excludeStaticPath()
    ),
    staticPathOptions = staticPathOptions(
      indexhtml = TRUE
    )
  )
)

s$stop()

## End(Not run)
</code></pre>

<hr>
<h2 id='staticPath'>Create a staticPath object</h2><span id='topic+staticPath'></span><span id='topic+excludeStaticPath'></span>

<h3>Description</h3>

<p>The <code>staticPath</code> function creates a <code>staticPath</code> object. Note that
if any of the arguments (other than <code>path</code>) are <code>NULL</code>, then that
means that for this particular static path, it should inherit the behavior
from the staticPathOptions set for the application as a whole.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>staticPath(
  path,
  indexhtml = NULL,
  fallthrough = NULL,
  html_charset = NULL,
  headers = NULL,
  validation = NULL
)

excludeStaticPath()
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="staticPath_+3A_path">path</code></td>
<td>
<p>The local path.</p>
</td></tr>
<tr><td><code id="staticPath_+3A_indexhtml">indexhtml</code></td>
<td>
<p>If an index.html file is present, should it be served up
when the client requests the static path or any subdirectory?</p>
</td></tr>
<tr><td><code id="staticPath_+3A_fallthrough">fallthrough</code></td>
<td>
<p>With the default value, <code>FALSE</code>, if a request is made
for a file that doesn't exist, then httpuv will immediately send a 404
response from the background I/O thread, without needing to call back into
the main R thread. This offers the best performance. If the value is
<code>TRUE</code>, then instead of sending a 404 response, httpuv will call the
application's <code>call</code> function, and allow it to handle the request.</p>
</td></tr>
<tr><td><code id="staticPath_+3A_html_charset">html_charset</code></td>
<td>
<p>When HTML files are served, the value that will be
provided for <code>charset</code> in the Content-Type header. For example, with
the default value, <code>"utf-8"</code>, the header is <code>Content-Type:
  text/html; charset=utf-8</code>. If <code>""</code> is used, then no <code>charset</code>
will be added in the Content-Type header.</p>
</td></tr>
<tr><td><code id="staticPath_+3A_headers">headers</code></td>
<td>
<p>Additional headers and values that will be included in the
response.</p>
</td></tr>
<tr><td><code id="staticPath_+3A_validation">validation</code></td>
<td>
<p>An optional validation pattern. Presently, the only type of
validation supported is an exact string match of a header. For example, if
<code>validation</code> is <code>'"abc" = "xyz"'</code>, then HTTP requests must have a
header named <code>abc</code> (case-insensitive) with the value <code>xyz</code>
(case-sensitive). If a request does not have a matching header, than httpuv
will give a 403 Forbidden response. If the <code>character(0)</code> (the
default), then no validation check will be performed.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>excludeStaticPath</code> function tells the application to ignore a
particular path for static serving. This is useful when you want to include a
path for static serving (like <code>"/"</code>) but then exclude a subdirectory of
it (like <code>"/dynamic"</code>) so that the subdirectory will always be passed to
the R code for handling requests. <code>excludeStaticPath</code> can be used not
only for directories; it can also exclude specific files.
</p>


<h3>See Also</h3>

<p><code><a href="httpuv.html#topic+staticPathOptions">staticPathOptions</a></code>.
</p>

<hr>
<h2 id='staticPathOptions'>Create options for static paths</h2><span id='topic+staticPathOptions'></span>

<h3>Description</h3>

<p>Create options for static paths
</p>


<h3>Usage</h3>

<pre><code class='language-R'>staticPathOptions(
  indexhtml = TRUE,
  fallthrough = FALSE,
  html_charset = "utf-8",
  headers = list(),
  validation = character(0),
  exclude = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="staticPathOptions_+3A_indexhtml">indexhtml</code></td>
<td>
<p>If an index.html file is present, should it be served up
when the client requests the static path or any subdirectory?</p>
</td></tr>
<tr><td><code id="staticPathOptions_+3A_fallthrough">fallthrough</code></td>
<td>
<p>With the default value, <code>FALSE</code>, if a request is made
for a file that doesn't exist, then httpuv will immediately send a 404
response from the background I/O thread, without needing to call back into
the main R thread. This offers the best performance. If the value is
<code>TRUE</code>, then instead of sending a 404 response, httpuv will call the
application's <code>call</code> function, and allow it to handle the request.</p>
</td></tr>
<tr><td><code id="staticPathOptions_+3A_html_charset">html_charset</code></td>
<td>
<p>When HTML files are served, the value that will be
provided for <code>charset</code> in the Content-Type header. For example, with
the default value, <code>"utf-8"</code>, the header is <code>Content-Type:
  text/html; charset=utf-8</code>. If <code>""</code> is used, then no <code>charset</code>
will be added in the Content-Type header.</p>
</td></tr>
<tr><td><code id="staticPathOptions_+3A_headers">headers</code></td>
<td>
<p>Additional headers and values that will be included in the
response.</p>
</td></tr>
<tr><td><code id="staticPathOptions_+3A_validation">validation</code></td>
<td>
<p>An optional validation pattern. Presently, the only type of
validation supported is an exact string match of a header. For example, if
<code>validation</code> is <code>'"abc" = "xyz"'</code>, then HTTP requests must have a
header named <code>abc</code> (case-insensitive) with the value <code>xyz</code>
(case-sensitive). If a request does not have a matching header, than httpuv
will give a 403 Forbidden response. If the <code>character(0)</code> (the
default), then no validation check will be performed.</p>
</td></tr>
<tr><td><code id="staticPathOptions_+3A_exclude">exclude</code></td>
<td>
<p>Should this path be excluded from static serving? (This is
only to be used internally, for <code><a href="httpuv.html#topic+excludeStaticPath">excludeStaticPath</a></code>.)</p>
</td></tr>
</table>

<hr>
<h2 id='stopAllServers'>Stop all servers</h2><span id='topic+stopAllServers'></span>

<h3>Description</h3>

<p>This will stop all applications which were created by
<code><a href="httpuv.html#topic+startServer">startServer</a></code> or <code><a href="httpuv.html#topic+startPipeServer">startPipeServer</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>stopAllServers()
</code></pre>


<h3>See Also</h3>

<p><code><a href="httpuv.html#topic+stopServer">stopServer</a></code> to stop a specific server.
</p>

<hr>
<h2 id='stopDaemonizedServer'>Stop a running daemonized server in Unix environments (deprecated)</h2><span id='topic+stopDaemonizedServer'></span>

<h3>Description</h3>

<p>This function will be removed in a future release of httpuv. Instead, use
<code><a href="httpuv.html#topic+stopServer">stopServer</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>stopDaemonizedServer(server)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="stopDaemonizedServer_+3A_server">server</code></td>
<td>
<p>A server object that was previously returned from
<code><a href="httpuv.html#topic+startServer">startServer</a></code> or <code><a href="httpuv.html#topic+startPipeServer">startPipeServer</a></code>.</p>
</td></tr>
</table>

<hr>
<h2 id='stopServer'>Stop a server</h2><span id='topic+stopServer'></span>

<h3>Description</h3>

<p>Given a server object that was returned from a previous invocation of
<code><a href="httpuv.html#topic+startServer">startServer</a></code> or <code><a href="httpuv.html#topic+startPipeServer">startPipeServer</a></code>, this closes all
open connections for that server and unbinds the port.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>stopServer(server)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="stopServer_+3A_server">server</code></td>
<td>
<p>A server object that was previously returned from
<code><a href="httpuv.html#topic+startServer">startServer</a></code> or <code><a href="httpuv.html#topic+startPipeServer">startPipeServer</a></code>.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="httpuv.html#topic+stopAllServers">stopAllServers</a></code> to stop all servers.
</p>

<hr>
<h2 id='WebServer'>WebServer class</h2><span id='topic+WebServer'></span>

<h3>Description</h3>

<p>This class represents a web server running one application. Multiple servers
can be running at the same time.
</p>


<h3>Methods</h3>


<dl>
<dt><code>initialize(host, port, app)</code></dt><dd>
<p>Create a new <code>WebServer</code> object. <code>app</code> is an httpuv application
object as described in <code><a href="httpuv.html#topic+startServer">startServer</a></code>.
</p>
</dd>
<dt><code>getHost()</code></dt><dd><p>Return the value of <code>host</code> that was passed to
<code>initialize()</code>.
</p>
</dd>
<dt><code>getPort()</code></dt><dd><p>Return the value of <code>port</code> that was passed to
<code>initialize()</code>.
</p>
</dd>
<dt><code>stop()</code></dt><dd><p>Stops a running server.</p>
</dd>
<dt><code>isRunning()</code></dt><dd><p>Returns TRUE if the server is currently running.</p>
</dd>
<dt><code>getStaticPaths()</code></dt><dd><p>Returns a list of <code><a href="httpuv.html#topic+staticPath">staticPath</a></code>
objects for the server.
</p>
</dd>
<dt><code>setStaticPath(..., .list = NULL)</code></dt><dd><p>Sets a static path for the
current server. Each static path can be given as a named argument, or as
an named item in <code>.list</code>. If there already exists a static path with
the same name, it will be replaced.
</p>
</dd>
<dt><code>removeStaticPath(path)</code></dt><dd><p>Removes a static path with the given
name.
</p>
</dd>
<dt><code>getStaticPathOptions()</code></dt><dd><p>Returns a list of default
<code>staticPathOptions</code> for the current server. Each static path will
use these options by default, but they can be overridden for each static
path.
</p>
</dd>
<dt><code>setStaticPathOption(..., .list = NULL)</code></dt><dd><p>Sets one or more
static path options. Each option can be given as a named argument, or as
a named item in <code>.list</code>.
</p>
</dd>
</dl>



<h3>Super class</h3>

<p><code><a href="#topic+Server">httpuv::Server</a></code> -&gt; <code>WebServer</code>
</p>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-WebServer-new"><code>WebServer$new()</code></a>
</p>
</li>
<li> <p><a href="#method-WebServer-getHost"><code>WebServer$getHost()</code></a>
</p>
</li>
<li> <p><a href="#method-WebServer-getPort"><code>WebServer$getPort()</code></a>
</p>
</li></ul>



<details><summary>Inherited methods</summary>
<ul>
<li><span class="pkg-link" data-pkg="httpuv" data-topic="Server" data-id="getStaticPathOptions"><a href='../../httpuv/html/Server.html#method-Server-getStaticPathOptions'><code>httpuv::Server$getStaticPathOptions()</code></a></span></li>
<li><span class="pkg-link" data-pkg="httpuv" data-topic="Server" data-id="getStaticPaths"><a href='../../httpuv/html/Server.html#method-Server-getStaticPaths'><code>httpuv::Server$getStaticPaths()</code></a></span></li>
<li><span class="pkg-link" data-pkg="httpuv" data-topic="Server" data-id="isRunning"><a href='../../httpuv/html/Server.html#method-Server-isRunning'><code>httpuv::Server$isRunning()</code></a></span></li>
<li><span class="pkg-link" data-pkg="httpuv" data-topic="Server" data-id="removeStaticPath"><a href='../../httpuv/html/Server.html#method-Server-removeStaticPath'><code>httpuv::Server$removeStaticPath()</code></a></span></li>
<li><span class="pkg-link" data-pkg="httpuv" data-topic="Server" data-id="setStaticPath"><a href='../../httpuv/html/Server.html#method-Server-setStaticPath'><code>httpuv::Server$setStaticPath()</code></a></span></li>
<li><span class="pkg-link" data-pkg="httpuv" data-topic="Server" data-id="setStaticPathOption"><a href='../../httpuv/html/Server.html#method-Server-setStaticPathOption'><code>httpuv::Server$setStaticPathOption()</code></a></span></li>
<li><span class="pkg-link" data-pkg="httpuv" data-topic="Server" data-id="stop"><a href='../../httpuv/html/Server.html#method-Server-stop'><code>httpuv::Server$stop()</code></a></span></li>
</ul>
</details>

<hr>
<a id="method-WebServer-new"></a>



<h4>Method <code>new()</code></h4>



<h5>Usage</h5>

<div class="r"><pre>WebServer$new(host, port, app, quiet = FALSE)</pre></div>


<hr>
<a id="method-WebServer-getHost"></a>



<h4>Method <code>getHost()</code></h4>



<h5>Usage</h5>

<div class="r"><pre>WebServer$getHost()</pre></div>


<hr>
<a id="method-WebServer-getPort"></a>



<h4>Method <code>getPort()</code></h4>



<h5>Usage</h5>

<div class="r"><pre>WebServer$getPort()</pre></div>




<h3>See Also</h3>

<p><code><a href="httpuv.html#topic+Server">Server</a></code> and <code><a href="httpuv.html#topic+PipeServer">PipeServer</a></code>.
</p>

<hr>
<h2 id='WebSocket'>WebSocket class</h2><span id='topic+WebSocket'></span>

<h3>Description</h3>

<p>A <code>WebSocket</code> object represents a single WebSocket connection. The
object can be used to send messages and close the connection, and to receive
notifications when messages are received or the connection is closed.
</p>


<h3>Details</h3>

<p>Note that this WebSocket class is different from the one provided by the
package named websocket. This class is meant to be used on the server side,
whereas the one in the websocket package is to be used as a client. The
WebSocket class in httpuv has an older API than the one in the websocket
package.
</p>
<p>WebSocket objects should never be created directly. They are obtained by
passing an <code>onWSOpen</code> function to <code><a href="httpuv.html#topic+startServer">startServer</a></code>.
</p>


<h3>Fields</h3>


<dl>
<dt><code>request</code></dt><dd>
<p>The Rook request environment that opened the connection. This can be
used to inspect HTTP headers, for example.
</p>
</dd>
</dl>



<h3>Methods</h3>


<dl>
<dt><code>onMessage(func)</code></dt><dd>
<p>Registers a callback function that will be invoked whenever a message
is received on this connection. The callback function will be invoked
with two arguments. The first argument is <code>TRUE</code> if the message
is binary and <code>FALSE</code> if it is text. The second argument is either
a raw vector (if the message is binary) or a character vector.
</p>
</dd>
<dt><code>onClose(func)</code></dt><dd>
<p>Registers a callback function that will be invoked when the connection
is closed.
</p>
</dd>
<dt><code>send(message)</code></dt><dd>
<p>Begins sending the given message over the websocket. The message must
be either a raw vector, or a single-element character vector that is
encoded in UTF-8.
</p>
</dd>
<dt><code>close()</code></dt><dd>
<p>Closes the websocket connection.
</p>
</dd>
</dl>



<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-WebSocket-new"><code>WebSocket$new()</code></a>
</p>
</li>
<li> <p><a href="#method-WebSocket-onMessage"><code>WebSocket$onMessage()</code></a>
</p>
</li>
<li> <p><a href="#method-WebSocket-onClose"><code>WebSocket$onClose()</code></a>
</p>
</li>
<li> <p><a href="#method-WebSocket-send"><code>WebSocket$send()</code></a>
</p>
</li>
<li> <p><a href="#method-WebSocket-close"><code>WebSocket$close()</code></a>
</p>
</li>
<li> <p><a href="#method-WebSocket-clone"><code>WebSocket$clone()</code></a>
</p>
</li></ul>


<hr>
<a id="method-WebSocket-new"></a>



<h4>Method <code>new()</code></h4>



<h5>Usage</h5>

<div class="r"><pre>WebSocket$new(handle, req)</pre></div>


<hr>
<a id="method-WebSocket-onMessage"></a>



<h4>Method <code>onMessage()</code></h4>



<h5>Usage</h5>

<div class="r"><pre>WebSocket$onMessage(func)</pre></div>


<hr>
<a id="method-WebSocket-onClose"></a>



<h4>Method <code>onClose()</code></h4>



<h5>Usage</h5>

<div class="r"><pre>WebSocket$onClose(func)</pre></div>


<hr>
<a id="method-WebSocket-send"></a>



<h4>Method <code>send()</code></h4>



<h5>Usage</h5>

<div class="r"><pre>WebSocket$send(message)</pre></div>


<hr>
<a id="method-WebSocket-close"></a>



<h4>Method <code>close()</code></h4>



<h5>Usage</h5>

<div class="r"><pre>WebSocket$close(code = 1000L, reason = "")</pre></div>


<hr>
<a id="method-WebSocket-clone"></a>



<h4>Method <code>clone()</code></h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>WebSocket$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt><dd><p>Whether to make a deep clone.</p>
</dd>
</dl>

</div>




<h3>Examples</h3>

<pre><code class='language-R'>
## Not run: 
# A WebSocket echo server that listens on port 8080
startServer("0.0.0.0", 8080,
  list(
    onHeaders = function(req) {
      # Print connection headers
      cat(capture.output(str(as.list(req))), sep = "\n")
    },
    onWSOpen = function(ws) {
      cat("Connection opened.\n")

      ws$onMessage(function(binary, message) {
        cat("Server received message:", message, "\n")
        ws$send(message)
      })
      ws$onClose(function() {
        cat("Connection closed.\n")
      })

    }
  )
)

## End(Not run)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
