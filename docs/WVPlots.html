<!DOCTYPE html><html><head><title>Help for package WVPlots</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {WVPlots}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#WVPlots-package'><p>WVPlots: Common Plots for Analysis</p></a></li>
<li><a href='#BinaryYScatterPlot'><p>Plot a scatter plot of a binary variable with smoothing curve.</p></a></li>
<li><a href='#ClevelandDotPlot'><p>Plot a Cleveland dot plot.</p></a></li>
<li><a href='#ConditionalSmoothedScatterPlot'><p>Plot a scatter plot with smoothing line.</p></a></li>
<li><a href='#DiscreteDistribution'><p>Plot distribution of a single discrete numerical variable.</p></a></li>
<li><a href='#DoubleDensityPlot'><p>Plot two density plots conditioned on an outcome variable.</p></a></li>
<li><a href='#DoubleHistogramPlot'><p>Plot two histograms conditioned on an outcome variable.</p></a></li>
<li><a href='#GainCurvePlot'><p>Plot the cumulative gain curve of a sort-order.</p></a></li>
<li><a href='#GainCurvePlotC'><p>Plot the cumulative gain curve of a sort-order with costs.</p></a></li>
<li><a href='#GainCurvePlotList'><p>Plot the cumulative gain curves of a sort-order.</p></a></li>
<li><a href='#GainCurvePlotWithNotation'><p>Plot the cumulative gain curve of a sort-order with extra notation</p></a></li>
<li><a href='#HexBinPlot'><p>Build a hex bin plot</p></a></li>
<li><a href='#LiftCurvePlot'><p>Plot the cumulative lift curve of a sort-order.</p></a></li>
<li><a href='#LiftCurvePlotList'><p>Plot the cumulative lift curves of a sort-order.</p></a></li>
<li><a href='#LogLogPlot'><p>Log-log plot</p></a></li>
<li><a href='#MetricPairPlot'><p>Plot the relationship between two metrics.</p></a></li>
<li><a href='#PairPlot'><p>Build a pair plot</p></a></li>
<li><a href='#plot_fit_trajectory'><p>Plot the trajectory of a model fit.</p></a></li>
<li><a href='#plot_Keras_fit_trajectory'><p>Plot the trajectory of a Keras model fit.</p></a></li>
<li><a href='#PlotDistCountBinomial'><p>Plot count data with a theoretical binomial</p></a></li>
<li><a href='#PlotDistCountNormal'><p>Plot distribution details as a histogram plus matching normal</p></a></li>
<li><a href='#PlotDistDensityBeta'><p>Plot empirical rate data as a density with the matching beta distribution</p></a></li>
<li><a href='#PlotDistDensityNormal'><p>Plot an empirical density with the matching normal distribution</p></a></li>
<li><a href='#PlotDistHistBeta'><p>Plot empirical rate data as a histogram plus matching beta</p></a></li>
<li><a href='#plotlyROC'><p>Use <code>plotly</code> to produce a ROC plot.</p></a></li>
<li><a href='#PRPlot'><p>Plot Precision-Recall plot.</p></a></li>
<li><a href='#PRTPlot'><p>Plot Precision-Recall or Enrichment-Recall as a function of threshold.</p></a></li>
<li><a href='#ROCPlot'><p>Plot receiver operating characteristic plot.</p></a></li>
<li><a href='#ROCPlotList'><p>Compare multiple ROC plots.</p></a></li>
<li><a href='#ROCPlotPair'><p>Compare two ROC plots.</p></a></li>
<li><a href='#ROCPlotPair2'><p>Compare two ROC plots.</p></a></li>
<li><a href='#ScatterBoxPlot'><p>Plot a scatter box plot.</p></a></li>
<li><a href='#ScatterBoxPlotH'><p>Plot a scatter box plot in horizontal mode.</p></a></li>
<li><a href='#ScatterHist'><p>Plot a scatter plot with marginals.</p></a></li>
<li><a href='#ScatterHistC'><p>Plot a conditional scatter plot with marginals.</p></a></li>
<li><a href='#ScatterHistN'><p>Plot a height scatter plot with marginals.</p></a></li>
<li><a href='#ShadedDensity'><p>Plot the distribution of a variable with a tail shaded</p></a></li>
<li><a href='#ShadedDensityCenter'><p>Plot the distribution of a variable with a center region shaded</p></a></li>
<li><a href='#ShadowHist'><p>Plot a Shadow Histogram Plot</p></a></li>
<li><a href='#ShadowPlot'><p>Plot a Shadow Bar Plot</p></a></li>
<li><a href='#simulate_aes_string'><p>Simulate the deprecated <code>ggplot2::aes_string()</code>.</p></a></li>
<li><a href='#ThresholdPlot'><p>Plot classifier metrics as a function of thresholds.</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Common Plots for Analysis</td>
</tr>
<tr>
<td>Version:</td>
<td>1.3.7</td>
</tr>
<tr>
<td>Date:</td>
<td>2023-08-19</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/WinVector/WVPlots">https://github.com/WinVector/WVPlots</a>,
<a href="https://winvector.github.io/WVPlots/">https://winvector.github.io/WVPlots/</a></td>
</tr>
<tr>
<td>Maintainer:</td>
<td>John Mount &lt;jmount@win-vector.com&gt;</td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/WinVector/WVPlots/issues">https://github.com/WinVector/WVPlots/issues</a></td>
</tr>
<tr>
<td>Description:</td>
<td>Select data analysis plots, under a standardized calling interface implemented on top of 'ggplot2' and 'plotly'.  
   Plots of interest include: 'ROC', gain curve, scatter plot with marginal distributions, 
   conditioned scatter plot with marginal densities,
   box and stem with matching theoretical distribution, and density with matching theoretical distribution.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.4.0), wrapr (&ge; 2.0.9)</td>
</tr>
<tr>
<td>Imports:</td>
<td>ggplot2 (&ge; 3.4.0), sigr (&ge; 1.1.4), cdata (&ge; 1.2.0),
rqdatatable (&ge; 1.3.1), rquery (&ge; 1.4.9), rlang, utils, grid,
gridExtra, graphics, grDevices, mgcv, stats</td>
</tr>
<tr>
<td>Suggests:</td>
<td>data.table, knitr, rmarkdown, plotly, hexbin, tinytest</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>ByteCompile:</td>
<td>true</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-08-20 01:24:05 UTC; johnmount</td>
</tr>
<tr>
<td>Author:</td>
<td>John Mount [aut, cre],
  Nina Zumel [aut],
  Win-Vector LLC [cph]</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-08-20 03:12:32 UTC</td>
</tr>
</table>
<hr>
<h2 id='WVPlots-package'>WVPlots: Common Plots for Analysis</h2><span id='topic+WVPlots'></span><span id='topic+WVPlots-package'></span>

<h3>Description</h3>

<p>Select data analysis plots, under a standardized calling interface implemented
on top of <code>ggplot2</code> and <code>plotly</code>.
Plots of interest include: <code>ROC</code>, gain curve, scatter plot with marginal distributions,
conditioned scatter plot with marginal densities.
box and stem with matching theoretical distribution, density with matching theoretical distribution.
</p>


<h3>Details</h3>

<p>For more information:
</p>

<ul>
<li> <p><code>vignette(package='WVPlots')</code>
</p>
</li>
<li> <p><code>RShowDoc('WVPlots_examples',package='WVPlots')</code>
</p>
</li>
<li><p> Website: <a href="https://github.com/WinVector/WVPlots">https://github.com/WinVector/WVPlots</a> </p>
</li></ul>



<h3>Author(s)</h3>

<p><strong>Maintainer</strong>: John Mount <a href="mailto:jmount@win-vector.com">jmount@win-vector.com</a>
</p>
<p>Authors:
</p>

<ul>
<li><p> Nina Zumel <a href="mailto:nzumel@win-vector.com">nzumel@win-vector.com</a>
</p>
</li></ul>

<p>Other contributors:
</p>

<ul>
<li><p>  Win-Vector LLC [copyright holder]
</p>
</li></ul>



<h3>See Also</h3>

<p>Useful links:
</p>

<ul>
<li> <p><a href="https://github.com/WinVector/WVPlots">https://github.com/WinVector/WVPlots</a>
</p>
</li>
<li> <p><a href="https://winvector.github.io/WVPlots/">https://winvector.github.io/WVPlots/</a>
</p>
</li>
<li><p> Report bugs at <a href="https://github.com/WinVector/WVPlots/issues">https://github.com/WinVector/WVPlots/issues</a>
</p>
</li></ul>


<hr>
<h2 id='BinaryYScatterPlot'>Plot a scatter plot of a binary variable with smoothing curve.</h2><span id='topic+BinaryYScatterPlot'></span>

<h3>Description</h3>

<p>Plot the scatter plot of a binary variable with a smoothing curve.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>BinaryYScatterPlot(
  frame,
  xvar,
  yvar,
  title,
  ...,
  se = FALSE,
  use_glm = TRUE,
  point_color = "black",
  smooth_color = "blue"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="BinaryYScatterPlot_+3A_frame">frame</code></td>
<td>
<p>data frame to get values from</p>
</td></tr>
<tr><td><code id="BinaryYScatterPlot_+3A_xvar">xvar</code></td>
<td>
<p>name of the independent column in frame</p>
</td></tr>
<tr><td><code id="BinaryYScatterPlot_+3A_yvar">yvar</code></td>
<td>
<p>name of the dependent (output or result to be modeled) column in frame</p>
</td></tr>
<tr><td><code id="BinaryYScatterPlot_+3A_title">title</code></td>
<td>
<p>title to place on plot</p>
</td></tr>
<tr><td><code id="BinaryYScatterPlot_+3A_...">...</code></td>
<td>
<p>no unnamed argument, added to force named binding of later arguments.</p>
</td></tr>
<tr><td><code id="BinaryYScatterPlot_+3A_se">se</code></td>
<td>
<p>if TRUE, add error bars (defaults to FALSE). Ignored if useGLM is TRUE</p>
</td></tr>
<tr><td><code id="BinaryYScatterPlot_+3A_use_glm">use_glm</code></td>
<td>
<p>if TRUE, &quot;smooths&quot; with a one-variable logistic regression (defaults to TRUE)</p>
</td></tr>
<tr><td><code id="BinaryYScatterPlot_+3A_point_color">point_color</code></td>
<td>
<p>color for points</p>
</td></tr>
<tr><td><code id="BinaryYScatterPlot_+3A_smooth_color">smooth_color</code></td>
<td>
<p>color for smoothing line</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The points are jittered for legibility. By default, a logistic regression fit is
used, so that the smoothing curve represents the probability of y == 1 (as fit by
the logistic regression). If
<code>use_glm</code> is set to FALSE, a standard smoothing curve (either loess or a
spline fit) is used.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
if (requireNamespace('data.table', quietly = TRUE)) {
	# don't multi-thread during CRAN checks
		data.table::setDTthreads(1)
}

set.seed(34903490)
x = rnorm(50)
y = 0.5*x^2 + 2*x + rnorm(length(x))
frm = data.frame(x=x,y=y,yC=y&gt;=as.numeric(quantile(y,probs=0.8)))
frm$absY &lt;- abs(frm$y)
frm$posY = frm$y &gt; 0
frm$costX = 1
WVPlots::BinaryYScatterPlot(frm, "x", "posY",
   title="Example 'Probability of Y' Plot")

</code></pre>

<hr>
<h2 id='ClevelandDotPlot'>Plot a Cleveland dot plot.</h2><span id='topic+ClevelandDotPlot'></span>

<h3>Description</h3>

<p>Plot counts of a categorical variable.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ClevelandDotPlot(
  frm,
  xvar,
  title,
  ...,
  sort = -1,
  limit_n = NULL,
  stem = TRUE,
  color = "black"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ClevelandDotPlot_+3A_frm">frm</code></td>
<td>
<p>data frame to get values from</p>
</td></tr>
<tr><td><code id="ClevelandDotPlot_+3A_xvar">xvar</code></td>
<td>
<p>name of the independent (input or model) column in frame</p>
</td></tr>
<tr><td><code id="ClevelandDotPlot_+3A_title">title</code></td>
<td>
<p>title to place on plot</p>
</td></tr>
<tr><td><code id="ClevelandDotPlot_+3A_...">...</code></td>
<td>
<p>no unnamed argument, added to force named binding of later arguments.</p>
</td></tr>
<tr><td><code id="ClevelandDotPlot_+3A_sort">sort</code></td>
<td>
<p>if TRUE sort data</p>
</td></tr>
<tr><td><code id="ClevelandDotPlot_+3A_limit_n">limit_n</code></td>
<td>
<p>if not NULL number of items to plot</p>
</td></tr>
<tr><td><code id="ClevelandDotPlot_+3A_stem">stem</code></td>
<td>
<p>if TRUE add stems/whiskers to plot</p>
</td></tr>
<tr><td><code id="ClevelandDotPlot_+3A_color">color</code></td>
<td>
<p>color for points and stems</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Assumes that <code>xvar</code> is a factor or can be coerced to one (character or integral).
</p>

<ul>
<li><p> sort &lt; 0 sorts the factor levels in decreasing order (most frequent level first)
</p>
</li>
<li><p> sort &gt; 0 sorts the factor levels in increasing order (good when used in conjunction with coord_flip())
</p>
</li>
<li><p> sort = 0 leaves the factor levels in &quot;natural order&quot; &ndash; usually alphabetical
</p>
</li>
<li><p> stem = FALSE will plot only the dots, without the stem to the y=0 line.
</p>
</li>
<li><p> limit_n = NULL plots all the levels, N an integer limits to the top N most populous levels
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>
if (requireNamespace('data.table', quietly = TRUE)) {
	# don't multi-thread during CRAN checks
		data.table::setDTthreads(1)
}

set.seed(34903490)
# discrete variable: letters of the alphabet
# frequencies of letters in English
# source: http://en.algoritmy.net/article/40379/Letter-frequency-English
letterFreqs = c(8.167, 1.492, 2.782, 4.253, 12.702, 2.228,
                2.015, 6.094, 6.966, 0.153, 0.772, 4.025, 2.406, 6.749, 7.507, 1.929,
                0.095, 5.987, 6.327, 9.056, 2.758, 0.978, 2.360, 0.150, 1.974, 0.074)
letterFreqs = letterFreqs/100
letterFrame = data.frame(letter = letters, freq=letterFreqs)
# now let's generate letters according to their letter frequencies
N = 1000
randomDraws = data.frame(draw=1:N,
  letter=sample(letterFrame$letter, size=N,
  replace=TRUE, prob=letterFrame$freq))
WVPlots::ClevelandDotPlot(randomDraws, "letter",
  title = "Example Cleveland-style dot plot")

# # Note the use of sort = 0. Also note that the graph omits counts
# # with no occurrences (5, and 7)
# WVPlots::ClevelandDotPlot(mtcars, "carb", sort = 0, "Example of counting integer values")

# # For counting integer values while including counts with no occurrences,
# # use Discrete Distribution.
# WVPlots::DiscreteDistribution(mtcars, "carb", "Better way to count integer values")
</code></pre>

<hr>
<h2 id='ConditionalSmoothedScatterPlot'>Plot a scatter plot with smoothing line.</h2><span id='topic+ConditionalSmoothedScatterPlot'></span>

<h3>Description</h3>

<p>Plot a scatter plot with a smoothing line; the smoothing window is aligned either left, center or right.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ConditionalSmoothedScatterPlot(
  frame,
  xvar,
  yvar,
  groupvar = NULL,
  title = "ConditionalSmoothedScatterPlot",
  ...,
  k = 3,
  align = "center",
  point_color = "black",
  point_alpha = 0.2,
  smooth_color = "black",
  palette = "Dark2"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ConditionalSmoothedScatterPlot_+3A_frame">frame</code></td>
<td>
<p>data frame to get values from</p>
</td></tr>
<tr><td><code id="ConditionalSmoothedScatterPlot_+3A_xvar">xvar</code></td>
<td>
<p>name of the independent column in frame. Assumed to be regularly spaced</p>
</td></tr>
<tr><td><code id="ConditionalSmoothedScatterPlot_+3A_yvar">yvar</code></td>
<td>
<p>name of the dependent (output or result to be modeled) column in frame</p>
</td></tr>
<tr><td><code id="ConditionalSmoothedScatterPlot_+3A_groupvar">groupvar</code></td>
<td>
<p>name of the grouping column in frame. Can be NULL for an unconditional plot</p>
</td></tr>
<tr><td><code id="ConditionalSmoothedScatterPlot_+3A_title">title</code></td>
<td>
<p>title for plot</p>
</td></tr>
<tr><td><code id="ConditionalSmoothedScatterPlot_+3A_...">...</code></td>
<td>
<p>no unnamed argument, added to force named binding of later arguments.</p>
</td></tr>
<tr><td><code id="ConditionalSmoothedScatterPlot_+3A_k">k</code></td>
<td>
<p>width of smoothing window. Must be odd for a center-aligned plot. Defaults to 3</p>
</td></tr>
<tr><td><code id="ConditionalSmoothedScatterPlot_+3A_align">align</code></td>
<td>
<p>smoothing window alignment: 'center', 'left', or 'right'. Defaults to 'center'</p>
</td></tr>
<tr><td><code id="ConditionalSmoothedScatterPlot_+3A_point_color">point_color</code></td>
<td>
<p>color of points, when groupvar is NULL. Set to NULL to turn off points.</p>
</td></tr>
<tr><td><code id="ConditionalSmoothedScatterPlot_+3A_point_alpha">point_alpha</code></td>
<td>
<p>alpha/opaqueness of points.</p>
</td></tr>
<tr><td><code id="ConditionalSmoothedScatterPlot_+3A_smooth_color">smooth_color</code></td>
<td>
<p>color of smoothing line, when groupvar is NULL</p>
</td></tr>
<tr><td><code id="ConditionalSmoothedScatterPlot_+3A_palette">palette</code></td>
<td>
<p>name of Brewer palette, when groupvar is non-NULL (can be NULL)</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>xvar</code> is the continuous independent variable and <code>yvar</code> is the dependent binary variable.
Smoothing is by a square window of width <code>k</code>.
</p>
<p>If <code>palette</code> is NULL, and <code>groupvar</code> is non-NULL, plot colors will be chosen from the default ggplot2 palette.
Setting <code>palette</code> to NULL
allows the user to choose a non-Brewer palette, for example with <code><a href="ggplot2.html#topic+scale_manual">scale_fill_manual</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
if (requireNamespace('data.table', quietly = TRUE)) {
	# don't multi-thread during CRAN checks
		data.table::setDTthreads(1)
}

y = c(1,2,3,4,5,10,15,18,20,25)
x = seq_len(length(y))
df = data.frame(x=x, y=y, group=x&gt;5)
WVPlots::ConditionalSmoothedScatterPlot(df, "x", "y", NULL,
   title="left smooth, one group", align="left")
# WVPlots::ConditionalSmoothedScatterPlot(df, "x", "y", "group",
#    title="left smooth, two groups", align="left")

</code></pre>

<hr>
<h2 id='DiscreteDistribution'>Plot distribution of a single discrete numerical variable.</h2><span id='topic+DiscreteDistribution'></span>

<h3>Description</h3>

<p>Similar to calling <code>ClevelandDotPlot</code> with <code>sort = 0</code> on a numerical x variable that
takes on a discrete set of values.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>DiscreteDistribution(frm, xvar, title, ..., stem = TRUE, color = "black")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="DiscreteDistribution_+3A_frm">frm</code></td>
<td>
<p>data frame to get values from</p>
</td></tr>
<tr><td><code id="DiscreteDistribution_+3A_xvar">xvar</code></td>
<td>
<p>numeric: name of the variable whose distribution is to be plotted</p>
</td></tr>
<tr><td><code id="DiscreteDistribution_+3A_title">title</code></td>
<td>
<p>title to place on plot</p>
</td></tr>
<tr><td><code id="DiscreteDistribution_+3A_...">...</code></td>
<td>
<p>no unnamed argument, added to force named binding of later arguments.</p>
</td></tr>
<tr><td><code id="DiscreteDistribution_+3A_stem">stem</code></td>
<td>
<p>if TRUE add whisker/stems to plot</p>
</td></tr>
<tr><td><code id="DiscreteDistribution_+3A_color">color</code></td>
<td>
<p>color of points and stems</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>
if (requireNamespace('data.table', quietly = TRUE)) {
	# don't multi-thread during CRAN checks
		data.table::setDTthreads(1)
}

frmx = data.frame(x = rbinom(1000, 20, 0.5))
WVPlots::DiscreteDistribution(frmx, "x","Discrete example")

</code></pre>

<hr>
<h2 id='DoubleDensityPlot'>Plot two density plots conditioned on an outcome variable.</h2><span id='topic+DoubleDensityPlot'></span>

<h3>Description</h3>

<p>Plot two density plots conditioned on a binary outcome variable.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>DoubleDensityPlot(
  frame,
  xvar,
  truthVar,
  title,
  ...,
  truth_target = NULL,
  palette = "Dark2"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="DoubleDensityPlot_+3A_frame">frame</code></td>
<td>
<p>data frame to get values from</p>
</td></tr>
<tr><td><code id="DoubleDensityPlot_+3A_xvar">xvar</code></td>
<td>
<p>name of the independent (input or model) column in frame</p>
</td></tr>
<tr><td><code id="DoubleDensityPlot_+3A_truthvar">truthVar</code></td>
<td>
<p>name of the dependent (output or result to be modeled) column in frame</p>
</td></tr>
<tr><td><code id="DoubleDensityPlot_+3A_title">title</code></td>
<td>
<p>title to place on plot</p>
</td></tr>
<tr><td><code id="DoubleDensityPlot_+3A_...">...</code></td>
<td>
<p>no unnamed argument, added to force named binding of later arguments.</p>
</td></tr>
<tr><td><code id="DoubleDensityPlot_+3A_truth_target">truth_target</code></td>
<td>
<p>if not NULL compare to this scalar value.</p>
</td></tr>
<tr><td><code id="DoubleDensityPlot_+3A_palette">palette</code></td>
<td>
<p>name of Brewer palette (can be NULL)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The use case for this visualization is to plot the distribution of a predictive model score
(usually the predicted probability
of a desired outcome) conditioned on the actual outcome. However, you can use it to compare the distribution of any
numerical quantity conditioned on a binary feature. See the examples.
</p>
<p>The plot will degrade gracefully in degenerate conditions, for example when only
one category is present.
</p>
<p>If <code>palette</code> is NULL, plot colors will be chosen from the default ggplot2 palette. Setting <code>palette</code> to NULL
allows the user to choose a non-Brewer palette, for example with <code><a href="ggplot2.html#topic+scale_manual">scale_fill_manual</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
if (requireNamespace('data.table', quietly = TRUE)) {
	# don't multi-thread during CRAN checks
		data.table::setDTthreads(1)
}

mpg = ggplot2::mpg
mpg$trans = gsub("\\(.*$", '', mpg$trans)
WVPlots::DoubleDensityPlot(mpg, "cty", "trans", "City driving mpg by transmission type")

if (FALSE) {
# redo the last plot with a custom palette
cmap = c("auto" = "#b2df8a", "manual" = "#1f78b4")
plt = WVPlots::DoubleDensityPlot(mpg, "cty", "trans",
              palette = NULL,
              title="City driving mpg by transmission type")
plt + ggplot2::scale_color_manual(values=cmap) +
      ggplot2::scale_fill_manual(values=cmap)

set.seed(34903490)
x = rnorm(50)
y = 0.5*x^2 + 2*x + rnorm(length(x))
frm = data.frame(score=x,
   truth=(y&gt;=as.numeric(quantile(y,probs=0.8))),
   stuck=TRUE,
   rare=FALSE)
frm[1,'rare'] = TRUE
WVPlots::DoubleDensityPlot(frm, "score", "truth", title="Example double density plot")
}

</code></pre>

<hr>
<h2 id='DoubleHistogramPlot'>Plot two histograms conditioned on an outcome variable.</h2><span id='topic+DoubleHistogramPlot'></span>

<h3>Description</h3>

<p>Plot two histograms conditioned on a binary outcome variable.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>DoubleHistogramPlot(
  frame,
  xvar,
  truthVar,
  title,
  ...,
  palette = "Dark2",
  breaks = 40
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="DoubleHistogramPlot_+3A_frame">frame</code></td>
<td>
<p>data frame to get values from</p>
</td></tr>
<tr><td><code id="DoubleHistogramPlot_+3A_xvar">xvar</code></td>
<td>
<p>name of the independent (input or model) column in frame</p>
</td></tr>
<tr><td><code id="DoubleHistogramPlot_+3A_truthvar">truthVar</code></td>
<td>
<p>name of the dependent (output or result to be modeled) column in frame</p>
</td></tr>
<tr><td><code id="DoubleHistogramPlot_+3A_title">title</code></td>
<td>
<p>title to place on plot</p>
</td></tr>
<tr><td><code id="DoubleHistogramPlot_+3A_...">...</code></td>
<td>
<p>no unnamed argument, added to force named binding of later arguments.</p>
</td></tr>
<tr><td><code id="DoubleHistogramPlot_+3A_palette">palette</code></td>
<td>
<p>name of Brewer palette (can be NULL)</p>
</td></tr>
<tr><td><code id="DoubleHistogramPlot_+3A_breaks">breaks</code></td>
<td>
<p>breaks to pass to histogram</p>
</td></tr>
</table>


<h3>Details</h3>

<p>To distinguish the two conditions, one histogram is plotted upside-down.
</p>
<p>The use case for this visualization is to plot a predictive model score (usually the predicted probability
of a desired outcome) conditioned on the actual outcome. However, you can use it to compare any
numerical quantity conditioned on a binary feature.
</p>
<p>If <code>palette</code> is NULL, plot colors will be chosen from the default ggplot2 palette. Setting <code>palette</code> to NULL
allows the user to choose a non-Brewer palette, for example with <code><a href="ggplot2.html#topic+scale_manual">scale_fill_manual</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
if (requireNamespace('data.table', quietly = TRUE)) {
	# don't multi-thread during CRAN checks
		data.table::setDTthreads(1)
}

set.seed(34903490)
x = rnorm(50)
y = 0.5*x^2 + 2*x + rnorm(length(x))
frm = data.frame(x=x,y=y,yC=y&gt;=as.numeric(quantile(y,probs=0.8)))
frm$absY &lt;- abs(frm$y)
frm$posY = frm$y &gt; 0
frm$costX = 1
WVPlots::DoubleHistogramPlot(frm, "x", "yC", title="Example double histogram plot")

if (FALSE) {
# redo the plot with a custom palette
plt = WVPlots::DoubleHistogramPlot(frm, "x", "yC", palette=NULL,
                              title="Example double histogram plot")
cmap = c("TRUE" = "#b2df8a", "FALSE" = "#1f78b4")
plt + ggplot2::scale_color_manual(values=cmap) +
      ggplot2::scale_fill_manual(values=cmap)
}

</code></pre>

<hr>
<h2 id='GainCurvePlot'>Plot the cumulative gain curve of a sort-order.</h2><span id='topic+GainCurvePlot'></span>

<h3>Description</h3>

<p>Plot the cumulative gain curve of a sort-order.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>GainCurvePlot(
  frame,
  xvar,
  truthVar,
  title,
  ...,
  estimate_sig = FALSE,
  large_count = 1000,
  truth_target = NULL,
  model_color = "darkblue",
  wizard_color = "darkgreen",
  shadow_color = "darkgray"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="GainCurvePlot_+3A_frame">frame</code></td>
<td>
<p>data frame to get values from</p>
</td></tr>
<tr><td><code id="GainCurvePlot_+3A_xvar">xvar</code></td>
<td>
<p>name of the independent (input or model score) column in frame</p>
</td></tr>
<tr><td><code id="GainCurvePlot_+3A_truthvar">truthVar</code></td>
<td>
<p>name of the dependent (output or result to be modeled) column in frame</p>
</td></tr>
<tr><td><code id="GainCurvePlot_+3A_title">title</code></td>
<td>
<p>title to place on plot</p>
</td></tr>
<tr><td><code id="GainCurvePlot_+3A_...">...</code></td>
<td>
<p>no unnamed argument, added to force named binding of later arguments.</p>
</td></tr>
<tr><td><code id="GainCurvePlot_+3A_estimate_sig">estimate_sig</code></td>
<td>
<p>logical, if TRUE compute significance.</p>
</td></tr>
<tr><td><code id="GainCurvePlot_+3A_large_count">large_count</code></td>
<td>
<p>numeric, upper bound target for number of plotting points.</p>
</td></tr>
<tr><td><code id="GainCurvePlot_+3A_truth_target">truth_target</code></td>
<td>
<p>if not NULL compare to this scalar value.</p>
</td></tr>
<tr><td><code id="GainCurvePlot_+3A_model_color">model_color</code></td>
<td>
<p>color for the model curve</p>
</td></tr>
<tr><td><code id="GainCurvePlot_+3A_wizard_color">wizard_color</code></td>
<td>
<p>color for the &quot;wizard&quot; (best possible) curve</p>
</td></tr>
<tr><td><code id="GainCurvePlot_+3A_shadow_color">shadow_color</code></td>
<td>
<p>color for the shaded area under the curve</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The use case for this visualization is to compare a predictive model
score to an actual outcome (either binary (0/1) or continuous). In this case the
gain curve plot measures how well the model score sorts the data compared
to the true outcome value.
</p>
<p>The x-axis represents the fraction of items seen when sorted by score, and the
y-axis represents the cumulative summed true outcome represented by the items seen so far.
See, for example,
<a href="https://www.ibm.com/docs/SSLVMB_24.0.0/spss/tutorials/mlp_bankloan_outputtype_02.html">https://www.ibm.com/docs/SSLVMB_24.0.0/spss/tutorials/mlp_bankloan_outputtype_02.html</a>.
</p>
<p>For comparison, <code>GainCurvePlot</code> also plots the &quot;wizard curve&quot;: the gain curve when the
data is sorted according to its true outcome.
</p>
<p>To improve presentation quality, the plot is limited to approximately <code>large_count</code> points (default: 1000).
For larger data sets, the data is appropriately randomly sampled down before plotting.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
if (requireNamespace('data.table', quietly = TRUE)) {
	# don't multi-thread during CRAN checks
		data.table::setDTthreads(1)
}

set.seed(34903490)
y = abs(rnorm(20)) + 0.1
x = abs(y + 0.5*rnorm(20))
frm = data.frame(model=x, value=y)
WVPlots::GainCurvePlot(frm, "model", "value",
   title="Example Continuous Gain Curve")

</code></pre>

<hr>
<h2 id='GainCurvePlotC'>Plot the cumulative gain curve of a sort-order with costs.</h2><span id='topic+GainCurvePlotC'></span>

<h3>Description</h3>

<p>Plot the cumulative gain curve of a sort-order with costs.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>GainCurvePlotC(
  frame,
  xvar,
  costVar,
  truthVar,
  title,
  ...,
  estimate_sig = FALSE,
  large_count = 1000,
  model_color = "darkblue",
  wizard_color = "darkgreen",
  shadow_color = "darkgray"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="GainCurvePlotC_+3A_frame">frame</code></td>
<td>
<p>data frame to get values from</p>
</td></tr>
<tr><td><code id="GainCurvePlotC_+3A_xvar">xvar</code></td>
<td>
<p>name of the independent (input or model score) column in frame</p>
</td></tr>
<tr><td><code id="GainCurvePlotC_+3A_costvar">costVar</code></td>
<td>
<p>cost of each item (drives x-axis sum)</p>
</td></tr>
<tr><td><code id="GainCurvePlotC_+3A_truthvar">truthVar</code></td>
<td>
<p>name of the dependent (output or result to be modeled) column in frame</p>
</td></tr>
<tr><td><code id="GainCurvePlotC_+3A_title">title</code></td>
<td>
<p>title to place on plot</p>
</td></tr>
<tr><td><code id="GainCurvePlotC_+3A_...">...</code></td>
<td>
<p>no unnamed argument, added to force named binding of later arguments.</p>
</td></tr>
<tr><td><code id="GainCurvePlotC_+3A_estimate_sig">estimate_sig</code></td>
<td>
<p>logical, if TRUE compute significance</p>
</td></tr>
<tr><td><code id="GainCurvePlotC_+3A_large_count">large_count</code></td>
<td>
<p>numeric, upper bound target for number of plotting points</p>
</td></tr>
<tr><td><code id="GainCurvePlotC_+3A_model_color">model_color</code></td>
<td>
<p>color for the model curve</p>
</td></tr>
<tr><td><code id="GainCurvePlotC_+3A_wizard_color">wizard_color</code></td>
<td>
<p>color for the &quot;wizard&quot; (best possible) curve</p>
</td></tr>
<tr><td><code id="GainCurvePlotC_+3A_shadow_color">shadow_color</code></td>
<td>
<p>color for the shaded area under the curve</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>GainCurvePlotC</code> plots a cumulative gain curve for the case where
items have an additional cost, in addition to an outcome value.
</p>
<p>The x-axis represents the fraction of total cost experienced when items are sorted by score, and the
y-axis represents the cumulative summed true outcome represented by the items seen so far.
</p>
<p>For comparison, <code>GainCurvePlotC</code> also plots the &quot;wizard curve&quot;: the gain curve when the
data is sorted according to its true outcome/cost (the optimal sort order).
</p>
<p>To improve presentation quality, the plot is limited to approximately <code>large_count</code> points (default: 1000).
For larger data sets, the data is appropriately randomly sampled down before plotting.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+GainCurvePlot">GainCurvePlot</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
if (requireNamespace('data.table', quietly = TRUE)) {
	# don't multi-thread during CRAN checks
		data.table::setDTthreads(1)
}

set.seed(34903490)
y = abs(rnorm(20)) + 0.1
x = abs(y + 0.5*rnorm(20))
frm = data.frame(model=x, value=y)
frm$costs=1
frm$costs[1]=5
WVPlots::GainCurvePlotC(frm, "model", "costs", "value",
   title="Example Continuous Gain CurveC")

</code></pre>

<hr>
<h2 id='GainCurvePlotList'>Plot the cumulative gain curves of a sort-order.</h2><span id='topic+GainCurvePlotList'></span><span id='topic+GainCurveListPlot'></span>

<h3>Description</h3>

<p>Plot the cumulative gain curves of a sort-order.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>GainCurvePlotList(
  frame,
  xvars,
  truthVar,
  title,
  ...,
  truth_target = NULL,
  palette = "Dark2"
)

GainCurveListPlot(
  frame,
  xvars,
  truthVar,
  title,
  ...,
  truth_target = NULL,
  palette = "Dark2"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="GainCurvePlotList_+3A_frame">frame</code></td>
<td>
<p>data frame to get values from</p>
</td></tr>
<tr><td><code id="GainCurvePlotList_+3A_xvars">xvars</code></td>
<td>
<p>name of the independent (input or model score) columns in frame</p>
</td></tr>
<tr><td><code id="GainCurvePlotList_+3A_truthvar">truthVar</code></td>
<td>
<p>name of the dependent (output or result to be modeled) column in frame</p>
</td></tr>
<tr><td><code id="GainCurvePlotList_+3A_title">title</code></td>
<td>
<p>title to place on plot</p>
</td></tr>
<tr><td><code id="GainCurvePlotList_+3A_...">...</code></td>
<td>
<p>no unnamed argument, added to force named binding of later arguments.</p>
</td></tr>
<tr><td><code id="GainCurvePlotList_+3A_truth_target">truth_target</code></td>
<td>
<p>if not NULL compare to this scalar value.</p>
</td></tr>
<tr><td><code id="GainCurvePlotList_+3A_palette">palette</code></td>
<td>
<p>color palette for the model curves</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The use case for this visualization is to compare a predictive model
score to an actual outcome (either binary (0/1) or continuous). In this case the
gain curve plot measures how well the model score sorts the data compared
to the true outcome value.
</p>
<p>The x-axis represents the fraction of items seen when sorted by score, and the
y-axis represents the gain seen so far (cumulative value of model over cummulative value of random selection)..
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
if (requireNamespace('data.table', quietly = TRUE)) {
	# don't multi-thread during CRAN checks
		data.table::setDTthreads(1)
}

set.seed(34903490)
y = abs(rnorm(20)) + 0.1
x = abs(y + 0.5*rnorm(20))
frm = data.frame(model=x, value=y)
WVPlots::GainCurvePlotList(frm, c("model", "value"), "value",
   title="Example Continuous gain Curves")

</code></pre>

<hr>
<h2 id='GainCurvePlotWithNotation'>Plot the cumulative gain curve of a sort-order with extra notation</h2><span id='topic+GainCurvePlotWithNotation'></span>

<h3>Description</h3>

<p>Plot the cumulative gain curve of a sort-order with extra notation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>GainCurvePlotWithNotation(
  frame,
  xvar,
  truthVar,
  title,
  gainx,
  labelfun,
  ...,
  sort_by_model = TRUE,
  estimate_sig = FALSE,
  large_count = 1000,
  model_color = "darkblue",
  wizard_color = "darkgreen",
  shadow_color = "darkgray",
  crosshair_color = "red",
  text_color = "black"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="GainCurvePlotWithNotation_+3A_frame">frame</code></td>
<td>
<p>data frame to get values from</p>
</td></tr>
<tr><td><code id="GainCurvePlotWithNotation_+3A_xvar">xvar</code></td>
<td>
<p>name of the independent (input or model score) column in frame</p>
</td></tr>
<tr><td><code id="GainCurvePlotWithNotation_+3A_truthvar">truthVar</code></td>
<td>
<p>name of the dependent (output or result to be modeled) column in frame</p>
</td></tr>
<tr><td><code id="GainCurvePlotWithNotation_+3A_title">title</code></td>
<td>
<p>title to place on plot</p>
</td></tr>
<tr><td><code id="GainCurvePlotWithNotation_+3A_gainx">gainx</code></td>
<td>
<p>the point on the x axis corresponding to the desired label</p>
</td></tr>
<tr><td><code id="GainCurvePlotWithNotation_+3A_labelfun">labelfun</code></td>
<td>
<p>a function to return a label for the marked point</p>
</td></tr>
<tr><td><code id="GainCurvePlotWithNotation_+3A_...">...</code></td>
<td>
<p>no unnamed argument, added to force named binding of later arguments.</p>
</td></tr>
<tr><td><code id="GainCurvePlotWithNotation_+3A_sort_by_model">sort_by_model</code></td>
<td>
<p>logical, if TRUE use the model to calculate gainy, else use wizard.</p>
</td></tr>
<tr><td><code id="GainCurvePlotWithNotation_+3A_estimate_sig">estimate_sig</code></td>
<td>
<p>logical, if TRUE compute significance</p>
</td></tr>
<tr><td><code id="GainCurvePlotWithNotation_+3A_large_count">large_count</code></td>
<td>
<p>numeric, upper bound target for number of plotting points</p>
</td></tr>
<tr><td><code id="GainCurvePlotWithNotation_+3A_model_color">model_color</code></td>
<td>
<p>color for the model curve</p>
</td></tr>
<tr><td><code id="GainCurvePlotWithNotation_+3A_wizard_color">wizard_color</code></td>
<td>
<p>color for the &quot;wizard&quot; (best possible) curve</p>
</td></tr>
<tr><td><code id="GainCurvePlotWithNotation_+3A_shadow_color">shadow_color</code></td>
<td>
<p>color for the shaded area under the curve</p>
</td></tr>
<tr><td><code id="GainCurvePlotWithNotation_+3A_crosshair_color">crosshair_color</code></td>
<td>
<p>color for the annotation location lines</p>
</td></tr>
<tr><td><code id="GainCurvePlotWithNotation_+3A_text_color">text_color</code></td>
<td>
<p>color for the annotation text</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This is the standard gain curve plot (see <code><a href="#topic+GainCurvePlot">GainCurvePlot</a></code>) with
a label attached to a particular value of x. The label is created by
a function <code>labelfun</code>, which takes as inputs the x and y coordinates
of a label and returns a string (the label).
</p>
<p>By default, uses the model to calculate the y value of the calculated point;
to use the wizard curve, set <code>sort_by_model = FALSE</code>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+GainCurvePlot">GainCurvePlot</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
if (requireNamespace('data.table', quietly = TRUE)) {
	# don't multi-thread during CRAN checks
		data.table::setDTthreads(1)
}

set.seed(34903490)
y = abs(rnorm(20)) + 0.1
x = abs(y + 0.5*rnorm(20))
frm = data.frame(model=x, value=y)
gainx = 0.25  # get the predicted top 25% most valuable points as sorted by the model
# make a function to calculate the label for the annotated point
labelfun = function(gx, gy) {
  pctx = gx*100
  pcty = gy*100

  paste("The predicted top ", pctx, "% most valuable points by the model\n",
        "are ", pcty, "% of total actual value", sep='')
}
WVPlots::GainCurvePlotWithNotation(frm, "model", "value",
   title="Example Gain Curve with annotation",
   gainx=gainx,labelfun=labelfun)

# now get the top 25% actual most valuable points

labelfun = function(gx, gy) {
  pctx = gx*100
  pcty = gy*100

  paste("The actual top ", pctx, "% most valuable points\n",
        "are ", pcty, "% of total actual value", sep='')
}

WVPlots::GainCurvePlotWithNotation(frm, "model", "value",
   title="Example Gain Curve with annotation",
   gainx=gainx,labelfun=labelfun, sort_by_model=FALSE)

</code></pre>

<hr>
<h2 id='HexBinPlot'>Build a hex bin plot</h2><span id='topic+HexBinPlot'></span>

<h3>Description</h3>

<p>Build a hex bin plot with rational color coding.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>HexBinPlot(
  d,
  xvar,
  yvar,
  title,
  ...,
  lightcolor = "#deebf7",
  darkcolor = "#000000",
  bins = 30,
  binwidth = NULL,
  na.rm = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="HexBinPlot_+3A_d">d</code></td>
<td>
<p>data frame</p>
</td></tr>
<tr><td><code id="HexBinPlot_+3A_xvar">xvar</code></td>
<td>
<p>name of x variable column</p>
</td></tr>
<tr><td><code id="HexBinPlot_+3A_yvar">yvar</code></td>
<td>
<p>name of y variable column</p>
</td></tr>
<tr><td><code id="HexBinPlot_+3A_title">title</code></td>
<td>
<p>plot title</p>
</td></tr>
<tr><td><code id="HexBinPlot_+3A_...">...</code></td>
<td>
<p>not used, forces later arguments to bind by name</p>
</td></tr>
<tr><td><code id="HexBinPlot_+3A_lightcolor">lightcolor</code></td>
<td>
<p>light color for least dense areas</p>
</td></tr>
<tr><td><code id="HexBinPlot_+3A_darkcolor">darkcolor</code></td>
<td>
<p>dark color for most dense areas</p>
</td></tr>
<tr><td><code id="HexBinPlot_+3A_bins">bins</code></td>
<td>
<p>passed to geom_hex</p>
</td></tr>
<tr><td><code id="HexBinPlot_+3A_binwidth">binwidth</code></td>
<td>
<p>passed to geom_hex</p>
</td></tr>
<tr><td><code id="HexBinPlot_+3A_na.rm">na.rm</code></td>
<td>
<p>passed to geom_hex</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Builds a standard ggplot2 hexbin plot,
with a color scale such that dense areas are colored darker (the default
ggplot2 fill scales will color dense areas lighter).
</p>
<p>The user can choose an alternate color scale with endpoints <code>lightcolor</code>
and <code>darkcolor</code>; it is up to the user to make sure that <code>lightcolor</code>
is lighter than <code>darkcolor</code>.
</p>
<p>Requires the <code>hexbin</code> package.
</p>


<h3>Value</h3>

<p>a ggplot2 hexbin plot
</p>


<h3>See Also</h3>

<p><code><a href="ggplot2.html#topic+geom_hex">geom_hex</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
if(requireNamespace("hexbin", quietly = TRUE)) {
   if (requireNamespace('data.table', quietly = TRUE)) {
	   # don't multi-thread during CRAN checks
		   data.table::setDTthreads(1)
   }
   set.seed(634267)
   dframe = data.frame(x = rnorm(1000), y = rnorm(1000))
   print(HexBinPlot(dframe, "x", "y", "Example hexbin"))

   diamonds = ggplot2::diamonds
   print(HexBinPlot(diamonds, "carat", "price", "Diamonds example"))

   # change the colorscale
    print(HexBinPlot(diamonds, "carat", "price", "Diamonds example",
                     lightcolor="#fed98e",
                     darkcolor="#993404"))
}

</code></pre>

<hr>
<h2 id='LiftCurvePlot'>Plot the cumulative lift curve of a sort-order.</h2><span id='topic+LiftCurvePlot'></span>

<h3>Description</h3>

<p>Plot the cumulative lift curve of a sort-order.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>LiftCurvePlot(
  frame,
  xvar,
  truthVar,
  title,
  ...,
  large_count = 1000,
  include_wizard = TRUE,
  truth_target = NULL,
  model_color = "darkblue",
  wizard_color = "darkgreen"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="LiftCurvePlot_+3A_frame">frame</code></td>
<td>
<p>data frame to get values from</p>
</td></tr>
<tr><td><code id="LiftCurvePlot_+3A_xvar">xvar</code></td>
<td>
<p>name of the independent (input or model score) column in frame</p>
</td></tr>
<tr><td><code id="LiftCurvePlot_+3A_truthvar">truthVar</code></td>
<td>
<p>name of the dependent (output or result to be modeled) column in frame</p>
</td></tr>
<tr><td><code id="LiftCurvePlot_+3A_title">title</code></td>
<td>
<p>title to place on plot</p>
</td></tr>
<tr><td><code id="LiftCurvePlot_+3A_...">...</code></td>
<td>
<p>no unnamed argument, added to force named binding of later arguments.</p>
</td></tr>
<tr><td><code id="LiftCurvePlot_+3A_large_count">large_count</code></td>
<td>
<p>numeric, upper bound target for number of plotting points</p>
</td></tr>
<tr><td><code id="LiftCurvePlot_+3A_include_wizard">include_wizard</code></td>
<td>
<p>logical, if TRUE plot the ideal or wizard plot.</p>
</td></tr>
<tr><td><code id="LiftCurvePlot_+3A_truth_target">truth_target</code></td>
<td>
<p>if not NULL compare to this scalar value.</p>
</td></tr>
<tr><td><code id="LiftCurvePlot_+3A_model_color">model_color</code></td>
<td>
<p>color for the model curve</p>
</td></tr>
<tr><td><code id="LiftCurvePlot_+3A_wizard_color">wizard_color</code></td>
<td>
<p>color for the &quot;wizard&quot; (best possible) curve</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The use case for this visualization is to compare a predictive model
score to an actual outcome (either binary (0/1) or continuous). In this case the
lift curve plot measures how well the model score sorts the data compared
to the true outcome value.
</p>
<p>The x-axis represents the fraction of items seen when sorted by score, and the
y-axis represents the lift seen so far (cumulative value of model over cummulative value of random selection)..
</p>
<p>For comparison, <code>LiftCurvePlot</code> also plots the &quot;wizard curve&quot;: the lift curve when the
data is sorted according to its true outcome.
</p>
<p>To improve presentation quality, the plot is limited to approximately <code>large_count</code> points (default: 1000).
For larger data sets, the data is appropriately randomly sampled down before plotting.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
if (requireNamespace('data.table', quietly = TRUE)) {
	# don't multi-thread during CRAN checks
		data.table::setDTthreads(1)
}

set.seed(34903490)
y = abs(rnorm(20)) + 0.1
x = abs(y + 0.5*rnorm(20))
frm = data.frame(model=x, value=y)
WVPlots::LiftCurvePlot(frm, "model", "value",
   title="Example Continuous Lift Curve")

</code></pre>

<hr>
<h2 id='LiftCurvePlotList'>Plot the cumulative lift curves of a sort-order.</h2><span id='topic+LiftCurvePlotList'></span><span id='topic+LiftCurveListPlot'></span>

<h3>Description</h3>

<p>Plot the cumulative lift curves of a sort-order.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>LiftCurvePlotList(
  frame,
  xvars,
  truthVar,
  title,
  ...,
  truth_target = NULL,
  palette = "Dark2"
)

LiftCurveListPlot(
  frame,
  xvars,
  truthVar,
  title,
  ...,
  truth_target = NULL,
  palette = "Dark2"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="LiftCurvePlotList_+3A_frame">frame</code></td>
<td>
<p>data frame to get values from</p>
</td></tr>
<tr><td><code id="LiftCurvePlotList_+3A_xvars">xvars</code></td>
<td>
<p>name of the independent (input or model score) columns in frame</p>
</td></tr>
<tr><td><code id="LiftCurvePlotList_+3A_truthvar">truthVar</code></td>
<td>
<p>name of the dependent (output or result to be modeled) column in frame</p>
</td></tr>
<tr><td><code id="LiftCurvePlotList_+3A_title">title</code></td>
<td>
<p>title to place on plot</p>
</td></tr>
<tr><td><code id="LiftCurvePlotList_+3A_...">...</code></td>
<td>
<p>no unnamed argument, added to force named binding of later arguments.</p>
</td></tr>
<tr><td><code id="LiftCurvePlotList_+3A_truth_target">truth_target</code></td>
<td>
<p>if not NULL compare to this scalar value.</p>
</td></tr>
<tr><td><code id="LiftCurvePlotList_+3A_palette">palette</code></td>
<td>
<p>color palette for the model curves</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The use case for this visualization is to compare a predictive model
score to an actual outcome (either binary (0/1) or continuous). In this case the
lift curve plot measures how well the model score sorts the data compared
to the true outcome value.
</p>
<p>The x-axis represents the fraction of items seen when sorted by score, and the
y-axis represents the lift seen so far (cumulative value of model over cummulative value of random selection)..
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
if (requireNamespace('data.table', quietly = TRUE)) {
	# don't multi-thread during CRAN checks
		data.table::setDTthreads(1)
}

set.seed(34903490)
y = abs(rnorm(20)) + 0.1
x = abs(y + 0.5*rnorm(20))
frm = data.frame(model=x, value=y)
WVPlots::LiftCurvePlotList(frm, c("model", "value"), "value",
   title="Example Continuous Lift Curves")

</code></pre>

<hr>
<h2 id='LogLogPlot'>Log-log plot</h2><span id='topic+LogLogPlot'></span>

<h3>Description</h3>

<p>Plot a trend on log-log paper.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>LogLogPlot(
  frame,
  xvar,
  yvar,
  title,
  ...,
  use_coord_trans = FALSE,
  point_color = "black",
  linear_color = "#018571",
  quadratic_color = "#a6611a",
  smoothing_color = "blue"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="LogLogPlot_+3A_frame">frame</code></td>
<td>
<p>data frame to get values from</p>
</td></tr>
<tr><td><code id="LogLogPlot_+3A_xvar">xvar</code></td>
<td>
<p>name of the independent (input or model) column in frame</p>
</td></tr>
<tr><td><code id="LogLogPlot_+3A_yvar">yvar</code></td>
<td>
<p>name of the dependent (output or result to be modeled) column in frame</p>
</td></tr>
<tr><td><code id="LogLogPlot_+3A_title">title</code></td>
<td>
<p>title to place on plot</p>
</td></tr>
<tr><td><code id="LogLogPlot_+3A_...">...</code></td>
<td>
<p>no unnamed argument, added to force named binding of later arguments.</p>
</td></tr>
<tr><td><code id="LogLogPlot_+3A_use_coord_trans">use_coord_trans</code></td>
<td>
<p>logical if TRUE, use coord_trans instead of <code>coord_trans(x = "log10", y = "log10")</code> instead of <code>scale_x_log10() + scale_y_log10()</code> (useful when there is not enough range to show ticks).</p>
</td></tr>
<tr><td><code id="LogLogPlot_+3A_point_color">point_color</code></td>
<td>
<p>the color of the data points</p>
</td></tr>
<tr><td><code id="LogLogPlot_+3A_linear_color">linear_color</code></td>
<td>
<p>the color of the linear growth lines</p>
</td></tr>
<tr><td><code id="LogLogPlot_+3A_quadratic_color">quadratic_color</code></td>
<td>
<p>the color of the quadratic growth lines</p>
</td></tr>
<tr><td><code id="LogLogPlot_+3A_smoothing_color">smoothing_color</code></td>
<td>
<p>the color of the smoothing line through the data</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This plot is intended for plotting functions that are observed costs
or durations as a function of problem size.  In this case we expect
the ideal or expected cost function to be non-decreasing.
Any negative trends are assumed to arise from the noise model.
The graph is specialized to compare non-decreasing linear and
non-decreasing quadratic growth.
</p>
<p>Some care must be taken in drawing conclusions from log-log plots,
as the transform is fairly violent.  Please see:
&quot;(Mar's Law) Everything is linear if plotted log-log with a fat magic marker&quot;
(from Akin's Laws of Spacecraft Design <a href="https://spacecraft.ssl.umd.edu/akins_laws.html">https://spacecraft.ssl.umd.edu/akins_laws.html</a>),
and &quot;So You Think You Have a Power Law&quot; <a href="http://bactra.org/weblog/491.html">http://bactra.org/weblog/491.html</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
if (requireNamespace('data.table', quietly = TRUE)) {
	# don't multi-thread during CRAN checks
		data.table::setDTthreads(1)
}

set.seed(5326)
frm = data.frame(x = 1:20)
frm$y &lt;- 5 + frm$x + 0.2 * frm$x * frm$x + 0.1*abs(rnorm(nrow(frm)))
WVPlots::LogLogPlot(frm, "x", "y", title="Example Trend")

</code></pre>

<hr>
<h2 id='MetricPairPlot'>Plot the relationship between two metrics.</h2><span id='topic+MetricPairPlot'></span>

<h3>Description</h3>

<p>Plot the relationship between two metrics.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>MetricPairPlot(
  frame,
  xvar,
  truthVar,
  title,
  ...,
  x_metric = "false_positive_rate",
  y_metric = "true_positive_rate",
  truth_target = TRUE,
  points_to_plot = NULL,
  linecolor = "black"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="MetricPairPlot_+3A_frame">frame</code></td>
<td>
<p>data frame to get values from</p>
</td></tr>
<tr><td><code id="MetricPairPlot_+3A_xvar">xvar</code></td>
<td>
<p>name of the independent (input or model) column in frame</p>
</td></tr>
<tr><td><code id="MetricPairPlot_+3A_truthvar">truthVar</code></td>
<td>
<p>name of the column to be predicted</p>
</td></tr>
<tr><td><code id="MetricPairPlot_+3A_title">title</code></td>
<td>
<p>title to place on plot</p>
</td></tr>
<tr><td><code id="MetricPairPlot_+3A_...">...</code></td>
<td>
<p>no unnamed argument, added to force named binding of later arguments.</p>
</td></tr>
<tr><td><code id="MetricPairPlot_+3A_x_metric">x_metric</code></td>
<td>
<p>metric to be plotted. See Details for the list of allowed metrics</p>
</td></tr>
<tr><td><code id="MetricPairPlot_+3A_y_metric">y_metric</code></td>
<td>
<p>metric to be plotted. See Details for the list of allowed metrics</p>
</td></tr>
<tr><td><code id="MetricPairPlot_+3A_truth_target">truth_target</code></td>
<td>
<p>truth value considered to be positive.</p>
</td></tr>
<tr><td><code id="MetricPairPlot_+3A_points_to_plot">points_to_plot</code></td>
<td>
<p>how many data points to use for plotting. Defaults to NULL (all data)</p>
</td></tr>
<tr><td><code id="MetricPairPlot_+3A_linecolor">linecolor</code></td>
<td>
<p>character: name of line color</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Plots two classifier metrics against each other, showing achievable combinations
of performance metrics. For example, plotting true_positive_rate vs false_positive_rate
recreates the ROC plot.
</p>
<p><code>MetricPairPlot</code> can plot a number of metrics. Some of the metrics are redundant,
in keeping with the customary terminology of various analysis communities.
</p>

<ul>
<li><p>sensitivity: fraction of true positives that were predicted to be true (also known as the true positive rate)
</p>
</li>
<li><p>specificity: fraction of true negatives to all negatives (or 1 - false_positive_rate)
</p>
</li>
<li><p>precision: fraction of predicted positives that are true positives
</p>
</li>
<li><p>recall: same as sensitivity or true positive rate
</p>
</li>
<li><p>accuracy: fraction of items correctly decided
</p>
</li>
<li><p>false_positive_rate: fraction of negatives predicted to be true over all negatives
</p>
</li>
<li><p>true_positive_rate: fraction of positives predicted to be true over all positives
</p>
</li>
<li><p>false_negative_rate: fraction of positives predicted to be all false over all positives
</p>
</li>
<li><p>true_negative_rate: fraction negatives predicted to be false over all negatives
</p>
</li></ul>

<p><code>points_to_plot</code> specifies the approximate number of datums used to
create the plots as an absolute count; for example setting <code>points_to_plot = 200</code> uses
approximately 200 points, rather than the entire data set. This can be useful when
visualizing very large data sets.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+ThresholdPlot">ThresholdPlot</a></code>, <code><a href="#topic+PRTPlot">PRTPlot</a></code>, <code><a href="#topic+ROCPlot">ROCPlot</a></code>, <code><a href="#topic+PRPlot">PRPlot</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
if (requireNamespace('data.table', quietly = TRUE)) {
	# don't multi-thread during CRAN checks
		data.table::setDTthreads(1)
}

# data with two different regimes of behavior
d &lt;- rbind(
  data.frame(
    x =  rnorm(1000),
    y = sample(c(TRUE, FALSE), prob = c(0.02, 0.98), size = 1000, replace = TRUE)),
  data.frame(
    x =  rnorm(200) + 5,
    y = sample(c(TRUE, FALSE), size = 200, replace = TRUE))
)

# Sensitivity/Specificity examples
MetricPairPlot(d, 'x', 'y',
   x_metric = 'false_positive_rate',
   y_metric = 'true_positive_rate',
   truth_target = TRUE,
   title = 'ROC equivalent')
if(FALSE) {
ThresholdPlot(d, 'x', 'y',
   title = 'Sensitivity/Specificity',
   metrics = c('sensitivity', 'specificity'),
   truth_target = TRUE)
ROCPlot(d, 'x', 'y',
   truthTarget = TRUE,
   title = 'ROC example')

# Precision/Recall examples
ThresholdPlot(d, 'x', 'y',
   title = 'precision/recall',
   metrics = c('recall', 'precision'),
   truth_target = TRUE)
MetricPairPlot(d, 'x', 'y',
   x_metric = 'recall',
   y_metric = 'precision',
   title = 'recall/precision',
   truth_target = TRUE)
PRPlot(d, 'x', 'y',
   truthTarget = TRUE,
   title = 'p/r plot')
}

</code></pre>

<hr>
<h2 id='PairPlot'>Build a pair plot</h2><span id='topic+PairPlot'></span>

<h3>Description</h3>

<p>Creates a matrix of scatterplots, one for each possible pair of variables.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>PairPlot(
  d,
  meas_vars,
  title,
  ...,
  group_var = NULL,
  alpha = 1,
  palette = "Dark2",
  point_color = "darkgray"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="PairPlot_+3A_d">d</code></td>
<td>
<p>data frame</p>
</td></tr>
<tr><td><code id="PairPlot_+3A_meas_vars">meas_vars</code></td>
<td>
<p>the variables to be plotted</p>
</td></tr>
<tr><td><code id="PairPlot_+3A_title">title</code></td>
<td>
<p>plot title</p>
</td></tr>
<tr><td><code id="PairPlot_+3A_...">...</code></td>
<td>
<p>not used, forces later arguments to bind by name</p>
</td></tr>
<tr><td><code id="PairPlot_+3A_group_var">group_var</code></td>
<td>
<p>variable for grouping and colorcoding</p>
</td></tr>
<tr><td><code id="PairPlot_+3A_alpha">alpha</code></td>
<td>
<p>alpha for points on plot</p>
</td></tr>
<tr><td><code id="PairPlot_+3A_palette">palette</code></td>
<td>
<p>name of a brewer palette (NULL for ggplot2 default coloring)</p>
</td></tr>
<tr><td><code id="PairPlot_+3A_point_color">point_color</code></td>
<td>
<p>point color for monochrome plots (no grouping)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If <code>palette</code> is NULL, and <code>group_var</code> is non-NULL, plot colors will be chosen from the default ggplot2 palette.
Setting <code>palette</code> to NULL
allows the user to choose a non-Brewer palette, for example with <code><a href="ggplot2.html#topic+scale_manual">scale_color_manual</a></code>.
</p>


<h3>Value</h3>

<p>a ggplot2 pair plot
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
if (requireNamespace('data.table', quietly = TRUE)) {
	# don't multi-thread during CRAN checks
		data.table::setDTthreads(1)
}

# PairPlot(iris, colnames(iris)[1:4], "Example plot", group_var = "Species")

# custom palette
colormap = c('#a6611a', '#dfc27d', '#018571')
PairPlot(iris, colnames(iris)[1:4], "Example plot",
         group_var = "Species", palette=NULL) +
         ggplot2::scale_color_manual(values=colormap)

# # no color-coding
# PairPlot(iris, colnames(iris)[1:4], "Example plot")

</code></pre>

<hr>
<h2 id='plot_fit_trajectory'>Plot the trajectory of a model fit.</h2><span id='topic+plot_fit_trajectory'></span>

<h3>Description</h3>

<p>Plot a history of model fit performance over the a trajectory of times.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot_fit_trajectory(
  d,
  column_description,
  title,
  ...,
  epoch_name = "epoch",
  needs_flip = c(),
  pick_metric = NULL,
  discount_rate = NULL,
  draw_ribbon = FALSE,
  draw_segments = FALSE,
  val_color = "#d95f02",
  train_color = "#1b9e77",
  pick_color = "#e6ab02"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot_fit_trajectory_+3A_d">d</code></td>
<td>
<p>data frame to get values from.</p>
</td></tr>
<tr><td><code id="plot_fit_trajectory_+3A_column_description">column_description</code></td>
<td>
<p>description of column measures (data.frame with columns measure, validation, and training).</p>
</td></tr>
<tr><td><code id="plot_fit_trajectory_+3A_title">title</code></td>
<td>
<p>character title for plot.</p>
</td></tr>
<tr><td><code id="plot_fit_trajectory_+3A_...">...</code></td>
<td>
<p>force later arguments to be bound by name</p>
</td></tr>
<tr><td><code id="plot_fit_trajectory_+3A_epoch_name">epoch_name</code></td>
<td>
<p>name for epoch or trajectory column.</p>
</td></tr>
<tr><td><code id="plot_fit_trajectory_+3A_needs_flip">needs_flip</code></td>
<td>
<p>character array of measures that need to be flipped.</p>
</td></tr>
<tr><td><code id="plot_fit_trajectory_+3A_pick_metric">pick_metric</code></td>
<td>
<p>character metric to maximize.</p>
</td></tr>
<tr><td><code id="plot_fit_trajectory_+3A_discount_rate">discount_rate</code></td>
<td>
<p>numeric what fraction of over-fit to subtract from validation performance.</p>
</td></tr>
<tr><td><code id="plot_fit_trajectory_+3A_draw_ribbon">draw_ribbon</code></td>
<td>
<p>present the difference in training and validation performance as a ribbon rather than two curves? (default FALSE)</p>
</td></tr>
<tr><td><code id="plot_fit_trajectory_+3A_draw_segments">draw_segments</code></td>
<td>
<p>logical if TRUE draw over-fit/under-fit segments.</p>
</td></tr>
<tr><td><code id="plot_fit_trajectory_+3A_val_color">val_color</code></td>
<td>
<p>color for validation performance curve</p>
</td></tr>
<tr><td><code id="plot_fit_trajectory_+3A_train_color">train_color</code></td>
<td>
<p>color for training performance curve</p>
</td></tr>
<tr><td><code id="plot_fit_trajectory_+3A_pick_color">pick_color</code></td>
<td>
<p>color for indicating optimal stopping point</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This visualization can be applied to any staged machine learning algorithm. For example one could
plot the performance of a gradient boosting machine as a function of the number of trees added. The
fit history data should be in the form given in the example below.
</p>
<p>The example below gives
a fit plot for a history report from Keras R package.
Please see <a href="https://win-vector.com/2017/12/23/plotting-deep-learning-model-performance-trajectories/">https://win-vector.com/2017/12/23/plotting-deep-learning-model-performance-trajectories/</a>
for some examples and details.
</p>


<h3>Value</h3>

<p>ggplot2 plot
</p>


<h3>See Also</h3>

<p><a href="#topic+plot_Keras_fit_trajectory">plot_Keras_fit_trajectory</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
if (requireNamespace('data.table', quietly = TRUE)) {
	# don't multi-thread during CRAN checks
		data.table::setDTthreads(1)
}

d &lt;- data.frame(
  epoch    = c(1,         2,         3,         4,         5),
  val_loss = c(0.3769818, 0.2996994, 0.2963943, 0.2779052, 0.2842501),
  val_acc  = c(0.8722000, 0.8895000, 0.8822000, 0.8899000, 0.8861000),
  loss     = c(0.5067290, 0.3002033, 0.2165675, 0.1738829, 0.1410933),
  acc      = c(0.7852000, 0.9040000, 0.9303333, 0.9428000, 0.9545333) )

cT &lt;- data.frame(
  measure =    c("minus binary cross entropy", "accuracy"),
  training =   c("loss",                       "acc"),
  validation = c("val_loss",                   "val_acc"),
  stringsAsFactors = FALSE)

plt &lt;- plot_fit_trajectory(
  d,
  column_description = cT,
  needs_flip = "minus binary cross entropy",
  title = "model performance by epoch, dataset, and measure",
  epoch_name = "epoch",
  pick_metric = "minus binary cross entropy",
  discount_rate = 0.1)

print(plt)

</code></pre>

<hr>
<h2 id='plot_Keras_fit_trajectory'>Plot the trajectory of a Keras model fit.</h2><span id='topic+plot_Keras_fit_trajectory'></span>

<h3>Description</h3>

<p>Plot a history of model fit performance over the number of training epochs.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot_Keras_fit_trajectory(
  d,
  title,
  ...,
  epoch_name = "epoch",
  lossname = "loss",
  loss_pretty_name = "minus binary cross entropy",
  perfname = "acc",
  perf_pretty_name = "accuracy",
  pick_metric = loss_pretty_name,
  fliploss = TRUE,
  discount_rate = NULL,
  draw_ribbon = FALSE,
  val_color = "#d95f02",
  train_color = "#1b9e77",
  pick_color = "#e6ab02"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot_Keras_fit_trajectory_+3A_d">d</code></td>
<td>
<p>data frame to get values from.</p>
</td></tr>
<tr><td><code id="plot_Keras_fit_trajectory_+3A_title">title</code></td>
<td>
<p>character title for plot.</p>
</td></tr>
<tr><td><code id="plot_Keras_fit_trajectory_+3A_...">...</code></td>
<td>
<p>force later arguments to be bound by name</p>
</td></tr>
<tr><td><code id="plot_Keras_fit_trajectory_+3A_epoch_name">epoch_name</code></td>
<td>
<p>name for epoch or trajectory column.</p>
</td></tr>
<tr><td><code id="plot_Keras_fit_trajectory_+3A_lossname">lossname</code></td>
<td>
<p>name of training loss column (default 'loss')</p>
</td></tr>
<tr><td><code id="plot_Keras_fit_trajectory_+3A_loss_pretty_name">loss_pretty_name</code></td>
<td>
<p>name for loss on graph (default 'minus binary cross entropy')</p>
</td></tr>
<tr><td><code id="plot_Keras_fit_trajectory_+3A_perfname">perfname</code></td>
<td>
<p>name of training performance column (default 'acc')</p>
</td></tr>
<tr><td><code id="plot_Keras_fit_trajectory_+3A_perf_pretty_name">perf_pretty_name</code></td>
<td>
<p>name for performance metric on graph (default 'accuracy')</p>
</td></tr>
<tr><td><code id="plot_Keras_fit_trajectory_+3A_pick_metric">pick_metric</code></td>
<td>
<p>character: metric to maximize (NULL for no pick line - default loss_pretty_name)</p>
</td></tr>
<tr><td><code id="plot_Keras_fit_trajectory_+3A_fliploss">fliploss</code></td>
<td>
<p>flip the loss so that &quot;larger is better&quot;? (default TRUE)</p>
</td></tr>
<tr><td><code id="plot_Keras_fit_trajectory_+3A_discount_rate">discount_rate</code></td>
<td>
<p>numeric: what fraction of over-fit to subtract from validation performance.</p>
</td></tr>
<tr><td><code id="plot_Keras_fit_trajectory_+3A_draw_ribbon">draw_ribbon</code></td>
<td>
<p>present the difference in training and validation performance as a ribbon rather than two curves? (default FALSE)</p>
</td></tr>
<tr><td><code id="plot_Keras_fit_trajectory_+3A_val_color">val_color</code></td>
<td>
<p>color for validation performance curve</p>
</td></tr>
<tr><td><code id="plot_Keras_fit_trajectory_+3A_train_color">train_color</code></td>
<td>
<p>color for training performance curve</p>
</td></tr>
<tr><td><code id="plot_Keras_fit_trajectory_+3A_pick_color">pick_color</code></td>
<td>
<p>color for indicating optimal stopping point</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Assumes a performance matrix that carries information for both training and validation loss,
and an additional training and validation performance metric, in the format that
a Keras history object returns.
</p>
<p>By default, flips the loss so that better performance is larger for both the loss and the performance metric,
and then draws a vertical line at the minimum validation loss (maximum flipped validation loss).
If you choose not to flip the loss, you should not use the loss as the pick_metric.
</p>
<p>The example below gives
a fit plot for a history report from Keras R package.
Please see <a href="https://winvector.github.io/FluidData/PlotExample/KerasPerfPlot.html">https://winvector.github.io/FluidData/PlotExample/KerasPerfPlot.html</a>
for some details.
</p>


<h3>Value</h3>

<p>ggplot2 plot
</p>


<h3>See Also</h3>

<p><a href="#topic+plot_fit_trajectory">plot_fit_trajectory</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
if (requireNamespace('data.table', quietly = TRUE)) {
	# don't multi-thread during CRAN checks
		data.table::setDTthreads(1)
}

# example data (from Keras)
d &lt;- data.frame(
  val_loss = c(0.3769818, 0.2996994, 0.2963943, 0.2779052, 0.2842501),
  val_acc  = c(0.8722000, 0.8895000, 0.8822000, 0.8899000, 0.8861000),
  loss     = c(0.5067290, 0.3002033, 0.2165675, 0.1738829, 0.1410933),
  acc      = c(0.7852000, 0.9040000, 0.9303333, 0.9428000, 0.9545333) )

plt &lt;- plot_Keras_fit_trajectory(
  d,
  title = "model performance by epoch, dataset, and measure")

print(plt)

</code></pre>

<hr>
<h2 id='PlotDistCountBinomial'>Plot count data with a theoretical binomial</h2><span id='topic+PlotDistCountBinomial'></span>

<h3>Description</h3>

<p>Compares empirical count data to a binomial distribution
</p>


<h3>Usage</h3>

<pre><code class='language-R'>PlotDistCountBinomial(
  frm,
  xvar,
  trial_size,
  title,
  ...,
  p = NULL,
  limit_to_observed_range = FALSE,
  count_color = "black",
  binom_color = "blue"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="PlotDistCountBinomial_+3A_frm">frm</code></td>
<td>
<p>data frame to get values from</p>
</td></tr>
<tr><td><code id="PlotDistCountBinomial_+3A_xvar">xvar</code></td>
<td>
<p>column of frm that counts the number of successes for each trial</p>
</td></tr>
<tr><td><code id="PlotDistCountBinomial_+3A_trial_size">trial_size</code></td>
<td>
<p>the number of &quot;coin flips&quot; in a trial</p>
</td></tr>
<tr><td><code id="PlotDistCountBinomial_+3A_title">title</code></td>
<td>
<p>title to place on plot</p>
</td></tr>
<tr><td><code id="PlotDistCountBinomial_+3A_...">...</code></td>
<td>
<p>no unnamed argument, added to force named binding of later arguments.</p>
</td></tr>
<tr><td><code id="PlotDistCountBinomial_+3A_p">p</code></td>
<td>
<p>mean of the binomial. If NULL, use empirical mean</p>
</td></tr>
<tr><td><code id="PlotDistCountBinomial_+3A_limit_to_observed_range">limit_to_observed_range</code></td>
<td>
<p>If TRUE, limit plot to observed counts</p>
</td></tr>
<tr><td><code id="PlotDistCountBinomial_+3A_count_color">count_color</code></td>
<td>
<p>color of empirical distribution</p>
</td></tr>
<tr><td><code id="PlotDistCountBinomial_+3A_binom_color">binom_color</code></td>
<td>
<p>color of theoretical binomial</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is useful for comparing the number of successes that occur
in a series of trials, all of the same size, to a binomial of a given
success-probability.
</p>
<p>Plots the empirical distribution of successes, and a theoretical matching binomial. If
the mean of the binomial, <code>p</code>, is given, the binomial with success-probability
<code>p</code> is plotted. Otherwise, <code>p</code> is taken to be the pooled success rate
of the data: <code>sum(frm[[xvar]]) / (trial_size*nrow(frm))</code>. The mean of
the binomial is reported in the subtitle of the plot (to three significant figures).
</p>
<p>If <code>limit_to_observed_range</code> is TRUE, the range of the plot will only cover
the range of the empirical data. Otherwise, the range of the plot will be
<code>0:trial_size</code> (the default).
</p>


<h3>See Also</h3>

<p><code><a href="#topic+PlotDistHistBeta">PlotDistHistBeta</a></code>, <code><a href="#topic+PlotDistDensityBeta">PlotDistDensityBeta</a></code>,
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
if (requireNamespace('data.table', quietly = TRUE)) {
	# don't multi-thread during CRAN checks
		data.table::setDTthreads(1)
}

set.seed(23590)
class_size = 35
nclasses = 100
true_frate = 0.4
fdata = data.frame(n_female = rbinom(nclasses, class_size, true_frate), stringsAsFactors = FALSE)

title = paste("Distribution of count of female students, class size =", class_size)
# compare to empirical p
PlotDistCountBinomial(fdata, "n_female", class_size, title)

if(FALSE) {
  # compare to theoretical p of 0.5
  PlotDistCountBinomial(fdata, "n_female", class_size, title,
                        p = 0.5)

  # Example where the distribution is not of a true single binomial
  fdata2 = rbind(data.frame(n_female = rbinom(50, class_size, 0.25)),
                data.frame(n_female = rbinom(10, class_size, 0.60)),
                stringsAsFactors = FALSE )
  PlotDistCountBinomial(fdata2, "n_female", class_size, title)
}

</code></pre>

<hr>
<h2 id='PlotDistCountNormal'>Plot distribution details as a histogram plus matching normal</h2><span id='topic+PlotDistCountNormal'></span>

<h3>Description</h3>

<p>Compares empirical data to a normal distribution with the same mean and standard deviation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>PlotDistCountNormal(
  frm,
  xvar,
  title,
  ...,
  binWidth = c(),
  hist_color = "black",
  normal_color = "blue",
  mean_color = "blue",
  sd_color = "blue"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="PlotDistCountNormal_+3A_frm">frm</code></td>
<td>
<p>data frame to get values from</p>
</td></tr>
<tr><td><code id="PlotDistCountNormal_+3A_xvar">xvar</code></td>
<td>
<p>name of the independent (input or model) column in frame</p>
</td></tr>
<tr><td><code id="PlotDistCountNormal_+3A_title">title</code></td>
<td>
<p>title to place on plot</p>
</td></tr>
<tr><td><code id="PlotDistCountNormal_+3A_...">...</code></td>
<td>
<p>no unnamed argument, added to force named binding of later arguments.</p>
</td></tr>
<tr><td><code id="PlotDistCountNormal_+3A_binwidth">binWidth</code></td>
<td>
<p>width of histogram bins</p>
</td></tr>
<tr><td><code id="PlotDistCountNormal_+3A_hist_color">hist_color</code></td>
<td>
<p>color of empirical histogram</p>
</td></tr>
<tr><td><code id="PlotDistCountNormal_+3A_normal_color">normal_color</code></td>
<td>
<p>color of matching theoretical normal</p>
</td></tr>
<tr><td><code id="PlotDistCountNormal_+3A_mean_color">mean_color</code></td>
<td>
<p>color of mean line</p>
</td></tr>
<tr><td><code id="PlotDistCountNormal_+3A_sd_color">sd_color</code></td>
<td>
<p>color of 1-standard deviation lines (can be NULL)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Plots the histograms of the empirical distribution and of the matching normal distribution.
Also plots the mean and plus/minus one standard deviation.
</p>
<p>Bin width for the histogram is calculated automatically to yield approximately 50 bins across the
range of the data, unless the <code>binWidth</code> argument is explicitly passed in. <code>binWidth</code> is reported
in the subtitle of the plot.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
if (requireNamespace('data.table', quietly = TRUE)) {
	# don't multi-thread during CRAN checks
		data.table::setDTthreads(1)
}

set.seed(52523)
d &lt;- data.frame(wt=100*rnorm(100))
PlotDistCountNormal(d,'wt','example')

# # no sd lines
# PlotDistCountNormal(d, 'wt', 'example', sd_color=NULL)

</code></pre>

<hr>
<h2 id='PlotDistDensityBeta'>Plot empirical rate data as a density with the matching beta distribution</h2><span id='topic+PlotDistDensityBeta'></span>

<h3>Description</h3>

<p>Compares empirical rate data to a beta distribution with the same mean and standard deviation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>PlotDistDensityBeta(
  frm,
  xvar,
  title,
  ...,
  curve_color = "lightgray",
  beta_color = "blue",
  mean_color = "blue",
  sd_color = "darkgray"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="PlotDistDensityBeta_+3A_frm">frm</code></td>
<td>
<p>data frame to get values from</p>
</td></tr>
<tr><td><code id="PlotDistDensityBeta_+3A_xvar">xvar</code></td>
<td>
<p>name of the independent (input or model) column in frame</p>
</td></tr>
<tr><td><code id="PlotDistDensityBeta_+3A_title">title</code></td>
<td>
<p>title to place on plot</p>
</td></tr>
<tr><td><code id="PlotDistDensityBeta_+3A_...">...</code></td>
<td>
<p>force later arguments to bind by name</p>
</td></tr>
<tr><td><code id="PlotDistDensityBeta_+3A_curve_color">curve_color</code></td>
<td>
<p>color for empirical density curve</p>
</td></tr>
<tr><td><code id="PlotDistDensityBeta_+3A_beta_color">beta_color</code></td>
<td>
<p>color for matching theoretical beta</p>
</td></tr>
<tr><td><code id="PlotDistDensityBeta_+3A_mean_color">mean_color</code></td>
<td>
<p>color for mean line</p>
</td></tr>
<tr><td><code id="PlotDistDensityBeta_+3A_sd_color">sd_color</code></td>
<td>
<p>color for 1-standard deviation lines (can be NULL)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Plots the empirical density, the theoretical matching beta, the mean value,
and plus/minus one standard deviation from the mean.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
if (requireNamespace('data.table', quietly = TRUE)) {
	# don't multi-thread during CRAN checks
		data.table::setDTthreads(1)
}

set.seed(52523)
N = 100
pgray = 0.1  # rate of gray horses in the population
herd_size = round(runif(N, min=25, 50))
ngray = rbinom(N, herd_size, pgray)
hdata = data.frame(n_gray=ngray, herd_size=herd_size)

# observed rate of gray horses in each herd
hdata$rate_gray = with(hdata, ngray/herd_size)

title = "Observed prevalence of gray horses in population"

PlotDistDensityBeta(hdata, "rate_gray", title) +
  ggplot2::geom_vline(xintercept = pgray, linetype=4, color="maroon") +
  ggplot2::annotate("text", x=pgray+0.01, y=0.01, hjust="left",
                    label = paste("True prevalence =", pgray))

# # no sd lines
# PlotDistDensityBeta(hdata, "rate_gray", title,
#                     sd_color=NULL)
</code></pre>

<hr>
<h2 id='PlotDistDensityNormal'>Plot an empirical density with the matching normal distribution</h2><span id='topic+PlotDistDensityNormal'></span>

<h3>Description</h3>

<p>Compares empirical data to a normal distribution with the same mean and standard deviation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>PlotDistDensityNormal(
  frm,
  xvar,
  title,
  ...,
  adjust = 0.5,
  curve_color = "lightgray",
  normal_color = "blue",
  mean_color = "blue",
  sd_color = "darkgray"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="PlotDistDensityNormal_+3A_frm">frm</code></td>
<td>
<p>data frame to get values from</p>
</td></tr>
<tr><td><code id="PlotDistDensityNormal_+3A_xvar">xvar</code></td>
<td>
<p>name of the independent (input or model) column in frame</p>
</td></tr>
<tr><td><code id="PlotDistDensityNormal_+3A_title">title</code></td>
<td>
<p>title to place on plot</p>
</td></tr>
<tr><td><code id="PlotDistDensityNormal_+3A_...">...</code></td>
<td>
<p>no unnamed argument, added to force named binding of later arguments.</p>
</td></tr>
<tr><td><code id="PlotDistDensityNormal_+3A_adjust">adjust</code></td>
<td>
<p>passed to geom_density; controls smoothness of density plot</p>
</td></tr>
<tr><td><code id="PlotDistDensityNormal_+3A_curve_color">curve_color</code></td>
<td>
<p>color for empirical density curve</p>
</td></tr>
<tr><td><code id="PlotDistDensityNormal_+3A_normal_color">normal_color</code></td>
<td>
<p>color for theoretical matching normal</p>
</td></tr>
<tr><td><code id="PlotDistDensityNormal_+3A_mean_color">mean_color</code></td>
<td>
<p>color of mean line</p>
</td></tr>
<tr><td><code id="PlotDistDensityNormal_+3A_sd_color">sd_color</code></td>
<td>
<p>color for 1-standard deviation lines (can be NULL)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Plots the empirical density, the theoretical matching normal, the mean value,
and plus/minus one standard deviation from the mean.
</p>


<h3>See Also</h3>

<p><code><a href="ggplot2.html#topic+geom_density">geom_density</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
if (requireNamespace('data.table', quietly = TRUE)) {
	# don't multi-thread during CRAN checks
		data.table::setDTthreads(1)
}

set.seed(52523)
d &lt;- data.frame(wt=100*rnorm(100))
PlotDistDensityNormal(d,'wt','example')

# # no sd lines
# PlotDistDensityNormal(d, 'wt', 'example', sd_color=NULL)

</code></pre>

<hr>
<h2 id='PlotDistHistBeta'>Plot empirical rate data as a histogram plus matching beta</h2><span id='topic+PlotDistHistBeta'></span>

<h3>Description</h3>

<p>Compares empirical rate data to a beta distribution with the same mean and standard deviation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>PlotDistHistBeta(
  frm,
  xvar,
  title,
  ...,
  bins = 30,
  hist_color = "darkgray",
  beta_color = "blue",
  mean_color = "blue",
  sd_color = "darkgray"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="PlotDistHistBeta_+3A_frm">frm</code></td>
<td>
<p>data frame to get values from</p>
</td></tr>
<tr><td><code id="PlotDistHistBeta_+3A_xvar">xvar</code></td>
<td>
<p>name of the independent (input or model) column in frame</p>
</td></tr>
<tr><td><code id="PlotDistHistBeta_+3A_title">title</code></td>
<td>
<p>title to place on plot</p>
</td></tr>
<tr><td><code id="PlotDistHistBeta_+3A_...">...</code></td>
<td>
<p>force later arguments to bind by name</p>
</td></tr>
<tr><td><code id="PlotDistHistBeta_+3A_bins">bins</code></td>
<td>
<p>passed to geom_histogram(). Default: 30</p>
</td></tr>
<tr><td><code id="PlotDistHistBeta_+3A_hist_color">hist_color</code></td>
<td>
<p>color of empirical histogram</p>
</td></tr>
<tr><td><code id="PlotDistHistBeta_+3A_beta_color">beta_color</code></td>
<td>
<p>color of matching theoretical beta</p>
</td></tr>
<tr><td><code id="PlotDistHistBeta_+3A_mean_color">mean_color</code></td>
<td>
<p>color of mean line</p>
</td></tr>
<tr><td><code id="PlotDistHistBeta_+3A_sd_color">sd_color</code></td>
<td>
<p>color of 1-standard devation lines (can be NULL)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Plots the histogram of the empirical distribution and the density of the matching beta distribution.
Also plots the mean and plus/minus one standard deviation.
</p>
<p>The number of bins for the histogram defaults to 30.
The binwidth can also be passed in instead of the number of bins.
</p>


<h3>Value</h3>

<p>ggplot2 plot
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
if (requireNamespace('data.table', quietly = TRUE)) {
	# don't multi-thread during CRAN checks
		data.table::setDTthreads(1)
}

set.seed(52523)
N = 100
pgray = 0.1  # rate of gray horses in the population
herd_size = round(runif(N, min=25, 50))
ngray = rbinom(N, herd_size, pgray)
hdata = data.frame(n_gray=ngray, herd_size=herd_size)

# observed rate of gray horses in each herd
hdata$rate_gray = with(hdata, n_gray/herd_size)

title = "Observed prevalence of gray horses in population"

PlotDistHistBeta(hdata, "rate_gray", title) +
  ggplot2::geom_vline(xintercept = pgray, linetype=4, color="maroon") +
  ggplot2::annotate("text", x=pgray+0.01, y=0.01, hjust="left",
                    label = paste("True prevalence =", pgray))

# # no sd lines
# PlotDistHistBeta(hdata, "rate_gray", title,
#                     sd_color=NULL)
</code></pre>

<hr>
<h2 id='plotlyROC'>Use <code>plotly</code> to produce a ROC plot.</h2><span id='topic+plotlyROC'></span>

<h3>Description</h3>

<p>Note: any <code>arrange_</code> warning is a version incompatibility between <code>plotly</code> and <code>dplyr</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plotlyROC(
  d,
  predCol,
  outcomeCol,
  outcomeTarget,
  title,
  ...,
  estimate_sig = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plotlyROC_+3A_d">d</code></td>
<td>
<p>dataframe</p>
</td></tr>
<tr><td><code id="plotlyROC_+3A_predcol">predCol</code></td>
<td>
<p>name of column with numeric predictions</p>
</td></tr>
<tr><td><code id="plotlyROC_+3A_outcomecol">outcomeCol</code></td>
<td>
<p>name of column with truth</p>
</td></tr>
<tr><td><code id="plotlyROC_+3A_outcometarget">outcomeTarget</code></td>
<td>
<p>value considered true</p>
</td></tr>
<tr><td><code id="plotlyROC_+3A_title">title</code></td>
<td>
<p>character title for plot</p>
</td></tr>
<tr><td><code id="plotlyROC_+3A_...">...</code></td>
<td>
<p>no unnamed argument, added to force named binding of later arguments.</p>
</td></tr>
<tr><td><code id="plotlyROC_+3A_estimate_sig">estimate_sig</code></td>
<td>
<p>logical, if TRUE estimate and display significance of difference from AUC 0.5.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>plotly plot
</p>


<h3>See Also</h3>

<p><code><a href="#topic+ROCPlot">ROCPlot</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
if(FALSE &amp;&amp; requireNamespace("plotly", quietly = TRUE)) {
   if (requireNamespace('data.table', quietly = TRUE)) {
	   # don't multi-thread during CRAN checks
		   data.table::setDTthreads(1)
   }
   set.seed(34903490)
   x = rnorm(50)
   y = 0.5*x^2 + 2*x + rnorm(length(x))
   frm = data.frame(x=x,yC=y&gt;=as.numeric(quantile(y,probs=0.8)))
   plotlyROC(frm, 'x', 'yC', TRUE, 'example plot', estimate_sig = TRUE)
}


</code></pre>

<hr>
<h2 id='PRPlot'>Plot Precision-Recall plot.</h2><span id='topic+PRPlot'></span>

<h3>Description</h3>

<p>Plot Precision-Recall plot.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>PRPlot(frame, xvar, truthVar, truthTarget, title, ..., estimate_sig = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="PRPlot_+3A_frame">frame</code></td>
<td>
<p>data frame to get values from</p>
</td></tr>
<tr><td><code id="PRPlot_+3A_xvar">xvar</code></td>
<td>
<p>name of the independent (input or model) column in frame</p>
</td></tr>
<tr><td><code id="PRPlot_+3A_truthvar">truthVar</code></td>
<td>
<p>name of the dependent (output or result to be modeled) column in frame</p>
</td></tr>
<tr><td><code id="PRPlot_+3A_truthtarget">truthTarget</code></td>
<td>
<p>value we consider to be positive</p>
</td></tr>
<tr><td><code id="PRPlot_+3A_title">title</code></td>
<td>
<p>title to place on plot</p>
</td></tr>
<tr><td><code id="PRPlot_+3A_...">...</code></td>
<td>
<p>no unnamed argument, added to force named binding of later arguments.</p>
</td></tr>
<tr><td><code id="PRPlot_+3A_estimate_sig">estimate_sig</code></td>
<td>
<p>logical, if TRUE compute significance</p>
</td></tr>
</table>


<h3>Details</h3>

<p>See https://www.nature.com/articles/nmeth.3945 for a discussion of precision and recall,
and how the precision/recall plot relates to the ROC plot.
</p>
<p>In addition to plotting precision versus recall, <code>PRPlot</code> reports the best
achieved F1 score, and plots an isoline corresponding to that F1 score.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+ROCPlot">ROCPlot</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
if (requireNamespace('data.table', quietly = TRUE)) {
	# don't multi-thread during CRAN checks
		data.table::setDTthreads(1)
}

set.seed(34903490)
x = rnorm(50)
y = 0.5*x^2 + 2*x + rnorm(length(x))
frm = data.frame(x=x,y=y,yC=y&gt;=as.numeric(quantile(y,probs=0.8)))
frm$absY &lt;- abs(frm$y)
frm$posY = frm$y &gt; 0
frm$costX = 1
WVPlots::PRPlot(frm, "x", "yC", TRUE, title="Example Precision-Recall plot")

</code></pre>

<hr>
<h2 id='PRTPlot'>Plot Precision-Recall or Enrichment-Recall as a function of threshold.</h2><span id='topic+PRTPlot'></span>

<h3>Description</h3>

<p>Plot classifier performance metrics as a function of threshold.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>PRTPlot(
  frame,
  predVar,
  truthVar,
  truthTarget,
  title,
  ...,
  plotvars = c("precision", "recall"),
  thresholdrange = c(-Inf, Inf),
  linecolor = "black"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="PRTPlot_+3A_frame">frame</code></td>
<td>
<p>data frame to get values from</p>
</td></tr>
<tr><td><code id="PRTPlot_+3A_predvar">predVar</code></td>
<td>
<p>name of the column of predicted scores</p>
</td></tr>
<tr><td><code id="PRTPlot_+3A_truthvar">truthVar</code></td>
<td>
<p>name of the column of actual outcomes in frame</p>
</td></tr>
<tr><td><code id="PRTPlot_+3A_truthtarget">truthTarget</code></td>
<td>
<p>value we consider to be positive</p>
</td></tr>
<tr><td><code id="PRTPlot_+3A_title">title</code></td>
<td>
<p>title to place on plot</p>
</td></tr>
<tr><td><code id="PRTPlot_+3A_...">...</code></td>
<td>
<p>no unnamed argument, added to force named binding of later arguments.</p>
</td></tr>
<tr><td><code id="PRTPlot_+3A_plotvars">plotvars</code></td>
<td>
<p>variables to plot, must be at least one of the measures listed below. Defaults to c(&quot;precision&quot;, &quot;recall&quot;)</p>
</td></tr>
<tr><td><code id="PRTPlot_+3A_thresholdrange">thresholdrange</code></td>
<td>
<p>range of thresholds to plot.</p>
</td></tr>
<tr><td><code id="PRTPlot_+3A_linecolor">linecolor</code></td>
<td>
<p>line color for the plot</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For a classifier, the precision is what fraction of predicted positives
are true positives; the recall is what fraction of true positives the
classifier finds, and the enrichment is the ratio of classifier precision to
the average rate of positives. Plotting precision-recall or enrichment-recall
as a function of classifier score helps identify a score threshold that achieves
an acceptable tradeoff between precision and recall, or enrichment and recall.
</p>
<p>In addition to precision/recall, <code>PRTPlot</code> can plot a number of other metrics:
</p>

<ul>
<li><p>precision: fraction of predicted positives that are true positives
</p>
</li>
<li><p>recall: fraction of true positives that were predicted to be true
</p>
</li>
<li><p>enrichment: ratio of classifier precision to prevalence of positive class
</p>
</li>
<li><p>sensitivity: the same as recall (also known as the true positive rate)
</p>
</li>
<li><p>specificity: fraction of true negatives to all negatives (or 1 - false_positive_rate)
</p>
</li>
<li><p>false_positive_rate: fraction of negatives predicted to be true over all negatives
</p>
</li></ul>

<p>For example, plotting sensitivity/false_positive_rate as functions of threshold will &quot;unroll&quot; an ROC Plot.
</p>
<p>Plots are in a single column, in the order specified by <code>plotvars</code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+ThresholdPlot">ThresholdPlot</a></code>, <code><a href="#topic+ROCPlot">ROCPlot</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
if (requireNamespace('data.table', quietly = TRUE)) {
	# don't multi-thread during CRAN checks
		data.table::setDTthreads(1)
}

df &lt;- iris
df$isVersicolor &lt;- with(df, Species=='versicolor')
model = glm(isVersicolor ~ Petal.Length + Petal.Width + Sepal.Length + Sepal.Width,
            data=df, family=binomial)
df$pred = predict(model, newdata=df, type="response")

WVPlots::PRTPlot(df, "pred", "isVersicolor", TRUE, title="Example Precision-Recall threshold plot")

if (FALSE) {
WVPlots::PRTPlot(df, "pred", "isVersicolor", TRUE,
                 plotvars = c("sensitivity", "specificity", "false_positive_rate"),
                 title="Sensitivity/specificity/FPR as functions of threshold")
}

</code></pre>

<hr>
<h2 id='ROCPlot'>Plot receiver operating characteristic plot.</h2><span id='topic+ROCPlot'></span>

<h3>Description</h3>

<p>Plot receiver operating characteristic plot.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ROCPlot(
  frame,
  xvar,
  truthVar,
  truthTarget,
  title,
  ...,
  estimate_sig = FALSE,
  returnScores = FALSE,
  nrep = 100,
  parallelCluster = NULL,
  curve_color = "darkblue",
  fill_color = "black",
  diag_color = "black",
  add_beta_ideal_curve = FALSE,
  beta_ideal_curve_color = "#fd8d3c",
  add_beta1_ideal_curve = FALSE,
  beta1_ideal_curve_color = "#f03b20",
  add_symmetric_ideal_curve = FALSE,
  symmetric_ideal_curve_color = "#bd0026",
  add_convex_hull = FALSE,
  convex_hull_color = "#404040",
  ideal_plot_step_size = 0.001
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ROCPlot_+3A_frame">frame</code></td>
<td>
<p>data frame to get values from</p>
</td></tr>
<tr><td><code id="ROCPlot_+3A_xvar">xvar</code></td>
<td>
<p>name of the independent (input or model) column in frame</p>
</td></tr>
<tr><td><code id="ROCPlot_+3A_truthvar">truthVar</code></td>
<td>
<p>name of the dependent (output or result to be modeled) column in frame</p>
</td></tr>
<tr><td><code id="ROCPlot_+3A_truthtarget">truthTarget</code></td>
<td>
<p>value we consider to be positive</p>
</td></tr>
<tr><td><code id="ROCPlot_+3A_title">title</code></td>
<td>
<p>title to place on plot</p>
</td></tr>
<tr><td><code id="ROCPlot_+3A_...">...</code></td>
<td>
<p>no unnamed argument, added to force named binding of later arguments.</p>
</td></tr>
<tr><td><code id="ROCPlot_+3A_estimate_sig">estimate_sig</code></td>
<td>
<p>logical, if TRUE estimate and display significance of difference from AUC 0.5.</p>
</td></tr>
<tr><td><code id="ROCPlot_+3A_returnscores">returnScores</code></td>
<td>
<p>logical if TRUE return detailed permutedScores</p>
</td></tr>
<tr><td><code id="ROCPlot_+3A_nrep">nrep</code></td>
<td>
<p>number of permutation repetitions to estimate p values.</p>
</td></tr>
<tr><td><code id="ROCPlot_+3A_parallelcluster">parallelCluster</code></td>
<td>
<p>(optional) a cluster object created by package parallel or package snow.</p>
</td></tr>
<tr><td><code id="ROCPlot_+3A_curve_color">curve_color</code></td>
<td>
<p>color of the ROC curve</p>
</td></tr>
<tr><td><code id="ROCPlot_+3A_fill_color">fill_color</code></td>
<td>
<p>shading color for the area under the curve</p>
</td></tr>
<tr><td><code id="ROCPlot_+3A_diag_color">diag_color</code></td>
<td>
<p>color for the AUC=0.5 line (x=y)</p>
</td></tr>
<tr><td><code id="ROCPlot_+3A_add_beta_ideal_curve">add_beta_ideal_curve</code></td>
<td>
<p>logical, if TRUE add the beta(a, b), beta(c, d) ideal curve found by moment matching.</p>
</td></tr>
<tr><td><code id="ROCPlot_+3A_beta_ideal_curve_color">beta_ideal_curve_color</code></td>
<td>
<p>color for ideal curve.</p>
</td></tr>
<tr><td><code id="ROCPlot_+3A_add_beta1_ideal_curve">add_beta1_ideal_curve</code></td>
<td>
<p>logical, if TRUE add the beta(1, a), beta(b, 2) ideal curve defined in <a href="https://doi.org/10.1177/0272989X15582210">doi:10.1177/0272989X15582210</a></p>
</td></tr>
<tr><td><code id="ROCPlot_+3A_beta1_ideal_curve_color">beta1_ideal_curve_color</code></td>
<td>
<p>color for ideal curve.</p>
</td></tr>
<tr><td><code id="ROCPlot_+3A_add_symmetric_ideal_curve">add_symmetric_ideal_curve</code></td>
<td>
<p>logical, if TRUE add the ideal curve as discussed in <a href="https://win-vector.com/2020/09/13/why-working-with-auc-is-more-powerful-than-one-might-think/">https://win-vector.com/2020/09/13/why-working-with-auc-is-more-powerful-than-one-might-think/</a>.</p>
</td></tr>
<tr><td><code id="ROCPlot_+3A_symmetric_ideal_curve_color">symmetric_ideal_curve_color</code></td>
<td>
<p>color for ideal curve.</p>
</td></tr>
<tr><td><code id="ROCPlot_+3A_add_convex_hull">add_convex_hull</code></td>
<td>
<p>logical, if TRUE add convex hull to plot</p>
</td></tr>
<tr><td><code id="ROCPlot_+3A_convex_hull_color">convex_hull_color</code></td>
<td>
<p>color for convex hull curve</p>
</td></tr>
<tr><td><code id="ROCPlot_+3A_ideal_plot_step_size">ideal_plot_step_size</code></td>
<td>
<p>step size used in ideal plots</p>
</td></tr>
</table>


<h3>Details</h3>

<p>See https://www.nature.com/articles/nmeth.3945 for a discussion of
true positive and false positive rates,
and how the ROC plot relates to the precision/recall plot.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+PRTPlot">PRTPlot</a></code>, <code><a href="#topic+ThresholdPlot">ThresholdPlot</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
if (requireNamespace('data.table', quietly = TRUE)) {
	# don't multi-thread during CRAN checks
		data.table::setDTthreads(1)
}

beta_example &lt;- function(
  n,
  shape1_pos, shape2_pos,
  shape1_neg, shape2_neg) {
  d &lt;- data.frame(
    y = sample(
      c(TRUE, FALSE),
      size = n,
      replace = TRUE),
    score = 0.0
  )
  d$score[d$y] &lt;- rbeta(sum(d$y), shape1 = shape1_pos, shape2 = shape2_pos)
  d$score[!d$y] &lt;- rbeta(sum(!d$y), shape1 = shape1_neg, shape2 = shape2_neg)
  d
}

d1 &lt;- beta_example(
  100,
  shape1_pos = 6,
  shape2_pos = 5,
  shape1_neg = 1,
  shape2_neg = 2)

ROCPlot(
   d1,
   xvar = "score",
   truthVar = "y", truthTarget = TRUE,
   title="Example ROC plot",
   estimate_sig = TRUE,
   add_beta_ideal_curve = TRUE,
   add_convex_hull = TRUE)

</code></pre>

<hr>
<h2 id='ROCPlotList'>Compare multiple ROC plots.</h2><span id='topic+ROCPlotList'></span><span id='topic+ROCPlotPairList'></span><span id='topic+ROCListPlot'></span>

<h3>Description</h3>

<p>Plot multiple receiver operating characteristic curves from the same data.frame.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ROCPlotList(
  frame,
  xvar_names,
  truthVar,
  truthTarget,
  title,
  ...,
  palette = "Dark2"
)

ROCPlotPairList(
  frame,
  xvar_names,
  truthVar,
  truthTarget,
  title,
  ...,
  palette = "Dark2"
)

ROCListPlot(
  frame,
  xvar_names,
  truthVar,
  truthTarget,
  title,
  ...,
  palette = "Dark2"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ROCPlotList_+3A_frame">frame</code></td>
<td>
<p>data frame to get values from</p>
</td></tr>
<tr><td><code id="ROCPlotList_+3A_xvar_names">xvar_names</code></td>
<td>
<p>names of the independent (input or model) columns in frame</p>
</td></tr>
<tr><td><code id="ROCPlotList_+3A_truthvar">truthVar</code></td>
<td>
<p>name of the dependent (output or result to be modeled) column in frame</p>
</td></tr>
<tr><td><code id="ROCPlotList_+3A_truthtarget">truthTarget</code></td>
<td>
<p>value we consider to be positive</p>
</td></tr>
<tr><td><code id="ROCPlotList_+3A_title">title</code></td>
<td>
<p>title to place on plot</p>
</td></tr>
<tr><td><code id="ROCPlotList_+3A_...">...</code></td>
<td>
<p>no unnamed argument, added to force named binding of later arguments.</p>
</td></tr>
<tr><td><code id="ROCPlotList_+3A_palette">palette</code></td>
<td>
<p>name of a brewer palette (NULL for ggplot2 default coloring)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The use case for this function is to compare the performance of two
models when applied to a data set, where the predictions from both models
are columns of the same data frame.
</p>
<p>If <code>palette</code> is NULL, plot colors will be chosen from the default ggplot2 palette. Setting <code>palette</code> to NULL
allows the user to choose a non-Brewer palette, for example with <code><a href="ggplot2.html#topic+scale_manual">scale_color_manual</a></code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+ROCPlot">ROCPlot</a></code>, <code><a href="#topic+ROCPlotPair">ROCPlotPair</a></code>, <code><a href="#topic+ROCPlotPair2">ROCPlotPair2</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
if (requireNamespace('data.table', quietly = TRUE)) {
	# don't multi-thread during CRAN checks
		data.table::setDTthreads(1)
}

set.seed(34903490)
x1 = rnorm(50)
x2 = rnorm(length(x1))
x3 = rnorm(length(x1))
y = 0.2*x2^2 + 0.5*x2 + x1 + rnorm(length(x1))
frm = data.frame(
   x1 = x1,
   x2 = x2,
   x3 = x3,
   yC = y &gt;= as.numeric(quantile(y,probs=0.8)))
WVPlots::ROCPlotList(
   frame = frm,
   xvar_names = c("x1", "x2", "x3"),
   truthVar = "yC", truthTarget = TRUE,
   title = "Example ROC list plot")

</code></pre>

<hr>
<h2 id='ROCPlotPair'>Compare two ROC plots.</h2><span id='topic+ROCPlotPair'></span>

<h3>Description</h3>

<p>Plot two receiver operating characteristic curves from the same data.frame.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ROCPlotPair(
  frame,
  xvar1,
  xvar2,
  truthVar,
  truthTarget,
  title,
  ...,
  estimate_sig = FALSE,
  returnScores = FALSE,
  nrep = 100,
  parallelCluster = NULL,
  palette = "Dark2"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ROCPlotPair_+3A_frame">frame</code></td>
<td>
<p>data frame to get values from</p>
</td></tr>
<tr><td><code id="ROCPlotPair_+3A_xvar1">xvar1</code></td>
<td>
<p>name of the first independent (input or model) column in frame</p>
</td></tr>
<tr><td><code id="ROCPlotPair_+3A_xvar2">xvar2</code></td>
<td>
<p>name of the second independent (input or model) column in frame</p>
</td></tr>
<tr><td><code id="ROCPlotPair_+3A_truthvar">truthVar</code></td>
<td>
<p>name of the dependent (output or result to be modeled) column in frame</p>
</td></tr>
<tr><td><code id="ROCPlotPair_+3A_truthtarget">truthTarget</code></td>
<td>
<p>value we consider to be positive</p>
</td></tr>
<tr><td><code id="ROCPlotPair_+3A_title">title</code></td>
<td>
<p>title to place on plot</p>
</td></tr>
<tr><td><code id="ROCPlotPair_+3A_...">...</code></td>
<td>
<p>no unnamed argument, added to force named binding of later arguments.</p>
</td></tr>
<tr><td><code id="ROCPlotPair_+3A_estimate_sig">estimate_sig</code></td>
<td>
<p>logical, if TRUE estimate and display significance of difference from AUC 0.5.</p>
</td></tr>
<tr><td><code id="ROCPlotPair_+3A_returnscores">returnScores</code></td>
<td>
<p>logical if TRUE return detailed permutedScores</p>
</td></tr>
<tr><td><code id="ROCPlotPair_+3A_nrep">nrep</code></td>
<td>
<p>number of permutation repetitions to estimate p values.</p>
</td></tr>
<tr><td><code id="ROCPlotPair_+3A_parallelcluster">parallelCluster</code></td>
<td>
<p>(optional) a cluster object created by package parallel or package snow.</p>
</td></tr>
<tr><td><code id="ROCPlotPair_+3A_palette">palette</code></td>
<td>
<p>name of a brewer palette (NULL for ggplot2 default coloring)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The use case for this function is to compare the performance of two
models when applied to a data set, where the predictions from both models
are columns of the same data frame.
</p>
<p>If <code>palette</code> is NULL, plot colors will be chosen from the default ggplot2 palette. Setting <code>palette</code> to NULL
allows the user to choose a non-Brewer palette, for example with <code><a href="ggplot2.html#topic+scale_manual">scale_color_manual</a></code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+ROCPlot">ROCPlot</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
if (requireNamespace('data.table', quietly = TRUE)) {
	# don't multi-thread during CRAN checks
		data.table::setDTthreads(1)
}

set.seed(34903490)
x1 = rnorm(50)
x2 = rnorm(length(x1))
y = 0.2*x2^2 + 0.5*x2 + x1 + rnorm(length(x1))
frm = data.frame(x1=x1,x2=x2,yC=y&gt;=as.numeric(quantile(y,probs=0.8)))
# WVPlots::ROCPlot(frm, "x1", "yC", TRUE, title="Example ROC plot")
# WVPlots::ROCPlot(frm, "x2", "yC", TRUE, title="Example ROC plot")
WVPlots::ROCPlotPair(frm, "x1", "x2", "yC", TRUE,
   title="Example ROC pair plot", estimate_sig = TRUE)

</code></pre>

<hr>
<h2 id='ROCPlotPair2'>Compare two ROC plots.</h2><span id='topic+ROCPlotPair2'></span>

<h3>Description</h3>

<p>Plot two receiver operating characteristic curves from different data frames.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ROCPlotPair2(
  nm1,
  frame1,
  xvar1,
  truthVar1,
  truthTarget1,
  nm2,
  frame2,
  xvar2,
  truthVar2,
  truthTarget2,
  title,
  ...,
  estimate_sig = TRUE,
  returnScores = FALSE,
  nrep = 100,
  parallelCluster = NULL,
  palette = "Dark2"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ROCPlotPair2_+3A_nm1">nm1</code></td>
<td>
<p>name of first model</p>
</td></tr>
<tr><td><code id="ROCPlotPair2_+3A_frame1">frame1</code></td>
<td>
<p>data frame to get values from</p>
</td></tr>
<tr><td><code id="ROCPlotPair2_+3A_xvar1">xvar1</code></td>
<td>
<p>name of the first independent (input or model) column in frame</p>
</td></tr>
<tr><td><code id="ROCPlotPair2_+3A_truthvar1">truthVar1</code></td>
<td>
<p>name of the dependent (output or result to be modeled) column in frame</p>
</td></tr>
<tr><td><code id="ROCPlotPair2_+3A_truthtarget1">truthTarget1</code></td>
<td>
<p>value we consider to be positive</p>
</td></tr>
<tr><td><code id="ROCPlotPair2_+3A_nm2">nm2</code></td>
<td>
<p>name of second model</p>
</td></tr>
<tr><td><code id="ROCPlotPair2_+3A_frame2">frame2</code></td>
<td>
<p>data frame to get values from</p>
</td></tr>
<tr><td><code id="ROCPlotPair2_+3A_xvar2">xvar2</code></td>
<td>
<p>name of the first independent (input or model) column in frame</p>
</td></tr>
<tr><td><code id="ROCPlotPair2_+3A_truthvar2">truthVar2</code></td>
<td>
<p>name of the dependent (output or result to be modeled) column in frame</p>
</td></tr>
<tr><td><code id="ROCPlotPair2_+3A_truthtarget2">truthTarget2</code></td>
<td>
<p>value we consider to be positive</p>
</td></tr>
<tr><td><code id="ROCPlotPair2_+3A_title">title</code></td>
<td>
<p>title to place on plot</p>
</td></tr>
<tr><td><code id="ROCPlotPair2_+3A_...">...</code></td>
<td>
<p>no unnamed argument, added to force named binding of later arguments.</p>
</td></tr>
<tr><td><code id="ROCPlotPair2_+3A_estimate_sig">estimate_sig</code></td>
<td>
<p>logical, if TRUE estimate and display significance of difference from AUC 0.5.</p>
</td></tr>
<tr><td><code id="ROCPlotPair2_+3A_returnscores">returnScores</code></td>
<td>
<p>logical if TRUE return detailed permutedScores</p>
</td></tr>
<tr><td><code id="ROCPlotPair2_+3A_nrep">nrep</code></td>
<td>
<p>number of permutation repetitions to estimate p values.</p>
</td></tr>
<tr><td><code id="ROCPlotPair2_+3A_parallelcluster">parallelCluster</code></td>
<td>
<p>(optional) a cluster object created by package parallel or package snow.</p>
</td></tr>
<tr><td><code id="ROCPlotPair2_+3A_palette">palette</code></td>
<td>
<p>name of Brewer palette to color curves (can be NULL)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Use this curve to compare model predictions to true outcome from two
data frames, each of which has its own model predictions and true outcome columns.
</p>
<p>If <code>palette</code> is NULL, plot colors will be chosen from the default ggplot2 palette. Setting <code>palette</code> to NULL
allows the user to choose a non-Brewer palette, for example with <code><a href="ggplot2.html#topic+scale_manual">scale_color_manual</a></code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+ROCPlot">ROCPlot</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
if (requireNamespace('data.table', quietly = TRUE)) {
	# don't multi-thread during CRAN checks
		data.table::setDTthreads(1)
}

set.seed(34903490)
x1 = rnorm(50)
x2 = rnorm(length(x1))
y = 0.2*x2^2 + 0.5*x2 + x1 + rnorm(length(x1))
frm = data.frame(x1=x1,x2=x2,yC=y&gt;=as.numeric(quantile(y,probs=0.8)))
# WVPlots::ROCPlot(frm, "x1", "yC", TRUE, title="Example ROC plot")
# WVPlots::ROCPlot(frm, "x2", "yC", TRUE, title="Example ROC plot")
WVPlots::ROCPlotPair2('train',frm, "x1", "yC", TRUE,
                      'test', frm, "x2", "yC", TRUE,
                      title="Example ROC pair plot", estimate_sig = TRUE)

</code></pre>

<hr>
<h2 id='ScatterBoxPlot'>Plot a scatter box plot.</h2><span id='topic+ScatterBoxPlot'></span>

<h3>Description</h3>

<p>Plot a boxplot with the data points superimposed.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ScatterBoxPlot(
  frm,
  xvar,
  yvar,
  title,
  ...,
  pt_alpha = 0.3,
  pt_color = "black",
  box_color = "black",
  box_fill = "lightgray"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ScatterBoxPlot_+3A_frm">frm</code></td>
<td>
<p>data frame to get values from</p>
</td></tr>
<tr><td><code id="ScatterBoxPlot_+3A_xvar">xvar</code></td>
<td>
<p>name of the independent column in frame; assumed discrete</p>
</td></tr>
<tr><td><code id="ScatterBoxPlot_+3A_yvar">yvar</code></td>
<td>
<p>name of the continuous column in frame</p>
</td></tr>
<tr><td><code id="ScatterBoxPlot_+3A_title">title</code></td>
<td>
<p>plot title</p>
</td></tr>
<tr><td><code id="ScatterBoxPlot_+3A_...">...</code></td>
<td>
<p>(doesn't take additional arguments, used to force later arguments by name)</p>
</td></tr>
<tr><td><code id="ScatterBoxPlot_+3A_pt_alpha">pt_alpha</code></td>
<td>
<p>transparency of points in scatter plot</p>
</td></tr>
<tr><td><code id="ScatterBoxPlot_+3A_pt_color">pt_color</code></td>
<td>
<p>point color</p>
</td></tr>
<tr><td><code id="ScatterBoxPlot_+3A_box_color">box_color</code></td>
<td>
<p>boxplot line color</p>
</td></tr>
<tr><td><code id="ScatterBoxPlot_+3A_box_fill">box_fill</code></td>
<td>
<p>boxplot fill color (can be NA for no fill)</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>xvar</code> is a discrete variable and <code>yvar</code> is a continuous variable.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+ScatterBoxPlotH">ScatterBoxPlotH</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
if (requireNamespace('data.table', quietly = TRUE)) {
	# don't multi-thread during CRAN checks
		data.table::setDTthreads(1)
}

classes = c("a", "b", "c")
means = c(2, 4, 3)
names(means) = classes
label = sample(classes, size=1000, replace=TRUE)
meas = means[label] + rnorm(1000)
frm2 = data.frame(label=label,
                  meas = meas)
WVPlots::ScatterBoxPlot(frm2, "label", "meas", pt_alpha=0.2, title="Example Scatter/Box plot")

</code></pre>

<hr>
<h2 id='ScatterBoxPlotH'>Plot a scatter box plot in horizontal mode.</h2><span id='topic+ScatterBoxPlotH'></span>

<h3>Description</h3>

<p>Plot a boxplot with the data points superimposed. Box plots are aligned horizontally.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ScatterBoxPlotH(
  frm,
  xvar,
  yvar,
  title,
  ...,
  pt_alpha = 0.3,
  pt_color = "black",
  box_color = "black",
  box_fill = "lightgray"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ScatterBoxPlotH_+3A_frm">frm</code></td>
<td>
<p>data frame to get values from</p>
</td></tr>
<tr><td><code id="ScatterBoxPlotH_+3A_xvar">xvar</code></td>
<td>
<p>name of the continuous column in frame</p>
</td></tr>
<tr><td><code id="ScatterBoxPlotH_+3A_yvar">yvar</code></td>
<td>
<p>name of the independent column in frame; assumed discrete</p>
</td></tr>
<tr><td><code id="ScatterBoxPlotH_+3A_title">title</code></td>
<td>
<p>plot title</p>
</td></tr>
<tr><td><code id="ScatterBoxPlotH_+3A_...">...</code></td>
<td>
<p>(doesn't take additional arguments, used to force later arguments by name)</p>
</td></tr>
<tr><td><code id="ScatterBoxPlotH_+3A_pt_alpha">pt_alpha</code></td>
<td>
<p>transparency of points in scatter plot</p>
</td></tr>
<tr><td><code id="ScatterBoxPlotH_+3A_pt_color">pt_color</code></td>
<td>
<p>point color</p>
</td></tr>
<tr><td><code id="ScatterBoxPlotH_+3A_box_color">box_color</code></td>
<td>
<p>boxplot line color</p>
</td></tr>
<tr><td><code id="ScatterBoxPlotH_+3A_box_fill">box_fill</code></td>
<td>
<p>boxplot fill color (can be NA for no fill)</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>xvar</code> is a continuous variable and <code>yvar</code> is a discrete variable.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+ScatterBoxPlot">ScatterBoxPlot</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
if (requireNamespace('data.table', quietly = TRUE)) {
	# don't multi-thread during CRAN checks
		data.table::setDTthreads(1)
}

classes = c("a", "b", "c")
means = c(2, 4, 3)
names(means) = classes
label = sample(classes, size=1000, replace=TRUE)
meas = means[label] + rnorm(1000)
frm2 = data.frame(label=label,
                  meas = meas)
WVPlots::ScatterBoxPlotH(frm2, "meas", "label",  pt_alpha=0.2, title="Example Scatter/Box plot")


</code></pre>

<hr>
<h2 id='ScatterHist'>Plot a scatter plot with marginals.</h2><span id='topic+ScatterHist'></span>

<h3>Description</h3>

<p>Plot a scatter plot with optional smoothing curves or contour lines, and marginal histogram/density plots.
Based on <a href="https://win-vector.com/2015/06/11/wanted-a-perfect-scatterplot-with-marginals/">https://win-vector.com/2015/06/11/wanted-a-perfect-scatterplot-with-marginals/</a>.
See also <code>ggExtra::ggMarginal</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ScatterHist(
  frame,
  xvar,
  yvar,
  title,
  ...,
  smoothmethod = "lm",
  estimate_sig = FALSE,
  minimal_labels = TRUE,
  binwidth_x = NULL,
  binwidth_y = NULL,
  adjust_x = 1,
  adjust_y = 1,
  point_alpha = 0.5,
  contour = FALSE,
  point_color = "black",
  hist_color = "gray",
  smoothing_color = "blue",
  density_color = "blue",
  contour_color = "blue"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ScatterHist_+3A_frame">frame</code></td>
<td>
<p>data frame to get values from</p>
</td></tr>
<tr><td><code id="ScatterHist_+3A_xvar">xvar</code></td>
<td>
<p>name of the independent (input or model) column in frame</p>
</td></tr>
<tr><td><code id="ScatterHist_+3A_yvar">yvar</code></td>
<td>
<p>name of the dependent (output or result to be modeled) column in frame</p>
</td></tr>
<tr><td><code id="ScatterHist_+3A_title">title</code></td>
<td>
<p>title to place on plot</p>
</td></tr>
<tr><td><code id="ScatterHist_+3A_...">...</code></td>
<td>
<p>no unnamed argument, added to force named binding of later arguments.</p>
</td></tr>
<tr><td><code id="ScatterHist_+3A_smoothmethod">smoothmethod</code></td>
<td>
<p>(optional) one of 'auto', 'loess', 'gam', 'lm', 'identity', or 'none'.</p>
</td></tr>
<tr><td><code id="ScatterHist_+3A_estimate_sig">estimate_sig</code></td>
<td>
<p>logical if TRUE and smoothmethod is 'identity' or 'lm', report goodness of fit and significance of relation.</p>
</td></tr>
<tr><td><code id="ScatterHist_+3A_minimal_labels">minimal_labels</code></td>
<td>
<p>logical drop some annotations</p>
</td></tr>
<tr><td><code id="ScatterHist_+3A_binwidth_x">binwidth_x</code></td>
<td>
<p>numeric binwidth for x histogram</p>
</td></tr>
<tr><td><code id="ScatterHist_+3A_binwidth_y">binwidth_y</code></td>
<td>
<p>numeric binwidth for y histogram</p>
</td></tr>
<tr><td><code id="ScatterHist_+3A_adjust_x">adjust_x</code></td>
<td>
<p>numeric adjust x density plot</p>
</td></tr>
<tr><td><code id="ScatterHist_+3A_adjust_y">adjust_y</code></td>
<td>
<p>numeric adjust y density plot</p>
</td></tr>
<tr><td><code id="ScatterHist_+3A_point_alpha">point_alpha</code></td>
<td>
<p>numeric opaqueness of the plot points</p>
</td></tr>
<tr><td><code id="ScatterHist_+3A_contour">contour</code></td>
<td>
<p>logical if TRUE add a 2d contour plot</p>
</td></tr>
<tr><td><code id="ScatterHist_+3A_point_color">point_color</code></td>
<td>
<p>color for scatter plots</p>
</td></tr>
<tr><td><code id="ScatterHist_+3A_hist_color">hist_color</code></td>
<td>
<p>fill color for marginal histograms</p>
</td></tr>
<tr><td><code id="ScatterHist_+3A_smoothing_color">smoothing_color</code></td>
<td>
<p>color for smoothing line</p>
</td></tr>
<tr><td><code id="ScatterHist_+3A_density_color">density_color</code></td>
<td>
<p>color for marginal density plots</p>
</td></tr>
<tr><td><code id="ScatterHist_+3A_contour_color">contour_color</code></td>
<td>
<p>color for contour plots</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If <code>smoothmethod</code> is:
</p>

<ul>
<li><p> 'auto', 'loess' or 'gam':  the appropriate smoothing curve is added to the scatterplot.
</p>
</li>
<li><p> 'lm' (the default): the best fit line is added to the scatterplot.
</p>
</li>
<li><p> 'identity':  the line x = y is added to the scatterplot. This is useful for comparing model predictions to true outcome.
</p>
</li>
<li><p> 'none': no smoothing line is added to the scatterplot.
</p>
</li></ul>

<p>If <code>estimate_sig</code> is TRUE and <code>smoothmethod</code> is:
</p>

<ul>
<li><p> 'lm': the R-squared of the linear fit is reported.
</p>
</li>
<li><p>  'identity': the R-squared of the exact relation between <code>xvar</code> and <code>yvar</code> is reported.
</p>
</li></ul>

<p>Note that the identity R-squared is NOT the square of the correlation between <code>xvar</code> and <code>yvar</code>
(which includes an implicit shift and scale). It is the coefficient of determination between <code>xvar</code> and
<code>yvar</code>, and can be negative. See <a href="https://en.wikipedia.org/wiki/Coefficient_of_determination">https://en.wikipedia.org/wiki/Coefficient_of_determination</a> for more details.
If <code>xvar</code> is the output of a model to predict <code>yvar</code>, then the identity R-squared, not the lm R-squared,
is the correct measure.
</p>
<p>If <code>smoothmethod</code> is neither 'lm' or 'identity' then <code>estimate_sig</code> is ignored.
</p>


<h3>Value</h3>

<p>plot grid
</p>


<h3>See Also</h3>

<p><code><a href="#topic+ScatterHistC">ScatterHistC</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
if (requireNamespace('data.table', quietly = TRUE)) {
	# don't multi-thread during CRAN checks
		data.table::setDTthreads(1)
}

set.seed(34903490)
x = rnorm(50)
y = 0.5*x^2 + 2*x + rnorm(length(x))
frm = data.frame(x=x,y=y)
WVPlots::ScatterHist(frm, "x", "y",
  title= "Example Fit",
  smoothmethod = "gam",
  contour = TRUE)

if (FALSE) {
# Same plot with custom colors
WVPlots::ScatterHist(frm, "x", "y",
  title= "Example Fit",
  smoothmethod = "gam",
  contour = TRUE,
  point_color = "#006d2c", # dark green
  hist_color = "#6baed6", # medium blue
  smoothing_color = "#54278f", # dark purple
  density_color = "#08519c", # darker blue
  contour_color = "#9e9ac8") # lighter purple
}

</code></pre>

<hr>
<h2 id='ScatterHistC'>Plot a conditional scatter plot with marginals.</h2><span id='topic+ScatterHistC'></span>

<h3>Description</h3>

<p>Plot a scatter plot conditioned on a discrete variable, with marginal conditional density plots.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ScatterHistC(
  frame,
  xvar,
  yvar,
  cvar,
  title,
  ...,
  annot_size = 3,
  colorPalette = "Dark2",
  adjust_x = 1,
  adjust_y = 1
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ScatterHistC_+3A_frame">frame</code></td>
<td>
<p>data frame to get values from</p>
</td></tr>
<tr><td><code id="ScatterHistC_+3A_xvar">xvar</code></td>
<td>
<p>name of the x variable</p>
</td></tr>
<tr><td><code id="ScatterHistC_+3A_yvar">yvar</code></td>
<td>
<p>name of the y variable</p>
</td></tr>
<tr><td><code id="ScatterHistC_+3A_cvar">cvar</code></td>
<td>
<p>name of condition variable</p>
</td></tr>
<tr><td><code id="ScatterHistC_+3A_title">title</code></td>
<td>
<p>title to place on plot</p>
</td></tr>
<tr><td><code id="ScatterHistC_+3A_...">...</code></td>
<td>
<p>no unnamed argument, added to force named binding of later arguments.</p>
</td></tr>
<tr><td><code id="ScatterHistC_+3A_annot_size">annot_size</code></td>
<td>
<p>numeric scale annotation text (if present)</p>
</td></tr>
<tr><td><code id="ScatterHistC_+3A_colorpalette">colorPalette</code></td>
<td>
<p>name of a Brewer palette (see https://colorbrewer2.org/ )</p>
</td></tr>
<tr><td><code id="ScatterHistC_+3A_adjust_x">adjust_x</code></td>
<td>
<p>numeric: adjust x density plot</p>
</td></tr>
<tr><td><code id="ScatterHistC_+3A_adjust_y">adjust_y</code></td>
<td>
<p>numeric: adjust y density plot</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>xvar</code> and <code>yvar</code> are the coordinates of the points, and <code>cvar</code> is the
discrete conditioning variable that indicates which category each point (x,y) belongs to.
</p>


<h3>Value</h3>

<p>plot grid
</p>


<h3>See Also</h3>

<p><code><a href="#topic+ScatterHist">ScatterHist</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
if (requireNamespace('data.table', quietly = TRUE)) {
	# don't multi-thread during CRAN checks
		data.table::setDTthreads(1)
}

set.seed(34903490)
frm = data.frame(x=rnorm(50),y=rnorm(50))
frm$cat &lt;- frm$x+frm$y&gt;0
WVPlots::ScatterHistC(frm, "x", "y", "cat",
                      title="Example Conditional Distribution")

</code></pre>

<hr>
<h2 id='ScatterHistN'>Plot a height scatter plot with marginals.</h2><span id='topic+ScatterHistN'></span>

<h3>Description</h3>

<p>Plot a scatter plot conditioned on a continuous variable, with marginal conditional density plots.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ScatterHistN(
  frame,
  xvar,
  yvar,
  zvar,
  title,
  ...,
  annot_size = 3,
  colorPalette = "RdYlBu",
  nclus = 3,
  adjust_x = 1,
  adjust_y = 1
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ScatterHistN_+3A_frame">frame</code></td>
<td>
<p>data frame to get values from</p>
</td></tr>
<tr><td><code id="ScatterHistN_+3A_xvar">xvar</code></td>
<td>
<p>name of the x variable</p>
</td></tr>
<tr><td><code id="ScatterHistN_+3A_yvar">yvar</code></td>
<td>
<p>name of the y variable</p>
</td></tr>
<tr><td><code id="ScatterHistN_+3A_zvar">zvar</code></td>
<td>
<p>name of height variable</p>
</td></tr>
<tr><td><code id="ScatterHistN_+3A_title">title</code></td>
<td>
<p>title to place on plot</p>
</td></tr>
<tr><td><code id="ScatterHistN_+3A_...">...</code></td>
<td>
<p>no unnamed argument, added to force named binding of later arguments.</p>
</td></tr>
<tr><td><code id="ScatterHistN_+3A_annot_size">annot_size</code></td>
<td>
<p>numeric: scale annotation text (if present)</p>
</td></tr>
<tr><td><code id="ScatterHistN_+3A_colorpalette">colorPalette</code></td>
<td>
<p>name of a Brewer palette (see https://colorbrewer2.org/ )</p>
</td></tr>
<tr><td><code id="ScatterHistN_+3A_nclus">nclus</code></td>
<td>
<p>scalar: number of z-clusters to plot</p>
</td></tr>
<tr><td><code id="ScatterHistN_+3A_adjust_x">adjust_x</code></td>
<td>
<p>numeric: adjust x density plot</p>
</td></tr>
<tr><td><code id="ScatterHistN_+3A_adjust_y">adjust_y</code></td>
<td>
<p>numeric: adjust y density plot</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>xvar</code> and <code>yvar</code> are the coordinates of the points, and <code>zvar</code> is the
continuous conditioning variable. <code>zvar</code> is partitioned into <code>nclus</code> disjoint
ranges (by default, 3), which are then treated as discrete categories.The scatterplot and marginal density plots
are color-coded by these categories.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+ScatterHistC">ScatterHistC</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
if (requireNamespace('data.table', quietly = TRUE)) {
	# don't multi-thread during CRAN checks
		data.table::setDTthreads(1)
}

set.seed(34903490)
frm = data.frame(x=rnorm(50),y=rnorm(50))
frm$z &lt;- frm$x+frm$y
WVPlots::ScatterHistN(frm, "x", "y", "z", title="Example Joint Distribution")

</code></pre>

<hr>
<h2 id='ShadedDensity'>Plot the distribution of a variable with a tail shaded</h2><span id='topic+ShadedDensity'></span>

<h3>Description</h3>

<p>Plot the distribution of a variable with a tail shaded. Annotate with the area of the shaded region.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ShadedDensity(
  frame,
  xvar,
  threshold,
  title,
  ...,
  tail = "left",
  linecolor = "darkgray",
  shading = "darkblue",
  annotate_area = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ShadedDensity_+3A_frame">frame</code></td>
<td>
<p>data frame to get values from</p>
</td></tr>
<tr><td><code id="ShadedDensity_+3A_xvar">xvar</code></td>
<td>
<p>name of the variable to be density plotted</p>
</td></tr>
<tr><td><code id="ShadedDensity_+3A_threshold">threshold</code></td>
<td>
<p>boundary value for the tail</p>
</td></tr>
<tr><td><code id="ShadedDensity_+3A_title">title</code></td>
<td>
<p>title to place on plot</p>
</td></tr>
<tr><td><code id="ShadedDensity_+3A_...">...</code></td>
<td>
<p>no unnamed argument, added to force named binding of later arguments.</p>
</td></tr>
<tr><td><code id="ShadedDensity_+3A_tail">tail</code></td>
<td>
<p>which tail to shade, 'left' (default) or 'right'</p>
</td></tr>
<tr><td><code id="ShadedDensity_+3A_linecolor">linecolor</code></td>
<td>
<p>color of density curve</p>
</td></tr>
<tr><td><code id="ShadedDensity_+3A_shading">shading</code></td>
<td>
<p>color of shaded region and boundaries</p>
</td></tr>
<tr><td><code id="ShadedDensity_+3A_annotate_area">annotate_area</code></td>
<td>
<p>if TRUE (default), report the area of the shaded region</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+ShadedDensityCenter">ShadedDensityCenter</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
if (requireNamespace('data.table', quietly = TRUE)) {
	# don't multi-thread during CRAN checks
		data.table::setDTthreads(1)
}

set.seed(52523)
d = data.frame(meas=rnorm(100))
threshold = -1.5
WVPlots::ShadedDensity(d, "meas", threshold,
                       title="Example shaded density plot, left tail")
if (FALSE) {
WVPlots::ShadedDensity(d, "meas", -threshold, tail="right",
                       title="Example shaded density plot, right tail")
}

</code></pre>

<hr>
<h2 id='ShadedDensityCenter'>Plot the distribution of a variable with a center region shaded</h2><span id='topic+ShadedDensityCenter'></span>

<h3>Description</h3>

<p>Plot the distribution of a variable with a center region shaded. Annotate with the area of the shaded region.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ShadedDensityCenter(
  frame,
  xvar,
  boundaries,
  title,
  ...,
  linecolor = "darkgray",
  shading = "darkblue",
  annotate_area = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ShadedDensityCenter_+3A_frame">frame</code></td>
<td>
<p>data frame to get values from</p>
</td></tr>
<tr><td><code id="ShadedDensityCenter_+3A_xvar">xvar</code></td>
<td>
<p>name of the variable to be density plotted</p>
</td></tr>
<tr><td><code id="ShadedDensityCenter_+3A_boundaries">boundaries</code></td>
<td>
<p>vector of the min and max boundaries of the shaded region</p>
</td></tr>
<tr><td><code id="ShadedDensityCenter_+3A_title">title</code></td>
<td>
<p>title to place on plot</p>
</td></tr>
<tr><td><code id="ShadedDensityCenter_+3A_...">...</code></td>
<td>
<p>no unnamed argument, added to force named binding of later arguments.</p>
</td></tr>
<tr><td><code id="ShadedDensityCenter_+3A_linecolor">linecolor</code></td>
<td>
<p>color of density curve</p>
</td></tr>
<tr><td><code id="ShadedDensityCenter_+3A_shading">shading</code></td>
<td>
<p>color of shaded region and boundaries</p>
</td></tr>
<tr><td><code id="ShadedDensityCenter_+3A_annotate_area">annotate_area</code></td>
<td>
<p>if TRUE (default), report the area of the shaded region</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+ShadedDensity">ShadedDensity</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
if (requireNamespace('data.table', quietly = TRUE)) {
	# don't multi-thread during CRAN checks
		data.table::setDTthreads(1)
}

set.seed(52523)
d = data.frame(meas=rnorm(100))
boundaries = c(-1.5, 1.5)
WVPlots::ShadedDensityCenter(d, "meas", boundaries,
                       title="Example center-shaded density plot")

</code></pre>

<hr>
<h2 id='ShadowHist'>Plot a Shadow Histogram Plot</h2><span id='topic+ShadowHist'></span>

<h3>Description</h3>

<p>Plot a histogram of a continuous variable <code>xvar</code>,
faceted on a categorical conditioning variable, <code>condvar</code>. Each faceted plot
also shows a &quot;shadow plot&quot; of the unconditioned histogram for comparison.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ShadowHist(
  frm,
  xvar,
  condvar,
  title,
  ...,
  ncol = 1,
  monochrome = FALSE,
  palette = "Dark2",
  fillcolor = "darkblue",
  bins = 30,
  binwidth = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ShadowHist_+3A_frm">frm</code></td>
<td>
<p>data frame to get values from.</p>
</td></tr>
<tr><td><code id="ShadowHist_+3A_xvar">xvar</code></td>
<td>
<p>name of the primary continuous variable</p>
</td></tr>
<tr><td><code id="ShadowHist_+3A_condvar">condvar</code></td>
<td>
<p>name of conditioning variable (categorical variable, controls faceting).</p>
</td></tr>
<tr><td><code id="ShadowHist_+3A_title">title</code></td>
<td>
<p>title to place on plot.</p>
</td></tr>
<tr><td><code id="ShadowHist_+3A_...">...</code></td>
<td>
<p>no unnamed argument, added to force named binding of later arguments.</p>
</td></tr>
<tr><td><code id="ShadowHist_+3A_ncol">ncol</code></td>
<td>
<p>numeric: number of columns in facet_wrap.</p>
</td></tr>
<tr><td><code id="ShadowHist_+3A_monochrome">monochrome</code></td>
<td>
<p>logical: if TRUE, all facets filled with same color</p>
</td></tr>
<tr><td><code id="ShadowHist_+3A_palette">palette</code></td>
<td>
<p>character: if monochrome==FALSE, name of brewer color palette (can be NULL)</p>
</td></tr>
<tr><td><code id="ShadowHist_+3A_fillcolor">fillcolor</code></td>
<td>
<p>character: if monochrome==TRUE, name of fill color</p>
</td></tr>
<tr><td><code id="ShadowHist_+3A_bins">bins</code></td>
<td>
<p>number of bins. Defaults to thirty.</p>
</td></tr>
<tr><td><code id="ShadowHist_+3A_binwidth">binwidth</code></td>
<td>
<p>width of the bins. Overrides bins.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Currently supports only the <code>bins</code> and <code>binwidth</code> arguments (see <code><a href="ggplot2.html#topic+geom_histogram">geom_histogram</a></code>),
but not the <code>center</code>, <code>boundary</code>, or <code>breaks</code> arguments.
</p>
<p>By default, the facet plots are arranged in a single column. This can be changed
with the optional <code>ncol</code> argument.
</p>
<p>If <code>palette</code> is NULL, and <code>monochrome</code> is FALSE, plot colors will be chosen from the default ggplot2 palette. Setting <code>palette</code> to NULL
allows the user to choose a non-Brewer palette, for example with <code><a href="ggplot2.html#topic+scale_manual">scale_fill_manual</a></code>.
For consistency with previous releases, <code>ShadowHist</code> defaults to <code>monochrome = FALSE</code>, while
<code><a href="#topic+ShadowPlot">ShadowPlot</a></code> defaults to <code>monochrome = TRUE</code>.
</p>
<p>Please see here for some interesting discussion <a href="https://drsimonj.svbtle.com/plotting-background-data-for-groups-with-ggplot2">https://drsimonj.svbtle.com/plotting-background-data-for-groups-with-ggplot2</a>.
</p>


<h3>Value</h3>

<p>a ggplot2 histogram plot
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
if (requireNamespace('data.table', quietly = TRUE)) {
	# don't multi-thread during CRAN checks
		data.table::setDTthreads(1)
}

ShadowHist(iris, "Petal.Length", "Species",
           title = "Petal Length distribution by Species")

if (FALSE) {
# make all the facets the same color
ShadowHist(iris, "Petal.Length", "Species",
           monochrome=TRUE,
           title = "Petal Length distribution by Species")
}

</code></pre>

<hr>
<h2 id='ShadowPlot'>Plot a Shadow Bar Plot</h2><span id='topic+ShadowPlot'></span>

<h3>Description</h3>

<p>Plot a bar chart of row counts conditioned on the categorical variable <code>condvar</code>,
faceted on a second categorical variable, <code>refinevar</code>. Each faceted plot
also shows a &quot;shadow plot&quot; of the totals conditioned on <code>condvar</code> alone.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ShadowPlot(
  frm,
  condvar,
  refinevar,
  title,
  ...,
  monochrome = TRUE,
  palette = "Dark2",
  fillcolor = "darkblue",
  ncol = 1
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ShadowPlot_+3A_frm">frm</code></td>
<td>
<p>data frame to get values from.</p>
</td></tr>
<tr><td><code id="ShadowPlot_+3A_condvar">condvar</code></td>
<td>
<p>name of the primary conditioning variable (a categorical variable, controls x-axis).</p>
</td></tr>
<tr><td><code id="ShadowPlot_+3A_refinevar">refinevar</code></td>
<td>
<p>name of the second or refining conditioning variable (also a categorical variable, controls faceting).</p>
</td></tr>
<tr><td><code id="ShadowPlot_+3A_title">title</code></td>
<td>
<p>title to place on plot.</p>
</td></tr>
<tr><td><code id="ShadowPlot_+3A_...">...</code></td>
<td>
<p>no unnamed argument, added to force named binding of later arguments.</p>
</td></tr>
<tr><td><code id="ShadowPlot_+3A_monochrome">monochrome</code></td>
<td>
<p>logical: if TRUE, all facets filled with same color</p>
</td></tr>
<tr><td><code id="ShadowPlot_+3A_palette">palette</code></td>
<td>
<p>character: if monochrome==FALSE, name of brewer color palette (can be NULL)</p>
</td></tr>
<tr><td><code id="ShadowPlot_+3A_fillcolor">fillcolor</code></td>
<td>
<p>character: if monochrome==TRUE, name of fill color for bars</p>
</td></tr>
<tr><td><code id="ShadowPlot_+3A_ncol">ncol</code></td>
<td>
<p>numeric: number of columns in facet_wrap.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This plot enables comparisons of subpopulation totals across both
<code>condvar</code> and <code>refinevar</code> simultaneously.
</p>
<p>By default, the facet plots are arranged in a single column. This can be changed
with the optional <code>ncol</code> argument.
</p>
<p>If <code>palette</code> is NULL, and <code>monochrome</code> is FALSE, plot colors will be chosen from the default ggplot2 palette. Setting <code>palette</code> to NULL
allows the user to choose a non-Brewer palette, for example with <code><a href="ggplot2.html#topic+scale_manual">scale_fill_manual</a></code>.
For consistency with previous releases, <code>ShadowPlot</code> defaults to <code>monochrome = TRUE</code>, while
<code><a href="#topic+ShadowHist">ShadowHist</a></code> defaults to <code>monochrome = FALSE</code>.
</p>
<p>Please see here for some interesting discussion <a href="https://drsimonj.svbtle.com/plotting-background-data-for-groups-with-ggplot2">https://drsimonj.svbtle.com/plotting-background-data-for-groups-with-ggplot2</a>.
</p>


<h3>Value</h3>

<p>a ggplot2 bar chart counting examples grouped by condvar, faceted by refinevar.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
if (requireNamespace('data.table', quietly = TRUE)) {
	# don't multi-thread during CRAN checks
		data.table::setDTthreads(1)
}

ShadowPlot(mtcars, "carb", "cyl",
           title = "Number of example cars by carb and cyl counts")

if (FALSE) {
# colorcode the facets
ShadowPlot(mtcars, "carb", "cyl",
           monochrome = FALSE,
           title = "Number of example cars by carb and cyl counts")
}

</code></pre>

<hr>
<h2 id='simulate_aes_string'>Simulate the deprecated <code>ggplot2::aes_string()</code>.</h2><span id='topic+simulate_aes_string'></span>

<h3>Description</h3>

<p>Use to allow replacing code of the form <code>ggplot2::aes_string(...)</code>
with code of the form <code>ggplot2::aes(!!!simulate_aes_string(...))</code>.
Purpose is to get out of the way of the deprecation and possible future removal of <code>ggplot2::aes_string()</code>.
Inspired by the research of <a href="https://stackoverflow.com/a/74424353/6901725">https://stackoverflow.com/a/74424353/6901725</a>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>simulate_aes_string(...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="simulate_aes_string_+3A_...">...</code></td>
<td>
<p>named string arguments to turn into symbols using 'rlang::data_sym()'.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>some rlang NSE that simulates string values at great complexity (but needed for newer ggplot2()).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
if (requireNamespace('data.table', quietly = TRUE)) {
	# don't multi-thread during CRAN checks
		data.table::setDTthreads(1)
}

d &lt;- data.frame(x = c(1, 2, 3), y = c(4, 5, 6))
xvar &lt;- 'x'  # the idea is, this is passed in and not known at coding time
yvar &lt;- 'y'
# what we want:
#  ggplot2::ggplot(data = d, mapping = ggplot2::aes_string(x = xvar, y = yvar)) +
#     ggplot2::geom_point()
# The required "tidy evaluation ideoms[sic] with `aes()`".
ggplot2::ggplot(data = d, mapping = ggplot2::aes(!!!simulate_aes_string(x = xvar, y = yvar))) +
   ggplot2::geom_point()

</code></pre>

<hr>
<h2 id='ThresholdPlot'>Plot classifier metrics as a function of thresholds.</h2><span id='topic+ThresholdPlot'></span>

<h3>Description</h3>

<p>Plot classifier metrics as a function of thresholds.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ThresholdPlot(
  frame,
  xvar,
  truthVar,
  title,
  ...,
  metrics = c("sensitivity", "specificity"),
  truth_target = TRUE,
  points_to_plot = NULL,
  monochrome = TRUE,
  palette = "Dark2",
  linecolor = "black"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ThresholdPlot_+3A_frame">frame</code></td>
<td>
<p>data frame to get values from</p>
</td></tr>
<tr><td><code id="ThresholdPlot_+3A_xvar">xvar</code></td>
<td>
<p>column of scores</p>
</td></tr>
<tr><td><code id="ThresholdPlot_+3A_truthvar">truthVar</code></td>
<td>
<p>column of true outcomes</p>
</td></tr>
<tr><td><code id="ThresholdPlot_+3A_title">title</code></td>
<td>
<p>title to place on plot</p>
</td></tr>
<tr><td><code id="ThresholdPlot_+3A_...">...</code></td>
<td>
<p>no unnamed argument, added to force named binding of later arguments.</p>
</td></tr>
<tr><td><code id="ThresholdPlot_+3A_metrics">metrics</code></td>
<td>
<p>metrics to be computed. See Details for the list of allowed metrics</p>
</td></tr>
<tr><td><code id="ThresholdPlot_+3A_truth_target">truth_target</code></td>
<td>
<p>truth value considered to be positive.</p>
</td></tr>
<tr><td><code id="ThresholdPlot_+3A_points_to_plot">points_to_plot</code></td>
<td>
<p>how many data points to use for plotting. Defaults to NULL (all data)</p>
</td></tr>
<tr><td><code id="ThresholdPlot_+3A_monochrome">monochrome</code></td>
<td>
<p>logical: if TRUE, all subgraphs plotted in same color</p>
</td></tr>
<tr><td><code id="ThresholdPlot_+3A_palette">palette</code></td>
<td>
<p>character: if monochrome==FALSE, name of brewer color palette (can be NULL)</p>
</td></tr>
<tr><td><code id="ThresholdPlot_+3A_linecolor">linecolor</code></td>
<td>
<p>character: if monochrome==TRUE, name of line color</p>
</td></tr>
</table>


<h3>Details</h3>

<p>By default, <code>ThresholdPlot</code> plots sensitivity and specificity of a
a classifier as a function of the decision threshold.
Plotting sensitivity-specificity (or other metrics) as a function of classifier score helps
identify a score threshold that achieves an acceptable tradeoff among desirable
properties.
</p>
<p><code>ThresholdPlot</code> can plot a number of metrics. Some of the metrics are redundant,
in keeping with the customary terminology of various analysis communities.
</p>

<ul>
<li><p>sensitivity: fraction of true positives that were predicted to be true (also known as the true positive rate)
</p>
</li>
<li><p>specificity: fraction of true negatives to all negatives (or 1 - false_positive_rate)
</p>
</li>
<li><p>precision: fraction of predicted positives that are true positives
</p>
</li>
<li><p>recall: same as sensitivity or true positive rate
</p>
</li>
<li><p>accuracy: fraction of items correctly decided
</p>
</li>
<li><p>false_positive_rate: fraction of negatives predicted to be true over all negatives
</p>
</li>
<li><p>true_positive_rate: fraction of positives predicted to be true over all positives
</p>
</li>
<li><p>false_negative_rate: fraction of positives predicted to be all false over all positives
</p>
</li>
<li><p>true_negative_rate: fraction negatives predicted to be false over all negatives
</p>
</li></ul>

<p>For example, plotting sensitivity/false_positive_rate as functions of threshold will &quot;unroll&quot; an ROC Plot.
</p>
<p><code>ThresholdPlot</code> can also plot distribution diagnostics about the scores:
</p>

<ul>
<li><p>fraction: the fraction of datums that scored greater than a given threshold
</p>
</li>
<li><p>cdf: CDF or <code>1 - fraction</code>; the fraction of datums that scored less than a given threshold
</p>
</li></ul>

<p>Plots are in a single column, in the order specified by <code>metrics</code>.
</p>
<p><code>points_to_plot</code> specifies the approximate number of datums used to
create the plots as an absolute count; for example setting <code>points_to_plot = 200</code> uses
approximately 200 points, rather than the entire data set. This can be useful when
visualizing very large data sets.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+PRTPlot">PRTPlot</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
if (requireNamespace('data.table', quietly = TRUE)) {
	# don't multi-thread during CRAN checks
		data.table::setDTthreads(1)
}

# data with two different regimes of behavior
d &lt;- rbind(
  data.frame(
    x =  rnorm(1000),
    y = sample(c(TRUE, FALSE), prob = c(0.02, 0.98), size = 1000, replace = TRUE)),
  data.frame(
    x =  rnorm(200) + 5,
    y = sample(c(TRUE, FALSE), size = 200, replace = TRUE))
)

# Sensitivity/Specificity examples
ThresholdPlot(d, 'x', 'y',
   title = 'Sensitivity/Specificity',
   metrics = c('sensitivity', 'specificity'),
   truth_target = TRUE)
if(FALSE) {
MetricPairPlot(d, 'x', 'y',
   x_metric = 'false_positive_rate',
   y_metric = 'true_positive_rate',
   truth_target = TRUE,
   title = 'ROC equivalent')
ROCPlot(d, 'x', 'y',
   truthTarget = TRUE,
   title = 'ROC example')

# Precision/Recall examples
ThresholdPlot(d, 'x', 'y',
   title = 'precision/recall',
   metrics = c('recall', 'precision'),
   truth_target = TRUE)
MetricPairPlot(d, 'x', 'y',
   x_metric = 'recall',
   y_metric = 'precision',
   title = 'recall/precision',
   truth_target = TRUE)
PRPlot(d, 'x', 'y',
   truthTarget = TRUE,
   title = 'p/r plot')
}

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
