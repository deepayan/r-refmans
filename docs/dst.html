<!DOCTYPE html><html lang="en"><head><title>Help for package dst</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {dst}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#dst-package'><p>Manipulation and combination of belief functions</p></a></li>
<li><a href='#addTobca'><p>Add some elements of 0 mass to an existing basic chance assignment.</p></a></li>
<li><a href='#ads'><p>The Captain's Problem. <code>ads</code>: Relation between variables Arrival (A), Departure delay (D) and Sailing delay (S)</p></a></li>
<li><a href='#bca'><p>Basic chance assignment mass function</p></a></li>
<li><a href='#bcaNorm'><p>Computer norm between two basic chance assignment objects</p></a></li>
<li><a href='#bcaPrint'><p>Simple printing of the <code>tt</code> matrix and mass values of a basic chance assignment (bca)</p></a></li>
<li><a href='#bcaPrintLarge'><p>Print summary statistics of large mass functions</p></a></li>
<li><a href='#bcaRel'><p>Representation of a mass function in a product space</p></a></li>
<li><a href='#bcaTrunc'><p>Truncation of a basic chance assignment mass function</p></a></li>
<li><a href='#belplau'><p>Calculation of the degrees of Belief and Plausibility of a basic chance assignment (bca).</p></a></li>
<li><a href='#belplauEval'><p>Evaluate A, B errors</p></a></li>
<li><a href='#belplauH'><p>Calculate belief, disbelief, unknown, plausibility, plausibility ratio</p></a></li>
<li><a href='#belplauHLogsumexp'><p>Calculate belief, disbelief, unknown, plausibility, plausibility ratio with logsumexp</p></a></li>
<li><a href='#belplauHQQ'><p>Compute belief, disbelief, unknown, plausibility, plausibility ratio based on commonality function</p></a></li>
<li><a href='#belplauLogsumexp'><p>Calculation of the degrees of Belief and Plausibility of a basic chance assignment (bca) with logsumexp.</p></a></li>
<li><a href='#belplauPlot'><p>Plot belplau matrix</p></a></li>
<li><a href='#captain_result'><p>The Captain's Problem. <code>swr</code>: Result of the evaluation of the Hypergraph at node Arrival (A)</p></a></li>
<li><a href='#commonality'><p>Compute qq from tt</p></a></li>
<li><a href='#decode'><p>Find the value in base 10 of a number coded in another base</p></a></li>
<li><a href='#dlfm'><p>The Captain's Problem. <code>dlfm</code>: Relation between variables Departure delay (D), Loading delay (L), Forecast of the weather (F), Maintenance delay (M)</p></a></li>
<li><a href='#DoSSnames'><p>Construct subsets names from column names of a tt matrix</p></a></li>
<li><a href='#dotprod'><p>Generalized inner product of two matrices</p></a></li>
<li><a href='#doubles'><p>Remove duplicate rows in a two-dimensional table.</p></a></li>
<li><a href='#dsrwon'><p>Combination of two mass functions</p></a></li>
<li><a href='#dsrwonLogsumexp'><p>Combination of two mass functions with logsumexp</p></a></li>
<li><a href='#elim'><p>Reduction of a relation</p></a></li>
<li><a href='#encode'><p>Convert a value to its representation in another chosen base</p></a></li>
<li><a href='#extFrame'><p>Extension of the frame of discernment of a variable</p></a></li>
<li><a href='#extmin'><p>Extension of a relation</p></a></li>
<li><a href='#fw'><p>The Captain's Problem. <code>fw</code>: Relation between variables Forecast of the weather (F) and  Weather at sea (W)</p></a></li>
<li><a href='#inters'><p>Intersection of two tables of propositions</p></a></li>
<li><a href='#intersBySSName'><p>Intersect two vectors of ssnames</p></a></li>
<li><a href='#logsum'><p>Adding small probabilities</p></a></li>
<li><a href='#marrayToMatrix'><p>Transformation of an array data to its matrix representation</p></a></li>
<li><a href='#matrixToMarray'><p>Transformation of the tt matrix of a relation</p></a></li>
<li><a href='#mFromMarginal'><p>Construct m vector of a bca from marginal probabilities</p></a></li>
<li><a href='#mFromQQ'><p>Construct a mass vector from qq function.</p></a></li>
<li><a href='#mFromQQRecursive'><p>Construct a mass vector from qq function and ttmatrix of focal elements recursively.</p></a></li>
<li><a href='#mobiusInvHQQ'><p>Mobius inversion of commonality function</p></a></li>
<li><a href='#mrf'><p>The Captain's Problem. <code>mrf</code>: Relation between variables No Maintenance (M = false) and  Repairs at sea (R)</p></a></li>
<li><a href='#mrt'><p>The Captain's Problem. <code>mrt</code>: Relation between variables Maintenance done (M = true) and  Repairs at sea (R)</p></a></li>
<li><a href='#nameCols'><p>Naming the columns of the <code>tt</code> matrix</p></a></li>
<li><a href='#nameCols_prod'><p>Naming the columns of the <code>tt</code> matrix of a product space</p></a></li>
<li><a href='#nameRows'><p>Combining the column names of a matrix to construct names for the rows</p></a></li>
<li><a href='#nzdsr'><p>Normalization of a basic chance assignment</p></a></li>
<li><a href='#nzdsrLogsumexp'><p>Normalization of a basic chance assignment with logsumexp</p></a></li>
<li><a href='#peeling'><p>The peeling algorithm</p></a></li>
<li><a href='#plautrans'><p>Plausibility transformation of the singletons of a frame</p></a></li>
<li><a href='#productSpace'><p>Product space representation of a relation</p></a></li>
<li><a href='#reduction'><p>Summary of a vector for any operator.</p></a></li>
<li><a href='#shape'><p>Obtain dimensions of an array or length of a vector with a single command</p></a></li>
<li><a href='#swr'><p>The Captain's Problem. <code>swr</code>: Relation between variables Sailing delay (S), Weather at sea (W), and Repairs at sea (R)</p></a></li>
<li><a href='#tabresul'><p>Prepare a table of results</p></a></li>
<li><a href='#ttmatrix'><p>Construct a description matrix from a list of subsets names.</p></a></li>
<li><a href='#ttmatrixFromMarginal'><p>Construct tt matrix of a bca from marginal probabilities</p></a></li>
<li><a href='#ttmatrixFromQQ'><p>Construct a description matrix from qq function.</p></a></li>
<li><a href='#ttmatrixPartition'><p>Create partition matrix</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Using the Theory of Belief Functions</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>Version:</td>
<td>1.8.0</td>
</tr>
<tr>
<td>Date:</td>
<td>2024-08-24</td>
</tr>
<tr>
<td>Description:</td>
<td>Using the Theory of Belief Functions for evidence calculus. Basic probability assignments, or mass functions, can be defined on the subsets of a set of possible values and combined. A mass function can be extended to a larger frame. Marginalization, i.e. reduction to a smaller frame can also be done. These features can be combined to analyze small belief networks and take into account situations where information cannot be satisfactorily described by probability distributions.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/RAPLER/dst-1/issues">https://github.com/RAPLER/dst-1/issues</a></td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.3.2</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.5.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>dplyr, ggplot2, tidyr, Matrix, methods, parallel, rlang, utils</td>
</tr>
<tr>
<td>Suggests:</td>
<td>igraph, knitr, rmarkdown, tidyverse, testthat</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-09-03 03:57:14 UTC; garyzhubc</td>
</tr>
<tr>
<td>Author:</td>
<td>Peiyuan Zhu [aut, cre],
  Claude Boivin [aut]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Peiyuan Zhu &lt;garyzhubc@gmail.com&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-09-03 04:20:06 UTC</td>
</tr>
</table>
<hr>
<h2 id='dst-package'>Manipulation and combination of belief functions</h2><span id='topic+dst'></span><span id='topic+dst-package'></span>

<h3>Description</h3>

<p>Package dst allows you to make basic probability assignments on subsets of a set of possibilities (events) and combine these events with Dempster's rule of combination.
</p>


<h3>Details</h3>

<p>The main operations that can be done are: </p>

<ul>
<li><p> definition of a basic chance assignment (bca) distribution on a variable,
</p>
</li>
<li><p> combination of two bca's defined on the same variable,
</p>
</li>
<li><p> definition of a bca which establish a relation between two or more variables,
</p>
</li>
<li><p> extension of a bca,
</p>
</li>
<li><p> marginalization of a bca. 
</p>
</li></ul>



<h3>Author(s)</h3>

<p>Claude Boivin &lt;webapp.cb@gmail.com&gt; Peiyuan Zhu &lt;garyzhubc@gmail.com&gt;
</p>


<h3>See Also</h3>

<p>Useful links:
</p>

<ul>
<li><p> Report bugs at <a href="https://github.com/RAPLER/dst-1/issues">https://github.com/RAPLER/dst-1/issues</a>
</p>
</li></ul>


<hr>
<h2 id='addTobca'>Add some elements of 0 mass to an existing basic chance assignment.</h2><span id='topic+addTobca'></span>

<h3>Description</h3>

<p>Given a previously defined basic chance assignment (bca), the user may want to add some elements of the set of possible values or some subsets, even if they have zero mass value. This feature is useful, for example, to examine the measure of plausibility of these elements or subsets of zero mass value.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>addTobca(x, tt, f)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="addTobca_+3A_x">x</code></td>
<td>
<p>A basic chance assignment (see <code><a href="#topic+bca">bca</a></code>).</p>
</td></tr>
<tr><td><code id="addTobca_+3A_tt">tt</code></td>
<td>
<p>A matrix constructed in a boolean style (0,1) or a boolean matrix. The number of columns of the matrix <code>tt</code> must match the number of columns of the <code>tt</code> matrix of <code>x</code> (see <code><a href="#topic+bca">bca</a></code>). Each row of the matrix identify a subset of the set of possible values.</p>
</td></tr>
<tr><td><code id="addTobca_+3A_f">f</code></td>
<td>
<p>Deprecated. Old name for <code>tt</code> matrix.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>x The original basic chance assignment <code>x</code> augmented with the added subsets defined by <code>tt</code>.
</p>


<h3>Author(s)</h3>

<p>Claude Boivin
</p>


<h3>Examples</h3>

<pre><code class='language-R'> 
y &lt;- bca(tt = matrix(c(1,0,0,1,1,1),nrow=2, byrow = TRUE), 
m = c(0.6, 0.4),  cnames = c("a", "b", "c"), idvar = 1)
addTobca(y, matrix(c(0,1,0,0,0,1, 0,1,1), nrow = 3, byrow = TRUE))
x &lt;- bca(tt = matrix(c(0,1,1,1,1,0,1,1,1),nrow=3, 
byrow = TRUE), m=c(0.2,0.5, 0.3), 
cnames = c("a", "b", "c"), idvar = 1)
xy &lt;- dsrwon(x,y)
xy1 &lt;- addTobca(nzdsr(xy), matrix(c(0,1,0,0,0,1), nrow = 2, byrow = TRUE))
xy1
# add all singletons to a bca
addTobca(x, tt = diag(rep(1, ncol(x$tt) ) )  ) 

</code></pre>

<hr>
<h2 id='ads'>The Captain's Problem. <code>ads</code>: Relation between variables Arrival (A), Departure delay (D) and Sailing delay (S)</h2><span id='topic+ads'></span>

<h3>Description</h3>

<p>This dataset is the <code>tt</code> matrix establishing the relation A = D + S, where A = 0:6, D = 0:3 and S = 0:3. The subset made of all the triplets (a,d,s) of (A x D x S) where a = d + s is true has a mass value of 1. To construct the <code>tt</code> matrix, we put the variables A, D, S side by side, as in a truth table representation. Each triplet of the subset is described by a row of the matrix as a vector of zeros and ones.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ads
</code></pre>


<h3>Format</h3>

<p>An integer matrix with 18 rows and 17 columns
</p>

<dl>
<dt>[1, c(1,2)]</dt><dd><p>value = 0, not used</p>
</dd>
<dt>[1, 3:17]</dt><dd><p>Identification numbers of the three variables. Column 3 to 9: variable 1; column 10 to 13: variable 2; column 14 to 17: variable 3.</p>
</dd>
<dt>nospec</dt><dd><p>identification number of the specification</p>
</dd>
<dt>m</dt><dd><p>the value of the specification, a number between 0 and 1</p>
</dd>
<dt>6</dt><dd><p>1 if 6 is part of the specification, 0 otherwise</p>
</dd>
<dt>5</dt><dd><p>1 if 5 is part of the specification, 0 otherwise</p>
</dd>
<dt>4</dt><dd><p>1 if 4 is part of the specification, 0 otherwise</p>
</dd>
<dt>3</dt><dd><p>1 if 3 is part of the specification, 0 otherwise</p>
</dd>
<dt>2</dt><dd><p>1 if 2 is part of the specification, 0 otherwise</p>
</dd>
<dt>1</dt><dd><p>1 if 1 is part of the specification, 0 otherwise</p>
</dd>
<dt>0</dt><dd><p>1 if 0 is part of the specification, 0 otherwise</p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>Claude Boivin, Stat.ASSQ
</p>


<h3>Source</h3>

<p>Almond, R.G. [1988] Fusion and Propagation in Graphical Belief Models. Computing Science and Statistics: Proceedings of the 20th Symposium on the Interface. Wegman, Edward J., Gantz, Donald T. and Miller, John J. (ed.). American Statistical Association, Alexandria, Virginia. pp 365&ndash;370.
</p>

<hr>
<h2 id='bca'>Basic chance assignment mass function</h2><span id='topic+bca'></span><span id='topic+bpa'></span>

<h3>Description</h3>

<p>Function <code>bca</code> is used to define subsets of a finite set <code class="reqn">\Theta</code> of possible values and to assign their corresponding mass value.<br />
The set <code class="reqn">\Theta</code> is called the frame of discernment. Each subset <code class="reqn">A</code> of  <code class="reqn">Theta</code> with a positive mass value is called a focal element or a proposition. The associated mass value is a number of the <code>(0,1]</code> interval, called &quot;basic chance assignment&quot; (the basic probability assignment of Shafer's book). All other subsets that have not received a positive mass value are assumed to have a mass value of zero.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bca(
  tt = NULL,
  m,
  qq = NULL,
  fzt = FALSE,
  include_all = FALSE,
  cnames = NULL,
  con = NULL,
  ssnames = NULL,
  idvar = NULL,
  infovar = NULL,
  varnames = NULL,
  valuenames = NULL,
  inforel = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="bca_+3A_tt">tt</code></td>
<td>
<p>Mandatory. A (0,1)-matrix or a boolean matrix. The number of columns must match the number of elements (values) of the frame of discernment <code class="reqn">\Theta</code>. Each row is a subset of <code class="reqn">\Theta</code>. The last row is the frame <code class="reqn">\Theta</code>, represented by a vector of 1's.</p>
</td></tr>
<tr><td><code id="bca_+3A_m">m</code></td>
<td>
<p>A numeric vector of length equal to the number of rows of the matrix  <code>tt</code>. Values of <code>m</code> must lie in the interval <code>(0,1]</code> and must add to one. The mass <code>m(k)</code> represents the chance value allotted to the proposition represented by the row <code>k</code> of the matrix <code>tt</code>.</p>
</td></tr>
<tr><td><code id="bca_+3A_qq">qq</code></td>
<td>
<p>Commonality functions from the frame of discernment to <code class="reqn">[0,1]</code></p>
</td></tr>
<tr><td><code id="bca_+3A_fzt">fzt</code></td>
<td>
<p>= FALSE Whether to use Fast Zeta Transform to construct commonality functions</p>
</td></tr>
<tr><td><code id="bca_+3A_include_all">include_all</code></td>
<td>
<p>= FALSE Put TRUE to include all elements with 0 mass in the bca.</p>
</td></tr>
<tr><td><code id="bca_+3A_cnames">cnames</code></td>
<td>
<p>A character vector containing the names of the elements of the frame of discernment <code class="reqn">\Theta</code>. The length must be equal to the number of elements of <code class="reqn">\Theta</code>. The names are first searched in the <code>valuenames</code> parameter. If NULL, column names of the matrix <code>tt</code> are taken if present. Otherwise, names are generated.</p>
</td></tr>
<tr><td><code id="bca_+3A_con">con</code></td>
<td>
<p>The measure of conflict can be provided. 0 by default.</p>
</td></tr>
<tr><td><code id="bca_+3A_ssnames">ssnames</code></td>
<td>
<p>A list of subsets names which will be obtained from the column names of the tt matrix.</p>
</td></tr>
<tr><td><code id="bca_+3A_idvar">idvar</code></td>
<td>
<p>The number given to the variable. A number is necessary to manage relations between variables  and make computations on a graph. 0 if omitted.</p>
</td></tr>
<tr><td><code id="bca_+3A_infovar">infovar</code></td>
<td>
<p>A two-column matrix containing variable identification numbers and the number of elements of the variable. Generated if omitted.</p>
</td></tr>
<tr><td><code id="bca_+3A_varnames">varnames</code></td>
<td>
<p>The name of the variable. Generated if omitted.</p>
</td></tr>
<tr><td><code id="bca_+3A_valuenames">valuenames</code></td>
<td>
<p>A list of the names of the variables with the name of the elements of their frame of discernment.</p>
</td></tr>
<tr><td><code id="bca_+3A_inforel">inforel</code></td>
<td>
<p>Not used here. Defined within function <code><a href="#topic+bcaRel">bcaRel</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>There is two ways of defining the bca: a (0,1) matrix or a list of subsets labels.
</p>


<h3>Value</h3>

<p>y An object of class <code>bcaspec</code> called a bca for &quot;basic chance assignment&quot;: </p>

<ul>
<li><p> tt  The table of focal elements. Rownames of the matrix of focal elements are generated from the column names of the elements of the frame. See <code><a href="#topic+nameRows">nameRows</a></code> for details.
</p>
</li>
<li><p> qq  Commonality functions from the frame of discernment to <code class="reqn">[0,1]</code>
</p>
</li>
<li><p> spec  A two column matrix. First column contains numbers given to the subsets, 1 to  <code>nrow(tt)</code>. Second column contains the mass values of the subsets. 
</p>
</li>
<li><p> con  The measure of conflict.
</p>
</li>
<li><p> infovar  The number of the variable and the size of the frame of discernment.
</p>
</li>
<li><p> varnames  The name of the variable.
</p>
</li>
<li><p> valuenames  A list of length 1 consisting of the name of the variable with the names of the elements of the frame of discernment (the column names of the <code>tt</code> matrix).
</p>
</li>
<li><p> ssnames A list of subsets names done from the column names of the tt matrix.
</p>
</li>
<li><p> inforel  Set at 0. used in function <code><a href="#topic+bcaRel">bcaRel</a></code>.
</p>
</li></ul>



<h3>Author(s)</h3>

<p>Claude Boivin
</p>


<h3>References</h3>


<ul>
<li><p> Shafer, G., (1976). A Mathematical Theory of Evidence. Princeton University Press, Princeton, New Jersey, p. 38: Basic probability assignment.
</p>
</li>
<li><p> Guan, J. W. and Bell, D. A., (1991). Evidence Theory and its Applications. Elsevier Science Publishing company inc., New York, N.Y., p. 29: Mass functions and belief functions 
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>tt&lt;- t(matrix(c(1,0,1,1),ncol = 2))
m&lt;- c(.9,.1)
cnames &lt;- c("yes","no")
bca(tt, m)
bca(tt, m, cnames)
tt1&lt;- t(matrix(c(1,0,1,1),ncol = 2))
colnames(tt1) &lt;- c("yes", "no")
m &lt;- c(.9, .1)
bca(tt=tt1, m, idvar = 1)
x &lt;- bca(tt=matrix(c(0,1,1,1,1,0,1,1,1),nrow = 3, 
byrow = TRUE), m = c(0.2,0.5, 0.3), include_all = TRUE,
cnames = c("a", "b", "c"), idvar = 1)
y &lt;- bca(tt=matrix(c(1,0,0,1,1,1),nrow = 2, 
byrow = TRUE), m = c(0.6,0.4), 
cnames = c("a", "b", "c"),varnames = "y", idvar = 1)
vacuous &lt;- bca(matrix(c(1,1,1), nrow = 1), m = 1, cnames = c("a","b","c"), ssnames = c("a","b","c"))
</code></pre>

<hr>
<h2 id='bcaNorm'>Computer norm between two basic chance assignment objects</h2><span id='topic+bcaNorm'></span>

<h3>Description</h3>

<p>Computer norm between two basic chance assignment objects
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bcaNorm(x, y, p = 1)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="bcaNorm_+3A_x">x</code></td>
<td>
<p>A bca to evaluate norm.</p>
</td></tr>
<tr><td><code id="bcaNorm_+3A_y">y</code></td>
<td>
<p>A bca to evaluate norm.</p>
</td></tr>
<tr><td><code id="bcaNorm_+3A_p">p</code></td>
<td>
<p>exponent parameter of the norm</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a number of norm evaluation
</p>


<h3>Author(s)</h3>

<p>Peiyuan Zhu
</p>


<h3>Examples</h3>

<pre><code class='language-R'>y1 &lt;- bca(tt = matrix(c(0,1,1,1,1,0,1,1,1),nrow = 3, 
byrow = TRUE), m = c(0.2,0.5, 0.3),
cnames = c("a", "b", "c"),
varnames = "x", idvar = 1)
y2 &lt;- bca(tt = matrix(c(1,0,0,1,1,1),nrow = 2, 
byrow = TRUE), m = c(0.6, 0.4),  
cnames = c("a", "b", "c"),  
varnames = "x", idvar = 1)
y1y2&lt;-dsrwon(y1,y2)
bcaNorm(y1y2,y1)
</code></pre>

<hr>
<h2 id='bcaPrint'>Simple printing of the <code>tt</code> matrix and mass values of a basic chance assignment (bca)</h2><span id='topic+bcaPrint'></span>

<h3>Description</h3>

<p>This utility function does a simple printing of a bca
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bcaPrint(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="bcaPrint_+3A_x">x</code></td>
<td>
<p>A list of class bcaspec.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A table of subsets with their associated mass. Subsets are identified by row names.
</p>


<h3>Author(s)</h3>

<p>Claude Boivin
</p>


<h3>Examples</h3>

<pre><code class='language-R'>z &lt;- bca(tt = matrix(c(0,1,1,1,1,0,1,1,1),nrow = 3, 
byrow = TRUE), m = c(0.2,0.5, 0.3), 
cnames = c("a", "b", "c"), idvar = 1)
bcaPrint(z)
</code></pre>

<hr>
<h2 id='bcaPrintLarge'>Print summary statistics of large mass functions</h2><span id='topic+bcaPrintLarge'></span>

<h3>Description</h3>

<p>Print summary statistics of large mass functions
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bcaPrintLarge(
  x,
  info_list = "all",
  num_top_mass = 10,
  cut_width_size = 10,
  cut_width_m = 1e-05
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="bcaPrintLarge_+3A_x">x</code></td>
<td>
<p>A basic chance assignment (see <code><a href="#topic+bca">bca</a></code>).</p>
</td></tr>
<tr><td><code id="bcaPrintLarge_+3A_info_list">info_list</code></td>
<td>
<p>=&quot;all&quot; statistics to be printed in a vector of characters
</p>

<ul>
<li><p> &quot;all&quot;: everything
</p>
</li>
<li><p> &quot;basic_subset_stat&quot;: basic statistics of subsets
</p>
</li>
<li><p> &quot;comp_subset_stat&quot;: more comprehensive statistics of subsets
</p>
</li>
<li><p> &quot;basic_mass_stat&quot;: basic statistics of masses
</p>
</li>
<li><p> &quot;comp_mass_stat&quot;: more comprehensive statistics of masses
</p>
</li>
<li><p> &quot;basic_joint_stat&quot;: basic statistics of masses vs subsets
</p>
</li>
<li><p> &quot;comp_joint_stat&quot;: more comprehensive statistics of masses vs subsets
</p>
</li></ul>
</td></tr>
<tr><td><code id="bcaPrintLarge_+3A_num_top_mass">num_top_mass</code></td>
<td>
<p>= 10 number of top masses to be printed</p>
</td></tr>
<tr><td><code id="bcaPrintLarge_+3A_cut_width_size">cut_width_size</code></td>
<td>
<p>width of a cut among subset sizes</p>
</td></tr>
<tr><td><code id="bcaPrintLarge_+3A_cut_width_m">cut_width_m</code></td>
<td>
<p>width of a cut among masses</p>
</td></tr>
</table>


<h3>Value</h3>


<ul>
<li><p> table of basic and more comprehensive statistics of subsets
</p>
</li>
<li><p> table of basic and more comprehensive statistics of masses
</p>
</li>
<li><p> table of basic and more comprehensive statistics of masses vs subsets
</p>
</li></ul>



<h3>Author(s)</h3>

<p>Peiyuan Zhu
</p>


<h3>Examples</h3>

<pre><code class='language-R'> if (requireNamespace("tidyverse", quietly = TRUE) ) { 
 ## library(tidyverse)
x &lt;- bca(tt = matrix(c(1,1,0,1,1,1), nrow = 2, byrow = TRUE), m = c(0.8, 0.2), cnames = c(1,2,3))
bcaPrintLarge(x)
}
</code></pre>

<hr>
<h2 id='bcaRel'>Representation of a mass function in a product space</h2><span id='topic+bcaRel'></span>

<h3>Description</h3>

<p>This function is used to represent a relation between two or more variables in their product space <code>P</code>. The relation can be described by more than one subset of <code>P</code>. Each subset can also  include more than one element. Complete disjunctive coding is used to represent one element in the input matrix of the function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bcaRel(
  tt,
  spec,
  infovar,
  varnames,
  valuenames,
  relnb = NULL,
  infovarnames,
  infovaluenames
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="bcaRel_+3A_tt">tt</code></td>
<td>
<p>The description matrix of the subsets establishing the relation. This matrix is obtained by putting the variables side by side, as in a truth table representation. For each variable, there are as many columns as possible values. Each row of the matrix is an element of a subset. Each element is described by a sequence of 0 (absence of value of a variable) or 1 (presence of value). This forms a complete disjunctive coding. CAUTION: Variables put side by side must be ordered by their *idvar* from left to right.</p>
</td></tr>
<tr><td><code id="bcaRel_+3A_spec">spec</code></td>
<td>
<p>A two column matrix. First column: numbers assigned to the sub-assemblies. Second column: the mass values of the sub-assemblies. If the subset has more than one element, the number of the subset and its associated mass value are repeated to match the number of elements in the subset.</p>
</td></tr>
<tr><td><code id="bcaRel_+3A_infovar">infovar</code></td>
<td>
<p>A two column matrix containing variable identification numbers and the number of elements of each variable. The identification numbers must be ordered in increasing number.</p>
</td></tr>
<tr><td><code id="bcaRel_+3A_varnames">varnames</code></td>
<td>
<p>The names of the variables.</p>
</td></tr>
<tr><td><code id="bcaRel_+3A_valuenames">valuenames</code></td>
<td>
<p>A list of the names of the variables with the name of the elements of their frame of discernment.</p>
</td></tr>
<tr><td><code id="bcaRel_+3A_relnb">relnb</code></td>
<td>
<p>A number given to the relation. Set at 0 if omitted.</p>
</td></tr>
<tr><td><code id="bcaRel_+3A_infovarnames">infovarnames</code></td>
<td>
<p>Deprecated. Old name for <code>varnames</code>.</p>
</td></tr>
<tr><td><code id="bcaRel_+3A_infovaluenames">infovaluenames</code></td>
<td>
<p>Deprecated. Old name for <code>valuenames</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <code>bcaspec</code> called a bca for &quot;basic chance assignment&quot;. This is a list containing the following components:  </p>

<ul>
<li><p> con The measure of conflict.
</p>
</li>
<li><p> tt The resulting table of subsets. Rownames of the matrix of subsets are generated from the column names of the elements of the product frame. See <code><a href="#topic+nameRows">nameRows</a></code> for details.
</p>
</li>
<li><p> spec The resulting two-column matrix of specification numbers with associated mass values.
</p>
</li>
<li><p> infovar The two-column matrix of variables number and size given in the input data.
</p>
</li>
<li><p> valuenames A list of the names of the variables with the name of the elements of their frame of discernment.
</p>
</li>
<li><p> inforel A two-column matrix containing the relation number and the depth (number of variables) of the relation.
</p>
</li></ul>



<h3>Author(s)</h3>

<p>Claude Boivin
</p>


<h3>Examples</h3>

<pre><code class='language-R'># A logical implication rule
# A typical relation between two variables is the
# logical implication a -&gt; b. Let us suppose
# that a stands for Rain: {yes, no} and b stands for
# Roadworks: {yes, no}. From experience,
# I am 75 % sure that there will be RoadWorks if there is no rain.

 # 1. The tt table of the logical implication
 ttrwf &lt;- matrix(c(0,1,1,0,1,0,1,0,1,0,0,1,1,1,1,1),
 nrow = 4, byrow = TRUE, 
 dimnames = list(NULL, c("rWdy", "rWdn", "Ry", "Rn")) )
 
 # 2. The mass distribution
 specrw &lt;-  matrix(c(1,1,1,2,0.75,0.75,0.75,0.25), ncol = 2, 
 dimnames = list(NULL, c("specnb", "mass")))
  
 # 3. Variables numbers and sizes
 inforw &lt;- matrix(c(4,5,2,2), ncol = 2, 
 dimnames = list(NULL, c("varnb", "size")) )
bcaRel(tt = ttrwf, spec = specrw, infovar = inforw,
 varnames = c("RdWorks", "Rain"), relnb = 6)

</code></pre>

<hr>
<h2 id='bcaTrunc'>Truncation of a basic chance assignment mass function</h2><span id='topic+bcaTrunc'></span>

<h3>Description</h3>

<p>When working with large frames of discernment, the bca resulting of repeated application of Dempster's Rule of Combination can become big. One way to handle this situation could be to group subsets whose mass is less than a small treshold value. The function <code>bcaTrunc</code> serves this purpose to reduce a large bca to its main elements.<br />
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bcaTrunc(x, seuil, use_ssnames = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="bcaTrunc_+3A_x">x</code></td>
<td>
<p>A bca to truncate.</p>
</td></tr>
<tr><td><code id="bcaTrunc_+3A_seuil">seuil</code></td>
<td>
<p>A treshold value</p>
</td></tr>
<tr><td><code id="bcaTrunc_+3A_use_ssnames">use_ssnames</code></td>
<td>
<p>Put TRUE to use ssnames parameteer instead of description matrix. Default = FALSE.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>tr_x The bca object truncated.
</p>


<h3>Author(s)</h3>

<p>Claude Boivin
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- bca(tt = matrix(c(0,1,0,0, 
0,0,1,1,
1,1,0,0,
1,0,1,0,
0,1,1,0,
1,1,1,1),ncol=4, byrow = TRUE), m = c(0.2, 0.5, 0.06, 0.04, 0.03, 0.17),
cnames = c("a", "b", "c", "d"))
bcaPrint(x)
tr_x &lt;- bcaTrunc(x, seuil = 0.1)
bcaPrint(tr_x)

</code></pre>

<hr>
<h2 id='belplau'>Calculation of the degrees of Belief and Plausibility of a basic chance assignment (bca).</h2><span id='topic+belplau'></span>

<h3>Description</h3>

<p>Degrees of Belief <code>Bel</code> and Plausibility <code>Pl</code> of the focal elements of a bca are computed. The ratio of the plausibility of a focal element against the plausibility of its contrary is also computed. Subsets with zero mass can be excluded from the calculations.<br />
</p>


<h3>Usage</h3>

<pre><code class='language-R'>belplau(x, remove = FALSE, h = NULL, fzt = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="belplau_+3A_x">x</code></td>
<td>
<p>A basic chance assignment mass function (see <code><a href="#topic+bca">bca</a></code>).</p>
</td></tr>
<tr><td><code id="belplau_+3A_remove">remove</code></td>
<td>
<p>= TRUE: Exclude subsets with zero mass.</p>
</td></tr>
<tr><td><code id="belplau_+3A_h">h</code></td>
<td>
<p>= NULL: Hypothesis to be tested. Description matrix in the same format than <code>x$tt</code></p>
</td></tr>
<tr><td><code id="belplau_+3A_fzt">fzt</code></td>
<td>
<p>= FALSE: Whether to use Fast Zeta Transform</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The degree of belief <code>Bel</code> is defined by: <br />
</p>
<p style="text-align: center;"><code class="reqn">bel(A) = Sum((m(B); B \subseteq A))</code>
</p>
<p> for every subset B of A.<br />
The degree of plausibility <code>pl</code> is defined by: <br />
</p>
<p style="text-align: center;"><code class="reqn">pl(A) = Sum[(m(B); B \cap A \neq \emptyset]</code>
</p>
<p> for every subset <code>B</code> of the frame of discernment. <br />
The plausibility ratio of a focal element <code>A</code> versus its contrary <code>not A</code> is defined by:  <code class="reqn">Pl(A)/(1-Bel(A))</code>.
</p>


<h3>Value</h3>

<p>A matrix of <code>M</code> rows by 3 columns is returned, where <code>M</code> is the number of focal elements: </p>

<ul>
<li><p> Column 1: the degree of Belief <code>bel</code>;
</p>
</li>
<li><p> Column 2: the degree of Disbellief (belief in favor of the contrary hypothesis) <code>disbel</code>;
</p>
</li>
<li><p> Column 3: the degree of Epistemic uncertainty <code>unc</code>;
</p>
</li>
<li><p> Column 4: the degree of Plausibility <code>plau</code>;
</p>
</li>
<li><p> Column 5: the Plausibility ratio <code>rplau</code>.
</p>
</li></ul>



<h3>Author(s)</h3>

<p>Claude Boivin, Peiyuan Zhu
</p>


<h3>References</h3>


<ul>
<li><p> Shafer, G., (1976). A Mathematical Theory of Evidence. Princeton University Press, Princeton, New Jersey, p. 39-43.
</p>
</li>
<li><p> Williams, P., (1990). An interpretation of Shenoy and Shafer's axioms for local computation. International Journal of Approximate Reasoning 4, pp. 225-232.
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- bca(tt = matrix(c(0,1,1,1,1,0,1,1,1),nrow = 3, 
byrow = TRUE), m = c(0.2,0.5, 0.3), 
cnames = c("a", "b", "c"), varnames = "x", idvar = 1)
belplau(x)
y &lt;- bca(tt = matrix(c(1,0,0,1,1,1),nrow = 2, 
byrow = TRUE), m = c(0.6, 0.4),  
cnames = c("a", "b", "c"),  varnames = "y", idvar = 1)
xy &lt;- nzdsr(dsrwon(x,y))
belplau(xy)
print("compare all elementary events")
xy1 &lt;- addTobca(x = xy, tt = matrix(c(0,1,0,0,0,1), nrow = 2, byrow = TRUE))
belplau(xy1) 
belplau(xy1, remove = TRUE) 
belplau(xy1, h = matrix(c(1,0,0,0,1,1), nrow = 2, byrow = TRUE))

</code></pre>

<hr>
<h2 id='belplauEval'>Evaluate A, B errors</h2><span id='topic+belplauEval'></span>

<h3>Description</h3>

<p>Calculate error A, B, and total error A+B by comparing two vectors as defined below. One vector represents the truth and the other represents a numerical quantity of importance.
</p>

<ul>
<li><p> Error A: out of all the comparisons between two elements, what proportion of errors are due to indicating an irrelevant element as more important than a relevant element
</p>
</li>
<li><p> Error B: out of all the comparisons between two elements, what proportion of errors are due to indicating a relevant element as less important than an irrelevant element
</p>
</li>
<li><p> Total error A+B: the sum of quantity A and quantity B
</p>
</li></ul>



<h3>Usage</h3>

<pre><code class='language-R'>belplauEval(
  belplau_mat,
  true_order,
  var = "rplau",
  err = "A",
  is_belplau = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="belplauEval_+3A_belplau_mat">belplau_mat</code></td>
<td>
<p>belplau matrix e.g. belplau(bca) or a numerical vector quantifying order of importance of the elements of the frame.</p>
</td></tr>
<tr><td><code id="belplauEval_+3A_true_order">true_order</code></td>
<td>
<p>a binary vector representing the truth. 1 means relevant and 0 means not relevant.</p>
</td></tr>
<tr><td><code id="belplauEval_+3A_var">var</code></td>
<td>
<p>= &quot;rplau&quot; column name of the belplau matrix to be used as ordering.</p>
</td></tr>
<tr><td><code id="belplauEval_+3A_err">err</code></td>
<td>
<p>= &quot;A&quot; kind of error to be evaluated. Can also take value &quot;B&quot; or &quot;A+B&quot;.</p>
</td></tr>
<tr><td><code id="belplauEval_+3A_is_belplau">is_belplau</code></td>
<td>
<p>= TRUE whether bel_plau is indeed a belplau matrix or just a numerical vector quantifying order of importance of elements.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A number in <code class="reqn">[0,1]</code> of error A, B, or total error A+B.
</p>


<h3>Author(s)</h3>

<p>Peiyuan Zhu
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- bca(tt = matrix(c(0,1,1,1,1,0,1,1,1),nrow = 3, 
byrow = TRUE), m = c(0.2,0.5, 0.3), 
cnames = c("a", "b", "c"), varnames = "x", idvar = 1)
belplau(x)
y &lt;- bca(tt = matrix(c(1,0,0,1,1,1),nrow = 2, 
byrow = TRUE), m = c(0.6, 0.4),  
cnames = c("a", "b", "c"),  varnames = "y", idvar = 1)
xy &lt;- nzdsr(dsrwon(x,y))
z&lt;-belplau(xy,h=ttmatrixPartition(xy$infovar[2],xy$infovar[2]))
belplauEval(z,c(0,1,0))
</code></pre>

<hr>
<h2 id='belplauH'>Calculate belief, disbelief, unknown, plausibility, plausibility ratio</h2><span id='topic+belplauH'></span>

<h3>Description</h3>

<p>Calculate belief, disbelief, unknown, plausibility, plausibility ratio
</p>


<h3>Usage</h3>

<pre><code class='language-R'>belplauH(MACC, W2, h)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="belplauH_+3A_macc">MACC</code></td>
<td>
<p>Vector of masses e.g. x$spec[,2]</p>
</td></tr>
<tr><td><code id="belplauH_+3A_w2">W2</code></td>
<td>
<p>Description matrix e.g. x$tt</p>
</td></tr>
<tr><td><code id="belplauH_+3A_h">h</code></td>
<td>
<p>H
hypotheses to be tested, same format as x$tt</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix of <code>M</code> rows by 5 columns is returned, where <code>M</code> is the number of hypothesis tested: </p>

<ul>
<li><p> Column 1: the degree of Belief <code>bel</code>;
</p>
</li>
<li><p> Column 2: the degree of Disbellief (belief in favor of the contrary hypothesis) <code>disbel</code>;
</p>
</li>
<li><p> Column 3: the degree of Epistemic uncertainty <code>unc</code>;
</p>
</li>
<li><p> Column 4: the degree of Plausibility <code>plau</code>;
</p>
</li>
<li><p> Column 5: the Plausibility ratio <code>rplau</code>.
</p>
</li></ul>



<h3>Author(s)</h3>

<p>Peiyuan Zhu
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- bca(tt = matrix(c(1,1,0,1,1,1), nrow = 2, byrow = TRUE), m = c(0.8, 0.2), cnames = c(1,2,3))
belplauH(MACC = x$spec[,2], W2 = x$tt, h = x$tt)
hyp &lt;- matrix(c(0,1,0, 0,1,1), nrow = 2, byrow = TRUE)
rownames(hyp) &lt;- nameRows(hyp)
belplauH(MACC = x$spec[,2], W2 = x$tt, h = hyp)
</code></pre>

<hr>
<h2 id='belplauHLogsumexp'>Calculate belief, disbelief, unknown, plausibility, plausibility ratio with logsumexp</h2><span id='topic+belplauHLogsumexp'></span>

<h3>Description</h3>

<p>Calculate belief, disbelief, unknown, plausibility, plausibility ratio with logsumexp
</p>


<h3>Usage</h3>

<pre><code class='language-R'>belplauHLogsumexp(MACC, W2, h)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="belplauHLogsumexp_+3A_macc">MACC</code></td>
<td>
<p>Vector of masses e.g. x$spec[,2]</p>
</td></tr>
<tr><td><code id="belplauHLogsumexp_+3A_w2">W2</code></td>
<td>
<p>Description matrix e.g. x$tt</p>
</td></tr>
<tr><td><code id="belplauHLogsumexp_+3A_h">h</code></td>
<td>
<p>Hypotheses to be tested, same format as x$tt</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix of <code>M</code> rows by 5 columns is returned, where <code>M</code> is the number of hypothesis tested: </p>

<ul>
<li><p> Column 1: the degree of Belief <code>bel</code>;
</p>
</li>
<li><p> Column 2: the degree of Disbellief (belief in favor of the contrary hypothesis) <code>disbel</code>;
</p>
</li>
<li><p> Column 3: the degree of Epistemic uncertainty <code>unc</code>;
</p>
</li>
<li><p> Column 4: the degree of Plausibility <code>plau</code>;
</p>
</li>
<li><p> Column 5: the Plausibility ratio <code>rplau</code>.
</p>
</li></ul>



<h3>Author(s)</h3>

<p>Peiyuan Zhu
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- bca(tt = matrix(c(1,1,0,1,1,1), nrow = 2, byrow = TRUE), m = c(0.8, 0.2), cnames = c(1,2,3))
belplauH(MACC = x$spec[,2], W2 = x$tt, h = x$tt)
hyp &lt;- matrix(c(0,1,0, 0,1,1), nrow = 2, byrow = TRUE)
rownames(hyp) &lt;- nameRows(hyp)
belplauH(MACC = x$spec[,2], W2 = x$tt, h = hyp)
</code></pre>

<hr>
<h2 id='belplauHQQ'>Compute belief, disbelief, unknown, plausibility, plausibility ratio based on commonality function</h2><span id='topic+belplauHQQ'></span>

<h3>Description</h3>

<p>Compute belief, disbelief, unknown, plausibility, plausibility ratio based on commonality function
</p>


<h3>Usage</h3>

<pre><code class='language-R'>belplauHQQ(qq, h = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="belplauHQQ_+3A_qq">qq</code></td>
<td>
<p>Commonality function</p>
</td></tr>
<tr><td><code id="belplauHQQ_+3A_h">h</code></td>
<td>
<p>= NULL Hypothesis to be evaluated</p>
</td></tr>
</table>


<h3>Value</h3>

<p>z A matrix of <code>M</code> rows by 5 columns is returned, where <code>M</code> is the number of hypothesis tested: </p>

<ul>
<li><p> Column 1: the degree of Belief <code>bel</code>;
</p>
</li>
<li><p> Column 2: the degree of Disbellief (belief in favor of the contrary hypothesis) <code>disbel</code>;
</p>
</li>
<li><p> Column 3: the degree of Epistemic uncertainty <code>unc</code>;
</p>
</li>
<li><p> Column 4: the degree of Plausibility <code>plau</code>;
</p>
</li>
<li><p> Column 5: the Plausibility ratio <code>rplau</code>.
</p>
</li></ul>



<h3>Author(s)</h3>

<p>Peiyuan Zhu
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- bca(tt = matrix(c(0,1,1,1,1,0,1,1,1),nrow = 3, byrow = TRUE),
m = c(0.2,0.5, 0.3), cnames = c("a", "b", "c"), varnames = "x", idvar = 1)
qq &lt;- commonality(x$tt,x$spec[,2])
belplauHQQ(qq,h=matrix(c(0,1,0), nrow=1, byrow=TRUE))
</code></pre>

<hr>
<h2 id='belplauLogsumexp'>Calculation of the degrees of Belief and Plausibility of a basic chance assignment (bca) with logsumexp.</h2><span id='topic+belplauLogsumexp'></span>

<h3>Description</h3>

<p>Degrees of Belief <code>Bel</code> and Plausibility <code>Pl</code> of the focal elements of a bca are computed. The ratio of the plausibility of a focal element against the plausibility of its contrary is also computed. Subsets with zero mass can be excluded from the calculations.<br />
</p>


<h3>Usage</h3>

<pre><code class='language-R'>belplauLogsumexp(x, remove = FALSE, h = NULL, fzt = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="belplauLogsumexp_+3A_x">x</code></td>
<td>
<p>A basic chance assignment mass function (see <code><a href="#topic+bca">bca</a></code>).</p>
</td></tr>
<tr><td><code id="belplauLogsumexp_+3A_remove">remove</code></td>
<td>
<p>= TRUE: Exclude subsets with zero mass.</p>
</td></tr>
<tr><td><code id="belplauLogsumexp_+3A_h">h</code></td>
<td>
<p>= NULL: Hypothesis to be tested. Description matrix in the same format than <code>x$tt</code></p>
</td></tr>
<tr><td><code id="belplauLogsumexp_+3A_fzt">fzt</code></td>
<td>
<p>= FALSE: Whether to use Fast Zeta Transform</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The degree of belief <code>Bel</code> is defined by: <br />
</p>
<p style="text-align: center;"><code class="reqn">bel(A) = Sum((m(B); B \subseteq A))</code>
</p>
<p> for every subset B of A.<br />
The degree of plausibility <code>pl</code> is defined by: <br />
</p>
<p style="text-align: center;"><code class="reqn">pl(A) = Sum[(m(B); B \cap A \neq \emptyset]</code>
</p>
<p> for every subset <code>B</code> of the frame of discernment. <br />
The plausibility ratio of a focal element <code>A</code> versus its contrary <code>not A</code> is defined by:  <code class="reqn">Pl(A)/(1-Bel(A))</code>.
</p>


<h3>Value</h3>

<p>A matrix of <code>M</code> rows by 3 columns is returned, where <code>M</code> is the number of focal elements: </p>

<ul>
<li><p> Column 1: the degree of Belief <code>bel</code>;
</p>
</li>
<li><p> Column 2: the degree of Disbellief (belief in favor of the contrary hypothesis) <code>disbel</code>;
</p>
</li>
<li><p> Column 3: the degree of Epistemic uncertainty <code>unc</code>;
</p>
</li>
<li><p> Column 4: the degree of Plausibility <code>plau</code>;
</p>
</li>
<li><p> Column 5: the Plausibility ratio <code>rplau</code>.
</p>
</li></ul>



<h3>Author(s)</h3>

<p>Claude Boivin, Peiyuan Zhu
</p>


<h3>References</h3>


<ul>
<li><p> Shafer, G., (1976). A Mathematical Theory of Evidence. Princeton University Press, Princeton, New Jersey, p. 39-43.
</p>
</li>
<li><p> Williams, P., (1990). An interpretation of Shenoy and Shafer's axioms for local computation. International Journal of Approximate Reasoning 4, pp. 225-232.
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- bca(tt = matrix(c(0,1,1,1,1,0,1,1,1),nrow = 3, 
byrow = TRUE), m = c(0.2,0.5, 0.3), 
cnames = c("a", "b", "c"), varnames = "x", idvar = 1)
belplau(x)
y &lt;- bca(tt = matrix(c(1,0,0,1,1,1),nrow = 2, 
byrow = TRUE), m = c(0.6, 0.4),  
cnames = c("a", "b", "c"),  varnames = "y", idvar = 1)
xy &lt;- nzdsr(dsrwon(x,y))
belplau(xy)
print("compare all elementary events")
xy1 &lt;- addTobca(x = xy, tt = matrix(c(0,1,0,0,0,1), nrow = 2, byrow = TRUE))
belplau(xy1) 
belplau(xy1, remove = TRUE) 
belplau(xy1, h = matrix(c(1,0,0,0,1,1), nrow = 2, byrow = TRUE))

</code></pre>

<hr>
<h2 id='belplauPlot'>Plot belplau matrix</h2><span id='topic+belplauPlot'></span>

<h3>Description</h3>

<p>Plot belplau matrix
</p>


<h3>Usage</h3>

<pre><code class='language-R'>belplauPlot(
  belplau_mat,
  xlab,
  color,
  y = "rplau",
  x = "index",
  levels = NULL,
  legend_title = "",
  main_title = "",
  is_log_scale = TRUE,
  is_negative = FALSE,
  is_factor = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="belplauPlot_+3A_belplau_mat">belplau_mat</code></td>
<td>
<p>Belplau matrix e.g. belplau(bpa) or a numerical vector quantifying order of importance of the elements of the frame</p>
</td></tr>
<tr><td><code id="belplauPlot_+3A_xlab">xlab</code></td>
<td>
<p>X-axis labels e.g. c(&quot;1:34&quot;,&quot;35:68&quot;,&quot;69:101&quot;)</p>
</td></tr>
<tr><td><code id="belplauPlot_+3A_color">color</code></td>
<td>
<p>Color of xlab e.g. c(0,1,0)</p>
</td></tr>
<tr><td><code id="belplauPlot_+3A_y">y</code></td>
<td>
<p>= &quot;rplau&quot;: column name of belplau matrix. Ignore if it's not belplau matrix.</p>
</td></tr>
<tr><td><code id="belplauPlot_+3A_x">x</code></td>
<td>
<p>= &quot;index&quot;: x-axis name</p>
</td></tr>
<tr><td><code id="belplauPlot_+3A_levels">levels</code></td>
<td>
<p>= NULL: levels of color in order</p>
</td></tr>
<tr><td><code id="belplauPlot_+3A_legend_title">legend_title</code></td>
<td>
<p>= &quot;&quot;: title of legend</p>
</td></tr>
<tr><td><code id="belplauPlot_+3A_main_title">main_title</code></td>
<td>
<p>= &quot;&quot;: main title</p>
</td></tr>
<tr><td><code id="belplauPlot_+3A_is_log_scale">is_log_scale</code></td>
<td>
<p>= TRUE Whether to use log-scale</p>
</td></tr>
<tr><td><code id="belplauPlot_+3A_is_negative">is_negative</code></td>
<td>
<p>= TRUE Whether to multiple by -1</p>
</td></tr>
<tr><td><code id="belplauPlot_+3A_is_factor">is_factor</code></td>
<td>
<p>= FALSE Whether to plot all x labels</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a plot of a column of the belplau matrix or a numerical vector quantifying order of importance of the elements of the frame
</p>


<h3>Author(s)</h3>

<p>Peiyuan Zhu
</p>


<h3>Examples</h3>

<pre><code class='language-R'>bpa &lt;- bca(tt = matrix(c(0,1,1,1,1,0,1,1,1),nrow = 3, 
byrow = TRUE), m = c(0.2,0.5, 0.3), 
cnames = c("a", "b", "c"), varnames = "x", idvar = 1)
bel_plau &lt;- belplau(bpa)
belplauPlot(bel_plau, c("a","b","c"), c(1,3,2))
</code></pre>

<hr>
<h2 id='captain_result'>The Captain's Problem. <code>swr</code>: Result of the evaluation of the Hypergraph at node Arrival (A)</h2><span id='topic+captain_result'></span>

<h3>Description</h3>

<p>This dataset is the <code>tt</code> bca resulting from the combination of the relations of the hypergraph and marginalization at node Arrival (A).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>captain_result
</code></pre>


<h3>Format</h3>

<p>A list of 8 elements, of class bcaspec.
</p>


<h3>Author(s)</h3>

<p>Claude Boivin, Stat.ASSQ
</p>


<h3>Source</h3>

<p>Almond, R.G. [1988] Fusion and Propagation in Graphical Belief Models. Computing Science and Statistics: Proceedings of the 20th Symposium on the Interface. Wegman, Edward J., Gantz, Donald T. and Miller, John J. (ed.). American Statistical Association, Alexandria, Virginia. pp 365&ndash;370.
</p>

<hr>
<h2 id='commonality'>Compute qq from tt</h2><span id='topic+commonality'></span>

<h3>Description</h3>

<p>qq is the commonality function as a set function from the subsets of the frame to <code class="reqn">[0,1]</code>. To evaluate it, input a set encoded in binary vector, so the commonality number at that set can be returned.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>commonality(tt, m, fzt = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="commonality_+3A_tt">tt</code></td>
<td>
<p>Mass assignment set matrix</p>
</td></tr>
<tr><td><code id="commonality_+3A_m">m</code></td>
<td>
<p>Mass assignment</p>
</td></tr>
<tr><td><code id="commonality_+3A_fzt">fzt</code></td>
<td>
<p>= FALSE Whether to use Fast Zeta Transform</p>
</td></tr>
</table>


<h3>Value</h3>

<p>f Commonality function
</p>


<h3>Author(s)</h3>

<p>Peiyuan Zhu
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- bca(tt = matrix(c(0,1,1,1,1,0,1,1,1),nrow = 3, byrow = TRUE),
m = c(0.2,0.5, 0.3), cnames = c("a", "b", "c"), varnames = "x", idvar = 1)
qq &lt;- commonality(x$tt,x$spec[,2])
qq(c(1,0,0))
</code></pre>

<hr>
<h2 id='decode'>Find the value in base 10 of a number coded in another base</h2><span id='topic+decode'></span><span id='topic+aplDecode'></span>

<h3>Description</h3>

<p>The <code>aplDecode</code> function of the project APL in R (<a href="https://rpubs.com/deleeuw/158476">https://rpubs.com/deleeuw/158476</a>) has been adapted to follow the standard implementation of the APL <code>decode</code> function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>decode(base, ind)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="decode_+3A_base">base</code></td>
<td>
<p>A scalar or a numeric vector which describes the number system in which the data is coded.</p>
</td></tr>
<tr><td><code id="decode_+3A_ind">ind</code></td>
<td>
<p>The value to decode represented by a numeric vector in the <code>base</code> system.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If the base value is a number system, e.g. base 2, we need only to enter it as a scalar, which is then processed to match the length of the expression to decode. If <code>length(ind)</code>  is less than <code>length(base)</code>, zeroes are added to the left of the vector <code>ind</code>  to match the length of the two vectors. And vice-versa.
</p>


<h3>Value</h3>

<p>A scalar representing the conversion of the coded number <code>ind</code> to its decimal representation.
</p>


<h3>Author(s)</h3>

<p>Claude Boivin
</p>


<h3>References</h3>


<ul>
<li><p> Jan de Leeuw and Masanao Yajima (March 07, 2016) <em>APL in R (Version 009)</em>, Source code. <a href="https://rpubs.com/deleeuw/158476">https://rpubs.com/deleeuw/158476</a>
</p>
</li>
<li><p>  L. Gilman and A. J. Rose.(1974): <em>APL an Interactive Approach</em>, Second Edition, John Wiley, New York.
</p>
</li>
<li><p>  APL 68000 Level II language manual. MicroAPL Ltd. 1990.
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>decode(c(2,2,2,2), c(1,0,1,1)) #   Find the base 10 value of the base 2 number 1011.
decode(2, c(1,0,1,1))  # left argument is extended to vector c(2,2,2,2)
decode(c(365,24,60), c(2,1,57)) # transform 2 days 1 h 57 min in minutes
decode(c(365,24,60), c(1,57))   # right vector extended
decode(c(24,60), c(2,1,57))     # left vector extended
decode(1.5, c(1,2,3)) # polynomial 1*x^2 +2*x +3 evaluated at x=1.5
</code></pre>

<hr>
<h2 id='dlfm'>The Captain's Problem. <code>dlfm</code>: Relation between variables Departure delay (D), Loading delay (L), Forecast of the weather (F), Maintenance delay (M)</h2><span id='topic+dlfm'></span>

<h3>Description</h3>

<p>This dataset is the <code>tt</code> matrix establishing the relation between the four variables. Each event (loading = true, forecast = foul, Maintenance = true) adds one day of Departure Delay. The elements (d,l, f, m) of (D x L x F x M) satisfying the relation form a subset with a mass value of 1. To construct the <code>tt</code> matrix, we put the variables D,L,F,M side by side, as in a truth table representation. Each 4-tuple of the subset is described by a row of the matrix as a vector of zeros and ones.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dlfm
</code></pre>


<h3>Format</h3>

<p>An integer matrix with 10 rows and 12 columns.
</p>

<dl>
<dt>[1,c(1,2)]</dt><dd><p>value = 0, not used</p>
</dd>
<dt>[1,3:12]</dt><dd><p>Identification numbers of the four variables. Column 3 to 6: variable 2; columns 7,8: variable 4; columns 9, 10: variable 5: columns 11,12: variable 6.</p>
</dd>
<dt>nospec</dt><dd><p>identification number of the specification</p>
</dd>
<dt>m</dt><dd><p>the value of the specification, a number between 0 and 1</p>
</dd>
<dt>3</dt><dd><p>1 if d3 is part of the specification, 0 otherwise</p>
</dd>
<dt>2</dt><dd><p>1 if d2 is part of the specification, 0 otherwise</p>
</dd>
<dt>1</dt><dd><p>1 if d1 is part of the specification, 0 otherwise</p>
</dd>
<dt>0</dt><dd><p>1 if d0 is part of the specification, 0 otherwise</p>
</dd>
<dt>true</dt><dd><p>1 if true is part of the specification, 0 otherwise</p>
</dd>
<dt>false</dt><dd><p>1 if false is part of the specification, 0 otherwise</p>
</dd>
<dt>foul</dt><dd><p>1 if foul is part of the specification, 0 otherwise</p>
</dd>
<dt>fair</dt><dd><p>1 if fair is part of the specification, 0 otherwise</p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>Claude Boivin, Stat.ASSQ
</p>


<h3>Source</h3>

<p>Almond, R.G. [1988] Fusion and Propagation in Graphical Belief Models. Computing Science and Statistics: Proceedings of the 20th Symposium on the Interface. Wegman, Edward J., Gantz, Donald T. and Miller, John J. (ed.). American Statistical Association, Alexandria, Virginia. pp 365&ndash;370.
</p>

<hr>
<h2 id='DoSSnames'>Construct subsets names from column names of a tt matrix</h2><span id='topic+DoSSnames'></span>

<h3>Description</h3>

<p>Construct subsets names from column names of a tt matrix
</p>


<h3>Usage</h3>

<pre><code class='language-R'>DoSSnames(tt)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="DoSSnames_+3A_tt">tt</code></td>
<td>
<p>A description matrix with column names</p>
</td></tr>
</table>


<h3>Value</h3>

<p>subsets_names A list of names.
</p>


<h3>Author(s)</h3>

<p>Claude Boivin
</p>


<h3>Examples</h3>

<pre><code class='language-R'>y1 &lt;- bca(tt = matrix(c(0,1,1,1,1,0,1,1,1),nrow = 3, 
byrow = TRUE), m = c(0.2,0.5, 0.3), 
cnames = c("a", "b", "c"),  
varnames = "x", idvar = 1) 
DoSSnames(y1$tt)
</code></pre>

<hr>
<h2 id='dotprod'>Generalized inner product of two matrices</h2><span id='topic+dotprod'></span>

<h3>Description</h3>

<p>The generalized inner product of two matrices combines two operators in the same manner as the classical inner product defined for the multiplication of two matrices. The number of rows of the second matrix must be equal the number of columns of the first matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dotprod(x, y, g, f)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="dotprod_+3A_x">x</code></td>
<td>
<p>A matrix of M rows by K columns.</p>
</td></tr>
<tr><td><code id="dotprod_+3A_y">y</code></td>
<td>
<p>A matrix of K rows by N columns.</p>
</td></tr>
<tr><td><code id="dotprod_+3A_g">g</code></td>
<td>
<p>Any operator: +, -, *, /, &amp;, |, ==, &lt;=, paste etc.</p>
</td></tr>
<tr><td><code id="dotprod_+3A_f">f</code></td>
<td>
<p>Any operator: +, -, *, /, &amp;, |, ==, &lt;=, paste etc.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The result of the generalized inner product is returned.
</p>


<h3>Author(s)</h3>

<p>Claude Boivin
</p>


<h3>Examples</h3>

<pre><code class='language-R'>print("Standard matrix product")
x &lt;- y &lt;- matrix(c(1:6), nrow = 2, byrow = TRUE)
dotprod(x, t(y), g = "+", f = "*")  ## same as x %*% t(y)
print("Find some data x2 in the rows of a larger matrix y2")
x2 &lt;- matrix(c(1,0,0,1,1,1), nrow = 2, byrow = TRUE)
y2 &lt;- matrix(c(1,0,0,0,1,0,1,1,0,0,1,1,1,1,1), 
nrow = 5, byrow = TRUE)
(1:nrow(y2)) * dotprod(x2, t(y2), g = "&amp;", f = "==")

print("Find some names in a long list")
team_names &lt;- matrix(c("Patrick", "Dole", "Amanda",
 "Dole", "Robert", "Calvin", "Alvina", "Klein",
  "Robert", "Gariepy", "Nellie", "Arcand"),
   ncol = 2, byrow = TRUE)
colnames(team_names) &lt;- c("First_name", "Last_name")
print("Where in the list are the person with first name Robert and where are the Doles?")
BobandDoles &lt;- matrix(c("Robert", "", "", "Dole"),
 ncol = 2, byrow = TRUE)
dotprod(team_names, t(BobandDoles),g="|",f="==") * (1:nrow(team_names))
</code></pre>

<hr>
<h2 id='doubles'>Remove duplicate rows in a two-dimensional table.</h2><span id='topic+doubles'></span>

<h3>Description</h3>

<p>Recursive function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>doubles(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="doubles_+3A_x">x</code></td>
<td>
<p>A matrix of numeric, character or logical type.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The submitted matrix with duplicated rows removed from.
</p>


<h3>Author(s)</h3>

<p>Claude Boivin
</p>


<h3>Examples</h3>

<pre><code class='language-R'>td0 &lt;- matrix(c(rep(c(1,0,1),times=3),0,0,1,1,1,1, 1,1,1),ncol = 3,byrow = TRUE)
(doubles(td0))
td1 &lt;- matrix(c(rep(c(1,0,1),times=3),0,0,1,1,1,1),ncol = 3,byrow = TRUE)
(doubles(td1))
td2 &lt;- matrix(c(1:3, 1:3,4:6,1:3),nrow = 4,byrow = TRUE)
(doubles(td2))
td3 &lt;- matrix(c("d","e","f", rep(c("a","b","cc"),times = 3),"g","h","i"),nrow = 5,byrow = TRUE)
(doubles(td3))
td4 &lt;- matrix(as.logical(td1),nrow = 5,byrow = TRUE)
(doubles(td4))
</code></pre>

<hr>
<h2 id='dsrwon'>Combination of two mass functions</h2><span id='topic+dsrwon'></span>

<h3>Description</h3>

<p>The unnormalized Dempster's rule is used to combine two mass functions <code>mx</code> and <code>my</code> defined  on the same frame of discernment and described by their respective basic chance assignments <code>x</code>  and <code>y</code>. Dempster's rule of combination is applied. The normalization is not done, leaving the choice  to the user to normalize the results or not (for the normalization operation, see function <code><a href="#topic+nzdsr">nzdsr</a></code>).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dsrwon(
  x,
  y,
  mcores = "no",
  use_ssnames = FALSE,
  use_qq = FALSE,
  varnames = NULL,
  relnb = NULL,
  skpt_tt = FALSE,
  infovarnames
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="dsrwon_+3A_x">x</code></td>
<td>
<p>A basic chance assignment (see <code><a href="#topic+bca">bca</a></code>).</p>
</td></tr>
<tr><td><code id="dsrwon_+3A_y">y</code></td>
<td>
<p>A basic chance assignment (see <code><a href="#topic+bca">bca</a></code>).</p>
</td></tr>
<tr><td><code id="dsrwon_+3A_mcores">mcores</code></td>
<td>
<p>Make use of multiple cores (&quot;yes&quot;) or not (&quot;no&quot;). Default = &quot;no&quot;.</p>
</td></tr>
<tr><td><code id="dsrwon_+3A_use_ssnames">use_ssnames</code></td>
<td>
<p>= TRUE to use ssnames instead of tt matrix to do the intersections. Default = FALSE</p>
</td></tr>
<tr><td><code id="dsrwon_+3A_use_qq">use_qq</code></td>
<td>
<p>= TRUE to use qq instead of tt matrix to do the intersections. Default = FALSE</p>
</td></tr>
<tr><td><code id="dsrwon_+3A_varnames">varnames</code></td>
<td>
<p>A character string to name the resulting variable. named &quot;z&quot; if omitted.</p>
</td></tr>
<tr><td><code id="dsrwon_+3A_relnb">relnb</code></td>
<td>
<p>Identification number of the relation. Can be omitted.</p>
</td></tr>
<tr><td><code id="dsrwon_+3A_skpt_tt">skpt_tt</code></td>
<td>
<p>Skip reconstruction of tt matrix. Default = FALSE.</p>
</td></tr>
<tr><td><code id="dsrwon_+3A_infovarnames">infovarnames</code></td>
<td>
<p>Deprecated. Old name for <code>varnames</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The calculations make use of multiple cores available.
</p>
<p>The two bca's <code>x</code> and <code>y</code> must be defined on the same frame of discernment for the combination to take place. The relation number of the x input is given to the output result.
</p>


<h3>Value</h3>

<p>A basic chance assignment with these two components added: </p>

<ul>
<li><p> I12 Intersection table of subsets.
</p>
</li>
<li><p> Sort_order Sort order of subsets.
</p>
</li></ul>



<h3>Author(s)</h3>

<p>Claude Boivin, Peiyuan Zhu
</p>


<h3>References</h3>

<p>Shafer, G., (1976). A Mathematical Theory of Evidence. Princeton University Press, Princeton, New Jersey, pp. 57-61: Dempster's rule of combination.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>y1 &lt;- bca(tt = matrix(c(0,1,1,1,1,0,1,1,1),nrow = 3, 
byrow = TRUE), m = c(0.2,0.5, 0.3), 
cnames = c("a", "b", "c"),  
varnames = "x", idvar = 1) 
y2 &lt;- bca(tt = matrix(c(1,0,0,1,1,1),nrow = 2, 
byrow = TRUE), m = c(0.6, 0.4),  
cnames = c("a", "b", "c"),  
varnames = "x", idvar = 1)
dsrwon(y1,y2)
# Sparse matrices
y1s &lt;- y1
y2s &lt;- y2
y1s$tt &lt;- methods::as(y1$tt, "RsparseMatrix")
y2s$tt &lt;- methods::as(y2$tt, "RsparseMatrix")
y1y2s &lt;- dsrwon(y1s, y2s, use_ssnames = TRUE)

# using commonalities
bma &lt;- bca(tt=matrix(c(1,1,0,1,rep(1,4)), ncol = 4, byrow = TRUE), 
m = c(0.1, 0.9), cnames = c("a", "b", "c", "d"))
bma2 &lt;- dsrwon(bma, bma, use_qq = TRUE)

vacuous &lt;- bca(matrix(c(1,1,1), nrow = 1), m = 1, cnames = c("a","b","c"))
dsrwon(vacuous, vacuous)
</code></pre>

<hr>
<h2 id='dsrwonLogsumexp'>Combination of two mass functions with logsumexp</h2><span id='topic+dsrwonLogsumexp'></span>

<h3>Description</h3>

<p>The unnormalized Dempster's rule is used to combine two mass functions <code>mx</code> and <code>my</code> defined  on the same frame of discernment and described by their respective basic chance assignments <code>x</code>  and <code>y</code>. Dempster's rule of combination is applied. The normalization is not done, leaving the choice  to the user to normalize the results or not (for the normalization operation, see function <code><a href="#topic+nzdsr">nzdsr</a></code>).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dsrwonLogsumexp(
  x,
  y,
  mcores = "no",
  use_ssnames = FALSE,
  use_qq = FALSE,
  varnames = NULL,
  relnb = NULL,
  skpt_tt = FALSE,
  infovarnames
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="dsrwonLogsumexp_+3A_x">x</code></td>
<td>
<p>A basic chance assignment (see <code><a href="#topic+bca">bca</a></code>).</p>
</td></tr>
<tr><td><code id="dsrwonLogsumexp_+3A_y">y</code></td>
<td>
<p>A basic chance assignment (see <code><a href="#topic+bca">bca</a></code>).</p>
</td></tr>
<tr><td><code id="dsrwonLogsumexp_+3A_mcores">mcores</code></td>
<td>
<p>Make use of multiple cores (&quot;yes&quot;) or not (&quot;no&quot;). Default = &quot;no&quot;.</p>
</td></tr>
<tr><td><code id="dsrwonLogsumexp_+3A_use_ssnames">use_ssnames</code></td>
<td>
<p>= TRUE to use ssnames instead of tt matrix to do the intersections. Default = FALSE</p>
</td></tr>
<tr><td><code id="dsrwonLogsumexp_+3A_use_qq">use_qq</code></td>
<td>
<p>= TRUE to use qq instead of tt matrix to do the intersections. Default = FALSE</p>
</td></tr>
<tr><td><code id="dsrwonLogsumexp_+3A_varnames">varnames</code></td>
<td>
<p>A character string to name the resulting variable. named &quot;z&quot; if omitted.</p>
</td></tr>
<tr><td><code id="dsrwonLogsumexp_+3A_relnb">relnb</code></td>
<td>
<p>Identification number of the relation. Can be omitted.</p>
</td></tr>
<tr><td><code id="dsrwonLogsumexp_+3A_skpt_tt">skpt_tt</code></td>
<td>
<p>Skip reconstruction of tt matrix. Default = FALSE.</p>
</td></tr>
<tr><td><code id="dsrwonLogsumexp_+3A_infovarnames">infovarnames</code></td>
<td>
<p>Deprecated. Old name for <code>varnames</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The calculations make use of multiple cores available.
</p>
<p>The two bca's <code>x</code> and <code>y</code> must be defined on the same frame of discernment for the combination to take place. The relation number of the x input is given to the output result.
</p>


<h3>Value</h3>

<p>A basic chance assignment with these two components added: </p>

<ul>
<li><p> I12 Intersection table of subsets.
</p>
</li>
<li><p> Sort_order Sort order of subsets.
</p>
</li></ul>



<h3>Author(s)</h3>

<p>Claude Boivin, Peiyuan Zhu
</p>


<h3>References</h3>

<p>Shafer, G., (1976). A Mathematical Theory of Evidence. Princeton University Press, Princeton, New Jersey, pp. 57-61: Dempster's rule of combination.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>y1 &lt;- bca(tt = matrix(c(0,1,1,1,1,0,1,1,1),nrow = 3, 
byrow = TRUE), m = c(0.2,0.5, 0.3), 
cnames = c("a", "b", "c"),  
varnames = "x", idvar = 1) 
y2 &lt;- bca(tt = matrix(c(1,0,0,1,1,1),nrow = 2, 
byrow = TRUE), m = c(0.6, 0.4),  
cnames = c("a", "b", "c"),  
varnames = "x", idvar = 1)
dsrwonLogsumexp(y1,y2)
# Sparse matrices
y1s &lt;- y1
y2s &lt;- y2
y1s$tt &lt;- methods::as(y1$tt, "RsparseMatrix")
y2s$tt &lt;- methods::as(y2$tt, "RsparseMatrix")
y1y2s &lt;- dsrwonLogsumexp(y1s, y2s, use_ssnames = TRUE)
vacuous &lt;- bca(matrix(c(1,1,1), nrow = 1), m = 1, cnames = c("a","b","c"))
dsrwonLogsumexp(vacuous, vacuous)
</code></pre>

<hr>
<h2 id='elim'>Reduction of a relation</h2><span id='topic+elim'></span>

<h3>Description</h3>

<p>This function works on a relation defined on a product of two variables or more.  Having fixed a variable to eliminate from the relation,  the reduced product space is determined and the corresponding reduced bca is computed.This operation is also called &quot;marginalization&quot;.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>elim(rel, xnb)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="elim_+3A_rel">rel</code></td>
<td>
<p>The relation to reduce, an object of class bcaspec.</p>
</td></tr>
<tr><td><code id="elim_+3A_xnb">xnb</code></td>
<td>
<p>Identification number of the variable to eliminate.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>r The reduced relation
</p>


<h3>Author(s)</h3>

<p>Claude Boivin
</p>


<h3>Examples</h3>

<pre><code class='language-R'> 
# We construct a relation between two variables to show marginalization.
wr_tt &lt;- matrix(c(1,rep(0,3),rep(c(1,0),3),0,1,1,1,0,0,
1,0,rep(1,5),0,1,1,0,rep(1,5)), ncol = 4, byrow = TRUE)
colnames(wr_tt) &lt;- c("Wy Ry", "Wy Rn", "Wn Ry", "Wn Rn")
rownames(wr_tt) &lt;- nameRows(wr_tt)
wr_spec = matrix(c(1:8, 0.017344, 0.046656, 
0.004336, 0.199456,0.011664,0.536544,0.049864, 0.134136), 
 ncol = 2, dimnames = list(NULL, c("specnb", "mass"))) 
 wr_infovar = matrix(c(4,5,2,2), ncol = 2, 
 dimnames = list(NULL, c("varnb", "size")) )
wr_rel &lt;- list(tt = wr_tt, con = 0.16, spec=wr_spec,
  infovar = wr_infovar, varnames = c("Roadworks","Rain"),
  valuenames = list( RdWorks = c("Wy", "Wn"), Rain=c("Ry", "Rn") ))
class(wr_rel) &lt;- "bcaspec"
bcaPrint(elim(wr_rel, xnb = 5))
bcaPrint(elim(wr_rel, xnb = 4))
 
</code></pre>

<hr>
<h2 id='encode'>Convert a value to its representation in another chosen base</h2><span id='topic+encode'></span><span id='topic+aplEncode'></span>

<h3>Description</h3>

<p>The <code>aplEncode</code> function of the project APL in R (<a href="https://rpubs.com/deleeuw/158476">https://rpubs.com/deleeuw/158476</a>) has been adapted to follow the standard implementation of the APL <code>encode</code> function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>encode(base, ind)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="encode_+3A_base">base</code></td>
<td>
<p>A numeric vector which describes the number system in which we want to recode the data.</p>
</td></tr>
<tr><td><code id="encode_+3A_ind">ind</code></td>
<td>
<p>The value to convert represented by a number or a numeric vector.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector or a matrix of the data converted.
</p>


<h3>Author(s)</h3>

<p>Claude Boivin
</p>


<h3>References</h3>


<ul>
<li><p> Jan de Leeuw and Masanao Yajima (March 07, 2016) <em>APL in R (Version 009)</em>, Source code. <a href="https://rpubs.com/deleeuw/158476">https://rpubs.com/deleeuw/158476</a>
</p>
</li>
<li><p>  L. Gilman and A. J. Rose.(1974): <em>APL an Interactive Approach</em>, Second Edition, John Wiley, New York.
</p>
</li>
<li><p>  APL 68000 Level II language manual. MicroAPL Ltd. 1990.
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>encode(c(2,2,2,2), 11)  # find the base 2 representation of number 11
encode(c(365,24,60), 2997) # convert 2997 minutes to days-hrs-min.
</code></pre>

<hr>
<h2 id='extFrame'>Extension of the frame of discernment of a variable</h2><span id='topic+extFrame'></span>

<h3>Description</h3>

<p>This function works on a basic chance assignment (bca) <code>x</code> defined on a single variable. Iy= t Allows the addition of new values to the frame of discernment.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>extFrame(x, use_ssnames = FALSE, lab = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="extFrame_+3A_x">x</code></td>
<td>
<p>An object of bca class, i.e. a basic chance assignment defined on one variable</p>
</td></tr>
<tr><td><code id="extFrame_+3A_use_ssnames">use_ssnames</code></td>
<td>
<p>Default= FALSE. Put TRUE if use of subset names is wanted.</p>
</td></tr>
<tr><td><code id="extFrame_+3A_lab">lab</code></td>
<td>
<p>A character vector containing the names of the elements to add to the frame of discernment.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>zxtnd The bca with its frame extended
</p>


<h3>Author(s)</h3>

<p>Claude Boivin
</p>


<h3>Examples</h3>

<pre><code class='language-R'>s1_e1 &lt;- bca(tt = matrix(c(1,0,1,1),nrow = 2, byrow = TRUE), 
m = c(0.6,0.4), cnames = c("S1","S2"), varnames = "v1", idvar = 1) 
s13_names &lt;- extFrame(s1_e1, lab = "S3", use_ssnames =TRUE)
s13 &lt;- extFrame(s1_e1, lab = "S3")
</code></pre>

<hr>
<h2 id='extmin'>Extension of a relation</h2><span id='topic+extmin'></span>

<h3>Description</h3>

<p>This function works on a basic chance assignment (bca) <code>x</code> defined on a single variable or more. A relation of reference is given, and an extension of the space of <code>x</code> is made to the larger product space of the relation of reference. The basic chance assignment to extend and the relation of reference must have at least one common variable for the extension to occur.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>extmin(rel1, relRef)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="extmin_+3A_rel1">rel1</code></td>
<td>
<p>An object of class bcaspec, i.e. a basic chance assignment defined on one variable or a relation.</p>
</td></tr>
<tr><td><code id="extmin_+3A_relref">relRef</code></td>
<td>
<p>The relation of reference. It can be an existing relation, or it can be constructed as a vacuous function.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>relRef</code> parameter is used to extract all the information on the variables, namely their identification numbers and the number of elements of each variable, variables names and columns names of the <code>tt</code> matrix. The relation of reference <code>relRef</code>  may be a relation already existing or simply the the vacuous relation defined on the product set of variables of interest.
</p>


<h3>Value</h3>

<p>the resulting extended bca.
</p>


<h3>Author(s)</h3>

<p>Claude Boivin
</p>


<h3>References</h3>

<p>G. Shafer and P. P. Shenoy. Local Computations in Hypertrees. School of Business, University of Kansas, Lawrence, KS, 1991. See p. 78, vacuous extension of a belief function.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Making a vacuous reference relation and extending a bca to its space.
init_tt = matrix(rep(1,10),nrow = 1, 
dimnames = list(NULL, c("3", "2", "1", "0", 
 "true", "false",  "foul", "fair",  "true", "false")) )
 init_spec &lt;- matrix(c(1,1), ncol = 2, 
 dimnames = list(NULL, c("specnb", "mass")))
 init_info &lt;- matrix(c(3,4,7,8,4,2,2,2), ncol = 2,
  dimnames = list(NULL, c("varnb", "size")) )
 relRef &lt;- bcaRel(tt = init_tt, spec = init_spec,
  infovar = init_info, 
  varnames = c("Sail", "Loading", "Weather", "Repairs"),
  relnb = 0)
 # a bcaspec defined on one variable
 l_rel &lt;- bca(tt = matrix(c(1,0,1,0,1,1), ncol = 2), 
 m = c(0.3,0.5,0.2), cnames = c("true", "false"), 
 infovar = matrix(c(4,2), ncol = 2, 
 dimnames = list(NULL, c("varnb", "size"))), 
 varnames = c("Loading"), 
 inforel = matrix(c(7,1), ncol = 2, 
 dimnames = list(NULL, c("relnb", "depth"))))
 z &lt;- extmin(l_rel, relRef)
 prmatrix(t(z$tt), collab = rep("", nrow(z$tt)))
 
</code></pre>

<hr>
<h2 id='fw'>The Captain's Problem. <code>fw</code>: Relation between variables Forecast of the weather (F) and  Weather at sea (W)</h2><span id='topic+fw'></span>

<h3>Description</h3>

<p>This dataset is the <code>tt</code> matrix establishing the relation between the two variables. An accurate forecast is described by this subset of two event:  (Forecast = foul, Weather = foul) and (Forecast = fair, Weather = fair). We assign a mass value of 0.8 to this subset. The remaining mass of 0.2 is allotted to the frame. To construct the <code>tt</code> matrix, we put the variables F and W side by side, as in a truth table representation. Each pair of the subset is described by a row of the matrix as a vector of zeros and ones.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fw
</code></pre>


<h3>Format</h3>

<p>An integer matrix with 4 rows and 6 columns.
</p>

<dl>
<dt>[1,c(1,2)]</dt><dd><p>value = 0, not used</p>
</dd>
<dt>[1,3:6]</dt><dd><p>Identification numbers of the two variables. Column 3,6: variable 5; columns 5,6: variable 7.</p>
</dd>
<dt>nospec</dt><dd><p>identification number of the specification</p>
</dd>
<dt>m</dt><dd><p>the value of the specification, a number between 0 and 1</p>
</dd>
<dt>foul</dt><dd><p>1 if foul is part of the specification, 0 otherwise</p>
</dd>
<dt>fair</dt><dd><p>1 if fair is part of the specification, 0 otherwise</p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>Claude Boivin
</p>


<h3>Source</h3>

<p>Almond, R.G. [1988] Fusion and Propagation in Graphical Belief Models. Computing Science and Statistics: Proceedings of the 20th Symposium on the Interface. Wegman, Edward J., Gantz, Donald T. and Miller, John J. (ed.). American Statistical Association, Alexandria, Virginia. pp 365&ndash;370.
</p>

<hr>
<h2 id='inters'>Intersection of two tables of propositions</h2><span id='topic+inters'></span>

<h3>Description</h3>

<p>Function <code>inters</code> returns a table of the intersection between two (0,1) or boolean matrices or two vectors. The two matrices must have the same number of columns. The two vectors must be of the same length. This function generalizes the intersection of two subsets represented by boolean vectors to the intersection of two matrices of subsets.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>inters(x, y)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="inters_+3A_x">x</code></td>
<td>
<p>A (0,1)-matrix or a boolean matrix of M rows by K columns, or a vector of length K.</p>
</td></tr>
<tr><td><code id="inters_+3A_y">y</code></td>
<td>
<p>A (0,1)-matrix or a boolean matrix of N rows by K columns or a vector of length K.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The result is a (0,1)-table of dimensions (M x K) x N). In the case of vectors, the result is a (0,1)-table of dimensions (1 x K) x 1)
</p>


<h3>Author(s)</h3>

<p>Claude Boivin
</p>


<h3>Examples</h3>

<pre><code class='language-R'>mx &lt;- matrix(c(0,1,0,0,1,1,1,1,1),nrow = 3, byrow = TRUE, dimnames = list(NULL, c("a", "b", "c")))
 rownames(mx) &lt;- nameRows(mx)
my&lt;-matrix(c(0,0,1,1,1,1),nrow = 2, byrow = TRUE, dimnames = list(NULL, c("a", "b", "c")))
 rownames(my) &lt;- nameRows(my)
inters(mx,my)
b1 &lt;- matrix(c(FALSE, TRUE, TRUE), nrow=1)
b2 &lt;- matrix(c(TRUE, TRUE, FALSE), nrow=1)
colnames(b1) &lt;- colnames(b2) &lt;- c("c1","c2","c3")
inters(b1,b2)
x3&lt;-matrix(c(1,1,0,1), ncol = 2, dimnames = list(NULL, c("a","b")))
y3&lt;-matrix(c(0,1,1,1), ncol = 2, dimnames = list(NULL, c("a","b")))
inters(x3,y3)
x4 &lt;-matrix(c(1,0,1,1,1,1,1,1),nrow = 2, byrow = TRUE, dimnames = list(NULL, c("a", "b", "c","d")))
y4 &lt;-matrix(c(1,0,0,1,1,1,1,1),nrow = 2, byrow = TRUE, dimnames = list(NULL, c("a", "b", "c","d")))
inters(x4,y4)
# Sparse matrices
stt1 &lt;- Matrix::sparseMatrix(i= c(1,1,2,2,3,3,3), j= c(2,3,1,2,1,2,3), x = 1, dims = c(3,3))
y1 &lt;- bca(tt = stt1, m = c(0.2,0.5, 0.3), 
         cnames = c("a", "b", "c"),  
         varnames = "x", idvar = 1) 
stt2 &lt;- Matrix::sparseMatrix(i= c(1,2,2,2), j= c(1,1,2,3), x = 1, dims = c(2,3))
y2 &lt;- bca(tt = stt2, m = c(0.6, 0.4),  
         cnames = c("a", "b", "c"),  
         varnames = "x", idvar = 1)
 sr &lt;-inters(y1$tt, y2$tt)   
 sr 
 class(sr)    
</code></pre>

<hr>
<h2 id='intersBySSName'>Intersect two vectors of ssnames</h2><span id='topic+intersBySSName'></span>

<h3>Description</h3>

<p>Intersect two vectors of ssnames
</p>


<h3>Usage</h3>

<pre><code class='language-R'>intersBySSName(zx, yz)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="intersBySSName_+3A_zx">zx</code></td>
<td>
<p>a vector of ssnames from one bca</p>
</td></tr>
<tr><td><code id="intersBySSName_+3A_yz">yz</code></td>
<td>
<p>a vector of ssnames from another bca</p>
</td></tr>
</table>


<h3>Value</h3>

<p>ssnames in the intersection of the two bcas
</p>


<h3>Author(s)</h3>

<p>Peiyuan Zhu
</p>


<h3>Examples</h3>

<pre><code class='language-R'>y1 &lt;- bca(tt = matrix(c(0,1,1,1,1,0,1,1,1),nrow = 3, 
byrow = TRUE), m = c(0.2,0.5, 0.3), 
cnames = c("a", "b", "c"),  
varnames = "x", idvar = 1) 
y2 &lt;- bca(tt = matrix(c(1,0,0,1,1,1),nrow = 2, 
byrow = TRUE), m = c(0.6, 0.4),  
cnames = c("a", "b", "c"),  
varnames = "x", idvar = 1)
intersBySSName(y1$ssnames[[1]], y2$ssnames[[2]])
</code></pre>

<hr>
<h2 id='logsum'>Adding small probabilities</h2><span id='topic+logsum'></span>

<h3>Description</h3>

<p>Adding small probabilities
</p>


<h3>Usage</h3>

<pre><code class='language-R'>logsum(l1, l2)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="logsum_+3A_l1">l1</code></td>
<td>
<p>log probabilities</p>
</td></tr>
<tr><td><code id="logsum_+3A_l2">l2</code></td>
<td>
<p>log probabilities</p>
</td></tr>
</table>


<h3>Value</h3>

<p>sum of probabilities exp(l1)+exp(l2)
</p>


<h3>Author(s)</h3>

<p>Peiyuan Zhu
</p>


<h3>Examples</h3>

<pre><code class='language-R'># sum of two 1e-5
exp(logsum(log(1e-5),log(1e-5)))
</code></pre>

<hr>
<h2 id='marrayToMatrix'>Transformation of an array data to its matrix representation</h2><span id='topic+marrayToMatrix'></span>

<h3>Description</h3>

<p>The array representation or product space representation is converted to the matrix representation of the corresponding relation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>marrayToMatrix(mtt)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="marrayToMatrix_+3A_mtt">mtt</code></td>
<td>
<p>The matrix <code>tt</code> of the relation in  array format</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The matrix representation of the data.
</p>


<h3>Author(s)</h3>

<p>Claude Boivin
</p>


<h3>Examples</h3>

<pre><code class='language-R'> mtt &lt;- array(c(1,0,0,0,1,1,0,0,1,0,0,1,1,0,1,0,1,1,0,1,1,1,1,0,1,0,1,1,1,1,1,1), c(2,2,8), 
 dimnames = list( RdWorks=c("Wy", "Wn") , Rain = c("Ry", "Rn"), ev=1:8) )
 print(z &lt;- marrayToMatrix(mtt))

</code></pre>

<hr>
<h2 id='matrixToMarray'>Transformation of the tt matrix of a relation</h2><span id='topic+matrixToMarray'></span>

<h3>Description</h3>

<p>The matrix representation of a relation is converted to the array representation or product space representation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>matrixToMarray(tt, valuenames)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="matrixToMarray_+3A_tt">tt</code></td>
<td>
<p>A (0,1)-matrix or a boolean matrix establishing the relation between two or more variables. The matrix is constructed by placing the variables side by side, as in a truth table representation.</p>
</td></tr>
<tr><td><code id="matrixToMarray_+3A_valuenames">valuenames</code></td>
<td>
<p>A list of the names of the variables with the name of each value of their frame of discernment.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>mtt The array (product space) representation of the <code>tt</code> matrix.
</p>


<h3>Author(s)</h3>

<p>Claude Boivin
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Define  wr_tt, a matrix describing the relation between two variables
wr_tt &lt;- matrix(c(1,rep(0,3),rep(c(1,0),3),0,1,1,1,0,0,
1,0,rep(1,5),0,1,1,0,rep(1,5)), ncol=4, byrow = TRUE)
colnames(wr_tt) &lt;- c("Wy Ry", "Wy Rn", "Wn Ry", "Wn Rn")
rownames(wr_tt) &lt;- nameRows(wr_tt)
vars = list( RdWorks = c("Wy", "Wn") , Rain = c("Ry", "Rn"))
print(zmToa &lt;- matrixToMarray(tt = wr_tt, valuenames = vars ) )
 
</code></pre>

<hr>
<h2 id='mFromMarginal'>Construct m vector of a bca from marginal probabilities</h2><span id='topic+mFromMarginal'></span>

<h3>Description</h3>

<p>Construct m vector of a bca from marginal probabilities
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mFromMarginal(
  marg_probs,
  a = 1e-05,
  simple = FALSE,
  min_prob = 0,
  max_prob = 2
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="mFromMarginal_+3A_marg_probs">marg_probs</code></td>
<td>
<p>vector of marginal probabilities</p>
</td></tr>
<tr><td><code id="mFromMarginal_+3A_a">a</code></td>
<td>
<p>=1e-5 probability that the sample is reliable</p>
</td></tr>
<tr><td><code id="mFromMarginal_+3A_simple">simple</code></td>
<td>
<p>=TRUE whether to use simple support function</p>
</td></tr>
<tr><td><code id="mFromMarginal_+3A_min_prob">min_prob</code></td>
<td>
<p>=0 lower bound on marginal probabilities</p>
</td></tr>
<tr><td><code id="mFromMarginal_+3A_max_prob">max_prob</code></td>
<td>
<p>=2 upper bound on marginal probabilities</p>
</td></tr>
</table>


<h3>Value</h3>

<p>vector of probability masses obtained from uniformly sampling the cut
</p>


<h3>Author(s)</h3>

<p>Peiyuan Zhu
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- c(2,2,1.5,1.2,1,0,0)
mFromMarginal(x, simple=FALSE)
</code></pre>

<hr>
<h2 id='mFromQQ'>Construct a mass vector from qq function.</h2><span id='topic+mFromQQ'></span>

<h3>Description</h3>

<p>Construct a mass vector from qq function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mFromQQ(qq, tt)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="mFromQQ_+3A_qq">qq</code></td>
<td>
<p>Commonality function</p>
</td></tr>
<tr><td><code id="mFromQQ_+3A_tt">tt</code></td>
<td>
<p>logical description matrix from ttmatrixFromQQ</p>
</td></tr>
</table>


<h3>Value</h3>

<p>m A corresponding mass vector
</p>


<h3>Author(s)</h3>

<p>Peiyuan Zhu
</p>


<h3>Examples</h3>

<pre><code class='language-R'>tt&lt;- t(matrix(c(1,0,1,1),ncol = 2))
m&lt;- c(.9,.1)
cnames &lt;- c("yes","no")
x&lt;- bca(tt, m, cnames=cnames)
mFromQQ(x$qq, x$tt)
</code></pre>

<hr>
<h2 id='mFromQQRecursive'>Construct a mass vector from qq function and ttmatrix of focal elements recursively.</h2><span id='topic+mFromQQRecursive'></span>

<h3>Description</h3>

<p>Construct a mass vector from qq function and ttmatrix of focal elements recursively.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mFromQQRecursive(qq, n)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="mFromQQRecursive_+3A_qq">qq</code></td>
<td>
<p>Commonality function</p>
</td></tr>
<tr><td><code id="mFromQQRecursive_+3A_n">n</code></td>
<td>
<p>Frame dimension</p>
</td></tr>
</table>


<h3>Value</h3>

<p>m A corresponding mass vector
</p>


<h3>Author(s)</h3>

<p>Peiyuan Zhu
</p>


<h3>Examples</h3>

<pre><code class='language-R'>tt&lt;- t(matrix(c(1,0,1,1),ncol = 2))
m&lt;- c(.9,.1)
cnames &lt;- c("yes","no")
x&lt;- bca(tt, m, cnames=cnames)
mFromQQ(x$qq, x$tt)
</code></pre>

<hr>
<h2 id='mobiusInvHQQ'>Mobius inversion of commonality function</h2><span id='topic+mobiusInvHQQ'></span>

<h3>Description</h3>

<p>Mobius inversion of commonality function
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mobiusInvHQQ(qq, h)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="mobiusInvHQQ_+3A_qq">qq</code></td>
<td>
<p>Commonality function</p>
</td></tr>
<tr><td><code id="mobiusInvHQQ_+3A_h">h</code></td>
<td>
<p>Hypothesis to be evaluated</p>
</td></tr>
</table>


<h3>Value</h3>

<p>m Mass of the hypothesis
</p>


<h3>Author(s)</h3>

<p>Peiyuan Zhu
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- bca(tt = matrix(c(0,1,1,1,1,0,1,1,1),nrow = 3, byrow = TRUE),
m = c(0.2,0.5, 0.3), cnames = c("a", "b", "c"), varnames = "x", idvar = 1)
qq &lt;- commonality(x$tt,x$spec[,2])
mobiusInvHQQ(qq, matrix(c(0,1,0,1,1,0), nrow = 2, byrow = TRUE))
</code></pre>

<hr>
<h2 id='mrf'>The Captain's Problem. <code>mrf</code>: Relation between variables No Maintenance (M = false) and  Repairs at sea (R)</h2><span id='topic+mrf'></span>

<h3>Description</h3>

<p>This dataset is the <code>tt</code> matrix establishing a set of two relations between the two variables. First, Repairs = true if Maintenance = false in (M x R). We are 20% sure that there will be Repairs if no maintenance. Second, Repairs = false if Maintenance = false in (M x R). We are 20% sure that there will be no repairs if no maintenance.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mrf
</code></pre>


<h3>Format</h3>

<p>A (0,1) matrix with 4 rows and 6 columns.
</p>

<dl>
<dt>[1,c(1,2)]</dt><dd><p>value = 0, not used</p>
</dd>
<dt>[1,3:6]</dt><dd><p>Identification numbers of the two variables. Column 3,4: variable 6; columns 5,6: variable 8</p>
</dd>
<dt>nospec</dt><dd><p>identification number of the specification</p>
</dd>
<dt>m</dt><dd><p>the value of the specification, a number between 0 and 1</p>
</dd>
<dt>true</dt><dd><p>1 if true is part of the specification, 0 otherwise</p>
</dd>
<dt>false</dt><dd><p>1 if false is part of the specification, 0 otherwise</p>
</dd>
</dl>



<h3>Details</h3>

<p>These two relations are implication rules. The remaining mass of 0.6 is allotted to the frame. To construct the <code>tt</code> matrix, we put the variables M and R side by side, as in a truth table representation. Each pair of the subset is described by a row of the matrix as a vector of zeros and ones.
</p>


<h3>Author(s)</h3>

<p>Claude Boivin, Stat.ASSQ
</p>


<h3>Source</h3>

<p>Almond, R.G. [1988] Fusion and Propagation in Graphical Belief Models. Computing Science and Statistics: Proceedings of the 20th Symposium on the Interface. Wegman, Edward J., Gantz, Donald T. and Miller, John J. (ed.). American Statistical Association, Alexandria, Virginia. pp 365&ndash;370.
</p>

<hr>
<h2 id='mrt'>The Captain's Problem. <code>mrt</code>: Relation between variables Maintenance done (M = true) and  Repairs at sea (R)</h2><span id='topic+mrt'></span>

<h3>Description</h3>

<p>This dataset is the <code>tt</code> matrix establishing a set of two relations between the two variables. First, Repairs = true if Maintenance = true in (M x R). We are 10% sure that there will be Repairs if maintenance is done. Second, Repairs = false if Maintenance = true in (M x R). We are 70% sure that there will be no repairs if maintenance is done.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mrt
</code></pre>


<h3>Format</h3>

<p>A (0,1) matrix with 4 rows and 6 columns.
</p>

<dl>
<dt>[1,c(1,2)]</dt><dd><p>value = 0, not used</p>
</dd>
<dt>[1,3:6]</dt><dd><p>Identification numbers of the two variables. Column 3,4: variable 6; columns 5,6: variable 8</p>
</dd>
<dt>nospec</dt><dd><p>identification number of the specification</p>
</dd>
<dt>m</dt><dd><p>the value of the specification, a number between 0 and 1</p>
</dd>
<dt>true</dt><dd><p>1 if true is part of the specification, 0 otherwise</p>
</dd>
<dt>false</dt><dd><p>1 if false is part of the specification, 0 otherwise</p>
</dd>
</dl>



<h3>Details</h3>

<p>These two relations are implication rules. The remaining mass of 0.2 is allotted to the frame. To construct the <code>tt</code> matrix, we put the variables M and R side by side, as in a truth table representation. Each pair of the subset is described by a row of the matrix as a vector of zeros and ones.
</p>


<h3>Author(s)</h3>

<p>Claude Boivin, Stat.ASSQ
</p>


<h3>Source</h3>

<p>Almond, R.G. [1988] Fusion and Propagation in Graphical Belief Models. Computing Science and Statistics: Proceedings of the 20th Symposium on the Interface. Wegman, Edward J., Gantz, Donald T. and Miller, John J. (ed.). American Statistical Association, Alexandria, Virginia. pp 365&ndash;370.
</p>

<hr>
<h2 id='nameCols'>Naming the columns of the <code>tt</code> matrix</h2><span id='topic+nameCols'></span>

<h3>Description</h3>

<p>This utility function makes use of the valuenames  and size parameters  of a set of variables to assign values names to the columns of a <code>tt</code> matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>nameCols(valuenames, size)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="nameCols_+3A_valuenames">valuenames</code></td>
<td>
<p>A list of the names of the variables with the name of the elements of their frame of discernment.</p>
</td></tr>
<tr><td><code id="nameCols_+3A_size">size</code></td>
<td>
<p>A vector of the size of the variables.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A character vector of length equal to the sum of the sizes of the variables.
</p>


<h3>Author(s)</h3>

<p>Claude Boivin
</p>


<h3>Examples</h3>

<pre><code class='language-R'>infoval &lt;- list(A = c("a1", "a2"), B = c("b1", "b2", "b3"))
sizes &lt;- c(2,3)
 print(nameCols(valuenames = infoval, size = sizes) )
</code></pre>

<hr>
<h2 id='nameCols_prod'>Naming the columns of the <code>tt</code> matrix of a product space</h2><span id='topic+nameCols_prod'></span>

<h3>Description</h3>

<p>This utility function makes use of the valuenames  and size parameters  of a set of variables to assign values names to the columns of the <code>tt</code> matrix of their product space.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>nameCols_prod(valuenames, size)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="nameCols_prod_+3A_valuenames">valuenames</code></td>
<td>
<p>A list of the names of the variables with the name of the elements of their frame of discernment.</p>
</td></tr>
<tr><td><code id="nameCols_prod_+3A_size">size</code></td>
<td>
<p>A vector of the size of the variables.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A character vector of length equal to the product of the sizes of the variables.
</p>


<h3>Author(s)</h3>

<p>Claude Boivin
</p>


<h3>Examples</h3>

<pre><code class='language-R'>infoval &lt;- list(A = c("a1", "a2"), B = c("b1", "b2", "b3"))
sizes &lt;- c(2,3)
 print(nameCols_prod(valuenames = infoval, size = sizes) )
</code></pre>

<hr>
<h2 id='nameRows'>Combining the column names of a matrix to construct names for the rows</h2><span id='topic+nameRows'></span>

<h3>Description</h3>

<p>This function determines the name of a row from all the columns of the <code>tt</code> that show 1 for that row.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>nameRows(tt, f)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="nameRows_+3A_tt">tt</code></td>
<td>
<p>A (0,1)-matrix or a boolean matrix.</p>
</td></tr>
<tr><td><code id="nameRows_+3A_f">f</code></td>
<td>
<p>Deprecated. Old name for <code>tt</code> matrix.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The row containing only 1s is called &quot;frame&quot;, to avoid too long a label. The empty set is identified by its code &quot;u00f8&quot;. The &quot;+&quot; sign is used to represent the logical &quot;or&quot; operator. The space &quot; &quot; is used to represent the logical &quot;and&quot; operator. Note that in the case of a product space defined on many variables, row labels can become very long.
</p>


<h3>Value</h3>

<p>A character vector of labels obtained for the rows of the <code>tt</code> matrix. The length of the result is <code>nrow(tt)</code>.
</p>


<h3>Author(s)</h3>

<p>Claude Boivin
</p>


<h3>Examples</h3>

<pre><code class='language-R'>tt &lt;- matrix(c(0,0,0,1,0,0,0,0,1,1,0,1,1,1,1),ncol = 3, byrow = TRUE)
colnames(tt) &lt;- c("A","B","C")
rownames(tt) &lt;-nameRows(tt)
tt
</code></pre>

<hr>
<h2 id='nzdsr'>Normalization of a basic chance assignment</h2><span id='topic+nzdsr'></span>

<h3>Description</h3>

<p>It may occur that the result of the combination of two basic chance assignments with Dempster's Rule of combination contains a non-zero mass allocated to the empty set. The function <code>nzdsr</code> normalizes the result of function <code>dsrwon</code> by dividing the mass value of the non-empty subsets by 1 minus the mass of the empty set.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>nzdsr(x, sparse = "no", comm = "no")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="nzdsr_+3A_x">x</code></td>
<td>
<p>A basic chance assignment, i.e. a object of class bcaspec.</p>
</td></tr>
<tr><td><code id="nzdsr_+3A_sparse">sparse</code></td>
<td>
<p>Put &quot;yes&quot; to use sparse matrix. Default = &quot;no&quot;.</p>
</td></tr>
<tr><td><code id="nzdsr_+3A_comm">comm</code></td>
<td>
<p>Put &quot;yes&quot; to use commonality function. Default = &quot;no&quot;.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>z The normalized basic chance assignment.
</p>


<h3>Author(s)</h3>

<p>Claude Boivin, Peiyuan Zhu
</p>


<h3>References</h3>

<p>Shafer, G., (1976). A Mathematical Theory of Evidence. Princeton University Press, Princeton, New Jersey, pp. 57-61: Dempster's rule of combination.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x1 &lt;- bca(tt= matrix(c(1,0,1,1),nrow = 2, byrow = TRUE), 
m = c(0.9,0.1), cnames = c("yes", "no"),
varnames = "x", idvar = 1)
x2 &lt;- bca(tt = matrix(c(0,1,1,1),nrow = 2, byrow = TRUE), 
m = c(0.5,0.5), cnames = c("yes", "no"), 
varnames = "x", idvar = 1)
print("combination of x1 and x2")
x1x2 &lt;- dsrwon(x1,x2, varname = "x")
nzdsr(x1x2) 
# Test with sparse matrices
x1s=x1
x2s=x2
x1s$tt &lt;- methods::as(x1$tt, "RsparseMatrix")
x2s$tt &lt;- methods::as(x2$tt, "RsparseMatrix")
x1x2s &lt;- dsrwon(x1s, x2s, use_ssnames = TRUE)
nzdsr(x1x2s)

print("normalization of a bca definition.")
y2 &lt;- bca(tt = matrix(c(0,0,0,1,0,0,1,1,1),nrow = 3, 
byrow = TRUE), m = c(0.2,0.5,0.3), 
cnames = c("a", "b", "c"), idvar = 1)
cat("y2")
cat("\  ")
y2
nzdsr(y2)  
</code></pre>

<hr>
<h2 id='nzdsrLogsumexp'>Normalization of a basic chance assignment with logsumexp</h2><span id='topic+nzdsrLogsumexp'></span>

<h3>Description</h3>

<p>It may occur that the result of the combination of two basic chance assignments with Dempster's Rule of combination contains a non-zero mass allocated to the empty set. The function <code>nzdsr</code> normalizes the result of function <code>dsrwon</code> by dividing the mass value of the non-empty subsets by 1 minus the mass of the empty set.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>nzdsrLogsumexp(x, sparse = "no", comm = "no")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="nzdsrLogsumexp_+3A_x">x</code></td>
<td>
<p>A basic chance assignment, i.e. a object of class bcaspec.</p>
</td></tr>
<tr><td><code id="nzdsrLogsumexp_+3A_sparse">sparse</code></td>
<td>
<p>Put &quot;yes&quot; to use sparse matrix. Default = &quot;no&quot;.</p>
</td></tr>
<tr><td><code id="nzdsrLogsumexp_+3A_comm">comm</code></td>
<td>
<p>Put &quot;yes&quot; to use commonality function. Default = &quot;no&quot;.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>z The normalized basic chance assignment.
</p>


<h3>Author(s)</h3>

<p>Claude Boivin, Peiyuan Zhu
</p>


<h3>References</h3>

<p>Shafer, G., (1976). A Mathematical Theory of Evidence. Princeton University Press, Princeton, New Jersey, pp. 57-61: Dempster's rule of combination.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x1 &lt;- bca(tt= matrix(c(1,0,1,1),nrow = 2, byrow = TRUE), 
m = c(0.9,0.1), cnames = c("yes", "no"),
varnames = "x", idvar = 1)
x2 &lt;- bca(tt = matrix(c(0,1,1,1),nrow = 2, byrow = TRUE), 
m = c(0.5,0.5), cnames = c("yes", "no"), 
varnames = "x", idvar = 1)
print("combination of x1 and x2")
x1x2 &lt;- dsrwon(x1,x2, varname = "x")
nzdsr(x1x2) 
# Test with sparse matrices
x1s=x1
x2s=x2
x1s$tt &lt;- methods::as(x1$tt, "RsparseMatrix")
x2s$tt &lt;- methods::as(x2$tt, "RsparseMatrix")
x1x2s &lt;- dsrwon(x1s, x2s, use_ssnames = TRUE)
nzdsr(x1x2s)

print("normalization of a bca definition.")
y2 &lt;- bca(tt = matrix(c(0,0,0,1,0,0,1,1,1),nrow = 3, 
byrow = TRUE), m = c(0.2,0.5,0.3), 
cnames = c("a", "b", "c"), idvar = 1)
cat("y2")
cat("\  ")
y2
nzdsr(y2)  
</code></pre>

<hr>
<h2 id='peeling'>The peeling algorithm</h2><span id='topic+peeling'></span>

<h3>Description</h3>

<p>An implementation of the peeling algorithm based on its description in terms of hypergraphs by R. Almond [1989].<br />
</p>


<h3>Usage</h3>

<pre><code class='language-R'>peeling(vars_def, hgm, hg_rel_names, elim_order, verbose = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="peeling_+3A_vars_def">vars_def</code></td>
<td>
<p>A list of variables and their possible values. Concatenate the valuenames parameter of all the variables of the hypergraph to obtain this list.</p>
</td></tr>
<tr><td><code id="peeling_+3A_hgm">hgm</code></td>
<td>
<p>The incidence matrix of the hypergraph (bipartite graph), which is the  description of the relations between the variables. The variables are the nodes of the hypergraph, and the relations are the edges. Each column describes a relation between the variables by a (0,1) vector. A &quot;1&quot; indicates that a variable belongs to the relation and a &quot;0&quot; not. This matrix must have row and column names. These names are used to show the graph eventually. They need not be the same as variables and relations names of the set of bca's to be analyzed. Use short names to obtain a clear graph.</p>
</td></tr>
<tr><td><code id="peeling_+3A_hg_rel_names">hg_rel_names</code></td>
<td>
<p>The names of the relations, which are objects of class &quot;bcaspec&quot;.</p>
</td></tr>
<tr><td><code id="peeling_+3A_elim_order">elim_order</code></td>
<td>
<p>The order of elimination of the variables. A vector of length <code>nrow(hgm)</code>. Variables are identified by numbers. The first number gives the first variable to eliminate. The variable of interest comes last.</p>
</td></tr>
<tr><td><code id="peeling_+3A_verbose">verbose</code></td>
<td>
<p>= TRUE: print steps on the console. Default = FALSE.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The peeling algorithm works on an undirected graph. Nodes of the graph (variables) are removed one by one until only the variable of interest remains. An order of elimination (peeling) of the variables must be chosen by the user. No algorithm is provided for that matter. At each step, a procedure of extension is applied to the bca's to merge, and marginalization is applied to eliminate a variable. The marginalization has the effect to integrate in the remaining nodes the information of the eliminated variable.
</p>


<h3>Value</h3>

<p>A bca class object.
</p>


<h3>Author(s)</h3>

<p>Claude Boivin
</p>


<h3>References</h3>


<ul>
<li><p> Almond, R. G. (1989) Fusion and Propagation of Graphical Belief Models: An Implementation and an Example. Ph. D. Thesis, the Department of Statistics, Harvard University. 288 pages (for the description of the peeling algorithm, see pages 52-53).
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'># Zadeh's Example
# 1. Defining variables and relations 
# (for details, see vignette: Zadeh_Example)
e1 &lt;- bca(tt = matrix(c(1,0,0,1,1,1), ncol = 2, byrow = TRUE),
 m = c(0.99, 0.01, 0), cnames = c("M", "T"), 
 varnames = "D1", idvar = 1)
e2 &lt;- bca(tt = matrix(c(1,0,0,1,1,1), ncol = 2, byrow = TRUE),
m = c(0.99, 0.01, 0), cnames = c("C", "T"), 
varnames = "D2", idvar = 2)
p_diag &lt;- bca(tt = matrix(c(1,1,1), ncol = 3, byrow = TRUE), 
m = 1, cnames = c("M", "T", "C"), 
varnames = "D", idvar = 3)
# Defining the relation between the variables
# tt matrix
tt_r1 &lt;- matrix(c(1,0,1,0,1,0,0,1,0,1,0,0,0,1,
1,0,0,1,1,0,0,1,0,0,1,0,1,0,0,1,1,0,0,1,0,
0,1,1,0,0,0,1,0,1,0,1,0,1,0,1,1,1,1,1,1,1), 
ncol = 7,byrow = TRUE)
colnames(tt_r1) = c("M", "T", "C", "T", "M", "T", "C")
# The mass function
spec_r1 &lt;- matrix(c(rep(1,7),2, rep(1,7), 0), ncol = 2, dimnames = list(NULL, c("specnb", "mass"))) 
# Variables numbers and dimension of their frame
info_r1 &lt;- matrix(c(1:3, 2,2,3), ncol = 2, dimnames = list(NULL, c("varnb", "size")) )
#  The relation between e1, e2 and a patient p
r1 &lt;- bcaRel(tt = tt_r1, spec = spec_r1, infovar = info_r1,
 varnames = c("D1", "D2", "D"), relnb = 1)

# 2. Setting the incidence matrix of the grapph
rel1 &lt;- 1*1:3 %in% r1$infovar[,1]
ev1 &lt;- 1*1:3 %in% e1$infovar[,1]
ev2 &lt;- 1*1:3 %in% e2$infovar[,1]
meddiag_hgm &lt;- matrix(c(ev1,ev2, rel1), ncol = 3, 
dimnames = list(c("D1", "D2", "D"), c("e1","e2", "r1")))

# 3. Setting the names of the variables and their frame of discernment
meddiag_vars1 &lt;- c(e1$valuenames, e2$valuenames, p_diag$valuenames)

# 4. Names of bca specifications (evidence and relations)
meddiag_rel_names &lt;- c("e1", "e2", "r1")

# 5. Order of elimination of variables
elim_order &lt;- c(1,2,3)

tabresul(peeling(vars_def = meddiag_vars1, hgm = meddiag_hgm,
hg_rel_names = meddiag_rel_names, elim_order = c(1, 2, 3)) )

</code></pre>

<hr>
<h2 id='plautrans'>Plausibility transformation of the singletons of a frame</h2><span id='topic+plautrans'></span>

<h3>Description</h3>

<p>Given a mass function defined on some subsets of a frame <code class="reqn">\Theta</code>, the application of the plausibility transformation to the singletons of <code class="reqn">\Theta</code> yields the probability distribution associated with this mass function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plautrans(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plautrans_+3A_x">x</code></td>
<td>
<p>A bca mass function.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>We compute the plausibility measure of all the singletons of the frame of discernment. The probability distribution of the singletons is obtained from their plausibility measures.
</p>


<h3>Value</h3>

<p>The matrix of singletons with their plausibility transformation added in the last column.
</p>


<h3>Author(s)</h3>

<p>Claude Boivin
</p>


<h3>References</h3>

<p>Cobb, B. R. and Shenoy, P.P. (2006). On the plausibility transformation method for translating belief function models to probability models. Journal of Approximate Reasoning, 41(3), April 2006, 314&ndash;330.
</p>


<h3>Examples</h3>

<pre><code class='language-R'> 
x &lt;- bca(tt = matrix(c(0,1,1,1,1,0,1,1,1),nrow = 3, 
byrow = TRUE), m = c(0.2,0.5, 0.3), 
cnames = c("a", "b", "c"), 
varnames = "x", idvar = 1)
plautrans(x)
</code></pre>

<hr>
<h2 id='productSpace'>Product space representation of a relation</h2><span id='topic+productSpace'></span>

<h3>Description</h3>

<p>This utility function takes the input matrix of a relation between two or more variables and yields its product space representation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>productSpace(tt, specnb, infovar)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="productSpace_+3A_tt">tt</code></td>
<td>
<p>A (0,1) or boolean matrix, where the variables are set side by side, as in a truth table. Each variable has a number of columns equal to the number of possible values.</p>
</td></tr>
<tr><td><code id="productSpace_+3A_specnb">specnb</code></td>
<td>
<p>A vector of integers ranging from 1 to <code>k</code>, where <code>k</code> is the number of subsets of the <code>tt</code> matrix. Values must start at one and can be increased by 1 or not. They determine the partitioning of the rows of the <code>tt</code> matrix between the <code>k</code> subsets.</p>
</td></tr>
<tr><td><code id="productSpace_+3A_infovar">infovar</code></td>
<td>
<p>A two-column matrix containing identification numbers of the variables and the number of elements of each variable (size of the frame).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The matrix of the product space representation of the relation.
</p>


<h3>Author(s)</h3>

<p>Claude Boivin
</p>


<h3>Examples</h3>

<pre><code class='language-R'> ttfw &lt;- matrix(c(1,0,1,0,0,1,0,1,1,1,1,1),nrow = 3,
  byrow = TRUE, 
  dimnames = list(NULL, c("foul", "fair", "foul", "fair")) )
 specfw &lt;- c(1,1,2) 
 infovarfw &lt;- matrix(c(5,7,2,2), ncol = 2, 
 dimnames = list(NULL, c("varnb", "size")) )
 rownames(ttfw) &lt;- nameRows(ttfw)
 ttfw
productSpace(tt = ttfw, specnb = specfw, infovar = infovarfw)
</code></pre>

<hr>
<h2 id='reduction'>Summary of a vector for any operator.</h2><span id='topic+reduction'></span><span id='topic+aplRDV'></span>

<h3>Description</h3>

<p>This utility function is used to obtain a summary of a vector of data for many operators. The function is taken from the project APL in R (<a href="https://rpubs.com/deleeuw/158476">https://rpubs.com/deleeuw/158476</a>).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>reduction(x, f)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="reduction_+3A_x">x</code></td>
<td>
<p>A vector of numbers or a character string.</p>
</td></tr>
<tr><td><code id="reduction_+3A_f">f</code></td>
<td>
<p>The operator. Must be compatible with the type of input vector (numeric or character)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The result of applying the chosen operator to all the elements of the vector is an object of length 1.
</p>


<h3>Author(s)</h3>

<p>Claude Boivin
</p>


<h3>References</h3>


<ul>
<li><p> Jan de Leeuw and Masanao Yajima (March 07, 2016) <em>APL in R (Version 009)</em>, Source code. <a href="https://rpubs.com/deleeuw/158476">https://rpubs.com/deleeuw/158476</a>
</p>
</li>
<li><p> G. Helzer. (1989): <em>An Encyclopedia of APL</em>, second edition, I-APL LTD, St. Albans, G.B.
</p>
</li>
<li><p>  L. Gilman and A. J. Rose.(1974): <em>APL an Interactive Approach</em>, Second Edition, John Wiley, New-York.
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'> reduction(c(1,2,3,4), f = "-")
 reduction(c(1,0,1,1,0), f = "|")
 reduction(c("a", "b", "c"), f = "paste")
 
</code></pre>

<hr>
<h2 id='shape'>Obtain dimensions of an array or length of a vector with a single command</h2><span id='topic+shape'></span><span id='topic+aplShape'></span>

<h3>Description</h3>

<p><code>shape</code> returns the dimension of given array or returns the length of a given vector. The function is taken from the project APL in R (<a href="https://rpubs.com/deleeuw/158476">https://rpubs.com/deleeuw/158476</a>).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>shape(a)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="shape_+3A_a">a</code></td>
<td>
<p>An array or a vector.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The dimension of the array <code>a</code> or the length of the vector <code>a</code>.
</p>


<h3>Author(s)</h3>

<p>Claude Boivin
</p>


<h3>References</h3>


<ul>
<li><p> Jan de Leeuw and Masanao Yajima (March 07, 2016) <em>APL in R (Version 009)</em>, Source code. <a href="https://rpubs.com/deleeuw/158476">https://rpubs.com/deleeuw/158476</a>
</p>
</li>
<li><p> G. Helzer. (1989): <em>An Encyclopedia of APL</em>, second edition, I-APL LTD, St. Albans, G.B.
</p>
</li>
<li><p>  L. Gilman and A. J. Rose.(1974): <em>APL an Interactive Approach</em>, Second Edition, John Wiley, New-York.
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>shape(array(c(1:6), c(2,3)))
shape(c("a", "b"))
</code></pre>

<hr>
<h2 id='swr'>The Captain's Problem. <code>swr</code>: Relation between variables Sailing delay (S), Weather at sea (W), and Repairs at sea (R)</h2><span id='topic+swr'></span>

<h3>Description</h3>

<p>This dataset is the <code>tt</code> matrix establishing a relation between S, W and R, where S = 0:3, W = (foul, fair) and R = (true, false). The goal of this relation is to account for other causes of sailing delay. All the elements (s,w,r) of (S x W x R) where W or R is true add one day of sailing delay. We put a mass value of 0.9 to this subset. The remaining mass of 0.1 is allotted to the frame.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>swr
</code></pre>


<h3>Format</h3>

<p>An integer matrix with 6 rows and 10 columns.
</p>

<dl>
<dt>[1,c(1,2)]</dt><dd><p>value = 0, not used</p>
</dd>
<dt>[1,3:10]</dt><dd><p>Identification numbers of the three variables. Column 3 to 6: variable 3; columns 7,8: variable 7, columns 9,10: variable 8</p>
</dd>
<dt>nospec</dt><dd><p>identification number of the specification</p>
</dd>
<dt>m</dt><dd><p>the value of the specification, a number between 0 and 1</p>
</dd>
<dt>3</dt><dd><p>1 if 3 is part of the specification, 0 otherwise</p>
</dd>
<dt>2</dt><dd><p>1 if 2 is part of the specification, 0 otherwise</p>
</dd>
<dt>1</dt><dd><p>1 if 1 is part of the specification, 0 otherwise</p>
</dd>
<dt>0</dt><dd><p>1 if 0 is part of the specification, 0 otherwise</p>
</dd>
<dt>foul</dt><dd><p>1 if foul is part of the specification, 0 otherwise</p>
</dd>
<dt>fair</dt><dd><p>1 if fair is part of the specification, 0 otherwise</p>
</dd>
<dt>true</dt><dd><p>1 if true is part of the specification, 0 otherwise</p>
</dd>
<dt>false</dt><dd><p>1 if false is part of the specification, 0 otherwise</p>
</dd>
</dl>



<h3>Details</h3>

<p>To construct the <code>tt</code> matrix, we put the variables S, W, R side by side, as in a truth table representation. Each triplet of the subset is described by a row of the matrix as a vector of zeros and ones.
</p>


<h3>Author(s)</h3>

<p>Claude Boivin, Stat.ASSQ
</p>


<h3>Source</h3>

<p>Almond, R.G. [1988] Fusion and Propagation in Graphical Belief Models. Computing Science and Statistics: Proceedings of the 20th Symposium on the Interface. Wegman, Edward J., Gantz, Donald T. and Miller, John J. (ed.). American Statistical Association, Alexandria, Virginia. pp 365&ndash;370.
</p>

<hr>
<h2 id='tabresul'>Prepare a table of results</h2><span id='topic+tabresul'></span>

<h3>Description</h3>

<p>This utility function is a more detailed version of the <code>belplau</code> function. Different tables of measures of belief, plausibility and of the plausibility ratio can be obtained, namely by removing subsets with zero mass if present, or by asking for singletons only. Unlike function <code>belplau</code>, function <code>tabresul</code> does not reconstruct the row names from the column names. You can assign short rownames of your choice to the tt matrix of your resulting bca before calling function <code>tabresul</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tabresul(x, singletonsOnly = FALSE, removeZeroes = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="tabresul_+3A_x">x</code></td>
<td>
<p>A basic chance assignment (bca)</p>
</td></tr>
<tr><td><code id="tabresul_+3A_singletonsonly">singletonsOnly</code></td>
<td>
<p>= TRUE reduces the table of results to elementary events (singletons).</p>
</td></tr>
<tr><td><code id="tabresul_+3A_removezeroes">removeZeroes</code></td>
<td>
<p>= TRUE removes subsets with 0 mass.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of two elements: </p>

<ul>
<li><p> mbp The table of focal elements with the addition of their associated mass, degree of belief, plausibility and the plausibility ratio.
</p>
</li>
<li><p> con The measure of conflict between subsets.
</p>
</li></ul>



<h3>Author(s)</h3>

<p>Claude Boivin
</p>


<h3>Examples</h3>

<pre><code class='language-R'> 
x &lt;- bca(tt = matrix(c(0,1,1,1,1,0,1,1,1),nrow = 3,
byrow = TRUE), m = c(0.2,0.5, 0.3), 
cnames = c("a", "b", "c"), 
varnames = "x", idvar = 1)
y &lt;- bca(tt = matrix(c(1,0,0,1,1,1),nrow = 2, 
byrow = TRUE), m = c(0.6, 0.4),  
cnames = c("a", "b", "c"), varnames = "y", idvar = 1)
xy &lt;- dsrwon(x,y)
xyNorm &lt;- nzdsr(xy)
tabresul(xyNorm) 
## print("Show all elementary events")
xy1 &lt;- addTobca(nzdsr(dsrwon(x,y)), 
matrix(c(0,1,0,0,0,1), 
nrow = 2, byrow = TRUE))
tabresul(xy1)
## print("Remove focal elements with 0 mass")
tabresul(xy1, removeZeroes = TRUE)
print("Retain singletons only")
tabresul(xy1, singletonsOnly = TRUE)
</code></pre>

<hr>
<h2 id='ttmatrix'>Construct a description matrix from a list of subsets names.</h2><span id='topic+ttmatrix'></span>

<h3>Description</h3>

<p>Construct a description matrix from a list of subsets names.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ttmatrix(x, sparse = "no")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ttmatrix_+3A_x">x</code></td>
<td>
<p>A list of names</p>
</td></tr>
<tr><td><code id="ttmatrix_+3A_sparse">sparse</code></td>
<td>
<p>= c(&quot;yes&quot;,&quot;no&quot;) whether to use sparse matrix. Default = &quot;no&quot;.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>ttmat A corresponding logical description matrix
</p>


<h3>Author(s)</h3>

<p>Claude Boivin
</p>


<h3>Examples</h3>

<pre><code class='language-R'>subsets_names &lt;- list(c("b", "c"), "b", c("a", "b", "c"))
ttmatrix(subsets_names)
znames &lt;- list("empty", "a", c("b", "c"), c("a", "b"), c("a", "b", "c") )
print(ttmatrix(znames) )
print(ttmatrix(znames, sparse = "yes") )
</code></pre>

<hr>
<h2 id='ttmatrixFromMarginal'>Construct tt matrix of a bca from marginal probabilities</h2><span id='topic+ttmatrixFromMarginal'></span>

<h3>Description</h3>

<p>Construct tt matrix of a bca from marginal probabilities
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ttmatrixFromMarginal(
  marg_probs,
  from_above = FALSE,
  simple = FALSE,
  min_prob = 0,
  max_prob = 2
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ttmatrixFromMarginal_+3A_marg_probs">marg_probs</code></td>
<td>
<p>marginal probabilities</p>
</td></tr>
<tr><td><code id="ttmatrixFromMarginal_+3A_from_above">from_above</code></td>
<td>
<p>=TRUE whether to cut marginal probabilities from above</p>
</td></tr>
<tr><td><code id="ttmatrixFromMarginal_+3A_simple">simple</code></td>
<td>
<p>=TRUE whether to use simple support function</p>
</td></tr>
<tr><td><code id="ttmatrixFromMarginal_+3A_min_prob">min_prob</code></td>
<td>
<p>=0 lower bound on marginal probabilities</p>
</td></tr>
<tr><td><code id="ttmatrixFromMarginal_+3A_max_prob">max_prob</code></td>
<td>
<p>=2 upper bound on marginal probabilities</p>
</td></tr>
</table>


<h3>Value</h3>

<p>matrix of possible subsets obtained from the cuts
</p>


<h3>Author(s)</h3>

<p>Peiyuan Zhu
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- c(2,2,1.5,1.2,1,0,0)
ttmatrixFromMarginal(x, FALSE)
</code></pre>

<hr>
<h2 id='ttmatrixFromQQ'>Construct a description matrix from qq function.</h2><span id='topic+ttmatrixFromQQ'></span>

<h3>Description</h3>

<p>Construct a description matrix from qq function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ttmatrixFromQQ(qq, n, valuenames)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ttmatrixFromQQ_+3A_qq">qq</code></td>
<td>
<p>Commonality function</p>
</td></tr>
<tr><td><code id="ttmatrixFromQQ_+3A_n">n</code></td>
<td>
<p>Dimension of the frame</p>
</td></tr>
<tr><td><code id="ttmatrixFromQQ_+3A_valuenames">valuenames</code></td>
<td>
<p>Vector of valuenames</p>
</td></tr>
</table>


<h3>Value</h3>

<p>ttmat A corresponding logical description matrix
</p>


<h3>Author(s)</h3>

<p>Peiyuan Zhu
</p>


<h3>Examples</h3>

<pre><code class='language-R'>tt&lt;- t(matrix(c(1,0,1,1),ncol = 2))
m&lt;- c(.9,.1)
cnames &lt;- c("yes","no")
x&lt;- bca(tt, m, cnames=cnames)
ttmatrixFromQQ(x$qq,as.integer(x$infovar[1,2]), unlist(x$valuenames))
</code></pre>

<hr>
<h2 id='ttmatrixPartition'>Create partition matrix</h2><span id='topic+ttmatrixPartition'></span>

<h3>Description</h3>

<p>Create partition matrix
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ttmatrixPartition(n, m)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ttmatrixPartition_+3A_n">n</code></td>
<td>
<p>partition size</p>
</td></tr>
<tr><td><code id="ttmatrixPartition_+3A_m">m</code></td>
<td>
<p>size of the set to be partitioned</p>
</td></tr>
</table>


<h3>Value</h3>

<p>h binary partition matrix of size n by m
</p>


<h3>Author(s)</h3>

<p>Peiyuan Zhu
</p>


<h3>Examples</h3>

<pre><code class='language-R'># test singleton hypotheses
x &lt;- bca(tt = matrix(c(1,1,0,1,1,1), nrow = 2, byrow = TRUE), m = c(0.8, 0.2), cnames = c(1,2,3))
pa &lt;- ttmatrixPartition(x$infovar[2], x$infovar[2])
belplau(x, h=pa)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
