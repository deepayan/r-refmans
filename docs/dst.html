<!DOCTYPE html><html><head><title>Help for package dst</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {dst}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#addTobca'><p>Add some elements of 0 mass to an existing basic chance assignment.</p></a></li>
<li><a href='#ads'><p>The Captain's Problem. <code>ads</code>: Relation between variables Arrival (A), Departure delay (D) and Sailing delay (S)</p></a></li>
<li><a href='#bca'><p>Basic chance assignment mass function</p></a></li>
<li><a href='#bcaPrint'><p>Simple printing of the <code>tt</code> matrix and mass values of a basic chance assignment (bca)</p></a></li>
<li><a href='#bcaRel'><p>Representation of a mass function in a product space</p></a></li>
<li><a href='#bcaTrunc'><p>Truncation of a basic chance assignment mass function</p></a></li>
<li><a href='#belplau'><p>Calculation of the degrees of Belief and Plausibility of a basic chance assignment (bca).</p></a></li>
<li><a href='#decode'><p>Find the value in base 10 of a number coded in another base</p></a></li>
<li><a href='#dlfm'><p>The Captain's Problem. <code>dlfm</code>: Relation between variables Departure delay (D), Loading delay (L), Forecast of the weather (F), Maintenance delay (M)</p></a></li>
<li><a href='#dotprod'><p>Generalized inner product of two matrices</p></a></li>
<li><a href='#doubles'><p>Remove duplicate rows in a two-dimensional table.</p></a></li>
<li><a href='#dsrwon'><p>Combination of two mass functions</p></a></li>
<li><a href='#dst-package'><p>Manipulation and combination of belief functions</p></a></li>
<li><a href='#elim'><p>Reduction of a relation</p></a></li>
<li><a href='#encode'><p>Convert a value to its representation in another chosen base</p></a></li>
<li><a href='#extmin'><p>Extension of a relation</p></a></li>
<li><a href='#fw'><p>The Captain's Problem. <code>fw</code>: Relation between variables Forecast of the weather (F) and  Weather at sea (W)</p></a></li>
<li><a href='#inters'><p>Intersection of two tables of propositions</p></a></li>
<li><a href='#marrayToMatrix'><p>Transformation of an array data to its matrix representation</p></a></li>
<li><a href='#matrixToMarray'><p>Transformation of the tt matrix of a relation</p></a></li>
<li><a href='#mrf'><p>The Captain's Problem. <code>mrf</code>: Relation between variables No Maintenance (M = false) and  Repairs at sea (R)</p></a></li>
<li><a href='#mrt'><p>The Captain's Problem. <code>mrt</code>: Relation between variables Maintenance done (M = true) and  Repairs at sea (R)</p></a></li>
<li><a href='#nameCols'><p>Naming the columns of the <code>tt</code> matrix</p></a></li>
<li><a href='#nameCols_prod'><p>Naming the columns of the <code>tt</code> matrix of a product space</p></a></li>
<li><a href='#nameRows'><p>Combining the column names of a matrix to construct names for the rows</p></a></li>
<li><a href='#nzdsr'><p>Normalization of a basic chance assignment</p></a></li>
<li><a href='#peeling'><p>The peeling algorithm</p></a></li>
<li><a href='#plautrans'><p>Plausibility transformation of the singletons of a frame</p></a></li>
<li><a href='#productSpace'><p>Product space representation of a relation</p></a></li>
<li><a href='#reduction'><p>Summary of a vector for any operator.</p></a></li>
<li><a href='#shape'><p>Obtain dimensions of an array or length of a vector with a single command</p></a></li>
<li><a href='#swr'><p>The Captain's Problem. <code>swr</code>: Relation between variables Sailing delay (S), Weather at sea (W), and Repairs at sea (R)</p></a></li>
<li><a href='#tabresul'><p>Prepare a table of results</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Using the Theory of Belief Functions</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>Version:</td>
<td>1.5.2</td>
</tr>
<tr>
<td>Date:</td>
<td>2023-11-15</td>
</tr>
<tr>
<td>Author:</td>
<td>Claude Boivin &lt;webapp.cb@gmail.com&gt;</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Claude Boivin &lt;webapp.cb@gmail.com&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Using the Theory of Belief Functions for evidence calculus. Basic probability assignments, or mass functions, can be defined on the subsets of a set of possible values and combined. A mass function can be extended to a larger frame. Marginalization, i.e. reduction to a smaller frame can also be done. These features can be combined to analyze small belief networks and take into account situations where information cannot be satisfactorily described by probability distributions.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/RAPLER/dst-1/issues">https://github.com/RAPLER/dst-1/issues</a></td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 2.10)</td>
</tr>
<tr>
<td>Imports:</td>
<td>parallel</td>
</tr>
<tr>
<td>Suggests:</td>
<td>igraph, knitr, rmarkdown, testthat</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-11-16 12:59:49 UTC; chrono03</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-11-16 14:50:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='addTobca'>Add some elements of 0 mass to an existing basic chance assignment.</h2><span id='topic+addTobca'></span>

<h3>Description</h3>

<p>Given a previously defined basic chance assignment (bca), the user may want to add some elements of the set of possible values or some subsets, even if they have zero mass value. This feature is useful, for example, to examine the measure of plausibility of these elements or subsets of zero mass value.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>addTobca(x, tt, f)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="addTobca_+3A_x">x</code></td>
<td>
<p>A basic chance assignment (see <code><a href="#topic+bca">bca</a></code>).</p>
</td></tr>
<tr><td><code id="addTobca_+3A_tt">tt</code></td>
<td>
<p>A matrix constructed in a boolean style (0,1) or a boolean matrix. The number of columns of the matrix <code>tt</code> must match the number of columns of the <code>tt</code> matrix of <code>x</code> (see <code><a href="#topic+bca">bca</a></code>). Each row of the matrix identify a subset of the set of possible values.</p>
</td></tr>
<tr><td><code id="addTobca_+3A_f">f</code></td>
<td>
<p>Deprecated. Old name for <code>tt</code> matrix.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>x The original basic chance assignment <code>x</code> augmented with the added subsets defined by <code>tt</code>.
</p>


<h3>Author(s)</h3>

<p>Claude Boivin
</p>


<h3>Examples</h3>

<pre><code class='language-R'> 
y &lt;- bca(tt = matrix(c(1,0,0,1,1,1),nrow=2, byrow = TRUE), 
m = c(0.6, 0.4),  cnames = c("a", "b", "c"), idvar = 1)
addTobca(y, matrix(c(0,1,0,0,0,1, 0,1,1), nrow = 3, byrow = TRUE))
x &lt;- bca(tt = matrix(c(0,1,1,1,1,0,1,1,1),nrow=3, 
byrow = TRUE), m=c(0.2,0.5, 0.3), 
cnames = c("a", "b", "c"), idvar = 1)
xy &lt;- dsrwon(x,y)
xy1 &lt;- addTobca(nzdsr(xy), matrix(c(0,1,0,0,0,1), nrow = 2, byrow = TRUE))
xy1
addTobca(x, tt = diag(1,  ncol(x$tt) ) ) # add all singletons

</code></pre>

<hr>
<h2 id='ads'>The Captain's Problem. <code>ads</code>: Relation between variables Arrival (A), Departure delay (D) and Sailing delay (S)</h2><span id='topic+ads'></span>

<h3>Description</h3>

<p>This dataset is the <code>tt</code> matrix establishing the relation A = D + S, where A = 0:6, D = 0:3 and S = 0:3. The subset made of all the triplets (a,d,s) of (A x D x S) where a = d + s is true has a mass value of 1. To construct the <code>tt</code> matrix, we put the variables A, D, S side by side, as in a truth table representation. Each triplet of the subset is described by a row of the matrix as a vector of zeros and ones.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ads
</code></pre>


<h3>Format</h3>

<p>An integer matrix with 18 rows and 17 columns
</p>

<dl>
<dt>[1, c(1,2)]</dt><dd><p>value = 0, not used</p>
</dd>
<dt>[1, 3:17]</dt><dd><p>Identification numbers of the three variables. Column 3 to 9: variable 1; column 10 to 13: variable 2; column 14 to 17: variable 3.</p>
</dd>
<dt>nospec</dt><dd><p>identification number of the specification</p>
</dd>
<dt>m</dt><dd><p>the value of the specification, a number between 0 and 1</p>
</dd>
<dt>6</dt><dd><p>1 if 6 is part of the specification, 0 otherwise</p>
</dd>
<dt>5</dt><dd><p>1 if 5 is part of the specification, 0 otherwise</p>
</dd>
<dt>4</dt><dd><p>1 if 4 is part of the specification, 0 otherwise</p>
</dd>
<dt>3</dt><dd><p>1 if 3 is part of the specification, 0 otherwise</p>
</dd>
<dt>2</dt><dd><p>1 if 2 is part of the specification, 0 otherwise</p>
</dd>
<dt>1</dt><dd><p>1 if 1 is part of the specification, 0 otherwise</p>
</dd>
<dt>0</dt><dd><p>1 if 0 is part of the specification, 0 otherwise</p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>Claude Boivin, Stat.ASSQ
</p>


<h3>Source</h3>

<p>Almond, R.G. [1988] Fusion and Propagation in Graphical Belief Models. Computing Science and Statistics: Proceedings of the 20th Symposium on the Interface. Wegman, Edward J., Gantz, Donald T. and Miller, John J. (ed.). American Statistical Association, Alexandria, Virginia. pp 365&ndash;370.
</p>

<hr>
<h2 id='bca'>Basic chance assignment mass function</h2><span id='topic+bca'></span><span id='topic+bpa'></span>

<h3>Description</h3>

<p>Function <code>bca</code> is used to define subsets of a finite set <code class="reqn">\Theta</code> of possible values and to assign their corresponding mass value.<br />
The set <code class="reqn">\Theta</code> is called the frame of discernment. Each subset <code class="reqn">A</code> of  <code class="reqn">Theta</code> with a positive mass value is called a focal element or a proposition. The associated mass value is a number of the <code>(0,1]</code> interval, called &quot;basic chance assignment&quot; (the basic probability assignment of Shafer's book). All other subsets that have not received a positive mass value are assumed to have a mass value of zero.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bca(
  tt,
  m,
  cnames = NULL,
  con = NULL,
  idvar = NULL,
  infovar = NULL,
  varnames = NULL,
  valuenames = NULL,
  inforel = NULL,
  f,
  varnb,
  infovarnames
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bca_+3A_tt">tt</code></td>
<td>
<p>A (0,1)-matrix or a boolean matrix. The number of columns must match the number of elements (values) of the frame of discernment <code class="reqn">\Theta</code>. Each row is a subset of <code class="reqn">\Theta</code>. The last row is the frame <code class="reqn">\Theta</code>, represented by a vector of 1's.</p>
</td></tr>
<tr><td><code id="bca_+3A_m">m</code></td>
<td>
<p>A numeric vector of length equal to the number of rows of the matrix  <code>tt</code>. Values of <code>m</code> must lie in the interval <code>(0,1]</code> and must add to one. The mass <code>m(k)</code> represents the chance value allotted to the proposition represented by the row <code>k</code> of the matrix <code>tt</code>.</p>
</td></tr>
<tr><td><code id="bca_+3A_cnames">cnames</code></td>
<td>
<p>A character vector containing the names of the elements of the frame of discernment <code class="reqn">\Theta</code>. The length must be equal to the number of elements of <code class="reqn">\Theta</code>. The names are first searched in the <code>valuenames</code> parameter. If NULL, column names of the matrix <code>tt</code> are taken if present. Otherwise, names are generated.</p>
</td></tr>
<tr><td><code id="bca_+3A_con">con</code></td>
<td>
<p>The measure of conflict can be provided. 0 by default.</p>
</td></tr>
<tr><td><code id="bca_+3A_idvar">idvar</code></td>
<td>
<p>The number given to the variable. A number is necessary to manage relations between variables  and make computations on a graph. 0 if omitted.</p>
</td></tr>
<tr><td><code id="bca_+3A_infovar">infovar</code></td>
<td>
<p>A two-column matrix containing variable identification numbers and the number of elements of the variable. Generated if omitted.</p>
</td></tr>
<tr><td><code id="bca_+3A_varnames">varnames</code></td>
<td>
<p>The name of the variable. Generated if omitted.</p>
</td></tr>
<tr><td><code id="bca_+3A_valuenames">valuenames</code></td>
<td>
<p>A list of the names of the variables with the name of the elements of their frame of discernment.</p>
</td></tr>
<tr><td><code id="bca_+3A_inforel">inforel</code></td>
<td>
<p>Not used here. Defined within function <code><a href="#topic+bcaRel">bcaRel</a></code>.</p>
</td></tr>
<tr><td><code id="bca_+3A_f">f</code></td>
<td>
<p>Deprecated. Old name for <code>tt</code> matrix.</p>
</td></tr>
<tr><td><code id="bca_+3A_varnb">varnb</code></td>
<td>
<p>Deprecated. Old name for <code>idvar</code>.</p>
</td></tr>
<tr><td><code id="bca_+3A_infovarnames">infovarnames</code></td>
<td>
<p>Deprecated. Old name for <code>varnames</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>y An object of class <code>bcaspec</code> called a bca for &quot;basic chance assignment&quot;: </p>

<ul>
<li><p> tt  The table of focal elements. Rownames of the matrix of focal elements are generated from the column names of the elements of the frame. See <code><a href="#topic+nameRows">nameRows</a></code> for details.
</p>
</li>
<li><p> spec  A two column matrix. First column contains numbers given to the subsets, 1 to  <code>nrow(tt)</code>. Second column contains the mass values of the subsets. 
</p>
</li>
<li><p> con  The measure of conflict.
</p>
</li>
<li><p> infovar  The number of the variable and the size of the frame of discernment.
</p>
</li>
<li><p> varnames  The name of the variable.
</p>
</li>
<li><p> valuenames  A list of length 1 consisting of the name of the variable with the names of the elements of the frame of discernment (the column names of the <code>tt</code> matrix).
</p>
</li>
<li><p> inforel  Set at 0. used in function <code><a href="#topic+bcaRel">bcaRel</a></code>.
</p>
</li></ul>



<h3>Author(s)</h3>

<p>Claude Boivin
</p>


<h3>References</h3>


<ul>
<li><p> Shafer, G., (1976). A Mathematical Theory of Evidence. Princeton University Press, Princeton, New Jersey, p. 38: Basic probability assignment.
</p>
</li>
<li><p> Guan, J. W. and Bell, D. A., (1991). Evidence Theory and its Applications. Elsevier Science Publishing company inc., New York, N.Y., p. 29: Mass functions and belief functions 
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>tt&lt;- t(matrix(c(1,0,1,1),ncol = 2))
m&lt;- c(.9,.1)
cnames &lt;- c("yes","no")
bca(tt, m)
bca(tt, m, cnames)
bca(tt, m, cnames, idvar = 1)
tt1&lt;- t(matrix(c(1,0,1,1),ncol = 2))
colnames(tt1) &lt;- c("yes", "no")
m &lt;- c(.9, .1)
bca(tt=tt1, m, idvar = 1)
x &lt;- bca(tt=matrix(c(0,1,1,1,1,0,1,1,1),nrow = 3, 
byrow = TRUE), m = c(0.2,0.5, 0.3), 
cnames = c("a", "b", "c"), idvar = 1)
y &lt;- bca(tt=matrix(c(1,0,0,1,1,1),nrow = 2, 
byrow = TRUE), m = c(0.6,0.4), 
cnames = c("a", "b", "c"),varnames = "y", idvar = 1)
vacuous &lt;- bca(matrix(c(1,1,1), nrow = 1), m = 1, cnames = c("a","b","c"))
</code></pre>

<hr>
<h2 id='bcaPrint'>Simple printing of the <code>tt</code> matrix and mass values of a basic chance assignment (bca)</h2><span id='topic+bcaPrint'></span>

<h3>Description</h3>

<p>This utility function does a simple printing of a bca
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bcaPrint(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bcaPrint_+3A_x">x</code></td>
<td>
<p>A list of class bcaspec.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A table of subsets with their associated mass. Subsets are identified by row names.
</p>


<h3>Author(s)</h3>

<p>Claude Boivin
</p>


<h3>Examples</h3>

<pre><code class='language-R'>z &lt;- bca(tt = matrix(c(0,1,1,1,1,0,1,1,1),nrow = 3, 
byrow = TRUE), m = c(0.2,0.5, 0.3), 
cnames = c("a", "b", "c"), idvar = 1)
bcaPrint(z)
</code></pre>

<hr>
<h2 id='bcaRel'>Representation of a mass function in a product space</h2><span id='topic+bcaRel'></span>

<h3>Description</h3>

<p>This function is used to represent a relation between two or more variables in their product space <code>P</code>. The relation can be described by more than one subset of <code>P</code>. Each subset can also  include more than one element. Complete disjunctive coding is used to represent one element in the input matrix of the function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bcaRel(
  tt,
  spec,
  infovar,
  varnames,
  valuenames,
  relnb = NULL,
  infovarnames,
  infovaluenames
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bcaRel_+3A_tt">tt</code></td>
<td>
<p>The description matrix of the subsets establishing the relation. This matrix is obtained by putting the variables side by side, as in a truth table representation. For each variable, there are as many columns as possible values. Each row of the matrix is an element of a subset. Each element is described by a sequence of 0 (absence of value of a variable) or 1 (presence of value). This forms a complete disjunctive coding.</p>
</td></tr>
<tr><td><code id="bcaRel_+3A_spec">spec</code></td>
<td>
<p>A two column matrix. First column: numbers assigned to the sub-assemblies. Second column: the mass values of the sub-assemblies. If the subset has more than one element, the number of the subset and its associated mass value are repeated to match the number of elements in the subset.</p>
</td></tr>
<tr><td><code id="bcaRel_+3A_infovar">infovar</code></td>
<td>
<p>A two column matrix containing variable identification numbers and the number of elements of each variable. The identification numbers must be ordered in increasing number.</p>
</td></tr>
<tr><td><code id="bcaRel_+3A_varnames">varnames</code></td>
<td>
<p>The names of the variables.</p>
</td></tr>
<tr><td><code id="bcaRel_+3A_valuenames">valuenames</code></td>
<td>
<p>A list of the names of the variables with the name of the elements of their frame of discernment.</p>
</td></tr>
<tr><td><code id="bcaRel_+3A_relnb">relnb</code></td>
<td>
<p>A number given to the relation. Set at 0 if omitted.</p>
</td></tr>
<tr><td><code id="bcaRel_+3A_infovarnames">infovarnames</code></td>
<td>
<p>Deprecated. Old name for <code>varnames</code>.</p>
</td></tr>
<tr><td><code id="bcaRel_+3A_infovaluenames">infovaluenames</code></td>
<td>
<p>Deprecated. Old name for <code>valuenames</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <code>bcaspec</code> called a bca for &quot;basic chance assignment&quot;. This is a list containing the following components:  </p>

<ul>
<li><p> con The measure of conflict.
</p>
</li>
<li><p> tt The resulting table of subsets. Rownames of the matrix of subsets are generated from the column names of the elements of the product frame. See <code><a href="#topic+nameRows">nameRows</a></code> for details.
</p>
</li>
<li><p> spec The resulting two-column matrix of specification numbers with associated mass values.
</p>
</li>
<li><p> infovar The two-column matrix of variables number and size given in the input data.
</p>
</li>
<li><p> valuenames A list of the names of the variables with the name of the elements of their frame of discernment.
</p>
</li>
<li><p> inforel A two-column matrix containing the relation number and the depth (number of variables) of the relation.
</p>
</li></ul>



<h3>Author(s)</h3>

<p>Claude Boivin
</p>


<h3>Examples</h3>

<pre><code class='language-R'># A logical implication rule
# A typical relation between two variables is the
# logical implication a -&gt; b. Let us suppose
# that a stands for Rain: {yes, no} and b stands for
# Roadworks: {yes, no}. From experience,
# I am 75 % sure that there will be RoadWorks if there is no rain.

 # 1. The tt table of the logical implication
 ttrwf &lt;- matrix(c(0,1,1,0,1,0,1,0,1,0,0,1,1,1,1,1),
 nrow = 4, byrow = TRUE, 
 dimnames = list(NULL, c("rWdy", "rWdn", "Ry", "Rn")) )
 
 # 2. The mass distribution
 specrw &lt;-  matrix(c(1,1,1,2,0.75,0.75,0.75,0.25), ncol = 2, 
 dimnames = list(NULL, c("specnb", "mass")))
  
 # 3. Variables numbers and sizes
 inforw &lt;- matrix(c(4,5,2,2), ncol = 2, 
 dimnames = list(NULL, c("varnb", "size")) )
bcaRel(tt = ttrwf, spec = specrw, infovar = inforw,
 varnames = c("RdWorks", "Rain"), relnb = 6)

</code></pre>

<hr>
<h2 id='bcaTrunc'>Truncation of a basic chance assignment mass function</h2><span id='topic+bcaTrunc'></span>

<h3>Description</h3>

<p>When working with large frames of discernment, the bca resulting of repeated application of Dempster's Rule of Combination can become big. One way to handle this situation could be to group subsets whose mass is less than a small treshold value. The function <code>bcaTrunc</code> serves this purpose to reduce a large bca to its main elements.<br />
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bcaTrunc(x, seuil)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bcaTrunc_+3A_x">x</code></td>
<td>
<p>A bca to truncate.</p>
</td></tr>
<tr><td><code id="bcaTrunc_+3A_seuil">seuil</code></td>
<td>
<p>A treshold value</p>
</td></tr>
</table>


<h3>Value</h3>

<p>tr_x The bca object truncated.
</p>


<h3>Author(s)</h3>

<p>Claude Boivin
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- bca(tt = matrix(c(0,1,0,0, 
0,0,1,1,
1,1,0,0,
1,0,1,0,
0,1,1,0,
1,1,1,1),ncol=4, byrow = TRUE), m = c(0.2, 0.5, 0.06, 0.04, 0.03, 0.17),
cnames = c("a", "b", "c", "d"))
bcaPrint(x)
tr_x &lt;- bcaTrunc(x, seuil = 0.1)
bcaPrint(tr_x)

</code></pre>

<hr>
<h2 id='belplau'>Calculation of the degrees of Belief and Plausibility of a basic chance assignment (bca).</h2><span id='topic+belplau'></span>

<h3>Description</h3>

<p>Degrees of Belief <code>Bel</code> and Plausibility <code>Pl</code> of the focal elements of a bca are computed. The ratio of the plausibility of a focal element against the plausibility of its contrary is also computed. Subsets with zero mass can be excluded from the calculations.<br />
</p>


<h3>Usage</h3>

<pre><code class='language-R'>belplau(x, remove = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="belplau_+3A_x">x</code></td>
<td>
<p>A basic chance assignment mass function (see <code><a href="#topic+bca">bca</a></code>).</p>
</td></tr>
<tr><td><code id="belplau_+3A_remove">remove</code></td>
<td>
<p>= TRUE: Exclude subsets with zero mass.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The degree of belief <code>Bel</code> is defined by: <br />
</p>
<p style="text-align: center;"><code class="reqn">bel(A) = Sum((m(B); B \subseteq A))</code>
</p>
<p> for every subset B of A.<br />
The degree of plausibility <code>pl</code> is defined by: <br />
</p>
<p style="text-align: center;"><code class="reqn">pl(A) = Sum[(m(B); B \cap A \neq \emptyset]</code>
</p>
<p> for every subset <code>B</code> of the frame of discernment. <br />
The plausibility ratio of a focal element <code>A</code> versus its contrary <code>not A</code> is defined by:  <code class="reqn">Pl(A)/(1-Bel(A))</code>.
</p>


<h3>Value</h3>

<p>A matrix of <code>M</code> rows by 3 columns is returned, where <code>M</code> is the number of focal elements: </p>

<ul>
<li><p> Column 1: the degree of belief <code>Bel</code>;
</p>
</li>
<li><p> Column 2: the degree of Plausibility <code>Pl</code>;
</p>
</li>
<li><p> Column 3: the Plausibility ratio
</p>
</li></ul>



<h3>Author(s)</h3>

<p>Claude Boivin
</p>


<h3>References</h3>


<ul>
<li><p> Shafer, G., (1976). A Mathematical Theory of Evidence. Princeton University Press, Princeton, New Jersey, p. 39-43.
</p>
</li>
<li><p> Williams, P., (1990). An interpretation of Shenoy and Shafer's axioms for local computation. International Journal of Approximate Reasoning 4, pp. 225-232.
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- bca(tt = matrix(c(0,1,1,1,1,0,1,1,1),nrow = 3, 
byrow = TRUE), m = c(0.2,0.5, 0.3), 
cnames = c("a", "b", "c"), varnames = "x", idvar = 1)
belplau(x)
y &lt;- bca(tt = matrix(c(1,0,0,1,1,1),nrow = 2, 
byrow = TRUE), m = c(0.6, 0.4),  
cnames = c("a", "b", "c"),  varnames = "y", idvar = 1)
xy &lt;- nzdsr(dsrwon(x,y))
belplau(xy)
print("compare all elementary events")
xy1 &lt;- addTobca(x = xy, tt = matrix(c(0,1,0,0,0,1), nrow = 2, byrow = TRUE))
belplau(xy1) 

</code></pre>

<hr>
<h2 id='decode'>Find the value in base 10 of a number coded in another base</h2><span id='topic+decode'></span><span id='topic+aplDecode'></span>

<h3>Description</h3>

<p>The <code>aplDecode</code> function of the project APL in R (<a href="https://rpubs.com/deleeuw/158476">https://rpubs.com/deleeuw/158476</a>) has been adapted to follow the standard implementation of the APL <code>decode</code> function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>decode(base, ind)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="decode_+3A_base">base</code></td>
<td>
<p>A scalar or a numeric vector which describes the number system in which the data is coded.</p>
</td></tr>
<tr><td><code id="decode_+3A_ind">ind</code></td>
<td>
<p>The value to decode represented by a numeric vector in the <code>base</code> system.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If the base value is a number system, e.g. base 2, we need only to enter it as a scalar, which is then processed to match the length of the expression to decode. If <code>length(ind)</code>  is less than <code>length(base)</code>, zeroes are added to the left of the vector <code>ind</code>  to match the length of the two vectors. And vice-versa.
</p>


<h3>Value</h3>

<p>A scalar representing the conversion of the coded number <code>ind</code> to its decimal representation.
</p>


<h3>Author(s)</h3>

<p>Claude Boivin
</p>


<h3>References</h3>


<ul>
<li><p> Jan de Leeuw and Masanao Yajima (March 07, 2016) <em>APL in R (Version 009)</em>, Source code. <a href="https://rpubs.com/deleeuw/158476">https://rpubs.com/deleeuw/158476</a>
</p>
</li>
<li><p>  L. Gilman and A. J. Rose.(1974): <em>APL an Interactive Approach</em>, Second Edition, John Wiley, New York.
</p>
</li>
<li><p>  APL 68000 Level II language manual. MicroAPL Ltd. 1990.
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>decode(c(2,2,2,2), c(1,0,1,1)) #   Find the base 10 value of the base 2 number 1011.
decode(2, c(1,0,1,1))  # left argument is extended to vector c(2,2,2,2)
decode(c(365,24,60), c(2,1,57)) # transform 2 days 1 h 57 min in minutes
decode(c(365,24,60), c(1,57))   # right vector extended
decode(c(24,60), c(2,1,57))     # left vector extended
decode(1.5, c(1,2,3)) # polynomial 1*x^2 +2*x +3 evaluated at x=1.5
</code></pre>

<hr>
<h2 id='dlfm'>The Captain's Problem. <code>dlfm</code>: Relation between variables Departure delay (D), Loading delay (L), Forecast of the weather (F), Maintenance delay (M)</h2><span id='topic+dlfm'></span>

<h3>Description</h3>

<p>This dataset is the <code>tt</code> matrix establishing the relation between the four variables. Each event (loading = true, forecast = foul, Maintenance = true) adds one day of Departure Delay. The elements (d,l, f, m) of (D x L x F x M) satisfying the relation form a subset with a mass value of 1. To construct the <code>tt</code> matrix, we put the variables D,L,F,M side by side, as in a truth table representation. Each 4-tuple of the subset is described by a row of the matrix as a vector of zeros and ones.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dlfm
</code></pre>


<h3>Format</h3>

<p>An integer matrix with 10 rows and 12 columns.
</p>

<dl>
<dt>[1,c(1,2)]</dt><dd><p>value = 0, not used</p>
</dd>
<dt>[1,3:12]</dt><dd><p>Identification numbers of the four variables. Column 3 to 6: variable 2; columns 7,8: variable 4; columns 9, 10: variable 5: columns 11,12: variable 6.</p>
</dd>
<dt>nospec</dt><dd><p>identification number of the specification</p>
</dd>
<dt>m</dt><dd><p>the value of the specification, a number between 0 and 1</p>
</dd>
<dt>3</dt><dd><p>1 if d3 is part of the specification, 0 otherwise</p>
</dd>
<dt>2</dt><dd><p>1 if d2 is part of the specification, 0 otherwise</p>
</dd>
<dt>1</dt><dd><p>1 if d1 is part of the specification, 0 otherwise</p>
</dd>
<dt>0</dt><dd><p>1 if d0 is part of the specification, 0 otherwise</p>
</dd>
<dt>true</dt><dd><p>1 if true is part of the specification, 0 otherwise</p>
</dd>
<dt>false</dt><dd><p>1 if false is part of the specification, 0 otherwise</p>
</dd>
<dt>foul</dt><dd><p>1 if foul is part of the specification, 0 otherwise</p>
</dd>
<dt>fair</dt><dd><p>1 if fair is part of the specification, 0 otherwise</p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>Claude Boivin, Stat.ASSQ
</p>


<h3>Source</h3>

<p>Almond, R.G. [1988] Fusion and Propagation in Graphical Belief Models. Computing Science and Statistics: Proceedings of the 20th Symposium on the Interface. Wegman, Edward J., Gantz, Donald T. and Miller, John J. (ed.). American Statistical Association, Alexandria, Virginia. pp 365&ndash;370.
</p>

<hr>
<h2 id='dotprod'>Generalized inner product of two matrices</h2><span id='topic+dotprod'></span>

<h3>Description</h3>

<p>The generalized inner product of two matrices combines two operators in the same manner as the classical inner product defined for the multiplication of two matrices. The number of rows of the second matrix must be equal the number of columns of the first matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dotprod(x, y, g, f)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dotprod_+3A_x">x</code></td>
<td>
<p>A matrix of M rows by K columns.</p>
</td></tr>
<tr><td><code id="dotprod_+3A_y">y</code></td>
<td>
<p>A matrix of K rows by N columns.</p>
</td></tr>
<tr><td><code id="dotprod_+3A_g">g</code></td>
<td>
<p>Any operator: +, -, *, /, &amp;, |, ==, &lt;=, paste etc.</p>
</td></tr>
<tr><td><code id="dotprod_+3A_f">f</code></td>
<td>
<p>Any operator: +, -, *, /, &amp;, |, ==, &lt;=, paste etc.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The result of the generalized inner product is returned.
</p>


<h3>Author(s)</h3>

<p>Claude Boivin
</p>


<h3>Examples</h3>

<pre><code class='language-R'>print("Standard matrix product")
x &lt;- y &lt;- matrix(c(1:6), nrow = 2, byrow = TRUE)
dotprod(x, t(y), g = "+", f = "*")  ## same as x %*% t(y)
print("Find some data x2 in the rows of a larger matrix y2")
x2 &lt;- matrix(c(1,0,0,1,1,1), nrow = 2, byrow = TRUE)
y2 &lt;- matrix(c(1,0,0,0,1,0,1,1,0,0,1,1,1,1,1), 
nrow = 5, byrow = TRUE)
(1:nrow(y2)) * dotprod(x2, t(y2), g = "&amp;", f = "==")

print("Find some names in a long list")
team_names &lt;- matrix(c("Patrick", "Dole", "Amanda",
 "Dole", "Robert", "Calvin", "Alvina", "Klein",
  "Robert", "Gariepy", "Nellie", "Arcand"),
   ncol = 2, byrow = TRUE)
colnames(team_names) &lt;- c("First_name", "Last_name")
print("Where in the list are the person with first name Robert and where are the Doles?")
BobandDoles &lt;- matrix(c("Robert", "", "", "Dole"),
 ncol = 2, byrow = TRUE)
dotprod(team_names, t(BobandDoles),g="|",f="==") * (1:nrow(team_names))
</code></pre>

<hr>
<h2 id='doubles'>Remove duplicate rows in a two-dimensional table.</h2><span id='topic+doubles'></span>

<h3>Description</h3>

<p>Recursive function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>doubles(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="doubles_+3A_x">x</code></td>
<td>
<p>A matrix of numeric, character or logical type.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The submitted matrix with duplicated rows removed from.
</p>


<h3>Author(s)</h3>

<p>Claude Boivin
</p>


<h3>Examples</h3>

<pre><code class='language-R'>td0 &lt;- matrix(c(rep(c(1,0,1),times=3),0,0,1,1,1,1, 1,1,1),ncol = 3,byrow = TRUE)
(doubles(td0))
td1 &lt;- matrix(c(rep(c(1,0,1),times=3),0,0,1,1,1,1),ncol = 3,byrow = TRUE)
(doubles(td1))
td2 &lt;- matrix(c(1:3, 1:3,4:6,1:3),nrow = 4,byrow = TRUE)
(doubles(td2))
td3 &lt;- matrix(c("d","e","f", rep(c("a","b","cc"),times = 3),"g","h","i"),nrow = 5,byrow = TRUE)
(doubles(td3))
td4 &lt;- matrix(as.logical(td1),nrow = 5,byrow = TRUE)
(doubles(td4))
</code></pre>

<hr>
<h2 id='dsrwon'>Combination of two mass functions</h2><span id='topic+dsrwon'></span>

<h3>Description</h3>

<p>The unnormalized Dempster's rule is used to combine two mass functions <code>mx</code> and <code>my</code> defined  on the same frame of discernment and described by their respective basic chance assignments <code>x</code>  and <code>y</code>. Dempster's rule of combination is applied. The normalization is not done, leaving the choice  to the user to normalize the results or not (for the normalization operation, see function <code><a href="#topic+nzdsr">nzdsr</a></code>).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dsrwon(x, y, mcores = "no", varnames = NULL, relnb = NULL, infovarnames)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dsrwon_+3A_x">x</code></td>
<td>
<p>A basic chance assignment (see <code><a href="#topic+bca">bca</a></code>).</p>
</td></tr>
<tr><td><code id="dsrwon_+3A_y">y</code></td>
<td>
<p>A basic chance assignment (see <code><a href="#topic+bca">bca</a></code>).</p>
</td></tr>
<tr><td><code id="dsrwon_+3A_mcores">mcores</code></td>
<td>
<p>Make use of multiple cores (&quot;yes&quot;) or not (&quot;no&quot;). Default = &quot;no&quot;.</p>
</td></tr>
<tr><td><code id="dsrwon_+3A_varnames">varnames</code></td>
<td>
<p>A character string to name the resulting variable. named &quot;z&quot; if omitted.</p>
</td></tr>
<tr><td><code id="dsrwon_+3A_relnb">relnb</code></td>
<td>
<p>Identification number of the relation. Can be omitted.</p>
</td></tr>
<tr><td><code id="dsrwon_+3A_infovarnames">infovarnames</code></td>
<td>
<p>Deprecated. Old name for <code>varnames</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The calculations make use of multiple cores available.
</p>
<p>The two bca's <code>x</code> and <code>y</code> must be defined on the same frame of discernment for the combination to take place. The relation number of the x input is given to the output result.
</p>


<h3>Value</h3>

<p>A basic chance assignment with these two components added: </p>

<ul>
<li><p> I12 Intersection table of subsets.
</p>
</li>
<li><p> Sort_order Sort order of subsets.
</p>
</li></ul>



<h3>Author(s)</h3>

<p>Claude Boivin
</p>


<h3>References</h3>

<p>Shafer, G., (1976). A Mathematical Theory of Evidence. Princeton University Press, Princeton, New Jersey, pp. 57-61: Dempster's rule of combination.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x1 &lt;- bca(tt = matrix(c(0,1,1,1,1,0,1,1,1),nrow = 3, 
byrow = TRUE), m = c(0.2,0.5, 0.3), 
cnames = c("a", "b", "c"),  
varnames = "x", idvar = 1)
x2 &lt;- bca(tt = matrix(c(1,0,0,1,1,1),nrow = 2, 
byrow = TRUE), m = c(0.6, 0.4),  
cnames = c("a", "b", "c"),  
varnames = "x", idvar = 1)
dsrwon(x1,x2)
frame &lt;- bca(matrix(c(1,1,1), nrow = 1), m = 1, cnames = c("a","b","c"))
dsrwon(frame, frame)
</code></pre>

<hr>
<h2 id='dst-package'>Manipulation and combination of belief functions</h2><span id='topic+dst'></span><span id='topic+dst-package'></span>

<h3>Description</h3>

<p>Package dst allows you to make basic probability assignments on subsets of a set of possibilities (events) and combine these events with Dempster's rule of combination.
</p>


<h3>Details</h3>

<p>The main operations that can be done are: </p>

<ul>
<li><p> definition of a basic chance assignment (bca) distribution on a variable,
</p>
</li>
<li><p> combination of two bca's defined on the same variable,
</p>
</li>
<li><p> definition of a bca which establish a relation between two or more variables,
</p>
</li>
<li><p> extension of a bca,
</p>
</li>
<li><p> marginalization of a bca. 
</p>
</li></ul>



<h3>Author(s)</h3>

<p>Claude Boivin &lt;webapp.cb@gmail.com&gt;
</p>


<h3>See Also</h3>

<p>Useful links:
</p>

<ul>
<li><p> Report bugs at <a href="https://github.com/RAPLER/dst-1/issues">https://github.com/RAPLER/dst-1/issues</a>
</p>
</li></ul>


<hr>
<h2 id='elim'>Reduction of a relation</h2><span id='topic+elim'></span>

<h3>Description</h3>

<p>This function works on a relation defined on a product of two variables or more.  Having fixed a variable to eliminate from the relation,  the reduced product space is determined and the corresponding reduced bca is computed.This operation is also called &quot;marginalization&quot;.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>elim(rel, xnb)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="elim_+3A_rel">rel</code></td>
<td>
<p>The relation to reduce, an object of class bcaspec.</p>
</td></tr>
<tr><td><code id="elim_+3A_xnb">xnb</code></td>
<td>
<p>Identification number of the variable to eliminate.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>r The reduced relation
</p>


<h3>Author(s)</h3>

<p>Claude Boivin
</p>


<h3>Examples</h3>

<pre><code class='language-R'> 
# We construct a relation between two variables to show marginalization.
wr_tt &lt;- matrix(c(1,rep(0,3),rep(c(1,0),3),0,1,1,1,0,0,
1,0,rep(1,5),0,1,1,0,rep(1,5)), ncol = 4, byrow = TRUE)
colnames(wr_tt) &lt;- c("Wy Ry", "Wy Rn", "Wn Ry", "Wn Rn")
rownames(wr_tt) &lt;- nameRows(wr_tt)
wr_spec = matrix(c(1:8, 0.017344, 0.046656, 
0.004336, 0.199456,0.011664,0.536544,0.049864, 0.134136), 
 ncol = 2, dimnames = list(NULL, c("specnb", "mass"))) 
 wr_infovar = matrix(c(4,5,2,2), ncol = 2, 
 dimnames = list(NULL, c("varnb", "size")) )
wr_rel &lt;- list(tt = wr_tt, con = 0.16, spec=wr_spec,
  infovar = wr_infovar, varnames = c("Roadworks","Rain"),
  valuenames = list( RdWorks = c("Wy", "Wn"), Rain=c("Ry", "Rn") ))
class(wr_rel) &lt;- "bcaspec"
bcaPrint(elim(wr_rel, xnb = 5))
bcaPrint(elim(wr_rel, xnb = 4))
 
</code></pre>

<hr>
<h2 id='encode'>Convert a value to its representation in another chosen base</h2><span id='topic+encode'></span><span id='topic+aplEncode'></span>

<h3>Description</h3>

<p>The <code>aplEncode</code> function of the project APL in R (<a href="https://rpubs.com/deleeuw/158476">https://rpubs.com/deleeuw/158476</a>) has been adapted to follow the standard implementation of the APL <code>encode</code> function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>encode(base, ind)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="encode_+3A_base">base</code></td>
<td>
<p>A numeric vector which describes the number system in which we want to recode the data.</p>
</td></tr>
<tr><td><code id="encode_+3A_ind">ind</code></td>
<td>
<p>The value to convert represented by a number or a numeric vector.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector or a matrix of the data converted.
</p>


<h3>Author(s)</h3>

<p>Claude Boivin
</p>


<h3>References</h3>


<ul>
<li><p> Jan de Leeuw and Masanao Yajima (March 07, 2016) <em>APL in R (Version 009)</em>, Source code. <a href="https://rpubs.com/deleeuw/158476">https://rpubs.com/deleeuw/158476</a>
</p>
</li>
<li><p>  L. Gilman and A. J. Rose.(1974): <em>APL an Interactive Approach</em>, Second Edition, John Wiley, New York.
</p>
</li>
<li><p>  APL 68000 Level II language manual. MicroAPL Ltd. 1990.
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>encode(c(2,2,2,2), 11)  # find the base 2 representation of number 11
encode(c(365,24,60), 2997) # convert 2997 minutes to days-hrs-min.
</code></pre>

<hr>
<h2 id='extmin'>Extension of a relation</h2><span id='topic+extmin'></span>

<h3>Description</h3>

<p>This function works on a basic chance assignment (bca) <code>x</code> defined on a single variable or more. A relation of reference is given, and an extension of the space of <code>x</code> is made to the larger product space of the relation of reference. The basic chance assignment to extend and the relation of reference must have at least one common variable for the extension to occur.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>extmin(rel1, relRef)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="extmin_+3A_rel1">rel1</code></td>
<td>
<p>An object of class bcaspec, i.e. a basic chance assignment defined on one variable or a relation.</p>
</td></tr>
<tr><td><code id="extmin_+3A_relref">relRef</code></td>
<td>
<p>The relation of reference. It can be an existing relation, or it can be constructed as a vacuous function.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>relRef</code> parameter is used to extract all the information on the variables, namely their identification numbers and the number of elements of each variable, variables names and columns names of the <code>tt</code> matrix. The relation of reference <code>relRef</code>  may be a relation already existing or simply the the vacuous relation defined on the product set of variables of interest.
</p>


<h3>Value</h3>

<p>the resulting extended bca.
</p>


<h3>Author(s)</h3>

<p>Claude Boivin
</p>


<h3>References</h3>

<p>G. Shafer and P. P. Shenoy. Local Computations in Hypertrees. School of Business, University of Kansas, Lawrence, KS, 1991. See p. 78, vacuous extension of a belief function.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Making a vacuous reference relation and extending a bca to its space.
init_tt = matrix(rep(1,10),nrow = 1, 
dimnames = list(NULL, c("3", "2", "1", "0", 
 "true", "false",  "foul", "fair",  "true", "false")) )
 init_spec &lt;- matrix(c(1,1), ncol = 2, 
 dimnames = list(NULL, c("specnb", "mass")))
 init_info &lt;- matrix(c(3,4,7,8,4,2,2,2), ncol = 2,
  dimnames = list(NULL, c("varnb", "size")) )
 relRef &lt;- bcaRel(tt = init_tt, spec = init_spec,
  infovar = init_info, 
  varnames = c("Sail", "Loading", "Weather", "Repairs"),
  relnb = 0)
 # a bcaspec defined on one variable
 l_rel &lt;- bca(tt = matrix(c(1,0,1,0,1,1), ncol = 2), 
 m = c(0.3,0.5,0.2), cnames = c("true", "false"), 
 infovar = matrix(c(4,2), ncol = 2, 
 dimnames = list(NULL, c("varnb", "size"))), 
 varnames = c("Loading"), 
 inforel = matrix(c(7,1), ncol = 2, 
 dimnames = list(NULL, c("relnb", "depth"))))
 z &lt;- extmin(l_rel, relRef)
 prmatrix(t(z$tt), collab = rep("", nrow(z$tt)))
 
</code></pre>

<hr>
<h2 id='fw'>The Captain's Problem. <code>fw</code>: Relation between variables Forecast of the weather (F) and  Weather at sea (W)</h2><span id='topic+fw'></span>

<h3>Description</h3>

<p>This dataset is the <code>tt</code> matrix establishing the relation between the two variables. An accurate forecast is described by this subset of two event:  (Forecast = foul, Weather = foul) and (Forecast = fair, Weather = fair). We assign a mass value of 0.8 to this subset. The remaining mass of 0.2 is allotted to the frame. To construct the <code>tt</code> matrix, we put the variables F and W side by side, as in a truth table representation. Each pair of the subset is described by a row of the matrix as a vector of zeros and ones.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fw
</code></pre>


<h3>Format</h3>

<p>An integer matrix with 4 rows and 6 columns.
</p>

<dl>
<dt>[1,c(1,2)]</dt><dd><p>value = 0, not used</p>
</dd>
<dt>[1,3:6]</dt><dd><p>Identification numbers of the two variables. Column 3,6: variable 5; columns 5,6: variable 7.</p>
</dd>
<dt>nospec</dt><dd><p>identification number of the specification</p>
</dd>
<dt>m</dt><dd><p>the value of the specification, a number between 0 and 1</p>
</dd>
<dt>foul</dt><dd><p>1 if foul is part of the specification, 0 otherwise</p>
</dd>
<dt>fair</dt><dd><p>1 if fair is part of the specification, 0 otherwise</p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>Claude Boivin
</p>


<h3>Source</h3>

<p>Almond, R.G. [1988] Fusion and Propagation in Graphical Belief Models. Computing Science and Statistics: Proceedings of the 20th Symposium on the Interface. Wegman, Edward J., Gantz, Donald T. and Miller, John J. (ed.). American Statistical Association, Alexandria, Virginia. pp 365&ndash;370.
</p>

<hr>
<h2 id='inters'>Intersection of two tables of propositions</h2><span id='topic+inters'></span>

<h3>Description</h3>

<p>Function <code>inters</code> returns a table of the intersection between two (0,1) or boolean matrices or two vectors. The two matrices must have the same number of columns. The two vectors must be of the same length. This function generalizes the intersection of two subsets represented by boolean vectors to the intersection of two matrices of subsets.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>inters(x, y)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="inters_+3A_x">x</code></td>
<td>
<p>A (0,1)-matrix or a boolean matrix of M rows by K columns, or a vector of length K.</p>
</td></tr>
<tr><td><code id="inters_+3A_y">y</code></td>
<td>
<p>A (0,1)-matrix or a boolean matrix of N rows by K columns or a vector of length K.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The result is a (0,1)-table of dimensions (M x K) x N). In the case of vectors, the result is a (0,1)-table of dimensions (1 x K) x 1)
</p>


<h3>Author(s)</h3>

<p>Claude Boivin
</p>


<h3>Examples</h3>

<pre><code class='language-R'>mx &lt;- matrix(c(0,1,0,0,1,1,1,1,1),nrow = 3, byrow = TRUE, dimnames = list(NULL, c("a", "b", "c")))
 rownames(mx) &lt;- nameRows(mx)
my&lt;-matrix(c(0,0,1,1,1,1),nrow = 2, byrow = TRUE, dimnames = list(NULL, c("a", "b", "c")))
 rownames(my) &lt;- nameRows(my)
inters(mx,my)
b1 &lt;- c(FALSE, TRUE, TRUE)
b2 &lt;- c(TRUE, TRUE, FALSE)
names(b1) &lt;- names(b2) &lt;- c("c1","c2","c3")
inters(b1,b2)
x3&lt;-matrix(c(1,1,0,1), ncol = 2, dimnames = list(NULL, c("a","b")))
y3&lt;-matrix(c(0,1,1,1), ncol = 2, dimnames = list(NULL, c("a","b")))
inters(x3,y3)
x4 &lt;-matrix(c(1,0,1,1,1,1,1,1),nrow = 2, byrow = TRUE, dimnames = list(NULL, c("a", "b", "c","d")))
y4 &lt;-matrix(c(1,0,0,1,1,1,1,1),nrow = 2, byrow = TRUE, dimnames = list(NULL, c("a", "b", "c","d")))
inters(x4,y4)
</code></pre>

<hr>
<h2 id='marrayToMatrix'>Transformation of an array data to its matrix representation</h2><span id='topic+marrayToMatrix'></span>

<h3>Description</h3>

<p>The array representation or product space representation is converted to the matrix representation of the corresponding relation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>marrayToMatrix(mtt)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="marrayToMatrix_+3A_mtt">mtt</code></td>
<td>
<p>The matrix <code>tt</code> of the relation in  array format</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The matrix representation of the data.
</p>


<h3>Author(s)</h3>

<p>Claude Boivin
</p>


<h3>Examples</h3>

<pre><code class='language-R'> mtt &lt;- array(c(1,0,0,0,1,1,0,0,1,0,0,1,1,0,1,0,1,1,0,1,1,1,1,0,1,0,1,1,1,1,1,1), c(2,2,8), 
 dimnames = list( RdWorks=c("Wy", "Wn") , Rain = c("Ry", "Rn"), ev=1:8) )
 print(z &lt;- marrayToMatrix(mtt))

</code></pre>

<hr>
<h2 id='matrixToMarray'>Transformation of the tt matrix of a relation</h2><span id='topic+matrixToMarray'></span>

<h3>Description</h3>

<p>The matrix representation of a relation is converted to the array representation or product space representation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>matrixToMarray(tt, valuenames)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="matrixToMarray_+3A_tt">tt</code></td>
<td>
<p>A (0,1)-matrix or a boolean matrix establishing the relation between two or more variables. The matrix is constructed by placing the variables side by side, as in a truth table representation.</p>
</td></tr>
<tr><td><code id="matrixToMarray_+3A_valuenames">valuenames</code></td>
<td>
<p>A list of the names of the variables with the name of each value of their frame of discernment.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>mtt The array (product space) representation of the <code>tt</code> matrix.
</p>


<h3>Author(s)</h3>

<p>Claude Boivin
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Define  wr_tt, a matrix describing the relation between two variables
wr_tt &lt;- matrix(c(1,rep(0,3),rep(c(1,0),3),0,1,1,1,0,0,
1,0,rep(1,5),0,1,1,0,rep(1,5)), ncol=4, byrow = TRUE)
colnames(wr_tt) &lt;- c("Wy Ry", "Wy Rn", "Wn Ry", "Wn Rn")
rownames(wr_tt) &lt;- nameRows(wr_tt)
vars = list( RdWorks = c("Wy", "Wn") , Rain = c("Ry", "Rn"))
print(zmToa &lt;- matrixToMarray(tt = wr_tt, valuenames = vars ) )
 
</code></pre>

<hr>
<h2 id='mrf'>The Captain's Problem. <code>mrf</code>: Relation between variables No Maintenance (M = false) and  Repairs at sea (R)</h2><span id='topic+mrf'></span>

<h3>Description</h3>

<p>This dataset is the <code>tt</code> matrix establishing a set of two relations between the two variables. First, Repairs = true if Maintenance = false in (M x R). We are 20% sure that there will be Repairs if no maintenance. Second, Repairs = false if Maintenance = false in (M x R). We are 20% sure that there will be no repairs if no maintenance.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mrf
</code></pre>


<h3>Format</h3>

<p>A (0,1) matrix with 4 rows and 6 columns.
</p>

<dl>
<dt>[1,c(1,2)]</dt><dd><p>value = 0, not used</p>
</dd>
<dt>[1,3:6]</dt><dd><p>Identification numbers of the two variables. Column 3,4: variable 6; columns 5,6: variable 8</p>
</dd>
<dt>nospec</dt><dd><p>identification number of the specification</p>
</dd>
<dt>m</dt><dd><p>the value of the specification, a number between 0 and 1</p>
</dd>
<dt>true</dt><dd><p>1 if true is part of the specification, 0 otherwise</p>
</dd>
<dt>false</dt><dd><p>1 if false is part of the specification, 0 otherwise</p>
</dd>
</dl>



<h3>Details</h3>

<p>These two relations are implication rules. The remaining mass of 0.6 is allotted to the frame. To construct the <code>tt</code> matrix, we put the variables M and R side by side, as in a truth table representation. Each pair of the subset is described by a row of the matrix as a vector of zeros and ones.
</p>


<h3>Author(s)</h3>

<p>Claude Boivin, Stat.ASSQ
</p>


<h3>Source</h3>

<p>Almond, R.G. [1988] Fusion and Propagation in Graphical Belief Models. Computing Science and Statistics: Proceedings of the 20th Symposium on the Interface. Wegman, Edward J., Gantz, Donald T. and Miller, John J. (ed.). American Statistical Association, Alexandria, Virginia. pp 365&ndash;370.
</p>

<hr>
<h2 id='mrt'>The Captain's Problem. <code>mrt</code>: Relation between variables Maintenance done (M = true) and  Repairs at sea (R)</h2><span id='topic+mrt'></span>

<h3>Description</h3>

<p>This dataset is the <code>tt</code> matrix establishing a set of two relations between the two variables. First, Repairs = true if Maintenance = true in (M x R). We are 10% sure that there will be Repairs if maintenance is done. Second, Repairs = false if Maintenance = true in (M x R). We are 70% sure that there will be no repairs if maintenance is done.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mrt
</code></pre>


<h3>Format</h3>

<p>A (0,1) matrix with 4 rows and 6 columns.
</p>

<dl>
<dt>[1,c(1,2)]</dt><dd><p>value = 0, not used</p>
</dd>
<dt>[1,3:6]</dt><dd><p>Identification numbers of the two variables. Column 3,4: variable 6; columns 5,6: variable 8</p>
</dd>
<dt>nospec</dt><dd><p>identification number of the specification</p>
</dd>
<dt>m</dt><dd><p>the value of the specification, a number between 0 and 1</p>
</dd>
<dt>true</dt><dd><p>1 if true is part of the specification, 0 otherwise</p>
</dd>
<dt>false</dt><dd><p>1 if false is part of the specification, 0 otherwise</p>
</dd>
</dl>



<h3>Details</h3>

<p>These two relations are implication rules. The remaining mass of 0.2 is allotted to the frame. To construct the <code>tt</code> matrix, we put the variables M and R side by side, as in a truth table representation. Each pair of the subset is described by a row of the matrix as a vector of zeros and ones.
</p>


<h3>Author(s)</h3>

<p>Claude Boivin, Stat.ASSQ
</p>


<h3>Source</h3>

<p>Almond, R.G. [1988] Fusion and Propagation in Graphical Belief Models. Computing Science and Statistics: Proceedings of the 20th Symposium on the Interface. Wegman, Edward J., Gantz, Donald T. and Miller, John J. (ed.). American Statistical Association, Alexandria, Virginia. pp 365&ndash;370.
</p>

<hr>
<h2 id='nameCols'>Naming the columns of the <code>tt</code> matrix</h2><span id='topic+nameCols'></span>

<h3>Description</h3>

<p>This utility function makes use of the valuenames  and size parameters  of a set of variables to assign values names to the columns of a <code>tt</code> matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>nameCols(valuenames, size)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="nameCols_+3A_valuenames">valuenames</code></td>
<td>
<p>A list of the names of the variables with the name of the elements of their frame of discernment.</p>
</td></tr>
<tr><td><code id="nameCols_+3A_size">size</code></td>
<td>
<p>A vector of the size of the variables.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A character vector of length equal to the sum of the sizes of the variables.
</p>


<h3>Author(s)</h3>

<p>Claude Boivin
</p>


<h3>Examples</h3>

<pre><code class='language-R'>infoval &lt;- list(A = c("a1", "a2"), B = c("b1", "b2", "b3"))
sizes &lt;- c(2,3)
 print(nameCols(valuenames = infoval, size = sizes) )
</code></pre>

<hr>
<h2 id='nameCols_prod'>Naming the columns of the <code>tt</code> matrix of a product space</h2><span id='topic+nameCols_prod'></span>

<h3>Description</h3>

<p>This utility function makes use of the valuenames  and size parameters  of a set of variables to assign values names to the columns of the <code>tt</code> matrix of their product space.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>nameCols_prod(valuenames, size)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="nameCols_prod_+3A_valuenames">valuenames</code></td>
<td>
<p>A list of the names of the variables with the name of the elements of their frame of discernment.</p>
</td></tr>
<tr><td><code id="nameCols_prod_+3A_size">size</code></td>
<td>
<p>A vector of the size of the variables.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A character vector of length equal to the product of the sizes of the variables.
</p>


<h3>Author(s)</h3>

<p>Claude Boivin
</p>


<h3>Examples</h3>

<pre><code class='language-R'>infoval &lt;- list(A = c("a1", "a2"), B = c("b1", "b2", "b3"))
sizes &lt;- c(2,3)
 print(nameCols_prod(valuenames = infoval, size = sizes) )
</code></pre>

<hr>
<h2 id='nameRows'>Combining the column names of a matrix to construct names for the rows</h2><span id='topic+nameRows'></span>

<h3>Description</h3>

<p>This function determines the name of a row from all the columns of the <code>tt</code> that show 1 for that row.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>nameRows(tt, f)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="nameRows_+3A_tt">tt</code></td>
<td>
<p>A (0,1)-matrix or a boolean matrix.</p>
</td></tr>
<tr><td><code id="nameRows_+3A_f">f</code></td>
<td>
<p>Deprecated. Old name for <code>tt</code> matrix.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The row containing only 1s is called &quot;frame&quot;, to avoid too long a label. The empty set is identified by its code &quot;u00f8&quot;. The &quot;+&quot; sign is used to represent the logical &quot;or&quot; operator. The space &quot; &quot; is used to represent the logical &quot;and&quot; operator. Note that in the case of a product space defined on many variables, row labels can become very long.
</p>


<h3>Value</h3>

<p>A character vector of labels obtained for the rows of the <code>tt</code> matrix. The length of the result is <code>nrow(tt)</code>.
</p>


<h3>Author(s)</h3>

<p>Claude Boivin
</p>


<h3>Examples</h3>

<pre><code class='language-R'>tt &lt;- matrix(c(0,0,0,1,0,0,0,0,1,1,0,1,1,1,1),ncol = 3, byrow = TRUE)
colnames(tt) &lt;- c("A","B","C")
rownames(tt) &lt;-nameRows(tt)
tt
</code></pre>

<hr>
<h2 id='nzdsr'>Normalization of a basic chance assignment</h2><span id='topic+nzdsr'></span>

<h3>Description</h3>

<p>It may occur that the result of the combination of two basic chance assignments with Dempster's Rule of combination contains a non-zero mass allocated to the empty set. The function <code>nzdsr</code> normalizes the result of function <code>dsrwon</code> by dividing the mass value of the non-empty subsets by 1 minus the mass of the empty set.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>nzdsr(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="nzdsr_+3A_x">x</code></td>
<td>
<p>A basic chance assignment, i.e. a object of class bcaspec.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>z The normalized basic chance assignment.
</p>


<h3>Author(s)</h3>

<p>Claude Boivin
</p>


<h3>References</h3>

<p>Shafer, G., (1976). A Mathematical Theory of Evidence. Princeton University Press, Princeton, New Jersey, pp. 57-61: Dempster's rule of combination.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x1 &lt;- bca(tt= matrix(c(1,0,1,1),nrow = 2, byrow = TRUE), 
m = c(0.9,0.1), cnames = c("yes", "no"),
varnames = "x", varnb = 1)
x2 &lt;- bca(tt = matrix(c(0,1,1,1),nrow = 2, byrow = TRUE), 
m = c(0.5,0.5), cnames = c("yes", "no"), 
varnames = "x", varnb = 1)
print("combination of x1 and x2")
x1x2 &lt;- dsrwon(x1,x2, varname = "x")
nzdsr(x1x2) 

print("normalization of a bca definition.")
y2 &lt;- bca(f = matrix(c(0,0,0,1,0,0,1,1,1),nrow = 3, 
byrow = TRUE), m = c(0.2,0.5,0.3), 
cnames = c("a", "b", "c"), varnb = 1)
nzdsr(y2)  
</code></pre>

<hr>
<h2 id='peeling'>The peeling algorithm</h2><span id='topic+peeling'></span>

<h3>Description</h3>

<p>An implementation of the peeling algorithm based on its description in terms of hypergraphs by R. Almond [1989].<br />
</p>


<h3>Usage</h3>

<pre><code class='language-R'>peeling(vars_def, hgm, hg_rel_names, elim_order, verbose = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="peeling_+3A_vars_def">vars_def</code></td>
<td>
<p>A list of variables and their possible values. Concatenate the valuenames parameter of all the variables of the hypergraph to obtain this list.</p>
</td></tr>
<tr><td><code id="peeling_+3A_hgm">hgm</code></td>
<td>
<p>The incidence matrix of the hypergraph (bipartite graph), which is the  description of the relations between the variables. The variables are the nodes of the hypergraph, and the relations are the edges. Each column describes a relation between the variables by a (0,1) vector. A &quot;1&quot; indicates that a variable belongs to the relation and a &quot;0&quot; not. This matrix must have row and column names. These names are used to show the graph eventually. They need not be the same as variables and relations names of the set of bca's to be analyzed. Use short names to obtain a clear graph.</p>
</td></tr>
<tr><td><code id="peeling_+3A_hg_rel_names">hg_rel_names</code></td>
<td>
<p>The names of the relations, which are objects of class &quot;bcaspec&quot;.</p>
</td></tr>
<tr><td><code id="peeling_+3A_elim_order">elim_order</code></td>
<td>
<p>The order of elimination of the variables. A vector of length <code>nrow(hgm)</code>. Variables are identified by numbers. The first number gives the first variable to eliminate. The variable of interest comes last.</p>
</td></tr>
<tr><td><code id="peeling_+3A_verbose">verbose</code></td>
<td>
<p>= TRUE: print steps on the console. Default = FALSE.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The peeling algorithm works on an undirected graph. Nodes of the graph (variables) are removed one by one until only the variable of interest remains. An order of elimination (peeling) of the variables must be chosen by the user. No algorithm is provided for that matter. At each step, a procedure of extension is applied to the bca's to merge, and marginalization is applied to eliminate a variable. The marginalization has the effect to integrate in the remaining nodes the information of the eliminated variable.
</p>


<h3>Value</h3>

<p>A bca class object.
</p>


<h3>Author(s)</h3>

<p>Claude Boivin
</p>


<h3>References</h3>


<ul>
<li><p> Almond, R. G. (1989) Fusion and Propagation of Graphical Belief Models: An Implementation and an Example. Ph. D. Thesis, the Department of Statistics, Harvard University. 288 pages (for the description of the peeling algorithm, see pages 52-53).
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'># Zadeh's Example
# 1. Defining variables and relations 
# (for details, see vignette: Zadeh_Example)
e1 &lt;- bca(tt = matrix(c(1,0,0,1,1,1), ncol = 2, byrow = TRUE),
 m = c(0.99, 0.01, 0), cnames = c("M", "T"), 
 varnames = "D1", idvar = 1)
e2 &lt;- bca(tt = matrix(c(1,0,0,1,1,1), ncol = 2, byrow = TRUE),
m = c(0.99, 0.01, 0), cnames = c("C", "T"), 
varnames = "D2", idvar = 2)
p_diag &lt;- bca(tt = matrix(c(1,1,1), ncol = 3, byrow = TRUE), 
m = 1, cnames = c("M", "T", "C"), 
varnames = "D", idvar = 3)
# Defining the relation between the variables
# tt matrix
tt_r1 &lt;- matrix(c(1,0,1,0,1,0,0,1,0,1,0,0,0,1,
1,0,0,1,1,0,0,1,0,0,1,0,1,0,0,1,1,0,0,1,0,
0,1,1,0,0,0,1,0,1,0,1,0,1,0,1,1,1,1,1,1,1), 
ncol = 7,byrow = TRUE)
colnames(tt_r1) = c("M", "T", "C", "T", "M", "T", "C")
# The mass function
spec_r1 &lt;- matrix(c(rep(1,7),2, rep(1,7), 0), ncol = 2, dimnames = list(NULL, c("specnb", "mass"))) 
# Variables numbers and dimension of their frame
info_r1 &lt;- matrix(c(1:3, 2,2,3), ncol = 2, dimnames = list(NULL, c("varnb", "size")) )
#  The relation between e1, e2 and a patient p
r1 &lt;- bcaRel(tt = tt_r1, spec = spec_r1, infovar = info_r1,
 varnames = c("D1", "D2", "D"), relnb = 1)

# 2. Setting the incidence matrix of the grapph
rel1 &lt;- 1*1:3 %in% r1$infovar[,1]
ev1 &lt;- 1*1:3 %in% e1$infovar[,1]
ev2 &lt;- 1*1:3 %in% e2$infovar[,1]
meddiag_hgm &lt;- matrix(c(ev1,ev2, rel1), ncol = 3, 
dimnames = list(c("D1", "D2", "D"), c("e1","e2", "r1")))

# 3. Setting the names of the variables and their frame of discernment
meddiag_vars1 &lt;- c(e1$valuenames, e2$valuenames, p_diag$valuenames)

# 4. Names of bca specifications (evidence and relations)
meddiag_rel_names &lt;- c("e1", "e2", "r1")

# 5. Order of elimination of variables
elim_order &lt;- c(1,2,3)

tabresul(peeling(vars_def = meddiag_vars1, hgm = meddiag_hgm,
hg_rel_names = meddiag_rel_names, elim_order = c(1, 2, 3)) )

</code></pre>

<hr>
<h2 id='plautrans'>Plausibility transformation of the singletons of a frame</h2><span id='topic+plautrans'></span>

<h3>Description</h3>

<p>Given a mass function defined on some subsets of a frame <code class="reqn">\Theta</code>, the application of the plausibility transformation to the singletons of <code class="reqn">\Theta</code> yields the probability distribution associated with this mass function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plautrans(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plautrans_+3A_x">x</code></td>
<td>
<p>A bca mass function.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>We compute the plausibility measure of all the singletons of the frame of discernment. The probability distribution of the singletons is obtained from their plausibility measures.
</p>


<h3>Value</h3>

<p>The matrix of singletons with their plausibility transformation added in the last column.
</p>


<h3>Author(s)</h3>

<p>Claude Boivin
</p>


<h3>References</h3>

<p>Cobb, B. R. and Shenoy, P.P. (2006). On the plausibility transformation method for translating belief function models to probability models. Journal of Approximate Reasoning, 41(3), April 2006, 314&ndash;330.
</p>


<h3>Examples</h3>

<pre><code class='language-R'> 
x &lt;- bca(tt = matrix(c(0,1,1,1,1,0,1,1,1),nrow = 3, 
byrow = TRUE), m = c(0.2,0.5, 0.3), 
cnames = c("a", "b", "c"), 
varnames = "x", varnb = 1)
plautrans(x)
</code></pre>

<hr>
<h2 id='productSpace'>Product space representation of a relation</h2><span id='topic+productSpace'></span>

<h3>Description</h3>

<p>This utility function takes the input matrix of a relation between two or more variables and yields its product space representation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>productSpace(tt, specnb, infovar)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="productSpace_+3A_tt">tt</code></td>
<td>
<p>A (0,1) or boolean matrix, where the variables are set side by side, as in a truth table. Each variable has a number of columns equal to the number of possible values.</p>
</td></tr>
<tr><td><code id="productSpace_+3A_specnb">specnb</code></td>
<td>
<p>A vector of integers ranging from 1 to <code>k</code>, where <code>k</code> is the number of subsets of the <code>tt</code> matrix. Values must start at one and can be increased by 1 or not. They determine the partitioning of the rows of the <code>tt</code> matrix between the <code>k</code> subsets.</p>
</td></tr>
<tr><td><code id="productSpace_+3A_infovar">infovar</code></td>
<td>
<p>A two-column matrix containing identification numbers of the variables and the number of elements of each variable (size of the frame).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The matrix of the product space representation of the relation.
</p>


<h3>Author(s)</h3>

<p>Claude Boivin
</p>


<h3>Examples</h3>

<pre><code class='language-R'> ttfw &lt;- matrix(c(1,0,1,0,0,1,0,1,1,1,1,1),nrow = 3,
  byrow = TRUE, 
  dimnames = list(NULL, c("foul", "fair", "foul", "fair")) )
 specfw &lt;- c(1,1,2) 
 infovarfw &lt;- matrix(c(5,7,2,2), ncol = 2, 
 dimnames = list(NULL, c("varnb", "size")) )
 rownames(ttfw) &lt;- nameRows(ttfw)
 ttfw
productSpace(tt = ttfw, specnb = specfw, infovar = infovarfw)
</code></pre>

<hr>
<h2 id='reduction'>Summary of a vector for any operator.</h2><span id='topic+reduction'></span><span id='topic+aplRDV'></span>

<h3>Description</h3>

<p>This utility function is used to obtain a summary of a vector of data for many operators. The function is taken from the project APL in R (<a href="https://rpubs.com/deleeuw/158476">https://rpubs.com/deleeuw/158476</a>).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>reduction(x, f)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="reduction_+3A_x">x</code></td>
<td>
<p>A vector of numbers or a character string.</p>
</td></tr>
<tr><td><code id="reduction_+3A_f">f</code></td>
<td>
<p>The operator. Must be compatible with the type of input vector (numeric or character)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The result of applying the chosen operator to all the elements of the vector is an object of length 1.
</p>


<h3>Author(s)</h3>

<p>Claude Boivin
</p>


<h3>References</h3>


<ul>
<li><p> Jan de Leeuw and Masanao Yajima (March 07, 2016) <em>APL in R (Version 009)</em>, Source code. <a href="https://rpubs.com/deleeuw/158476">https://rpubs.com/deleeuw/158476</a>
</p>
</li>
<li><p> G. Helzer. (1989): <em>An Encyclopedia of APL</em>, second edition, I-APL LTD, St. Albans, G.B.
</p>
</li>
<li><p>  L. Gilman and A. J. Rose.(1974): <em>APL an Interactive Approach</em>, Second Edition, John Wiley, New-York.
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'> reduction(c(1,2,3,4), f = "-")
 reduction(c(1,0,1,1,0), f = "|")
 reduction(c("a", "b", "c"), f = "paste")
 
</code></pre>

<hr>
<h2 id='shape'>Obtain dimensions of an array or length of a vector with a single command</h2><span id='topic+shape'></span><span id='topic+aplShape'></span>

<h3>Description</h3>

<p><code>shape</code> returns the dimension of given array or returns the length of a given vector. The function is taken from the project APL in R (<a href="https://rpubs.com/deleeuw/158476">https://rpubs.com/deleeuw/158476</a>).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>shape(a)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="shape_+3A_a">a</code></td>
<td>
<p>An array or a vector.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The dimension of the array <code>a</code> or the length of the vector <code>a</code>.
</p>


<h3>Author(s)</h3>

<p>Claude Boivin
</p>


<h3>References</h3>


<ul>
<li><p> Jan de Leeuw and Masanao Yajima (March 07, 2016) <em>APL in R (Version 009)</em>, Source code. <a href="https://rpubs.com/deleeuw/158476">https://rpubs.com/deleeuw/158476</a>
</p>
</li>
<li><p> G. Helzer. (1989): <em>An Encyclopedia of APL</em>, second edition, I-APL LTD, St. Albans, G.B.
</p>
</li>
<li><p>  L. Gilman and A. J. Rose.(1974): <em>APL an Interactive Approach</em>, Second Edition, John Wiley, New-York.
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>shape(array(c(1:6), c(2,3)))
shape(c("a", "b"))
</code></pre>

<hr>
<h2 id='swr'>The Captain's Problem. <code>swr</code>: Relation between variables Sailing delay (S), Weather at sea (W), and Repairs at sea (R)</h2><span id='topic+swr'></span>

<h3>Description</h3>

<p>This dataset is the <code>tt</code> matrix establishing a relation between S, W and R, where S = 0:3, W = (foul, fair) and R = (true, false). The goal of this relation is to account for other causes of sailing delay. All the elements (s,w,r) of (S x W x R) where W or R is true add one day of sailing delay. We put a mass value of 0.9 to this subset. The remaining mass of 0.1 is allotted to the frame.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>swr
</code></pre>


<h3>Format</h3>

<p>An integer matrix with 6 rows and 10 columns.
</p>

<dl>
<dt>[1,c(1,2)]</dt><dd><p>value = 0, not used</p>
</dd>
<dt>[1,3:10]</dt><dd><p>Identification numbers of the three variables. Column 3 to 6: variable 3; columns 7,8: variable 7, columns 9,10: variable 8</p>
</dd>
<dt>nospec</dt><dd><p>identification number of the specification</p>
</dd>
<dt>m</dt><dd><p>the value of the specification, a number between 0 and 1</p>
</dd>
<dt>3</dt><dd><p>1 if 3 is part of the specification, 0 otherwise</p>
</dd>
<dt>2</dt><dd><p>1 if 2 is part of the specification, 0 otherwise</p>
</dd>
<dt>1</dt><dd><p>1 if 1 is part of the specification, 0 otherwise</p>
</dd>
<dt>0</dt><dd><p>1 if 0 is part of the specification, 0 otherwise</p>
</dd>
<dt>foul</dt><dd><p>1 if foul is part of the specification, 0 otherwise</p>
</dd>
<dt>fair</dt><dd><p>1 if fair is part of the specification, 0 otherwise</p>
</dd>
<dt>true</dt><dd><p>1 if true is part of the specification, 0 otherwise</p>
</dd>
<dt>false</dt><dd><p>1 if false is part of the specification, 0 otherwise</p>
</dd>
</dl>



<h3>Details</h3>

<p>To construct the <code>tt</code> matrix, we put the variables S, W, R side by side, as in a truth table representation. Each triplet of the subset is described by a row of the matrix as a vector of zeros and ones.
</p>


<h3>Author(s)</h3>

<p>Claude Boivin, Stat.ASSQ
</p>


<h3>Source</h3>

<p>Almond, R.G. [1988] Fusion and Propagation in Graphical Belief Models. Computing Science and Statistics: Proceedings of the 20th Symposium on the Interface. Wegman, Edward J., Gantz, Donald T. and Miller, John J. (ed.). American Statistical Association, Alexandria, Virginia. pp 365&ndash;370.
</p>

<hr>
<h2 id='tabresul'>Prepare a table of results</h2><span id='topic+tabresul'></span>

<h3>Description</h3>

<p>This utility function is a more detailed version of the <code>belplau</code> function. Different tables of measures of belief, plausibility and of the plausibility ratio can be obtained, namely by removing subsets with zero mass if present, or by asking for singletons only. Unlike function <code>belplau</code>, function <code>tabresul</code> does not reconstruct the row names from the column names. You can assign short rownames of your choice to the tt matrix of your resulting bca before calling function <code>tabresul</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tabresul(x, singletonsOnly = FALSE, removeZeroes = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tabresul_+3A_x">x</code></td>
<td>
<p>A basic chance assignment (bca)</p>
</td></tr>
<tr><td><code id="tabresul_+3A_singletonsonly">singletonsOnly</code></td>
<td>
<p>= TRUE reduces the table of results to elementary events (singletons).</p>
</td></tr>
<tr><td><code id="tabresul_+3A_removezeroes">removeZeroes</code></td>
<td>
<p>= TRUE removes subsets with 0 mass.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of two elements: </p>

<ul>
<li><p> mbp The table of focal elements with the addition of their associated mass, degree of belief, plausibility and the plausibility ratio.
</p>
</li>
<li><p> con The measure of conflict between subsets.
</p>
</li></ul>



<h3>Author(s)</h3>

<p>Claude Boivin
</p>


<h3>Examples</h3>

<pre><code class='language-R'> 
x &lt;- bca(tt = matrix(c(0,1,1,1,1,0,1,1,1),nrow = 3,
byrow = TRUE), m = c(0.2,0.5, 0.3), 
cnames = c("a", "b", "c"), 
varnames = "x", idvar = 1)
y &lt;- bca(tt = matrix(c(1,0,0,1,1,1),nrow = 2, 
byrow = TRUE), m = c(0.6, 0.4),  
cnames = c("a", "b", "c"), varnames = "y", idvar = 1)
xy &lt;- dsrwon(x,y)
xyNorm &lt;- nzdsr(xy)
tabresul(xyNorm) 
## print("Show all elementary events")
xy1 &lt;- addTobca(nzdsr(dsrwon(x,y)), 
matrix(c(0,1,0,0,0,1), 
nrow = 2, byrow = TRUE))
tabresul(xy1)
## print("Remove focal elements with 0 mass")
tabresul(xy1, removeZeroes = TRUE)
print("Retain singletons only")
tabresul(xy1, singletonsOnly = TRUE)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
