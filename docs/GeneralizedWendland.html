<!DOCTYPE html><html><head><title>Help for package GeneralizedWendland</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {GeneralizedWendland}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#choleskyFactory'><p>Function Factory for Generating chol Function with unified arguments</p></a></li>
<li><a href='#cov.askey'><p>Askey covariance function</p></a></li>
<li><a href='#cov.wendland'><p>Generalized Wendland Covariance Function</p></a></li>
<li><a href='#covarianceFactory'><p>covarianceFactory</p></a></li>
<li><a href='#factory-covDiag'><p>Diagnostics For Arbitrary Covariance Functions</p></a></li>
<li><a href='#factory-predict'><p>Function factory for prediction generator</p></a></li>
<li><a href='#generalizedwendland-error'><p>Simple errors defined by <span class="pkg">GeneralizedWendland</span> package</p></a></li>
<li><a href='#generalizedwendland-internal'><p>Internal Functions defined in package <span class="pkg">GeneralizedWendland</span></p></a></li>
<li><a href='#GeneralizedWendland-package'><p>Fully Parametrized Generalized Covariance Function for R</p></a></li>
<li><a href='#generalizedwendland-warning'><p>Simple warnings defined by <span class="pkg">GeneralizedWendland</span> package.</p></a></li>
<li><a href='#mleFactory'><p>Function Factory for Generating mle Function with unified arguments</p></a></li>
<li><a href='#neg2loglikDiagFactory'><p>Diagnostics for arbitrarily specified, likelihood-based Gaussian process models</p></a></li>
<li><a href='#neg2loglikFactory'><p>Function Factory for <code>neg2loglikelihood</code> with Unified Input Arguments</p></a></li>
<li><a href='#optimFactory'><p>Function Factory for Optimization function with Unified Arguments</p></a></li>
<li><a href='#Rcpp_Wendland-class'><p>Class &quot;Rcpp_Wendland&quot;</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Fully Parameterized Generalized Wendland Covariance Function</td>
</tr>
<tr>
<td>Version:</td>
<td>0.6.0</td>
</tr>
<tr>
<td>Date:</td>
<td>2024-02-18</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Thomas C. Fischer &lt;thomascasparfischer@gmail.com&gt;</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.1)</td>
</tr>
<tr>
<td>SystemRequirements:</td>
<td>gsl (&gt;= 2.7)</td>
</tr>
<tr>
<td>Imports:</td>
<td>methods, stats, utils, Matrix, Rcpp, spam, spam64, parallel,
optimParallel, fields</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>Rcpp, RcppEigen, BH, Matrix</td>
</tr>
<tr>
<td>Suggests:</td>
<td>knitr, R.rsp, testthat (&ge; 3.0.0), mvtnorm, ggplot2,
gridExtra, dplyr, microbenchmark</td>
</tr>
<tr>
<td>Description:</td>
<td>A fully parameterized Generalized Wendland covariance function for use in Gaussian process models, as well as multiple methods for approximating it via covariance interpolation. The available methods are linear interpolation, polynomial interpolation, and cubic spline interpolation.
  Moreno Bevilacqua and Reinhard Furrer and Tarik Faouzi and Emilio Porcu (2019) &lt;url:&lt;https://projecteuclid.org/journalArticle/Download?urlId=10.1214%2F17-AOS1652 &gt;&gt;.
  Moreno Bevilacqua and Christian Caama√±o-Carrillo and Emilio Porcu (2022) &lt;<a href="https://arxiv.org/abs/2008.02904">arXiv:2008.02904</a>&gt;.
  Reinhard Furrer and Roman Flury and Florian Gerber (2022) &lt;url:&lt;https://CRAN.R-project.org/package=spam &gt;&gt;.</td>
</tr>
<tr>
<td>RcppModules:</td>
<td>Wendland</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>Config/testthat/edition:</td>
<td>3</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>R.rsp, knitr</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-02-18 20:50:48 UTC; thoma</td>
</tr>
<tr>
<td>Author:</td>
<td>Thomas C. Fischer [aut, cre],
  Reinhard Furrer [aut, ths],
  Josef Stocker [aut]</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-02-18 21:20:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='choleskyFactory'>Function Factory for Generating chol Function with unified arguments</h2><span id='topic+choleskyFactory'></span>

<h3>Description</h3>

<p>A function factory which returns a function of the form <code>function(Sigma)</code> which performs a cholesky decomposition using an approach tailored to the type of input Sigma. Currently works for vectors, matrices, spam objects, and dgCMatrix objects from the <span class="pkg">Matrix</span> package.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>choleskyFactory(chol.args = list(), Rstruct = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="choleskyFactory_+3A_chol.args">chol.args</code></td>
<td>
<p>A list of optional settings for a cholesky function.</p>
</td></tr>
<tr><td><code id="choleskyFactory_+3A_rstruct">Rstruct</code></td>
<td>
<p>A <code>spam.chol.NgPeyton</code> object which represents the sparsity structure of covariance matrix Sigma.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The output of <code>choleskyFactory</code> is intended to replace calls to <code>chol.default</code> or <code>chol.spam</code>. The object type is determined during runtime, after which the appropriate function is called to obtain the cholesky decomposition. For spam objects, the function attempts to use <code>update.spam.chol.NgPeyton</code> if <code>Rstruct</code> is specified, and upon failure defaults to <code>chol.spam</code>. The result is then assigned in the execution environment of <code>choleskyFactory</code>, so that <code>Rstruct</code> will be defined in the next call.
</p>


<h3>Value</h3>

<p>A function of the form <code>function(Sigma)</code>.
</p>


<h3>Author(s)</h3>

<p>Thomas Caspar Fischer</p>


<h3>References</h3>

<p>Hadley Wickham (2015) <em>Advanced R</em>, CRC Press.
Reinhard Furrer and Roman Flury and Florian Gerber (2022) spam: SPArse Matrix, R package version 2.8-0.
</p>


<h3>See Also</h3>

<p><code><a href="base.html#topic+chol">chol</a></code>,
<code><a href="spam.html#topic+chol.spam">chol.spam</a></code>,
<code><a href="spam.html#topic+update.spam.chol.NgPeyton">update.spam.chol.NgPeyton</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(1234)
locations &lt;- data.frame(x = runif(10), y = runif(10))
theta &lt;- c(0.5,1,1,0,0)
dmat &lt;- as.matrix(dist(locations))
Sigma &lt;- cov.wendland(dmat, theta)

cholFun &lt;- choleskyFactory(chol.args = list())
cholD &lt;- cholFun(Sigma)

cholFun &lt;- choleskyFactory(chol.args = list(pivot = TRUE))
cholD_pivot &lt;- cholFun(Sigma)

cholFun &lt;- choleskyFactory(chol.args = list(pivot = "RCM"))
cholS_RCM &lt;- cholFun(spam::as.spam(Sigma))
</code></pre>

<hr>
<h2 id='cov.askey'>Askey covariance function</h2><span id='topic+cov.askey'></span>

<h3>Description</h3>

<p>A covariance function of the form
</p>
<p style="text-align: center;"><code class="reqn">\rho_{\beta,\kappa,\mu} = \begin{cases} \sigma + \theta \quad 0 \leq r &lt; \epsilon \\ (1-r)^{\mu} \quad  \epsilon \leq r &lt; 1 \\ 0 \quad 1 \leq r \end{cases}</code>
</p>

<p>where <code class="reqn">r=h/\beta</code>. This is equivalent to the generalized Wendland covariance with <code class="reqn">\kappa=0</code>, but much more computationally efficient.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cov.askey(h, theta, ..., cov.args = list())
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cov.askey_+3A_h">h</code></td>
<td>
<p>A numeric vector, matrix, or spam object storing distances.</p>
</td></tr>
<tr><td><code id="cov.askey_+3A_theta">theta</code></td>
<td>
<p>Numeric vector <code class="reqn">\vec{\theta}=(\beta, \sigma, \mu, \theta)</code> storing parameters.</p>
</td></tr>
<tr><td><code id="cov.askey_+3A_...">...</code></td>
<td>
<p>Other arguments.</p>
</td></tr>
<tr><td><code id="cov.askey_+3A_cov.args">cov.args</code></td>
<td>
<p>Named list of arguments. See Details.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Using the list cov.args, users can provide the following arguments:
</p>

<dl>
<dt>cov.eps (default: <code>.Machine$double.eps^0.5</code>)</dt><dd><p>The threshold distance <code class="reqn">\epsilon</code> below which the function will return <code class="reqn">\sigma + \theta</code>.</p>
</dd>
</dl>



<h3>Value</h3>

<p>Returns an object of the same type as input object h which stores the computed covariance values, i.e. a spam object if input h was also a spam object.
</p>


<h3>Author(s)</h3>

<p>Thomas Caspar Fischer</p>


<h3>References</h3>

<p>Moreno Bevilacqua and Tarik Faouzi and Reinhard Furrer and Emilio Porcu (2019) Estimation and prediction using generalized Wendland covariance functions under fixed domain asymptotics, <em>Annals of Statistics</em>, <b>47</b>(2), 828&ndash;856.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+cov.wendland">cov.wendland</a></code>
</p>

<hr>
<h2 id='cov.wendland'>Generalized Wendland Covariance Function</h2><span id='topic+cov.wendland'></span>

<h3>Description</h3>

<p>A fully parametrized generalized Wendland covariance function for use in geostatistical modeling, as well as multiple methods of obtaining computationally inexpensive approximations.
</p>
<p style="text-align: center;"><code class="reqn">\rho_{\beta,\kappa,\mu} = \begin{cases}\sigma + \theta \quad 0 \leq r &lt; \epsilon \\ \frac{\sigma}{B(1+2\kappa,\mu)} \int_r^1 (u^2-r^2)^\kappa (1-u)^{\mu-1} du \quad \epsilon \leq r &lt; 1 \\ 0 \quad 1 \leq r \end{cases}</code>
</p>

<p>where <code class="reqn">r=h/\beta</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cov.wendland(h, theta, ..., cov.args = list())
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cov.wendland_+3A_h">h</code></td>
<td>
<p>A numeric vector, matrix, or spam object storing distances.</p>
</td></tr>
<tr><td><code id="cov.wendland_+3A_theta">theta</code></td>
<td>
<p>Numeric vector <code class="reqn">\vec{\theta}=(\beta, \sigma, \kappa, \mu, \theta)</code> storing parameters.</p>
</td></tr>
<tr><td><code id="cov.wendland_+3A_...">...</code></td>
<td>
<p>Other arguments.</p>
</td></tr>
<tr><td><code id="cov.wendland_+3A_cov.args">cov.args</code></td>
<td>
<p>Named list of arguments. See Details.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Using the list cov.args, users can provide the following additional arguments:
</p>

<dl>
<dt>numint.abstol (default: <code>1e-3</code>)</dt><dd><p>Absolute tolerance for numerical integration.</p>
</dd>
<dt>numint.reltol (default: <code>1e-3</code>)</dt><dd><p>Relative tolerance for numerical integration.</p>
</dd>
<dt>numint.qag_key (default: <code>0</code>)</dt><dd><p>Method to use in QAG integration (Values 1 - 6)</p>
</dd>
<dt>numint.subintervals (default: <code>0</code>)</dt><dd><p>Number of subintervals to use in QAG/QAGS integration.</p>
</dd>
<dt>interp.method (default: <code>'none'</code>)</dt><dd><p>Method to use for covariance interpolation. Valid methods are 'none', 'linear', 'polynomial', and 'cspline'.</p>
</dd>
<dt>interp.num_support (default: <code>0</code>)</dt><dd><p>Number of support points to use for covariance interpolation.</p>
</dd>
<dt>cov.reparameterize (default: <code>TRUE</code>)</dt><dd><p>Whether to apply the reparameterization <code class="reqn">\mu=\frac{1+d}{2} + \kappa + \nu</code>, where <code class="reqn">\nu</code> takes the place of <code class="reqn">\mu</code> in input vector <code class="reqn">\vec{\theta}</code>. This allows users to use box constraints in maximum likelihood estimation, as the covariance function is valid for <code class="reqn">\nu \in [0,\infty)</code> rather than <code class="reqn">\mu \in [\frac{1+d}{2} + \kappa,\infty)</code>.</p>
</dd>
<dt>cov.eps (default: <code>.Machine$double.eps^0.5</code>)</dt><dd><p>The threshold distance <code class="reqn">\epsilon</code> below which the function will return <code class="reqn">\sigma + \theta</code>.</p>
</dd>
<dt>cov.d_value (default: <code>2</code>)</dt><dd><p>Dimensionality of space in which measurements were taken. This only takes effect if <code>cov.reparameterize</code> is TRUE.</p>
</dd>
</dl>



<h3>Value</h3>

<p>Returns an object of the same type as input object h which stores the computed covariance values, i.e. a spam object if input h was also a spam object.
</p>


<h3>Author(s)</h3>

<p>Thomas Caspar Fischer</p>


<h3>References</h3>

<p>Moreno Bevilacqua and Tarik Faouzi and Reinhard Furrer and Emilio Porcu (2019) Estimation and prediction using generalized Wendland covariance functions under fixed domain asymptotics, <em>Annals of Statistics</em>, <b>47</b>(2), 828&ndash;856.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>h &lt;- seq(0, 1, 0.01)
plot(0, type = "n", xlab = "Distance", ylab = "Covariance",
     xlim = c(0, 1), ylim = c(0,1))

theta &lt;- c(range=1, sill=1, kappa=1, mu=0, nugget=0)
cov.args &lt;- list()
lines(x = h, y = cov.wendland(h, theta, cov.args = cov.args),
      lwd = 2)

theta &lt;- c(range=1, sill=1, kappa=1, mu=0, nugget=0)
cov.args &lt;- list(cov.reparametrize = FALSE, cov.d_value = 2)
theta[4] &lt;- (1 + cov.args[[2]])/2 + theta[3] + theta[4]
lines(x = h, y = cov.wendland(h, theta, cov.args = cov.args),
      col = "red", lty = 3, lwd = 3.5)

theta &lt;- c(range=0.5, sill=1, kappa=1, mu=0, nugget=0)
cov.args &lt;- list(interp.method="cspline", interp.num_support=100)
lines(x = h, y = cov.wendland(h, theta, cov.args = cov.args),
      col = "green", lwd = 2)

legend("topright", legend = c("Default", "No reparameterization",
                              "Cubic spline interpolation"),
       col = c(1, 2, 3), lty = c(1,3,1), lwd = c(2, 3.5, 2))
</code></pre>

<hr>
<h2 id='covarianceFactory'>covarianceFactory</h2><span id='topic+covarianceFactory'></span>

<h3>Description</h3>

<p>A function factory which sets up a covariance function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>covarianceFactory(covariance, cov.args = list())
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="covarianceFactory_+3A_covariance">covariance</code></td>
<td>
<p>A function which takes as input an object containing distances (h), a vector of parameters (theta), and a list of optional settings (cov.args)</p>
</td></tr>
<tr><td><code id="covarianceFactory_+3A_cov.args">cov.args</code></td>
<td>
<p>A list of optional settings for a covariance function.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>covarianceFactory()</code> is a function factory which takes as input an arbitrary covariance function and a list of additional arguments and returns a function with these arguments. The argument <code>cov.args</code> mainly serves to pass the relevant arguments to the covariance function, but also allows users to specify the following two arguments:
</p>

<dl>
<dt>cov.fixed_range_value (default: <code>NA</code>)</dt><dd><p>A constant value for the range parameter. Note that the code assumes that the first value of <code>theta</code> corresponds to the range parameter, as this notation is used in the <span class="pkg">spam</span> package.</p>
</dd>
<dt>cov.fixed_nugget_value (default: <code>NA</code>)</dt><dd><p>A constant value for the nugget parameter. Note that the code assumes that the last value of <code>theta</code> corresponds to the nugget parameter, as this notation is used in the <span class="pkg">spam</span> package.</p>
</dd>
</dl>

<p>Note that if either of these arguments are specified, the corresponding entries should also be omitted in <code>theta</code>.
</p>


<h3>Value</h3>

<p>A function of the form <code>function(h, theta)</code>. This function is enclosed in the execution environment of <code>choleskyFactory</code> and hence has access to the arguments <code>covariance</code> and <code>cov.args</code>. The manufactured function returns the result of <code>covariance(h = h, theta = theta, cov.args = cov.args)</code>.
</p>


<h3>Author(s)</h3>

<p>Thomas Caspar Fischer</p>


<h3>References</h3>

<p>Wickham, H. (2015) <em>Advanced R</em>, CRC Press.
</p>


<h3>See Also</h3>

<p><code><a href="spam.html#topic+covmat">covmat</a></code> and
<code><a href="#topic+cov.wendland">cov.wendland</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(GeneralizedWendland)
library(spam)

hs &lt;- seq(0, 1, 0.05)
covSph &lt;- covarianceFactory(cov.sph)
covExp &lt;- covarianceFactory(cov.exp)
covWend &lt;- covarianceFactory(cov.wendland)

plot(0, type = "n", xlim = c(0, 1), ylim = c(0, 1))
lines(hs, covSph(hs, theta = c(0.5, 1, 0)))
lines(hs, covExp(hs, theta = c(0.5, 1, 0)), col = "red")
lines(hs, covWend(hs, theta = c(0.5, 1, 0.5, 0.5, 0)), col = "green")
</code></pre>

<hr>
<h2 id='factory-covDiag'>Diagnostics For Arbitrary Covariance Functions</h2><span id='topic+covDiagFactory'></span><span id='topic+accumulated_error'></span><span id='topic+point_diagnostics'></span>

<h3>Description</h3>

<p>A suite of diagnostic tools. The functions described here provide the user with quick access to diagnostics for arbitrary target covariance functions and arbitrary reference covariance functions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>covDiagFactory(target_covariance,
  diagnostic_funs = c("accumulated_error", "point_diagnostics"),
  reference_covariance = cov.askey, reference_cov.args = list())

accumulated_error(target_covFun, target_cov.theta, reference_covFun,
  reference_cov.theta, ..., absolute = TRUE, lower = 0, upper = 1,
  subdivisions = 500L, abs.tol = .Machine$double.eps^0.5,
  rel.tol = .Machine$double.eps^0.25)

point_diagnostics(target_covFun, target_cov.theta, reference_covFun,
  reference_cov.theta, ..., grid_resolution = 100)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="factory-covDiag_+3A_diagnostic_funs">diagnostic_funs</code></td>
<td>
<p>A character vector for specifying which diagnostics to compute and return. Currently, <code>accumulated_error</code> and <code>point_diagnostics</code> are implemented. Note that the functions themselves are not intended to be called directly by the user.</p>
</td></tr>
<tr><td><code id="factory-covDiag_+3A_reference_covariance">reference_covariance</code></td>
<td>
<p>Covariance function with formals <code>function(h, theta, ..., cov.args)</code></p>
</td></tr>
<tr><td><code id="factory-covDiag_+3A_reference_covfun">reference_covFun</code></td>
<td>
<p>Same as reference_covariance, but implicitly assumes that the input was generated using <code>covarianceFactory()</code>.</p>
</td></tr>
<tr><td><code id="factory-covDiag_+3A_reference_cov.args">reference_cov.args</code></td>
<td>
<p>List with additional arguments to be passed to reference_covariance.</p>
</td></tr>
<tr><td><code id="factory-covDiag_+3A_reference_cov.theta">reference_cov.theta</code></td>
<td>
<p>Numeric vector containing parameters for reference_covariance.</p>
</td></tr>
<tr><td><code id="factory-covDiag_+3A_target_covariance">target_covariance</code></td>
<td>
<p>Covariance function with formals <code>function(h, theta, ..., cov.args)</code></p>
</td></tr>
<tr><td><code id="factory-covDiag_+3A_target_cov.theta">target_cov.theta</code></td>
<td>
<p>Numeric vector containing parameters for target_covariance.</p>
</td></tr>
<tr><td><code id="factory-covDiag_+3A_target_covfun">target_covFun</code></td>
<td>
<p>Same as target_covariance, but implicitly assumes that the input was generated using <code>covarianceFactory()</code>.</p>
</td></tr>
<tr><td><code id="factory-covDiag_+3A_...">...</code></td>
<td>
<p>Other arguments</p>
</td></tr>
<tr><td><code id="factory-covDiag_+3A_grid_resolution">grid_resolution</code></td>
<td>
<p>Number of points <code class="reqn">n</code> to evaluate the covariance function at.</p>
</td></tr>
<tr><td><code id="factory-covDiag_+3A_absolute">absolute</code></td>
<td>
<p>Logical value. Whether to return absolute value.</p>
</td></tr>
<tr><td><code id="factory-covDiag_+3A_lower">lower</code></td>
<td>
<p>Lower boundary for accumulated error. Defaults to 0. Passed to <code>integrate()</code>.</p>
</td></tr>
<tr><td><code id="factory-covDiag_+3A_upper">upper</code></td>
<td>
<p>Upper boundary for accumulated error. Defaults to 1. Passed to <code>integrate()</code>.</p>
</td></tr>
<tr><td><code id="factory-covDiag_+3A_subdivisions">subdivisions</code></td>
<td>
<p>The maximum number of subintervals. Passed to <code>integrate()</code>.</p>
</td></tr>
<tr><td><code id="factory-covDiag_+3A_abs.tol">abs.tol</code></td>
<td>
<p>Absolute accuracy. Passed to <code>integrate()</code></p>
</td></tr>
<tr><td><code id="factory-covDiag_+3A_rel.tol">rel.tol</code></td>
<td>
<p>Relative accuracy. Passed to <code>integrate()</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function manufactured by <code>covDiagFactory</code> has the form <code>function(target_theta_list, target_args_list = list(), reference_cov.theta = NULL, ...)</code> and serves to iterate over a large variety of parameters.
</p>

<dl>
<dt>target_theta_list</dt><dd><p>List of named numeric vectors, each providing at least one or more values for a parameter.</p>
</dd>
<dt>target_args_list (default = <code>list()</code>)</dt><dd><p>List of named vectors, each providing at least one or more values for each argument to be provided to target_covariance.</p>
</dd>
<dt>reference_cov.theta (default = <code>NULL</code>)</dt><dd><p>A numeric vector with parameters for the reference covariance. This is primarily intended to use when comparing different covariance functions, in which case the target covariance is compared to the reference with constant parameters.If this argument is left at default and the target and reference are identical, the parameters in <code>target_theta_list</code> will be used by both. Otherwise this will raise an exception.</p>
</dd>
</dl>



<h3>Value</h3>

<p><code>covDiagFactory()</code> is a function factory which generates a function for computing diagnostics across a large variety of parameter values and additional arguments. The manufactured function has the form <code>function(target_theta_list, target_args_list = list(), reference_cov.theta = NULL, ...</code> and returns a list of the same length as <code>diagnostic_funs</code>, each entry storing a <code>data.frame</code> with the results returned by the associated diagnostic function.
</p>


<h3>Available diagnostic functions</h3>

<p>All diagnostic functions have in common that, apart from the required parameters kappa and mu, any remaining parameters are optional and captured using the <code>...</code> operator. Any unspecified arguments are left at default. The provided arguments are then turned into a grid using <code>expand.grid</code>, which is then iterated over to compute the requested diagnostic metrics.
Note that there are some built-in checks which ensure that invalid configurations are dropped from the grid. For example, rows with interpolator = 'none' and a non-zero number of supports are dropped to prevent redundant computations.
</p>


<h4>Accumulated Error</h4>

<p>The accumulated error corresponds to the area between the approximated and exact covariance curve.</p>



<h4>Point diagnostics</h4>

<p>This option returns error metrics across a user-defined number of points on the interval [0,1]. The metrics returned are &quot;error&quot;, &quot;absolute error&quot;, &quot;maximum error&quot;, &quot;target covariance value&quot;, and &quot;reference covariance value&quot;.</p>



<h3>Author(s)</h3>

<p>Thomas Caspar Fischer</p>


<h3>See Also</h3>

<p><code><a href="#topic+cov.wendland">cov.wendland</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>
interpolators &lt;- c("linear", "cspline", "polynomial")
diagnostics &lt;- c("accumulated_error", "point_diagnostics")

diagnosticFun &lt;- covDiagFactory(cov.wendland, diagnostic_funs = diagnostics,
  reference_covariance = cov.wendland)
target_theta_list &lt;- list(range = 0.5, sill = 1, kappa = c(0, 0.5, 1), mu = 0,
  nugget = 0)
target_args_list &lt;- list(interp.method = interpolators, interp.num_support = 25)
wendland_comparison &lt;- diagnosticFun(target_theta_list = target_theta_list,
  target_args_list = target_args_list)

diagnosticFun &lt;- covDiagFactory(cov.wendland, diagnostic_funs = diagnostics,
  reference_covariance = cov.askey)
target_theta_list &lt;- list(range = 0.5, sill = 1, kappa = 0, mu = 0.5, nugget = 0)
target_args_list &lt;- list(interp.method = interpolators, interp.num_support = 25)
askey_comparison &lt;- diagnosticFun(target_theta_list = target_theta_list,
  target_args_list = target_args_list, reference_cov.theta = c(0.5, 1, 0.5, 0))
</code></pre>

<hr>
<h2 id='factory-predict'>Function factory for prediction generator</h2><span id='topic+predictionFactory'></span>

<h3>Description</h3>

<p>A function factory which generates a function for sampling from the predictive distribution
</p>


<h3>Usage</h3>

<pre><code class='language-R'>predictionFactory(y, locs0, locs1, covariance, X0 = list2DF(nrow = nrow(locs0)),
  X1 = list2DF(nrow = nrow(locs1)), ..., cov.args = list(), chol.args = list(),
  use_spam = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="factory-predict_+3A_y">y</code></td>
<td>
<p>Observed measurements.</p>
</td></tr>
<tr><td><code id="factory-predict_+3A_locs0">locs0</code></td>
<td>
<p>Locations at which measurements were obtained.</p>
</td></tr>
<tr><td><code id="factory-predict_+3A_locs1">locs1</code></td>
<td>
<p>Locations at which to predict.</p>
</td></tr>
<tr><td><code id="factory-predict_+3A_covariance">covariance</code></td>
<td>
<p>Covariance function.</p>
</td></tr>
<tr><td><code id="factory-predict_+3A_x0">X0</code></td>
<td>
<p>Covariates. By default corresponds to an empty data.frame() with <code>nrow(locs0)</code> rows.</p>
</td></tr>
<tr><td><code id="factory-predict_+3A_x1">X1</code></td>
<td>
<p>Covariates for new locations. By default corresponds to an empty data.frame() with <code>nrow(locs1)</code> rows.</p>
</td></tr>
<tr><td><code id="factory-predict_+3A_...">...</code></td>
<td>
<p>Additional arguments. Unused.</p>
</td></tr>
<tr><td><code id="factory-predict_+3A_cov.args">cov.args</code></td>
<td>
<p>Additional arguments for covariance function.</p>
</td></tr>
<tr><td><code id="factory-predict_+3A_chol.args">chol.args</code></td>
<td>
<p>Additional arguments for function used to compute cholesky decomposition.</p>
</td></tr>
<tr><td><code id="factory-predict_+3A_use_spam">use_spam</code></td>
<td>
<p>Logical value. If TRUE, use spam to compute predictions.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a function of the form <code>function(n, param)</code>, where n corresponds to the number of simulations to run, and param is a parameter vector as returned by <code>optim</code>.
</p>


<h3>Author(s)</h3>

<p>Thomas Caspar Fischer</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(23)
n &lt;- 100
res &lt;- c(20, 20)

locs &lt;- data.frame(x = runif(n), y = runif(n))
locs_new &lt;- expand.grid(x = seq(0, 1, length.out = res[1]),
                        y = seq(0, 1, length.out = res[2]))
range &lt;- 0.3
dmat &lt;- as.matrix(dist(locs))
theta &lt;- c(range, 1, 1, 0, 0)
cov.args &lt;- list()
chol.args &lt;- list()
Sigma &lt;- cov.wendland(h = dmat, theta = theta, cov.args = cov.args)
y &lt;- c(spam::rmvnorm(n = 1, Sigma = Sigma))

predictionFun &lt;- predictionFactory(y = y, locs0 = locs, locs1 = locs_new,
  covariance = cov.wendland, cov.args = cov.args, chol.args = chol.args,
  use_spam = FALSE)

predictions &lt;- predictionFun(n=10, param=theta)

image(x = seq(0, 1, length.out=res[1]),
      y = seq(0, 1, length.out=res[2]),
      z = matrix(apply(predictions,2,mean), res[1], res[2]),
      col = hcl.colors(9, "Blue-Red"),
      breaks = qnorm(seq(0.05, 0.95, 0.1)),
      xlab = "", ylab = "", xaxt = "n", yaxt = "n",
      useRaster = TRUE)

</code></pre>

<hr>
<h2 id='generalizedwendland-error'>Simple errors defined by <span class="pkg">GeneralizedWendland</span> package</h2><span id='topic+generalizedwendland-error'></span><span id='topic+update.spam.chol.error'></span><span id='topic+covfun.notfunction.error'></span>

<h3>Description</h3>

<p>An overview of the <code>simpleError</code> objects defined by the <span class="pkg">GeneralizedWendland</span> package.
</p>


<h3>Error definitions</h3>


<dl>
<dt><code>update.spam.chol.error</code>: <em>&quot;Updated covariance entries do not match length of original one.&quot;</em></dt><dd><p> Warning which is raised when <code>update.spam.chol.NgPeyton</code> fails because the length of the entries in the updated covariance matrix is not equal to the length of the original matrix. This usually indicates that the initial sparsity structure was too sparse for the given parameters.</p>
</dd>
<dt><code>wendland.insuffparam.error</code>: <em>&quot;Too few parameters for Wendland.&quot;</em></dt><dd><p>Insert description here</p>
</dd>
<dt><code>wendland.excessparam.error</code>: <em>&quot;Too many parameters for Wendland. Did you supply fix range or nugget?&quot;</em></dt><dd><p>Insert description here</p>
</dd>
<dt><code>covfun.notfunction.error</code>: <em>&quot;Argument covariance must be a function.&quot;</em></dt><dd><p>Insert description here</p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>Thomas Caspar Fischer</p>

<hr>
<h2 id='generalizedwendland-internal'>Internal Functions defined in package <span class="pkg">GeneralizedWendland</span></h2><span id='topic+generalizedwendland-internal'></span><span id='topic+control.wendland'></span><span id='topic+control.askey'></span>

<h3>Description</h3>

<p>The functions or variables listed here are used internally, i.e. they are not intended to be called directly by the user.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>control.wendland(numint.abstol = getOption("wendland.numint.abstol"),
  numint.reltol = getOption("wendland.numint.reltol"),
  numint.qag_key = getOption("wendland.numint.qag_key"),
  numint.subintervals = getOption("wendland.numint.subintervals"),
  interp.method = getOption("wendland.interp.method"),
  interp.num_support = getOption("wendland.interp.num_support"),
  cov.reparameterize = getOption("wendland.cov.reparameterize"),
  cov.eps = getOption("wendland.cov.eps"),
  cov.d_value = getOption("wendland.cov.d_value"), ...)

control.askey(cov.reparameterize = getOption("wendland.cov.reparameterize"),
  cov.eps = getOption("wendland.cov.eps"),
  cov.d_value = getOption("wendland.cov.d_value"), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="generalizedwendland-internal_+3A_numint.abstol">numint.abstol</code></td>
<td>
<p>Absolute tolerance for numerical integration (default: 1e-3).</p>
</td></tr>
<tr><td><code id="generalizedwendland-internal_+3A_numint.reltol">numint.reltol</code></td>
<td>
<p>Relative tolerance for numerical integration (default: 1e-3).</p>
</td></tr>
<tr><td><code id="generalizedwendland-internal_+3A_numint.qag_key">numint.qag_key</code></td>
<td>
<p>Method to use in QAG integration, from 0-6 (default: 0).</p>
</td></tr>
<tr><td><code id="generalizedwendland-internal_+3A_numint.subintervals">numint.subintervals</code></td>
<td>
<p>Number of subintervals to use in QAG/QAGS integration (default: 0).</p>
</td></tr>
<tr><td><code id="generalizedwendland-internal_+3A_interp.method">interp.method</code></td>
<td>
<p>Method to use for covariance interpolation. Valid methods are 'none', 'linear', 'polynomial', and 'cspline' (default: 'none').</p>
</td></tr>
<tr><td><code id="generalizedwendland-internal_+3A_interp.num_support">interp.num_support</code></td>
<td>
<p>Number of support points to use for covariance interpolation (default: 0).</p>
</td></tr>
<tr><td><code id="generalizedwendland-internal_+3A_cov.reparameterize">cov.reparameterize</code></td>
<td>
<p>Whether to apply the reparameterization <code class="reqn">\mu=\frac{1+d}{2} + \kappa + \nu</code>, where <code class="reqn">\nu</code> takes the place of <code class="reqn">\mu</code> in input vector <code class="reqn">\vec{\theta}</code> (default: TRUE). This allows users to use box constraints in maximum likelihood estimation, as the covariance function is valid for <code class="reqn">\nu \in [0,\infty)</code> rather than <code class="reqn">\mu \in [\frac{1+d}{2} + \kappa,\infty)</code>.</p>
</td></tr>
<tr><td><code id="generalizedwendland-internal_+3A_cov.eps">cov.eps</code></td>
<td>
<p>The threshold distance <code class="reqn">\epsilon</code> below which the function will return <code class="reqn">\sigma + \theta</code> (default: .Machine$double.eps^0.5).</p>
</td></tr>
<tr><td><code id="generalizedwendland-internal_+3A_cov.d_value">cov.d_value</code></td>
<td>
<p>Dimensionality of space in which measurements were taken (default: 2). This only takes effect if <code>cov.reparameterize</code> is TRUE.</p>
</td></tr>
<tr><td><code id="generalizedwendland-internal_+3A_...">...</code></td>
<td>
<p>Other arguments. Unused.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The functions <code>control.wendland</code> and <code>control.askey</code> are helper functions which create a named list containing the relevant default arguments passed via the <code>cov.args</code> argument of <code>cov.wendland</code> and <code>cov.askey</code> respectively. In addition, users can override the default values.
</p>


<h3>Value</h3>

<p>A named list.
</p>


<h3>Author(s)</h3>

<p>Thomas Caspar Fischer</p>

<hr>
<h2 id='GeneralizedWendland-package'>Fully Parametrized Generalized Covariance Function for R</h2><span id='topic+GeneralizedWendland-package'></span><span id='topic+GeneralizedWendland'></span><span id='topic+generalizedwendland-package'></span><span id='topic+generalizedwendland'></span>

<h3>Description</h3>

<p>This package provides a fully parametrized generalized Wendland covariance function for use in geostatistical modeling, as well as various options for approximations and adjustments. In addition, the package comes with a modified process for parameter estimation, based on the spam-implementations, but compartmentalized using function factories.
</p>


<h3>Details</h3>

<p>The package requires the user to complete some initial steps before it can be used. Apart from the R dependencies, the user will need to manually install the GNU Scientific Library on their system and ensure that R can find the required libraries. On Windows systems, users can install devtools and then install gsl via MSYS2 &gt; pacman.
</p>


<h3>Author(s)</h3>

<p>Thomas Caspar Fischer</p>


<h3>See Also</h3>

<p><code><a href="#topic+cov.wendland">cov.wendland</a></code>.
</p>

<hr>
<h2 id='generalizedwendland-warning'>Simple warnings defined by <span class="pkg">GeneralizedWendland</span> package.</h2><span id='topic+generalizedwendland-warning'></span><span id='topic+update.spam.chol.warn'></span><span id='topic+wendland.interp.redundantsupport.warn'></span><span id='topic+wendland.interp.lowsupport.warn'></span><span id='topic+wendland.interp.unimplemented.warn'></span>

<h3>Description</h3>

<p>An overview of the <code>simpleError</code> objects defined by the <span class="pkg">GeneralizedWendland</span> package.
</p>


<h3>Warning definitions</h3>


<dl>
<dt><code>update.spam.chol.warn</code>: <em>&quot;Updated covariance entries do not match length of original one. Deleting stored Rstruct.&quot;</em></dt><dd>
<p>Warning which is raised when <code>update.spam.chol.NgPeyton</code> fails because the length of the entries in the updated covariance matrix is not equal to the length of the original matrix. This usually indicates that the initial sparsity structure was too sparse for the given parameters.</p>
</dd>
<dt><code>wendland.interp.redundantsupport.warn</code>: <em>&quot;Argument interp.num_support &gt; 0 while using exact method. Set to 0.&quot;</em></dt><dd><p>Insert description here.</p>
</dd>
<dt><code>wendland.interp.lowsupport.warn</code>: <em>&quot;Argument interp.method != 'none' with less than 3 support points. Forced to 'none'.&quot;</em></dt><dd><p>Insert description here.</p>
</dd>
<dt><code>wendland.interp.unimplemented.warn</code>: &quot;Interpolator not implemented. Forcing exact method.&quot;</dt><dd><p>Insert description here.</p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>Thomas Caspar Fischer</p>

<hr>
<h2 id='mleFactory'>Function Factory for Generating mle Function with unified arguments</h2><span id='topic+mleFactory'></span>

<h3>Description</h3>

<p>A factory function which returns a function of the form <code>function(y, X = data.frame(), distmat, init_parameters, theta_llim, theta_ulim)</code> which can be called to compute the maximum likelihood estimates for a Kriging model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mleFactory(covariance, cov.args = list(), chol.args = list(),
  optim.args = list(), hessian = FALSE, optimParallel.args = list())
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mleFactory_+3A_covariance">covariance</code></td>
<td>
<p>A function of the form <code>function(h, theta, ..., cov.args = list())</code>, where h is an object storing a distance matrix, theta is a numeric vector of parameters for the linear predictor and covariance function, and cov.args is a list of optional arguments for the covariance function.</p>
</td></tr>
<tr><td><code id="mleFactory_+3A_cov.args">cov.args</code></td>
<td>
<p>A list of optional settings for a covariance function.</p>
</td></tr>
<tr><td><code id="mleFactory_+3A_chol.args">chol.args</code></td>
<td>
<p>A list of optional settings for a cholesky function. <em>Note</em>: Valid input arguments change depending on whether the distance matrix provided to the output function is sparse. This may change in a future version.</p>
</td></tr>
<tr><td><code id="mleFactory_+3A_optim.args">optim.args</code></td>
<td>
<p>A list of optional settings for optim. See <code><a href="stats.html#topic+optim">optim</a></code> for documentation of valid arguments.</p>
</td></tr>
<tr><td><code id="mleFactory_+3A_hessian">hessian</code></td>
<td>
<p>A logical value which specifies whether the hessian matrix is to be returned in the output. Is FALSE by default.</p>
</td></tr>
<tr><td><code id="mleFactory_+3A_optimparallel.args">optimParallel.args</code></td>
<td>
<p>A list of optional settings for optimParallel. See <code>optimParallel</code> for documentation of valid arguments.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The purpose of this function factory is to return an mle function with unified arguments. The returned function performs the same task as for example <code>spam::mle()</code>, but simplifies the process in two ways: The returned function detects whether the Gaussian process is a zero-mean process through the input argument X and whether methods from the <span class="pkg">spam</span> package should be used based on the type of input argument distmat, and autonomously chooses appropriate methods to compute the neg2loglikelihood. Hence the user does not need to choose a specialized method themselves.
</p>


<h3>Value</h3>

<p>A function of the form <code>function(y, X = data.frame(), distmat, beta0 = NULL, init_parameters, theta_llim, theta_ulim)</code> which returns the output of <code>optim</code> or <code>optimParallel</code> if <code>optimParallel.args</code> was specified.
</p>


<h3>Author(s)</h3>

<p>Thomas Caspar Fischer</p>


<h3>References</h3>

<p>Hadley Wickham (2015) <em>Advanced R</em>, CRC Press.
</p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+optim">optim</a></code>,
<code>optimParallel</code>,
<code><a href="#topic+covarianceFactory">covarianceFactory</a></code>,
<code><a href="#topic+choleskyFactory">choleskyFactory</a></code> and
<code><a href="#topic+optimFactory">optimFactory</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(57)
n &lt;- 50
range &lt;- 0.4
theta  &lt;- c(range, 1, 1, 0, 0)

locs &lt;- data.frame(x = runif(n), y = runif(n))
dmat  &lt;- as.matrix(dist(locs))
Sigma &lt;- cov.wendland(h = dmat, theta = theta)
y &lt;- c(spam::rmvnorm(1, Sigma = Sigma))

init_parameters   &lt;- c(0.7, 2, 0, 2, 2)
lower_constraints &lt;- c(0.1, 0.1, 0, 0, 0)
upper_constraints &lt;- c(sqrt(2), 2, 2, 2, 2)

mleFunction &lt;- mleFactory(covariance = cov.wendland)
mle_result1 &lt;- mleFunction(y = y, distmat = dmat,
                           init_parameters = init_parameters, theta_llim = lower_constraints,
                           theta_ulim = upper_constraints)

mleFunctionDM &lt;- mleFactory(covariance = cov.wendland,
                            cov.args = list(fixed_range_value = range))
mle_result2 &lt;- mleFunctionDM(y = y, X = data.frame(), distmat = dmat,
                             init_parameters = init_parameters[-1],
                             theta_llim = lower_constraints[-1],
                             theta_ulim = upper_constraints[-1])
</code></pre>

<hr>
<h2 id='neg2loglikDiagFactory'>Diagnostics for arbitrarily specified, likelihood-based Gaussian process models</h2><span id='topic+neg2loglikDiagFactory'></span>

<h3>Description</h3>

<p>A helper function for rapidly exploring the parameter space around the maximum likelihood estimate
</p>


<h3>Usage</h3>

<pre><code class='language-R'>neg2loglikDiagFactory(y, X = data.frame(), distmat, covariance, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="neg2loglikDiagFactory_+3A_y">y</code></td>
<td>
<p>Dependent variable</p>
</td></tr>
<tr><td><code id="neg2loglikDiagFactory_+3A_x">X</code></td>
<td>
<p>Optional design matrix with covariates</p>
</td></tr>
<tr><td><code id="neg2loglikDiagFactory_+3A_distmat">distmat</code></td>
<td>
<p>Distance matrix. Can be provided either as a dense matrix or spam object.</p>
</td></tr>
<tr><td><code id="neg2loglikDiagFactory_+3A_covariance">covariance</code></td>
<td>
<p>Covariance function.</p>
</td></tr>
<tr><td><code id="neg2loglikDiagFactory_+3A_...">...</code></td>
<td>
<p>Other arguments to be passed on.</p>
</td></tr>
</table>


<h3>Details</h3>


<dl>
<dt>theta_list</dt><dd><p>Named list of vectors with parameters to be passed to covariance.</p>
</dd>
<dt>cov.args_list (default = <code>list()</code>)</dt><dd><p>Named list of vectors with arguments to be passed to covariance</p>
</dd>
<dt>chol.args_list (default = <code>list()</code>)</dt><dd><p>Named list of vectors with arguments to be passed to <code><a href="#topic+choleskyFactory">choleskyFactory</a></code>.</p>
</dd>
</dl>



<h3>Value</h3>

<p>Returns a function of the form <code>function(theta_list, cov.args_list = list(), chol.args_list = list())</code> which returns a <code>data.frame</code> containing the neg2loglikelihood at all permutations of the provided arguments.
</p>


<h3>Note</h3>

<p>The function manufactured by <code>neg2loglikDiagFactory</code> in principle also accepts covariance functions generated using <code><a href="#topic+covarianceFactory">covarianceFactory</a></code>. However, the function is not yet compatible with the arguments <code>fixed_range_value</code> and <code>fixed_nugget_value</code>. For now, these should be left at default when using <code><a href="#topic+covarianceFactory">covarianceFactory</a></code>.
</p>


<h3>Author(s)</h3>

<p>Thomas Caspar Fischer</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(63)
n &lt;- 50
range &lt;- 0.7
theta  &lt;- c(range, 1, 1, 0, 0)

locs &lt;- data.frame(x = runif(n), y = runif(n))
dmat  &lt;- as.matrix(dist(locs))
Sigma &lt;- cov.wendland(h = dmat, theta = theta)
y &lt;- c(spam::rmvnorm(1, Sigma = Sigma))

neg2loglikIterator &lt;- neg2loglikDiagFactory(y = y, distmat = dmat,
  covariance = cov.wendland)
theta_list &lt;- list(range = 0.5, sill = 1, kappa = 0, mu = c(0, 0.25, 0.5),
  nugget = 0)
cov.args_list &lt;- list(numint.abstol = c(1e-1, 1e-3, 1e-6), numint.reltol = c(1e-3))

results &lt;- neg2loglikIterator(theta_list, cov.args_list = cov.args_list)
</code></pre>

<hr>
<h2 id='neg2loglikFactory'>Function Factory for <code>neg2loglikelihood</code> with Unified Input Arguments</h2><span id='topic+neg2loglikFactory'></span>

<h3>Description</h3>

<p>A function factory which generates a function of the form <code>function(parameters)</code> which returns the neg2loglikelihood.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>neg2loglikFactory(y, X, distmat, covariance = NULL, cov.args = list(),
  chol.args = list(), Rstruct = NULL, covarianceFunction = NULL,
  choleskyFunction = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="neg2loglikFactory_+3A_y">y</code></td>
<td>
<p>Numeric vector. Dependent variable.</p>
</td></tr>
<tr><td><code id="neg2loglikFactory_+3A_x">X</code></td>
<td>
<p>Optional data.frame containing covariates.</p>
</td></tr>
<tr><td><code id="neg2loglikFactory_+3A_distmat">distmat</code></td>
<td>
<p>Distance matrix, either a numeric matrix or a spam object.</p>
</td></tr>
<tr><td><code id="neg2loglikFactory_+3A_covariance">covariance</code></td>
<td>
<p>A function which takes as input an object containing distances (h), a vector of parameters (theta), and a list of optional settings (cov.args).</p>
</td></tr>
<tr><td><code id="neg2loglikFactory_+3A_cov.args">cov.args</code></td>
<td>
<p>A list of optional settings for a covariance function.</p>
</td></tr>
<tr><td><code id="neg2loglikFactory_+3A_chol.args">chol.args</code></td>
<td>
<p>A list of optional settings for a cholesky function.</p>
</td></tr>
<tr><td><code id="neg2loglikFactory_+3A_rstruct">Rstruct</code></td>
<td>
<p>A 'spam.chol.NgPeyton' object which represents the sparsity structure.</p>
</td></tr>
<tr><td><code id="neg2loglikFactory_+3A_covariancefunction">covarianceFunction</code></td>
<td>
<p>A function returned by <code>covarianceFactory()</code>.</p>
</td></tr>
<tr><td><code id="neg2loglikFactory_+3A_choleskyfunction">choleskyFunction</code></td>
<td>
<p>A function returned by <code>choleskyFactory()</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function factory returns a function of the form <code>function(parameters)</code> which computes the neg2loglikelihood for given input parameters. The purpose of this is to reduce the number of arguments that need to be specified by the user in a call to <code>optim</code>, or <code>optimParallel</code>. Furthermore, the function detects whether the input distmat is a spam object, and autonomously selects the appropriate method for computing the neg2loglikelihood.
</p>
<p>The function is intended to be called from within <code><a href="#topic+mleFactory">mleFactory</a></code>, but is also exported by NAMESPACE for users wishing to make use of the function. There are two distinct strategies available for using the function.
</p>
<p><b>Option 1</b>: the user may specify covariance, cov.args, chol.args, and Rstruct in the call. This syntax is more in line with the corresponding functions found in the <span class="pkg">spam</span> package, yet still allows passing arguments for customizing the behaviour of the cholesky decomposition.
</p>
<p><b>Option 2</b>: the user may instead specify covarianceFunction and choleskyFunction, obtained from calls to <code>covarianceFactory</code> and <code>choleskyFactory</code>, respectively.
</p>
<p>In both cases, the arguments y, X, and distmat are required input. Note that the two options are equivalent, apart from the second option allowing for more concise code.
</p>


<h3>Value</h3>

<p>Returns function of the form <code>function(parameters)</code>.
</p>


<h3>Author(s)</h3>

<p>Thomas Caspar Fischer</p>


<h3>References</h3>

<p>Hadley Wickham (2015) <em>Advanced R</em>, CRC Press.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+covarianceFactory">covarianceFactory</a></code> and
<code><a href="#topic+choleskyFactory">choleskyFactory</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(63)
n &lt;- 50
range &lt;- 0.7
theta  &lt;- c(range, 1, 1, 0, 0)

locs &lt;- data.frame(x = runif(n), y = runif(n))
dmat  &lt;- as.matrix(dist(locs))
Sigma &lt;- cov.wendland(h = dmat, theta = theta)
y &lt;- c(spam::rmvnorm(1, Sigma = Sigma))
X &lt;- data.frame()

neg2loglikFun &lt;- neg2loglikFactory(y = y, X = X, distmat = dmat,
  covariance = cov.wendland, cov.args = list(), chol.args = list())
result1 &lt;- neg2loglikFun(theta)

covarianceFun &lt;- covarianceFactory(cov.wendland, cov.args = list())
choleskyFun &lt;- choleskyFactory(chol.args = list())
neg2loglikFun &lt;- neg2loglikFactory(y = y, X = X, distmat = dmat,
  covarianceFunction = covarianceFun, choleskyFunction = choleskyFun)
result2 &lt;- neg2loglikFun(theta)
</code></pre>

<hr>
<h2 id='optimFactory'>Function Factory for Optimization function with Unified Arguments</h2><span id='topic+optimFactory'></span>

<h3>Description</h3>

<p>A function factory which returns a function with unified input arguments, and provides compatibility with the package <span class="pkg">optimParallel</span>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>optimFactory(optim.args = list(), hessian = FALSE, optimParallel.args = list())
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="optimFactory_+3A_optim.args">optim.args</code></td>
<td>
<p>A named list of optional settings for optim. See <code><a href="stats.html#topic+optim">optim</a></code> for documentation of valid arguments.</p>
</td></tr>
<tr><td><code id="optimFactory_+3A_hessian">hessian</code></td>
<td>
<p>A logical which specifies whether the hessian matrix is to be returned with the output.</p>
</td></tr>
<tr><td><code id="optimFactory_+3A_optimparallel.args">optimParallel.args</code></td>
<td>
<p>A named list which is passed to <code>optimParallel</code> from the <span class="pkg">optimParallel</span> package. See details.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function factory <code>optimFactory()</code> returns a function of the form <code>function(par, fn, gr = NULL, ..., lower, upper)</code>. It is intended to replace calls to <code>optim</code> or <code>optimParallel</code> by wrapping both functions. By default, it returns a function that corresponds to <code>optim</code> with default arguments.
</p>
<p>To use optimParallel, users may specify the following arguments in optimParallel.args:
</p>

<dl>
<dt>num_cores (default = <code>NULL</code>)</dt><dd><p>The number of cores to use during numerical optimization. Is NULL by default, which corresponds to using <code>stats::optim</code>. When <code>num_cores</code> is a numeric value, the actual number of cores is set to <code>min(detectCores()-1, num_cores)</code> to avoid accidentally overloading the user's system.</p>
</dd>
<dt>forward (default = <code>FALSE</code>)</dt><dd><p>A logical value which controls whether <code>optimParallel</code> should use central difference approximation of the gradient (<code>FALSE</code>) or forward difference approximation (<code>TRUE</code>).</p>
</dd>
<dt>loginfo (default = <code>FALSE</code>)</dt><dd><p>A logical value which controls whether <code>optimParallel</code> should return additional information about the optimization process. See <code>optimParallel</code>.</p>
</dd>
</dl>



<h3>Value</h3>

<p>A function of the form <code>function(par, fn, gr = NULL, ..., lower, upper)</code> which returns the output obtained from calls to <code>optim</code> or <code>optimParallel</code>
</p>


<h3>Author(s)</h3>

<p>Thomas Caspar Fischer</p>


<h3>References</h3>

<p>Hadley Wickham (2015) <em>Advanced R</em>, CRC Press.
Florian Gerber and Reinhard Furrer (2019) optimParallel: An R package providing a parallel version of the L-BFGS-B optimization method, <em>The R Journal</em>, <b>11</b>(1), 352&ndash;358
</p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+optim">optim</a></code> and
<code>optimParallel</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(GeneralizedWendland)
library(optimParallel)

set.seed(43)
n &lt;- 50
range &lt;- 0.4
dist_max &lt;- 2
theta  &lt;- c(range, 1, 1, 0, 0)

locs &lt;- data.frame(x = runif(n, 0, sqrt(dist_max)),
                   y = runif(n, 0, sqrt(dist_max)))
dmat  &lt;- spam::nearest.dist(locs, locs, delta = dist_max)
Sigma &lt;- cov.wendland(h = dmat, theta = theta)
y &lt;- c(spam::rmvnorm(1, Sigma = Sigma))

init_parameters   &lt;- c(0.7, 2, 0, 2, 2)
lower_constraints &lt;- c(0.1, 0.1, 0, 0, 0)
upper_constraints &lt;- c(sqrt(2), 2, 2, 2, 2)

mleFunction &lt;- mleFactory(covariance = cov.wendland)
(mle_result &lt;- mleFunction(y = y, distmat = dmat, init_parameters = init_parameters,
                       theta_llim = lower_constraints, theta_ulim = upper_constraints))

mleFunctionPar &lt;- mleFactory(covariance = cov.wendland, optimParallel.args = list(num_cores = 2))
(mle_result_par &lt;- mleFunctionPar(y = y, distmat = dmat, init_parameters = init_parameters,
                       theta_llim = lower_constraints, theta_ulim = upper_constraints))

</code></pre>

<hr>
<h2 id='Rcpp_Wendland-class'>Class &quot;Rcpp_Wendland&quot;</h2><span id='topic+Rcpp_Wendland-class'></span>

<h3>Description</h3>

<p>Rcpp class which serves as an interface to the C++ implementation of the generalized Wendland covariance function.
</p>


<h3>Details</h3>

<p>Parts of the covariance function require C and C++ dependencies. This Rcpp class serves as an interface to these dependencies.
</p>


<h3>Methods</h3>



<h4>Constructor</h4>


<dl>
<dt>Constructor</dt><dd><p><code>wend &lt;- new("Rcpp_Wendland")</code>: Creates an instance of the Rcpp_Wendland class.</p>
</dd>
</dl>




<h4>Get/Set methods</h4>


<dl>
<dt>setParameters</dt><dd><p><code>wend$setParameters(range, sill, kappa, mu, nugget)</code>: Set Parameters</p>
</dd>
<dt>setEpsTol</dt><dd><p><code>wend$setEpsTol(eps)</code>: set numeric precision.</p>
</dd>
</dl>




<h4>Integration options</h4>


<dl>
<dt>setIntegratorQNG</dt><dd><p><code>wend$setIntegrator(abstol, reltol, intervals=0, qag_key=0)</code></p>
</dd>
</dl>




<h4>Interpolation options</h4>


<dl>
<dt>setInterpolator</dt><dd><p><code>wend$setInterpolatorLinear(num_points, interp_type=0)</code></p>
</dd>
</dl>




<h4>Computation</h4>


<dl>
<dt>compute</dt><dd><p><code>wend$compute(d)</code>: Compute for single value.</p>
</dd>
<dt>computeVector</dt><dd><p><code>wend$computeVector(d)</code>: Compute for numeric vector.</p>
</dd>
<dt>computeMatrix</dt><dd><p><code>wend$computeMatrix(d)</code>: Compute for numeric matrix.</p>
</dd>
<dt>computeMSparse</dt><dd><p><code>wend$computeMSparse(d)</code>: Compute for dgCMatrix from <span class="pkg">Matrix</span>.</p>
</dd>
<dt>computeSpam</dt><dd><p><code>wend$computeSpam(index, values)</code>: Compute for spam object, turned into triplet form using <code>spam::triplet</code>.</p>
</dd>
</dl>




<h3>Author(s)</h3>

<p>Thomas Caspar Fischer</p>


<h3>References</h3>

<p>Dirk Eddelbuettel (2013) Seamless R and C++ Integration with Rcpp. <em>Springer</em>, New York
</p>


<h3>See Also</h3>

<p><code><a href="#topic+cov.wendland">cov.wendland</a></code>
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
