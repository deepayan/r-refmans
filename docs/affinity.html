<!DOCTYPE html><html><head><title>Help for package affinity</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {affinity}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#adjacencies'><p>Adjacency, for use in creating area based meshes</p></a></li>
<li><a href='#affinething'><p>Use affine logic interactively georegister a raster</p></a></li>
<li><a href='#affinity-package'><p>affinity: Raster Georeferencing, Grid Affine Transforms, Cell Abstraction</p></a></li>
<li><a href='#assignproj'><p>Assign projection</p></a></li>
<li><a href='#domath'><p>Calculate the math of an affine transform</p></a></li>
<li><a href='#extent_dim_to_gt'><p>Create geotransform from extent and dimension</p></a></li>
<li><a href='#geo_transform0'><p>Geo transform parameter creator</p></a></li>
<li><a href='#geo_world0'><p>World file parameter creator</p></a></li>
<li><a href='#gt_dim_to_extent'><p>Determine extent from eotransform vector and dimension</p></a></li>
<li><a href='#monterey'><p>Monterey Bay elevation</p></a></li>
<li><a href='#raster_io'><p>GDAL RasterIO parameter creator</p></a></li>
<li><a href='#raster_to_gt'><p>Geotransform from raster object</p></a></li>
<li><a href='#raster_to_rasterio'><p>RasterIO window from raster object</p></a></li>
<li><a href='#raster_to_world'><p>World vector from raster object.</p></a></li>
<li><a href='#rasterio_to_sfio'><p>The sf/stars RasterIO list</p></a></li>
<li><a href='#sfio_to_rasterio'><p>sf package RasterIO from RasterIO window vector</p></a></li>
<li><a href='#world_to_geotransform'><p>Create geotransform from world vector</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Title:</td>
<td>Raster Georeferencing, Grid Affine Transforms, Cell Abstraction</td>
</tr>
<tr>
<td>Version:</td>
<td>0.2.5</td>
</tr>
<tr>
<td>Description:</td>
<td>Tools for raster georeferencing, grid affine transforms, and general raster logic. 
 These functions provide converters between raster specifications, world vector, geotransform, 
 'RasterIO' window, and 'RasterIO window' in 'sf' package list format. There are functions to offset
 a matrix by padding any of four corners (useful for vectorizing neighbourhood operations), and
 helper functions to harvesting user clicks on a graphics device to use for simple georeferencing
 of images.  Methods used are available from <a href="https://en.wikipedia.org/wiki/World_file">https://en.wikipedia.org/wiki/World_file</a> and
 <a href="https://gdal.org/user/raster_data_model.html">https://gdal.org/user/raster_data_model.html</a>. </td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.2.3)</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>LazyDataCompression:</td>
<td>xz</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.1.1</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/hypertidy/affinity">https://github.com/hypertidy/affinity</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/hypertidy/affinity/issues">https://github.com/hypertidy/affinity/issues</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>Imports:</td>
<td>raster, reproj, stats</td>
</tr>
<tr>
<td>Suggests:</td>
<td>rmarkdown, covr, knitr</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2021-06-01 16:38:09 UTC; mdsumner</td>
</tr>
<tr>
<td>Author:</td>
<td>Michael D. Sumner [aut, cre]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Michael D. Sumner &lt;mdsumner@gmail.com&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2021-06-02 07:50:05 UTC</td>
</tr>
</table>
<hr>
<h2 id='adjacencies'>Adjacency, for use in creating area based meshes</h2><span id='topic+adjacencies'></span><span id='topic+bl'></span><span id='topic+tl'></span><span id='topic+br'></span><span id='topic+tr'></span><span id='topic+image0'></span><span id='topic+image1'></span><span id='topic+text0'></span>

<h3>Description</h3>

<p>Functions 'bottom left', 'top left', 'bottom right', and 'top right' named by
their initials, provide very low level relative positional structures for use in
raster logic. These are used to traverse the divide left by area-based rasters which are
inherently a discrete value across a finite element. If we want that element as part of a
continuous surface we need to find local relative values for its corners. Used in
quadmesh and anglr packages, and useful for calculating neighbourhood values.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bl(x)

tl(x)

br(x)

tr(x)

image0(x, ...)

image1(x, ...)

text0(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="adjacencies_+3A_x">x</code></td>
<td>
<p>matrix</p>
</td></tr>
<tr><td><code id="adjacencies_+3A_...">...</code></td>
<td>
<p>arguments passed to image()</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Some tiny functions 'image0', 'image1', 'text0' exist purely to illustrate the ideas in
a vignette.
</p>


<h3>Value</h3>

<p>matrix, padded by one row and one column relative to input
</p>


<h3>Examples</h3>

<pre><code class='language-R'>(m &lt;- matrix(1:12, 3))
tl(m)
tr(m)
bl(m)
br(m)
tl(br(m))
image0(tl(br(m)))
text0(tl(br(m)))
</code></pre>

<hr>
<h2 id='affinething'>Use affine logic interactively georegister a raster</h2><span id='topic+affinething'></span>

<h3>Description</h3>

<p>User clicks are collected in a controlled way for use by <code><a href="#topic+domath">domath()</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>affinething(x, rgb = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="affinething_+3A_x">x</code></td>
<td>
<p>a raster</p>
</td></tr>
<tr><td><code id="affinething_+3A_rgb">rgb</code></td>
<td>
<p>use RGB plot for a raster with 3 layers</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Obtain control points for the simple affine transform (offset and scale) on an ungeoreferenced image.
</p>


<h3>Value</h3>

<p>matrix of x,y coordinates in the space of the current raster extent
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Not run: 
library(raster)
r &lt;- raster("my_unreferenced_raster.png")
xy &lt;- affinething(r)  ## click on two points that you know a location of
my_x &lt;- c(1000, 2000)
my_y &lt;- c(-1000, -500)
prj &lt;- "+proj=laea +lon=147 +lat_0=-42" ## use your own map projection, that correspond to my_x/my_y
pt &lt;- cbind(my_x, my_y)
## now convert those control points to an extent for your raster
ex &lt;- domath(pt, xy, r, prj)

## now we can fix up the data
r &lt;- raster::setExtent(r, ex)
raster::projection(r) &lt;- prj
## hooray!

## End(Not run)

</code></pre>

<hr>
<h2 id='affinity-package'>affinity: Raster Georeferencing, Grid Affine Transforms, Cell Abstraction</h2><span id='topic+affinity'></span><span id='topic+affinity-package'></span>

<h3>Description</h3>

<p>Tools for raster georeferencing, grid affine transforms, and general raster logic. 
These functions provide converters between raster specifications, world vector, geotransform, 
'RasterIO' window, and 'RasterIO window' in 'sf' package list format. There are functions to offset
a matrix by padding any of four corners (useful for vectorizing neighbourhood operations), and
helper functions to harvesting user clicks on a graphics device to use for simple georeferencing
of images.  Methods used are available from &lt;https://en.wikipedia.org/wiki/World_file&gt; and
&lt;https://gdal.org/user/raster_data_model.html&gt;.
</p>


<h3>Author(s)</h3>

<p><strong>Maintainer</strong>: Michael D. Sumner <a href="mailto:mdsumner@gmail.com">mdsumner@gmail.com</a>
</p>


<h3>See Also</h3>

<p>Useful links:
</p>

<ul>
<li> <p><a href="https://github.com/hypertidy/affinity">https://github.com/hypertidy/affinity</a>
</p>
</li>
<li><p> Report bugs at <a href="https://github.com/hypertidy/affinity/issues">https://github.com/hypertidy/affinity/issues</a>
</p>
</li></ul>


<hr>
<h2 id='assignproj'>Assign projection</h2><span id='topic+assignproj'></span>

<h3>Description</h3>

<p>Set the projection of a spatial object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>assignproj(x, proj = "+proj=longlat +datum=WGS84")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="assignproj_+3A_x">x</code></td>
<td>
<p>spatial object for use with <code><a href="raster.html#topic+projection">raster::projection()</a></code></p>
</td></tr>
<tr><td><code id="assignproj_+3A_proj">proj</code></td>
<td>
<p>PROJ.4 string</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a spatial object with the projection set
</p>

<hr>
<h2 id='domath'>Calculate the math of an affine transform</h2><span id='topic+domath'></span>

<h3>Description</h3>

<p>Given relative location and absolute locations, convert to an actual real world extent
for a matrix of data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>domath(pts, xy, r = NULL, proj = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="domath_+3A_pts">pts</code></td>
<td>
<p>known points of 'xy'</p>
</td></tr>
<tr><td><code id="domath_+3A_xy">xy</code></td>
<td>
<p>'xy' obtain from <code>affinething</code></p>
</td></tr>
<tr><td><code id="domath_+3A_r">r</code></td>
<td>
<p>raster in use</p>
</td></tr>
<tr><td><code id="domath_+3A_proj">proj</code></td>
<td>
<p>optional projection, if the pts are longlat and the raster is not</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Convert known geographic points with raw graphic control points and a reference raster
to an extent for the raster in geography.
</p>


<h3>Value</h3>

<p>raster extent
</p>


<h3>See Also</h3>

<p><code><a href="#topic+affinething">affinething()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## not a real example, but the extent we could provide volcano if the second set of points
## described the real world positions of the first set of points within the matrix
domath(cbind(c(147, 148), c(-42, -43)), cbind(c(0.2, 0.3), c(0.1, 0.5)), raster::raster(volcano))
</code></pre>

<hr>
<h2 id='extent_dim_to_gt'>Create geotransform from extent and dimension</h2><span id='topic+extent_dim_to_gt'></span>

<h3>Description</h3>

<p>Create the geotransform (see <code><a href="#topic+geo_transform0">geo_transform0()</a></code>) from extent and dimension.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>extent_dim_to_gt(x, dim)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="extent_dim_to_gt_+3A_x">x</code></td>
<td>
<p>extent parameters, c(xmin,xmax,ymin,ymax)</p>
</td></tr>
<tr><td><code id="extent_dim_to_gt_+3A_dim">dim</code></td>
<td>
<p>dimensions x,y of grid (ncol,nrow)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The dimension is always ncol, nrow.
</p>


<h3>Value</h3>

<p>6-element <code><a href="#topic+geo_transform0">geo_transform0()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>extent_dim_to_gt(c(0, 5, 0, 10), c(5, 10))
</code></pre>

<hr>
<h2 id='geo_transform0'>Geo transform parameter creator</h2><span id='topic+geo_transform0'></span>

<h3>Description</h3>

<p>Basic function to create a geotransform as used by GDAL.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>geo_transform0(px, ul, sh = c(0, 0))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="geo_transform0_+3A_px">px</code></td>
<td>
<p>pixel resolution (XY, Y-negative)</p>
</td></tr>
<tr><td><code id="geo_transform0_+3A_ul">ul</code></td>
<td>
<p>grid offset, top-left corner</p>
</td></tr>
<tr><td><code id="geo_transform0_+3A_sh">sh</code></td>
<td>
<p>affine shear (XY)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>vector of parameters xmin, xres, yskew, ymax, xskew, yres
</p>


<h3>See Also</h3>

<p><code><a href="#topic+geo_world0">geo_world0()</a></code> which uses the same parameters in a different order
</p>


<h3>Examples</h3>

<pre><code class='language-R'>geo_transform0(px = c(1, -1), ul = c(0, 0))
</code></pre>

<hr>
<h2 id='geo_world0'>World file parameter creator</h2><span id='topic+geo_world0'></span><span id='topic+geotransform_to_world'></span>

<h3>Description</h3>

<p>Basic function to create a <a href="https://en.wikipedia.org/wiki/World_file">'world file'</a>
as used by various non-geo image formats
</p>
<p>Reformat to world vector.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>geo_world0(px, ul, sh = c(0, 0))

geotransform_to_world(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="geo_world0_+3A_px">px</code></td>
<td>
<p>pixel resolution (XY, Y-negative)</p>
</td></tr>
<tr><td><code id="geo_world0_+3A_ul">ul</code></td>
<td>
<p>grid offset, top-left corner</p>
</td></tr>
<tr><td><code id="geo_world0_+3A_sh">sh</code></td>
<td>
<p>affine shear (XY)</p>
</td></tr>
<tr><td><code id="geo_world0_+3A_x">x</code></td>
<td>
<p>geotransform parameters, as per <code><a href="#topic+geo_transform0">geo_transform0()</a></code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>Note that xmin/xmax are <em>centre_of_cell</em> (of top-left cell) unlike the geotransform which is
top-left <em>corner_of_cell</em>. The parameters are otherwise the same, but in a different order.
</p>


<h3>Value</h3>

<p>vector of parameters xres, yskew, xskew, yres, xmin, ymax
</p>
<p>world vector, as per <code><a href="#topic+geo_world0">geo_world0()</a></code>
</p>


<h3>See Also</h3>

<p><a href="#topic+geo_transform0">geo_transform0</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>geo_world0(px = c(1, -1), ul = c(0, 0))
(gt &lt;- geo_transform0(px = c(1, -1), ul = c(0, 0)))
wf &lt;- geotransform_to_world(gt)
world_to_geotransform(wf)
</code></pre>

<hr>
<h2 id='gt_dim_to_extent'>Determine extent from eotransform vector and dimension</h2><span id='topic+gt_dim_to_extent'></span>

<h3>Description</h3>

<p>Create the extent (xlim, ylim) from the geotransform and dimensions
of the grid.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gt_dim_to_extent(x, dim)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gt_dim_to_extent_+3A_x">x</code></td>
<td>
<p>geotransform parameters, as per <code><a href="#topic+geo_transform0">geo_transform0()</a></code></p>
</td></tr>
<tr><td><code id="gt_dim_to_extent_+3A_dim">dim</code></td>
<td>
<p>dimensions x,y of grid (ncol,nrow)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The extent is <code>c(xmin, xmax, ymin, ymax)</code>.
</p>


<h3>Value</h3>

<p>4-element extent c(xmin,xmax,ymin,ymax)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>gt_dim_to_extent(geo_transform0(c(1, -1), c(0, 10)), c(5, 10))
</code></pre>

<hr>
<h2 id='monterey'>Monterey Bay elevation</h2><span id='topic+monterey'></span>

<h3>Description</h3>

<p>Extent is in the examples, stolen from rayshader.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>monterey
</code></pre>


<h3>Format</h3>

<p>An object of class <code>matrix</code> (inherits from <code>array</code>) with 270 rows and 270 columns.
</p>


<h3>Details</h3>

<p>A matrix 540x540 of topography. Used in <code><a href="#topic+affinething">affinething()</a></code> examples.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>ex &lt;- c(-122.366765, -121.366765, 36.179392, 37.179392)
</code></pre>

<hr>
<h2 id='raster_io'>GDAL RasterIO parameter creator</h2><span id='topic+raster_io'></span><span id='topic+raster_io0'></span>

<h3>Description</h3>

<p>Basic function to create the window paramers as used by GDAL RasterIO.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>raster_io0(
  src_offset,
  src_dim,
  out_dim = src_dim,
  resample = "NearestNeighbour"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="raster_io_+3A_src_offset">src_offset</code></td>
<td>
<p>index offset (0-based, top left)</p>
</td></tr>
<tr><td><code id="raster_io_+3A_src_dim">src_dim</code></td>
<td>
<p>source dimension (XY)</p>
</td></tr>
<tr><td><code id="raster_io_+3A_out_dim">out_dim</code></td>
<td>
<p>output dimension (XY, optional src_dim will be used if not set)</p>
</td></tr>
<tr><td><code id="raster_io_+3A_resample">resample</code></td>
<td>
<p>resampling algorith for GDAL see details</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Resampling algorithm is one of 'NearestNeighbour' (default), 'Average', 'Bilinear', 'Cubic', 'CubicSpline', 'Gauss', 'Lanczos', 'Mode', but
more may be available given the version of GDAL in use.
</p>


<h3>Value</h3>

<p>numeric vector of values specifying offset, source dimension, output dimension
</p>


<h3>Examples</h3>

<pre><code class='language-R'>raster_io0(c(0L, 0L), src_dim = c(24L, 10L))
</code></pre>

<hr>
<h2 id='raster_to_gt'>Geotransform from raster object</h2><span id='topic+raster_to_gt'></span>

<h3>Description</h3>

<p>Return the geotransform defining the raster's offset and resolution.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>raster_to_gt(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="raster_to_gt_+3A_x">x</code></td>
<td>
<p>raster object (the raster package, extends BasicRaster)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The geotransform vector is six coefficients xmin, xres, yskew, ymax, xskew, yres, values
relative to the top left corner of the top left pixel. &quot;yres&quot; the y-spacing is
traditionally negative.
</p>


<h3>Value</h3>

<p>a geotransform vector
</p>


<h3>Examples</h3>

<pre><code class='language-R'>raster_to_gt(raster::raster(volcano))
</code></pre>

<hr>
<h2 id='raster_to_rasterio'>RasterIO window from raster object</h2><span id='topic+raster_to_rasterio'></span><span id='topic+raster_to_sfio'></span>

<h3>Description</h3>

<p>Return the RasterIO window vector defining the raster's offset and resolution and dimensions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>raster_to_rasterio(x)

raster_to_sfio(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="raster_to_rasterio_+3A_x">x</code></td>
<td>
<p>a raster object (BasicRaster, from raster package)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The RasterIO window is a six element vector of offset (x,y),  dimension of source (nx0, ny0) and
dimension of output (nx, ny).
</p>
<p>The sf RasterIO is the RasterIO window in a list format used by the sf package, it contains the same
information, and is created by <code><a href="#topic+raster_to_sfio">raster_to_sfio()</a></code>.
</p>


<h3>Value</h3>

<p>RasterIO window vector 'c(x0, y0, nx0, ny0, nx, y)' see Details
</p>


<h3>Examples</h3>

<pre><code class='language-R'>raster_to_rasterio(raster::raster(volcano))
</code></pre>

<hr>
<h2 id='raster_to_world'>World vector from raster object.</h2><span id='topic+raster_to_world'></span>

<h3>Description</h3>

<p>Return the world transform defining the raster's offset and resolution.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>raster_to_world(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="raster_to_world_+3A_x">x</code></td>
<td>
<p>raster object (the raster package, extends BasicRaster)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The world vector is the values xres, yres, xmin, ymax relative to the
centre of the top left pixel. &quot;yres&quot; the y-spacing is traditionally negative.
</p>


<h3>Value</h3>

<p>a geotransform vector
</p>


<h3>Examples</h3>

<pre><code class='language-R'>raster_to_world(raster::raster(volcano))
</code></pre>

<hr>
<h2 id='rasterio_to_sfio'>The sf/stars RasterIO list</h2><span id='topic+rasterio_to_sfio'></span>

<h3>Description</h3>

<p>We create the list as used by the stars/sf GDAL IO function 'gdal_read(, RasterIO_parameters)'.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rasterio_to_sfio(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rasterio_to_sfio_+3A_x">x</code></td>
<td>
<p>rasterio params as from <code><a href="#topic+raster_io0">raster_io0()</a></code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>Note that the input is a 4 or 6 element vector, with offset 0-based and
output dimensions optional (will use the source window). The resample argument uses the syntax
identical to that used in GDAL itself.
</p>


<h3>Value</h3>

<p>list in sf RasterIO format
</p>


<h3>Examples</h3>

<pre><code class='language-R'>rio &lt;- raster_io0(c(0L, 0L), src_dim = c(24L, 10L))
rasterio_to_sfio(rio)
</code></pre>

<hr>
<h2 id='sfio_to_rasterio'>sf package RasterIO from RasterIO window vector</h2><span id='topic+sfio_to_rasterio'></span>

<h3>Description</h3>

<p>Basic function to create the window parameters as used by GDAL RasterIO, in
format used by sf, in 'gdal_read(,RasterIO_parameters)'.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sfio_to_rasterio(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sfio_to_rasterio_+3A_x">x</code></td>
<td>
<p>a RasterIO parameter list</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a sf-RasterIO parameter list
</p>


<h3>Examples</h3>

<pre><code class='language-R'>sfio_to_rasterio(rasterio_to_sfio(raster_io0(c(0L, 0L), src_dim = c(24L, 10L))))
</code></pre>

<hr>
<h2 id='world_to_geotransform'>Create geotransform from world vector</h2><span id='topic+world_to_geotransform'></span>

<h3>Description</h3>

<p>Convert world vector (centre offset) and x,y spacing to
geotransform format.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>world_to_geotransform(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="world_to_geotransform_+3A_x">x</code></td>
<td>
<p>worldfile parameters, as per <code><a href="#topic+geo_world0">geo_world0()</a></code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>geotransform vector, see <code><a href="#topic+geo_transform0">geo_transform0()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>(wf &lt;- geo_world0(px = c(1, -1), ul = c(0, 0)))
gt &lt;- world_to_geotransform(wf)
geotransform_to_world(gt)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
