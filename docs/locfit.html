<!DOCTYPE html><html><head><title>Help for package locfit</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {locfit}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#aic'>
<p>Compute Akaike's Information Criterion.</p></a></li>
<li><a href='#aicplot'>
<p>Compute an AIC plot.</p></a></li>
<li><a href='#ais'><p>Australian Institute of Sport Dataset</p></a></li>
<li><a href='#ang'>
<p>Angular Term for a Locfit model.</p></a></li>
<li><a href='#bad'><p>Example dataset for bandwidth selection</p></a></li>
<li><a href='#border'><p>Cricket Batting Dataset</p></a></li>
<li><a href='#chemdiab'><p>Chemical Diabetes Dataset</p></a></li>
<li><a href='#claw54'><p>Claw Dataset</p></a></li>
<li><a href='#cldem'><p>Example data set for classification</p></a></li>
<li><a href='#cltest'><p>Test dataset for classification</p></a></li>
<li><a href='#cltrain'><p>Training dataset for classification</p></a></li>
<li><a href='#co2'><p>Carbon Dioxide Dataset</p></a></li>
<li><a href='#cp'>
<p>Compute Mallows' Cp for local regression models.</p></a></li>
<li><a href='#cpar'>
<p>Conditionally parametric term for a Locfit model.</p></a></li>
<li><a href='#cpplot'>
<p>Compute a Cp plot.</p></a></li>
<li><a href='#crit'>
<p>Compute critical values for confidence intervals.</p></a></li>
<li><a href='#dat'>
<p>Locfit - data evaluation structure.</p></a></li>
<li><a href='#density.lf'>
<p>Density estimation using Locfit</p></a></li>
<li><a href='#diab'><p>Exhaust emissions</p></a></li>
<li><a href='#ethanol'><p>Exhaust emissions</p></a></li>
<li><a href='#expit'>
<p>Inverse logistic link function</p></a></li>
<li><a href='#fitted.locfit'>
<p>Fitted values for a &lsquo;&quot;locfit&quot;&rsquo; object.</p></a></li>
<li><a href='#formula.locfit'>
<p>Formula from a Locfit object.</p></a></li>
<li><a href='#gam.lf'>
<p>Locfit call for Generalized Additive Models</p></a></li>
<li><a href='#gam.slist'><p>Vector of GAM special terms</p></a></li>
<li><a href='#gcv'>
<p>Compute generalized cross-validation statistic.</p></a></li>
<li><a href='#gcvplot'>
<p>Compute a generalized cross-validation plot.</p></a></li>
<li><a href='#geyser'><p>Old Faithful Geyser Dataset</p></a></li>
<li><a href='#geyser.round'><p>Discrete Old Faithful Geyser Dataset</p></a></li>
<li><a href='#hatmatrix'>
<p>Weight diagrams and the hat matrix for a local regression model.</p></a></li>
<li><a href='#heart'><p>Survival Times of Heart Transplant Recipients</p></a></li>
<li><a href='#insect'><p>Insect Dataset</p></a></li>
<li><a href='#iris'><p>Fisher's Iris Data (subset)</p></a></li>
<li><a href='#kangaroo'><p>Kangaroo skull measurements dataset</p></a></li>
<li><a href='#kappa0'>
<p>Critical Values for Simultaneous Confidence Bands.</p></a></li>
<li><a href='#kdeb'>
<p>Bandwidth selectors for kernel density estimation.</p></a></li>
<li><a href='#km.mrl'>
<p>Mean Residual Life using Kaplan-Meier estimate</p></a></li>
<li><a href='#lcv'><p>Compute Likelihood Cross Validation Statistic.</p></a></li>
<li><a href='#lcvplot'>
<p>Compute the likelihood cross-validation plot.</p></a></li>
<li><a href='#left'>
<p>One-sided left smooth for a Locfit model.</p></a></li>
<li><a href='#lf'>
<p>Locfit term in Additive Model formula</p></a></li>
<li><a href='#lfeval'>
<p>Extract Locfit Evaluation Structure.</p></a></li>
<li><a href='#lfgrid'>
<p>Locfit - grid evaluation structure.</p></a></li>
<li><a href='#lfknots'>
<p>Extraction of fit-point information from a Locfit object.</p></a></li>
<li><a href='#lflim'>
<p>Construct Limit Vectors for Locfit fits.</p></a></li>
<li><a href='#lfmarg'>
<p>Generate grid margins.</p></a></li>
<li><a href='#lines.locfit'>
<p>Add locfit line to existing plot</p></a></li>
<li><a href='#livmet'><p>liver Metastases dataset</p></a></li>
<li><a href='#locfit'>
<p>Local Regression, Likelihood and Density Estimation.</p></a></li>
<li><a href='#locfit.censor'>
<p>Censored Local Regression</p></a></li>
<li><a href='#locfit.matrix'>
<p>Reconstruct a Locfit model matrix.</p></a></li>
<li><a href='#locfit.quasi'>
<p>Local Quasi-Likelihood with global reweighting.</p></a></li>
<li><a href='#locfit.raw'>
<p>Local Regression, Likelihood and Density Estimation.</p></a></li>
<li><a href='#locfit.robust'>
<p>Robust Local Regression</p></a></li>
<li><a href='#lp'>
<p>Local Polynomial Model Term</p></a></li>
<li><a href='#lscv'>
<p>Least Squares Cross Validation Statistic.</p></a></li>
<li><a href='#lscv.exact'>
<p>Exact LSCV Calculation</p></a></li>
<li><a href='#lscvplot'>
<p>Compute the LSCV plot.</p></a></li>
<li><a href='#mcyc'><p>Acc(De?)celeration of a Motorcycle Hitting a Wall</p></a></li>
<li><a href='#mine'><p>Fracture Counts in Coal Mines</p></a></li>
<li><a href='#mmsamp'><p>Test dataset for minimax Local Regression</p></a></li>
<li><a href='#morths'><p>Henderson and Sheppard Mortality Dataset</p></a></li>
<li><a href='#none'>
<p>Locfit Evaluation Structure</p></a></li>
<li><a href='#panel.locfit'>
<p>Locfit panel function</p></a></li>
<li><a href='#panel.xyplot.lf'>
<p>Locfit panel function</p></a></li>
<li><a href='#penny'><p>Penny Thickness Dataset</p></a></li>
<li><a href='#plot.eval'>
<p>Plot evaluation points from a 2-d locfit object.</p></a></li>
<li><a href='#plot.gcvplot'>
<p>Produce a cross-validation plot.</p></a></li>
<li><a href='#plot.lfeval'>
<p>Plot a Locfit Evaluation Structure.</p></a></li>
<li><a href='#plot.locfit'>
<p>Plot an object of class locfit.</p></a></li>
<li><a href='#plot.locfit.1d'>
<p>Plot a one dimensional preplot.locfit object.</p></a></li>
<li><a href='#plot.locfit.2d'>
<p>Plot a two-dimensional &quot;preplot.locfit&quot; object.</p></a></li>
<li><a href='#plot.locfit.3d'>
<p>Plot a high-dimensional &quot;preplot.locfit&quot; object using trellis displays.</p></a></li>
<li><a href='#plot.preplot.locfit'>
<p>Plot a &quot;preplot.locfit&quot; object.</p></a></li>
<li><a href='#plot.scb'>
<p>Plot method for simultaneous confidence bands</p></a></li>
<li><a href='#plotbyfactor'>
<p>x-y scatterplot, colored by levels of a factor.</p></a></li>
<li><a href='#points.locfit'>
<p>Add &lsquo;locfit&rsquo; points to existing plot</p></a></li>
<li><a href='#predict.locfit'>
<p>Prediction from a Locfit object.</p></a></li>
<li><a href='#preplot.locfit'>
<p>Prediction from a Locfit object.</p></a></li>
<li><a href='#preplot.locfit.raw'>
<p>Prediction from a Locfit object.</p></a></li>
<li><a href='#print.gcvplot'>
<p>Print method for gcvplot objects</p></a></li>
<li><a href='#print.lfeval'>
<p>Print the Locfit Evaluation Points.</p></a></li>
<li><a href='#print.locfit'>
<p>Print method for &quot;locfit&quot; object.</p></a></li>
<li><a href='#print.preplot.locfit'>
<p>Print method for preplot.locfit objects.</p></a></li>
<li><a href='#print.scb'>
<p>Print method for simultaneous confidence bands</p></a></li>
<li><a href='#print.summary.locfit'>
<p>Print a Locfit summary object.</p></a></li>
<li><a href='#rbox'>
<p>Local Regression, Likelihood and Density Estimation.</p></a></li>
<li><a href='#regband'>
<p>Bandwidth selectors for local regression.</p></a></li>
<li><a href='#residuals.locfit'>
<p>Fitted values and residuals for a Locfit object.</p></a></li>
<li><a href='#right'>
<p>One-sided right smooth for a Locfit model.</p></a></li>
<li><a href='#rv'>
<p>Residual variance from a locfit object.</p></a></li>
<li><a href='#rva'>
<p>Substitute variance estimate on a locfit object.</p></a></li>
<li><a href='#scb'>
<p>Simultaneous Confidence Bands</p></a></li>
<li><a href='#sjpi'>
<p>Sheather-Jones Plug-in bandwidth criterion.</p></a></li>
<li><a href='#smooth.lf'>
<p>Local Regression, Likelihood and Density Estimation.</p></a></li>
<li><a href='#spence.15'>
<p>Spencer's 15 point graduation rule.</p></a></li>
<li><a href='#spence.21'>
<p>Spencer's 21 point graduation rule.</p></a></li>
<li><a href='#spencer'><p>Spencer's Mortality Dataset</p></a></li>
<li><a href='#stamp'><p>Stamp Thickness Dataset</p></a></li>
<li><a href='#store'>
<p>Save S functions.</p></a></li>
<li><a href='#summary.gcvplot'>
<p>Summary method for a gcvplot structure.</p></a></li>
<li><a href='#summary.locfit'>
<p>Print method for a locfit object.</p></a></li>
<li><a href='#summary.preplot.locfit'>
<p>Summary method for a preplot.locfit object.</p></a></li>
<li><a href='#trimod'><p>Generated sample from a bivariate trimodal normal mixture</p></a></li>
<li><a href='#xbar'>
<p>Locfit Evaluation Structure</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Version:</td>
<td>1.5-9.10</td>
</tr>
<tr>
<td>Title:</td>
<td>Local Regression, Likelihood and Density Estimation</td>
</tr>
<tr>
<td>Date:</td>
<td>2024-06-24</td>
</tr>
<tr>
<td>Author:</td>
<td>Catherine Loader [aut],
  Jiayang Sun [ctb],
  Lucent Technologies [cph],
  Andy Liaw [cre]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Andy Liaw &lt;andy_liaw@merck.com&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Local regression, likelihood and density estimation methods as described in the 1999 book by Loader.</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 4.1.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>lattice</td>
</tr>
<tr>
<td>Suggests:</td>
<td>interp, gam</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>SystemRequirements:</td>
<td>USE_C17</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-06-24 10:28:43 UTC; ripley</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-06-24 11:38:20 UTC</td>
</tr>
</table>
<hr>
<h2 id='aic'>
Compute Akaike's Information Criterion.
</h2><span id='topic+aic'></span>

<h3>Description</h3>

<p>The calling sequence for <code>aic</code> matches those for the
<code><a href="#topic+locfit">locfit</a></code> or <code><a href="#topic+locfit.raw">locfit.raw</a></code> functions.
The fit is not returned; instead, the returned object contains
Akaike's information criterion for the fit.
</p>
<p>The definition of AIC used here is -2*log-likelihood + pen*(fitted d.f.).
For quasi-likelihood, and local regression, this assumes the scale
parameter is one. Other scale parameters can effectively be used
by changing the penalty.
</p>
<p>The AIC score is exact (up to numerical roundoff) if the
<code>ev="data"</code> argument is provided. Otherwise, the residual
sum-of-squares and degrees of freedom are computed using locfit's
standard interpolation based approximations.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>aic(x, ..., pen=2)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="aic_+3A_x">x</code></td>
<td>
<p>model formula</p>
</td></tr>
<tr><td><code id="aic_+3A_...">...</code></td>
<td>
<p>other arguments to locfit</p>
</td></tr>
<tr><td><code id="aic_+3A_pen">pen</code></td>
<td>
<p>penalty for the degrees of freedom term</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+locfit">locfit</a></code>,
<code><a href="#topic+locfit.raw">locfit.raw</a></code>,
<code><a href="#topic+aicplot">aicplot</a></code>
</p>

<hr>
<h2 id='aicplot'>
Compute an AIC plot.
</h2><span id='topic+aicplot'></span>

<h3>Description</h3>

<p>The <code>aicplot</code> function loops through calls to the <code><a href="#topic+aic">aic</a></code>
function (and hence to <code><a href="#topic+locfit">locfit</a></code>), using a different
smoothing parameter for each call.
The returned structure contains the AIC statistic for each fit, and can
be used to produce an AIC plot.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>aicplot(..., alpha)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="aicplot_+3A_...">...</code></td>
<td>
<p> arguments to the <code><a href="#topic+aic">aic</a></code>, <code><a href="#topic+locfit">locfit</a></code>
functions.</p>
</td></tr>
<tr><td><code id="aicplot_+3A_alpha">alpha</code></td>
<td>
<p> Matrix of smoothing parameters. The <code>aicplot</code> function
loops through calls to <code><a href="#topic+aic">aic</a></code>, using each row of
<code>alpha</code> as the smoothing parameter in turn. If <code>alpha</code>
is provided as a vector, it will be converted to a one-column
matrix, thus interpreting each component as a nearest neighbor
smoothing parameter.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object with class <code>"gcvplot"</code>, containing the smoothing
parameters and AIC scores. The actual plot is produced using
<code><a href="#topic+plot.gcvplot">plot.gcvplot</a></code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+locfit">locfit</a></code>,
<code><a href="#topic+locfit.raw">locfit.raw</a></code>,
<code><a href="#topic+gcv">gcv</a></code>,
<code><a href="#topic+aic">aic</a></code>,
<code><a href="#topic+plot.gcvplot">plot.gcvplot</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(morths)
plot(aicplot(deaths~age,weights=n,data=morths,family="binomial",
  alpha=seq(0.2,1.0,by=0.05)))
</code></pre>

<hr>
<h2 id='ais'>Australian Institute of Sport Dataset</h2><span id='topic+ais'></span>

<h3>Description</h3>

<p>The first two columns are the gender of the athlete
and their sport. The remaining 11 columns are various measurements
made on the athletes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(ais)</code></pre>


<h3>Format</h3>

<p>A dataframe.
</p>


<h3>Source</h3>

<p>Cook and Weisberg (1994).
</p>


<h3>References</h3>

<p>Cook and Weisberg (1994). An Introduction to Regression Graphics.
Wiley, New York.
</p>

<hr>
<h2 id='ang'>
Angular Term for a Locfit model.
</h2><span id='topic+ang'></span>

<h3>Description</h3>

<p>The <code>ang()</code> function is used in a locfit model formula
to specify that a variable should be treated as an angular
or periodic term. The <code>scale</code> argument is used to
set the period.
</p>
<p><code>ang(x)</code> is equivalent to <code>lp(x,style="ang")</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ang(x,...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ang_+3A_x">x</code></td>
<td>
<p>numeric variable to be treated periodically.</p>
</td></tr>
<tr><td><code id="ang_+3A_...">...</code></td>
<td>
<p>Other arguments to <code><a href="#topic+lp">lp</a></code>.</p>
</td></tr>
</table>


<h3>References</h3>

<p>Loader, C. (1999). Local Regression and Likelihood. Springer, NY (Section 6.2).
</p>


<h3>See Also</h3>

<p><code><a href="#topic+locfit">locfit</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># generate an x variable, and a response with period 0.2
x &lt;- seq(0,1,length=200)
y &lt;- sin(10*pi*x)+rnorm(200)/5

# compute the periodic local fit. Note the scale argument is period/(2pi)
fit &lt;- locfit(y~ang(x,scale=0.2/(2*pi)))

# plot the fit over a single period
plot(fit)

# plot the fit over the full range of the data
plot(fit,xlim=c(0,1))
</code></pre>

<hr>
<h2 id='bad'>Example dataset for bandwidth selection</h2><span id='topic+bad'></span>

<h3>Description</h3>

<p>Example dataset from Loader (1999).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(bad)</code></pre>


<h3>Format</h3>

<p>Data Frame with x and y variables.
</p>


<h3>References</h3>

<p>Loader, C. (1999). Bandwidth Selection: Classical or Plug-in?
Annals of Statistics 27.
</p>

<hr>
<h2 id='border'>Cricket Batting Dataset</h2><span id='topic+border'></span>

<h3>Description</h3>

<p>Scores in 265 innings for Australian batsman Allan Border.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(border)</code></pre>


<h3>Format</h3>

<p>A dataframe with day (decimalized); not out indicator and score.
The not out indicator should be used as a censoring variable.
</p>


<h3>Source</h3>

<p>Compiled from the Cricinfo archives.
</p>


<h3>References</h3>

<p>CricInfo: The Home of Cricket on the Internet.
<a href="https://www.espncricinfo.com/">https://www.espncricinfo.com/</a>
</p>

<hr>
<h2 id='chemdiab'>Chemical Diabetes Dataset</h2><span id='topic+chemdiab'></span>

<h3>Description</h3>

<p>Numeric variables are <code>rw</code>, <code>fpg</code>,
<code>ga</code>, <code>ina</code> and <code>sspg</code>. Classifier <code>cc</code> is the Diabetic
type.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(chemdiab)</code></pre>


<h3>Format</h3>

<p>Data frame with five numeric measurements and categroical response.
</p>


<h3>Source</h3>

<p>Reaven and Miller (1979).
</p>


<h3>References</h3>

<p>Reaven, G. M. and Miller, R. G. (1979).
An attempt to define the nature of chemical diabetes using a multidimensional
analysis. Diabetologia 16, 17-24.
</p>

<hr>
<h2 id='claw54'>Claw Dataset</h2><span id='topic+claw54'></span>

<h3>Description</h3>

<p>A random sample of size 54 from the claw density of Marron and Wand
(1992), as used in Figure 10.5 of Loader (1999).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(claw54)</code></pre>


<h3>Format</h3>

<p>Numeric vector with length 54.
</p>


<h3>Source</h3>

<p>Randomly generated.
</p>


<h3>References</h3>

<p>Loader, C. (1999). Local Regression and Likelihood. Springer, New York.
</p>
<p>Marron, J. S. and Wand, M. P. (1992). Exact mean integrated squared error.
Annals of Statistics 20, 712-736.
</p>

<hr>
<h2 id='cldem'>Example data set for classification</h2><span id='topic+cldem'></span>

<h3>Description</h3>

<p>Observations from Figure 8.7 of Loader (1999).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(cldem)</code></pre>


<h3>Format</h3>

<p>Data Frame with x and y variables.
</p>


<h3>References</h3>

<p>Loader, C. (1999). Local Regression and Likelihood. Springer, New York.
</p>

<hr>
<h2 id='cltest'>Test dataset for classification</h2><span id='topic+cltest'></span>

<h3>Description</h3>

<p>200 observations from a 2 population model. Under population 0,
<code class="reqn">x_{1,i}</code> has a standard normal distribution, and
<code class="reqn">x_{2,i} = (2-x_{1,i}^2+z_i)/3</code>, where <code class="reqn">z_i</code> is also standard normal.
Under population 1, <code class="reqn">x_{2,i} = -(2-x_{1,i}^2+z_i)/3</code>.
The optimal classification regions form a checkerboard pattern,
with horizontal boundary at <code class="reqn">x_2=0</code>, vertical boundaries at
<code class="reqn">x_1 = \pm \sqrt{2}</code>.
</p>
<p>This is the same model as the cltrain dataset.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(cltest)</code></pre>


<h3>Format</h3>

<p>Data Frame. Three variables x1, x2 and y. The latter indicates
class membership.
</p>

<hr>
<h2 id='cltrain'>Training dataset for classification</h2><span id='topic+cltrain'></span>

<h3>Description</h3>

<p>200 observations from a 2 population model. Under population 0,
<code class="reqn">x_{1,i}</code> has a standard normal distribution, and
<code class="reqn">x_{2,i} = (2-x_{1,i}^2+z_i)/3</code>, where <code class="reqn">z_i</code> is also standard normal.
Under population 1, <code class="reqn">x_{2,i} = -(2-x_{1,i}^2+z_i)/3</code>.
The optimal classification regions form a checkerboard pattern,
with horizontal boundary at <code class="reqn">x_2=0</code>, vertical boundaries at
<code class="reqn">x_1 = \pm \sqrt{2}</code>.
</p>
<p>This is the same model as the cltest dataset.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(cltrain)</code></pre>


<h3>Format</h3>

<p>Data Frame. Three variables x1, x2 and y. The latter indicates
class membership.
</p>

<hr>
<h2 id='co2'>Carbon Dioxide Dataset</h2><span id='topic+co2'></span>

<h3>Description</h3>

<p>Monthly time series of carbon dioxide measurements at Mauna Loa,
Hawaii from 1959 to 1990.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(co2)</code></pre>


<h3>Format</h3>

<p>Data frame with <code>year</code>, <code>month</code> and <code>co2</code> variables.
</p>


<h3>Source</h3>

<p>Boden, Sepanski and Stoss (1992).
</p>


<h3>References</h3>

<p>Boden, Sepanski and Stoss (1992).
Trends '91: A compedium of data on global change - Highlights.
Carbon Dioxide Information Analysis Center, Oak Ridge National Laboratory.
</p>

<hr>
<h2 id='cp'>
Compute Mallows' Cp for local regression models.
</h2><span id='topic+cp'></span>

<h3>Description</h3>

<p>The calling sequence for <code>cp</code> matches those for the
<code><a href="#topic+locfit">locfit</a></code> or <code><a href="#topic+locfit.raw">locfit.raw</a></code> functions.
The fit is not returned; instead, the returned object contains
Cp criterion for the fit.
</p>
<p>Cp is usually computed using a variance estimate from the largest
model under consideration, rather than
<code class="reqn">\sigma^2=1</code>. This will be done
automatically when the <code><a href="#topic+cpplot">cpplot</a></code> function is used.
</p>
<p>The Cp score is exact (up to numerical roundoff) if the
<code>ev="data"</code> argument is provided. Otherwise, the residual
sum-of-squares and degrees of freedom are computed using locfit's
standard interpolation based approximations.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cp(x, ..., sig2=1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cp_+3A_x">x</code></td>
<td>
<p>model formula or numeric vector of the independent variable.</p>
</td></tr>
<tr><td><code id="cp_+3A_...">...</code></td>
<td>
<p>other arguments to <code><a href="#topic+locfit">locfit</a></code> and/or
<code><a href="#topic+locfit.raw">locfit.raw</a></code>.</p>
</td></tr>
<tr><td><code id="cp_+3A_sig2">sig2</code></td>
<td>
<p>residual variance estimate.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+locfit">locfit</a></code>,
<code><a href="#topic+locfit.raw">locfit.raw</a></code>,
<code><a href="#topic+cpplot">cpplot</a></code>
</p>

<hr>
<h2 id='cpar'>
Conditionally parametric term for a Locfit model.
</h2><span id='topic+cpar'></span>

<h3>Description</h3>

<p>A term entered in a <code><a href="#topic+locfit">locfit</a></code> model formula using
<code>cpar</code> will result in a fit that is conditionally parametric.
Equivalent to <code>lp(x,style="cpar")</code>.
</p>
<p>This function is presently almost deprecated. Specifying a conditionally
parametric fit as <code>y~x1+cpar(x2)</code> wil no longer work; instead, the
model is specified as <code>y~lp(x1,x2,style=c("n","cpar"))</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cpar(x,...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cpar_+3A_x">x</code></td>
<td>
<p>numeric variable.</p>
</td></tr>
<tr><td><code id="cpar_+3A_...">...</code></td>
<td>
<p>Other arguments to <code>link{lp}()</code>.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+locfit">locfit</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(ethanol, package="locfit")
# fit a conditionally parametric model
fit &lt;- locfit(NOx ~ lp(E, C, style=c("n","cpar")), data=ethanol)
plot(fit)
# one way to force a parametric fit with locfit
fit &lt;- locfit(NOx ~ cpar(E), data=ethanol)
</code></pre>

<hr>
<h2 id='cpplot'>
Compute a Cp plot.
</h2><span id='topic+cpplot'></span>

<h3>Description</h3>

<p>The <code>cpplot</code> function loops through calls to the <code><a href="#topic+cp">cp</a></code>
function (and hence to <code>link{locfit}</code>), using a different
smoothing parameter for each call.
The returned structure contains the Cp statistic for each fit, and can
be used to produce an AIC plot.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cpplot(..., alpha, sig2)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cpplot_+3A_...">...</code></td>
<td>
<p> arguments to the <code><a href="#topic+cp">cp</a></code>, <code><a href="#topic+locfit">locfit</a></code>
functions.</p>
</td></tr>
<tr><td><code id="cpplot_+3A_alpha">alpha</code></td>
<td>
<p> Matrix of smoothing parameters. The <code>cpplot</code> function
loops through calls to <code><a href="#topic+cp">cp</a></code>, using each row of
<code>alpha</code> as the smoothing parameter in turn. If <code>alpha</code>
is provided as a vector, it will be converted to a one-column
matrix, thus interpreting each component as a nearest neighbor
smoothing parameter.</p>
</td></tr>
<tr><td><code id="cpplot_+3A_sig2">sig2</code></td>
<td>
<p> Residual variance. If not specified, the residual variance
is computed using the fitted model with the fewest residual degrees
of freedom.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object with class <code>"gcvplot"</code>, containing the smoothing
parameters and CP scores. The actual plot is produced using
<code><a href="#topic+plot.gcvplot">plot.gcvplot</a></code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+locfit">locfit</a></code>,
<code><a href="#topic+locfit.raw">locfit.raw</a></code>,
<code><a href="#topic+gcv">gcv</a></code>,
<code><a href="#topic+aic">aic</a></code>,
<code><a href="#topic+plot.gcvplot">plot.gcvplot</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(ethanol)
plot(cpplot(NOx~E,data=ethanol,alpha=seq(0.2,1.0,by=0.05)))
</code></pre>

<hr>
<h2 id='crit'>
Compute critical values for confidence intervals.
</h2><span id='topic+crit'></span><span id='topic+crit+3C-'></span>

<h3>Description</h3>

<p>Every <code>"locfit"</code> object contains a critical value object to be used in
computing and ploting confidence intervals. By default, a 95% pointwise
confidence level is used. To change the confidence level, the critical
value object must be substituted using <code><a href="#topic+crit">crit</a></code> and
<code><a href="#topic+crit+3C-">crit&lt;-</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>crit(fit, const=c(0, 1), d=1, cov=0.95, rdf=0)
crit(fit) &lt;- value
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="crit_+3A_fit">fit</code></td>
<td>
<p><code>"locfit"</code> object. This is optional; if a fit is
provided, defaults for the other arguments are taken from the critical
value currently stored on this fit, rather than the usual values above.
<code>crit(fit)</code> with no other arguments will just return the current
critical value.</p>
</td></tr>
<tr><td><code id="crit_+3A_const">const</code></td>
<td>
<p>Tube formula constants for simultaneous bands (the default,
<code>c(0,1)</code>, produces pointwise coverage). Usually this is generated
by the <code><a href="#topic+kappa0">kappa0</a></code> function and should not be provided by the
user.</p>
</td></tr>
<tr><td><code id="crit_+3A_d">d</code></td>
<td>
<p>Dimension of the fit. Again, users shouldn't usually provide
it.</p>
</td></tr>
<tr><td><code id="crit_+3A_cov">cov</code></td>
<td>
<p>Coverage Probability for critical values.</p>
</td></tr>
<tr><td><code id="crit_+3A_rdf">rdf</code></td>
<td>
<p>Residual degrees of freedom. If non-zero, the critical values
are based on the Student's t distribution. When <code>rdf=0</code>, the
normal distribution is used.</p>
</td></tr>
<tr><td><code id="crit_+3A_value">value</code></td>
<td>
<p>Critical value object generated by <code><a href="#topic+crit">crit</a></code> or
<code><a href="#topic+kappa0">kappa0</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Critical value object.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+locfit">locfit</a></code>, <code><a href="#topic+plot.locfit">plot.locfit</a></code>,
<code><a href="#topic+kappa0">kappa0</a></code>, <code><a href="#topic+crit+3C-">crit&lt;-</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># compute and plot 99% confidence intervals, with local variance estimate.
data(ethanol)
fit &lt;- locfit(NOx~E,data=ethanol)
crit(fit) &lt;- crit(fit,cov=0.99)
plot(fit,band="local")

# compute and plot 99% simultaneous bands
crit(fit) &lt;- kappa0(NOx~E,data=ethanol,cov=0.99)
plot(fit,band="local")
</code></pre>

<hr>
<h2 id='dat'>
Locfit - data evaluation structure.
</h2><span id='topic+dat'></span>

<h3>Description</h3>

<p><code>dat</code> is used to specify evaluation on the given data points 
for <code><a href="#topic+locfit.raw">locfit.raw</a>()</code>. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dat(cv=FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dat_+3A_cv">cv</code></td>
<td>
<p>Whether cross-validation should be done.</p>
</td></tr>
</table>

<hr>
<h2 id='density.lf'>
Density estimation using Locfit
</h2><span id='topic+density.lf'></span>

<h3>Description</h3>

<p>This function provides an interface to Locfit, in the syntax of
(a now old version of) the S-Plus <code>density</code> function. This can reproduce
<code>density</code> results, but allows additional
<code><a href="#topic+locfit.raw">locfit.raw</a></code> arguments, such as the degree of fit, to be given.
</p>
<p>It also works in double precision, whereas <code>density</code> only works
in single precision.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>density.lf(x, n = 50, window = "gaussian", width, from, to,
  cut = if(iwindow == 4.) 0.75 else 0.5,
  ev = lfgrid(mg = n, ll = from, ur = to),
  deg = 0, family = "density", link = "ident", ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="density.lf_+3A_x">x</code></td>
<td>
<p>numeric vector of observations whose density is to be estimated.</p>
</td></tr>
<tr><td><code id="density.lf_+3A_n">n</code></td>
<td>
<p>number of evaluation points.
Equivalent to the <code><a href="#topic+locfit.raw">locfit.raw</a> mg</code> argument.</p>
</td></tr>
<tr><td><code id="density.lf_+3A_window">window</code></td>
<td>
<p>Window type to use for estimation.
Equivalent to the <code><a href="#topic+locfit.raw">locfit.raw</a> kern</code> argument. This includes
all the <code>density</code> windows except <code>cosine</code>.</p>
</td></tr>
<tr><td><code id="density.lf_+3A_width">width</code></td>
<td>
<p>Window width. Following <code>density</code>, this is the full
width; not the half-width usually used by Locfit and
many other smoothers.</p>
</td></tr>
<tr><td><code id="density.lf_+3A_from">from</code></td>
<td>
<p>Lower limit for estimation domain.</p>
</td></tr>
<tr><td><code id="density.lf_+3A_to">to</code></td>
<td>
<p>Upper limit for estimation domain.</p>
</td></tr>
<tr><td><code id="density.lf_+3A_cut">cut</code></td>
<td>
<p>Controls default expansion of the domain.</p>
</td></tr>
<tr><td><code id="density.lf_+3A_ev">ev</code></td>
<td>
<p>Locfit evaluation structure &ndash; default <code><a href="#topic+lfgrid">lfgrid</a>()</code>.</p>
</td></tr>
<tr><td><code id="density.lf_+3A_deg">deg</code></td>
<td>
<p>Fitting degree &ndash; default 0 for kernel estimation.</p>
</td></tr>
<tr><td><code id="density.lf_+3A_family">family</code></td>
<td>
<p>Fitting family &ndash; default is <code>"density"</code>.</p>
</td></tr>
<tr><td><code id="density.lf_+3A_link">link</code></td>
<td>
<p>Link function &ndash; default is the <code>"identity"</code>.</p>
</td></tr>
<tr><td><code id="density.lf_+3A_...">...</code></td>
<td>
<p>Additional arguments to <code><a href="#topic+locfit.raw">locfit.raw</a></code>, with standard
defaults.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with components <code>x</code> (evaluation points) and <code>y</code>
(estimated density).
</p>


<h3>See Also</h3>

<p><code>density</code>,
<code><a href="#topic+locfit">locfit</a></code>,
<code><a href="#topic+locfit.raw">locfit.raw</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(geyser)
density.lf(geyser, window="tria")
# the same result with density, except less precision.
density(geyser, window="tria")
</code></pre>

<hr>
<h2 id='diab'>Exhaust emissions</h2><span id='topic+diab'></span>

<h3>Description</h3>

<p>NOx exhaust emissions from a single cylinder engine.  Two predictor
variables are E (the engine's equivalence ratio) and C (Compression
ratio). 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(ethanol)</code></pre>


<h3>Format</h3>

<p>Data frame with NOx, E and C variables.
</p>


<h3>Source</h3>

<p>Brinkman (1981). Also studied extensively by Cleveland (1993).
</p>


<h3>References</h3>

<p>Brinkman, N. D. (1981). Ethanol fuel - a single-cylinder engine study
of efficiency and exhaust emissions. SAE transactions 90, 1414-1424.
</p>
<p>Cleveland, W. S. (1993). Visualizing data. Hobart Press, Summit, NJ.
</p>

<hr>
<h2 id='ethanol'>Exhaust emissions</h2><span id='topic+ethanol'></span>

<h3>Description</h3>

<p>NOx exhaust emissions from a single cylinder engine.  Two predictor
variables are E (the engine's equivalence ratio) and C (Compression
ratio). 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(ethanol)</code></pre>


<h3>Format</h3>

<p>Data frame with NOx, E and C variables.
</p>


<h3>Source</h3>

<p>Brinkman (1981). Also studied extensively by Cleveland (1993).
</p>


<h3>References</h3>

<p>Brinkman, N. D. (1981). Ethanol fuel - a single-cylinder engine study
of efficiency and exhaust emissions. SAE transactions 90, 1414-1424.
</p>
<p>Cleveland, W. S. (1993). Visualizing data. Hobart Press, Summit, NJ.
</p>

<hr>
<h2 id='expit'>
Inverse logistic link function
</h2><span id='topic+expit'></span>

<h3>Description</h3>

<p>Computes <code class="reqn">e^x/(1+e^x)</code>. 
This is the inverse of the logistic link function,
<code class="reqn">\log(p/(1-p))</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>expit(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="expit_+3A_x">x</code></td>
<td>
<p>numeric vector</p>
</td></tr>
</table>

<hr>
<h2 id='fitted.locfit'>
Fitted values for a &lsquo;&quot;locfit&quot;&rsquo; object.
</h2><span id='topic+fitted.locfit'></span>

<h3>Description</h3>

<p>Evaluates the fitted values (i.e. evaluates the surface
at the original data points) for a Locfit object. This function works
by reconstructing the model matrix from the original formula, and
predicting at those points. The function may be fooled; for example,
if the original data frame has changed since the fit, or if the
model formula includes calls to random number generators.</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'locfit'
fitted(object, data=NULL, what="coef", cv=FALSE,
studentize=FALSE, type="fit", tr, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fitted.locfit_+3A_object">object</code></td>
<td>

<p><code>"locfit"</code> object.
</p>
</td></tr>
<tr><td><code id="fitted.locfit_+3A_data">data</code></td>
<td>

<p>The data frame for the original fit. Usually, this shouldn't be needed,
especially when the function is called directly. It may be needed
when called inside another function.
</p>
</td></tr>
<tr><td><code id="fitted.locfit_+3A_what">what</code></td>
<td>

<p>What to compute fitted values of. The default, <code>what="coef"</code>, works
with the fitted curve itself. Other choices include <code>"nlx"</code> for the
length of the weight diagram; <code>"infl"</code> for the influence function;
<code>"band"</code> for the bandwidth; <code>"degr"</code> for the local polynomial
degree; <code>"lik"</code> for the maximized local likelihood; <code>"rdf"</code>
for the local residual degrees of freedom and <code>"vari"</code> for the
variance function. The interpolation algorithm for some of these quantities
is questionable.
</p>
</td></tr>
<tr><td><code id="fitted.locfit_+3A_cv">cv</code></td>
<td>

<p>If <code>TRUE</code>, leave-one-out cross validated fitted values are approximated.
Won't make much sense, unless <code>what="coef"</code>.
</p>
</td></tr>
<tr><td><code id="fitted.locfit_+3A_studentize">studentize</code></td>
<td>

<p>If <code>TRUE</code>, residuals are studentized.
</p>
</td></tr>
<tr><td><code id="fitted.locfit_+3A_type">type</code></td>
<td>

<p>Type of fit or residuals to compute. The default is <code>"fit"</code> for
<code>fitted.locfit</code>, and <code>"dev"</code> for <code><a href="#topic+residuals.locfit">residuals.locfit</a></code>.
Other choices include <code>"pear"</code> for Pearson residuals; <code>"raw"</code>
for raw residuals, <code>"ldot"</code> for likelihood derivative;
<code>"d2"</code> for the deviance residual squared; <code>lddot</code> for the
likelihood second derivative. Generally, <code>type</code> should only be
used when <code>what="coef"</code>.
</p>
</td></tr>
<tr><td><code id="fitted.locfit_+3A_tr">tr</code></td>
<td>

<p>Back transformation for likelihood models.
</p>
</td></tr>
<tr><td><code id="fitted.locfit_+3A_...">...</code></td>
<td>
<p>arguments passed to and from methods.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A numeric vector of the fitted values.
</p>


<h3>See Also</h3>

<p><code>locfit</code>,
<code>predict.locfit</code>,
<code>residuals.locfit</code>
</p>

<hr>
<h2 id='formula.locfit'>
Formula from a Locfit object.
</h2><span id='topic+formula.locfit'></span>

<h3>Description</h3>

<p>Extract the model formula from a locfit object.</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'locfit'
formula(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="formula.locfit_+3A_x">x</code></td>
<td>
 <p><code>locfit</code> object.</p>
</td></tr>
<tr><td><code id="formula.locfit_+3A_...">...</code></td>
<td>
<p>Arguments passed to and from other methods.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns the formula from the locfit object.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+locfit">locfit</a></code>
</p>

<hr>
<h2 id='gam.lf'>
Locfit call for Generalized Additive Models
</h2><span id='topic+gam.lf'></span>

<h3>Description</h3>

<p>This is a locfit calling function used by
<code><a href="#topic+lf">lf</a>()</code> terms in additive models. It is
not normally called directly by users.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gam.lf(x, y, w, xeval, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gam.lf_+3A_x">x</code></td>
<td>
<p>numeric predictor</p>
</td></tr>
<tr><td><code id="gam.lf_+3A_y">y</code></td>
<td>
<p>numeric response</p>
</td></tr>
<tr><td><code id="gam.lf_+3A_w">w</code></td>
<td>
<p>prior weights</p>
</td></tr>
<tr><td><code id="gam.lf_+3A_xeval">xeval</code></td>
<td>
<p>evaluation points</p>
</td></tr>
<tr><td><code id="gam.lf_+3A_...">...</code></td>
<td>
<p>other arguments to <code><a href="#topic+locfit.raw">locfit.raw</a>()</code></p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+locfit">locfit</a></code>,
<code><a href="#topic+locfit.raw">locfit.raw</a></code>,
<code><a href="#topic+lf">lf</a></code>,
<code>gam</code>
</p>

<hr>
<h2 id='gam.slist'>Vector of GAM special terms</h2><span id='topic+gam.slist'></span>

<h3>Description</h3>

<p>This vector adds <code>"lf"</code> to the default vector of special
terms recognized by a <code>gam()</code> model formula.
To ensure this is recognized, attach the Locfit library with
<code>library(locfit,first=T)</code>.
</p>


<h3>Format</h3>

<p>Character vector.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+lf">lf</a></code>,
<code>gam</code>
</p>

<hr>
<h2 id='gcv'>
Compute generalized cross-validation statistic.
</h2><span id='topic+gcv'></span>

<h3>Description</h3>

<p>The calling sequence for <code>gcv</code> matches those for the
<code><a href="#topic+locfit">locfit</a></code> or <code><a href="#topic+locfit.raw">locfit.raw</a></code> functions.
The fit is not returned; instead, the returned object contains
Wahba's generalized cross-validation score for the fit.
</p>
<p>The GCV score is exact (up to numerical roundoff) if the
<code>ev="data"</code> argument is provided. Otherwise, the residual
sum-of-squares and degrees of freedom are computed using locfit's
standard interpolation based approximations.
</p>
<p>For likelihood models, GCV is computed uses the deviance
in place of the residual sum of squares. This produces useful
results but I do not know of any theory validating
this extension.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gcv(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gcv_+3A_x">x</code>, <code id="gcv_+3A_...">...</code></td>
<td>
<p>Arguments passed on to <code><a href="#topic+locfit">locfit</a></code> or
<code><a href="#topic+locfit.raw">locfit.raw</a></code>.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+locfit">locfit</a></code>,
<code><a href="#topic+locfit.raw">locfit.raw</a></code>,
<code><a href="#topic+gcvplot">gcvplot</a></code>
</p>

<hr>
<h2 id='gcvplot'>
Compute a generalized cross-validation plot.
</h2><span id='topic+gcvplot'></span>

<h3>Description</h3>

<p>The <code>gcvplot</code> function loops through calls to the <code><a href="#topic+gcv">gcv</a></code>
function (and hence to <code>link{locfit}</code>), using a different
smoothing parameter for each call.
The returned structure contains the GCV statistic for each fit, and can
be used to produce an GCV plot.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gcvplot(..., alpha, df=2)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gcvplot_+3A_...">...</code></td>
<td>
<p> arguments to the <code><a href="#topic+gcv">gcv</a></code>, <code><a href="#topic+locfit">locfit</a></code>
functions.</p>
</td></tr>
<tr><td><code id="gcvplot_+3A_alpha">alpha</code></td>
<td>
<p> Matrix of smoothing parameters. The <code>gcvplot</code> function
loops through calls to <code><a href="#topic+gcv">gcv</a></code>, using each row of
<code>alpha</code> as the smoothing parameter in turn. If <code>alpha</code>
is provided as a vector, it will be converted to a one-column
matrix, thus interpreting each component as a nearest neighbor
smoothing parameter.</p>
</td></tr>
<tr><td><code id="gcvplot_+3A_df">df</code></td>
<td>
<p> Degrees of freedom to use as the x-axis. 2=trace(L), 
3=trace(L'L).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object with class <code>"gcvplot"</code>, containing the smoothing
parameters and GCV scores. The actual plot is produced using
<code><a href="#topic+plot.gcvplot">plot.gcvplot</a></code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+locfit">locfit</a></code>,
<code><a href="#topic+locfit.raw">locfit.raw</a></code>,
<code><a href="#topic+gcv">gcv</a></code>,
<code><a href="#topic+plot.gcvplot">plot.gcvplot</a></code>,
<code><a href="#topic+summary.gcvplot">summary.gcvplot</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(ethanol)
plot(gcvplot(NOx~E,data=ethanol,alpha=seq(0.2,1.0,by=0.05)))
</code></pre>

<hr>
<h2 id='geyser'>Old Faithful Geyser Dataset</h2><span id='topic+geyser'></span>

<h3>Description</h3>

<p>The durations of 107 eruptions of the Old Faithful Geyser.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(geyser)</code></pre>


<h3>Format</h3>

<p>A numeric vector of length 107.
</p>


<h3>Source</h3>

<p>Scott (1992). Note that several different Old Faithful Geyser datasets
(including the faithful dataset in R's base library) have been used
in various places in the statistics literature. The version provided
here has been used in density estimation and bandwidth selection work.
</p>


<h3>References</h3>

<p>Scott, D. W. (1992). Multivariate Density Estimation: Theory,
Practice and Visualization. Wiley.
</p>

<hr>
<h2 id='geyser.round'>Discrete Old Faithful Geyser Dataset</h2><span id='topic+geyser.round'></span>

<h3>Description</h3>

<p>This is a variant of the <code><a href="#topic+geyser">geyser</a></code> dataset, where
each observation is rounded to the nearest 0.05 minutes, and the
counts tallied.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(geyser.round)</code></pre>


<h3>Format</h3>

<p>Data Frame with variables <code>duration</code> and <code>count</code>.
</p>


<h3>Source</h3>

<p>Scott (1992). Note that several different Old Faithful Geyser datasets
(including the faithful dataset in R's base library) have been used
in various places in the statistics literature. The version provided
here has been used in density estimation and bandwidth selection work.
</p>


<h3>References</h3>

<p>Scott, D. W. (1992). Multivariate Density Estimation: Theory,
Practice and Visualization. Wiley.
</p>

<hr>
<h2 id='hatmatrix'>
Weight diagrams and the hat matrix for a local regression model.
</h2><span id='topic+hatmatrix'></span>

<h3>Description</h3>

<p><code>hatmatrix()</code> computes the weight diagrams (also known as
equivalent or effective kernels) for a local regression smooth.
Essentially, <code>hatmatrix()</code> is a front-end to <code><a href="#topic+locfit">locfit</a>()</code>,
setting a flag to compute and return weight diagrams, rather than the
fit.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>hatmatrix(formula, dc=TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="hatmatrix_+3A_formula">formula</code></td>
<td>
<p>model formula.</p>
</td></tr>
<tr><td><code id="hatmatrix_+3A_dc">dc</code></td>
<td>
<p>derivative adjustment (see <code><a href="#topic+locfit.raw">locfit.raw</a></code>)</p>
</td></tr>
<tr><td><code id="hatmatrix_+3A_...">...</code></td>
<td>
<p>Other arguments to <code><a href="#topic+locfit">locfit</a></code> and
<code><a href="#topic+locfit.raw">locfit.raw</a></code>.
</p>
</td></tr></table>


<h3>Value</h3>

<p>A matrix with n rows and p columns; each column being the
weight diagram for the corresponding <code>locfit</code> fit point.
If <code>ev="data"</code>, this is the transpose of the hat matrix.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+locfit">locfit</a></code>, <code><a href="#topic+plot.locfit.1d">plot.locfit.1d</a></code>, <code><a href="#topic+plot.locfit.2d">plot.locfit.2d</a></code>,
<code><a href="#topic+plot.locfit.3d">plot.locfit.3d</a></code>, <code><a href="#topic+lines.locfit">lines.locfit</a></code>, <code><a href="#topic+predict.locfit">predict.locfit</a></code>
</p>

<hr>
<h2 id='heart'>Survival Times of Heart Transplant Recipients</h2><span id='topic+heart'></span>

<h3>Description</h3>

<p>The survival times of 184 participants in the Stanford heart
transplant program.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(heart)</code></pre>


<h3>Format</h3>

<p>Data frame with surv, cens and age variables.
</p>


<h3>Source</h3>

<p>Miller and Halperin (1982).
The original dataset includes information on additional patients who
never received a transplant. Other authors reported earlier versions
of the data.
</p>


<h3>References</h3>

<p>Miller, R. G. and Halperin, J. (1982). Regression with censored data.
Biometrika 69, 521-531.
</p>

<hr>
<h2 id='insect'>Insect Dataset</h2><span id='topic+insect'></span>

<h3>Description</h3>

<p>An experiment measuring death rates for insects, with 30 insects at
each of five treatment levels.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(insect)</code></pre>


<h3>Format</h3>

<p>Data frame with <code>lconc</code> (dosage), <code>deaths</code>
(number of deaths) and <code>nins</code>
(number of insects) variables.
</p>


<h3>Source</h3>

<p>Bliss (1935).
</p>


<h3>References</h3>

<p>Bliss (1935).
The calculation of the dosage-mortality curve.
<em>Annals of Applied Biology</em> 22, 134-167.
</p>

<hr>
<h2 id='iris'>Fisher's Iris Data (subset)</h2><span id='topic+iris'></span>

<h3>Description</h3>

<p>Four measurements on each of fifty flowers of two species of iris
(Versicolor and Virginica) &ndash; A classification dataset. Fisher's
original dataset contained a third species (Setosa) which is trivially
seperable.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(iris)</code></pre>


<h3>Format</h3>

<p>Data frame with species, petal.wid, petal.len, sepal.wid, sepal.len.
</p>


<h3>Source</h3>

<p>Fisher (1936). Reproduced in Andrews and Herzberg (1985) Chapter 1.
</p>


<h3>References</h3>

<p>Andrews, D. F. and Herzberg, A. M. (1985). Data. Springer-Verlag.
</p>
<p>Fisher, R. A. (1936). The Use of Multiple Measurements in Taxonomic
Problems. Annals of Eugenics 7, Part II. 179-188.
</p>

<hr>
<h2 id='kangaroo'>Kangaroo skull measurements dataset</h2><span id='topic+kangaroo'></span>

<h3>Description</h3>

<p>Variables are <code>sex</code> (m/f), <code>spec</code> (giganteus, melanops,
fuliginosus) and 18 numeric measurements.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(kangaroo)</code></pre>


<h3>Format</h3>

<p>Data frame with measurements on the skulls of 101 kangaroos.
(number of insects) variables.
</p>


<h3>Source</h3>

<p>Andrews and Herzberg (1985) Chapter 53.
</p>


<h3>References</h3>

<p>Andrews, D. F. and Herzberg, A. M. (1985).
Data.
Springer-Verlag, New York.
</p>

<hr>
<h2 id='kappa0'>
Critical Values for Simultaneous Confidence Bands.
</h2><span id='topic+kappa0'></span>

<h3>Description</h3>

<p>The geometric constants for simultaneous confidence bands are computed,
as described in Sun and Loader (1994) (bias adjustment is not implemented
here). These are then passed to the <code><a href="#topic+crit">crit</a></code> function, which
computes the critical value for the confidence bands.
</p>
<p>The method requires both the weight diagrams l(x), the
derivative l'(x) and (in 2 or more dimensions) the second
derivatives l&rdquo;(x).
These are implemented exactly for a constant bandwidth.
For nearest
neighbor bandwidths, the computations are approximate and a warning
is produced.
</p>
<p>The theoretical justification for the bands uses normality of
the random errors <code class="reqn">e_1,\dots,e_n</code> in the regression model,
and in particular the spherical symmetry of the error vector.
For non-normal distributions, and likelihood models, one relies
on central limit and related theorems.
</p>
<p>Computation uses the product Simpson's rule to evaluate the
multidimensional integrals (The domain of integration, and
hence the region of simultaneous coverage, is determined by
the <code>flim</code> argument). Expect the integration to be slow in more
than one dimension. The <code>mint</code> argument controls the
precision.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>kappa0(formula, cov=0.95, ev=lfgrid(20), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="kappa0_+3A_formula">formula</code></td>
<td>

<p>Local regression model formula. A <code>"locfit"</code> object can also
be provided; in this case the formula and other arguments are extracted
from this object.
</p>
</td></tr>
<tr><td><code id="kappa0_+3A_cov">cov</code></td>
<td>
<p> Coverage Probability for critical values.  </p>
</td></tr>
<tr><td><code id="kappa0_+3A_ev">ev</code></td>
<td>
<p> Locfit evaluation structure. Should usually be a grid &ndash;
this specifies the integration rule. </p>
</td></tr>
<tr><td><code id="kappa0_+3A_...">...</code></td>
<td>
<p>Other arguments to <code><a href="#topic+locfit">locfit</a></code>. Important arguments
include <code>flim</code> and <code>alpha</code>. </p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with components for the critical value, geometric constants,
e.t.c. Can be passed directly to <code><a href="#topic+plot.locfit">plot.locfit</a></code> as the
<code>crit</code> argument.
</p>


<h3>References</h3>

<p>Sun, J. and Loader, C. (1994). Simultaneous confidence bands for linear
regression and smoothing. Annals of Statistics 22, 1328-1345.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+locfit">locfit</a></code>, <code><a href="#topic+plot.locfit">plot.locfit</a></code>,
<code><a href="#topic+crit">crit</a></code>, <code><a href="#topic+crit+3C-">crit&lt;-</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># compute and plot simultaneous confidence bands
data(ethanol)
fit &lt;- locfit(NOx~E,data=ethanol)
crit(fit) &lt;- kappa0(NOx~E,data=ethanol)
plot(fit,crit=crit,band="local")
</code></pre>

<hr>
<h2 id='kdeb'>
Bandwidth selectors for kernel density estimation.
</h2><span id='topic+kdeb'></span>

<h3>Description</h3>

<p>Function to compute kernel density estimate bandwidths, as used in the
simulation results in Chapter 10 of Loader (1999).
</p>
<p>This function is included for comparative purposes only. Plug-in
selectors are based on flawed logic, make unreasonable and restrictive
assumptions
and do not use the full power of the estimates available in Locfit.
Any relation between the results produced by this function and
desirable estimates are entirely coincidental.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>kdeb(x, h0 = 0.01 * sd, h1 = sd, meth = c("AIC", "LCV", "LSCV", "BCV", 
  "SJPI", "GKK"), kern = "gauss", gf = 2.5)

</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="kdeb_+3A_x">x</code></td>
<td>
<p>One dimensional data vector.</p>
</td></tr>
<tr><td><code id="kdeb_+3A_h0">h0</code></td>
<td>
<p>Lower limit for bandwidth selection. Can be fairly small,
but h0=0 would cause problems.</p>
</td></tr>
<tr><td><code id="kdeb_+3A_h1">h1</code></td>
<td>
<p>Upper limit.</p>
</td></tr>
<tr><td><code id="kdeb_+3A_meth">meth</code></td>
<td>
<p>Required selection method(s).</p>
</td></tr>
<tr><td><code id="kdeb_+3A_kern">kern</code></td>
<td>
<p>Kernel. Most methods require <code>kern="gauss"</code>, the default
for this function only.</p>
</td></tr>
<tr><td><code id="kdeb_+3A_gf">gf</code></td>
<td>
<p>Standard deviation for the gaussian kernel. Default 2.5, as
Locfit's standard. Most papers use 1.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Vector of selected bandwidths.
</p>


<h3>References</h3>

<p>Loader, C. (1999). Local Regression and Likelihood. Springer, New York.
</p>

<hr>
<h2 id='km.mrl'>
Mean Residual Life using Kaplan-Meier estimate
</h2><span id='topic+km.mrl'></span>

<h3>Description</h3>

<p>This function computes the mean residual life for censored data
using the Kaplan-Meier estimate of the survival function. If
<code class="reqn">S(t)</code> is the K-M estimate, the MRL for a censored observation
is computed as <code class="reqn">(\int_t^{\infty} S(u)du)/S(t)</code>. We take
<code class="reqn">S(t)=0</code> when <code class="reqn">t</code> is greater than the largest observation,
regardless of whether that observation was censored.
</p>
<p>When there are ties between censored and uncensored observations,
for definiteness our ordering places the censored observations
before uncensored.
</p>
<p>This function is used by <code><a href="#topic+locfit.censor">locfit.censor</a></code> to compute
censored regression estimates.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>km.mrl(times, cens)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="km.mrl_+3A_times">times</code></td>
<td>

<p>Obsereved survival times.
</p>
</td></tr>
<tr><td><code id="km.mrl_+3A_cens">cens</code></td>
<td>

<p>Logical variable indicating censoring. The coding is <code>1</code>
or <code>TRUE</code> for censored; <code>0</code> or <code>FALSE</code> for uncensored.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector of the estimated mean residual life. For uncensored observations,
the corresponding estimate is 0.
</p>


<h3>References</h3>

<p>Buckley, J. and James, I. (1979). Linear Regression with censored data.
Biometrika 66, 429-436.
</p>
<p>Loader, C. (1999). Local Regression and Likelihood. Springer, NY (Section 7.2).
</p>


<h3>See Also</h3>

<p><code><a href="#topic+locfit.censor">locfit.censor</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># censored regression using the Kaplan-Meier estimate.
data(heart, package="locfit")
fit &lt;- locfit.censor(log10(surv+0.5)~age, cens=cens, data=heart, km=TRUE)
plotbyfactor(heart$age, 0.5+heart$surv, heart$cens, ylim=c(0.5,16000), log="y")
lines(fit, tr=function(x)10^x)
</code></pre>

<hr>
<h2 id='lcv'>Compute Likelihood Cross Validation Statistic.</h2><span id='topic+lcv'></span>

<h3>Description</h3>

<p>The calling sequence for <code>lcv</code> matches those for the
<code><a href="#topic+locfit">locfit</a></code> or <code><a href="#topic+locfit.raw">locfit.raw</a></code> functions.
The fit is not returned; instead, the returned object contains
likelihood cross validation score for the fit.
</p>
<p>The LCV score is exact (up to numerical roundoff) if the
<code>ev="cross"</code> argument is provided. Otherwise, the influence
and cross validated residuals
are computed using locfit's
standard interpolation based approximations.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lcv(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="lcv_+3A_x">x</code></td>
<td>
<p>model formula</p>
</td></tr>
<tr><td><code id="lcv_+3A_...">...</code></td>
<td>
<p>other arguments to locfit</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+locfit">locfit</a></code>,
<code><a href="#topic+locfit.raw">locfit.raw</a></code>,
<code><a href="#topic+lcvplot">lcvplot</a></code>
</p>

<hr>
<h2 id='lcvplot'>
Compute the likelihood cross-validation plot.
</h2><span id='topic+lcvplot'></span>

<h3>Description</h3>

<p>The <code>lcvplot</code> function loops through calls to the <code><a href="#topic+lcv">lcv</a></code>
function (and hence to <code>link{locfit}</code>), using a different
smoothing parameter for each call.
The returned structure contains the likelihood cross validation statistic
for each fit, and can be used to produce an LCV plot.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lcvplot(..., alpha)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="lcvplot_+3A_...">...</code></td>
<td>
<p> arguments to the <code><a href="#topic+lcv">lcv</a></code>, <code><a href="#topic+locfit">locfit</a></code>
functions.</p>
</td></tr>
<tr><td><code id="lcvplot_+3A_alpha">alpha</code></td>
<td>
<p> Matrix of smoothing parameters. The <code>aicplot</code> function
loops through calls to <code><a href="#topic+lcv">lcv</a></code>, using each row of
<code>alpha</code> as the smoothing parameter in turn. If <code>alpha</code>
is provided as a vector, it will be converted to a one-column
matrix, thus interpreting each component as a nearest neighbor
smoothing parameter.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object with class <code>"gcvplot"</code>, containing the smoothing
parameters and LCV scores. The actual plot is produced using
<code><a href="#topic+plot.gcvplot">plot.gcvplot</a></code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+locfit">locfit</a></code>,
<code><a href="#topic+locfit.raw">locfit.raw</a></code>,
<code><a href="#topic+gcv">gcv</a></code>,
<code><a href="#topic+lcv">lcv</a></code>,
<code><a href="#topic+plot.gcvplot">plot.gcvplot</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(ethanol)
plot(lcvplot(NOx~E,data=ethanol,alpha=seq(0.2,1.0,by=0.05)))
</code></pre>

<hr>
<h2 id='left'>
One-sided left smooth for a Locfit model.
</h2><span id='topic+left'></span>

<h3>Description</h3>

<p>The <code>left()</code> function is used in a locfit model formula
to specify a one-sided smooth: when fitting at a point <code class="reqn">x</code>,
only data points with <code class="reqn">x_i \le x</code> should be used.
This can be useful in estimating points of discontinuity,
and in cross-validation for forecasting a time series.
<code>left(x)</code> is equivalent to <code>lp(x,style="left")</code>.
</p>
<p>When using this function, it will usually be necessary to specify an
evaluation structure, since the fit is not smooth and locfit's
interpolation methods are unreliable. Also, it is usually best
to use <code>deg=0</code> or <code>deg=1</code>, otherwise the fits may be too
variable. If nearest neighbor bandwidth specification is used,
it does not recognize <code>left()</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>left(x,...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="left_+3A_x">x</code></td>
<td>
<p>numeric variable.</p>
</td></tr>
<tr><td><code id="left_+3A_...">...</code></td>
<td>
<p>Other arguments to <code><a href="#topic+lp">lp</a>()</code>.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+locfit">locfit</a></code>,
<code><a href="#topic+lp">lp</a></code>,
<code><a href="#topic+right">right</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># compute left and right smooths
data(penny)
xev &lt;- (1945:1988)+0.5
fitl &lt;- locfit(thickness~left(year,h=10,deg=1), ev=xev, data=penny)
fitr &lt;- locfit(thickness~right(year,h=10,deg=1),ev=xev, data=penny)
# plot the squared difference, to show the change points.
plot( xev, (predict(fitr,where="ev") - predict(fitl,where="ev"))^2 )
</code></pre>

<hr>
<h2 id='lf'>
Locfit term in Additive Model formula
</h2><span id='topic+lf'></span>

<h3>Description</h3>

<p>This function is used to specify a smooth term in a <code>gam()</code>
model formula.
</p>
<p>This function is designed to be used with the S-Plus
<code>gam()</code> function. For R users, there are at least two different
<code>gam()</code> functions available. Most current distributions of R
will include the <code>mgcv</code> library by Simon Wood; <code>lf()</code>
is not compatable with this function.
</p>
<p>On CRAN, there is a <code>gam</code> package by Trevor Hastie, similar to
the S-Plus version. <code>lf()</code> should be compatable with this, although
it's untested.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lf(..., alpha=0.7, deg=2, scale=1, kern="tcub", ev=rbox(), maxk=100)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="lf_+3A_...">...</code></td>
<td>
<p>numeric predictor variable(s)</p>
</td></tr>
<tr><td><code id="lf_+3A_alpha">alpha</code>, <code id="lf_+3A_deg">deg</code>, <code id="lf_+3A_scale">scale</code>, <code id="lf_+3A_kern">kern</code>, <code id="lf_+3A_ev">ev</code>, <code id="lf_+3A_maxk">maxk</code></td>
<td>
<p>these are as in
<code><a href="#topic+locfit.raw">locfit.raw</a></code>.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+locfit">locfit</a></code>,
<code><a href="#topic+locfit.raw">locfit.raw</a></code>,
<code><a href="#topic+gam.lf">gam.lf</a></code>,
<code>gam</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run:   
# fit an additive semiparametric model to the ethanol data.
stopifnot(require(gam))
# The `gam' package must be attached _before_ `locfit', otherwise
# the following will not work.
data(ethanol, package = "lattice")
fit &lt;- gam(NOx ~ lf(E) + C, data=ethanol)
op &lt;- par(mfrow=c(2, 1))
plot(fit)
par(op)

## End(Not run)
</code></pre>

<hr>
<h2 id='lfeval'>
Extract Locfit Evaluation Structure.
</h2><span id='topic+lfeval'></span>

<h3>Description</h3>

<p>Extracts the evaluation structure from a <code>"locfit"</code> object.
This object has the class <code>"lfeval"</code>, and has its own set of
methods for plotting e.t.c.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lfeval(object)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="lfeval_+3A_object">object</code></td>
<td>
<p><code>"locfit"</code> object</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>"lfeval"</code> object.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+locfit">locfit</a></code>,
<code><a href="#topic+plot.lfeval">plot.lfeval</a></code>,
<code><a href="#topic+print.lfeval">print.lfeval</a></code>
</p>

<hr>
<h2 id='lfgrid'>
Locfit - grid evaluation structure.
</h2><span id='topic+lfgrid'></span>

<h3>Description</h3>

<p><code>lfgrid()</code> is used to specify evaluation on a grid of points
for <code><a href="#topic+locfit.raw">locfit.raw</a>()</code>. The structure computes
a bounding box for the data, and divides that into a grid with
specified margins.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lfgrid(mg=10, ll, ur)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="lfgrid_+3A_mg">mg</code></td>
<td>

<p>Number of grid points along each margin. Can be a single number (which
is applied in each dimension), or a vector specifying a value for
each dimension.
</p>
</td></tr>
<tr><td><code id="lfgrid_+3A_ll">ll</code></td>
<td>

<p>Lower left limits for the grid. Length should be the number
of dimensions of the data provided to <code><a href="#topic+locfit.raw">locfit.raw</a>()</code>.
</p>
</td></tr>
<tr><td><code id="lfgrid_+3A_ur">ur</code></td>
<td>

<p>Upper right limits for the grid. By default, <code>ll</code> and
<code>ur</code> are generated as the bounding box for the data.
</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>data(ethanol, package="locfit")
plot.eval(locfit(NOx ~ lp(E, C, scale=TRUE), data=ethanol, ev=lfgrid()))
</code></pre>

<hr>
<h2 id='lfknots'>
Extraction of fit-point information from a Locfit object.
</h2><span id='topic+lfknots'></span>

<h3>Description</h3>

<p>Extracts information, such as fitted values, influence functions
from a <code>"locfit"</code> object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lfknots(x, tr, what = c("x", "coef", "h", "nlx"), delete.pv = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="lfknots_+3A_x">x</code></td>
<td>

<p>Fitted object from <code><a href="#topic+locfit">locfit</a>()</code>.
</p>
</td></tr>
<tr><td><code id="lfknots_+3A_tr">tr</code></td>
<td>

<p>Back transformation. Default is the invers link function from the Locfit
object.
</p>
</td></tr>
<tr><td><code id="lfknots_+3A_what">what</code></td>
<td>

<p>What to return; default is <code>c("x","coef","h","nlx")</code>.
Allowed fields are <code>x</code> (fit points); <code>coef</code> (fitted values);
<code>f1</code> (local slope); <code>nlx</code> (length of the weight diagram);
<code>nlx1</code> (estimated derivative of <code>nlx</code>); <code>se</code> (standard errors);
<code>infl</code> (influence function); <code>infla</code> (slope of influence function);
<code>lik</code> (maximixed local log-likelihood and local degrees of freedom);
<code>h</code> (bandwidth) and <code>deg</code> (degree of fit).
</p>
</td></tr>
<tr><td><code id="lfknots_+3A_delete.pv">delete.pv</code></td>
<td>
<p>If <code>T</code>, pseudo-vertices are deleted.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix with one row for each fit point. Columns correspond to
the specified <code>what</code> vector; some fields contribute multiple columns.
</p>

<hr>
<h2 id='lflim'>
Construct Limit Vectors for Locfit fits.
</h2><span id='topic+lflim'></span>

<h3>Description</h3>

<p>This function is used internally to interpret <code>xlim</code> and <code>flim</code>
arguments. It should not be called directly.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lflim(limits, nm, ret)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="lflim_+3A_limits">limits</code></td>
<td>

<p>Limit argument.
</p>
</td></tr>
<tr><td><code id="lflim_+3A_nm">nm</code></td>
<td>

<p>Variable names.
</p>
</td></tr>
<tr><td><code id="lflim_+3A_ret">ret</code></td>
<td>

<p>Initial return vector.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Vector with length 2*dim.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+locfit">locfit</a></code>
</p>

<hr>
<h2 id='lfmarg'>
Generate grid margins.
</h2><span id='topic+lfmarg'></span>

<h3>Description</h3>

<p>This function is usually called by <code><a href="#topic+plot.locfit">plot.locfit</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lfmarg(xlim, m = 40)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="lfmarg_+3A_xlim">xlim</code></td>
<td>

<p>Vector of limits for the grid. Should be of length 2*d;
the first d components represent the lower left corner,
and the next d components the upper right corner.
Can also be a <code>"locfit"</code> object.
</p>
</td></tr>
<tr><td><code id="lfmarg_+3A_m">m</code></td>
<td>

<p>Number of points for each grid margin. Can be a vector of length d.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list, whose components are the d grid margins.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+locfit">locfit</a></code>, <code><a href="#topic+plot.locfit">plot.locfit</a></code>
</p>

<hr>
<h2 id='lines.locfit'>
Add locfit line to existing plot
</h2><span id='topic+lines.locfit'></span><span id='topic+llines.locfit'></span>

<h3>Description</h3>

<p>Adds a Locfit line to an existing plot.  <code>llines</code> is for use
within a panel function for Lattice.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'locfit'
lines(x, m=100, tr=x$trans, ...)
## S3 method for class 'locfit'
llines(x, m=100, tr=x$trans, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="lines.locfit_+3A_x">x</code></td>
<td>
<p><code>locfit</code> object. Should be a model with one predictor.</p>
</td></tr>
<tr><td><code id="lines.locfit_+3A_m">m</code></td>
<td>
<p>Number of points to evaluate the line at.</p>
</td></tr>
<tr><td><code id="lines.locfit_+3A_tr">tr</code></td>
<td>
<p>Transformation function to use for plotting.  Default is the
inverse link function, or the identity function if derivatives are
required.</p>
</td></tr> 
<tr><td><code id="lines.locfit_+3A_...">...</code></td>
<td>
<p>Other arguments to the default <code><a href="graphics.html#topic+lines">lines</a></code> function.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+locfit">locfit</a></code>, <code><a href="#topic+plot.locfit">plot.locfit</a></code>, <code><a href="graphics.html#topic+lines">lines</a></code>
</p>

<hr>
<h2 id='livmet'>liver Metastases dataset</h2><span id='topic+livmet'></span>

<h3>Description</h3>

<p>Survival times for 622 patients diagnosed with Liver Metastases.
</p>
<p>Beware, the censoring variable
is coded as 1 = uncensored, so use <code>cens=1-z</code> in
<code><a href="#topic+locfit">locfit</a>()</code> calls.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(livmet)</code></pre>


<h3>Format</h3>

<p>Data frame with survival times (<code>t</code>), censoring indicator
(<code>z</code>) and a number of covariates.
</p>


<h3>Source</h3>

<p>Haupt and Mansmann (1995)
</p>


<h3>References</h3>

<p>Haupt, G. and Mansmann, U. (1995)
CART for Survival Data.
Statlib Archive.
</p>

<hr>
<h2 id='locfit'>
Local Regression, Likelihood and Density Estimation.
</h2><span id='topic+locfit'></span>

<h3>Description</h3>

<p><code>locfit</code> is the model formula-based interface to the Locfit
library for fitting local regression and likelihood models.
</p>
<p><code>locfit</code> is implemented as a front-end to <code><a href="#topic+locfit.raw">locfit.raw</a></code>.
See that function for options to control smoothing parameters,
fitting family and other aspects of the fit.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>locfit(formula, data=sys.frame(sys.parent()), weights=1, cens=0, base=0,
       subset, geth=FALSE, ..., lfproc=locfit.raw)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="locfit_+3A_formula">formula</code></td>
<td>

<p>Model Formula; e.g. <code>y~lp(x)</code> for a regression model; <code>~lp(x)</code> for a
density estimation model. Use of <code>lp()</code> on the RHS is recommended, especially
when non-default smoothing parameters are used.
</p>
</td></tr>
<tr><td><code id="locfit_+3A_data">data</code></td>
<td>

<p>Data Frame.
</p>
</td></tr>
<tr><td><code id="locfit_+3A_weights">weights</code></td>
<td>

<p>Prior weights (or sample sizes) for individual observations. This is
typically used where observations have unequal variance.
</p>
</td></tr>
<tr><td><code id="locfit_+3A_cens">cens</code></td>
<td>

<p>Censoring indicator. <code>1</code> (or <code>TRUE</code>) denotes a censored observation.
<code>0</code> (or <code>FALSE</code>) denotes uncensored.
</p>
</td></tr>
<tr><td><code id="locfit_+3A_base">base</code></td>
<td>

<p>Baseline for local fitting. For local regression models, specifying
a <code>base</code> is equivalent to using <code>y-base</code> as the reponse. But <code>base</code>
also works for local likelihood.
</p>
</td></tr>
<tr><td><code id="locfit_+3A_subset">subset</code></td>
<td>

<p>Subset observations in the data frame.
</p>
</td></tr>
<tr><td><code id="locfit_+3A_geth">geth</code></td>
<td>

<p>Don't use.
</p>
</td></tr>
<tr><td><code id="locfit_+3A_...">...</code></td>
<td>

<p>Other arguments to <code><a href="#topic+locfit.raw">locfit.raw</a>()</code> (or the <code>lfproc</code>).
</p>
</td></tr>
<tr><td><code id="locfit_+3A_lfproc">lfproc</code></td>
<td>

<p>A processing function to compute the local fit. Default is
<code>locfit.raw()</code>. Other choices include <code>locfit.robust()</code>,
<code>locfit.censor()</code> and <code>locfit.quasi()</code>.
</p>
</td></tr></table>


<h3>Value</h3>

<p>An object with class <code>"locfit"</code>. A standard set of methods for printing,
ploting, etc. these objects is provided.
</p>


<h3>References</h3>

<p>Loader, C. (1999). Local Regression and Likelihood. Springer, New York.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+locfit.raw">locfit.raw</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># fit and plot a univariate local regression
data(ethanol, package="locfit")
fit &lt;- locfit(NOx ~ E, data=ethanol)
plot(fit, get.data=TRUE)

# a bivariate local regression with smaller smoothing parameter
fit &lt;- locfit(NOx~lp(E,C,nn=0.5,scale=0), data=ethanol)
plot(fit)

# density estimation
data(geyser, package="locfit")
fit &lt;- locfit( ~ lp(geyser, nn=0.1, h=0.8))
plot(fit,get.data=TRUE)
</code></pre>

<hr>
<h2 id='locfit.censor'>
Censored Local Regression
</h2><span id='topic+locfit.censor'></span>

<h3>Description</h3>

<p><code>locfit.censor</code> produces local regression estimates for censored
data. The basic idea is to use an EM style algorithm, where one
alternates between estimating the regression and the true values
of censored observations.
</p>
<p><code>locfit.censor</code> is designed as a front end
to <code><a href="#topic+locfit.raw">locfit.raw</a></code> with data vectors, or as an intemediary
between <code><a href="#topic+locfit">locfit</a></code> and <code><a href="#topic+locfit.raw">locfit.raw</a></code> with a
model formula. If you can stand the syntax, the second calling
sequence above will be slightly more efficient than the third.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>locfit.censor(x, y, cens, ..., iter=3, km=FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="locfit.censor_+3A_x">x</code></td>
<td>

<p>Either a <code><a href="#topic+locfit">locfit</a></code> model formula or a numeric vector
of the predictor variable.
</p>
</td></tr>
<tr><td><code id="locfit.censor_+3A_y">y</code></td>
<td>

<p>If <code>x</code> is numeric, <code>y</code> gives the response variable.
</p>
</td></tr>
<tr><td><code id="locfit.censor_+3A_cens">cens</code></td>
<td>

<p>Logical variable indicating censoring. The coding is <code>1</code>
or <code>TRUE</code> for censored; <code>0</code> or <code>FALSE</code> for uncensored.
</p>
</td></tr>
<tr><td><code id="locfit.censor_+3A_...">...</code></td>
<td>

<p>Other arguments to <code><a href="#topic+locfit.raw">locfit.raw</a></code>
</p>
</td></tr>
<tr><td><code id="locfit.censor_+3A_iter">iter</code></td>
<td>
<p>Number of EM iterations to perform</p>
</td></tr>
<tr><td><code id="locfit.censor_+3A_km">km</code></td>
<td>

<p>If <code>km=TRUE</code>, the estimation of censored observations uses
the Kaplan-Meier estimate, leading to a local version of the
Buckley-James estimate. If <code>km=F</code>, the estimation is based
on a normal model (Schmee and Hahn). Beware of claims that B-J
is nonparametric; it makes stronger assumptions on the upper tail
of survival distributions than most authors care to admit.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>locfit</code> object.
</p>


<h3>References</h3>

<p>Buckley, J. and James, I. (1979). Linear Regression with censored data.
Biometrika 66, 429-436.
</p>
<p>Loader, C. (1999). Local Regression and Likelihood. Springer, NY (Section 7.2).
</p>
<p>Schmee, J. and Hahn, G. J. (1979). A simple method for linear regression
analysis with censored data (with discussion). Technometrics 21, 417-434.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+km.mrl">km.mrl</a></code>,
<code><a href="#topic+locfit">locfit</a></code>,
<code><a href="#topic+locfit.raw">locfit.raw</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(heart, package="locfit")
fit &lt;- locfit.censor(log10(surv+0.5) ~ age, cens=cens, data=heart)
## Can also be written as:
## Not run: fit &lt;- locfit(log10(surv + 0.5) ~ age, cens=cens, data=heart, lfproc=locfit.censor)
with(heart, plotbyfactor(age, 0.5 + surv, cens, ylim=c(0.5, 16000), log="y"))
lines(fit, tr=function(x) 10^x)
</code></pre>

<hr>
<h2 id='locfit.matrix'>
Reconstruct a Locfit model matrix.
</h2><span id='topic+locfit.matrix'></span>

<h3>Description</h3>

<p>Reconstructs the model matrix, and associated variables such as
the response, prior weights and censoring indicators, from a
<code>locfit</code> object. This is used by functions such as
<code><a href="#topic+fitted.locfit">fitted.locfit</a></code>; it is not normally called directly.
The function will only work properly if the data frame has not been
changed since the fit was constructed.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>locfit.matrix(fit, data)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="locfit.matrix_+3A_fit">fit</code></td>
<td>
<p>Locfit object</p>
</td></tr>
<tr><td><code id="locfit.matrix_+3A_data">data</code></td>
<td>
<p> Data Frame.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with variables <code>x</code> (the model matrix); <code>y</code> (the response);
<code>w</code> (prior weights); <code>sc</code> (scales); <code>ce</code> (censoring indicator)
and <code>base</code> (baseline fit).
</p>


<h3>See Also</h3>

<p><code><a href="#topic+locfit">locfit</a></code>, <code><a href="#topic+fitted.locfit">fitted.locfit</a></code>, <code><a href="#topic+residuals.locfit">residuals.locfit</a></code>
</p>

<hr>
<h2 id='locfit.quasi'>
Local Quasi-Likelihood with global reweighting.
</h2><span id='topic+locfit.quasi'></span>

<h3>Description</h3>

<p><code>locfit.quasi</code> assumes a specified mean-variance relation,
and performs iterartive reweighted local regression under this
assumption. This is appropriate for local quasi-likelihood models,
and is an alternative to specifying a family such as <code>"qpoisson"</code>.
</p>
<p><code>locfit.quasi</code> is designed as a front end
to <code><a href="#topic+locfit.raw">locfit.raw</a></code> with data vectors, or as an intemediary
between <code><a href="#topic+locfit">locfit</a></code> and <code><a href="#topic+locfit.raw">locfit.raw</a></code> with a
model formula. If you can stand the syntax, the second calling
sequence above will be slightly more efficient than the third.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>locfit.quasi(x, y, weights, ..., iter=3, var=abs)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="locfit.quasi_+3A_x">x</code></td>
<td>

<p>Either a <code><a href="#topic+locfit">locfit</a></code> model formula or a numeric vector
of the predictor variable.
</p>
</td></tr>
<tr><td><code id="locfit.quasi_+3A_y">y</code></td>
<td>

<p>If <code>x</code> is numeric, <code>y</code> gives the response variable.
</p>
</td></tr>
<tr><td><code id="locfit.quasi_+3A_weights">weights</code></td>
<td>
<p>Case weights to use in the fitting.</p>
</td></tr>
<tr><td><code id="locfit.quasi_+3A_...">...</code></td>
<td>

<p>Other arguments to <code><a href="#topic+locfit.raw">locfit.raw</a></code>
</p>
</td></tr>
<tr><td><code id="locfit.quasi_+3A_iter">iter</code></td>
<td>
<p>Number of EM iterations to perform</p>
</td></tr>
<tr><td><code id="locfit.quasi_+3A_var">var</code></td>
<td>

<p>Function specifying the assumed relation between the mean and variance.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>"locfit"</code> object.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+locfit">locfit</a></code>,
<code><a href="#topic+locfit.raw">locfit.raw</a></code>
</p>

<hr>
<h2 id='locfit.raw'>
Local Regression, Likelihood and Density Estimation.
</h2><span id='topic+locfit.raw'></span>

<h3>Description</h3>

<p><code>locfit.raw</code> is an interface to Locfit using numeric vectors
(for a model-formula based interface, use <code><a href="#topic+locfit">locfit</a></code>).
Although this function has a large number of arguments, most users
are likely to need only a small subset.
</p>
<p>The first set of arguments (<code>x</code>, <code>y</code>, <code>weights</code>,
<code>cens</code>, and <code>base</code>) specify the regression
variables and associated quantities.
</p>
<p>Another set (<code>scale</code>, <code>alpha</code>, <code>deg</code>, <code>kern</code>,
<code>kt</code>, <code>acri</code> and <code>basis</code>) control the amount of smoothing:
bandwidth, smoothing weights and the local model. Most of these arguments
are deprecated - they'll currently still work, but should be provided through
the <code>lp()</code> model term instead.
</p>
<p><code>deriv</code> and <code>dc</code> relate to derivative (or local slope)
estimation.
</p>
<p><code>family</code> and <code>link</code> specify the likelihood family.
</p>
<p><code>xlim</code> and <code>renorm</code> may be used in density estimation.
</p>
<p><code>ev</code> specifies the evaluation structure or set of evaluation points.
</p>
<p><code>maxk</code>,  <code>itype</code>, <code>mint</code>, <code>maxit</code> and <code>debug</code>
control the Locfit algorithms, and will be rarely used.
</p>
<p><code>geth</code> and <code>sty</code> are used by other functions calling
<code>locfit.raw</code>, and should not be used directly.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>locfit.raw(x, y, weights=1, cens=0, base=0,
  scale=FALSE, alpha=0.7, deg=2, kern="tricube", kt="sph",
    acri="none", basis=list(NULL),
  deriv=numeric(0), dc=FALSE,
  family, link="default",
  xlim, renorm=FALSE,
  ev=rbox(),
  maxk=100, itype="default", mint=20, maxit=20, debug=0,
  geth=FALSE, sty="none")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="locfit.raw_+3A_x">x</code></td>
<td>

<p>Vector (or matrix) of the independent variable(s). Can be constructed using the
<code>lp()</code> function.
</p>
</td></tr>
<tr><td><code id="locfit.raw_+3A_y">y</code></td>
<td>

<p>Response variable for regression models. For density families,
<code>y</code> can be omitted.
</p>
</td></tr>
<tr><td><code id="locfit.raw_+3A_weights">weights</code></td>
<td>

<p>Prior weights for observations (reciprocal of variance, or sample size).  
</p>
</td></tr>
<tr><td><code id="locfit.raw_+3A_cens">cens</code></td>
<td>

<p>Censoring indicators for hazard rate or censored regression. The coding
is <code>1</code> (or <code>TRUE</code>) for a censored observation, and
<code>0</code> (or <code>FALSE</code>) for uncensored observations.
</p>
</td></tr>
<tr><td><code id="locfit.raw_+3A_base">base</code></td>
<td>

<p>Baseline parameter estimate. If provided, the local regression model is
fitted as <code class="reqn">Y_i = b_i + m(x_i) + \epsilon_i</code>, with Locfit estimating
the <code class="reqn">m(x)</code> term. For regression models, this effectively subtracts
<code class="reqn">b_i</code> from <code class="reqn">Y_i</code>. The advantage of the <code>base</code> formulation
is that it extends to likelihood regression models.
</p>
</td></tr>
<tr><td><code id="locfit.raw_+3A_scale">scale</code></td>
<td>
<p> Deprecated - see <code><a href="#topic+lp">lp</a>()</code>. </p>
</td></tr>
<tr><td><code id="locfit.raw_+3A_alpha">alpha</code></td>
<td>
<p>Deprecated - see <code><a href="#topic+lp">lp</a>()</code>.
A single number (e.g. <code>alpha=0.7</code>)
is interpreted as a nearest neighbor fraction. With two
componentes (e.g. <code>alpha=c(0.7,1.2)</code>), the first component
is a nearest neighbor fraction, and the second component is
a fixed component. A third component is the penalty term in locally
adaptive smoothing.
</p>
</td></tr>
<tr><td><code id="locfit.raw_+3A_deg">deg</code></td>
<td>

<p>Degree of local polynomial. Deprecated - see <code><a href="#topic+lp">lp</a>()</code>.
</p>
</td></tr>
<tr><td><code id="locfit.raw_+3A_kern">kern</code></td>
<td>

<p>Weight function, default = <code>"tcub"</code>.
Other choices are <code>"rect"</code>, <code>"trwt"</code>, <code>"tria"</code>,
<code>"epan"</code>, <code>"bisq"</code> and <code>"gauss"</code>. Choices may be restricted
when derivatives are required; e.g. for confidence bands and some
bandwidth selectors.
</p>
</td></tr>
<tr><td><code id="locfit.raw_+3A_kt">kt</code></td>
<td>

<p>Kernel type, <code>"sph"</code> (default); <code>"prod"</code>.
In multivariate problems, <code>"prod"</code> uses a 
simplified product model which speeds up computations.
</p>
</td></tr>
<tr><td><code id="locfit.raw_+3A_acri">acri</code></td>
<td>
<p>Deprecated - see <code><a href="#topic+lp">lp</a>().</code></p>
</td></tr>
<tr><td><code id="locfit.raw_+3A_basis">basis</code></td>
<td>
<p>User-specified basis functions.</p>
</td></tr> 
<tr><td><code id="locfit.raw_+3A_deriv">deriv</code></td>
<td>

<p>Derivative estimation. If <code>deriv=1</code>, the returned fit will be
estimating the derivative (or more correctly, an estimate of the
local slope). If <code>deriv=c(1,1)</code> the second order derivative
is estimated. <code>deriv=2</code> is for the partial derivative, with
respect to the second variable, in multivariate settings.  </p>
</td></tr>
<tr><td><code id="locfit.raw_+3A_dc">dc</code></td>
<td>
<p> Derivative adjustment.  </p>
</td></tr>
<tr><td><code id="locfit.raw_+3A_family">family</code></td>
<td>

<p>Local likelihood family; <code>"gaussian"</code>; 
<code>"binomial"</code>; <code>"poisson"</code>; <code>"gamma"</code> and <code>"geom"</code>.
Density and rate estimation families are <code>"dens"</code>, <code>"rate"</code> and 
<code>"hazard"</code> (hazard rate). If the family is preceded by a <code>'q'</code>
(for example, <code>family="qbinomial"</code>), quasi-likelihood variance
estimates are used. Otherwise, the residual variance (<code><a href="#topic+rv">rv</a></code>)
is fixed at 1. The default family is <code>"qgauss"</code> if a response
<code>y</code> is provided; <code>"density"</code> if no response is provided.
</p>
</td></tr>
<tr><td><code id="locfit.raw_+3A_link">link</code></td>
<td>

<p>Link function for local likelihood fitting. Depending on the family, 
choices may be <code>"ident"</code>, <code>"log"</code>, <code>"logit"</code>,
<code>"inverse"</code>, <code>"sqrt"</code> and <code>"arcsin"</code>.
</p>
</td></tr>
<tr><td><code id="locfit.raw_+3A_xlim">xlim</code></td>
<td>

<p>For density estimation, Locfit allows the density to be supported on
a bounded interval (or rectangle, in more than one dimension).
The format should be <code>c(ll,ul)</code> where <code>ll</code> is a vector of
the lower bounds and <code>ur</code> the upper bounds. Bounds such as
<code class="reqn">[0,\infty)</code> are not supported, but can be effectively
implemented by specifying a very large upper bound.
</p>
</td></tr>
<tr><td><code id="locfit.raw_+3A_renorm">renorm</code></td>
<td>
<p>Local likelihood density estimates may not integrate
exactly to 1. If <code>renorm=T</code>, the integral will be estimated
numerically and the estimate rescaled. Presently this is implemented
only in one dimension.
</p>
</td></tr>
<tr><td><code id="locfit.raw_+3A_ev">ev</code></td>
<td>

<p>The evaluation structure,
<code><a href="#topic+rbox">rbox</a>()</code> for tree structures;
<code><a href="#topic+lfgrid">lfgrid</a>()</code> for grids;
<code><a href="#topic+dat">dat</a>()</code> for data points;
<code><a href="#topic+none">none</a>()</code> for none.
A vector or matrix of evaluation points can also be provided,
although in this case you may prefer to use the
<code><a href="#topic+smooth.lf">smooth.lf</a>()</code> interface to Locfit.
Note that arguments <code>flim</code>, <code>mg</code> and <code>cut</code> are now
given as arguments to the evaluation structure function, rather
than to <code>locfit.raw()</code> directly (change effective 12/2001).
</p>
</td></tr>
<tr><td><code id="locfit.raw_+3A_maxk">maxk</code></td>
<td>

<p>Controls space assignment for evaluation structures.
For the adaptive evaluation structures, it is impossible to be sure
in advance how many vertices will be generated. If you get
warnings about &lsquo;Insufficient vertex space&rsquo;, Locfit's default assigment
can be increased by increasing <code>maxk</code>. The default is <code>maxk=100</code>.
</p>
</td></tr>
<tr><td><code id="locfit.raw_+3A_itype">itype</code></td>
<td>

<p>Integration type for density estimation. Available methods include
<code>"prod"</code>, <code>"mult"</code> and <code>"mlin"</code>; and <code>"haz"</code> for
hazard rate estimation problems. The available integration methods
depend on model specification (e.g. dimension, degree of fit). By
default, the best available method is used.
</p>
</td></tr>
<tr><td><code id="locfit.raw_+3A_mint">mint</code></td>
<td>

<p>Points for numerical integration rules. Default 20.
</p>
</td></tr>
<tr><td><code id="locfit.raw_+3A_maxit">maxit</code></td>
<td>

<p>Maximum iterations for local likelihood estimation. Default 20.
</p>
</td></tr>
<tr><td><code id="locfit.raw_+3A_debug">debug</code></td>
<td>
<p>If &gt; 0; prints out some debugging information.</p>
</td></tr>
<tr><td><code id="locfit.raw_+3A_geth">geth</code></td>
<td>
<p>Don't use!</p>
</td></tr>
<tr><td><code id="locfit.raw_+3A_sty">sty</code></td>
<td>
<p> Deprecated - see <code><a href="#topic+lp">lp</a>()</code>. </p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object with class &quot;locfit&quot;. A standard set of methods for printing, ploting, etc. these objects is provided.
</p>


<h3>References</h3>

<p>Loader, C., (1999) Local Regression and Likelihood.
</p>

<hr>
<h2 id='locfit.robust'>
Robust Local Regression
</h2><span id='topic+locfit.robust'></span>

<h3>Description</h3>

<p><code>locfit.robust</code> implements a robust local regression where
outliers are iteratively identified and downweighted, similarly
to the lowess method (Cleveland, 1979). The iterations and scale
estimation are performed on a global basis.
</p>
<p>The scale estimate is 6 times the median absolute residual, while
the robust downweighting uses the bisquare function. These are
performed in the S code so easily changed.
</p>
<p>This can be interpreted as an extension of M estimation to local
regression. An alternative extension (implemented in locfit via
<code>family="qrgauss"</code>) performs the iteration and scale estimation
on a local basis.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>locfit.robust(x, y, weights, ..., iter=3)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="locfit.robust_+3A_x">x</code></td>
<td>

<p>Either a <code><a href="#topic+locfit">locfit</a></code> model formula or a numeric vector
of the predictor variable.
</p>
</td></tr>
<tr><td><code id="locfit.robust_+3A_y">y</code></td>
<td>

<p>If <code>x</code> is numeric, <code>y</code> gives the response variable.
</p>
</td></tr>
<tr><td><code id="locfit.robust_+3A_weights">weights</code></td>
<td>
<p>weights to use in the fitting.</p>
</td></tr>
<tr><td><code id="locfit.robust_+3A_...">...</code></td>
<td>
<p>Other arguments to <code><a href="#topic+locfit.raw">locfit.raw</a></code>.</p>
</td></tr>
<tr><td><code id="locfit.robust_+3A_iter">iter</code></td>
<td>
<p>Number of iterations to perform</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>"locfit"</code> object.
</p>


<h3>References</h3>

<p>Cleveland, W. S. (1979).
Robust locally weighted regression and smoothing scatterplots.
J. Amer. Statist. Assn. 74, 829-836.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+locfit">locfit</a></code>,
<code><a href="#topic+locfit.raw">locfit.raw</a></code>
</p>

<hr>
<h2 id='lp'>
Local Polynomial Model Term
</h2><span id='topic+lp'></span>

<h3>Description</h3>

<p><code>lp</code> is a local polynomial model term for Locfit models.
Usually, it will be the only term on the RHS of the model formula.
</p>
<p>Smoothing parameters should be provided as arguments to <code>lp()</code>,
rather than to <code><a href="#topic+locfit">locfit</a>()</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lp(..., nn, h, adpen, deg, acri, scale, style)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="lp_+3A_...">...</code></td>
<td>
<p>Predictor variables for the local regression model.
</p>
</td></tr>
<tr><td><code id="lp_+3A_nn">nn</code></td>
<td>

<p>Nearest neighbor component of the smoothing parameter.
Default value is 0.7, unless either <code>h</code> or <code>adpen</code> are
provided, in which case the default is 0.
</p>
</td></tr>
<tr><td><code id="lp_+3A_h">h</code></td>
<td>

<p>The constant component of the smoothing parameter. Default: 0.
</p>
</td></tr>
<tr><td><code id="lp_+3A_adpen">adpen</code></td>
<td>
<p>Penalty parameter for adaptive fitting.</p>
</td></tr>
<tr><td><code id="lp_+3A_deg">deg</code></td>
<td>
<p>Degree of polynomial to use.</p>
</td></tr>
<tr><td><code id="lp_+3A_acri">acri</code></td>
<td>
<p>Criterion for adaptive bandwidth selection.</p>
</td></tr>
<tr><td><code id="lp_+3A_style">style</code></td>
<td>
<p>Style for special terms (<code><a href="#topic+left">left</a></code>,
<code><a href="#topic+ang">ang</a></code> e.t.c.). Do not try to set this directly;
call <code><a href="#topic+locfit">locfit</a></code> instead. </p>
</td></tr>
<tr><td><code id="lp_+3A_scale">scale</code></td>
<td>

<p>A scale to apply to each variable. This is especially important for
multivariate fitting, where variables may be measured in
non-comparable units. It is also used to specify the frequency
for <code><a href="#topic+ang">ang</a></code> terms. If <code>scale=F</code> (the default) no scaling
is performed. If <code>scale=T</code>, marginal standard deviations are used.
Alternatively, a numeric vector can provide scales for the
individual variables.
</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+locfit">locfit</a></code>,
<code><a href="#topic+locfit.raw">locfit.raw</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(ethanol, package="locfit")
# fit with 50% nearest neighbor bandwidth.
fit &lt;- locfit(NOx~lp(E,nn=0.5),data=ethanol)
# bivariate fit.
fit &lt;- locfit(NOx~lp(E,C,scale=TRUE),data=ethanol)

# density estimation
data(geyser, package="locfit")
fit &lt;- locfit.raw(lp(geyser,nn=0.1,h=0.8))
</code></pre>

<hr>
<h2 id='lscv'>
Least Squares Cross Validation Statistic.
</h2><span id='topic+lscv'></span>

<h3>Description</h3>

<p>The calling sequence for <code>lscv</code> matches those for the
<code><a href="#topic+locfit">locfit</a></code> or <code><a href="#topic+locfit.raw">locfit.raw</a></code> functions.
Note that this function is only designed for density estimation
in one dimension. The returned object contains the
least squares cross validation score for the fit.
</p>
<p>The computation of <code class="reqn">\int \hat f(x)^2 dx</code> is performed numerically.
For kernel density estimation, this is unlikely to agree exactly
with other LSCV routines, which may perform the integration analytically.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lscv(x, ..., exact=FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="lscv_+3A_x">x</code></td>
<td>
<p>model formula (or numeric vector, if <code>exact=T</code>)</p>
</td></tr>
<tr><td><code id="lscv_+3A_...">...</code></td>
<td>
<p>other arguments to <code><a href="#topic+locfit">locfit</a></code> or
<code><a href="#topic+lscv.exact">lscv.exact</a></code> </p>
</td></tr>
<tr><td><code id="lscv_+3A_exact">exact</code></td>
<td>
<p>By default, the computation is approximate.
If <code>exact=TRUE</code>, exact computation using
<code><a href="#topic+lscv.exact">lscv.exact</a></code> is performed. This uses kernel density estimation
with a constant bandwidth.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector consisting of the LSCV statistic and fitted degrees of freedom.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+locfit">locfit</a></code>,
<code><a href="#topic+locfit.raw">locfit.raw</a></code>,
<code><a href="#topic+lscv.exact">lscv.exact</a></code>
<code><a href="#topic+lscvplot">lscvplot</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># approximate calculation for a kernel density estimate
data(geyser, package="locfit")
lscv(~lp(geyser,h=1,deg=0), ev=lfgrid(100,ll=1,ur=6), kern="gauss")
# same computation, exact
lscv(lp(geyser,h=1),exact=TRUE)
</code></pre>

<hr>
<h2 id='lscv.exact'>
Exact LSCV Calculation
</h2><span id='topic+lscv.exact'></span>

<h3>Description</h3>

<p>This function performs the exact computation of the least squares
cross validation statistic for one-dimensional kernel density estimation
and a constant bandwidth.
</p>
<p>At the time of writing, it is implemented only for the Gaussian
kernel (with the standard deviation of 0.4; Locfit's standard).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lscv.exact(x, h=0)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="lscv.exact_+3A_x">x</code></td>
<td>
<p>Numeric data vector.</p>
</td></tr>
<tr><td><code id="lscv.exact_+3A_h">h</code></td>
<td>
<p>The bandwidth. If <code>x</code> is constructed with
<code><a href="#topic+lp">lp</a>()</code>, the bandwidth should be given there instead.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector of the LSCV statistic and the fitted degrees of freedom.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+lscv">lscv</a></code>,
<code><a href="#topic+lscvplot">lscvplot</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(geyser, package="locfit")
lscv.exact(lp(geyser,h=0.25))
# equivalent form using lscv
lscv(lp(geyser, h=0.25), exact=TRUE)
</code></pre>

<hr>
<h2 id='lscvplot'>
Compute the LSCV plot.
</h2><span id='topic+lscvplot'></span>

<h3>Description</h3>

<p>The <code>lscvplot</code> function loops through calls to the <code><a href="#topic+lscv">lscv</a></code>
function (and hence to <code>link{locfit}</code>), using a different
smoothing parameter for each call.
The returned structure contains the LSCV statistic for each density
estimate, and can be used to produce an LSCV plot.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lscvplot(..., alpha)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="lscvplot_+3A_...">...</code></td>
<td>
<p> arguments to the <code><a href="#topic+lscv">lscv</a></code>, <code><a href="#topic+locfit">locfit</a></code>
functions.</p>
</td></tr>
<tr><td><code id="lscvplot_+3A_alpha">alpha</code></td>
<td>
<p> Matrix of smoothing parameters. The <code>lscvplot</code> function
loops through calls to <code><a href="#topic+lscv">lscv</a></code>, using each row of
<code>alpha</code> as the smoothing parameter in turn. If <code>alpha</code>
is provided as a vector, it will be converted to a one-column
matrix, thus interpreting each component as a nearest neighbor
smoothing parameter.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object with class <code>"gcvplot"</code>, containing the smoothing
parameters and LSCV scores. The actual plot is produced using
<code><a href="#topic+plot.gcvplot">plot.gcvplot</a></code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+locfit">locfit</a></code>,
<code><a href="#topic+locfit.raw">locfit.raw</a></code>,
<code><a href="#topic+gcv">gcv</a></code>,
<code><a href="#topic+lscv">lscv</a></code>,
<code><a href="#topic+plot.gcvplot">plot.gcvplot</a></code>
</p>

<hr>
<h2 id='mcyc'>Acc(De?)celeration of a Motorcycle Hitting a Wall</h2><span id='topic+mcyc'></span>

<h3>Description</h3>

<p>Measurements of the acceleration of a motorcycle as it hits a wall.
Actually, rumored to be a concatenation of several such datasets.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(mcyc)</code></pre>


<h3>Format</h3>

<p>Data frame with time and accel variables.
</p>


<h3>Source</h3>

<p>H\&quot;ardle (1990).
</p>


<h3>References</h3>

<p>H\&quot;ardle, W. (1990). Applied Nonparametric Regression.
Cambridge University Press.
</p>

<hr>
<h2 id='mine'>Fracture Counts in Coal Mines</h2><span id='topic+mine'></span>

<h3>Description</h3>

<p>The number of fractures in the upper seam of coal mines, and four
predictor variables. This dataset can be modeled using Poisson regression.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(mine)</code></pre>


<h3>Format</h3>

<p>A dataframe with the response frac, and predictor variables
extrp, time, seamh and inb.
</p>


<h3>Source</h3>

<p>Myers (1990).
</p>


<h3>References</h3>

<p>Myers, R. H. (1990). Classical and Modern Regression with Applications
(Second edition). PWS-Kent Publishing, Boston.
</p>

<hr>
<h2 id='mmsamp'>Test dataset for minimax Local Regression</h2><span id='topic+mmsamp'></span>

<h3>Description</h3>

<p>50 observations, as used in Figure 13.1 of Loader (1999).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(cltest)</code></pre>


<h3>Format</h3>

<p>Data Frame with x and y variables.
</p>


<h3>References</h3>

<p>Loader, C. (1999). Local Regression and Likelihood. Springer, New York.
</p>

<hr>
<h2 id='morths'>Henderson and Sheppard Mortality Dataset</h2><span id='topic+morths'></span>

<h3>Description</h3>

<p>Observed mortality for 55 to 99.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(morths)</code></pre>


<h3>Format</h3>

<p>Data frame with age, n and number of deaths.
</p>


<h3>Source</h3>

<p>Henderson and Sheppard (1919).
</p>


<h3>References</h3>

<p>Henderson, R. and Sheppard, H. N. (1919). Graduation of mortality and
other tables. Actuarial Society of America, New York.
</p>

<hr>
<h2 id='none'>
Locfit Evaluation Structure
</h2><span id='topic+none'></span>

<h3>Description</h3>

<p><code>none()</code> is an evaluation structure for <code><a href="#topic+locfit.raw">locfit.raw</a>()</code>,
specifying no evaluation points. Only the initial parametric fit is
computed - this is the easiest and most efficient way to coerce
Locfit into producing a parametric regression fit.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>none()
</code></pre>


<h3>Examples</h3>

<pre><code class='language-R'>data(ethanol, package="locfit")
# fit a fourth degree polynomial using locfit
fit &lt;- locfit(NOx~E,data=ethanol,deg=4,ev=none())
plot(fit,get.data=TRUE)
</code></pre>

<hr>
<h2 id='panel.locfit'>
Locfit panel function
</h2><span id='topic+panel.locfit'></span>

<h3>Description</h3>

<p>This panel function can be used to add locfit fits to plots generated
by Lattice.
</p>
<p>Currently it works with <code>xyplot</code> for 1-d fits
and crudely with <code>wireframe</code> for 2-d fits.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>panel.locfit(x, y, subscripts, z, rot.mat, distance, shade,
                 light.source, xlim, ylim, zlim, xlim.scaled,
                 ylim.scaled, zlim.scaled, region, col, lty, lwd,
                 alpha, col.groups, polynum, drape, at, xlab, ylab,
                 zlab, xlab.default, ylab.default, zlab.default,
                 aspect, panel.aspect, scales.3d, contour, labels,
                 ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="panel.locfit_+3A_x">x</code>, <code id="panel.locfit_+3A_y">y</code>, <code id="panel.locfit_+3A_subscripts">subscripts</code>, <code id="panel.locfit_+3A_z">z</code></td>
<td>
<p>usual arguments to a <code>panel</code> function</p>
</td></tr>
<tr><td><code id="panel.locfit_+3A_rot.mat">rot.mat</code>, <code id="panel.locfit_+3A_distance">distance</code>, <code id="panel.locfit_+3A_shade">shade</code>, <code id="panel.locfit_+3A_light.source">light.source</code>, <code id="panel.locfit_+3A_xlim">xlim</code>, <code id="panel.locfit_+3A_ylim">ylim</code>, <code id="panel.locfit_+3A_zlim">zlim</code>, <code id="panel.locfit_+3A_xlim.scaled">xlim.scaled</code>, <code id="panel.locfit_+3A_ylim.scaled">ylim.scaled</code>, <code id="panel.locfit_+3A_zlim.scaled">zlim.scaled</code>, <code id="panel.locfit_+3A_region">region</code>, <code id="panel.locfit_+3A_col">col</code>, <code id="panel.locfit_+3A_lty">lty</code>, <code id="panel.locfit_+3A_lwd">lwd</code>, <code id="panel.locfit_+3A_alpha">alpha</code>, <code id="panel.locfit_+3A_col.groups">col.groups</code>, <code id="panel.locfit_+3A_polynum">polynum</code>, <code id="panel.locfit_+3A_drape">drape</code>, <code id="panel.locfit_+3A_at">at</code>, <code id="panel.locfit_+3A_xlab">xlab</code>, <code id="panel.locfit_+3A_ylab">ylab</code>, <code id="panel.locfit_+3A_zlab">zlab</code>, <code id="panel.locfit_+3A_xlab.default">xlab.default</code>, <code id="panel.locfit_+3A_ylab.default">ylab.default</code>, <code id="panel.locfit_+3A_zlab.default">zlab.default</code>, <code id="panel.locfit_+3A_aspect">aspect</code>, <code id="panel.locfit_+3A_panel.aspect">panel.aspect</code>, <code id="panel.locfit_+3A_scales.3d">scales.3d</code>, <code id="panel.locfit_+3A_contour">contour</code>, <code id="panel.locfit_+3A_labels">labels</code></td>
<td>

<p>further arguments passed on to underlying plotting functions</p>
</td></tr>
<tr><td><code id="panel.locfit_+3A_...">...</code></td>
<td>
<p>Most Locfit arguments can be passed through <code>xyplot</code>.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+locfit">locfit</a></code>, <code><a href="#topic+plot.locfit.3d">plot.locfit.3d</a></code>, <code>xyplot</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# a simple multi-panel display
data(ethanol, package="locfit")
xyplot(NOx ~ E | C, data=ethanol, panel=panel.locfit)

# The second example uses some Locfit optional arguments.
# Note we can pass the alpha (bandwidth) and family arguments directly to
# xyplot. The cens argument must be given in full; not as a data frame variable.
# The resulting plot does not (yet) distinguish the censored points, but
# the fit will correctly apply censoring.
data(border, package="locfit")
xyplot(runs ~ day, data=border, panel=panel.locfit, family="poisson",
 alpha=0.3, cens=border$no)

## End(Not run)
</code></pre>

<hr>
<h2 id='panel.xyplot.lf'>
Locfit panel function
</h2><span id='topic+panel.xyplot.lf'></span>

<h3>Description</h3>

<p>Panel function used by <code><a href="#topic+plot.locfit.3d">plot.locfit.3d</a></code> for one dimensional
plots.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>panel.xyplot.lf(x, y, subscripts, clo, cup, wh, type="l", ...)

</code></pre>


<h3>See Also</h3>

<p><code><a href="#topic+plot.locfit.3d">plot.locfit.3d</a></code>
</p>

<hr>
<h2 id='penny'>Penny Thickness Dataset</h2><span id='topic+penny'></span>

<h3>Description</h3>

<p>For each year, 1945 to 1989, the thickness of two U.S. pennies
was recorded.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(penny)</code></pre>


<h3>Format</h3>

<p>A dataframe.
</p>


<h3>Source</h3>

<p>Scott (1992).
</p>


<h3>References</h3>

<p>Scott (1992). Multivariate Density Estimation.
Wiley, New York.
</p>

<hr>
<h2 id='plot.eval'>
Plot evaluation points from a 2-d locfit object.
</h2><span id='topic+plot.eval'></span>

<h3>Description</h3>

<p>This function is used to plot the evaluation structure generated by
Locfit for a two dimensional fit. Vertices of the tree structure are
displayed as <code>O</code>; pseudo-vertices as <code>*</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot.eval(x, add=FALSE, text=FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.eval_+3A_x">x</code></td>
<td>
<p><code>"locfit"</code> object. </p>
</td></tr>
<tr><td><code id="plot.eval_+3A_add">add</code></td>
<td>
<p>If <code>TRUE</code>, add to existing plot.</p>
</td></tr>
<tr><td><code id="plot.eval_+3A_text">text</code></td>
<td>
<p>If <code>TRUE</code>, numbers will be added indicating the order points
were added.</p>
</td></tr>
<tr><td><code id="plot.eval_+3A_...">...</code></td>
<td>
<p>Arguments passed to and from other methods.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+locfit">locfit</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(ethanol, package="locfit")
fit &lt;- locfit(NOx ~ E + C, data=ethanol, scale=0)
plot.eval(fit)
</code></pre>

<hr>
<h2 id='plot.gcvplot'>
Produce a cross-validation plot.
</h2><span id='topic+plot.gcvplot'></span>

<h3>Description</h3>

<p>Plots the value of the GCV (or other statistic) in a <code>gcvplot</code> object
against the degrees of freedom of the fit.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'gcvplot'
plot(x, xlab = "Fitted DF", ylab = x$cri, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.gcvplot_+3A_x">x</code></td>
<td>
<p> A <code>gcvplot</code> object, produced by <code><a href="#topic+gcvplot">gcvplot</a></code>,
<code><a href="#topic+aicplot">aicplot</a></code> etc.</p>
</td></tr>
<tr><td><code id="plot.gcvplot_+3A_xlab">xlab</code></td>
<td>
<p>Text label for the x axis.</p>
</td></tr>
<tr><td><code id="plot.gcvplot_+3A_ylab">ylab</code></td>
<td>
<p>Text label for the y axis.</p>
</td></tr>
<tr><td><code id="plot.gcvplot_+3A_...">...</code></td>
<td>
<p> Other arguments to <code><a href="base.html#topic+plot">plot</a></code> .</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+locfit">locfit</a></code>,
<code><a href="#topic+locfit.raw">locfit.raw</a></code>,
<code><a href="#topic+gcv">gcv</a></code>,
<code><a href="#topic+aicplot">aicplot</a></code>,
<code><a href="#topic+cpplot">cpplot</a></code>,
<code><a href="#topic+gcvplot">gcvplot</a></code>,
<code><a href="#topic+lcvplot">lcvplot</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(ethanol)
plot(gcvplot(NOx~E,data=ethanol,alpha=seq(0.2,1.0,by=0.05)))
</code></pre>

<hr>
<h2 id='plot.lfeval'>
Plot a Locfit Evaluation Structure.
</h2><span id='topic+plot.lfeval'></span>

<h3>Description</h3>

<p>Plots the evaluation points from a <code>locfit</code> or <code>lfeval</code>
structure, for one- or two-dimensional fits.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'lfeval'
plot(x, add=FALSE, txt=FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.lfeval_+3A_x">x</code></td>
<td>
<p>A <code>lfeval</code> or <code>locfit</code> object</p>
</td></tr>
<tr><td><code id="plot.lfeval_+3A_add">add</code></td>
<td>
<p>If <code>TRUE</code>, the points will be added to the existing plot.
Otherwise, a new plot is created.</p>
</td></tr>
<tr><td><code id="plot.lfeval_+3A_txt">txt</code></td>
<td>
<p>If <code>TRUE</code>, the points are annotated with numbers in the
order they were entered into the fit.</p>
</td></tr>
<tr><td><code id="plot.lfeval_+3A_...">...</code></td>
<td>
<p>Additional graphical parameters.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>"lfeval"</code> object.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+lfeval">lfeval</a></code>,
<code><a href="#topic+locfit">locfit</a></code>,
<code><a href="#topic+print.lfeval">print.lfeval</a></code>
</p>

<hr>
<h2 id='plot.locfit'>
Plot an object of class locfit.
</h2><span id='topic+plot.locfit'></span>

<h3>Description</h3>

<p>The <code>plot.locfit</code> function generates grids of ploting points, followed
by a call to <code><a href="#topic+preplot.locfit">preplot.locfit</a></code>. The returned object is then
passed to <code><a href="#topic+plot.locfit.1d">plot.locfit.1d</a></code>, <code><a href="#topic+plot.locfit.2d">plot.locfit.2d</a></code> or
<code><a href="#topic+plot.locfit.3d">plot.locfit.3d</a></code> as appropriate.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'locfit'
plot(x, xlim, pv, tv, m, mtv=6, band="none", tr=NULL,
  what = "coef", get.data=FALSE, f3d=(d == 2) &amp;&amp; (length(tv) &gt; 0), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.locfit_+3A_x">x</code></td>
<td>

<p>locfit object.
</p>
</td></tr>
<tr><td><code id="plot.locfit_+3A_xlim">xlim</code></td>
<td>

<p>Plotting limits. Eg. <code>xlim=c(0,0,1,1)</code> plots over the unit square in
two dimensions. Default is bounding box of the data.
</p>
</td></tr>
<tr><td><code id="plot.locfit_+3A_pv">pv</code></td>
<td>

<p>Panel variables, to be varied within each panel of a plot.  May be
specified as a character vector, or variable numbers.  There must be
one or two panel variables; default is all variables in one or two
dimensions; Variable 1 in three or more dimensions.
May by specified using either variable numbers or names.
</p>
</td></tr>
<tr><td><code id="plot.locfit_+3A_tv">tv</code></td>
<td>

<p>Trellis variables, to be varied from panel to panel of the plot.
</p>
</td></tr>
<tr><td><code id="plot.locfit_+3A_m">m</code></td>
<td>

<p>Controls the plot resolution (within panels, for trellis displays).
Default is 100 points in one dimension; 40 points (per dimension)
in two or more dimensions.
</p>
</td></tr>
<tr><td><code id="plot.locfit_+3A_mtv">mtv</code></td>
<td>

<p>Number of points for trellis variables; default 6.
</p>
</td></tr>
<tr><td><code id="plot.locfit_+3A_band">band</code></td>
<td>

<p>Type of confidence bands to add to the plot. Default is <code>"none"</code>. Other
choices include <code>"global"</code> for bands using a global variance estimate;
<code>"local"</code> for bands using a local variance estimate and <code>"pred"</code>
for prediction bands (at present, using a global variance estimate).
To obtain the global variance estimate for a fit, use <code><a href="#topic+rv">rv</a></code>.
This can be changed with <code><a href="#topic+rv+3C-">rv&lt;-</a></code>. Confidence bands, by default,
are 95%, based on normal approximations and neglecting bias.
To change the critical value or confidence level, or to obtain
simultaneous instead of pointwise confidence,
the critical value stored on the fit must be changed. See the
<code><a href="#topic+kappa0">kappa0</a></code> and <code><a href="#topic+crit">crit</a></code> functions.
</p>
</td></tr>
<tr><td><code id="plot.locfit_+3A_tr">tr</code></td>
<td>

<p>Transformation function to use for plotting. Default is the inverse
link function, or the identity function if derivatives are requested.
</p>
</td></tr>
<tr><td><code id="plot.locfit_+3A_what">what</code></td>
<td>

<p>What to plot. See <code><a href="#topic+predict.locfit">predict.locfit</a></code>.
</p>
</td></tr>
<tr><td><code id="plot.locfit_+3A_get.data">get.data</code></td>
<td>

<p>If <code>TRUE</code>, original data is added to the plot. Default: <code>FALSE</code>.
</p>
</td></tr>
<tr><td><code id="plot.locfit_+3A_f3d">f3d</code></td>
<td>

<p>Force the <code>locfit.3d</code> class on the prediction object, thereby generating
a trellis style plot. Default: <code>FALSE</code>, unless a <code>tv</code> argument is'
provided. Not available in R.
</p>
</td></tr>
<tr><td><code id="plot.locfit_+3A_...">...</code></td>
<td>

<p>Other arguments to <code>plot.locfit.1d</code>, <code>plot.locfit.2d</code> or
<code>plot.locfit.3d</code> as appropriate.
</p>
</td></tr></table>


<h3>See Also</h3>

<p><code><a href="#topic+locfit">locfit</a></code>, <code><a href="#topic+plot.locfit.1d">plot.locfit.1d</a></code>,
<code><a href="#topic+plot.locfit.2d">plot.locfit.2d</a></code>, <code><a href="#topic+plot.locfit.3d">plot.locfit.3d</a></code>,
<code><a href="#topic+lines.locfit">lines.locfit</a></code>, <code><a href="#topic+predict.locfit">predict.locfit</a></code>,
<code><a href="#topic+preplot.locfit">preplot.locfit</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- rnorm(100)
y &lt;- dnorm(x) + rnorm(100) / 5
plot(locfit(y~x), band="global")
x &lt;- cbind(rnorm(100), rnorm(100))
plot(locfit(~x), type="persp")
</code></pre>

<hr>
<h2 id='plot.locfit.1d'>
Plot a one dimensional preplot.locfit object.
</h2><span id='topic+plot.locfit.1d'></span>

<h3>Description</h3>

<p>This function is not usually called directly. It will be called automatically
when plotting a one-dimensional <code>locfit</code> or <code>preplot.locfit</code>
object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'locfit.1d'
plot(x, add=FALSE, main="", xlab="default", ylab=x$yname,
  type="l", ylim, lty=1, col=1, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.locfit.1d_+3A_x">x</code></td>
<td>
<p>One dimensional <code>preplot.locfit</code> object.</p>
</td></tr>
<tr><td><code id="plot.locfit.1d_+3A_add">add</code></td>
<td>
<p>If <code>TRUE</code>, the plot will be added to the existing
plot.</p>
</td></tr>
<tr><td><code id="plot.locfit.1d_+3A_main">main</code>, <code id="plot.locfit.1d_+3A_xlab">xlab</code>, <code id="plot.locfit.1d_+3A_ylab">ylab</code>, <code id="plot.locfit.1d_+3A_type">type</code>, <code id="plot.locfit.1d_+3A_ylim">ylim</code>, <code id="plot.locfit.1d_+3A_lty">lty</code>, <code id="plot.locfit.1d_+3A_col">col</code></td>
<td>
<p>Graphical parameters
passed on to <code><a href="base.html#topic+plot">plot</a></code> (only if <code>add=FALSE</code>).</p>
</td></tr>
<tr><td><code id="plot.locfit.1d_+3A_...">...</code></td>
<td>
<p>Additional graphical parameters to the <code>plot</code> function
(only if <code>add=FALSE</code>).</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+locfit">locfit</a></code>, <code><a href="#topic+plot.locfit">plot.locfit</a></code>, <code><a href="#topic+preplot.locfit">preplot.locfit</a></code>
</p>

<hr>
<h2 id='plot.locfit.2d'>
Plot a two-dimensional &quot;preplot.locfit&quot; object.
</h2><span id='topic+plot.locfit.2d'></span>

<h3>Description</h3>

<p>This function is not usually called directly. It will be called automatically
when plotting one-dimensional <code>locfit</code> or <code>preplot.locfit</code>
objects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'locfit.2d'
plot(x, type="contour", main, xlab, ylab, zlab=x$yname, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.locfit.2d_+3A_x">x</code></td>
<td>
<p>Two dimensional <code>preplot.locfit</code> object.</p>
</td></tr>
<tr><td><code id="plot.locfit.2d_+3A_type">type</code></td>
<td>
<p>one of <code>"contour"</code>, <code>"persp"</code>, or <code>"image"</code>.</p>
</td></tr>
<tr><td><code id="plot.locfit.2d_+3A_main">main</code></td>
<td>
<p>title for the plot.</p>
</td></tr>
<tr><td><code id="plot.locfit.2d_+3A_xlab">xlab</code>, <code id="plot.locfit.2d_+3A_ylab">ylab</code></td>
<td>
<p>text labels for the x- and y-axes.</p>
</td></tr>
<tr><td><code id="plot.locfit.2d_+3A_zlab">zlab</code></td>
<td>
<p>if <code>type="persp"</code>, the label for the z-axis.</p>
</td></tr>
<tr><td><code id="plot.locfit.2d_+3A_...">...</code></td>
<td>
<p>Additional arguments to the <code>contour</code>, <code>persp</code> or
<code>image</code> functions.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+locfit">locfit</a></code>, <code><a href="#topic+plot.locfit">plot.locfit</a></code>, <code><a href="#topic+preplot.locfit">preplot.locfit</a></code>
</p>

<hr>
<h2 id='plot.locfit.3d'>
Plot a high-dimensional &quot;preplot.locfit&quot; object using trellis displays.
</h2><span id='topic+plot.locfit.3d'></span>

<h3>Description</h3>

<p>This function plots cross-sections of a Locfit model (usually in three
or more dimensions) using trellis displays. It is not usually called
directly, but is invoked by <code><a href="#topic+plot.locfit">plot.locfit</a></code>.
</p>
<p>The R libraries <code>lattice</code> and <code>grid</code> provide a partial
(at time of writing) implementation of trellis. Currently, this works
with one panel variable.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'locfit.3d'
plot(x, main="", pv, tv, type = "level", pred.lab = x$vnames,
               resp.lab=x$yname, crit = 1.96, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.locfit.3d_+3A_x">x</code></td>
<td>
<p><code>"preplot.locfit"</code> object.</p>
</td></tr>
<tr><td><code id="plot.locfit.3d_+3A_main">main</code></td>
<td>
<p>title for the plot.</p>
</td></tr>
<tr><td><code id="plot.locfit.3d_+3A_pv">pv</code></td>
<td>
<p>Panel variables. These are the variables (either one or two)
that are varied within each panel of the display.</p>
</td></tr>
<tr><td><code id="plot.locfit.3d_+3A_tv">tv</code></td>
<td>
<p>Trellis variables. These are varied from panel to panel
of the display.</p>
</td></tr>
<tr><td><code id="plot.locfit.3d_+3A_type">type</code></td>
<td>
<p>Type of display. When there are two panel variables,
the choices are <code>"contour"</code>, <code>"level"</code> and
<code>"persp"</code>.</p>
</td></tr>
<tr><td><code id="plot.locfit.3d_+3A_pred.lab">pred.lab</code></td>
<td>
<p>label for the predictor variable.</p>
</td></tr>
<tr><td><code id="plot.locfit.3d_+3A_resp.lab">resp.lab</code></td>
<td>
<p>label for the response variable.</p>
</td></tr>
<tr><td><code id="plot.locfit.3d_+3A_crit">crit</code></td>
<td>
<p>critical value for the confidence level.</p>
</td></tr>
<tr><td><code id="plot.locfit.3d_+3A_...">...</code></td>
<td>
<p>graphical parameters passed to <code>xyplot</code> or
<code>contourplot</code>.</p>
</td></tr> 
</table>


<h3>See Also</h3>

<p><code>plot.locfit</code>,
<code>preplot.locfit</code>
</p>

<hr>
<h2 id='plot.preplot.locfit'>
Plot a &quot;preplot.locfit&quot; object.
</h2><span id='topic+plot.preplot.locfit'></span>

<h3>Description</h3>

<p>The <code><a href="#topic+plot.locfit">plot.locfit</a>()</code> function is implemented, roughly, as
a call to <code><a href="#topic+preplot.locfit">preplot.locfit</a>()</code>, followed by a call to
<code>plot.locfitpred()</code>. For most users, there will be little
need to call <code>plot.locfitpred()</code> directly.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'preplot.locfit'
plot(x, pv, tv, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.preplot.locfit_+3A_x">x</code></td>
<td>
<p>A <code>preplot.locfit</code> object, produced by
<code><a href="#topic+preplot.locfit">preplot.locfit</a>()</code>.
</p>
</td></tr>
<tr><td><code id="plot.preplot.locfit_+3A_pv">pv</code>, <code id="plot.preplot.locfit_+3A_tv">tv</code>, <code id="plot.preplot.locfit_+3A_...">...</code></td>
<td>

<p>Other arguments to <code>plot.locfit.1d</code>, <code>plot.locfit.2d</code> or
<code>plot.locfit.3d</code> as appropriate.
</p>
</td></tr></table>


<h3>See Also</h3>

<p><code><a href="#topic+locfit">locfit</a></code>, <code><a href="#topic+plot.locfit">plot.locfit</a></code>,
<code><a href="#topic+preplot.locfit">preplot.locfit</a></code>, <code><a href="#topic+plot.locfit.1d">plot.locfit.1d</a></code>,
<code><a href="#topic+plot.locfit.2d">plot.locfit.2d</a></code>, <code><a href="#topic+plot.locfit.3d">plot.locfit.3d</a></code>.
</p>

<hr>
<h2 id='plot.scb'>
Plot method for simultaneous confidence bands
</h2><span id='topic+plot.scb'></span><span id='topic+plot.scb.1d'></span><span id='topic+plot.scb.2d'></span>

<h3>Description</h3>

<p>Plot method for simultaneous confidence bands created by the
<code><a href="#topic+scb">scb</a></code> function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'scb'
plot(x, add=FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.scb_+3A_x">x</code></td>
<td>
 <p><code>scb</code> object created by <code><a href="#topic+scb">scb</a></code>.  </p>
</td></tr>
<tr><td><code id="plot.scb_+3A_add">add</code></td>
<td>
<p>If <code>TRUE</code>, bands will be added to the existing plot.</p>
</td></tr>
<tr><td><code id="plot.scb_+3A_...">...</code></td>
<td>
<p>Arguments passed to and from other methods.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+scb">scb</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># corrected confidence bands for a linear logistic model
data(insect)
fit &lt;- scb(deaths ~ lconc, type=4, w=nins, data=insect,
           deg=1, family="binomial", kern="parm")
plot(fit)
</code></pre>

<hr>
<h2 id='plotbyfactor'>
x-y scatterplot, colored by levels of a factor.
</h2><span id='topic+plotbyfactor'></span>

<h3>Description</h3>

<p>Produces a scatter plot of x-y data, with different classes given
by a factor f. The different classes are identified by different
colours and/or symbols.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plotbyfactor(x, y, f, data, col = 1:10, pch = "O", add = FALSE, lg,
    xlab = deparse(substitute(x)), ylab = deparse(substitute(y)),
    log = "", ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plotbyfactor_+3A_x">x</code></td>
<td>

<p>Variable for x axis.
</p>
</td></tr>
<tr><td><code id="plotbyfactor_+3A_y">y</code></td>
<td>

<p>Variable for y axis.
</p>
</td></tr>
<tr><td><code id="plotbyfactor_+3A_f">f</code></td>
<td>

<p>Factor (or variable for which as.factor() works).
</p>
</td></tr>
<tr><td><code id="plotbyfactor_+3A_data">data</code></td>
<td>

<p>data frame for variables x, y, f. Default: sys.parent().
</p>
</td></tr>
<tr><td><code id="plotbyfactor_+3A_col">col</code></td>
<td>

<p>Color numbers to use in plot. Will be replicated if shorter than the
number of levels of the factor f. Default: 1:10.
</p>
</td></tr>
<tr><td><code id="plotbyfactor_+3A_pch">pch</code></td>
<td>

<p>Vector of plot characters. Replicated if necessary.
Default: &quot;O&quot;.
</p>
</td></tr>
<tr><td><code id="plotbyfactor_+3A_add">add</code></td>
<td>

<p>If <code>TRUE</code>, add to existing plot. Otherwise, create new plot.
</p>
</td></tr>
<tr><td><code id="plotbyfactor_+3A_lg">lg</code></td>
<td>

<p>Coordinates to place a legend. Default: Missing (no legend).
</p>
</td></tr>
<tr><td><code id="plotbyfactor_+3A_xlab">xlab</code>, <code id="plotbyfactor_+3A_ylab">ylab</code></td>
<td>
<p>Axes labels.</p>
</td></tr>
<tr><td><code id="plotbyfactor_+3A_log">log</code></td>
<td>
<p>Should the axes be in log scale? Use <code>"x"</code>, <code>"y"</code>,
or <code>"xy"</code> to specify which axis to be in log scale.</p>
</td></tr>
<tr><td><code id="plotbyfactor_+3A_...">...</code></td>
<td>

<p>Other graphical parameters, labels, titles e.t.c.
</p>
</td></tr></table>


<h3>Examples</h3>

<pre><code class='language-R'>data(iris)
plotbyfactor(petal.wid, petal.len, species, data=iris)
</code></pre>

<hr>
<h2 id='points.locfit'>
Add &lsquo;locfit&rsquo; points to existing plot
</h2><span id='topic+points.locfit'></span>

<h3>Description</h3>

<p>This function shows the points at which the local fit
was computed directly, rather than being interpolated. This can
be useful if one is unsure of the validity of interpolation.</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'locfit'
points(x, tr, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="points.locfit_+3A_x">x</code></td>
<td>

<p><code>"locfit"</code> object. Should be a model with one predictor.
</p>
</td></tr>
<tr><td><code id="points.locfit_+3A_tr">tr</code></td>
<td>

<p>Back transformation.
</p>
</td></tr>
<tr><td><code id="points.locfit_+3A_...">...</code></td>
<td>

<p>Other arguments to the default <code><a href="graphics.html#topic+points">points</a></code> function.
</p>
</td></tr></table>


<h3>See Also</h3>

<p><code><a href="#topic+locfit">locfit</a></code>, <code><a href="#topic+plot.locfit">plot.locfit</a></code>, <code><a href="graphics.html#topic+points">points</a></code>
</p>

<hr>
<h2 id='predict.locfit'>
Prediction from a Locfit object.
</h2><span id='topic+predict.locfit'></span>

<h3>Description</h3>

<p>The <code><a href="#topic+locfit">locfit</a></code> function computes a local fit at a selected set
of points (as defined by the <code>ev</code> argument). The <code>predict.locfit</code>
function is used to interpolate from these points to any other points.
The method is based on cubic hermite polynomial interpolation, using the
estimates and local slopes at each fit point.
</p>
<p>The motivation for this two-step procedure is computational speed.
Depending on the sample size, dimension and fitting procedure, the
local fitting method can be expensive, and it is desirable to keep the
number of points at which the direct fit is computed to a minimum.
The interpolation method used by <code>predict.locfit()</code> is usually
much faster, and can be computed at larger numbers of points.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'locfit'
predict(object, newdata=NULL, where = "fitp",
          se.fit=FALSE, band="none", what="coef", ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="predict.locfit_+3A_object">object</code></td>
<td>
<p>Fitted object from <code><a href="#topic+locfit">locfit</a>()</code>.</p>
</td></tr>
<tr><td><code id="predict.locfit_+3A_newdata">newdata</code></td>
<td>
<p>Points to predict at. Can be given in several forms:
vector/matrix; list, data frame.</p>
</td></tr>
<tr><td><code id="predict.locfit_+3A_se.fit">se.fit</code></td>
<td>
<p>If <code>TRUE</code>, standard errors are computed along with
the fitted values.</p>
</td></tr>
<tr><td><code id="predict.locfit_+3A_where">where</code>, <code id="predict.locfit_+3A_what">what</code>, <code id="predict.locfit_+3A_band">band</code></td>
<td>
<p>arguments passed on to
<code><a href="#topic+preplot.locfit">preplot.locfit</a></code>.</p>
</td></tr> 
<tr><td><code id="predict.locfit_+3A_...">...</code></td>
<td>
<p>Additional arguments to <code><a href="#topic+preplot.locfit">preplot.locfit</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>If <code>se.fit=F</code>, a numeric vector of predictors.
If <code>se.fit=T</code>, a list with components <code>fit</code>, <code>se.fit</code> and
<code>residual.scale</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(ethanol, package="locfit")
fit &lt;- locfit(NOx ~ E, data=ethanol)
predict(fit,c(0.6,0.8,1.0))
</code></pre>

<hr>
<h2 id='preplot.locfit'>
Prediction from a Locfit object.
</h2><span id='topic+preplot.locfit'></span>

<h3>Description</h3>

<p><code>preplot.locfit</code> can be called directly, although it is more usual
to call <code><a href="#topic+plot.locfit">plot.locfit</a></code> or <code><a href="#topic+predict.locfit">predict.locfit</a></code>.
The advantage of <code>preplot.locfit</code> is in S-Plus 5, where arithmetic
and transformations can be performed on the <code>"preplot.locfit"</code>
object.
</p>
<p><code>plot(preplot(fit))</code> is essentially synonymous with <code>plot(fit)</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'locfit'
preplot(object, newdata=NULL, where, tr=NULL, what="coef",
  band="none", get.data=FALSE, f3d=FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="preplot.locfit_+3A_object">object</code></td>
<td>
<p>Fitted object from <code><a href="#topic+locfit">locfit</a>()</code>.</p>
</td></tr>
<tr><td><code id="preplot.locfit_+3A_newdata">newdata</code></td>
<td>
<p>Points to predict at. Can be given in several forms:
vector/matrix; list, data frame.</p>
</td></tr>
<tr><td><code id="preplot.locfit_+3A_where">where</code></td>
<td>
<p>An alternative to <code>newdata</code>. Choices include
<code>"grid"</code> for the grid <code><a href="#topic+lfmarg">lfmarg</a>(object)</code>;
<code>"data"</code> for the original data points and <code>"fitp"</code> for the
direct fitting points (ie. no interpolation).</p>
</td></tr>
<tr><td><code id="preplot.locfit_+3A_tr">tr</code></td>
<td>
<p>Transformation for likelihood models. Default is the inverse
of the link function.</p>
</td></tr>
<tr><td><code id="preplot.locfit_+3A_what">what</code></td>
<td>
<p>What to compute predicted values of. The default,
<code>what="coef"</code>, works with the fitted curve itself. Other
choices include <code>"nlx"</code> for the length of the weight diagram;
<code>"infl"</code> for the influence function; <code>"band"</code> for the
bandwidth; <code>"degr"</code> for the local polynomial degree;
<code>"lik"</code> for the maximized local likelihood; <code>"rdf"</code> for
the local residual degrees of freedom and <code>"vari"</code> for the
variance function. The interpolation algorithm for some of these
quantities is questionable.</p>
</td></tr>
<tr><td><code id="preplot.locfit_+3A_band">band</code></td>
<td>
<p>Compute standard errors for the fit and include confidence
bands on the returned object. Default is <code>"none"</code>. Other
choices include <code>"global"</code> for bands using a global variance
estimate; <code>"local"</code> for bands using a local variance estimate
and <code>"pred"</code> for prediction bands (at present, using a global
variance estimate).  To obtain the global variance estimate for a
fit, use <code><a href="#topic+rv">rv</a></code>.  This can be changed with
<code><a href="#topic+rv+3C-">rv&lt;-</a></code>. Confidence bands, by default, are 95%, based on
normal approximations and neglecting bias.  To change the critical
value or confidence level, or to obtain simultaneous instead of
pointwise confidence, the critical value stored on the fit must be
changed. See the <code><a href="#topic+kappa0">kappa0</a></code> and <code><a href="#topic+crit">crit</a></code>
functions.</p>
</td></tr>
<tr><td><code id="preplot.locfit_+3A_get.data">get.data</code></td>
<td>
<p>If <code>TRUE</code>, the original data is attached to the
returned object, and added to the plot.</p>
</td></tr>
<tr><td><code id="preplot.locfit_+3A_f3d">f3d</code></td>
<td>
<p>If <code>TRUE</code>, sets a flag that forces ploting using the
trellis style.  Not available in R.</p>
</td></tr>
<tr><td><code id="preplot.locfit_+3A_...">...</code></td>
<td>
<p>arguments passed to and from other methods.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object with class <code>"preplot.locfit"</code>, containing the predicted
values and additional information used to construct the plot.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+locfit">locfit</a></code>, <code><a href="#topic+predict.locfit">predict.locfit</a></code>, <code><a href="#topic+plot.locfit">plot.locfit</a></code>.
</p>

<hr>
<h2 id='preplot.locfit.raw'>
Prediction from a Locfit object.
</h2><span id='topic+preplot.locfit.raw'></span>

<h3>Description</h3>

<p><code>preplot.locfit.raw</code> is an internal function used by
<code><a href="#topic+predict.locfit">predict.locfit</a></code> and <code><a href="#topic+preplot.locfit">preplot.locfit</a></code>.
It should not normally be called directly.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'locfit.raw'
preplot(object, newdata, where, what, band, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="preplot.locfit.raw_+3A_object">object</code></td>
<td>

<p>Fitted object from <code><a href="#topic+locfit">locfit</a>()</code>.
</p>
</td></tr>
<tr><td><code id="preplot.locfit.raw_+3A_newdata">newdata</code></td>
<td>

<p>New data points.
</p>
</td></tr>
<tr><td><code id="preplot.locfit.raw_+3A_where">where</code></td>
<td>

<p>Type of data provided in <code>newdata</code>.
</p>
</td></tr>
<tr><td><code id="preplot.locfit.raw_+3A_what">what</code></td>
<td>

<p>What to compute predicted values of.
</p>
</td></tr>
<tr><td><code id="preplot.locfit.raw_+3A_band">band</code></td>
<td>

<p>Compute standard errors for the fit and include confidence bands on
the returned object.</p>
</td></tr>
<tr><td><code id="preplot.locfit.raw_+3A_...">...</code></td>
<td>
<p>Arguments passed to and from other methods.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list containing raw output from the internal prediction routines.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+locfit">locfit</a></code>, <code><a href="#topic+predict.locfit">predict.locfit</a></code>, <code><a href="#topic+preplot.locfit">preplot.locfit</a></code>.
</p>

<hr>
<h2 id='print.gcvplot'>
Print method for gcvplot objects
</h2><span id='topic+print.gcvplot'></span>

<h3>Description</h3>

<p>Print method for <code>"gcvplot"</code> objects. Actually, equivalent to
<code><a href="#topic+plot.gcvplot">plot.gcvplot</a>()</code>.
<code><a href="#topic+scb">scb</a></code> function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'gcvplot'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.gcvplot_+3A_x">x</code></td>
<td>
 <p><code>gcvplot</code> object.  </p>
</td></tr>
<tr><td><code id="print.gcvplot_+3A_...">...</code></td>
<td>
<p>Arguments passed to and from other methods.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+gcvplot">gcvplot</a></code>,
<code><a href="#topic+plot.gcvplot">plot.gcvplot</a></code>
<code><a href="#topic+summary.gcvplot">summary.gcvplot</a></code>
</p>

<hr>
<h2 id='print.lfeval'>
Print the Locfit Evaluation Points.
</h2><span id='topic+print.lfeval'></span>

<h3>Description</h3>

<p>Prints a matrix of the evaluation points from a <code>locfit</code>
or <code>lfeval</code> structure.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'lfeval'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.lfeval_+3A_x">x</code></td>
<td>
<p>A <code>lfeval</code> or <code>locfit</code> object</p>
</td></tr>
<tr><td><code id="print.lfeval_+3A_...">...</code></td>
<td>
<p>Arguments passed to and from other methods.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Matrix of the fit points.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+lfeval">lfeval</a></code>,
<code><a href="#topic+locfit">locfit</a></code>,
<code><a href="#topic+plot.lfeval">plot.lfeval</a></code>
</p>

<hr>
<h2 id='print.locfit'>
Print method for &quot;locfit&quot; object.
</h2><span id='topic+print.locfit'></span>

<h3>Description</h3>

<p>Prints a short summary of a <code>"locfit"</code> object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'locfit'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.locfit_+3A_x">x</code></td>
<td>
<p><code>locfit</code> object.</p>
</td></tr>
<tr><td><code id="print.locfit_+3A_...">...</code></td>
<td>
<p>Arguments passed to and from other methods.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+locfit">locfit</a></code></p>

<hr>
<h2 id='print.preplot.locfit'>
Print method for preplot.locfit objects.
</h2><span id='topic+print.preplot.locfit'></span>

<h3>Description</h3>

<p>Print method for objects created by the
<code><a href="#topic+preplot.locfit">preplot.locfit</a></code> function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'preplot.locfit'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.preplot.locfit_+3A_x">x</code></td>
<td>
 <p><code>"preplot.locfit"</code> object.  </p>
</td></tr>
<tr><td><code id="print.preplot.locfit_+3A_...">...</code></td>
<td>
<p>Arguments passed to and from other methods.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+preplot.locfit">preplot.locfit</a></code>,
<code><a href="#topic+predict.locfit">predict.locfit</a></code>
</p>

<hr>
<h2 id='print.scb'>
Print method for simultaneous confidence bands
</h2><span id='topic+print.scb'></span>

<h3>Description</h3>

<p>Print method for simultaneous confidence bands created by the
<code><a href="#topic+scb">scb</a></code> function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'scb'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.scb_+3A_x">x</code></td>
<td>
 <p><code>"scb"</code> object created by <code><a href="#topic+scb">scb</a></code>.</p>
</td></tr>
<tr><td><code id="print.scb_+3A_...">...</code></td>
<td>
<p>Arguments passed to and from other methods.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+scb">scb</a></code>
</p>

<hr>
<h2 id='print.summary.locfit'>
Print a Locfit summary object.
</h2><span id='topic+print.summary.locfit'></span>

<h3>Description</h3>

<p>Print method for <code>"summary.locfit"</code> objects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'summary.locfit'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.summary.locfit_+3A_x">x</code></td>
<td>
<p>Object from <code><a href="#topic+summary.locfit">summary.locfit</a></code>.</p>
</td></tr>
<tr><td><code id="print.summary.locfit_+3A_...">...</code></td>
<td>
<p>Arguments passed to and from methods.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+summary.locfit">summary.locfit</a>()</code>
</p>

<hr>
<h2 id='rbox'>
Local Regression, Likelihood and Density Estimation.
</h2><span id='topic+rbox'></span>

<h3>Description</h3>

<p><code>rbox()</code> is used to specify a rectangular box evaluation
structure for <code><a href="#topic+locfit.raw">locfit.raw</a>()</code>. The structure begins
by generating a bounding box for the data, then recursively divides
the box to a desired precision.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rbox(cut=0.8, type="tree", ll, ur)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rbox_+3A_type">type</code></td>
<td>

<p>If <code>type="tree"</code>, the cells are recursively divided according to
the bandwidths at each corner of the cell; see Chapter 11 of Loader (1999).
If <code>type="kdtree"</code>, the K-D tree structure used in Loess
(Cleveland and Grosse, 1991) is used.
</p>
</td></tr>
<tr><td><code id="rbox_+3A_cut">cut</code></td>
<td>

<p>Precision of the tree; a smaller value of <code>cut</code> results in a
larger tree with more nodes being generated.
</p>
</td></tr>
<tr><td><code id="rbox_+3A_ll">ll</code></td>
<td>

<p>Lower left corner of the initial cell. Length should be the number
of dimensions of the data provided to <code><a href="#topic+locfit.raw">locfit.raw</a>()</code>.
</p>
</td></tr>
<tr><td><code id="rbox_+3A_ur">ur</code></td>
<td>

<p>Upper right corner of the initial cell. By default, <code>ll</code> and
<code>ur</code> are generated as the bounding box for the data.
</p>
</td></tr>
</table>


<h3>References</h3>

<p>Loader, C. (1999). Local Regression and Likelihood. Springer, New York.
</p>
<p>Cleveland, W. and Grosse, E. (1991). Computational Methods for Local
Regression. Statistics and Computing 1.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(ethanol, package="locfit")
plot.eval(locfit(NOx~E+C,data=ethanol,scale=0,ev=rbox(cut=0.8)))
plot.eval(locfit(NOx~E+C,data=ethanol,scale=0,ev=rbox(cut=0.3)))
</code></pre>

<hr>
<h2 id='regband'>
Bandwidth selectors for local regression.
</h2><span id='topic+regband'></span>

<h3>Description</h3>

<p>Function to compute local regression bandwidths for local linear regression,
implemented as a front end to <code><a href="#topic+locfit">locfit</a>()</code>.
</p>
<p>This function is included for comparative purposes only. Plug-in
selectors are based on flawed logic, make unreasonable and restrictive
assumptions
and do not use the full power of the estimates available in Locfit.
Any relation between the results produced by this function and
desirable estimates are entirely coincidental.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>regband(formula, what = c("CP", "GCV", "GKK", "RSW"), deg=1, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="regband_+3A_formula">formula</code></td>
<td>
<p>Model Formula (one predictor).</p>
</td></tr>
<tr><td><code id="regband_+3A_what">what</code></td>
<td>
<p>Methods to use.</p>
</td></tr>
<tr><td><code id="regband_+3A_deg">deg</code></td>
<td>
<p>Degree of fit.</p>
</td></tr>
<tr><td><code id="regband_+3A_...">...</code></td>
<td>
<p>Other Locfit options.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Vector of selected bandwidths.
</p>

<hr>
<h2 id='residuals.locfit'>
Fitted values and residuals for a Locfit object.
</h2><span id='topic+residuals.locfit'></span>

<h3>Description</h3>

<p><code>residuals.locfit</code> is implemented as a front-end to
<code><a href="#topic+fitted.locfit">fitted.locfit</a></code>, with the <code>type</code> argument set.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'locfit'
residuals(object, data=NULL, type="deviance", ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="residuals.locfit_+3A_object">object</code></td>
<td>
<p><code>locfit</code> object.</p>
</td></tr>
<tr><td><code id="residuals.locfit_+3A_data">data</code></td>
<td>
<p>The data frame for the original fit. Usually, shouldn't be
needed.</p>
</td></tr>
<tr><td><code id="residuals.locfit_+3A_type">type</code></td>
<td>
<p>Type of fit or residuals to compute. The default is
<code>"fit"</code> for <code>fitted.locfit</code>, and <code>"dev"</code> for
<code><a href="#topic+residuals.locfit">residuals.locfit</a></code>.  Other choices include <code>"pear"</code>
for Pearson residuals; <code>"raw"</code> for raw residuals, <code>"ldot"</code>
for likelihood derivative; <code>"d2"</code> for the deviance residual
squared; <code>lddot</code> for the likelihood second derivative.
Generally, <code>type</code> should only be used when <code>what="coef"</code>.</p>
</td></tr>
<tr><td><code id="residuals.locfit_+3A_...">...</code></td>
<td>
<p>arguments passed to and from other methods.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A numeric vector of the residuals.
</p>

<hr>
<h2 id='right'>
One-sided right smooth for a Locfit model.
</h2><span id='topic+right'></span>

<h3>Description</h3>

<p>The <code>right()</code> function is used in a locfit model formula
to specify a one-sided smooth: when fitting at a point <code class="reqn">x</code>,
only data points with <code class="reqn">x_i \le x</code> should be used.
This can be useful in estimating points of discontinuity,
and in cross-validation for forecasting a time series.
<code>right(x)</code> is equivalent to <code>lp(x,style="right")</code>.
</p>
<p>When using this function, it will usually be necessary to specify an
evaluation structure, since the fit is not smooth and locfit's
interpolation methods are unreliable. Also, it is usually best
to use <code>deg=0</code> or <code>deg=1</code>, otherwise the fits may be too
variable. If nearest neighbor bandwidth specification is used,
it does not recognize <code>right()</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>right(x,...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="right_+3A_x">x</code></td>
<td>
<p>numeric variable.</p>
</td></tr>
<tr><td><code id="right_+3A_...">...</code></td>
<td>
<p>Other arguments to <code><a href="#topic+lp">lp</a>()</code>.</p>
</td></tr>
</table>


<h3>See Also</h3>


<p><code><a href="#topic+locfit">locfit</a></code>,
<code><a href="#topic+left">left</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># compute left and right smooths
data(penny)
xev &lt;- (1945:1988)+0.5
fitl &lt;- locfit(thickness~left(year,h=10,deg=1), ev=xev, data=penny)
fitr &lt;- locfit(thickness~right(year, h=10, deg=1), ev=xev, data=penny)
# plot the squared difference, to show the change points.
plot( xev, (predict(fitr, where="ev") - predict(fitl, where="ev"))^2 )
</code></pre>

<hr>
<h2 id='rv'>
Residual variance from a locfit object.
</h2><span id='topic+rv'></span>

<h3>Description</h3>

<p>As part of the <code><a href="#topic+locfit">locfit</a></code> fitting procedure, an estimate
of the residual variance is computed; the <code>rv</code> function extracts
the variance from the <code>"locfit"</code> object.
The estimate used is the residual sum of squares
(or residual deviance, for quasi-likelihood models),
divided by the residual degrees of freedom.
</p>
<p>For likelihood (not quasi-likelihood) models, the estimate is 1.0.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rv(fit)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rv_+3A_fit">fit</code></td>
<td>

<p><code>"locfit"</code> object.
</p>
</td></tr></table>


<h3>Value</h3>

<p>Returns the residual variance estimate from the <code>"locfit"</code> object.
</p>


<h3>See Also</h3>

<p><a href="#topic+locfit">locfit</a>, <a href="#topic+rv+3C-">rv&lt;-</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(ethanol)
fit &lt;- locfit(NOx~E,data=ethanol)
rv(fit)
</code></pre>

<hr>
<h2 id='rva'>
Substitute variance estimate on a locfit object.
</h2><span id='topic+rv+3C-'></span>

<h3>Description</h3>

<p>By default, Locfit uses the normalized residual sum of squares as the
variance estimate when constructing confidence intervals.
In some cases, the user may like to use alternative variance
estimates; this function allows the default value to be changed.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rv(fit) &lt;- value
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rva_+3A_fit">fit</code></td>
<td>
<p><code>"locfit"</code> object.</p>
</td></tr>
<tr><td><code id="rva_+3A_value">value</code></td>
<td>
<p>numeric replacement value.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><a href="#topic+locfit">locfit</a>(), <a href="#topic+rv">rv</a>(), <a href="#topic+plot.locfit">plot.locfit</a>()
</p>

<hr>
<h2 id='scb'>
Simultaneous Confidence Bands
</h2><span id='topic+scb'></span>

<h3>Description</h3>

<p><code>scb</code> is implemented as a front-end to <code><a href="#topic+locfit">locfit</a></code>,
to compute simultaneous confidence bands using the tube formula
method and extensions, based on Sun and Loader (1994).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>scb(x, ..., ev = lfgrid(20), simul = TRUE, type = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="scb_+3A_x">x</code></td>
<td>
<p>A numeric vector or matrix of predictors (as in
<code><a href="#topic+locfit.raw">locfit.raw</a></code>), or a model formula (as in
<code><a href="#topic+locfit">locfit</a></code>).</p>
</td></tr>
<tr><td><code id="scb_+3A_...">...</code></td>
<td>
<p>Additional arguments to <code><a href="#topic+locfit.raw">locfit.raw</a></code>.</p>
</td></tr>
<tr><td><code id="scb_+3A_ev">ev</code></td>
<td>
<p>The evaluation structure to use.  See <code><a href="#topic+locfit.raw">locfit.raw</a></code>.</p>
</td></tr>
<tr><td><code id="scb_+3A_simul">simul</code></td>
<td>
<p>Should the coverage be simultaneous or pointwise?</p>
</td></tr>
<tr><td><code id="scb_+3A_type">type</code></td>
<td>
<p>Type of confidence bands. <code>type=0</code> computes pointwise
95% bands. <code>type=1</code> computes basic simultaneous bands with no
corrections. <code>type=2,3,4</code> are the centered and corrected bands
for parametric regression models listed in Table 3 of Sun, Loader and
McCormick (2000).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list containing the evaluation points, fit, standard deviations and upper
and lower confidence bounds. The class is <code>"scb"</code>; methods for
printing and ploting are provided.
</p>


<h3>References</h3>

<p>Sun J. and Loader, C. (1994).
Simultaneous confidence bands in linear regression and smoothing.
<em>The Annals of Statistics</em> 22, 1328-1345.
</p>
<p>Sun, J., Loader, C. and McCormick, W. (2000).
Confidence bands in generalized linear models.
<em>The Annals of Statistics</em> 28, 429-460.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+locfit">locfit</a></code>, <code><a href="#topic+print.scb">print.scb</a></code>, <code><a href="#topic+plot.scb">plot.scb</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># corrected confidence bands for a linear logistic model
data(insect)
fit &lt;- scb(deaths~lp(lconc,deg=1), type=4, w=nins,
           data=insect,family="binomial",kern="parm")
plot(fit)
</code></pre>

<hr>
<h2 id='sjpi'>
Sheather-Jones Plug-in bandwidth criterion.
</h2><span id='topic+sjpi'></span>

<h3>Description</h3>

<p>Given a dataset and set of pilot bandwidths, this function
computes a bandwidth via the plug-in method, and the assumed
&lsquo;pilot&rsquo; relationship of Sheather and Jones (1991).
The S-J method chooses the bandwidth at which the two intersect.
</p>
<p>The purpose of this function is to demonstrate the sensitivity of
plug-in methods to pilot bandwidths and assumptions. This function
does not provide a reliable method of bandwidth selection.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sjpi(x, a)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sjpi_+3A_x">x</code></td>
<td>
<p>data vector</p>
</td></tr>
<tr><td><code id="sjpi_+3A_a">a</code></td>
<td>
<p>vector of pilot bandwidths</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix with four columns; the number of rows equals the length of <code>a</code>.
The first column is the plug-in selected bandwidth. The second column
is the pilot bandwidths <code>a</code>. The third column is the pilot bandwidth
according to the assumed relationship of Sheather and Jones. The fourth
column is an intermediate calculation.
</p>


<h3>References</h3>

<p>Sheather, S. J. and Jones, M. C. (1991). A reliable data-based bandwidth
selection method for kernel density estimation. JRSS-B 53, 683-690.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+locfit">locfit</a></code>,
<code><a href="#topic+locfit.raw">locfit.raw</a></code>,
<code><a href="#topic+lcvplot">lcvplot</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Fig 10.2 (S-J parts) from Loader (1999).
data(geyser, package="locfit")
gf &lt;- 2.5
a &lt;- seq(0.05, 0.7, length=100)
z &lt;- sjpi(geyser, a)

# the plug-in curve. Multiplying by gf=2.5 corresponds to Locfit's standard
# scaling for the Gaussian kernel.
plot(gf*z[, 2], gf*z[, 1], type = "l", xlab = "Pilot Bandwidth k", ylab
     = "Bandwidth h")

# Add the assumed curve.
lines(gf * z[, 3], gf * z[, 1], lty = 2)
legend(gf*0.05, gf*0.4, lty = 1:2, legend = c("Plug-in", "SJ assumed"))
</code></pre>

<hr>
<h2 id='smooth.lf'>
Local Regression, Likelihood and Density Estimation.
</h2><span id='topic+smooth.lf'></span>

<h3>Description</h3>

<p><code>smooth.lf</code> is a simple interface to the Locfit library.
The input consists of a predictor vector (or matrix) and response.
The output is a list with vectors of fitting points and fitted values.
Most <code><a href="#topic+locfit.raw">locfit.raw</a></code> options are valid.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>smooth.lf(x, y, xev=x, direct=FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="smooth.lf_+3A_x">x</code></td>
<td>

<p>Vector (or matrix) of the independent variable(s).
</p>
</td></tr>
<tr><td><code id="smooth.lf_+3A_y">y</code></td>
<td>

<p>Response variable. If omitted, <code>x</code> is treated as the response and
the predictor variable is <code>1:n</code>.
</p>
</td></tr>
<tr><td><code id="smooth.lf_+3A_xev">xev</code></td>
<td>

<p>Fitting Points. Default is the data vector <code>x</code>.
</p>
</td></tr>
<tr><td><code id="smooth.lf_+3A_direct">direct</code></td>
<td>

<p>Logical variable. If <code>T</code>, local regression is performed directly
at each fitting point. If <code>F</code>, the standard Locfit method combining
fitting and interpolation is used.
</p>
</td></tr>
<tr><td><code id="smooth.lf_+3A_...">...</code></td>
<td>

<p>Other arguments to <code><a href="#topic+locfit.raw">locfit.raw</a>()</code>.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with components <code>x</code> (fitting points) and <code>y</code> (fitted values).
Also has a <code>call</code> component, so <code>update()</code> will work.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+locfit">locfit</a>()</code>,
<code><a href="#topic+locfit.raw">locfit.raw</a>()</code>,
<code><a href="#topic+density.lf">density.lf</a>()</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># using smooth.lf() to fit a local likelihood model.
data(morths)
fit &lt;- smooth.lf(morths$age, morths$deaths, weights=morths$n,
                 family="binomial")
plot(fit,type="l")

# update with the direct fit
fit1 &lt;- update(fit, direct=TRUE)
lines(fit1,col=2)
print(max(abs(fit$y-fit1$y)))
</code></pre>

<hr>
<h2 id='spence.15'>
Spencer's 15 point graduation rule.
</h2><span id='topic+spence.15'></span>

<h3>Description</h3>

<p>Spencer's 15 point rule is a weighted moving average operation
for a sequence of observations equally spaced in time. The
average at time t depends on the observations at times t-7,...,t+7.
</p>
<p>Except for boundary effects, the function will reproduce
polynomials up to degree 3.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>spence.15(y)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="spence.15_+3A_y">y</code></td>
<td>
<p>Data vector of observations at equally spaced points.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector with the same length as the input vector, representing
the graduated (smoothed) values.
</p>


<h3>References</h3>

<p>Spencer, J. (1904).
On the graduation of rates of sickness and mortality.
Journal of the Institute of Actuaries 38, 334-343.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+spence.21">spence.21</a></code>,
<code><a href="#topic+spencer">spencer</a></code>,
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(spencer)
yy &lt;- spence.15(spencer$mortality)
plot(spencer$age, spencer$mortality)
lines(spencer$age, yy)
</code></pre>

<hr>
<h2 id='spence.21'>
Spencer's 21 point graduation rule.
</h2><span id='topic+spence.21'></span>

<h3>Description</h3>

<p>Spencer's 21 point rule is a weighted moving average operation
for a sequence of observations equally spaced in time. The
average at time t depends on the observations at times t-11,...,t+11.
</p>
<p>Except for boundary effects, the function will reproduce
polynomials up to degree 3.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>spence.21(y)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="spence.21_+3A_y">y</code></td>
<td>
<p>Data vector of observations at equally spaced points.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector with the same length as the input vector, representing
the graduated (smoothed) values.
</p>


<h3>References</h3>

<p>Spencer, J. (1904).
On the graduation of rates of sickness and mortality.
Journal of the Institute of Actuaries 38, 334-343.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+spence.15">spence.15</a></code>,
<code><a href="#topic+spencer">spencer</a></code>,
</p>


<h3>Examples</h3>

<pre><code class='language-R'> data(spencer)
yy &lt;- spence.21(spencer$mortality)
plot(spencer$age, spencer$mortality)
lines(spencer$age, yy)
</code></pre>

<hr>
<h2 id='spencer'>Spencer's Mortality Dataset</h2><span id='topic+spencer'></span><span id='topic+spencer'></span>

<h3>Description</h3>

<p>Observed mortality rates for ages 20 to 45.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(spencer)</code></pre>


<h3>Format</h3>

<p>Data frame with age and mortality variables.
</p>


<h3>Source</h3>

<p>Spencer (1904).
</p>


<h3>References</h3>

<p>Spencer, J. (1904).
On the graduation of rates of sickness and mortality.
Journal of the Institute of Actuaries 38, 334-343.
</p>

<hr>
<h2 id='stamp'>Stamp Thickness Dataset</h2><span id='topic+stamp'></span>

<h3>Description</h3>

<p>Thicknesses of 482 postage stamps of the 1872 Hidalgo issue of Mexico.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(stamp)</code></pre>


<h3>Format</h3>

<p>Data frame with <code>thick</code> (stamp thickness) and <code>count</code>
(number of stamps) variables.
</p>


<h3>Source</h3>

<p>Izenman and Sommer (1988).
</p>


<h3>References</h3>

<p>Izenman, A. J. and Sommer, C. J. (1988).
Philatelic mixtures and multimodal densities.
Journal of the American Statistical Association 73, 602-606.
</p>

<hr>
<h2 id='store'>
Save S functions.
</h2><span id='topic+store'></span>

<h3>Description</h3>

<p>I've gotta keep track of this mess somehow!
</p>


<h3>Usage</h3>

<pre><code class='language-R'>store(data=FALSE, grand=FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="store_+3A_data">data</code></td>
<td>
<p>whether data objects are to be saved.</p>
</td></tr>
<tr><td><code id="store_+3A_grand">grand</code></td>
<td>
<p>whether everything is to be saved.</p>
</td></tr>
</table>

<hr>
<h2 id='summary.gcvplot'>
Summary method for a gcvplot structure.
</h2><span id='topic+summary.gcvplot'></span>

<h3>Description</h3>

<p>Computes a short summary for a generalized cross-validation plot structure
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'gcvplot'
summary(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary.gcvplot_+3A_object">object</code></td>
<td>
<p>A <code>gcvplot</code> structure produced by a call to
<code><a href="#topic+gcvplot">gcvplot</a></code>, <code><a href="#topic+cpplot">cpplot</a></code> e.t.c.</p>
</td></tr>
<tr><td><code id="summary.gcvplot_+3A_...">...</code></td>
<td>
<p>arugments to and from other methods.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix with two columns; one row for each fit computed in the
<code><a href="#topic+gcvplot">gcvplot</a></code> call.
The first column is the fitted degrees
of freedom; the second is the GCV or other criterion computed.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+locfit">locfit</a></code>,
<code><a href="#topic+gcv">gcv</a></code>,
<code><a href="#topic+gcvplot">gcvplot</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(ethanol)
summary(gcvplot(NOx~E,data=ethanol,alpha=seq(0.2,1.0,by=0.05)))
</code></pre>

<hr>
<h2 id='summary.locfit'>
Print method for a locfit object.
</h2><span id='topic+summary.locfit'></span>

<h3>Description</h3>

<p>Prints a short summary of a <code>"locfit"</code> object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'locfit'
summary(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary.locfit_+3A_object">object</code></td>
<td>
<p><code>locfit</code> object.</p>
</td></tr>
<tr><td><code id="summary.locfit_+3A_...">...</code></td>
<td>
<p>arguments passed to and from methods.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>summary.locfit</code> object, containg a short summary of the
<code>locfit</code> object.
</p>

<hr>
<h2 id='summary.preplot.locfit'>
Summary method for a preplot.locfit object.
</h2><span id='topic+summary.preplot.locfit'></span>

<h3>Description</h3>

<p>Prints a short summary of a <code>"preplot.locfit"</code> object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'preplot.locfit'
summary(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary.preplot.locfit_+3A_object">object</code></td>
<td>

<p><code>preplot.locfit</code> object.
</p>
</td></tr>
<tr><td><code id="summary.preplot.locfit_+3A_...">...</code></td>
<td>
<p>arguments passed to and from methods.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The fitted values from a
<code>preplot.locfit</code> object.
</p>

<hr>
<h2 id='trimod'>Generated sample from a bivariate trimodal normal mixture</h2><span id='topic+trimod'></span>

<h3>Description</h3>

<p>This is a random sample from a mixture of three bivariate standard
normal components;
the sample was used for the examples in Loader (1996).
</p>


<h3>Format</h3>

<p>Data frame with 225 observations and variables x0, x1.
</p>


<h3>Source</h3>

<p>Randomly generated in S.
</p>


<h3>References</h3>

<p>Loader, C. R. (1996).
Local Likelihood Density Estimation.
Annals of Statistics 24, 1602-1618.
</p>

<hr>
<h2 id='xbar'>
Locfit Evaluation Structure
</h2><span id='topic+xbar'></span>

<h3>Description</h3>

<p><code>xbar()</code> is an evaluation structure for <code><a href="#topic+locfit.raw">locfit.raw</a>()</code>,
evaluating the fit at a single point, namely, the average of each predictor
variable.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>xbar()
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
