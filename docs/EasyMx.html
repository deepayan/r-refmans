<!DOCTYPE html><html><head><title>Help for package EasyMx</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {EasyMx}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#EasyMx-package'><p>EasyMx: Easy modeling in OpenMx</p></a></li>
<li><a href='#emxCholeskyComponent'><p>Creates component for a Biometric Cholesky Model</p></a></li>
<li><a href='#emxCholeskyVariance'><p>Create a variance matrix in Cholesky form</p></a></li>
<li><a href='#emxCommonPathwayComponent'><p>Creates component for a Biometric Common Pathway Model</p></a></li>
<li><a href='#emxCovariances'><p>Create a set of covariances</p></a></li>
<li><a href='#emxFactorModel'><p>Create a factor model</p></a></li>
<li><a href='#emxGeneticFactorComponent'><p>Creates component for a Genetic Factor Model</p></a></li>
<li><a href='#emxGeneticFactorVariance'><p>Creates a variance matrix accoring to the Genetic Factor Model</p></a></li>
<li><a href='#emxGrowthModel'><p>Create a latent growth curve model</p></a></li>
<li><a href='#emxIndependentPathwayComponent'><p>Creates component for a Biometric Independent Pathway Model</p></a></li>
<li><a href='#emxKroneckerVariance'><p>Creates a large Variance matrix by Kroneckering two smaller matrices</p></a></li>
<li><a href='#emxLoadings'><p>Create a factor loadings matrix</p></a></li>
<li><a href='#emxMeans'><p>Create a set of means</p></a></li>
<li><a href='#emxMixtureModel'><p>Create a mixture model</p></a></li>
<li><a href='#emxRegressionModel'><p>Create a regression model</p></a></li>
<li><a href='#emxRelatednessMatrix'><p>Create a relatedness matrix</p></a></li>
<li><a href='#emxResiduals'><p>Create a residual variances matrix</p></a></li>
<li><a href='#emxStateSpaceMixtureClassify'><p>Classify time series in a state space mixture model</p></a></li>
<li><a href='#emxStateSpaceMixtureModel'><p>Create a state space mixture model</p></a></li>
<li><a href='#emxThresholds'><p>Create a set of thresholds for ordinal data</p></a></li>
<li><a href='#emxTwinModel'><p>Creates behavior genetics Twin Model</p></a></li>
<li><a href='#emxVarianceComponents'><p>Creates Variance Components Model</p></a></li>
<li><a href='#emxVARModel'><p>Create a vector autoregressive (VAR) model</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Date:</td>
<td>2023-01-27</td>
</tr>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Easy Model-Builder Functions for 'OpenMx'</td>
</tr>
<tr>
<td>Imports:</td>
<td>methods</td>
</tr>
<tr>
<td>Description:</td>
<td>Utilities for building certain kinds of common matrices and models in 
    the extended structural equation modeling package, 'OpenMx'.</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.0.0), OpenMx</td>
</tr>
<tr>
<td>Suggests:</td>
<td>rpf (&ge; 0.45)</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL]</td>
</tr>
<tr>
<td>Version:</td>
<td>0.3-2</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://bitbucket.org/mhunter/easymx">https://bitbucket.org/mhunter/easymx</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://bitbucket.org/mhunter/easymx/issues">https://bitbucket.org/mhunter/easymx/issues</a></td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-01-30 21:31:39 UTC; mhunter</td>
</tr>
<tr>
<td>Author:</td>
<td>Michael D. Hunter <a href="https://orcid.org/0000-0002-3651-6709"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cre],
  Joshua N. Pritikin [ctb]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Michael D. Hunter &lt;mhunter.ou@gmail.com&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-01-30 22:00:07 UTC</td>
</tr>
</table>
<hr>
<h2 id='EasyMx-package'>EasyMx: Easy modeling in OpenMx</h2><span id='topic+EasyMx-package'></span><span id='topic+EasyMx'></span>

<h3>Description</h3>

<p>EasyMx is a package for extended structural equation modeling. It is built as a higher-level frontend on top of OpenMx.  It is intended as an Easy introduction to OpenMx: Easy Mx.  Try the example below.</p>


<h3>Details</h3>

<p>All of the functions in the EasyMx package create OpenMx objects. These are most often MxMatrix, MxAlgebra, or MxModel objects.  The primary difference between EasyMx and OpenMx is design philosophy.  OpenMx has its foundation in WYSIWID: What you say is what it does.  This requires the user to be very explicit.  The EasyMx package is not as strong or flexible as OpenMx, but it places less burden on the user.  Many decisions are made automatically for the user.  Some of them are modifiable within EasyMx; for others the user is encouraged to use OpenMx, where nearly everything is modifiable.
</p>
<p>The package is broadly divided into two styles of functions: matrix builders and model builders.
</p>
<p>The matrix builder functions are utilities for building common structural equation model matrices.  These include <code><a href="#topic+emxLoadings">emxLoadings</a></code> for factor loadings, <code><a href="#topic+emxResiduals">emxResiduals</a></code> for residual variances, <code><a href="#topic+emxCovariances">emxCovariances</a></code> for latent or manifest covariances, <code><a href="#topic+emxMeans">emxMeans</a></code> for means and intercepts matrices, and <code><a href="#topic+emxThresholds">emxThresholds</a></code> for thresholds matrices when ordinal data are involved.
</p>
<p>The model builder functions are higher-level utilities for building common kinds of structural equation models.  The model builders often call several matrix builders.  The model builders include <code><a href="#topic+emxFactorModel">emxFactorModel</a></code> for (multiple) factor models, <code><a href="#topic+emxGrowthModel">emxGrowthModel</a></code> for latent growth curve models, and <code><a href="#topic+emxRegressionModel">emxRegressionModel</a></code> for full-information likelihood estimation of regression for observed variables.
</p>
<p>There are also a few model builder functions for non-standard structural equation models.  In particular, the <code><a href="#topic+emxVARModel">emxVARModel</a></code> function creates vector autoregressive models, and the <code><a href="#topic+emxStateSpaceMixtureModel">emxStateSpaceMixtureModel</a></code> function creates state space mixture models.
</p>
<p>A third category of functions encompasses special functions for behavior genetics modeling.  Some of these functions are matrix builders, and others are model builders.  The lowest-level functions for behavior genetics are <code><a href="#topic+emxCholeskyVariance">emxCholeskyVariance</a></code>, <code><a href="#topic+emxGeneticFactorVariance">emxGeneticFactorVariance</a></code>, <code><a href="#topic+emxRelatednessMatrix">emxRelatednessMatrix</a></code>, and <code><a href="#topic+emxKroneckerVariance">emxKroneckerVariance</a></code>.
</p>
<p>A higher-level set of behavior genetics matrix builders create all the matrices and algebraic statements needed for e.g. the A component of an ACE model.  These functions are <code><a href="#topic+emxCholeskyComponent">emxCholeskyComponent</a></code> and <code><a href="#topic+emxGeneticFactorComponent">emxGeneticFactorComponent</a></code>.
</p>
<p>The highest-level of behavior genetics functions builds some basic twin models.  The primary function for this is <code><a href="#topic+emxTwinModel">emxTwinModel</a></code>.
</p>
<p>Finally, a mixture model helper is provided: <code><a href="#topic+emxMixtureModel">emxMixtureModel</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Make and run a one factor model
## Not run: 
require(EasyMx)

data(demoOneFactor)
fmod &lt;- list(G=names(demoOneFactor))
fit1 &lt;- emxFactorModel(fmod, demoOneFactor, run=TRUE)
summary(fit1)

## End(Not run)
</code></pre>

<hr>
<h2 id='emxCholeskyComponent'>Creates component for a Biometric Cholesky Model</h2><span id='topic+emxCholeskyComponent'></span>

<h3>Description</h3>

<p>This function creates all the objects needed for a Cholesky component.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>emxCholeskyComponent(x, xname, xvalues, xfree,
                     h=2, hname=paste0('H', xname), hvalues, hlabels)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="emxCholeskyComponent_+3A_x">x</code></td>
<td>
<p>character vector. The base names of the variables used for the matrix with no repetition for twins (x, y, z not x1, y1, z1, x2, y2, z2).</p>
</td></tr>
<tr><td><code id="emxCholeskyComponent_+3A_xname">xname</code></td>
<td>
<p>character. Name of the component matrix.</p>
</td></tr>
<tr><td><code id="emxCholeskyComponent_+3A_xvalues">xvalues</code></td>
<td>
<p>numeric vector. Values of the component matrix.</p>
</td></tr>
<tr><td><code id="emxCholeskyComponent_+3A_xfree">xfree</code></td>
<td>
<p>logical vector. Whether each element of the component matrix is freely estimates.</p>
</td></tr>
<tr><td><code id="emxCholeskyComponent_+3A_h">h</code></td>
<td>
<p>numeric. The number of variables for the relatedness matrix, i.e. the number of critters with relationships</p>
</td></tr>
<tr><td><code id="emxCholeskyComponent_+3A_hname">hname</code></td>
<td>
<p>character. Name of the relatedness matrix.</p>
</td></tr>
<tr><td><code id="emxCholeskyComponent_+3A_hvalues">hvalues</code></td>
<td>
<p>numeric vector. Values for the relatedness matrix.</p>
</td></tr>
<tr><td><code id="emxCholeskyComponent_+3A_hlabels">hlabels</code></td>
<td>
<p>character vector. Labels for the relatedness matrix.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is a combination of emxCholeskyVariance, emxRelatednessMatrix, and emxKroneckerVariance.
</p>


<h3>Value</h3>

<p>A list with elements (1) the lower triangular matrix for the Cholesky, (2) the full positive definite variance matrix, (3) the relatedness matrix, and (4) the Kronecker product of the variance matrix and the relatedness matrix.
</p>


<h3>See Also</h3>

<p><a href="#topic+emxGeneticFactorComponent">emxGeneticFactorComponent</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>   
# Create an ACE model in 22 lines
require(EasyMx)
require(OpenMx)
data(twinData)
twinVar = names(twinData)
selVars &lt;- c('ht1', 'bmi1','ht2','bmi2')
mzdzData &lt;- subset(twinData, zyg %in% c(1, 3), c(selVars, 'zyg'))
mzdzData$RCoef &lt;- c(1, NA, .5)[mzdzData$zyg]
nVar = length(selVars)/2
x &lt;- paste0('x', 1:nVar)

acomp &lt;- emxCholeskyComponent(x, 'A', hvalues=c(1, .5, 1), hlabels=c(NA, 'data.RCoef', NA))
ccomp &lt;- emxCholeskyComponent(x, 'C', hvalues=c(1, 1, 1))
ecomp &lt;- emxCholeskyComponent(x, 'E', hvalues=c(1, 0, 1))
totalVar &lt;- mxAlgebra(AKron + CKron + EKron, 'V', dimnames=list(selVars, selVars))
totalMean &lt;- emxMeans(selVars, type='twin')
expect &lt;- mxExpectationNormal(totalVar$name, totalMean$name)
fitfun &lt;- mxFitFunctionML()

comlist &lt;- c(acomp, ccomp, ecomp, list(totalVar, totalMean, expect, fitfun))

model &lt;- mxModel('model', comlist, mxData(mzdzData, 'raw'))
## Not run: 
run2 &lt;- mxRun(model)

## End(Not run)


</code></pre>

<hr>
<h2 id='emxCholeskyVariance'>Create a variance matrix in Cholesky form</h2><span id='topic+emxCholeskyVariance'></span>

<h3>Description</h3>

<p>This function creates a Cholesky variance matrix and associated MxMatrix and MxAlgebra objects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>emxCholeskyVariance(x, name, values=.8, free=TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="emxCholeskyVariance_+3A_x">x</code></td>
<td>
<p>character vector. The names of the variables used for the matrix.</p>
</td></tr>
<tr><td><code id="emxCholeskyVariance_+3A_name">name</code></td>
<td>
<p>character. The name of the variance matrix created.</p>
</td></tr>
<tr><td><code id="emxCholeskyVariance_+3A_values">values</code></td>
<td>
<p>numeric vector. The starting values for the lower triangular matrix.</p>
</td></tr>
<tr><td><code id="emxCholeskyVariance_+3A_free">free</code></td>
<td>
<p>logical vector. Whether the lower triangular elements are free.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This is a helper function for creating a matrix that is symmetric and positive definite. Full covariance matrices are the most common case of these.  In a behavior genetics modeling context, Cholesky components can be created for Additive genetics, Common environments, and unique Environments. These are unrestrictive models of the covariances of multiple phenotypes.
</p>


<h3>Value</h3>

<p>A list with two components. The first component is the lower triangular MxMatrix. The second component is an MxAlgebra, the result of which is the positive definite variance matrix.
</p>


<h3>See Also</h3>

<p><a href="#topic+emxGeneticFactorVariance">emxGeneticFactorVariance</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>   
# Create a Cholesky variance matrix called 'A'
require(EasyMx)
nVar &lt;- 3
x &lt;- paste0('x', 1:nVar)
amat &lt;- emxCholeskyVariance(x, 'A')

</code></pre>

<hr>
<h2 id='emxCommonPathwayComponent'>Creates component for a Biometric Common Pathway Model</h2><span id='topic+emxCommonPathwayComponent'></span>

<h3>Description</h3>

<p>UNDER ACTIVE DEVELOPMENT. DO NOT TRUST. This function creates all the objects needed for a Common Pathway component.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>emxCommonPathwayComponent(x, xname, xvalues=.8, xfree=TRUE, xlbound=NA, xubound=NA,
                          h=2, hname=paste0('H', xname), hvalues, hlabels)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="emxCommonPathwayComponent_+3A_x">x</code></td>
<td>
<p>character vector. The base names of the variables used for the matrix with no repetition for twins (x, y, z not x1, y1, z1, x2, y2, z2).</p>
</td></tr>
<tr><td><code id="emxCommonPathwayComponent_+3A_xname">xname</code></td>
<td>
<p>character. Name of the component matrix.</p>
</td></tr>
<tr><td><code id="emxCommonPathwayComponent_+3A_xvalues">xvalues</code></td>
<td>
<p>Matrix of fixed and/or starting values of parameters</p>
</td></tr>
<tr><td><code id="emxCommonPathwayComponent_+3A_xfree">xfree</code></td>
<td>
<p>Matrix of TRUE (for free) and FALSE (for fixed) values</p>
</td></tr>
<tr><td><code id="emxCommonPathwayComponent_+3A_xlbound">xlbound</code></td>
<td>
<p>Matrix of numeric lower bounds for parameters</p>
</td></tr>
<tr><td><code id="emxCommonPathwayComponent_+3A_xubound">xubound</code></td>
<td>
<p>Matrix of numeric upper bounds for parameters</p>
</td></tr>
<tr><td><code id="emxCommonPathwayComponent_+3A_h">h</code></td>
<td>
<p>numeric. The number of variables for the relatedness matrix, i.e. the number of critters with relationships</p>
</td></tr>
<tr><td><code id="emxCommonPathwayComponent_+3A_hname">hname</code></td>
<td>
<p>character. Name of the relatedness matrix.</p>
</td></tr>
<tr><td><code id="emxCommonPathwayComponent_+3A_hvalues">hvalues</code></td>
<td>
<p>numeric vector. Values for the relatedness matrix.</p>
</td></tr>
<tr><td><code id="emxCommonPathwayComponent_+3A_hlabels">hlabels</code></td>
<td>
<p>character vector. Labels for the relatedness matrix.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is a combination of emxCholeskyVariance, emxRelatednessMatrix, and emxKroneckerVariance.
</p>


<h3>Value</h3>

<p>A list with elements (1) the lower triangular matrix for the Cholesky, (2) the full positive definite variance matrix, (3) the relatedness matrix, and (4) the Kronecker product of the variance matrix and the relatedness matrix.
</p>


<h3>See Also</h3>

<p><a href="#topic+emxGeneticFactorComponent">emxGeneticFactorComponent</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>   
# Create an ACE model in 22 lines
require(EasyMx)
require(OpenMx)
data(twinData)
twinVar = names(twinData)
selVars &lt;- c('ht1', 'bmi1','ht2','bmi2')
mzdzData &lt;- subset(twinData, zyg %in% c(1, 3), c(selVars, 'zyg'))
mzdzData$RCoef &lt;- c(1, NA, .5)[mzdzData$zyg]
nVar = length(selVars)/2
x &lt;- paste0('x', 1:nVar)

acomp &lt;- emxCholeskyComponent(x, 'A', hvalues=c(1, .5, 1), hlabels=c(NA, 'data.RCoef', NA))
ccomp &lt;- emxCholeskyComponent(x, 'C', hvalues=c(1, 1, 1))
ecomp &lt;- emxCholeskyComponent(x, 'E', hvalues=c(1, 0, 1))
totalVar &lt;- mxAlgebra(AKron + CKron + EKron, 'V', dimnames=list(selVars, selVars))
totalMean &lt;- emxMeans(selVars, type='twin')
expect &lt;- mxExpectationNormal(totalVar$name, totalMean$name)
fitfun &lt;- mxFitFunctionML()

comlist &lt;- c(acomp, ccomp, ecomp, list(totalVar, totalMean, expect, fitfun))

model &lt;- mxModel('model', comlist, mxData(mzdzData, 'raw'))
## Not run: 
run2 &lt;- mxRun(model)

## End(Not run)

</code></pre>

<hr>
<h2 id='emxCovariances'>Create a set of covariances</h2><span id='topic+emxCovariances'></span>

<h3>Description</h3>

<p>This function creates a covariance matrix as an MxMatrix or MxPath object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>emxCovariances(x, values, free, path=FALSE, type, name='Variances')
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="emxCovariances_+3A_x">x</code></td>
<td>
<p>character vector. The names of the variables for which covariances are created.</p>
</td></tr>
<tr><td><code id="emxCovariances_+3A_values">values</code></td>
<td>
<p>numeric vector. See Details.</p>
</td></tr>
<tr><td><code id="emxCovariances_+3A_free">free</code></td>
<td>
<p>logical vector. See Details.</p>
</td></tr>
<tr><td><code id="emxCovariances_+3A_path">path</code></td>
<td>
<p>logical. Whether to return the MxPath object instead of the MxMatrix.</p>
</td></tr>
<tr><td><code id="emxCovariances_+3A_type">type</code></td>
<td>
<p>character.  The kind of covariance structure to create.  See Details.</p>
</td></tr>
<tr><td><code id="emxCovariances_+3A_name">name</code></td>
<td>
<p>The name of the matrix created.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Possible values for the <code>type</code> argument are 'independent', 'full', and 'corr'.  When <code>type='independent'</code>, the remaining arguments are passes to <code><a href="#topic+emxResiduals">emxResiduals</a></code>.  The <code>values</code> and <code>free</code> arguments are only used when the <code>type</code> argument is 'independent'.  For all other cases, they are ignored.
</p>
<p>When <code>type='full'</code>, a full covariance matrix is created.  That is, a symmetric matrix is created with all unique elements freely estimated.  The starting values for the variances are all 1; for the covariances, all 0.5.
</p>
<p>When <code>type='corr'</code>, a full correlation matrix is created.  That is, a symmetric matrix is created with all unique elements not on the diagonal freely estimated.  The starting values for the correlations are all 0.5.  The variances are fixed at 1.
</p>


<h3>Value</h3>

<p>Depending on the value of the <code>path</code> argument, either an MxMatrix or and MxPath object that can be inspected, modified, and/or included in MxModel objects.
</p>


<h3>See Also</h3>

<p><a href="#topic+emxFactorModel">emxFactorModel</a>, <a href="#topic+emxGrowthModel">emxGrowthModel</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>   
# Create a covariance matrix
require(EasyMx)
manVars &lt;- paste0('x', 1:6)
latVars &lt;- paste0('F', 1:2)
emxCovariances(manVars, type='full')
emxCovariances(latVars, type='corr', path=TRUE)


</code></pre>

<hr>
<h2 id='emxFactorModel'>Create a factor model</h2><span id='topic+emxFactorModel'></span><span id='topic+emxModelFactor'></span>

<h3>Description</h3>

<p>This function creates a factor model as an MxModel object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>emxFactorModel(model, data, name, run=FALSE, identification, use, ordinal,
    ..., parameterization=c("lisrel", "ifa"), weight = as.character(NA))
emxModelFactor(model, data, name, run=FALSE, identification, use, ordinal,
    ..., parameterization=c("lisrel", "ifa"), weight = as.character(NA))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="emxFactorModel_+3A_model">model</code></td>
<td>
<p>named list. Gives the factor loading pattern. See Details.</p>
</td></tr>
<tr><td><code id="emxFactorModel_+3A_data">data</code></td>
<td>
<p>data used for the model</p>
</td></tr>
<tr><td><code id="emxFactorModel_+3A_name">name</code></td>
<td>
<p>character.  Optional name of the model created.</p>
</td></tr>
<tr><td><code id="emxFactorModel_+3A_run">run</code></td>
<td>
<p>logical. Whether to run the model before returning.</p>
</td></tr>
<tr><td><code id="emxFactorModel_+3A_identification">identification</code></td>
<td>
<p>Not yet implemented.  How the model is identified.  Currently ignored.</p>
</td></tr>
<tr><td><code id="emxFactorModel_+3A_use">use</code></td>
<td>
<p>character vector.  The names of the variables to use.</p>
</td></tr>
<tr><td><code id="emxFactorModel_+3A_ordinal">ordinal</code></td>
<td>
<p>character vector.  The names of the ordinal variables.</p>
</td></tr>
<tr><td><code id="emxFactorModel_+3A_...">...</code></td>
<td>
<p>Force later arguments to be named.  ... is ignored.</p>
</td></tr>
<tr><td><code id="emxFactorModel_+3A_parameterization">parameterization</code></td>
<td>
<p>character.  Whether to specify the model as a LISREL SEM or as an Item Factor Analysis</p>
</td></tr>
<tr><td><code id="emxFactorModel_+3A_weight">weight</code></td>
<td>
<p>character. Name of the data column used for sample weights.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>model</code> argument must be a named list.  The names of the list give the names of the latent variables.  Each list element gives the names of the variables that load onto that latent variable.  This may sound complicated, but the example below makes this more clear.  It is intended to be visually intuitive.
</p>


<h3>Value</h3>

<p>An MxModel.
</p>


<h3>See Also</h3>

<p><a href="#topic+emxLoadings">emxLoadings</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>   
# Example
require(EasyMx)
data(myFADataRaw)
xmap &lt;- list(F1=paste0('x', 1:6), F2=paste0('y', 1:3), F3=paste0('z', 1:3))
## Not run: 
mod &lt;- emxFactorModel(xmap, data=myFADataRaw, run=TRUE)

## End(Not run)

</code></pre>

<hr>
<h2 id='emxGeneticFactorComponent'>Creates component for a Genetic Factor Model</h2><span id='topic+emxGeneticFactorComponent'></span>

<h3>Description</h3>

<p>This function creates all the objects needed for Genetic Factor component
</p>


<h3>Usage</h3>

<pre><code class='language-R'>emxGeneticFactorComponent(x, xname, xvalues=.8, xfree=TRUE, xlbound=NA, xubound=NA,
                          h=2, hname=paste0('H', xname), hvalues, hlabels)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="emxGeneticFactorComponent_+3A_x">x</code></td>
<td>
<p>character vector. The base names of the variables used for the matrix with no repetition for twins (x, y, z not x1, y1, z1, x2, y2, z2).</p>
</td></tr>
<tr><td><code id="emxGeneticFactorComponent_+3A_xname">xname</code></td>
<td>
<p>character. Name of the component matrix.</p>
</td></tr>
<tr><td><code id="emxGeneticFactorComponent_+3A_xvalues">xvalues</code></td>
<td>
<p>numeric vector. Values of the genetic factor loadings.</p>
</td></tr>
<tr><td><code id="emxGeneticFactorComponent_+3A_xfree">xfree</code></td>
<td>
<p>logical vector. Whether the genetic factor loadings are free.</p>
</td></tr>
<tr><td><code id="emxGeneticFactorComponent_+3A_xlbound">xlbound</code></td>
<td>
<p>numeric vector. Lower bounds of the factor loadings.</p>
</td></tr>
<tr><td><code id="emxGeneticFactorComponent_+3A_xubound">xubound</code></td>
<td>
<p>numeric vector. Upper bounds of the factor loadings.</p>
</td></tr>
<tr><td><code id="emxGeneticFactorComponent_+3A_h">h</code></td>
<td>
<p>numeric. The number of variables for the relatedness matrix, i.e. the number of critters with relationships</p>
</td></tr>
<tr><td><code id="emxGeneticFactorComponent_+3A_hname">hname</code></td>
<td>
<p>character. Name of the relatedness matrix.</p>
</td></tr>
<tr><td><code id="emxGeneticFactorComponent_+3A_hvalues">hvalues</code></td>
<td>
<p>numeric vector. Values for the relatedness matrix.</p>
</td></tr>
<tr><td><code id="emxGeneticFactorComponent_+3A_hlabels">hlabels</code></td>
<td>
<p>character vector. Labels for the relatedness matrix.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is a combination of emxGeneticFactorVariance, emxRelatednessMatrix, and emxKroneckerVariance.
</p>


<h3>Value</h3>

<p>A list with elements (1) the genetic factor loadings matrix, (2) the full positive definite variance matrix, (3) the relatedness matrix, and (4) the Kronecker product of the variance matrix and the relatedness matrix.
</p>


<h3>See Also</h3>

<p><a href="#topic+emxCholeskyComponent">emxCholeskyComponent</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>   
# Create genetic factor A component for DZ twins
require(EasyMx)
xvars &lt;- paste0('x', 1:4)
acomp &lt;- emxGeneticFactorComponent(xvars, 'A', hvalues=c(1, .5, 1))

</code></pre>

<hr>
<h2 id='emxGeneticFactorVariance'>Creates a variance matrix accoring to the Genetic Factor Model</h2><span id='topic+emxGeneticFactorVariance'></span>

<h3>Description</h3>

<p>This function creates a variance matrix according to the genetic factor model
</p>


<h3>Usage</h3>

<pre><code class='language-R'>emxGeneticFactorVariance(x, name, values=.8, free=TRUE, lbound=NA, ubound=NA)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="emxGeneticFactorVariance_+3A_x">x</code></td>
<td>
<p>character vector. The names of the variables used for the matrix.</p>
</td></tr>
<tr><td><code id="emxGeneticFactorVariance_+3A_name">name</code></td>
<td>
<p>character. The name of the variance matrix created.</p>
</td></tr>
<tr><td><code id="emxGeneticFactorVariance_+3A_values">values</code></td>
<td>
<p>numeric vector. The starting values for the lower triangular matrix.</p>
</td></tr>
<tr><td><code id="emxGeneticFactorVariance_+3A_free">free</code></td>
<td>
<p>logical vector. Whether the lower triangular elements are free.</p>
</td></tr>
<tr><td><code id="emxGeneticFactorVariance_+3A_lbound">lbound</code></td>
<td>
<p>numeric vector. Lower bounds on free parameters.</p>
</td></tr>
<tr><td><code id="emxGeneticFactorVariance_+3A_ubound">ubound</code></td>
<td>
<p>numeric vector. Upper bounds on free parameters.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with two components. The first component is the factor loadings matrix. The second component is an MxAlgebra, the result of which is the variance matrix implied by the factor loadings.
</p>


<h3>See Also</h3>

<p><a href="#topic+emxCholeskyVariance">emxCholeskyVariance</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>   
# Create a genetic factor variance matrix
require(EasyMx)
xvars &lt;- paste0('x', 1:2)
emxGeneticFactorVariance(xvars, 'D')

</code></pre>

<hr>
<h2 id='emxGrowthModel'>Create a latent growth curve model</h2><span id='topic+emxGrowthModel'></span><span id='topic+emxModelGrowth'></span>

<h3>Description</h3>

<p>This function creates a latent growth curve model as an MxModel object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>emxGrowthModel(model, data, name, run=FALSE, identification, use, ordinal, times)
emxModelGrowth(model, data, name, run=FALSE, identification, use, ordinal, times)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="emxGrowthModel_+3A_model">model</code></td>
<td>
<p>character or numeric. See Details.</p>
</td></tr>
<tr><td><code id="emxGrowthModel_+3A_data">data</code></td>
<td>
<p>data used for the model</p>
</td></tr>
<tr><td><code id="emxGrowthModel_+3A_name">name</code></td>
<td>
<p>character.  Optional name of the model created.</p>
</td></tr>
<tr><td><code id="emxGrowthModel_+3A_run">run</code></td>
<td>
<p>logical. Whether to run the model before returning.</p>
</td></tr>
<tr><td><code id="emxGrowthModel_+3A_identification">identification</code></td>
<td>
<p>Not yet implemented.  How the model is identified.  Currently ignored.</p>
</td></tr>
<tr><td><code id="emxGrowthModel_+3A_use">use</code></td>
<td>
<p>character vector.  The names of the variables to use.</p>
</td></tr>
<tr><td><code id="emxGrowthModel_+3A_ordinal">ordinal</code></td>
<td>
<p>character vector.  The names of the ordinal variables.</p>
</td></tr>
<tr><td><code id="emxGrowthModel_+3A_times">times</code></td>
<td>
<p>optional character or numeric vector. Either the numeric times of measurement or the names of the variables in <code>data</code> that give the times of measurement.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>model</code> argument can be either a character or a number that tells the kind of growth curve to make.  If it is a character it currently must be one of &quot;Intercept&quot;, &quot;Linear&quot;, &quot;Quadratic&quot;, &quot;Cubic&quot;, &quot;Quartic&quot;, or &quot;Quintic&quot;, and it produces a polynomial growth curve of the corresponding type.  If it is a number, the function produces a polynomial growth curve of the corresponding order.  Zero is an intercept only, one is linear, two is quadratic; and so on.
</p>
<p>When missing, the <code>times</code> are assumed to start at zero and increment by one until the number of variables is completed.
</p>


<h3>Value</h3>

<p>An MxModel
</p>


<h3>See Also</h3>

<p><a href="#topic+emxFactorModel">emxFactorModel</a>, <a href="#topic+emxGrowthModel">emxGrowthModel</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>   
# Example
require(EasyMx)
data(myLongitudinalData)
## Not run: 
mod &lt;- emxGrowthModel('Linear', data=myLongitudinalData, use=names(myLongitudinalData), run=TRUE)

## End(Not run)
</code></pre>

<hr>
<h2 id='emxIndependentPathwayComponent'>Creates component for a Biometric Independent Pathway Model</h2><span id='topic+emxIndependentPathwayComponent'></span>

<h3>Description</h3>

<p>UNDER ACTIVE DEVELOPMENT. DO NOT TRUST. This function creates all the objects needed for an Independent Pathway component.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>emxIndependentPathwayComponent(x, xname, xvalues=.8, xfree=TRUE, xlbound=NA, xubound=NA,
                               h=2, hname=paste0('H', xname), hvalues, hlabels)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="emxIndependentPathwayComponent_+3A_x">x</code></td>
<td>
<p>character vector. The base names of the variables used for the matrix with no repetition for twins (x, y, z not x1, y1, z1, x2, y2, z2).</p>
</td></tr>
<tr><td><code id="emxIndependentPathwayComponent_+3A_xname">xname</code></td>
<td>
<p>character. Name of the component matrix.</p>
</td></tr>
<tr><td><code id="emxIndependentPathwayComponent_+3A_xvalues">xvalues</code></td>
<td>
<p>Matrix of fixed and/or starting values of parameters</p>
</td></tr>
<tr><td><code id="emxIndependentPathwayComponent_+3A_xfree">xfree</code></td>
<td>
<p>Matrix of TRUE (for free) and FALSE (for fixed) values</p>
</td></tr>
<tr><td><code id="emxIndependentPathwayComponent_+3A_xlbound">xlbound</code></td>
<td>
<p>Matrix of numeric lower bounds for parameters</p>
</td></tr>
<tr><td><code id="emxIndependentPathwayComponent_+3A_xubound">xubound</code></td>
<td>
<p>Matrix of numeric upper bounds for parameters</p>
</td></tr>
<tr><td><code id="emxIndependentPathwayComponent_+3A_h">h</code></td>
<td>
<p>numeric. The number of variables for the relatedness matrix, i.e. the number of critters with relationships</p>
</td></tr>
<tr><td><code id="emxIndependentPathwayComponent_+3A_hname">hname</code></td>
<td>
<p>character. Name of the relatedness matrix.</p>
</td></tr>
<tr><td><code id="emxIndependentPathwayComponent_+3A_hvalues">hvalues</code></td>
<td>
<p>numeric vector. Values for the relatedness matrix.</p>
</td></tr>
<tr><td><code id="emxIndependentPathwayComponent_+3A_hlabels">hlabels</code></td>
<td>
<p>character vector. Labels for the relatedness matrix.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is a combination of emxCholeskyVariance, emxRelatednessMatrix, and emxKroneckerVariance.
</p>


<h3>Value</h3>

<p>A list with elements (1) the lower triangular matrix for the Cholesky, (2) the full positive definite variance matrix, (3) the relatedness matrix, and (4) the Kronecker product of the variance matrix and the relatedness matrix.
</p>


<h3>See Also</h3>

<p><a href="#topic+emxGeneticFactorComponent">emxGeneticFactorComponent</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>   
# Create an ACE model in 22 lines
require(EasyMx)
require(OpenMx)
data(twinData)
twinVar = names(twinData)
selVars &lt;- c('ht1', 'bmi1','ht2','bmi2')
mzdzData &lt;- subset(twinData, zyg %in% c(1, 3), c(selVars, 'zyg'))
mzdzData$RCoef &lt;- c(1, NA, .5)[mzdzData$zyg]
nVar = length(selVars)/2
x &lt;- paste0('x', 1:nVar)

acomp &lt;- emxCholeskyComponent(x, 'A', hvalues=c(1, .5, 1), hlabels=c(NA, 'data.RCoef', NA))
ccomp &lt;- emxCholeskyComponent(x, 'C', hvalues=c(1, 1, 1))
ecomp &lt;- emxCholeskyComponent(x, 'E', hvalues=c(1, 0, 1))
totalVar &lt;- mxAlgebra(AKron + CKron + EKron, 'V', dimnames=list(selVars, selVars))
totalMean &lt;- emxMeans(selVars, type='twin')
expect &lt;- mxExpectationNormal(totalVar$name, totalMean$name)
fitfun &lt;- mxFitFunctionML()

comlist &lt;- c(acomp, ccomp, ecomp, list(totalVar, totalMean, expect, fitfun))

model &lt;- mxModel('model', comlist, mxData(mzdzData, 'raw'))
## Not run: 
run2 &lt;- mxRun(model)

## End(Not run)

</code></pre>

<hr>
<h2 id='emxKroneckerVariance'>Creates a large Variance matrix by Kroneckering two smaller matrices</h2><span id='topic+emxKroneckerVariance'></span>

<h3>Description</h3>

<p>This function creates the wide format variance matrix when combined with a relatedness matrix
</p>


<h3>Usage</h3>

<pre><code class='language-R'>emxKroneckerVariance(h, v, name)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="emxKroneckerVariance_+3A_h">h</code></td>
<td>
<p>MxMatrix. Left hand side of the Kronecker product.  Typically the relatedness matrix.</p>
</td></tr>
<tr><td><code id="emxKroneckerVariance_+3A_v">v</code></td>
<td>
<p>MxMatrix. Right hand side of the Kronecker product.  Typically the variance matrix.</p>
</td></tr>
<tr><td><code id="emxKroneckerVariance_+3A_name">name</code></td>
<td>
<p>character. Name of the resulting large matrix.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>In many behavior genetic models, a relationship matrix is combined with a base variance matrix.  The combination is done with a Kronecker product so that the variance exists (possibly weighted by zero or another number) for each member of the relationship.
</p>


<h3>Value</h3>

<p>MxAlgebra
</p>


<h3>See Also</h3>

<p><a href="#topic+emxRelatednessMatrix">emxRelatednessMatrix</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>   
# Create a loadings matrix
require(EasyMx)
x &lt;- letters[23:26]
amat &lt;- emxCholeskyVariance(x, 'A')
ahmat &lt;- emxRelatednessMatrix(2, c(1, .5, 1), name='AH')
ab &lt;- emxKroneckerVariance(ahmat, amat[[2]], 'AB')

</code></pre>

<hr>
<h2 id='emxLoadings'>Create a factor loadings matrix</h2><span id='topic+emxLoadings'></span>

<h3>Description</h3>

<p>This function creates a factor loadings matrix as an MxMatrix or MxPath object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>emxLoadings(x, values=.8, free=TRUE, path=FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="emxLoadings_+3A_x">x</code></td>
<td>
<p>named list. Gives the factor loading pattern. See Details.</p>
</td></tr>
<tr><td><code id="emxLoadings_+3A_values">values</code></td>
<td>
<p>numeric vector. The starting values for the nonzero loadings.</p>
</td></tr>
<tr><td><code id="emxLoadings_+3A_free">free</code></td>
<td>
<p>logical vector. Whether the nonzero loadings are free.</p>
</td></tr>
<tr><td><code id="emxLoadings_+3A_path">path</code></td>
<td>
<p>logical. Whether to return the MxPath object instead of the MxMatrix.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>x</code> argument must be a named list.  The names of the list give the names of the latent variables.  Each list element gives the names of the variables that load onto that latent variable.  This may sound complicated, but the example below makes this more clear.  It is intended to be visually intuitive.
</p>


<h3>Value</h3>

<p>Depending on the value of the <code>path</code> argument, either an MxMatrix or and MxPath object that can be inspected, modified, and/or included in MxModel objects.
</p>


<h3>See Also</h3>

<p><a href="#topic+emxFactorModel">emxFactorModel</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>   
# Create a loadings matrix
require(EasyMx)
xmap &lt;- list(F1=paste0('x', 1:6), F2=paste0('y', 1:3), F3=paste0('z', 1:3))
emxLoadings(xmap)
emxLoadings(xmap, path=TRUE)

</code></pre>

<hr>
<h2 id='emxMeans'>Create a set of means</h2><span id='topic+emxMeans'></span>

<h3>Description</h3>

<p>This function creates a means matrix as an MxMatrix or MxPath object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>emxMeans(x, values=0, free=TRUE, path=FALSE, type='saturated', name, column=TRUE, labels)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="emxMeans_+3A_x">x</code></td>
<td>
<p>character vector. The names of the variables for which means are created.</p>
</td></tr>
<tr><td><code id="emxMeans_+3A_values">values</code></td>
<td>
<p>numeric vector. See Details.</p>
</td></tr>
<tr><td><code id="emxMeans_+3A_free">free</code></td>
<td>
<p>logical vector. See Details.</p>
</td></tr>
<tr><td><code id="emxMeans_+3A_path">path</code></td>
<td>
<p>logical. Whether to return the MxPath object instead of the MxMatrix.</p>
</td></tr>
<tr><td><code id="emxMeans_+3A_type">type</code></td>
<td>
<p>character.  The kind of covariance structure to create.  See Details.</p>
</td></tr>
<tr><td><code id="emxMeans_+3A_name">name</code></td>
<td>
<p>The name of the matrix created.</p>
</td></tr>
<tr><td><code id="emxMeans_+3A_column">column</code></td>
<td>
<p>logical. Whether to create the means vector as a column or row.</p>
</td></tr>
<tr><td><code id="emxMeans_+3A_labels">labels</code></td>
<td>
<p>character vector. Optional labels for the means.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Possible values for the <code>type</code> argument are 'saturated', 'equal', 'twin', 'special'.

</p>


<h3>Value</h3>

<p>Depending on the value of the <code>path</code> argument, either an MxMatrix or and MxPath object that can be inspected, modified, and/or included in MxModel objects.
</p>


<h3>See Also</h3>

<p><a href="#topic+emxFactorModel">emxFactorModel</a>, <a href="#topic+emxGrowthModel">emxGrowthModel</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>   
# Create a covariance matrix
require(EasyMx)
manVars &lt;- paste0('x', 1:6)
emxMeans(manVars, type='saturated')


</code></pre>

<hr>
<h2 id='emxMixtureModel'>Create a mixture model</h2><span id='topic+emxMixtureModel'></span><span id='topic+emxModelMixture'></span>

<h3>Description</h3>

<p>This function creates a mxiture model as an MxModel object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>emxMixtureModel(model, data, run=FALSE, p=NA, ...)
emxModelMixture(model, data, run=FALSE, p=NA, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="emxMixtureModel_+3A_model">model</code></td>
<td>
<p>list. The MxModel objects that compose the mixture.</p>
</td></tr>
<tr><td><code id="emxMixtureModel_+3A_data">data</code></td>
<td>
<p>data used for the model</p>
</td></tr>
<tr><td><code id="emxMixtureModel_+3A_run">run</code></td>
<td>
<p>logical. Whether to run the model before returning.</p>
</td></tr>
<tr><td><code id="emxMixtureModel_+3A_p">p</code></td>
<td>
<p>character.  Optional name of the mixing proportions matrix.</p>
</td></tr>
<tr><td><code id="emxMixtureModel_+3A_...">...</code></td>
<td>
<p>Further Mx Objects passed into the mixture model.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>model</code> argument is list of MxModel objects.  These are the classes over which the mixture model operates.
</p>
<p>The <code>p</code> argument is optional.  If not specified, the function will create and properly scale the mixing proportions for you.  If specified, the Mx Object that gives the mixing proportions should be a column vector (one-column matrix).
</p>


<h3>Value</h3>

<p>An MxModel.
</p>


<h3>See Also</h3>

<p><a href="#topic+emxLoadings">emxLoadings</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>   
# Factor Mixture Example
require(EasyMx)
data(myFADataRaw)
xmap1 &lt;- list(F1=paste0('x', 1:6), F2=paste0('y', 1:3), F3=paste0('z', 1:3))
mod1 &lt;- emxFactorModel(xmap1, data=myFADataRaw, name='m1')

xmap2 &lt;- list(F1=c(paste0('x', 1:6), paste0('y', 1:3), paste0('z', 1:3)))
mod2 &lt;- emxFactorModel(xmap2, data=myFADataRaw, name='m2')

mod &lt;- emxMixtureModel(list(mod1, mod2), data=myFADataRaw)
# To estimate parameters either
#  1. mod &lt;- mxRun(mod)   or
#  2. include run=TRUE in the arguments above
summary(mod)
coef(mod)

# Latent Profile Example
require(EasyMx)

m1 &lt;- omxSaturatedModel(demoOneFactor)[[1]]
m1 &lt;- mxRename(m1, 'profile1')

m2 &lt;- omxSaturatedModel(demoOneFactor)[[1]]
m2 &lt;- mxRename(m2, 'profile2')

mod &lt;- emxMixtureModel(list(m1, m2), data=demoOneFactor)
# To estimate parameters either
#  1. mod &lt;- mxRun(mod)   or
#  2. include run=TRUE in the arguments above
summary(mod)
coef(mod)

mxGetExpected(mod$profile1, 'covariance')
mxGetExpected(mod$profile1, 'means')
mxGetExpected(mod$profile2, 'covariance')
mxGetExpected(mod$profile2, 'means')


</code></pre>

<hr>
<h2 id='emxRegressionModel'>Create a regression model</h2><span id='topic+emxRegressionModel'></span><span id='topic+emxModelRegression'></span>

<h3>Description</h3>

<p>This function creates a regression model as an MxModel object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>emxRegressionModel(model, data, type='Steven', run, ...)
emxModelRegression(model, data, type='Steven', run, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="emxRegressionModel_+3A_model">model</code></td>
<td>
<p>formula.  See Details.</p>
</td></tr>
<tr><td><code id="emxRegressionModel_+3A_data">data</code></td>
<td>
<p>data used for the model</p>
</td></tr>
<tr><td><code id="emxRegressionModel_+3A_run">run</code></td>
<td>
<p>logical. Whether to run the model before returning.</p>
</td></tr>
<tr><td><code id="emxRegressionModel_+3A_type">type</code></td>
<td>
<p>character.  Either 'Steven' or 'Joshua'.  See Details.</p>
</td></tr>
<tr><td><code id="emxRegressionModel_+3A_...">...</code></td>
<td>
<p>Further named arguments to be passed to <code>lm</code> for the formula</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>model</code> argument is a formula identical to what is used in <code><a href="stats.html#topic+lm">lm</a></code>.
</p>
<p>The <code>type</code> argument switches the kind of regression model that is specified.  When there are no missing data, the two versions will estimate the same regression parameters but <code>type='Steven'</code> will estimate addition parameters that are not estimated by <code>type='Joshua'</code>.  The <code>type='Steven'</code> model is due to Steven Boker and many others.  It estimates more parameters than a typical regression analysis and has a different set of assumptions.  More exactly, <code>type='Steven'</code> models the outcome and all of the predictors as a multivariate Normal distribution.  By contrast, <code>type='Joshua'</code> is due to Joshua Pritikin and exactly replicates the typical regression model with its usual assumptions.  In particular, <code>type='Joshua'</code> models the regression residual as a univariate Normal distribution. Predictors are assumed to have no measurement error (see Westfall &amp; Yarkoni, 2016).
</p>
<p>The benefit of <code>type='Steven'</code> is that it handles missing data with
full-information maximum likelihood (FIML; Enders &amp; Bandalos, 2001), at the cost of using a different model with different assumptions from ordinary least squares regression.  The benefit of <code>type='Joshua'</code> is that it exactly replicates regression as a maximum likelhood model, at the cost of having the same weakness in terms of missing data as OLS regression.
</p>


<h3>Value</h3>

<p>An MxModel.
</p>


<h3>References</h3>

<p>Enders, C. K. &amp; Bandalos, D. L. (2001). The relative performance of full
information maximum likelihood estimation for missing data in structural
equation models. &lt;i&gt;Structural Equation Modeling, 8&lt;/i&gt;(3), 430-457.
</p>
<p>Westfall, J. &amp; Yarkoni, T. (2016). Statistically controlling for
confounding constructs is harder than you think. &lt;i&gt;PLoS ONE,
11&lt;/i&gt;(3). doi:10.1371/journal.pone.0152719 </p>


<h3>See Also</h3>

<p><a href="stats.html#topic+lm">lm</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>   
# Example
require(EasyMx)
data(myRegDataRaw)
myrdr &lt;- myRegDataRaw
myrdr[1, 4] &lt;- NA

## Not run: 
run &lt;- emxRegressionModel(y~1+x*z, data=myrdr, run=TRUE)
summary(run)

## End(Not run)

summary(lm(y~1+x*z, data=myrdr))



</code></pre>

<hr>
<h2 id='emxRelatednessMatrix'>Create a relatedness matrix</h2><span id='topic+emxRelatednessMatrix'></span>

<h3>Description</h3>

<p>This function creates a relatedness matrix as an MxMatrix, often used in behavior genetics modeling.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>emxRelatednessMatrix(nvar, values, labels, name='h')
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="emxRelatednessMatrix_+3A_nvar">nvar</code></td>
<td>
<p>numeric. The number of variables for the matrix, i.e. the number of rows or columns.</p>
</td></tr>
<tr><td><code id="emxRelatednessMatrix_+3A_values">values</code></td>
<td>
<p>numeric vector. Values used in the matrix.</p>
</td></tr>
<tr><td><code id="emxRelatednessMatrix_+3A_labels">labels</code></td>
<td>
<p>character vector. Labels of the elements in the matrix.  See Details.</p>
</td></tr>
<tr><td><code id="emxRelatednessMatrix_+3A_name">name</code></td>
<td>
<p>character. The name of the matrix created.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>labels</code> argument can be used to create a &quot;definition variable&quot; which populates the value from one of the data columns for each row in the data.  In this context, if the genetic relatedness coefficient between a pair of individuals is given by a column in the data then that information can be used to create in the relatedness matrix.  Alternatively, multiple groups can be created 
</p>


<h3>Value</h3>

<p>An MxMatrix object.
</p>


<h3>See Also</h3>

<p><a href="#topic+emxGeneticFactorVariance">emxGeneticFactorVariance</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>   
# Create a Cholesky variance matrix called 'A'
require(EasyMx)
ahmat &lt;- emxRelatednessMatrix(2, c(1, .5, 1), labels=c(NA, 'data.RCoef', NA), name='AH')
# data.RCoef creates a definition variable and ignores the .5 value.

</code></pre>

<hr>
<h2 id='emxResiduals'>Create a residual variances matrix</h2><span id='topic+emxResiduals'></span>

<h3>Description</h3>

<p>This function creates a factor loadings matrix as an MxMatrix or MxPath object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>emxResiduals(x, values=.2, free=TRUE, lbound=NA, ubound=NA, path=FALSE, type='unique')
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="emxResiduals_+3A_x">x</code></td>
<td>
<p>character vector. The names of the variables for which residual variances are created.</p>
</td></tr>
<tr><td><code id="emxResiduals_+3A_values">values</code></td>
<td>
<p>numeric vector. The starting values for the variances.</p>
</td></tr>
<tr><td><code id="emxResiduals_+3A_free">free</code></td>
<td>
<p>logical vector. Whether the variances are free.</p>
</td></tr>
<tr><td><code id="emxResiduals_+3A_lbound">lbound</code></td>
<td>
<p>numeric vector. Lower bounds for the variances.</p>
</td></tr>
<tr><td><code id="emxResiduals_+3A_ubound">ubound</code></td>
<td>
<p>numeric vector. Upper bounds for the variances.</p>
</td></tr>
<tr><td><code id="emxResiduals_+3A_path">path</code></td>
<td>
<p>logical. Whether to return the MxPath object instead of the MxMatrix.</p>
</td></tr>
<tr><td><code id="emxResiduals_+3A_type">type</code></td>
<td>
<p>character.  The kind of residual variance structure to create.  See Details.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Possible values for the <code>type</code> argument are 'unique' and 'identical'.  When <code>type='unique'</code>, each residual variances is a unique free parameter.  When <code>type='identical'</code>, all of the residual variances are given by a single free parameter.  In this case, all the residual variances are constrained to be equal.  However, no linear or non-liniear contraint function is used.  Rather, a single parameter occurs in multiple locations by using the same label.
</p>


<h3>Value</h3>

<p>Depending on the value of the <code>path</code> argument, either an MxMatrix or and MxPath object that can be inspected, modified, and/or included in MxModel objects.
</p>


<h3>See Also</h3>

<p><a href="#topic+emxFactorModel">emxFactorModel</a>, <a href="#topic+emxGrowthModel">emxGrowthModel</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>   
# Create a residual variance matrix
require(EasyMx)
manVars &lt;- paste0('x', 1:6)
emxResiduals(manVars, lbound=1e-6)
emxResiduals(manVars, type='identical')
emxResiduals(manVars, path=TRUE)

</code></pre>

<hr>
<h2 id='emxStateSpaceMixtureClassify'>Classify time series in a state space mixture model</h2><span id='topic+emxStateSpaceMixtureClassify'></span>

<h3>Description</h3>

<p>This function classifies time series (usually people) in a state space mixture model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>emxStateSpaceMixtureClassify(model)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="emxStateSpaceMixtureClassify_+3A_model">model</code></td>
<td>
<p>MxModel.  The output from <code><a href="#topic+emxStateSpaceMixtureModel">emxStateSpaceMixtureModel</a></code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>This is a helper function for state space mixture modeling.  The function will almost exclusively be used in conjunction with emxStateSpaceMixtureModel.  The present function takes a state space mixture model as input, and returns detailed information about the most likely class for each unique ID.
</p>


<h3>Value</h3>

<p>A named list with elements
</p>
<table>
<tr><td><code>estimated_classes</code></td>
<td>
<p>A vector of the most likely class for each person.  Dimension is people.</p>
</td></tr>
<tr><td><code>joint_m2ll</code></td>
<td>
<p>A matrix of joint minus two summed log likelihoods of each person <em>and</em> each class.  Dimension is people by classes.</p>
</td></tr>
<tr><td><code>m2ll</code></td>
<td>
<p>A matrix of minus two summed log likelihoods of each person <em>given</em> each class.  Dimension is people by classes.</p>
</td></tr>
<tr><td><code>likelihood</code></td>
<td>
<p>An array of the likelihoods (i.e., probability densities) of each combination of time point, person, and class.  Dimension is time points by people by classes.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><a href="#topic+emxStateSpaceMixtureModel">emxStateSpaceMixtureModel</a> , <a href="#topic+emxMixtureModel">emxMixtureModel</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>   
# Example
require(EasyMx)
data(myFADataRaw)

ds0 &lt;- myFADataRaw[,1:3]

# Make a VAR Model
vm &lt;- emxVARModel(data=ds0, use=names(ds0), name='varmodel')

# Re-label parameters to have different AR parameters
# for class 1 and class 2
vm1 &lt;- OpenMx::omxSetParameters(vm, labels=vm$Dynamics$labels,
    newlabels=paste0(vm$Dynamics$labels, '_k1'), name='klass1')
vm2 &lt;- OpenMx::omxSetParameters(vm, labels=vm$Dynamics$labels,
    newlabels=paste0(vm$Dynamics$labels, '_k2'), name='klass2')

# Pretend you have a data set of 50 people
# each measured 10 times on 3 variables
ds1 &lt;- myFADataRaw[, 1:3]
ds1$id &lt;- rep(1:50, each=nrow(myFADataRaw)/50)

## Not run: 
# Make the state space mixture model
ssmm &lt;- emxStateSpaceMixtureModel(model=list(vm1, vm2),
    data=ds1, ID='id')

# Fit model
ssmmr &lt;- mxRun(ssmm)

# Extract estimated classes and diagnostics
eclasses &lt;- emxStateSpaceMixtureClassify(ssmmr)

## End(Not run)

</code></pre>

<hr>
<h2 id='emxStateSpaceMixtureModel'>Create a state space mixture model</h2><span id='topic+emxStateSpaceMixtureModel'></span><span id='topic+emxModelStateSpaceMixture'></span>

<h3>Description</h3>

<p>This function creates a state space mixture model as an MxModel object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>emxStateSpaceMixtureModel(model, data, name, run=FALSE, use, ID, time, ...)
emxModelStateSpaceMixture(model, data, name, run=FALSE, use, ID, time, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="emxStateSpaceMixtureModel_+3A_model">model</code></td>
<td>
<p>list of MxModel objects, each of which should be a state space model</p>
</td></tr>
<tr><td><code id="emxStateSpaceMixtureModel_+3A_data">data</code></td>
<td>
<p>data used for the model</p>
</td></tr>
<tr><td><code id="emxStateSpaceMixtureModel_+3A_name">name</code></td>
<td>
<p>character.  Optional name of the model created.</p>
</td></tr>
<tr><td><code id="emxStateSpaceMixtureModel_+3A_run">run</code></td>
<td>
<p>logical. Whether to run the model before returning.</p>
</td></tr>
<tr><td><code id="emxStateSpaceMixtureModel_+3A_use">use</code></td>
<td>
<p>character vector.  The names of the variables to use.  Currently ignored.</p>
</td></tr>
<tr><td><code id="emxStateSpaceMixtureModel_+3A_id">ID</code></td>
<td>
<p>character.  Name of variable that identifies each unique person.</p>
</td></tr>
<tr><td><code id="emxStateSpaceMixtureModel_+3A_time">time</code></td>
<td>
<p>character.  Name of the variable that gives the time of each obsevation.  Currently ignored.</p>
</td></tr>
<tr><td><code id="emxStateSpaceMixtureModel_+3A_...">...</code></td>
<td>
<p>Force later arguments to be named.  ... is ignored.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The idea of state space mixture modeling is to model multiple, multivariate time series while allowing for qualitative differences between the time series.  Suppose you have a multivariate time series for several people.  You think some people should have the same time series model, but not everyone.  You think there should be a small number of homogeneous sets of people that follow the same time series model, but you do not know which people or the exact parameter values of the candidate time series models.  This function presents one solution to this problem.
</p>
<p>State space mixture modeling begins with a set of candidate state space models, and uses these state space models as the mixture classes.  The goal is to simultaneously estimate the free parameters of the state space models, and estimate which multivariate time series (e.g., perseon) belongs to which mixture class.
</p>
<p>The component state space models may share some free parameters or none.  Note that free parameters with the same name are constrained to be equal across all models.  Conversely, unnamed free parameters are given unique names and are allowed to differ for each person-mixture combination, which creates a very large number of free parameters.  We strongly encourage you to name all of your free parameters in the <code>model</code> list to avoid melting your computer's CPU.
</p>
<p>The <code>model</code> argument currently must be a list.  The elements of the list should be MxModel objects.  Each list element forms a mixture class in the final model.
</p>
<p>This function creates a multigroup mixture model where the mixture classes are the elements of the <code>model</code> list argument.  Each unique <code>ID</code> forms a group.
</p>
<p>The <code>data</code> argument can be a list of <code>data.frame</code> objects with one element for each <code>ID</code>, or a single <code>data.frame</code> with an <code>ID</code> variable that separates groups.
</p>


<h3>Value</h3>

<p>An MxModel.
</p>


<h3>See Also</h3>

<p><a href="#topic+emxStateSpaceMixtureClassify">emxStateSpaceMixtureClassify</a> , <a href="#topic+emxMixtureModel">emxMixtureModel</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>   
# Example
require(EasyMx)
data(myFADataRaw)

ds0 &lt;- myFADataRaw[,1:3]

# Make a VAR Model
vm &lt;- emxVARModel(data=ds0, use=names(ds0), name='varmodel')

# Re-label parameters to have different AR parameters
# for class 1 and class 2
vm1 &lt;- OpenMx::omxSetParameters(vm, labels=vm$Dynamics$labels,
    newlabels=paste0(vm$Dynamics$labels, '_k1'), name='klass1')
vm2 &lt;- OpenMx::omxSetParameters(vm, labels=vm$Dynamics$labels,
    newlabels=paste0(vm$Dynamics$labels, '_k2'), name='klass2')

# Pretend you have a data set of 50 people
# each measured 10 times on 3 variables
ds1 &lt;- myFADataRaw[, 1:3]
ds1$id &lt;- rep(1:50, each=nrow(myFADataRaw)/50)

## Not run: 
# Make and fit the state space mixture model
ssmm &lt;- emxStateSpaceMixtureModel(model=list(vm1, vm2),
    data=ds1, ID='id', run=TRUE)

## End(Not run)
</code></pre>

<hr>
<h2 id='emxThresholds'>Create a set of thresholds for ordinal data</h2><span id='topic+emxThresholds'></span>

<h3>Description</h3>

<p>This function creates a threshold matrix as an MxMatrix object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>emxThresholds(data, ordinalCols, deviation=TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="emxThresholds_+3A_data">data</code></td>
<td>
<p>The data frame or matrix for which thresholds should be created.</p>
</td></tr>
<tr><td><code id="emxThresholds_+3A_ordinalcols">ordinalCols</code></td>
<td>
<p>optional character vector.  The names of the ordinal variables in the data.</p>
</td></tr>
<tr><td><code id="emxThresholds_+3A_deviation">deviation</code></td>
<td>
<p>logical. Return the list of OpenMx objects needed for the deviation form of the threholds (default) or just the raw thresholds matrix</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An MxMatrix giving the thresholds.
</p>


<h3>See Also</h3>

<p><a href="#topic+emxFactorModel">emxFactorModel</a>, <a href="#topic+emxGrowthModel">emxGrowthModel</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>   
# Example
require(EasyMx)
data(jointdata)
jointdata[, c(2, 4, 5)] &lt;- mxFactor(jointdata[,c(2, 4, 5)],
	levels=sapply(jointdata[,c(2, 4, 5)], function(x){sort(unique(x))}))
emxThresholds(jointdata, c(FALSE, TRUE, FALSE, TRUE, TRUE))

</code></pre>

<hr>
<h2 id='emxTwinModel'>Creates behavior genetics Twin Model</h2><span id='topic+emxTwinModel'></span><span id='topic+emxModelTwin'></span>

<h3>Description</h3>

<p>This function creates an MxModel and associated objects for a basic Twin model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>emxTwinModel(model, relatedness, data, run=FALSE, use, name='model', components='ACE')
emxModelTwin(model, relatedness, data, run=FALSE, use, name='model', components='ACE')
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="emxTwinModel_+3A_model">model</code></td>
<td>
<p>Description of the model. Currently ignored.</p>
</td></tr>
<tr><td><code id="emxTwinModel_+3A_relatedness">relatedness</code></td>
<td>
<p>Description of the relatedness patterns.  Currently the name of the variable that gives the coefficient of relatedness.</p>
</td></tr>
<tr><td><code id="emxTwinModel_+3A_data">data</code></td>
<td>
<p>data.frame or matrix. The data set used in the model.</p>
</td></tr>
<tr><td><code id="emxTwinModel_+3A_run">run</code></td>
<td>
<p>logical. Whether to run the model before returning.</p>
</td></tr>
<tr><td><code id="emxTwinModel_+3A_use">use</code></td>
<td>
<p>character vector. Names of the variables used in the model.</p>
</td></tr>
<tr><td><code id="emxTwinModel_+3A_name">name</code></td>
<td>
<p>character. Name of the model.</p>
</td></tr>
<tr><td><code id="emxTwinModel_+3A_components">components</code></td>
<td>
<p>character. Name of the variance components to include. Current valid options are 'ACE' and 'ADE'</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Because the model argument is ignored and the relatedness argument has limited use, this function only constructs a very basic and rigid Twin model.  It creates a Cholesky model with A, C, and E components or a Cholesky model with A, D, and E components. The means are constrained equal across twins.
</p>


<h3>Value</h3>

<p>MxModel.
</p>


<h3>See Also</h3>

<p><a href="#topic+emxFactorModel">emxFactorModel</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>   
# Create an ACE model in 10 lines
# 8 of those are data handling.
# 2 are the actual model.
require(EasyMx)
require(OpenMx)
data(twinData)
twinVar = names(twinData)
selVars &lt;- c('ht1', 'bmi1','ht2','bmi2')
mzdzData &lt;- subset(twinData, zyg %in% c(1, 3), c(selVars, 'zyg'))
mzdzData$RCoef &lt;- c(1, NA, .5)[mzdzData$zyg]

## Not run: 
run3 &lt;- emxTwinModel(model='Cholesky', relatedness='RCoef',
	data=mzdzData, use=selVars, run=TRUE, name='TwCh')

## End(Not run)

</code></pre>

<hr>
<h2 id='emxVarianceComponents'>Creates Variance Components Model</h2><span id='topic+emxVarianceComponents'></span>

<h3>Description</h3>

<p>This function creates a variance components model as an MxModel object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>emxVarianceComponents(model, data, run)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="emxVarianceComponents_+3A_model">model</code></td>
<td>
<p>MxModel. See Details.</p>
</td></tr>
<tr><td><code id="emxVarianceComponents_+3A_data">data</code></td>
<td>
<p>matrix or data.frame. The used in the model</p>
</td></tr>
<tr><td><code id="emxVarianceComponents_+3A_run">run</code></td>
<td>
<p>logical. Whether to run the model before returning.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function does not really do anything currently.  Do not use it.
</p>


<h3>Value</h3>

<p>MxModel.
</p>


<h3>See Also</h3>

<p><a href="#topic+emxFactorModel">emxFactorModel</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>   
# Create a loadings matrix
require(EasyMx)


</code></pre>

<hr>
<h2 id='emxVARModel'>Create a vector autoregressive (VAR) model</h2><span id='topic+emxVARModel'></span><span id='topic+emxModelVAR'></span>

<h3>Description</h3>

<p>This function creates a vector autoregressive (VAR) model as an MxModel object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>emxVARModel(model, data, name, run=FALSE, use, ID)
emxModelVAR(model, data, name, run=FALSE, use, ID)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="emxVARModel_+3A_model">model</code></td>
<td>
<p>Currently ignored, but later will specify particular kinds of VAR models</p>
</td></tr>
<tr><td><code id="emxVARModel_+3A_data">data</code></td>
<td>
<p>data used for the model</p>
</td></tr>
<tr><td><code id="emxVARModel_+3A_name">name</code></td>
<td>
<p>character.  Optional name of the model created.</p>
</td></tr>
<tr><td><code id="emxVARModel_+3A_run">run</code></td>
<td>
<p>logical. Whether to run the model before returning.</p>
</td></tr>
<tr><td><code id="emxVARModel_+3A_use">use</code></td>
<td>
<p>character vector.  The names of the variables to use.  Currently ignored.</p>
</td></tr>
<tr><td><code id="emxVARModel_+3A_id">ID</code></td>
<td>
<p>character.  Name of variable that identifies each unique person.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The purpose of this function is to quickly specify a vector autoregressive model.  It is currently in the early stages of development and might change considerable with regard to the <code>model</code> argument and the <code>ID</code> argument.
</p>




<h3>Value</h3>

<p>An MxModel.
</p>


<h3>See Also</h3>

<p><a href="#topic+emxStateSpaceMixtureModel">emxStateSpaceMixtureModel</a> , <a href="#topic+emxFactorModel">emxFactorModel</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>   
# Example
require(EasyMx)
data(myFADataRaw)
ds0 &lt;- myFADataRaw[,1:3]

# Make a VAR Model
vm &lt;- emxVARModel(data=ds0, use=names(ds0), name='varmodel')
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
