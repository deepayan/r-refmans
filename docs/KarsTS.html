<!DOCTYPE html><html><head><title>Help for package KarsTS</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {KarsTS}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#aboutKTS'>
<p>aboutKTS: opens information file about KarsTS version</p></a></li>
<li><a href='#aggregateKTS'>
<p>aggregateKTS: creation of time series of aggregated values</p></a></li>
<li><a href='#anaSamPer'>
<p>anaSamper: analyzing sampling periods and gaps</p></a></li>
<li><a href='#applyGap2TSer'>
<p>applyGap2TSer: apply a gap set to a time series</p></a></li>
<li><a href='#applyTheiler'>
<p>applyTheiler: apply Theiler's window</p></a></li>
<li><a href='#are2TsTimeCompatible'>
<p>are2TsTimeCompatible: test time compatibility between two time series</p></a></li>
<li><a href='#areTsGapTimeCompatible'>
<p>areTsGapTimeCompatible: tests time compatibility between a time series and a gap set</p></a></li>
<li><a href='#areTsRmTimeCompatible'>
<p>areTsRmTimeCompatible: test time compatibility between a time series and a recurrence matrix</p></a></li>
<li><a href='#arimaKalman'>
<p>arimaKalman: ARIMA + Kalman smoother</p></a></li>
<li><a href='#arimaXKalman'>
<p>arimaXKalman: ARIMAX + Kalman smoother</p></a></li>
<li><a href='#assignMultiple'>
<p>assignMultiple: assign multiple</p></a></li>
<li><a href='#buttons1'>
<p>buttons1: create the buttons corresponding to the Time Series Menu</p></a></li>
<li><a href='#buttons2'>
<p>buttons2: create the buttons corresponding to the Gap Sets Menu</p></a></li>
<li><a href='#buttons3'>
<p>buttons3: create the buttons corresponding to the Analysis Menu</p></a></li>
<li><a href='#buttons4'>
<p>buttons4: create the buttons corresponding to the Plots Menu</p></a></li>
<li><a href='#buttons5'>
<p>buttons5: create the buttons corresponding to the Filling Menu</p></a></li>
<li><a href='#checkIfAny'>
<p>checkIfAny: check if there are any data sets in the environment</p></a></li>
<li><a href='#checkIfAnyGapOrTs'>
<p>checkIfAny: check if there are any time series or gap sets in the environment</p></a></li>
<li><a href='#checkIfAnyGapTs'>
<p>checkIfAny: check if there are any time series and gap sets in the environment</p></a></li>
<li><a href='#checkIfAnyRm'>
<p>checkIfAny: check if there is some recurrence matrix in the environment</p></a></li>
<li><a href='#checkIfAnyRmTs'>
<p>checkIfAnyRmTs: check if there is some recurrence matrix and some time series in the environment</p></a></li>
<li><a href='#checkIfAnyTs'>
<p>checkIfAnyTs: check if there is some time series in the environment</p></a></li>
<li><a href='#cleanEnvir'>
<p>cleanEnvir: removes a list of variables from KTSEnv</p></a></li>
<li><a href='#compareVecVec'>
<p>compareVecVec: compare the elements of two vectors</p></a></li>
<li><a href='#composeKTS'>
<p>composeKTS: perform operations on time series</p></a></li>
<li><a href='#createChb'>
<p>createChb: creates a check box on the main screen</p></a></li>
<li><a href='#createChbChb'>
<p>createChbChb: two column check box</p></a></li>
<li><a href='#createChbEntry'>
<p>createChbEntry: creates a check box with associated text entries</p></a></li>
<li><a href='#createCrossRM'>
<p>createCrossRM: creates a cross recurrence matrix</p></a></li>
<li><a href='#createCrossRMPlot'>
<p>createCrossRMPlot: creates a cross recurrence plot</p></a></li>
<li><a href='#createDistMatrix'>
<p>createDistMatrix: creates distance matrix</p></a></li>
<li><a href='#createEachRb'>
<p>createEachRb: creates a radiobutton on the main screen</p></a></li>
<li><a href='#createEntry'>
<p>createChb: creates a text entry on the main screen</p></a></li>
<li><a href='#createFAN'>
<p>createFAN: creates a fixed amount of neighbors (FAN) matrix.</p></a></li>
<li><a href='#createFANplot'>
<p>createFANplot: creates a plot from a fixed amount of neighbors (FAN) recurrence matrix</p></a></li>
<li><a href='#createGapChb'>
<p>createGapChb: creates a check box of gap sets</p></a></li>
<li><a href='#createGapRb'>
<p>createGapRb: creates a radio button of gap sets</p></a></li>
<li><a href='#createJointRM'>
<p>createJointRM: creates a joint recurrence matrix</p></a></li>
<li><a href='#createJointRMPlot'>
<p>createJointRMPlot: creates a cross recurrence plot</p></a></li>
<li><a href='#createNote'>
<p>createNote: creates a note on the input panel</p></a></li>
<li><a href='#createOK'>
<p>createOK: creates the OK or NEXT button on the input panel</p></a></li>
<li><a href='#createRandGaps'>
<p>createRandGaps: create random gaps in a time series</p></a></li>
<li><a href='#createRandName'>
<p>createRandName: creates a random name</p></a></li>
<li><a href='#createRb'>
<p>createRb: creates a radio button</p></a></li>
<li><a href='#createRmChb'>
<p>createRmChb: creates a check box of recurrence matrices</p></a></li>
<li><a href='#createRmRb'>
<p>createRmRb: creates a radiobutton of recurrence matrices</p></a></li>
<li><a href='#createSimpleRM'>
<p>createSimpleRM: creates a recurrence matrix</p></a></li>
<li><a href='#createSimpleRMPlot'>
<p>createSimpleRMPlot: creates a recurrence plot</p></a></li>
<li><a href='#createSpecGaps'>
<p>createSpecGaps: creates a specific gap in a time series</p></a></li>
<li><a href='#createSubPanR4C1'>
<p>createSubPanR4C1: creates the input panel on the main screen</p></a></li>
<li><a href='#createTitle'>
<p>createTitle: creates a title in the input panel</p></a></li>
<li><a href='#createTITLE'>
<p>createTITLE: create a title on the input panel</p></a></li>
<li><a href='#createTsChb'>
<p>createTsChb: creates a check box of time series</p></a></li>
<li><a href='#createTsRb'>
<p>createTsRb: creates a radiobutton of time series</p></a></li>
<li><a href='#cumuKTS'>
<p>cumuKTS: creates a cumulated time series</p></a></li>
<li><a href='#destroyMainScreen'>
<p>A function to destroy KarsTS main screen</p></a></li>
<li><a href='#destroyWelcome'>
<p>destroyWelcome: destroys KarsTS welcome screen</p></a></li>
<li><a href='#determinismKTS'>
<p>determinismKTS: estimate determinism</p></a></li>
<li><a href='#diffKTS'>
<p>diffKTS: calculate differences of a time series</p></a></li>
<li><a href='#E1dAndE2d'>
<p>E1dAndE2d: invariants E1(d) and E2(d)</p></a></li>
<li><a href='#embedData'>
<p>embedData: embeds a time series</p></a></li>
<li><a href='#endingLines'>
<p>endingLines: add three lines of asterisks on the output panel</p></a></li>
<li><a href='#exportall'>
<p>exportall: exports all types of data sets</p></a></li>
<li><a href='#fillWithTwins'>
<p>fillWithTwins: fills missing values using twin points</p></a></li>
<li><a href='#findDateFormat'>
<p>findDateFormat: finds the format of a set of dates</p></a></li>
<li><a href='#findTwins'>
<p>findTwins: finds twin points in a recurrence matrix</p></a></li>
<li><a href='#fnnKTS'>
<p>fnn: plots embedding dimendion vs false nearest neighbors</p></a></li>
<li><a href='#functToExport'>
<p>functToExport: functions to export</p></a></li>
<li><a href='#gamKTS'>
<p>A function to fill values by means of a generalized additive model</p></a></li>
<li><a href='#gapCheckedTF'>
<p>gapCheckedTF: identifies checked gap sets</p></a></li>
<li><a href='#gapDetect'>
<p>gapDetect: identifies the gap sets currently loaded</p></a></li>
<li><a href='#gapForSelMethod'>
<p>gapForSelMethod: gap set to fill</p></a></li>
<li><a href='#genGapExample'>
<p>A function to generate a gap set example</p></a></li>
<li><a href='#genRmExample'>
<p>A function to generate a recurrence matrix example</p></a></li>
<li><a href='#genTSExample'>
<p>A function to generate an example time series</p></a></li>
<li><a href='#getClassEnvir'>
<p>getClassEnvir: get objects of a class from an environment</p></a></li>
<li><a href='#getCoordsKTS'>
<p>getCoordsKTS: get coordinates from a plot</p></a></li>
<li><a href='#getCRP'>
<p>getCRP: gets the correlation probability of recurrence</p></a></li>
<li><a href='#getDelayCharTimes'>
<p>getDelayCharTimes: transforms dates from character to numeric.</p></a></li>
<li><a href='#getFANRM2'>
<p>getFANRM2: creates a fixed amount of neighbours (FAN) matrix via console.</p></a></li>
<li><a href='#getGapsAfterFill'>
<p>getGapsAfterFill: get the remaining gaps</p></a></li>
<li><a href='#getMaxNegSlope'>
<p>getMaxNegSlope: get the maximum negative slope</p></a></li>
<li><a href='#getMaxPosSlope'>
<p>getMaxPosSlope: get the maximum negative slope</p></a></li>
<li><a href='#getNAsGaps'>
<p>getNAsGaps: get the gaps in a time series</p></a></li>
<li><a href='#getNewGapsInd'>
<p>A function to create random gaps</p></a></li>
<li><a href='#getOtherErrEstim'>
<p>getOtherErrEstim: get some error estimates from a linear fit</p></a></li>
<li><a href='#getProTaos'>
<p>getProTaos:calculate the probability of recurrence</p></a></li>
<li><a href='#getRecurrencePoints'>
<p>A function to get recurrent points in a time series</p></a></li>
<li><a href='#getRollStatistics'>
<p>getRollStatistics: get rolling statistics</p>
It is used internally</a></li>
<li><a href='#getSamPerTable'>
<p>getSamPerTable: get sampling periods table</p></a></li>
<li><a href='#getSamPerTable.1Freq'>
<p>getSamPerTable.1Freq: get sampling periods table (time series with one frequency)</p></a></li>
<li><a href='#getScreenSize'>
<p>getScreenSize: gets the computer screen size</p></a></li>
<li><a href='#getStatistics'>
<p>getStatistics: calculates the statistics of a time series</p></a></li>
<li><a href='#getUniqueSampPer'>
<p>getUniqueSampPer: get unique sampling periods</p></a></li>
<li><a href='#goodnessFilling'>
<p>goodnessFilling: estimate the goodness of the filling</p></a></li>
<li><a href='#groupDates'>
<p>groupDates: groups dates</p></a></li>
<li><a href='#groupIndices'>
<p>groupIndices: group indices</p></a></li>
<li><a href='#histKTS'>
<p>histKTS: plots histogram</p></a></li>
<li><a href='#invariantsKTS'>
<p>invariantsKTS: invariant plots</p></a></li>
<li><a href='#isTimeAlright'>
<p>isTimeAlright: checks whether a set of dates fits KarsTS format</p></a></li>
<li><a href='#KarsTS'>
<p>KarsTS: launches KarsTS</p></a></li>
<li><a href='#KarsTS-package'>
<p>An Interface for Microclimate Time Series Analysis</p></a></li>
<li><a href='#laminarityKTS'>
<p>laminarityKTS: estimate laminarity</p></a></li>
<li><a href='#linCorrKTS'>
<p>linCorrKTS: linear correlation plot</p></a></li>
<li><a href='#linearityKTS'>
<p>linearityKTS: linearity tests</p></a></li>
<li><a href='#loadAllTypes'>
<p>loadAllTypes: load all types of data sets</p></a></li>
<li><a href='#loadKarsTSFonts'>
<p>loadKarsTSFonts: load KarsTS fonts</p></a></li>
<li><a href='#loessKTS'>
<p>loess: loess smoothing</p></a></li>
<li><a href='#mainScreen'>
<p>mainScreen: launches the main screen</p></a></li>
<li><a href='#meanValue'>
<p>meanValue: mean value filling</p></a></li>
<li><a href='#mergeTsOrGap'>
<p>mergeTsOrGap: merges time series or gap sets</p></a></li>
<li><a href='#missForestKTS'>
<p>missForestKTS: filling missing values with random forest algorithm</p></a></li>
<li><a href='#modeKTS'>
<p>modeKTS: computes the mode</p></a></li>
<li><a href='#mutInf'>
<p>mutInf: mutual information</p></a></li>
<li><a href='#mutualKTS'>
<p>mutualKTS: plots the mutual information</p></a></li>
<li><a href='#myApplyVector'>
<p>myApplyVector: apply type function</p></a></li>
<li><a href='#myLinModel'>
<p>myLinModel: performs a linear fit</p></a></li>
<li><a href='#myScale'>
<p>myScale: scaling function</p></a></li>
<li><a href='#naApproxKTS'>
<p>naApproxKTS: filling by linear interpolation</p></a></li>
<li><a href='#NAs4Resamp'>
<p>NAs4Resamp: upsamples a time series.</p></a></li>
<li><a href='#naSplinesKTS'>
<p>naSplinesKTS: filling by spline interpolation</p></a></li>
<li><a href='#normalityKTS'>
<p>normalityKTS: normality tests</p></a></li>
<li><a href='#packagesToImport'>
<p>packagesToImport: packages to import to KarsTS</p></a></li>
<li><a href='#pcaKTS'>
<p>pcaKTS: principal component analysis</p></a></li>
<li><a href='#plotTimeSeries'>
<p>plotTimeSeries: plot time series</p></a></li>
<li><a href='#readMultEntryvalues'>
<p>readMultEntryvalues: verifies multiple entry values</p></a></li>
<li><a href='#refreshDataSetsList'>
<p>refreshDataSetsList: refreshes KarsTS data set list</p></a></li>
<li><a href='#removeAllTypes'>
<p>removeAllTypes: removes data sets</p></a></li>
<li><a href='#removeIfExists'>
<p>removeIfExists: remove if exists</p></a></li>
<li><a href='#removePoints'>
<p>removePoints: graphically remove points from a time series</p></a></li>
<li><a href='#renameAllTypes'>
<p>renameAllTypes: rename all types of data sets</p></a></li>
<li><a href='#rmCheckedTF'>
<p>rmCheckedTF: identifies checked recurrence matrices</p></a></li>
<li><a href='#rmDetect'>
<p>rmDetect: identifies the recurrence matrices currently loaded</p></a></li>
<li><a href='#rmSlopeOutliers'>
<p>rmSlopeOutliers: slope filter</p></a></li>
<li><a href='#rollStatisticsKTS'>
<p>rollStatisticsKTS: rolling statistics</p></a></li>
<li><a href='#roundKTS'>
<p>roundKTS: rounding</p></a></li>
<li><a href='#RPKTS'>
<p>Recurrence of probability</p></a></li>
<li><a href='#saveAllTypes'>
<p>saveAllTypes: saves all types of data sets.</p></a></li>
<li><a href='#saveReport'>
<p>saveReport: saves report</p></a></li>
<li><a href='#scaleKTS'>
<p>scaleKTS: scale time series</p></a></li>
<li><a href='#scattTimeSeries'>
<p>A function for plotting time series in the phase space</p></a></li>
<li><a href='#selectionGaps'>
<p>selectionGaps: select gaps in a time series</p></a></li>
<li><a href='#selectionTS'>
<p>selectionTS</p></a></li>
<li><a href='#separateEntry'>
<p>separateEntry: separates and checks comma-separated entry values</p></a></li>
<li><a href='#setCorrectDate'>
<p>setCorrectDate: verifies date entry and returns proper output</p></a></li>
<li><a href='#setwdKTS'>
<p>setwdKTS: set working directory</p></a></li>
<li><a href='#showHelp'>
<p>showHelp: shows KarsTS help</p></a></li>
<li><a href='#slopeOutliersBut'>
<p>slopeOutliersBut: remove slope outliers</p></a></li>
<li><a href='#stationarityKTS'>
<p>stationarityKTS: stationarity tests</p></a></li>
<li><a href='#statisticsKTS'>
<p>statisticsKTS: calculates the statistics of one or more time series</p></a></li>
<li><a href='#stinemannKTS'>
<p>stinemannKTS: filling by Stinemann's interpolation</p></a></li>
<li><a href='#stlplusKTS'>
<p>stlplusKTS: loess seasonal decomposition</p></a></li>
<li><a href='#theilerKTS'>
<p>theilerKTS: apply Theiler's window via interface</p></a></li>
<li><a href='#tsCheckedTF'>
<p>tsCheckedTF: identifies checked time series</p></a></li>
<li><a href='#tsDetect'>
<p>tsDetect: identifies the time series currently loaded</p></a></li>
<li><a href='#verifyCharEntry'>
<p>verifyCharEntry: verify character entries</p></a></li>
<li><a href='#verifyDateEntry'>
<p>verifyDateEntry: verify date entries</p></a></li>
<li><a href='#verifyIntEntry'>
<p>verifyIntEntry: verify integer entries</p></a></li>
<li><a href='#verifyRealEntry'>
<p>verifyRealEntry: verify character entries</p></a></li>
<li><a href='#welcomeScreen'>
<p>welcomeScreen: launches the welcome screen</p></a></li>
<li><a href='#windRoseKTS'>
<p>windRoseKTS: wind rose</p></a></li>
<li><a href='#writeMethodSummary'>
<p>writeMethodSummary: writes a summary of the filling method</p></a></li>
<li><a href='#writeMethodTitle'>
<p>writeMethodTitle: writes a title on KarsTS output window</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>An Interface for Microclimate Time Series Analysis</td>
</tr>
<tr>
<td>Version:</td>
<td>2.4.1</td>
</tr>
<tr>
<td>Date:</td>
<td>2021-01-13</td>
</tr>
<tr>
<td>Author:</td>
<td>Marina Saez [aut, cre],
  David Benavente [ths],
  Soledad Cuezva [ths],
  Concepcion Pla [ctb]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Marina Saez &lt;marinasaez_andreu@hotmail.com&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>An R code with a GUI for microclimate time series, with an emphasis on underground environments. 'KarsTS' provides linear and nonlinear methods, including recurrence analysis (Marwan et al. (2007) &lt;<a href="https://doi.org/10.1016%2Fj.physrep.2006.11.001">doi:10.1016/j.physrep.2006.11.001</a>&gt;) and filling methods (Moffat et al. (2007) &lt;<a href="https://doi.org/10.1016%2Fj.agrformet.2007.08.011">doi:10.1016/j.agrformet.2007.08.011</a>&gt;), as well as tools to manipulate easily time series and gap sets.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>Note:</td>
<td>Please, cite this package as: Marina Saez (2021). KarsTS: An
Interface For Microclimate Time Series Analysis. R package
version 2.4.1.</td>
</tr>
<tr>
<td>Imports:</td>
<td>circular, MVN, tcltk, tcltk2, tseriesChaos, stlplus, tseries,
forecast, stinepack, missForest, nonlinearTseries, stats,
graphics, utils, zoo, grDevices, rgl, mgcv, infotheo, plot3D</td>
</tr>
<tr>
<td>Depends:</td>
<td>R(&ge; 3.5.0)</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2021-01-14 15:32:43 UTC; rs</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2021-01-14 20:50:05 UTC</td>
</tr>
</table>
<hr>
<h2 id='aboutKTS'>
aboutKTS: opens information file about KarsTS version
</h2><span id='topic+aboutKTS'></span>

<h3>Description</h3>

<p>This function opens a file containing information about KarsTS version
</p>


<h3>Author(s)</h3>

<p>Marina Saez Andreu
</p>

<hr>
<h2 id='aggregateKTS'>
aggregateKTS: creation of time series of aggregated values
</h2><span id='topic+aggregateKTS'></span>

<h3>Description</h3>

<p>This function creates time series of aggregated values.The user choses the inputs via interface: time series to aggregate, aggregation period, statistic, name for the output and NA treatment (see details).
</p>


<h3>Details</h3>

<p>The statistics available are: median, mean, minimum, maximum, standard deviation and sum.
The NA treatment can be: ignore or propagate. In the first case, the statistic is computed using the observations available in the window, as long as the window is not completely missing.In the second case, incomplete windows are assigned NA.
</p>


<h3>Value</h3>

<p>A time series of aggregated values appears in the environment KTSEnv
</p>


<h3>Author(s)</h3>

<p>Marina Saez Andreu
</p>

<hr>
<h2 id='anaSamPer'>
anaSamper: analyzing sampling periods and gaps
</h2><span id='topic+anaSamPer'></span>

<h3>Description</h3>

<p>Time series need to have a homogeneous sampling period for most calculations.This function divides a time series in homogeneous-sampling-period pieces that contain either observations or NAs.This information allows to decide how to resample the time series. Note that it also provides a list of gaps. 
</p>


<h3>Details</h3>

<p>Once chosen the time serie to analyze, KarsTS offers a list of possible sampling periods (time jumps in the time series), but a human decision is necessary to separate safely true sampling periods from gaps.Tipically, time jumps correspoding to sampling periods appear many times. 
</p>


<h3>Value</h3>

<p>A table containing the aforementioned information appears on KarsTS output window.
</p>


<h3>Author(s)</h3>

<p>Marina Saez Andreu
</p>

<hr>
<h2 id='applyGap2TSer'>
applyGap2TSer: apply a gap set to a time series
</h2><span id='topic+applyGap2TSer'></span>

<h3>Description</h3>

<p>This function applies a set of gaps to a time series.
</p>


<h3>Details</h3>

<p>The new time series name is a combination of the original time series and the gap set names.
</p>


<h3>Value</h3>

<p>A new time series with NAs at the locations indicated by the gap set
</p>


<h3>Author(s)</h3>

<p>Marina Saez Andreu
</p>

<hr>
<h2 id='applyTheiler'>
applyTheiler: apply Theiler's window
</h2><span id='topic+applyTheiler'></span>

<h3>Description</h3>

<p>It is used to apply a Theiler's window to a matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>applyTheiler(RM, thW)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="applyTheiler_+3A_rm">RM</code></td>
<td>

<p>The recurrence matrix, in KarsTS format
</p>
</td></tr>
<tr><td><code id="applyTheiler_+3A_thw">thW</code></td>
<td>

<p>The window, in lags from the diagonal
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A recurrence matrix, in KarsTS format, where the diagonals from the main diagonal up to the distance given by the window have been removed.
</p>


<h3>Author(s)</h3>

<p>Marina Saez Andreu
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
RM &lt;- genRmExample(InKTSEnv = FALSE,plotRM = FALSE)

RM1 &lt;- applyTheiler(RM,10)

</code></pre>

<hr>
<h2 id='are2TsTimeCompatible'>
are2TsTimeCompatible: test time compatibility between two time series
</h2><span id='topic+are2TsTimeCompatible'></span>

<h3>Description</h3>

<p>It checks for three types of compatibility: the initial dates are the same, the sampling period is the same and the final date is the same. It is used internally to check whether the inputs chosen by the user are appropiated.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>are2TsTimeCompatible (TS1, TS2)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="are2TsTimeCompatible_+3A_ts1">TS1</code></td>
<td>

<p>A time series
</p>
</td></tr>
<tr><td><code id="are2TsTimeCompatible_+3A_ts2">TS2</code></td>
<td>

<p>Another time series
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A logical vector, which is c(TRUE, TRUE, TRUE) when all the time compatibilty conditions are met.
</p>


<h3>Author(s)</h3>

<p>Marina Saez Andreu
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Generate two time series
TS1 &lt;- genTSExample(InKTSEnv = FALSE)
TS2 &lt;- genTSExample(InKTSEnv = FALSE)

## Their times are identical
timeComp &lt;- are2TsTimeCompatible (TS1, TS2)
timeComp

## We modifify the time of TS2. Now their starts are different,
## although they still have same sampling period and length
TS2$time &lt;- TS2$time + 1
timeComp &lt;- are2TsTimeCompatible (TS1,  TS2)
timeComp

</code></pre>

<hr>
<h2 id='areTsGapTimeCompatible'>
areTsGapTimeCompatible: tests time compatibility between a time series and a gap set
</h2><span id='topic+areTsGapTimeCompatible'></span>

<h3>Description</h3>

<p>It checks for three types of compatibility: the initial dates are the same, the sampling period is the same and the length is the same. It is used internally to check whether the inputs chosen by the user are appropiated.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>areTsGapTimeCompatible(TS1, GAP1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="areTsGapTimeCompatible_+3A_ts1">TS1</code></td>
<td>

<p>A time series
</p>
</td></tr>
<tr><td><code id="areTsGapTimeCompatible_+3A_gap1">GAP1</code></td>
<td>

<p>A gap set
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A logical vector, which is c(TRUE, TRUE, TRUE) when all the time compatibilty conditions are met.
</p>


<h3>Author(s)</h3>

<p>Marina Saez Andreu
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Generate a time series
TS &lt;- genTSExample(InKTSEnv = FALSE)
## Generate a gap set consisiting of four gaps of 3 NAs each
GS &lt;- genGapExample(TS, 3, 4, InKTSEnv = FALSE)

## They are obviously compatible since we use TS to create GS
timeComp &lt;- areTsGapTimeCompatible (TS, GS)
timeComp

## We modifify the time of TS. The initial dates are not compatible anymore,
## although the sampling period and the length remain untouched.
TS$time &lt;- TS$time + 1
timeComp &lt;-  areTsGapTimeCompatible (TS, GS)
timeComp

</code></pre>

<hr>
<h2 id='areTsRmTimeCompatible'>
areTsRmTimeCompatible: test time compatibility between a time series and a recurrence matrix
</h2><span id='topic+areTsRmTimeCompatible'></span>

<h3>Description</h3>

<p>It checks for three types of compatibility: the initial dates are the same, the sampling period is the same and the length is the same. It is used internally to check whether the inputs chosen by the user are appropiated.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>areTsRmTimeCompatible(TS1, RM1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="areTsRmTimeCompatible_+3A_ts1">TS1</code></td>
<td>

<p>A time series
</p>
</td></tr>
<tr><td><code id="areTsRmTimeCompatible_+3A_rm1">RM1</code></td>
<td>

<p>A recurrence matrix
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A logical vector, which is c(TRUE, TRUE, TRUE) when all the time compatibilty conditions are met.
</p>


<h3>Author(s)</h3>

<p>Marina Saez Andreu
</p>

<hr>
<h2 id='arimaKalman'>
arimaKalman: ARIMA + Kalman smoother
</h2><span id='topic+arimaKalman'></span>

<h3>Description</h3>

<p>This function fits an ARIMA model to a univariate time series and uses the model to feed a Kalman smoother, which is used to fill missing values in the time series. It is used through the ARIMA button in the Filling Menu.
</p>


<h3>Details</h3>

<p>This function input panel contains a button called &quot;Estimate ARIMA parameters&quot;; this button calls the function forecast::auto.arima to provide an automatic estimation of the ARIMA parameters.These parameters can also be directly introduced by the user.
Optionally, the filling can be applied only to a set of gaps in the time series.
If the time series does not contain any NAs, KarsTS will fit the ARIMA model anyway and return the parameters. 
</p>


<h3>Value</h3>

<p>The filled time series appears in the environment susEnv
</p>


<h3>Author(s)</h3>

<p>Marina Saez Andreu
</p>

<hr>
<h2 id='arimaXKalman'>
arimaXKalman: ARIMAX + Kalman smoother
</h2><span id='topic+arimaXKalman'></span>

<h3>Description</h3>

<p>This function fits an ARIMAX model to a time series and uses the model to feed a Kalman smoother, which is used to fill missing values in the time series. It is used through the ARIMAX button in the Filling Menu.
</p>


<h3>Details</h3>

<p>The only difference between this function and arimaKalman is that arimaXKalman allows the introduction of regressor variables in the model.
See arimaKalman for more details.
</p>


<h3>Value</h3>

<p>The filled time series appears in the environment susEnv
</p>


<h3>Author(s)</h3>

<p>Marina Saez Andreu
</p>

<hr>
<h2 id='assignMultiple'>
assignMultiple: assign multiple
</h2><span id='topic+assignMultiple'></span>

<h3>Description</h3>

<p>This function applies the function assign multiple times
</p>


<h3>Usage</h3>

<pre><code class='language-R'>assignMultiple(namesVector, valuesList, envir = KTSEnv)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="assignMultiple_+3A_namesvector">namesVector</code></td>
<td>

<p>A vector containing the names to be assigned
</p>
</td></tr>
<tr><td><code id="assignMultiple_+3A_valueslist">valuesList</code></td>
<td>

<p>The values to which the names will be assigned
</p>
</td></tr>
<tr><td><code id="assignMultiple_+3A_envir">envir</code></td>
<td>

<p>The environment
</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Marina Saez Andreu
</p>

<hr>
<h2 id='buttons1'>
buttons1: create the buttons corresponding to the Time Series Menu
</h2><span id='topic+buttons1'></span>

<h3>Description</h3>

<p>This function creates the buttons corresponding to the Time Series Menu
</p>


<h3>Author(s)</h3>

<p>Marina Saez Andreu
</p>

<hr>
<h2 id='buttons2'>
buttons2: create the buttons corresponding to the Gap Sets Menu
</h2><span id='topic+buttons2'></span>

<h3>Description</h3>

<p>This function creates the buttons corresponding to the Gap Set Menu
</p>


<h3>Author(s)</h3>

<p>Marina Saez Andreu
</p>

<hr>
<h2 id='buttons3'>
buttons3: create the buttons corresponding to the Analysis Menu
</h2><span id='topic+buttons3'></span>

<h3>Description</h3>

<p>This function creates the buttons corresponding to the Analysis Menu
</p>


<h3>Author(s)</h3>

<p>Marina Saez Andreu
</p>

<hr>
<h2 id='buttons4'>
buttons4: create the buttons corresponding to the Plots Menu
</h2><span id='topic+buttons4'></span>

<h3>Description</h3>

<p>This function creates the buttons corresponding to the Plots Menu
</p>


<h3>Author(s)</h3>

<p>Marina Saez Andreu
</p>

<hr>
<h2 id='buttons5'>
buttons5: create the buttons corresponding to the Filling Menu
</h2><span id='topic+buttons5'></span>

<h3>Description</h3>

<p>This function creates the buttons corresponding to the Filling Menu
</p>


<h3>Author(s)</h3>

<p>Marina Saez Andreu
</p>

<hr>
<h2 id='checkIfAny'>
checkIfAny: check if there are any data sets in the environment
</h2><span id='topic+checkIfAny'></span>

<h3>Description</h3>

<p>This functions checks whether there are any data sets (time series, gap sets or recurrence matrices) in the environment (KTSEnv). If it is the case, it launches a function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>checkIfAny(action = NULL, envirName = KTSEnv)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="checkIfAny_+3A_action">action</code></td>
<td>

<p>The function to be launched
</p>
</td></tr>
<tr><td><code id="checkIfAny_+3A_envirname">envirName</code></td>
<td>

<p>The environment where the data sets are to be found
</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Marina Saez Andreu
</p>

<hr>
<h2 id='checkIfAnyGapOrTs'>
checkIfAny: check if there are any time series or gap sets in the environment
</h2><span id='topic+checkIfAnyGapOrTs'></span>

<h3>Description</h3>

<p>This functions checks whether there are any time series or gap sets in the environment (KTSEnv). If it is the case, it launches a function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>checkIfAnyGapOrTs(action = NULL, envirName = KTSEnv)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="checkIfAnyGapOrTs_+3A_action">action</code></td>
<td>

<p>The function to be launched
</p>
</td></tr>
<tr><td><code id="checkIfAnyGapOrTs_+3A_envirname">envirName</code></td>
<td>

<p>The environment where the data sets are to be found
</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Marina Saez Andreu
</p>

<hr>
<h2 id='checkIfAnyGapTs'>
checkIfAny: check if there are any time series and gap sets in the environment
</h2><span id='topic+checkIfAnyGapTs'></span>

<h3>Description</h3>

<p>This functions checks whether there are any time series and gap sets in the environment (KTSEnv). If it is the case, it launches a function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>checkIfAnyGapTs(action = NULL, envirName = KTSEnv)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="checkIfAnyGapTs_+3A_action">action</code></td>
<td>

<p>The function to be launched
</p>
</td></tr>
<tr><td><code id="checkIfAnyGapTs_+3A_envirname">envirName</code></td>
<td>

<p>The environment where the data sets are to be found
</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Marina Saez Andreu
</p>

<hr>
<h2 id='checkIfAnyRm'>
checkIfAny: check if there is some recurrence matrix in the environment
</h2><span id='topic+checkIfAnyRm'></span>

<h3>Description</h3>

<p>This functions checks whether there are any recurrence matrices in the environment (KTSEnv). If it is the case, it launches a function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>checkIfAnyRm(action = NULL, envirName = KTSEnv)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="checkIfAnyRm_+3A_action">action</code></td>
<td>

<p>The function to be launched
</p>
</td></tr>
<tr><td><code id="checkIfAnyRm_+3A_envirname">envirName</code></td>
<td>

<p>The environment where the data sets are to be found
</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Marina Saez Andreu
</p>

<hr>
<h2 id='checkIfAnyRmTs'>
checkIfAnyRmTs: check if there is some recurrence matrix and some time series in the environment
</h2><span id='topic+checkIfAnyRmTs'></span>

<h3>Description</h3>

<p>This functions checks whether there are any recurrence matrices and time seriesin the environment (KTSEnv). If it is the case, it launches a function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>checkIfAnyRmTs(action = NULL, envirName = KTSEnv)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="checkIfAnyRmTs_+3A_action">action</code></td>
<td>

<p>The function to be launched
</p>
</td></tr>
<tr><td><code id="checkIfAnyRmTs_+3A_envirname">envirName</code></td>
<td>

<p>The environment where the data sets are to be found
</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Marina Saez Andreu
</p>

<hr>
<h2 id='checkIfAnyTs'>
checkIfAnyTs: check if there is some time series in the environment
</h2><span id='topic+checkIfAnyTs'></span>

<h3>Description</h3>

<p>This functions checks whether there are any time seriesin the environment (KTSEnv). If it is the case, it launches a function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>checkIfAnyTs(action = NULL, envirName = KTSEnv)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="checkIfAnyTs_+3A_action">action</code></td>
<td>

<p>The function to be launched
</p>
</td></tr>
<tr><td><code id="checkIfAnyTs_+3A_envirname">envirName</code></td>
<td>

<p>The environment where the data sets are to be found
</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Marina Saez Andreu
</p>

<hr>
<h2 id='cleanEnvir'>
cleanEnvir: removes a list of variables from KTSEnv
</h2><span id='topic+cleanEnvir'></span>

<h3>Description</h3>

<p>In order to communicate the functions in an interface, it is often unavoidable to create global variables. This function cleans the global variables that are mere intermediate results of the prodecures.It is used internally 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cleanEnvir(envir = KTSEnv)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cleanEnvir_+3A_envir">envir</code></td>
<td>

<p>The environment where the intermediate objects are to be removed.It defaults to KTSEnv. 
</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Marina Saez Andreu
</p>

<hr>
<h2 id='compareVecVec'>
compareVecVec: compare the elements of two vectors
</h2><span id='topic+compareVecVec'></span>

<h3>Description</h3>

<p>Checks whether there are any shared elements between two vectors.It is used internally
</p>


<h3>Usage</h3>

<pre><code class='language-R'>compareVecVec(VA, VB)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="compareVecVec_+3A_va">VA</code></td>
<td>

<p>One vector
</p>
</td></tr>
<tr><td><code id="compareVecVec_+3A_vb">VB</code></td>
<td>

<p>Another vector
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A logical matrix showing the coincidences
</p>


<h3>Author(s)</h3>

<p>Marina Saez Andreu
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
compareVecVec(1:10, 7:12)

V1 &lt;- c("Apples", "Strawberries","Watermelon")
V2 &lt;- c("Ananas", "Apples", "Strawberries", "Coconut")
compareVecVec(V1,V2)

</code></pre>

<hr>
<h2 id='composeKTS'>
composeKTS: perform operations on time series
</h2><span id='topic+composeKTS'></span>

<h3>Description</h3>

<p>This function allows to perform a number of operations on the values of the time series.The operations currently available are: sum, multiplication, opposite, reciprocal and natural logarithm. It is used through the Operations button in the Analysis Menu
</p>


<h3>Details</h3>

<p>Opposite, inverse and logarithm can be applied simultaneously to N time series. The output consists of N output time series the names of which are assigned by default (original names plus Opp, Recip or Ln).
On the contrary, the output of sum and multiplication is a single time series and the user must choose its name.
</p>


<h3>Value</h3>

<p>The output time series in the environment KTSEnv
</p>


<h3>Author(s)</h3>

<p>Marina Saez Andreu
</p>

<hr>
<h2 id='createChb'>
createChb: creates a check box on the main screen
</h2><span id='topic+createChb'></span>

<h3>Description</h3>

<p>This function creates a check box on the main screen
</p>


<h3>Usage</h3>

<pre><code class='language-R'>createChb(labTitle = NULL, variableName = NULL, defaultVal = "0")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="createChb_+3A_labtitle">labTitle</code></td>
<td>

<p>A title for the check box
</p>
</td></tr>
<tr><td><code id="createChb_+3A_variablename">variableName</code></td>
<td>

<p>A name for the variable associated to the check box
</p>
</td></tr>
<tr><td><code id="createChb_+3A_defaultval">defaultVal</code></td>
<td>

<p>Default value (defaults to not selected)
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A variable that will be passed to the corresponding OnOk function
</p>


<h3>Author(s)</h3>

<p>Marina Saez Andreu
</p>

<hr>
<h2 id='createChbChb'>
createChbChb: two column check box
</h2><span id='topic+createChbChb'></span>

<h3>Description</h3>

<p>createChbChb: creates a two column check box on the main screen
</p>


<h3>Usage</h3>

<pre><code class='language-R'>createChbChb(ind, elements, prefix1 = NULL, prefix2 = NULL, envir = KTSEnv)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="createChbChb_+3A_ind">ind</code></td>
<td>

<p>Number of rows of the check box
</p>
</td></tr>
<tr><td><code id="createChbChb_+3A_elements">elements</code></td>
<td>

<p>Row labels
</p>
</td></tr>
<tr><td><code id="createChbChb_+3A_prefix1">prefix1</code></td>
<td>

<p>A prefix to assign a name to the output variables (column 1)
</p>
</td></tr>
<tr><td><code id="createChbChb_+3A_prefix2">prefix2</code></td>
<td>

<p>A prefix to assign a name to the output variables (column 2)
</p>
</td></tr>
<tr><td><code id="createChbChb_+3A_envir">envir</code></td>
<td>

<p>Enviroment to which the output variables will be assigned
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An output variable for each box. They are be passed to the corresponding onOk function
</p>


<h3>Author(s)</h3>

<p>Marina Saez Andreu
</p>

<hr>
<h2 id='createChbEntry'>
createChbEntry: creates a check box with associated text entries
</h2><span id='topic+createChbEntry'></span>

<h3>Description</h3>

<p>This function creates an element in the input panel consisting of two columns: a check box and the corresponding text entries. It is used internally
</p>


<h3>Usage</h3>

<pre><code class='language-R'>createChbEntry(ind, elements, prefix = "scbValue", envir = KTSEnv, dCh = "0", dEn = "")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="createChbEntry_+3A_ind">ind</code></td>
<td>

<p>Number of rows
</p>
</td></tr>
<tr><td><code id="createChbEntry_+3A_elements">elements</code></td>
<td>

<p>Row labels
</p>
</td></tr>
<tr><td><code id="createChbEntry_+3A_prefix">prefix</code></td>
<td>

<p>A prefix to assign names to the output variables
</p>
</td></tr>
<tr><td><code id="createChbEntry_+3A_envir">envir</code></td>
<td>

<p>Environment (defaults to the environment KTSEnv)
</p>
</td></tr>
<tr><td><code id="createChbEntry_+3A_dch">dCh</code></td>
<td>

<p>Default value for the checkbox
</p>
</td></tr>
<tr><td><code id="createChbEntry_+3A_den">dEn</code></td>
<td>

<p>Default value for the text entry
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Variables that will be passed to the corresponding OnOk function
</p>


<h3>Author(s)</h3>

<p>Marina Saez Andreu
</p>

<hr>
<h2 id='createCrossRM'>
createCrossRM: creates a cross recurrence matrix
</h2><span id='topic+createCrossRM'></span>

<h3>Description</h3>

<p>This function creates a cross recurrence matrix. It is used through the Cross Recurrence Matrix button in the Analysis Menu
</p>


<h3>Details</h3>

<p>The inputs are two time series representing similar variables (for example, two air temperature time series). They must have the same sampling period, although they can have different lengths.
The matrix can be visualized by means of the Plot Cross Recurrence Matrix button in the Plots Menu
</p>


<h3>Value</h3>

<p>A cross recurrence matrix in the environment susEnv. Cross recurrence matrices are not symmetrical, therefore the entire matrix is stored (not only a triangle).
</p>


<h3>Author(s)</h3>

<p>Marina Saez Andreu
</p>


<h3>References</h3>

<p>Marwan,R., Romano, M.C., Thiel,M., Kurths,J.(2007): Recurrence plots for the analysis of complex systems. Physics Reports 438, 237-329.
</p>

<hr>
<h2 id='createCrossRMPlot'>
createCrossRMPlot: creates a cross recurrence plot
</h2><span id='topic+createCrossRMPlot'></span>

<h3>Description</h3>

<p>This function creates a cross recurrence plot from a previously created cross recurrence matrix. It is used through the Plot Cross Recurrence Plot in the Plots Menu
</p>


<h3>Author(s)</h3>

<p>Marina Saez Andreu
</p>


<h3>References</h3>

<p>Marwan,R., Romano, M.C., Thiel,M., Kurths,J.(2007): Recurrence plots for the analysis of complex systems. Physics Reports 438, 237-329.
</p>

<hr>
<h2 id='createDistMatrix'>
createDistMatrix: creates distance matrix
</h2><span id='topic+createDistMatrix'></span>

<h3>Description</h3>

<p>This function calculates and plots a distance matrix via interface.
</p>


<h3>Details</h3>

<p>A distance matrix is an unthresholded recurrence matrix.The norm can be Euclidean or Infinity.  
</p>


<h3>Author(s)</h3>

<p>Marina Saez Andreu
</p>

<hr>
<h2 id='createEachRb'>
createEachRb: creates a radiobutton on the main screen
</h2><span id='topic+createEachRb'></span>

<h3>Description</h3>

<p>This function creates a radiobutton. It is used internally
</p>


<h3>Usage</h3>

<pre><code class='language-R'>createEachRb(labTitle = NULL, variable = NULL, panel = KTSEnv$subPanR4C1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="createEachRb_+3A_labtitle">labTitle</code></td>
<td>

<p>A title for the check box
</p>
</td></tr>
<tr><td><code id="createEachRb_+3A_variable">variable</code></td>
<td>

<p>The variable associated to the radiobutton
</p>
</td></tr>
<tr><td><code id="createEachRb_+3A_panel">panel</code></td>
<td>

<p>The panel where the radiobutton is to be placed (defaults to the input panel in the main screen)
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A variable that will be passed to the corresponding OnOk function
</p>


<h3>Author(s)</h3>

<p>Marina Saez Andreu
</p>

<hr>
<h2 id='createEntry'>
createChb: creates a text entry on the main screen
</h2><span id='topic+createEntry'></span>

<h3>Description</h3>

<p>This function creates a text entry on the input panel (on the main screen)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>createEntry(labTitle, textVariableName, defaultVal = "", font = KTSEnv$KTSFonts$T1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="createEntry_+3A_labtitle">labTitle</code></td>
<td>

<p>The text entry title
</p>
</td></tr>
<tr><td><code id="createEntry_+3A_textvariablename">textVariableName</code></td>
<td>

<p>The name of the variable associated to the text entry
</p>
</td></tr>
<tr><td><code id="createEntry_+3A_defaultval">defaultVal</code></td>
<td>

<p>Default value (empty entry)
</p>
</td></tr>
<tr><td><code id="createEntry_+3A_font">font</code></td>
<td>

<p>Title font
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A variable that will be passed to the corresponding OnOk function
</p>


<h3>Author(s)</h3>

<p>Marina Saez Andreu
</p>

<hr>
<h2 id='createFAN'>
createFAN: creates a fixed amount of neighbors (FAN) matrix.
</h2><span id='topic+createFAN'></span>

<h3>Description</h3>

<p>This function creates a fixed amount of neighbours (FAN) recurrence matrix. It is used through the FAN Recurrence Matrix button in the Analysis Menu.
</p>


<h3>Details</h3>

<p>The FAN recurrence matrix can be created from an existing matrix; in this case, only the closest neighbors are kept.The FAN recurrence matrix can be created directly from a time series. In this case, the embedding dimension, delay, tolerance, Theiler's window and fixed amount of neighbours must be provided via interface.
The matrix can be visualized by means of the FAN Recurrence Plot button in the Plots Menu.
Note that FAN recurrence matrices are not symmetric.
</p>


<h3>Author(s)</h3>

<p>Marina Saez Andreu
</p>


<h3>References</h3>

<p>Marwan,R., Romano, M.C., Thiel,M., Kurths,J.(2007): Recurrence plots for the analysis of complex systems. Physics Reports 438, 237-329.
</p>

<hr>
<h2 id='createFANplot'>
createFANplot: creates a plot from a fixed amount of neighbors (FAN) recurrence matrix
</h2><span id='topic+createFANplot'></span>

<h3>Description</h3>

<p>This function creates a recurrence plot from a previously created fixed amount of neighbors (FAN) recurrence matrix.
</p>


<h3>Author(s)</h3>

<p>Marina Saez Andreu
</p>


<h3>References</h3>

<p>Marwan,R., Romano, M.C., Thiel,M., Kurths,J.(2007): Recurrence plots for the analysis of complex systems. Physics Reports 438, 237-329.
</p>

<hr>
<h2 id='createGapChb'>
createGapChb: creates a check box of gap sets
</h2><span id='topic+createGapChb'></span>

<h3>Description</h3>

<p>This function creates a check box showing all the gap sets available. It is used internally
</p>


<h3>Usage</h3>

<pre><code class='language-R'>createGapChb(labTitle = "Gap sets", envir = KTSEnv)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="createGapChb_+3A_labtitle">labTitle</code></td>
<td>

<p>Title for the check box
</p>
</td></tr>
<tr><td><code id="createGapChb_+3A_envir">envir</code></td>
<td>

<p>Environment
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Variables to be passed to the corresponding OnOk function
</p>


<h3>Author(s)</h3>

<p>Marina Saez Andreu
</p>

<hr>
<h2 id='createGapRb'>
createGapRb: creates a radio button of gap sets
</h2><span id='topic+createGapRb'></span>

<h3>Description</h3>

<p>This function creates a radiobutton showing all the gap sets available
</p>


<h3>Usage</h3>

<pre><code class='language-R'>createGapRb(labTitle = "Gap sets", envir = KTSEnv)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="createGapRb_+3A_labtitle">labTitle</code></td>
<td>

<p>Title for the check box
</p>
</td></tr>
<tr><td><code id="createGapRb_+3A_envir">envir</code></td>
<td>

<p>Environment
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A variable to be passed to the corresponding OnOk function
</p>


<h3>Author(s)</h3>

<p>Marina Saez Andreu
</p>

<hr>
<h2 id='createJointRM'>
createJointRM: creates a joint recurrence matrix
</h2><span id='topic+createJointRM'></span>

<h3>Description</h3>

<p>This function creates a joint recurrence matrix. It is used through the Joint Recurrence Matrix button in the Analysis Menu
</p>


<h3>Details</h3>

<p>The inputs are two time series. They must have the same sampling period. The shorter one will determine the size of the recurrence matrix.
The matrix can be visualized by means of the Plot Joint Recurrence Matrix button in the Plots Menu
</p>


<h3>Value</h3>

<p>A joint recurrence matrix in the environment susEnv
</p>


<h3>Author(s)</h3>

<p>Marina Saez Andreu
</p>


<h3>References</h3>

<p>Marwan,R., Romano, M.C., Thiel,M., Kurths,J.(2007): Recurrence plots for the analysis of complex systems. Physics Reports 438, 237-329.
</p>

<hr>
<h2 id='createJointRMPlot'>
createJointRMPlot: creates a cross recurrence plot
</h2><span id='topic+createJointRMPlot'></span>

<h3>Description</h3>

<p>This function creates a joint recurrence plot from a previously created joint recurrence matrix. It is used through the Plot Joint Recurrence Plot in the Plots Menu
</p>


<h3>Author(s)</h3>

<p>Marina Saez Andreu
</p>


<h3>References</h3>

<p>Marwan,R., Romano, M.C., Thiel,M., Kurths,J.(2007): Recurrence plots for the analysis of complex systems. Physics Reports 438, 237-329.
</p>

<hr>
<h2 id='createNote'>
createNote: creates a note on the input panel
</h2><span id='topic+createNote'></span>

<h3>Description</h3>

<p>This function creates a note on the input panel
</p>


<h3>Usage</h3>

<pre><code class='language-R'>createNote(labTitle = NULL, pady = c(10, 10))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="createNote_+3A_labtitle">labTitle</code></td>
<td>

<p>Text
</p>
</td></tr>
<tr><td><code id="createNote_+3A_pady">pady</code></td>
<td>

<p>Upper and lower margins
</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Marina Saez andreu
</p>

<hr>
<h2 id='createOK'>
createOK: creates the OK or NEXT button on the input panel
</h2><span id='topic+createOK'></span>

<h3>Description</h3>

<p>This function creates the OK or NEXT button on the input panel.When the button is pressed the corresponding function is launched.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>createOK(labTitle = "NEXT", action = NULL, width = 7, panel = KTSEnv$subPanR4C1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="createOK_+3A_labtitle">labTitle</code></td>
<td>

<p>Usually, its values are &quot;OK&quot; or &quot;NEXT&quot;
</p>
</td></tr>
<tr><td><code id="createOK_+3A_action">action</code></td>
<td>

<p>Function that will be launched when the button is pressed.
</p>
</td></tr>
<tr><td><code id="createOK_+3A_width">width</code></td>
<td>

<p>Button width
</p>
</td></tr>
<tr><td><code id="createOK_+3A_panel">panel</code></td>
<td>

<p>Panel were the button will be placed
</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Marina Saez Andreu
</p>

<hr>
<h2 id='createRandGaps'>
createRandGaps: create random gaps in a time series
</h2><span id='topic+createRandGaps'></span>

<h3>Description</h3>

<p>This function creates N gaps of length M, randomly distributed through a time series. The inputs are the time series, the number of gaps and their length. It is used through the Random Gaps button in the Gap Sets menu.
</p>


<h3>Details</h3>

<p>The new gaps will not overlay previously existing gaps.
</p>


<h3>Value</h3>

<p>The function creates a gap set and applies it to a copy of the input time series.Both the gap set and the new time series appear in the environment susEnv.   
</p>


<h3>Author(s)</h3>

<p>Marina Saez Andreu
</p>

<hr>
<h2 id='createRandName'>
createRandName: creates a random name
</h2><span id='topic+createRandName'></span>

<h3>Description</h3>

<p>This function creates a random name consisting of a prefix and a random number from 10000 to 99999.It is used internally
</p>


<h3>Usage</h3>

<pre><code class='language-R'>createRandName(prefix = "panel")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="createRandName_+3A_prefix">prefix</code></td>
<td>

<p>The prefix to which the random number will be added
</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Marina Saez Andreu
</p>


<h3>Examples</h3>

<pre><code class='language-R'>createRandName("Rodrigo")
createRandName("Rodrigo")
createRandName("Diaz")
</code></pre>

<hr>
<h2 id='createRb'>
createRb: creates a radio button
</h2><span id='topic+createRb'></span>

<h3>Description</h3>

<p>This function creates a radio button
</p>


<h3>Usage</h3>

<pre><code class='language-R'>createRb(variable = NULL, dataVector = NULL, panel = KTSEnv$subPanR4C1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="createRb_+3A_variable">variable</code></td>
<td>

<p>The variable to which the radiobutton is linked
</p>
</td></tr>
<tr><td><code id="createRb_+3A_datavector">dataVector</code></td>
<td>

<p>The names of the buttons
</p>
</td></tr>
<tr><td><code id="createRb_+3A_panel">panel</code></td>
<td>

<p>The panel where to place the radiobutton (defaults to the main screen input panel)
</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Marina Saez Andreu
</p>

<hr>
<h2 id='createRmChb'>
createRmChb: creates a check box of recurrence matrices
</h2><span id='topic+createRmChb'></span>

<h3>Description</h3>

<p>This function creates a check box listing the recurrence matrices that exist in the environment KTSEnv.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>createRmChb(labTitle = "Recurrence matrices", envir = KTSEnv)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="createRmChb_+3A_labtitle">labTitle</code></td>
<td>

<p>Check box title
</p>
</td></tr>
<tr><td><code id="createRmChb_+3A_envir">envir</code></td>
<td>

<p>Environment (defaults to KTSEnv)
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Variables that will be read in the corresponding onOk function
</p>


<h3>Author(s)</h3>

<p>Marina Saez Andreu
</p>

<hr>
<h2 id='createRmRb'>
createRmRb: creates a radiobutton of recurrence matrices
</h2><span id='topic+createRmRb'></span>

<h3>Description</h3>

<p>This function creates a radiobutton listing the recurrence matrices that exist in the environment KTSEnv.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>createRmRb(labTitle = "Recurrence matrices", envir = KTSEnv)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="createRmRb_+3A_labtitle">labTitle</code></td>
<td>

<p>Radiobutton title
</p>
</td></tr>
<tr><td><code id="createRmRb_+3A_envir">envir</code></td>
<td>

<p>Environment (defaults to KTSEnv)
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A variable that will be read in the corresponding onOk function
</p>


<h3>Author(s)</h3>

<p>Marina Saez Andreu
</p>

<hr>
<h2 id='createSimpleRM'>
createSimpleRM: creates a recurrence matrix
</h2><span id='topic+createSimpleRM'></span>

<h3>Description</h3>

<p>This function creates a recurrence matrix. It is used through the Recurrence Matrix button in the Analysis Menu.
</p>


<h3>Details</h3>

<p>The inputs are a time series, the delay, the embedding dimension and a name for the output matrix.
The matrix can be visualized by means of the Recurrence Plot button in the Plots Menu
Note that there are specific buttons to create and plot cross and joint recurrence matrices.
</p>


<h3>Value</h3>

<p>The recurrence points are represented in a two-column data frame by their positions in the recurrence matrix. Only the upper triangle is stored.
</p>


<h3>Author(s)</h3>

<p>Marina Saez Andreu
</p>


<h3>References</h3>

<p>Marwan,R., Romano, M.C., Thiel,M., Kurths,J.(2007): Recurrence plots for the analysis of complex systems. Physics Reports 438, 237-329.
</p>

<hr>
<h2 id='createSimpleRMPlot'>
createSimpleRMPlot: creates a recurrence plot
</h2><span id='topic+createSimpleRMPlot'></span>

<h3>Description</h3>

<p>This function creates a recurrence plot from a previously created recurrence matrix.Note that there are specific buttons to create and plot cross and joint recurrence matrices. It is used through the Plot Recurrence Plot in the Plots Menu
</p>


<h3>Author(s)</h3>

<p>Marina Saez Andreu
</p>


<h3>References</h3>

<p>Marwan,R., Romano, M.C., Thiel,M., Kurths,J.(2007): Recurrence plots for the analysis of complex systems. Physics Reports 438, 237-329.
</p>

<hr>
<h2 id='createSpecGaps'>
createSpecGaps: creates a specific gap in a time series
</h2><span id='topic+createSpecGaps'></span>

<h3>Description</h3>

<p>This function creates a gap between two dates chosen by the user.It is used through the Specific Gaps button in the Gap Sets menu.
</p>


<h3>Value</h3>

<p>The function creates a gap set and applies it to a copy of the input time series.Both the gap set and the new time series appear in the environment susEnv. 
</p>


<h3>Author(s)</h3>

<p>Marina Saez Andreu
</p>

<hr>
<h2 id='createSubPanR4C1'>
createSubPanR4C1: creates the input panel on the main screen
</h2><span id='topic+createSubPanR4C1'></span>

<h3>Description</h3>

<p>This function creates a blank input panel on the main screen. It is used whenever is necessary to erase the elements of the input panel (title, check boxes, radiobutton etc.) and write new ones.It is used internally
</p>


<h3>Author(s)</h3>

<p>Marina Saez Andreu
</p>

<hr>
<h2 id='createTitle'>
createTitle: creates a title in the input panel
</h2><span id='topic+createTitle'></span>

<h3>Description</h3>

<p>This function creates (on the input panel) a label  that works as a second level title.It is used internally
</p>


<h3>Usage</h3>

<pre><code class='language-R'>createTitle(labTitle = "Title")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="createTitle_+3A_labtitle">labTitle</code></td>
<td>

<p>The text of the title
</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Marina Saez Andreu
</p>

<hr>
<h2 id='createTITLE'>
createTITLE: create a title on the input panel
</h2><span id='topic+createTITLE'></span>

<h3>Description</h3>

<p>This function creates (on the input panel) a label  that works as a first level title.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>createTITLE(labTitle = "TITLE", panel = KTSEnv$subPanR4C1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="createTITLE_+3A_labtitle">labTitle</code></td>
<td>

<p>Text of the title
</p>
</td></tr>
<tr><td><code id="createTITLE_+3A_panel">panel</code></td>
<td>

<p>Panel where the title is to be written (defaults to the input panel on the main screen)
</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Marina Saez Andreu
</p>

<hr>
<h2 id='createTsChb'>
createTsChb: creates a check box of time series
</h2><span id='topic+createTsChb'></span>

<h3>Description</h3>

<p>This function creates a check box listing the time series that exist in the environment KTSEnv.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>createTsChb(labTitle = "Time series", envir = KTSEnv)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="createTsChb_+3A_labtitle">labTitle</code></td>
<td>

<p>Check box title
</p>
</td></tr>
<tr><td><code id="createTsChb_+3A_envir">envir</code></td>
<td>

<p>Environment (defaults to KTSEnv)
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Variables that will be read in the corresponding onOk function
</p>


<h3>Author(s)</h3>

<p>Marina Saez Andreu
</p>

<hr>
<h2 id='createTsRb'>
createTsRb: creates a radiobutton of time series
</h2><span id='topic+createTsRb'></span>

<h3>Description</h3>

<p>This function creates a radiobutton listing the time series that exist in the environment KTSEnv.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>createTsRb(labTitle = "Time series", variableName = "selTsP", envir = KTSEnv)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="createTsRb_+3A_labtitle">labTitle</code></td>
<td>

<p>Radiobutton title
</p>
</td></tr>
<tr><td><code id="createTsRb_+3A_variablename">variableName</code></td>
<td>

<p>Name of the variable to be assigned to the radiobutton
</p>
</td></tr>
<tr><td><code id="createTsRb_+3A_envir">envir</code></td>
<td>

<p>Environment (defaults to KTSEnv)
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A variable that will be read in the corresponding onOk function
</p>


<h3>Author(s)</h3>

<p>Marina Saez Andreu
</p>

<hr>
<h2 id='cumuKTS'>
cumuKTS: creates a cumulated time series
</h2><span id='topic+cumuKTS'></span>

<h3>Description</h3>

<p>This function creates a cumulated time series, that is, each point is the sum of all the previous values in the time series.It is particulary useful when the input time series has zero mean.It is used through the button Cumulative sum in the Time Series Menu
</p>


<h3>Value</h3>

<p>The cumulated time series
</p>


<h3>Author(s)</h3>

<p>Marina Saez Andreu
</p>

<hr>
<h2 id='destroyMainScreen'>
A function to destroy KarsTS main screen
</h2><span id='topic+destroyMainScreen'></span>

<h3>Description</h3>

<p>A function to destroy KarsTS main screen. It is normally destroyed via interface.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>destroyMainScreen()
</code></pre>


<h3>Author(s)</h3>

<p>Marina Saez Andreu
</p>

<hr>
<h2 id='destroyWelcome'>
destroyWelcome: destroys KarsTS welcome screen
</h2><span id='topic+destroyWelcome'></span>

<h3>Description</h3>

<p>This function destroys KarsTS welcome screen. It is used through the button Start in the welcome screen.
</p>


<h3>Author(s)</h3>

<p>Marina Saez Andreu
</p>

<hr>
<h2 id='determinismKTS'>
determinismKTS: estimate determinism
</h2><span id='topic+determinismKTS'></span>

<h3>Description</h3>

<p>This function is used to study the determinism of a system, based on the number and length of the diagonal lines that contains the recurrence matrix that represents the system. It is used through the button Determinism in the Anaylisis menu.
</p>


<h3>Value</h3>

<p>The following outputs are written on KarsTS output window: recurrence rate, determinism, ratio and summary of the lengths of the diagonal lines. Besides, a new window containing a histogram of diagonal lines pops up. 
</p>


<h3>Author(s)</h3>

<p>Marina Saez Andreu
</p>


<h3>References</h3>

<p>Marwan,R., Romano, M.C., Thiel,M., Kurths,J.(2007): Recurrence plots for the analysis of complex systems. Physics Reports 438, 237-329.
</p>

<hr>
<h2 id='diffKTS'>
diffKTS: calculate differences of a time series
</h2><span id='topic+diffKTS'></span>

<h3>Description</h3>

<p>This function creates a new time series by differencing the input time series.It is used through the button differences in the Time Series Menu
</p>


<h3>Details</h3>

<p>The inputs are: time series, lag and center yes/not. In this context, center the time series means that the differenced time series will be interpolated, so that the output time series has same length and dates as the original time series. 
</p>


<h3>Value</h3>

<p>The differenced time series
</p>


<h3>Author(s)</h3>

<p>Marina Saez Andreu
</p>

<hr>
<h2 id='E1dAndE2d'>
E1dAndE2d: invariants E1(d) and E2(d)
</h2><span id='topic+E1dAndE2d'></span>

<h3>Description</h3>

<p>This function uses the function nonlinearTseries::estimateEmbeddingDim to plot the invariants E1(d) and E2(d) (Cao,1997). E1(d) helps finding the embedding dimension of a scalar time series and E2(d) can distinguish stochastic from deterministic signals.It is used through the button E1d &amp; E2d in the Plots Menu.
</p>


<h3>Author(s)</h3>

<p>Marina Saez Andreu
</p>


<h3>References</h3>

<p>Cao, L (1997): Practical method for determining the minimum embedding dimension of a scalar time series. Physica D: Nonlinear Phenomena, 110,1, pp. 43-50.
</p>

<hr>
<h2 id='embedData'>
embedData: embeds a time series
</h2><span id='topic+embedData'></span>

<h3>Description</h3>

<p>This function embeds a time series and adds NAs so that the embedded data have the same length as the original time series.It is used internally
</p>


<h3>Usage</h3>

<pre><code class='language-R'>embedData(TSData, embDim, embDelay)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="embedData_+3A_tsdata">TSData</code></td>
<td>

<p>Values of the time series
</p>
</td></tr>
<tr><td><code id="embedData_+3A_embdim">embDim</code></td>
<td>

<p>Embedding dimension
</p>
</td></tr>
<tr><td><code id="embedData_+3A_embdelay">embDelay</code></td>
<td>

<p>Delay
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix of embedded data, with as many NAs as necessary so that it has the same length as the original time series.
</p>


<h3>Author(s)</h3>

<p>Marina Saez Andreu
</p>

<hr>
<h2 id='endingLines'>
endingLines: add three lines of asterisks on the output panel
</h2><span id='topic+endingLines'></span>

<h3>Description</h3>

<p>This function adds three lines of asterisks on the output panel.It is used to separate outputs of different functions.It is used internally
</p>


<h3>Usage</h3>

<pre><code class='language-R'>endingLines()
</code></pre>


<h3>Author(s)</h3>

<p>Marina Saez Andreu
</p>

<hr>
<h2 id='exportall'>
exportall: exports all types of data sets
</h2><span id='topic+exportall'></span>

<h3>Description</h3>

<p>This function is used to export time series, gap sets or recurrence matrices to csv or txt files. It is used through the button Export in the Time Series or Gap Sets menus. 
</p>


<h3>Details</h3>

<p>All types of data sets can be exported both from the Time Series  menu or from the Gap Sets menu.It is possible to export more than one time series to the same file; however, each gap set and recurrence matrix must be stored separatedly. The files are created in the woking directory. 
</p>


<h3>Author(s)</h3>

<p>Marina Saez Andreu
</p>

<hr>
<h2 id='fillWithTwins'>
fillWithTwins: fills missing values using twin points
</h2><span id='topic+fillWithTwins'></span>

<h3>Description</h3>

<p>This function finds twin points in a recurrence matrix and uses them to fill adjacent missing values. Many points do not have twins, therefore it is unlikely that all the missing values are filled. It is used through the button twins in the Filling Menu
</p>


<h3>Details</h3>

<p>The inputs to this function are: the time series to fill (TSF), a recurrence matrix that represents the system (RM), the maximum distance (MD) and, optionally, the gap set to fill. A missing value is replaced by the median of its twin points.
Case A: TSF was used to build RM. In this case, RM lacks information at the points to fill; therefore, it is necessary to find the twins of the adjacent points, that is, MD must be greater than 0.
Case B: the system was reconstructed using other time series, that is, RM was calculated without TSF. In this case, it is possible to set MD to 0, although it can be greater than 0, as well. 
</p>


<h3>Value</h3>

<p>The filled time series in susEnv and a summary of the procedure on the output window.
</p>


<h3>Author(s)</h3>

<p>Marina Saez Andreu
</p>

<hr>
<h2 id='findDateFormat'>
findDateFormat: finds the format of a set of dates
</h2><span id='topic+findDateFormat'></span>

<h3>Description</h3>

<p>This function identifies the format of a set of dates from a list of allowed formats.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>findDateFormat(X, tz = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="findDateFormat_+3A_x">X</code></td>
<td>

<p>The date (given as a character string)
</p>
</td></tr>
<tr><td><code id="findDateFormat_+3A_tz">tz</code></td>
<td>

<p>The time zone
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The allowed formats are: &quot;%m/%d/%Y %H:%M&quot;, &quot;%Y/%m/%d %H:%M&quot;,&quot;%Y-%m-%d %H:%M&quot; and &quot;%m-%d-%Y %H:%M&quot;
</p>


<h3>Value</h3>

<p>It returns the date format, ready to use in the funtion strptime. If the dates have different formats, the function returns &quot;variousFormats&quot;. If the format is not one of the allowed ones, it returns &quot;notAllowedformat&quot;.
</p>


<h3>Author(s)</h3>

<p>Marina Saez Andreu
</p>

<hr>
<h2 id='findTwins'>
findTwins: finds twin points in a recurrence matrix
</h2><span id='topic+findTwins'></span>

<h3>Description</h3>

<p>This function finds twin points (that is, identical columns) in a recurrence matrix.It is used internally
</p>


<h3>Usage</h3>

<pre><code class='language-R'>findTwins(recMat, pointsToFind = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="findTwins_+3A_recmat">recMat</code></td>
<td>

<p>The recurrence matrix
</p>
</td></tr>
<tr><td><code id="findTwins_+3A_pointstofind">pointsToFind</code></td>
<td>

<p>The points (columns) whose twins are to be found (defaults to all)
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function classifies the columns in families of twins and assigns an integer number to each family. The numbers are mere codes to identify the families and they do not have any meaning themselves.
</p>


<h3>Value</h3>

<p>A vector of integers. Each number represents a family of twins. Positions corresponding to columns with no twins are assigned NA. When the search of twins is limited to a subset of points, the uninteresting points are assigned NA also.  
</p>


<h3>Author(s)</h3>

<p>Marina Saez Andreu
</p>


<h3>References</h3>

<p>Marwan,R., Romano, M.C., Thiel,M., Kurths,J.(2007): Recurrence plots for the analysis of complex systems. Physics Reports 438, 237-329.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Generate time series and recurrence matrix
res &lt;- genRmExample(name = "SRM", InKTSEnv = FALSE, plotRM = FALSE)
TS &lt;- res$TS
SRM &lt;- res$newSimpRM

# Find twins
SRMTwins &lt;- findTwins(SRM)

# Interpretation example
aFamily &lt;- SRMTwins[which(is.finite(SRMTwins))][1]
twinsInFamily &lt;- which(SRMTwins == aFamily)
TS[twinsInFamily,] 
# The values in TS are very similar
# The columns in the recurrence matrix are identical,
# although this cannot be observed directly
# because of the way KarsTS stores recurrence matrices
</code></pre>

<hr>
<h2 id='fnnKTS'>
fnn: plots embedding dimendion vs false nearest neighbors
</h2><span id='topic+fnnKTS'></span>

<h3>Description</h3>

<p>This function plots embedding dimension vs false nearest neighbors using tseriesChaos::false.nearest and tseriesChaos::plot.false.nearest. It is used to find the minimum embedding dimension. It is used through the button FNN in the Plots Menu.
</p>


<h3>Author(s)</h3>

<p>Marina Saez andreu
</p>

<hr>
<h2 id='functToExport'>
functToExport: functions to export
</h2><span id='topic+functToExport'></span><span id='topic+KTSEnv'></span><span id='topic+makeGlobal'></span>

<h3>Description</h3>

<p>This function exports the function KarsTS::KarsTS. It is used internally. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>functToExport()
</code></pre>


<h3>Details</h3>

<p>Other objects documente here: <br />
makeGlobal is a vector containing the variables to declare global.It is used internally. <br />
KTSEnv is the environment where the loaded data sets are and it can be accesed directly from the R console. We reccomend to use KarsTS to manipulate the data sets; however, the user can handle them directly from R in order to apply functionalities not included in KarsTS. If that is the case, be careful to produce data sets with the right format; otherwise, KarsTS will not recognize them. See the User's Guide for more information. 
</p>


<h3>Author(s)</h3>

<p>Marina Saez Andreu
</p>

<hr>
<h2 id='gamKTS'>
A function to fill values by means of a generalized additive model
</h2><span id='topic+gamKTS'></span>

<h3>Description</h3>

<p>This function is used to fill gaps using a generalized additive model (gam) with tensor smoothing. It is used through the Multivariate Splines in the Filling Menu. Although the gam model is not necessarily a multivariate spline, the button has this name because we think is more familiar to the users. 
</p>


<h3>Details</h3>

<p>The user selects the time series to fill and a set of predictor time series. The function fits a generalized linear model a gap and uses the model to fill the gap. This is done for every gap in the gap set. It is used through the Multivariate Splines in the Filling Menu. The user can choose a fixed d.f. regression spline or a penalized regression spline. It is also possible to choose any of the smoothing bases allowed by the function mgcv::te. 
</p>


<h3>Value</h3>

<p>The filled time series in the environment KTSEnv and a summary of the results on the output window.
</p>


<h3>Author(s)</h3>

<p>Marina Saez Andreu
</p>

<hr>
<h2 id='gapCheckedTF'>
gapCheckedTF: identifies checked gap sets
</h2><span id='topic+gapCheckedTF'></span>

<h3>Description</h3>

<p>This function identifies which gap sets have been checked from a check box
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gapCheckedTF(prefix = "gcbValue", envir = KTSEnv)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gapCheckedTF_+3A_prefix">prefix</code></td>
<td>

<p>A prefix to reconstruct the names that were assigned to the variables in the check box.
</p>
</td></tr>
<tr><td><code id="gapCheckedTF_+3A_envir">envir</code></td>
<td>

<p>The environment
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A logical vector
</p>


<h3>Author(s)</h3>

<p>Marina Saez Andreu
</p>

<hr>
<h2 id='gapDetect'>
gapDetect: identifies the gap sets currently loaded
</h2><span id='topic+gapDetect'></span>

<h3>Description</h3>

<p>This function identifies the gap sets currently loaded in the environment KTSEnv
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gapDetect()
</code></pre>


<h3>Value</h3>

<p>A vector containing the names of the gap sets
</p>


<h3>Author(s)</h3>

<p>Marina Saez Andreu
</p>

<hr>
<h2 id='gapForSelMethod'>
gapForSelMethod: gap set to fill
</h2><span id='topic+gapForSelMethod'></span>

<h3>Description</h3>

<p>This function finds which gap the user selected to apply a filling method on it. If none was selected, it creates a gap set containing all the gap sets in the time series.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gapForSelMethod(selTsName, selTs, envir = KTSEnv)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gapForSelMethod_+3A_seltsname">selTsName</code></td>
<td>

<p>The time series name
</p>
</td></tr>
<tr><td><code id="gapForSelMethod_+3A_selts">selTs</code></td>
<td>

<p>The time series
</p>
</td></tr>
<tr><td><code id="gapForSelMethod_+3A_envir">envir</code></td>
<td>

<p>The environment
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list containing the selected gap set name and the gap set. If the user did not select any gap set or there is no gap set in the environment, the function creates a gap set containing all the gaps in the time series. It is name is All plus the time series name.
</p>


<h3>Author(s)</h3>

<p>Marina Saez Andreu
</p>

<hr>
<h2 id='genGapExample'>
A function to generate a gap set example
</h2><span id='topic+genGapExample'></span>

<h3>Description</h3>

<p>A function to generate a gap set example.It can be assigned to the KTSEnv environment. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>genGapExample(timSer, lGaps, nGaps, name = "GS", InKTSEnv = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="genGapExample_+3A_timser">timSer</code></td>
<td>

<p>The time series where the gaps are generated
</p>
</td></tr>
<tr><td><code id="genGapExample_+3A_lgaps">lGaps</code></td>
<td>

<p>The length of the gaps
</p>
</td></tr>
<tr><td><code id="genGapExample_+3A_ngaps">nGaps</code></td>
<td>

<p>The number of gaps
</p>
</td></tr>
<tr><td><code id="genGapExample_+3A_name">name</code></td>
<td>

<p>A name for the gap set. It defaults to GS. When InKTSEnv is FALSE, the name is not necessary.
</p>
</td></tr>
<tr><td><code id="genGapExample_+3A_inktsenv">InKTSEnv</code></td>
<td>

<p>Assign to the environment KTSEnv (TRUE) or not (FALSE)
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The gap set
</p>


<h3>Author(s)</h3>

<p>Marina Saez Andreu
</p>

<hr>
<h2 id='genRmExample'>
A function to generate a recurrence matrix example
</h2><span id='topic+genRmExample'></span>

<h3>Description</h3>

<p>A function to generate a recurrence matrix example. It can be assigned to the KTSEnv environment.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>genRmExample(name = "SRM", InKTSEnv = TRUE, plotRM = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="genRmExample_+3A_name">name</code></td>
<td>

<p>A name for the recurrence matrix. When the local environment is used instead of KTSEnv, the name is still necessary for the recurrence plot title.
</p>
</td></tr>
<tr><td><code id="genRmExample_+3A_inktsenv">InKTSEnv</code></td>
<td>

<p>Assign the output to the KTSEnv (TRUE) or to the local  environment (FALSE)
</p>
</td></tr>
<tr><td><code id="genRmExample_+3A_plotrm">plotRM</code></td>
<td>

<p>Plot the recurrence matrix (TRUE) or not (FALSE)
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The recurrence matrix is calculated on a sinusoidal time series composed with a random walk. The embedding dimension is 2, the delay is 290 and the threshold is 20.
</p>


<h3>Value</h3>

<p>The recurrence matrix and the time series
</p>


<h3>Author(s)</h3>

<p>Marina Saez Andreu
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
 res &lt;- genRmExample(name = "RMExample", InKTSEnv = FALSE, plotRM = FALSE)
 res$newSimpRM
 res$TS
</code></pre>

<hr>
<h2 id='genTSExample'>
A function to generate an example time series
</h2><span id='topic+genTSExample'></span>

<h3>Description</h3>

<p>This function generates an example time series. The dates range from 2015 to 2016 and the sampling period is half an hour. The time series can be white noise or a random walk. It can be assigned to the KTSEnv environment. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>genTSExample(stationary = TRUE, name = "TS", InKTSEnv = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="genTSExample_+3A_stationary">stationary</code></td>
<td>

<p>Generate white noise (TRUE) or a random walk (FALSE)
</p>
</td></tr>
<tr><td><code id="genTSExample_+3A_name">name</code></td>
<td>

<p>A name for the time series. It defaults to TS. When InKTSEnv is FALSE, the name is not necessary.
</p>
</td></tr>
<tr><td><code id="genTSExample_+3A_inktsenv">InKTSEnv</code></td>
<td>

<p>Assign to the environment KTSEnv (TRUE) or not (FALSE)
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The time series
</p>


<h3>Author(s)</h3>

<p>Marina Saez Andreu
</p>

<hr>
<h2 id='getClassEnvir'>
getClassEnvir: get objects of a class from an environment
</h2><span id='topic+getClassEnvir'></span>

<h3>Description</h3>

<p>This function identifies objects of a class in an environment 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getClassEnvir(classGet = "list", envir = KTSEnv)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getClassEnvir_+3A_classget">classGet</code></td>
<td>

<p>The class
</p>
</td></tr>
<tr><td><code id="getClassEnvir_+3A_envir">envir</code></td>
<td>

<p>The environment
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector with the names of the objects
</p>


<h3>Author(s)</h3>

<p>Marina Saez Andreu
</p>

<hr>
<h2 id='getCoordsKTS'>
getCoordsKTS: get coordinates from a plot
</h2><span id='topic+getCoordsKTS'></span>

<h3>Description</h3>

<p>This function allows to manually select points from a plot and get their coordinates. It is used through the button Get coordinates in the Plots menu.
</p>


<h3>Details</h3>

<p>This function has two steps. In the first place, it is necessary to select a time series and plot it. The plot appears on a pop-up window. Then, the user clicks on one or more points and they turn green. When the user presses the Write results button, a list of coordinates (time and value) appears on the output window. 
</p>


<h3>Author(s)</h3>

<p>Marina Saez Andreu
</p>

<hr>
<h2 id='getCRP'>
getCRP: gets the correlation probability of recurrence
</h2><span id='topic+getCRP'></span>

<h3>Description</h3>

<p>This function calculates the correlation probability of recurrence of two systems, given by their recurrece matrices. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getCRP(prob1, prob2, xLims, doPlot = FALSE, main = "plotTitle")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getCRP_+3A_prob1">prob1</code></td>
<td>

<p>Probability of recurrence of the first matrix
</p>
</td></tr>
<tr><td><code id="getCRP_+3A_prob2">prob2</code></td>
<td>

<p>Probability of recurrence of the second matrix
</p>
</td></tr>
<tr><td><code id="getCRP_+3A_xlims">xLims</code></td>
<td>

<p>X range where the correlation probability will be calculated. The diagonals very close or very far from the main diagonal are usually discarded for estimating the CPR.
</p>
</td></tr>
<tr><td><code id="getCRP_+3A_doplot">doPlot</code></td>
<td>

<p>Get a plot (TRUE) or not (FALSE)
</p>
</td></tr>
<tr><td><code id="getCRP_+3A_main">main</code></td>
<td>

<p>Title for the plot
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Correlation probability of recurrence (CPR)
</p>


<h3>Author(s)</h3>

<p>Marina Saez Andreu
</p>


<h3>References</h3>

<p>Romano, M. C. (2004). Synchronization Analysis by Means of Recurrences in Phase Space, Universitat Postdam. Doctoral dissertation.
</p>

<hr>
<h2 id='getDelayCharTimes'>
getDelayCharTimes: transforms dates from character to numeric. 
</h2><span id='topic+getDelayCharTimes'></span>

<h3>Description</h3>

<p>This function transforms a set of dates (given as character) to numeric after testing that their format is allowed by KarsTS.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getDelayCharTimes(initialTimes, tz = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getDelayCharTimes_+3A_initialtimes">initialTimes</code></td>
<td>

<p>The dates
</p>
</td></tr>
<tr><td><code id="getDelayCharTimes_+3A_tz">tz</code></td>
<td>

<p>The time zone
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector with the times in numeric form
</p>


<h3>Author(s)</h3>

<p>Marina Saez Andreu
</p>

<hr>
<h2 id='getFANRM2'>
getFANRM2: creates a fixed amount of neighbours (FAN) matrix via console.
</h2><span id='topic+getFANRM2'></span>

<h3>Description</h3>

<p>This function creates a fixed amount of neighbours (FAN) matrix via console from a time series. To create a FAN matrix via interface, see the function createFAN.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getFANRM2(selTs, embedDim, lagDelay, threshold, theilerWin, fan)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getFANRM2_+3A_selts">selTs</code></td>
<td>

<p>A univarate time series in KarsTS format.
</p>
</td></tr>
<tr><td><code id="getFANRM2_+3A_embeddim">embedDim</code></td>
<td>

<p>The embedding dimension. 
</p>
</td></tr>
<tr><td><code id="getFANRM2_+3A_lagdelay">lagDelay</code></td>
<td>

<p>The delay (in lags).
</p>
</td></tr>
<tr><td><code id="getFANRM2_+3A_threshold">threshold</code></td>
<td>

<p>The threshold. 
</p>
</td></tr>
<tr><td><code id="getFANRM2_+3A_theilerwin">theilerWin</code></td>
<td>

<p>The Theiler's window (in lags). 
</p>
</td></tr>
<tr><td><code id="getFANRM2_+3A_fan">fan</code></td>
<td>

<p>The fixed amount of neighbours. 
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>In case you do not want to embed your time series, set embedDim to 1 and lagDelay to 0. 
If you do not want to apply a Theiler's window, set theilerWin to 0.
The threshold will determine in the first place the number of neighbors of each point; then, the fixed amount of neighbours will determine how many of those are kept. For example, if a point A has 10 neighbors (according to the threshold) and the fan is 5, the point A will have 5 neighbors in the output matrix. However, if a point B has only 4 neighbors (according to the threshold), the number of neighbors of B in the output matrix will be 4. If you want a matrix with a truly fixed amount of neighbors, give the threshold a value high enough to render it useless. 
</p>


<h3>Value</h3>

<p>A list containing the X and Y positions of the recurrent points in the FAN recurrence matrix.
</p>


<h3>Author(s)</h3>

<p>Marina Saez Andreu
</p>


<h3>References</h3>

<p>Marwan,R., Romano, M.C., Thiel,M., Kurths,J.(2007): Recurrence plots for the analysis of complex systems. Physics Reports 438, 237-329.
</p>

<hr>
<h2 id='getGapsAfterFill'>
getGapsAfterFill: get the remaining gaps
</h2><span id='topic+getGapsAfterFill'></span>

<h3>Description</h3>

<p>This function identifies which gaps remain in a time series after applying a filling method. It is used internally.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getGapsAfterFill(filledTS, selGap, envir = KTSEnv)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getGapsAfterFill_+3A_filledts">filledTS</code></td>
<td>

<p>The filled time series
</p>
</td></tr>
<tr><td><code id="getGapsAfterFill_+3A_selgap">selGap</code></td>
<td>

<p>The gap set that was meant to be filled
</p>
</td></tr>
<tr><td><code id="getGapsAfterFill_+3A_envir">envir</code></td>
<td>

<p>The environment
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>It returns a list containing two data frames: one of them lists the remaining gaps and the other, the filled gaps.
</p>


<h3>Author(s)</h3>

<p>Marina Saez Andreu
</p>

<hr>
<h2 id='getMaxNegSlope'>
getMaxNegSlope: get the maximum negative slope
</h2><span id='topic+getMaxNegSlope'></span>

<h3>Description</h3>

<p>This function returns the greater negative difference in a time series (greater in absolute value). It is used internally.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getMaxNegSlope(timSerVals)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getMaxNegSlope_+3A_timservals">timSerVals</code></td>
<td>

<p>The time series (only the values, not the times)
</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Marina Saez Andreu
</p>

<hr>
<h2 id='getMaxPosSlope'>
getMaxPosSlope: get the maximum negative slope
</h2><span id='topic+getMaxPosSlope'></span>

<h3>Description</h3>

<p>This function returns the greater positive difference in a time series.It is used internally.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getMaxPosSlope(timSerVals)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getMaxPosSlope_+3A_timservals">timSerVals</code></td>
<td>

<p>The time series (only the values, not the times)
</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Marina Saez Andreu
</p>

<hr>
<h2 id='getNAsGaps'>
getNAsGaps: get the gaps in a time series
</h2><span id='topic+getNAsGaps'></span>

<h3>Description</h3>

<p>This function identifies the gaps existing in a time series and returns a table.It is used internally.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getNAsGaps(y)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getNAsGaps_+3A_y">y</code></td>
<td>

<p>The time series (only values, not times)
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix listing the initial and final indices of each gap
</p>


<h3>Author(s)</h3>

<p>Marina Saez Andreu
</p>

<hr>
<h2 id='getNewGapsInd'>
A function to create random gaps
</h2><span id='topic+getNewGapsInd'></span>

<h3>Description</h3>

<p>This function creates nGaps gaps of length lGaps in the time series timSer. It is used internally. The gaps do not overlay amongst them; they do not overlay pre-existing gaps either.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getNewGapsInd(timSer, lGaps, nGaps)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getNewGapsInd_+3A_timser">timSer</code></td>
<td>

<p>The time series where the gaps will be created.
</p>
</td></tr>
<tr><td><code id="getNewGapsInd_+3A_lgaps">lGaps</code></td>
<td>

<p>The length of the gaps
</p>
</td></tr>
<tr><td><code id="getNewGapsInd_+3A_ngaps">nGaps</code></td>
<td>

<p>The number of gaps.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector containing the indices of the gaps
</p>


<h3>Author(s)</h3>

<p>Marina Saez Andreu
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Create time series
TS &lt;- genTSExample(InKTSEnv = FALSE)[1:50,]

# Create 3 gaps of 7 NAs each
gInd &lt;- getNewGapsInd(TS, 7, 3)

# Create time series duplicate and apply the gaps
TS1 &lt;- TS
TS1$value[gInd] &lt;- NA

#Compare
cbind(TS, TS1$value)

</code></pre>

<hr>
<h2 id='getOtherErrEstim'>
getOtherErrEstim: get some error estimates from a linear fit
</h2><span id='topic+getOtherErrEstim'></span>

<h3>Description</h3>

<p>This function gets the relative root mean square error,the mean absolute error and bias error.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getOtherErrEstim(observed, predicted)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getOtherErrEstim_+3A_observed">observed</code></td>
<td>

<p>Observed values
</p>
</td></tr>
<tr><td><code id="getOtherErrEstim_+3A_predicted">predicted</code></td>
<td>

<p>Predicted values
</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Marina Saez Andreu
</p>

<hr>
<h2 id='getProTaos'>
getProTaos:calculate the probability of recurrence
</h2><span id='topic+getProTaos'></span>

<h3>Description</h3>

<p>This function calculates the probability of recurrence of a system, given by a recurrence matrix in KarsTS format. The RP is calculated for each diagonal (upper triangle).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getProTaos(RecMat, xlim = NULL, main = NULL, doPlot = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getProTaos_+3A_recmat">RecMat</code></td>
<td>

<p>A recurrence matrix in KarsTS format
</p>
</td></tr>
<tr><td><code id="getProTaos_+3A_xlim">xlim</code></td>
<td>

<p>X range of the plot.
</p>
</td></tr>
<tr><td><code id="getProTaos_+3A_main">main</code></td>
<td>

<p>Plot title
</p>
</td></tr>
<tr><td><code id="getProTaos_+3A_doplot">doPlot</code></td>
<td>

<p>Get the plot or not
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list containing
</p>
<table>
<tr><td><code>Tao</code></td>
<td>
<p>The diagonals where the RP was calculated</p>
</td></tr>
<tr><td><code>Prob</code></td>
<td>
<p>The RP for each diagonal</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Marina Saez Andreu
</p>


<h3>References</h3>

<p>Romano, M. C. (2004). Synchronization Analysis by Means of Recurrences in Phase Space, Universitat Postdam. Doctoral dissertation.
</p>

<hr>
<h2 id='getRecurrencePoints'>
A function to get recurrent points in a time series
</h2><span id='topic+getRecurrencePoints'></span>

<h3>Description</h3>

<p>This function is the core of the function createSimpleRm. It finds the recurrence points in a time series, possibly embedded. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getRecurrencePoints(timSer, embedDim, lagDelay, threshold)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getRecurrencePoints_+3A_timser">timSer</code></td>
<td>

<p>The time series
</p>
</td></tr>
<tr><td><code id="getRecurrencePoints_+3A_embeddim">embedDim</code></td>
<td>

<p>The embedding dimension
</p>
</td></tr>
<tr><td><code id="getRecurrencePoints_+3A_lagdelay">lagDelay</code></td>
<td>

<p>The delay for the embedding (in lags)
</p>
</td></tr>
<tr><td><code id="getRecurrencePoints_+3A_threshold">threshold</code></td>
<td>

<p>The threshold
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Two points in the phase space are recurrent when the distance between them (infinite norm) is less than the threshold. <br />
In a recurrence matrix the X positions read rightwards and the Y positions read upwards. Recurrence matrices are symmetric and their diagonal (line X = Y) cannot contain not-recurrent points. For this reason, only the upper triangle is stored.  
</p>


<h3>Value</h3>

<p>A list containing the X and Y positions of the recurrent points in the recurrence matrix (upper triangle)
</p>


<h3>Author(s)</h3>

<p>Marina Saez Andreu
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# # Generate time series
timSer &lt;- genTSExample(stationary = FALSE, InKTSEnv = FALSE)
graphics::plot(timSer)

# # Calculate recurrence matrix
RP &lt;- getRecurrencePoints(timSer, 1, 0, threshold = 0.1)
X &lt;- RP$recPointsX
Y &lt;- RP$recPointsY

# # Recurrence plot
LT &lt;- nrow(timSer)
graphics::par(pty = "s")
# Upper triangle
graphics::plot(timSer$time[X], timSer$time[Y], cex = 0.3, col = 4, xlab = "", ylab = "")
# Lower triangle
graphics::points(timSer$time[Y], timSer$time[X], cex = 0.3, col = 4)
# Diagonal
graphics::points(1:LT, 1:LT, cex = 0.3, col = 4)

graphics::par(pty = "m")
</code></pre>

<hr>
<h2 id='getRollStatistics'>
getRollStatistics: get rolling statistics
It is used internally
</h2><span id='topic+getRollStatistics'></span>

<h3>Description</h3>

<p>This function calculates a certain statistic in centered sliding windows along a time series. The available statistics are: minimum, first quartile,median, mean, third quartile, maximum and standard deviation. Incomplete windows can be assigned NA (option tailsTS = FALSE); alternatively, the statistic can be calculated with the available values.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getRollStatistics(selTs, selTsName, slidingWin, tailsTS = FALSE, selStatisTF)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getRollStatistics_+3A_selts">selTs</code></td>
<td>

<p>The input time series
</p>
</td></tr>
<tr><td><code id="getRollStatistics_+3A_seltsname">selTsName</code></td>
<td>

<p>The input time series name
</p>
</td></tr>
<tr><td><code id="getRollStatistics_+3A_slidingwin">slidingWin</code></td>
<td>

<p>The sliding window size
</p>
</td></tr>
<tr><td><code id="getRollStatistics_+3A_tailsts">tailsTS</code></td>
<td>

<p>The action regarding the tails (TRUE or FALSE)
</p>
</td></tr>
<tr><td><code id="getRollStatistics_+3A_selstatistf">selStatisTF</code></td>
<td>

<p>A data frame containing seven columns. Each column corresponds to a statistic. When the user selects a statistic, its value is TRUE; otherwise, it is FALSE. 
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>For each selected statistic, the function creates a time series in the environment susEnv (for example, a time series of mean values).
</p>


<h3>Author(s)</h3>

<p>Marina Saez Andreu
</p>

<hr>
<h2 id='getSamPerTable'>
getSamPerTable: get sampling periods table
</h2><span id='topic+getSamPerTable'></span>

<h3>Description</h3>

<p>This function divides a time series in pieces with a single sampling period and either values or missing values. Internally, this function separates true missing values from missing values that are the result of the existence of different sampling periods in the time series. Note that KarsTS time series are regular; when a time series with different time steps is loaded, NAs are added to achieve regularity. It is used internally. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getSamPerTable(timSer, sampPer)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getSamPerTable_+3A_timser">timSer</code></td>
<td>

<p>The input time series
</p>
</td></tr>
<tr><td><code id="getSamPerTable_+3A_sampper">sampPer</code></td>
<td>

<p>A vector that contains the existing sampling periods.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>It returns a data frame listing all the pieces.
</p>


<h3>Author(s)</h3>

<p>Marina Saez Andreu
</p>

<hr>
<h2 id='getSamPerTable.1Freq'>
getSamPerTable.1Freq: get sampling periods table (time series with one frequency)
</h2><span id='topic+getSamPerTable.1Freq'></span>

<h3>Description</h3>

<p>This function is a simplified version of getSamPerTable for time series that have a single sampling period. It is used internally.
</p>


<h3>Author(s)</h3>

<p>Marina Saez Andreu
</p>

<hr>
<h2 id='getScreenSize'>
getScreenSize: gets the computer screen size
</h2><span id='topic+getScreenSize'></span>

<h3>Description</h3>

<p>This function gets the computer screen size.It is used internally.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getScreenSize()
</code></pre>


<h3>Value</h3>

<p>The width and heigth of the screen are assigned to the enviroment susEnv.
</p>


<h3>Author(s)</h3>

<p>Marina Saez Andreu
</p>

<hr>
<h2 id='getStatistics'>
getStatistics: calculates the statistics of a time series
</h2><span id='topic+getStatistics'></span>

<h3>Description</h3>

<p>This function calculates the minimum, first quartile, median, mean, third quartile, maximum and standard deviation of a time series.It is used internally.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getStatistics(selTs)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getStatistics_+3A_selts">selTs</code></td>
<td>

<p>The time series
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector containing the statistics values
</p>


<h3>Author(s)</h3>

<p>Marina Saez Andreu
</p>

<hr>
<h2 id='getUniqueSampPer'>
getUniqueSampPer: get unique sampling periods
</h2><span id='topic+getUniqueSampPer'></span>

<h3>Description</h3>

<p>This function get the time steps existing in a time series and sorts them according to the number of times they appear (starting by the most repeated). It returns a table with this information.It is used internally.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getUniqueSampPer(timeSer)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getUniqueSampPer_+3A_timeser">timeSer</code></td>
<td>

<p>The time series
</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Marina Saez Andreu
</p>

<hr>
<h2 id='goodnessFilling'>
goodnessFilling: estimate the goodness of the filling
</h2><span id='topic+goodnessFilling'></span>

<h3>Description</h3>

<p>This function performs a linear fit between observed and predicted values. The predicted values come from an artificial gap set that has been filled. When true missing values are imputed, it is impossible to estimate the goodness of the filling. It is used through the Check filling button in the Filling menu.
</p>


<h3>Value</h3>

<p>A summary of the fit in the output window and different plots in pop-up windows.
</p>


<h3>Author(s)</h3>

<p>Marina Saez Andreu
</p>

<hr>
<h2 id='groupDates'>
groupDates: groups dates
</h2><span id='topic+groupDates'></span>

<h3>Description</h3>

<p>This function transforms the output of the function groupIndices from indices to dates.It is used internally.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>groupDates(rawIndices, TimSer)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="groupDates_+3A_rawindices">rawIndices</code></td>
<td>

<p>The indices
</p>
</td></tr>
<tr><td><code id="groupDates_+3A_timser">TimSer</code></td>
<td>

<p>The time series to which the indices belong.
</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Marina Saez Andreu
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
X &lt;- sort(sample(1:50,25))
TS &lt;- genTSExample(InKTSEnv = FALSE)
groupIndices(X)
groupDates(X, TS)

</code></pre>

<hr>
<h2 id='groupIndices'>
groupIndices: group indices
</h2><span id='topic+groupIndices'></span>

<h3>Description</h3>

<p>This function groups a set of sorted indices. For example: 1,2,3,50,100,101,102,103 would be grouped as follows: 1-3, 50, 100-103.It is used internally.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>groupIndices(rawIndices)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="groupIndices_+3A_rawindices">rawIndices</code></td>
<td>

<p>The indices
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>It returns a data frame. Each row corresponds to a group. The columns are: initial index, final index and group length.
</p>


<h3>Author(s)</h3>

<p>Marina Saez Andreu
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
X &lt;- sort(sample(1:50,25))
X
groupIndices(X)

</code></pre>

<hr>
<h2 id='histKTS'>
histKTS: plots histogram
</h2><span id='topic+histKTS'></span>

<h3>Description</h3>

<p>This function plots the histogram of a time series values. Its inputs are the time series and, optionally, the approximate number of bars. It is used internally through the button Histogram in the Plots menu
</p>


<h3>Author(s)</h3>

<p>Marina Saez Andreu
</p>

<hr>
<h2 id='invariantsKTS'>
invariantsKTS: invariant plots
</h2><span id='topic+invariantsKTS'></span>

<h3>Description</h3>

<p>This function estimates the correlation sum and dimension and the KS Entropy through the functions nonlinearTseries::corrDim and nonlinearTseries::sampleEntropy. It returns three plots: correlation sum, correlation dimension and sample entropy.The first two appear on the same pop-up window.It is used internally through the button Invariants in the Analysis menu.
</p>


<h3>Author(s)</h3>

<p>Marina Saez Andreu
</p>

<hr>
<h2 id='isTimeAlright'>
isTimeAlright: checks whether a set of dates fits KarsTS format
</h2><span id='topic+isTimeAlright'></span>

<h3>Description</h3>

<p>This function checks whether a set of dates format is correct according to KarsTS specifications.It is used internally.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>isTimeAlright(timeCharacter, tz = KTSEnv$timeZone)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="isTimeAlright_+3A_timecharacter">timeCharacter</code></td>
<td>

<p>A vector containg the dates as character.
</p>
</td></tr>
<tr><td><code id="isTimeAlright_+3A_tz">tz</code></td>
<td>

<p>The time zone.
</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Marina Saez Andreu
</p>

<hr>
<h2 id='KarsTS'>
KarsTS: launches KarsTS
</h2><span id='topic+KarsTS'></span>

<h3>Description</h3>

<p>This function is used to launch KarsTS interface.
This is the only function in the package that is called through the R command window. The rest are used internally or manipulated via interface.If the user closes the interface accidentally, this function can be simply run again.  
</p>


<h3>Usage</h3>

<pre><code class='language-R'>KarsTS(skipWelcome = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="KarsTS_+3A_skipwelcome">skipWelcome</code></td>
<td>

<p>When TRUE, the interface main screen appears directly
</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Marina Saez Andreu
</p>

<hr>
<h2 id='KarsTS-package'>
An Interface for Microclimate Time Series Analysis
</h2><span id='topic+KarsTS-package'></span>

<h3>Description</h3>

<p>An R code with a GUI for microclimate time series, with an emphasis on underground environments. 'KarsTS' provides linear and nonlinear methods, including recurrence analysis (Marwan et al. (2007) &lt;doi:10.1016/j.physrep.2006.11.001&gt;) and filling methods (Moffat et al. (2007) &lt;doi:10.1016/j.agrformet.2007.08.011&gt;), as well as tools to manipulate easily time series and gap sets.
</p>


<h3>Details</h3>

<p><span class="pkg">KarsTS</span> is a package for microclimate time series, with an emphasis on undergroung environments, such as caves. Microclimate research typically includes CO2 and Rn concentrations, temperature and humidity time series, amongst others. Many of these time series have a strong nonlinear behavior and they often contain significant gaps. <span class="pkg">KarsTS</span> provides linear and non-linear analysis and filling methods, as well as tools to manipulate easily time series and gap sets. <br />
<br />
The interface <span class="pkg">KarsTS</span> is opened by running the function <code>KarsTS</code> on the R or RStudio console. It has five menus: Time Series, Gap Sets, Analysis, Plots and Filling. <br />
<b>Time Series menu</b>: time series basic manipulation (loading, saving, resampling, scaling, rounding, etc.). <br />
<b>Gap Sets menu</b>: gap sets basic manipulation (loading, saving, selection, MCAR Little's test etc.). Gap sets manipulation allows to apply a filling method to a subset of gaps in a time series (for example, gaps smaller than a certain length). <br />
<b>Analysis menu</b>: linear and non-linear analytic procedures (statistics, rolling statistics, loess decomposition,invariants, recurrence matrices, stationarity and linearity tests etc.). <br />
<b>Plots menu</b>: tools for plotting recurrence matrices, time series, phase portraits, manual removal of points etc. It contains also analytic procedures with mainly graphical results (linear correlation, mutual information, false nearest neighbors etc.). <br />
<b>Filling menu</b>: univariate and multivariate methods to fill missing values in time series (interpolation, ARIMA, random forest algorithm etc.).<br />
<br />
See the <b>User's Guide</b> for more information.
</p>


<h3>Note</h3>

<p>Please, cite this package as: <br />
Marina Saez (2018). KarsTS: An interface for microclimate time series analysis. R package version 2.2.
</p>


<h3>Author(s)</h3>

<p>Marina Saez [aut, cre],
  David Benavente [ths],
  Soledad Cuezva [ths],
  Concepcion Pla [ctb]
</p>
<p>Maintainer: Marina Saez &lt;marinasaez_andreu@hotmail.com&gt;
</p>

<hr>
<h2 id='laminarityKTS'>
laminarityKTS: estimate laminarity
</h2><span id='topic+laminarityKTS'></span>

<h3>Description</h3>

<p>This function is used to study the laminarity of a system, based on the number and length of the vertical lines that contains the recurrence matrix that represents the system. It is used internally through the button Laminarity in the Anaylisis menu.
</p>


<h3>Value</h3>

<p>The following outputs are written on KarsTS output window: recurrence rate, laminarity, ratio and summary of the lengths of the vertical lines. Besides, a new window containing a histogram of vertical lines pops up. 
</p>


<h3>Author(s)</h3>

<p>Marina Saez Andreu
</p>


<h3>References</h3>

<p>Marwan,R., Romano, M.C., Thiel,M., Kurths,J.(2007): Recurrence plots for the analysis of complex systems. Physics Reports 438, 237-329.
</p>

<hr>
<h2 id='linCorrKTS'>
linCorrKTS: linear correlation plot
</h2><span id='topic+linCorrKTS'></span>

<h3>Description</h3>

<p>This function plots the autocorrelation and partial autocorrelation functions or the cross correlation function, depending on the number of input time series. It is used internally through the Linear correlation button in the Plots menu.
</p>


<h3>Author(s)</h3>

<p>Marina Saez Andreu
</p>

<hr>
<h2 id='linearityKTS'>
linearityKTS: linearity tests
</h2><span id='topic+linearityKTS'></span>

<h3>Description</h3>

<p>This function runs a number of linearity tests using the functions surrogateTest and nonlinearityTest from package nonlinearTseries.It is used internally through the Linearity button in the Analysis menu.
</p>


<h3>Author(s)</h3>

<p>Marina Saez Andreu
</p>

<hr>
<h2 id='loadAllTypes'>
loadAllTypes: load all types of data sets
</h2><span id='topic+loadAllTypes'></span>

<h3>Description</h3>

<p>This function loads all types of data sets (time series, data sets and recurrence matrices). It generates two buttons: one is used to load R files and the other is used to import csv and txt files. The function automatically recognizes the type of data set, checks whether the format is right and places the data sets in the environment susEnv. It is used through the Load button in the Time Series or the Gap Sets menus.
</p>


<h3>Author(s)</h3>

<p>Marina Saez Andreu
</p>

<hr>
<h2 id='loadKarsTSFonts'>
loadKarsTSFonts: load KarsTS fonts
</h2><span id='topic+loadKarsTSFonts'></span>

<h3>Description</h3>

<p>This function creates fonts for KarsTS and assign them to the environment susEnv.It is used internally.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>loadKarsTSFonts()
</code></pre>


<h3>Author(s)</h3>

<p>Marina Saez Andreu
</p>

<hr>
<h2 id='loessKTS'>
loess: loess smoothing
</h2><span id='topic+loessKTS'></span>

<h3>Description</h3>

<p>This function performs a loess smoothing using the function stats::loess. The user has to enter the time series and the alpha parameter. Optionally, the user can enter the control parameter and some predictor time series.It is used through the Loess smooth. button in the Analysis menu.
</p>


<h3>Author(s)</h3>

<p>Marina Saez Andreu
</p>

<hr>
<h2 id='mainScreen'>
mainScreen: launches the main screen
</h2><span id='topic+mainScreen'></span>

<h3>Description</h3>

<p>This function launches KarsTS main screen when the welcome screen is destroyed.It is used internally.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mainScreen()
</code></pre>


<h3>Author(s)</h3>

<p>Marina Saez Andreu
</p>

<hr>
<h2 id='meanValue'>
meanValue: mean value filling
</h2><span id='topic+meanValue'></span>

<h3>Description</h3>

<p>This function replaces each missing value by the mean (or median) of the values located in equivalent positions in the periods around. It is used through the button Mean Value in the Filling menu.
</p>


<h3>Details</h3>

<p>The user needs to enter the following inputs: time series, period, number of surrounding periods to consider, maximum number of iterations, minimum number of observations ar one side and statistic (median or mean). Note that the surrounding periods can have missing values also; they can even be completely missing.The method can be applied iteratively, although it is not advisable to use many iterations because filling missing values does not increases the real amount of information available. In case the missing values concentrate at one side, the filling might be biased. The minimum number of observations at one side is useful to discard these biased fillings. 
</p>


<h3>Value</h3>

<p>The filled time series in the environment susEnv and a summary of the results on the output window.
</p>


<h3>Author(s)</h3>

<p>Marina Saez Andreu
</p>

<hr>
<h2 id='mergeTsOrGap'>
mergeTsOrGap: merges time series or gap sets
</h2><span id='topic+mergeTsOrGap'></span>

<h3>Description</h3>

<p>This function merges two or more time series and two or more gap sets. The time series cannot overlap and must have the same unique sampling period. The gap sets must coome from time series with the same initial date and sampling period.It is used through the button Merge of the Time Series or the Gap Sets menus.
</p>


<h3>Value</h3>

<p>The merged time series, the merged gap set or both.
</p>


<h3>Author(s)</h3>

<p>Marina Saez Andreu
</p>

<hr>
<h2 id='missForestKTS'>
missForestKTS: filling missing values with random forest algorithm
</h2><span id='topic+missForestKTS'></span>

<h3>Description</h3>

<p>This function is used to fill missing values using the function missForest::missForest.The user must choose the input and output time series, the number of trees and the maximum number of iterations. It is used through the button MissForest in the Filling menu.
</p>


<h3>Value</h3>

<p>The filled time series in the environment KTSEnv and a summary of the results on the output window. 
</p>


<h3>Author(s)</h3>

<p>Marina Saez Andreu
</p>

<hr>
<h2 id='modeKTS'>
modeKTS: computes the mode
</h2><span id='topic+modeKTS'></span>

<h3>Description</h3>

<p>This function computes the mode after removing missing values.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>modeKTS(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="modeKTS_+3A_x">x</code></td>
<td>

<p>The data 
</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Marina Saez Andreu
</p>

<hr>
<h2 id='mutInf'>
mutInf: mutual information
</h2><span id='topic+mutInf'></span>

<h3>Description</h3>

<p>This function calculates the mutual information between two time series via interface.The core functions belong to the package <code>infotheo</code>. 
</p>


<h3>Author(s)</h3>

<p>Marina Saez Andreu
</p>

<hr>
<h2 id='mutualKTS'>
mutualKTS: plots the mutual information
</h2><span id='topic+mutualKTS'></span>

<h3>Description</h3>

<p>This function computes the average mutual information using the function tseriesChaos::mutual and plots the result. As in the linear correlation button, the input can be one or two time series. It is used through the Mutual button in the Plots menu.
</p>


<h3>Author(s)</h3>

<p>Marina Saez Andreu
</p>

<hr>
<h2 id='myApplyVector'>
myApplyVector: apply type function
</h2><span id='topic+myApplyVector'></span>

<h3>Description</h3>

<p>This function applies a function to the elements of a vector so that the result for each element is located in a row in a matrix. It is used internally.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>myApplyVector(FUN = NULL, dataVector = NULL, out.ncols = 1, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="myApplyVector_+3A_fun">FUN</code></td>
<td>

<p>the function to apply
</p>
</td></tr>
<tr><td><code id="myApplyVector_+3A_datavector">dataVector</code></td>
<td>

<p>The vector to which elements apply the function
</p>
</td></tr>
<tr><td><code id="myApplyVector_+3A_out.ncols">out.ncols</code></td>
<td>

<p>Number of columns for the output matrix
</p>
</td></tr>
<tr><td><code id="myApplyVector_+3A_...">...</code></td>
<td>

<p>Further arguments to passed
</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Marina Saez Andreu
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
exampleF &lt;- function(X){c(X + 5, X*5)}
myApplyVector(FUN = exampleF, dataVector = 1:10, out.ncols = 2)

</code></pre>

<hr>
<h2 id='myLinModel'>
myLinModel: performs a linear fit
</h2><span id='topic+myLinModel'></span>

<h3>Description</h3>

<p>This function is used to perform a linear model between observed and predicted values. It also prepares the outputs to be writen on the output window and plots different  graphics.It is the core of the goodnessFilling function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>myLinModel(observed, predicted)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="myLinModel_+3A_observed">observed</code></td>
<td>

<p>Observed values
</p>
</td></tr>
<tr><td><code id="myLinModel_+3A_predicted">predicted</code></td>
<td>

<p>Predicted values
</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Marina Saez Andreu
</p>

<hr>
<h2 id='myScale'>
myScale: scaling function
</h2><span id='topic+myScale'></span>

<h3>Description</h3>

<p>This function is used to scale one or more variables with the possibility of removing the attributes from the base::scale output. It is also possible to perform a robust scaling using the median and the median absolute deviation instead of the mean and the standard deviation. It is used internally.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>myScale(inputMatrix, scaleType = "Robust", outputType = c("outDef", "outList", "outNo"))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="myScale_+3A_inputmatrix">inputMatrix</code></td>
<td>

<p>Matrix containing the variables to scale.
</p>
</td></tr>
<tr><td><code id="myScale_+3A_scaletype">scaleType</code></td>
<td>

<p>Robust scaling or not
</p>
</td></tr>
<tr><td><code id="myScale_+3A_outputtype">outputType</code></td>
<td>

<p>Three types of outputs: output as in base::scale, attributes removed but stored in a list and no attributes at all. 
</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Marina Saez Andreu
</p>

<hr>
<h2 id='naApproxKTS'>
naApproxKTS: filling by linear interpolation
</h2><span id='topic+naApproxKTS'></span>

<h3>Description</h3>

<p>This function fills missing values in a time series by means of linear interpolation.It is used through the Linear button in the Filling menu.
</p>


<h3>Value</h3>

<p>The filled time series in the environment KTSEnv and a summary of the results on the output window.
</p>


<h3>Author(s)</h3>

<p>Marina Saez Andreu
</p>

<hr>
<h2 id='NAs4Resamp'>
NAs4Resamp: upsamples a time series.
</h2><span id='topic+NAs4Resamp'></span>

<h3>Description</h3>

<p>NAs4Resamp introduces NAs in a time series for upsampling, via interface.The user needs to provide the new sampling period in seconds.This function only introduces NAs, then they need to be filled (menu Filling methods).
</p>


<h3>Value</h3>

<p>The upsampled time series in KarsTS format.
</p>


<h3>Author(s)</h3>

<p>Marina Saez Andreu
</p>

<hr>
<h2 id='naSplinesKTS'>
naSplinesKTS: filling by spline interpolation
</h2><span id='topic+naSplinesKTS'></span>

<h3>Description</h3>

<p>This function fills missing values in a time series by means of splines interpolation. It is used through the Splines button in the Filling menu.
</p>


<h3>Value</h3>

<p>The filled time series in the environment KTSEnv and a summary of the results on the output window.
</p>


<h3>Author(s)</h3>

<p>Marina Saez Andreu
</p>

<hr>
<h2 id='normalityKTS'>
normalityKTS: normality tests
</h2><span id='topic+normalityKTS'></span>

<h3>Description</h3>

<p>This function runs a number of normality tests using the functions uniNorm, mardiaTest and hzTest from package MVN. It is used through the Normality button in the Analysis menu.
</p>


<h3>Author(s)</h3>

<p>Marina Saez Andreu
</p>

<hr>
<h2 id='packagesToImport'>
packagesToImport: packages to import to KarsTS
</h2><span id='topic+packagesToImport'></span>

<h3>Description</h3>

<p>This function imports from other packages the functions that KarsTS needs.It is used internally.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>packagesToImport()

</code></pre>


<h3>Author(s)</h3>

<p>Marina Saez Andreu
</p>

<hr>
<h2 id='pcaKTS'>
pcaKTS: principal component analysis
</h2><span id='topic+pcaKTS'></span>

<h3>Description</h3>

<p>This function performs a principal component analysis using the function prcomp.It is used through the button PCA in the Analysis menu.
</p>


<h3>Value</h3>

<p>The punctuations as new time series in the environment KTSEnv. A summary on the output window, including the loadings and the variance explained.
</p>


<h3>Author(s)</h3>

<p>Marina Saez Andreu
</p>

<hr>
<h2 id='plotTimeSeries'>
plotTimeSeries: plot time series
</h2><span id='topic+plotTimeSeries'></span>

<h3>Description</h3>

<p>This function is used to plot one or more time series. They can be plotted using lines, points or both. The plot can appear on the plot window (main screen) or in a new window. In the second case, it is possible to select a part of the time series and plot it in another window.It is used through the Plot ts button in the Plots menu.
</p>


<h3>Author(s)</h3>

<p>Marina Saez Andreu
</p>

<hr>
<h2 id='readMultEntryvalues'>
readMultEntryvalues: verifies multiple entry values
</h2><span id='topic+readMultEntryvalues'></span>

<h3>Description</h3>

<p>This function verifies that the values of multiple text entries are valid.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>readMultEntryvalues(nElements, prefix = "entValue", type = "character")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="readMultEntryvalues_+3A_nelements">nElements</code></td>
<td>

<p>Number of entries
</p>
</td></tr>
<tr><td><code id="readMultEntryvalues_+3A_prefix">prefix</code></td>
<td>

<p>A prefix that has been previously used to name the variables associated to the entries.
</p>
</td></tr>
<tr><td><code id="readMultEntryvalues_+3A_type">type</code></td>
<td>

<p>The required type of element: character, integer or real.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The text entry values transformed in integer or real if necessary. If the value is not valid the function returns NA.
</p>


<h3>Author(s)</h3>

<p>Marina Saez Andreu
</p>

<hr>
<h2 id='refreshDataSetsList'>
refreshDataSetsList: refreshes KarsTS data set list
</h2><span id='topic+refreshDataSetsList'></span>

<h3>Description</h3>

<p>This function identifies the time series, gap sets and recurrence matrices present in the environment susEnv.It returns a list of data sets, which is assigned to susEnv so that it is accesible from all the package functions. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>refreshDataSetsList(outp = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="refreshDataSetsList_+3A_outp">outp</code></td>
<td>

<p>when outp = TRUE, it shows a summary of the data sets on the output window.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function is used internally every time a new data set is created in order to refresh the data set list. From this list, KarsTS extracts information every time it creates a check box or radiobutton of gap sets. Optionally, information about the data sets appears on the output window (when outp = TRUE ). This happens when the user runs the function by means of the button List in the Time Series or Gap Sets menus. In this case, the user gets to see the information. 
</p>


<h3>Value</h3>

<p>It returns a list containing: the time series names, the number of time series, the gap sets names, the number of gap sets, the recurrence matrices names and the number of recurrence matrices. 
</p>


<h3>Author(s)</h3>

<p>Marina Saez Andreu
</p>

<hr>
<h2 id='removeAllTypes'>
removeAllTypes: removes data sets
</h2><span id='topic+removeAllTypes'></span>

<h3>Description</h3>

<p>This function removes all types of data sets (time series, gap sets, recurrence matrices) from the environment susEnv. It is used through the button Remove in the Time Series or Gap Sets menus.
</p>


<h3>Author(s)</h3>

<p>Marina Saez Andreu
</p>

<hr>
<h2 id='removeIfExists'>
removeIfExists: remove if exists
</h2><span id='topic+removeIfExists'></span>

<h3>Description</h3>

<p>This function checks whether a variable exists and removes it in case it does. It is used to clean KTSEnv from global variables created as by-products of the procedures.  It is used internally.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>removeIfExists(candidates, envir = KTSEnv)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="removeIfExists_+3A_candidates">candidates</code></td>
<td>

<p>The names of the variables to remove.
</p>
</td></tr>
<tr><td><code id="removeIfExists_+3A_envir">envir</code></td>
<td>

<p>The environment
</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Marina Saez Andreu
</p>

<hr>
<h2 id='removePoints'>
removePoints: graphically remove points from a time series
</h2><span id='topic+removePoints'></span>

<h3>Description</h3>

<p>This function is used to remove from a time series a set of graphically selected points. It is useful to remove outliers.It is used through the Remove Points button in the Plots menu.
</p>


<h3>Details</h3>

<p>The points are actually removed from a copy of the time series, which is called by default timeSeriesName_pr. The points to remove are selected by dragging the mouse over them. All points within a radius are selected; the user can control this radius (or threshold) via interface. 
</p>


<h3>Value</h3>

<p>A new time series where the selected points values have been replaced by NAs.
</p>


<h3>Author(s)</h3>

<p>Marina Saez Andreu
</p>

<hr>
<h2 id='renameAllTypes'>
renameAllTypes: rename all types of data sets
</h2><span id='topic+renameAllTypes'></span>

<h3>Description</h3>

<p>This function is used to rename time series, gap sets or recurrence matrices. The data set with the original name is kept. It is used through the Rename button in the Time Series or the Gap Sets menus.
</p>


<h3>Author(s)</h3>

<p>Marina Saez Andreu
</p>

<hr>
<h2 id='rmCheckedTF'>
rmCheckedTF: identifies checked recurrence matrices
</h2><span id='topic+rmCheckedTF'></span>

<h3>Description</h3>

<p>This function identifies which time series have been checked from a check box.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rmCheckedTF(prefix = "rcbValue", envir = KTSEnv)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rmCheckedTF_+3A_prefix">prefix</code></td>
<td>

<p>A prefix to reconstruct the names that were assigned to the variables in the check box.
</p>
</td></tr>
<tr><td><code id="rmCheckedTF_+3A_envir">envir</code></td>
<td>

<p>The environment
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A logical vector
</p>


<h3>Author(s)</h3>

<p>Marina Saez Andreu
</p>

<hr>
<h2 id='rmDetect'>
rmDetect: identifies the recurrence matrices currently loaded
</h2><span id='topic+rmDetect'></span>

<h3>Description</h3>

<p>This function identifies the recurrence matrices currently loaded in the environment susEnv. It is used internally.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rmDetect()
</code></pre>


<h3>Value</h3>

<p>A vector containing the names of the recurrence matrices
</p>


<h3>Author(s)</h3>

<p>Marina Saez Andreu
</p>

<hr>
<h2 id='rmSlopeOutliers'>
rmSlopeOutliers: slope filter
</h2><span id='topic+rmSlopeOutliers'></span>

<h3>Description</h3>

<p>This function filters the slope (difference) outliers in a time series. It finds the greater outlier, it removes the value causing it and it tries to re-fill value by linear interpolation. Then the greater outlier in the modified time series is found and so on. It is used internally.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rmSlopeOutliers(tS = NULL, origMxPosSlope = NULL, origMxNegSlope = NULL, filling = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rmSlopeOutliers_+3A_ts">tS</code></td>
<td>

<p>The time series
</p>
</td></tr>
<tr><td><code id="rmSlopeOutliers_+3A_origmxposslope">origMxPosSlope</code></td>
<td>

<p>The maximum allowed positive slope. Greater slopes are considered as outliers.
</p>
</td></tr>
<tr><td><code id="rmSlopeOutliers_+3A_origmxnegslope">origMxNegSlope</code></td>
<td>

<p>The maximum allowed negative slope. Greater slopes (in absolute value) are considered as outliers.
</p>
</td></tr>
<tr><td><code id="rmSlopeOutliers_+3A_filling">filling</code></td>
<td>

<p>The positions in the time series corresponding to filled values(that is, not actual observations).When this argument is not null, the actual observations remain untouched whether if they cause outliers or not. 
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The smoothed time series. The function stops when there are no more outliers or when it reaches 100000 iterations. This is a safety measure to avoid infinite loops.If the time series still contains outliers, run the function again.  
</p>


<h3>Author(s)</h3>

<p>Marina Saez andreu
</p>

<hr>
<h2 id='rollStatisticsKTS'>
rollStatisticsKTS: rolling statistics
</h2><span id='topic+rollStatisticsKTS'></span>

<h3>Description</h3>

<p>This function gathers, via interface, the outputs that are necessary to run the function getRollStatistics. It is used through the button Rolling statistics in the Analysis menu.
</p>


<h3>Author(s)</h3>

<p>Marina Saez Andreu
</p>

<hr>
<h2 id='roundKTS'>
roundKTS: rounding
</h2><span id='topic+roundKTS'></span>

<h3>Description</h3>

<p>This function rounds the values of one or more time series to a number of decimal places or significant digits. When the user enters both, the significant digits option takes priority.It is used through the button Round in the Time Series menu.
</p>


<h3>Value</h3>

<p>The rounded time series in the environment KTSEnv.
</p>


<h3>Author(s)</h3>

<p>Marina Saez Andreu
</p>

<hr>
<h2 id='RPKTS'>
Recurrence of probability
</h2><span id='topic+RPKTS'></span>

<h3>Description</h3>

<p>RPKTS:This function is used to calculate the recurrece probability via interface
</p>


<h3>Details</h3>

<p>When two time series are selected, KarsTS calculates their correlation probability of recurrence too.
</p>


<h3>Author(s)</h3>

<p>Marina Saez Andreu
</p>


<h3>References</h3>

<p>Romano, M. C. (2004). Synchronization Analysis by Means of Recurrences in Phase Space, Universitat Postdam. Doctoral dissertation.
</p>

<hr>
<h2 id='saveAllTypes'>
saveAllTypes: saves all types of data sets.
</h2><span id='topic+saveAllTypes'></span>

<h3>Description</h3>

<p>This function saves all types of data sets (time series, gap sets or recurrence matrices) to one or more R files in the working directory. When various data sets are to be saved to the same file, the user must provide name; otherwise, the file bear the name of the data set.Through the button save in the Time Series or the Gap Sets menu. 
</p>


<h3>Author(s)</h3>

<p>Marina Saez Andreu
</p>

<hr>
<h2 id='saveReport'>
saveReport: saves report
</h2><span id='topic+saveReport'></span>

<h3>Description</h3>

<p>This function saves the contents of the output window to a txt file in the working directory.The file name is report plus the date of creation.Through the button Save report to txt file (lower part of the main screen).
</p>


<h3>Author(s)</h3>

<p>Marina Saez Andreu
</p>

<hr>
<h2 id='scaleKTS'>
scaleKTS: scale time series
</h2><span id='topic+scaleKTS'></span>

<h3>Description</h3>

<p>This function is used to scale or more time series. It handles the inputs and outputs of the myScale function.Through the button Scale in the Time Series menu.
</p>


<h3>Author(s)</h3>

<p>Marina Saez Andreu
</p>

<hr>
<h2 id='scattTimeSeries'>
A function for plotting time series in the phase space
</h2><span id='topic+scattTimeSeries'></span>

<h3>Description</h3>

<p>This function plots time series in a two dimensional or three dimensional phase space. The time series can be embedded so that the sum of the dimension of all time series is 2 or 3. Is is used through the Phase Portraits button in the Plots Menu. 
</p>


<h3>Author(s)</h3>

<p>Marina Saez Andreu
</p>

<hr>
<h2 id='selectionGaps'>
selectionGaps: select gaps in a time series
</h2><span id='topic+selectionGaps'></span>

<h3>Description</h3>

<p>This function is used create a gap set from a time series. The new gap set contains the gaps that meet some criteria. The available criteria are: all gaps, minimum length, maximum length and specific gaps (selected from a list). The user can choose one or more criteria.Through the button Gap selection in the Gap Sets menu.
</p>


<h3>Details</h3>

<p>The criteria can be combined in two ways: a. (minimum length and maximum length) and specific gaps; b. (minimum length or maximum length) and specific gaps. When the user chooses only one length criterion, the combination must be the second (the first one would produce and empty gap). 
</p>


<h3>Value</h3>

<p>A gap set gathering the required gaps. 
</p>


<h3>Author(s)</h3>

<p>Marina Saez Andreu
</p>

<hr>
<h2 id='selectionTS'>
selectionTS
</h2><span id='topic+selectionTS'></span>

<h3>Description</h3>

<p>This function is used to cut a piece of time series, resample a time series or both. The user chooses the initial and final dates of the new time series and the resampling factor.The dates default to the original time series extremes and the resampling factor defaults to 1(no resampling). Through the Cut and resampling button in the Time Series menu.
</p>


<h3>Author(s)</h3>

<p>Marina Saez Andreu
</p>

<hr>
<h2 id='separateEntry'>
separateEntry: separates and checks comma-separated entry values
</h2><span id='topic+separateEntry'></span>

<h3>Description</h3>

<p>Some text entries in KarsTS consist of a list of values separated by commas. This function separates the values and checks whether they have the appropiate format.It is used internally
</p>


<h3>Usage</h3>

<pre><code class='language-R'>separateEntry(y, class1 = verifyIntEntry, class2 = verifyCharEntry, noValid = NA)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="separateEntry_+3A_y">y</code></td>
<td>

<p>The value to check
</p>
</td></tr>
<tr><td><code id="separateEntry_+3A_class1">class1</code></td>
<td>

<p>The class the first element should be
</p>
</td></tr>
<tr><td><code id="separateEntry_+3A_class2">class2</code></td>
<td>

<p>The class the second element should be
</p>
</td></tr>
<tr><td><code id="separateEntry_+3A_novalid">noValid</code></td>
<td>

<p>The output to return when the input is not valid
</p>
</td></tr>
</table>

<hr>
<h2 id='setCorrectDate'>
setCorrectDate: verifies date entry and returns proper output
</h2><span id='topic+setCorrectDate'></span>

<h3>Description</h3>

<p>This function is used inside the verifyDateEntry function, whic is used to verify if a date is correct. The function setCorrectDate verifies if the year, month, day, hour, minutes or seconds are correct. For example, the day has to be an integer between 1 and 31, the minutes and seconds must be integers between 0 an 59 etc.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>setCorrectDate(x, type)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="setCorrectDate_+3A_x">x</code></td>
<td>

<p>The element to test
</p>
</td></tr>
<tr><td><code id="setCorrectDate_+3A_type">type</code></td>
<td>

<p>The type of element: year, month, day, hour, minute or second
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The element if it is valid; NA otherwise.
</p>


<h3>Author(s)</h3>

<p>Marina Saez Andreu
</p>

<hr>
<h2 id='setwdKTS'>
setwdKTS: set working directory
</h2><span id='topic+setwdKTS'></span>

<h3>Description</h3>

<p>This function is used to change the working directory by means of the Set WD button on the main screen.
</p>


<h3>Author(s)</h3>

<p>Marina Saez Andreu
</p>

<hr>
<h2 id='showHelp'>
showHelp: shows KarsTS help
</h2><span id='topic+showHelp'></span>

<h3>Description</h3>

<p>This function is used to open a short help file through the Help button on KarsTS main screen. For further help, a User's Guide in pdf format is available.
</p>


<h3>Author(s)</h3>

<p>Marina Saez Andreu
</p>

<hr>
<h2 id='slopeOutliersBut'>
slopeOutliersBut: remove slope outliers
</h2><span id='topic+slopeOutliersBut'></span>

<h3>Description</h3>

<p>This function handles the inputs and outputs from function rmSlopeOutliers. It removes, one by one, points that produce abnormally steep slopes and replaces them by linear interpolation. The peaks are progresively filed down and the result is a smoothed time series. Usually, these outliers are caused by wrong measurements; filling missing values can produce them also.It is used through the button Rm slope Outliers in the Filling menu.
</p>


<h3>Details</h3>

<p>In the first step, the user must choose the time series to smooth and whether if the outliers must be removed from a filling or from the whole time series. In the second step, the user must provide the maximum positive and negative slopes or, alternatively, a reference time series from which calculate them. When the outliers are removed from a filling, the reference time series is the non-filled time series.
</p>


<h3>Value</h3>

<p>The smoothed time series. In order to avoid infinite loops, there is a maximum of 100000 iterations. If, by then, the time series has not been completely smoothed, it will necessary to apply the function again.
</p>


<h3>Author(s)</h3>

<p>Marina Saez Andreu
</p>

<hr>
<h2 id='stationarityKTS'>
stationarityKTS: stationarity tests
</h2><span id='topic+stationarityKTS'></span>

<h3>Description</h3>

<p>This function runs a number of stationarity tests using the functions PP.test and Box.test from package stats and adf.test and kpss.test from package tseries.Through the Stationarity button in the Analysis menu.
</p>


<h3>Author(s)</h3>

<p>Marina Saez Andreu
</p>

<hr>
<h2 id='statisticsKTS'>
statisticsKTS: calculates the statistics of one or more time series
</h2><span id='topic+statisticsKTS'></span>

<h3>Description</h3>

<p>This function handles the inputs and outputs from the function getStatistics, which is used to calculate the statistics of a time series.Through the button Statistics in the Analysis menu.
</p>


<h3>Value</h3>

<p>A table on the output window.
</p>


<h3>Author(s)</h3>

<p>Marina Saez Andreu
</p>

<hr>
<h2 id='stinemannKTS'>
stinemannKTS: filling by Stinemann's interpolation
</h2><span id='topic+stinemannKTS'></span>

<h3>Description</h3>

<p>This function fills missing values in a time series by means of Stinemann's interpolation.Through the Stinemann's button in the Filling menu.
</p>


<h3>Value</h3>

<p>The filled time series in the environment KTSEnv and a summary of the results on the output window.
</p>


<h3>Author(s)</h3>

<p>Marina Saez Andreu
</p>

<hr>
<h2 id='stlplusKTS'>
stlplusKTS: loess seasonal decomposition
</h2><span id='topic+stlplusKTS'></span>

<h3>Description</h3>

<p>This function performs a loess seasonal decomposition using the function stlplus::stlplus.
Through the button Loess.decomp. in the Analysis menu.
</p>


<h3>Details</h3>

<p>The user enters via interface the time series, the period, the seasonal window, the trend window and the type of decomposition (additive or multiplicative). Optionally, the trend can be decomposed using more windows.
</p>


<h3>Value</h3>

<p>The trend, the seasonal and the irregular components.These bear the name of the original time series plus Tr, Sea and Rem, respectively. If the trend is further decomposed, the user must enter names for the output components. 
</p>


<h3>Author(s)</h3>

<p>Marina Saez Andreu
</p>

<hr>
<h2 id='theilerKTS'>
theilerKTS: apply Theiler's window via interface
</h2><span id='topic+theilerKTS'></span>

<h3>Description</h3>

<p>It applies a Theiler's window to a recurrence matrix via interface.
</p>


<h3>Author(s)</h3>

<p>Marina Saez Andreu
</p>

<hr>
<h2 id='tsCheckedTF'>
tsCheckedTF: identifies checked time series
</h2><span id='topic+tsCheckedTF'></span>

<h3>Description</h3>

<p>This function identifies which time series have been checked from a check box. It is used internally.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tsCheckedTF(prefix = "scbValue", envir = KTSEnv)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tsCheckedTF_+3A_prefix">prefix</code></td>
<td>

<p>A prefix to reconstruct the names that were assigned to the variables in the check box.
</p>
</td></tr>
<tr><td><code id="tsCheckedTF_+3A_envir">envir</code></td>
<td>

<p>The environment
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A logical vector
</p>


<h3>Author(s)</h3>

<p>Marina Saez Andreu
</p>

<hr>
<h2 id='tsDetect'>
tsDetect: identifies the time series currently loaded
</h2><span id='topic+tsDetect'></span>

<h3>Description</h3>

<p>This function identifies the time series currently loaded in the environment susEnv
It is used internally
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tsDetect()
</code></pre>


<h3>Value</h3>

<p>A vector containing the names of the time series
</p>


<h3>Author(s)</h3>

<p>Marina Saez Andreu
</p>

<hr>
<h2 id='verifyCharEntry'>
verifyCharEntry: verify character entries
</h2><span id='topic+verifyCharEntry'></span>

<h3>Description</h3>

<p>This function reads a variable coming from a text entry and checks whether it is character or not.It is used internally.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>verifyCharEntry(x, noValid = "isNoValid")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="verifyCharEntry_+3A_x">x</code></td>
<td>

<p>The element to check
</p>
</td></tr>
<tr><td><code id="verifyCharEntry_+3A_novalid">noValid</code></td>
<td>

<p>The output the function will return when the input is not character.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>One-character strings are not allowed.
</p>


<h3>Author(s)</h3>

<p>Marina Saez Andreu
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
verifyCharEntry("Strawberry", noValid = "isNoValid")
verifyCharEntry(235, noValid = "isNoValid")
verifyCharEntry(235, noValid = NA)

</code></pre>

<hr>
<h2 id='verifyDateEntry'>
verifyDateEntry: verify date entries
</h2><span id='topic+verifyDateEntry'></span>

<h3>Description</h3>

<p>This function checks whether a date is valid or not.It has six inputs (seconds, minutes,hours,day,month and year); these come from a set of text entries.It is used internally.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>verifyDateEntry(valSecs, valMins, valHour, valDay, valMonth, valYear)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="verifyDateEntry_+3A_valsecs">valSecs</code></td>
<td>

<p>Seconds
</p>
</td></tr>
<tr><td><code id="verifyDateEntry_+3A_valmins">valMins</code></td>
<td>

<p>Minutes
</p>
</td></tr>
<tr><td><code id="verifyDateEntry_+3A_valhour">valHour</code></td>
<td>

<p>Hour
</p>
</td></tr>
<tr><td><code id="verifyDateEntry_+3A_valday">valDay</code></td>
<td>

<p>Day
</p>
</td></tr>
<tr><td><code id="verifyDateEntry_+3A_valmonth">valMonth</code></td>
<td>

<p>Month
</p>
</td></tr>
<tr><td><code id="verifyDateEntry_+3A_valyear">valYear</code></td>
<td>

<p>Year
</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Marina Saez Andreu
</p>

<hr>
<h2 id='verifyIntEntry'>
verifyIntEntry: verify integer entries
</h2><span id='topic+verifyIntEntry'></span>

<h3>Description</h3>

<p>This function reads a variable coming from a text entry and checks whether it is integer or not.It is used internally.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>verifyIntEntry(x, noValid = "isNoValid")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="verifyIntEntry_+3A_x">x</code></td>
<td>

<p>The element to check
</p>
</td></tr>
<tr><td><code id="verifyIntEntry_+3A_novalid">noValid</code></td>
<td>

<p>The output the function will return when the input is not character.
</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Marina Saez Andreu
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
verifyIntEntry("Strawberry", noValid = "isNoValid")
verifyIntEntry(235.6, noValid = NA)
verifyIntEntry(235, noValid = NA)
verifyIntEntry(0235, noValid = NA)
verifyIntEntry(235.0, noValid = NA)

</code></pre>

<hr>
<h2 id='verifyRealEntry'>
verifyRealEntry: verify character entries
</h2><span id='topic+verifyRealEntry'></span>

<h3>Description</h3>

<p>This function reads a variable coming from a text entry and checks whether it is real or not.It is used internally.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>verifyRealEntry(x, noValid = "isNoValid")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="verifyRealEntry_+3A_x">x</code></td>
<td>

<p>The element to check
</p>
</td></tr>
<tr><td><code id="verifyRealEntry_+3A_novalid">noValid</code></td>
<td>

<p>The output the function will return when the input is not character.
</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Marina Saez Andreu
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
verifyRealEntry("Strawberry", noValid = "isNoValid")
verifyRealEntry(235, noValid = NA)
verifyRealEntry(0235, noValid = NA)
verifyRealEntry(235.6, noValid = NA)

</code></pre>

<hr>
<h2 id='welcomeScreen'>
welcomeScreen: launches the welcome screen
</h2><span id='topic+welcomeScreen'></span>

<h3>Description</h3>

<p>This function launches KarsTS welcome screen. It is used internally.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>welcomeScreen()
</code></pre>


<h3>Author(s)</h3>

<p>Marina Saez Andreu
</p>

<hr>
<h2 id='windRoseKTS'>
windRoseKTS: wind rose
</h2><span id='topic+windRoseKTS'></span>

<h3>Description</h3>

<p>This function plots a wind rose from directional data. The data must be in sexagesimal degrees. It is used through the button Wind Rose in the Analysis menu.
</p>


<h3>Author(s)</h3>

<p>Marina Saez Andreu
</p>

<hr>
<h2 id='writeMethodSummary'>
writeMethodSummary: writes a summary of the filling method
</h2><span id='topic+writeMethodSummary'></span>

<h3>Description</h3>

<p>This function is internally used when any of the filling methods that KarsTS offers is used. It writes on KarsTS output window information that is shared by all filling methods: which time series and gap set were to fill, which gaps were effectively filled and which remained empty. Filling-method-specific information is writen trhough other functions. It is used internally.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>writeMethodSummary(filledNasTable, remainingNAsInGap, selTsName, selGapName, selGap)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="writeMethodSummary_+3A_fillednastable">filledNasTable</code></td>
<td>

<p>Table of filled gaps
</p>
</td></tr>
<tr><td><code id="writeMethodSummary_+3A_remainingnasingap">remainingNAsInGap</code></td>
<td>

<p>Table of gaps that could not be filled. It does not include gaps whose filling was not attempted. 
</p>
</td></tr>
<tr><td><code id="writeMethodSummary_+3A_seltsname">selTsName</code></td>
<td>

<p>Name of the time series that was filled.
</p>
</td></tr>
<tr><td><code id="writeMethodSummary_+3A_selgapname">selGapName</code></td>
<td>

<p>Name of the gap set that was meant to be filled
</p>
</td></tr>
<tr><td><code id="writeMethodSummary_+3A_selgap">selGap</code></td>
<td>

<p>Gap set that was meant to be filled
</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Marina Saez Andreu
</p>

<hr>
<h2 id='writeMethodTitle'>
writeMethodTitle: writes a title on KarsTS output window
</h2><span id='topic+writeMethodTitle'></span>

<h3>Description</h3>

<p>This function writes a title on KarsTS output window. It is used internally.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>writeMethodTitle(titleMethod)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="writeMethodTitle_+3A_titlemethod">titleMethod</code></td>
<td>

<p>The text of the title
</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Marina Saez Andreu
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
