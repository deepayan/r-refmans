<!DOCTYPE html><html><head><title>Help for package yum</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {yum}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#build_tree'><p>Convert the objects loaded from YAML fragments into a tree</p></a></li>
<li><a href='#delete_yaml_fragments'><p>Delete all YAML fragments from a file</p></a></li>
<li><a href='#extract_yaml_dir'><p>Extract all YAML fragments from all files in a directory</p></a></li>
<li><a href='#extract_yaml_fragments'><p>Extract all YAML fragments from a file</p></a></li>
<li><a href='#find_yaml_fragment_indices'><p>Find the indices ('line numbers') of all YAML fragments from a file</p></a></li>
<li><a href='#flatten_list_of_lists'><p>Flatten a list of lists to a list of atomic vectors</p></a></li>
<li><a href='#is.odd'><p>Checking whether numbers are odd or even</p></a></li>
<li><a href='#load_and_simplify'><p>Load YAML fragments in one or multiple files and simplify them</p></a></li>
<li><a href='#load_yaml_dir'><p>Load all YAML fragments from all files in a directory</p></a></li>
<li><a href='#load_yaml_fragments'><p>Load all YAML fragments from a file</p></a></li>
<li><a href='#load_yaml_list'><p>Load all YAML fragments from all character vectors in a list</p></a></li>
<li><a href='#simplify_by_flattening'><p>Simplify the structure of extracted YAML fragments</p></a></li>
<li><a href='#vecTxt'><p>Easily parse a vector into a character value</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Title:</td>
<td>Utilities to Extract and Process 'YAML' Fragments</td>
</tr>
<tr>
<td>Version:</td>
<td>0.1.0</td>
</tr>
<tr>
<td>Description:</td>
<td>Provides a number of functions to facilitate
  extracting information in 'YAML' fragments from one or 
  multiple files, optionally structuring the information
  in a 'data.tree'. 'YAML' (recursive acronym for "YAML ain't
  Markup Language") is a convention for specifying structured
  data in a format that is both machine- and human-readable.
  'YAML' therefore lends itself well for embedding (meta)data
  in plain text files, such as Markdown files. This principle
  is implemented in 'yum' with minimal dependencies (i.e. only
  the 'yaml' packages, and the 'data.tree' package can be
  used to enable additional functionality).</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://r-packages.gitlab.io/yum">https://r-packages.gitlab.io/yum</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://gitlab.com/r-packages/yum/-/issues">https://gitlab.com/r-packages/yum/-/issues</a></td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.1.1</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.0.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>yaml (&ge; 2.2)</td>
</tr>
<tr>
<td>Suggests:</td>
<td>covr, data.tree (&ge; 0.7), here, testthat</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2021-07-16 18:56:40 UTC; micro</td>
</tr>
<tr>
<td>Author:</td>
<td>Gjalt-Jorn Peters [aut, cre]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Gjalt-Jorn Peters &lt;gjalt-jorn@userfriendlyscience.com&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2021-07-16 19:20:03 UTC</td>
</tr>
</table>
<hr>
<h2 id='build_tree'>Convert the objects loaded from YAML fragments into a tree</h2><span id='topic+build_tree'></span>

<h3>Description</h3>

<p>If the <a href="data.tree.html#topic+data.tree">data.tree::data.tree</a> package is installed, this function
can be used to convert a list of objects, as loaded from extracted
YAML fragments, into a <code><a href="data.tree.html#topic+Node">data.tree::Node()</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>build_tree(
  x,
  idName = "id",
  parentIdName = "parentId",
  childrenName = "children",
  autofill = c(label = "id"),
  rankdir = "LR",
  directed = "false",
  silent = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="build_tree_+3A_x">x</code></td>
<td>
<p>Either a list of YAML fragments loaded from a file with
<code><a href="#topic+load_yaml_fragments">load_yaml_fragments()</a></code>, or a list of such lists loaded from all files
in a directory with <code><a href="#topic+load_yaml_dir">load_yaml_dir()</a></code>.</p>
</td></tr>
<tr><td><code id="build_tree_+3A_idname">idName</code></td>
<td>
<p>The name of the field containing each elements' identifier,
used to build the data tree when there are references to a parent from a child
element.</p>
</td></tr>
<tr><td><code id="build_tree_+3A_parentidname">parentIdName</code></td>
<td>
<p>The name of the field containing references to an element's
parent element (i.e. the field containing the identifier of the corresponding
parent element).</p>
</td></tr>
<tr><td><code id="build_tree_+3A_childrenname">childrenName</code></td>
<td>
<p>The name of the field containing an element's children, either
as a list of elements, or using the 'shorthand' notation, in which case a vector
is supplied with the identifiers of the children.</p>
</td></tr>
<tr><td><code id="build_tree_+3A_autofill">autofill</code></td>
<td>
<p>A named vector where the names represent fields to fill with
the values of the fields specified in the vector values. Note that autofill
replacements are only applied if the fields to be autofilled (i.e. the names of
the vector specified in <code>autofill</code>) do not already have a value.</p>
</td></tr>
<tr><td><code id="build_tree_+3A_rankdir">rankdir</code></td>
<td>
<p>How to plot the plot when it's plotted: the default <code>"LR"</code> plots from
left to right. Specify e.g. <code>"TB"</code> to plot from top to bottom.</p>
</td></tr>
<tr><td><code id="build_tree_+3A_directed">directed</code></td>
<td>
<p>Whether the edges should have arrows (<code>"forward"</code> or <code>"backward"</code>)
or not (<code>"false"</code>).</p>
</td></tr>
<tr><td><code id="build_tree_+3A_silent">silent</code></td>
<td>
<p>Whether to provide (<code>FALSE</code>) or suppress (<code>TRUE</code>) more detailed progress updates.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a <code><a href="data.tree.html#topic+Node">data.tree::Node()</a></code> object.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>loadedYum &lt;- yum::load_yaml_fragments(text=c(
"---",
"-",
"  id: firstFragment",
"---",
"Outside of YAML",
"---",
"-",
"  id: secondFragment",
"  parentId: firstFragment",
"---",
"Also outside of YAML"));
yum::build_tree(loadedYum);
</code></pre>

<hr>
<h2 id='delete_yaml_fragments'>Delete all YAML fragments from a file</h2><span id='topic+delete_yaml_fragments'></span>

<h3>Description</h3>

<p>These function deletes all YAML fragments from a file, returning
a character vector without the lines that specified the YAML
fragments.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>delete_yaml_fragments(
  file,
  text,
  delimiterRegEx = "^---$",
  ignoreOddDelimiters = FALSE,
  silent = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="delete_yaml_fragments_+3A_file">file</code></td>
<td>
<p>The path to a file to scan; if provided, takes precedence
over <code>text</code>.</p>
</td></tr>
<tr><td><code id="delete_yaml_fragments_+3A_text">text</code></td>
<td>
<p>A character vector to scan, where every element should
represent one line in the file; can be specified instead of <code>file</code>.</p>
</td></tr>
<tr><td><code id="delete_yaml_fragments_+3A_delimiterregex">delimiterRegEx</code></td>
<td>
<p>The regular expression used to locate YAML
fragments.</p>
</td></tr>
<tr><td><code id="delete_yaml_fragments_+3A_ignoreodddelimiters">ignoreOddDelimiters</code></td>
<td>
<p>Whether to throw an error (FALSE) or
delete the last delimiter (TRUE) if an odd number of delimiters is
encountered.</p>
</td></tr>
<tr><td><code id="delete_yaml_fragments_+3A_silent">silent</code></td>
<td>
<p>Whether to be silent (TRUE) or informative (FALSE).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of character vectors.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>yum::delete_yaml_fragments(text=c("---", "First YAML fragment", "---",
                                   "Outside of YAML",
                                   "---", "Second fragment", "---",
                                   "Also outside of YAML"));

</code></pre>

<hr>
<h2 id='extract_yaml_dir'>Extract all YAML fragments from all files in a directory</h2><span id='topic+extract_yaml_dir'></span>

<h3>Description</h3>

<p>These function extracts all YAML fragments from all files in a
directory returning a list of character vectors containing the
extracted fragments.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>extract_yaml_dir(
  path,
  recursive = TRUE,
  fileRegexes = c("^[^\\.]+.*$"),
  delimiterRegEx = "^---$",
  ignoreOddDelimiters = FALSE,
  encoding = "UTF-8",
  silent = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="extract_yaml_dir_+3A_path">path</code></td>
<td>
<p>The path containing the files.</p>
</td></tr>
<tr><td><code id="extract_yaml_dir_+3A_recursive">recursive</code></td>
<td>
<p>Whether to also process subdirectories (<code>TRUE</code>)
or not (<code>FALSE</code>).</p>
</td></tr>
<tr><td><code id="extract_yaml_dir_+3A_fileregexes">fileRegexes</code></td>
<td>
<p>A vector of regular expressions to match the files
against: only files matching one or more regular expressions in this
vector are processed. The default regex (<code style="white-space: pre;">&#8288;^[^\.]+.*$&#8288;</code>) matches all
files except those that start with a period (<code>.</code>).</p>
</td></tr>
<tr><td><code id="extract_yaml_dir_+3A_delimiterregex">delimiterRegEx</code></td>
<td>
<p>The regular expression used to locate YAML
fragments.</p>
</td></tr>
<tr><td><code id="extract_yaml_dir_+3A_ignoreodddelimiters">ignoreOddDelimiters</code></td>
<td>
<p>Whether to throw an error (FALSE) or
delete the last delimiter (TRUE) if an odd number of delimiters is
encountered.</p>
</td></tr>
<tr><td><code id="extract_yaml_dir_+3A_encoding">encoding</code></td>
<td>
<p>The encoding to use when calling <code><a href="base.html#topic+readLines">readLines()</a></code>. Set to
NULL to let <code><a href="base.html#topic+readLines">readLines()</a></code> guess.</p>
</td></tr>
<tr><td><code id="extract_yaml_dir_+3A_silent">silent</code></td>
<td>
<p>Whether to be silent (<code>TRUE</code>) or informative (<code>FALSE</code>).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of character vectors.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>### First get the directory where 'yum' is installed
yumDir &lt;- system.file(package="yum");
### Specify the path of some example files
examplePath &lt;- file.path(yumDir, "extdata");
### Show files (should be three .dct files)
list.files(examplePath);
### Load these files
yum::extract_yaml_dir(path=examplePath);
</code></pre>

<hr>
<h2 id='extract_yaml_fragments'>Extract all YAML fragments from a file</h2><span id='topic+extract_yaml_fragments'></span>

<h3>Description</h3>

<p>These function extracts all YAML fragments from a file,
returning a list of character vectors containing the extracted
fragments.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>extract_yaml_fragments(
  text,
  file,
  delimiterRegEx = "^---$",
  ignoreOddDelimiters = FALSE,
  encoding = "UTF-8",
  silent = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="extract_yaml_fragments_+3A_text">text</code>, <code id="extract_yaml_fragments_+3A_file">file</code></td>
<td>
<p>As <code>text</code> or <code>file</code>, you can specify a <code>file</code> to read with
encoding <code>encoding</code>, which will then be read using <code><a href="base.html#topic+readLines">base::readLines()</a></code>. If the
argument is named <code>text</code>, whether it is the path to an existing file is checked
first, and if it is, that file is read. If the argument is named <code>file</code>, and it
does not point to an existing file, an error is produced (useful if calling
from other functions). A <code>text</code> should be a character vector where every
element is a line of the original source (like provided by <code><a href="base.html#topic+readLines">base::readLines()</a></code>);
although if a character vector of one element <em>and</em> including at least one
newline character (<code style="white-space: pre;">&#8288;\\n&#8288;</code>) is provided as <code>text</code>, it is split at the newline
characters using <code><a href="base.html#topic+strsplit">base::strsplit()</a></code>. Basically, this behavior means that the
first argument can be either a character vector or the path to a file; and if
you're specifying a file and you want to be certain that an error is thrown if
it doesn't exist, make sure to name it <code>file</code>.</p>
</td></tr>
<tr><td><code id="extract_yaml_fragments_+3A_delimiterregex">delimiterRegEx</code></td>
<td>
<p>The regular expression used to locate YAML
fragments.</p>
</td></tr>
<tr><td><code id="extract_yaml_fragments_+3A_ignoreodddelimiters">ignoreOddDelimiters</code></td>
<td>
<p>Whether to throw an error (FALSE) or
delete the last delimiter (TRUE) if an odd number of delimiters is
encountered.</p>
</td></tr>
<tr><td><code id="extract_yaml_fragments_+3A_encoding">encoding</code></td>
<td>
<p>The encoding to use when calling <code><a href="base.html#topic+readLines">readLines()</a></code>. Set to
NULL to let <code><a href="base.html#topic+readLines">readLines()</a></code> guess.</p>
</td></tr>
<tr><td><code id="extract_yaml_fragments_+3A_silent">silent</code></td>
<td>
<p>Whether to be silent (<code>TRUE</code>) or informative (<code>FALSE</code>).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of character vectors, where each vector corresponds to
one YAML fragment in the source file or text.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>extract_yaml_fragments(text="
---
First: YAML fragment
  id: firstFragment
---
Outside of YAML
---
Second: YAML fragment
  id: secondFragment
  parentId: firstFragment
---
Also outside of YAML
");
</code></pre>

<hr>
<h2 id='find_yaml_fragment_indices'>Find the indices ('line numbers') of all YAML fragments from a file</h2><span id='topic+find_yaml_fragment_indices'></span>

<h3>Description</h3>

<p>These function finds all YAML fragments from a file, returning
their start and end indices or all indices of all lines in the (non-)YAML
fragments.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>find_yaml_fragment_indices(
  file,
  text,
  invert = FALSE,
  returnFragmentIndices = TRUE,
  returnPairedIndices = TRUE,
  delimiterRegEx = "^---$",
  ignoreOddDelimiters = FALSE,
  silent = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="find_yaml_fragment_indices_+3A_file">file</code></td>
<td>
<p>The path to a file to scan; if provided, takes precedence
over <code>text</code>.</p>
</td></tr>
<tr><td><code id="find_yaml_fragment_indices_+3A_text">text</code></td>
<td>
<p>A character vector to scan, where every element should
represent one line in the file; can be specified instead of <code>file</code>.</p>
</td></tr>
<tr><td><code id="find_yaml_fragment_indices_+3A_invert">invert</code></td>
<td>
<p>Set to <code>TRUE</code> to return the indices of the character
vector that are <em>not</em> YAML fragments.</p>
</td></tr>
<tr><td><code id="find_yaml_fragment_indices_+3A_returnfragmentindices">returnFragmentIndices</code></td>
<td>
<p>Set to <code>TRUE</code> to return all indices of the
relevant fragments (i.e. including intermediate indices).</p>
</td></tr>
<tr><td><code id="find_yaml_fragment_indices_+3A_returnpairedindices">returnPairedIndices</code></td>
<td>
<p>Whether to return two vectors with the
start and end indices, or pair them up in vectors of 2.</p>
</td></tr>
<tr><td><code id="find_yaml_fragment_indices_+3A_delimiterregex">delimiterRegEx</code></td>
<td>
<p>The regular expression used to locate YAML
fragments.</p>
</td></tr>
<tr><td><code id="find_yaml_fragment_indices_+3A_ignoreodddelimiters">ignoreOddDelimiters</code></td>
<td>
<p>Whether to throw an error (FALSE) or
delete the last delimiter (TRUE) if an odd number of delimiters is
encountered.</p>
</td></tr>
<tr><td><code id="find_yaml_fragment_indices_+3A_silent">silent</code></td>
<td>
<p>Whether to be silent (TRUE) or informative (FALSE).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of numeric vectors with start and end indices
</p>


<h3>Examples</h3>

<pre><code class='language-R'>### Create simple text vector with the right delimiters
simpleExampleText &lt;-
  c(
    "---",
    "First YAML fragment",
    "---",
    "Outside of YAML",
    "This, too.",
    "---",
    "Second fragment",
    "---",
    "Also outside of YAML",
    "Another one outside",
    "Last one"
  );

yum::find_yaml_fragment_indices(
  text=simpleExampleText
);

yum::find_yaml_fragment_indices(
  text=simpleExampleText,
  returnFragmentIndices = FALSE
);

yum::find_yaml_fragment_indices(
  text=simpleExampleText,
  invert = TRUE
);

</code></pre>

<hr>
<h2 id='flatten_list_of_lists'>Flatten a list of lists to a list of atomic vectors</h2><span id='topic+flatten_list_of_lists'></span>

<h3>Description</h3>

<p>This function takes a hierarchical structure of lists and
extracts all atomic vectors, returning one flat list of all
those vectors.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>flatten_list_of_lists(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="flatten_list_of_lists_+3A_x">x</code></td>
<td>
<p>The list of lists.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of atomic vectors.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>### First create a list of lists
listOfLists &lt;-
  list(list(list(1:3, 8:5), 7:7), list(1:4, 8:2));
yum::flatten_list_of_lists(listOfLists);
</code></pre>

<hr>
<h2 id='is.odd'>Checking whether numbers are odd or even</h2><span id='topic+is.odd'></span><span id='topic+is.even'></span>

<h3>Description</h3>

<p>Checking whether numbers are odd or even
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is.odd(vector)

is.even(vector)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="is.odd_+3A_vector">vector</code></td>
<td>
<p>The vector to process</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A logical vector.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>is.odd(4);
</code></pre>

<hr>
<h2 id='load_and_simplify'>Load YAML fragments in one or multiple files and simplify them</h2><span id='topic+load_and_simplify'></span><span id='topic+load_and_simplify_dir'></span>

<h3>Description</h3>

<p>These function extracts all YAML fragments from a file or text (<code>load_and_simplify</code>)
or from all files in a directory (<code>load_and_simplify_dir</code>) and loads them
by calling <code><a href="#topic+load_yaml_fragments">load_yaml_fragments()</a></code>, and then calls <code><a href="#topic+simplify_by_flattening">simplify_by_flattening()</a></code>,
on the result, returning the resulting list.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>load_and_simplify(
  text,
  file,
  yamlFragments = NULL,
  select = ".*",
  simplify = ".*",
  delimiterRegEx = "^---$",
  ignoreOddDelimiters = FALSE,
  encoding = "UTF-8",
  silent = TRUE
)

load_and_simplify_dir(
  path,
  recursive = TRUE,
  fileRegexes = c("^[^\\.]+.*$"),
  select = ".*",
  simplify = ".*",
  delimiterRegEx = "^---$",
  ignoreOddDelimiters = FALSE,
  encoding = "UTF-8",
  silent = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="load_and_simplify_+3A_text">text</code></td>
<td>
<p>As <code>text</code> or <code>file</code>, you can specify a <code>file</code> to read with
encoding <code>encoding</code>, which will then be read using <code><a href="base.html#topic+readLines">base::readLines()</a></code>. If the
argument is named <code>text</code>, whether it is the path to an existing file is checked
first, and if it is, that file is read. If the argument is named <code>file</code>, and it
does not point to an existing file, an error is produced (useful if calling
from other functions). A <code>text</code> should be a character vector where every
element is a line of the original source (like provided by <code><a href="base.html#topic+readLines">base::readLines()</a></code>);
although if a character vector of one element <em>and</em> including at least one
newline character (<code style="white-space: pre;">&#8288;\\n&#8288;</code>) is provided as <code>text</code>, it is split at the newline
characters using <code><a href="base.html#topic+strsplit">base::strsplit()</a></code>. Basically, this behavior means that the
first argument can be either a character vector or the path to a file; and if
you're specifying a file and you want to be certain that an error is thrown if
it doesn't exist, make sure to name it <code>file</code>.</p>
</td></tr>
<tr><td><code id="load_and_simplify_+3A_file">file</code></td>
<td>
<p>As <code>text</code> or <code>file</code>, you can specify a <code>file</code> to read with
encoding <code>encoding</code>, which will then be read using <code><a href="base.html#topic+readLines">base::readLines()</a></code>. If the
argument is named <code>text</code>, whether it is the path to an existing file is checked
first, and if it is, that file is read. If the argument is named <code>file</code>, and it
does not point to an existing file, an error is produced (useful if calling
from other functions). A <code>text</code> should be a character vector where every
element is a line of the original source (like provided by <code><a href="base.html#topic+readLines">base::readLines()</a></code>);
although if a character vector of one element <em>and</em> including at least one
newline character (<code style="white-space: pre;">&#8288;\\n&#8288;</code>) is provided as <code>text</code>, it is split at the newline
characters using <code><a href="base.html#topic+strsplit">base::strsplit()</a></code>. Basically, this behavior means that the
first argument can be either a character vector or the path to a file; and if
you're specifying a file and you want to be certain that an error is thrown if
it doesn't exist, make sure to name it <code>file</code>.</p>
</td></tr>
<tr><td><code id="load_and_simplify_+3A_yamlfragments">yamlFragments</code></td>
<td>
<p>A character vector of class <code>yamlFragment</code> where
every element corresponds to one line of the YAML fragments, or a list
of multiple such character vectors (of class <code>yamlFragments</code>). Specify
either <code>yamlFragments</code> (which, if specified, takes precedence over <code>file</code>
and <code>text</code>), <code>file</code>, or <code>text</code> (<code>file</code> takes precedence over <code>text</code>).</p>
</td></tr>
<tr><td><code id="load_and_simplify_+3A_select">select</code></td>
<td>
<p>A vector of regular expressions specifying object names
to retain. The default (<code style="white-space: pre;">&#8288;.*&#8288;</code>) matches everything, so by default, all
objects are retained.</p>
</td></tr>
<tr><td><code id="load_and_simplify_+3A_simplify">simplify</code></td>
<td>
<p>A regular expression specifying which elements to
simplify (default is everything)</p>
</td></tr>
<tr><td><code id="load_and_simplify_+3A_delimiterregex">delimiterRegEx</code></td>
<td>
<p>The regular expression used to locate YAML
fragments.</p>
</td></tr>
<tr><td><code id="load_and_simplify_+3A_ignoreodddelimiters">ignoreOddDelimiters</code></td>
<td>
<p>Whether to throw an error (FALSE) or
delete the last delimiter (TRUE) if an odd number of delimiters is
encountered.</p>
</td></tr>
<tr><td><code id="load_and_simplify_+3A_encoding">encoding</code></td>
<td>
<p>The encoding to use when calling <code><a href="base.html#topic+readLines">readLines()</a></code>. Set to
NULL to let <code><a href="base.html#topic+readLines">readLines()</a></code> guess.</p>
</td></tr>
<tr><td><code id="load_and_simplify_+3A_silent">silent</code></td>
<td>
<p>Whether to be silent (<code>TRUE</code>) or informative (<code>FALSE</code>).</p>
</td></tr>
<tr><td><code id="load_and_simplify_+3A_path">path</code></td>
<td>
<p>The path containing the files.</p>
</td></tr>
<tr><td><code id="load_and_simplify_+3A_recursive">recursive</code></td>
<td>
<p>Whether to also process subdirectories (<code>TRUE</code>)
or not (<code>FALSE</code>).</p>
</td></tr>
<tr><td><code id="load_and_simplify_+3A_fileregexes">fileRegexes</code></td>
<td>
<p>A vector of regular expressions to match the files
against: only files matching one or more regular expressions in this
vector are processed. The default regex (<code style="white-space: pre;">&#8288;^[^\.]+.*$&#8288;</code>) matches all
files except those that start with a period (<code>.</code>).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of objects, where each object corresponds to one
item specified in the read YAML fragment(s) from the source file
or text. If the convention of the <code>rock</code>, <code>dct</code> and <code>justifier</code>
packages is followed, each object in this list contains one or
more named objects (lists), where the name indicates the type
of information contained. Each of those objects (lists) then
contains one or more objects of that type, such as metadata or
codes for <code>rock</code>, a decentralized construct taxonomy element
for <code>dct</code>, and a justification, decision, assertion, or source
for <code>justifier</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>yum::load_and_simplify(text="
---
firstObject:
  id: firstFragment
---
Outside of YAML
---
otherObjectType:
  -
    id: secondFragment
    parentId: firstFragment
  -
    id: thirdFragment
    parentId: firstFragment
---
Also outside of YAML");

</code></pre>

<hr>
<h2 id='load_yaml_dir'>Load all YAML fragments from all files in a directory</h2><span id='topic+load_yaml_dir'></span>

<h3>Description</h3>

<p>These function extracts all YAML fragments from all files in a
directory returning a list of character vectors containing the
extracted fragments.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>load_yaml_dir(
  path,
  recursive = TRUE,
  fileRegexes = c("^[^\\.]+.*$"),
  select = ".*",
  delimiterRegEx = "^---$",
  ignoreOddDelimiters = FALSE,
  encoding = "UTF-8",
  silent = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="load_yaml_dir_+3A_path">path</code></td>
<td>
<p>The path containing the files.</p>
</td></tr>
<tr><td><code id="load_yaml_dir_+3A_recursive">recursive</code></td>
<td>
<p>Whether to also process subdirectories (<code>TRUE</code>)
or not (<code>FALSE</code>).</p>
</td></tr>
<tr><td><code id="load_yaml_dir_+3A_fileregexes">fileRegexes</code></td>
<td>
<p>A vector of regular expressions to match the files
against: only files matching one or more regular expressions in this
vector are processed. The default regex (<code style="white-space: pre;">&#8288;^[^\.]+.*$&#8288;</code>) matches all
files except those that start with a period (<code>.</code>).</p>
</td></tr>
<tr><td><code id="load_yaml_dir_+3A_select">select</code></td>
<td>
<p>A vector of regular expressions specifying object names
to retain. The default (<code style="white-space: pre;">&#8288;.*&#8288;</code>) matches everything, so by default, all
objects are retained.</p>
</td></tr>
<tr><td><code id="load_yaml_dir_+3A_delimiterregex">delimiterRegEx</code></td>
<td>
<p>The regular expression used to locate YAML
fragments.</p>
</td></tr>
<tr><td><code id="load_yaml_dir_+3A_ignoreodddelimiters">ignoreOddDelimiters</code></td>
<td>
<p>Whether to throw an error (FALSE) or
delete the last delimiter (TRUE) if an odd number of delimiters is
encountered.</p>
</td></tr>
<tr><td><code id="load_yaml_dir_+3A_encoding">encoding</code></td>
<td>
<p>The encoding to use when calling <code><a href="base.html#topic+readLines">readLines()</a></code>. Set to
NULL to let <code><a href="base.html#topic+readLines">readLines()</a></code> guess.</p>
</td></tr>
<tr><td><code id="load_yaml_dir_+3A_silent">silent</code></td>
<td>
<p>Whether to be silent (<code>TRUE</code>) or informative (<code>FALSE</code>).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>These function extracts all YAML fragments from all files in a
directory and then calls <code><a href="yaml.html#topic+yaml.load">yaml::yaml.load()</a></code> to parse them. It
then returns a list where each element is a list with the parsed
fragments in a file.
</p>


<h3>Value</h3>

<p>A list of lists of objects.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>### First get the directory where 'yum' is installed
yumDir &lt;- system.file(package="yum");
### Specify the path of some example files
examplePath &lt;- file.path(yumDir, "extdata");
### Show files (should be three .dct files)
list.files(examplePath);
### Load these files
yum::load_yaml_dir(path=examplePath);
</code></pre>

<hr>
<h2 id='load_yaml_fragments'>Load all YAML fragments from a file</h2><span id='topic+load_yaml_fragments'></span>

<h3>Description</h3>

<p>These function extracts all YAML fragments from a file and then
calls <code><a href="yaml.html#topic+yaml.load">yaml::yaml.load()</a></code> to parse them. It then returns a list
of the parsed fragments.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>load_yaml_fragments(
  text,
  file,
  yamlFragments = NULL,
  select = ".*",
  delimiterRegEx = "^---$",
  ignoreOddDelimiters = FALSE,
  encoding = "UTF-8",
  silent = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="load_yaml_fragments_+3A_text">text</code></td>
<td>
<p>As <code>text</code> or <code>file</code>, you can specify a <code>file</code> to read with
encoding <code>encoding</code>, which will then be read using <code><a href="base.html#topic+readLines">base::readLines()</a></code>. If the
argument is named <code>text</code>, whether it is the path to an existing file is checked
first, and if it is, that file is read. If the argument is named <code>file</code>, and it
does not point to an existing file, an error is produced (useful if calling
from other functions). A <code>text</code> should be a character vector where every
element is a line of the original source (like provided by <code><a href="base.html#topic+readLines">base::readLines()</a></code>);
although if a character vector of one element <em>and</em> including at least one
newline character (<code style="white-space: pre;">&#8288;\\n&#8288;</code>) is provided as <code>text</code>, it is split at the newline
characters using <code><a href="base.html#topic+strsplit">base::strsplit()</a></code>. Basically, this behavior means that the
first argument can be either a character vector or the path to a file; and if
you're specifying a file and you want to be certain that an error is thrown if
it doesn't exist, make sure to name it <code>file</code>.</p>
</td></tr>
<tr><td><code id="load_yaml_fragments_+3A_file">file</code></td>
<td>
<p>As <code>text</code> or <code>file</code>, you can specify a <code>file</code> to read with
encoding <code>encoding</code>, which will then be read using <code><a href="base.html#topic+readLines">base::readLines()</a></code>. If the
argument is named <code>text</code>, whether it is the path to an existing file is checked
first, and if it is, that file is read. If the argument is named <code>file</code>, and it
does not point to an existing file, an error is produced (useful if calling
from other functions). A <code>text</code> should be a character vector where every
element is a line of the original source (like provided by <code><a href="base.html#topic+readLines">base::readLines()</a></code>);
although if a character vector of one element <em>and</em> including at least one
newline character (<code style="white-space: pre;">&#8288;\\n&#8288;</code>) is provided as <code>text</code>, it is split at the newline
characters using <code><a href="base.html#topic+strsplit">base::strsplit()</a></code>. Basically, this behavior means that the
first argument can be either a character vector or the path to a file; and if
you're specifying a file and you want to be certain that an error is thrown if
it doesn't exist, make sure to name it <code>file</code>.</p>
</td></tr>
<tr><td><code id="load_yaml_fragments_+3A_yamlfragments">yamlFragments</code></td>
<td>
<p>A character vector of class <code>yamlFragment</code> where
every element corresponds to one line of the YAML fragments, or a list
of multiple such character vectors (of class <code>yamlFragments</code>). Specify
either <code>yamlFragments</code> (which, if specified, takes precedence over <code>file</code>
and <code>text</code>), <code>file</code>, or <code>text</code> (<code>file</code> takes precedence over <code>text</code>).</p>
</td></tr>
<tr><td><code id="load_yaml_fragments_+3A_select">select</code></td>
<td>
<p>A vector of regular expressions specifying object names
to retain. The default (<code style="white-space: pre;">&#8288;.*&#8288;</code>) matches everything, so by default, all
objects are retained.</p>
</td></tr>
<tr><td><code id="load_yaml_fragments_+3A_delimiterregex">delimiterRegEx</code></td>
<td>
<p>The regular expression used to locate YAML
fragments.</p>
</td></tr>
<tr><td><code id="load_yaml_fragments_+3A_ignoreodddelimiters">ignoreOddDelimiters</code></td>
<td>
<p>Whether to throw an error (FALSE) or
delete the last delimiter (TRUE) if an odd number of delimiters is
encountered.</p>
</td></tr>
<tr><td><code id="load_yaml_fragments_+3A_encoding">encoding</code></td>
<td>
<p>The encoding to use when calling <code><a href="base.html#topic+readLines">readLines()</a></code>. Set to
NULL to let <code><a href="base.html#topic+readLines">readLines()</a></code> guess.</p>
</td></tr>
<tr><td><code id="load_yaml_fragments_+3A_silent">silent</code></td>
<td>
<p>Whether to be silent (<code>TRUE</code>) or informative (<code>FALSE</code>).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of objects, where each object corresponds to one
YAML fragment from the source file or text. If the convention of
the <code>rock</code>, <code>dct</code> and <code>justifier</code> packages is followed, each object
in this list contains one or more named objects (lists), where the
name indicated the type of information contained. Each of those
objects (lists) then contains one or more objects of that type,
such as metadata or codes for <code>rock</code>, a decentralized construct
taxonomy element for <code>dct</code>, and a justification for <code>justifier</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>yum::load_yaml_fragments(text="
---
-
  id: firstFragment
---
Outside of YAML
---
-
  id: secondFragment
  parentId: firstFragment
---
Also outside of YAML");

</code></pre>

<hr>
<h2 id='load_yaml_list'>Load all YAML fragments from all character vectors in a list</h2><span id='topic+load_yaml_list'></span>

<h3>Description</h3>

<p>These function extracts all YAML fragments from character vectors
in a list, returning a list of character vectors containing the
extracted fragments.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>load_yaml_list(
  x,
  recursive = TRUE,
  select = ".*",
  delimiterRegEx = "^---$",
  ignoreOddDelimiters = FALSE,
  encoding = "UTF-8",
  silent = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="load_yaml_list_+3A_x">x</code></td>
<td>
<p>The list containing the character vectors.</p>
</td></tr>
<tr><td><code id="load_yaml_list_+3A_recursive">recursive</code></td>
<td>
<p>Whether to first <code>unlist</code> the list (<code>TRUE</code>)
or not (<code>FALSE</code>).</p>
</td></tr>
<tr><td><code id="load_yaml_list_+3A_select">select</code></td>
<td>
<p>A vector of regular expressions specifying object names
to retain. The default (<code style="white-space: pre;">&#8288;.*&#8288;</code>) matches everything, so by default, all
objects are retained.</p>
</td></tr>
<tr><td><code id="load_yaml_list_+3A_delimiterregex">delimiterRegEx</code></td>
<td>
<p>The regular expression used to locate YAML
fragments.</p>
</td></tr>
<tr><td><code id="load_yaml_list_+3A_ignoreodddelimiters">ignoreOddDelimiters</code></td>
<td>
<p>Whether to throw an error (FALSE) or
delete the last delimiter (TRUE) if an odd number of delimiters is
encountered.</p>
</td></tr>
<tr><td><code id="load_yaml_list_+3A_encoding">encoding</code></td>
<td>
<p>The encoding to use when calling <code><a href="base.html#topic+readLines">readLines()</a></code>. Set to
NULL to let <code><a href="base.html#topic+readLines">readLines()</a></code> guess.</p>
</td></tr>
<tr><td><code id="load_yaml_list_+3A_silent">silent</code></td>
<td>
<p>Whether to be silent (<code>TRUE</code>) or informative (<code>FALSE</code>).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function calls <code><a href="yaml.html#topic+yaml.load">yaml::yaml.load()</a></code> on all character vectors
in a list. It then returns a list where each element is a list
with the parsed fragments in a file.
</p>


<h3>Value</h3>

<p>A list of lists of objects.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>yamlList &lt;- list(c(
"---",
"-",
"  id: firstFragment",
"---"), c(
"---",
"-",
"  id: secondFragment",
"  parentId: firstFragment",
"---"));
yum::load_yaml_list(yamlList);
</code></pre>

<hr>
<h2 id='simplify_by_flattening'>Simplify the structure of extracted YAML fragments</h2><span id='topic+simplify_by_flattening'></span>

<h3>Description</h3>

<p>This function does some cleaning and simplifying to allow
efficient specification of elements in the YAML fragments.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>simplify_by_flattening(x, simplify = ".*", .level = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="simplify_by_flattening_+3A_x">x</code></td>
<td>
<p>Extracted (and loaded) YAML fragments</p>
</td></tr>
<tr><td><code id="simplify_by_flattening_+3A_simplify">simplify</code></td>
<td>
<p>A regular expression specifying which elements to
simplify (default is everything)</p>
</td></tr>
<tr><td><code id="simplify_by_flattening_+3A_.level">.level</code></td>
<td>
<p>Internal argument to enable slightly-less-than-elegant 'recursion'.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A simplified list (but still a list)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>yamlFragmentExample &lt;- '
---
source:
  -
    id: src_1
    label: "Label 1"
  -
    id: src_2
    label: "Label 2"
assertion:
  -
    id: assertion_1
    label: "Assertion 1"
  -
    id: assertion_2
    label: "Assertion 2"
---
';
loadedExampleFragments &lt;-
  load_yaml_fragments(yamlFragmentExample);
simplified &lt;-
  simplify_by_flattening(loadedExampleFragments);

### Pre simmplification:
str(loadedExampleFragments);

### Post simmplification:
str(simplified);

</code></pre>

<hr>
<h2 id='vecTxt'>Easily parse a vector into a character value</h2><span id='topic+vecTxt'></span><span id='topic+vecTxtQ'></span>

<h3>Description</h3>

<p>Easily parse a vector into a character value
</p>


<h3>Usage</h3>

<pre><code class='language-R'>vecTxt(
  vector,
  delimiter = ", ",
  useQuote = "",
  firstDelimiter = NULL,
  lastDelimiter = " &amp; ",
  firstElements = 0,
  lastElements = 1,
  lastHasPrecedence = TRUE
)

vecTxtQ(vector, useQuote = "'", ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="vecTxt_+3A_vector">vector</code></td>
<td>
<p>The vector to process.</p>
</td></tr>
<tr><td><code id="vecTxt_+3A_delimiter">delimiter</code>, <code id="vecTxt_+3A_firstdelimiter">firstDelimiter</code>, <code id="vecTxt_+3A_lastdelimiter">lastDelimiter</code></td>
<td>
<p>The delimiters
to use for respectively the middle, first
<code>firstElements</code>, and last <code>lastElements</code> elements.</p>
</td></tr>
<tr><td><code id="vecTxt_+3A_usequote">useQuote</code></td>
<td>
<p>This character string is pre- and appended to all elements;
so use this to quote all elements (<code>useQuote="'"</code>), doublequote all
elements (<code>useQuote='"'</code>), or anything else (e.g. <code>useQuote='|'</code>).
The only difference between <code>vecTxt</code> and <code>vecTxtQ</code> is that the
latter by default quotes the elements.</p>
</td></tr>
<tr><td><code id="vecTxt_+3A_firstelements">firstElements</code>, <code id="vecTxt_+3A_lastelements">lastElements</code></td>
<td>
<p>The number of elements for which to use
the first respective last delimiters</p>
</td></tr>
<tr><td><code id="vecTxt_+3A_lasthasprecedence">lastHasPrecedence</code></td>
<td>
<p>If the vector is very short, it's possible that the
sum of firstElements and lastElements is larger than the vector length. In
that case, downwardly adjust the number of elements to separate with the
first delimiter (<code>TRUE</code>) or the number of elements to separate with the
last delimiter (<code>FALSE</code>)?</p>
</td></tr>
<tr><td><code id="vecTxt_+3A_...">...</code></td>
<td>
<p>Any addition arguments to <code>vecTxtQ</code> are passed on to
<code>vecTxt</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A character vector of length 1.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>vecTxtQ(names(mtcars));
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
