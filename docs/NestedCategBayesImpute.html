<!DOCTYPE html><html lang="en"><head><title>Help for package NestedCategBayesImpute</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {NestedCategBayesImpute}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#checkconstraints'>
<p>Checking a data matrix of households for the possible/impossible status under a predefined set of structural zeros.</p></a></li>
<li><a href='#checkconstraints_HHhead_at_group_level'>
<p>Checking a data matrix of households for the possible/impossible status under a predefined set of structural zeros.</p></a></li>
<li><a href='#checkSZ'>
<p>The new implementation of checkconstraints and will evently replace checkconstraints.</p></a></li>
<li><a href='#checkSZ2'>
<p>Michael: Edit here</p></a></li>
<li><a href='#GetImpossibleHouseholds'>
<p>Generate the desired number of impossible households required to observe a given number of possible households.</p></a></li>
<li><a href='#groupcount'>
<p>Generate 2D count table for two integer-valued vectors.</p></a></li>
<li><a href='#groupcount1D'>
<p>Generate histogram count for an integer-valued vector.</p></a></li>
<li><a href='#households2individuals'>
<p>Convert a household data matrix to the corresponding individual member data matrix.</p></a></li>
<li><a href='#initData'>
<p>Initialize the input data structure.</p></a></li>
<li><a href='#initMissing'>
<p>Initilize the misising data structure from input data</p></a></li>
<li><a href='#initOutput'>
<p>Set the output structure for saving posterior samples of parameters.</p></a></li>
<li><a href='#initParameters'>
<p>Initialize the model parameters for the MCMC.</p></a></li>
<li><a href='#RunModel'>
<p>Run the mcmc sampler for the model.</p></a></li>
<li><a href='#sampleG'>
<p>Update household (group) level latent class indexes.</p></a></li>
<li><a href='#samplehouseholds'>
<p>Rcpp implementation for sampling household data without constraints.</p></a></li>
<li><a href='#sampleM'>
<p>Update individual level latent class  indexes.</p></a></li>
<li><a href='#SampleMissing'>
<p>Sample and update missing data</p></a></li>
<li><a href='#UpdateAlpha'>
<p>Update alpha.</p></a></li>
<li><a href='#UpdateBeta'>
<p>Update beta.</p></a></li>
<li><a href='#UpdateLambda'>
<p>Update lambda.</p></a></li>
<li><a href='#UpdateLambdaWeighted'>
<p>Update lambda.</p></a></li>
<li><a href='#UpdateOmega'>
<p>Update omega and v.</p></a></li>
<li><a href='#UpdateOmegaWeighted'>
<p>Update omega and v.</p></a></li>
<li><a href='#UpdatePhi'>
<p>Update phi.</p></a></li>
<li><a href='#UpdatePhiWeighted'>
<p>Update phi.</p></a></li>
<li><a href='#UpdatePi'>
<p>Update pi and u.</p></a></li>
<li><a href='#UpdatePiWeighted'>
<p>Update pi and u.</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Modeling, Imputing and Generating Synthetic Versions of Nested
Categorical Data in the Presence of Impossible Combinations</td>
</tr>
<tr>
<td>Version:</td>
<td>1.2.1</td>
</tr>
<tr>
<td>Date:</td>
<td>2019-02-07</td>
</tr>
<tr>
<td>Author:</td>
<td>Quanli Wang, Olanrewaju Akande, Jingchen Hu, Jerry Reiter and Andres Barrientos</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Olanrewaju Akande &lt;akandelanre13@gmail.com&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>This tool set provides a set of functions to fit the nested Dirichlet process mixture of products of multinomial distributions (NDPMPM) model for nested categorical household data in the presence of impossible combinations. It has direct applications in imputing missing values for and generating synthetic versions of nested household data.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL (&ge; 3)</a></td>
</tr>
<tr>
<td>LazyData:</td>
<td>TRUE</td>
</tr>
<tr>
<td>Imports:</td>
<td>stats, coda, dplyr, Rcpp (&ge; 0.12.0), RcppParallel</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>Rcpp, RcppParallel</td>
</tr>
<tr>
<td>SystemRequirements:</td>
<td>GNU make</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2019-02-07 18:13:45 UTC; klbh847</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2019-02-07 21:43:40 UTC</td>
</tr>
</table>
<hr>
<h2 id='checkconstraints'>
Checking a data matrix of households for the possible/impossible status under a predefined set of structural zeros.
</h2><span id='topic+checkconstraints'></span>

<h3>Description</h3>

<p>Checking a data matrix of households for the possible/impossible status under a predefined set of structural zeros.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>checkconstraints(data, neededpossiblehh, hh_size)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="checkconstraints_+3A_data">data</code></td>
<td>

<p>A household data matrix generated by calling <code style="white-space: pre;">&#8288;samplinghouseholds&#8288;</code>.
</p>
</td></tr>
<tr><td><code id="checkconstraints_+3A_neededpossiblehh">neededpossiblehh</code></td>
<td>

<p>The number of possible households needed before checking is stopped.
</p>
</td></tr>
<tr><td><code id="checkconstraints_+3A_hh_size">hh_size</code></td>
<td>

<p>The household size for the households in <code style="white-space: pre;">&#8288;data&#8288;</code>.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Given an input household data matrix, these functions will check the possible/impossible status of each household and also output the desired number of possible and impossible households separately. <code style="white-space: pre;">&#8288;checkconstraints&#8288;</code> checks constraints when the household head is included as an individual within the household.
</p>
<p>The predefined list of structural zeros currently included should be viewed as an example of a system of constraints. It was derived by treating a subset of the 2012 American Community Survey as a population, and identifying combinations involving the relationship variable that do not appear in the data.  This list should not be interpreted as a &ldquo;true&rdquo; list of impossible combinations in the target population. We force the combinations of variables in this list to have zero probability to be consistent with the 2012 ACS public use file that we used in the example.
</p>
<p>The structural zeros included are:
</p>

<ul>
<li><p> Each household must contain exactly one head and he/she must be at least 16 years old.
</p>
</li>
<li><p> Each household cannot contain more than one spouse and he/she must be at least 16 years old.
</p>
</li>
<li><p> Married couples are of opposite sex, and age difference between individuals in the couples cannot exceed 49.
</p>
</li>
<li><p> The household head must be older than the oldest child by at least 7.
</p>
</li>
<li><p> The youngest parent must be older than the household head by at least 10.
</p>
</li>
<li><p> The youngest parent-in-law must be older than the household head by at least 4.
</p>
</li>
<li><p> The age difference between the household head and siblings cannot exceed 37.
</p>
</li>
<li><p> The household head must be at least 34 years old. Also, the household head must be older than the oldest grandchild by at least 26.
</p>
</li></ul>

<p>Users can modify the list of structural zeros by downloading the package source, making changes only to the checkconstraints_imp.cpp file and re-building the package. Please note that the structural zeros have been specified according to the structure of our example data so that the specific column indexes and levels of age, gender and relationship to household head variables in subsequent data sets must match those in our example data. For more information on the structure of the data, see the documentation of the <code style="white-space: pre;">&#8288;RunModel&#8288;</code> function.
</p>


<h3>Value</h3>

<p>A list containing information on checking result.
</p>
<table role = "presentation">
<tr><td><code>outcome</code></td>
<td>
<p>An indicator vector for the possible/impossible household status under constraints.</p>
</td></tr>
<tr><td><code>Households</code></td>
<td>
<p>A data matrix for impossible households.</p>
</td></tr>
<tr><td><code>Index</code></td>
<td>
<p>A vector for the original indexes of households when possible households are found. Generally not to be used.</p>
</td></tr>
<tr><td><code>synHouseholds</code></td>
<td>
<p>A data matrix for possible households.</p>
</td></tr>
<tr><td><code>possible</code></td>
<td>
<p>The actual number of possible households returned.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Quanli Wang, Olanrewaju Akande
</p>

<hr>
<h2 id='checkconstraints_HHhead_at_group_level'>
Checking a data matrix of households for the possible/impossible status under a predefined set of structural zeros.
</h2><span id='topic+checkconstraints_HHhead_at_group_level'></span>

<h3>Description</h3>

<p>Checking a data matrix of households for the possible/impossible status under a predefined set of structural zeros.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>checkconstraints_HHhead_at_group_level(data, neededpossiblehh, hh_size, parallel)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="checkconstraints_HHhead_at_group_level_+3A_data">data</code></td>
<td>

<p>A household data matrix generated by calling <code style="white-space: pre;">&#8288;samplinghouseholds&#8288;</code>.
</p>
</td></tr>
<tr><td><code id="checkconstraints_HHhead_at_group_level_+3A_neededpossiblehh">neededpossiblehh</code></td>
<td>

<p>The number of possible households needed before checking is stopped.
</p>
</td></tr>
<tr><td><code id="checkconstraints_HHhead_at_group_level_+3A_hh_size">hh_size</code></td>
<td>

<p>The household size for the households in <code style="white-space: pre;">&#8288;data&#8288;</code>.
</p>
</td></tr>
<tr><td><code id="checkconstraints_HHhead_at_group_level_+3A_parallel">parallel</code></td>
<td>

<p>Logical indicator for running the function in parallel mode.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Given an input household data matrix, these functions will check the possible/impossible status of each household and also output the desired number of possible and impossible households separately. <code style="white-space: pre;">&#8288;checkconstraints_HHhead_at_group_level&#8288;</code> checks contraints when the household head is moved to the household level. For the list of structural zeros currently included, see the documentation for <code style="white-space: pre;">&#8288;checkconstraints&#8288;</code>.
</p>


<h3>Value</h3>

<p>A list containing information on checking result.
</p>
<table role = "presentation">
<tr><td><code>outcome</code></td>
<td>
<p>An indicator vector for the possible/impossible household status under constraints.</p>
</td></tr>
<tr><td><code>Households</code></td>
<td>
<p>A data matrix for impossible households.</p>
</td></tr>
<tr><td><code>Index</code></td>
<td>
<p>A vector for the original indexes of households when possible households are found. Generally not to be used.</p>
</td></tr>
<tr><td><code>synHouseholds</code></td>
<td>
<p>A data matrix for possible households.</p>
</td></tr>
<tr><td><code>possible</code></td>
<td>
<p>The actual number of possible households returned.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Quanli Wang, Olanrewaju Akande
</p>

<hr>
<h2 id='checkSZ'>
The new implementation of checkconstraints and will evently replace checkconstraints.
</h2><span id='topic+checkSZ'></span>

<h3>Description</h3>

<p>Checking a data matrix of households for the possible/impossible status under a predefined set of structural zeros.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>checkSZ(Data_to_check, h)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="checkSZ_+3A_data_to_check">Data_to_check</code></td>
<td>
<p>The household data matrix that is to be checked for structure zero constriants.</p>
</td></tr>
<tr><td><code id="checkSZ_+3A_h">h</code></td>
<td>
<p>The household size for the households to be checked.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Given an input household data matrix, these functions will check the possible/impossible status of each household and also output the desired number of possible and impossible households separately. <code style="white-space: pre;">&#8288;checkconstraints&#8288;</code> checks constraints when the household head is included as an individual within the household.
</p>
<p>The predefined list of structural zeros currently included should be viewed as an example of a system of constraints. It was derived by treating a subset of the 2012 American Community Survey as a population, and identifying combinations involving the relationship variable that do not appear in the data.  This list should not be interpreted as a &ldquo;true&rdquo; list of impossible combinations in the target population. We force the combinations of variables in this list to have zero probability to be consistent with the 2012 ACS public use file that we used in the example.
</p>
<p>The structural zeros included are:
</p>

<ul>
<li><p> Each household must contain exactly one head and he/she must be at least 16 years old.
</p>
</li>
<li><p> Each household cannot contain more than one spouse and he/she must be at least 16 years old.
</p>
</li>
<li><p> Married couples are of opposite sex, and age difference between individuals in the couples cannot exceed 49.
</p>
</li>
<li><p> The household head must be older than the oldest child by at least 7.
</p>
</li>
<li><p> The youngest parent must be older than the household head by at least 10.
</p>
</li>
<li><p> The youngest parent-in-law must be older than the household head by at least 4.
</p>
</li>
<li><p> The age difference between the household head and siblings cannot exceed 37.
</p>
</li>
<li><p> The household head must be at least 34 years old. Also, the household head must be older than the oldest grandchild by at least 26.
</p>
</li></ul>

<p>Users can modify the list of structural zeros by downloading the package source, making changes only to the checkconstraints_imp.cpp file and re-building the package. Please note that the structural zeros have been specified according to the structure of our example data so that the specific column indexes and levels of age, gender and relationship to household head variables in subsequent data sets must match those in our example data. For more information on the structure of the data, see the documentation of the <code style="white-space: pre;">&#8288;RunModel&#8288;</code> function.
</p>


<h3>Value</h3>

<p>A list containing information on checking result.
</p>
<table role = "presentation">
<tr><td><code>outcome</code></td>
<td>
<p>An indicator vector for the possible/impossible household status under constraints.</p>
</td></tr>
<tr><td><code>Households</code></td>
<td>
<p>A data matrix for impossible households.</p>
</td></tr>
<tr><td><code>Index</code></td>
<td>
<p>A vector for the original indexes of households when possible households are found. Generally not to be used.</p>
</td></tr>
<tr><td><code>synHouseholds</code></td>
<td>
<p>A data matrix for possible households.</p>
</td></tr>
<tr><td><code>possible</code></td>
<td>
<p>The actual number of possible households returned.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Quanli Wang, Olanrewaju Akande
</p>

<hr>
<h2 id='checkSZ2'>
Michael: Edit here
</h2><span id='topic+checkSZ2'></span>

<h3>Description</h3>

<p>Michael: Edit here
</p>


<h3>Usage</h3>

<pre><code class='language-R'>checkSZ2(Data_to_check, h)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="checkSZ2_+3A_data_to_check">Data_to_check</code></td>
<td>

<p>Michael: Edit here
</p>
</td></tr>
<tr><td><code id="checkSZ2_+3A_h">h</code></td>
<td>

<p>Michael: Edit here
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Michael: Edit here
</p>


<h3>Value</h3>

<p>Michael: Edit here
</p>

<hr>
<h2 id='GetImpossibleHouseholds'>
Generate the desired number of impossible households required to observe a given number of possible households.
</h2><span id='topic+GetImpossibleHouseholds'></span>

<h3>Description</h3>

<p>Given model parameters, generate the desired number of impossible households required to observe a given number of possible households. Also generate synthetic (and valid) data of the same size as the observed data when required.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>GetImpossibleHouseholds(d, n_star_h, lambda, omega, phi, pi, blocksize, n, synindex,
                        HHhead_at_group_level,Parallel)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="GetImpossibleHouseholds_+3A_d">d</code></td>
<td>

<p>Vector containing the number of levels for each individual-level variable.
</p>
</td></tr>
<tr><td><code id="GetImpossibleHouseholds_+3A_n_star_h">n_star_h</code></td>
<td>

<p>Vector containing the number of observed households for the different household sizes in the original data.
</p>
</td></tr>
<tr><td><code id="GetImpossibleHouseholds_+3A_lambda">lambda</code></td>
<td>
<p>Multinomial probabilities for each group-level variable.
</p>
</td></tr>
<tr><td><code id="GetImpossibleHouseholds_+3A_omega">omega</code></td>
<td>
<p>Latent class probabilities for the group-level and individual-level latent class pairs.
</p>
</td></tr>
<tr><td><code id="GetImpossibleHouseholds_+3A_phi">phi</code></td>
<td>
<p>Multinomial probabilities for each individual-level variable by each pair of group-level and individual-level latent classes.
</p>
</td></tr>
<tr><td><code id="GetImpossibleHouseholds_+3A_pi">pi</code></td>
<td>
<p>Latent class probabilities for the group-level latent classes.
</p>
</td></tr>
<tr><td><code id="GetImpossibleHouseholds_+3A_blocksize">blocksize</code></td>
<td>

<p>Number of households to be generated at a time; batch sampling is used to improve computing speed.
</p>
</td></tr>
<tr><td><code id="GetImpossibleHouseholds_+3A_n">n</code></td>
<td>

<p>Number of households in the original input data and the sum of <code style="white-space: pre;">&#8288;n_star_h&#8288;</code>.
</p>
</td></tr>
<tr><td><code id="GetImpossibleHouseholds_+3A_synindex">synindex</code></td>
<td>
<p>Logical indicator for sampling synthetic data. Set to TRUE when synthetic data is needed.
</p>
</td></tr>
<tr><td><code id="GetImpossibleHouseholds_+3A_hhhead_at_group_level">HHhead_at_group_level</code></td>
<td>

<p>Logical indicator for data structure with respect to the household head. Set to TRUE if the household head has been moved to the household level and FALSE otherwise.
</p>
</td></tr>
<tr><td><code id="GetImpossibleHouseholds_+3A_parallel">Parallel</code></td>
<td>

<p>Logical indicator for running the function in parallel mode.
</p>
</td></tr>
</table>


<h3>Value</h3>

<table role = "presentation">
<tr><td><code>G_Individuals_and_M_extra</code></td>
<td>
<p>A data matrix containing both the group-level (in long format) and individual-level latent classes for the impossible households.</p>
</td></tr>
<tr><td><code>G_extra</code></td>
<td>
<p>A vector containing the group-level latent classes for the impossible households.</p>
</td></tr>
<tr><td><code>IndividualData_extra</code></td>
<td>
<p>A data matrix containing the individual-level data for the impossible households.</p>
</td></tr>
<tr><td><code>HHdata_extra</code></td>
<td>
<p>A data matrix containing the group-level data for the impossible households.</p>
</td></tr>
<tr><td><code>hh_size_new</code></td>
<td>
<p>A vector for the number of impossible households for the different household sizes.</p>
</td></tr>
<tr><td><code>synIndividuals_all</code></td>
<td>
<p>Synthetic data when synindex is TRUE. NULL otherwise.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Quanli Wang
</p>

<hr>
<h2 id='groupcount'>
Generate 2D count table for two integer-valued vectors.
</h2><span id='topic+groupcount'></span>

<h3>Description</h3>

<p>Similar to 'table' function, this function builts a contingency table of the counts at each combination of all possible values from two integer-valued input vectors.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>groupcount(g1, g2, n1, n2)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="groupcount_+3A_g1">g1</code></td>
<td>

<p>The first integer-valued input vector. The max value in g1 is n1.
</p>
</td></tr>
<tr><td><code id="groupcount_+3A_g2">g2</code></td>
<td>

<p>The second integer-valued input vector. The max value in g1 is n2.
</p>
</td></tr>
<tr><td><code id="groupcount_+3A_n1">n1</code></td>
<td>

<p>The maximum value in g1.
</p>
</td></tr>
<tr><td><code id="groupcount_+3A_n2">n2</code></td>
<td>

<p>The maximum value in g2.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This is implemented as an utility function to build a 2D histogram count table. For efficiency, it does not check if the maximum values in input vectors exceed the maximum values specified.
</p>


<h3>Value</h3>

<p>The count table.
</p>


<h3>Author(s)</h3>

<p>Quanli Wang
</p>


<h3>Examples</h3>

<pre><code class='language-R'>n1 &lt;- 20
n2 &lt;- 10
g1 &lt;- sample.int(n1,1000, replace = TRUE)
g2 &lt;- sample.int(n2,1000, replace = TRUE)
counts &lt;- groupcount(g1,g2,n1,n2)
</code></pre>

<hr>
<h2 id='groupcount1D'>
Generate histogram count for an integer-valued vector.
</h2><span id='topic+groupcount1D'></span>

<h3>Description</h3>

<p>Generate histogram count for an integer-valued vector.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>groupcount1D(g, n)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="groupcount1D_+3A_g">g</code></td>
<td>

<p>An integer-valued input vector. The max value in g is n.
</p>
</td></tr>
<tr><td><code id="groupcount1D_+3A_n">n</code></td>
<td>

<p>The max value in g.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This is implemented as an utility function for 1D histgram count. For efficiency, it does not check if the maximum value in the input vector exceeds the maximum value specified.
</p>


<h3>Value</h3>

<p>The count values.
</p>


<h3>Author(s)</h3>

<p>Quanli Wang
</p>


<h3>Examples</h3>

<pre><code class='language-R'>n &lt;- 20
g &lt;- sample.int(n,1000, replace = TRUE)
counts &lt;- groupcount1D(g,n)
</code></pre>

<hr>
<h2 id='households2individuals'>
Convert a household data matrix to the corresponding individual member data matrix.
</h2><span id='topic+households2individuals'></span>

<h3>Description</h3>

<p>Convert a household data matrix to the corresponding individual member data matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>households2individuals(data, hh_size)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="households2individuals_+3A_data">data</code></td>
<td>

<p>Household data matrix.
</p>
</td></tr>
<tr><td><code id="households2individuals_+3A_hh_size">hh_size</code></td>
<td>

<p>The household size for the households in <code style="white-space: pre;">&#8288;data&#8288;</code>.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Individual member data matrix.
</p>


<h3>Author(s)</h3>

<p>Quanli Wang
</p>

<hr>
<h2 id='initData'>
Initialize the input data structure.
</h2><span id='topic+initData'></span>

<h3>Description</h3>

<p>Initialize the input data structure.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>initData(md)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="initData_+3A_md">md</code></td>
<td>
<p>A list holds all the input data with optional missing data info.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list object including all the necessary data variables needed by the sampler.
</p>
<table role = "presentation">
<tr><td><code>origdata</code></td>
<td>
<p>Original data.</p>
</td></tr>
<tr><td><code>n_i</code></td>
<td>
<p>Vector containing the number of individuals in each household in the data.</p>
</td></tr>
<tr><td><code>n</code></td>
<td>
<p>Number of households in the data</p>
</td></tr>
<tr><td><code>HHdataorigT</code></td>
<td>
<p>The transposed household level data &ndash; each column now represents each household.</p>
</td></tr>
<tr><td><code>HHserial</code></td>
<td>
<p>Vector containing the household index for each individual in the data.</p>
</td></tr>
<tr><td><code>n_individuals</code></td>
<td>
<p>The total number of individuals N across all n households in the input data.</p>
</td></tr>
<tr><td><code>n_individuals_real</code></td>
<td>
<p>The real total number of individuals N across all n households. The is the same as n_individuals if the household head hasn't been moved to the household level and different otherwise.</p>
</td></tr>
<tr><td><code>p</code></td>
<td>
<p>Number of individual-level variables.</p>
</td></tr>
<tr><td><code>d</code></td>
<td>
<p>Vector containing the number of levels for each of the <code style="white-space: pre;">&#8288;p&#8288;</code> variables.</p>
</td></tr>
<tr><td><code>dataT</code></td>
<td>
<p>The transposed individual level data &ndash; each column now represents each individual.</p>
</td></tr>
<tr><td><code>maxd</code></td>
<td>
<p>The max value in <code style="white-space: pre;">&#8288;d&#8288;</code></p>
</td></tr>
<tr><td><code>n_star_h</code></td>
<td>
<p>Vector containing the number of observed households for the different household sizes in the original data.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Quanli Wang
</p>

<hr>
<h2 id='initMissing'>
Initilize the misising data structure from input data
</h2><span id='topic+initMissing'></span>

<h3>Description</h3>

<p>Initilize the misising data structure from input data
</p>


<h3>Usage</h3>

<pre><code class='language-R'>initMissing(data,struc_zero_variables,miss_batch)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="initMissing_+3A_data">data</code></td>
<td>
<p>A list that holds all input data info.</p>
</td></tr>
<tr><td><code id="initMissing_+3A_struc_zero_variables">struc_zero_variables</code></td>
<td>
<p>column indexes for the variables that define structural zeros like age and relate (including those for the household head).</p>
</td></tr>
<tr><td><code id="initMissing_+3A_miss_batch">miss_batch</code></td>
<td>
<p>initial number of batches to sample for each household with missing data.</p>
</td></tr>
</table>

<hr>
<h2 id='initOutput'>
Set the output structure for saving posterior samples of parameters.
</h2><span id='topic+initOutput'></span>

<h3>Description</h3>

<p>Set the output structure for saving posterior samples of parameters.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>initOutput(data, hyper, mc)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="initOutput_+3A_data">data</code></td>
<td>

<p>A list object including all the necessary data variables needed by the sampler.; output of the <code style="white-space: pre;">&#8288;initData&#8288;</code> function.
</p>
</td></tr>
<tr><td><code id="initOutput_+3A_hyper">hyper</code></td>
<td>

<p>Hyper parameters for priors.
</p>
</td></tr>
<tr><td><code id="initOutput_+3A_mc">mc</code></td>
<td>

<p>MCMC parameters.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of output parameters to be saved.
</p>
<table role = "presentation">
<tr><td><code>alphaout</code></td>
<td>
<p>Vector of posterior samples for the concentration parameter in the Dirichlet process for the group-level latent classes.</p>
</td></tr>
<tr><td><code>betaout</code></td>
<td>
<p>Vector of posterior samples for the concentration parameter in the Dirichlet process for the individual-level latent classes. Currently, this is assumed to be the same within all group-level classes.</p>
</td></tr>
<tr><td><code>piout</code></td>
<td>
<p>Matrix of posterior samples for the vector of probabilities for the group-level latent classes.</p>
</td></tr>
<tr><td><code>omegaout</code></td>
<td>
<p>3D array of posterior samples for the matrix of probabilities for the group-level and individual-level latent class pairs.</p>
</td></tr>
<tr><td><code>nout</code></td>
<td>
<p>Vector of posterior samples for the total number of impossible households sampled.</p>
</td></tr>
<tr><td><code>extrasize</code></td>
<td>
<p>Matrix of posterior samples for the number of impossible households sampled, split by household size.</p>
</td></tr>
<tr><td><code>F_occupied</code></td>
<td>
<p>Vector of posterior samples for the number of occupied household-level latent classes.</p>
</td></tr>
<tr><td><code>S_occupied_max</code></td>
<td>
<p>Vector of posterior samples for the max number of occupied individual-level latent classes.</p>
</td></tr>
<tr><td><code>elapsed_time</code></td>
<td>
<p>Vector of time taken to run each iteration.</p>
</td></tr>
<tr><td><code>newphiout</code></td>
<td>
<p>3D array of posterior samples for the individual-level probabilities for each individual-level variable by each pair of group-level and individual-level latent classes.</p>
</td></tr>
<tr><td><code>lambdaout</code></td>
<td>
<p>A list of an array of posterior samples for the group-level probabilities for each group-level variable. Each array in the list is for each group-level variable.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Quanli Wang, Olanrewaju Akande
</p>

<hr>
<h2 id='initParameters'>
Initialize the model parameters for the MCMC.
</h2><span id='topic+initParameters'></span>

<h3>Description</h3>

<p>Initialize the model parameters for the MCMC.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>initParameters(data, hyper, HHhead_at_group_level)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="initParameters_+3A_data">data</code></td>
<td>

<p>A list object including all the necessary data variables needed by the sampler; output of the <code style="white-space: pre;">&#8288;initData&#8288;</code> function.
</p>
</td></tr>
<tr><td><code id="initParameters_+3A_hyper">hyper</code></td>
<td>

<p>Hyper parameters for the prior distributions.
</p>
</td></tr>
<tr><td><code id="initParameters_+3A_hhhead_at_group_level">HHhead_at_group_level</code></td>
<td>

<p>Logical indicator for data structure with respect to the household head. Set to TRUE if the household head has been moved to the household level and FALSE otherwise.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of the initial values of the parameters.
</p>
<table role = "presentation">
<tr><td><code>alpha</code></td>
<td>
<p>Concentration parameter in the Dirichlet process for the group-level latent classes.</p>
</td></tr>
<tr><td><code>beta</code></td>
<td>
<p>Concentration parameter in the Dirichlet process for the individual-level latent classes. Currently, this is assumed to be the same within all group-level classes.</p>
</td></tr>
<tr><td><code>phi</code></td>
<td>
<p>Matrix of posterior samples for the individual-level probabilities for each individual-level variable by each pair of group-level and individual-level latent classes.</p>
</td></tr>
<tr><td><code>HHdata_all</code></td>
<td>
<p>The transposed household level data &ndash; each column represents each household.</p>
</td></tr>
<tr><td><code>lambda</code></td>
<td>
<p>A list of matrices of the group-level probabilities for each group-level variable by the group-level latent classes. Each matrix in the list is for each group-level variable.</p>
</td></tr>
<tr><td><code>u</code></td>
<td>
<p>Vector of the beta-distributed variables in the stick breaking representation of the group-level latent classes.</p>
</td></tr>
<tr><td><code>pi</code></td>
<td>
<p>Vector of the probabilities for the group-level latent classes.</p>
</td></tr>
<tr><td><code>v</code></td>
<td>
<p>Matrix of the beta-distributed variables in the stick breaking representation of the individual-level latent classes by the group-level latent classes.</p>
</td></tr>
<tr><td><code>omega</code></td>
<td>
<p>Matrix of the probabilities for the individual-level latent classes by the group-level latent classes.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Quanli Wang
</p>

<hr>
<h2 id='RunModel'>
Run the mcmc sampler for the model.
</h2><span id='topic+RunModel'></span>

<h3>Description</h3>

<p>Run the mcmc sampler for the model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>RunModel(orig,mc,hyper,para,output,synindex,individual_variable_index,
    household_variable_index,HHhead_at_group_level,weight_option,struc_weight,MissData,
    Parallel)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="RunModel_+3A_orig">orig</code></td>
<td>
<p>A list object including all the necessary data variables needed by the sampler.; output of the <code style="white-space: pre;">&#8288;initData&#8288;</code> function.</p>
</td></tr>
<tr><td><code id="RunModel_+3A_mc">mc</code></td>
<td>
<p>A list specifying the number of mcmc iterations, burn-in, thinning and the effective sample size.</p>
</td></tr>
<tr><td><code id="RunModel_+3A_hyper">hyper</code></td>
<td>
<p>Hyper parameters for the prior distributions.</p>
</td></tr>
<tr><td><code id="RunModel_+3A_para">para</code></td>
<td>
<p>A list of the initial values of the parameters; output of the <code style="white-space: pre;">&#8288;initParameters&#8288;</code> function.</p>
</td></tr>
<tr><td><code id="RunModel_+3A_output">output</code></td>
<td>
<p>A list of output parameters to be saved; output of the <code style="white-space: pre;">&#8288;initOutput&#8288;</code> function.</p>
</td></tr>
<tr><td><code id="RunModel_+3A_synindex">synindex</code></td>
<td>
<p>A vector of iteration indexes for sampling synthetic data. length(<code style="white-space: pre;">&#8288;synindex&#8288;</code>) is the number of synthetic data needed. </p>
</td></tr>
<tr><td><code id="RunModel_+3A_individual_variable_index">individual_variable_index</code></td>
<td>
<p>Vector of column indexes for the individual-level variables.</p>
</td></tr>
<tr><td><code id="RunModel_+3A_household_variable_index">household_variable_index</code></td>
<td>
<p>Vector of column indexes for the group-level variables.</p>
</td></tr>
<tr><td><code id="RunModel_+3A_hhhead_at_group_level">HHhead_at_group_level</code></td>
<td>
<p>Logical indicator for whether or not to move the household head to the household level. Set to TRUE to move the household head and FALSE otherwise.</p>
</td></tr>
<tr><td><code id="RunModel_+3A_weight_option">weight_option</code></td>
<td>
<p>Logical indicator for whether or not to cap the number of impossible households to sample and re-weight the multinomial counts within each latent class back to the expected truth. Set to TRUE to use the weigthting option nd FALSE otherwise.</p>
</td></tr>
<tr><td><code id="RunModel_+3A_struc_weight">struc_weight</code></td>
<td>
<p>Vector specifying the weights to be used for each household size. The weights must be ordered by household sizes and no household must be excluded.</p>
</td></tr>
<tr><td><code id="RunModel_+3A_missdata">MissData</code></td>
<td>
<p>A list that stores all the info related to missing data. Default to NULL for no missing data.</p>
</td></tr>
<tr><td><code id="RunModel_+3A_parallel">Parallel</code></td>
<td>

<p>Logical indicator for running the function in parallel mode.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function runs the mcmc sampler for the NDPMPM model and generates posterior samples of parameters. It also generates synthetic data when needed.
</p>
<p>Please note that:
</p>

<ul>
<li><p>The minimum household size for this mcmc sampler is 2 because households of size 1 do not violate the structural zeros specified in this package. Also, moving the household head to the household level is not possible for households of size 1.
</p>
</li>
<li><p>Each variable included must be recoded to start from 1.
</p>
</li>
<li><p>Moving the household head to the household level and setting the HHhead_at_group_level option to TRUE speeds up the sampler significantly.
</p>
</li>
<li><p>Setting the weight_option to TRUE and specifying weights also speeds up the sampler but the exact rate of speedup depends on the specific weights.
</p>
</li></ul>

<p>Our example data set contains a sample of 2000 households and seven variables from the 2012 American Community Survey data. The variables are described below:
</p>

<ul>
<li><p>ownership (ownership of dwelling): 1 = owned or being bought (loan), 2 = rented.
</p>
</li>
<li><p>householdsize (household size): 2 = 2 people, 3 = 3 people, 4 = 4 people, 5 = 5 people, 6 = 6 people.
</p>
</li>
<li><p>sex (gender): 1 = male, 2 = female.
</p>
</li>
<li><p>race: 1 = white, 2 = black, 3 = American Indian or Alaska Native, 4 = Chinese, 5 = Japanese, 6 = other Asian/Pacific Islander,
7 = other race, 8 = two major races, 9 = three/more major races.
</p>
</li>
<li><p>hisp (Hispanic origin). 1 = not Hispanic, 2 = Mexican, 3 = Puerto Rican, 4 = Cuban, 5 = other.
</p>
</li>
<li><p>age: 1 = 0 (less then one year old), 2 = 1, 3 = 2,   . . . , 94 = 93
</p>
</li>
<li><p>relate (relationship to the household head): 1 = head/householder, 2 = spouse, 3 = child, 4 = child-in-law, 5 = parent, 6 = parent-in-
law, 7 = sibling, 8 = sibling-in-law, 9 = grandchild, 10 = other relatives, 11 = partner, friend, visitor, 12 = other non-relatives
</p>
</li></ul>

<p>Subsequent data sets must follow this structure because of the predefined list of structural zeros or users can modify the list of structural zeros by downloading the package source, making changes only to the checkconstraints_imp.cpp file and re-building the package.
</p>


<h3>Value</h3>

<table role = "presentation">
<tr><td><code>synData</code></td>
<td>
<p>The list of synthetic data when the length(<code style="white-space: pre;">&#8288;synindex&#8288;</code>) &gt; 0.</p>
</td></tr>
<tr><td><code>output</code></td>
<td>
<p>The list of posterior samples for the parameters included in <code style="white-space: pre;">&#8288;output&#8288;</code>.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Quanli Wang, Olanrewaju Akande
</p>

<hr>
<h2 id='sampleG'>
Update household (group) level latent class indexes.
</h2><span id='topic+sampleG'></span>

<h3>Description</h3>

<p>Update household (group) level latent class indexes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sampleG(phi, data, omega, pi, ni, HHdata, lambda, Parallel)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="sampleG_+3A_phi">phi</code></td>
<td>

<p>Matrix of posterior samples for the individual-level probabilities for each individual-level variable by each pair of group-level and individual-level latent classes.
</p>
</td></tr>
<tr><td><code id="sampleG_+3A_data">data</code></td>
<td>

<p>Individual level data.
</p>
</td></tr>
<tr><td><code id="sampleG_+3A_omega">omega</code></td>
<td>

<p>Matrix of the probabilities for the individual-level latent classes by the group-level latent classes.
</p>
</td></tr>
<tr><td><code id="sampleG_+3A_pi">pi</code></td>
<td>

<p>Vector of the probabilities for the group-level latent classes.
</p>
</td></tr>
<tr><td><code id="sampleG_+3A_ni">ni</code></td>
<td>

<p>Vector containing the number of individuals in each household in the data..
</p>
</td></tr>
<tr><td><code id="sampleG_+3A_hhdata">HHdata</code></td>
<td>

<p>Household level data.
</p>
</td></tr>
<tr><td><code id="sampleG_+3A_lambda">lambda</code></td>
<td>

<p>A list of matrices of the group-level probabilities for each group-level variable by the group-level latent classes. Each matrix in the list is for each group-level variable.
</p>
</td></tr>
<tr><td><code id="sampleG_+3A_parallel">Parallel</code></td>
<td>

<p>Logical indicator for running the function in parallel mode.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Function for obtaining a posterior sample of the household-level latent class indexes for all households in the input data based on the corresponding full conditional distribution.
</p>


<h3>Value</h3>

<p>A list with two variables.
</p>
<table role = "presentation">
<tr><td><code>G</code></td>
<td>
<p>A vector for the updated values of the household-level latent class indexes for all households in the input data.</p>
</td></tr>
<tr><td><code>G_Individuals</code></td>
<td>
<p>The vector <code style="white-space: pre;">&#8288;G&#8288;</code> expanded to a long format to match the number of individuals in <code style="white-space: pre;">&#8288;data&#8288;</code>.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Quanli Wang
</p>

<hr>
<h2 id='samplehouseholds'>
Rcpp implementation for sampling household data without constraints.
</h2><span id='topic+samplehouseholds'></span>

<h3>Description</h3>

<p>Rcpp implementation for sampling household data without constraints.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>samplehouseholds(phi, omega, pi, d, lambda, currrentbatch, nHouseholds, householdsize,
      HeadAtGroupLevel, Parallel)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="samplehouseholds_+3A_phi">phi</code></td>
<td>
<p>Matrix of posterior samples for the individual-level probabilities for each individual-level variable by each pair of group-level and individual-level latent classes.</p>
</td></tr>
<tr><td><code id="samplehouseholds_+3A_omega">omega</code></td>
<td>
<p>Matrix of the probabilities for the individual-level latent classes by the group-level latent classes.</p>
</td></tr>
<tr><td><code id="samplehouseholds_+3A_pi">pi</code></td>
<td>
<p>Vector of the probabilities for the group-level latent classes.</p>
</td></tr>
<tr><td><code id="samplehouseholds_+3A_d">d</code></td>
<td>
<p>Vector containing the number of levels for each of the indiviual-level variables.</p>
</td></tr>
<tr><td><code id="samplehouseholds_+3A_lambda">lambda</code></td>
<td>
<p>A list of matrices of the group-level probabilities for each group-level variable by the group-level latent classes. Each matrix in the list is for each group-level variable.</p>
</td></tr>
<tr><td><code id="samplehouseholds_+3A_currrentbatch">currrentbatch</code></td>
<td>

<p>The current batch number for the household data to be generated. The household ID will be generated based on this batch number.
</p>
</td></tr>
<tr><td><code id="samplehouseholds_+3A_nhouseholds">nHouseholds</code></td>
<td>

<p>The number of households to be generated by one call to this function.
</p>
</td></tr>
<tr><td><code id="samplehouseholds_+3A_householdsize">householdsize</code></td>
<td>

<p>The size of the households to be generated.
</p>
</td></tr>
<tr><td><code id="samplehouseholds_+3A_headatgrouplevel">HeadAtGroupLevel</code></td>
<td>

<p>Logical indicator for running the model that codes household head at the group level.
</p>
</td></tr>
<tr><td><code id="samplehouseholds_+3A_parallel">Parallel</code></td>
<td>

<p>Logical indicator for running the function in parallel mode.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function allows the model to generate a batch of <code style="white-space: pre;">&#8288;nHouseholds&#8288;</code> with each household of size <code style="white-space: pre;">&#8288;householdsize&#8288;</code>. The generated household data will include both possible and impossible households. Use <code style="white-space: pre;">&#8288;samplehouseholds&#8288;</code> when the household head is included as an individual within the household.
</p>


<h3>Value</h3>

<p>A data matrix with each row for one household.
</p>


<h3>Author(s)</h3>

<p>Quanli Wang
</p>

<hr>
<h2 id='sampleM'>
Update individual level latent class  indexes.
</h2><span id='topic+sampleM'></span>

<h3>Description</h3>

<p>Update individual level latent class  indexes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sampleM(phi, data, omega, G, serial,  Parallel)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="sampleM_+3A_phi">phi</code></td>
<td>

<p>Matrix of posterior samples for the individual-level probabilities for each individual-level variable by each pair of group-level and individual-level latent classes.
</p>
</td></tr>
<tr><td><code id="sampleM_+3A_data">data</code></td>
<td>

<p>Input individual-level data.
</p>
</td></tr>
<tr><td><code id="sampleM_+3A_omega">omega</code></td>
<td>

<p>Matrix of the probabilities for the individual-level latent classes by the group-level latent classes.
</p>
</td></tr>
<tr><td><code id="sampleM_+3A_g">G</code></td>
<td>

<p>Household-level latent class indexes.
</p>
</td></tr>
<tr><td><code id="sampleM_+3A_serial">serial</code></td>
<td>

<p>Vector containing the household index for each individual in the data.
</p>
</td></tr>
<tr><td><code id="sampleM_+3A_parallel">Parallel</code></td>
<td>

<p>Logical indicator for running the function in parallel mode.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Function for obtaining a posterior sample of the individual-level latent class indexes for all individuals in the input data based on the corresponding full conditional distribution.
</p>


<h3>Value</h3>

<p>A vector for the updated values of the individual-level latent class indexes for all individuals in the input data.
</p>


<h3>Author(s)</h3>

<p>Quanli Wang
</p>

<hr>
<h2 id='SampleMissing'>
Sample and update missing data
</h2><span id='topic+SampleMissing'></span>

<h3>Description</h3>

<p>Sample and update missing data if missing data are presented in the input
</p>


<h3>Usage</h3>

<pre><code class='language-R'>SampleMissing(MissData, para, orig, G_household, M, hyper)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="SampleMissing_+3A_missdata">MissData</code></td>
<td>

<p>The missing data structure that provides all infro related to missing data</p>
</td></tr>
<tr><td><code id="SampleMissing_+3A_para">para</code></td>
<td>
<p>A list of the initial values of the parameters; output of the <code style="white-space: pre;">&#8288;initParameters&#8288;</code> function.</p>
</td></tr>
<tr><td><code id="SampleMissing_+3A_orig">orig</code></td>
<td>
<p>A list object including all the necessary data variables needed by the sampler.</p>
</td></tr>
<tr><td><code id="SampleMissing_+3A_g_household">G_household</code></td>
<td>
<p>group level household index</p>
</td></tr>
<tr><td><code id="SampleMissing_+3A_m">M</code></td>
<td>
<p>individual level latent class  indexes</p>
</td></tr>
<tr><td><code id="SampleMissing_+3A_hyper">hyper</code></td>
<td>
<p>Hyper parameters for the prior distributions.</p>
</td></tr>
</table>

<hr>
<h2 id='UpdateAlpha'>
Update alpha.
</h2><span id='topic+UpdateAlpha'></span>

<h3>Description</h3>

<p>Update alpha &ndash; the concentration parameter in the Dirichlet process for the group-level latent classes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>UpdateAlpha(aa, ab, u)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="UpdateAlpha_+3A_aa">aa</code></td>
<td>

<p>Hyper-parameter a for alpha.
</p>
</td></tr>
<tr><td><code id="UpdateAlpha_+3A_ab">ab</code></td>
<td>

<p>Hyper-parameter b for alpha.
</p>
</td></tr>
<tr><td><code id="UpdateAlpha_+3A_u">u</code></td>
<td>

<p>Vector of the beta-distributed variables in the stick breaking representation of the group-level latent classes.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Updated (posterior) value for alpha based on the corresponding full conditional distribution.
</p>


<h3>Author(s)</h3>

<p>Quanli Wang
</p>

<hr>
<h2 id='UpdateBeta'>
Update beta.
</h2><span id='topic+UpdateBeta'></span>

<h3>Description</h3>

<p>Update beta &ndash; the concentration parameter in the Dirichlet process for the individual-level latent classes. Currently, this is assumed to be the same within all group-level classes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>UpdateBeta(ba, bb, v)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="UpdateBeta_+3A_ba">ba</code></td>
<td>

<p>Hyper-parameter a for beta.
</p>
</td></tr>
<tr><td><code id="UpdateBeta_+3A_bb">bb</code></td>
<td>

<p>Hyper-parameter b for beta.
</p>
</td></tr>
<tr><td><code id="UpdateBeta_+3A_v">v</code></td>
<td>

<p>Matrix of the beta-distributed variables in the stick breaking representation of the individual-level latent classes by the group-level latent classes.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Updated (posterior) value for beta based on the corresponding full conditional distribution..
</p>


<h3>Author(s)</h3>

<p>Quanli Wang
</p>

<hr>
<h2 id='UpdateLambda'>
Update lambda.
</h2><span id='topic+UpdateLambda'></span>

<h3>Description</h3>

<p>Update lambda &ndash; the list of matrices of the group-level probabilities for each group-level variable by the group-level latent classes when the weighting/capping option is not used. Each matrix in the list is for each group-level variable.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>UpdateLambda(HHdata_all, G_all, dHH, FF)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="UpdateLambda_+3A_hhdata_all">HHdata_all</code></td>
<td>

<p>Data matrix for the household-level data from both the original data and the sampled impossible households.
</p>
</td></tr>
<tr><td><code id="UpdateLambda_+3A_g_all">G_all</code></td>
<td>

<p>A vector of the household-level latent class indexes for all households both in the original data and the sampled impossible households.
</p>
</td></tr>
<tr><td><code id="UpdateLambda_+3A_dhh">dHH</code></td>
<td>

<p>A vector containing the number of levels for each household-level variable.
</p>
</td></tr>
<tr><td><code id="UpdateLambda_+3A_ff">FF</code></td>
<td>

<p>Maximum number of household-level latent classes allowed.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Function for obtaining a posterior sample of lambda when the weighting/capping option is not used.
</p>


<h3>Value</h3>

<p>Updated (posterior) value for lambda based on the corresponding full conditional distribution.
</p>


<h3>Author(s)</h3>

<p>Quanli Wang
</p>

<hr>
<h2 id='UpdateLambdaWeighted'>
Update lambda.
</h2><span id='topic+UpdateLambdaWeighted'></span>

<h3>Description</h3>

<p>Update lambda &ndash; the list of matrices of the group-level probabilities for each group-level variable by the group-level latent classes &ndash; when the weighting/capping option is used. The weighting options allows capping the number of impossible households to sample and re-weight the multinomial counts within each latent class back to the expected truth. Each matrix in the list is for each group-level variable.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>UpdateLambdaWeighted(HHdata_all, G_all, dHH, FF,struc_weight)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="UpdateLambdaWeighted_+3A_hhdata_all">HHdata_all</code></td>
<td>

<p>Data matrix for the household-level data from both the original data and the sampled impossible households.
</p>
</td></tr>
<tr><td><code id="UpdateLambdaWeighted_+3A_g_all">G_all</code></td>
<td>

<p>A vector of the household-level latent class indexes for all households both in the original data and the sampled impossible households.
</p>
</td></tr>
<tr><td><code id="UpdateLambdaWeighted_+3A_dhh">dHH</code></td>
<td>

<p>A vector containing the number of levels for each household-level variable.
</p>
</td></tr>
<tr><td><code id="UpdateLambdaWeighted_+3A_ff">FF</code></td>
<td>

<p>Maximum number of household-level latent classes allowed.
</p>
</td></tr>
<tr><td><code id="UpdateLambdaWeighted_+3A_struc_weight">struc_weight</code></td>
<td>
<p>A vector of weights by household sizes used in capping the number of sampled impossible households.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Function for obtaining a posterior sample of lambda when the weighting/capping option is used.
</p>


<h3>Value</h3>

<p>Updated (posterior) value for lambda based on the corresponding full conditional distribution.
</p>


<h3>Author(s)</h3>

<p>Quanli Wang, Olanrewaju Akande
</p>

<hr>
<h2 id='UpdateOmega'>
Update omega and v.
</h2><span id='topic+UpdateOmega'></span>

<h3>Description</h3>

<p>Update omega &ndash; the matrix of the probabilities for the individual-level latent classes by the group-level latent classes &ndash; and v &ndash; the matrix of the beta-distributed variables in the stick breaking representation of the individual-level latent classes by the group-level latent classes &ndash; when the weighting/capping option is not used.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>UpdateOmega(beta, M_all, FF, SS)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="UpdateOmega_+3A_beta">beta</code></td>
<td>

<p>Concentration parameter in the Dirichlet process for the individual-level latent classes. Currently, this is assumed to be the same within all group-level classes.
</p>
</td></tr>
<tr><td><code id="UpdateOmega_+3A_m_all">M_all</code></td>
<td>

<p>A vector of both the household-level and individual-level latent class indexes for all households both in the original data and the sampled impossible households.
</p>
</td></tr>
<tr><td><code id="UpdateOmega_+3A_ff">FF</code></td>
<td>

<p>Maximum number of household-level latent classes allowed.
</p>
</td></tr>
<tr><td><code id="UpdateOmega_+3A_ss">SS</code></td>
<td>

<p>Maximum number of individual-level latent classes allowed.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list containing the updated (posterior) values for omega and v based on the corresponding full conditional distributions.
</p>


<h3>Author(s)</h3>

<p>Quanli Wang
</p>

<hr>
<h2 id='UpdateOmegaWeighted'>
Update omega and v.
</h2><span id='topic+UpdateOmegaWeighted'></span>

<h3>Description</h3>

<p>Update omega &ndash; the matrix of the probabilities for the individual-level latent classes by the group-level latent classes &ndash; and v &ndash; the matrix of the beta-distributed variables in the stick breaking representation of the individual-level latent classes by the group-level latent classes &ndash; when the weighting/capping option is used. The weighting options allows capping the number of impossible households to sample and re-weight the multinomial counts within each latent class back to the expected truth.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>UpdateOmegaWeighted(beta, M_all, FF, SS, struc_weight)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="UpdateOmegaWeighted_+3A_beta">beta</code></td>
<td>

<p>Concentration parameter in the Dirichlet process for the individual-level latent classes. Currently, this is assumed to be the same within all group-level classes.
</p>
</td></tr>
<tr><td><code id="UpdateOmegaWeighted_+3A_m_all">M_all</code></td>
<td>

<p>A vector of both the household-level and individual-level latent class indexes for all households both in the original data and the sampled impossible households.
</p>
</td></tr>
<tr><td><code id="UpdateOmegaWeighted_+3A_ff">FF</code></td>
<td>

<p>Maximum number of household-level latent classes allowed.
</p>
</td></tr>
<tr><td><code id="UpdateOmegaWeighted_+3A_ss">SS</code></td>
<td>

<p>Maximum number of individual-level latent classes allowed.
</p>
</td></tr>
<tr><td><code id="UpdateOmegaWeighted_+3A_struc_weight">struc_weight</code></td>
<td>
<p>A vector of weights by household sizes used in capping the number of sampled impossible households.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list containing the updated (posterior) values for omega and v based on the corresponding full conditional distributions.
</p>


<h3>Author(s)</h3>

<p>Quanli Wang, Olanrewaju Akande
</p>

<hr>
<h2 id='UpdatePhi'>
Update phi.
</h2><span id='topic+UpdatePhi'></span>

<h3>Description</h3>

<p>Update phi &ndash; the matrix of posterior samples for the individual-level probabilities for each individual-level variable by each pair of group-level and individual-level latent classes &ndash; when the weighting/capping option is not used.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>UpdatePhi(data, M_all, FF, SS, d, maxd)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="UpdatePhi_+3A_data">data</code></td>
<td>

<p>Data matrix for the individual-level data from both the original data and the sampled impossible households.
</p>
</td></tr>
<tr><td><code id="UpdatePhi_+3A_m_all">M_all</code></td>
<td>

<p>A vector of both the household-level and individual-level latent class indexes for all households both in the original data and the sampled impossible households.
</p>
</td></tr>
<tr><td><code id="UpdatePhi_+3A_ff">FF</code></td>
<td>

<p>Maximum number of household-level latent classes allowed.
</p>
</td></tr>
<tr><td><code id="UpdatePhi_+3A_ss">SS</code></td>
<td>

<p>Maximum number of individual-level latent classes allowed.
</p>
</td></tr>
<tr><td><code id="UpdatePhi_+3A_d">d</code></td>
<td>

<p>A vector for the number of levels of each individual-level variable.
</p>
</td></tr>
<tr><td><code id="UpdatePhi_+3A_maxd">maxd</code></td>
<td>

<p>Maximum value in <code style="white-space: pre;">&#8288;d&#8288;</code>.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Function for obtaining a posterior sample of phi when the weighting/capping option is not used.
</p>


<h3>Value</h3>

<p>Updated (posterior) value for phi based on the corresponding full conditional distribution.
</p>


<h3>Author(s)</h3>

<p>Quanli Wang
</p>

<hr>
<h2 id='UpdatePhiWeighted'>
Update phi.
</h2><span id='topic+UpdatePhiWeighted'></span>

<h3>Description</h3>

<p>Update phi &ndash; the matrix of posterior samples for the individual-level probabilities for each individual-level variable by each pair of group-level and individual-level latent classes &ndash; when the weighting/capping option is used. The weighting options allows capping the number of impossible households to sample and re-weight the multinomial counts within each latent class back to the expected truth.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>UpdatePhiWeighted(data, M_all, FF, SS, d, maxd, struc_weight)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="UpdatePhiWeighted_+3A_data">data</code></td>
<td>

<p>Data matrix for the individual-level data from both the original data and the sampled impossible households.
</p>
</td></tr>
<tr><td><code id="UpdatePhiWeighted_+3A_m_all">M_all</code></td>
<td>

<p>A vector of both the household-level and individual-level latent class indexes for all households both in the original data and the sampled impossible households.
</p>
</td></tr>
<tr><td><code id="UpdatePhiWeighted_+3A_ff">FF</code></td>
<td>

<p>Maximum number of household-level latent classes allowed.
</p>
</td></tr>
<tr><td><code id="UpdatePhiWeighted_+3A_ss">SS</code></td>
<td>

<p>Maximum number of individual-level latent classes allowed.
</p>
</td></tr>
<tr><td><code id="UpdatePhiWeighted_+3A_d">d</code></td>
<td>

<p>A vector for the number of levels of each individual-level variable.
</p>
</td></tr>
<tr><td><code id="UpdatePhiWeighted_+3A_maxd">maxd</code></td>
<td>

<p>Maximum value in <code style="white-space: pre;">&#8288;d&#8288;</code>.
</p>
</td></tr>
<tr><td><code id="UpdatePhiWeighted_+3A_struc_weight">struc_weight</code></td>
<td>
<p>A vector of weights by household sizes used in capping the number of sampled impossible households.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Function for obtaining a posterior sample of phi when the weighting/capping option is used.
</p>


<h3>Value</h3>

<p>Updated (posterior) value for phi based on the corresponding full conditional distribution.
</p>


<h3>Author(s)</h3>

<p>Quanli Wang, Olanrewaju Akande
</p>

<hr>
<h2 id='UpdatePi'>
Update pi and u.
</h2><span id='topic+UpdatePi'></span>

<h3>Description</h3>

<p>Update pi &ndash; the vector of the probabilities for the group-level latent classes &ndash; and u &ndash; the vector of the beta-distributed variables in the stick breaking representation of the group-level latent classes &ndash; when the weighting/capping option is not used.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>UpdatePi(alpha, G_all, FF)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="UpdatePi_+3A_alpha">alpha</code></td>
<td>

<p>Concentration parameter in the Dirichlet process for the group-level latent classes
</p>
</td></tr>
<tr><td><code id="UpdatePi_+3A_g_all">G_all</code></td>
<td>

<p>A vector of the household-level latent class indexes for all households both in the original data and the sampled impossible households.
</p>
</td></tr>
<tr><td><code id="UpdatePi_+3A_ff">FF</code></td>
<td>

<p>Maximum number of household-level latent classes allowed.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Function for obtaining a posterior sample of pi when the weighting/capping option is not used.
</p>


<h3>Value</h3>

<p>A list containing the updated (posterior) values for pi and u based on the corresponding full conditional distributions.
</p>


<h3>Author(s)</h3>

<p>Quanli wang
</p>

<hr>
<h2 id='UpdatePiWeighted'>
Update pi and u.
</h2><span id='topic+UpdatePiWeighted'></span>

<h3>Description</h3>

<p>Update pi &ndash; the vector of the probabilities for the group-level latent classes &ndash; and u &ndash; the vector of the beta-distributed variables in the stick breaking representation of the group-level latent classes when the weighting/capping option is used. The weighting options allows capping the number of impossible households to sample and re-weight the multinomial counts within each latent class back to the expected truth.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>UpdatePiWeighted(alpha, G_all, FF, struc_weight)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="UpdatePiWeighted_+3A_alpha">alpha</code></td>
<td>

<p>Concentration parameter in the Dirichlet process for the group-level latent classes
</p>
</td></tr>
<tr><td><code id="UpdatePiWeighted_+3A_g_all">G_all</code></td>
<td>

<p>A vector of the household-level latent class indexes for all households both in the original data and the sampled impossible households.
</p>
</td></tr>
<tr><td><code id="UpdatePiWeighted_+3A_ff">FF</code></td>
<td>

<p>Maximum number of household-level latent classes allowed.
</p>
</td></tr>
<tr><td><code id="UpdatePiWeighted_+3A_struc_weight">struc_weight</code></td>
<td>
<p>A vector of weights by household sizes used in capping the number of sampled impossible households.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Function for obtaining a posterior sample of pi when the weighting/capping option is used.
</p>


<h3>Value</h3>

<p>A list containing the updated (posterior) values for pi and u based on the corresponding full conditional distributions.
</p>


<h3>Author(s)</h3>

<p>Quanli wang, Olanrewaju Akande
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
