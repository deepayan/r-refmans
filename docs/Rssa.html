<!DOCTYPE html><html lang="en"><head><title>Help for package Rssa</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {Rssa}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#Rssa-package'><p>A collection of methods for singular spectrum analysis</p></a></li>
<li><a href='#AustralianWine'><p>Australian Wine Sales</p></a></li>
<li><a href='#Barbara'><p>Classical &lsquo;Barbara&rsquo; image (color, wide)</p></a></li>
<li><a href='#bforecast'><p>Perform bootstrap SSA forecasting of the series</p></a></li>
<li><a href='#cadzow'>
<p>Cadzow Iterations</p></a></li>
<li><a href='#calc.v'><p>Calculate Factor Vector(s)</p></a></li>
<li><a href='#cleanup'>
<p>Cleanup of all cached data from SSA objects</p></a></li>
<li><a href='#clone'>
<p>Cloning of SSA objects</p></a></li>
<li><a href='#clplot'>
<p>Ratio of complete lag vectors in dependence on window length</p></a></li>
<li><a href='#decompose'><p>Perform SSA Decomposition</p></a></li>
<li><a href='#eossa'><p>ESPRIT-based O-SSA nested decomposition</p></a></li>
<li><a href='#forecast'><p>Perform SSA forecasting of series</p></a></li>
<li><a href='#fossa'><p>Nested Filter-adjusted O-SSA decomposition</p></a></li>
<li><a href='#frobenius.cor'><p>Calculate Frobenius correlations of the component matrices</p></a></li>
<li><a href='#gapfill'><p>Perform SSA gapfilling via forecast</p></a></li>
<li><a href='#grouping.auto'><p>Group Elementary Series</p></a></li>
<li><a href='#grouping.auto.pgram'>
<p>Group elementary series using periodogram</p></a></li>
<li><a href='#grouping.auto.wcor'><p>Group Elementary Series Using W-correlation Matrix</p></a></li>
<li><a href='#hbhmat'><p>Hankel with Hankel block matrices operations.</p></a></li>
<li><a href='#hmat'><p>Hankel matrices operations.</p></a></li>
<li><a href='#hmatr'><p>Calculate the heterogeneity matrix.</p></a></li>
<li><a href='#igapfill'><p>Perform SSA gapfilling via iterative reconstruction</p></a></li>
<li><a href='#iossa'><p>Iterative O-SSA nested decomposition</p></a></li>
<li><a href='#iossa.result'><p>Summary of Iterative O-SSA results</p></a></li>
<li><a href='#lrr'><p>Calculate the min-norm Linear Recurrence Relation</p></a></li>
<li><a href='#Mars'><p>Webcam image of Mars</p></a></li>
<li><a href='#MotorVehicle'><p>Total U.S. Domestic and Foreign Car Sales</p></a></li>
<li><a href='#owcor'><p>Calculate generalized (oblique) W-correlation matrix</p></a></li>
<li><a href='#parestimate'><p>Estimate periods from (set of) eigenvectors</p></a></li>
<li><a href='#plot'><p>Plot SSA object</p></a></li>
<li><a href='#plot.reconstruction'><p>Plot the results of SSA reconstruction</p></a></li>
<li><a href='#precache'><p>Calculates and caches elementary components inside SSA object</p></a></li>
<li><a href='#reconstruct'><p>Perform a series reconstruction</p></a></li>
<li><a href='#residuals'><p>Obtain the residuals from SSA reconstruction</p></a></li>
<li><a href='#rforecast'><p>Perform recurrent SSA forecasting of the series</p></a></li>
<li><a href='#ssa'><p>Create a new SSA object</p></a></li>
<li><a href='#ssa-input'><p>Input Data Formats Used by SSA Routines</p></a></li>
<li><a href='#ssa-object'><p>Properties of SSA object</p></a></li>
<li><a href='#ssa.capabilities'>
<p>SSA methods and capabilities check</p></a></li>
<li><a href='#summarize.gaps'><p>Summarize Gaps in a Series</p></a></li>
<li><a href='#tmat'><p>Toeplitz matrices operations.</p></a></li>
<li><a href='#USUnemployment'><p>U.S. unemployment figures</p></a></li>
<li><a href='#vforecast'><p>Perform vector SSA forecasting of the series</p></a></li>
<li><a href='#wcor'><p>Calculate the W-correlation matrix</p></a></li>
<li><a href='#wnorm'><p>Calculate Weighted Norm of series</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>A Collection of Methods for Singular Spectrum Analysis</td>
</tr>
<tr>
<td>Version:</td>
<td>1.1</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.1), svd (&ge; 0.4), forecast</td>
</tr>
<tr>
<td>Imports:</td>
<td>lattice, methods</td>
</tr>
<tr>
<td>Suggests:</td>
<td>testthat (&ge; 0.7), RSpectra, PRIMME, irlba</td>
</tr>
<tr>
<td>SystemRequirements:</td>
<td>fftw (&gt;=3.2)</td>
</tr>
<tr>
<td>Author:</td>
<td>Anton Korobeynikov [aut, cre],
  Alex Shlemov [aut],
  Konstantin Usevich [aut],
  Nina Golyandina [aut]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Anton Korobeynikov &lt;anton@korobeynikov.info&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Methods and tools for Singular Spectrum Analysis including decomposition,
             forecasting and gap-filling for univariate and multivariate time series.
             General description of the methods with many examples can be found in the book
             Golyandina (2018, &lt;<a href="https://doi.org/10.1007%2F978-3-662-57380-8">doi:10.1007/978-3-662-57380-8</a>&gt;).
             See 'citation("Rssa")' for details.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/asl/rssa">https://github.com/asl/rssa</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/asl/rssa/issues">https://github.com/asl/rssa/issues</a></td>
</tr>
<tr>
<td>Config/testthat/parallel:</td>
<td>true</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-09-04 20:53:58 UTC; asl</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-09-05 00:00:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='Rssa-package'>A collection of methods for singular spectrum analysis</h2><span id='topic+Rssa-package'></span><span id='topic+Rssa'></span>

<h3>Description</h3>

<p>Singular Spectrum Analysis (SSA, in short) is a modern non-parametric
method for the analysis of time series and digital images. This
package provides a set of fast and reliable implementations of various
routines to perform decomposition, reconstruction and forecasting.
A comprehensive description of the methods and functions from Rssa 
can be found in Golyandina et al (2018). The companion web-site is
https://ssa-with-r-book.github.io/.
</p>


<h3>Details</h3>

<p>Typically the use of the package starts with the <em>decomposition</em>
of the time series using <code><a href="#topic+ssa">ssa</a></code>. After this a suitable
<em>grouping</em> of the elementary time series is required. This can be
done heuristically, for example, via looking at the plots of the
decomposition (<code><a href="#topic+plot.ssa">plot</a></code>). Alternatively, one
can examine the so-called w-correlation matrix
(<code><a href="#topic+wcor">wcor</a></code>). Automatic grouping can be performed by means of
<code><a href="#topic+grouping.auto">grouping.auto</a></code>. 
In addition, Oblique SSA
methods can be used to improve the series separability
(<code><a href="#topic+iossa">iossa</a></code>, <code><a href="#topic+fossa">fossa</a></code>).
</p>
<p>Next step includes the <em>reconstruction</em> of
the time-series using the selected grouping
(<code><a href="#topic+reconstruct.ssa">reconstruct</a></code>). One ends with
frequency estimation (<code><a href="#topic+parestimate">parestimate</a></code>),
series forecasting (<code><a href="#topic+forecast.ssa">forecast</a></code>,
<code><a href="#topic+rforecast.ssa">rforecast</a></code>,
<code><a href="#topic+vforecast.ssa">vforecast</a></code>)
and (if any) gap filling (<code><a href="#topic+gapfill">gapfill</a></code>, 
<code><a href="#topic+igapfill">igapfill</a></code>). 
</p>


<h3>References</h3>

<p>Golyandina N., Korobeynikov A., Zhigljavsky A. (2018):
<em>Singular Spectrum Analysis with R.</em>  Use R!.
Springer, Berlin, Heidelberg.
</p>
<p>Golyandina, N., Nekrutkin, V. and Zhigljavsky, A. (2001):
<em>Analysis of Time Series Structure: SSA and related techniques.</em>
Chapman and Hall/CRC. ISBN 1584881941f
</p>
<p>Golyandina, N. and Stepanov, D. (2005): <em>SSA-based approaches to
analysis and forecast of multidimensional time series</em>. In
Proceedings of the 5th St.Petersburg Workshop on Simulation, June
26-July 2, 2005, St. Petersburg State University, St. Petersburg,
293&ndash;298. <a href="https://www.gistatgroup.com/gus/mssa2.pdf">https://www.gistatgroup.com/gus/mssa2.pdf</a>
</p>
<p>Golyandina, N. and Usevich, K. (2009): <em>2D-extensions of singular
spectrum analysis: algorithm and elements of theory.</em> In Matrix
Methods: Theory, Algorithms, Applications. World Scientific
Publishing, 450-474.
</p>
<p>Korobeynikov, A. (2010): <em>Computation- and space-efficient
implementation of SSA.</em> Statistics and Its Interface, Vol. 3, No. 3,
Pp. 257-268
</p>
<p>Golyandina, N., Korobeynikov, A. (2012, 2014): <em>Basic Singular Spectrum
Analysis and Forecasting with R.</em> Computational Statistics and Data
Analysis, Vol. 71, Pp. 934-954. <a href="https://arxiv.org/abs/1206.6910">https://arxiv.org/abs/1206.6910</a>
</p>
<p>Golyandina, N., Zhigljavsky, A. (2013): <em>Singular Spectrum
Analysis for time series</em>. Springer Briefs in Statistics. Springer.
</p>
<p>Shlemov, A. and Golyandina, N. (2014): <em>Shaped extensions of singular
spectrum analysis</em>. 21st International Symposium on Mathematical 
Theory of Networks and Systems, July 7-11, 2014. Groningen, 
The Netherlands. p.1813-1820. <a href="https://arxiv.org/abs/1507.05286">https://arxiv.org/abs/1507.05286</a>
</p>
<p>Golyandina, N., Korobeynikov, A., Shlemov, A. and Usevich, K. (2015):
<em>Multivariate and 2D Extensions of Singular Spectrum Analysis
with the Rssa Package</em>. Journal of Statistical Software, Vol. 67, Issue 2.
<a href="https://doi.org/10.18637/jss.v067.i02">doi:10.18637/jss.v067.i02</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+ssa-input">ssa-input</a></code>,
<code><a href="#topic+ssa">ssa</a></code>, <code><a href="#topic+decompose.ssa">decompose</a></code>,
<code><a href="#topic+reconstruct.ssa">reconstruct</a></code>,
<code><a href="#topic+wcor">wcor</a></code>, <code><a href="#topic+plot.ssa">plot</a></code>,
<code><a href="#topic+parestimate">parestimate</a></code>,
<code><a href="#topic+rforecast.ssa">rforecast</a></code>,
<code><a href="#topic+vforecast.ssa">vforecast</a></code>,
<code><a href="#topic+forecast.ssa">forecast</a></code>,
<code><a href="#topic+iossa">iossa</a></code>,
<code><a href="#topic+fossa">fossa</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>s &lt;- ssa(co2) # Perform the decomposition using the default window length
summary(s)        # Show various information about the decomposition
plot(s)           # Show the plot of the eigenvalues
r &lt;- reconstruct(s, groups = list(Trend = c(1, 4),
                                  Seasonality = c(2:3, 5:6))) # Reconstruct into 2 series
plot(r, add.original = TRUE)  # Plot the reconstruction

# Simultaneous trend extraction using MSSA

s &lt;- ssa(EuStockMarkets, kind = "mssa")
r &lt;- reconstruct(s, groups = list(Trend = c(1,2)))
plot(r, plot.method = "xyplot", add.residuals = FALSE,
     superpose = TRUE, auto.key = list(columns = 2))
# Trend forecast
f &lt;- rforecast(s, groups = list(Trend = c(1, 2)),
               len = 50, only.new = FALSE)
library(lattice)
xyplot(ts.union(Original = EuStockMarkets, "Recurrent Forecast" = f),
       superpose = TRUE, auto.key = list(columns = 2))

</code></pre>

<hr>
<h2 id='AustralianWine'>Australian Wine Sales</h2><span id='topic+AustralianWine'></span>

<h3>Description</h3>

<p>Monthly Australian wine sales in thousands of litres from Jan 1980 till Jul 1995.
By wine makers in bottles of less than or equal to 1 litre.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(AustralianWine)</code></pre>


<h3>Format</h3>

<p>A multivariate time series with 187 observations on 7
variables. The object is of class 'mts'.</p>


<h3>Source</h3>

<p>Hyndman, R.J. Time Series Data Library, http://data.is/TSDLdemo.
</p>

<hr>
<h2 id='Barbara'>Classical &lsquo;Barbara&rsquo; image (color, wide)</h2><span id='topic+Barbara'></span>

<h3>Description</h3>

<p>Classical &lsquo;Barbara&rsquo; image (wide version).
720 x 576 x 3 (color, RGB model), from 0 to 255.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(Barbara)</code></pre>


<h3>Format</h3>

<p>An integer array of dimension 3.</p>


<h3>Source</h3>

<p><a href="https://www.hlevkin.com/hlevkin/06testimages.htm">https://www.hlevkin.com/hlevkin/06testimages.htm</a>
</p>

<hr>
<h2 id='bforecast'>Perform bootstrap SSA forecasting of the series</h2><span id='topic+bforecast'></span><span id='topic+bforecast.default'></span><span id='topic+bforecast.ssa'></span><span id='topic+bforecast.1d.ssa'></span><span id='topic+bforecast.toeplitz.ssa'></span>

<h3>Description</h3>

<p>Perform bootstrap SSA forecasting of the one-dimensional series.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class '1d.ssa'
bforecast(x, groups, len = 1, R = 100, level = 0.95,
          type = c("recurrent", "vector"),
          interval = c("confidence", "prediction"),
          only.new = TRUE,
          only.intervals = FALSE, ...,
          drop = TRUE, drop.attributes = FALSE, cache = TRUE)
## S3 method for class 'toeplitz.ssa'
bforecast(x, groups, len = 1, R = 100, level = 0.95,
          type = c("recurrent", "vector"),
          interval = c("confidence", "prediction"),
          only.new = TRUE,
          only.intervals = FALSE, ...,
          drop = TRUE, drop.attributes = FALSE, cache = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="bforecast_+3A_x">x</code></td>
<td>
<p>SSA object holding the decomposition</p>
</td></tr>
<tr><td><code id="bforecast_+3A_groups">groups</code></td>
<td>
<p>list, the grouping of eigentriples to be used in the forecast</p>
</td></tr>
<tr><td><code id="bforecast_+3A_len">len</code></td>
<td>
<p>the desired length of the forecasted series</p>
</td></tr>
<tr><td><code id="bforecast_+3A_r">R</code></td>
<td>
<p>number of bootstrap replications</p>
</td></tr>
<tr><td><code id="bforecast_+3A_level">level</code></td>
<td>
<p>vector of confidence levels for bounds</p>
</td></tr>
<tr><td><code id="bforecast_+3A_type">type</code></td>
<td>
<p>the type of forecast method to be used during
bootstrapping</p>
</td></tr>
<tr><td><code id="bforecast_+3A_interval">interval</code></td>
<td>
<p>type of interval calculation</p>
</td></tr>
<tr><td><code id="bforecast_+3A_only.new">only.new</code></td>
<td>
<p>logical, if 'FALSE' then confidence bounds for the
signal as well as prediction are reported</p>
</td></tr>
<tr><td><code id="bforecast_+3A_only.intervals">only.intervals</code></td>
<td>
<p>logical, if 'TRUE' then bootstrap method is used
for confidence bounds only, otherwise &mdash; mean bootstrap forecast is
returned as well</p>
</td></tr>
<tr><td><code id="bforecast_+3A_...">...</code></td>
<td>
<p>additional arguments passed to forecasting routines</p>
</td></tr>
<tr><td><code id="bforecast_+3A_drop">drop</code></td>
<td>
<p>logical, if 'TRUE' then the result is coerced to series
itself, when possible (length of 'groups' is one)</p>
</td></tr>
<tr><td><code id="bforecast_+3A_drop.attributes">drop.attributes</code></td>
<td>
<p>logical, if 'TRUE' then the attributes of the input series
are not copied to the reconstructed ones</p>
</td></tr>
<tr><td><code id="bforecast_+3A_cache">cache</code></td>
<td>
<p>logical, if 'TRUE' then intermediate results will be
cached in the SSA object</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The routine uses the reconstruction residuals in order to calculate
their empirical distribution (the residuals are assumed to be
stationary). Empirical distribution of the residuals is used to
perform bootstrap series simulation. Such bootsrapped series are then
extended via selected forecast method. Finally, the distribution of
forecasted values is used to calculate bootstrap estimate of series
forecast and confidence bounds.
</p>
<p>See Section 3.2.1.5 from Golyandina et al (2018) for details.
</p>


<h3>Value</h3>

<p>List of matricies. Each matrix has 1 + 2*length(level) columns and
'len' rows. First column contains the forecasted values, remaining
columns &mdash; low and upper bootstrap confidence bounds for average
forecasted values.
</p>
<p>The matrix itself, if length of groups is one and 'drop = TRUE'.
</p>


<h3>References</h3>

<p>Golyandina N., Korobeynikov A., Zhigljavsky A. (2018):
<em>Singular Spectrum Analysis with R.</em>  Use R!.
Springer, Berlin, Heidelberg.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+Rssa">Rssa</a></code> for an overview of the package, as well as,
<code><a href="#topic+rforecast">rforecast</a></code>,
<code><a href="#topic+vforecast">vforecast</a></code>,
<code><a href="#topic+forecast">forecast</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Decompose 'co2' series with default parameters
s &lt;- ssa(co2)
# Produce 24 forecasted values and confidence bounds of the series using
# the first 3 eigentriples as a base space for the forecast.

f &lt;- bforecast(s, groups = list(1:3), len = 24, R = 50)
matplot(f, col = c("black", "red", "red"), type='l')
</code></pre>

<hr>
<h2 id='cadzow'>
Cadzow Iterations
</h2><span id='topic+cadzow'></span><span id='topic+cadzow.ssa'></span>

<h3>Description</h3>

<p>Perform the finite rank approximation of the series via Cadzow iterations
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'ssa'
cadzow(x, rank, correct = TRUE, tol = 1e-6, maxiter = 0,
         norm = function(x) max(abs(x)),
         trace = FALSE, ..., cache = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="cadzow_+3A_x">x</code></td>
<td>
<p>input SSA object</p>
</td></tr>
<tr><td><code id="cadzow_+3A_rank">rank</code></td>
<td>
<p>desired rank of approximation</p>
</td></tr>
<tr><td><code id="cadzow_+3A_correct">correct</code></td>
<td>
<p>logical, if 'TRUE' then additional correction as in
Gillard et al (2013) is performed</p>
</td></tr>
<tr><td><code id="cadzow_+3A_tol">tol</code></td>
<td>
<p>tolerance value used for convergence criteria</p>
</td></tr>
<tr><td><code id="cadzow_+3A_maxiter">maxiter</code></td>
<td>
<p>number of iterations to perform, if zero then
iterations are performed until the convergence</p>
</td></tr>
<tr><td><code id="cadzow_+3A_norm">norm</code></td>
<td>
<p>distance function used for covergence criterion</p>
</td></tr>
<tr><td><code id="cadzow_+3A_trace">trace</code></td>
<td>
<p>logical, indicates whether the convergence process should be traced</p>
</td></tr>
<tr><td><code id="cadzow_+3A_...">...</code></td>
<td>
<p>further arguments passed to <code>reconstruct</code></p>
</td></tr>
<tr><td><code id="cadzow_+3A_cache">cache</code></td>
<td>
<p>logical, if 'TRUE' then intermediate results will be
cached in the SSA object.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Cadzow iterations aim to solve the problem of the approximation of the
input series by a series of finite rank. The idea of the algorithm is
quite simple: alternating projections of the trajectory matrix to
Hankel and low-rank matrices are performed which hopefully converge to
a Hankel low-rank matrix. See Algorithm 3.10 in Golyandina et al (2018).
</p>
<p>Note that the results of one Cadzow iteration with no correction
coincides with the result of reconstruction by the leading <code>rank</code>
components.
</p>
<p>Unfortunately, being simple, the method often yields the solution which is
far away from the optimum.
</p>


<h3>References</h3>

<p>Golyandina N., Korobeynikov A., Zhigljavsky A. (2018):
<em>Singular Spectrum Analysis with R.</em>  Use R!.
Springer, Berlin, Heidelberg.
</p>
<p>Cadzow J. A. (1988) Signal enhancement a composite property mapping algorithm,
IEEE Transactions on Acoustics, Speech, and Signal Processing, 36,
49-62.
</p>
<p>Gillard, J. and Zhigljavsky, A. (2013) Stochastic optimization
algorithms for Hankel structured low-rank approximation. Unpublished
Manuscript. Cardiff School of Mathematics. Cardiff.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+Rssa">Rssa</a></code> for an overview of the package, as well as,
<code><a href="#topic+reconstruct">reconstruct</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Decompose co2 series with default parameters
s &lt;- ssa(co2)
# Now make rank 3 approximation using the Cadzow iterations
F &lt;- cadzow(s, rank = 3, tol = 1e-10)
library(lattice)
xyplot(cbind(Original = co2, Cadzow = F), superpose = TRUE)
# All but the first 3 eigenvalues are close to 0
plot(ssa(F))

# Compare with SSA reconstruction
F &lt;- cadzow(s, rank = 3, maxiter = 1, correct = FALSE)
Fr &lt;- reconstruct(s, groups = list(1:3))$F1
print(max(abs(F - Fr)))

# Cadzow with and without weights
set.seed(3)
N &lt;- 60
L &lt;- 30
K &lt;- N - L + 1
alpha &lt;- 0.1

sigma &lt;- 0.1
signal &lt;- cos(2*pi * seq_len(N) / 10)
x &lt;- signal + rnorm(N, sd = sigma)

weights &lt;- rep(alpha, K)
weights[seq(1, K, L)] &lt;- 1
salpha &lt;- ssa(x, L = L,
              column.oblique = "identity",
              row.oblique = weights)
calpha &lt;- cadzow(salpha, rank = 2)

cz &lt;- cadzow(ssa(x, L = L), rank = 2)

print(mean((cz - signal)^2))
print(mean((calpha - signal)^2))
</code></pre>

<hr>
<h2 id='calc.v'>Calculate Factor Vector(s)</h2><span id='topic+calc.v'></span><span id='topic+calc.v.ssa'></span><span id='topic+calc.v.cssa'></span>

<h3>Description</h3>

<p>Generic function for the factor vector calculation given the SSA
decomposition.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'ssa'
calc.v(x, idx, ...)
## S3 method for class 'cssa'
calc.v(x, idx, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="calc.v_+3A_x">x</code></td>
<td>
<p>SSA object holding the decomposition.</p>
</td></tr>
<tr><td><code id="calc.v_+3A_idx">idx</code></td>
<td>
<p>indices of the factor vectors to compute.</p>
</td></tr>
<tr><td><code id="calc.v_+3A_...">...</code></td>
<td>
<p>additional arguments to 'calc.v'.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Factor vector is a column of the factor matrix V, which is calculated
as follows:
</p>
<p style="text-align: center;"><code class="reqn">%
    V = \Sigma^{-1} X^{T} U,
  </code>
</p>

<p>where X is a Hankel trajectory matrix, U is the matrix of eigenvectors
and Sigma is a matrix of singular values.
</p>


<h3>Value</h3>

<p>A numeric vector of suitable length (usually depends on SSA method
and window length).
</p>


<h3>See Also</h3>

<p><code><a href="#topic+Rssa">Rssa</a></code> for an overview of the package, as well as,
<code><a href="#topic+ssa-object">ssa-object</a></code>,
<code><a href="#topic+ssa">ssa</a></code>,
<code><a href="#topic+decompose.ssa">decompose</a></code>,
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Decompose 'co2' series with default parameters
s &lt;- ssa(co2)
# Calculate the 5th factor vector
v &lt;- calc.v(s, 5)
</code></pre>

<hr>
<h2 id='cleanup'>
Cleanup of all cached data from SSA objects
</h2><span id='topic+cleanup'></span><span id='topic+cleanup.ssa'></span>

<h3>Description</h3>

<p>Function to copy SSA objects
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cleanup(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="cleanup_+3A_x">x</code></td>
<td>
<p>object to be cleaned</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For the sake of memory efficiency SSA objects hold references to the
data, not the data itself. That is why they can hold huge amount of
data and passing them by value is still cheap.
</p>
<p>Also, SSA routines tend to save some intermediate information which
can be used later inside SSA object. This includes (but not limited
to) elementary series, etc.
</p>
<p><code>cleanup</code> call deletes all pre-cached stuff freeing memory necessary
for calculations.
</p>

<hr>
<h2 id='clone'>
Cloning of SSA objects
</h2><span id='topic+clone'></span><span id='topic+clone.ssa'></span>

<h3>Description</h3>

<p>Function to copy SSA objects
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'ssa'
clone(x, copy.storage = TRUE, copy.cache = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="clone_+3A_x">x</code></td>
<td>
<p>object to be cloned</p>
</td></tr>
<tr><td><code id="clone_+3A_copy.storage">copy.storage</code></td>
<td>
<p>enable/disable copying of the internal storage</p>
</td></tr>
<tr><td><code id="clone_+3A_copy.cache">copy.cache</code></td>
<td>
<p>enable/disable copying of the set of pre-cached
elementary series</p>
</td></tr>
<tr><td><code id="clone_+3A_...">...</code></td>
<td>
<p>additional arguments to <code>clone</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>For the sake of memory efficiency SSA objects hold references to the
data, not the data itself. That is why they can hold huge amount of
data and passing them by value is still cheap.
</p>
<p>However, this means that one cannot safely copy the object using
normal assignment operator, since freeing of references in one object
would yield stale references in another. The <code>clone</code> method provides
safe &lsquo;deep copy&rsquo; of SSA objects.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Decompose 'co2' series with default parameters
s &lt;- ssa(co2);
# Perform 'normal copy' of SSA object
s1 &lt;- s;
# Perform 'deep copy' of SSA object
s2 &lt;- clone(s);
# Add some data to 's'
reconstruct(s);
# Now 's1' also contains this data, but 's2' - not
summary(s1);
summary(s2);
</code></pre>

<hr>
<h2 id='clplot'>
Ratio of complete lag vectors in dependence on window length
</h2><span id='topic+clplot'></span>

<h3>Description</h3>

<p>Function to plot the dependence of ratios of complete lagged vectors on window lengths.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>clplot(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="clplot_+3A_x">x</code></td>
<td>
<p>input series</p>
</td></tr>
<tr><td><code id="clplot_+3A_...">...</code></td>
<td>
<p>further arguments passed to plotting functions</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function plots the dependence of ratios of complete lagged vectors on window lengths.
This information can be used for the choice of window length, since only complete lagged vectors
are used for construction of the SVD expansion in SSA. See page 89 (Chapter 2) in Golyandina et al (2018).
</p>


<h3>References</h3>

<p>Golyandina N., Korobeynikov A., Zhigljavsky A. (2018):
<em>Singular Spectrum Analysis with R.</em>  Use R!.
Springer, Berlin, Heidelberg.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+Rssa">Rssa</a></code> for an overview of the package, as well as,
<code><a href="#topic+igapfill">igapfill</a></code>,
<code><a href="#topic+gapfill">gapfill</a></code>
<code><a href="#topic+summarize.gaps">summarize.gaps</a></code>,
</p>

<hr>
<h2 id='decompose'>Perform SSA Decomposition</h2><span id='topic+decompose'></span><span id='topic+decompose.default'></span><span id='topic+decompose.ssa'></span><span id='topic+decompose.cssa'></span><span id='topic+decompose.toeplitz.ssa'></span>

<h3>Description</h3>

<p>Performs the SSA decomposition.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'ssa'
decompose(x, neig = NULL, ..., force.continue = FALSE)
## S3 method for class 'toeplitz.ssa'
decompose(x, neig = NULL, ..., force.continue = FALSE)
## S3 method for class 'cssa'
decompose(x, neig = NULL, ..., force.continue = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="decompose_+3A_x">x</code></td>
<td>
<p>SSA object holding the decomposition.</p>
</td></tr>
<tr><td><code id="decompose_+3A_neig">neig</code></td>
<td>
<p>number of desired eigentriples or 'NULL' for default value (minimum from 50 and trajectory space dimension).</p>
</td></tr>
<tr><td><code id="decompose_+3A_...">...</code></td>
<td>
<p>additional arguments passed to SVD routines.</p>
</td></tr>
<tr><td><code id="decompose_+3A_force.continue">force.continue</code></td>
<td>
<p>logical, if TRUE then continuation of the decomposition is explicitly requested</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This is the main function which does the decomposition of the SSA
trajectory matrix. Depending on the SVD method selected in the
<code><a href="#topic+ssa">ssa</a></code> different SVD implementations are called. This
might be the ordinary full SVD routines or fast methods which exploit
the Hankel / Toeplitz / Hankel with Hankel blocks matrix structure and
allow the calculation of first few eigentriples.
</p>
<p>Some SVD methods support continuation of the decomposition: if the
'ssa' object already holds some decomposition and more eigentriples
are requested, then the decomposition continues using the current
values as a starting point reducing the computation time dramatically.
</p>


<h3>Value</h3>

<p>The SSA object.
</p>


<h3>Note</h3>

<p>Usually there is no need to call this function directly. Call to
<code><a href="#topic+ssa">ssa</a></code> does the decomposition in the end. Other functions
do the decomposition when necessary.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+Rssa">Rssa</a></code> for an overview of the package, as well as,
<code><a href="svd.html#topic+svd">svd</a></code>, <code><a href="#topic+ssa">ssa</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Decompose 'co2' series with default parameters and decomposition turned off.
s &lt;- ssa(co2, force.decompose = FALSE, svd.method = "nutrlan")
# Perform the decomposition
decompose(s, neig = 50)
# Continue the decomposition
decompose(s, neig = 100)
</code></pre>

<hr>
<h2 id='eossa'>ESPRIT-based O-SSA nested decomposition</h2><span id='topic+eossa'></span><span id='topic+eossa.ssa'></span>

<h3>Description</h3>

<p>Perform ESPRIT-based O-SSA (EOSSA) algorithm.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'ssa'
eossa(x, nested.groups, k = 2,
      subspace = c("column", "row"),
      dimensions = NULL,
      solve.method = c("ls", "tls"),
      beta = 8,
      ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="eossa_+3A_x">x</code></td>
<td>
<p>SSA object holding SSA decomposition</p>
</td></tr>
<tr><td><code id="eossa_+3A_nested.groups">nested.groups</code></td>
<td>
<p>list or named list of numbers of eigentriples
from full decomposition, describes elementary components for EOSSA nested redecomposition</p>
</td></tr>
<tr><td><code id="eossa_+3A_k">k</code></td>
<td>
<p>the number of components in desired resultant decomposition</p>
</td></tr>
<tr><td><code id="eossa_+3A_subspace">subspace</code></td>
<td>
<p>which subspace will be used for oblique matrix construction</p>
</td></tr>
<tr><td><code id="eossa_+3A_dimensions">dimensions</code></td>
<td>
<p>a vector of dimension indices to construct shift matrices along. 'NULL' means all dimensions</p>
</td></tr>
<tr><td><code id="eossa_+3A_solve.method">solve.method</code></td>
<td>
<p>approximate matrix equation solving method, 'ls' for least-squares, 'tls' for total-least-squares.</p>
</td></tr>
<tr><td><code id="eossa_+3A_beta">beta</code></td>
<td>
<p>In multidimensional (nD) case, coefficient(s) in convex linear combination of
shifted matrices. The length of <code>beta</code> should be <code>ndim - 1</code>,
where <code>ndim</code> is the number of independent dimensions.
If only one value is passed, it is expanded to a geometric progression.</p>
</td></tr>
<tr><td><code id="eossa_+3A_...">...</code></td>
<td>
<p>additional arguments passed to <code><a href="#topic+decompose">decompose</a></code>
routines</p>
</td></tr>
</table>


<h3>Details</h3>

<p>EOSSA is an experimental signal separation method working in Nested Oblique SSA setting.
As opposed to <code><a href="#topic+iossa">iossa</a></code>,
this method does not require initial approximate decomposition.
Moreover, it can be used for initial decomposition construction for IOSSA.
</p>
<p>EOSSA is motivated by parametric model of finite-dimensional signal,
however it does not exploit this model directly and does not estimate the parameters.
Therefore, it works for wider class of time series.
According to the experiments, it works for series that could be locally
approximated by a series of finite dimension, but at this moment there is no any theoretical results for this.
</p>
<p>EOSSA constructs shift matrix estimation by the same way is in ESPRIT
(see <code><a href="#topic+parestimate">parestimate</a></code>) method and
uses its eigenspace to build separating scalar products
(see <code><a href="#topic+iossa">iossa</a></code> for more information about Oblique SSA decompositions).
Consequently, the method ideally separates signals of finite dimension with absence of noise.
With presence of noise it provides approximate results due to continuity.
The method performs eigenvectors clustering inside (for now <code><a href="stats.html#topic+hclust">hclust</a></code> is used),
the number of components (argument <code>k</code>) should be passed.
</p>


<h3>Value</h3>

<p>Object of &lsquo;ossa&rsquo; class.
</p>


<h3>References</h3>

<p>Shlemov A. (2017): <em>The method of signal separation using the eigenspaces of the shift matrices (in Russian)</em>,
In Proceedings of the SPISOK-2017 conference, April 26&ndash;28, Saint Petersburg, Russia.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+Rssa">Rssa</a></code> for an overview of the package, as well as,
<code><a href="#topic+ssa-object">ssa-object</a></code>,
<code><a href="#topic+parestimate">ESPRIT</a></code>,
<code><a href="#topic+iossa">iossa</a></code>,
<code><a href="#topic+fossa">fossa</a></code>,
<code><a href="#topic+owcor">owcor</a></code>,
<code><a href="#topic+iossa.result">iossa.result</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Separability of three finite-dimensional series, EOSSA vs Basic SSA
N &lt;- 150
L &lt;- 70
omega1 &lt;- 0.065
omega2 &lt;- 0.07
omega3 &lt;- 0.02
sigma &lt;- 0.5

F1.real &lt;- 2*sin(2*pi*omega1*(1:N))
F2.real &lt;- 4*sin(2*pi*omega2*(1:N))
F3.real &lt;- sin(2*pi*omega3*(1:N))

noise &lt;- rnorm(N, sd = sigma)
F &lt;- F1.real + F2.real + F3.real + noise

ss &lt;- ssa(F, L)
eoss &lt;- eossa(ss, nested.groups = list(1:2, 3:4, 5:6), k = 3)

print(eoss)

plot(ss, type = "series", groups = list(1:2, 3:4, 5:6))
plot(eoss, type = "series", groups = eoss$iossa.groups)

plot(reconstruct(ss,
                 groups = list(1:2, 3:4, 5:6)),
     add.residuals = TRUE, plot.method = "xyplot", main = "",
     xlab = "")

plot(reconstruct(eoss, groups = list(1:2, 3:4, 5:6)),
     add.residuals = TRUE, plot.method = "xyplot", main = "",
     xlab = "")

plot(reconstruct(ss,
                 groups = list(Reconstructed = 1:6, F1 = 1:2, F2 = 3:4, F3 = 5:6)),
     add.residuals = TRUE, plot.method = "xyplot", main = "",
     xlab = "")

plot(reconstruct(eoss,
                 groups = list(Reconstructed = 1:6, F1 = 1:2, F2 = 3:4, F3 = 5:6)),
     add.residuals = TRUE, plot.method = "xyplot", main = "",
     xlab = "")

rec.ideal &lt;- reconstruct(ss,
                         groups = list(Signal = 1:6, F1 = 1:2, F2 = 3:4, F3 = 5:6))
rec.ideal$Signal &lt;- F1.real + F2.real + F3.real
rec.ideal$F1 &lt;- F2.real
rec.ideal$F2 &lt;- F1.real
rec.ideal$F3 &lt;- F3.real

plot(rec.ideal,
     add.residuals = TRUE, plot.method = "xyplot", main = "",
     xlab = "")

# Real-life example (co2), EOSSA vs Basic SSA
sigma &lt;- 0.05 
ss &lt;- ssa(co2)
plot(ss, type = "vector")
eoss &lt;- eossa(ss, 1:6, k = 4)
eoss$iossa.groups

plot(eoss)
rec &lt;- reconstruct(eoss, groups = eoss$iossa.groups)
plot(rec)

plot(reconstruct(ss,
                 groups = list(ET1 = 1,ET2 = 2,ET3 = 3,ET4 = 4,ET5 = 5,ET6 = 6)),
     add.residuals = TRUE, plot.method = "xyplot", main = "",
     xlab = "")

plot(reconstruct(eoss,
                 groups = eoss$iossa.groups),
     add.residuals = TRUE, plot.method = "xyplot", main = "",
     xlab = "")

# Sine wave with phase shift, EOSSA vs Basic SSA
omega1 &lt;- 0.06
omega2 &lt;- 0.07
sigma &lt;- 0.25

F1.real &lt;- sin(2*pi*omega1*(1:N))
F2.real &lt;- sin(2*pi*omega2*(1:N))
v &lt;- c(F1.real,  F2.real)
v &lt;- v + rnorm(v, sd = sigma)
# v &lt;- c(F1.real,  F2.real)

ss &lt;- ssa(v, L = 35)

eoss &lt;- eossa(ss, 1:4, 2)
ioss &lt;- iossa(ss, list(1:2, 3:4))

plot(reconstruct(eoss, groups = eoss$iossa.groups))

plot(reconstruct(eoss,
     groups = eoss$iossa.groups), plot.method = "xyplot", main = "",
     xlab = "")

plot(reconstruct(ss, groups = list(1:2, 3:4)),
     plot.method = "xyplot",
     main = "", xlab = "")
plot(reconstruct(ss, groups = list(1,2, 3,4)),
     plot.method = "xyplot",
     main = "", xlab = "")
</code></pre>

<hr>
<h2 id='forecast'>Perform SSA forecasting of series</h2><span id='topic+forecast.ssa'></span><span id='topic+forecast.1d.ssa'></span><span id='topic+forecast.toeplitz.ssa'></span><span id='topic+predict.ssa'></span><span id='topic+predict.1d.ssa'></span><span id='topic+predict.mssa'></span><span id='topic+predict.toeplitz.ssa'></span>

<h3>Description</h3>

<p>All-in-one function to perform SSA forecasting of one-dimensional series.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class '1d.ssa'
forecast(object,
         groups, h = 1,
         method = c("recurrent", "vector"),
         interval = c("none", "confidence", "prediction"),
         only.intervals = TRUE,
         ...,
         drop = TRUE, drop.attributes = FALSE, cache = TRUE)
## S3 method for class 'toeplitz.ssa'
forecast(object,
         groups, h = 1,
         method = c("recurrent", "vector"),
         interval = c("none", "confidence", "prediction"),
         only.intervals = TRUE,
         ...,
         drop = TRUE, drop.attributes = FALSE, cache = TRUE)
## S3 method for class '1d.ssa'
predict(object,
        groups, len = 1,
        method = c("recurrent", "vector"),
        interval = c("none", "confidence", "prediction"),
        only.intervals = TRUE,
        ...,
        drop = TRUE, drop.attributes = FALSE, cache = TRUE)
## S3 method for class 'toeplitz.ssa'
predict(object,
        groups, len = 1,
        method = c("recurrent", "vector"),
        interval = c("none", "confidence", "prediction"),
        only.intervals = TRUE,
        ...,
        drop = TRUE, drop.attributes = FALSE, cache = TRUE)
## S3 method for class 'mssa'
predict(object,
        groups, len = 1,
        method = c("recurrent", "vector"),
        direction = c("column", "row"),
        ...,
        drop = TRUE, drop.attributes = FALSE, cache = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="forecast_+3A_object">object</code></td>
<td>
<p>SSA object holding the decomposition</p>
</td></tr>
<tr><td><code id="forecast_+3A_groups">groups</code></td>
<td>
<p>list, the grouping of eigentriples to be used in the forecast</p>
</td></tr>
<tr><td><code id="forecast_+3A_h">h</code>, <code id="forecast_+3A_len">len</code></td>
<td>
<p>the desired length of the forecasted series</p>
</td></tr>
<tr><td><code id="forecast_+3A_method">method</code></td>
<td>
<p>method of forecasting to be used</p>
</td></tr>
<tr><td><code id="forecast_+3A_interval">interval</code></td>
<td>
<p>type of interval calculation</p>
</td></tr>
<tr><td><code id="forecast_+3A_only.intervals">only.intervals</code></td>
<td>
<p>logical, if 'TRUE' then bootstrap method is used
for confidence bounds only, otherwise &mdash; mean bootstrap forecast is
returned as well</p>
</td></tr>
<tr><td><code id="forecast_+3A_direction">direction</code></td>
<td>
<p>direction of forecast in multichannel SSA case, &quot;column&quot;
stands for so-called L-forecast and &quot;row&quot; stands for K-forecast</p>
</td></tr>
<tr><td><code id="forecast_+3A_...">...</code></td>
<td>
<p>further arguments passed for forecast routines
(e.g. <code>level</code> argument to <code>bforecast</code>)</p>
</td></tr>
<tr><td><code id="forecast_+3A_drop">drop</code></td>
<td>
<p>logical, if 'TRUE' then the result is coerced to series
itself, when possible (length of 'groups' is one)</p>
</td></tr>
<tr><td><code id="forecast_+3A_drop.attributes">drop.attributes</code></td>
<td>
<p>logical, if 'TRUE' then the forecast routines do not try
to infer the time index arguments for the forecasted series.</p>
</td></tr>
<tr><td><code id="forecast_+3A_cache">cache</code></td>
<td>
<p>logical, if 'TRUE' then intermediate results will be
cached in the SSA object.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is a convenient wrapper over other forecast routines (see
'See Also') turning their value into object of type 'forecast' which
can be used with the routines from <span class="pkg">forecast</span> package.
</p>


<h3>Value</h3>

<p>object of class 'forecast' for <code>forecast</code> function call,
predicted series for <code>predict</code> call.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+Rssa">Rssa</a></code> for an overview of the package, as well as,
<code><a href="#topic+rforecast">rforecast</a></code>,
<code><a href="#topic+vforecast">vforecast</a></code>,
<code><a href="#topic+bforecast">bforecast</a></code>,
<code><a href="forecast.html#topic+forecast">forecast (package)</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>s &lt;- ssa(co2)
# Calculate 24-point forecast using first 6 components as a base
f &lt;- forecast(s, groups = list(1:6), method = "recurrent", bootstrap = TRUE, len = 24, R = 10)

# Plot the result including the last 24 points of the series
plot(f, include = 24, shadecols = "green", type = "l")
# Use of predict() for prediction
p &lt;- predict(s, groups = list(1:6), method = "recurrent", len = 24)
# Simple plotting
plot(p, ylab = "Forecasteed Values")

</code></pre>

<hr>
<h2 id='fossa'>Nested Filter-adjusted O-SSA decomposition</h2><span id='topic+fossa'></span><span id='topic+fossa.ssa'></span>

<h3>Description</h3>

<p>Perform nested decomposition by Filter-adjusted O-SSA (FOSSA).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  ## S3 method for class 'ssa'
fossa(x, nested.groups, filter = c(-1, 1), gamma = Inf, normalize = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="fossa_+3A_x">x</code></td>
<td>
<p>SSA object holding SSA decomposition</p>
</td></tr>
<tr><td><code id="fossa_+3A_nested.groups">nested.groups</code></td>
<td>
<p>vector of numbers of eigentriples from full decomposition
for nested decomposition. The argument is coerced to a vector, if
necessary</p>
</td></tr>
<tr><td><code id="fossa_+3A_filter">filter</code></td>
<td>
<p>numeric vector or array of reversed impulse response (IR)
coefficients for filter adjustment or list of such vectors or arrays</p>
</td></tr>
<tr><td><code id="fossa_+3A_gamma">gamma</code></td>
<td>
<p>weight of filter adjustment. See &lsquo;Details&rsquo; and &lsquo;References&rsquo;</p>
</td></tr>
<tr><td><code id="fossa_+3A_normalize">normalize</code></td>
<td>
<p>logical, whether to normalize left decomposition vectors before filtering</p>
</td></tr>
<tr><td><code id="fossa_+3A_...">...</code></td>
<td>
<p>additional arguments passed to <code><a href="#topic+decompose">decompose</a></code>
routines</p>
</td></tr>
</table>


<h3>Details</h3>

<p>See Golyandina N. and Shlemov A. (2015) and Section 2.5 in Golyanina et al (2018) 
for full details in the 1D case and 
p.250-252 from the same book for an example in the 2D case.
</p>
<p>Briefly, FOSSA serves for decomposition of series components that are
mixed due to equal contributions of their elementary components, e.g. of
sinusoids with equal amplitudes or of complex-form trend and
periodics. FOSSA performs a new decomposition of a part of the
ssa-object, which is given by a set of eigentriples. Note that
eigentriples that do not belong to the chosen set are not changed.
</p>
<p>In particular, Filter-adjusted O-SSA performs a nested decomposition
specified by a number of eigentriples via Oblique SSA with a specific
inner product in the row space:
</p>
<p style="text-align: center;"><code class="reqn">%
    \langle x, y \rangle = (x, y) + \gamma^2(\Phi(x), \Phi(y)),
  </code>
</p>

<p>where <code class="reqn">(\cdot, \cdot)</code> denotes conventional inner product and
'<code class="reqn">\Phi</code>' is linear filtration which is specified by <code>filter</code> argument.
</p>
<p>The default value of <code class="reqn">\Phi</code> corresponds to sequential
differences, that is, to derivation. Such version of Filter-adjusted
O-SSA is called &lsquo;DerivSSA&rsquo;. See &lsquo;References&rsquo; for more details.
</p>


<h4><code>filter</code> argument</h4>

<p>For 1D-SSA, Toeplitz-SSA and MSSA:
Filter can be given by a vector or a list of vectors. Each vector corresponds to reversed IR
for a filter, these filters are applied independently and their results are stacked such that the matrix
<code class="reqn">[X:\Phi_1(X):\Phi_2(X)]</code> is decomposed.
</p>
<p>For 2D-SSA: the following variants are possible: (1) a list of vectors.
Each vector corresponds to reversed IR for a filter. Each filter is
applied to different dimensions, the first to columns, the second to rows, and the results are stacked.
(2) single vector. Given vector corresponds to one-dimensional filter applied to both dimensions, the same as list of two equal vectors.
(3) a list of matrices, where each matrix provides 2d filter coefficients and the results are stacked.
(4) single matrix. Given matrix corresponds to two-dimensional filter applied once, the same as list of one matrix.
</p>
<p>For nD-SSA: the same as for 2D-SSA, a list of vectors for filters by directions, single vector,
a list of arrays (matroids) for nD filters or single array.
</p>



<h4>Normalization</h4>

<p>Let us explain for the 1D case.
Let <code class="reqn">X</code> be the reconstructed matrix, corresponding to the selected eigentriples
<code class="reqn">\{(\sigma_i,U_i,V_i)\}</code>, <code class="reqn">\Psi(X)</code> is the matrix, where the filter is applied to
each row of <code class="reqn">X</code>.
</p>
<p>Then <code>normalize = FALSE</code> (Algorithm 2.9 or 2.10 in Golyandina et al (2018)) corresponds 
to finding the basis in the column space of
<code class="reqn">X</code> by means of the SVD of <code class="reqn">[X, \Psi(X)]</code>, while
<code>normalize = TRUE</code> (by default, see Algorithm 2.11 in Golyandina et al (2018))
corresponds to finding the basis by the SVD of <code class="reqn">[V, \Phi(V)]</code>,
where the rows of
matrix <code class="reqn">V</code> are <code class="reqn">V_i</code>.
The value by default <code>TRUE</code> guaranties that the contributions
of sine waves will be ordered by decreasing of frequencies, although can
slightly worsen the weak separability</p>



<h3>Value</h3>

<p>Object of class &lsquo;ossa&rsquo;. The field &lsquo;ossa.set&rsquo; contains the vector of indices
of elementary components used in Filter-adjusted O-SSA (that is, used in <code>nested.groups</code>).
</p>


<h3>References</h3>

<p>Golyandina N., Korobeynikov A., Zhigljavsky A. (2018):
<em>Singular Spectrum Analysis with R.</em>  Use R!.
Springer, Berlin, Heidelberg.
</p>
<p>Golyandina N. and Shlemov A. (2015): <em>Variations of Singular Spectrum Analysis
for separability improvement: non-orthogonal decompositions of time series</em>, 
Statistics and Its Interface. Vol.8, No 3, P.277-294.
<a href="https://arxiv.org/abs/1308.4022">https://arxiv.org/abs/1308.4022</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+Rssa">Rssa</a></code> for an overview of the package, as well as,
<code><a href="#topic+iossa">iossa</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Separation of two mixed sine-waves with equal amplitudes
N &lt;- 150
L &lt;- 70
omega1 &lt;- 1/15
omega2 &lt;- 1/10

v &lt;- sin(2*pi*omega1 * (1:N)) + sin(2*pi*omega2 * (1:N))
s &lt;- ssa(v, L)
fs &lt;- fossa(s, nested.groups = 1:4, gamma = 100)

# Rssa does most of the plots via lattice
ws &lt;- plot(wcor(s, groups = 1:4))
wfs &lt;- plot(wcor(fs, groups = 1:4))
plot(ws, split = c(1, 1, 2, 1), more = TRUE)
plot(wfs, split = c(2, 1, 2, 1), more = FALSE)

opar &lt;- par(mfrow = c(2, 1))
plot(reconstruct(s, groups = list(1:2, 3:4)))
plot(reconstruct(fs, groups = list(1:2, 3:4)))
par(opar)

# Real-life example: Australian Wine Sales

data(AustralianWine)
s &lt;- ssa(AustralianWine[1:120, "Fortified"], L = 60)
fs &lt;- fossa(s, nested.groups = list(6:7, 8:9, 10:11), gamma = 10)

plot(reconstruct(fs, groups = list(6:7, 8:9, 10:11)))
plot(wcor(s, groups = 6:11))
plot(wcor(fs, groups = 6:11))

# Real life example: improving of strong separability
data(USUnemployment)
unempl.male &lt;- USUnemployment[, "MALE"]
s &lt;- ssa(unempl.male)
fs &lt;- fossa(s, nested.groups = 1:13, gamma = 1000)

# Comparison of reconstructions
rec &lt;- reconstruct(s, groups = list(c(1:4, 7:11), c(5:6, 12:13)))
frec &lt;- reconstruct(fs, groups &lt;- list(5:13, 1:4))
# Trends
matplot(data.frame(frec$F1, rec$F1, unempl.male), type= 'l',
        col=c("red","blue","black"), lty=c(1,1,2))
# Seasonalities
matplot(data.frame(frec$F2, rec$F2), type = 'l', col=c("red","blue"), lty=c(1,1))

# W-cor matrices before and after FOSSA
ws &lt;- plot(wcor(s, groups = 1:30), grid = 14)
wfs &lt;- plot(wcor(fs, groups = 1:30), grid = 14)
plot(ws, split = c(1, 1, 2, 1), more = TRUE)
plot(wfs, split = c(2, 1, 2, 1), more = FALSE)

# Eigenvectors before and after FOSSA
plot(s, type = "vectors", idx = 1:13)
plot(fs, type = "vectors", idx = 1:13)

# 2D plots of periodic eigenvectors before and after FOSSA
plot(s, type = "paired", idx = c(5, 12))
plot(fs, type = "paired", idx = c(1, 3))

# Compare FOSSA with and without normalize
N &lt;- 150
L &lt;- 70
omega1 &lt;- 1/15
omega2 &lt;- 1/10

v &lt;- 3*sin(2*pi*omega1 * (1:N)) + 2*sin(2*pi*omega2 * (1:N))
s &lt;- ssa(v, L)
fs &lt;- fossa(s, nested.groups = 1:4, gamma = 100)
fs.norm &lt;- fossa(s, nested.groups = 1:4, gamma = 100, normalize = TRUE)
opar &lt;- par(mfrow = c(2, 1))
plot(reconstruct(fs, groups = list(1:2, 3:4)))
plot(reconstruct(fs.norm, groups = list(1:2, 3:4)))
par(opar)

# 2D example
data(Mars)
s &lt;- ssa(Mars)
plot(s, "vectors", idx = 1:50)
plot(s, "series", idx = 1:50)
fs &lt;- fossa(s, nested.groups = 1:50, gamma = Inf)
plot(fs, "vectors", idx = 1:14)
plot(fs, "series", groups = 1:13)

# Filters example, extracting horizontal and vertical stripes
data(Mars)
s &lt;- ssa(Mars)
fs.hor &lt;- fossa(s, nested.groups = 1:50, gamma = Inf,
                filter = list(c(-1, 1), c(1)))
plot(fs.hor, "vectors", idx = 1:14)
plot(fs.hor, "series", groups = 1:13)
fs.ver &lt;- fossa(s, nested.groups = 1:50, gamma = Inf,
                filter = list(c(1), c(-1, 1)))
plot(fs.ver, "vectors", idx = 1:14)
plot(fs.ver, "series", groups = 1:13)

</code></pre>

<hr>
<h2 id='frobenius.cor'>Calculate Frobenius correlations of the component matrices</h2><span id='topic+frobenius.cor'></span>

<h3>Description</h3>

<p>Function calculates Frobenius correlations between grouped matrices
from the SSA matrix decomposition</p>


<h3>Usage</h3>

<pre><code class='language-R'>frobenius.cor(x, groups, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="frobenius.cor_+3A_x">x</code></td>
<td>
<p>input SSA object, supposed to be of class &lsquo;ossa&rsquo;</p>
</td></tr>
<tr><td><code id="frobenius.cor_+3A_groups">groups</code></td>
<td>
<p>list of numeric vectors, indices of elementary matrix components
in the SSA matrix decomposition</p>
</td></tr>
<tr><td><code id="frobenius.cor_+3A_...">...</code></td>
<td>
<p>further arguments passed to <code>decompose</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>Function computes matrix of Frobenius correlations between grouped matrices from the SSA matrix decomposition.
For group <code class="reqn">\mathcal{I} = \{i_1, \dots, i_s\}</code> the group matrix is defined as
<code class="reqn">\mathbf{X}_\mathcal{I} = \sum_{i \in \mathcal{I}} \sigma_i U_i V_i^\mathrm{T}</code>.
</p>
<p>Frobenius correlation of two matrices is defined as follows:
</p>
<p style="text-align: center;"><code class="reqn">%
    \mathrm{fcor}(\mathbf{Z}, \mathbf{Y}) =
      \frac{\langle \mathbf{Z}, \mathbf{Y} \rangle_\mathrm{F}}
           {\|\mathbf{Z}\|_\mathrm{F} \cdot \|\mathbf{Y}\|_\mathrm{F}}.
  </code>
</p>

<p>Frobenius correlation is a measure of Frobenius orthogonality of the components.
If grouped matrices are correlated then the w-correlations of the corresponding reconstructed series is not
relevant measure of separability (and one should use <code><a href="#topic+owcor">owcor</a></code> instead).
Also, if the elementary matrices <code class="reqn">\mathbf{X}_i = \sigma_i U_i V_i^\mathrm{T}</code>
of the decomposition are not F-orthogonal,
then <code class="reqn">\sigma_i</code> do not reflect their true contributions into the matrix decomposition.
</p>
<p>This function normally should be used only for object of class &lsquo;ossa&rsquo;.
Otherwise it always returns identical matrix (for disjoint groups).
</p>


<h3>Value</h3>

<p>Object of type 'wcor.matrix'.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+wcor">wcor</a></code>,
<code><a href="#topic+owcor">owcor</a></code>,
<code><a href="#topic+iossa">iossa</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Separation of two mixed sine-waves with equal amplitudes
N &lt;- 150
L &lt;- 70
omega1 &lt;- 1/5
omega2 &lt;- 1/10

v &lt;- sin(2*pi*omega1 * (1:N)) + sin(2*pi*omega2 * (1:N))
s &lt;- ssa(v, L)
fs &lt;- fossa(s, nested.groups = 1:4, gamma = 100)

# Decomposition is F-orthogonal
plot(frobenius.cor(fs, groups = 1:4), main = "F-correlation matrix")

plot(wcor(s, groups = 1:4))
plot(wcor(fs, groups = 1:4))


# Separate two non-separable sine series with different amplitudes

N &lt;- 150
L &lt;- 70

omega1 &lt;- 0.07
omega2 &lt;- 0.0675

F &lt;- 2*sin(2*pi*omega1 * (1:N)) + 2*sin(2*pi*omega2 * (1:N))
s &lt;- ssa(F, L)
ios &lt;- iossa(s, nested.groups = list(1:2, 3:4),
             kappa = NULL, maxiter = 1000, tol = 1e-5)

plot(reconstruct(ios, groups = ios$iossa.groups))
summary(ios)

# Decomposition is really oblique
plot(frobenius.cor(ios, groups = 1:4), main = "F-correlation matrix")

plot(wcor(ios, groups = 1:4))
plot(owcor(ios, groups = list(1:2, 3:4)), main = "Oblique W-correlation matrix")




data(USUnemployment)
unempl.male &lt;- USUnemployment[, "MALE"]

s &lt;- ssa(unempl.male)
ios &lt;- iossa(s, nested.groups = list(c(1:4, 7:11), c(5:6, 12:13)))
summary(ios)

# W-cor matrix before IOSSA and w-cor matrix after it
plot(wcor(s, groups = 1:30))
plot(wcor(ios, groups = 1:30))

# Confirmation of the indicated max value in the above warning
plot(frobenius.cor(ios, groups = 1:30), main = "F-correlation matrix")

</code></pre>

<hr>
<h2 id='gapfill'>Perform SSA gapfilling via forecast</h2><span id='topic+gapfill'></span><span id='topic+gapfill.1d.ssa'></span><span id='topic+gapfill.toeplitz.ssa'></span><span id='topic+gapfill.mssa'></span><span id='topic+gapfill.cssa'></span>

<h3>Description</h3>

<p>Perform SSA gapfilling of the series.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class '1d.ssa'
gapfill(x, groups, base = c("original", "reconstructed"),
        method = c("sequential", "simultaneous"),
        alpha = function(len) seq.int(0, 1, length.out = len), ...,
        drop = TRUE, drop.attributes = FALSE, cache = TRUE)
## S3 method for class 'mssa'
gapfill(x, groups, base = c("original", "reconstructed"),
        alpha = function(len) seq.int(0, 1, length.out = len), ...,
        drop = TRUE, drop.attributes = FALSE, cache = TRUE)
## S3 method for class 'cssa'
gapfill(x, groups, base = c("original", "reconstructed"),
        method = c("sequential", "simultaneous"),
        alpha = function(len) seq.int(0, 1, length.out = len), ...,
        drop = TRUE, drop.attributes = FALSE, cache = TRUE)
## S3 method for class 'toeplitz.ssa'
gapfill(x, groups, base = c("original", "reconstructed"),
        method = c("sequential", "simultaneous"),
        alpha = function(len) seq.int(0, 1, length.out = len), ...,
        drop = TRUE, drop.attributes = FALSE, cache = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="gapfill_+3A_x">x</code></td>
<td>
<p>Shaped SSA object holding the decomposition</p>
</td></tr>
<tr><td><code id="gapfill_+3A_groups">groups</code></td>
<td>
<p>list, the grouping of eigentriples to be used in the forecast</p>
</td></tr>
<tr><td><code id="gapfill_+3A_base">base</code></td>
<td>
<p>series used as a 'seed' for gapfilling: original or
reconstructed according to the value of <code>groups</code> argument</p>
</td></tr>
<tr><td><code id="gapfill_+3A_method">method</code></td>
<td>
<p>method used for gapfilling, &quot;sequential&quot; means to
filling by a recurrent forecast from complete parts; &quot;simultaneous&quot;
tries to build a projections onto the signal subspace. See
'References' for more info.</p>
</td></tr>
<tr><td><code id="gapfill_+3A_alpha">alpha</code></td>
<td>
<p>weight used for combining forecasts from left and right
when method = &quot;sequential&quot;; 0.5 means that the forecasts are averaged,
0 (1) means that only forecast from the left (right correspondingly)
is used, arbitrary function could be specified; by default linear
weights are used.</p>
</td></tr>
<tr><td><code id="gapfill_+3A_...">...</code></td>
<td>
<p>additional arguments passed to <code><a href="#topic+reconstruct">reconstruct</a></code>
routines</p>
</td></tr>
<tr><td><code id="gapfill_+3A_drop">drop</code></td>
<td>
<p>logical, if 'TRUE' then the result is coerced to series
itself, when possible (length of 'groups' is one)</p>
</td></tr>
<tr><td><code id="gapfill_+3A_drop.attributes">drop.attributes</code></td>
<td>
<p>logical, if 'TRUE' then the attributes of the input series
are not copied to the reconstructed ones.</p>
</td></tr>
<tr><td><code id="gapfill_+3A_cache">cache</code></td>
<td>
<p>logical, if 'TRUE' then intermediate results will be
cached in the SSA object.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function fills in the missed entries in the series. Both methods
described in Golyandina and Osipov (2007) are implemented:
</p>

<ul>
<li><p> method = &quot;sequential&quot; performs forecast from complete chunks
onto incomplete. For internal gaps forecast is performed from both
sides of the gap and average is taken in order to reduce the
forecast error. For gaps in the beginning or end of the series the
method coincides with ordinary recurrent forecast;
</p>
</li>
<li><p> method = &quot;simultaneous&quot; performs gap filling via projections
onto signal subspace. The method may fail if insufficient complete
observations are provided.
</p>
</li></ul>

<p>Details of the used algorithms see in Golyandina et al (2018), 
Algorithms 3.8 and 3.9 respectively.
</p>


<h3>Value</h3>

<p>List of objects with gaps filled in. Elements of the list have the
same names as elements of <code>groups</code>. If group is unnamed,
corresponding component gets name &lsquo;Fn&rsquo;, where &lsquo;n&rsquo; is its index in
<code>groups</code> list.
</p>
<p>Or, the forecasted object itself, if length of groups is one and 'drop = TRUE'.
</p>


<h3>References</h3>

<p>Golyandina N., Korobeynikov A., Zhigljavsky A. (2018):
<em>Singular Spectrum Analysis with R.</em>  Use R!.
Springer, Berlin, Heidelberg.
</p>
<p>N. Golyandina, E. Osipov (2007): <em>The &quot;Caterpillar&quot;-SSA method
for analysis of time series with missing values</em>. Journal of
Statistical Planning and Inference, Vol. 137, No. 8, Pp 2642&ndash;2653
<a href="https://www.gistatgroup.com/cat/mvssa1en.pdf">https://www.gistatgroup.com/cat/mvssa1en.pdf</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+Rssa">Rssa</a></code> for an overview of the package, as well as,
<code><a href="#topic+rforecast">rforecast</a></code>,
<code><a href="#topic+igapfill">igapfill</a></code>,
<code><a href="#topic+clplot">clplot</a></code>,
<code><a href="#topic+summarize.gaps">summarize.gaps</a></code>,
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Produce series with gaps
F &lt;- co2; F[100:200] &lt;- NA
# Perform shaped SSA
s &lt;- ssa(F, L = 72)
# Fill in gaps using the trend and 2 periodicty components
g &lt;- gapfill(s, groups = list(1:6))
# Compare the result
plot(g)
lines(co2, col = "red")
</code></pre>

<hr>
<h2 id='grouping.auto'>Group Elementary Series</h2><span id='topic+grouping.auto'></span>

<h3>Description</h3>

<p>The &lsquo;grouping.auto&rsquo; function performs the Grouping Step of
SSA using different approaches.</p>


<h3>Usage</h3>

<pre><code class='language-R'>grouping.auto(x, ..., grouping.method = c("pgram", "wcor"))
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="grouping.auto_+3A_x">x</code></td>
<td>
<p>SSA object</p>
</td></tr>
<tr><td><code id="grouping.auto_+3A_grouping.method">grouping.method</code></td>
<td>
<p>String specifying the method used to perform
the grouping. Allowed methods are &lsquo;&quot;pgram&quot;&rsquo; (the default) and
&lsquo;&quot;wcor&quot;&rsquo;</p>
</td></tr>
<tr><td><code id="grouping.auto_+3A_...">...</code></td>
<td>
<p>Further arguments to specific methods</p>
</td></tr>
</table>


<h3>Details</h3>

<p>&lsquo;grouping.auto&rsquo; is a wrapper function which calls the methods
&lsquo;grouping.auto.pgram&rsquo; and &lsquo;grouping.auto.wcor&rsquo;.
</p>


<h3>Value</h3>

<p>List of integer vectors holding the indices of the elementary components
forming each grouped objects.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+grouping.auto.pgram">grouping.auto.pgram</a></code>, <code><a href="#topic+grouping.auto.wcor">grouping.auto.wcor</a></code>
</p>

<hr>
<h2 id='grouping.auto.pgram'>
Group elementary series using periodogram
</h2><span id='topic+grouping.auto.pgram'></span><span id='topic+grouping.auto.pgram.ssa'></span><span id='topic+grouping.auto.pgram.toeplitz.ssa'></span><span id='topic+grouping.auto.pgram.1d.ssa'></span><span id='topic+plot.grouping.auto.pgram'></span>

<h3>Description</h3>

<p>Group elementary components automatically using their frequency contributions 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  ## S3 method for class '1d.ssa'
grouping.auto.pgram(x, groups,
             base = c("series", "eigen", "factor"),
             freq.bins = 2,
             threshold = 0,
             method = c("constant", "linear"),
             ...,
             drop = TRUE)
  ## S3 method for class 'grouping.auto.pgram'
plot(x, superpose, order, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="grouping.auto.pgram_+3A_x">x</code></td>
<td>
<p>SSA object</p>
</td></tr>
<tr><td><code id="grouping.auto.pgram_+3A_groups">groups</code></td>
<td>
<p>indices of elementary components for grouping</p>
</td></tr>
<tr><td><code id="grouping.auto.pgram_+3A_base">base</code></td>
<td>
<p>input for periodogram: elementary reconstructed series, eigenvectors or factor vectors</p>
</td></tr>
<tr><td><code id="grouping.auto.pgram_+3A_freq.bins">freq.bins</code></td>
<td>
<p>single integer number &gt; 1 (the number of intervals),
vector of frequency breaks (of length &gt;=2) or list of frequency ranges.
For each range, if only one element provided it will
be used as the upper bound and the lower bound will be zero</p>
</td></tr>
<tr><td><code id="grouping.auto.pgram_+3A_threshold">threshold</code></td>
<td>
<p>contribution threshold. If zero then dependent grouping approach will be used</p>
</td></tr>
<tr><td><code id="grouping.auto.pgram_+3A_method">method</code></td>
<td>
<p>method of periodogram interpolation</p>
</td></tr>
<tr><td><code id="grouping.auto.pgram_+3A_superpose">superpose</code></td>
<td>
<p>logical, whether to plot contributions for all intervals on one panel</p>
</td></tr>
<tr><td><code id="grouping.auto.pgram_+3A_order">order</code></td>
<td>
<p>logical, whether to reorder components by contribution</p>
</td></tr>
<tr><td><code id="grouping.auto.pgram_+3A_...">...</code></td>
<td>
<p>additional arguments passed to <code><a href="#topic+reconstruct">reconstruct</a></code> and
<code><a href="lattice.html#topic+xyplot">xyplot</a></code> routines</p>
</td></tr>
<tr><td><code id="grouping.auto.pgram_+3A_drop">drop</code></td>
<td>
<p>logical, whether to exclude empty groups from resulted list</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Elementary components are grouped using their frequency contribution (periodogram).
Optionally (see argument 'base') periodogram of eigen or factor vectors may be used.
</p>
<p>For each elementary component and for each frequency interval
(which are specified by 'freq.bins' argument)
relative (from 0 till 1) contribution
is computed using one of two methods:
'constant' (periodogram is considered as a sequence of separate bars)
or 'linear' (periodogram is linearly interpolated).
</p>
<p>Two approaches of grouping is implemented:
</p>

<dl>
<dt>'independent' or 'threshold'</dt><dd><p>Each group includes components
with frequency contribution in correspondent interval is greater than specified threshold;
resulted groups can intersect.
If 'threshold' is a vector, correspondent value of threshold will be using
for each interval. See Algorithm 2.16 in Golyandina et al (2018).</p>
</dd>
<dt>'dependent' or 'splitting'</dt><dd><p>Elementary components are separated to disjoint subsets;
for each component interval with the highest contribution is selected. 
See Algorithm 2.17 in Golyandina et al (2018)</p>
</dd>
</dl>

<p>If 'freq.bins' is named, result groups will take the same names.
</p>
<p>If drop = 'TRUE' (by default), empty groups will be excluded from result.
</p>
<p>See  Section 2.7 in Golyandina et al (2018) and the paper Alexandrov, Golyandina (2005) for the details of the algorithm.
</p>


<h3>Value</h3>

<p>object of class 'grouping.auto.pgram' (list of groups with some additional info) for grouping method;
'trellis' object for plot method.
</p>


<h3>References</h3>

<p>Golyandina N., Korobeynikov A., Zhigljavsky A. (2018):
<em>Singular Spectrum Analysis with R.</em>  Use R!.
Springer, Berlin, Heidelberg.
</p>
<p>Alexandrov, Th., Golyandina, N. (2005):
<em>Automatic extraction and forecast of time series cyclic components
within the framework of SSA.</em>
In Proceedings of the 5th St.Petersburg Workshop on Simulation,
June 26 &ndash; July 2, 2005, St.Petersburg State University, St.Petersburg, Pp. 45&ndash;50
<a href="https://www.gistatgroup.com/gus/autossa2.pdf">https://www.gistatgroup.com/gus/autossa2.pdf</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+Rssa">Rssa</a></code> for an overview of the package, as well as,
<code><a href="#topic+reconstruct">reconstruct</a></code>,
<code><a href="#topic+rforecast">rforecast</a></code>,
<code><a href="#topic+vforecast">vforecast</a></code>,
<code><a href="#topic+parestimate">parestimate</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  ss &lt;- ssa(co2)
  plot(ss, type = "vectors", idx = 1:12)
  plot(ss, type = "vectors", vectors = "factor", idx = 1:12)
  plot(ss, type = "series", groups = 1:12)

  g1 &lt;- grouping.auto(ss, base = "series", freq.bins = list(0.005), threshold = 0.95)
  g2 &lt;- grouping.auto(ss, base = "eigen", freq.bins = 2, threshold = 0)
  g3 &lt;- grouping.auto(ss, base = "factor", freq.bins = list(c(0.1), c(0.1, 0.2)), 
                      threshold = 0, method = "linear")
  g4 &lt;- grouping.auto(ss, freq.bins = c(0.1, 0.2), threshold = 0)

  g &lt;- grouping.auto(ss, freq.bins = 8, threshold = 0)
  plot(reconstruct(ss, groups = g))
  plot(g)

  g &lt;- grouping.auto(ss, freq.bins = list(0.1, 0.2, 0.3, 0.4, 0.5), threshold = 0.95)
  plot(reconstruct(ss, groups = g))
  plot(g)
</code></pre>

<hr>
<h2 id='grouping.auto.wcor'>Group Elementary Series Using W-correlation Matrix</h2><span id='topic+grouping.auto.wcor'></span><span id='topic+grouping.auto.wcor.ssa'></span>

<h3>Description</h3>

<p>Group elemenatry series automatically via
the hierarchical clustering with w-correlation matrix as a proximity
matrix</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'ssa'
grouping.auto.wcor(x, groups, nclust = length(groups) / 2, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="grouping.auto.wcor_+3A_x">x</code></td>
<td>
<p>SSA object</p>
</td></tr>
<tr><td><code id="grouping.auto.wcor_+3A_groups">groups</code></td>
<td>
<p>list of numeric vectors, indices of elementary components
used for reconstruction</p>
</td></tr>
<tr><td><code id="grouping.auto.wcor_+3A_nclust">nclust</code></td>
<td>
<p>integer, desired number of output series</p>
</td></tr>
<tr><td><code id="grouping.auto.wcor_+3A_...">...</code></td>
<td>
<p>further arguments passed to <code>hclust</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>Standard <code>hclust</code> routine is used to perform the grouping
of the elementary components. See Algorithm 2.15 in Golyandina et al (2018) for details.
</p>


<h3>Value</h3>

<p>List of integer vectors holding the indices of the elementary components
forming each grouped objects
</p>


<h3>References</h3>

<p>Golyandina N., Korobeynikov A., Zhigljavsky A. (2018):
<em>Singular Spectrum Analysis with R.</em>  Use R!.
Springer, Berlin, Heidelberg.
</p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+hclust">hclust</a></code>, <code><a href="#topic+wcor">wcor</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Decompose 'co2' series with default parameters
s &lt;- ssa(co2)
# Form 3 series from the initial 6 ones:
lst &lt;- grouping.auto(s, grouping.method = "wcor",
                     groups = 1:6, nclust=3)
# Automatic grouping:
print(lst)
plot(lst)
# Check separability
w &lt;- wcor(s, groups = lst)
plot(w)
</code></pre>

<hr>
<h2 id='hbhmat'>Hankel with Hankel block matrices operations.</h2><span id='topic+new.hbhmat'></span><span id='topic+is.hbhmat'></span><span id='topic+hbhcols'></span><span id='topic+hbhrows'></span><span id='topic+hbhankel'></span><span id='topic+hbhmatmul'></span>

<h3>Description</h3>

<p>A set of routines to operate on Hankel with Hankel block matrices
stored in compact FFT-based form.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>new.hbhmat(F, L = (N + 1) %/% 2,
           wmask = NULL, fmask = NULL, weights = NULL,
           circular = FALSE)
is.hbhmat(h)
hbhcols(h)
hbhrows(h)
hbhmatmul(hmat, v, transposed = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="hbhmat_+3A_f">F</code></td>
<td>
<p>array to construct the trajectory matrix for.</p>
</td></tr>
<tr><td><code id="hbhmat_+3A_l">L</code></td>
<td>
<p>the window length.</p>
</td></tr>
<tr><td><code id="hbhmat_+3A_wmask">wmask</code>, <code id="hbhmat_+3A_fmask">fmask</code>, <code id="hbhmat_+3A_weights">weights</code></td>
<td>
<p>special parameters for shaped SSA case (see <code><a href="#topic+ssa">ssa</a></code>).
<code>wmask</code> and <code>fmask</code> are logical matrices, window and factor masks respectively.
<code>weights</code> is integer matrix which denotes hankel weights for array elements. If 'NULL',
parameters for simple rectangular 2D SSA case are used.</p>
</td></tr>
<tr><td><code id="hbhmat_+3A_circular">circular</code></td>
<td>
<p>logical vector of one or two elements, describes field topology.
'TRUE' means circularity by a corresponding coordinate. If vector has only one element,
this element will be used twice.</p>
</td></tr>
<tr><td><code id="hbhmat_+3A_h">h</code>, <code id="hbhmat_+3A_hmat">hmat</code></td>
<td>
<p>matrix to operate on.</p>
</td></tr>
<tr><td><code id="hbhmat_+3A_transposed">transposed</code></td>
<td>
<p>logical, if 'TRUE' the multiplication is performed
with the transposed matrix.</p>
</td></tr>
<tr><td><code id="hbhmat_+3A_v">v</code></td>
<td>
<p>vector to multiply with.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Fast Fourier Transform provides a very efficient matrix-vector
multiplication routine for Hankel with Hankel blocks matrices. See the
paper in 'References' for the details of the algorithm.
</p>


<h3>Author(s)</h3>

<p>Konstantin Usevich</p>


<h3>References</h3>

<p>Korobeynikov, A. (2010) <em>Computation- and space-efficient implementation of
SSA.</em> Statistics and Its Interface, Vol. 3, No. 3, Pp. 257-268
</p>

<hr>
<h2 id='hmat'>Hankel matrices operations.</h2><span id='topic+new.hmat'></span><span id='topic+is.hmat'></span><span id='topic+hcols'></span><span id='topic+hrows'></span><span id='topic+hankel'></span><span id='topic+hmatmul'></span>

<h3>Description</h3>

<p>A set of routines to operate on Hankel matrices stored in
compact FFT-based form.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>new.hmat(F, L = (N + 1)%/%2, circular = FALSE, wmask = NULL,
         fmask = NULL, weights = NULL, fft.plan = NULL)
is.hmat(h)
hcols(h)
hrows(h)
hmatmul(hmat, v, transposed = FALSE)
hankel(X, L)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="hmat_+3A_f">F</code></td>
<td>
<p>series to construct the trajectory matrix for.</p>
</td></tr>
<tr><td><code id="hmat_+3A_fft.plan">fft.plan</code></td>
<td>
<p>internal hint argument, should be NULL in most cases</p>
</td></tr>
<tr><td><code id="hmat_+3A_wmask">wmask</code>, <code id="hmat_+3A_fmask">fmask</code>, <code id="hmat_+3A_weights">weights</code></td>
<td>
<p>special parameters for shaped SSA case (see <code><a href="#topic+ssa">ssa</a></code>).
<code>wmask</code> and <code>fmask</code> are logical vectors, window and factor masks respectively.
<code>weights</code> is integer vector which denotes hankel weights for array elements. If 'NULL',
parameters for simple 1D SSA case are used.</p>
</td></tr>
<tr><td><code id="hmat_+3A_circular">circular</code></td>
<td>
<p>logical vector of one element, describes series topology.
'TRUE' means circularity by time.</p>
</td></tr>
<tr><td><code id="hmat_+3A_l">L</code></td>
<td>
<p>the window length.</p>
</td></tr>
<tr><td><code id="hmat_+3A_h">h</code>, <code id="hmat_+3A_hmat">hmat</code></td>
<td>
<p>matrix to operate on.</p>
</td></tr>
<tr><td><code id="hmat_+3A_transposed">transposed</code></td>
<td>
<p>logical, if 'TRUE' the multiplication is performed
with the transposed matrix.</p>
</td></tr>
<tr><td><code id="hmat_+3A_v">v</code></td>
<td>
<p>vector to multiply with.</p>
</td></tr>
<tr><td><code id="hmat_+3A_x">X</code></td>
<td>
<p>series to construct the trajectory matrix for or matrix for hankelization</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Fast Fourier Transform provides a very efficient matrix-vector
multiplication routine for Hankel matrices. See the paper in
'References' for the details of the algorithm.
</p>


<h3>References</h3>

<p>Korobeynikov, A. (2010) <em>Computation- and space-efficient implementation of
SSA.</em> Statistics and Its Interface, Vol. 3, No. 3, Pp. 257-268
</p>


<h3>See Also</h3>

<p><code><a href="#topic+Rssa">Rssa</a></code> for an overview of the package, as well as,
<code><a href="#topic+ssa">ssa</a></code>,
<code><a href="#topic+decompose.ssa">decompose</a></code>,
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Construct the Hankel trajectory matrix for 'co2' series
h &lt;- new.hmat(co2, L = 10)
# Print number of columns and rows
print(hrows(h))
print(hcols(h))
</code></pre>

<hr>
<h2 id='hmatr'>Calculate the heterogeneity matrix.</h2><span id='topic+hmatr'></span><span id='topic+plot.hmatr'></span>

<h3>Description</h3>

<p>Function calculates the heterogeneity matrix for the one-dimensional series.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>hmatr(F, ...,
      B = N %/% 4, T = N %/% 4, L = B %/% 2,
      neig = 10)

## S3 method for class 'hmatr'
plot(x,
     col = rev(heat.colors(256)),
     main = "Heterogeneity Matrix", xlab = "", ylab = "", ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="hmatr_+3A_f">F</code></td>
<td>
<p>the series to be checked for structural changes</p>
</td></tr>
<tr><td><code id="hmatr_+3A_...">...</code></td>
<td>
<p>further arguments passed to <code>ssa</code> routine for
<code>hmatr</code> call or <code>image</code> for <code>plot.hmatr</code> call</p>
</td></tr>
<tr><td><code id="hmatr_+3A_b">B</code></td>
<td>
<p>integer, length of base series</p>
</td></tr>
<tr><td><code id="hmatr_+3A_t">T</code></td>
<td>
<p>integer, length of tested series</p>
</td></tr>
<tr><td><code id="hmatr_+3A_l">L</code></td>
<td>
<p>integer, window length for the decomposition of the base
series</p>
</td></tr>
<tr><td><code id="hmatr_+3A_neig">neig</code></td>
<td>
<p>integer, number of eigentriples to consider for
calculating projections</p>
</td></tr>
<tr><td><code id="hmatr_+3A_x">x</code></td>
<td>
<p>'hmatr' object</p>
</td></tr>
<tr><td><code id="hmatr_+3A_col">col</code></td>
<td>
<p>color palette to use</p>
</td></tr>
<tr><td><code id="hmatr_+3A_main">main</code></td>
<td>
<p>plot title</p>
</td></tr>
<tr><td><code id="hmatr_+3A_xlab">xlab</code>, <code id="hmatr_+3A_ylab">ylab</code></td>
<td>
<p>labels for 'x' and 'y' axis</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <em>heterogeneity matrix</em> (H-matrix) provides a
consistent view on the structural discrepancy between different parts of the
series. Denote by <code class="reqn">F_{i,j}</code> the subseries of F of the form: <code class="reqn">F_{i,j} =
  \left(f_{i},\dots,f_{j}\right)</code>. Fix two integers <code class="reqn">B &gt; L</code> and <code class="reqn">T \geq L</code>. Let
these integers denote the lengths of <em>base</em> and <em>test</em> subseries,
respectively. Introduce the H-matrix <code class="reqn">G_{B,T}</code> with the elements <code class="reqn">g_{ij}</code> as
follows:
</p>
<p style="text-align: center;"><code class="reqn">
    g_{ij} = g(F_{i,i+B}, F_{j,j+T}),
  </code>
</p>

<p>for <code class="reqn">i=1,\dots,N-B+1</code> and <code class="reqn">j=1,\dots,N-T+1</code>, that is we split the series
F into subseries of lengths B and T and calculate the heterogeneity index
between all possible pairs of the subseries.
</p>
<p>The heterogeneity index <code class="reqn">g(F^{(1)}, F^{(2)})</code> between the series
<code class="reqn">F^{(1)}</code> and <code class="reqn">F^{(2)}</code> can be calculated as follows: let
<code class="reqn">U_{j}^{(1)}</code>, <code class="reqn">j=1,\dots,L</code> denote the eigenvectors of the
SVD of the trajectory matrix of the series <code class="reqn">F^{(1)}</code>. Fix I to be a
subset of <code class="reqn">\left\{1,\dots,L\right\}</code> and denote <code class="reqn">\mathcal{L}^{(1)} =
  \mathrm{span}\,\left(U_{i},\, i \in I\right)</code>. Denote by
<code class="reqn">X^{(2)}_{1},\dots,X^{(2)}_{K_{2}}</code> (<code class="reqn">K_{2} = N_{2} - L + 1</code>) the
L-lagged vectors of the series <code class="reqn">F^{(2)}</code>. Now define
</p>
<p style="text-align: center;"><code class="reqn">
    g(F^{(1)},F^{(2)})
    = \frac{\sum_{j=1}^{K_{2}}{\mathrm{dist}^{2}\left(X^{(2)}_{j},
        \mathcal{L}^{(1)}\right)}}
    {\sum_{j=1}^{K_{2}}{\left\|X^{(2)}_{j}\right\|^{2}}}, </code>
</p>
<p> where
<code class="reqn">\mathrm{dist}\,(X,\mathcal{L})</code> denotes the Euclidean distance between the
vector X and the subspace <code class="reqn">\mathcal{L}</code>. One can easily see that
<code class="reqn">0 \leq g \leq 1</code>.
</p>


<h3>Value</h3>

<p>object of type 'hmatr'
</p>


<h3>References</h3>

<p>Golyandina, N., Nekrutkin, V. and Zhigljavsky, A. (2001): <em>Analysis of
Time Series Structure: SSA and related techniques.</em> Chapman and Hall/CRC. ISBN 1584881941
</p>


<h3>See Also</h3>

<p><code><a href="#topic+ssa">ssa</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Calculate H-matrix for co2 series
h &lt;- hmatr(co2, L = 24)
# Plot the matrix
plot(h)
</code></pre>

<hr>
<h2 id='igapfill'>Perform SSA gapfilling via iterative reconstruction</h2><span id='topic+igapfill'></span><span id='topic+igapfill.ssa'></span><span id='topic+igapfill.1d.ssa'></span><span id='topic+igapfill.cssa'></span><span id='topic+igapfill.toeplitz.ssa'></span><span id='topic+igapfill.nd.ssa'></span>

<h3>Description</h3>

<p>Perform iterative gapfilling of the series.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class '1d.ssa'
igapfill(x, groups, fill = NULL, tol = 1e-6, maxiter = 0,
          norm = function(x) sqrt(max(x^2)),
          base = c("original", "reconstructed"), ..., trace = FALSE,
          drop = TRUE, drop.attributes = FALSE, cache = TRUE)
## S3 method for class 'cssa'
igapfill(x, groups, fill = NULL, tol = 1e-6, maxiter = 0,
          norm = function(x) sqrt(max(x^2)),
          base = c("original", "reconstructed"), ..., trace = FALSE,
          drop = TRUE, drop.attributes = FALSE, cache = TRUE)
## S3 method for class 'toeplitz.ssa'
igapfill(x, groups, fill = NULL, tol = 1e-6, maxiter = 0,
          norm = function(x) sqrt(max(x^2)),
          base = c("original", "reconstructed"), ..., trace = FALSE,
          drop = TRUE, drop.attributes = FALSE, cache = TRUE)
## S3 method for class 'nd.ssa'
igapfill(x, groups, fill = NULL, tol = 1e-6, maxiter = 0,
          norm = function(x) sqrt(max(x^2)),
          base = c("original", "reconstructed"), ..., trace = FALSE,
          drop = TRUE, drop.attributes = FALSE, cache = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="igapfill_+3A_x">x</code></td>
<td>
<p>Shaped SSA object holding the decomposition</p>
</td></tr>
<tr><td><code id="igapfill_+3A_groups">groups</code></td>
<td>
<p>list, the grouping of eigentriples to be used in the forecast</p>
</td></tr>
<tr><td><code id="igapfill_+3A_fill">fill</code></td>
<td>
<p>initial values for missed entries, recycled if necessary;
if missed, then average of the series will be used</p>
</td></tr>
<tr><td><code id="igapfill_+3A_tol">tol</code></td>
<td>
<p>tolerance for reconstruction iterations</p>
</td></tr>
<tr><td><code id="igapfill_+3A_maxiter">maxiter</code></td>
<td>
<p>upper bound for the number of iterations</p>
</td></tr>
<tr><td><code id="igapfill_+3A_norm">norm</code></td>
<td>
<p>distance function used for covergence criterion</p>
</td></tr>
<tr><td><code id="igapfill_+3A_base">base</code></td>
<td>
<p>series used as a 'seed' for gapfilling: original or
reconstructed according to the value of <code>groups</code> argument</p>
</td></tr>
<tr><td><code id="igapfill_+3A_...">...</code></td>
<td>
<p>additional arguments passed to <code><a href="#topic+reconstruct">reconstruct</a></code>
routines</p>
</td></tr>
<tr><td><code id="igapfill_+3A_trace">trace</code></td>
<td>
<p>logical, indicates whether the convergence process should be traced</p>
</td></tr>
<tr><td><code id="igapfill_+3A_drop">drop</code></td>
<td>
<p>logical, if 'TRUE' then the result is coerced to series
itself, when possible (length of 'groups' is one)</p>
</td></tr>
<tr><td><code id="igapfill_+3A_drop.attributes">drop.attributes</code></td>
<td>
<p>logical, if 'TRUE' then the attributes of the input series
are not copied to the reconstructed ones.</p>
</td></tr>
<tr><td><code id="igapfill_+3A_cache">cache</code></td>
<td>
<p>logical, if 'TRUE' then intermediate results will be
cached in the SSA object.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Iterative gapfilling starts from filling missed entries with initial
values, then the missed values are imputed from the successive
reconstructions. This process continues until convergence up to a
stationary point (e.g. filling / reconstruction does not change missed
values at all).
</p>
<p>Details of the used algorithm see in Golyandina et al (2018), 
Algorithms 3.7.
</p>


<h3>Value</h3>

<p>List of objects with gaps filled in. Elements of the list have the
same names as elements of <code>groups</code>. If group is unnamed,
corresponding component gets name &lsquo;Fn&rsquo;, where &lsquo;n&rsquo; is its index in
<code>groups</code> list.
</p>
<p>Or, the forecasted object itself, if length of groups is one and 'drop = TRUE'.
</p>


<h3>Note</h3>

<p>The method is very sensitive to the initial value of missed entries
('fill' argument). If the series are not stationary (e.g. contains
some trend) than the method may be prohibitely slow, or even fail to
converge or produce bogus results.
</p>


<h3>References</h3>

<p>Golyandina N., Korobeynikov A., Zhigljavsky A. (2018):
<em>Singular Spectrum Analysis with R.</em>  Use R!.
Springer, Berlin, Heidelberg.
</p>
<p>Kondrashov, D. &amp; Ghil, M. (2006) <em>Spatio-temporal filling of
missing points in geophysical data sets</em>. Nonlinear Processes In
Geophysics, Vol. 13(2), pp. 151-159.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+Rssa">Rssa</a></code> for an overview of the package, as well as,
<code><a href="#topic+gapfill">gapfill</a></code>,
<code><a href="#topic+clplot">clplot</a></code>,
<code><a href="#topic+summarize.gaps">summarize.gaps</a></code>,
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Produce series with gaps
F &lt;- co2; F[100:200] &lt;- NA
# Perform shaped SSA
s &lt;- ssa(F, L = 72)
# Fill in gaps using the trend and 2 periodicty components
# Due to trend, provide a linear filler to speedup the process
fill &lt;- F; fill[100:200] &lt;- F[99] + (1:101)/101*(F[201] - F[99])
g &lt;- igapfill(s, groups = list(1:6), fill = fill, maxit = 50)
# Compare the result
plot(g)
lines(co2, col = "red")
</code></pre>

<hr>
<h2 id='iossa'>Iterative O-SSA nested decomposition</h2><span id='topic+iossa'></span><span id='topic+iossa.ssa'></span>

<h3>Description</h3>

<p>Perform Iterative O-SSA (IOSSA) algorithm.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'ssa'
iossa(x, nested.groups, ..., tol = 1e-5, kappa = 2,
      maxiter = 100,
      norm = function(x) sqrt(mean(x^2)),
      trace = FALSE,
      kappa.balance = 0.5)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="iossa_+3A_x">x</code></td>
<td>
<p>SSA object holding SSA decomposition</p>
</td></tr>
<tr><td><code id="iossa_+3A_nested.groups">nested.groups</code></td>
<td>
<p>list or named list of numbers of eigentriples
from full decomposition, describes initial grouping for IOSSA iterations</p>
</td></tr>
<tr><td><code id="iossa_+3A_tol">tol</code></td>
<td>
<p>tolerance for IOSSA iterations</p>
</td></tr>
<tr><td><code id="iossa_+3A_kappa">kappa</code></td>
<td>
<p>&lsquo;kappa&rsquo; parameter for sigma-correction (see &lsquo;Details&rsquo; and &lsquo;References&rsquo;) procedure.
If 'NULL', sigma-correction will not be performed</p>
</td></tr>
<tr><td><code id="iossa_+3A_maxiter">maxiter</code></td>
<td>
<p>upper bound for the number of iterations</p>
</td></tr>
<tr><td><code id="iossa_+3A_norm">norm</code></td>
<td>
<p>function, calculates a norm of a vector; this norm is
applied to the difference between the reconstructed series at
sequential iterations and is used for convergence detection</p>
</td></tr>
<tr><td><code id="iossa_+3A_trace">trace</code></td>
<td>
<p>logical, indicates whether the convergence process should be traced</p>
</td></tr>
<tr><td><code id="iossa_+3A_kappa.balance">kappa.balance</code></td>
<td>
<p>sharing proportion of sigma-correction multiplier
between column and row inner products</p>
</td></tr>
<tr><td><code id="iossa_+3A_...">...</code></td>
<td>
<p>additional arguments passed to <code><a href="#topic+decompose">decompose</a></code>
routines</p>
</td></tr>
</table>


<h3>Details</h3>

<p>See Golyandina N. and Shlemov A. (2015) and Section 2.4 in Golyanina et al (2018) 
for full details in the 1D case and 
p.250-252 from the same book for an example in the 2D case.
</p>
<p>Briefly, Iterative Oblique SSA (IOSSA) is an iterative (EM-like) method for
improving separability in SSA. In particular, it serves for separation
of mixed components, which are not  orthogonal, e.g., of sinusoids
with close frequencies or for trend separation for short series. IOSSA
performs a new decomposition of a part of the ssa-object, which is
given by a set of eigentriples. Note that eigentriples that do not
belong to the chosen set are not changed.
</p>
<p>Oblique SSA can make many series orthogonal by the choice of inner
product. Iterative O-SSA find the separating inner products by
iterations that are hopefully converges to a stationary point. See
References for more details.
</p>
<p>Sigma-correction procedure does the renormalization of new inner
products. This prevents the mixing of the components during the next
iteration. Such approach makes the whole procedure more stable and can
solve the problem of lack of strong separability.
</p>
<p>Details of the used algorithms can be found in Golyandina et al (2018), 
Algorithms 2.7 and 2.8.
</p>


<h3>Value</h3>

<p>Object of &lsquo;ossa&rsquo; class. In addition to usual &lsquo;ssa&rsquo; class
fields, it also contains the following fields:
</p>

<dl>
<dt>iossa.result</dt><dd><p>object of &lsquo;iossa.result&rsquo; class, a list which
contains algorithm parameters, condition numbers, separability
measures, the number of iterations and convergence status (see
<code><a href="#topic+iossa.result">iossa.result</a></code>)</p>
</dd>
<dt>iossa.groups</dt><dd><p>list of groups within the nested decomposition;
numbers of components correspond to their numbers in the full
decomposition</p>
</dd>
<dt>iossa.groups.all</dt><dd><p>list, describes cumulative grouping after
after sequential Iterative O-SSA decompositions in the case of
non-intersecting <code>nested.groups</code>. Otherwise,
<code>iossa.groups.all</code> coincides with <code>iossa.groups</code></p>
</dd>
<dt>ossa.set</dt><dd><p>vector of the indices of elementary components used
in Iterative O-SSA (that is, used in <code>nested.groups</code>)</p>
</dd>
</dl>



<h3>References</h3>

<p>Golyandina N., Korobeynikov A., Zhigljavsky A. (2018):
<em>Singular Spectrum Analysis with R.</em>  Use R!.
Springer, Berlin, Heidelberg.
</p>
<p>Golyandina N. and Shlemov A. (2015): <em>Variations of Singular Spectrum Analysis
for separability improvement: non-orthogonal decompositions of time series</em>, 
Statistics and Its Interface. Vol.8, No 3, P.277-294.
<a href="https://arxiv.org/abs/1308.4022">https://arxiv.org/abs/1308.4022</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+Rssa">Rssa</a></code> for an overview of the package, as well as,
<code><a href="#topic+ssa-object">ssa-object</a></code>,
<code><a href="#topic+fossa">fossa</a></code>,
<code><a href="#topic+owcor">owcor</a></code>,
<code><a href="#topic+iossa.result">iossa.result</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Separate three non-separable sine series with different amplitudes
N &lt;- 150
L &lt;- 70

omega1 &lt;- 0.05
omega2 &lt;- 0.06
omega3 &lt;- 0.07

F &lt;- 4*sin(2*pi*omega1 * (1:N)) + 2*sin(2*pi*omega2 * (1:N)) + sin(2*pi*omega3 * (1:N))
s &lt;- ssa(F, L)
ios &lt;- iossa(s, nested.groups = list(1:2, 3:4, 5:6), kappa = NULL, maxiter = 100, tol = 1e-3)

plot(reconstruct(ios, groups = ios$iossa.groups))
summary(ios)


# Separate two non-separable sines with equal amplitudes
N &lt;- 200
L &lt;- 100
omega1 &lt;- 0.07
omega2 &lt;- 0.06

F &lt;- sin(2*pi*omega1 * (1:N)) + sin(2*pi*omega2 * (1:N))
s &lt;- ssa(F, L)

# Apply FOSSA and then IOSSA
fs &lt;- fossa(s, nested.groups = 1:4)
ios &lt;- iossa(fs, nested.groups = list(1:2, 3:4), maxiter = 100)
summary(ios)

opar &lt;- par(mfrow = c(3, 1))
plot(reconstruct(s, groups = list(1:2, 3:4)))
plot(reconstruct(fs, groups = list(1:2, 3:4)))
plot(reconstruct(ios, groups = ios$iossa.groups))
par(opar)

wo &lt;- plot(wcor(ios, groups = 1:4))
gwo &lt;- plot(owcor(ios, groups = 1:4))
plot(wo, split = c(1, 1, 2, 1), more = TRUE)
plot(gwo, split = c(2, 1, 2, 1), more = FALSE)



data(USUnemployment)
unempl.male &lt;- USUnemployment[, "MALE"]

s &lt;- ssa(unempl.male)
ios &lt;- iossa(s, nested.groups = list(c(1:4, 7:11), c(5:6, 12:13)))
summary(ios)

# Comparison of reconstructions
rec &lt;- reconstruct(s, groups = list(c(1:4, 7:11), c(5:6, 12:13)))
iorec &lt;- reconstruct(ios, groups &lt;- ios$iossa.groups)
# Trends
matplot(data.frame(iorec$F1, rec$F1, unempl.male), type='l',
        col=c("red","blue","black"), lty=c(1,1,2))
# Seasonalities
matplot(data.frame(iorec$F2, rec$F2), type='l', col=c("red","blue"),lty=c(1,1))

# W-cor matrix before IOSSA and w-cor matrix after it
ws &lt;- plot(wcor(s, groups = 1:30), grid = 14)
wios &lt;- plot(wcor(ios, groups = 1:30), grid = 14)
plot(ws, split = c(1, 1, 2, 1), more = TRUE)
plot(wios, split = c(2, 1, 2, 1), more = FALSE)

# Eigenvectors before and after Iterative O-SSA
plot(s, type = "vectors", idx = 1:13)
plot(ios, type = "vectors", idx = 1:13)

# 2D plots of periodic eigenvectors before and after Iterative O-SSA
plot(s, type = "paired", idx = c(5, 12))
plot(ios, type = "paired", idx = c(10, 12), plot.contrib = FALSE)

data(AustralianWine)
Fortified &lt;- AustralianWine[, "Fortified"]
s &lt;- ssa(window(Fortified, start = 1982 + 5/12, end = 1986 + 5/12), L = 18)
ios &lt;- iossa(s, nested.groups = list(trend = 1, 2:7),
             kappa = NULL,
             maxIter = 1)
fs &lt;- fossa(s, nested.groups = 1:7, gamma = 1000)

rec.ssa &lt;- reconstruct(s, groups = list(trend = 1, 2:7))
rec.iossa &lt;- reconstruct(ios, groups = ios$iossa.groups);
rec.fossa &lt;- reconstruct(fs, groups = list(trend = 7, 1:6))

Fort &lt;- cbind(`Basic SSA trend` = rec.ssa$trend,
              `Iterative O-SSA trend` = rec.iossa$trend,
              `DerivSSA trend` = rec.fossa$trend,
              `Full series` = Fortified)

library(lattice)
xyplot(Fort, superpose = TRUE, col = c("red", "blue", "green4", "black"))



# Shaped 2D I. O-SSA separates finite rank fields exactly
mx1 &lt;- outer(1:50, 1:50,
             function(i, j) exp(i/25 - j/20))
mx2 &lt;- outer(1:50, 1:50,
             function(i, j) sin(2*pi * i/17) * cos(2*pi * j/7))

mask &lt;- matrix(TRUE, 50, 50)
mask[23:25, 23:27] &lt;- FALSE
mask[1:2, 1] &lt;- FALSE
mask[50:49, 1] &lt;- FALSE
mask[1:2, 50] &lt;- FALSE

mx1[!mask] &lt;- mx2[!mask] &lt;- NA

s &lt;- ssa(mx1 + mx2, kind = "2d-ssa", L = c(10, 10))
plot(reconstruct(s, groups = list(1, 2:5)))

ios &lt;- iossa(s, nested.groups = list(1, 2:5), kappa = NULL)
plot(reconstruct(ios, groups = ios$iossa.groups))


# I. O-SSA for MSSA
N.A &lt;- 150
N.B &lt;- 120
L &lt;- 40

omega1 &lt;- 0.05
omega2 &lt;- 0.055

tt.A &lt;- 1:N.A
tt.B &lt;- 1:N.B
F1 &lt;- list(A = 2 * sin(2*pi * omega1 * tt.A), B = cos(2*pi * omega1 * tt.B))
F2 &lt;- list(A = 1 * sin(2*pi * omega2 * tt.A), B = cos(2*pi * omega2 * tt.B))

F &lt;- list(A = F1$A + F2$A, B = F1$B + F2$B)

s &lt;- ssa(F, kind = "mssa")
plot(reconstruct(s, groups = list(1:2, 3:4)), plot.method = "xyplot")

ios &lt;- iossa(s, nested.groups = list(1:2, 3:4), kappa = NULL)
plot(reconstruct(ios, groups = ios$iossa.groups), plot.method = "xyplot")

</code></pre>

<hr>
<h2 id='iossa.result'>Summary of Iterative O-SSA results</h2><span id='topic+iossa.result'></span><span id='topic+print.iossa.result'></span><span id='topic+summary.iossa.result'></span>

<h3>Description</h3>

<p>Various routines to print Iterative Oblique SSA results
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  ## S3 method for class 'iossa.result'
print(x, digits = max(3, getOption("digits") - 3), ...)
  ## S3 method for class 'iossa.result'
summary(object, digits = max(3, getOption("digits") - 3), ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="iossa.result_+3A_x">x</code>, <code id="iossa.result_+3A_object">object</code></td>
<td>
<p>object of class &lsquo;iossa.result&rsquo; or &lsquo;ossa&rsquo;</p>
</td></tr>
<tr><td><code id="iossa.result_+3A_digits">digits</code></td>
<td>
<p>integer, used for number formatting</p>
</td></tr>
<tr><td><code id="iossa.result_+3A_...">...</code></td>
<td>
<p>further arguments passed to method</p>
</td></tr>
</table>


<h3>Details</h3>

<p>An object of class &lsquo;iossa.result&rsquo; is a list with the following fields:
</p>

<dl>
<dt>converged</dt><dd><p>logical, whether algorithm has been converged</p>
</dd>
<dt>iter</dt><dd><p>the number of OSSA iterations</p>
</dd>
<dt>cond</dt><dd><p>numeric vector with two elements, condition numbers of the final column and row inner products</p>
</dd>
<dt>initial.tau</dt><dd><p>numeric vector, proportions of high rank components contribution
for each of initial series
(denotes how well the series is approximated by a series of finite rank)</p>
</dd>
<dt>tau</dt><dd><p>numeric vector, proportions of high rank components contribution for each of final series</p>
</dd>
<dt>initial.wcor</dt><dd><p>W-correlation matrix of the initial nested decomposition</p>
</dd>
<dt>wcor</dt><dd><p>W-correlations matrix of the final nested decomposition</p>
</dd>
<dt>owcor</dt><dd><p>oblique W-correlation matrix (see <code><a href="#topic+owcor">owcor</a></code>)
of the final nested decomposition</p>
</dd>
<dt>initial.rec</dt><dd><p>list of initial series (reconstructed initial nested decomposition)</p>
</dd>
<dt>kappa, maxiter, tol</dt><dd><p>Iterative O-SSA procedure parameters</p>
</dd>
</dl>



<h3>References</h3>

<p>Golyandina N. and Shlemov A. (2015): <em>Variations of Singular Spectrum Analysis
for separability improvement: non-orthogonal decompositions of time series</em>, 
Statistics and Its Interface. Vol.8, No 3, P.277-294.
<a href="https://arxiv.org/abs/1308.4022">https://arxiv.org/abs/1308.4022</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+Rssa">Rssa</a></code> for an overview of the package, as well as,
<code><a href="#topic+iossa">iossa</a></code>,
<code><a href="#topic+owcor">owcor</a></code>,
<code><a href="#topic+summary.ssa">summary.ssa</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Separate three non-separable sines with different amplitudes
N &lt;- 150
L &lt;- 70

omega1 &lt;- 0.05
omega2 &lt;- 0.06
omega3 &lt;- 0.07

F &lt;- 4*sin(2*pi*omega1 * (1:N)) + 2*sin(2*pi*omega2 * (1:N)) + sin(2*pi*omega3 * (1:N))
s &lt;- ssa(F, L)
ios &lt;- iossa(s, nested.groups = list(1:2, 3:4, 5:6), kappa = NULL, maxiter = 100, tol = 1e-3)

print(ios)
print(ios$iossa.result)

</code></pre>

<hr>
<h2 id='lrr'>Calculate the min-norm Linear Recurrence Relation</h2><span id='topic+lrr'></span><span id='topic+lrr.default'></span><span id='topic+lrr.ssa'></span><span id='topic+lrr.1d.ssa'></span><span id='topic+lrr.toeplitz.ssa'></span><span id='topic+roots'></span><span id='topic+roots.lrr'></span><span id='topic+plot.lrr'></span>

<h3>Description</h3>

<p>Calculates the min-norm Linear Recurrence Relation given the one-dimensional 'ssa' object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class '1d.ssa'
lrr(x, groups, reverse = FALSE, ..., drop = TRUE)
## S3 method for class 'toeplitz.ssa'
lrr(x, groups, reverse = FALSE, ..., drop = TRUE)
## Default S3 method:
lrr(x, eps = sqrt(.Machine$double.eps),
        reverse = FALSE, ..., orthonormalize = TRUE)
## S3 method for class 'lrr'
roots(x, ..., method = c("companion", "polyroot"))
## S3 method for class 'lrr'
plot(x, ..., raw = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="lrr_+3A_x">x</code></td>
<td>
<p>SSA object holding the decomposition or matrix containing the basis vectors in columns
for <code>lrr</code> call or 'lrr' object itself for other function calls</p>
</td></tr>
<tr><td><code id="lrr_+3A_groups">groups</code></td>
<td>
<p>list, the grouping of eigentriples used to derive the LRR</p>
</td></tr>
<tr><td><code id="lrr_+3A_reverse">reverse</code></td>
<td>
<p>logical, if 'TRUE', then LRR is assumed to go back</p>
</td></tr>
<tr><td><code id="lrr_+3A_...">...</code></td>
<td>
<p>further arguments to be passed to <code>decompose</code> or
<code>plot</code> call, if necessary</p>
</td></tr>
<tr><td><code id="lrr_+3A_drop">drop</code></td>
<td>
<p>logical, if 'TRUE' then the result is coerced to lrr object
itself, when possible (length of 'groups' is one)</p>
</td></tr>
<tr><td><code id="lrr_+3A_eps">eps</code></td>
<td>
<p>Tolerance for verticality checking</p>
</td></tr>
<tr><td><code id="lrr_+3A_method">method</code></td>
<td>
<p>methods used for calculation of the polynomial roots: via eigenvalues
of companion matrix or R's standard <code>polyroot</code> routine</p>
</td></tr>
<tr><td><code id="lrr_+3A_raw">raw</code></td>
<td>
<p>logical, if 'TRUE' then <code>plot</code> routine will not add any
additional plot components (e.g. unit circle)</p>
</td></tr>
<tr><td><code id="lrr_+3A_orthonormalize">orthonormalize</code></td>
<td>
<p>logical, if 'FALSE' then the basis is assumed orthonormal.
Otherwise, orthonormalization is performed</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Produces the min-norm linear recurrence relation from the series. The default
implementation works as follows.
</p>
<p>Denote by <code class="reqn">U_i</code> the columns of matrix <code class="reqn">x</code>. Denote by
<code class="reqn">\tilde{U}_{i}</code> the same vector <code class="reqn">U_i</code> but without the
last coordinate. Denote the last coordinate of <code class="reqn">U_i</code> by
<code class="reqn">\pi_i</code>. The returned value is
</p>
<p style="text-align: center;"><code class="reqn">
    \mathcal{R} = \frac{1}{1-\nu^2}\sum_{i=1}^{d}{\pi_i \tilde{U}_{i}},
  </code>
</p>

<p>where
</p>
<p style="text-align: center;"><code class="reqn">
    \nu^2 = \pi_1^2 + \dots + \pi_d^2.
  </code>
</p>

<p>For <code>lrr.ssa</code> case the matrix <code class="reqn">U</code> used is the matrix of basis
vector corresponding to the selected elementary series.
</p>
<p>For <code>reverse = 'TRUE'</code> everything is the same, besides the
last coordinate substituted for the first coordinate.
</p>
<p>Details of the used algorithm see in Golyandina et al (2018), 
Algorithms 3.1 and 3.2.
</p>


<h3>Value</h3>

<p>Named list of object of class 'lrr' for <code>lrr</code> function call,
where elements have the same names as elements of <code>groups</code>
(if group is unnamed, corresponding component gets name &lsquo;Fn&rsquo;,
where &lsquo;n&rsquo; is its index in <code>groups</code> list).
Or the object itself if 'drop = TRUE' and groups has length one.
</p>
<p>Vector with the roots of the of the characteristic
polynomial of the LRR for <code>roots</code> function call. Roots are
ordered by moduli decreasing.
</p>


<h3>References</h3>

<p>Golyandina N., Korobeynikov A., Zhigljavsky A. (2018):
<em>Singular Spectrum Analysis with R.</em>  Use R!.
Springer, Berlin, Heidelberg.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+Rssa">Rssa</a></code> for an overview of the package, as well as,
<code><a href="#topic+ssa">ssa</a></code>,
<code><a href="#topic+parestimate">parestimate</a></code>,
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Decompose 'co2' series with default parameters
s &lt;- ssa(co2, L = 24)
# Calculate the LRR out of first 3 eigentriples
l &lt;- lrr(s, groups = list(1:3))
# Calculate the roots of the LRR
r &lt;- roots(l)
# Moduli of the roots
Mod(r)
# Periods of three roots with maximal moduli
2*pi/Arg(r)[1:3]
# Plot the roots
plot(l)
</code></pre>

<hr>
<h2 id='Mars'>Webcam image of Mars</h2><span id='topic+Mars'></span>

<h3>Description</h3>

<p>Image of Mars obtained by a webcam.
258 x 275, grayscale, from 0 to 255.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(Mars)</code></pre>


<h3>Format</h3>

<p>A double matrix with integer values.</p>


<h3>Source</h3>

<p>Thierry, P. Tutorial for IRIS 5.59 (an astronomical images processing software),
<a href="http://www.astrosurf.com/buil/iris/tutorial8/doc23_us.htm">http://www.astrosurf.com/buil/iris/tutorial8/doc23_us.htm</a>.
Last updated: 20.12.2005
</p>

<hr>
<h2 id='MotorVehicle'>Total U.S. Domestic and Foreign Car Sales</h2><span id='topic+MotorVehicle'></span>

<h3>Description</h3>

<p>Monthly series containing total domestic and foreign car sales in the
USA in thousands, from 1967 till 2010.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(MotorVehicle)</code></pre>


<h3>Format</h3>

<p>A time series of length 541.</p>


<h3>Source</h3>

<p>U.S. Bureau of Economic Analysis. Table 7.2.5S. Auto and Truck Unit Sales Production Inventories
Expenditures and Price, 2010.
</p>

<hr>
<h2 id='owcor'>Calculate generalized (oblique) W-correlation matrix</h2><span id='topic+owcor'></span>

<h3>Description</h3>

<p>Function calculates oblique W-correlation matrix for the series.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  owcor(x, groups, ..., cache = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="owcor_+3A_x">x</code></td>
<td>
<p>the input object of &lsquo;ossa&rsquo; class</p>
</td></tr>
<tr><td><code id="owcor_+3A_groups">groups</code></td>
<td>
<p>list of numeric vectors, indices of elementary components
used for reconstruction. The elementary components must belong to
the current OSSA component set</p>
</td></tr>
<tr><td><code id="owcor_+3A_...">...</code></td>
<td>
<p>further arguments passed to <code>reconstruct</code> routine</p>
</td></tr>
<tr><td><code id="owcor_+3A_cache">cache</code></td>
<td>
<p>logical, if 'TRUE' then intermediate results will be
cached in 'ssa' object.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Matrix of oblique weighted correlations will be computed.
For two series, oblique W-covariation is defined as follows:
</p>
<p style="text-align: center;"><code class="reqn">%
    \mathrm{owcov}(F_1, F_2) =
      \langle L^\dagger X_1 (R^\dagger)^\mathrm{T},
              L^\dagger X_2 (R^\dagger)^\mathrm{T} \rangle_\mathrm{F},
  </code>
</p>

<p>where
<code class="reqn">X_1, X_2</code> denotes the trajectory matrices of series <code class="reqn">F_1, F_2</code>
correspondingly, <code class="reqn">L = [U_{b_1} : ... : U_{b_r}], R = [V_{b_1}: ... V_{b_r}]</code>,
where <code class="reqn">\\\{b_1, \dots, b_r\\\}</code> is current OSSA component set
(see description of &lsquo;ossa.set&rsquo; field of &lsquo;ossa&rsquo; object),
'<code class="reqn">\langle \cdot, \cdot
  \rangle_\mathrm{F}</code>' denotes Frobenius matrix inner product
and '<code class="reqn">\dagger</code>' denotes Moore-Penrose pseudo-inverse matrix.
</p>
<p>And oblique W-correlation is defined the following way:
</p>
<p style="text-align: center;"><code class="reqn">%
    \mathrm{owcor}(F_1, F_2) = \frac{\mathrm{owcov}(F_1, F_2)}
      {\sqrt{\mathrm{owcov}(F_1, F_1) \cdot \mathrm{owcov(F_2, F_2)}}}
  </code>
</p>

<p>Oblique W-correlation is an OSSA analogue of W-correlation, that is, a
measure of series separability. If I-OSSA procedure separates series
exactly, their oblique W-correlation will be equal to zero.
</p>


<h3>Value</h3>

<p>Object of class &lsquo;wcor.matrix&rsquo;
</p>


<h3>References</h3>

<p>Golyandina N. and Shlemov A. (2015): <em>Variations of Singular Spectrum Analysis
for separability improvement: non-orthogonal decompositions of time series</em>, 
Statistics and Its Interface. Vol.8, No 3, P.277-294.
<a href="https://arxiv.org/abs/1308.4022">https://arxiv.org/abs/1308.4022</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+Rssa">Rssa</a></code> for an overview of the package, as well as,
<code><a href="#topic+wcor">wcor</a></code>,
<code><a href="#topic+iossa">iossa</a></code>,
<code><a href="#topic+iossa">fossa</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Separate two non-separable sines
N &lt;- 150
L &lt;- 70

omega1 &lt;- 0.06
omega2 &lt;- 0.065

F &lt;- 4*sin(2*pi*omega1 * (1:N)) + sin(2*pi*omega2 * (1:N))
s &lt;- ssa(F, L)
ios &lt;- iossa(s, nested.groups = list(1:2, 3:4), kappa = NULL, maxIter = 200, tol = 1e-8)

p.wcor &lt;- plot(wcor(ios, groups = list(1:2, 3:4)))
p.owcor &lt;- plot(owcor(ios, groups = list(1:2, 3:4)), main = "OW-correlation matrix")
print(p.wcor, split = c(1, 1, 2, 1), more = TRUE)
print(p.owcor, split = c(2, 1, 2, 1))
</code></pre>

<hr>
<h2 id='parestimate'>Estimate periods from (set of) eigenvectors</h2><span id='topic+parestimate'></span><span id='topic+parestimate.1d.ssa'></span><span id='topic+parestimate.toeplitz.ssa'></span><span id='topic+parestimate.mssa'></span><span id='topic+parestimate.cssa'></span><span id='topic+parestimate.nd.ssa'></span>

<h3>Description</h3>

<p>Function to estimate the parameters (frequencies and rates) given a set of SSA eigenvectors.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class '1d.ssa'
parestimate(x, groups, method = c("esprit", "pairs"),
            subspace = c("column", "row"),
            normalize.roots = NULL,
            dimensions = NULL,
            solve.method = c("ls", "tls"),
            ...,
            drop = TRUE)
## S3 method for class 'toeplitz.ssa'
parestimate(x, groups, method = c("esprit", "pairs"),
            subspace = c("column", "row"),
            normalize.roots = NULL,
            dimensions = NULL,
            solve.method = c("ls", "tls"),
            ...,
            drop = TRUE)
## S3 method for class 'mssa'
parestimate(x, groups, method = c("esprit", "pairs"),
            subspace = c("column", "row"),
            normalize.roots = NULL,
            dimensions = NULL,
            solve.method = c("ls", "tls"),
            ...,
            drop = TRUE)
## S3 method for class 'cssa'
parestimate(x, groups, method = c("esprit", "pairs"),
            subspace = c("column", "row"),
            normalize.roots = NULL,
            dimensions = NULL,
            solve.method = c("ls", "tls"),
            ...,
            drop = TRUE)
## S3 method for class 'nd.ssa'
parestimate(x, groups,
            method = c("esprit"),
            subspace = c("column", "row"),
            normalize.roots = NULL,
            dimensions = NULL,
            solve.method = c("ls", "tls"),
            pairing.method = c("diag", "memp"),
            beta = 8,
            ...,
            drop = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="parestimate_+3A_x">x</code></td>
<td>
<p>SSA object</p>
</td></tr>
<tr><td><code id="parestimate_+3A_groups">groups</code></td>
<td>
<p>list of indices of eigenvectors to estimate from</p>
</td></tr>
<tr><td><code id="parestimate_+3A_...">...</code></td>
<td>
<p>further arguments passed to 'decompose' routine, if
necessary</p>
</td></tr>
<tr><td><code id="parestimate_+3A_drop">drop</code></td>
<td>
<p>logical, if 'TRUE' then the result is coerced to lowest
dimension, when possible (length of <code>groups</code> is one)</p>
</td></tr>
<tr><td><code id="parestimate_+3A_dimensions">dimensions</code></td>
<td>
<p>a vector of dimension indices to perform ESPRIT along. 'NULL' means all dimensions.</p>
</td></tr>
<tr><td><code id="parestimate_+3A_method">method</code></td>
<td>
<p>For 1D-SSA, Toeplitz SSA, and MSSA:
parameter estimation method,
'esprit' for 1D-ESPRIT (Algorithm 3.3 in Golyandina et al (2018)),
'pairs' for rough estimation based on pair of eigenvectors (Algorithm 3.4 in Golyandina et al (2018)).
For nD-SSA: parameter estimation method. 
For now only 'esprit' is supported (Algorithm 5.6 in Golyandina et al (2018)).</p>
</td></tr>
<tr><td><code id="parestimate_+3A_solve.method">solve.method</code></td>
<td>
<p>approximate matrix equation solving method, 'ls' for least-squares, 'tls' for total-least-squares.</p>
</td></tr>
<tr><td><code id="parestimate_+3A_pairing.method">pairing.method</code></td>
<td>
<p>method for esprit roots pairing, 'diag' for &lsquo;2D-ESPRIT diagonalization&rsquo;, 'memp' for &ldquo;MEMP with an
improved pairing step'</p>
</td></tr>
<tr><td><code id="parestimate_+3A_subspace">subspace</code></td>
<td>
<p>which subspace will be used for parameter estimation</p>
</td></tr>
<tr><td><code id="parestimate_+3A_normalize.roots">normalize.roots</code></td>
<td>
<p>logical vector or 'NULL', force signal roots to lie on unit circle.
'NULL' means automatic selection: normalize iff circular topology OR Toeplitz SSA used</p>
</td></tr>
<tr><td><code id="parestimate_+3A_beta">beta</code></td>
<td>
<p>In nD-ESPRIT, coefficient(s) in convex linear combination of
shifted matrices. The length of <code>beta</code> should be <code>ndim - 1</code>, where <code>ndim</code> is the number of independent dimensions.
If only one value is passed, it is expanded to a geometric progression.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>See Sections 3.1 and 5.3 in Golyandina et al (2018) for full details.
</p>
<p>Briefly, the time series is assumed to satisfy the model
</p>
<p style="text-align: center;"><code class="reqn">
    x_n = \sum_k{C_k\mu_k^n}
  </code>
</p>

<p>for complex <code class="reqn">\mu_k</code> or, alternatively,
</p>
<p style="text-align: center;"><code class="reqn">
    x_n = \sum_k{A_k \rho_k^n \sin(2\pi\omega_k n + \phi_k)}.
  </code>
</p>

<p>The return value are the estimated moduli and arguments of complex
<code class="reqn">\mu_k</code>, more precisely, <code class="reqn">\rho_k</code> ('moduli') and <code class="reqn">T_k =
  1/\omega_k</code> ('periods').
</p>
<p>For images, the model
</p>
<p style="text-align: center;"><code class="reqn">
    x_{ij}=\sum_k C_k \lambda_k^i \mu_k^j
  </code>
</p>

<p>is considered.
</p>
<p>Also &lsquo;print&rsquo; and &lsquo;plot&rsquo; methods are implemented for classes
&lsquo;fdimpars.1d&rsquo; and &lsquo;fdimpars.nd&rsquo;.
</p>


<h3>Value</h3>

<p>For 1D-SSA (and Toeplitz), a list of objects of S3-class &lsquo;fdimpars.1d&rsquo;. Each object is a list with 5 components:
</p>

<dl>
<dt>roots</dt><dd><p>complex roots of minimal LRR characteristic polynomial</p>
</dd>
<dt>periods</dt><dd><p>periods of dumped sinusoids</p>
</dd>
<dt>frequencies</dt><dd><p>frequencies of dumped sinusoids</p>
</dd>
<dt>moduli</dt><dd><p>moduli of roots</p>
</dd>
<dt>rates</dt><dd><p>rates of exponential trend (<code>rates == log(moduli)</code>)</p>
</dd>
</dl>

<p>For 'method' = 'pairs' all moduli are set equal to 1 and all rates equal to 0.
</p>
<p>For nD-SSA, a list of objects of S3-class &lsquo;fdimpars.nd&rsquo;. Each object
is named list of <code>n</code> &lsquo;fdimpars.1d&rsquo; objects, each for corresponding
spatial coordinate.
</p>
<p>In all cases elements of the list have the same names as elements of
<code>groups</code>. If group is unnamed, corresponding component gets name
&lsquo;Fn&rsquo;, where &lsquo;n&rsquo; is its index in <code>groups</code> list.
</p>
<p>If 'drop = TRUE' and length of 'groups' is one, then corresponding
list of estimated parameters is returned.
</p>


<h3>References</h3>

<p>Golyandina N., Korobeynikov A., Zhigljavsky A. (2018):
<em>Singular Spectrum Analysis with R.</em>  Use R!.
Springer, Berlin, Heidelberg.
</p>
<p>Roy, R., Kailath, T., (1989): <em>ESPRIT: estimation of signal parameters via
rotational invariance techniques</em>. IEEE Trans. Acoust. 37, 984&ndash;995.
</p>
<p>Rouquette, S., Najim, M. (2001): <em>Estimation of frequencies and damping factors by two-
dimensional esprit type methods</em>. IEEE Transactions on Signal Processing 49(1), 237&ndash;245.
</p>
<p>Wang, Y., Chan, J-W., Liu, Zh. (2005): <em>Comments on &ldquo;estimation of frequencies and
damping factors by two-dimensional esprit type methods&rdquo;</em>.
IEEE Transactions on Signal Processing 53(8), 3348&ndash;3349.
</p>
<p>Shlemov A, Golyandina N (2014) Shaped extensions of Singular Spectrum Analysis. In: 21st
international symposium on mathematical theory of networks and systems, July 7&ndash;11, 2014.
Groningen, The Netherlands, pp 1813&ndash;1820.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+Rssa">Rssa</a></code> for an overview of the package, as well as,
<code><a href="#topic+ssa">ssa</a></code>,
<code><a href="#topic+lrr">lrr</a></code>,
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Decompose 'co2' series with default parameters
s &lt;- ssa(co2, neig = 20)
# Estimate the periods from 2nd and 3rd eigenvectors using 'pairs' method
print(parestimate(s, groups = list(c(2, 3)), method = "pairs"))
# Estimate the peroids from 2nd, 3rd, 5th and 6th eigenvectors using ESPRIT
pe &lt;- parestimate(s, groups = list(c(2, 3, 5, 6)), method = "esprit")
print(pe)
plot(pe)


# Artificial image for 2D SSA
mx &lt;- outer(1:50, 1:50,
            function(i, j) sin(2*pi * i/17) * cos(2*pi * j/7) + exp(i/25 - j/20)) +
      rnorm(50^2, sd = 0.1)
# Decompose 'mx' with default parameters
s &lt;- ssa(mx, kind = "2d-ssa")
# Estimate parameters
pe &lt;- parestimate(s, groups = list(1:5))
print(pe)
plot(pe, col = c("green", "red", "blue"))

# Real example: Mars photo
data(Mars)
# Decompose only Mars image (without background)
s &lt;- ssa(Mars, mask = Mars != 0, wmask = circle(50), kind = "2d-ssa")
# Reconstruct and plot texture pattern
plot(reconstruct(s, groups = list(c(13,14, 17, 18))))
# Estimate pattern parameters
pe &lt;- parestimate(s, groups = list(c(13,14, 17, 18)))
print(pe)
plot(pe, col = c("green", "red", "blue", "black"))

</code></pre>

<hr>
<h2 id='plot'>Plot SSA object</h2><span id='topic+plot.ssa'></span>

<h3>Description</h3>

<p>This function plots various sorts of figures related to the SSA method.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'ssa'
plot(x,
     type = c("values", "vectors", "paired", "series", "wcor"),
     ...,
     vectors = c("eigen", "factor"),
     plot.contrib = TRUE,
     numvalues = nsigma(x),
     numvectors = min(nsigma(x), 10),
     idx = 1:numvectors,
     idy,
     groups)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot_+3A_x">x</code></td>
<td>
<p>SSA object holding the decomposition</p>
</td></tr>
<tr><td><code id="plot_+3A_type">type</code></td>
<td>
<p>Type of the plot (see 'Details' for more information)</p>
</td></tr>
<tr><td><code id="plot_+3A_...">...</code></td>
<td>
<p>Arguments to be passed to methods, such as graphical
parameters</p>
</td></tr>
<tr><td><code id="plot_+3A_vectors">vectors</code></td>
<td>
<p>For type = 'vectors', choose the vectors to plot</p>
</td></tr>
<tr><td><code id="plot_+3A_plot.contrib">plot.contrib</code></td>
<td>
<p>logical. If 'TRUE' (the default), the contribution
of the component to the total variance is plotted.
For &lsquo;ossa&rsquo; class, Frobenius orthogonality checking of elementary matrices is performed.
If not all matrices are orthogonal, corresponding warning is risen</p>
</td></tr>
<tr><td><code id="plot_+3A_numvalues">numvalues</code></td>
<td>
<p>Number of eigenvalues to plot (for type = 'values')</p>
</td></tr>
<tr><td><code id="plot_+3A_numvectors">numvectors</code></td>
<td>
<p>Total number of eigenvectors to plot (for type = 'vectors')</p>
</td></tr>
<tr><td><code id="plot_+3A_idx">idx</code></td>
<td>
<p>Indices of eigenvectors to plot (for type = 'vectors')</p>
</td></tr>
<tr><td><code id="plot_+3A_idy">idy</code></td>
<td>
<p>Second set of indices of eigenvectors to plot (for type = 'paired')</p>
</td></tr>
<tr><td><code id="plot_+3A_groups">groups</code></td>
<td>
<p>Grouping used for the decomposition (see <code><a href="#topic+reconstruct.ssa">reconstruct</a></code>)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is the single entry to various plots of SSA objects. Right
now this includes:
</p>

<dl>
<dt>values</dt><dd><p>plot the graph of the component norms.</p>
</dd>
<dt>vectors</dt><dd><p>plot the eigenvectors.</p>
</dd>
<dt>paired</dt><dd><p>plot the pairs of eigenvectors (useful for the
detection of periodic components).</p>
</dd>
<dt>series</dt><dd><p>plot the reconstructed series.</p>
</dd>
<dt>wcor</dt><dd><p>plot the W-correlation matrix for the reconstructed objects.</p>
</dd>
</dl>

<p>Additional (non-standard) graphical parameters which can be transfered via ...:
</p>

<dl>
<dt>plot.type</dt><dd><p>lattice plot type. This argument will be transfered as <code>type</code>
argument to function <code>panel.xyplot</code>.</p>
</dd>
<dt>ref</dt><dd><p>logical. Whether to plot zero-level lines in series-plot, eigenvectors-plot and paired-plot.
Zero-level isolines will be plotted for 2d-eigenvectors-plot.</p>
</dd>
<dt>symmetric</dt><dd><p>logical. Whether to use symmetric scales in series-plot, eigenvectors-plot and paired-plot.</p>
</dd>
<dt>useRaster</dt><dd><p>logical. For 2d-eigenvector-plot and wcor-plot, indicating whether raster representations
should be used. 'TRUE' by default.</p>
</dd>
<dt>col</dt><dd><p>color vector for colorscale (for 2d- and wcor-plots),
given by two or more colors,
the first color corresponds to the minimal value,
while the last one corresponds to the maximal value (will be interpolated by <code>colorRamp</code>)</p>
</dd>
<dt>zlim</dt><dd><p>for 2d-plot, range of displayed values</p>
</dd>
<dt>at</dt><dd><p>for 2d-eigenvectors-plot, a numeric vector giving breakpoints along the range of <code>z</code>,
a list of such vectors
or a character string.
If a list is given, corresponding list element (with recycling) will be used for each
plot panel.
For character strings, values 'free' and 'same' are allowed: 'free' means
special breakpoints' vectors (will be evaluated automatically, see description of <code>cuts</code>
argument in 'Details') for each component. 'same' means one breakpoints' vector for all
component (will be evaluated automatically too)</p>
</dd>
<dt>cuts</dt><dd><p>for 2d-reconstruction-plot, the number of levels the range of <code>z</code> would be divided into.</p>
</dd>
<dt>fill.color</dt><dd><p>color or 'NULL'. Defines background color for shaped 2d-eigenvectors plot. If 'NULL', standard white
background will be used.</p>
</dd>
</dl>



<h3>See Also</h3>

<p><code><a href="#topic+ssa-object">ssa-object</a></code>,
<code><a href="#topic+ssa">ssa</a></code>
<code><a href="#topic+plot.reconstruction">plot.reconstruction</a></code>,
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Decompose 'co2' series with default parameters
s &lt;- ssa(co2)
# Plot the eigenvalues
plot(s, type = "values")
# Plot W-cor matrix for first 10 reconstructed components
plot(s, type = "wcor", groups = 1:10)
# Plot the paired plot for first 6 eigenvectors
plot(s, type = "paired", idx = 1:6)
# Plot eigenvectors for first 6 components
plot(s, type = "vectors", idx = 1:6)
# Plot the first 4 reconstructed components
plot(s, type = "series", groups = list(1:4))
# Plot the eigenvalues by points only
plot(s, type = "values", plot.type = "p")

# Artificial image for 2dSSA
mx &lt;- outer(1:50, 1:50,
            function(i, j) sin(2*pi * i/17) * cos(2*pi * j/7) + exp(i/25 - j/20)) +
      rnorm(50^2, sd = 0.1)
# Decompose 'mx' with default parameters
s &lt;- ssa(mx, kind = "2d-ssa")
# Plot the eigenvalues
plot(s, type = "values")
# Plot eigenvectors for first 6 components
plot(s, type = "vectors", idx = 1:6,
     ref = TRUE, at = "same", cuts = 50,
     plot.contrib = TRUE, symmetric = TRUE)
# Plot factor vectors for first 6 components
plot(s, type = "vectors", vectors = "factor", idx = 1:6,
     ref = TRUE, at = "same", cuts = 50,
     plot.contrib = TRUE, symmetric = TRUE)
# Plot wcor for first 12 components
plot(s, type = "wcor", groups = 1:12, grid = c(2, 6))

# 3D-SSA example (2D-MSSA)
data(Barbara)
ss &lt;- ssa(Barbara, L = c(50, 50, 1))
plot(ss, type = "values")
plot(ss, type = "vectors", idx = 1:12, slice = list(k = 1),
     cuts = 50, plot.contrib = TRUE)
plot(ss, type = "vectors", idx = 1:12, slice = list(k = 1, i = 1))
plot(ss, type = "vectors", vectors = "factor", idx = 1:12, slice = list(k = 3),
     cuts = 50, plot.contrib = FALSE)
plot(ss, type = "series", groups = 1:12, slice = list(k = 1))
plot(ss, type = "series", groups = 1:12, slice = list(k = 1, i = 1))
plot(ss, plot.method = "xyplot", type = "series", groups = 1:12, slice = list(k = 1, i = 1))

</code></pre>

<hr>
<h2 id='plot.reconstruction'>Plot the results of SSA reconstruction</h2><span id='topic+plot.reconstruction'></span><span id='topic+plot.ssa.reconstruction'></span><span id='topic+plot.1d.ssa.reconstruction'></span><span id='topic+plot.toeplitz.ssa.reconstruction'></span><span id='topic+plot.mssa.reconstruction'></span><span id='topic+plot.2d.ssa.reconstruction'></span><span id='topic+plot.nd.ssa.reconstruction'></span>

<h3>Description</h3>

<p>Plot the result of SSA Reconstruction step
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class '1d.ssa.reconstruction'
plot(x, ...,
     type = c("raw", "cumsum"),
     plot.method = c("native", "matplot", "xyplot"),
     base.series = NULL,
     add.original = TRUE,
     add.residuals = TRUE)
## S3 method for class 'toeplitz.ssa.reconstruction'
plot(x, ...,
     type = c("raw", "cumsum"),
     plot.method = c("native", "matplot", "xyplot"),
     base.series = NULL,
     add.original = TRUE,
     add.residuals = TRUE)
## S3 method for class 'mssa.reconstruction'
plot(x,
     slice = list(),
     ...,
     type = c("raw", "cumsum"),
     plot.method = c("native", "matplot", "xyplot"),
     na.pad = c("left", "right"),
     base.series = NULL,
     add.original = TRUE,
     add.residuals = TRUE)
## S3 method for class '2d.ssa.reconstruction'
plot(x, ...,
     type = c("raw", "cumsum"),
     base.series = NULL,
     add.original = TRUE,
     add.residuals = TRUE,
     add.ranges,
     col = grey(c(0, 1)),
     zlim,
     at)
## S3 method for class 'nd.ssa.reconstruction'
plot(x, slice, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot.reconstruction_+3A_x">x</code></td>
<td>
<p>SSA object holding the decomposition</p>
</td></tr>
<tr><td><code id="plot.reconstruction_+3A_slice">slice</code></td>
<td>
<p>for &lsquo;mssa&rsquo;: list with elements named 'series' and 'components';
for &lsquo;nd.ssa&rsquo;: list with elements named 'i', 'j', 'k' or 'x', 'y', 'z', 't'
or 'd1', 'd2', ... or &lsquo;1', '2', ...; works like &rsquo;['-operator,
allows one to select which components from the reconstruction of
multivariate time series or which subarray from reconstruction of
multidimentional array to draw.</p>
</td></tr>
<tr><td><code id="plot.reconstruction_+3A_type">type</code></td>
<td>
<p>Type of the plot (see 'Details' for more information)</p>
</td></tr>
<tr><td><code id="plot.reconstruction_+3A_...">...</code></td>
<td>
<p>Arguments to be passed to methods, such as graphical
parameters</p>
</td></tr>
<tr><td><code id="plot.reconstruction_+3A_plot.method">plot.method</code></td>
<td>
<p>Plotting method to use: either ordinary all-in-one
via matplot or xyplot, or native plotting method of the input time
series</p>
</td></tr>
<tr><td><code id="plot.reconstruction_+3A_na.pad">na.pad</code></td>
<td>
<p>select how to pad the series of unequal length with NA's</p>
</td></tr>
<tr><td><code id="plot.reconstruction_+3A_base.series">base.series</code></td>
<td>
<p>another SSA reconstruction object, the series of
which should be considered as an original. Useful for plotting the
results of sequential SSA</p>
</td></tr>
<tr><td><code id="plot.reconstruction_+3A_add.original">add.original</code></td>
<td>
<p>logical, if 'TRUE' then the original series are added
to the plot</p>
</td></tr>
<tr><td><code id="plot.reconstruction_+3A_add.residuals">add.residuals</code></td>
<td>
<p>logical, if 'TRUE' then the residuals are added
to the plot</p>
</td></tr>
<tr><td><code id="plot.reconstruction_+3A_col">col</code></td>
<td>
<p>color vector for colorscale,
given by two or more colors,
the first color corresponds to the minimal value,
while the last one corresponds to the maximal value (will be interpolated by <code>colorRamp</code>)</p>
</td></tr>
<tr><td><code id="plot.reconstruction_+3A_zlim">zlim</code></td>
<td>
<p>for 2d-plot, range of displayed values</p>
</td></tr>
<tr><td><code id="plot.reconstruction_+3A_at">at</code></td>
<td>
<p>for 2d-eigenvectors-plot, a numeric vector giving breakpoints along the range of <code>z</code>,
a list of such vectors
or a character string.
If a list is given, corresponding list element (with recycling) will be used for each
plot panel.
For character strings, values 'free' and 'same' are allowed: 'free' means
special breakpoints' vectors (will be evaluated automatically, see description of <code>cuts</code>
argument in 'Details') for each component. 'same' means one breakpoints' vector for all
component (will be evaluated automatically too)</p>
</td></tr>
<tr><td><code id="plot.reconstruction_+3A_add.ranges">add.ranges</code></td>
<td>
<p>logical, if 'TRUE', the range of the components values
will be printed in panels captions</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Additional (non-standard) graphical parameters applicable to 2D SSA plots can be transfered via ...:
</p>

<dl>
<dt>cuts</dt><dd><p>the number of levels the range of image would be divided into.</p>
</dd>
<dt>ref</dt><dd><p>logical, whether to plot zero-level isolines</p>
</dd>
<dt>symmetric</dt><dd><p>logical, whether to use symmetric image range scale</p>
</dd>
<dt>useRaster</dt><dd><p>logical, indicates whether raster representations should be used. 'TRUE' by default.</p>
</dd>
<dt>fill.uncovered</dt><dd><p>single number, matrix, one of the following strings: 'mean', 'original', 'void'
or a list of such objects.
For shaped 2d-reconstruction-plot this argument defines filling
method for uncovered by window array elements on components and residuals plots.
If number, all uncovered elements will be replaced by it. If matrix, all uncovered elements will be replaced by
corresponding matrix elements. If 'mean', they will be replaced by mean value of current component. If 'original',
they will be replaced by corresponding elements of original array. 'void' (by default) means no filling.
If list is given, corresponding list element (with recycling) will be used for each plot panel.</p>
</dd>
<dt>fill.color</dt><dd><p>color or 'NULL'. Defines background color for shaped 2d-reconstruction plot. If 'NULL', standard white
background will be used.</p>
</dd>
</dl>



<h3>See Also</h3>

<p><code><a href="#topic+ssa-object">ssa-object</a></code>,
<code><a href="#topic+ssa">ssa</a></code>
<code><a href="#topic+reconstruct">reconstruct</a></code>,
<code><a href="#topic+plot">plot</a></code>,
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Decompose 'co2' series with default parameters
s &lt;- ssa(co2)
r &lt;- reconstruct(s, groups = list(c(1, 4), c(2, 3), c(5, 6)))
# Plot full 'co2' reconstruction into trend, periodic components and noise
plot(r)

# Artificial image for 2dSSA
mx &lt;- outer(1:50, 1:50,
            function(i, j) sin(2*pi * i/17) * cos(2*pi * j/7) + exp(i/25 - j/20)) +
      rnorm(50^2, sd = 0.1)
# Decompose 'mx' with default parameters
s &lt;- ssa(mx, kind = "2d-ssa")
# Reconstruct
r &lt;- reconstruct(s, groups = list(1, 2:5))
# Plot components, original image and residuals
plot(r)
# Plot cumulative sum of components only
plot(r, type = "cumsum", add.residuals = FALSE, add.original = FALSE)

# Real example: Mars photo
data(Mars)
# Decompose only Mars image (without backgroud)
s &lt;- ssa(Mars, mask = Mars != 0, wmask = circle(50), kind = "2d-ssa")
# Reconstruct and plot trend
plot(reconstruct(s, 1), fill.uncovered = "original")
# Reconstruct and plot texture pattern
plot(reconstruct(s, groups = list(c(13, 14, 17, 18))))

# Decompose 'EuStockMarkets' series with default parameters
s &lt;- ssa(EuStockMarkets, kind = "mssa")
r &lt;- reconstruct(s, groups = list(Trend = 1:2))
# Plot original series, trend and residuals superimposed
plot(r, plot.method = "xyplot", superpose = TRUE,
     auto.key = list(columns = 3),
     col = c("blue", "green", "red", "violet"),
     lty = c(rep(1, 4), rep(2, 4), rep(3, 4)))
# Plot the series separately
plot(r, plot.method = "xyplot", add.residuals = FALSE,
     screens = list(colnames(EuStockMarkets)),
     col = c("blue", "green", "red", "violet"),
     lty = c(rep(1, 4), rep(2, 4), rep(3, 4)))

# 3D-SSA example (2D-MSSA)
data(Barbara)
ss &lt;- ssa(Barbara, L = c(50, 50, 1))
plot(reconstruct(ss, groups = 1), slice = list(k = 1))

</code></pre>

<hr>
<h2 id='precache'>Calculates and caches elementary components inside SSA object</h2><span id='topic+precache'></span><span id='topic+precache.ssa'></span>

<h3>Description</h3>

<p>Calculates all the elementary series and saves inside SSA
object. After this the grouping procedure can be performed much
faster.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>precache(x, n, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="precache_+3A_x">x</code></td>
<td>
<p>SSA object</p>
</td></tr>
<tr><td><code id="precache_+3A_n">n</code></td>
<td>
<p>integer, number of series to calculate and save</p>
</td></tr>
<tr><td><code id="precache_+3A_...">...</code></td>
<td>
<p>further arguments passed to the reconstruction routines</p>
</td></tr>
</table>


<h3>Note</h3>

<p>In most cases it is not necessary to call this routine directly. By
default functions from the package collect all elementary
series they encounter during the calculations.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+reconstruct.ssa">reconstruct</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Decompose 'co2' series with default parameters
s &lt;- ssa(co2)
summary(s)
# Precache the stuff
precache(s)
summary(s)
</code></pre>

<hr>
<h2 id='reconstruct'>Perform a series reconstruction</h2><span id='topic+reconstruct'></span><span id='topic+reconstruct.ssa'></span>

<h3>Description</h3>

<p>Reconstruct the data given the SSA decomposition and the desired
grouping of the elementary components.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'ssa'
reconstruct(x, groups, ..., drop.attributes = FALSE, cache = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="reconstruct_+3A_x">x</code></td>
<td>
<p>SSA object</p>
</td></tr>
<tr><td><code id="reconstruct_+3A_groups">groups</code></td>
<td>
<p>list of numeric vectors, indices of elementary components
used for reconstruction, the entries of the list can be named, see
'Value' for more information</p>
</td></tr>
<tr><td><code id="reconstruct_+3A_...">...</code></td>
<td>
<p>further arguments passed to routines (e.g. to
<code>decompose</code> routine if the continuation is desired).</p>
</td></tr>
<tr><td><code id="reconstruct_+3A_drop.attributes">drop.attributes</code></td>
<td>
<p>logical, if 'TRUE' then the attributes of the
input objects are not copied to the reconstructed ones.</p>
</td></tr>
<tr><td><code id="reconstruct_+3A_cache">cache</code></td>
<td>
<p>logical, if 'TRUE' then intermediate results will be
cached in the SSA object.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Reconstruction is performed in a common form for different types of input objects.
See Section 1.1.2.6 in Golyandina et al (2018) for the explanation.
Formal algorithms are described in this book in Algorithm 2.2 for 1D-SSA, Algorithm 4.3 for MSSA,
Algorithm 5.2 for 2D-SSA and Algorithm 5.6 for Shaped 2D-SSA.
</p>
<p>Fast implementation of reconstruction with the help of FFT is described in Korobeynikov (2010)
for the 1D case and in Section 6.2 (Rank-one quasi-hankelization) of Golyandina et al (2015) 
for the general case.
</p>


<h3>Value</h3>

<p>List of reconstructed objects. Elements of the list have the same
names as elements of <code>groups</code>. If the group is unnamed, then
corresponding component will obtain name &lsquo;Fn&rsquo;, where &lsquo;n&rsquo; is its index
in <code>groups</code> list.
</p>


<h3>Note</h3>

<p>By default (argument <code>drop.attributes</code>) the routine tries to
preserve all the attributes of the input object. This way, for
example, the reconstruction result of 'ts' object is the 'ts' object
with the same time scale.
</p>


<h3>References</h3>

<p>Golyandina N., Korobeynikov A., Zhigljavsky A. (2018):
<em>Singular Spectrum Analysis with R.</em>  Use R!.
Springer, Berlin, Heidelberg.
</p>
<p>Korobeynikov, A. (2010): <em>Computation- and space-efficient
implementation of SSA.</em> Statistics and Its Interface, Vol. 3, No. 3,
Pp. 257-268
</p>
<p>Golyandina, N., Korobeynikov, A., Shlemov, A. and Usevich, K. (2015):
<em>Multivariate and 2D Extensions of Singular Spectrum Analysis
with the Rssa Package</em>. Journal of Statistical Software, Vol. 67, Issue 2.
<a href="https://doi.org/10.18637/jss.v067.i02">doi:10.18637/jss.v067.i02</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+Rssa">Rssa</a></code> for an overview of the package, as well as,
<code><a href="#topic+ssa-input">ssa-input</a></code>,  
<code><a href="#topic+ssa">ssa</a></code>,
<code><a href="#topic+plot.reconstruction">plot.reconstruction</a></code>,
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Decompose 'co2' series with default parameters
s &lt;- ssa(co2)
# Reconstruct the series, grouping elementary series.
r &lt;- reconstruct(s, groups = list(Trend = c(1, 4), Season1 = c(2,3), Season2 = c(5, 6)))
plot(r)
# 'groups' argument might contain duplicate entries as well
r &lt;- reconstruct(s, groups = list(1, 1:4, 1:6))
plot(r)


# Real example: Mars photo
data(Mars)
# Decompose only Mars image (without backgroud)
s &lt;- ssa(Mars, mask = Mars != 0, wmask = circle(50), kind = "2d-ssa")
# Reconstruct and plot trend
plot(reconstruct(s, 1), fill.uncovered = "original")
# Reconstruct and plot texture pattern
plot(reconstruct(s, groups = list(c(13, 14, 17, 18))))

# Decompose 'EuStockMarkets' series with default parameters
s &lt;- ssa(EuStockMarkets, kind = "mssa")
r &lt;- reconstruct(s, groups = list(Trend = 1:2))
# Plot original series, trend and residuals superimposed
plot(r, plot.method = "xyplot", superpose = TRUE,
     auto.key = list(columns = 3),
     col = c("blue", "green", "red", "violet"),
     lty = c(rep(1, 4), rep(2, 4), rep(3, 4)))

</code></pre>

<hr>
<h2 id='residuals'>Obtain the residuals from SSA reconstruction</h2><span id='topic+residuals.ssa'></span><span id='topic+residuals.ssa.reconstruction'></span>

<h3>Description</h3>

<p>Obtain the residuals from SSA reconstruction
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'ssa'
residuals(object, groups, ..., cache = TRUE)
## S3 method for class 'ssa.reconstruction'
residuals(object, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="residuals_+3A_object">object</code></td>
<td>
<p>input object</p>
</td></tr>
<tr><td><code id="residuals_+3A_groups">groups</code></td>
<td>
<p>list of numeric vectors, indices of elementary components
used for reconstruction, the entries of the list can be named.</p>
</td></tr>
<tr><td><code id="residuals_+3A_...">...</code></td>
<td>
<p>further arguments passed to <code>reconstruct</code> routine</p>
</td></tr>
<tr><td><code id="residuals_+3A_cache">cache</code></td>
<td>
<p>logical, if 'TRUE' then intermediate results will be
cached in the SSA object.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function calculates the residuals either from SSA object
corresponding to reconstruction using <code>groups</code> arguments, or just
extracts the residuals from reconstruction object.
</p>


<h3>Value</h3>

<p>residuals object
</p>


<h3>See Also</h3>

<p><code><a href="#topic+Rssa">Rssa</a></code> for an overview of the package, as well as,
<code><a href="#topic+reconstruct">reconstruct</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Decompose 'co2' series with default parameters
s &lt;- ssa(co2)
# Reconstruct the series, grouping elementary series.
r &lt;- reconstruct(s, groups = list(c(1, 4), c(2,3), c(5, 6)))
print(residuals(r))

# If there are several groups, then the residuals are calculated as
# residuals for the model corresponding to the combined model.
r &lt;- reconstruct(s, groups = list(c(6, 7), c(6,7), c(8, 9)))
r1 &lt;- reconstruct(s, groups = list(6:9))
max(abs(residuals(r) - residuals(r1))) # 0 
max(abs(co2 - (r1$F1 + residuals(r1)))) # 0
</code></pre>

<hr>
<h2 id='rforecast'>Perform recurrent SSA forecasting of the series</h2><span id='topic+rforecast'></span><span id='topic+rforecast.default'></span><span id='topic+rforecast.ssa'></span><span id='topic+rforecast.1d.ssa'></span><span id='topic+rforecast.toeplitz.ssa'></span><span id='topic+rforecast.mssa'></span><span id='topic+rforecast.cssa'></span><span id='topic+rforecast.pssa.1d.ssa'></span>

<h3>Description</h3>

<p>Perform recurrent SSA forecasting of the series.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class '1d.ssa'
rforecast(x, groups, len = 1, base = c("reconstructed", "original"),
          only.new = TRUE, reverse = FALSE, ...,
          drop = TRUE, drop.attributes = FALSE, cache = TRUE)
## S3 method for class 'toeplitz.ssa'
rforecast(x, groups, len = 1, base = c("reconstructed", "original"),
          only.new = TRUE, reverse = FALSE, ...,
          drop = TRUE, drop.attributes = FALSE, cache = TRUE)
## S3 method for class 'mssa'
rforecast(x, groups, len = 1, base = c("reconstructed", "original"),
          direction = c("row", "column"), only.new = TRUE, ..., drop = TRUE,
          drop.attributes = FALSE, cache = TRUE)
## S3 method for class 'cssa'
rforecast(x, groups, len = 1, base = c("reconstructed", "original"),
          only.new = TRUE, reverse = FALSE, ...,
          drop = TRUE, drop.attributes = FALSE, cache = TRUE)
## S3 method for class 'pssa.1d.ssa'
rforecast(x, groups, len = 1, base = c("reconstructed", "original"),
          only.new = TRUE, reverse = FALSE, ...,
          drop = TRUE, drop.attributes = FALSE, cache = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="rforecast_+3A_x">x</code></td>
<td>
<p>SSA object holding the decomposition</p>
</td></tr>
<tr><td><code id="rforecast_+3A_groups">groups</code></td>
<td>
<p>list, the grouping of eigentriples to be used in the forecast</p>
</td></tr>
<tr><td><code id="rforecast_+3A_len">len</code></td>
<td>
<p>integer, the desired length of the forecasted series</p>
</td></tr>
<tr><td><code id="rforecast_+3A_base">base</code></td>
<td>
<p>series used as a 'seed' of forecast: original or
reconstructed according to the value of <code>groups</code> argument</p>
</td></tr>
<tr><td><code id="rforecast_+3A_direction">direction</code></td>
<td>
<p>direction of forecast in multichannel SSA case, &quot;column&quot;
stands for so-called L-forecast and &quot;row&quot; stands for K-forecast</p>
</td></tr>
<tr><td><code id="rforecast_+3A_only.new">only.new</code></td>
<td>
<p>logical, if 'TRUE' then only forecasted values are returned,
whole series otherwise</p>
</td></tr>
<tr><td><code id="rforecast_+3A_reverse">reverse</code></td>
<td>
<p>logical, direction of forecast in 1D SSA case, 'FALSE'
(default) means that the forecast moves forward in the time and
'TRUE' means the opposite</p>
</td></tr>
<tr><td><code id="rforecast_+3A_...">...</code></td>
<td>
<p>additional arguments passed to <code><a href="#topic+reconstruct">reconstruct</a></code>
routines</p>
</td></tr>
<tr><td><code id="rforecast_+3A_drop">drop</code></td>
<td>
<p>logical, if 'TRUE' then the result is coerced to series
itself, when possible (length of 'groups' is one)</p>
</td></tr>
<tr><td><code id="rforecast_+3A_drop.attributes">drop.attributes</code></td>
<td>
<p>logical, if 'TRUE' then the attributes of the input series
are not copied to the reconstructed ones.</p>
</td></tr>
<tr><td><code id="rforecast_+3A_cache">cache</code></td>
<td>
<p>logical, if 'TRUE' then intermediate results will be
cached in the SSA object.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The routines applies the recurrent SSA forecasting algorithm to
produce the new series which is expected to 'continue' the current
series on the basis of a given decomposition. The algorithm
sequentialy projects the incomplete embedding vectors (from either the original
or the reconstructed series) onto the subspace spanned by the
selected eigentriples of the decomposition to derive the missed
(last) values of the such vectors. Then the filled value 
In such a way the forecasting elements are produced on
one-by-one basis.
</p>
<p>It is shown in Golyandina et al (2001) that this approach corresponds
to application of a linear recurrence formula (the same formula as 
described in <code><a href="#topic+lrr">lrr</a></code>) to initial data taken from either the original
or the reconstructed series.
</p>
<p>In particular, the <code class="reqn">m</code>-th step of the forecast is calculated by
means of linear recurrence relation (see <code><a href="#topic+lrr">lrr</a></code>) as
<code class="reqn">y_{n+m}=\sum_{k=1}^{L-1} a_k y_{n+m-k}</code> where the starting points
<code class="reqn">y_{n-(L-2)}</code>, ..., <code class="reqn">y_{n}</code> are taken from the reconstructed
time series (<code>base="reconstructed"</code>) or from the initial
(<code>base="initial"</code>) time series.
</p>
<p>For multichannel SSA the column forecast is obtained via applying the
LRR to each series separately. The row forecast is more complicated
and is based on a multivariate LRR. Forecast uses the formulae from
Golyandina and Stepanov (2005) and Golyandina et.al (2015).
</p>
<p>For details of 1D-SSA recurrent forecasting, see Section 3.2.1.2 and 
Algorithm 3.5 in Golyandina et al (2018).
For details of MSSA recurrent forecasting, see Section 4.3.1.2  and 
Algorithm 4.4 (column forecasting).
</p>


<h3>Value</h3>

<p>List of forecasted objects. Elements of the list have the same names
as elements of <code>groups</code>. If group is unnamed, corresponding
component gets name &lsquo;Fn&rsquo;, where &lsquo;n&rsquo; is its index in <code>groups</code>
list.
</p>
<p>Or, the forecasted object itself, if length of groups is one and 'drop = TRUE'.
</p>


<h3>References</h3>

<p>Golyandina, N., Nekrutkin, V. and Zhigljavsky, A. (2001): <em>Analysis of
Time Series Structure: SSA and related techniques.</em> Chapman and
Hall/CRC. ISBN 1584881941
</p>
<p>Golyandina, N., Korobeynikov, A., Shlemov, A. and Usevich, K. (2015):
<em>Multivariate and 2D Extensions of Singular Spectrum Analysis
with the Rssa Package</em>. Journal of Statistical Software, Vol. 67, Issue 2.
<a href="https://doi.org/10.18637/jss.v067.i02">doi:10.18637/jss.v067.i02</a>
</p>
<p>Golyandina, N. and Stepanov, D. (2005): <em>SSA-based approaches to
analysis and forecast of multidimensional time series</em>. In
Proceedings of the 5th St.Petersburg Workshop on Simulation, June
26-July 2, 2005, St. Petersburg State University, St. Petersburg,
293&ndash;298. <a href="https://www.gistatgroup.com/gus/mssa2.pdf">https://www.gistatgroup.com/gus/mssa2.pdf</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+Rssa">Rssa</a></code> for an overview of the package, as well as,
<code><a href="#topic+forecast">forecast</a></code>,
<code><a href="#topic+vforecast">vforecast</a></code>,
<code><a href="#topic+bforecast">bforecast</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Decompose 'co2' series with default parameters
s &lt;- ssa(co2)
# Produce 24 forecasted values of the series using different sets of eigentriples
# as a base space for the forecast.
rfor &lt;- rforecast(s, groups = list(c(1,4), 1:4), len = 24, only.new=FALSE)
matplot(data.frame(c(co2, rep(NA, 24)), rfor), type = "l")

# Forecast `co2' trend by SSA with projections
s &lt;- ssa(co2, column.projector = 2, row.projector = 2)
len &lt;- 100
rfor &lt;- rforecast(s, groups = list(trend = seq_len(nspecial(s))), len = len, only.new = FALSE)
matplot(data.frame(c(co2, rep(NA, len)), rfor), type = "l")

# Forecast finite rank series with polynomial component by SSA with projections
v &lt;- 5000 * sin(2*pi / 13 * (1:100)) +  (1:100)^2 + 10000
s &lt;- ssa(v, row.projector = 2, column.projector = 2)
plot(rforecast(s, groups = list(all = 1:6), len = 100, only.new = FALSE), type = "l")
</code></pre>

<hr>
<h2 id='ssa'>Create a new SSA object</h2><span id='topic+ssa'></span><span id='topic+new.ssa'></span>

<h3>Description</h3>

<p>Set up the SSA object and perform the decomposition, if necessary.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ssa(x,
    L = (N + 1) %/% 2,
    neig = NULL,
    mask = NULL,
    wmask = NULL,
    column.projector = "none",
    row.projector = "none",
    column.oblique = "identity",
    row.oblique = "identity",
    ...,
    kind = c("1d-ssa", "2d-ssa", "nd-ssa", "toeplitz-ssa", "mssa", "cssa"),
    circular = FALSE,
    svd.method = c("auto", "nutrlan", "propack", "svd", "eigen", 
                   "rspectra", "primme", "irlba", "rsvd"),
    force.decompose = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ssa_+3A_x">x</code></td>
<td>
<p>object to be decomposed. See
<code><a href="#topic+ssa-input">ssa-input</a></code> for more information</p>
</td></tr>
<tr><td><code id="ssa_+3A_l">L</code></td>
<td>
<p>integer, window length. Fixed to half of the series length by
default. Should be vector of length 2 for 2d SSA</p>
</td></tr>
<tr><td><code id="ssa_+3A_neig">neig</code></td>
<td>
<p>integer, number of desired eigentriples. If 'NULL', then
sane default value will be used, see 'Details'</p>
</td></tr>
<tr><td><code id="ssa_+3A_mask">mask</code></td>
<td>
<p>for shaped 2d SSA case only. Logical matrix with same dimension as
<code>x</code>. Specifies form of decomposed array. If 'NULL', then all
non-NA elements will be used</p>
</td></tr>
<tr><td><code id="ssa_+3A_wmask">wmask</code></td>
<td>
<p>for shaped 2d SSA case only. Logical matrix which specifies window form.
See &lsquo;Details&rsquo; for more information about the window shape selection</p>
</td></tr>
<tr><td><code id="ssa_+3A_...">...</code></td>
<td>
<p>further arguments passed to <code><a href="#topic+decompose.ssa">decompose</a></code> </p>
</td></tr>
<tr><td><code id="ssa_+3A_kind">kind</code></td>
<td>
<p>SSA method. This includes ordinary 1d SSA, 2d SSA,
Toeplitz variant of 1d SSA, multichannel variant of SSA and complex
SSA</p>
</td></tr>
<tr><td><code id="ssa_+3A_circular">circular</code></td>
<td>
<p>logical vector of one or two elements, describes series topology for
1d SSA and Toeplitz SSA or field topology for 2d SSA. 'TRUE' means
series circularity for 1d case or circularity by a corresponding
coordinate for 2d case. See Shlemov and Golyandina (2014) for more information</p>
</td></tr>
<tr><td><code id="ssa_+3A_svd.method">svd.method</code></td>
<td>
<p>singular value decomposition method. See 'Details'
for more info</p>
</td></tr>
<tr><td><code id="ssa_+3A_column.projector">column.projector</code>, <code id="ssa_+3A_row.projector">row.projector</code></td>
<td>
<p>column and row signal subspaces projectors for
SSA with projection. See &lsquo;Details&rsquo; for information about methods of
projectors specification</p>
</td></tr>
<tr><td><code id="ssa_+3A_column.oblique">column.oblique</code>, <code id="ssa_+3A_row.oblique">row.oblique</code></td>
<td>
<p>column and row matrix weights for 
Weighted Oblique SSA. See &lsquo;Details&rsquo; for information about how to use this feature</p>
</td></tr>
<tr><td><code id="ssa_+3A_force.decompose">force.decompose</code></td>
<td>
<p>logical, if 'TRUE' then the decomposition is
performed before return.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This is the main entry point to the package. This routine
constructs the SSA object filling all necessary internal structures
and performing the decomposition if necessary.
For the comprehensive description of SSA modifications and their algorithms
see Golyandina et al (2018). 
</p>


<h4>Variants of SSA</h4>

<p>The following implementations of the SSA method are supported
(corresponds to different values of <code>kind</code> argument):
</p>

<dl>
<dt>1d-ssa</dt><dd><p>Basic 1d SSA as described in Chapter 1 of Golyandina et al (2001).
This is also known as Broomhead-King variant of SSA or
BK-SSA, see Broomhead and King (1986).</p>
</dd>
<dt>toeplitz-ssa</dt><dd><p>Toeplitz variant of 1d SSA. See Section 1.7.2
in Golyandina et al (2001). This is also known as Vautard-Ghil
variant of SSA or VG-SSA for analysis of stationary time series,
see Vautard and Ghil (1989).</p>
</dd>
<dt>mssa</dt><dd><p>Multichannel SSA for simultaneous decomposition of
several time series (possible of unequal length). See
Golyandina and Stepanov (2005).</p>
</dd>
<dt>cssa</dt><dd><p>Complex variant of 1d SSA.</p>
</dd>
<dt>2d-ssa</dt><dd><p>2d SSA for decomposition of images and arrays. See
Golyandina and Usevich (2009) and Golyandina et.al (2015) for more information.</p>
</dd>
<dt>nd-ssa</dt><dd><p>Multidimensional SSA decomposition for arrays (tensors).</p>
</dd>
</dl>




<h4>Window shape selection (for shaped 2d SSA)</h4>

<p>Window shape may be specified by argument <code>wmask</code>. If <code>wmask</code> is 'NULL',
then standard rectangular window (specified by <code>L</code>) will be used.
</p>
<p>Also in <code>wmask</code> one may use following functions:
</p>

<dl>
<dt>circle(R)</dt><dd><p>circular mask of radius <code>R</code></p>
</dd>
<dt>triangle(side)</dt><dd><p>mask in form of isosceles right-angled triangle with
cathetus <code>side</code>. Right angle lay on topleft corner of container square
matrix</p>
</dd>
</dl>

<p>These functions are not exported, they defined only for <code>wmask</code> expression.
If one has objects with the same names and wants to use them rather than these functions,
one should use special wrapper function <code>I()</code> (see 'Examples'). 
</p>



<h4>Projectors specification for SSA with projection</h4>

<p>Projectors are specified by means of <code>column.projector</code> and
<code>row.projector</code> arguments (see Golyandina and Shlemov (2017)). 
Each may be a matrix of orthonormal
(otherwise QR orthonormalization process will be perfomed) basis of
projection subspace, or single integer, which will be interpreted as
dimension of orthogonal polynomial basis (note that the dimension
equals to degree plus 1, e.g. quadratic basis has dimension 3), or
one of following character strings (or unique prefix): 'none',
'constant' (or 'centering'), 'linear', 'quadratic' or 'qubic' for
orthonormal bases of the corresponding functions.
</p>
<p>Here is the the list of the most used options
</p>

<dl>
<dt>both projectors are 'none'</dt><dd><p>corresponds to ordinary 1D SSA,</p>
</dd>
<dt>column.projector='centering'</dt><dd><p>corresponds to 1D SSA
with centering,</p>
</dd>
<dt>column.projector='centering' and
row.projector='centering'</dt><dd><p>corresponds to 1D SSA with double
centering.</p>
</dd>
</dl>

<p>SSA with centering and double centering may improve the separation
of linear trend (see Golyandina et.al (2001) for more information).
</p>



<h4>Weighted Oblique SSA</h4>

<p>Corresponding matrix norm weights may be specified for ordinary 1D SSA case 
by means of <code>column.oblique</code> and <code>row.oblique</code> arguments. These 
arguments should be either 'identical' or positive numeric vectors of length 
<code>L</code> and <code>N - L + 1</code> for <code>column.oblique</code> and 
<code>row.oblique</code> respectively.
</p>
<p>Weighted Oblique SSA inside <code><a href="#topic+cadzow">Cadzow</a></code> iterations 
may improve finite-rank estimation of signal 
(see e.g. Cadzow(alpha) iterations in Zvonarev and Golyandina (2017) 
for more information).
</p>



<h4>SVD methods</h4>

<p>The main step of the SSA method is the singular decomposition of the
so-called series trajectory matrix. Package provides several
implementations of this procedure (corresponds to different values of
<code>svd.method</code>) argument:
</p>

<dl>
<dt>auto</dt><dd><p>Automatic method selection depending on the series length,
window length, SSA kind and number of eigenvalues
requested.</p>
</dd>
<dt>nutrlan</dt><dd><p>Thick-restart Lanczos eigensolver which operates on
cross-product matrix. This methods exploits the Hankel structure of
the trajectory matrix efficiently and is really fast. The method
allows the truncated SVD (only specifid amount of eigentriples to be
computed) and the continuation of the decomposition. See
Korobeynikov (2010) for more information.</p>
</dd>
<dt>propack</dt><dd><p>SVD via implicitly restarted Lanczos
bidiagonalization with partial reothogonalization. This methods
exploits the Hankel structure of the trajectory matrix efficiently
and is really fast. This is the 'proper' SVD implementation (the
matrix of factor vectors are calculated), thus the memory
requirements of the methods are higher than for nu-TRLAN. Usually
the method is slightly faster that nu-TRLAN and more numerically
stable. The method allows the truncated SVD (only specifid amount
of eigentriples to be computed). See Korobeynikov (2010) for more
information.</p>
</dd>
<dt>svd</dt><dd><p>Full SVD as provided by LAPACK DGESDD
routine. Neither continuation of the decomposition nor the
truncated SVD is supported. The method does not assume anything
special about the trajectory matrix and thus is slow.</p>
</dd>
<dt>eigen</dt><dd><p>Full SVD via eigendecompsition of the cross-product
matrix. In many cases faster than previous method, but still
really slow for more or less non-trivial matrix sizes.</p>
</dd>
<dt>rspectra</dt><dd><p>SVD via <code>svds</code> function from Rspectra package
(if installed)</p>
</dd>
<dt>primme</dt><dd><p>SVD via <code>svds</code> function from PRIMME package
(if installed)</p>
</dd>
<dt>irlba</dt><dd><p>SVD via <code>svds</code> function from irlba package
(if installed)</p>
</dd>
<dt>rsvd</dt><dd><p>SVD via <code>svdr</code> function from irlba package
(if installed)</p>
</dd>
</dl>

<p>Usually the <code>ssa</code> function tries to provide the best SVD
implementation for given series length and the window size. In
particular, for small series and window sizes it is better to use
generic black-box routines (as provided by 'svd' and 'eigen'
methods). For long series special-purpose routines are to be used.
</p>



<h3>Value</h3>

<p>Object of class &lsquo;ssa&rsquo;. The precise layout of the object is mostly
meant opaque and subject to change in different version of the
package. See <code><a href="#topic+ssa-object">ssa-object</a></code> for details.
</p>


<h3>References</h3>

<p>Golyandina N., Korobeynikov A., Zhigljavsky A. (2018):
<em>Singular Spectrum Analysis with R.</em>  Use R!.
Springer, Berlin, Heidelberg.
</p>
<p>Broomhead, D.S., and King, G.P. (1986a): <em>Extracting qualitative
dynamics from experimental data</em>, Physica D, 20, 217&ndash;236.
</p>
<p>Vautard, R., and Ghil, M. (1989): <em>Singular spectrum analysis in
nonlinear dynamics, with applications to paleoclimatic time series</em>,
Physica D, 35, 395&ndash;424.
</p>
<p>Golyandina, N., Nekrutkin, V. and Zhigljavsky, A. (2001): <em>Analysis of
Time Series Structure: SSA and related techniques.</em> Chapman and
Hall/CRC. ISBN 1584881941
</p>
<p>Golyandina, N. and Stepanov, D. (2005): <em>SSA-based approaches to
analysis and forecast of multidimensional time series</em>. In
Proceedings of the 5th St.Petersburg Workshop on Simulation, June
26-July 2, 2005, St. Petersburg State University, St. Petersburg,
293&ndash;298. <a href="https://www.gistatgroup.com/gus/mssa2.pdf">https://www.gistatgroup.com/gus/mssa2.pdf</a>
</p>
<p>Golyandina, N. and Usevich, K. (2009): <em>2D-extensions of singular
spectrum analysis: algorithm and elements of theory.</em> In Matrix
Methods: Theory, Algorithms, Applications. World Scientific
Publishing, 450-474.
</p>
<p>Korobeynikov, A. (2010): <em>Computation- and space-efficient
implementation of SSA.</em> Statistics and Its Interface, Vol. 3, No. 3,
Pp. 257-268
</p>
<p>Golyandina, N., Korobeynikov, A. (2012, 2014): <em>Basic Singular Spectrum
Analysis and Forecasting with R.</em> Computational Statistics and Data
Analysis, Vol. 71, Pp. 934-954. <a href="https://arxiv.org/abs/1206.6910">https://arxiv.org/abs/1206.6910</a>
</p>
<p>Golyandina, N., Zhigljavsky, A. (2013): <em>Singular Spectrum
Analysis for time series</em>. Springer Briefs in Statistics. Springer.
</p>
<p>Shlemov, A. and Golyandina, N. (2014): <em>Shaped extensions of singular
spectrum analysis</em>. 21st International Symposium on Mathematical 
Theory of Networks and Systems, July 7-11, 2014. Groningen, 
The Netherlands. p.1813-1820. <a href="https://arxiv.org/abs/1507.05286">https://arxiv.org/abs/1507.05286</a>
</p>
<p>Golyandina, N., Korobeynikov, A., Shlemov, A. and Usevich, K. (2015):
<em>Multivariate and 2D Extensions of Singular Spectrum Analysis
with the Rssa Package</em>. Journal of Statistical Software, Vol. 67, Issue 2.
<a href="https://doi.org/10.18637/jss.v067.i02">doi:10.18637/jss.v067.i02</a>
</p>
<p>Golyandina, N. and Shlemov, A. (2017): <em>Semi-nonparametric singular 
spectrum analysis with projection</em>. Statistics and its Interface, Vol. 10, 
Issue 1, p. 47-57.
<a href="https://arxiv.org/abs/1401.4980">https://arxiv.org/abs/1401.4980</a>
</p>
<p>Zvonarev, N. and Golyandina, N. (2017): <em>Iterative algorithms for weighted and 
unweighted finite-rank time-series approximations</em>. Statistics and its Interface,
Vol. 10, Issue 1, p. 5-18.
<a href="https://arxiv.org/abs/1507.02751">https://arxiv.org/abs/1507.02751</a>
</p>


<h3>See Also</h3>

<p><code><a href="svd.html#topic+svd">svd</a></code>,
<code><a href="#topic+ssa-object">ssa-object</a></code>,
<code><a href="#topic+ssa-input">ssa-input</a></code>,
<code><a href="#topic+ssa.capabilities">ssa.capabilities</a></code>,
<code><a href="#topic+decompose.ssa">decompose</a></code>,
<code><a href="#topic+reconstruct">reconstruct</a></code>,
<code><a href="#topic+plot">plot</a></code>,
<code><a href="#topic+forecast">forecast</a></code>,
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Decompose 'co2' series with default parameters
s &lt;- ssa(co2)
# Show the summary
summary(s)
# Reconstruct the series, with suitable grouping
r &lt;- reconstruct(s, groups = list(c(1, 4), c(2, 3), c(5, 6)))

plot(r)


# Decompose 'EuStockMarkets' series with default parameters
s &lt;- ssa(EuStockMarkets, kind = "mssa")
r &lt;- reconstruct(s, groups = list(Trend = 1:2))
# Plot original series, trend and residuals superimposed

plot(r, plot.method = "xyplot", superpose = TRUE,
     auto.key = list(columns = 3),
     col = c("blue", "green", "red", "violet"),
     lty = c(rep(1, 4), rep(2, 4), rep(3, 4)))


# Artificial image for 2dSSA
mx &lt;- outer(1:50, 1:50,
            function(i, j) sin(2*pi * i/17) * cos(2*pi * j/7) + exp(i/25 - j/20)) +
      rnorm(50^2, sd = 0.1)
# Decompose 'mx' with circular window
s &lt;- ssa(mx, kind = "2d-ssa", wmask = circle(5), neig = 10)
# Reconstruct
r &lt;- reconstruct(s, groups = list(1, 2:5))

# Plot components, original image and residuals
plot(r)


# Real example: Mars photo
data(Mars)
# Decompose only Mars image (without backgroud)
s &lt;- ssa(Mars, mask = Mars != 0, wmask = circle(50), kind = "2d-ssa")

# Plot eigenarrays
plot(s, type = "vectors", idx = 1:25)
# Plot factor arrays
plot(s, type = "vectors", vectors = "factor", idx = 1:25)
# Reconstruct and plot trend
plot(reconstruct(s, 1), fill.uncovered = "original")
# Reconstruct and plot texture pattern
plot(reconstruct(s, groups = list(c(13,14, 17, 18))))

# I()-wrapper demo
circle &lt;- 50
s &lt;- ssa(Mars, wmask = circle(R = I(circle)))

# CSSA-based trend extraction
s &lt;- ssa(EuStockMarkets[, 1] + 1.0i*EuStockMarkets[, 2], kind = "cssa")
r &lt;- reconstruct(s, groups = list(Trend = 1:2))
plot(r)

# `co2' decomposition with double projection to linear functions
s &lt;- ssa(co2, column.projector = "centering", row.projector = "centering")
plot(reconstruct(s, groups = list(trend = seq_len(nspecial(s)))))


# Artificial 2d example with double projection
ii &lt;- matrix(1:100, 100, 100); jj &lt;- t(ii)
x &lt;- ii + 2 * jj
s &lt;- ssa(x, column.projector = "centering", row.projector = "centering")
plot(s)
plot(reconstruct(s, groups = list(trend = seq_len(nspecial(s)))))

# 3D-SSA example (2D-MSSA)
data(Barbara)
Barbara.noised &lt;- Barbara

# Corrupt image by regular noise
noise &lt;- outer(seq_len(dim(Barbara)[1]),
               seq_len(dim(Barbara)[2]),
               function(i, j) sin(2*pi * (i/13 + j/23)))
Barbara.noised[,, 1] &lt;- Barbara.noised[,, 1] + 10 * noise
Barbara.noised[,, 2] &lt;- Barbara.noised[,, 2] + 30 * noise
Barbara.noised[,, 3] &lt;- Barbara.noised[,, 3] + 5 * noise

# Normalize image for plotting
Barbara.noised &lt;- (Barbara.noised - min(Barbara.noised)) / diff(range(Barbara.noised))

plot(c(0, 1), c(0, 1), type = "n", xlab = "", ylab = "")
rasterImage(Barbara.noised, 0, 0, 1, 1, interpolate = FALSE)


# Multichannel 2D-SSA
ss &lt;- ssa(Barbara.noised, L = c(50, 50, 1))
plot(ss, type = "series", groups = 1:18, slice = list(k = 1))
plot(ss, type = "vectors", idx = 1:12, slice = list(k = 1))
plot(ss, type = "vectors", vectors = "factor", idx = 1:12, slice = list(k = 3))
# Denoise image
Barbara.rec &lt;- residuals(ss, groups = 5:6)
plot(c(0, 1), c(0, 1), type = "n", xlab = "", ylab = "")
rasterImage(Barbara.rec, 0, 0, 1, 1, interpolate = FALSE)

</code></pre>

<hr>
<h2 id='ssa-input'>Input Data Formats Used by SSA Routines</h2><span id='topic+ssa-input'></span>

<h3>Description</h3>

<p>The inputs of SSA can be quite different depending on the kind of SSA
used. However, there is a common of all the variants of SSA and all
the routines. The package tries hard to preserve the specifics of
input object as much as possible. This means, that all the attributes,
etc. are copied back to the reconstructed objects. This way, the
result of the SSA decomposition of a 'ts' object is a 'ts' object as
well.
</p>
<p>For forecasting, it is not possible in general to preserve the
attributes of the input objects. However, <code>Rssa</code> knows about some
common time series classes (e.g. 'ts') and tries to infer the time
scales for forecasted objects as well.
</p>
<p>The input formats are as follows:
</p>


<h4>1d SSA and Toeplitz SSA</h4>

<p>Input is assumed to be a simple vector, or vector-like object
(e.g. univariare 'ts' or 'zooreg' object). Everything else is
coerced to vector.
</p>



<h4>2d SSA</h4>

<p>Input assumed to be a matrix. If there are any <code>NA</code>'s then the
shaped variant of 2d SSA will be used. All non-<code>NA</code> elements
will be used as a mask.
</p>



<h4>nd SSA</h4>

<p>Input assumed to be an array of arbitrary dimension. If there are any
<code>NA</code>'s then the shaped variant will be used.
</p>



<h4>MSSA</h4>

<p>While the representation of a one dimensional time series in
R is pretty obvious, there are multiple possible ways of
defining the multivariate time series. Let us outline some common
choices.
</p>

<ul>
<li><p> Matrix with separate series in the columns. Optionally,
additional time structure like in 'mts' objects, can be embedded.
</p>
</li>
<li><p> Matrix-like (e.g. a 'data.frame') object with series in the
columns. In particular, 'data.frame' would be a result of reading
the series from the file via 'read.table' function.
</p>
</li>
<li><p> List of separate time series objects (e.g. a 'list' of 'ts'
or 'zoo' objects).
</p>
</li></ul>

<p>Also, the time scales of the individual time series can be
normalized via head or tail padding with <code>NA</code> (for example, as
a result of the <code>ts.union</code> call), or specified via time series
attributes. Or, everything can be mixed all together.
</p>
<p>The <code>ssa</code> routine with 'kind = mssa' allows one to provide any
of the outlined multivariate series formats. As usual, all the
attributes, names of the series, NA padding, etc. is carefully
preserved.
</p>



<h4>CSSA</h4>

<p>Complex vectors are assumed at the input.
</p>



<h3>See Also</h3>

<p><code><a href="#topic+ssa">ssa</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>s &lt;- ssa(co2) # Perform the decomposition using the default window length
r &lt;- reconstruct(s, groups = list(Trend = c(1, 4),
                                  Seasonality = c(2, 3))) # Reconstruct into 2 series
class(r$Trend) # Result is 'ts' object

# Simultaneous trend extraction using MSSA
s &lt;- ssa(EuStockMarkets, kind = "mssa")
r &lt;- reconstruct(s, groups = list(Trend = c(1,2)))
class(r$Trend) # Result is 'mts' object

# Trend forecast
f &lt;- rforecast(s, groups = list(Trend = c(1, 2)), len = 50, only.new = FALSE)
class(f) # For 'ts' objects the time scales are inferred automatically

# Artificial image for 2dSSA
mx &lt;- outer(1:50, 1:50,
            function(i, j) sin(2*pi * i/17) * cos(2*pi * j/7) + exp(i/25 - j/20)) +
      rnorm(50^2, sd = 0.1)
# Decompose 'mx' with circular window
s &lt;- ssa(mx, kind = "2d-ssa", wmask = circle(5), neig = 10)
# Reconstruct
r &lt;- reconstruct(s, groups = list(1, 2:5))
# Plot components, original image and residuals
plot(r)

# 3D-SSA example (2D-MSSA)
data(Barbara)

ss &lt;- ssa(Barbara, L = c(50, 50, 1))
plot(ss)

</code></pre>

<hr>
<h2 id='ssa-object'>Properties of SSA object</h2><span id='topic+ssa-object'></span><span id='topic+nlambda'></span><span id='topic+nsigma'></span><span id='topic+nu'></span><span id='topic+nv'></span><span id='topic+nspecial'></span><span id='topic+nspecial.ssa'></span><span id='topic+summary.ssa'></span><span id='topic++24.ssa'></span><span id='topic+contributions'></span>

<h3>Description</h3>

<p>Functions to access various fields of SSA object, query
for number of singular values, eigenvectors, factor vectors and &lsquo;special&rsquo; decomposition
triples (now, ProjectionSSA triples) in the SSA object and other miscellaneous info.
See Chapter 1 in Golyandina et al (2018) for explanation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>nsigma(x)
nu(x)
nv(x)
## S3 method for class 'ssa'
nspecial(x)
## S3 method for class 'ssa'
summary(object, digits = max(3, getOption("digits") - 3), ...)
## S3 method for class 'ssa'
x$name
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ssa-object_+3A_x">x</code></td>
<td>
<p>SSA object to query</p>
</td></tr>
<tr><td><code id="ssa-object_+3A_object">object</code></td>
<td>
<p>an object for which a summary is desired</p>
</td></tr>
<tr><td><code id="ssa-object_+3A_digits">digits</code></td>
<td>
<p>integer, used for number formatting</p>
</td></tr>
<tr><td><code id="ssa-object_+3A_...">...</code></td>
<td>
<p>additional arguments affecting the summary produced</p>
</td></tr>
<tr><td><code id="ssa-object_+3A_name">name</code></td>
<td>
<p>field of SSA object to extract. See 'Details' for list of
the fields</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The internals of SSA object is inheritely opaque, because depending on
the selected SVD method and other conditions it might contains
different fields.
</p>
<p>However, it is possible to extract some fields out of it using the
operator <code>$</code>, in particular, the following values of argument
<code>name</code> are supported:
</p>

<dl>
<dt>sigma</dt><dd><p>Vector of singular values</p>
</dd>
<dt>U</dt><dd><p>The matrix of eigenvectors</p>
</dd>
<dt>V</dt><dd><p>The matrix of factor vectors. Might not exist depending on the selected SVD method</p>
</dd>
</dl>

<p>If SSA with projections is being performed, then the eigentriples are ordered as follows:
at first, row projection triples, then column projection triples and then
SVD-triples. Non-SVD triples (like projection triples) are called &lsquo;special triples&rsquo;.
The number of special triples can be obtained by calling <code>nspecial</code> method.
Also, one can use the following fields of the SSA object:
</p>

<dl>
<dt>nPR</dt><dd><p>the number of row projection triples, may be NULL</p>
</dd>
<dt>nPL</dt><dd><p>the number of column projection triples, may be NULL</p>
</dd>
</dl>



<h3>Value</h3>

<p>an 'integer' of length 1 for <code>nu</code>, <code>nv</code>, <code>nsigma</code>,
<code>nspecial</code> routines, matrix or vector for <code>$</code> operator.
</p>


<h3>About decompositions</h3>

<p>The result of Decomposition step of SSA and its modifications can be written down in the following form:
</p>
<p style="text-align: center;"><code class="reqn">%
    {(*)} \quad \mathbf{X} = \sum_i \mathbf{X}_i, \qquad \mathbf{X}_i = \sigma_i U_i V_i^\mathrm{T},</code>
</p>

<p>where <code class="reqn">\mathbf{X}</code> is the trajectory matrix,
<code class="reqn">U_i \in R^L</code>, <code class="reqn">V_i \in R^K</code>, <code class="reqn">\sigma_i</code> are non-negative numbers.
Also, we assume that <code class="reqn">\|U_i\| = 1</code>, <code class="reqn">\|V_i\| = 1</code>.
</p>
<p>The Singular Value Decomposition is a particular case of <code class="reqn">(*)</code> and corresponds to orthonormal systems of
<code class="reqn">\{U_i\}</code> and <code class="reqn">\{V_i\}</code>.
We call <code class="reqn">(\sigma_i, U_i, V_i)</code> eigentriple, <code class="reqn">\sigma_i</code>
are singular values, <code class="reqn">U_i</code> are left singular values or eigenvectors,
<code class="reqn">V_i</code> are right singular vectors or factor vectors, by analogy with the SVD.
</p>
<p>For the most of SSA decompositions, <code class="reqn">U_i</code> belongs to the column space of <code class="reqn">\mathbf{X}</code>,
while <code class="reqn">V_i</code> belongs to the row space of <code class="reqn">\mathbf{X}</code>.
Therefore, let us consider such decompositions called <em>consistent.</em>
</p>
<p>Note that <code class="reqn">(*)</code> is a decomposition of <code class="reqn">\mathbf{X}</code> into a sum of rank-one matrices.
If the systems <code class="reqn">\{U_i\}</code> and <code class="reqn">\{V_i\}</code> are linearly-independent,
then the decomposition <code class="reqn">(*)</code> is minimal (has minimal possible number of addends).
</p>
<p>If at least one of the systems is not linear independent,
the decomposition <code class="reqn">(*)</code> is not minimal.
If both <code class="reqn">\{U_i\}</code> and <code class="reqn">\{V_i\}</code> are orthonormal,
then the decomposition <code class="reqn">(*)</code> is called bi-orthogonal.
If <code class="reqn">\{U_i\}</code> is orthonormal, the decomposition is called left-orthogonal;
If <code class="reqn">\{V_i\}</code> is orthonormal, the decomposition is called right-orthogonal.
</p>
<p>Let <code class="reqn">r</code> be rank of <code class="reqn">\mathbf{X}</code>. Minimal decomposition has exactly <code class="reqn">r</code> addends.
Introduce the Frobenius-inner product as
<code class="reqn">\langle \mathbf{Z}, \mathbf{Y} \rangle _\mathrm{F} = \sum_{i, j} z_{i, j} \cdot y_{i, j}</code>.
Thus, we can say about F-orthogonality and F-orthogonal decompositions if <code class="reqn">\mathbf{X}_i</code>
are F-orthogonal. For F-orthogonality, left or right orthogonality is sufficient.
</p>
<p>Generally, <code class="reqn">\|\mathbf{X}\|^2</code> can be not equal to <code class="reqn">\sum_i \|\mathbf{X}_i\|^2</code>.
For F-orthogonal decompositions, <code class="reqn">\|\mathbf{X}\|^2 = \sum_i \|\mathbf{X}_i\|^2</code>.
</p>
<p>The contribution of k-th matrix component is defined as
<code class="reqn">{\|\mathbf{X}_k\|^2} / {\|\mathbf{X}\|^2} = {\sigma_k^2} / (\sum_i \sigma_i^2)</code>.
</p>
<p>For F-orthogonal decompositions, the sum of component contributions is equal to 1.
Otherwise, this sum can considerably differ from 1
(e.g., the sum of component contributions can be 90% or 146%).
</p>
<p><strong>Remark.</strong> If the system <code class="reqn">\{U_i\}</code> (or <code class="reqn">\{V_i\}</code>) has vectors
that do not belong to the column (or row) spaces, then the decomposition can be not minimal even
if <code class="reqn">\{U_i\}</code> (or <code class="reqn">\{V_i\}</code>) are linearly independent,
since these projections on the column (or row) space can be dependent.
</p>


<h3>Decompositions for different SSA modifications</h3>


<dl>
<dt>Basic SSA</dt><dd><p>the SVD, consistent, minimal, bi-orthogonal and
therefore F-orthogonal decomposition. Implemented in
<code><a href="#topic+ssa">ssa</a></code> with <code>kind='1d-ssa'</code></p>
</dd>
<dt>FOSSA</dt><dd><p>consistent, minimal F-orthogonal
decomposition. Implemented in <code><a href="#topic+fossa">fossa</a></code></p>
</dd>
<dt>IOSSA</dt><dd><p>consistent, minimal oblique decomposition. Implemented
in <code><a href="#topic+iossa">iossa</a></code></p>
</dd>
<dt>SSA with projections</dt><dd><p>non-consistent if at least one basis
vector used for the projection does not belong to the column (row)
trajectory space, F-orthogonal decomposition. The components,
which are obtained by projections, are located at the beginning of
the decomposition and have numbers <code class="reqn">1, \dots,
        n_\mathrm{special}</code>. Implemented in <code><a href="#topic+ssa">ssa</a></code> with
<code>kind='1d-ssa'</code> and non-<code>NULL</code> <code>row.projector</code> or
<code>column.projector</code> arguments</p>
</dd>
<dt>Toeplitz SSA</dt><dd><p>generally, non-consistent, non-minimal
F-orthogonal decomposition. Implemented in
<code><a href="#topic+ssa">ssa</a></code> with <code>kind='toeplitz-ssa'</code></p>
</dd>
</dl>



<h3>Note</h3>

<p>For <code>nsigma</code>, <code>nu</code>, <code>nv</code>, <code>$</code>  routines, the
values returned solely depend on used singular value decomposition
method and parameters of this method (e.g. 'neig' argument for
'propack' and 'nutrlan' SVD methods).
</p>


<h3>References</h3>

<p>Golyandina N., Korobeynikov A., Zhigljavsky A. (2018):
<em>Singular Spectrum Analysis with R.</em>  Use R!.
Springer, Berlin, Heidelberg.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+Rssa">Rssa</a></code> for an overview of the package, as well as,
<code><a href="#topic+ssa">ssa</a></code>,
<code><a href="#topic+calc.v">calc.v</a></code>,
<code><a href="#topic+iossa">iossa</a></code>,
<code><a href="#topic+fossa">fossa</a></code>,
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Decompose 'co2' series with default parameters
s &lt;- ssa(co2, neig = 20)
# Show the number of eigentriples saved in the 's'
print(nsigma(s))
# Show the summary 
summary(s)
# Show the set of singular values
print(s$sigma)
# Show the first eigenvector
print(s$U[, 1])

# Decompose `co2' series with polynomial projections
s &lt;- ssa(co2, row.projector = 1, column.projector = 2)
print(nspecial(s))
print(c(s$nPL, s$nPR))
# Reconstruct a polynomial trend
plot(reconstruct(s, groups = list(trend = seq_len(nspecial(s)))))
</code></pre>

<hr>
<h2 id='ssa.capabilities'>
SSA methods and capabilities check
</h2><span id='topic+ssa.capabilities'></span>

<h3>Description</h3>

<p>Not all SSA algorithms and methods could be applied to SSA objects of
any kind (e.g. gapfilling requires shaped SSA object, one cannot
forecast for 3D-SSA and so on). This function allows one to determine
a set of methods allowed to be applied to a particular SSA object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ssa.capabilities(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ssa.capabilities_+3A_x">x</code></td>
<td>
<p>SSA object holding the decomposition</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Logical vector, indicating which methods are allowed
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Decompose 'co2' series with default parameters
s &lt;- ssa(co2)
# Since this is 1d SSA object, everything should be supported except
# gapfilling
print(ssa.capabilities(s))
</code></pre>

<hr>
<h2 id='summarize.gaps'>Summarize Gaps in a Series</h2><span id='topic+summarize.gaps'></span><span id='topic+summarize.gaps.ssa'></span><span id='topic+summarize.gaps.1d.ssa'></span><span id='topic+summarize.gaps.toeplitz.ssa'></span><span id='topic+summarize.gaps.cssa'></span><span id='topic+summarize.gaps.default'></span>

<h3>Description</h3>

<p>Provide a summary about the gaps in a series given desired
window length, namely whether the gap is internal or not, whether it
is sparce or dense, etc.</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class '1d.ssa'
summarize.gaps(x, L = NULL)
## S3 method for class 'toeplitz.ssa'
summarize.gaps(x, L = NULL)
## S3 method for class 'cssa'
summarize.gaps(x, L = NULL)
## Default S3 method:
summarize.gaps(x, L)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="summarize.gaps_+3A_x">x</code></td>
<td>
<p>SSA object</p>
</td></tr>
<tr><td><code id="summarize.gaps_+3A_l">L</code></td>
<td>
<p>vector of window lengths, if missing or NULL, then all viable
window lengths are considered</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Object of type 'ssa.gaps': a list with entries which correspond to
every window length. For each window length, entry is a list of gaps
with their descriptions.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+Rssa">Rssa</a></code> for an overview of the package, as well as,
<code><a href="#topic+gapfill">gapfill</a></code>,
<code><a href="#topic+igapfill">igapfill</a></code>,
<code><a href="#topic+clplot">clplot</a></code>,
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Produce series with gaps
F &lt;- co2; F[c(12, 100:200, 250)] &lt;- NA
# Summarize the gaps
s &lt;- ssa(F, L = 72)
g &lt;- summarize.gaps(s, L = c(36, 72, 144))
# Print the results
print(g)
# Plot the proportion of complete lag-vectors
plot(g)
</code></pre>

<hr>
<h2 id='tmat'>Toeplitz matrices operations.</h2><span id='topic+new.tmat'></span><span id='topic+is.tmat'></span><span id='topic+tcols'></span><span id='topic+trows'></span><span id='topic+tmatmul'></span>

<h3>Description</h3>

<p>A set of routines to operate on Toeplitz matrices stored in compact
FFT-based form.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>new.tmat(F, L = (N + 1) %/% 2, circular = FALSE, fft.plan = NULL)
is.tmat(t)
tcols(t)
trows(t)
tmatmul(tmat, v, transposed = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="tmat_+3A_f">F</code></td>
<td>
<p>series to construct the Toeplitz version of L x L autocovariance matrix.</p>
</td></tr>
<tr><td><code id="tmat_+3A_fft.plan">fft.plan</code></td>
<td>
<p>internal hint argument, should be NULL in most cases</p>
</td></tr>
<tr><td><code id="tmat_+3A_l">L</code></td>
<td>
<p>the window length.</p>
</td></tr>
<tr><td><code id="tmat_+3A_circular">circular</code></td>
<td>
<p>logical vector of one element, describes series topology.
'TRUE' means series circularity</p>
</td></tr>
<tr><td><code id="tmat_+3A_t">t</code>, <code id="tmat_+3A_tmat">tmat</code></td>
<td>
<p>matrix to operate on.</p>
</td></tr>
<tr><td><code id="tmat_+3A_transposed">transposed</code></td>
<td>
<p>logical, if 'TRUE' the multiplication is performed
with the transposed matrix.</p>
</td></tr>
<tr><td><code id="tmat_+3A_v">v</code></td>
<td>
<p>vector to multiply with.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Fast Fourier Transform provides a very efficient matrix-vector
multiplication routine for Toeplitz matrices. See the paper in
'References' for the details of the algorithm.
</p>


<h3>References</h3>

<p>Korobeynikov, A. (2010) <em>Computation- and space-efficient implementation of
SSA.</em> Statistics and Its Interface, Vol. 3, No. 3, Pp. 257-268
</p>


<h3>See Also</h3>

<p><code><a href="#topic+Rssa">Rssa</a></code> for an overview of the package, as well as,
<code><a href="#topic+ssa">ssa</a></code>,
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Construct the Toeplitz version of the autocovariance matrix for 'co2' series
h &lt;- new.tmat(co2, L = 10)
# Print the number of columns and rows
print(trows(h)); print(tcols(h))
</code></pre>

<hr>
<h2 id='USUnemployment'>U.S. unemployment figures</h2><span id='topic+USUnemployment'></span>

<h3>Description</h3>

<p>Monthly U.S. male (16-19 years and from 20 years) and female (16-19 years and from 20 years)
unemployment figures in thousands from 1948 till 1981.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(USUnemployment)</code></pre>


<h3>Format</h3>

<p>A multivariate time series with 408 observations on 4
variables. The object is of class 'mts'.</p>


<h3>Source</h3>

<p>Andrews D. F. and Herzberg H. M. (1985):
<em>Data: A Collection of Problems from Many Fields for the Student and Research Worker</em>,
Springer Series in Statistics.
</p>

<hr>
<h2 id='vforecast'>Perform vector SSA forecasting of the series</h2><span id='topic+vforecast'></span><span id='topic+vforecast.default'></span><span id='topic+vforecast.ssa'></span><span id='topic+vforecast.1d.ssa'></span><span id='topic+vforecast.toeplitz.ssa'></span><span id='topic+vforecast.mssa'></span><span id='topic+vforecast.cssa'></span><span id='topic+vforecast.pssa.1d.ssa'></span>

<h3>Description</h3>

<p>Perform vector SSA forecasting of the series.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class '1d.ssa'
vforecast(x, groups, len = 1, only.new = TRUE, ...,
          drop = TRUE, drop.attributes = FALSE)
## S3 method for class 'toeplitz.ssa'
vforecast(x, groups, len = 1, only.new = TRUE, ...,
          drop = TRUE, drop.attributes = FALSE)
## S3 method for class 'toeplitz.ssa'
vforecast(x, groups, len = 1, only.new = TRUE, ...,
          drop = TRUE, drop.attributes = FALSE)
## S3 method for class 'mssa'
vforecast(x, groups, len = 1,
          direction = c("row", "column"),
          only.new = TRUE, ...,
          drop = TRUE, drop.attributes = FALSE)
## S3 method for class 'cssa'
vforecast(x, groups, len = 1, only.new = TRUE, ...,
          drop = TRUE, drop.attributes = FALSE)
## S3 method for class 'pssa.1d.ssa'
vforecast(x, groups, len = 1, only.new = TRUE, ...,
          drop = TRUE, drop.attributes = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="vforecast_+3A_x">x</code></td>
<td>
<p>SSA object holding the decomposition</p>
</td></tr>
<tr><td><code id="vforecast_+3A_groups">groups</code></td>
<td>
<p>list, the grouping of eigentriples to be used in the forecast</p>
</td></tr>
<tr><td><code id="vforecast_+3A_len">len</code></td>
<td>
<p>integer, the desired length of the forecasted series</p>
</td></tr>
<tr><td><code id="vforecast_+3A_direction">direction</code></td>
<td>
<p>direction of forecast in multichannel SSA case, &quot;column&quot;
stands for so-called L-forecast and &quot;row&quot; stands for K-forecast</p>
</td></tr>
<tr><td><code id="vforecast_+3A_only.new">only.new</code></td>
<td>
<p>logical, if 'TRUE' then only forecasted values are returned,
whole series otherwise</p>
</td></tr>
<tr><td><code id="vforecast_+3A_...">...</code></td>
<td>
<p>additional arguments passed to <code><a href="#topic+decompose">decompose</a></code>
routines</p>
</td></tr>
<tr><td><code id="vforecast_+3A_drop">drop</code></td>
<td>
<p>logical, if 'TRUE' then the result is coerced to series
itself, when possible (length of 'groups' is one)</p>
</td></tr>
<tr><td><code id="vforecast_+3A_drop.attributes">drop.attributes</code></td>
<td>
<p>logical, if 'TRUE' then the attributes of the input series
are not copied to the reconstructed ones.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The routines applies the vector SSA forecasting algorithm to
produce the new series which is expected to 'continue' the current
series on the basis of a given decomposition. Vector forecast
differs from recurrent forecast in such a way that it continues the set
of vectors in the subspace spanning the chosen eigenvectors (the same
formula as described in <code><a href="#topic+lrr">lrr</a></code> is used for constructing of
the last components of the new vectors) and then derives the series out
of this extended set of vectors.
</p>
<p>For multichannel SSA, forecast can be constructed in two versions, 
row and column ones; it uses the formulae from Golyandina et al (2015).
</p>
<p>For details of 1D-SSA recurrent forecasting, see Section 3.2.1.3 and 
Algorithm 3.6 in Golyandina et al (2018).
For details of MSSA recurrent forecasting, see Section 4.3.1.3  and 
Algorithm 4.5 (column forecasting).
</p>


<h3>Value</h3>

<p>List of forecasted objects. Elements of the list have the same names
as elements of <code>groups</code>. If group is unnamed, corresponding
component gets name &lsquo;Fn&rsquo;, where &lsquo;n&rsquo; is its index in <code>groups</code>
list.
</p>
<p>Or, the forecasted object itself, if length of groups is one and 'drop = TRUE'.
</p>


<h3>References</h3>

<p>Golyandina N., Korobeynikov A., Zhigljavsky A. (2018):
<em>Singular Spectrum Analysis with R.</em>  Use R!.
Springer, Berlin, Heidelberg.
</p>
<p>Golyandina, N., Nekrutkin, V. and Zhigljavsky, A. (2001): <em>Analysis of
Time Series Structure: SSA and related techniques.</em> Chapman and
Hall/CRC. ISBN 1584881941
</p>
<p>Golyandina, N. and Stepanov, D. (2005): <em>SSA-based approaches to
analysis and forecast of multidimensional time series</em>. In
Proceedings of the 5th St.Petersburg Workshop on Simulation, June
26-July 2, 2005, St. Petersburg State University, St. Petersburg,
293&ndash;298. <a href="https://www.gistatgroup.com/gus/mssa2.pdf">https://www.gistatgroup.com/gus/mssa2.pdf</a>
</p>
<p>Golyandina, N., Korobeynikov, A., Shlemov, A. and Usevich, K. (2015):
<em>Multivariate and 2D Extensions of Singular Spectrum Analysis
with the Rssa Package</em>. Journal of Statistical Software, Vol. 67, Issue 2.
<a href="https://doi.org/10.18637/jss.v067.i02">doi:10.18637/jss.v067.i02</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+Rssa">Rssa</a></code> for an overview of the package, as well as,
<code><a href="#topic+rforecast">rforecast</a></code>,
<code><a href="#topic+bforecast">bforecast</a></code>,
<code><a href="#topic+forecast">forecast</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Decompose 'co2' series with default parameters
s &lt;- ssa(co2)
# Produce 24 forecasted values of the series using different sets of eigentriples
# as a base space for the forecast.
vfor &lt;- vforecast(s, groups = list(c(1,4), 1:4), len = 24, only.new=FALSE)
matplot(data.frame(c(co2, rep(NA, 24)), vfor), type="l")

# Forecast `co2' trend by SSA with projections
s &lt;- ssa(co2, column.projector = 2, row.projector = 2)
len &lt;- 100
vfor &lt;- vforecast(s, groups = list(trend = seq_len(nspecial(s))), len = len, only.new = FALSE)
matplot(data.frame(c(co2, rep(NA, len)), vfor), type = "l")

# Forecast finite rank series with polynomial component by SSA with projections
v &lt;- 5000 * sin(2*pi / 13 * (1:100)) +  (1:100)^2 + 10000
s &lt;- ssa(v, row.projector = 2, column.projector = 2)
plot(vforecast(s, groups = list(all = 1:6), len = 100, only.new = FALSE), type = "l")
</code></pre>

<hr>
<h2 id='wcor'>Calculate the W-correlation matrix</h2><span id='topic+wcor'></span><span id='topic+wcor.ssa'></span><span id='topic+wcor.ossa'></span><span id='topic+wcor.default'></span><span id='topic+plot.wcor.matrix'></span>

<h3>Description</h3>

<p>Function calculates the W-correlation matrix for the series.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'ssa'
wcor(x, groups, Fs, ..., cache = TRUE)
## S3 method for class 'ossa'
wcor(x, groups, Fs, ..., cache = TRUE)
## Default S3 method:
wcor(x, L = (N + 1) %/% 2, ..., weights = NULL)
## S3 method for class 'wcor.matrix'
plot(x,
     grid = c(),
     ...,
     col = grey(c(1, 0)),
     cuts = 20,
     zlim = range(abs(x), 0, 1),
     at)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="wcor_+3A_x">x</code></td>
<td>
<p>the input object. This might be ssa object for <em>ssa</em>
method, or just a matrix with elementary series in columns for
<em>default</em> implementation.</p>
</td></tr>
<tr><td><code id="wcor_+3A_l">L</code></td>
<td>
<p>window length.</p>
</td></tr>
<tr><td><code id="wcor_+3A_weights">weights</code></td>
<td>
<p>additional weights</p>
</td></tr>
<tr><td><code id="wcor_+3A_groups">groups</code></td>
<td>
<p>list of numeric vectors, indices of elementary components
used for reconstruction.</p>
</td></tr>
<tr><td><code id="wcor_+3A_fs">Fs</code></td>
<td>
<p>list of series (e.g. 'ssa.reconstruction' object) for W-cor computation.
If missing, reconstructed series from the input 'ssa' object <code>x</code> will be used.</p>
</td></tr>
<tr><td><code id="wcor_+3A_...">...</code></td>
<td>
<p>further arguments passed to <code>reconstruct</code> routine
for <code>wcor</code> or to <code>plot</code> for <code>plot.wcor.matrix</code></p>
</td></tr>
<tr><td><code id="wcor_+3A_cache">cache</code></td>
<td>
<p>logical, if 'TRUE' then intermediate results will be
cached in 'ssa' object.</p>
</td></tr>
<tr><td><code id="wcor_+3A_grid">grid</code></td>
<td>
<p>numeric vector, indices of matrix blocks (groups)
which will be separated by grid line.
Lines will be drawn on the left of and under noted blocks.
Also this argument can be list of two numeric vectors
with names 'x' and 'y', for control vertical and horizontal
grid lines separately.</p>
</td></tr>
<tr><td><code id="wcor_+3A_col">col</code></td>
<td>
<p>color vector for colorscale,
given by two or more colors,
the first color corresponds to the minimal value,
while the last one corresponds to the maximal value (will be interpolated by <code>colorRamp</code>)</p>
</td></tr>
<tr><td><code id="wcor_+3A_cuts">cuts</code></td>
<td>
<p>integer, the number of levels the range of W-cor
values will be divided into.</p>
</td></tr>
<tr><td><code id="wcor_+3A_zlim">zlim</code></td>
<td>
<p>range of displayed W-cor values.</p>
</td></tr>
<tr><td><code id="wcor_+3A_at">at</code></td>
<td>
<p>A numeric vector giving breakpoints along the range of the image.
if missing, will be evaluated automatically (see description of the <code>cuts</code> argument).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>W-correlation matrix is a standard way of checking for weak
separability between the elementary components. In particular, the
strongly correlated elementary components should be placed into the
same group. The function calculates such a matrix either directly from
'ssa' object or from the matrix of elementary series.
</p>
<p>For plotting additional (non-standard) graphical parameters which can be passed via ...:
</p>

<dl>
<dt>useRaster</dt><dd><p>logical, indicates whether raster plot should be used. 'FALSE' by default</p>
</dd>
</dl>

<p>For class &lsquo;ossa&rsquo;, checking of Frobenius orthogonality is performed.
If there are reconstructed matrices, which are not F-orthogonal (it is
a usual case for Oblique SSA), the warning about possible irrelevancy
will be shown, since then weighted correlations do not indicate weak
separability properly.  In such a case, the use of
<code><a href="#topic+owcor">owcor</a></code> is preferred.
</p>


<h3>Value</h3>

<p>Object of type 'wcor.matrix'.
</p>


<h3>References</h3>

<p>Golyandina, N., Nekrutkin, V. and Zhigljavsky, A. (2001): <em>Analysis of
Time Series Structure: SSA and related techniques.</em> Chapman and
Hall/CRC. ISBN 1584881941
</p>


<h3>See Also</h3>

<p><code><a href="#topic+reconstruct.ssa">reconstruct</a></code>
<code><a href="#topic+owcor">owcor.</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Decompose co2 series with default parameters
s &lt;- ssa(co2)
# Calculate the w-correlation matrix between first 20 series
# for a guess for grouping
w &lt;- wcor(s, groups = 1:20)
plot(w, grid = c(2,4, 5,7))
# Calculate the w-correlation matrix for the chosen groups
# to check separability
w &lt;- wcor(s, groups = list(c(1,4), c(2,3), c(5,6)))


# Artificial image for 2D SSA
mx &lt;- outer(1:50, 1:50,
            function(i, j) sin(2*pi * i/17) * cos(2*pi * j/7) + exp(i/25 - j/20)) +
      rnorm(50^2, sd = 0.1)
# Decompose 'mx' with default parameters
s &lt;- ssa(mx, kind = "2d-ssa")
# Plot wcor for first 12 components
plot(wcor(s, groups = 1:12), grid = c(2, 6))

# Real example: Mars photo
data(Mars)
# Decompose only Mars image (without backgroud)
s &lt;- ssa(Mars, mask = Mars != 0, wmask = circle(50), kind = "2d-ssa")
# Plot wcor for the first 25 components
plot(wcor(s, groups = 1:25), grid = c(13, 15, 17,19))

</code></pre>

<hr>
<h2 id='wnorm'>Calculate Weighted Norm of series</h2><span id='topic+wnorm'></span><span id='topic+wnorm.1d.ssa'></span><span id='topic+wnorm.nd.ssa'></span><span id='topic+wnorm.toeplitz.ssa'></span><span id='topic+wnorm.mssa'></span><span id='topic+wnorm.default'></span><span id='topic+wnorm.complex'></span>

<h3>Description</h3>

<p>Function calculates the W-norm for input objects or for objects stored in input ssa obect.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class '1d.ssa'
wnorm(x, ...)
## S3 method for class 'nd.ssa'
wnorm(x, ...)
## S3 method for class 'toeplitz.ssa'
wnorm(x, ...)
## S3 method for class 'mssa'
wnorm(x, ...)
## Default S3 method:
wnorm(x, L = (N + 1) %/% 2, ...)
## S3 method for class 'complex'
wnorm(x, L = (N + 1) %/% 2, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="wnorm_+3A_x">x</code></td>
<td>
<p>the input object. This might be ssa object for <em>ssa</em>
method, or just a series.</p>
</td></tr>
<tr><td><code id="wnorm_+3A_l">L</code></td>
<td>
<p>window length.</p>
</td></tr>
<tr><td><code id="wnorm_+3A_...">...</code></td>
<td>
<p>arguments to be passed to methods.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>L</code>-weighted norm of series is Frobenius norm of its
<code>L</code>-trajectory matrix. So, if <code>x</code> is vector (series), the
result of <code>wnorm(x, L)</code> is equal to <code>sqrt(sum(hankel(x,
  L)^2)</code>, but in fact is calculated much more efficiently. For 1d SSA and
Toeplitz SSA <code>wnorm(x)</code> calculates weighted norm for stored
original input series and stored window length.
</p>
<p><code>L</code>-weighted norm of 2d array is Frobenius norm of its <code>L[1]
  * L[2]</code>-trajectory hankel-block-hankel matrix.  For 2d SSA this method
calculates weighted norm for stored original input array and stored
2d-window lengths.
</p>


<h3>References</h3>

<p>Golyandina, N., Nekrutkin, V. and Zhigljavsky, A. (2001): <em>Analysis of
Time Series Structure: SSA and related techniques.</em> Chapman and
Hall/CRC. ISBN 1584881941
</p>


<h3>See Also</h3>

<p><code><a href="#topic+ssa-input">ssa-input</a></code>,
<code><a href="#topic+hankel">hankel</a></code>,
<code><a href="#topic+wcor">wcor</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>wnorm(co2, 20)
# Construct ssa-object for 'co2' with default parameters but don't decompose
ss &lt;- ssa(co2, force.decompose = FALSE)
wnorm(ss)

# Artificial image for 2D SSA

mx &lt;- outer(1:50, 1:50,
            function(i, j) sin(2*pi * i/17) * cos(2*pi * j/7) + exp(i/25 - j/20)) +
      rnorm(50^2, sd = 0.1)
# Construct ssa-object for 'mx' with default parameters but don't decompose
s &lt;- ssa(mx, kind = "2d-ssa", force.decompose = FALSE)
wnorm(s)

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
