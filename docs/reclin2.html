<!DOCTYPE html><html><head><title>Help for package reclin2</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {reclin2}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#add_from_x'><p>Add a variable from one of the data sets to pairs</p></a></li>
<li><a href='#cluster_call'><p>Call a function on each of the worker nodes and pass it the pairs</p></a></li>
<li><a href='#cluster_collect'><p>Collect pairs from cluster nodes</p></a></li>
<li><a href='#cluster_modify_pairs'><p>Call a function on each of the worker nodes to modify the pairs on the node</p></a></li>
<li><a href='#cluster_pair'><p>Generate all possible pairs using multiple processes</p></a></li>
<li><a href='#cluster_pair_blocking'><p>Generate pairs using simple blocking using multiple processes</p></a></li>
<li><a href='#cluster_pair_minsim'><p>Generate pairs with a minimal similarity using multiple processes</p></a></li>
<li><a href='#cmp_identical'><p>Comparison functions</p></a></li>
<li><a href='#compare_pairs.cluster_pairs'><p>Compare pairs on a set of variables common in both data sets</p></a></li>
<li><a href='#compare_vars.cluster_pairs'><p>Compare pairs on given variables</p></a></li>
<li><a href='#deduplicate_equivalence'><p>Deduplication using equivalence groups</p></a></li>
<li><a href='#get_inspect_pairs'><p>Get a subset of pairs to inspect</p></a></li>
<li><a href='#greedy'><p>Greedy one-to-one matching of pairs</p></a></li>
<li><a href='#link'><p>Use the selected pairs to generate a linked data set</p></a></li>
<li><a href='#linkexample1'><p>Tiny example dataset for probabilistic linkage</p></a></li>
<li><a href='#match_n_to_m'><p>Force n to m matching on a set of pairs</p></a></li>
<li><a href='#merge_pairs.cluster_pairs'><p>Merge two sets of pairs into one</p></a></li>
<li><a href='#pair'><p>Generate all possible pairs</p></a></li>
<li><a href='#pair_blocking'><p>Generate pairs using simple blocking</p></a></li>
<li><a href='#pair_minsim'><p>Generate pairs with a minimal similarity</p></a></li>
<li><a href='#predict.problink_em'><p>Calculate weights and probabilities for pairs</p></a></li>
<li><a href='#problink_em'><p>Calculate EM-estimates of m- and u-probabilities</p></a></li>
<li><a href='#score_simple.cluster_pairs'><p>Score pairs based on a number of comparison vectors</p></a></li>
<li><a href='#select_greedy.cluster_pairs'><p>Select matching pairs enforcing one-to-one linkage</p></a></li>
<li><a href='#select_threshold.cluster_pairs'><p>Select matching pairs with a score above or equal to a threshold</p></a></li>
<li><a href='#select_unique.cluster_pairs'><p>Deselect pairs that are linked to multiple records</p></a></li>
<li><a href='#summary.problink_em'><p>Summarise the results from <code>problink_em</code></p></a></li>
<li><a href='#tabulate_patterns.cluster_pairs'><p>Create a table of comparison patterns</p></a></li>
<li><a href='#town_names'><p>Spelling variations of a set of town names</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Record Linkage Toolkit</td>
</tr>
<tr>
<td>Version:</td>
<td>0.5.0</td>
</tr>
<tr>
<td>Description:</td>
<td>Functions to assist in performing probabilistic record linkage and
    deduplication: generating pairs, comparing records, em-algorithm for
    estimating m- and u-probabilities
    (I. Fellegi &amp; A. Sunter (1969) &lt;<a href="https://doi.org/10.1080%2F01621459.1969.10501049">doi:10.1080/01621459.1969.10501049</a>&gt;, 
    T.N. Herzog, F.J. Scheuren, &amp; W.E. Winkler (2007), 
    "Data Quality and Record Linkage Techniques", ISBN:978-0-387-69502-0),
    forcing one-to-one matching. Can also be
    used for pre- and post-processing for machine learning methods for record
    linkage. Focus is on memory, CPU performance and flexibility. </td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/djvanderlaan/reclin2/issues">https://github.com/djvanderlaan/reclin2/issues</a></td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/djvanderlaan/reclin2">https://github.com/djvanderlaan/reclin2</a></td>
</tr>
<tr>
<td>Depends:</td>
<td>data.table, R (&ge; 3.6.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>stringdist, stats, utils, lpSolve, Rcpp, parallel</td>
</tr>
<tr>
<td>Suggests:</td>
<td>simplermarkdown</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>Rcpp</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>simplermarkdown</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>LazyLoad:</td>
<td>yes</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-02-09 07:44:04 UTC; eoos</td>
</tr>
<tr>
<td>Author:</td>
<td>Jan van der Laan <a href="https://orcid.org/0000-0002-0693-1514"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cre]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Jan van der Laan &lt;r@eoos.dds.nl&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-02-09 08:30:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='add_from_x'>Add a variable from one of the data sets to pairs</h2><span id='topic+add_from_x'></span><span id='topic+add_from_y'></span>

<h3>Description</h3>

<p>Add a variable from one of the data sets to pairs
</p>


<h3>Usage</h3>

<pre><code class='language-R'>add_from_x(pairs, variable, new_variable = variable, ...)

add_from_y(pairs, variable, new_variable = variable, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="add_from_x_+3A_pairs">pairs</code></td>
<td>
<p><code><a href="data.table.html#topic+data.table">data.table</a></code> with pairs. Should contain the columns 
<code>.x</code> and <code>.y</code>.</p>
</td></tr>
<tr><td><code id="add_from_x_+3A_variable">variable</code></td>
<td>
<p>name of the variable that should be added</p>
</td></tr>
<tr><td><code id="add_from_x_+3A_new_variable">new_variable</code></td>
<td>
<p>optional variable name of the new variable in
<code>pairs</code>. When omitted <code>variable</code> is used.</p>
</td></tr>
<tr><td><code id="add_from_x_+3A_...">...</code></td>
<td>
<p>other parameters are passed on to <code>compare_vars</code>. Especially
<code>inplace</code>, <code>x</code> and <code>y</code> might be of interest.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns the pairs with the column added. When <code>inplace = TRUE</code>
<code>pairs</code> is returned invisibly and the original <code>pairs</code> is 
modified.
</p>

<hr>
<h2 id='cluster_call'>Call a function on each of the worker nodes and pass it the pairs</h2><span id='topic+cluster_call'></span>

<h3>Description</h3>

<p>Call a function on each of the worker nodes and pass it the pairs
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cluster_call(pairs, fun, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cluster_call_+3A_pairs">pairs</code></td>
<td>
<p>an object or type <code>cluster_pairs</code> as created for example by
<code><a href="#topic+cluster_pair">cluster_pair</a></code>.</p>
</td></tr>
<tr><td><code id="cluster_call_+3A_fun">fun</code></td>
<td>
<p>a function to call on each of the worker nodes. See details on the
arguments of this function.</p>
</td></tr>
<tr><td><code id="cluster_call_+3A_...">...</code></td>
<td>
<p>additional arguments are passed on to <code>fun</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function will have to accept the following arguments as its first three
arguments:
</p>

<dl>
<dt>pairs</dt><dd><p>the <code>data.table</code> with the pairs of the worker node.</p>
</dd>
<dt>x</dt><dd><p>a <code>data.table</code> with the portion of <code>x</code> present on the 
worker node.</p>
</dd>
<dt>y</dt><dd><p>a <code>data.table</code> with <code>y</code>.</p>
</dd>
</dl>



<h3>Value</h3>

<p>The function will return a list with for each worker the result of the
function call. When the functions return <code>NULL</code> the result is returned
invisibly. Because the result is returned to main node, make sure you don't
accidentally return all pairs. If you don't want to return anything end your
function with <code>NULL</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Generate some pairs
library(parallel)
data("linkexample1", "linkexample2")
cl &lt;- makeCluster(2)

pairs &lt;- cluster_pair(cl, linkexample1, linkexample2)
compare_pairs(pairs, c("lastname", "firstname", "address", "sex"))

# Add a new column to pairs
cluster_call(pairs, function(pairs, ...) {
  pairs[, name := firstname &amp; lastname]
  # we don't want to return the pairs; so make sure to return something
  # else
  NULL
})

# Get the number of pairs on each node
lenghts &lt;- cluster_call(pairs, function(pairs, ...) {
  nrow(pairs)
})
lengths &lt;- unlist(lenghts)
lenghts

# Cleanup
stopCluster(cl)

</code></pre>

<hr>
<h2 id='cluster_collect'>Collect pairs from cluster nodes</h2><span id='topic+cluster_collect'></span>

<h3>Description</h3>

<p>Collect pairs from cluster nodes
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cluster_collect(pairs, select = NULL, clear = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cluster_collect_+3A_pairs">pairs</code></td>
<td>
<p>an object or type <code>cluster_pairs</code> as created for example by
<code><a href="#topic+cluster_pair">cluster_pair</a></code>.</p>
</td></tr>
<tr><td><code id="cluster_collect_+3A_select">select</code></td>
<td>
<p>the name of a logical column that is used to select the pairs
that will be collected</p>
</td></tr>
<tr><td><code id="cluster_collect_+3A_clear">clear</code></td>
<td>
<p>remove the pairs from the cluster nodes</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns an object of type <code>pairs</code> which is a <code>data.table</code>. This
object can be used as a regular (non-cluster) set of pairs
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(parallel)
data("linkexample1", "linkexample2")
cl &lt;- makeCluster(2)


pairs &lt;- cluster_pair(cl, linkexample1, linkexample2)
local_pairs &lt;- cluster_collect(pairs, clear = FALSE)

compare_pairs(pairs, c("lastname", "firstname", "address", "sex"))
model &lt;- problink_em(~ lastname + firstname + address + sex, data = pairs)
predict(model, pairs, type = "mpost", add = TRUE, binary = TRUE)
# Select pairs with a mpost &gt; 0.5
select_threshold(pairs, "selected", "mpost", 0.5)
# Collect the selected pairs
local_pairs &lt;- cluster_collect(pairs, "selected")

stopCluster(cl)
</code></pre>

<hr>
<h2 id='cluster_modify_pairs'>Call a function on each of the worker nodes to modify the pairs on the node</h2><span id='topic+cluster_modify_pairs'></span>

<h3>Description</h3>

<p>Call a function on each of the worker nodes to modify the pairs on the node
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cluster_modify_pairs(pairs, fun, ..., new_name = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cluster_modify_pairs_+3A_pairs">pairs</code></td>
<td>
<p>an object or type <code>cluster_pairs</code> as created for example by
<code><a href="#topic+cluster_pair">cluster_pair</a></code>.</p>
</td></tr>
<tr><td><code id="cluster_modify_pairs_+3A_fun">fun</code></td>
<td>
<p>a function to call on each of the worker nodes. See details on the
arguments of this function.</p>
</td></tr>
<tr><td><code id="cluster_modify_pairs_+3A_...">...</code></td>
<td>
<p>additional arguments are passed on to <code>fun</code>.</p>
</td></tr>
<tr><td><code id="cluster_modify_pairs_+3A_new_name">new_name</code></td>
<td>
<p>name of new object to assign the pairs to on the cluster
nodes.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function will have to accept the following arguments as its first three
arguments:
</p>

<dl>
<dt>pairs</dt><dd><p>the <code>data.table</code> with the pairs of the worker node. </p>
</dd>
<dt>x</dt><dd><p>a <code>data.table</code> with the portion of <code>x</code> present on the 
worker node.</p>
</dd>
<dt>y</dt><dd><p>a <code>data.table</code> with <code>y</code>. </p>
</dd>
</dl>

<p>The function should either return a <code>data.table</code> with the new pairs, or
<code>NULL</code>. When a <code>data.table</code> is returned this values will replace
the pairs when <code>new_name</code> is missing or create new pairs in the
environment <code>new_name</code>. When the function returns <code>NULL</code> it is
assumed that the function modified the pairs by reference (e.g. using
<code>pairs[, new_var := new_val]</code>). Note that this also means that
<code>new_name</code> is ignored.
</p>


<h3>Value</h3>

<p>Will return a <code>cluster_pairs</code> object. When <code>new_name</code> is not given
it will return the input <code>pairs</code> invisibly. Otherwise it will return a
new <code>cluster_pairs</code> object.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Generate some pairs
library(parallel)
data("linkexample1", "linkexample2")
cl &lt;- makeCluster(2)

pairs &lt;- cluster_pair(cl, linkexample1, linkexample2)
compare_pairs(pairs, c("lastname", "firstname", "address", "sex"))

# Create a new set of pairs containing a random sample of the original
# pairs.
sample &lt;-  cluster_call(pairs, new_name = "sample", function(pairs, ...) {
  sel &lt;- sample(nrow(pairs), round(nrow(pairs)*0.1))
  pairs[sel, ]
})

# Cleanup
stopCluster(cl)

</code></pre>

<hr>
<h2 id='cluster_pair'>Generate all possible pairs using multiple processes</h2><span id='topic+cluster_pair'></span>

<h3>Description</h3>

<p>Generates all combinations of records from <code>x</code> and <code>y</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cluster_pair(cluster, x, y, deduplication = FALSE, name = "default")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cluster_pair_+3A_cluster">cluster</code></td>
<td>
<p>a cluster object as created by <code><a href="parallel.html#topic+makeCluster">makeCluster</a></code>
from <code>parallel</code> or from the <code>snow</code> package.</p>
</td></tr>
<tr><td><code id="cluster_pair_+3A_x">x</code></td>
<td>
<p>first <code>data.frame</code></p>
</td></tr>
<tr><td><code id="cluster_pair_+3A_y">y</code></td>
<td>
<p>second <code>data.frame</code>. Ignored when <code>deduplication = TRUE</code>.</p>
</td></tr>
<tr><td><code id="cluster_pair_+3A_deduplication">deduplication</code></td>
<td>
<p>generate pairs from only <code>x</code>. Ignore <code>y</code>. This 
is usefull for deduplication of <code>x</code>.</p>
</td></tr>
<tr><td><code id="cluster_pair_+3A_name">name</code></td>
<td>
<p>the name of the resulting object to create locally on the different
R processes.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Generating (all) pairs of the records of two data sets, is usually the first 
step when linking the two data sets. 
</p>
<p><code>x</code> is split into <code>length{cluster}</code> parts which are distributed
over the worker nodes. <code>y</code> is copied to each of the nodes. On the nodes
then <code><a href="#topic+pair">pair</a></code> is called. The pairs are stored in the global
object <code>reclin_env</code> on the nodes in the variable <code>name</code>. The pairs
can then be further processes using functions such as
<code><a href="#topic+compare_pairs">compare_pairs</a></code>, and <code><a href="#topic+tabulate_patterns">tabulate_patterns</a></code>. The function
<code><a href="#topic+cluster_collect">cluster_collect</a></code> collects the pairs from each of the nodes.
</p>


<h3>Value</h3>

<p>A object of type <code>cluster_pairs</code> which is a <code>list</code> containing the
cluster and the name of the pairs object on the cluster nodes. For the pairs
objects created on the nodes see the documentation of <code><a href="#topic+pair">pair</a></code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+cluster_pair_blocking">cluster_pair_blocking</a></code> and <code><a href="#topic+cluster_pair_minsim">cluster_pair_minsim</a></code> are
other methods to generate pairs.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(parallel)
data("linkexample1", "linkexample2")
cl &lt;- makeCluster(2)

pairs &lt;- cluster_pair(cl, linkexample1, linkexample2)
stopCluster(cl)

</code></pre>

<hr>
<h2 id='cluster_pair_blocking'>Generate pairs using simple blocking using multiple processes</h2><span id='topic+cluster_pair_blocking'></span>

<h3>Description</h3>

<p>Generates all combinations of records from <code>x</code> and <code>y</code> where the 
blocking variables are equal.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cluster_pair_blocking(
  cluster,
  x,
  y,
  on,
  deduplication = FALSE,
  name = "default"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cluster_pair_blocking_+3A_cluster">cluster</code></td>
<td>
<p>a cluster object as created by <code><a href="parallel.html#topic+makeCluster">makeCluster</a></code>
from <code>parallel</code> or from the <code>snow</code> package.</p>
</td></tr>
<tr><td><code id="cluster_pair_blocking_+3A_x">x</code></td>
<td>
<p>first <code>data.frame</code></p>
</td></tr>
<tr><td><code id="cluster_pair_blocking_+3A_y">y</code></td>
<td>
<p>second <code>data.frame</code>. Ignored when <code>deduplication = TRUE</code>.</p>
</td></tr>
<tr><td><code id="cluster_pair_blocking_+3A_on">on</code></td>
<td>
<p>the variables defining the blocks or strata for which 
all pairs of <code>x</code> and <code>y</code> will be generated.</p>
</td></tr>
<tr><td><code id="cluster_pair_blocking_+3A_deduplication">deduplication</code></td>
<td>
<p>generate pairs from only <code>x</code>. Ignore <code>y</code>. This 
is usefull for deduplication of <code>x</code>.</p>
</td></tr>
<tr><td><code id="cluster_pair_blocking_+3A_name">name</code></td>
<td>
<p>the name of the resulting object to create locally on the different
R processes.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Generating (all) pairs of the records of two data sets, is usually the first 
step when linking the two data sets. However, this often results in a too 
large number of records. Therefore, blocking is usually applied. 
</p>
<p><code>x</code> is split into <code>length{cluster}</code> parts which are distributed
over the worker nodes. <code>y</code> is copied to each of the nodes. On the nodes
then <code><a href="#topic+pair_blocking">pair_blocking</a></code> is called. The pairs are stored in the global
object <code>reclin_env</code> on the nodes in the variable <code>name</code>. The pairs
can then be further processes using functions such as
<code><a href="#topic+compare_pairs">compare_pairs</a></code>, and <code><a href="#topic+tabulate_patterns">tabulate_patterns</a></code>. The function
<code><a href="#topic+cluster_collect">cluster_collect</a></code> collects the pairs from each of the nodes.
</p>


<h3>Value</h3>

<p>A object of type <code>cluster_pairs</code> which is a <code>list</code> containing the
cluster and the name of the pairs object on the cluster nodes. For the pairs
objects created on the nodes see the documentation of <code><a href="#topic+pair">pair</a></code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+cluster_pair">cluster_pair</a></code> and <code><a href="#topic+cluster_pair_minsim">cluster_pair_minsim</a></code> are 
other methods to generate pairs.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(parallel)
data("linkexample1", "linkexample2")
cl &lt;- makeCluster(2)

pairs &lt;- cluster_pair_blocking(cl, linkexample1, linkexample2, "postcode")
stopCluster(cl)

</code></pre>

<hr>
<h2 id='cluster_pair_minsim'>Generate pairs with a minimal similarity using multiple processes</h2><span id='topic+cluster_pair_minsim'></span>

<h3>Description</h3>

<p>Generates all combinations of records from <code>x</code> and <code>y</code> where the 
blocking variables are equal.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cluster_pair_minsim(
  cluster,
  x,
  y,
  on,
  minsim = 0,
  on_blocking = character(0),
  comparators = list(default_comparator),
  default_comparator = cmp_identical(),
  keep_simsum = TRUE,
  deduplication = FALSE,
  name = "default"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cluster_pair_minsim_+3A_cluster">cluster</code></td>
<td>
<p>a cluster object as created by <code><a href="parallel.html#topic+makeCluster">makeCluster</a></code>
from <code>parallel</code> or <code>makeCluster</code> from <code>snow</code>.</p>
</td></tr>
<tr><td><code id="cluster_pair_minsim_+3A_x">x</code></td>
<td>
<p>first <code>data.frame</code></p>
</td></tr>
<tr><td><code id="cluster_pair_minsim_+3A_y">y</code></td>
<td>
<p>second <code>data.frame</code>. Ignored when <code>deduplication = TRUE</code>.</p>
</td></tr>
<tr><td><code id="cluster_pair_minsim_+3A_on">on</code></td>
<td>
<p>the variables defining the blocks or strata for which 
all pairs of <code>x</code> and <code>y</code> will be generated.</p>
</td></tr>
<tr><td><code id="cluster_pair_minsim_+3A_minsim">minsim</code></td>
<td>
<p>minimal similarity score.</p>
</td></tr>
<tr><td><code id="cluster_pair_minsim_+3A_on_blocking">on_blocking</code></td>
<td>
<p>variables for which the pairs have to match.</p>
</td></tr>
<tr><td><code id="cluster_pair_minsim_+3A_comparators">comparators</code></td>
<td>
<p>named list of functions with which the variables are compared. 
This function should accept two vectors. Function should either return a vector
or a <code>data.table</code> with multiple columns.</p>
</td></tr>
<tr><td><code id="cluster_pair_minsim_+3A_default_comparator">default_comparator</code></td>
<td>
<p>variables for which no comparison function is defined using
<code>comparators</code> is compares with the function <code>default_comparator</code>.</p>
</td></tr>
<tr><td><code id="cluster_pair_minsim_+3A_keep_simsum">keep_simsum</code></td>
<td>
<p>add a variable <code>minsim</code> to the result with the similarity 
score of the pair.</p>
</td></tr>
<tr><td><code id="cluster_pair_minsim_+3A_deduplication">deduplication</code></td>
<td>
<p>generate pairs from only <code>x</code>. Ignore <code>y</code>. This 
is usefull for deduplication of <code>x</code>.</p>
</td></tr>
<tr><td><code id="cluster_pair_minsim_+3A_name">name</code></td>
<td>
<p>the name of the resulting object to create locally on the different
R processes.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Generating (all) pairs of the records of two data sets, is usually the first 
step when linking the two data sets. However, this often results in a too 
large number of records. <code>pair_minsim</code> will only keep pairs with a 
similarity score equal or larger than <code>minsim</code>. The similarity score is
calculated by summing the results of the comparators for all variables 
of <code>on</code>.
</p>
<p><code>x</code> is split into <code>length{cluster}</code> parts which are distributed
over the worker nodes. <code>y</code> is copied to each of the nodes. On the nodes
then <code><a href="#topic+cluster_pair_minsim">cluster_pair_minsim</a></code> is called. The pairs are stored in the global
object <code>reclin_env</code> on the nodes in the variable <code>name</code>. The pairs
can then be further processes using functions such as
<code><a href="#topic+compare_pairs">compare_pairs</a></code>, and <code><a href="#topic+tabulate_patterns">tabulate_patterns</a></code>. The function
<code><a href="#topic+cluster_collect">cluster_collect</a></code> collects the pairs from each of the nodes.
</p>


<h3>Value</h3>

<p>A object of type <code>cluster_pairs</code> which is a <code>list</code> containing the
cluster and the name of the pairs object on the cluster nodes. For the pairs
objects created on the nodes see the documentation of <code><a href="#topic+pair">pair</a></code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+cluster_pair">cluster_pair</a></code> and <code><a href="#topic+cluster_pair_blocking">cluster_pair_blocking</a></code> are 
other methods to generate pairs.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(parallel)
data("linkexample1", "linkexample2")
cl &lt;- makeCluster(2)

# Either address or postcode has to match to keep a pair
pairs &lt;- cluster_pair_minsim(cl, linkexample1, linkexample2, 
   on = c("postcode", "address"), minsim = 1)
stopCluster(cl)

</code></pre>

<hr>
<h2 id='cmp_identical'>Comparison functions</h2><span id='topic+cmp_identical'></span><span id='topic+cmp_jarowinkler'></span><span id='topic+jaro_winkler'></span><span id='topic+cmp_lcs'></span><span id='topic+lcs'></span><span id='topic+cmp_jaccard'></span><span id='topic+jaccard'></span>

<h3>Description</h3>

<p>Comparison functions
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cmp_identical()

cmp_jarowinkler(threshold = 0.95)

jaro_winkler(threshold = 0.8)

cmp_lcs(threshold = 0.8)

lcs(threshold = 0.8)

cmp_jaccard(threshold = 0.8)

jaccard(threshold = 0.8)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cmp_identical_+3A_threshold">threshold</code></td>
<td>
<p>threshold to use for the Jaro-Winkler string distance when
creating a binary result.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A comparison function should accept two arguments: both vectors. When the 
function is called with both arguments it should compare the elements in the 
first vector to those in the second. When called in this way, both vectors
have the same length. What the function should return depends on the methods
used to score the pairs. Usually the comparison functions return a similarity
score with a value of 0 indication complete difference and a value &gt; 0 
indicating similarity (often a value of 1 will indicate perfect similarity). 
</p>
<p>Some methods, such as <code><a href="#topic+problink_em">problink_em</a></code>, can handle similarity
scores, but also need binary values (<code>0</code>/<code>FALSE</code> = complete 
dissimilarity; <code>1</code>/<code>TRUE</code> = complete similarity). In order to
allow for this the comparison function is called with one argument.
</p>
<p>When the comparison is called with one argument, it is passed the result of
a previous comparison. The function should translate that result to a binary 
(<code>TRUE</code>/<code>FALSE</code> or <code>1</code>/<code>0</code>) result. The result should 
not contain missing values. 
</p>
<p>The <code>jaro_winkler</code>, <code>lcs</code> and <code>jaccard</code> functions use the corresponding 
methods from <code><a href="stringdist.html#topic+stringdist">stringdist</a></code> except that they are transformed from
a distance to a similarity score.
</p>


<h3>Value</h3>

<p>The functions return a comparison function (see details).
</p>


<h3>Warning</h3>

<p>The functions <code>identical</code>, <code>jaro_winkler</code>, <code>lcs</code> and
<code>jaccard</code> are deprecated and will be removed in future versions of the
package. Instead use the functions <code>cmp_identical</code>,
<code>cmp_jarowinkler</code>, <code>cmp_lcs</code> and <code>cmp_jaccard</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>cmp &lt;- cmp_identical()
x &lt;- cmp(c("john", "mary", "susan", "jack"), 
         c("johan", "mary", "susanna", NA))
# Applying the comparison function to the result of the comparison results 
# in a logical result, with NA's and values of FALSE set to FALSE
cmp(x)

cmp &lt;- cmp_jarowinkler(0.95)
x &lt;- cmp(c("john", "mary", "susan", "jack"), 
         c("johan", "mary", "susanna", NA))
# Applying the comparison function to the result of the comparison results 
# in a logical result, with NA's and values below the threshold FALSE
cmp(x)



</code></pre>

<hr>
<h2 id='compare_pairs.cluster_pairs'>Compare pairs on a set of variables common in both data sets</h2><span id='topic+compare_pairs.cluster_pairs'></span><span id='topic+compare_pairs'></span><span id='topic+compare_pairs.pairs'></span>

<h3>Description</h3>

<p>Compare pairs on a set of variables common in both data sets
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'cluster_pairs'
compare_pairs(
  pairs,
  on,
  comparators = list(default_comparator),
  default_comparator = cmp_identical(),
  new_name = NULL,
  ...
)

compare_pairs(
  pairs,
  on,
  comparators = list(default_comparator),
  default_comparator = cmp_identical(),
  ...
)

## S3 method for class 'pairs'
compare_pairs(
  pairs,
  on,
  comparators = list(default_comparator),
  default_comparator = cmp_identical(),
  x = attr(pairs, "x"),
  y = attr(pairs, "y"),
  inplace = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="compare_pairs.cluster_pairs_+3A_pairs">pairs</code></td>
<td>
<p><code><a href="data.table.html#topic+data.table">data.table</a></code> with pairs. Should contain the columns 
<code>.x</code> and <code>.y</code>.</p>
</td></tr>
<tr><td><code id="compare_pairs.cluster_pairs_+3A_on">on</code></td>
<td>
<p>character vector of variables that should be compared.</p>
</td></tr>
<tr><td><code id="compare_pairs.cluster_pairs_+3A_comparators">comparators</code></td>
<td>
<p>named list of functions with which the variables are compared. 
This function should accept two vectors. Function should either return a vector
or a <code>data.table</code> with multiple columns.</p>
</td></tr>
<tr><td><code id="compare_pairs.cluster_pairs_+3A_default_comparator">default_comparator</code></td>
<td>
<p>variables for which no comparison function is defined using
<code>comparators</code> is compares with the function <code>default_comparator</code>.</p>
</td></tr>
<tr><td><code id="compare_pairs.cluster_pairs_+3A_new_name">new_name</code></td>
<td>
<p>name of new object to assign the pairs to on the cluster
nodes.</p>
</td></tr>
<tr><td><code id="compare_pairs.cluster_pairs_+3A_...">...</code></td>
<td>
<p>Ignored for now</p>
</td></tr>
<tr><td><code id="compare_pairs.cluster_pairs_+3A_x">x</code></td>
<td>
<p><code>data.table</code> with one half of the pairs.</p>
</td></tr>
<tr><td><code id="compare_pairs.cluster_pairs_+3A_y">y</code></td>
<td>
<p><code>data.table</code> with the other half of the pairs.</p>
</td></tr>
<tr><td><code id="compare_pairs.cluster_pairs_+3A_inplace">inplace</code></td>
<td>
<p>logical indicating whether <code>pairs</code> should be modified in place. When
pairs is large this can be more efficient.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>It is assumed the variables in <code>on</code> are present in both <code>x</code> and <code>y</code>. Variables
with the same names are added to pairs. 
When the <code>comparator</code> returns a <code>data.table</code> multiple columns are added to <code>pairs</code>. 
The names of these columns are <code>variable</code> pasted together with the names of 
the <code>data.table</code> returned by <code>comparator</code> (separated by &quot;_&quot;).
</p>


<h3>Value</h3>

<p>Returns the <code>data.table</code> <code>pairs</code> with one or more columns added in
case of <code>compare_pairs.pairs</code>. 
</p>
<p>In case of <code>compare_pairs.cluster_pairs</code>, <code>compare_pair.pairs</code> is called on
each cluster node and the resulting pairs are assigned to <code>new_name</code> in
the environment <code>reclin_env</code>. When <code>new_name</code> is not given (or
equal to NULL) the original pairs on the nodes are overwritten.
</p>

<hr>
<h2 id='compare_vars.cluster_pairs'>Compare pairs on given variables</h2><span id='topic+compare_vars.cluster_pairs'></span><span id='topic+compare_vars'></span><span id='topic+compare_vars.pairs'></span>

<h3>Description</h3>

<p>Compare pairs on given variables
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'cluster_pairs'
compare_vars(
  pairs,
  variable,
  on_x = variable,
  on_y = on_x,
  comparator = cmp_identical(),
  new_name = NULL,
  ...
)

compare_vars(
  pairs,
  variable,
  on_x = variable,
  on_y = on_x,
  comparator = cmp_identical(),
  ...
)

## S3 method for class 'pairs'
compare_vars(
  pairs,
  variable,
  on_x = variable,
  on_y = on_x,
  comparator = cmp_identical(),
  x = attr(pairs, "x"),
  y = attr(pairs, "y"),
  inplace = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="compare_vars.cluster_pairs_+3A_pairs">pairs</code></td>
<td>
<p><code><a href="data.table.html#topic+data.table">data.table</a></code> with pairs. Should contain the columns 
<code>.x</code> and <code>.y</code>.</p>
</td></tr>
<tr><td><code id="compare_vars.cluster_pairs_+3A_variable">variable</code></td>
<td>
<p>character vector with name of resulting column name that is added
to pairs.</p>
</td></tr>
<tr><td><code id="compare_vars.cluster_pairs_+3A_on_x">on_x</code></td>
<td>
<p>character vector with the column names from <code>x</code> on which to 
compare.</p>
</td></tr>
<tr><td><code id="compare_vars.cluster_pairs_+3A_on_y">on_y</code></td>
<td>
<p>character vector with the column names from <code>y</code> on which to 
compare.</p>
</td></tr>
<tr><td><code id="compare_vars.cluster_pairs_+3A_comparator">comparator</code></td>
<td>
<p>function with which the variables are compared. When <code>on_x</code> and 
<code>on_y</code> have length 1, this function should accept two vectors. Otherwise
it will receive two <code>data.tables</code>. Function should either return a vector
or a <code>data.table</code> with multiple columns.</p>
</td></tr>
<tr><td><code id="compare_vars.cluster_pairs_+3A_new_name">new_name</code></td>
<td>
<p>name of new object to assign the pairs to on the cluster
nodes.</p>
</td></tr>
<tr><td><code id="compare_vars.cluster_pairs_+3A_...">...</code></td>
<td>
<p>Passed on to the comparator function.</p>
</td></tr>
<tr><td><code id="compare_vars.cluster_pairs_+3A_x">x</code></td>
<td>
<p><code>data.table</code> with one half of the pairs.</p>
</td></tr>
<tr><td><code id="compare_vars.cluster_pairs_+3A_y">y</code></td>
<td>
<p><code>data.table</code> with the other half of the pairs.</p>
</td></tr>
<tr><td><code id="compare_vars.cluster_pairs_+3A_inplace">inplace</code></td>
<td>
<p>logical indicating whether <code>pairs</code> should be modified in place. When
pairs is large this can be more efficient.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>When <code>comparator</code> returns a <code>data.table</code> multiple columns are added to <code>pairs</code>. 
The names of these columns are <code>variable</code> pasted together with the names of 
the <code>data.table</code> returned by <code>comparator</code> (separated by &quot;_&quot;).
</p>


<h3>Value</h3>

<p>Returns the <code>data.table</code> <code>pairs</code> with one or more columns added.
</p>

<hr>
<h2 id='deduplicate_equivalence'>Deduplication using equivalence groups</h2><span id='topic+deduplicate_equivalence'></span>

<h3>Description</h3>

<p>Deduplication using equivalence groups
</p>


<h3>Usage</h3>

<pre><code class='language-R'>deduplicate_equivalence(pairs, variable, selection, x = attr(pairs, "x"))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="deduplicate_equivalence_+3A_pairs">pairs</code></td>
<td>
<p>a <code>pairs</code> object, such as generated by 
<code><a href="#topic+pair_blocking">pair_blocking</a></code></p>
</td></tr>
<tr><td><code id="deduplicate_equivalence_+3A_variable">variable</code></td>
<td>
<p>name of the variable to create in <code>x</code> that will contain the
group labels.</p>
</td></tr>
<tr><td><code id="deduplicate_equivalence_+3A_selection">selection</code></td>
<td>
<p>a logical variable with the same length as <code>pairs</code> has
rows, or the name of such a variable in <code>pairs</code>. Pairs are only 
selected when <code>select</code> is <code>TRUE</code>. When missing 
it is assumed all pairs are selected.</p>
</td></tr>
<tr><td><code id="deduplicate_equivalence_+3A_x">x</code></td>
<td>
<p>the first data set; when missing <code>attr(pairs, "x")</code> is used.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns <code>x</code> with a variable containing the group labels. Records with 
the same group label (should) correspond to the same entity.
</p>

<hr>
<h2 id='get_inspect_pairs'>Get a subset of pairs to inspect</h2><span id='topic+get_inspect_pairs'></span>

<h3>Description</h3>

<p>Get a subset of pairs to inspect
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_inspect_pairs(
  pairs,
  variable,
  threshold,
  position = NULL,
  n = 11,
  x = attr(pairs, "x"),
  y = attr(pairs, "y")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_inspect_pairs_+3A_pairs">pairs</code></td>
<td>
<p><code><a href="data.table.html#topic+data.table">data.table</a></code> with pairs.</p>
</td></tr>
<tr><td><code id="get_inspect_pairs_+3A_variable">variable</code></td>
<td>
<p>name of variable to base the selection on; should be a variable
with the similarity score of the pairs.</p>
</td></tr>
<tr><td><code id="get_inspect_pairs_+3A_threshold">threshold</code></td>
<td>
<p>the threshold around which to select pairs. Used when position 
is not given.</p>
</td></tr>
<tr><td><code id="get_inspect_pairs_+3A_position">position</code></td>
<td>
<p>select pairs around this position (based on order of 
<code>variable</code>), e.g. <code>position = 1</code> will select the pairs with the 
highest similarity score.</p>
</td></tr>
<tr><td><code id="get_inspect_pairs_+3A_n">n</code></td>
<td>
<p>number of pairs to select. Pairs are selected symmetric around the 
theshold.</p>
</td></tr>
<tr><td><code id="get_inspect_pairs_+3A_x">x</code></td>
<td>
<p><code>data.table</code> with one half of the pairs.</p>
</td></tr>
<tr><td><code id="get_inspect_pairs_+3A_y">y</code></td>
<td>
<p><code>data.table</code> with the other half of the pairs.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a list with elements <code>pairs</code> with the selected pairs; 
<code>x</code> records from <code>x</code> corresponding to the pairs; <code>y</code> records
from <code>y</code> corresponding to the pairs; <code>position</code> position of the 
selected pairs; <code>index</code> index of the pairs in <code>pairs</code>.
</p>

<hr>
<h2 id='greedy'>Greedy one-to-one matching of pairs</h2><span id='topic+greedy'></span>

<h3>Description</h3>

<p>Greedy one-to-one matching of pairs
</p>


<h3>Usage</h3>

<pre><code class='language-R'>greedy(x, y, weight, n = 1L, m = 1L, include_ties = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="greedy_+3A_x">x</code></td>
<td>
<p>id's of lhs of pairs; converted to integer</p>
</td></tr>
<tr><td><code id="greedy_+3A_y">y</code></td>
<td>
<p>id's of rhs of pairs; converted to integer</p>
</td></tr>
<tr><td><code id="greedy_+3A_weight">weight</code></td>
<td>
<p>numeric vector with weight of pair</p>
</td></tr>
<tr><td><code id="greedy_+3A_n">n</code></td>
<td>
<p>an integer. Each element of x can be linked to at most n elements of
y.</p>
</td></tr>
<tr><td><code id="greedy_+3A_m">m</code></td>
<td>
<p>an integer. Each element of y can be linked to at most m elements of
x.</p>
</td></tr>
<tr><td><code id="greedy_+3A_include_ties">include_ties</code></td>
<td>
<p>when pairs for a given record have an equal weight, should
all pairs be included.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Pairs with the highest weight are selected as long a neither the lhs as the
rhs are already selected in a pair with a higher weight. When <code>include_ties</code>
is <code>TRUE</code> all pairs are included when multiple pairs for a given record have
an equal weight.
</p>


<h3>Value</h3>

<p>A logical vector with the same length as <code>x</code>.
</p>

<hr>
<h2 id='link'>Use the selected pairs to generate a linked data set</h2><span id='topic+link'></span>

<h3>Description</h3>

<p>Use the selected pairs to generate a linked data set
</p>


<h3>Usage</h3>

<pre><code class='language-R'>link(
  pairs,
  selection = NULL,
  all = FALSE,
  all_x = all,
  all_y = all,
  x = attr(pairs, "x"),
  y = attr(pairs, "y"),
  suffixes = c(".x", ".y"),
  keep_from_pairs = c(".x", ".y")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="link_+3A_pairs">pairs</code></td>
<td>
<p>a <code>pairs</code> object, such as generated by 
<code><a href="#topic+pair_blocking">pair_blocking</a></code></p>
</td></tr>
<tr><td><code id="link_+3A_selection">selection</code></td>
<td>
<p>a logical variable with the same length as <code>pairs</code> has
rows, or the name of such a variable in <code>pairs</code>. Pairs are only 
selected when <code>select</code> is <code>TRUE</code>. When missing 
<code>attr(pairs, "selection")</code> is used when available.</p>
</td></tr>
<tr><td><code id="link_+3A_all">all</code></td>
<td>
<p>return all records from <code>x</code> and <code>y</code>; even those that 
don't match.</p>
</td></tr>
<tr><td><code id="link_+3A_all_x">all_x</code></td>
<td>
<p>return all records from <code>x</code>.</p>
</td></tr>
<tr><td><code id="link_+3A_all_y">all_y</code></td>
<td>
<p>return all records from <code>y</code>.</p>
</td></tr>
<tr><td><code id="link_+3A_x">x</code></td>
<td>
<p>the first data set; when missing <code>attr(pairs, "x")</code> is used.</p>
</td></tr>
<tr><td><code id="link_+3A_y">y</code></td>
<td>
<p>the second data set; when missing <code>attr(pairs, "y")</code> is used.</p>
</td></tr>
<tr><td><code id="link_+3A_suffixes">suffixes</code></td>
<td>
<p>a character vector of length 2 specifying the suffixes to be
used for making unique the names of columns in the result.</p>
</td></tr>
<tr><td><code id="link_+3A_keep_from_pairs">keep_from_pairs</code></td>
<td>
<p>character vector with names of variables in <code>pairs</code>
that should be included in the output.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Uses the selected pairs to link the two data sets to each other. Renames 
variables that are in both data sets.
</p>


<h3>Value</h3>

<p>Returns a <code>data.table</code> containing records from <code>x</code> and <code>y</code> and
<code>pairs</code>. Columns that occur both in <code>x</code> and <code>y</code> gain a suffix
indicating from which data set they are.
</p>

<hr>
<h2 id='linkexample1'>Tiny example dataset for probabilistic linkage</h2><span id='topic+linkexample1'></span><span id='topic+linkexample2'></span>

<h3>Description</h3>

<p>Contains fictional records of 7 persons.
</p>


<h3>Format</h3>

<p>Two data frames with resp. 6 and 5 records and 6 columns.
</p>


<h3>Details</h3>


<ul>
<li> <p><code>id</code> the id of the person; this contains no errors and can be used to 
validate the linkage. 
</p>
</li>
<li> <p><code>lastname</code> the last name of the person; contains errors.
</p>
</li>
<li> <p><code>firstname</code> the first name of the persons; contains errors.
</p>
</li>
<li> <p><code>address</code> the address; contains errors.
</p>
</li>
<li> <p><code>sex</code> the sex; contains errors and missing values.
</p>
</li>
<li> <p><code>postcode</code> the postcode; contains no errors. 
</p>
</li></ul>


<hr>
<h2 id='match_n_to_m'>Force n to m matching on a set of pairs</h2><span id='topic+match_n_to_m'></span>

<h3>Description</h3>

<p>Force n to m matching on a set of pairs
</p>


<h3>Usage</h3>

<pre><code class='language-R'>match_n_to_m(x, y, w, n = 1, m = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="match_n_to_m_+3A_x">x</code></td>
<td>
<p>a vector of identifiers for each x in each pair This vector should 
have a unique value for each element in x.</p>
</td></tr>
<tr><td><code id="match_n_to_m_+3A_y">y</code></td>
<td>
<p>a vector of identifiers for each y in each pair This vector should 
have a unique value for each element in y.</p>
</td></tr>
<tr><td><code id="match_n_to_m_+3A_w">w</code></td>
<td>
<p>a vector with weights for each pair. The algorithm will try to 
maximise the total weight of the selected pairs.</p>
</td></tr>
<tr><td><code id="match_n_to_m_+3A_n">n</code></td>
<td>
<p>an integer. Each element of x can be linked to at most n elements of
y.</p>
</td></tr>
<tr><td><code id="match_n_to_m_+3A_m">m</code></td>
<td>
<p>an integer. Each element of y can be linked to at most m elements of
x.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The algorithm will try to select pairs in such a way each element of <code>x</code>
is matched to at most <code>n</code> elements of <code>y</code> and that each element of
<code>y</code> is matched at most <code>m</code> elements of <code>x</code>. It tries to select 
elements in such a way that the total weight <code>w</code> of the selected 
elements is maximised.
</p>


<h3>Value</h3>

<p>A logical vector with the same length as <code>x</code> indicating the selected 
records.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>d &lt;- data.frame(x=c(1,1,1,2,2,3,3), y=c(1,2,3,4,5,6,7), w=1:7)
# One-to-one matching:
d[match_n_to_m(d$x, d$y, d$w), ]

# N-to-one matching:
d[match_n_to_m(d$x, d$y, d$w, n=999), ]

# One-to-m matching:
d[match_n_to_m(d$x, d$y, d$w, m=999), ]

# N-to-M matching, e.g. select all pairs
d[match_n_to_m(d$x, d$y, d$w, n=999, m=999), ]



</code></pre>

<hr>
<h2 id='merge_pairs.cluster_pairs'>Merge two sets of pairs into one</h2><span id='topic+merge_pairs.cluster_pairs'></span><span id='topic+rbind.cluster_pairs'></span><span id='topic+merge_pairs'></span><span id='topic+merge_pairs.pairs'></span><span id='topic+rbind.pairs'></span>

<h3>Description</h3>

<p>Merge two sets of pairs into one
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'cluster_pairs'
merge_pairs(
  pairs1,
  pairs2,
  name = paste(pairs1$name, pairs2$name, sep = "+"),
  ...
)

## S3 method for class 'cluster_pairs'
rbind(...)

merge_pairs(pairs1, pairs2, ...)

## S3 method for class 'pairs'
merge_pairs(pairs1, pairs2, ...)

## S3 method for class 'pairs'
rbind(...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="merge_pairs.cluster_pairs_+3A_pairs1">pairs1</code></td>
<td>
<p>the first set of pairs</p>
</td></tr>
<tr><td><code id="merge_pairs.cluster_pairs_+3A_pairs2">pairs2</code></td>
<td>
<p>the second set of pairs</p>
</td></tr>
<tr><td><code id="merge_pairs.cluster_pairs_+3A_name">name</code></td>
<td>
<p>name of new object to assign the pairs to on the cluster
nodes.</p>
</td></tr>
<tr><td><code id="merge_pairs.cluster_pairs_+3A_...">...</code></td>
<td>
<p>for <code>rbind</code> the <code>pairs</code> or <code>cluster_pairs</code> objects 
the need to be combined; for <code>merge_pairs</code> these are passed on to 
other methods.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function will give an error when the two sets of pairs have different values
for <code>attr(pairs1, "x")</code> and <code>attr(pairs1, "y")</code>. When these attributes
are missing the code will not generate an error; the user is then
responsible for ensuring that the indices in <code>pairs1</code> and <code>pairs2</code>
refer to the same datasets.
</p>


<h3>Value</h3>

<p>Returns a <code>pairs</code> or <code>cluster_pairs</code> object where both sets of pairs
are combined. Duplicate pairs are removed. 
</p>
<p>In case of <code>merge_pairs.cluster_pairs</code>, <code>merge_pairs.pairs</code> is called on
each cluster node and the resulting pairs are assigned to <code>name</code> in
the environment <code>reclin_env</code>.
</p>

<hr>
<h2 id='pair'>Generate all possible pairs</h2><span id='topic+pair'></span>

<h3>Description</h3>

<p>Generates all combinations of records from <code>x</code> and <code>y</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pair(x, y, deduplication = FALSE, add_xy = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pair_+3A_x">x</code></td>
<td>
<p>first <code>data.frame</code></p>
</td></tr>
<tr><td><code id="pair_+3A_y">y</code></td>
<td>
<p>second <code>data.frame</code>. Ignored when <code>deduplication = TRUE</code>.</p>
</td></tr>
<tr><td><code id="pair_+3A_deduplication">deduplication</code></td>
<td>
<p>generate pairs from only <code>x</code>. Ignore <code>y</code>. This 
is usefull for deduplication of <code>x</code>.</p>
</td></tr>
<tr><td><code id="pair_+3A_add_xy">add_xy</code></td>
<td>
<p>add <code>x</code> and <code>y</code> as attributes to the returned 
pairs. This makes calling some subsequent operations that need <code>x</code> and 
<code>y</code> (such as <code><a href="#topic+compare_pairs">compare_pairs</a></code> easier.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Generating (all) pairs of the records of two data sets, is usually the first 
step when linking the two data sets.
</p>


<h3>Value</h3>

<p>A <code><a href="data.table.html#topic+data.table">data.table</a></code> with two columns, 
<code>.x</code> and <code>.y</code>, is returned. Columns <code>.x</code> and <code>.y</code> are 
row numbers from <code>data.frame</code>s <code>.x</code> and <code>.y</code> respectively.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+pair_blocking">pair_blocking</a></code> and <code><a href="#topic+pair_minsim">pair_minsim</a></code> are other methods
to generate pairs.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("linkexample1", "linkexample2")
pairs &lt;- pair(linkexample1, linkexample2)

</code></pre>

<hr>
<h2 id='pair_blocking'>Generate pairs using simple blocking</h2><span id='topic+pair_blocking'></span>

<h3>Description</h3>

<p>Generates all combinations of records from <code>x</code> and <code>y</code> where the 
blocking variables are equal.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pair_blocking(x, y, on, deduplication = FALSE, add_xy = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pair_blocking_+3A_x">x</code></td>
<td>
<p>first <code>data.frame</code></p>
</td></tr>
<tr><td><code id="pair_blocking_+3A_y">y</code></td>
<td>
<p>second <code>data.frame</code>. Ignored when <code>deduplication = TRUE</code>.</p>
</td></tr>
<tr><td><code id="pair_blocking_+3A_on">on</code></td>
<td>
<p>the variables defining the blocks or strata for which 
all pairs of <code>x</code> and <code>y</code> will be generated.</p>
</td></tr>
<tr><td><code id="pair_blocking_+3A_deduplication">deduplication</code></td>
<td>
<p>generate pairs from only <code>x</code>. Ignore <code>y</code>. This 
is usefull for deduplication of <code>x</code>.</p>
</td></tr>
<tr><td><code id="pair_blocking_+3A_add_xy">add_xy</code></td>
<td>
<p>add <code>x</code> and <code>y</code> as attributes to the returned 
pairs. This makes calling some subsequent operations that need <code>x</code> and 
<code>y</code> (such as <code><a href="#topic+compare_pairs">compare_pairs</a></code> easier.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Generating (all) pairs of the records of two data sets, is usually the first 
step when linking the two data sets. However, this often results in a too 
large number of records. Therefore, blocking is usually applied.
</p>


<h3>Value</h3>

<p>A <code><a href="data.table.html#topic+data.table">data.table</a></code> with two columns, 
<code>.x</code> and <code>.y</code>, is returned. Columns <code>.x</code> and <code>.y</code> are 
row numbers from <code>data.frame</code>s <code>.x</code> and <code>.y</code> respectively.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+pair">pair</a></code> and <code><a href="#topic+pair_minsim">pair_minsim</a></code> are other methods
to generate pairs.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("linkexample1", "linkexample2")
pairs &lt;- pair_blocking(linkexample1, linkexample2, "postcode")

</code></pre>

<hr>
<h2 id='pair_minsim'>Generate pairs with a minimal similarity</h2><span id='topic+pair_minsim'></span>

<h3>Description</h3>

<p>Generates all combinations of records from <code>x</code> and <code>y</code> where the 
blocking variables are equal.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pair_minsim(
  x,
  y,
  on,
  minsim = 0,
  on_blocking = character(0),
  comparators = list(default_comparator),
  default_comparator = cmp_identical(),
  keep_simsum = TRUE,
  deduplication = FALSE,
  add_xy = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pair_minsim_+3A_x">x</code></td>
<td>
<p>first <code>data.frame</code></p>
</td></tr>
<tr><td><code id="pair_minsim_+3A_y">y</code></td>
<td>
<p>second <code>data.frame</code>. Ignored when <code>deduplication = TRUE</code>.</p>
</td></tr>
<tr><td><code id="pair_minsim_+3A_on">on</code></td>
<td>
<p>the variables defining on which the pairs of records from <code>x</code> 
and <code>y</code> are compared.</p>
</td></tr>
<tr><td><code id="pair_minsim_+3A_minsim">minsim</code></td>
<td>
<p>minimal similarity score.</p>
</td></tr>
<tr><td><code id="pair_minsim_+3A_on_blocking">on_blocking</code></td>
<td>
<p>variables for which the pairs have to match.</p>
</td></tr>
<tr><td><code id="pair_minsim_+3A_comparators">comparators</code></td>
<td>
<p>named list of functions with which the variables are compared. 
This function should accept two vectors. Function should either return a vector
or a <code>data.table</code> with multiple columns.</p>
</td></tr>
<tr><td><code id="pair_minsim_+3A_default_comparator">default_comparator</code></td>
<td>
<p>variables for which no comparison function is defined using
<code>comparators</code> is compares with the function <code>default_comparator</code>.</p>
</td></tr>
<tr><td><code id="pair_minsim_+3A_keep_simsum">keep_simsum</code></td>
<td>
<p>add a variable <code>minsim</code> to the result with the similarity 
score of the pair.</p>
</td></tr>
<tr><td><code id="pair_minsim_+3A_deduplication">deduplication</code></td>
<td>
<p>generate pairs from only <code>x</code>. Ignore <code>y</code>. This 
is usefull for deduplication of <code>x</code>.</p>
</td></tr>
<tr><td><code id="pair_minsim_+3A_add_xy">add_xy</code></td>
<td>
<p>add <code>x</code> and <code>y</code> as attributes to the returned 
pairs. This makes calling some subsequent operations that need <code>x</code> and 
<code>y</code> (such as <code><a href="#topic+compare_pairs">compare_pairs</a></code> easier.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Generating (all) pairs of the records of two data sets, is usually the first 
step when linking the two data sets. However, this often results in a too 
large number of records. <code>pair_minsim</code> will only keep pairs with a 
similarity score equal or larger than <code>minsim</code>. The similarity score is
calculated by summing the results of the comparators for all variables 
of <code>on</code>.
</p>
<p>Missing values in the variables on which the pairs are compared count as a 
similarity of 0.
</p>


<h3>Value</h3>

<p>A <code><a href="data.table.html#topic+data.table">data.table</a></code> with two columns, 
<code>.x</code> and <code>.y</code>, is returned. Columns <code>.x</code> and <code>.y</code> are 
row numbers from <code>data.frame</code>s <code>.x</code> and <code>.y</code> respectively.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+pair">pair</a></code> and <code><a href="#topic+pair_blocking">pair_blocking</a></code> are other methods
to generate pairs.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("linkexample1", "linkexample2")
pairs &lt;- pair_minsim(linkexample1, linkexample2, 
   on = c("postcode", "address"), minsim = 1)
# Either address or postcode has to match to keep a pair

data("linkexample1", "linkexample2")
pairs &lt;- pair_minsim(linkexample1, linkexample2, on_blocking = "postcode",
   on = c("lastname", "firstname", "address"), minsim = 2)
# Postcode has to match; from lastname, firstname, address there have to match
# two or more (e.g. one mismatch is allowed).

</code></pre>

<hr>
<h2 id='predict.problink_em'>Calculate weights and probabilities for pairs</h2><span id='topic+predict.problink_em'></span>

<h3>Description</h3>

<p>Calculate weights and probabilities for pairs
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'problink_em'
predict(
  object,
  pairs = newdata,
  newdata = NULL,
  type = c("weights", "mpost", "probs", "all"),
  binary = FALSE,
  add = FALSE,
  comparators,
  inplace = FALSE,
  new_name = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="predict.problink_em_+3A_object">object</code></td>
<td>
<p>an object of type <code>problink_em</code> as produced by 
<code><a href="#topic+problink_em">problink_em</a></code>.</p>
</td></tr>
<tr><td><code id="predict.problink_em_+3A_pairs">pairs</code></td>
<td>
<p>a object with pairs for which to calculate weights.</p>
</td></tr>
<tr><td><code id="predict.problink_em_+3A_newdata">newdata</code></td>
<td>
<p>an alternative name for the <code>pairs</code> argument. Specify 
<code>newdata</code> or <code>pairs</code>.</p>
</td></tr>
<tr><td><code id="predict.problink_em_+3A_type">type</code></td>
<td>
<p>a character vector of length one specifying what to calculate. 
See results for more information.</p>
</td></tr>
<tr><td><code id="predict.problink_em_+3A_binary">binary</code></td>
<td>
<p>convert comparison vectors to binary vectors using the 
comparison function in comparators.</p>
</td></tr>
<tr><td><code id="predict.problink_em_+3A_add">add</code></td>
<td>
<p>add the predictions to the original pairs object.</p>
</td></tr>
<tr><td><code id="predict.problink_em_+3A_comparators">comparators</code></td>
<td>
<p>a list of comparison functions (see <code><a href="#topic+compare_pairs">compare_pairs</a></code>). 
When missing <code>attr(pairs, 'comparators')</code> is used.</p>
</td></tr>
<tr><td><code id="predict.problink_em_+3A_inplace">inplace</code></td>
<td>
<p>logical indicating whether <code>pairs</code> should be modified in place. When
pairs is large this can be more efficient.</p>
</td></tr>
<tr><td><code id="predict.problink_em_+3A_new_name">new_name</code></td>
<td>
<p>name of new object to assign the pairs to on the cluster
nodes (only relevant when pairs is of type <code>cluster_pairs</code>.</p>
</td></tr>
<tr><td><code id="predict.problink_em_+3A_...">...</code></td>
<td>
<p>unused.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>When <code>pairs</code> is of type <code>pairs</code>, returns a data.table with either
the <code>.x</code> and <code>.y</code> columns from  <code>pairs</code> (when <code>add = FALSE</code>) 
or all columns of <code>pairs</code>. To these columns are added: 
</p>

<ul>
<li><p> In case of <code>type = "weights"</code> a column <code>weights</code> with the calculated
weights.
</p>
</li>
<li><p> In case of <code>type = "mpost"</code> a column <code>mpost</code> with the calculated
posterior probabilities (probability that pair is a match given comparison vector.
</p>
</li>
<li><p> In case of <code>type = "prob"</code> the columns <code>mprob</code> and <code>uprob</code> with the
m and u-probabilites and <code>mpost</code> and <code>upost</code> with the posterior m- and
u-probabilities.
</p>
</li>
<li><p> In case of <code>type = "all"</code> all of the above.
</p>
</li></ul>

<p>In case of <code>compare_pairs.cluster_pairs</code>, <code>compare_pair.pairs</code> is called on
each cluster node and the resulting pairs are assigned to <code>new_name</code> in
the environment <code>reclin_env</code>. When <code>new_name</code> is not given (or
equal to NULL) the original pairs on the nodes are overwritten.
</p>

<hr>
<h2 id='problink_em'>Calculate EM-estimates of m- and u-probabilities</h2><span id='topic+problink_em'></span>

<h3>Description</h3>

<p>Calculate EM-estimates of m- and u-probabilities
</p>


<h3>Usage</h3>

<pre><code class='language-R'>problink_em(
  formula,
  data,
  patterns,
  mprobs0 = list(0.95),
  uprobs0 = list(0.02),
  p0 = 0.05,
  tol = 1e-05,
  mprob_max = 0.999,
  uprob_min = 1e-04
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="problink_em_+3A_formula">formula</code></td>
<td>
<p>a formula object with the variables for which to calculate the
m-  and u-probabilities. Should be of the form <code>~ var1 + var2</code>.</p>
</td></tr>
<tr><td><code id="problink_em_+3A_data">data</code></td>
<td>
<p>data set with pairs on which to estimate the model. Alternatively
one can use the <code>patterns</code> argument.</p>
</td></tr>
<tr><td><code id="problink_em_+3A_patterns">patterns</code></td>
<td>
<p>table of patterns (as output by 
<code><a href="#topic+tabulate_patterns">tabulate_patterns</a></code>).</p>
</td></tr>
<tr><td><code id="problink_em_+3A_mprobs0">mprobs0</code>, <code id="problink_em_+3A_uprobs0">uprobs0</code></td>
<td>
<p>initial values of the m- and u-probabilities. These
should be lists with numeric values. The names of the elements in the list
should correspond to the names in <code>by_x</code> in <code><a href="#topic+compare_pairs">compare_pairs</a></code>.</p>
</td></tr>
<tr><td><code id="problink_em_+3A_p0">p0</code></td>
<td>
<p>the initial estimate of the probability that a pair is a match.</p>
</td></tr>
<tr><td><code id="problink_em_+3A_tol">tol</code></td>
<td>
<p>when the change in the m and u-probabilities is smaller than <code>tol</code>
the algorithm is stopped.</p>
</td></tr>
<tr><td><code id="problink_em_+3A_mprob_max">mprob_max</code></td>
<td>
<p>maximum values of the estimated m-probabilities. Values equal to
one can lead to numerical instabilities.</p>
</td></tr>
<tr><td><code id="problink_em_+3A_uprob_min">uprob_min</code></td>
<td>
<p>maximum values of the estimated m-probabilities. Values equal to
zero can lead to numerical instabilities.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns an object of type <code>problink_em</code>. This is a list containing the
estimated <code>mprobs</code>, <code>uprobs</code> and overall linkage probability 
<code>p</code>. It also contains the table of comparison <code>patterns</code>.
</p>


<h3>References</h3>

<p>Fellegi, I. and A. Sunter (1969). &quot;A Theory for Record Linkage&quot;, 
<em>Journal of the American Statistical Association</em>. 64 (328): 
pp. 1183-1210. <a href="https://doi.org/10.2307/2286061">doi:10.2307/2286061</a>.
</p>
<p>Herzog, T.N., F.J. Scheuren and W.E. Winkler (2007). 
<em>Data Quality and Record Linkage Techniques</em>, Springer.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("linkexample1", "linkexample2")
pairs &lt;- pair_blocking(linkexample1, linkexample2, "postcode")
pairs &lt;- compare_pairs(pairs, c("lastname", "firstname", "address", "sex"))
model &lt;- problink_em(~ lastname + firstname + address + sex, data = pairs)
summary(model)

</code></pre>

<hr>
<h2 id='score_simple.cluster_pairs'>Score pairs based on a number of comparison vectors</h2><span id='topic+score_simple.cluster_pairs'></span><span id='topic+score_simple'></span><span id='topic+score_simple.pairs'></span>

<h3>Description</h3>

<p>Score pairs based on a number of comparison vectors
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'cluster_pairs'
score_simple(
  pairs,
  variable,
  on,
  w1 = 1,
  w0 = 0,
  wna = 0,
  new_name = NULL,
  ...
)

score_simple(pairs, variable, on, w1 = 1, w0 = 0, wna = 0, ...)

## S3 method for class 'pairs'
score_simple(
  pairs,
  variable,
  on,
  w1 = 1,
  w0 = 0,
  wna = 0,
  inplace = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="score_simple.cluster_pairs_+3A_pairs">pairs</code></td>
<td>
<p>a <code>pairs</code> object, such as generated by 
<code><a href="#topic+pair_blocking">pair_blocking</a></code></p>
</td></tr>
<tr><td><code id="score_simple.cluster_pairs_+3A_variable">variable</code></td>
<td>
<p>the name of the new variable to create in pairs. This will be a
logical variable with a value of <code>TRUE</code> for the selected pairs.</p>
</td></tr>
<tr><td><code id="score_simple.cluster_pairs_+3A_on">on</code></td>
<td>
<p>character vector of variables on which the score should be based.</p>
</td></tr>
<tr><td><code id="score_simple.cluster_pairs_+3A_w1">w1</code></td>
<td>
<p>a vector or list with weights for agreement for each of the
variables. It can either be a numeric vector of length 1 in which case the
same weight is used for all variables; A numeric vector of length equal to
the length of <code>on</code> in which case the weights correspond one-to-one to
the variables in <code>on</code>; A named numeric vector where the names
correspond to those in <code>on</code>, missing values are assigned a value of 1;
or a named list with numeric values.  See details for more information.</p>
</td></tr>
<tr><td><code id="score_simple.cluster_pairs_+3A_w0">w0</code></td>
<td>
<p>a vector or list with weights for non-agreement for each of the
variables. See details for more information. For the format see <code>w1</code>.</p>
</td></tr>
<tr><td><code id="score_simple.cluster_pairs_+3A_wna">wna</code></td>
<td>
<p>a vector or list with weights for agreement for each of the
variables. See details for more information. For the format see <code>w1</code>.</p>
</td></tr>
<tr><td><code id="score_simple.cluster_pairs_+3A_new_name">new_name</code></td>
<td>
<p>name of new object to assign the pairs to on the cluster
nodes.</p>
</td></tr>
<tr><td><code id="score_simple.cluster_pairs_+3A_...">...</code></td>
<td>
<p>ignored</p>
</td></tr>
<tr><td><code id="score_simple.cluster_pairs_+3A_inplace">inplace</code></td>
<td>
<p>logical indicating whether <code>pairs</code> should be modified in place. When
pairs is large this can be more efficient.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The individual contribution of a variable <code>x</code> to the total score is
given by <code>x * w1 + (1-x) * w0</code> in case of non-<code>NA</code> values and
<code>wna</code> in case of <code>NA</code>. This assumes that the values 1 corresponds
to complete agreement and the value 0 to complete non-agreement. In case of
complete agreement a variable contributes <code>w1</code> to the total score and in
case of complete non-agreement it contributes <code>w0</code> to the total score.
</p>


<h3>Value</h3>

<p>Returns the <code>data.table</code> <code>pairs</code> with the column <code>variable</code> added in
case of <code>score_simple.pairs</code>. 
</p>
<p>In case of <code>score_simple.cluster_pairs</code>, <code>score_simple.pairs</code> is called on
each cluster node and the resulting pairs are assigned to <code>new_name</code> in
the environment <code>reclin_env</code>. When <code>new_name</code> is not given (or
equal to NULL) the original pairs on the nodes are overwritten.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("linkexample1", "linkexample2")
pairs &lt;- pair_blocking(linkexample1, linkexample2, "postcode")
compare_pairs(pairs, on = c("firstname", "lastname", "sex"), inplace = TRUE)

score_simple(pairs, "score", on = c("firstname", "lastname", "sex"))

# Change the default weights
score_simple(pairs, "score", on = c("firstname", "lastname", "sex"), 
  w1 = 2, w0 = -1, wna = NA)

# Use a named vector; omited elements from w1 get a weight of 1; those from
# w0 and wna a weight of 0.
score_simple(pairs, "score", on = c("firstname", "lastname", "sex"), 
  w1 = c("firstname" = 2, "lastname" = 3), 
  w0 = c("firstname" = -1, "lastname" = -0.5))

# Use a named list; omited elements from w1 get a weight of 1; those from
# w0 and wna a weight of 0.
score_simple(pairs, "score", on = c("firstname", "lastname", "sex"), 
  w1 = list("firstname" = 2, "lastname" = 3), 
  w0 = list("firstname" = -1, "lastname" = -0.5))

</code></pre>

<hr>
<h2 id='select_greedy.cluster_pairs'>Select matching pairs enforcing one-to-one linkage</h2><span id='topic+select_greedy.cluster_pairs'></span><span id='topic+select_n_to_m.cluster_pairs'></span><span id='topic+select_greedy'></span><span id='topic+select_greedy.pairs'></span><span id='topic+select_n_to_m'></span><span id='topic+select_n_to_m.pairs'></span>

<h3>Description</h3>

<p>Select matching pairs enforcing one-to-one linkage
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'cluster_pairs'
select_greedy(
  pairs,
  variable,
  score,
  threshold,
  preselect = NULL,
  id_x = NULL,
  id_y = NULL,
  ...
)

## S3 method for class 'cluster_pairs'
select_n_to_m(
  pairs,
  variable,
  score,
  threshold,
  preselect = NULL,
  id_x = NULL,
  id_y = NULL,
  ...
)

select_greedy(
  pairs,
  variable,
  score,
  threshold,
  preselect = NULL,
  id_x = NULL,
  id_y = NULL,
  ...
)

## S3 method for class 'pairs'
select_greedy(
  pairs,
  variable,
  score,
  threshold,
  preselect = NULL,
  id_x = NULL,
  id_y = NULL,
  x = attr(pairs, "x"),
  y = attr(pairs, "y"),
  inplace = FALSE,
  include_ties = FALSE,
  n = 1L,
  m = 1L,
  ...
)

select_n_to_m(
  pairs,
  variable,
  score,
  threshold,
  preselect = NULL,
  id_x = NULL,
  id_y = NULL,
  ...
)

## S3 method for class 'pairs'
select_n_to_m(
  pairs,
  variable,
  score,
  threshold,
  preselect = NULL,
  id_x = NULL,
  id_y = NULL,
  x = attr(pairs, "x"),
  y = attr(pairs, "y"),
  inplace = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="select_greedy.cluster_pairs_+3A_pairs">pairs</code></td>
<td>
<p>a <code>pairs</code> object, such as generated by 
<code><a href="#topic+pair_blocking">pair_blocking</a></code></p>
</td></tr>
<tr><td><code id="select_greedy.cluster_pairs_+3A_variable">variable</code></td>
<td>
<p>the name of the new variable to create in pairs. This will be a
logical variable with a value of <code>TRUE</code> for the selected pairs.</p>
</td></tr>
<tr><td><code id="select_greedy.cluster_pairs_+3A_score">score</code></td>
<td>
<p>name of the score/weight variable of the pairs. When not given
and <code>attr(pairs, "score")</code> is defined, that is used.</p>
</td></tr>
<tr><td><code id="select_greedy.cluster_pairs_+3A_threshold">threshold</code></td>
<td>
<p>the threshold to apply. Pairs with a score above the 
threshold are selected.</p>
</td></tr>
<tr><td><code id="select_greedy.cluster_pairs_+3A_preselect">preselect</code></td>
<td>
<p>a logical variable with the same length as <code>pairs</code> has
rows, or the name of such a variable in <code>pairs</code>. Pairs are only 
selected when <code>preselect</code> is <code>TRUE</code>. This interacts with 
<code>threshold</code> (pairs have to be selected with both conditions).</p>
</td></tr>
<tr><td><code id="select_greedy.cluster_pairs_+3A_id_x">id_x</code></td>
<td>
<p>a integer vector with the same length as the number of rows in 
<code>pairs</code>, or the name of a column in <code>x</code>. This vector should 
identify unique objects in <code>x</code>. When not specified it is assumed that
each element in <code>x</code> is unique.</p>
</td></tr>
<tr><td><code id="select_greedy.cluster_pairs_+3A_id_y">id_y</code></td>
<td>
<p>a integer vector with the same length as the number of rows in 
<code>pairs</code>, or the name of a column in <code>y</code>. This vector should 
identify unique objects in <code>y</code>. When not specified it is assumed that
each element in <code>y</code> is unique.</p>
</td></tr>
<tr><td><code id="select_greedy.cluster_pairs_+3A_...">...</code></td>
<td>
<p>Used to pass additional arguments to methods</p>
</td></tr>
<tr><td><code id="select_greedy.cluster_pairs_+3A_x">x</code></td>
<td>
<p><code>data.table</code> with one half of the pairs.</p>
</td></tr>
<tr><td><code id="select_greedy.cluster_pairs_+3A_y">y</code></td>
<td>
<p><code>data.table</code> with the other half of the pairs.</p>
</td></tr>
<tr><td><code id="select_greedy.cluster_pairs_+3A_inplace">inplace</code></td>
<td>
<p>logical indicating whether <code>pairs</code> should be modified in place. When
pairs is large this can be more efficient.</p>
</td></tr>
<tr><td><code id="select_greedy.cluster_pairs_+3A_include_ties">include_ties</code></td>
<td>
<p>when pairs for a given record have an equal weight, should
all pairs be included.</p>
</td></tr>
<tr><td><code id="select_greedy.cluster_pairs_+3A_n">n</code></td>
<td>
<p>an integer. Each element of x can be linked to at most n elements of
y.</p>
</td></tr>
<tr><td><code id="select_greedy.cluster_pairs_+3A_m">m</code></td>
<td>
<p>an integer. Each element of y can be linked to at most m elements of
x.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Both methods force one-to-one matching. <code>select_greedy</code> uses a greedy 
algorithm that selects the first pair with the highest weight. 
<code>select_n_to_m</code> tries to optimise the total weight of all of the 
selected pairs. In general this will result in a better selection. However,
<code>select_n_to_m</code> uses much more memory and is much slower and, therefore,
can only be used when the number of possible pairs is not too large. 
</p>
<p>Note that when <code>include_ties = TRUE</code> the same record can still be 
selected more than once. In that case the pairs will have an equal weight.
</p>


<h3>Value</h3>

<p>Returns the <code>pairs</code> with the variable given by <code>variable</code> added. This
is a logical variable indicating which pairs are selected as matches.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("linkexample1", "linkexample2")
pairs &lt;- pair_blocking(linkexample1, linkexample2, "postcode")
pairs &lt;- compare_pairs(pairs, c("lastname", "firstname", "address", "sex"))
model &lt;- problink_em(~ lastname + firstname + address + sex, data = pairs)
pairs &lt;- predict(model, pairs, type = "mpost", add = TRUE, binary = TRUE)

# Select pairs with a mpost &gt; 0.5 and force one-to-one linkage
pairs &lt;- select_n_to_m(pairs, "ntom", "mpost", 0.5)
pairs &lt;- select_greedy(pairs, "greedy", "mpost", 0.5)
table(pairs$ntom, pairs$greedy)

# The same example as above using a cluster;
library(parallel)
cl &lt;- makeCluster(2)

pairs &lt;- cluster_pair_blocking(cl, linkexample1, linkexample2, "postcode")
compare_pairs(pairs, c("lastname", "firstname", "address", "sex"))
model &lt;- problink_em(~ lastname + firstname + address + sex, data = pairs)
predict(model, pairs, type = "mpost", add = TRUE, binary = TRUE)
# Select pairs with a mpost &gt; 0.5 and force one-to-one linkage
# select_n_to_m and select_greedy only work on pairs that are local; 
# therefore we first collect the pairs
select_threshold(pairs, "selected", "mpost", 0.5)
local_pairs &lt;- cluster_collect(pairs, "selected")
local_pairs &lt;- select_n_to_m(local_pairs, "ntom", "mpost", 0.5)
local_pairs &lt;- select_greedy(local_pairs, "greedy", "mpost", 0.5)
table(local_pairs$ntom, local_pairs$greedy)

stopCluster(cl)

</code></pre>

<hr>
<h2 id='select_threshold.cluster_pairs'>Select matching pairs with a score above or equal to a threshold</h2><span id='topic+select_threshold.cluster_pairs'></span><span id='topic+select_threshold'></span><span id='topic+select_threshold.pairs'></span>

<h3>Description</h3>

<p>Select matching pairs with a score above or equal to a threshold
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'cluster_pairs'
select_threshold(pairs, variable, score, threshold, new_name = NULL, ...)

select_threshold(pairs, variable, score, threshold, ...)

## S3 method for class 'pairs'
select_threshold(pairs, variable, score, threshold, inplace = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="select_threshold.cluster_pairs_+3A_pairs">pairs</code></td>
<td>
<p>a <code>pairs</code> object, such as generated by 
<code><a href="#topic+pair_blocking">pair_blocking</a></code></p>
</td></tr>
<tr><td><code id="select_threshold.cluster_pairs_+3A_variable">variable</code></td>
<td>
<p>the name of the new variable to create in pairs. This will be a
logical variable with a value of <code>TRUE</code> for the selected pairs.</p>
</td></tr>
<tr><td><code id="select_threshold.cluster_pairs_+3A_score">score</code></td>
<td>
<p>name of the score/weight variable of the pairs. When not given
and <code>attr(pairs, "score")</code> is defined, that is used.</p>
</td></tr>
<tr><td><code id="select_threshold.cluster_pairs_+3A_threshold">threshold</code></td>
<td>
<p>the threshold to apply. Pairs with a score above or equal to the 
threshold are selected.</p>
</td></tr>
<tr><td><code id="select_threshold.cluster_pairs_+3A_new_name">new_name</code></td>
<td>
<p>name of new object to assign the pairs to on the cluster
nodes.</p>
</td></tr>
<tr><td><code id="select_threshold.cluster_pairs_+3A_...">...</code></td>
<td>
<p>ignored</p>
</td></tr>
<tr><td><code id="select_threshold.cluster_pairs_+3A_inplace">inplace</code></td>
<td>
<p>logical indicating whether <code>pairs</code> should be modified in place. When
pairs is large this can be more efficient.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns the <code>pairs</code> with the variable given by <code>variable</code> added. This
is a logical variable indicating which pairs are selected a matches.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("linkexample1", "linkexample2")
pairs &lt;- pair_blocking(linkexample1, linkexample2, "postcode")
pairs &lt;- compare_pairs(pairs, c("lastname", "firstname", "address", "sex"))
model &lt;- problink_em(~ lastname + firstname + address + sex, data = pairs)
pairs &lt;- predict(model, pairs, type = "mpost", add = TRUE, binary = TRUE)
# Select pairs with a mpost &gt; 0.5
select_threshold(pairs, "selected", "mpost", 0.5, inplace = TRUE)

# Example using cluster;
# In general the syntax is exactly the same except for the first call to 
# to cluster_pair. Note the in general `inplace = TRUE` is implied when
# working with a cluster; therefore the assignment back to pairs can be 
# omitted (also not a problem if it is not).
library(parallel)
data("linkexample1", "linkexample2")
cl &lt;- makeCluster(2)

pairs &lt;- cluster_pair(cl, linkexample1, linkexample2)
compare_pairs(pairs, c("lastname", "firstname", "address", "sex"))
model &lt;- problink_em(~ lastname + firstname + address + sex, data = pairs)
predict(model, pairs, type = "mpost", add = TRUE, binary = TRUE)
# Select pairs with a mpost &gt; 0.5
# Unlike the regular pairs: inplace = TRUE is implied here
select_threshold(pairs, "selected", "mpost", 0.5)
stopCluster(cl)

</code></pre>

<hr>
<h2 id='select_unique.cluster_pairs'>Deselect pairs that are linked to multiple records</h2><span id='topic+select_unique.cluster_pairs'></span><span id='topic+select_unique'></span><span id='topic+select_unique.pairs'></span>

<h3>Description</h3>

<p>Deselect pairs that are linked to multiple records
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'cluster_pairs'
select_unique(
  pairs,
  variable,
  preselect = NULL,
  n = 1,
  m = 1,
  id_x = NULL,
  id_y = NULL,
  ...
)

select_unique(
  pairs,
  variable,
  preselect = NULL,
  n = 1,
  m = 1,
  id_x = NULL,
  id_y = NULL,
  ...
)

## S3 method for class 'pairs'
select_unique(
  pairs,
  variable,
  preselect = NULL,
  n = 1,
  m = 1,
  id_x = NULL,
  id_y = NULL,
  x = attr(pairs, "x"),
  y = attr(pairs, "y"),
  inplace = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="select_unique.cluster_pairs_+3A_pairs">pairs</code></td>
<td>
<p>a <code>pairs</code> object, such as generated by 
<code><a href="#topic+pair_blocking">pair_blocking</a></code></p>
</td></tr>
<tr><td><code id="select_unique.cluster_pairs_+3A_variable">variable</code></td>
<td>
<p>the name of the new variable to create in pairs. This will be a
logical variable with a value of <code>TRUE</code> for the selected pairs.</p>
</td></tr>
<tr><td><code id="select_unique.cluster_pairs_+3A_preselect">preselect</code></td>
<td>
<p>a logical variable with the same length as <code>pairs</code> has
rows, or the name of such a variable in <code>pairs</code>. Pairs are only 
selected when <code>preselect</code> is <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="select_unique.cluster_pairs_+3A_n">n</code></td>
<td>
<p>do not select pairs with a y-record that is linked to more than
<code>n</code> records.</p>
</td></tr>
<tr><td><code id="select_unique.cluster_pairs_+3A_m">m</code></td>
<td>
<p>do not select pairs with a m-record that is linked to more than
<code>m</code> records.</p>
</td></tr>
<tr><td><code id="select_unique.cluster_pairs_+3A_id_x">id_x</code></td>
<td>
<p>a integer vector with the same length as the number of rows in 
<code>pairs</code>, or the name of a column in <code>x</code>. This vector should 
identify unique objects in <code>x</code>. When not specified it is assumed that
each element in <code>x</code> is unique.</p>
</td></tr>
<tr><td><code id="select_unique.cluster_pairs_+3A_id_y">id_y</code></td>
<td>
<p>a integer vector with the same length as the number of rows in 
<code>pairs</code>, or the name of a column in <code>y</code>. This vector should 
identify unique objects in <code>y</code>. When not specified it is assumed that
each element in <code>y</code> is unique.</p>
</td></tr>
<tr><td><code id="select_unique.cluster_pairs_+3A_...">...</code></td>
<td>
<p>Used to pass additional arguments to methods</p>
</td></tr>
<tr><td><code id="select_unique.cluster_pairs_+3A_x">x</code></td>
<td>
<p><code>data.table</code> with one half of the pairs.</p>
</td></tr>
<tr><td><code id="select_unique.cluster_pairs_+3A_y">y</code></td>
<td>
<p><code>data.table</code> with the other half of the pairs.</p>
</td></tr>
<tr><td><code id="select_unique.cluster_pairs_+3A_inplace">inplace</code></td>
<td>
<p>logical indicating whether <code>pairs</code> should be modified in place. When
pairs is large this can be more efficient.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function can be used to remove pairs for which there is ambiguity. For
example when a record from <code>x</code> is linked to multiple records from
<code>y</code> and we know that there are no duplicate records in <code>y</code> (records
that belong to the same object), then we know that at least on of the two
links is incorrect but we cannot decide which of the two. In that case we may
want to decide that we will not link both records. Running
<code>select_unique</code> with <code>m == 1</code> will remove both records.
</p>
<p>In case one wants to select one of the records randomly: <code>select_greedy</code>
will select the pair with the highest weight and in case of an equal weight
the first. Adding a random component to the weights will ensure a random
selection.
</p>


<h3>Value</h3>

<p>Returns the <code>pairs</code> with the variable given by <code>variable</code> added. This
is a logical variable indicating which pairs are selected as matches.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("linkexample1", "linkexample2")
pairs &lt;- pair_blocking(linkexample1, linkexample2, "postcode")
compare_pairs(pairs, on = c("lastname", "firstname", "address", "sex"),
  default_comparator = jaro_winkler(0.9), inplace = TRUE)
score_simple(pairs, "score", 
  on = c("lastname", "firstname", "address", "sex"),
  w1 = list(lastname = 2), inplace = TRUE)
select_threshold(pairs, variable = "select", 
  score = "score", threshold = 4.0, inplace =  TRUE)
select_unique(pairs, variable = "select_unique", preselect = "select")

</code></pre>

<hr>
<h2 id='summary.problink_em'>Summarise the results from <code><a href="#topic+problink_em">problink_em</a></code></h2><span id='topic+summary.problink_em'></span>

<h3>Description</h3>

<p>Summarise the results from <code><a href="#topic+problink_em">problink_em</a></code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'problink_em'
summary(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary.problink_em_+3A_object">object</code></td>
<td>
<p>the <code><a href="#topic+problink_em">problink_em</a></code> object.</p>
</td></tr>
<tr><td><code id="summary.problink_em_+3A_...">...</code></td>
<td>
<p>ignored;</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns the original <code>object</code> with a <code>data.frame</code> with the patterns
and corresponding m-, u-probabilities and weights added.
</p>

<hr>
<h2 id='tabulate_patterns.cluster_pairs'>Create a table of comparison patterns</h2><span id='topic+tabulate_patterns.cluster_pairs'></span><span id='topic+tabulate_patterns'></span><span id='topic+tabulate_patterns.pairs'></span>

<h3>Description</h3>

<p>Create a table of comparison patterns
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'cluster_pairs'
tabulate_patterns(pairs, on, comparators, complete = TRUE, ...)

tabulate_patterns(pairs, on, comparators, complete = TRUE, ...)

## S3 method for class 'pairs'
tabulate_patterns(pairs, on, comparators, complete = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tabulate_patterns.cluster_pairs_+3A_pairs">pairs</code></td>
<td>
<p>a <code>pairs</code> object, such as generated by 
<code><a href="#topic+pair_blocking">pair_blocking</a></code></p>
</td></tr>
<tr><td><code id="tabulate_patterns.cluster_pairs_+3A_on">on</code></td>
<td>
<p>variables from <code>pairs</code> defining the comparison patterns. When
missing <code>names(comparators)</code> is used.</p>
</td></tr>
<tr><td><code id="tabulate_patterns.cluster_pairs_+3A_comparators">comparators</code></td>
<td>
<p>a list with comparison functions for each of the 
columns. When missing or <code>NULL</code>, the function looks for columns in 
<code>pairs</code> with a <code>comparator</code> attribute.</p>
</td></tr>
<tr><td><code id="tabulate_patterns.cluster_pairs_+3A_complete">complete</code></td>
<td>
<p>add patterns that do not occur in the dataset to the result 
(with <code>n = 0</code>).</p>
</td></tr>
<tr><td><code id="tabulate_patterns.cluster_pairs_+3A_...">...</code></td>
<td>
<p>passed on to other methods.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Since comparison vectors can contain continuous numbers (usually between 0
and 1), this could result in a very large number of possible comparison 
vectors. Therefore, the comparison vectors are passed on to the comparators
in order to threshold them. This usually results in values 0 or 1. Missing
values are usually codes as 0. However, this all depends on the comparison
functions used. For more information see the documentation on the 
<a href="#topic+cmp_identical">comparison functions</a>.
</p>


<h3>Value</h3>

<p>Returns a <code>data.frame</code> with all unique comparison patterns that exist
in <code>pairs</code>, with a column <code>n</code> added with the number of times each
pattern occurs.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("linkexample1", "linkexample2")
pairs &lt;- pair_blocking(linkexample1, linkexample2, "postcode")
pairs &lt;- compare_pairs(pairs, c("lastname", "firstname", "address", "sex"))
tabulate_patterns(pairs)

</code></pre>

<hr>
<h2 id='town_names'>Spelling variations of a set of town names</h2><span id='topic+town_names'></span>

<h3>Description</h3>

<p>Contains spelling variations found in various files of a set of town/village
names. Names were selected that contain 'rdam' or 'rdm'. The correct/official
names are also given. This data set can be used as an example data set for 
deduplication
</p>


<h3>Format</h3>

<p>Data frames with 584 records and two columns.
</p>


<h3>Details</h3>


<ul>
<li><p> name the name of the town/village as found in the files
</p>
</li>
<li><p> official_name the official/correct name
</p>
</li></ul>


</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
