<!DOCTYPE html><html><head><title>Help for package regexPipes</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {regexPipes}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#grep'><p>Overriding grep from base package</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Wrappers Around 'base::grep()' for Use with Pipes</td>
</tr>
<tr>
<td>Version:</td>
<td>0.0.1</td>
</tr>
<tr>
<td>Author:</td>
<td>Billy Buchanan</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Billy Buchanan &lt;Billy.Buchanan@fayette.kyschools.us&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Provides wrappers around base::grep() where the first argument
    is standardized to take the data object. This makes it less of a pain to use
    regular expressions with 'magrittr' or other pipe operators.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>LazyData:</td>
<td>TRUE</td>
</tr>
<tr>
<td>Suggests:</td>
<td>magrittr, pipeR</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>5.0.1</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2016-09-14 19:03:56 UTC; billy</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2016-09-14 21:50:50</td>
</tr>
</table>
<hr>
<h2 id='grep'>Overriding grep from base package</h2><span id='topic+gregexpr'></span><span id='topic+grep'></span><span id='topic+grepl'></span><span id='topic+gsub'></span><span id='topic+regexec'></span><span id='topic+regexpr'></span><span id='topic+sub'></span>

<h3>Description</h3>

<p>Overrides the grep function to be amenable to using pipe
operators.  The documentation below comes from the help file for base::grep
</p>
<p>grep, grepl, regexpr, gregexpr and regexec search for matches to
argument pattern within each element of a character vector: they differ in
the format of and amount of detail in the results.
</p>
<p>sub and gsub perform replacement of the first and all matches respectively.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>grep(x, pattern, ignore.case = FALSE, perl = FALSE, value = FALSE,
  fixed = FALSE, useBytes = FALSE, invert = FALSE)

grepl(x, pattern, ignore.case = FALSE, perl = FALSE, fixed = FALSE,
  useBytes = FALSE)

sub(x, pattern, replacement, ignore.case = FALSE, perl = FALSE,
  fixed = FALSE, useBytes = FALSE)

gsub(x, pattern, replacement, ignore.case = FALSE, perl = FALSE,
  fixed = FALSE, useBytes = FALSE)

regexpr(text, pattern, ignore.case = FALSE, perl = FALSE, fixed = FALSE,
  useBytes = FALSE)

gregexpr(text, pattern, ignore.case = FALSE, perl = FALSE, fixed = FALSE,
  useBytes = FALSE)

regexec(text, pattern, ignore.case = FALSE, fixed = FALSE,
  useBytes = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="grep_+3A_x">x</code></td>
<td>
<p>a character vector where matches are sought, or an object
which can be coerced by as.character to a character vector. Long vectors are
supported.</p>
</td></tr>
<tr><td><code id="grep_+3A_pattern">pattern</code></td>
<td>
<p>character string containing a regular expression (or
character string for fixed = TRUE) to be matched in the given character
vector. Coerced by as.character to a character string if possible. If a
character vector of length 2 or more is supplied, the first element is used
with a warning. Missing values are allowed except for regexpr and gregexpr.</p>
</td></tr>
<tr><td><code id="grep_+3A_ignore.case">ignore.case</code></td>
<td>
<p>if FALSE, the pattern matching is case sensitive and if
TRUE, case is ignored during matching.</p>
</td></tr>
<tr><td><code id="grep_+3A_perl">perl</code></td>
<td>
<p>logical. Should Perl-compatible regexps be used?</p>
</td></tr>
<tr><td><code id="grep_+3A_value">value</code></td>
<td>
<p>if FALSE, a vector containing the (integer) indices of the
matches determined by grep is returned, and if TRUE, a vector containing the
matching elements themselves is returned.</p>
</td></tr>
<tr><td><code id="grep_+3A_fixed">fixed</code></td>
<td>
<p>logical. If TRUE, pattern is a string to be matched as is.
Overrides all conflicting arguments.</p>
</td></tr>
<tr><td><code id="grep_+3A_usebytes">useBytes</code></td>
<td>
<p>logical. If TRUE the matching is done byte-by-byte rather
than character-by-character</p>
</td></tr>
<tr><td><code id="grep_+3A_invert">invert</code></td>
<td>
<p>logical. If TRUE return indices or values for elements that do
not match.</p>
</td></tr>
<tr><td><code id="grep_+3A_replacement">replacement</code></td>
<td>
<p>a replacement for matched pattern in sub and gsub. Coerced
to character if possible. For fixed = FALSE this can include backreferences
&quot;\1&quot; to &quot;\9&quot; to parenthesized subexpressions of pattern. For perl = TRUE
only, it can also contain &quot;\U&quot; or &quot;\L&quot; to convert the rest of the replacement
to upper or lower case and &quot;\E&quot; to end case conversion. If a character vector
of length 2 or more is supplied, the first element is used with a warning.
If NA, all elements in the result corresponding to matches will be set to NA.</p>
</td></tr>
<tr><td><code id="grep_+3A_text">text</code></td>
<td>
<p>a character vector where matches are sought, or an object
which can be coerced by as.character to a character vector. Long vectors are
supported.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Arguments which should be character strings or character vectors are coerced to character if possible.
</p>
<p>Each of these functions (apart from regexec, which currently does not support Perl-style regular expressions) operates in one of three modes:
</p>
<p>1. fixed = TRUE: use exact matching.
</p>
<p>2. perl = TRUE: use Perl-style regular expressions.
</p>
<p>3. fixed = FALSE, perl = FALSE: use POSIX 1003.2 extended regular expressions.
</p>
<p>See the help pages on regular expression for details of the different types of regular expressions.
</p>
<p>The two *sub functions differ only in that sub replaces only the first occurrence of a pattern whereas gsub replaces all occurrences. If replacement contains backreferences which are not defined in pattern the result is undefined (but most often the backreference is taken to be &quot;&quot;).
</p>
<p>For regexpr, gregexpr and regexec it is an error for pattern to be NA, otherwise NA is permitted and gives an NA match.
</p>
<p>The main effect of useBytes is to avoid errors/warnings about invalid inputs and spurious matches in multibyte locales, but for regexpr it changes the interpretation of the output. It inhibits the conversion of inputs with marked encodings, and is forced if any input is found which is marked as &quot;bytes&quot; see Encoding).
</p>
<p>Caseless matching does not make much sense for bytes in a multibyte locale, and you should expect it only to work for ASCII characters if useBytes = TRUE.
</p>
<p>regexpr and gregexpr with perl = TRUE allow Python-style named captures, but not for long vector inputs.
</p>
<p>Invalid inputs in the current locale are warned about up to 5 times.
</p>
<p>Caseless matching with PERL = TRUE for non-ASCII characters depends on the PCRE library being compiled with 'Unicode property support': an external library might not be.
</p>


<h3>Value</h3>

<p>grep(value = FALSE) returns a vector of the indices of the elements of x that yielded a match (or not, for invert = TRUE. This will be an
integer vector unless the input is a long vector, when it will be a double vector.
</p>
<p>grep(value = TRUE) returns a character vector containing the selected elements of x (after coercion, preserving names but no other attributes).
</p>
<p>grepl returns a logical vector (match or not for each element of x).
</p>
<p>For sub and gsub return a character vector of the same length and with the same attributes as x (after possible coercion to character).
Elements of character vectors x which are not substituted will be returned unchanged (including any declared encoding). If useBytes =
FALSE a non-ASCII substituted result will often be in UTF-8 with a marked encoding (e.g., if there is a UTF-8 input, and in a multibyte
locale unless fixed = TRUE). Such strings can be re-encoded by enc2native.
</p>
<p>regexpr returns an integer vector of the same length as text giving the starting position of the first match or -1 if there is none, with
attribute &quot;match.length&quot;, an integer vector giving the length of the matched text (or -1 for no match). The match positions and lengths are
in characters unless useBytes = TRUE is used, when they are in bytes. If named capture is used there are further attributes &quot;capture.start&quot;,
&quot;capture.length&quot; and &quot;capture.names&quot;.
</p>
<p>gregexpr returns a list of the same length as text each element of which is of the same form as the return value for regexpr, except that the starting positions of every (disjoint) match are given.
</p>
<p>regexec returns a list of the same length as text each element of which is either -1 if there is no match, or a sequence of integers with the starting positions of the match and all substrings corresponding to parenthesized subexpressions of pattern, with attribute &quot;match.length&quot; a vector giving the lengths of the matches (or -1 for no match).
</p>


<h3>Warning</h3>

<p>POSIX 1003.2 mode of gsub and gregexpr does not work correctly with repeated word-boundaries (e.g., pattern = &quot;\b&quot;). Use perl = TRUE for such matches (but that may not work as expected with non-ASCII inputs, as the meaning of 'word' is system-dependent).
</p>


<h3>Performance considerations</h3>

<p>If you are doing a lot of regular expression matching, including on very long strings, you will want to consider the options used. Generally PCRE will be faster than the default regular expression engine, and fixed = TRUE faster still (especially when each pattern is matched only a few times).
</p>
<p>If you are working in a single-byte locale and have marked UTF-8 strings that are representable in that locale, convert them first as just one UTF-8 string will force all the matching to be done in Unicode, which attracts a penalty of around 3x for the default POSIX 1003.2 mode.
</p>
<p>If you can make use of useBytes = TRUE, the strings will not be checked before matching, and the actual matching will be faster. Often byte-based matching suffices in a UTF-8 locale since byte patterns of one character never match part of another.
</p>


<h3>Source</h3>

<p>The C code for POSIX-style regular expression matching has changed over the years. As from R 2.10.0 the TRE library of Ville Laurikari (http://laurikari.net/tre/) is used. The POSIX standard does give some room for interpretation, especially in the handling of invalid regular expressions and the collation of character ranges, so the results will have changed slightly over the years.
</p>
<p>For Perl-style matching PCRE (http://www.pcre.org) is used.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(magrittr)
letters %&gt;% regexPipes::grep("[a-z]")

txt &lt;- c("arm","foot","lefroo", "bafoobar")
if(length(i &lt;- txt %&gt;% regexPipes::grep("foo")))
   cat("'foo' appears at least once in\n\t", txt, "\n")
i # 2 and 4
txt[i]

## Double all 'a' or 'b's;  "\" must be escaped, i.e., 'doubled'
gstext &lt;- "abc and ABC"
gstext %&gt;% regexPipes::gsub("([ab])", "\\1_\\1_")

txt &lt;- c("The", "licenses", "for", "most", "software", "are",
  "designed", "to", "take", "away", "your", "freedom",
  "to", "share", "and", "change", "it.",
   "", "By", "contrast,", "the", "GNU", "General", "Public", "License",
   "is", "intended", "to", "guarantee", "your", "freedom", "to",
   "share", "and", "change", "free", "software", "--",
   "to", "make", "sure", "the", "software", "is",
   "free", "for", "all", "its", "users")
( i &lt;- txt %&gt;% regexPipes::grep("[gu]") ) # indices
stopifnot( txt[i] == txt %&gt;% regexPipes::grep("[gu]", value = TRUE) )

## Note that in locales such as en_US this includes B as the
## collation order is aAbBcCdEe ...
(ot &lt;- txt %&gt;% regexPipes::sub("[b-e]", "."))
txt[ot != txt %&gt;% regexPipes::gsub("[b-e]", ".")]#- gsub does "global" substitution

txt[txt %&gt;% regexPipes::gsub("g", "#") !=
    txt %&gt;% regexPipes::gsub("g", "#", ignore.case = TRUE)] # the "G" words

txt %&gt;% regexPipes::regexpr("en")

txt %&gt;% regexPipes::gregexpr("e")

## Using grepl() for filtering
## Find functions with argument names matching "warn":
findArgs &lt;- function(env, pattern) {
  nms &lt;- ls(envir = as.environment(env))
  nms &lt;- nms[is.na(match(nms, c("F","T")))] # &lt;-- work around "checking hack"
  aa &lt;- sapply(nms, function(.) { o &lt;- get(.)
               if(is.function(o)) names(formals(o)) })
  iw &lt;- sapply(aa, function(a) any(a %&gt;% regexPipes::grepl(pattern, ignore.case=TRUE)))
  aa[iw]
}
findArgs("package:base", "warn")

## trim trailing white space
str &lt;- "Now is the time      "
str %&gt;% regexPipes::sub(" +$", "")  ## spaces only
## what is considered 'white space' depends on the locale.
str %&gt;% regexPipes::sub("[[:space:]]+$", "") ## white space, POSIX-style
## what PCRE considered white space changed in version 8.34: see ?regex
str %&gt;% regexPipes::sub("\\s+$", "", perl = TRUE) ## PCRE-style white space

## capitalizing
txt &lt;- "a test of capitalizing"
txt %&gt;% regexPipes::gsub("(\\w)(\\w*)", "\\U\\1\\L\\2",  perl=TRUE)
txt %&gt;% regexPipes::gsub("\\b(\\w)", "\\U\\1",  perl=TRUE)

txt2 &lt;- "useRs may fly into JFK or laGuardia"
txt2 %&gt;% regexPipes::gsub("(\\w)(\\w*)(\\w)", "\\U\\1\\E\\2\\U\\3", perl=TRUE)
txt2 %&gt;%  regexPipes::sub("(\\w)(\\w*)(\\w)", "\\U\\1\\E\\2\\U\\3", perl=TRUE)

## named capture
notables &lt;- c("  Ben Franklin and Jefferson Davis",
              "\tMillard Fillmore")
# name groups 'first' and 'last'
name.rex &lt;- "(?&lt;first&gt;[[:upper:]][[:lower:]]+) (?&lt;last&gt;[[:upper:]][[:lower:]]+)"
(parsed &lt;- notables %&gt;% regexPipes::regexpr(name.rex, perl = TRUE))

# Example below fails, but unclear what the cause is
# notables %&gt;% regexPipes::gregexpr(name.rex, perl = TRUE)[[2]]
# Same example with the object passed w/o magrittr does work
regexPipes::gregexpr(notables, name.rex, perl = TRUE)[[2]]
parse.one &lt;- function(res, result) {
  m &lt;- do.call(rbind, lapply(seq_along(res), function(i) {
    if(result[i] == -1) return("")
    st &lt;- attr(result, "capture.start")[i, ]
    substring(res[i], st, st + attr(result, "capture.length")[i, ] - 1)
  }))
  colnames(m) &lt;- attr(result, "capture.names")
  m
}
parse.one(notables, parsed)

## Decompose a URL into its components.
## Example by LT (http://www.cs.uiowa.edu/~luke/R/regexp.html).
x &lt;- "http://stat.umn.edu:80/xyz"
m &lt;- x %&gt;% regexPipes::regexec("^(([^:]+)://)?([^:/]+)(:([0-9]+))?(/.*)")
m
regmatches(x, m)
## Element 3 is the protocol, 4 is the host, 6 is the port, and 7
## is the path.  We can use this to make a function for extracting the
## parts of a URL:
URL_parts &lt;- function(x) {
    m &lt;- x %&gt;% regexPipes::regexec("^(([^:]+)://)?([^:/]+)(:([0-9]+))?(/.*)")
    parts &lt;- do.call(rbind,
                     lapply(regmatches(x, m), `[`, c(3L, 4L, 6L, 7L)))
    colnames(parts) &lt;- c("protocol","host","port","path")
    parts
}
URL_parts(x)

## There is no gregexec() yet, but one can emulate it by running
## regexec() on the regmatches obtained via gregexpr().  E.g.:
pattern &lt;- "([[:alpha:]]+)([[:digit:]]+)"
s &lt;- "Test: A1 BC23 DEF456"
lapply(regmatches(s, s %&gt;% regexPipes::gregexpr(pattern)),
       function(e) regmatches(e, e %&gt;% regexPipes::regexec(pattern)))

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
