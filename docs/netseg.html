<!DOCTYPE html><html><head><title>Help for package netseg</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {netseg}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#netseg-package'><p>netseg: Measures of Network Segregation and Homophily</p></a></li>
<li><a href='#assort'><p>Assortativity Coefficient</p></a></li>
<li><a href='#Catania'><p>Pattern of sexual contacts in AMEN study</p></a></li>
<li><a href='#Classroom'><p>Classroom network</p></a></li>
<li><a href='#coleman'><p>Coleman's homophily index</p></a></li>
<li><a href='#EF3'><p>Example data from Figure III of Echenique and Fryer (2006)</p></a></li>
<li><a href='#ei'><p>Krackhard and Stern's E-I index</p></a></li>
<li><a href='#fold'><p>Folding square matrices around the diagonal</p></a></li>
<li><a href='#freeman'><p>Generalized Freeman's segregation index</p></a></li>
<li><a href='#gamix'><p>Gupta-Anderson-May measure of within-group mixing</p></a></li>
<li><a href='#group_sizes'><p>Computing group sizes from square mixing matrices</p></a></li>
<li><a href='#mixingm'><p>Network mixing matrix</p></a></li>
<li><a href='#orwg'><p>Odds ratio of existence of within-group ties</p></a></li>
<li><a href='#smi'><p>Segregation Matrix Index</p></a></li>
<li><a href='#ssi'><p>Spectral Segregation Index for Social Networks</p></a></li>
<li><a href='#symmetrize'><p>(De)symmetrize square numeric matrix</p></a></li>
<li><a href='#WhiteKinship'><p>White's data on Effective Kinship Networks</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Title:</td>
<td>Measures of Network Segregation and Homophily</td>
</tr>
<tr>
<td>Version:</td>
<td>1.0-2</td>
</tr>
<tr>
<td>Description:</td>
<td>Segregation is a network-level property such that edges between 
  predefined groups of vertices are relatively less likely. Network homophily 
  is a individual-level tendency to form relations with people who are similar 
  on some attribute (e.g. gender, music taste, social status, etc.). In general
  homophily leads to segregation, but segregation might arise without 
  homophily. This package implements descriptive indices measuring 
  homophily/segregation. It is a computational companion 
  to Bojanowski &amp; Corten (2014) &lt;<a href="https://doi.org/10.1016%2Fj.socnet.2014.04.001">doi:10.1016/j.socnet.2014.04.001</a>&gt;.</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 2.10)</td>
</tr>
<tr>
<td>Imports:</td>
<td>igraph (&ge; 0.6-0)</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://mbojan.github.io/netseg/">https://mbojan.github.io/netseg/</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/mbojan/netseg/issues">https://github.com/mbojan/netseg/issues</a></td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.1</td>
</tr>
<tr>
<td>Suggests:</td>
<td>testthat (&ge; 2.1.0), knitr, rmarkdown, scales</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-06-30 22:12:59 UTC; mbojan</td>
</tr>
<tr>
<td>Author:</td>
<td>Michal Bojanowski <a href="https://orcid.org/0000-0001-7503-852X"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cre]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Michal Bojanowski &lt;michal2992@gmail.com&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-07-01 07:40:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='netseg-package'>netseg: Measures of Network Segregation and Homophily</h2><span id='topic+netseg-package'></span><span id='topic+_PACKAGE'></span><span id='topic+netseg'></span>

<h3>Description</h3>

<p><img src="../help/figures/logo.png" style='float: right' alt='logo' width='120' />
</p>
<p>Segregation is a network-level property such that edges between predefined groups of vertices are relatively less likely. Network homophily is a individual-level tendency to form relations with people who are similar on some attribute (e.g. gender, music taste, social status, etc.). In general homophily leads to segregation, but segregation might arise without homophily. This package implements descriptive indices measuring homophily/segregation. It is a computational companion to Bojanowski &amp; Corten (2014) <a href="https://doi.org/10.1016/j.socnet.2014.04.001">doi:10.1016/j.socnet.2014.04.001</a>.
</p>


<h3>Author(s)</h3>

<p><strong>Maintainer</strong>: Michal Bojanowski <a href="mailto:michal2992@gmail.com">michal2992@gmail.com</a> (<a href="https://orcid.org/0000-0001-7503-852X">ORCID</a>)
</p>


<h3>References</h3>

<p>Bojanowski, Michał, and Rense Corten. 2014. &quot;Measuring Segregation in Social
Networks.&quot; <em>Social Networks</em> 39: 14–32.
<a href="https://doi.org/10.1016/j.socnet.2014.04.001">doi:10.1016/j.socnet.2014.04.001</a>.
</p>


<h3>See Also</h3>

<p>Useful links:
</p>

<ul>
<li><p> Package homepage: https://mbojan.github.io/netseg
</p>
</li>
<li><p> Bug reports: https://github.com/mbojan/netseg/issues
</p>
</li></ul>


<hr>
<h2 id='assort'>Assortativity Coefficient</h2><span id='topic+assort'></span><span id='topic+assort.table'></span><span id='topic+assort.igraph'></span><span id='topic+assort.default'></span>

<h3>Description</h3>

<p>Assortativity coefficient is a measure of segregation for social networks
due to Newman &amp; Girvan (2002).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>assort(object, ...)

## S3 method for class 'table'
assort(object, ...)

## S3 method for class 'igraph'
assort(object, vattr, ...)

## Default S3 method:
assort(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="assort_+3A_object">object</code></td>
<td>
<p>R object, see available methods</p>
</td></tr>
<tr><td><code id="assort_+3A_...">...</code></td>
<td>
<p>other arguments to/from other methods</p>
</td></tr>
<tr><td><code id="assort_+3A_vattr">vattr</code></td>
<td>
<p>character, name of the vertex attribute for which the measure is
to be calculated</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The measure evaluates the relative prevalence of within-group ties. It is
based on the contact layer of the mixing matrix.
</p>
<p>Assortativity coefficient is 1 if all ties are within-group.
The minimum can be negative, but not less than -1, and depends on the
relative number of ties of nodes in different groups. If the network
conforms to &quot;proportionate mixing&quot;, the coefficient is 0.
</p>
<p>If <code>object</code> is a table it is interpreted as a mixing matrix.
Two-dimensional table is interpreted as a contact layer. Three-dimensional
table is interpreted as a full mixing matrix <code class="reqn">m_{ghy}</code>
cross-classyfying all dyads, in which <code class="reqn">g</code> and <code class="reqn">h</code> correspond to
group membership of ego and alter respectively. Layers <code class="reqn">y=1</code> and
<code class="reqn">y=2</code> are assumed to be non-contact and contact layers respectively.
</p>
<p>If <code>object</code> is of class &quot;igraph&quot; it is required to supply <code>vattr</code>
with the name of the vertex attribute to calculate intermediate mixing
matrix.
</p>
<p>For any other classes, <code>object</code> is coerced to a table and the table
method is called.
</p>


<h3>Value</h3>

<p>Numeric value of the index.
</p>


<h3>References</h3>

<p>Newman, M. J. and Girvan, M. (2002) &quot;Mixing patterns and
community structure in networks&quot;, arXiv:cond-mat/0210146v1
</p>
<p>Newman, M. J. (2003) &quot;Mixing patterns in networks&quot; arXiv:cond-mat/0209450v2
</p>


<h3>See Also</h3>

<p>Mixing matrices: <code><a href="#topic+mixingm">mixingm()</a></code>
</p>
<p>Other segregation measures: 
<code><a href="#topic+coleman">coleman</a>()</code>,
<code><a href="#topic+ei">ei</a>()</code>,
<code><a href="#topic+freeman">freeman</a>()</code>,
<code><a href="#topic+gamix">gamix</a>()</code>,
<code><a href="#topic+orwg">orwg</a>()</code>,
<code><a href="#topic+smi">smi</a>()</code>,
<code><a href="#topic+ssi">ssi</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>assort(WhiteKinship, "gender")
assort(EF3, "type")

# Values of `assort()` for full networks of different sizes
if( requireNamespace("igraph", quietly = TRUE) ) {
  f &lt;- function(n) {
    gfull &lt;- igraph::make_full_graph(n, directed=FALSE)
    igraph::V(gfull)$type &lt;- rep(1:2, length = igraph::vcount(gfull))
    assort(gfull, "type")
  }
  set.seed(1)
  x &lt;- sort(sample(5:100, 25) * 2)
  y &lt;- sapply(x, f)
  plot(x, y, type="o",
       xlab="Network size", ylab="Assortativity coefficient",
       main="Assortativity coef. for full networks of different sizes")
}
</code></pre>

<hr>
<h2 id='Catania'>Pattern of sexual contacts in AMEN study</h2><span id='topic+Catania'></span>

<h3>Description</h3>

<p>Contact layer of the mixing matrix of men and women in US based on &quot;Aids in
Multi-Ethnic  Neighborhoods&quot; (AMEN). Based on Newman (2003).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Catania
</code></pre>


<h3>Format</h3>

<p>Four-by-four numeric matrix with dimnames.
</p>
<div class="sourceCode"><pre>#&gt;           female
#&gt; male       black hispanic other white
#&gt;   black      506       32    26    69
#&gt;   hispanic    23      308    38   114
#&gt;   other       10       14    32    47
#&gt;   white       26       46    68   599
</pre></div>


<h3>Source</h3>

<p>Newman, M. (2003) &quot;Mixing patterns in networks&quot; Arxiv:cond-mat/0209450 v2
</p>


<h3>References</h3>

<p>Catania et al. (1992) &quot;The population-based AMEN (AIDS in Multi-Ethnic
Neighborhoods) study&quot; <em>American Journal of Public Health</em> 82, 284-287
</p>
<p>Morris, M. (1995) &quot;Data driven network models for the spread of infectious
disease&quot;. In D. Mollison (ed.) <em>Epidemic Models: Their Structure and
Relation to Data</em>, pp. 302-322, Cambridge University Press, Cambridge
</p>
<p>Newman, M. (2003) &quot;Mixing patterns in networks&quot; Arxiv:cond-mat/0209450 v2
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(Catania)

# assortativity
ep &lt;- sum(Catania %*% Catania)
( sum(diag(Catania)) - ep ) / ( 1 - ep )
</code></pre>

<hr>
<h2 id='Classroom'>Classroom network</h2><span id='topic+Classroom'></span>

<h3>Description</h3>

<p>A directed network of ties &quot;with whom do you like to play with?&quot; collected in
a school class of 9-year olds. The data comes from a study undertook by
Educational Research Institute (Dolata 2014).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Classroom
</code></pre>


<h3>Format</h3>

<p>Object of class &quot;igraph&quot; with a directed network of size 26. Vertex
attributes:
</p>

<ul>
<li> <p><code>gender</code> &ndash; with values &quot;Boy&quot; or &quot;Girl&quot;.
</p>
</li></ul>



<h3>References</h3>

<p>Dolata, Roman (ed). (2014). <em>Czy szkoła ma znaczenie? Zróżnicowanie wyników
nauczania po pierwszym etapie edukacyjnym oraz jego pozaszkolne i szkolne
uwarunkowania</em>. Vol. 1.  Warsaw: Instytut Badań Edukacyjnych.
</p>

<hr>
<h2 id='coleman'>Coleman's homophily index</h2><span id='topic+coleman'></span><span id='topic+coleman.table'></span><span id='topic+coleman.igraph'></span><span id='topic+coleman.default'></span>

<h3>Description</h3>

<p>Colemans's homphily index for directed networks.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>coleman(object, ...)

## S3 method for class 'table'
coleman(object, gsizes = NULL, loops = FALSE, ...)

## S3 method for class 'igraph'
coleman(object, vattr, ...)

## Default S3 method:
coleman(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="coleman_+3A_object">object</code></td>
<td>
<p>R object, see Details for available methods</p>
</td></tr>
<tr><td><code id="coleman_+3A_...">...</code></td>
<td>
<p>other arguments passed to/from methods</p>
</td></tr>
<tr><td><code id="coleman_+3A_gsizes">gsizes</code></td>
<td>
<p>numeric vector of group sizes</p>
</td></tr>
<tr><td><code id="coleman_+3A_loops">loops</code></td>
<td>
<p>logical, whether loops are allowed</p>
</td></tr>
<tr><td><code id="coleman_+3A_vattr">vattr</code></td>
<td>
<p>character, vertex attribute</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Coleman's homophily index computes homophily scores for each group
defined by a vertex attribute.
</p>
<p>If <code>object</code> is a table it is interpreted as a mixing matrix.
Two-dimensional table is interpreted as a contact layer. Three-dimensional
table is interpreted as a full mixing matrix <code class="reqn">m_{ghy}</code>
cross-classyfying all dyads, in which <code class="reqn">g</code> and <code class="reqn">h</code> correspond to
group membership of ego and alter respectively. Layers <code class="reqn">y=1</code> and
<code class="reqn">y=2</code> are assumed to be non-contact and contact layers respectively.
</p>
<p>If <code>object</code> is of class &quot;igraph&quot; it is required to supply <code>vattr</code>
with the name of the vertex attribute to calculate intermediate mixing
matrix.
</p>


<h3>Value</h3>

<p>Vector of numeric values of the index for each group
</p>


<h3>References</h3>

<p>Coleman, J. (1958) &quot;Relational analysis: The study of social organizations
with survey methods&quot;, <em>Human Organization</em> 17:28&ndash;36.
</p>


<h3>See Also</h3>

<p>Other segregation measures: 
<code><a href="#topic+assort">assort</a>()</code>,
<code><a href="#topic+ei">ei</a>()</code>,
<code><a href="#topic+freeman">freeman</a>()</code>,
<code><a href="#topic+gamix">gamix</a>()</code>,
<code><a href="#topic+orwg">orwg</a>()</code>,
<code><a href="#topic+smi">smi</a>()</code>,
<code><a href="#topic+ssi">ssi</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if(requireNamespace("igraph", quietly = TRUE)) {
  # Converting networks to directed
  coleman(igraph::as.directed(WhiteKinship, "mutual"), "gender")
  coleman(igraph::as.directed(EF3, "mutual"), "race")
}
</code></pre>

<hr>
<h2 id='EF3'>Example data from Figure III of Echenique and Fryer (2006)</h2><span id='topic+EF3'></span>

<h3>Description</h3>

<p>Artificial example data from Echenique &amp; Fryer (2006) Figure III representing
a city with black and white neighbourhoods.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>EF3
</code></pre>


<h3>Format</h3>

<p>Object of class &quot;igraph&quot;. An undirected network with vertex
attributes:
</p>

<ul>
<li> <p><code>name</code> &ndash; vertex names of the form &quot;A1&quot; in which letter and number indicate
the position in the lattice
</p>
</li>
<li> <p><code>race</code> &ndash; values 1 or 2 indicate the two groups
</p>
</li></ul>



<h3>Details</h3>

<p>This data is taken from Echenique &amp; Fryer (2006, figure III). The data
represent a fictional city composed of 30 neighborhoods that are either
black or white.
</p>


<h3>Source</h3>

<p>Echenique, Federico and Roland G. Fryer, Jr. (2006) &quot;A Measure of
Segregation Based On Social Interactions&quot; <em>Quarterly Journal of Economics</em>
CXXII(2):441-485
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if(requireNamespace("igraph", quietly = TRUE)) {
  set.seed(1)
  plot(
    EF3,
    layout = igraph::layout.fruchterman.reingold,
    vertex.color = igraph::V(EF3)$type+1,
    vertex.label.family = "",
    sub = "Source: Echenique &amp; Fryer (2006)",
    main = "Neighborhood racial segregation\n in a fictional city"
  )
}
</code></pre>

<hr>
<h2 id='ei'>Krackhard and Stern's E-I index</h2><span id='topic+ei'></span><span id='topic+ei.table'></span><span id='topic+ei.igraph'></span><span id='topic+ei.default'></span>

<h3>Description</h3>

<p>An index proposed by Krackhard and Stern (1988) to capture relative
prevalence of between- and within-group ties. From that perspective it can
be interpreted as a measure of network segregation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ei(object, ...)

## S3 method for class 'table'
ei(object, ...)

## S3 method for class 'igraph'
ei(
  object,
  vattr,
  directed = is.directed(object),
  loops = any(is.loop(object)),
  ...
)

## Default S3 method:
ei(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ei_+3A_object">object</code></td>
<td>
<p>R object, see Details for available methods</p>
</td></tr>
<tr><td><code id="ei_+3A_...">...</code></td>
<td>
<p>other arguments passed to/from other methods</p>
</td></tr>
<tr><td><code id="ei_+3A_vattr">vattr</code></td>
<td>
<p>character scalar or vector of length equal to the size of
<code>object</code>, vertex attribute for which mixing matrix is to be computed</p>
</td></tr>
<tr><td><code id="ei_+3A_directed">directed</code></td>
<td>
<p>logical whether the network is directed</p>
</td></tr>
<tr><td><code id="ei_+3A_loops">loops</code></td>
<td>
<p>logical, whether loops are allowed</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If <code>object</code> is a table it is interpreted as a mixing matrix.
Two-dimensional table is interpreted as a contact layer. Three-dimensional
table is interpreted as a full mixing matrix <code class="reqn">m_{ghy}</code>
cross-classyfying all dyads, in which <code class="reqn">g</code> and <code class="reqn">h</code> correspond to
group membership of ego and alter respectively. Layers <code class="reqn">y=1</code> and
<code class="reqn">y=2</code> are assumed to be non-contact and contact layers respectively.
</p>
<p>If <code>object</code> is of class &quot;igraph&quot; it is required to supply <code>vattr</code>
with the name of the vertex attribute to calculate intermediate mixing
matrix.
</p>


<h3>Value</h3>

<p>Numerical value of the E-I index.
</p>


<h3>References</h3>

<p>Krackhardt, D., &amp; Stern, R. N. (1988). Informal networks and
organizational crises: An experimental simulation. <em>Social Psychology
Quarterly</em>, 123-140.
</p>


<h3>See Also</h3>

<p>Other segregation measures: 
<code><a href="#topic+assort">assort</a>()</code>,
<code><a href="#topic+coleman">coleman</a>()</code>,
<code><a href="#topic+freeman">freeman</a>()</code>,
<code><a href="#topic+gamix">gamix</a>()</code>,
<code><a href="#topic+orwg">orwg</a>()</code>,
<code><a href="#topic+smi">smi</a>()</code>,
<code><a href="#topic+ssi">ssi</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>ei(WhiteKinship, "gender")
</code></pre>

<hr>
<h2 id='fold'>Folding square matrices around the diagonal</h2><span id='topic+fold'></span>

<h3>Description</h3>

<p>Fold a square matrix by collapsing lower triangle on upper triangle, or vice
versa, through addition.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fold(x, direction = c("upper", "lower"))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fold_+3A_x">x</code></td>
<td>
<p>square numeric matrix</p>
</td></tr>
<tr><td><code id="fold_+3A_direction">direction</code></td>
<td>
<p>character, one of <code>"upper"</code> or <code>"lower"</code>,
direction of folding</p>
</td></tr>
</table>


<h3>Details</h3>

<p>By default, for <code>direction=="upper"</code>, the function takes the values in
the lower triangle of <code>x</code> and adds them symetrically to the values in
the upper triangle. The values on the diagonal remain unchanged. The lower
triangle is filled with 0s. If <code>direction=="lower"</code> the upper triangle
is collapsed on to the lower triangle.
</p>


<h3>Value</h3>

<p>Square matrix of the same <code>dim</code> as <code>x</code> with the lower
(upper) triangle folded onto the upper (lower) triangle.
</p>


<h3>See Also</h3>

<p><code><a href="base.html#topic+upper.tri">upper.tri()</a></code>, <code><a href="base.html#topic+lower.tri">lower.tri()</a></code>, <code><a href="#topic+symmetrize">symmetrize()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>(m &lt;- matrix(1:4, 2, 2))
(f1 &lt;- fold(m))
(f2 &lt;- fold(m, "lower"))

stopifnot( all.equal(diag(m), diag(f1)) )
stopifnot( all.equal(diag(m), diag(f2)) )
stopifnot( all.equal(f1[1,2], m[2,1] + m[1,2]) )
stopifnot( all.equal(f2[2,1], m[2,1] + m[1,2]) )
</code></pre>

<hr>
<h2 id='freeman'>Generalized Freeman's segregation index</h2><span id='topic+freeman'></span><span id='topic+freeman.table'></span><span id='topic+freeman.igraph'></span><span id='topic+freeman.default'></span>

<h3>Description</h3>

<p>Calculate Freeman's segregation index for undirected networks with
arbitrary number of groups.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>freeman(object, ...)

## S3 method for class 'table'
freeman(object, gsizes = NULL, loops = FALSE, ...)

## S3 method for class 'igraph'
freeman(object, vattr, gsizes = NULL, loops = any(is.loop(object)), ...)

## Default S3 method:
freeman(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="freeman_+3A_object">object</code></td>
<td>
<p>R object, see Details for available methods</p>
</td></tr>
<tr><td><code id="freeman_+3A_...">...</code></td>
<td>
<p>other arguments passed to/from other methods</p>
</td></tr>
<tr><td><code id="freeman_+3A_gsizes">gsizes</code></td>
<td>
<p>numeric, optional true distribution of types, see Details</p>
</td></tr>
<tr><td><code id="freeman_+3A_loops">loops</code></td>
<td>
<p>logical, whether loops are allowed</p>
</td></tr>
<tr><td><code id="freeman_+3A_vattr">vattr</code></td>
<td>
<p>character scalar or any vector of length equal to
<code>vcount(object)</code>, name of the vertex attribute in <code>object</code>
designating the groups or a vector with the attribute itself</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Freeman's segregation index (Freeman, 1978) is designed to capture the
extent to which the defined groups of vertices tend to have more edges with
vertices from the same group than with other groups.  Formally, the index
compares the observed number of between-group ties with the number of
between-group ties that would be expected if ties would be created randomly.
</p>
<p>Originally the index has a discontinuity for network and group size
configurations that are characterized by the higher number of between-group
ties that is expected under a random graph, for which it returns 0 (as
originally described by Freeman (1978)). We removed that truncation such that
it returns values betweem -1 and 1.
</p>
<p>The original Freeman's formulation involves two groups of vertices. Here
it is extended to the arbitrary number of groups. The generalization
affects the way in which the expected number of between-group edges under pure
random graph is calculated, see Bojanowski &amp; Corten (2014) for details.
</p>
<p>The function internally calculates the sizes of groups of vertices in the
supplied attribute <code>vattr</code>. However, it is possible to override this by
specifying &quot;true&quot; type distribution with the <code>gsizes</code> argument. It is assumed
to be a table (as returned by <code><a href="base.html#topic+table">table()</a></code>) or a numeric vector with the group
sizes. This may be especially usefull when dealing with large graphs and/or
with large number of isolates.
</p>
<p>If <code>object</code> is a table it is interpreted as a mixing matrix.
Two-dimensional table is interpreted as a contact layer. Three-dimensional
table is interpreted as a full mixing matrix <code class="reqn">m_{ghy}</code>
cross-classyfying all dyads, in which <code class="reqn">g</code> and <code class="reqn">h</code> correspond to
group membership of ego and alter respectively. Layers <code class="reqn">y=1</code> and
<code class="reqn">y=2</code> are assumed to be non-contact and contact layers respectively.
</p>
<p>If <code>object</code> is of class &quot;igraph&quot; it is required to supply <code>vattr</code>
with the name of the vertex attribute to calculate intermediate mixing
matrix.
</p>
<p>Method for mixing matrices
</p>
<p>Method for &quot;igraph&quot;s
</p>


<h3>Value</h3>

<p>The value of the Freeman's index.
</p>


<h3>References</h3>

<p>Freeman, Linton C. (1978) Segregation in Social Networks,
<em>Sociological Methods &amp; Research</em> <b>6</b>(4):411&ndash;429
</p>
<p>Bojanowski, Michał, and Rense Corten. 2014. &quot;Measuring Segregation in
Social Networks.&quot; <em>Social Networks</em> 39: 14–32.
<a href="https://doi.org/10.1016/j.socnet.2014.04.001">doi:10.1016/j.socnet.2014.04.001</a>
</p>


<h3>See Also</h3>

<p>Other segregation measures: 
<code><a href="#topic+assort">assort</a>()</code>,
<code><a href="#topic+coleman">coleman</a>()</code>,
<code><a href="#topic+ei">ei</a>()</code>,
<code><a href="#topic+gamix">gamix</a>()</code>,
<code><a href="#topic+orwg">orwg</a>()</code>,
<code><a href="#topic+smi">smi</a>()</code>,
<code><a href="#topic+ssi">ssi</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## White's data from Freeman's article segregation level
freeman(WhiteKinship, "gender")

# using 'more' argument
freeman(WhiteKinship, "gender")
</code></pre>

<hr>
<h2 id='gamix'>Gupta-Anderson-May measure of within-group mixing</h2><span id='topic+gamix'></span><span id='topic+gamix.table'></span><span id='topic+gamix.igraph'></span><span id='topic+gamix.default'></span>

<h3>Description</h3>

<p>Measure of within-group mixing in networks proposed in Gupta, Anderson and
May (1989).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gamix(object, ...)

## S3 method for class 'table'
gamix(object, ...)

## S3 method for class 'igraph'
gamix(object, vattr, ...)

## Default S3 method:
gamix(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gamix_+3A_object">object</code></td>
<td>
<p>R object, see Details for available methods</p>
</td></tr>
<tr><td><code id="gamix_+3A_...">...</code></td>
<td>
<p>other objects passed to/from other methods</p>
</td></tr>
<tr><td><code id="gamix_+3A_vattr">vattr</code></td>
<td>
<p>character, name of vertex attribute</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The measure varies between <code>-1/vcount(g)</code> for dissassortative mixing
and 1 for perfect within-group mixing. It takes a value of 0 for
proportionate mixing.
</p>
<p>If <code>object</code> is a table it is interpreted as a mixing matrix.
Two-dimensional table is interpreted as a contact layer. Three-dimensional
table is interpreted as a full mixing matrix <code class="reqn">m_{ghy}</code>
cross-classyfying all dyads, in which <code class="reqn">g</code> and <code class="reqn">h</code> correspond to
group membership of ego and alter respectively. Layers <code class="reqn">y=1</code> and
<code class="reqn">y=2</code> are assumed to be non-contact and contact layers respectively.
</p>
<p>If <code>object</code> is of class &quot;igraph&quot; it is required to supply <code>vattr</code>
with the name of the vertex attribute to calculate intermediate mixing
matrix.
</p>


<h3>Value</h3>

<p>Numerical value of the measure.
</p>


<h3>References</h3>

<p>Gupta, S., Anderson, R., May, R. (1989) &quot;Networks of sexual contacts:
implications for the pattern of spread of HIV&quot;, AIDS 3:807&ndash;817
</p>


<h3>See Also</h3>

<p>Other segregation measures: 
<code><a href="#topic+assort">assort</a>()</code>,
<code><a href="#topic+coleman">coleman</a>()</code>,
<code><a href="#topic+ei">ei</a>()</code>,
<code><a href="#topic+freeman">freeman</a>()</code>,
<code><a href="#topic+orwg">orwg</a>()</code>,
<code><a href="#topic+smi">smi</a>()</code>,
<code><a href="#topic+ssi">ssi</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>gamix(WhiteKinship, "gender")
gamix(EF3, "race")
</code></pre>

<hr>
<h2 id='group_sizes'>Computing group sizes from square mixing matrices</h2><span id='topic+group_sizes'></span>

<h3>Description</h3>

<p><code><a href="#topic+group_sizes">group_sizes()</a></code> recomputes group sizes from a full mixing matrix. This is
only limited to square (single-attribute) mixing matrices.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>group_sizes(mm, directed = TRUE, loops = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="group_sizes_+3A_mm">mm</code></td>
<td>
<p>numeric array with <code>dim</code> of <code class="reqn">(k, k, 2)</code> for some <code class="reqn">k</code></p>
</td></tr>
<tr><td><code id="group_sizes_+3A_directed">directed</code></td>
<td>
<p>logical, whether network is directed</p>
</td></tr>
<tr><td><code id="group_sizes_+3A_loops">loops</code></td>
<td>
<p>logical, whether loops are allowed</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A numeric vector of group sizes
</p>

<hr>
<h2 id='mixingm'>Network mixing matrix</h2><span id='topic+mixingm'></span><span id='topic+mixingm.igraph'></span><span id='topic+mixingdf'></span><span id='topic+mixingdf.table'></span><span id='topic+mixingdf.igraph'></span>

<h3>Description</h3>

<p>Creating network mixing matrices (<code><a href="#topic+mixingm">mixingm()</a></code>) and data frames (<code><a href="#topic+mixingdf">mixingdf()</a></code>).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mixingm(object, ...)

## S3 method for class 'igraph'
mixingm(
  object,
  rattr,
  cattr = rattr,
  full = FALSE,
  directed = is.directed(object),
  loops = any(is.loop(object)),
  ...
)

mixingdf(object, ...)

## S3 method for class 'table'
mixingdf(object, ...)

## S3 method for class 'igraph'
mixingdf(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mixingm_+3A_object">object</code></td>
<td>
<p>R object, see Details for available methods</p>
</td></tr>
<tr><td><code id="mixingm_+3A_...">...</code></td>
<td>
<p>other arguments passed to/from other methods</p>
</td></tr>
<tr><td><code id="mixingm_+3A_rattr">rattr</code></td>
<td>
<p>name of the vertex attribute or an attribute itself as a vector.
If <code>cattr</code> is not <code>NULL</code>, <code>rattr</code> is used for rows of the resulting mixing
matrix.</p>
</td></tr>
<tr><td><code id="mixingm_+3A_cattr">cattr</code></td>
<td>
<p>name of the vertex attribute or an attribute itself as a vector.
If supplied, used for columns in the mixing matrix.</p>
</td></tr>
<tr><td><code id="mixingm_+3A_full">full</code></td>
<td>
<p>logical, whether two- or three-dimensional mixing matrix should
be returned.</p>
</td></tr>
<tr><td><code id="mixingm_+3A_directed">directed</code></td>
<td>
<p>logical, whether the network is directed. By default,
directedness of the network is determined with <code><a href="igraph.html#topic+is_directed">igraph::is_directed()</a></code>.</p>
</td></tr>
<tr><td><code id="mixingm_+3A_loops">loops</code></td>
<td>
<p>logical, whether loops are allowed. By default it is <code>TRUE</code>
whenever there is at least one loop in <code>object</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Network mixing matrix is, traditionally, a two-dimensional
cross-classification of edges depending on the values of a specified vertex
attribute for tie sender and tie receiver. It is an important tool
for assessing network homophily or segregation.
</p>
<p>Let <code class="reqn">G</code> be the number of distinct values of the vertex attribute in
question.  We may say that we have <code class="reqn">G</code> mutually exclusive groups in the
network.  The mixing matrix is a <code class="reqn">G \times G</code> matrix such that
<code class="reqn">m_{ij}</code> is the number of ties send by vertices in group <code class="reqn">i</code>
to vertices in group <code class="reqn">j</code>. The diagonal of that matrix is of special
interest as, say, <code class="reqn">m_{ii}</code> is the number of ties <em>within</em>
group <code class="reqn">i</code>.
</p>
<p>A full mixing matrix is a three-dimensional array that cross-classifies
<em>all</em> network <em>dyads</em> depending on:
</p>

<ol>
<li><p> the value of the vertex attribute for tie sender
</p>
</li>
<li><p> the value of the vertex attribute for tie receiver
</p>
</li>
<li><p> the status of the dyad, i.e. whether it is connected or not
</p>
</li></ol>

<p>The two-dimensional version is a so-called &quot;contact layer&quot;
of the three-dimensional version.
</p>
<p>If <code>object</code> is of class &quot;igraph,&quot; mixing matrix is created for the
network in <code>object</code> based on vertex attributes supplied in arguments
<code>rattr</code> and optionally <code>cattr</code>.
</p>
<p>If only <code>rattr</code> is specified (or, equivalently, <code>rattr</code> and <code>cattr</code> are
identical), the result will be a mixing matrix <code class="reqn">G \times G</code> if <code>full</code>
is <code>FALSE</code> or <code class="reqn">G \times G \times 2</code> if <code>full</code> is <code>TRUE</code>. Where
<code class="reqn">G</code> is the number of categories of vertex attribute specified by
<code>rattr</code>.
</p>
<p>If <code>rattr</code> and <code>cattr</code> can be used to specify different vertex attributes
for tie sender and tie receiver.
</p>


<h3>Value</h3>

<p>Function <code><a href="#topic+mixingm">mixingm()</a></code>, depending on <code>full</code> argument, a two- or
three-dimensional array crossclassifying connected or all dyads in
<code>object</code>. For undirected network and if <code>foldit</code> is <code>TRUE</code> (default), the
matrix is folded onto the upper triangle (entries in lower triangle are 0).
</p>
<p>Function <code><a href="#topic+mixingdf">mixingdf()</a></code> returns non-zero entries of a mixing matrix (as
returned by <code><a href="#topic+mixingm">mixingm()</a></code>), but organized in a data frame with columns:
</p>

<ul>
<li> <p><code>ego</code>, <code>alter</code> &ndash; group membership of ego an alter
</p>
</li>
<li> <p><code>tie</code> &ndash; present only if <code>full=TRUE</code>, with <code>TRUE</code> or <code>FALSE</code> for connected
and disconnected dyads respectively
</p>
</li>
<li> <p><code>n</code> &ndash; counts
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>if(requireNamespace("igraph", quietly = TRUE)) {
  # some directed network
  net &lt;- igraph::make_graph(c(1,2, 1,3, 2,3,  4,5,  1,4, 1,5, 4,2, 5,3))
  igraph::V(net)$type &lt;- c(1,1,1, 2,2)
  mixingm(net, "type")
  mixingm(net, "type", full=TRUE)
  # as undirected
  mixingm( igraph::as.undirected(net), "type")
  mixingm(net, "type")
  mixingm(net, "type", full=TRUE)
}
</code></pre>

<hr>
<h2 id='orwg'>Odds ratio of existence of within-group ties</h2><span id='topic+orwg'></span><span id='topic+orwg.table'></span><span id='topic+orwg.igraph'></span><span id='topic+orwg.default'></span>

<h3>Description</h3>

<p>Odds ratio for connected, as opposed to disconnected, dyads depending
whether it is between- or within-group, i.e. how much more likely the dyad
will be connected if it is within-group.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>orwg(object, ...)

## S3 method for class 'table'
orwg(object, ...)

## S3 method for class 'igraph'
orwg(object, vattr, ...)

## Default S3 method:
orwg(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="orwg_+3A_object">object</code></td>
<td>
<p>R object, see Details for available methods</p>
</td></tr>
<tr><td><code id="orwg_+3A_...">...</code></td>
<td>
<p>other arguments passed to/from other methods</p>
</td></tr>
<tr><td><code id="orwg_+3A_vattr">vattr</code></td>
<td>
<p>character scalar or any vector, name of the vertex attribute or
the attribute itself (as a vector)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The measure takes values, like all odds ratios, from (0; Inf).
</p>
<p>If <code>object</code> is a table it is interpreted as a mixing matrix.
Two-dimensional table is interpreted as a contact layer. Three-dimensional
table is interpreted as a full mixing matrix <code class="reqn">m_{ghy}</code>
cross-classyfying all dyads, in which <code class="reqn">g</code> and <code class="reqn">h</code> correspond to
group membership of ego and alter respectively. Layers <code class="reqn">y=1</code> and
<code class="reqn">y=2</code> are assumed to be non-contact and contact layers respectively.
</p>
<p>If <code>object</code> is of class &quot;igraph&quot; it is required to supply <code>vattr</code>
with the name of the vertex attribute to calculate intermediate mixing
matrix.
</p>


<h3>Value</h3>

<p>Numeric value of the measure.
</p>


<h3>References</h3>

<p>Moody, Jim (2001) &quot;Race, school integration, and friendship segregation in
America&quot;, American Journal of Sociology, 107(3):679&ndash;377
</p>


<h3>See Also</h3>

<p>Other segregation measures: 
<code><a href="#topic+assort">assort</a>()</code>,
<code><a href="#topic+coleman">coleman</a>()</code>,
<code><a href="#topic+ei">ei</a>()</code>,
<code><a href="#topic+freeman">freeman</a>()</code>,
<code><a href="#topic+gamix">gamix</a>()</code>,
<code><a href="#topic+smi">smi</a>()</code>,
<code><a href="#topic+ssi">ssi</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>orwg(WhiteKinship, "gender")
</code></pre>

<hr>
<h2 id='smi'>Segregation Matrix Index</h2><span id='topic+smi'></span><span id='topic+smi.table'></span><span id='topic+smi.igraph'></span><span id='topic+smi.default'></span>

<h3>Description</h3>

<p>Segregation Matrix Index due to Freshtman (1997). A measure of network
segregation. Currently (and originally) supports only two groups.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>smi(object, ...)

## S3 method for class 'table'
smi(object, normalize = TRUE, ...)

## S3 method for class 'igraph'
smi(object, vattr, ...)

## Default S3 method:
smi(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="smi_+3A_object">object</code></td>
<td>
<p>R object, see Details for available methods</p>
</td></tr>
<tr><td><code id="smi_+3A_...">...</code></td>
<td>
<p>other arguments passed to/from other methods</p>
</td></tr>
<tr><td><code id="smi_+3A_normalize">normalize</code></td>
<td>
<p>logical, whether normalized values should be returned,
defaults to <code>TRUE</code></p>
</td></tr>
<tr><td><code id="smi_+3A_vattr">vattr</code></td>
<td>
<p>character, name of the node attribute designating groups</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The Segregation Matrix Index (SMI) is calculated for every group separately.
It compares the density within group to the density of between group ties of
nodes belonging to that group.
</p>
<p>Non-normalized version is the ratio of the within-group density to the
between-group density, so vary between 0 and infinity. The normalized
version varies between 0 and 1.
</p>
<p>If <code>object</code> is a table it is interpreted as a mixing matrix.
Two-dimensional table is interpreted as a contact layer. Three-dimensional
table is interpreted as a full mixing matrix <code class="reqn">m_{ghy}</code>
cross-classyfying all dyads, in which <code class="reqn">g</code> and <code class="reqn">h</code> correspond to
group membership of ego and alter respectively. Layers <code class="reqn">y=1</code> and
<code class="reqn">y=2</code> are assumed to be non-contact and contact layers respectively.
</p>
<p>If <code>object</code> is of class &quot;igraph&quot; it is required to supply <code>vattr</code>
with the name of the vertex attribute to calculate intermediate mixing
matrix.
</p>


<h3>Value</h3>

<p>Numeric vector of length equal to the number of groups in <code>g</code>
according to <code>vattr</code> with the values of SMI for the groups.
</p>


<h3>References</h3>

<p>Freshtman, M. (1997) &quot;Cohesive Group Segregation Detection in a
Social Network by the Segregation Matrix Index&quot;, Social Networks,
19:193&ndash;207
</p>


<h3>See Also</h3>

<p>Other segregation measures: 
<code><a href="#topic+assort">assort</a>()</code>,
<code><a href="#topic+coleman">coleman</a>()</code>,
<code><a href="#topic+ei">ei</a>()</code>,
<code><a href="#topic+freeman">freeman</a>()</code>,
<code><a href="#topic+gamix">gamix</a>()</code>,
<code><a href="#topic+orwg">orwg</a>()</code>,
<code><a href="#topic+ssi">ssi</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># smi() needs a directed network
smi( igraph::as.directed(WhiteKinship, "mutual"), "gender")
</code></pre>

<hr>
<h2 id='ssi'>Spectral Segregation Index for Social Networks</h2><span id='topic+ssi'></span>

<h3>Description</h3>

<p>These functions implement Spectral Segregation Index as proposed by
Echenique &amp; Fryer (2006). This index is a node-level measure of segregation
in a given network.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ssi(g, vattr)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ssi_+3A_g">g</code></td>
<td>
<p>object of class &quot;igraph&quot; representing a network</p>
</td></tr>
<tr><td><code id="ssi_+3A_vattr">vattr</code></td>
<td>
<p>character, name of the vertex attribute</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For a full description and axiomatization see Echenique &amp; Fryer (2006).
</p>
<p>The network <code>g</code> is converted to adjacency matrix and normalized so that
all rows sum-up to 1.
</p>
<p>The procedure essentially consists of creating a submatrix, say, <code class="reqn">B</code> of
the adjacency matrix, say <code class="reqn">A</code>. This submatrix <code class="reqn">B</code> contains only
vertices of the given type. It may be viewed as a type-homogeneous
subnetwork of <code>A</code>. This subnetwork is further decomposed into connected
components.  Then, for every component, an eigenvalue decomposition is
applied.  The value of the index for the component is simply the largest
eigenvalue, and the individual-level indices are obtained by distributing it
according to the corresponding eigenvector.
</p>


<h3>Value</h3>

<p>Named vector of individual level values of SSI. Names correspond to vertex
ids in <code>g</code>.
</p>


<h3>References</h3>

<p>Echenique, F., &amp; Fryer Jr, R. G. (2007). A measure of segregation based on
social interactions. The Quarterly Journal of Economics, 122(2), 441-485.
</p>


<h3>See Also</h3>

<p>Other segregation measures: 
<code><a href="#topic+assort">assort</a>()</code>,
<code><a href="#topic+coleman">coleman</a>()</code>,
<code><a href="#topic+ei">ei</a>()</code>,
<code><a href="#topic+freeman">freeman</a>()</code>,
<code><a href="#topic+gamix">gamix</a>()</code>,
<code><a href="#topic+orwg">orwg</a>()</code>,
<code><a href="#topic+smi">smi</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if(requireNamespace("igraph", quietly = TRUE)) {

### artificial EF data
x &lt;- ssi(EF3, "race")
x


# show it on picture
a &lt;- igraph::V(EF3)$race
# rescale SSI values to use as shades of gray
k &lt;- 1 - scale(x, center=min(x), scale=max(x) - min(x))
plot( EF3, layout=igraph::layout.fruchterman.reingold,
vertex.color= gray(k),
vertex.label.family="",
vertex.shape=c("circle", "square")[a],
vertex.label.color=gray( (1-k) &gt; .4 )
)

### For White's kinship data
x &lt;- ssi(WhiteKinship, "gender")
x

# plot it
a &lt;- match(igraph::V(WhiteKinship)$gender, unique(igraph::V(WhiteKinship)$gender))
k &lt;- 1 - scale(x, center=min(x), scale=max(x) - min(x))
set.seed(1234)
plot( WhiteKinship, layout=igraph::layout.fruchterman.reingold,
main="Node segregation in White's kinship data",
vertex.label.family="",
vertex.label=igraph::V(WhiteKinship)$name,
vertex.color= gray(k),
vertex.shape=c("circle", "csquare")[a],
vertex.label.color="black")
legend( "topleft", legend=c("Men", "Women"), pch=c(0,1), col=1)
}
</code></pre>

<hr>
<h2 id='symmetrize'>(De)symmetrize square numeric matrix</h2><span id='topic+symmetrize'></span>

<h3>Description</h3>

<p>(De)symmetrize square binary matrix in various ways.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>symmetrize(mat, rule = c("upper", "lower", "div", "intdiv"))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="symmetrize_+3A_mat">mat</code></td>
<td>
<p>square numeric matrix</p>
</td></tr>
<tr><td><code id="symmetrize_+3A_rule">rule</code></td>
<td>
<p>character, direction of copying, see Details</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Argument <code>mat</code> is to be a square numeric matrix. The way it is made
symmetric, or asymetric, depends on the value of the <code>rule</code> argument.
</p>
<p>If <code>rule</code> is &quot;upper&quot; or &quot;lower&quot; then <code>mat</code> is made symmetric by copying,
respectively, upper triangle onto lower, or lower onto upper. The value of
<code>rule</code> specifies values of which triangle will stay in the returned value.
</p>
<p>If <code>rule</code> is &quot;intdiv&quot; then the off-diagonal values are distributed
approximately equally between the lower/upper triangles. If <code>r</code> is the
computed result, then <code>r[i,j]</code> will be equal to
<code style="white-space: pre;">&#8288;(x[i,j] + x[j,i]) \%/\% 2&#8288;</code> if <code>r[i,j]</code> is in the lower triangle.
It will be equal to
<code style="white-space: pre;">&#8288;(x[i,j] + x[j,i]) \%/\% 2 + 1&#8288;</code> if in the upper triangle.
</p>
<p>If <code>rule</code> is &quot;div&quot; then the off-diagonal values are distributed equally
between the lower/upper triangles: as with &quot;intdiv&quot; but using normal
<code>/</code> division.
</p>


<h3>Value</h3>

<p>A matrix: symmetrized version of <code>mat</code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+fold">fold()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>m &lt;- matrix(1:16, 4, 4)

# copy upper triangle onto lower symmetrically
symmetrize(m, "upper")

# copy lower triangle onto upper symmetrically
symmetrize(m, "lower")

# distribute off-diagonal values exactly
# r[i,j] = (m[i,j] + m[j,i]) / 2
r1 &lt;- symmetrize(m, "div")
r1
all.equal(sum(m), sum(r1))

# distribute off-diagonal values using integer division
r2 &lt;- symmetrize(m, "intdiv")
r2
all.equal(sum(m), sum(r2))
</code></pre>

<hr>
<h2 id='WhiteKinship'>White's data on Effective Kinship Networks</h2><span id='topic+WhiteKinship'></span>

<h3>Description</h3>

<p>This data is taken from Freeman (1978) who uses data from White (1975) to
illustrate the segregation measure.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>WhiteKinship
</code></pre>


<h3>Format</h3>

<p>Object of class &quot;igraph&quot; with an undirected network of size 10. Vertex
attribute <code>gender</code>, takes values &quot;male&quot; or &quot;female&quot;.
</p>


<h3>Details</h3>

<p>Based on Freeman (1978):
</p>
<p>White dealt with the problem of segregation among social positions rather
than among individual persons. He specified a set of standard kinship
positions that he called the &ldquo;effective kinship network&rdquo;.
</p>
<p>Traditional analysis (e.g. Murdock, 1971) have argued that societies
sometimes proscribe interaction among some kinship positions as an extension
of icest taboos.  Thus, given this reasoning, kinship positions should be
segregated according to the gender of their occupants. White's data provide
possibility to test of this hypothesis.
</p>
<p>White collected data on the rules governing various kinds of interaction
among occupants of his ten standard kinship positions for a sample of 219
societies.  For every pair of positions White specified whether or not
interaction between their occupants was ever restricted in any society in
the sample.
</p>


<h3>Source</h3>

<p>Freeman, Linton C. (1978) &quot;Segregation in Social Networks&quot; Sociological
Methods and Research 6(4):411&ndash;429
</p>


<h3>References</h3>

<p>Freeman, Linton C. (1978) &quot;Segregation in Social Networks&quot; Sociological
Methods and Research 6(4):411&ndash;429
</p>
<p>Murdock, G. P. (1971) &quot;Cross-Sex Patterns of Kin Behavior&quot; Ethnology 1:
359&ndash;368
</p>
<p>White, D. R. (1975) &quot;Communicative Avoidance in Social Networks&quot;. University
of California, Irvine. (mimeo)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if( requireNamespace("igraph", quietly = TRUE) ) {
  set.seed(2992)
  plot(
    WhiteKinship, layout=igraph::layout.fruchterman.reingold,
    vertex.color= match(igraph::V(WhiteKinship)$gender, unique(igraph::V(WhiteKinship)$gender)),
    vertex.label=igraph::V(WhiteKinship)$name, vertex.label.family="",
    main="White's (1975) data on kinship networks"
  )
  legend("topleft", col=2:3, legend=c("Woman", "Man"), pch=19)
}
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
