<!DOCTYPE html><html lang="en"><head><title>Help for package cccp</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {cccp}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#cccp'>
<p>Solving linear and quadratic programs with cone constraints</p></a></li>
<li><a href='#CPD-class'><p>Class <code>"CPD"</code></p></a></li>
<li><a href='#CPG'>
<p>Rcpp module: CPG</p></a></li>
<li><a href='#cps'>
<p>Solving a convex program</p></a></li>
<li><a href='#ctrl'>
<p>Creating objects of reference-class CTRL</p></a></li>
<li><a href='#dcp'>
<p>Creating a member object of the reference-class <code>DCP</code></p></a></li>
<li><a href='#dlp'>
<p>Creating a member object of the reference-class <code>DLP</code></p></a></li>
<li><a href='#dnl'>
<p>Creating a member object of the reference-class <code>DNL</code></p></a></li>
<li><a href='#dqp'>
<p>Creating a member object of the reference-class <code>DQP</code></p></a></li>
<li><a href='#getFoo'>
<p>Extractor methods for reference class objects</p></a></li>
<li><a href='#gp'>
<p>Geometric program</p></a></li>
<li><a href='#l1'>
<p>Minimizing L1-norm</p></a></li>
<li><a href='#nlfc'>
<p>Definition of nonlinear inequality constraints</p></a></li>
<li><a href='#nnoc'>
<p>Definition of linear inequality constraints</p></a></li>
<li><a href='#psdc'>
<p>Definition of positive semidefinite cone inequality constraints</p></a></li>
<li><a href='#Rcpp_CONEC-class'><p>Class <code>"Rcpp_CONEC"</code></p></a></li>
<li><a href='#Rcpp_CPS-class'><p>Class <code>"Rcpp_CPS"</code></p></a></li>
<li><a href='#Rcpp_CTRL-class'><p>Class <code>"Rcpp_CTRL"</code></p></a></li>
<li><a href='#Rcpp_DCP-class'><p>Class <code>"Rcpp_DCP"</code></p></a></li>
<li><a href='#Rcpp_DLP-class'><p>Class <code>"Rcpp_DLP"</code></p></a></li>
<li><a href='#Rcpp_DNL-class'><p>Class <code>"Rcpp_DNL"</code></p></a></li>
<li><a href='#Rcpp_DQP-class'><p>Class <code>"Rcpp_DQP"</code></p></a></li>
<li><a href='#Rcpp_PDV-class'><p>Class <code>"Rcpp_PDV"</code></p></a></li>
<li><a href='#rp'>
<p>Risk-parity optimization</p></a></li>
<li><a href='#socc'>
<p>Definition of second-oder cone inequality constraints</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Version:</td>
<td>0.3-1</td>
</tr>
<tr>
<td>Date:</td>
<td>2023-12-09</td>
</tr>
<tr>
<td>Title:</td>
<td>Cone Constrained Convex Problems</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Bernhard Pfaff &lt;bernhard@pfaffikus.de&gt;</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.0.1), methods</td>
</tr>
<tr>
<td>Suggests:</td>
<td>RUnit, numDeriv</td>
</tr>
<tr>
<td>LazyLoad:</td>
<td>yes</td>
</tr>
<tr>
<td>Description:</td>
<td>Routines for solving convex optimization problems with cone constraints by means of interior-point methods. The implemented algorithms are partially ported from CVXOPT, a Python module for convex optimization (see <a href="https://cvxopt.org">https://cvxopt.org</a> for more information). </td>
</tr>
<tr>
<td>Imports:</td>
<td>Rcpp (&ge; 0.11.2)</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>Rcpp, RcppArmadillo</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL (&ge; 3)</a></td>
</tr>
<tr>
<td>RcppModules:</td>
<td>CPG</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-12-09 17:18:24 UTC; bp</td>
</tr>
<tr>
<td>Author:</td>
<td>Bernhard Pfaff [aut, cre],
  Lieven Vandenberghe [cph] (copyright holder of cvxopt),
  Martin Andersen [cph] (copyright holder of cvxopt),
  Joachim Dahl [cph] (copyright holder of cvxopt)</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-12-09 17:50:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='cccp'>
Solving linear and quadratic programs with cone constraints
</h2><span id='topic+cccp'></span>

<h3>Description</h3>

<p>This function is the main function for defining and solving convex
problems in the form of either linear or quadratic programs with cone
constraints. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cccp(P = NULL, q = NULL, A = NULL, b = NULL, cList = list(),
     x0 = NULL, f0 = NULL, g0 = NULL, h0 = NULL,
     nlfList = list(), nlgList = list(), nlhList = list(),
     optctrl = ctrl())
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="cccp_+3A_p">P</code></td>
<td>
<p>An object of class <code>matrix</code> with dimension <code class="reqn">N \times
      N</code> or <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="cccp_+3A_q">q</code></td>
<td>
<p>An object of class <code>vector</code> with dimension <code class="reqn">N \times
      1</code> or <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="cccp_+3A_a">A</code></td>
<td>
<p>An object of class <code>matrix</code> with dimension <code class="reqn">p \times N</code>.</p>
</td></tr>
<tr><td><code id="cccp_+3A_b">b</code></td>
<td>
<p>An object of class <code>vector</code> with dimension <code class="reqn">p \times 1</code>.</p>
</td></tr>
<tr><td><code id="cccp_+3A_clist">cList</code></td>
<td>
<p>A <code>list</code> object containing the cone constraints.
Elements must be of either S4-class <code>NNOC</code>, or <code>SOCC</code>, or
<code>PSDC</code>.</p>
</td></tr>
<tr><td><code id="cccp_+3A_x0">x0</code></td>
<td>
<p>An object of class <code>vector</code> with dimension <code class="reqn">n
      \times 1</code> for the initial values. The point <code>x0</code> must be in
the domain of the nonlinear constraints.</p>
</td></tr>
<tr><td><code id="cccp_+3A_f0">f0</code></td>
<td>
<p><code>function</code>: the scalar-valued convex and
twice-differentiable objective function (its first argument must be
&lsquo;<code>x</code>&rsquo;).</p>
</td></tr>
<tr><td><code id="cccp_+3A_g0">g0</code></td>
<td>
<p><code>function</code>: the gradient function of the objective (its
first argument must be &lsquo;<code>x</code>&rsquo;).</p>
</td></tr>
<tr><td><code id="cccp_+3A_h0">h0</code></td>
<td>
<p><code>function</code>: the Hessian function of the objective (its
first argument must be &lsquo;<code>x</code>&rsquo;).</p>
</td></tr>
<tr><td><code id="cccp_+3A_nlflist">nlfList</code></td>
<td>
<p>A <code>list</code> object containing the nonlinear
constraints as its elements. The functions have to be specified with
<code>x</code> as their first argument and must be casted in implicit
form, <em>i.e.</em> <code class="reqn">f(x) \le 0</code>.</p>
</td></tr>
<tr><td><code id="cccp_+3A_nlglist">nlgList</code></td>
<td>
<p>A <code>list</code> object containing the gradient functions
as its elements. The functions have to be specified with <code>x</code> as
their first argument.</p>
</td></tr>
<tr><td><code id="cccp_+3A_nlhlist">nlhList</code></td>
<td>
<p>A <code>list</code> object containing the Hessian functions
as its elements. The functions have to be specified with <code>x</code> as
their first argument.</p>
</td></tr>
<tr><td><code id="cccp_+3A_optctrl">optctrl</code></td>
<td>
<p>An object of S4-class <code>Rcpp_CTRL</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <code>Rcpp_CPS</code>. 
</p>

<hr>
<h2 id='CPD-class'>Class <code>"CPD"</code></h2><span id='topic+CPD-class'></span>

<h3>Description</h3>

<p>Class union of <code>Rcpp_DLP</code>, <code>Rcpp_DQP</code>, <code>Rcpp_DCP</code>
and <code>Rcpp_DNL</code>.
</p>


<h3>Objects from the Class</h3>

<p>A virtual Class: No objects may be created from it.</p>


<h3>Methods</h3>

<p>No methods defined with class &quot;CPD&quot; in the signature.
</p>

<hr>
<h2 id='CPG'>
Rcpp module: CPG
</h2><span id='topic+CONEC'></span><span id='topic+CTRL'></span><span id='topic+CPG'></span><span id='topic+PDV'></span><span id='topic+DCP'></span><span id='topic+DLP'></span><span id='topic+DNL'></span><span id='topic+DQP'></span><span id='topic+CPS'></span><span id='topic+rpp'></span><span id='topic+gpp'></span>

<h3>Description</h3>

<p>Module for defining and solving convex programs.
</p>


<h3>Details</h3>

<p>The module contains the following items:
classes: </p>

<dl>
<dt>CONEC</dt><dd><p>Class for inequality (cone) constraints.</p>
</dd>
<dt>CTRL</dt><dd><p>Class for control parameters used in optimizations.</p>
</dd>
<dt>PDV</dt><dd><p>Class for primal/dual variables.</p>
</dd>
<dt>DCP</dt><dd><p>Class for definition of convex programs.</p>
</dd>
<dt>DLP</dt><dd><p>Class for definition of linear programs.</p>
</dd>
<dt>DNL</dt><dd><p>Class for definition of linear programs with non-linear constraints.</p>
</dd>
<dt>DQP</dt><dd><p>Class for definition of quadratic programs.</p>
</dd>
<dt>CPS</dt><dd><p>Class for solution of convex programs.</p>
</dd>
</dl>

<p>functions: </p>

<dl>
<dt>rpp</dt><dd><p>Function for solving risk parity portfolios.</p>
</dd>
<dt>gpp</dt><dd><p>Function for solving a geometric program.</p>
</dd>
</dl>


<hr>
<h2 id='cps'>
Solving a convex program
</h2><span id='topic+cps'></span><span id='topic+cps+2CRcpp_DLP+2CRcpp_CTRL-method'></span><span id='topic+cps+2CRcpp_DNL+2CRcpp_CTRL-method'></span><span id='topic+cps+2CRcpp_DQP+2CRcpp_CTRL-method'></span><span id='topic+cps+2CRcpp_DCP+2CRcpp_CTRL-method'></span>

<h3>Description</h3>

<p>This function returns an optimal point for a cone constraint convex
program. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'Rcpp_DCP,Rcpp_CTRL'
cps(cpd, ctrl)  
## S4 method for signature 'Rcpp_DLP,Rcpp_CTRL'
cps(cpd, ctrl)  
## S4 method for signature 'Rcpp_DNL,Rcpp_CTRL'
cps(cpd, ctrl)  
## S4 method for signature 'Rcpp_DQP,Rcpp_CTRL'
cps(cpd, ctrl)  
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="cps_+3A_cpd">cpd</code></td>
<td>
<p>An object belonging to the class union <code>CPD</code>.</p>
</td></tr>
<tr><td><code id="cps_+3A_ctrl">ctrl</code></td>
<td>
<p>An object of reference-class <code>Rcpp_CTRL</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of reference-class <code>Rcpp_CPS</code>. 
</p>

<hr>
<h2 id='ctrl'>
Creating objects of reference-class CTRL
</h2><span id='topic+ctrl'></span>

<h3>Description</h3>

<p>This function creates an object of reference-class <code>CTRL</code> which
contains optimization parameters, <em>e.g.</em> the maximum number of
iterations. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ctrl(maxiters = 100L, abstol = 1e-06, reltol = 1e-06,
     feastol = 1e-06, stepadj = 0.95, beta = 0.5, trace = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ctrl_+3A_maxiters">maxiters</code></td>
<td>
<p><code>integer</code>, the maximum count of iterations.</p>
</td></tr>
<tr><td><code id="ctrl_+3A_abstol">abstol</code></td>
<td>
<p><code>numeric</code>, the absolute level for convergence to be
achieved.</p>
</td></tr>
<tr><td><code id="ctrl_+3A_reltol">reltol</code></td>
<td>
<p><code>numeric</code>, the relative level for convergence to be
achieved.</p>
</td></tr>
<tr><td><code id="ctrl_+3A_feastol">feastol</code></td>
<td>
<p><code>numeric</code>, the feasable level for convergence to be
achieved.</p>
</td></tr>
<tr><td><code id="ctrl_+3A_stepadj">stepadj</code></td>
<td>
<p><code>numeric</code>, step size adjustment in combined step.</p>
</td></tr>
<tr><td><code id="ctrl_+3A_beta">beta</code></td>
<td>
<p><code>numeric</code>, parameter in backtracking line search.</p>
</td></tr>
<tr><td><code id="ctrl_+3A_trace">trace</code></td>
<td>
<p><code>logical</code>, if <code>TRUE</code> (the default), the
solver's progress during the iterations is shown.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of reference-class <code>CTRL</code>.
</p>


<h3>Note</h3>

<p>Either <code>abstol</code> or <code>reltol</code> can be set to a negative real
number. <code>feastol</code> must be greater than zero.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+Rcpp_CTRL-class">Rcpp_CTRL</a></code>
</p>

<hr>
<h2 id='dcp'>
Creating a member object of the reference-class <code>DCP</code>
</h2><span id='topic+dcp'></span>

<h3>Description</h3>

<p>This function returns an object containing the definition of a convex
program with non-linear constraints and (if provided) cone
constraints. 
The returned object is a member of the reference-class <code>DCP</code>. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dcp(x0, f0, g0, h0, cList = list(), nlfList = list(), nlgList = list(),
    nlhList = list(), A = NULL, b = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="dcp_+3A_x0">x0</code></td>
<td>
<p>An object of class <code>vector</code> with dimension <code class="reqn">n
      \times 1</code> for the initial values. The point <code>x0</code> must be in
the domain of the nonlinear constraints.</p>
</td></tr>
<tr><td><code id="dcp_+3A_f0">f0</code></td>
<td>
<p><code>function</code>: the scalar-valued convex and
twice-differentiable objective function (its first argument must be
&lsquo;<code>x</code>&rsquo;).</p>
</td></tr>
<tr><td><code id="dcp_+3A_g0">g0</code></td>
<td>
<p><code>function</code>: the gradient function of the objective (its
first argument must be &lsquo;<code>x</code>&rsquo;); returning a vector.</p>
</td></tr>
<tr><td><code id="dcp_+3A_h0">h0</code></td>
<td>
<p><code>function</code>: the Hessian function of the objective (its
first argument must be &lsquo;<code>x</code>&rsquo;); returning a matrix.</p>
</td></tr>
<tr><td><code id="dcp_+3A_clist">cList</code></td>
<td>
<p>A <code>list</code> object containing the cone
constraints. Elements must be of either S4-class <code>NNOC</code>, or
<code>SOCC</code>, or <code>PSDC</code> or an empty list in case of no
inequality constraints.</p>
</td></tr> 
<tr><td><code id="dcp_+3A_nlflist">nlfList</code></td>
<td>
<p>A <code>list</code> object containing the nonlinear
constraints as its elements. The functions have to be specified with
<code>x</code> as their first argument and must be casted in implicit
form, <em>i.e.</em> <code class="reqn">f(x) \le 0</code>.</p>
</td></tr>
<tr><td><code id="dcp_+3A_nlglist">nlgList</code></td>
<td>
<p>A <code>list</code> object containing the gradient functions
as its elements. The functions have to be specified with <code>x</code> as
their first argument.</p>
</td></tr>
<tr><td><code id="dcp_+3A_nlhlist">nlhList</code></td>
<td>
<p>A <code>list</code> object containing the Hessian functions
as its elements. The functions have to be specified with <code>x</code> as
their first argument.</p>
</td></tr>
<tr><td><code id="dcp_+3A_a">A</code></td>
<td>
<p>An object of class <code>matrix</code> with dimension <code class="reqn">p \times
      n</code> or <code>NULL</code> for problems without equality constraints.</p>
</td></tr>
<tr><td><code id="dcp_+3A_b">b</code></td>
<td>
<p>An object of class <code>vector</code> with dimension <code class="reqn">p \times
      1</code> or <code>NULL</code> for problems without equality constraints.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object belonging to the reference-class <code>DCP</code>. 
</p>

<hr>
<h2 id='dlp'>
Creating a member object of the reference-class <code>DLP</code>
</h2><span id='topic+dlp'></span>

<h3>Description</h3>

<p>This function returns an object containing the definition of a cone
constrained linear program. The returned object is a member of the
reference-class <code>DLP</code>. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dlp(q, A = NULL, b = NULL, cList = list())
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="dlp_+3A_q">q</code></td>
<td>
<p>An object of class <code>vector</code> with dimension <code class="reqn">n \times 1</code>.</p>
</td></tr>
<tr><td><code id="dlp_+3A_a">A</code></td>
<td>
<p>An object of class <code>matrix</code> with dimension <code class="reqn">p \times
      n</code> or <code>NULL</code> for problems without equality constraints.</p>
</td></tr>
<tr><td><code id="dlp_+3A_b">b</code></td>
<td>
<p>An object of class <code>vector</code> with dimension <code class="reqn">p \times
      1</code> or <code>NULL</code> for problems without equality constraints.</p>
</td></tr>
<tr><td><code id="dlp_+3A_clist">cList</code></td>
<td>
<p>A <code>list</code> object containing the cone
constraints. Elements must be of either reference-class <code>NNOC</code>, or
<code>SOCC</code>, or <code>PSDC</code> or an empty list in case of no
inequality constraints.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object belonging to the reference-class <code>DLP</code>. 
</p>

<hr>
<h2 id='dnl'>
Creating a member object of the reference-class <code>DNL</code>
</h2><span id='topic+dnl'></span>

<h3>Description</h3>

<p>This function returns an object containing the definition of a linear
program with non-linear constraints and (if provided) cone
constraints. 
The returned object is a member of the reference-class <code>DNL</code>. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dnl(q, A = NULL, b = NULL, cList = list(),
    x0, nlfList = list(), nlgList = list(), nlhList = list())
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="dnl_+3A_q">q</code></td>
<td>
<p><code>vector</code> of length <code class="reqn">n</code> for the coefficients in the
objective.</p>
</td></tr>
<tr><td><code id="dnl_+3A_a">A</code></td>
<td>
<p>An object of class <code>matrix</code> with dimension <code class="reqn">p \times
      n</code> or <code>NULL</code> for problems without equality constraints.</p>
</td></tr>
<tr><td><code id="dnl_+3A_b">b</code></td>
<td>
<p>An object of class <code>vector</code> with dimension <code class="reqn">p \times
      1</code> or <code>NULL</code> for problems without equality constraints.</p>
</td></tr>
<tr><td><code id="dnl_+3A_clist">cList</code></td>
<td>
<p>A <code>list</code> object containing the cone
constraints. Elements must be of either S4-class <code>NNOC</code>, or
<code>SOCC</code>, or <code>PSDC</code> or an empty list in case of no
inequality constraints.</p>
</td></tr>
<tr><td><code id="dnl_+3A_x0">x0</code></td>
<td>
<p>An object of class <code>vector</code> with dimension <code class="reqn">n
      \times 1</code> for the initial values. The point <code>x0</code> must be in
the domain of the nonlinear constraints.</p>
</td></tr>
<tr><td><code id="dnl_+3A_nlflist">nlfList</code></td>
<td>
<p>A <code>list</code> object containing the nonlinear
constraints as its elements. The functions have to be specified with
<code>x</code> as their first argument and must be casted in implicit
form, <em>i.e.</em> <code class="reqn">f(x) \le 0</code>.</p>
</td></tr>
<tr><td><code id="dnl_+3A_nlglist">nlgList</code></td>
<td>
<p>A <code>list</code> object containing the gradient functions
as its elements. The functions have to be specified with <code>x</code> as
their first argument.</p>
</td></tr>
<tr><td><code id="dnl_+3A_nlhlist">nlhList</code></td>
<td>
<p>A <code>list</code> object containing the Hessian functions
as its elements. The functions have to be specified with <code>x</code> as
their first argument.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object belonging to the reference-class <code>DNL</code>. 
</p>

<hr>
<h2 id='dqp'>
Creating a member object of the reference-class <code>DQP</code>
</h2><span id='topic+dqp'></span>

<h3>Description</h3>

<p>This function returns an object containing the definition of a cone
constrained quadratic program. The returned object is a member of the
reference-class <code>DQP</code>. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dqp(P, q, A = NULL, b = NULL, cList = list())
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="dqp_+3A_p">P</code></td>
<td>
<p>An object of class <code>matrix</code> with dimension <code class="reqn">n \times n</code>.</p>
</td></tr>
<tr><td><code id="dqp_+3A_q">q</code></td>
<td>
<p>An object of class <code>vector</code> with dimension <code class="reqn">n \times 1</code>.</p>
</td></tr>
<tr><td><code id="dqp_+3A_a">A</code></td>
<td>
<p>An object of class <code>matrix</code> with dimension <code class="reqn">p \times
      n</code> or <code>NULL</code> for problems without equality constraints.</p>
</td></tr>
<tr><td><code id="dqp_+3A_b">b</code></td>
<td>
<p>An object of class <code>vector</code> with dimension <code class="reqn">p \times
      1</code> or <code>NULL</code> for problems without equality constraints.</p>
</td></tr>
<tr><td><code id="dqp_+3A_clist">cList</code></td>
<td>
<p>A <code>list</code> object containing the cone
constraints. Elements must be of either reference-class <code>NNOC</code>, or
<code>SOCC</code>, or <code>PSDC</code> or an empty list in case of no
inequality constraints.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object belonging to the reference-class <code>DQP</code>. 
</p>

<hr>
<h2 id='getFoo'>
Extractor methods for reference class objects
</h2><span id='topic+gets'></span><span id='topic+gets+2CRcpp_PDV-method'></span><span id='topic+gets+2CRcpp_CPS-method'></span><span id='topic+getx'></span><span id='topic+getx+2CRcpp_PDV-method'></span><span id='topic+getx+2CRcpp_CPS-method'></span><span id='topic+gety'></span><span id='topic+gety+2CRcpp_PDV-method'></span><span id='topic+gety+2CRcpp_CPS-method'></span><span id='topic+getz'></span><span id='topic+getz+2CRcpp_PDV-method'></span><span id='topic+getz+2CRcpp_CPS-method'></span><span id='topic+getstate'></span><span id='topic+getstate+2CRcpp_CPS-method'></span><span id='topic+getstatus'></span><span id='topic+getstatus+2CRcpp_CPS-method'></span><span id='topic+getniter'></span><span id='topic+getniter+2CRcpp_CPS-method'></span><span id='topic+getparams'></span><span id='topic+getparams+2CRcpp_CTRL-method'></span>

<h3>Description</h3>

<p>Returns a member of reference class objects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'Rcpp_PDV'
getx(object)  
## S4 method for signature 'Rcpp_CPS'
getx(object)  
## S4 method for signature 'Rcpp_PDV'
gety(object)  
## S4 method for signature 'Rcpp_CPS'
gety(object)  
## S4 method for signature 'Rcpp_PDV'
gets(object)  
## S4 method for signature 'Rcpp_CPS'
gets(object)  
## S4 method for signature 'Rcpp_PDV'
getz(object)  
## S4 method for signature 'Rcpp_CPS'
getz(object)  
## S4 method for signature 'Rcpp_CPS'
getstate(object)  
## S4 method for signature 'Rcpp_CPS'
getstatus(object)  
## S4 method for signature 'Rcpp_CPS'
getniter(object)  
## S4 method for signature 'Rcpp_CTRL'
getparams(object)  
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="getFoo_+3A_object">object</code></td>
<td>
<p>An object of either reference-class <code>Rcpp_PDV</code> or
<code>Rcpp_CPS</code>, or <code>Rcpp_CTRL</code>.</p>
</td></tr> 
</table>


<h3>Value</h3>

<p>The relevant member object of the class.
</p>

<hr>
<h2 id='gp'>
Geometric program
</h2><span id='topic+gp'></span>

<h3>Description</h3>

<p>This function solves a geometric program.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gp(F0, g0, FList = list(), gList = list(), nno = NULL,
   A = NULL, b = NULL, optctrl = ctrl())
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="gp_+3A_f0">F0</code></td>
<td>
<p>Matrix in the objective function.</p>
</td></tr>
<tr><td><code id="gp_+3A_g0">g0</code></td>
<td>
<p>Matrix in the objective function (affine terms).</p>
</td></tr>
<tr><td><code id="gp_+3A_flist">FList</code></td>
<td>
<p>List of matrices in posinomial functions.</p>
</td></tr>
<tr><td><code id="gp_+3A_glist">gList</code></td>
<td>
<p>List of matrices in posinomial functions (affine terms).</p>
</td></tr>
<tr><td><code id="gp_+3A_nno">nno</code></td>
<td>
<p>Object created by a call to <code>nnoc()</code>.</p>
</td></tr>
<tr><td><code id="gp_+3A_a">A</code></td>
<td>
<p>Lefthand-side matrix of equality constraints.</p>
</td></tr>
<tr><td><code id="gp_+3A_b">b</code></td>
<td>
<p>Lefthand-side matrix of equality constraints.</p>
</td></tr>
<tr><td><code id="gp_+3A_optctrl">optctrl</code></td>
<td>
<p>Object of reference class &lsquo;Rcpp_CTRL&rsquo;, created
by a call to <code>ctrl()</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Solves a geometric program casted in its epigraph form.
</p>


<h3>Value</h3>

<p>An object of S4-class <code>Rcpp_CPS</code>.
</p>


<h3>References</h3>

<p>Boyd, S., Kim, S.-J., Vandenberghe, L. and A. Hassibi (2007), A tutorial on
geometric programming, <em>Optim Eng</em>, Educational Section,
<b>8</b>:67&ndash;127, Springer. 
</p>

<hr>
<h2 id='l1'>
Minimizing L1-norm
</h2><span id='topic+l1'></span>

<h3>Description</h3>

<p>This function minimizes a L1-norm of the form <code class="reqn">||P u - q||_1</code>,
whereby <code class="reqn">P</code> is a <code class="reqn">(m \times n)</code> matrix and <code class="reqn">q</code> is a <code class="reqn">m
  \times 1</code> vector. This function is wrapper function for invoking the 
<code>cps</code>-method of Linear Programs.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>l1(P, q = NULL, optctrl = ctrl())
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="l1_+3A_p">P</code></td>
<td>
<p><code>matrix</code> of dimension <code class="reqn">m \times n</code>.</p>
</td></tr>
<tr><td><code id="l1_+3A_q">q</code></td>
<td>
<p><code>vector</code> of length <code class="reqn">m</code>.</p>
</td></tr>
<tr><td><code id="l1_+3A_optctrl">optctrl</code></td>
<td>
<p>An object of S4-class <code>Rcpp_CTRL</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of S4-class <code>Rcpp_CPS</code>.
</p>

<hr>
<h2 id='nlfc'>
Definition of nonlinear inequality constraints
</h2><span id='topic+nlfc'></span>

<h3>Description</h3>

<p>This function is the interface to the reference class <code>NLFC</code> for
creating nonlinear constraints.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>nlfc(G, h)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="nlfc_+3A_g">G</code></td>
<td>
<p>Object of class <code>"matrix"</code>: A <code class="reqn">(m \times n)</code> matrix
containing the coefficients of the lefthand-side linear inequality
constraints.</p>
</td></tr> 
<tr><td><code id="nlfc_+3A_h">h</code></td>
<td>
<p>Object of class <code>NLFV</code>: A <code class="reqn">(m \times 1)</code> vector
containing the coefficients of the righthand-side linear inequality
constraints as slot <code>u</code>. 
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>List with elements: <code>conType</code>, <code>G</code> and <code>h</code>.
</p>

<hr>
<h2 id='nnoc'>
Definition of linear inequality constraints
</h2><span id='topic+nnoc'></span>

<h3>Description</h3>

<p>This function is the interface to the reference class <code>NNOC</code> for
creating linear constraints.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>nnoc(G, h)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="nnoc_+3A_g">G</code></td>
<td>
<p>Object of class <code>"matrix"</code>: A <code class="reqn">(m \times n)</code> matrix
containing the coefficients of the lefthand-side linear inequality
constraints.</p>
</td></tr> 
<tr><td><code id="nnoc_+3A_h">h</code></td>
<td>
<p>Object of class <code>NNOV</code>: A <code class="reqn">(m \times 1)</code> vector
containing the coefficients of the righthand-side linear inequality
constraints as slot <code>u</code>. 
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>List with elements: <code>conType</code>, <code>G</code> and <code>h</code>.
</p>

<hr>
<h2 id='psdc'>
Definition of positive semidefinite cone inequality constraints
</h2><span id='topic+psdc'></span>

<h3>Description</h3>

<p>This function is the interface to the reference class <code>PSDC</code> for
creating positive semidefinite cone constraints.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>psdc(Flist, F0)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="psdc_+3A_flist">Flist</code></td>
<td>
<p>Object of class <code>"list"</code>: A list with the matrices
appearing on the left-hand side of the matrix inequality.</p>
</td></tr> 
<tr><td><code id="psdc_+3A_f0">F0</code></td>
<td>
<p>Object of class <code>"matrix"</code>: The matrix appearing on the
righthand-side.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A psd-cone constraint is given as <code class="reqn">\sum_{i = 1}^n x_i F_i \le
  F_0</code>. The matrix <code class="reqn">G</code> is created as <code class="reqn">G = [\textrm{vech}(F_1) |
  \ldots | \textrm{vech}(F_n)]</code> and the vector <code class="reqn">h</code> is constructed as
<code class="reqn">h = [\textrm{vech}(F_0)]</code>.  
</p>


<h3>Value</h3>

<p>List with elements: <code>conType</code>, <code>G</code> and <code>h</code>.
</p>

<hr>
<h2 id='Rcpp_CONEC-class'>Class <code>"Rcpp_CONEC"</code></h2><span id='topic+Rcpp_CONEC-class'></span>

<h3>Description</h3>

<p>Class for inequality (cone) constraints.
</p>


<h3>Extends</h3>

<p>Class <code>"C++Object"</code>, directly.
All reference classes extend and inherit methods from <code>"<a href="methods.html#topic+envRefClass-class">envRefClass</a>"</code>.
</p>


<h3>Fields</h3>


<dl>
<dt><code>cone</code>:</dt><dd><p>Object of class <code>activeBindingFunction</code>:
Type of cone constraints.</p>
</dd>
<dt><code>G</code>:</dt><dd><p>Object of class <code>activeBindingFunction</code>:
Left-hand side of inequality constraints.</p>
</dd>
<dt><code>h</code>:</dt><dd><p>Object of class <code>activeBindingFunction</code>:
Right-hand side of inequality constraints.</p>
</dd>
<dt><code>sidx</code>:</dt><dd><p>Object of class <code>activeBindingFunction</code>:
Row index for subsets of cone constraints.</p>
</dd>
<dt><code>dims</code>:</dt><dd><p>Object of class <code>activeBindingFunction</code>:
Dimension of cone constraints.</p>
</dd>  
<dt><code>K</code>:</dt><dd><p>Object of class <code>activeBindingFunction</code>: Count
of inequality constraints.</p>
</dd>  
<dt><code>n</code>:</dt><dd><p>Object of class <code>activeBindingFunction</code>: Count
of variables in objective.</p>
</dd>  
</dl>



<h3>Examples</h3>

<pre><code class='language-R'>showClass("Rcpp_CONEC")
</code></pre>

<hr>
<h2 id='Rcpp_CPS-class'>Class <code>"Rcpp_CPS"</code></h2><span id='topic+Rcpp_CPS-class'></span>

<h3>Description</h3>

<p>Class for solution of convex programs.
</p>


<h3>Extends</h3>

<p>Class <code>"C++Object"</code>, directly.
All reference classes extend and inherit methods from <code>"<a href="methods.html#topic+envRefClass-class">envRefClass</a>"</code>.
</p>


<h3>Fields</h3>


<dl>
<dt><code>pdv</code>:</dt><dd><p>Object of class <code>activeBindingFunction</code>:
Primal-dual variables.</p>
</dd>
<dt><code>state</code>:</dt><dd><p>Object of class <code>activeBindingFunction</code>:
Vector of state variables in convex programs.</p>
</dd>
<dt><code>status</code>:</dt><dd><p>Object of class <code>activeBindingFunction</code>:
Character indicating the status of the returned solution.</p>
</dd>
<dt><code>niter</code>:</dt><dd><p>Object of class <code>activeBindingFunction</code>:
Integer, count of iterations.</p>
</dd>
<dt><code>sidx</code>:</dt><dd><p>Object of class <code>activeBindingFunction</code>:
Integer matrix, start and end indices of slack variables.</p>
</dd>
</dl>



<h3>Examples</h3>

<pre><code class='language-R'>showClass("Rcpp_CPS")
</code></pre>

<hr>
<h2 id='Rcpp_CTRL-class'>Class <code>"Rcpp_CTRL"</code></h2><span id='topic+Rcpp_CTRL-class'></span>

<h3>Description</h3>

<p>Class for control options used in optimization routines.
</p>


<h3>Extends</h3>

<p>Class <code>"C++Object"</code>, directly.
All reference classes extend and inherit methods from <code>"<a href="methods.html#topic+envRefClass-class">envRefClass</a>"</code>.
</p>


<h3>Fields</h3>


<dl>
<dt><code>ctrlparams</code>:</dt><dd><p>Object of class
<code>activeBindingFunction</code>: List of control parameters.</p>
</dd>
</dl>



<h3>Examples</h3>

<pre><code class='language-R'>showClass("Rcpp_CTRL")
</code></pre>

<hr>
<h2 id='Rcpp_DCP-class'>Class <code>"Rcpp_DCP"</code></h2><span id='topic+Rcpp_DCP-class'></span>

<h3>Description</h3>

<p>Class for definition of convex programs with non-linear constraints.
</p>


<h3>Extends</h3>

<p>Class <code>"C++Object"</code>, directly.
All reference classes extend and inherit methods from <code>"<a href="methods.html#topic+envRefClass-class">envRefClass</a>"</code>.
</p>


<h3>Fields</h3>


<dl>
<dt><code>x0</code>:</dt><dd><p>Object of class <code>activeBindingFunction</code>:
Initial values.</p>
</dd>
<dt><code>cList</code>:</dt><dd><p>Object of class <code>activeBindingFunction</code>:
Inequality constraints, class <code>CONEC</code>.</p>
</dd>
<dt><code>nList</code>:</dt><dd><p>Object of class <code>activeBindingFunction</code>:
List with elements of functions for evaluating non-linear
constraints, their associated gradients and their associated
Hessians.</p>
</dd>
<dt><code>A</code>:</dt><dd><p>Object of class <code>activeBindingFunction</code>:
Left-hand side of equality cosntraints.</p>
</dd>
<dt><code>b</code>:</dt><dd><p>Object of class <code>activeBindingFunction</code>:
Right-hand side of equality cosntraints.</p>
</dd>
</dl>



<h3>Examples</h3>

<pre><code class='language-R'>showClass("Rcpp_DCP")
</code></pre>

<hr>
<h2 id='Rcpp_DLP-class'>Class <code>"Rcpp_DLP"</code></h2><span id='topic+Rcpp_DLP-class'></span>

<h3>Description</h3>

<p>Class for definition of linear programs.
</p>


<h3>Extends</h3>

<p>Class <code>"C++Object"</code>, directly.
All reference classes extend and inherit methods from <code>"<a href="methods.html#topic+envRefClass-class">envRefClass</a>"</code>.
</p>


<h3>Fields</h3>


<dl>
<dt><code>q</code>:</dt><dd><p>Object of class <code>activeBindingFunction</code>:
Matrix related to linear term in objective.</p>
</dd>
<dt><code>A</code>:</dt><dd><p>Object of class <code>activeBindingFunction</code>:
Left-hand side of equality cosntraints.</p>
</dd>
<dt><code>b</code>:</dt><dd><p>Object of class <code>activeBindingFunction</code>:
Right-hand side of equality cosntraints.</p>
</dd>
<dt><code>cList</code>:</dt><dd><p>Object of class <code>activeBindingFunction</code>:
Inequality constraints, class <code>CONEC</code>.</p>
</dd>
</dl>



<h3>Examples</h3>

<pre><code class='language-R'>showClass("Rcpp_DLP")
</code></pre>

<hr>
<h2 id='Rcpp_DNL-class'>Class <code>"Rcpp_DNL"</code></h2><span id='topic+Rcpp_DNL-class'></span>

<h3>Description</h3>

<p>Class for definition of linear programs with non-linear constraints.
</p>


<h3>Extends</h3>

<p>Class <code>"C++Object"</code>, directly.
All reference classes extend and inherit methods from <code>"<a href="methods.html#topic+envRefClass-class">envRefClass</a>"</code>.
</p>


<h3>Fields</h3>


<dl>
<dt><code>q</code>:</dt><dd><p>Object of class <code>activeBindingFunction</code>:
Matrix related to linear term in objective.</p>
</dd>
<dt><code>A</code>:</dt><dd><p>Object of class <code>activeBindingFunction</code>:
Left-hand side of equality cosntraints.</p>
</dd>
<dt><code>b</code>:</dt><dd><p>Object of class <code>activeBindingFunction</code>:
Right-hand side of equality cosntraints.</p>
</dd>
<dt><code>cList</code>:</dt><dd><p>Object of class <code>activeBindingFunction</code>:
Inequality constraints, class <code>CONEC</code>.</p>
</dd>
<dt><code>x0</code>:</dt><dd><p>Object of class <code>activeBindingFunction</code>:
Initial values.</p>
</dd>
<dt><code>nList</code>:</dt><dd><p>Object of class <code>activeBindingFunction</code>:
List with elements of functions for evaluating non-linear
constraints, their associated gradients and their associated
Hessians.</p>
</dd>
</dl>



<h3>Examples</h3>

<pre><code class='language-R'>showClass("Rcpp_DNL")
</code></pre>

<hr>
<h2 id='Rcpp_DQP-class'>Class <code>"Rcpp_DQP"</code></h2><span id='topic+Rcpp_DQP-class'></span>

<h3>Description</h3>

<p>Class for definition of quadratic programs.
</p>


<h3>Extends</h3>

<p>Class <code>"C++Object"</code>, directly.
All reference classes extend and inherit methods from <code>"<a href="methods.html#topic+envRefClass-class">envRefClass</a>"</code>.
</p>


<h3>Fields</h3>


<dl>
<dt><code>P</code>:</dt><dd><p>Object of class <code>activeBindingFunction</code>:
Matrix related to quadratic term in objective.</p>
</dd>
<dt><code>q</code>:</dt><dd><p>Object of class <code>activeBindingFunction</code>:
Matrix related to linear term in objective.</p>
</dd>
<dt><code>A</code>:</dt><dd><p>Object of class <code>activeBindingFunction</code>:
Left-hand side of equality cosntraints.</p>
</dd>
<dt><code>b</code>:</dt><dd><p>Object of class <code>activeBindingFunction</code>:
Right-hand side of equality cosntraints.</p>
</dd>
<dt><code>cList</code>:</dt><dd><p>Object of class <code>activeBindingFunction</code>:
Inequality constraints, class <code>CONEC</code>.</p>
</dd>
</dl>



<h3>Examples</h3>

<pre><code class='language-R'>showClass("Rcpp_DQP")
</code></pre>

<hr>
<h2 id='Rcpp_PDV-class'>Class <code>"Rcpp_PDV"</code></h2><span id='topic+Rcpp_PDV-class'></span>

<h3>Description</h3>

<p>Class for primal/dual variables in convex programs.
</p>


<h3>Extends</h3>

<p>Class <code>"C++Object"</code>, directly.
All reference classes extend and inherit methods from <code>"<a href="methods.html#topic+envRefClass-class">envRefClass</a>"</code>.
</p>


<h3>Fields</h3>


<dl>
<dt><code>x</code>:</dt><dd><p>Object of class <code>activeBindingFunction</code>:
Primal variables.</p>
</dd> 
<dt><code>y</code>:</dt><dd><p>Object of class <code>activeBindingFunction</code>: Dual
variables.</p>
</dd>
<dt><code>s</code>:</dt><dd><p>Object of class <code>activeBindingFunction</code>:
Primal slack variables.</p>
</dd>
<dt><code>z</code>:</dt><dd><p>Object of class <code>activeBindingFunction</code>: Dual
slack variables.</p>
</dd>
<dt><code>kappa</code>:</dt><dd><p>Object of class <code>activeBindingFunction</code>:
Self-dual embedding variable; used in LPs, only.</p>
</dd>
<dt><code>tau</code>:</dt><dd><p>Object of class <code>activeBindingFunction</code>:
Self-dual embedding variable; used in LPs, only.</p>
</dd>
</dl>



<h3>Examples</h3>

<pre><code class='language-R'>showClass("Rcpp_PDV")
</code></pre>

<hr>
<h2 id='rp'>
Risk-parity optimization
</h2><span id='topic+rp'></span>

<h3>Description</h3>

<p>This function determines a risk-parity solution of a long-only
portfolio with a budget-constraint.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rp(x0, P, mrc, optctrl = ctrl())
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="rp_+3A_x0">x0</code></td>
<td>
<p><code>matrix</code> of dimension <code class="reqn">n \times 1</code>; starting values.</p>
</td></tr>
<tr><td><code id="rp_+3A_p">P</code></td>
<td>
<p><code>matrix</code> of dimension <code class="reqn">n \times n</code>; dispersion matrix.</p>
</td></tr>
<tr><td><code id="rp_+3A_mrc">mrc</code></td>
<td>
<p><code>matrix</code> of dimension <code class="reqn">n \times 1</code>; the marginal
risk contributions.</p>
</td></tr>
<tr><td><code id="rp_+3A_optctrl">optctrl</code></td>
<td>
<p>An object of S4-class <code>Rcpp_CTRL</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of S4-class <code>Rcpp_CPS</code>.
</p>


<h3>References</h3>

<p>Spinu, F. (2013), An Algorithm for Computing Risk Parity Weights,
SSRN, <em>OMERS Capital Markets</em>, July 2013.
</p>

<hr>
<h2 id='socc'>
Definition of second-oder cone inequality constraints
</h2><span id='topic+socc'></span>

<h3>Description</h3>

<p>This function is the interface to the reference class <code>SOCC</code> for
creating second-oder cone constraints.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>socc(F, g, d, f)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="socc_+3A_f">F</code></td>
<td>
<p>Object of class <code>"matrix"</code>: The matrix appearing in the
norm-expression on the left-hand side of a second-order cone constraint.</p>
</td></tr> 
<tr><td><code id="socc_+3A_g">g</code></td>
<td>
<p>Object of class <code>"numeric"</code>: The vector appearing in the
norm-expression on the left-hand side of a second-order cone constraint.</p>
</td></tr>
<tr><td><code id="socc_+3A_d">d</code></td>
<td>
<p>Object of class <code>"numeric"</code>: The vector appearing on the
right-hand side of a second-order cone constraint.</p>
</td></tr> 
<tr><td><code id="socc_+3A_f">f</code></td>
<td>
<p>Object of class <code>"numeric"</code>: The scalar appearing on the
right-hand side of a second-order cone constraint.</p>
</td></tr> 
</table>


<h3>Details</h3>

<p>A second-order cone constraint is given as <code class="reqn">|| Fx + g ||_2 \le d'x
  + f</code>. The matrix <code class="reqn">G</code> is created as <code class="reqn">G = [-d, -F]</code> and the
vector <code class="reqn">h</code> is constructed as <code class="reqn">h = [f, g]</code>. 
</p>


<h3>Value</h3>

<p>List with elements: <code>conType</code>, <code>G</code> and <code>h</code>.
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
