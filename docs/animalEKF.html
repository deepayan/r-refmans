<!DOCTYPE html><html><head><title>Help for package animalEKF</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {animalEKF}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#animalEKF-package'>
<p>Extended Kalman Filters for Animal Movement</p></a></li>
<li><a href='#bc_longlat_map'>
<p>Image of Bolsa Chica for use with <code>shark_vis_longlat</code></p></a></li>
<li><a href='#bc_longlat_map_img_ras'>
<p>Raster image of Bolsa Chica for use with <code>shark_vis_longlat</code></p></a></li>
<li><a href='#cdlm_robot'>
<p>Shiny app for 1D simulation of robot movement with CDLM.</p></a></li>
<li><a href='#cdlm_robot_twostate'>
<p>Shiny app for simulation of 1D robot movement with CDLM and two states.</p></a></li>
<li><a href='#cdlm_robot_twostate_2D'>
<p>Shiny app for simulation of 2D robot movement with CDLM and two states.</p></a></li>
<li><a href='#EKF_1d_interp_joint'>
<p>Extended Kalman Filter (EKF) for 1-D movement with interpolation</p></a></li>
<li><a href='#EKF_interp_joint'>
<p>Extended Kalman Filter (EKF) for joint shark movement with interpolation</p></a></li>
<li><a href='#low_var_sample'>
<p>Sample particles using low-variance sampling.</p></a></li>
<li><a href='#make_segments'>
<p>Plot path connecting points on ggplot.</p></a></li>
<li><a href='#normalize_angle'>
<p>Wrap angle measurements to the interval (-pi, pi).</p></a></li>
<li><a href='#rug_multicolor'>
<p>Multicolor rug of tick marks.</p></a></li>
<li><a href='#shark_data_longlat'>
<p>Raw shark data spline-interpolated to 90-second intervals</p></a></li>
<li><a href='#shark_data_raw'>
<p>Original shark data</p></a></li>
<li><a href='#shark_vis_longlat'>
<p>Shiny app for visualizing observed shark movement.</p></a></li>
<li><a href='#sim_trajectory_joint'>
<p>Simulation and interpolation of trajectories.</p></a></li>
<li><a href='#spline_interp'>
<p>Bezier spline interpolation of observations.</p></a></li>
<li><a href='#tess2spat'>
<p>Convert Voronoi tessellation tiles to a shapefile.</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Extended Kalman Filters for Animal Movement</td>
</tr>
<tr>
<td>Version:</td>
<td>1.2</td>
</tr>
<tr>
<td>Date:</td>
<td>2023-09-09</td>
</tr>
<tr>
<td>Author:</td>
<td>Samuel Ackerman</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Samuel Ackerman &lt;smackrmn@gmail.com&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Synthetic generation of 1-D and 2-D correlated random walks (CRWs) for animal movement with behavioral switching, and particle filter estimation of movement parameters from observed trajectories using Extended Kalman Filter (EKF) model. See Ackerman (2018) <a href="https://digital.library.temple.edu/digital/collection/p245801coll10/id/499150">https://digital.library.temple.edu/digital/collection/p245801coll10/id/499150</a>.</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.3.0), shiny, sp, sf</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>Imports:</td>
<td>MCMCpack, ellipse, mvtnorm, deldir, colorspace, Matrix, MASS,
png, grDevices, bezier, HDInterval, plyr, stats, methods,
utils, ggplot2, rlang</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-09-29 04:35:32 UTC; Sam Ackerman</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-09-29 15:32:41 UTC</td>
</tr>
</table>
<hr>
<h2 id='animalEKF-package'>
Extended Kalman Filters for Animal Movement
</h2><span id='topic+animalEKF-package'></span><span id='topic+animalEKF'></span>

<h3>Description</h3>

<p>Synthetic generation of 1-D and 2-D correlated random walks (CRWs)
for animal movement with behavioral switching, and particle filter estimation
of movement parameters from observed trajectories using Extended Kalman Filter (EKF) model.
See Ackerman (2018)<br /> <a href="https://digital.library.temple.edu/digital/collection/p245801coll10/id/499150">https://digital.library.temple.edu/digital/collection/p245801coll10/id/499150</a>.
</p>


<h3>Note</h3>

<p>I am indebted to Dr. Mario Espinoza and co-authors for providing the shark observation data that inspired this work, and for allowing it to be included in this package.  I am
especially grateful to Dr. Espinoza for many discussions regarding the nuances of modeling animal movement, particularly for suggesting the idea of behavioral switching models.
</p>
<p>I am grateful to my doctoral thesis advisors, Dr. Marc Sobel, Dr. Richard Heiberger, and Dr. Mike O'Connor for supervising my research in this topic.  I am particularly grateful to 
Dr. Heiberger for his many hours in advising me on package design and on the <code>shiny</code> simulations in this package. 
</p>


<h3>References</h3>

<p>Ackerman, Samuel.  &quot;A Probabilistic Characterization of Shark Movement Using Location Tracking Data.&quot;  Temple University doctoral thesis, 2018.  <a href="https://digital.library.temple.edu/digital/collection/p245801coll10/id/499150">https://digital.library.temple.edu/digital/collection/p245801coll10/id/499150</a>
</p>
<p>Carvalho, Carlos M., Johannes, Michael S., Lopes, Hedibert F., and Nicholas G. Polson.  &quot;Particle Learning and Smoothing.&quot;  Statistical Science, 2010.
</p>
<p>Espinoza, Mario, Farrugia, Thomas J., Lowe, Christopher G.  &quot;Habitat Use, Movements and Site Fidelity of the Gray Smooth-Hound Shark in a Newly Restored Southern California Estuary.&quot; Journal of Experimental Marine Biology and Ecology, 2011.
</p>

<hr>
<h2 id='bc_longlat_map'>
Image of Bolsa Chica for use with <code><a href="#topic+shark_vis_longlat">shark_vis_longlat</a></code>
</h2><span id='topic+bc_longlat_map'></span>

<h3>Description</h3>

<p>Image of Bolsa Chica for use with <code><a href="#topic+shark_vis_longlat">shark_vis_longlat</a></code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(bc_longlat_map)</code></pre>


<h3>Format</h3>

<p>The format is:
List of 8
$ lat.center: Named num 33.7
..- attr(*, &quot;names&quot;)= chr &quot;lat&quot;
$ lon.center: Named num -118
..- attr(*, &quot;names&quot;)= chr &quot;lon&quot;
$ zoom      : num 15
$ myTile    : num [1:640, 1:640, 1:4] 0.639 0.639 0.639 0.639 0.639 ...
$ BBOX      :List of 2
..$ ll: num [1, 1:2] 33.7 -118.1
.. ..- attr(*, &quot;dimnames&quot;)=List of 2
.. .. ..$ : NULL
.. .. ..$ : chr [1:2] &quot;lat&quot; &quot;lon&quot;
..$ ur: num [1, 1:2] 33.7 -118
.. ..- attr(*, &quot;dimnames&quot;)=List of 2
.. .. ..$ : NULL
.. .. ..$ : chr [1:2] &quot;lat&quot; &quot;lon&quot;
$ url       : chr &quot;google&quot;
$ size      : num [1:2] 640 640
$ SCALE     : num 1
- attr(*, &quot;class&quot;)= chr &quot;staticMap&quot;
</p>


<h3>Source</h3>

<p>Google Maps.
</p>

<hr>
<h2 id='bc_longlat_map_img_ras'>
Raster image of Bolsa Chica for use with <code><a href="#topic+shark_vis_longlat">shark_vis_longlat</a></code>
</h2><span id='topic+bc_longlat_map_img_ras'></span>

<h3>Description</h3>

<p>Raster image of Bolsa Chica for use with <code><a href="#topic+shark_vis_longlat">shark_vis_longlat</a></code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data("bc_longlat_map_img_ras")</code></pre>


<h3>Format</h3>

<p>The format is:
'raster' chr [1:640, 1:640] &quot;#A3CCFFFF&quot; &quot;#A3CCFFFF&quot; &quot;#A3CCFFFF&quot; ...
</p>


<h3>Source</h3>

<p>Google Maps.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(bc_longlat_map_img_ras)
</code></pre>

<hr>
<h2 id='cdlm_robot'>
Shiny app for 1D simulation of robot movement with CDLM.
</h2><span id='topic+cdlm_robot'></span>

<h3>Description</h3>

<p>Shiny app for 1D simulation of robot movement with CDLM.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cdlm_robot()</code></pre>


<h3>Details</h3>

<p>This shiny app illustrates a 1-D robot movement model.  Here, T (&quot;maximum number of iterations&quot;) steps are simulated for a robot moving along a 1-D line.  Each of the T steps represents a length of time represented by &quot;time step (sec)&quot; seconds; the longer the interval, the more location uncertainty there is between steps.  
At each step, the robot moves with velocity (v_t) modeled by a normal distribution with mean alpha (&quot;unknown true mean of velocity&quot;) and variance &quot;known true variance.&quot; For simplicity, we will only attempt to model the mean velocity while sequentially observing only the locations, since we assume the variance is known. 
The particle filter learns the movement parameters through N (&quot;number of particles&quot;) particles, or independent simulations.  At each point in time, the filter simulates N draws of the velocity from the prior distribution, a normal distribution with mean mu (&quot;prior mean on velocity mean&quot;) and variance sigma (&quot;prior variance on velocity mean&quot;). These distributions are shown in color panel 1.  Ideally, over time the colored distributions should converge to the true one (thick black curve).
</p>
<p>Panel 1 shows the particles' distributions of the velocities.  Ideally the means of these distributions should converge to the true value (vertical line).
Note: this simulation works best if the distribution of true velocity is either clearly negative or positive.  If the distribution straddles v_t=0 with significant probability, movement will be more difficult to visualize.  In the above case, the location should be the one more in the direction of the sign of velocity (i.e. if velocity distribution &gt;0, then the robot should be consistently moving to the right).
</p>
<p>Panel 2 shows each particle's prediction of the location (black dot) and the 95% confidence interval of this prediction (width of colored rectangle).  The true observed location and the previous one are the two dashed vertical lines.  Particles whose dots fall closer to the vertical line have better prediction.
</p>
<p>Panel 3 shows the weights of the particles as calculated by the closeness of their location prediction to the true one.  Closer particles in panel 2 should have higher weights (the colors correspond).
</p>
<p>Panel 4 shows the predictions and confidence intervals of particles being resampled by their weights (with replacement).  More of the predictions should be closer to the truth here than in panel 2.
</p>
<p>Panel 5 shows convergence over time of the means of the particle distributions of velocity (panel 1) to the true value (vertical dashed line). Ideally these should converge to the true value. 
</p>
<p>Panel 6 shows the history of predicted locations over time, by vertical lines representing each particle's predictions.  Ideally the particle predictions should both converge to the observed locations
and should also be grouped closer together, as the estimated velocity distribution standard deviation decreases.
</p>
<p>The particle filter models the true value of location and the true velocity.  It is reasonable to assume that these are independent, which is why the covariance matrices given are diagonal. 
</p>


<h3>Note</h3>

<p>Video explanation of simulation applet by author: <a href="https://youtu.be/iVG_bCU0jCA">https://youtu.be/iVG_bCU0jCA</a>
</p>


<h3>References</h3>

<p>Ackerman, Samuel.  &quot;A Probabilistic Characterization of Shark Movement Using Location Tracking Data.&quot;  Temple University doctoral thesis, 2018.  <a href="https://digital.library.temple.edu/digital/collection/p245801coll10/id/499150">https://digital.library.temple.edu/digital/collection/p245801coll10/id/499150</a>
</p>
<p>Carvalho, Carlos M., Johannes, Michael S., Lopes, Hedibert F., and Nicholas G. Polson.  &quot;Particle learning and smoothing.&quot;  Statistical Science, 2010.
</p>

<hr>
<h2 id='cdlm_robot_twostate'>
Shiny app for simulation of 1D robot movement with CDLM and two states.
</h2><span id='topic+cdlm_robot_twostate'></span>

<h3>Description</h3>

<p>Shiny app for simulation of 1D robot movement with CDLM and two states.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cdlm_robot_twostate()</code></pre>


<h3>Details</h3>

<p>See <code>cdlm_robot</code> for explanation of the basic concepts.  This function is similar except there are two behavioral states (1 and 2, &quot;slow&quot;/&quot;fast&quot;) to model, as well as the switching probabilities between them.
</p>
<p>The means of the velocities of the two behaviors are simulated by a normal distribution with two means alpha (&quot;unknown true mean of velocity&quot;, types 1 and 2).  The variance in each case is the same and known, as before. The prior means and variances of the velocities are assigned as before. 
</p>
<p>The transition probabilities between the behaviors are given by &quot;transition probability between type 1 and 2&quot; and &quot;2 and 1&quot;.  If box &quot;are transition probabilities known?&quot; is checked, then they are known.  Otherwise, the transition probabilities will be estimated by a Dirichlet prior (vector &quot;Dirichlet prior values&quot; of form 1-&gt;1, 1-&gt;2, 2-&gt;1, 2-&gt;2 of positive numbers, which should roughly correspond to the true probabilities in ratio).  Note that the predictions in this simulation are unlikely to be as good as in the prior 1-D example since there are more parameters to learn and only a limited number of timesteps or particles.
</p>
<p>Panel 1 shows the particles' distributions of the velocities for each behavior.  This simulation works best if the distributions are well-separated.
</p>
<p>Panel 2 shows the location predictions for each behavior.  The black dot indicates the mean predicted location, and the 
rectangle width is the width of the 95% confidence interval.  The rectangle for behavior 1 is solid, for behavior 2 it has crosshatches.
</p>
<p>Panel 3 shows the overall resampling weights for the particles, as well as the behavior-conditional ones.  The higher the behavior-conditional weight bar is, the better the
particle's prediction at that behavior matches what was observed.  The overall weight (top row) is the average of the 
conditional weight values, weighted by the transition probability into that behavior.
</p>
<p>Panel 4 shows the resampled particles, along with their prediction of location and behavior type.  Ideally, the resampled rectangles should be centered around the observed point.  
It is not necessarily true that the resampled (most likely) rectangles will be the narrowest, since the likelihood of the behavior predicting the observed location is a combination of
both the density of that location at the prediction distribution (closeness to the center), as well as the likelihood (transition probability) of having that behavior, given the previous one.
In panel 4, the particle predictions are shown one at a time as that particle is resampled; the weight bar in panel 3 should be in bold as that particle is selected.
</p>
<p>Panel 5 shows convergence over time of the means of the particle distributions of velocity (panel 1) to the true value (vertical dashed line). Ideally these should converge to the true value. 
</p>
<p>Panel 6 shows the history of predicted locations over time, by vertical lines representing each particle's predictions.  Ideally the particle predictions should both converge to the observed locations
and should also be grouped closer together, as the estimated velocity distribution standard deviation decreases.
</p>
<p>Panel 7 shows the estimated distributions of the behavior switching probabilities (if they are not known).  The true probabilities are shown by a vertical line, and ideally the mean
of the estimated distribution should be around there.
</p>
<p>Panel 8 shows the accuracy of particle predictions of the behavior.  The color (1=black, 2=gray) is the true behavior type, and the height of the bar is the fraction of particles correctly predicting it.  Ideally, all bars should be high.
</p>


<h3>Note</h3>

<p>Video explanation of simulation applet by author: <a href="https://youtu.be/4XR8eB89z7E">https://youtu.be/4XR8eB89z7E</a>
</p>


<h3>References</h3>

<p>Ackerman, Samuel.  &quot;A Probabilistic Characterization of Shark Movement Using Location Tracking Data.&quot;  Temple University doctoral thesis, 2018.  <a href="https://digital.library.temple.edu/digital/collection/p245801coll10/id/499150">https://digital.library.temple.edu/digital/collection/p245801coll10/id/499150</a>
</p>
<p>Carvalho, Carlos M., Johannes, Michael S., Lopes, Hedibert F., and Nicholas G. Polson.  &quot;Particle learning and smoothing.&quot;  Statistical Science, 2010.
</p>

<hr>
<h2 id='cdlm_robot_twostate_2D'>
Shiny app for simulation of 2D robot movement with CDLM and two states.
</h2><span id='topic+cdlm_robot_twostate_2D'></span>

<h3>Description</h3>

<p>Shiny app for simulation of 2D robot movement with CDLM and two states.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cdlm_robot_twostate_2D()</code></pre>


<h3>Details</h3>

<p>See <code>cdlm_robot</code> and <code>cdlm_robot_twostate</code> for explanation of the basic concepts.  This function simulates a 2-D moving robot with two behavioral states (1 and 2, &quot;slow&quot;/&quot;fast&quot;) to model, as well as the switching probabilities between them.
</p>
<p>The means of the log-speeds of the two behaviors are simulated by a normal distribution with two means alpha (&quot;unknown true mean of log-speed&quot;, types 1 and 2).  The variance in each case is the same and known, as before. The prior means and variances of the velocities are assigned as before. 
</p>
<p>The transition probabilities between the behaviors are given by &quot;transition probability between type 1 and 2&quot; and &quot;2 and 1&quot;.  If box &quot;are transition probabilities known?&quot; is checked, then they are known.  Otherwise, the transition probabilities will be estimated by a Dirichlet prior (vector &quot;Dirichlet prior values&quot; of form 1-&gt;1, 1-&gt;2, 2-&gt;1, 2-&gt;2 of positive numbers, which should roughly correspond to the true probabilities in ratio).  Note that the predictions in this simulation are unlikely to be as good as in the prior 1-D example since there are more parameters to learn and only a limited number of timesteps or particles.
</p>
<p>Panel 1 shows the particles' distributions of the log-speed for each behavior.  This simulation works best if the distributions are well-separated.
</p>
<p>Panel 2 shows the location predictions (center with confidence ellipse, either solid or dashed by behavior type)
</p>
<p>Panel 3 shows the overall resampling weights for the particles, as well as the behavior-conditional ones.  The higher the behavior-conditional weight bar is, the better the
particle's prediction at that behavior matches what was observed.  The overall weight (top row) is the average of the 
conditional weight values, weighted by the transition probability into that behavior.
</p>
<p>Panel 4 shows the resampled particles, along with their prediction of location and behavior type.  Ideally, the resampled ellipses should be centered around the observed point.  
It is not necessarily true that the resampled (most likely) ellipses will be the smallest, since the likelihood of the behavior predicting the observed location is a combination of
both the density of that location at the ellipse, as well as the likelihood (transition probability) of having that behavior, given the previous one.
In panel 4, the particle predictions are shown one at a time as that particle is resampled; the weight bar in panel 3 should be in bold as that particle is selected.
</p>
<p>Panel 5 shows convergence over time of the means of the particle distributions of log-speed (panel 1) to the true value (vertical dashed line). Ideally these should converge to the true value. 
</p>
<p>Panel 6 shows the history of predicted locations over time in terms of a spatial density plot (grayscale shading).  Ideally, these should concentrate around the red overlaid trajectory of observed locations.
</p>
<p>Panel 7 shows the estimated distributions of the behavior switching probabilities (if they are not known).  The true probabilities are shown by a vertical line, and ideally the mean
of the estimated distribution should be around there.
</p>
<p>Panel 8 shows the accuracy of particle predictions of the behavior.  The color (1=black, 2=gray) is the true behavior type, and the height of the bar is the fraction of particles correctly predicting it.  Ideally, all bars should be high.
</p>


<h3>Note</h3>

<p>Video explanation of simulation applet by author: <a href="https://youtu.be/4XR8eB89z7E">https://youtu.be/4XR8eB89z7E</a>
</p>


<h3>References</h3>

<p>Ackerman, Samuel.  &quot;A Probabilistic Characterization of Shark Movement Using Location Tracking Data.&quot;  Temple University doctoral thesis, 2018.  <a href="https://digital.library.temple.edu/digital/collection/p245801coll10/id/499150">https://digital.library.temple.edu/digital/collection/p245801coll10/id/499150</a>
</p>
<p>Carvalho, Carlos M., Johannes, Michael S., Lopes, Hedibert F., and Nicholas G. Polson.  &quot;Particle learning and smoothing.&quot;  Statistical Science, 2010.
</p>

<hr>
<h2 id='EKF_1d_interp_joint'>
Extended Kalman Filter (EKF) for 1-D movement with interpolation
</h2><span id='topic+EKF_1d_interp_joint'></span>

<h3>Description</h3>

<p>Extended Kalman Filter (EKF) for 1-D movement with interpolation
</p>


<h3>Usage</h3>

<pre><code class='language-R'>EKF_1d_interp_joint(d, npart=100, sigma_pars, 
                    alpha0_pars=list(mu0=c(5, 9), V0=c(0.25, 0.25)),
                    Errvar0=rep(list(5), 2), Errvar_df=c(20, 20), 
                    Particle_errvar0, Particle_err_df=20, delaysample=1,
                    dirichlet_init=c(10,3,3,8), maxStep=NULL, 
                    state_favor=c(1,1), nstates=2,
                    lowvarsample=FALSE, time_radius=60*30, spat_radius=300,
                    min_num_neibs=10, interact=TRUE, 
                    interact_pars=list(mu0=0, precision0=2,
                    known_precision=2),
                    neff_sample=1, time_dep_trans=FALSE, 
                    time_dep_trans_init=dirichlet_init, smoothing=FALSE, 
                    fix_smoothed_behaviors=TRUE, smooth_parameters=TRUE,
                    reg_dt=120, max_int_wo_obs=NULL,
                    resamp_full_hist=TRUE, compare_with_known=FALSE,
                    known_trans_prob=NULL, known_foraging_prob=NULL,
                    known_regular_step_ds=NULL, update_eachstep=FALSE,
                    update_params_for_obs_only=FALSE,
                    output_plot=TRUE, loc_pred_plot_conf=0.5,
                    output_dir=getwd(), pdf_prefix="EKF_1D", verbose=3)

					
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="EKF_1d_interp_joint_+3A_d">d</code></td>
<td>

<p>Dataset of observations, with required variable columns: tag, X, velocity, date_as_sec, time_to_next, state.guess2, prev.guess2.
</p>
</td></tr>
<tr><td><code id="EKF_1d_interp_joint_+3A_npart">npart</code></td>
<td>

<p>Number of particles to be used in simulation.
</p>
</td></tr>
<tr><td><code id="EKF_1d_interp_joint_+3A_sigma_pars">sigma_pars</code></td>
<td>

<p>Vector of inverse-gamma parameters for sigma^2 (logV variance).  Two elements for each state.  The inverse gamma parameters are specified in pairs.
</p>
</td></tr>
<tr><td><code id="EKF_1d_interp_joint_+3A_alpha0_pars">alpha0_pars</code></td>
<td>

<p>List of initial values of mean velocity (mu) and degrees of freedom (V), one for each behavioral state.
</p>
</td></tr>
<tr><td><code id="EKF_1d_interp_joint_+3A_errvar0">Errvar0</code></td>
<td>

<p>List of prior 1x1 covariance matrices for predicting y from x, one for each behavioral state.
</p>
</td></tr>
<tr><td><code id="EKF_1d_interp_joint_+3A_errvar_df">Errvar_df</code></td>
<td>

<p>Vector of degrees of freedom of <code>Errvar0</code> covariance matrices.
</p>
</td></tr>
<tr><td><code id="EKF_1d_interp_joint_+3A_particle_errvar0">Particle_errvar0</code></td>
<td>

<p>Prior 1x1 covariance matrix for predicting x_t from x_t-1.
</p>
</td></tr>
<tr><td><code id="EKF_1d_interp_joint_+3A_particle_err_df">Particle_err_df</code></td>
<td>

<p>Degree of freedom of <code>Particle_errvar0</code>.
</p>
</td></tr>
<tr><td><code id="EKF_1d_interp_joint_+3A_dirichlet_init">dirichlet_init</code></td>
<td>

<p>List of 4-element vectors specifying Dirichlet parameters for transition matrices for each region.  Will be replicated to equal number of regions.
</p>
</td></tr>
<tr><td><code id="EKF_1d_interp_joint_+3A_maxstep">maxStep</code></td>
<td>

<p>Maximum number of regular steps to simulate.  Default is NULL, meaning that the number of regular steps simulated will be the minimum number
required to cover the range of observed data.  If not NULL, maxStep will be the minimum of the submitted value or the the above.
</p>
</td></tr>
<tr><td><code id="EKF_1d_interp_joint_+3A_delaysample">delaysample</code></td>
<td>

<p>Number of regular steps at which resampling will begin.  The default =1 means resampling will begin immediately.
</p>
</td></tr>
<tr><td><code id="EKF_1d_interp_joint_+3A_state_favor">state_favor</code></td>
<td>

<p>Vector of weights to favor states when resampling (but not propagating).  For instance c(1,3)
will favor state 2 weight 3 times as much as state 1 weights for particles.  By default, they are equally weighted.
</p>
</td></tr>
<tr><td><code id="EKF_1d_interp_joint_+3A_nstates">nstates</code></td>
<td>

<p>Number of behavioral states.  For now restricted to a maximum of 2.
</p>
</td></tr>
<tr><td><code id="EKF_1d_interp_joint_+3A_lowvarsample">lowvarsample</code></td>
<td>

<p>Logical.  If TRUE, use low-variance sampling when resampling particles to ensure particles are resampled proportionately to weight.  Otherwise there is some sampling variance when drawing random samples.
The setting applies to smoothing as well.
</p>
</td></tr>
<tr><td><code id="EKF_1d_interp_joint_+3A_time_radius">time_radius</code></td>
<td>

<p>Time in seconds to consider for spatial neighbors (1-D interval on either side).
</p>
</td></tr>
<tr><td><code id="EKF_1d_interp_joint_+3A_spat_radius">spat_radius</code></td>
<td>

<p>Radius (half of interval length) in meters of spatial neighborhood.
</p>
</td></tr>
<tr><td><code id="EKF_1d_interp_joint_+3A_min_num_neibs">min_num_neibs</code></td>
<td>

<p>Minimum number of time and spatial radius observations that need to exist to constitute a neighborhood.
</p>
</td></tr>
<tr><td><code id="EKF_1d_interp_joint_+3A_interact">interact</code></td>
<td>

<p>Logical.  If TRUE, simulate interaction parameters of neighborhood.   If <code>nstates</code>=1, automatically set to FALSE.
</p>
</td></tr>
<tr><td><code id="EKF_1d_interp_joint_+3A_interact_pars">interact_pars</code></td>
<td>

<p>List of interaction priors: <code>mu0</code> and <code>precision0</code> are prior mu and precision for normal draws of interaction parameter.  <code>known_precision</code> is the known precision of the lognormal intensity.
</p>
</td></tr>
<tr><td><code id="EKF_1d_interp_joint_+3A_neff_sample">neff_sample</code></td>
<td>

<p>Number between 0 and 1.  If effective sample size &lt; <code>neff_sample</code>, then resample.  Recommended to always resample if interpolating, so set neff_sample=1 as default.
</p>
</td></tr>
<tr><td><code id="EKF_1d_interp_joint_+3A_time_dep_trans">time_dep_trans</code></td>
<td>

<p>Logical. If TRUE, state transition matrices are time-dependent meaning that probability depends on the number of steps a shark has remained in the current state.
</p>
</td></tr>
<tr><td><code id="EKF_1d_interp_joint_+3A_time_dep_trans_init">time_dep_trans_init</code></td>
<td>

<p>4-element numeric vector of Dirichlet parameters for <code>time_dep_trans</code>.
</p>
</td></tr>
<tr><td><code id="EKF_1d_interp_joint_+3A_smoothing">smoothing</code></td>
<td>

<p>Logical.  If TRUE, perform smoothing at the end.
</p>
</td></tr>
<tr><td><code id="EKF_1d_interp_joint_+3A_fix_smoothed_behaviors">fix_smoothed_behaviors</code></td>
<td>

<p>Logical.  If TRUE, when performing smoothing, keep behavior modes fixed for each particle history from what was originally predicted duruing filtering, 
before smoothing.  This means the particles will be smoothed backwards with each particle weight at each time point being conditioned on the 
behavior predicted in filtering.  Thus, the behavioral agreement with, say, the observed or true behaviors is the same for smoothing as for 
filtering, since behaviors are not allowed to change.  If <code>nstates==1</code>, then automatically <code>fix_smoothed_behaviors=FALSE</code>.
</p>
</td></tr>
<tr><td><code id="EKF_1d_interp_joint_+3A_smooth_parameters">smooth_parameters</code></td>
<td>

<p>Logical.  If TRUE, when performing smoothing, resample the parameters theta as well.
</p>
</td></tr>
<tr><td><code id="EKF_1d_interp_joint_+3A_reg_dt">reg_dt</code></td>
<td>

<p>Length in seconds of each regular interval.
</p>
</td></tr>
<tr><td><code id="EKF_1d_interp_joint_+3A_max_int_wo_obs">max_int_wo_obs</code></td>
<td>

<p>When simulating, the maximum number of intervals of length <code>reg_dt</code> without observations for a given shark that we will simulate.  If this is exceeded, algorithm will wait until next observation and start from there.
Default is NULL, meaning it will be set to <code>maxStep</code>, and thus the algorithm will continue simulating without 
stopping, regardless of when the next observation is. 
</p>
</td></tr>
<tr><td><code id="EKF_1d_interp_joint_+3A_resamp_full_hist">resamp_full_hist</code></td>
<td>

<p>Logical.  If TRUE, resample the full particle history, not just all particle times since the last observation, each time resampling occurs.
</p>
</td></tr>
<tr><td><code id="EKF_1d_interp_joint_+3A_compare_with_known">compare_with_known</code></td>
<td>

<p>Logical.  If TRUE, provide a known regular-step dataset from which <code>d</code> is a irregularly-sampled subset, for comparison with particle predictions.
</p>
</td></tr>
<tr><td><code id="EKF_1d_interp_joint_+3A_known_trans_prob">known_trans_prob</code></td>
<td>

<p>If <code>nstates</code>=2, a matrix of row 2 where each column is the behavior transition probabilities between each opposing behavior, in each region.  
</p>
</td></tr>
<tr><td><code id="EKF_1d_interp_joint_+3A_known_foraging_prob">known_foraging_prob</code></td>
<td>

<p>If <code>nstates</code>=2, a matrix of the foraging probabilities for each region. 
</p>
</td></tr>
<tr><td><code id="EKF_1d_interp_joint_+3A_known_regular_step_ds">known_regular_step_ds</code></td>
<td>

<p>If <code>compare_with_known</code>=TRUE, the dataset of the original regular-step trajectories. Note: this dataset needs to have 
column <code>date_as_sec</code> (date in seconds) and time gap <code>reg_dt</code> be the same as the set of regular-step intervals
that the EKF is trying to estimate movement at.  Otherwise, the simulated movement locations and the true ones will not
correspond.
</p>
</td></tr>
<tr><td><code id="EKF_1d_interp_joint_+3A_update_eachstep">update_eachstep</code></td>
<td>

<p>Logical.  If TRUE, for regular steps without observations, update the movement parameters based on the simulated movements.  If FALSE, parameters are
only updated based on the simulated movements when a new observation occurs; this means the simulated movements are drawn using the parameter values learned 
since the last observation.
</p>
</td></tr>
<tr><td><code id="EKF_1d_interp_joint_+3A_update_params_for_obs_only">update_params_for_obs_only</code></td>
<td>

<p>Logical.  If TRUE, the particle movement parameters are updated based on simulated movement only at intervals with observed locations.  
If FALSE, particle movement in intermediate steps that are simulated will be used to update as well.
If TRUE, then <code>update_eachstep=FALSE</code>, meaning that parameter updates will be done only for (and at) the steps that represent observations.
If FALSE, then <code>update_eachstep</code> can be either TRUE or FALSE, but simulated steps will be used to update, but 
<code>update_eachstep</code> controls the timing of the the update; if TRUE, it happens one step at a time, and if FALSE, a batch update is done
at observations for the set of simulated steps. 
</p>
</td></tr>
<tr><td><code id="EKF_1d_interp_joint_+3A_output_plot">output_plot</code></td>
<td>

<p>Logical.  If TRUE, a set of diagnostic plots will be printed to a file in <code>output_dir</code>.  Otherwise, it 
will be output to the plotting console.
</p>
</td></tr>
<tr><td><code id="EKF_1d_interp_joint_+3A_loc_pred_plot_conf">loc_pred_plot_conf</code></td>
<td>

<p>Numeric.  Confidence level of confidence interval for location prediction error to plot in step-wise diagnostics.
</p>
</td></tr>
<tr><td><code id="EKF_1d_interp_joint_+3A_pdf_prefix">pdf_prefix</code></td>
<td>

<p>String prefix for output PDF filename, if <code>output_plot = TRUE</code>.  Filename will be the prefix followed by a timestamp.
</p>
</td></tr>
<tr><td><code id="EKF_1d_interp_joint_+3A_output_dir">output_dir</code></td>
<td>

<p>Directory for output PDF of diagnostic plots.
</p>
</td></tr>
<tr><td><code id="EKF_1d_interp_joint_+3A_verbose">verbose</code></td>
<td>

<p>Integer, one of 0,1,2,3. Control of verbosity of printouts during simulation.  3 means show both printouts and plots; 2 means show plots only; 
1 means show printouts only; 0 means show no plots or prinouts.  Final plotting will be done regardless.
</p>
</td></tr>
</table>


<h3>Value</h3>

<table>
<tr><td><code>d</code></td>
<td>
<p>Input dataset as <code>data.frame</code></p>
</td></tr>
<tr><td><code>N</code></td>
<td>
<p>Number of regular steps of length <code>reg_dt</code> needed to cover the observed range of time.</p>
</td></tr>
<tr><td><code>t_reg</code></td>
<td>
<p>Vector of times of regular step <code>reg_dt</code>.</p>
</td></tr>
<tr><td><code>nsharks</code></td>
<td>
<p>Number of sharks in output data.</p>
</td></tr>
<tr><td><code>shark_names</code></td>
<td>
<p>Names of sharks in output data.</p>
</td></tr>
<tr><td><code>shark_valid_steps</code></td>
<td>
<p>List of regular-step intervals that each shark has simulated particle movement for.</p>
</td></tr>
<tr><td><code>shark_intervals</code></td>
<td>
<p>List of regular-step intervals that each shark has observations for.</p>
</td></tr>
<tr><td><code>first_intervals</code></td>
<td>
<p>List of regular-step intervals that begin each shark's segments of simulated particle movement.
If observed gaps are larger than <code>max_int_wo_obs</code>, the shark's trajectory will be simulated as two or more separate segments.</p>
</td></tr>
<tr><td><code>included_intervals</code></td>
<td>
<p>Unique list of regular-step intervals with simulated movement for any shark.</p>
</td></tr>
<tr><td><code>mu</code></td>
<td>
<p>Array of estimated values of mean log-velocity for normal inverse-gamma conjugate distribution</p>
</td></tr>
<tr><td><code>XY_errvar</code></td>
<td>
<p>Estimated matrix and degrees of freedom of estimated location error covariance, for each behavior.</p>
</td></tr>
<tr><td><code>sigma_pars</code></td>
<td>
<p>Posterior inverse gamma distribution parameters for the velocity (or, for 2-D, log-velocity) variance.</p>
</td></tr>
<tr><td><code>Xpart_history</code></td>
<td>
<p>Overall history of estimated movement values.</p>
</td></tr>
<tr><td><code>param_draws</code></td>
<td>
<p>Posterior sampled values of mean of velocity (or, for 2-D, log-velocity).</p>
</td></tr>
<tr><td><code>variance_draws</code></td>
<td>
<p>Posterior sampled value of variance of velocity (or, for 2-D, log-velocity).</p>
</td></tr>
<tr><td><code>eff_size_hist</code></td>
<td>
<p>History of effective sample sizes in simulations.</p>
</td></tr>
<tr><td><code>agree_table</code></td>
<td>
<p>Table of observed agreement between particle predictions of behavior and those observed, overall and by behavior, if <code>nstates &gt; 1</code>.</p>
</td></tr>
<tr><td><code>states</code></td>
<td>
<p>Observed vector of behavioral states.</p>
</td></tr>
<tr><td><code>state_counts</code></td>
<td>
<p>Array of total number of simulated regular-step intervals in each behavioral state.</p>
</td></tr>
<tr><td><code>lambda_matrix</code></td>
<td>
<p>History of particle predicted values of lambda, the behavior variable.</p>
</td></tr>
<tr><td><code>lambda_matrix_beforesamp</code></td>
<td>
<p>Same as <code>lambda_matrix</code>, except the history before each time has not been resampled according to the particle
resampling weights.  For <code>lambda_matrix</code>, <code>Xpart_history</code>, and other estimated outputs, the entire particle history is resampled.</p>
</td></tr>
<tr><td><code>resample_history</code></td>
<td>
<p>Fraction of unique particles that are resampled at each regular step over the history.</p>
</td></tr>
<tr><td><code>transition_mat</code></td>
<td>
<p>Estimated transition probability matrix parameters for Dirichlet distribution.  If <code>nstates==1</code>, is meaningless.</p>
</td></tr>
<tr><td><code>error_beforesamp</code></td>
<td>
<p>For each regular step <code>i</code> with an observation, the quantiles of summed prediction errors before each round of resampling, across history.</p>
</td></tr>
<tr><td><code>error_beforesamp_quantiles</code></td>
<td>
<p>Quantiles of <code>error_beforesamp_allpart</code> across history.</p>
</td></tr>
<tr><td><code>error_final_allpart</code></td>
<td>
<p>For each regular step <code>i</code> with an observation, the sum of prediction errors for any observations in that interval (final after resampling).</p>
</td></tr>
<tr><td><code>error_final_quantiles</code></td>
<td>
<p>Quantiles of <code>error_final_allpart</code> across history.</p>
</td></tr>
<tr><td><code>error_true_allpart</code></td>
<td>
<p>If <code>compare_with_known == TRUE</code>, for each regular step <code>i</code>, the sum of prediction errors for any true locations in that interval.</p>
</td></tr>
<tr><td><code>error_true_quantiles</code></td>
<td>
<p>If <code>compare_with_known == TRUE</code>, quantiles of <code>error_final_true_allpart</code> across history.</p>
</td></tr>
</table>
<p>The following inputted parameters are returned :
</p>
<table>
<tr><td><code>npart</code></td>
<td>
</td></tr>
<tr><td><code>nstates</code></td>
<td>
</td></tr>
<tr><td><code>state_favor</code></td>
<td>
</td></tr>
<tr><td><code>known_regular_step_ds</code></td>
<td>
</td></tr>
<tr><td><code>known_foraging_prob</code></td>
<td>
</td></tr>
<tr><td><code>neff_sample</code></td>
<td>
</td></tr>
<tr><td><code>resamp_full_hist</code></td>
<td>
</td></tr>
<tr><td><code>time_dep_trans</code></td>
<td>
</td></tr>
<tr><td><code>interact</code></td>
<td>
</td></tr>
<tr><td><code>spat_radius</code></td>
<td>
</td></tr>
<tr><td><code>time_radius</code></td>
<td>
</td></tr>
<tr><td><code>lowvarsample</code></td>
<td>
</td></tr>
<tr><td><code>update_eachstep</code></td>
<td>
</td></tr>
<tr><td><code>update_params_for_obs_only</code></td>
<td>
</td></tr>
</table>
<p>The following are returned if <code>nstates &gt; 1</code>:
</p>
<table>
<tr><td><code>trans_counts</code></td>
<td>
<p>Array of total number of simulated regular-step intervals with transitions between each possible pair of behaviors.</p>
</td></tr>
<tr><td><code>trans_mean</code></td>
<td>
<p>Posterior estimates of mean behavior switching probabilities from <code>region_trans_draws</code>.</p>
</td></tr>
<tr><td><code>region_foraging_draws</code></td>
<td>
<p>Posterior estimate of probability of foraging (lambda=0) from behavior switching probabilities.</p>
</td></tr>
<tr><td><code>region_trans_draws</code></td>
<td>
<p>Posterior draws of behavior switching probabilities from <code>transition_mat</code>. For 2-D, this is separately by region, if
there are multiple regions.</p>
</td></tr>
</table>
<p>In addition, the following are returned if <code>compare_with_known = TRUE</code>:
</p>
<table>
<tr><td><code>error_final_true_allpart</code></td>
<td>
<p>Errors from estimating true locations from particle locations (at the same times).</p>
</td></tr>
<tr><td><code>error_final_true_quantiles</code></td>
<td>
<p>Quantiles of <code>error_final_true_allpart</code> across history.</p>
</td></tr>
<tr><td><code>euclidean_estimate_true_from_obs</code></td>
<td>
<p>Estimates of true locations by Euclidean interpolation from observations</p>
</td></tr>
<tr><td><code>error_euclidean_estimate_true_from_obs</code></td>
<td>
<p>Euclidean error from <code>euclidean_estimate_true_from_obs</code> compared to true locations from <code>known_regular_step_ds</code>.</p>
</td></tr>
</table>
<p>In addition, the following are returned if <code>interact = TRUE</code>:
</p>
<table>
<tr><td><code>spatial_interact_pars</code></td>
<td>
<p>Estimated parameters for sharks' tendency to be influenced by other neighboring sharks in determining behavior.</p>
</td></tr>
<tr><td><code>interact_mu_draws</code></td>
<td>
<p>Posterior sampled values of interaction mu parameter.</p>
</td></tr>
<tr><td><code>interact_intensity_draw</code></td>
<td>
<p>Posterior sampled values of interaction tendency multiplier, at different proportions of neighboring sharks with second behavior type.</p>
</td></tr>
<tr><td><code>spatial_interact_mu_history</code></td>
<td>
<p>History of simulated values of interaction mu.</p>
</td></tr>
<tr><td><code>spatial_interact_intensity_history</code></td>
<td>
<p>History of simulated values of interaction tendency multiplier.</p>
</td></tr>
</table>
<p>The following are returned if <code>smoothing = TRUE</code>:
</p>
<table>
<tr><td><code>Xpart_history_smoothed</code></td>
<td>
<p>Resampled values of <code>Xpart_history</code> by reverse smoothing resampling (see Carvalho et al).</p>
</td></tr>
<tr><td><code>error_smoothed_allpart</code></td>
<td>
<p>For each regular step <code>i</code>, the sum of prediction errors for smoothed particles for any observations in that interval.</p>
</td></tr>
<tr><td><code>error_smoothed_quantiles</code></td>
<td>
<p>Quantiles of <code>error_smoothed_allpart</code> across history.</p>
</td></tr>
</table>
<p>In addition, if <code>smooth_parameters = TRUE</code>:
</p>
<table>
<tr><td><code>param_draws_smoothed</code></td>
<td>
<p>Posterior sampled values of mean of velocity (or, for 2-D, log-velocity) after resampling by smoothing.</p>
</td></tr>
<tr><td><code>variance_draws_smoothed</code></td>
<td>
<p>Posterior sampled values of variance of velocity (or, for 2-D, log-velocity) after resampling by smoothing.</p>
</td></tr>
<tr><td><code>transition_mat_smoothed</code></td>
<td>
<p>Estimated transition probability matrix parameters for Dirichlet distribution after resampling by smoothing.</p>
</td></tr>
</table>
<p>In addition, if <code>smooth_parameters = TRUE</code> and <code>interact = TRUE</code>:
</p>
<table>
<tr><td><code>spatial_interact_pars_smoothed</code></td>
<td>
<p>Estimated parameters for sharks' tendency to be influenced by other neighboring sharks in determining behavior, after resampling by smoothing.</p>
</td></tr>
<tr><td><code>interact_mu_draws_smoothed</code></td>
<td>
<p>Posterior sampled values of interaction mu parameter, after resampling by smoothing.</p>
</td></tr>
<tr><td><code>interact_intensity_draw_smoothed</code></td>
<td>
<p>Posterior sampled values of interaction tendency multiplier, at different proportions of neighboring sharks with second behavior type, after resampling by smoothing.</p>
</td></tr>
</table>
<p>In addition to smoothing, if <code>compare_with_known = TRUE</code>:
</p>
<table>
<tr><td><code>error_smoothed_true_allpart</code></td>
<td>
<p>For each regular step <code>i</code>, the sum of prediction errors for smoothed particles for any observations in that interval.</p>
</td></tr>
<tr><td><code>error_smoothed_true_quantiles</code></td>
<td>
<p>Quantiles of <code>error_smoothed_true_allpart</code> across history.</p>
</td></tr>
</table>
<p>In addition to smoothing, if <code>smoothing = TRUE</code> but <code>fix_smoothed_behaviors = FALSE</code> (smoothed behaviors allowed to change from filtering):
</p>
<table>
<tr><td><code>mu_smoothed</code></td>
<td>
<p>Corresponding version of <code>mu</code> after resampling by smoothing.</p>
</td></tr>
<tr><td><code>sigma_pars_smoothed</code></td>
<td>
<p>Corresponding version of <code>sigma_pars</code> after resampling by smoothing.</p>
</td></tr>
<tr><td><code>agree_table_smoothed</code></td>
<td>
<p>Corresponding version of <code>agree_table</code> for smoothed states <code>lambda_matrix_smoothed</code>.</p>
</td></tr>
</table>


<h3>Note</h3>

<p>See <code><a href="#topic+sim_trajectory_joint">sim_trajectory_joint</a></code> for a full example of usage.
Video explanation of EKF state-space model by author: <a href="https://youtu.be/SgyhRVUn77k">https://youtu.be/SgyhRVUn77k</a>
</p>


<h3>Author(s)</h3>

<p>Samuel Ackerman
</p>


<h3>References</h3>

<p>Ackerman, Samuel.  &quot;A Probabilistic Characterization of Shark Movement Using Location Tracking Data.&quot;  Temple University doctoral thesis, 2018.  <a href="https://digital.library.temple.edu/digital/collection/p245801coll10/id/499150">https://digital.library.temple.edu/digital/collection/p245801coll10/id/499150</a>
</p>
<p>Carvalho, Carlos M., Johannes, Michael S., Lopes, Hedibert F., and Nicholas G. Polson.  &quot;Particle learning and smoothing.&quot;  Statistical Science, 2010.
</p>

<hr>
<h2 id='EKF_interp_joint'>
Extended Kalman Filter (EKF) for joint shark movement with interpolation
</h2><span id='topic+EKF_interp_joint'></span>

<h3>Description</h3>

<p>Extended Kalman Filter (EKF) for joint shark movement with interpolation
</p>


<h3>Usage</h3>

<pre><code class='language-R'>EKF_interp_joint(area_map=NULL, d, npart=100, sigma_pars, tau_pars,
                 mu0_pars=list(alpha=c(-4.5 ,-2), beta=c(0,0)),
                 V0_pars=list(alpha=c(0.25, 0.25), beta=c(0.25, 0.25)), 
                 Errvar0=rep(list(diag(2)), 2),
                 Errvar_df=c(20, 20), Particle_errvar0, Particle_err_df=20,
                 dirichlet_init=c(9,2,2,7), logvelocity_truncate=c(-10, 15),
                 maxStep=NULL, delaysample=1, state_favor=c(1,1),
                 nstates=2,centroids=matrix(c(0,0), ncol=2),
                 truncate_to_map=TRUE, enforce_full_line_in_map=TRUE,
                 do_trunc_adjust=TRUE, lowvarsample=TRUE,
                 time_radius=60*30, spat_radius=300, min_num_neibs=10, 
                 interact=TRUE, interact_pars=list(mu0=0, precision0=2, 
                 known_precision=2), neff_sample=1, time_dep_trans=FALSE,
                 time_dep_trans_init=dirichlet_init, smoothing=FALSE,
                 fix_smoothed_behaviors=TRUE, smooth_parameters=TRUE, 
                 reg_dt=120, max_int_wo_obs=NULL, resamp_full_hist=TRUE, 
                 compare_with_known=FALSE, known_trans_prob=NULL, 
                 known_foraging_prob=NULL, known_regular_step_ds=NULL,	
                 update_eachstep=FALSE, update_params_for_obs_only=FALSE,
                 output_plot=TRUE, loc_pred_plot_conf=0.5,
                 output_dir=getwd(), pdf_prefix="EKF_2D", verbose=3)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="EKF_interp_joint_+3A_area_map">area_map</code></td>
<td>

<p>Shapefile within which the observations are located (optional).  Should be the output of applying <code>sf::st_geometry</code> on an object of class <code>sf</code>.
If input is NULL, a default rectangular one is created that contains the observed X-Y points in <code>d</code>.
</p>
</td></tr>
<tr><td><code id="EKF_interp_joint_+3A_d">d</code></td>
<td>

<p>Dataset of observations, with required variable columns: tag, X, Y, logvelocity, speed, turn.angle.rad, region (optional), date_as_sec, time_to_next, state.guess2, prev.guess2.
</p>
</td></tr>
<tr><td><code id="EKF_interp_joint_+3A_npart">npart</code></td>
<td>

<p>Number of particles to be used in simulation.
</p>
</td></tr>
<tr><td><code id="EKF_interp_joint_+3A_sigma_pars">sigma_pars</code></td>
<td>

<p>Vector of inverse-gamma parameters for sigma^2 (logV variance).  Two elements for each state.  The inverse gamma parameters are specified in pairs.
</p>
</td></tr>
<tr><td><code id="EKF_interp_joint_+3A_tau_pars">tau_pars</code></td>
<td>

<p>Vector of inverse-gamma parameters for tau^2 (turn angle variance).
</p>
</td></tr>
<tr><td><code id="EKF_interp_joint_+3A_mu0_pars">mu0_pars</code></td>
<td>

<p>List of initial values of mean logV (alpha) and turn (beta) for one or two behavioral states.
</p>
</td></tr>
<tr><td><code id="EKF_interp_joint_+3A_v0_pars">V0_pars</code></td>
<td>

<p>List of initial values of degrees of freedom of inverse-gamma sigma and tau (variances of alpha and beta) for 
one or two behavioral state.
</p>
</td></tr>
<tr><td><code id="EKF_interp_joint_+3A_errvar0">Errvar0</code></td>
<td>

<p>List of prior 2x2 covariance matrices for predicting y from x, one for each behavioral state.
</p>
</td></tr>
<tr><td><code id="EKF_interp_joint_+3A_errvar_df">Errvar_df</code></td>
<td>

<p>Vector of degrees of freedom of <code>Errvar0</code> covariance matrices.
</p>
</td></tr>
<tr><td><code id="EKF_interp_joint_+3A_particle_errvar0">Particle_errvar0</code></td>
<td>

<p>Prior 2x2 covariance matrix for predicting x_t from x_t-1.
</p>
</td></tr>
<tr><td><code id="EKF_interp_joint_+3A_particle_err_df">Particle_err_df</code></td>
<td>

<p>Degree of freedom of <code>Particle_errvar0</code>.
</p>
</td></tr>
<tr><td><code id="EKF_interp_joint_+3A_dirichlet_init">dirichlet_init</code></td>
<td>

<p>List of 4-element vectors specifying Dirichlet parameters for transition matrices for each region.  Will be replicated to equal number of regions.
</p>
</td></tr>
<tr><td><code id="EKF_interp_joint_+3A_logvelocity_truncate">logvelocity_truncate</code></td>
<td>

<p>When simulating log-velocity, a vector of the allowable range (values outside will be truncated to fall in this range).
Log-velocity is simulated by a normal distribution (which is symmetric but can be positive or negative), so that speed (=exp(log_velocity)) will be 
positive.  However, the transformation has asymmetric impact in that, say, a fixed error in underestimating log-velocity results in a smaller
displacement (when translated to speed and thus distance) than the same error over-estimated.  The variance of 
log-velocity takes into account low and high values equally.  This restriction prevents the variance from growing too large
from low (e.g. very negative) values of log-velocity, which will then cause large over-estimates of speed and distance traveled.
The difference between, say, log-velocity of -2 and -50 is very small in practical terms of distance, but the effect
on the variance will be much larger for the -50.
</p>
</td></tr>
<tr><td><code id="EKF_interp_joint_+3A_maxstep">maxStep</code></td>
<td>

<p>Maximum number of regular steps to simulate.  Default is NULL, meaning that the number of regular steps simulated will be the minimum number
required to cover the range of observed data.  If not NULL, maxStep will be the minimum of the submitted value or the the above.
</p>
</td></tr>
<tr><td><code id="EKF_interp_joint_+3A_delaysample">delaysample</code></td>
<td>

<p>Number of regular steps at which resampling will begin.  The default =1 means resampling will begin immediately.
</p>
</td></tr>
<tr><td><code id="EKF_interp_joint_+3A_state_favor">state_favor</code></td>
<td>

<p>Vector of weights to favor states when resampling (but not propagating).  For instance c(1,3)
will favor state 2 weight 3 times as much as state 1 weights for particles.  By default, they are equally weighted.
</p>
</td></tr>
<tr><td><code id="EKF_interp_joint_+3A_nstates">nstates</code></td>
<td>

<p>Number of behavioral states.  For now restricted to a maximum of 2.
</p>
</td></tr>
<tr><td><code id="EKF_interp_joint_+3A_centroids">centroids</code></td>
<td>

<p>Matrix with two columns specifying the centroids of regions.
</p>
</td></tr>
<tr><td><code id="EKF_interp_joint_+3A_truncate_to_map">truncate_to_map</code></td>
<td>

<p>Logical.  If TRUE, make sure that coordinate predictions are inside the boundary <code>area_map</code> by truncated sampling.
</p>
</td></tr>
<tr><td><code id="EKF_interp_joint_+3A_enforce_full_line_in_map">enforce_full_line_in_map</code></td>
<td>

<p>Logical.  If TRUE, when conducting truncated sampling (<code>truncate_to_map==TRUE</code>), count the prediction of the next
location as being inside the boundary if the full line segment connecting it to the current location is inside the map.
Otherwise, only the predicted point (and not the line connecting them) must be inside the map.  The idea is that the truncation
allows only 'feasible' straight-line moves to be made, and so the full line segment must be inside the map.  However,
there may be situations in which this restriction prevents the algorithm from making good predictions, such as if the time gap
<code>reg_dt</code> is too long, or if the map contains 'narrow' areas where requiring the line to be inside would 
prevent a prediction and the algorithm would get 'stuck'.
</p>
</td></tr>
<tr><td><code id="EKF_interp_joint_+3A_do_trunc_adjust">do_trunc_adjust</code></td>
<td>

<p>Logical.  If TRUE, adjust particle posterior weights by the fraction of their predictions that are within the truncation boundary.
</p>
</td></tr>
<tr><td><code id="EKF_interp_joint_+3A_lowvarsample">lowvarsample</code></td>
<td>

<p>Logical.  If TRUE, use low-variance sampling when resampling particles to ensure particles are resampled proportionately to weight.  Otherwise there is some sampling variance when drawing random samples.
The setting applies to smoothing as well.
</p>
</td></tr>
<tr><td><code id="EKF_interp_joint_+3A_time_radius">time_radius</code></td>
<td>

<p>Time in seconds to consider for spatial neighbors.
</p>
</td></tr>
<tr><td><code id="EKF_interp_joint_+3A_spat_radius">spat_radius</code></td>
<td>

<p>Radius in meters of (circular) spatial neighborhood.
</p>
</td></tr>
<tr><td><code id="EKF_interp_joint_+3A_min_num_neibs">min_num_neibs</code></td>
<td>

<p>Minimum number of time and spatial radius observations that need to exist to constitute a neighborhood.
</p>
</td></tr>
<tr><td><code id="EKF_interp_joint_+3A_interact">interact</code></td>
<td>

<p>Logical.  If TRUE, simulate interaction parameters of neighborhood.   If <code>nstates</code>=1, or if only one shark, automatically set to FALSE.
</p>
</td></tr>
<tr><td><code id="EKF_interp_joint_+3A_interact_pars">interact_pars</code></td>
<td>

<p>List of interaction priors: <code>mu0</code> and <code>precision0</code> are prior mu and precision for normal draws of interaction parameter.  <code>known_precision</code> is the known precision of the lognormal intensity.
</p>
</td></tr>
<tr><td><code id="EKF_interp_joint_+3A_neff_sample">neff_sample</code></td>
<td>

<p>Number between 0 and 1.  If effective sample size &lt; <code>neff_sample</code>, then resample.  Recommended to always resample if interpolating, so set neff_sample=1 as default.
</p>
</td></tr>
<tr><td><code id="EKF_interp_joint_+3A_time_dep_trans">time_dep_trans</code></td>
<td>

<p>Logical. If TRUE, state transition matrices are time-dependent meaning that probability depends on the number of steps a shark has remained in the current state.
</p>
</td></tr>
<tr><td><code id="EKF_interp_joint_+3A_time_dep_trans_init">time_dep_trans_init</code></td>
<td>

<p>4-element numeric vector of Dirichlet parameters for <code>time_dep_trans</code>.
</p>
</td></tr>
<tr><td><code id="EKF_interp_joint_+3A_smoothing">smoothing</code></td>
<td>

<p>Logical.  If TRUE, perform smoothing at the end.
</p>
</td></tr>
<tr><td><code id="EKF_interp_joint_+3A_fix_smoothed_behaviors">fix_smoothed_behaviors</code></td>
<td>

<p>Logical.  If TRUE, when performing smoothing, keep behavior modes fixed for each particle history from what was originally predicted during filtering, 
before smoothing.  This means the particles will be smoothed backwards with each particle weight at each time point being conditioned on the 
behavior predicted in filtering.  Thus, the behavioral agreement with, say, the observed or true behaviors is the same for smoothing as for 
filtering, since behaviors are not allowed to change.  If <code>nstates==1</code>, then automatically <code>fix_smoothed_behaviors=FALSE</code>.
</p>
</td></tr>
<tr><td><code id="EKF_interp_joint_+3A_smooth_parameters">smooth_parameters</code></td>
<td>

<p>Logical.  If TRUE, when performing smoothing, resample the parameters theta as well.
</p>
</td></tr>
<tr><td><code id="EKF_interp_joint_+3A_reg_dt">reg_dt</code></td>
<td>

<p>Length in seconds of each regular interval.
</p>
</td></tr>
<tr><td><code id="EKF_interp_joint_+3A_max_int_wo_obs">max_int_wo_obs</code></td>
<td>

<p>When simulating, the maximum number of intervals of length <code>reg_dt</code> without observations for a given shark that we will simulate.  If this is exceeded, algorithm will wait until next observation and start from there.
Default is NULL, meaning it will be set to <code>maxStep</code>, and thus the algorithm will continue simulating without 
stopping, regardless of when the next observation is.
</p>
</td></tr>
<tr><td><code id="EKF_interp_joint_+3A_resamp_full_hist">resamp_full_hist</code></td>
<td>

<p>Logical.  If TRUE, resample the full particle history, not just all particle times since the last observation, each time resampling occurs.
</p>
</td></tr>
<tr><td><code id="EKF_interp_joint_+3A_compare_with_known">compare_with_known</code></td>
<td>

<p>Logical.  If TRUE, provide a known regular-step dataset from which <code>d</code> is a irregularly-sampled subset, for comparison with particle predictions.
</p>
</td></tr>
<tr><td><code id="EKF_interp_joint_+3A_known_trans_prob">known_trans_prob</code></td>
<td>

<p>If <code>nstates = 2</code>, a matrix of row 2 where each column is the behavior transition probabilities between each opposing behavior, in each region.  
</p>
</td></tr>
<tr><td><code id="EKF_interp_joint_+3A_known_foraging_prob">known_foraging_prob</code></td>
<td>

<p>If <code>nstates = 2</code>, a matrix of the foraging probabilities for each region. 
</p>
</td></tr>
<tr><td><code id="EKF_interp_joint_+3A_known_regular_step_ds">known_regular_step_ds</code></td>
<td>

<p>If <code>compare_with_known = TRUE</code>, the dataset of the original regular-step trajectories. Note: this dataset needs to have 
column <code>date_as_sec</code> (date in seconds) and time gap <code>reg_dt</code> be the same as the set of regular-step intervals
that the EKF is trying to estimate movement at.  Otherwise, the simulated movement locations and the true ones will not
correspond.
</p>
</td></tr>
<tr><td><code id="EKF_interp_joint_+3A_update_eachstep">update_eachstep</code></td>
<td>

<p>Logical.  If TRUE, for regular steps without observations, update the movement parameters based on the simulated movements.  If FALSE, parameters are
only updated based on the simulated movements when a new observation occurs; this means the simulated movements are drawn using the parameter values learned 
since the last observation.
</p>
</td></tr>
<tr><td><code id="EKF_interp_joint_+3A_update_params_for_obs_only">update_params_for_obs_only</code></td>
<td>

<p>Logical.  If TRUE, the particle movement parameters are updated based on simulated movement only at intervals with observed locations.  
If FALSE, particle movement in intermediate steps that are simulated will be used to update as well.
If TRUE, then <code>update_eachstep = FALSE</code>, meaning that parameter updates will be done only for (and at) the steps that represent observations.
If FALSE, then <code>update_eachstep</code> can be either TRUE or FALSE, but simulated steps will be used to update, but 
<code>update_eachstep</code> controls the timing of the the update; if TRUE, it happens one step at a time, and if FALSE, a batch update is done
at observations for the set of simulated steps. 
</p>
</td></tr>
<tr><td><code id="EKF_interp_joint_+3A_output_plot">output_plot</code></td>
<td>

<p>Logical.  If TRUE, a set of diagnostic plots will be printed to a file in <code>output_dir</code>.  Otherwise, it 
will be output to the plotting console.
</p>
</td></tr>
<tr><td><code id="EKF_interp_joint_+3A_loc_pred_plot_conf">loc_pred_plot_conf</code></td>
<td>

<p>Numeric.  Confidence level of ellipse for location prediction error to plot in step-wise diagnostics.
</p>
</td></tr>
<tr><td><code id="EKF_interp_joint_+3A_pdf_prefix">pdf_prefix</code></td>
<td>

<p>String prefix for output PDF filename, if <code>output_plot = TRUE</code>.  Filename will be the prefix followed by a timestamp.
</p>
</td></tr>
<tr><td><code id="EKF_interp_joint_+3A_output_dir">output_dir</code></td>
<td>

<p>Directory for output PDF of diagnostic plots.
</p>
</td></tr>
<tr><td><code id="EKF_interp_joint_+3A_verbose">verbose</code></td>
<td>

<p>Integer, one of 0,1,2,3. Control of verbosity of printouts during simulation.  3 means show both printouts and plots; 2 means show plots only; 
1 means show printouts only; 0 means show no plots or prinouts.  Final plotting will be done regardless.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Many of the returned values are the same as in <code><a href="#topic+EKF_1d_interp_joint">EKF_1d_interp_joint</a></code>.  The ones that differ are listed below. 
</p>
<table>
<tr><td><code>centroids</code></td>
<td>
<p>Input centroids of spatial regions.</p>
</td></tr>
<tr><td><code>nregions</code></td>
<td>
<p>Number of unique regions, as determined by <code>centroids</code></p>
</td></tr></table>
<p>.
</p>
<table>
<tr><td><code>tau_pars</code></td>
<td>
<p>Posterior inverse gamma distribution parameters for the turn angle variance.</p>
</td></tr>
<tr><td><code>cov_err_hist</code></td>
<td>
<p>Overall history of location estimate error draws.</p>
</td></tr>
<tr><td><code>param_draws</code></td>
<td>
<p>Posterior sampled valued of mean of log-velocity and turn.</p>
</td></tr>
<tr><td><code>variance_draws</code></td>
<td>
<p>Posterior sampled valued of variance of log-velocity and turn.</p>
</td></tr>
<tr><td><code>trans_mean_byregion</code></td>
<td>
<p>Posterior estimates of mean behavior switching probabilities from <code>region_trans_draws</code>.</p>
</td></tr>
<tr><td><code>region_counts</code></td>
<td>
<p>Array of total number of simulated regular-step intervals that shark begin movement in each spatial region.  A proxy for the 
total amount of time spent in each region.</p>
</td></tr>
<tr><td><code>euclidean_estimate_true_from_obs</code></td>
<td>
<p>Estimates of true locations by Euclidean and Bezier cubic spline interpolation from observations</p>
</td></tr>
<tr><td><code>error_euclidean_estimate_true_from_obs</code></td>
<td>
<p>Euclidean error from <code>euclidean_estimate_true_from_obs</code> compared to true locations from <code>known_regular_step_ds</code>.</p>
</td></tr>
</table>
<p>The following inputted parameters are returned:
</p>
<table>
<tr><td><code>area_map</code></td>
<td>
</td></tr>
</table>


<h3>Note</h3>

<p>See <code><a href="#topic+sim_trajectory_joint">sim_trajectory_joint</a></code> for a full example of usage.
Video explanation of EKF state-space model by author: <a href="https://youtu.be/SgyhRVUn77k">https://youtu.be/SgyhRVUn77k</a>
</p>


<h3>Author(s)</h3>

<p>Samuel Ackerman
</p>


<h3>References</h3>

<p>Ackerman, Samuel.  &quot;A Probabilistic Characterization of Shark Movement Using Location Tracking Data.&quot;  Temple University doctoral thesis, 2018.  <a href="https://digital.library.temple.edu/digital/collection/p245801coll10/id/499150">https://digital.library.temple.edu/digital/collection/p245801coll10/id/499150</a>
</p>
<p>Carvalho, Carlos M., Johannes, Michael S., Lopes, Hedibert F., and Nicholas G. Polson.  &quot;Particle learning and smoothing.&quot;  Statistical Science, 2010.
</p>

<hr>
<h2 id='low_var_sample'>
Sample particles using low-variance sampling.
</h2><span id='topic+low_var_sample'></span>

<h3>Description</h3>

<p>Sample particles using low-variance sampling.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>low_var_sample(wts, M=length(wts))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="low_var_sample_+3A_wts">wts</code></td>
<td>

<p>Vector of weights.  
</p>
</td></tr>
<tr><td><code id="low_var_sample_+3A_m">M</code></td>
<td>

<p>The number of items to sample. When resampling, should be number of particles <code>npart</code>.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Low-variance sampling guarantees items will be sampled in proportion to their weights.  With random sampling with replacement (<code>sample</code> function), there is some variability in the final proportions of items.
</p>


<h3>Value</h3>

<p>A numeric vector of length <code>M</code>.
</p>


<h3>Author(s)</h3>

<p>Samuel Ackerman
</p>


<h3>References</h3>

<p>James Edward Baker. Reducing bias and inefficiency in the selection algorithm. Proceedings of the Second International Conference on Genetic Algorithms on Genetic Algorithms and Their Application, 1987.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>n &lt;- 20
w &lt;- runif(n)

#can use M != to length(wts)
low_var_sample(wts=w, M=15)

lv &lt;- low_var_sample(wts=w, M=n)

#usual resampling with weights
a &lt;- sample(x=1:n, size=n, prob=w, replace=TRUE)

#the first should be more in proportion to weights
table(lv)/n
table(a)/n
#proportions
w/sum(w)
</code></pre>

<hr>
<h2 id='make_segments'>
Plot path connecting points on ggplot.
</h2><span id='topic+make_segments'></span>

<h3>Description</h3>

<p>Convert x-y coordinates to a <code>data.frame</code> for <code>geom_path</code> plotting on <code><a href="ggplot2.html#topic+ggplot">ggplot</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>make_segments(xy, N=nrow(xy))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="make_segments_+3A_xy">xy</code></td>
<td>

<p>Matrix or <code>data.frame</code> of x-y points to plot as a path.  If there are any rows that are NA-valued,
the resulting path will consist of disconnected segments in those locations.
</p>
</td></tr>
<tr><td><code id="make_segments_+3A_n">N</code></td>
<td>

<p>Number of rows of <code>xy</code> to plot as a path.   By default, the number of rows, so all of <code>xy</code>.
</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Samuel Ackerman
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
#generate toy dataset
library(ggplot2)
d &lt;- as.data.frame(cbind(X=runif(50), Y=runif(50)))

#create segments with some missing lines so will be some gaps)
dseg &lt;- d
dseg[ sample(20),] &lt;- NA

g &lt;- ggplot(d, aes(x=.data$X, y=.data$Y)) + theme_bw() 
g &lt;- g + stat_density2d(aes(fill=after_stat(!!str2lang("density"))), geom="tile", contour=FALSE)
g &lt;- g + scale_fill_gradient(low="white", high="black") + theme(legend.position="bottom")
g &lt;- g + geom_path(data=make_segments(xy=dseg), aes(x=.data$X, y=.data$Y), colour="red", lwd=1.5) 
g

</code></pre>

<hr>
<h2 id='normalize_angle'>
Wrap angle measurements to the interval (-pi, pi).
</h2><span id='topic+normalize_angle'></span>

<h3>Description</h3>

<p>Wrap angle measurements to the interval (-pi, pi).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>normalize_angle(theta)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="normalize_angle_+3A_theta">theta</code></td>
<td>

<p>Numeric vector.
</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Samuel Ackerman
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
x &lt;- rnorm(n=1000, mean=1, sd=2)
xn &lt;- normalize_angle(x)

plot(density(x), xlab="x", main="Unwrapped and wrapped normal density", las=1)
abline(v=1)

#this density is only estimated from -pi to pi
dens_wrapped &lt;- density(xn, from=-pi, to=pi)
lines(dens_wrapped, col="red")

segments(x0=c(-pi, pi), x1=c(-pi, pi), y0=c(0,0), 
	y1=dens_wrapped$y[c(1, length(dens_wrapped$y))],
	col="red") 

legend("topleft", col=c(1,2), legend=c("unwrapped","wrapped"), lty=1)

</code></pre>

<hr>
<h2 id='rug_multicolor'>
Multicolor rug of tick marks.
</h2><span id='topic+rug_multicolor'></span>

<h3>Description</h3>

<p>Adapt <code>rug</code> function to allow tick marks to be of different colors.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rug_multicolor(x, plot_side=3, ticksize=-0.04, col_vec=rep(1, length(x)))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rug_multicolor_+3A_x">x</code></td>
<td>

<p>Numeric vector of axis tick mark locations.
</p>
</td></tr>
<tr><td><code id="rug_multicolor_+3A_plot_side">plot_side</code></td>
<td>

<p>Which side to plot on.  1=bottom, 2=left, 3=top, and 4=right.
</p>
</td></tr>
<tr><td><code id="rug_multicolor_+3A_ticksize">ticksize</code></td>
<td>

<p>Size of tick marks.  Negative values mean ticks are on outside of plot.  This feeds into the <code>tck</code> parameter of the <code><a href="graphics.html#topic+axis">axis</a></code> function.
</p>
</td></tr>
<tr><td><code id="rug_multicolor_+3A_col_vec">col_vec</code></td>
<td>

<p>Vector of color definitions, corresponding to each value of <code>x</code>.
</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Samuel Ackerman
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
d &lt;- data.frame(X=runif(20), Y=runif(20))
plot(d, xlim=c(0,1), ylim=c(0,1))

# draw rug of ticks on each axis where the coordinates are
rug_multicolor(x=d$X, col_vec=colorspace::rainbow_hcl(n=20), ticksize=-0.05)
rug_multicolor(x=d$Y, plot_side=4, col_vec=colorspace::rainbow_hcl(n=20), ticksize=-0.05)
</code></pre>

<hr>
<h2 id='shark_data_longlat'>
Raw shark data spline-interpolated to 90-second intervals
</h2><span id='topic+shark_data_longlat'></span>

<h3>Description</h3>

<p>Raw shark data spline-interpolated to 90-second intervals (matrix)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(shark_data_longlat)</code></pre>


<h3>Format</h3>

<p>The format is:
int [1:226400, 1:7] 1217951746 1217951836 1217951926 1217952016 1217952106 1217952196 1217952286 1217952376 1217952466 1217952556 ...
- attr(*, &quot;dimnames&quot;)=List of 2
..$ : NULL
..$ : chr [1:7] &quot;date_as_sec&quot; &quot;lat&quot; &quot;lon&quot; &quot;t_intervals&quot; ...
</p>


<h3>Source</h3>

<p>Espinoza, Mario, Farrugia, Thomas J., and Christopher G. Lowe. Habitat use, movements
and site fidelity of the gray smooth-hound shark in a newly restored Southern
California estuary. Journal of Experimental Marine Biology and Ecology, 2011.
</p>

<hr>
<h2 id='shark_data_raw'>
Original shark data
</h2><span id='topic+shark_data_raw'></span>

<h3>Description</h3>

<p>Original shark data observations, unequally spaced in time
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(shark_data_raw)</code></pre>


<h3>Format</h3>

<p>A data frame with 68528 observations on the following 12 variables.
</p>

<dl>
<dt><code>tag</code></dt><dd><p>a factor with levels <code>GSH01</code> <code>GSH02</code> <code>GSH03</code> <code>GSH04</code> <code>GSH05</code> <code>GSH06</code> <code>GSH07</code> <code>GSH08</code> <code>GSH09</code> <code>GSH10</code> <code>GSH11</code> <code>GSH12</code> <code>GSH13</code> <code>GSH14</code> <code>GSH15</code> <code>GSH16</code> <code>GSH17</code> <code>GSH18</code> <code>GSH19</code> <code>GSH20</code> <code>GSH21</code> <code>GSH22</code></p>
</dd>
<dt><code>X</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>Y</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>logvelocity</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>bearing.to.east.tonext.rad</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>turn.angle.rad</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>state.guess2</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>prev.guess2</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>time_to_next</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>dx_to_next</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>dy_to_next</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>date_as_sec</code></dt><dd><p>a numeric vector</p>
</dd>
</dl>



<h3>Source</h3>

<p>Espinoza, Mario, Farrugia, Thomas J., and Christopher G. Lowe. Habitat use, movements
and site fidelity of the gray smooth-hound shark in a newly restored Southern
California estuary. Journal of Experimental Marine Biology and Ecology, 2011.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
##stored as separate integer and numeric variables for storage purposes

data(shark_data_raw, package="animalEKF")
shark_data &lt;- do.call(cbind, shark_data_raw)
head(shark_data)

</code></pre>

<hr>
<h2 id='shark_vis_longlat'>
Shiny app for visualizing observed shark movement.
</h2><span id='topic+shark_vis_longlat'></span>

<h3>Description</h3>

<p>Shiny app for visualizing observed shark movement.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>shark_vis_longlat()</code></pre>


<h3>Details</h3>

<p>This shiny app visually illustrates movement of sharks in the dataset referenced in the paper below.  The observations to be visualized are selected in &quot;Range of observed steps&quot;.  They are then linearly interpolated with step size &quot;seconds to interpolate&quot;.  In our paper, we model the impact of other sharks' behaviors in a spatial-temporal neighborhood.  If desired, a spatial neighborhood of desired size &quot;spatial radius&quot; will appear around each shark in the presence of other sharks.  It will flash red if another shark enters in that radius (i.e., they are neighbors).
</p>


<h3>Source</h3>

<p>Espinoza, Mario, Farrugia, Thomas J., and Christopher G. Lowe. Habitat use, movements
and site fidelity of the gray smooth-hound shark in a newly restored Southern
California estuary. Journal of Experimental Marine Biology and Ecology, 2011.
</p>

<hr>
<h2 id='sim_trajectory_joint'>
Simulation and interpolation of trajectories.
</h2><span id='topic+sim_trajectory_joint'></span><span id='topic+interp_trajectory_joint'></span>

<h3>Description</h3>

<p><code>sim_trajectory_joint</code> simulates regular-step trajectories under correlated random walk (CRW).
<code>interp_trajectory_joint</code> interpolates regular steps to irregular ones drawn from a log-normal distribution.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sim_trajectory_joint(area_map=NULL, centroids=matrix(c(0,0), ncol=2), 
                     transition_matrices=list(matrix(c(10,3,2,9), 
                     ncol=2, byrow=TRUE)), 
                     mu0_pars=list(alpha=c(-4 ,-1.6), beta=c(0,0)), 
                     var0_pars=list(alpha=c(1.6,0.16), beta=c(2,0.5)), 
                     N=100, nstates=2, reg_dt=120, gen_irreg=TRUE, 
                     one_d=FALSE, dt_lnorm_mu=log(120), dt_lnorm_sd=1,
                     dt_vals=NULL, starting_polygon=area_map,
                     nsharks=1, interact=FALSE, 
                     interact_pars=list(interacting_sharks=c(1:nsharks),
                     time_radius=60*30, spat_radius=200, min_num_neibs=10,
                     eta_mu=c(2,1), rho_sd=c(0.75, 0.75)),
                     time_dep_trans=FALSE, trans_alpha=c(1, 1.5)) 

interp_trajectory_joint(d, nstates, one_d, dt_lnorm_mu=5, dt_lnorm_sd=1, 
                        dt_vals=NULL, centroids=matrix(c(0,0), ncol=2))



</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sim_trajectory_joint_+3A_area_map">area_map</code></td>
<td>

<p>Shapefile within which the observations are located (optional).  Should be the output of applying <code>sf::st_geometry</code> on an object of class <code>sf</code>.
If input is NULL, a default rectangular shapefile is created.
</p>
</td></tr>
<tr><td><code id="sim_trajectory_joint_+3A_centroids">centroids</code></td>
<td>

<p>Matrix with two columns specifying the centroids of regions.  The number of rows specifies the number of regions.
</p>
</td></tr>
<tr><td><code id="sim_trajectory_joint_+3A_transition_matrices">transition_matrices</code></td>
<td>

<p>A list of 2x2 matrices specifying the Dirichlet parameters for behavior transition probabilities. The list is replicated so it's the length of the number of regions.  If <code>nstates</code>=1 then these are not used since there is only one behavior. 
</p>
</td></tr>
<tr><td><code id="sim_trajectory_joint_+3A_mu0_pars">mu0_pars</code></td>
<td>

<p>List of mean values of alpha (=log-speed if 2-D, and velocity if 1-D) and beta (turn angle, ignored for 1-D) for one or two behavioral states.
</p>
</td></tr>
<tr><td><code id="sim_trajectory_joint_+3A_var0_pars">var0_pars</code></td>
<td>

<p>List of variances of alpha and beta distributions (see <code>mu0_pars</code>).
</p>
</td></tr>
<tr><td><code id="sim_trajectory_joint_+3A_n">N</code></td>
<td>

<p>Number of regular steps to simulate.
</p>
</td></tr>
<tr><td><code id="sim_trajectory_joint_+3A_nstates">nstates</code></td>
<td>

<p>Number of behavioral states.  For now restricted to a maximum of 2.
</p>
</td></tr>
<tr><td><code id="sim_trajectory_joint_+3A_reg_dt">reg_dt</code></td>
<td>

<p>Length in seconds of each regular interval.
</p>
</td></tr>
<tr><td><code id="sim_trajectory_joint_+3A_gen_irreg">gen_irreg</code></td>
<td>

<p>Logical.  If TRUE, then use <code>interp_trajectory_joint</code> to make irregular steps.
</p>
</td></tr>
<tr><td><code id="sim_trajectory_joint_+3A_one_d">one_d</code></td>
<td>

<p>Logical.  If TRUE, then simulation occurs on 1-D line, if FALSE (the default) it is 2-D.
</p>
</td></tr>
<tr><td><code id="sim_trajectory_joint_+3A_dt_lnorm_mu">dt_lnorm_mu</code></td>
<td>

<p>Mean parameter mu of the log-normal distribution to draw time step lengths.  
</p>
</td></tr>
<tr><td><code id="sim_trajectory_joint_+3A_dt_lnorm_sd">dt_lnorm_sd</code></td>
<td>

<p>Standard deviation parameter sigma of the log-normal distribution to draw time step lengths.
</p>
</td></tr>  
<tr><td><code id="sim_trajectory_joint_+3A_starting_polygon">starting_polygon</code></td>
<td>

<p>Polygon to draw starting coordinates in.  This helps if you want the trajectories to start around the same area.
</p>
</td></tr>
<tr><td><code id="sim_trajectory_joint_+3A_nsharks">nsharks</code></td>
<td>

<p>Number of sharks to simulate trajectories for.  If <code>nsharks</code>&gt;1, then joint effects may take place.
</p>
</td></tr>
<tr><td><code id="sim_trajectory_joint_+3A_interact">interact</code></td>
<td>

<p>Logical.  If TRUE, simulate interaction parameters of neighborhood (either 1-D or 2-D).   If <code>nstates</code>=1, automatically set to FALSE.
</p>
</td></tr>
<tr><td><code id="sim_trajectory_joint_+3A_interact_pars">interact_pars</code></td>
<td>

<p>List of interaction priors: 1) <code>interacting_sharks</code> means which of the sharks 1...<code>nsharks</code> are to use interaction parameters; 2) <code>time_radius</code> is the time in seconds, and 3) <code>spat_radius</code> is the spatial radius is meters to consider for spatial neighbors; 4) <code>min_num_neibs</code> is the minimum number of time and spatial radius observations that need to exist to constitute a neighborhood; 5) <code>eta_mu</code> is the vector of mean value for the interaction parameter <code>eta</code>; <code>rho_sd</code> is the vector of standard deviations of the interaction multiplier rho.
</p>
</td></tr>
<tr><td><code id="sim_trajectory_joint_+3A_time_dep_trans">time_dep_trans</code></td>
<td>

<p>Logical. If TRUE, state transition matrices are time-dependent meaning that probability depends on the number of steps a shark has remained in the current state.
</p>
</td></tr>
<tr><td><code id="sim_trajectory_joint_+3A_trans_alpha">trans_alpha</code></td>
<td>

<p>If <code>time_dep_trans</code>=TRUE, the transition alpha parameters for the Dirichlet distribution for drawing behaviors.
</p>
</td></tr>
<tr><td><code id="sim_trajectory_joint_+3A_d">d</code></td>
<td>

<p>Input for <code>interp_trajectory_joint</code>.  An array, usually output by <code>sim_trajectory_joint</code>, of regular-step trajectories.
</p>
</td></tr>
<tr><td><code id="sim_trajectory_joint_+3A_dt_vals">dt_vals</code></td>
<td>

<p>An optional vector of time difference values.  By default is NULL, meaning time gaps will be generated by 
<code>dt_lnorm_mu</code> and <code>dt_lnorm_sd</code>, but supplying a vector to <code>dt_vals</code> lets the user specify
the time gaps rather than having them be randomly generated.  
</p>
</td></tr> 
</table>


<h3>Value</h3>

<table>
<tr><td><code>d</code></td>
<td>

<p>Array of regular-step trajectory locations.
</p>
</td></tr>
<tr><td><code>d_ds</code></td>
<td>

<p>Object <code>d</code> in format <code>data.frame</code>.
</p>
</td></tr>
<tr><td><code>di</code></td>
<td>

<p>If <code>gen_irreg==TRUE</code>, is the non-constant step length locations.
</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Samuel Ackerman
</p>


<h3>Examples</h3>

<pre><code class='language-R'>	

# read shapefile and convert into a Polygon
bolsachica &lt;- sf::st_read(system.file("shapes/FTB_lines.shp", package="animalEKF")[1])
bolsachica &lt;- sf::st_polygonize(bolsachica)

island &lt;- sf::st_read(system.file("shapes/FTB_island.shp", package="animalEKF")[1])
# the actual available room for movement is the area in the water, subtracting the island inside
bolsachica &lt;- sf::st_difference(sf::st_geometry(bolsachica), sf::st_geometry(island))


# sample 5 points approximately equally spaced within the shapefile, as region centroids
regions &lt;- sf::st_sample(x=sf::st_geometry(bolsachica), size=5, type="regular", exact=TRUE)
# extract the coordinates
regions &lt;- as.data.frame(sf::st_coordinates(regions)[, c("X","Y")])

#define Voronoi tessellation tile in which to start shark paths
vortess &lt;- deldir::deldir(x=regions[,"X"], y=regions[,"Y"], wlines="tess", 
						  plotit=FALSE, suppressMsge=TRUE)
# convert these to a set of Polygons, and choose one of them as the starting polygon
vtiles &lt;- sf::st_as_sf(tess2spat(vortess))
sf::st_crs(vtiles) &lt;- sf::st_crs(bolsachica)
# extract only the 3rd tile
# note, want to have the simulation paths spread out, so a given draw may result in
# cramped and thus hard to estimate paths

starting_polygon &lt;- sf::st_sfc(vtiles[[1]][[3]], crs=sf::st_crs(vtiles))
starting_polygon &lt;- sf::st_intersection(sf::st_geometry(bolsachica),
						sf::st_geometry(starting_polygon))

#define list of transition matrices between behaviors

tmat_list &lt;- list(matrix(c(8, 2, 2, 4), ncol=2, byrow=TRUE),
                  matrix(c(1.5*5, 1.5*1, 3, 3), ncol=2, byrow=TRUE),
                  matrix(c(7, 1, 1, 7), ncol=2, byrow=TRUE))

#generate 4-shark simulated trajectory with 100 regular steps of length 120 seconds.  
#Sharks 3 and 4 will be interacting with the others, but 1 and 2 will not.
			  
nsharks &lt;- 4	
		
#simulate trajectory
#setting gen_irreg=TRUE generates an irregular trajectory from the regular-step one
#with the log-normal specified in dt_lnorm_mu and dt_lnorm_sd
#sim_4sharks$di would contain the irregular dataset
#otherwise, say you wanted to try different interpolations, you can use the same regular
#step from sim_trajectory_joint and then interpolate separately with interp_trajectory_joint.

#make simulated trajectories all start in the same area so they will be close enough to be
#interacting, for the purposes of this exercise
#note that the simulation may time out trying to draw points in this starting polygon that end 
#up in the shapefile boundary

nsteps_sim &lt;- 100
reg_dt &lt;- 120



sim_4sharks &lt;- sim_trajectory_joint(area_map=sf::st_geometry(bolsachica), centroids=regions, 
                                    transition_matrices=tmat_list, nsharks=nsharks,
                                    mu0_pars=list(alpha=c(-4 ,-1.6), beta=c(0,0)), 
                                    var0_pars=list(alpha=c(1,0.25), beta=c(1,.25)),
                                    N=nsteps_sim, nstates=2, reg_dt=reg_dt,
                                    gen_irreg=FALSE, one_d=FALSE,
                                    starting_polygon=starting_polygon, interact=TRUE, 
                                    interact_pars=list(interacting_sharks=c(3:4),
                                    time_radius=60*30, spat_radius=150,
                                    min_num_neibs=10,
                                    eta_mu=c(2,1), rho_sd=c(0.75, 0.75)),
                                    time_dep_trans=FALSE, 
                                    dt_lnorm_mu=log(120), dt_lnorm_sd=0.4) 




#plot trajectories

shark_names &lt;- dimnames(sim_4sharks$d)[[ 3 ]]
shark_colors &lt;- 2:5
names(shark_colors) &lt;- shark_names


sp::plot(bolsachica, main="Full trajectories")
deldir::plot.deldir(vortess, wlines="tess", add=TRUE)

for (ss in shark_names) {
    lines(sim_4sharks$d[,c("X","Y"), ss], col=shark_colors[ss])
}
		   
#now interpolate to uneven steps with lognormal mean log(120) (so they are on 
#average the same as the regular steps and sd=0.4
#d is the regular step, di is irregular

#if want to interpolate separately.  Otherwise just set gen_irreg=TRUE above
#this is so you can interpolate a dataset not generated by sim_trajectory_joint
#if gen_irreg=TRUE in sim_trajectory_joint,
#interp_ds will be returned as the 'di' object
				   
interp_ds &lt;- interp_trajectory_joint(d=sim_4sharks$d, nstates=2, 
                                     one_d=FALSE, 
                                     dt_lnorm_mu=log(reg_dt),
                                     dt_lnorm_sd=0.4,
                                     centroids=regions)	



#now plot observed ones, may differ
sp::plot(bolsachica, main="Observed trajectories")
deldir::plot.deldir(vortess, wlines="tess", add=TRUE)

for (ss in shark_names) {
    lines(interp_ds[ interp_ds$tag == ss ,c("X","Y")], col=shark_colors[ss])
}


	
		
#try to recover EKF with steps at the original 120 seconds
#use the original simulated transition and foraging probabilities for comparison		
		
		
#intial values for some parameters
tau_pars_init &lt;- c(8, 14, 10,1) #2
sigma_pars_init &lt;- c(5, 8, 8, 3)

#measurement error

bmat &lt;- matrix(c(1, -0.3, -0.3, 1), ncol=2)
Errvar_init1 &lt;-5*20*bmat
Errvar_init2 &lt;- 15*20*bmat

#particle error
Particle_err_init &lt;- 0.5*20*bmat
		
# only estimate movement on first 5 steps
# for better results, npart should be set higher, like 150 or more
nsteps_estimate &lt;- 5
npart &lt;- 15		
		
		
#again, if you use gen_irreg=TRUE in sim_trajectory_joint,
#the input 'd' argument should be sim_4sharks$di or interp_ds

#NOTE: user should set output_plot=TRUE to see PDF,
#for purposes of package testing we set it to FALSE 
# if FALSE, plots will still appear in the console


ekf_interp_mod &lt;- EKF_interp_joint(d=interp_ds, npart=npart, 
                                   area_map=bolsachica,
                                   state_favor=c(1,2),
                                   centroids=regions, 
                                   sigma_pars=sigma_pars_init,
                                   tau_pars=tau_pars_init,
                                   Errvar0=list(Errvar_init1, Errvar_init2),
                                   Particle_errvar0=Particle_err_init,
                                   mu0_pars=list(alpha=c(-4 ,-1.3), beta=c(0,0)), 
                                   truncate=TRUE, 
                                   neff_sample=0.75, dirichlet_init=c(8,2,2,4), 
                                   smoothing=TRUE, fix_smoothed_behaviors=FALSE, 
                                   time_dep_trans=FALSE, resamp_full_hist=FALSE, 
                                   nstates=2, reg_dt=reg_dt, interact=TRUE, 
                                   maxStep=nsteps_estimate, update_eachstep=TRUE, 
                                   compare_with_known=TRUE, 
                                   known_trans_prob=sim_4sharks$true_transition_prob, 
                                   known_foraging_prob=sim_4sharks$true_foraging_prob, 
                                   known_regular_step_ds=sim_4sharks$d_ds,
                                   output_plot=FALSE)		
				   

#simulate one-dimensional movement for 1 robot (shark)
#here we use gen_irreg=TRUE instead of generating a separate interpolation object

one_d &lt;- sim_trajectory_joint(centroids=NULL, N=nsteps_sim,
                              mu0_pars=list(alpha=c(4, 9)),
                              var0_pars=list(alpha=c(1, 1)),
                              transition_matrices=tmat_list[[ 1 ]], nstates=2,
                              reg_dt=reg_dt, gen_irreg=TRUE, one_d=TRUE,
                              dt_lnorm_mu=log(120), dt_lnorm_sd=0.55)




#measurement error
bmat &lt;- matrix(1)
Errvar_init1 &lt;-1*bmat
Errvar_init2 &lt;-3*bmat


#particle error
Particle_err_init &lt;- 0.1*bmat



ekf_1d &lt;- EKF_1d_interp_joint(d=one_d$di, npart=npart,  maxStep=nsteps_estimate, 
                              state_favor=c(1,1), nstates=2, lowvarsample=TRUE, 
                              neff_sample=1, time_dep_trans=FALSE, reg_dt=reg_dt, 
                              max_int_wo_obs=15, resamp_full_hist=FALSE, 
                              alpha0_pars=list(mu0=c(4, 9), V0=c(0.25, 0.25)),
                              sigma_pars=sigma_pars_init,
                              Errvar0=list(Errvar_init1, Errvar_init2),
                              Particle_errvar0=Particle_err_init,
                              compare_with_known=TRUE, 
                              known_trans_prob=one_d$true_transition_prob, 
                              known_foraging_prob=one_d$true_foraging_prob, 
                              known_regular_step_ds=one_d$d_ds, update_eachstep=TRUE,
                              smoothing=TRUE, output_plot=FALSE)							  
				   
				   
				   
</code></pre>

<hr>
<h2 id='spline_interp'>
Bezier spline interpolation of observations.
</h2><span id='topic+spline_interp'></span>

<h3>Description</h3>

<p>Calculate a Bezier spline interpolation of irregular observations to regular-length time intervals.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>spline_interp(di, area_map=NULL, t_reg=NULL, reg_dt=120,
              max_dt_wo_obs=60*30, maxStep=NULL, 
              centroids=matrix(c(0,0), ncol=2),
              nstates=2, spline_deg=3, split_logv=-3)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="spline_interp_+3A_di">di</code></td>
<td>

<p>Object of class <code>data.frame</code> containing irregular-spaced observations.  Dataset must contain the following fields: 1) <code>"X"</code> and <code>"Y"</code>: X and Y location coordinates, 
2) <code>"date_as_sec"</code>: time/date of observation as seconds since an epoch.  <code>"time_to_next"</code> should also be included, but will be calculated if not.  Also <code>"tag"</code> (animal
identifier) should be included as well.  If not, all observations are assumed to be of the same animal.
This can be generated from <code>sim_trajectory_joint</code> with <code>gen_irreg=TRUE</code>. 
</p>
</td></tr>
<tr><td><code id="spline_interp_+3A_area_map">area_map</code></td>
<td>

<p>Shapefile that all interpolated points should be inside of.
</p>
</td></tr>
<tr><td><code id="spline_interp_+3A_t_reg">t_reg</code></td>
<td>

<p>Desired time steps (must have a constant difference) to interpolate to.  If is given, the default value of
<code>reg_dt</code> is overridden.  Will be truncated to the set of values within the range of observed values of
<code>di$date_as_sec</code>.
</p>
</td></tr>
<tr><td><code id="spline_interp_+3A_reg_dt">reg_dt</code></td>
<td>

<p>Length in seconds of each regular interval.
</p>
</td></tr>
<tr><td><code id="spline_interp_+3A_max_dt_wo_obs">max_dt_wo_obs</code></td>
<td>

<p>When interpolating, the maximum time length without observations for a given shark that we will interpolate.  If this is exceeded, algorithm will wait until next observation and start from there.  
</p>
</td></tr>
<tr><td><code id="spline_interp_+3A_maxstep">maxStep</code></td>
<td>

<p>Maximum number of regular steps to interpolate.
</p>
</td></tr>
<tr><td><code id="spline_interp_+3A_centroids">centroids</code></td>
<td>

<p>Matrix with two columns specifying the centroids of regions.  If <code>NULL</code>, only one region will be used.
</p>
</td></tr>
<tr><td><code id="spline_interp_+3A_nstates">nstates</code></td>
<td>

<p>Number of behavioral states.  For now restricted to a maximum of 2.
</p>
</td></tr>
<tr><td><code id="spline_interp_+3A_spline_deg">spline_deg</code></td>
<td>

<p>Degree of spline.  The default is 3, or a cubic.  Every <code>spline_deg</code>+1 observations will be used to construct one spline segment.
</p>
</td></tr>
<tr><td><code id="spline_interp_+3A_split_logv">split_logv</code></td>
<td>

<p>If <code>nstates</code>=2, state 1 from the interpolated values will be designated by the logvelocity being &lt; <code>split_logv</code>.
</p>
</td></tr>
</table>


<h3>Value</h3>

<table>
<tr><td><code>d</code></td>
<td>
<p>Array of regular step locations.</p>
</td></tr>
<tr><td><code>di</code></td>
<td>
<p>Original irregular-step dataset.</p>
</td></tr>
<tr><td><code>shark_names</code></td>
<td>
<p>Vector of the names of sharks in the dataset.</p>
</td></tr>
<tr><td><code>d_ds</code></td>
<td>
<p>Output regular-step dataset <code>d</code> in form <code>data.frame</code>.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Samuel Ackerman
</p>


<h3>References</h3>

<p>Bezier R package.  Aaron Olsen.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#can also be 'di' output of sim_trajectory_joint (set gen_irreg=TRUE)

di &lt;- data.frame(X=runif(n=9), Y=runif(n=9),
                 time_to_next=c(2,4,15,8,5,18,3,5,NA))
di$date_as_sec &lt;- c(0, cumsum(di$time_to_next[-9]))
region_centroids &lt;- cbind(X=runif(2), Y=runif(2))

#one log observation with dt =18 &gt; 16 will be omitted
spl &lt;- spline_interp(di=di, area_map=NULL, reg_dt=3, max_dt_wo_obs=16, maxStep=NULL, 
                     centroids=region_centroids, nstates=2, spline_deg=3, split_logv=-3)

plot(di[,c("X","Y")], xlim=c(0,1), ylim=c(0,1), type="b", las=1,
     "Observations interpolated by regular interval spline")
lines(spl$d_ds[,c("X","Y")], type="l", col="red")
legend("topleft", col=1:2, legend=c("observations","spline"), lty=1)


</code></pre>

<hr>
<h2 id='tess2spat'>
Convert Voronoi tessellation tiles to a shapefile.
</h2><span id='topic+tess2spat'></span>

<h3>Description</h3>

<p>Convert Voronoi tessellation tiles to a shapefile.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tess2spat(obj, idvec=NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tess2spat_+3A_obj">obj</code></td>
<td>

<p>Voronoi tessellation object created through function <code>deldir</code>.
</p>
</td></tr>
<tr><td><code id="tess2spat_+3A_idvec">idvec</code></td>
<td>

<p>Optional vector of ids for output shapefile polygons.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Object of class <code>SpatialPolygons</code>.
</p>


<h3>Author(s)</h3>

<p>Samuel Ackerman
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
library(deldir)
library(sp)

vortess &lt;- deldir(x=runif(8), y=runif(8), plotit=FALSE, suppressMsge=TRUE)
old_pars &lt;- par(mfcol=par()$mfcol)

par(mfcol=c(1,2))
deldir::plot.deldir(vortess, wlines="tess", xlim=c(0,1), ylim=c(0,1))
vortess_shape &lt;- tess2spat(obj=vortess)
plot(vortess_shape)
par(old_pars)

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
