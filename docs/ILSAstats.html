<!DOCTYPE html><html lang="en"><head><title>Help for package ILSAstats</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {ILSAstats}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#center'><p>Centering</p></a></li>
<li><a href='#icc'><p>Intraclass Correlation Coefficient</p></a></li>
<li><a href='#lmerPV'><p>Linear Mixed-Models with Plausible Values</p></a></li>
<li><a href='#repcreate'><p>Creation of Replicate Weights</p></a></li>
<li><a href='#repdata'><p>Simulated data with 5000 cases</p></a></li>
<li><a href='#repglm'><p>Generalized Linear Models with Replicate Weights</p></a></li>
<li><a href='#replm'><p>Linear Models with Replicate Weights</p></a></li>
<li><a href='#repmean'><p>Mean, Variance and Standard Deviation with Replicate Weights</p></a></li>
<li><a href='#repmeandif'><p>Mean Difference of Independent Samples with Replicate Weights</p></a></li>
<li><a href='#repprop'><p>Proportions with Replicate Weights</p></a></li>
<li><a href='#repquant'><p>Quantiles with Replicate Weights</p></a></li>
<li><a href='#reprho'><p>Correlations with Replicate Weights</p></a></li>
<li><a href='#repse'><p>Standard Error for Estimates with Replicate Weights and Plausible Values</p></a></li>
<li><a href='#repsetup'><p>Setup for Analysis with Replicate Weights</p></a></li>
<li><a href='#WeMixPV'><p>Survey Weighted Mixed-Effects Models with Plausible Values</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Statistics for International Large-Scale Assessments (ILSA)</td>
</tr>
<tr>
<td>Version:</td>
<td>0.3.7</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Andrés Christiansen &lt;andres.christiansen@iea-hamburg.de&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Calculates point estimates and standard errors using replicate weights and plausible values for International Large-Scale Assessments (ILSA), including: means, proportions, quantiles, correlations, singlelevel regressions, and multilevel regressions.</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>LazyDataCompression:</td>
<td>xz</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.3.2</td>
</tr>
<tr>
<td>Suggests:</td>
<td>wCorr, lme4, MuMIn, WeMix</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.5.0)</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL (&ge; 3)</a></td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2025-02-20 18:18:32 UTC; andreschristiansen</td>
</tr>
<tr>
<td>Author:</td>
<td>Andrés Christiansen
    <a href="https://orcid.org/0000-0003-2692-7843"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [aut, cre],
  Andrés Strello <a href="https://orcid.org/0000-0002-5613-8338"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [ctb],
  Pablo Torres [ctb]</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2025-02-21 11:40:39 UTC</td>
</tr>
</table>
<hr>
<h2 id='center'>Centering</h2><span id='topic+center'></span><span id='topic+grand.mean'></span><span id='topic+group.mean'></span><span id='topic+getgroup.mean'></span>

<h3>Description</h3>

<p>Centers a vector, a matrix or a data frame to the grand mean or the group mean.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>center(X, group = NULL, grandmean = NULL, groupmean = NULL, wt = NULL)

grand.mean(x, wt = NULL)

group.mean(x, group, wt = NULL)

getgroup.mean(x, group, wt = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="center_+3A_x">X</code></td>
<td>
<p>a matrix or a data frame.</p>
</td></tr>
<tr><td><code id="center_+3A_group">group</code></td>
<td>
<p>a vector indicating the group for centering.</p>
</td></tr>
<tr><td><code id="center_+3A_grandmean">grandmean</code></td>
<td>
<p>a numeric or character vector indicating the number or the
the names of columns of <code>X</code> to which grand-mean should be applied.</p>
</td></tr>
<tr><td><code id="center_+3A_groupmean">groupmean</code></td>
<td>
<p>a numeric or character vector indicating the number or the
the names of columns of <code>X</code> to which group-mean should be applied.</p>
</td></tr>
<tr><td><code id="center_+3A_wt">wt</code></td>
<td>
<p>a numeric vector of weights.</p>
</td></tr>
<tr><td><code id="center_+3A_x">x</code></td>
<td>
<p>a vector, a matrix or a data frame.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a data frame, or a vector.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Less data for shorter example
repdata2 &lt;- repdata[1:10,c(1:3,6:10,51)]

### One variable ----

# grand-mean
grand.mean(repdata2$item01)
grand.mean(repdata2$item01,wt = repdata2$wt)

# group-mean
group.mean(repdata2$item01,group = repdata2$GROUP)
group.mean(repdata2$item01,group = repdata2$GROUP,wt = repdata2$wt)

### More than one variable with the same rule ----

# grand-mean
grand.mean(repdata2[,4:8])
grand.mean(repdata2[,4:8],wt = repdata2$wt)

# group-mean
group.mean(repdata2[,4:8],group = repdata2$GROUP)
group.mean(repdata2[,4:8],group = repdata2$GROUP,wt = repdata2$wt)

### More than one variable with different rules ----
center(repdata2, group = repdata2$GROUP, grandmean = 4:5, groupmean = 6:8, wt = repdata2$wt)
center(repdata2, group = repdata2$GROUP, grandmean = 6:8, groupmean = 4:5, wt = repdata2$wt)

center(repdata2, group = repdata2$GROUP, wt = repdata2$wt,
       grandmean = paste0("item0",1:3), groupmean = paste0("item0",4:5))
center(repdata2, group = repdata2$GROUP, wt = repdata2$wt,
       grandmean = paste0("item0",4:5), groupmean = paste0("item0",1:3))
</code></pre>

<hr>
<h2 id='icc'>Intraclass Correlation Coefficient</h2><span id='topic+icc'></span>

<h3>Description</h3>

<p>Calculates the intraclass correlation coefficient (ICC) fitting a
linear mixed-effects model using <a href="lme4.html#topic+lmer">lmer</a>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>icc(x, PV = FALSE, group, data, weights = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="icc_+3A_x">x</code></td>
<td>
<p>a string vector specifying variable names (within <code>data</code>).</p>
</td></tr>
<tr><td><code id="icc_+3A_pv">PV</code></td>
<td>
<p>a logical value indicating if the variables in <code>x</code> are
plausible values.</p>
</td></tr>
<tr><td><code id="icc_+3A_group">group</code></td>
<td>
<p>a string specifying the variable name (within <code>data</code>) to be used for grouping.</p>
</td></tr>
<tr><td><code id="icc_+3A_data">data</code></td>
<td>
<p>an optional data frame containing the variables named in
<code>formula</code>.  By default the variables are taken from the
environment from which <code>lmer</code> is called. While <code>data</code> is
optional, the package authors <em>strongly</em> recommend its use,
especially when later applying methods such as <code>update</code> and
<code>drop1</code> to the fitted model (<em>such methods are not
guaranteed to work properly if <code>data</code> is omitted</em>). If
<code>data</code> is omitted, variables will be taken from the environment
of <code>formula</code> (if specified as a formula) or from the parent
frame (if specified as a character vector).</p>
</td></tr>
<tr><td><code id="icc_+3A_weights">weights</code></td>
<td>
<p>an optional vector of &lsquo;prior weights&rsquo; to be used
in the fitting process.  Should be <code>NULL</code> or a numeric vector.
Prior <code>weights</code> are <em>not</em> normalized or standardized in
any way.  In particular, the diagonal of the residual covariance
matrix is the squared residual standard deviation parameter
<code><a href="lme4.html#topic+sigma">sigma</a></code> times the vector of inverse <code>weights</code>.
Therefore, if the <code>weights</code> have relatively large magnitudes,
then in order to compensate, the <code><a href="lme4.html#topic+sigma">sigma</a></code> parameter will
also need to have a relatively large magnitude.</p>
</td></tr>
<tr><td><code id="icc_+3A_...">...</code></td>
<td>

<p>Arguments passed on to <code><a href="lme4.html#topic+lmer">lme4::lmer</a></code>
</p>

<dl>
<dt><code>formula</code></dt><dd><p>a two-sided linear formula object describing both the
fixed-effects and random-effects part of the model, with the
response on the left of a <code>~</code> operator and the terms, separated
by <code>+</code> operators, on the right.  Random-effects terms are
distinguished by vertical bars (<code>|</code>) separating expressions
for design matrices from grouping factors.  Two vertical bars
(<code>||</code>) can be used to specify multiple uncorrelated random
effects for the same grouping variable. 
(Because of the way it is implemented, the <code>||</code>-syntax <em>works
only for design matrices containing numeric (continuous) predictors</em>;
to fit models with independent categorical effects, see <code><a href="lme4.html#topic+dummy">dummy</a></code>
or the <code>lmer_alt</code> function from the <a href="https://CRAN.R-project.org/package=afex"><span class="pkg">afex</span></a> package.)
</p>
</dd>
<dt><code>REML</code></dt><dd><p>logical scalar - Should the estimates be chosen to
optimize the REML criterion (as opposed to the log-likelihood)?</p>
</dd>
<dt><code>control</code></dt><dd><p>a list (of correct class, resulting from
<code><a href="lme4.html#topic+lmerControl">lmerControl</a>()</code> or <code><a href="lme4.html#topic+glmerControl">glmerControl</a>()</code>
respectively) containing control parameters, including the nonlinear
optimizer to be used and parameters to be passed through to the
nonlinear optimizer, see the <code>*lmerControl</code> documentation for
details.</p>
</dd>
<dt><code>start</code></dt><dd><p>a named <code><a href="base.html#topic+list">list</a></code> of starting values for the
parameters in the model.  For <code>lmer</code> this can be a numeric
vector or a list with one component named <code>"theta"</code>.</p>
</dd>
<dt><code>verbose</code></dt><dd><p>integer scalar.  If <code>&gt; 0</code> verbose output is
generated during the optimization of the parameter estimates.  If
<code>&gt; 1</code> verbose output is generated during the individual
penalized iteratively reweighted least squares (PIRLS) steps.</p>
</dd>
<dt><code>subset</code></dt><dd><p>an optional expression indicating the subset of the rows
of <code>data</code> that should be used in the fit. This can be a logical
vector, or a numeric vector indicating which observation numbers are
to be included, or a character vector of the row names to be
included.  All observations are included by default.</p>
</dd>
<dt><code>na.action</code></dt><dd><p>a function that indicates what should happen when the
data contain <code>NA</code>s.  The default action (<code>na.omit</code>,
inherited from the 'factory fresh' value of
<code>getOption("na.action")</code>) strips any observations with any
missing values in any variables.</p>
</dd>
<dt><code>offset</code></dt><dd><p>this can be used to specify an <em>a priori</em> known
component to be included in the linear predictor during
fitting. This should be <code>NULL</code> or a numeric vector of length
equal to the number of cases.  One or more <code><a href="stats.html#topic+offset">offset</a></code>
terms can be included in the formula instead or as well, and if more
than one is specified their sum is used.  See
<code><a href="stats.html#topic+model.offset">model.offset</a></code>.</p>
</dd>
<dt><code>contrasts</code></dt><dd><p>an optional list. See the <code>contrasts.arg</code> of
<code>model.matrix.default</code>.</p>
</dd>
<dt><code>devFunOnly</code></dt><dd><p>logical - return only the deviance evaluation
function. Note that because the deviance function operates on
variables stored in its environment, it may not return
<em>exactly</em> the same values on subsequent calls (but the results
should always be within machine tolerance).</p>
</dd>
</dl>
</td></tr>
</table>


<h3>Value</h3>

<p>a numeric value or a list.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># ICC of one variable
icc(x = "Math1",group = "GROUP", weights = repdata$wt, data = repdata)


# ICC of more than one variable
icc(x = c("Math1","Math2","Math3","Math4","Math5","SES"),
    group = "GROUP", weights = repdata$wt, data = repdata)


# ICC of PVs
icc(x = c("Math1","Math2","Math3","Math4","Math5"), PV = TRUE,
    group = "GROUP", weights = repdata$wt, data = repdata)
</code></pre>

<hr>
<h2 id='lmerPV'>Linear Mixed-Models with Plausible Values</h2><span id='topic+lmerPV'></span>

<h3>Description</h3>

<p>Fits a linear mixed-effects model using <a href="lme4.html#topic+lmer">lmer</a> and plausible values.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lmerPV(
  formula,
  data = NULL,
  weights = NULL,
  pvs,
  relatedpvs = TRUE,
  grandmean = NULL,
  groupmean = NULL,
  group = NULL,
  nullmodel = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="lmerPV_+3A_formula">formula</code></td>
<td>
<p>a two-sided linear formula object describing both the
fixed-effects and random-effects part of the model, with the
response on the left of a <code>~</code> operator and the terms, separated
by <code>+</code> operators, on the right.  Random-effects terms are
distinguished by vertical bars (<code>|</code>) separating expressions
for design matrices from grouping factors.  Two vertical bars
(<code>||</code>) can be used to specify multiple uncorrelated random
effects for the same grouping variable. 
(Because of the way it is implemented, the <code>||</code>-syntax <em>works
only for design matrices containing numeric (continuous) predictors</em>;
to fit models with independent categorical effects, see <code><a href="lme4.html#topic+dummy">dummy</a></code>
or the <code>lmer_alt</code> function from the <a href="https://CRAN.R-project.org/package=afex"><span class="pkg">afex</span></a> package.)
</p>
</td></tr>
<tr><td><code id="lmerPV_+3A_data">data</code></td>
<td>
<p>an optional data frame containing the variables named in
<code>formula</code>.  By default the variables are taken from the
environment from which <code>lmer</code> is called. While <code>data</code> is
optional, the package authors <em>strongly</em> recommend its use,
especially when later applying methods such as <code>update</code> and
<code>drop1</code> to the fitted model (<em>such methods are not
guaranteed to work properly if <code>data</code> is omitted</em>). If
<code>data</code> is omitted, variables will be taken from the environment
of <code>formula</code> (if specified as a formula) or from the parent
frame (if specified as a character vector).</p>
</td></tr>
<tr><td><code id="lmerPV_+3A_weights">weights</code></td>
<td>
<p>an optional vector of &lsquo;prior weights&rsquo; to be used
in the fitting process.  Should be <code>NULL</code> or a numeric vector.
Prior <code>weights</code> are <em>not</em> normalized or standardized in
any way.  In particular, the diagonal of the residual covariance
matrix is the squared residual standard deviation parameter
<code><a href="lme4.html#topic+sigma">sigma</a></code> times the vector of inverse <code>weights</code>.
Therefore, if the <code>weights</code> have relatively large magnitudes,
then in order to compensate, the <code><a href="lme4.html#topic+sigma">sigma</a></code> parameter will
also need to have a relatively large magnitude.</p>
</td></tr>
<tr><td><code id="lmerPV_+3A_pvs">pvs</code></td>
<td>
<p>a list indicating which variables from <code>formula</code>
should be replaced by which plausible values variables. For more details
check the examples.</p>
</td></tr>
<tr><td><code id="lmerPV_+3A_relatedpvs">relatedpvs</code></td>
<td>
<p>a logical value indicating if <code>pvs</code> are drawn
from the same model, and have the same number of plausible values.
If <code>TRUE</code> (default), a total of <code class="reqn">n</code> estimations will be done,
where <code class="reqn">n</code> is the number of plausible values for each plausible value variable.
If <code>FALSE</code>, a total of <code class="reqn">n_1 \times n_2 \times n_...</code>
estimations will be done, where <code class="reqn">n_i</code> is the number of plausible values
in each plausible value variable.</p>
</td></tr>
<tr><td><code id="lmerPV_+3A_grandmean">grandmean</code></td>
<td>
<p>a character vector indicating the names of columns of
<code>data</code> to which grand-mean should be applied.</p>
</td></tr>
<tr><td><code id="lmerPV_+3A_groupmean">groupmean</code></td>
<td>
<p>a character vector indicating the names of columns of
<code>data</code> to which group-mean should be applied.</p>
</td></tr>
<tr><td><code id="lmerPV_+3A_group">group</code></td>
<td>
<p>a string specifying the variable name (within <code>df</code>) to be
used for grouping. Categories in <code>group</code> are treated as independent, e.g.,
countries.</p>
</td></tr>
<tr><td><code id="lmerPV_+3A_nullmodel">nullmodel</code></td>
<td>
<p>a logical value indicating if the null model should also be estimated.</p>
</td></tr>
<tr><td><code id="lmerPV_+3A_...">...</code></td>
<td>

<p>Arguments passed on to <code><a href="lme4.html#topic+lmer">lme4::lmer</a></code>
</p>

<dl>
<dt><code>REML</code></dt><dd><p>logical scalar - Should the estimates be chosen to
optimize the REML criterion (as opposed to the log-likelihood)?</p>
</dd>
<dt><code>control</code></dt><dd><p>a list (of correct class, resulting from
<code><a href="lme4.html#topic+lmerControl">lmerControl</a>()</code> or <code><a href="lme4.html#topic+glmerControl">glmerControl</a>()</code>
respectively) containing control parameters, including the nonlinear
optimizer to be used and parameters to be passed through to the
nonlinear optimizer, see the <code>*lmerControl</code> documentation for
details.</p>
</dd>
<dt><code>start</code></dt><dd><p>a named <code><a href="base.html#topic+list">list</a></code> of starting values for the
parameters in the model.  For <code>lmer</code> this can be a numeric
vector or a list with one component named <code>"theta"</code>.</p>
</dd>
<dt><code>verbose</code></dt><dd><p>integer scalar.  If <code>&gt; 0</code> verbose output is
generated during the optimization of the parameter estimates.  If
<code>&gt; 1</code> verbose output is generated during the individual
penalized iteratively reweighted least squares (PIRLS) steps.</p>
</dd>
<dt><code>subset</code></dt><dd><p>an optional expression indicating the subset of the rows
of <code>data</code> that should be used in the fit. This can be a logical
vector, or a numeric vector indicating which observation numbers are
to be included, or a character vector of the row names to be
included.  All observations are included by default.</p>
</dd>
<dt><code>na.action</code></dt><dd><p>a function that indicates what should happen when the
data contain <code>NA</code>s.  The default action (<code>na.omit</code>,
inherited from the 'factory fresh' value of
<code>getOption("na.action")</code>) strips any observations with any
missing values in any variables.</p>
</dd>
<dt><code>offset</code></dt><dd><p>this can be used to specify an <em>a priori</em> known
component to be included in the linear predictor during
fitting. This should be <code>NULL</code> or a numeric vector of length
equal to the number of cases.  One or more <code><a href="stats.html#topic+offset">offset</a></code>
terms can be included in the formula instead or as well, and if more
than one is specified their sum is used.  See
<code><a href="stats.html#topic+model.offset">model.offset</a></code>.</p>
</dd>
<dt><code>contrasts</code></dt><dd><p>an optional list. See the <code>contrasts.arg</code> of
<code>model.matrix.default</code>.</p>
</dd>
<dt><code>devFunOnly</code></dt><dd><p>logical - return only the deviance evaluation
function. Note that because the deviance function operates on
variables stored in its environment, it may not return
<em>exactly</em> the same values on subsequent calls (but the results
should always be within machine tolerance).</p>
</dd>
</dl>
</td></tr>
</table>


<h3>Value</h3>

<p>a list.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Null model - with PVs
## Named list, with element names matching formula variables
pvs = list(MATH = paste0("Math",1:5))


m1 &lt;- lmerPV(formula = MATH ~ 1 + (1|GROUP), # Intercept varies across GROUP
      pvs = pvs, # Named list
      data = repdata, # Data frame
      weights = repdata$wt) # Weights vector
m1

## Fixed effects
m1$fixef

## Random effects
m1$ranef

## Models for each PV
summary(m1$models)

# Multiple regression
## Named list, with element names matching formula variables
pvs = list(MATH = paste0("Math",1:5))


m2 &lt;- lmerPV(formula = MATH ~ 1 + GENDER + SES + schoolSES + (1|GROUP),
             pvs = pvs, # Named list
             data = repdata, # Data frame
             weights = repdata$wt) # Weights vector
m2

# Multiple regression with grandmean centering
## Named list, with element names matching formula variables
pvs = list(MATH = paste0("Math",1:5))


m3 &lt;- lmerPV(formula = MATH ~ 1 + GENDER + SES + schoolSES + (1|GROUP),
             pvs = pvs, # Named list
             data = repdata, # Data frame
             weights = repdata$wt,
             grandmean = c("SES","schoolSES"))
m3

# Multiple regression with groupmean centering
## Named list, with element names matching formula variables
pvs = list(MATH = paste0("Math",1:5))


m4 &lt;- lmerPV(formula = MATH ~ 1 + GENDER + SES + schoolSES + (1|GROUP),
             pvs = pvs, # Named list
             data = repdata, # Data frame
             weights = repdata$wt,
             grandmean = "schoolSES",
             groupmean = "SES",
             group = repdata$GROUP)
m4



</code></pre>

<hr>
<h2 id='repcreate'>Creation of Replicate Weights</h2><span id='topic+repcreate'></span>

<h3>Description</h3>

<p>Creates replicate weights given jackknife replicates and jackknife zones.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>repcreate(
  df,
  wt,
  jkzone,
  jkrep,
  repwtname,
  reps = NULL,
  method = c("TIMSS", "PIRLS", "ICILS", "ICCS")
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="repcreate_+3A_df">df</code></td>
<td>
<p>a data frame.</p>
</td></tr>
<tr><td><code id="repcreate_+3A_wt">wt</code></td>
<td>
<p>a string specifying the name of the column (within <code>df</code>) with the
total weights.</p>
</td></tr>
<tr><td><code id="repcreate_+3A_jkzone">jkzone</code></td>
<td>
<p>a string specifying the name of the column in <code>df</code>
that contains the jackknife zone information.</p>
</td></tr>
<tr><td><code id="repcreate_+3A_jkrep">jkrep</code></td>
<td>
<p>a string specifying the name of the column in <code>df</code>
that contains the jackknife replicate information.</p>
</td></tr>
<tr><td><code id="repcreate_+3A_repwtname">repwtname</code></td>
<td>
<p>a string specifying the variable names for the
replicate weights.</p>
</td></tr>
<tr><td><code id="repcreate_+3A_reps">reps</code></td>
<td>
<p>an integer indicating the number of replications to be created.
If <code>NULL</code> the maximum number of zones will be used.</p>
</td></tr>
<tr><td><code id="repcreate_+3A_method">method</code></td>
<td>
<p>a string indicating the name of the large-scale assessment
to determine the replication method to use. Available options are:
<code>"TIMSS"</code>, <code>"PIRLS"</code>, <code>"ICILS"</code>,  and <code>"ICCS"</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a data frame.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
head(repdata)

# Creation of replicate weights
RW &lt;- repcreate(df = repdata, # the data frame with all the information
                 wt = "wt", # the total weights column name
                 jkzone = "jkzones", # the jkzones column name
                 jkrep = "jkrep", # the jkreps column name
                 repwtname = "REPWT", # the desired name for the rep weights
                 reps = 50, # the number of replications
                 method = "ICILS") # the name of the method aka the study name

head(RW)
</code></pre>

<hr>
<h2 id='repdata'>Simulated data with 5000 cases</h2><span id='topic+repdata'></span>

<h3>Description</h3>

<p>Simulated data with 5000 cases
</p>

<hr>
<h2 id='repglm'>Generalized Linear Models with Replicate Weights</h2><span id='topic+repglm'></span>

<h3>Description</h3>

<p>Fits a generalized linear model using <a href="stats.html#topic+glm">glm</a> for replicate weights.
For a detailed explanation on how the standard errors are estimated
see <code><a href="#topic+repse">repse</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>repglm(
  formula,
  family = stats::gaussian,
  pvs = NULL,
  relatedpvs = TRUE,
  quiet = FALSE,
  summarize = TRUE,
  setup = NULL,
  df,
  wt,
  repwt,
  group = NULL,
  exclude = NULL,
  na.action = getOption("na.action"),
  method = c("TIMSS", "PIRLS", "ICILS", "ICCS", "PISA", "TALIS")
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="repglm_+3A_formula">formula</code></td>
<td>
<p>an object of class <code>"<a href="stats.html#topic+formula">formula</a>"</code> (or one that
can be coerced to that class): a symbolic description of the
model to be fitted.  The details of model specification are given
under &lsquo;Details&rsquo;.</p>
</td></tr>
<tr><td><code id="repglm_+3A_family">family</code></td>
<td>
<p>a description of the error distribution and link
function to be used in the model.  For <code>glm</code> this can be a
character string naming a family function, a family function or the
result of a call to a family function.  For <code>glm.fit</code> only the
third option is supported.  (See <code><a href="stats.html#topic+family">family</a></code> for details of
family functions.)</p>
</td></tr>
<tr><td><code id="repglm_+3A_pvs">pvs</code></td>
<td>
<p>if plausible values are not used, this should be <code>NULL</code>.
Otherwise it is a list indicating which variables from <code>formula</code>
should be replaced by which plausible values variables. For more details
check the examples.</p>
</td></tr>
<tr><td><code id="repglm_+3A_relatedpvs">relatedpvs</code></td>
<td>
<p>a logical value indicating if <code>pvs</code> are drawn
from the same model. If <code>TRUE</code> (default), a total of <code class="reqn">n</code> estimations will be done,
where <code class="reqn">n</code> is the number of plausible values for each plausible value variable.
If <code>FALSE</code>, a total of <code class="reqn">n_1 \times n_2 \times n_...</code>
estimations will be done, where <code class="reqn">n_i</code> is the number of plausible values in each plausible value variable.</p>
</td></tr>
<tr><td><code id="repglm_+3A_quiet">quiet</code></td>
<td>
<p>a logical value indicating if progress status should be shown
while estimating models by group. Default is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="repglm_+3A_summarize">summarize</code></td>
<td>
<p>a logical value indicating if <code>lm</code> objects should be
converted to <code>summary.lm</code> or <code>summary.glm</code> objects and stripped from certain elements
to reduce the size of the output object. Default is <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="repglm_+3A_setup">setup</code></td>
<td>
<p>an optional list produced by <code><a href="#topic+repsetup">repsetup</a></code>.</p>
</td></tr>
<tr><td><code id="repglm_+3A_df">df</code></td>
<td>
<p>a data frame.</p>
</td></tr>
<tr><td><code id="repglm_+3A_wt">wt</code></td>
<td>
<p>a string specifying the name of the column (within <code>df</code>) with the
total weights.</p>
</td></tr>
<tr><td><code id="repglm_+3A_repwt">repwt</code></td>
<td>
<p>a string indicating the common names for the replicate weights
columns (within <code>df</code>), or a data frame with the replicate weights.</p>
</td></tr>
<tr><td><code id="repglm_+3A_group">group</code></td>
<td>
<p>a string specifying the variable name (within <code>df</code>) to be
used for grouping. Categories in <code>group</code> are treated as independent, e.g.,
countries.</p>
</td></tr>
<tr><td><code id="repglm_+3A_exclude">exclude</code></td>
<td>
<p>a vector indicating which groups
(in the same format as <code>group</code>)
should be excluded from the pooled and composite estimates.</p>
</td></tr>
<tr><td><code id="repglm_+3A_na.action">na.action</code></td>
<td>
<p>a function which indicates what should happen
when the data contain <code>NA</code>s.  The default is set by
the <code>na.action</code> setting of <code><a href="base.html#topic+options">options</a></code>, and is
<code><a href="stats.html#topic+na.fail">na.fail</a></code> if that is unset.  The &lsquo;factory-fresh&rsquo;
default is <code><a href="stats.html#topic+na.omit">na.omit</a></code>.  Another possible value is
<code>NULL</code>, no action.  Value <code><a href="stats.html#topic+na.exclude">na.exclude</a></code> can be useful.</p>
</td></tr>
<tr><td><code id="repglm_+3A_method">method</code></td>
<td>
<p>a string indicating the name of the large-scale assessment
to determine the replication method to use. Available options are:
<code>"TIMSS"</code>, <code>"PIRLS"</code>, <code>"ICILS"</code>, <code>"ICCS"</code>,
<code>"PISA"</code>, and <code>"TALIS"</code>. Note that <code>"TIMSS"</code> and <code>"PIRLS"</code>
refer to the method used from 2016 onwards.
Their method has not yet been implemented for previous cycles.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list with the standard errors and the total weights models.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Less data for shorter example
repdata2 &lt;- repdata[1:1000,]

RW &lt;- repcreate(df = repdata2, # the data frame with all the information
                 wt = "wt", # the total weights column name
                 jkzone = "jkzones", # the jkzones column name
                 jkrep = "jkrep", # the jkreps column name
                 repwtname = "REPWT", # the desired name for the rep weights
                 reps = 50, # the number of replications
                 method = "ICILS") # the name of the method aka the study name

### No groups ----

# Simple regression - weights within df
replm(formula = Math1 ~ 1 + GENDER,
      wt = "wt", # Name of total weight column within df
      repwt = "REPWT", # Common names of replicate weights within df
      df = cbind(repdata2,RW), # Data frame
      method = "ICILS") # the name of the method aka the study name

# Simple regression - weights as a separate data frame
replm(formula = Math1 ~ 1 + GENDER,
       wt = "wt", # Name of total weight column within df
       repwt = RW, # Data frame of weights
       df = repdata2, # Data frame
       method = "ICILS") # the name of the method aka the study name

# Multiple regression
replm(formula = Math1 ~ 1 + GENDER + Reading1,
       wt = "wt", # Name of total weight column within df
       repwt = RW, # Data frame of weights
       df = repdata2, # Data frame
       method = "ICILS") # the name of the method aka the study name

# Multiple regression - with PVs
## Named list, with element names matching formula variables
pvs = list(Math = paste0("Math",1:3))
pvs

replm(formula = Math ~ 1 + GENDER + Reading1, # Math1 now is "Math"
       wt = "wt", # Name of total weight column within df
       repwt = RW, # Data frame of weights
       df = repdata2, # Data frame
       pvs = pvs, # Named list
       method = "ICILS") # the name of the method aka the study name

# Multiple regression - with more than one related PV variable
## Named list, with element names matching formula variables
pvs = list(Math = paste0("Math",1:3),
           Reading = paste0("Reading",1:3))
pvs

replm(formula = Math ~ 1 + GENDER + Reading, # Reading1 now is "Reading"
       wt = "wt", # Name of total weight column within df
       repwt = RW, # Data frame of weights
       df = repdata2, # Data frame
       pvs = pvs, # Named list
       method = "ICILS") # the name of the method aka the study name

# Multiple regression - with more than UNrelated PV variables
## Named list, with element names matching formula variables
pvs = list(Math = paste0("Math",1:3),
           Reading = paste0("Reading",1:3))
pvs

replm(formula = Math ~ 1 + GENDER + Reading, # Reading1 now is "Reading"
       wt = "wt", # Name of total weight column within df
       repwt = RW, # Data frame of weights
       df = repdata2, # Data frame
       pvs = pvs, # Named list
       relatedpvs = FALSE, # Unrelated PVs
       method = "ICILS") # the name of the method aka the study name


### Groups ----

# Simple regression - weights within df
replm(formula = Math1 ~ 1 + GENDER,
      wt = "wt", # Name of total weight column within df
      repwt = "REPWT", # Common names of replicate weights within df
      df = cbind(repdata2,RW), # Data frame
      group = "GROUP",
      method = "ICILS") # the name of the method aka the study name

# Simple regression - weights as a separate data frame
replm(formula = Math1 ~ 1 + GENDER,
      wt = "wt", # Name of total weight column within df
      repwt = RW, # Data frame of weights
      df = repdata2, # Data frame
      group = "GROUP",
      method = "ICILS") # the name of the method aka the study name

# Multiple regression
replm(formula = Math1 ~ 1 + GENDER + Reading1,
      wt = "wt", # Name of total weight column within df
      repwt = RW, # Data frame of weights
      df = repdata2, # Data frame
      group = "GROUP",
      method = "ICILS") # the name of the method aka the study name

# Multiple regression - with PVs
## Named list, with element names matching formula variables
pvs = list(Math = paste0("Math",1:3))
pvs

replm(formula = Math ~ 1 + GENDER + Reading1, # Math1 now is "Math"
      wt = "wt", # Name of total weight column within df
      repwt = RW, # Data frame of weights
      df = repdata2, # Data frame
      pvs = pvs, # Named list
      group = "GROUP",
      method = "ICILS") # the name of the method aka the study name

# Multiple regression - with more than one related PV variable
## Named list, with element names matching formula variables
pvs = list(Math = paste0("Math",1:3),
           Reading = paste0("Reading",1:3))
pvs

replm(formula = Math ~ 1 + GENDER + Reading, # Reading1 now is "Reading"
      wt = "wt", # Name of total weight column within df
      repwt = RW, # Data frame of weights
      df = repdata2, # Data frame
      pvs = pvs, # Named list
      group = "GROUP",
      method = "ICILS") # the name of the method aka the study name

# Multiple regression - with UNrelated PV variables
## Named list, with element names matching formula variables
pvs = list(Math = paste0("Math",1:3),
           Reading = paste0("Reading",1:3))
pvs

replm(formula = Math ~ 1 + GENDER + Reading, # Reading1 now is "Reading"
      wt = "wt", # Name of total weight column within df
      repwt = RW, # Data frame of weights
      df = repdata2, # Data frame
      pvs = pvs, # Named list
      relatedpvs = FALSE, # Unrelated PVs
      group = "GROUP",
      method = "ICILS") # the name of the method aka the study name
</code></pre>

<hr>
<h2 id='replm'>Linear Models with Replicate Weights</h2><span id='topic+replm'></span>

<h3>Description</h3>

<p>Fits a linear model using <a href="stats.html#topic+lm">lm</a> for replicate weights.
For a detailed explanation on how the standard errors are estimated
see <code><a href="#topic+repse">repse</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>replm(
  formula,
  pvs = NULL,
  relatedpvs = TRUE,
  quiet = FALSE,
  summarize = TRUE,
  setup = NULL,
  df,
  wt,
  repwt,
  group = NULL,
  exclude = NULL,
  na.action = getOption("na.action"),
  method = c("TIMSS", "PIRLS", "ICILS", "ICCS", "PISA", "TALIS")
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="replm_+3A_formula">formula</code></td>
<td>
<p>an object of class &quot;formula&quot; (or one that can be coerced to that class):
a symbolic description of the model to be fitted.</p>
</td></tr>
<tr><td><code id="replm_+3A_pvs">pvs</code></td>
<td>
<p>if plausible values are not used, this should be <code>NULL</code>.
Otherwise it is a list indicating which variables from <code>formula</code>
should be replaced by which plausible values variables. For more details
check the examples.</p>
</td></tr>
<tr><td><code id="replm_+3A_relatedpvs">relatedpvs</code></td>
<td>
<p>a logical value indicating if <code>pvs</code> are drawn
from the same model. If <code>TRUE</code> (default), a total of <code class="reqn">n</code> estimations will be done,
where <code class="reqn">n</code> is the number of plausible values for each plausible value variable.
If <code>FALSE</code>, a total of <code class="reqn">n_1 \times n_2 \times n_...</code>
estimations will be done, where <code class="reqn">n_i</code> is the number of plausible values in each plausible value variable.</p>
</td></tr>
<tr><td><code id="replm_+3A_quiet">quiet</code></td>
<td>
<p>a logical value indicating if progress status should be shown
while estimating models by group. Default is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="replm_+3A_summarize">summarize</code></td>
<td>
<p>a logical value indicating if <code>lm</code> objects should be
converted to <code>summary.lm</code> or <code>summary.glm</code> objects and stripped from certain elements
to reduce the size of the output object. Default is <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="replm_+3A_setup">setup</code></td>
<td>
<p>an optional list produced by <code><a href="#topic+repsetup">repsetup</a></code>.</p>
</td></tr>
<tr><td><code id="replm_+3A_df">df</code></td>
<td>
<p>a data frame.</p>
</td></tr>
<tr><td><code id="replm_+3A_wt">wt</code></td>
<td>
<p>a string specifying the name of the column (within <code>df</code>) with the
total weights.</p>
</td></tr>
<tr><td><code id="replm_+3A_repwt">repwt</code></td>
<td>
<p>a string indicating the common names for the replicate weights
columns (within <code>df</code>), or a data frame with the replicate weights.</p>
</td></tr>
<tr><td><code id="replm_+3A_group">group</code></td>
<td>
<p>a string specifying the variable name (within <code>df</code>) to be
used for grouping. Categories in <code>group</code> are treated as independent, e.g.,
countries.</p>
</td></tr>
<tr><td><code id="replm_+3A_exclude">exclude</code></td>
<td>
<p>a vector indicating which groups
(in the same format as <code>group</code>)
should be excluded from the pooled and composite estimates.</p>
</td></tr>
<tr><td><code id="replm_+3A_na.action">na.action</code></td>
<td>
<p>a function which indicates what should happen
when the data contain <code>NA</code>s.  The default is set by
the <code>na.action</code> setting of <code><a href="base.html#topic+options">options</a></code>, and is
<code><a href="stats.html#topic+na.fail">na.fail</a></code> if that is unset.  The &lsquo;factory-fresh&rsquo;
default is <code><a href="stats.html#topic+na.omit">na.omit</a></code>.  Another possible value is
<code>NULL</code>, no action.  Value <code><a href="stats.html#topic+na.exclude">na.exclude</a></code> can be useful.</p>
</td></tr>
<tr><td><code id="replm_+3A_method">method</code></td>
<td>
<p>a string indicating the name of the large-scale assessment
to determine the replication method to use. Available options are:
<code>"TIMSS"</code>, <code>"PIRLS"</code>, <code>"ICILS"</code>, <code>"ICCS"</code>,
<code>"PISA"</code>, and <code>"TALIS"</code>. Note that <code>"TIMSS"</code> and <code>"PIRLS"</code>
refer to the method used from 2016 onwards.
Their method has not yet been implemented for previous cycles.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Less data for shorter example
repdata2 &lt;- repdata[1:1000,]

RW &lt;- repcreate(df = repdata2, # the data frame with all the information
                 wt = "wt", # the total weights column name
                 jkzone = "jkzones", # the jkzones column name
                 jkrep = "jkrep", # the jkreps column name
                 repwtname = "REPWT", # the desired name for the rep weights
                 reps = 50, # the number of replications
                 method = "ICILS") # the name of the method aka the study name

### No groups ----

# Simple regression - weights within df
replm(formula = Math1 ~ 1 + GENDER,
      wt = "wt", # Name of total weight column within df
      repwt = "REPWT", # Common names of replicate weights within df
      df = cbind(repdata2,RW), # Data frame
      method = "ICILS") # the name of the method aka the study name

# Simple regression - weights as a separate data frame
replm(formula = Math1 ~ 1 + GENDER,
       wt = "wt", # Name of total weight column within df
       repwt = RW, # Data frame of weights
       df = repdata2, # Data frame
       method = "ICILS") # the name of the method aka the study name

# Multiple regression
replm(formula = Math1 ~ 1 + GENDER + Reading1,
       wt = "wt", # Name of total weight column within df
       repwt = RW, # Data frame of weights
       df = repdata2, # Data frame
       method = "ICILS") # the name of the method aka the study name

# Multiple regression - with PVs
## Named list, with element names matching formula variables
pvs = list(Math = paste0("Math",1:3))
pvs

replm(formula = Math ~ 1 + GENDER + Reading1, # Math1 now is "Math"
       wt = "wt", # Name of total weight column within df
       repwt = RW, # Data frame of weights
       df = repdata2, # Data frame
       pvs = pvs, # Named list
       method = "ICILS") # the name of the method aka the study name

# Multiple regression - with more than one related PV variable
## Named list, with element names matching formula variables
pvs = list(Math = paste0("Math",1:3),
           Reading = paste0("Reading",1:3))
pvs

replm(formula = Math ~ 1 + GENDER + Reading, # Reading1 now is "Reading"
       wt = "wt", # Name of total weight column within df
       repwt = RW, # Data frame of weights
       df = repdata2, # Data frame
       pvs = pvs, # Named list
       method = "ICILS") # the name of the method aka the study name

# Multiple regression - with more than UNrelated PV variables
## Named list, with element names matching formula variables
pvs = list(Math = paste0("Math",1:3),
           Reading = paste0("Reading",1:3))
pvs

replm(formula = Math ~ 1 + GENDER + Reading, # Reading1 now is "Reading"
       wt = "wt", # Name of total weight column within df
       repwt = RW, # Data frame of weights
       df = repdata2, # Data frame
       pvs = pvs, # Named list
       relatedpvs = FALSE, # Unrelated PVs
       method = "ICILS") # the name of the method aka the study name


### Groups ----

# Simple regression - weights within df
replm(formula = Math1 ~ 1 + GENDER,
      wt = "wt", # Name of total weight column within df
      repwt = "REPWT", # Common names of replicate weights within df
      df = cbind(repdata2,RW), # Data frame
      group = "GROUP",
      method = "ICILS") # the name of the method aka the study name

# Simple regression - weights as a separate data frame
replm(formula = Math1 ~ 1 + GENDER,
      wt = "wt", # Name of total weight column within df
      repwt = RW, # Data frame of weights
      df = repdata2, # Data frame
      group = "GROUP",
      method = "ICILS") # the name of the method aka the study name

# Multiple regression
replm(formula = Math1 ~ 1 + GENDER + Reading1,
      wt = "wt", # Name of total weight column within df
      repwt = RW, # Data frame of weights
      df = repdata2, # Data frame
      group = "GROUP",
      method = "ICILS") # the name of the method aka the study name

# Multiple regression - with PVs
## Named list, with element names matching formula variables
pvs = list(Math = paste0("Math",1:3))
pvs

replm(formula = Math ~ 1 + GENDER + Reading1, # Math1 now is "Math"
      wt = "wt", # Name of total weight column within df
      repwt = RW, # Data frame of weights
      df = repdata2, # Data frame
      pvs = pvs, # Named list
      group = "GROUP",
      method = "ICILS") # the name of the method aka the study name

# Multiple regression - with more than one related PV variable
## Named list, with element names matching formula variables
pvs = list(Math = paste0("Math",1:3),
           Reading = paste0("Reading",1:3))
pvs

replm(formula = Math ~ 1 + GENDER + Reading, # Reading1 now is "Reading"
      wt = "wt", # Name of total weight column within df
      repwt = RW, # Data frame of weights
      df = repdata2, # Data frame
      pvs = pvs, # Named list
      group = "GROUP",
      method = "ICILS") # the name of the method aka the study name

# Multiple regression - with UNrelated PV variables
## Named list, with element names matching formula variables
pvs = list(Math = paste0("Math",1:3),
           Reading = paste0("Reading",1:3))
pvs

replm(formula = Math ~ 1 + GENDER + Reading, # Reading1 now is "Reading"
      wt = "wt", # Name of total weight column within df
      repwt = RW, # Data frame of weights
      df = repdata2, # Data frame
      pvs = pvs, # Named list
      relatedpvs = FALSE, # Unrelated PVs
      group = "GROUP",
      method = "ICILS") # the name of the method aka the study name
</code></pre>

<hr>
<h2 id='repmean'>Mean, Variance and Standard Deviation with Replicate Weights</h2><span id='topic+repmean'></span>

<h3>Description</h3>

<p>Estimates the mean, variance and standard deviation with replicate weights
for a variable or a group of variables and for one or more
populations. For a detailed explanation on how the standard errors are estimated
see <code><a href="#topic+repse">repse</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>repmean(
  x,
  PV = FALSE,
  setup = NULL,
  repwt,
  wt,
  df,
  method = c("TIMSS", "PIRLS", "ICILS", "ICCS", "PISA", "TALIS"),
  var = c("unbiased", "ML"),
  group = NULL,
  by = NULL,
  exclude = NULL,
  zones = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="repmean_+3A_x">x</code></td>
<td>
<p>a string vector specifying variable names (within <code>df</code>) for
analysis.</p>
</td></tr>
<tr><td><code id="repmean_+3A_pv">PV</code></td>
<td>
<p>a logical value indicating if the variables in <code>x</code> are
plausible values.</p>
</td></tr>
<tr><td><code id="repmean_+3A_setup">setup</code></td>
<td>
<p>an optional list produced by <code><a href="#topic+repsetup">repsetup</a></code>.</p>
</td></tr>
<tr><td><code id="repmean_+3A_repwt">repwt</code></td>
<td>
<p>a string indicating the common names for the replicate weights
columns (within <code>df</code>), or a data frame with the replicate weights.</p>
</td></tr>
<tr><td><code id="repmean_+3A_wt">wt</code></td>
<td>
<p>a string specifying the name of the column (within <code>df</code>) with the
total weights.</p>
</td></tr>
<tr><td><code id="repmean_+3A_df">df</code></td>
<td>
<p>a data frame.</p>
</td></tr>
<tr><td><code id="repmean_+3A_method">method</code></td>
<td>
<p>a string indicating the name of the large-scale assessment
to determine the replication method to use. Available options are:
<code>"TIMSS"</code>, <code>"PIRLS"</code>, <code>"ICILS"</code>, <code>"ICCS"</code>,
<code>"PISA"</code>, and <code>"TALIS"</code>. Note that <code>"TIMSS"</code> and <code>"PIRLS"</code>
refer to the method used from 2016 onwards.
Their method has not yet been implemented for previous cycles.</p>
</td></tr>
<tr><td><code id="repmean_+3A_var">var</code></td>
<td>
<p>a string indicating the method to use for the variance:
<code>"unbiased"</code> calculates the unbiased estimate (n-1); <code>"ML"</code>
calculates the maximum likelihood estimate.</p>
</td></tr>
<tr><td><code id="repmean_+3A_group">group</code></td>
<td>
<p>a string specifying the variable name (within <code>df</code>) to be
used for grouping. Categories in <code>group</code> are treated as independent, e.g.,
countries.</p>
</td></tr>
<tr><td><code id="repmean_+3A_by">by</code></td>
<td>
<p>a string specifying a second variable (within <code>df</code>) for grouping.
Categories used in <code>by</code> are not considered independent, e.g., gender
within a country. If used,
the output will be a list with the same length as the  unique values of
<code>by</code>. This can only be used for analyses with one variable or a group
of PVs.</p>
</td></tr>
<tr><td><code id="repmean_+3A_exclude">exclude</code></td>
<td>
<p>a vector indicating which groups
(in the same format as <code>group</code>)
should be excluded from the pooled and composite estimates.</p>
</td></tr>
<tr><td><code id="repmean_+3A_zones">zones</code></td>
<td>
<p>a string specifying the name of the variable containing the
replicate zones.
Used for calculating the number of zones to be used by variable and group.
If <code>NULL</code>, zones are not be calculated.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a data frame or a list.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Creation of replicate weights
RW &lt;- repcreate(df = repdata, # the data frame with all the information
                 wt = "wt", # the total weights column name
                 jkzone = "jkzones", # the jkzones column name
                 jkrep = "jkrep", # the jkreps column name
                 repwtname = "REPWT", # the desired name for the rep weights
                 reps = 50, # the number of replications
                 method = "ICILS") # the name of the method aka the study name

### No groups ----

# One variable - weights within df
repmean(x = c("item01"),
        PV = FALSE,
        repwt = "REPWT", wt = "wt", df = cbind(repdata,RW),
        method = "ICILS",var = "ML",zones = "jkzones")

# One variable - weights as a separate data frame
repmean(x = c("item01"),
        PV = FALSE,
        repwt = RW, wt = "wt", df = repdata,
        method = "ICILS",var = "ML",zones = "jkzones")

# Multiple variables
repmean(x = c("item01","item02","item03"),
        PV = FALSE,
        repwt = RW, wt = "wt", df = repdata,
        method = "ICILS",var = "ML",zones = "jkzones")

# One PV variable
repmean(x = paste0("Math",1:5),
        PV = TRUE, # if set to TRUE, PVs will be treated as separate variables
        repwt = RW, wt = "wt", df = repdata,
        method = "ICILS",var = "ML",zones = "jkzones")

### Groups ----

# One variable
repmean(x = c("item01"),
        PV = FALSE,
        repwt = RW, wt = "wt", df = repdata,
        method = "ICILS",var = "ML",zones = "jkzones",
        group = "GROUP",
        exclude = "GR2") # GR2 will not be used for Pooled nor Composite

# Multiple variables
repmean(x = c("item01","item02","item03"),
        PV = FALSE,
        repwt = RW, wt = "wt", df = repdata,
        method = "ICILS",var = "ML",zones = "jkzones",
        group = "GROUP",
        exclude = "GR2") # GR2 will not be used for Pooled nor Composite

# One PV variable
repmean(x = paste0("Math",1:5),
        PV = TRUE, # if set to TRUE, PVs will be treated as separate variables
        repwt = RW, wt = "wt", df = repdata,
        method = "ICILS",var = "ML",zones = "jkzones",
        group = "GROUP",
        exclude = "GR2") # GR2 will not be used for Pooled nor Composite

### Groups and By ----

# One variable
repmean(x = c("item01"),
        PV = FALSE,
        repwt = RW, wt = "wt", df = repdata,
        method = "ICILS",var = "ML",zones = "jkzones",
        group = "GROUP",
        by = "GENDER", # results will be separated by GENDER
        exclude = "GR2") # GR2 will not be used for Pooled nor Composite

# One PV variable
repmean(x = paste0("Math",1:5),
        PV = TRUE, # if set to TRUE, PVs will be treated as separate variables
        repwt = RW, wt = "wt", df = repdata,
        method = "ICILS",var = "ML",zones = "jkzones",
        group = "GROUP",
        by = "GENDER", # results will be separated by GENDER
        exclude = "GR2") # GR2 will not be used for Pooled nor Composite
</code></pre>

<hr>
<h2 id='repmeandif'>Mean Difference of Independent Samples with Replicate Weights</h2><span id='topic+repmeandif'></span>

<h3>Description</h3>

<p>Estimates the mean difference for a single variable with replicate weights.
For a detailed explanation on how the standard errors are estimated
see <code><a href="#topic+repse">repse</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>repmeandif(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="repmeandif_+3A_x">x</code></td>
<td>
<p>a data frame produced by <code><a href="#topic+repmean">repmean</a></code> for a single variable.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a data frame or a list.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Creation of replicate weights
RW &lt;- repcreate(df = repdata, # the data frame with all the information
                 wt = "wt", # the total weights column name
                 jkzone = "jkzones", # the jkzones column name
                 jkrep = "jkrep", # the jkreps column name
                 repwtname = "REPWT", # the desired name for the rep weights
                 reps = 50, # the number of replications
                 method = "ICILS") # the name of the method aka the study name


### Groups ----

# One variable
reme &lt;- repmean(x = c("item01"),
                PV = FALSE,
                repwt = RW, wt = "wt", df = repdata,
                method = "ICILS",var = "ML",zones = "jkzones",
                group = "GROUP",
                exclude = "GR2") # GR2 will not be used for Pooled nor Composite

repmeandif(reme)


# One PV variable
reme &lt;- repmean(x = paste0("Math",1:5),
                PV = TRUE, # if set to TRUE, PVs will be treated as separate variables
                repwt = RW, wt = "wt", df = repdata,
                method = "ICILS",var = "ML",zones = "jkzones",
                group = "GROUP",
                exclude = "GR2") # GR2 will not be used for Pooled nor Composite

repmeandif(reme)

### Groups and By ----

# One variable
reme &lt;- repmean(x = c("item01"),
                PV = FALSE,
                repwt = RW, wt = "wt", df = repdata,
                method = "ICILS",var = "ML",zones = "jkzones",
                group = "GROUP",
                by = "GENDER", # results will be separated by GENDER
                exclude = "GR2") # GR2 will not be used for Pooled nor Composite

repmeandif(reme)

# One PV variable
reme &lt;- repmean(x = paste0("Math",1:5),
                PV = TRUE, # if set to TRUE, PVs will be treated as separate variables
                repwt = RW, wt = "wt", df = repdata,
                method = "ICILS",var = "ML",zones = "jkzones",
                group = "GROUP",
                by = "GENDER", # results will be separated by GENDER
                exclude = "GR2") # GR2 will not be used for Pooled nor Composite

repmeandif(reme)
</code></pre>

<hr>
<h2 id='repprop'>Proportions with Replicate Weights</h2><span id='topic+repprop'></span>

<h3>Description</h3>

<p>Estimates proportions using replicate weights
for a variable or a group of plausible values variables and for one or more
populations.
For a detailed explanation on how the standard errors are estimated
see <code><a href="#topic+repse">repse</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>repprop(
  x,
  categories = NULL,
  setup = NULL,
  repwt,
  wt,
  df,
  method = c("TIMSS", "PIRLS", "ICILS", "ICCS", "PISA", "TALIS"),
  group = NULL,
  exclude = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="repprop_+3A_x">x</code></td>
<td>
<p>a string vector specifying variable names (within <code>df</code>) for
analysis.</p>
</td></tr>
<tr><td><code id="repprop_+3A_categories">categories</code></td>
<td>
<p>a vector indicating all possible response categories.
If <code>NULL</code>, categories will be derived from the data.</p>
</td></tr>
<tr><td><code id="repprop_+3A_setup">setup</code></td>
<td>
<p>an optional list produced by <code><a href="#topic+repsetup">repsetup</a></code>.</p>
</td></tr>
<tr><td><code id="repprop_+3A_repwt">repwt</code></td>
<td>
<p>a string indicating the common names for the replicate weights
columns (within <code>df</code>), or a data frame with the replicate weights.</p>
</td></tr>
<tr><td><code id="repprop_+3A_wt">wt</code></td>
<td>
<p>a string specifying the name of the column (within <code>df</code>) with the
total weights.</p>
</td></tr>
<tr><td><code id="repprop_+3A_df">df</code></td>
<td>
<p>a data frame.</p>
</td></tr>
<tr><td><code id="repprop_+3A_method">method</code></td>
<td>
<p>a string indicating the name of the large-scale assessment
to determine the replication method to use. Available options are:
<code>"TIMSS"</code>, <code>"PIRLS"</code>, <code>"ICILS"</code>, <code>"ICCS"</code>,
<code>"PISA"</code>, and <code>"TALIS"</code>. Note that <code>"TIMSS"</code> and <code>"PIRLS"</code>
refer to the method used from 2016 onwards.
Their method has not yet been implemented for previous cycles.</p>
</td></tr>
<tr><td><code id="repprop_+3A_group">group</code></td>
<td>
<p>a string specifying the variable name (within <code>df</code>) to be
used for grouping. Categories in <code>group</code> are treated as independent, e.g.,
countries.</p>
</td></tr>
<tr><td><code id="repprop_+3A_exclude">exclude</code></td>
<td>
<p>a vector indicating which groups
(in the same format as <code>group</code>)
should be excluded from the pooled and composite estimates.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Creation of replicate weights
RW &lt;- repcreate(df = repdata, # the data frame with all the information
                 wt = "wt", # the total weights column name
                 jkzone = "jkzones", # the jkzones column name
                 jkrep = "jkrep", # the jkreps column name
                 repwtname = "REPWT", # the desired name for the rep weights
                 reps = 50, # the number of replications
                 method = "ICILS") # the name of the method aka the study name

### No groups ----

# One variable - weights within df
repprop(x = c("item01"),
        repwt = "REPWT", wt = "wt", df = cbind(repdata,RW),
        method = "ICILS")

# One variable - weights weights as a separate data frame
repprop(x = c("item01"),
        repwt = RW, wt = "wt", df = repdata,
        method = "ICILS")

# Multiple variables - PVs are assumed
repprop(x = c("CatMath1","CatMath2","CatMath3"),
        repwt = RW, wt = "wt", df = repdata,
        method = "ICILS")

### Groups ----

# One variable - weights within df
repprop(x = c("item01"),
        group = "GROUP",
        repwt = "REPWT", wt = "wt", df = cbind(repdata,RW),
        method = "ICILS")

# One variable - weights weights as a separate data frame
repprop(x = c("item01"),
        group = "GROUP",
        repwt = RW, wt = "wt", df = repdata,
        method = "ICILS")

# Multiple variables - PVs are assumed
repprop(x = c("CatMath1","CatMath2","CatMath3"),
        group = "GROUP",
        repwt = RW, wt = "wt", df = repdata,
        method = "ICILS")

# Multiple variables - excluding one group
repprop(x = c("CatMath1","CatMath2","CatMath3"),
        group = "GROUP",
        exclude = "GR2",
        repwt = RW, wt = "wt", df = repdata,
        method = "ICILS")

</code></pre>

<hr>
<h2 id='repquant'>Quantiles with Replicate Weights</h2><span id='topic+repquant'></span>

<h3>Description</h3>

<p>Estimates quantiles with replicate weights
for a variable or a group of variables and for one or more
populations.
For a detailed explanation on how the standard errors are estimated
see <code><a href="#topic+repse">repse</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>repquant(
  x,
  qtl = c(0.05, 0.25, 0.75, 0.95),
  PV = FALSE,
  setup = NULL,
  repwt,
  wt,
  df,
  method = c("TIMSS", "PIRLS", "ICILS", "ICCS", "PISA", "TALIS"),
  group = NULL,
  by = NULL,
  exclude = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="repquant_+3A_x">x</code></td>
<td>
<p>a string vector specifying variable names (within <code>df</code>) for
analysis.</p>
</td></tr>
<tr><td><code id="repquant_+3A_qtl">qtl</code></td>
<td>
<p>a numeric vector indicating the desired quantiles (between 0 and 1).</p>
</td></tr>
<tr><td><code id="repquant_+3A_pv">PV</code></td>
<td>
<p>a logical value indicating if the variables in <code>x</code> are
plausible values.</p>
</td></tr>
<tr><td><code id="repquant_+3A_setup">setup</code></td>
<td>
<p>an optional list produced by <code><a href="#topic+repsetup">repsetup</a></code>.</p>
</td></tr>
<tr><td><code id="repquant_+3A_repwt">repwt</code></td>
<td>
<p>a string indicating the common names for the replicate weights
columns (within <code>df</code>), or a data frame with the replicate weights.</p>
</td></tr>
<tr><td><code id="repquant_+3A_wt">wt</code></td>
<td>
<p>a string specifying the name of the column (within <code>df</code>) with the
total weights.</p>
</td></tr>
<tr><td><code id="repquant_+3A_df">df</code></td>
<td>
<p>a data frame.</p>
</td></tr>
<tr><td><code id="repquant_+3A_method">method</code></td>
<td>
<p>a string indicating the name of the large-scale assessment
to determine the replication method to use. Available options are:
<code>"TIMSS"</code>, <code>"PIRLS"</code>, <code>"ICILS"</code>, <code>"ICCS"</code>,
<code>"PISA"</code>, and <code>"TALIS"</code>. Note that <code>"TIMSS"</code> and <code>"PIRLS"</code>
refer to the method used from 2016 onwards.
Their method has not yet been implemented for previous cycles.</p>
</td></tr>
<tr><td><code id="repquant_+3A_group">group</code></td>
<td>
<p>a string specifying the variable name (within <code>df</code>) to be
used for grouping. Categories in <code>group</code> are treated as independent, e.g.,
countries.</p>
</td></tr>
<tr><td><code id="repquant_+3A_by">by</code></td>
<td>
<p>a string specifying a second variable (within <code>df</code>) for grouping.
Categories used in <code>by</code> are not considered independent, e.g., gender
within a country. If used,
the output will be a list with the same length as the  unique values of
<code>by</code>. This can only be used for analyses with one variable or a group
of PVs.</p>
</td></tr>
<tr><td><code id="repquant_+3A_exclude">exclude</code></td>
<td>
<p>a vector indicating which groups
(in the same format as <code>group</code>)
should be excluded from the pooled and composite estimates.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a data frame or a list.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
RWT &lt;- repcreate(df = repdata, # the data frame with all the information
                 wt = "wt", # the total weights column name
                 jkzone = "jkzones", # the jkzones column name
                 jkrep = "jkrep", # the jkreps column name
                 repwtname = "REPWT", # the desired name for the rep weights
                 reps = 50, # the number of replications
                 method = "ICILS") # the name of the method aka the study name

### No groups ----

# One variable - weights within df
repquant(x = c("item01"),
        qtl = c(0.05, 0.25, 0.75, 0.95),
        PV = FALSE,
        repwt = "REPWT", wt = "wt", df = cbind(repdata,RWT),
        method = "ICILS")

# One variable - weights as a separate data frame
repquant(x = c("item01"),
        qtl = c(0.05, 0.25, 0.75, 0.95),
        PV = FALSE,
        repwt = RWT, wt = "wt", df = repdata,
        method = "ICILS")

# One PV variable
repquant(x = paste0("Math",1:5),
        qtl = c(0.05, 0.25, 0.75, 0.95),
        PV = TRUE, # if set to TRUE, PVs will be treated as separate variables
        repwt = RWT, wt = "wt", df = repdata,
        method = "ICILS")

### Groups ----

# One variable
repquant(x = c("item01"),
        qtl = c(0.05, 0.25, 0.75, 0.95),
        PV = FALSE,
        repwt = RWT, wt = "wt", df = repdata,
        method = "ICILS",
        group = "GROUP",
        exclude = "GR2") # GR2 will not be used for Pooled nor Composite


# One PV variable
repquant(x = paste0("Math",1:5),
        qtl = c(0.05, 0.25, 0.75, 0.95),
        PV = TRUE, # if set to TRUE, PVs will be treated as separate variables
        repwt = RWT, wt = "wt", df = repdata,
        method = "ICILS",
        group = "GROUP",
        exclude = "GR2") # GR2 will not be used for Pooled nor Composite

### Groups and By ----

# One variable
repquant(x = c("item01"),
        qtl = c(0.05, 0.25, 0.75, 0.95),
        PV = FALSE,
        repwt = RWT, wt = "wt", df = repdata,
        method = "ICILS",
        group = "GROUP",
        by = "GENDER", # results will be separated by GENDER
        exclude = "GR2") # GR2 will not be used for Pooled nor Composite

# One PV variable
repquant(x = paste0("Math",1:5),
        qtl = c(0.05, 0.25, 0.75, 0.95),
        PV = TRUE, # if set to TRUE, PVs will be treated as separate variables
        repwt = RWT, wt = "wt", df = repdata,
        method = "ICILS",
        group = "GROUP",
        by = "GENDER", # results will be separated by GENDER
        exclude = "GR2") # GR2 will not be used for Pooled nor Composite
</code></pre>

<hr>
<h2 id='reprho'>Correlations with Replicate Weights</h2><span id='topic+reprho'></span>

<h3>Description</h3>

<p>Estimates correlation coefficients using replicate weights.
For a detailed explanation on how the standard errors are estimated
see <code><a href="#topic+repse">repse</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>reprho(
  x = NULL,
  pv = NULL,
  pv2 = NULL,
  relatedpvs = TRUE,
  setup = NULL,
  repwt,
  wt,
  df,
  rho = c("pearson", "spearman", "polychoric"),
  method = c("TIMSS", "PIRLS", "ICILS", "ICCS", "PISA", "TALIS"),
  group = NULL,
  exclude = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="reprho_+3A_x">x</code></td>
<td>
<p>a string vector specifying variable names (within <code>df</code>) for analysis.
If <code>pv</code> is <code>NULL</code>, this function estimates correlations between all variables in the vector.
If <code>pv2</code> is NOT <code>NULL</code>, then <code>x</code> should be set to <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="reprho_+3A_pv">pv</code></td>
<td>
<p>a string vector indicating the variable names for all plausible values
of a construct. If not <code>NULL</code>, this function estimates correlations only between
<code>x</code> and the plausible values construct.</p>
</td></tr>
<tr><td><code id="reprho_+3A_pv2">pv2</code></td>
<td>
<p>a string vector indicating the variable names for all plausible values
of a second construct (distinct from <code>pv</code>).</p>
</td></tr>
<tr><td><code id="reprho_+3A_relatedpvs">relatedpvs</code></td>
<td>
<p>a logical value indicating if <code>pv</code> and <code>pv2</code> are drawn
from the same model, and have the same number of plausible values.
If <code>TRUE</code> (default), a total of <code class="reqn">n</code> estimations will be done,
where <code class="reqn">n</code> is the number of plausible values of each.
If <code>FALSE</code>, a total of <code class="reqn">n_1 \times n_2</code>
estimations will be done, where <code class="reqn">n_1</code> is the number of plausible values in <code>pv</code>
and <code class="reqn">n_2</code> is the number of plausible values in <code>pv2</code>.</p>
</td></tr>
<tr><td><code id="reprho_+3A_setup">setup</code></td>
<td>
<p>an optional list produced by <code><a href="#topic+repsetup">repsetup</a></code>.</p>
</td></tr>
<tr><td><code id="reprho_+3A_repwt">repwt</code></td>
<td>
<p>a string indicating the common names for the replicate weights
columns within <code>df</code>, or a data frame with the replicate weights.</p>
</td></tr>
<tr><td><code id="reprho_+3A_wt">wt</code></td>
<td>
<p>a string specifying the name of the column in <code>df</code> that contains the total weights.</p>
</td></tr>
<tr><td><code id="reprho_+3A_df">df</code></td>
<td>
<p>a data frame.</p>
</td></tr>
<tr><td><code id="reprho_+3A_rho">rho</code></td>
<td>
<p>a string indicating the correlation coefficient to be computed:
<code>"pearson"</code>, <code>"polychoric"</code>, or <code>"spearman"</code> (lower or uppercase).</p>
</td></tr>
<tr><td><code id="reprho_+3A_method">method</code></td>
<td>
<p>a string indicating the name of the large-scale assessment to
determine the replication method to use. Available options are:
<code>"TIMSS"</code>, <code>"PIRLS"</code>, <code>"ICILS"</code>, <code>"ICCS"</code>, and <code>"PISA"</code>.</p>
</td></tr>
<tr><td><code id="reprho_+3A_group">group</code></td>
<td>
<p>a string specifying the variable name (within <code>df</code>) to be used for grouping.</p>
</td></tr>
<tr><td><code id="reprho_+3A_exclude">exclude</code></td>
<td>
<p>a vector indicating which groups (in the same format as <code>group</code>)
should be excluded from the estimation of pooled and composite estimates.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a data frame.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Creation of replicate weights
RW &lt;- repcreate(df = repdata, # the data frame with all the information
                wt = "wt", # the total weights column name
                jkzone = "jkzones", # the jkzones column name
                jkrep = "jkrep", # the jkreps column name
                repwtname = "REPWT", # the desired name for the rep weights
                reps = 50, # the number of replications
                method = "ICILS") # the name of the method aka the study name


### No groups ----

# Non PVs
reprho(x = c("GENDER",paste0("Math",1:3)),
       pv = NULL,
       pv2 = NULL,
       rho = "pearson",
       repwt = RW,
       wt = "wt",
       df = repdata,
       method = "ICILS")

# X var and PVs
reprho(x = c("GENDER",paste0("Math",1:3)),
       pv = paste0("Reading",1:5),
       pv2 = NULL,
       rho = "pearson",
       repwt = RW,
       wt = "wt",
       df = repdata,
       method = "ICILS")

# PVs and PVs (related)
reprho(x = NULL,
       pv = paste0("Math",1:5),
       pv2 = paste0("Reading",1:5),
       rho = "pearson",
       repwt = RW,
       wt = "wt",
       df = repdata,
       method = "ICILS")

# PVs and PVs (UNrelated)
reprho(x = NULL,
       pv = paste0("Math",1:5),
       pv2 = paste0("Reading",1:5),
       relatedpvs = FALSE,
       rho = "pearson",
       repwt = RW,
       wt = "wt",
       df = repdata,
       method = "ICILS")


### Groups ----

# Non PVs
reprho(x = c("GENDER",paste0("Math",1:3)),
       pv = NULL,
       pv2 = NULL,
       rho = "pearson",
       repwt = RW,
       wt = "wt",
       df = repdata,
       group = "GROUP",
       method = "ICILS")

# X var and PVs
reprho(x = c("GENDER",paste0("Math",1:3)),
       pv = paste0("Reading",1:5),
       pv2 = NULL,
       rho = "pearson",
       repwt = RW,
       wt = "wt",
       df = repdata,
       group = "GROUP",
       method = "ICILS")

# PVs and PVs (related)
reprho(x = NULL,
       pv = paste0("Math",1:5),
       pv2 = paste0("Reading",1:5),
       rho = "pearson",
       repwt = RW,
       wt = "wt",
       df = repdata,
       group = "GROUP",
       method = "ICILS")

# PVs and PVs (UNrelated)
reprho(x = NULL,
       pv = paste0("Math",1:5),
       pv2 = paste0("Reading",1:5),
       relatedpvs = FALSE,
       rho = "pearson",
       repwt = RW,
       wt = "wt",
       df = repdata,
       group = "GROUP",
       method = "ICILS")
</code></pre>

<hr>
<h2 id='repse'>Standard Error for Estimates with Replicate Weights and Plausible Values</h2><span id='topic+repse'></span><span id='topic+repsecomp'></span><span id='topic+pvse'></span>

<h3>Description</h3>

<p>Calculates the standard error given a vector or list of previous estimations.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>repse(
  er,
  e0,
  setup = NULL,
  method = c("TIMSS", "PIRLS", "ICILS", "ICCS", "PISA", "TALIS")
)

repsecomp(se)

pvse(PVse, PVe0, df = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="repse_+3A_er">er</code></td>
<td>
<p>a vector or a list containing any statistic of interest
(e.g., percent, mean, variance, regression coefficient).
If it is a vector or list of <code>length==1</code>, the function estimates
standard errors without plausible values. If it is a list with
<code>length&gt;1</code>, it estimates standard errors with plausible values.</p>
</td></tr>
<tr><td><code id="repse_+3A_e0">e0</code></td>
<td>
<p>a numeric vector or a vector containing any statistic of interest
(e.g., percent, mean, variance, regression coefficient), computed using
total weights. For scenarios without plausible values,
<code>e0</code> should be a single value. For scenarios with plausible values,
<code>e0</code> should be a vector of the same length as <code>er</code>.</p>
</td></tr>
<tr><td><code id="repse_+3A_setup">setup</code></td>
<td>
<p>an optional list produced by <code><a href="#topic+repsetup">repsetup</a></code>.</p>
</td></tr>
<tr><td><code id="repse_+3A_method">method</code></td>
<td>
<p>a string indicating the name of the large-scale assessment
to determine the replication method to use. Available options are:
<code>"TIMSS"</code>, <code>"PIRLS"</code>, <code>"ICILS"</code>, <code>"ICCS"</code>,
<code>"PISA"</code>, and <code>"TALIS"</code>. Note that <code>"TIMSS"</code> and <code>"PIRLS"</code>
refer to the method used from 2016 onwards.
Their method has not yet been implemented for previous cycles.</p>
</td></tr>
<tr><td><code id="repse_+3A_se">se</code></td>
<td>
<p>a numeric vector with standard errors,
used by <code>repsecomp()</code> to estimate a composite standard error.</p>
</td></tr>
<tr><td><code id="repse_+3A_pvse">PVse</code></td>
<td>
<p>a numeric vector containing the standard errors of the estimates of each
plausible value.</p>
</td></tr>
<tr><td><code id="repse_+3A_pve0">PVe0</code></td>
<td>
<p>a numeric vector containing the point estimates of each plausible value.</p>
</td></tr>
<tr><td><code id="repse_+3A_df">df</code></td>
<td>
<p>a logical value indicating if degrees should be calculated.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The standard errors are calculated using a modifier <code class="reqn">m</code>, for TIMSS
and ICILS: <code class="reqn">m = 0.5</code>; for ICILS and ICCS: <code class="reqn">m = 1</code>; and for PISA and TALIS:
<code class="reqn">\frac{1}{R(1-0.5)^2}</code>. Depending on the statistic, one of the following
formulas is used.
</p>
<p>The standard error not involving plausible values is calculated by:
</p>
<p style="text-align: center;"><code class="reqn">\sqrt{m\times \sum_{r=1}^{R}(\varepsilon_r-\varepsilon_0)^2}.</code>
</p>

<p>The standard error involving plausibles values and replicate weights is calculated by:
</p>
<p style="text-align: center;"><code class="reqn">\sqrt{\left[ \sum_{p=1}^{P} \left( m\times \sum_{r=1}^{R}(\varepsilon_{rp}-\varepsilon_{0p})^2 \right)  \dfrac{1}{P}\right]+  \left[ \left(1+ \dfrac{1}{P} \right) \dfrac{\sum_{p=1}^{P} (\varepsilon_{0p}-\overline{\varepsilon}_{0p})^{2}}{P-1} \right]}.</code>
</p>

<p>The standard error involving plausibles values without replicate weights is calculated by:
</p>
<p style="text-align: center;"><code class="reqn">\sqrt{  \dfrac{\sum_{p=1}^{P} SE^2_{\varepsilon_{0P}}}{P}+  \left[ \left(1+ \dfrac{1}{P} \right) \dfrac{\sum_{p=1}^{P} (\varepsilon_{0p}-\overline{\varepsilon}_{0p})^{2}}{P-1} \right]}.</code>
</p>

<p>The standard error of the difference of
two statistics (<code class="reqn">a</code> and <code class="reqn">b</code>) from independent samples is calculated by:
</p>
<p style="text-align: center;"><code class="reqn">\sqrt{SE_a^{2}+SE_b^{2}}.</code>
</p>

<p>The standard error of the difference of
two statistics (<code class="reqn">a</code> and <code class="reqn">b</code>) from dependent samples
not involving plausible values
is calculated by:
</p>
<p style="text-align: center;"><code class="reqn">\sqrt{m\times \sum_{r=1}^R((a_r-b_r)-(a_0-b_0))^2}.</code>
</p>

<p>The standard error of the difference of
two statistics (<code class="reqn">a</code> and <code class="reqn">b</code>) from dependent samples
involving plausible values
is calculated by:
</p>
<p style="text-align: center;"><code class="reqn">\sqrt{\left[ \sum_{p=1}^{P} \left( m\times \sum_{r=1}^{R}((a_{rp}-b_{rp})-(a_{0p}-b_{0p}))^2 \right)  \dfrac{1}{P}\right]+  \left[ \left(1+ \dfrac{1}{P} \right) \dfrac{\sum_{p=1}^{P} \left((a_{0p}-b_{0p})- ( \overline{a}_{0p}-\overline{b}_{0p}) \right)^{2}}{P-1} \right]}.</code>
</p>

<p>The standard error of a composite estimate is calculated by:
</p>
<p style="text-align: center;"><code class="reqn">\sqrt{\dfrac{\sum_{c=1}^CSE^2_{\varepsilon_c}}{C^{2}}}.</code>
</p>

<p>The standard error of the difference between an element (<code class="reqn">a</code>) of the composite
and the composite is calculated by:
</p>
<p style="text-align: center;"><code class="reqn">\sqrt{\dfrac{\sum_{c=1}^CSE^2_{\varepsilon_c}}{C^{2}}+\left(\dfrac{(C-1)^2-1}{C^2}\right)SE^2_a}.</code>
</p>

<p>Where
<code class="reqn">\varepsilon</code> represents a statistic of interest,
the subindex <code class="reqn">0</code> indicates an estimate using the total weights,
<code class="reqn">r</code> indicates a replicate from a total of <code class="reqn">R</code>,
<code class="reqn">p</code> indicates a plausible value from a total of <code class="reqn">P</code>,
and <code class="reqn">c</code> indicates an element in a composite estimate from value a total of <code class="reqn">C</code>.
</p>


<h3>Value</h3>

<p>the standard error.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Creation of replicate weights
RW &lt;- repcreate(df = repdata, # the data frame with all the information
                wt = "wt", # the total weights column name
                jkzone = "jkzones", # the jkzones column name
                jkrep = "jkrep", # the jkreps column name
                repwtname = "REPWT", # the desired name for the rep weights
                reps = 50, # the number of replications
                method = "ICILS") # the name of the method aka the study name

# Non-PVs ----

## Mean with total weights
E0 &lt;- stats::weighted.mean(x = repdata$item01, w = repdata$wt, na.rm = TRUE)
E0

## Means by replication
ER &lt;- as.vector(apply(RW,2,function(i){
  stats::weighted.mean(x = repdata$item01, w = i, na.rm = TRUE)
}))
ER

## Standard error by hand
repse(er = ER, e0 = E0, method = "ICILS")

## Standard error with repmean()
repmean(x = "item01",wt = "wt",repwt = RW,df = repdata, method = "ICILS")


# PVs ----

## Mean with total weights
E0 &lt;- sapply(1:5,function(i){
  stats::weighted.mean(x = repdata[,paste0("Math",i)], w = repdata$wt,
                       na.rm = TRUE)
})
E0

## Means by replication
ER &lt;- lapply(1:5, function(j){
  as.vector(apply(RW,2,function(i){
    stats::weighted.mean(x = repdata[,paste0("Math",j)], w = i, na.rm = TRUE)
  }))
})
ER

## Standard error by hand
repse(er = ER, e0 = E0, method = "ICILS")

## Standard error with repmean()
repmean(x = paste0("Math",1:5),wt = "wt",repwt = RW,df = repdata, method = "ICILS",PV = TRUE)


</code></pre>

<hr>
<h2 id='repsetup'>Setup for Analysis with Replicate Weights</h2><span id='topic+repsetup'></span>

<h3>Description</h3>

<p>Creates a list with common arguments used for analysis with replicate
weights.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>repsetup(
  repwt,
  wt,
  df,
  method = c("TIMSS", "PIRLS", "ICILS", "ICCS", "PISA", "TALIS"),
  group = NULL,
  exclude = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="repsetup_+3A_repwt">repwt</code></td>
<td>
<p>a string indicating the common names for the replicate weights
columns (within <code>df</code>), or a data frame with the replicate weights.</p>
</td></tr>
<tr><td><code id="repsetup_+3A_wt">wt</code></td>
<td>
<p>a string specifying the name of the column (within <code>df</code>) with the
total weights.</p>
</td></tr>
<tr><td><code id="repsetup_+3A_df">df</code></td>
<td>
<p>a data frame.</p>
</td></tr>
<tr><td><code id="repsetup_+3A_method">method</code></td>
<td>
<p>a string indicating the name of the large-scale assessment
to determine the replication method to use. Available options are:
<code>"TIMSS"</code>, <code>"PIRLS"</code>, <code>"ICILS"</code>, <code>"ICCS"</code>,
<code>"PISA"</code>, and <code>"TALIS"</code>. Note that <code>"TIMSS"</code> and <code>"PIRLS"</code>
refer to the method used from 2016 onwards.
Their method has not yet been implemented for previous cycles.</p>
</td></tr>
<tr><td><code id="repsetup_+3A_group">group</code></td>
<td>
<p>a string specifying the variable name (within <code>df</code>) to be
used for grouping. Categories in <code>group</code> are treated as independent, e.g.,
countries.</p>
</td></tr>
<tr><td><code id="repsetup_+3A_exclude">exclude</code></td>
<td>
<p>a vector indicating which groups
(in the same format as <code>group</code>)
should be excluded from the pooled and composite estimates.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list to be used in other functions.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Creation of replicate weights
RW &lt;- repcreate(df = repdata, # the data frame with all the information
                 wt = "wt", # the total weights column name
                 jkzone = "jkzones", # the jkzones column name
                 jkrep = "jkrep", # the jkreps column name
                 repwtname = "REPWT", # the desired name for the rep weights
                 reps = 50, # the number of replications
                 method = "ICILS") # the name of the method aka the study name

### No groups ----
stp1 &lt;- repsetup(repwt = RW, wt = "wt", df = repdata, method = "ICILS")
stp1

### Groups ----
stp2 &lt;- repsetup(repwt = RW, wt = "wt", df = repdata, method = "ICILS",
                 group = "GROUP", exclude = "GR2")
stp2


### repmean ----

repmean(x = "Math1",setup = stp1)

repmean(x = "Math1",setup = stp2)
</code></pre>

<hr>
<h2 id='WeMixPV'>Survey Weighted Mixed-Effects Models with Plausible Values</h2><span id='topic+WeMixPV'></span>

<h3>Description</h3>

<p>Fits a linear mixed-effects model using <a href="WeMix.html#topic+mix">mix</a> and plausible values.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>WeMixPV(formula, data = NULL, weights = NULL, pvs, relatedpvs = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="WeMixPV_+3A_formula">formula</code></td>
<td>
<p>a formula object in the style of <code>lme4</code> that creates the model.</p>
</td></tr>
<tr><td><code id="WeMixPV_+3A_data">data</code></td>
<td>
<p>a data frame containing the raw data for the model.</p>
</td></tr>
<tr><td><code id="WeMixPV_+3A_weights">weights</code></td>
<td>
<p>a character vector of names of weight variables found in the data frame starts with units (level 1) and increasing (larger groups).</p>
</td></tr>
<tr><td><code id="WeMixPV_+3A_pvs">pvs</code></td>
<td>
<p>a list indicating which variables from <code>formula</code>
should be replaced by which plausible values variables. For more details
check the examples.</p>
</td></tr>
<tr><td><code id="WeMixPV_+3A_relatedpvs">relatedpvs</code></td>
<td>
<p>a logical value indicating if <code>pvs</code> are drawn
from the same model, and have the same number of plausible values.
If <code>TRUE</code> (default), a total of <code class="reqn">n</code> estimations will be done,
where <code class="reqn">n</code> is the number of plausible values for each plausible value variable.
If <code>FALSE</code>, a total of <code class="reqn">n_1 \times n_2 \times n_...</code>
estimations will be done, where <code class="reqn">n_i</code> is the number of plausible values
in each plausible value variable.</p>
</td></tr>
<tr><td><code id="WeMixPV_+3A_...">...</code></td>
<td>

<p>Arguments passed on to <code><a href="WeMix.html#topic+mix">WeMix::mix</a></code>
</p>

<dl>
<dt><code>cWeights</code></dt><dd><p>logical, set to <code>TRUE</code> to use conditional weights. Otherwise, <code>mix</code> expects unconditional weights.</p>
</dd>
<dt><code>center_group</code></dt><dd><p>a list where the name of each element is the name of the aggregation level, and the element is a formula of
variable names to be group mean centered; for example to group mean center gender and age within the group student:
<code>list("student"= ~gender+age)</code>, default value of NULL does not perform any group mean centering.</p>
</dd>
<dt><code>center_grand</code></dt><dd><p>a formula of variable names  to be grand mean centered, for example to center the variable education by overall mean of 
education: <code>~education</code>. Default is NULL which does no centering.</p>
</dd>
<dt><code>max_iteration</code></dt><dd><p>a optional integer, for non-linear models fit by adaptive quadrature which limits number of iterations allowed
before quitting. Defaults  to 10. This is used because if the likelihood surface is flat, 
models may run for a very  long time without converging.</p>
</dd>
<dt><code>nQuad</code></dt><dd><p>an optional integer  number of quadrature points to evaluate models solved by adaptive quadrature.
Only non-linear models are evaluated with adaptive quadrature. See notes for additional guidelines.</p>
</dd>
<dt><code>run</code></dt><dd><p>logical; <code>TRUE</code> runs the model while <code>FALSE</code> provides partial output for debugging or testing. Only applies to non-linear
models evaluated by adaptive quadrature.</p>
</dd>
<dt><code>verbose</code></dt><dd><p>logical, default <code>FALSE</code>; set to <code>TRUE</code> to print results of intermediate steps of adaptive quadrature. Only applies to non-linear models.</p>
</dd>
<dt><code>acc0</code></dt><dd><p>deprecated; ignored.</p>
</dd>
<dt><code>keepAdapting</code></dt><dd><p>logical, set to <code>TRUE</code> when the adaptive quadrature should adapt after every Newton step. Defaults to <code>FALSE</code>. 
<code>FALSE</code> should be used for faster (but less accurate) results. Only applies to non-linear models.</p>
</dd>
<dt><code>start</code></dt><dd><p>optional numeric vector representing the point at which the model should start optimization; takes the shape of c(coef, vars) 
from results (see help).</p>
</dd>
<dt><code>fast</code></dt><dd><p>logical; deprecated</p>
</dd>
<dt><code>family</code></dt><dd><p>the family; optionally used to specify generalized linear mixed models. Currently only <code>binomial()</code> 
and <code>poisson()</code> are supported.</p>
</dd>
</dl>
</td></tr>
</table>


<h3>Value</h3>

<p>a list.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Prepare data weights
repdata2 &lt;- repdata
repdata2$wt1 &lt;- repdata2$wt # weight level 1
repdata2$wt2 &lt;- 1 # weight level 2


# Null model - with PVs
## Named list, with element names matching formula variables
pvs = list(MATH = paste0("Math",1:5))


m1 &lt;- WeMixPV(formula = MATH ~ 1 + (1|GROUP), # Intercept varies across GROUP
             pvs = pvs, # Named list
             data = repdata2, # Data frame
             weights = c("wt1","wt2")) # Weights vector
m1

## Fixed effects
m1$fixef

## Random effects
m1$ranef

## Models for each PV
summary(m1$models)

# Multiple regression
## Named list, with element names matching formula variables
pvs = list(MATH = paste0("Math",1:5))


m2 &lt;- WeMixPV(formula = MATH ~ 1 + GENDER + SES + schoolSES + (1|GROUP),
             pvs = pvs, # Named list
             data = repdata2, # Data frame
             weights = c("wt1","wt2")) # Weights vector
m2




</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
