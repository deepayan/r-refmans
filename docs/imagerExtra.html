<!DOCTYPE html><html><head><title>Help for package imagerExtra</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {imagerExtra}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#BalanceSimplest'><p>Balance color of image by Simplest Color Balance</p></a></li>
<li><a href='#DCT'><p>Two Dimensional Discrete Cosine Transformation and Inverse Cosine Transformation</p></a></li>
<li><a href='#DenoiseDCT'><p>denoise image by DCT denoising</p></a></li>
<li><a href='#dogs'><p>Photograph of a dog from GAHAG</p></a></li>
<li><a href='#EqualizeADP'><p>Adaptive Double Plateaus Histogram Equalization</p></a></li>
<li><a href='#EqualizeDP'><p>Double Plateaus Histogram Equalization</p></a></li>
<li><a href='#EqualizePiecewise'><p>Piecewise Affine Histogram Equalization</p></a></li>
<li><a href='#GetHue'><p>store hue of color image</p></a></li>
<li><a href='#Grayscale'><p>compute average of RGB channels</p></a></li>
<li><a href='#imagerExtra'><p>imagerExtra: Extra Image Processing Library Based on Imager</p></a></li>
<li><a href='#OCR'><p>Optical Character Recognition with tesseract</p></a></li>
<li><a href='#papers'><p>Photograph of a paper</p></a></li>
<li><a href='#RestoreHue'><p>restore hue of color image</p></a></li>
<li><a href='#SegmentCV'><p>Chan-Vese segmentation</p></a></li>
<li><a href='#SPE'><p>Correct inhomogeneous background of image by solving Screened Poisson Equation</p></a></li>
<li><a href='#ThresholdAdaptive'><p>Local Adaptive Thresholding</p></a></li>
<li><a href='#ThresholdFuzzy'><p>Fuzzy Entropy Image Segmentation</p></a></li>
<li><a href='#ThresholdML'><p>Multilevel Thresholding</p></a></li>
<li><a href='#ThresholdTriclass'><p>Iterative Triclass Thresholding</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Extra Image Processing Library Based on 'imager'</td>
</tr>
<tr>
<td>Version:</td>
<td>1.3.2</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Shota Ochi &lt;shotaochi1990@gmail.com&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Provides advanced functions for image processing based on the package 'imager'.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 2.10.0), imager (&ge; 0.40.2)</td>
</tr>
<tr>
<td>Imports:</td>
<td>fftwtools, magrittr, Rcpp (&ge; 0.12.14)</td>
</tr>
<tr>
<td>Suggests:</td>
<td>testthat (&ge; 2.0.0), knitr, rmarkdown, tesseract</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/ShotaOchi/imagerExtra">https://github.com/ShotaOchi/imagerExtra</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/ShotaOchi/imagerExtra/issues">https://github.com/ShotaOchi/imagerExtra/issues</a></td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>Rcpp</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>6.1.1</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2019-01-24 16:05:36 UTC; shota</td>
</tr>
<tr>
<td>Author:</td>
<td>Shota Ochi [aut, cre],
  Guoshen Yu [ctb, cph],
  Guillermo Sapiro [ctb, cph],
  Catalina Sbert [ctb, cph],
  Image Processing On Line [cph],
  Pascal Getreuer [ctb, cph]</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2019-01-25 13:50:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='BalanceSimplest'>Balance color of image by Simplest Color Balance</h2><span id='topic+BalanceSimplest'></span>

<h3>Description</h3>

<p>Balance color of image by Simplest Color Balance
</p>


<h3>Usage</h3>

<pre><code class='language-R'>BalanceSimplest(im, sleft, sright, range = c(0, 255))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="BalanceSimplest_+3A_im">im</code></td>
<td>
<p>a grayscale image of class cimg</p>
</td></tr>
<tr><td><code id="BalanceSimplest_+3A_sleft">sleft</code></td>
<td>
<p>left saturation percentage. sleft can be specified by numeric or string, e.g. 1 and &quot;1%&quot;. note that sleft is a percentile.</p>
</td></tr>
<tr><td><code id="BalanceSimplest_+3A_sright">sright</code></td>
<td>
<p>right saturation percentage. sright can be specified by numeric or string. note that sright is a percentile.</p>
</td></tr>
<tr><td><code id="BalanceSimplest_+3A_range">range</code></td>
<td>
<p>this function assumes that the range of pixel values of of input image is [0,255] by default. you may prefer [0,1].</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a grayscale image of class cimg
</p>


<h3>Author(s)</h3>

<p>Shota Ochi
</p>


<h3>References</h3>

<p>Nicolas Limare, Jose-Luis Lisani, Jean-Michel Morel, Ana Belen Petro, and Catalina Sbert, Simplest Color Balance, Image Processing On Line, 1 (2011), pp. 297-315. <a href="https://doi.org/10.5201/ipol.2011.llmps-scb">https://doi.org/10.5201/ipol.2011.llmps-scb</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>dev.new()
par(mfcol = c(1,2))
boats_g &lt;- grayscale(boats)
plot(boats_g, main = "Original")
BalanceSimplest(boats_g, 1, 1) %&gt;% plot(., main = "Simplest Color Balance")
</code></pre>

<hr>
<h2 id='DCT'>Two Dimensional Discrete Cosine Transformation and Inverse Cosine Transformation</h2><span id='topic+DCT'></span><span id='topic+DCT2D'></span><span id='topic+IDCT2D'></span>

<h3>Description</h3>

<p>DCT2D computes two dimensional discrete cosine transformation.
IDCT2D computes two dimensional inverse discrete cosine transformation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>DCT2D(imormat, returnmat = FALSE)

IDCT2D(imormat, returnmat = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="DCT_+3A_imormat">imormat</code></td>
<td>
<p>a grayscale image of class cimg or a numeric matrix</p>
</td></tr>
<tr><td><code id="DCT_+3A_returnmat">returnmat</code></td>
<td>
<p>if returnmat is TRUE, returns numeric matrix. if FALSE, returns a grayscale image of class cimg.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a grayscale image of class cimg or a numeric matrix
</p>


<h3>Author(s)</h3>

<p>Shota Ochi
</p>


<h3>References</h3>

<p>Makhoul, J. (1980). A fast cosine transform in one and two dimensions. IEEE Transactions on Acoustics, Speech, and Signal Processing. 28 (1): 27-34.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>g &lt;- grayscale(boats)
layout(matrix(1:2, 1, 2))
plot(g, main = "Original")
gg &lt;- DCT2D(g) %&gt;% IDCT2D() %&gt;% plot(main = "Transformed")
mean((g - gg)^2)
</code></pre>

<hr>
<h2 id='DenoiseDCT'>denoise image by DCT denoising</h2><span id='topic+DenoiseDCT'></span>

<h3>Description</h3>

<p>denoise image by DCT denoising
</p>


<h3>Usage</h3>

<pre><code class='language-R'>DenoiseDCT(im, sdn, flag_dct16x16 = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="DenoiseDCT_+3A_im">im</code></td>
<td>
<p>a grayscale image of class cimg</p>
</td></tr>
<tr><td><code id="DenoiseDCT_+3A_sdn">sdn</code></td>
<td>
<p>standard deviation of Gaussian white noise</p>
</td></tr>
<tr><td><code id="DenoiseDCT_+3A_flag_dct16x16">flag_dct16x16</code></td>
<td>
<p>flag_dct16x16 determines the size of patches. if TRUE, the size of patches is 16x16. if FALSE, the size if patches is 8x8.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a grayscale image of class cimg
</p>


<h3>Author(s)</h3>

<p>Shota Ochi
</p>


<h3>References</h3>

<p>Guoshen Yu, and Guillermo Sapiro, DCT Image Denoising: a Simple and Effective Image Denoising Algorithm, Image Processing On Line, 1 (2011), pp. 292-296. <a href="https://doi.org/10.5201/ipol.2011.ys-dct">https://doi.org/10.5201/ipol.2011.ys-dct</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>dev.new()
par(mfcol = c(1,2))
boats_g &lt;- grayscale(boats)
boats_noisy &lt;- imnoise(dim = dim(boats_g), sd = 0.05) + boats_g 
plot(boats_noisy, main = "Noisy Boats")
DenoiseDCT(boats_g, 0.05) %&gt;% plot(., main = "Denoised Boats")
</code></pre>

<hr>
<h2 id='dogs'>Photograph of a dog from GAHAG</h2><span id='topic+dogs'></span>

<h3>Description</h3>

<p>This photograph was downloaded from http://gahag.net/img/201603/03s/gahag-0062116383-1.jpg.
Its size was reduced by half to speed up loading and save space.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dogs
</code></pre>


<h3>Format</h3>

<p>an image of class cimg</p>


<h3>Source</h3>

<p><a href="http://gahag.net/img/201603/03s/gahag-0062116383-1.jpg">http://gahag.net/img/201603/03s/gahag-0062116383-1.jpg</a>
</p>

<hr>
<h2 id='EqualizeADP'>Adaptive Double Plateaus Histogram Equalization</h2><span id='topic+EqualizeADP'></span>

<h3>Description</h3>

<p>compute the paramters, t_down and t_up, and then apply double plateaus histogram equalization.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>EqualizeADP(im, n = 5, N = 1000, range = c(0, 255),
  returnparam = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="EqualizeADP_+3A_im">im</code></td>
<td>
<p>a grayscale image of class cimg</p>
</td></tr>
<tr><td><code id="EqualizeADP_+3A_n">n</code></td>
<td>
<p>window size to determine local maximum</p>
</td></tr>
<tr><td><code id="EqualizeADP_+3A_n">N</code></td>
<td>
<p>the number of subintervals of histogram</p>
</td></tr>
<tr><td><code id="EqualizeADP_+3A_range">range</code></td>
<td>
<p>range of the pixel values of image. this function assumes that the range of pixel values of of an input image is [0,255] by default. you may prefer [0,1].</p>
</td></tr>
<tr><td><code id="EqualizeADP_+3A_returnparam">returnparam</code></td>
<td>
<p>if returnparam is TRUE, returns the computed parameters: t_down and t_up.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a grayscale image of class cimg or a numericvector
</p>


<h3>Author(s)</h3>

<p>Shota Ochi
</p>


<h3>References</h3>

<p>Kun Liang, Yong Ma, Yue Xie, Bo Zhou ,Rui Wang (2012). A new adaptive contrast enhancement algorithm for infrared images based on double plateaus histogram equalization. Infrared Phys. Technol. 55, 309-315.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>g &lt;- grayscale(dogs)
layout(matrix(1:2, 1, 2))
plot(g, main = "Original")
EqualizeADP(g) %&gt;% plot(main = "Contrast Enhanced")
</code></pre>

<hr>
<h2 id='EqualizeDP'>Double Plateaus Histogram Equalization</h2><span id='topic+EqualizeDP'></span>

<h3>Description</h3>

<p>enhance contrast of image by double plateaus histogram equalization.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>EqualizeDP(im, t_down, t_up, N = 1000, range = c(0, 255))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="EqualizeDP_+3A_im">im</code></td>
<td>
<p>a grayscale image of class cimg</p>
</td></tr>
<tr><td><code id="EqualizeDP_+3A_t_down">t_down</code></td>
<td>
<p>lower threshold</p>
</td></tr>
<tr><td><code id="EqualizeDP_+3A_t_up">t_up</code></td>
<td>
<p>upper threshold</p>
</td></tr>
<tr><td><code id="EqualizeDP_+3A_n">N</code></td>
<td>
<p>the number of subintervals of histogram</p>
</td></tr>
<tr><td><code id="EqualizeDP_+3A_range">range</code></td>
<td>
<p>range of the pixel values of image. this function assumes that the range of pixel values of of an input image is [0,255] by default. you may prefer [0,1].</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a grayscale image of class cimg
</p>


<h3>Author(s)</h3>

<p>Shota Ochi
</p>


<h3>References</h3>

<p>Kun Liang, Yong Ma, Yue Xie, Bo Zhou ,Rui Wang (2012). A new adaptive contrast enhancement algorithm for infrared images based on double plateaus histogram equalization. Infrared Phys. Technol. 55, 309-315.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>g &lt;- grayscale(dogs)
layout(matrix(1:2, 1, 2))
plot(g, main = "Original")
EqualizeDP(g, 20, 186) %&gt;% plot(main = "Contrast Enhanced")
</code></pre>

<hr>
<h2 id='EqualizePiecewise'>Piecewise Affine Histogram Equalization</h2><span id='topic+EqualizePiecewise'></span>

<h3>Description</h3>

<p>enhance contrast of image by piecewise affine histogram equalization
</p>


<h3>Usage</h3>

<pre><code class='language-R'>EqualizePiecewise(im, N, smax = 255, smin = 0, range = c(0, 255))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="EqualizePiecewise_+3A_im">im</code></td>
<td>
<p>a grayscale image of class cimg</p>
</td></tr>
<tr><td><code id="EqualizePiecewise_+3A_n">N</code></td>
<td>
<p>number of subintervals of partition. N controls how the input gray levels will be mapped in the output image.
if N is large, Piecewise Affine Equalization and Histogram Equalization are very similar.</p>
</td></tr>
<tr><td><code id="EqualizePiecewise_+3A_smax">smax</code></td>
<td>
<p>maximum value of slopes. if smax is small, contrast enhancement is suppressed.</p>
</td></tr>
<tr><td><code id="EqualizePiecewise_+3A_smin">smin</code></td>
<td>
<p>minimum value of slopes. if smin is large, contrast enhancement is propelled, and saturations occur excessively.</p>
</td></tr>
<tr><td><code id="EqualizePiecewise_+3A_range">range</code></td>
<td>
<p>range of the pixel values of image. this function assumes that the range of pixel values of of an input image is [0,255] by default. you may prefer [0,1].
if you change range, you should change smax. one example is this (smax = range[2] - range[1]).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a grayscale image of class cimg
</p>


<h3>Author(s)</h3>

<p>Shota Ochi
</p>


<h3>References</h3>

<p>Jose-Luis Lisani, Ana-Belen Petro, and Catalina Sbert, Color and Contrast Enhancement by Controlled Piecewise Affine Histogram Equalization, Image Processing On Line, 2 (2012), pp. 243-265. <a href="https://doi.org/10.5201/ipol.2012.lps-pae">https://doi.org/10.5201/ipol.2012.lps-pae</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>dev.new()
par(mfcol = c(1,2))
boats_g &lt;- grayscale(boats)
plot(boats_g, main = "Original")
EqualizePiecewise(boats_g, 10) %&gt;% plot(., main = "Piecewise Affine Equalization")
</code></pre>

<hr>
<h2 id='GetHue'>store hue of color image</h2><span id='topic+GetHue'></span>

<h3>Description</h3>

<p>store hue of color image
</p>


<h3>Usage</h3>

<pre><code class='language-R'>GetHue(imcol)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="GetHue_+3A_imcol">imcol</code></td>
<td>
<p>a color image of class cimg</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a color image of class cimg
</p>


<h3>Author(s)</h3>

<p>Shota Ochi
</p>


<h3>Examples</h3>

<pre><code class='language-R'>GetHue(boats)
</code></pre>

<hr>
<h2 id='Grayscale'>compute average of RGB channels</h2><span id='topic+Grayscale'></span>

<h3>Description</h3>

<p>compute average of RGB channels
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Grayscale(imcol)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Grayscale_+3A_imcol">imcol</code></td>
<td>
<p>a color image of class cimg</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a grayscale image of class cimg
</p>


<h3>Author(s)</h3>

<p>Shota Ochi
</p>


<h3>Examples</h3>

<pre><code class='language-R'>Grayscale(boats) %&gt;% plot
</code></pre>

<hr>
<h2 id='imagerExtra'>imagerExtra: Extra Image Processing Library Based on Imager</h2><span id='topic+imagerExtra'></span><span id='topic+imagerExtra-package'></span>

<h3>Description</h3>

<p>imagerExtra is built on imager. imager by Simon Simon Barthelme provides an interface with CImg that is a C++ library for image processing. imager makes functions of CImg accessible from R and adds many utilities for accessing and working with image data from R.
imagerExtra provides advanced functions for image processing based on imager.
</p>

<hr>
<h2 id='OCR'>Optical Character Recognition with tesseract</h2><span id='topic+OCR'></span><span id='topic+OCR_data'></span>

<h3>Description</h3>

<p>OCR and OCR_data are wrappers for ocr and ocr_data of tesseract package.
You need to install tesseract package to use these functions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>OCR(imorpx, engine = tesseract::tesseract("eng"), HOCR = FALSE)

OCR_data(imorpx, engine = tesseract::tesseract("eng"))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="OCR_+3A_imorpx">imorpx</code></td>
<td>
<p>a grayscale image of class cimg or a pixel set</p>
</td></tr>
<tr><td><code id="OCR_+3A_engine">engine</code></td>
<td>
<p>a tesseract engine. See the reference manual of tesseract for detail.</p>
</td></tr>
<tr><td><code id="OCR_+3A_hocr">HOCR</code></td>
<td>
<p>if TRUE return results as HOCR xml instead of plain text</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Shota Ochi
</p>


<h3>Examples</h3>

<pre><code class='language-R'>hello &lt;- DenoiseDCT(papers, 0.01) %&gt;% ThresholdAdaptive(., 0.1, range = c(0,1))
if (requireNamespace("tesseract", quietly = TRUE))
{
  OCR(hello) %&gt;% cat
  OCR_data(hello)
}
</code></pre>

<hr>
<h2 id='papers'>Photograph of a paper</h2><span id='topic+papers'></span>

<h3>Description</h3>

<p>This photograph was filmed by Shota Ochi.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>papers
</code></pre>


<h3>Format</h3>

<p>an image of class cimg</p>

<hr>
<h2 id='RestoreHue'>restore hue of color image</h2><span id='topic+RestoreHue'></span>

<h3>Description</h3>

<p>restore hue of color image
</p>


<h3>Usage</h3>

<pre><code class='language-R'>RestoreHue(im, hueim)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="RestoreHue_+3A_im">im</code></td>
<td>
<p>a grayscale image of class cimg</p>
</td></tr>
<tr><td><code id="RestoreHue_+3A_hueim">hueim</code></td>
<td>
<p>a color image of class cimg</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a color image of class cimg
</p>


<h3>Author(s)</h3>

<p>Shota Ochi
</p>


<h3>Examples</h3>

<pre><code class='language-R'>g &lt;- Grayscale(boats)
hue &lt;- GetHue(boats)
layout(matrix(1:2, 1, 2))
plot(g, main = "Original")
RestoreHue(g, hue) %&gt;% plot(main="Resotred")
</code></pre>

<hr>
<h2 id='SegmentCV'>Chan-Vese segmentation</h2><span id='topic+SegmentCV'></span>

<h3>Description</h3>

<p>iterative image segmentation with Chan-Vese model
</p>


<h3>Usage</h3>

<pre><code class='language-R'>SegmentCV(im, mu = 0.25, nu = 0, lambda1 = 1, lambda2 = 1,
  tol = 1e-04, maxiter = 500, dt = 0.5, initial, returnstep)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="SegmentCV_+3A_im">im</code></td>
<td>
<p>a grayscale image of class cimg</p>
</td></tr>
<tr><td><code id="SegmentCV_+3A_mu">mu</code></td>
<td>
<p>length penalty</p>
</td></tr>
<tr><td><code id="SegmentCV_+3A_nu">nu</code></td>
<td>
<p>area penalty</p>
</td></tr>
<tr><td><code id="SegmentCV_+3A_lambda1">lambda1</code></td>
<td>
<p>fit weight inside the cuve</p>
</td></tr>
<tr><td><code id="SegmentCV_+3A_lambda2">lambda2</code></td>
<td>
<p>fit weight outside the curve</p>
</td></tr>
<tr><td><code id="SegmentCV_+3A_tol">tol</code></td>
<td>
<p>convergence tolerance</p>
</td></tr>
<tr><td><code id="SegmentCV_+3A_maxiter">maxiter</code></td>
<td>
<p>maximum number of iterations</p>
</td></tr>
<tr><td><code id="SegmentCV_+3A_dt">dt</code></td>
<td>
<p>time step</p>
</td></tr>
<tr><td><code id="SegmentCV_+3A_initial">initial</code></td>
<td>
<p>&quot;interactive&quot; or a grayscale image of class cimg. you can define initial condition as a rectangle shape interactively if initial is &quot;interactive&quot;. If initial is a grayscale image of class cimg, pixels whose values are negative will be treated as outside of contour. pixels whose values are non-negative will be treated as inside of contour. checker board condition will be used if initial is not specified.</p>
</td></tr>
<tr><td><code id="SegmentCV_+3A_returnstep">returnstep</code></td>
<td>
<p>a numeric vector that determines which result will be returned. 0 means initial condition, and 1 means the result after 1 iteration. final result will be returned if returnstep is not specified.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a pixel set or a list of lists of numeric and pixel set
</p>


<h3>Author(s)</h3>

<p>Shota Ochi
</p>


<h3>References</h3>

<p>Pascal Getreuer (2012). Chan-Vese Segmentation. Image Processing On Line 2, 214-224.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>layout(matrix(1:2, 1, 2))
g &lt;- grayscale(dogs)
plot(g, main = "Original")
SegmentCV(g, lambda2 = 15) %&gt;% plot(main = "Binarized")
</code></pre>

<hr>
<h2 id='SPE'>Correct inhomogeneous background of image by solving Screened Poisson Equation</h2><span id='topic+SPE'></span>

<h3>Description</h3>

<p>Correct inhomogeneous background of image by solving Screened Poisson Equation
</p>


<h3>Usage</h3>

<pre><code class='language-R'>SPE(im, lamda, s = 0.1, range = c(0, 255))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="SPE_+3A_im">im</code></td>
<td>
<p>a grayscale image of class cimg</p>
</td></tr>
<tr><td><code id="SPE_+3A_lamda">lamda</code></td>
<td>
<p>this function corrects inhomogeneous background while preserving image details. lamda controls the trade-off. when lamda is too large, this function acts as an edge detector.</p>
</td></tr>
<tr><td><code id="SPE_+3A_s">s</code></td>
<td>
<p>saturation percentage. this function uses <code><a href="#topic+BalanceSimplest">BalanceSimplest</a></code>. s is used as both sleft and sright. that's why s can not be over 50%.</p>
</td></tr>
<tr><td><code id="SPE_+3A_range">range</code></td>
<td>
<p>this function assumes that the range of pixel values of of an input image is [0,255] by default. you may prefer [0,1].</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a grayscale image of class cimg
</p>


<h3>Author(s)</h3>

<p>Shota Ochi
</p>


<h3>References</h3>

<p>Jean-Michel Morel, Ana-Belen Petro, and Catalina Sbert, Screened Poisson Equation for Image Contrast Enhancement, Image Processing On Line, 4 (2014), pp. 16-29. <a href="https://doi.org/10.5201/ipol.2014.84">https://doi.org/10.5201/ipol.2014.84</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>dev.new()
par(mfcol = c(1,2))
boats_g &lt;- grayscale(boats)
plot(boats_g, main = "Original")
SPE(boats_g, 0.1) %&gt;% plot(main = "Screened Poisson Equation")
</code></pre>

<hr>
<h2 id='ThresholdAdaptive'>Local Adaptive Thresholding</h2><span id='topic+ThresholdAdaptive'></span>

<h3>Description</h3>

<p>Local Adaptive Thresholding
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ThresholdAdaptive(im, k, windowsize = 17, range = c(0, 255))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ThresholdAdaptive_+3A_im">im</code></td>
<td>
<p>a grayscale image of class cimg</p>
</td></tr>
<tr><td><code id="ThresholdAdaptive_+3A_k">k</code></td>
<td>
<p>a numeric in the range [0,1]. when k is high, local threshold values tend to be lower. when k is low, local threshold value tend to be higher.</p>
</td></tr>
<tr><td><code id="ThresholdAdaptive_+3A_windowsize">windowsize</code></td>
<td>
<p>windowsize controls the number of local neighborhood</p>
</td></tr>
<tr><td><code id="ThresholdAdaptive_+3A_range">range</code></td>
<td>
<p>this function assumes that the range of pixel values of of input image is [0,255] by default. you may prefer [0,1]. 
Note that range determines the max standard deviation. The max standard deviation plays an important role in this function.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a pixel set
</p>


<h3>Author(s)</h3>

<p>Shota Ochi
</p>


<h3>References</h3>

<p>Faisal Shafait, Daniel Keysers, Thomas M. Breuel, &quot;Efficient implementation of local adaptive thresholding techniques using integral images&quot;, Proc. SPIE 6815, Document Recognition and Retrieval XV, 681510 (28 January 2008)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>layout(matrix(1:4, 2, 2))
plot(papers, main = "Original")
threshold(papers) %&gt;% plot(main = "A variant of Otsu")
ThresholdAdaptive(papers, 0, range = c(0,1)) %&gt;% plot(main = "local adaptive (k = 0)")
ThresholdAdaptive(papers, 0.2, range = c(0,1)) %&gt;% plot(main = "local adaptive (k = 0.2)")
</code></pre>

<hr>
<h2 id='ThresholdFuzzy'>Fuzzy Entropy Image Segmentation</h2><span id='topic+ThresholdFuzzy'></span>

<h3>Description</h3>

<p>automatic fuzzy thresholding based on particle swarm optimization
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ThresholdFuzzy(im, n = 50, maxiter = 100, omegamax = 0.9,
  omegamin = 0.1, c1 = 2, c2 = 2, mutrate = 0.2, vmaxcoef = 0.1,
  intervalnumber = 1000, returnvalue = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ThresholdFuzzy_+3A_im">im</code></td>
<td>
<p>a grayscale image of class cimg</p>
</td></tr>
<tr><td><code id="ThresholdFuzzy_+3A_n">n</code></td>
<td>
<p>swarm size</p>
</td></tr>
<tr><td><code id="ThresholdFuzzy_+3A_maxiter">maxiter</code></td>
<td>
<p>maximum iterative time</p>
</td></tr>
<tr><td><code id="ThresholdFuzzy_+3A_omegamax">omegamax</code></td>
<td>
<p>maximum inertia weight</p>
</td></tr>
<tr><td><code id="ThresholdFuzzy_+3A_omegamin">omegamin</code></td>
<td>
<p>minimum inertia weight</p>
</td></tr>
<tr><td><code id="ThresholdFuzzy_+3A_c1">c1</code></td>
<td>
<p>acceleration coefficient</p>
</td></tr>
<tr><td><code id="ThresholdFuzzy_+3A_c2">c2</code></td>
<td>
<p>acceleration coefficient</p>
</td></tr>
<tr><td><code id="ThresholdFuzzy_+3A_mutrate">mutrate</code></td>
<td>
<p>rate of gaussian mutation</p>
</td></tr>
<tr><td><code id="ThresholdFuzzy_+3A_vmaxcoef">vmaxcoef</code></td>
<td>
<p>coefficient of maximum velocity</p>
</td></tr>
<tr><td><code id="ThresholdFuzzy_+3A_intervalnumber">intervalnumber</code></td>
<td>
<p>interval number of histogram</p>
</td></tr>
<tr><td><code id="ThresholdFuzzy_+3A_returnvalue">returnvalue</code></td>
<td>
<p>if returnvalue is TRUE, returns a threshold value. if FALSE, returns a pixel set.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a pixsel set or a numeric
</p>


<h3>Author(s)</h3>

<p>Shota Ochi
</p>


<h3>References</h3>

<p>Linyi Li, Deren Li (2008). Fuzzy entropy image segmentation based on particle swarm optimization. Progress in Natural Science.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>g &lt;- grayscale(boats)
layout(matrix(1:2, 1, 2))
plot(g, main = "Original")
ThresholdFuzzy(g) %&gt;% plot(main = "Fuzzy Thresholding")
</code></pre>

<hr>
<h2 id='ThresholdML'>Multilevel Thresholding</h2><span id='topic+ThresholdML'></span>

<h3>Description</h3>

<p>Segments a grayscale image into several gray levels.
Multilevel thresholding selection based on the artificial bee colony algorithm is used when thr is not a numeric vector. Preset parameters for fast computing is used when thr is &quot;fast&quot;. Preset parameters for precise computing is used when thr is &quot;precise&quot;. You can tune the parameters if thr is &quot;manual&quot;.
Also you can specify the values of thresholds by setting thr as a numeric vector.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ThresholdML(im, k, thr = "fast", sn = 30, mcn = 100, limit = 100,
  intervalnumber = 1000, returnvalue = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ThresholdML_+3A_im">im</code></td>
<td>
<p>a grayscale image of class cimg</p>
</td></tr>
<tr><td><code id="ThresholdML_+3A_k">k</code></td>
<td>
<p>level of thresholding. k is ignored when thr is a numeric vector.</p>
</td></tr>
<tr><td><code id="ThresholdML_+3A_thr">thr</code></td>
<td>
<p>thresholds, either numeric vector, or &quot;fast&quot;, or &quot;precise&quot;, or &quot;manual&quot;.</p>
</td></tr>
<tr><td><code id="ThresholdML_+3A_sn">sn</code></td>
<td>
<p>population size. sn is ignored except when thr is &quot;manual&quot;.</p>
</td></tr>
<tr><td><code id="ThresholdML_+3A_mcn">mcn</code></td>
<td>
<p>maximum cycle number. mcn is ignored except when thr is &quot;manual&quot;.</p>
</td></tr>
<tr><td><code id="ThresholdML_+3A_limit">limit</code></td>
<td>
<p>abandonment criteria. limit is ignored except when thr is &quot;manual&quot;.</p>
</td></tr>
<tr><td><code id="ThresholdML_+3A_intervalnumber">intervalnumber</code></td>
<td>
<p>interval number of histogram. intervalnumber is ignored except when thr is &quot;manual&quot;.</p>
</td></tr>
<tr><td><code id="ThresholdML_+3A_returnvalue">returnvalue</code></td>
<td>
<p>if returnvalue is TRUE, returns threshold values. if FALSE, returns a grayscale image of class cimg.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a grayscale image of class cimg or a numeric vector
</p>


<h3>Author(s)</h3>

<p>Shota Ochi
</p>


<h3>References</h3>

<p>Ming-HuwiHorng (2011). Multilevel thresholding selection based on the artificial bee colony algorithm for image segmentation. Expert Systems with Applications.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>g &lt;- grayscale(boats)
ThresholdML(g, k = 2) %&gt;% plot
</code></pre>

<hr>
<h2 id='ThresholdTriclass'>Iterative Triclass Thresholding</h2><span id='topic+ThresholdTriclass'></span>

<h3>Description</h3>

<p>compute threshold value by Iterative Triclass Threshold Technique
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ThresholdTriclass(im, stopval = 0.01, repeatnum, intervalnumber = 1000,
  returnvalue = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ThresholdTriclass_+3A_im">im</code></td>
<td>
<p>a grayscale image of class cimg</p>
</td></tr>
<tr><td><code id="ThresholdTriclass_+3A_stopval">stopval</code></td>
<td>
<p>value to determine whether stop iteration of triclass thresholding or not. Note that if repeat is set, stop is ignored.</p>
</td></tr>
<tr><td><code id="ThresholdTriclass_+3A_repeatnum">repeatnum</code></td>
<td>
<p>number of repetition of triclass thresholding</p>
</td></tr>
<tr><td><code id="ThresholdTriclass_+3A_intervalnumber">intervalnumber</code></td>
<td>
<p>interval number  of histogram</p>
</td></tr>
<tr><td><code id="ThresholdTriclass_+3A_returnvalue">returnvalue</code></td>
<td>
<p>if returnvalue is TRUE, ThresholdTriclass returns threshold value. if FALSE, ThresholdTriclass returns pixset.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a pixel set or a numeric
</p>


<h3>Author(s)</h3>

<p>Shota Ochi
</p>


<h3>References</h3>

<p>Cai HM, Yang Z, Cao XH, Xia WM, Xu XY (2014). A New Iterative Triclass Thresholding Technique in Image Segmentation. IEEE TRANSACTIONS ON IMAGE PROCESSING.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>g &lt;- grayscale(boats)
layout(matrix(1:4, 2, 2))
plot(boats, main = "Original")
plot(g, main = "Grayscale")
threshold(g) %&gt;% plot(main = "A Variant of Otsu")
ThresholdTriclass(g) %&gt;% plot(main = "Triclass")
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
