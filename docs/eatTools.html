<!DOCTYPE html><html><head><title>Help for package eatTools</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {eatTools}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#addLeadingZerosToCharInt'><p>Add leading zeros to all columns that can be identified as integers in a character data.frame</p></a></li>
<li><a href='#asNumericIfPossible'>
<p>Convert a Vector, Matrix or Data Frame Into Numeric Values If Possible</p></a></li>
<li><a href='#catch_asNumericIfPossible'>
<p>Use <code>asNumericIfPossible</code> with modified warning.</p></a></li>
<li><a href='#contr.wec.weighted'><p>Calculates contrasts for a weighted factor variable based on weighted effect coding</p></a></li>
<li><a href='#crop'><p>Remove Trailing and Leading Characters From Character Strings</p></a></li>
<li><a href='#descr'><p>Descriptive statistics for one or several variables</p></a></li>
<li><a href='#do_call_rbind_withName'><p>Row bind a list while assigning names to rows</p></a></li>
<li><a href='#eatTools-package'><p>eatTools: Miscellaneous Functions for the Analysis of Educational Assessments</p></a></li>
<li><a href='#existsBackgroundVariables'><p>Internally needed function for consistency checks and data preparation.</p></a></li>
<li><a href='#facToChar'><p>Transform columns in a data frame</p></a></li>
<li><a href='#gsubAll'><p>Pattern matching and replacement</p></a></li>
<li><a href='#halveString'><p>Split string exactly in two parts</p></a></li>
<li><a href='#insert.col'><p>Insert Columns into a <code>data.frame</code> at a Specific Position</p></a></li>
<li><a href='#makeDataFrame'><p>Converts <code>tbl</code> or <code>data.table</code> objects to plain <code>data.frames</code> for internal processing</p></a></li>
<li><a href='#makeTria'><p>Reshapes an unordered covariance/correlation matrix into triangular shape</p></a></li>
<li><a href='#mergeAttr'><p>Merge Two Data Frames with additional messages and maintain variable attributes</p></a></li>
<li><a href='#multiseq'>
<p>multiple sequences</p></a></li>
<li><a href='#na_omit_selection'><p>Drop rows containing missing values</p></a></li>
<li><a href='#num.to.cat'><p>Transform continuous variables into ordered factors</p></a></li>
<li><a href='#print_and_capture'><p>Easy integration of (small) tables into (error) messages</p></a></li>
<li><a href='#pwc'><p>Part-whole correlation for numeric data frames</p></a></li>
<li><a href='#rbind_common'><p>Combine data.frames by row, using only common columns.</p></a></li>
<li><a href='#readMultisep'><p>Read in data.frames with separator characters &gt;=1Byte</p></a></li>
<li><a href='#recodeLookup'><p>Recode a variable according to a lookup table</p></a></li>
<li><a href='#removeNonNumeric'><p>Removes all non-numeric characters from a string.</p></a></li>
<li><a href='#removeNumeric'><p>Removes alphanumeric characters from a string.</p></a></li>
<li><a href='#removePattern'><p>Removes a specified pattern from a string.</p></a></li>
<li><a href='#roundDF'><p>Round a <code>data.frame</code>.</p></a></li>
<li><a href='#seq2'>
<p>Sequence generation</p></a></li>
<li><a href='#set.col.type'>
<p>Set the Class of Columns in a Data Frame</p></a></li>
<li><a href='#tablePattern'><p>Creates skeleton for frequency tables with desired values</p></a></li>
<li><a href='#tableUnlist'><p>Frequency table for data frames, e.g. across multiple columns</p></a></li>
<li><a href='#whereAre'><p>Matches a scalar with elements of a vector.</p></a></li>
<li><a href='#wideToLong'><p>Transform wide format data sets into the long format necessary for eatRep analyses</p></a></li>
<li><a href='#wtdTable'><p>Computed weighted frequency tables</p></a></li>
<li><a href='#wtdVar'><p>Computed weighted variance</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Miscellaneous Functions for the Analysis of Educational
Assessments</td>
</tr>
<tr>
<td>Version:</td>
<td>0.7.5</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 4.0.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>stats, data.table</td>
</tr>
<tr>
<td>Description:</td>
<td>
   Miscellaneous functions for data cleaning and data analysis of educational assessments. Includes functions for descriptive 
   analyses, character vector manipulations and weighted statistics. Mainly a lightweight dependency for the packages 'eatRep', 
   'eatGADS', 'eatPrep' and 'eatModel' (which will be subsequently submitted to 'CRAN').
   The function for defining (weighted) contrasts in weighted effect coding refers to
   te Grotenhuis et al. (2017) &lt;<a href="https://doi.org/10.1007%2Fs00038-016-0901-1">doi:10.1007/s00038-016-0901-1</a>&gt;.
   Functions for weighted statistics refer to
   Wolter (2007) &lt;<a href="https://doi.org/10.1007%2F978-0-387-35099-8">doi:10.1007/978-0-387-35099-8</a>&gt;.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/weirichs/eatTools">https://github.com/weirichs/eatTools</a></td>
</tr>
<tr>
<td>Suggests:</td>
<td>testthat, covr</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-11-23 12:51:11 UTC; Sebastian Weirich</td>
</tr>
<tr>
<td>Author:</td>
<td>Sebastian Weirich [aut, cre],
  Martin Hecht [aut],
  Karoline Sachse [aut],
  Benjamin Becker [aut],
  Nicole Mahler [aut]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Sebastian Weirich &lt;sebastian.weirich@iqb.hu-berlin.de&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-11-23 13:30:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='addLeadingZerosToCharInt'>Add leading zeros to all columns that can be identified as integers in a character data.frame</h2><span id='topic+addLeadingZerosToCharInt'></span>

<h3>Description</h3>

<p>Adds leading zeros to all columns that can be identified as integers in a data.frame that consists of character columns only.</p>


<h3>Usage</h3>

<pre><code class='language-R'>addLeadingZerosToCharInt(dat)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="addLeadingZerosToCharInt_+3A_dat">dat</code></td>
<td>

<p>a data.frame consisting of character columns only
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a data.frame of only character columns and the same dimensions as the input data.frame where all columns with integers are all of the same arity now due to added leading zeros.
</p>


<h3>Author(s)</h3>

<p>Karoline Sachse
</p>


<h3>Examples</h3>

<pre><code class='language-R'>dat &lt;- data.frame(v1 = c("0","300","e",NA),
                  v2=c("0","90","10000",NA),
                  v3=c("k","kk","kkk",NA),
                  v4=NA,
                  v5=c("0","90","100","1"))
dat &lt;- set.col.type(dat)
addLeadingZerosToCharInt(dat)
</code></pre>

<hr>
<h2 id='asNumericIfPossible'>
Convert a Vector, Matrix or Data Frame Into Numeric Values If Possible
</h2><span id='topic+asNumericIfPossible'></span>

<h3>Description</h3>

<p>This function converts vectors and matrices of all kinds to <code>numeric</code>. The function can
also be used to convert all columns of a <code>data.frame</code> to class <code>numeric</code> for
which this conversion is possible i.e. without creating <code>NA</code> when it fails.
Non-convertible columns are maintained.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>asNumericIfPossible(x, maintain.factor.scores = TRUE, force.string = TRUE,
transform.factors = TRUE, varName = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="asNumericIfPossible_+3A_x">x</code></td>
<td>
<p>A vector or data frame which should be converted. </p>
</td></tr>
<tr><td><code id="asNumericIfPossible_+3A_maintain.factor.scores">maintain.factor.scores</code></td>
<td>
<p>Logical:
If <code>TRUE</code>, conversion of the factor levels is attempted
(like in <code>as.numeric(as.character(f))</code>).
If <code>FALSE</code>, the internal codes of the factor are returned
(like in <code>as.numeric(f)</code>).
See 'Details'. This argument is only evaluated if
<code>transform.factors = TRUE</code>.  </p>
</td></tr>
<tr><td><code id="asNumericIfPossible_+3A_force.string">force.string</code></td>
<td>
<p>Logical indicating whether columns should be force to
numeric, even if NAs are induced.
If <code>FALSE</code>, affected columns are maintained.
If <code>TRUE</code>, conversion is forced.   </p>
</td></tr>
<tr><td><code id="asNumericIfPossible_+3A_transform.factors">transform.factors</code></td>
<td>
<p>Logical indicating whether columns of class
<code>factor</code> should be converted.
If <code>FALSE</code>, columns of class <code>factor</code> are maintained.
If <code>TRUE</code>, conversion of factors is attempted.   </p>
</td></tr>
<tr><td><code id="asNumericIfPossible_+3A_varname">varName</code></td>
<td>
<p>Optional: Name of the corresponding variable. Doesn't have
to be changed by user.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>In <span class="rlang"><b>R</b></span>, factors may represent ordered categories or categorical variables.
Depending on the meaning of the variable, a conversion of the nominal values
(of a factor variable) to numeric values may be desirable or not. The arguments
<code>transform.factors</code> and <code>maintain.factor.scores</code> specify if and how
factor variables should be treated. See examples.
</p>


<h3>Author(s)</h3>

<p>Sebastian Weirich, Karoline Sachse, Benjamin Becker
</p>


<h3>Examples</h3>

<pre><code class='language-R'>dat &lt;- data.frame(X1 = c("1",NA,"0"), X2 = c("a",NA,"b"),
                  X3 = c(TRUE,FALSE,FALSE), X4 = as.factor(c("a",NA,"b")),
                  X5 = as.factor(c("5","6","7")), stringsAsFactors = FALSE)
str(dat)
asNumericIfPossible(dat)
asNumericIfPossible(dat, transform.factors=TRUE,
                      maintain.factor.scores=FALSE)
asNumericIfPossible(dat, transform.factors=TRUE,
                      maintain.factor.scores=TRUE)
</code></pre>

<hr>
<h2 id='catch_asNumericIfPossible'>
Use <code>asNumericIfPossible</code> with modified warning.
</h2><span id='topic+catch_asNumericIfPossible'></span>

<h3>Description</h3>

<p>This function uses <code>asNumericIfPossible</code> but lets the user change the warning
issued by <code>asNumericIfPossible</code>. Suited for use in other <code>R</code> packages.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>catch_asNumericIfPossible(x, warn, maintain.factor.scores = TRUE,
force.string = TRUE, transform.factors = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="catch_asNumericIfPossible_+3A_x">x</code></td>
<td>
<p>A vector or data frame which should be converted. </p>
</td></tr>
<tr><td><code id="catch_asNumericIfPossible_+3A_warn">warn</code></td>
<td>
<p>A character vector of length 1 with the desired warning. </p>
</td></tr>
<tr><td><code id="catch_asNumericIfPossible_+3A_maintain.factor.scores">maintain.factor.scores</code></td>
<td>
<p>Logical:
If <code>TRUE</code>, conversion of the factor levels is attempted
(like in <code>as.numeric(as.character(f))</code>).
If <code>FALSE</code>, the internal codes of the factor are returned
(like in <code>as.numeric(f)</code>).
See 'Details'. This argument is only evaluated if
<code>transform.factors = TRUE</code>.  </p>
</td></tr>
<tr><td><code id="catch_asNumericIfPossible_+3A_force.string">force.string</code></td>
<td>
<p>Logical indicating whether columns should be force to
numeric, even if NAs are induced.
If <code>FALSE</code>, affected columns are maintained.
If <code>TRUE</code>, conversion is forced.   </p>
</td></tr>
<tr><td><code id="catch_asNumericIfPossible_+3A_transform.factors">transform.factors</code></td>
<td>
<p>Logical indicating whether columns of class
<code>factor</code> should be converted.
If <code>FALSE</code>, columns of class <code>factor</code> are maintained.
If <code>TRUE</code>, conversion of factors is attempted.   </p>
</td></tr>
</table>


<h3>Details</h3>

<p>For details see <code><a href="#topic+asNumericIfPossible">asNumericIfPossible</a></code>
</p>


<h3>Author(s)</h3>

<p>Benjamin Becker
</p>


<h3>Examples</h3>

<pre><code class='language-R'>char &lt;- c("a", "b", 1)
catch_asNumericIfPossible(x = char, warn = "Vector could not be converted")
</code></pre>

<hr>
<h2 id='contr.wec.weighted'>Calculates contrasts for a weighted factor variable based on weighted effect coding</h2><span id='topic+contr.wec.weighted'></span>

<h3>Description</h3>

<p>Function works equivalent to <code>contr.wec</code> from the <code>wec</code> package, but allows
for weighted contrasts.</p>


<h3>Usage</h3>

<pre><code class='language-R'>contr.wec.weighted (x, omitted, weights)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="contr.wec.weighted_+3A_x">x</code></td>
<td>

<p>grouping variable of class factor
</p>
</td></tr>
<tr><td><code id="contr.wec.weighted_+3A_omitted">omitted</code></td>
<td>

<p>Label of the factor label that should be taken as the omitted category
</p>
</td></tr>
<tr><td><code id="contr.wec.weighted_+3A_weights">weights</code></td>
<td>

<p>Numeric vector of non-negative weights
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a contrast matrix based on weighted effect coding.
</p>


<h3>Author(s)</h3>

<p>Sebastian Weirich, based upon the <code>contr.wec</code> function of the <code>wec</code> package
</p>


<h3>Examples</h3>

<pre><code class='language-R'>### exemplary data according to wec paper
dat &lt;- data.frame ( group = as.factor(c(rep(1,3), rep(2,2))), wgt = c(2/3, 4/3, 2, 3/8, 5/8))
### default contrasts
contrasts(dat[,"group"])
### weighted effect coding for weighted data
contr.wec.weighted(x= dat[,"group"], omitted=1,weights=dat[,"wgt"])
### equal to weighted effect coding: wec::contr.wec(x= dat[,"group"], omitted=1)
contr.wec.weighted(x= dat[,"group"], omitted=1,weights=rep(1, nrow(dat)))
</code></pre>

<hr>
<h2 id='crop'>Remove Trailing and Leading Characters From Character Strings</h2><span id='topic+crop'></span>

<h3>Description</h3>

<p>Similarly to the function <code>trim</code> from the <code>gdata</code> package, this function
can be used to remove trailing and leading spaces from character strings. However, 
in contrast to <code>trim</code>, any character can be removed by <code>crop</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>crop(x, char = " ")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="crop_+3A_x">x</code></td>
<td>
<p> character string </p>
</td></tr>
<tr><td><code id="crop_+3A_char">char</code></td>
<td>
<p>character to be removed from beginning and end of <code>x</code> </p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Martin Hecht, Sebastian Weirich
</p>


<h3>Examples</h3>

<pre><code class='language-R'>str &lt;- c(" 12  kk ", "op j    q ", "110")
crop(str)
crop(str, "op")
</code></pre>

<hr>
<h2 id='descr'>Descriptive statistics for one or several variables</h2><span id='topic+descr'></span>

<h3>Description</h3>

<p>Function computes descriptive statistics for one variable
or several variables within a data frame.</p>


<h3>Usage</h3>

<pre><code class='language-R'>descr (variable, na = NA, p.weights = NULL, na.rm = FALSE, verbose=TRUE) </code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="descr_+3A_variable">variable</code></td>
<td>


<p>one variable or a data.frame with several variables
</p>
</td></tr>
<tr><td><code id="descr_+3A_na">na</code></td>
<td>


<p>optional values with should be considered a missing values
</p>
</td></tr>
<tr><td><code id="descr_+3A_p.weights">p.weights</code></td>
<td>


<p>optional: vector with individual weights if weighted statistics should be computed
</p>
</td></tr>
<tr><td><code id="descr_+3A_na.rm">na.rm</code></td>
<td>


<p>logical: should missings be removed prior to estimation?
</p>
</td></tr>
<tr><td><code id="descr_+3A_verbose">verbose</code></td>
<td>

<p>logical: Print messages to console?
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a data frame with the following columns
</p>
<table>
<tr><td><code>N</code></td>
<td>

<p>number of observations
</p>
</td></tr>
<tr><td><code>N.valid</code></td>
<td>

<p>number of non-missing observations
</p>
</td></tr>
<tr><td><code>Missing</code></td>
<td>

<p>number of missings
</p>
</td></tr>
<tr><td><code>Minimum</code></td>
<td>

<p>minimum of numeric variables
</p>
</td></tr>
<tr><td><code>Maximum</code></td>
<td>

<p>maximum of numeric variables
</p>
</td></tr>
<tr><td><code>Sum</code></td>
<td>

<p>sum of numeric variables
</p>
</td></tr>
<tr><td><code>Mean</code></td>
<td>

<p>arithmetic mean of numeric variables
</p>
</td></tr>
<tr><td><code>std.err</code></td>
<td>

<p>standard error of the arithmetic mean. Note: for weighted means, standard error
is estimated according to Cochran (1977): <code class="reqn">sigma_x^2=n/((n-1)*w_s^2)*Sigma(w_i^2*(x_i-x))</code>.
</p>
</td></tr>
<tr><td><code>sig</code></td>
<td>

<p>p value
</p>
</td></tr>
<tr><td><code>Median</code></td>
<td>

<p>median of numeric variables
</p>
</td></tr>
<tr><td><code>SD</code></td>
<td>

<p>standard deviation of numeric variables
</p>
</td></tr>
<tr><td><code>Var</code></td>
<td>

<p>variance of numeric variables
</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Sebastian Weirich
</p>


<h3>References</h3>

<p>Cochran W. G. (1977). <em>Sampling Techniques</em> (3rd Edn). Wiley, New York
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(mtcars)
descr(mtcars)
</code></pre>

<hr>
<h2 id='do_call_rbind_withName'>Row bind a list while assigning names to rows</h2><span id='topic+do_call_rbind_withName'></span>

<h3>Description</h3>

<p>Use <code>do.call(rbind, ...)</code> on a list of <code>data.frames</code> while creating a new variable
(<code>colName</code>) which contains, for example, the original list naming (<code>name</code>).</p>


<h3>Usage</h3>

<pre><code class='language-R'>do_call_rbind_withName(df_list, name = names(df_list), colName)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="do_call_rbind_withName_+3A_df_list">df_list</code></td>
<td>

<p>A list of <code>data.frames</code>.
</p>
</td></tr>
<tr><td><code id="do_call_rbind_withName_+3A_name">name</code></td>
<td>

<p>Vector of names to fill <code>colName</code>. Default uses the names of <code>df_list</code>.
</p>
</td></tr>
<tr><td><code id="do_call_rbind_withName_+3A_colname">colName</code></td>
<td>

<p>A single character; name for the new column.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a <code>data.frame</code>.
</p>


<h3>Author(s)</h3>

<p>Benjamin Becker
</p>


<h3>Examples</h3>

<pre><code class='language-R'>### create example list
df_list &lt;- lapply(mtcars, function(x) {
  data.frame(m = mean(x), sd = sd(x))
})

### transform to a single data.frame
do_call_rbind_withName(df_list, colName = "variable")
</code></pre>

<hr>
<h2 id='eatTools-package'>eatTools: Miscellaneous Functions for the Analysis of Educational Assessments</h2><span id='topic+eatTools-package'></span>

<h3>Description</h3>

<p>The <code>eatTools</code> package provides various groups of functions. The main groups of functions include:
transformation of vector types, modification of character variables, descriptive analyses and weighted statistics. The package's purpose is mainly to function as a lightweight dependency for other packages.
</p>


<h3>Transformation of vector types</h3>

<p>The functions <code><a href="#topic+asNumericIfPossible">asNumericIfPossible</a></code> and <code><a href="#topic+catch_asNumericIfPossible">catch_asNumericIfPossible</a></code> transform character and factor variables to numeric. <code><a href="#topic+facToChar">facToChar</a></code> transforms factor variables to character. <code><a href="#topic+set.col.type">set.col.type</a></code> allows manually setting the type of multiple variables within a <code>data.frame</code>.
</p>


<h3>Modification of character variables</h3>

<p>Multiple convenience functions exist for modification of character variables: removing certain pattern (<code><a href="#topic+removePattern">removePattern</a></code>), removing numerics (<code><a href="#topic+removeNumeric">removeNumeric</a></code>) and removing non numerics (<code><a href="#topic+removeNonNumeric">removeNonNumeric</a></code>), substituting multiple patterns within a string (<code><a href="#topic+gsubAll">gsubAll</a></code>) and splitting strings into multiple or a fixed number of parts but at specific position (<code><a href="#topic+halveString">halveString</a></code>)
</p>


<h3>Descriptive Statistics</h3>

<p>The function <code><a href="#topic+descr">descr</a></code> provides simple descriptive statistics for a <code>data.frame</code>, but in a format especially useful for further automated processing (long format <code>data.frame</code>).
</p>


<h3>Weighted Statistics</h3>

<p><code><a href="#topic+wtdVar">wtdVar</a></code> provides calculation of weighted variances (this can be done also by the package <code>Hmisc</code>, which has, however, a very high number of dependencies). <code><a href="#topic+wtdTable">wtdTable</a></code> provides a weighted frequency table.
</p>

<hr>
<h2 id='existsBackgroundVariables'>Internally needed function for consistency checks and data preparation.</h2><span id='topic+existsBackgroundVariables'></span>

<h3>Description</h3>

<p>Function is necessary for <code>eatRep</code> and <code>eatModel</code> as well
and therefore exported to namespace.</p>


<h3>Usage</h3>

<pre><code class='language-R'>existsBackgroundVariables (dat, variable, warnIfMissing = FALSE,
     stopIfMissingOnVars = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="existsBackgroundVariables_+3A_dat">dat</code></td>
<td>

<p>A data frame
</p>
</td></tr>
<tr><td><code id="existsBackgroundVariables_+3A_variable">variable</code></td>
<td>

<p>column number or variable name
</p>
</td></tr>
<tr><td><code id="existsBackgroundVariables_+3A_warnifmissing">warnIfMissing</code></td>
<td>

<p>Logical: gives a warning if the variable contains missing values
</p>
</td></tr>
<tr><td><code id="existsBackgroundVariables_+3A_stopifmissingonvars">stopIfMissingOnVars</code></td>
<td>

<p>Character vector of variable names. Only for these variables, warnings as raised
through <code>warnIfMissing = TRUE</code> are turned into errors.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a structured list of variable names
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(mtcars)
existsBackgroundVariables(mtcars, 2:4)
</code></pre>

<hr>
<h2 id='facToChar'>Transform columns in a data frame</h2><span id='topic+facToChar'></span>

<h3>Description</h3>

<p>Function transforms all data frame columns of a specific class
into another class.</p>


<h3>Usage</h3>

<pre><code class='language-R'>facToChar ( dataFrame, from = "factor", to = "character")</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="facToChar_+3A_dataframe">dataFrame</code></td>
<td>


<p>a data frame
</p>
</td></tr>
<tr><td><code id="facToChar_+3A_from">from</code></td>
<td>


<p>which column class should be transformed?
</p>
</td></tr>
<tr><td><code id="facToChar_+3A_to">to</code></td>
<td>


<p>target column class
</p>
</td></tr>
</table>


<h3>Value</h3>






<p>a data frame
</p>


<h3>Author(s)</h3>

<p>Sebastian Weirich
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(mtcars)
### original classes
sapply(mtcars, class)
mtcars1 &lt;- facToChar(mtcars, from = "numeric", to = "character")
sapply(mtcars1, class)
</code></pre>

<hr>
<h2 id='gsubAll'>Pattern matching and replacement</h2><span id='topic+gsubAll'></span>

<h3>Description</h3>

<p>Function is a wrapper for <code>gsub()</code> which allows to replace more than one pattern.</p>


<h3>Usage</h3>

<pre><code class='language-R'>gsubAll ( string, old, new)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gsubAll_+3A_string">string</code></td>
<td>
<p>a character vector where matches are sought</p>
</td></tr>
<tr><td><code id="gsubAll_+3A_old">old</code></td>
<td>


<p>character vector containing strings to be matched in the given character vector named <code>string</code>.
</p>
</td></tr>
<tr><td><code id="gsubAll_+3A_new">new</code></td>
<td>


<p>a replacement for matched pattern
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>character vector with replaced patterns
</p>


<h3>Author(s)</h3>

<p>Benjamin Becker
</p>


<h3>Examples</h3>

<pre><code class='language-R'>### replace all numbers by words
txt &lt;- "1 example for 2 reasons in 4 seasons"
gsubAll ( txt, old = as.character(1:4), new = c("one", "two", "three", "four"))
</code></pre>

<hr>
<h2 id='halveString'>Split string exactly in two parts</h2><span id='topic+halveString'></span>

<h3>Description</h3>

<p><code>strsplit</code> splits a string according to a specific regular expression. The number
of occurrences of the splitting regular expression defines the number of splits. <code>halveString</code>
allows to split the string in only two parts, no matter how often the splitting regular expression occurs.</p>


<h3>Usage</h3>

<pre><code class='language-R'>halveString (string, pattern, first = TRUE , colnames=c("X1", "X2"))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="halveString_+3A_string">string</code></td>
<td>

<p>A character vector.
</p>
</td></tr>
<tr><td><code id="halveString_+3A_pattern">pattern</code></td>
<td>

<p>character vector (or object which can be coerced to such) to use for splitting.
</p>
</td></tr>
<tr><td><code id="halveString_+3A_first">first</code></td>
<td>

<p>Logical: Relevant if the pattern occurs more than one time in the string. Defines whether
the first (default) or last occurrence is used for splitting.
</p>
</td></tr>
<tr><td><code id="halveString_+3A_colnames">colnames</code></td>
<td>

<p>Optional: character vector of length 2 to specify the colnames of the resulting data.frame.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix with two columns
</p>


<h3>Examples</h3>

<pre><code class='language-R'>str1 &lt;- c("John_Bolton", "Richard_Milhouse_Nixon", "Madonna")
strsplit(str1, split = "_")
halveString(str1, pattern = "_")
halveString(str1, pattern = "_", first=FALSE)

# split patterns with more than one character and regular expression
str2 &lt;- c("John._.Bolton", "Richard._.Milhouse._.Nixon", "Madonna")
halveString(str2, pattern = encodeString("._."), first=FALSE)
</code></pre>

<hr>
<h2 id='insert.col'>Insert Columns into a <code>data.frame</code> at a Specific Position
</h2><span id='topic+insert.col'></span>

<h3>Description</h3>

<p>Insert columns into a <code>data.frame</code> at a specific position. Transforms <code>tibble</code> or <code>data.table</code> to <code>data.frame</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  insert.col(dat, toinsert, after)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="insert.col_+3A_dat">dat</code></td>
<td>
<p>A data frame</p>
</td></tr>
<tr><td><code id="insert.col_+3A_toinsert">toinsert</code></td>
<td>
<p>Column name(s) or column number(s) of the columns to be reinserted </p>
</td></tr>
<tr><td><code id="insert.col_+3A_after">after</code></td>
<td>
<p>Column name or column number after which the columns specified in <code>insert</code> should be reinserted.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A	data frame with columns in specified positions.
</p>

<hr>
<h2 id='makeDataFrame'>Converts <code>tbl</code> or <code>data.table</code> objects to plain <code>data.frames</code> for internal processing</h2><span id='topic+makeDataFrame'></span>

<h3>Description</h3>

<p>Function is mainly used for internal checks in the eatRep and eatModel package: objects
which expected to be <code>data.frames</code> for further processing are converted to data.frame when their class
is <code>tbl</code>, for example.</p>


<h3>Usage</h3>

<pre><code class='language-R'>makeDataFrame (dat, name = "dat", minRow = 1, onlyWarn=TRUE)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="makeDataFrame_+3A_dat">dat</code></td>
<td>

<p>An object which is intended to be a data.frame.
</p>
</td></tr>
<tr><td><code id="makeDataFrame_+3A_name">name</code></td>
<td>

<p>Optional: name of data.frame for use in messages
</p>
</td></tr>
<tr><td><code id="makeDataFrame_+3A_minrow">minRow</code></td>
<td>

<p>When used internally, function report when data.frame has less rows than specified in <code>minRow</code>.
</p>
</td></tr>
<tr><td><code id="makeDataFrame_+3A_onlywarn">onlyWarn</code></td>
<td>

<p>If <code>TRUE</code>, function warns if data.frame has less rows than specified in <code>minRow</code>.
Otherwise, functions aborts with an error message.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>data frame.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>dat  &lt;- data.table::data.table(x1 = 1:5, y1 = letters[1:5])
# unexpected in 'classical' data frames
class(dat[,"x1"])
dat  &lt;- makeDataFrame(dat)
</code></pre>

<hr>
<h2 id='makeTria'>Reshapes an unordered covariance/correlation matrix into triangular shape</h2><span id='topic+makeTria'></span>

<h3>Description</h3>

<p>Function is mainly used for <code>eatAnalysis::wtdHetcor</code> function from the
<code>eatAnalysis</code> package (<a href="https://github.com/beckerbenj/eatAnalysis/">https://github.com/beckerbenj/eatAnalysis/</a>)
and the <code>eatModel::q3FromRes</code> function in the <code>eatModel</code>
package: Triangular covariance/correlation matrices are tidily reshaped.</p>


<h3>Usage</h3>

<pre><code class='language-R'>makeTria (dfr)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="makeTria_+3A_dfr">dfr</code></td>
<td>

<p>A data frame consisting of a row name column and a square matrix.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>data frame.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>dfr &lt;- data.frame ( vars = paste0("var", 2:4), matrix(c(1:3, NA, NA, 5, 4,NA,6),
       nrow=3, ncol=3, dimnames=list(NULL, paste0("var", 1:3))))
makeTria(dfr)
</code></pre>

<hr>
<h2 id='mergeAttr'>Merge Two Data Frames with additional messages and maintain variable attributes</h2><span id='topic+mergeAttr'></span>

<h3>Description</h3>

<p>This is a wrapper for the <code><a href="base.html#topic+merge">merge</a></code> function. <code>merge</code>
does not maintain variable attributes. <code>mergeAttr</code> might be useful if variable
attributes should be maintained. For example, if SPSS data are imported via
<code><a href="foreign.html#topic+read.spss">read.spss</a></code>, variable and value labels are stored
as attributes which get lost if data are merged subsequently. Moreover, function gives
additional messages if (combinations of) by-variables are not unique in at least one data.frame,
or if by-variables have different classes, or if some units of the by-variables are missing in
one of the data sets. Users are free to specify which kind of messages are desirable.</p>


<h3>Usage</h3>

<pre><code class='language-R'>mergeAttr(x, y, by = intersect(names(x), names(y)),
      by.x = by, by.y = by, all = FALSE, all.x = all, all.y = all,
      sort = TRUE, suffixes = c(".x",".y"), setAttr = TRUE, onlyVarValLabs = TRUE,
      homoClass = TRUE, unitName = "unit", xName = "x", yName = "y",
      verbose = c("match", "unique", "class", "dataframe", "common"))</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mergeAttr_+3A_x">x</code></td>
<td>

<p>first data frame to be merged.
</p>
</td></tr>
<tr><td><code id="mergeAttr_+3A_y">y</code></td>
<td>

<p>second data frame to be merged.
</p>
</td></tr>
<tr><td><code id="mergeAttr_+3A_by">by</code></td>
<td>

<p>specifications of the columns used for merging
</p>
</td></tr>
<tr><td><code id="mergeAttr_+3A_by.x">by.x</code></td>
<td>

<p>specifications of the columns used for merging
</p>
</td></tr>
<tr><td><code id="mergeAttr_+3A_by.y">by.y</code></td>
<td>

<p>specifications of the columns used for merging
</p>
</td></tr>
<tr><td><code id="mergeAttr_+3A_all">all</code></td>
<td>

<p>logical; <code>all = L</code> is shorthand for <code>all.x = L</code> and <code>all.y = L</code>,
where <code>L</code> is either <code>TRUE</code> or <code>FALSE</code>.
</p>
</td></tr>
<tr><td><code id="mergeAttr_+3A_all.x">all.x</code></td>
<td>

<p>logical; if <code>TRUE</code>, then extra rows will be added to the output, one for each
row in <code>x</code> that has no matching row in <code>y</code>. These rows will have <code>NAs</code> 
in those columns that are usually filled with values from <code>y</code>. The default 
is <code>FALSE</code>, so that only rows with data from both <code>x</code> and <code>y</code> are 
included in the output.
</p>
</td></tr>
<tr><td><code id="mergeAttr_+3A_all.y">all.y</code></td>
<td>

<p>logical; analogous to <code>all.x</code>.
</p>
</td></tr>
<tr><td><code id="mergeAttr_+3A_sort">sort</code></td>
<td>

<p>logical. Should the result be sorted on the <code>by</code> columns?
</p>
</td></tr>
<tr><td><code id="mergeAttr_+3A_suffixes">suffixes</code></td>
<td>

<p>a character vector of length 2 specifying the suffixes to be used for making unique
the names of columns in the result which not used for merging (appearing in <code>by</code> etc).
</p>
</td></tr>
<tr><td><code id="mergeAttr_+3A_setattr">setAttr</code></td>
<td>

<p>Logical: restore the variable attributes? If FALSE, the behavior of <code>mergeAttr</code> equals
the behavior of <code>merge</code>.
</p>
</td></tr>
<tr><td><code id="mergeAttr_+3A_onlyvarvallabs">onlyVarValLabs</code></td>
<td>

<p>Logical: If TRUE, only the variable and value labels as captured by <code>read.spss</code> and
stored by <code>convertLabel</code> from the <code>eatAnalysis</code> package will be restored.
If FALSE, all variable attributes will be restored.
</p>
</td></tr>
<tr><td><code id="mergeAttr_+3A_homoclass">homoClass</code></td>
<td>

<p>Logical: Beginning with R version 3.5, <code>merge</code> may give an error if the class of the
by-variables differs in both data.frames. If TRUE, class of by-variable(s) will be homogenized
before merging.
</p>
</td></tr>
<tr><td><code id="mergeAttr_+3A_unitname">unitName</code></td>
<td>

<p>Optional: Set the name for the unit variable to get more informative messages. This is mainly
relevant if <code>mergeAttr</code> is called from other functions.
</p>
</td></tr>
<tr><td><code id="mergeAttr_+3A_xname">xName</code></td>
<td>

<p>Optional: Set the name for the x data.frame to get more informative messages. This is mainly
relevant if <code>mergeAttr</code> is called from other functions.
</p>
</td></tr>
<tr><td><code id="mergeAttr_+3A_yname">yName</code></td>
<td>

<p>Optional: Set the name for the y data.frame to get more informative messages. This is mainly
relevant if <code>mergeAttr</code> is called from other functions.
</p>
</td></tr>
<tr><td><code id="mergeAttr_+3A_verbose">verbose</code></td>
<td>

<p>Optional: Choose whether messages concerning missing levels in by-variables should be printed
on console (<code>"match"</code>), or messages concerning uniqueness of by-variables (<code>"unique"</code>),
or messages concerning different classes of by-variables (<code>"class"</code>), or messages concerning
appropriate class (<code>data.frame</code>) of <code>x</code> and <code>y</code> (<code>"dataframe"</code>), or messages
concerning additional common variables (except by-variables; <code>"common"</code>)). Multiple choices
are possible, e.g. <code>verbose = c("match", "class")</code>. If <code>verbose = TRUE</code>, all
messages are printed, if <code>verbose = FALSE</code>, no messages are printed at all. The default
is equivalent to <code>verbose = TRUE</code>.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>data frame. See the help page of <code><a href="base.html#topic+merge">merge</a></code> for further details.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>### data frame 1, variable 'y' with variable.label 'test participation'
df1 &lt;- data.frame ( id = 1:3, sex = factor ( c("male", "male", "female")),
       happy = c("low", "low", "medium"))
attr(df1[,"happy"], "variable.label") &lt;- "happieness in the workplace"

### data frame 2 without labels 
df2 &lt;- data.frame ( id = as.factor(c(2,2,4)), status = factor ( c("married", "married", "single")),
       convicted = c(FALSE, FALSE, TRUE))

### lost label after merging
df3 &lt;- merge(df1, df2, all = TRUE)
attr(df3[,"happy"], "variable.label")

### maintain label
df4 &lt;- mergeAttr(df1, df2, all = TRUE, onlyVarValLabs = FALSE)
attr(df4[,"happy"], "variable.label")

### adapt messages
df5 &lt;- mergeAttr(df1, df2, all = TRUE, onlyVarValLabs = FALSE, unitName = "student",
       xName = "student questionnaire", yName = "school questionnaire",
       verbose = c("match", "unique"))
</code></pre>

<hr>
<h2 id='multiseq'>
multiple sequences
</h2><span id='topic+multiseq'></span>

<h3>Description</h3>

<p>creates a sequence for every unique value in a vector
</p>


<h3>Usage</h3>

<pre><code class='language-R'>multiseq(v)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="multiseq_+3A_v">v</code></td>
<td>
<p> a vector </p>
</td></tr>
</table>


<h3>Value</h3>

<p>a vector with multiple sequences
</p>


<h3>Author(s)</h3>

<p>Martin Hecht
</p>


<h3>Examples</h3>

<pre><code class='language-R'>v &lt;- c("a", "a", "a", "c", "b", "b" , "a")
multiseq(v)
</code></pre>

<hr>
<h2 id='na_omit_selection'>Drop rows containing missing values</h2><span id='topic+na_omit_selection'></span>

<h3>Description</h3>

<p>Drop rows containing missing values in selected columns.</p>


<h3>Usage</h3>

<pre><code class='language-R'>na_omit_selection (dat, varsToOmitIfNA)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="na_omit_selection_+3A_dat">dat</code></td>
<td>


<p>a data.frame
</p>
</td></tr>
<tr><td><code id="na_omit_selection_+3A_varstoomitifna">varsToOmitIfNA</code></td>
<td>


<p>Name or column number of the variables which should be considered for
row deletion due to NAs
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data.frame with deleted rows
</p>


<h3>Examples</h3>

<pre><code class='language-R'>dat1 &lt;- data.frame ( v1 = c(1,NA,3), v2 = c(letters[1:2],NA),
                     v3 = c(NA, NA, TRUE), stringsAsFactors = FALSE)
na.omit(dat1)
na_omit_selection(dat1, "v2")
</code></pre>

<hr>
<h2 id='num.to.cat'>Transform continuous variables into ordered factors</h2><span id='topic+num.to.cat'></span>

<h3>Description</h3>

<p>Function is useful if parameters on the &lsquo;PISA&rsquo; metric should be transformed into competence levels. </p>


<h3>Usage</h3>

<pre><code class='language-R'>num.to.cat(x, cut.points, cat.values = NULL)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="num.to.cat_+3A_x">x</code></td>
<td>


<p>Numeric vector.
</p>
</td></tr>
<tr><td><code id="num.to.cat_+3A_cut.points">cut.points</code></td>
<td>


<p>Numeric vector with cut scores.
</p>
</td></tr>
<tr><td><code id="num.to.cat_+3A_cat.values">cat.values</code></td>
<td>


<p>Optional: vector with labels for the cut scores. Note: if specified, length of 
cat.values should be length(cut.points)+1.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Vector with factor values. 
</p>


<h3>Author(s)</h3>

<p>Sebastian Weirich
</p>


<h3>Examples</h3>

<pre><code class='language-R'>values &lt;- rnorm(10,0,1.5) * 100 + 500
num.to.cat(x = values, cut.points = 390+0:3*75)
num.to.cat(x = values, cut.points = 390+0:3*75, cat.values = c("1a", "1b", 2:4))
</code></pre>

<hr>
<h2 id='print_and_capture'>Easy integration of (small) tables into (error) messages</h2><span id='topic+print_and_capture'></span>

<h3>Description</h3>

<p>Some (error) messages are more understandable if small (frequency)
tables are used for clearness. The function simplifies integration of these tables.
The function is intended to be used in combination with <code><a href="base.html#topic+message">message</a></code>,
<code><a href="base.html#topic+stop">stop</a></code>, or <code><a href="base.html#topic+cat">cat</a></code>, for example.</p>


<h3>Usage</h3>

<pre><code class='language-R'>print_and_capture (x, spaces = 0) </code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print_and_capture_+3A_x">x</code></td>
<td>

<p>The object which should be integrated. Normally, a (small) table or data frame.
</p>
</td></tr>
<tr><td><code id="print_and_capture_+3A_spaces">spaces</code></td>
<td>

<p>Number of spaces between left border and the table
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a string which may be combined with messages
</p>


<h3>Examples</h3>

<pre><code class='language-R'>frequency.table &lt;- as.table(matrix(c(12,0,5,7),2,2))
attr(frequency.table, "dimnames") &lt;- list("sex" = c("male", "female"),
        "migration" = c(TRUE, FALSE))
message("Some combinations of variables with zero observations: \n",
        print_and_capture(frequency.table, spaces = 5))
</code></pre>

<hr>
<h2 id='pwc'>Part-whole correlation for numeric data frames</h2><span id='topic+pwc'></span>

<h3>Description</h3>

<p>Computes the part-whole correlation (correlation of an item
with the whole scale except for this item)</p>


<h3>Usage</h3>

<pre><code class='language-R'>pwc(dat)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pwc_+3A_dat">dat</code></td>
<td>


<p>a data.frame with numeric columns (items)
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data.frame with three columns: First column item identifier, second column with
conventional item-scale correlation, third column with part-whole correlation
</p>


<h3>Examples</h3>

<pre><code class='language-R'>dat &lt;- data.frame ( item1 = c(0,1,1,3), item2 = c(2,3,1,3), item3 = c(1, NA, 3,3))
pwc(dat)
</code></pre>

<hr>
<h2 id='rbind_common'>Combine data.frames by row, using only common columns.</h2><span id='topic+rbind_common'></span>

<h3>Description</h3>

<p><code>rbind</code>s a list of data.frames, using only these columns which occur
in each of the single data.frames.</p>


<h3>Usage</h3>

<pre><code class='language-R'>rbind_common(...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rbind_common_+3A_...">...</code></td>
<td>

<p>input data frames to row bind together. The first argument can be a list of data frames,
in which case all other arguments are ignored. Any NULL inputs are silently dropped.
If all inputs are NULL, the output is NULL. If the data.frames have no common columns,
the output is NULL and a warning is given.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a single data frame
</p>


<h3>Examples</h3>

<pre><code class='language-R'>### data frame 1
df1 &lt;- data.frame ( a = 1:3, b = TRUE)

### data frame 2
df2 &lt;- data.frame ( d = 100, a = 11:13)

### data frame 3
df3 &lt;- data.frame ( d = 1000, x = 101:103)

### one common col
rbind_common(df1, df2)

### no common cols
rbind_common(df1, df2, df3)
</code></pre>

<hr>
<h2 id='readMultisep'>Read in data.frames with separator characters &gt;=1Byte</h2><span id='topic+readMultisep'></span>

<h3>Description</h3>

<p>Read in character separated data.frames with separator characters &gt;=1Byte.</p>


<h3>Usage</h3>

<pre><code class='language-R'>readMultisep(file, sep)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="readMultisep_+3A_file">file</code></td>
<td>

<p>the name of the file which the data are to be read from.
</p>
</td></tr>
<tr><td><code id="readMultisep_+3A_sep">sep</code></td>
<td>

<p>the field separator character(s).
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data frame containing a representation of the data in the file.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>filePath &lt;- tempfile(fileext = ".txt")
dat &lt;- data.frame(v1 = c("0","300","e",NA),
                  v2=c("0","90","10000",NA),
                  v3=c("k","kk","kkk",NA),
                  v4=NA,
                  v5=c("0","90","100","1"))
write.table(dat, file = filePath, row.names = FALSE, col.names = FALSE, sep = "]&amp;;")
readMultisep(filePath, sep="]&amp;;")
</code></pre>

<hr>
<h2 id='recodeLookup'>Recode a variable according to a lookup table</h2><span id='topic+recodeLookup'></span>

<h3>Description</h3>

<p>Recodes the values of a variable. Function resembles the <code>recode</code>
function from the <code>car</code> package, but uses a lookup table to specify old and new values. </p>


<h3>Usage</h3>

<pre><code class='language-R'>recodeLookup(var, lookup)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="recodeLookup_+3A_var">var</code></td>
<td>

<p>a vector (e.g. numeric, character, or factor)
</p>
</td></tr>
<tr><td><code id="recodeLookup_+3A_lookup">lookup</code></td>
<td>

<p>a data.frame with exact two columns. First column contains old values, second column new values.
Values which do not occur in the old column remain unchanged.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a vector of the same length as <code>var</code> with recoded values
</p>


<h3>Examples</h3>

<pre><code class='language-R'>num_var &lt;- sample(1:10, size = 10, replace = TRUE)
lookup  &lt;- data.frame(old = c(2, 4, 6), new = c(200,400,600))
num_var2&lt;- recodeLookup(num_var, lookup)
</code></pre>

<hr>
<h2 id='removeNonNumeric'>Removes all non-numeric characters from a string.</h2><span id='topic+removeNonNumeric'></span>

<h3>Description</h3>

<p>Function removes all non-numeric characters from a string.</p>


<h3>Usage</h3>

<pre><code class='language-R'>removeNonNumeric ( string)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="removeNonNumeric_+3A_string">string</code></td>
<td>


<p>a character vector
</p>
</td></tr>
</table>


<h3>Value</h3>






<p>a character string
</p>


<h3>Author(s)</h3>

<p>Sebastian Weirich
</p>


<h3>Examples</h3>

<pre><code class='language-R'>str &lt;- c(".d1.nh.120", "empty", "110", ".nh.dgd", "only.nh")
removeNonNumeric(str)
</code></pre>

<hr>
<h2 id='removeNumeric'>Removes alphanumeric characters from a string.</h2><span id='topic+removeNumeric'></span>

<h3>Description</h3>

<p>Function removes alphanumeric characters from a string.</p>


<h3>Usage</h3>

<pre><code class='language-R'>removeNumeric ( string)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="removeNumeric_+3A_string">string</code></td>
<td>


<p>a character vector
</p>
</td></tr>
</table>


<h3>Value</h3>






<p>a character string
</p>


<h3>Author(s)</h3>

<p>Sebastian Weirich
</p>


<h3>Examples</h3>

<pre><code class='language-R'>str &lt;- c(".d1.nh.120", "empty", "110", ".nh.dgd", "only.nh")
removeNumeric(str)
</code></pre>

<hr>
<h2 id='removePattern'>Removes a specified pattern from a string.</h2><span id='topic+removePattern'></span>

<h3>Description</h3>

<p>Function remove a specified string from a character vector.</p>


<h3>Usage</h3>

<pre><code class='language-R'>removePattern ( string, pattern)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="removePattern_+3A_string">string</code></td>
<td>


<p>a character vector
</p>
</td></tr>
<tr><td><code id="removePattern_+3A_pattern">pattern</code></td>
<td>


<p>a character pattern
</p>
</td></tr>
</table>


<h3>Value</h3>






<p>a character string
</p>


<h3>Author(s)</h3>

<p>Sebastian Weirich
</p>


<h3>Examples</h3>

<pre><code class='language-R'>str &lt;- c(".d1.nh.120", "empty", "110", ".nh.dgd", "only.nh")
removePattern(str, ".nh.")
</code></pre>

<hr>
<h2 id='roundDF'>Round a <code>data.frame</code>.</h2><span id='topic+roundDF'></span>

<h3>Description</h3>

<p>Round all numeric variables in a <code>data.frame</code>, leave the other variables untouched. Column and row names are preserved.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>roundDF(dat, digits = 3)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="roundDF_+3A_dat">dat</code></td>
<td>
<p>A <code>data.frame</code>.</p>
</td></tr>
<tr><td><code id="roundDF_+3A_digits">digits</code></td>
<td>
<p>Integer indicating the number of decimal places.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns the rounded <code>data.frame</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>roundDF(mtcars, digits = 0)
</code></pre>

<hr>
<h2 id='seq2'>
Sequence generation
</h2><span id='topic+seq2'></span>

<h3>Description</h3>

<p>Creates a sequence of integers. Modified version of <code>seq</code> returning an empty vector if the starting point is larger than the end point.
Originally provided by <code>rlang::seq2()</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>seq2(from, to)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="seq2_+3A_from">from</code></td>
<td>
<p>The starting value of the sequence. Of length 1.</p>
</td></tr>
<tr><td><code id="seq2_+3A_to">to</code></td>
<td>
<p>The end value of the sequence. Of length 1.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A numerical sequence
</p>


<h3>Examples</h3>

<pre><code class='language-R'>seq2(from = 1, to = 5)
</code></pre>

<hr>
<h2 id='set.col.type'>
Set the Class of Columns in a Data Frame
</h2><span id='topic+set.col.type'></span>

<h3>Description</h3>

<p>This function converts the classes of columns to <code>character</code>, <code>numeric</code>, <code>logical</code>, <code>integer</code> or <code>factor</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>set.col.type(dat, col.type = list("character" = NULL), verbose = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="set.col.type_+3A_dat">dat</code></td>
<td>
<p> A data frame </p>
</td></tr>
<tr><td><code id="set.col.type_+3A_col.type">col.type</code></td>
<td>
<p>A named list of column names that are to be converted. The names of the list indicate the class to which the respective column should be converted (<code>character</code>, <code>numeric</code>, <code>numeric.if.possible</code>, <code>logical</code>, <code>integer</code> or <code>factor</code>) </p>
</td></tr>
<tr><td><code id="set.col.type_+3A_verbose">verbose</code></td>
<td>
<p> if <code>TRUE</code> details about converted columns are printed on the console</p>
</td></tr>
<tr><td><code id="set.col.type_+3A_...">...</code></td>
<td>
<p>Additional arguments to be passed to <code>asNumericIfPossible</code>
</p>
</td></tr></table>


<h3>Details</h3>

<p>Use <code>col.type="numeric.if.possible"</code> if conversion to numeric should be tested upfront, see <code>asNumericIfPossible</code> for details.
</p>


<h3>Value</h3>

<p>A data frame with column classes changed according to the specifications in <code>col.type</code>
</p>


<h3>Author(s)</h3>

<p>Martin Hecht, Karoline Sachse
</p>


<h3>See Also</h3>

<p><code>asNumericIfPossible</code></p>


<h3>Examples</h3>

<pre><code class='language-R'>str(d &lt;- data.frame("var1" = 1, "var2" = TRUE, "var3" = FALSE,
    "var4" = as.factor(1), "var5" = as.factor("a"),"var6" = "b",
    stringsAsFactors = FALSE))

str(set.col.type(d))
str(set.col.type(d, list("numeric" = NULL)))
str(set.col.type(d, list("character" = c("var1" , "var2"),
    "numeric" = "var3", "logical" = "var4")))
str(set.col.type(d, list("numeric.if.possible" = NULL)))
str(set.col.type(d, list("numeric.if.possible" = NULL),
    transform.factors = TRUE))
str(set.col.type(d, list("numeric.if.possible" = NULL), transform.factors = TRUE,
    maintain.factor.scores = FALSE))
</code></pre>

<hr>
<h2 id='tablePattern'>Creates skeleton for frequency tables with desired values</h2><span id='topic+tablePattern'></span>

<h3>Description</h3>

<p>Function takes values and creates a frequency table including these values. Models behavior of factor variables.</p>


<h3>Usage</h3>

<pre><code class='language-R'>tablePattern (x, pattern = NULL, weights, na.rm = TRUE,
useNA = c("no", "ifany", "always"))</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tablePattern_+3A_x">x</code></td>
<td>


<p>a vector
</p>
</td></tr>
<tr><td><code id="tablePattern_+3A_pattern">pattern</code></td>
<td>


<p>desired values for table output
</p>
</td></tr>
<tr><td><code id="tablePattern_+3A_weights">weights</code></td>
<td>

<p>optional: weights
</p>
</td></tr>
<tr><td><code id="tablePattern_+3A_na.rm">na.rm</code></td>
<td>

<p>should missing values be removed
</p>
</td></tr>
<tr><td><code id="tablePattern_+3A_usena">useNA</code></td>
<td>

<p>whether to include [NA] values in the table
</p>
</td></tr>
</table>


<h3>Value</h3>






<p>a frequency table
</p>


<h3>Author(s)</h3>

<p>Sebastian Weirich
</p>


<h3>Examples</h3>

<pre><code class='language-R'>grades &lt;- c(1,1,3,4,2,3,4,5,5,3,2,1)
table(grades)
tablePattern(grades, pattern = 1:6)
</code></pre>

<hr>
<h2 id='tableUnlist'>Frequency table for data frames, e.g. across multiple columns</h2><span id='topic+tableUnlist'></span>

<h3>Description</h3>

<p>Replaces the somehow buggy function combination <code>table(unlist(data))</code>.</p>


<h3>Usage</h3>

<pre><code class='language-R'>tableUnlist(dataFrame, useNA = c("no", "ifany",
    "always"))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tableUnlist_+3A_dataframe">dataFrame</code></td>
<td>

<p>Data frame with more than one column.
</p>
</td></tr>
<tr><td><code id="tableUnlist_+3A_usena">useNA</code></td>
<td>

<p>whether to include NA values in the table. See help file of <code>table</code> for more details.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A frequency table
</p>


<h3>Examples</h3>

<pre><code class='language-R'>dat  &lt;- data.frame ( matrix ( data = sample(0:1,200,replace=TRUE), nrow=20, ncol=10))
tableUnlist(dat)
</code></pre>

<hr>
<h2 id='whereAre'>Matches a scalar with elements of a vector.</h2><span id='topic+whereAre'></span>

<h3>Description</h3>

<p>The function closely resembles the <code>match</code> function, but allows for
multiple matches.</p>


<h3>Usage</h3>

<pre><code class='language-R'>whereAre(a,b,verbose=TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="whereAre_+3A_a">a</code></td>
<td>


<p>a scalar
</p>
</td></tr>
<tr><td><code id="whereAre_+3A_b">b</code></td>
<td>


<p>a numeric or character vector
</p>
</td></tr>
<tr><td><code id="whereAre_+3A_verbose">verbose</code></td>
<td>


<p>logical: print messages on console?
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A numeric vector
</p>


<h3>Author(s)</h3>

<p>Sebastian Weirich
</p>


<h3>Examples</h3>

<pre><code class='language-R'>a &lt;- 12
b &lt;- c(10, 11, 12, 10, 11, 12)
match(a, b)
whereAre(a=a, b=b)
</code></pre>

<hr>
<h2 id='wideToLong'>Transform wide format data sets into the long format necessary for eatRep analyses</h2><span id='topic+wideToLong'></span>

<h3>Description</h3>

<p>Data from large-scale assessments often are provided in the wide format.
This function easily transform data into the long format required by eatRep.</p>


<h3>Usage</h3>

<pre><code class='language-R'>wideToLong (datWide, noImp, imp, multipleColumns = TRUE, variable.name = "variable",
            value.name = "value")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="wideToLong_+3A_datwide">datWide</code></td>
<td>


<p>Data set in the wide format, i.e. one row per person
</p>
</td></tr>
<tr><td><code id="wideToLong_+3A_noimp">noImp</code></td>
<td>


<p>character vector of non-imputed variables which are desired for following analyses
</p>
</td></tr>
<tr><td><code id="wideToLong_+3A_imp">imp</code></td>
<td>


<p>Named list of character vectors which include the imputed variables which are desired for following analyses
</p>
</td></tr>
<tr><td><code id="wideToLong_+3A_multiplecolumns">multipleColumns</code></td>
<td>

<p>Logical: use one column for each imputed variable (if more than one imputed variable is used)?
Alternatively, only one column for all imputed variables is used (this is the default behavior
of the <code>melt</code> function from the <code>reshape2</code> package).
</p>
</td></tr>
<tr><td><code id="wideToLong_+3A_variable.name">variable.name</code></td>
<td>

<p>Applies only if <code>multipleColumns = "FALSE"</code>: name of variable used to store measured variable names
</p>
</td></tr>
<tr><td><code id="wideToLong_+3A_value.name">value.name</code></td>
<td>

<p>Applies only if <code>multipleColumns = "FALSE"</code>: name of variable used to store values
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data.frame in the long format.
</p>


<h3>Author(s)</h3>

<p>Sebastian Weirich
</p>


<h3>Examples</h3>

<pre><code class='language-R'>### create arbitrary wide format large-scale assessment data for two
### subjects, each with three imputations
datWide &lt;- data.frame ( id = paste0("P",1:5), weight = abs(rnorm(5,10,1)),
           country = c("USA", "BRA", "TUR", "GER", "AUS"),
           sex = factor(c("female", "male", "female", "female", "male")),
           matrix(data = rnorm(n=15, mean = 500, sd = 75),
                  nrow=5, dimnames = list(NULL, paste0("mat.pv", 1:3))),
           matrix(data = rnorm(n=15, mean = 480, sd = 80),
                  nrow=5, dimnames = list(NULL, paste0("sci.pv", 1:3))),
           stringsAsFactors=FALSE)
datLong &lt;- wideToLong(datWide = datWide, noImp = c("id", "weight", "country", "sex"),
             imp = list ( math = paste0("mat.pv", 1:3),
			             science = paste0("sci.pv", 1:3)))
datLong2&lt;- wideToLong(datWide = datWide, noImp = c("id", "weight", "country", "sex"),
             imp = list ( math = paste0("mat.pv", 1:3),
			             science = paste0("sci.pv", 1:3)),
			       multipleColumns = FALSE, variable.name = "varName",
			       value.name = "val")
</code></pre>

<hr>
<h2 id='wtdTable'>Computed weighted frequency tables</h2><span id='topic+wtdTable'></span>

<h3>Description</h3>

<p>This functions works quite equally as the <code>wtd.table</code> function
from the <code>Hmisc</code> package.</p>


<h3>Usage</h3>

<pre><code class='language-R'>wtdTable(x , weights , na.rm = FALSE)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="wtdTable_+3A_x">x</code></td>
<td>


<p>a character or category or factor vector
</p>
</td></tr>
<tr><td><code id="wtdTable_+3A_weights">weights</code></td>
<td>


<p>a numeric vector of non-negative weights
</p>
</td></tr>
<tr><td><code id="wtdTable_+3A_na.rm">na.rm</code></td>
<td>


<p>set to <code>FALSE</code> to suppress checking for NAs. If <code>TRUE</code>, NAs are removed
from <code>x</code> as well as from <code>weights</code> prior to variance estimation.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a frequency table
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- c(50, 1, 50)
w &lt;- c(1, 4, 1)
wtdTable(x, w)
</code></pre>

<hr>
<h2 id='wtdVar'>Computed weighted variance</h2><span id='topic+wtdVar'></span>

<h3>Description</h3>

<p>This functions works quite equally as the <code>wtd.var</code> function
from the <code>Hmisc</code> package.</p>


<h3>Usage</h3>

<pre><code class='language-R'>wtdVar(x , weights , na.rm = FALSE)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="wtdVar_+3A_x">x</code></td>
<td>


<p>numeric vector
</p>
</td></tr>
<tr><td><code id="wtdVar_+3A_weights">weights</code></td>
<td>


<p>a numeric vector of non-negative weights
</p>
</td></tr>
<tr><td><code id="wtdVar_+3A_na.rm">na.rm</code></td>
<td>


<p>set to <code>FALSE</code> to suppress checking for NAs. If <code>TRUE</code>, NAs are removed
from <code>x</code> as well as from <code>weights</code> prior to variance estimation.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a scalar
</p>


<h3>Author(s)</h3>

<p>Benjamin Becker
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- c(50, 1, 25)
w &lt;- c(1, 4, 1)
wtdVar(x, w)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
