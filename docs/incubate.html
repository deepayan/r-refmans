<!DOCTYPE html><html lang="en"><head><title>Help for package incubate</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {incubate}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#incubate'><p>Incubate package for parametric time-to-event analysis with delay</p></a></li>
<li><a href='#as_percent'><p>Format a number as percentage.</p></a></li>
<li><a href='#bsDataStep'><p>Generate bootstrap distribution of model parameters to fitted incubate model.</p></a></li>
<li><a href='#coef.incubate_fit'><p>Coefficients of a delay-model fit.</p></a></li>
<li><a href='#confint.incubate_fit'><p>Confidence intervals for parameters of incubate-model fits.</p></a></li>
<li><a href='#delay_fit'><p>Fit optimal parameters according to the objective function (either MPSE or MLE-based).</p></a></li>
<li><a href='#delay_model'><p>Fit a delayed Exponential or Weibull model to one or two given sample(s).</p></a></li>
<li><a href='#DelayedExponential'><p>Delayed Exponential Distribution</p></a></li>
<li><a href='#DelayedWeibull'><p>Delayed Weibull Distribution</p></a></li>
<li><a href='#estimRoundingError'><p>Estimate rounding error based on given sample of metric values</p>
The idea is to check at which level of rounding the sample values do not change.</a></li>
<li><a href='#getDist'><p>Get delay distribution function</p></a></li>
<li><a href='#minObjFunPORT'><p>Minimize an objective function with PORT routine (nlminb)</p></a></li>
<li><a href='#objFunFactory'><p>Factory method for objective function, either according to maximum product of spacings estimation ('MPSE')</p>
or according to some flavour of maximum likelihood estimation (e.g., naive ('MLEn') or corrected ('MLEc') or weighted ('MLEw') MLE).</a></li>
<li><a href='#power_diff'><p>Power simulation function for a two-group comparison of the delay parameter.</p></a></li>
<li><a href='#publication_examples'><p>Small data sets from different publications</p></a></li>
<li><a href='#scalePars'><p>Calculate parameter scaling for optimization routine.</p></a></li>
<li><a href='#stankovic'><p>Survival of mice with glioma under different treatments</p></a></li>
<li><a href='#test_diff'><p>Test the difference for delay model parameter(s) between two uncorrelated groups, based on maximum product of spacings estimation (MPSE).</p></a></li>
<li><a href='#test_GOF'><p>Goodness-of-fit (GOF) test statistic.</p></a></li>
<li><a href='#transform.incubate_fit'><p>Transform observed data to unit interval</p></a></li>
<li><a href='#update.incubate_fit'><p>Refit an <code>incubate_fit</code>-object with specified optimization arguments.</p>
If more things need to be changed go back to <code>delay_model</code> and start from scratch.</a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Title:</td>
<td>Parametric Time-to-Event Analysis with Variable Incubation
Phases</td>
</tr>
<tr>
<td>Version:</td>
<td>1.3.0</td>
</tr>
<tr>
<td>Date:</td>
<td>2024-08-16</td>
</tr>
<tr>
<td>Description:</td>
<td>Fit parametric models for time-to-event data that show an initial
    'incubation period', i.e., a variable delay phase where the hazard is zero. The
    delayed Weibull distribution serves as foundational data model. The
    specific method of 'MPSE' (maximum product of spacings estimation) and MLE-based methods are used for parameter
    estimation. Bootstrap confidence intervals for parameters and significance
    tests in a two group setting are provided.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/LGPL-3">LGPL (&ge; 3)</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>Imports:</td>
<td>future (&ge; 1.21), future.apply (&ge; 1.6), glue (&ge; 1.4), MASS,
purrr (&ge; 0.3), rlang (&ge; 0.4), stats, survival, tibble</td>
</tr>
<tr>
<td>Suggests:</td>
<td>boot, dplyr, future.callr, ggplot2 (&ge; 3.3), knitr, testthat
(&ge; 3.0.0), tidyr, withr</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://gitlab.com/imb-dev/incubate/">https://gitlab.com/imb-dev/incubate/</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://gitlab.com/imb-dev/incubate/-/issues/">https://gitlab.com/imb-dev/incubate/-/issues/</a></td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.3.2</td>
</tr>
<tr>
<td>Config/testthat/edition:</td>
<td>3</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.5.0)</td>
</tr>
<tr>
<td>Collate:</td>
<td>'data.R' 'delay_estimation.R' 'delay.R' 'delay_test.R'
'incubate-package.R' 'utils.R'</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-08-16 08:38:15 UTC; kuhnmat</td>
</tr>
<tr>
<td>Author:</td>
<td>Matthias Kuhn <a href="https://orcid.org/0000-0003-2868-5155"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cre, cph]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Matthias Kuhn &lt;matthias.kuhn@tu-dresden.de&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-08-16 09:10:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='incubate'>Incubate package for parametric time-to-event analysis with delay</h2><span id='topic+incubate-package'></span><span id='topic+incubate'></span>

<h3>Description</h3>

<p>Estimation and statistical tests on parameters in parametric time-to-event analyses with delay.
</p>


<h3>Author(s)</h3>

<p><strong>Maintainer</strong>: Matthias Kuhn <a href="mailto:matthias.kuhn@tu-dresden.de">matthias.kuhn@tu-dresden.de</a> (<a href="https://orcid.org/0000-0003-2868-5155">ORCID</a>) [copyright holder]
</p>


<h3>See Also</h3>

<p>Useful links:
</p>

<ul>
<li> <p><a href="https://gitlab.com/imb-dev/incubate/">https://gitlab.com/imb-dev/incubate/</a>
</p>
</li>
<li><p> Report bugs at <a href="https://gitlab.com/imb-dev/incubate/-/issues/">https://gitlab.com/imb-dev/incubate/-/issues/</a>
</p>
</li></ul>


<hr>
<h2 id='as_percent'>Format a number as percentage.</h2><span id='topic+as_percent'></span>

<h3>Description</h3>

<p>Internal helper function that is not exported.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>as_percent(x, digits = 1)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="as_percent_+3A_x">x</code></td>
<td>
<p>numeric vector to be formated as percentage</p>
</td></tr>
<tr><td><code id="as_percent_+3A_digits">digits</code></td>
<td>
<p>requested number of decimal digits of the percentage</p>
</td></tr>
</table>


<h3>Value</h3>

<p>number formatted as percentage character
</p>

<hr>
<h2 id='bsDataStep'>Generate bootstrap distribution of model parameters to fitted incubate model.</h2><span id='topic+bsDataStep'></span>

<h3>Description</h3>

<p>Bootstrap data are here estimated coefficients from models fitted to bootstrap samples.
The bootstrap data is used to make bootstrap inference in the second step.
It is an internal function, the main entry point is <code><a href="#topic+confint.incubate_fit">confint.incubate_fit()</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bsDataStep(
  object,
  bs_data = c("parametric", "ordinary"),
  R,
  useBoot = FALSE,
  smd_factor = 0.25
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="bsDataStep_+3A_object">object</code></td>
<td>
<p>an <code>incubate_fit</code>-object</p>
</td></tr>
<tr><td><code id="bsDataStep_+3A_bs_data">bs_data</code></td>
<td>
<p>character. Which type of bootstrap method to generate data?</p>
</td></tr>
<tr><td><code id="bsDataStep_+3A_r">R</code></td>
<td>
<p>integer. Number of bootstrapped model coefficient estimates</p>
</td></tr>
<tr><td><code id="bsDataStep_+3A_useboot">useBoot</code></td>
<td>
<p>flag. Do you want to use the boot-package? Default value is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="bsDataStep_+3A_smd_factor">smd_factor</code></td>
<td>
<p>numeric. smooth-delay factor: influence the amount of smoothing. 0 means no smoothing at all. Default is 0.25 (as was optimal in simulation for log-quantile together with log-delay-shift = 5)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>bootstrap data, either as matrix or of class <code>boot</code> (depending on the <code>useBoot</code>-flag)
</p>

<hr>
<h2 id='coef.incubate_fit'>Coefficients of a delay-model fit.</h2><span id='topic+coef.incubate_fit'></span>

<h3>Description</h3>

<p>Coefficients of a delay-model fit.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'incubate_fit'
coef(object, transformed = FALSE, group = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="coef.incubate_fit_+3A_object">object</code></td>
<td>
<p>object that is a <code>incubate_fit</code></p>
</td></tr>
<tr><td><code id="coef.incubate_fit_+3A_transformed">transformed</code></td>
<td>
<p>flag. Do we request the transformed parameters as used within the optimization?</p>
</td></tr>
<tr><td><code id="coef.incubate_fit_+3A_group">group</code></td>
<td>
<p>character string to request the canonical parameter for one group</p>
</td></tr>
<tr><td><code id="coef.incubate_fit_+3A_...">...</code></td>
<td>
<p>further arguments, currently not used.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>named coefficient vector
</p>

<hr>
<h2 id='confint.incubate_fit'>Confidence intervals for parameters of incubate-model fits.</h2><span id='topic+confint.incubate_fit'></span>

<h3>Description</h3>

<p>Bias-corrected bootstrap confidence limits (either quantile-based or normal-approximation based) are generated.
Optionally, there are also variants that use a log-transformation first.
At least R=1000 bootstrap replications are recommended. Default are quantile-based confidence intervals that internally use a log-transformation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'incubate_fit'
confint(
  object,
  parm,
  level = 0.95,
  R = 199L,
  bs_data,
  bs_infer = c("logquantile", "lognormal", "quantile", "quantile0", "normal", "normal0"),
  useBoot = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="confint.incubate_fit_+3A_object">object</code></td>
<td>
<p>object of class <code>incubate_fit</code></p>
</td></tr>
<tr><td><code id="confint.incubate_fit_+3A_parm">parm</code></td>
<td>
<p>character. Which parameters to get confidence interval for?</p>
</td></tr>
<tr><td><code id="confint.incubate_fit_+3A_level">level</code></td>
<td>
<p>numeric. Which is the requested confidence level for the interval? Default value is 0.95</p>
</td></tr>
<tr><td><code id="confint.incubate_fit_+3A_r">R</code></td>
<td>
<p>number of bootstrap replications. Used only if not <code>bs_data</code>-object is provided.</p>
</td></tr>
<tr><td><code id="confint.incubate_fit_+3A_bs_data">bs_data</code></td>
<td>
<p>character or bootstrap data object. If character, it specifies which type of bootstrap is requested and the bootstrap data will be generated. Data can also be provided here directly. If missing it uses parametric bootstrap.</p>
</td></tr>
<tr><td><code id="confint.incubate_fit_+3A_bs_infer">bs_infer</code></td>
<td>
<p>character. Which type of bootstrap inference is requested to generate the confidence interval?</p>
</td></tr>
<tr><td><code id="confint.incubate_fit_+3A_useboot">useBoot</code></td>
<td>
<p>logical. Delegate bootstrap confint calculation to the <code>boot</code>-package?</p>
</td></tr>
<tr><td><code id="confint.incubate_fit_+3A_...">...</code></td>
<td>
<p>further arguments, currently not used.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix (or vector) with columns giving lower and upper confidence limits for each parameter.
</p>

<hr>
<h2 id='delay_fit'>Fit optimal parameters according to the objective function (either MPSE or MLE-based).</h2><span id='topic+delay_fit'></span>

<h3>Description</h3>

<p>The objective function carries the given data in its environment and it is to be minimized.
R's standard routine <code>stats::optim</code> does the numerical optimization, using numerical derivatives.
or the analytical solution is returned directly if available.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>delay_fit(objFun, optim_args = NULL, verbose = 0)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="delay_fit_+3A_objfun">objFun</code></td>
<td>
<p>objective function to be minimized</p>
</td></tr>
<tr><td><code id="delay_fit_+3A_optim_args">optim_args</code></td>
<td>
<p>list of own arguments for optimization. If <code>NULL</code> it uses the default optim arguments associated to the objective function.</p>
</td></tr>
<tr><td><code id="delay_fit_+3A_verbose">verbose</code></td>
<td>
<p>integer that indicates the level of verboseness. Default 0 is quiet.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>optimization object including a named parameter vector or <code>NULL</code> in case of errors during optimization
</p>

<hr>
<h2 id='delay_model'>Fit a delayed Exponential or Weibull model to one or two given sample(s).</h2><span id='topic+delay_model'></span>

<h3>Description</h3>

<p>Maximum product of spacings estimation is used by default to fit the parameters. Estimation via naive maximum likelihood (<code style="white-space: pre;">&#8288;method = 'MLEn&#8288;</code>) is available, too,
but MLEn yields biased estimates. MLEc is a corrected version of MLE due to Cheng.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>delay_model(
  x = stop("Specify observations for at least one group x=!", call. = FALSE),
  y = NULL,
  distribution = c("exponential", "weibull"),
  twoPhase = FALSE,
  bind = NULL,
  ties = c("density", "equidist", "random", "error"),
  method = c("MPSE", "MLEn", "MLEw", "MLEc"),
  profiled = method == "MLEw",
  optim_args = NULL,
  verbose = 0
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="delay_model_+3A_x">x</code></td>
<td>
<p>numeric. observations of 1st group. Can also be a list of data from two groups.</p>
</td></tr>
<tr><td><code id="delay_model_+3A_y">y</code></td>
<td>
<p>numeric. observations from 2nd group</p>
</td></tr>
<tr><td><code id="delay_model_+3A_distribution">distribution</code></td>
<td>
<p>character. Which delayed distribution is assumed? Exponential or Weibull.</p>
</td></tr>
<tr><td><code id="delay_model_+3A_twophase">twoPhase</code></td>
<td>
<p>logical. Allow for two phases?</p>
</td></tr>
<tr><td><code id="delay_model_+3A_bind">bind</code></td>
<td>
<p>character. parameter names that are bind together in 2-group situation.</p>
</td></tr>
<tr><td><code id="delay_model_+3A_ties">ties</code></td>
<td>
<p>character. How to handle ties.</p>
</td></tr>
<tr><td><code id="delay_model_+3A_method">method</code></td>
<td>
<p>character. Which method to fit the model? 'MPSE' = maximum product of spacings estimation <em>or</em> 'MLEn' = naive maximum likelihood estimation <em>or</em> 'MLEw' = weighted MLE' <em>or</em> MLEc' = corrected MLE</p>
</td></tr>
<tr><td><code id="delay_model_+3A_profiled">profiled</code></td>
<td>
<p>logical. Profile out scale from log-likelihood if possible.</p>
</td></tr>
<tr><td><code id="delay_model_+3A_optim_args">optim_args</code></td>
<td>
<p>list. optimization arguments to use. Use <code>NULL</code> to use the data-dependent default values.</p>
</td></tr>
<tr><td><code id="delay_model_+3A_verbose">verbose</code></td>
<td>
<p>integer. level of verboseness. Default 0 is quiet.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Numerical optimization is done by <code>stats::optim</code>.
</p>


<h3>Value</h3>

<p><code>incubate_fit</code> the delay-model fit object. Or <code>NULL</code> if optimization failed (e.g. too few observations).
</p>

<hr>
<h2 id='DelayedExponential'>Delayed Exponential Distribution</h2><span id='topic+DelayedExponential'></span><span id='topic+dexp_delayed'></span><span id='topic+pexp_delayed'></span><span id='topic+qexp_delayed'></span><span id='topic+rexp_delayed'></span><span id='topic+mexp_delayed'></span>

<h3>Description</h3>

<p>Density, distribution function, quantile function, random generation and restricted mean survival time function for the delayed exponential distribution.
There is an initial delay phase (parameter <code>delay1</code>) where no events occur. After that, <code>rate1</code> applies.
Optionally, a second phase is possible where the hazard rate might change (parameters <code>delay2</code> and <code>rate2</code>).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dexp_delayed(
  x,
  delay1 = 0,
  rate1 = 1,
  delay2 = NULL,
  rate2 = NULL,
  delay = delay1,
  rate = rate1,
  log = FALSE
)

pexp_delayed(
  q,
  delay1 = 0,
  rate1 = 1,
  delay2 = NULL,
  rate2 = NULL,
  delay = delay1,
  rate = rate1,
  ...
)

qexp_delayed(
  p,
  delay1 = 0,
  rate1 = 1,
  delay2 = NULL,
  rate2 = NULL,
  delay = delay1,
  rate = rate1,
  lower.tail = TRUE,
  log.p = FALSE
)

rexp_delayed(
  n,
  delay1 = 0,
  rate1 = 1,
  delay2 = NULL,
  rate2 = NULL,
  delay = delay1,
  rate = rate1
)

mexp_delayed(
  t = +Inf,
  delay1 = 0,
  rate1 = 1,
  delay2 = NULL,
  rate2 = NULL,
  delay = delay1,
  rate = rate1
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="DelayedExponential_+3A_x">x</code></td>
<td>
<p>A numeric vector of values for which to get the density.</p>
</td></tr>
<tr><td><code id="DelayedExponential_+3A_delay1">delay1</code></td>
<td>
<p>numeric. The first delay, must be non-negative.</p>
</td></tr>
<tr><td><code id="DelayedExponential_+3A_rate1">rate1</code></td>
<td>
<p>numeric. The event rate, must be non-negative.</p>
</td></tr>
<tr><td><code id="DelayedExponential_+3A_delay2">delay2</code></td>
<td>
<p>numeric. The second delay, must be non-negative.</p>
</td></tr>
<tr><td><code id="DelayedExponential_+3A_rate2">rate2</code></td>
<td>
<p>numeric. The second event rate, must be non-negative.</p>
</td></tr>
<tr><td><code id="DelayedExponential_+3A_delay">delay</code></td>
<td>
<p>numeric. Alias for first delay.</p>
</td></tr>
<tr><td><code id="DelayedExponential_+3A_rate">rate</code></td>
<td>
<p>numeric. Alias for first rate.</p>
</td></tr>
<tr><td><code id="DelayedExponential_+3A_log">log</code></td>
<td>
<p>logical. Return value on log-scale?</p>
</td></tr>
<tr><td><code id="DelayedExponential_+3A_q">q</code></td>
<td>
<p>A numeric vector of quantile values.</p>
</td></tr>
<tr><td><code id="DelayedExponential_+3A_...">...</code></td>
<td>
<p>further arguments are passed on to the underlying non-delayed function, e.g., <code style="white-space: pre;">&#8288;lower.tail=&#8288;</code> to <code><a href="stats.html#topic+Exponential">stats::pexp()</a></code></p>
</td></tr>
<tr><td><code id="DelayedExponential_+3A_p">p</code></td>
<td>
<p>A numeric vector of probabilities.</p>
</td></tr>
<tr><td><code id="DelayedExponential_+3A_lower.tail">lower.tail</code></td>
<td>
<p>logical. Give cumulative probability of lower tail?</p>
</td></tr>
<tr><td><code id="DelayedExponential_+3A_log.p">log.p</code></td>
<td>
<p>logical. P-value on log-sclae?</p>
</td></tr>
<tr><td><code id="DelayedExponential_+3A_n">n</code></td>
<td>
<p>integer. Number of random observations requested.</p>
</td></tr>
<tr><td><code id="DelayedExponential_+3A_t">t</code></td>
<td>
<p>A numeric vector of times that restrict the mean survival. Default is <code>+Inf</code>, i.e., the unrestricted mean survival time.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Additional arguments are forwarded via <code>...</code> to the underlying functions of the exponential distribution in the <code>stats</code>-package.
If only a single initial delay phase is there, the numerical arguments other than <code>n</code> are recycled to the length of the result (as with the exponential distribution in <code>stats</code>).
With two phases, the arguments are <strong>not</strong> recycled. Only the first element of delays and rates are used as it otherwise becomes ambiguous which delay and rate parameter apply for observations in different phases.
Generally, only the first elements of the logical arguments are used.
</p>


<h3>Value</h3>

<p>Functions pertaining to the delayed exponential distribution:
</p>

<ul>
<li> <p><code>dexp_delayed</code> gives the density
</p>
</li>
<li> <p><code>pexp_delayed</code> gives the distribution function
</p>
</li>
<li> <p><code>qexp_delayed</code> gives the quantile function
</p>
</li>
<li> <p><code>rexp_delayed</code> generates a pseudo-random sample
</p>
</li>
<li> <p><code>mexp_delayed</code> gives the restricted mean survival time
</p>
</li></ul>

<p>The length of the result is determined by <code>n</code> for <code>rexp_delayed</code>, and is the maximum of the lengths of the numerical arguments for the other functions,
R's recycling rules apply when only single initial delay phase is used.
</p>


<h3>See Also</h3>

<p>stats::Exponential
</p>

<hr>
<h2 id='DelayedWeibull'>Delayed Weibull Distribution</h2><span id='topic+DelayedWeibull'></span><span id='topic+dweib_delayed'></span><span id='topic+pweib_delayed'></span><span id='topic+qweib_delayed'></span><span id='topic+rweib_delayed'></span><span id='topic+mweib_delayed'></span>

<h3>Description</h3>

<p>Density, distribution function, quantile function and random generation for the delayed Weibull distribution.
Besides the additional parameter <code>delay</code>, the other two Weibull-parameters are in principle retained as in R's stats-package:
</p>

<ul>
<li> <p><code>shape</code>
</p>
</li>
<li> <p><code>scale</code> (as inverse of rate)
</p>
</li></ul>



<h3>Usage</h3>

<pre><code class='language-R'>dweib_delayed(
  x,
  delay1,
  shape1,
  scale1 = 1,
  delay2 = NULL,
  shape2 = NULL,
  scale2 = 1,
  delay = delay1,
  shape = shape1,
  scale = scale1,
  log = FALSE
)

pweib_delayed(
  q,
  delay1,
  shape1,
  scale1 = 1,
  delay2 = NULL,
  shape2 = NULL,
  scale2 = 1,
  delay = delay1,
  shape = shape1,
  scale = scale1,
  lower.tail = TRUE,
  log.p = FALSE
)

qweib_delayed(
  p,
  delay1,
  shape1,
  scale1 = 1,
  delay2 = NULL,
  shape2 = NULL,
  scale2 = 1,
  delay = delay1,
  shape = shape1,
  scale = scale1,
  lower.tail = TRUE,
  log.p = FALSE
)

rweib_delayed(
  n,
  delay1,
  shape1,
  scale1 = 1,
  delay2 = NULL,
  shape2 = NULL,
  scale2 = 1,
  delay = delay1,
  shape = shape1,
  scale = scale1
)

mweib_delayed(
  t = +Inf,
  delay1,
  shape1,
  scale1 = 1,
  delay2 = NULL,
  shape2 = NULL,
  scale2 = 1,
  delay = delay1,
  shape = shape1,
  scale = scale1
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="DelayedWeibull_+3A_x">x</code></td>
<td>
<p>A numeric vector of values for which to get the density.</p>
</td></tr>
<tr><td><code id="DelayedWeibull_+3A_delay1">delay1</code></td>
<td>
<p>numeric. The first delay, must be non-negative.</p>
</td></tr>
<tr><td><code id="DelayedWeibull_+3A_shape1">shape1</code></td>
<td>
<p>numeric. First shape parameter, must be positive.</p>
</td></tr>
<tr><td><code id="DelayedWeibull_+3A_scale1">scale1</code></td>
<td>
<p>numeric. First scale parameter (inverse of rate), must be positive.</p>
</td></tr>
<tr><td><code id="DelayedWeibull_+3A_delay2">delay2</code></td>
<td>
<p>numeric. The second delay, must be non-negative.</p>
</td></tr>
<tr><td><code id="DelayedWeibull_+3A_shape2">shape2</code></td>
<td>
<p>numeric. The second shape parameter, must be non-negative.</p>
</td></tr>
<tr><td><code id="DelayedWeibull_+3A_scale2">scale2</code></td>
<td>
<p>numeric. The second scale parameter (inverse of rate), must be positive.</p>
</td></tr>
<tr><td><code id="DelayedWeibull_+3A_delay">delay</code></td>
<td>
<p>numeric. Alias for first delay.</p>
</td></tr>
<tr><td><code id="DelayedWeibull_+3A_shape">shape</code></td>
<td>
<p>numeric. Alias for first shape.</p>
</td></tr>
<tr><td><code id="DelayedWeibull_+3A_scale">scale</code></td>
<td>
<p>numeric. Alias for first scale.</p>
</td></tr>
<tr><td><code id="DelayedWeibull_+3A_log">log</code></td>
<td>
<p>logical. Return value on log-scale?</p>
</td></tr>
<tr><td><code id="DelayedWeibull_+3A_q">q</code></td>
<td>
<p>A numeric vector of quantile values.</p>
</td></tr>
<tr><td><code id="DelayedWeibull_+3A_lower.tail">lower.tail</code></td>
<td>
<p>logical. Give cumulative probability of lower tail?</p>
</td></tr>
<tr><td><code id="DelayedWeibull_+3A_log.p">log.p</code></td>
<td>
<p>logical. P-value on log-sclae?</p>
</td></tr>
<tr><td><code id="DelayedWeibull_+3A_p">p</code></td>
<td>
<p>A numeric vector of probabilities.</p>
</td></tr>
<tr><td><code id="DelayedWeibull_+3A_n">n</code></td>
<td>
<p>integer. Number of random observations requested.</p>
</td></tr>
<tr><td><code id="DelayedWeibull_+3A_t">t</code></td>
<td>
<p>A numeric vector of times that restrict the mean survival. Default is <code>+Inf</code>, i.e., the unrestricted mean survival time.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Additional arguments are forwarded via <code>...</code> to the underlying functions of the exponential distribution in the stats-package.
</p>
<p>The numerical arguments other than <code>n</code> are recycled to the length of the result. Only the first elements of the logical arguments are used.
</p>


<h3>Value</h3>

<p>Functions pertaining to the delayed Weibull distribution:
</p>

<ul>
<li> <p><code>dweib_delayed</code> gives the density
</p>
</li>
<li> <p><code>pweib_delayed</code> gives the distribution function
</p>
</li>
<li> <p><code>qweib_delayed</code> gives the quantile function
</p>
</li>
<li> <p><code>rweib_delayed</code> generates a pseudo-random sample
</p>
</li>
<li> <p><code>mweib_delayed</code> gives the restricted mean survival time
</p>
</li></ul>

<p>The length of the result is determined by <code>n</code> for <code>rweib_delayed</code>, and is the maximum of the lengths of the numerical arguments for the other functions, R's recycling rules apply.
</p>

<hr>
<h2 id='estimRoundingError'>Estimate rounding error based on given sample of metric values
The idea is to check at which level of rounding the sample values do not change.</h2><span id='topic+estimRoundingError'></span>

<h3>Description</h3>

<p>Estimate rounding error based on given sample of metric values
The idea is to check at which level of rounding the sample values do not change.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>estimRoundingError(obs, roundDigits = seq.int(-4L, 6L), maxObs = 100L)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="estimRoundingError_+3A_obs">obs</code></td>
<td>
<p>numeric. Metric values from a sample to estimate the corresponding rounding error</p>
</td></tr>
<tr><td><code id="estimRoundingError_+3A_rounddigits">roundDigits</code></td>
<td>
<p>integer. Which level of rounding to test? Negative numbers round to corresponding powers of 10</p>
</td></tr>
<tr><td><code id="estimRoundingError_+3A_maxobs">maxObs</code></td>
<td>
<p>integer. How many observations to consider at most? If the provided sample has more observations a sub-sample is used.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>estimated rounding error
</p>

<hr>
<h2 id='getDist'>Get delay distribution function</h2><span id='topic+getDist'></span>

<h3>Description</h3>

<p>Get delay distribution function
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getDist(
  distribution = c("exponential", "weibull"),
  type = c("cdf", "prob", "density", "random", "param"),
  twoPhase = FALSE,
  twoGroup = FALSE,
  bind = NULL,
  profiled = FALSE,
  transformed = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="getDist_+3A_distribution">distribution</code></td>
<td>
<p>character(1). delay distribution.</p>
</td></tr>
<tr><td><code id="getDist_+3A_type">type</code></td>
<td>
<p>character(1). type of function, cdf: cumulative distribution function, density or random function</p>
</td></tr>
<tr><td><code id="getDist_+3A_twophase">twoPhase</code></td>
<td>
<p>logical(1). For <code>type='param'</code>, do we model two phases?</p>
</td></tr>
<tr><td><code id="getDist_+3A_twogroup">twoGroup</code></td>
<td>
<p>logical(1). For type='param', do we have two groups?</p>
</td></tr>
<tr><td><code id="getDist_+3A_bind">bind</code></td>
<td>
<p>character. For type='param', names of parameters that are bind between the two groups.</p>
</td></tr>
<tr><td><code id="getDist_+3A_profiled">profiled</code></td>
<td>
<p>logical(1). For type='param', do we request profiling?</p>
</td></tr>
<tr><td><code id="getDist_+3A_transformed">transformed</code></td>
<td>
<p>logical(1). For type='param', do we need parameter names transformed (as used inside the optimization function?)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>selected distribution function or parameter names
</p>

<hr>
<h2 id='minObjFunPORT'>Minimize an objective function with PORT routine (nlminb)</h2><span id='topic+minObjFunPORT'></span>

<h3>Description</h3>

<p>Minimize an objective function with PORT routine (nlminb)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>minObjFunPORT(objFun, start, lower = -Inf, upper = +Inf, verbose = 0)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="minObjFunPORT_+3A_objfun">objFun</code></td>
<td>
<p>objective function</p>
</td></tr>
<tr><td><code id="minObjFunPORT_+3A_start">start</code></td>
<td>
<p>numeric vector of parameter values to start optimization</p>
</td></tr>
<tr><td><code id="minObjFunPORT_+3A_lower">lower</code></td>
<td>
<p>numeric. lower bound for parameters (boxed constraint)</p>
</td></tr>
<tr><td><code id="minObjFunPORT_+3A_upper">upper</code></td>
<td>
<p>numeric. upper bound for parameters (boxed constraint)</p>
</td></tr>
<tr><td><code id="minObjFunPORT_+3A_verbose">verbose</code></td>
<td>
<p>numeric. Verbosity level.</p>
</td></tr>
</table>

<hr>
<h2 id='objFunFactory'>Factory method for objective function, either according to maximum product of spacings estimation ('MPSE')
or according to some flavour of maximum likelihood estimation (e.g., naive ('MLEn') or corrected ('MLEc') or weighted ('MLEw') MLE).</h2><span id='topic+objFunFactory'></span>

<h3>Description</h3>

<p>Given the observed data this factory method produces an objective function
which is either the negative of the MPSE-criterion H or the negative log-likelihood for MLE.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>objFunFactory(
  x,
  y = NULL,
  distribution = c("exponential", "weibull"),
  twoPhase = FALSE,
  bind = NULL,
  method = c("MPSE", "MLEn", "MLEc", "MLEw"),
  profiled = FALSE,
  ties = c("density", "equidist", "random", "error"),
  verbose = 0
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="objFunFactory_+3A_x">x</code></td>
<td>
<p>numeric. observations</p>
</td></tr>
<tr><td><code id="objFunFactory_+3A_y">y</code></td>
<td>
<p>numeric. observations in second group.</p>
</td></tr>
<tr><td><code id="objFunFactory_+3A_distribution">distribution</code></td>
<td>
<p>character(1). delayed distribution family</p>
</td></tr>
<tr><td><code id="objFunFactory_+3A_twophase">twoPhase</code></td>
<td>
<p>logical flag. Do we allow for two delay phases where event rate may change? Default is <code>FALSE</code>, i.e., a single delay phase.</p>
</td></tr>
<tr><td><code id="objFunFactory_+3A_bind">bind</code></td>
<td>
<p>character. parameter names that are bind together (i.e. equated) between both groups</p>
</td></tr>
<tr><td><code id="objFunFactory_+3A_method">method</code></td>
<td>
<p>character(1). Specifies the method for which to build the objective function. Default value is <code>MPSE</code>. <code>MLEn</code> is the naive MLE-method, calculating the likelihood function as the product of density values. <code>MLEc</code> is the modified MLE.</p>
</td></tr>
<tr><td><code id="objFunFactory_+3A_profiled">profiled</code></td>
<td>
<p>logical. Should scale parameter be profiled out prior to optimization?</p>
</td></tr>
<tr><td><code id="objFunFactory_+3A_ties">ties</code></td>
<td>
<p>character. How to handle ties within data of a group.</p>
</td></tr>
<tr><td><code id="objFunFactory_+3A_verbose">verbose</code></td>
<td>
<p>integer flag. How much verbosity in output? The higher the more output. Default value is 0 which is no output.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The objective function takes a vector of model parameters as argument.
</p>
<p>From the observations, negative or infinite values are discarded during pre-processing.
In any case, the objective function is to be <strong>minimized</strong>.
</p>


<h3>Value</h3>

<p>the objective function (e.g., the negative MPSE criterion) for given choice of model parameters or <code>NULL</code> upon errors
</p>

<hr>
<h2 id='power_diff'>Power simulation function for a two-group comparison of the delay parameter.</h2><span id='topic+power_diff'></span>

<h3>Description</h3>

<p>There are two ways of operation:
</p>

<ol>
<li> <p><code>power=NULL</code> Given sample size <code>n</code> it simulates the power.
</p>
</li>
<li> <p><code>n=NULL</code> Given a power an iterative search is started to find a suitable <code>n</code> within a specified range.
</p>
</li></ol>



<h3>Usage</h3>

<pre><code class='language-R'>power_diff(
  distribution = c("exponential", "weibull"),
  twoPhase = FALSE,
  param = "delay1",
  test = c("bootstrap", "pearson", "moran", "logrank", "logrank_pp", "LR"),
  eff = stop("Provide parameters for both groups that reflect the effect!"),
  n = NULL,
  r = 1,
  sig.level = 0.05,
  power = NULL,
  nPowerSim = 1600,
  R = 201,
  nRange = c(5, 50),
  verbose = 0
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="power_diff_+3A_distribution">distribution</code></td>
<td>
<p>character. Which assumed distribution is used for the power calculation.</p>
</td></tr>
<tr><td><code id="power_diff_+3A_twophase">twoPhase</code></td>
<td>
<p>logical(1). Do we model two phases per group? Default is <code>FALSE</code>, i.e. a single delay phase per group.</p>
</td></tr>
<tr><td><code id="power_diff_+3A_param">param</code></td>
<td>
<p>character. Parameter name(s) which are to be tested for difference and for which to simulate the power. Default value is <code>'delay1'</code>.</p>
</td></tr>
<tr><td><code id="power_diff_+3A_test">test</code></td>
<td>
<p>character. Which test to use for this power estimation?</p>
</td></tr>
<tr><td><code id="power_diff_+3A_eff">eff</code></td>
<td>
<p>list. The two list elements contain the model parameters (as understood by the delay-distribution functions provided by this package) for the two groups.</p>
</td></tr>
<tr><td><code id="power_diff_+3A_n">n</code></td>
<td>
<p>integer. Number of observations per group for the power simulation or <code>NULL</code> when n is to be estimated for a given power.</p>
</td></tr>
<tr><td><code id="power_diff_+3A_r">r</code></td>
<td>
<p>numeric. Ratio of both groups sizes, ny / nx. Default value is 1, i.e., balanced group sizes. Must be positive.</p>
</td></tr>
<tr><td><code id="power_diff_+3A_sig.level">sig.level</code></td>
<td>
<p>numeric. Significance level. Default is 0.05.</p>
</td></tr>
<tr><td><code id="power_diff_+3A_power">power</code></td>
<td>
<p>numeric. <code>NULL</code> when power is to be estimated for a given sample size or a desired power is specified (and <code>n</code> is estimated).</p>
</td></tr>
<tr><td><code id="power_diff_+3A_npowersim">nPowerSim</code></td>
<td>
<p>integer. Number of simulation rounds. Default value 1600 yields a standard error of 0.01 for power if the true power is 80%.</p>
</td></tr>
<tr><td><code id="power_diff_+3A_r">R</code></td>
<td>
<p>integer. Number of bootstrap samples for test of difference in parameter within each power simulation. It affects the resolution of the P-value for each simulation round. A value of around <code>R=200</code> gives a resolution of 0.5% which might be enough for power analysis.</p>
</td></tr>
<tr><td><code id="power_diff_+3A_nrange">nRange</code></td>
<td>
<p>integer. Admissible range for sample size when power is pre-specified and sample size is requested.</p>
</td></tr>
<tr><td><code id="power_diff_+3A_verbose">verbose</code></td>
<td>
<p>numeric. How many details are requested? Higher value means more details. 0=off, no details.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>In any case, the distribution, the parameters that are tested for, the type of test and the effect size (<code style="white-space: pre;">&#8288;eff=&#8288;</code>) need to be specified.
The more power simulation rounds (parameter <code style="white-space: pre;">&#8288;nPowerSim=&#8288;</code>) the more densely the space of data according to the specified model is sampled.
</p>
<p>Note that this second modus (when <code>n</code> is estimated) is computationally quite heavy.
The iterative search for <code>n</code> uses some heuristics and the estimated sample size might actually give a different power-level.
It is important to check the stated power in the output. The search algorithm comes to results closer to the power aimed at
when the admissible range for sample size (<code style="white-space: pre;">&#8288;nRange=&#8288;</code>) is chosen sensibly.
In case the estimated sample size and the achieved power is too high it might pay off to rerun the function with an adapted admissible range.
</p>


<h3>Value</h3>

<p>List of results of power simulation. Or <code>NULL</code> in case of errors.
</p>

<hr>
<h2 id='publication_examples'>Small data sets from different publications</h2><span id='topic+publication_examples'></span><span id='topic+rockette'></span><span id='topic+fatigue'></span><span id='topic+susquehanna'></span><span id='topic+pollution'></span>

<h3>Description</h3>

<p>Most data sets come from publications about parameter estimation in Weibull models.
See the references in the section &quot;Source&quot; below.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>publication_examples

fatigue

susquehanna

pollution
</code></pre>


<h3>Format</h3>

<p>An object of class <code>numeric</code> of length 4.
</p>
<p>An object of class <code>numeric</code> of length 10.
</p>
<p>An object of class <code>numeric</code> of length 20.
</p>
<p>An object of class <code>numeric</code> of length 20.
</p>


<h3>Details</h3>

<p>These small data sets are provided as numeric vectors.
</p>

<dl>
<dt><code>rockette</code>:</dt><dd><p>Artificial sample of length 4 given by Rockette. The maximum likelihood function has two stationary points, none of them is the global maximum.</p>
</dd>
<dt><code>fatigue</code>:</dt><dd><p>Fatigue times of ten bearings of a specific type in hours.</p>
</dd>
<dt><code>susquehanna</code>:</dt><dd><p>Maximum flood levels (in millions of cubic feet per second) for the Susquehanna River of Harrisburg (Pennsylvania, USA) over 20 4-year periods.</p>
</dd>
<dt><code>pollution</code>:</dt><dd><p>Beach pollution levels in South Wales (measured in number of coliform per 100 ml) on 20 days over a 5-week period.</p>
</dd>
</dl>



<h3>Source</h3>

<p>McCool, J.I., 1974. Inferential techniques for Weibull populations. Technical Report TR 74-0180, Wright Patterson Air Force Base, Ohio.
</p>
<p>Rockette, H., 1974. Maximum Likelihood Estimation with the Weibull Model.
</p>
<p>Dumonceaux, R. and Antle, C. E., 1973. Discrimination between the lognormal and the Weibull distributions. Technometrics, 15, 923-926.
</p>
<p>Steen, P. J. and Stickler, D. J., 1976. A Sewage Pollution Study of Beaches from Cardiff to Ogmore. Report January 1976, Cardiff: Department of Applied Biology, UWIST.
</p>

<hr>
<h2 id='scalePars'>Calculate parameter scaling for optimization routine.</h2><span id='topic+scalePars'></span>

<h3>Description</h3>

<p>The scale per parameter corresponds to the step width within the optimization path.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>scalePars(parV, lowerB = 0.00001, upperB = 100000)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="scalePars_+3A_parv">parV</code></td>
<td>
<p>named numeric parameter vector for optimization</p>
</td></tr>
<tr><td><code id="scalePars_+3A_lowerb">lowerB</code></td>
<td>
<p>numeric. lower bound for parameter scales</p>
</td></tr>
<tr><td><code id="scalePars_+3A_upperb">upperB</code></td>
<td>
<p>numeric. upper bound for parameter scales</p>
</td></tr>
</table>


<h3>Value</h3>

<p>vector of parameter scaling
</p>

<hr>
<h2 id='stankovic'>Survival of mice with glioma under different treatments</h2><span id='topic+stankovic'></span>

<h3>Description</h3>

<p>This data set stems from an animal experiment described in Stankovic (2018).
In particular, the data in question is shown in Figure 6J and 6K.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>stankovic
</code></pre>


<h3>Format</h3>


<dl>
<dt>Figure</dt><dd><p>The figure in the publication where the data is shown</p>
</dd>
<dt>Time</dt><dd><p>Survival in days</p>
</dd>
<dt>Status</dt><dd><p>Right-censor status: 1 means observed event</p>
</dd>
<dt>Group</dt><dd><p>Experimental group identifier</p>
</dd>
<dt>Colour</dt><dd><p>Colour used in the Stankovic publication to mark this group</p>
</dd>
</dl>



<h3>Details</h3>

<p>The data were read directly from the survival plots in the publication with the help of Plot Digitizer, version 2.6.9.
</p>


<h3>Source</h3>

<p>Dudvarski Stankovic N, Bicker F, Keller S, et al. EGFL7 enhances surface expression of integrin a5b1 to promote angiogenesis in malignant brain tumors. EMBO Mol Med. 2018;10(9):e8420. doi:10.15252/emmm.201708420 https://www.ncbi.nlm.nih.gov/pmc/articles/PMC6127886/
</p>

<hr>
<h2 id='test_diff'>Test the difference for delay model parameter(s) between two uncorrelated groups, based on maximum product of spacings estimation (MPSE).</h2><span id='topic+test_diff'></span>

<h3>Description</h3>

<p>It is in fact a model comparison between a null model where the parameters are enforced to be equal and an unconstrained full model.
As test statistic we use twice the difference in best (=lowest) objective function value, i.e. 2 * (<code>val_0</code> - <code>val_1</code>).
This is reminiscent of a likelihood ratio test statistic albeit the objective function is not a negative log-likelihood
but the negative of the maximum product spacing metric.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>test_diff(
  x,
  y = stop("Provide data for group y!"),
  distribution = c("exponential", "weibull"),
  twoPhase = FALSE,
  method = c("MPSE", "MLEn", "MLEw", "MLEc"),
  profiled = method == "MLEw",
  ties = c("density", "equidist", "random", "error"),
  param = "delay1",
  type = c("all", "bootstrap", "GOF", "moran", "pearson", "logrank", "LR"),
  doLogrank = TRUE,
  R = 400,
  chiSqApprox = FALSE,
  verbose = 0
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="test_diff_+3A_x">x</code></td>
<td>
<p>data from reference/control group.</p>
</td></tr>
<tr><td><code id="test_diff_+3A_y">y</code></td>
<td>
<p>data from the treatment group.</p>
</td></tr>
<tr><td><code id="test_diff_+3A_distribution">distribution</code></td>
<td>
<p>character(1). Name of the parametric delay distribution to use.</p>
</td></tr>
<tr><td><code id="test_diff_+3A_twophase">twoPhase</code></td>
<td>
<p>logical(1). Do we model two phases per group? Default is <code>FALSE</code>, i.e. a single delay phase per group.</p>
</td></tr>
<tr><td><code id="test_diff_+3A_method">method</code></td>
<td>
<p>character. Which method to fit the models.</p>
</td></tr>
<tr><td><code id="test_diff_+3A_profiled">profiled</code></td>
<td>
<p>logical. Use the profiled likelihood?</p>
</td></tr>
<tr><td><code id="test_diff_+3A_ties">ties</code></td>
<td>
<p>character. How to handle ties in data vector of a group?</p>
</td></tr>
<tr><td><code id="test_diff_+3A_param">param</code></td>
<td>
<p>character. Names of parameters to test difference for. Default value is <code>'delay1'</code>.</p>
</td></tr>
<tr><td><code id="test_diff_+3A_type">type</code></td>
<td>
<p>character. Which type of tests to perform?</p>
</td></tr>
<tr><td><code id="test_diff_+3A_dologrank">doLogrank</code></td>
<td>
<p>logical. In any case do log-rank based tests?</p>
</td></tr>
<tr><td><code id="test_diff_+3A_r">R</code></td>
<td>
<p>numeric(1). Number of bootstrap samples to evaluate the distribution of the test statistic.</p>
</td></tr>
<tr><td><code id="test_diff_+3A_chisqapprox">chiSqApprox</code></td>
<td>
<p>logical flag. In bootstrap, should we calculate the approximate degrees of freedom for the distribution of the test statistic under H0?</p>
</td></tr>
<tr><td><code id="test_diff_+3A_verbose">verbose</code></td>
<td>
<p>numeric. How many details are requested? Higher value means more details. 0=off, no details.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>High values of this difference speak against the null-model (i.e. high <code>val_0</code> indicates bad fit under 0-model and low values of <code>val_1</code> indicate a good fit under the more general model1.
The test is implemented as a parametric bootstrap test, i.e. we
</p>

<ol>
<li><p> take given null-model fit as ground truth
</p>
</li>
<li><p> regenerate data according to this model.
</p>
</li>
<li><p> recalculate the test statistic
</p>
</li>
<li><p> appraise the observed test statistic in light of the generated distribution under H0
</p>
</li></ol>



<h3>Value</h3>

<p>list with the results of the test. Element P contains the different P-values, for instance from parametric bootstrap
</p>

<hr>
<h2 id='test_GOF'>Goodness-of-fit (GOF) test statistic.</h2><span id='topic+test_GOF'></span>

<h3>Description</h3>

<p>The GOF-test is performed for a fitted delay-model.
There are different GOF-tests implemented:
</p>

<ul>
<li> <p><strong>Moran GOF</strong> is based on spacings, like the MPSE-criterion itself.
</p>
</li>
<li> <p><strong>Pearson GOF</strong> uses categories and compares observed to expected frequencies.
</p>
</li></ul>



<h3>Usage</h3>

<pre><code class='language-R'>test_GOF(delayFit, method = c("moran", "pearson"))
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="test_GOF_+3A_delayfit">delayFit</code></td>
<td>
<p>delay_model fit</p>
</td></tr>
<tr><td><code id="test_GOF_+3A_method">method</code></td>
<td>
<p>character(1). which method to use for GOF. Default is 'moran'.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An <code>htest</code>-object containing the GOF-test result
</p>

<hr>
<h2 id='transform.incubate_fit'>Transform observed data to unit interval</h2><span id='topic+transform.incubate_fit'></span>

<h3>Description</h3>

<p>The transformation is the probability integral transform. It uses the cumulative distribution function with the estimated parameters of the model fit.
All available data in the model fit is transformed.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'incubate_fit'
transform(`_data`, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="transform.incubate_fit_+3A__data">_data</code></td>
<td>
<p>a fitted model object of class <code>incubate_fit</code></p>
</td></tr>
<tr><td><code id="transform.incubate_fit_+3A_...">...</code></td>
<td>
<p>currently ignored</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The transformed data, either a vector (for single group) or a list with entries x and y (in two group scenario)
</p>


<h3>Note</h3>

<p>This S3-method implementation is quite different from its default method that allows for non-standard evaluation on data frames, primarily intended for interactive use.
But the name <code>transform</code> fits so nicely to the intended purpose that it is re-used for the probability integral transform, here.
</p>

<hr>
<h2 id='update.incubate_fit'>Refit an <code>incubate_fit</code>-object with specified optimization arguments.
If more things need to be changed go back to <code>delay_model</code> and start from scratch.</h2><span id='topic+update.incubate_fit'></span>

<h3>Description</h3>

<p>Refit an <code>incubate_fit</code>-object with specified optimization arguments.
If more things need to be changed go back to <code>delay_model</code> and start from scratch.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'incubate_fit'
update(object, optim_args = NULL, verbose = 0, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="update.incubate_fit_+3A_object">object</code></td>
<td>
<p><code>incubate_fit</code>-object</p>
</td></tr>
<tr><td><code id="update.incubate_fit_+3A_optim_args">optim_args</code></td>
<td>
<p>optimization arguments</p>
</td></tr>
<tr><td><code id="update.incubate_fit_+3A_verbose">verbose</code></td>
<td>
<p>integer flag. Requested verbosity during <code>delay_fit</code></p>
</td></tr>
<tr><td><code id="update.incubate_fit_+3A_...">...</code></td>
<td>
<p>further arguments, currently not used.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The updated fitted object of class <code>incubate_fit</code>
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
