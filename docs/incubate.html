<!DOCTYPE html><html><head><title>Help for package incubate</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {incubate}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#as_percent'><p>Format a number as percentage.</p></a></li>
<li><a href='#bsDataStep'><p>Generate bootstrap distribution of model parameters to fitted incubate model.</p></a></li>
<li><a href='#coef.incubate_fit'><p>Coefficients of a delay-model fit.</p></a></li>
<li><a href='#confint.incubate_fit'><p>Confidence intervals for parameters of incubate-model fits.</p></a></li>
<li><a href='#delay_fit'><p>Fit optimal parameters according to the objective function (either MPSE or MLE0).</p></a></li>
<li><a href='#delay_model'><p>Fit a delayed Exponential or Weibull model to one or two given sample(s).</p></a></li>
<li><a href='#DelayedExponential'><p>Delayed Exponential Distribution</p></a></li>
<li><a href='#DelayedWeibull'><p>Delayed Weibull Distribution</p></a></li>
<li><a href='#estimRoundingError'><p>Estimate rounding error based on given sample of metric values</p>
The idea is to check at which level of rounding the sample values do not change.</a></li>
<li><a href='#getDist'><p>Get delay distribution function</p></a></li>
<li><a href='#getPars'><p>Extract the parameters for the specified group.</p></a></li>
<li><a href='#incubate'><p>Incubate package for parametric time-to-event analysis with delay</p></a></li>
<li><a href='#objFunFactory'><p>Factory method for objective function, either according to maximum product of spacings estimation ('MPSE')</p>
or according to standard maximum likelihood estimation ('MLE0').</a></li>
<li><a href='#power_diff'><p>Power simulation function for a two-group comparison of the delay parameter.</p></a></li>
<li><a href='#stankovic'><p>Survival of mice with glioma under different treatments.</p></a></li>
<li><a href='#test_diff'><p>Test the difference for delay model parameter(s) between two uncorrelated groups, based on maximum product of spacings estimation (MPSE).</p></a></li>
<li><a href='#test_GOF'><p>Goodness-of-fit (GOF) test statistic.</p></a></li>
<li><a href='#transform.incubate_fit'><p>Transform observed data to unit interval</p></a></li>
<li><a href='#update.incubate_fit'><p>Refit an <code>incubate_fit</code>-object with specified optimization arguments.</p>
If more things need to be changed use <code>delay_model</code>.</a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Title:</td>
<td>Parametric Time-to-Event Analysis with Variable Incubation
Phases</td>
</tr>
<tr>
<td>Version:</td>
<td>1.2.1</td>
</tr>
<tr>
<td>Date:</td>
<td>2023-08-21</td>
</tr>
<tr>
<td>Description:</td>
<td>Fit parametric models for time-to-event data that show an initial
    'incubation period', i.e., a variable delay phase where the hazard is zero. The
    delayed Weibull distribution serves as foundational data model. The
    specific method of 'MPSE' (maximum product of spacings estimation) is used for parameter
    estimation. Bootstrap confidence intervals for parameters and significance
    tests in a two group setting are provided.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/LGPL-3">LGPL (&ge; 3)</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>Imports:</td>
<td>future (&ge; 1.21), future.apply (&ge; 1.6), glue (&ge; 1.4), MASS,
purrr (&ge; 0.3), rlang (&ge; 0.4), stats, survival, tibble</td>
</tr>
<tr>
<td>Suggests:</td>
<td>boot, future.callr, ggplot2 (&ge; 3.3), knitr, testthat (&ge;
3.0.0)</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://gitlab.com/imb-dev/incubate/">https://gitlab.com/imb-dev/incubate/</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://gitlab.com/imb-dev/incubate/-/issues/">https://gitlab.com/imb-dev/incubate/-/issues/</a></td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>Config/testthat/edition:</td>
<td>3</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 2.10)</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-08-21 13:58:42 UTC; kuhnmat</td>
</tr>
<tr>
<td>Author:</td>
<td>Matthias Kuhn <a href="https://orcid.org/0000-0003-2868-5155"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cre]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Matthias Kuhn &lt;matthias.kuhn@tu-dresden.de&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-08-21 15:00:26 UTC</td>
</tr>
</table>
<hr>
<h2 id='as_percent'>Format a number as percentage.</h2><span id='topic+as_percent'></span>

<h3>Description</h3>

<p>Internal helper function that is not exported.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>as_percent(x, digits = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="as_percent_+3A_x">x</code></td>
<td>
<p>numeric vector to be formated as percentage</p>
</td></tr>
<tr><td><code id="as_percent_+3A_digits">digits</code></td>
<td>
<p>requested number of decimal digits of the percentage</p>
</td></tr>
</table>


<h3>Value</h3>

<p>number formatted as percentage character
</p>

<hr>
<h2 id='bsDataStep'>Generate bootstrap distribution of model parameters to fitted incubate model.</h2><span id='topic+bsDataStep'></span>

<h3>Description</h3>

<p>Bootstrap data are here estimated coefficients from models fitted to bootstrap samples.
The bootstrap data is used to make bootstrap inference in the second step.
It is an internal function, the main entry point is <code><a href="#topic+confint.incubate_fit">confint.incubate_fit()</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bsDataStep(
  object,
  bs_data = c("parametric", "ordinary"),
  R,
  useBoot = FALSE,
  smd_factor = 0.25
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bsDataStep_+3A_object">object</code></td>
<td>
<p>an <code>incubate_fit</code>-object</p>
</td></tr>
<tr><td><code id="bsDataStep_+3A_bs_data">bs_data</code></td>
<td>
<p>character. Which type of bootstrap method to generate data?</p>
</td></tr>
<tr><td><code id="bsDataStep_+3A_r">R</code></td>
<td>
<p>integer. Number of bootstrapped model coefficient estimates</p>
</td></tr>
<tr><td><code id="bsDataStep_+3A_useboot">useBoot</code></td>
<td>
<p>flag. Do you want to use the boot-package? Default value is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="bsDataStep_+3A_smd_factor">smd_factor</code></td>
<td>
<p>numeric. smooth-delay factor: influence the amount of smoothing. 0 means no smoothing at all. Default is 0.25 (as was optimal in simulation for log-quantile together with log-delay-shift = 5)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>bootstrap data, either as matrix or of class <code>boot</code> (depending on the <code>useBoot</code>-flag)
</p>

<hr>
<h2 id='coef.incubate_fit'>Coefficients of a delay-model fit.</h2><span id='topic+coef.incubate_fit'></span>

<h3>Description</h3>

<p>Coefficients of a delay-model fit.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'incubate_fit'
coef(object, group = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="coef.incubate_fit_+3A_object">object</code></td>
<td>
<p>object that is a <code>incubate_fit</code></p>
</td></tr>
<tr><td><code id="coef.incubate_fit_+3A_group">group</code></td>
<td>
<p>character string to request the canonical parameter for one group</p>
</td></tr>
<tr><td><code id="coef.incubate_fit_+3A_...">...</code></td>
<td>
<p>further arguments, currently not used.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>named coefficient vector
</p>

<hr>
<h2 id='confint.incubate_fit'>Confidence intervals for parameters of incubate-model fits.</h2><span id='topic+confint.incubate_fit'></span>

<h3>Description</h3>

<p>Bias-corrected bootstrap confidence limits (either quantile-based or normal-approximation based) are generated.
Optionally, there are also variants that use a log-transformation first.
At least R=1000 bootstrap replications are recommended. Default are quantile-based confidence intervals that internally use a log-transformation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'incubate_fit'
confint(
  object,
  parm,
  level = 0.95,
  R = 199L,
  bs_data,
  bs_infer = c("logquantile", "lognormal", "quantile", "quantile0", "normal", "normal0"),
  useBoot = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="confint.incubate_fit_+3A_object">object</code></td>
<td>
<p>object of class <code>incubate_fit</code></p>
</td></tr>
<tr><td><code id="confint.incubate_fit_+3A_parm">parm</code></td>
<td>
<p>character. Which parameters to get confidence interval for?</p>
</td></tr>
<tr><td><code id="confint.incubate_fit_+3A_level">level</code></td>
<td>
<p>numeric. Which is the requested confidence level for the interval? Default value is 0.95</p>
</td></tr>
<tr><td><code id="confint.incubate_fit_+3A_r">R</code></td>
<td>
<p>number of bootstrap replications. Used only if not <code>bs_data</code>-object is provided.</p>
</td></tr>
<tr><td><code id="confint.incubate_fit_+3A_bs_data">bs_data</code></td>
<td>
<p>character or bootstrap data object. If character, it specifies which type of bootstrap is requested and the bootstrap data will be generated. Data can also be provided here directly. If missing it uses parametric bootstrap.</p>
</td></tr>
<tr><td><code id="confint.incubate_fit_+3A_bs_infer">bs_infer</code></td>
<td>
<p>character. Which type of bootstrap inference is requested to generate the confidence interval?</p>
</td></tr>
<tr><td><code id="confint.incubate_fit_+3A_useboot">useBoot</code></td>
<td>
<p>logical. Delegate bootstrap confint calculation to the <code>boot</code>-package?</p>
</td></tr>
<tr><td><code id="confint.incubate_fit_+3A_...">...</code></td>
<td>
<p>further arguments, currently not used.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix (or vector) with columns giving lower and upper confidence limits for each parameter.
</p>

<hr>
<h2 id='delay_fit'>Fit optimal parameters according to the objective function (either MPSE or MLE0).</h2><span id='topic+delay_fit'></span>

<h3>Description</h3>

<p>The objective function carries the given data in its environment and it is to be minimized.
R's standard routine <code>stats::optim</code> does the numerical optimization, using numerical derivatives.
or the analytical solution is returned directly if available.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>delay_fit(objFun, optim_args = NULL, verbose = 0)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="delay_fit_+3A_objfun">objFun</code></td>
<td>
<p>objective function to be minimized</p>
</td></tr>
<tr><td><code id="delay_fit_+3A_optim_args">optim_args</code></td>
<td>
<p>list of own arguments for optimization. If <code>NULL</code> it uses the default optim arguments associated to the objective function.</p>
</td></tr>
<tr><td><code id="delay_fit_+3A_verbose">verbose</code></td>
<td>
<p>integer that indicates the level of verboseness. Default 0 is quiet.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>optimization object including a named parameter vector or <code>NULL</code> in case of errors during optimization
</p>

<hr>
<h2 id='delay_model'>Fit a delayed Exponential or Weibull model to one or two given sample(s).</h2><span id='topic+delay_model'></span>

<h3>Description</h3>

<p>Maximum product spacing is used to fit the parameters.
Numerical optimization is done by <code>stats::optim</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>delay_model(
  x = stop("Specify observations!", call. = FALSE),
  y = NULL,
  distribution = c("exponential", "weibull"),
  method = c("MPSE", "MLE0"),
  bind = NULL,
  ties = c("density", "equidist", "random", "error"),
  optim_args = NULL,
  verbose = 0
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="delay_model_+3A_x">x</code></td>
<td>
<p>numeric. observations of 1st group. Can also be a list of data from two groups.</p>
</td></tr>
<tr><td><code id="delay_model_+3A_y">y</code></td>
<td>
<p>numeric. observations from 2nd group</p>
</td></tr>
<tr><td><code id="delay_model_+3A_distribution">distribution</code></td>
<td>
<p>character. Which delayed distribution is assumed? Exponential or Weibull.</p>
</td></tr>
<tr><td><code id="delay_model_+3A_method">method</code></td>
<td>
<p>character. Which method to fit the model? 'MPSE' = maximum product of spacings estimation <em>or</em> 'MLE0' = standard maximum likelihood estimation</p>
</td></tr>
<tr><td><code id="delay_model_+3A_bind">bind</code></td>
<td>
<p>character. parameter names that are bind together in 2-group situation.</p>
</td></tr>
<tr><td><code id="delay_model_+3A_ties">ties</code></td>
<td>
<p>character. How to handle ties.</p>
</td></tr>
<tr><td><code id="delay_model_+3A_optim_args">optim_args</code></td>
<td>
<p>list. optimization arguments to use. Use <code>NULL</code> to use the data-dependent default values.</p>
</td></tr>
<tr><td><code id="delay_model_+3A_verbose">verbose</code></td>
<td>
<p>integer. level of verboseness. Default 0 is quiet.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>incubate_fit</code> the delay-model fit object. Or <code>NULL</code> if optimization failed (e.g. too few observations).
</p>

<hr>
<h2 id='DelayedExponential'>Delayed Exponential Distribution</h2><span id='topic+DelayedExponential'></span><span id='topic+dexp_delayed'></span><span id='topic+pexp_delayed'></span><span id='topic+qexp_delayed'></span><span id='topic+rexp_delayed'></span>

<h3>Description</h3>

<p>Density, distribution function, quantile function and random generation for the delayed exponential distribution with <code>rate</code>-parameter.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dexp_delayed(x, delay, rate = 1, ...)

pexp_delayed(q, delay, rate = 1, ...)

qexp_delayed(p, delay, rate = 1, ...)

rexp_delayed(n, delay, rate = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="DelayedExponential_+3A_x">x</code></td>
<td>
<p>A numeric vector of values for which to get the density.</p>
</td></tr>
<tr><td><code id="DelayedExponential_+3A_delay">delay</code></td>
<td>
<p>numeric. The delay, must be non-negative.</p>
</td></tr>
<tr><td><code id="DelayedExponential_+3A_rate">rate</code></td>
<td>
<p>numeric. The event rate, must be non-negative.</p>
</td></tr>
<tr><td><code id="DelayedExponential_+3A_...">...</code></td>
<td>
<p>further arguments are passed on to the underlying non-delayed function, e.g., <code><a href="stats.html#topic+Exponential">stats::dexp()</a></code></p>
</td></tr>
<tr><td><code id="DelayedExponential_+3A_q">q</code></td>
<td>
<p>A numeric vector of quantile values.</p>
</td></tr>
<tr><td><code id="DelayedExponential_+3A_p">p</code></td>
<td>
<p>A numeric vector of probabilities.</p>
</td></tr>
<tr><td><code id="DelayedExponential_+3A_n">n</code></td>
<td>
<p>integer. Number of random observations requested.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Additional arguments are forwarded via <code>...</code> to the underlying functions of the exponential distribution in the <code>stats</code>-package.
The numerical arguments other than <code>n</code> are recycled to the length of the result. Only the first elements of the logical arguments are used.
</p>


<h3>Value</h3>

<p><code>dexp_delayed</code> gives the density, <code>pexp_delayed</code> gives the distribution function, <code>qexp_delayed</code> gives the quantile function,
and <code>rexp_delayed</code> generates a pseudo-random sample from the delayed exponential distribution.
</p>
<p>The length of the result is determined by <code>n</code> for <code>rexp_delayed</code>, and is the maximum of the lengths of the numerical arguments for the other functions.
</p>

<hr>
<h2 id='DelayedWeibull'>Delayed Weibull Distribution</h2><span id='topic+DelayedWeibull'></span><span id='topic+dweib_delayed'></span><span id='topic+pweib_delayed'></span><span id='topic+qweib_delayed'></span><span id='topic+rweib_delayed'></span>

<h3>Description</h3>

<p>Density, distribution function, quantile function and random generation for the delayed Weibull distribution with parameters
as in the Weibull distribution functions in R's stats-package, namely:
</p>

<ul>
<li> <p><code>delay</code>
</p>
</li>
<li> <p><code>shape</code>
</p>
</li>
<li> <p><code>scale</code> (inverse of rate)
</p>
</li></ul>



<h3>Usage</h3>

<pre><code class='language-R'>dweib_delayed(x, delay, shape, scale = 1, ...)

pweib_delayed(q, delay, shape, scale = 1, ...)

qweib_delayed(p, delay, shape, scale = 1, ...)

rweib_delayed(n, delay, shape, scale = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="DelayedWeibull_+3A_x">x</code></td>
<td>
<p>A numeric vector of values for which to get the density.</p>
</td></tr>
<tr><td><code id="DelayedWeibull_+3A_delay">delay</code></td>
<td>
<p>numeric. The delay, must be non-negative.</p>
</td></tr>
<tr><td><code id="DelayedWeibull_+3A_shape">shape</code></td>
<td>
<p>numeric. Shape parameter, must be positive.</p>
</td></tr>
<tr><td><code id="DelayedWeibull_+3A_scale">scale</code></td>
<td>
<p>numeric. Scale parameter (inverse of rate), must be positive.</p>
</td></tr>
<tr><td><code id="DelayedWeibull_+3A_...">...</code></td>
<td>
<p>further arguments are passed on to the underlying non-delayed function, e.g., <code><a href="stats.html#topic+Weibull">stats::dweibull()</a></code></p>
</td></tr>
<tr><td><code id="DelayedWeibull_+3A_q">q</code></td>
<td>
<p>A numeric vector of quantile values.</p>
</td></tr>
<tr><td><code id="DelayedWeibull_+3A_p">p</code></td>
<td>
<p>A numeric vector of probabilities.</p>
</td></tr>
<tr><td><code id="DelayedWeibull_+3A_n">n</code></td>
<td>
<p>integer. Number of random observations requested.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Additional arguments are forwarded via <code>...</code> to the underlying functions of the exponential distribution in the stats-package.
</p>
<p>The numerical arguments other than <code>n</code> are recycled to the length of the result. Only the first elements of the logical arguments are used.
</p>


<h3>Value</h3>

<p><code>dweib_delayed</code> gives the density, <code>pweib_delayed</code> gives the distribution function, <code>qweib_delayed</code> gives the quantile function,
and <code>rweib_delayed</code> generates a pseudo-random sample from the delayed Weibull distribution.
</p>
<p>The length of the result is determined by <code>n</code> for <code>rweib_delayed</code>, and is the maximum of the lengths of the numerical arguments for the other functions.
</p>

<hr>
<h2 id='estimRoundingError'>Estimate rounding error based on given sample of metric values
The idea is to check at which level of rounding the sample values do not change.</h2><span id='topic+estimRoundingError'></span>

<h3>Description</h3>

<p>Estimate rounding error based on given sample of metric values
The idea is to check at which level of rounding the sample values do not change.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>estimRoundingError(obs, roundDigits = seq.int(-4L, 6L), maxObs = 100L)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="estimRoundingError_+3A_obs">obs</code></td>
<td>
<p>numeric. Metric values from a sample to estimate the corresponding rounding error</p>
</td></tr>
<tr><td><code id="estimRoundingError_+3A_rounddigits">roundDigits</code></td>
<td>
<p>integer. Which level of rounding to test? Negative numbers round to corresponding powers of 10</p>
</td></tr>
<tr><td><code id="estimRoundingError_+3A_maxobs">maxObs</code></td>
<td>
<p>integer. How many observations to consider at most? If the provided sample has more observations a sub-sample is used.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>estimated rounding error
</p>

<hr>
<h2 id='getDist'>Get delay distribution function</h2><span id='topic+getDist'></span>

<h3>Description</h3>

<p>Get delay distribution function
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getDist(
  distribution = c("exponential", "weibull"),
  type = c("cdf", "prob", "density", "random", "param"),
  twoGroup = FALSE,
  bind = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getDist_+3A_distribution">distribution</code></td>
<td>
<p>character(1). delay distribution.</p>
</td></tr>
<tr><td><code id="getDist_+3A_type">type</code></td>
<td>
<p>character(1). type of function, cdf: cumulative distribution function, density or random function</p>
</td></tr>
<tr><td><code id="getDist_+3A_twogroup">twoGroup</code></td>
<td>
<p>logical(1). Do we have two groups?</p>
</td></tr>
<tr><td><code id="getDist_+3A_bind">bind</code></td>
<td>
<p>character. Names of parameters that are bind between the two groups.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>selected distribution function or parameter names
</p>

<hr>
<h2 id='getPars'>Extract the parameters for the specified group.</h2><span id='topic+getPars'></span>

<h3>Description</h3>

<p>The parameters of the requested group are named using the canonical parameter names of the distribution.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getPars(par, group = "x", twoGroup, oNames, bind)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getPars_+3A_par">par</code></td>
<td>
<p>named parameters (as simple vector or as list)</p>
</td></tr>
<tr><td><code id="getPars_+3A_group">group</code></td>
<td>
<p>character. Which group to extract parameters for?</p>
</td></tr>
<tr><td><code id="getPars_+3A_twogroup">twoGroup</code></td>
<td>
<p>flag. Is it a two-group setting?</p>
</td></tr>
<tr><td><code id="getPars_+3A_onames">oNames</code></td>
<td>
<p>character. Original parameter names from distribution.</p>
</td></tr>
<tr><td><code id="getPars_+3A_bind">bind</code></td>
<td>
<p>character. Which parameters are bind together in a two-group setting?</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For a one-group setting or when <code>group=NULL</code> it simply returns the given parameter.
This is an internal helper function
used in <code><a href="#topic+coef.incubate_fit">coef.incubate_fit()</a></code>, <code><a href="#topic+bsDataStep">bsDataStep()</a></code> and in the factory method <code><a href="#topic+objFunFactory">objFunFactory()</a></code> below.
</p>


<h3>Value</h3>

<p>named vector of parameters from the relevant group
</p>

<hr>
<h2 id='incubate'>Incubate package for parametric time-to-event analysis with delay</h2><span id='topic+incubate'></span><span id='topic+incubate-package'></span>

<h3>Description</h3>

<p>Estimation and statistical tests on parameters in parametric time-to-event analyses with delay.
</p>


<h3>Author(s)</h3>

<p><strong>Maintainer</strong>: Matthias Kuhn <a href="mailto:matthias.kuhn@tu-dresden.de">matthias.kuhn@tu-dresden.de</a> (<a href="https://orcid.org/0000-0003-2868-5155">ORCID</a>)
</p>


<h3>See Also</h3>

<p>Useful links:
</p>

<ul>
<li> <p><a href="https://gitlab.com/imb-dev/incubate/">https://gitlab.com/imb-dev/incubate/</a>
</p>
</li>
<li><p> Report bugs at <a href="https://gitlab.com/imb-dev/incubate/-/issues/">https://gitlab.com/imb-dev/incubate/-/issues/</a>
</p>
</li></ul>


<hr>
<h2 id='objFunFactory'>Factory method for objective function, either according to maximum product of spacings estimation ('MPSE')
or according to standard maximum likelihood estimation ('MLE0').</h2><span id='topic+objFunFactory'></span>

<h3>Description</h3>

<p>Given the observed data this factory method produces an MPSE objective function implementation
which is the negative of the MPSE-criterion H or the negative log-likelihood for MLE.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>objFunFactory(
  x,
  y = NULL,
  method = c("MPSE", "MLE0"),
  distribution = c("exponential", "weibull"),
  bind = NULL,
  ties = c("density", "equidist", "random", "error"),
  verbose = 0L
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="objFunFactory_+3A_x">x</code></td>
<td>
<p>numeric. observations</p>
</td></tr>
<tr><td><code id="objFunFactory_+3A_y">y</code></td>
<td>
<p>numeric. observations in second group.</p>
</td></tr>
<tr><td><code id="objFunFactory_+3A_method">method</code></td>
<td>
<p>character(1). Specifies the method for which to build the objective function. Default value is <code>MPSE</code>. <code>MLE0</code> is the standard MLE-method, calculating the likelihood function as the product of density values</p>
</td></tr>
<tr><td><code id="objFunFactory_+3A_distribution">distribution</code></td>
<td>
<p>character(1). delayed distribution family</p>
</td></tr>
<tr><td><code id="objFunFactory_+3A_bind">bind</code></td>
<td>
<p>character. parameter names that are bind together (i.e. equated) between both groups</p>
</td></tr>
<tr><td><code id="objFunFactory_+3A_ties">ties</code></td>
<td>
<p>character. How to handle ties within data of a group.</p>
</td></tr>
<tr><td><code id="objFunFactory_+3A_verbose">verbose</code></td>
<td>
<p>integer flag. How much verbosity in output? The higher the more output. Default value is 0 which is no output.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>From the observations, negative or infinite values are discarded. In any case, the objective function is to be minimized.
</p>


<h3>Value</h3>

<p>the objective function (e.g., the negative MPSE criterion) for given choice of model parameters or <code>NULL</code> upon errors
</p>

<hr>
<h2 id='power_diff'>Power simulation function for a two-group comparison of the delay parameter.</h2><span id='topic+power_diff'></span>

<h3>Description</h3>

<p>There are two ways of operation:
</p>

<ol>
<li> <p><code>power=NULL</code> Given sample size <code>n</code> it simulates the power.
</p>
</li>
<li> <p><code>n=NULL</code> Given a power an iterative search is started to find a suitable <code>n</code> within a specified range.
</p>
</li></ol>



<h3>Usage</h3>

<pre><code class='language-R'>power_diff(
  distribution = c("exponential", "weibull"),
  param = "delay",
  test = c("bootstrap", "pearson", "moran", "lr", "lr_pp"),
  eff = stop("Provide parameters for both group that reflect the effect!"),
  n = NULL,
  r = 1,
  sig.level = 0.05,
  power = NULL,
  nPowerSim = 1600,
  R = 201,
  nRange = c(5, 50)
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="power_diff_+3A_distribution">distribution</code></td>
<td>
<p>character. Which assumed distribution is used for the power calculation.</p>
</td></tr>
<tr><td><code id="power_diff_+3A_param">param</code></td>
<td>
<p>character. Parameter name(s) for which to simulate the power.</p>
</td></tr>
<tr><td><code id="power_diff_+3A_test">test</code></td>
<td>
<p>character. Which test to use for this power estimation?</p>
</td></tr>
<tr><td><code id="power_diff_+3A_eff">eff</code></td>
<td>
<p>list. The two list elements contain the model parameters (as understood by the delay-distribution functions provided by this package) for the two groups.</p>
</td></tr>
<tr><td><code id="power_diff_+3A_n">n</code></td>
<td>
<p>integer. Number of observations per group for the power simulation or <code>NULL</code> when n is to be estimated for a given power.</p>
</td></tr>
<tr><td><code id="power_diff_+3A_r">r</code></td>
<td>
<p>numeric. Ratio of both groups sizes, ny / nx. Default value is 1, i.e., balanced group sizes. Must be positive.</p>
</td></tr>
<tr><td><code id="power_diff_+3A_sig.level">sig.level</code></td>
<td>
<p>numeric. Significance level. Default is 0.05.</p>
</td></tr>
<tr><td><code id="power_diff_+3A_power">power</code></td>
<td>
<p>numeric. <code>NULL</code> when power is to be estimated for a given sample size or a desired power is specified (and <code>n</code> is estimated).</p>
</td></tr>
<tr><td><code id="power_diff_+3A_npowersim">nPowerSim</code></td>
<td>
<p>integer. Number of simulation rounds. Default value 1600 yields a standard error of 0.01 for power if the true power is 80%.</p>
</td></tr>
<tr><td><code id="power_diff_+3A_r">R</code></td>
<td>
<p>integer. Number of bootstrap samples for test of difference in parameter within each power simulation. It affects the resolution of the P-value for each simulation round. A value of around <code>R=200</code> gives a resolution of 0.5% which might be enough for power analysis.</p>
</td></tr>
<tr><td><code id="power_diff_+3A_nrange">nRange</code></td>
<td>
<p>integer. Admissible range for sample size when power is pre-specified and sample size is requested.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>In any case, the distribution, the parameters that are tested for, the type of test and the effect size (<code style="white-space: pre;">&#8288;eff=&#8288;</code>) need to be specified.
The more power simulation rounds (parameter <code style="white-space: pre;">&#8288;nPowerSim=&#8288;</code>) the more densely the space of data according to the specified model is sampled.
</p>
<p>Note that this second modus (when <code>n</code> is estimated) is computationally quite heavy.
The iterative search for <code>n</code> uses some heuristics and the estimated sample size might actually give a different power-level.
It is important to check the stated power in the output. The search algorithm comes to results closer to the power aimed at
when the admissible range for sample size (<code style="white-space: pre;">&#8288;nRange=&#8288;</code>) is chosen sensibly.
In case the estimated sample size and the achieved power is too high it might pay off to rerun the function with an adapted admissible range.
</p>


<h3>Value</h3>

<p>List of results of power simulation. Or <code>NULL</code> in case of errors.
</p>

<hr>
<h2 id='stankovic'>Survival of mice with glioma under different treatments.</h2><span id='topic+stankovic'></span>

<h3>Description</h3>

<p>A dataset from an animal experiment described in Stankovic (2018), shown in Figure 6J and 6K.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>stankovic
</code></pre>


<h3>Format</h3>


<dl>
<dt>Figure</dt><dd><p>The figure in the publication where the data is shown</p>
</dd>
<dt>Time</dt><dd><p>Survival in days</p>
</dd>
<dt>Status</dt><dd><p>Right-censor status: 1 means observed event</p>
</dd>
<dt>Group</dt><dd><p>Experimental group identifier</p>
</dd>
<dt>Colour</dt><dd><p>Colour used in the Stankovic publication to mark this group</p>
</dd>
</dl>



<h3>Details</h3>

<p>The data were read directly from the survival plots in the publication with the help of Plot Digitizer, version 2.6.9.
</p>


<h3>Source</h3>

<p>Dudvarski Stankovic N, Bicker F, Keller S, et al. EGFL7 enhances surface expression of integrin a5b1 to promote angiogenesis in malignant brain tumors. EMBO Mol Med. 2018;10(9):e8420. doi:10.15252/emmm.201708420 <a href="https://www.ncbi.nlm.nih.gov/pmc/articles/PMC6127886/">https://www.ncbi.nlm.nih.gov/pmc/articles/PMC6127886/</a>
</p>

<hr>
<h2 id='test_diff'>Test the difference for delay model parameter(s) between two uncorrelated groups, based on maximum product of spacings estimation (MPSE).</h2><span id='topic+test_diff'></span>

<h3>Description</h3>

<p>It is in fact a model comparison between a null model where the parameters are enforced to be equal and an unconstrained full model.
As test statistic we use twice the difference in best (=lowest) objective function value, i.e. 2 * (<code>val_0</code> - <code>val_1</code>).
This is reminiscent of a likelihood ratio test statistic albeit the objective function is not a negative log-likelihood
but the negative of the maximum product spacing metric.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>test_diff(
  x,
  y = stop("Provide data for group y!"),
  distribution = c("exponential", "weibull"),
  param = "delay",
  R = 400,
  ties = c("density", "equidist", "random", "error"),
  type = c("all", "bootstrap", "gof", "moran", "pearson", "lr", "lr_pp"),
  verbose = 0
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="test_diff_+3A_x">x</code></td>
<td>
<p>data from reference/control group.</p>
</td></tr>
<tr><td><code id="test_diff_+3A_y">y</code></td>
<td>
<p>data from the treatment group.</p>
</td></tr>
<tr><td><code id="test_diff_+3A_distribution">distribution</code></td>
<td>
<p>character(1). Name of the parametric delay distribution to use.</p>
</td></tr>
<tr><td><code id="test_diff_+3A_param">param</code></td>
<td>
<p>character. Names of parameters to test difference for. Default value is <code>'delay'</code>.</p>
</td></tr>
<tr><td><code id="test_diff_+3A_r">R</code></td>
<td>
<p>numeric(1). Number of bootstrap samples to evaluate the distribution of the test statistic.</p>
</td></tr>
<tr><td><code id="test_diff_+3A_ties">ties</code></td>
<td>
<p>character. How to handle ties in data vector of a group?</p>
</td></tr>
<tr><td><code id="test_diff_+3A_type">type</code></td>
<td>
<p>character. Which type of tests to perform?</p>
</td></tr>
<tr><td><code id="test_diff_+3A_verbose">verbose</code></td>
<td>
<p>numeric. How many details are requested? Higher value means more details. 0=off, no details.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>High values of this difference speak against the null-model (i.e. high <code>val_0</code> indicates bad fit under 0-model and low values of <code>val_1</code> indicate a good fit under the more general model1.
The test is implemented as a parametric bootstrap test, i.e. we
</p>

<ol>
<li><p> take given null-model fit as ground truth
</p>
</li>
<li><p> regenerate data according to this model.
</p>
</li>
<li><p> recalculate the test statistic
</p>
</li>
<li><p> appraise the observed test statistic in light of the generated distribution under H0
</p>
</li></ol>



<h3>Value</h3>

<p>list with the results of the test. Element P contains the different P-values, for instance from parametric bootstrap
</p>

<hr>
<h2 id='test_GOF'>Goodness-of-fit (GOF) test statistic.</h2><span id='topic+test_GOF'></span>

<h3>Description</h3>

<p>The GOF-test is performed for a fitted delay-model.
There are different GOF-tests implemented:
</p>

<ul>
<li> <p><strong>Moran GOF</strong> is based on spacings, like the MPSE-criterion itself.
</p>
</li>
<li> <p><strong>Pearson GOF</strong> uses categories and compares observed to expected frequencies.
</p>
</li></ul>



<h3>Usage</h3>

<pre><code class='language-R'>test_GOF(delayFit, method = c("moran", "pearson"))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="test_GOF_+3A_delayfit">delayFit</code></td>
<td>
<p>delay_model fit</p>
</td></tr>
<tr><td><code id="test_GOF_+3A_method">method</code></td>
<td>
<p>character(1). which method to use for GOF. Default is 'moran'.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An <code>htest</code>-object containing the GOF-test result
</p>

<hr>
<h2 id='transform.incubate_fit'>Transform observed data to unit interval</h2><span id='topic+transform.incubate_fit'></span>

<h3>Description</h3>

<p>The transformation is the probability integral transform. It uses the cumulative distribution function with the estimated parameters of the model fit.
All available data in the model fit is transformed.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'incubate_fit'
transform(`_data`, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="transform.incubate_fit_+3A__data">_data</code></td>
<td>
<p>a fitted model object of class <code>incubate_fit</code></p>
</td></tr>
<tr><td><code id="transform.incubate_fit_+3A_...">...</code></td>
<td>
<p>currently ignored</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The transformed data, either a vector (for single group) or a list with entries x and y (in two group scenario)
</p>


<h3>Note</h3>

<p>This S3-method implementation is quite different from its default method that allows for non-standard evaluation on data frames, primarily for interactive use.
But the name <code>transform</code> just fits so nicely to the intended purpose that it is re-used for the probability integral transform.
</p>

<hr>
<h2 id='update.incubate_fit'>Refit an <code>incubate_fit</code>-object with specified optimization arguments.
If more things need to be changed use <code>delay_model</code>.</h2><span id='topic+update.incubate_fit'></span>

<h3>Description</h3>

<p>Refit an <code>incubate_fit</code>-object with specified optimization arguments.
If more things need to be changed use <code>delay_model</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'incubate_fit'
update(object, optim_args, verbose = 0, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="update.incubate_fit_+3A_object">object</code></td>
<td>
<p><code>incubate_fit</code>-object</p>
</td></tr>
<tr><td><code id="update.incubate_fit_+3A_optim_args">optim_args</code></td>
<td>
<p>optimization arguments</p>
</td></tr>
<tr><td><code id="update.incubate_fit_+3A_verbose">verbose</code></td>
<td>
<p>integer flag. Requested verbosity during <code>delay_fit</code></p>
</td></tr>
<tr><td><code id="update.incubate_fit_+3A_...">...</code></td>
<td>
<p>further arguments, currently not used.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The updated fitted object of class <code>incubate_fit</code>
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
