<!DOCTYPE html><html lang="en"><head><title>Help for package scpoisson</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {scpoisson}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#scpoisson-package'><p>scpoisson: Single Cell Poisson Probability Paradigm</p></a></li>
<li><a href='#adj_CDF_logit'><p>A novel data representation based on Poisson probability</p></a></li>
<li><a href='#clust_clean'><p>Cluster label clean</p></a></li>
<li><a href='#cluster_size'><p>Cluster size</p></a></li>
<li><a href='#diff_gene_list'><p>Differential expression analysis</p></a></li>
<li><a href='#fwer_cutoff-generic'><p>return Family-Wise Error Rate (FWER) cutoffs</p></a></li>
<li><a href='#fwer_cutoff-matrix'><p>get FWER from idx_hc attribute of shc object</p></a></li>
<li><a href='#fwer_cutoff-shc'><p>get FWER cutoffs for shc object</p></a></li>
<li><a href='#get_example_data'><p>get example data</p></a></li>
<li><a href='#HclustDepart'><p>Cluster cells in a recursive way</p></a></li>
<li><a href='#interpolate'><p>Linear interpolation for one sample given reference sample</p></a></li>
<li><a href='#logit'><p>Logit transformation</p></a></li>
<li><a href='#LouvainDepart'><p>Louvain clustering using departure as data representation</p></a></li>
<li><a href='#nboot_small'><p>Random sample generation function to generate sets of samples from theoretical Poisson distribution.</p></a></li>
<li><a href='#new_quantile'><p>A more &quot;continuous&quot; approximation of quantiles of samples with a few integer case</p></a></li>
<li><a href='#new_quantile_pois'><p>A more &quot;continuous&quot; approximation of quantiles from the theoretical Poisson distribution.</p></a></li>
<li><a href='#para_est_new'><p>Parameter estimates based on two-way approximation</p></a></li>
<li><a href='#qq_interpolation'><p>Paired quantile after interpolation between two samples</p></a></li>
<li><a href='#qqplot_env_pois'><p>Q-Q plot comparing samples with a theoretical Poisson distribution</p></a></li>
<li><a href='#qqplot_small_test'><p>Q-Q plot comparing two samples with small discrete counts</p></a></li>
<li><a href='#scppp'><p>Generate New scppp object</p></a></li>
<li><a href='#sigp'><p>Significance for first split using sigclust2</p></a></li>
<li><a href='#theme_dirk'><p>Dirk theme ggplots</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Title:</td>
<td>Single Cell Poisson Probability Paradigm</td>
</tr>
<tr>
<td>Version:</td>
<td>0.0.1</td>
</tr>
<tr>
<td>Description:</td>
<td>Useful to visualize the Poissoneity (an independent Poisson statistical framework, 
  where each RNA measurement for each cell comes from its own independent Poisson distribution) of 
  Unique Molecular Identifier (UMI) based single cell RNA sequencing (scRNA-seq) data, and explore 
  cell clustering based on model departure as a novel data representation. </td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://opensource.org/licenses/mit-license.php">MIT</a> + file LICENSE</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.1</td>
</tr>
<tr>
<td>Suggests:</td>
<td>renv, testthat (&ge; 3.0.0), vdiffr, rmarkdown, knitr, qpdf</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>Config/testthat/edition:</td>
<td>3</td>
</tr>
<tr>
<td>Imports:</td>
<td>ggplot2, glmpca, Seurat, magrittr, dplyr, tidyr, purrr,
Matrix, Rdpack, SeuratObject, WGCNA, broom, stats, methods,
matrixStats</td>
</tr>
<tr>
<td>RdMacros:</td>
<td>Rdpack</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 2.10)</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2022-08-15 18:12:26 UTC; yue</td>
</tr>
<tr>
<td>Author:</td>
<td>Yue Pan [aut, cre],
  Justin Landis <a href="https://orcid.org/0000-0001-5501-4934"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut],
  Dirk Dittmer [aut],
  James S. Marron [aut],
  Di Wu [aut]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Yue Pan &lt;yuep027@gmail.com&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2022-08-17 06:50:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='scpoisson-package'>scpoisson: Single Cell Poisson Probability Paradigm</h2><span id='topic+scpoisson'></span><span id='topic+scpoisson-package'></span>

<h3>Description</h3>

<p>Useful to visualize the Poissoneity (an independent Poisson statistical framework, where each RNA measurement for each cell comes from its own independent Poisson distribution) of Unique Molecular Identifier (UMI) based single cell RNA sequencing (scRNA-seq) data, and explore cell clustering based on model departure as a novel data representation.
</p>


<h3>Author(s)</h3>

<p><strong>Maintainer</strong>: Yue Pan <a href="mailto:yuep027@gmail.com">yuep027@gmail.com</a>
</p>
<p>Authors:
</p>

<ul>
<li><p> Justin Landis <a href="mailto:jtlandis314@gmail.com">jtlandis314@gmail.com</a> (<a href="https://orcid.org/0000-0001-5501-4934">ORCID</a>)
</p>
</li>
<li><p> Dirk Dittmer <a href="mailto:dirk_dittmer@med.unc.edu">dirk_dittmer@med.unc.edu</a>
</p>
</li>
<li><p> James S. Marron <a href="mailto:marron@unc.edu">marron@unc.edu</a>
</p>
</li>
<li><p> Di Wu <a href="mailto:did@email.unc.edu">did@email.unc.edu</a>
</p>
</li></ul>


<hr>
<h2 id='adj_CDF_logit'>A novel data representation based on Poisson probability</h2><span id='topic+adj_CDF_logit'></span>

<h3>Description</h3>

<p>This function returns a matrix of a novel data representation with the same dimension as input data matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>adj_CDF_logit(data, change = 1e-10, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="adj_CDF_logit_+3A_data">data</code></td>
<td>
<p>A UMI count data matrix with genes as rows and cells as columns or an S3 object for class 'scppp'.</p>
</td></tr>
<tr><td><code id="adj_CDF_logit_+3A_change">change</code></td>
<td>
<p>A numeric value used to correct for exactly 0 and 1 before logit transformation.
Any values below <code>change</code> are set to be <code>change</code> and
any values above <code class="reqn">1- change</code> are set to be <code class="reqn">1- change</code>.</p>
</td></tr>
<tr><td><code id="adj_CDF_logit_+3A_...">...</code></td>
<td>
<p>not used.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This is a function used to calculate model departure as a novel data representation.
</p>


<h3>Value</h3>

<p>A matrix of departure as a novel data representation (matrix as input) or an S3 object for class 'scppp' (scppp object as input; departure result will be stored in object scppp under &quot;representation&quot;).
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Matrix as input
test_set &lt;- matrix(rpois(500, 0.5), nrow = 10)
adj_CDF_logit(test_set)
# scppp object as input
adj_CDF_logit(scppp(test_set))

</code></pre>

<hr>
<h2 id='clust_clean'>Cluster label clean</h2><span id='topic+clust_clean'></span>

<h3>Description</h3>

<p>This function removes unwanted characters from cluster label string
</p>


<h3>Usage</h3>

<pre><code class='language-R'>clust_clean(clust)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="clust_clean_+3A_clust">clust</code></td>
<td>
<p>a string indicates cluster label at each split step</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The clust_clean function removes any &quot;-&quot; or &quot;NA&quot; at the end of a string for a given cluster label
</p>


<h3>Value</h3>

<p>a string with unwanted characters removed
</p>

<hr>
<h2 id='cluster_size'>Cluster size</h2><span id='topic+cluster_size'></span>

<h3>Description</h3>

<p>This function calculates the number of elements in current cluster
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cluster_size(test_dat)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="cluster_size_+3A_test_dat">test_dat</code></td>
<td>
<p>a matrix or data frame with cells to cluster as rows</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a numeric value with number of cells to cluster
</p>

<hr>
<h2 id='diff_gene_list'>Differential expression analysis</h2><span id='topic+diff_gene_list'></span>

<h3>Description</h3>

<p>This function returns a data frame with differential expression analysis results.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>diff_gene_list(
  data,
  final_clust_res = NULL,
  clust1 = "1",
  clust2 = "2",
  t_test = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="diff_gene_list_+3A_data">data</code></td>
<td>
<p>A departure matrix generated from adj_CDF_logit() or an S3 object for class 'scppp'.</p>
</td></tr>
<tr><td><code id="diff_gene_list_+3A_final_clust_res">final_clust_res</code></td>
<td>
<p>A data frame with clustering results generated from HclustDepart(). It contains two columns: names (cell names) and clusters (cluster label).</p>
</td></tr>
<tr><td><code id="diff_gene_list_+3A_clust1">clust1</code></td>
<td>
<p>One of the cluster label used to make comparison, default &quot;1&quot;.</p>
</td></tr>
<tr><td><code id="diff_gene_list_+3A_clust2">clust2</code></td>
<td>
<p>The other cluster label used to make comparison, default &quot;2&quot;.</p>
</td></tr>
<tr><td><code id="diff_gene_list_+3A_t_test">t_test</code></td>
<td>
<p>A logical value indicating whether the t-test should be used to make comparison. In general, for large cluster (<code class="reqn">n \ge 30</code>), the t-test should be used. Otherwise, the Wilcoxon test might be more appropriate.</p>
</td></tr>
<tr><td><code id="diff_gene_list_+3A_...">...</code></td>
<td>
<p>not used.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This is a function used to find deferentially expressed genes between two clusters.
</p>


<h3>Value</h3>

<p>A data frame contains genes (ranked by decreasing order of mean difference), and associated statistics (p-values, FDR adjusted p-values, etc.).
If the input is an S3 object for class 'scppp', differential expression analysis results will be stored in object scppp under &quot;de_results&quot;.
</p>

<hr>
<h2 id='fwer_cutoff-generic'>return Family-Wise Error Rate (FWER) cutoffs</h2><span id='topic+fwer_cutoff-generic'></span><span id='topic+fwer_cutoff'></span>

<h3>Description</h3>

<p>return Family-Wise Error Rate (FWER) cutoffs
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fwer_cutoff(obj, ...)
</code></pre>

<hr>
<h2 id='fwer_cutoff-matrix'>get FWER from idx_hc attribute of shc object</h2><span id='topic+fwer_cutoff-matrix'></span><span id='topic+fwer_cutoff.matrix'></span>

<h3>Description</h3>

<p>get FWER from idx_hc attribute of shc object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'matrix'
fwer_cutoff(obj, alpha, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="fwer_cutoff-matrix_+3A_obj">obj</code></td>
<td>
<p><code>shc</code> object</p>
</td></tr>
<tr><td><code id="fwer_cutoff-matrix_+3A_alpha">alpha</code></td>
<td>
<p>numeric value specifying level</p>
</td></tr>
<tr><td><code id="fwer_cutoff-matrix_+3A_...">...</code></td>
<td>
<p>other parameters to be used by the function</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Patrick Kimes
</p>

<hr>
<h2 id='fwer_cutoff-shc'>get FWER cutoffs for shc object</h2><span id='topic+fwer_cutoff-shc'></span><span id='topic+fwer_cutoff.shc'></span>

<h3>Description</h3>

<p>get FWER cutoffs for shc object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'shc'
fwer_cutoff(obj, alpha, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="fwer_cutoff-shc_+3A_obj">obj</code></td>
<td>
<p><code>shc</code> object</p>
</td></tr>
<tr><td><code id="fwer_cutoff-shc_+3A_alpha">alpha</code></td>
<td>
<p>numeric value specifying level</p>
</td></tr>
<tr><td><code id="fwer_cutoff-shc_+3A_...">...</code></td>
<td>
<p>other parameters to be used by the function</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Patrick Kimes
</p>

<hr>
<h2 id='get_example_data'>get example data</h2><span id='topic+get_example_data'></span>

<h3>Description</h3>

<p>get example data
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_example_data(x = c("p5", "p56"))
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="get_example_data_+3A_x">x</code></td>
<td>
<p>data set to choose</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data set from example data
</p>

<hr>
<h2 id='HclustDepart'>Cluster cells in a recursive way</h2><span id='topic+HclustDepart'></span>

<h3>Description</h3>

<p>This function returns a list with clustering results.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>HclustDepart(data, maxSplit = 10, minSize = 10, sim = 100, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="HclustDepart_+3A_data">data</code></td>
<td>
<p>A UMI count matrix with genes as rows and cells as columns or an S3 object for class 'scppp'.</p>
</td></tr>
<tr><td><code id="HclustDepart_+3A_maxsplit">maxSplit</code></td>
<td>
<p>A numeric value specifying the maximum allowable number of splitting steps (default 10).</p>
</td></tr>
<tr><td><code id="HclustDepart_+3A_minsize">minSize</code></td>
<td>
<p>A numeric value specifying the minimal allowable cluster size (the number of cells for the smallest cluster, default 10).</p>
</td></tr>
<tr><td><code id="HclustDepart_+3A_sim">sim</code></td>
<td>
<p>A numeric value specifying the number of simulations during the Monte Carlo simulation procedure for statistical significance test, i.e. n_sim argument when apply sigclust2 (default = 100).</p>
</td></tr>
<tr><td><code id="HclustDepart_+3A_...">...</code></td>
<td>
<p>not used.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This is a function used to get cell clustering results in a recursive way.
At each step, the two-way approximation is re-calculated again within each subcluster,
and the potential for further splitting is calculated using sigclust2.
A non significant result suggests cells are reasonably homogeneous
and may come from the same cell type. In addition, to avoid over splitting,
the maximum allowable number of splitting steps <code>maxSplit</code>
(default is 10, which leads to at most <code class="reqn">2^{10} = 1024</code> total number of clusters) and
minimal allowable cluster size <code>minSize</code>
(the number of cells in a cluster allowed for further splitting, default is 10)
may be set beforehand.
Thus the process is stopped when any of the conditions
is satisfied: (1) the split is no longer statistically significant;
(2) the maximum allowable number of splitting steps is reached;
(3) any current cluster has less than 10 cells.
</p>


<h3>Value</h3>

<p>A list with the following elements:
</p>

<ul>
<li><p><code>res2</code>: a data frame contains two columns: names (cell names) and clusters (cluster label)
</p>
</li>
<li><p><code>sigclust_p</code>: a matrix with cells to cluster as rows, split index as columns,
the entry in row <code>i</code> and column <code>j</code> denoting the p-value
for the cell <code>i</code> at split step <code>j</code>
</p>
</li>
<li><p><code>sigclust_z</code>: a matrix with cells to cluster as rows, split index as columns,
the entry in row <code>i</code> and column <code>j</code> denoting the z-score
for the cell <code>i</code> at split step <code>j</code>
</p>
</li></ul>

<p>If the input is an S3 object for class 'scppp', clustering result will be stored in object scppp under &quot;clust_results&quot;.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
test_set &lt;- matrix(rpois(500, 0.5), nrow = 10)
HclustDepart(test_set)

</code></pre>

<hr>
<h2 id='interpolate'>Linear interpolation for one sample given reference sample</h2><span id='topic+interpolate'></span>

<h3>Description</h3>

<p>This function returns a data frame with interpolated data points.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>interpolate(df, reference, sample_id)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="interpolate_+3A_df">df</code></td>
<td>
<p>The object data frame requires interpolation.</p>
</td></tr>
<tr><td><code id="interpolate_+3A_reference">reference</code></td>
<td>
<p>The reference data frame to make comparison.</p>
</td></tr>
<tr><td><code id="interpolate_+3A_sample_id">sample_id</code></td>
<td>
<p>A character to denote the object data frame.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This is a function developed to do linear interpolation for corresponding probability
from empirical cumulative distribution function (CDF) and corresponding quantiles.
Given a reference data frame and a data frame needed to do interpolation,
if there are any CDF values in reference but not in object data frame,
do the linear interpolation and insert both CDF values and respective quantiles
to the original object data frame.
</p>


<h3>Value</h3>

<p>A data frame contains CDF, the sample name, and the corresponding quantiles.
</p>

<hr>
<h2 id='logit'>Logit transformation</h2><span id='topic+logit'></span>

<h3>Description</h3>

<p>This function applies logit transformation for a given probability
</p>


<h3>Usage</h3>

<pre><code class='language-R'>logit(p)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="logit_+3A_p">p</code></td>
<td>
<p>a numeric value of probability, ranges between 0 and 1, exactly 0 and 1 not allowed</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The logit function transforms a probability within the range of 0 and 1 to the real line
</p>


<h3>Value</h3>

<p>a numeric value transformed to the real line
</p>

<hr>
<h2 id='LouvainDepart'>Louvain clustering using departure as data representation</h2><span id='topic+LouvainDepart'></span>

<h3>Description</h3>

<p>This function returns a list with elements useful to check and compare cell clustering.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>LouvainDepart(
  data,
  pdat = NULL,
  PCA = TRUE,
  N = 15,
  pres = 0.8,
  tsne = FALSE,
  umap = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="LouvainDepart_+3A_data">data</code></td>
<td>
<p>A UMI count matrix with genes as rows and cells as columns or an S3 object for class 'scppp'.</p>
</td></tr>
<tr><td><code id="LouvainDepart_+3A_pdat">pdat</code></td>
<td>
<p>A matrix used as input for cell clustering. If not specify, the departure matrix will be calculated within the function.</p>
</td></tr>
<tr><td><code id="LouvainDepart_+3A_pca">PCA</code></td>
<td>
<p>A logic value specifying whether apply PCA before Louvain clustering, default is <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="LouvainDepart_+3A_n">N</code></td>
<td>
<p>A numeric value specifying the number of principal components included for further clustering (default 15).</p>
</td></tr>
<tr><td><code id="LouvainDepart_+3A_pres">pres</code></td>
<td>
<p>A numeric value specifying the resolution parameter in Louvain clustering (default 0.8)</p>
</td></tr>
<tr><td><code id="LouvainDepart_+3A_tsne">tsne</code></td>
<td>
<p>A logic value specifying whether t-SNE dimension reduction should be applied for visualization.</p>
</td></tr>
<tr><td><code id="LouvainDepart_+3A_umap">umap</code></td>
<td>
<p>A logic value specifying whether UMAP dimension reduction should be applied for visualization.</p>
</td></tr>
<tr><td><code id="LouvainDepart_+3A_...">...</code></td>
<td>
<p>not used.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This is a function used to get cell clustering using Louvain clustering algorithm implemented in the Seurat package.
</p>


<h3>Value</h3>

<p>A list with the following elements:
</p>

<ul>
<li><p><code>sdata</code>: a Seurat object
</p>
</li>
<li><p><code>tsne_data</code>: a matrix containing t-SNE dimension reduction results,
with cells as rows, and first two t-SNE dimensions as columns; NULL if <code>tsne = FALSE</code>.
</p>
</li>
<li><p><code>umap_data</code>: a matrix containing UMAP dimension reduction results,
with cells as rows, and first two UMAP dimensions as columns; NULL if <code>tsne = FALSE</code>.
</p>
</li>
<li><p><code>res_clust</code>: a data frame contains two columns: names (cell names) and clusters (cluster label)
</p>
</li></ul>



<h3>References</h3>

<p>Stuart T, Butler A, Hoffman P, Hafemeister C, Papalexi E, Mauck III WM, Hao Y, Stoeckius M, Smibert P, Satija R (2019).
&ldquo;Comprehensive Integration of Single-Cell Data.&rdquo;
<em>Cell</em>, <b>177</b>, 1888-1902.
<a href="https://doi.org/10.1016/j.cell.2019.05.031">doi:10.1016/j.cell.2019.05.031</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
set.seed(1234)
test_set &lt;- matrix(rpois(500, 2), nrow = 20)
rownames(test_set) &lt;- paste0("gene", 1:nrow(test_set))
colnames(test_set) &lt;- paste0("cell", 1:ncol(test_set))
LouvainDepart(test_set)

</code></pre>

<hr>
<h2 id='nboot_small'>Random sample generation function to generate sets of samples from theoretical Poisson distribution.</h2><span id='topic+nboot_small'></span>

<h3>Description</h3>

<p>This function returns a data frame with generated sets of samples and simulation index.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>nboot_small(x, lambda, R)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="nboot_small_+3A_x">x</code></td>
<td>
<p>a numeric vector of sampled data points to compare with theoretical Poisson.</p>
</td></tr>
<tr><td><code id="nboot_small_+3A_lambda">lambda</code></td>
<td>
<p>a numeric value for mean of theoretical Poisson.</p>
</td></tr>
<tr><td><code id="nboot_small_+3A_r">R</code></td>
<td>
<p>a numeric value for mean of theoretical Poisson.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This is a function used to simulate a given number sets of samples from a theoretical Poisson distribution
that match input samples on sample size and sample mean (or theoretical Poisson parameter).
Plotting these as envelopes in Q-Q plot shows the variability in shapes we can expect when
sampling from the theoretical Poisson distribution.
</p>


<h3>Value</h3>

<p>A data frame contains simulated data and corresponding simulation index.
Random sample generation function to generate sets of samples from theoretical Poisson distribution.
</p>
<p>nboot_small returns a data frame with generate sets of samples and simulation index.
</p>
<p>This is a function used to simulate a given number sets of samples from a theoretical Poisson distribution
that match input samples on sample size and sample mean (or theoretical Poisson parameter).
Plotting these as envelopes in Q-Q plot shows the variability in shapes we can expect when
sampling from the theoretical Poisson distribution.
</p>
<p>a numeric vector of number of simulation sets that match input samples on sample size
and sample mean (or theoretical Poisson parameter).
</p>

<hr>
<h2 id='new_quantile'>A more &quot;continuous&quot; approximation of quantiles of samples with a few integer case</h2><span id='topic+new_quantile'></span>

<h3>Description</h3>

<p>This function returns a data frame including data points and corresponding quantile.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>new_quantile(data, sample)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="new_quantile_+3A_data">data</code></td>
<td>
<p>A numeric vector of sampled data points.</p>
</td></tr>
<tr><td><code id="new_quantile_+3A_sample">sample</code></td>
<td>
<p>A character string denotes which sample data points come from.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This is a function developed to get quantile for samples with only a few integer values.
Define both <code class="reqn">p_{-1} = 0</code> and <code class="reqn">q_{-1} = 0</code>.
Replace the point mass at each integer <code class="reqn">z</code> by a bar on the interval <code class="reqn">[z â€“ \frac{1}{2}, z+ \frac{1}{2}]</code>
with height <code class="reqn">P(X = z)</code>. This is a more &quot;continuous&quot; approximation of quantiles in this case.
</p>


<h3>Value</h3>

<p>A data frame contains the corresponding probability from cumulative distribution function (CDF), sample name, and corresponding respective quantiles.
</p>

<hr>
<h2 id='new_quantile_pois'>A more &quot;continuous&quot; approximation of quantiles from the theoretical Poisson distribution.</h2><span id='topic+new_quantile_pois'></span>

<h3>Description</h3>

<p>This function returns a data frame including the probability
from cumulative distribution function (CDF) and corresponding quantiles.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>new_quantile_pois(data, lambda)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="new_quantile_pois_+3A_data">data</code></td>
<td>
<p>A numeric vector of sampled data points to compare with theoretical Poisson.</p>
</td></tr>
<tr><td><code id="new_quantile_pois_+3A_lambda">lambda</code></td>
<td>
<p>A numeric value for theoretical Poisson distribution parameter (equal to mean).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This is a function developed to get corresponding quantiles from theoretical Poisson distribution.
The data points ranges from 0 to maximum value of sampled data used to compare with the theoretical Poisson distribution.
</p>


<h3>Value</h3>

<p>A data frame contains CDF probability and corresponding quantiles from the theoretical Poisson distribution.
</p>

<hr>
<h2 id='para_est_new'>Parameter estimates based on two-way approximation</h2><span id='topic+para_est_new'></span>

<h3>Description</h3>

<p>This function returns a vector consists of parameter estimates for overall offset,
cell effect, and gene effect.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>para_est_new(test_set)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="para_est_new_+3A_test_set">test_set</code></td>
<td>
<p>A UMI count data matrix with genes as rows and cells as columns</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This is a function used to calculate parameter estimates based on
<code class="reqn">\lambda_{gc}  = e^{\mu + \alpha_g + \beta_c}</code>,
where <code class="reqn">\mu</code> is the overall offset,
<code class="reqn">\alpha</code> is a vector with the same length as the number of genes,
and <code class="reqn">\beta</code> is a vector with the same length as the number of cells.
The order of elements in vectors <code class="reqn">\alpha</code> or <code class="reqn">\beta</code> is the same as rows (genes) or
cells (columns) from input data. Be sure to remove cells/genes with all zeros.
</p>


<h3>Value</h3>

<p>A numeric vector containing parameter estimates from overall offset (first element), gene effect (same order as rows) and cell effect (same order as columns).
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Matrix as input
test_set &lt;- matrix(rpois(500, 0.5), nrow = 10)
para_est_new(test_set)

</code></pre>

<hr>
<h2 id='qq_interpolation'>Paired quantile after interpolation between two samples</h2><span id='topic+qq_interpolation'></span>

<h3>Description</h3>

<p>This function returns a data frame with paired quantiles in two samples after interpolation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>qq_interpolation(dfp, dfq, sample1, sample2)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="qq_interpolation_+3A_dfp">dfp</code></td>
<td>
<p>A data frame generated from function new_quantile() based on a specific distribution.</p>
</td></tr>
<tr><td><code id="qq_interpolation_+3A_dfq">dfq</code></td>
<td>
<p>Another data frame generated from function new_quantile() based on a specific distribution.</p>
</td></tr>
<tr><td><code id="qq_interpolation_+3A_sample1">sample1</code></td>
<td>
<p>A character to denote sample name of distribution used to generate <code>dfp</code>.</p>
</td></tr>
<tr><td><code id="qq_interpolation_+3A_sample2">sample2</code></td>
<td>
<p>A character to denote sample name of distribution used to generate <code>dfq</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This is a function for quantile interpolation of two samples.
For each unique quantile value that has original data
point in one sample but no corresponding original data point in another sample,
apply a linear interpolation. So the common quantile values after interpolation
should have unique points the same as unique quantile points from either sample.
</p>


<h3>Value</h3>

<p>A data frame contains corresponding probability from cumulative distribution function (CDF),
corresponding quantiles from the first sample (<code>dfp</code>),
and corresponding quantiles from the second sample (<code>dfq</code>).
</p>

<hr>
<h2 id='qqplot_env_pois'>Q-Q plot comparing samples with a theoretical Poisson distribution</h2><span id='topic+qqplot_env_pois'></span>

<h3>Description</h3>

<p>This function returns a Q-Q plot with envelope using a more &quot;continuous&quot; approximation of quantiles.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>qqplot_env_pois(sample_data, lambda, envelope_size = 100, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="qqplot_env_pois_+3A_sample_data">sample_data</code></td>
<td>
<p>A numeric vector of sample data points or an S3 object for class 'scppp'.</p>
</td></tr>
<tr><td><code id="qqplot_env_pois_+3A_lambda">lambda</code></td>
<td>
<p>A numeric value specifying the theoretical Poisson parameter.</p>
</td></tr>
<tr><td><code id="qqplot_env_pois_+3A_envelope_size">envelope_size</code></td>
<td>
<p>A numeric value specifying the size of envelope on Q-Q plot (default 100).</p>
</td></tr>
<tr><td><code id="qqplot_env_pois_+3A_...">...</code></td>
<td>
<p>not used.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This is a function for Q-Q envelope plot used to compare whether given sample data points come from the
theoretical Poisson distribution.  By simulating repeated samples of the same size from the candidate
theoretical distribution, and overlaying the envelope on the same figure, it provides a feeling of
understanding the natural variation from the theoretical distribution.
</p>
<p>If an S3 object for class 'scppp' is used as input and the stored result under &quot;data&quot; is a matrix,
The GLM-PCA algorithm will be applied to estimate the Poisson parameter for each matrix entry.
Then a specific number of entries will be selected as sample data points to compare with the theoretical Poisson distribution.
</p>


<h3>Value</h3>

<p>A ggplot object.
</p>


<h3>References</h3>

<p>Townes FW, Street K (2020).
<em>glmpca: Dimension Reduction of Non-Normally Distributed Data</em>.
R package version 0.2.0, <a href="https://CRAN.R-project.org/package=glmpca">https://CRAN.R-project.org/package=glmpca</a>.
</p>

<hr>
<h2 id='qqplot_small_test'>Q-Q plot comparing two samples with small discrete counts</h2><span id='topic+qqplot_small_test'></span>

<h3>Description</h3>

<p>This function returns a ggplot object used to visualize quantiles comparing distributions of two samples.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>qqplot_small_test(P, Q, sample1, sample2)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="qqplot_small_test_+3A_p">P</code></td>
<td>
<p>A numeric vector from one sample.</p>
</td></tr>
<tr><td><code id="qqplot_small_test_+3A_q">Q</code></td>
<td>
<p>A numeric vector from the other sample.</p>
</td></tr>
<tr><td><code id="qqplot_small_test_+3A_sample1">sample1</code></td>
<td>
<p>A character to denote sample name of one distribution <code>P</code> generated from.</p>
</td></tr>
<tr><td><code id="qqplot_small_test_+3A_sample2">sample2</code></td>
<td>
<p>A character to denote sample name of the other distribution <code>Q</code> generated from.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This is a function for quantile-quantile plot comparing comparing samples from two discrete distributions
after <em>continuity correction</em> and linear interpolation
</p>


<h3>Value</h3>

<p>A ggplot object. Q-Q plot with continuity correction. Quantiles from one sample on the horizontal axis and corresponding quantiles
from the other sample on the vertical axis.
</p>

<hr>
<h2 id='scppp'>Generate New scppp object</h2><span id='topic+scppp'></span>

<h3>Description</h3>

<p>Define S3 class that stores scRNA-seq data and associated information
(e.g. model departure representation, cell clustering results) if
corresponding functions are called.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>scppp(data, sample = c("columns", "rows"))
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="scppp_+3A_data">data</code></td>
<td>
<p>input data - Usually a matrix of counts</p>
</td></tr>
<tr><td><code id="scppp_+3A_sample">sample</code></td>
<td>
<p>by rows or columns</p>
</td></tr>
</table>


<h3>Value</h3>

<p>S3 object for class 'scppp'.
</p>

<hr>
<h2 id='sigp'>Significance for first split using sigclust2</h2><span id='topic+sigp'></span>

<h3>Description</h3>

<p>This function returns a list with elements mainly generated from sigclust2.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sigp(test_dat, minSize = 10, sim = 100)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="sigp_+3A_test_dat">test_dat</code></td>
<td>
<p>A UMI count data matrix with samples to cluster as rows and features as columns.</p>
</td></tr>
<tr><td><code id="sigp_+3A_minsize">minSize</code></td>
<td>
<p>A numeric value specifying the minimal allowable cluster size (the number of cells for the smallest cluster, default 10).</p>
</td></tr>
<tr><td><code id="sigp_+3A_sim">sim</code></td>
<td>
<p>A numeric value specifying the number of simulations during the Monte Carlo simulation procedure (default 100).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This is a function used to calculate the significance level of the first split from hierarchical clustering
based on euclidean distance and Ward's linkage.
</p>


<h3>Value</h3>

<p>A list with the following elements:
</p>

<ul>
<li><p><code>p</code>: p-value for the first split
</p>
</li>
<li><p><code>z</code>: z-score for the first split
</p>
</li>
<li><p><code>shc_result</code>: a <code>shc</code> S3-object as defined in sigclust2 package
</p>
</li>
<li><p><code>clust2</code>: a vector with group index for each cell
</p>
</li>
<li><p><code>clust_dat</code>: a matrix of data representation used as input for hierarchical clustering
</p>
</li></ul>



<h3>References</h3>

<p>Kimes PK, Liu Y, Neil Hayes D, Marron JS (2017).
&ldquo;Statistical significance for hierarchical clustering.&rdquo;
<em>Biometrics</em>, <b>73</b>(3), 811&ndash;821.
Michael Linderman (2019).
<em>Rclusterpp: Linkable C++ Clustering</em>.
R package version 0.2.5, <a href="https://github.com/nolanlab/Rclusterpp">https://github.com/nolanlab/Rclusterpp</a>.
</p>

<hr>
<h2 id='theme_dirk'>Dirk theme ggplots</h2><span id='topic+theme_dirk'></span>

<h3>Description</h3>

<p>This function generates ggplot object with theme elements that Dirk appreciates on his ggplots
</p>


<h3>Usage</h3>

<pre><code class='language-R'>theme_dirk(
  base_size = 22,
  base_family = "",
  base_line_size = base_size/22,
  base_rect_size = base_size/22,
  time_stamp = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="theme_dirk_+3A_base_size">base_size</code></td>
<td>
<p>base font size, given in pts.</p>
</td></tr>
<tr><td><code id="theme_dirk_+3A_base_family">base_family</code></td>
<td>
<p>base font family</p>
</td></tr>
<tr><td><code id="theme_dirk_+3A_base_line_size">base_line_size</code></td>
<td>
<p>base size for line elements</p>
</td></tr>
<tr><td><code id="theme_dirk_+3A_base_rect_size">base_rect_size</code></td>
<td>
<p>base size for rect elements</p>
</td></tr>
<tr><td><code id="theme_dirk_+3A_time_stamp">time_stamp</code></td>
<td>
<p>Logical value to indicate if the current
time should be added as a caption to the plot. Helpful for
versioning of plots.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>list that can be added to a ggplot object
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
