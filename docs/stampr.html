<!DOCTYPE html><html><head><title>Help for package stampr</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {stampr}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#stampr-package'><p>stampr: Spatial Temporal Analysis of Moving Polygons</p></a></li>
<li><a href='#eyeshp'><p>Hurricane Katrina eye point dataset</p></a></li>
<li><a href='#fire1'><p>Forest Fire dataset</p></a></li>
<li><a href='#fire2'><p>Forest Fire dataset</p></a></li>
<li><a href='#glob.change'><p>glob.change</p></a></li>
<li><a href='#katrina'><p>Hurricane Katrina polygons dataset</p></a></li>
<li><a href='#mpb'><p>MPB dataset</p></a></li>
<li><a href='#stamp'><p>Spatial temporal analysis of moving polygons</p></a></li>
<li><a href='#stamp.direction'><p>Perform polygon directional analysis</p></a></li>
<li><a href='#stamp.distance'><p>stamp.distance</p></a></li>
<li><a href='#stamp.group.summary'><p>Compile stamp summary statistics by group</p></a></li>
<li><a href='#stamp.map'><p>Mapping (plotting) functionality for <code>stamp</code> output</p></a></li>
<li><a href='#stamp.multichange'><p>run stamp function for multiple years of polygons at once</p></a></li>
<li><a href='#stamp.stgroup.summary'><p>Compile stamp summary statistics by space-time group</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Spatial Temporal Analysis of Moving Polygons</td>
</tr>
<tr>
<td>Version:</td>
<td>0.3.1</td>
</tr>
<tr>
<td>Description:</td>
<td>Perform spatial temporal analysis of moving polygons; a
    longstanding analysis problem in Geographic Information Systems. Facilitates
    directional analysis, distance analysis, and some other simple functionality for
    examining spatial-temporal patterns of moving polygons.</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/jedalong/stampr">https://github.com/jedalong/stampr</a></td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 4.0)</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>Imports:</td>
<td>sf, spdep, dplyr, graphics, grDevices, rlang, lwgeom,
geosphere</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-01-09 16:19:51 UTC; jlong83</td>
</tr>
<tr>
<td>Author:</td>
<td>Jed Long <a href="https://orcid.org/0000-0002-2815-0399"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [aut,
    cre],
  Colin Robertson [aut]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Jed Long &lt;jed.long@uwo.ca&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-01-09 17:10:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='stampr-package'>stampr: Spatial Temporal Analysis of Moving Polygons</h2><span id='topic+stampr-package'></span>

<h3>Description</h3>

<p>The Package <code>stampr</code> provides tools for performing spatial temporal analysis of moving polygons.
These tools allow the calculation of directional relationships, distance relations, and other basic
functionality, such as global change metrics. More details about each of these functions
can be found in its help documentation.
</p>


<h3>Details</h3>

<p><code>stampr</code>'s functions utilize the <code>sf</code> objects (as of version 0.3.0) from the 
package <code>sf</code>. Polygon relationships are still understudied in the field of 
geographic information science, but hopefully <code>stampr</code> can provide users with a
platform for new developments and applied research looking at interesting geographical phenomena.
</p>


<h3>Author(s)</h3>

<p>Jed Long and Colin Robertson
</p>


<h3>References</h3>

<p>Robertson, C., Nelson, T., Boots, B., and Wulder, M. (2007) STAMP: Spatial-temporal analysis of moving polygons
<em>Journal of Geographical Systems</em>, 9:207-227.
Long, J., Robertson, C., Nelson, T. (2018) stampr: Spatial-Temporal Analysis of Moving Polygons in R <em>Journal of Statistical Software</em>. Code Snippets, 84(1), 1â€“19.
</p>

<hr>
<h2 id='eyeshp'>Hurricane Katrina eye point dataset</h2><span id='topic+eyeshp'></span>

<h3>Description</h3>

<p>A dataset containing points representing the eye of Hurricane Katrina centroid from 21:00 26-AUG-2005 to 
21:00 29-AUG-2005. Polygon contours were extracted from the US NOAA H*Wind product, downloadable from:
<a href="https://www.aoml.noaa.gov/hrd/data_sub/wind.html">https://www.aoml.noaa.gov/hrd/data_sub/wind.html</a>
</p>


<h3>Format</h3>

<p>A <code>sf</code> object with 33 records of the eye location of Hurricane Katrina, every 
3 hrs, from 21:00 25-AUG-2005 to 21:00 29-AUG-2005. The date and time of each polygon is recorded in the
column <code>DateTime</code>.
</p>


<h3>Details</h3>

<p>The <code>eyeshp</code> dataset contains points that were derived from the raw NOAA H*Wind data. The data is included here
to provide a point-data comparison to the data in the <code>katrina</code> dataset which is polygon data
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(eyeshp)
plot(eyeshp)
</code></pre>

<hr>
<h2 id='fire1'>Forest Fire dataset</h2><span id='topic+fire1'></span>

<h3>Description</h3>

<p>A dataset containing fake forest fire polygons representing the movement of the forest fire from T1 (fire1) to T2 (fire2). The data is provided purely for demonstration purposes.
</p>


<h3>Format</h3>

<p><code>fire1</code> &mdash; a <code>sf</code> object with polygons representing the location of forest fire.
</p>


<h3>Source</h3>

<p>Simulated data
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(fire1)
plot(fire1)

data(fire2)
plot(fire2)

## Not run: 
library(mapview)
mapview(fire1) + mapview(fire2)

## End(Not run)
</code></pre>

<hr>
<h2 id='fire2'>Forest Fire dataset</h2><span id='topic+fire2'></span>

<h3>Description</h3>

<p>see fire1
</p>


<h3>Format</h3>

<p><code>fire2</code> &mdash; a <code>sf</code> object
</p>

<hr>
<h2 id='glob.change'>glob.change</h2><span id='topic+glob.change'></span>

<h3>Description</h3>

<p>The function <code>glob.change</code> computes a set of three global change metrics for comparison
between two polygon sets. These metrics are outlined in Robertson et al. (2007; Table 4).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>glob.change(T1, T2)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="glob.change_+3A_t1">T1</code></td>
<td>
<p>a <code>sf</code> object of polygons from time 1.</p>
</td></tr>
<tr><td><code id="glob.change_+3A_t2">T2</code></td>
<td>
<p>a <code>sf</code> object of polygons from time 2.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>glob.change</code> computes three change metrics, detailed below, that can be used to quantify changes
between two polygon sets:
<br /><br />
<code>NumRatio</code> &ndash; ratio between the number of polygons in <code>T2</code> and <code>T1</code>;
</p>
<p style="text-align: center;"><code class="reqn">\mathtt{NumRatio} = \frac{\#(T1)}{\#(T2)}</code>
</p>

<p><br />
<code>AreaRatio</code> &ndash; ratio between the areas of polygons in T2 and T1;
</p>
<p style="text-align: center;"><code class="reqn">\mathtt{AreaRatio} = \frac{A(T2)}{A(T1)}</code>
</p>

<p><br />
<code>AvgAreaRatio</code> &ndash; ratio between the <code>AreaRatio</code> and <code>NumRatio</code>;
</p>
<p style="text-align: center;"><code class="reqn">\mathtt{AvgAreaRatio} = \frac{\mathtt{AreaRatio}}{\mathtt{NumRatio}} = \frac{\frac{A(T2)}{A(T1)}}{\frac{\#(T1)}{\#(T2)}}</code>
</p>



<h3>Value</h3>

<p>A <code>list</code> object with three elements - Results for the <code>NumRatio</code>, <code>AreaRatio</code>, and <code>AvgAreaRatio</code> metrics.
</p>

<hr>
<h2 id='katrina'>Hurricane Katrina polygons dataset</h2><span id='topic+katrina'></span>

<h3>Description</h3>

<p>A dataset containing polygons representing the movement of Hurricane Katrina from 21:00 26-AUG-2005 to 
21:00 29-AUG-2005. Polygon contours were extracted from the US NOAA H*Wind product, downloadable from:
<a href="https://www.aoml.noaa.gov/hrd/data_sub/wind.html">https://www.aoml.noaa.gov/hrd/data_sub/wind.html</a>
</p>


<h3>Format</h3>

<p>A <code>sf</code> object with 33 records of of the location of Hurricane Katrina, every 
3 hrs, from 21:00 25-AUG-2005 to 21:00 29-AUG-2005. The date and time of each polygon is recorded in the
column <code>DateTime</code>.
</p>


<h3>Details</h3>

<p>The <code>katrina</code> dataset contains polygons that were derived from the raw NOAA H*Wind data. The 39 mph isotach
(contour of equal wind speed) was used to delineate, as a spatial polygon, the extent of Hurricane Katrina 
at a given time. Polygons were derived at 3 hr intervals; which means there are 33 different time points in
the dataset.
</p>


<h3>Source</h3>

<p><a href="https://www.aoml.noaa.gov/hrd/data_sub/wind.html">https://www.aoml.noaa.gov/hrd/data_sub/wind.html</a>
</p>


<h3>References</h3>

<p>Powell, M.D., Murillo, S., Dodge, P., Uhlhorn, E., Gamache, J., Cardone, V., Cox, A., Otero, S., Carrasco, N., 
Annane, B., St. Fleur, R. (2010) Reconstruction of Hurricane Katrina's wind fields for storm surge and wave 
hindcasting. <em>Ocean Engineering</em>, 37, 26-36. <br /><br />
Powell, M.D., Houston, S.H. (1998) The HMD real-time hurricane wind analysis system. <em>Journal of Wind
Engineering and Industrial Aerodynamics</em>, 77/78, 53-64.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(katrina)
plot(katrina['Id'])
</code></pre>

<hr>
<h2 id='mpb'>MPB dataset</h2><span id='topic+mpb'></span>

<h3>Description</h3>

<p>A dataset containing polygons representing the location of mountain pine beetle hotspot polygons in Morice Forest District, British Columbia, Canada.
</p>


<h3>Format</h3>

<p><code>mpb</code> &mdash; a <code>sf</code> object with 711 mountain pine beetle hotspot polygons that occurred over eight years. The temporal indicator is the <code>TGROUP</code> column. Another variable <code>REGION</code> indicates whether the hotspot was in the northern or southern regions, which experienced mostly independent outbreaks.
</p>


<h3>Details</h3>

<p>These data were derived from helicopter-based GPS surveys during early years of large mountain pine beetle outbreak in Western Canada.
</p>


<h3>Source</h3>

<p>Data obtained from Trisalyn Nelson (ASU)
</p>


<h3>References</h3>

<p>Nelson TA, Boots B, Wulder MA, Carroll AL. Environmental characteristics of mountain pine beetle infestation hot spots. <em>Journal of Ecosystems and Management</em>. 2007 Mar 14;8(1).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(mpb)
plot(mpb['TGROUP'])
</code></pre>

<hr>
<h2 id='stamp'>Spatial temporal analysis of moving polygons</h2><span id='topic+stamp'></span>

<h3>Description</h3>

<p>This function generates a <code>sf</code> polygons object that can be used for spatial temporal analysis of moving polygons
as described in the paper Robertson et al. (2007).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>stamp(T1, T2, dc = 0, direction = FALSE, distance = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="stamp_+3A_t1">T1</code></td>
<td>
<p>a <code>sf</code> polygons object of polygons from time 1.</p>
</td></tr>
<tr><td><code id="stamp_+3A_t2">T2</code></td>
<td>
<p>a <code>sf</code> polygons object of polygons from time 2.</p>
</td></tr>
<tr><td><code id="stamp_+3A_dc">dc</code></td>
<td>
<p>spatial distance threshold for determining groupings (see <b>Details</b>) in appropriate units.</p>
</td></tr>
<tr><td><code id="stamp_+3A_direction">direction</code></td>
<td>
<p>logical, whether or not to perform directional analysis. See documentation for
<code>stamp.direction</code> for further details.</p>
</td></tr>
<tr><td><code id="stamp_+3A_distance">distance</code></td>
<td>
<p>logical, whether or not to perform distance analysis. See documentation for 
<code>stamp.distance</code> for further details.</p>
</td></tr>
<tr><td><code id="stamp_+3A_...">...</code></td>
<td>
<p>additional parameters to be passed to functions if <code>direction</code>, or <code>distance</code> are
set to <code>TRUE</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>stamp</code> function can be used to perform spatial temporal analysis of moving polygons (STAMP)
as outlined in the paper by Robertson et al., (2007). Polygon movement &quot;groups&quot; are delineated based on
polygon connectedness defined by the distance threshold <code>dc</code>. That is, if polygon
boundaries (in T1 or T2) are within distance <code>dc</code> of one another they will be designated
to the same group. STAMP events are reported at four levels of increasing complexity: <br />
LEV1 &ndash; disappearance (<code>DISA</code>), stable (<code>STBL</code>), and generation (<code>GENA</code>); <br />
LEV2 &ndash; disappearance (<code>DISA</code>), contraction (<code>CONT</code>), stable (<code>STBL</code>),
expansion (<code>EXPN</code>), and generation (<code>GENR</code>); <br />
LEV3 &ndash; disappearance (<code>DISA</code>), T1 displacement (<code>DISP1</code>), convergence (<code>CONV</code>),
concentration (<code>CONC</code>), contraction (<code>CONT</code>), stable (<code>STBL</code>),
expansion (<code>EXP</code>), fragmentation (<code>FRAG</code>), divergence (<code>DIV</code>),
T2 displacement (<code>DISP2</code>), and generation (<code>GENR</code>); <br />
LEV4 &ndash; LEV4 is different from other levels. It is used to identify those groups where
union (<code>UNION</code>), division (<code>DIVISION</code>), and both union and division
(<code>BOTH</code>) events occur. These events occur when there are more than one
stable event in a group. Groups with one or no stable events receive an <code>NA</code>
value for LEV4. <br />
See Robertson et al. (2007; especially Figure 1) for complete descriptions of all STAMP movement
event types.
</p>
<p>Note also that there must be a unique ID of each polygon, the function uses the row.names of the polygon objects. Modify the row.names accordingly if you wish to use an alternative ID label.
</p>


<h3>Value</h3>

<p>This function returns a <code>sf</code> polygons object with the following data columns:
</p>
<table>
<tr><td><code>ID1</code></td>
<td>
<p>Polygon ID from T1 polygons; <code>NA</code> if it did not exist,</p>
</td></tr>
<tr><td><code>ID2</code></td>
<td>
<p>Polygon ID from T2 polygons; <code>NA</code> if it did not exist,</p>
</td></tr>
<tr><td><code>LEV1</code></td>
<td>
<p>Level 1 STAMP designation,</p>
</td></tr>
<tr><td><code>LEV2</code></td>
<td>
<p>Level 2 STAMP designation,</p>
</td></tr>
<tr><td><code>LEV3</code></td>
<td>
<p>Level 3 STAMP designation,</p>
</td></tr>
<tr><td><code>LEV4</code></td>
<td>
<p>Level 4 STAMP designation,</p>
</td></tr>
<tr><td><code>GROUP</code></td>
<td>
<p>Group ID signifying group membership,</p>
</td></tr>
<tr><td><code>AREA</code></td>
<td>
<p>Polygon area in appropriate areal units,</p>
</td></tr>
<tr><td><code>--</code></td>
<td>
<p>(optional) Additional columns from directional analysis if <code>direction = TRUE</code>,</p>
</td></tr>
<tr><td><code>--</code></td>
<td>
<p>(optional) Additional columns from distance analysis if <code>distance = TRUE</code>,</p>
</td></tr>
</table>


<h3>References</h3>

<p>Robertson, C., Nelson, T., Boots, B., and Wulder, M. (2007) STAMP: Spatial-temporal analysis of moving polygons.
<em>Journal of Geographical Systems</em>, 9:207-227.
</p>


<h3>See Also</h3>

<p>stamp.direction stamp.distance stamp.map stamp.group.summary
</p>

<hr>
<h2 id='stamp.direction'>Perform polygon directional analysis</h2><span id='topic+stamp.direction'></span>

<h3>Description</h3>

<p><code>stamp.direction</code> facilitates polygon directional analysis using a variety of methods.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>stamp.direction(stmp, dir.mode = "CentroidAngle", ndir = 4, group = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="stamp.direction_+3A_stmp">stmp</code></td>
<td>
<p>a <code>sf</code> object generated from the <code>stamp</code> function.</p>
</td></tr>
<tr><td><code id="stamp.direction_+3A_dir.mode">dir.mode</code></td>
<td>
<p>a character item identifying which directional relations method is to be used. See <b>Details</b>
for information on each individual method.</p>
</td></tr>
<tr><td><code id="stamp.direction_+3A_ndir">ndir</code></td>
<td>
<p>(optional) parameter identifying the number of directions to be computed. See individual method
<b>Details</b> for appropriate usage.</p>
</td></tr>
<tr><td><code id="stamp.direction_+3A_group">group</code></td>
<td>
<p>(optional) a logical value identifying whether direction should be computed on groups or individual
event polygons (only used with <code>CentroidAngle</code> method).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>stamp.direction</code> function can be used to facilitate directional analysis on output
<code>stamp.obj</code> objects from function <code>stamp</code>. Currently, four directional analysis methods
are available:  
</p>

<ul>
<li> <p><code>"CentroidAngle"</code> &ndash; The centroid angle is simply the angle between the centroids of two polygons.
The centroid angle method is computed on STAMP objects by first grouping all T1 polygons (by STAMP group)
and computing their centroid. Then, the angle from each T1 group centroid, to the centroid of each STAMP event
within the group is calculated. Centroid angles are recorded in degrees, with North having a value of 0, East
90, and so on. <code>"CentroidAngle"</code> ignores the <code>ndir</code> parameter.
</p>
</li>
<li> <p><code>"ConeModel"</code> &ndash; The cone model method calculates areas of STAMP event polygons within cones radiating from
the centroid of the origin polygon.  The cone model method first computes the centroid of all T1 polygons in a STAMP grouping. It then
computes <code>ndir</code> equally spaced cones radiating outward from the T1 centroid. The first cone is always
centered on North, but there can be any number of cones. The area of each STAMP event, in each cone (specifying direction),
is then calculated. See Peuquet and Zhang (1987) for more detailed information
</p>
</li>
<li> <p><code>"MBRModel"</code> &ndash;   The minimum bounding rectangle (MBR) method first computes the MBR for all T1 events
in a STAMP grouping. Then the lines of four edges of the MBR are extended outwards to infinity creating
sections for the eight cardinal directions around the MBR, along with the MBR itself. The area
of each stamp event within each of the nine sections is then computed. See Skiadopoulos et al. (2005) for
more detailed information. <code>"MBRModel"</code> ignores the <code>ndir</code> parameter.
</p>
</li>
<li> <p><code>"ModConeModel"</code> &ndash; The modified cone model first computes the centroid of the T1 events.
Then <code>ndir = 4 or 8</code> cones are created outward from this centroid to the minimum bounding rectangle
of the entire grouping. As described by Robertson et al. (2007) this approach is more accommodating
to polygon groups that are irregular in size or shape. The modified cone model method first computes the centroid of all T1 polygons in a STAMP grouping.
It then computes the bounding box of ALL events in a STAMP grouping. Then, <code>ndir=4</code> or <code>8</code>
cones are computed. In the case of <code>ndir=4</code>, cones radiate from the T1 centroid to the four
corners of the bounding box. The result of the modified cone model method is that the cones
are not equally spaced, but tailored to the individual STAMP groupings shape. See Robertson et al.
(2007) for more detailed information. NOTE: This function has been altered slightly as of stampr v 0.3.
</p>
</li></ul>

<p>As of V 0.3 all operations are conducted using sf object classes, all directional (azimuth) and area calculations use WGS84.
</p>


<h3>Value</h3>

<p>Appends the input <code>stamp</code> object with appropriate columns for the directional analysis chosen, if
<code>dir.mode</code> is:
</p>
<table>
<tr><td><code>"CentroidAngle"</code></td>
<td>
<p>A single column with centroid angle results, in degrees (North = 0 degrees). If
<code>group=TRUE</code> then values are identical for all event polygons in the group.</p>
</td></tr>
<tr><td><code>"ConeModel"</code></td>
<td>
<p><code>ndir</code> new columns with the area (m2) of the STAMP event in each direction,
named appropriately (e.g., as <code>DIR45</code>, where 45 refers to the mid-point of that directional cone).</p>
</td></tr>
<tr><td><code>"MBRModel"</code></td>
<td>
<p>9 new columns with the area (m2) of the STAMP event in each direction,
named appropriately as, for example, &quot;MBR_SW&quot;,&quot;MBR_S&quot;,... etc.</p>
</td></tr>
<tr><td><code>"ModConeModel"</code></td>
<td>
<p><code>ndir</code> new columns  with the area (m2) of the STAMP event in each direction,
named appropriately as, for example, &quot;MC4_N&quot;,&quot;MC8_SE&quot;, ... etc.</p>
</td></tr>
</table>
<p>Note: STAMP events that are singular (i.e., only 1 polygon in the group)
will have <code>NA</code>'s from directional analysis.
</p>


<h3>References</h3>

<p>Robertson, C., Nelson, T., Boots, B., and Wulder, M. (2007) STAMP: Spatial-temporal analysis of moving polygons.
<em>Journal of Geographical Systems</em>, 9:207-227. <br /><br />
Peuquet, D., Zhang, C.X. (1987) An algorithm to determine the directional relationship between arbitrarily-shaped
polygons in the plane. <em>Pattern Recognition</em>, 20:65-74. <br /><br />
Skiadopoulos, S. Giannoukos, C., Sarkas, N., Vassiliadis, P., Sellis, T., and Koubarakis, M. (2005) Computing and
managing directional relations. <em>IEEE Transactions on Knowledge and Data Engineering</em>, 17:1610-1623.
</p>


<h3>See Also</h3>

<p>stamp stamp.distance
</p>

<hr>
<h2 id='stamp.distance'>stamp.distance</h2><span id='topic+stamp.distance'></span>

<h3>Description</h3>

<p>The function <code>stamp.distance</code> can be used to compute various measures of distance 
between polygon events and groups. In turn, distance measurements can be used to estimate the velocity
of polygon movement.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>stamp.distance(stmp, dist.mode = "Centroid", group = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="stamp.distance_+3A_stmp">stmp</code></td>
<td>
<p>a <code>sf</code> object generated from the <code>stamp</code> function.</p>
</td></tr>
<tr><td><code id="stamp.distance_+3A_dist.mode">dist.mode</code></td>
<td>
<p>Character determining the method by which polygon distances are computed. If <code>"Centroid"</code>
then the centroid distance is calculated, if <code>"Hausdorff"</code> then the discrete Hausdorff distance
is calculated; see <code>Details</code>.</p>
</td></tr>
<tr><td><code id="stamp.distance_+3A_group">group</code></td>
<td>
<p>logical indicating whether distances should be computed from the T1 polygon to each individual 
stamp event (<code>group = FALSE</code> &ndash; the default), or whether T2 polygons should combined (through a spatial 
union) in order to compute the measure of distance for each stamp group (<code>group = TRUE</code>)</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>stamp.distance</code> computes distance between polygon sets based on either centroid or
Hausdorff distance calculations. Centroid distance is simply the distance from the centroid
of all T1 polygons (combined) to each stamp event (<code>group = FALSE</code>), or to the union of
all T2 polygons within a group (<code>group = TRUE</code>), in the second case, all events within a group
are given an identical distance value.<br /><br />
The Hausdorff distance calculation uses the Hausdorff distance, as
programmed in the function <code>st_distance</code>. A value of <code>par = 0.1</code> is used
to increase the precision of this measurement &ndash; see <code>help(st_distance)</code>. The returned distance
is then the Hausdorff distance of all T1 polygons (combined) to each stamp event (<code>group = FALSE</code>),
or to the union of all T2 polygons within a group (<code>group = TRUE</code>), in the second case, all events 
within a group are given an identical distance value.
All distance calculations are computed in meters using the geographical projection WGS84.
</p>


<h3>Value</h3>

<p>Appropriately named columns (e.g., <code>CENDIST</code> or <code>HAUSDIST</code>) in the stamp <code>sf</code>
object. Distances are in meters.
</p>


<h3>References</h3>

<p>Hausdorff Distance: <a href="https://en.wikipedia.org/wiki/Hausdorff_distance">https://en.wikipedia.org/wiki/Hausdorff_distance</a>
</p>


<h3>See Also</h3>

<p>stamp stamp.direction
</p>

<hr>
<h2 id='stamp.group.summary'>Compile stamp summary statistics by group</h2><span id='topic+stamp.group.summary'></span>

<h3>Description</h3>

<p>The function <code>stamp.group.summary</code> compiles summary statistics for each STAMP grouping.
Specifically, it computes the area of each STAMP event type (e.g., generation, expansion, etc.)
within each grouping. It also computes the number of events belonging to each event type.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>stamp.group.summary(stmp, area = TRUE, count = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="stamp.group.summary_+3A_stmp">stmp</code></td>
<td>
<p>a <code>sf</code> object generated from the <code>stamp</code> function.</p>
</td></tr>
<tr><td><code id="stamp.group.summary_+3A_area">area</code></td>
<td>
<p>logical, whether or not to compute the STAMP event areas.</p>
</td></tr>
<tr><td><code id="stamp.group.summary_+3A_count">count</code></td>
<td>
<p>logical, whether or not to compute the count of STAMP events within each group.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>stamp.group.summary</code> computes area and count summary statistics of STAMP output. Note that if
both <code>area</code> and <code>count</code> are set to <code>FALSE</code>, <code>stamp.group.summary</code> returns a
<code>data.frame</code> with just the group IDs as the only column.
</p>


<h3>Value</h3>

<p>A <code>data.frame</code> where rows are stamp groups and columns correspond to the STAMP event types (ID, areas, and counts).
</p>

<hr>
<h2 id='stamp.map'>Mapping (plotting) functionality for <code>stamp</code> output</h2><span id='topic+stamp.map'></span>

<h3>Description</h3>

<p>This function maps STAMP output for visual assessment of STAMP events and groupings.
Choice of which aspect of the stamp output to be visualized is controlled by passing
the column name to the <code>stamp.map</code> function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>stamp.map(stmp, by = "LEV1", ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="stamp.map_+3A_stmp">stmp</code></td>
<td>
<p>output from the <code>stamp</code> function, i.e., a (<code>sf</code> object).</p>
</td></tr>
<tr><td><code id="stamp.map_+3A_by">by</code></td>
<td>
<p>tells the function which attribute to visualize, one of <code>"LEV1"</code>,
<code>"LEV2"</code>, <code>"LEV3"</code>, <code>"LEV4"</code>, or <code>"GROUP"</code></p>
</td></tr>
<tr><td><code id="stamp.map_+3A_...">...</code></td>
<td>
<p>additional parameters to be passed to the sf plot function</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>stamp.map</code> function can be used to visualize any of the stamp event designation levels
(e.g., <code>"LEV1"</code>, <code>"LEV2"</code>, <code>"LEV3"</code>, <code>"LEV4"</code>, or the STAMP groupings
(based off of parameter <code>dc</code> in the <code>stamp</code> function).
</p>


<h3>Value</h3>

<p><code>stamp.map</code> returns a map of the <code>stamp</code> output using the <code>plot.sf</code> functionality. 
It implements a pre-defined coloring scheme.
</p>


<h3>See Also</h3>

<p>stamp
data(&quot;fire1&quot;)
data(&quot;fire2&quot;)
ch &lt;- stamp(fire1, fire2, dc=1, direction=FALSE, distance=FALSE)
stamp.map(ch, &quot;LEV1&quot;) 
stamp.map(ch, &quot;LEV2&quot;) 
stamp.map(ch, &quot;LEV3&quot;) 
stamp.map(ch, &quot;LEV4&quot;)
</p>

<hr>
<h2 id='stamp.multichange'>run stamp function for multiple years of polygons at once</h2><span id='topic+stamp.multichange'></span>

<h3>Description</h3>

<p>The function <code>stamp.multichange</code> is a wrapper function that makes multiple calls to the stamp 
function to ease spatial-temporal analysis of multiple years of polygon data
</p>


<h3>Usage</h3>

<pre><code class='language-R'>stamp.multichange(polys, changeByRow = TRUE, changeField = "", ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="stamp.multichange_+3A_polys">polys</code></td>
<td>
<p>a <code>sf</code> polygon object with 2+ years of data to run through the <code>stamp</code> function.</p>
</td></tr>
<tr><td><code id="stamp.multichange_+3A_changebyrow">changeByRow</code></td>
<td>
<p>logical, whether or not each time period is a separate unique row of data (e.g., as per the <code>katrina</code> data)</p>
</td></tr>
<tr><td><code id="stamp.multichange_+3A_changefield">changeField</code></td>
<td>
<p>string, name of the field which contains time period if changeByRow is FALSE</p>
</td></tr>
<tr><td><code id="stamp.multichange_+3A_...">...</code></td>
<td>
<p>list of paramater values to provide to the <code>stamp</code> function</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>stamp.multichange</code> is a simple wrapper function for the <code>stamp</code> function. The two options for data structure
are those in the <code>katrina</code> data, where each time period is a row, and rows are time-ordered, and the structure of 
the <code>mpb</code> data, where time period is specified by a column. Time periods should be ordered from 1 through T.
</p>


<h3>Value</h3>

<p>A <code>sf</code> object which includes all outputs from the calls to the <code>stamp</code> function. If there are T time periods,
there will be T-1 time periods in the resulting <code>sf</code> object.
</p>


<h3>See Also</h3>

<p>stamp.stgroup.summary
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
## NOT RUN ##
data("katrina")
ch &lt;- stamp.multichange(katrina, changeByRow = TRUE, dc = 0, distance = TRUE, direction = FALSE)
STGroup &lt;- stamp.stgroup.summary(ch)
head(STGroup)

## End(Not run)
</code></pre>

<hr>
<h2 id='stamp.stgroup.summary'>Compile stamp summary statistics by space-time group</h2><span id='topic+stamp.stgroup.summary'></span>

<h3>Description</h3>

<p>The function <code>stamp.stgroup.summary</code> compiles summary statistics for each STAMP space-time grouping.
Specifically, it computes the area of each STAMP event type (e.g., generation, expansion, etc.)
within each grouping. It also computes the number of events belonging to each event type.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>stamp.stgroup.summary(stmp, area = TRUE, count = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="stamp.stgroup.summary_+3A_stmp">stmp</code></td>
<td>
<p>a <code>sf</code> polygon object generated from the <code>stamp.multichange</code> function.</p>
</td></tr>
<tr><td><code id="stamp.stgroup.summary_+3A_area">area</code></td>
<td>
<p>logical, whether or not to compute the STAMP event areas.</p>
</td></tr>
<tr><td><code id="stamp.stgroup.summary_+3A_count">count</code></td>
<td>
<p>logical, whether or not to compute the count of STAMP events within each group.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>stamp.stgroup.summary</code> computes area and count summary statistics of STAMP output derived from multi-time analysis using stamp.multichange.
stamp.multichange is just a wrapper function for applying stamp to multiple time periods in the same dataset. Note that if
both <code>area</code> and <code>count</code> are set to <code>FALSE</code>, <code>stamp.stgroup.summary</code> returns a
<code>data.frame</code> with just the stgroup IDs as the only column.
</p>


<h3>Value</h3>

<p>A <code>data.frame</code> where rows are stamp groups and columns correspond to the STAMP event types (ID, areas, and counts).
</p>


<h3>See Also</h3>

<p>stamp.multichange
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
 ##NOT RUN##
library(sf)
data("katrina")
ch &lt;- stamp.multichange(katrina, changeByRow = TRUE, dc = 0, distance = TRUE, direction = FALSE)
STGroup &lt;- stamp.stgroup.summary(ch)
head(STGroup)

## End(Not run)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
