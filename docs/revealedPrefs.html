<!DOCTYPE html><html><head><title>Help for package revealedPrefs</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {revealedPrefs}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#revealedPrefs-package'>
<p>Revealed Preferences and Microeconomic Rationality</p></a></li>
<li><a href='#checkGarp'>
<p>Non-parametric tests of rationality axioms (WARP, SARP, GARP).</p></a></li>
<li><a href='#cpLower'>
<p>Lower bound on the number of GARP-consistent subpopulations.</p></a></li>
<li><a href='#cpUpper'>
<p>Upper bound on the number of GARP-consistent subpopulations and clustering.</p></a></li>
<li><a href='#directPrefs'>
<p>Compute direct and indirect revealed preferences.</p></a></li>
<li><a href='#noGarp'><p>revealedPrefs example datasets</p></a></li>
<li><a href='#simGarp'>
<p>Generate random data consistent with rationality axioms (WARP, SARP, GARP).</p></a></li>
<li><a href='#simPrefs'>
<p>Generate random data according to a given matrix of direct preferences.</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Revealed Preferences and Microeconomic Rationality</td>
</tr>
<tr>
<td>Version:</td>
<td>0.4.1</td>
</tr>
<tr>
<td>Date:</td>
<td>2019-09-03</td>
</tr>
<tr>
<td>Author:</td>
<td>Julien Boelaert &lt;jubo.stats@gmail.com&gt;</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Julien Boelaert &lt;jubo.stats@gmail.com&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Computation of (direct and indirect) revealed preferences, fast non-parametric tests of rationality axioms (WARP, SARP, GARP), simulation of axiom-consistent data, and detection of axiom-consistent subpopulations. Rationality tests follow Varian (1982) &lt;<a href="https://doi.org/10.2307%2F1912771">doi:10.2307/1912771</a>&gt;, axiom-consistent subpopulations follow Crawford and Pendakur (2012) &lt;<a href="https://doi.org/10.1111%2Fj.1468-0297.2012.02545.x">doi:10.1111/j.1468-0297.2012.02545.x</a>&gt;.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL (&ge; 3)</a></td>
</tr>
<tr>
<td>Imports:</td>
<td>pso</td>
</tr>
<tr>
<td>Depends:</td>
<td>Rcpp</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>Rcpp, RcppArmadillo</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2019-09-03 17:45:22 UTC; bart</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2019-09-05 02:10:05 UTC</td>
</tr>
</table>
<hr>
<h2 id='revealedPrefs-package'>
Revealed Preferences and Microeconomic Rationality
</h2><span id='topic+revealedPrefs-package'></span><span id='topic+revealedPrefs'></span>

<h3>Description</h3>

<p>Computation of (direct and indirect) revealed preferences, fast non-parametric tests of rationality axioms (WARP, SARP, GARP), simulation of axiom-consistent data, and detection of axiom-consistent subpopulations. Rationality tests follow Varian (1982) &lt;doi:10.2307/1912771&gt;, axiom-consistent subpopulations follow Crawford and Pendakur (2012) &lt;doi:10.1111/j.1468-0297.2012.02545.x&gt;.
</p>


<h3>Details</h3>

<p>This package is meant for the analysis of (quantity, price) data, eg. of bundles of goods and corresponding prices. It features fast algorithms that make the analysis of large datasets feasible.
</p>
<p>Functions <code>directPrefs</code> and <code>indirectPrefs</code> compute revealed preferences.
</p>
<p>Functions <code>checkWarp</code>, <code>checkSarp</code>, <code>checkGarp</code> perform fast non-parametric tests of rationality using the corresponding rationality axioms.
</p>
<p>Functions <code>simWarp</code>, <code>simSarp</code>, <code>simGarp</code> and <code>simPrefs</code> generate simulated data consistent with a rationality axiom or with a given preference matrix.
</p>
<p>Functions <code>cpLower</code> and <code>cpUpper</code> generate Crawford-Pendakur type bounds on the number of subpopulations and provide the corresponding clusterings.
</p>


<h3>Author(s)</h3>

<p>Julien Boelaert &lt;jubo.stats@gmail.com&gt;
</p>
<p>Maintainer: Julien Boelaert &lt;jubo.stats@gmail.com&gt;
</p>


<h3>References</h3>

<p>Varian, H. R. (1982) The Nonparametric Approach to Demand Analysis, 
<em>Econometrica</em>, 50(4):945-973.
</p>
<p>Varian, H. R. (1984) <em>Microeconomic Analysis</em>. New York/London:
Norton, 2nd edition, pp 141-143.
</p>
<p>Crawford, I. and Pendakur, K. (2013). How many types are there?
<em>The Economic Journal</em>, 123(567):77-95.
</p>


<h3>See Also</h3>

<p>See <a href="#topic+directPrefs">directPrefs</a> for computation of preferences, <a href="#topic+checkGarp">checkGarp</a> for rationality tests, <code>simGarp</code> for data generation, and <a href="#topic+cpUpper">cpUpper</a> for clustering of data into non-violating subsets.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Compute preferences and check rationality on a GARP-violating dataset:
data(noGarp)
indirectPrefs(noGarp$x, noGarp$p)
checkGarp(noGarp$x, noGarp$p)

# Cluster dataset into GARP-consistent subpopulations:
cpUpper(noGarp$x, noGarp$p)
</code></pre>

<hr>
<h2 id='checkGarp'>
Non-parametric tests of rationality axioms (WARP, SARP, GARP).
</h2><span id='topic+checkGarp'></span><span id='topic+checkWarp'></span><span id='topic+checkSarp'></span><span id='topic+print.axiomTest'></span><span id='topic+summary.axiomTest'></span>

<h3>Description</h3>

<p>Functions for non-parametric tests of compliance with rationality axioms.
</p>
<p>Functions <code>checkWarp</code>, <code>checkSarp</code> and <code>checkGarp</code> perform exact tests of the Weak Axiom of Revealed Preferences (WARP), the Strong Axiom of Revealed Preferences (SARP) and the Generalized Axiom of Revealed Preferences (GARP) respectively, to check whether the given data are consistent with utility maximization.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>checkWarp(x, p, afriat.par= 1)
checkSarp(x, p, afriat.par= 1, method= c("deep", "floyd"))
checkGarp(x, p, afriat.par= 1, method= c("floyd"))
## S3 method for class 'axiomTest'
print(x, ...)
## S3 method for class 'axiomTest'
summary(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="checkGarp_+3A_x">x</code></td>
<td>
<p>data frame or matrix containing the observed quantities, where each row corresponds to an observation and the columns are types of goods, or an object of class <code>axiomTest</code> for use with <code>print</code>,</p>
</td></tr>
<tr><td><code id="checkGarp_+3A_p">p</code></td>
<td>
<p>data frame or matrix (of same dimensions as x) containing the corresponding prices,</p>
</td></tr>
<tr><td><code id="checkGarp_+3A_afriat.par">afriat.par</code></td>
<td>
<p>the Afriat parameter, real number in [0,1], which allows a certain level of error in the optimization of choices; default is 1, ie. no optimization error allowed,</p>
</td></tr>
<tr><td><code id="checkGarp_+3A_method">method</code></td>
<td>
<p>character string: <code>"deep"</code> for depth-first search (default for Sarp), <code>"floyd"</code> for Floyd-Warshall algorithm (can be very slow for large datasets when no violations are present),</p>
</td></tr>
<tr><td><code id="checkGarp_+3A_object">object</code></td>
<td>
<p>an object of class <code>axiomTest</code> as returned by eg. <code>checkWarp</code>,</p>
</td></tr>
<tr><td><code id="checkGarp_+3A_...">...</code></td>
<td>
<p>additional arguments passed to the <code>print</code> and <code>summary</code> methods (unused).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Rationality axioms can be summarized as follows:
</p>
<p>WARP: if X directly prefered to Y and X is not equal to Y, then Y cannot be directly prefered to X (WARP is a necessary condition for the existence of a single-valued utility-maximizing demand function consistent with the data).
</p>
<p>SARP: if X (in)directly prefered to Y and X is not equal to Y, then Y cannot be (in)directly prefered to X (SARP is a necessary and sufficient condition for the existence of a single-valued utility-maximizing demand function consistent with the data).
</p>
<p>GARP: if X (in)directly prefered to Y, then Y cannot be strictly directly prefered to X (GARP is a necessary and sufficient condition for the existence of a (possibly multiple-valued) utility-maximizing demand function consistent with the data). 
</p>
<p>If WARP or GARP are violated, then SARP is also violated.
</p>
<p>Testing of WARP is straightforward by pairwise comparison of revealed preferences. GARP is tested using the Floyd-Warshall algorithm to find the transitive closure of the direct preference relationship. SARP can be tested either using the Floyd-Warshall algorithm, or using a depth-first search that systematically explores the preference relationship in search of a violating cycle.
</p>


<h3>Value</h3>

<p>Functions <code>checkWarp</code>, <code>checkSarp</code> and <code>checkGarp</code> return an object of class <code>axiomTest</code> which may contain the following elements:
</p>
<table>
<tr><td><code>violation</code></td>
<td>
<p>logical value, <code>TRUE</code> if a violation was found,</p>
</td></tr>
<tr><td><code>path</code></td>
<td>
<p>last path taken during depth-first search,</p>
</td></tr>
<tr><td><code>path.strict</code></td>
<td>
<p>(for <code>deep</code> method) vector of logical values indicating the strictness of direct preference relations in the last path taken,</p>
</td></tr>
<tr><td><code>violators</code></td>
<td>
<p>vector of indices of axiom-violating observations (only the first violators that were found are reported, this is not a complete list),</p>
</td></tr>
<tr><td><code>strict</code></td>
<td>
<p>vector of logical values indicating whether the preferences between reported violators (or path) are strict or not,</p>
</td></tr>
<tr><td><code>direct.violation</code></td>
<td>
<p>logical value, <code>TRUE</code> if a violation was found in direct preferences,</p>
</td></tr>
<tr><td><code>type</code></td>
<td>
<p>the violated or non-violated rationality axiom,</p>
</td></tr> 
<tr><td><code>method</code></td>
<td>
<p>method used for the non-parametric test,</p>
</td></tr>
<tr><td><code>afriat.par</code></td>
<td>
<p>Afriat parameter used in the algorithm.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Julien Boelaert <a href="mailto:jubo.stats@gmail.com">jubo.stats@gmail.com</a>
</p>


<h3>References</h3>

<p>Varian, H. R. (1982) The Nonparametric Approach to Demand Analysis, 
<em>Econometrica</em>, 50(4):945-973.
</p>
<p>Varian, H. R. (1984) <em>Microeconomic Analysis</em>. New York/London:
Norton, 2nd edition, pp 141-143.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Check axioms for GARP-violating data:
data(noGarp)
summary(checkGarp(noGarp$x, noGarp$p))

# Check axioms for SARP-consistent data:
data(okSarp)
summary(checkSarp(okSarp$x, okSarp$p))
</code></pre>

<hr>
<h2 id='cpLower'>
Lower bound on the number of GARP-consistent subpopulations.
</h2><span id='topic+cpLower'></span><span id='topic+print.lowerBound'></span><span id='topic+summary.lowerBound'></span>

<h3>Description</h3>

<p>The <code>cpLower</code> function computes a Crawford-Pendakur type lower bound on the number of GARP-consistent subpopulations by creating a set of pairwise GARP-violating observations.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cpLower(x, p, times= 1, afriat.par= 1)
## S3 method for class 'lowerBound'
print(x, ...)
## S3 method for class 'lowerBound'
summary(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cpLower_+3A_x">x</code></td>
<td>
<p>data frame or matrix containing the observed quantities, where each row corresponds to an observation and the columns are types of goods, or an object of class <code>lowerBound</code> to be used with <code>print</code>,</p>
</td></tr>
<tr><td><code id="cpLower_+3A_p">p</code></td>
<td>
<p>data frame or matrix (of same dimensions as x) containing the corresponding prices,</p>
</td></tr>
<tr><td><code id="cpLower_+3A_times">times</code></td>
<td>
<p>number of times the algorithm is run (the final result is the best of <code>times</code> results, ie. highest number of clusters found),</p>
</td></tr>
<tr><td><code id="cpLower_+3A_afriat.par">afriat.par</code></td>
<td>
<p>the Afriat parameter, a real number in [0,1], which allows a certain level of error in the optimization of choices ; default is 1, ie. no optimization error allowed,</p>
</td></tr>
<tr><td><code id="cpLower_+3A_object">object</code></td>
<td>
<p>object of class <code>lowerBound</code> as returned by <code>cpLower</code>,</p>
</td></tr>
<tr><td><code id="cpLower_+3A_...">...</code></td>
<td>
<p>additional arguments passed to the <code>print</code> and <code>summary</code> methods (unused).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For each run of the algorithm, a random permutation of the observations is drawn, and one by one each observation is pairwise-tested against all previously found violators. If the current observation is found pairwise-inconsistent with all previously found violators it is added to 
the set of violators.
</p>


<h3>Value</h3>

<p><code>cpLower</code> returns an object of class <code>lowerBound</code> which contains the following elements:
</p>
<table>
<tr><td><code>violators</code></td>
<td>
<p>numeric vector containing the indices of observations that are pairwise GARP-inconsistent,</p>
</td></tr>
<tr><td><code>n.clust</code></td>
<td>
<p>lower bound on the number of types,</p>
</td></tr>
<tr><td><code>hist.n.types</code></td>
<td>
<p>numeric vector containing the history of numbers of types found during multiple runs of the algorithm.</p>
</td></tr>
<tr><td><code>n.types</code></td>
<td>
<p>lower bound on the number of types,</p>
</td></tr>
<tr><td><code>afriat.par</code></td>
<td>
<p>Afriat parameter used in the algorithm.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Julien Boelaert <a href="mailto:jubo.stats@gmail.com">jubo.stats@gmail.com</a>
</p>


<h3>References</h3>

<p>Crawford, I. and Pendakur, K. (2013). How many types are there?
<em>The Economic Journal</em>, 123(567):77-95.
</p>


<h3>See Also</h3>

<p>See <a href="#topic+cpUpper">cpUpper</a> for the upper bound on the number of types.</p>


<h3>Examples</h3>

<pre><code class='language-R'># Lower bound for GARP-violating data:
data(noGarp)
cp.low &lt;- cpLower(noGarp$x, noGarp$p)
cp.low
cp.low$violators
</code></pre>

<hr>
<h2 id='cpUpper'>
Upper bound on the number of GARP-consistent subpopulations and clustering.
</h2><span id='topic+cpUpper'></span><span id='topic+print.upperBound'></span><span id='topic+summary.upperBound'></span>

<h3>Description</h3>

<p>The <code>cpUpper</code> function computes a Crawford-Pendakur type upper bound on the number of GARP-consistent subpopulations, and performs clustering of the data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cpUpper(x, p, times= 1, afriat.par= 1, method= c("fastfloyd", "floyd"))
## S3 method for class 'upperBound'
print(x, ...)
## S3 method for class 'upperBound'
summary(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cpUpper_+3A_x">x</code></td>
<td>
<p>data frame or matrix containing the observed quantities, where each row corresponds to an observation and the columns are types of goods, or an object of class <code>upperBound</code> to be used with <code>print</code>,</p>
</td></tr>
<tr><td><code id="cpUpper_+3A_p">p</code></td>
<td>
<p>data frame or matrix (of same dimensions as x) containing the corresponding prices,</p>
</td></tr>
<tr><td><code id="cpUpper_+3A_times">times</code></td>
<td>
<p>number of times the algorithm is run (the final result is the best of <code>times</code> results, ie. lowest number of clusters found), default is 1,</p>
</td></tr>
<tr><td><code id="cpUpper_+3A_afriat.par">afriat.par</code></td>
<td>
<p>the Afriat parameter, a real number in [0,1], which allows a certain level of error in the optimization of choices ; default is 1, ie. no optimization error allowed,</p>
</td></tr>
<tr><td><code id="cpUpper_+3A_method">method</code></td>
<td>
<p>character string: <code>"fastfloyd"</code> or <code>"floyd"</code> (see Details). Default <code>"fastfloyd"</code>. </p>
</td></tr>
<tr><td><code id="cpUpper_+3A_object">object</code></td>
<td>
<p>an object of class <code>upperBound</code> as returned by <code>cpUpper</code>,</p>
</td></tr>
<tr><td><code id="cpUpper_+3A_...">...</code></td>
<td>
<p>additional arguments passed to the <code>print</code> and 
<code>summary</code> methods (unused).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For each run of the algorithm, a random permutation of the observations is drawn, and one by one each observation is associated with the biggest cluster that can include it while preserving consistency with the GARP rationality axiom. If no cluster is compatible with a given observation a new cluster is created to accomodate it.
</p>
<p>Three methods are available: 
<code>"fastfloyd"</code> (default) uses an iterative variant of the Floyd-Warshall algorithm, in which the check of consistency of the current observation with a given cluster is done in a single step of the Floyd-Warshall algorithm. Much faster than <code>"floyd"</code>.
</p>
<p><code>"floyd"</code> uses the algorithm described in Crawford and Pendakur (2013): at each step the complete Floyd-Warshall algorithm is run to check whether each cluster can accomodate the current observation.
</p>


<h3>Value</h3>

<p><code>cpUpper</code> returns an object of class <code>upperBound</code> which contains the following elements:
</p>
<table>
<tr><td><code>clustering</code></td>
<td>
<p>numeric vector with length equal to number of observations, containing the cluster number of each observation,</p>
</td></tr>
<tr><td><code>cluster.pop</code></td>
<td>
<p>numeric vector containg the numbers of observations allocated to each cluster,</p>
</td></tr>
<tr><td><code>hist.n.types</code></td>
<td>
<p>numeric vector containing the history of numbers of clusters found during multiple runs of the algorithm.</p>
</td></tr>
<tr><td><code>n.types</code></td>
<td>
<p>upper bound on the number of types,</p>
</td></tr>
<tr><td><code>afriat.par</code></td>
<td>
<p>Afriat parameter used in the algorithm.</p>
</td></tr>
</table>


<h3>Note</h3>

<p>Warning: <code>cpUpper</code> can be very slow for large datasets (eg. more than 1000 observations).
</p>


<h3>Author(s)</h3>

<p>Julien Boelaert <a href="mailto:jubo.stats@gmail.com">jubo.stats@gmail.com</a>
</p>


<h3>References</h3>

<p>Crawford, I. and Pendakur, K. (2013). How many types are there?
<em>The Economic Journal</em>, 123(567):77-95.
</p>


<h3>See Also</h3>

<p>See <a href="#topic+cpLower">cpLower</a> for the lower bound on number of types.</p>


<h3>Examples</h3>

<pre><code class='language-R'># Cluster GARP-violating data:
data(noGarp)
cp.up &lt;- cpUpper(noGarp$x, noGarp$p)
cp.up$clustering
</code></pre>

<hr>
<h2 id='directPrefs'>
Compute direct and indirect revealed preferences.
</h2><span id='topic+directPrefs'></span><span id='topic+indirectPrefs'></span>

<h3>Description</h3>

<p>The <code>directPrefs</code> function computes direct revealed preferences, the <code>indirectPrefs</code> function computes indirect revealed preferences.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>directPrefs(x, p, afriat.par= 1)
indirectPrefs(x, p, afriat.par= 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="directPrefs_+3A_x">x</code></td>
<td>
<p>data frame or matrix containing the observed quantities, where each row corresponds to an observation and the columns are types of goods.</p>
</td></tr>
<tr><td><code id="directPrefs_+3A_p">p</code></td>
<td>
<p>data frame or matrix (of same dimensions as x) containing the corresponding prices.</p>
</td></tr>
<tr><td><code id="directPrefs_+3A_afriat.par">afriat.par</code></td>
<td>
<p>the Afriat parameter, real number in [0,1], which allows a certain level of error in the optimization of choices; default is 1, ie. no optimization error allowed.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Direct preferences are directly computed from matrix multiplication of prices and quantities. Indirect preferences are computed using a variant of the Floyd-Warshall algorithm.
</p>


<h3>Value</h3>

<p>A matrix of direct or indirect revealed preferences:
</p>
<table>
<tr><td><code>prefs[i</code>, <code>j] = 0</code></td>
<td>
<p>if bundle <code>i</code> is not revealed prefered to bundle <code>j</code></p>
</td></tr> 
<tr><td><code>prefs[i</code>, <code>j] = 1</code></td>
<td>
<p>if bundle <code>i</code> is revealed prefered to bundle <code>j</code></p>
</td></tr> 
<tr><td><code>prefs[i</code>, <code>j] = 2</code></td>
<td>
<p>if bundle <code>i</code> is strictly revealed prefered to bundle <code>j</code></p>
</td></tr> 
</table>


<h3>Author(s)</h3>

<p>Julien Boelaert <a href="mailto:jubo.stats@gmail.com">jubo.stats@gmail.com</a>
</p>


<h3>References</h3>

<p>Varian, H. R. (1984) <em>Microeconomic Analysis</em>. New York/London:
Norton, 2nd edition, pp 141-143.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Compute direct and indirect preferences of SARP-violating data:
data(noSarp)
directPrefs(noSarp$x, noSarp$p)
indirectPrefs(noSarp$x, noSarp$p)
</code></pre>

<hr>
<h2 id='noGarp'>revealedPrefs example datasets</h2><span id='topic+noGarp'></span><span id='topic+noWarp'></span><span id='topic+noSarp'></span><span id='topic+okSarp'></span><span id='topic+noAxiom'></span>

<h3>Description</h3>

<p>Toy examples to test for consistency with rationality axioms.</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(noGarp)
data(noWarp)
data(noSarp)
data(okSarp)
data(noAxiom)
</code></pre>


<h3>Format</h3>

<p>Each dataset is a list of two matrices, named x and p, that contain quantities and prices, respectively. Each row is an observation, each column is a type of good.
</p>


<h3>Details</h3>

<p>Data in <code>noAxiom</code> violate WARP, GARP and SARP.
</p>
<p>Data in <code>noWarp</code> violate WARP and SARP, but not GARP.
</p>
<p>Data in <code>noGarp</code> violate GARP and SARP, but not WARP.
</p>
<p>Data in <code>noSarp</code> violate SARP, but not WARP or GARP.
</p>
<p>Data in <code>okSarp</code> are consistent with WARP, SARP and GARP.
</p>


<h3>Author(s)</h3>

<p>Julien Boelaert <a href="mailto:jubo.stats@gmail.com">jubo.stats@gmail.com</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(noWarp)
checkWarp(noWarp$x, noWarp$p)
</code></pre>

<hr>
<h2 id='simGarp'>
Generate random data consistent with rationality axioms (WARP, SARP, GARP).
</h2><span id='topic+simGarp'></span><span id='topic+simWarp'></span><span id='topic+simSarp'></span>

<h3>Description</h3>

<p>Functions for generating random data (prices and quantities) consistent with the chosen rationality axiom.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>simWarp(nobs, ngoods, afriat.par= 1, maxit= 10 * nobs, 
        qmin= 0, qmax= 1, pmin= 0, pmax= 1)
simSarp(nobs, ngoods, afriat.par= 1, maxit= 10 * nobs, 
        qmin= 0, qmax= 1, pmin= 0, pmax= 1)
simGarp(nobs, ngoods, afriat.par= 1, maxit= 10 * nobs, 
        qmin= 0, qmax= 1, pmin= 0, pmax= 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="simGarp_+3A_nobs">nobs</code></td>
<td>
<p>the desired number of observations (number of rows in the quantities and prices matrices),</p>
</td></tr>
<tr><td><code id="simGarp_+3A_ngoods">ngoods</code></td>
<td>
<p>the number of goods in the dataset (number of columns in the quantities and prices matrices),</p>
</td></tr>
<tr><td><code id="simGarp_+3A_afriat.par">afriat.par</code></td>
<td>
<p>the Afriat parameter, a real number in [0,1], which allows a certain level of error in the optimization of choices; default is 1, ie. no optimization error allowed,</p>
</td></tr>
<tr><td><code id="simGarp_+3A_maxit">maxit</code></td>
<td>
<p>maximum number of iterations (default to 10 times <code>nobs</code>),</p>
</td></tr>
<tr><td><code id="simGarp_+3A_qmin">qmin</code></td>
<td>
<p>minimum quantities for each good,</p>
</td></tr>
<tr><td><code id="simGarp_+3A_qmax">qmax</code></td>
<td>
<p>maximum quantities for each good,</p>
</td></tr>
<tr><td><code id="simGarp_+3A_pmin">pmin</code></td>
<td>
<p>minimum prices for each good,</p>
</td></tr>
<tr><td><code id="simGarp_+3A_pmax">pmax</code></td>
<td>
<p>maximum prices for each good.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The data are iteratively incremented: at each iteration a new random observation (prices and quantities) is generated, and is accepted only if it is consistent with the previously accepted data, in which case it is added to the data. The random observations (price-quantities couples) are independently generated from uniform distributions in the support defined by <code>qmin</code>, <code>qmax</code>, and <code>pmin</code>, <code>pmax</code>.
</p>
<p>For GARP and SARP the depth-first search method is used to check for consistency (a recursive search using only the new candidate observation as starting point), for WARP the candidate observation is pairwise checked against all previously accepted data.
</p>
<p>The algorithm stops if the desired number of observations <code>nobs</code> is reached. If the desired number of observations <code>nobs</code> is not reached in <code>maxit</code> iterations, a warning is issued and the function returns the largest dataset attained.
</p>


<h3>Value</h3>

<table>
<tr><td><code>x</code></td>
<td>
<p>numeric matrix of generated quantities,</p>
</td></tr>
<tr><td><code>p</code></td>
<td>
<p>numeric matrix of generated prices,</p>
</td></tr> 
<tr><td><code>iter</code></td>
<td>
<p>number of iterations before the algorithm stopped,</p>
</td></tr>
<tr><td><code>nobs</code></td>
<td>
<p>number of generated observations.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Julien Boelaert <a href="mailto:jubo.stats@gmail.com">jubo.stats@gmail.com</a>
</p>


<h3>References</h3>

<p>Varian, H. R. (1982) The Nonparametric Approach to Demand Analysis, 
<em>Econometrica</em>, 50(4):945-973.
</p>
<p>Varian, H. R. (1984) <em>Microeconomic Analysis</em>. New York/London:
Norton, 2nd edition, pp 141-143.
</p>


<h3>See Also</h3>

<p>See <a href="#topic+checkGarp">checkGarp</a> for rationality tests.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Generate 100 WARP-consistent observations of 5 goods
simdata &lt;- simWarp(100, 5)
summary(checkWarp(simdata$x, simdata$p))
summary(checkGarp(simdata$x, simdata$p))
</code></pre>

<hr>
<h2 id='simPrefs'>
Generate random data according to a given matrix of direct preferences.
</h2><span id='topic+simPrefs'></span>

<h3>Description</h3>

<p>Function for generating random data (prices and quantities) consistent with a given direct preferences matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>simPrefs(pref.mat, ngoods, afriat.par= 1, 
         qmin= 0, qmax= 1, pmin= 0, pmax= 1,
         maxit= 100, verbose= FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="simPrefs_+3A_pref.mat">pref.mat</code></td>
<td>
<p>the desired matrix of direct preferences (must be a square matrix, see details),</p>
</td></tr>
<tr><td><code id="simPrefs_+3A_ngoods">ngoods</code></td>
<td>
<p>the number of goods in the dataset (number of columns in the quantities and prices matrices),</p>
</td></tr>
<tr><td><code id="simPrefs_+3A_afriat.par">afriat.par</code></td>
<td>
<p>the Afriat parameter, a real number in [0,1], which allows a certain level of error in the optimization of choices; default is 1, ie. no optimization error allowed,</p>
</td></tr>
<tr><td><code id="simPrefs_+3A_qmin">qmin</code></td>
<td>
<p>minimum quantities for each good,</p>
</td></tr>
<tr><td><code id="simPrefs_+3A_qmax">qmax</code></td>
<td>
<p>maximum quantities for each good,</p>
</td></tr>
<tr><td><code id="simPrefs_+3A_pmin">pmin</code></td>
<td>
<p>minimum prices for each good,</p>
</td></tr>
<tr><td><code id="simPrefs_+3A_pmax">pmax</code></td>
<td>
<p>maximum prices for each good,</p>
</td></tr>
<tr><td><code id="simPrefs_+3A_maxit">maxit</code></td>
<td>
<p>maximum number of iterations of the optimization algorithm (default to 100),</p>
</td></tr>
<tr><td><code id="simPrefs_+3A_verbose">verbose</code></td>
<td>
<p>logical value: if <code>TRUE</code> a trace of the optimization algorithm is printed.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The input <code>pref.mat</code> must be a square matrix, with number of rows equal to the number of desired observations. All entries must be either 0, 1, or 2. The interpretation of the matrix is the same as in function <code>directPrefs</code>:
</p>
<p><code>pref.mat[i, j] = 0</code> if bundle <code>i</code> is not revealed prefered to bundle <code>j</code>
</p>
<p><code>pref.mat[i, j] = 1</code> if bundle <code>i</code> is revealed prefered to bundle <code>j</code>
</p>
<p><code>pref.mat[i, j] = 2</code> if bundle <code>i</code> is strictly revealed prefered to bundle <code>j</code>.
</p>
<p>All diagonal entries of <code>pref.mat</code> must be 1 (each bundle is revealed prefered to itself), except when <code>afriat.par</code> is strictly less than 1.
</p>
<p>The simulated data (quantities and prices) are obtained by particle swarm optimization (of package <code>pso</code>). Fitness must reach 0 for the data to be consistent with the preference matrix. If optimization fails, a warning is issued.
</p>


<h3>Value</h3>

<table>
<tr><td><code>x</code></td>
<td>
<p>numeric matrix of generated quantities, or <code>NULL</code> if optimization fails,</p>
</td></tr>
<tr><td><code>p</code></td>
<td>
<p>numeric matrix of generated prices, or <code>NULL</code> if optimizaiton fails.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Julien Boelaert <a href="mailto:jubo.stats@gmail.com">jubo.stats@gmail.com</a>
</p>


<h3>References</h3>

<p>Varian, H. R. (1982) The Nonparametric Approach to Demand Analysis, 
<em>Econometrica</em>, 50(4):945-973.
</p>
<p>Varian, H. R. (1984) <em>Microeconomic Analysis</em>. New York/London:
Norton, 2nd edition, pp 141-143.
</p>


<h3>See Also</h3>

<p>See <a href="#topic+directPrefs">directPrefs</a> for computation of preferences.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Generate 3 observations of 5 goods, according to a given preference matrix
pref.mat &lt;- matrix(c(1,0,0,2,1,0,2,2,1), 3)
simdata &lt;- simPrefs(pref.mat = pref.mat, ngoods = 5)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
