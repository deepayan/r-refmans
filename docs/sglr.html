<!DOCTYPE html><html><head><title>Help for package sglr</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {sglr}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#sglr-package'>
<p>A package for computing the boundaries for sequential generalized</p>
likelihood ratio test for pre-licensure vaccine studies</a></li>
<li><a href='#computeBoundary'>
<p>A function to compute the boundary of the decision region in terms of</p>
the number of adverse events (AEs) of interest, such as vaccine AEs.</a></li>
<li><a href='#glrSearch'>
<p>This function searches through a space of design boundaries (scalar</p>
values a and b) to find values that achieve close to specified
type I and type II errors for the sequential generalized
likelihood ratio test of p0 versus p1 (specified
respectively as vector of length 2) in pre-licensure vaccine trials</a></li>
<li><a href='#plotBoundary'>
<p>A function to plot the boundary of the decision region</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Sequential Generalized Likelihood Ratio Decision Boundaries
Proposed by Shih, Lai, Heyse and Chen (2010,
&lt;doi:10.1002/Sim.4036&gt;)</td>
</tr>
<tr>
<td>Version:</td>
<td>0.8</td>
</tr>
<tr>
<td>Date:</td>
<td>2022-04-18</td>
</tr>
<tr>
<td>Author:</td>
<td>Balasubramanian Narasimhan (with input from Tze Lai and Mei-Chiung Shih)</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Balasubramanian Narasimhan &lt;naras@stat.stanford.edu&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>We provide functions for computing the decision boundaries for pre-licensure vaccine trials using the Generalized Likelihood Ratio tests proposed by Shih, Lai, Heyse and Chen (2010, &lt;<a href="https://doi.org/10.1002%2Fsim.4036">doi:10.1002/sim.4036</a>&gt;).</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 2.7)</td>
</tr>
<tr>
<td>Imports:</td>
<td>rlang, ggplot2, shiny</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2022-04-19 01:05:32 UTC; naras</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2022-04-19 11:40:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='sglr-package'>
A package for computing the boundaries for sequential generalized
likelihood ratio test for pre-licensure vaccine studies
</h2><span id='topic+sglr-package'></span><span id='topic+sglr'></span>

<h3>Description</h3>

<p>This package is an implementation of the methodology of Shih, Lai,
Heyse, and Chen (to appear in Statistics in Medicine) for computing
Generalized Likelihood Ratio test boundaries for pre-licensure vaccine
studies
</p>


<h3>Details</h3>


<table>
<tr>
 <td style="text-align: left;">
    Package: </td><td style="text-align: left;"> sglr</td>
</tr>
<tr>
 <td style="text-align: left;">
    Type: </td><td style="text-align: left;"> Package</td>
</tr>
<tr>
 <td style="text-align: left;">
    Version: </td><td style="text-align: left;"> 0.05</td>
</tr>
<tr>
 <td style="text-align: left;">
    Date: </td><td style="text-align: left;"> 2010-04-20</td>
</tr>
<tr>
 <td style="text-align: left;">
    License: </td><td style="text-align: left;"> GPL (version 2 or later)</td>
</tr>
<tr>
 <td style="text-align: left;">
    LazyLoad: </td><td style="text-align: left;"> yes</td>
</tr>
<tr>
 <td style="text-align: left;">
  </td>
</tr>

</table>

<p>The package provides several functions. The function <code>glrSearch</code>
computes boundaries for testing a given <code class="reqn">p_0</code> versus <code class="reqn">p_1</code>
(specified as a two-dimensional vector) given a significance level
<code class="reqn">\alpha</code> and a type II error <code class="reqn">\beta</code>.  The function
<code>computeBoundary</code> computes the boundary in terms of a more
understandable and usable quantity, such as the number of adverse
events in a pre-licensure vaccine study for example. It takes as input
a set of given boundaries for the GLR statistic. The third function is
<code>plotBoundary</code> which also takes the same arguments as
<code class="reqn">computeBoundary</code> and produces a plot. The last two functions can
make use of statistics computed previously for the problem, which can
be specified as an argument; otherwise, the statistics are computed
from scratch.
</p>


<h3>Author(s)</h3>

<p>Balasubramanian Narasimhan with input from Tze Lai and Mei-Chiung Shih.
Maintainer: Balasubramanian Narasimhan &lt;naras@stat.stanford.edu&gt;
</p>


<h3>References</h3>

<p>&ldquo;Sequential Generalized Likelihood Ratio Tests for Vaccine Safety Evaluation&rdquo;
doi: <a href="https://doi.org/10.1002/sim.4036">10.1002/sim.4036</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(sglr)
result &lt;- glrSearch(p=c(.5, .75), alpha=0.05, beta=0.10)
## print(result)  ## large amounts of output possible!
result[1:3]
</code></pre>

<hr>
<h2 id='computeBoundary'>
A function to compute the boundary of the decision region in terms of
the number of adverse events (AEs) of interest, such as vaccine AEs.
</h2><span id='topic+computeBoundary'></span>

<h3>Description</h3>

<p>This function computes the boundary of the decision region in a manner
that can be employed in the field, as a table, for example. See
section 4.2 of the reference below.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>computeBoundary(b1, b0, p, glrTables = NULL, tol=1e-7)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="computeBoundary_+3A_b1">b1</code></td>
<td>

<p>The acceptance boundary value (corresponds to the boundary <code class="reqn">b_1</code> in the appendix of reference)
</p>
</td></tr>
<tr><td><code id="computeBoundary_+3A_b0">b0</code></td>
<td>

<p>The rejection boundary value (corresponds to the boundary <code class="reqn">b_0</code> in the appendix of reference)
</p>
</td></tr>
<tr><td><code id="computeBoundary_+3A_p">p</code></td>
<td>

<p>The vector of probabilities, <code class="reqn">(p_0, p_1)</code> with <code class="reqn">p_0 &lt; p_1</code>. 
</p>
</td></tr>
<tr><td><code id="computeBoundary_+3A_glrtables">glrTables</code></td>
<td>

<p>A previously computed set of likelihood functions, to speed up
computation for the <em>same hypothesis testing
problem</em>. Otherwise, it is computed ab initio, resulting in a longer
running time.
</p>
</td></tr>
<tr><td><code id="computeBoundary_+3A_tol">tol</code></td>
<td>

<p>A numerical tolerance, defaults to 1e-7
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This essentially computes the probabilities of hitting
the boundaries using a recursion.
</p>


<h3>Value</h3>

<table>
<tr><td><code>upper</code></td>
<td>
<p>The upper boundary that indicates rejection of the null
hypothesis</p>
</td></tr>
<tr><td><code>lower</code></td>
<td>
<p>The upper boundary that indicates acceptance of the null
hypothesis</p>
</td></tr> 
<tr><td><code>estimate</code></td>
<td>
<p>The estimated <code class="reqn">\alpha</code> and <code class="reqn">\beta</code>
values corresponding to the two boundaries</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Balasubramanian Narasimhan
</p>


<h3>References</h3>

<p>&ldquo;Sequential Generalized Likelihood Ratio Tests for Vaccine Safety Evaluation&rdquo;
doi: <a href="https://doi.org/10.1002/sim.4036">10.1002/sim.4036</a>.
</p>


<h3>See Also</h3>

<p>See Also <code><a href="#topic+glrSearch">glrSearch</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>computeBoundary(b1=2.8, b0=3.3, p=c(.5, .75))
</code></pre>

<hr>
<h2 id='glrSearch'>
This function searches through a space of design boundaries (scalar
values a and b) to find values that achieve close to specified
type I and type II errors for the sequential generalized
likelihood ratio test of p0 versus p1 (specified
respectively as vector of length 2) in pre-licensure vaccine trials
</h2><span id='topic+glrSearch'></span>

<h3>Description</h3>

<p>The search through the space of <code class="reqn">b_1</code> (corresponds to <code class="reqn">b_1</code> in
paper) and <code class="reqn">b_0</code> (corresponds to <code class="reqn">b_0</code> in paper) is greedy
initially. Then refinements to the boundary are made by adjusting the
boundaries by the step-size. It is entirely possible that the
step-size is so small that a maximum number of iterations can be
reached. Depending on how close <code class="reqn">p_0</code> and <code class="reqn">p_1</code> are the memory
usage can grow significantly. The process is computationally intensive
being dominated by a recursion deep in the search.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>glrSearch(p, alpha, beta, stepSize = 0.5, tol = 1e-7,
          startB1 = log(1/beta), startB0 = log(1/alpha),
          maxIter = 25, gridIt = FALSE, nGrid = 5, verbose = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="glrSearch_+3A_p">p</code></td>
<td>

<p>The vector of <code class="reqn">p_0</code> and <code class="reqn">p_1</code>, with <code class="reqn">p_0 &lt; p_1</code>
</p>
</td></tr>
<tr><td><code id="glrSearch_+3A_alpha">alpha</code></td>
<td>

<p>A value for type I error <code class="reqn">\alpha</code> between 0 and 1 typically 0.05 which is the
default value
</p>
</td></tr>
<tr><td><code id="glrSearch_+3A_beta">beta</code></td>
<td>

<p>A value for type II error (<code class="reqn">\beta</code>) between 0 and 1 typically below .2,
default 0.10
</p>
</td></tr>
<tr><td><code id="glrSearch_+3A_stepsize">stepSize</code></td>
<td>

<p>A value to use for moving the boundaries during the search, 0.5
default seems to work.
</p>
</td></tr>
<tr><td><code id="glrSearch_+3A_tol">tol</code></td>
<td>

<p>A value that is used for deciding when to terminate the search. A
euclidean metric is used. Default 1e-7.
</p>
</td></tr>
<tr><td><code id="glrSearch_+3A_startb1">startB1</code></td>
<td>

<p>A starting value for the futility boundary, default is log of reciprocal
type I error
</p>
</td></tr>
<tr><td><code id="glrSearch_+3A_startb0">startB0</code></td>
<td>

<p>A starting value for the rejection boundary, default is log of reciprocal
type II error
</p>
</td></tr>
<tr><td><code id="glrSearch_+3A_maxiter">maxIter</code></td>
<td>

<p>A maximum number of iterations to be used for the search. This
allows for a bailout if the step size is too small.
</p>
</td></tr>
<tr><td><code id="glrSearch_+3A_gridit">gridIt</code></td>
<td>

<p>A logical value indicating if a grid of values should be evaluated
once the boundaries are bracketed in the search.
</p>
</td></tr>
<tr><td><code id="glrSearch_+3A_ngrid">nGrid</code></td>
<td>

<p>The number of grid points to use, default 5
</p>
</td></tr>
<tr><td><code id="glrSearch_+3A_verbose">verbose</code></td>
<td>

<p>A logical flag indicating if you want verbose output during
search. Useful for situations where the code gets confused.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>One should not use this code without a basic understanding of the
Shih, Lai, Heyse and Chen paper cited below, particularly the section
on the pre-licensure vaccine trials.
</p>
<p>As the search can be computationally intensive, the program needs to
use some variables internally by reference, particularly large tables
that stay constant.
</p>
<p>In our experiments, starting off with the default step size has
usually worked, but in other cases the step size and the maximum
number of iterations may need to be adjusted.
</p>


<h3>Value</h3>

<table>
<tr><td><code>b1</code></td>
<td>
<p>The explored values of the futility boundary
<code class="reqn">b_1</code> (corresponds to the boundary <code class="reqn">b_1</code> in the appendix of reference)</p>
</td></tr>
<tr><td><code>b0</code></td>
<td>
<p>The explored values of the rejection boundary
<code class="reqn">b_0</code> (corresponds to the boundary <code class="reqn">b_0</code> in the appendix of reference)</p>
</td></tr>
<tr><td><code>estimate</code></td>
<td>
<p>The estimated <code class="reqn">\alpha</code> and <code class="reqn">\beta</code>
values corresponding to the explored boundaries (a 2-column matrix);
first column is <code class="reqn">\alpha</code>, second is <code class="reqn">\beta</code></p>
</td></tr>
<tr><td><code>glrTables</code></td>
<td>
<p>The constant values of the log likelihoods under
<code class="reqn">p_0</code>, <code class="reqn">p_1</code> and the estimate probability of terminating at that
step. The first two, are, in turn, lists of length <code class="reqn">n</code> where <code class="reqn">n</code>
is the maximum number of adverse events that might be needed for the
test. The last element is a matrix of 2 columns, specifying the
probability of terminating at each value of <code class="reqn">n</code></p>
</td></tr>
<tr><td><code>alphaTable</code></td>
<td>
<p>a matrix (nGrid x nGrid) of <code class="reqn">\alpha</code> values
corresponding to the combinations of boundaries <code class="reqn">b</code> and <code class="reqn">a</code>
(which are the row and column names of the matrix). This is computed
only if <code>gridIt=TRUE</code> </p>
</td></tr>
<tr><td><code>betaTable</code></td>
<td>
<p>a matrix (nGrid x nGrid) of <code class="reqn">\beta</code> values
corresponding to the combinations of boundaries <code class="reqn">b</code> and <code class="reqn">a</code>
(which are the row and column names of the matrix). This is computed
only if <code>gridIt=TRUE</code></p>
</td></tr>
<tr><td><code>b1Vals</code></td>
<td>
<p>the vector of <code class="reqn">b_1</code> (or equivalently <code class="reqn">b_1</code>) values
used in the grid, computed only if <code>gridIt=TRUE</code></p>
</td></tr>
<tr><td><code>b0Vals</code></td>
<td>
<p>the vector of <code class="reqn">b_0</code> (or equivalently <code class="reqn">b_0</code>) values
used in the grid, computed only if <code>gridIt=TRUE</code></p>
</td></tr>
<tr><td><code>iterations</code></td>
<td>
<p>The number of iterations actually used</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Balasubramanian Narasimhan
</p>


<h3>References</h3>

<p>&ldquo;Sequential Generalized Likelihood Ratio Tests for Vaccine Safety Evaluation&rdquo;
doi: <a href="https://doi.org/10.1002/sim.4036">10.1002/sim.4036</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(sglr)
result &lt;- glrSearch(p=c(.5, .75), alpha=0.05, beta=0.10)

result &lt;- glrSearch(p=c(.5, .75), alpha=0.05, beta=0.10, verbose=TRUE)

result &lt;- glrSearch(p=c(.5, .75), alpha=0.05, beta=0.10, gridIt=TRUE)
print(result$alphaTable)
print(result$betaTable)

## takes a while
result &lt;- glrSearch(p=c(.5, 2/3), alpha=0.05, beta=0.10)
print(names(result))

##result &lt;- glrSearch(p=c(.5, 2/3), alpha=0.05, beta=0.10, gridIt=TRUE)
##print(result$alphaTable)
##print(result$betaTable)
</code></pre>

<hr>
<h2 id='plotBoundary'>
A function to plot the boundary of the decision region
</h2><span id='topic+plotBoundary'></span>

<h3>Description</h3>

<p>This function attempts to plot the boundary of the decision region, but
currently falls flat.  Will be rewritten.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plotBoundary(b1, b0, p, glrTables = NULL, tol = 1e-7,
             legend  =FALSE, textXOffset = 2, textYSkip = 2)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plotBoundary_+3A_b1">b1</code></td>
<td>

<p>The acceptance boundary value (corresponds to the boundary <code class="reqn">b_1</code> in the appendix of reference)
</p>
</td></tr>
<tr><td><code id="plotBoundary_+3A_b0">b0</code></td>
<td>

<p>The rejection boundary value (corresponds to the boundary <code class="reqn">b_0</code> in the appendix of reference)
</p>
</td></tr>
<tr><td><code id="plotBoundary_+3A_p">p</code></td>
<td>

<p>The vector of probabilities, <code class="reqn">(p_0, p_1)</code> with <code class="reqn">p_0 &lt; p_1</code>.
</p>
</td></tr>
<tr><td><code id="plotBoundary_+3A_glrtables">glrTables</code></td>
<td>

<p>A previously computed set of likelihood functions, to speed up
computation for the <em>same hypothesis testing problem</em>. This can
speed up computations.
</p>
</td></tr>
<tr><td><code id="plotBoundary_+3A_tol">tol</code></td>
<td>

<p>The tolerance, default of 1e-7
</p>
</td></tr>
<tr><td><code id="plotBoundary_+3A_legend">legend</code></td>
<td>

<p>A flag indicating if a legend is desired or not, default false
</p>
</td></tr>
<tr><td><code id="plotBoundary_+3A_textxoffset">textXOffset</code></td>
<td>

<p>Horizontal offset for legend text
</p>
</td></tr>
<tr><td><code id="plotBoundary_+3A_textyskip">textYSkip</code></td>
<td>

<p>Vertical skip for legend text
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This essentially computes the recursion and the probabilities of hitting
the boundaries and returns a ggplot2 object
</p>


<h3>Value</h3>

<p>A ggplot2 object
</p>


<h3>Author(s)</h3>

<p>Balasubramanian Narasimhan
</p>


<h3>See Also</h3>

<p>See Also <code><a href="#topic+glrSearch">glrSearch</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>plotBoundary(b1=2.8, b0=3.3, p=c(.5, .75))
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
