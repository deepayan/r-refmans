<!DOCTYPE html><html lang="en"><head><title>Help for package solaR2</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {solaR2}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#solaR2-package'>
<p>Solar Radiation and Photovoltaic Systems with R version 2</p></a></li>
<li><a href='#A1_calcSol'>
<p>Apparent movement of the Sun from the Earth</p></a></li>
<li><a href='#A2_calcG0'><p>Irradiation and irradiance on the horizontal plane.</p></a></li>
<li><a href='#A3_calcGef'><p>Irradiation and irradiance on the generator plane.</p></a></li>
<li><a href='#A4_prodGCPV'><p>Performance of a grid connected PV system.</p></a></li>
<li><a href='#A5_prodPVPS'>
<p>Performance of a PV pumping system</p></a></li>
<li><a href='#A6_calcShd'><p>Shadows on PV systems.</p></a></li>
<li><a href='#A7_optimShd'>
<p>Shadows calculation for a set of distances between elements of a PV grid connected plant.</p></a></li>
<li><a href='#A8_Meteo2Meteo'><p>Transformation of intradaily meteorological data into daily and</p>
daily into monthly data.</a></li>
<li><a href='#A8_readBD'><p>Daily or intradaily values of global horizontal irradiation and ambient</p>
temperature from a local file or a data.frame.</a></li>
<li><a href='#A8_readG0dm'><p>Monthly mean values of global horizontal irradiation.</p></a></li>
<li><a href='#A8_readSIAR'>
<p>Meteorological data from the SIAR network.</p></a></li>
<li><a href='#B1_Meteo-class'><p>Class &quot;Meteo&quot;</p></a></li>
<li><a href='#B2_Sol-class'><p>Class &quot;Sol&quot;: Apparent movement of the Sun from the Earth</p></a></li>
<li><a href='#B3_G0-class'><p>Class &quot;G0&quot;: irradiation and irradiance on the horizontal plane.</p></a></li>
<li><a href='#B4_Gef-class'><p>Class &quot;Gef&quot;: irradiation and irradiance on the generator plane.</p></a></li>
<li><a href='#B5_ProdGCPV-class'><p>Class &quot;ProdGCPV&quot;: performance of a grid connected PV system.</p></a></li>
<li><a href='#B6_ProdPVPS-class'><p>Class &quot;ProdPVPS&quot;: performance of a PV pumping system.</p></a></li>
<li><a href='#B7_Shade-class'><p>Class &quot;Shade&quot;: shadows in a PV system.</p></a></li>
<li><a href='#C_corrFdKt'><p>Correlations between the fraction of diffuse irradiation and the</p>
clearness index.</a></li>
<li><a href='#C_fBTd'><p>Daily time base</p></a></li>
<li><a href='#C_fBTi'><p>Intra-daily time base</p></a></li>
<li><a href='#C_fCompD'><p>Components of daily global solar irradiation on a horizontal surface</p></a></li>
<li><a href='#C_fCompI'>
<p>Calculation of solar irradiance on a horizontal surface</p></a></li>
<li><a href='#C_fInclin'>
<p>Solar irradiance on an inclined surface</p></a></li>
<li><a href='#C_fProd'>
<p>Performance of a PV system</p></a></li>
<li><a href='#C_fPump'><p>Performance of a centrifugal pump</p></a></li>
<li><a href='#C_fSolD'>
<p>Daily apparent movement of the Sun from the Earth</p></a></li>
<li><a href='#C_fSolI'>
<p>Instantaneous apparent movement of the Sun from the Earth</p></a></li>
<li><a href='#C_fSombra'><p>Shadows on PV systems</p></a></li>
<li><a href='#C_fTemp'>
<p>Intradaily evolution of ambient temperature</p></a></li>
<li><a href='#C_fTheta'>
<p>Angle of incidence of solar irradiation on a inclined surface</p></a></li>
<li><a href='#C_HQCurve'><p>H-Q curves of a centrifugal pump</p></a></li>
<li><a href='#C_local2Solar'>
<p>Local time, mean solar time and UTC time zone.</p></a></li>
<li><a href='#C_NmgPVPS'><p>Nomogram of a photovoltaic pumping system</p></a></li>
<li><a href='#C_sample2Diff'><p>Small utilities for difftime objects.</p></a></li>
<li><a href='#C_solarAngles'><p>Solar angles</p></a></li>
<li><a href='#C_utils-angle'><p>Conversion between angle units.</p></a></li>
<li><a href='#C_utils-time'><p>Utilities for time indexes.</p></a></li>
<li><a href='#D_as.data.tableD-methods'><p>Methods for Function as.data.tableD</p></a></li>
<li><a href='#D_as.data.tableI-methods'><p>Methods for Function as.data.tableI</p></a></li>
<li><a href='#D_as.data.tableM-methods'><p>Methods for Function as.data.tableM</p></a></li>
<li><a href='#D_as.data.tableY-methods'><p>Methods for Function as.data.tableY</p></a></li>
<li><a href='#D_compare-methods'><p>Compare G0, Gef and ProdGCPV objects</p></a></li>
<li><a href='#D_getData-methods'><p>Methods for function getData</p></a></li>
<li><a href='#D_getG0-methods'><p>Methods for function getG0</p></a></li>
<li><a href='#D_getLat-methods'><p>Methods for Function getLat</p></a></li>
<li><a href='#D_indexD-methods'><p>Methods for Function indexD</p></a></li>
<li><a href='#D_indexI-methods'><p>Methods for Function indexI</p></a></li>
<li><a href='#D_levelplot-methods'><p>Methods for function levelplot.</p></a></li>
<li><a href='#D_Losses-methods'><p>Losses of a GCPV system</p></a></li>
<li><a href='#D_mergesolaR-methods'><p>Merge solaR objects</p></a></li>
<li><a href='#D_shadeplot-methods'><p>Methods for Function shadeplot</p></a></li>
<li><a href='#D_window-methods'><p>Methods for extracting a time window</p></a></li>
<li><a href='#D_writeSolar-methods'><p>Exporter of solaR results</p></a></li>
<li><a href='#D_xyplot-methods'><p>Methods for function xyplot in Package &lsquo;solaR&rsquo;</p></a></li>
<li><a href='#E_aguiar'><p>Markov Transition Matrices for the Aguiar etal. procedure</p></a></li>
<li><a href='#E_helios'><p>Daily irradiation and ambient temperature from the Helios-IES database</p></a></li>
<li><a href='#E_prodEx'><p>Productivity of a set of PV systems of a PV plant.</p></a></li>
<li><a href='#E_pumpCoef'><p>Coefficients of centrifugal pumps.</p></a></li>
<li><a href='#E_SIAR'><p>Data on the stations that make up the SIAR network</p></a></li>
<li><a href='#E_solaR.theme'><p>solaR theme</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Radiation and Photovoltaic Systems</td>
</tr>
<tr>
<td>Version:</td>
<td>0.11</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>Description:</td>
<td>Provides tools for calculating solar geometry, solar radiation on horizontal and inclined planes, and simulating the performance of various photovoltaic (PV) systems. Supports daily and intradaily irradiation data, enabling detailed analysis of grid-connected and water-pumping PV systems, including shading effects and solar angle calculations. </td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://solarization.github.io/solaR2/">https://solarization.github.io/solaR2/</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/solarization/solaR2/issues">https://github.com/solarization/solaR2/issues</a></td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>LazyData:</td>
<td>yes</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 4.0.0), lattice</td>
</tr>
<tr>
<td>Imports:</td>
<td>data.table, latticeExtra, RColorBrewer, httr2, graphics,
grDevices, stats, methods, utils</td>
</tr>
<tr>
<td>Suggests:</td>
<td>zoo, sp, raster, rasterVis, tdr, meteoForecast, jsonlite,
testthat (&ge; 3.0.0)</td>
</tr>
<tr>
<td>Config/testthat/edition:</td>
<td>3</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2025-01-16 20:09:30 UTC; Fran</td>
</tr>
<tr>
<td>Author:</td>
<td>Oscar Perpiñán-Lamigueiro
    <a href="https://orcid.org/0000-0002-4134-7196"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [aut],
  Francisco Delgado-López [aut, cre]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Francisco Delgado-López &lt;f.delgadol@alumnos.upm.es&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2025-01-16 20:40:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='solaR2-package'>
Solar Radiation and Photovoltaic Systems with R version 2
</h2><span id='topic+solaR2-package'></span><span id='topic+solaR2'></span>

<h3>Description</h3>

<p>The <code>solaR2</code> package allows for reproducible research both for
photovoltaics (PV) systems performance and solar radiation. It
includes a set of classes, methods and functions to calculate the sun
geometry and the solar radiation incident on a photovoltaic generator
and to simulate the performance of several applications of the
photovoltaic energy. This package performs the whole calculation
procedure from both daily and intradaily global horizontal irradiation
to the final productivity of grid-connected PV systems and water
pumping PV systems.
</p>


<h3>Details</h3>

<p><code>solaRd</code> is designed using a set of <code>S4</code> classes whose core
is a group of slots with multivariate time series. The classes share a
variety of methods to access the information and several visualization
methods. In addition, the package provides a tool for the visual
statistical analysis of the performance of a large PV plant composed of
several systems.
</p>
<p>Although <code>solaRd</code> is primarily designed for time series associated
to a location defined by its latitude/longitude values and the
temperature and irradiation conditions, it can be easily combined with
spatial packages for space-time analysis.
</p>
<p><b>Please note that this package needs to set the timezone to
<code>UTC</code>. Every ‘data.table’ object created by the package will have an
index with this time zone as a synonym of mean solar time.</b>.
</p>
<p>You can check it after loading <code>solaR2</code> with:
</p>
<p><code>Sys.getenv('TZ')</code>
</p>
<p>If you need to change it, use:
</p>
<p><code>Sys.setenv(TZ = 'YourTimeZone')</code>
</p>
<p>Index of functions and classes:
</p>
<pre>
G0-class                Class "G0": irradiation and irradiance on the
                        horizontal plane.
Gef-class               Class "Gef": irradiation and irradiance on the
                        generator plane.
HQCurve                 H-Q curves of a centrifugal pump
Meteo-class             Class "Meteo"
NmgPVPS                 Nomogram of a photovoltaic pumping system
ProdGCPV-class          Class "ProdGCPV": performance of a grid
                        connected PV system.
ProdPVPS-class          Class "ProdPVPS": performance of a PV pumping
                        system.
Shade-class             Class "Shade": shadows in a PV system.
Sol-class               Class "Sol": Apparent movement of the Sun from
                        the Earth
aguiar                  Markov Transition Matrices for the Aguiar etal.
                        procedure
as.data.tableD          Methods for Function as.data.frameD
as.data.tableI          Methods for Function as.data.frameI
as.data.tableM          Methods for Function as.data.frameM
as.data.tableY          Methods for Function as.data.frameY
calcG0                  Irradiation and irradiance on the horizontal
                        plane.
calcGef                 Irradiation and irradiance on the generator
                        plane.
calcShd                 Shadows on PV systems.
calcSol                 Apparent movement of the Sun from the Earth
compare                 Compare G0, Gef and ProdGCPV objects
compareLosses           Losses of a GCPV system
corrFdKt                Correlations between the fraction of diffuse
                        irradiation and the clearness index.
d2r                     Conversion between angle units.
diff2Hours              Small utilities for difftime objects.
fBTd                    Daily time base
fCompD                  Components of daily global solar irradiation on
                        a horizontal surface
fCompI                  Calculation of solar irradiance on a horizontal
                        surface
fInclin                 Solar irradiance on an inclined surface
fProd                   Performance of a PV system
fPump                   Performance of a centrifugal pump
fSolD                   Daily apparent movement of the Sun from the
                        Earth
fSolI                   Instantaneous apparent movement of the Sun from
                        the Earth
fSombra                 Shadows on PV systems
fTemp                   Intradaily evolution of ambient temperature
fTheta                  Angle of incidence of solar irradiation on a
                        inclined surface
getData                 Methods for function getData
getG0                   Methods for function getG0
getLat                  Methods for Function getLat
helios                  Daily irradiation and ambient temperature from
                        the Helios-IES database
hour                    Utilities for time indexes.
indexD                  Methods for Function indexD
indexI                  Methods for Function indexI
levelplot-methods       Methods for function levelplot.
local2Solar             Local time, mean solar time and UTC time zone.
mergesolaR              Merge solaR objects
optimShd                Shadows calculation for a set of distances
                        between elements of a PV grid connected plant.
prodEx                  Productivity of a set of PV systems of a PV
                        plant.
prodGCPV                Performance of a grid connected PV system.
prodPVPS                Performance of a PV pumping system
pumpCoef                Coefficients of centrifugal pumps.
readBD                  Daily or intradaily values of global horizontal
                        irradiation and ambient temperature from a
                        local file or a data.frame.
readG0dm                Monthly mean values of global horizontal
                        irradiation.
readSIAR                Meteorological data exported from the SIAR network
shadeplot               Methods for Function shadeplot
solaR.theme             solaR theme
window                  Methods for extracting a time window
writeSolar              Exporter of solaR results

xyplot-methods          Methods for function xyplot in Package 'solaR'
</pre>


<h3>Author(s)</h3>

<p>Oscar Perpiñán Lamigueiro,
Francisco Delgado López.
</p>

<hr>
<h2 id='A1_calcSol'>
Apparent movement of the Sun from the Earth
</h2><span id='topic+calcSol'></span>

<h3>Description</h3>

<p>Compute the apparent movement of the Sun from the Earth with the
functions <code><a href="#topic+fSolD">fSolD</a></code> and <code><a href="#topic+fSolI">fSolI</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>calcSol(lat, BTd, sample = 'hour', BTi,
        EoT = TRUE, keep.night = TRUE,
        method = 'michalsky')
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="A1_calcSol_+3A_lat">lat</code></td>
<td>
<p>Latitude (degrees) of the point of the Earth where
calculations are needed. 
It is positive for locations above the Equator.</p>
</td></tr>
<tr><td><code id="A1_calcSol_+3A_btd">BTd</code></td>
<td>
<p>Daily time base, a <code>POSIXct</code> object which  may be
the result of <code><a href="#topic+fBTd">fBTd</a></code>. It is not considered if <code>BTi</code>
is provided.</p>
</td></tr>
<tr><td><code id="A1_calcSol_+3A_sample">sample</code></td>
<td>
<p>Increment of the intradaily sequence. It is a character
string, containing one of ‘&quot;sec&quot;’, ‘&quot;min&quot;’, ‘&quot;hour&quot;’.
This can optionally be preceded by a (positive or
negative) integer and a space, or followed by ‘&quot;s&quot;’. It is
used by <code><a href="base.html#topic+seq.POSIXt">seq.POSIXt</a></code>.
</p>
<p>It is not considered if <code>BTi</code> is provided.</p>
</td></tr>
<tr><td><code id="A1_calcSol_+3A_bti">BTi</code></td>
<td>
<p>Intradaily time base, a <code>POSIXct</code> object to be used by
<code><a href="#topic+fSolI">fSolI</a></code>. It may be the result of <code><a href="#topic+fBTi">fBTi</a></code>.</p>
</td></tr>
<tr><td><code id="A1_calcSol_+3A_eot">EoT</code></td>
<td>
<p>logical, if <code>TRUE</code> the Equation of Time is
used. Default is TRUE.</p>
</td></tr>
<tr><td><code id="A1_calcSol_+3A_keep.night">keep.night</code></td>
<td>
<p>logical, if <code>TRUE</code> (default) the night is
included in the time series.</p>
</td></tr>
<tr><td><code id="A1_calcSol_+3A_method">method</code></td>
<td>
<p><code>character</code>, method for the sun geometry
calculations to be chosen from 'cooper', 'spencer', 'michalsky' and
'strous'. See references for details.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code><a href="#topic+Sol-class">Sol-class</a></code> object.</p>


<h3>Author(s)</h3>

<p>Oscar Perpiñán Lamigueiro,
Francisco Delgado López.</p>


<h3>References</h3>

 <ul>
<li><p>Cooper, P.I., Solar Energy, 12, 3
(1969). &quot;The Absorption of Solar Radiation in Solar Stills&quot;
</p>
</li>
<li><p>Spencer, Search 2 (5), 172,
<a href="https://www.mail-archive.com/sundial@uni-koeln.de/msg01050.html">https://www.mail-archive.com/sundial@uni-koeln.de/msg01050.html</a>
</p>
</li>
<li><p>Strous:
<a href="https://www.aa.quae.nl/en/reken/zonpositie.html">https://www.aa.quae.nl/en/reken/zonpositie.html</a>
</p>
</li>
<li><p>Michalsky, J., 1988: The Astronomical Almanac's algorithm for
approximate solar position (1950-2050), Solar Energy 40, 227-235
</p>
</li>
<li><p> Perpiñán, O, Energía Solar Fotovoltaica, 2015.
(<a href="https://oscarperpinan.github.io/esf/">https://oscarperpinan.github.io/esf/</a>)
</p>
</li>
<li><p> Perpiñán, O. (2012), &quot;solaR: Solar Radiation and Photovoltaic
Systems with R&quot;, Journal of Statistical Software, 50(9), 1-32,
<a href="https://doi.org/10.18637/jss.v050.i09">doi:10.18637/jss.v050.i09</a> </p>
</li></ul>
 

<h3>Examples</h3>

<pre><code class='language-R'>library("data.table")


BTd &lt;- fBTd(mode &lt;- 'serie')

lat &lt;- 37.2
sol &lt;- calcSol(lat, BTd[100])
print(as.data.tableD(sol))

library(lattice)
xyplot(as.data.tableI(sol))

solStrous &lt;- calcSol(lat, BTd[100], method = 'strous')
print(as.data.tableD(solStrous))

solSpencer &lt;- calcSol(lat, BTd[100], method = 'spencer')
print(as.data.tableD(solSpencer))

solCooper &lt;- calcSol(lat, BTd[100], method = 'cooper')
print(as.data.tableD(solCooper))
</code></pre>

<hr>
<h2 id='A2_calcG0'>Irradiation and irradiance on the horizontal plane.</h2><span id='topic+calcG0'></span>

<h3>Description</h3>

<p>This function obtains the global, diffuse and direct irradiation and
irradiance on the horizontal plane from the values of <em>daily</em> and
<em>intradaily</em> global irradiation on the horizontal plane.
It makes use of the functions <code><a href="#topic+calcSol">calcSol</a></code>,
<code><a href="#topic+fCompD">fCompD</a></code>, <code><a href="#topic+fCompI">fCompI</a></code>, <code><a href="#topic+fBTd">fBTd</a></code>
and <code><a href="#topic+readBDd">readBDd</a></code> (or equivalent).
</p>
<p>Besides, if information about maximum and minimum temperatures values are available it obtains a series of temperature values with <code><a href="#topic+fTemp">fTemp</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>
calcG0(lat, modeRad = 'prom', dataRad,
       sample = 'hour', keep.night = TRUE,
       sunGeometry = 'michalsky',
       corr, f, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="A2_calcG0_+3A_lat">lat</code></td>
<td>
<p>numeric, latitude (degrees) of the point of the Earth where calculations are needed. It is positive for locations above the Equator.</p>
</td></tr>
<tr><td><code id="A2_calcG0_+3A_moderad">modeRad</code></td>
<td>
<p>A character string, describes the kind of source data of the
global irradiation and ambient temperature.
</p>
<p>It can be <code>modeRad = 'prom'</code> for monthly mean calculations. With
this option, a set of 12 values inside <code>dataRad</code> must be
provided, as defined in <code><a href="#topic+readG0dm">readG0dm</a></code>.
</p>
<p><code>modeRad = 'aguiar'</code> uses a set of 12 monthly average values
(provided with <code>dataRad</code>) and produces a synthetic daily
irradiation time series following the procedure by Aguiar etal. (see
reference below).
</p>
<p>If <code>modeRad = 'bd'</code> the information of <em>daily</em> irradiation is read from a
file, a <code>data.table</code> defined by <code>dataRad</code>, a <code>zoo</code> or a
<code>Meteo</code> object. (See <code><a href="#topic+readBDd">readBDd</a></code>, <code><a href="#topic+dt2Meteo">dt2Meteo</a></code>
and <code><a href="#topic+zoo2Meteo">zoo2Meteo</a></code> for details).
</p>
<p>If <code>modeRad = 'bdI'</code> the information of <em>intradaily</em> irradiation is read from a
file, a <code>data.table</code> defined by <code>dataRad</code>, a <code>zoo</code> or a
<code>Meteo</code> object. (See <code><a href="#topic+readBDi">readBDi</a></code>,
<code><a href="#topic+dt2Meteo">dt2Meteo</a></code> and <code><a href="#topic+zoo2Meteo">zoo2Meteo</a></code> for details).
</p>
</td></tr>
<tr><td><code id="A2_calcG0_+3A_datarad">dataRad</code></td>
<td>

<ul>
<li><p>If <code>modeRad = 'prom'</code> or <code>modeRad = 'aguiar'</code>, a
numeric with 12 values or a named list whose components will be
processed with <code><a href="#topic+readG0dm">readG0dm</a></code>.
</p>
</li>
<li><p>If <code>modeRad = 'bd'</code> a character (name of the file to be
read with <code>readBDd</code>), a <code>data.table</code> (to be processed with
<code>dt2Meteo</code>), a <code>zoo</code> (to be processed with
<code>zoo2Meteo</code>), a <code>Meteo</code> object, or a <code>list</code> as
defined by <code><a href="#topic+readBDd">readBDd</a></code>, <code><a href="#topic+dt2Meteo">dt2Meteo</a></code> or
<code><a href="#topic+zoo2Meteo">zoo2Meteo</a></code>. The resulting object will include a column
named <code>Ta</code>, with information about ambient temperature.
</p>
</li>
<li><p>If <code>modeRad = 'bdI'</code> a character (name of the file to
be read with <code>readBDi</code>), a <code>data.table</code> (to be processed
with <code>dt2Meteo</code>), a <code>zoo</code> (to be processed with
<code>zoo2Meteo</code>), a <code>Meteo</code> object, or a <code>list</code> as
defined by <code><a href="#topic+readBDi">readBDi</a></code>, <code><a href="#topic+dt2Meteo">dt2Meteo</a></code> or
<code><a href="#topic+zoo2Meteo">zoo2Meteo</a></code>. The resulting object will include a column
named <code>Ta</code>, with information about ambient temperature.
</p>
</li></ul>
</td></tr>
<tr><td><code id="A2_calcG0_+3A_sample">sample</code></td>
<td>
<p><code>character</code>, containing one of ‘&quot;sec&quot;’, ‘&quot;min&quot;’,
‘&quot;hour&quot;’.  This can optionally be preceded by a (positive or
negative) integer and a space, or followed by ‘&quot;s&quot;’ (used by
<code><a href="base.html#topic+seq.POSIXt">seq.POSIXt</a></code>). It is not used when <code>modeRad = "bdI"</code>.</p>
</td></tr>
<tr><td><code id="A2_calcG0_+3A_keep.night">keep.night</code></td>
<td>
<p><code>logical</code>. When it is TRUE (default) the
time series includes the night.</p>
</td></tr>
<tr><td><code id="A2_calcG0_+3A_sungeometry">sunGeometry</code></td>
<td>
<p><code>character</code>, method for the sun geometry
calculations. See <code><a href="#topic+calcSol">calcSol</a></code>, <code><a href="#topic+fSolD">fSolD</a></code> and <code><a href="#topic+fSolI">fSolI</a></code>.</p>
</td></tr>
<tr><td><code id="A2_calcG0_+3A_corr">corr</code></td>
<td>
<p>A character, the correlation between the fraction of diffuse irradiation and the
clearness index to be used.
</p>
<p>With this version several options are available, as described in
<code><a href="#topic+corrFdKt">corrFdKt</a></code>. For example, the <code><a href="#topic+FdKtPage">FdKtPage</a></code> is
selected with <code>corr = 'Page'</code> while the <code><a href="#topic+FdKtCPR">FdKtCPR</a></code> with
<code>corr = 'CPR'</code>.
</p>
<p>If <code>corr = 'user'</code> the use of a correlation
defined by a function <code>f</code> is possible.
</p>
<p>If <code>corr = 'none'</code> the object defined by <code>dataRad</code> should include
information about global, diffuse and direct daily irradiation with columns named 
<code>G0d</code>, <code>D0d</code> and <code>B0d</code>, respectively
(or <code>G0</code>, <code>D0</code> and <code>B0</code> if <code>modeRad = 'bdI'</code>).
If <code>corr</code> is missing, then it is internally set to <code>CPR</code>
when <code>modeRad = 'bd'</code>, to <code>Page</code>
when <code>modeRad = 'prom'</code> and to <code>BRL</code> when <code>modeRad = 'bdI'</code>.</p>
</td></tr>
<tr><td><code id="A2_calcG0_+3A_f">f</code></td>
<td>
<p>A function defininig a correlation between the fraction of
diffuse irradiation and the clearness index. It is only neccessary
when <code>corr = 'user'</code></p>
</td></tr>
<tr><td><code id="A2_calcG0_+3A_...">...</code></td>
<td>
<p>Additional arguments for <code><a href="#topic+fCompD">fCompD</a></code> or <code><a href="#topic+fCompI">fCompI</a></code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>G0</code> object.</p>


<h3>Author(s)</h3>

<p>Oscar Perpiñán Lamigueiro,
Francisco Delgado López.</p>


<h3>References</h3>


<ul>
<li><p> Perpiñán, O, Energía Solar Fotovoltaica, 2015.
(<a href="https://oscarperpinan.github.io/esf/">https://oscarperpinan.github.io/esf/</a>)
</p>
</li>
<li><p> Perpiñán, O. (2012), &quot;solaR: Solar Radiation and Photovoltaic
Systems with R&quot;, Journal of Statistical Software, 50(9), 1-32,
<a href="https://doi.org/10.18637/jss.v050.i09">doi:10.18637/jss.v050.i09</a>
</p>
</li>
<li><p> Aguiar, Collares-Pereira and Conde, &quot;Simple procedure for
generating sequences of daily radiation values using a library of
Markov transition matrices&quot;, Solar Energy, Volume 40, Issue 3, 1988, Pages 269–279</p>
</li></ul>



<h3>See Also</h3>

<p><code><a href="#topic+calcSol">calcSol</a></code>,
<code><a href="#topic+fCompD">fCompD</a></code>,
<code><a href="#topic+fCompI">fCompI</a></code>,
<code><a href="#topic+readG0dm">readG0dm</a></code>,
<code><a href="#topic+readBDd">readBDd</a></code>,
<code><a href="#topic+readBDi">readBDi</a></code>,
<code><a href="#topic+dt2Meteo">dt2Meteo</a></code>,
<code><a href="#topic+corrFdKt">corrFdKt</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library("data.table")


G0dm &lt;- c(2.766, 3.491, 4.494, 5.912, 6.989, 7.742, 7.919, 7.027, 5.369, 3.562, 2.814, 2.179)*1000;
Ta &lt;- c(10, 14.1, 15.6, 17.2, 19.3, 21.2, 28.4, 29.9, 24.3, 18.2, 17.2, 
  15.2)

g0 &lt;- calcG0(lat = 37.2, modeRad = 'prom', dataRad = list(G0dm = G0dm, Ta = Ta))
print(g0)
xyplot(g0)

## Aguiar et al.

g0 &lt;- calcG0(lat = 37.2, modeRad = 'aguiar', dataRad = G0dm)
print(g0)
xyplot(g0)

##Now the G0I component of g0 is used as
##the bdI argument to calcG0 in order to
##test the intradaily correlations of fd-kt

BDi = as.data.tableI(g0)
BDi$Ta = 25 ##Information about temperature must be contained in BDi

g02 &lt;- calcG0(lat = 37.2, 
            modeRad = 'bdI', 
            dataRad = list(lat = 37.2, file = BDi), 
            corr = 'none')

print(g02)

g03 &lt;- calcG0(lat = 37.2, 
            modeRad = 'bdI', 
            dataRad = list(lat = 37.2, file = BDi), 
            corr = 'BRL')
print(g03)

xyplot(Fd ~ Kt, data = g03, pch = 19, alpha = 0.3)
</code></pre>

<hr>
<h2 id='A3_calcGef'>Irradiation and irradiance on the generator plane.</h2><span id='topic+calcGef'></span>

<h3>Description</h3>

<p>This function obtains the global, diffuse and direct irradiation and
irradiance on the generator plane from the values of <em>daily</em> or <em>intradaily</em> global
irradiation on the horizontal plane. It makes use of the functions
<code><a href="#topic+calcG0">calcG0</a></code>, <code><a href="#topic+fTheta">fTheta</a></code>,
<code><a href="#topic+fInclin">fInclin</a></code>. Besides, it can calculate the shadows effect with
the <code><a href="#topic+calcShd">calcShd</a></code> function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>calcGef(lat,
        modeTrk = 'fixed',
        modeRad = 'prom',
        dataRad,
        sample = 'hour',
        keep.night = TRUE,
        sunGeometry = 'michalsky',
        corr, f,
        betaLim = 90, beta = abs(lat)-10, alpha = 0,
        iS = 2, alb = 0.2, horizBright = TRUE, HCPV = FALSE,
        modeShd = '',
        struct = list(),
        distances = data.table(),
        ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="A3_calcGef_+3A_lat">lat</code></td>
<td>
<p>numeric, latitude (degrees) of the point of the Earth where calculations are needed. It is positive for locations above the Equator.</p>
</td></tr>
<tr><td><code id="A3_calcGef_+3A_modetrk">modeTrk</code></td>
<td>
<p>character, to be chosen from <code>'fixed'</code>,
<code>'two'</code> or <code>'horiz'</code>. When <code>modeTrk = 'fixed'</code> the
surface is fixed (inclination and azimuth angles are constant). The
performance of a two-axis tracker is calculated with <code>modeTrk =
      'two'</code>, and <code>modeTrk = 'horiz'</code> is the option for an horizontal
N-S tracker. Its default value is <code>modeTrk = 'fixed'</code></p>
</td></tr>
<tr><td><code id="A3_calcGef_+3A_moderad">modeRad</code>, <code id="A3_calcGef_+3A_datarad">dataRad</code></td>
<td>
<p>Information about the source data of the
global irradiation. See <code><a href="#topic+calcG0">calcG0</a></code> for details.</p>
</td></tr>
<tr><td><code id="A3_calcGef_+3A_sample">sample</code>, <code id="A3_calcGef_+3A_keep.night">keep.night</code></td>
<td>
<p>See <code><a href="#topic+calcSol">calcSol</a></code> for details.</p>
</td></tr>
<tr><td><code id="A3_calcGef_+3A_sungeometry">sunGeometry</code></td>
<td>
<p><code>character</code>, method for the sun geometry
calculations. See <code><a href="#topic+calcSol">calcSol</a></code>, <code><a href="#topic+fSolD">fSolD</a></code> and <code><a href="#topic+fSolI">fSolI</a></code>.</p>
</td></tr>
<tr><td><code id="A3_calcGef_+3A_corr">corr</code>, <code id="A3_calcGef_+3A_f">f</code></td>
<td>
<p>See <code><a href="#topic+calcG0">calcG0</a></code> for details.</p>
</td></tr>
<tr><td><code id="A3_calcGef_+3A_beta">beta</code></td>
<td>
<p>numeric, inclination angle of the surface
(degrees). It is only needed when <code>modeTrk = 'fixed'</code>.</p>
</td></tr>
<tr><td><code id="A3_calcGef_+3A_betalim">betaLim</code></td>
<td>
<p>numeric, maximum value of the inclination angle
for a tracking surface. Its default value is 90 (no
limitation))</p>
</td></tr>
<tr><td><code id="A3_calcGef_+3A_alpha">alpha</code></td>
<td>
<p>numeric, azimuth angle of the surface (degrees). It is
measured from the south (<code>alpha = 0</code>), and it is negative to the
east and positive to the west. It is only needed when
<code>modeTrk = 'fixed'</code>. Its default value is <code>alpha = 0</code></p>
</td></tr>
<tr><td><code id="A3_calcGef_+3A_is">iS</code></td>
<td>
<p>integer, degree of dirtiness. Its value must be included in
the set (1,2,3,4). <code>iS = 1</code> corresponds to a clean surface while
<code>iS = 4</code> is the selection for a dirty surface. Its default value is
2.</p>
</td></tr>
<tr><td><code id="A3_calcGef_+3A_alb">alb</code></td>
<td>
<p>numeric, albedo reflection coefficient. Its default value is 0.2</p>
</td></tr>
<tr><td><code id="A3_calcGef_+3A_modeshd">modeShd</code>, <code id="A3_calcGef_+3A_struct">struct</code>, <code id="A3_calcGef_+3A_distances">distances</code></td>
<td>
<p>See <code><a href="#topic+calcShd">calcShd</a></code> for
details.</p>
</td></tr>
<tr><td><code id="A3_calcGef_+3A_horizbright">horizBright</code></td>
<td>
<p>logical, if TRUE, the horizon brightness correction proposed by Reind et al. is used.</p>
</td></tr>
<tr><td><code id="A3_calcGef_+3A_hcpv">HCPV</code></td>
<td>
<p>logical, if TRUE the diffuse and albedo components of the
<em>effective</em> irradiance are set to zero. HCPV is the acronym of
High Concentration PV system.</p>
</td></tr>
<tr><td><code id="A3_calcGef_+3A_...">...</code></td>
<td>
<p>Additional arguments for <code><a href="#topic+calcSol">calcSol</a></code> and
<code><a href="#topic+calcG0">calcG0</a></code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>Gef</code> object.</p>


<h3>Author(s)</h3>

<p>Oscar Perpiñán Lamigueiro,
Francisco Delgado López.</p>


<h3>References</h3>


<ul>
<li><p> Hay, J. E. and McKay, D. C.: Estimating Solar Irradiance on Inclined Surfaces: A Review and Assessment of Methodologies. Int. J. Solar Energy, (3):pp. 203, 1985.
</p>
</li>
<li><p> Martin, N. and Ruiz, J.M.: Calculation of the PV modules angular losses under field conditions by means of an analytical model. Solar Energy Materials &amp; Solar Cells, 70:25–38, 2001.
</p>
</li>
<li><p> D. T. Reindl and W. A. Beckman and J. A. Duffie: Evaluation of
hourly tilted surface radiation models, Solar Energy, 45:9-17,
1990.
</p>
</li>
<li><p> Perpiñán, O, Energía Solar Fotovoltaica, 2015.
(<a href="https://oscarperpinan.github.io/esf/">https://oscarperpinan.github.io/esf/</a>)
</p>
</li>
<li><p> Perpiñán, O. (2012), &quot;solaR: Solar Radiation and Photovoltaic
Systems with R&quot;, Journal of Statistical Software, 50(9), 1-32,
<a href="https://doi.org/10.18637/jss.v050.i09">doi:10.18637/jss.v050.i09</a>
</p>
</li></ul>


<h3>See Also</h3>

<p><code><a href="#topic+calcG0">calcG0</a></code>,
<code><a href="#topic+fTheta">fTheta</a></code>,
<code><a href="#topic+fInclin">fInclin</a></code>,
<code><a href="#topic+calcShd">calcShd</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library("data.table")


lat &lt;- 37.2

###12 Average days.

G0dm = c(2.766, 3.491, 4.494, 5.912, 6.989, 7.742, 7.919, 7.027, 5.369,
         3.562, 2.814, 2.179)*1000;
Ta = c(10, 14.1, 15.6, 17.2, 19.3, 21.2, 28.4, 29.9, 24.3, 18.2, 17.2,
       15.2)

##Fixed surface, default values of inclination and azimuth.

gef &lt;- calcGef(lat = lat, modeRad = 'prom', dataRad = list(G0dm = G0dm, Ta = Ta))
print(gef)
xyplot(gef)

##Two-axis surface, no limitation angle.

gef2 &lt;- calcGef(lat = lat, modeRad = 'prom',
                dataRad = list(G0dm = G0dm, Ta = Ta),
                modeTrk = 'two')
print(gef2)
xyplot(gef2)

struct = list(W = 23.11, L = 9.8, Nrow = 2, Ncol = 8)
distances = data.table(Lew = 40, Lns = 30, H = 0)

gefShd &lt;- calcGef(lat = lat, modeRad = 'prom',
                  dataRad = list(G0dm = G0dm, Ta = Ta),
                  modeTrk = 'two',
                  modeShd = c('area', 'prom'), 
                  struct = struct, distances = distances)
print(gefShd)
</code></pre>

<hr>
<h2 id='A4_prodGCPV'>Performance of a grid connected PV system.</h2><span id='topic+prodGCPV'></span>

<h3>Description</h3>

<p>Compute every step from solar angles to effective irradiance to calculate the performance of a grid connected PV system.</p>


<h3>Usage</h3>

<pre><code class='language-R'>prodGCPV(lat,
         modeTrk = 'fixed',
         modeRad = 'prom',
         dataRad,
         sample = 'hour',
         keep.night = TRUE,
         sunGeometry = 'michalsky',
         corr, f,
         betaLim = 90, beta = abs(lat)-10, alpha = 0,
         iS = 2, alb = 0.2, horizBright = TRUE, HCPV = FALSE,
         module = list(),
         generator = list(),
         inverter = list(),
         effSys = list(),
         modeShd = '',
         struct = list(),
         distances = data.table(),
         ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="A4_prodGCPV_+3A_lat">lat</code></td>
<td>
<p>numeric, latitude (degrees) of the point of the Earth where calculations are needed. It is positive for locations above the Equator.</p>
</td></tr>
<tr><td><code id="A4_prodGCPV_+3A_modetrk">modeTrk</code></td>
<td>
<p>A character string, describing the tracking method
of the generator. See <code><a href="#topic+calcGef">calcGef</a></code> for details.</p>
</td></tr>
<tr><td><code id="A4_prodGCPV_+3A_moderad">modeRad</code>, <code id="A4_prodGCPV_+3A_datarad">dataRad</code></td>
<td>
<p>Information about the source data of the
global irradiation. See <code><a href="#topic+calcG0">calcG0</a></code> for details.</p>
</td></tr>
<tr><td><code id="A4_prodGCPV_+3A_sample">sample</code>, <code id="A4_prodGCPV_+3A_keep.night">keep.night</code></td>
<td>
<p>See <code><a href="#topic+calcSol">calcSol</a></code> for details.</p>
</td></tr>
<tr><td><code id="A4_prodGCPV_+3A_sungeometry">sunGeometry</code></td>
<td>
<p><code>character</code>, method for the sun geometry
calculations. See <code><a href="#topic+calcSol">calcSol</a></code>, <code><a href="#topic+fSolD">fSolD</a></code> and <code><a href="#topic+fSolI">fSolI</a></code>.</p>
</td></tr>
<tr><td><code id="A4_prodGCPV_+3A_corr">corr</code>, <code id="A4_prodGCPV_+3A_f">f</code></td>
<td>
<p>See <code><a href="#topic+calcG0">calcG0</a></code> for details.</p>
</td></tr>
<tr><td><code id="A4_prodGCPV_+3A_betalim">betaLim</code>, <code id="A4_prodGCPV_+3A_beta">beta</code>, <code id="A4_prodGCPV_+3A_alpha">alpha</code>, <code id="A4_prodGCPV_+3A_is">iS</code>, <code id="A4_prodGCPV_+3A_alb">alb</code>, <code id="A4_prodGCPV_+3A_horizbright">horizBright</code>, <code id="A4_prodGCPV_+3A_hcpv">HCPV</code></td>
<td>
<p>See <code><a href="#topic+calcGef">calcGef</a></code> for details.</p>
</td></tr>
<tr><td><code id="A4_prodGCPV_+3A_module">module</code></td>
<td>
<p>list of numeric values with information about the PV module, </p>

<dl>
<dt><code>Vocn</code></dt><dd><p>open-circuit voltage of the module at Standard
Test Conditions (default value 57.6 volts.)</p>
</dd>
<dt><code>Iscn</code></dt><dd><p>short circuit current of the module at Standard
Test Conditions (default value 4.7 amperes.)</p>
</dd>
<dt><code>Vmn</code></dt><dd><p>maximum power point voltage of the module at
Standard Test Conditions (default value 46.08 amperes.)</p>
</dd>
<dt><code>Imn</code></dt><dd><p>Maximum power current of the module at Standard
Test Conditions (default value 4.35 amperes.)</p>
</dd>
<dt><code>Ncs</code></dt><dd><p>number of cells in series inside the module
(default value 96)</p>
</dd>
<dt><code>Ncp</code></dt><dd><p>number of cells in parallel inside the module (default value 1)</p>
</dd>
<dt><code>CoefVT</code></dt><dd><p>coefficient of decrement of voltage of each
cell with the temperature (default value 0.0023 volts per celsius degree)</p>
</dd>
<dt><code>TONC</code></dt><dd><p>nominal operational  cell temperature, celsius
degree (default value 47).</p>
</dd>
</dl>
</td></tr>
<tr><td><code id="A4_prodGCPV_+3A_generator">generator</code></td>
<td>
<p>list of numeric values with information about the generator, </p>

<dl>
<dt><code>Nms</code></dt><dd><p>number of modules in series (default value 12)</p>
</dd>
<dt><code>Nmp</code></dt><dd><p>number of modules in parallel (default value 11)</p>
</dd>
</dl>
</td></tr>
<tr><td><code id="A4_prodGCPV_+3A_inverter">inverter</code></td>
<td>
<p>list of numeric values with information about the DC/AC inverter, </p>

<dl>
<dt><code>Ki</code></dt><dd><p>vector of three values, coefficients of the
efficiency curve of the inverter (default c(0.01, 0.025, 0.05)),
or a matrix of nine values (3x3) if there is dependence with the
voltage (see references).</p>
</dd>
<dt><code>Pinv</code></dt><dd><p>nominal inverter power (W) (default value 25000
watts.)</p>
</dd>
<dt><code>Vmin, Vmax</code></dt><dd><p> minimum and maximum voltages of the MPP
range of the inverter (default values 420 and 750 volts)</p>
</dd>
<dt><code>Gumb</code></dt><dd><p> minimum irradiance for the inverter to start
(W/m²) (default value 20 W/m²)</p>
</dd>
</dl>
</td></tr>
<tr><td><code id="A4_prodGCPV_+3A_effsys">effSys</code></td>
<td>
<p>list of numeric values with information about the system losses, </p>

<dl>
<dt><code>ModQual</code></dt><dd><p>average tolerance of the set of modules (%), default value is 3</p>
</dd>
<dt><code>ModDisp</code></dt><dd><p> module parameter disperssion losses (%), default value is 2</p>
</dd>
<dt><code>OhmDC</code></dt><dd><p> Joule losses due to the DC wiring (%), default value is 1.5</p>
</dd>
<dt><code>OhmAC</code></dt><dd><p>Joule losses due to the AC wiring (%), default value is 1.5</p>
</dd>
<dt><code>MPP</code></dt><dd><p> average error of the MPP algorithm of the inverter (%), default value is 1</p>
</dd>
<dt><code>TrafoMT</code></dt><dd><p>losses due to the MT transformer (%), default value is 1</p>
</dd>
<dt><code>Disp</code></dt><dd><p> losses due to stops of the system (%), default value is 0.5</p>
</dd>
</dl>
</td></tr>
<tr><td><code id="A4_prodGCPV_+3A_modeshd">modeShd</code>, <code id="A4_prodGCPV_+3A_struct">struct</code>, <code id="A4_prodGCPV_+3A_distances">distances</code></td>
<td>
<p>See <code><a href="#topic+calcShd">calcShd</a></code> for
details.</p>
</td></tr>
<tr><td><code id="A4_prodGCPV_+3A_...">...</code></td>
<td>
<p>Additional arguments for <code><a href="#topic+calcG0">calcG0</a></code> or <code><a href="#topic+calcGef">calcGef</a></code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>The calculation of the irradiance on the horizontal plane is
carried out with the function <code><a href="#topic+calcG0">calcG0</a></code>. The transformation
to the inclined surface makes use of the <code><a href="#topic+fTheta">fTheta</a></code> and
<code><a href="#topic+fInclin">fInclin</a></code> functions inside the <code><a href="#topic+calcGef">calcGef</a></code>
function. The shadows are computed with  <code><a href="#topic+calcShd">calcShd</a></code> while
the performance of the PV system is simulated with
<code><a href="#topic+fProd">fProd</a></code>.</p>


<h3>Value</h3>

<p>A <code>ProdGCPV</code> object.</p>


<h3>Author(s)</h3>

<p>Oscar Perpiñán Lamigueiro,
Francisco Delgado López.</p>


<h3>References</h3>


<ul>
<li><p> Perpiñán, O, Energía Solar Fotovoltaica, 2015.
(<a href="https://oscarperpinan.github.io/esf/">https://oscarperpinan.github.io/esf/</a>)
</p>
</li>
<li><p> Perpiñán, O. (2012), &quot;solaR: Solar Radiation and Photovoltaic
Systems with R&quot;, Journal of Statistical Software, 50(9), 1-32,
<a href="https://doi.org/10.18637/jss.v050.i09">doi:10.18637/jss.v050.i09</a>
</p>
</li></ul>


<h3>See Also</h3>

<p><code><a href="#topic+fProd">fProd</a></code>,
<code><a href="#topic+calcGef">calcGef</a></code>,
<code><a href="#topic+calcShd">calcShd</a></code>,
<code><a href="#topic+calcG0">calcG0</a></code>,
<code><a href="#topic+compare">compare</a></code>,
<code><a href="#topic+compareLosses">compareLosses</a></code>,
<code><a href="#topic+mergesolaR">mergesolaR</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library("data.table")


lat &lt;- 37.2;

G0dm &lt;- c(2766, 3491, 4494, 5912, 6989, 7742, 7919, 7027, 5369, 3562,
          2814, 2179)

Ta &lt;- c(10, 14.1, 15.6, 17.2, 19.3, 21.2, 28.4, 29.9, 24.3, 18.2,
        17.2, 15.2)

prom &lt;- list(G0dm = G0dm, Ta = Ta)

###Comparison of different tracker methods
prodFixed &lt;- prodGCPV(lat = lat, dataRad = prom,
                      keep.night = FALSE)

prod2x &lt;- prodGCPV(lat = lat, dataRad = prom,
                   modeTrk = 'two',
                   keep.night = FALSE)

prodHoriz &lt;- prodGCPV(lat = lat,dataRad = prom,
                      modeTrk = 'horiz',
                      keep.night = FALSE)

##Comparison of yearly productivities
compare(prodFixed, prod2x, prodHoriz)
compareLosses(prodFixed, prod2x, prodHoriz)

##Comparison of power time series
ComparePac &lt;- data.table(Dates = indexI(prod2x),
                         two = as.data.tableI(prod2x)$Pac,
                         horiz = as.data.tableI(prodHoriz)$Pac,
                         fixed = as.data.tableI(prodFixed)$Pac)

AngSol &lt;- as.data.tableI(as(prodFixed, 'Sol'))

ComparePac &lt;- merge(AngSol, ComparePac, by = 'Dates')

ComparePac[, Month := as.factor(month(Dates))]

xyplot(two + horiz + fixed ~ AzS|Month, data = ComparePac,
       type = 'l',
       auto.key = list(space = 'right',
                     lines = TRUE,
                     points = FALSE),
       ylab = 'Pac')



###Shadows
#Two-axis trackers
struct2x &lt;- list(W = 23.11, L = 9.8, Nrow = 2, Ncol = 8)
dist2x &lt;- data.table(Lew = 40, Lns = 30, H = 0)
prod2xShd &lt;- prodGCPV(lat = lat, dataRad = prom,
                      modeTrk = 'two',
                      modeShd = 'area',
                      struct = struct2x,
                      distances = dist2x)
print(prod2xShd)

#Horizontal N-S tracker
structHoriz &lt;- list(L = 4.83);
distHoriz &lt;- data.table(Lew = structHoriz$L*4);

#Without Backtracking
prodHorizShd &lt;- prodGCPV(lat = lat, dataRad = prom,
                         sample = '10 min',
                         modeTrk = 'horiz',
                         modeShd = 'area', betaLim = 60,
                         distances = distHoriz,
                         struct = structHoriz)
print(prodHorizShd)

xyplot(r2d(Beta)~r2d(w),
       data = prodHorizShd,
       type = 'l',
       main = 'Inclination angle of a horizontal axis tracker',
       xlab = expression(omega (degrees)),
       ylab = expression(beta (degrees)))

#With Backtracking
prodHorizBT &lt;- prodGCPV(lat = lat, dataRad = prom,
                        sample = '10 min',
                        modeTrk = 'horiz',
                        modeShd = 'bt', betaLim = 60,
                        distances = distHoriz,
                        struct = structHoriz)

print(prodHorizBT)

xyplot(r2d(Beta)~r2d(w),
       data = prodHorizBT,
       type = 'l',
       main = 'Inclination angle of a horizontal axis tracker\n with backtracking',
       xlab = expression(omega (degrees)),
       ylab = expression(beta (degrees)))

compare(prodFixed, prod2x, prodHoriz, prod2xShd,
        prodHorizShd, prodHorizBT)

compareLosses(prodFixed, prod2x, prodHoriz, prod2xShd,
              prodHorizShd, prodHorizBT)

compareYf2 &lt;- mergesolaR(prodFixed, prod2x, prodHoriz, prod2xShd,
                         prodHorizShd, prodHorizBT)

xyplot(prodFixed + prod2x +prodHoriz + prod2xShd + prodHorizShd + prodHorizBT ~ Dates,
       data = compareYf2, type = 'l', ylab = 'kWh/kWp',
       main = 'Daily productivity',
       auto.key = list(space = 'right'))

</code></pre>

<hr>
<h2 id='A5_prodPVPS'>
Performance of a PV pumping system
</h2><span id='topic+prodPVPS'></span>

<h3>Description</h3>

<p>Compute every step from solar angles to effective irradiance to calculate the performance of a PV pumping system.  </p>


<h3>Usage</h3>

<pre><code class='language-R'>prodPVPS(lat,
         modeTrk = 'fixed',
         modeRad = 'prom',
         dataRad,
         sample = 'hour',
         keep.night = TRUE,
         sunGeometry = 'michalsky',
         corr, f,
         betaLim = 90, beta = abs(lat)-10, alpha = 0,
         iS = 2, alb = 0.2, horizBright = TRUE, HCPV = FALSE,
         pump , H,
         Pg, converter= list(),
         effSys = list(),
         ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="A5_prodPVPS_+3A_lat">lat</code></td>
<td>
<p>numeric, latitude (degrees) of the point of the Earth where
calculations are needed. It is positive for locations above the
Equator.</p>
</td></tr>
<tr><td><code id="A5_prodPVPS_+3A_modetrk">modeTrk</code></td>
<td>
<p>A character string, describing the tracking method
of the generator. See <code><a href="#topic+calcGef">calcGef</a></code> for details.</p>
</td></tr>
<tr><td><code id="A5_prodPVPS_+3A_moderad">modeRad</code>, <code id="A5_prodPVPS_+3A_datarad">dataRad</code></td>
<td>
<p>Information about the source data of the
global irradiation. See <code><a href="#topic+calcG0">calcG0</a></code> for details.</p>
</td></tr>
<tr><td><code id="A5_prodPVPS_+3A_sample">sample</code>, <code id="A5_prodPVPS_+3A_keep.night">keep.night</code></td>
<td>
<p>See <code><a href="#topic+calcSol">calcSol</a></code> for
details.</p>
</td></tr>
<tr><td><code id="A5_prodPVPS_+3A_sungeometry">sunGeometry</code></td>
<td>
<p><code>character</code>, method for the sun geometry
calculations. See <code><a href="#topic+calcSol">calcSol</a></code>, <code><a href="#topic+fSolD">fSolD</a></code> and <code><a href="#topic+fSolI">fSolI</a></code>.</p>
</td></tr>
<tr><td><code id="A5_prodPVPS_+3A_corr">corr</code>, <code id="A5_prodPVPS_+3A_f">f</code></td>
<td>
<p>See <code><a href="#topic+calcG0">calcG0</a></code> for details.</p>
</td></tr>
<tr><td><code id="A5_prodPVPS_+3A_betalim">betaLim</code>, <code id="A5_prodPVPS_+3A_beta">beta</code>, <code id="A5_prodPVPS_+3A_alpha">alpha</code>, <code id="A5_prodPVPS_+3A_is">iS</code>, <code id="A5_prodPVPS_+3A_alb">alb</code>, <code id="A5_prodPVPS_+3A_horizbright">horizBright</code>, <code id="A5_prodPVPS_+3A_hcpv">HCPV</code></td>
<td>
<p>See <code><a href="#topic+calcGef">calcGef</a></code> for details.</p>
</td></tr>
<tr><td><code id="A5_prodPVPS_+3A_pump">pump</code></td>
<td>
<p>A <code>list</code> extracted from <code><a href="#topic+pumpCoef">pumpCoef</a></code></p>
</td></tr>
<tr><td><code id="A5_prodPVPS_+3A_h">H</code></td>
<td>
<p>Total manometric head (m)</p>
</td></tr>
<tr><td><code id="A5_prodPVPS_+3A_pg">Pg</code></td>
<td>
<p>Nominal power of the PV generator (Wp)</p>
</td></tr>
<tr><td><code id="A5_prodPVPS_+3A_converter">converter</code></td>
<td>
<p><code>list</code> containing the nominal power of the
frequency converter, <code>Pnom</code>, and <code>Ki</code>, vector of three
values, coefficients of the efficiency curve.</p>
</td></tr>
<tr><td><code id="A5_prodPVPS_+3A_effsys">effSys</code></td>
<td>
<p>list of numeric values with information about the system
losses,
</p>

<dl>
<dt><code>ModQual</code></dt><dd><p>average tolerance of the set of modules
(%), default value is 3</p>
</dd>
<dt><code>ModDisp</code></dt><dd><p> module parameter disperssion losses (%),
default value is 2</p>
</dd>
<dt><code>OhmDC</code></dt><dd><p> Joule losses due to the DC wiring (%),
default value is 1.5</p>
</dd>
<dt><code>OhmAC</code></dt><dd><p>Joule losses due to the AC wiring (%),
default value is 1.5</p>
</dd>
</dl>
</td></tr>
<tr><td><code id="A5_prodPVPS_+3A_...">...</code></td>
<td>
<p>Additional arguments for <code><a href="#topic+calcSol">calcSol</a></code>,
<code><a href="#topic+calcG0">calcG0</a></code> and <code><a href="#topic+calcGef">calcGef</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The calculation of the irradiance on the generator is carried
out with the function <code><a href="#topic+calcGef">calcGef</a></code>. The  performance of the PV system is simulated with <code><a href="#topic+fPump">fPump</a></code>.</p>


<h3>Value</h3>

<p>A <code><a href="#topic+ProdPVPS-class">ProdPVPS</a></code> object.</p>


<h3>Author(s)</h3>

<p>Oscar Perpiñán Lamigueiro,
Francisco Delgado López.</p>


<h3>References</h3>


<ul>
<li><p> Abella, M. A., Lorenzo, E. y Chenlo, F.: PV water pumping
systems based on standard frequency converters. Progress in
Photovoltaics: Research and Applications, 11(3):179–191, 2003, ISSN
1099-159X.
</p>
</li>
<li><p> Perpiñán, O, Energía Solar Fotovoltaica, 2015.
(<a href="https://oscarperpinan.github.io/esf/">https://oscarperpinan.github.io/esf/</a>)
</p>
</li>
<li><p> Perpiñán, O. (2012), &quot;solaR: Solar Radiation and Photovoltaic
Systems with R&quot;, Journal of Statistical Software, 50(9), 1-32,
<a href="https://doi.org/10.18637/jss.v050.i09">doi:10.18637/jss.v050.i09</a>
</p>
</li></ul>


<h3>See Also</h3>

<p><code><a href="#topic+NmgPVPS">NmgPVPS</a></code>, <code><a href="#topic+fPump">fPump</a></code>, <code><a href="#topic+pumpCoef">pumpCoef</a></code></p>

<hr>
<h2 id='A6_calcShd'>Shadows on PV systems.</h2><span id='topic+calcShd'></span>

<h3>Description</h3>

<p> Compute the irradiance and irradiation including shadows
for two-axis and horizontal N-S axis trackers and fixed surfaces.  It
makes use of the function <code><a href="#topic+fSombra">fSombra</a></code> for the shadows factor
calculation. It is used by the function <code><a href="#topic+calcGef">calcGef</a></code>.  </p>


<h3>Usage</h3>

<pre><code class='language-R'>
calcShd(radEf,
        modeShd = '',
        struct = list(),
        distances = data.table())
</code></pre>


<h3>Arguments</h3>

 <table role = "presentation">
<tr><td><code id="A6_calcShd_+3A_radef">radEf</code></td>
<td>
<p>A
<code><a href="#topic+Gef-class">Gef</a></code> object. It may be the result of the
<code><a href="#topic+calcGef">calcGef</a></code> function.</p>
</td></tr>
<tr><td><code id="A6_calcShd_+3A_modeshd">modeShd</code></td>
<td>
<p>character, defines the type of shadow calculation. In
this version of the package the effect of the shadow is calculated
as a proportional reduction of the circumsolar diffuse and direct
irradiances. This type of approach is selected with
<code>modeShd = 'area'</code>. In future versions other approaches which
relate the geometric shadow and the electrical connections of the PV
generator will be available. If <code>radEf@modeTrk = 'horiz'</code> it is
possible to calculate the effect of backtracking with
<code>modeShd = 'bt'</code>. If <code>modeShd = c('area','bt')</code> the
backtracking method will be carried out and therefore no shadows
will appear. Finally, for two-axis trackers it is possible to select
<code>modeShd = 'prom'</code> in order to calculate the effect of shadows on
an average tracker (see <code><a href="#topic+fSombra6">fSombra6</a></code>).  The result will
include three variables (Gef0, Def0 and Bef0) with the
irradiance/irradiation without shadows as a reference.</p>
</td></tr>
<tr><td><code id="A6_calcShd_+3A_struct">struct</code></td>
<td>
<p><code>list</code>.
</p>
<p>When <code>radEf@modeTrk = 'fixed'</code> or <code>modeTrk = 'horiz'</code> only a
component named <code>L</code>, which is the height (meters) of the
tracker, is needed.
</p>
<p>For two-axis trackers (<code>radEf@modeTrk = 'two'</code>), an additional
component named <code>W</code>, the width of the tracker, is
required. Moreover, only when <code>radEf@modeTrk = 'two'</code> two components named
<code>Nrow</code> and <code>Ncol</code> are included under this list. These
components define, respectively, the number of rows and columns of
the whole set of two-axis trackers in the PV plant.</p>
</td></tr>
<tr><td><code id="A6_calcShd_+3A_distances">distances</code></td>
<td>
<p><code>data.frame</code>.
</p>
<p>When <code>radEf@modeTrk = 'fixed'</code> it includes a component named <code>D</code>
for the distance between fixed surfaces. An additional component
named <code>H</code> can be included with the relative height between
surfaces.
</p>
<p>When <code>radEf@modeTrk = 'horiz'</code> it only includes a component named
<code>Lew</code>, being the distance between horizontal NS trackers along
the East-West direction.
</p>
<p>When <code>radEf@modeTrk = 'two'</code> it includes a component named <code>Lns</code>
being the distance between trackers along the North-South direction,
a component named <code>Lew</code>, being the distance between trackers
along the East-West direction and a (optional) component named
<code>H</code> with the relative height between surfaces.
</p>
<p>The distances, in meters, are defined between axis of the trackers.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>Gef</code> object including three additional variables
(<code>Gef0</code>, <code>Def0</code> and <code>Bef0</code>) in the slots <code>GefI</code>,
<code>GefD</code>, <code>Gefdm</code> and <code>Gefy</code> with the
irradiance/irradiation without shadows as a reference.</p>


<h3>Author(s)</h3>

<p>Oscar Perpiñán Lamigueiro,
Francisco Delgado López.</p>


<h3>References</h3>


<ul>
<li><p> Perpiñán, O, Energía Solar Fotovoltaica, 2015.
(<a href="https://oscarperpinan.github.io/esf/">https://oscarperpinan.github.io/esf/</a>)
</p>
</li>
<li><p> Perpiñán, O. (2012), &quot;solaR: Solar Radiation and Photovoltaic
Systems with R&quot;, Journal of Statistical Software, 50(9), 1-32,
<a href="https://doi.org/10.18637/jss.v050.i09">doi:10.18637/jss.v050.i09</a>
</p>
</li></ul>


<h3>See Also</h3>

 <p><code><a href="#topic+calcG0">calcG0</a></code>, <code><a href="#topic+fTheta">fTheta</a></code>,
<code><a href="#topic+fInclin">fInclin</a></code>, <code><a href="#topic+calcShd">calcShd</a></code>.  </p>

<hr>
<h2 id='A7_optimShd'>
Shadows calculation for a set of distances between elements of a PV grid connected plant.
</h2><span id='topic+optimShd'></span>

<h3>Description</h3>

<p>The optimum distance between trackers or static structures of a PV
grid connected plant depends on two main factors: the ground
requirement ratio (defined as the ratio of the total ground area to
the generator PV array area), and the productivity of the system
including shadow losses. Therefore, the optimum separation may be the
one which achieves the highest productivity with the lowest ground
requirement ratio. 
</p>
<p>However, this definition is not complete since the terrain
characteristics and the costs of wiring or civil works could alter the
decision. This function is a help for choosing this distance: it
computes the productivity for a set of combinations of distances
between the elements of the plant.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>optimShd(lat,
         modeTrk = 'fixed',
         modeRad = 'prom',
         dataRad,
         sample = 'hour',
         keep.night = TRUE,
         sunGeometry = 'michalsky',
         betaLim = 90, beta = abs(lat)-10, alpha = 0,
         iS = 2, alb = 0.2, HCPV = FALSE,
         module = list(),
         generator = list(),
         inverter = list(),
         effSys = list(),
         modeShd = '',
         struct = list(),
         distances = data.table(),
         res = 2,
         prog = TRUE)

</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="A7_optimShd_+3A_lat">lat</code></td>
<td>
<p>numeric, latitude (degrees) of the point of the Earth where calculations are needed. It is positive for locations above the Equator.</p>
</td></tr>
<tr><td><code id="A7_optimShd_+3A_modetrk">modeTrk</code></td>
<td>
<p>character, to be chosen from <code>'fixed'</code>,
<code>'two'</code> or <code>'horiz'</code>. When <code>modeTrk = 'fixed'</code> the
surface is fixed (inclination and azimuth angles are constant). The
performance of a two-axis tracker is calculated with <code>modeTrk =
  'two'</code>, and <code>modeTrk = 'horiz'</code> is the option for an horizontal
N-S tracker. Its default value is <code>modeTrk = 'fixed'</code></p>
</td></tr>
<tr><td><code id="A7_optimShd_+3A_moderad">modeRad</code>, <code id="A7_optimShd_+3A_datarad">dataRad</code></td>
<td>
<p>Information about the source data of the
global irradiation. See <code><a href="#topic+calcG0">calcG0</a></code> for details. For this
function the option <code>modeRad = 'bdI'</code> is not supported.</p>
</td></tr>
<tr><td><code id="A7_optimShd_+3A_sample">sample</code></td>
<td>
<p><code>character</code>, containing one of ‘&quot;sec&quot;’, ‘&quot;min&quot;’,
‘&quot;hour&quot;’.  This can optionally be preceded by a (positive or
negative) integer and a space, or followed by ‘&quot;s&quot;’ (used by
<code><a href="base.html#topic+seq.POSIXt">seq.POSIXt</a></code>)</p>
</td></tr>
<tr><td><code id="A7_optimShd_+3A_keep.night">keep.night</code></td>
<td>
<p><code>logical</code> When it is TRUE (default) the
time series includes the night.</p>
</td></tr>
<tr><td><code id="A7_optimShd_+3A_sungeometry">sunGeometry</code></td>
<td>
<p><code>character</code>, method for the sun geometry
calculations. See <code><a href="#topic+calcSol">calcSol</a></code>, <code><a href="#topic+fSolD">fSolD</a></code> and <code><a href="#topic+fSolI">fSolI</a></code>.</p>
</td></tr>
<tr><td><code id="A7_optimShd_+3A_betalim">betaLim</code>, <code id="A7_optimShd_+3A_beta">beta</code>, <code id="A7_optimShd_+3A_alpha">alpha</code>, <code id="A7_optimShd_+3A_is">iS</code>, <code id="A7_optimShd_+3A_alb">alb</code>, <code id="A7_optimShd_+3A_hcpv">HCPV</code></td>
<td>
<p>See <code><a href="#topic+calcGef">calcGef</a></code> for details.</p>
</td></tr>
<tr><td><code id="A7_optimShd_+3A_module">module</code></td>
<td>
<p>list of numeric values with information about the PV module, </p>

<dl>
<dt><code>Vocn</code></dt><dd><p>open-circuit voltage of the module at Standard
Test Conditions (default value 57.6 volts.)</p>
</dd>
<dt><code>Iscn</code></dt><dd><p>short circuit current of the module at Standard
Test Conditions (default value 4.7 amperes.)</p>
</dd>
<dt><code>Vmn</code></dt><dd><p>maximum power point voltage of the module at
Standard Test Conditions (default value 46.08 amperes.)</p>
</dd>
<dt><code>Imn</code></dt><dd><p>Maximum power current of the module at Standard
Test Conditions (default value 4.35 amperes.)</p>
</dd>
<dt><code>Ncs</code></dt><dd><p>number of cells in series inside the module
(default value 96)</p>
</dd>
<dt><code>Ncp</code></dt><dd><p>number of cells in parallel inside the module (default value 1)</p>
</dd>
<dt><code>CoefVT</code></dt><dd><p>coefficient of decrement of voltage of each
cell with the temperature (default value 0.0023 volts per celsius degree)</p>
</dd>
<dt><code>TONC</code></dt><dd><p>nominal operational  cell temperature, celsius
degree (default value 47).</p>
</dd>
</dl>
</td></tr>
<tr><td><code id="A7_optimShd_+3A_generator">generator</code></td>
<td>
<p>list of numeric values with information about the generator, </p>

<dl>
<dt><code>Nms</code></dt><dd><p>number of modules in series (default value 12)</p>
</dd>
<dt><code>Nmp</code></dt><dd><p>number of modules in parallel (default value 11)</p>
</dd>
</dl>
</td></tr>
<tr><td><code id="A7_optimShd_+3A_inverter">inverter</code></td>
<td>
<p>list of numeric values with information about the DC/AC inverter, </p>

<dl>
<dt><code>Ki</code></dt><dd><p>vector of three values, coefficients of the
efficiency curve of the inverter (default c(0.01, 0.025, 0.05)),
or a matrix of nine values (3x3) if there is dependence with the
voltage (see references).</p>
</dd>
<dt><code>Pinv</code></dt><dd><p>nominal inverter power (W) (default value 25000
watts.)</p>
</dd>
<dt><code>Vmin, Vmax</code></dt><dd><p> minimum and maximum voltages of the MPP
range of the inverter (default values 420 and 750 volts)</p>
</dd>
<dt><code>Gumb</code></dt><dd><p> minimum irradiance for the inverter to start
(W/m²) (default value 20 W/m²)</p>
</dd>
</dl>
</td></tr>
<tr><td><code id="A7_optimShd_+3A_effsys">effSys</code></td>
<td>
<p>list of numeric values with information about the system losses, </p>

<dl>
<dt><code>ModQual</code></dt><dd><p>average tolerance of the set of modules (%), default value is 3</p>
</dd>
<dt><code>ModDisp</code></dt><dd><p> module parameter disperssion losses (%), default value is 2</p>
</dd>
<dt><code>OhmDC</code></dt><dd><p> Joule losses due to the DC wiring (%), default value is 1.5</p>
</dd>
<dt><code>OhmAC</code></dt><dd><p>Joule losses due to the AC wiring (%), default value is 1.5</p>
</dd>
<dt><code>MPP</code></dt><dd><p> average error of the MPP algorithm of the inverter (%), default value is 1</p>
</dd>
<dt><code>TrafoMT</code></dt><dd><p>losses due to the MT transformer (%), default value is 1</p>
</dd>
<dt><code>Disp</code></dt><dd><p> losses due to stops of the system (%), default value is 0.5</p>
</dd>
</dl>
</td></tr>
<tr><td><code id="A7_optimShd_+3A_modeshd">modeShd</code></td>
<td>
<p>character, defines the type of shadow calculation. In
this version of the package the effect of the shadow is calculated
as a proportional reduction of the circumsolar diffuse and direct
irradiances. This type of approach is selected with
<code>modeShd = 'area'</code>. In future versions other approaches which
relate the geometric shadow and the electrical connections of the PV
generator will be available. If <code>modeTrk = 'horiz'</code> it is
possible to calculate the effect of backtracking with
<code>modeShd = 'bt'</code>. If <code>modeShd = c('area','bt')</code> the
backtracking method will be carried out and therefore no shadows
will appear. Finally, for two-axis trackers it is possible to select
<code>modeShd = 'prom'</code> in order to calculate the effect of shadows on
an average tracker (see <code><a href="#topic+fSombra6">fSombra6</a></code>).
The result will include three variables (Gef0, Def0 and Bef0) with the
irradiance/irradiation without shadows as a reference.</p>
</td></tr>
<tr><td><code id="A7_optimShd_+3A_struct">struct</code></td>
<td>
<p><code>list</code>. When <code>modeTrk = 'fixed'</code> or
<code>modeTrk = 'horiz'</code> only a component named <code>L</code>, which is the
height (meters) of the tracker, is needed. For two-axis trackers
(<code>modeTrk = 'two'</code>), an additional component named <code>W</code>, the
width of the tracker, is required. Moreover, two components named
<code>Nrow</code> and <code>Ncol</code> are included under this list. These
components define, respectively, the number of rows and columns of
the whole setof trackers in the PV plant.</p>
</td></tr>
<tr><td><code id="A7_optimShd_+3A_distances">distances</code></td>
<td>
<p><code>list</code>, whose three components are vectors of
length 2: </p>
 <dl>
<dt><code>Lew</code></dt><dd><p> (only when
<code>modeTrk = 'horiz'</code> or <code>modeTrk = 'two'</code>), minimum and maximum
distance (meters) between horizontal NS and two-axis trackers along
the East-West direction.</p>
</dd>  <dt><code>Lns</code></dt><dd><p> (only when
<code>modeTrk = 'two'</code>), minimum and maximum distance (meters) between
two-axis trackers along the North-South direction.</p>
</dd>
<dt><code>D</code></dt><dd><p>(only when <code>modeTrk = 'fixed'</code>), minimum and
maximum distance (meters) between fixed surfaces.</p>
</dd>  </dl>
<p> These
distances, in meters, are defined between the axis of the trackers.</p>
</td></tr>
<tr><td><code id="A7_optimShd_+3A_res">res</code></td>
<td>
<p>numeric; <code>optimShd</code> constructs a sequence from the
minimum to the maximum value of <code>distances</code>, with <code>res</code> as
the increment, in meters, of the sequence.</p>
</td></tr>  <tr><td><code id="A7_optimShd_+3A_prog">prog</code></td>
<td>
<p>logical,
show a progress bar; default value is TRUE</p>
</td></tr> </table>


<h3>Details</h3>

 <p><code>optimShd</code> calculates the energy produced for every
combination of distances as defined by <code>distances</code> and
<code>res</code>. The result of this function is a <code><a href="#topic+Shade-class">Shade-class</a></code>
object.  A method of <code>shadeplot</code> for this class is defined
(<code><a href="#topic+shadeplot-methods">shadeplot-methods</a></code>), and it shows the graphical relation
between the productivity and the distance between trackers or fixed
surfaces.  </p>


<h3>Value</h3>

<p>A <code><a href="#topic+Shade-class">Shade</a></code> object.</p>


<h3>Author(s)</h3>

<p>Oscar Perpiñán Lamigueiro,
Francisco Delgado López.</p>


<h3>References</h3>


<ul>
<li><p> Perpiñán, O.: Grandes Centrales Fotovoltaicas: producción, seguimiento y ciclo de vida. PhD Thesis, UNED, 2008. <a href="https://www.researchgate.net/publication/39419806_Grandes_Centrales_Fotovoltaicas_Produccion_Seguimiento_y_Ciclo_de_Vida">https://www.researchgate.net/publication/39419806_Grandes_Centrales_Fotovoltaicas_Produccion_Seguimiento_y_Ciclo_de_Vida</a>.
</p>
</li>
<li><p> Perpiñán, O, Energía Solar Fotovoltaica, 2015.
(<a href="https://oscarperpinan.github.io/esf/">https://oscarperpinan.github.io/esf/</a>)
</p>
</li>
<li><p> Perpiñán, O. (2012), &quot;solaR: Solar Radiation and Photovoltaic
Systems with R&quot;, Journal of Statistical Software, 50(9), 1-32,
<a href="https://doi.org/10.18637/jss.v050.i09">doi:10.18637/jss.v050.i09</a>
</p>
</li></ul>



<h3>See Also</h3>

<p><code><a href="#topic+prodGCPV">prodGCPV</a></code>,
<code><a href="#topic+calcShd">calcShd</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library("data.table")


lat &lt;- 37.2;
G0dm &lt;- c(2766, 3491, 4494, 5912, 6989, 7742, 7919, 7027, 5369, 3562, 2814,
2179)
Ta &lt;- c(10, 14.1, 15.6, 17.2, 19.3, 21.2, 28.4, 29.9, 24.3, 18.2, 17.2, 15.2)
prom &lt;- list(G0dm = G0dm, Ta = Ta)

###Two-axis trackers
library("latticeExtra")

struct2x &lt;- list(W = 23.11, L = 9.8, Nrow = 2, Ncol = 3)
dist2x &lt;- list(Lew = c(30, 45),Lns = c(20, 40))

ShdM2x &lt;- optimShd(lat = lat, dataRad = prom, modeTrk = 'two',
                   modeShd = c('area','prom'),
                   distances = dist2x, struct = struct2x,
                   res = 5)

shadeplot(ShdM2x)

pLew &lt;- xyplot(Yf ~ GRR,data = ShdM2x, groups = factor(Lew), type = c('l','g'),
    main = 'Productivity for each Lew value')
pLew + glayer(panel.text(x[1], y[1], group.value))

pLns &lt;- xyplot(Yf~GRR,data = ShdM2x,groups = factor(Lns),type = c('l','g'),
    main = 'Productivity for each Lns value')
pLns + glayer(panel.text(x[1], y[1], group.value))

## 1-axis tracker with Backtracking
structHoriz &lt;- list(L = 4.83);
distHoriz &lt;- list(Lew = structHoriz$L * c(2,5));


Shd12HorizBT &lt;- optimShd(lat = lat, dataRad = prom,
        modeTrk = 'horiz',
        betaLim = 60,
        distances = distHoriz, res = 2,
        struct = structHoriz,
        modeShd = 'bt')

shadeplot(Shd12HorizBT)

xyplot(diff(Yf) ~ GRR[-1],data = Shd12HorizBT, type = c('l','g'))

###Fixed system
structFixed = list(L = 5);
distFixed &lt;- list(D = structFixed$L*c(1,3));
Shd12Fixed &lt;- optimShd(lat = lat, dataRad = prom,
        modeTrk = 'fixed',
        distances = distFixed, res = 2,
        struct = structFixed,
        modeShd = 'area')
shadeplot(Shd12Fixed)
</code></pre>

<hr>
<h2 id='A8_Meteo2Meteo'>Transformation of intradaily meteorological data into daily and
daily into monthly data.</h2><span id='topic+Meteoi2Meteod'></span><span id='topic+Meteod2Meteom'></span>

<h3>Description</h3>

<p>Functions for the class <code>Meteo</code> that transforms an
intradaily <code>Meteo</code> object into a daily and a daily into a
monthly.</p>


<h3>Usage</h3>

<pre><code class='language-R'>Meteoi2Meteod(G0i)

Meteod2Meteom(G0d)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="A8_Meteo2Meteo_+3A_g0i">G0i</code></td>
<td>
<p>A <code>Meteo</code> object with intradaily data</p>
</td></tr>
<tr><td><code id="A8_Meteo2Meteo_+3A_g0d">G0d</code></td>
<td>
<p>A <code>Meteo</code> object with daily data</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>Meteo</code> object</p>


<h3>Author(s)</h3>

<p>Oscar Perpiñán Lamigueiro,
Francisco Delgado López.</p>


<h3>See Also</h3>

<p><code><a href="#topic+readBDd">readBDd</a></code>,
<code><a href="#topic+readG0dm">readG0dm</a></code>,
<code><a href="#topic+readSIAR">readSIAR</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library("data.table")


G0dm &lt;- c(2.766,3.491,4.494,5.912,6.989,7.742,7.919,
         7.027,5.369,3.562,2.814,2.179) * 1000;
Ta &lt;- c(10, 14.1, 15.6, 17.2, 19.3, 21.2,
       28.4, 29.9, 24.3, 18.2, 17.2, 15.2)
prom &lt;- list(G0dm = G0dm, Ta = Ta)

g0 &lt;- calcG0(lat = 37.2, dataRad = prom, modeRad = 'aguiar')
G0i &lt;- as.data.tableI(g0)
G0i &lt;- dt2Meteo(G0i, lat = 37.2)
G0i

G0d &lt;- Meteoi2Meteod(G0i)
G0d

G0m &lt;- Meteod2Meteom(G0d)
G0m

</code></pre>

<hr>
<h2 id='A8_readBD'>Daily or intradaily values of global horizontal irradiation and ambient
temperature from a local file or a data.frame.</h2><span id='topic+readBDd'></span><span id='topic+readBDi'></span><span id='topic+dt2Meteo'></span><span id='topic+zoo2Meteo'></span>

<h3>Description</h3>

<p>Constructor for the class <code>Meteo</code> with values of
<em>daily</em> or <em>intradaily</em> values of global horizontal irradiation and ambient temperature
from a local file or a data.frame.</p>


<h3>Usage</h3>

<pre><code class='language-R'>readBDd(file,  lat,
        format = '%d/%m/%Y',
        header = TRUE, fill = TRUE, dec = '.', sep = ';',
        dates.col = 'Dates', ta.col = 'Ta',
        g0.col = 'G0', keep.cols = FALSE, ...)

readBDi(file,  lat,
        format = '%d/%m/%Y %H:%M:%S',
        header = TRUE, fill = TRUE, dec = '.',
        sep = ';', dates.col = 'Dates', times.col,
        ta.col = 'Ta', g0.col = 'G0', keep.cols = FALSE, ...)

dt2Meteo(file,  lat, source = '', type)

zoo2Meteo(file, lat, source = '')
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="A8_readBD_+3A_file">file</code></td>
<td>
<p>The name of the file (<code>readBDd</code> and <code>readBDi</code>),
<code>data.frame</code> (or <code>data.table</code>) (<code>dt2Meteo</code>) or <code>zoo</code>
(<code>zoo2Meteo</code>) which the data are to be read from.
It should contain a column <code>G0d</code> with <em>daily</em>
(<code>readBDd</code>) or <code>G0</code> with <em>intradaily</em>
(<code>readBDi</code>) values of global horizontal irradiation (Wh/m²). It
should also include a column named <code>Ta</code> with values of ambient
temperature. However, if the object is only a vector with
irradiation values, it will converted to a <code>data.table</code> with
two columns named <code>G0</code> and <code>Ta</code> (filled with constant
values)
</p>
<p>If the <code>Meteo</code> object is to be used with <code><a href="#topic+calcG0">calcG0</a></code>
(or <code>fCompD</code>, <code>fCompI</code>) and the option
<code>corr = 'none'</code>, the file/data.frame <b>must</b> include three
columns named <code>G0</code>, <code>B0</code> and <code>D0</code> with values of
global, direct and diffuse irradiation on the horizontal plane.
</p>
<p>Only for daily data: if the ambient temperature is not available,
the file should include two columns named <code>TempMax</code> and
<code>TempMin</code> with daily values of maximum and minimum ambient
temperature, respectively (see <code><a href="#topic+fTemp">fTemp</a></code> for details).</p>
</td></tr>
<tr><td><code id="A8_readBD_+3A_header">header</code>, <code id="A8_readBD_+3A_fill">fill</code>, <code id="A8_readBD_+3A_dec">dec</code>, <code id="A8_readBD_+3A_sep">sep</code></td>
<td>
<p>See <code><a href="data.table.html#topic+fread">fread</a></code></p>
</td></tr>
<tr><td><code id="A8_readBD_+3A_format">format</code></td>
<td>
<p>character string with the format of the dates or time
index.
(Default for daily time bases:<code>%d/%m/%Y</code>).
(Default for intradaily time bases: <code>%d/%m/%Y  %H:%M:%S</code>)</p>
</td></tr>
<tr><td><code id="A8_readBD_+3A_lat">lat</code></td>
<td>
<p>numeric, latitude (degrees) of the location.</p>
</td></tr>
<tr><td><code id="A8_readBD_+3A_dates.col">dates.col</code></td>
<td>
<p>character string with the name of the column wich
contains the dates of the time series.</p>
</td></tr>
<tr><td><code id="A8_readBD_+3A_times.col">times.col</code></td>
<td>
<p>character string with the name of the column wich
contains the time index of the series in case is in a different
column than the dates.</p>
</td></tr>
<tr><td><code id="A8_readBD_+3A_source">source</code></td>
<td>
<p>character string with information about the source of
the values. (Default: the name of the file).</p>
</td></tr>
<tr><td><code id="A8_readBD_+3A_ta.col">ta.col</code>, <code id="A8_readBD_+3A_g0.col">g0.col</code></td>
<td>
<p>character, the name of the columns with the
information of ambient temperature and radiation in the provided
file</p>
</td></tr>
<tr><td><code id="A8_readBD_+3A_keep.cols">keep.cols</code></td>
<td>
<p>If <code>keep.cols=FALSE</code>(default value), the
<code>Meteo</code> object does not include the columns that are not
important for the rest of operations</p>
</td></tr>
<tr><td><code id="A8_readBD_+3A_...">...</code></td>
<td>
<p>Arguments for <code><a href="data.table.html#topic+fread">fread</a></code></p>
</td></tr>
<tr><td><code id="A8_readBD_+3A_type">type</code></td>
<td>
<p>character, type of the data in <code>dt2Meteo</code>. To choose between
<code>'prom'</code>, <code>'bd'</code> and <code>'bdI'</code>. If it is not provided,
the function <code>dt2Meteo</code> calculate the type.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>Meteo</code> object.</p>


<h3>Author(s)</h3>

<p>Oscar Perpiñán Lamigueiro,
Francisco Delgado López.
</p>


<h3>See Also</h3>

<p><code><a href="data.table.html#topic+fread">fread</a></code>,
<code><a href="#topic+readG0dm">readG0dm</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library("data.table")


data(helios)
names(helios) = c('Dates', 'G0d', 'TempMax', 'TempMin')

bd = dt2Meteo(helios, lat = 41, source = 'helios-IES', type = 'bd')

getData(bd)

xyplot(bd)
</code></pre>

<hr>
<h2 id='A8_readG0dm'>Monthly mean values of global horizontal irradiation.</h2><span id='topic+readG0dm'></span>

<h3>Description</h3>

<p>Constructor for the class <code>Meteo</code> with 12 values of
monthly means of irradiation.</p>


<h3>Usage</h3>

<pre><code class='language-R'>readG0dm(G0dm, Ta = 25, lat = 0,
    year= as.POSIXlt(Sys.Date())$year+1900,
    promDays = c(17,14,15,15,15,10,18,18,18,19,18,13),
    source = '')
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="A8_readG0dm_+3A_g0dm">G0dm</code></td>
<td>
<p>numeric, 12 values of monthly means of daily global horizontal
irradiation (Wh/m²).</p>
</td></tr>
<tr><td><code id="A8_readG0dm_+3A_ta">Ta</code></td>
<td>
<p>numeric, 12 values of monthly means of ambient temperature
(degrees Celsius).</p>
</td></tr>
<tr><td><code id="A8_readG0dm_+3A_lat">lat</code></td>
<td>
<p>numeric, latitude (degrees) of the location.</p>
</td></tr>
<tr><td><code id="A8_readG0dm_+3A_year">year</code></td>
<td>
<p>numeric (Default: current year).</p>
</td></tr>
<tr><td><code id="A8_readG0dm_+3A_promdays">promDays</code></td>
<td>
<p>numeric, set of the average days for each month.</p>
</td></tr>
<tr><td><code id="A8_readG0dm_+3A_source">source</code></td>
<td>
<p>character string with information about the source of
the values.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>Meteo</code> object</p>


<h3>Author(s)</h3>

<p>Oscar Perpiñán Lamigueiro,
Francisco Delgado López.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+readBDd">readBDd</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library("data.table")


G0dm &lt;-
  c(2.766,3.491,4.494,5.912,6.989,7.742,7.919,7.027,5.369,3.562,2.814,2.179) * 1000;
Ta &lt;- c(10, 14.1, 15.6, 17.2, 19.3, 21.2, 28.4, 29.9, 24.3, 18.2, 17.2, 15.2)
BD &lt;- readG0dm(G0dm = G0dm, Ta = Ta, lat = 37.2)
print(BD)
getData(BD)
xyplot(BD)
</code></pre>

<hr>
<h2 id='A8_readSIAR'>
Meteorological data from the SIAR network.
</h2><span id='topic+readSIAR'></span>

<h3>Description</h3>

<p>Download, interpolate and transform meteorological data
fromm the SIAR network.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>readSIAR(Lon = 0, Lat = 0,
         inicio = paste(year(Sys.Date())-1, '01-01', sep = '-'),
         final = paste(year(Sys.Date())-1, '12-31', sep = '-'),
         tipo = 'Mensuales', n_est = 3)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="A8_readSIAR_+3A_lon">Lon</code></td>
<td>
<p>numeric, longitude (degrees) of the location.</p>
</td></tr>
<tr><td><code id="A8_readSIAR_+3A_lat">Lat</code></td>
<td>
<p>numeric, latitude (degrees) of the location.</p>
</td></tr>
<tr><td><code id="A8_readSIAR_+3A_inicio">inicio</code></td>
<td>
<p>character or Date, first day of the records.</p>
</td></tr>
<tr><td><code id="A8_readSIAR_+3A_final">final</code></td>
<td>
<p>character or Date, last day of the records.</p>
</td></tr>
<tr><td><code id="A8_readSIAR_+3A_tipo">tipo</code></td>
<td>
<p>character, tipe of the records. To choose between
<code>Mensuales</code>, <code>Semanales</code>, <code>Diarios</code>,
<code>Horarios</code>.</p>
</td></tr>
<tr><td><code id="A8_readSIAR_+3A_n_est">n_est</code></td>
<td>
<p>integer, select that number of stations closest to the
given point and then perform an IDW (Inverse Distance Weighting)
interpolation with these data.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>Meteo</code> object</p>


<h3>Author(s)</h3>

<p>Francisco Delgado López,
Oscar Perpiñán Lamigueiro.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+readG0dm">readG0dm</a></code>,
<code><a href="#topic+readBDd">readBDd</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library("data.table")

library("httr2")
library("jsonlite")

SIAR = readSIAR(Lon = -3.603, Lat = 40.033,
## Aranjuez, Comunity of Madrid, Spain
                inicio = '2023-01-01',
                final = '2023-05-01',
                tipo = 'Mensuales', n_est = 3)
SIAR

</code></pre>

<hr>
<h2 id='B1_Meteo-class'>Class &quot;Meteo&quot;</h2><span id='topic+Meteo-class'></span><span id='topic+show+2CMeteo-method'></span>

<h3>Description</h3>

<p>A class for meteorological data.
</p>


<h3>Objects from the Class</h3>

<p>Objects can be created by the family of <code><a href="#topic+readBDd">readBDd</a></code> functions.
</p>


<h3>Slots</h3>


<dl>
<dt><code>latm</code>:</dt><dd><p>Latitude (degrees) of the meteorological station or
source of the data.</p>
</dd>
<dt><code>data</code>:</dt><dd><p>A <code>data.table</code> object with the time series of
daily irradiation (<code>G0</code>, Wh/m²), the ambient temperature (<code>Ta</code>)
or the maximum and minimum ambient 
temperature (<code>TempMax</code> and <code>TempMin</code>).</p>
</dd>
<dt><code>source</code>:</dt><dd><p>A character with a short description of the
source of the data.</p>
</dd>
<dt><code>type</code>:</dt><dd><p>A character, <code>prom</code>, <code>bd</code> or
<code>bdI</code> depending on the constructor.</p>
</dd>
</dl>



<h3>Methods</h3>


<dl>
<dt>getData</dt><dd><p><code>signature(object = "Meteo")</code>: extracts the
<code>data</code> slot as a <code>data.table</code> object.</p>
</dd>
<dt>getG0</dt><dd><p><code>signature(object = "Meteo")</code>: extracts the
irradiation as vector.</p>
</dd>
<dt>getLat</dt><dd><p><code>signature(object = "Meteo")</code>: extracts the
latitude value.</p>
</dd>
<dt>indexD</dt><dd><p><code>signature(object = "Meteo")</code>: extracts the index
of the <code>data</code> slot.</p>
</dd>
<dt>xyplot</dt><dd><p><code>signature(x = "formula", data = "Meteo")</code>: plot
the content of the object according to the <code>formula</code> argument.</p>
</dd>
<dt>xyplot</dt><dd><p><code>signature(x = "Meteo", data = "missing")</code>: plot
the <code>data</code> slot using the <code>xyplot</code> method for <code>zoo</code>
objects.</p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>Oscar Perpiñán Lamigueiro,
Francisco Delgado López.</p>


<h3>See Also</h3>

<p><code><a href="#topic+readBDd">readBDd</a></code>,
<code><a href="#topic+readBDi">readBDi</a></code>,
<code><a href="#topic+zoo2Meteo">zoo2Meteo</a></code>,
<code><a href="#topic+dt2Meteo">dt2Meteo</a></code>,
<code><a href="#topic+readG0dm">readG0dm</a></code>,
</p>

<hr>
<h2 id='B2_Sol-class'>Class &quot;Sol&quot;: Apparent movement of the Sun from the Earth</h2><span id='topic+Sol-class'></span><span id='topic+show+2CSol-method'></span>

<h3>Description</h3>

<p>A class which describe the apparent movement of the Sun from the Earth.
</p>


<h3>Objects from the Class</h3>

<p>Objects can be created by <code><a href="#topic+calcSol">calcSol</a></code>.
</p>


<h3>Slots</h3>


<dl>
<dt><code>lat</code>:</dt><dd><p>numeric, latitude (degrees) as defined in the
call to <code><a href="#topic+calcSol">calcSol</a></code>.</p>
</dd>
<dt><code>solD</code>:</dt><dd><p>Object of class <code>"data.table"</code> created by
<code><a href="#topic+fSolD">fSolD</a></code>.</p>
</dd>
<dt><code>solI</code>:</dt><dd><p>Object of class <code>"data,table"</code> created by
<code><a href="#topic+fSolI">fSolI</a></code>.</p>
</dd>
<dt><code>method</code>:</dt><dd><p>character, method for the sun geometry calculations.</p>
</dd>
<dt><code>sample</code>:</dt><dd><p><code>difftime</code>, increment of the intradaily sequence.</p>
</dd>
</dl>



<h3>Methods</h3>


<dl>
<dt>as.data.tableD</dt><dd><p><code>signature(object = "Sol")</code>: conversion
to a data.table with daily values.</p>
</dd>
<dt>as.data.tableI</dt><dd><p><code>signature(object = "Sol")</code>: conversion
to a data.table with intradaily values.</p>
</dd>
<dt>getLat</dt><dd><p><code>signature(object = "Sol")</code>: latitude (degrees)
as defined in the call to <code><a href="#topic+calcSol">calcSol</a></code>.</p>
</dd>
<dt>indexD</dt><dd><p><code>signature(object = "Sol")</code>: index of the
<code>solD</code> slot. </p>
</dd>
<dt>indexI</dt><dd><p><code>signature(object = "Sol")</code>: index of the
<code>solI</code> object. </p>
</dd>
<dt>xyplot</dt><dd><p><code>signature(x = "formula", data = "Sol")</code>:
displays the contents of a <code>Sol</code> object with the
<code>xyplot</code> method for formulas.</p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>Oscar Perpiñán Lamigueiro,
Francisco Delgado López.
</p>


<h3>References</h3>


<ul>
<li><p> Perpiñán, O, Energía Solar Fotovoltaica, 2015.
(<a href="https://oscarperpinan.github.io/esf/">https://oscarperpinan.github.io/esf/</a>)
</p>
</li>
<li><p> Perpiñán, O. (2012), &quot;solaR: Solar Radiation and Photovoltaic
Systems with R&quot;, Journal of Statistical Software, 50(9), 1-32,
<a href="https://doi.org/10.18637/jss.v050.i09">doi:10.18637/jss.v050.i09</a>
</p>
</li></ul>


<h3>See Also</h3>

<p><code><a href="#topic+G0-class">G0</a></code>,
<code><a href="#topic+Gef-class">Gef</a></code>.
</p>

<hr>
<h2 id='B3_G0-class'>Class &quot;G0&quot;: irradiation and irradiance on the horizontal plane.</h2><span id='topic+G0-class'></span><span id='topic+show+2CG0-method'></span>

<h3>Description</h3>

<p>This class contains the global, diffuse and direct
irradiation and irradiance on the horizontal plane, and ambient
temperature. </p>


<h3>Objects from the Class</h3>

<p>Objects can be created by the function <code><a href="#topic+calcG0">calcG0</a></code>.
</p>


<h3>Slots</h3>


<dl>
<dt><code>G0D</code>:</dt><dd><p>Object of class <code>data.table</code> created by
<code><a href="#topic+fCompD">fCompD</a></code>. It includes daily
values of:
</p>

<dl>
<dt>Fd: </dt><dd><p>numeric, the diffuse fraction</p>
</dd>
<dt>Ktd: </dt><dd><p>numeric, the clearness index</p>
</dd>
<dt>G0d: </dt><dd><p>numeric, the global irradiation on a horizontal surface
(Wh/m²)</p>
</dd>
<dt>D0d: </dt><dd><p>numeric, the diffuse irradiation on a horizontal
surface (Wh/m²)</p>
</dd>
<dt>B0d: </dt><dd><p>numeric, the direct irradiation on a horizontal surface
(Wh/m²)</p>
</dd></dl>

</dd>
<dt><code>G0I</code>:</dt><dd><p>Object of class <code>data.table</code> created by
<code><a href="#topic+fCompI">fCompI</a></code>. It includes values of:
</p>

<dl>
<dt>kt: </dt><dd><p>numeric, clearness index</p>
</dd>
<dt>G0: </dt><dd><p>numeric, global irradiance on a horizontal surface, (W/m²)</p>
</dd>
<dt>D0: </dt><dd><p>numeric, diffuse irradiance on a horizontal surface, (W/m²)</p>
</dd>
<dt>B0: </dt><dd><p>numeric, direct irradiance on a horizontal surface, (W/m²)</p>
</dd>
</dl>

</dd>
<dt><code>G0dm</code>:</dt><dd><p>Object of class <code>data.table</code> with monthly mean
values of daily irradiation.</p>
</dd>
<dt><code>G0y</code>:</dt><dd><p>Object of class <code>data.table</code> with yearly sums of irradiation.</p>
</dd>
<dt><code>Ta</code>:</dt><dd><p>Object of class <code>data.table</code> with intradaily ambient
temperature values.</p>
</dd>
</dl>

<p>Besides, this class contains the slots from the <code><a href="#topic+Sol-class">Sol</a></code> and
<code><a href="#topic+Meteo-class">Meteo</a></code> classes.
</p>


<h3>Extends</h3>

<p>Class <code>"<a href="#topic+Meteo-class">Meteo</a>"</code>, directly.
Class <code>"<a href="#topic+Sol-class">Sol</a>"</code>, directly.
</p>


<h3>Methods</h3>


<dl>
<dt>as.data.tableD</dt><dd><p><code>signature(object = "G0")</code>: conversion
to a data.table with daily values.</p>
</dd>
<dt>as.data.tableI</dt><dd><p><code>signature(object = "G0")</code>: conversion
to a data.table with intradaily values.</p>
</dd>
<dt>as.data.tableM</dt><dd><p><code>signature(object = "G0")</code>: conversion
to a data.table with monthly values.</p>
</dd>
<dt>as.data.tableY</dt><dd><p><code>signature(object = "G0")</code>: conversion
to a data.frame with yearly values.</p>
</dd>
<dt>indexD</dt><dd><p><code>signature(object = "G0")</code>: index of the
<code>solD</code> slot. </p>
</dd>
<dt>indexI</dt><dd><p><code>signature(object = "G0")</code>: index of the
<code>solI</code> slot. </p>
</dd>
<dt>getLat</dt><dd><p><code>signature(object = "G0")</code>: latitude of the inherited
<code><a href="#topic+Sol-class">Sol</a></code> object. </p>
</dd>
<dt>xyplot</dt><dd><p><code>signature(x = "G0", data = "missing")</code>: display
the time series of daily values of irradiation.</p>
</dd>
<dt>xyplot</dt><dd><p><code>signature(x = "formula", data = "G0")</code>:
displays the contents of a <code>G0</code> object with the
<code>xyplot</code> method for formulas.</p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>Oscar Perpiñán Lamigueiro,
Francisco Delgado López.
</p>


<h3>References</h3>


<ul>
<li><p> Perpiñán, O, Energía Solar Fotovoltaica, 2015.
(<a href="https://oscarperpinan.github.io/esf/">https://oscarperpinan.github.io/esf/</a>)
</p>
</li>
<li><p> Perpiñán, O. (2012), &quot;solaR: Solar Radiation and Photovoltaic
Systems with R&quot;, Journal of Statistical Software, 50(9), 1-32,
<a href="https://doi.org/10.18637/jss.v050.i09">doi:10.18637/jss.v050.i09</a>
</p>
</li></ul>


<h3>See Also</h3>

<p><code><a href="#topic+Sol-class">Sol</a></code>,
<code><a href="#topic+Gef-class">Gef</a></code>.
</p>

<hr>
<h2 id='B4_Gef-class'>Class &quot;Gef&quot;: irradiation and irradiance on the generator plane.</h2><span id='topic+Gef-class'></span><span id='topic+show+2CGef-method'></span>

<h3>Description</h3>

<p>This class contains the global, diffuse and direct
irradiation and irradiance on the horizontal plane, and ambient
temperature. </p>


<h3>Objects from the Class</h3>

<p>Objects can be created by the function <code><a href="#topic+calcGef">calcGef</a></code>.
</p>


<h3>Slots</h3>


<dl>
<dt><code>GefI</code>:</dt><dd><p>Object of class <code>data.table</code> created by
<code><a href="#topic+fInclin">fInclin</a></code>. It contains these components:
</p>

<dl>
<dt>Bo: </dt><dd><p>Extra-atmospheric irradiance on the inclined surface
(W/m²)</p>
</dd>
<dt>Bn: </dt><dd><p>Direct normal irradiance (W/m²)</p>
</dd>
<dt>G, B, D, Di, Dc, R: </dt><dd><p>Global, direct, diffuse (total, isotropic
and anisotropic) and albedo irradiance incident on an inclined
surface (W/m²)</p>
</dd>
<dt>Gef, Bef, Def, Dief, Dcef, Ref: </dt><dd><p>Effective global, direct,
diffuse (total, isotropic and anisotropic) and albedo irradiance
incident on an inclined surface (W/m²)</p>
</dd>
<dt>FTb, FTd, FTr: </dt><dd><p>Factor of angular losses for the direct,
diffuse and albedo components</p>
</dd></dl>
</dd>
<dt><code>GefD</code>:</dt><dd><p>Object of class <code>data.table</code> with daily values
of global, diffuse and direct irradiation.</p>
</dd>
<dt><code>Gefdm</code>:</dt><dd><p>Object of class <code>data.table</code> with monthly means
of daily global, diffuse and direct irradiation.</p>
</dd>
<dt><code>Gefy</code>:</dt><dd><p>Object of class <code>data.table</code> with yearly sums of
global, diffuse and direct irradiation.</p>
</dd>
<dt><code>Theta</code>:</dt><dd><p>Object of class <code>data.table</code> created by
<code><a href="#topic+fTheta">fTheta</a></code>. It contains these components:
</p>

<dl>
<dt><code>Beta</code>: </dt><dd><p>numeric, inclination angle of the surface
(radians). When <code>modeTrk='fixed'</code> it is the value of the
argument <code>beta</code> converted from degreesto radians.</p>
</dd>
<dt><code>Alpha</code>: </dt><dd><p>numeric, azimuth angle of the surface
(radians). When <code>modeTrk='fixed'</code> it is the value of the
argument <code>alpha</code> converted from degrees to radians.</p>
</dd>
<dt><code>cosTheta</code>: </dt><dd><p>numeric, cosine of the incidence angle of the solar
irradiance on the surface</p>
</dd>
</dl>
</dd>
<dt><code>iS</code>:</dt><dd><p>numeric, degree of dirtiness.</p>
</dd>
<dt><code>alb</code>:</dt><dd><p>numeric, albedo reflection coefficient.</p>
</dd>
<dt><code>modeTrk</code>:</dt><dd><p>character, mode of tracking.</p>
</dd>
<dt><code>modeShd</code>:</dt><dd><p>character, mode of shadows.</p>
</dd>
<dt><code>angGen</code>:</dt><dd><p>A list with the values of <code>alpha</code>,
<code>beta</code> and <code>betaLim</code>.</p>
</dd>
<dt><code>struct</code>:</dt><dd><p>A list with the dimensions of the structure. </p>
</dd>
<dt><code>distances</code>:</dt><dd><p>A data.frame with the distances between structures.</p>
</dd>
</dl>



<h3>Extends</h3>

<p>Class <code>"<a href="#topic+G0-class">G0</a>"</code>, directly.
Class <code>"<a href="#topic+Meteo-class">Meteo</a>"</code>, by class &quot;G0&quot;, distance 2.
Class <code>"<a href="#topic+Sol-class">Sol</a>"</code>, by class &quot;G0&quot;, distance 2.
</p>


<h3>Methods</h3>


<dl>
<dt>as.data.tableD</dt><dd><p><code>signature(object = "Gef")</code>: conversion
to a data.table with daily values.</p>
</dd>
<dt>as.data.tableI</dt><dd><p><code>signature(object = "Gef")</code>: conversion
to a data.table with intradaily values.</p>
</dd>
<dt>as.data.tableM</dt><dd><p><code>signature(object = "Gef")</code>: conversion
to a data.table with monthly values.</p>
</dd>
<dt>as.data.tableY</dt><dd><p><code>signature(object = "Gef")</code>: conversion
to a data.table with yearly values.</p>
</dd>
<dt>indexD</dt><dd><p><code>signature(object = "Gef")</code>: index of the
<code>solD</code> slot. </p>
</dd>
<dt>indexI</dt><dd><p><code>signature(object = "Gef")</code>: index of the
<code>solI</code> slot. </p>
</dd>
<dt>getLat</dt><dd><p><code>signature(object = "Gef")</code>: latitude of the inherited
<code><a href="#topic+Sol-class">Sol</a></code> object. </p>
</dd>
<dt>xyplot</dt><dd><p><code>signature(x = "Gef", data = "missing")</code>: display
the time series of daily values of irradiation.</p>
</dd>
<dt>xyplot</dt><dd><p><code>signature(x = "formula", data = "Gef")</code>:
displays the contents of a <code>Gef</code> object with the
<code>xyplot</code> method for formulas.</p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>Oscar Perpiñán Lamigueiro,
Francisco Delgado López.
</p>


<h3>References</h3>


<ul>
<li><p> Perpiñán, O, Energía Solar Fotovoltaica, 2015.
(<a href="https://oscarperpinan.github.io/esf/">https://oscarperpinan.github.io/esf/</a>)
</p>
</li>
<li><p> Perpiñán, O. (2012), &quot;solaR: Solar Radiation and Photovoltaic
Systems with R&quot;, Journal of Statistical Software, 50(9), 1-32,
<a href="https://doi.org/10.18637/jss.v050.i09">doi:10.18637/jss.v050.i09</a>
</p>
</li></ul>


<h3>See Also</h3>

<p><code><a href="#topic+Sol-class">Sol</a></code>,
<code><a href="#topic+G0-class">G0</a></code>.
</p>

<hr>
<h2 id='B5_ProdGCPV-class'>Class &quot;ProdGCPV&quot;: performance of a grid connected PV system.</h2><span id='topic+ProdGCPV-class'></span><span id='topic+show+2CProdGCPV-method'></span>

<h3>Description</h3>

<p>A class containing values of the performance of a grid
connected PV system.</p>


<h3>Objects from the Class</h3>

<p>Objects can be created by <code><a href="#topic+prodGCPV">prodGCPV</a></code>.
</p>


<h3>Slots</h3>


<dl>
<dt><code>prodI</code>:</dt><dd><p>Object of class <code>data.table</code> created by
<code><a href="#topic+fProd">fProd</a></code>. It includes these components:
</p>

<dl>
<dt>Tc: </dt><dd><p>cell temperature, <code class="reqn">^{\circ}{\rm C}</code>.</p>
</dd>
<dt>Voc, Isc, Vmpp, Impp: </dt><dd><p>open circuit voltage, short circuit current, MPP voltage and current, respectively.</p>
</dd>
<dt>Vdc, Idc: </dt><dd><p>voltage and current at the input of the inverter.</p>
</dd>
<dt>Pdc: </dt><dd><p>power at the input of the inverter, W</p>
</dd>
<dt>Pac: </dt><dd><p>power at the output of the inverter, W</p>
</dd>
<dt>EffI: </dt><dd><p>efficiency of the inverter</p>
</dd>
</dl>
</dd>
<dt><code>prodD</code>:</dt><dd><p>A <code>data.table</code> object with daily values of AC (<code>Eac</code>) and
DC (<code>Edc</code>) energy (Wh), and
productivity (<code>Yf</code>, Wh/Wp) of the system.</p>
</dd>
<dt><code>prodDm</code>:</dt><dd><p>A <code>data.table</code> object with monthly means of
daily values of AC and DC energy (kWh), and
productivity of the system.</p>
</dd>
<dt><code>prody</code>:</dt><dd><p>A <code>data.table</code> object with yearly sums of AC and
DC energy (kWh), and
productivity of the system.</p>
</dd>
<dt><code>module</code>:</dt><dd><p>A list with the characteristics of the module.</p>
</dd>
<dt><code>generator</code>:</dt><dd><p>A list with the characteristics of the PV generator.</p>
</dd>
<dt><code>inverter</code>:</dt><dd><p>A list with the characteristics of the inverter.</p>
</dd>
<dt><code>effSys</code>:</dt><dd><p>A list with the efficiency values of the system.</p>
</dd>
</dl>

<p>Besides, this class contains the slots from the
<code>"<a href="#topic+Meteo-class">Meteo</a>"</code>, <code>"<a href="#topic+Sol-class">Sol</a>"</code>,
<code>"<a href="#topic+G0-class">G0</a>"</code> and <code>"<a href="#topic+Gef-class">Gef</a>"</code> classes.
</p>


<h3>Extends</h3>

<p>Class <code>"<a href="#topic+Gef-class">Gef</a>"</code>, directly.
Class <code>"<a href="#topic+G0-class">G0</a>"</code>, by class &quot;Gef&quot;, distance 2.
Class <code>"<a href="#topic+Meteo-class">Meteo</a>"</code>, by class &quot;Gef&quot;, distance 3.
Class <code>"<a href="#topic+Sol-class">Sol</a>"</code>, by class &quot;Gef&quot;, distance 3.
</p>


<h3>Methods</h3>


<dl>
<dt>as.data.tableD</dt><dd><p><code>signature(object = "ProdGCPV")</code>: conversion
to a data.table with daily values.</p>
</dd>
<dt>as.data.tableI</dt><dd><p><code>signature(object = "ProdGCPV")</code>: conversion
to a data.table with intradaily values.</p>
</dd>
<dt>as.data.tableM</dt><dd><p><code>signature(object = "ProdGCPV")</code>: conversion
to a data.table with monthly values.</p>
</dd>
<dt>as.data.tableY</dt><dd><p><code>signature(object = "ProdGCPV")</code>: conversion
to a data.table with yearly values.</p>
</dd>
<dt>indexD</dt><dd><p><code>signature(object = "ProdGCPV")</code>: index of the
<code>solD</code> slot. </p>
</dd>
<dt>indexI</dt><dd><p><code>signature(object = "ProdGCPV")</code>: index of the
<code>solI</code> object. </p>
</dd>
<dt>getLat</dt><dd><p><code>signature(object = "ProdGCPV")</code>: latitude of the inherited
<code><a href="#topic+Sol-class">Sol</a></code> object. </p>
</dd>
<dt>xyplot</dt><dd><p><code>signature(x = "ProdGCPV", data = "missing")</code>: display
the time series of daily values.</p>
</dd>
<dt>xyplot</dt><dd><p><code>signature(x = "formula", data = "ProdGCPV")</code>:
displays the contents of a <code>ProdGCPV</code> object with the
<code>xyplot</code> method for formulas.</p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>Oscar Perpiñán Lamigueiro,
Francisco Delgado López.</p>


<h3>References</h3>


<ul>
<li><p> Perpiñán, O, Energía Solar Fotovoltaica, 2015.
(<a href="https://oscarperpinan.github.io/esf/">https://oscarperpinan.github.io/esf/</a>)
</p>
</li>
<li><p> Perpiñán, O. (2012), &quot;solaR: Solar Radiation and Photovoltaic
Systems with R&quot;, Journal of Statistical Software, 50(9), 1-32,
<a href="https://doi.org/10.18637/jss.v050.i09">doi:10.18637/jss.v050.i09</a>
</p>
</li></ul>


<h3>See Also</h3>

<p><code><a href="#topic+Sol-class">Sol</a></code>,
<code><a href="#topic+G0-class">G0</a></code>,
<code><a href="#topic+Gef-class">Gef</a></code>,
<code><a href="#topic+Shade-class">Shade</a></code>.
</p>

<hr>
<h2 id='B6_ProdPVPS-class'>Class &quot;ProdPVPS&quot;: performance of a PV pumping system.</h2><span id='topic+ProdPVPS-class'></span><span id='topic+show+2CProdPVPS-method'></span>

<h3>Description</h3>

<p>Performance of a PV pumping system with a centrifugal pump
and a variable frequency converter.</p>


<h3>Objects from the Class</h3>

<p>Objects can be created by <code><a href="#topic+prodPVPS">prodPVPS</a></code>.
</p>


<h3>Slots</h3>


<dl>
<dt><code>prodI</code>:</dt><dd><p>Object of class <code>data.table</code> with these components:
</p>

<dl>
<dt>Q: </dt><dd><p>Flow rate, (m³/h)</p>
</dd>
<dt>Pb, Ph: </dt><dd><p>Pump shaft power and hydraulical power (W), respectively.</p>
</dd>
<dt>etam, etab: </dt><dd><p>Motor and pump efficiency, respectively.</p>
</dd>
<dt>f: </dt><dd><p>Frequency (Hz)</p>
</dd>
</dl>
</dd>
<dt><code>prodD</code>:</dt><dd><p>A <code>data.table</code> object with daily values of AC
energy (Wh), flow (m³) and productivity of the system.</p>
</dd>
<dt><code>prodDm</code>:</dt><dd><p>A <code>data.table</code> object with monthly means of
daily values of AC energy (kWh), flow (m³) and
productivity of the system.</p>
</dd>
<dt><code>prody</code>:</dt><dd><p>A <code>data.table</code> object with yearly sums of AC
energy (kWh), flow (m³) and productivity of the system.</p>
</dd>
<dt><code>pump</code></dt><dd><p>A <code>list</code> extracted from <code><a href="#topic+pumpCoef">pumpCoef</a></code></p>
</dd>
<dt><code>H</code></dt><dd><p>Total manometric head (m)</p>
</dd>
<dt><code>Pg</code></dt><dd><p>Nominal power of the PV generator (Wp)</p>
</dd>
<dt><code>converter</code></dt><dd><p><code>list</code> containing the nominal power of the
frequency converter, <code>Pnom</code>, and <code>Ki</code>, vector of three
values, coefficients of the efficiency curve.</p>
</dd>
<dt><code>effSys</code></dt><dd><p>list of numeric values with information about the system
losses</p>
</dd>
</dl>

<p>Besides, this class contains the slots from the <code><a href="#topic+Gef-class">Gef</a></code> class.
</p>


<h3>Extends</h3>

<p>Class <code>"<a href="#topic+Gef-class">Gef</a>"</code>, directly.
Class <code>"<a href="#topic+G0-class">G0</a>"</code>, by class &quot;Gef&quot;, distance 2.
Class <code>"<a href="#topic+Meteo-class">Meteo</a>"</code>, by class &quot;Gef&quot;, distance 3.
Class <code>"<a href="#topic+Sol-class">Sol</a>"</code>, by class &quot;Gef&quot;, distance 3.
</p>


<h3>Methods</h3>


<dl>
<dt>as.data.tableD</dt><dd><p><code>signature(object = "ProdPVPS")</code>: conversion
to a data.table with daily values.</p>
</dd>
<dt>as.data.tableI</dt><dd><p><code>signature(object = "ProdPVPS")</code>: conversion
to a data.table with intradaily values.</p>
</dd>
<dt>as.data.tableM</dt><dd><p><code>signature(object = "ProdPVPS")</code>: conversion
to a data.table with monthly values.</p>
</dd>
<dt>as.data.tableY</dt><dd><p><code>signature(object = "ProdPVPS")</code>: conversion
to a data.table with yearly values.</p>
</dd>
<dt>indexD</dt><dd><p><code>signature(object = "ProdPVPS")</code>: index of the
<code>solD</code> slot. </p>
</dd>
<dt>indexI</dt><dd><p><code>signature(object = "ProdPVPS")</code>: index of the
<code>solI</code> object. </p>
</dd>
<dt>getLat</dt><dd><p><code>signature(object = "ProdPVPS")</code>: latitude of the inherited
<code><a href="#topic+Sol-class">Sol</a></code> object. </p>
</dd>
<dt>xyplot</dt><dd><p><code>signature(x = "ProdPVPS", data = "missing")</code>: display
the time series of daily values.</p>
</dd>
<dt>xyplot</dt><dd><p><code>signature(x = "formula", data = "ProdPVPS")</code>:
displays the contents of a <code>ProdPVPS</code> object with the
<code>xyplot</code> method for formulas.</p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>Oscar Perpiñán Lamigueiro,
Francisco Delgado López.</p>


<h3>References</h3>


<ul>
<li><p> Abella, M. A., Lorenzo, E. y Chenlo, F.: PV water pumping systems based on standard frequency converters. Progress in Photovoltaics: Research and Applications, 11(3):179–191, 2003, ISSN 1099-159X.
</p>
</li>
<li><p> Perpiñán, O, Energía Solar Fotovoltaica, 2015.
(<a href="https://oscarperpinan.github.io/esf/">https://oscarperpinan.github.io/esf/</a>)
</p>
</li>
<li><p> Perpiñán, O. (2012), &quot;solaR: Solar Radiation and Photovoltaic
Systems with R&quot;, Journal of Statistical Software, 50(9), 1-32,
<a href="https://doi.org/10.18637/jss.v050.i09">doi:10.18637/jss.v050.i09</a>
</p>
</li></ul>


<h3>See Also</h3>

<p><code><a href="#topic+prodPVPS">prodPVPS</a></code>,
<code><a href="#topic+fPump">fPump</a></code>.
</p>

<hr>
<h2 id='B7_Shade-class'>Class &quot;Shade&quot;: shadows in a PV system.</h2><span id='topic+Shade-class'></span><span id='topic+as.data.frame+2CShade-method'></span><span id='topic+show+2CShade-method'></span>

<h3>Description</h3>

<p>A class for the optimization of shadows in a PV system.</p>


<h3>Objects from the Class</h3>

<p>Objects can be created by <code><a href="#topic+optimShd">optimShd</a></code>.</p>


<h3>Slots</h3>


<dl>
<dt><code>FS</code>:</dt><dd><p>numeric, shadows factor values for each
combination of distances.</p>
</dd>
<dt><code>GRR</code>:</dt><dd><p>numeric, Ground Requirement Ratio for each combination.</p>
</dd>
<dt><code>Yf</code>:</dt><dd><p>numeric, final productivity for each combination.</p>
</dd>
<dt><code>FS.loess</code>:</dt><dd><p>A local fitting of <code>FS</code> with <code>loess</code>.</p>
</dd>
<dt><code>Yf.loess</code>:</dt><dd><p>A local fitting of <code>Yf</code> with <code>loess</code>.</p>
</dd>
<dt><code>modeShd</code>:</dt><dd><p>character, mode of shadows.</p>
</dd>
<dt><code>struct</code>:</dt><dd><p>A list with the dimensions of the structure. </p>
</dd>
<dt><code>distances</code>:</dt><dd><p>A data.frame with the distances between structures.</p>
</dd>
<dt><code>res</code></dt><dd><p>numeric, difference (meters) between the different steps of the calculation.</p>
</dd>
</dl>

<p>Besides, as a reference, this class includes a <code><a href="#topic+ProdGCPV-class">ProdGCPV</a></code> object
with the performance of a PV systems without shadows.
</p>


<h3>Extends</h3>

<p>Class <code>"<a href="#topic+ProdGCPV-class">ProdGCPV</a>"</code>, directly.
Class <code>"<a href="#topic+Gef-class">Gef</a>"</code>, by class &quot;ProdGCPV&quot;, distance 2.
Class <code>"<a href="#topic+G0-class">G0</a>"</code>, by class &quot;ProdGCPV&quot;, distance 3.
Class <code>"<a href="#topic+Meteo-class">Meteo</a>"</code>, by class &quot;ProdGCPV&quot;, distance 4.
Class <code>"<a href="#topic+Sol-class">Sol</a>"</code>, by class &quot;ProdGCPV&quot;, distance 4.
</p>


<h3>Methods</h3>


<dl>
<dt>as.data.frame</dt><dd><p><code>signature(x = "Shade")</code>: conversion to a
data.frame including columns for distances (<code>Lew</code>,
<code>Lns</code>, and <code>D</code>) and results (<code>FS</code>, <code>GRR</code> and <code>Yf</code>).</p>
</dd>
<dt>shadeplot</dt><dd><p><code>signature(x = "Shade")</code>: display the results of
the iteration with a level plot for the two-axis tracking, or with
conventional plot for horizontal tracking and fixed systems.</p>
</dd>
<dt>xyplot</dt><dd><p><code>signature(x = "formula", data = "Shade")</code>:
display the content of the <code>Shade</code> object with the
<code>xyplot</code> method for formulas.</p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>Oscar Perpiñán Lamigueiro,
Francisco Delgado López.
</p>


<h3>References</h3>


<ul>
<li><p> Perpiñán, O.: Grandes Centrales Fotovoltaicas: producción, seguimiento y ciclo de vida. PhD Thesis, UNED, 2008. <a href="https://www.researchgate.net/publication/39419806_Grandes_Centrales_Fotovoltaicas_Produccion_Seguimiento_y_Ciclo_de_Vida">https://www.researchgate.net/publication/39419806_Grandes_Centrales_Fotovoltaicas_Produccion_Seguimiento_y_Ciclo_de_Vida</a>.
</p>
</li>
<li><p> Perpiñán, O, Energía Solar Fotovoltaica, 2015.
(<a href="https://oscarperpinan.github.io/esf/">https://oscarperpinan.github.io/esf/</a>)
</p>
</li>
<li><p> Perpiñán, O. (2012), &quot;solaR: Solar Radiation and Photovoltaic
Systems with R&quot;, Journal of Statistical Software, 50(9), 1-32,
<a href="https://doi.org/10.18637/jss.v050.i09">doi:10.18637/jss.v050.i09</a>
</p>
</li></ul>



<h3>See Also</h3>

<p><code><a href="#topic+Gef-class">Gef</a></code>,
<code><a href="#topic+ProdGCPV-class">ProdGCPV</a></code>.
</p>

<hr>
<h2 id='C_corrFdKt'>Correlations between the fraction of diffuse irradiation and the
clearness index.</h2><span id='topic+corrFdKt'></span><span id='topic+Ktd'></span><span id='topic+Ktm'></span><span id='topic+Kti'></span><span id='topic+FdKtPage'></span><span id='topic+FdKtLJ'></span><span id='topic+FdKtCPR'></span><span id='topic+FdKtEKDd'></span><span id='topic+FdKtCLIMEDd'></span><span id='topic+FdKtEKDh'></span><span id='topic+FdKtCLIMEDh'></span><span id='topic+FdKtBRL'></span>

<h3>Description</h3>

<p>A set of correlations between the fraction of diffuse irradiation and the
clearness index used by <code><a href="#topic+fCompD">fCompD</a></code> and <code><a href="#topic+fCompI">fCompI</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## Monthly means of daily values
Ktm(sol, G0dm)
FdKtPage(sol, G0dm)
FdKtLJ(sol, G0dm)

## Daily values
Ktd(sol, G0d)
FdKtCPR(sol, G0d)
FdKtEKDd(sol, G0d)
FdKtCLIMEDd(sol, G0d)

## Intradaily values
Kti(sol, G0i)
FdKtEKDh(sol, G0i)
FdKtCLIMEDh(sol, G0i)
FdKtBRL(sol, G0i)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="C_corrFdKt_+3A_sol">sol</code></td>
<td>
<p>A <code><a href="#topic+Sol-class">Sol</a></code> object, it may be the result of
the <code><a href="#topic+calcSol">calcSol</a></code> function.</p>
</td></tr>
<tr><td><code id="C_corrFdKt_+3A_g0dm">G0dm</code></td>
<td>
<p>A <code><a href="#topic+Meteo-class">Meteo</a></code> object with monthly means of
radiation. It may be the result of the <code><a href="#topic+readG0dm">readG0dm</a></code>
function.</p>
</td></tr>
<tr><td><code id="C_corrFdKt_+3A_g0d">G0d</code></td>
<td>
<p>A <code><a href="#topic+Meteo-class">Meteo</a></code> object with daily values of
radiation. It may be the result of the <code><a href="#topic+readBDd">readBDd</a></code> (or
equivalent) function.</p>
</td></tr>
<tr><td><code id="C_corrFdKt_+3A_g0i">G0i</code></td>
<td>
<p>A <code><a href="#topic+Meteo-class">Meteo</a></code> object with intraidaily values
of radiation. It may be the result of the <code><a href="#topic+readBDi">readBDi</a></code> (or
equivalent) function.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data.table, with two columns:
</p>
<table role = "presentation">
<tr><td><code>Fd</code></td>
<td>
<p>A numeric, the diffuse fraction.</p>
</td></tr>
<tr><td><code>Kt</code></td>
<td>
<p>A numeric, the clearness index(provided by the Kt functions).</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Oscar Perpiñán Lamigueiro, Francisco Delgado López; The BRL model was suggested by Kevin Ummel.</p>


<h3>References</h3>


<ul>
<li><p> Page, J. K., The calculation of monthly mean solar radiation for horizontal and inclined surfaces from
sunshine records for latitudes 40N-40S. En U.N. Conference on New Sources of Energy, vol. 4, págs.
378–390, 1961.
</p>
</li>
<li><p> Collares-Pereira, M. y Rabl, A.,  The average distribution of solar radiation: correlations between
diffuse and hemispherical and between daily and hourly insolation
values. Solar Energy, 22:155–164, 1979.
</p>
</li>
<li><p> Erbs, D.G, Klein, S.A. and Duffie, J.A., Estimation of the diffuse
radiation fraction for hourly, daily and monthly-average global
radiation. Solar Energy, 28:293:302, 1982.
</p>
</li>
<li><p> De Miguel, A. et al., Diffuse solar irradiation model evaluation
in the north mediterranean belt area, Solar Energy, 70:143-153, 2001.
</p>
</li>
<li><p> Ridley, B., Boland, J. and Lauret, P., Modelling of diffuse solar
fraction with multiple predictors, Renewable Energy, 35:478-482, 2010.
</p>
</li></ul>



<h3>See Also</h3>

<p><code><a href="#topic+fCompD">fCompD</a></code>,
<code><a href="#topic+fCompI">fCompI</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library("data.table")


lat &lt;- 37.2
BTd &lt;- fBTd(mode = 'prom')
G0dm &lt;- c(2.766, 3.491, 4.494, 5.912, 6.989, 7.742, 7.919, 7.027, 5.369,
    3.562, 2.814, 2.179)*1000;
Ta &lt;- c(10, 14.1, 15.6, 17.2, 19.3, 21.2, 28.4, 29.9, 24.3, 18.2, 17.2,
    15.2)

prom &lt;- readG0dm(G0dm = G0dm, Ta = Ta, lat = lat)
sol &lt;- calcSol(lat = lat, BTd = BTd)

Kt &lt;- Ktm(sol = sol, G0dm = prom)
Kt

Page &lt;- FdKtPage(sol = sol, G0dm = prom)
LJ &lt;- FdKtLJ(sol = sol, G0dm = prom)
Monthly &lt;- merge(Page, LJ, by = 'Kt',
                suffixes = c('.Page', '.LJ'))
Monthly

xyplot(Fd.Page+Fd.LJ~Kt, data = Monthly,
       type = c('l', 'g'), auto.key = list(space = 'right'))

Kt = Ktd(sol = sol, G0d = prom)
Kt

CPR &lt;- FdKtCPR(sol = sol, G0d = prom)
CLIMEDd &lt;- FdKtCLIMEDd(sol = sol, G0d = prom)
Daily &lt;- merge(CPR, CLIMEDd, by = 'Kt',
              suffixes = c('.CPR', '.CLIMEDd'))
Daily

xyplot(Fd.CPR + Fd.CLIMEDd ~ Kt, data = Daily,
       type = c('l', 'g'), auto.key = list(space = 'right'))

</code></pre>

<hr>
<h2 id='C_fBTd'>Daily time base</h2><span id='topic+fBTd'></span>

<h3>Description</h3>

<p>Construction of a daily time base for solar irradiation calculation</p>


<h3>Usage</h3>

<pre><code class='language-R'>fBTd(mode = "prom",
    year = as.POSIXlt(Sys.Date())$year+1900,
    start = paste('01-01-',year,sep = ''),
    end = paste('31-12-',year,sep = ''),
                   format = '%d-%m-%Y')
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="C_fBTd_+3A_mode">mode</code></td>
<td>
<p>character, controls the type of time base to be
created. With  <code>mode = 'serie'</code> the result is a daily time series from <code>start</code> to <code>end</code>. With <code>mode = 'prom'</code> only twelve days, one for each month, are included. During these 'average days' the declination angle is equal to the monthly mean of this angle.</p>
</td></tr>
<tr><td><code id="C_fBTd_+3A_year">year</code></td>
<td>
<p>which year is to be used for the time base when <code>mode = 'prom'</code>. Its default value is the current year.</p>
</td></tr>
<tr><td><code id="C_fBTd_+3A_start">start</code></td>
<td>
<p>first day of the time base for <code>mode = 'serie'</code>. Its default value is the first of January of the current year. </p>
</td></tr>
<tr><td><code id="C_fBTd_+3A_end">end</code></td>
<td>
<p>last day of the time base for <code>mode = 'serie'</code>. Its
default value is the last day of December of the current year.</p>
</td></tr>
<tr><td><code id="C_fBTd_+3A_format">format</code></td>
<td>
<p>format of <code>start</code> and <code>end</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is commonly used inside <code>fSolD</code>.</p>


<h3>Value</h3>

<p>This function returns a <code>POSIXct</code> object.</p>


<h3>Author(s)</h3>

<p>Oscar Perpiñán Lamigueiro,
Francisco Delgado López.</p>


<h3>References</h3>


<ul>
<li><p> Perpiñán, O, Energía Solar Fotovoltaica, 2015.
(<a href="https://oscarperpinan.github.io/esf/">https://oscarperpinan.github.io/esf/</a>)
</p>
</li>
<li><p> Perpiñán, O. (2012), &quot;solaR: Solar Radiation and Photovoltaic
Systems with R&quot;, Journal of Statistical Software, 50(9), 1-32,
<a href="https://doi.org/10.18637/jss.v050.i09">doi:10.18637/jss.v050.i09</a>
</p>
</li></ul>


<h3>See Also</h3>

<p><code><a href="#topic+fSolD">fSolD</a></code>,
<code><a href="base.html#topic+as.POSIXct">as.POSIXct</a></code>,
<code><a href="base.html#topic+seq.POSIXt">seq.POSIXt</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library("data.table")


#Average days
fBTd(mode = 'prom')

#The day #100 of the year 2008
BTd = fBTd(mode = 'serie', year = 2008)
BTd[100]
</code></pre>

<hr>
<h2 id='C_fBTi'>Intra-daily time base</h2><span id='topic+fBTi'></span>

<h3>Description</h3>

<p>Construction of an intra-daily time base for solar
irradiation calculation</p>


<h3>Usage</h3>

<pre><code class='language-R'>fBTi(BTd, sample = 'hour')
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="C_fBTi_+3A_btd">BTd</code></td>
<td>
<p>vector, it may be a result for <code>fBTd</code> or <code>indexD</code></p>
</td></tr>
<tr><td><code id="C_fBTi_+3A_sample">sample</code></td>
<td>
<p>character, identify the sample of the time set. Its
default value is 'hour'.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is commonly used inside <code>fSolI</code>.</p>


<h3>Value</h3>

<p>This function returns a <code>POSIXct</code> object.</p>


<h3>Author(s)</h3>

<p>Oscar Perpiñán Lamigueiro,
Francisco Delgado López.</p>


<h3>Examples</h3>

<pre><code class='language-R'>library("data.table")


#Average days
BTd &lt;- fBTd(mode = 'prom')

#Intradaily base time for the first day
BTi &lt;- fBTi(BTd = BTd[1], sample = 'hour')
BTi
</code></pre>

<hr>
<h2 id='C_fCompD'>Components of daily global solar irradiation on a horizontal surface</h2><span id='topic+fCompD'></span>

<h3>Description</h3>

<p>Extract the diffuse and direct components from the daily global irradiation on a horizontal surface by means of regressions between the clearness index and the diffuse fraction parameters.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fCompD(sol, G0d, corr = "CPR",f)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="C_fCompD_+3A_sol">sol</code></td>
<td>
<p>A <code>Sol</code> object from <code><a href="#topic+calcSol">calcSol</a></code> or a
<code>data.table</code> object from <code><a href="#topic+fSolD">fSolD</a></code>. Both of them
include a component named <code>Bo0d</code>, which stands for the
extra-atmospheric daily irradiation incident on a horizontal
surface</p>
</td></tr>
<tr><td><code id="C_fCompD_+3A_g0d">G0d</code></td>
<td>
<p>A <code>Meteo</code> object from <code><a href="#topic+readG0dm">readG0dm</a></code>,
<code><a href="#topic+readBDd">readBDd</a></code>, or a <code>data.table</code> object containing daily
global irradiation (Wh/m²) on a horizontal surface. See below for
<code>corr = 'none'</code>.</p>
</td></tr>
<tr><td><code id="C_fCompD_+3A_corr">corr</code></td>
<td>
<p>A character, the correlation between the fraction of diffuse irradiation and the
clearness index to be used.
</p>
<p>With this version several options are available, as described in
<code><a href="#topic+corrFdKt">corrFdKt</a></code>. For example, the <code><a href="#topic+FdKtPage">FdKtPage</a></code> is
selected with <code>corr = 'Page'</code> and the <code><a href="#topic+FdKtCPR">FdKtCPR</a></code> with
<code>corr = 'CPR'</code>.
</p>
<p>If <code>corr = 'user'</code> the use of a correlation
defined by a function <code>f</code> is possible.
</p>
<p>If <code>corr = 'none'</code> the <code>G0d</code> object should include information
about global, diffuse and direct daily irradiation with columns named
<code>G0d</code>, <code>D0d</code> and <code>B0d</code>, respectively. </p>
</td></tr>
<tr><td><code id="C_fCompD_+3A_f">f</code></td>
<td>
<p>A function defininig a correlation between the fraction of
diffuse irradiation and the clearness index. It is only neccessary when <code>corr = 'user'</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>data.table</code> object  which includes:
</p>
<table role = "presentation">
<tr><td><code>Fd</code></td>
<td>
<p>numeric, the diffuse fraction</p>
</td></tr>
<tr><td><code>Ktd</code></td>
<td>
<p>numeric, the clearness index</p>
</td></tr>
<tr><td><code>G0d</code></td>
<td>
<p>numeric, the global irradiation on a horizontal surface (Wh/m²)</p>
</td></tr>
<tr><td><code>D0d</code></td>
<td>
<p>numeric, the diffuse irradiation on a horizontal surface (Wh/m²)</p>
</td></tr>
<tr><td><code>B0d</code></td>
<td>
<p>numeric, the direct irradiation on a horizontal surface (Wh/m²)</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Oscar Perpiñán Lamigueiro,
Francisco Delgado López.
</p>


<h3>References</h3>


<ul>
<li><p> Perpiñán, O, Energía Solar Fotovoltaica, 2015.
(<a href="https://oscarperpinan.github.io/esf/">https://oscarperpinan.github.io/esf/</a>)
</p>
</li>
<li><p> Perpiñán, O. (2012), &quot;solaR: Solar Radiation and Photovoltaic
Systems with R&quot;, Journal of Statistical Software, 50(9), 1-32,
<a href="https://doi.org/10.18637/jss.v050.i09">doi:10.18637/jss.v050.i09</a>
</p>
</li></ul>


<h3>See Also</h3>

<p><code><a href="#topic+fCompI">fCompI</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library("data.table")


lat &lt;- 37.2;
BTd &lt;- fBTd(mode = 'serie')

SolD &lt;- fSolD(lat, BTd[100])

G0d &lt;- 5000
fCompD(SolD, G0d, corr = "Page")
fCompD(SolD, G0d, corr = "CPR")

#define a function fKtd with the correlation of CPR
fKTd &lt;- function(sol, G0d){
Kt &lt;- Ktm(sol, G0d)
Fd &lt;- (0.99*(Kt &lt;= 0.17))+ (Kt&gt;0.17)*(1.188 -2.272 * Kt + 9.473 * Kt^2 -
21.856 * Kt^3 + 14.648 * Kt^4)
return(data.table(Fd, Kt))}
#The same as with corr = "CPR"
fCompD(SolD, G0d, corr = "user", f = fKTd)

lat &lt;- -37.2;
SolDs &lt;- fSolD(lat, BTd[283])
G0d &lt;- data.table(Dates = SolDs$Dates, G0d = 5000)
fCompD(SolDs, G0d, corr = "CPR")

lat &lt;- 37.2;
G0dm &lt;- c(2.766,3.491,4.494,5.912,6.989,7.742,7.919,7.027,5.369,3.562,2.814,2.179)*1000;
Rad &lt;- readG0dm(G0dm, lat = lat)
solD &lt;- fSolD(lat, fBTd(mode = 'prom'))
fCompD(solD, Rad, corr = 'Page')
</code></pre>

<hr>
<h2 id='C_fCompI'>
Calculation of solar irradiance on a horizontal surface</h2><span id='topic+fCompI'></span>

<h3>Description</h3>

<p>From the daily global, diffuse and direct irradiation values supplied by <code>fCompD</code>, the profile of the global, diffuse and direct irradiance is calculated with the <code>rd</code> and <code>rg</code> components of <code>fSolI</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fCompI(sol, compD, G0I, corr = 'none', f, filterG0 = TRUE)</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="C_fCompI_+3A_sol">sol</code></td>
<td>
<p>A <code>Sol</code> object as provided by <code><a href="#topic+calcSol">calcSol</a></code> or
a <code>data.table</code> object as provided by <code><a href="#topic+fSolI">fSolI</a></code>.</p>
</td></tr>
<tr><td><code id="C_fCompI_+3A_compd">compD</code></td>
<td>
<p>A <code>data.table</code> object as provided by fCompD. It is not
considered if <code>G0I</code> is provided.</p>
</td></tr>
<tr><td><code id="C_fCompI_+3A_g0i">G0I</code></td>
<td>
<p>A <code>Meteo</code> object from <code><a href="#topic+readBDi">readBDi</a></code>,
<code><a href="#topic+dt2Meteo">dt2Meteo</a></code> or <code><a href="#topic+zoo2Meteo">zoo2Meteo</a></code>, or a
<code>data.table</code> object containing <em>intradaily</em> global
irradiance (W/m²) on a horizontal surface.
</p>
<p>See below for <code>corr = 'none'</code>.</p>
</td></tr>
<tr><td><code id="C_fCompI_+3A_corr">corr</code></td>
<td>
<p>A character, the correlation between the the fraction of
intradaily diffuse irradiation and the clearness index to be
used. It is ignored if <code>G0I</code> is not provided.
</p>
<p>With this version several correlations are available, as described in
<code><a href="#topic+corrFdKt">corrFdKt</a></code>. You should choose one of <em>intradaily</em>
proposals. For example, the <code><a href="#topic+FdKtCLIMEDh">FdKtCLIMEDh</a></code> is
selected with <code>corr = 'CLIMEDh'</code>.
</p>
<p>If <code>corr = 'user'</code> the use of a correlation defined by a function
<code>f</code> is possible.
</p>
<p>If <code>corr = 'none'</code> the <code>G0I</code> object must include information
about global, diffuse and direct intradaily irradiation with columns
named <code>G0</code>, <code>D0</code> and <code>B0</code>, respectively. </p>
</td></tr>
<tr><td><code id="C_fCompI_+3A_f">f</code></td>
<td>
<p>A function defininig a correlation between the fraction of
diffuse irradiation and the clearness index. It is only neccessary
when <code>corr = 'user'</code></p>
</td></tr>
<tr><td><code id="C_fCompI_+3A_filterg0">filterG0</code></td>
<td>
<p>A logical. If <code>TRUE</code> (default) this function sets the
global irradiation values to <code>NA</code> when they are higher than the
extra-atmospheric irradiation values.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>data.table</code> with these components:
</p>
<table role = "presentation">
<tr><td><code>kt</code></td>
<td>
<p>numeric, clearness index.</p>
</td></tr>
<tr><td><code>fd</code></td>
<td>
<p>numeric, diffuse fraction.</p>
</td></tr>
<tr><td><code>G0</code></td>
<td>
<p>numeric, global irradiance on a horizontal surface, (W/m²)</p>
</td></tr>
<tr><td><code>D0</code></td>
<td>
<p>numeric, diffuse irradiance on a horizontal surface, (W/m²)</p>
</td></tr>
<tr><td><code>B0</code></td>
<td>
<p>numeric, direct irradiance on a horizontal surface, (W/m²)</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Oscar Perpiñán Lamigueiro,
Francisco Delgado López.
</p>


<h3>References</h3>

 
<ul>
<li><p> Collares-Pereira, M. y Rabl, A.,  The average distribution of solar radiation: correlations between
diffuse and hemispherical and between daily and hourly insolation values. Solar Energy, 22:155–164, 1979.
</p>
</li>
<li><p> Perpiñán, O, Energía Solar Fotovoltaica, 2015.
(<a href="https://oscarperpinan.github.io/esf/">https://oscarperpinan.github.io/esf/</a>)
</p>
</li>
<li><p> Perpiñán, O. (2012), &quot;solaR: Solar Radiation and Photovoltaic
Systems with R&quot;, Journal of Statistical Software, 50(9), 1-32,
<a href="https://doi.org/10.18637/jss.v050.i09">doi:10.18637/jss.v050.i09</a>
</p>
</li></ul>



<h3>See Also</h3>

<p><code><a href="#topic+fCompD">fCompD</a></code>,
<code><a href="#topic+fSolI">fSolI</a></code>,
<code><a href="#topic+calcSol">calcSol</a></code>,
<code><a href="#topic+corrFdKt">corrFdKt</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library("data.table")


lat &lt;- 37.2

BTd &lt;- fBTd(mode = 'serie')
solD &lt;- fSolD(lat, BTd[100])
solI &lt;- fSolI(solD, sample = 'hour')
G0d &lt;- data.table(Dates = solD$Dates, G0d = 5000)
compD &lt;- fCompD(solD, G0d, corr = "Page")
fCompI(solI, compD)

sol &lt;- calcSol(lat, fBTd(mode = 'prom'), sample = 'hour', keep.night = FALSE)

G0dm &lt;- c(2.766, 3.491, 4.494, 5.912, 6.989, 7.742,
          7.919, 7.027, 5.369, 3.562, 2.814, 2.179)*1000

Ta &lt;- c(10, 14.1, 15.6, 17.2, 19.3, 21.2, 28.4, 29.9,
        24.3, 18.2, 17.2, 15.2)

BD &lt;- readG0dm(G0dm = G0dm, Ta = Ta, lat = lat)
compD &lt;- fCompD(sol, BD, corr = 'Page')
compI &lt;- fCompI(sol, compD)
head(compI)

## Use of 'corr'.  The help page of calcG0 includes additional examples
## with intradaily data xyplot(fd ~ kt, data = compI)

climed &lt;- fCompI(sol, G0I = compI, corr = 'CLIMEDh')
xyplot(Fd ~ Kt, data = climed)

ekdh &lt;- fCompI(sol, G0I = compI, corr = 'EKDh')
xyplot(Fd ~ Kt, data = ekdh)

brl &lt;- fCompI(sol, G0I = compI, corr = 'BRL')
xyplot(Fd ~ Kt, data = brl)
</code></pre>

<hr>
<h2 id='C_fInclin'>
Solar irradiance on an inclined surface
</h2><span id='topic+fInclin'></span>

<h3>Description</h3>

<p>The solar irradiance incident on an inclined surface is calculated from
the direct and  diffuse irradiance on a horizontal surface, and from the
evolution of the angles of the Sun and the surface. Moreover, the effect
of the angle of incidence and dust on the PV module is included to
obtain the effective irradiance.
</p>
<p>This function is used by the <code><a href="#topic+calcGef">calcGef</a></code> function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fInclin(compI, angGen, iS = 2, alb = 0.2, horizBright = TRUE, HCPV = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="C_fInclin_+3A_compi">compI</code></td>
<td>
<p>A <code>G0</code> object. It may be the result of <code><a href="#topic+calcG0">calcG0</a></code>.</p>
</td></tr>
<tr><td><code id="C_fInclin_+3A_anggen">angGen</code></td>
<td>
<p>A <code>data.table</code> object, including at least three variables
named <code>Beta</code>, <code>Alpha</code> and <code>cosTheta</code>. It may be the result of <code><a href="#topic+fTheta">fTheta</a></code>.</p>
</td></tr>
<tr><td><code id="C_fInclin_+3A_is">iS</code></td>
<td>
<p>integer, degree of dirtiness. Its value must be included in the set (1,2,3,4). <code>iS = 1</code> corresponds to a clean surface while <code>iS = 4</code> is the choice for a dirty surface. Its default value is 2</p>
</td></tr>
<tr><td><code id="C_fInclin_+3A_alb">alb</code></td>
<td>
<p>numeric, albedo reflection coefficient. Its default value
is 0.2</p>
</td></tr>
<tr><td><code id="C_fInclin_+3A_horizbright">horizBright</code></td>
<td>
<p>logical, if TRUE, the horizon brightness correction proposed by Reind et al. is used.</p>
</td></tr>
<tr><td><code id="C_fInclin_+3A_hcpv">HCPV</code></td>
<td>
<p>logical, if TRUE the diffuse and albedo components of the
<em>effective</em> irradiance are set to zero. HCPV is the acronym of
High Concentration PV system.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The solar irradiance incident on an inclined surface can be calculated from the direct and  diffuse irradiance on a horizontal surface, and from the evolution of the angles of the Sun and the surface. The transformation of the direct radiation is straightforward since only geometric considerations are needed. However, the treatment of the diffuse irradiance is more complex since it involves the modelling of the atmosphere. There are several models for the estimation of diffuse irradiance on an inclined surface. The one which combines simplicity and acceptable results is the proposal of Hay and McKay. This model divides the diffuse component in isotropic and anisotropic whose values depends on a anisotropy index.
On the other hand, the effective irradiance, the fraction of the incident irradiance that reaches the cells inside a PV module, is calculated with the losses due to the angle of incidence and dirtiness. This behaviour can be simulated with a model proposed by Martin and Ruiz requiring information about the angles of the surface and the level of dirtiness (<code>iS</code>) .
</p>


<h3>Value</h3>

<p>A <code>data.table</code> object with these components:
</p>
<table role = "presentation">
<tr><td><code>Bo</code></td>
<td>
<p>Extra-atmospheric irradiance on the inclined surface (W/m²)</p>
</td></tr>
<tr><td><code>Bn</code></td>
<td>
<p>Direct normal irradiance (W/m²)</p>
</td></tr>
<tr><td><code>G</code>, <code>B</code>, <code>D</code>, <code>Di</code>, <code>Dc</code>, <code>R</code></td>
<td>
<p>Global, direct, diffuse (total, isotropic and anisotropic) and albedo irradiance incident on an inclined surface (W/m²)</p>
</td></tr>
<tr><td><code>Gef</code>, <code>Bef</code>, <code>Def</code>, <code>Dief</code>, <code>Dcef</code>, <code>Ref</code></td>
<td>
<p>Effective global, direct, diffuse (total, isotropic and anisotropic) and albedo irradiance incident on an inclined surface (W/m²)</p>
</td></tr>
<tr><td><code>FTb</code>, <code>FTd</code>, <code>FTr</code></td>
<td>
<p>Factor of angular losses for the direct, diffuse and albedo components</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Oscar Perpiñán Lamigueiro,
Francisco Delgado López.
</p>


<h3>References</h3>


<ul>
<li><p> Hay, J. E. and McKay, D. C.: Estimating Solar Irradiance on Inclined Surfaces: A Review and Assessment of Methodologies. Int. J. Solar Energy, (3):pp. 203, 1985.
</p>
</li>
<li><p> Martin, N. and Ruiz, J.M.: Calculation of the PV modules angular losses under field conditions by means of an analytical model. Solar Energy Materials &amp; Solar Cells, 70:25–38, 2001.
</p>
</li>
<li><p> D. T. Reindl and W. A. Beckman and J. A. Duffie: Evaluation of
hourly tilted surface radiation models, Solar Energy, 45:9-17, 1990.
</p>
</li>
<li><p> Perpiñán, O, Energía Solar Fotovoltaica, 2015.
(<a href="https://oscarperpinan.github.io/esf/">https://oscarperpinan.github.io/esf/</a>)
</p>
</li>
<li><p> Perpiñán, O. (2012), &quot;solaR: Solar Radiation and Photovoltaic
Systems with R&quot;, Journal of Statistical Software, 50(9), 1-32,
<a href="https://doi.org/10.18637/jss.v050.i09">doi:10.18637/jss.v050.i09</a>
</p>
</li></ul>


<h3>See Also</h3>

<p><code><a href="#topic+fTheta">fTheta</a></code>,
<code><a href="#topic+fCompI">fCompI</a></code>,
<code><a href="#topic+calcGef">calcGef</a></code>.
</p>

<hr>
<h2 id='C_fProd'>
Performance of a PV system
</h2><span id='topic+fProd'></span>

<h3>Description</h3>

<p>Simulate the behaviour of a grid connected PV system under different
conditions of irradiance and temperature. This function is used by the
<code><a href="#topic+prodGCPV">prodGCPV</a></code> function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fProd(inclin, module, generator, inverter, effSys)</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="C_fProd_+3A_inclin">inclin</code></td>
<td>
<p>A <code><a href="#topic+Gef-class">Gef</a></code> object, a <code>data.table</code> object. In case of being <code>data.table</code> it must include a component named <code>Gef</code> (effective irradiance, W/m²) and another named <code>Ta</code> (ambient temperature, <code class="reqn">^{\circ}{\rm C}</code>).</p>
</td></tr>
<tr><td><code id="C_fProd_+3A_module">module</code></td>
<td>
<p>list of numeric values with information about the PV module, </p>

<dl>
<dt><code>Vocn</code></dt><dd><p>open-circuit voltage of the module at Standard
Test Conditions (default value 51.91 volts.)</p>
</dd>
<dt><code>Iscn</code></dt><dd><p>short circuit current of the module at Standard
Test Conditions (default value 14.07 amperes.)</p>
</dd>
<dt><code>Vmn</code></dt><dd><p>maximum power point voltage of the module at
Standard Test Conditions (default value 43.76 volts.)</p>
</dd>
<dt><code>Imn</code></dt><dd><p>Maximum power current of the module at Standard
Test Conditions (default value 13.03 amperes.)</p>
</dd>
<dt><code>Ncs</code></dt><dd><p>number of cells in series inside the module
(default value 24)</p>
</dd>
<dt><code>Ncp</code></dt><dd><p>number of cells in parallel inside the module (default value 6)</p>
</dd>
<dt><code>CoefVT</code></dt><dd><p>coefficient of decrement of voltage of each
cell with the temperature (default value 0.0049 volts per celsius degree)</p>
</dd>
<dt><code>TONC</code></dt><dd><p>nominal operational  cell temperature, celsius
degree (default value 45).</p>
</dd>
</dl>
</td></tr>
<tr><td><code id="C_fProd_+3A_generator">generator</code></td>
<td>
<p>list of numeric values with information about the generator, </p>

<dl>
<dt><code>Nms</code></dt><dd><p>number of modules in series (default value 22)</p>
</dd>
<dt><code>Nmp</code></dt><dd><p>number of modules in parallel (default value 130)</p>
</dd>
</dl>
</td></tr>
<tr><td><code id="C_fProd_+3A_inverter">inverter</code></td>
<td>
<p>list of numeric values with information about the DC/AC inverter, </p>

<dl>
<dt><code>Ki</code></dt><dd><p>vector of three values, coefficients of the
efficiency curve of the inverter (default c(0.002, 0.005, 0.008)),
or a matrix of nine values (3x3) if there is dependence with the
voltage (see references).</p>
</dd>
<dt><code>Pinv</code></dt><dd><p>nominal inverter power (W) (default value 1.5e6
watts.)</p>
</dd>
<dt><code>Vmin, Vmax</code></dt><dd><p> minimum and maximum voltages of the MPP
range of the inverter (default values 822 and 1300 volts)</p>
</dd>
<dt><code>Gumb</code></dt><dd><p> minimum irradiance for the inverter to start
(W/m²) (default value 20 W/m²)</p>
</dd>
</dl>
</td></tr>
<tr><td><code id="C_fProd_+3A_effsys">effSys</code></td>
<td>
<p>list of numeric values with information about the system losses, </p>

<dl>
<dt><code>ModQual</code></dt><dd><p>average tolerance of the set of modules (%), default value is 3</p>
</dd>
<dt><code>ModDisp</code></dt><dd><p> module parameter disperssion losses (%), default value is 2</p>
</dd>
<dt><code>OhmDC</code></dt><dd><p> Joule losses due to the DC wiring (%), default value is 1.5</p>
</dd>
<dt><code>OhmAC</code></dt><dd><p>Joule losses due to the AC wiring (%), default value is 1.5</p>
</dd>
<dt><code>MPP</code></dt><dd><p> average error of the MPP algorithm of the inverter (%), default value is 1</p>
</dd>
<dt><code>TrafoMT</code></dt><dd><p>losses due to the MT transformer (%), default value is 1</p>
</dd>
<dt><code>Disp</code></dt><dd><p> losses due to stops of the system (%), default value is 0.5</p>
</dd>
</dl>
</td></tr>
</table>


<h3>Value</h3>

<p>If <code>inclin</code> is <code>data.table</code> or <code>Gef</code> object, the result
is a <code>data.table</code> object with these components:
</p>
<table role = "presentation">
<tr><td><code>Tc</code></td>
<td>
<p>cell temperature, <code class="reqn">^{\circ}{\rm C}</code>.</p>
</td></tr>
<tr><td><code>Voc</code>, <code>Isc</code>, <code>Vmpp</code>, <code>Impp</code></td>
<td>
<p>open circuit voltage, short circuit current, MPP voltage and current, respectively, in the conditions of irradiance and temperature provided by <code>Inclin</code></p>
</td></tr>
<tr><td><code>Vdc</code>, <code>Idc</code></td>
<td>
<p>voltage and current at the input of the inverter. If no voltage limitation occurs (according to the values of <code>inverter$Vmax</code> and <code>inverter$Vmin</code>), their values are identical to <code>Vmpp</code> and <code>Impp</code>. If the limit values are reached a warning is produced</p>
</td></tr>
<tr><td><code>Pdc</code></td>
<td>
<p>power at the input of the inverter, W</p>
</td></tr>
<tr><td><code>Pac</code></td>
<td>
<p>power at the output of the inverter, W</p>
</td></tr>
<tr><td><code>EffI</code></td>
<td>
<p>efficiency of the inverter</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Oscar Perpiñán Lamigueiro,
Francisco Delgado López.
</p>


<h3>References</h3>


<ul>
<li><p> Jantsch, M., Schmidt, H. y Schmid, J.: Results on the
concerted action on power conditioning and control. 11th European
photovoltaic Solar Energy Conference, 1992.
</p>
</li>
<li><p> Baumgartner, F. P., Schmidt, H., Burger, B., Bründlinger,
R., Haeberlin, H. and Zehner, M.: Status and Relevance of the DC
Voltage Dependency of the Inverter Efficiency. 22nd European
Photovoltaic Solar Energy Conference, 2007.
</p>
</li>
<li><p> Alonso Garcia, M. C.: Caracterización y modelado de asociaciones de dispositivos fotovoltaicos. PhD Thesis, CIEMAT, 2005.
</p>
</li>
<li><p> Perpiñán, O, Energía Solar Fotovoltaica, 2015.
(<a href="https://oscarperpinan.github.io/esf/">https://oscarperpinan.github.io/esf/</a>)
</p>
</li>
<li><p> Perpiñán, O. (2012), &quot;solaR: Solar Radiation and Photovoltaic
Systems with R&quot;, Journal of Statistical Software, 50(9), 1-32,
<a href="https://doi.org/10.18637/jss.v050.i09">doi:10.18637/jss.v050.i09</a>
</p>
</li></ul>


<h3>See Also</h3>

<p><code><a href="#topic+fInclin">fInclin</a></code>,
<code><a href="#topic+prodGCPV">prodGCPV</a></code>,
<code><a href="#topic+fTemp">fTemp</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library("data.table")


inclin &lt;- data.table(Gef = c(200,400,600,800,1000),Ta = 25)

#using default values
fProd(inclin)

#Using a matrix for Ki (voltage dependence)
inv1 &lt;- list(Ki = rbind(c(-0.00019917, 7.513e-06, -5.4183e-09),
c(0.00806, -4.161e-06, 2.859e-08),
c(0.02118, 3.4002e-05, -4.8967e-08)))

fProd(inclin, inverter = inv1)

#Voltage limits of the inverter
inclin &lt;- data.table(Gef = 800,Ta = 30)
gen1 &lt;- list(Nms = 10, Nmp = 11)

prod &lt;- fProd(inclin,generator = gen1)
print(prod)

with(prod, Vdc * Idc / (Vmpp * Impp))
</code></pre>

<hr>
<h2 id='C_fPump'>Performance of a centrifugal pump</h2><span id='topic+fPump'></span>

<h3>Description</h3>

<p>Compute the performance of the different parts of a centrifugal pump fed by a frequency converter following the affinity laws.</p>


<h3>Usage</h3>

<pre><code class='language-R'>fPump(pump, H)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="C_fPump_+3A_pump">pump</code></td>
<td>
<p><code>list</code> containing the parameters of the pump to be simulated. It may be a row of <code><a href="#topic+pumpCoef">pumpCoef</a></code>.</p>
</td></tr>
<tr><td><code id="C_fPump_+3A_h">H</code></td>
<td>
<p>Total manometric head (m).</p>
</td></tr>
</table>


<h3>Value</h3>

<table role = "presentation">
<tr><td><code>lim</code></td>
<td>
<p>Range of values of electrical power input</p>
</td></tr>
<tr><td><code>fQ</code></td>
<td>
<p>Function constructed with <code>splinefun</code> relating flow and electrical power</p>
</td></tr>
<tr><td><code>fPb</code></td>
<td>
<p>Function constructed with <code>splinefun</code> relating pump shaft power and electrical power of the motor</p>
</td></tr>
<tr><td><code>fPh</code></td>
<td>
<p>Function constructed with <code>splinefun</code> relating hydraulical power and electrical power of the motor</p>
</td></tr>
<tr><td><code>fFreq</code></td>
<td>
<p>Function constructed with <code>splinefun</code> relating frequency and electrical power of the motor</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Oscar Perpiñán Lamigueiro,
Francisco Delgado López.
</p>


<h3>References</h3>


<ul>
<li><p> Abella, M. A., Lorenzo, E. y Chenlo, F.: PV water pumping systems based on standard frequency converters. Progress in Photovoltaics: Research and Applications, 11(3):179–191, 2003, ISSN 1099-159X.
</p>
</li>
<li><p> Perpiñán, O, Energía Solar Fotovoltaica, 2015.
(<a href="https://oscarperpinan.github.io/esf/">https://oscarperpinan.github.io/esf/</a>)
</p>
</li>
<li><p> Perpiñán, O. (2012), &quot;solaR: Solar Radiation and Photovoltaic
Systems with R&quot;, Journal of Statistical Software, 50(9), 1-32,
<a href="https://doi.org/10.18637/jss.v050.i09">doi:10.18637/jss.v050.i09</a>
</p>
</li></ul>


<h3>See Also</h3>

<p><code><a href="#topic+NmgPVPS">NmgPVPS</a></code>, <code><a href="#topic+prodPVPS">prodPVPS</a></code>, <code><a href="#topic+pumpCoef">pumpCoef</a></code>, <code>splinefun</code>.</p>


<h3>Examples</h3>

<pre><code class='language-R'>library("data.table")



data(pumpCoef)
CoefSP8A44 &lt;- subset(pumpCoef, Qn == 8 &amp; stages == 44)

fSP8A44 &lt;- fPump(pump = CoefSP8A44,H = 40)
SP8A44 = with(fSP8A44,{
                Pac = seq(lim[1],lim[2],by = 100)
                Pb = fPb(Pac)
                etam = Pb/Pac
                Ph = fPh(Pac)
                etab = Ph/Pb
                f = fFreq(Pac)
                Q = fQ(Pac)
                result = data.frame(Q,Pac,Pb,Ph,etam,etab,f)})

#Efficiency of the motor, pump and the motor-pump
library("latticeExtra")

SP8A44$etamb = with(SP8A44,etab*etam)
lab = c(expression(eta[motor]), expression(eta[pump]), expression(eta[mp]))
p &lt;- xyplot(etam + etab + etamb ~ Pac,data = SP8A44,type = 'l', ylab = 'Efficiency')

p + glayer(panel.text(x[1], y[1], lab[group.number], pos = 3))

#Mechanical, hydraulic and electrical power
lab &lt;- c(expression(P[pump]), expression(P[hyd]))
p &lt;- xyplot(Pb + Ph ~ Pac,data = SP8A44,type = 'l', ylab = 'Power (W)', xlab = 'AC Power (W)')

p + glayer(panel.text(x[length(x)], y[length(x)], lab[group.number], pos = 3))

#Flow and electrical power
xyplot(Q ~ Pac,data = SP8A44,type = 'l')
</code></pre>

<hr>
<h2 id='C_fSolD'>
Daily apparent movement of the Sun from the Earth
</h2><span id='topic+fSolD'></span>

<h3>Description</h3>

<p>Compute the daily apparent movement of the Sun from the Earth. This movement is mainly described (for the simulation of photovoltaic systems) by the declination angle, the sunrise angle and the daily extra-atmospheric irradiation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fSolD(lat, BTd, method = 'michalsky')
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="C_fSolD_+3A_lat">lat</code></td>
<td>
<p>Latitude (degrees) of the point of the Earth where calculations are needed. It is positive for locations above the Equator.</p>
</td></tr>
<tr><td><code id="C_fSolD_+3A_btd">BTd</code></td>
<td>
<p>Daily temporal base, a <code>POSIXct</code> object which  may be
the result of <code><a href="#topic+fBTd">fBTd</a></code>.</p>
</td></tr>
<tr><td><code id="C_fSolD_+3A_method">method</code></td>
<td>
<p><code>character</code>, method for the sun geometry
calculations to be chosen from 'cooper', 'spencer', 'michalsky' and
'strous'. See references for details.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>data.table</code> object with these components:
</p>
<table role = "presentation">
<tr><td><code>lat</code></td>
<td>
<p>Latitude (degrees)</p>
</td></tr>
<tr><td><code>decl</code></td>
<td>
<p>Declination angle (radians) for each day of year in <code>dn</code> or <code>BTd</code></p>
</td></tr>
<tr><td><code>eo</code></td>
<td>
<p>Factor of correction due the eccentricity of orbit of the Earth around the Sun.</p>
</td></tr>
<tr><td><code>ws</code></td>
<td>
<p>Sunrise angle (in radians) for each day of year. Due to the convention which considers that the solar hour angle is negative before midday, this angle is negative.</p>
</td></tr>
<tr><td><code>Bo0d</code></td>
<td>
<p>Extra-atmospheric daily irradiation (watt-hour per
squared meter) incident on a horizontal surface</p>
</td></tr>
<tr><td><code>EoT</code></td>
<td>
<p>Equation of Time.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Oscar Perpiñán Lamigueiro,
Francisco Delgado López.
</p>


<h3>References</h3>

 <ul>
<li><p>Cooper, P.I., Solar Energy, 12, 3
(1969). &quot;The Absorption of Solar Radiation in Solar Stills&quot;
</p>
</li>
<li><p>Spencer, Search 2 (5), 172,
<a href="https://www.mail-archive.com/sundial@uni-koeln.de/msg01050.html">https://www.mail-archive.com/sundial@uni-koeln.de/msg01050.html</a>
</p>
</li>
<li><p>Strous:
<a href="https://www.aa.quae.nl/en/reken/zonpositie.html">https://www.aa.quae.nl/en/reken/zonpositie.html</a>
</p>
</li>
<li><p>Michalsky, J., 1988: The Astronomical Almanac's algorithm for
approximate solar position (1950-2050), Solar Energy 40, 227-235
</p>
</li>
<li><p> Perpiñán, O, Energía Solar Fotovoltaica, 2015.
(<a href="https://oscarperpinan.github.io/esf/">https://oscarperpinan.github.io/esf/</a>)
</p>
</li>
<li><p> Perpiñán, O. (2012), &quot;solaR: Solar Radiation and Photovoltaic
Systems with R&quot;, Journal of Statistical Software, 50(9), 1-32,
<a href="https://doi.org/10.18637/jss.v050.i09">doi:10.18637/jss.v050.i09</a>
</p>
</li></ul>


<h3>Examples</h3>

<pre><code class='language-R'>library("data.table")


BTd &lt;- fBTd(mode = 'serie')

lat &lt;- 37.2
(fSolD(lat, BTd[100]))
(fSolD(lat, BTd[100], method = 'strous'))
(fSolD(lat, BTd[100], method = 'spencer'))
(fSolD(lat, BTd[100], method = 'cooper'))

lat &lt;- -37.2
(fSolD(lat, BTd[283]))

#Solar angles along the year
SolD &lt;- fSolD(lat, BTd = fBTd())

xyplot(SolD)

#Calculation of the daylength for several latitudes
library("latticeExtra")

Lats &lt;- c(-60, -40, -20, 0, 20, 40, 60)
NomLats &lt;- ifelse(Lats &gt; 0, paste(Lats,'N', sep = ''),
                  paste(abs(Lats), 'S', sep = ''))
NomLats[Lats == 0] &lt;- '0'

BTd &lt;- fBTd(mode = 'serie')
mat &lt;- matrix(nrow = length(BTd), ncol = length(Lats))
colnames(mat) &lt;- NomLats
WsZ &lt;- data.table(Dates = BTd, mat)

for (i in seq_along(Lats)){
    SolDaux &lt;- fSolD(lat = Lats[i], BTd = fBTd(mode = 'serie'));
    WsZ[,i+1] &lt;- r2h(2*abs(SolDaux$ws))}

p = xyplot(`60S` + `40S` + `20S` + `0` + `20N` + `40N` + `60N` ~ Dates, data = WsZ, type = "l",
           ylab = expression(omega[s] * (h)))
plab = p+glayer(panel.text(x[1], y[1], NomLats[group.number], pos = 2))
print(plab)
</code></pre>

<hr>
<h2 id='C_fSolI'>
Instantaneous apparent movement of the Sun from the Earth
</h2><span id='topic+fSolI'></span>

<h3>Description</h3>

<p>Compute the angles which describe the intradaily apparent movement of the Sun from the Earth.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fSolI(solD, sample = 'hour', BTi, EoT = TRUE, keep.night = TRUE, method = 'michalsky')
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="C_fSolI_+3A_sold">solD</code></td>
<td>
<p>A <code>data.table</code> object with the result of
<code>fSolD</code></p>
</td></tr>
<tr><td><code id="C_fSolI_+3A_sample">sample</code></td>
<td>
<p>Increment of the intradaily sequence. It is a character
string, containing one of ‘&quot;sec&quot;’, ‘&quot;min&quot;’, ‘&quot;hour&quot;’.  This can
optionally be preceded by a (positive or negative) integer and a
space, or followed by ‘&quot;s&quot;’. It is used by <code><a href="base.html#topic+seq.POSIXt">seq.POSIXt</a></code>.
</p>
<p>It is not considered when <code>BTi</code> is provided.</p>
</td></tr>
<tr><td><code id="C_fSolI_+3A_bti">BTi</code></td>
<td>
<p>Intradaily time base, a <code>POSIXct</code> object. It could be
the index of the <code>G0I</code> argument to
<code><a href="#topic+calcG0">calcG0</a></code>. <code>fSolI</code> will produce results only for
those days contained both in <code>solD</code> and in <code>BTi</code>.</p>
</td></tr>
<tr><td><code id="C_fSolI_+3A_eot">EoT</code></td>
<td>
<p>logical, if <code>TRUE</code> (default) the Equation of Time is used.</p>
</td></tr>
<tr><td><code id="C_fSolI_+3A_keep.night">keep.night</code></td>
<td>
<p>logical, if <code>TRUE</code> (default) the night is
included in the time series.</p>
</td></tr>
<tr><td><code id="C_fSolI_+3A_method">method</code></td>
<td>
<p><code>character</code>, method
for the sun geometry calculations to be chosen from 'cooper',
'spencer', 'michalsky' and 'strous'. See references for details.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>data.table</code> object is returned with these components:
</p>
<table role = "presentation">
<tr><td><code>lat</code></td>
<td>
<p>numeric, latitude (degrees)</p>
</td></tr>
<tr><td><code>w</code></td>
<td>
<p>numeric, solar hour angle (radians)</p>
</td></tr>
<tr><td><code>aman</code></td>
<td>
<p>logical, <code>TRUE</code> when Sun is above the horizon </p>
</td></tr>
<tr><td><code>cosThzS</code></td>
<td>
<p>numeric, cosine of the solar zenith angle</p>
</td></tr>
<tr><td><code>AzS</code></td>
<td>
<p>numeric, solar acimuth angle (radians)</p>
</td></tr>
<tr><td><code>AlS</code></td>
<td>
<p>numeric, solar elevation angle (radians)</p>
</td></tr>
<tr><td><code>Bo0</code></td>
<td>
<p>numeric, extra-atmospheric irradiance (W/m2)</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Oscar Perpiñán Lamigueiro,
Francisco Delgado López.
</p>


<h3>References</h3>

 <ul>
<li><p>Cooper, P.I., Solar Energy, 12, 3
(1969). &quot;The Absorption of Solar Radiation in Solar Stills&quot;
</p>
</li>
<li><p>Spencer, Search 2 (5), 172,
<a href="https://www.mail-archive.com/sundial@uni-koeln.de/msg01050.html">https://www.mail-archive.com/sundial@uni-koeln.de/msg01050.html</a>
</p>
</li>
<li><p>Strous:
<a href="https://www.aa.quae.nl/en/reken/zonpositie.html">https://www.aa.quae.nl/en/reken/zonpositie.html</a>
</p>
</li>
<li><p>Michalsky, J., 1988: The Astronomical Almanac's algorithm for
approximate solar position (1950-2050), Solar Energy 40, 227-235
</p>
</li>
<li><p>Collares-Pereira, M. y Rabl, A.,
The average distribution of solar radiation: correlations between
diffuse and hemispherical and between daily and hourly insolation
values. 
Solar Energy, 22:155–164, 1979.
</p>
</li>
<li><p> Perpiñán, O, Energía Solar Fotovoltaica, 2015.
(<a href="https://oscarperpinan.github.io/esf/">https://oscarperpinan.github.io/esf/</a>)
</p>
</li>
<li><p> Perpiñán, O. (2012), &quot;solaR: Solar Radiation and Photovoltaic
Systems with R&quot;, Journal of Statistical Software, 50(9), 1-32,
<a href="https://doi.org/10.18637/jss.v050.i09">doi:10.18637/jss.v050.i09</a>
</p>
</li></ul>



<h3>See Also</h3>

<p><code><a href="#topic+fSolD">fSolD</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library("data.table")


###Angles for one day
BTd &lt;- fBTd(mode = 'serie')

#North hemisphere
lat &lt;- 37.2
solD &lt;- fSolD(lat,BTd[100])
solI &lt;- fSolI(solD, sample = 'hour')
print(solI)

#South hemisphere
lat &lt;- -37.2;
solDs &lt;- fSolD(lat,BTd[283])
solIs &lt;- fSolI(solDs, sample = 'hour')
print(solIs)

###Angles for the 12 average days
lat &lt;- 37.2;
solD &lt;- fSolD(lat,BTd = fBTd(mode = 'prom'))
solI &lt;- fSolI(solD, sample = '10 min', keep.night = FALSE)

###Solar elevation angle vs. azimuth.
#This kind of graphics is useful for shadows calculations
library("latticeExtra")

mon &lt;- month.abb
p &lt;- xyplot(r2d(AlS)~r2d(AzS),
    groups = month(Dates),
    data = solI, type = 'l', col = 'black',
    xlab = expression(psi[s]),ylab = expression(gamma[s]))

plab &lt;- p + glayer({
  idx &lt;- round(length(x)/2+1)
  panel.text(x[idx], y[idx], mon[group.value], pos = 3, offset = 0.2, cex = 0.8)})

print(plab)
</code></pre>

<hr>
<h2 id='C_fSombra'>Shadows on PV systems</h2><span id='topic+fSombra'></span><span id='topic+fSombra2X'></span><span id='topic+fSombra6'></span><span id='topic+fSombraHoriz'></span><span id='topic+fSombraEst'></span>

<h3>Description</h3>

<p>Compute the shadows factor for two-axis and horizontal N-S axis trackers and fixed surfaces.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fSombra(angGen, distances, struct, modeTrk = 'fixed',prom = TRUE)

fSombra6(angGen,distances,struct,prom = TRUE)

fSombra2X(angGen,distances,struct)

fSombraHoriz(angGen, distances,struct)

fSombraEst(angGen, distances,struct)

</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="C_fSombra_+3A_anggen">angGen</code></td>
<td>
<p>A <code>data.table</code> object, including at least variables
named <code>Beta</code>, <code>Alpha</code>, <code>AzS</code>, <code>AlS</code> and <code>cosTheta</code>.</p>
</td></tr>
<tr><td><code id="C_fSombra_+3A_distances">distances</code></td>
<td>
<p><code>data.frame</code>, with a component named <code>Lew</code>, being the distance (meters) between horizontal NS and two-axis trackers along the East-West direction, a component named <code>Lns</code> for two-axis trackers or a component named <code>D</code> for static surfaces. An additional component named <code>H</code> can be included with the relative height (meters) between surfaces. When <code>modeTrk = 'two'</code> (or when <code>fSombra6</code> is used) this data.frame may have five rows. Each of these rows defines the distances of a tracker in a set of six ones.</p>
</td></tr>
<tr><td><code id="C_fSombra_+3A_struct">struct</code></td>
<td>
<p><code>list</code>. When <code>modeTrk = 'fixed'</code> or <code>modeTrk = 'horiz'</code> only a component named <code>L</code>, which is the height (meters) of the tracker, is needed. For two-axis trackers (<code>modeTrk = 'two'</code>), an additional component named <code>W</code>, the width of the tracker, is required. Moreover, two components named <code>Nrow</code> and <code>Ncol</code> are included under this list. These components define, respectively, the number of rows and columns of the whole set of trackers in the PV plant.</p>
</td></tr>
<tr><td><code id="C_fSombra_+3A_modetrk">modeTrk</code></td>
<td>
<p>character, to be chosen from <code>'fixed'</code>, <code>'two'</code> or <code>'horiz'</code>. When <code>modeTrk = 'fixed'</code> the surface is fixed (inclination and azimuth angles are constant). The performance of a two-axis tracker is calculated with <code>modeTrk = 'two'</code>, and <code>modeTrk = 'horiz'</code> is the option for an horizontal N-S tracker. Its default value is <code>modeTrk = 'fixed'</code></p>
</td></tr>
<tr><td><code id="C_fSombra_+3A_prom">prom</code></td>
<td>
<p>logical, only needed for two-axis tracker mode. If <code>TRUE</code> the shadows are averaged between the set of trackers defined by <code>struct$Nrow</code> and <code>struct$Ncol</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p><code><a href="#topic+fSombra">fSombra</a></code> is only a wrapper for <code><a href="#topic+fSombra6">fSombra6</a></code> (two-axis trackers), <code><a href="#topic+fSombraEst">fSombraEst</a></code> (fixed systems) and <code><a href="#topic+fSombraHoriz">fSombraHoriz</a></code> (horizontal N-S axis trackers). Depending on the value of <code>modeTrk</code> the corresponding function is selected.
<code><a href="#topic+fSombra6">fSombra6</a></code> calculates the shadows factor in a set of six two-axis trackers. If <code>distances</code> has only one row, this function constructs a symmetric grid around a tracker located at (0,0,0). These five trackers are located at (-Lew, Lns, H), (0, Lns, H), (Lew, Lns, H), (-Lew, 0, H) and (Lns, 0, H). It is possible to define a irregular grid around (0,0,0) including five rows in <code>distances</code>. When <code>prom = TRUE</code> the shadows factor for each of the six trackers is calculated. Then, according to the distribution of trackers in the plant defined by <code>struct$Nrow</code> and <code>struct$Ncol</code>, a weighted average of the shadows factors is the result.
It is important to note that the distances are defined between axis for trackers and between similar points of the structure for fixed surfaces.
</p>


<h3>Value</h3>

<p><code>data.table</code> including <code>angGen</code> and a variable named <code>FS</code>, which is the shadows factor. This factor is the ratio between the area of the generator affected by shadows and the total area. Therefore its value is 1 when the PV generator is completely shadowed.</p>


<h3>Author(s)</h3>

<p>Oscar Perpiñán Lamigueiro,
Francisco Delgado López.
</p>


<h3>References</h3>


<ul>
<li><p> Perpiñán, O.: Grandes Centrales Fotovoltaicas: producción, seguimiento y ciclo de vida. PhD Thesis, UNED, 2008. <a href="https://www.researchgate.net/publication/39419806_Grandes_Centrales_Fotovoltaicas_Produccion_Seguimiento_y_Ciclo_de_Vida">https://www.researchgate.net/publication/39419806_Grandes_Centrales_Fotovoltaicas_Produccion_Seguimiento_y_Ciclo_de_Vida</a>.
</p>
</li>
<li><p> Perpiñán, O, Energía Solar Fotovoltaica, 2015.
(<a href="https://oscarperpinan.github.io/esf/">https://oscarperpinan.github.io/esf/</a>)
</p>
</li>
<li><p> Perpiñán, O. (2012), &quot;solaR: Solar Radiation and Photovoltaic
Systems with R&quot;, Journal of Statistical Software, 50(9), 1-32,
<a href="https://doi.org/10.18637/jss.v050.i09">doi:10.18637/jss.v050.i09</a>
</p>
</li></ul>



<h3>See Also</h3>

<p><code><a href="#topic+calcShd">calcShd</a></code>, <code><a href="#topic+optimShd">optimShd</a></code>, <code><a href="#topic+fTheta">fTheta</a></code>, <code><a href="#topic+calcSol">calcSol</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library("data.table")


lat &lt;- 37.2;
sol &lt;- calcSol(lat, fBTd(mode = 'prom'), sample = '10 min', keep.night = FALSE)
angGen &lt;- fTheta(sol, beta = 35);
Angles &lt;- merge(as.data.tableI(sol), angGen)

###Two-axis tracker
#Symmetric grid
distances = data.table(Lew = 40,Lns = 30,H = 0)
struct = list(W = 23.11, L = 9.8, Nrow = 2, Ncol = 8)

ShdFactor &lt;- fSombra6(Angles, distances, struct, prom = FALSE)

Angles$FS = ShdFactor
xyplot(FS ~ w, groups = month(Dates), data = Angles,
    type = 'l',
    auto.key = list(space = 'right',
                    lines = TRUE,
                    points = FALSE))

#Symmetric grid defined with a five rows data.frame
distances = data.table(Lew = c(-40,0,40,-40,40),
                       Lns = c(30,30,30,0,0),
                       H = 0)
ShdFactor2 &lt;- fSombra6(Angles, distances, struct,prom = FALSE)

#of course, with the same result
identical(ShdFactor, ShdFactor2)
</code></pre>

<hr>
<h2 id='C_fTemp'>
Intradaily evolution of ambient temperature
</h2><span id='topic+fTemp'></span>

<h3>Description</h3>

<p>From the maximum and minimum daily values of ambient temperature, its evolution its calculated through a combination of cosine functions (ESRA method)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fTemp(sol, BD)</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="C_fTemp_+3A_sol">sol</code></td>
<td>
<p>A <code><a href="#topic+Sol-class">Sol</a></code> object. It may be the result of the
<code><a href="#topic+calcSol">calcSol</a></code> function.</p>
</td></tr>
<tr><td><code id="C_fTemp_+3A_bd">BD</code></td>
<td>
<p>A <code><a href="#topic+Meteo-class">Meteo</a></code> object, as provided by the
<code><a href="#topic+readBDd">readBDd</a></code> function. It must
include information about <code>TempMax</code> and <code>TempMin</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The ESRA method  estimates the dependence of the temperature on the time of the day (given as the local solar time) from only two inputs: minimum and maximum daily
temperatures. It assumes that the temperature daily profile can be
described using three piecewise cosine functions, dividing the day
into three periods: from midnight to sunrise, from sunrise to the time
of peak temperature (3 hours after midday), and to midnight.
</p>


<h3>Value</h3>

<p>A <code>data.table</code> object with the profile of the ambient temperature.</p>


<h3>Author(s)</h3>

<p>Oscar Perpiñán Lamigueiro,
Francisco Delgado López.</p>


<h3>References</h3>


<ul>
<li><p> Huld, T. , Suri, M., Dunlop, E. D., and Micale F., Estimating
average daytime and daily temperature profiles within Europe,
Environmental Modelling &amp; Software 21 (2006) 1650-1661.
</p>
</li>
<li><p> Perpiñán, O, Energía Solar Fotovoltaica, 2015.
(<a href="https://oscarperpinan.github.io/esf/">https://oscarperpinan.github.io/esf/</a>)
</p>
</li>
<li><p> Perpiñán, O. (2012), &quot;solaR: Solar Radiation and Photovoltaic
Systems with R&quot;, Journal of Statistical Software, 50(9), 1-32,
<a href="https://doi.org/10.18637/jss.v050.i09">doi:10.18637/jss.v050.i09</a>
</p>
</li></ul>



<h3>See Also</h3>

<p><code><a href="#topic+calcSol">calcSol</a></code>,
<code><a href="#topic+readBDd">readBDd</a></code>.
</p>

<hr>
<h2 id='C_fTheta'>
Angle of incidence of solar irradiation on a inclined surface
</h2><span id='topic+fTheta'></span>

<h3>Description</h3>

<p>The orientation, azimuth and incidence angle are calculated from the
results of <code>fSolI</code> or <code>calcSol</code>and from the information supplied by the
arguments <code>beta</code> and <code>alpha</code> when the surface is fixed
(<code>modeTrk = 'fixed')</code> or the movement equations when a tracking
surface is chosen (<code>modeTrk = 'horiz'</code> or <code>modeTrk = 'two')</code>.
Besides, the modified movement of a horizontal NS tracker due to the
backtracking strategy is calculated if <code>BT = TRUE</code> with information
about the tracker and the distance between the trackers included in the
system.
</p>
<p>This function is used by the <code><a href="#topic+calcGef">calcGef</a></code> function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fTheta(sol, beta, alpha = 0, modeTrk = "fixed", betaLim = 90,
    BT = FALSE, struct, dist)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="C_fTheta_+3A_sol">sol</code></td>
<td>
<p><code>Sol</code> object as provided by <code><a href="#topic+calcSol">calcSol</a></code>.</p>
</td></tr>
<tr><td><code id="C_fTheta_+3A_beta">beta</code></td>
<td>
<p>numeric, inclination angle of the surface (degrees). It is only needed when <code>modeTrk = 'fixed'</code>.</p>
</td></tr>
<tr><td><code id="C_fTheta_+3A_alpha">alpha</code></td>
<td>
<p>numeric, azimuth angle of the surface (degrees). It is
measured from the south (<code>alpha = 0</code>), and it is negative to
the east and positive to the west. It is only needed when
<code>modeTrk = 'fixed'</code>. Its default value is <code>alpha = 0</code> (surface
facing to the south).</p>
</td></tr>
<tr><td><code id="C_fTheta_+3A_modetrk">modeTrk</code></td>
<td>
<p>character, to be chosen from <code>'fixed'</code>,
<code>'two'</code> or <code>'horiz'</code>. When <code>modeTrk = 'fixed'</code> the
surface is fixed (inclination and azimuth angles are constant). The
performance of a two-axis tracker is calculated with <code>modeTrk =
      'two'</code>, and <code>modeTrk = 'horiz'</code> is the option for an
horizontal N-S tracker. Its default value is <code>modeTrk = 'fixed'</code></p>
</td></tr>
<tr><td><code id="C_fTheta_+3A_betalim">betaLim</code></td>
<td>
<p>numeric, maximum value of the inclination angle for a tracking surface. Its default value is 90 (no limitation))</p>
</td></tr>
<tr><td><code id="C_fTheta_+3A_bt">BT</code></td>
<td>
<p>logical, <code>TRUE</code> when the bactracking technique is to be used with a horizontal NS tracker, as described by Panico et al. (see References). The default value is <code>FALSE</code>. In future versions of this package this technique will be available for two-axis trackers.</p>
</td></tr>
<tr><td><code id="C_fTheta_+3A_struct">struct</code></td>
<td>
<p>Only needed when <code>BT = TRUE</code>. A <code>list</code>, with a component named <code>L</code>, which is the height (meters) of the tracker. In future versions the backtracking technique will be used in conjuction with two-axis trackers, and a additional component named <code>W</code> will be needed.</p>
</td></tr>
<tr><td><code id="C_fTheta_+3A_dist">dist</code></td>
<td>
<p>Only needed when <code>BT = TRUE</code>. A <code>data.frame</code>, with a component named <code>Lew</code>, being the distance between the horizontal NS trackers along the East-West direction. In future versions an additional component named <code>Lns</code> will be needed for two-axis trackers with backtracking.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>data.table</code> object with these components:
</p>
<table role = "presentation">
<tr><td><code>Beta</code></td>
<td>
<p>numeric, inclination angle of the surface (radians). When <code>modeTrk = 'fixed'</code> it is the value of the argument <code>beta</code> converted from degrees to radians.</p>
</td></tr>
<tr><td><code>Alpha</code></td>
<td>
<p>numeric, azimuth angle of the surface (radians). When <code>modeTrk = 'fixed'</code> it is the value of the argument <code>alpha</code> converted from degrees to radians.</p>
</td></tr>
<tr><td><code>cosTheta</code></td>
<td>
<p>numeric, cosine of the incidence angle of the solar irradiance on the surface</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Oscar Perpiñán Lamigueiro,
Francisco Delgado López.
</p>


<h3>References</h3>


<ul>
<li><p> Perpiñán, O, Energía Solar Fotovoltaica, 2015.
(<a href="https://oscarperpinan.github.io/esf/">https://oscarperpinan.github.io/esf/</a>)
</p>
</li>
<li><p> Panico, D., Garvison, P., Wenger, H. J., Shugar, D.,
Backtracking: a novel strategy for tracking PV systems, Photovoltaic
Specialists Conference, 668-673, 1991
</p>
</li>
<li><p> Perpiñán, O. (2012), &quot;solaR: Solar Radiation and Photovoltaic
Systems with R&quot;, Journal of Statistical Software, 50(9), 1-32,
<a href="https://doi.org/10.18637/jss.v050.i09">doi:10.18637/jss.v050.i09</a>
</p>
</li></ul>


<h3>See Also</h3>

<p><code><a href="#topic+fInclin">fInclin</a></code>,
<code><a href="#topic+fSombra">fSombra</a></code>,
<code><a href="#topic+calcGef">calcGef</a></code>.
</p>

<hr>
<h2 id='C_HQCurve'>H-Q curves of a centrifugal pump</h2><span id='topic+HQCurve'></span>

<h3>Description</h3>

<p>Compute and display the H-Q curves of a centrifugal pump
fed working at several frequencies, and the iso-efficiency curve as a reference.</p>


<h3>Usage</h3>

<pre><code class='language-R'>HQCurve(pump)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="C_HQCurve_+3A_pump">pump</code></td>
<td>
<p><code>list</code> containing the parameters of the pump to be simulated. It may be a row of <code><a href="#topic+pumpCoef">pumpCoef</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<table role = "presentation">
<tr><td><code>result</code></td>
<td>
<p>A <code>data.frame</code> with the result of the
simulation. It contains several columns with values of manometric
height (<code>H</code>), frequency (<code>fe</code> and <code>fb</code>), mechanical power
(<code>Pb</code>), AC electrical power (<code>Pm</code>), DC electrical power
(<code>Pdc</code>) and efficiency of the pump (<code>etab</code>) and motor (<code>etam</code>).</p>
</td></tr>
<tr><td><code>plot</code></td>
<td>
<p>The plot with several curves labelled with the
correspondent frequencies, and the isoefficiency curve (named &quot;ISO&quot;).</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Oscar Perpiñán Lamigueiro,
Francisco Delgado López.
</p>


<h3>References</h3>


<ul>
<li><p> Abella, M. A., Lorenzo, E. y Chenlo, F.: PV water pumping systems based on standard frequency converters. Progress in Photovoltaics: Research and Applications, 11(3):179–191, 2003, ISSN 1099-159X.
</p>
</li>
<li><p> Perpiñán, O, Energía Solar Fotovoltaica, 2015.
(<a href="https://oscarperpinan.github.io/esf/">https://oscarperpinan.github.io/esf/</a>)
</p>
</li>
<li><p> Perpiñán, O. (2012), &quot;solaR: Solar Radiation and Photovoltaic
Systems with R&quot;, Journal of Statistical Software, 50(9), 1-32,
<a href="https://doi.org/10.18637/jss.v050.i09">doi:10.18637/jss.v050.i09</a>
</p>
</li></ul>


<h3>See Also</h3>

<p><code><a href="#topic+NmgPVPS">NmgPVPS</a></code>,
<code><a href="#topic+prodPVPS">prodPVPS</a></code>,
<code><a href="#topic+pumpCoef">pumpCoef</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library("data.table")


data(pumpCoef)

CoefSP8A44 &lt;- subset(pumpCoef, Qn == 8&amp;stages == 44)
CurvaSP8A44 &lt;- HQCurve(pump = CoefSP8A44)
</code></pre>

<hr>
<h2 id='C_local2Solar'>
Local time, mean solar time and UTC time zone.
</h2><span id='topic+local2Solar'></span><span id='topic+lonHH'></span>

<h3>Description</h3>

<p>The function <code>local2Solar</code> converts the time zone of a <code>POSIXct</code> object to
the mean solar time and set its time zone to UTC as a synonym of mean
solar time. It includes two corrections:
the difference of longitudes between the location and the time zone, and
the daylight saving time.
</p>
<p>The function <code>lonHH</code> calculates the longitude (radians) of a time zone.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>local2Solar(x, lon = NULL)
lonHH(tz)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="C_local2Solar_+3A_x">x</code></td>
<td>
<p>a <code>POSIXct</code> object</p>
</td></tr>
<tr><td><code id="C_local2Solar_+3A_lon">lon</code></td>
<td>
<p>A numeric value of the longitude (degrees) of the
location. If <code>lon = NULL</code> (default), this value is assumed to
be equal to the longitude of the time zone of <code>x</code>, so only the
daylight saving time correction (if needed) is included.</p>
</td></tr>
<tr><td><code id="C_local2Solar_+3A_tz">tz</code></td>
<td>
<p>A character, a time zone as documented in
<a href="https://en.wikipedia.org/wiki/List_of_tz_database_time_zones">https://en.wikipedia.org/wiki/List_of_tz_database_time_zones</a>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Since the result of <code>local2Solar</code> is the mean solar time, the
Equation of Time correction is not calculated with this function. The
<code><a href="#topic+eot">eot</a></code> function includes this correction if desired.
</p>


<h3>Value</h3>

<p>The function <code>local2Solar</code> produces a <code>POSIXct</code> object
with its time zone set to UTC.
</p>
<p>The function <code>lonHH</code> gives a numeric value.</p>


<h3>Note</h3>

<p>It is important to note that the <code>solaR2</code> package sets the system
time zone to <code>UTC</code> with <code>Sys.setenv(TZ = 'UTC')</code>.
</p>


<h3>Author(s)</h3>

<p>Oscar Perpiñán Lamigueiro,
Francisco Delgado López.</p>


<h3>References</h3>


<ul>
<li><p> Perpiñán, O, Energía Solar Fotovoltaica, 2015.
(<a href="https://oscarperpinan.github.io/esf/">https://oscarperpinan.github.io/esf/</a>)
</p>
</li>
<li><p> Perpiñán, O. (2012), &quot;solaR: Solar Radiation and Photovoltaic
Systems with R&quot;, Journal of Statistical Software, 50(9), 1-32,
<a href="https://doi.org/10.18637/jss.v050.i09">doi:10.18637/jss.v050.i09</a>
</p>
</li></ul>


<h3>Examples</h3>

<pre><code class='language-R'>library("data.table")


t.local &lt;- as.POSIXct("2006-01-08 10:07:52", tz = 'Europe/Madrid')

##The local time zone and the location have the same longitude (15 degrees)
local2Solar(t.local)
##But Madrid is at lon = -3
local2Solar(t.local, lon = -3)

##Daylight saving time
t.local.dst &lt;- as.POSIXct("2006-07-08 10:07:52", tz = 'Europe/Madrid')

local2Solar(t.local.dst)
local2Solar(t.local.dst, lon = -3)

</code></pre>

<hr>
<h2 id='C_NmgPVPS'>Nomogram of a photovoltaic pumping system
</h2><span id='topic+NmgPVPS'></span>

<h3>Description</h3>

<p>This function simulate the performance of a water pump fed by a frequency converter with several PV generators of different size during a day. The result is plotted as a nomogram which relates the nominal power of the PV generator, the total water flow and the total manometric head.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>NmgPVPS(pump, Pg, H, Gd, Ta = 30,
    lambda = 0.0045, TONC = 47, eta = 0.95,
    Gmax = 1200, t0 = 6, Nm = 6,
    title = '', theme = custom.theme.2())
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="C_NmgPVPS_+3A_pump">pump</code></td>
<td>
<p>A <code>list</code> extracted from <code><a href="#topic+pumpCoef">pumpCoef</a></code></p>
</td></tr>
<tr><td><code id="C_NmgPVPS_+3A_pg">Pg</code></td>
<td>
<p>Sequence of values of the nominal power of the PV generator (Wp))</p>
</td></tr>
<tr><td><code id="C_NmgPVPS_+3A_h">H</code></td>
<td>
<p>Sequence of values of the total manometric head (m)</p>
</td></tr>
<tr><td><code id="C_NmgPVPS_+3A_gd">Gd</code></td>
<td>
<p>Global irradiation incident on the generator (Wh/m²)</p>
</td></tr>
<tr><td><code id="C_NmgPVPS_+3A_ta">Ta</code></td>
<td>
<p>Ambient temperature (<code class="reqn">^{\circ}{\rm C}</code>).</p>
</td></tr>
<tr><td><code id="C_NmgPVPS_+3A_lambda">lambda</code></td>
<td>
<p>Power losses factor due to temperature</p>
</td></tr>
<tr><td><code id="C_NmgPVPS_+3A_tonc">TONC</code></td>
<td>
<p>Nominal operational cell temperature (<code class="reqn">^{\circ}{\rm C}</code>).</p>
</td></tr>
<tr><td><code id="C_NmgPVPS_+3A_eta">eta</code></td>
<td>
<p>Average efficiency of the frequency converter</p>
</td></tr>
<tr><td><code id="C_NmgPVPS_+3A_gmax">Gmax</code></td>
<td>
<p>Maximum value of irradiance (parameter of the IEC 61725)</p>
</td></tr>
<tr><td><code id="C_NmgPVPS_+3A_t0">t0</code></td>
<td>
<p>Hours from midday to sunset (parameter of the IEC 61725)</p>
</td></tr>
<tr><td><code id="C_NmgPVPS_+3A_nm">Nm</code></td>
<td>
<p>Number of samples per hour</p>
</td></tr>
<tr><td><code id="C_NmgPVPS_+3A_title">title</code></td>
<td>
<p>Main title of the plot.</p>
</td></tr>
<tr><td><code id="C_NmgPVPS_+3A_theme">theme</code></td>
<td>
<p>Theme of the lattice plot.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function computes the irradiance profile according to the IEC 61725 &quot;Analytical Expression for Daily Solar Profiles&quot;, which is a common reference in the official documents regarding PV pumping systems.
At this version only pumps from the manufacturer Grundfos are included in <code><a href="#topic+pumpCoef">pumpCoef</a></code>.</p>


<h3>Value</h3>

<table role = "presentation">
<tr><td><code>I</code></td>
<td>
<p><code>list</code> with the results of irradiance, power and flow of the system.</p>
</td></tr>
<tr><td><code>D</code></td>
<td>
<p><code>list</code> with the results of total irradiation, electrical energy and flow for every nominal power of the generator.</p>
</td></tr>
<tr><td><code>param</code></td>
<td>
<p><code>list</code> with the arguments used in the call to the function.</p>
</td></tr>
<tr><td><code>plot</code></td>
<td>
<p><code>trellis</code> object containing the nomogram.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Oscar Perpiñán Lamigueiro,
Francisco Delgado López.
</p>


<h3>References</h3>


<ul>
<li><p> Abella, M. A., Lorenzo, E. y Chenlo, F.: PV water pumping systems based on standard frequency converters. Progress in Photovoltaics: Research and Applications, 11(3):179–191, 2003, ISSN 1099-159X.
</p>
</li>
<li><p> Perpiñán, O, Energía Solar Fotovoltaica, 2015.
(<a href="https://oscarperpinan.github.io/esf/">https://oscarperpinan.github.io/esf/</a>)
</p>
</li>
<li><p> Perpiñán, O. (2012), &quot;solaR: Solar Radiation and Photovoltaic
Systems with R&quot;, Journal of Statistical Software, 50(9), 1-32,
<a href="https://doi.org/10.18637/jss.v050.i09">doi:10.18637/jss.v050.i09</a>
</p>
</li></ul>



<h3>See Also</h3>

<p><code><a href="#topic+fPump">fPump</a></code>, <code><a href="#topic+prodPVPS">prodPVPS</a></code>, <code><a href="#topic+pumpCoef">pumpCoef</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>library("data.table")


Pg = seq(4000, 8000,by = 100);
H = seq(120, 150,by = 5);

data(pumpCoef)

CoefSP8A44 &lt;- subset(pumpCoef, Qn == 8 &amp; stages == 44)

NmgSP8A44 &lt;- NmgPVPS(pump = CoefSP8A44,Pg = Pg,H = H,Gd = 5000,
     title = 'Choice of Pump', theme = custom.theme())
</code></pre>

<hr>
<h2 id='C_sample2Diff'>Small utilities for difftime objects.</h2><span id='topic+diff2Hours'></span><span id='topic+char2diff'></span><span id='topic+sample2Hours'></span><span id='topic+P2E'></span>

<h3>Description</h3>

<p><code>diff2Hours</code> converts a <code>difftime</code> object into its numeric
value with <code>units = 'hours'</code>.
</p>
<p><code>char2diff</code> converts a character description into a
<code>difftime</code> object, following the code of
<code><a href="base.html#topic+seq.POSIXt">seq.POSIXt</a></code>.
</p>
<p><code>sample2Hours</code> calculates the sampling time in hours described by a character
or a <code>difftime</code>.
</p>
<p><code>P2E</code> (power to energy) sums a series of power values (for
example, irradiance) to obtain energy aggregation (for example,
irradiation) using <code>sample2Hours</code> for the units conversion.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>diff2Hours(by)
char2diff(by)
sample2Hours(by)
P2E(x, by)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="C_sample2Diff_+3A_by">by</code></td>
<td>
<p>A character for <code>char2diff</code>, <code>sample2Hours</code> and <code>P2E</code>, or
a <code>difftime</code> for <code>diff2Hours</code>, <code>sample2Hours</code> and
<code>P2E</code>.</p>
</td></tr>
<tr><td><code id="C_sample2Diff_+3A_x">x</code></td>
<td>
<p>A numeric vector.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A numeric value or a <code>difftime</code> object.</p>


<h3>Author(s)</h3>

<p>Oscar Perpiñán Lamigueiro,
Francisco Delgado López.</p>


<h3>See Also</h3>

<p><code><a href="#topic+Sol-class">Sol</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library("data.table")


char2diff('min')
char2diff('2 s')

sample2Hours('s')
sample2Hours('30 m')

by1 &lt;- char2diff('10 min')
sample2Hours(by1)
</code></pre>

<hr>
<h2 id='C_solarAngles'>Solar angles</h2><span id='topic+declination'></span><span id='topic+eccentricity'></span><span id='topic+eot'></span><span id='topic+sunrise'></span><span id='topic+bo0d'></span><span id='topic+sunHour'></span><span id='topic+zenith'></span><span id='topic+azimuth'></span>

<h3>Description</h3>

<p>A set of functions that compute the apparent movement of
the Sun from the Earth.</p>


<h3>Usage</h3>

<pre><code class='language-R'>## Declination
declination(d, method = 'michalsky')

## Eccentricity
eccentricity(d, method = 'michalsky')

## Equation of time
eot(d)

## Solar time
sunrise(d, lat, method = 'michalsky',
        decl = declination(d, method = method))


## Extraterrestrial irradiation
bo0d(d, lat, method = 'michalsky',
     decl = declination(d, method = method),
     eo = eccentricity(d, method = method),
     ws = sunrise(d, lat, method = method))

## Sun hour angle
sunHour(d, BTi, sample = 'hour', EoT = TRUE,
        method = 'michalsky',
        eqtime = eot(d))

## Cosine of the zenith angle
zenith(d, lat, BTi, sample = 'hour', method = 'michalsky',
       decl = declination(d, method = method),
       w = sunHour(d, BTi, sample, method = method))

## Azimuth angle
azimuth(d, lat, BTi, sample = 'hour', method = 'michalsky',
        decl = declination(d, method = method),
        w = sunHour(d, BTi, sample, method = method),
        cosThzS = zenith(d, lat, BTi, sample,
                         method = method,
                         decl = decl,
                         w = w))
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="C_solarAngles_+3A_d">d</code></td>
<td>
<p>Date, a daily time base, it may be the result of
<code><a href="#topic+fBTd">fBTd</a></code></p>
</td></tr>
<tr><td><code id="C_solarAngles_+3A_method">method</code></td>
<td>
<p>character, method for the sun geometry calculations, to
be chosen from 'cooper', 'spencer', 'michalsky' and 'strous'. See
references for details.</p>
</td></tr>
<tr><td><code id="C_solarAngles_+3A_lat">lat</code></td>
<td>
<p>numeric, latitude (degrees) of the point of the Earth where
calculations are needed.
It is positive for locations above the Equator.</p>
</td></tr>
<tr><td><code id="C_solarAngles_+3A_sample">sample</code></td>
<td>
<p>Character, increment of the intradaily sequence.</p>
</td></tr>
<tr><td><code id="C_solarAngles_+3A_bti">BTi</code></td>
<td>
<p><code>POSIXct</code>, intradily time base, it may the result of
<code><a href="#topic+fBTi">fBTi</a></code>.</p>
</td></tr>
<tr><td><code id="C_solarAngles_+3A_eot">EoT</code></td>
<td>
<p>logical, if <code>EoT=TRUE</code> (default value), the function
<code>sunHour</code> use the Equation of time</p>
</td></tr>
<tr><td><code id="C_solarAngles_+3A_decl">decl</code>, <code id="C_solarAngles_+3A_eo">eo</code>, <code id="C_solarAngles_+3A_ws">ws</code>, <code id="C_solarAngles_+3A_eqtime">eqtime</code>, <code id="C_solarAngles_+3A_w">w</code>, <code id="C_solarAngles_+3A_costhzs">cosThzS</code></td>
<td>
<p>Arguments that compute the
variables they reference (default value). It can be replaced with
previously calculated values to avoid calculating the same variable
twice.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector with the calculated elements. Its size varies depending on
whether the calculations are daily or intradaily. 
</p>


<h3>Author(s)</h3>

<p>Francisco Delgado López,
Oscar Perpiñán Lamigueiro.</p>


<h3>References</h3>

 <ul>
<li><p>Cooper, P.I., Solar Energy, 12, 3
(1969). &quot;The Absorption of Solar Radiation in Solar Stills&quot;
</p>
</li>
<li><p>Spencer, Search 2 (5), 172,
<a href="https://www.mail-archive.com/sundial@uni-koeln.de/msg01050.html">https://www.mail-archive.com/sundial@uni-koeln.de/msg01050.html</a>
</p>
</li>
<li><p>Strous:
<a href="https://www.aa.quae.nl/en/reken/zonpositie.html">https://www.aa.quae.nl/en/reken/zonpositie.html</a>
</p>
</li>
<li><p>Michalsky, J., 1988: The Astronomical Almanac's algorithm for
approximate solar position (1950-2050), Solar Energy 40, 227-235
</p>
</li>
<li><p> Perpiñán, O, Energía Solar Fotovoltaica, 2015.
(<a href="https://oscarperpinan.github.io/esf/">https://oscarperpinan.github.io/esf/</a>)
</p>
</li>
<li><p> Perpiñán, O. (2012), &quot;solaR: Solar Radiation and Photovoltaic
Systems with R&quot;, Journal of Statistical Software, 50(9), 1-32,
<a href="https://doi.org/10.18637/jss.v050.i09">doi:10.18637/jss.v050.i09</a> </p>
</li></ul>
 

<h3>See Also</h3>

<p><code><a href="#topic+fSolD">fSolD</a></code>,
<code><a href="#topic+fSolI">fSolI</a></code>,
<code><a href="#topic+calcSol">calcSol</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library("data.table")


d = fBTd(mode = 'serie')[100]

decl = declination(d, method = 'michalsky')
decl

w = sunHour(d, sample = 'hour', method = 'michalsky')
w

cosThzS = zenith(d, lat = 37.2, sample = 'hour',
                 method = 'michalsky',
                 decl = decl,
                 w = w)
cosThzS

</code></pre>

<hr>
<h2 id='C_utils-angle'>Conversion between angle units.</h2><span id='topic+d2r'></span><span id='topic+r2d'></span><span id='topic+h2r'></span><span id='topic+r2h'></span><span id='topic+r2sec'></span><span id='topic+h2d'></span><span id='topic+d2h'></span>

<h3>Description</h3>

<p>Several small functions to convert angle units. </p>


<h3>Usage</h3>

<pre><code class='language-R'>d2r(x)
r2d(x)
h2r(x)
h2d(x)
r2h(x)
d2h(x)
r2sec(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="C_utils-angle_+3A_x">x</code></td>
<td>
<p>A numeric value.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A numeric value:
</p>

<dl>
<dt>d2r: </dt><dd><p>Degrees to radians.</p>
</dd>
<dt>r2d: </dt><dd><p>Radians to degrees.</p>
</dd>
<dt>h2r: </dt><dd><p>Hours to radians.</p>
</dd>
<dt>r2h: </dt><dd><p>Radians to hours.</p>
</dd>
<dt>h2d: </dt><dd><p>Hours to degrees.</p>
</dd>
<dt>d2h: </dt><dd><p>Degrees to hours.</p>
</dd>
<dt>r2sec: </dt><dd><p>Radians to seconds.</p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>Oscar Perpiñán Lamigueiro,
Francisco Delgado López.</p>

<hr>
<h2 id='C_utils-time'>Utilities for time indexes.</h2><span id='topic+hms'></span><span id='topic+doy'></span><span id='topic+dom'></span><span id='topic+dst'></span><span id='topic+truncDay'></span>

<h3>Description</h3>

<p>Several small functions to extract information from <code>POSIXct</code>
indexes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>hms(x)
doy(x)
dom(x)
dst(x)
truncDay(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="C_utils-time_+3A_x">x</code></td>
<td>
<p>A <code>POSIXct</code> vector.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>doy</code> and <code>dom</code> provide the (numeric) day of year and day of month,
respectively.
</p>
<p><code>hms</code> gives the numeric value
</p>
<p><code>hour(x)+minute(x)/60+second(x)/3600</code>
</p>
<p><code>dst</code> is +1 if the Daylight Savings Time flag is in force,
zero if not, -1 if unknown (<code><a href="base.html#topic+DateTimeClasses">DateTimeClasses</a></code>).
</p>
<p><code>truncDay</code> truncates the <code>POSIXct</code> object towards the day.
</p>


<h3>Author(s)</h3>

<p>Oscar Perpiñán Lamigueiro,
Francisco Delgado López.
</p>


<h3>See Also</h3>

<p><code>as.POSIXct</code>
</p>

<hr>
<h2 id='D_as.data.tableD-methods'>Methods for Function as.data.tableD</h2><span id='topic+as.data.tableD'></span><span id='topic+as.data.tableD-methods'></span><span id='topic+as.data.tableD+2CG0-method'></span><span id='topic+as.data.tableD+2CGef-method'></span><span id='topic+as.data.tableD+2CProdGCPV-method'></span><span id='topic+as.data.tableD+2CProdPVPS-method'></span><span id='topic+as.data.tableD+2CSol-method'></span>

<h3>Description</h3>

<p>Convert a <code>Sol</code>, <code>G0</code>, <code>Gef</code>,
<code>ProdGCPV</code> or <code>ProdPVPS</code> object into a
<code>data.table</code> object with daily values.</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'Sol'
as.data.tableD(object, complete=FALSE, day=FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="D_as.data.tableD-methods_+3A_object">object</code></td>
<td>
<p>A <code>Sol</code> object (or extended.)</p>
</td></tr>
<tr><td><code id="D_as.data.tableD-methods_+3A_complete">complete</code></td>
<td>
<p>A logical.</p>
</td></tr>
<tr><td><code id="D_as.data.tableD-methods_+3A_day">day</code></td>
<td>
<p>A logical.</p>
</td></tr>
</table>


<h3>Methods</h3>


<dl>
<dt><code>signature(object = "Sol")</code></dt><dd><p>Conversion to a <code>data.table</code>
object with the content of the <code>solD</code> slot. If <code>day=TRUE</code>
(default is <code>FALSE</code>), the result includes three columns named
<code>month</code>, <code>day</code> (day of the year) and <code>year</code>. 
</p>
</dd>
<dt><code>signature(object = "G0")</code></dt><dd><p>If <code>complete=FALSE</code> (default) the result includes only
the columns of <code>G0d</code>, <code>D0d</code> and <code>B0d</code> from the
<code>G0D</code> slot. If
<code>complete=TRUE</code> it returns the contents of the slots <code>solD</code>
and <code>G0D</code>.
</p>
</dd>
<dt><code>signature(object = "Gef")</code></dt><dd><p>If <code>complete=FALSE</code> (default) the result includes only
the columns of <code>Gefd</code>, <code>Defd</code> and <code>Befd</code> from the
<code>GefD</code> slot. If
<code>complete=TRUE</code> it returns the contents of the slots <code>solD</code>,
<code>G0D</code> and <code>GefD</code>
</p>
</dd>
<dt><code>signature(object = "ProdGCPV")</code></dt><dd><p>If <code>complete=FALSE</code>
(default) the result includes only the columns of <code>Eac</code>,
<code>Edc</code> and <code>Yf</code> from the <code>prodD</code> slot. If
<code>complete=TRUE</code> it returns the contents of the slots <code>solD</code>,
<code>G0D</code>, <code>GefD</code> and <code>prodD</code>.
</p>
</dd>
<dt><code>signature(object = "ProdPVPS")</code></dt><dd><p>If <code>complete=FALSE</code>
(default) the result includes only the columns of <code>Eac</code>,
<code>Qd</code> and <code>Yf</code> from the <code>prodD</code> slot. If
<code>complete=TRUE</code> it returns the contents of the slots <code>solD</code>,
<code>G0D</code>, <code>GefD</code> and <code>prodD</code>.
</p>
</dd>
</dl>


<h3>Author(s)</h3>

<p>Oscar Perpiñán Lamigueiro,
Francisco Delgado López.</p>


<h3>Examples</h3>

<pre><code class='language-R'>library("data.table")


lat = 37.2
BTd = fBTd(mode = 'prom')
sol = calcSol(lat, BTd)
solD = as.data.tableD(sol)
solD

solD2 = as.data.tableD(sol, day = TRUE)
solD2

G0dm &lt;- c(2766, 3491, 4494, 5912, 6989, 7742, 7919, 7027, 5369, 3562,
          2814, 2179)
Ta &lt;- c(10, 14.1, 15.6, 17.2, 19.3, 21.2, 28.4, 29.9, 24.3, 18.2,
        17.2, 15.2)
prom &lt;- list(G0dm = G0dm, Ta = Ta)
prodfixed = prodGCPV(lat, dataRad = prom)
prodD = as.data.tableD(prodfixed, complete = TRUE, day = TRUE)
prodD
</code></pre>

<hr>
<h2 id='D_as.data.tableI-methods'>Methods for Function as.data.tableI</h2><span id='topic+as.data.tableI'></span><span id='topic+as.data.tableI-methods'></span><span id='topic+as.data.tableI+2CG0-method'></span><span id='topic+as.data.tableI+2CGef-method'></span><span id='topic+as.data.tableI+2CProdGCPV-method'></span><span id='topic+as.data.tableI+2CProdPVPS-method'></span><span id='topic+as.data.tableI+2CSol-method'></span>

<h3>Description</h3>

<p>Convert a <code>Sol</code>, <code>G0</code>, <code>Gef</code>,
<code>ProdGCPV</code> or <code>ProdPVPS</code> object into a
<code>data.table</code> object with daily values.</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'Sol'
as.data.tableI(object, complete=FALSE, day=FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="D_as.data.tableI-methods_+3A_object">object</code></td>
<td>
<p>A <code>Sol</code> object (or extended.)</p>
</td></tr>
<tr><td><code id="D_as.data.tableI-methods_+3A_complete">complete</code></td>
<td>
<p>A logical.</p>
</td></tr>
<tr><td><code id="D_as.data.tableI-methods_+3A_day">day</code></td>
<td>
<p>A logical.</p>
</td></tr>
</table>


<h3>Methods</h3>


<dl>
<dt><code>signature(object = "Sol")</code></dt><dd><p>If <code>complete=FALSE</code> and
<code>day=FALSE</code> (default) the result includes only the content of the
<code>solI</code> slot. If <code>complete=TRUE</code> the contents of the
<code>solD</code> slots are included.
</p>
</dd>
<dt><code>signature(object = "G0")</code></dt><dd><p>If <code>complete=FALSE</code> and
<code>day=FALSE</code> (default) the result includes only   the columns of
<code>G0</code>, <code>D0</code> and <code>B0</code> of the <code>G0I</code> slot.
If  <code>complete=TRUE</code> it returns the contents of the slots <code>G0I</code>
and <code>solI</code>. If <code>day=TRUE</code> the daily values (slots <code>G0D</code>
and <code>solD</code>) are also included.)
</p>
</dd>
<dt><code>signature(object = "Gef")</code></dt><dd><p>If <code>complete=FALSE</code> and
<code>day=FALSE</code> (default) the result includes only  the columns of
<code>Gef</code>, <code>Def</code> and <code>Bef</code> of the <code>GefI</code> slot. If  <code>complete=TRUE</code> it
returns the contents of the slots <code>GefI</code>, <code>G0I</code> and
<code>solI</code>. If <code>day=TRUE</code> the daily values (slots <code>GefD</code>, <code>G0D</code>
and <code>solD</code>) are also included.)
</p>
</dd>
<dt><code>signature(object = "ProdGCPV")</code></dt><dd><p>If <code>complete=FALSE</code> and
<code>day=FALSE</code> (default) the result includes only  the columns of
<code>Pac</code> and <code>Pdc</code> of the <code>prodI</code> slot. If  <code>complete=TRUE</code> it
returns the contents of the slots <code>prodI</code>, <code>GefI</code>, <code>G0I</code> and
<code>solI</code>. If <code>day=TRUE</code> the daily values (slots <code>prodD</code>, <code>GefD</code>, <code>G0D</code>
and <code>solD</code>) are also included.)
</p>
</dd>
<dt><code>signature(object = "ProdPVPS")</code></dt><dd><p>If <code>complete=FALSE</code> and
<code>day=FALSE</code> (default) the result includes only  the columns of
<code>Pac</code> and <code>Q</code> of the <code>prodI</code> slot. If  <code>complete=TRUE</code> it
returns the contents of the slots <code>prodI</code>, <code>GefI</code>, <code>G0I</code> and
<code>solI</code>. If <code>day=TRUE</code> the daily values (slots <code>prodD</code>, <code>GefD</code>, <code>G0D</code>
and <code>solD</code>) are also included.)
</p>
</dd>
</dl>


<h3>Author(s)</h3>

<p>Oscar Perpiñán Lamigueiro,
Francisco Delgado López.</p>


<h3>Examples</h3>

<pre><code class='language-R'>library("data.table")


lat = 37.2
BTd = fBTd(mode = 'prom')[1]
sol = calcSol(lat, BTd, keep.night = FALSE)
solI = as.data.tableI(sol)
solI

solI2 = as.data.tableI(sol, day = TRUE)
solI2 

G0dm &lt;- c(2766, 3491, 4494, 5912, 6989, 7742, 7919, 7027, 5369, 3562,
          2814, 2179)
Ta &lt;- c(10, 14.1, 15.6, 17.2, 19.3, 21.2, 28.4, 29.9, 24.3, 18.2,
        17.2, 15.2)
prom &lt;- list(G0dm = G0dm, Ta = Ta)
prodfixed = prodGCPV(lat, dataRad = prom)
prodI = as.data.tableI(prodfixed, complete = TRUE, day = TRUE)
prodI
</code></pre>

<hr>
<h2 id='D_as.data.tableM-methods'>Methods for Function as.data.tableM</h2><span id='topic+as.data.tableM'></span><span id='topic+as.data.tableM-methods'></span><span id='topic+as.data.tableM+2CG0-method'></span><span id='topic+as.data.tableM+2CGef-method'></span><span id='topic+as.data.tableM+2CProdGCPV-method'></span><span id='topic+as.data.tableM+2CProdPVPS-method'></span>

<h3>Description</h3>

<p>Convert a <code>G0</code>, <code>Gef</code>,
<code>ProdGCPV</code> or <code>ProdPVPS</code> object into a
<code>as.data.table</code> object with monthly average of daily values.</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'G0'
as.data.tableM(object, complete=FALSE, day=FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="D_as.data.tableM-methods_+3A_object">object</code></td>
<td>
<p>A <code>G0</code> object (or extended.)</p>
</td></tr>
<tr><td><code id="D_as.data.tableM-methods_+3A_complete">complete</code></td>
<td>
<p>A logical.</p>
</td></tr>
<tr><td><code id="D_as.data.tableM-methods_+3A_day">day</code></td>
<td>
<p>A logical</p>
</td></tr>
</table>


<h3>Methods</h3>


<dl>
<dt><code>signature(object = "G0")</code></dt><dd><p>The result is the <code>G0dm</code>
slot. If <code>day=TRUE</code> (default is <code>FALSE</code>), the result
includes two columns names <code>month</code> and <code>year</code>.
</p>
</dd>
<dt><code>signature(object = "Gef")</code></dt><dd><p>If <code>complete=FALSE</code>
(default) the result is the slot <code>Gefdm</code>. If
<code>complete=TRUE</code> it returns the slot <code>G0dm</code>.
</p>
</dd>
<dt><code>signature(object = "ProdGCPV")</code></dt><dd><p>If <code>complete=FALSE</code>
(default) the result is the <code>prodDm</code> slot. If
<code>complete=TRUE</code> the result includes the slots <code>G0dm</code> and <code>Gefdm</code>.
</p>
</dd>
<dt><code>signature(object = "ProdPVPS")</code></dt><dd><p>If <code>complete=FALSE</code>
(default) the result is the <code>prodDm</code> slot. If
<code>complete=TRUE</code> the result includes the slots <code>G0dm</code> and <code>Gefdm</code>.
</p>
</dd>
</dl>


<h3>Author(s)</h3>

<p>Oscar Perpiñán Lamigueiro,
Francisco Delgado López.</p>


<h3>Examples</h3>

<pre><code class='language-R'>library("data.table")


lat &lt;- 37.2
G0dm &lt;- c(2766, 3491, 4494, 5912, 6989, 7742, 7919, 7027, 5369, 3562,
          2814, 2179)
Ta &lt;- c(10, 14.1, 15.6, 17.2, 19.3, 21.2, 28.4, 29.9, 24.3, 18.2,
        17.2, 15.2)
prom &lt;- list(G0dm = G0dm, Ta = Ta)
prodfixed &lt;- prodGCPV(lat, dataRad = prom)
prodM &lt;- as.data.tableM(prodfixed, complete = TRUE, day = TRUE)
prodM
</code></pre>

<hr>
<h2 id='D_as.data.tableY-methods'>Methods for Function as.data.tableY</h2><span id='topic+as.data.tableY'></span><span id='topic+as.data.tableY-methods'></span><span id='topic+as.data.tableY+2CG0-method'></span><span id='topic+as.data.tableY+2CGef-method'></span><span id='topic+as.data.tableY+2CProdGCPV-method'></span><span id='topic+as.data.tableY+2CProdPVPS-method'></span>

<h3>Description</h3>

<p>Convert a <code>G0</code>, <code>Gef</code>,
<code>ProdGCPV</code> or <code>ProdPVPS</code> object into a
<code>data.table</code> object with yearly values.</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'G0'
as.data.tableY(object, complete=FALSE, day=FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="D_as.data.tableY-methods_+3A_object">object</code></td>
<td>
<p>A <code>G0</code> object (or extended.)</p>
</td></tr>
<tr><td><code id="D_as.data.tableY-methods_+3A_complete">complete</code></td>
<td>
<p>A logical.</p>
</td></tr>
<tr><td><code id="D_as.data.tableY-methods_+3A_day">day</code></td>
<td>
<p>A logical.</p>
</td></tr>
</table>


<h3>Methods</h3>


<dl>
<dt><code>signature(object = "G0")</code></dt><dd><p>The result is the <code>G0y</code>
slot. If <code>day = TRUE</code> (default is <code>FALSE</code>), the result
includes a column named <code>year</code>.
</p>
</dd>
<dt><code>signature(object = "Gef")</code></dt><dd><p>If <code>complete=FALSE</code>
(default) the result is the slot <code>Gefy</code>. If
<code>complete=TRUE</code> it returns the slot <code>G0y</code>.
</p>
</dd>
<dt><code>signature(object = "ProdGCPV")</code></dt><dd><p>If <code>complete=FALSE</code>
(default) the result is the <code>prody</code> slot. If
<code>complete=TRUE</code> the result includes the slots <code>G0y</code> and <code>Gefy</code>.
</p>
</dd>
<dt><code>signature(object = "ProdPVPS")</code></dt><dd><p>If <code>complete=FALSE</code>
(default) the result is the <code>prody</code> slot. If
<code>complete=TRUE</code> the result includes the slots <code>G0y</code> and <code>Gefy</code>.
</p>
</dd>
</dl>


<h3>Author(s)</h3>

<p>Oscar Perpiñán Lamigueiro,
Francisco Delgado López.</p>


<h3>Examples</h3>

<pre><code class='language-R'>library("data.table")


lat &lt;- 37.2
G0dm &lt;- c(2766, 3491, 4494, 5912, 6989, 7742, 7919, 7027, 5369, 3562,
          2814, 2179)
Ta &lt;- c(10, 14.1, 15.6, 17.2, 19.3, 21.2, 28.4, 29.9, 24.3, 18.2,
        17.2, 15.2)
prom &lt;- list(G0dm = G0dm, Ta = Ta)
prodfixed = prodGCPV(lat, dataRad = prom)
prodY = as.data.tableY(prodfixed, complete = TRUE, day = TRUE)
prodY
</code></pre>

<hr>
<h2 id='D_compare-methods'>Compare G0, Gef and ProdGCPV objects</h2><span id='topic+compare'></span><span id='topic+compare-methods'></span><span id='topic+compare+2CG0-method'></span><span id='topic+compare+2CGef-method'></span><span id='topic+compare+2CProdGCPV-method'></span>

<h3>Description</h3>

<p>Compare and plot the yearly values of several objects.</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'G0'
compare(...)</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="D_compare-methods_+3A_...">...</code></td>
<td>
<p>A list of objects to be compared.</p>
</td></tr>
</table>


<h3>Methods</h3>

<p>The class of the first element of <code>...</code> is used to determine the
suitable method. The result is plotted with <code><a href="graphics.html#topic+dotplot">dotplot</a></code>:</p>

<dl>
<dt><code>signature(... = "G0")</code></dt><dd><p>yearly values of <code>G0d</code>, 
<code>B0d</code> and <code>D0d</code>.</p>
</dd>
<dt><code>signature(... = "Gef")</code></dt><dd><p>yearly values of <code>Gefd</code>, <code>Befd</code> and <code>Defd</code>.</p>
</dd>
<dt><code>signature(... = "ProdGCPV")</code></dt><dd><p>yearly values of <code>Yf</code>, <code>Gefd</code> and <code>G0d</code>.</p>
</dd>
</dl>


<h3>Author(s)</h3>

<p>Oscar Perpiñán Lamigueiro,
Francisco Delgado López.</p>


<h3>See Also</h3>

<p><code><a href="graphics.html#topic+dotplot">dotplot</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library("data.table")


lat &lt;- 37.2;
G0dm &lt;- c(2766, 3491, 4494, 5912, 6989, 7742, 7919, 7027, 5369, 3562, 2814,
2179)
Ta &lt;- c(10, 14.1, 15.6, 17.2, 19.3, 21.2, 28.4, 29.9, 24.3, 18.2, 17.2, 15.2)
prom &lt;- list(G0dm = G0dm, Ta = Ta)

###Comparison of different tracker methods
ProdFixed &lt;- prodGCPV(lat = lat, dataRad = prom, keep.night = FALSE)
Prod2x &lt;- prodGCPV(lat = lat, dataRad = prom, modeTrk = 'two', keep.night = FALSE)
ProdHoriz &lt;- prodGCPV(lat = lat, dataRad = prom, modeTrk = 'horiz', keep.night = FALSE)

compare(ProdFixed, Prod2x, ProdHoriz)

##The first element rules the method
GefFixed &lt;- as(ProdFixed, 'Gef')
compare(GefFixed, Prod2x, ProdHoriz)

</code></pre>

<hr>
<h2 id='D_getData-methods'>Methods for function getData</h2><span id='topic+getData'></span><span id='topic+getData-methods'></span><span id='topic+getData+2CMeteo-method'></span>

<h3>Description</h3>

<p>Meteorological source data of a <code>Meteo</code> (or extended) object.
</p>


<h3>Methods</h3>


<dl>
<dt><code>signature(object = "Meteo")</code></dt><dd><p>returns the meteorological
source data of the slot <code>data</code> of the object.
</p>
</dd>
</dl>


<h3>Author(s)</h3>

<p>Oscar Perpiñán Lamigueiro,
Francisco Delgado López.</p>

<hr>
<h2 id='D_getG0-methods'>Methods for function getG0</h2><span id='topic+getG0'></span><span id='topic+getG0-methods'></span><span id='topic+getG0+2CMeteo-method'></span>

<h3>Description</h3>

<p>Global irradiation source data of a <code>Meteo</code> (or extended) object.
</p>


<h3>Methods</h3>


<dl>
<dt><code>signature(object = "Meteo")</code></dt><dd><p>returns the global irradiation
values stored in a <code>Meteo</code> object.
</p>
</dd>
</dl>


<h3>Author(s)</h3>

<p>Oscar Perpiñán Lamigueiro,
Francisco Delgado López.</p>

<hr>
<h2 id='D_getLat-methods'>Methods for Function getLat</h2><span id='topic+getLat'></span><span id='topic+getLat-methods'></span><span id='topic+getLat+2CG0-method'></span><span id='topic+getLat+2CMeteo-method'></span><span id='topic+getLat+2CSol-method'></span>

<h3>Description</h3>

<p>Latitude angle of <code>solaR</code> objects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getLat(object, units='rad')</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="D_getLat-methods_+3A_object">object</code></td>
<td>
<p>A <code>Sol</code> or <code>Meteo</code> object (or extended.)</p>
</td></tr>
<tr><td><code id="D_getLat-methods_+3A_units">units</code></td>
<td>
<p>A character, 'rad' or 'deg'.</p>
</td></tr>
</table>


<h3>Methods</h3>

<p>This function returns the latitude angle in radians
(<code>units='rad'</code>, default) or degrees (<code>units='deg'</code>).
</p>

<dl>
<dt><code>signature(object = "Meteo")</code></dt><dd><p>Value of the <code>latData</code>
slot, which is defined by the argument <code>lat</code> of the
<code><a href="#topic+readG0dm">readG0dm</a></code> and
<code><a href="#topic+readBDd">readBDd</a></code> functions, or by the <code>lat</code> component of the
<code>dataRad</code> object passed to <code>calcG0</code>
(or equivalent) . It is the latitude of the
meteorological station (or equivalent) which provided the irradiation
source data. It may be different from the value used for the
calculation procedure.</p>
</dd>
<dt><code>signature(object = "Sol")</code></dt><dd><p>Value of the <code>lat</code> slot,
which is defined by the argument <code>lat</code> of the <code>calcSol</code>
function. It is the value used through the calculation procedure.</p>
</dd>
<dt><code>signature(object = "G0")</code></dt><dd><p>same as for the <code>Sol</code> class.</p>
</dd>
</dl>


<h3>Author(s)</h3>

<p>Oscar Perpiñán Lamigueiro,
Francisco Delgado López.</p>

<hr>
<h2 id='D_indexD-methods'>Methods for Function indexD</h2><span id='topic+indexD'></span><span id='topic+indexD-methods'></span><span id='topic+indexD+2CMeteo-method'></span><span id='topic+indexD+2CSol-method'></span><span id='topic+indexD+2CG0-method'></span>

<h3>Description</h3>

<p>Daily time index of <code>solaR</code> objects.
</p>


<h3>Methods</h3>


<dl>
<dt><code>signature(object = "Meteo")</code></dt><dd><p>returns the index of the
<code>data</code> slot (a <code>data.table</code> object.)
</p>
</dd>
<dt><code>signature(object = "Sol")</code></dt><dd><p>returns the index of the
<code>solD</code> slot (a <code>data.table</code> object.)
</p>
</dd>
<dt><code>signature(object = "G0")</code></dt><dd><p>same as for <code>object='Sol'</code></p>
</dd>
</dl>


<h3>Author(s)</h3>

<p>Oscar Perpiñán Lamigueiro,
Francisco Delgado López.</p>

<hr>
<h2 id='D_indexI-methods'>Methods for Function indexI</h2><span id='topic+indexI'></span><span id='topic+indexI-methods'></span><span id='topic+indexI+2CSol-method'></span>

<h3>Description</h3>

<p>Intra-daily time index of <code>solaR</code> objects.
</p>


<h3>Methods</h3>


<dl>
<dt><code>signature(object = "Sol")</code></dt><dd><p>returns the index of the slot
<code>solI</code> (a <code>data.table</code> object).
</p>
</dd>
</dl>


<h3>Author(s)</h3>

<p>Oscar Perpiñán Lamigueiro,
Francisco Delgado López.</p>

<hr>
<h2 id='D_levelplot-methods'>Methods for function levelplot.</h2><span id='topic+levelplot-methods'></span><span id='topic+levelplot+2Cformula+2Czoo-method'></span><span id='topic+levelplot+2Cformula+2CSol-method'></span><span id='topic+levelplot+2Cformula+2CMeteo-method'></span><span id='topic+levelplot+2Cformula+2CG0-method'></span>

<h3>Description</h3>

<p>Methods for function <code>levelplot</code> and <code>zoo</code> and <code>solaR</code> objects.
</p>


<h3>Methods</h3>


<dl>
<dt><code>signature(x = "formula", data = "Meteo")</code>: </dt><dd>
<p>The <code>Meteo</code> object is converted into a <code>data.table</code> object, and
the previous method is used.</p>
</dd>
<dt><code>signature(x = "formula", data = "Sol")</code>: </dt><dd><p>idem</p>
</dd>
<dt><code>signature(x = "formula", data = "G0")</code>: </dt><dd><p>idem</p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>Oscar Perpiñán Lamigueiro,
Francisco Delgado López.</p>

<hr>
<h2 id='D_Losses-methods'>Losses of a GCPV system</h2><span id='topic+compareLosses'></span><span id='topic+compareLosses-methods'></span><span id='topic+compareLosses+2CProdGCPV-method'></span><span id='topic+losses'></span><span id='topic+losses-methods'></span><span id='topic+losses+2CGef-method'></span><span id='topic+losses+2CProdGCPV-method'></span>

<h3>Description</h3>

<p>The function <code>losses</code> calculates the yearly losses
from a <code>Gef</code> or a <code>ProdGCPV</code> object. The function
<code>compareLosses</code> compares the losses from several <code>ProdGCPV</code>
objects and plots the result with <code><a href="graphics.html#topic+dotplot">dotplot</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>compareLosses(...)
losses(object)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="D_Losses-methods_+3A_...">...</code></td>
<td>
<p>A list of <code>ProdGCPV</code> objects to be compared.</p>
</td></tr>
<tr><td><code id="D_Losses-methods_+3A_object">object</code></td>
<td>
<p>An object of <code>Gef</code> or <code>ProdGCPV</code> class..</p>
</td></tr>
</table>


<h3>Methods</h3>


<dl>
<dt><code>signature(... = "Gef")</code></dt><dd><p>shadows and angle of
incidence (<code>AoI</code>) losses.</p>
</dd>
<dt><code>signature(... = "ProdGCPV")</code></dt><dd><p>shadows, <code>AoI</code>,
generator (mainly temperature), DC and AC system (as detailed in
<code>effSys</code> of <code><a href="#topic+fProd">fProd</a></code>) and inverter losses.</p>
</dd>
</dl>


<h3>Author(s)</h3>

<p>Oscar Perpiñán Lamigueiro,
Francisco Delgado López.</p>


<h3>References</h3>


<ul>
<li><p> Perpiñán, O, Energía Solar Fotovoltaica, 2015.
(<a href="https://oscarperpinan.github.io/esf/">https://oscarperpinan.github.io/esf/</a>)
</p>
</li>
<li><p> Perpiñán, O. (2012), &quot;solaR: Solar Radiation and Photovoltaic
Systems with R&quot;, Journal of Statistical Software, 50(9), 1-32,
<a href="https://doi.org/10.18637/jss.v050.i09">doi:10.18637/jss.v050.i09</a> </p>
</li></ul>


<h3>See Also</h3>

<p><code><a href="#topic+fInclin">fInclin</a></code>,
<code><a href="#topic+fProd">fProd</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library("data.table")
setDTthreads(2)

lat &lt;- 37.2;
G0dm &lt;- c(2766, 3491, 4494, 5912, 6989, 7742, 7919, 7027, 5369, 3562, 2814,
2179)
Ta &lt;- c(10, 14.1, 15.6, 17.2, 19.3, 21.2, 28.4, 29.9, 24.3, 18.2, 17.2, 15.2)
prom &lt;- list(G0dm = G0dm, Ta = Ta)

###Comparison of different tracker methods
ProdFixed &lt;- prodGCPV(lat = lat,dataRad = prom, keep.night = FALSE)
Prod2x &lt;- prodGCPV(lat = lat, dataRad = prom, modeTrk = 'two', keep.night = FALSE)
ProdHoriz &lt;- prodGCPV(lat = lat,dataRad = prom, modeTrk = 'horiz', keep.night = FALSE)

losses(ProdFixed)
losses(as(ProdFixed, 'Gef'))

compareLosses(ProdFixed, Prod2x, ProdHoriz)
</code></pre>

<hr>
<h2 id='D_mergesolaR-methods'>Merge solaR objects</h2><span id='topic+mergesolaR'></span><span id='topic+mergesolaR-methods'></span><span id='topic+mergesolaR+2CG0-method'></span><span id='topic+mergesolaR+2CGef-method'></span><span id='topic+mergesolaR+2CMeteo-method'></span><span id='topic+mergesolaR+2CProdGCPV-method'></span><span id='topic+mergesolaR+2CProdPVPS-method'></span>

<h3>Description</h3>

<p>Merge the daily time series of solaR objects</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'G0'
mergesolaR(...)</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="D_mergesolaR-methods_+3A_...">...</code></td>
<td>
<p>A list of objects to be merged.</p>
</td></tr>
</table>


<h3>Methods</h3>

<p>The class of the first element of <code>...</code> is used to
determine the suitable method. Only the most important daily variable is
merged, depending on the class of the objects:</p>

<dl>
<dt><code>signature(... = "Meteo")</code></dt><dd><p><code>G0</code></p>
</dd>
<dt><code>signature(... = "G0")</code></dt><dd><p><code>G0d</code></p>
</dd>
<dt><code>signature(... = "Gef")</code></dt><dd><p><code>Gefd</code></p>
</dd>
<dt><code>signature(... = "ProdGCPV")</code></dt><dd><p><code>Yf</code></p>
</dd>
<dt><code>signature(... = "ProdPVPS")</code></dt><dd><p><code>Yf</code></p>
</dd>
</dl>


<h3>Author(s)</h3>

<p>Oscar Perpiñán Lamigueiro,
Francisco Delgado López.</p>


<h3>Examples</h3>

<pre><code class='language-R'>library("data.table")


lat &lt;- 37.2;
G0dm &lt;- c(2766, 3491, 4494, 5912, 6989, 7742, 7919, 7027, 5369, 3562, 2814,
2179)
Ta &lt;- c(10, 14.1, 15.6, 17.2, 19.3, 21.2, 28.4, 29.9, 24.3, 18.2, 17.2, 15.2)
prom &lt;- list(G0dm = G0dm, Ta = Ta)

###Different tracker methods
ProdFixed &lt;- prodGCPV(lat = lat,dataRad = prom, keep.night = FALSE)
Prod2x &lt;- prodGCPV(lat = lat, dataRad = prom, modeTrk = 'two', keep.night = FALSE)
ProdHoriz &lt;- prodGCPV(lat = lat,dataRad = prom, modeTrk = 'horiz', keep.night = FALSE)

prod &lt;- mergesolaR(ProdFixed, Prod2x, ProdHoriz)
head(prod)
</code></pre>

<hr>
<h2 id='D_shadeplot-methods'>Methods for Function shadeplot</h2><span id='topic+shadeplot'></span><span id='topic+shadeplot-methods'></span><span id='topic+shadeplot+2CShade-method'></span>

<h3>Description</h3>

<p>Visualization of the content of a <code><a href="#topic+Shade-class">Shade</a></code> object.
</p>


<h3>Methods</h3>


<dl>
<dt><code>signature(x = "Shade")</code></dt><dd><p>display the results of
the iteration with a level plot for the two-axis tracking, or with
conventional plot for horizontal tracking and fixed systems.</p>
</dd>
</dl>


<h3>Author(s)</h3>

<p>Oscar Perpiñán Lamigueiro,
Francisco Delgado López.</p>

<hr>
<h2 id='D_window-methods'>Methods for extracting a time window</h2><span id='topic+window'></span><span id='topic+window-methods'></span><span id='topic++5B+2CMeteo+2CANY+2CANY-method'></span><span id='topic++5B+2CSol+2CANY+2CANY-method'></span><span id='topic++5B+2CG0+2CANY+2CANY-method'></span><span id='topic++5B+2CGef+2CANY+2CANY-method'></span><span id='topic++5B+2CProdGCPV+2CANY+2CANY-method'></span><span id='topic++5B+2CProdPVPS+2CANY+2CANY-method'></span><span id='topic++5B+2CMeteo-method'></span><span id='topic++5B+2CSol-method'></span><span id='topic++5B+2CG0-method'></span><span id='topic++5B+2CGef-method'></span><span id='topic++5B+2CProdGCPV-method'></span><span id='topic++5B+2CProdPVPS-method'></span>

<h3>Description</h3>

<p>Method for extracting the subset of a <code>solaR</code> object
whose daily time index (<code><a href="#topic+indexD">indexD</a></code>) is comprised between the
times <code>i</code> and <code>j</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'Meteo'
x[i, j, ..., drop = TRUE]
## S4 method for signature 'Sol'
x[i, j, ..., drop = TRUE]
## S4 method for signature 'G0'
x[i, j, ..., drop = TRUE]
## S4 method for signature 'Gef'
x[i, j, ..., drop = TRUE]
## S4 method for signature 'ProdGCPV'
x[i, j, ..., drop = TRUE]
## S4 method for signature 'ProdPVPS'
x[i, j, ..., drop = TRUE]
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="D_window-methods_+3A_x">x</code></td>
<td>
<p>A <code>Meteo</code>, <code>Sol</code>, etc. object.</p>
</td></tr>
<tr><td><code id="D_window-methods_+3A_i">i</code></td>
<td>
<p>an index/time value (<code>Date</code> or <code>POSIXct</code>
classes) defining the start of the time window.</p>
</td></tr>
<tr><td><code id="D_window-methods_+3A_j">j</code></td>
<td>
<p>an index/time value (<code>Date</code> or <code>POSIXct</code>
classes) defining the end of the time window.</p>
</td></tr>
<tr><td><code id="D_window-methods_+3A_...">...</code>, <code id="D_window-methods_+3A_drop">drop</code></td>
<td>
<p>Additional arguments for <code>window.zoo</code></p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Oscar Perpiñán Lamigueiro,
Francisco Delgado López.</p>


<h3>See Also</h3>

<p><code><a href="#topic+indexD">indexD</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library("data.table")


lat &lt;- 37.2
sol &lt;- calcSol(lat, BTd = fBTd(mode = 'serie'))
range(indexD(sol))

start &lt;- as.Date(indexD(sol)[1])
end &lt;- start + 30

solWindow &lt;- sol[start, end]
range(indexD(solWindow))
</code></pre>

<hr>
<h2 id='D_writeSolar-methods'>Exporter of solaR results</h2><span id='topic+writeSolar'></span><span id='topic+writeSolar-methods'></span><span id='topic+writeSolar+2CSol-method'></span>

<h3>Description</h3>

<p>Exports the results of the <code>solaR</code> functions as text
files using <code><a href="utils.html#topic+write.table">write.table</a></code></p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'Sol'
writeSolar(object, file, complete = FALSE,
    day = FALSE, timeScales = c('i', 'd', 'm', 'y'), sep = ',', ...)</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="D_writeSolar-methods_+3A_object">object</code></td>
<td>
<p>A <code>Sol</code> object (or extended.)</p>
</td></tr>
<tr><td><code id="D_writeSolar-methods_+3A_file">file</code></td>
<td>
<p>A character with the name of the file.</p>
</td></tr>
<tr><td><code id="D_writeSolar-methods_+3A_complete">complete</code></td>
<td>
<p>A logical. Should all the variables be exported?</p>
</td></tr>
<tr><td><code id="D_writeSolar-methods_+3A_day">day</code></td>
<td>
<p>A logical. Should be daily values included in the
intradaily file?</p>
</td></tr>
<tr><td><code id="D_writeSolar-methods_+3A_timescales">timeScales</code></td>
<td>
<p>A character. Use 'i' to export intradaily values,
'd' for daily values, 'm' for monthly values and 'y' for yearly
values. A different file will be created for each choice.</p>
</td></tr>
<tr><td><code id="D_writeSolar-methods_+3A_sep">sep</code></td>
<td>
<p>The field separator character.</p>
</td></tr>
<tr><td><code id="D_writeSolar-methods_+3A_...">...</code></td>
<td>
<p>Additional arguments for <code>write.table</code></p>
</td></tr>
</table>


<h3>Methods</h3>


<dl>
<dt><code>signature(object = "Sol")</code></dt><dd><p>This function exports the
slots with results using <code><a href="utils.html#topic+write.table">write.table</a></code>. If <code>complete
	= FALSE</code> and <code>day = FALSE</code> (default) the result includes only the
content of the <code>solI</code> slot. It <code>day = TRUE</code> the contents of
the <code>solD</code> slot are included.</p>
</dd>
<dt><code>signature(object = "G0")</code></dt><dd><p>If <code>complete = FALSE</code> and
<code>day = FALSE</code> (default) the result includes only the columns of
<code>G0</code>, <code>D0</code> and <code>B0</code> of the <code>G0I</code> slot. If
<code>complete = TRUE</code> it returns the contents of the slots <code>G0I</code>
and <code>solI</code>. If <code>day = TRUE</code> the daily values (slots
<code>G0D</code> and <code>solD</code>) are also included.  </p>
</dd>
<dt><code>signature(object = "Gef")</code></dt><dd><p>If <code>complete = FALSE</code> and
<code>day = FALSE</code> (default) the result includes only the columns of
<code>Gef</code>, <code>Def</code> and <code>Bef</code> of the <code>GefI</code> slot. If
<code>complete = TRUE</code> it returns the contents of the slots <code>GefI</code>,
<code>G0I</code> and <code>solI</code>. If <code>day = TRUE</code> the daily values (slots
<code>GefD</code>, <code>G0D</code> and <code>solD</code>) are also included.  </p>
</dd>
<dt><code>signature(object = "ProdGCPV")</code></dt><dd><p>If <code>complete = FALSE</code>
and <code>day = FALSE</code> (default) the result includes only the columns of
<code>Pac</code> and <code>Pdc</code> of the <code>prodI</code> slot. If
<code>complete = TRUE</code> it returns the contents of the slots
<code>prodI</code>, <code>GefI</code>, <code>G0I</code> and <code>solI</code>. If
<code>day = TRUE</code> the daily values (slots <code>prodD</code>, <code>GefD</code>,
<code>G0D</code> and <code>solD</code>) are also included.  </p>
</dd>
<dt><code>signature(object = "ProdPVPS")</code></dt><dd><p>If <code>complete = FALSE</code>
and <code>day = FALSE</code> (default) the result includes only the columns of
<code>Pac</code> and <code>Q</code> of the <code>prodI</code> slot. If
<code>complete = TRUE</code> it returns the contents of the slots
<code>prodI</code>, <code>GefI</code>, <code>G0I</code> and <code>solI</code>. If
<code>day = TRUE</code> the daily values (slots <code>prodD</code>, <code>GefD</code>,
<code>G0D</code> and <code>solD</code>) are also included.  </p>
</dd>
</dl>


<h3>Author(s)</h3>

<p>Oscar Perpiñán Lamigueiro,
Francisco Delgado López.</p>


<h3>See Also</h3>

<p><code><a href="utils.html#topic+write.table">write.table</a></code>,
<code><a href="data.table.html#topic+fread">fread</a></code>,
<code><a href="#topic+as.data.tableI">as.data.tableI</a></code>,
<code><a href="#topic+as.data.tableD">as.data.tableD</a></code>,
<code><a href="#topic+as.data.tableM">as.data.tableM</a></code>,
<code><a href="#topic+as.data.tableY">as.data.tableY</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library("data.table")


lat &lt;- 37.2;
G0dm &lt;- c(2766, 3491, 4494, 5912, 6989, 7742, 7919, 7027, 5369, 3562, 2814, 2179)
Ta &lt;- c(10, 14.1, 15.6, 17.2, 19.3, 21.2, 28.4, 29.9, 24.3, 18.2, 17.2, 15.2)
prom &lt;- list(G0dm = G0dm, Ta = Ta)

prodFixed &lt;- prodGCPV(lat = lat, dataRad = prom, modeRad = 'aguiar', keep.night = FALSE)

old &lt;- setwd(tempdir())

writeSolar(prodFixed, 'prodFixed.csv')

dir()

zI &lt;- fread("prodFixed.csv",
            header = TRUE, sep = ",")
zI

zD &lt;- fread("prodFixed.D.csv",
            header = TRUE, sep = ",")
zD

zM &lt;- fread("prodFixed.M.csv",
            header = TRUE, sep = ",")
zM

zY &lt;- fread("prodFixed.Y.csv",
            header = TRUE, sep = ",")
zY

setwd(old)
</code></pre>

<hr>
<h2 id='D_xyplot-methods'>Methods for function xyplot in Package &lsquo;solaR&rsquo;</h2><span id='topic+xyplot-methods'></span><span id='topic+xyplot+2Cformula+2CShade-method'></span><span id='topic+xyplot+2Cformula+2CMeteo-method'></span><span id='topic+xyplot+2Cformula+2CSol-method'></span><span id='topic+xyplot+2Cformula+2CG0-method'></span><span id='topic+xyplot+2Cdata.table+2Cmissing-method'></span><span id='topic+xyplot+2CMeteo+2Cmissing-method'></span><span id='topic+xyplot+2CG0+2Cmissing-method'></span><span id='topic+xyplot+2CProdPVPS+2Cmissing-method'></span><span id='topic+xyplot+2CProdGCPV+2Cmissing-method'></span>

<h3>Description</h3>

<p>Methods for function <code>xyplot</code> in Package &lsquo;solaR&rsquo;</p>


<h3>Methods</h3>


<dl>
<dt><code>signature(x = "data.table", data = "missing")</code>: </dt><dd>
<p>This method creates an XY plot for objects of class
<code>data.table</code> without specifying a <code>data</code> argument. It
must contain a column named <code>Dates</code> with the time information.</p>
</dd>
<dt><code>signature(x = "formula", data = "Meteo")</code>: </dt><dd>
<p>The <code>Meteo</code> object is converted into a <code>data.table</code> object with
<code>getData(x)</code> and displayed with the method for <code>data.table</code>.
</p>
</dd>
<dt><code>signature(x = "formula", data = "Sol")</code>: </dt><dd>
<p>The <code>Sol</code> object is converted into a <code>data.table</code> object
with <code>as.data.tableI(x, complete = TRUE, day = TRUE)</code> and
displayed with the method for <code>data.table</code>.
</p>
</dd>
<dt><code>signature(x = "formula", data = "G0")</code>: </dt><dd>
<p>Idem.
</p>
</dd>
<dt><code>signature(x = "Meteo", data = "missing")</code>: </dt><dd>
<p>The <code>Meteo</code> object is converted into a <code>data.table</code>
object with <code>getData(data)</code>. This <code>data.table</code> is the
<code>x</code> argument for a call to <code>xyplot</code>, using the S4
method for <code>signature(x = "data.table", data = "missing")</code>.
</p>
</dd>
<dt><code>signature(x = "G0", data = "missing")</code>: </dt><dd>
<p>The <code>G0</code> object is converted into a <code>data.table</code> object
with <code>indexD(data)</code>. This <code>data.table</code> is the <code>x</code>
argument for a call to <code>xyplot</code>, using the S4 method for
<code>signature(x = 'data.table', data = 'missing')</code>.
</p>
</dd>
<dt><code>signature(x = "ProdGCPV", data = "missing")</code>: </dt><dd>
<p>Idem, but the variables are not superposed.</p>
</dd>
<dt><code>signature(x = "ProdPVPS", data = "missing")</code>: </dt><dd>
<p>Idem.</p>
</dd>
<dt><code>signature(x = "formula", data = "Shade")</code>: </dt><dd>
<p>Idem.</p>
</dd>
</dl>


<h3>Author(s)</h3>

<p>Oscar Perpiñán Lamigueiro,
Francisco Delgado López.</p>

<hr>
<h2 id='E_aguiar'>Markov Transition Matrices for the Aguiar etal. procedure</h2><span id='topic+aguiar'></span><span id='topic+MTM'></span><span id='topic+Ktlim'></span><span id='topic+Ktmtm'></span>

<h3>Description</h3>

<p>Markov Transition Matrices and auxiliary data for generating
sequences of daily radiation values.</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(MTM)</code></pre>


<h3>Format</h3>

<p><code>MTM</code> is a <code>data.frame</code> with the collection of Markov
Transition Matrices defined in the paper &quot;Simple procedure for
generating sequences of daily radiation values using a library of
Markov transition matrices&quot;, Aguiar et al., Solar Energy,
1998. <code>Ktlim</code> (matrix) and <code>Ktmtm</code> (vector) are auxiliary data
to choose the correspondent matrix of the collection.
</p>


<h3>Author(s)</h3>

<p>Oscar Perpiñán Lamiguiero,
Francisco Delgado López.</p>

<hr>
<h2 id='E_helios'>Daily irradiation and ambient temperature from the Helios-IES database</h2><span id='topic+helios'></span>

<h3>Description</h3>

<p>A year of irradiation, maximum and minimum ambient
temperature from the HELIOS-IES database.</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(helios)</code></pre>


<h3>Format</h3>

<p>A data frame with 355 observations on the following 4 variables:
</p>

<dl>
<dt><code>yyyy.mm.dd</code></dt><dd><p>a factor: year, month and day.</p>
</dd>
<dt><code>G.0.</code></dt><dd><p>a numeric vector, daily global horizontal irradiation.</p>
</dd>
<dt><code>TambMax</code></dt><dd><p>a numeric vector, maximum ambient temperature.</p>
</dd>
<dt><code>TambMin</code></dt><dd><p>a numeric vector, minimum ambient temperature.</p>
</dd>
</dl>



<h3>Source</h3>

<p>http://helios.ies-def.upm.es/consulta.aspx</p>

<hr>
<h2 id='E_prodEx'>Productivity of a set of PV systems of a PV plant.</h2><span id='topic+prodEx'></span>

<h3>Description</h3>

<p>A <code>data.table</code> object with the time evolution of the final productivity of a set
of 22 systems of a large PV plant.</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(prodEx)</code></pre>


<h3>References</h3>

<p>O. Perpiñán, Statistical analysis of the performance and
simulation of a two-axis tracking PV system, Solar Energy,
83:11(2074–2085),
2009.<a href="https://oa.upm.es/1843/1/PERPINAN_ART2009_01.pdf">https://oa.upm.es/1843/1/PERPINAN_ART2009_01.pdf</a>
</p>

<hr>
<h2 id='E_pumpCoef'>Coefficients of centrifugal pumps.</h2><span id='topic+pumpCoef'></span>

<h3>Description</h3>

<p>Coefficients of centrifugal pumps</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(pumpCoef)</code></pre>


<h3>Format</h3>

<p>A <code>data.table</code> with 13 columns:
</p>

<dl>
<dt>Qn</dt><dd><p>rated flux</p>
</dd>
<dt>stages</dt><dd><p>number of stages</p>
</dd>
<dt>Qmax</dt><dd><p>maximum flux</p>
</dd>
<dt>Pmn</dt><dd><p>rated motor power</p>
</dd>
<dt>a, b, c</dt><dd><p>Coefficients of the equation <code class="reqn">H=a \cdot f^2+b \cdot f \cdot Q+c \cdot Q^2</code>.</p>
</dd>
<dt>g, h, i</dt><dd><p>Coefficients of the efficiency curve of the motor (50 Hz): <code class="reqn">\eta_{m}=g \cdot (\%P_{mn})^2+h \cdot (\%P{mn})+i</code>.</p>
</dd>
<dt>j, k, l</dt><dd><p>Coefficients of the efficiency curve of the pump (50 Hz): <code class="reqn">\eta_{b}=j \cdot Q^2+k \cdot Q+l</code>.</p>
</dd>
</dl>



<h3>Details</h3>

<p>With this version only pumps from the manufacturer Grundfos are included.</p>


<h3>Source</h3>

<p>https://product-selection.grundfos.com/</p>


<h3>References</h3>


<ul>
<li><p> Perpiñán, O, Energía Solar Fotovoltaica, 2015.
(<a href="https://oscarperpinan.github.io/esf/">https://oscarperpinan.github.io/esf/</a>)
</p>
</li>
<li><p> Perpiñán, O. (2012), &quot;solaR: Solar Radiation and Photovoltaic
Systems with R&quot;, Journal of Statistical Software, 50(9), 1-32,
<a href="https://doi.org/10.18637/jss.v050.i09">doi:10.18637/jss.v050.i09</a>
</p>
</li></ul>

<hr>
<h2 id='E_SIAR'>Data on the stations that make up the SIAR network</h2><span id='topic+est_SIAR'></span>

<h3>Description</h3>

<p>Information about the location and operational status of
the stations that make up the SIAR network</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(SIAR)</code></pre>


<h3>Format</h3>

<p><code>est_SIAR</code> is a <code>data.table</code> with 625 estations containing the following information:
</p>

<dl>
<dt><code>Estacion</code></dt><dd><p>character, name of the station.</p>
</dd>
<dt><code>Codigo</code></dt><dd><p>character, code of the station.</p>
</dd>
<dt><code>Longitud</code></dt><dd><p>numeric, longitude of the station in degrees
(negative is for locations in the west).</p>
</dd>
<dt><code>Latitud</code></dt><dd><p>numeric, latitud of the station in degrees.</p>
</dd>
<dt><code>Altitud</code></dt><dd><p>integer, altitude of the station in meters.</p>
</dd>
<dt><code>Fecha_Instalacion</code></dt><dd><p>Date, day the station was installed,
and therefore, the start of its records.</p>
</dd>
<dt><code>Fecha_Baja</code></dt><dd><p>Date, day the station was decommisioned,
and therefore, the end of its records (if its value is <code>NA</code>,
it means it is still operational).</p>
</dd>
</dl>



<h3>Source</h3>

<p>https://servicio.mapa.gob.es/websiar/</p>

<hr>
<h2 id='E_solaR.theme'>solaR theme</h2><span id='topic+solaR.theme'></span>

<h3>Description</h3>

<p>A customized theme for lattice. It is based on the <code>custom.theme.2</code>
function of the <code>latticeExtra</code> package with the next values:
</p>

<ul>
<li><p><code>pch = 19</code>
</p>
</li>
<li><p><code>cex = 0.7</code>
</p>
</li>
<li><p><code>region = rev(brewer.pal(9, 'YlOrRd'))</code>
</p>
</li>
<li><p><code>strip.background$col = 'lightgray'</code>
</p>
</li>
<li><p><code>strip.shingle$col = 'transparent'</code></p>
</li></ul>


</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
