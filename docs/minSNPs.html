<!DOCTYPE html><html lang="en"><head><title>Help for package minSNPs</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {minSNPs}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#binomial_naive_bayes'><p><code>binomial_naive_bayes</code></p></a></li>
<li><a href='#branch_and_search'><p><code>branch_and_search</code></p></a></li>
<li><a href='#cal_fn'><p><code>cal_fn</code></p></a></li>
<li><a href='#cal_fp'><p><code>cal_fp</code></p></a></li>
<li><a href='#cal_met_snp'><p><code>cal_met_snp</code></p></a></li>
<li><a href='#calculate_mcc'><p><code>calculate_mcc</code></p></a></li>
<li><a href='#calculate_mcc_multi'><p><code>calculate_mcc_multi</code></p></a></li>
<li><a href='#calculate_percent'><p><code>calculate_percent</code></p></a></li>
<li><a href='#calculate_simpson'><p><code>calculate_simpson</code></p></a></li>
<li><a href='#calculate_simpson_by_group'><p><code>calculate_simpson_by_group</code></p></a></li>
<li><a href='#calculate_state'><p><code>calculate_state</code></p></a></li>
<li><a href='#calculate_variant_within_group'><p><code>identify_group_variant_breakdown</code></p></a></li>
<li><a href='#check_fasta_meta_mapping'><p><code>check_fasta_meta_mapping</code></p></a></li>
<li><a href='#check_meta_target'><p><code>check_meta_target</code></p></a></li>
<li><a href='#check_multistate'><p><code>check_multistate</code></p></a></li>
<li><a href='#check_percent'><p><code>check_percent</code></p></a></li>
<li><a href='#coef.binomial_naive_bayes'><p><code>coef.binomial_naive_bayes</code></p></a></li>
<li><a href='#combine_fastq_search_result'><p><code>combine_fastq_search_result</code></p></a></li>
<li><a href='#combine_search_string_result'><p><code>combine_search_string_result</code></p></a></li>
<li><a href='#combine_search_string_result_from_files'><p><code>combine_search_string_result_from_files</code></p></a></li>
<li><a href='#combine_search_string_result_from_list'><p><code>combine_search_string_result_from_list</code></p></a></li>
<li><a href='#estimate_coverage'><p><code>estimate_coverage</code></p></a></li>
<li><a href='#extend_length'><p><code>extend_length</code></p></a></li>
<li><a href='#find_optimised_snps'><p><code>find_optimised_snps</code></p></a></li>
<li><a href='#flag_allele'><p><code>flag_allele</code></p></a></li>
<li><a href='#flag_position'><p><code>flag_position</code></p></a></li>
<li><a href='#full_merge'><p><code>full_merge</code></p></a></li>
<li><a href='#full_merge_1'><p><code>full_merge_1</code></p></a></li>
<li><a href='#generate_kmer_search_string'><p><code>generate_kmer_search_string</code></p></a></li>
<li><a href='#generate_kmers'><p><code>generate_kmers</code></p></a></li>
<li><a href='#generate_pattern'><p><code>generate_pattern</code></p></a></li>
<li><a href='#generate_prioritisation'><p><code>generate_prioritisation</code></p></a></li>
<li><a href='#generate_snp_search_string'><p><code>generate_snp_search_string</code></p></a></li>
<li><a href='#get_all_process_methods'><p><code>get_all_process_methods</code></p></a></li>
<li><a href='#get_binomial_tables'><p><code>get_binomial_tables</code></p></a></li>
<li><a href='#get_metric_fun'><p><code>get_metric_fun</code></p></a></li>
<li><a href='#get_positions_to_search'><p><code>get_positions_to_search</code></p></a></li>
<li><a href='#get_snps_set'><p><code>get_snps_set</code></p></a></li>
<li><a href='#get_usual_length'><p><code>get_usual_length</code></p></a></li>
<li><a href='#identify_overlaps'><p><code>identify_overlaps</code></p></a></li>
<li><a href='#infer_from_combined'><p><code>infer_from_combined</code></p></a></li>
<li><a href='#iterate_merge'><p><code>iterate_merge</code></p></a></li>
<li><a href='#iterate_through'><p><code>iterate_through</code></p></a></li>
<li><a href='#map_profile_to_target'><p><code>map_profile_to_target</code></p></a></li>
<li><a href='#match_count'><p><code>match_count</code></p></a></li>
<li><a href='#mcc_calculation'><p><code>mcc_calculation</code></p></a></li>
<li><a href='#merge_fasta'><p><code>merge_fasta</code></p></a></li>
<li><a href='#output_parsed'><p><code>output_parsed</code></p></a></li>
<li><a href='#output_result'><p><code>output_result</code></p></a></li>
<li><a href='#output_to_files'><p><code>output_to_files</code></p></a></li>
<li><a href='#parse_group_mcc'><p><code>parse_group_mcc</code></p></a></li>
<li><a href='#parse_group_mcc_multi'><p><code>parse_group_mcc_multi</code></p></a></li>
<li><a href='#predict_balk'><p><code>predict_balk</code></p></a></li>
<li><a href='#predict.binomial_naive_bayes'><p><code>predict.binomial_naive_bayes</code></p></a></li>
<li><a href='#print.binomial_naive_bayes'><p><code>print.binomial_naive_bayes</code></p></a></li>
<li><a href='#process_allele'><p><code>process_allele</code></p></a></li>
<li><a href='#process_kmer_result'><p><code>process_kmer_result</code></p></a></li>
<li><a href='#process_result_file'><p><code>process_result_file</code></p></a></li>
<li><a href='#process_snp_result'><p><code>process_snp_result</code></p></a></li>
<li><a href='#profile_to_group_result'><p><code>profile_to_group_result</code></p></a></li>
<li><a href='#read_fasta'><p><code>read_fasta</code></p></a></li>
<li><a href='#read_sequences_from_fastq'><p><code>read_sequences_from_fastq</code></p></a></li>
<li><a href='#remove_dup_isolate'><p><code>remove_dup_isolate</code></p></a></li>
<li><a href='#remove_snp_conflict'><p><code>remove_snp_conflic</code></p></a></li>
<li><a href='#resolve_IUPAC_missing'><p><code>resolve_IUPAC_missing</code></p></a></li>
<li><a href='#reverse_complement'><p><code>reverse_complement</code></p></a></li>
<li><a href='#scramble_sequence'><p><code>scramble_sequence</code></p></a></li>
<li><a href='#search_from_fastq_reads'><p><code>search_from_fastq_reads</code></p></a></li>
<li><a href='#search_from_reads'><p><code>search_from_reads</code></p></a></li>
<li><a href='#select_n_set_i_depth'><p><code>select_n_set_i_depth</code></p></a></li>
<li><a href='#sequence_reads_match_count'><p><code>sequence_reads_match_count</code></p></a></li>
<li><a href='#summarise_result'><p><code>summarise_result</code></p></a></li>
<li><a href='#summary.binomial_naive_bayes'><p><code>summary.binomial_naive_bayes</code></p></a></li>
<li><a href='#train_balk'><p><code>train_balk</code></p></a></li>
<li><a href='#transform_snp'><p><code>transform_snp</code></p></a></li>
<li><a href='#translate_position'><p><code>translate_position</code></p></a></li>
<li><a href='#view_mcc'><p><code>view_mcc</code></p></a></li>
<li><a href='#view_mcc_multi'><p><code>view_mcc_multi</code></p></a></li>
<li><a href='#view_percent'><p><code>view_percent</code></p></a></li>
<li><a href='#view_simpson'><p><code>view_simpson</code></p></a></li>
<li><a href='#write_fasta'><p><code>write_fasta</code></p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Title:</td>
<td>Resolution-Optimised SNPs Searcher</td>
</tr>
<tr>
<td>Version:</td>
<td>0.2.0</td>
</tr>
<tr>
<td>Description:</td>
<td>This is a R implementation of "Minimum SNPs" software as described in "Price E.P., Inman-Bamber, J., Thiruvenkataswamy, V., Huygens, F and Giffard, P.M." (2007) &lt;<a href="https://doi.org/10.1186%2F1471-2105-8-278">doi:10.1186/1471-2105-8-278</a>&gt; "Computer-aided identification of polymorphism sets diagnostic for groups of bacterial and viral genetic variants."</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.4.0)</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://opensource.org/licenses/mit-license.php">MIT</a> + file LICENSE</td>
</tr>
<tr>
<td>Imports:</td>
<td>BiocParallel, data.table</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>Suggests:</td>
<td>knitr, testthat, pkgdown, rmarkdown, withr</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/ludwigHoon/minSNPs">https://github.com/ludwigHoon/minSNPs</a></td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-03-05 13:05:50 UTC; ldwg</td>
</tr>
<tr>
<td>Author:</td>
<td>Ludwig Kian Soon Hoon
    <a href="https://orcid.org/0000-0002-2310-3403"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [aut, cre],
  Peter Shaw <a href="https://orcid.org/0000-0002-3187-8938"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [aut,
    ctb],
  Phil Giffard <a href="https://orcid.org/0000-0002-3030-9127"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, ctb]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Ludwig Kian Soon Hoon &lt;ldwgkshoon@gmail.com&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-03-05 14:30:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='binomial_naive_bayes'><code>binomial_naive_bayes</code></h2><span id='topic+binomial_naive_bayes'></span>

<h3>Description</h3>

<p><code>binomial_naive_bayes</code> is an implementation of the binomial naive bayes algorithm.
modified from bernoulli_naive_bayes function in the naivebayes package
</p>


<h3>Usage</h3>

<pre><code class='language-R'>binomial_naive_bayes(x, y, prior = NULL, laplace = 1, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="binomial_naive_bayes_+3A_x">x</code></td>
<td>
<p>a matrix with numeric: 0,1, up to binomial_n columns</p>
</td></tr>
<tr><td><code id="binomial_naive_bayes_+3A_y">y</code></td>
<td>
<p>a factor or character or logical vector</p>
</td></tr>
<tr><td><code id="binomial_naive_bayes_+3A_prior">prior</code></td>
<td>
<p>a vector of prior probabilities</p>
</td></tr>
<tr><td><code id="binomial_naive_bayes_+3A_laplace">laplace</code></td>
<td>
<p>a numeric value for Laplace smoothing</p>
</td></tr>
<tr><td><code id="binomial_naive_bayes_+3A_...">...</code></td>
<td>
<p>additional arguments</p>
</td></tr>
</table>


<h3>Value</h3>

<p>return a binomial_naive_bayes object
</p>

<hr>
<h2 id='branch_and_search'><code>branch_and_search</code></h2><span id='topic+branch_and_search'></span>

<h3>Description</h3>

<p><code>branch_and_search</code> is the actual function used to
find optimised SNPs set. This function is called by
<code>find_optimised_snps</code>, after preprocessing.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>branch_and_search(
  starting_positions = c(),
  excluded_positions = c(),
  seqc,
  metric,
  number_of_result = 1,
  max_depth = 1,
  bp = SerialParam(),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="branch_and_search_+3A_starting_positions">starting_positions</code></td>
<td>
<p>the starting positions that is already in
the SNP set.</p>
</td></tr>
<tr><td><code id="branch_and_search_+3A_excluded_positions">excluded_positions</code></td>
<td>
<p>excluded positions</p>
</td></tr>
<tr><td><code id="branch_and_search_+3A_seqc">seqc</code></td>
<td>
<p>list of sequences, either passed directly from
<code>process_allele</code> or <code>read_fasta</code> or equivalence</p>
</td></tr>
<tr><td><code id="branch_and_search_+3A_metric">metric</code></td>
<td>
<p>either 'simpson' or 'percent'</p>
</td></tr>
<tr><td><code id="branch_and_search_+3A_number_of_result">number_of_result</code></td>
<td>
<p>number of results to return, 0 will be coerced to 1</p>
</td></tr>
<tr><td><code id="branch_and_search_+3A_max_depth">max_depth</code></td>
<td>
<p>maximum depth to go before terminating,
0 means it will only calculate the metric for included position</p>
</td></tr>
<tr><td><code id="branch_and_search_+3A_bp">bp</code></td>
<td>
<p>BiocParallel backend.
Rule of thumbs: use MulticoreParam(workers = ncpus - 2)</p>
</td></tr>
<tr><td><code id="branch_and_search_+3A_...">...</code></td>
<td>
<p>other parameters as needed</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Will return the resolution-optimised SNPs set, based on the metric.
</p>

<hr>
<h2 id='cal_fn'><code>cal_fn</code></h2><span id='topic+cal_fn'></span>

<h3>Description</h3>

<p><code>cal_fn</code> is used to check if the proportion of false negative
fastas and metas are compatible.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cal_fn(pattern, goi, target)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="cal_fn_+3A_pattern">pattern</code></td>
<td>
<p>the pattern from <code>generate_pattern</code></p>
</td></tr>
<tr><td><code id="cal_fn_+3A_goi">goi</code></td>
<td>
<p>the group of interest (names of isolates)</p>
</td></tr>
<tr><td><code id="cal_fn_+3A_target">target</code></td>
<td>
<p>the target sequence(s)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>proportion: no. false negative/number of isolates
</p>

<hr>
<h2 id='cal_fp'><code>cal_fp</code></h2><span id='topic+cal_fp'></span>

<h3>Description</h3>

<p><code>cal_fp</code> is used to check if the proportion of false positive
fastas and metas are compatible.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cal_fp(pattern, goi, target)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="cal_fp_+3A_pattern">pattern</code></td>
<td>
<p>the pattern from <code>generate_pattern</code></p>
</td></tr>
<tr><td><code id="cal_fp_+3A_goi">goi</code></td>
<td>
<p>the group of interest (names of isolates)</p>
</td></tr>
<tr><td><code id="cal_fp_+3A_target">target</code></td>
<td>
<p>the target sequence(s)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>proportion: no. false positive/number of isolates
</p>

<hr>
<h2 id='cal_met_snp'><code>cal_met_snp</code></h2><span id='topic+cal_met_snp'></span>

<h3>Description</h3>

<p><code>cal_met_snp</code> is used to calculate the metric at each position
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cal_met_snp(position, metric, seqc, prepend_position = c(), ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="cal_met_snp_+3A_position">position</code></td>
<td>
<p>position to check</p>
</td></tr>
<tr><td><code id="cal_met_snp_+3A_metric">metric</code></td>
<td>
<p>either 'simpson' or 'percent'</p>
</td></tr>
<tr><td><code id="cal_met_snp_+3A_seqc">seqc</code></td>
<td>
<p>list of sequences, either passed directly from
<code>process_allele</code> or <code>read_fasta</code> or equivalence</p>
</td></tr>
<tr><td><code id="cal_met_snp_+3A_prepend_position">prepend_position</code></td>
<td>
<p>is the position to be added to the</p>
</td></tr>
<tr><td><code id="cal_met_snp_+3A_...">...</code></td>
<td>
<p>other parameters as needed</p>
</td></tr>
</table>


<h3>Value</h3>

<p>return the value at that position,
as well as base pattern for next iteration.
</p>

<hr>
<h2 id='calculate_mcc'><code>calculate_mcc</code></h2><span id='topic+calculate_mcc'></span>

<h3>Description</h3>

<p><code>calculate_mcc</code> is used to calculate the MCC score given the SNP profile.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>calculate_mcc(pattern, goi, MUST_HAVE_TARGET = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="calculate_mcc_+3A_pattern">pattern</code></td>
<td>
<p>the SNP profile for each samples</p>
</td></tr>
<tr><td><code id="calculate_mcc_+3A_goi">goi</code></td>
<td>
<p>the samples belonging to the group of interest</p>
</td></tr>
<tr><td><code id="calculate_mcc_+3A_must_have_target">MUST_HAVE_TARGET</code></td>
<td>
<p>whether to force the profile to have at least 1 target profile
(the profile containing the most goi)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the MCC score
</p>

<hr>
<h2 id='calculate_mcc_multi'><code>calculate_mcc_multi</code></h2><span id='topic+calculate_mcc_multi'></span>

<h3>Description</h3>

<p><code>calculate_mcc_multi</code> Calculate the multi-class MCC score for the SNPs.
It assigns each SNP profile to a class, based on the majority of the samples having the profile,
targets with the less samples are prioritised first, breaking ties by alphabetical order.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>calculate_mcc_multi(pattern, meta, target = "target", priority = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="calculate_mcc_multi_+3A_pattern">pattern</code></td>
<td>
<p>the SNP profile for each samples</p>
</td></tr>
<tr><td><code id="calculate_mcc_multi_+3A_meta">meta</code></td>
<td>
<p>A data.table containing the meta data</p>
</td></tr>
<tr><td><code id="calculate_mcc_multi_+3A_target">target</code></td>
<td>
<p>the column name of the target in the meta data, default to target</p>
</td></tr>
<tr><td><code id="calculate_mcc_multi_+3A_priority">priority</code></td>
<td>
<p>A data.table of the targets and priority,
either supplied by user, or by default generated by <code>generate_prioritisation</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>multiclass-MCC score
</p>

<hr>
<h2 id='calculate_percent'><code>calculate_percent</code></h2><span id='topic+calculate_percent'></span>

<h3>Description</h3>

<p><code>calculate_percent</code> is used to calculate dissimilarity index,
proportion of isolates not in goi that have been discriminated against.
1 being all and 0 being none.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>calculate_percent(pattern, goi)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="calculate_percent_+3A_pattern">pattern</code></td>
<td>
<p>list of sequences' pattern (profile)</p>
</td></tr>
<tr><td><code id="calculate_percent_+3A_goi">goi</code></td>
<td>
<p>group of interest</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Will return the dissimilarity index of the list of patterns.
</p>

<hr>
<h2 id='calculate_simpson'><code>calculate_simpson</code></h2><span id='topic+calculate_simpson'></span>

<h3>Description</h3>

<p><code>calculate_simpson</code> is used to calculate Simpson's index.
Which is in the range of 0-1, where the greater the value,
the more diverse the population.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>calculate_simpson(pattern)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="calculate_simpson_+3A_pattern">pattern</code></td>
<td>
<p>list of sequences' pattern (profile)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Will return the Simpson's index of the list of patterns.
</p>

<hr>
<h2 id='calculate_simpson_by_group'><code>calculate_simpson_by_group</code></h2><span id='topic+calculate_simpson_by_group'></span>

<h3>Description</h3>

<p><code>calculate_simpson_by_group</code> is used to calculate Simpson's index.
Which is in the range of 0-1, where the greater the value,
the more diverse the population.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>calculate_simpson_by_group(pattern, meta, target)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="calculate_simpson_by_group_+3A_pattern">pattern</code></td>
<td>
<p>list of sequences' pattern (profile)</p>
</td></tr>
<tr><td><code id="calculate_simpson_by_group_+3A_meta">meta</code></td>
<td>
<p>the metadata</p>
</td></tr>
<tr><td><code id="calculate_simpson_by_group_+3A_target">target</code></td>
<td>
<p>the target column name</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Will return the Simpson's index of the list of patterns.
</p>

<hr>
<h2 id='calculate_state'><code>calculate_state</code></h2><span id='topic+calculate_state'></span>

<h3>Description</h3>

<p><code>calculate_state</code> calculate the number of states given the SNP(s)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>calculate_state(pattern)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="calculate_state_+3A_pattern">pattern</code></td>
<td>
<p>list of sequences' pattern (profile)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>number of states
</p>

<hr>
<h2 id='calculate_variant_within_group'><code>identify_group_variant_breakdown</code></h2><span id='topic+calculate_variant_within_group'></span>

<h3>Description</h3>

<p><code>calculate_variant_within_group</code> is used to identify proportion of different samples
having the same profile.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>calculate_variant_within_group(pattern, meta, target, get_count = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="calculate_variant_within_group_+3A_pattern">pattern</code></td>
<td>
<p>list of sequences' pattern (profile)</p>
</td></tr>
<tr><td><code id="calculate_variant_within_group_+3A_meta">meta</code></td>
<td>
<p>metadata of the sequences</p>
</td></tr>
<tr><td><code id="calculate_variant_within_group_+3A_target">target</code></td>
<td>
<p>column name of the target group</p>
</td></tr>
<tr><td><code id="calculate_variant_within_group_+3A_get_count">get_count</code></td>
<td>
<p>whether to return the count of samples rather than the raw number, default to FALSE.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Will return the Simpson's index of the list of patterns.
</p>

<hr>
<h2 id='check_fasta_meta_mapping'><code>check_fasta_meta_mapping</code></h2><span id='topic+check_fasta_meta_mapping'></span>

<h3>Description</h3>

<p><code>check_fasta_meta_mapping</code> is used to check if
fastas and metas are compatible.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>check_fasta_meta_mapping(fasta, meta)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="check_fasta_meta_mapping_+3A_fasta">fasta</code></td>
<td>
<p>the fasta read into memory to join</p>
</td></tr>
<tr><td><code id="check_fasta_meta_mapping_+3A_meta">meta</code></td>
<td>
<p>the meta read into memory to join</p>
</td></tr>
</table>


<h3>Value</h3>

<p>TRUE/FALSE if the fasta and meta are compatible
</p>

<hr>
<h2 id='check_meta_target'><code>check_meta_target</code></h2><span id='topic+check_meta_target'></span>

<h3>Description</h3>

<p><code>check_meta_target</code> is used to check if parameters needed by
<code>calculate_mcc_multi</code> and <code>simpson_by_group</code> are all present.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>check_meta_target(list_of_parameters)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="check_meta_target_+3A_list_of_parameters">list_of_parameters</code></td>
<td>
<p>is a list of parameter passed
to functions that will perform the calculation</p>
</td></tr>
</table>


<h3>Value</h3>

<p>TRUE if the parameters exists, else FALSE
</p>

<hr>
<h2 id='check_multistate'><code>check_multistate</code></h2><span id='topic+check_multistate'></span>

<h3>Description</h3>

<p><code>check_multistate</code> is used to remove positions where there are
more than 1 state within the group of interest.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>check_multistate(position, sequences)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="check_multistate_+3A_position">position</code></td>
<td>
<p>position to check</p>
</td></tr>
<tr><td><code id="check_multistate_+3A_sequences">sequences</code></td>
<td>
<p>sequences from group of interest</p>
</td></tr>
</table>


<h3>Value</h3>

<p>return 'TRUE' if the position contains multistate otherwise 'FALSE'
</p>

<hr>
<h2 id='check_percent'><code>check_percent</code></h2><span id='topic+check_percent'></span>

<h3>Description</h3>

<p><code>check_percent</code> is used to check if parameters needed by
<code>calculate_percent</code> are all present.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>check_percent(list_of_parameters)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="check_percent_+3A_list_of_parameters">list_of_parameters</code></td>
<td>
<p>is a list of parameter passed
to functions that will perform the calculation</p>
</td></tr>
</table>


<h3>Value</h3>

<p>TRUE if goi exists, else FALSE
</p>

<hr>
<h2 id='coef.binomial_naive_bayes'><code>coef.binomial_naive_bayes</code></h2><span id='topic+coef.binomial_naive_bayes'></span>

<h3>Description</h3>

<p><code>coef.binomial_naive_bayes</code> is an implementation of the coef method for the binomial naive bayes algorithm.
modified from bernoulli_naive_bayes function in the naivebayes package
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'binomial_naive_bayes'
coef(object, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="coef.binomial_naive_bayes_+3A_object">object</code></td>
<td>
<p>a binomial_naive_bayes object</p>
</td></tr>
<tr><td><code id="coef.binomial_naive_bayes_+3A_...">...</code></td>
<td>
<p>additional arguments</p>
</td></tr>
</table>


<h3>Value</h3>

<p>return a data frame of coefficients
</p>

<hr>
<h2 id='combine_fastq_search_result'><code>combine_fastq_search_result</code></h2><span id='topic+combine_fastq_search_result'></span>

<h3>Description</h3>

<p><code>combine_fastq_search_result</code> combines the search results from <code>search_from_fastq_reads</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>combine_fastq_search_result(
  results,
  search_table,
  previous_result = NULL,
  bp = MulticoreParam()
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="combine_fastq_search_result_+3A_results">results</code></td>
<td>
<p>the result (fastq_search_result) from <code>search_from_fastq_reads</code> to combine.</p>
</td></tr>
<tr><td><code id="combine_fastq_search_result_+3A_search_table">search_table</code></td>
<td>
<p>a dataframe with the following columns:
- &quot;id&quot;,&quot;type&quot;,&quot;sequence&quot;,&quot;strand&quot;,&quot;result&quot;,&quot;extra&quot;,&quot;match_ref_seq&quot;</p>
</td></tr>
<tr><td><code id="combine_fastq_search_result_+3A_previous_result">previous_result</code></td>
<td>
<p>the result (fastq_search_result) to append to</p>
</td></tr>
<tr><td><code id="combine_fastq_search_result_+3A_bp">bp</code></td>
<td>
<p>BiocParallel backend to use for parallelization</p>
</td></tr>
</table>


<h3>Value</h3>

<p>will return a dataframe containing: -
'sequence', 'search_id', 'reads', 'raw_match', 'mean_qualities', 'indexes', 'id', 'type',
'strand', 'result', 'extra', 'match_ref_seq', 'n_reads'
</p>

<hr>
<h2 id='combine_search_string_result'><code>combine_search_string_result</code></h2><span id='topic+combine_search_string_result'></span>

<h3>Description</h3>

<p><code>combine_search_string_result</code> combines the search results from <code>search_from_fastq_reads</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>combine_search_string_result(
  results,
  search_table,
  append_to_current_result = data.frame(),
  bp = MulticoreParam()
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="combine_search_string_result_+3A_results">results</code></td>
<td>
<p>the dataframes to collapse.</p>
</td></tr>
<tr><td><code id="combine_search_string_result_+3A_search_table">search_table</code></td>
<td>
<p>a dataframe with the following columns:
- &quot;id&quot;,&quot;type&quot;,&quot;sequence&quot;,&quot;strand&quot;,&quot;result&quot;,&quot;extra&quot;,&quot;match_ref_seq&quot;</p>
</td></tr>
<tr><td><code id="combine_search_string_result_+3A_append_to_current_result">append_to_current_result</code></td>
<td>
<p>the dataframe of previous result to append to</p>
</td></tr>
<tr><td><code id="combine_search_string_result_+3A_bp">bp</code></td>
<td>
<p>BiocParallel backend to use for parallelization</p>
</td></tr>
</table>


<h3>Value</h3>

<p>will return a dataframe containing: -
'sequence', 'search_id', 'reads', 'raw_match', 'mean_qualities', 'indexes', 'id', 'type',
'strand', 'result', 'extra', 'match_ref_seq', 'n_reads'
</p>

<hr>
<h2 id='combine_search_string_result_from_files'><code>combine_search_string_result_from_files</code></h2><span id='topic+combine_search_string_result_from_files'></span>

<h3>Description</h3>

<p><code>combine_search_string_result_from_files</code>
<code>combine_search_string_result</code> combines the search results from temp file generated from <code>search_from_fastq_reads</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>combine_search_string_result_from_files(
  result_files,
  search_table,
  read_length_files = c(),
  append_to_current_result = NULL,
  bp = MulticoreParam()
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="combine_search_string_result_from_files_+3A_result_files">result_files</code></td>
<td>
<p>the output files from <code>search_from_fastq_reads</code> to combine</p>
</td></tr>
<tr><td><code id="combine_search_string_result_from_files_+3A_search_table">search_table</code></td>
<td>
<p>a dataframe with the following columns:
- &quot;id&quot;,&quot;type&quot;,&quot;sequence&quot;,&quot;strand&quot;,&quot;result&quot;,&quot;extra&quot;,&quot;match_ref_seq&quot;</p>
</td></tr>
<tr><td><code id="combine_search_string_result_from_files_+3A_read_length_files">read_length_files</code></td>
<td>
<p>the read_length output files from <code>search_from_fastq_reads</code></p>
</td></tr>
<tr><td><code id="combine_search_string_result_from_files_+3A_append_to_current_result">append_to_current_result</code></td>
<td>
<p>the fastq_search_result of result to append to</p>
</td></tr>
<tr><td><code id="combine_search_string_result_from_files_+3A_bp">bp</code></td>
<td>
<p>BiocParallel backend to use for parallelization</p>
</td></tr>
</table>


<h3>Value</h3>

<p>will return a fastq_search_result object containing read_lengths and a dataframe containing: -
'sequence', 'search_id', 'reads', 'raw_match', 'mean_qualities', 'indexes', 'id', 'type',
'strand', 'result', 'extra', 'match_ref_seq', 'n_reads'
</p>

<hr>
<h2 id='combine_search_string_result_from_list'><code>combine_search_string_result_from_list</code></h2><span id='topic+combine_search_string_result_from_list'></span>

<h3>Description</h3>

<p><code>combine_search_string_result_from_list</code> combines the search results from <code>search_from_fastq_reads</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>combine_search_string_result_from_list(
  results,
  search_table,
  append_to_current_result = data.frame(),
  bp = MulticoreParam()
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="combine_search_string_result_from_list_+3A_results">results</code></td>
<td>
<p>the dataframes from <code>search_from_fastq_reads</code> to combine.</p>
</td></tr>
<tr><td><code id="combine_search_string_result_from_list_+3A_search_table">search_table</code></td>
<td>
<p>a dataframe with the following columns:
- &quot;id&quot;,&quot;type&quot;,&quot;sequence&quot;,&quot;strand&quot;,&quot;result&quot;,&quot;extra&quot;,&quot;match_ref_seq&quot;</p>
</td></tr>
<tr><td><code id="combine_search_string_result_from_list_+3A_append_to_current_result">append_to_current_result</code></td>
<td>
<p>the dataframe of previous result to append to</p>
</td></tr>
<tr><td><code id="combine_search_string_result_from_list_+3A_bp">bp</code></td>
<td>
<p>BiocParallel backend to use for parallelization</p>
</td></tr>
</table>


<h3>Value</h3>

<p>will return a dataframe containing: -
'sequence', 'search_id', 'reads', 'raw_match', 'mean_qualities', 'indexes', 'id', 'type',
'strand', 'result', 'extra', 'match_ref_seq', 'n_reads'
</p>

<hr>
<h2 id='estimate_coverage'><code>estimate_coverage</code></h2><span id='topic+estimate_coverage'></span>

<h3>Description</h3>

<p><code>estimate_coverage</code>
<code>estimate_coverage</code> estimate the average coverage by comparing number of bases from reads to genome size
</p>


<h3>Usage</h3>

<pre><code class='language-R'>estimate_coverage(read_lengths, genome_size)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="estimate_coverage_+3A_read_lengths">read_lengths</code></td>
<td>
<p>the lengths of the reads</p>
</td></tr>
<tr><td><code id="estimate_coverage_+3A_genome_size">genome_size</code></td>
<td>
<p>the genome size</p>
</td></tr>
</table>


<h3>Value</h3>

<p>will return an estimated average coverage
</p>

<hr>
<h2 id='extend_length'><code>extend_length</code></h2><span id='topic+extend_length'></span>

<h3>Description</h3>

<p><code>extend_length</code> extend the search sequence such that
there will always be (prev) bases before the SNPs and
(after) bases after the SNPs.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>extend_length(
  overlaps,
  position_reference,
  genome_position,
  prev,
  after,
  ori_string_start,
  ori_string_end,
  ori_snp_pos,
  genome_max
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="extend_length_+3A_overlaps">overlaps</code></td>
<td>
<p>Overlappings</p>
</td></tr>
<tr><td><code id="extend_length_+3A_position_reference">position_reference</code></td>
<td>
<p>the mapping of position
in SNP matrix to reference genome</p>
</td></tr>
<tr><td><code id="extend_length_+3A_genome_position">genome_position</code></td>
<td>
<p>the position of the SNP in the reference genome</p>
</td></tr>
<tr><td><code id="extend_length_+3A_prev">prev</code></td>
<td>
<p>number of bases before the SNP included in the search string</p>
</td></tr>
<tr><td><code id="extend_length_+3A_after">after</code></td>
<td>
<p>number of bases after the SNP included in the search string</p>
</td></tr>
<tr><td><code id="extend_length_+3A_ori_string_start">ori_string_start</code></td>
<td>
<p>original starting point of search string</p>
</td></tr>
<tr><td><code id="extend_length_+3A_ori_string_end">ori_string_end</code></td>
<td>
<p>original ending point of the search string</p>
</td></tr>
<tr><td><code id="extend_length_+3A_ori_snp_pos">ori_snp_pos</code></td>
<td>
<p>original SNP position in search string</p>
</td></tr>
<tr><td><code id="extend_length_+3A_genome_max">genome_max</code></td>
<td>
<p>length of the reference genome</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list containing the new 'string_start',
'string_end', 'snp_pos', 'snps_in_string'.
</p>

<hr>
<h2 id='find_optimised_snps'><code>find_optimised_snps</code></h2><span id='topic+find_optimised_snps'></span>

<h3>Description</h3>

<p><code>find_optimised_snps</code> is used to find optimised SNPs set.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>find_optimised_snps(
  seqc,
  metric = "simpson",
  goi = c(),
  accept_multiallelic = TRUE,
  number_of_result = 1,
  max_depth = 1,
  included_positions = c(),
  excluded_positions = c(),
  search_from = NULL,
  iterate_included = FALSE,
  completely_unique = FALSE,
  bp = SerialParam(),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="find_optimised_snps_+3A_seqc">seqc</code></td>
<td>
<p>list of sequences, either passed directly from
<code>process_allele</code> or <code>read_fasta</code> or equivalence</p>
</td></tr>
<tr><td><code id="find_optimised_snps_+3A_metric">metric</code></td>
<td>
<p>either 'simpson' or 'percent'</p>
</td></tr>
<tr><td><code id="find_optimised_snps_+3A_goi">goi</code></td>
<td>
<p>group of interest, if creteria is percent,
must be specified, ignored otherwise</p>
</td></tr>
<tr><td><code id="find_optimised_snps_+3A_accept_multiallelic">accept_multiallelic</code></td>
<td>
<p>whether include positions with &gt; 1 state in goi</p>
</td></tr>
<tr><td><code id="find_optimised_snps_+3A_number_of_result">number_of_result</code></td>
<td>
<p>number of results to return, 0 will be coerced to 1</p>
</td></tr>
<tr><td><code id="find_optimised_snps_+3A_max_depth">max_depth</code></td>
<td>
<p>maximum depth to go before terminating,
0 means it will only calculate the metric for included position</p>
</td></tr>
<tr><td><code id="find_optimised_snps_+3A_included_positions">included_positions</code></td>
<td>
<p>included positions</p>
</td></tr>
<tr><td><code id="find_optimised_snps_+3A_excluded_positions">excluded_positions</code></td>
<td>
<p>excluded positions</p>
</td></tr>
<tr><td><code id="find_optimised_snps_+3A_search_from">search_from</code></td>
<td>
<p>search only from these positions, i.e.,
any positions not in here are excluded, default to NULL</p>
</td></tr>
<tr><td><code id="find_optimised_snps_+3A_iterate_included">iterate_included</code></td>
<td>
<p>whether to calculate index
at each level of the included SNPs</p>
</td></tr>
<tr><td><code id="find_optimised_snps_+3A_completely_unique">completely_unique</code></td>
<td>
<p>whether to identify completely unique SNPs set,
default to FALSE, only the 1st SNP must be different</p>
</td></tr>
<tr><td><code id="find_optimised_snps_+3A_bp">bp</code></td>
<td>
<p>BiocParallel backend.
Rule of thumbs: use MulticoreParam(workers = ncpus - 2)</p>
</td></tr>
<tr><td><code id="find_optimised_snps_+3A_...">...</code></td>
<td>
<p>other parameters as needed</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Will return the resolution-optimised SNPs set, based on the metric.
</p>

<hr>
<h2 id='flag_allele'><code>flag_allele</code></h2><span id='topic+flag_allele'></span>

<h3>Description</h3>

<p><code>flag_allele</code> is used to find out a list of samples that has been
flagged with length different from most and will not be included in
computation of minimum SNPs.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>flag_allele(seqc, bp = BiocParallel::SerialParam())
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="flag_allele_+3A_seqc">seqc</code></td>
<td>
<p>a list containing list of nucleotides. To keep it simple,
use provided read_fasta to import the fasta file.</p>
</td></tr>
<tr><td><code id="flag_allele_+3A_bp">bp</code></td>
<td>
<p>is the biocparallel backend, default to serialParam,
most likely sufficient in most scenario</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Will return a list of ignored samples.
</p>

<hr>
<h2 id='flag_position'><code>flag_position</code></h2><span id='topic+flag_position'></span>

<h3>Description</h3>

<p><code>flag_position</code> is used to find out positions that will be ignored in
calculation (either not A,C,G,T or '-'), can be case sensitive
or insensitive.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>flag_position(
  pro_seqc,
  dash_ignore = TRUE,
  accepted_char = c("A", "C", "T", "G"),
  ignore_case = TRUE,
  remove_invariant = FALSE,
  biallelic_only = FALSE,
  bp = SerialParam()
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="flag_position_+3A_pro_seqc">pro_seqc</code></td>
<td>
<p>Sequences after processed, i.e. all with the same length</p>
</td></tr>
<tr><td><code id="flag_position_+3A_dash_ignore">dash_ignore</code></td>
<td>
<p>whether to treat '-' as another type</p>
</td></tr>
<tr><td><code id="flag_position_+3A_accepted_char">accepted_char</code></td>
<td>
<p>character to accept, default to c(&quot;A&quot;, &quot;C&quot;, &quot;T&quot;, &quot;G&quot;)</p>
</td></tr>
<tr><td><code id="flag_position_+3A_ignore_case">ignore_case</code></td>
<td>
<p>whether to be case insensitive, default to TRUE</p>
</td></tr>
<tr><td><code id="flag_position_+3A_remove_invariant">remove_invariant</code></td>
<td>
<p>whether to remove invariant positions, default to FALSE</p>
</td></tr>
<tr><td><code id="flag_position_+3A_biallelic_only">biallelic_only</code></td>
<td>
<p>whether to remove positions with more than 2 alleles, default to FALSE</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Will return a list of positions that need to be ignored.
</p>

<hr>
<h2 id='full_merge'><code>full_merge</code></h2><span id='topic+full_merge'></span>

<h3>Description</h3>

<p><code>full_merge</code> is used to merge 2 fasta,
where a position exist only in 1 of the fasta, the fasta without allele
in that positions are given reference genome's allele at that position.
**Doesn't work for large dataset, hence the need for <code>full_merge_1</code>**
</p>


<h3>Usage</h3>

<pre><code class='language-R'>full_merge(
  fasta_1,
  fasta_2,
  meta_1,
  meta_2,
  ref,
  bp = BiocParallel::MulticoreParam(),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="full_merge_+3A_fasta_1">fasta_1</code></td>
<td>
<p>fasta read into memory to join</p>
</td></tr>
<tr><td><code id="full_merge_+3A_fasta_2">fasta_2</code></td>
<td>
<p>fasta read into memory to join</p>
</td></tr>
<tr><td><code id="full_merge_+3A_meta_1">meta_1</code></td>
<td>
<p>meta file for 'fasta_1' denoting all positions of SNPs
and position in reference genome</p>
</td></tr>
<tr><td><code id="full_merge_+3A_meta_2">meta_2</code></td>
<td>
<p>meta file for 'fasta_2' denoting all positions of SNPs
and position in reference genome</p>
</td></tr>
<tr><td><code id="full_merge_+3A_ref">ref</code></td>
<td>
<p>name of the reference genome (needs to be in both fasta files)</p>
</td></tr>
<tr><td><code id="full_merge_+3A_bp">bp</code></td>
<td>
<p>the BiocParallel backend</p>
</td></tr>
<tr><td><code id="full_merge_+3A_...">...</code></td>
<td>
<p>all other arguments</p>
</td></tr>
</table>


<h3>Value</h3>

<p>merged fasta and meta
</p>

<hr>
<h2 id='full_merge_1'><code>full_merge_1</code></h2><span id='topic+full_merge_1'></span>

<h3>Description</h3>

<p><code>full_merge_1</code> is used to merge 2 fasta,
where a position exist only in 1 of the fasta, the fasta without allele
in that positions are given reference genome's allele at that position.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>full_merge_1(
  fasta_1,
  fasta_2,
  meta_1,
  meta_2,
  ref,
  bp = BiocParallel::SerialParam(),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="full_merge_1_+3A_fasta_1">fasta_1</code></td>
<td>
<p>fasta read into memory to join</p>
</td></tr>
<tr><td><code id="full_merge_1_+3A_fasta_2">fasta_2</code></td>
<td>
<p>fasta read into memory to join</p>
</td></tr>
<tr><td><code id="full_merge_1_+3A_meta_1">meta_1</code></td>
<td>
<p>meta file for 'fasta_1' denoting all positions of SNPs
and position in reference genome</p>
</td></tr>
<tr><td><code id="full_merge_1_+3A_meta_2">meta_2</code></td>
<td>
<p>meta file for 'fasta_2' denoting all positions of SNPs
and position in reference genome</p>
</td></tr>
<tr><td><code id="full_merge_1_+3A_ref">ref</code></td>
<td>
<p>name of the reference genome (needs to be in both fasta files)</p>
</td></tr>
<tr><td><code id="full_merge_1_+3A_bp">bp</code></td>
<td>
<p>the BiocParallel backend</p>
</td></tr>
<tr><td><code id="full_merge_1_+3A_...">...</code></td>
<td>
<p>all other arguments</p>
</td></tr>
</table>


<h3>Value</h3>

<p>merged fasta and meta
</p>

<hr>
<h2 id='generate_kmer_search_string'><code>generate_kmer_search_string</code></h2><span id='topic+generate_kmer_search_string'></span>

<h3>Description</h3>

<p><code>generate_kmer_search_string</code> generate the search strings
to detect genes' presence
</p>


<h3>Usage</h3>

<pre><code class='language-R'>generate_kmer_search_string(
  gene_seq,
  k,
  id_prefix = NULL,
  bp = MulticoreParam()
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="generate_kmer_search_string_+3A_gene_seq">gene_seq</code></td>
<td>
<p>sequences to generate k_mers from</p>
</td></tr>
<tr><td><code id="generate_kmer_search_string_+3A_k">k</code></td>
<td>
<p>kmer length</p>
</td></tr>
<tr><td><code id="generate_kmer_search_string_+3A_id_prefix">id_prefix</code></td>
<td>
<p>prefix for the gene id</p>
</td></tr>
<tr><td><code id="generate_kmer_search_string_+3A_bp">bp</code></td>
<td>
<p>BiocParallel backend to use</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a dataframe containing the search strings
</p>

<hr>
<h2 id='generate_kmers'><code>generate_kmers</code></h2><span id='topic+generate_kmers'></span>

<h3>Description</h3>

<p><code>generate_kmers</code> generate the kmer sequences of the given length
</p>


<h3>Usage</h3>

<pre><code class='language-R'>generate_kmers(final_string, k)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="generate_kmers_+3A_final_string">final_string</code></td>
<td>
<p>the string to generate kmers</p>
</td></tr>
<tr><td><code id="generate_kmers_+3A_k">k</code></td>
<td>
<p>the length of the kmer</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a vector of kmers
</p>

<hr>
<h2 id='generate_pattern'><code>generate_pattern</code></h2><span id='topic+generate_pattern'></span>

<h3>Description</h3>

<p><code>generate_pattern</code> is used to generate pattern for calculation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>generate_pattern(seqc, ordered_index = c(), append_to = list())
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="generate_pattern_+3A_seqc">seqc</code></td>
<td>
<p>list of sequences</p>
</td></tr>
<tr><td><code id="generate_pattern_+3A_ordered_index">ordered_index</code></td>
<td>
<p>list of indexes for the pattern in the order</p>
</td></tr>
<tr><td><code id="generate_pattern_+3A_append_to">append_to</code></td>
<td>
<p>existing patterns to append to</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Will return concatenated list of string for searching.
</p>

<hr>
<h2 id='generate_prioritisation'><code>generate_prioritisation</code></h2><span id='topic+generate_prioritisation'></span>

<h3>Description</h3>

<p><code>generate_prioritisation</code> create a vector of the targets in order of priority.
Targets with the less samples are prioritised first, breaking ties by alphabetical order.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>generate_prioritisation(meta)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="generate_prioritisation_+3A_meta">meta</code></td>
<td>
<p>A data.table containing the meta data, expect the</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data.table of the targets in order of priority
</p>

<hr>
<h2 id='generate_snp_search_string'><code>generate_snp_search_string</code></h2><span id='topic+generate_snp_search_string'></span>

<h3>Description</h3>

<p><code>generate_snp_search_string</code> identify the SNPs that will overlap
the search strings generated from the targeted SNPs
</p>


<h3>Usage</h3>

<pre><code class='language-R'>generate_snp_search_string(
  selected_snps,
  position_reference,
  ref_seq,
  snp_matrix,
  prev,
  after,
  position_type = "fasta",
  extend_length = TRUE,
  fasta_name_as_result = TRUE,
  bp = MulticoreParam()
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="generate_snp_search_string_+3A_selected_snps">selected_snps</code></td>
<td>
<p>list of targeted SNPs</p>
</td></tr>
<tr><td><code id="generate_snp_search_string_+3A_position_reference">position_reference</code></td>
<td>
<p>the mapping between
reference genome positions and orthologous SNP matrix positions</p>
</td></tr>
<tr><td><code id="generate_snp_search_string_+3A_ref_seq">ref_seq</code></td>
<td>
<p>the reference genome sequence</p>
</td></tr>
<tr><td><code id="generate_snp_search_string_+3A_snp_matrix">snp_matrix</code></td>
<td>
<p>the orthologous SNP matrix</p>
</td></tr>
<tr><td><code id="generate_snp_search_string_+3A_prev">prev</code></td>
<td>
<p>number of characters before the SNP</p>
</td></tr>
<tr><td><code id="generate_snp_search_string_+3A_after">after</code></td>
<td>
<p>number of characters after the SNP</p>
</td></tr>
<tr><td><code id="generate_snp_search_string_+3A_position_type">position_type</code></td>
<td>
<p>type of SNPs input, &quot;fasta&quot;
(orthologous SNP matrix based) or &quot;genome&quot;
(reference genome based); Default to &quot;fasta&quot;</p>
</td></tr>
<tr><td><code id="generate_snp_search_string_+3A_extend_length">extend_length</code></td>
<td>
<p>whether to extend the search string
before and after the SNP and ignore overlapping SNPs</p>
</td></tr>
<tr><td><code id="generate_snp_search_string_+3A_fasta_name_as_result">fasta_name_as_result</code></td>
<td>
<p>Whether the result should use 
the fasta matching sequence name or the fasta position and allele,
default to using fasta sequence name (TRUE)</p>
</td></tr>
<tr><td><code id="generate_snp_search_string_+3A_bp">bp</code></td>
<td>
<p>BiocParallel backend to use</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a dataframe containing the search strings
</p>

<hr>
<h2 id='get_all_process_methods'><code>get_all_process_methods</code></h2><span id='topic+get_all_process_methods'></span>

<h3>Description</h3>

<p><code>get_all_process_methods</code> is used to get the metrics function
and required parameters. Additional metric may be set by
assigning it to 'MinSNPs_process_methods' variable.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_all_process_methods(process_name = "")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="get_all_process_methods_+3A_process_name">process_name</code></td>
<td>
<p>name of the metric, &quot;&quot; to return all,
'SNP' or 'KMER' are provided as default.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list, including the function to process the search sequence result
</p>

<hr>
<h2 id='get_binomial_tables'><code>get_binomial_tables</code></h2><span id='topic+get_binomial_tables'></span>

<h3>Description</h3>

<p><code>get_binomial_tables</code> is an internal function that returns a table of probability for binomial naive bayes.
modified from bernoulli_naive_bayes function in the naivebayes package
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_binomial_tables(prob1)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="get_binomial_tables_+3A_prob1">prob1</code></td>
<td>
<p>a matrix of probabilities</p>
</td></tr>
</table>


<h3>Value</h3>

<p>return table of probability for binomial naive bayes
</p>

<hr>
<h2 id='get_metric_fun'><code>get_metric_fun</code></h2><span id='topic+get_metric_fun'></span>

<h3>Description</h3>

<p><code>get_metric_fun</code> is used to get the metrics function
and required parameters. Additional metric may set by
assigning to 'MinSNPs_metrics' variable.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_metric_fun(metric_name = "")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="get_metric_fun_+3A_metric_name">metric_name</code></td>
<td>
<p>name of the metric, by default percent/simpson</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list, including the function to calculate the
metric based on a position ('calc'), and function to check for
additional parameters the function need ('args')
</p>

<hr>
<h2 id='get_positions_to_search'><code>get_positions_to_search</code></h2><span id='topic+get_positions_to_search'></span>

<h3>Description</h3>

<p><code>get_positions_to_search</code> is used to identify all the positions
to loop through, used by <code>branch_and_search</code> and <code>find_optimised_snps</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_positions_to_search(seqc_len, excluded_pos, traversed, bp)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="get_positions_to_search_+3A_seqc_len">seqc_len</code></td>
<td>
<p>length of the matrix</p>
</td></tr>
<tr><td><code id="get_positions_to_search_+3A_excluded_pos">excluded_pos</code></td>
<td>
<p>vector of excluded positions</p>
</td></tr>
<tr><td><code id="get_positions_to_search_+3A_traversed">traversed</code></td>
<td>
<p>vector of positions that is previously selected</p>
</td></tr>
<tr><td><code id="get_positions_to_search_+3A_bp">bp</code></td>
<td>
<p>BiocParallel backend</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Will return a list of positions to search through
</p>

<hr>
<h2 id='get_snps_set'><code>get_snps_set</code></h2><span id='topic+get_snps_set'></span>

<h3>Description</h3>

<p><code>get_snps_set</code> extract the SNP sets from the output of
'find_optimised_snps'.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_snps_set(results, as = "data.frame")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="get_snps_set_+3A_results">results</code></td>
<td>
<p>output from 'find_optimised_snps'</p>
</td></tr>
<tr><td><code id="get_snps_set_+3A_as">as</code></td>
<td>
<p>output format, either 'data.frame' or 'list'.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>will return either 
1. a dataframe containing SNPs_set (SNP position separated by &quot;,&quot;) and score
2. a list containing SNPs_set (SNP position as numeric vector) and score (attr of the list)
</p>

<hr>
<h2 id='get_usual_length'><code>get_usual_length</code></h2><span id='topic+get_usual_length'></span>

<h3>Description</h3>

<p><code>get_usual_length</code> is used to find out
the length of the sequences (W/O deletion).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_usual_length(seqc, bp = SerialParam())
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="get_usual_length_+3A_seqc">seqc</code></td>
<td>
<p>a list containing list of nucleotides. To keep it simple,
use provided read_fasta to import the fasta file.</p>
</td></tr>
<tr><td><code id="get_usual_length_+3A_bp">bp</code></td>
<td>
<p>is the biocparallel backend, default to serialParam,
most likely sufficient in most scenario</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Will return the length of most of the samples,
the higher number is taken as tie breaker
</p>

<hr>
<h2 id='identify_overlaps'><code>identify_overlaps</code></h2><span id='topic+identify_overlaps'></span>

<h3>Description</h3>

<p><code>identify_overlaps</code> identify the overlapping SNPs in the sequences
</p>


<h3>Usage</h3>

<pre><code class='language-R'>identify_overlaps(position_reference, genome_position, prev, after)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="identify_overlaps_+3A_position_reference">position_reference</code></td>
<td>
<p>the mapping of position
in SNP matrix to reference genome</p>
</td></tr>
<tr><td><code id="identify_overlaps_+3A_genome_position">genome_position</code></td>
<td>
<p>the position of the SNP in the reference genome</p>
</td></tr>
<tr><td><code id="identify_overlaps_+3A_prev">prev</code></td>
<td>
<p>number of bases before the SNP included in the search string</p>
</td></tr>
<tr><td><code id="identify_overlaps_+3A_after">after</code></td>
<td>
<p>number of bases after the SNP included in the search string</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list containing 2 dataframes listing the bystander SNPs
in the flanking sequence before and after the SNPs
</p>

<hr>
<h2 id='infer_from_combined'><code>infer_from_combined</code></h2><span id='topic+infer_from_combined'></span>

<h3>Description</h3>

<p><code>infer_from_combined</code> infers the results (presence/absense of genes &amp; CC) from the combined result
</p>


<h3>Usage</h3>

<pre><code class='language-R'>infer_from_combined(combined_result, search_table, genome_size, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="infer_from_combined_+3A_combined_result">combined_result</code></td>
<td>
<p>the combined result from <code>combine_fastq_search_result</code> or equivalent,
with a list containing:
- result: a dataframe containing the following columns:
'sequence', 'search_id', 'reads', 'raw_match', 'mean_qualities', 'indexes', 'id', 'type',
'strand', 'result', 'extra', 'match_ref_seq', 'n_reads'
- read_length:
'reads_id', 'reads_length'</p>
</td></tr>
<tr><td><code id="infer_from_combined_+3A_search_table">search_table</code></td>
<td>
<p>a dataframe with the following columns:
- &quot;id&quot;,&quot;type&quot;,&quot;sequence&quot;,&quot;strand&quot;,&quot;result&quot;,&quot;extra&quot;,&quot;match_ref_seq&quot;</p>
</td></tr>
<tr><td><code id="infer_from_combined_+3A_genome_size">genome_size</code></td>
<td>
<p>estimated genome size for coverage calculation</p>
</td></tr>
<tr><td><code id="infer_from_combined_+3A_...">...</code></td>
<td>
<p>additional arguments to pass to the process methods</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a dataframe containing the following columns:
- type, rank, result, reads_count, proportion_matched, pass_filter
</p>

<hr>
<h2 id='iterate_merge'><code>iterate_merge</code></h2><span id='topic+iterate_merge'></span>

<h3>Description</h3>

<p><code>iterate_merge</code> is used to combine &gt; 2 fastas iteratively.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>iterate_merge(
  fastas,
  metas,
  ref,
  method = "full",
  bp = BiocParallel::SerialParam(),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="iterate_merge_+3A_fastas">fastas</code></td>
<td>
<p>list of fastas read into memory to join</p>
</td></tr>
<tr><td><code id="iterate_merge_+3A_metas">metas</code></td>
<td>
<p>list of metas read into memory to join</p>
</td></tr>
<tr><td><code id="iterate_merge_+3A_ref">ref</code></td>
<td>
<p>name of the reference genome (needs to be in both fasta files)</p>
</td></tr>
<tr><td><code id="iterate_merge_+3A_method">method</code></td>
<td>
<p>how to join the 2 fasta, currently supported methods are:
inner, full</p>
</td></tr>
<tr><td><code id="iterate_merge_+3A_bp">bp</code></td>
<td>
<p>the BiocParallel backend</p>
</td></tr>
<tr><td><code id="iterate_merge_+3A_...">...</code></td>
<td>
<p>all other arguments</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Will return a list containing a merged FASTA and a meta.
</p>

<hr>
<h2 id='iterate_through'><code>iterate_through</code></h2><span id='topic+iterate_through'></span>

<h3>Description</h3>

<p><code>iterate_through</code> is used to calculate the metric at each position
</p>


<h3>Usage</h3>

<pre><code class='language-R'>iterate_through(metric, seqc, bp = MulticoreParam(), ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="iterate_through_+3A_metric">metric</code></td>
<td>
<p>either 'simpson' or 'percent'</p>
</td></tr>
<tr><td><code id="iterate_through_+3A_seqc">seqc</code></td>
<td>
<p>list of sequences, either passed directly from
<code>process_allele</code> or <code>read_fasta</code> or equivalence</p>
</td></tr>
<tr><td><code id="iterate_through_+3A_bp">bp</code></td>
<td>
<p>BiocParallel backend.
Rule of thumbs: use MulticoreParam(workers = ncpus - 2)</p>
</td></tr>
<tr><td><code id="iterate_through_+3A_...">...</code></td>
<td>
<p>other parameters as needed</p>
</td></tr>
</table>


<h3>Value</h3>

<p>return a dataframe containing the position and result.
</p>

<hr>
<h2 id='map_profile_to_target'><code>map_profile_to_target</code></h2><span id='topic+map_profile_to_target'></span>

<h3>Description</h3>

<p><code>map_profile_to_target</code> creates a mapping of the profile to the target, breaking the ties by the priority.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>map_profile_to_target(meta, patterns, priority, sensitive_to_1 = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="map_profile_to_target_+3A_meta">meta</code></td>
<td>
<p>A data.table containing the meta data</p>
</td></tr>
<tr><td><code id="map_profile_to_target_+3A_patterns">patterns</code></td>
<td>
<p>A list of the patterns from <code>generate_pattern</code></p>
</td></tr>
<tr><td><code id="map_profile_to_target_+3A_priority">priority</code></td>
<td>
<p>A data.table of the targets and priority, either generated by <code>generate_prioritisation</code> or supplied by user</p>
</td></tr>
<tr><td><code id="map_profile_to_target_+3A_sensitive_to_1">sensitive_to_1</code></td>
<td>
<p>whether to be completely sensitive to the first target (percent default), set to TRUE for percent</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector of the targets in order of priority
</p>

<hr>
<h2 id='match_count'><code>match_count</code></h2><span id='topic+match_count'></span>

<h3>Description</h3>

<p><code>match_count</code> return the number of matches of the target string in the
given sequence
</p>


<h3>Usage</h3>

<pre><code class='language-R'>match_count(target, search_from)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="match_count_+3A_target">target</code></td>
<td>
<p>the search target</p>
</td></tr>
<tr><td><code id="match_count_+3A_search_from">search_from</code></td>
<td>
<p>the sequence to search from</p>
</td></tr>
</table>


<h3>Value</h3>

<p>number of matches
</p>

<hr>
<h2 id='mcc_calculation'><code>mcc_calculation</code></h2><span id='topic+mcc_calculation'></span>

<h3>Description</h3>

<p><code>mcc_calculation</code> calculate the MCC score given the truth and predicted target.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mcc_calculation(
  result_with_truth,
  is_multi = TRUE,
  return_all_intermediate = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="mcc_calculation_+3A_result_with_truth">result_with_truth</code></td>
<td>
<p>the dataframe containing the truth and predicted target</p>
</td></tr>
<tr><td><code id="mcc_calculation_+3A_is_multi">is_multi</code></td>
<td>
<p>Whether to use MCC-multi or MCC</p>
</td></tr>
<tr><td><code id="mcc_calculation_+3A_return_all_intermediate">return_all_intermediate</code></td>
<td>
<p>whether to return all intermediate values, only possible for binary class</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Will return the mcc score
</p>

<hr>
<h2 id='merge_fasta'><code>merge_fasta</code></h2><span id='topic+merge_fasta'></span>

<h3>Description</h3>

<p><code>merge_fasta</code> is used to combine 2 fasta.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>merge_fasta(
  fasta_1,
  fasta_2,
  meta_1,
  meta_2,
  ref,
  method = "full",
  bp = BiocParallel::SerialParam(),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="merge_fasta_+3A_fasta_1">fasta_1</code></td>
<td>
<p>fasta read into memory to join</p>
</td></tr>
<tr><td><code id="merge_fasta_+3A_fasta_2">fasta_2</code></td>
<td>
<p>fasta read into memory to join</p>
</td></tr>
<tr><td><code id="merge_fasta_+3A_meta_1">meta_1</code></td>
<td>
<p>meta file for 'fasta_1' denoting all positions of SNPs
and position in reference genome</p>
</td></tr>
<tr><td><code id="merge_fasta_+3A_meta_2">meta_2</code></td>
<td>
<p>meta file for 'fasta_2' denoting all positions of SNPs
and position in reference genome</p>
</td></tr>
<tr><td><code id="merge_fasta_+3A_ref">ref</code></td>
<td>
<p>name of the reference genome (needs to be in both fasta files)</p>
</td></tr>
<tr><td><code id="merge_fasta_+3A_method">method</code></td>
<td>
<p>how to join the 2 fasta, currently supported methods are:
inner, full</p>
</td></tr>
<tr><td><code id="merge_fasta_+3A_bp">bp</code></td>
<td>
<p>the BiocParallel backend</p>
</td></tr>
<tr><td><code id="merge_fasta_+3A_...">...</code></td>
<td>
<p>all other arguments</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Will return a list containing a merged FASTA and a meta.
</p>

<hr>
<h2 id='output_parsed'><code>output_parsed</code></h2><span id='topic+output_parsed'></span>

<h3>Description</h3>

<p><code>output_parsed</code> is subfunction used by <code>output_result</code>
to present the result and save the result as tsv.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>output_parsed(
  parsed_view,
  seqc_obj,
  result,
  file_name,
  additional_details = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="output_parsed_+3A_parsed_view">parsed_view</code></td>
<td>
<p>the result from <code>get_metric_fun</code>, passed from
<code>output_result</code></p>
</td></tr>
<tr><td><code id="output_parsed_+3A_seqc_obj">seqc_obj</code></td>
<td>
<p>the sequences object.</p>
</td></tr>
<tr><td><code id="output_parsed_+3A_result">result</code></td>
<td>
<p>is the result from <code>find_optimised_snps</code></p>
</td></tr>
<tr><td><code id="output_parsed_+3A_file_name">file_name</code></td>
<td>
<p>file name, either tsv or &quot;&quot; for terminal output</p>
</td></tr>
<tr><td><code id="output_parsed_+3A_additional_details">additional_details</code></td>
<td>
<p>whether to print additional details.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>NULL, result either printed or saved as tsv.
</p>

<hr>
<h2 id='output_result'><code>output_result</code></h2><span id='topic+output_result'></span>

<h3>Description</h3>

<p><code>output_result</code> is used to present the result
and save the result as tsv.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>output_result(result, view = "", ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="output_result_+3A_result">result</code></td>
<td>
<p>is the result from <code>find_optimised_snps</code></p>
</td></tr>
<tr><td><code id="output_result_+3A_view">view</code></td>
<td>
<p>how to present the output,
&quot;csv&quot; or &quot;tsv&quot; will be saved as a file.
Otherwise, printed to console.</p>
</td></tr>
<tr><td><code id="output_result_+3A_...">...</code></td>
<td>
<p>if view is &quot;tsv&quot; or &quot;csv&quot;, file name can be passed, e.g.,
file_name = &quot;result.tsv&quot;, otherwise, file is saved as &lt;timestamp&gt;.tsv.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>NULL, result either printed or saved as tsv.
</p>

<hr>
<h2 id='output_to_files'><code>output_to_files</code></h2><span id='topic+output_to_files'></span>

<h3>Description</h3>

<p><code>output_to_files</code> is write the result to files.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>output_to_files(merged_result, filename = "merged")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="output_to_files_+3A_merged_result">merged_result</code></td>
<td>
<p>a list containing the merged fasta and meta.</p>
</td></tr>
<tr><td><code id="output_to_files_+3A_filename">filename</code></td>
<td>
<p>filename to write to, will output
&lt;filename&gt;.fasta and &lt;filename&gt;.csv.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>NULL, files written to filesystem
</p>

<hr>
<h2 id='parse_group_mcc'><code>parse_group_mcc</code></h2><span id='topic+parse_group_mcc'></span>

<h3>Description</h3>

<p><code>parse_group_mcc</code> is used to group the sample according to SNPs profile and present in a table format
</p>


<h3>Usage</h3>

<pre><code class='language-R'>parse_group_mcc(pattern, goi, MUST_HAVE_TARGET = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="parse_group_mcc_+3A_pattern">pattern</code></td>
<td>
<p>the SNP profile for each samples</p>
</td></tr>
<tr><td><code id="parse_group_mcc_+3A_goi">goi</code></td>
<td>
<p>the samples belonging to the group of interest</p>
</td></tr>
<tr><td><code id="parse_group_mcc_+3A_must_have_target">MUST_HAVE_TARGET</code></td>
<td>
<p>whether to force the profile to have at least 1 target profile
(the profile containing the most goi)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the parsed group views
</p>

<hr>
<h2 id='parse_group_mcc_multi'><code>parse_group_mcc_multi</code></h2><span id='topic+parse_group_mcc_multi'></span>

<h3>Description</h3>

<p><code>parse_group_mcc_multi</code> is used to put samples according to SNP profile, and
put them into a table format.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>parse_group_mcc_multi(result, as_string = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="parse_group_mcc_multi_+3A_result">result</code></td>
<td>
<p>result from <code>find_optimised_snps</code></p>
</td></tr>
<tr><td><code id="parse_group_mcc_multi_+3A_as_string">as_string</code></td>
<td>
<p>whether to return the result as string or data.frame</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Will return the grouped samples.
</p>

<hr>
<h2 id='predict_balk'><code>predict_balk</code></h2><span id='topic+predict_balk'></span>

<h3>Description</h3>

<p><code>predict_balk</code> is a function that predicts the class of new data using a binomial naive bayes classifier
</p>


<h3>Usage</h3>

<pre><code class='language-R'>predict_balk(object, newdata = NULL, snp_id = NULL, type = "prob")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="predict_balk_+3A_object">object</code></td>
<td>
<p>The classifier object</p>
</td></tr>
<tr><td><code id="predict_balk_+3A_newdata">newdata</code></td>
<td>
<p>A list of sequences</p>
</td></tr>
<tr><td><code id="predict_balk_+3A_snp_id">snp_id</code></td>
<td>
<p>A vector of SNP IDs</p>
</td></tr>
<tr><td><code id="predict_balk_+3A_type">type</code></td>
<td>
<p>The type of prediction, either &quot;prob&quot; or &quot;class&quot;</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector of either the class or the probability of the class
</p>

<hr>
<h2 id='predict.binomial_naive_bayes'><code>predict.binomial_naive_bayes</code></h2><span id='topic+predict.binomial_naive_bayes'></span>

<h3>Description</h3>

<p><code>predict.binomial_naive_bayes</code> is an implementation of the predict method for the binomial naive bayes algorithm.
modified from bernoulli_naive_bayes function in the naivebayes package
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'binomial_naive_bayes'
predict(object, newdata = NULL, type = c("class", "prob"), ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="predict.binomial_naive_bayes_+3A_object">object</code></td>
<td>
<p>a binomial_naive_bayes object</p>
</td></tr>
<tr><td><code id="predict.binomial_naive_bayes_+3A_newdata">newdata</code></td>
<td>
<p>a matrix with numeric: 0,1,up to binomial_n columns</p>
</td></tr>
<tr><td><code id="predict.binomial_naive_bayes_+3A_type">type</code></td>
<td>
<p>a character string specifying the type of output: &quot;class&quot; or &quot;prob&quot;</p>
</td></tr>
<tr><td><code id="predict.binomial_naive_bayes_+3A_...">...</code></td>
<td>
<p>additional arguments</p>
</td></tr>
</table>


<h3>Value</h3>

<p>return a factor or matrix of class probabilities
</p>

<hr>
<h2 id='print.binomial_naive_bayes'><code>print.binomial_naive_bayes</code></h2><span id='topic+print.binomial_naive_bayes'></span>

<h3>Description</h3>

<p><code>print.binomial_naive_bayes</code> is an implementation of the print method for the binomial naive bayes algorithm.
modified from bernoulli_naive_bayes function in the naivebayes package
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'binomial_naive_bayes'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="print.binomial_naive_bayes_+3A_x">x</code></td>
<td>
<p>a binomial_naive_bayes object</p>
</td></tr>
<tr><td><code id="print.binomial_naive_bayes_+3A_...">...</code></td>
<td>
<p>additional arguments</p>
</td></tr>
</table>


<h3>Value</h3>

<p>return a binomial_naive_bayes object
</p>

<hr>
<h2 id='process_allele'><code>process_allele</code></h2><span id='topic+process_allele'></span>

<h3>Description</h3>

<p><code>process_allele</code> is used to returned the processed allelic profiles, by
removing the allele profile with duplicate name and length different
from most. 1st allele profile with the duplicated name is returned,
the longer length is taken as normal should there be 2 modes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>process_allele(
  seqc,
  bp = BiocParallel::SerialParam(),
  check_length = TRUE,
  check_bases = TRUE,
  dash_ignore = TRUE,
  accepted_char = c("A", "C", "T", "G"),
  ignore_case = TRUE,
  remove_invariant = FALSE,
  biallelic_only = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="process_allele_+3A_seqc">seqc</code></td>
<td>
<p>a list containing list of nucleotides. To keep it simple,
use provided read_fasta to import the fasta file.</p>
</td></tr>
<tr><td><code id="process_allele_+3A_bp">bp</code></td>
<td>
<p>is the biocparallel backend, default to serialParam,
most likely sufficient in most scenario</p>
</td></tr>
<tr><td><code id="process_allele_+3A_check_length">check_length</code></td>
<td>
<p>Check the length of each sample in the matrix, default to TRUE</p>
</td></tr>
<tr><td><code id="process_allele_+3A_check_bases">check_bases</code></td>
<td>
<p>Check the bases of each sample in the matrix, default to TRUE</p>
</td></tr>
<tr><td><code id="process_allele_+3A_dash_ignore">dash_ignore</code></td>
<td>
<p>whether to treat '-' as another type</p>
</td></tr>
<tr><td><code id="process_allele_+3A_accepted_char">accepted_char</code></td>
<td>
<p>character to accept, default to c(&quot;A&quot;, &quot;C&quot;, &quot;T&quot;, &quot;G&quot;)</p>
</td></tr>
<tr><td><code id="process_allele_+3A_ignore_case">ignore_case</code></td>
<td>
<p>whether to be case insensitive, default to TRUE</p>
</td></tr>
<tr><td><code id="process_allele_+3A_remove_invariant">remove_invariant</code></td>
<td>
<p>whether to remove invariant positions, default to FALSE</p>
</td></tr>
<tr><td><code id="process_allele_+3A_biallelic_only">biallelic_only</code></td>
<td>
<p>whether to remove positions with more than 2 alleles, default to FALSE</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Will return the processed allelic profiles.
</p>

<hr>
<h2 id='process_kmer_result'><code>process_kmer_result</code></h2><span id='topic+process_kmer_result'></span>

<h3>Description</h3>

<p><code>process_kmer_result</code> processes the KMER result from <code>infer_from_combined</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>process_kmer_result(partial_result, search_table, min_match_per_read = 1, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="process_kmer_result_+3A_partial_result">partial_result</code></td>
<td>
<p>the result from <code>infer_from_combined</code> with only KMER</p>
</td></tr>
<tr><td><code id="process_kmer_result_+3A_search_table">search_table</code></td>
<td>
<p>a dataframe with the following columns:
- &quot;id&quot;,&quot;type&quot;,&quot;sequence&quot;,&quot;strand&quot;,&quot;result&quot;,&quot;extra&quot;,&quot;match_ref_seq&quot;</p>
</td></tr>
<tr><td><code id="process_kmer_result_+3A_min_match_per_read">min_match_per_read</code></td>
<td>
<p>the minimum number of kmer matches in a read, discarding reads with less than this number</p>
</td></tr>
<tr><td><code id="process_kmer_result_+3A_...">...</code></td>
<td>
<p>ignored</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a dataframe containing the following columns:
- type, rank, result, reads_count, proportion_matched, pass_filter, proportion_scheme_found, details
</p>

<hr>
<h2 id='process_result_file'><code>process_result_file</code></h2><span id='topic+process_result_file'></span>

<h3>Description</h3>

<p><code>process_result_file</code> extract the SNP sets from the saved output file.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>process_result_file(result_filepath)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="process_result_file_+3A_result_filepath">result_filepath</code></td>
<td>
<p>is the path of the saved output file.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>will return a list containing SNPs_set (SNP position as numeric vector).
</p>

<hr>
<h2 id='process_snp_result'><code>process_snp_result</code></h2><span id='topic+process_snp_result'></span>

<h3>Description</h3>

<p><code>process_snp_result</code> processes the SNP result from <code>infer_from_combined</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>process_snp_result(
  partial_result,
  search_table,
  count_measure = "n_reads",
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="process_snp_result_+3A_partial_result">partial_result</code></td>
<td>
<p>the result from <code>infer_from_combined</code> with only SNP</p>
</td></tr>
<tr><td><code id="process_snp_result_+3A_search_table">search_table</code></td>
<td>
<p>a dataframe with the following columns:
- &quot;id&quot;,&quot;type&quot;,&quot;sequence&quot;,&quot;strand&quot;,&quot;result&quot;,&quot;extra&quot;,&quot;match_ref_seq&quot;</p>
</td></tr>
<tr><td><code id="process_snp_result_+3A_count_measure">count_measure</code></td>
<td>
<p>the column name of the count measure to use for removing the conflicts</p>
</td></tr>
<tr><td><code id="process_snp_result_+3A_...">...</code></td>
<td>
<p>ignored</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list containing:
- result: a dataframe containing the following columns:
- type, rank, result, reads_count, proportion_matched, pass_filter, proportion_scheme_found, details
- snps_found: a vector containing the SNPs ID that have been identified without conflict
- proportion_snps_found: the proportion of SNPs found without conflict
</p>

<hr>
<h2 id='profile_to_group_result'><code>profile_to_group_result</code></h2><span id='topic+profile_to_group_result'></span>

<h3>Description</h3>

<p><code>profile_to_group_result</code> given profile target, return the result
</p>


<h3>Usage</h3>

<pre><code class='language-R'>profile_to_group_result(patterns, profile_target)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="profile_to_group_result_+3A_patterns">patterns</code></td>
<td>
<p>the SNP profile for each samples</p>
</td></tr>
<tr><td><code id="profile_to_group_result_+3A_profile_target">profile_target</code></td>
<td>
<p>the profile target - should be from samples previously seen, generate with <code>map_profile_to_target</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>Will return the result, given the SNP profile.
</p>

<hr>
<h2 id='read_fasta'><code>read_fasta</code></h2><span id='topic+read_fasta'></span>

<h3>Description</h3>

<p><code>read_fasta</code> is used to read fasta file, implementation
similar to seqinr, but much simpler and allow for spaces in sample name.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>read_fasta(file, force_to_upper = TRUE, bp = SerialParam())
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="read_fasta_+3A_file">file</code></td>
<td>
<p>file path</p>
</td></tr>
<tr><td><code id="read_fasta_+3A_force_to_upper">force_to_upper</code></td>
<td>
<p>whether to transform sequences
to upper case, default to TRUE</p>
</td></tr>
<tr><td><code id="read_fasta_+3A_bp">bp</code></td>
<td>
<p>is the biocparallel backend, default to serialParam,
most likely sufficient in most scenario</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Will return list of named character vectors.
</p>

<hr>
<h2 id='read_sequences_from_fastq'><code>read_sequences_from_fastq</code></h2><span id='topic+read_sequences_from_fastq'></span>

<h3>Description</h3>

<p><code>read_sequences_from_fastq</code> get the sequences
from a fastq file, it completely ignores the quality scores
</p>


<h3>Usage</h3>

<pre><code class='language-R'>read_sequences_from_fastq(
  fastq_file,
  force_to_upper = TRUE,
  skip_n_reads = 0,
  max_n_reads = -1,
  output_quality = TRUE,
  quality_offset = 33,
  bp = MulticoreParam()
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="read_sequences_from_fastq_+3A_fastq_file">fastq_file</code></td>
<td>
<p>location of the fastq file</p>
</td></tr>
<tr><td><code id="read_sequences_from_fastq_+3A_force_to_upper">force_to_upper</code></td>
<td>
<p>whether to transform sequences
to upper case, default to TRUE</p>
</td></tr>
<tr><td><code id="read_sequences_from_fastq_+3A_skip_n_reads">skip_n_reads</code></td>
<td>
<p>number of reads to skip, default to 0</p>
</td></tr>
<tr><td><code id="read_sequences_from_fastq_+3A_max_n_reads">max_n_reads</code></td>
<td>
<p>maximum number of reads to read, default to -1 (all)</p>
</td></tr>
<tr><td><code id="read_sequences_from_fastq_+3A_output_quality">output_quality</code></td>
<td>
<p>whether to output the quality scores, default to TRUE</p>
</td></tr>
<tr><td><code id="read_sequences_from_fastq_+3A_quality_offset">quality_offset</code></td>
<td>
<p>the quality offset to use, default to 33</p>
</td></tr>
<tr><td><code id="read_sequences_from_fastq_+3A_bp">bp</code></td>
<td>
<p>BiocParallel backend to use for parallelization</p>
</td></tr>
</table>


<h3>Value</h3>

<p>will return a list of sequences, with qualities as attribute
</p>

<hr>
<h2 id='remove_dup_isolate'><code>remove_dup_isolate</code></h2><span id='topic+remove_dup_isolate'></span>

<h3>Description</h3>

<p><code>remove_dup_isolate</code> is used to remove isolate with the same name.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>remove_dup_isolate(seqc)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="remove_dup_isolate_+3A_seqc">seqc</code></td>
<td>
<p>a list containing list of nucleotides. To keep it simple,
use provided read_fasta to import the fasta file.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>return the list of samples where only the first instance of
the isolate with the duplicate name is kept
</p>

<hr>
<h2 id='remove_snp_conflict'><code>remove_snp_conflic</code></h2><span id='topic+remove_snp_conflict'></span>

<h3>Description</h3>

<p><code>remove_snp_conflic</code> removes the reads with SNPs conflicts from the result
</p>


<h3>Usage</h3>

<pre><code class='language-R'>remove_snp_conflict(result, count_measure = "n_reads")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="remove_snp_conflict_+3A_result">result</code></td>
<td>
<p>the result from <code>infer_from_combined</code></p>
</td></tr>
<tr><td><code id="remove_snp_conflict_+3A_count_measure">count_measure</code></td>
<td>
<p>the column name of the count measure to use for removing the conflicts</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a dataframe containing the same columns as the input result with row containing conflicts removed
</p>

<hr>
<h2 id='resolve_IUPAC_missing'><code>resolve_IUPAC_missing</code></h2><span id='topic+resolve_IUPAC_missing'></span>

<h3>Description</h3>

<p><code>resolve_IUPAC_missing</code> is used to replace the
ambiguity codes found in the sequences.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>resolve_IUPAC_missing(
  seqc,
  log_operation = TRUE,
  log_file = "replace.log",
  max_ambiguity = -1,
  replace_method = "random",
  N_is_any_base = FALSE,
  output_progress = TRUE,
  bp = MulticoreParam()
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="resolve_IUPAC_missing_+3A_seqc">seqc</code></td>
<td>
<p>the sequences to be processed</p>
</td></tr>
<tr><td><code id="resolve_IUPAC_missing_+3A_log_operation">log_operation</code></td>
<td>
<p>whether to log the operation</p>
</td></tr>
<tr><td><code id="resolve_IUPAC_missing_+3A_log_file">log_file</code></td>
<td>
<p>log file to write the operations</p>
</td></tr>
<tr><td><code id="resolve_IUPAC_missing_+3A_max_ambiguity">max_ambiguity</code></td>
<td>
<p>proportion of ambiguity codes to tolerate,
-1 = ignore. Default to -1</p>
</td></tr>
<tr><td><code id="resolve_IUPAC_missing_+3A_replace_method">replace_method</code></td>
<td>
<p>how to substitute the ambiguity codes,
current supported methods:random and most_common, default to &quot;random&quot;.</p>
</td></tr>
<tr><td><code id="resolve_IUPAC_missing_+3A_n_is_any_base">N_is_any_base</code></td>
<td>
<p>whether to treat N as any base or substitute it
with one of the alleles found at the position.</p>
</td></tr>
<tr><td><code id="resolve_IUPAC_missing_+3A_output_progress">output_progress</code></td>
<td>
<p>whether to output progress</p>
</td></tr>
<tr><td><code id="resolve_IUPAC_missing_+3A_bp">bp</code></td>
<td>
<p>the BiocParallel backend</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Will return the processed sequences.
</p>

<hr>
<h2 id='reverse_complement'><code>reverse_complement</code></h2><span id='topic+reverse_complement'></span>

<h3>Description</h3>

<p><code>reverse_complement</code> returns the reverse complement of the
given sequence
</p>


<h3>Usage</h3>

<pre><code class='language-R'>reverse_complement(seq)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="reverse_complement_+3A_seq">seq</code></td>
<td>
<p>the sequence to reverse complement</p>
</td></tr>
</table>


<h3>Value</h3>

<p>reverse complemented sequence
</p>

<hr>
<h2 id='scramble_sequence'><code>scramble_sequence</code></h2><span id='topic+scramble_sequence'></span>

<h3>Description</h3>

<p><code>scramble_sequence</code> scramble the orthologous matrix based on a seed
</p>


<h3>Usage</h3>

<pre><code class='language-R'>scramble_sequence(seqc, seed)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="scramble_sequence_+3A_seqc">seqc</code></td>
<td>
<p>the sequence to scramble</p>
</td></tr>
<tr><td><code id="scramble_sequence_+3A_seed">seed</code></td>
<td>
<p>the seed to use for scrambling</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a named list, containing the scambled sequence and the new positions
</p>

<hr>
<h2 id='search_from_fastq_reads'><code>search_from_fastq_reads</code></h2><span id='topic+search_from_fastq_reads'></span>

<h3>Description</h3>

<p><code>search_from_fastq_reads</code> identify the matches
from a list of search strings
</p>


<h3>Usage</h3>

<pre><code class='language-R'>search_from_fastq_reads(
  fastq_file,
  search_tables,
  skip_n_reads = 0,
  progress = TRUE,
  max_n_reads = -1,
  quality_offset = 33,
  output_temp_result = TRUE,
  temp_result_folder = "./temp_results",
  simplify_id = TRUE,
  output_read_length = TRUE,
  bp = MulticoreParam()
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="search_from_fastq_reads_+3A_fastq_file">fastq_file</code></td>
<td>
<p>fastq file containing the runs to search from</p>
</td></tr>
<tr><td><code id="search_from_fastq_reads_+3A_search_tables">search_tables</code></td>
<td>
<p>a dataframe with the following columns:
- [&quot;id&quot;],&quot;type&quot;,[&quot;sequence&quot;],&quot;strand&quot;,&quot;result&quot;,&quot;extra&quot;,&quot;match_ref_seq&quot;</p>
</td></tr>
<tr><td><code id="search_from_fastq_reads_+3A_skip_n_reads">skip_n_reads</code></td>
<td>
<p>number of reads to skip, default is 0</p>
</td></tr>
<tr><td><code id="search_from_fastq_reads_+3A_progress">progress</code></td>
<td>
<p>whether to show the progress bar</p>
</td></tr>
<tr><td><code id="search_from_fastq_reads_+3A_max_n_reads">max_n_reads</code></td>
<td>
<p>maximum number of reads to read, default to -1 (all)</p>
</td></tr>
<tr><td><code id="search_from_fastq_reads_+3A_quality_offset">quality_offset</code></td>
<td>
<p>the quality offset to use, default to 33</p>
</td></tr>
<tr><td><code id="search_from_fastq_reads_+3A_output_temp_result">output_temp_result</code></td>
<td>
<p>whether to output the temporary results</p>
</td></tr>
<tr><td><code id="search_from_fastq_reads_+3A_temp_result_folder">temp_result_folder</code></td>
<td>
<p>directory to output the temporary results</p>
</td></tr>
<tr><td><code id="search_from_fastq_reads_+3A_simplify_id">simplify_id</code></td>
<td>
<p>simplify and shorten the read id to the first part</p>
</td></tr>
<tr><td><code id="search_from_fastq_reads_+3A_output_read_length">output_read_length</code></td>
<td>
<p>whether to output the read length, NULL - do not output; csv - output to csv file; data - output to result</p>
</td></tr>
<tr><td><code id="search_from_fastq_reads_+3A_bp">bp</code></td>
<td>
<p>BiocParallel backend to use for parallelization</p>
</td></tr>
</table>


<h3>Value</h3>

<p>will return a list of dataframe containing: -
'search_id', 'sequence', 'reads', 'raw_match', 'mean_qualities', 'indexes'.
</p>

<hr>
<h2 id='search_from_reads'><code>search_from_reads</code></h2><span id='topic+search_from_reads'></span>

<h3>Description</h3>

<p><code>search_from_reads</code> identify the matches
from a list of search strings
</p>


<h3>Usage</h3>

<pre><code class='language-R'>search_from_reads(
  all_reads,
  search_tables,
  progress = TRUE,
  ID = "S1",
  all_qualities = NULL,
  output_temp_result = TRUE,
  temp_result_folder = "./temp_results",
  output_read_length = TRUE,
  bp = MulticoreParam()
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="search_from_reads_+3A_all_reads">all_reads</code></td>
<td>
<p>The reads containing the runs to search from</p>
</td></tr>
<tr><td><code id="search_from_reads_+3A_search_tables">search_tables</code></td>
<td>
<p>a dataframe with the following columns:
- [&quot;id&quot;],&quot;type&quot;,[&quot;sequence&quot;],&quot;strand&quot;,&quot;result&quot;,&quot;extra&quot;,&quot;match_ref_seq&quot;</p>
</td></tr>
<tr><td><code id="search_from_reads_+3A_progress">progress</code></td>
<td>
<p>whether to show the progress bar</p>
</td></tr>
<tr><td><code id="search_from_reads_+3A_id">ID</code></td>
<td>
<p>the ID to use, default to S1</p>
</td></tr>
<tr><td><code id="search_from_reads_+3A_all_qualities">all_qualities</code></td>
<td>
<p>quality data, default to NULL</p>
</td></tr>
<tr><td><code id="search_from_reads_+3A_output_temp_result">output_temp_result</code></td>
<td>
<p>whether to output the temporary results</p>
</td></tr>
<tr><td><code id="search_from_reads_+3A_temp_result_folder">temp_result_folder</code></td>
<td>
<p>directory to output the temporary results</p>
</td></tr>
<tr><td><code id="search_from_reads_+3A_output_read_length">output_read_length</code></td>
<td>
<p>whether to output the read length, NULL - do not output; csv - output to csv file; data - output to result</p>
</td></tr>
<tr><td><code id="search_from_reads_+3A_bp">bp</code></td>
<td>
<p>BiocParallel backend to use for parallelization</p>
</td></tr>
</table>


<h3>Value</h3>

<p>will return a list of dataframe containing: -
'search_id', 'sequence', 'reads', 'raw_match', 'mean_qualities', 'indexes'.
</p>

<hr>
<h2 id='select_n_set_i_depth'><code>select_n_set_i_depth</code></h2><span id='topic+select_n_set_i_depth'></span>

<h3>Description</h3>

<p><code>select_n_set_i_depth</code> is the actual function used to
find optimised SNPs set. This function is called by
<code>find_optimised_snps</code>, after preprocessing.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>select_n_set_i_depth(
  starting_positions = c(),
  excluded_positions = c(),
  seqc,
  metric,
  number_of_result = 1,
  max_depth = 1,
  seqc_length,
  bp = SerialParam(),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="select_n_set_i_depth_+3A_starting_positions">starting_positions</code></td>
<td>
<p>the starting positions that is already in
the SNP set.</p>
</td></tr>
<tr><td><code id="select_n_set_i_depth_+3A_excluded_positions">excluded_positions</code></td>
<td>
<p>excluded positions</p>
</td></tr>
<tr><td><code id="select_n_set_i_depth_+3A_seqc">seqc</code></td>
<td>
<p>list of sequences, either passed directly from
<code>process_allele</code> or <code>read_fasta</code> or equivalence</p>
</td></tr>
<tr><td><code id="select_n_set_i_depth_+3A_metric">metric</code></td>
<td>
<p>either 'simpson' or 'percent'</p>
</td></tr>
<tr><td><code id="select_n_set_i_depth_+3A_number_of_result">number_of_result</code></td>
<td>
<p>number of results to return, 0 will be coerced to 1</p>
</td></tr>
<tr><td><code id="select_n_set_i_depth_+3A_max_depth">max_depth</code></td>
<td>
<p>maximum depth to go before terminating,
0 means it will only calculate the metric for included position</p>
</td></tr>
<tr><td><code id="select_n_set_i_depth_+3A_seqc_length">seqc_length</code></td>
<td>
<p>the length to iterate through.</p>
</td></tr>
<tr><td><code id="select_n_set_i_depth_+3A_bp">bp</code></td>
<td>
<p>BiocParallel backend.
Rule of thumbs: use MulticoreParam(workers = ncpus - 2)</p>
</td></tr>
<tr><td><code id="select_n_set_i_depth_+3A_...">...</code></td>
<td>
<p>other parameters as needed</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Will return the resolution-optimised SNPs set, based on the metric.
</p>

<hr>
<h2 id='sequence_reads_match_count'><code>sequence_reads_match_count</code></h2><span id='topic+sequence_reads_match_count'></span>

<h3>Description</h3>

<p><code>sequence_reads_match_count</code> look for the search sequences in reads and return the matches indexes and mean qualities
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sequence_reads_match_count(search_sequence, reads, qualities)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="sequence_reads_match_count_+3A_search_sequence">search_sequence</code></td>
<td>
<p>the search sequence to look for where '.' stands for any character.</p>
</td></tr>
<tr><td><code id="sequence_reads_match_count_+3A_reads">reads</code></td>
<td>
<p>the sequences reads to search for.</p>
</td></tr>
<tr><td><code id="sequence_reads_match_count_+3A_qualities">qualities</code></td>
<td>
<p>the qualities of each bases in the reads.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>will return a list containing for each read: -
count, mean_quality, indexes
</p>

<hr>
<h2 id='summarise_result'><code>summarise_result</code></h2><span id='topic+summarise_result'></span>

<h3>Description</h3>

<p><code>summarise_result</code> calculate the MCC score given the SNP sets, training, validation and metadata(s).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>summarise_result(
  snp_sets,
  training_seqs,
  validation_seqs,
  training_metadata,
  validation_metadata,
  priority,
  is_multi = TRUE,
  return_all_intermediate = FALSE,
  is_percent = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="summarise_result_+3A_snp_sets">snp_sets</code></td>
<td>
<p>the dataframe containing the truth and predicted target</p>
</td></tr>
<tr><td><code id="summarise_result_+3A_training_seqs">training_seqs</code></td>
<td>
<p>the training sequences</p>
</td></tr>
<tr><td><code id="summarise_result_+3A_validation_seqs">validation_seqs</code></td>
<td>
<p>the validation sequences</p>
</td></tr>
<tr><td><code id="summarise_result_+3A_training_metadata">training_metadata</code></td>
<td>
<p>the training metadata</p>
</td></tr>
<tr><td><code id="summarise_result_+3A_validation_metadata">validation_metadata</code></td>
<td>
<p>the validation metadata</p>
</td></tr>
<tr><td><code id="summarise_result_+3A_priority">priority</code></td>
<td>
<p>the priority of the target, generated by <code>generate_prioritisation</code></p>
</td></tr>
<tr><td><code id="summarise_result_+3A_is_multi">is_multi</code></td>
<td>
<p>Whether to use MCC-multi or MCC</p>
</td></tr>
<tr><td><code id="summarise_result_+3A_return_all_intermediate">return_all_intermediate</code></td>
<td>
<p>whether to return all intermediate values, only possible for binary class</p>
</td></tr>
<tr><td><code id="summarise_result_+3A_is_percent">is_percent</code></td>
<td>
<p>whether to return result by considering all the profiles having a GOI as target profile</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Will return the summarised result
</p>

<hr>
<h2 id='summary.binomial_naive_bayes'><code>summary.binomial_naive_bayes</code></h2><span id='topic+summary.binomial_naive_bayes'></span>

<h3>Description</h3>

<p><code>summary.binomial_naive_bayes</code> is an implementation of the summary method for the binomial naive bayes algorithm.
modified from bernoulli_naive_bayes function in the naivebayes package
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'binomial_naive_bayes'
summary(object, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="summary.binomial_naive_bayes_+3A_object">object</code></td>
<td>
<p>a binomial_naive_bayes object</p>
</td></tr>
<tr><td><code id="summary.binomial_naive_bayes_+3A_...">...</code></td>
<td>
<p>additional arguments</p>
</td></tr>
</table>


<h3>Value</h3>

<p>return a summary of the binomial_naive_bayes object
</p>

<hr>
<h2 id='train_balk'><code>train_balk</code></h2><span id='topic+train_balk'></span>

<h3>Description</h3>

<p><code>train_balk</code> is a function that trains a binomial naive bayes classifier for sequence data
</p>


<h3>Usage</h3>

<pre><code class='language-R'>train_balk(
  seqc,
  snps_pos,
  meta,
  binomial_n = 1,
  laplace = 1,
  snp_id = NULL,
  prior = NULL,
  fit_prior = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="train_balk_+3A_seqc">seqc</code></td>
<td>
<p>A list of sequences</p>
</td></tr>
<tr><td><code id="train_balk_+3A_snps_pos">snps_pos</code></td>
<td>
<p>A vector of SNP positions</p>
</td></tr>
<tr><td><code id="train_balk_+3A_meta">meta</code></td>
<td>
<p>A data frame containing the metadata, require isolate and target columns</p>
</td></tr>
<tr><td><code id="train_balk_+3A_binomial_n">binomial_n</code></td>
<td>
<p>The number of classes for the binomial naive bayes, default to 1 - bernoulli, 2 - binomial (support heterozygous SNPs)</p>
</td></tr>
<tr><td><code id="train_balk_+3A_laplace">laplace</code></td>
<td>
<p>The Laplace smoothing parameter</p>
</td></tr>
<tr><td><code id="train_balk_+3A_snp_id">snp_id</code></td>
<td>
<p>A vector of SNP IDs, if not provided, it will be inferred from the SNP positions</p>
</td></tr>
<tr><td><code id="train_balk_+3A_prior">prior</code></td>
<td>
<p>The prior probabilities of the classes</p>
</td></tr>
<tr><td><code id="train_balk_+3A_fit_prior">fit_prior</code></td>
<td>
<p>Whether to learn class prior probabilities</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list containing the classifier and the transformation levels
</p>

<hr>
<h2 id='transform_snp'><code>transform_snp</code></h2><span id='topic+transform_snp'></span>

<h3>Description</h3>

<p><code>transform_snp</code> is a function that transforms a SNP into a matrix for binomial naive bayes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>transform_snp(pat, binomial_n, levels = c(), get = c("levels", "transformed"))
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="transform_snp_+3A_pat">pat</code></td>
<td>
<p>A string of a SNP</p>
</td></tr>
<tr><td><code id="transform_snp_+3A_binomial_n">binomial_n</code></td>
<td>
<p>The number of classes for the binomial naive bayes, default to 1 - bernoulli, 2 - binomial (support heterozygous SNPs)</p>
</td></tr>
<tr><td><code id="transform_snp_+3A_levels">levels</code></td>
<td>
<p>Existing transformation levels, if not provided, it will be inferred from the SNP</p>
</td></tr>
<tr><td><code id="transform_snp_+3A_get">get</code></td>
<td>
<p>What to return, either &quot;levels&quot; or &quot;transformed&quot;, or both</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector of either the transformation levels or the transformed SNP or a list containing both
</p>

<hr>
<h2 id='translate_position'><code>translate_position</code></h2><span id='topic+translate_position'></span>

<h3>Description</h3>

<p><code>translate_position</code> translate the scambled position in the alignment
to the original position or vice versa
</p>


<h3>Usage</h3>

<pre><code class='language-R'>translate_position(position, positions_table, to = "original")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="translate_position_+3A_position">position</code></td>
<td>
<p>the position to translate</p>
</td></tr>
<tr><td><code id="translate_position_+3A_positions_table">positions_table</code></td>
<td>
<p>the table containing the original and scrambled positions</p>
</td></tr>
<tr><td><code id="translate_position_+3A_to">to</code></td>
<td>
<p>the direction to translate, either &quot;original&quot; or &quot;scrambled&quot;</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the translated position
</p>

<hr>
<h2 id='view_mcc'><code>view_mcc</code></h2><span id='topic+view_mcc'></span>

<h3>Description</h3>

<p><code>view_mcc</code> is used to present the result of selected SNPs set
based on the MCC score
</p>


<h3>Usage</h3>

<pre><code class='language-R'>view_mcc(result, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="view_mcc_+3A_result">result</code></td>
<td>
<p>is the result from <code>find_optimised_snps</code></p>
</td></tr>
<tr><td><code id="view_mcc_+3A_...">...</code></td>
<td>
<p>other optional parameters</p>
</td></tr>
</table>


<h3>Value</h3>

<p>formatted result list to be saved or presented.
</p>

<hr>
<h2 id='view_mcc_multi'><code>view_mcc_multi</code></h2><span id='topic+view_mcc_multi'></span>

<h3>Description</h3>

<p><code>view_mcc_multi</code> is used to present the result of selected SNPs set
based on the multi-MCC score
</p>


<h3>Usage</h3>

<pre><code class='language-R'>view_mcc_multi(result, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="view_mcc_multi_+3A_result">result</code></td>
<td>
<p>is the result from <code>find_optimised_snps</code></p>
</td></tr>
<tr><td><code id="view_mcc_multi_+3A_...">...</code></td>
<td>
<p>other optional parameters</p>
</td></tr>
</table>


<h3>Value</h3>

<p>formatted result list to be saved or presented.
</p>

<hr>
<h2 id='view_percent'><code>view_percent</code></h2><span id='topic+view_percent'></span>

<h3>Description</h3>

<p><code>view_percent</code> is used to present the result of selected
SNPs set based on Simpson's Index.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>view_percent(result, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="view_percent_+3A_result">result</code></td>
<td>
<p>is the result from <code>find_optimised_snps</code></p>
</td></tr>
<tr><td><code id="view_percent_+3A_...">...</code></td>
<td>
<p>other optional parameters</p>
</td></tr>
</table>


<h3>Value</h3>

<p>formatted result list to be saved or presented.
</p>

<hr>
<h2 id='view_simpson'><code>view_simpson</code></h2><span id='topic+view_simpson'></span>

<h3>Description</h3>

<p><code>view_simpson</code> is used to present the result of selected
SNPs set based on Simpson's Index.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>view_simpson(result, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="view_simpson_+3A_result">result</code></td>
<td>
<p>is the result from <code>find_optimised_snps</code></p>
</td></tr>
<tr><td><code id="view_simpson_+3A_...">...</code></td>
<td>
<p>other optional parameters</p>
</td></tr>
</table>


<h3>Value</h3>

<p>formatted result list to be saved or presented.
</p>

<hr>
<h2 id='write_fasta'><code>write_fasta</code></h2><span id='topic+write_fasta'></span>

<h3>Description</h3>

<p><code>write_fasta</code> is used to write
the named character vectors to fasta file.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>write_fasta(seqc, filename)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="write_fasta_+3A_seqc">seqc</code></td>
<td>
<p>a list containing list of nucleotides. To keep it simple,
use provided read_fasta to import the fasta file.</p>
</td></tr>
<tr><td><code id="write_fasta_+3A_filename">filename</code></td>
<td>
<p>filename of the output file</p>
</td></tr>
</table>


<h3>Value</h3>

<p>will write the alignments to file
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
