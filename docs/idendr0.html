<!DOCTYPE html><html><head><title>Help for package idendr0</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {idendr0}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#idendr0-package'><p>Interactive Dendrograms</p></a></li>
<li><a href='#clusterId2SegmentIds'><p>clusterId2SegmentIds</p></a></li>
<li><a href='#computeLeafColorIdxs'><p>computeLeafColorIdxs</p></a></li>
<li><a href='#computeLeafOrder'><p>computeLeafOrder</p></a></li>
<li><a href='#computeMemberIndices'><p>computeMemberIndices</p></a></li>
<li><a href='#computeSubclusterIndices'><p>computeSubclusterIndices</p></a></li>
<li><a href='#createClustersFromLeafColors'><p>createClustersFromLeafColors</p></a></li>
<li><a href='#cutDendro'><p>cutDendro</p></a></li>
<li><a href='#dendro2fig'><p>dendro2fig</p></a></li>
<li><a href='#fig2dendro'><p>fig2dendro</p></a></li>
<li><a href='#fig2heatmap'><p>fig2heatmap</p></a></li>
<li><a href='#gw2xy'><p>gw2xy</p></a></li>
<li><a href='#hca5000'>
<p>idendro demo data</p></a></li>
<li><a href='#heatmap2fig'><p>heatmap2fig</p></a></li>
<li><a href='#idendro'><p>Interactive Dendrogram</p></a></li>
<li><a href='#mySeq'><p>mySeq</p></a></li>
<li><a href='#popDendroZoomHistory'><p>popDendroZoomHistory</p></a></li>
<li><a href='#popSelectionHistory'><p>popSelectionHistory</p></a></li>
<li><a href='#prepareDendro'><p>prepareDendro</p></a></li>
<li><a href='#printVar'><p>printVar</p></a></li>
<li><a href='#pushDendroZoomHistory'><p>pushDendroZoomHistory</p></a></li>
<li><a href='#pushSelectionHistory'><p>pushSelectionHistory</p></a></li>
<li><a href='#selectCluster'><p>selectCluster</p></a></li>
<li><a href='#smoothHeatmap'><p>smoothHeatmap</p></a></li>
<li><a href='#smoothHeatmapAccordingToClusters'><p>smoothHeatmapAccordingToClusters</p></a></li>
<li><a href='#unselectAllClusters'><p>unselectAllClusters</p></a></li>
<li><a href='#unselectCurrentCluster'><p>unselectCurrentCluster</p></a></li>
<li><a href='#xy2gw'><p>xy2gw</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Interactive Dendrograms</td>
</tr>
<tr>
<td>Version:</td>
<td>1.5.3</td>
</tr>
<tr>
<td>Date:</td>
<td>2017-02-22</td>
</tr>
<tr>
<td>Author:</td>
<td>Tomas Sieger</td>
</tr>
<tr>
<td>Imports:</td>
<td>tcltk, tkrplot, grDevices, graphics, stats</td>
</tr>
<tr>
<td>Suggests:</td>
<td>rggobi, DendSer, cluster, RColorBrewer, datasets</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="http://github.com/tsieger/idendr0">http://github.com/tsieger/idendr0</a></td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Tomas Sieger &lt;tomas.sieger@seznam.cz&gt;</td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/tsieger/idendr0/issues">https://github.com/tsieger/idendr0/issues</a></td>
</tr>
<tr>
<td>Description:</td>
<td>Interactive dendrogram that enables the user to select and
    color clusters, to zoom and pan the dendrogram, and to visualize
    the clustered data not only in a built-in heat map, but also in
    'GGobi' interactive plots and user-supplied plots. 
    This is a backport of Qt-based 'idendro' 
    (<a href="https://github.com/tsieger/idendro">https://github.com/tsieger/idendro</a>) to base R graphics and 
    Tcl/Tk GUI.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a></td>
</tr>
<tr>
<td>LazyLoad:</td>
<td>yes</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2017-02-22 12:09:45 UTC; sieger</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2017-02-22 14:13:11</td>
</tr>
</table>
<hr>
<h2 id='idendr0-package'>Interactive Dendrograms</h2><span id='topic+idendr0-package'></span><span id='topic+idendr0'></span>

<h3>Description</h3>

<p>Interactive dendrogram that enables the user to select and
color clusters, to zoom and pan the dendrogram, and to visualize
the clustered data not only in a built-in heat map, but also in
'GGobi' interactive plots and user-supplied plots.
This is a backport of Qt-based 'idendro'
(&lt;https://github.com/tsieger/idendro&gt;) to base R graphics and Tcl/Tk GUI.</p>


<h3>Details</h3>


<table>
<tr>
 <td style="text-align: left;">Package: </td><td style="text-align: left;"> idendr0</td>
</tr>
<tr>
 <td style="text-align: left;">
Type: </td><td style="text-align: left;"> Package</td>
</tr>
<tr>
 <td style="text-align: left;">
Title: </td><td style="text-align: left;"> Interactive Dendrograms</td>
</tr>
<tr>
 <td style="text-align: left;">
Version: </td><td style="text-align: left;"> 1.5.3</td>
</tr>
<tr>
 <td style="text-align: left;">
Date: </td><td style="text-align: left;"> 2017-02-22</td>
</tr>
<tr>
 <td style="text-align: left;">
Author: </td><td style="text-align: left;"> Tomas Sieger</td>
</tr>
<tr>
 <td style="text-align: left;">
Depends: </td><td style="text-align: left;"> </td>
</tr>
<tr>
 <td style="text-align: left;">
Imports: </td><td style="text-align: left;"> tcltk, tkrplot, grDevices, graphics, stats</td>
</tr>
<tr>
 <td style="text-align: left;">
Suggests: </td><td style="text-align: left;"> rggobi, DendSer, cluster, RColorBrewer, datasets</td>
</tr>
<tr>
 <td style="text-align: left;">
URL: </td><td style="text-align: left;"> http://github.com/tsieger/idendr0</td>
</tr>
<tr>
 <td style="text-align: left;">
Maintainer: </td><td style="text-align: left;"> Tomas Sieger &lt;tomas.sieger@seznam.cz&gt;</td>
</tr>
<tr>
 <td style="text-align: left;">
BugReports: </td><td style="text-align: left;"> https://github.com/tsieger/idendr0/issues</td>
</tr>
<tr>
 <td style="text-align: left;">
License: </td><td style="text-align: left;"> GPL-2</td>
</tr>
<tr>
 <td style="text-align: left;">
LazyLoad: </td><td style="text-align: left;"> yes</td>
</tr>
<tr>
 <td style="text-align: left;">
LazyData: </td><td style="text-align: left;"> true</td>
</tr>

</table>



<h3>Author(s)</h3>

<p>Tomas Sieger</p>


<h3>References</h3>

<p>Sieger, T.,  Hurley, C. B., Fiser, K., Beleites, C. (2017)
Interactive Dendrograms: The R Packages idendro and idendr0.
<em>Journal of Statistical Software</em>, <b>76</b>(10), 1&ndash;22.
doi:10.18637/jss.v076.i10
</p>

<hr>
<h2 id='clusterId2SegmentIds'>clusterId2SegmentIds</h2><span id='topic+clusterId2SegmentIds'></span>

<h3>Description</h3>

<p>Convert cluster IDs to indices of dendrogram segments.</p>


<h3>Usage</h3>

<pre><code class='language-R'>clusterId2SegmentIds(ids)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="clusterId2SegmentIds_+3A_ids">ids</code></td>
<td>
<p>cluster IDs</p>
</td></tr>
</table>


<h3>Value</h3>

<p>segment IDs</p>


<h3>Author(s)</h3>

<p>Tomas Sieger</p>

<hr>
<h2 id='computeLeafColorIdxs'>computeLeafColorIdxs</h2><span id='topic+computeLeafColorIdxs'></span>

<h3>Description</h3>

<p>Compute colors of all leafs in dendrogram according to the current
cluster selection.</p>


<h3>Usage</h3>

<pre><code class='language-R'>computeLeafColorIdxs(df)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="computeLeafColorIdxs_+3A_df">df</code></td>
<td>
<p>dhared data frame, see 'prepareDendro'</p>
</td></tr>
</table>


<h3>Value</h3>

<p>leaf colors</p>


<h3>Author(s)</h3>

<p>Tomas Sieger</p>

<hr>
<h2 id='computeLeafOrder'>computeLeafOrder</h2><span id='topic+computeLeafOrder'></span>

<h3>Description</h3>

<p>Compute the assignment of dendrogram leafs to the original
observations.</p>


<h3>Usage</h3>

<pre><code class='language-R'>computeLeafOrder(merging, dbg = 0)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="computeLeafOrder_+3A_merging">merging</code></td>
<td>
<p>(n-1) by 2 matrix describing HCA merging, usually the
'merge' component of the return value from 'hclust'</p>
</td></tr>
<tr><td><code id="computeLeafOrder_+3A_dbg">dbg</code></td>
<td>
<p>debug verbosity level</p>
</td></tr>
</table>


<h3>Value</h3>

<p>leaf ordering</p>


<h3>Author(s)</h3>

<p>Tomas Sieger</p>

<hr>
<h2 id='computeMemberIndices'>computeMemberIndices</h2><span id='topic+computeMemberIndices'></span>

<h3>Description</h3>

<p>Compute indices of observations forming given cluster.</p>


<h3>Usage</h3>

<pre><code class='language-R'>computeMemberIndices(h, clusterIdx)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="computeMemberIndices_+3A_h">h</code></td>
<td>
<p>HCA result, usually 'hclust' return value</p>
</td></tr>
<tr><td><code id="computeMemberIndices_+3A_clusteridx">clusterIdx</code></td>
<td>
<p>cluster index</p>
</td></tr>
</table>


<h3>Value</h3>

<p>indices of observations forming cluster 'clusterIdx'</p>


<h3>Author(s)</h3>

<p>Tomas Sieger</p>

<hr>
<h2 id='computeSubclusterIndices'>computeSubclusterIndices</h2><span id='topic+computeSubclusterIndices'></span>

<h3>Description</h3>

<p>Compute indices of all subclusters (even deep down the hierarchy)
appearing in given cluster.</p>


<h3>Usage</h3>

<pre><code class='language-R'>computeSubclusterIndices(h, clusterIdx)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="computeSubclusterIndices_+3A_h">h</code></td>
<td>
<p>HCA result, usually 'hclust' return value</p>
</td></tr>
<tr><td><code id="computeSubclusterIndices_+3A_clusteridx">clusterIdx</code></td>
<td>
<p>cluster index</p>
</td></tr>
</table>


<h3>Value</h3>

<p>subclusters indices</p>


<h3>Author(s)</h3>

<p>Tomas Sieger</p>

<hr>
<h2 id='createClustersFromLeafColors'>createClustersFromLeafColors</h2><span id='topic+createClustersFromLeafColors'></span>

<h3>Description</h3>

<p>Initialize clusters (i.e. cluster selection) from leaf colors (i.e.
assignment of some observations to some clusters)</p>


<h3>Usage</h3>

<pre><code class='language-R'>createClustersFromLeafColors(df, leafColors, maxClusterCount, 
    dbg = 0)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="createClustersFromLeafColors_+3A_df">df</code></td>
<td>
<p>shared data frame, see 'prepareDendro'</p>
</td></tr>
<tr><td><code id="createClustersFromLeafColors_+3A_leafcolors">leafColors</code></td>
<td>
<p>leaf color indices, i.e. a nonnegative number
assigned to each observation. 0 means given observation is not
member of any cluster, a value i&gt;0 means given observation is a
member of cluster 'i'.</p>
</td></tr>
<tr><td><code id="createClustersFromLeafColors_+3A_maxclustercount">maxClusterCount</code></td>
<td>
<p>max cluster count</p>
</td></tr>
<tr><td><code id="createClustersFromLeafColors_+3A_dbg">dbg</code></td>
<td>
<p>debug verbosity level</p>
</td></tr>
</table>


<h3>Value</h3>

<p>shared data frame 'df' with cluster selection based on 'leafColors'</p>


<h3>Author(s)</h3>

<p>Tomas Sieger</p>

<hr>
<h2 id='cutDendro'>cutDendro</h2><span id='topic+cutDendro'></span>

<h3>Description</h3>

<p>Select clusters by cutting the current zoom of the dendrogram at a
specified height.</p>


<h3>Usage</h3>

<pre><code class='language-R'>cutDendro(df, cutG, dendroZoom, dbg = FALSE)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cutDendro_+3A_df">df</code></td>
<td>
<p>shared data frame</p>
</td></tr>
<tr><td><code id="cutDendro_+3A_cutg">cutG</code></td>
<td>
<p>cutting grow height</p>
</td></tr>
<tr><td><code id="cutDendro_+3A_dendrozoom">dendroZoom</code></td>
<td>
<p>current dendro zoom region</p>
</td></tr>
<tr><td><code id="cutDendro_+3A_dbg">dbg</code></td>
<td>
<p>debug level</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of shared data frame 'df' with new cluster selection,
and the number of clusters selected.</p>


<h3>Author(s)</h3>

<p>Tomas Sieger</p>

<hr>
<h2 id='dendro2fig'>dendro2fig</h2><span id='topic+dendro2fig'></span>

<h3>Description</h3>

<p>Dendrogram -&gt; figure coords conversion.</p>


<h3>Usage</h3>

<pre><code class='language-R'>dendro2fig(gw)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dendro2fig_+3A_gw">gw</code></td>
<td>
<p>a list of 'g' and 'w' components, g=gw[1]: dendro height ... 0,
w=gw[2]: n ... 1 (charm to strange)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>converted values, a list of 'g' and 'w' components</p>


<h3>Author(s)</h3>

<p>Tomas Sieger</p>

<hr>
<h2 id='fig2dendro'>fig2dendro</h2><span id='topic+fig2dendro'></span>

<h3>Description</h3>

<p>Fig -&gt; dendro coord conversion.</p>


<h3>Usage</h3>

<pre><code class='language-R'>fig2dendro(gw)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fig2dendro_+3A_gw">gw</code></td>
<td>
<p>##&lt;&lt; a list of 'g' and 'w' components</p>
</td></tr>
</table>


<h3>Value</h3>

<p>converted values, a list of 'g' and 'w' components</p>


<h3>Author(s)</h3>

<p>Tomas Sieger</p>

<hr>
<h2 id='fig2heatmap'>fig2heatmap</h2><span id='topic+fig2heatmap'></span>

<h3>Description</h3>

<p>Figure -&gt; heatmap coord conversion.</p>


<h3>Usage</h3>

<pre><code class='language-R'>fig2heatmap(gw)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fig2heatmap_+3A_gw">gw</code></td>
<td>
<p>a list of 'g' and 'w' components</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list of 'g' and 'w' components</p>


<h3>Author(s)</h3>

<p>Tomas Sieger</p>

<hr>
<h2 id='gw2xy'>gw2xy</h2><span id='topic+gw2xy'></span>

<h3>Description</h3>

<p>Logical grow/width to physical x/y coord conversion.</p>


<h3>Usage</h3>

<pre><code class='language-R'>gw2xy(gw)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gw2xy_+3A_gw">gw</code></td>
<td>
<p>a list of 'g' and 'w' components</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list of 'x' and 'y' components</p>


<h3>Author(s)</h3>

<p>Tomas Sieger</p>

<hr>
<h2 id='hca5000'>
idendro demo data
</h2><span id='topic+hca5000'></span>

<h3>Description</h3>

<p>Hierarchical cluster analysis demonstration data consisting of raw
data (5000 observations having 3 features measured) and clustered data
(as computed by &lsquo;hclust&rsquo;).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(hca5000)
</code></pre>


<h3>Format</h3>

<p>A list of 'x' and 'hx' elements.
'x' is a matrix of 5000 rows (observations) by 3 columns (dimensions).
'hx' is an object of class 'hclust' containing the result of
hierarchical cluster analysis performed on 'x'.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if (interactive()) {
    library(idendr0)
    data(hca5000)
    idendro(hca5000$hx, hca5000$x, observationAnnotationEnabled = FALSE)
}
</code></pre>

<hr>
<h2 id='heatmap2fig'>heatmap2fig</h2><span id='topic+heatmap2fig'></span>

<h3>Description</h3>

<p>Heatmap -&gt; figure coord conversion.</p>


<h3>Usage</h3>

<pre><code class='language-R'>heatmap2fig(gw)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="heatmap2fig_+3A_gw">gw</code></td>
<td>
<p>a list of 'g' and 'w' components</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list of 'g' and 'w' components</p>


<h3>Author(s)</h3>

<p>Tomas Sieger</p>

<hr>
<h2 id='idendro'>Interactive Dendrogram</h2><span id='topic+idendro'></span>

<h3>Description</h3>

<p>'idendro' is a plot enabling users to visualize a dendrogram and
inspect it interactively: to select and color clusters anywhere in
the dendrogram, to zoom and pan the dendrogram, and to visualize
the clustered data not only in a built-in heat map, but also in any
interactive plot implemented in GGobi (as available using the
'rggobi' package). The integration with GGobi (enabled using the
'ggobi' argument), but also with the user's code is implemented in
terms of two callbacks (see the 'colorizeCallback' and
'fetchSelectedCallback' arguments).
'idendro' can be used to inspect quite large dendrograms (tens
of thousands of observations, at least).
</p>
<p>The 'idendr0' package is a lightweight backport of the 'idendro'
package. While the 'idendro' package depends on libraries not
easily available on some platforms (e.g. Windows), the 'idendr0'
package is based on platform-independent Tcl/Tk graphic widget
toolkit, and thus made widely available. However, the 'idendro'
package should be preferred, if available, for its better
interactivity and performance.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>idendro(h, x = NULL, qx = NULL, clusters = NULL, hscale = 1.5, 
    vscale = 1.5, silent = FALSE, zoomFactor = 1/240, 
    observationAnnotationEnabled = TRUE, 
    clusterColors = c("red", "green", "blue", "yellow", "magenta", 
        "cyan", "darkred", "darkgreen", "purple", "darkcyan"), 
    unselectedClusterColor = "black", maxClusterCount = max(length(clusterColors), 
        ifelse(!is.null(clusters), max(clusters), 0)), heatmapEnabled = TRUE, 
    heatmapSmoothing = c("none", "cluster", "zoom"), 
    heatmapColors = colorRampPalette(c("#00007F", "blue", "#007FFF", "cyan", 
        "#7FFF7F", "yellow", "#FF7F00", "red", "#7F0000"))(10), 
    doScaleHeatmap = TRUE, doScaleHeatmapByRows = FALSE, 
    heatmapRelSize = 0.2, colorizeCallback = NULL, fetchSelectedCallback = NULL, 
    brushedmapEnabled = !is.null(fetchSelectedCallback), 
    brushedmapRelSize = ifelse(!is.null(x), heatmapRelSize/ncol(x), 0.05), 
    geometry = NULL, ggobi = FALSE, ggobiGlyphType = 1, ggobiGlyphSize = 1, 
    ggobiFetchingStyle = "selected", ggobiColorScheme = "Paired 12", dbg = 0, ...)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="idendro_+3A_h">h</code></td>
<td>
<p>object of class 'stats::hclust' (or other class
convertible to class 'hclust' by the 'as.hclust' function)
describing a hierarchical clustering.
If _inversions_ in heights (see 'hclust') is detected,
the heights get fixed in a simple naive way by preserving
non-negative relative differences in the heights, but changing
negative differences to zero. Using clustering with monotone
distance measure should be considered in that case.</p>
</td></tr>
<tr><td><code id="idendro_+3A_x">x</code></td>
<td>
<p>data frame holding observations tha were clustered
giving rise to 'h'.
The heat map will depict this data. (The heat map can be scaled
- see the 'doScaleHeatmap' and 'doScaleHeatmapByRows' arguments.)
Non-numeric types will get converted to numeric using 'as.numeric'.
This parameter is optional.</p>
</td></tr>
<tr><td><code id="idendro_+3A_qx">qx</code></td>
<td>
<p>(unused, appears for compatibility with
idendro::idendro).</p>
</td></tr>
<tr><td><code id="idendro_+3A_clusters">clusters</code></td>
<td>
<p>the assignment of observations to clusters to start
with, typically the value of a previous call to 'idendro'.
A numeric vector of length of the number of observations is
expected, in which 0s denote unselected observations, and values
of i &gt; 0 mark members of the cluster &lsquo;i&rsquo;.</p>
</td></tr>
<tr><td><code id="idendro_+3A_hscale">hscale</code></td>
<td>
<p>horizontal scaling factor of the dendrogram
figure. As the dendrogram is implemented as a Tcl/Tk image, and
rtcltk does not support image resizing (e.g. on window
maximization), the dendrogram keeps its original size regardless
of the size of its enclosing window. Thus specifying the
hscale of more than 100% is preferred to make the dendrogram
large enough.</p>
</td></tr>
<tr><td><code id="idendro_+3A_vscale">vscale</code></td>
<td>
<p>vertical scaling factor of the dendrogram
figure. See 'hscale'.</p>
</td></tr>
<tr><td><code id="idendro_+3A_silent">silent</code></td>
<td>
<p>if TRUE, no informative messages will be shown</p>
</td></tr>
<tr><td><code id="idendro_+3A_zoomfactor">zoomFactor</code></td>
<td>
<p>the amount of zoom in/out as controlled by the
mouse wheel</p>
</td></tr>
<tr><td><code id="idendro_+3A_observationannotationenabled">observationAnnotationEnabled</code></td>
<td>
<p>shall the names of individual
observations (rownames of 'x') be shown next to the
dendrogram/heat map?</p>
</td></tr>
<tr><td><code id="idendro_+3A_clustercolors">clusterColors</code></td>
<td>
<p>colors
of individual clusters</p>
</td></tr>
<tr><td><code id="idendro_+3A_unselectedclustercolor">unselectedClusterColor</code></td>
<td>
<p>the color of unselected dendrogram
branches</p>
</td></tr>
<tr><td><code id="idendro_+3A_maxclustercount">maxClusterCount</code></td>
<td>
<p>the
maximum number of clusters user can select. If greater than the number
of 'clusterColors', cluster colors will get recycled.
This parameter affects the size of the GUI and the number of
clusters that can be selected automatically by &quot;cutting&quot; the
dendrogram.</p>
</td></tr>
<tr><td><code id="idendro_+3A_heatmapenabled">heatmapEnabled</code></td>
<td>
<p>shall the heat map be drawn?</p>
</td></tr>
<tr><td><code id="idendro_+3A_heatmapsmoothing">heatmapSmoothing</code></td>
<td>
<p>heat map smoothing mode,
one of
'none' - the heat map gets never smoothed, it displays the
features of all the individual observations
'cluster' - the heat map depicts the average features
for the currently selected clusters,
'zoom' - the heat map displays the average feature for each
elementary (i.e. the finest) cluster seen in the
dendrogram currently.</p>
</td></tr>
<tr><td><code id="idendro_+3A_heatmapcolors">heatmapColors</code></td>
<td>
<p>heat map
color palette represented by a list of colors, e.g.
a sequential palette generated by &lsquo;brewer.pal&rsquo;, or
&lsquo;colorRampPalette(.)(.)&rsquo;, &lsquo;gray.colors(.)&rsquo;, or &lsquo;hsv(.)&rsquo;.</p>
</td></tr>
<tr><td><code id="idendro_+3A_doscaleheatmap">doScaleHeatmap</code></td>
<td>
<p>scale each heat map column to the &lt;0,1&gt; range?
(The default is TRUE.)</p>
</td></tr>
<tr><td><code id="idendro_+3A_doscaleheatmapbyrows">doScaleHeatmapByRows</code></td>
<td>
<p>scale heat map rows, not columns
(The default is FALSE.)</p>
</td></tr>
<tr><td><code id="idendro_+3A_heatmaprelsize">heatmapRelSize</code></td>
<td>
<p>relative size of the heat map - the ratio
of the heat map width to the width of the dendrogram, the heat
map, and the brushed map. The default is 20%.</p>
</td></tr>
<tr><td><code id="idendro_+3A_colorizecallback">colorizeCallback</code></td>
<td>
<p>callback function called when cluster
selection changes; the argument is a vector assigning color
indices (0=no color, &gt;0 colors) to individual observations.</p>
</td></tr>
<tr><td><code id="idendro_+3A_fetchselectedcallback">fetchSelectedCallback</code></td>
<td>
<p>callback function used to fetch
observation selection made externally. The callback must return
a boolean vector of length of the number of observations in &lsquo;x&rsquo;.
i-th element in the vector specifies whether given observation
is selected.</p>
</td></tr>
<tr><td><code id="idendro_+3A_brushedmapenabled">brushedmapEnabled</code></td>
<td>
<p>shall
brushed map be drawn? If TRUE, a column vector is drawn next to
dendrogram (and heatmap, if there is one) depicting observation
that were fetched by fetchSelectedCallback. The color of the
observations is the color of the cluster used to fetch
observations into.</p>
</td></tr>
<tr><td><code id="idendro_+3A_brushedmaprelsize">brushedmapRelSize</code></td>
<td>
<p>relative
size of the brushed map - the ratio of the brushed map width to
the width of the dendrogram, the heat map, and the brushed map.
The default is the size of a single column in the heat map, or
5% if there is no heatmap.</p>
</td></tr>
<tr><td><code id="idendro_+3A_geometry">geometry</code></td>
<td>
<p>window geometry (&quot;width x height + xoffset +
yoffset&quot;). Almost useless as the dendrogram does not resize, see
the 'hscale' and 'vscale' arguments instead.</p>
</td></tr>
<tr><td><code id="idendro_+3A_ggobi">ggobi</code></td>
<td>
<p>plot feature space projections of &lsquo;x&rsquo; in ggobi
and bidirectionally integrate with the plot? (defaults to FALSE
as some users may not have ggobi available)</p>
</td></tr>
<tr><td><code id="idendro_+3A_ggobiglyphtype">ggobiGlyphType</code></td>
<td>
<p>ggobi glyph type used to draw observations in
ggobi (defaults to a single pixel; see rggobi::glyph_type)</p>
</td></tr>
<tr><td><code id="idendro_+3A_ggobiglyphsize">ggobiGlyphSize</code></td>
<td>
<p>size of ggobi glyphs (see rggobi::glyph_size)</p>
</td></tr>
<tr><td><code id="idendro_+3A_ggobifetchingstyle">ggobiFetchingStyle</code></td>
<td>
<p>how should we recognize
ggobi-selected observations to be fetched to idendro?
Use 'selected' to fetch observations selected by ggobi brush,
or glyph type number 2-6 to fetch observations selected by ggobi
persistent brushing with a specific glyph type.</p>
</td></tr>
<tr><td><code id="idendro_+3A_ggobicolorscheme">ggobiColorScheme</code></td>
<td>
<p>GGobi color scheme used to
color observations in ggobi plots according to the clusters
selected in the dendrogram</p>
</td></tr>
<tr><td><code id="idendro_+3A_dbg">dbg</code></td>
<td>
<p>debug level (0=none, 1=brief, 2=verbose)</p>
</td></tr>
<tr><td><code id="idendro_+3A_...">...</code></td>
<td>
<p>additional graphical parameters to be passed to the
dendrogram plot.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>'idendro' displays an interactive dendrogram enriched, optionally,
with a heat map and/or a brushed map.
</p>
<p>The dendrogram represents the result of a hierarchical cluster
analysis performed on a set of observations (see e.g. 'hclust').
There is an axis drawn below the dendrogram displaying the &quot;height&quot;
of the clusters in the dendrogram.
</p>
<p>The heat map visualizes the observations living in k-dimensional
feature space by mapping their features onto a color scale and
displaying them as rows of 'k' colored rectangles. By default,
normalization (scaling) of individual features to a common visual
scale is enabled. Scaling of observations is also supported (see the
'doScaleHeatmapByRows' argument).
</p>
<p>The brushed map can indicate which observations are currently
selected in some external plot/tool 'idendro' is integrated
with (e.g. a GGobi scatter plot matrix). Technically speaking,
the current selection must be determined explicitly by clicking the
&quot;fetCh selected&quot; button (or pressing the 'Alt+C' shortcut), which
results in calling the 'fetchSelectedCallback' function (see
arguments).
</p>
<p>The dendrogram can be zoomed and panned. To zoom in a
specific region, right click and drag in the dendrogram.
Mouse wheel can also be used to zoom in and out. To pan a zoomed
dendrogram, middle click and drag the mouse. Zooming and panning
history is available (see 'GUI').
</p>
<p>User can select clusters manually one by one (by clicking
at individual clusters in the dendrogram), or automatically by
&quot;cutting&quot; the dendrogram at a specified height. To cut the
dendrogram, navigate the mouse close to the dendrogram axis
(a dashed line will appear across the dendrogram at a specified
height), and left click. Clusters just beneath the cutting
height will get selected, replacing the clusters currently
selected. Selection history is available (see 'GUI').
</p>
<p><em>Graphic User interface (GUI):</em>
</p>
<p>In the left part of the dendrogram window, there is a simple GUI.
In the top part of the GUI come cluster-specific controls and info
panels arranged in rows. (The number of rows is determined by the
'maxClusterCount' argument.)
In each row, there is the current cluster selector (a radio button
decorated with a cluster ID and a color code (determined by the
'clusterColors' argument)), and cluster-specific statistics: the
total number (and the ratio) of the observations in that specific
cluster out of the total number of observations, and the number
(and the ratio) of the observations in that cluster out of the
observations brushed.
The current cluster determines which color and ID will be
associated with a cluster selected in the dendrogram,
At any time, exactly one cluster is selected as the current
cluster. 
</p>
<p>At the bottom of the GUI window, there are buttons controling
zooming, cluster selection, and heat map smoothing:
</p>
<p>&quot;Undo zoom&quot; - retrieves the previous zoom region from history
</p>
<p>&quot;Full view&quot; - zooms the dendrogram out maximally
</p>
<p>&quot;Undo selection&quot; - retrieves the previous cluster selection from
history
</p>
<p>&quot;Unselect&quot; - unselects the current cluster in the dendrogram
</p>
<p>&quot;Unselect all&quot; - unselects all clusters
</p>
<p>The &quot;heat map smoothing&quot; mode can be set to one of:
</p>
<p>&quot;none&quot; - the heat map gets never smoothed, it displays the
features of all the individual observations
</p>
<p>&quot;cluster&quot; - the heat map displays the average features for the 
currently selected clusters
</p>
<p>&quot;zoom&quot; - the heat map displays the average feature for each
elementary (i.e. the finest) cluster seen in the dendrogram
currently. When the dendrogram is zoomed out maximally,
the features of all the elementary clusters (i.e. the
individual observations) are displayed. When the user zooms in
the dendrogram, such that some clusters get hidden, the
features of the observations forming the hidden clusters get
averaged.
</p>
<p>&quot;Quit&quot;
</p>


<h3>Value</h3>

<p>vector of colors assigned to observations. 0s denote unselected
observations, while values of i &gt; 0 denote the cluster &lsquo;i&rsquo;.</p>


<h3>Author(s)</h3>

<p>Tomas Sieger</p>


<h3>References</h3>

<p>Sieger, T.,  Hurley, C. B., Fiser, K., Beleites, C. (2017)
Interactive Dendrograms: The R Packages idendro and idendr0.
<em>Journal of Statistical Software</em>, <b>76</b>(10), 1&ndash;22.
doi:10.18637/jss.v076.i10
</p>


<h3>See Also</h3>

<p>idendro::idendro, stats::hclust, stats::plot.hclust
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if (interactive()) {
    data(iris, envir = environment())
    hc &lt;- hclust(dist(iris[, 1:4]))
    idendro(hc, iris)
}
# see demos for more examples
</code></pre>

<hr>
<h2 id='mySeq'>mySeq</h2><span id='topic+mySeq'></span>

<h3>Description</h3>

<p>Sequence generation resembling matlab ':' operator.
The difference from R &lsquo;seq&rsquo; is the behaviour in case when
from=2, to=1 and b=1 - in that case R seq raises an error, while
matlab returns an empty sequence.
This function returns an empty sequence as well in this case.</p>


<h3>Usage</h3>

<pre><code class='language-R'>mySeq(from, to, by = 1)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mySeq_+3A_from">from</code></td>
<td>
<p>starting value</p>
</td></tr>
<tr><td><code id="mySeq_+3A_to">to</code></td>
<td>
<p>ending value</p>
</td></tr>
<tr><td><code id="mySeq_+3A_by">by</code></td>
<td>
<p>step (defaults to 1)</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Tomas Sieger</p>

<hr>
<h2 id='popDendroZoomHistory'>popDendroZoomHistory</h2><span id='topic+popDendroZoomHistory'></span>

<h3>Description</h3>

<p>Restore (and discard from history) the last dendro zoom.</p>


<h3>Usage</h3>

<pre><code class='language-R'>popDendroZoomHistory(df, dbg = FALSE)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="popDendroZoomHistory_+3A_df">df</code></td>
<td>
<p>shared data frame</p>
</td></tr>
<tr><td><code id="popDendroZoomHistory_+3A_dbg">dbg</code></td>
<td>
<p>debug flag/level</p>
</td></tr>
</table>


<h3>Value</h3>

<p>dendro zoom popped (or NULL if stack empty)</p>


<h3>Author(s)</h3>

<p>Tomas Sieger</p>

<hr>
<h2 id='popSelectionHistory'>popSelectionHistory</h2><span id='topic+popSelectionHistory'></span>

<h3>Description</h3>

<p>Restore (and discard from history) the last cluster selection.</p>


<h3>Usage</h3>

<pre><code class='language-R'>popSelectionHistory(df, dbg = FALSE)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="popSelectionHistory_+3A_df">df</code></td>
<td>
<p>shared data frame</p>
</td></tr>
<tr><td><code id="popSelectionHistory_+3A_dbg">dbg</code></td>
<td>
<p>debug flag/level</p>
</td></tr>
</table>


<h3>Value</h3>

<p>shared data frame holding cluster selection (or NULL if no
selection found in the selection history)</p>


<h3>Author(s)</h3>

<p>Tomas Sieger</p>

<hr>
<h2 id='prepareDendro'>prepareDendro</h2><span id='topic+prepareDendro'></span>

<h3>Description</h3>

<p>Perform all computations needed to display a dendrogram and
initialize a shared data frame.
</p>
<p>This is an internal function not to be called by the user.</p>


<h3>Usage</h3>

<pre><code class='language-R'>prepareDendro(h, x = NULL, xOrig = NULL, doFlipG = TRUE, dbg = 0)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="prepareDendro_+3A_h">h</code></td>
<td>
<p>an object of class 'stats::hclust' describing a clustering</p>
</td></tr>
<tr><td><code id="prepareDendro_+3A_x">x</code></td>
<td>
<p>a data frame holding observations tha were clustered
giving rise to 'h', converted to numeric, and scaled</p>
</td></tr>
<tr><td><code id="prepareDendro_+3A_xorig">xOrig</code></td>
<td>
<p>a data frame holding observations tha were clustered
giving rise to 'h'</p>
</td></tr>
<tr><td><code id="prepareDendro_+3A_doflipg">doFlipG</code></td>
<td>
<p>should branches' heights (&quot;grow&quot;) be flipped
such that the heights of elementary observations correspond not
to 0, but to the height of the dendrogram?</p>
</td></tr>
<tr><td><code id="prepareDendro_+3A_dbg">dbg</code></td>
<td>
<p>debug verbosity level</p>
</td></tr>
</table>


<h3>Value</h3>

<p>shared data frame</p>


<h3>Author(s)</h3>

<p>Tomas Sieger</p>

<hr>
<h2 id='printVar'>printVar</h2><span id='topic+printVar'></span>

<h3>Description</h3>

<p>Print the name, type and value of a variable.</p>


<h3>Usage</h3>

<pre><code class='language-R'>printVar(x)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="printVar_+3A_x">x</code></td>
<td>
<p>variable to print</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Tomas Sieger</p>

<hr>
<h2 id='pushDendroZoomHistory'>pushDendroZoomHistory</h2><span id='topic+pushDendroZoomHistory'></span>

<h3>Description</h3>

<p>Save the current dendroZoom (as stored in '.sharedEnv').</p>


<h3>Usage</h3>

<pre><code class='language-R'>pushDendroZoomHistory(df, dendroZoom, dbg = FALSE)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pushDendroZoomHistory_+3A_df">df</code></td>
<td>
<p>shared data frame</p>
</td></tr>
<tr><td><code id="pushDendroZoomHistory_+3A_dendrozoom">dendroZoom</code></td>
<td>
<p>dendro zoom to push</p>
</td></tr>
<tr><td><code id="pushDendroZoomHistory_+3A_dbg">dbg</code></td>
<td>
<p>debug flag/level</p>
</td></tr>
</table>


<h3>Value</h3>

<p>shared data frame with dendro zoom pushed on top of the
dendro zoom stack</p>


<h3>Author(s)</h3>

<p>Tomas Sieger</p>

<hr>
<h2 id='pushSelectionHistory'>pushSelectionHistory</h2><span id='topic+pushSelectionHistory'></span>

<h3>Description</h3>

<p>Save the current cluster selection (as stored in df).</p>


<h3>Usage</h3>

<pre><code class='language-R'>pushSelectionHistory(df, dbg = FALSE)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pushSelectionHistory_+3A_df">df</code></td>
<td>
<p>shared data frame</p>
</td></tr>
<tr><td><code id="pushSelectionHistory_+3A_dbg">dbg</code></td>
<td>
<p>debug flag/level</p>
</td></tr>
</table>


<h3>Value</h3>

<p>shared data frame with cluster selection pushed on top of the
selection stack.</p>


<h3>Author(s)</h3>

<p>Tomas Sieger</p>

<hr>
<h2 id='selectCluster'>selectCluster</h2><span id='topic+selectCluster'></span>

<h3>Description</h3>

<p>Select the nearest cluster to the position 'pos'.</p>


<h3>Usage</h3>

<pre><code class='language-R'>selectCluster(pos, df, dendroZoom, dbg = FALSE)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="selectCluster_+3A_pos">pos</code></td>
<td>
<p>(x,y) position in the dendro figure</p>
</td></tr>
<tr><td><code id="selectCluster_+3A_df">df</code></td>
<td>
<p>shared data frame</p>
</td></tr>
<tr><td><code id="selectCluster_+3A_dendrozoom">dendroZoom</code></td>
<td>
<p>the current dendro zoom region (used to determine
the scaling)</p>
</td></tr>
<tr><td><code id="selectCluster_+3A_dbg">dbg</code></td>
<td>
<p>debug flag/level</p>
</td></tr>
</table>


<h3>Value</h3>

<p>shared data frame</p>


<h3>Author(s)</h3>

<p>Tomas Sieger</p>

<hr>
<h2 id='smoothHeatmap'>smoothHeatmap</h2><span id='topic+smoothHeatmap'></span>

<h3>Description</h3>

<p>Smooth heatmap by averaging data over observations in clusters.</p>


<h3>Usage</h3>

<pre><code class='language-R'>smoothHeatmap(x, ch, dbg.heatmap = 0)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="smoothHeatmap_+3A_x">x</code></td>
<td>
<p>a data frame holding observations tha were clustered</p>
</td></tr>
<tr><td><code id="smoothHeatmap_+3A_ch">ch</code></td>
<td>
<p>number of clusters specifying the amount of smoothing:
observations in clusters will get smoothed together, the value
of 'n' specifies no smoothing while the value of 1 would lead
to maximal smoothing</p>
</td></tr>
<tr><td><code id="smoothHeatmap_+3A_dbg.heatmap">dbg.heatmap</code></td>
<td>
<p>debug verbosity level</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a data frame holding smoothed observations</p>


<h3>Author(s)</h3>

<p>Tomas Sieger</p>

<hr>
<h2 id='smoothHeatmapAccordingToClusters'>smoothHeatmapAccordingToClusters</h2><span id='topic+smoothHeatmapAccordingToClusters'></span>

<h3>Description</h3>

<p>Smooth heatmap by averaging the observations associated with the
currently selected clusters. Observations that are not contained
in any cluster currently selected stay untouched.</p>


<h3>Usage</h3>

<pre><code class='language-R'>smoothHeatmapAccordingToClusters(df, dbg.heatmap.smooth = 0)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="smoothHeatmapAccordingToClusters_+3A_df">df</code></td>
<td>
<p>shared data frame</p>
</td></tr>
<tr><td><code id="smoothHeatmapAccordingToClusters_+3A_dbg.heatmap.smooth">dbg.heatmap.smooth</code></td>
<td>
<p>debug verbosity level</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Tomas Sieger</p>

<hr>
<h2 id='unselectAllClusters'>unselectAllClusters</h2><span id='topic+unselectAllClusters'></span>

<h3>Description</h3>

<p>Unselect all clusters.</p>


<h3>Usage</h3>

<pre><code class='language-R'>unselectAllClusters(df, dbg)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="unselectAllClusters_+3A_df">df</code></td>
<td>
<p>shared data frame</p>
</td></tr>
<tr><td><code id="unselectAllClusters_+3A_dbg">dbg</code></td>
<td>
<p>debug flag/level</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list of a shared data frame 'df' and a boolean flag
'selectionChanged' determing if cluster selection has changed
(so the caller can learn whether to redraw clusters).</p>


<h3>Author(s)</h3>

<p>Tomas Sieger</p>

<hr>
<h2 id='unselectCurrentCluster'>unselectCurrentCluster</h2><span id='topic+unselectCurrentCluster'></span>

<h3>Description</h3>

<p>Unselect the current cluster.</p>


<h3>Usage</h3>

<pre><code class='language-R'>unselectCurrentCluster(df, dbg = FALSE)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="unselectCurrentCluster_+3A_df">df</code></td>
<td>
<p>shared data frame</p>
</td></tr>
<tr><td><code id="unselectCurrentCluster_+3A_dbg">dbg</code></td>
<td>
<p>debug flag/level</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list of shared data frame 'df' and a boolean flag
'selectionChanged' determing if clsuter selection has changed
(so the caller can learn whether to redraw clusters).</p>


<h3>Author(s)</h3>

<p>Tomas Sieger</p>

<hr>
<h2 id='xy2gw'>xy2gw</h2><span id='topic+xy2gw'></span>

<h3>Description</h3>

<p>Physical x/y to logical grow/width coord conversion.</p>


<h3>Usage</h3>

<pre><code class='language-R'>xy2gw(xy)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="xy2gw_+3A_xy">xy</code></td>
<td>
<p>a list of 'x' and 'y' components</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list of 'g' and 'w' components</p>


<h3>Author(s)</h3>

<p>Tomas Sieger</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
