<!DOCTYPE html><html><head><title>Help for package supclust</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {supclust}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#back.search'><p>Internal functions for Supervised Grouping</p></a></li>
<li><a href='#coef.pelora'><p>Extract the Model Coefficients of Pelora</p></a></li>
<li><a href='#dlda'><p>Classification with Wilma's Clusters</p></a></li>
<li><a href='#fitted.pelora'><p>Extract the Fitted Values of Pelora</p></a></li>
<li><a href='#fitted.wilma'><p>Extract the Fitted Values of Wilma</p></a></li>
<li><a href='#leukemia'><p>A part of the Golub's famous AML/ALL-leukemia dataset</p></a></li>
<li><a href='#margin'><p>Classification Margin Between Two Sample Classes</p></a></li>
<li><a href='#pelora'><p>Supervised Grouping of Predictor Variables</p></a></li>
<li><a href='#plot.pelora'><p>2-Dimensional Visualization of Pelora's Output</p></a></li>
<li><a href='#plot.wilma'><p>2-Dimensional Visualization of Wilma's Output</p></a></li>
<li><a href='#predict.pelora'><p>Predict Method for Pelora</p></a></li>
<li><a href='#predict.wilma'><p>Predict Method for Wilma</p></a></li>
<li><a href='#print.pelora'><p>Print Method for Pelora Objects</p></a></li>
<li><a href='#print.wilma'><p>Print Method for Wilma Objects</p></a></li>
<li><a href='#score'><p>Wilcoxon Score for Binary Problems</p></a></li>
<li><a href='#sign.change'><p>Sign-flipping of Predictor Variables to Obtain Equal Polarity</p></a></li>
<li><a href='#sign.flip'><p>Sign-flipping of Predictor Variables to Obtain Equal Polarity</p></a></li>
<li><a href='#standardize.genes'><p>Standardization of Predictor Variables</p></a></li>
<li><a href='#summary.pelora'><p>Summary Method for Pelora Objects</p></a></li>
<li><a href='#summary.wilma'><p>Summary Method for Wilma Objects</p></a></li>
<li><a href='#wilma'><p>Supervised Clustering of Predictor Variables</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Title:</td>
<td>Supervised Clustering of Predictor Variables Such as Genes</td>
</tr>
<tr>
<td>Version:</td>
<td>1.1-1</td>
</tr>
<tr>
<td>Date:</td>
<td>2021-09-25</td>
</tr>
<tr>
<td>Description:</td>
<td>Methodology for supervised grouping aka "clustering" of
   potentially many predictor variables, such as genes etc, implementing
   algorithms 'PELORA' and 'WILMA'.</td>
</tr>
<tr>
<td>Imports:</td>
<td>graphics, stats, rpart, class</td>
</tr>
<tr>
<td>Author:</td>
<td>Marcel Dettling &lt;marcel.dettling@zhaw.ch&gt; and Martin Maechler</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Martin Maechler &lt;maechler@stat.math.ethz.ch&gt;</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/mmaechler/supclust">https://github.com/mmaechler/supclust</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2021-09-25 17:14:48 UTC; maechler</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2021-09-27 12:40:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='back.search'>Internal functions for Supervised Grouping</h2><span id='topic+back.search'></span><span id='topic+p.1clust'></span><span id='topic+printClist'></span><span id='topic+ridge.coef'></span>

<h3>Description</h3>

<p>These are not to be called by the user.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+pelora">pelora</a></code> and <code><a href="#topic+wilma">wilma</a></code></p>

<hr>
<h2 id='coef.pelora'>Extract the Model Coefficients of Pelora</h2><span id='topic+coef.pelora'></span>

<h3>Description</h3>

<p>Yields the coefficients of the penalized logistic
regression model that is fitted by <code>pelora</code> with its groups of
predictor variables (genes) as input</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'pelora'
coef(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="coef.pelora_+3A_object">object</code></td>
<td>
<p>an <span class="rlang"><b>R</b></span> object of <code><a href="base.html#topic+class">class</a></code> <code>"pelora"</code>,
typically the result of <code><a href="#topic+pelora">pelora</a>()</code>.</p>
</td></tr>
<tr><td><code id="coef.pelora_+3A_...">...</code></td>
<td>
<p>further arguments passed to and from methods.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A numeric vector of length <code class="reqn">\code{noc}+1</code>, giving the
penalized logistic regression coefficients for the intercept and the
<code>noc</code> groups and/or single variables identified by <code>pelora</code>.</p>


<h3>Author(s)</h3>

<p>Marcel Dettling, <a href="mailto:dettling@stat.math.ethz.ch">dettling@stat.math.ethz.ch</a></p>


<h3>See Also</h3>

<p><code><a href="#topic+pelora">pelora</a></code>, also for references.</p>


<h3>Examples</h3>

<pre><code class='language-R'> ## Running the examples of Pelora's help page
 example(pelora, echo = FALSE)
 coef(fit)
</code></pre>

<hr>
<h2 id='dlda'>Classification with Wilma's Clusters</h2><span id='topic+dlda'></span><span id='topic+nnr'></span><span id='topic+logreg'></span><span id='topic+aggtrees'></span>

<h3>Description</h3>

<p>The four functions <code>nnr</code> (nearest neighbor rule),
<code>dlda</code> (diagonal linear discriminant analysis), <code>logreg</code>
(logistic regression) and <code>aggtrees</code> (aggregated trees) are used
for binary classification with the cluster representatives of Wilma's
output.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dlda    (xlearn, xtest, ylearn)
nnr     (xlearn, xtest, ylearn)
logreg  (xlearn, xtest, ylearn)
aggtrees(xlearn, xtest, ylearn)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dlda_+3A_xlearn">xlearn</code></td>
<td>
<p>Numeric matrix of explanatory variables (<code class="reqn">q</code>
variables in columns, <code class="reqn">n</code> cases in rows), containing the learning
or training data. Typically, these are the (gene) cluster
representatives of Wilma's output.</p>
</td></tr>
<tr><td><code id="dlda_+3A_xtest">xtest</code></td>
<td>
<p>A numeric matrix of explanatory variables (<code class="reqn">q</code>
variables in columns, <code class="reqn">m</code> cases in rows), containing the test or
validation data. Typically, these are the fitted (gene) cluster
representatives of Wilma's output for the training data, obtained
from <code>predict.wilma</code>.</p>
</td></tr>
<tr><td><code id="dlda_+3A_ylearn">ylearn</code></td>
<td>
<p>Numeric vector of length <code class="reqn">n</code> containing the class labels
for the training observations. These labels have to be coded by 0 and 1.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>nnr</code> implements the 1-nearest-neighbor-rule with
Euclidean distance function. <code>dlda</code> is linear discriminant
analysis, using the restriction that the covariance matrix is diagonal
with equal variance for all predictors. <code>logreg</code> is default
logistic regression. <code>aggtrees</code> fits a default stump (a
classification tree with two terminal nodes) by <code>rpart</code> for every
predictor variable and uses majority voting to determine the final
classifier.
</p>


<h3>Value</h3>

<p>Numeric vector of length <code class="reqn">m</code>, containing the predicted class
labels for the test observations. The class labels are coded by 0 and
1.</p>


<h3>Author(s)</h3>

<p>Marcel Dettling</p>


<h3>References</h3>

<p>see those in <code><a href="#topic+wilma">wilma</a></code>.</p>


<h3>See Also</h3>

<p><code><a href="#topic+wilma">wilma</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>## Generating random learning data: 20 observations and 10 variables (clusters)
set.seed(342)
xlearn &lt;- matrix(rnorm(200), nrow = 20, ncol = 10)

## Generating random test data: 8 observations and 10 variables(clusters)
xtest  &lt;- matrix(rnorm(80),  nrow = 8,  ncol = 10)

## Generating random class labels for the learning data
ylearn &lt;- as.numeric(runif(20)&gt;0.5)

## Predicting the class labels for the test data
nnr(xlearn, xtest, ylearn)
dlda(xlearn, xtest, ylearn)
logreg(xlearn, xtest, ylearn)
aggtrees(xlearn, xtest, ylearn)
</code></pre>

<hr>
<h2 id='fitted.pelora'>Extract the Fitted Values of Pelora</h2><span id='topic+fitted.pelora'></span>

<h3>Description</h3>

<p>Yields the fitted values, i.e., the centroids of the (gene)
groups that have been identified by <code><a href="#topic+pelora">pelora</a></code>.</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'pelora'
fitted(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fitted.pelora_+3A_object">object</code></td>
<td>
<p>An <span class="rlang"><b>R</b></span> object of <code><a href="base.html#topic+class">class</a></code> <code>"pelora"</code>,
typically the result of <code><a href="#topic+pelora">pelora</a>()</code>.</p>
</td></tr>
<tr><td><code id="fitted.pelora_+3A_...">...</code></td>
<td>
<p>Further arguments passed to and from methods.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Numeric matrix of fitted values (for <code class="reqn">n</code> cases in rows, and
<code>noc</code> group centroids in columns).
</p>


<h3>Author(s)</h3>

<p>Marcel Dettling, <a href="mailto:dettling@stat.math.ethz.ch">dettling@stat.math.ethz.ch</a></p>


<h3>See Also</h3>

<p><code><a href="#topic+pelora">pelora</a></code>, also for references.
</p>


<h3>Examples</h3>

<pre><code class='language-R'> ## Running the examples of Pelora's help page
 example(pelora, echo = FALSE)
 fitted(fit)
</code></pre>

<hr>
<h2 id='fitted.wilma'>Extract the Fitted Values of Wilma</h2><span id='topic+fitted.wilma'></span>

<h3>Description</h3>

<p>Yields the fitted values, i.e. the centroids of the (gene)
clusters that have been found by <code>wilma</code>.</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'wilma'
fitted(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fitted.wilma_+3A_object">object</code></td>
<td>
<p>An <span class="rlang"><b>R</b></span> object of <code><a href="base.html#topic+class">class</a></code> <code>"wilma"</code>,
typically the result of <code><a href="#topic+wilma">wilma</a>()</code>.</p>
</td></tr>
<tr><td><code id="fitted.wilma_+3A_...">...</code></td>
<td>
<p>further arguments passed to and from methods.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Numeric matrix of fitted values (for <code class="reqn">n</code> cases in rows, and
<code>noc</code> group centroids in columns).
</p>


<h3>Author(s)</h3>

<p>Marcel Dettling, <a href="mailto:dettling@stat.math.ethz.ch">dettling@stat.math.ethz.ch</a></p>


<h3>See Also</h3>

<p><code><a href="#topic+wilma">wilma</a></code>, also for references.</p>


<h3>Examples</h3>

<pre><code class='language-R'> ## Running the examples of Wilma's help page
 example(wilma, echo = FALSE)
 fitted(fit)
</code></pre>

<hr>
<h2 id='leukemia'>A part of the Golub's famous AML/ALL-leukemia dataset</h2><span id='topic+leukemia'></span><span id='topic+leukemia.x'></span><span id='topic+leukemia.y'></span><span id='topic+leukemia.z'></span>

<h3>Description</h3>

<p>Part of the training set of the famous AML/ALL-leukemia
dataset from the Whitehead Institute.  It has been reduced to 250
genes, about half of which are very informative for classification,
whereas the other half was chosen randomly.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(leukemia)
</code></pre>


<h3>Format</h3>

<p>Contains three <span class="rlang"><b>R</b></span>-objects:
The expression (38 x 250) matrix <code>leukemia.x</code>,
the associated binary (<code>0,1</code>) response variable <code>leukemia.y</code>,
and the associated 3-class response variable <code>leukemia.z</code> with
values in <code>0,1,2</code>.
</p>


<h3>Author(s)</h3>

<p>Marcel Dettling</p>


<h3>Source</h3>

<p>originally at <code>http://www.genome.wi.mit.edu/MPR/</code>, (which is
not a valid URL any more).
</p>


<h3>References</h3>

<p>First published in<br />
Golub et al. (1999)
Molecular Classification of Cancer: Class Discovery and Class
Prediction by Gene Expression Monitoring.
<em>Science</em> <b>286</b>, 531&ndash;538.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(leukemia, package="supclust")
str(leukemia.x)
str(leukemia.y)
str(leukemia.z)
op &lt;- par(mfrow= 1:2)
plot(leukemia.x[,56], leukemia.y)
plot(leukemia.x[,174],leukemia.z)
par(op)
</code></pre>

<hr>
<h2 id='margin'>Classification Margin Between Two Sample Classes</h2><span id='topic+margin'></span>

<h3>Description</h3>

<p>For a set of <code class="reqn">n</code> observations grouped into two classes (for
example <code class="reqn">n</code> expression values of a gene), the <code>margin</code>
function measures the size of the gap between the classes. This is the
distance between the observation of response class zero having the
lowest value, and the individual of with response one having the
highest value.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>margin(x, resp)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="margin_+3A_x">x</code></td>
<td>
<p>Numeric vector of length <code class="reqn">n</code>, for example containing gene
or cluster expression values of <code class="reqn">n</code> different cases.</p>
</td></tr>
<tr><td><code id="margin_+3A_resp">resp</code></td>
<td>
<p>Numeric vector of length <code class="reqn">n</code> containing the &ldquo;binary&rdquo;
class labels of the cases.  Must be coded by <code>0</code> and <code>1</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A numeric value, the <code>margin</code>. Positive <code>margin</code>
indicates perfect separation of the response classes, whereas negative
<code>margin</code> means imperfect separation.</p>


<h3>Author(s)</h3>

<p>Marcel Dettling</p>


<h3>References</h3>

<p>see those in <code><a href="#topic+wilma">wilma</a></code>.</p>


<h3>See Also</h3>

<p><code><a href="#topic+wilma">wilma</a></code>, <code><a href="#topic+score">score</a></code> is the second statistic
that is used there.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(leukemia, package="supclust")
op &lt;- par(mfrow=c(1,3))
plot(leukemia.x[,69],leukemia.y)
title(paste("Margin = ", round(margin(leukemia.x[,69], leukemia.y),2)))

## Sign-flipping is very important
plot(leukemia.x[,161],leukemia.y)
title(paste("Margin = ", round(margin(leukemia.x[,161], leukemia.y),2)))
x &lt;- sign.flip(leukemia.x, leukemia.y)$flipped.matrix
plot(x[,161],leukemia.y)
title(paste("Margin = ", round(margin(x[,161], leukemia.y),2)))
par(op)
</code></pre>

<hr>
<h2 id='pelora'>Supervised Grouping of Predictor Variables</h2><span id='topic+pelora'></span>

<h3>Description</h3>

<p>Performs selection and supervised grouping of predictor
variables in large (microarray gene expression) datasets, with an
option for simultaneous classification. Works in a greedy forward
strategy and optimizes the binomial log-likelihood, based on estimated
conditional probabilities from penalized logistic regression analysis.</p>


<h3>Usage</h3>

<pre><code class='language-R'>pelora(x, y, u = NULL, noc = 10, lambda = 1/32, flip = "pm",
       standardize = TRUE, trace = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pelora_+3A_x">x</code></td>
<td>
<p>Numeric matrix of explanatory variables (<code class="reqn">p</code> variables in
columns, <code class="reqn">n</code> cases in rows). For example, these can be
microarray gene expression data which should be grouped.</p>
</td></tr>
<tr><td><code id="pelora_+3A_y">y</code></td>
<td>
<p>Numeric vector of length <code class="reqn">n</code> containing the class labels
of the individuals. These labels have to be coded by 0 and 1.</p>
</td></tr>
<tr><td><code id="pelora_+3A_u">u</code></td>
<td>
<p>Numeric matrix of additional (clinical) explanatory variables
(<code class="reqn">m</code> variables in columns, <code class="reqn">n</code> cases in rows) that are used
in the (penalized logistic regression) prediction model, but neither
grouped nor averaged. For example, these can be 'traditional'
clinical variables.</p>
</td></tr>
<tr><td><code id="pelora_+3A_noc">noc</code></td>
<td>
<p>Integer, the number of clusters that should be searched for
on the data.</p>
</td></tr>
<tr><td><code id="pelora_+3A_lambda">lambda</code></td>
<td>
<p>Real, defaults to 1/32. Rescaled penalty parameter that
should be in <code class="reqn">[0,1]</code>.</p>
</td></tr>
<tr><td><code id="pelora_+3A_flip">flip</code></td>
<td>
<p>Character string, describing a method how the <code>x</code>
(gene expression) matrix should be sign-flipped. Possible are
<code>"pm"</code> (the default) where the sign for each variable is
determined upon its entering into the group, <code>"cor"</code> where the
sign for each variable is determined a priori as the sign of the
empirical correlation of that variable with the <code>y</code>-vector, and
<code>"none"</code> where no sign-flipping is carried out.</p>
</td></tr>
<tr><td><code id="pelora_+3A_standardize">standardize</code></td>
<td>
<p>Logical, defaults to <code>TRUE</code>. Is indicating
whether the predictor variables (genes) should be standardized to
zero mean and unit variance.</p>
</td></tr>
<tr><td><code id="pelora_+3A_trace">trace</code></td>
<td>
<p>Integer &gt;= 0; when positive, the output of the internal
loops is provided; <code>trace &gt;= 2</code> provides output even from the
internal C routines.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>pelora</code> returns an object of class &quot;pelora&quot;. The functions
<code>print</code> and <code>summary</code> are used to obtain an overview of the
variables (genes) that have been selected and the groups that have
been formed. The function <code>plot</code> yields a two-dimensional
projection into the space of the first two group centroids that
<code>pelora</code> found. The generic function <code>fitted</code> returns
the fitted values, these are the cluster representatives. <code>coef</code>
returns the penalized logistic regression coefficients <code class="reqn">\theta_j</code>
for each of the predictors. Finally, <code>predict</code> is used for
classifying test data with Pelora's internal penalized logistic
regression classifier on the basis of the (gene) groups that have been
found.
</p>
<p>An object of class &quot;pelora&quot; is a list containing:
</p>
<table>
<tr><td><code>genes</code></td>
<td>
<p>A list of length <code>noc</code>, containing integer vectors
consisting of the indices (column numbers) of the variables (genes)
that have been clustered.</p>
</td></tr>
<tr><td><code>values</code></td>
<td>
<p>A numerical matrix with dimension <code class="reqn">n \times
      \code{noc}</code>, containing the fitted values, i.e. the group
centroids <code class="reqn">\tilde{x}_j</code>.</p>
</td></tr>
<tr><td><code>y</code></td>
<td>
<p>Numeric vector of length <code class="reqn">n</code> containing the class labels
of the individuals. These labels are coded by 0 and 1.</p>
</td></tr>
<tr><td><code>steps</code></td>
<td>
<p>Numerical vector of length <code>noc</code>, showing the number
of forward/backward cycles in the fitting process of each cluster.</p>
</td></tr>
<tr><td><code>lambda</code></td>
<td>
<p>The rescaled penalty parameter.</p>
</td></tr>
<tr><td><code>noc</code></td>
<td>
<p>The number of clusters that has been searched for on the data.</p>
</td></tr>
<tr><td><code>px</code></td>
<td>
<p>The number of columns (genes) in the <code>x</code>-matrix.</p>
</td></tr>
<tr><td><code>flip</code></td>
<td>
<p>The method that has been chosen for sign-flipping the
<code>x</code>-matrix.</p>
</td></tr>
<tr><td><code>var.type</code></td>
<td>
<p>A factor with <code>noc</code> entries, describing whether
the <code class="reqn">j</code>th predictor is a group of predictors (genes) or a single
(clinical) predictor variable.</p>
</td></tr>
<tr><td><code>crit</code></td>
<td>
<p>A list of length <code>noc</code>, containing numerical vectors
that provide information about the development of the grouping
criterion during the clustering.</p>
</td></tr>
<tr><td><code>signs</code></td>
<td>
<p>Numerical vector of length <code class="reqn">p</code>, saying whether the
<code class="reqn">i</code>th variable (gene) should be sign-flipped (-1) or not (+1).</p>
</td></tr>
<tr><td><code>samp.names</code></td>
<td>
<p>The names of the samples (rows) in the
<code>x</code>-matrix.</p>
</td></tr>
<tr><td><code>gene.names</code></td>
<td>
<p>The names of the variables (columns) in the
<code>x</code>-matrix.</p>
</td></tr>
<tr><td><code>call</code></td>
<td>
<p>The function call.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Marcel Dettling, <a href="mailto:dettling@stat.math.ethz.ch">dettling@stat.math.ethz.ch</a></p>


<h3>References</h3>

<p>Marcel Dettling (2003)
<em>Finding Predictive Gene Groups from Microarray Data</em>, see
<a href="https://stat.ethz.ch/~dettling/supervised.html">https://stat.ethz.ch/~dettling/supervised.html</a>
</p>
<p>Marcel Dettling and Peter Bühlmann (2002).
Supervised Clustering of Genes.
<em>Genome Biology</em>, <b>3</b>(12): research0069.1-0069.15,
doi: <a href="https://doi.org/10.1186/gb-2002-3-12-research0069">10.1186/gb-2002-3-12-research0069</a>.
</p>
<p>Marcel Dettling and Peter Bühlmann (2004).
Finding Predictive Gene Groups from Microarray Data.
<em>Journal of Multivariate Analysis</em> <b>90</b>, 106&ndash;131,
doi: <a href="https://doi.org/10.1016/j.jmva.2004.02.012">10.1016/j.jmva.2004.02.012</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+wilma">wilma</a></code> for another supervised clustering technique.</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Working with a "real" microarray dataset
data(leukemia, package="supclust")

## Generating random test data: 3 observations and 250 variables (genes)
set.seed(724)
xN &lt;- matrix(rnorm(750), nrow = 3, ncol = 250)

## Fitting Pelora
fit &lt;- pelora(leukemia.x, leukemia.y, noc = 3)

## Working with the output
fit
summary(fit)
plot(fit)
fitted(fit)
coef(fit)

## Fitted values and class probabilities for the training data
predict(fit, type = "cla")
predict(fit, type = "prob")

## Predicting fitted values and class labels for the random test data
predict(fit, newdata = xN)
predict(fit, newdata = xN, type = "cla", noc = c(1,2,3))
predict(fit, newdata = xN, type = "pro", noc = c(1,3))

## Fitting Pelora such that the first 70 variables (genes) are not grouped
fit &lt;- pelora(leukemia.x[, -(1:70)], leukemia.y, leukemia.x[,1:70])

## Working with the output
fit
summary(fit)
plot(fit)
fitted(fit)
coef(fit)

## Fitted values and class probabilities for the training data
predict(fit, type = "cla")
predict(fit, type = "prob")

## Predicting fitted values and class labels for the random test data
predict(fit, newdata = xN[, -(1:70)], newclin = xN[, 1:70])
predict(fit, newdata = xN[, -(1:70)], newclin = xN[, 1:70], "cla", noc  = 1:10)
predict(fit, newdata = xN[, -(1:70)], newclin = xN[, 1:70], type = "pro")
</code></pre>

<hr>
<h2 id='plot.pelora'>2-Dimensional Visualization of Pelora's Output</h2><span id='topic+plot.pelora'></span>

<h3>Description</h3>

<p>Yields a projection of the cases (for example <code class="reqn">n</code> gene
expression profiles) into the space of the first two gene group
centroids that were identified by <code>pelora</code>.</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'pelora'
plot(x, main = "2-Dimensional Projection Pelora's output",
            xlab = NULL, ylab = NULL, col = seq(x$yvals), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.pelora_+3A_x">x</code></td>
<td>
<p>An <span class="rlang"><b>R</b></span> object of <code><a href="base.html#topic+class">class</a></code> <code>"pelora"</code>,
typically the result of <code><a href="#topic+pelora">pelora</a>()</code>.</p>
</td></tr>
<tr><td><code id="plot.pelora_+3A_main">main</code></td>
<td>
<p>A character string, giving the title of the plot.</p>
</td></tr>
<tr><td><code id="plot.pelora_+3A_xlab">xlab</code></td>
<td>
<p>A character string, giving the annotation of the
<code>x</code>-axis.</p>
</td></tr>
<tr><td><code id="plot.pelora_+3A_ylab">ylab</code></td>
<td>
<p>A character string, giving the annotation of the
<code>x</code>-axis.</p>
</td></tr>
<tr><td><code id="plot.pelora_+3A_col">col</code></td>
<td>
<p>A numeric vector of length 2, coding the colors that will
be used for plotting the class labels.</p>
</td></tr>
<tr><td><code id="plot.pelora_+3A_...">...</code></td>
<td>
<p>Further arguments passed to and from methods.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Marcel Dettling, <a href="mailto:dettling@stat.math.ethz.ch">dettling@stat.math.ethz.ch</a></p>


<h3>See Also</h3>

<p><code><a href="#topic+pelora">pelora</a></code>, also for references.
</p>


<h3>Examples</h3>

<pre><code class='language-R'> ## Running the examples of Pelora's help page
 example(pelora, echo = FALSE)
 plot(fit)
</code></pre>

<hr>
<h2 id='plot.wilma'>2-Dimensional Visualization of Wilma's Output</h2><span id='topic+plot.wilma'></span>

<h3>Description</h3>

<p>Yields a projection of the cases (for example <code class="reqn">n</code> gene
expression profiles) into the space of the first two gene group
centroids that were identified by <code>wilma</code>.</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'wilma'
plot(x, xlab = NULL, ylab = NULL, col = seq(x$yvals),
           main = "2-Dimensional Projection of Wilma's Output", ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.wilma_+3A_x">x</code></td>
<td>
<p>an <span class="rlang"><b>R</b></span> object of <code><a href="base.html#topic+class">class</a></code> <code>"wilma"</code>,
typically the result of <code><a href="#topic+wilma">wilma</a>()</code>.</p>
</td></tr>
<tr><td><code id="plot.wilma_+3A_xlab">xlab</code></td>
<td>
<p>character string, giving the annotation of the
<code>x</code>-axis.</p>
</td></tr>
<tr><td><code id="plot.wilma_+3A_ylab">ylab</code></td>
<td>
<p>character string, giving the annotation of the
<code>x</code>-axis.</p>
</td></tr>
<tr><td><code id="plot.wilma_+3A_col">col</code></td>
<td>
<p>a numeric vector of length 2, coding the colors that will
be used for plotting the class labels.</p>
</td></tr>
<tr><td><code id="plot.wilma_+3A_main">main</code></td>
<td>
<p>a character string, giving the title of the plot.</p>
</td></tr>
<tr><td><code id="plot.wilma_+3A_...">...</code></td>
<td>
<p>Further arguments passed to and from methods.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Marcel Dettling, <a href="mailto:dettling@stat.math.ethz.ch">dettling@stat.math.ethz.ch</a></p>


<h3>See Also</h3>

<p><code><a href="#topic+wilma">wilma</a></code>, also for references.</p>


<h3>Examples</h3>

<pre><code class='language-R'> ## Running the examples of Wilma's help page
 example(wilma, echo = FALSE)
 plot(fit)
</code></pre>

<hr>
<h2 id='predict.pelora'>Predict Method for Pelora</h2><span id='topic+predict.pelora'></span>

<h3>Description</h3>

<p>Yields fitted values, predicted class labels and
conditional probability estimates for training and test data, which
are based on the gene groups <code>pelora</code> found, and on its internal
penalized logistic regression classifier.</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'pelora'
predict(object, newdata = NULL, newclin = NULL,
               type = c("fitted", "probs", "class"), noc = object$noc, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="predict.pelora_+3A_object">object</code></td>
<td>
<p>An <span class="rlang"><b>R</b></span> object of <code><a href="base.html#topic+class">class</a></code> <code>"pelora"</code>,
typically the result of <code><a href="#topic+pelora">pelora</a>()</code>.</p>
</td></tr>
<tr><td><code id="predict.pelora_+3A_newdata">newdata</code></td>
<td>
<p>Numeric matrix with the same number of explanatory
variables as the original <code>x</code>-matrix (<code class="reqn">p</code> variables in
columns, <code class="reqn">r</code> cases in rows). For example, these can be
additional microarray gene expression data which should be
predicted.</p>
</td></tr>
<tr><td><code id="predict.pelora_+3A_newclin">newclin</code></td>
<td>
<p>Numeric matrix with the same number of additional
(clinical) explanatory variables as the original <code>u</code>-matrix
(<code class="reqn">m</code> variables in columns, <code class="reqn">r</code> cases in rows) that are used
in the (penalized logistic regression) prediction model, but neither
grouped nor averaged. Only needs to be given, if the model fit
included an <code>u</code>-matrix. For example, these can be 'traditional'
clinical variables.</p>
</td></tr>
<tr><td><code id="predict.pelora_+3A_type">type</code></td>
<td>
<p>Character string, describing whether fitted values
<code>"fitted"</code>, estimated conditional probabilites <code>"probs"</code>
or class labels <code>"class"</code> should be returned.</p>
</td></tr>
<tr><td><code id="predict.pelora_+3A_noc">noc</code></td>
<td>
<p>Integer, saying with how many clusters the fitted values,
probability estimates or class labels should be determined. Also
numeric vectors are allowed as an argument. The output is then a
numeric matrix with fitted values, probability estimates or class
labels for a multiple number of clusters.</p>
</td></tr>
<tr><td><code id="predict.pelora_+3A_...">...</code></td>
<td>
<p>Further arguments passed to and from methods.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If <code>newdata = NULL</code>, then the in-sample fitted values,
probability estimates and class label predictions are returned.
</p>


<h3>Value</h3>

<p>Depending on whether <code>noc</code> is a single number or a numeric
vector. In the first case, a numeric vector of length <code class="reqn">r</code> is
returned, which contains fitted values for <code>noc</code> clusters, or
probability estimates/class label predictions with <code>noc</code>
clusters.
</p>
<p>In the latter case, a numeric matrix with <code>length(noc)</code> columns,
each containing fitted values for <code>noc</code> clusters, or
probability estimates/class label predictions with <code>noc</code>
clusters, is returned.
</p>


<h3>Author(s)</h3>

<p>Marcel Dettling, <a href="mailto:dettling@stat.math.ethz.ch">dettling@stat.math.ethz.ch</a></p>


<h3>See Also</h3>

<p><code><a href="#topic+pelora">pelora</a></code>, also for references.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Working with a "real" microarray dataset
data(leukemia, package="supclust")

## Generating random test data: 3 observations and 250 variables (genes)
set.seed(724)
xN &lt;- matrix(rnorm(750), nrow = 3, ncol = 250)

## Fitting Pelora
fit &lt;- pelora(leukemia.x, leukemia.y, noc = 3)

## Fitted values and class probabilities for the training data
predict(fit, type = "cla")
predict(fit, type = "prob")

## Predicting fitted values and class labels for the random test data
predict(fit, newdata = xN)
predict(fit, newdata = xN, type = "cla", noc = c(1,2,3))
predict(fit, newdata = xN, type = "pro", noc = c(1,3))

## Fitting Pelora such that the first 70 variables (genes) are not grouped
fit &lt;- pelora(leukemia.x[, -(1:70)], leukemia.y, leukemia.x[,1:70])

## Fitted values and class probabilities for the training data
predict(fit, type = "cla")
predict(fit, type = "prob")

## Predicting fitted values and class labels for the random test data
predict(fit, newdata = xN[, -(1:70)], newclin = xN[, 1:70])
predict(fit, newdata = xN[, -(1:70)], newclin = xN[, 1:70], "cla", noc  = 1:10)
predict(fit, newdata = xN[, -(1:70)], newclin = xN[, 1:70], type = "pro")
</code></pre>

<hr>
<h2 id='predict.wilma'>Predict Method for Wilma</h2><span id='topic+predict.wilma'></span>

<h3>Description</h3>

<p>Yields fitted values or predicted class labels for training
and test data, which are based on the supervised gene clusters
<code>wilma</code> found, and on a choice of four different classifiers: the
nearest-neighbor rule, diagonal linear discriminant analysis, logistic
regression and aggregated trees.</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'wilma'
predict(object, newdata = NULL, type = c("fitted", "class"),
              classifier = c("nnr", "dlda", "logreg", "aggtrees"),
              noc = object$noc, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="predict.wilma_+3A_object">object</code></td>
<td>
<p>an <span class="rlang"><b>R</b></span> object of <code><a href="base.html#topic+class">class</a></code> <code>"wilma"</code>,
typically the result of <code><a href="#topic+wilma">wilma</a>()</code>.</p>
</td></tr>
<tr><td><code id="predict.wilma_+3A_newdata">newdata</code></td>
<td>
<p>numeric matrix with the same number of explanatory
variables as the original <code>x</code>-matrix (<code class="reqn">p</code> variables in
columns, <code class="reqn">r</code> cases in rows).  For example, these can be
additional microarray gene expression data which should be
predicted.</p>
</td></tr>
<tr><td><code id="predict.wilma_+3A_type">type</code></td>
<td>
<p>character string describing whether fitted values
<code>"fitted"</code> or predicted class labels <code>"class"</code> should be
returned.</p>
</td></tr>
<tr><td><code id="predict.wilma_+3A_classifier">classifier</code></td>
<td>
<p>character string specifying which classifier should
be used.  Choices are <code>"nnr"</code>, the 1-nearest-neighbor-rule;
<code>"dlda"</code>, diagonal linear discriminant analysis;
<code>"logreg"</code>, logistic regression; <code>"aggtrees"</code> aggregated
trees. </p>
</td></tr>
<tr><td><code id="predict.wilma_+3A_noc">noc</code></td>
<td>
<p>integer specifying how many clusters the fitted values or
class label predictions should be determined. Also numeric vectors
are allowed as an argument. The output is then a numeric matrix with
fitted values or class label predictions for a multiple number of
clusters.</p>
</td></tr>
<tr><td><code id="predict.wilma_+3A_...">...</code></td>
<td>
<p>further arguments passed to and from methods.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If <code>newdata = NULL</code>, then the in-sample fitted values or class
label predictions are returned.
</p>


<h3>Value</h3>

<p>Depending on whether <code>noc</code> is a single number or a numeric
vector. In the first case, a numeric vector of length <code class="reqn">r</code> is
returned, which contains fitted values for <code>noc</code> clusters, or
class label predictions with <code>noc</code> clusters.
</p>
<p>In the latter case, a numeric matrix with <code>length(noc)</code> columns,
each containing fitted values for <code>noc</code> clusters, or class label
predictions with <code>noc</code> clusters, is returned.
</p>


<h3>Author(s)</h3>

<p>Marcel Dettling, <a href="mailto:dettling@stat.math.ethz.ch">dettling@stat.math.ethz.ch</a></p>


<h3>See Also</h3>

<p><code><a href="#topic+wilma">wilma</a></code> also for <em>references</em>, and for the four
classifiers
<code><a href="#topic+nnr">nnr</a></code>, <code><a href="#topic+dlda">dlda</a></code>, <code><a href="#topic+logreg">logreg</a></code>,
<code><a href="#topic+aggtrees">aggtrees</a></code>.</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Working with a "real" microarray dataset
data(leukemia, package="supclust")

## Generating random test data: 3 observations and 250 variables (genes)
set.seed(724)
xN &lt;- matrix(rnorm(750), nrow = 3, ncol = 250)

## Fitting Wilma
fit  &lt;- wilma(leukemia.x, leukemia.y, noc = 3, trace = 1)

## Fitted values and class predictions for the training data
predict(fit, type = "cla")
predict(fit, type = "fitt")

## Predicting fitted values and class labels for test data
predict(fit, newdata = xN)
predict(fit, newdata = xN, type = "cla", classifier = "nnr", noc = c(1,2,3))
predict(fit, newdata = xN, type = "cla", classifier = "dlda", noc = c(1,3))
predict(fit, newdata = xN, type = "cla", classifier = "logreg")
predict(fit, newdata = xN, type = "cla", classifier = "aggtrees")
</code></pre>

<hr>
<h2 id='print.pelora'>Print Method for Pelora Objects</h2><span id='topic+print.pelora'></span>

<h3>Description</h3>

<p>Yields an overview about the type, size and final criterion
value of the predictor variables that were selected by <code>pelora</code>.</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'pelora'
print(x, digits = getOption("digits"), details = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.pelora_+3A_x">x</code></td>
<td>
<p>an <span class="rlang"><b>R</b></span> object of <code><a href="base.html#topic+class">class</a></code> <code>"pelora"</code>,
typically the result of <code><a href="#topic+pelora">pelora</a>()</code>.</p>
</td></tr>
<tr><td><code id="print.pelora_+3A_digits">digits</code></td>
<td>
<p>the number of digits that should be printed.</p>
</td></tr>
<tr><td><code id="print.pelora_+3A_details">details</code></td>
<td>
<p>logical, defaults to <code>FALSE</code>. If set to
<code>TRUE</code>, the output corresponds to
<code><a href="#topic+summary.pelora">summary.pelora</a></code>.</p>
</td></tr>
<tr><td><code id="print.pelora_+3A_...">...</code></td>
<td>
<p>Further arguments passed to and from methods.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Marcel Dettling, <a href="mailto:dettling@stat.math.ethz.ch">dettling@stat.math.ethz.ch</a></p>


<h3>See Also</h3>

<p><code><a href="#topic+pelora">pelora</a></code>, also for references.
</p>


<h3>Examples</h3>

<pre><code class='language-R'> ## Running the examples of Pelora's help page
 example(pelora, echo = FALSE)
 print(fit)
</code></pre>

<hr>
<h2 id='print.wilma'>Print Method for Wilma Objects</h2><span id='topic+print.wilma'></span>

<h3>Description</h3>

<p>Yields an overview about the size and the final criterion
values of the clusters that were selected by <code>wilma</code>.</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'wilma'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.wilma_+3A_x">x</code></td>
<td>
<p>An <span class="rlang"><b>R</b></span> object of <code><a href="base.html#topic+class">class</a></code> <code>"wilma"</code>,
typically the result of <code><a href="#topic+wilma">wilma</a>()</code>.</p>
</td></tr>
<tr><td><code id="print.wilma_+3A_...">...</code></td>
<td>
<p>Further arguments passed to and from methods.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Marcel Dettling, <a href="mailto:dettling@stat.math.ethz.ch">dettling@stat.math.ethz.ch</a></p>


<h3>See Also</h3>

<p><code><a href="#topic+wilma">wilma</a></code>, also for references.</p>


<h3>Examples</h3>

<pre><code class='language-R'> ## Running the examples of Wilma's help page
 example(wilma, echo = FALSE)
 print(fit)
</code></pre>

<hr>
<h2 id='score'>Wilcoxon Score for Binary Problems</h2><span id='topic+score'></span>

<h3>Description</h3>

<p>For a set of <code class="reqn">n</code> observations grouped into two classes (for
example <code class="reqn">n</code> expression values of a gene), the <code>score</code>
function measures the separation of the classes. It can be interpreted
as counting for each observation having response zero, the number of
individuals of response class one that are smaller, and summing up
these quantities.</p>


<h3>Usage</h3>

<pre><code class='language-R'>score(x, resp)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="score_+3A_x">x</code></td>
<td>
<p>Numeric vector of length <code class="reqn">n</code>, for example containing gene
or cluster expression values of <code class="reqn">n</code> different cases.</p>
</td></tr>
<tr><td><code id="score_+3A_resp">resp</code></td>
<td>
<p>Numeric vector of length <code class="reqn">n</code> containing the &ldquo;binary&rdquo;
class labels of the cases.  Must be coded by <code>0</code> and <code>1</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A numeric value, the <code>score</code>. The minimal <code>score</code> is
zero, the maximal <code>score</code> is the product of the number of samples
in class 0 and class 1. Values near the minimal or maximal
<code>score</code> indicate good separation, whereas intermediate
<code>score</code> means poor separation.</p>


<h3>Author(s)</h3>

<p>Marcel Dettling, <a href="mailto:dettling@stat.math.ethz.ch">dettling@stat.math.ethz.ch</a></p>


<h3>See Also</h3>

<p><code><a href="#topic+wilma">wilma</a></code> also for <em>references</em>;
<code><a href="#topic+margin">margin</a></code> is the second statistic that is used there.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(leukemia, package="supclust")
op &lt;- par(mfrow=c(1,3))
plot(leukemia.x[,69],leukemia.y)
title(paste("Score = ", score(leukemia.x[,69], leukemia.y)))

## Sign-flipping is very important
plot(leukemia.x[,161],leukemia.y)
title(paste("Score = ", score(leukemia.x[,161], leukemia.y),2))
x &lt;- sign.flip(leukemia.x, leukemia.y)$flipped.matrix
plot(x[,161],leukemia.y)
title(paste("Score = ", score(x[,161], leukemia.y),2))
par(op)
</code></pre>

<hr>
<h2 id='sign.change'>Sign-flipping of Predictor Variables to Obtain Equal Polarity</h2><span id='topic+sign.change'></span>

<h3>Description</h3>

<p>Computes the empirical correlation for each predictor
variable (gene) in the <code>x</code>-Matrix with the response <code>y</code>, and
multiplies its values with (-1) if the empirical correlation has a
negative sign. For gene expression data, this amounts to treating
under- and overexpression symmetrically. After the <code>sign.change</code>,
low (expression) values point towards response class 0 and high
(expression) values point towards class 1.</p>


<h3>Usage</h3>

<pre><code class='language-R'>sign.change(x, y)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sign.change_+3A_x">x</code></td>
<td>
<p>Numeric matrix of explanatory variables (<code class="reqn">p</code> variables in
columns, <code class="reqn">n</code> cases in rows). For example, these can be
microarray gene expression data which should be sign-flipped and
then grouped.</p>
</td></tr>
<tr><td><code id="sign.change_+3A_y">y</code></td>
<td>
<p>Numeric vector of length <code class="reqn">n</code> containing the class labels
of the individuals. These labels have to be coded by 0 and 1.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a list containing:
</p>
<table>
<tr><td><code>x.new</code></td>
<td>
<p>The sign-flipped <code>x</code>-matrix.</p>
</td></tr>
<tr><td><code>signs</code></td>
<td>
<p>Numeric vector of length <code class="reqn">p</code>, which for each
predictor variable indicates whether it was sign-flipped (coded by
-1) or not (coded by +1).</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Marcel Dettling, <a href="mailto:dettling@stat.math.ethz.ch">dettling@stat.math.ethz.ch</a></p>


<h3>See Also</h3>

<p><code><a href="#topic+pelora">pelora</a></code> also for <em>references</em>,
as well as for older methodology,
<code><a href="#topic+wilma">wilma</a></code> and <code><a href="#topic+sign.flip">sign.flip</a></code>.</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(leukemia, package="supclust")

op &lt;- par(mfrow=c(1,3))
plot(leukemia.x[,69],leukemia.y)
title(paste("Margin = ", round(margin(leukemia.x[,69], leukemia.y),2)))

## Sign-flipping is very important
plot(leukemia.x[,161],leukemia.y)
title(paste("Margin = ", round(margin(leukemia.x[,161], leukemia.y),2)))
x &lt;- sign.change(leukemia.x, leukemia.y)$x.new
plot(x[,161],leukemia.y)
title(paste("Margin = ", round(margin(x[,161], leukemia.y),2)))
par(op)
</code></pre>

<hr>
<h2 id='sign.flip'>Sign-flipping of Predictor Variables to Obtain Equal Polarity</h2><span id='topic+sign.flip'></span>

<h3>Description</h3>

<p>Computes the <code>score</code> for each predictor variable
(gene) in the <code>x</code>-Matrix, and multiplies its values with (-1) if
its <code>score</code> is greater or equal than half of the maximal
<code>score</code>. For gene expression data, this amounts to treating
under- and overexpression symmetrically. After the sign-flip
procedure, low (expression) values point towards response class 0 and
high (expression) values point towards class 1.</p>


<h3>Usage</h3>

<pre><code class='language-R'>sign.flip(x, y)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sign.flip_+3A_x">x</code></td>
<td>
<p>Numeric matrix of explanatory variables (<code class="reqn">p</code> variables in
columns, <code class="reqn">n</code> cases in rows). For example, these can be
microarray gene expression data which should be sign-flipped and
then clustered.</p>
</td></tr>
<tr><td><code id="sign.flip_+3A_y">y</code></td>
<td>
<p>Numeric vector of length <code class="reqn">n</code> containing the class labels
of the individuals. These labels have to be coded by 0 and 1.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a list containing:
</p>
<table>
<tr><td><code>flipped.matrix</code></td>
<td>
<p>The sign-flipped <code>x</code>-matrix.</p>
</td></tr>
<tr><td><code>signs</code></td>
<td>
<p>Numeric vector of length <code class="reqn">p</code>, which for each
predictor variable indicates whether it was sign-flipped (coded by
-1) or not (coded by +1).</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Marcel Dettling, <a href="mailto:dettling@stat.math.ethz.ch">dettling@stat.math.ethz.ch</a></p>


<h3>See Also</h3>

<p><code><a href="#topic+wilma">wilma</a></code> also for the <em>references</em>
and <code><a href="#topic+score">score</a></code>, as well as for a
newer methodology, <code><a href="#topic+pelora">pelora</a></code> and <code><a href="#topic+sign.change">sign.change</a></code>.</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(leukemia, package="supclust")

op &lt;- par(mfrow=c(1,3))
plot(leukemia.x[,69],leukemia.y)
title(paste("Margin = ", round(margin(leukemia.x[,69], leukemia.y),2)))

## Sign-flipping is very important
plot(leukemia.x[,161],leukemia.y)
title(paste("Margin = ", round(margin(leukemia.x[,161], leukemia.y),2)))
x &lt;- sign.flip(leukemia.x, leukemia.y)$flipped.matrix
plot(x[,161],leukemia.y)
title(paste("Margin = ", round(margin(x[,161], leukemia.y),2)))
par(op)# reset
</code></pre>

<hr>
<h2 id='standardize.genes'>Standardization of Predictor Variables</h2><span id='topic+standardize.genes'></span>

<h3>Description</h3>

<p>Standardizes each column (gene) of the <code>x</code>-matrix to
zero mean and unit variance. This function is not to be called by the
user, the standardization is handled internally in <code>pelora</code>.</p>


<h3>Usage</h3>

<pre><code class='language-R'>standardize.genes(exmat)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="standardize.genes_+3A_exmat">exmat</code></td>
<td>
<p>Numeric matrix of explanatory variables (<code class="reqn">p</code>
variables in columns, <code class="reqn">n</code> cases in rows). For example, these can
be microarray gene expression data which should be standardized and
then grouped.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a list containing:
</p>
<table>
<tr><td><code>x</code></td>
<td>
<p>The standardized <code>x</code>-matrix</p>
</td></tr>
<tr><td><code>means</code></td>
<td>
<p>Numeric vector of length <code class="reqn">p</code>, containing the initial
mean of each column (gene) of the <code>x</code>-matrix.</p>
</td></tr>
<tr><td><code>sdevs</code></td>
<td>
<p>Numeric vector of length <code class="reqn">p</code>, containing the initial
standard deviation of each column (gene) of the <code>x</code>-matrix.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Marcel Dettling, <a href="mailto:dettling@stat.math.ethz.ch">dettling@stat.math.ethz.ch</a></p>


<h3>See Also</h3>

<p><code><a href="#topic+pelora">pelora</a></code> also for the <em>references</em>.</p>

<hr>
<h2 id='summary.pelora'>Summary Method for Pelora Objects</h2><span id='topic+summary.pelora'></span>

<h3>Description</h3>

<p>Yields detailed information about the variables (genes)
that have been selected, and how they were grouped.</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'pelora'
summary(object, digits, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary.pelora_+3A_object">object</code></td>
<td>
<p>an <span class="rlang"><b>R</b></span> object of <code><a href="base.html#topic+class">class</a></code> <code>"pelora"</code>,
typically the result of <code><a href="#topic+pelora">pelora</a>()</code>.</p>
</td></tr>
<tr><td><code id="summary.pelora_+3A_digits">digits</code></td>
<td>
<p>The number of digits that should be printed.</p>
</td></tr>
<tr><td><code id="summary.pelora_+3A_...">...</code></td>
<td>
<p>Further arguments passed to and from methods.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Marcel Dettling, <a href="mailto:dettling@stat.math.ethz.ch">dettling@stat.math.ethz.ch</a></p>


<h3>See Also</h3>

<p><code><a href="#topic+pelora">pelora</a></code>, also for references.
</p>


<h3>Examples</h3>

<pre><code class='language-R'> ## Running the examples of Pelora's help page
 example(pelora, echo = FALSE)
 summary(fit)
</code></pre>

<hr>
<h2 id='summary.wilma'>Summary Method for Wilma Objects</h2><span id='topic+summary.wilma'></span>

<h3>Description</h3>

<p>Yields detailed information about the variables (genes)
that have been selected, and how they were clustered.</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'wilma'
summary(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary.wilma_+3A_object">object</code></td>
<td>
<p>An <span class="rlang"><b>R</b></span> object of <code><a href="base.html#topic+class">class</a></code> <code>"wilma"</code>,
typically the result of <code><a href="#topic+wilma">wilma</a>()</code>.</p>
</td></tr>
<tr><td><code id="summary.wilma_+3A_...">...</code></td>
<td>
<p>Further arguments passed to and from methods.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Marcel Dettling, <a href="mailto:dettling@stat.math.ethz.ch">dettling@stat.math.ethz.ch</a></p>


<h3>See Also</h3>

<p><code><a href="#topic+wilma">wilma</a></code>, also for references.</p>


<h3>Examples</h3>

<pre><code class='language-R'> ## Running the examples of Wilma's help page
 example(wilma, echo = FALSE)
 summary(fit)
</code></pre>

<hr>
<h2 id='wilma'>Supervised Clustering of Predictor Variables</h2><span id='topic+wilma'></span>

<h3>Description</h3>

<p>Performs supervised clustering of predictor variables for
large (microarray gene expression) datasets. Works in a greedy forward
strategy and optimizes a combination of the Wilcoxon and Margin
statistics for finding the clusters.</p>


<h3>Usage</h3>

<pre><code class='language-R'>wilma(x, y, noc, genes = NULL, flip = TRUE, once.per.clust = FALSE, trace = 0)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="wilma_+3A_x">x</code></td>
<td>
<p>Numeric matrix of explanatory variables (<code class="reqn">p</code> variables in
columns, <code class="reqn">n</code> cases in rows). For example, these can be
microarray gene expression data which should be clustered.</p>
</td></tr>
<tr><td><code id="wilma_+3A_y">y</code></td>
<td>
<p>Numeric vector of length <code class="reqn">n</code> containing the class labels
of the individuals. These labels have to be coded by 0 and 1.</p>
</td></tr>
<tr><td><code id="wilma_+3A_noc">noc</code></td>
<td>
<p>Integer, the number of clusters that should be searched for
on the data.</p>
</td></tr>
<tr><td><code id="wilma_+3A_genes">genes</code></td>
<td>
<p>Defaults to <code>NULL</code>. An optional list (of length
<code>noc</code>) of vectors containing the indices (column numbers) of
the previously known initial clusters.</p>
</td></tr>
<tr><td><code id="wilma_+3A_flip">flip</code></td>
<td>
<p>Logical, defaults to <code>TRUE</code>. Is indicating whether
the clustering should be done with or without sign-flipping.</p>
</td></tr>
<tr><td><code id="wilma_+3A_once.per.clust">once.per.clust</code></td>
<td>
<p>Logical, defaults to <code>FALSE</code>. Is indicating
if each variable (gene) should only be allowed to enter into each
cluster once; equivalently, the cluster mean profile has only
weights <code class="reqn">\pm 1</code> for each variable.</p>
</td></tr>
<tr><td><code id="wilma_+3A_trace">trace</code></td>
<td>
<p>Integer &gt;= 0; when positive, the output of the internal
loops is provided; <code>trace &gt;= 2</code> provides output even from the
internal C routines.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>wilma</code> returns an object of class &quot;wilma&quot;. The functions
<code>print</code> and <code>summary</code> are used to obtain an overview of the
clusters that have been found. The function <code>plot</code> yields a
two-dimensional projection into the space of the first two clusters
that <code>wilma</code> found. The generic function <code>fitted</code> returns
the fitted values, these are the cluster representatives. Finally,
<code>predict</code> is used for classifying test data on the basis of
Wilma's cluster with either the nearest-neighbor-rule, diagonal linear
discriminant analysis, logistic regression or aggregated trees.
</p>
<p>An object of class &quot;wilma&quot; is a list containing:
</p>
<table>
<tr><td><code>clist</code></td>
<td>
<p>A list of length <code>noc</code>, containing integer vectors
consisting of the indices (column numbers) of the variables (genes)
that have been clustered.</p>
</td></tr>
<tr><td><code>steps</code></td>
<td>
<p>Numerical vector of length <code>noc</code>, showing the number
of forward/backward cycles in the fitting process of each cluster.</p>
</td></tr>
<tr><td><code>y</code></td>
<td>
<p>Numeric vector of length <code class="reqn">n</code> containing the class labels
of the individuals. These labels have to be coded by 0 and 1.</p>
</td></tr>
<tr><td><code>x.means</code></td>
<td>
<p>A list of length <code>noc</code>, containing numerical
matrices consisting of the cluster representatives after insertion
of each variable.</p>
</td></tr>
<tr><td><code>noc</code></td>
<td>
<p>Integer, the number of clusters that has been searched for
on the data.</p>
</td></tr>
<tr><td><code>signs</code></td>
<td>
<p>Numerical vector of length <code class="reqn">p</code>, saying whether the
<code class="reqn">i</code>th variable (gene) should be sign-flipped (-1) or not (+1).</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Marcel Dettling, <a href="mailto:dettling@stat.math.ethz.ch">dettling@stat.math.ethz.ch</a></p>


<h3>References</h3>

<p>Marcel Dettling (2002)
<em>Supervised Clustering of Genes</em>, see
<a href="https://stat.ethz.ch/~dettling/supercluster.html">https://stat.ethz.ch/~dettling/supercluster.html</a>
</p>
<p>Marcel Dettling and Peter Bühlmann (2002).
Supervised Clustering of Genes.
<em>Genome Biology</em>, <b>3</b>(12): research0069.1-0069.15,
doi: <a href="https://doi.org/10.1186/gb-2002-3-12-research0069">10.1186/gb-2002-3-12-research0069</a> .
</p>
<p>Marcel Dettling and Peter Bühlmann (2004).
Finding Predictive Gene Groups from Microarray Data.
<em>Journal of Multivariate Analysis</em> <b>90</b>, 106&ndash;131,
doi: <a href="https://doi.org/10.1016/j.jmva.2004.02.012">10.1016/j.jmva.2004.02.012</a> .
</p>


<h3>See Also</h3>

<p><code><a href="#topic+score">score</a></code>, <code><a href="#topic+margin">margin</a></code>, and for a newer
methodology, <code><a href="#topic+pelora">pelora</a></code>.</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Working with a "real" microarray dataset
data(leukemia, package="supclust")

## Generating random test data: 3 observations and 250 variables (genes)
set.seed(724)
xN &lt;- matrix(rnorm(750), nrow = 3, ncol = 250)

## Fitting Wilma
fit  &lt;- wilma(leukemia.x, leukemia.y, noc = 3, trace = 1)

## Working with the output
fit
summary(fit)
plot(fit)
fitted(fit)

## Fitted values and class predictions for the training data
predict(fit, type = "cla")
predict(fit, type = "fitt")

## Predicting fitted values and class labels for test data
predict(fit, newdata = xN)
predict(fit, newdata = xN, type = "cla", classifier = "nnr", noc = c(1,2,3))
predict(fit, newdata = xN, type = "cla", classifier = "dlda", noc = c(1,3))
predict(fit, newdata = xN, type = "cla", classifier = "logreg")
predict(fit, newdata = xN, type = "cla", classifier = "aggtrees")
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
