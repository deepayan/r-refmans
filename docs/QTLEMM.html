<!DOCTYPE html><html><head><title>Help for package QTLEMM</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {QTLEMM}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#D.make'><p>Generate D Matrix</p></a></li>
<li><a href='#EM.MIM'><p>EM Algorithm for QTL MIM</p></a></li>
<li><a href='#EM.MIM2'><p>EM Algorithm for QTL MIM with Selective Genotyping</p></a></li>
<li><a href='#EM.MIMv'><p>EM Algorithm for QTL MIM with Asymptotic Variance-Covariance Matrix</p></a></li>
<li><a href='#EQF.permu'><p>EQF Permutation</p></a></li>
<li><a href='#EQF.plot'><p>EQF plot</p></a></li>
<li><a href='#IM.search'><p>QTL search by IM</p></a></li>
<li><a href='#IM.search2'><p>QTL search by IM with Selective Genotyping</p></a></li>
<li><a href='#LOD.QTLdetect'><p>QTL Detect by LOD</p></a></li>
<li><a href='#LRTthre'><p>LRT Threshold</p></a></li>
<li><a href='#MIM.points'><p>QTL Short Distance Correction by MIM</p></a></li>
<li><a href='#MIM.points2'><p>QTL Short Distance Correction by MIM with Selective Genotyping</p></a></li>
<li><a href='#MIM.search'><p>QTL search by MIM</p></a></li>
<li><a href='#MIM.search2'><p>QTL search by MIM with Seletive Genotyping</p></a></li>
<li><a href='#progeny'><p>Progeny Simulation</p></a></li>
<li><a href='#Q.make'><p>Generate Q Matrix</p></a></li>
<li><a href='#Qhot'><p>QTL Hotspot</p></a></li>
<li><a href='#Qhot.EQF'><p>EQF Matrix Conversion</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>QTL Mapping and Hotspots Detection</td>
</tr>
<tr>
<td>Version:</td>
<td>2.1.0</td>
</tr>
<tr>
<td>Description:</td>
<td>
    For QTL mapping, this package comprises several functions designed to execute diverse 
    tasks, such as simulating or analyzing data, calculating significance thresholds, and 
    visualizing QTL mapping results. The single-QTL or multiple-QTL method, which enables 
    the fitting and comparison of various statistical models, is employed to analyze the 
    data for estimating QTL parameters. The models encompass linear regression, permutation 
    tests, normal mixture models, and truncated normal mixture models. The Gaussian stochastic 
    process is utilized to compute significance thresholds for QTL detection on a genetic 
    linkage map within experimental populations. Two types of data, complete genotyping, and 
    selective genotyping data from various experimental populations, including backcross, F2, 
    recombinant inbred (RI) populations, and advanced intercrossed (AI) populations, are 
    considered in the QTL mapping analysis. For QTL hotspot detection, statistical methods can 
    be developed based on either utilizing individual-level data or summarized data. We have 
    proposed a statistical framework capable of handling both individual-level data and 
    summarized QTL data for QTL hotspot detection. Our statistical framework can overcome the 
    underestimation of thresholds resulting from ignoring the correlation structure among 
    traits. Additionally, it can identify different types of hotspots with minimal computational 
    cost during the detection process. Here, we endeavor to furnish the R codes for our QTL 
    mapping and hotspot detection methods, intended for general use in genes, genomics, and 
    genetics studies. The QTL mapping methods for the complete and selective genotyping designs 
    are based on the multiple interval mapping (MIM) model proposed by Kao, C.-H. , Z.-B. Zeng 
    and R. D. Teasdale (1999) &lt;<a href="https://doi.org/10.1534%2Fgenetics.103.021642">doi:10.1534/genetics.103.021642</a>&gt; and H.-I Lee, H.-A. Ho and 
    C.-H. Kao (2014) &lt;<a href="https://doi.org/10.1534%2Fgenetics.114.168385">doi:10.1534/genetics.114.168385</a>&gt;, respectively. The QTL hotspot detection 
    analysis is based on the method by Wu, P.-Y., M.-.H. Yang, and C.-H. Kao (2021) 
    &lt;<a href="https://doi.org/10.1093%2Fg3journal%2Fjkab056">doi:10.1093/g3journal/jkab056</a>&gt;.</td>
</tr>
<tr>
<td>Imports:</td>
<td>mvtnorm, utils, stats, graphics, grDevices, gtools</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/py-chung/QTLEMM">https://github.com/py-chung/QTLEMM</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/py-chung/QTLEMM/issues">https://github.com/py-chung/QTLEMM/issues</a></td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.3.1</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-06-24 10:05:52 UTC; pingyuan</td>
</tr>
<tr>
<td>Author:</td>
<td>Ping-Yuan Chung [cre],
  Chen-Hung Kao [aut],
  Y.-T. Guo [aut],
  H.-N. Ho [aut],
  H.-I. Lee [aut],
  P.-Y. Wu [aut],
  M.-H. Yang [aut],
  M.-H. Zeng [aut]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Ping-Yuan Chung &lt;pychung@webmail.stat.sinica.edu.tw&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-06-25 09:00:06 UTC</td>
</tr>
</table>
<hr>
<h2 id='D.make'>Generate D Matrix</h2><span id='topic+D.make'></span>

<h3>Description</h3>

<p>Generate the genetic design matrix of specified QTL number and effects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>D.make(
  nQTL,
  type = "RI",
  a = TRUE,
  d = TRUE,
  aa = FALSE,
  dd = FALSE,
  ad = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="D.make_+3A_nqtl">nQTL</code></td>
<td>
<p>integer. The number of QTLs.</p>
</td></tr>
<tr><td><code id="D.make_+3A_type">type</code></td>
<td>
<p>character. The population type of the dataset. Includes
backcross (type=&quot;BC&quot;), advanced intercross population (type=&quot;AI&quot;), and
recombinant inbred population (type=&quot;RI&quot;). The default value is &quot;RI&quot;.</p>
</td></tr>
<tr><td><code id="D.make_+3A_a">a</code></td>
<td>
<p>integer or vector. A integer or vector to determines which
additive effects of QTLs will be considered in this design matrix. If
a=TRUE, the additive effect of all QTLs will be considered. If
a=FALSE, no additive effect will be considered.</p>
</td></tr>
<tr><td><code id="D.make_+3A_d">d</code></td>
<td>
<p>integer or vector. A integer or vector to determines which
dominant effects of QTLs will be considered in this design matrix. If
d=TRUE, the dominant effect of all QTLs will be considered.If
d=FALSE, no dominant effect will be considered.</p>
</td></tr>
<tr><td><code id="D.make_+3A_aa">aa</code></td>
<td>
<p>vector or matrix. The additive-by-additive interaction. Two
format can be used in this parameter. One format is a vector, where
every two elements indicate a combination of additive-by-additive
interaction. The other format is a 2*i matrix, where i is the number
of combinations of interaction, and each column indicates the two
interacting QTLs. Additionally, if aa=TRUE, all combinations of
additive-by-additive interaction will be considered. If aa=FALSE, no
additive-by-additive interaction will be considered.</p>
</td></tr>
<tr><td><code id="D.make_+3A_dd">dd</code></td>
<td>
<p>vector or matrix. The dominant-by-dominant interaction. The
format is the same as that in aa.</p>
</td></tr>
<tr><td><code id="D.make_+3A_ad">ad</code></td>
<td>
<p>vector or matrix. The additive-by-dominant interaction. The
format is the same as that in aa. Note that in each pair of QTLs, the
first element indicates the additive effect, and the second element
indicates the dominant effect.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The genetic design matrix, where the elements represent the coded
variables of the QTL effects. It is a g*p matrix, where g is the number
of possible QTL genotypes, and p is the number of effects in the MIM
model.
</p>


<h3>Note</h3>

<p>For the 'type' parameter, if type=&quot;BC&quot;, the design matrix exclusively
contains additive effects and additive-by-additive interactions. However,
if type=&quot;AI&quot; or type=&quot;RI&quot;, it encompasses additive and dominance effects
along with all interactions.
</p>
<p>For instance, when aa=c(1,3,2,4,5,6), it denotes that the interaction
between QTL1 and QTL3, the interaction between QTL2 and QTL4, and that
between QTL5 and QTL6 will be considered in the design matrix. Furthermore,
the matrix format can be expressed as aa=matrix(c(1,3,2,4,5,6),2,3).
Similarly, parameters DD and AD are also expressed in the same format.
</p>


<h3>References</h3>

<p>KAO, C.-H. and Z.-B. ZENG 1997 General formulas for obtaining the maximum
likelihood estimates and the asymptotic variance-covariance matrix in QTL
mapping when using the EM algorithm. Biometrics 53, 653-665. &lt;doi: 10.2307/2533965.&gt;
</p>
<p>KAO, C.-H., Z.-B. ZENG and R. D. TEASDALE 1999 Multiple interval mapping
for Quantitative Trait Loci. Genetics 152: 1203-1216. &lt;doi: 10.1093/genetics/152.3.1203&gt;
</p>


<h3>Examples</h3>

<pre><code class='language-R'>D.make(4, d = c(1,3,4), aa = c(1,2,2,3), dd = c(1,3,1,4), ad = c(1,2,2,1,2,3,3,4))

aa &lt;- matrix(c(1,2,3,4,4,5), 2, 3)
aa
D.make(5, type = "BC", a = c(1,3,4,5), aa = aa)
</code></pre>

<hr>
<h2 id='EM.MIM'>EM Algorithm for QTL MIM</h2><span id='topic+EM.MIM'></span>

<h3>Description</h3>

<p>Expectation-maximization algorithm for QTL multiple interval mapping.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>EM.MIM(
  D.matrix,
  cp.matrix,
  y,
  E.vector0 = NULL,
  X = NULL,
  beta0 = NULL,
  variance0 = NULL,
  crit = 10^-5,
  stop = 1000,
  conv = TRUE,
  console = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="EM.MIM_+3A_d.matrix">D.matrix</code></td>
<td>
<p>matrix. The design matrix of QTL effects is a g*p
matrix, where g is the number of possible QTL genotypes, and p is the
number of effects considered in the MIM model. This design matrix can
be conveniently generated using the function D.make().</p>
</td></tr>
<tr><td><code id="EM.MIM_+3A_cp.matrix">cp.matrix</code></td>
<td>
<p>matrix. The conditional probability matrix is an n*g
matrix, where n is the number of individuals, and g is the number of
possible genotypes of QTLs. This conditional probability matrix can
be easily generated using the function Q.make().</p>
</td></tr>
<tr><td><code id="EM.MIM_+3A_y">y</code></td>
<td>
<p>vector. A vector with n elements that contain the phenotype
values of individuals.</p>
</td></tr>
<tr><td><code id="EM.MIM_+3A_e.vector0">E.vector0</code></td>
<td>
<p>vector. The initial value for QTL effects. The
number of elements corresponds to the column dimension of the design
matrix. If E.vector0=NULL, the initial value for all effects will be
set to 0.</p>
</td></tr>
<tr><td><code id="EM.MIM_+3A_x">X</code></td>
<td>
<p>matrix. The design matrix of the fixed factors except for
QTL effects. It is an n*k matrix, where n is the number of
individuals, and k is the number of fixed factors. If X=NULL,
the matrix will be an n*1 matrix where all elements are 1.</p>
</td></tr>
<tr><td><code id="EM.MIM_+3A_beta0">beta0</code></td>
<td>
<p>vector. The initial value for effects of the fixed
factors. The number of elements corresponds to the column dimension
of the fixed factor design matrix.  If beta0=NULL, the initial value
will be set to the average of y.</p>
</td></tr>
<tr><td><code id="EM.MIM_+3A_variance0">variance0</code></td>
<td>
<p>numeric. The initial value for variance. If
variance0=NULL, the initial value will be set to the variance of
phenotype values.</p>
</td></tr>
<tr><td><code id="EM.MIM_+3A_crit">crit</code></td>
<td>
<p>numeric. The convergence criterion of EM algorithm.
The E and M steps will iterate until a convergence criterion is met.
It must be a value between 0 and 1.</p>
</td></tr>
<tr><td><code id="EM.MIM_+3A_stop">stop</code></td>
<td>
<p>numeric. The stopping criterion of EM algorithm. The E and
M steps will halt when the iteration number reaches the stopping
criterion, treating the algorithm as having failed to converge.</p>
</td></tr>
<tr><td><code id="EM.MIM_+3A_conv">conv</code></td>
<td>
<p>logical. If set to False, it will disregard the failure to
converge and output the last result obtained during the EM algorithm
before reaching the stopping criterion.</p>
</td></tr>
<tr><td><code id="EM.MIM_+3A_console">console</code></td>
<td>
<p>logical. Determines whether the process of the algorithm
will be displayed in the R console or not.</p>
</td></tr>
</table>


<h3>Value</h3>

<table>
<tr><td><code>E.vector</code></td>
<td>
<p>The QTL effects are calculated by the EM algorithm.</p>
</td></tr>
<tr><td><code>beta</code></td>
<td>
<p>The effects of the fixed factors are calculated by the EM
algorithm.</p>
</td></tr>
<tr><td><code>variance</code></td>
<td>
<p>The error variance is calculated by the EM algorithm.</p>
</td></tr>
<tr><td><code>PI.matrix</code></td>
<td>
<p>The posterior probabilities matrix after the
process of the EM algorithm.</p>
</td></tr>
<tr><td><code>log.likelihood</code></td>
<td>
<p>The log-likelihood value of this model.</p>
</td></tr>
<tr><td><code>LRT</code></td>
<td>
<p>The LRT statistic of this model.</p>
</td></tr>
<tr><td><code>R2</code></td>
<td>
<p>The coefficient of determination of this model. This
can be used as an estimate of heritability.</p>
</td></tr>
<tr><td><code>y.hat</code></td>
<td>
<p>The fitted values of trait values are calculated by
the estimated values from the EM algorithm.</p>
</td></tr>
<tr><td><code>iteration.number</code></td>
<td>
<p>The iteration number of the EM algorithm.</p>
</td></tr>
</table>


<h3>References</h3>

<p>KAO, C.-H. and Z.-B. ZENG 1997 General formulas for obtaining the maximum
likelihood estimates and the asymptotic variance-covariance matrix in QTL
mapping when using the EM algorithm. Biometrics 53, 653-665. &lt;doi: 10.2307/2533965.&gt;
</p>
<p>KAO, C.-H., Z.-B. ZENG and R. D. TEASDALE 1999 Multiple interval mapping
for Quantitative Trait Loci. Genetics 152: 1203-1216. &lt;doi: 10.1093/genetics/152.3.1203&gt;
</p>


<h3>See Also</h3>

<p><code><a href="#topic+D.make">D.make</a></code>
<code><a href="#topic+Q.make">Q.make</a></code>
<code><a href="#topic+EM.MIM2">EM.MIM2</a></code>
<code><a href="#topic+EM.MIMv">EM.MIMv</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># load the example data
load(system.file("extdata", "exampledata.RDATA", package = "QTLEMM"))

# run and result
D.matrix &lt;- D.make(3, type = "RI", aa = c(1, 3, 2, 3), dd = c(1, 2, 1, 3), ad = c(1, 2, 2, 3))
cp.matrix &lt;- Q.make(QTL, marker, geno, type = "RI", ng = 2)$cp.matrix
result &lt;- EM.MIM(D.matrix, cp.matrix, y)
result$E.vector
</code></pre>

<hr>
<h2 id='EM.MIM2'>EM Algorithm for QTL MIM with Selective Genotyping</h2><span id='topic+EM.MIM2'></span>

<h3>Description</h3>

<p>Expectation-maximization algorithm for QTL multiple interval mapping.
It can handle genotype data which is selective genotyping.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>EM.MIM2(
  QTL,
  marker,
  geno,
  D.matrix,
  cp.matrix = NULL,
  y,
  yu = NULL,
  sele.g = "n",
  tL = NULL,
  tR = NULL,
  type = "RI",
  ng = 2,
  cM = TRUE,
  E.vector0 = NULL,
  X = NULL,
  beta0 = NULL,
  variance0 = NULL,
  crit = 10^-5,
  stop = 1000,
  conv = TRUE,
  console = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="EM.MIM2_+3A_qtl">QTL</code></td>
<td>
<p>matrix. A q*2 matrix contains the QTL information, where the
row dimension 'q' represents the number of QTLs in the chromosomes. The
first column labels the chromosomes where the QTLs are located, and the
second column labels the positions of QTLs (in morgan (M) or centimorgan
(cM)).</p>
</td></tr>
<tr><td><code id="EM.MIM2_+3A_marker">marker</code></td>
<td>
<p>matrix. A k*2 matrix contains the marker information,
where the row dimension 'k' represents the number of markers in the
chromosomes. The first column labels the chromosomes where the markers
are located, and the second column labels the positions of markers (in
morgan (M) or centimorgan (cM)). It's important to note that chromosomes
and positions must be sorted in order.</p>
</td></tr>
<tr><td><code id="EM.MIM2_+3A_geno">geno</code></td>
<td>
<p>matrix. A n*k matrix contains the genotypes of k markers
for n individuals. The marker genotypes of P1 homozygote (MM),
heterozygote (Mm), and P2 homozygote (mm) are coded as 2, 1, and 0,
respectively, with NA indicating missing values.</p>
</td></tr>
<tr><td><code id="EM.MIM2_+3A_d.matrix">D.matrix</code></td>
<td>
<p>matrix. The design matrix of QTL effects is a g*p
matrix, where g is the number of possible QTL genotypes, and p is the
number of effects considered in the MIM model. This design matrix can
be conveniently generated using the function D.make().</p>
</td></tr>
<tr><td><code id="EM.MIM2_+3A_cp.matrix">cp.matrix</code></td>
<td>
<p>matrix. The conditional probability matrix is an
n*g matrix, where n is the number of genotyped individuals, and g is
the number of possible genotypes of QTLs. If cp.matrix=NULL, the
function will calculate the conditional probability matrix for selective
genotyping.</p>
</td></tr>
<tr><td><code id="EM.MIM2_+3A_y">y</code></td>
<td>
<p>vector. A vector that contains the phenotype values of
individuals with genotypes.</p>
</td></tr>
<tr><td><code id="EM.MIM2_+3A_yu">yu</code></td>
<td>
<p>vector. A vector that contains the phenotype values of
individuals without genotypes.</p>
</td></tr>
<tr><td><code id="EM.MIM2_+3A_sele.g">sele.g</code></td>
<td>
<p>character. Determines the type of data being analyzed:
If sele.g=&quot;n&quot;, it considers the data as complete genotyping data. If
sele.g=&quot;f&quot;, it treats the data as selective genotyping data and utilizes
the proposed corrected frequency model (Lee 2014) for analysis; If
sele.g=&quot;t&quot;, it considers the data as selective genotyping data and uses
the truncated model (Lee 2014) for analysis; If sele.g=&quot;p&quot;, it treats
the data as selective genotyping data and uses the population
frequency-based model (Lee 2014) for analysis. Note that the 'yu'
argument must be provided when sele.g=&quot;f&quot; or &quot;p&quot;.</p>
</td></tr>
<tr><td><code id="EM.MIM2_+3A_tl">tL</code></td>
<td>
<p>numeric. The lower truncation point of phenotype value when
sele.g=&quot;t&quot;. When sele.g=&quot;t&quot; and tL=NULL, the 'yu' argument must be
provided. In this case, the function will consider the minimum of 'yu'
as the lower truncation point.</p>
</td></tr>
<tr><td><code id="EM.MIM2_+3A_tr">tR</code></td>
<td>
<p>numeric. The upper truncation point of phenotype value when
sele.g=&quot;t&quot;. When sele.g=&quot;t&quot; and tR=NULL, the 'yu' argument must be
provided. In this case, the function will consider the maximum of 'yu'
as the upper truncation point.</p>
</td></tr>
<tr><td><code id="EM.MIM2_+3A_type">type</code></td>
<td>
<p>character. The population type of the dataset. Includes
backcross (type=&quot;BC&quot;), advanced intercross population (type=&quot;AI&quot;), and
recombinant inbred population (type=&quot;RI&quot;). The default value is &quot;RI&quot;.</p>
</td></tr>
<tr><td><code id="EM.MIM2_+3A_ng">ng</code></td>
<td>
<p>integer. The generation number of the population type. For
instance, in a BC1 population where type=&quot;BC&quot;, ng=1; in an AI F3
population where type=&quot;AI&quot;, ng=3.</p>
</td></tr>
<tr><td><code id="EM.MIM2_+3A_cm">cM</code></td>
<td>
<p>logical. Specify the unit of marker position. If cM=TRUE, it
denotes centimorgan; if cM=FALSE, it denotes morgan.</p>
</td></tr>
<tr><td><code id="EM.MIM2_+3A_e.vector0">E.vector0</code></td>
<td>
<p>vector. The initial value for QTL effects. The
number of elements corresponds to the column dimension of the design
matrix. If E.vector0=NULL, the initial value for all effects will be
set to 0.</p>
</td></tr>
<tr><td><code id="EM.MIM2_+3A_x">X</code></td>
<td>
<p>matrix. The design matrix of the fixed factors except for
QTL effects. It is an n*k matrix, where n is the number of
individuals, and k is the number of fixed factors. If X=NULL,
the matrix will be an n*1 matrix where all elements are 1.</p>
</td></tr>
<tr><td><code id="EM.MIM2_+3A_beta0">beta0</code></td>
<td>
<p>vector. The initial value for effects of the fixed
factors. The number of elements corresponds to the column dimension
of the fixed factor design matrix.  If beta0=NULL, the initial value
will be set to the average of y.</p>
</td></tr>
<tr><td><code id="EM.MIM2_+3A_variance0">variance0</code></td>
<td>
<p>numeric. The initial value for variance. If
variance0=NULL, the initial value will be set to the variance of
phenotype values.</p>
</td></tr>
<tr><td><code id="EM.MIM2_+3A_crit">crit</code></td>
<td>
<p>numeric. The convergence criterion of EM algorithm.
The E and M steps will iterate until a convergence criterion is met.
It must be a value between 0 and 1.</p>
</td></tr>
<tr><td><code id="EM.MIM2_+3A_stop">stop</code></td>
<td>
<p>numeric. The stopping criterion of EM algorithm. The E and
M steps will halt when the iteration number reaches the stopping
criterion, treating the algorithm as having failed to converge.</p>
</td></tr>
<tr><td><code id="EM.MIM2_+3A_conv">conv</code></td>
<td>
<p>logical. If set to False, it will disregard the failure to
converge and output the last result obtained during the EM algorithm
before reaching the stopping criterion.</p>
</td></tr>
<tr><td><code id="EM.MIM2_+3A_console">console</code></td>
<td>
<p>logical. Determines whether the process of the algorithm
will be displayed in the R console or not.</p>
</td></tr>
</table>


<h3>Value</h3>

<table>
<tr><td><code>QTL</code></td>
<td>
<p>The QTL imformation of this analysis.</p>
</td></tr>
<tr><td><code>E.vector</code></td>
<td>
<p>The QTL effects are calculated by the EM algorithm.</p>
</td></tr>
<tr><td><code>beta</code></td>
<td>
<p>The effects of the fixed factors are calculated by the EM
algorithm.</p>
</td></tr>
<tr><td><code>variance</code></td>
<td>
<p>The variance is calculated by the EM algorithm.</p>
</td></tr>
<tr><td><code>PI.matrix</code></td>
<td>
<p>The posterior probabilities matrix after the
process of the EM algorithm.</p>
</td></tr>
<tr><td><code>log.likelihood</code></td>
<td>
<p>The log-likelihood value of this model.</p>
</td></tr>
<tr><td><code>LRT</code></td>
<td>
<p>The LRT statistic of this model.</p>
</td></tr>
<tr><td><code>R2</code></td>
<td>
<p>The coefficient of determination of this model. This
can be used as an estimate of heritability.</p>
</td></tr>
<tr><td><code>y.hat</code></td>
<td>
<p>The fitted values of trait values with genotyping are
calculated by the estimated values from the EM algorithm.</p>
</td></tr>
<tr><td><code>yu.hat</code></td>
<td>
<p>The fitted values of trait values without genotyping
are calculated by the estimated values from the EM algorithm.</p>
</td></tr>
<tr><td><code>iteration.number</code></td>
<td>
<p>The iteration number of the EM algorithm.</p>
</td></tr>
<tr><td><code>model</code></td>
<td>
<p>The model of this analysis, contains complete a
genotyping model, a proposed model, a truncated model, and a
frequency-based model.</p>
</td></tr>
</table>


<h3>References</h3>

<p>KAO, C.-H. and Z.-B. ZENG 1997 General formulas for obtaining the maximum
likelihood estimates and the asymptotic variance-covariance matrix in QTL
mapping when using the EM algorithm. Biometrics 53, 653-665. &lt;doi: 10.2307/2533965.&gt;
</p>
<p>KAO, C.-H., Z.-B. ZENG and R. D. TEASDALE 1999 Multiple interval mapping
for Quantitative Trait Loci. Genetics 152: 1203-1216. &lt;doi: 10.1093/genetics/152.3.1203&gt;
</p>
<p>H.-I LEE, H.-A. HO and C.-H. KAO 2014 A new simple method for improving
QTL mapping under selective genotyping. Genetics 198: 1685-1698. &lt;doi: 10.1534/genetics.114.168385.&gt;
</p>


<h3>See Also</h3>

<p><code><a href="#topic+D.make">D.make</a></code>
<code><a href="#topic+Q.make">Q.make</a></code>
<code><a href="#topic+EM.MIM">EM.MIM</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># load the example data
load(system.file("extdata", "exampledata.RDATA", package = "QTLEMM"))

# make the seletive genotyping data
ys &lt;- y[y &gt; quantile(y)[4] | y &lt; quantile(y)[2]]
yu &lt;- y[y &gt;= quantile(y)[2] &amp; y &lt;= quantile(y)[4]]
geno.s &lt;- geno[y &gt; quantile(y)[4] | y &lt; quantile(y)[2],]

# run and result
D.matrix &lt;- D.make(3, type = "RI", aa = c(1, 3, 2, 3), dd = c(1, 2, 1, 3), ad = c(1, 2, 2, 3))
result &lt;- EM.MIM2(QTL, marker, geno.s, D.matrix, y = ys, yu = yu, sele.g = "f")
result$E.vector
</code></pre>

<hr>
<h2 id='EM.MIMv'>EM Algorithm for QTL MIM with Asymptotic Variance-Covariance Matrix</h2><span id='topic+EM.MIMv'></span>

<h3>Description</h3>

<p>Expectation-maximization algorithm for QTL multiple interval mapping.
It can obtain the asymptotic variance-covariance matrix of the result
from the EM algorithm and the approximate solution of variances of
parameters.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>EM.MIMv(
  QTL,
  marker,
  geno,
  D.matrix,
  cp.matrix = NULL,
  y,
  type = "RI",
  ng = 2,
  cM = TRUE,
  E.vector0 = NULL,
  X = NULL,
  beta0 = NULL,
  variance0 = NULL,
  crit = 10^-5,
  stop = 1000,
  conv = TRUE,
  var.pos = TRUE,
  console = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="EM.MIMv_+3A_qtl">QTL</code></td>
<td>
<p>matrix. A q*2 matrix contains the QTL information, where the
row dimension 'q' represents the number of QTLs in the chromosomes. The
first column labels the chromosomes where the QTLs are located, and the
second column labels the positions of QTLs (in morgan (M) or centimorgan
(cM)).</p>
</td></tr>
<tr><td><code id="EM.MIMv_+3A_marker">marker</code></td>
<td>
<p>matrix. A k*2 matrix contains the marker information,
where the row dimension 'k' represents the number of markers in the
chromosomes. The first column labels the chromosomes where the markers
are located, and the second column labels the positions of markers (in
morgan (M) or centimorgan (cM)). It's important to note that chromosomes
and positions must be sorted in order.</p>
</td></tr>
<tr><td><code id="EM.MIMv_+3A_geno">geno</code></td>
<td>
<p>matrix. A n*k matrix contains the genotypes of k markers
for n individuals. The marker genotypes of P1 homozygote (MM),
heterozygote (Mm), and P2 homozygote (mm) are coded as 2, 1, and 0,
respectively, with NA indicating missing values.</p>
</td></tr>
<tr><td><code id="EM.MIMv_+3A_d.matrix">D.matrix</code></td>
<td>
<p>matrix. The design matrix of QTL effects is a g*p
matrix, where g is the number of possible QTL genotypes, and p is the
number of effects considered in the MIM model. The design matrix can
be easily generated by the function D.make().</p>
</td></tr>
<tr><td><code id="EM.MIMv_+3A_cp.matrix">cp.matrix</code></td>
<td>
<p>matrix. The conditional probability matrix is an
n*g matrix, where n is the number of genotyped individuals, and g is
the number of possible genotypes of QTLs. If cp.matrix=NULL, the
function will calculate the conditional probability matrix, and markers
whose positions are the same as QTLs will be skipped.</p>
</td></tr>
<tr><td><code id="EM.MIMv_+3A_y">y</code></td>
<td>
<p>vector. A vector with n elements that contain the phenotype
values of individuals.</p>
</td></tr>
<tr><td><code id="EM.MIMv_+3A_type">type</code></td>
<td>
<p>character. The population type of the dataset. Includes
backcross (type=&quot;BC&quot;), advanced intercross population (type=&quot;AI&quot;), and
recombinant inbred population (type=&quot;RI&quot;). The default value is &quot;RI&quot;.</p>
</td></tr>
<tr><td><code id="EM.MIMv_+3A_ng">ng</code></td>
<td>
<p>integer. The generation number of the population type. For
instance, in a BC1 population where type=&quot;BC&quot;, ng=1; in an AI F3
population where type=&quot;AI&quot;, ng=3.</p>
</td></tr>
<tr><td><code id="EM.MIMv_+3A_cm">cM</code></td>
<td>
<p>logical. Specify the unit of marker position. If cM=TRUE, it
denotes centimorgan; if cM=FALSE, it denotes morgan.</p>
</td></tr>
<tr><td><code id="EM.MIMv_+3A_e.vector0">E.vector0</code></td>
<td>
<p>vector. The initial value for QTL effects. The
number of elements corresponds to the column dimension of the design
matrix. If E.vector0=NULL, the initial value for all effects will be
set to 0.</p>
</td></tr>
<tr><td><code id="EM.MIMv_+3A_x">X</code></td>
<td>
<p>matrix. The design matrix of the fixed factors except for
QTL effects. It is an n*k matrix, where n is the number of
individuals, and k is the number of fixed factors. If X=NULL,
the matrix will be an n*1 matrix where all elements are 1.</p>
</td></tr>
<tr><td><code id="EM.MIMv_+3A_beta0">beta0</code></td>
<td>
<p>vector. The initial value for effects of the fixed
factors. The number of elements corresponds to the column dimension
of the fixed factor design matrix.  If beta0=NULL, the initial value
will be set to the average of y.</p>
</td></tr>
<tr><td><code id="EM.MIMv_+3A_variance0">variance0</code></td>
<td>
<p>numeric. The initial value for variance. If
variance0=NULL, the initial value will be the variance of
phenotype values.</p>
</td></tr>
<tr><td><code id="EM.MIMv_+3A_crit">crit</code></td>
<td>
<p>numeric. The convergence criterion of EM algorithm.
The E and M steps will iterate until a convergence criterion is met.
It must be a value between 0 and 1.</p>
</td></tr>
<tr><td><code id="EM.MIMv_+3A_stop">stop</code></td>
<td>
<p>numeric. The stopping criterion of EM algorithm. The E and
M steps will halt when the iteration number reaches the stopping
criterion, treating the algorithm as having failed to converge.</p>
</td></tr>
<tr><td><code id="EM.MIMv_+3A_conv">conv</code></td>
<td>
<p>logical. If set to False, it will disregard the failure to
converge and output the last result obtained during the EM algorithm
before reaching the stopping criterion.</p>
</td></tr>
<tr><td><code id="EM.MIMv_+3A_var.pos">var.pos</code></td>
<td>
<p>logical. Determines whether the variance of the position
of QTLs will be considered in the asymptotic variance-covariance matrix
or not.</p>
</td></tr>
<tr><td><code id="EM.MIMv_+3A_console">console</code></td>
<td>
<p>logical. Determines whether the process of the algorithm
will be displayed in the R console or not.</p>
</td></tr>
</table>


<h3>Value</h3>

<table>
<tr><td><code>E.vector</code></td>
<td>
<p>The QTL effects are calculated by the EM algorithm.</p>
</td></tr>
<tr><td><code>beta</code></td>
<td>
<p>The effects of the fixed factors are calculated by the EM
algorithm.</p>
</td></tr>
<tr><td><code>variance</code></td>
<td>
<p>The error variance is calculated by the EM algorithm.</p>
</td></tr>
<tr><td><code>PI.matrix</code></td>
<td>
<p>The posterior probabilities matrix after the
process of the EM algorithm.</p>
</td></tr>
<tr><td><code>log.likelihood</code></td>
<td>
<p>The log-likelihood value of this model.</p>
</td></tr>
<tr><td><code>LRT</code></td>
<td>
<p>The LRT statistic of this model.</p>
</td></tr>
<tr><td><code>R2</code></td>
<td>
<p>The coefficient of determination of this model. This
can be used as an estimate of heritability.</p>
</td></tr>
<tr><td><code>y.hat</code></td>
<td>
<p>The fitted values of trait values are calculated by
the estimated values from the EM algorithm.</p>
</td></tr>
<tr><td><code>iteration.number</code></td>
<td>
<p>The iteration number of the EM algorithm.</p>
</td></tr>
<tr><td><code>avc.matrix</code></td>
<td>
<p>The asymptotic variance-covariance matrix contains
position of QTLs, QTL effects, variance, and fix effects.</p>
</td></tr>
<tr><td><code>EMvar</code></td>
<td>
<p>The asymptotic approximate variances include the position
of QTLs, QTL effects, variance, and fixed effects. Parameters for which
the approximate variance cannot be calculated will be shown as 0. The
approximate variance of the position of QTLs is calculated in morgan.</p>
</td></tr>
</table>


<h3>References</h3>

<p>KAO, C.-H. and Z.-B. ZENG 1997 General formulas for obtaining the maximum
likelihood estimates and the asymptotic variance-covariance matrix in QTL
mapping when using the EM algorithm. Biometrics 53, 653-665. &lt;doi: 10.2307/2533965.&gt;
</p>
<p>KAO, C.-H., Z.-B. ZENG and R. D. TEASDALE 1999 Multiple interval mapping
for Quantitative Trait Loci. Genetics 152: 1203-1216. &lt;doi: 10.1093/genetics/152.3.1203&gt;
</p>


<h3>See Also</h3>

<p><code><a href="#topic+D.make">D.make</a></code>
<code><a href="#topic+Q.make">Q.make</a></code>
<code><a href="#topic+EM.MIM">EM.MIM</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># load the example data
load(system.file("extdata", "exampledata.RDATA", package = "QTLEMM"))

# run and result
D.matrix &lt;- D.make(3, type = "RI", aa = c(1, 3, 2, 3), dd = c(1, 2, 1, 3), ad = c(1, 2, 2, 3))
result &lt;- EM.MIMv(QTL, marker, geno, D.matrix, cp.matrix = NULL, y)
result$EMvar
</code></pre>

<hr>
<h2 id='EQF.permu'>EQF Permutation</h2><span id='topic+EQF.permu'></span>

<h3>Description</h3>

<p>The EQF matrix cluster permutation process for QTL hotspot detection.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>EQF.permu(
  LOD.QTLdetect.result,
  ptime = 1000,
  alpha = 0.05,
  Q = TRUE,
  console = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="EQF.permu_+3A_lod.qtldetect.result">LOD.QTLdetect.result</code></td>
<td>
<p>list. The data list of the output from
LOD.QTLdetect().</p>
</td></tr>
<tr><td><code id="EQF.permu_+3A_ptime">ptime</code></td>
<td>
<p>integer. The permutation times.</p>
</td></tr>
<tr><td><code id="EQF.permu_+3A_alpha">alpha</code></td>
<td>
<p>numeric. The type 1 error rate of detecting the hotspot.</p>
</td></tr>
<tr><td><code id="EQF.permu_+3A_q">Q</code></td>
<td>
<p>logical. When set to TRUE, the function will additionally carry
out the permutation of the Q method as the control group, which will be
indicated as 'B' in the output.</p>
</td></tr>
<tr><td><code id="EQF.permu_+3A_console">console</code></td>
<td>
<p>logical. Determines whether the process of the algorithm
will be displayed in the R console or not.</p>
</td></tr>
</table>


<h3>Value</h3>

<table>
<tr><td><code>EQF.matrix</code></td>
<td>
<p>The matrix denotes the EQF value of each bin.</p>
</td></tr>
<tr><td><code>bin</code></td>
<td>
<p>The bin information matrix used in this analysis.</p>
</td></tr>
<tr><td><code>LOD.threshold</code></td>
<td>
<p>The LOD threshold used in this analysis.</p>
</td></tr>
<tr><td><code>cluster.number</code></td>
<td>
<p>The number of QTLs in each cluster group.</p>
</td></tr>
<tr><td><code>cluster.id</code></td>
<td>
<p>The serial number of traits in each cluster group.</p>
</td></tr>
<tr><td><code>cluster.matrix</code></td>
<td>
<p>The new EQF matrix after the clustering process.</p>
</td></tr>
<tr><td><code>permu.matrix.cluster</code></td>
<td>
<p>The permutation result of the clustering
method, which has been sorted by order.</p>
</td></tr>
<tr><td><code>permu.matrix.Q</code></td>
<td>
<p>The permutation result of the Q method, which has
been sorted by order.</p>
</td></tr>
<tr><td><code>EQF.threshold</code></td>
<td>
<p>The EQF threshold is calculated from the
permutation process.</p>
</td></tr>
</table>


<h3>References</h3>

<p>Wu, P.-Y., M.-.H. Yang, and C.-H. KAO 2021 A Statistical Framework
for QTL Hotspot Detection. G3: Genes, Genomes, Genetics: jkab056. &lt;doi: 10.1093/g3journal/jkab056&gt;
</p>


<h3>See Also</h3>

<p><code><a href="#topic+LOD.QTLdetect">LOD.QTLdetect</a></code>
<code><a href="#topic+EQF.plot">EQF.plot</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># load the example data
load(system.file("extdata", "LODexample.RDATA", package = "QTLEMM"))

# run and result
result &lt;- EQF.permu(LOD.QTLdetect.result, ptime = 50)
result$cluster.number
</code></pre>

<hr>
<h2 id='EQF.plot'>EQF plot</h2><span id='topic+EQF.plot'></span>

<h3>Description</h3>

<p>Generate an EQF plot based on the result of the permutation process
used to detect the QTL hotspot.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>EQF.plot(result, plot.all = TRUE, plot.chr = TRUE, plot.main = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="EQF.plot_+3A_result">result</code></td>
<td>
<p>list. The data list of the output from LOD.QTLdetect(),
EQF.permu(), or Qhot.EQF().</p>
</td></tr>
<tr><td><code id="EQF.plot_+3A_plot.all">plot.all</code></td>
<td>
<p>logical. When set to TRUE, it directs the function to
output one figure of the EQF values over the bins.</p>
</td></tr>
<tr><td><code id="EQF.plot_+3A_plot.chr">plot.chr</code></td>
<td>
<p>logical. When set to TRUE, it instructs the function to
output the figures of the EQF values over the bins for each chromosome.</p>
</td></tr>
<tr><td><code id="EQF.plot_+3A_plot.main">plot.main</code></td>
<td>
<p>logical of character. When set to TRUE, it will use the
default title on the plot. When set to FALSE, it will be no title on the
plot. Users can also use this argument to set their own title.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>One or several EQF plots.
</p>


<h3>References</h3>

<p>Wu, P.-Y., M.-.H. Yang, and C.-H. KAO 2021 A Statistical Framework
for QTL Hotspot Detection. G3: Genes, Genomes, Genetics: jkab056. &lt;doi: 10.1093/g3journal/jkab056&gt;
</p>


<h3>See Also</h3>

<p><code><a href="#topic+LOD.QTLdetect">LOD.QTLdetect</a></code>
<code><a href="#topic+EQF.permu">EQF.permu</a></code>
<code><a href="#topic+Qhot.EQF">Qhot.EQF</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># load the example data
load(system.file("extdata", "LODexample.RDATA", package = "QTLEMM"))

# run and result
EQF.plot(LOD.QTLdetect.result)
EQF.plot(EQF.permu.result)
</code></pre>

<hr>
<h2 id='IM.search'>QTL search by IM</h2><span id='topic+IM.search'></span>

<h3>Description</h3>

<p>Expectation-maximization algorithm for QTL interval mapping to search
for possible position of QTL in all chromosomes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>IM.search(
  marker,
  geno,
  y,
  method = "EM",
  type = "RI",
  D.matrix = NULL,
  ng = 2,
  cM = TRUE,
  speed = 1,
  crit = 10^-5,
  d.eff = FALSE,
  LRT.thre = TRUE,
  simu = 1000,
  alpha = 0.05,
  detect = TRUE,
  QTLdist = 15,
  plot.all = TRUE,
  plot.chr = TRUE,
  console = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="IM.search_+3A_marker">marker</code></td>
<td>
<p>matrix. A k*2 matrix contains the marker information,
where the row dimension 'k' represents the number of markers in the
chromosomes. The first column labels the chromosomes where the markers
are located, and the second column labels the positions of markers (in
morgan (M) or centimorgan (cM)). It's important to note that chromosomes
and positions must be sorted in order.</p>
</td></tr>
<tr><td><code id="IM.search_+3A_geno">geno</code></td>
<td>
<p>matrix. A n*k matrix contains the genotypes of k markers
for n individuals. The marker genotypes of P1 homozygote (MM),
heterozygote (Mm), and P2 homozygote (mm) are coded as 2, 1, and 0,
respectively, with NA indicating missing values.</p>
</td></tr>
<tr><td><code id="IM.search_+3A_y">y</code></td>
<td>
<p>vector. A vector with n elements contains the phenotype values
of individuals.</p>
</td></tr>
<tr><td><code id="IM.search_+3A_method">method</code></td>
<td>
<p>character. When method=&quot;EM&quot;, it indicates that the interval
mapping method by Lander and Botstein (1989) is used in the analysis.
Conversely, when method=&quot;REG&quot;, it indicates that the approximate regression
interval mapping method by Haley and Knott (1992) is used in the analysis.</p>
</td></tr>
<tr><td><code id="IM.search_+3A_type">type</code></td>
<td>
<p>character. The population type of the dataset. Includes
backcross (type=&quot;BC&quot;), advanced intercross population (type=&quot;AI&quot;), and
recombinant inbred population (type=&quot;RI&quot;). The default value is &quot;RI&quot;.</p>
</td></tr>
<tr><td><code id="IM.search_+3A_d.matrix">D.matrix</code></td>
<td>
<p>matrix. The design matrix of the IM model. If D.matrix=NULL,
the design matrix will be constructed using Cockerham’s model: In BC
population, it is a 2*1 matrix with values 0.5 and -0.5 for the additive
effect; In RI or AI population, it is a 3*2 matrix. The first column
consists of 1, 0, and -1 for the additive effect, and the second column
consists of 0.5, -0.5, and 0.5 for the dominant effect.</p>
</td></tr>
<tr><td><code id="IM.search_+3A_ng">ng</code></td>
<td>
<p>integer. The generation number of the population type. For
instance, in a BC1 population where type=&quot;BC&quot;, ng=1; in an AI F3
population where type=&quot;AI&quot;, ng=3.</p>
</td></tr>
<tr><td><code id="IM.search_+3A_cm">cM</code></td>
<td>
<p>logical. Specify the unit of marker position. If cM=TRUE, it
denotes centimorgan; if cM=FALSE, it denotes morgan.</p>
</td></tr>
<tr><td><code id="IM.search_+3A_speed">speed</code></td>
<td>
<p>numeric. The walking speed of the QTL search (in cM).</p>
</td></tr>
<tr><td><code id="IM.search_+3A_crit">crit</code></td>
<td>
<p>numeric. The convergence criterion of EM algorithm.
The E and M steps will iterate until a convergence criterion is met.
It must be a value between 0 and 1.</p>
</td></tr>
<tr><td><code id="IM.search_+3A_d.eff">d.eff</code></td>
<td>
<p>logical. Specifies whether the dominant effect will be
considered in the parameter estimation for AI or RI population.</p>
</td></tr>
<tr><td><code id="IM.search_+3A_lrt.thre">LRT.thre</code></td>
<td>
<p>logical or numeric. If set to TRUE, the LRT threshold
will be computed based on the Gaussian stochastic process (Kao and Ho 2012).
Alternatively, users can input a numerical value as the LRT threshold to
evaluate the significance of QTL detection.</p>
</td></tr>
<tr><td><code id="IM.search_+3A_simu">simu</code></td>
<td>
<p>integer. Determines the number of simulation samples that
will be used to compute the LRT threshold using the Gaussian process.
It must be a value between 50 and 10^8.</p>
</td></tr>
<tr><td><code id="IM.search_+3A_alpha">alpha</code></td>
<td>
<p>numeric. The type I error rate for the LRT threshold.</p>
</td></tr>
<tr><td><code id="IM.search_+3A_detect">detect</code></td>
<td>
<p>logical. Determines whether the significant QTL, whose LRT
statistic is larger than the LRT threshold, will be displayed in the
output dataset or not.</p>
</td></tr>
<tr><td><code id="IM.search_+3A_qtldist">QTLdist</code></td>
<td>
<p>numeric. The minimum distance (in cM) among different
linked significant QTL.</p>
</td></tr>
<tr><td><code id="IM.search_+3A_plot.all">plot.all</code></td>
<td>
<p>logical. When set to TRUE, it directs the function to
output the profile of LRT statistics for the genome in one figure.</p>
</td></tr>
<tr><td><code id="IM.search_+3A_plot.chr">plot.chr</code></td>
<td>
<p>logical. When set to TRUE, it instructs the function to
output the profile of LRT statistics for the chromosomes.</p>
</td></tr>
<tr><td><code id="IM.search_+3A_console">console</code></td>
<td>
<p>logical. Determines whether the process of the algorithm
will be displayed in the R console or not.</p>
</td></tr>
</table>


<h3>Value</h3>

<table>
<tr><td><code>effect</code></td>
<td>
<p>The estimated effects and LRT statistics of all positions.</p>
</td></tr>
<tr><td><code>LRT.threshold</code></td>
<td>
<p>The LRT threshold value is computed for the data using
the Gaussian stochastic process (Kuo 2011; Kao and Ho 2012).</p>
</td></tr>
<tr><td><code>detect.QTL</code></td>
<td>
<p>The positions, effects, and LRT statistics of the detected
QTL are significant using the obtained LRT threshold value.</p>
</td></tr>
</table>
<p>Graphical outputs including LOD value and effect of each position.
</p>


<h3>References</h3>

<p>KAO, C.-H. and Z.-B. ZENG 1997 General formulas for obtaining the maximum
likelihood estimates and the asymptotic variance-covariance matrix in QTL
mapping when using the EM algorithm. Biometrics 53, 653-665. &lt;doi: 10.2307/2533965.&gt;
</p>
<p>KAO, C.-H., Z.-B. ZENG and R. D. TEASDALE 1999 Multiple interval mapping
for Quantitative Trait Loci. Genetics 152: 1203-1216. &lt;doi: 10.1093/genetics/152.3.1203&gt;
</p>
<p>KAO, C.-H. and H.-A. Ho 2012 A score-statistic approach for determining
threshold values in QTL mapping. Frontiers in Bioscience. E4, 2670-2682. &lt;doi: 10.2741/e582&gt;
</p>


<h3>See Also</h3>

<p><code><a href="#topic+EM.MIM">EM.MIM</a></code>
<code><a href="#topic+IM.search2">IM.search2</a></code>
<code><a href="#topic+LRTthre">LRTthre</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># load the example data
load(system.file("extdata", "exampledata.RDATA", package = "QTLEMM"))

# run and result
result &lt;- IM.search(marker, geno, y, type = "RI", ng = 2, speed = 7, crit = 10^-3, LRT.thre = 10)
result$detect.QTL
</code></pre>

<hr>
<h2 id='IM.search2'>QTL search by IM with Selective Genotyping</h2><span id='topic+IM.search2'></span>

<h3>Description</h3>

<p>Expectation-maximization algorithm for QTL interval mapping to search
for possible positions of QTL in all chromosomes. It can handle genotype
data which is selective genotyping.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>IM.search2(
  marker,
  geno,
  y,
  yu = NULL,
  sele.g = "n",
  tL = NULL,
  tR = NULL,
  method = "EM",
  type = "RI",
  D.matrix = NULL,
  ng = 2,
  cM = TRUE,
  speed = 1,
  crit = 10^-5,
  d.eff = FALSE,
  LRT.thre = TRUE,
  simu = 1000,
  alpha = 0.05,
  detect = TRUE,
  QTLdist = 15,
  plot.all = TRUE,
  plot.chr = TRUE,
  console = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="IM.search2_+3A_marker">marker</code></td>
<td>
<p>matrix. A k*2 matrix contains the marker information,
where the row dimension 'k' represents the number of markers in the
chromosomes. The first column labels the chromosomes where the markers
are located, and the second column labels the positions of markers (in
morgan (M) or centimorgan (cM)). It's important to note that chromosomes
and positions must be sorted in order.</p>
</td></tr>
<tr><td><code id="IM.search2_+3A_geno">geno</code></td>
<td>
<p>matrix. A n*k matrix contains the genotypes of k markers
for n individuals. The marker genotypes of P1 homozygote (MM),
heterozygote (Mm), and P2 homozygote (mm) are coded as 2, 1, and 0,
respectively, with NA indicating missing values.</p>
</td></tr>
<tr><td><code id="IM.search2_+3A_y">y</code></td>
<td>
<p>vector. A vector that contains the phenotype values of
individuals with genotypes.</p>
</td></tr>
<tr><td><code id="IM.search2_+3A_yu">yu</code></td>
<td>
<p>vector. A vector that contains the phenotype values of
individuals without genotypes.</p>
</td></tr>
<tr><td><code id="IM.search2_+3A_sele.g">sele.g</code></td>
<td>
<p>character. Determines the type of data being analyzed:
If sele.g=&quot;n&quot;, it considers the data as complete genotyping data. If
sele.g=&quot;f&quot;, it treats the data as selective genotyping data and utilizes
the proposed corrected frequency model (Lee 2014) for analysis; If
sele.g=&quot;t&quot;, it considers the data as selective genotyping data and uses
the truncated model (Lee 2014) for analysis; If sele.g=&quot;p&quot;, it treats
the data as selective genotyping data and uses the population
frequency-based model (Lee 2014) for analysis. Note that the 'yu'
argument must be provided when sele.g=&quot;f&quot; or &quot;p&quot;.</p>
</td></tr>
<tr><td><code id="IM.search2_+3A_tl">tL</code></td>
<td>
<p>numeric. The lower truncation point of phenotype value when
sele.g=&quot;t&quot;. When sele.g=&quot;t&quot; and tL=NULL, the 'yu' argument must be
provided. In this case, the function will consider the minimum of 'yu'
as the lower truncation point.</p>
</td></tr>
<tr><td><code id="IM.search2_+3A_tr">tR</code></td>
<td>
<p>numeric. The upper truncation point of phenotype value when
sele.g=&quot;t&quot;. When sele.g=&quot;t&quot; and tR=NULL, the 'yu' argument must be
provided. In this case, the function will consider the maximum of 'yu'
as the upper truncation point.</p>
</td></tr>
<tr><td><code id="IM.search2_+3A_method">method</code></td>
<td>
<p>character. When method=&quot;EM&quot;, it indicates that the interval
mapping method by Lander and Botstein (1989) is used in the analysis.
Conversely, when method=&quot;REG&quot;, it indicates that the approximate regression
interval mapping method by Haley and Knott (1992) is used in the analysis.</p>
</td></tr>
<tr><td><code id="IM.search2_+3A_type">type</code></td>
<td>
<p>character. The population type of the dataset. Includes
backcross (type=&quot;BC&quot;), advanced intercross population (type=&quot;AI&quot;), and
recombinant inbred population (type=&quot;RI&quot;). The default value is &quot;RI&quot;.</p>
</td></tr>
<tr><td><code id="IM.search2_+3A_d.matrix">D.matrix</code></td>
<td>
<p>matrix. The design matrix of the IM model. If D.matrix=NULL,
the design matrix will be constructed using Cockerham’s model: In BC
population, it is a 2*1 matrix with values 0.5 and -0.5 for the additive
effect; In RI or AI population, it is a 3*2 matrix. The first column
consists of 1, 0, and -1 for the additive effect, and the second column
consists of 0.5, -0.5, and 0.5 for the dominant effect.</p>
</td></tr>
<tr><td><code id="IM.search2_+3A_ng">ng</code></td>
<td>
<p>integer. The generation number of the population type. For
instance, in a BC1 population where type=&quot;BC&quot;, ng=1; in an AI F3
population where type=&quot;AI&quot;, ng=3.</p>
</td></tr>
<tr><td><code id="IM.search2_+3A_cm">cM</code></td>
<td>
<p>logical. Specify the unit of marker position. If cM=TRUE, it
denotes centimorgan; if cM=FALSE, it denotes morgan.</p>
</td></tr>
<tr><td><code id="IM.search2_+3A_speed">speed</code></td>
<td>
<p>numeric. The walking speed of the QTL search (in cM).</p>
</td></tr>
<tr><td><code id="IM.search2_+3A_crit">crit</code></td>
<td>
<p>numeric. The convergence criterion of EM algorithm.
The E and M steps will iterate until a convergence criterion is met.
It must be a value between 0 and 1.</p>
</td></tr>
<tr><td><code id="IM.search2_+3A_d.eff">d.eff</code></td>
<td>
<p>logical. Specifies whether the dominant effect will be
considered in the parameter estimation for AI or RI population.</p>
</td></tr>
<tr><td><code id="IM.search2_+3A_lrt.thre">LRT.thre</code></td>
<td>
<p>logical or numeric. If set to TRUE, the LRT threshold
will be computed based on the Gaussian stochastic process (Kao and Ho 2012).
Alternatively, users can input a numerical value as the LRT threshold to
evaluate the significance of QTL detection.</p>
</td></tr>
<tr><td><code id="IM.search2_+3A_simu">simu</code></td>
<td>
<p>integer. Determines the number of simulation samples that
will be used to compute the LRT (Likelihood Ratio Test) threshold using
the Gaussian process. It must be a value between 50 and 10^8.</p>
</td></tr>
<tr><td><code id="IM.search2_+3A_alpha">alpha</code></td>
<td>
<p>numeric. The type I error rate for the LRT threshold.</p>
</td></tr>
<tr><td><code id="IM.search2_+3A_detect">detect</code></td>
<td>
<p>logical. Determines whether the significant QTL, whose LRT
statistic is larger than the LRT threshold, will be displayed in the
output dataset or not.</p>
</td></tr>
<tr><td><code id="IM.search2_+3A_qtldist">QTLdist</code></td>
<td>
<p>numeric. The minimum distance (in cM) among different
linked significant QTL.</p>
</td></tr>
<tr><td><code id="IM.search2_+3A_plot.all">plot.all</code></td>
<td>
<p>logical. When set to TRUE, it directs the function to
output the profile of LRT statistics for the genome in one figure.</p>
</td></tr>
<tr><td><code id="IM.search2_+3A_plot.chr">plot.chr</code></td>
<td>
<p>logical. When set to TRUE, it instructs the function to
output the profile of LRT statistics for the chromosomes.</p>
</td></tr>
<tr><td><code id="IM.search2_+3A_console">console</code></td>
<td>
<p>logical. Determines whether the process of the algorithm
will be displayed in the R console or not.</p>
</td></tr>
</table>


<h3>Value</h3>

<table>
<tr><td><code>effect</code></td>
<td>
<p>The estimated effects and LRT statistics of all positions.</p>
</td></tr>
<tr><td><code>LRT.threshold</code></td>
<td>
<p>The LRT threshold value computed for the data using the
Gaussian stochastic process (Kuo 2011; Kao and Ho 2012).</p>
</td></tr>
<tr><td><code>detect.QTL</code></td>
<td>
<p>The positions, effects and LRT statistics of the detected
QTL significant using the obtained LRT threshold value.</p>
</td></tr>
<tr><td><code>model</code></td>
<td>
<p>The model of selective genotyping data in this analyze.</p>
</td></tr>
</table>
<p>Graphical outputs including LOD value and effect of each position.
</p>


<h3>References</h3>

<p>KAO, C.-H. and Z.-B. ZENG 1997 General formulas for obtaining the maximum
likelihood estimates and the asymptotic variance-covariance matrix in QTL
mapping when using the EM algorithm. Biometrics 53, 653-665. &lt;doi: 10.2307/2533965.&gt;
</p>
<p>KAO, C.-H., Z.-B. ZENG and R. D. TEASDALE 1999 Multiple interval mapping
for Quantitative Trait Loci. Genetics 152: 1203-1216. &lt;doi: 10.1093/genetics/152.3.1203&gt;
</p>
<p>H.-I LEE, H.-A. HO and C.-H. KAO 2014 A new simple method for improving
QTL mapping under selective genotyping. Genetics 198: 1685-1698. &lt;doi: 10.1534/genetics.114.168385.&gt;
</p>
<p>KAO, C.-H. and H.-A. Ho 2012 A score-statistic approach for determining
threshold values in QTL mapping. Frontiers in Bioscience. E4, 2670-2682. &lt;doi: 10.2741/e582&gt;
</p>


<h3>See Also</h3>

<p><code><a href="#topic+EM.MIM2">EM.MIM2</a></code>
<code><a href="#topic+IM.search">IM.search</a></code>
<code><a href="#topic+LRTthre">LRTthre</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># load the example data
load(system.file("extdata", "exampledata.RDATA", package = "QTLEMM"))

# make the seletive genotyping data
ys &lt;- y[y &gt; quantile(y)[4] | y &lt; quantile(y)[2]]
yu &lt;- y[y &gt;= quantile(y)[2] &amp; y &lt;= quantile(y)[4]]
geno.s &lt;- geno[y &gt; quantile(y)[4] | y &lt; quantile(y)[2],]

# run and result
result &lt;- IM.search2(marker, geno.s, ys, yu, sele.g = "f", type = "RI", ng = 2,
speed = 7, crit = 10^-3, LRT.thre = 10)
result$detect.QTL
</code></pre>

<hr>
<h2 id='LOD.QTLdetect'>QTL Detect by LOD</h2><span id='topic+LOD.QTLdetect'></span>

<h3>Description</h3>

<p>Detect QTL by the likelihood of odds (LOD) matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>LOD.QTLdetect(LOD, bin, thre = 3, QTLdist = 20, console = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="LOD.QTLdetect_+3A_lod">LOD</code></td>
<td>
<p>matrix. The LOD matrix, which is a t*p matrix, where t is
the number of traits and p is the number of bins on the chromosomes.
Missing values should be denoted as NA in the matrix.</p>
</td></tr>
<tr><td><code id="LOD.QTLdetect_+3A_bin">bin</code></td>
<td>
<p>matrix. An n*2 matrix that represents the number of bins on
each chromosome, where n is the number of chromosomes. The first column
denotes the chromosome number, and the second column denotes the number
of bins on that chromosome. It's important to ensure that chromosomes
are divided in order.</p>
</td></tr>
<tr><td><code id="LOD.QTLdetect_+3A_thre">thre</code></td>
<td>
<p>numeric. The LOD threshold. Any LOD score under this
threshold will be calculated as 0.</p>
</td></tr>
<tr><td><code id="LOD.QTLdetect_+3A_qtldist">QTLdist</code></td>
<td>
<p>numeric. The minimum distance (in bins) among different
linked significant QTL.</p>
</td></tr>
<tr><td><code id="LOD.QTLdetect_+3A_console">console</code></td>
<td>
<p>logical. Determines whether the process of the algorithm
will be displayed in the R console or not.</p>
</td></tr>
</table>


<h3>Value</h3>

<table>
<tr><td><code>detect.QTL.number</code></td>
<td>
<p>The number of detected QTL in each trait.</p>
</td></tr>
<tr><td><code>QTL.matrix</code></td>
<td>
<p>The QTL position matrix. Where the elements 1
donates the position of QTL; elements 0 donate the bins whose LOD
score is under the LOD threshold; other positions are shown as NA.</p>
</td></tr>
<tr><td><code>EQF.matrix</code></td>
<td>
<p>The matrix denotes the EQF value of each bin.</p>
</td></tr>
<tr><td><code>linkage.QTL.number</code></td>
<td>
<p>The linkage QTL number of all detected
QTL. In other words, it is the table that denote how many QTL are
on one chromosome.</p>
</td></tr>
<tr><td><code>LOD.threshold</code></td>
<td>
<p>The LOD threshold used in this analysis.</p>
</td></tr>
<tr><td><code>bin</code></td>
<td>
<p>The bin information matrix used in this analysis.</p>
</td></tr>
</table>


<h3>References</h3>

<p>Wu, P.-Y., M.-.H. Yang, and C.-H. KAO 2021 A Statistical Framework
for QTL Hotspot Detection. G3: Genes, Genomes, Genetics: jkab056. &lt;doi: 10.1093/g3journal/jkab056&gt;
</p>


<h3>See Also</h3>

<p><code><a href="#topic+EQF.permu">EQF.permu</a></code>
<code><a href="#topic+EQF.plot">EQF.plot</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># load the example data
load(system.file("extdata", "LODexample.RDATA", package = "QTLEMM"))
dim(LODexample) # 100 traits, 633 bins on chromosome

# run and result
result &lt;- LOD.QTLdetect(LODexample, bin, thre = 3, QTLdist = 10)
result$detect.QTL.number

</code></pre>

<hr>
<h2 id='LRTthre'>LRT Threshold</h2><span id='topic+LRTthre'></span>

<h3>Description</h3>

<p>The LRT threshold for QTL interval mapping based on the
Gaussian stochastic process (Kao and Ho 2012).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>LRTthre(
  marker,
  type = "RI",
  ng = 2,
  cM = TRUE,
  ns = 200,
  gv = 25,
  speed = 1,
  simu = 1000,
  d.eff = FALSE,
  alpha = 0.05,
  console = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="LRTthre_+3A_marker">marker</code></td>
<td>
<p>matrix. A k*2 matrix contains the marker information,
where the row dimension 'k' represents the number of markers in the
chromosomes. The first column labels the chromosomes where the markers
are located, and the second column labels the positions of markers (in
morgan (M) or centimorgan (cM)). It's important to note that chromosomes
and positions must be sorted in order.</p>
</td></tr>
<tr><td><code id="LRTthre_+3A_type">type</code></td>
<td>
<p>character. The population type of the dataset. Includes
backcross (type=&quot;BC&quot;), advanced intercross population (type=&quot;AI&quot;), and
recombinant inbred population (type=&quot;RI&quot;). The default value is &quot;RI&quot;.</p>
</td></tr>
<tr><td><code id="LRTthre_+3A_ng">ng</code></td>
<td>
<p>integer. The generation number of the population type. For
instance, in a BC1 population where type=&quot;BC&quot;, ng=1; in an AI F3
population where type=&quot;AI&quot;, ng=3.</p>
</td></tr>
<tr><td><code id="LRTthre_+3A_cm">cM</code></td>
<td>
<p>logical. Specify the unit of marker position. If cM=TRUE, it
denotes centimorgan; if cM=FALSE, it denotes morgan.</p>
</td></tr>
<tr><td><code id="LRTthre_+3A_ns">ns</code></td>
<td>
<p>integer. The number of individuals for generating the
individual trait values. Changes in this value do not significantly
affect the outcome of the LRT threshold value.</p>
</td></tr>
<tr><td><code id="LRTthre_+3A_gv">gv</code></td>
<td>
<p>numeric. The genetic variance for generating the
individual trait values. Changes in this value do not significantly
affect the outcome of the LRT threshold value.</p>
</td></tr>
<tr><td><code id="LRTthre_+3A_speed">speed</code></td>
<td>
<p>numeric. The walking speed of the QTL analysis (in cM).</p>
</td></tr>
<tr><td><code id="LRTthre_+3A_simu">simu</code></td>
<td>
<p>integer. Determines the number of simulation samples that
will be used to compute the LRT threshold using the Gaussian process.</p>
</td></tr>
<tr><td><code id="LRTthre_+3A_d.eff">d.eff</code></td>
<td>
<p>logical. Specifies whether the dominant effect will be
considered in the parameter estimation for AI or RI population.</p>
</td></tr>
<tr><td><code id="LRTthre_+3A_alpha">alpha</code></td>
<td>
<p>numeric. The type I error rate for the LRT threshold.</p>
</td></tr>
<tr><td><code id="LRTthre_+3A_console">console</code></td>
<td>
<p>logical. Determines whether the process of the algorithm
will be displayed in the R console or not.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The LRT threshold for QTL interval mapping.
</p>


<h3>References</h3>

<p>KAO, C.-H. and H.-A. Ho 2012 A score-statistic approach for determining
threshold values in QTL mapping. Frontiers in Bioscience. E4, 2670-2682. &lt;doi: 10.2741/e582&gt;
</p>


<h3>See Also</h3>

<p><code><a href="mvtnorm.html#topic+rmvnorm">rmvnorm</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># load the example data
load(system.file("extdata", "exampledata.RDATA", package = "QTLEMM"))

# run and result
LRTthre(marker, type = "RI", ng = 2, speed = 2, simu = 60)
</code></pre>

<hr>
<h2 id='MIM.points'>QTL Short Distance Correction by MIM</h2><span id='topic+MIM.points'></span>

<h3>Description</h3>

<p>Expectation-maximization algorithm for QTL multiple interval mapping to
find the best QTL position near the designated QTL position.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>MIM.points(
  QTL,
  marker,
  geno,
  y,
  method = "EM",
  type = "RI",
  D.matrix = NULL,
  ng = 2,
  cM = TRUE,
  scope = 5,
  speed = 1,
  crit = 10^-3,
  console = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="MIM.points_+3A_qtl">QTL</code></td>
<td>
<p>matrix. A q*2 matrix contains the QTL information, where the
row dimension 'q' represents the number of QTLs in the chromosomes. The
first column labels the chromosomes where the QTLs are located, and the
second column labels the positions of QTLs (in morgan (M) or centimorgan
(cM)).</p>
</td></tr>
<tr><td><code id="MIM.points_+3A_marker">marker</code></td>
<td>
<p>matrix. A k*2 matrix contains the marker information,
where the row dimension 'k' represents the number of markers in the
chromosomes. The first column labels the chromosomes where the markers
are located, and the second column labels the positions of markers (in
morgan (M) or centimorgan (cM)). It's important to note that chromosomes
and positions must be sorted in order.</p>
</td></tr>
<tr><td><code id="MIM.points_+3A_geno">geno</code></td>
<td>
<p>matrix. A n*k matrix contains the genotypes of k markers
for n individuals. The marker genotypes of P1 homozygote (MM),
heterozygote (Mm), and P2 homozygote (mm) are coded as 2, 1, and 0,
respectively, with NA indicating missing values.</p>
</td></tr>
<tr><td><code id="MIM.points_+3A_y">y</code></td>
<td>
<p>vector. A vector with n elements that contains the phenotype
values of individuals.</p>
</td></tr>
<tr><td><code id="MIM.points_+3A_method">method</code></td>
<td>
<p>character. When method=&quot;EM&quot;, it indicates that the interval
mapping method by Lander and Botstein (1989) is used in the analysis.
Conversely, when method=&quot;REG&quot;, it indicates that the approximate regression
interval mapping method by Haley and Knott (1992) is used in the analysis.</p>
</td></tr>
<tr><td><code id="MIM.points_+3A_type">type</code></td>
<td>
<p>character. The population type of the dataset. Includes
backcross (type=&quot;BC&quot;), advanced intercross population (type=&quot;AI&quot;), and
recombinant inbred population (type=&quot;RI&quot;). The default value is &quot;RI&quot;.</p>
</td></tr>
<tr><td><code id="MIM.points_+3A_d.matrix">D.matrix</code></td>
<td>
<p>matrix. The design matrix of QTL effects is a g*p matrix,
where g is the number of possible QTL genotypes, and p is the number of
effects considered in the MIM model. This design matrix can be easily
generated by the function D.make(). If set to NULL, it will automatically
generate a design matrix with all additive and dominant effects and without
any epistasis effect.</p>
</td></tr>
<tr><td><code id="MIM.points_+3A_ng">ng</code></td>
<td>
<p>integer. The generation number of the population type. For
instance, in a BC1 population where type=&quot;BC&quot;, ng=1; in an AI F3
population where type=&quot;AI&quot;, ng=3.</p>
</td></tr>
<tr><td><code id="MIM.points_+3A_cm">cM</code></td>
<td>
<p>logical. Specify the unit of marker position. If cM=TRUE, it
denotes centimorgan; if cM=FALSE, it denotes morgan.</p>
</td></tr>
<tr><td><code id="MIM.points_+3A_scope">scope</code></td>
<td>
<p>numeric vector. During the MIM process, it will search forward
and backward for the corresponding centimorgan (cM). Users can assign a
numeric number for every QTL or a numeric vector for each QTL. Note that 0
denotes that the corresponding QTL position is fixed, and the positions of
its surrounding intervals will not be searched.</p>
</td></tr>
<tr><td><code id="MIM.points_+3A_speed">speed</code></td>
<td>
<p>numeric. The walking speed of the QTL search (in cM).</p>
</td></tr>
<tr><td><code id="MIM.points_+3A_crit">crit</code></td>
<td>
<p>numeric. The convergence criterion of EM algorithm.
The E and M steps will iterate until a convergence criterion is met.
It must be a value between 0 and 1.</p>
</td></tr>
<tr><td><code id="MIM.points_+3A_console">console</code></td>
<td>
<p>logical. Determines whether the process of the algorithm
will be displayed in the R console or not.</p>
</td></tr>
</table>


<h3>Value</h3>

<table>
<tr><td><code>effect</code></td>
<td>
<p>The estimated effects, log-likelihood value, and LRT
statistics of all searched positions.</p>
</td></tr>
<tr><td><code>QTL.best</code></td>
<td>
<p>The positions of the best QTL combination.</p>
</td></tr>
<tr><td><code>effect.best</code></td>
<td>
<p>The estimated effects and LRT statistics of the best
QTL combination.</p>
</td></tr>
</table>


<h3>References</h3>

<p>KAO, C.-H. and Z.-B. ZENG 1997 General formulas for obtaining the maximum
likelihood estimates and the asymptotic variance-covariance matrix in QTL
mapping when using the EM algorithm. Biometrics 53, 653-665. &lt;doi: 10.2307/2533965.&gt;
</p>
<p>KAO, C.-H., Z.-B. ZENG and R. D. TEASDALE 1999 Multiple interval mapping
for Quantitative Trait Loci. Genetics 152: 1203-1216. &lt;doi: 10.1093/genetics/152.3.1203&gt;
</p>


<h3>See Also</h3>

<p><code><a href="#topic+EM.MIM">EM.MIM</a></code>
<code><a href="#topic+MIM.points2">MIM.points2</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># load the example data
load(system.file("extdata", "exampledata.RDATA", package = "QTLEMM"))

# run and result
result &lt;- MIM.points(QTL, marker, geno, y, type = "RI", ng = 2, scope = c(0,1,2), speed = 2)
result$QTL.best
result$effect.best
</code></pre>

<hr>
<h2 id='MIM.points2'>QTL Short Distance Correction by MIM with Selective Genotyping</h2><span id='topic+MIM.points2'></span>

<h3>Description</h3>

<p>Expectation-maximization algorithm for QTL multiple interval mapping to
find the best QTL position near the designated QTL position. It can
handle genotype data which is selective genotyping.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>MIM.points2(
  QTL,
  marker,
  geno,
  y,
  yu = NULL,
  sele.g = "n",
  tL = NULL,
  tR = NULL,
  method = "EM",
  type = "RI",
  D.matrix = NULL,
  ng = 2,
  cM = TRUE,
  scope = 5,
  speed = 1,
  crit = 10^-3,
  console = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="MIM.points2_+3A_qtl">QTL</code></td>
<td>
<p>matrix. A q*2 matrix contains the QTL information, where the
row dimension 'q' represents the number of QTLs in the chromosomes. The
first column labels the chromosomes where the QTLs are located, and the
second column labels the positions of QTLs (in morgan (M) or centimorgan
(cM)).</p>
</td></tr>
<tr><td><code id="MIM.points2_+3A_marker">marker</code></td>
<td>
<p>matrix. A k*2 matrix contains the marker information,
where the row dimension 'k' represents the number of markers in the
chromosomes. The first column labels the chromosomes where the markers
are located, and the second column labels the positions of markers (in
morgan (M) or centimorgan (cM)). It's important to note that chromosomes
and positions must be sorted in order.</p>
</td></tr>
<tr><td><code id="MIM.points2_+3A_geno">geno</code></td>
<td>
<p>matrix. A n*k matrix contains the genotypes of k markers
for n individuals. The marker genotypes of P1 homozygote (MM),
heterozygote (Mm), and P2 homozygote (mm) are coded as 2, 1, and 0,
respectively, with NA indicating missing values.</p>
</td></tr>
<tr><td><code id="MIM.points2_+3A_y">y</code></td>
<td>
<p>vector. A vector that contains the phenotype values of
individuals with genotypes.</p>
</td></tr>
<tr><td><code id="MIM.points2_+3A_yu">yu</code></td>
<td>
<p>vector. A vector that contains the phenotype values of
individuals without genotypes.</p>
</td></tr>
<tr><td><code id="MIM.points2_+3A_sele.g">sele.g</code></td>
<td>
<p>character. Determines the type of data being analyzed:
If sele.g=&quot;n&quot;, it considers the data as complete genotyping data. If
sele.g=&quot;f&quot;, it treats the data as selective genotyping data and utilizes
the proposed corrected frequency model (Lee 2014) for analysis; If
sele.g=&quot;t&quot;, it considers the data as selective genotyping data and uses
the truncated model (Lee 2014) for analysis; If sele.g=&quot;p&quot;, it treats
the data as selective genotyping data and uses the population
frequency-based model (Lee 2014) for analysis. Note that the 'yu'
argument must be provided when sele.g=&quot;f&quot; or &quot;p&quot;.</p>
</td></tr>
<tr><td><code id="MIM.points2_+3A_tl">tL</code></td>
<td>
<p>numeric. The lower truncation point of phenotype value when
sele.g=&quot;t&quot;. When sele.g=&quot;t&quot; and tL=NULL, the 'yu' argument must be
provided. In this case, the function will consider the minimum of 'yu'
as the lower truncation point.</p>
</td></tr>
<tr><td><code id="MIM.points2_+3A_tr">tR</code></td>
<td>
<p>numeric. The upper truncation point of phenotype value when
sele.g=&quot;t&quot;. When sele.g=&quot;t&quot; and tR=NULL, the 'yu' argument must be
provided. In this case, the function will consider the maximum of 'yu'
as the upper truncation point.</p>
</td></tr>
<tr><td><code id="MIM.points2_+3A_method">method</code></td>
<td>
<p>character. When method=&quot;EM&quot;, it indicates that the interval
mapping method by Lander and Botstein (1989) is used in the analysis.
Conversely, when method=&quot;REG&quot;, it indicates that the approximate regression
interval mapping method by Haley and Knott (1992) is used in the analysis.</p>
</td></tr>
<tr><td><code id="MIM.points2_+3A_type">type</code></td>
<td>
<p>character. The population type of the dataset. Includes
backcross (type=&quot;BC&quot;), advanced intercross population (type=&quot;AI&quot;), and
recombinant inbred population (type=&quot;RI&quot;). The default value is &quot;RI&quot;.</p>
</td></tr>
<tr><td><code id="MIM.points2_+3A_d.matrix">D.matrix</code></td>
<td>
<p>matrix. The design matrix of QTL effects is a g*p matrix,
where g is the number of possible QTL genotypes, and p is the number of
effects considered in the MIM model. This design matrix can be easily
generated by the function D.make(). If set to NULL, it will automatically
generate a design matrix with all additive and dominant effects and without
any epistasis effect.</p>
</td></tr>
<tr><td><code id="MIM.points2_+3A_ng">ng</code></td>
<td>
<p>integer. The generation number of the population type. For
instance, in a BC1 population where type=&quot;BC&quot;, ng=1; in an AI F3
population where type=&quot;AI&quot;, ng=3.</p>
</td></tr>
<tr><td><code id="MIM.points2_+3A_cm">cM</code></td>
<td>
<p>logical. Specify the unit of marker position. If cM=TRUE, it
denotes centimorgan; if cM=FALSE, it denotes morgan.</p>
</td></tr>
<tr><td><code id="MIM.points2_+3A_scope">scope</code></td>
<td>
<p>numeric vector. During the MIM process, it will search forward
and backward for the corresponding centimorgan (cM). Users can assign a
numeric number for every QTL or a numeric vector for each QTL. Note that 0
denotes that the corresponding QTL position is fixed, and the positions of
its surrounding intervals will not be searched.</p>
</td></tr>
<tr><td><code id="MIM.points2_+3A_speed">speed</code></td>
<td>
<p>numeric. The walking speed of the QTL search (in cM).</p>
</td></tr>
<tr><td><code id="MIM.points2_+3A_crit">crit</code></td>
<td>
<p>numeric. The convergence criterion of EM algorithm.
The E and M steps will iterate until a convergence criterion is met.
It must be a value between 0 and 1.</p>
</td></tr>
<tr><td><code id="MIM.points2_+3A_console">console</code></td>
<td>
<p>logical. Determines whether the process of the algorithm
will be displayed in the R console or not.</p>
</td></tr>
</table>


<h3>Value</h3>

<table>
<tr><td><code>effect</code></td>
<td>
<p>The estimated effects, log likelihood value, and LRT
statistics of all searched positions.</p>
</td></tr>
<tr><td><code>QTL.best</code></td>
<td>
<p>The positions of the best QTL combination.</p>
</td></tr>
<tr><td><code>effect.best</code></td>
<td>
<p>The estimated effects and LRT statistics of the best
QTL combination.</p>
</td></tr>
<tr><td><code>model</code></td>
<td>
<p>The model of selective genotyping data in this analysis.</p>
</td></tr>
</table>


<h3>References</h3>

<p>KAO, C.-H. and Z.-B. ZENG 1997 General formulas for obtaining the maximum
likelihood estimates and the asymptotic variance-covariance matrix in QTL
mapping when using the EM algorithm. Biometrics 53, 653-665. &lt;doi: 10.2307/2533965.&gt;
</p>
<p>KAO, C.-H., Z.-B. ZENG and R. D. TEASDALE 1999 Multiple interval mapping
for Quantitative Trait Loci. Genetics 152: 1203-1216. &lt;doi: 10.1093/genetics/152.3.1203&gt;
</p>
<p>H.-I LEE, H.-A. HO and C.-H. KAO 2014 A new simple method for improving
QTL mapping under selective genotyping. Genetics 198: 1685-1698. &lt;doi: 10.1534/genetics.114.168385.&gt;
</p>


<h3>See Also</h3>

<p><code><a href="#topic+EM.MIM2">EM.MIM2</a></code>
<code><a href="#topic+MIM.points">MIM.points</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># load the example data
load(system.file("extdata", "exampledata.RDATA", package = "QTLEMM"))

# make the seletive genotyping data
ys &lt;- y[y &gt; quantile(y)[4] | y &lt; quantile(y)[2]]
yu &lt;- y[y &gt;= quantile(y)[2] &amp; y &lt;= quantile(y)[4]]
geno.s &lt;- geno[y &gt; quantile(y)[4] | y &lt; quantile(y)[2],]

# run and result
result &lt;- MIM.points2(QTL, marker, geno.s, ys, yu, sele.g = "f",
 type = "RI", ng = 2, scope = c(0,1,2), speed = 2)
result$QTL.best
result$effect.best
</code></pre>

<hr>
<h2 id='MIM.search'>QTL search by MIM</h2><span id='topic+MIM.search'></span>

<h3>Description</h3>

<p>Expectation-maximization algorithm for QTL multiple interval mapping to
find one more QTL in the presence of some known QTLs.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>MIM.search(
  QTL,
  marker,
  geno,
  y,
  method = "EM",
  type = "RI",
  D.matrix = NULL,
  ng = 2,
  cM = TRUE,
  speed = 1,
  QTLdist = 15,
  link = TRUE,
  crit = 10^-3,
  console = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="MIM.search_+3A_qtl">QTL</code></td>
<td>
<p>matrix. A q*2 matrix contains the QTL information, where the
row dimension 'q' represents the number of QTLs in the chromosomes. The
first column labels the chromosomes where the QTLs are located, and the
second column labels the positions of QTLs (in morgan (M) or centimorgan
(cM)).</p>
</td></tr>
<tr><td><code id="MIM.search_+3A_marker">marker</code></td>
<td>
<p>matrix. A k*2 matrix contains the marker information,
where the row dimension 'k' represents the number of markers in the
chromosomes. The first column labels the chromosomes where the markers
are located, and the second column labels the positions of markers (in
morgan (M) or centimorgan (cM)). It's important to note that chromosomes
and positions must be sorted in order.</p>
</td></tr>
<tr><td><code id="MIM.search_+3A_geno">geno</code></td>
<td>
<p>matrix. A n*k matrix contains the genotypes of k markers
for n individuals. The marker genotypes of P1 homozygote (MM),
heterozygote (Mm), and P2 homozygote (mm) are coded as 2, 1, and 0,
respectively, with NA indicating missing values.</p>
</td></tr>
<tr><td><code id="MIM.search_+3A_y">y</code></td>
<td>
<p>vector. A vector with n elements that contains the phenotype
values of individuals.</p>
</td></tr>
<tr><td><code id="MIM.search_+3A_method">method</code></td>
<td>
<p>character. When method=&quot;EM&quot;, it indicates that the interval
mapping method by Lander and Botstein (1989) is used in the analysis.
Conversely, when method=&quot;REG&quot;, it indicates that the approximate regression
interval mapping method by Haley and Knott (1992) is used in the analysis.</p>
</td></tr>
<tr><td><code id="MIM.search_+3A_type">type</code></td>
<td>
<p>character. The population type of the dataset. Includes
backcross (type=&quot;BC&quot;), advanced intercross population (type=&quot;AI&quot;), and
recombinant inbred population (type=&quot;RI&quot;). The default value is &quot;RI&quot;.</p>
</td></tr>
<tr><td><code id="MIM.search_+3A_d.matrix">D.matrix</code></td>
<td>
<p>matrix. The design matrix of QTL effects is a g*p matrix,
where g is the number of possible QTL genotypes, and p is the number of
effects considered in the MIM model. It's important to note that the QTL
number of the design matrix must be the original QTL number plus one. The
design matrix can be easily generated by the function D.make(). If set to
NULL, it will automatically generate a design matrix with all additive and
dominant effects and without any epistasis effect.</p>
</td></tr>
<tr><td><code id="MIM.search_+3A_ng">ng</code></td>
<td>
<p>integer. The generation number of the population type. For
instance, in a BC1 population where type=&quot;BC&quot;, ng=1; in an AI F3
population where type=&quot;AI&quot;, ng=3.</p>
</td></tr>
<tr><td><code id="MIM.search_+3A_cm">cM</code></td>
<td>
<p>logical. Specify the unit of marker position. If cM=TRUE, it
denotes centimorgan; if cM=FALSE, it denotes morgan.</p>
</td></tr>
<tr><td><code id="MIM.search_+3A_speed">speed</code></td>
<td>
<p>numeric. The walking speed of the QTL search (in cM).</p>
</td></tr>
<tr><td><code id="MIM.search_+3A_qtldist">QTLdist</code></td>
<td>
<p>numeric. The minimum distance (in cM) among different
linked significant QTL. Positions near the known QTLs within this distance
will not be considered as candidate positions in the search process.</p>
</td></tr>
<tr><td><code id="MIM.search_+3A_link">link</code></td>
<td>
<p>logical. When set to False, positions on the same chromosomes
as the known QTLs will not be searched.</p>
</td></tr>
<tr><td><code id="MIM.search_+3A_crit">crit</code></td>
<td>
<p>numeric. The convergence criterion of EM algorithm.
The E and M steps will iterate until a convergence criterion is met.
It must be a value between 0 and 1.</p>
</td></tr>
<tr><td><code id="MIM.search_+3A_console">console</code></td>
<td>
<p>logical. Determines whether the process of the algorithm
will be displayed in the R console or not.</p>
</td></tr>
</table>


<h3>Value</h3>

<table>
<tr><td><code>effect</code></td>
<td>
<p>The estimated effects, log-likelihood value, and LRT
statistics of all searched positions.</p>
</td></tr>
<tr><td><code>QTL.best</code></td>
<td>
<p>The positions of the best QTL combination.</p>
</td></tr>
<tr><td><code>effect.best</code></td>
<td>
<p>The estimated effects and LRT statistics of the best
QTL combination.</p>
</td></tr>
</table>


<h3>References</h3>

<p>KAO, C.-H. and Z.-B. ZENG 1997 General formulas for obtaining the maximum
likelihood estimates and the asymptotic variance-covariance matrix in QTL
mapping when using the EM algorithm. Biometrics 53, 653-665. &lt;doi: 10.2307/2533965.&gt;
</p>
<p>KAO, C.-H., Z.-B. ZENG and R. D. TEASDALE 1999 Multiple interval mapping
for Quantitative Trait Loci. Genetics 152: 1203-1216. &lt;doi: 10.1093/genetics/152.3.1203&gt;
</p>


<h3>See Also</h3>

<p><code><a href="#topic+EM.MIM">EM.MIM</a></code>
<code><a href="#topic+MIM.search2">MIM.search2</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># load the example data
load(system.file("extdata", "exampledata.RDATA", package = "QTLEMM"))

# run and result
QTL &lt;- c(1, 23)
result &lt;- MIM.search(QTL, marker, geno, y, type = "RI", ng = 2, speed = 15, QTLdist = 50)
result$QTL.best
result$effect.best
</code></pre>

<hr>
<h2 id='MIM.search2'>QTL search by MIM with Seletive Genotyping</h2><span id='topic+MIM.search2'></span>

<h3>Description</h3>

<p>Expectation-maximization algorithm for QTL multiple interval mapping to
find one more QTL in the presence of some known QTLs. It can handle
genotype data which is selective genotyping.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>MIM.search2(
  QTL,
  marker,
  geno,
  y,
  yu = NULL,
  sele.g = "n",
  tL = NULL,
  tR = NULL,
  method = "EM",
  type = "RI",
  D.matrix = NULL,
  ng = 2,
  cM = TRUE,
  speed = 1,
  QTLdist = 15,
  link = TRUE,
  crit = 10^-3,
  console = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="MIM.search2_+3A_qtl">QTL</code></td>
<td>
<p>matrix. A q*2 matrix contains the QTL information, where the
row dimension 'q' represents the number of QTLs in the chromosomes. The
first column labels the chromosomes where the QTLs are located, and the
second column labels the positions of QTLs (in morgan (M) or centimorgan
(cM)).</p>
</td></tr>
<tr><td><code id="MIM.search2_+3A_marker">marker</code></td>
<td>
<p>matrix. A k*2 matrix contains the marker information,
where the row dimension 'k' represents the number of markers in the
chromosomes. The first column labels the chromosomes where the markers
are located, and the second column labels the positions of markers (in
morgan (M) or centimorgan (cM)). It's important to note that chromosomes
and positions must be sorted in order.</p>
</td></tr>
<tr><td><code id="MIM.search2_+3A_geno">geno</code></td>
<td>
<p>matrix. A n*k matrix contains the genotypes of k markers
for n individuals. The marker genotypes of P1 homozygote (MM),
heterozygote (Mm), and P2 homozygote (mm) are coded as 2, 1, and 0,
respectively, with NA indicating missing values.</p>
</td></tr>
<tr><td><code id="MIM.search2_+3A_y">y</code></td>
<td>
<p>vector. A vector that contains the phenotype values of
individuals with genotypes.</p>
</td></tr>
<tr><td><code id="MIM.search2_+3A_yu">yu</code></td>
<td>
<p>vector. A vector that contains the phenotype values of
individuals without genotypes.</p>
</td></tr>
<tr><td><code id="MIM.search2_+3A_sele.g">sele.g</code></td>
<td>
<p>character. Determines the type of data being analyzed:
If sele.g=&quot;n&quot;, it considers the data as complete genotyping data. If
sele.g=&quot;f&quot;, it treats the data as selective genotyping data and utilizes
the proposed corrected frequency model (Lee 2014) for analysis; If
sele.g=&quot;t&quot;, it considers the data as selective genotyping data and uses
the truncated model (Lee 2014) for analysis; If sele.g=&quot;p&quot;, it treats
the data as selective genotyping data and uses the population
frequency-based model (Lee 2014) for analysis. Note that the 'yu'
argument must be provided when sele.g=&quot;f&quot; or &quot;p&quot;.</p>
</td></tr>
<tr><td><code id="MIM.search2_+3A_tl">tL</code></td>
<td>
<p>numeric. The lower truncation point of phenotype value when
sele.g=&quot;t&quot;. When sele.g=&quot;t&quot; and tL=NULL, the 'yu' argument must be
provided. In this case, the function will consider the minimum of 'yu'
as the lower truncation point.</p>
</td></tr>
<tr><td><code id="MIM.search2_+3A_tr">tR</code></td>
<td>
<p>numeric. The upper truncation point of phenotype value when
sele.g=&quot;t&quot;. When sele.g=&quot;t&quot; and tR=NULL, the 'yu' argument must be
provided. In this case, the function will consider the maximum of 'yu'
as the upper truncation point.</p>
</td></tr>
<tr><td><code id="MIM.search2_+3A_method">method</code></td>
<td>
<p>character. When method=&quot;EM&quot;, it indicates that the interval
mapping method by Lander and Botstein (1989) is used in the analysis.
Conversely, when method=&quot;REG&quot;, it indicates that the approximate regression
interval mapping method by Haley and Knott (1992) is used in the analysis.</p>
</td></tr>
<tr><td><code id="MIM.search2_+3A_type">type</code></td>
<td>
<p>character. The population type of the dataset. Includes
backcross (type=&quot;BC&quot;), advanced intercross population (type=&quot;AI&quot;), and
recombinant inbred population (type=&quot;RI&quot;). The default value is &quot;RI&quot;.</p>
</td></tr>
<tr><td><code id="MIM.search2_+3A_d.matrix">D.matrix</code></td>
<td>
<p>matrix. The design matrix of QTL effects is a g*p matrix,
where g is the number of possible QTL genotypes, and p is the number of
effects considered in the MIM model. It's important to note that the QTL
number of the design matrix must be the original QTL number plus one. The
design matrix can be easily generated by the function D.make(). If set to
NULL, it will automatically generate a design matrix with all additive and
dominant effects and without any epistasis effect.</p>
</td></tr>
<tr><td><code id="MIM.search2_+3A_ng">ng</code></td>
<td>
<p>integer. The generation number of the population type. For
instance, in a BC1 population where type=&quot;BC&quot;, ng=1; in an AI F3
population where type=&quot;AI&quot;, ng=3.</p>
</td></tr>
<tr><td><code id="MIM.search2_+3A_cm">cM</code></td>
<td>
<p>logical. Specify the unit of marker position. If cM=TRUE, it
denotes centimorgan; if cM=FALSE, it denotes morgan.</p>
</td></tr>
<tr><td><code id="MIM.search2_+3A_speed">speed</code></td>
<td>
<p>numeric. The walking speed of the QTL search (in cM).</p>
</td></tr>
<tr><td><code id="MIM.search2_+3A_qtldist">QTLdist</code></td>
<td>
<p>numeric. The minimum distance (in cM) among different
linked significant QTL. Positions near the known QTLs within this distance
will not be considered as candidate positions in the search process.</p>
</td></tr>
<tr><td><code id="MIM.search2_+3A_link">link</code></td>
<td>
<p>logical. When set to False, positions on the same chromosomes
as the known QTLs will not be searched.</p>
</td></tr>
<tr><td><code id="MIM.search2_+3A_crit">crit</code></td>
<td>
<p>numeric. The convergence criterion of EM algorithm.
The E and M steps will iterate until a convergence criterion is met.
It must be a value between 0 and 1.</p>
</td></tr>
<tr><td><code id="MIM.search2_+3A_console">console</code></td>
<td>
<p>logical. Determines whether the process of the algorithm
will be displayed in the R console or not.</p>
</td></tr>
</table>


<h3>Value</h3>

<table>
<tr><td><code>effect</code></td>
<td>
<p>The estimated effects, log-likelihood value, and LRT
statistics of all searched positions.</p>
</td></tr>
<tr><td><code>QTL.best</code></td>
<td>
<p>The positions of the best QTL combination.</p>
</td></tr>
<tr><td><code>effect.best</code></td>
<td>
<p>The estimated effects and LRT statistics of the best
QTL combination.</p>
</td></tr>
<tr><td><code>model</code></td>
<td>
<p>The model of selective genotyping data in this analyze.</p>
</td></tr>
</table>


<h3>References</h3>

<p>KAO, C.-H. and Z.-B. ZENG 1997 General formulas for obtaining the maximum
likelihood estimates and the asymptotic variance-covariance matrix in QTL
mapping when using the EM algorithm. Biometrics 53, 653-665. &lt;doi: 10.2307/2533965.&gt;
</p>
<p>KAO, C.-H., Z.-B. ZENG and R. D. TEASDALE 1999 Multiple interval mapping
for Quantitative Trait Loci. Genetics 152: 1203-1216. &lt;doi: 10.1093/genetics/152.3.1203&gt;
</p>
<p>H.-I LEE, H.-A. HO and C.-H. KAO 2014 A new simple method for improving
QTL mapping under selective genotyping. Genetics 198: 1685-1698. &lt;doi: 10.1534/genetics.114.168385.&gt;
</p>


<h3>See Also</h3>

<p><code><a href="#topic+EM.MIM2">EM.MIM2</a></code>
<code><a href="#topic+MIM.search">MIM.search</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># load the example data
load(system.file("extdata", "exampledata.RDATA", package = "QTLEMM"))

# make the seletive genotyping data
ys &lt;- y[y &gt; quantile(y)[4] | y &lt; quantile(y)[2]]
yu &lt;- y[y &gt;= quantile(y)[2] &amp; y &lt;= quantile(y)[4]]
geno.s &lt;- geno[y &gt; quantile(y)[4] | y &lt; quantile(y)[2],]

# run and result
QTL &lt;- c(1, 23)
result &lt;- MIM.search2(QTL, marker, geno.s, ys, yu, sele.g = "f",
 type = "RI", ng = 2, speed = 15, QTLdist = 50)
result$QTL.best
result$effect.best
</code></pre>

<hr>
<h2 id='progeny'>Progeny Simulation</h2><span id='topic+progeny'></span>

<h3>Description</h3>

<p>Generate simulated phenotype and genotype data for a specified
generation from various breeding schemes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>progeny(
  QTL,
  marker,
  type = "RI",
  ng = 2,
  cM = TRUE,
  E.vector = NULL,
  h2 = 0.5,
  size = 200
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="progeny_+3A_qtl">QTL</code></td>
<td>
<p>matrix. A q*2 matrix contains the QTL information, where the
row dimension 'q' represents the number of QTLs in the chromosomes. The
first column labels the chromosomes where the QTLs are located, and the
second column labels the positions of QTLs (in morgan (M) or centimorgan
(cM)).</p>
</td></tr>
<tr><td><code id="progeny_+3A_marker">marker</code></td>
<td>
<p>matrix. A k*2 matrix contains the marker information,
where the row dimension 'k' represents the number of markers in the
chromosomes. The first column labels the chromosomes where the markers
are located, and the second column labels the positions of markers (in
morgan (M) or centimorgan (cM)). It's important to note that chromosomes
and positions must be sorted in order.</p>
</td></tr>
<tr><td><code id="progeny_+3A_type">type</code></td>
<td>
<p>character. The population type of the dataset. Includes
backcross (type=&quot;BC&quot;), advanced intercross population (type=&quot;AI&quot;), and
recombinant inbred population (type=&quot;RI&quot;). The default value is &quot;RI&quot;.</p>
</td></tr>
<tr><td><code id="progeny_+3A_ng">ng</code></td>
<td>
<p>integer. The generation number of the population type. For
instance, in a BC1 population where type=&quot;BC&quot;, ng=1; in an AI F3
population where type=&quot;AI&quot;, ng=3.</p>
</td></tr>
<tr><td><code id="progeny_+3A_cm">cM</code></td>
<td>
<p>logical. Specify the unit of marker position. If cM=TRUE, it
denotes centimorgan; if cM=FALSE, it denotes morgan.</p>
</td></tr>
<tr><td><code id="progeny_+3A_e.vector">E.vector</code></td>
<td>
<p>vector. Set the effect of QTLs. It should be a named
vector, where the names of elements represent the effects of QTLs and
their interactions. For example: the additive effect of QTL1 is coded as
&quot;a1&quot;; the dominant effect of QTL2 is coded as &quot;d2&quot;; the interaction of
the additive effect of QTL2 and the dominant effect of QTL1 is coded as
&quot;a2:d1&quot;. So, if the additive effect of QTL1 is 2, the dominant effect of
QTL2 is 5, and the interaction of the additive effect of QTL2 and the
dominant effect of QTL1 is 3, the user should input: E.vector = c(&quot;a1&quot;=2,
&quot;d2&quot;=5, &quot;a2:d1&quot;=3). If E.vector=NULL, the phenotypic value will not be
simulated.</p>
</td></tr>
<tr><td><code id="progeny_+3A_h2">h2</code></td>
<td>
<p>numeric. Set the heritability for simulated phenotypes. It
should be a number between 0 and 1.</p>
</td></tr>
<tr><td><code id="progeny_+3A_size">size</code></td>
<td>
<p>numeric. The population size of simulated progeny.</p>
</td></tr>
</table>


<h3>Value</h3>

<table>
<tr><td><code>phe</code></td>
<td>
<p>The phenotypic value of each simulated progeny.</p>
</td></tr>
<tr><td><code>E.vector</code></td>
<td>
<p>The effect vector used in this simulation.</p>
</td></tr>
<tr><td><code>marker.prog</code></td>
<td>
<p>The marker genotype of each simulated progeny.</p>
</td></tr>
<tr><td><code>QTL.prog</code></td>
<td>
<p>The QTL genotype of each simulated progeny.</p>
</td></tr>
<tr><td><code>VG</code></td>
<td>
<p>The genetic variance of this population.</p>
</td></tr>
<tr><td><code>VE</code></td>
<td>
<p>The environmental variance of this population.</p>
</td></tr>
<tr><td><code>genetic.value</code></td>
<td>
<p>The genetic value of each simulated progeny.</p>
</td></tr>
</table>


<h3>References</h3>

<p>Haldane J.B.S. 1919. The combination of linkage values and the calculation
of distance between the loci for linked factors. Genetics 8: 299–309.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># load the example data
load(system.file("extdata", "exampledata.RDATA", package = "QTLEMM"))

# run and result
result &lt;- progeny(QTL, marker, type = "RI", ng = 5, E.vector = c("a1" = 2, "d2" = 5, "a2:d1" = 3),
h2 = 0.5, size = 200)
result$phe
</code></pre>

<hr>
<h2 id='Q.make'>Generate Q Matrix</h2><span id='topic+Q.make'></span>

<h3>Description</h3>

<p>Generate the conditional probability matrix using the information of QTL
and marker, along with the genotype data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Q.make(
  QTL,
  marker,
  geno = NULL,
  interval = FALSE,
  type = "RI",
  ng = 2,
  cM = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Q.make_+3A_qtl">QTL</code></td>
<td>
<p>matrix. A q*2 matrix contains the QTL information, where the
row dimension 'q' represents the number of QTLs in the chromosomes. The
first column labels the chromosomes where the QTLs are located, and the
second column labels the positions of QTLs (in morgan (M) or centimorgan
(cM)).</p>
</td></tr>
<tr><td><code id="Q.make_+3A_marker">marker</code></td>
<td>
<p>matrix. A k*2 matrix contains the marker information,
where the row dimension 'k' represents the number of markers in the
chromosomes. The first column labels the chromosomes where the markers
are located, and the second column labels the positions of markers (in
morgan (M) or centimorgan (cM)). It's important to note that chromosomes
and positions must be sorted in order.</p>
</td></tr>
<tr><td><code id="Q.make_+3A_geno">geno</code></td>
<td>
<p>matrix. A n*k matrix contains the genotypes of k markers
for n individuals. The marker genotypes of P1 homozygote (MM),
heterozygote (Mm), and P2 homozygote (mm) are coded as 2, 1, and 0,
respectively, with NA indicating missing values.</p>
</td></tr>
<tr><td><code id="Q.make_+3A_interval">interval</code></td>
<td>
<p>logical. When set to interval=TRUE, if a QTL shares the
same position as a marker, the marker will be skipped and not considered
as a flanking marker.</p>
</td></tr>
<tr><td><code id="Q.make_+3A_type">type</code></td>
<td>
<p>character. The population type of the dataset. Includes
backcross (type=&quot;BC&quot;), advanced intercross population (type=&quot;AI&quot;), and
recombinant inbred population (type=&quot;RI&quot;). The default value is &quot;RI&quot;.</p>
</td></tr>
<tr><td><code id="Q.make_+3A_ng">ng</code></td>
<td>
<p>integer. The generation number of the population type. For
instance, in a BC1 population where type=&quot;BC&quot;, ng=1; in an AI F3
population where type=&quot;AI&quot;, ng=3.</p>
</td></tr>
<tr><td><code id="Q.make_+3A_cm">cM</code></td>
<td>
<p>logical. Specify the unit of marker position. If cM=TRUE, it
denotes centimorgan; if cM=FALSE, it denotes morgan.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The output contains k conditional probability matrices for the k
flanking marker pairs (the k Q-matrices) and a conditional
probability matrix of each QTL for all individuals (the cp-matrix)
provided the genotype data of the testing population is input..
</p>


<h3>Note</h3>

<p>If geno=NULL, the function can still be executed, and the output will
contain k Q-matrices but no cp-matrix.
</p>


<h3>References</h3>

<p>KAO, C.-H. and Z.-B. ZENG 1997 General formulas for obtaining the maximum
likelihood estimates and the asymptotic variance-covariance matrix in QTL
mapping when using the EM algorithm. Biometrics 53, 653-665. &lt;doi: 10.2307/2533965.&gt;
</p>
<p>KAO, C.-H., Z.-B. ZENG and R. D. TEASDALE 1999 Multiple interval mapping
for Quantitative Trait Loci. Genetics 152: 1203-1216. &lt;doi: 10.1093/genetics/152.3.1203&gt;
</p>


<h3>Examples</h3>

<pre><code class='language-R'># load the example data
load(system.file("extdata", "exampledata.RDATA", package = "QTLEMM"))

# run and result
result &lt;- Q.make(QTL, marker, geno)
head(result$cp.matrix)
</code></pre>

<hr>
<h2 id='Qhot'>QTL Hotspot</h2><span id='topic+Qhot'></span>

<h3>Description</h3>

<p>This function generates both numerical and graphical summaries of the QTL
hotspot detection in the genomes, including information about the flanking
markers of QTLs.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Qhot(DataQTL, DataCrop, ScanStep = 1, NH = 100, NP = 1000, save.pdf = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Qhot_+3A_dataqtl">DataQTL</code></td>
<td>
<p>data.frame. A data frame with 5 columns for QTL information.
The columns represent the serial number of QTLs, the trait names, the
chromosome numbers, the left flanking marker positions(in cM) of QTLs, and
the right flanking marker positions(in cM) of QTLs.</p>
</td></tr>
<tr><td><code id="Qhot_+3A_datacrop">DataCrop</code></td>
<td>
<p>data.frame. A data frame with 3 columns for chromosome
information consists of the chromosome names, the center positions(in cM)
and the lengths of chromosomes.</p>
</td></tr>
<tr><td><code id="Qhot_+3A_scanstep">ScanStep</code></td>
<td>
<p>numeric. A value for the length(cM) of every bin.</p>
</td></tr>
<tr><td><code id="Qhot_+3A_nh">NH</code></td>
<td>
<p>integer. A value for the number of spurious hotspots in the
proposed method.</p>
</td></tr>
<tr><td><code id="Qhot_+3A_np">NP</code></td>
<td>
<p>integer. A value for permutation times to calculate the
threshold.</p>
</td></tr>
<tr><td><code id="Qhot_+3A_save.pdf">save.pdf</code></td>
<td>
<p>logical. When set to TRUE, the PDF file of plots will be
saved in the working directory instead of being displayed in the console.</p>
</td></tr>
</table>


<h3>Value</h3>

<table>
<tr><td><code>EQF</code></td>
<td>
<p>The expected QTL frequency(EQF) in every bin per chromosome.</p>
</td></tr>
<tr><td><code>P.threshold</code></td>
<td>
<p>The EQF thresholds for proposed method.</p>
</td></tr>
<tr><td><code>Q.threshold</code></td>
<td>
<p>The EQF thresholds for the Q method.</p>
</td></tr>
<tr><td><code>nHot</code></td>
<td>
<p>The numbers of detected hotspots per chromosome for the proposed
method and Q method.</p>
</td></tr>
</table>
<p>Graphical outputs for visualizing the summarized results includes the
expected QTL frequency of scan steps, and the composition of QTLs for
different traits in the detected hotspots.
</p>


<h3>Note</h3>

<p>This program may generate a large amount of graphical output. To manage this,
it's recommended to save the results in a PDF file using the &quot;save.pdf&quot;
argument.
</p>


<h3>References</h3>

<p>Wu, P.-Y., M.-.H. Yang, and C.-H. KAO 2021 A Statistical Framework for QTL
Hotspot Detection. G3: Genes, Genomes, Genetics: jkab056. &lt;doi: 10.1093/g3journal/jkab056&gt;
</p>


<h3>Examples</h3>

<pre><code class='language-R'># load the example data
load(system.file("extdata", "QHOTexample.RDATA", package = "QTLEMM"))

# run and result
result &lt;- Qhot(QTL.example, crop.example, 5, 20, 100, save.pdf = FALSE)
</code></pre>

<hr>
<h2 id='Qhot.EQF'>EQF Matrix Conversion</h2><span id='topic+Qhot.EQF'></span>

<h3>Description</h3>

<p>Convert the QTL flanking marker data to EQF matrix. And the EQF matrix 
cluster permutation process can be further carried out to detect QTL 
hotspots.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Qhot.EQF(
  DataQTL,
  Datachr,
  bin.size = 0.5,
  permu = TRUE,
  ptime = 1000,
  alpha = 0.05,
  Q = TRUE,
  console = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Qhot.EQF_+3A_dataqtl">DataQTL</code></td>
<td>
<p>data.frame. A data frame with 5 columns for QTL information.
The columns represent the serial number of QTLs, the trait names, the
chromosome numbers, the left flanking marker positions(in cM) of QTLs, and
the right flanking marker positions(in cM) of QTLs.</p>
</td></tr>
<tr><td><code id="Qhot.EQF_+3A_datachr">Datachr</code></td>
<td>
<p>vector. The length of each chromosome(in cM).</p>
</td></tr>
<tr><td><code id="Qhot.EQF_+3A_bin.size">bin.size</code></td>
<td>
<p>numeric. The bin size(in cM) for QTL detection. If the 
distance of flanking marker of a QTL is lass than the bin size, it will be
mark in the EQF matrix and will participate in the cluster grouping process.</p>
</td></tr>
<tr><td><code id="Qhot.EQF_+3A_permu">permu</code></td>
<td>
<p>logical. When set to TRUE, the function will carry out the 
cluster grouping process and cluster group permutation.</p>
</td></tr>
<tr><td><code id="Qhot.EQF_+3A_ptime">ptime</code></td>
<td>
<p>integer. The permutation times.</p>
</td></tr>
<tr><td><code id="Qhot.EQF_+3A_alpha">alpha</code></td>
<td>
<p>numeric. The type 1 error rate of detecting the hotspot.</p>
</td></tr>
<tr><td><code id="Qhot.EQF_+3A_q">Q</code></td>
<td>
<p>logical. When set to TRUE, the function will additionally carry
out the permutation of the Q method as the control group, which will be
indicated as 'B' in the output.</p>
</td></tr>
<tr><td><code id="Qhot.EQF_+3A_console">console</code></td>
<td>
<p>logical. Determines whether the process of the algorithm
will be displayed in the R console or not.</p>
</td></tr>
</table>


<h3>Value</h3>

<table>
<tr><td><code>EQF.matrix</code></td>
<td>
<p>The matrix denotes the EQF value of each bin for every 
QTL in this database.</p>
</td></tr>
<tr><td><code>bin</code></td>
<td>
<p>The bin information matrix whose first column denotes the 
chromosome number and the second column denotes the number of bins on 
that chromosome.</p>
</td></tr>
<tr><td><code>bin.size</code></td>
<td>
<p>The bin size set in this analysis.</p>
</td></tr>
<tr><td><code>EQF.trait</code></td>
<td>
<p>The matrix denotes the EQF value of each bin for every 
trait of this database.</p>
</td></tr>
<tr><td><code>EQF.detect</code></td>
<td>
<p>The matrix denotes the EQF value of each bin for the 
trait that have the QTL detected in the set bin size.</p>
</td></tr>
<tr><td><code>EQF.nondetect</code></td>
<td>
<p>The matrix denotes the EQF value of each bin for the 
trait that have no QTL detected in the set bin size.</p>
</td></tr>
<tr><td><code>cluster.matrix</code></td>
<td>
<p>The new EQF matrix after the clustering process.</p>
</td></tr>
<tr><td><code>permu.matrix.cluster</code></td>
<td>
<p>The permutation result of the clustering
method, which has been sorted by order.</p>
</td></tr>
<tr><td><code>permu.matrix.Q</code></td>
<td>
<p>The permutation result of the Q method, which has
been sorted by order.</p>
</td></tr>
<tr><td><code>EQF.threshold</code></td>
<td>
<p>The EQF threshold is calculated from the
permutation process.</p>
</td></tr>
</table>


<h3>References</h3>

<p>Wu, P.-Y., M.-.H. Yang, and C.-H. KAO 2021 A Statistical Framework
for QTL Hotspot Detection. G3: Genes, Genomes, Genetics: jkab056. &lt;doi: 10.1093/g3journal/jkab056&gt;
</p>


<h3>See Also</h3>

<p><code><a href="#topic+Qhot">Qhot</a></code>
<code><a href="#topic+EQF.plot">EQF.plot</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># load the example data
load(system.file("extdata", "QHOTEQFexample.RDATA", package = "QTLEMM"))

#' # run and result
result &lt;- Qhot.EQF(QTL.example, chr.example, bin.size = 2, permu = TRUE, 
ptime = 100, alpha = 0.05, Q = FALSE)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
