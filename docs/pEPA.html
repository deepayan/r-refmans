<!DOCTYPE html><html lang="en"><head><title>Help for package pEPA</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {pEPA}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#csc.C1.test'><p>Computes Test for Cross-Sectional Clusters.</p></a></li>
<li><a href='#csc.C3.test'><p>Computes Test for Cross-Sectional Clusters.</p></a></li>
<li><a href='#csc.test'><p>Computes Test for Cross-Sectional Clusters.</p></a></li>
<li><a href='#observed'><p>Sample Panel of Commodities Spot Prices.</p></a></li>
<li><a href='#pool_av.S1.test'><p>Computes Test for Overall Equal Predictive Ability.</p></a></li>
<li><a href='#pool_av.S3.test'><p>Computes Test for Overall Equal Predictive Ability.</p></a></li>
<li><a href='#pool_av.test'><p>Computes Test for the Pooled Average.</p></a></li>
<li><a href='#predicted'><p>Sample Panels of Commodities Spot Prices Forecasts.</p></a></li>
<li><a href='#tc.test'><p>Computes Test for Time Clusters.</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Tests of Equal Predictive Accuracy for Panels of Forecasts</td>
</tr>
<tr>
<td>Version:</td>
<td>1.2</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 2.10)</td>
</tr>
<tr>
<td>Imports:</td>
<td>Rcpp</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>Rcpp, RcppArmadillo</td>
</tr>
<tr>
<td>Date:</td>
<td>2025-03-07</td>
</tr>
<tr>
<td>Author:</td>
<td>Krzysztof Drachal [aut, cre] (Faculty of Economic Sciences, University
    of Warsaw, Poland)</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Krzysztof Drachal &lt;kdrachal@wne.uw.edu.pl&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Allows to perform the tests of equal predictive accuracy for panels of forecasts. Main references: Qu et al. (2024) &lt;<a href="https://doi.org/10.1016%2Fj.ijforecast.2023.08.001">doi:10.1016/j.ijforecast.2023.08.001</a>&gt; and Akgun et al. (2024) &lt;<a href="https://doi.org/10.1016%2Fj.ijforecast.2023.02.001">doi:10.1016/j.ijforecast.2023.02.001</a>&gt;. </td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>LazyData:</td>
<td>TRUE</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://CRAN.R-project.org/package=pEPA">https://CRAN.R-project.org/package=pEPA</a></td>
</tr>
<tr>
<td>Note:</td>
<td>Research funded by the grant of the National Science Centre,
Poland, under the contract number DEC-2018/31/B/HS4/02021.</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2025-03-07 19:58:07 UTC; Krzysiek</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2025-03-07 20:30:01 UTC</td>
</tr>
</table>
<hr>
<h2 id='csc.C1.test'>Computes Test for Cross-Sectional Clusters.</h2><span id='topic+csc.C1.test'></span>

<h3>Description</h3>

<p>This function computes test of the equal predictive accuracy for cross-sectional clusters. It corresponds to <code class="reqn">C^{(1)}_{nT}</code> statistic in the referenced paper by Akgun et al. (2024). The null hypothesis of this test is that a pair of forecasts have the same expected accuracy among cross-sectional clusters. However, their predictive accuracy can be different across the clusters, but the same among each cluster. The test is suitable for situations with cross-sectional independence. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>csc.C1.test(evaluated1,evaluated2,realized,loss.type="SE",cl)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="csc.C1.test_+3A_evaluated1">evaluated1</code></td>
<td>
<p>same as in <code><a href="#topic+pool_av.test">pool_av.test</a></code>, but cross-sections are ordered rowwise</p>
</td></tr>
<tr><td><code id="csc.C1.test_+3A_evaluated2">evaluated2</code></td>
<td>
<p>same as in <code><a href="#topic+pool_av.test">pool_av.test</a></code>, but cross-sections are ordered rowwise</p>
</td></tr>
<tr><td><code id="csc.C1.test_+3A_realized">realized</code></td>
<td>
<p>same as in <code><a href="#topic+pool_av.test">pool_av.test</a></code>, but cross-sections are ordered rowwise</p>
</td></tr>
<tr><td><code id="csc.C1.test_+3A_loss.type">loss.type</code></td>
<td>
<p>same as in <code><a href="#topic+pool_av.test">pool_av.test</a></code></p>
</td></tr>
<tr><td><code id="csc.C1.test_+3A_cl">cl</code></td>
<td>
<p><code><a href="base.html#topic+vector">vector</a></code> of the beginning indices of rows for each pre-defined clusters &ndash; as a result always <code>cl[1]=1</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>class <code>htest</code> object, <code><a href="base.html#topic+list">list</a></code> of 
</p>
<table role = "presentation">
<tr><td><code>statistic</code></td>
<td>
<p>test statistic</p>
</td></tr>
<tr><td><code>parameter</code></td>
<td>
<p><code class="reqn">K</code>, number of cross-sectional clusters</p>
</td></tr>
<tr><td><code>alternative</code></td>
<td>
<p>alternative hypothesis of the test</p>
</td></tr>
<tr><td><code>p.value</code></td>
<td>
<p>p-value</p>
</td></tr>
<tr><td><code>method</code></td>
<td>
<p>name of the test</p>
</td></tr>
<tr><td><code>data.name</code></td>
<td>
<p>names of the tested data</p>
</td></tr>
</table>


<h3>References</h3>

<p>Akgun, O., Pirotte, A., Urga, G., Yang, Z. 2024. Equal predictive ability tests based on panel data with applications to OECD and IMF forecasts. <em>International Journal of Forecasting</em> <b>40</b>, 202&ndash;228.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+pool_av.test">pool_av.test</a></code>, <code><a href="#topic+csc.C3.test">csc.C3.test</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(forecasts)
y &lt;- t(observed)
# just to save time
y &lt;- y[,1:40]
f.bsr &lt;- matrix(NA,ncol=ncol(y),nrow=56)
f.dma &lt;- f.bsr
# extract prices predicted by BSR rec and DMA methods
for (i in 1:56)
  {
    f.bsr[i,] &lt;- predicted[[i]][1:40,1]
    f.dma[i,] &lt;- predicted[[i]][1:40,9]
  }
# 2 cross-sectional clusters: energy commodities and non-energy commodities
cs.cl &lt;- c(1,9)
t &lt;- csc.C1.test(evaluated1=f.bsr,evaluated2=f.dma,realized=y,loss.type="SE",cl=cs.cl)

</code></pre>

<hr>
<h2 id='csc.C3.test'>Computes Test for Cross-Sectional Clusters.</h2><span id='topic+csc.C3.test'></span>

<h3>Description</h3>

<p>This function computes test of the equal predictive accuracy for cross-sectional clusters. It corresponds to <code class="reqn">C^{(3)}_{nT}</code> statistic in the referenced paper by Akgun et al. (2024). The null hypothesis of this test is that a pair of forecasts have the same expected accuracy among cross-sectional clusters. However, their predictive accuracy can be different across the clusters, but the same among each cluster. The test allows for strong cross-sectional dependence. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>csc.C3.test(evaluated1,evaluated2,realized,loss.type="SE",cl)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="csc.C3.test_+3A_evaluated1">evaluated1</code></td>
<td>
<p>same as in <code><a href="#topic+pool_av.test">pool_av.test</a></code>, but cross-sections are ordered rowwise</p>
</td></tr>
<tr><td><code id="csc.C3.test_+3A_evaluated2">evaluated2</code></td>
<td>
<p>same as in <code><a href="#topic+pool_av.test">pool_av.test</a></code>, but cross-sections are ordered rowwise</p>
</td></tr>
<tr><td><code id="csc.C3.test_+3A_realized">realized</code></td>
<td>
<p>same as in <code><a href="#topic+pool_av.test">pool_av.test</a></code>, but cross-sections are ordered rowwise</p>
</td></tr>
<tr><td><code id="csc.C3.test_+3A_loss.type">loss.type</code></td>
<td>
<p>same as in <code><a href="#topic+pool_av.test">pool_av.test</a></code></p>
</td></tr>
<tr><td><code id="csc.C3.test_+3A_cl">cl</code></td>
<td>
<p><code><a href="base.html#topic+vector">vector</a></code> of the beginning indices of rows for each pre-defined clusters &ndash; as a result always <code>cl[1]=1</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>class <code>htest</code> object, <code><a href="base.html#topic+list">list</a></code> of 
</p>
<table role = "presentation">
<tr><td><code>statistic</code></td>
<td>
<p>test statistic</p>
</td></tr>
<tr><td><code>parameter</code></td>
<td>
<p><code class="reqn">K</code>, number of cross-sectional clusters</p>
</td></tr>
<tr><td><code>alternative</code></td>
<td>
<p>alternative hypothesis of the test</p>
</td></tr>
<tr><td><code>p.value</code></td>
<td>
<p>p-value</p>
</td></tr>
<tr><td><code>method</code></td>
<td>
<p>name of the test</p>
</td></tr>
<tr><td><code>data.name</code></td>
<td>
<p>names of the tested data</p>
</td></tr>
</table>


<h3>References</h3>

<p>Akgun, O., Pirotte, A., Urga, G., Yang, Z. 2024. Equal predictive ability tests based on panel data with applications to OECD and IMF forecasts. <em>International Journal of Forecasting</em> <b>40</b>, 202&ndash;228.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+pool_av.test">pool_av.test</a></code>, <code><a href="#topic+csc.C1.test">csc.C1.test</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(forecasts)
y &lt;- t(observed)
# just to reduce computation time restrict to energy commodities only
y &lt;- y[1:8,]
f.bsr &lt;- matrix(NA,ncol=ncol(y),nrow=8)
f.dma &lt;- f.bsr
# extract prices predicted by BSR rec and DMA methods
for (i in 1:8)
  {
    f.bsr[i,] &lt;- predicted[[i]][,1]
    f.dma[i,] &lt;- predicted[[i]][,9]
  }
# 2 cross-sectional clusters: crude oil and other energy commodities
cs.cl &lt;- c(1,4)
t &lt;- csc.C3.test(evaluated1=f.bsr,evaluated2=f.dma,realized=y,loss.type="SE",cl=cs.cl)

</code></pre>

<hr>
<h2 id='csc.test'>Computes Test for Cross-Sectional Clusters.</h2><span id='topic+csc.test'></span>

<h3>Description</h3>

<p>This function computes test of the equal predictive accuracy for cross-sectional clusters. The null hypothesis of this test is that a pair of forecasts have the same expected accuracy among cross-sectional clusters. However, their predictive accuracy can be different across the clusters, but the same among each cluster. The test is suitable if either: <code class="reqn">K \ge 2</code> and <code>significance level</code> <code class="reqn">\le 0.08326</code>, or <code class="reqn">2 \le K \le 14</code> and <code>significance level</code> <code class="reqn">\le 0.1</code>, or <code class="reqn">K = \{ 2,3 \} </code> and <code>significance level</code> <code class="reqn">\le 0.2</code>, where <code class="reqn">K</code> denotes the number of time clusters.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>csc.test(evaluated1,evaluated2,realized,loss.type="SE",cl,dc=FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="csc.test_+3A_evaluated1">evaluated1</code></td>
<td>
<p>same as in <code><a href="#topic+pool_av.test">pool_av.test</a></code>, but cross-sections are ordered rowwise</p>
</td></tr>
<tr><td><code id="csc.test_+3A_evaluated2">evaluated2</code></td>
<td>
<p>same as in <code><a href="#topic+pool_av.test">pool_av.test</a></code>, but cross-sections are ordered rowwise</p>
</td></tr>
<tr><td><code id="csc.test_+3A_realized">realized</code></td>
<td>
<p>same as in <code><a href="#topic+pool_av.test">pool_av.test</a></code>, but cross-sections are ordered rowwise</p>
</td></tr>
<tr><td><code id="csc.test_+3A_loss.type">loss.type</code></td>
<td>
<p>same as in <code><a href="#topic+pool_av.test">pool_av.test</a></code></p>
</td></tr>
<tr><td><code id="csc.test_+3A_cl">cl</code></td>
<td>
<p><code><a href="base.html#topic+vector">vector</a></code> of the beginning indices of rows for each pre-defined clusters &ndash; as a result always <code>cl[1]=1</code></p>
</td></tr>
<tr><td><code id="csc.test_+3A_dc">dc</code></td>
<td>
<p><code><a href="base.html#topic+logical">logical</a></code> indicating if apply decorrelating clusters, if not specified <code>dc=FALSE</code> is used</p>
</td></tr>
</table>


<h3>Value</h3>

<p>class <code>htest</code> object, <code><a href="base.html#topic+list">list</a></code> of 
</p>
<table role = "presentation">
<tr><td><code>statistic</code></td>
<td>
<p>test statistic</p>
</td></tr>
<tr><td><code>parameter</code></td>
<td>
<p><code class="reqn">K</code>, number of cross-sectional clusters</p>
</td></tr>
<tr><td><code>alternative</code></td>
<td>
<p>alternative hypothesis of the test</p>
</td></tr>
<tr><td><code>p.value</code></td>
<td>
<p>p-value</p>
</td></tr>
<tr><td><code>method</code></td>
<td>
<p>name of the test</p>
</td></tr>
<tr><td><code>data.name</code></td>
<td>
<p>names of the tested data</p>
</td></tr>
</table>


<h3>References</h3>

<p>Qu, R., Timmermann, A., Zhu, Y. 2024. Comparing forecasting performance with panel data. <em>International Journal of Forecasting</em> <b>40</b>, 918&ndash;941. 
</p>


<h3>See Also</h3>

<p><code><a href="#topic+pool_av.test">pool_av.test</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>data(forecasts)
y &lt;- t(observed)
f.bsr &lt;- matrix(NA,ncol=ncol(y),nrow=56)
f.dma &lt;- f.bsr
# extract prices predicted by BSR rec and DMA methods
for (i in 1:56)
  {
    f.bsr[i,] &lt;- predicted[[i]][,1]
    f.dma[i,] &lt;- predicted[[i]][,9]
  }
# 2 cross-sectional clusters: energy commodities and non-energy commodities
cs.cl &lt;- c(1,9)
t &lt;- csc.test(evaluated1=f.bsr,evaluated2=f.dma,realized=y,loss.type="SE",cl=cs.cl)
</code></pre>

<hr>
<h2 id='observed'>Sample Panel of Commodities Spot Prices.</h2><span id='topic+observed'></span>

<h3>Description</h3>

<p>Observed spot prices of various commodities.</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(forecasts)</code></pre>


<h3>Format</h3>

<p><code>observed</code> is <code><a href="base.html#topic+matrix">matrix</a></code> object such that its columns correspond to spot prices of selected 56 commodities.

</p>


<h3>Details</h3>

<p>They cover the period between 1996 and 2021, and are in monthly freqency. Variables names are the same as in the paper by Drachal and Pawłowski (2024). The observed prices were taken from The World Bank (2022).  
</p>


<h3>References</h3>

<p>Drachal, K., Pawłowski, M. 2024. Forecasting selected commodities' prices with the Bayesian symbolic regression. <em>International Journal of Financial Studies</em> <b>12</b>, 34, <a href="https://doi.org/10.3390/ijfs12020034">doi:10.3390/ijfs12020034</a>
</p>
<p>The World Bank. 2022. Commodity Markets. <a href="https://www.worldbank.org/en/research/commodity-markets">https://www.worldbank.org/en/research/commodity-markets</a> 
</p>


<h3>See Also</h3>

<p><code><a href="#topic+predicted">predicted</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>data(forecasts)
# WTI prices
t1 &lt;- observed[,3]
</code></pre>

<hr>
<h2 id='pool_av.S1.test'>Computes Test for Overall Equal Predictive Ability.</h2><span id='topic+pool_av.S1.test'></span>

<h3>Description</h3>

<p>This function computes test of the equal predictive accuracy for the pooled average. It corresponds to <code class="reqn">S^{(1)}_{nT}</code> statistic in the referenced paper by Akgun et al. (2024). The null hypothesis of this test is that the pooled average loss is equal in expectation for a pair of forecasts from both considered methods. The alternative one is that the differences do not average out across the cross-sectional and time-series dimensions. The test is suitable for situations with cross-sectional independence.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pool_av.S1.test(evaluated1,evaluated2,realized,loss.type="SE")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="pool_av.S1.test_+3A_evaluated1">evaluated1</code></td>
<td>
<p>same as in <code><a href="#topic+pool_av.test">pool_av.test</a></code></p>
</td></tr>
<tr><td><code id="pool_av.S1.test_+3A_evaluated2">evaluated2</code></td>
<td>
<p>same as in <code><a href="#topic+pool_av.test">pool_av.test</a></code></p>
</td></tr>
<tr><td><code id="pool_av.S1.test_+3A_realized">realized</code></td>
<td>
<p>same as in <code><a href="#topic+pool_av.test">pool_av.test</a></code></p>
</td></tr>
<tr><td><code id="pool_av.S1.test_+3A_loss.type">loss.type</code></td>
<td>
<p>same as in <code><a href="#topic+pool_av.test">pool_av.test</a></code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>class <code>htest</code> object, <code><a href="base.html#topic+list">list</a></code> of 
</p>
<table role = "presentation">
<tr><td><code>statistic</code></td>
<td>
<p>test statistic</p>
</td></tr>
<tr><td><code>alternative</code></td>
<td>
<p>alternative hypothesis of the test</p>
</td></tr>
<tr><td><code>p.value</code></td>
<td>
<p>p-value</p>
</td></tr>
<tr><td><code>method</code></td>
<td>
<p>name of the test</p>
</td></tr>
<tr><td><code>data.name</code></td>
<td>
<p>names of the tested data</p>
</td></tr>
</table>


<h3>References</h3>

<p>Akgun, O., Pirotte, A., Urga, G., Yang, Z. 2024. Equal predictive ability tests based on panel data with applications to OECD and IMF forecasts. <em>International Journal of Forecasting</em> <b>40</b>, 202&ndash;228.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+pool_av.test">pool_av.test</a></code>, <code><a href="#topic+pool_av.S3.test">pool_av.S3.test</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>data(forecasts)
y &lt;- t(observed)
f.bsr &lt;- matrix(NA,ncol=ncol(y),nrow=56)
f.dma &lt;- f.bsr
# extract prices predicted by BSR rec and DMA methods
for (i in 1:56)
  {
    f.bsr[i,] &lt;- predicted[[i]][,1]
    f.dma[i,] &lt;- predicted[[i]][,9]
  }
t &lt;- pool_av.S1.test(evaluated1=f.bsr,evaluated2=f.dma,realized=y,loss.type="SE")
</code></pre>

<hr>
<h2 id='pool_av.S3.test'>Computes Test for Overall Equal Predictive Ability.</h2><span id='topic+pool_av.S3.test'></span>

<h3>Description</h3>

<p>This function computes test of the equal predictive accuracy for the pooled average. It corresponds to <code class="reqn">S^{(3)}_{nT}</code> statistic in the referenced paper by Akgun et al. (2024). The null hypothesis of this test is that the pooled average loss is equal in expectation for a pair of forecasts from both considered methods. The alternative one is that the differences do not average out across the cross-sectional and time-series dimensions. The test allows for strong cross-sectional dependence.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pool_av.S3.test(evaluated1,evaluated2,realized,loss.type="SE")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="pool_av.S3.test_+3A_evaluated1">evaluated1</code></td>
<td>
<p>same as in <code><a href="#topic+pool_av.test">pool_av.test</a></code></p>
</td></tr>
<tr><td><code id="pool_av.S3.test_+3A_evaluated2">evaluated2</code></td>
<td>
<p>same as in <code><a href="#topic+pool_av.test">pool_av.test</a></code></p>
</td></tr>
<tr><td><code id="pool_av.S3.test_+3A_realized">realized</code></td>
<td>
<p>same as in <code><a href="#topic+pool_av.test">pool_av.test</a></code></p>
</td></tr>
<tr><td><code id="pool_av.S3.test_+3A_loss.type">loss.type</code></td>
<td>
<p>same as in <code><a href="#topic+pool_av.test">pool_av.test</a></code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>class <code>htest</code> object, <code><a href="base.html#topic+list">list</a></code> of 
</p>
<table role = "presentation">
<tr><td><code>statistic</code></td>
<td>
<p>test statistic</p>
</td></tr>
<tr><td><code>alternative</code></td>
<td>
<p>alternative hypothesis of the test</p>
</td></tr>
<tr><td><code>p.value</code></td>
<td>
<p>p-value</p>
</td></tr>
<tr><td><code>method</code></td>
<td>
<p>name of the test</p>
</td></tr>
<tr><td><code>data.name</code></td>
<td>
<p>names of the tested data</p>
</td></tr>
</table>


<h3>References</h3>

<p>Akgun, O., Pirotte, A., Urga, G., Yang, Z. 2024. Equal predictive ability tests based on panel data with applications to OECD and IMF forecasts. <em>International Journal of Forecasting</em> <b>40</b>, 202&ndash;228.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+pool_av.test">pool_av.test</a></code>, <code><a href="#topic+pool_av.S1.test">pool_av.S1.test</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(forecasts)
y &lt;- t(observed)
# just to reduce computation time shorten time-series
y &lt;- y[,1:40]
f.bsr &lt;- matrix(NA,ncol=ncol(y),nrow=56)
f.dma &lt;- f.bsr
# extract prices predicted by BSR rec and DMA methods
for (i in 1:56)
  {
    f.bsr[i,] &lt;- predicted[[i]][1:40,1]
    f.dma[i,] &lt;- predicted[[i]][1:40,9]
  }
t &lt;- pool_av.S3.test(evaluated1=f.bsr,evaluated2=f.dma,realized=y,loss.type="SE")

</code></pre>

<hr>
<h2 id='pool_av.test'>Computes Test for the Pooled Average.</h2><span id='topic+pool_av.test'></span>

<h3>Description</h3>

<p>This function computes test of the equal predictive accuracy for the pooled average. The null hypothesis of this test is that the pooled average loss is equal in expectation for a pair of forecasts from both considered methods. The alternative hypothesis can be formulated as the differences do not average out across the cross-sectional and time-series dimensions. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pool_av.test(evaluated1,evaluated2,realized,loss.type="SE",J=NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="pool_av.test_+3A_evaluated1">evaluated1</code></td>
<td>
<p><code><a href="base.html#topic+matrix">matrix</a></code> of forecasts from the first method, cross-sections are ordered by rows, and time by columns</p>
</td></tr>
<tr><td><code id="pool_av.test_+3A_evaluated2">evaluated2</code></td>
<td>
<p><code><a href="base.html#topic+matrix">matrix</a></code> of forecasts from the second method, cross-sections are ordered by rows, and time by columns</p>
</td></tr>
<tr><td><code id="pool_av.test_+3A_realized">realized</code></td>
<td>
<p><code><a href="base.html#topic+matrix">matrix</a></code> of the observed values, cross-sections are ordered by rows, and time by columns</p>
</td></tr>
<tr><td><code id="pool_av.test_+3A_loss.type">loss.type</code></td>
<td>
<p>a method to compute the loss function, <code>loss.type="SE"</code> applies squared errors, <code>loss.type="AE"</code> &ndash; absolute errors, <code>loss.type="SPE"</code> &ndash; squared proportional error (useful if errors are heteroskedastic), <code>loss.type="ASE"</code> &ndash; absolute scaled error, if <code>loss.type</code> is specified as some <code><a href="base.html#topic+numeric">numeric</a></code>, then the function of type <code>exp(loss.type*errors)-1-loss.type*errors</code> is applied (useful when it is more costly to underpredict <code>realized</code> than to overpredict), if not specified <code>loss.type="SE"</code> is used</p>
</td></tr>
<tr><td><code id="pool_av.test_+3A_j">J</code></td>
<td>
<p><code><a href="base.html#topic+numeric">numeric</a></code> maximum lag length, if not specified <code>J=round(T^(1/3))</code> is used, where <code>T=ncol(realized)</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>class <code>htest</code> object, <code><a href="base.html#topic+list">list</a></code> of 
</p>
<table role = "presentation">
<tr><td><code>statistic</code></td>
<td>
<p>test statistic</p>
</td></tr>
<tr><td><code>parameter</code></td>
<td>
<p><code>J</code>, maximum lag length</p>
</td></tr>
<tr><td><code>alternative</code></td>
<td>
<p>alternative hypothesis of the test</p>
</td></tr>
<tr><td><code>p.value</code></td>
<td>
<p>p-value</p>
</td></tr>
<tr><td><code>method</code></td>
<td>
<p>name of the test</p>
</td></tr>
<tr><td><code>data.name</code></td>
<td>
<p>names of the tested data</p>
</td></tr>
</table>


<h3>References</h3>

<p>Hyndman, R.J., Koehler, A.B. 2006. Another look at measures of forecast accuracy. <em>International Journal of Forecasting</em> <b>22</b>, 679&ndash;688.
</p>
<p>Qu, R., Timmermann, A., Zhu, Y. 2024. Comparing forecasting performance with panel data. <em>International Journal of Forecasting</em> <b>40</b>, 918&ndash;941. 
</p>
<p>Taylor, S. J., 2005. <em>Asset Price Dynamics, Volatility, and Prediction</em>,  Princeton University Press.
</p>
<p>Triacca, U., 2024. <em>Comparing Predictive Accuracy of Two Forecasts</em>, <a href="https://www.lem.sssup.it/phd/documents/Lesson19.pdf">https://www.lem.sssup.it/phd/documents/Lesson19.pdf</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(forecasts)
y &lt;- t(observed)
f.bsr &lt;- matrix(NA,ncol=ncol(y),nrow=56)
f.dma &lt;- f.bsr
# extract prices predicted by BSR rec and DMA methods
for (i in 1:56)
  {
    f.bsr[i,] &lt;- predicted[[i]][,1]
    f.dma[i,] &lt;- predicted[[i]][,9]
  }
t &lt;- pool_av.test(evaluated1=f.bsr,evaluated2=f.dma,realized=y,loss.type="SE")
</code></pre>

<hr>
<h2 id='predicted'>Sample Panels of Commodities Spot Prices Forecasts.</h2><span id='topic+predicted'></span>

<h3>Description</h3>

<p>Forecasts obtained from various methods applied to various commodities prices.</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(forecasts)</code></pre>


<h3>Format</h3>

<p><code>predicted</code> is <code><a href="base.html#topic+list">list</a></code> of forecasts of spot prices of selected 56 commodities. For each commodity <code><a href="base.html#topic+matrix">matrix</a></code> of forecasts generated by various methods is provided. Columns correspond to various methods. 

</p>


<h3>Details</h3>

<p>The forecasts were taken from Drachal and Pawłowski (2024). They cover the period between 1996 and 2021, and are in monthly freqency. Variables and methods names are the same as in that paper, where they are described in details. 
</p>


<h3>References</h3>

<p>Drachal, K., Pawłowski, M. 2024. Forecasting selected commodities' prices with the Bayesian symbolic regression. <em>International Journal of Financial Studies</em> <b>12</b>, 34, <a href="https://doi.org/10.3390/ijfs12020034">doi:10.3390/ijfs12020034</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+observed">observed</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>data(forecasts)
# WTI prices predicted by BSR rec method
t2 &lt;- predicted[[3]][,1]
</code></pre>

<hr>
<h2 id='tc.test'>Computes Test for Time Clusters.</h2><span id='topic+tc.test'></span>

<h3>Description</h3>

<p>This function computes test of the equal predictive accuracy for time clusters. The null hypothesis of this test is that the equal predictive accuracy for the two methods holds within each of the time clusters. The test is suitable if either: <code class="reqn">K \ge 2</code> and <code>significance level</code> <code class="reqn">\le 0.08326</code>, or <code class="reqn">2 \le K \leq 14</code> and <code>significance level</code> <code class="reqn">\le 0.1</code>, or <code class="reqn">K = \{ 2,3 \} </code> and <code>significance level</code> <code class="reqn">\le 0.2</code>, where <code class="reqn">K</code> denotes the number of time clusters.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tc.test(evaluated1,evaluated2,realized,loss.type="SE",cl)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="tc.test_+3A_evaluated1">evaluated1</code></td>
<td>
<p>same as in <code><a href="#topic+pool_av.test">pool_av.test</a></code></p>
</td></tr>
<tr><td><code id="tc.test_+3A_evaluated2">evaluated2</code></td>
<td>
<p>same as in <code><a href="#topic+pool_av.test">pool_av.test</a></code></p>
</td></tr>
<tr><td><code id="tc.test_+3A_realized">realized</code></td>
<td>
<p>same as in <code><a href="#topic+pool_av.test">pool_av.test</a></code></p>
</td></tr>
<tr><td><code id="tc.test_+3A_loss.type">loss.type</code></td>
<td>
<p>same as in <code><a href="#topic+pool_av.test">pool_av.test</a></code></p>
</td></tr>
<tr><td><code id="tc.test_+3A_cl">cl</code></td>
<td>
<p><code><a href="base.html#topic+vector">vector</a></code> of the beginning indices of each pre-defined blocks of time &ndash; as a result always <code>cl[1]=1</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>class <code>htest</code> object, <code><a href="base.html#topic+list">list</a></code> of 
</p>
<table role = "presentation">
<tr><td><code>statistic</code></td>
<td>
<p>test statistic</p>
</td></tr>
<tr><td><code>parameter</code></td>
<td>
<p><code class="reqn">K</code>, number of time clusters</p>
</td></tr>
<tr><td><code>alternative</code></td>
<td>
<p>alternative hypothesis of the test</p>
</td></tr>
<tr><td><code>p.value</code></td>
<td>
<p>p-value</p>
</td></tr>
<tr><td><code>method</code></td>
<td>
<p>name of the test</p>
</td></tr>
<tr><td><code>data.name</code></td>
<td>
<p>names of the tested data</p>
</td></tr>
</table>


<h3>References</h3>

<p>Qu, R., Timmermann, A., Zhu, Y. 2024. Comparing forecasting performance with panel data. <em>International Journal of Forecasting</em> <b>40</b>, 918&ndash;941. 
</p>


<h3>See Also</h3>

<p><code><a href="#topic+pool_av.test">pool_av.test</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>data(forecasts)
y &lt;- t(observed)
f.bsr &lt;- matrix(NA,ncol=ncol(y),nrow=56)
f.dma &lt;- f.bsr
# extract prices predicted by BSR rec and DMA methods
for (i in 1:56)
  {
    f.bsr[i,] &lt;- predicted[[i]][,1]
    f.dma[i,] &lt;- predicted[[i]][,9]
  }
# 3 time clusters: Jun 1996 -- Nov 2007, Dec 2007 -- Jun 2009, Jul 2009 - Aug 2021
# rownames(observed)[1] 
# rownames(observed)[139] 
# rownames(observed)[158] 
t.cl &lt;- c(1,139,158)
t &lt;- tc.test(evaluated1=f.bsr,evaluated2=f.dma,realized=y,loss.type="SE",cl=t.cl)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
