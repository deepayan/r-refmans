<!DOCTYPE html><html><head><title>Help for package dsims</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {dsims}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#add.hotspot'><p>S4 generic method to add a hotspot to the density grid</p></a></li>
<li><a href='#analyse.data'><p>S4 generic method to run analyses</p></a></li>
<li><a href='#Density-class'><p>Class &quot;Density&quot;</p></a></li>
<li><a href='#Density.Summary-class'><p>Class &quot;Density.Summary&quot;</p></a></li>
<li><a href='#description.summary'><p>Provides a description of the summary object/output</p></a></li>
<li><a href='#Detectability-class'><p>S4 Class &quot;Detectability&quot;</p></a></li>
<li><a href='#DS.Analysis-class'><p>Class &quot;DS.Analysis&quot;</p></a></li>
<li><a href='#dsims-package'><p>Distance Sampling Simulations 'dsims'</p></a></li>
<li><a href='#generate.population'><p>S4 generic method to generate an instance of a population</p></a></li>
<li><a href='#generate.transects,Simulation-method'><p>generate.transects</p></a></li>
<li><a href='#get.densities'><p>Method to get density values</p></a></li>
<li><a href='#get.N'><p>S4 generic method to return N</p></a></li>
<li><a href='#histogram.N.ests'><p>histogram.N.ests</p></a></li>
<li><a href='#make.density'><p>Creates a Density object</p></a></li>
<li><a href='#make.detectability'><p>Creates a Detectability object</p></a></li>
<li><a href='#make.ds.analysis'><p>Creates an Analysis object</p></a></li>
<li><a href='#make.population.description'><p>Creates a Population.Description object</p></a></li>
<li><a href='#make.simulation'><p>Creates a Simulation object</p></a></li>
<li><a href='#plot,Density,ANY-method'><p>Plot</p></a></li>
<li><a href='#plot,Detectability,ANY-method'><p>Plot</p></a></li>
<li><a href='#plot,Population,ANY-method'><p>Plot</p></a></li>
<li><a href='#plot,Survey,Region-method'><p>plot</p></a></li>
<li><a href='#Population-class'><p>Class &quot;Population&quot;</p></a></li>
<li><a href='#Population.Description-class'><p>Class &quot;Population.Description&quot;</p></a></li>
<li><a href='#run.simulation'><p>Method to run a simulation</p></a></li>
<li><a href='#run.survey'><p>S4 generic method to simulate a survey</p></a></li>
<li><a href='#rztpois'><p>Randomly generates values from a zero-truncated Poisson distribution</p></a></li>
<li><a href='#save.sim.results'><p>save.sim.results</p></a></li>
<li><a href='#set.densities'><p>Method to set density values</p></a></li>
<li><a href='#show,Density.Summary-method'><p>show</p></a></li>
<li><a href='#show,Simulation-method'><p>show</p></a></li>
<li><a href='#show,Simulation.Summary-method'><p>show</p></a></li>
<li><a href='#Simulation-class'><p>Class &quot;Simulation&quot;</p></a></li>
<li><a href='#Simulation.Summary-class'><p>Class &quot;Simulation.Summary&quot;</p></a></li>
<li><a href='#summary,Density-method'><p>summary</p></a></li>
<li><a href='#summary,Simulation-method'><p>summary</p></a></li>
<li><a href='#Survey-class'><p>Virtual Class &quot;Survey&quot;</p></a></li>
<li><a href='#Survey.LT-class'><p>Class &quot;Survey.LT&quot; extends class &quot;Survey&quot;</p></a></li>
<li><a href='#Survey.PT-class'><p>Class &quot;Survey.PT&quot; extends class &quot;Survey&quot;</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Depends:</td>
<td>dssd (&ge; 0.2.2)</td>
</tr>
<tr>
<td>Imports:</td>
<td>mrds, Distance, sf, ggplot2, purrr, dplyr, mgcv, methods,
rstudioapi, gridExtra, rlang</td>
</tr>
<tr>
<td>Suggests:</td>
<td>testthat, parallel, pbapply, knitr, lwgeom, rmarkdown</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Distance Sampling Simulations</td>
</tr>
<tr>
<td>Version:</td>
<td>1.0.4</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Laura Marshall &lt;lhm@st-and.ac.uk&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Performs distance sampling simulations. 'dsims' repeatedly generates
    instances of a user defined population within a given survey region. It then 
    generates realisations of a survey design and simulates the detection process. 
    The data are then analysed so that the results can be compared for accuracy 
    and precision across all replications. This process allows users to optimise 
    survey designs for their specific set of survey conditions. The effects of 
    uncertainty in population distribution or parameters can be investigated
    under a number of simulations so that users can be confident that they have
    achieved a robust survey design before deploying vessels into the field. The
    distance sampling designs used in this package from 'dssd' are detailed in
    Chapter 7 of Advanced Distance Sampling, Buckland et. al. (2008, ISBN-13: 
    978-0199225873). General distance sampling methods are detailed in Introduction 
    to Distance Sampling: Estimating Abundance of Biological Populations, Buckland 
    et. al. (2004, ISBN-13: 978-0198509271). Find out more about estimating 
    animal/plant abundance with distance sampling at <a href="http://distancesampling.org/">http://distancesampling.org/</a>.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>Language:</td>
<td>en-GB</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/DistanceDevelopment/dsims">https://github.com/DistanceDevelopment/dsims</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/DistanceDevelopment/dsims/issues">https://github.com/DistanceDevelopment/dsims/issues</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>Collate:</td>
<td>'AICc.R' 'generic.functions.R' 'Density.Summary.R' 'Density.R'
'Population.Description.R' 'Detectability.R' 'Population.R'
'Survey.R' 'DS.Analysis.R' 'Simulation.R' 'ClassConstructors.R'
'Simulation.Summary.R' 'Survey.LT.R' 'Survey.PT.R'
'accumulate.PP.results.R' 'accumulate.warnings.R'
'add.covariate.values.R' 'add.summary.results.R'
'calc.perp.dists.R' 'calc.rad.dists.R'
'calculate.scale.param.R' 'check.covariates.R'
'check.simulation.R' 'check.transects.R'
'create.results.arrays.R' 'description.summary.R'
'dsims-package.R' 'generate.pop.D.R' 'generate.pop.N.R'
'get.covered.area.lines.R' 'get.covered.area.points.R'
'get.density.surface.R' 'message.handler.R'
'modify.strata.for.analysis.R' 'process.dist.shapes.R'
'read.line.transects.R' 'read.point.transects.R'
'read.seg.transects.R' 'run.simulation.R' 'rztpois.R'
'save.sim.results.R' 'simulate.detections.R'
'single.sim.loop.R' 'store.ddf.results.R' 'store.dht.results.R'</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-11-24 13:46:36 UTC; lhm</td>
</tr>
<tr>
<td>Author:</td>
<td>Laura Marshall [aut, cre],
  Thomas Len [ctb]</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-11-29 14:10:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='add.hotspot'>S4 generic method to add a hotspot to the density grid</h2><span id='topic+add.hotspot'></span><span id='topic+add.hotspot+2CDensity-method'></span>

<h3>Description</h3>

<p>Uses a Gaussian decay around a central location to add a hotspot to the
density grid.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>add.hotspot(object, centre, sigma, amplitude)

## S4 method for signature 'Density'
add.hotspot(object, centre, sigma, amplitude)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="add.hotspot_+3A_object">object</code></td>
<td>
<p>a <code><a href="#topic+Density-class">Density-class</a></code> object</p>
</td></tr>
<tr><td><code id="add.hotspot_+3A_centre">centre</code></td>
<td>
<p>an x,y-coordinate giving the centre of the hotspot</p>
</td></tr>
<tr><td><code id="add.hotspot_+3A_sigma">sigma</code></td>
<td>
<p>a value giving the scale parameter for a gaussian decay</p>
</td></tr>
<tr><td><code id="add.hotspot_+3A_amplitude">amplitude</code></td>
<td>
<p>the height of the hotspot at its centre</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the updated <code><a href="#topic+Density-class">Density-class</a></code> object
</p>


<h3>See Also</h3>

<p><code><a href="#topic+make.density">make.density</a></code>
</p>

<hr>
<h2 id='analyse.data'>S4 generic method to run analyses</h2><span id='topic+analyse.data'></span><span id='topic+analyse.data+2CDS.Analysis+2CSurvey-method'></span><span id='topic+analyse.data+2CDS.Analysis+2Cdata.frame-method'></span>

<h3>Description</h3>

<p>This method carries out an analysis of distance sampling data. This method
is provided to allow the user to perform diagnostics of the analyses used
in the simulation. The data argument can be obtained by a call to
<code>simulate.survey(object, dht.table = TRUE)</code>. Note if the first object
supplied is of class DS.Analysis then the second argument must be of class
DDf.Data. The data argument may be of either class for an object argument
of class Simulation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>analyse.data(analysis, data.obj, ...)

## S4 method for signature 'DS.Analysis,Survey'
analyse.data(analysis, data.obj, warnings = NULL, ...)

## S4 method for signature 'DS.Analysis,data.frame'
analyse.data(analysis, data.obj, warnings = NULL, transect = "line", ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="analyse.data_+3A_analysis">analysis</code></td>
<td>
<p>an object of class DS.Analysis</p>
</td></tr>
<tr><td><code id="analyse.data_+3A_data.obj">data.obj</code></td>
<td>
<p>an object of class Survey or a dataframe</p>
</td></tr>
<tr><td><code id="analyse.data_+3A_...">...</code></td>
<td>
<p>optional arguments (currently not used)</p>
</td></tr>
<tr><td><code id="analyse.data_+3A_warnings">warnings</code></td>
<td>
<p>a list of warnings and how many times they arose</p>
</td></tr>
<tr><td><code id="analyse.data_+3A_transect">transect</code></td>
<td>
<p>character value either &quot;line&quot; or &quot;point&quot; specifying type of
transect used in survey</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list containing an S3 ddf object and optionally an S3 dht object relating to the model with the minimum criteria.
</p>
<p>either returns a list of the best model, warnings and the number of successfully
fitted models (if warnings is supplied as a list) otherwise displays warnings as it goes
and returns the best fitting ds model.
</p>

<hr>
<h2 id='Density-class'>Class &quot;Density&quot;</h2><span id='topic+Density-class'></span>

<h3>Description</h3>

<p>Class <code>"Density"</code> is an S4 class containing a list of grids which
describe the density of individuals / clusters of a population. The list
contains one grid (<code>data.frame</code>) for each strata.
</p>


<h3>Slots</h3>


<dl>
<dt><code>region.name</code></dt><dd><p>Object of class <code>"character"</code>; the region name.</p>
</dd>
<dt><code>strata.name</code></dt><dd><p>Object of class <code>"character"</code>; the strata names</p>
</dd>
<dt><code>density.surface</code></dt><dd><p>Object of class <code>"list"</code>; list of data.frames
with the columns x, y and density. There must be one data.frame for each
strata.</p>
</dd>
<dt><code>x.space</code></dt><dd><p>Object of class <code>"numeric"</code>; The spacing between
gridpoints described in the density data.frames in the x-direction.</p>
</dd>
<dt><code>y.space</code></dt><dd><p>Object of class <code>"numeric"</code>; The spacing between
gridpoints described in the density data.frames in the y-direction.</p>
</dd>
<dt><code>units</code></dt><dd><p>Object of class <code>"numeric"</code>; The units of the grid
points.</p>
</dd>
</dl>


<h3>See Also</h3>

<p><code><a href="#topic+make.density">make.density</a></code>
</p>

<hr>
<h2 id='Density.Summary-class'>Class &quot;Density.Summary&quot;</h2><span id='topic+Density.Summary-class'></span>

<h3>Description</h3>

<p>Class <code>"Density.Summary"</code> is an S4 class containing a
summary of the density grids for each strata.
</p>


<h3>Slots</h3>


<dl>
<dt><code>summary</code></dt><dd><p>a summary of the average abundances and densities for
each strata.</p>
</dd>
</dl>


<h3>See Also</h3>

<p><code><a href="#topic+make.density">make.density</a></code>
</p>

<hr>
<h2 id='description.summary'>Provides a description of the summary object/output</h2><span id='topic+description.summary'></span>

<h3>Description</h3>

<p>Prints a list of the terms used in the simulation summary.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>description.summary()
</code></pre>


<h3>Value</h3>

<p>no return, displays an explanation of the simulation summary
</p>


<h3>Author(s)</h3>

<p>Laura Marshall
</p>

<hr>
<h2 id='Detectability-class'>S4 Class &quot;Detectability&quot;</h2><span id='topic+Detectability-class'></span>

<h3>Description</h3>

<p>S4 Class &quot;Detectability&quot;
</p>


<h3>Slots</h3>


<dl>
<dt><code>key.function</code></dt><dd><p>Object of class <code>"character"</code>; a code
specifying the detection function form (&quot;hn&quot; = half normal, &quot;hr&quot; =
hazard rate.)</p>
</dd>
<dt><code>scale.param</code></dt><dd><p>Object of class <code>"numeric"</code>; The scale
parameter for the detection function.</p>
</dd>
<dt><code>shape.param</code></dt><dd><p>Object of class <code>"numeric"</code>; The shape
parameter for the detection function.</p>
</dd>
<dt><code>cov.param</code></dt><dd><p>Object of class <code>"numeric"</code>; The parameter
values associated with the covariates. Not yet implemented</p>
</dd>
<dt><code>truncation</code></dt><dd><p>Object of class <code>"numeric"</code>; The maximum
distance at which objects may be detected.</p>
</dd>
</dl>


<h3>See Also</h3>

<p><code><a href="#topic+make.detectability">make.detectability</a></code>
</p>

<hr>
<h2 id='DS.Analysis-class'>Class &quot;DS.Analysis&quot;</h2><span id='topic+DS.Analysis-class'></span>

<h3>Description</h3>

<p>Class <code>"DDF.Analysis"</code> is an S4 class describing a basic
detection function model to be fitted to distance sampling data.
</p>


<h3>Slots</h3>


<dl>
<dt><code>dfmodel</code></dt><dd><p>Object of class <code>"formula"</code>; describing the
detection function model.</p>
</dd>
<dt><code>key</code></dt><dd><p>key function to use; &quot;hn&quot; gives half-normal (default), &quot;hr&quot;
gives hazard-rate and &quot;unif&quot; gives uniform. Note that if uniform key
is used, covariates cannot be included in the model.</p>
</dd>
<dt><code>adjustment</code></dt><dd><p>a list containing adjustment parameters: adjustment -
either &quot;cos&quot; (recommended), &quot;herm&quot; or &quot;poly&quot;, order - the orders of
the adjustment terms to fit, scale - the scale by which the distances
in the adjustment terms are divided. See details.</p>
</dd>
<dt><code>truncation</code></dt><dd><p>Object of class <code>"list"</code>; Specifies
the truncation distance for the analyses.</p>
</dd>
<dt><code>cutpoints</code></dt><dd><p>Object of class <code>"character"</code>; gives the
cutpoints of the bins for binned data analysis.</p>
</dd>
<dt><code>er.var</code></dt><dd><p>specifies which encounter rate variance estimator to use.</p>
</dd>
<dt><code>control.opts</code></dt><dd><p>A list to specify various options including
monotonicity, method, initial.values.</p>
</dd>
<dt><code>group.strata</code></dt><dd><p>Dataframe with two columns (&quot;design.id&quot; and
&quot;analysis.id&quot;). The former gives the strata names as defined in the
design (i.e. the region object) the second specifies how they should
be grouped (into less strata) for the analyses</p>
</dd>
<dt><code>criteria</code></dt><dd><p>Object of class <code>"character"</code>; describes
which model selection criteria to use (&quot;AIC&quot;,&quot;AICc&quot;,&quot;BIC&quot;).</p>
</dd>
</dl>


<h3>Methods</h3>


<dl>
<dt><code>run.analysis</code></dt><dd><p><code>signature=c(object = "DS.Analysis",
 data = data.frame)</code>: runs the analysis described in the object on the
data provided.</p>
</dd>
</dl>


<hr>
<h2 id='dsims-package'>Distance Sampling Simulations 'dsims'</h2><span id='topic+dsims-package'></span><span id='topic+dsims'></span>

<h3>Description</h3>

<p>Runs simulations of distance sampling surveys to help users optimise
their survey designs for their particular study.
</p>


<h3>Details</h3>

<p>The full process involves defining the study region, a description of the
population of interest (including its distribution within the study region),
a survey design, a detection process and one or more models to fit to the
resulting data. The simulation engine will then use this information to
generate both a population and a set of transects and simulate the detection
process. The resulting data will be analysed and the estimates stored.
By repeating this many times we can test the accuracy and precision of
our estimates from various survey designs given our particular population
of interest.
</p>
<p>This package interfaces with the survey design package 'dssd' to create the survey
regions, designs and generate the survey transects. While the 'DSsim' simulation
package relied on survey transects already being contained in shapefiles within
the supplied directory, dsims will generate the survey transects directly in R.
</p>
<p>The main functions in this package are: <a href="#topic+make.density">make.density</a>, <a href="#topic+make.population.description">make.population.description</a>, <a href="#topic+make.detectability">make.detectability</a>, <a href="#topic+make.ds.analysis">make.ds.analysis</a>, <a href="#topic+make.simulation">make.simulation</a>, <a href="#topic+run.survey">run.survey</a> and <a href="#topic+run.simulation">run.simulation</a>. See also make.region and make.design in the dssd package for examples of how to define study regions and designs.
</p>
<p>Further information on distance sampling methods and example code is available at <a href="http://distancesampling.org/R/">http://distancesampling.org/R/</a>.
</p>
<p>Also see our website for vignettes / example code at <a href="http://examples.distancesampling.org">http://examples.distancesampling.org</a>.
</p>
<p>For help with distance sampling and this package, there is a Google Group <a href="https://groups.google.com/forum/#!forum/distance-sampling">https://groups.google.com/forum/#!forum/distance-sampling</a>.
</p>


<h3>Author(s)</h3>

<p>Laura Marshall &lt;lhm@st-and.ac.uk&gt;
</p>

<hr>
<h2 id='generate.population'>S4 generic method to generate an instance of a population</h2><span id='topic+generate.population'></span><span id='topic+generate.population+2CPopulation.Description-method'></span><span id='topic+generate.population+2CSimulation-method'></span>

<h3>Description</h3>

<p>Uses the population description and detectability details to generate an
instance of the population. Note that if the first argument supplied is
of class Population.Description rather than class Simulation then
detectability and region must also be supplied.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>generate.population(object, ...)

## S4 method for signature 'Population.Description'
generate.population(object, detectability = NULL, region = NULL)

## S4 method for signature 'Simulation'
generate.population(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="generate.population_+3A_object">object</code></td>
<td>
<p>an object of class Simulation or Population.Description</p>
</td></tr>
<tr><td><code id="generate.population_+3A_...">...</code></td>
<td>
<p>when this is called on an object of class Population.Description
the additional arguments detectability and region.obj should also be supplied</p>
</td></tr>
<tr><td><code id="generate.population_+3A_detectability">detectability</code></td>
<td>
<p>object of class Detectability (optional - only
required if object is of class Population.Description)</p>
</td></tr>
<tr><td><code id="generate.population_+3A_region">region</code></td>
<td>
<p>the region object for the population (optional - only
required if object is of class Population.Description)</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code><a href="#topic+Population-class">Population-class</a></code> object
</p>

<hr>
<h2 id='generate.transects+2CSimulation-method'>generate.transects</h2><span id='topic+generate.transects+2CSimulation-method'></span>

<h3>Description</h3>

<p>Generates a set of transects based on the design provided.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'Simulation'
generate.transects(object, quiet = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="generate.transects+2B2CSimulation-method_+3A_object">object</code></td>
<td>
<p>object of class Simulation</p>
</td></tr>
<tr><td><code id="generate.transects+2B2CSimulation-method_+3A_quiet">quiet</code></td>
<td>
<p>if TRUE silences some warnings</p>
</td></tr>
<tr><td><code id="generate.transects+2B2CSimulation-method_+3A_...">...</code></td>
<td>
<p>not implemented</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an object of class Transect from dssd package
</p>

<hr>
<h2 id='get.densities'>Method to get density values</h2><span id='topic+get.densities'></span>

<h3>Description</h3>

<p>This method extracts the density values from a density object. It will
optionally also return the x and y centre points for the density grid
cells.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get.densities(density, coords = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get.densities_+3A_density">density</code></td>
<td>
<p>object of class Density</p>
</td></tr>
<tr><td><code id="get.densities_+3A_coords">coords</code></td>
<td>
<p>if TRUE also returns x, y coordinates</p>
</td></tr>
</table>


<h3>Value</h3>

<p>either returns a numeric vector of density values or a dataframe
with columns x, y and density.
</p>

<hr>
<h2 id='get.N'>S4 generic method to return N</h2><span id='topic+get.N'></span><span id='topic+get.N+2CPopulation.Description-method'></span>

<h3>Description</h3>

<p>Returns the population size
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get.N(object)

## S4 method for signature 'Population.Description'
get.N(object)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get.N_+3A_object">object</code></td>
<td>
<p>an object of class Population.Description</p>
</td></tr>
</table>


<h3>Value</h3>

<p>numeric value of the population size
</p>

<hr>
<h2 id='histogram.N.ests'>histogram.N.ests</h2><span id='topic+histogram.N.ests'></span>

<h3>Description</h3>

<p>Plots a histogram of the estimates abundances
</p>


<h3>Usage</h3>

<pre><code class='language-R'>histogram.N.ests(x, use.max.reps = FALSE, N.ests = "individuals", ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="histogram.N.ests_+3A_x">x</code></td>
<td>
<p>object of class Simulation</p>
</td></tr>
<tr><td><code id="histogram.N.ests_+3A_use.max.reps">use.max.reps</code></td>
<td>
<p>by default this is FALSE meaning that only simulation repetitions where all models converged for that data set are included. By setting this to TRUE any repetition where one or more models converged will be included in the summary results.</p>
</td></tr>
<tr><td><code id="histogram.N.ests_+3A_n.ests">N.ests</code></td>
<td>
<p>character indicating whether to plot estimates of abundance of 'individuals',
'clusters' or 'both'. By default this is individuals.</p>
</td></tr>
<tr><td><code id="histogram.N.ests_+3A_...">...</code></td>
<td>
<p>optional parameters to pass to the generic hist function in graphics</p>
</td></tr>
</table>


<h3>Value</h3>

<p>No return value, displays a histogram of the abundance estimates
</p>

<hr>
<h2 id='make.density'>Creates a Density object</h2><span id='topic+make.density'></span>

<h3>Description</h3>

<p>Creates a density grid across the study area describing the distribution
of animals.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>make.density(
  region = make.region(),
  x.space = 20,
  y.space = NULL,
  constant = numeric(0),
  fitted.model = NULL,
  density.formula = NULL,
  density.surface = list()
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="make.density_+3A_region">region</code></td>
<td>
<p>the Region object in which the density grid will be created</p>
</td></tr>
<tr><td><code id="make.density_+3A_x.space">x.space</code></td>
<td>
<p>the intervals in the grid in the x direction</p>
</td></tr>
<tr><td><code id="make.density_+3A_y.space">y.space</code></td>
<td>
<p>the intervals in the grid in the y direction</p>
</td></tr>
<tr><td><code id="make.density_+3A_constant">constant</code></td>
<td>
<p>a value describing a constant density across the surface. If not supplied a default value of 1 is used for all strata.</p>
</td></tr>
<tr><td><code id="make.density_+3A_fitted.model">fitted.model</code></td>
<td>
<p><code>gam</code> object created using <code>mgcv</code> with only x and y as explanatory covariates.</p>
</td></tr>
<tr><td><code id="make.density_+3A_density.formula">density.formula</code></td>
<td>
<p>a formula of x and/or y describing the
density surface.</p>
</td></tr>
<tr><td><code id="make.density_+3A_density.surface">density.surface</code></td>
<td>
<p>Object of class <code>list</code>; an sf grid recording
the density grid polygons, density values within those polygons and the
central x and y coordinates.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>There are multiple ways to create the density grid. The most straight forward
is to create a grid with constant values (to which high and low areas can later
be added) or pass in a fitted <code>mgcv gam</code>. The gam model should only be fitted
with x and y as explanatory variables. If you plan on trying multiple
animal distributions by adding high and low areas to a constant surface it is
recommended to make a copy of the initial flat density grid object as the first
step in grid generation is computationally intensive and can take a little while
to complete, especially if you have a fine density grid.
</p>


<h3>Value</h3>

<p><code><a href="#topic+Density-class">Density-class</a></code> object
</p>


<h3>Author(s)</h3>

<p>Laura Marshall
</p>


<h3>See Also</h3>

<p><code>make.region</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># A simple density surface with a constant value of 1 can be created within a rectangular
# Create a region from shapefile
shapefile.name &lt;- system.file("extdata", "StAndrew.shp", package = "dssd")
region &lt;- make.region(region.name = "St Andrews bay",
                      shape = shapefile.name)

# Create a density object
density &lt;- make.density(region = region,
                       x.space = 1000,
                       constant = 1)

# Add some ares of higher / lower density
density &lt;- add.hotspot(object = density,
                       centre = c(-170000, 6255000),
                       sigma = 10000,
                       amplitude = 4)
density &lt;- add.hotspot(object = density,
                       centre = c(-150000, 6240000),
                       sigma = 10000,
                       amplitude = -0.9)

# Plot the density
plot(density, region)

</code></pre>

<hr>
<h2 id='make.detectability'>Creates a Detectability object</h2><span id='topic+make.detectability'></span>

<h3>Description</h3>

<p>The detectability of the population is described by the values in this
class.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>make.detectability(
  key.function = "hn",
  scale.param = 25,
  shape.param = numeric(0),
  cov.param = list(),
  truncation = 50
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="make.detectability_+3A_key.function">key.function</code></td>
<td>
<p>specifies shape of the detection function (either
half-normal &quot;hn&quot;, hazard rate &quot;hr&quot; or uniform &quot;uf&quot;)</p>
</td></tr>
<tr><td><code id="make.detectability_+3A_scale.param">scale.param</code></td>
<td>
<p>numeric vector with either a single value to be applied globally or a value for each strata. These should be supplied on the natural scale.</p>
</td></tr>
<tr><td><code id="make.detectability_+3A_shape.param">shape.param</code></td>
<td>
<p>numeric vector with either a single value to be applied globally or a value for each strata. These should be supplied on the natural scale.</p>
</td></tr>
<tr><td><code id="make.detectability_+3A_cov.param">cov.param</code></td>
<td>
<p>Named list with one named entry per individual level covariate. Covariate parameter values should be defined on the log scale (rather than the natural scale), this is the same scale as provided in the ddf output in mrds and also in the MCDS output in Distance. Cluster sizes parameter values can be defined here. Each list entry will either be a data.frame containing 2 or 3 columns: level, param and where desired strata. If the region has multiple strata but this column is omitted then the values will be assumed to apply globally. The cluster size entry in the list must be named 'size'. Alternatively the list element may a numeric vector with either a single value to be applied globally or a value for each strata.</p>
</td></tr>
<tr><td><code id="make.detectability_+3A_truncation">truncation</code></td>
<td>
<p>the maximum perpendicular (or radial) distance at which
objects may be detected from a line (or point) transect.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code><a href="#topic+Detectability-class">Detectability-class</a></code> object
</p>


<h3>Author(s)</h3>

<p>Laura Marshall
</p>


<h3>See Also</h3>

<p><code><a href="#topic+make.simulation">make.simulation</a></code> <code><a href="#topic+make.population.description">make.population.description</a></code> <code><a href="#topic+make.density">make.density</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Multi-strata example (make sf shape)
s1 = matrix(c(0,0,0,2,1,2,1,0,0,0),ncol=2, byrow=TRUE)
s2 = matrix(c(1,0,1,2,2,2,2,0,1,0),ncol=2, byrow=TRUE)
pol1 = sf::st_polygon(list(s1))
pol2 = sf::st_polygon(list(s2))
sfc &lt;- sf::st_sfc(pol1,pol2)
strata.names &lt;- c("low", "high")
sf.pol &lt;- sf::st_sf(strata = strata.names, geom = sfc)

region &lt;- make.region(region.name = "Multi-strata Eg",
                      strata.name = strata.names,
                      shape = sf.pol)

density &lt;- make.density(region = region,
                        x.space = 0.22,
                        constant = c(20,50))

covs &lt;- list()
covs$size &lt;- list(list(distribution = "poisson", lambda = 25),
                  list(distribution = "poisson", lambda = 15))
covs$sex &lt;- data.frame(level = rep(c("male", "female"),2),
                      prob = c(0.5, 0.5, 0.6, 0.4),
                      strata = c(rep("low",2),rep("high",2)))

# Define the population description (this time using the density to determine
# the population size)
popdesc &lt;- make.population.description(region = region,
                                       density = density,
                                       covariates = covs,
                                       fixed.N = FALSE)

cov.param &lt;- list()
cov.param$size &lt;- c(log(1.02),log(1.005))
cov.param$sex &lt;- data.frame(level = c("male", "female", "male", "female"),
                            param = c(log(1.5), 0, log(1.7), log(1.2)),
                            strata = c("low","low","high","high"))

# define the detecability
detect &lt;- make.detectability(key.function = "hn",
                             scale.param = 0.08,
                             cov.param = cov.param,
                             truncation = 0.2)

plot(detect, popdesc)

</code></pre>

<hr>
<h2 id='make.ds.analysis'>Creates an Analysis object</h2><span id='topic+make.ds.analysis'></span>

<h3>Description</h3>

<p>This method creates an Analysis objects which describes a one or more
models to fit to the distance data. The simulation will fit each of these
models to the data generated in the simulation and select the model with
the minimum criteria value.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>make.ds.analysis(
  dfmodel = list(~1),
  key = "hn",
  truncation = numeric(0),
  cutpoints = numeric(0),
  er.var = "R2",
  control.opts = list(),
  group.strata = data.frame(),
  criteria = "AIC"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="make.ds.analysis_+3A_dfmodel">dfmodel</code></td>
<td>
<p>list of distance sampling model formula specifying the detection function
(see <code>?Distance::ds</code> for further details)</p>
</td></tr>
<tr><td><code id="make.ds.analysis_+3A_key">key</code></td>
<td>
<p>key function to use; &quot;hn&quot; gives half-normal (default) and &quot;hr&quot; gives
hazard-rate.</p>
</td></tr>
<tr><td><code id="make.ds.analysis_+3A_truncation">truncation</code></td>
<td>
<p>absolute truncation distance in simulation units matching the
region units.</p>
</td></tr>
<tr><td><code id="make.ds.analysis_+3A_cutpoints">cutpoints</code></td>
<td>
<p>supply a vector of cutpoints if you wish the simulation to perform
binned analyses.</p>
</td></tr>
<tr><td><code id="make.ds.analysis_+3A_er.var">er.var</code></td>
<td>
<p>encounter rate variance estimator to use when abundance estimates are
required. Defaults to &quot;R2&quot; for line transects and &quot;P3&quot; for point transects. See
<code>mrds::varn</code> for more information / options.</p>
</td></tr>
<tr><td><code id="make.ds.analysis_+3A_control.opts">control.opts</code></td>
<td>
<p>A list of control options: method - optimisation method,</p>
</td></tr>
<tr><td><code id="make.ds.analysis_+3A_group.strata">group.strata</code></td>
<td>
<p>Dataframe with two columns (&quot;design.id&quot; and &quot;analysis.id&quot;). The
former gives the strata names as defined in the design (i.e. the region object) the
second specifies how they should be grouped (into less strata) for the analyses. See
details for more information.</p>
</td></tr>
<tr><td><code id="make.ds.analysis_+3A_criteria">criteria</code></td>
<td>
<p>character model selection criteria (AIC, AICc, BIC)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>It is possible to group strata at the analysis stage using the group.strata
argument. For example, for design purposes it may have been sensible to
divide strata into substrata. This can help make more convex shapes and
therefore zigzag designs more efficient or perhaps it helped to keep
transects angled parallel to density gradients across the study area.
Despite these (purely design relevant) substrata we may still wish to
calculate estimates of density / abundance etc. for each stratum. The
table below gives an example of the data.frame which can be used to do
this. Imagine a study region with an onshore strata and an offshore
strata. The onshore strata has been divided in two at the design stage
to keep transects perpendicular to the coast. We now want to analyse
this as just two strata the onshore and offshore.
</p>

<table>
<tr>
 <td style="text-align: left;"> design.id         </td><td style="text-align: left;"> analysis.id </td>
</tr>
<tr>
 <td style="text-align: left;">
              ---------         </td><td style="text-align: left;"> ----------- </td>
</tr>
<tr>
 <td style="text-align: left;">
              onshoreN          </td><td style="text-align: left;"> onshore     </td>
</tr>
<tr>
 <td style="text-align: left;">
              onshoreS          </td><td style="text-align: left;"> onshore     </td>
</tr>
<tr>
 <td style="text-align: left;">
              offshore          </td><td style="text-align: left;"> offshore    </td>
</tr>

</table>



<h3>Value</h3>

<p><code><a href="#topic+DS.Analysis-class">DS.Analysis-class</a></code> object
</p>


<h3>Author(s)</h3>

<p>Laura Marshall
</p>


<h3>See Also</h3>

<p><code>ds</code> <code><a href="#topic+make.simulation">make.simulation</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Model selection considering both a half-normal and a hazard-rate model
# using AIC criteria and truncating 5% of the data
ds.analyses &lt;- make.ds.analysis(dfmodel = ~1,
                                key = c("hn", "hr"),
                                truncation = 500,
                                criteria = "AIC")

# Model selection considering both a half-normal with no covariates and with size
# as a covariate using AIC criteria and truncating at 500
ds.analyses &lt;- make.ds.analysis(dfmodel = list(~1, ~size),
                                key = "hn",
                                truncation = 500,
                                criteria = "AIC")

# Model selection considering both a half-normal with no covariates and with size
# as a covariate and a hazard rate, using AIC criteria and truncating at 500
ds.analyses &lt;- make.ds.analysis(dfmodel = list(~1, ~size, ~1),
                                key = c("hn", "hn", "hr"),
                                truncation = 500,
                                criteria = "AIC")

</code></pre>

<hr>
<h2 id='make.population.description'>Creates a Population.Description object</h2><span id='topic+make.population.description'></span>

<h3>Description</h3>

<p>Creates an object which describes a population. The values in this object
will be used to create instances of the population.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>make.population.description(
  region = make.region(),
  density = make.density(),
  covariates = list(),
  N = numeric(0),
  fixed.N = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="make.population.description_+3A_region">region</code></td>
<td>
<p>the Region object in which this population exists (see make.region).</p>
</td></tr>
<tr><td><code id="make.population.description_+3A_density">density</code></td>
<td>
<p>the Density object describing the distribution of the individuals / clusters (see <a href="#topic+make.density">make.density</a>).</p>
</td></tr>
<tr><td><code id="make.population.description_+3A_covariates">covariates</code></td>
<td>
<p>Named list with one named entry per individual-level covariate. Cluster sizes can be defined here, it must be named 'size'. The distribution of covariate values can either be defined by specifying a particular distribution and its parameters or as a discrete distribution in a dataframe. Dataframes should have columns level and prob (and optionally strata) specifying the covariates levels, probabilities and strata if they are strata specific. Distributions can be defined as lists with named entries distribution and the relevant parameters as specified in details. A list of distributions can be provided with one for each strata.</p>
</td></tr>
<tr><td><code id="make.population.description_+3A_n">N</code></td>
<td>
<p>the number of individuals / clusters in a population with one value per
strata. Total population size is 1000 by default.</p>
</td></tr>
<tr><td><code id="make.population.description_+3A_fixed.n">fixed.N</code></td>
<td>
<p>a logical value. If TRUE the population is generated from the value(s)
of N otherwise it is generated from the values in the density grid.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Individual-level covariate values can be defined as one of the following distributions: 'normal', 'poisson', 'ztruncpois' or 'lognormal'. The distribution name and the associated parameters as defined in the table below must be provided in a named list. Either one list can be provided for the entire study area or multiple lists grouped together as a list with one per strata.
</p>

<table>
<tr>
 <td style="text-align: left;"> Distribution  </td><td style="text-align: left;"> Parameters  </td><td style="text-align: left;">         </td>
</tr>
<tr>
 <td style="text-align: left;">
               normal        </td><td style="text-align: left;"> mean        </td><td style="text-align: left;"> sd      </td>
</tr>
<tr>
 <td style="text-align: left;">
               poisson       </td><td style="text-align: left;"> lambda      </td><td style="text-align: left;">         </td>
</tr>
<tr>
 <td style="text-align: left;">
               ztruncpois    </td><td style="text-align: left;"> mean        </td><td style="text-align: left;">         </td>
</tr>
<tr>
 <td style="text-align: left;">
               lognormal     </td><td style="text-align: left;"> meanlog     </td><td style="text-align: left;"> sdlog   </td>
</tr>
<tr>
 <td style="text-align: left;">
              </td>
</tr>

</table>



<h3>Value</h3>

<p><code><a href="#topic+Population.Description-class">Population.Description-class</a></code>
</p>


<h3>Author(s)</h3>

<p>Laura Marshall
</p>


<h3>See Also</h3>

<p><code><a href="#topic+make.simulation">make.simulation</a></code> <code><a href="#topic+make.detectability">make.detectability</a></code> <code><a href="#topic+make.density">make.density</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Create a basic rectangular study area
region &lt;- make.region()

# Make a density grid (large spacing for speed)
density &lt;- make.density(region = region,
                        x.space = 200,
                        y.space = 100,
                        constant = 1)
density &lt;- add.hotspot(density, centre = c(1000, 100), sigma = 250, amplitude = 10)

# Define some covariate values for out population
covs &lt;- list()
covs$size &lt;- list(distribution = "ztruncpois", mean = 5)

# Define the population description
popdsc &lt;- make.population.description(region = region,
                                      density = density,
                                      covariates = covs,
                                      N = 200)

# define the detecability
detect &lt;- make.detectability(key.function = "hn", scale.param = 25, truncation = 50)

# generate an example population
pop &lt;- generate.population(popdsc, region = region, detectability = detect)

plot(pop, region)

# Multi-strata example (make sf shape)
s1 = matrix(c(0,0,0,2,1,2,1,0,0,0),ncol=2, byrow=TRUE)
s2 = matrix(c(1,0,1,2,2,2,2,0,1,0),ncol=2, byrow=TRUE)
pol1 = sf::st_polygon(list(s1))
pol2 = sf::st_polygon(list(s2))
sfc &lt;- sf::st_sfc(pol1,pol2)
strata.names &lt;- c("low", "high")
sf.pol &lt;- sf::st_sf(strata = strata.names, geom = sfc)

region &lt;- make.region(region.name = "Multi-strata Eg",
                      strata.name = strata.names,
                      shape = sf.pol)

density &lt;- make.density(region = region,
                        x.space = 0.22,
                        constant = c(10,80))

covs &lt;- list()
covs$size &lt;- list(list(distribution = "poisson", lambda = 25),
                  list(distribution = "poisson", lambda = 15))
covs$sex &lt;- data.frame(level = rep(c("male", "female"),2),
                      prob = c(0.5, 0.5, 0.6, 0.4),
                      strata = c(rep("low",2),rep("high",2)))

# Define the population description (this time using the density to determine
# the population size)
popdesc &lt;- make.population.description(region = region,
                                       density = density,
                                       covariates = covs,
                                       fixed.N = FALSE)

# define the detecability (see make.detectability to alter detection function
# for different covariate values)
detect &lt;- make.detectability(key.function = "hn", scale.param = 25, truncation = 50)

# generate an example population
pop &lt;- generate.population(popdesc, region = region, detectability = detect)

plot(pop, region)


</code></pre>

<hr>
<h2 id='make.simulation'>Creates a Simulation object</h2><span id='topic+make.simulation'></span>

<h3>Description</h3>

<p>This creates a simulation with all the information necessary for dsims
to generate a population, create transects, simulate the survey process
and fit detection functions and estimate density / abundance. This function can be
used by itself based on default values to create a simple line transect example, see
Examples below. To create more complex simulations it is advisable to define the
different parts of the simulation individually before grouping them together. See
the Arguments for links to the functions which make the definitions for the
individual simulation components. For a more in depth example please refer to the
'GettingStarted' vignette.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>make.simulation(
  reps = 10,
  design = make.design(),
  population.description = make.population.description(),
  detectability = make.detectability(),
  ds.analysis = make.ds.analysis()
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="make.simulation_+3A_reps">reps</code></td>
<td>
<p>number of times the simulation should be repeated</p>
</td></tr>
<tr><td><code id="make.simulation_+3A_design">design</code></td>
<td>
<p>an object of class Survey.Design created by a call to
make.design</p>
</td></tr>
<tr><td><code id="make.simulation_+3A_population.description">population.description</code></td>
<td>
<p>an object of class Population.Description
created by a call to <a href="#topic+make.population.description">make.population.description</a></p>
</td></tr>
<tr><td><code id="make.simulation_+3A_detectability">detectability</code></td>
<td>
<p>and object of class Detectability created by a call to
<a href="#topic+make.detectability">make.detectability</a></p>
</td></tr>
<tr><td><code id="make.simulation_+3A_ds.analysis">ds.analysis</code></td>
<td>
<p>an objects of class DS.Analysis created by
a call to <a href="#topic+make.ds.analysis">make.ds.analysis</a></p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>make.simulation</code> function is now set up so that by
default (with the exception of specifying point transects rather than
line) it can run a simple simulation example. See examples.
</p>


<h3>Value</h3>

<p><code><a href="#topic+Simulation-class">Simulation-class</a></code> object
</p>


<h3>Author(s)</h3>

<p>Laura Marshall
</p>


<h3>See Also</h3>

<p><code>make.region</code> <code><a href="#topic+make.density">make.density</a></code> <code><a href="#topic+make.population.description">make.population.description</a></code> <code><a href="#topic+make.detectability">make.detectability</a></code> <code><a href="#topic+make.ds.analysis">make.ds.analysis</a></code> <code>make.design</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Create a basic rectangular study area
region &lt;- make.region()

# Make a density grid (large spacing for speed)
density &lt;- make.density(region = region,
                        x.space = 300,
                        y.space = 100,
                        constant = 1)
density &lt;- add.hotspot(density, centre = c(1000, 100), sigma = 250, amplitude = 10)

# Define the population description
popdsc &lt;- make.population.description(region = region,
                                      density = density,
                                      N = 200)

# Define the detecability
detect &lt;- make.detectability(key.function = "hn",
                             scale.param = 25,
                             truncation = 50)

# Define the design
design &lt;- make.design(region = region,
                      transect.type = "line",
                      design = "systematic",
                      samplers = 20,
                      design.angle = 0,
                      truncation = 50)

# Define the analyses
ds.analyses &lt;- make.ds.analysis(dfmodel = ~1,
                                key = "hn",
                                truncation = 50,
                                criteria = "AIC")

# Put all the components together in the simulation (note no. of replicates
# reps = 1 is only for a single test run and should be 999 or more to be able
# to draw inference.)
simulation &lt;- make.simulation(reps = 1,
                              design = design,
                              population.description = popdsc,
                              detectability = detect,
                              ds.analysis = ds.analyses)

# run an example survey to check the setup
survey &lt;- run.survey(simulation)
plot(survey, region)

# Run the simulation
# Warning: if you have increased the number of replications then it can take a
# long time to run!
simulation &lt;- run.simulation(simulation)
summary(simulation)

# For a more in depth example please look at
vignette("GettingStarted", 'dsims')

</code></pre>

<hr>
<h2 id='plot+2CDensity+2CANY-method'>Plot</h2><span id='topic+plot+2CDensity+2CANY-method'></span><span id='topic+plot+2CDensity+2CRegion-method'></span>

<h3>Description</h3>

<p>Plots an S4 object of class 'Density'
</p>
<p>Plots an S4 object of class 'Density'
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'Density,ANY'
plot(x, y, strata = "all", title = "", scale = 1)

## S4 method for signature 'Density,Region'
plot(x, y, strata = "all", title = "", scale = 1, line.col = gray(0.2))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot+2B2CDensity+2B2CANY-method_+3A_x">x</code></td>
<td>
<p>object of class Density</p>
</td></tr>
<tr><td><code id="plot+2B2CDensity+2B2CANY-method_+3A_y">y</code></td>
<td>
<p>object of class Region</p>
</td></tr>
<tr><td><code id="plot+2B2CDensity+2B2CANY-method_+3A_strata">strata</code></td>
<td>
<p>the strata name or number to be plotted. By default
all strata will be plotted.</p>
</td></tr>
<tr><td><code id="plot+2B2CDensity+2B2CANY-method_+3A_title">title</code></td>
<td>
<p>plot title</p>
</td></tr>
<tr><td><code id="plot+2B2CDensity+2B2CANY-method_+3A_scale">scale</code></td>
<td>
<p>used to scale the x and y values in the plot (warning may give
unstable results when a projection is defined for the study area!)</p>
</td></tr>
<tr><td><code id="plot+2B2CDensity+2B2CANY-method_+3A_line.col">line.col</code></td>
<td>
<p>sets the line colour for the shapefile</p>
</td></tr>
</table>


<h3>Value</h3>

<p>ggplot object
</p>
<p>ggplot object
</p>

<hr>
<h2 id='plot+2CDetectability+2CANY-method'>Plot</h2><span id='topic+plot+2CDetectability+2CANY-method'></span><span id='topic+plot+2CDetectability+2CPopulation.Description-method'></span>

<h3>Description</h3>

<p>Plots an S4 object of class 'Detectability'
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'Detectability,ANY'
plot(
  x,
  y,
  add = FALSE,
  plot.units = character(0),
  region.col = NULL,
  gap.col = NULL,
  main = "",
  ...
)

## S4 method for signature 'Detectability,Population.Description'
plot(
  x,
  y,
  add = FALSE,
  plot.units = character(0),
  region.col = NULL,
  gap.col = NULL,
  main = "",
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot+2B2CDetectability+2B2CANY-method_+3A_x">x</code></td>
<td>
<p>object of class Detectability</p>
</td></tr>
<tr><td><code id="plot+2B2CDetectability+2B2CANY-method_+3A_y">y</code></td>
<td>
<p>object of class Population.Description</p>
</td></tr>
<tr><td><code id="plot+2B2CDetectability+2B2CANY-method_+3A_add">add</code></td>
<td>
<p>logical indicating whether it should be added to
existing plot</p>
</td></tr>
<tr><td><code id="plot+2B2CDetectability+2B2CANY-method_+3A_plot.units">plot.units</code></td>
<td>
<p>allows for units to be converted between m
and km</p>
</td></tr>
<tr><td><code id="plot+2B2CDetectability+2B2CANY-method_+3A_region.col">region.col</code></td>
<td>
<p>fill colour for the region</p>
</td></tr>
<tr><td><code id="plot+2B2CDetectability+2B2CANY-method_+3A_gap.col">gap.col</code></td>
<td>
<p>fill colour for the gaps</p>
</td></tr>
<tr><td><code id="plot+2B2CDetectability+2B2CANY-method_+3A_main">main</code></td>
<td>
<p>character plot title</p>
</td></tr>
<tr><td><code id="plot+2B2CDetectability+2B2CANY-method_+3A_...">...</code></td>
<td>
<p>other general plot parameters</p>
</td></tr>
</table>


<h3>Value</h3>

<p>No return value, gives a warning to the user
</p>
<p>No return value, plotting function
</p>

<hr>
<h2 id='plot+2CPopulation+2CANY-method'>Plot</h2><span id='topic+plot+2CPopulation+2CANY-method'></span><span id='topic+plot+2CPopulation+2CRegion-method'></span>

<h3>Description</h3>

<p>Unused, will give a warning that the region must also be supplied.
</p>
<p>Plots an S4 object of class 'Population'. Requires that the
associated region has already been plotted. This function adds
the locations of the individuals/clusters in the population.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'Population,ANY'
plot(x, y, ...)

## S4 method for signature 'Population,Region'
plot(x, y, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot+2B2CPopulation+2B2CANY-method_+3A_x">x</code></td>
<td>
<p>object of class Population</p>
</td></tr>
<tr><td><code id="plot+2B2CPopulation+2B2CANY-method_+3A_y">y</code></td>
<td>
<p>object of class Region</p>
</td></tr>
<tr><td><code id="plot+2B2CPopulation+2B2CANY-method_+3A_...">...</code></td>
<td>
<p>other general plot parameters</p>
</td></tr>
</table>


<h3>Value</h3>

<p>ggplot object
</p>

<hr>
<h2 id='plot+2CSurvey+2CRegion-method'>plot</h2><span id='topic+plot+2CSurvey+2CRegion-method'></span><span id='topic+plot+2CSurvey+2CANY-method'></span>

<h3>Description</h3>

<p>Produces four plots of the survey: 1) Plots the transects inside the survey
region, 2) plots the population, 3) plots the transects, population and
detections 4) plots a histogram of the detection distances. Note that only
plots 3 &amp; 4 are generated without the survey region if Region is omitted.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'Survey,Region'
plot(x, y, type = "all", ...)

## S4 method for signature 'Survey,ANY'
plot(x, y = NULL, type = "all", ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot+2B2CSurvey+2B2CRegion-method_+3A_x">x</code></td>
<td>
<p>object of class Survey</p>
</td></tr>
<tr><td><code id="plot+2B2CSurvey+2B2CRegion-method_+3A_y">y</code></td>
<td>
<p>object of class Region or NULL</p>
</td></tr>
<tr><td><code id="plot+2B2CSurvey+2B2CRegion-method_+3A_type">type</code></td>
<td>
<p>character specifies which plots you would like, defaults to &quot;all&quot;.
Other options include &quot;transects&quot;, &quot;population&quot;, &quot;survey&quot; and &quot;distances&quot;. These
will plot only the transects, only the population locations, both the transects
and population with detections indicated or a histogram of the detection distances,
respectively. Note that the final plots is only available if there were
one or more detections. Only &quot;survey&quot; and &quot;distances&quot; available if the y
Region argument is not supplied.</p>
</td></tr>
<tr><td><code id="plot+2B2CSurvey+2B2CRegion-method_+3A_...">...</code></td>
<td>
<p>additional plotting parameters</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Generate 4 plots showing the survey population, transects (including covered areas), detections and a histogram of the detection distances. Plots include the survey region. Also invisibly returns a list of ggplot objects if the user would like to customise the plots.
</p>
<p>Generate 2 plots showing the survey population, transects (including covered areas), detections and a histogram of the detection distances. Plots do not include survey region. Also invisibly returns a list of ggplot objects if the user would like to customise the plots.
</p>

<hr>
<h2 id='Population-class'>Class &quot;Population&quot;</h2><span id='topic+Population-class'></span>

<h3>Description</h3>

<p>Contains an instance of a population including a description of their detectability
in the form of an object of class Detectability.
</p>


<h3>Slots</h3>


<dl>
<dt><code>region.name</code></dt><dd><p>Object of class <code>"character"</code>; the name of the region
object.</p>
</dd>
<dt><code>strata.names</code></dt><dd><p>Object of class <code>"character"</code>; the names of the
strata.</p>
</dd>
<dt><code>N</code></dt><dd><p>Object of class <code>"numeric"</code>; the number of individuals/clusters.</p>
</dd>
<dt><code>D</code></dt><dd><p>Object of class <code>"numeric"</code>; the density of individuals/clusters.</p>
</dd>
<dt><code>population</code></dt><dd><p>Object of class <code>"data.frame"</code>; the locations of
individuals/clusters and any population covariates.</p>
</dd>
<dt><code>detectability</code></dt><dd><p>Object of class <code>"Detectability"</code>; describes how
easily the individuals/clusters can be detected.</p>
</dd>
</dl>


<h3>Methods</h3>


<dl>
<dt><code>plot</code></dt><dd><p><code>signature=(object = "Line.Transect")</code>: plots the locations
of the individuals/clusters.</p>
</dd>
</dl>



<h3>See Also</h3>

<p><code><a href="#topic+make.population.description">make.population.description</a></code>, <code><a href="#topic+make.detectability">make.detectability</a></code>
</p>

<hr>
<h2 id='Population.Description-class'>Class &quot;Population.Description&quot;</h2><span id='topic+Population.Description-class'></span>

<h3>Description</h3>

<p>Class <code>"Population.Description"</code> is an S4 class containing a
description of the population. It provides methods to generate an
example population.
</p>


<h3>Slots</h3>


<dl>
<dt><code>N</code></dt><dd><p>Object of class <code>"numeric"</code>; number of individuals
in the population (optional).</p>
</dd>
<dt><code>density</code></dt><dd><p>Object of class <code>"Density"</code>; describes the
population density</p>
</dd>
<dt><code>region.name</code></dt><dd><p>Object of class <code>"character"</code>; name of
the region in which the population exists.</p>
</dd>
<dt><code>strata.names</code></dt><dd><p>Character vector giving the strata names for the study region.</p>
</dd>
<dt><code>covariates</code></dt><dd><p>Named list with one named entry per individual level covariate.
Cluster sizes can be defined here. Each list entry will either be a data.frame
containing 2 columns, the first the level (level) and the second the probability</p>
</dd>
<dt><code>size</code></dt><dd><p>logical value indicating whether the population occurs in
clusters.
(prob). The cluster size entry in the list must be named 'size'.</p>
</dd>
<dt><code>gen.by.N</code></dt><dd><p>Object of class <code>"logical"</code>; If <code>TRUE</code>
N is fixed otherwise it is generated from a Poisson distribution.</p>
</dd>
</dl>


<h3>Methods</h3>


<dl>
<dt><code>get.N</code></dt><dd><p><code>signature=(object = "Population.Description")</code>:
returns the value of <code>N</code></p>
</dd>
<dt><code>generate.population</code></dt><dd><p><code>signature=(object = "Population.Description")</code>: generates a single realisation of the population.</p>
</dd>
</dl>



<h3>See Also</h3>

<p><code><a href="#topic+make.population.description">make.population.description</a></code>
</p>

<hr>
<h2 id='run.simulation'>Method to run a simulation</h2><span id='topic+run.simulation'></span>

<h3>Description</h3>

<p>Runs the simulation and returns the simulation object with results. If
running in parallel and max.cores is not specified it will default to using
one less than the number of cores / threads on your machine. For example
code see <code><a href="#topic+make.simulation">make.simulation</a></code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>run.simulation(
  simulation,
  run.parallel = FALSE,
  max.cores = NA,
  counter = TRUE,
  transect.path = character(0),
  progress.file = character(0)
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="run.simulation_+3A_simulation">simulation</code></td>
<td>
<p><code><a href="#topic+Simulation-class">Simulation-class</a></code> object</p>
</td></tr>
<tr><td><code id="run.simulation_+3A_run.parallel">run.parallel</code></td>
<td>
<p>logical option to use multiple processors</p>
</td></tr>
<tr><td><code id="run.simulation_+3A_max.cores">max.cores</code></td>
<td>
<p>integer maximum number of cores to use, if not specified then
one less than the number available will be used.</p>
</td></tr>
<tr><td><code id="run.simulation_+3A_counter">counter</code></td>
<td>
<p>logical indicates if you would like to see the progress counter.</p>
</td></tr>
<tr><td><code id="run.simulation_+3A_transect.path">transect.path</code></td>
<td>
<p>character gives the pathway to a folder of shapefiles or
the path to a single shapefile (.shp file) which give the transects which should
be used for the simulations. If a folder of transects a new shapefile will be
used for each repetition. If a path specifying a single shapefile then the same
transects will be used for each repetition.</p>
</td></tr>
<tr><td><code id="run.simulation_+3A_progress.file">progress.file</code></td>
<td>
<p>character path with filename to output progress to file
for Distance for Windows progress counter. Not to be used when running directly
in R.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the <code><a href="#topic+Simulation-class">Simulation-class</a></code> object which now includes
the results
</p>


<h3>See Also</h3>

<p><code><a href="#topic+make.simulation">make.simulation</a></code>
</p>

<hr>
<h2 id='run.survey'>S4 generic method to simulate a survey</h2><span id='topic+run.survey'></span><span id='topic+run.survey+2CSimulation-method'></span><span id='topic+run.survey+2CSurvey.LT-method'></span><span id='topic+run.survey+2CSurvey.PT-method'></span>

<h3>Description</h3>

<p>Simulates the process by which individuals or clusters are detected. If
a simulation is passed in then it will generate a population, set of
transects and simulate the detection process. If a survey is passed in
it will simply simulate the detection process. See
<code><a href="#topic+make.simulation">make.simulation</a></code> for example usage.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>run.survey(object, ...)

## S4 method for signature 'Simulation'
run.survey(object, filename = character(0))

## S4 method for signature 'Survey.LT'
run.survey(object, region = NULL)

## S4 method for signature 'Survey.PT'
run.survey(object, region = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="run.survey_+3A_object">object</code></td>
<td>
<p>an object of class Simulation</p>
</td></tr>
<tr><td><code id="run.survey_+3A_...">...</code></td>
<td>
<p>allows extra arguments</p>
</td></tr>
<tr><td><code id="run.survey_+3A_filename">filename</code></td>
<td>
<p>optional argument specifying a path to a shapefile if
the transects are to be loaded from file.</p>
</td></tr>
<tr><td><code id="run.survey_+3A_region">region</code></td>
<td>
<p>an object of class Region.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object which inherits from a <code><a href="#topic+Survey-class">Survey-class</a></code> object.
This will be a <code><a href="#topic+Survey.LT-class">Survey.LT-class</a></code> object in the case of a
simulation with a line transect design and a <code><a href="#topic+Survey.PT-class">Survey.PT-class</a></code>
if the simulation has a point transect design.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+make.simulation">make.simulation</a></code>
</p>

<hr>
<h2 id='rztpois'>Randomly generates values from a zero-truncated Poisson distribution</h2><span id='topic+rztpois'></span>

<h3>Description</h3>

<p>Generates values from a zero-truncated Poisson distribution with mean
equal to that specified. It uses an optimisation routine to check which 
value of lambda will give values with the requested mean.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rztpois(n, mean = NA)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rztpois_+3A_n">n</code></td>
<td>
<p>number of values to randomly generate</p>
</td></tr>
<tr><td><code id="rztpois_+3A_mean">mean</code></td>
<td>
<p>mean of the generated values</p>
</td></tr>
</table>


<h3>Value</h3>

<p>returns a randomly generated value from a zero-truncated Poisson
distribution.
</p>


<h3>Note</h3>

<p>Internal function not intended to be called by user.
</p>


<h3>Author(s)</h3>

<p>Len Thomas
</p>

<hr>
<h2 id='save.sim.results'>save.sim.results</h2><span id='topic+save.sim.results'></span>

<h3>Description</h3>

<p>Saves the simulation results from each replicate to file. It will save up to 3 txt files, one for the abundance estimation for individuals, one for the abundance estimation of clusters (where applicable) and one for detectability estimates and model selection information.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>save.sim.results(simulation, filepath = character(0), sim.ID = numeric(0))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="save.sim.results_+3A_simulation">simulation</code></td>
<td>
<p>object of class <code>Simulation</code> which has been run.</p>
</td></tr>
<tr><td><code id="save.sim.results_+3A_filepath">filepath</code></td>
<td>
<p>optionally a path to the directory where you would like the files saved, otherwise it will save it to the working directory.</p>
</td></tr>
<tr><td><code id="save.sim.results_+3A_sim.id">sim.ID</code></td>
<td>
<p>optionally you can add a simulation ID to the filename</p>
</td></tr>
</table>


<h3>Value</h3>

<p>invisibly returns the original simulation object
</p>


<h3>Author(s)</h3>

<p>L. Marshall
</p>

<hr>
<h2 id='set.densities'>Method to set density values</h2><span id='topic+set.densities'></span>

<h3>Description</h3>

<p>This method sets the density values in a density object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>set.densities(density, densities)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="set.densities_+3A_density">density</code></td>
<td>
<p>object of class Density</p>
</td></tr>
<tr><td><code id="set.densities_+3A_densities">densities</code></td>
<td>
<p>a numeric vector of density values to update the
density grid with.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>returns the Density object with updated density values
</p>

<hr>
<h2 id='show+2CDensity.Summary-method'>show</h2><span id='topic+show+2CDensity.Summary-method'></span>

<h3>Description</h3>

<p>displays the density summary table
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'Density.Summary'
show(object)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="show+2B2CDensity.Summary-method_+3A_object">object</code></td>
<td>
<p>object of class Density.Summary</p>
</td></tr>
</table>


<h3>Value</h3>

<p>No return value, displays the density summary
</p>

<hr>
<h2 id='show+2CSimulation-method'>show</h2><span id='topic+show+2CSimulation-method'></span>

<h3>Description</h3>

<p>Not currently implemented
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'Simulation'
show(object)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="show+2B2CSimulation-method_+3A_object">object</code></td>
<td>
<p>object of class Simulation</p>
</td></tr>
</table>


<h3>Value</h3>

<p>No return value, displays a summary of the simulation
</p>

<hr>
<h2 id='show+2CSimulation.Summary-method'>show</h2><span id='topic+show+2CSimulation.Summary-method'></span>

<h3>Description</h3>

<p>Displays the simulation summary
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'Simulation.Summary'
show(object)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="show+2B2CSimulation.Summary-method_+3A_object">object</code></td>
<td>
<p>object of class Simulation.Summary</p>
</td></tr>
</table>


<h3>Value</h3>

<p>No return value, displays information in Simulation.Summary
object
</p>

<hr>
<h2 id='Simulation-class'>Class &quot;Simulation&quot;</h2><span id='topic+Simulation-class'></span>

<h3>Description</h3>

<p>Class <code>"Simulation"</code> is an S4 class containing descriptions of the
region, population, survey design and analyses the user wishes to investigate.
Once the simulation has been run the N.D.Estimates will contain multiple
estimates of abundance and density obtained by repeatedly generating
populations, simulating the survey and completing the analyses.
</p>


<h3>Slots</h3>


<dl>
<dt><code>reps</code></dt><dd><p>Object of class <code>"numeric"</code>; the number of
times the simulation should be repeated.</p>
</dd>
<dt><code>single.transect.set</code></dt><dd><p>Object of class <code>"logical"</code>; if
<code>TRUE</code> the same set of transects are used in each repetition.</p>
</dd>
<dt><code>design</code></dt><dd><p>Object of class <code>"Survey.Design"</code>; the
survey design.</p>
</dd>
<dt><code>population.description</code></dt><dd><p>Object of class <code>"Population.Description"</code>;
the population.description.</p>
</dd>
<dt><code>detectability</code></dt><dd><p>Object of class <code>"Detectability"</code>; a
description of the detectability of the population.</p>
</dd>
<dt><code>ds.analysis</code></dt><dd><p>Object of class <code>"DS.Analysis"</code></p>
</dd>
<dt><code>add.options</code></dt><dd><p>a list to expand simulation options in the future.</p>
</dd>
<dt><code>ddf.param.ests</code></dt><dd><p>Object of class <code>"array"</code>; stores the
parameters associated with the detection function.</p>
</dd>
<dt><code>results</code></dt><dd><p>A <code>"list"</code> with elements 'individuals' (and
optionally 'clusters' and 'expected.size') as well as 'Detection'.
</p>
<p>The 'individuals' and 'clusters' elements are a list of three
3-dimensional arrays. The first is a summary array containing
values for 'Area' (strata area), 'CoveredArea' (the area
covered in the strata by the survey), Effort' (the line length
or number of points surveyed), 'n' (the number of sightings),
'n.miss.dists' (the number of missing distances - only applicable
to mixed detector types and not yet implemented in dsims), 'k'
(the number of transects), 'ER' (encounter rate), 'se.ER'
(standard error of the encounter rate), 'cv.ER' (coefficient of
variation of the encounter rate). A value is provided for each
of these for each strata as well as the region as a whole and
for each simulation repetition as well as storing the mean and
standard deviation of these values across simulation repetitions.
</p>
<p>The second array 'N' is the abundance estimates table. It contains
values for the 'Estimate' (estimated abundance based on data from
iteration i), 'se' (standard error associated with the estimate),
'cv' (coefficient of variation of estimate), 'lcl' (lower 95%
confidence interval value), 'ucl' (upper 95% confidence interval
value), 'df' the degrees of freedom associated with the estimate.
A value is provided for each of these for each strata as well as
the region as a whole and for each simulation repetition as well
as storing the mean and standard deviation of these values across
simulation repetitions.
</p>
<p>The third array 'D' is the density estimates table. It contains
values for the 'Estimate' (estimated density based on data from
iteration i), 'se' (standard error associated with the estimate),
'cv' (coefficient of variation of estimate), 'lcl' (lower 95%
confidence interval value), 'ucl' (upper 95% confidence interval
value), 'df' the degrees of freedom associated with the estimate.
A value is provided for each of these for each strata as well as
the region as a whole and for each simulation repetition as well
as storing the mean and standard deviation of these values across
simulation repetitions.
</p>
<p>When animals occur in clusters the expected.size element of the
results list contains a 3-dimensional array. It gives values
for 'Expected.S' (expected cluster size), 'se.Expected.S'
(the standard error of the expected cluster size),
'cv.Expected.S' (the coefficient of variation for the expected
cluster size). Values are given for each analysis strata as
well as a value for the survey region as a whole and across
each simulation repetition as well as overall means and standard
deviations across repetitions.
</p>
<p>The Detection element of the results list is a 3-dimensional
array with values for 'True.Pa' (the proportion of animals in
the covered region which were detected), 'Pa' (the estimated
proportion of animals detected in the covered region), 'ESW'
(the estimated strip width), 'f(0)' (The estimated value of
the detection function pdf at distance 0), 'SelectedModel'
(the index of the model which had the best fit to the dataset
for the repetition), 'DeltaCriteria' (the difference in
information criteria between the best and second best fitting
models where two or more models were fitted and converged),
'SuccessfulModels' (the number of models which successfully
converged). Currently detection functions are pooled across
all strata so there is only one global value for each
simulated dataset as well as a mean value and standard
deviation where appropriate.</p>
</dd>
<dt><code>warnings</code></dt><dd><p>A <code>"list"</code> to store warnings and error messages encountered
during runtime.</p>
</dd>
</dl>


<h3>Methods</h3>


<dl>
<dt><code>summary</code></dt><dd><p><code>signature=(object = "Simulation")</code>: produces
a summary of the simulation and its results.</p>
</dd>
<dt><code>generate.population</code></dt><dd><p><code>signature = (object =
 "Simulation")</code>: generates a single instance of a population.</p>
</dd>
<dt><code>generate.transects</code></dt><dd><p><code>signature = (object =
 "Simulation")</code>: generates a single set of transects.</p>
</dd>
<dt><code>run.survey</code></dt><dd><p><code>signature = (object =
 "Simulation")</code>: carries out the simulation process as far as generating
the distance data and returns an object containing the population,
transects and data.</p>
</dd>
<dt><code>run.simulation</code></dt><dd><p><code>signature = (simulation = "Simulation")</code>: runs
the whole simulation for the specified number of repetitions.</p>
</dd>
</dl>



<h3>See Also</h3>

<p><code><a href="#topic+make.simulation">make.simulation</a></code>
</p>

<hr>
<h2 id='Simulation.Summary-class'>Class &quot;Simulation.Summary&quot;</h2><span id='topic+Simulation.Summary-class'></span>

<h3>Description</h3>

<p>Class <code>"Simulation.Summary"</code> is an S4 class containing a summary of
the simulation results. This is returned when <code>summary(Simulation)</code>
is called. If it is not assigned to a variable the object will be
displayed via the <code>show</code> method.
</p>


<h3>Methods</h3>


<dl>
<dt><code>show</code></dt><dd><p><code>signature=(object = "Simulation.Summary")</code>: prints
the contents of the object in a user friendly format.</p>
</dd>
</dl>


<hr>
<h2 id='summary+2CDensity-method'>summary</h2><span id='topic+summary+2CDensity-method'></span>

<h3>Description</h3>

<p>Provides a summary table of the density object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'Density'
summary(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary+2B2CDensity-method_+3A_object">object</code></td>
<td>
<p>object of class Simulation</p>
</td></tr>
<tr><td><code id="summary+2B2CDensity-method_+3A_...">...</code></td>
<td>
<p>not implemented</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a <code><a href="#topic+Density.Summary-class">Density.Summary-class</a></code> object
</p>

<hr>
<h2 id='summary+2CSimulation-method'>summary</h2><span id='topic+summary+2CSimulation-method'></span>

<h3>Description</h3>

<p>Provides a summary of the simulation results.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'Simulation'
summary(object, description.summary = TRUE, use.max.reps = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary+2B2CSimulation-method_+3A_object">object</code></td>
<td>
<p>object of class Simulation</p>
</td></tr>
<tr><td><code id="summary+2B2CSimulation-method_+3A_description.summary">description.summary</code></td>
<td>
<p>logical indicating whether an
explanation of the summary should be displayed</p>
</td></tr>
<tr><td><code id="summary+2B2CSimulation-method_+3A_use.max.reps">use.max.reps</code></td>
<td>
<p>by default this is FALSE meaning that only simulation repetitions where all models converged for that data set are included. By setting this to TRUE any repetition where one or more models converged will be included in the summary results.</p>
</td></tr>
<tr><td><code id="summary+2B2CSimulation-method_+3A_...">...</code></td>
<td>
<p>no additional arguments currently implemented</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Object of class Simulation.Summary
</p>

<hr>
<h2 id='Survey-class'>Virtual Class &quot;Survey&quot;</h2><span id='topic+Survey-class'></span>

<h3>Description</h3>

<p>Class <code>"Survey"</code> is an S4 class containing an instance of a population.
</p>


<h3>Slots</h3>


<dl>
<dt><code>population</code></dt><dd><p>Object of class <code>"Population"</code>; an instance of
a population.</p>
</dd>
</dl>

<hr>
<h2 id='Survey.LT-class'>Class &quot;Survey.LT&quot; extends class &quot;Survey&quot;</h2><span id='topic+Survey.LT-class'></span>

<h3>Description</h3>

<p>Class <code>"Survey.LT"</code> is an S4 class containing a population
and a set of transects.
</p>


<h3>Slots</h3>


<dl>
<dt><code>transect</code></dt><dd><p>Object of class <code>"Line.Transect"</code>; the
line transects.</p>
</dd>
<dt><code>perpendicular.truncation</code></dt><dd><p>Object of class <code>"numeric"</code>; the
maximum distance from the transect at which animals may be detected.</p>
</dd>
</dl>


<h3>See Also</h3>

<p><code>make.design</code>
</p>

<hr>
<h2 id='Survey.PT-class'>Class &quot;Survey.PT&quot; extends class &quot;Survey&quot;</h2><span id='topic+Survey.PT-class'></span>

<h3>Description</h3>

<p>Class <code>"Survey.PT"</code> is an S4 class containing a population
and a set of transects.
</p>


<h3>Slots</h3>


<dl>
<dt><code>transect</code></dt><dd><p>Object of class <code>"Point.Transect"</code>; the
point transects.</p>
</dd>
<dt><code>radial.truncation</code></dt><dd><p>Object of class <code>"numeric"</code>; the
maximum distance from the transect at which animals may be detected.</p>
</dd>
</dl>


<h3>See Also</h3>

<p><code>make.design</code>
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
