<!DOCTYPE html><html><head><title>Help for package updog</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {updog}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#updog-package'><p><code>updog</code> Flexible Genotyping for Polyploids</p></a></li>
<li><a href='#dbetabinom'><p>The Beta-Binomial Distribution</p></a></li>
<li><a href='#filter_snp'><p>Filter SNPs based on the output of <code>multidog()</code>.</p></a></li>
<li><a href='#flexdog'><p>Flexible genotyping for polyploids from next-generation sequencing data.</p></a></li>
<li><a href='#flexdog_full'><p>Flexible genotyping for polyploids from next-generation sequencing data.</p></a></li>
<li><a href='#format_multidog'><p>Return arrayicized elements from the output of <code>multidog</code>.</p></a></li>
<li><a href='#get_q_array'><p>Return the probabilities of an offspring's genotype given its</p>
parental genotypes for all possible combinations of parental and
offspring genotypes. This is for species with polysomal inheritance
and bivalent, non-preferential pairing.</a></li>
<li><a href='#is.flexdog'><p>Tests if an argument is a <code>flexdog</code> object.</p></a></li>
<li><a href='#is.multidog'><p>Tests if an argument is a <code>multidog</code> object.</p></a></li>
<li><a href='#log_sum_exp'><p>Log-sum-exponential trick.</p></a></li>
<li><a href='#log_sum_exp_2'><p>Log-sum-exponential trick using just two doubles.</p></a></li>
<li><a href='#multidog'><p>Fit <code>flexdog</code> to multiple SNPs.</p></a></li>
<li><a href='#oracle_cor'><p>Calculates the correlation between the true genotype and an</p>
oracle estimator.</a></li>
<li><a href='#oracle_cor_from_joint'><p>Calculate the correlation of the oracle estimator with the true</p>
genotype from the joint distribution matrix.</a></li>
<li><a href='#oracle_joint'><p>The joint probability of the genotype and the genotype estimate</p>
of an oracle estimator.</a></li>
<li><a href='#oracle_mis'><p>Calculate oracle misclassification error rate.</p></a></li>
<li><a href='#oracle_mis_from_joint'><p>Get the oracle misclassification error rate directly from the</p>
joint distribution of the genotype and the oracle estimator.</a></li>
<li><a href='#oracle_mis_vec'><p>Returns the oracle misclassification rates for each genotype.</p></a></li>
<li><a href='#oracle_mis_vec_from_joint'><p>Get the oracle misclassification error rates (conditional on</p>
true genotype) directly from the
joint distribution of the genotype and the oracle estimator.</a></li>
<li><a href='#oracle_plot'><p>Construct an oracle plot from the output of <code>oracle_joint</code>.</p></a></li>
<li><a href='#plot_geno'><p>Make a genotype plot.</p></a></li>
<li><a href='#plot.flexdog'><p>Draw a genotype plot from the output of <code>flexdog</code>.</p></a></li>
<li><a href='#plot.multidog'><p>Plot the output of <code>multidog</code>.</p></a></li>
<li><a href='#rflexdog'><p>Simulate GBS data from the <code>flexdog</code> likelihood.</p></a></li>
<li><a href='#rgeno'><p>Simulate individual genotypes from one of the supported <code>flexdog</code> models.</p></a></li>
<li><a href='#snpdat'><p>GBS data from Shirasawa et al (2017)</p></a></li>
<li><a href='#uitdewilligen'><p>Subset of individuals and SNPs from Uitdewilligen et al (2013).</p></a></li>
<li><a href='#wem'><p>EM algorithm to fit weighted ash objective.</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Title:</td>
<td>Flexible Genotyping for Polyploids</td>
</tr>
<tr>
<td>Version:</td>
<td>2.1.5</td>
</tr>
<tr>
<td>Description:</td>
<td>Implements empirical Bayes approaches to genotype
       polyploids from next generation sequencing data while
       accounting for allele bias, overdispersion, and sequencing
       error. The main functions are flexdog() and multidog(), 
       which allow the specification
       of many different genotype distributions. Also provided are functions to
       simulate genotypes, rgeno(), and read-counts, rflexdog(), as well as
       functions to calculate oracle genotyping error rates, oracle_mis(), and
       correlation with the true genotypes, oracle_cor(). These latter two
       functions are useful for read depth calculations. Run
       browseVignettes(package = "updog") in R for example usage. See
       Gerard et al. (2018) &lt;<a href="https://doi.org/10.1534%2Fgenetics.118.301468">doi:10.1534/genetics.118.301468</a>&gt; and
       Gerard and Ferrao (2020) &lt;<a href="https://doi.org/10.1093%2Fbioinformatics%2Fbtz852">doi:10.1093/bioinformatics/btz852</a>&gt; for details 
       on the implemented methods.</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.4.0)</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/dcgerard/updog/issues">https://github.com/dcgerard/updog/issues</a></td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/dcgerard/updog/">https://github.com/dcgerard/updog/</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>Rcpp, RcppArmadillo</td>
</tr>
<tr>
<td>Imports:</td>
<td>Rcpp (&ge; 0.12.16), RcppArmadillo, assertthat, ggplot2,
reshape2, foreach, future, doFuture, doRNG, methods, iterators</td>
</tr>
<tr>
<td>Suggests:</td>
<td>covr, testthat, SuppDists, knitr, rmarkdown,
VariantAnnotation, GenomicRanges, S4Vectors, IRanges</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-11-28 17:50:18 UTC; dgerard</td>
</tr>
<tr>
<td>Author:</td>
<td>David Gerard <a href="https://orcid.org/0000-0001-9450-5023"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cre]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>David Gerard &lt;gerard.1787@gmail.com&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-11-29 15:50:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='updog-package'><code>updog</code> Flexible Genotyping for Polyploids</h2><span id='topic+updog-package'></span><span id='topic+updog'></span>

<h3>Description</h3>

<p>Implements empirical Bayes approaches to genotype
polyploids from next generation sequencing data while
accounting for allele bias, overdispersion, and sequencing
error. The main functions are <code><a href="#topic+flexdog">flexdog</a>()</code>
and <code><a href="#topic+multidog">multidog</a>()</code>, which allow the specification
of many different genotype distributions. Also provided
are functions to simulate genotypes, <code><a href="#topic+rgeno">rgeno</a>()</code>,
and read-counts, <code><a href="#topic+rflexdog">rflexdog</a>()</code>, as well as
functions to calculate oracle genotyping error rates,
<code><a href="#topic+oracle_mis">oracle_mis</a>()</code>, and correlation with the true
genotypes, <code><a href="#topic+oracle_cor">oracle_cor</a>()</code>. These latter two
functions are useful for read depth calculations. Run
<code>browseVignettes(package = "updog")</code> in R for example usage. See
Gerard et al. (2018)
&lt;<a href="https://doi.org/10.1534/genetics.118.301468">doi:10.1534/genetics.118.301468</a>&gt;
and Gerard and Ferrao (2020)
&lt;<a href="https://doi.org/10.1093/bioinformatics/btz852">doi:10.1093/bioinformatics/btz852</a>&gt;
for details on the implemented methods.
</p>


<h3>Details</h3>

<p>The package is named <code>updog</code> for &quot;Using
Parental Data for Offspring Genotyping&quot; because
we originally developed the
method for full-sib populations, but it works
now for more general populations.
</p>
<p>Our best competitor is probably the <code>fitPoly</code> package,
which you can check out at
<a href="https://cran.r-project.org/package=fitPoly">https://cran.r-project.org/package=fitPoly</a>. Though, we think
that <code>updog</code> returns better calibrated measures of uncertainty
when you have next-generation sequencing data.
</p>
<p>If you find a bug or want an enhancement, please submit an
issue at <a href="https://github.com/dcgerard/updog/issues">https://github.com/dcgerard/updog/issues</a>.
</p>


<h3><code>updog</code> Functions</h3>


<dl>
<dt><code><a href="#topic+flexdog">flexdog</a>()</code></dt><dd><p>The main function that
fits an empirical Bayes approach to genotype polyploids
from next generation sequencing data.</p>
</dd>
<dt><code><a href="#topic+multidog">multidog</a>()</code></dt><dd><p>A convenience function for running
<code><a href="#topic+flexdog">flexdog</a>()</code> over many SNPs. This function provides
support for parallel computing.</p>
</dd>
<dt><code><a href="#topic+format_multidog">format_multidog</a>()</code></dt><dd><p>Return arrayicized elements from the output of <code><a href="#topic+multidog">multidog</a>()</code>.</p>
</dd>
<dt><code><a href="#topic+filter_snp">filter_snp</a>()</code></dt><dd><p>Filter SNPs based on the output of <code><a href="#topic+multidog">multidog</a>()</code></p>
</dd>
<dt><code><a href="#topic+rgeno">rgeno</a>()</code></dt><dd><p>simulate the genotypes of a sample
from one of the models allowed in <code><a href="#topic+flexdog">flexdog</a>()</code>.</p>
</dd>
<dt><code><a href="#topic+rflexdog">rflexdog</a>()</code></dt><dd><p>Simulate read-counts from the
<code><a href="#topic+flexdog">flexdog</a>()</code> model.</p>
</dd>
<dt><code><a href="#topic+plot.flexdog">plot.flexdog</a>()</code></dt><dd><p>Plotting the output of
<code><a href="#topic+flexdog">flexdog</a>()</code>.</p>
</dd>
<dt><code><a href="#topic+plot.multidog">plot.multidog</a>()</code></dt><dd><p>Plotting the output of
<code><a href="#topic+multidog">multidog</a>()</code>.</p>
</dd>
<dt><code><a href="#topic+oracle_joint">oracle_joint</a>()</code></dt><dd><p>The joint distribution of the true genotype
and an oracle estimator.</p>
</dd>
<dt><code><a href="#topic+oracle_plot">oracle_plot</a>()</code></dt><dd><p>Visualize the output of <code><a href="#topic+oracle_joint">oracle_joint</a>()</code>.</p>
</dd>
<dt><code><a href="#topic+oracle_mis">oracle_mis</a>()</code></dt><dd><p>The oracle misclassification error rate (Bayes rate).</p>
</dd>
<dt><code><a href="#topic+oracle_cor">oracle_cor</a>()</code></dt><dd><p>Correlation between the true genotype and the oracle estimated genotype.</p>
</dd>
</dl>



<h3><code>updog</code> Datasets</h3>


<dl>
<dt><code><a href="#topic+snpdat">snpdat</a></code></dt><dd><p>A small example dataset for using
<code><a href="#topic+flexdog">flexdog</a></code>.</p>
</dd>
<dt><code><a href="#topic+uitdewilligen">uitdewilligen</a></code></dt><dd><p>A small example dataset</p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>David Gerard
</p>


<h3>References</h3>


<ul>
<li><p>Gerard, D., Ferrão, L. F. V., Garcia, A. A. F., &amp; Stephens, M. (2018). Genotyping Polyploids from Messy Sequencing Data. <em>Genetics</em>, 210(3), 789-807. <a href="https://doi.org/10.1534/genetics.118.301468">doi:10.1534/genetics.118.301468</a>.
</p>
</li>
<li><p>Gerard, David, and Luís Felipe Ventorim Ferrão. &quot;Priors for genotyping polyploids.&quot; Bioinformatics 36, no. 6 (2020): 1795-1800. <a href="https://doi.org/10.1093/bioinformatics/btz852">doi:10.1093/bioinformatics/btz852</a>.
</p>
</li></ul>


<hr>
<h2 id='dbetabinom'>The Beta-Binomial Distribution</h2><span id='topic+dbetabinom'></span><span id='topic+pbetabinom'></span><span id='topic+qbetabinom'></span><span id='topic+rbetabinom'></span><span id='topic+betabinom'></span>

<h3>Description</h3>

<p>Density, distribution function, quantile function and random generation
for the beta-binomial distribution when parameterized
by the mean <code>mu</code> and the overdispersion parameter <code>rho</code>
rather than the typical shape parameters.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dbetabinom(x, size, mu, rho, log)

pbetabinom(q, size, mu, rho, log_p)

qbetabinom(p, size, mu, rho)

rbetabinom(n, size, mu, rho)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dbetabinom_+3A_x">x</code>, <code id="dbetabinom_+3A_q">q</code></td>
<td>
<p>A vector of quantiles.</p>
</td></tr>
<tr><td><code id="dbetabinom_+3A_size">size</code></td>
<td>
<p>A vector of sizes.</p>
</td></tr>
<tr><td><code id="dbetabinom_+3A_mu">mu</code></td>
<td>
<p>Either a scalar of the mean for each observation,
or a vector of means of each observation, and thus
the same length as <code>x</code> and <code>size</code>. This must
be between 0 and 1.</p>
</td></tr>
<tr><td><code id="dbetabinom_+3A_rho">rho</code></td>
<td>
<p>Either a scalar of the overdispersion parameter
for each observation, or a vector of overdispersion
parameters of each observation, and thus the same length as
<code>x</code> and <code>size</code>. This must be between 0 and 1.</p>
</td></tr>
<tr><td><code id="dbetabinom_+3A_log">log</code>, <code id="dbetabinom_+3A_log_p">log_p</code></td>
<td>
<p>A logical vector either of length 1 or the same
length as <code>x</code> and <code>size</code>. This determines whether
to return the log probabilities for all observations
(in the case that its length is 1) or for
each observation (in the case that
its length is that of <code>x</code> and <code>size</code>).</p>
</td></tr>
<tr><td><code id="dbetabinom_+3A_p">p</code></td>
<td>
<p>A vector of probabilities.</p>
</td></tr>
<tr><td><code id="dbetabinom_+3A_n">n</code></td>
<td>
<p>The number of observations.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Let <code class="reqn">\mu</code> and <code class="reqn">\rho</code> be the mean and overdispersion parameters.
Let <code class="reqn">\alpha</code> and <code class="reqn">\beta</code> be the usual shape parameters of
a beta distribution. Then we have the relation
</p>
<p style="text-align: center;"><code class="reqn">\mu = \alpha/(\alpha + \beta),</code>
</p>

<p>and
</p>
<p style="text-align: center;"><code class="reqn">\rho = 1/(1 + \alpha + \beta).</code>
</p>

<p>This necessarily means that
</p>
<p style="text-align: center;"><code class="reqn">\alpha = \mu (1 - \rho)/\rho,</code>
</p>

<p>and
</p>
<p style="text-align: center;"><code class="reqn">\beta = (1 - \mu) (1 - \rho)/\rho.</code>
</p>



<h3>Value</h3>

<p>Either a random sample (<code>rbetabinom</code>),
the density (<code>dbetabinom</code>), the tail
probability (<code>pbetabinom</code>), or the quantile
(<code>qbetabinom</code>) of the beta-binomial distribution.
</p>


<h3>Functions</h3>


<ul>
<li> <p><code>dbetabinom()</code>: Density function.
</p>
</li>
<li> <p><code>pbetabinom()</code>: Distribution function.
</p>
</li>
<li> <p><code>qbetabinom()</code>: Quantile function.
</p>
</li>
<li> <p><code>rbetabinom()</code>: Random generation.
</p>
</li></ul>


<h3>Author(s)</h3>

<p>David Gerard
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- rbetabinom(n = 10, size = 10, mu = 0.1, rho = 0.01)
dbetabinom(x = 1, size = 10, mu = 0.1, rho = 0.01, log = FALSE)
pbetabinom(q = 1, size = 10, mu = 0.1, rho = 0.01, log_p = FALSE)
qbetabinom(p = 0.6, size = 10, mu = 0.1, rho = 0.01)


</code></pre>

<hr>
<h2 id='filter_snp'>Filter SNPs based on the output of <code><a href="#topic+multidog">multidog</a>()</code>.</h2><span id='topic+filter_snp'></span>

<h3>Description</h3>

<p>Filter based on provided logical predicates in terms of the variable
names in <code>x$snpdf</code>. This function filters both <code>x$snpdf</code>
and <code>x$inddf</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>filter_snp(x, expr)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="filter_snp_+3A_x">x</code></td>
<td>
<p>The output of <code>multidog</code>.</p>
</td></tr>
<tr><td><code id="filter_snp_+3A_expr">expr</code></td>
<td>
<p>Logical predicate expression defined in terms of the variables
in <code>x$snpdf</code>. Only SNPs where the condition evaluates to
<code>TRUE</code> are kept.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>David Gerard
</p>


<h3>See Also</h3>


<dl>
<dt><code><a href="#topic+multidog">multidog</a>()</code>:</dt><dd><p>For the variables in <code>x$snpdf</code>
which you can filter by.</p>
</dd>
</dl>



<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
data("uitdewilligen")
mout &lt;- multidog(refmat = t(uitdewilligen$refmat),
                 sizemat = t(uitdewilligen$sizemat),
                 ploidy = uitdewilligen$ploidy,
                 nc = 2)

## The following filters are for educational purposes only and should
## not be taken as a default filter:
mout2 &lt;- filter_snp(mout, bias &lt; 0.8 &amp; od &lt; 0.003)

## End(Not run)

</code></pre>

<hr>
<h2 id='flexdog'>Flexible genotyping for polyploids from next-generation sequencing data.</h2><span id='topic+flexdog'></span>

<h3>Description</h3>

<p>Genotype polyploid individuals from next generation
sequencing (NGS) data while assuming the genotype distribution is one of
several forms. <code>flexdog</code> does this while accounting for allele bias,
overdispersion, sequencing error. The method is described
in detail in Gerard et. al. (2018) and Gerard and Ferrão (2020). See
<code><a href="#topic+multidog">multidog</a>()</code> for running flexdog on multiple SNPs in parallel.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>flexdog(
  refvec,
  sizevec,
  ploidy,
  model = c("norm", "hw", "bb", "s1", "s1pp", "f1", "f1pp", "flex", "uniform", "custom"),
  p1ref = NULL,
  p1size = NULL,
  p2ref = NULL,
  p2size = NULL,
  snpname = NULL,
  bias_init = exp(c(-1, -0.5, 0, 0.5, 1)),
  verbose = TRUE,
  prior_vec = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="flexdog_+3A_refvec">refvec</code></td>
<td>
<p>A vector of counts of reads of the reference allele.</p>
</td></tr>
<tr><td><code id="flexdog_+3A_sizevec">sizevec</code></td>
<td>
<p>A vector of total counts.</p>
</td></tr>
<tr><td><code id="flexdog_+3A_ploidy">ploidy</code></td>
<td>
<p>The ploidy of the species. Assumed to be the same for each
individual.</p>
</td></tr>
<tr><td><code id="flexdog_+3A_model">model</code></td>
<td>
<p>What form should the prior (genotype distribution) take?
See Details for possible values.</p>
</td></tr>
<tr><td><code id="flexdog_+3A_p1ref">p1ref</code></td>
<td>
<p>The reference counts for the first parent if
<code>model = "f1"</code> or <code>model = "f1pp"</code>, or for
the only parent if <code>model = "s1"</code> or <code>model = "s1pp"</code>.</p>
</td></tr>
<tr><td><code id="flexdog_+3A_p1size">p1size</code></td>
<td>
<p>The total counts for the first parent if
<code>model = "f1"</code> or <code>model = "f1pp"</code>,
or for the only parent if <code>model = "s1"</code> or <code>model = "s1pp"</code>.</p>
</td></tr>
<tr><td><code id="flexdog_+3A_p2ref">p2ref</code></td>
<td>
<p>The reference counts for the second parent if
<code>model = "f1"</code> or <code>model = "f1pp"</code>.</p>
</td></tr>
<tr><td><code id="flexdog_+3A_p2size">p2size</code></td>
<td>
<p>The total counts for the second parent if
<code>model = "f1"</code> or <code>model = "f1pp"</code>.</p>
</td></tr>
<tr><td><code id="flexdog_+3A_snpname">snpname</code></td>
<td>
<p>A string. The name of the SNP under consideration.
This is just returned in the <code>input</code> list for your reference.</p>
</td></tr>
<tr><td><code id="flexdog_+3A_bias_init">bias_init</code></td>
<td>
<p>A vector of initial values for the bias parameter
over the multiple runs of <code><a href="#topic+flexdog_full">flexdog_full</a>()</code>.</p>
</td></tr>
<tr><td><code id="flexdog_+3A_verbose">verbose</code></td>
<td>
<p>Should we output more (<code>TRUE</code>) or less
(<code>FALSE</code>)?</p>
</td></tr>
<tr><td><code id="flexdog_+3A_prior_vec">prior_vec</code></td>
<td>
<p>The pre-specified genotype distribution. Only used if
<code>model = "custom"</code> and must otherwise be <code>NULL</code>. If specified,
then it should be a vector of length <code>ploidy + 1</code> with
non-negative elements that sum to 1.</p>
</td></tr>
<tr><td><code id="flexdog_+3A_...">...</code></td>
<td>
<p>Additional parameters to pass to <code><a href="#topic+flexdog_full">flexdog_full</a>()</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Possible values of the genotype distribution (values of <code>model</code>) are:
</p>

<dl>
<dt><code>"norm"</code></dt><dd><p>A distribution whose genotype frequencies are proportional
to the density value of a normal with some mean and some standard deviation.
Unlike the <code>"bb"</code> and <code>"hw"</code> options, this will allow for
distributions both more and less dispersed than a binomial.
This seems to be the most robust to violations in modeling assumptions, and so is the
default. This prior class was developed in Gerard and Ferrão (2020).</p>
</dd>
<dt><code>"hw"</code></dt><dd><p>A binomial distribution that results from assuming that
the population is in Hardy-Weinberg equilibrium (HWE). This actually does
pretty well even when there are minor to moderate deviations from HWE.
Though it does not perform as well as the '&quot;norm&quot;' option when there
are severe deviations from HWE.</p>
</dd>
<dt><code>"bb"</code></dt><dd><p>A beta-binomial distribution. This is an overdispersed
version of <code>"hw"</code> and can be derived from a special case of the Balding-Nichols model.</p>
</dd>
<dt><code>"s1"</code></dt><dd><p>This prior assumes the individuals are
all full-siblings resulting
from one generation of selfing. I.e. there is only
one parent. This model assumes
a particular type of meiotic behavior: polysomic
inheritance with
bivalent, non-preferential pairing.</p>
</dd>
<dt><code>"f1"</code></dt><dd><p>This prior assumes the individuals are all
full-siblings resulting
from one generation of a bi-parental cross.
This model assumes
a particular type of meiotic behavior: polysomic
inheritance with
bivalent, non-preferential pairing.</p>
</dd>
<dt><code>"f1pp"</code></dt><dd><p>This prior allows for double reduction
and preferential pairing in an F1 population of tretraploids.</p>
</dd>
<dt><code>"s1pp"</code></dt><dd><p>This prior allows for double reduction
and preferential pairing in an S1 population of tretraploids.</p>
</dd>
<dt><code>"flex"</code></dt><dd><p>Generically any categorical distribution. Theoretically,
this works well if you have a lot of individuals. In practice, it seems to
be much less robust to violations in modeling assumptions.</p>
</dd>
<dt><code>"uniform"</code></dt><dd><p>A discrete uniform distribution. This should never
be used in practice.</p>
</dd>
<dt><code>"custom"</code></dt><dd><p>A pre-specified prior distribution. You specify
it using the <code>prior_vec</code> argument. You should almost never
use this option in practice.</p>
</dd>
</dl>

<p>You might think a good default is <code>model = "uniform"</code> because it is
somehow an &quot;uninformative prior.&quot; But it is very informative and tends to
work horribly in practice. The intuition is that it will estimate
the allele bias and sequencing error rates so that the estimated genotypes
are approximately uniform (since we are assuming that they are approximately
uniform). This will usually result in unintuitive genotyping since most
populations don't have a uniform genotype distribution.
I include it as an option only for completeness. Please don't use it.
</p>
<p>The value of <code>prop_mis</code> is a very intuitive measure for
the quality of the SNP. <code>prop_mis</code> is the posterior
proportion of individuals mis-genotyped. So if you want only SNPS
that accurately genotype, say, 95% of the individuals, you could
discard all SNPs with a <code>prop_mis</code> over <code>0.05</code>.
</p>
<p>The value of <code>maxpostprob</code> is a very intuitive measure
for the quality of the genotype estimate of an individual.
This is the posterior probability of correctly genotyping
the individual when using <code>geno</code> (the posterior mode)
as the genotype estimate. So if you want to correctly genotype,
say, 95% of individuals, you could discard all individuals
with a <code>maxpostprob</code> of under <code>0.95</code>. However, if you are
just going to impute missing genotypes later, you might consider
not discarding any individuals as <code>flexdog</code>'s genotype estimates will
probably be more accurate than other more naive approaches, such
as imputing using the grand mean.
</p>
<p>In most datasets I've examined, allelic bias is a major issue. However,
you may fit the model assuming no allelic bias by setting
<code>update_bias = FALSE</code> and <code>bias_init = 1</code>.
</p>
<p>Prior to using <code>flexdog</code>, during the read-mapping step,
you could try to get rid of allelic bias by
using WASP (<a href="https://doi.org/10.1101/011221">doi:10.1101/011221</a>). If you are successful
in removing the allelic bias (because its only source was the read-mapping
step), then setting <code>update_bias = FALSE</code> and <code>bias_init = 1</code>
would be reasonable. You can visually inspect SNPs for bias by
using <code><a href="#topic+plot_geno">plot_geno</a>()</code>.
</p>
<p><code>flexdog()</code>, like most methods, is invariant to which allele you
label as the &quot;reference&quot; and which you label as the &quot;alternative&quot;.
That is, if you set <code>refvec</code> with the number of alternative
read-counts, then the resulting genotype estimates
will be the estimated allele dosage of the alternative allele.
</p>


<h3>Value</h3>

<p>An object of class <code>flexdog</code>, which consists
of a list with some or all of the following elements:
</p>

<dl>
<dt><code>bias</code></dt><dd><p>The estimated bias parameter.</p>
</dd>
<dt><code>seq</code></dt><dd><p>The estimated sequencing error rate.</p>
</dd>
<dt><code>od</code></dt><dd><p>The estimated overdispersion parameter.</p>
</dd>
<dt><code>num_iter</code></dt><dd><p>The number of EM iterations ran. You should
be wary if this equals <code>itermax</code>.</p>
</dd>
<dt><code>llike</code></dt><dd><p>The maximum marginal log-likelihood.</p>
</dd>
<dt><code>postmat</code></dt><dd><p>A matrix of posterior probabilities of each
genotype for each individual. The rows index the individuals
and the columns index the allele dosage.</p>
</dd>
<dt><code>genologlike</code></dt><dd><p>A matrix of genotype <em>log</em>-likelihoods of each
genotype for each individual. The rows index the individuals
and the columns index the allele dosage.</p>
</dd>
<dt><code>gene_dist</code></dt><dd><p>The estimated genotype distribution. The
<code>i</code>th element is the proportion of individuals with
genotype <code>i-1</code>.</p>
</dd>
<dt><code>par</code></dt><dd><p>A list of the final estimates of the parameters
of the genotype distribution. The elements included in <code>par</code>
depends on the value of <code>model</code>:
</p>

<dl>
<dt><code>model = "norm"</code>:</dt><dd>

<dl>
<dt><code>mu</code>:</dt><dd><p>The normal mean.</p>
</dd>
<dt><code>sigma</code>:</dt><dd><p>The normal standard deviation (not variance).</p>
</dd>
</dl>

</dd>
<dt><code>model = "hw"</code>:</dt><dd>

<dl>
<dt><code>alpha</code>:</dt><dd><p>The major allele frequency.</p>
</dd>
</dl>

</dd>
<dt><code>model = "bb"</code>:</dt><dd>

<dl>
<dt><code>alpha</code>:</dt><dd><p>The major allele frequency.</p>
</dd>
<dt><code>tau</code>:</dt><dd><p>The overdispersion parameter. See the
description of <code>rho</code> in the Details of
<code><a href="#topic+betabinom">betabinom</a>()</code>.</p>
</dd>
</dl>

</dd>
<dt><code>model = "s1"</code>:</dt><dd>

<dl>
<dt><code>pgeno</code>:</dt><dd><p>The allele dosage of the parent.</p>
</dd>
<dt><code>alpha</code>:</dt><dd><p>The mixture proportion of the discrete
uniform (included and fixed at a small value mostly for
numerical stability reasons). See the description
of <code>fs1_alpha</code> in <code><a href="#topic+flexdog_full">flexdog_full</a>()</code>.</p>
</dd>
</dl>

</dd>
<dt><code>model = "f1"</code>:</dt><dd>

<dl>
<dt><code>p1geno</code>:</dt><dd><p>The allele dosage of the first parent.</p>
</dd>
<dt><code>p2geno</code>:</dt><dd><p>The allele dosage of the second parent.</p>
</dd>
<dt><code>alpha</code>:</dt><dd><p>The mixture proportion of the discrete
uniform (included and fixed at a small value mostly for
numerical stability reasons). See the description
of <code>fs1_alpha</code> in <code><a href="#topic+flexdog_full">flexdog_full</a>()</code>.</p>
</dd>
</dl>

</dd>
<dt><code>model = "s1pp"</code>:</dt><dd>

<dl>
<dt><code>ell1</code>:</dt><dd><p>The estimated dosage of the parent.</p>
</dd>
<dt><code>tau1</code>:</dt><dd><p>The estimated double reduction parameter
of the parent. Available if <code>ell1</code> is <code>1</code>, <code>2</code>,
or <code>3</code>. Identified if <code>ell1</code> is <code>1</code> or <code>3</code>.</p>
</dd>
<dt><code>gamma1</code>:</dt><dd><p>The estimated preferential pairing parameter.
Available if <code>ell1</code> is <code>2</code>. However, it is not
returned in an identified form.</p>
</dd>
<dt><code>alpha</code>:</dt><dd><p>The mixture proportion of the discrete
uniform (included and fixed at a small value mostly for
numerical stability reasons). See the description
of <code>fs1_alpha</code> in <code><a href="#topic+flexdog_full">flexdog_full</a>()</code>.</p>
</dd>
</dl>

</dd>
<dt><code>model = "f1pp"</code>:</dt><dd>

<dl>
<dt><code>ell1</code>:</dt><dd><p>The estimated dosage of parent 1.</p>
</dd>
<dt><code>ell2</code>:</dt><dd><p>The estimated dosage of parent 2.</p>
</dd>
<dt><code>tau1</code>:</dt><dd><p>The estimated double reduction parameter
of parent 1. Available if <code>ell1</code> is <code>1</code>, <code>2</code>,
or <code>3</code>. Identified if <code>ell1</code> is <code>1</code> or <code>3</code>.</p>
</dd>
<dt><code>tau2</code>:</dt><dd><p>The estimated double reduction parameter
of parent 2. Available if <code>ell2</code> is <code>1</code>, <code>2</code>,
or <code>3</code>. Identified if <code>ell2</code> is <code>1</code> or <code>3</code>.</p>
</dd>
<dt><code>gamma1</code>:</dt><dd><p>The estimated preferential pairing parameter
of parent 1. Available if <code>ell1</code> is <code>2</code>. However,
it is not returned in an identified form.</p>
</dd>
<dt><code>gamma2</code>:</dt><dd><p>The estimated preferential pairing parameter
of parent 2. Available if <code>ell2</code> is <code>2</code>. However,
it is not returned in an identified form.</p>
</dd>
<dt><code>alpha</code>:</dt><dd><p>The mixture proportion of the discrete
uniform (included and fixed at a small value mostly for
numerical stability reasons). See the description
of <code>fs1_alpha</code> in <code><a href="#topic+flexdog_full">flexdog_full</a>()</code>.</p>
</dd>
</dl>

</dd>
<dt><code>model = "flex"</code>:</dt><dd><p><code>par</code> is an empty list.</p>
</dd>
<dt><code>model = "uniform"</code>:</dt><dd><p><code>par</code> is an empty list.</p>
</dd>
<dt><code>model = "custom"</code>:</dt><dd><p><code>par</code> is an empty list.</p>
</dd>
</dl>
</dd>
<dt><code>geno</code></dt><dd><p>The posterior mode genotype. These are your
genotype estimates.</p>
</dd>
<dt><code>maxpostprob</code></dt><dd><p>The maximum posterior probability. This
is equivalent to the posterior probability of correctly
genotyping each individual.</p>
</dd>
<dt><code>postmean</code></dt><dd><p>The posterior mean genotype. In downstream
association studies, you might want to consider using these
estimates.</p>
</dd>
<dt><code>input$refvec</code></dt><dd><p>The value of <code>refvec</code> provided by
the user.</p>
</dd>
<dt><code>input$sizevec</code></dt><dd><p>The value of <code>sizevec</code> provided
by the user.</p>
</dd>
<dt><code>input$ploidy</code></dt><dd><p>The value of <code>ploidy</code> provided
by the user.</p>
</dd>
<dt><code>input$model</code></dt><dd><p>The value of <code>model</code> provided by
the user.</p>
</dd>
<dt><code>input$p1ref</code></dt><dd><p>The value of <code>p1ref</code> provided by the user.</p>
</dd>
<dt><code>input$p1size</code></dt><dd><p>The value of <code>p1size</code> provided by the user.</p>
</dd>
<dt><code>input$p2ref</code></dt><dd><p>The value of <code>p2ref</code> provided by the user.</p>
</dd>
<dt><code>input$p2size</code></dt><dd><p>The value of <code>p2size</code> provided by the user.</p>
</dd>
<dt><code>input$snpname</code></dt><dd><p>The value of <code>snpname</code> provided by the user.</p>
</dd>
<dt><code>prop_mis</code></dt><dd><p>The posterior proportion of individuals
genotyped incorrectly.</p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>David Gerard
</p>


<h3>References</h3>


<ul>
<li><p>Gerard, D., Ferrão, L. F. V., Garcia, A. A. F., &amp; Stephens, M. (2018). Genotyping Polyploids from Messy Sequencing Data. <em>Genetics</em>, 210(3), 789-807. <a href="https://doi.org/10.1534/genetics.118.301468">doi:10.1534/genetics.118.301468</a>.
</p>
</li>
<li><p>Gerard, David, and Luís Felipe Ventorim Ferrão. &quot;Priors for genotyping polyploids.&quot; Bioinformatics 36, no. 6 (2020): 1795-1800. <a href="https://doi.org/10.1093/bioinformatics/btz852">doi:10.1093/bioinformatics/btz852</a>.
</p>
</li></ul>



<h3>See Also</h3>

<p>Run <code>browseVignettes(package = "updog")</code> in R for example usage.
Other useful functions include:
</p>

<dl>
<dt><code><a href="#topic+multidog">multidog</a>()</code></dt><dd><p>For running <code>flexdog()</code> on multiple
SNPs in parallel.</p>
</dd>
<dt><code><a href="#topic+flexdog_full">flexdog_full</a>()</code></dt><dd><p>For additional parameter options
when running <code>flexdog()</code>.</p>
</dd>
<dt><code><a href="#topic+rgeno">rgeno</a>()</code></dt><dd><p>For simulating genotypes under the allowable
prior models in <code>flexdog()</code>.</p>
</dd>
<dt><code><a href="#topic+rflexdog">rflexdog</a>()</code></dt><dd><p>For simulating read-counts under the
assumed likelihood model in <code>flexdog()</code>.</p>
</dd>
<dt><code><a href="#topic+plot.flexdog">plot.flexdog</a>()</code></dt><dd><p>For plotting the output of
<code>flexdog()</code>.</p>
</dd>
<dt><code><a href="#topic+oracle_mis">oracle_mis</a>()</code></dt><dd><p>For calculating the oracle genotyping
error rates. This is useful for read-depth calculations
<em>before</em> collecting data. After you have data, using
the value of <code>prop_mis</code> is better.</p>
</dd>
<dt><code><a href="#topic+oracle_cor">oracle_cor</a>()</code></dt><dd><p>For calculating the correlation
between the true genotypes and an oracle estimator
(useful for read-depth calculations <em>before</em>
collecting data).</p>
</dd>
</dl>



<h3>Examples</h3>

<pre><code class='language-R'>

## An S1 population where the first individual
## is the parent.
data("snpdat")
ploidy  &lt;- 6
refvec  &lt;- snpdat$counts[snpdat$snp == "SNP2"]
sizevec &lt;- snpdat$size[snpdat$snp == "SNP2"]
fout    &lt;- flexdog(refvec   = refvec[-1],
                   sizevec  = sizevec[-1],
                   ploidy   = ploidy,
                   model    = "s1",
                   p1ref    = refvec[1],
                   p1size   = sizevec[1])
plot(fout)



## A natural population. We will assume a
## normal prior since there are so few
## individuals.
data("uitdewilligen")
ploidy  &lt;- 4
refvec  &lt;- uitdewilligen$refmat[, 1]
sizevec &lt;- uitdewilligen$sizemat[, 1]
fout    &lt;- flexdog(refvec  = refvec,
                   sizevec = sizevec,
                   ploidy  = ploidy,
                   model   = "norm")
plot(fout)



</code></pre>

<hr>
<h2 id='flexdog_full'>Flexible genotyping for polyploids from next-generation sequencing data.</h2><span id='topic+flexdog_full'></span>

<h3>Description</h3>

<p>Genotype polyploid individuals from next generation
sequencing (NGS) data while assuming the genotype distribution is one of
several forms. <code><a href="#topic+flexdog_full">flexdog_full</a>()</code> does this while accounting for allele bias,
overdispersion, and sequencing error. This function has more
options than <code><a href="#topic+flexdog">flexdog</a></code> and is only meant for expert users.
The method is described in detail in Gerard et. al. (2018) and
Gerard and Ferrão (2020).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>flexdog_full(
  refvec,
  sizevec,
  ploidy,
  model = c("norm", "hw", "bb", "s1", "s1pp", "f1", "f1pp", "flex", "uniform", "custom"),
  verbose = TRUE,
  mean_bias = 0,
  var_bias = 0.7^2,
  mean_seq = -4.7,
  var_seq = 1,
  mean_od = -5.5,
  var_od = 0.5^2,
  seq = 0.005,
  bias = 1,
  od = 0.001,
  update_bias = TRUE,
  update_seq = TRUE,
  update_od = TRUE,
  itermax = 200,
  tol = 10^-4,
  fs1_alpha = 10^-3,
  p1ref = NULL,
  p1size = NULL,
  p2ref = NULL,
  p2size = NULL,
  snpname = NULL,
  prior_vec = NULL,
  seq_upper = 0.05
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="flexdog_full_+3A_refvec">refvec</code></td>
<td>
<p>A vector of counts of reads of the reference allele.</p>
</td></tr>
<tr><td><code id="flexdog_full_+3A_sizevec">sizevec</code></td>
<td>
<p>A vector of total counts.</p>
</td></tr>
<tr><td><code id="flexdog_full_+3A_ploidy">ploidy</code></td>
<td>
<p>The ploidy of the species. Assumed to be the same for each
individual.</p>
</td></tr>
<tr><td><code id="flexdog_full_+3A_model">model</code></td>
<td>
<p>What form should the prior (genotype distribution) take?
See Details for possible values.</p>
</td></tr>
<tr><td><code id="flexdog_full_+3A_verbose">verbose</code></td>
<td>
<p>Should we output more (<code>TRUE</code>) or less
(<code>FALSE</code>)?</p>
</td></tr>
<tr><td><code id="flexdog_full_+3A_mean_bias">mean_bias</code></td>
<td>
<p>The prior mean of the log-bias.</p>
</td></tr>
<tr><td><code id="flexdog_full_+3A_var_bias">var_bias</code></td>
<td>
<p>The prior variance of the log-bias.</p>
</td></tr>
<tr><td><code id="flexdog_full_+3A_mean_seq">mean_seq</code></td>
<td>
<p>The prior mean of the logit of the sequencing
error rate.</p>
</td></tr>
<tr><td><code id="flexdog_full_+3A_var_seq">var_seq</code></td>
<td>
<p>The prior variance of the logit of the sequencing
error rate.</p>
</td></tr>
<tr><td><code id="flexdog_full_+3A_mean_od">mean_od</code></td>
<td>
<p>The prior mean of the logit of the overdispersion parameter.</p>
</td></tr>
<tr><td><code id="flexdog_full_+3A_var_od">var_od</code></td>
<td>
<p>The prior variance of the logit of the overdispersion
parameter.</p>
</td></tr>
<tr><td><code id="flexdog_full_+3A_seq">seq</code></td>
<td>
<p>The starting value of the sequencing error rate.</p>
</td></tr>
<tr><td><code id="flexdog_full_+3A_bias">bias</code></td>
<td>
<p>The starting value of the bias.</p>
</td></tr>
<tr><td><code id="flexdog_full_+3A_od">od</code></td>
<td>
<p>The starting value of the overdispersion parameter.</p>
</td></tr>
<tr><td><code id="flexdog_full_+3A_update_bias">update_bias</code></td>
<td>
<p>A logical. Should we update <code>bias</code>
(<code>TRUE</code>), or not (<code>FALSE</code>)?</p>
</td></tr>
<tr><td><code id="flexdog_full_+3A_update_seq">update_seq</code></td>
<td>
<p>A logical. Should we update <code>seq</code>
(<code>TRUE</code>), or not (<code>FALSE</code>)?</p>
</td></tr>
<tr><td><code id="flexdog_full_+3A_update_od">update_od</code></td>
<td>
<p>A logical. Should we update <code>od</code>
(<code>TRUE</code>), or not (<code>FALSE</code>)?</p>
</td></tr>
<tr><td><code id="flexdog_full_+3A_itermax">itermax</code></td>
<td>
<p>The total number of EM iterations to
run.</p>
</td></tr>
<tr><td><code id="flexdog_full_+3A_tol">tol</code></td>
<td>
<p>The tolerance stopping criterion. The EM algorithm will stop
if the difference in the log-likelihoods between two consecutive
iterations is less than <code>tol</code>.</p>
</td></tr>
<tr><td><code id="flexdog_full_+3A_fs1_alpha">fs1_alpha</code></td>
<td>
<p>The value at which to fix
the mixing proportion for the uniform component
when <code>model = "f1"</code>, <code>model = "s1"</code>,
<code>model = "f1pp"</code>, or <code>model = "s1pp"</code>.
I would recommend some small value such as <code>10^-3</code>.</p>
</td></tr>
<tr><td><code id="flexdog_full_+3A_p1ref">p1ref</code></td>
<td>
<p>The reference counts for the first parent if
<code>model = "f1"</code> or <code>model = "f1pp"</code>, or for
the only parent if <code>model = "s1"</code> or <code>model = "s1pp"</code>.</p>
</td></tr>
<tr><td><code id="flexdog_full_+3A_p1size">p1size</code></td>
<td>
<p>The total counts for the first parent if
<code>model = "f1"</code> or <code>model = "f1pp"</code>,
or for the only parent if <code>model = "s1"</code> or <code>model = "s1pp"</code>.</p>
</td></tr>
<tr><td><code id="flexdog_full_+3A_p2ref">p2ref</code></td>
<td>
<p>The reference counts for the second parent if
<code>model = "f1"</code> or <code>model = "f1pp"</code>.</p>
</td></tr>
<tr><td><code id="flexdog_full_+3A_p2size">p2size</code></td>
<td>
<p>The total counts for the second parent if
<code>model = "f1"</code> or <code>model = "f1pp"</code>.</p>
</td></tr>
<tr><td><code id="flexdog_full_+3A_snpname">snpname</code></td>
<td>
<p>A string. The name of the SNP under consideration.
This is just returned in the <code>input</code> list for your reference.</p>
</td></tr>
<tr><td><code id="flexdog_full_+3A_prior_vec">prior_vec</code></td>
<td>
<p>The pre-specified genotype distribution. Only used if
<code>model = "custom"</code> and must otherwise be <code>NULL</code>. If specified,
then it should be a vector of length <code>ploidy + 1</code> with
non-negative elements that sum to 1.</p>
</td></tr>
<tr><td><code id="flexdog_full_+3A_seq_upper">seq_upper</code></td>
<td>
<p>The upper bound on the possible sequencing error rate.
Default is 0.05, but you should adjust this if you have prior knowledge
on the sequencing error rate of the sequencing technology.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Possible values of the genotype distribution (values of <code>model</code>) are:
</p>

<dl>
<dt><code>"norm"</code></dt><dd><p>A distribution whose genotype frequencies are proportional
to the density value of a normal with some mean and some standard deviation.
Unlike the <code>"bb"</code> and <code>"hw"</code> options, this will allow for
distributions both more and less dispersed than a binomial.
This seems to be the most robust to violations in modeling assumptions, and so is the
default. This prior class was developed in Gerard and Ferrão (2020).</p>
</dd>
<dt><code>"hw"</code></dt><dd><p>A binomial distribution that results from assuming that
the population is in Hardy-Weinberg equilibrium (HWE). This actually does
pretty well even when there are minor to moderate deviations from HWE.
Though it does not perform as well as the '&quot;norm&quot;' option when there
are severe deviations from HWE.</p>
</dd>
<dt><code>"bb"</code></dt><dd><p>A beta-binomial distribution. This is an overdispersed
version of <code>"hw"</code> and can be derived from a special case of the Balding-Nichols model.</p>
</dd>
<dt><code>"s1"</code></dt><dd><p>This prior assumes the individuals are
all full-siblings resulting
from one generation of selfing. I.e. there is only
one parent. This model assumes
a particular type of meiotic behavior: polysomic
inheritance with
bivalent, non-preferential pairing.</p>
</dd>
<dt><code>"f1"</code></dt><dd><p>This prior assumes the individuals are all
full-siblings resulting
from one generation of a bi-parental cross.
This model assumes
a particular type of meiotic behavior: polysomic
inheritance with
bivalent, non-preferential pairing.</p>
</dd>
<dt><code>"f1pp"</code></dt><dd><p>This prior allows for double reduction
and preferential pairing in an F1 population of tretraploids.</p>
</dd>
<dt><code>"s1pp"</code></dt><dd><p>This prior allows for double reduction
and preferential pairing in an S1 population of tretraploids.</p>
</dd>
<dt><code>"flex"</code></dt><dd><p>Generically any categorical distribution. Theoretically,
this works well if you have a lot of individuals. In practice, it seems to
be much less robust to violations in modeling assumptions.</p>
</dd>
<dt><code>"uniform"</code></dt><dd><p>A discrete uniform distribution. This should never
be used in practice.</p>
</dd>
<dt><code>"custom"</code></dt><dd><p>A pre-specified prior distribution. You specify
it using the <code>prior_vec</code> argument. You should almost never
use this option in practice.</p>
</dd>
</dl>

<p>You might think a good default is <code>model = "uniform"</code> because it is
somehow an &quot;uninformative prior.&quot; But it is very informative and tends to
work horribly in practice. The intuition is that it will estimate
the allele bias and sequencing error rates so that the estimated genotypes
are approximately uniform (since we are assuming that they are approximately
uniform). This will usually result in unintuitive genotyping since most
populations don't have a uniform genotype distribution.
I include it as an option only for completeness. Please don't use it.
</p>
<p>The value of <code>prop_mis</code> is a very intuitive measure for
the quality of the SNP. <code>prop_mis</code> is the posterior
proportion of individuals mis-genotyped. So if you want only SNPS
that accurately genotype, say, 95% of the individuals, you could
discard all SNPs with a <code>prop_mis</code> over <code>0.05</code>.
</p>
<p>The value of <code>maxpostprob</code> is a very intuitive measure
for the quality of the genotype estimate of an individual.
This is the posterior probability of correctly genotyping
the individual when using <code>geno</code> (the posterior mode)
as the genotype estimate. So if you want to correctly genotype,
say, 95% of individuals, you could discard all individuals
with a <code>maxpostprob</code> of under <code>0.95</code>. However, if you are
just going to impute missing genotypes later, you might consider
not discarding any individuals as <code>flexdog</code>'s genotype estimates will
probably be more accurate than other more naive approaches, such
as imputing using the grand mean.
</p>
<p>In most datasets I've examined, allelic bias is a major issue. However,
you may fit the model assuming no allelic bias by setting
<code>update_bias = FALSE</code> and <code>bias_init = 1</code>.
</p>
<p>Prior to using <code>flexdog</code>, during the read-mapping step,
you could try to get rid of allelic bias by
using WASP (<a href="https://doi.org/10.1101/011221">doi:10.1101/011221</a>). If you are successful
in removing the allelic bias (because its only source was the read-mapping
step), then setting <code>update_bias = FALSE</code> and <code>bias_init = 1</code>
would be reasonable. You can visually inspect SNPs for bias by
using <code><a href="#topic+plot_geno">plot_geno</a>()</code>.
</p>
<p><code>flexdog()</code>, like most methods, is invariant to which allele you
label as the &quot;reference&quot; and which you label as the &quot;alternative&quot;.
That is, if you set <code>refvec</code> with the number of alternative
read-counts, then the resulting genotype estimates
will be the estimated allele dosage of the alternative allele.
</p>


<h3>Value</h3>

<p>An object of class <code>flexdog</code>, which consists
of a list with some or all of the following elements:
</p>

<dl>
<dt><code>bias</code></dt><dd><p>The estimated bias parameter.</p>
</dd>
<dt><code>seq</code></dt><dd><p>The estimated sequencing error rate.</p>
</dd>
<dt><code>od</code></dt><dd><p>The estimated overdispersion parameter.</p>
</dd>
<dt><code>num_iter</code></dt><dd><p>The number of EM iterations ran. You should
be wary if this equals <code>itermax</code>.</p>
</dd>
<dt><code>llike</code></dt><dd><p>The maximum marginal log-likelihood.</p>
</dd>
<dt><code>postmat</code></dt><dd><p>A matrix of posterior probabilities of each
genotype for each individual. The rows index the individuals
and the columns index the allele dosage.</p>
</dd>
<dt><code>genologlike</code></dt><dd><p>A matrix of genotype <em>log</em>-likelihoods of each
genotype for each individual. The rows index the individuals
and the columns index the allele dosage.</p>
</dd>
<dt><code>gene_dist</code></dt><dd><p>The estimated genotype distribution. The
<code>i</code>th element is the proportion of individuals with
genotype <code>i-1</code>.</p>
</dd>
<dt><code>par</code></dt><dd><p>A list of the final estimates of the parameters
of the genotype distribution. The elements included in <code>par</code>
depends on the value of <code>model</code>:
</p>

<dl>
<dt><code>model = "norm"</code>:</dt><dd>

<dl>
<dt><code>mu</code>:</dt><dd><p>The normal mean.</p>
</dd>
<dt><code>sigma</code>:</dt><dd><p>The normal standard deviation (not variance).</p>
</dd>
</dl>

</dd>
<dt><code>model = "hw"</code>:</dt><dd>

<dl>
<dt><code>alpha</code>:</dt><dd><p>The major allele frequency.</p>
</dd>
</dl>

</dd>
<dt><code>model = "bb"</code>:</dt><dd>

<dl>
<dt><code>alpha</code>:</dt><dd><p>The major allele frequency.</p>
</dd>
<dt><code>tau</code>:</dt><dd><p>The overdispersion parameter. See the
description of <code>rho</code> in the Details of
<code><a href="#topic+betabinom">betabinom</a>()</code>.</p>
</dd>
</dl>

</dd>
<dt><code>model = "s1"</code>:</dt><dd>

<dl>
<dt><code>pgeno</code>:</dt><dd><p>The allele dosage of the parent.</p>
</dd>
<dt><code>alpha</code>:</dt><dd><p>The mixture proportion of the discrete
uniform (included and fixed at a small value mostly for
numerical stability reasons). See the description
of <code>fs1_alpha</code> in <code><a href="#topic+flexdog_full">flexdog_full</a>()</code>.</p>
</dd>
</dl>

</dd>
<dt><code>model = "f1"</code>:</dt><dd>

<dl>
<dt><code>p1geno</code>:</dt><dd><p>The allele dosage of the first parent.</p>
</dd>
<dt><code>p2geno</code>:</dt><dd><p>The allele dosage of the second parent.</p>
</dd>
<dt><code>alpha</code>:</dt><dd><p>The mixture proportion of the discrete
uniform (included and fixed at a small value mostly for
numerical stability reasons). See the description
of <code>fs1_alpha</code> in <code><a href="#topic+flexdog_full">flexdog_full</a>()</code>.</p>
</dd>
</dl>

</dd>
<dt><code>model = "s1pp"</code>:</dt><dd>

<dl>
<dt><code>ell1</code>:</dt><dd><p>The estimated dosage of the parent.</p>
</dd>
<dt><code>tau1</code>:</dt><dd><p>The estimated double reduction parameter
of the parent. Available if <code>ell1</code> is <code>1</code>, <code>2</code>,
or <code>3</code>. Identified if <code>ell1</code> is <code>1</code> or <code>3</code>.</p>
</dd>
<dt><code>gamma1</code>:</dt><dd><p>The estimated preferential pairing parameter.
Available if <code>ell1</code> is <code>2</code>. However, it is not
returned in an identified form.</p>
</dd>
<dt><code>alpha</code>:</dt><dd><p>The mixture proportion of the discrete
uniform (included and fixed at a small value mostly for
numerical stability reasons). See the description
of <code>fs1_alpha</code> in <code><a href="#topic+flexdog_full">flexdog_full</a>()</code>.</p>
</dd>
</dl>

</dd>
<dt><code>model = "f1pp"</code>:</dt><dd>

<dl>
<dt><code>ell1</code>:</dt><dd><p>The estimated dosage of parent 1.</p>
</dd>
<dt><code>ell2</code>:</dt><dd><p>The estimated dosage of parent 2.</p>
</dd>
<dt><code>tau1</code>:</dt><dd><p>The estimated double reduction parameter
of parent 1. Available if <code>ell1</code> is <code>1</code>, <code>2</code>,
or <code>3</code>. Identified if <code>ell1</code> is <code>1</code> or <code>3</code>.</p>
</dd>
<dt><code>tau2</code>:</dt><dd><p>The estimated double reduction parameter
of parent 2. Available if <code>ell2</code> is <code>1</code>, <code>2</code>,
or <code>3</code>. Identified if <code>ell2</code> is <code>1</code> or <code>3</code>.</p>
</dd>
<dt><code>gamma1</code>:</dt><dd><p>The estimated preferential pairing parameter
of parent 1. Available if <code>ell1</code> is <code>2</code>. However,
it is not returned in an identified form.</p>
</dd>
<dt><code>gamma2</code>:</dt><dd><p>The estimated preferential pairing parameter
of parent 2. Available if <code>ell2</code> is <code>2</code>. However,
it is not returned in an identified form.</p>
</dd>
<dt><code>alpha</code>:</dt><dd><p>The mixture proportion of the discrete
uniform (included and fixed at a small value mostly for
numerical stability reasons). See the description
of <code>fs1_alpha</code> in <code><a href="#topic+flexdog_full">flexdog_full</a>()</code>.</p>
</dd>
</dl>

</dd>
<dt><code>model = "flex"</code>:</dt><dd><p><code>par</code> is an empty list.</p>
</dd>
<dt><code>model = "uniform"</code>:</dt><dd><p><code>par</code> is an empty list.</p>
</dd>
<dt><code>model = "custom"</code>:</dt><dd><p><code>par</code> is an empty list.</p>
</dd>
</dl>
</dd>
<dt><code>geno</code></dt><dd><p>The posterior mode genotype. These are your
genotype estimates.</p>
</dd>
<dt><code>maxpostprob</code></dt><dd><p>The maximum posterior probability. This
is equivalent to the posterior probability of correctly
genotyping each individual.</p>
</dd>
<dt><code>postmean</code></dt><dd><p>The posterior mean genotype. In downstream
association studies, you might want to consider using these
estimates.</p>
</dd>
<dt><code>input$refvec</code></dt><dd><p>The value of <code>refvec</code> provided by
the user.</p>
</dd>
<dt><code>input$sizevec</code></dt><dd><p>The value of <code>sizevec</code> provided
by the user.</p>
</dd>
<dt><code>input$ploidy</code></dt><dd><p>The value of <code>ploidy</code> provided
by the user.</p>
</dd>
<dt><code>input$model</code></dt><dd><p>The value of <code>model</code> provided by
the user.</p>
</dd>
<dt><code>input$p1ref</code></dt><dd><p>The value of <code>p1ref</code> provided by the user.</p>
</dd>
<dt><code>input$p1size</code></dt><dd><p>The value of <code>p1size</code> provided by the user.</p>
</dd>
<dt><code>input$p2ref</code></dt><dd><p>The value of <code>p2ref</code> provided by the user.</p>
</dd>
<dt><code>input$p2size</code></dt><dd><p>The value of <code>p2size</code> provided by the user.</p>
</dd>
<dt><code>input$snpname</code></dt><dd><p>The value of <code>snpname</code> provided by the user.</p>
</dd>
<dt><code>prop_mis</code></dt><dd><p>The posterior proportion of individuals
genotyped incorrectly.</p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>David Gerard
</p>


<h3>References</h3>


<ul>
<li><p>Gerard, D., Ferrão, L. F. V., Garcia, A. A. F., &amp; Stephens, M. (2018). Genotyping Polyploids from Messy Sequencing Data. <em>Genetics</em>, 210(3), 789-807. <a href="https://doi.org/10.1534/genetics.118.301468">doi:10.1534/genetics.118.301468</a>.
</p>
</li>
<li><p>Gerard, David, and Luís Felipe Ventorim Ferrão. &quot;Priors for genotyping polyploids.&quot; Bioinformatics 36, no. 6 (2020): 1795-1800. <a href="https://doi.org/10.1093/bioinformatics/btz852">doi:10.1093/bioinformatics/btz852</a>.
</p>
</li></ul>



<h3>See Also</h3>

<p>Run <code>browseVignettes(package = "updog")</code> in R for example usage.
Other useful functions include:
</p>

<dl>
<dt><code><a href="#topic+multidog">multidog</a></code></dt><dd><p>For running <code>flexdog</code> on multiple
SNPs in parallel.</p>
</dd>
<dt><code><a href="#topic+flexdog">flexdog</a></code></dt><dd><p>For a more user-friendly version of
<code>flexdog_full</code>.</p>
</dd>
<dt><code><a href="#topic+rgeno">rgeno</a></code></dt><dd><p>For simulating genotypes under the allowable
prior models in <code>flexdog</code>.</p>
</dd>
<dt><code><a href="#topic+rflexdog">rflexdog</a></code></dt><dd><p>For simulating read-counts under the
assumed likelihood model in <code>flexdog</code>.</p>
</dd>
<dt><code><a href="#topic+plot.flexdog">plot.flexdog</a></code></dt><dd><p>For plotting the output of
<code>flexdog</code>.</p>
</dd>
<dt><code><a href="#topic+oracle_mis">oracle_mis</a></code></dt><dd><p>For calculating the oracle genotyping
error rates. This is useful for read-depth calculations
<em>before</em> collecting data. After you have data, using
the value of <code>prop_mis</code> is better.</p>
</dd>
<dt><code><a href="#topic+oracle_cor">oracle_cor</a></code></dt><dd><p>For calculating the correlation
between the true genotypes and an oracle estimator
(useful for read-depth calculations <em>before</em>
collecting data).</p>
</dd>
</dl>



<h3>Examples</h3>

<pre><code class='language-R'>## A natural population. We will assume a
## normal prior since there are so few
## individuals.
data("uitdewilligen")
ploidy  &lt;- 4
refvec  &lt;- uitdewilligen$refmat[, 1]
sizevec &lt;- uitdewilligen$sizemat[, 1]
fout    &lt;- flexdog_full(refvec  = refvec,
                        sizevec = sizevec,
                        ploidy  = ploidy,
                        model   = "norm")
plot(fout)

</code></pre>

<hr>
<h2 id='format_multidog'>Return arrayicized elements from the output of <code><a href="#topic+multidog">multidog</a></code>.</h2><span id='topic+format_multidog'></span>

<h3>Description</h3>

<p>This function will allow you to have genotype estimates, maximum posterior
probability, and other values in the form of a matrix/array. If multiple
variable names are provided, the data are formatted as a 3-dimensional
array with the dimensions corresponding to (individuals, SNPs, variables).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>format_multidog(x, varname = "geno")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="format_multidog_+3A_x">x</code></td>
<td>
<p>The output of <code>multidog</code>.</p>
</td></tr>
<tr><td><code id="format_multidog_+3A_varname">varname</code></td>
<td>
<p>A character vector of the variable names whose values
populate the cells. These should be column names from <code>x$inddf</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Note that the order of the individuals will be reshuffled. The order of the
SNPs should be the same as in <code>x$snpdf</code>.
</p>


<h3>Author(s)</h3>

<p>David Gerard
</p>

<hr>
<h2 id='get_q_array'>Return the probabilities of an offspring's genotype given its
parental genotypes for all possible combinations of parental and
offspring genotypes. This is for species with polysomal inheritance
and bivalent, non-preferential pairing.</h2><span id='topic+get_q_array'></span>

<h3>Description</h3>

<p>Return the probabilities of an offspring's genotype given its
parental genotypes for all possible combinations of parental and
offspring genotypes. This is for species with polysomal inheritance
and bivalent, non-preferential pairing.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_q_array(ploidy)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_q_array_+3A_ploidy">ploidy</code></td>
<td>
<p>A positive integer. The ploidy of the species.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An three-way array of proportions. The (i, j, k)th element
is the probability of an offspring having k - 1 reference
alleles given that parent 1 has i - 1 reference alleles and
parent 2 has j - 1 reference alleles. Each dimension of the
array is <code>ploidy + 1</code>. In the dimension names, &quot;A&quot; stands
for the reference allele and &quot;a&quot; stands for the
alternative allele.
</p>


<h3>Author(s)</h3>

<p>David Gerard
</p>


<h3>Examples</h3>

<pre><code class='language-R'>qarray &lt;- get_q_array(6)
apply(qarray, c(1, 2), sum) ## should all be 1's.

</code></pre>

<hr>
<h2 id='is.flexdog'>Tests if an argument is a <code>flexdog</code> object.</h2><span id='topic+is.flexdog'></span>

<h3>Description</h3>

<p>Tests if an argument is a <code>flexdog</code> object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is.flexdog(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="is.flexdog_+3A_x">x</code></td>
<td>
<p>Anything.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A logical. <code>TRUE</code> if <code>x</code> is a <code>flexdog</code> object, and <code>FALSE</code> otherwise.
</p>


<h3>Author(s)</h3>

<p>David Gerard
</p>


<h3>Examples</h3>

<pre><code class='language-R'>is.flexdog("anything")
# FALSE

</code></pre>

<hr>
<h2 id='is.multidog'>Tests if an argument is a <code>multidog</code> object.</h2><span id='topic+is.multidog'></span>

<h3>Description</h3>

<p>Tests if an argument is a <code>multidog</code> object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is.multidog(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="is.multidog_+3A_x">x</code></td>
<td>
<p>Anything.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A logical. <code>TRUE</code> if <code>x</code> is a <code>multidog</code> object, and <code>FALSE</code> otherwise.
</p>


<h3>Author(s)</h3>

<p>David Gerard
</p>


<h3>Examples</h3>

<pre><code class='language-R'>is.multidog("anything")
# FALSE

</code></pre>

<hr>
<h2 id='log_sum_exp'>Log-sum-exponential trick.</h2><span id='topic+log_sum_exp'></span>

<h3>Description</h3>

<p>Log-sum-exponential trick.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>log_sum_exp(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="log_sum_exp_+3A_x">x</code></td>
<td>
<p>A vector to log-sum-exp.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The log of the sum of the exponential
of the elements in <code>x</code>.
</p>


<h3>Author(s)</h3>

<p>David Gerard
</p>

<hr>
<h2 id='log_sum_exp_2'>Log-sum-exponential trick using just two doubles.</h2><span id='topic+log_sum_exp_2'></span>

<h3>Description</h3>

<p>Log-sum-exponential trick using just two doubles.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>log_sum_exp_2(x, y)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="log_sum_exp_2_+3A_x">x</code></td>
<td>
<p>A double.</p>
</td></tr>
<tr><td><code id="log_sum_exp_2_+3A_y">y</code></td>
<td>
<p>Another double.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The log of the sum of the exponential of x and y.
</p>


<h3>Author(s)</h3>

<p>David Gerard
</p>

<hr>
<h2 id='multidog'>Fit <code><a href="#topic+flexdog">flexdog</a></code> to multiple SNPs.</h2><span id='topic+multidog'></span>

<h3>Description</h3>

<p>This is a convenience function that will run <code><a href="#topic+flexdog">flexdog</a></code> over many SNPs.
Support is provided for parallel computing through the doParallel package.
This function has not been extensively tested. Please report any bugs to
<a href="https://github.com/dcgerard/updog/issues">https://github.com/dcgerard/updog/issues</a>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>multidog(
  refmat,
  sizemat,
  ploidy,
  model = c("norm", "hw", "bb", "s1", "s1pp", "f1", "f1pp", "flex", "uniform", "custom"),
  nc = 1,
  p1_id = NULL,
  p2_id = NULL,
  bias_init = exp(c(-1, -0.5, 0, 0.5, 1)),
  prior_vec = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="multidog_+3A_refmat">refmat</code></td>
<td>
<p>A matrix of reference read counts. The columns index
the individuals and the rows index the markers (SNPs). This matrix must have
rownames (for the names of the markers) and column names (for the names
of the individuals). These names must match the names in <code>sizemat</code>.</p>
</td></tr>
<tr><td><code id="multidog_+3A_sizemat">sizemat</code></td>
<td>
<p>A matrix of total read counts. The columns index
the individuals and the rows index the markers (SNPs). This matrix must have
rownames (for the names of the markers) and column names (for the names
of the individuals). These names must match the names in <code>refmat</code>.</p>
</td></tr>
<tr><td><code id="multidog_+3A_ploidy">ploidy</code></td>
<td>
<p>The ploidy of the species. Assumed to be the same for each
individual.</p>
</td></tr>
<tr><td><code id="multidog_+3A_model">model</code></td>
<td>
<p>What form should the prior (genotype distribution) take?
See Details for possible values.</p>
</td></tr>
<tr><td><code id="multidog_+3A_nc">nc</code></td>
<td>
<p>The number of computing cores to use when doing parallelization
on your local machine. See the section &quot;Parallel Computation&quot; for how
to implement more complicated evaluation strategies using the
<code>future</code> package.
</p>
<p>When you are specifying other evaluation strategies using the
<code>future</code> package, you should also set <code>nc = NA</code>.
</p>
<p>The value of <code>nc</code> should never be
more than the number of cores available in your computing environment.
You can determine the maximum number of available cores by running
<code>future::availableCores()</code> in R.</p>
</td></tr>
<tr><td><code id="multidog_+3A_p1_id">p1_id</code></td>
<td>
<p>The ID of the first parent. This should be a character of
length 1. This should correspond to a single column name in <code>refmat</code>
and <code>sizemat</code>.</p>
</td></tr>
<tr><td><code id="multidog_+3A_p2_id">p2_id</code></td>
<td>
<p>The ID of the second parent. This should be a character of
length 1. This should correspond to a single column name in <code>refmat</code>
and <code>sizemat</code>.</p>
</td></tr>
<tr><td><code id="multidog_+3A_bias_init">bias_init</code></td>
<td>
<p>A vector of initial values for the bias parameter
over the multiple runs of <code><a href="#topic+flexdog_full">flexdog_full</a>()</code>.</p>
</td></tr>
<tr><td><code id="multidog_+3A_prior_vec">prior_vec</code></td>
<td>
<p>The pre-specified genotype distribution. Only used if
<code>model = "custom"</code> and must otherwise be <code>NULL</code>. If specified,
then it should be a vector of length <code>ploidy + 1</code> with
non-negative elements that sum to 1.</p>
</td></tr>
<tr><td><code id="multidog_+3A_...">...</code></td>
<td>
<p>Additional parameters to pass to <code><a href="#topic+flexdog_full">flexdog_full</a>()</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>You should format your reference counts and total read counts in two
separate matrices. The rows should index the markers (SNPs) and the
columns should index the individuals. Row names are how we ID the SNPs
and column names are how we ID the individuals, and so they are required
attributes.
</p>
<p>If your data are in VCF files, I would recommend importing them using the
VariantAnnotation package from Bioconductor
<a href="https://bioconductor.org/packages/VariantAnnotation/">https://bioconductor.org/packages/VariantAnnotation/</a>. It's a great
VCF parser.
</p>
<p>See the details of <code><a href="#topic+flexdog">flexdog</a></code> for the possible values of
<code>model</code>.
</p>
<p>If <code>model = "f1"</code>, <code>model = "s1"</code>, <code>model = "f1pp"</code>
or <code>model = "s1pp"</code> then the user may
provide the individual ID for parent(s) via the <code>p1_id</code>
and <code>p2_id</code> arguments.
</p>
<p>The output is a list containing two data frames. The first data frame,
called <code>snpdf</code>, contains information on each SNP, such as the allele bias
and the sequencing error rate. The second data frame, called <code>inddf</code>,
contains information on each individual at each SNP, such as the estimated
genotype and the posterior probability of being classified correctly.
</p>
<p>SNPs that contain 0 reads (or all missing data) are entirely removed.
</p>


<h3>Value</h3>

<p>A list-like object of two data frames.
</p>

<dl>
<dt><code>snpdf</code></dt><dd><p>A data frame containing properties of the SNPs (markers).
The rows index the SNPs. The variables include:
</p>

<dl>
<dt><code>snp</code></dt><dd><p>The name of the SNP (marker).</p>
</dd>
<dt><code>bias</code></dt><dd><p>The estimated allele bias of the SNP.</p>
</dd>
<dt><code>seq</code></dt><dd><p>The estimated sequencing error rate of the SNP.</p>
</dd>
<dt><code>od</code></dt><dd><p>The estimated overdispersion parameter of the SNP.</p>
</dd>
<dt><code>prop_mis</code></dt><dd><p>The estimated proportion of individuals
misclassified in the SNP.</p>
</dd>
<dt><code>num_iter</code></dt><dd><p>The number of iterations performed during
the EM algorithm for that SNP.</p>
</dd>
<dt><code>llike</code></dt><dd><p>The maximum marginal likelihood of the SNP.</p>
</dd>
<dt><code>ploidy</code></dt><dd><p>The provided ploidy of the species.</p>
</dd>
<dt><code>model</code></dt><dd><p>The provided model for the prior genotype
distribution.</p>
</dd>
<dt><code>p1ref</code></dt><dd><p>The user-provided reference read counts of parent 1.</p>
</dd>
<dt><code>p1size</code></dt><dd><p>The user-provided total read counts of parent 1.</p>
</dd>
<dt><code>p2ref</code></dt><dd><p>The user-provided reference read counts of parent 2.</p>
</dd>
<dt><code>p2size</code></dt><dd><p>The user-provided total read counts of parent 2.</p>
</dd>
<dt><code>Pr_k</code></dt><dd><p>The estimated frequency of individuals with genotype
k, where k can be any integer between 0 and the ploidy level.</p>
</dd>
<dt>Model specific parameter estimates</dt><dd><p>See the return value of
<code>par</code> in the help page of <code><a href="#topic+flexdog">flexdog</a></code>.</p>
</dd>
</dl>
</dd>
<dt><code>inddf</code></dt><dd><p>A data frame containing the properties of the
individuals at each SNP. The variables include:
</p>

<dl>
<dt><code>snp</code></dt><dd><p>The name of the SNP (marker).</p>
</dd>
<dt><code>ind</code></dt><dd><p>The name of the individual.</p>
</dd>
<dt><code>ref</code></dt><dd><p>The provided reference counts for that individual at
that SNP.</p>
</dd>
<dt><code>size</code></dt><dd><p>The provided total counts for that individual at
that SNP.</p>
</dd>
<dt><code>geno</code></dt><dd><p>The posterior mode genotype for that individual at
that SNP. This is the estimated reference allele dosage for a
given individual at a given SNP.</p>
</dd>
<dt><code>postmean</code></dt><dd><p>The posterior mean genotype for that individual
at that SNP. This is a continuous genotype estimate of the
reference allele dosage for a given individual at a given SNP.</p>
</dd>
<dt><code>maxpostprob</code></dt><dd><p>The maximum posterior probability. This
is the posterior probability that the individual was genotyped
correctly.</p>
</dd>
<dt><code>Pr_k</code></dt><dd><p>The posterior probability that a given individual
at a given SNP has genotype k, where k can vary from 0 to the
ploidy level of the species.</p>
</dd>
<dt><code>logL_k</code></dt><dd><p>The genotype <em>log</em>-likelihoods for dosage
k for a given individual at a given SNP, where k can vary f
rom 0 to the ploidy level of the species.</p>
</dd>
</dl>
</dd>
</dl>



<h3>Parallel Computation</h3>

<p>The <code>multidog()</code> function supports parallel computing. It does
so through the <a href="https://cran.r-project.org/package=future">future</a>
package.
</p>
<p>If you are just running <code>multidog()</code> on a local machine, then you
can use the <code>nc</code> argument to specify the parallelization. Any value
of <code>nc</code> greater than 1 will result in multiple background R sessions to
genotype all of the SNPs. The maximum value of <code>nc</code> you should
try can be found by running <code>future::availableCores()</code>. Running
<code>multidog()</code> using <code>nc</code> is equivalent to setting the future
plan with <code>future::plan(future::multisession, workers = nc)</code>.
</p>
<p>Using the future package means that different evaluation strategies
are possible. In particular, if you are using a high performance machine,
you can explore using the
<a href="https://cran.r-project.org/package=future.batchtools">future.batchtools</a>
package to evaluate <code>multidog()</code> using schedulers like Slurm
or TORQUE/PBS.
</p>
<p>To use a different strategy, set <code>nc = NA</code> and then
run <code>future::plan()</code> prior to
running <code>multidog()</code>. For example, to set up forked R processes
on your current machine (instead of using background R sessions), you would
run (will not work on Windows):
<code>future::plan(future::multicore)</code>, followed by
running <code>multidog()</code> with <code>nc = NA</code>. See the examples below.
</p>


<h3>Author(s)</h3>

<p>David Gerard
</p>


<h3>See Also</h3>


<dl>
<dt><code><a href="#topic+flexdog">flexdog</a>()</code>:</dt><dd><p>For the underlying genotyping function.</p>
</dd>
<dt><code><a href="#topic+format_multidog">format_multidog</a>()</code>:</dt><dd><p>For converting the output
of <code>multidog()</code> to a matrix.</p>
</dd>
<dt><code><a href="#topic+filter_snp">filter_snp</a>()</code>:</dt><dd><p>For filtering SNPs using the
output of <code>multidog()</code>.</p>
</dd>
</dl>



<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
data("uitdewilligen")

## Run multiple R sessions using the `nc` variable.
mout &lt;- multidog(refmat = t(uitdewilligen$refmat),
                 sizemat = t(uitdewilligen$sizemat),
                 ploidy = uitdewilligen$ploidy,
                 nc = 2)
mout$inddf
mout$snpdf

## Run multiple external R sessions on the local machine.
## Note that we set `nc = NA`.
cl &lt;- parallel::makeCluster(2, timeout = 60)
future::plan(future::cluster, workers = cl)
mout &lt;- multidog(refmat = t(uitdewilligen$refmat),
                 sizemat = t(uitdewilligen$sizemat),
                 ploidy = uitdewilligen$ploidy,
                 nc = NA)
mout$inddf
mout$snpdf

## Close cluster and reset future to current R process
parallel::stopCluster(cl)
future::plan(future::sequential)

## End(Not run)

</code></pre>

<hr>
<h2 id='oracle_cor'>Calculates the correlation between the true genotype and an
oracle estimator.</h2><span id='topic+oracle_cor'></span>

<h3>Description</h3>

<p>Calculates the correlation between the oracle MAP estimator (where we have perfect
knowledge about the data generation process) and the true genotype. This is a useful
approximation when you have a lot of individuals.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>oracle_cor(n, ploidy, seq, bias, od, dist)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="oracle_cor_+3A_n">n</code></td>
<td>
<p>The read-depth.</p>
</td></tr>
<tr><td><code id="oracle_cor_+3A_ploidy">ploidy</code></td>
<td>
<p>The ploidy of the individual.</p>
</td></tr>
<tr><td><code id="oracle_cor_+3A_seq">seq</code></td>
<td>
<p>The sequencing error rate.</p>
</td></tr>
<tr><td><code id="oracle_cor_+3A_bias">bias</code></td>
<td>
<p>The allele-bias.</p>
</td></tr>
<tr><td><code id="oracle_cor_+3A_od">od</code></td>
<td>
<p>The overdispersion parameter.</p>
</td></tr>
<tr><td><code id="oracle_cor_+3A_dist">dist</code></td>
<td>
<p>The distribution of the alleles.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>To come up with <code>dist</code>, you need some additional assumptions.
For example, if the population is in Hardy-Weinberg equilibrium and
the allele frequency is <code>alpha</code> then you could calculate
<code>dist</code> using the R code: <code>dbinom(x = 0:ploidy, size = ploidy, prob = alpha)</code>.
Alternatively, if you know the genotypes of the individual's two parents are, say,
<code>ref_count1</code> and <code>ref_count2</code>, then you could use the <code><a href="#topic+get_q_array">get_q_array</a></code>
function from the updog package: <code>get_q_array(ploidy)[ref_count1 + 1, ref_count2 + 1, ]</code>.
</p>


<h3>Value</h3>

<p>The Pearson correlation between the true genotype and the oracle estimator.
</p>


<h3>Author(s)</h3>

<p>David Gerard
</p>


<h3>References</h3>


<ul>
<li><p>Gerard, D., Ferrão, L. F. V., Garcia, A. A. F., &amp; Stephens, M. (2018). Genotyping Polyploids from Messy Sequencing Data. <em>Genetics</em>, 210(3), 789-807. <a href="https://doi.org/10.1534/genetics.118.301468">doi:10.1534/genetics.118.301468</a>.
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>## Hardy-Weinberg population with allele-frequency of 0.75.
## Moderate bias and moderate overdispersion.
## See how correlation decreases as we
## increase the ploidy.
ploidy &lt;- 2
dist &lt;- stats::dbinom(0:ploidy, ploidy, 0.75)
oracle_cor(n = 100, ploidy = ploidy, seq = 0.001,
           bias = 0.7, od = 0.01, dist = dist)

ploidy &lt;- 4
dist &lt;- stats::dbinom(0:ploidy, ploidy, 0.75)
oracle_cor(n = 100, ploidy = ploidy, seq = 0.001,
           bias = 0.7, od = 0.01, dist = dist)

ploidy &lt;- 6
dist &lt;- stats::dbinom(0:ploidy, ploidy, 0.75)
oracle_cor(n = 100, ploidy = ploidy, seq = 0.001,
           bias = 0.7, od = 0.01, dist = dist)

</code></pre>

<hr>
<h2 id='oracle_cor_from_joint'>Calculate the correlation of the oracle estimator with the true
genotype from the joint distribution matrix.</h2><span id='topic+oracle_cor_from_joint'></span>

<h3>Description</h3>

<p>Calculates the correlation between the oracle MAP estimator (where we have perfect
knowledge about the data generation process) and the true genotype. This is a useful
approximation when you have a lot of individuals.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>oracle_cor_from_joint(jd)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="oracle_cor_from_joint_+3A_jd">jd</code></td>
<td>
<p>A matrix of numerics. Element (i, j) is the probability
of genotype i - 1 and estimated genotype j - 1. This is usually
obtained from <code><a href="#topic+oracle_joint">oracle_joint</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The Pearson correlation between the true genotype and the oracle estimator.
</p>


<h3>Author(s)</h3>

<p>David Gerard
</p>


<h3>References</h3>


<ul>
<li><p>Gerard, D., Ferrão, L. F. V., Garcia, A. A. F., &amp; Stephens, M. (2018). Genotyping Polyploids from Messy Sequencing Data. <em>Genetics</em>, 210(3), 789-807. <a href="https://doi.org/10.1534/genetics.118.301468">doi:10.1534/genetics.118.301468</a>.
</p>
</li></ul>



<h3>See Also</h3>

<p><code><a href="#topic+oracle_joint">oracle_joint</a></code> for getting <code>jd</code>.
<code><a href="#topic+oracle_cor">oracle_cor</a></code> for not having to first calculate
<code>jd</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Hardy-Weinberg population with allele-frequency of 0.75.
## Moderate bias and moderate overdispersion.
ploidy &lt;- 6
dist &lt;- stats::dbinom(0:ploidy, ploidy, 0.75)
jd &lt;- oracle_joint(n = 100, ploidy = ploidy, seq = 0.001,
                   bias = 0.7, od = 0.01, dist = dist)
oracle_cor_from_joint(jd = jd)

## Compare to oracle_cor
oracle_cor(n = 100, ploidy = ploidy, seq = 0.001,
           bias = 0.7, od = 0.01, dist = dist)


</code></pre>

<hr>
<h2 id='oracle_joint'>The joint probability of the genotype and the genotype estimate
of an oracle estimator.</h2><span id='topic+oracle_joint'></span>

<h3>Description</h3>

<p>This returns the joint distribution of the true genotypes and an oracle
estimator given perfect knowledge of the data generating process. This is a useful
approximation when you have a lot of individuals.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>oracle_joint(n, ploidy, seq, bias, od, dist)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="oracle_joint_+3A_n">n</code></td>
<td>
<p>The read-depth.</p>
</td></tr>
<tr><td><code id="oracle_joint_+3A_ploidy">ploidy</code></td>
<td>
<p>The ploidy of the individual.</p>
</td></tr>
<tr><td><code id="oracle_joint_+3A_seq">seq</code></td>
<td>
<p>The sequencing error rate.</p>
</td></tr>
<tr><td><code id="oracle_joint_+3A_bias">bias</code></td>
<td>
<p>The allele-bias.</p>
</td></tr>
<tr><td><code id="oracle_joint_+3A_od">od</code></td>
<td>
<p>The overdispersion parameter.</p>
</td></tr>
<tr><td><code id="oracle_joint_+3A_dist">dist</code></td>
<td>
<p>The distribution of the alleles.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>To come up with <code>dist</code>, you need some additional assumptions.
For example, if the population is in Hardy-Weinberg equilibrium and
the allele frequency is <code>alpha</code> then you could calculate
<code>dist</code> using the R code: <code>dbinom(x = 0:ploidy, size = ploidy, prob = alpha)</code>.
Alternatively, if you know the genotypes of the individual's two parents are, say,
<code>ref_count1</code> and <code>ref_count2</code>, then you could use the <code><a href="#topic+get_q_array">get_q_array</a></code>
function from the updog package: <code>get_q_array(ploidy)[ref_count1 + 1, ref_count2 + 1, ]</code>.
</p>
<p>See the Examples to see how to reconcile the output of <code>oracle_joint</code>
with <code><a href="#topic+oracle_mis">oracle_mis</a></code> and <code><a href="#topic+oracle_mis_vec">oracle_mis_vec</a></code>.
</p>


<h3>Value</h3>

<p>A matrix. Element (i, j) is the joint probability of estimating
the genotype to be i+1 when the true genotype is j+1. That is, the
estimated genotype indexes the rows and the true genotype indexes
the columns. This is when
using an oracle estimator.
</p>


<h3>Author(s)</h3>

<p>David Gerard
</p>


<h3>References</h3>


<ul>
<li><p>Gerard, D., Ferrão, L. F. V., Garcia, A. A. F., &amp; Stephens, M. (2018). Genotyping Polyploids from Messy Sequencing Data. <em>Genetics</em>, 210(3), 789-807. <a href="https://doi.org/10.1534/genetics.118.301468">doi:10.1534/genetics.118.301468</a>.
</p>
</li></ul>



<h3>See Also</h3>


<dl>
<dt><code><a href="#topic+oracle_plot">oracle_plot</a></code></dt><dd><p>For visualizing the joint distribution output from <code>oracle_joint</code>.</p>
</dd>
<dt><code><a href="#topic+oracle_mis_from_joint">oracle_mis_from_joint</a></code></dt><dd><p>For obtaining the same results as <code><a href="#topic+oracle_mis">oracle_mis</a></code>
directly from the output of <code>oracle_joint</code>.</p>
</dd>
<dt><code><a href="#topic+oracle_mis_vec_from_joint">oracle_mis_vec_from_joint</a></code></dt><dd><p>For obtaining the same results as <code><a href="#topic+oracle_mis_vec">oracle_mis_vec</a></code>
directly from the output of <code>oracle_joint</code>.</p>
</dd>
<dt><code><a href="#topic+oracle_cor_from_joint">oracle_cor_from_joint</a></code></dt><dd><p>For obtaining the same results as <code><a href="#topic+oracle_cor">oracle_cor</a></code>
directly from the output of <code>oracle_joint</code>.</p>
</dd>
</dl>



<h3>Examples</h3>

<pre><code class='language-R'>## Hardy-Weinberg population with allele-frequency of 0.75.
## Moderate bias and moderate overdispersion.
ploidy &lt;- 4
dist &lt;- stats::dbinom(0:ploidy, ploidy, 0.75)
jd &lt;- oracle_joint(n = 100, ploidy = ploidy, seq = 0.001,
                   bias = 0.7, od = 0.01, dist = dist)
jd

## Get same output as oracle_mis this way:
1 - sum(diag(jd))
oracle_mis(n = 100, ploidy = ploidy, seq = 0.001,
           bias = 0.7, od = 0.01, dist = dist)

## Get same output as oracle_mis_vec this way:
1 - diag(sweep(x = jd, MARGIN = 2, STATS = colSums(jd), FUN = "/"))
oracle_mis_vec(n = 100, ploidy = ploidy, seq = 0.001,
               bias = 0.7, od = 0.01, dist = dist)

</code></pre>

<hr>
<h2 id='oracle_mis'>Calculate oracle misclassification error rate.</h2><span id='topic+oracle_mis'></span>

<h3>Description</h3>

<p>Given perfect knowledge of the data generating parameters,
<code>oracle_mis</code> calculates the misclassification error
rate, where the error rate is taken over both the data generation
process and the allele-distribution.
This is an ideal level of the misclassification error rate and
any real method will have a larger rate than this. This is a useful
approximation when you have a lot of individuals.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>oracle_mis(n, ploidy, seq, bias, od, dist)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="oracle_mis_+3A_n">n</code></td>
<td>
<p>The read-depth.</p>
</td></tr>
<tr><td><code id="oracle_mis_+3A_ploidy">ploidy</code></td>
<td>
<p>The ploidy of the individual.</p>
</td></tr>
<tr><td><code id="oracle_mis_+3A_seq">seq</code></td>
<td>
<p>The sequencing error rate.</p>
</td></tr>
<tr><td><code id="oracle_mis_+3A_bias">bias</code></td>
<td>
<p>The allele-bias.</p>
</td></tr>
<tr><td><code id="oracle_mis_+3A_od">od</code></td>
<td>
<p>The overdispersion parameter.</p>
</td></tr>
<tr><td><code id="oracle_mis_+3A_dist">dist</code></td>
<td>
<p>The distribution of the alleles.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>To come up with <code>dist</code>, you need some additional assumptions.
For example, if the population is in Hardy-Weinberg equilibrium and
the allele frequency is <code>alpha</code> then you could calculate
<code>dist</code> using the R code: <code>dbinom(x = 0:ploidy, size = ploidy, prob = alpha)</code>.
Alternatively, if you know the genotypes of the individual's two parents are, say,
<code>ref_count1</code> and <code>ref_count2</code>, then you could use the <code><a href="#topic+get_q_array">get_q_array</a></code>
function from the updog package: <code>get_q_array(ploidy)[ref_count1 + 1, ref_count2 + 1, ]</code>.
</p>


<h3>Value</h3>

<p>A double. The oracle misclassification error rate.
</p>


<h3>Author(s)</h3>

<p>David Gerard
</p>


<h3>References</h3>


<ul>
<li><p>Gerard, D., Ferrão, L. F. V., Garcia, A. A. F., &amp; Stephens, M. (2018). Genotyping Polyploids from Messy Sequencing Data. <em>Genetics</em>, 210(3), 789-807. <a href="https://doi.org/10.1534/genetics.118.301468">doi:10.1534/genetics.118.301468</a>.
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>## Hardy-Weinberg population with allele-frequency of 0.75.
## Moderate bias and moderate overdispersion.
## See how oracle misclassification error rates change as we
## increase the ploidy.
ploidy &lt;- 2
dist &lt;- stats::dbinom(0:ploidy, ploidy, 0.75)
oracle_mis(n = 100, ploidy = ploidy, seq = 0.001,
           bias = 0.7, od = 0.01, dist = dist)

ploidy &lt;- 4
dist &lt;- stats::dbinom(0:ploidy, ploidy, 0.75)
oracle_mis(n = 100, ploidy = ploidy, seq = 0.001,
           bias = 0.7, od = 0.01, dist = dist)

ploidy &lt;- 6
dist &lt;- stats::dbinom(0:ploidy, ploidy, 0.75)
oracle_mis(n = 100, ploidy = ploidy, seq = 0.001,
           bias = 0.7, od = 0.01, dist = dist)

</code></pre>

<hr>
<h2 id='oracle_mis_from_joint'>Get the oracle misclassification error rate directly from the
joint distribution of the genotype and the oracle estimator.</h2><span id='topic+oracle_mis_from_joint'></span>

<h3>Description</h3>

<p>Get the oracle misclassification error rate directly from the
joint distribution of the genotype and the oracle estimator.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>oracle_mis_from_joint(jd)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="oracle_mis_from_joint_+3A_jd">jd</code></td>
<td>
<p>A matrix of numerics. Element (i, j) is the probability
of genotype i - 1 and estimated genotype j - 1. This is usually
obtained from <code><a href="#topic+oracle_joint">oracle_joint</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A double. The oracle misclassification error rate.
</p>


<h3>Author(s)</h3>

<p>David Gerard
</p>


<h3>References</h3>


<ul>
<li><p>Gerard, D., Ferrão, L. F. V., Garcia, A. A. F., &amp; Stephens, M. (2018). Genotyping Polyploids from Messy Sequencing Data. <em>Genetics</em>, 210(3), 789-807. <a href="https://doi.org/10.1534/genetics.118.301468">doi:10.1534/genetics.118.301468</a>.
</p>
</li></ul>



<h3>See Also</h3>

<p><code><a href="#topic+oracle_joint">oracle_joint</a></code> for getting <code>jd</code>.
<code><a href="#topic+oracle_mis">oracle_mis</a></code> for not having to first calculate
<code>jd</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Hardy-Weinberg population with allele-frequency of 0.75.
## Moderate bias and moderate overdispersion.
ploidy &lt;- 6
dist &lt;- stats::dbinom(0:ploidy, ploidy, 0.75)
jd &lt;- oracle_joint(n = 100, ploidy = ploidy, seq = 0.001,
                   bias = 0.7, od = 0.01, dist = dist)
oracle_mis_from_joint(jd = jd)

## Compare to oracle_cor
oracle_mis(n = 100, ploidy = ploidy, seq = 0.001,
           bias = 0.7, od = 0.01, dist = dist)

</code></pre>

<hr>
<h2 id='oracle_mis_vec'>Returns the oracle misclassification rates for each genotype.</h2><span id='topic+oracle_mis_vec'></span>

<h3>Description</h3>

<p>Given perfect knowledge of the data generating parameters,
<code>oracle_mis_vec</code> calculates the misclassification error
rate at each genotype. This differs from <code><a href="#topic+oracle_mis">oracle_mis</a></code>
in that this will <em>not</em> average over the genotype distribution to
get an overall misclassification error rate. That is, <code>oracle_mis_vec</code>
returns a vector of misclassification error rates <em>conditional</em> on
each genotype.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>oracle_mis_vec(n, ploidy, seq, bias, od, dist)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="oracle_mis_vec_+3A_n">n</code></td>
<td>
<p>The read-depth.</p>
</td></tr>
<tr><td><code id="oracle_mis_vec_+3A_ploidy">ploidy</code></td>
<td>
<p>The ploidy of the individual.</p>
</td></tr>
<tr><td><code id="oracle_mis_vec_+3A_seq">seq</code></td>
<td>
<p>The sequencing error rate.</p>
</td></tr>
<tr><td><code id="oracle_mis_vec_+3A_bias">bias</code></td>
<td>
<p>The allele-bias.</p>
</td></tr>
<tr><td><code id="oracle_mis_vec_+3A_od">od</code></td>
<td>
<p>The overdispersion parameter.</p>
</td></tr>
<tr><td><code id="oracle_mis_vec_+3A_dist">dist</code></td>
<td>
<p>The distribution of the alleles.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This is an ideal level of the misclassification error rate and
any real method will have a larger rate than this. This is a useful
approximation when you have a lot of individuals.
</p>
<p>To come up with <code>dist</code>, you need some additional assumptions.
For example, if the population is in Hardy-Weinberg equilibrium and
the allele frequency is <code>alpha</code> then you could calculate
<code>dist</code> using the R code: <code>dbinom(x = 0:ploidy, size = ploidy, prob = alpha)</code>.
Alternatively, if you know the genotypes of the individual's two parents are, say,
<code>ref_count1</code> and <code>ref_count2</code>, then you could use the <code><a href="#topic+get_q_array">get_q_array</a></code>
function from the updog package: <code>get_q_array(ploidy)[ref_count1 + 1, ref_count2 + 1, ]</code>.
</p>


<h3>Value</h3>

<p>A vector of numerics. Element i is the oracle misclassification
error rate when genotyping an individual with actual
genotype i + 1.
</p>


<h3>Author(s)</h3>

<p>David Gerard
</p>


<h3>References</h3>


<ul>
<li><p>Gerard, D., Ferrão, L. F. V., Garcia, A. A. F., &amp; Stephens, M. (2018). Genotyping Polyploids from Messy Sequencing Data. <em>Genetics</em>, 210(3), 789-807. <a href="https://doi.org/10.1534/genetics.118.301468">doi:10.1534/genetics.118.301468</a>.
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>## Hardy-Weinberg population with allele-frequency of 0.75.
## Moderate bias and moderate overdispersion.
ploidy &lt;- 4
dist &lt;- stats::dbinom(0:ploidy, ploidy, 0.75)
om &lt;- oracle_mis_vec(n = 100, ploidy = ploidy, seq = 0.001,
                     bias = 0.7, od = 0.01, dist = dist)
om

## Get same output as oracle_mis this way:
sum(dist * om)
oracle_mis(n = 100, ploidy = ploidy, seq = 0.001,
           bias = 0.7, od = 0.01, dist = dist)

</code></pre>

<hr>
<h2 id='oracle_mis_vec_from_joint'>Get the oracle misclassification error rates (conditional on
true genotype) directly from the
joint distribution of the genotype and the oracle estimator.</h2><span id='topic+oracle_mis_vec_from_joint'></span>

<h3>Description</h3>

<p>Get the oracle misclassification error rates (conditional on
true genotype) directly from the
joint distribution of the genotype and the oracle estimator.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>oracle_mis_vec_from_joint(jd)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="oracle_mis_vec_from_joint_+3A_jd">jd</code></td>
<td>
<p>A matrix of numerics. Element (i, j) is the probability
of genotype i - 1 and estimated genotype j - 1. This is usually
obtained from <code><a href="#topic+oracle_joint">oracle_joint</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector of numerics. Element i is the oracle misclassification
error rate when genotyping an individual with actual
genotype i + 1.
</p>


<h3>Author(s)</h3>

<p>David Gerard
</p>


<h3>References</h3>


<ul>
<li><p>Gerard, D., Ferrão, L. F. V., Garcia, A. A. F., &amp; Stephens, M. (2018). Genotyping Polyploids from Messy Sequencing Data. <em>Genetics</em>, 210(3), 789-807. <a href="https://doi.org/10.1534/genetics.118.301468">doi:10.1534/genetics.118.301468</a>.
</p>
</li></ul>



<h3>See Also</h3>

<p><code><a href="#topic+oracle_joint">oracle_joint</a></code> for getting <code>jd</code>.
<code><a href="#topic+oracle_mis_vec">oracle_mis_vec</a></code> for not having to first calculate
<code>jd</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Hardy-Weinberg population with allele-frequency of 0.75.
## Moderate bias and moderate overdispersion.
ploidy &lt;- 6
dist &lt;- stats::dbinom(0:ploidy, ploidy, 0.75)
jd &lt;- oracle_joint(n = 100, ploidy = ploidy, seq = 0.001,
                   bias = 0.7, od = 0.01, dist = dist)
oracle_mis_vec_from_joint(jd = jd)

## Compare to oracle_cor
oracle_mis_vec(n = 100, ploidy = ploidy, seq = 0.001,
               bias = 0.7, od = 0.01, dist = dist)

</code></pre>

<hr>
<h2 id='oracle_plot'>Construct an oracle plot from the output of <code><a href="#topic+oracle_joint">oracle_joint</a></code>.</h2><span id='topic+oracle_plot'></span>

<h3>Description</h3>

<p>After obtaining the joint distribution of the true genotype with the estimated genotype from
the oracle estimator using <code><a href="#topic+oracle_joint">oracle_joint</a></code>, you can use <code>oracle_plot</code> to
visualize this joint distribution.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>oracle_plot(jd)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="oracle_plot_+3A_jd">jd</code></td>
<td>
<p>A matrix containing the joint distribution of the true genotype and
the oracle estimator. Usually, this is obtained by a call from <code><a href="#topic+oracle_joint">oracle_joint</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code><a href="ggplot2.html#topic+ggplot">ggplot</a></code> object containing the oracle plot. The x-axis indexes
the possible values of the estimated genotype. The y-axis indexes the possible values of
the true genotype. The number in cell (i, j) is the probability that an individual will have
true genotype i but is estimated to have genotype j. This is when using an oracle estimator.
The cells are also color-coded by the size of the probability in each cell. At the top are
listed the oracle misclassification error rate and the correlation of the true genotype
with the estimated genotype. Both of these quantities may be derived from the joint distribution.
</p>


<h3>Author(s)</h3>

<p>David Gerard
</p>


<h3>References</h3>


<ul>
<li><p>Gerard, D., Ferrão, L. F. V., Garcia, A. A. F., &amp; Stephens, M. (2018). Genotyping Polyploids from Messy Sequencing Data. <em>Genetics</em>, 210(3), 789-807. <a href="https://doi.org/10.1534/genetics.118.301468">doi:10.1534/genetics.118.301468</a>.
</p>
</li></ul>



<h3>See Also</h3>

<p><code><a href="#topic+oracle_joint">oracle_joint</a></code> for obtaining <code>jd</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>ploidy &lt;- 6
dist &lt;- stats::dbinom(0:ploidy, ploidy, 0.75)
jd &lt;- oracle_joint(n = 100, ploidy = ploidy, seq = 0.001,
                   bias = 0.7, od = 0.01, dist = dist)
pl &lt;- oracle_plot(jd = jd)
print(pl)

</code></pre>

<hr>
<h2 id='plot_geno'>Make a genotype plot.</h2><span id='topic+plot_geno'></span>

<h3>Description</h3>

<p>The x-axis is the counts of the non-reference allele,
and the y-axis is the counts of the reference allele.
Transparency is controlled by the <code>maxpostprob</code>
vector. These types of plots are used in Gerard et. al. (2018) and
Gerard and Ferrão (2020).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot_geno(
  refvec,
  sizevec,
  ploidy,
  p1ref = NULL,
  p1size = NULL,
  p2ref = NULL,
  p2size = NULL,
  geno = NULL,
  seq = 0,
  bias = 1,
  maxpostprob = NULL,
  p1geno = NULL,
  p2geno = NULL,
  use_colorblind = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot_geno_+3A_refvec">refvec</code></td>
<td>
<p>A vector of non-negative integers. The number of
reference reads observed in the individuals</p>
</td></tr>
<tr><td><code id="plot_geno_+3A_sizevec">sizevec</code></td>
<td>
<p>A vector of positive integers. The total number of
reads in the individuals.</p>
</td></tr>
<tr><td><code id="plot_geno_+3A_ploidy">ploidy</code></td>
<td>
<p>A non-negative integer. The ploidy of the species.</p>
</td></tr>
<tr><td><code id="plot_geno_+3A_p1ref">p1ref</code></td>
<td>
<p>A vector of non-negative integers. The number of
reference reads observed in parent 1 (if the individuals are
all siblings).</p>
</td></tr>
<tr><td><code id="plot_geno_+3A_p1size">p1size</code></td>
<td>
<p>A vector of positive integers. The total number of
reads in parent 1 (if the individuals are
all siblings).</p>
</td></tr>
<tr><td><code id="plot_geno_+3A_p2ref">p2ref</code></td>
<td>
<p>A vector of non-negative integers. The number of
reference reads observed in parent 2 (if the individuals are
all siblings).</p>
</td></tr>
<tr><td><code id="plot_geno_+3A_p2size">p2size</code></td>
<td>
<p>A vector of positive integers. The total number of
reads in parent 2 (if the individuals are
all siblings).</p>
</td></tr>
<tr><td><code id="plot_geno_+3A_geno">geno</code></td>
<td>
<p>The individual genotypes.</p>
</td></tr>
<tr><td><code id="plot_geno_+3A_seq">seq</code></td>
<td>
<p>The sequencing error rate.</p>
</td></tr>
<tr><td><code id="plot_geno_+3A_bias">bias</code></td>
<td>
<p>The bias parameter.</p>
</td></tr>
<tr><td><code id="plot_geno_+3A_maxpostprob">maxpostprob</code></td>
<td>
<p>A vector of the posterior probabilities of being at
the modal genotype.</p>
</td></tr>
<tr><td><code id="plot_geno_+3A_p1geno">p1geno</code></td>
<td>
<p>Parent 1's genotype.</p>
</td></tr>
<tr><td><code id="plot_geno_+3A_p2geno">p2geno</code></td>
<td>
<p>Parent 2's genotype.</p>
</td></tr>
<tr><td><code id="plot_geno_+3A_use_colorblind">use_colorblind</code></td>
<td>
<p>A logical. Should we use a colorblind safe palette (<code>TRUE</code>),
or not (<code>FALSE</code>)? Only allowed if <code>ploidy &lt;= 6</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If parental genotypes are provided (<code>p1geno</code> and <code>p2geno</code>) then
they will be colored the same as the offspring. Since they are often hard to see,
a small black dot will also indicate their position.
</p>


<h3>Value</h3>

<p>A <code><a href="ggplot2.html#topic+ggplot">ggplot</a></code> object for the genotype plot.
</p>


<h3>Author(s)</h3>

<p>David Gerard
</p>


<h3>References</h3>


<ul>
<li><p>Gerard, D., Ferrão, L. F. V., Garcia, A. A. F., &amp; Stephens, M. (2018). Genotyping Polyploids from Messy Sequencing Data. <em>Genetics</em>, 210(3), 789-807. <a href="https://doi.org/10.1534/genetics.118.301468">doi:10.1534/genetics.118.301468</a>.
</p>
</li>
<li><p>Gerard, David, and Luís Felipe Ventorim Ferrão. &quot;Priors for genotyping polyploids.&quot; Bioinformatics 36, no. 6 (2020): 1795-1800. <a href="https://doi.org/10.1093/bioinformatics/btz852">doi:10.1093/bioinformatics/btz852</a>.
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>data("snpdat")
refvec  &lt;- snpdat$counts[snpdat$snp == "SNP1"]
sizevec &lt;- snpdat$size[snpdat$snp == "SNP1"]
ploidy  &lt;- 6
plot_geno(refvec = refvec, sizevec = sizevec, ploidy = ploidy)

</code></pre>

<hr>
<h2 id='plot.flexdog'>Draw a genotype plot from the output of <code><a href="#topic+flexdog">flexdog</a></code>.</h2><span id='topic+plot.flexdog'></span>

<h3>Description</h3>

<p>A wrapper for <code><a href="#topic+plot_geno">plot_geno</a></code>. This will create a genotype plot for a single SNP.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'flexdog'
plot(x, use_colorblind = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.flexdog_+3A_x">x</code></td>
<td>
<p>A <code>flexdog</code> object.</p>
</td></tr>
<tr><td><code id="plot.flexdog_+3A_use_colorblind">use_colorblind</code></td>
<td>
<p>Should we use a colorblind-safe palette
(<code>TRUE</code>) or not (<code>FALSE</code>)? <code>TRUE</code> is only allowed
if the ploidy is less than or equal to 6.</p>
</td></tr>
<tr><td><code id="plot.flexdog_+3A_...">...</code></td>
<td>
<p>Not used.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>On a genotype plot, the x-axis contains the counts of the non-reference allele and the y-axis
contains the counts of the reference allele. The dashed lines are the expected counts (both reference and alternative)
given the sequencing error rate and the allele-bias. The plots are color-coded by the maximum-a-posterior genotypes.
Transparency is proportional to the maximum posterior probability for an
individual's genotype. Thus, we are less certain of the genotype of more transparent individuals. These
types of plots are used in Gerard et. al. (2018) and Gerard and Ferrão (2020).
</p>


<h3>Value</h3>

<p>A <code><a href="ggplot2.html#topic+ggplot">ggplot</a></code> object for the genotype plot.
</p>


<h3>Author(s)</h3>

<p>David Gerard
</p>


<h3>References</h3>


<ul>
<li><p>Gerard, D., Ferrão, L. F. V., Garcia, A. A. F., &amp; Stephens, M. (2018). Genotyping Polyploids from Messy Sequencing Data. <em>Genetics</em>, 210(3), 789-807. <a href="https://doi.org/10.1534/genetics.118.301468">doi:10.1534/genetics.118.301468</a>.
</p>
</li>
<li><p>Gerard, David, and Luís Felipe Ventorim Ferrão. &quot;Priors for genotyping polyploids.&quot; Bioinformatics 36, no. 6 (2020): 1795-1800. <a href="https://doi.org/10.1093/bioinformatics/btz852">doi:10.1093/bioinformatics/btz852</a>.
</p>
</li></ul>



<h3>See Also</h3>


<dl>
<dt><code><a href="#topic+plot_geno">plot_geno</a></code></dt><dd><p>The underlying plotting function.</p>
</dd>
<dt><code><a href="#topic+flexdog">flexdog</a></code></dt><dd><p>Creates a <code>flexdog</code> object.</p>
</dd>
</dl>


<hr>
<h2 id='plot.multidog'>Plot the output of <code><a href="#topic+multidog">multidog</a></code>.</h2><span id='topic+plot.multidog'></span>

<h3>Description</h3>

<p>Produce genotype plots from the output of <code><a href="#topic+multidog">multidog</a></code>. You may
select which SNPs to plot.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'multidog'
plot(x, indices = seq(1, min(5, nrow(x$snpdf))), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.multidog_+3A_x">x</code></td>
<td>
<p>The output of <code><a href="#topic+multidog">multidog</a></code>.</p>
</td></tr>
<tr><td><code id="plot.multidog_+3A_indices">indices</code></td>
<td>
<p>A vector of integers. The indices of the SNPs to plot.</p>
</td></tr>
<tr><td><code id="plot.multidog_+3A_...">...</code></td>
<td>
<p>not used.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>On a genotype plot, the x-axis contains the counts of the non-reference allele and the y-axis
contains the counts of the reference allele. The dashed lines are the expected counts (both reference and alternative)
given the sequencing error rate and the allele-bias. The plots are color-coded by the maximum-a-posterior genotypes.
Transparency is proportional to the maximum posterior probability for an
individual's genotype. Thus, we are less certain of the genotype of more transparent individuals. These
types of plots are used in Gerard et. al. (2018) and Gerard and Ferrão (2020).
</p>


<h3>Author(s)</h3>

<p>David Gerard
</p>


<h3>References</h3>


<ul>
<li><p>Gerard, D., Ferrão, L. F. V., Garcia, A. A. F., &amp; Stephens, M. (2018). Genotyping Polyploids from Messy Sequencing Data. <em>Genetics</em>, 210(3), 789-807. <a href="https://doi.org/10.1534/genetics.118.301468">doi:10.1534/genetics.118.301468</a>.
</p>
</li>
<li><p>Gerard, David, and Luís Felipe Ventorim Ferrão. &quot;Priors for genotyping polyploids.&quot; Bioinformatics 36, no. 6 (2020): 1795-1800. <a href="https://doi.org/10.1093/bioinformatics/btz852">doi:10.1093/bioinformatics/btz852</a>.
</p>
</li></ul>



<h3>See Also</h3>

<p><code><a href="#topic+plot_geno">plot_geno</a></code>.
</p>

<hr>
<h2 id='rflexdog'>Simulate GBS data from the <code><a href="#topic+flexdog">flexdog</a></code> likelihood.</h2><span id='topic+rflexdog'></span>

<h3>Description</h3>

<p>This will take a vector of genotypes and a vector of total read-counts, then generate a vector of reference
counts. To get the genotypes, you could use <code><a href="#topic+rgeno">rgeno</a></code>. The likelihood used to generate read-counts
is described in detail in Gerard et. al. (2018).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rflexdog(sizevec, geno, ploidy, seq = 0.005, bias = 1, od = 0.001)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rflexdog_+3A_sizevec">sizevec</code></td>
<td>
<p>A vector of total read-counts for the individuals.</p>
</td></tr>
<tr><td><code id="rflexdog_+3A_geno">geno</code></td>
<td>
<p>A vector of genotypes for the individuals. I.e. the number of reference alleles
each individual has.</p>
</td></tr>
<tr><td><code id="rflexdog_+3A_ploidy">ploidy</code></td>
<td>
<p>The ploidy of the species.</p>
</td></tr>
<tr><td><code id="rflexdog_+3A_seq">seq</code></td>
<td>
<p>The sequencing error rate.</p>
</td></tr>
<tr><td><code id="rflexdog_+3A_bias">bias</code></td>
<td>
<p>The bias parameter. Pr(a read after selected) / Pr(A read after selected).</p>
</td></tr>
<tr><td><code id="rflexdog_+3A_od">od</code></td>
<td>
<p>The overdispersion parameter. See the
Details of the <code>rho</code> variable in <code><a href="#topic+betabinom">betabinom</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector the same length as <code>sizevec</code>. The ith element
is the number of reference counts for individual i.
</p>


<h3>Author(s)</h3>

<p>David Gerard
</p>


<h3>References</h3>


<ul>
<li><p>Gerard, D., Ferrão, L. F. V., Garcia, A. A. F., &amp; Stephens, M. (2018). Genotyping Polyploids from Messy Sequencing Data. <em>Genetics</em>, 210(3), 789-807. <a href="https://doi.org/10.1534/genetics.118.301468">doi:10.1534/genetics.118.301468</a>.
</p>
</li>
<li><p>Gerard, David, and Luís Felipe Ventorim Ferrão. &quot;Priors for genotyping polyploids.&quot; Bioinformatics 36, no. 6 (2020): 1795-1800. <a href="https://doi.org/10.1093/bioinformatics/btz852">doi:10.1093/bioinformatics/btz852</a>.
</p>
</li></ul>



<h3>See Also</h3>

<p><code><a href="#topic+rgeno">rgeno</a></code> for a way to generate genotypes of individuals. <code><a href="#topic+rbetabinom">rbetabinom</a></code>
for how we generate the read-counts.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(1)
n       &lt;- 100
ploidy  &lt;- 6

## Generate the genotypes of individuals from an F1 population,
## where the first parent has 1 copy of the reference allele
## and the second parent has two copies of the reference
## allele.
genovec &lt;- rgeno(n = n, ploidy = ploidy, model = "f1",
                 p1geno = 1, p2geno = 2)

## Get the total number of read-counts for each individual.
## Ideally, you would take this from real data as the total
## read-counts are definitely not Poisson.
sizevec &lt;- stats::rpois(n = n, lambda = 200)

## Generate the counts of reads with the reference allele
## when there is a strong bias for the reference allele
## and there is no overdispersion.
refvec  &lt;- rflexdog(sizevec = sizevec, geno = genovec,
                    ploidy = ploidy, seq = 0.001,
                    bias = 0.5, od = 0)

## Plot the simulated data using plot_geno.
plot_geno(refvec = refvec, sizevec = sizevec,
          ploidy = ploidy, seq = 0.001, bias = 0.5)

</code></pre>

<hr>
<h2 id='rgeno'>Simulate individual genotypes from one of the supported <code><a href="#topic+flexdog">flexdog</a></code> models.</h2><span id='topic+rgeno'></span>

<h3>Description</h3>

<p>This will simulate genotypes of a sample of individuals drawn from one of the populations supported by
<code><a href="#topic+flexdog">flexdog</a></code>. See the details of <code><a href="#topic+flexdog">flexdog</a></code> for the models allowed. These genotype
distributions are described in detail in Gerard and Ferrão (2020).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rgeno(
  n,
  ploidy,
  model = c("hw", "bb", "norm", "f1", "s1", "flex", "uniform"),
  allele_freq = NULL,
  od = NULL,
  p1geno = NULL,
  p2geno = NULL,
  pivec = NULL,
  mu = NULL,
  sigma = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rgeno_+3A_n">n</code></td>
<td>
<p>The number of observations.</p>
</td></tr>
<tr><td><code id="rgeno_+3A_ploidy">ploidy</code></td>
<td>
<p>The ploidy of the species.</p>
</td></tr>
<tr><td><code id="rgeno_+3A_model">model</code></td>
<td>
<p>What form should the prior take? See Details in <code><a href="#topic+flexdog">flexdog</a></code>.</p>
</td></tr>
<tr><td><code id="rgeno_+3A_allele_freq">allele_freq</code></td>
<td>
<p>If <code>model = "hw"</code>, then this is the allele frequency of the population.
For any other model, this should be <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="rgeno_+3A_od">od</code></td>
<td>
<p>If <code>model = "bb"</code>, then this is the overdispersion parameter of the beta-binomial
distribution. See <code><a href="#topic+betabinom">betabinom</a></code> for details. For any other model, this should be
<code>NULL</code>.</p>
</td></tr>
<tr><td><code id="rgeno_+3A_p1geno">p1geno</code></td>
<td>
<p>Either the first parent's genotype if <code>model = "f1"</code>,
or the only parent's
genotype if <code>model = "s1"</code>.
For any other model, this should be <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="rgeno_+3A_p2geno">p2geno</code></td>
<td>
<p>The second parent's genotype if <code>model = "f1"</code>.
For any other model, this should be <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="rgeno_+3A_pivec">pivec</code></td>
<td>
<p>A vector of probabilities. If <code>model = "ash"</code>, then this represents
the mixing proportions of the discrete uniforms. If
<code>model = "flex"</code>, then element <code>i</code> is the probability of genotype <code>i - 1</code>.
For any other model, this should be <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="rgeno_+3A_mu">mu</code></td>
<td>
<p>If <code>model = "norm"</code>, this is the mean of the normal.
For any other model, this should be <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="rgeno_+3A_sigma">sigma</code></td>
<td>
<p>If <code>model = "norm"</code>, this is the standard deviation of the normal.
For any other model, this should be <code>NULL</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>List of non-<code>NULL</code> arguments:
</p>

<dl>
<dt><code>model = "flex"</code>:</dt><dd><p><code>pivec</code></p>
</dd>
<dt><code>model = "hw"</code>:</dt><dd><p><code>allele_freq</code></p>
</dd>
<dt><code>model = "f1"</code>:</dt><dd><p><code>p1geno</code> and <code>p2geno</code></p>
</dd>
<dt><code>model = "s1"</code>:</dt><dd><p><code>p1geno</code></p>
</dd>
<dt><code>model = "uniform"</code>:</dt><dd><p>no non-<code>NULL</code> arguments</p>
</dd>
<dt><code>model = "bb"</code>:</dt><dd><p><code>allele_freq</code> and <code>od</code></p>
</dd>
<dt><code>model == "norm"</code>:</dt><dd><p><code>mu</code> and <code>sigma</code></p>
</dd>
</dl>



<h3>Value</h3>

<p>A vector of length <code>n</code> with the genotypes of the sampled individuals.
</p>


<h3>Author(s)</h3>

<p>David Gerard
</p>


<h3>References</h3>


<ul>
<li><p>Gerard, D., Ferrão, L. F. V., Garcia, A. A. F., &amp; Stephens, M. (2018). Genotyping Polyploids from Messy Sequencing Data. <em>Genetics</em>, 210(3), 789-807. <a href="https://doi.org/10.1534/genetics.118.301468">doi:10.1534/genetics.118.301468</a>.
</p>
</li>
<li><p>Gerard, David, and Luís Felipe Ventorim Ferrão. &quot;Priors for genotyping polyploids.&quot; Bioinformatics 36, no. 6 (2020): 1795-1800. <a href="https://doi.org/10.1093/bioinformatics/btz852">doi:10.1093/bioinformatics/btz852</a>.
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>## F1 Population where parent 1 has 1 copy of the referenc allele
## and parent 2 has 4 copies of the reference allele.
ploidy &lt;- 6
rgeno(n = 10, ploidy = ploidy, model = "f1", p1geno = 1, p2geno = 4)

## A population in Hardy-Weinberge equilibrium with an
## allele frequency of 0.75
rgeno(n = 10, ploidy = ploidy, model = "hw", allele_freq = 0.75)

</code></pre>

<hr>
<h2 id='snpdat'>GBS data from Shirasawa et al (2017)</h2><span id='topic+snpdat'></span>

<h3>Description</h3>

<p>Contains counts of reference alleles and total read counts from the GBS data of Shirasawa et al (2017) for
the three SNPs used as examples in Gerard et. al. (2018).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>snpdat
</code></pre>


<h3>Format</h3>

<p>A <code>tibble</code> with 419 rows and 4 columns:
</p>

<dl>
<dt>id</dt><dd><p>The identification label of the individuals.</p>
</dd>
<dt>snp</dt><dd><p>The SNP label.</p>
</dd>
<dt>counts</dt><dd><p>The number of read-counts that support the reference allele.</p>
</dd>
<dt>size</dt><dd><p>The total number of read-counts at a given SNP.</p>
</dd>
</dl>



<h3>Value</h3>

<p>A <code>tibble</code>. See the Format Section.
</p>


<h3>Source</h3>

<p><a href="https://doi.org/10.1038/srep44207">doi:10.1038/srep44207</a>
</p>


<h3>References</h3>


<ul>
<li><p>Shirasawa, Kenta, Masaru Tanaka, Yasuhiro Takahata, Daifu Ma, Qinghe Cao, Qingchang Liu, Hong Zhai, Sang-Soo Kwak, Jae Cheol Jeong, Ung-Han Yoon, Hyeong-Un Lee, Hideki Hirakawa, and Sahiko Isobe &quot;A high-density SNP genetic map consisting of a complete set of homologous groups in autohexaploid sweetpotato (Ipomoea batatas).&quot; <em>Scientific Reports 7</em> (2017). <a href="https://doi.org/10.1038/srep44207">doi:10.1038/srep44207</a>
</p>
</li>
<li><p>Gerard, D., Ferrão, L. F. V., Garcia, A. A. F., &amp; Stephens, M. (2018). Genotyping Polyploids from Messy Sequencing Data. <em>Genetics</em>, 210(3), 789-807. <a href="https://doi.org/10.1534/genetics.118.301468">doi:10.1534/genetics.118.301468</a>.
</p>
</li></ul>


<hr>
<h2 id='uitdewilligen'>Subset of individuals and SNPs from Uitdewilligen et al (2013).</h2><span id='topic+uitdewilligen'></span>

<h3>Description</h3>

<p>A list containing a matrix of reference counts, a matrix of total counts, and the ploidy level (4) of the species.
This is a subset of the data from Uitdewilligen et al (2013).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>uitdewilligen
</code></pre>


<h3>Format</h3>

<p>A list containing three objects. Two matrices and a numeric scalar:
</p>

<dl>
<dt>refmat</dt><dd><p>A matrix of read counts containing the reference allele. The rows index the individuals and the columns index the SNPs.</p>
</dd>
<dt>sizemat</dt><dd><p>A matrix of the total number of read counts. The rows index the individuals and the columns index the SNPs.</p>
</dd>
<dt>ploidy</dt><dd><p>The ploidy level of the species (just 4).</p>
</dd>
</dl>



<h3>Value</h3>

<p>A list. See the Format Section.
</p>


<h3>Source</h3>

<p><a href="https://doi.org/10.1371/journal.pone.0062355">doi:10.1371/journal.pone.0062355</a>
</p>


<h3>References</h3>


<ul>
<li><p>Uitdewilligen, J. G., Wolters, A. M. A., Bjorn, B., Borm, T. J., Visser, R. G., &amp; van Eck, H. J. (2013). A next-generation sequencing method for genotyping-by-sequencing of highly heterozygous autotetraploid potato. <em>PLoS One</em>, 8(5), e62355. <a href="https://doi.org/10.1371/journal.pone.0062355">doi:10.1371/journal.pone.0062355</a>
</p>
</li></ul>


<hr>
<h2 id='wem'>EM algorithm to fit weighted ash objective.</h2><span id='topic+wem'></span>

<h3>Description</h3>

<p>Solves the following optimization problem
</p>
<p style="text-align: center;"><code class="reqn">\max_{\pi} \sum_k w_k \log(\sum_j \pi_j \ell_jk).</code>
</p>

<p>It does this using a weighted EM algorithm.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>wem(weight_vec, lmat, pi_init, lambda, itermax, obj_tol)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="wem_+3A_weight_vec">weight_vec</code></td>
<td>
<p>A vector of weights. Each element of <code>weight_vec</code> corresponds
to a column of <code>lmat</code>.</p>
</td></tr>
<tr><td><code id="wem_+3A_lmat">lmat</code></td>
<td>
<p>A matrix of inner weights. The columns are the &quot;individuals&quot; and the rows are the &quot;classes.&quot;</p>
</td></tr>
<tr><td><code id="wem_+3A_pi_init">pi_init</code></td>
<td>
<p>The initial values of <code>pivec</code>. Each element of <code>pi_init</code>
corresponds to a row of <code>lmat</code>.</p>
</td></tr>
<tr><td><code id="wem_+3A_lambda">lambda</code></td>
<td>
<p>The penalty on the pi's. Should be greater than 0 and really really small.</p>
</td></tr>
<tr><td><code id="wem_+3A_itermax">itermax</code></td>
<td>
<p>The maximum number of EM iterations to take.</p>
</td></tr>
<tr><td><code id="wem_+3A_obj_tol">obj_tol</code></td>
<td>
<p>The objective stopping criterion.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector of numerics.
</p>


<h3>Author(s)</h3>

<p>David Gerard
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(2)
n &lt;- 3
p &lt;- 5
lmat &lt;- matrix(stats::runif(n * p), nrow = n)
weight_vec &lt;- seq_len(p)
pi_init &lt;- stats::runif(n)
pi_init &lt;- pi_init / sum(pi_init)
wem(weight_vec = weight_vec,
    lmat       = lmat,
    pi_init    = pi_init,
    lambda     = 0,
    itermax    = 100,
    obj_tol    = 10^-6)


</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
