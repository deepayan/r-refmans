<!DOCTYPE html><html><head><title>Help for package SimBIID</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {SimBIID}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#SimBIID-package'><p>Simulation-based inference for infectious disease models</p></a></li>
<li><a href='#ABCRef'><p>Produces ABC reference table</p></a></li>
<li><a href='#ABCSMC'><p>Runs ABC-SMC algorithm</p></a></li>
<li><a href='#compileRcpp'><p>Compiles <code>SimBIID_model</code> object</p></a></li>
<li><a href='#ebola'><p>Time series counts of ebola cases</p></a></li>
<li><a href='#mparseRcpp'><p>Parse custom model using <code>SimInf</code> style markup</p></a></li>
<li><a href='#plot.ABCSMC'><p>Plots <code>ABCSMC</code> objects</p></a></li>
<li><a href='#plot.PMCMC'><p>Plots <code>PMCMC</code> objects</p></a></li>
<li><a href='#plot.SimBIID_runs'><p>Plots <code>SimBIID_runs</code> objects</p></a></li>
<li><a href='#PMCMC'><p>Runs particle MCMC algorithm</p></a></li>
<li><a href='#predict.PMCMC'><p>Predicts future course of outbreak from <code>PMCMC</code> objects</p></a></li>
<li><a href='#print.ABCSMC'><p>Prints <code>ABCSMC</code> objects</p></a></li>
<li><a href='#print.PMCMC'><p>Prints <code>PMCMC</code> objects</p></a></li>
<li><a href='#print.SimBIID_model'><p>Prints <code>SimBIID_model</code> objects</p></a></li>
<li><a href='#print.SimBIID_runs'><p>Prints <code>SimBIID_runs</code> objects</p></a></li>
<li><a href='#run'><p>Runs <code>SimBIID_model</code> object</p></a></li>
<li><a href='#smallpox'><p>Time series counts of smallpox cases</p></a></li>
<li><a href='#summary.ABCSMC'><p>Summarises <code>ABCSMC</code> objects</p></a></li>
<li><a href='#summary.PMCMC'><p>Summarises <code>PMCMC</code> objects</p></a></li>
<li><a href='#window.PMCMC'><p>Time windows for <code>PMCMC</code> objects</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Title:</td>
<td>Simulation-Based Inference Methods for Infectious Disease Models</td>
</tr>
<tr>
<td>Version:</td>
<td>0.2.1</td>
</tr>
<tr>
<td>Description:</td>
<td>Provides some code to run simulations of state-space models, and then
             use these in the Approximate Bayesian Computation Sequential Monte Carlo (ABC-SMC) 
             algorithm of Toni et al. (2009) &lt;<a href="https://doi.org/10.1098%2Frsif.2008.0172">doi:10.1098/rsif.2008.0172</a>&gt; and a bootstrap particle
             filter based particle Markov chain Monte Carlo (PMCMC) algorithm 
             (Andrieu et al., 2010 &lt;<a href="https://doi.org/10.1111%2Fj.1467-9868.2009.00736.x">doi:10.1111/j.1467-9868.2009.00736.x</a>&gt;). 
             Also provides functions to plot and summarise the outputs.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL (&ge; 3)</a></td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/tjmckinley/SimBIID">https://github.com/tjmckinley/SimBIID</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/tjmckinley/SimBIID/issues">https://github.com/tjmckinley/SimBIID/issues</a></td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.5)</td>
</tr>
<tr>
<td>Imports:</td>
<td>stats, dplyr, purrr, tibble, ggplot2, tidyr, mvtnorm,
grDevices, RColorBrewer, Rcpp, RcppXPtrUtils, coda</td>
</tr>
<tr>
<td>Suggests:</td>
<td>parallel, GGally, testthat</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>Rcpp, RcppArmadillo</td>
</tr>
<tr>
<td>Config/testthat/edition:</td>
<td>3</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.1.0</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2021-02-03 23:15:00 UTC; tj</td>
</tr>
<tr>
<td>Author:</td>
<td>Trevelyan J. McKinley [aut, cre],
  Stefan Widgren [aut] (Author of 'R/mparse.R'),
  Pavol Bauer [cph] (R/mparse.R),
  Robin Eriksson [cph] (R/mparse.R),
  Stefan Engblom [cph] (R/mparse.R)</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Trevelyan J. McKinley &lt;t.mckinley@exeter.ac.uk&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2021-02-04 05:20:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='SimBIID-package'>Simulation-based inference for infectious disease models</h2><span id='topic+SimBIID-package'></span>

<h3>Description</h3>

<p>Package implements various simulation-based inference routines for infectious
disease models.
</p>


<h3>Details</h3>

<p>Provides some code to run simulations of state-space models, and then
use these in the Approximate Bayesian Computation Sequential Monte Carlo (ABC-SMC) 
algorithm of Toni et al. (2009) &lt;doi:10.1098/rsif.2008.0172&gt; and a bootstrap particle
filter based particle Markov chain Monte Carlo (PMCMC) algorithm 
(Andrieu et al., 2010 &lt;doi:10.1111/j.1467-9868.2009.00736.x&gt;). 
Also provides functions to plot and summarise the outputs.
</p>


<h3>Author(s)</h3>

<p>Trevelyan J. McKinley &lt;t.mckinley@exeter.ac.uk&gt;
</p>

<hr>
<h2 id='ABCRef'>Produces ABC reference table</h2><span id='topic+ABCRef'></span>

<h3>Description</h3>

<p>Produces reference table of simulated outcomes for use in various
Approximate Bayesian Computation (ABC) algorithms.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ABCRef(
  npart,
  priors,
  pars,
  func,
  sumNames,
  parallel = FALSE,
  mc.cores = NA,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ABCRef_+3A_npart">npart</code></td>
<td>
<p>The number of particles (must be a positive integer).</p>
</td></tr>
<tr><td><code id="ABCRef_+3A_priors">priors</code></td>
<td>
<p>A <code>data.frame</code> containing columns <code>parnames</code>, <code>dist</code>, <code>p1</code> and 
<code>p2</code>, with number of rows equal to the number of parameters. The column
<code>parname</code> simply gives names to each parameter for plotting and summarising.
Each entry in the <code>dist</code> column must contain one of <code>c("unif", "norm", "gamma")</code>, 
and the corresponding <code>p1</code> and <code>p2</code> entries relate to the hyperparameters 
(lower and upper bounds in the uniform case; mean and standard deviation in the 
normal case; and shape and rate in the gamma case).</p>
</td></tr>
<tr><td><code id="ABCRef_+3A_pars">pars</code></td>
<td>
<p>A named vector or matrix of parameters to use for the simulations. If <code>pars</code> is a vector then
this is repeated 'npart' times, else it must be a <code>matrix</code> with 'npart' rows. 
You cannot specify both 'pars' and 'priors'.</p>
</td></tr>
<tr><td><code id="ABCRef_+3A_func">func</code></td>
<td>
<p>Function that runs the simulator. The first argument must be <code>pars</code>. The function
must return a <code>vector</code> of simulated summary measures, or a missing value (<code>NA</code>)
if there is an error. The output from the function must be a vector with length equal 
to <code>length(sumNames)</code>.</p>
</td></tr>
<tr><td><code id="ABCRef_+3A_sumnames">sumNames</code></td>
<td>
<p>A <code>character</code> vector of summary statistic names.</p>
</td></tr>
<tr><td><code id="ABCRef_+3A_parallel">parallel</code></td>
<td>
<p>A <code>logical</code> determining whether to use parallel processing or not.</p>
</td></tr>
<tr><td><code id="ABCRef_+3A_mc.cores">mc.cores</code></td>
<td>
<p>Number of cores to use if using parallel processing.</p>
</td></tr>
<tr><td><code id="ABCRef_+3A_...">...</code></td>
<td>
<p>Extra arguments to be passed to <code>func</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Runs simulations for a large number of particles, either pre-specified or
sampled from the a set of given prior distributions. Returns a table of summary 
statistics for each particle. Useful for deciding on initial tolerances during an
<code><a href="#topic+ABCSMC">ABCSMC</a></code> run, or for producing a reference table to use in e.g. the 
ABC with Random Forests approach of Raynal et al. (2017).
</p>


<h3>Value</h3>

<p>An <code>data.frame</code> object with <code>npart</code> rows, where the first <code>p</code> columns correspond to 
the proposed parameters, and the remaining columns correspond to the simulated outputs.
</p>


<h3>References</h3>

<p>Raynal, L, Marin J-M, Pudlo P, Ribatet M, Robert CP and Estoup A. (2017) &lt;ArXiv:1605.05537&gt;
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## set up SIR simulation model
transitions &lt;- c(
    "S -&gt; beta * S * I -&gt; I", 
    "I -&gt; gamma * I -&gt; R"
)
compartments &lt;- c("S", "I", "R")
pars &lt;- c("beta", "gamma")
model &lt;- mparseRcpp(
    transitions = transitions, 
    compartments = compartments,
    pars = pars
)
model &lt;- compileRcpp(model)

## generate function to run simulators
## and produce final epidemic size and time
## summary statistics
simRef &lt;- function(pars, model) {
    ## run model over a 100 day period with
    ## one initial infective in a population
    ## of 120 individuals
    sims &lt;- model(pars, 0, 100, c(119, 1, 0))
    
    ## return vector of summary statistics
    c(finaltime = sims[2], finalsize = sims[5])
}

## set priors
priors &lt;- data.frame(
    parnames = c("beta", "gamma"), 
    dist = rep("gamma", 2), 
    stringsAsFactors = FALSE
)
priors$p1 &lt;- c(10, 10)
priors$p2 &lt;- c(10^4, 10^2)

## produce reference table by sampling from priors
## (add additional arguments to 'func' at the end)
refTable &lt;- ABCRef(
    npart = 100, 
    priors = priors, 
    func = simRef, 
    sumNames = c("finaltime", "finalsize"),
    model = model
)
refTable


</code></pre>

<hr>
<h2 id='ABCSMC'>Runs ABC-SMC algorithm</h2><span id='topic+ABCSMC'></span><span id='topic+ABCSMC.ABCSMC'></span><span id='topic+ABCSMC.default'></span>

<h3>Description</h3>

<p>Runs the Approximate Bayesian Computation Sequential Monte Carlo 
(ABC-SMC) algorithm of Toni et al. (2009) for fitting 
infectious disease models to time series count data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ABCSMC(x, ...)

## S3 method for class 'ABCSMC'
ABCSMC(
  x,
  tols = NULL,
  ptols = NULL,
  mintols = NULL,
  ngen = 1,
  parallel = FALSE,
  mc.cores = NA,
  ...
)

## Default S3 method:
ABCSMC(
  x,
  priors,
  func,
  u,
  tols = NULL,
  ptols = NULL,
  mintols = NULL,
  ngen = 1,
  npart = 100,
  parallel = FALSE,
  mc.cores = NA,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ABCSMC_+3A_x">x</code></td>
<td>
<p>An <code>ABCSMC</code> object or a named vector with entries
containing the observed summary statistics to match to. Names must match to 'tols'.</p>
</td></tr>
<tr><td><code id="ABCSMC_+3A_...">...</code></td>
<td>
<p>Further arguments to pass to <code>func</code>. (Not used if extending runs.)</p>
</td></tr>
<tr><td><code id="ABCSMC_+3A_tols">tols</code></td>
<td>
<p>A <code>vector</code> or <code>matrix</code> of tolerances, with the number of rows defining
the number of generations required, and columns defining the summary statistics
to match to. If a <code>vector</code>, then the length determines the summary statistics.
The columns/entries must match to those in 'x'.</p>
</td></tr>
<tr><td><code id="ABCSMC_+3A_ptols">ptols</code></td>
<td>
<p>The proportion of simulated outcomes at each generation to use to derive adaptive 
tolerances.</p>
</td></tr>
<tr><td><code id="ABCSMC_+3A_mintols">mintols</code></td>
<td>
<p>A vector of minimum tolerance levels.</p>
</td></tr>
<tr><td><code id="ABCSMC_+3A_ngen">ngen</code></td>
<td>
<p>The number of generations of ABC-SMC to run.</p>
</td></tr>
<tr><td><code id="ABCSMC_+3A_parallel">parallel</code></td>
<td>
<p>A <code>logical</code> determining whether to use parallel processing or not.</p>
</td></tr>
<tr><td><code id="ABCSMC_+3A_mc.cores">mc.cores</code></td>
<td>
<p>Number of cores to use if using parallel processing.</p>
</td></tr>
<tr><td><code id="ABCSMC_+3A_priors">priors</code></td>
<td>
<p>A <code>data.frame</code> containing columns <code>parnames</code>, <code>dist</code>, <code>p1</code> and 
<code>p2</code>, with number of rows equal to the number of parameters. The column
<code>parname</code> simply gives names to each parameter for plotting and summarising.
Each entry in the <code>dist</code> column must contain one of <code>c("unif", "norm", "gamma")</code>, 
and the corresponding <code>p1</code> and <code>p2</code> entries relate to the hyperparameters 
(lower and upper bounds in the uniform case; mean and standard deviation in the 
normal case; and shape and rate in the gamma case).</p>
</td></tr>
<tr><td><code id="ABCSMC_+3A_func">func</code></td>
<td>
<p>Function that runs the simulator and checks whether the simulation matches the data. 
The first four arguments must be <code>pars</code>, <code>data</code>, <code>tols</code> and 
<code>u</code>. If the simulations do not match the data then the function must 
return an <code>NA</code>, else it must returns a <code>vector</code> of simulated summary measures. 
In this latter case the output from the function must be a vector with length equal to 
<code>ncol(data)</code> and with entries in the same order as the columns of <code>data</code>.</p>
</td></tr>
<tr><td><code id="ABCSMC_+3A_u">u</code></td>
<td>
<p>A named vector of initial states.</p>
</td></tr>
<tr><td><code id="ABCSMC_+3A_npart">npart</code></td>
<td>
<p>An integer specifying the number of particles.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Samples initial particles from the specified prior distributions and 
then runs a series of generations of ABC-SMC. The generations can either be 
specified with a set of fixed tolerances, or by setting the tolerances at 
each new generation as a quantile of the tolerances of the accepted particles 
at the previous generation. Uses bisection method as detailed in McKinley et al. (2018).
Passing an <code>ABCSMC</code> object into the <code>ABCSMC()</code> function acts as a 
continuation method, allowing further generations to be run.
</p>


<h3>Value</h3>

<p>An <code>ABCSMC</code> object, essentially a <code>list</code> containing:
</p>

<ul>
<li><p><code>pars</code>: a <code>list</code> of <code>matrix</code> objects containing the accepted
particles. Each element of the list corresponds to a generation 
of ABC-SMC, with each matrix being of dimension 
<code>npart</code> x <code>npars</code>;
</p>
</li>
<li><p><code>output</code>: a <code>list</code> of <code>matrix</code> objects containing the simulated
summary statistics. Each element of the list corresponds to a
generation of ABC-SMC, with each matrix being of dimension 
<code>npart</code> x <code>ncol(data)</code>;
</p>
</li>
<li><p><code>weights</code>: a <code>list</code> of <code>vector</code> objects containing the particle
weights. Each element of the list corresponds to a
generation of ABC-SMC, with each vector being of length
<code>npart</code>;
</p>
</li>
<li><p><code>ESS</code>: a <code>list</code> of effective sample sizes. Each element of the list 
corresponds to a generation of ABC-SMC, with each vector being of 
length <code>npart</code>;
</p>
</li>
<li><p><code>accrate</code>: a <code>vector</code> of length <code>nrow(tols)</code> containing the
acceptance rates for each generation of ABC;
</p>
</li>
<li><p><code>tols</code>: a copy of the <code>tols</code> input;
</p>
</li>
<li><p><code>ptols</code>: a copy of the <code>ptols</code> input;
</p>
</li>
<li><p><code>mintols</code>: a copy of the <code>mintols</code> input;
</p>
</li>
<li><p><code>priors</code>: a copy of the <code>priors</code> input;
</p>
</li>
<li><p><code>data</code>: a copy of the <code>data</code> input;
</p>
</li>
<li><p><code>func</code>: a copy of the <code>func</code> input;
</p>
</li>
<li><p><code>u</code> a copy of the <code>u</code> input;
</p>
</li>
<li><p><code>addargs</code>: a copy of the <code>...</code> inputs.
</p>
</li></ul>



<h3>References</h3>

<p>Toni T, Welch D, Strelkowa N, Ipsen A and Stumpf MP (2009) &lt;doi:10.1098/rsif.2008.0172&gt;
</p>
<p>McKinley TJ, Cook AR and Deardon R (2009) &lt;doi:10.2202/1557-4679.1171&gt;
</p>
<p>McKinley TJ, Vernon I, Andrianakis I, McCreesh N, Oakley JE, Nsubuga RN, Goldstein M and White RG (2018) &lt;doi:10.1214/17-STS618&gt;
</p>


<h3>See Also</h3>

<p><code><a href="#topic+print.ABCSMC">print.ABCSMC</a></code>, <code><a href="#topic+plot.ABCSMC">plot.ABCSMC</a></code>, <code><a href="#topic+summary.ABCSMC">summary.ABCSMC</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## set up SIR simulationmodel
transitions &lt;- c(
    "S -&gt; beta * S * I -&gt; I", 
    "I -&gt; gamma * I -&gt; R"
)
compartments &lt;- c("S", "I", "R")
pars &lt;- c("beta", "gamma")
model &lt;- mparseRcpp(
    transitions = transitions, 
    compartments = compartments,
    pars = pars
)
model &lt;- compileRcpp(model)

## generate function to run simulators
## and return summary statistics
simSIR &lt;- function(pars, data, tols, u, model) {

    ## run model
    sims &lt;- model(pars, 0, data[2] + tols[2], u)
    
    ## this returns a vector of the form:
    ## completed (1/0), t, S, I, R (here)
    if(sims[1] == 0) {
        ## if simulation rejected
        return(NA)
    } else {
        ## extract finaltime and finalsize
        finaltime &lt;- sims[2]
        finalsize &lt;- sims[5]
    }
    
    ## return vector if match, else return NA
    if(all(abs(c(finalsize, finaltime) - data) &lt;= tols)){
        return(c(finalsize, finaltime))
    } else {
        return(NA)
    }
}

## set priors
priors &lt;- data.frame(
    parnames = c("beta", "gamma"), 
    dist = rep("gamma", 2), 
    stringsAsFactors = FALSE
)
priors$p1 &lt;- c(10, 10)
priors$p2 &lt;- c(10^4, 10^2)

## define the targeted summary statistics
data &lt;- c(
    finalsize = 30, 
    finaltime = 76
)

## set initial states (1 initial infection 
## in population of 120)
iniStates &lt;- c(S = 119, I = 1, R = 0)

## set initial tolerances
tols &lt;- c(
    finalsize = 50,
    finaltime = 50
)

## run 2 generations of ABC-SMC
## setting tolerance to be 50th
## percentile of the accepted 
## tolerances at each generation
post &lt;- ABCSMC(
    x = data, 
    priors = priors, 
    func = simSIR, 
    u = iniStates, 
    tols = tols, 
    ptol = 0.2, 
    ngen = 2, 
    npart = 50,
    model = model
)
post

## run one further generation
post &lt;- ABCSMC(post, ptols = 0.5, ngen = 1)
post
summary(post)

## plot posteriors
plot(post)

## plot outputs
plot(post, "output")


</code></pre>

<hr>
<h2 id='compileRcpp'>Compiles <code>SimBIID_model</code> object</h2><span id='topic+compileRcpp'></span>

<h3>Description</h3>

<p>Compiles an object of class <code>SimBIID_model</code> into an
<code>XPtr</code> object for use in Rcpp functions, or an
object of class <code>function</code> for calling directly from R.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>compileRcpp(model)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="compileRcpp_+3A_model">model</code></td>
<td>
<p>An object of class <code>SimBIID_model</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <code>XPtr</code> that points to the compiled function, or
an R <code>function</code> object for calling directly from R.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+mparseRcpp">mparseRcpp</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## set up SIR simulationmodel
transitions &lt;- c(
    "S -&gt; beta * S * I -&gt; I", 
    "I -&gt; gamma * I -&gt; R"
)
compartments &lt;- c("S", "I", "R")
pars &lt;- c("beta", "gamma")
model &lt;- mparseRcpp(
    transitions = transitions, 
    compartments = compartments,
    pars = pars
)

## compile model to be run directly
model &lt;- compileRcpp(model)
model

## set initial states (1 initial infection 
## in population of 120)
iniStates &lt;- c(S = 119, I = 1, R = 0)

## set parameters
pars &lt;- c(beta = 0.001, gamma = 0.1)

## run compiled model
model(pars, 0, 100, iniStates)


</code></pre>

<hr>
<h2 id='ebola'>Time series counts of ebola cases</h2><span id='topic+ebola'></span>

<h3>Description</h3>

<p>A dataset containing time series counts for the number
of new individuals exhibiting clinical signs, and the number of
new removals each day for the 1995 Ebola epidemic in the Democratic
Republic of Congo
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ebola
</code></pre>


<h3>Format</h3>

<p>A data frame with 192 rows and 3 variables:
</p>

<dl>
<dt>time</dt><dd><p>days from 1st January 1995</p>
</dd>
<dt>clin_signs</dt><dd><p>number of new clinical cases at each day</p>
</dd>
<dt>removals</dt><dd><p>number of new removals at each day</p>
</dd>
</dl>



<h3>Source</h3>

<p>Khan AS et al. (1999) &lt;doi:10.1086/514306&gt;
</p>

<hr>
<h2 id='mparseRcpp'>Parse custom model using <code>SimInf</code> style markup</h2><span id='topic+mparseRcpp'></span>

<h3>Description</h3>

<p>Parse custom model using <code>SimInf</code> style markup.
Does not have full functionality of <code>mparse</code>. Currently only supports
simulations on a single node.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mparseRcpp(
  transitions = NULL,
  compartments = NULL,
  pars = NULL,
  obsProcess = NULL,
  addVars = NULL,
  stopCrit = NULL,
  tspan = FALSE,
  incidence = FALSE,
  afterTstar = NULL,
  PF = FALSE,
  runFromR = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mparseRcpp_+3A_transitions">transitions</code></td>
<td>
<p>character vector containing transitions on the form <code>"X -&gt;
... -&gt; Y"</code>. The left (right) side is the initial (final)
state and the propensity is written in between the
<code>-&gt;</code>-signs. The special symbol <code>@</code> is reserved for the empty
set. For example, <code>transitions = c("S -&gt; k1*S*I -&gt; I", "I -&gt;
k2*I -&gt; R")</code> expresses a SIR model.</p>
</td></tr>
<tr><td><code id="mparseRcpp_+3A_compartments">compartments</code></td>
<td>
<p>contains the names of the involved compartments, for
example, <code>compartments = c("S", "I", "R")</code>.</p>
</td></tr>
<tr><td><code id="mparseRcpp_+3A_pars">pars</code></td>
<td>
<p>a <code>character</code> vector containing the names of the parameters.</p>
</td></tr>
<tr><td><code id="mparseRcpp_+3A_obsprocess">obsProcess</code></td>
<td>
<p><code>data.frame</code> determining the observation process. Columns must be in the order:
<code>dataNames</code>, <code>dist</code>, <code>p1</code>, <code>p2</code>. <code>dataNames</code> is a <code>character</code>
denoting the name of the variable that will be output from the observation process; <code>dist</code> 
is a <code>character</code> specifying the distribution of the observation process (must be one of 
<code>"unif"</code>, <code>"pois"</code>, <code>"norm"</code> or <code>"binom"</code> at the current time); <code>p1</code> is the first parameter 
(the lower bound in the case of <code>"unif"</code>, the rate in the case of <code>"pois"</code>, the mean in the case of 
<code>"norm"</code> or the <code>size</code> in the case of <code>"binom"</code>); and finally <code>p2</code> is the second parameter 
(the upper bound in the case of <code>"unif"</code>, <code>NA</code> in the case of <code>"pois"</code>, the standard deviation in 
the case of <code>"norm"</code>, and <code>prob</code> in the case of <code>"binom"</code>).</p>
</td></tr>
<tr><td><code id="mparseRcpp_+3A_addvars">addVars</code></td>
<td>
<p>a <code>character</code> vector where the names specify the additional variables to be added to the 
function call. These can be used to specify variables that can be used for 
e.g. additional stopping criteria.</p>
</td></tr>
<tr><td><code id="mparseRcpp_+3A_stopcrit">stopCrit</code></td>
<td>
<p>A <code>character</code> vector including additional stopping criteria for rejecting
simulations early. These will be inserted within <code>if(CRIT){out[0] = 0; return out;}</code> statements
within the underlying Rcpp code, which a return value of 0 corresponds to rejecting
the simulation. Variables in <code>CRIT</code> must match either those in <code>compartments</code>
and/or <code>addVars</code>.</p>
</td></tr>
<tr><td><code id="mparseRcpp_+3A_tspan">tspan</code></td>
<td>
<p>A <code>logical</code> determining whether to return time series counts or not.</p>
</td></tr>
<tr><td><code id="mparseRcpp_+3A_incidence">incidence</code></td>
<td>
<p>A <code>logical</code> specifying whether to return incidence curves in addition to counts.</p>
</td></tr>
<tr><td><code id="mparseRcpp_+3A_aftertstar">afterTstar</code></td>
<td>
<p>A <code>character</code> containing code to insert after each new event time is
generated.</p>
</td></tr>
<tr><td><code id="mparseRcpp_+3A_pf">PF</code></td>
<td>
<p>A <code>logical</code> determining whether to compile the code for use in a particle filter.</p>
</td></tr>
<tr><td><code id="mparseRcpp_+3A_runfromr">runFromR</code></td>
<td>
<p><code>logical</code> determining whether code is to be compiled to run directly in R,
or whether to be compiled as an <code>XPtr</code> object for use in Rcpp.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Uses a <code>SimInf</code> style markup to create compartmental state-space
written using <code>Rcpp</code>. A helper <code>run</code> function exists to compile 
and run the model. Another helper function, <code>compileRcpp</code>,
can compile the model to produce a function that can be run directly from R, 
or compiled into an external pointer (using the <code>RcppXPtrUtils</code> package).
</p>


<h3>Value</h3>

<p>An object of class <code>SimBIID_model</code>, which is essentially a <code>list</code> 
containing elements:
</p>

<ul>
<li><p>code: parsed code to compile;
</p>
</li>
<li><p>transitions: copy of <code>transitions</code> argument;
</p>
</li>
<li><p>compartments: copy of <code>compartments</code> argument;
</p>
</li>
<li><p>pars: copy of <code>pars</code> argument;
</p>
</li>
<li><p>obsProcess: copy of <code>obsProcess</code> argument;
</p>
</li>
<li><p>stopCrit: copy of <code>stopCrit</code> argument;
</p>
</li>
<li><p>addVars: copy of <code>addVars</code> argument;
</p>
</li>
<li><p>tspan: copy of <code>tspan</code> argument;
</p>
</li>
<li><p>incidence: copy of <code>incidence</code> argument;
</p>
</li>
<li><p>afterTstar: copy of <code>afterTstar</code> argument;
</p>
</li>
<li><p>PF: copy of <code>PF</code> argument;
</p>
</li>
<li><p>runFromR: copy of <code>runFromR</code> argument.
</p>
</li></ul>

<p>This can be compiled into an <code>XPtr</code> or <code>function</code> object
using <code>compileRcpp()</code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+run">run</a></code>, <code><a href="#topic+compileRcpp">compileRcpp</a></code>, <code><a href="#topic+print.SimBIID_model">print.SimBIID_model</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

## set up SIR simulation model
transitions &lt;- c(
    "S -&gt; beta * S * I -&gt; I", 
    "I -&gt; gamma * I -&gt; R"
)
compartments &lt;- c("S", "I", "R")
pars &lt;- c("beta", "gamma")
model &lt;- mparseRcpp(
    transitions = transitions, 
    compartments = compartments,
    pars = pars
)

## compile and run model
sims &lt;- run(
    model = model,
    pars = c(beta = 0.001, gamma = 0.1),
    tstart = 0,
    tstop = 100,
    u = c(S = 119, I = 1, R = 0)
)
sims


</code></pre>

<hr>
<h2 id='plot.ABCSMC'>Plots <code>ABCSMC</code> objects</h2><span id='topic+plot.ABCSMC'></span>

<h3>Description</h3>

<p>Plot method for <code>ABCSMC</code> objects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'ABCSMC'
plot(
  x,
  type = c("post", "output"),
  gen = NA,
  joint = FALSE,
  transfunc = NA,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.ABCSMC_+3A_x">x</code></td>
<td>
<p>An <code>ABCSMC</code> object.</p>
</td></tr>
<tr><td><code id="plot.ABCSMC_+3A_type">type</code></td>
<td>
<p>Takes the value <code>"post"</code> if you want to plot posterior distributions.
Takes the value <code>"output"</code> if you want to plot the simulated outputs.</p>
</td></tr>
<tr><td><code id="plot.ABCSMC_+3A_gen">gen</code></td>
<td>
<p>A vector of generations to plot. If left missing then defaults to all generations.</p>
</td></tr>
<tr><td><code id="plot.ABCSMC_+3A_joint">joint</code></td>
<td>
<p>A logical describing whether joint or marginal distributions are wanted.</p>
</td></tr>
<tr><td><code id="plot.ABCSMC_+3A_transfunc">transfunc</code></td>
<td>
<p>Is a <code>function</code> object where the arguments to the function must
match all or a subset of the parameters in the model. This function needs 
to return a <code>data.frame</code> object with columns containing the transformed
parameters.</p>
</td></tr>
<tr><td><code id="plot.ABCSMC_+3A_...">...</code></td>
<td>
<p>Not used here.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A plot of the ABC posterior distributions for different generations, or the distributions
of the simulated summary measures for different generations.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+ABCSMC">ABCSMC</a></code>, <code><a href="#topic+print.ABCSMC">print.ABCSMC</a></code>, <code><a href="#topic+summary.ABCSMC">summary.ABCSMC</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

## set up SIR simulation model
transitions &lt;- c(
    "S -&gt; beta * S * I -&gt; I", 
    "I -&gt; gamma * I -&gt; R"
)
compartments &lt;- c("S", "I", "R")
pars &lt;- c("beta", "gamma")
model &lt;- mparseRcpp(
    transitions = transitions, 
    compartments = compartments,
    pars = pars
)
model &lt;- compileRcpp(model)

## generate function to run simulators
## and return summary statistics
simSIR &lt;- function(pars, data, tols, u, model) {

    ## run model
    sims &lt;- model(pars, 0, data[2] + tols[2], u)
    
    ## this returns a vector of the form:
    ## completed (1/0), t, S, I, R (here)
    if(sims[1] == 0) {
        ## if simulation rejected
        return(NA)
    } else {
        ## extract finaltime and finalsize
        finaltime &lt;- sims[2]
        finalsize &lt;- sims[5]
    }
    
    ## return vector if match, else return NA
    if(all(abs(c(finalsize, finaltime) - data) &lt;= tols)){
        return(c(finalsize, finaltime))
    } else {
        return(NA)
    }
}

## set priors
priors &lt;- data.frame(
    parnames = c("beta", "gamma"), 
    dist = rep("gamma", 2), 
    stringsAsFactors = FALSE
)
priors$p1 &lt;- c(10, 10)
priors$p2 &lt;- c(10^4, 10^2)

## define the targeted summary statistics
data &lt;- c(
    finalsize = 30, 
    finaltime = 76
)

## set initial states (1 initial infection 
## in population of 120)
iniStates &lt;- c(S = 119, I = 1, R = 0)

## set initial tolerances
tols &lt;- c(
    finalsize = 50,
    finaltime = 50
)

## run 2 generations of ABC-SMC
## setting tolerance to be 50th
## percentile of the accepted 
## tolerances at each generation
post &lt;- ABCSMC(
    x = data, 
    priors = priors, 
    func = simSIR, 
    u = iniStates, 
    tols = tols, 
    ptol = 0.2, 
    ngen = 2, 
    npart = 50,
    model = model
)
post

## run one further generation
post &lt;- ABCSMC(post, ptols = 0.5, ngen = 1)
post
summary(post)

## plot posteriors
plot(post)

## plot outputs
plot(post, "output")


</code></pre>

<hr>
<h2 id='plot.PMCMC'>Plots <code>PMCMC</code> objects</h2><span id='topic+plot.PMCMC'></span>

<h3>Description</h3>

<p>Plot method for <code>PMCMC</code> objects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'PMCMC'
plot(
  x,
  type = c("post", "trace"),
  joint = FALSE,
  transfunc = NA,
  ask = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.PMCMC_+3A_x">x</code></td>
<td>
<p>A <code>PMCMC</code> object.</p>
</td></tr>
<tr><td><code id="plot.PMCMC_+3A_type">type</code></td>
<td>
<p>Takes the value <code>"post"</code> if you want to plot posterior distributions.
Takes the value <code>"trace"</code> if you want to plot the trace plots.</p>
</td></tr>
<tr><td><code id="plot.PMCMC_+3A_joint">joint</code></td>
<td>
<p>A logical describing whether joint or marginal distributions are wanted.</p>
</td></tr>
<tr><td><code id="plot.PMCMC_+3A_transfunc">transfunc</code></td>
<td>
<p>Is a <code>function</code> object where the arguments to the function must
match all or a subset of the parameters in the model. This function needs 
to return a <code>data.frame</code> object with columns containing the transformed
parameters.</p>
</td></tr>
<tr><td><code id="plot.PMCMC_+3A_ask">ask</code></td>
<td>
<p>Should the user ask before moving onto next trace plot.</p>
</td></tr>
<tr><td><code id="plot.PMCMC_+3A_...">...</code></td>
<td>
<p>Not used here.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A plot of the (approximate) posterior distributions obtained from fitting a particle 
Markov chain Monte Carlo algorithm, or provides corresponding trace plots.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+PMCMC">PMCMC</a></code>, <code><a href="#topic+print.PMCMC">print.PMCMC</a></code>, <code><a href="#topic+predict.PMCMC">predict.PMCMC</a></code>, <code><a href="#topic+summary.PMCMC">summary.PMCMC</a></code>
<code><a href="#topic+window.PMCMC">window.PMCMC</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

## set up data to pass to PMCMC
flu_dat &lt;- data.frame(
    t = 1:14,
    Robs = c(3, 8, 26, 76, 225, 298, 258, 233, 189, 128, 68, 29, 14, 4)
)

## set up observation process
obs &lt;- data.frame(
    dataNames = "Robs",
    dist = "pois",
    p1 = "R + 1e-5",
    p2 = NA,
    stringsAsFactors = FALSE
)

## set up model (no need to specify tspan
## argument as it is set in PMCMC())
transitions &lt;- c(
    "S -&gt; beta * S * I / (S + I + R + R1) -&gt; I", 
    "I -&gt; gamma * I -&gt; R",
    "R -&gt; gamma1 * R -&gt; R1"
)
compartments &lt;- c("S", "I", "R", "R1")
pars &lt;- c("beta", "gamma", "gamma1")
model &lt;- mparseRcpp(
    transitions = transitions, 
    compartments = compartments,
    pars = pars,
    obsProcess = obs
)

## set priors
priors &lt;- data.frame(
    parnames = c("beta", "gamma", "gamma1"), 
    dist = rep("unif", 3), 
    stringsAsFactors = FALSE)
priors$p1 &lt;- c(0, 0, 0)
priors$p2 &lt;- c(5, 5, 5)

## define initial states
iniStates &lt;- c(S = 762, I = 1, R = 0, R1 = 0)

set.seed(50)

## run PMCMC algorithm
post &lt;- PMCMC(
    x = flu_dat, 
    priors = priors,
    func = model, 
    u = iniStates,
    npart = 25,
    niter = 5000, 
    nprintsum = 1000
)

## plot MCMC traces
plot(post, "trace")

## continue for some more iterations
post &lt;- PMCMC(post, niter = 5000, nprintsum = 1000)

## plot traces and posteriors
plot(post, "trace")
plot(post)

## remove burn-in
post &lt;- window(post, start = 5000)

## summarise posteriors
summary(post)


</code></pre>

<hr>
<h2 id='plot.SimBIID_runs'>Plots <code>SimBIID_runs</code> objects</h2><span id='topic+plot.SimBIID_runs'></span>

<h3>Description</h3>

<p>Plot method for <code>SimBIID_runs</code> objects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'SimBIID_runs'
plot(
  x,
  which = c("all", "t"),
  type = c("runs", "sums"),
  rep = NA,
  quant = 0.9,
  data = NULL,
  matchData = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.SimBIID_runs_+3A_x">x</code></td>
<td>
<p>An <code>SimBIID_runs</code> object.</p>
</td></tr>
<tr><td><code id="plot.SimBIID_runs_+3A_which">which</code></td>
<td>
<p>A character vector of states to plot. Can be <code>"all"</code> to plot all
states (and final event times), or <code>"t"</code> to plot final event times.</p>
</td></tr>
<tr><td><code id="plot.SimBIID_runs_+3A_type">type</code></td>
<td>
<p>Character stating whether to plot full simulations over time (<code>"runs"</code>) or
summaries (<code>"sums"</code>).</p>
</td></tr>
<tr><td><code id="plot.SimBIID_runs_+3A_rep">rep</code></td>
<td>
<p>An integer vector of simulation runs to plot.</p>
</td></tr>
<tr><td><code id="plot.SimBIID_runs_+3A_quant">quant</code></td>
<td>
<p>A vector of quantiles (&gt; 0.5) to plot if <code>type == "runs"</code>.</p>
</td></tr>
<tr><td><code id="plot.SimBIID_runs_+3A_data">data</code></td>
<td>
<p>A <code>data.frame</code> containing time series count data, 
with the first column called <code>t</code>, followed by columns of time-series counts.</p>
</td></tr>
<tr><td><code id="plot.SimBIID_runs_+3A_matchdata">matchData</code></td>
<td>
<p>A character vector containing matches between the columns of <code>data</code> and
the columns of the model runs. Each entry must be of the form e.g. <code>"SD = SR"</code>,
where <code>SD</code> is the name of the column in <code>data</code>, and <code>SR</code> is the name
of the column in <code>x</code>.</p>
</td></tr>
<tr><td><code id="plot.SimBIID_runs_+3A_...">...</code></td>
<td>
<p>Not used here.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A plot of individual simulations and/or summaries of repeated simulations 
extracted from <code>SimBIID_runs</code> object.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+mparseRcpp">mparseRcpp</a></code>, <code><a href="#topic+print.SimBIID_runs">print.SimBIID_runs</a></code>, <code><a href="#topic+run">run</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## set up SIR simulation model
transitions &lt;- c(
    "S -&gt; beta * S * I -&gt; I", 
    "I -&gt; gamma * I -&gt; R"
)
compartments &lt;- c("S", "I", "R")
pars &lt;- c("beta", "gamma")
model &lt;- mparseRcpp(
    transitions = transitions, 
    compartments = compartments,
    pars = pars,
    tspan = TRUE
)

## run 100 replicate simulations and
## plot outputs
sims &lt;- run(
    model = model,
    pars = c(beta = 0.001, gamma = 0.1),
    tstart = 0,
    tstop = 100,
    u = c(S = 119, I = 1, R = 0),
    tspan = seq(1, 100, length.out = 10),
    nrep = 100
)
plot(sims, quant = c(0.55, 0.75, 0.9))

## add replicate 1 to plot
plot(sims, quant = c(0.55, 0.75, 0.9), rep = 1)


</code></pre>

<hr>
<h2 id='PMCMC'>Runs particle MCMC algorithm</h2><span id='topic+PMCMC'></span><span id='topic+PMCMC.PMCMC'></span><span id='topic+PMCMC.default'></span>

<h3>Description</h3>

<p>Runs particle Markov chain Monte Carlo (PMCMC) algorithm using 
a bootstrap particle filter for fitting infectious disease models to 
time series count data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>PMCMC(x, ...)

## S3 method for class 'PMCMC'
PMCMC(
  x,
  niter = 1000,
  nprintsum = 100,
  adapt = TRUE,
  adaptmixprop = 0.05,
  nupdate = 100,
  ...
)

## Default S3 method:
PMCMC(
  x,
  priors,
  func,
  u,
  npart = 100,
  iniPars = NA,
  fixpars = FALSE,
  niter = 1000,
  nprintsum = 100,
  adapt = TRUE,
  propVar = NA,
  adaptmixprop = 0.05,
  nupdate = 100,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="PMCMC_+3A_x">x</code></td>
<td>
<p>A <code>PMCMC</code> object, or a <code>data.frame</code> containing time series count data, 
with the first column called <code>t</code>, followed by columns of time-series counts. 
The time-series counts columns must be in the order of the 'counts' object in the
'func' function (see below).</p>
</td></tr>
<tr><td><code id="PMCMC_+3A_...">...</code></td>
<td>
<p>Not used here.</p>
</td></tr>
<tr><td><code id="PMCMC_+3A_niter">niter</code></td>
<td>
<p>An integer specifying the number of iterations to run the MCMC.</p>
</td></tr>
<tr><td><code id="PMCMC_+3A_nprintsum">nprintsum</code></td>
<td>
<p>Prints summary of MCMC to screen every <code>nprintsum</code> iterations. 
Also defines how often adaptive scaling of proposal variances occur.</p>
</td></tr>
<tr><td><code id="PMCMC_+3A_adapt">adapt</code></td>
<td>
<p>Logical determining whether to use adaptive proposal or not.</p>
</td></tr>
<tr><td><code id="PMCMC_+3A_adaptmixprop">adaptmixprop</code></td>
<td>
<p>Mixing proportion for adaptive proposal.</p>
</td></tr>
<tr><td><code id="PMCMC_+3A_nupdate">nupdate</code></td>
<td>
<p>Controls when to start adaptive update.</p>
</td></tr>
<tr><td><code id="PMCMC_+3A_priors">priors</code></td>
<td>
<p>A <code>data.frame</code> containing columns <code>parnames</code>, <code>dist</code>, <code>p1</code> and 
<code>p2</code>, with number of rows equal to the number of parameters. The column
<code>parname</code> simply gives names to each parameter for plotting and summarising.
Each entry in the <code>dist</code> column must contain one of <code>c("unif", "norm", "gamma")</code>, 
and the corresponding <code>p1</code> and <code>p2</code> entries relate to the hyperparameters 
(lower and upper bounds in the uniform case; mean and standard deviation in the 
normal case; and shape and rate in the gamma case).</p>
</td></tr>
<tr><td><code id="PMCMC_+3A_func">func</code></td>
<td>
<p>A <code>SimBIID_model</code> object or an <code>XPtr</code> to simulation function. If the latter, 
then this function must take the following arguments in order: 
</p>

<ul>
<li><p><code>NumericVector pars</code>: a vector of parameters;
</p>
</li>
<li><p><code>double tstart</code>: the start time;
</p>
</li>
<li><p><code>double tstop</code>: the end time;
</p>
</li>
<li><p><code>IntegerVector u</code>: a vector of states at time <code>tstart</code>;
</p>
</li>
<li><p><code>IntegerVector counts</code>: a vector of observed counts at <code>tstop</code>.</p>
</li></ul>
</td></tr>
<tr><td><code id="PMCMC_+3A_u">u</code></td>
<td>
<p>A named vector of initial states.</p>
</td></tr>
<tr><td><code id="PMCMC_+3A_npart">npart</code></td>
<td>
<p>An integer specifying the number of particles for the bootstrap particle filter.</p>
</td></tr>
<tr><td><code id="PMCMC_+3A_inipars">iniPars</code></td>
<td>
<p>A named vector of initial values for the parameters of the model. If left unspecified, 
then these are sampled from the prior distribution(s).</p>
</td></tr>
<tr><td><code id="PMCMC_+3A_fixpars">fixpars</code></td>
<td>
<p>A logical determining whether to fix the input parameters (useful for 
determining the variance of the marginal likelihood estimates).</p>
</td></tr>
<tr><td><code id="PMCMC_+3A_propvar">propVar</code></td>
<td>
<p>A numeric (npars x npars) matrix with log (or logistic) covariances to use
as (initial) proposal matrix. If left unspecified then defaults to 
<code>diag(nrow(priors)) * (0.1 ^ 2) / nrow(priors)</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Function runs a particle MCMC algorithm using a bootstrap particle filter for a given model. 
If running with <code>fixpars = TRUE</code> then this runs <code>niter</code> simulations
using fixed parameter values. This can be used to optimise the number of 
particles after a training run. Also has <code>print()</code>, <code>summary()</code>,
<code>plot()</code>, <code>predict()</code> and <code>window()</code> methods.
</p>


<h3>Value</h3>

<p>If the code throws an error, then it returns a missing value (<code>NA</code>). If 
<code>fixpars = TRUE</code> it returns a list of length 2 containing:
</p>

<ul>
<li><p><code>output</code>: a matrix with two columns. The first contains the simulated
log-likelihood, and the second is a binary indicator relating to whether the
simulation was 'skipped' or not (1 = skipped, 0 = not skipped);
</p>
</li>
<li><p><code>pars</code>: a vector of parameters used for the simulations.
</p>
</li></ul>

<p>If <code>fixpars = FALSE</code>, the routine returns a <code>PMCMC</code> object, essentially a 
<code>list</code> containing:
</p>

<ul>
<li><p><code>pars</code>: an <code>mcmc</code> object containing posterior samples for the parameters;
</p>
</li>
<li><p><code>u</code>: a copy of the <code>u</code> input;
</p>
</li>
<li><p><code>accrate</code>: the cumulative acceptance rate;
</p>
</li>
<li><p><code>npart</code>: the chosen number of particles;
</p>
</li>
<li><p><code>time</code>: the time taken to run the routine (in seconds);
</p>
</li>
<li><p><code>propVar</code>: the proposal covariance for the parameter updates;
</p>
</li>
<li><p><code>data</code>: a copy of the <code>x</code> input;
</p>
</li>
<li><p><code>priors</code>: a copy of the <code>priors</code> input;
</p>
</li>
<li><p><code>func</code>: a copy of the <code>func</code> input.
</p>
</li></ul>



<h3>References</h3>

<p>Andrieu C, Doucet A and Holenstein R (2010) &lt;doi:10.1111/j.1467-9868.2009.00736.x&gt;
</p>


<h3>See Also</h3>

<p><code><a href="#topic+print.PMCMC">print.PMCMC</a></code>, <code><a href="#topic+plot.PMCMC">plot.PMCMC</a></code>, <code><a href="#topic+predict.PMCMC">predict.PMCMC</a></code>, <code><a href="#topic+summary.PMCMC">summary.PMCMC</a></code>
<code><a href="#topic+window.PMCMC">window.PMCMC</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## set up data to pass to PMCMC
flu_dat &lt;- data.frame(
    t = 1:14,
    Robs = c(3, 8, 26, 76, 225, 298, 258, 233, 189, 128, 68, 29, 14, 4)
)

## set up observation process
obs &lt;- data.frame(
    dataNames = "Robs",
    dist = "pois",
    p1 = "R + 1e-5",
    p2 = NA,
    stringsAsFactors = FALSE
)

## set up model (no need to specify tspan
## argument as it is set in PMCMC())
transitions &lt;- c(
    "S -&gt; beta * S * I / (S + I + R + R1) -&gt; I", 
    "I -&gt; gamma * I -&gt; R",
    "R -&gt; gamma1 * R -&gt; R1"
)
compartments &lt;- c("S", "I", "R", "R1")
pars &lt;- c("beta", "gamma", "gamma1")
model &lt;- mparseRcpp(
    transitions = transitions, 
    compartments = compartments,
    pars = pars,
    obsProcess = obs
)

## set priors
priors &lt;- data.frame(
    parnames = c("beta", "gamma", "gamma1"), 
    dist = rep("unif", 3), 
    stringsAsFactors = FALSE)
priors$p1 &lt;- c(0, 0, 0)
priors$p2 &lt;- c(5, 5, 5)

## define initial states
iniStates &lt;- c(S = 762, I = 1, R = 0, R1 = 0)

set.seed(50)

## run PMCMC algorithm
post &lt;- PMCMC(
    x = flu_dat, 
    priors = priors,
    func = model, 
    u = iniStates,
    npart = 25,
    niter = 5000, 
    nprintsum = 1000
)

## plot MCMC traces
plot(post, "trace")

## continue for some more iterations
post &lt;- PMCMC(post, niter = 5000, nprintsum = 1000)

## plot traces and posteriors
plot(post, "trace")
plot(post)

## remove burn-in
post &lt;- window(post, start = 5000)

## summarise posteriors
summary(post)


</code></pre>

<hr>
<h2 id='predict.PMCMC'>Predicts future course of outbreak from <code>PMCMC</code> objects</h2><span id='topic+predict.PMCMC'></span>

<h3>Description</h3>

<p>Predict method for <code>PMCMC</code> objects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'PMCMC'
predict(object, tspan, npart = 50, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="predict.PMCMC_+3A_object">object</code></td>
<td>
<p>A <code>PMCMC</code> object.</p>
</td></tr>
<tr><td><code id="predict.PMCMC_+3A_tspan">tspan</code></td>
<td>
<p>A vector of times over which to output predictions.</p>
</td></tr>
<tr><td><code id="predict.PMCMC_+3A_npart">npart</code></td>
<td>
<p>The number of particles to use in the bootstrap filter.</p>
</td></tr>
<tr><td><code id="predict.PMCMC_+3A_...">...</code></td>
<td>
<p>Not used here.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>SimBIID_runs</code> object.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+PMCMC">PMCMC</a></code>, <code><a href="#topic+print.PMCMC">print.PMCMC</a></code>, <code><a href="#topic+plot.PMCMC">plot.PMCMC</a></code>, <code><a href="#topic+summary.PMCMC">summary.PMCMC</a></code>
<code><a href="#topic+window.PMCMC">window.PMCMC</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## set up data to pass to PMCMC
flu_dat &lt;- data.frame(
    t = 1:14,
    Robs = c(3, 8, 26, 76, 225, 298, 258, 233, 189, 128, 68, 29, 14, 4)
)

## set up observation process
obs &lt;- data.frame(
    dataNames = "Robs",
    dist = "pois",
    p1 = "R + 1e-5",
    p2 = NA,
    stringsAsFactors = FALSE
)

## set up model (no need to specify tspan
## argument as it is set in PMCMC())
transitions &lt;- c(
    "S -&gt; beta * S * I / (S + I + R + R1) -&gt; I", 
    "I -&gt; gamma * I -&gt; R",
    "R -&gt; gamma1 * R -&gt; R1"
)
compartments &lt;- c("S", "I", "R", "R1")
pars &lt;- c("beta", "gamma", "gamma1")
model &lt;- mparseRcpp(
    transitions = transitions, 
    compartments = compartments,
    pars = pars,
    obsProcess = obs
)

## set priors
priors &lt;- data.frame(
    parnames = c("beta", "gamma", "gamma1"), 
    dist = rep("unif", 3), 
    stringsAsFactors = FALSE)
priors$p1 &lt;- c(0, 0, 0)
priors$p2 &lt;- c(5, 5, 5)

## define initial states
iniStates &lt;- c(S = 762, I = 1, R = 0, R1 = 0)

## run PMCMC algorithm for first three days of data
post &lt;- PMCMC(
    x = flu_dat[1:3, ], 
    priors = priors, 
    func = model, 
    u = iniStates, 
    npart = 75, 
    niter = 10000, 
    nprintsum = 1000
)

## plot traces
plot(post, "trace")

## run predictions forward in time
post_pred &lt;- predict(
    window(post, start = 2000, thin = 8), 
    tspan = 4:14
)

## plot predictions
plot(post_pred, quant = c(0.6, 0.75, 0.95))


</code></pre>

<hr>
<h2 id='print.ABCSMC'>Prints <code>ABCSMC</code> objects</h2><span id='topic+print.ABCSMC'></span>

<h3>Description</h3>

<p>Print method for <code>ABCSMC</code> objects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'ABCSMC'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.ABCSMC_+3A_x">x</code></td>
<td>
<p>An <code>ABCSMC</code> object.</p>
</td></tr>
<tr><td><code id="print.ABCSMC_+3A_...">...</code></td>
<td>
<p>Not used here.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Summary outputs printed to the screen.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+ABCSMC">ABCSMC</a></code>, <code><a href="#topic+plot.ABCSMC">plot.ABCSMC</a></code>, <code><a href="#topic+summary.ABCSMC">summary.ABCSMC</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## set up SIR simulationmodel
transitions &lt;- c(
    "S -&gt; beta * S * I -&gt; I", 
    "I -&gt; gamma * I -&gt; R"
)
compartments &lt;- c("S", "I", "R")
pars &lt;- c("beta", "gamma")
model &lt;- mparseRcpp(
    transitions = transitions, 
    compartments = compartments,
    pars = pars
)
model &lt;- compileRcpp(model)

## generate function to run simulators
## and return summary statistics
simSIR &lt;- function(pars, data, tols, u, model) {

    ## run model
    sims &lt;- model(pars, 0, data[2] + tols[2], u)
    
    ## this returns a vector of the form:
    ## completed (1/0), t, S, I, R (here)
    if(sims[1] == 0) {
        ## if simulation rejected
        return(NA)
    } else {
        ## extract finaltime and finalsize
        finaltime &lt;- sims[2]
        finalsize &lt;- sims[5]
    }
    
    ## return vector if match, else return NA
    if(all(abs(c(finalsize, finaltime) - data) &lt;= tols)){
        return(c(finalsize, finaltime))
    } else {
        return(NA)
    }
}

## set priors
priors &lt;- data.frame(
    parnames = c("beta", "gamma"), 
    dist = rep("gamma", 2), 
    stringsAsFactors = FALSE
)
priors$p1 &lt;- c(10, 10)
priors$p2 &lt;- c(10^4, 10^2)

## define the targeted summary statistics
data &lt;- c(
    finalsize = 30, 
    finaltime = 76
)

## set initial states (1 initial infection 
## in population of 120)
iniStates &lt;- c(S = 119, I = 1, R = 0)

## set initial tolerances
tols &lt;- c(
    finalsize = 50,
    finaltime = 50
)

## run 2 generations of ABC-SMC
## setting tolerance to be 50th
## percentile of the accepted 
## tolerances at each generation
post &lt;- ABCSMC(
    x = data, 
    priors = priors, 
    func = simSIR, 
    u = iniStates, 
    tols = tols, 
    ptol = 0.2, 
    ngen = 2, 
    npart = 50,
    model = model
)
post

## run one further generation
post &lt;- ABCSMC(post, ptols = 0.5, ngen = 1)
post
summary(post)

## plot posteriors
plot(post)

## plot outputs
plot(post, "output")


</code></pre>

<hr>
<h2 id='print.PMCMC'>Prints <code>PMCMC</code> objects</h2><span id='topic+print.PMCMC'></span>

<h3>Description</h3>

<p>Print method for <code>PMCMC</code> objects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'PMCMC'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.PMCMC_+3A_x">x</code></td>
<td>
<p>A <code>PMCMC</code> object.</p>
</td></tr>
<tr><td><code id="print.PMCMC_+3A_...">...</code></td>
<td>
<p>Not used here.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Summary outputs printed to the screen.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+PMCMC">PMCMC</a></code>, <code><a href="#topic+plot.PMCMC">plot.PMCMC</a></code>, <code><a href="#topic+predict.PMCMC">predict.PMCMC</a></code>, <code><a href="#topic+summary.PMCMC">summary.PMCMC</a></code>
<code><a href="#topic+window.PMCMC">window.PMCMC</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## set up data to pass to PMCMC
flu_dat &lt;- data.frame(
    t = 1:14,
    Robs = c(3, 8, 26, 76, 225, 298, 258, 233, 189, 128, 68, 29, 14, 4)
)

## set up observation process
obs &lt;- data.frame(
    dataNames = "Robs",
    dist = "pois",
    p1 = "R + 1e-5",
    p2 = NA,
    stringsAsFactors = FALSE
)

## set up model (no need to specify tspan
## argument as it is set in PMCMC())
transitions &lt;- c(
    "S -&gt; beta * S * I / (S + I + R + R1) -&gt; I", 
    "I -&gt; gamma * I -&gt; R",
    "R -&gt; gamma1 * R -&gt; R1"
)
compartments &lt;- c("S", "I", "R", "R1")
pars &lt;- c("beta", "gamma", "gamma1")
model &lt;- mparseRcpp(
    transitions = transitions, 
    compartments = compartments,
    pars = pars,
    obsProcess = obs
)

## set priors
priors &lt;- data.frame(
    parnames = c("beta", "gamma", "gamma1"), 
    dist = rep("unif", 3), 
    stringsAsFactors = FALSE)
priors$p1 &lt;- c(0, 0, 0)
priors$p2 &lt;- c(5, 5, 5)

## define initial states
iniStates &lt;- c(S = 762, I = 1, R = 0, R1 = 0)

set.seed(50)

## run PMCMC algorithm
post &lt;- PMCMC(
    x = flu_dat, 
    priors = priors,
    func = model, 
    u = iniStates,
    npart = 25,
    niter = 5000, 
    nprintsum = 1000
)

## plot MCMC traces
plot(post, "trace")

## continue for some more iterations
post &lt;- PMCMC(post, niter = 5000, nprintsum = 1000)

## plot traces and posteriors
plot(post, "trace")
plot(post)

## remove burn-in
post &lt;- window(post, start = 5000)

## summarise posteriors
summary(post)


</code></pre>

<hr>
<h2 id='print.SimBIID_model'>Prints <code>SimBIID_model</code> objects</h2><span id='topic+print.SimBIID_model'></span>

<h3>Description</h3>

<p>Print method for <code>SimBIID_model</code> objects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'SimBIID_model'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.SimBIID_model_+3A_x">x</code></td>
<td>
<p>A <code>SimBIID_model</code> object.</p>
</td></tr>
<tr><td><code id="print.SimBIID_model_+3A_...">...</code></td>
<td>
<p>Not used here.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Prints parsed <code>Rcpp</code> code to the screen.
</p>

<hr>
<h2 id='print.SimBIID_runs'>Prints <code>SimBIID_runs</code> objects</h2><span id='topic+print.SimBIID_runs'></span>

<h3>Description</h3>

<p>Print method for <code>SimBIID_runs</code> objects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'SimBIID_runs'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.SimBIID_runs_+3A_x">x</code></td>
<td>
<p>A <code>SimBIID_runs</code> object.</p>
</td></tr>
<tr><td><code id="print.SimBIID_runs_+3A_...">...</code></td>
<td>
<p>Not used here.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Summary outputs printed to the screen.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+mparseRcpp">mparseRcpp</a></code>, <code><a href="#topic+plot.SimBIID_runs">plot.SimBIID_runs</a></code>, <code><a href="#topic+run">run</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## set up SIR simulation model
transitions &lt;- c(
    "S -&gt; beta * S * I -&gt; I", 
    "I -&gt; gamma * I -&gt; R"
)
compartments &lt;- c("S", "I", "R")
pars &lt;- c("beta", "gamma")
model &lt;- mparseRcpp(
    transitions = transitions, 
    compartments = compartments,
    pars = pars,
    tspan = TRUE
)

## run 100 replicate simulations and
## plot outputs
sims &lt;- run(
    model = model,
    pars = c(beta = 0.001, gamma = 0.1),
    tstart = 0,
    tstop = 100,
    u = c(S = 119, I = 1, R = 0),
    tspan = seq(1, 100, length.out = 10),
    nrep = 100
)
sims


</code></pre>

<hr>
<h2 id='run'>Runs <code>SimBIID_model</code> object</h2><span id='topic+run'></span>

<h3>Description</h3>

<p>Wrapper function that compiles (if necessary) and runs
a <code>SimBIID_model</code> object. Returns results in a 
user-friendly manner as a <code>SimBIID_run</code> object, 
for which <code>print()</code> and <code>plot()</code> generics 
are provided.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>run(
  model,
  pars,
  tstart,
  tstop,
  u,
  tspan,
  nrep = 1,
  parallel = FALSE,
  mc.cores = NA
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="run_+3A_model">model</code></td>
<td>
<p>An object of class <code>SimBIID_model</code>.</p>
</td></tr>
<tr><td><code id="run_+3A_pars">pars</code></td>
<td>
<p>A named vector of parameters.</p>
</td></tr>
<tr><td><code id="run_+3A_tstart">tstart</code></td>
<td>
<p>The time at which to start the simulation.</p>
</td></tr>
<tr><td><code id="run_+3A_tstop">tstop</code></td>
<td>
<p>The time at which to stop the simulation.</p>
</td></tr>
<tr><td><code id="run_+3A_u">u</code></td>
<td>
<p>A named vector of initial states.</p>
</td></tr>
<tr><td><code id="run_+3A_tspan">tspan</code></td>
<td>
<p>A numeric vector containing the times at which to 
save the states of the system.</p>
</td></tr>
<tr><td><code id="run_+3A_nrep">nrep</code></td>
<td>
<p>Specifies the number of simulations to run.</p>
</td></tr>
<tr><td><code id="run_+3A_parallel">parallel</code></td>
<td>
<p>A <code>logical</code> determining whether to use parallel processing or not.</p>
</td></tr>
<tr><td><code id="run_+3A_mc.cores">mc.cores</code></td>
<td>
<p>Number of cores to use if using parallel processing.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <code>SimBIID_run</code>, essentially a list 
containing elements:
</p>

<ul>
<li><p>sums: a <code>data.frame()</code> with summaries of the model runs. This
includes columns <code>run</code>, <code>completed</code>, <code>t</code>, <code>u*</code> 
(see help file for <code>SimBIID_model</code> for more details);
</p>
</li>
<li><p>runs: a <code>data.frame()</code> object, containing columns: <code>run</code>,
<code>t</code>, <code>u*</code> (see help file for <code>SimBIID_model</code> for more details).
These contain time series counts for the simulations. Note that this will
only be returned if <code>tspan = TRUE</code> in the original <code>SimBIID_model</code> object.
</p>
</li>
<li><p>bootEnd: a time point denoting when bootstrapped estimates end and predictions
begin (for <code>predict.PMCMC()</code> method). 
</p>
</li></ul>



<h3>See Also</h3>

<p><code><a href="#topic+mparseRcpp">mparseRcpp</a></code>, <code><a href="#topic+print.SimBIID_runs">print.SimBIID_runs</a></code>, <code><a href="#topic+plot.SimBIID_runs">plot.SimBIID_runs</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## set up SIR simulation model
transitions &lt;- c(
    "S -&gt; beta * S * I -&gt; I", 
    "I -&gt; gamma * I -&gt; R"
)
compartments &lt;- c("S", "I", "R")
pars &lt;- c("beta", "gamma")
model &lt;- mparseRcpp(
    transitions = transitions, 
    compartments = compartments,
    pars = pars
)

## compile and run model
sims &lt;- run(
    model = model,
    pars = c(beta = 0.001, gamma = 0.1),
    tstart = 0,
    tstop = 100,
    u = c(S = 119, I = 1, R = 0)
)
sims

## add tspan option to return
## time series counts at different
## time points
model &lt;- mparseRcpp(
    transitions = transitions, 
    compartments = compartments,
    pars = pars,
    tspan = TRUE
)
sims &lt;- run(
    model = model,
    pars = c(beta = 0.001, gamma = 0.1),
    tstart = 0,
    tstop = 100,
    u = c(S = 119, I = 1, R = 0),
    tspan = seq(1, 100, length.out = 10)
)
sims

## run 100 replicate simulations and
## plot outputs
sims &lt;- run(
    model = model,
    pars = c(beta = 0.001, gamma = 0.1),
    tstart = 0,
    tstop = 100,
    u = c(S = 119, I = 1, R = 0),
    tspan = seq(1, 100, length.out = 10),
    nrep = 100
)
sims
plot(sims)

</code></pre>

<hr>
<h2 id='smallpox'>Time series counts of smallpox cases</h2><span id='topic+smallpox'></span>

<h3>Description</h3>

<p>A dataset containing time series counts for the number
of new removals for the 1967 Abakaliki smallpox outbreak.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>smallpox
</code></pre>


<h3>Format</h3>

<p>A data frame with 23 rows and 2 variables:
</p>

<dl>
<dt>time</dt><dd><p>days from initial observed removal</p>
</dd>
<dt>removals</dt><dd><p>number of new removals in (time - 1, time)</p>
</dd>
</dl>



<h3>Source</h3>

<p>Thompson D and Foege W (1968) &lt;https://apps.who.int/iris/bitstream/handle/10665/67462/WHO_SE_68.3.pdf&gt;
</p>

<hr>
<h2 id='summary.ABCSMC'>Summarises <code>ABCSMC</code> objects</h2><span id='topic+summary.ABCSMC'></span>

<h3>Description</h3>

<p>Summary method for <code>ABCSMC</code> objects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'ABCSMC'
summary(object, gen = NA, transfunc = NA, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary.ABCSMC_+3A_object">object</code></td>
<td>
<p>An <code>ABCSMC</code> object.</p>
</td></tr>
<tr><td><code id="summary.ABCSMC_+3A_gen">gen</code></td>
<td>
<p>The generation of ABC that you want to extract. If left missing then
defaults to final generation.</p>
</td></tr>
<tr><td><code id="summary.ABCSMC_+3A_transfunc">transfunc</code></td>
<td>
<p>Is a <code>function</code> object where the arguments to the function must
match all or a subset of the parameters in the model. This function needs 
to return a <code>data.frame</code> object with columns containing the transformed
parameters.</p>
</td></tr>
<tr><td><code id="summary.ABCSMC_+3A_...">...</code></td>
<td>
<p>Not used here.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>data.frame</code> with weighted posterior means and variances.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+ABCSMC">ABCSMC</a></code>, <code><a href="#topic+print.ABCSMC">print.ABCSMC</a></code>, <code><a href="#topic+plot.ABCSMC">plot.ABCSMC</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## set up SIR simulationmodel
transitions &lt;- c(
    "S -&gt; beta * S * I -&gt; I", 
    "I -&gt; gamma * I -&gt; R"
)
compartments &lt;- c("S", "I", "R")
pars &lt;- c("beta", "gamma")
model &lt;- mparseRcpp(
    transitions = transitions, 
    compartments = compartments,
    pars = pars
)
model &lt;- compileRcpp(model)

## generate function to run simulators
## and return summary statistics
simSIR &lt;- function(pars, data, tols, u, model) {

    ## run model
    sims &lt;- model(pars, 0, data[2] + tols[2], u)
    
    ## this returns a vector of the form:
    ## completed (1/0), t, S, I, R (here)
    if(sims[1] == 0) {
        ## if simulation rejected
        return(NA)
    } else {
        ## extract finaltime and finalsize
        finaltime &lt;- sims[2]
        finalsize &lt;- sims[5]
    }
    
    ## return vector if match, else return NA
    if(all(abs(c(finalsize, finaltime) - data) &lt;= tols)){
        return(c(finalsize, finaltime))
    } else {
        return(NA)
    }
}

## set priors
priors &lt;- data.frame(
    parnames = c("beta", "gamma"), 
    dist = rep("gamma", 2), 
    stringsAsFactors = FALSE
)
priors$p1 &lt;- c(10, 10)
priors$p2 &lt;- c(10^4, 10^2)

## define the targeted summary statistics
data &lt;- c(
    finalsize = 30, 
    finaltime = 76
)

## set initial states (1 initial infection 
## in population of 120)
iniStates &lt;- c(S = 119, I = 1, R = 0)

## set initial tolerances
tols &lt;- c(
    finalsize = 50,
    finaltime = 50
)

## run 2 generations of ABC-SMC
## setting tolerance to be 50th
## percentile of the accepted 
## tolerances at each generation
post &lt;- ABCSMC(
    x = data, 
    priors = priors, 
    func = simSIR, 
    u = iniStates, 
    tols = tols, 
    ptol = 0.2, 
    ngen = 2, 
    npart = 50,
    model = model
)
post

## run one further generation
post &lt;- ABCSMC(post, ptols = 0.5, ngen = 1)
post
summary(post)

## plot posteriors
plot(post)

## plot outputs
plot(post, "output")


</code></pre>

<hr>
<h2 id='summary.PMCMC'>Summarises <code>PMCMC</code> objects</h2><span id='topic+summary.PMCMC'></span>

<h3>Description</h3>

<p>Summary method for <code>PMCMC</code> objects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'PMCMC'
summary(object, transfunc = NA, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary.PMCMC_+3A_object">object</code></td>
<td>
<p>A <code>PMCMC</code> object.</p>
</td></tr>
<tr><td><code id="summary.PMCMC_+3A_transfunc">transfunc</code></td>
<td>
<p>Is a <code>function</code> object where the arguments to the function must
match all or a subset of the parameters in the model. This function needs 
to return a <code>data.frame</code> object with columns containing the transformed
parameters.</p>
</td></tr>
<tr><td><code id="summary.PMCMC_+3A_...">...</code></td>
<td>
<p>Not used here.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>summary.mcmc</code> object.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+PMCMC">PMCMC</a></code>, <code><a href="#topic+print.PMCMC">print.PMCMC</a></code>, <code><a href="#topic+predict.PMCMC">predict.PMCMC</a></code>, <code><a href="#topic+plot.PMCMC">plot.PMCMC</a></code>
<code><a href="#topic+window.PMCMC">window.PMCMC</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## set up data to pass to PMCMC
flu_dat &lt;- data.frame(
    t = 1:14,
    Robs = c(3, 8, 26, 76, 225, 298, 258, 233, 189, 128, 68, 29, 14, 4)
)

## set up observation process
obs &lt;- data.frame(
    dataNames = "Robs",
    dist = "pois",
    p1 = "R + 1e-5",
    p2 = NA,
    stringsAsFactors = FALSE
)

## set up model (no need to specify tspan
## argument as it is set in PMCMC())
transitions &lt;- c(
    "S -&gt; beta * S * I / (S + I + R + R1) -&gt; I", 
    "I -&gt; gamma * I -&gt; R",
    "R -&gt; gamma1 * R -&gt; R1"
)
compartments &lt;- c("S", "I", "R", "R1")
pars &lt;- c("beta", "gamma", "gamma1")
model &lt;- mparseRcpp(
    transitions = transitions, 
    compartments = compartments,
    pars = pars,
    obsProcess = obs
)

## set priors
priors &lt;- data.frame(
    parnames = c("beta", "gamma", "gamma1"), 
    dist = rep("unif", 3), 
    stringsAsFactors = FALSE)
priors$p1 &lt;- c(0, 0, 0)
priors$p2 &lt;- c(5, 5, 5)

## define initial states
iniStates &lt;- c(S = 762, I = 1, R = 0, R1 = 0)

set.seed(50)

## run PMCMC algorithm
post &lt;- PMCMC(
    x = flu_dat, 
    priors = priors,
    func = model, 
    u = iniStates,
    npart = 25,
    niter = 5000, 
    nprintsum = 1000
)

## plot MCMC traces
plot(post, "trace")

## continue for some more iterations
post &lt;- PMCMC(post, niter = 5000, nprintsum = 1000)

## plot traces and posteriors
plot(post, "trace")
plot(post)

## remove burn-in
post &lt;- window(post, start = 5000)

## summarise posteriors
summary(post)


</code></pre>

<hr>
<h2 id='window.PMCMC'>Time windows for <code>PMCMC</code> objects</h2><span id='topic+window.PMCMC'></span>

<h3>Description</h3>

<p><code>window</code> method for class <code>PMCMC</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'PMCMC'
window(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="window.PMCMC_+3A_x">x</code></td>
<td>
<p>a <code>PMCMC</code> object, usually as a result of a call to
<code>PMCMC</code>.</p>
</td></tr>
<tr><td><code id="window.PMCMC_+3A_...">...</code></td>
<td>
<p>arguments to pass to <code><a href="coda.html#topic+window.mcmc">window.mcmc</a></code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>Acts as a wrapper function for <code><a href="coda.html#topic+window.mcmc">window.mcmc</a></code> 
from the <code>coda</code> package
</p>


<h3>Value</h3>

<p>a <code>PMCMC</code> object
</p>


<h3>See Also</h3>

<p><code><a href="#topic+PMCMC">PMCMC</a></code>, <code><a href="#topic+print.PMCMC">print.PMCMC</a></code>, <code><a href="#topic+predict.PMCMC">predict.PMCMC</a></code>, <code><a href="#topic+summary.PMCMC">summary.PMCMC</a></code>
<code><a href="#topic+plot.PMCMC">plot.PMCMC</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## set up data to pass to PMCMC
flu_dat &lt;- data.frame(
    t = 1:14,
    Robs = c(3, 8, 26, 76, 225, 298, 258, 233, 189, 128, 68, 29, 14, 4)
)

## set up observation process
obs &lt;- data.frame(
    dataNames = "Robs",
    dist = "pois",
    p1 = "R + 1e-5",
    p2 = NA,
    stringsAsFactors = FALSE
)

## set up model (no need to specify tspan
## argument as it is set in PMCMC())
transitions &lt;- c(
    "S -&gt; beta * S * I / (S + I + R + R1) -&gt; I", 
    "I -&gt; gamma * I -&gt; R",
    "R -&gt; gamma1 * R -&gt; R1"
)
compartments &lt;- c("S", "I", "R", "R1")
pars &lt;- c("beta", "gamma", "gamma1")
model &lt;- mparseRcpp(
    transitions = transitions, 
    compartments = compartments,
    pars = pars,
    obsProcess = obs
)

## set priors
priors &lt;- data.frame(
    parnames = c("beta", "gamma", "gamma1"), 
    dist = rep("unif", 3), 
    stringsAsFactors = FALSE)
priors$p1 &lt;- c(0, 0, 0)
priors$p2 &lt;- c(5, 5, 5)

## define initial states
iniStates &lt;- c(S = 762, I = 1, R = 0, R1 = 0)

set.seed(50)

## run PMCMC algorithm
post &lt;- PMCMC(
    x = flu_dat, 
    priors = priors,
    func = model, 
    u = iniStates,
    npart = 25,
    niter = 5000, 
    nprintsum = 1000
)

## plot MCMC traces
plot(post, "trace")

## continue for some more iterations
post &lt;- PMCMC(post, niter = 5000, nprintsum = 1000)

## plot traces and posteriors
plot(post, "trace")
plot(post)

## remove burn-in
post &lt;- window(post, start = 5000)

## summarise posteriors
summary(post)


</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
