<!DOCTYPE html><html lang="en"><head><title>Help for package spgs</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {spgs}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#spgs-package'>
<p>Statistical Patterns in Genomic Sequences</p></a></li>
<li><a href='#ag.test'><p>Test of Purine-Pyrimidine Parity Based on Purine Count</p></a></li>
<li><a href='#agct.test'><p>Test of Purine-Pyrimidine Parity Based on Euclidean distance</p></a></li>
<li><a href='#array2vector'>
<p>Convert Arrays and Tables to Vectors with Named Elements</p></a></li>
<li><a href='#chargaff.gibbs.test'><p>Test of CSPR for Dinucleotides Under Gibbs Distribution</p></a></li>
<li><a href='#chargaff0.test'><p>Vector Test of Chargaff's Second Parity Rule (CSPR) for Mononucleotides</p></a></li>
<li><a href='#chargaff1.test'><p>Matrix Test of CSPR for Mononucleotides</p></a></li>
<li><a href='#chargaff2.test'><p>Matrix Test of CSPR for Dinucleotides</p></a></li>
<li><a href='#chisq.unif.test'>
<p>Test of Uniformity Based on Pearsons's Chi-Squared test</p></a></li>
<li><a href='#complement'>
<p>Complement of a DNA/RNA Sequence</p></a></li>
<li><a href='#cylinder.counts'>
<p>Count Cylinders (Fixed-Offset Patterns) in Character Vectors</p></a></li>
<li><a href='#diffsign.test'>
<p>the Differents-Sign Test of Statistical Independence</p></a></li>
<li><a href='#diid.disturbance'>
<p>Construct feasible Random Noise Generating a Bernoulli Process</p></a></li>
<li><a href='#diid.test'>
<p>A Test for a Bernoulli Scheme (IID Sequence)</p></a></li>
<li><a href='#disambiguate'>
<p>Disambiguate a Nucleic Sequence</p></a></li>
<li><a href='#estimateMarkovChain'>
<p>Fit a first-Order Markov Chain to a Sequence of Finite Symbols</p></a></li>
<li><a href='#ks.unif.test'>
<p>Using <code>ks.test</code> to test for Uniformity on the Unit Interval</p></a></li>
<li><a href='#lb.test'>
<p>The Ljung-Box Test for Uncorrelated Data</p></a></li>
<li><a href='#markov.disturbance'>
<p>Construct feasible Random Noise Generating a First-Order Markov Chain</p></a></li>
<li><a href='#markov.test'>
<p>A Test for First-Order Markovianness</p></a></li>
<li><a href='#Nanoarchaeum+20equitans+20Kin4-M+20Chromosome'><p>DNA sequence for the Nanoarchaeum equitans Kin4-M Chromosome</p></a></li>
<li><a href='#oligoProfile'>
<p>Oligo Profiles and Oligo Profile Correlation Plots of Nucleotide Sequences</p></a></li>
<li><a href='#pair.counts'>
<p>Count Pairs in Character Vectors</p></a></li>
<li><a href='#Pieris+20Rapae+20Granulovirus+20Genome'><p>DNA sequence for the Pieris Rapae Granulovirus Genome</p></a></li>
<li><a href='#quadruple.counts'>
<p>Count Quadruplets in Character Vectors</p></a></li>
<li><a href='#rank.test'>
<p>The Rank Test of Statistical Independence</p></a></li>
<li><a href='#rcspr2mat'>
<p>Random Stochastic Matrices Complying with Chargaff's Second Parity Rule for Dinucleotides</p></a></li>
<li><a href='#reverseComplement'>
<p>Reverse Complement of a DNA/RNA Sequence</p></a></li>
<li><a href='#rstochmat'>
<p>Random Generation of Stochastic Matrices</p></a></li>
<li><a href='#rstochvec'>
<p>Random Generation of Stochastic (Probability) Vectors</p></a></li>
<li><a href='#simulateMarkovChain'>
<p>Simulate a first-Order Markov Chain</p></a></li>
<li><a href='#triple.counts'>
<p>Count Triplets in Character Vectors</p></a></li>
<li><a href='#turningpoint.test'>
<p>The Turning Point Test of Statistical Independence</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>Title:</td>
<td>Statistical Patterns in Genomic Sequences</td>
</tr>
<tr>
<td>Version:</td>
<td>1.0-4</td>
</tr>
<tr>
<td>Date:</td>
<td>2023-10-02</td>
</tr>
<tr>
<td>Author:</td>
<td>Andrew Hart [aut, cre],
  Servet Martínez [aut],
  Universidad de Chile [cph],
  INRIA-Chile [cph]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Andrew Hart &lt;ahart@dim.uchile.cl&gt;</td>
</tr>
<tr>
<td>Copyright:</td>
<td>Universidad de Chile, INRIA-Chile</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>graphics, stats</td>
</tr>
<tr>
<td>Enhances:</td>
<td>seqinr</td>
</tr>
<tr>
<td>Description:</td>
<td>A collection of statistical hypothesis tests and other 
	techniques for identifying certain spatial relationships/phenomena in 
	DNA sequences. In particular, it provides tests and graphical methods for determining 
	whether or not DNA sequences comply with Chargaff's second parity rule 
	or exhibit purine-pyrimidine parity. In addition, there are functions for 
	efficiently simulating discrete state space Markov chains and testing 
	arbitrary symbolic sequences of symbols for the presence of first-order 
	Markovianness.
	Also, it has functions for counting words/k-mers (and cylinder patterns) in 
	arbitrary symbolic sequences. Functions which take a DNA sequence as input 
	can handle sequences stored as SeqFastadna objects from the 'seqinr' package.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Classification/MSC:</td>
<td>62F03, 62G10, 62M07, 62P10, 92D20</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-10-02 19:35:08 UTC; ahart</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-10-03 14:20:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='spgs-package'>
Statistical Patterns in Genomic Sequences
</h2><span id='topic+spgs-package'></span><span id='topic+spgs'></span>

<h3>Description</h3>

<p>provides functions for exploring and testing statistical properties and 
patterns in DNA sequences.
</p>


<h3>Details</h3>


<table>
<tr>
 <td style="text-align: left;">
Package: </td><td style="text-align: left;"> spgs </td>
</tr>
<tr>
 <td style="text-align: left;">
Type: </td><td style="text-align: left;"> Package</td>
</tr>
<tr>
 <td style="text-align: left;">
License: </td><td style="text-align: left;"> GPL (&gt;= 2)</td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>

<p>This package provides a range of statistical tests for various properties of DNA
and/or other genomic sequences.  There are eight groups of functions:
</p>

<dl>
<dt>Testing for Chargaff's second parity rule in bacteria and other DNA sequences</dt><dd>
<p><code><a href="#topic+chargaff0.test">chargaff0.test</a></code>, <code><a href="#topic+chargaff1.test">chargaff1.test</a></code>, <code><a href="#topic+chargaff2.test">chargaff2.test</a></code>,
<code><a href="#topic+chargaff.gibbs.test">chargaff.gibbs.test</a></code>, <code><a href="#topic+oligoProfile">oligoProfile</a></code>
</p>
</dd>
<dt>Testing for purine-pyrimidine parity in viruses and other DNA sequences</dt><dd>
<p><code><a href="#topic+ag.test">ag.test</a></code>, <code><a href="#topic+agct.test">agct.test</a></code>
</p>
</dd>
<dt>Testing for Bernoulli/Markov processes</dt><dd>
<p><code><a href="#topic+markov.test">markov.test</a></code>, <code><a href="#topic+diid.test">diid.test</a></code>
</p>
</dd>
<dt>Independence tests</dt><dd>
<p><code><a href="#topic+diffsign.test">diffsign.test</a></code>, <code><a href="#topic+turningpoint.test">turningpoint.test</a></code>, 
<code><a href="#topic+rank.test">rank.test</a></code>, <code><a href="#topic+lb.test">lb.test</a></code>
</p>
</dd>
<dt>Tests for uniform distribution</dt><dd>
<p><code><a href="#topic+ks.unif.test">ks.unif.test</a></code>, <code><a href="#topic+chisq.unif.test">chisq.unif.test</a></code>
</p>
</dd>
<dt>Simulation of random vectors, stochastic matrices, Bernoulli processes and Markov chains </dt><dd>
<p><code><a href="#topic+simulateMarkovChain">simulateMarkovChain</a></code>, <code><a href="#topic+estimateMarkovChain">estimateMarkovChain</a></code>, 
<code><a href="#topic+rstochvec">rstochvec</a></code>, <code><a href="#topic+rstochmat">rstochmat</a></code>, <code><a href="#topic+rcspr2mat">rcspr2mat</a></code>
</p>
</dd>
<dt>Functions for obtaining the complement or reverse complement of a DNA sequence</dt><dd>
<p><code><a href="#topic+complement">complement</a></code>, <code><a href="#topic+reverseComplement">reverseComplement</a></code>
</p>
</dd>
<dt>Functions for counting words/k-mers and cylinders in symbolic sequences</dt><dd>
<p><code><a href="#topic+pair.counts">pair.counts</a></code>, <code><a href="#topic+triple.counts">triple.counts</a></code>, <code><a href="#topic+quadruple.counts">quadruple.counts</a></code>, <code><a href="#topic+cylinder.counts">cylinder.counts</a></code>
</p>
</dd>
</dl>

<p>The word/k-mer counting functions are general and can deal with arbitrary 
symbolic sequences, not only DNA sequences.
</p>
<p>Functions which take a DNA sequence as input are able to work with sequences 
stored as <code>SeqFastadna</code> objects generated by the <span class="pkg">seqinr</span> package.
</p>


<h3>Author(s)</h3>

<p>Andrew Hart and Servet Martínez
</p>
<p>Maintainer: Andrew Hart &lt;ahart@dim.uchile.cl&gt;
</p>


<h3>References</h3>

<p>Hart, A.G. and Martínez, S. (2011)
Statistical testing of Chargaff's second parity rule in bacterial genome sequences.
<em>Stoch. Models</em> <b>27(2)</b>, 1&ndash;46.
</p>
<p>Hart, A.G. and Martínez, S. (2014) 
Markovianness and Conditional Independence in Annotated Bacterial DNA.  
<em>Stat. Appl. Genet. Mol. Biol.</em> <b>13(6)</b>, 693-716.  arXiv:1311.4411 [q-bio.QM].
</p>
<p>Hart, A.G. and Martínez, S. (2012)
A Gibbs approach to Chargaff's second parity rule.
<em>J. Stat. Phys.</em> <b>146(2)</b>, 408-422.  arXiv:1105.0685 [math.pr].
</p>


<h3>See Also</h3>

<p><code><a href="seqinr.html#topic+seqinr-package">seqinr</a></code>
</p>

<hr>
<h2 id='ag.test'>Test of Purine-Pyrimidine Parity Based on Purine Count</h2><span id='topic+ag.test'></span>

<h3>Description</h3>

<p>Performs a test proposed by Hart and Martínez (2011) for the equivalence of the
relative frequencies of purines (<code class="reqn">A+G</code>) and pyrimidines (<code class="reqn">C+T</code>) in DNA
sequences.  It does this by checking whether or not the mononucleotide
frequencies of a DNA sequence satisfy the relationship A+G=C+T.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ag.test(x, type=c("interval", "simplex"))
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ag.test_+3A_x">x</code></td>
<td>
<p>either a vector containing the relative frequencies of each of the 4 nucleotides 
A, C, G, T, a character vector representing a DNA sequence in which each element contains a single nucleotide, or
a DNA sequence stored using the SeqFastadna class from the <span class="pkg"><a href="seqinr.html#topic+seqinr">seqinr</a></span> package.</p>
</td></tr>
<tr><td><code id="ag.test_+3A_type">type</code></td>
<td>
<p>Specifies one of two possible tests to perform, both of which are
based on the same test statistic, but assuming different forms of the Dirichlet
distribution under the null. &ldquo;&lsquo;<span class="samp">&#8288;simplex&#8288;</span>&rsquo;&rdquo; assumes a Dirichlet(1,1,1,1) distribution
on the 3-simplex while &ldquo;&lsquo;<span class="samp">&#8288;interval&#8288;</span>&rsquo;&rdquo; assumes a Dirichlet(1,1) (uniform)
distribution on the unit interval.  The default is &ldquo;&lsquo;<span class="samp">&#8288;interval&#8288;</span>&rsquo;&rdquo;.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The first argument may be a character vector representing a DNA sequence, a DNA
sequence represented using the SeqFastadna class from the <span class="pkg">seqinr</span> package,
or a vector containing the relative frequencies of the A, C, G and T nucleic
acids.
</p>
<p>Let A, C, G and T denote the relative frequencies of the nucleotide bases
appearing in  a DNA sequence. This function carries out a statistical hypothesis
test that the relative frequencies satisfy the relation <code class="reqn">A+G=C+T</code>, or that
purines <code class="reqn">\{A, G\}</code> occur equally as often as pyrimidines <code class="reqn">\{C,T\}</code> in a DNA sequence.
The relationship can be rewritten as <code class="reqn">A-T=C-G</code>, from which it is easy to see
that the property being tested is a generalisation of Chargaff's second parity
rule for mononucleotides, which states that <code class="reqn">A=T</code> and <code class="reqn">C=G</code>. The test is
set up as follows:
</p>
<p><code class="reqn">H_0</code>: <code class="reqn">A+G \neq C+T</code> <br />
<code class="reqn">H_1</code>: <code class="reqn">A+G = C+T</code>
</p>
<p>If &lsquo;<span class="samp">&#8288;type&#8288;</span>&rsquo; is set to &ldquo;&lsquo;<span class="samp">&#8288;simplex&#8288;</span>&rsquo;&rdquo;, the vector <code class="reqn">(A,C,G,T)</code> is
assumed to come from a Dirichlet(1,1,1,1) distribution on the 3-simplex under
the null hypothesis.  Otherwise, if &lsquo;<span class="samp">&#8288;type&#8288;</span>&rsquo; is set to
&ldquo;&lsquo;<span class="samp">&#8288;interval&#8288;</span>&rsquo;&rdquo;, it is assumed under the null hypothesis that
<code class="reqn">(A+G,C+T)</code> ~ Dirichlet(1,1) or, in other words, <code class="reqn">A+G</code> and <code class="reqn">C+T</code> are
uniformly distributed on the unit interval and satisfy <code class="reqn">A+G+C+T=1</code>.
</p>
<p>In both cases, the test statistic is <code class="reqn">\eta_V^* = |A+G-0.5|</code>.
</p>


<h3>Value</h3>

<p>A list with class &quot;htest.ext&quot; containing the following components:
</p>
<table role = "presentation">
<tr><td><code>statistic</code></td>
<td>
<p>the value of the test statistic.</p>
</td></tr>
<tr><td><code>p.value</code></td>
<td>
<p>the p-value of the test. Only included if &lsquo;<span class="samp">&#8288;no.p.value&#8288;</span>&rsquo; is &lsquo;<span class="samp">&#8288;FALSE&#8288;</span>&rsquo;.</p>
</td></tr>
<tr><td><code>method</code></td>
<td>
<p>a character string indicating what type of test was performed.</p>
</td></tr>
<tr><td><code>data.name</code></td>
<td>
<p>a character string giving the name of the data.</p>
</td></tr>
<tr><td><code>estimate</code></td>
<td>
<p>the probability vector used to derive the test statistic.</p>
</td></tr>
<tr><td><code>stat.desc</code></td>
<td>
<p>a brief description of the test statistic.</p>
</td></tr>
<tr><td><code>null</code></td>
<td>
<p>the null hypothesis (<code class="reqn">H_0</code>) of the test.</p>
</td></tr>
<tr><td><code>alternative</code></td>
<td>
<p>the alternative hypothesis (<code class="reqn">H_1</code>) of the test.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Andrew Hart and Servet Martínez
</p>


<h3>References</h3>

<p>Hart, A.G. and Martínez, S. (2011)
Statistical testing of Chargaff's second parity rule in bacterial genome sequences.
<em>Stoch. Models</em> <b>27(2)</b>, 1&ndash;46.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+chargaff0.test">chargaff0.test</a></code>, <code><a href="#topic+chargaff1.test">chargaff1.test</a></code>, 
<code><a href="#topic+chargaff2.test">chargaff2.test</a></code>, <code><a href="#topic+agct.test">agct.test</a></code>,
<code><a href="#topic+chargaff.gibbs.test">chargaff.gibbs.test</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#Demonstration on real viral sequence
data(pieris)
ag.test(pieris)
ag.test(pieris, type="simplex")

#Simulate synthetic DNA sequence that does not exhibit Purine-Pyrimidine parity
trans.mat &lt;- matrix(c(.4, .1, .4, .1, .2, .1, .6, .1, .4, .1, .3, .2, .1, .2, .4, .3), 
ncol=4, byrow=TRUE)
seq &lt;- simulateMarkovChain(500000, trans.mat, states=c("a", "c", "g", "t"))
ag.test(seq)
</code></pre>

<hr>
<h2 id='agct.test'>Test of Purine-Pyrimidine Parity Based on Euclidean distance</h2><span id='topic+agct.test'></span>

<h3>Description</h3>

<p>Performs a test proposed by Hart and Martínez (2011) for the equivalence of the
relative frequencies of purines (<code class="reqn">A+G</code>) and pyrimidines (<code class="reqn">C+T</code>) in DNA
sequences.  It does this by checking whether or not the mononucleotide
frequencies of a DNA sequence satisfy the relationship A+G=C+T.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>agct.test(x, alg=c("exact", "simulate", "lower", "Lower", "upper"), n)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="agct.test_+3A_x">x</code></td>
<td>
<p>either a vector containing the relative frequencies of each of the 4 nucleotides 
A, C, G, T, a character vector representing a DNA sequence in which each element contains a single nucleotide, or
a DNA sequence stored using the SeqFastadna class from the <span class="pkg"><a href="seqinr.html#topic+seqinr">seqinr</a></span> package.</p>
</td></tr>
<tr><td><code id="agct.test_+3A_alg">alg</code></td>
<td>
<p>the algorithm for computing the p-value.  If set to &ldquo;&lsquo;<span class="samp">&#8288;simulate&#8288;</span>&rsquo;&rdquo;, the
p-value is obtained via Monte Carlo simulation.  If set to &ldquo;&lsquo;<span class="samp">&#8288;lower&#8288;</span>&rsquo;&rdquo;, an analytic
lower bound on the p-value is computed.  If set to &ldquo;&lsquo;<span class="samp">&#8288;upper&#8288;</span>&rsquo;&rdquo;, an analytic upper
bound on the p-value is computed.  &ldquo;&lsquo;<span class="samp">&#8288;lower&#8288;</span>&rsquo;&rdquo; and &ldquo;&lsquo;<span class="samp">&#8288;upper&#8288;</span>&rsquo;&rdquo; are based on formulae
in Hart and Martínez (2011).  a Tighter (though unpublished) lower bound on the p-value  may be obtained by specifying &ldquo;&lsquo;<span class="samp">&#8288;Lower&#8288;</span>&rsquo;&rdquo;. If
&lsquo;<span class="samp">&#8288;alg&#8288;</span>&rsquo; is specified as &ldquo;&lsquo;<span class="samp">&#8288;exact&#8288;</span>&rsquo;&rdquo; (the default value), the p-value for the test is
computed exactly.</p>
</td></tr>
<tr><td><code id="agct.test_+3A_n">n</code></td>
<td>
<p>The number of replications to use for Monte Carlo simulation.  
If computationally feasible, a value &gt;= 10000000 is recommended.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The first argument may be a character vector representing a DNA sequence, a DNA
sequence represented using the SeqFastadna class from the <span class="pkg">seqinr</span> package,
or a vector containing the relative frequencies of the A, C, G and T nucleic
acids.
</p>
<p>Let A, C, G and T denote the relative frequencies of the nucleotide bases
appearing in  a DNA sequence. This function carries out a statistical hypothesis
test that the relative frequencies satisfy the relation <code class="reqn">A+G=C+T</code>, or that
purines <code class="reqn">\{A, G\}</code> occur equally as often as pyrimidines <code class="reqn">\{C,T\}</code> in a DNA sequence.
The relationship can be rewritten as <code class="reqn">A-T=C-G</code>, from which it is easy to see
that the property being tested is a generalisation of Chargaff's second parity
rule for mononucleotides, which states that <code class="reqn">A=T</code> and <code class="reqn">C=G</code>. The test is
set up as follows:
</p>
<p><code class="reqn">H_0</code>: <code class="reqn">A+G \neq C+T</code> <br />
<code class="reqn">H_1</code>: <code class="reqn">A+G = C+T</code>
</p>
<p>The vector <code class="reqn">(A,C,G,T)</code> is assumed to come from a Dirichlet(1,1,1,1)
distribution on the 3-simplex under the null hypothesis.
</p>
<p>The test statistic <code class="reqn">\eta_V</code> is the Euclidean distance from the
relative frequency vector <code class="reqn">(A,C,G,T)</code> to the closest point in the square set
<code class="reqn">\theta_V=\{(x,y,1/2-x,1/2-y) : 0 &lt;= x,y &lt;= 1/2\}</code>, which divides the 3-simplex into two equal parts.
<code class="reqn">\eta_V</code> lies in the range <code class="reqn">[0,\sqrt{3/8}]</code>.
</p>


<h3>Value</h3>

<p>A list with class &quot;htest.ext&quot; containing the following components:
</p>
<table role = "presentation">
<tr><td><code>statistic</code></td>
<td>
<p>the value of the test statistic.</p>
</td></tr>
<tr><td><code>p.value</code></td>
<td>
<p>the p-value of the test.</p>
</td></tr>
<tr><td><code>method</code></td>
<td>
<p>a character string indicating what type of test was performed.</p>
</td></tr>
<tr><td><code>data.name</code></td>
<td>
<p>a character string giving the name of the data.</p>
</td></tr>
<tr><td><code>estimate</code></td>
<td>
<p>the probability vector used to derive the test statistic.</p>
</td></tr>
<tr><td><code>stat.desc</code></td>
<td>
<p>a brief description of the test statistic.</p>
</td></tr>
<tr><td><code>null</code></td>
<td>
<p>the null hypothesis (<code class="reqn">H_0</code>) of the test.</p>
</td></tr>
<tr><td><code>alternative</code></td>
<td>
<p>the alternative hypothesis (<code class="reqn">H_1</code>) of the test.</p>
</td></tr>
</table>


<h3>Note</h3>

<p><code>agct.test(x, alg="upper")</code> is equivalent to <code>ag.test(x,
alg="simplex")</code> except that the p-value computed using the formula for
&lsquo;<span class="samp">&#8288;alg="upper"&#8288;</span>&rsquo; is exact for the test statistic <code class="reqn">\eta_V^*</code> used in
<code><a href="#topic+ag.test">ag.test</a></code>, whereas it is merely an upper bound on the p-value for
<code class="reqn">\eta_V</code>.
</p>


<h3>Author(s)</h3>

<p>Andrew Hart and Servet Martínez
</p>


<h3>References</h3>

<p>Hart, A.G. and Martínez, S. (2011)
Statistical testing of Chargaff's second parity rule in bacterial genome sequences.
<em>Stoch. Models</em> <b>27(2)</b>, 1&ndash;46.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+chargaff0.test">chargaff0.test</a></code>, <code><a href="#topic+chargaff1.test">chargaff1.test</a></code>, 
<code><a href="#topic+chargaff2.test">chargaff2.test</a></code>, <code><a href="#topic+ag.test">ag.test</a></code>,
<code><a href="#topic+chargaff.gibbs.test">chargaff.gibbs.test</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#Demonstration on real viral sequence
data(pieris)
agct.test(pieris)

#Simulate synthetic DNA sequence that does not exhibit Purine-Pyrimidine parity
trans.mat &lt;- matrix(c(.4, .1, .4, .1, .2, .1, .6, .1, .4, .1, .3, .2, .1, .2, .4, .3), 
ncol=4, byrow=TRUE)
seq &lt;- simulateMarkovChain(500000, trans.mat, states=c("a", "c", "g", "t"))
agct.test(seq)
</code></pre>

<hr>
<h2 id='array2vector'>
Convert Arrays and Tables to Vectors with Named Elements
</h2><span id='topic+array2vector'></span><span id='topic+table2vector'></span>

<h3>Description</h3>

<p>Convert an array/table into an integer vector, preserving the names 
corresponding to each element in a sensible way.  These functions differ from 
<code><a href="base.html#topic+as.vector">as.vector</a></code> in that they name each element of the resulting vector 
by combining appropriate names from the various dimensions that together 
uniquely identify the position of each element in the original array/table.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>array2vector(x, sep=".", sort=FALSE, rev=FALSE, ...)
table2vector(x, sep=".", sort=FALSE, rev=FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="array2vector_+3A_x">x</code></td>
<td>

<p>an array or table.  
</p>
</td></tr>
<tr><td><code id="array2vector_+3A_sep">sep</code></td>
<td>

<p>a character string to be used to separate the name corresponding to each 
dimension when constructing the element names for the vector.  The default value is <code>"."</code>.
</p>
</td></tr>
<tr><td><code id="array2vector_+3A_sort">sort</code></td>
<td>

<p>Should the elements in the resulting vector be sorted in lexicographic order 
according to the names they are assigned?  The default is <code>FALSE</code>.
</p>
</td></tr>
<tr><td><code id="array2vector_+3A_rev">rev</code></td>
<td>

<p>For the purposes of sorting, should the names of the vector's elements be read 
from right-to-left, i.e. in reverse order?  The default is <code>FALSE</code>.
</p>
</td></tr>
<tr><td><code id="array2vector_+3A_...">...</code></td>
<td>

<p>Arguments to be passed from or to other functions.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>table2vector</code> is merely a convenience alias for <code>array2vector</code>, which 
converts a multi-dimensional array or table to a vector using 
<code><a href="base.html#topic+as.vector">as.vector</a></code>, but names each of the elements in the resulting vector 
according to the names contained in its <code>dimnames</code> attribute.
</p>
<p>the name of each element is constructed by concatenating names (one from each 
<code>dimnames</code> member) seperated by the value specified in <code>sep</code>.
</p>
<p>Note that dimensions of <code>x</code> which lack a corresponding vector of names in 
the <code>dimnames</code> attribute will be assigned a names vector of the form 
<code>1:d</code> where <code>d</code> is the dimension size specified in the corresponding 
entry of the <code>dim</code> attribute.
</p>


<h3>Value</h3>

<p>An integer vector with names set as described in &lsquo;Details&rsquo;.
</p>


<h3>Author(s)</h3>

<p>Andrew Hart and Servet Martínez
</p>


<h3>See Also</h3>

<p><code><a href="#topic+pair.counts">pair.counts</a></code>, <code><a href="#topic+triple.counts">triple.counts</a></code>, 
<code><a href="#topic+quadruple.counts">quadruple.counts</a></code>, <code><a href="#topic+cylinder.counts">cylinder.counts</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>a &lt;- array(1:8, dim=rep(2,3), dimnames=list(c("a","b"), c("x","p"), c("v","u")))
array2vector(a)
array2vector(a, sep="")
array2vector(a, sep="", sort=TRUE)
array2vector(a, sep="", sort=TRUE, rev=TRUE)
array2vector(a, sep="", sort=TRUE, decreasing=TRUE)
</code></pre>

<hr>
<h2 id='chargaff.gibbs.test'>Test of CSPR for Dinucleotides Under Gibbs Distribution</h2><span id='topic+chargaff.gibbs.test'></span>

<h3>Description</h3>

<p>Performs a test of Chargaff's second parity rule (CSPR) for dinucleotides under a Gibbsian assumption on the DNA sequence, which was  proposed in Hart and Martínez (2012).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>chargaff.gibbs.test(x, maxLag=200)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="chargaff.gibbs.test_+3A_x">x</code></td>
<td>
<p>either a character vector representing a DNA sequence in which each element contains a single nucleotide, or
a DNA sequence stored using the SeqFastadna class from the <span class="pkg"><a href="seqinr.html#topic+seqinr">seqinr</a></span> package.</p>
</td></tr>
<tr><td><code id="chargaff.gibbs.test_+3A_maxlag">maxLag</code></td>
<td>
<p>The maximum number of lags (cylinder lengths) to use in computing
variances.  the default value is &lsquo;<span class="samp">&#8288;200&#8288;</span>&rsquo;.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function performs a test of Chargaff's second parity rule for dinucleotides 
assuming the DNA sequence was generated by a Gibbs distribution.  Under the null 
hypothesis, the test statistic <code class="reqn">\eta</code> is asymptotically 
<code class="reqn">\chi^2</code> on 5 degrees of freedom.
</p>
<p>The test is set up as follows:
</p>
<p><code class="reqn">H_0</code>:  the sequence complies with CSPR for dinucleotides <br />
<code class="reqn">H_1</code>:  the sequence does not comply with CSPR for dinucleotides
</p>


<h3>Value</h3>

<p>A list with class &quot;htest&quot; containing the following components:
</p>
<table role = "presentation">
<tr><td><code>statistic</code></td>
<td>
<p>the value of the test statistic.</p>
</td></tr>
<tr><td><code>p.value</code></td>
<td>
<p>the p-value of the test.</p>
</td></tr>
<tr><td><code>method</code></td>
<td>
<p>a character string indicating what type of test was performed.</p>
</td></tr>
<tr><td><code>data.name</code></td>
<td>
<p>a character string giving the name of the data.</p>
</td></tr>
<tr><td><code>FHat</code></td>
<td>
<p>the 5-element vector <code class="reqn">n\hat F</code> used in calculating the test statistic.</p>
</td></tr>
<tr><td><code>pairs</code></td>
<td>
<p>the stochastic matrix of dinucleotide counts used to derive <code class="reqn">n\hat F</code>.</p>
</td></tr>
<tr><td><code>v</code></td>
<td>
<p>The asymptotic covariance matrix of <code class="reqn">n\hat F</code>.</p>
</td></tr>
<tr><td><code>n</code></td>
<td>
<p>the length of the DNA sequence.</p>
</td></tr>
<tr><td><code>cutoff</code></td>
<td>
<p>the actual number of lags used by the algorithm to calculate covariances.</p>
</td></tr>
<tr><td><code>maxCutoff</code></td>
<td>
<p>the value specified for the maxLag parameter when the test was performed.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Andrew Hart and Servet Martínez
</p>


<h3>References</h3>

<p>Hart, A.G. and Martínez, S. (2012)
A Gibbs approach to Chargaff's second parity rule.
<em>J. Stat. Phys.</em> <b>146(2)</b>, 408-422.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+chargaff0.test">chargaff0.test</a></code>, <code><a href="#topic+chargaff1.test">chargaff1.test</a></code>, 
<code><a href="#topic+chargaff2.test">chargaff2.test</a></code>, <code><a href="#topic+agct.test">agct.test</a></code>, 
<code><a href="#topic+ag.test">ag.test</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#Demonstration on real bacterial sequence
data(nanoarchaeum)
chargaff.gibbs.test(nanoarchaeum)

#Simulate synthetic DNA sequence that does not satisfy Chargaff's second parity rule
trans.mat &lt;- matrix(c(.4, .1, .4, .1, .2, .1, .6, .1, .4, .1, .3, .2, .1, .2, .4, .3), 
ncol=4, byrow=TRUE)
seq &lt;- simulateMarkovChain(500000, trans.mat, states=c("a", "c", "g", "t"))
chargaff.gibbs.test(seq)
</code></pre>

<hr>
<h2 id='chargaff0.test'>Vector Test of Chargaff's Second Parity Rule (CSPR) for Mononucleotides</h2><span id='topic+chargaff0.test'></span>

<h3>Description</h3>

<p>Performs the vector test of Chargaff's second parity rule (CSPR) for mononucleotides proposed in Hart and Martínez (2001).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>chargaff0.test(x, alg=c("exact", "simulate", "lower", "upper", "Lower", "Upper"), n, 
no.p.value=FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="chargaff0.test_+3A_x">x</code></td>
<td>
<p>either a vector containing the relative frequencies of each of the 4 nucleotides 
A, C, G, T, a character vector representing a DNA sequence in which each element contains a single nucleotide, or
a DNA sequence stored using the SeqFastadna class from the <span class="pkg"><a href="seqinr.html#topic+seqinr">seqinr</a></span> package.</p>
</td></tr>
<tr><td><code id="chargaff0.test_+3A_alg">alg</code></td>
<td>
<p>the algorithm for computing the p-value.  If set to &ldquo;&lsquo;<span class="samp">&#8288;simulate&#8288;</span>&rsquo;&rdquo;, the
p-value is obtained via Monte Carlo simulation.  If set to &ldquo;&lsquo;<span class="samp">&#8288;lower&#8288;</span>&rsquo;&rdquo;, an analytic
lower bound on the p-value is computed.  If set to &ldquo;&lsquo;<span class="samp">&#8288;upper&#8288;</span>&rsquo;&rdquo;, an analytic upper
bound on the p-value is computed.  &ldquo;&lsquo;<span class="samp">&#8288;lower&#8288;</span>&rsquo;&rdquo; and &ldquo;&lsquo;<span class="samp">&#8288;upper&#8288;</span>&rsquo;&rdquo; are based on formulae
in Hart and Martínez (2011).  a Tighter (though unpublished) lower
/upper bound on the p-value  may be obtained by specifying &ldquo;&lsquo;<span class="samp">&#8288;Lower&#8288;</span>&rsquo;&rdquo;/&ldquo;&lsquo;<span class="samp">&#8288;Upper&#8288;</span>&rsquo;&rdquo;. If
&lsquo;<span class="samp">&#8288;type&#8288;</span>&rsquo; is specified as &ldquo;&lsquo;<span class="samp">&#8288;exact&#8288;</span>&rsquo;&rdquo; (the default value),the p-value for the test is
computed exactly for small values of the test statistic and crudely approximated for large values.  See the note below for further details.</p>
</td></tr>
<tr><td><code id="chargaff0.test_+3A_n">n</code></td>
<td>
<p>The number of replications to use for Monte Carlo simulation.  
If computationally feasible, a value &gt;= 10000000 is recommended.</p>
</td></tr>
<tr><td><code id="chargaff0.test_+3A_no.p.value">no.p.value</code></td>
<td>
<p>If &lsquo;<span class="samp">&#8288;TRUE&#8288;</span>&rsquo;, do not compute the p-value.  
The default is &lsquo;<span class="samp">&#8288;FALSE&#8288;</span>&rsquo;.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The first argument may be a character vector representing a DNA sequence, a DNA
sequence represented using the SeqFastadna class from the <span class="pkg">seqinr</span> package,
or a vector containing the relative frequencies of the A, C, G and T nucleic
acids.
</p>
<p>Letting A, C, G and T denote the relative frequencies of their corresponding nucleic acids, this function performs the following hypothesis test:
</p>
<p><code class="reqn">H_0</code>: <code class="reqn">A\neq T</code> or <code class="reqn">C\neq G</code> <br />
<code class="reqn">H_1</code>: <code class="reqn">A=T</code> and <code class="reqn">C=G</code>
</p>
<p>The vector <code class="reqn">(A,C,G,T)</code> is assumed to come from a Dirichlet(1,1,1,1)
distribution on the 3-simplex under the null hypothesis.
</p>
<p>The test statistic is <code class="reqn">\eta_0 = \sqrt{(A-T)^2/2+(C-G)^2/2}</code>.
</p>


<h3>Value</h3>

<p>A list with class &quot;htest.ext&quot; containing the following components:
</p>
<table role = "presentation">
<tr><td><code>statistic</code></td>
<td>
<p>the value of the test statistic.</p>
</td></tr>
<tr><td><code>p.value</code></td>
<td>
<p>the p-value of the test. Only included if no.p.value is FALSE.</p>
</td></tr>
<tr><td><code>method</code></td>
<td>
<p>a character string indicating what type of test was performed.</p>
</td></tr>
<tr><td><code>data.name</code></td>
<td>
<p>a character string giving the name of the data.</p>
</td></tr>
<tr><td><code>estimate</code></td>
<td>
<p>the probability vector used to derive the test statistic.</p>
</td></tr>
<tr><td><code>stat.desc</code></td>
<td>
<p>a brief description of the test statistic.</p>
</td></tr>
<tr><td><code>null</code></td>
<td>
<p>the null hypothesis (<code class="reqn">H_0</code>) of the test.</p>
</td></tr>
<tr><td><code>alternative</code></td>
<td>
<p>the alternative hypothesis (<code class="reqn">H_1</code>) of the test.</p>
</td></tr>
</table>


<h3>Note</h3>

<p>Currently, regardless of the algorithm (<code>alg</code>) selected, the p-value or
bound is only computed correctly when the test statistic is smaller than or
equal to <code class="reqn">\sqrt{2}/4</code>.  A value of 1 is returned when 
the test statistic is greater than <code class="reqn">\sqrt{2}/4</code>.  This is not
accurate, but shouldn't matter as it is well within the acceptance region of the
null hypothesis.
</p>
<p>The algebraically computed bounds on the p-value obtained when &lsquo;<span class="samp">&#8288;alg&#8288;</span>&rsquo; is set
to either &ldquo;&lsquo;<span class="samp">&#8288;lower&#8288;</span>&rsquo;&rdquo;or  &ldquo;&lsquo;<span class="samp">&#8288;upper&#8288;</span>&rsquo;&rdquo; are not as tight as
those corresponding to &ldquo;&lsquo;<span class="samp">&#8288;Lower&#8288;</span>&rsquo;&rdquo; and &ldquo;&lsquo;<span class="samp">&#8288;Upper&#8288;</span>&rsquo;&rdquo;, which  should be
generally preferred.  However, &ldquo;&lsquo;<span class="samp">&#8288;exact&#8288;</span>&rsquo;&rdquo; or &ldquo;&lsquo;<span class="samp">&#8288;simulate&#8288;</span>&rsquo;&rdquo;
should be employed for real- world analysis.
</p>
<p>&lsquo;<span class="samp">&#8288;no.p.value&#8288;</span>&rsquo; suppresses computation of the p-value when it is set to
&lsquo;<span class="samp">&#8288;TRUE&#8288;</span>&rsquo;.  This may be useful wen using this function to help simulate the
test statistic.
</p>


<h3>Author(s)</h3>

<p>Andrew Hart and Servet Martínez
</p>


<h3>References</h3>

<p>Hart, A.G. and Martínez, S. (2011)
Statistical testing of Chargaff's second parity rule in bacterial genome sequences.
<em>Stoch. Models</em> <b>27(2)</b>, 1&ndash;46.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+chargaff1.test">chargaff1.test</a></code>, <code><a href="#topic+chargaff2.test">chargaff2.test</a></code>, 
<code><a href="#topic+agct.test">agct.test</a></code>, <code><a href="#topic+ag.test">ag.test</a></code>, 
<code><a href="#topic+chargaff.gibbs.test">chargaff.gibbs.test</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#Demonstration on real bacterial sequence
data(nanoarchaeum)
chargaff0.test(nanoarchaeum)

#Simulate synthetic DNA sequence that does not satisfy Chargaff's second parity rule
trans.mat &lt;- matrix(c(.4, .1, .4, .1, .2, .1, .6, .1, .4, .1, .3, .2, .1, .2, .4, .3), 
ncol=4, byrow=TRUE)
seq &lt;- simulateMarkovChain(500000, trans.mat, states=c("a", "c", "g", "t"))
chargaff0.test(seq)
</code></pre>

<hr>
<h2 id='chargaff1.test'>Matrix Test of CSPR for Mononucleotides</h2><span id='topic+chargaff1.test'></span>

<h3>Description</h3>

<p>Performs a test of Chargaff's second parity rule (CSPR) for mononucleotides on a genomic sequence using a 4X4 stochastic matrix 
estimated from the sequence.  The test was proposed by
Hart and Martínez (2011).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>chargaff1.test(x, alg=c("table", "simulate", "upper"), n, no.p.value=FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="chargaff1.test_+3A_x">x</code></td>
<td>
<p>either a vector containing the relative frequencies of each of the 4 nucleotides 
A, C, G, T, a character vector representing a DNA sequence in which each element contains a single nucleotide, or
a DNA sequence stored using the SeqFastadna class from the <span class="pkg"><a href="seqinr.html#topic+seqinr">seqinr</a></span> package.</p>
</td></tr>
<tr><td><code id="chargaff1.test_+3A_alg">alg</code></td>
<td>
<p>the algorithm for computing the p-value.  If set to &ldquo;&lsquo;<span class="samp">&#8288;simulate&#8288;</span>&rsquo;&rdquo;, the
p-value is obtained via Monte Carlo simulation.  If set to &ldquo;&lsquo;<span class="samp">&#8288;upper&#8288;</span>&rsquo;&rdquo;, an analytic upper
bound on the p-value is computed.  &ldquo;&lsquo;<span class="samp">&#8288;upper&#8288;</span>&rsquo;&rdquo; are based on formulae
in Hart and Martínez (2011).  If
&lsquo;<span class="samp">&#8288;type&#8288;</span>&rsquo; is specified as &ldquo;&lsquo;<span class="samp">&#8288;table&#8288;</span>&rsquo;&rdquo; (the default value),the p-value for the test is
obtained from a linear interpolation of a look-up table.  See the note below for further details.</p>
</td></tr>
<tr><td><code id="chargaff1.test_+3A_n">n</code></td>
<td>
<p>The number of replications to use for Monte Carlo simulation.  
If computationally feasible, a value &gt;= 10000000 is recommended.</p>
</td></tr>
<tr><td><code id="chargaff1.test_+3A_no.p.value">no.p.value</code></td>
<td>
<p>If &lsquo;<span class="samp">&#8288;TRUE&#8288;</span>&rsquo;, do not compute the p-value.  
The default is &lsquo;<span class="samp">&#8288;FALSE&#8288;</span>&rsquo;.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The first argument may be a character vector representing a DNA sequence, a DNA
sequence represented using the SeqFastadna class from the <span class="pkg">seqinr</span> package,
or a vector containing the relative frequencies of the A, C, G and T nucleic
acids.
</p>
<p>This function performs a test of Chargaff's second parity rule for
mononucleotides based on a 4X4 stochastic matrix <code class="reqn">P</code> estimated from the
empirical dinucleotide distribution of a genomic sequence .  The <code class="reqn">a,b)</code>
entry of <code class="reqn">P</code> gives the empirical probability (relative frequency) that a
nucleotide <code class="reqn">a</code> is followed by a nucleotide <code class="reqn">b</code> in the sequence. The test
is set up as follows:
</p>
<p><code class="reqn">H_0</code>:  the sequence (or matrix <code class="reqn">P</code>) does not comply with CSPR for mononucleotides <br />
<code class="reqn">H_1</code>:  the sequence (or matrix <code class="reqn">P</code>) complies with CSPR for mononucleotides
</p>


<h3>Value</h3>

<p>A list with class &quot;htest.ext&quot; containing the following components:
</p>
<table role = "presentation">
<tr><td><code>statistic</code></td>
<td>
<p>the value of the test statistic.</p>
</td></tr>
<tr><td><code>p.value</code></td>
<td>
<p>the p-value of the test. Only included if no.p.value is FALSE.</p>
</td></tr>
<tr><td><code>method</code></td>
<td>
<p>a character string indicating what type of test was performed.</p>
</td></tr>
<tr><td><code>data.name</code></td>
<td>
<p>a character string giving the name of the data.</p>
</td></tr>
<tr><td><code>f</code></td>
<td>
<p>the 2-element vector used in calculating the test statistic.</p>
</td></tr>
<tr><td><code>estimate</code></td>
<td>
<p>the stochastic matrix <code class="reqn">P</code> used to derive the test statistic.</p>
</td></tr>
<tr><td><code>stat.desc</code></td>
<td>
<p>a brief description of the test statistic.</p>
</td></tr>
<tr><td><code>null</code></td>
<td>
<p>the null hypothesis (<code class="reqn">H_0</code>) of the test.</p>
</td></tr>
<tr><td><code>alternative</code></td>
<td>
<p>the alternative hypothesis (<code class="reqn">H_1</code>) of the test.</p>
</td></tr>
</table>


<h3>Note</h3>

<p>Currently, the look-up table that is employed when &lsquo;<span class="samp">&#8288;alg&#8288;</span>&rsquo; is set to
&ldquo;&lsquo;<span class="samp">&#8288;table&#8288;</span>&rsquo;&rdquo; does not provide an accurate p-value when the statistic is
smaller than 0.00806.  Care should be taken when adjusting p-values for multiple testing.
</p>
<p>The algebraically computed upper bound on the p-value obtained when &lsquo;<span class="samp">&#8288;alg&#8288;</span>&rsquo;
is set to &ldquo;&lsquo;<span class="samp">&#8288;upper&#8288;</span>&rsquo;&rdquo; is not very tight and not suitable for real-
world applications.
</p>
<p>&lsquo;<span class="samp">&#8288;no.p.value&#8288;</span>&rsquo; suppresses computation of the p-value when it is set to
&lsquo;<span class="samp">&#8288;TRUE&#8288;</span>&rsquo;.  This may be useful wen using this function to help simulate the
test statistic.
</p>


<h3>Author(s)</h3>

<p>Andrew Hart and Servet Martínez
</p>


<h3>References</h3>

<p>Hart, A.G. and Martínez, S. (2011)
Statistical testing of Chargaff's second parity rule in bacterial genome sequences.
<em>Stoch. Models</em> <b>27(2)</b>, 1&ndash;46.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+chargaff0.test">chargaff0.test</a></code>, <code><a href="#topic+chargaff2.test">chargaff2.test</a></code>, 
<code><a href="#topic+agct.test">agct.test</a></code>, <code><a href="#topic+ag.test">ag.test</a></code>,
<code><a href="#topic+chargaff.gibbs.test">chargaff.gibbs.test</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#Demonstration on real bacterial sequence
data(nanoarchaeum)
chargaff1.test(nanoarchaeum)

#Simulate synthetic DNA sequence that does not satisfy Chargaff's second parity rule
trans.mat &lt;- matrix(c(.4, .1, .4, .1, .2, .1, .6, .1, .4, .1, .3, .2, .1, .2, .4, .3), 
ncol=4, byrow=TRUE)
seq &lt;- simulateMarkovChain(500000, trans.mat, states=c("a", "c", "g", "t"))
chargaff1.test(seq)
</code></pre>

<hr>
<h2 id='chargaff2.test'>Matrix Test of CSPR for Dinucleotides</h2><span id='topic+chargaff2.test'></span>

<h3>Description</h3>

<p>Performs the matrix test of Chargaff's second parity rule (CSPR) for dinucleotides proposed in Hart and Martínez (2011).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>chargaff2.test(x, alg=c("table", "simulate", "upper"), n, no.p.value=FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="chargaff2.test_+3A_x">x</code></td>
<td>
<p>either a vector containing the relative frequencies of each of the 4 nucleotides 
A, C, G, T, a character vector representing a DNA sequence in which each element contains a single nucleotide, or
a DNA sequence stored using the SeqFastadna class from the <span class="pkg"><a href="seqinr.html#topic+seqinr">seqinr</a></span> package.</p>
</td></tr>
<tr><td><code id="chargaff2.test_+3A_alg">alg</code></td>
<td>
<p>the algorithm for computing the p-value.  If set to &ldquo;&lsquo;<span class="samp">&#8288;simulate&#8288;</span>&rsquo;&rdquo;, the
p-value is obtained via Monte Carlo simulation.  If set to &ldquo;&lsquo;<span class="samp">&#8288;upper&#8288;</span>&rsquo;&rdquo;, an analytic upper
bound on the p-value is computed.  &ldquo;&lsquo;<span class="samp">&#8288;upper&#8288;</span>&rsquo;&rdquo; are based on formulae
in Hart and Martínez (2011).  If
&lsquo;<span class="samp">&#8288;type&#8288;</span>&rsquo; is specified as &ldquo;&lsquo;<span class="samp">&#8288;table&#8288;</span>&rsquo;&rdquo; (the default value),the p-value for the test is
obtained from a linear interpolation of a look-up table.  See the note below for further details.</p>
</td></tr>
<tr><td><code id="chargaff2.test_+3A_n">n</code></td>
<td>
<p>The number of replications to use for Monte Carlo simulation.  
If computationally feasible, a value &gt;= 10000000 is recommended.</p>
</td></tr>
<tr><td><code id="chargaff2.test_+3A_no.p.value">no.p.value</code></td>
<td>
<p>If &lsquo;<span class="samp">&#8288;TRUE&#8288;</span>&rsquo;, do not compute the p-value.  
The default is &lsquo;<span class="samp">&#8288;FALSE&#8288;</span>&rsquo;.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function performs a test of Chargaff's second parity rule for
dinucleotides based on a 4X4 stochastic matrix <code class="reqn">\hat P</code> estimated from the
empirical dinucleotide distribution of a genomic sequence .  The <code class="reqn">a,b)</code>
entry of <code class="reqn">\hat P</code> gives the empirical probability (relative frequency) that a
nucleotide <code class="reqn">a</code> is followed by a nucleotide <code class="reqn">b</code> in the sequence. The test
is set up as follows:
</p>
<p><code class="reqn">H_0</code>:  the sequence (or matrix <code class="reqn">\hat P</code>) does not comply with CSPR for dinucleotides <br />
<code class="reqn">H_1</code>:  the sequence (or matrix <code class="reqn">\hat P</code>) complies with CSPR for dinucleotides
</p>


<h3>Value</h3>

<p>A list with class &quot;htest.ext&quot; containing the following components:
</p>
<table role = "presentation">
<tr><td><code>statistic</code></td>
<td>
<p>the value of the test statistic.</p>
</td></tr>
<tr><td><code>p.value</code></td>
<td>
<p>the p-value of the test. Only included if no.p.value is FALSE.</p>
</td></tr>
<tr><td><code>method</code></td>
<td>
<p>a character string indicating what type of test was performed.</p>
</td></tr>
<tr><td><code>data.name</code></td>
<td>
<p>a character string giving the name of the data.</p>
</td></tr>
<tr><td><code>f</code></td>
<td>
<p>the 5-element vector used in calculating the test statistic.</p>
</td></tr>
<tr><td><code>estimate</code></td>
<td>
<p>the stochastic matrix <code class="reqn">\hat P</code> used to derive the test statistic.</p>
</td></tr>
<tr><td><code>stat.desc</code></td>
<td>
<p>a brief description of the test statistic.</p>
</td></tr>
<tr><td><code>null</code></td>
<td>
<p>the null hypothesis (<code class="reqn">H_0</code>) of the test.</p>
</td></tr>
<tr><td><code>alternative</code></td>
<td>
<p>the alternative hypothesis (<code class="reqn">H_1</code>) of the test.</p>
</td></tr>
</table>


<h3>Note</h3>

<p>Currently, the look-up table that is employed when &lsquo;<span class="samp">&#8288;alg&#8288;</span>&rsquo; is set to
&ldquo;&lsquo;<span class="samp">&#8288;table&#8288;</span>&rsquo;&rdquo; does not provide an accurate p-value when the statistic is
smaller than 0.05899. Care should be taken when adjusting p-values for multiple testing.
</p>
<p>The algebraically computed upper bound on the p-value obtained when &lsquo;<span class="samp">&#8288;alg&#8288;</span>&rsquo;
is set to &ldquo;&lsquo;<span class="samp">&#8288;upper&#8288;</span>&rsquo;&rdquo; is not very tight and not suitable for real-
world applications.
</p>
<p>&lsquo;<span class="samp">&#8288;no.p.value&#8288;</span>&rsquo; suppresses computation of the p-value when it is set to
&lsquo;<span class="samp">&#8288;TRUE&#8288;</span>&rsquo;.  This may be useful wen using this function to help simulate the
test statistic.
</p>


<h3>Author(s)</h3>

<p>Andrew Hart and Servet Martínez
</p>


<h3>References</h3>

<p>Hart, A.G. and Martínez, S. (2011)
Statistical testing of Chargaff's second parity rule in bacterial genome sequences.
<em>Stoch. Models</em> <b>27(2)</b>, 1&ndash;46.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+chargaff0.test">chargaff0.test</a></code>, <code><a href="#topic+chargaff1.test">chargaff1.test</a></code>
<code><a href="#topic+agct.test">agct.test</a></code>, <code><a href="#topic+ag.test">ag.test</a></code>,
<code><a href="#topic+chargaff.gibbs.test">chargaff.gibbs.test</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#Demonstration on real bacterial sequence
data(nanoarchaeum)
chargaff2.test(nanoarchaeum)

#Simulate synthetic DNA sequence that does not satisfy Chargaff's second parity rule
trans.mat &lt;- matrix(c(.4, .1, .4, .1, .2, .1, .6, .1, .4, .1, .3, .2, .1, .2, .4, .3), 
ncol=4, byrow=TRUE)
seq &lt;- simulateMarkovChain(500000, trans.mat, states=c("a", "c", "g", "t"))
chargaff2.test(seq)
</code></pre>

<hr>
<h2 id='chisq.unif.test'>
Test of Uniformity Based on Pearsons's Chi-Squared test
</h2><span id='topic+chisq.unif.test'></span>

<h3>Description</h3>

<p>Tests if a set of data points is uniformly distributed over a specified interval [a,b].
</p>


<h3>Usage</h3>

<pre><code class='language-R'>chisq.unif.test(x, bins=NULL, interval=c(0,1), min.bin.size=10, all.inside=TRUE, 
rightmost.closed=TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="chisq.unif.test_+3A_x">x</code></td>
<td>
<p>A numeric vector of data values.</p>
</td></tr>
<tr><td><code id="chisq.unif.test_+3A_bins">bins</code></td>
<td>
<p>If specified, the number of bins to use to discretise the
interval.  Otherwise, the number of bins will be chosen automatically.</p>
</td></tr>
<tr><td><code id="chisq.unif.test_+3A_interval">interval</code></td>
<td>
<p>A two-element vector giving the support of the uniform distribution.  The
default is <code>c(0,1)</code>.</p>
</td></tr>
<tr><td><code id="chisq.unif.test_+3A_min.bin.size">min.bin.size</code></td>
<td>
<p>The minimum number of data points to have in each bin.  If
bins cannot be chosen without violating this constraint, an error is
generated.  The default is 10.  This parameter is ignored if &lsquo;<span class="samp">&#8288;bins&#8288;</span>&rsquo; 
is specified.</p>
</td></tr>
<tr><td><code id="chisq.unif.test_+3A_all.inside">all.inside</code></td>
<td>
<p>Determines if data points outside the interval should be counted as belonging to the extremal bins.  The default is &lsquo;<span class="samp">&#8288;TRUE&#8288;</span>&rsquo;.</p>
</td></tr>
<tr><td><code id="chisq.unif.test_+3A_rightmost.closed">rightmost.closed</code></td>
<td>
<p>Determines if data points that coinside
with<code>interval[2]</code> are counted as belonging to the last bin.  This
parameter only has an effect if <code>all.inside</code> is set to <code>FALSE</code>.  The
default is <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="chisq.unif.test_+3A_...">...</code></td>
<td>
<p>Additional parameters to be passed to <code><a href="stats.html#topic+chisq.test">chisq.test</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function tests the fit of a set of data points to a uniform distribution on
<code class="reqn">[a,b]</code> by partitioning <code class="reqn">[a,b]</code> into &lsquo;<span class="samp">&#8288;bins&#8288;</span>&rsquo; bins, counting how many
points fall in each bin and then testing that the points are equally distributed
among the bins using Pearson's chi-squared test.
</p>
<p>When &lsquo;<span class="samp">&#8288;bins&#8288;</span>&rsquo; is not specified, its value is selected using the following
heuristic.  Let <code class="reqn">n</code> be the number of data points.  If <code class="reqn">n&gt;200</code>, then
&lsquo;<span class="samp">&#8288;bins&#8288;</span>&rsquo; is set to 20.  Otherwise, &lsquo;<span class="samp">&#8288;bins&#8288;</span>&rsquo; is set to <code class="reqn">n/10</code>.
Next,while there is a bin containing fewer than &lsquo;<span class="samp">&#8288;min.bin.size&#8288;</span>&rsquo; points in
the resulting partition, &lsquo;<span class="samp">&#8288;bins&#8288;</span>&rsquo; is decremented by one.  This process stops
either when &lsquo;<span class="samp">&#8288;bins&#8288;</span>&rsquo; is equal to 1 or every bin contains at least
&lsquo;<span class="samp">&#8288;min.bin.size&#8288;</span>&rsquo; points.
</p>


<h3>Value</h3>

<p>A list with class &ldquo;htest&rdquo; containing the following components:
</p>
<table role = "presentation">
<tr><td><code>statistic</code></td>
<td>
<p>the value of the test statistic.</p>
</td></tr>
<tr><td><code>parameter</code></td>
<td>
<p>A vector containing the degrees of freedom  of the chi-squared
test (df), the left end of the interval (a) and the right end of the interval
(b).</p>
</td></tr>
<tr><td><code>p.value</code></td>
<td>
<p>the p-value of the test.</p>
</td></tr>
<tr><td><code>method</code></td>
<td>
<p>a character string indicating what type of test was performed.</p>
</td></tr>
<tr><td><code>data.name</code></td>
<td>
<p>a character string giving the name of the data.</p>
</td></tr>
<tr><td><code>bins</code></td>
<td>
<p>The number of bins used for the test.</p>
</td></tr>
<tr><td><code>min.bin.size</code></td>
<td>
<p>The minimum bin size.</p>
</td></tr>
<tr><td><code>interval</code></td>
<td>
<p>The interval used for the test.</p>
</td></tr>
</table>


<h3>Warning</h3>

<p>The arguments &lsquo;<span class="samp">&#8288;all.inside&#8288;</span>&rsquo; and &lsquo;<span class="samp">&#8288;rightmost.closed&#8288;</span>&rsquo; are included 
for experimentation and should be altered with caution.
</p>


<h3>Author(s)</h3>

<p>Andrew Hart and Servet Martínez
</p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+chisq.test">chisq.test</a></code>, <code><a href="base.html#topic+findInterval">findInterval</a></code>, <code><a href="#topic+ks.unif.test">ks.unif.test</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#Generate an IID uniform(0,1) sequence
u &lt;- runif(1000)
chisq.unif.test(u)
</code></pre>

<hr>
<h2 id='complement'>
Complement of a DNA/RNA Sequence
</h2><span id='topic+complement'></span><span id='topic+complement.default'></span><span id='topic+complement.SeqFastadna'></span><span id='topic+complement.list'></span>

<h3>Description</h3>

<p>Compute the complement of a DNA or RNA sequence.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## Default S3 method:
complement(x, content=c("dna", "rna"), 
case=c("lower", "upper", "as is"), ...)
## S3 method for class 'SeqFastadna'
complement(x, ...)
## S3 method for class 'list'
complement(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="complement_+3A_x">x</code></td>
<td>

<p>A character vector, an object that can be coersed to a character vector or a 
list of objects that canbe be converted to character vectors.  this argument 
can also be a <code>SeqFastadna</code> object provided by the <span class="pkg">seqinr</span> package.
</p>
</td></tr>
<tr><td><code id="complement_+3A_content">content</code></td>
<td>

<p>The content type of sequence(s).  At present, supported types include 
&ldquo;<code>dna</code>&rdquo; and &ldquo;<code>rna</code>&rdquo;.  the default type is 
&ldquo;<code>dna</code>&rdquo;. 
</p>
</td></tr>
<tr><td><code id="complement_+3A_case">case</code></td>
<td>

<p>Determines how symbols in <code>x</code> should be treated before translating them 
into their complements. &ldquo;<code>lower</code>&rdquo;, the default behaviour, converts 
all symbols to lowercase while &ldquo;<code>upper</code>&rdquo; converts them to 
uppercase.  &ldquo;<code>as is</code>&rdquo; allows the symbols to pass unchanged so that the case 
of each output symbol matches that of the corresponding input symbol.
</p>
</td></tr>
<tr><td><code id="complement_+3A_...">...</code></td>
<td>

<p>Arguments to be passed from or to other functions.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If <code>x</code> is a SeqFastadna object or a character vector in which each element 
is a single nucleobase, then it represents a single sequence and its 
complementary sequence will be returned in the same form.
</p>
<p>On the other hand, if <code>x</code> is a vector of character strings, each of which 
represents a nucleic sequence, then the result will bea a character vector in 
which each element contains the complement of the corresponding element 
in <code>x</code> as a character string.
</p>


<h3>Value</h3>

<p>According to the input <code>x</code>, a character vector, SeqFastadna object or list 
containing the complement(s) of the sequence(s) in <code>x</code>.
</p>


<h3>Author(s)</h3>

<p>Andrew Hart and Servet Martínez
</p>


<h3>See Also</h3>

<p><code><a href="#topic+reverseComplement">reverseComplement</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>complement("actg")
complement(c("t", "g", "a"))

#List of sequences
some.dna &lt;- list("atgcgtcgttaa", c("g", "t", "g", "a", "a", "a"))
complement(some.dna)

#RNA sequence example
complement(c("a", "u", "g"), content="rna")

#Examples of lowercase, uppercase and as-is conversion
mixed.case &lt;- c("t", "G", "g", "C", "a")
complement(mixed.case)
complement(mixed.case, case="upper")
complement(mixed.case, case="as is")
</code></pre>

<hr>
<h2 id='cylinder.counts'>
Count Cylinders (Fixed-Offset Patterns) in Character Vectors
</h2><span id='topic+cylinder.counts'></span>

<h3>Description</h3>

<p>Count fixed tuples of not necessarily adjacent symbols/elements in a character vector.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cylinder.counts(x, cylinder, case=c("lower", "upper", "as is"), circular=TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="cylinder.counts_+3A_x">x</code></td>
<td>

<p>a character vector or an object that can be coersed to a character vector.
</p>
</td></tr>
<tr><td><code id="cylinder.counts_+3A_cylinder">cylinder</code></td>
<td>

<p>A vector of indices specifying the form of cylinders to count.  See &lsquo;Details&rsquo;.
</p>
</td></tr>
<tr><td><code id="cylinder.counts_+3A_case">case</code></td>
<td>

<p>determines how labels for the array should be generated: in
lowercase, in uppercase or left as is, in which case labels such as &ldquo;b&rdquo;
and &ldquo;B&rdquo; will be seen as distinct symbols and counted separately.
</p>
</td></tr>
<tr><td><code id="cylinder.counts_+3A_circular">circular</code></td>
<td>

<p>Determines if the vector should be treated as circular or not.  The default is 
<code>TRUE</code>, meaning that the start and end of the sequence will be joined 
together for the purpose of counting.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>cylinder</code> represents a set of symbol patterns that one wishes to count in 
the sequence <code>x</code>. For example, if <code>cylinder</code> is <code>c(1,3,5)</code>, then 
this function will count occurrences of all patterns of the form &lsquo;<span class="samp">&#8288;u.v.w&#8288;</span>&rsquo;, 
where &lsquo;<span class="samp">&#8288;u&#8288;</span>&rsquo;, &lsquo;<span class="samp">&#8288;v&#8288;</span>&rsquo; and &lsquo;<span class="samp">&#8288;w&#8288;</span>&rsquo; can be any symbol present in <code>x</code> and 
<code>.</code> stands for a symbol whose value is not relevant to the pattern.    
</p>
<p>Suppose that <code>x</code> is a sequence of the nucleotides <code>a</code>, <code>c</code>, 
<code>g</code> and <code>t</code>.  Then, <code>cylinder=1:2</code> will count the occurrences of 
all 16 dinucleotides: <code>aa</code>, <code>ac</code>, <code>ag</code>, <code>at</code>, <code>ca</code>, 
<code>cc</code>, ....  In contrast, <code>cylinder=c(1,3)</code> will counts 16 sets of 
trinucleotides:  <code>a.a</code>, <code>a.c</code>, <code>a.g</code>, <code>a.t</code>, <code>c.a</code>, 
<code>c.c</code>, <code>c.g</code>, ....  the dot &ldquo;<code>.</code>&rdquo; stands for any 
nucleotide, so that <code>a.c</code> represents the set <code>aac</code>, <code>acc</code>, 
<code>agc</code>, <code>atg</code>.  In both of these examples, a <code class="reqn">4\times 4</code> 
array of counts will be produced, but in the first case the array will 
represent counts of dinucleotides, while in the second case it will represent 
counts of groups of trinucleotides.
</p>
<p>If <code>circular</code> is <code>TRUE</code>, the vector <code>x</code> is treated as circular so that the 
some of all the counts in the resulting array is equal to the length of the 
vector and the sums across all dimentions of the array are equivalent, that is: 
writing<br />
<code>counts &lt;- cylinder.counts(x, cylinder=c(1,3,5))</code> <br />
for some character sequence x, then <br />
<code>apply(counts,1,sum)</code>, <code>apply(counts,2,sum)</code> and <code>apply(counts,3,sum)</code><br />
will all be identical.
</p>
<p>On the other hand, if <code>circular</code> is <code>FALSE</code>, the sum of all the 
entries in the counts array will be less than the length of the vector and 
there will be a discrepancy between the sums over the various dimensions.
</p>


<h3>Value</h3>

<p>An <code class="reqn">n</code>-dimensional array of counts, where <code class="reqn">n</code> is the length of 
<code>cylinder</code>.
</p>


<h3>Note</h3>

<p><code><a href="base.html#topic+table">table</a></code>is more efficient (by almost a factor of 2) at computing the 
counts of cylinders of length 1, whereas <code>cylinder.counts</code> is faster and 
uses less memory than  for cylinders of length greater than 1.  
</p>


<h3>Author(s)</h3>

<p>Andrew Hart and Servet Martínez
</p>


<h3>See Also</h3>

<p><code><a href="#topic+pair.counts">pair.counts</a></code>, <code><a href="#topic+triple.counts">triple.counts</a></code>, 
<code><a href="#topic+quadruple.counts">quadruple.counts</a></code>, 
<code><a href="#topic+array2vector">array2vector</a></code>, <code><a href="#topic+table2vector">table2vector</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#Generate an IID uniform DNA sequence
seq &lt;- simulateMarkovChain(5000, matrix(0.25, 4, 4), states=c("a","c","g","t"))
cylinder.counts(seq, 1) #essentially the same as unclass(table(seq))
cylinder.counts(seq, 1:5) #counts of all 5-mers in the sequence

 #counts of all patterns of the form a.b where a and b represent
 #specific symbols and . denotes an arbitrary symbol.
 pat &lt;- cylinder.counts(seq, c(1, 3))
#For example, pat["a","c"] gives the number of times that any of 
#the following 4 words appears in the sequence:  aac, acc, agc, atc.
identical(cylinder.counts(seq, c(1,3)), apply(cylinder.counts(seq, 1:3), c(1, 3), sum))

##some relationships between cylinder.counts and other functionns
identical(cylinder.counts(seq, 1:2), pair.counts(seq))
identical(cylinder.counts(seq, 1:3), triple.counts(seq))
identical(cylinder.counts(seq, 1:4), quadruple.counts(seq))

#The following relationship means that counts on circular sequences are 
#invariant under translationn
identical(cylinder.counts(seq, 1:6), cylinder.counts(seq, 10:15))

#Treating seq as non circular, most of the preceding relationships continue to hold
identical(cylinder.counts(seq, 1:2, circular=FALSE), 
  pair.counts(seq, circular=FALSE))
identical(cylinder.counts(seq, 1:3, circular=FALSE), 
triple.counts(seq, circular=FALSE))
identical(cylinder.counts(seq, 1:4, circular=FALSE), 
  quadruple.counts(seq, circular=FALSE))
#The following relationship no longer holds; that is, non-circular counts
#are not invariant under translation.
identical(cylinder.counts(seq, 1:6, circular=FALSE), 
  cylinder.counts(seq, 10:15, circular=FALSE))
</code></pre>

<hr>
<h2 id='diffsign.test'>
the Differents-Sign Test of Statistical Independence
</h2><span id='topic+diffsign.test'></span>

<h3>Description</h3>

<p>Tests for a trend in a data series by comparing the number of positive differences between successive elements in the series to the number expected in an i.i.d. series.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>diffsign.test(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="diffsign.test_+3A_x">x</code></td>
<td>

<p>a numeric vector or univariate time series.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Perform a test for trend based on the signs of successive differences in a data series.
#this function counts the number of positive successive differences in the data, standardises #it to have mean 0 and variance 1 and asymptotically tests it against a 
standard normal distribution.  the test statistic is:
</p>
<p>D = (pd - mu)/sigma, where <br />
pd is the number of positive differences in the data series, <br />
mu = (n-1)/2, <br />
sigma = sqrt((n+1)/12) and <br />
n is the number of points in the data series.
</p>
<p>The test is set up as follows:
</p>
<p><code class="reqn">H_0</code>:  the data series is i.i.d. (not trending) <br />
<code class="reqn">H_1</code>:  the data series is not i.i.d. (trending)
</p>


<h3>Value</h3>

<p>A list with class &quot;htest&quot; containing the following components:
</p>
<table role = "presentation">
<tr><td><code>statistic</code></td>
<td>
<p>the value of the test statistic.</p>
</td></tr>
<tr><td><code>p.value</code></td>
<td>
<p>the p-value of the test.</p>
</td></tr>
<tr><td><code>method</code></td>
<td>
<p>a character string indicating what type of test was performed.</p>
</td></tr>
<tr><td><code>data.name</code></td>
<td>
<p>a character string giving the name of the data.</p>
</td></tr>
<tr><td><code>n</code></td>
<td>
<p>the number of points in the data series.</p>
</td></tr>
<tr><td><code>mu</code></td>
<td>
<p>The expected number of positive differences that would be seen in an i.i.d. series.</p>
</td></tr>
<tr><td><code>sigma</code></td>
<td>
<p>The standard deviation of the number of positive differences that would be seen in an i.i.d. series.</p>
</td></tr>
</table>


<h3>Note</h3>

<p>Missing values are not handled. 
</p>
<p>Points followed by a point having the exact same value are removed from the data series before computing the test statistic.
</p>
<p>This test is useful for detecting linear trends in  data series.
</p>


<h3>Author(s)</h3>

<p>Andrew Hart and Servet Martínez
</p>


<h3>References</h3>

<p>Brockwell, Peter J., Davis, Richard A. (2002) <em>Introduction to Time Series and Forecasting</em>.
Springer Texts in Statistics, Springer-Verlag, New York.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+turningpoint.test">turningpoint.test</a></code>, <code><a href="#topic+rank.test">rank.test</a></code>, <code><a href="#topic+lb.test">lb.test</a></code>
<code><a href="#topic+markov.test">markov.test</a></code>, <code><a href="#topic+diid.test">diid.test</a></code>,
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#Generate an IID standard normal sequence
n &lt;- rnorm(1000)
diffsign.test(n)
</code></pre>

<hr>
<h2 id='diid.disturbance'>
Construct feasible Random Noise Generating a Bernoulli Process
</h2><span id='topic+diid.disturbance'></span>

<h3>Description</h3>

<p>Produces a sequence of random noise which would generate an observed sequence of
finite symbols provided that the sequence of symbols results from a Bernoulli 
process.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>diid.disturbance(x, random = TRUE,  estimates = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="diid.disturbance_+3A_x">x</code></td>
<td>

<p>A sequence of finite symbols represented  as a  character vector.
</p>
</td></tr>
<tr><td><code id="diid.disturbance_+3A_random">random</code></td>
<td>
<p>This can be a logical value or a number in the range 0-1. If &lsquo;<span class="samp">&#8288;TRUE&#8288;</span>&rsquo;, random
noise will be generated.  If &lsquo;<span class="samp">&#8288;FALSE&#8288;</span>&rsquo;, the constant value 0.5 will be used
as the noise source.  If a value in the range 0-1 is specified, that value will
be used as a constant noise source.  the default value is &lsquo;<span class="samp">&#8288;TRUE&#8288;</span>&rsquo;.
</p>
</td></tr>
<tr><td><code id="diid.disturbance_+3A_estimates">estimates</code></td>
<td>

<p>A logical value specifying if the distribution estimated for the Bernoulli process should be included in
the return.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>If &lsquo;<span class="samp">&#8288;estimates&#8288;</span>&rsquo; is &lsquo;<span class="samp">&#8288;TRUE&#8288;</span>&rsquo;, returns a list containing the following components:
</p>
<table role = "presentation">
<tr><td><code>disturbance</code></td>
<td>
<p>the sequence of random noise as a numeric vector.</p>
</td></tr>
<tr><td><code>stat.dist</code></td>
<td>
<p>The stationary distribution estimated from x.</p>
</td></tr>
</table>
<p>Otherwise, if &lsquo;<span class="samp">&#8288;estimate&#8288;</span>&rsquo; is &lsquo;<span class="samp">&#8288;FALSE&#8288;</span>&rsquo;, returns the sequence of random
noise as a numeric vector.
</p>


<h3>Author(s)</h3>

<p>Andrew Hart and Servet Martínez
</p>


<h3>See Also</h3>

<p><code><a href="#topic+markov.test">markov.test</a></code>, <code><a href="#topic+diid.test">diid.test</a></code>, <code><a href="#topic+markov.disturbance">markov.disturbance</a></code>
</p>

<hr>
<h2 id='diid.test'>
A Test for a Bernoulli Scheme (IID Sequence)
</h2><span id='topic+diid.test'></span>

<h3>Description</h3>

<p>Tests whether or not a data series  constitutes a Bernoulli scheme, that is, an 
independent and identically distributed (IID) sequence of symbols, by inferring the 
sequence of IID U(0,1) random noise that might have generated it.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>diid.test(x, type = c("lb", "ks"), method = "holm", lag = 20, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="diid.test_+3A_x">x</code></td>
<td>

<p>the data series as a vector.
</p>
</td></tr>
<tr><td><code id="diid.test_+3A_type">type</code></td>
<td>

<p>the procedures to use to test whether or not the noise series is 
independently and identically distributed on the unit interval.  
See &lsquo;Details&rsquo;.
</p>
</td></tr>
<tr><td><code id="diid.test_+3A_method">method</code></td>
<td>

<p>the correction method to be used for adjusting the p-values.  It is identical to the
<code>method</code> argument of the <code><a href="stats.html#topic+p.adjust">p.adjust</a></code> function, which is called
to adjust the p-values.
</p>
</td></tr>
<tr><td><code id="diid.test_+3A_lag">lag</code></td>
<td>

<p>the number of lags to use when applying the Ljung-Box (portmanteau) test (<code>lb.test</code>).
</p>
</td></tr>
<tr><td><code id="diid.test_+3A_...">...</code></td>
<td>

<p>parameters to pass on to functions that can be subsequently called.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function tests if a symbolic sequence is a Bernoulli scheme, that is, 
independently and identically distributed (IID). It does this by reverse-
engineering the sequence to obtain a sample of the kind of output from a pseudo-
random number generator that would have produced the observed sequence if it had 
been generated by simulating an IID sequence. The sample output is then tested 
to see if it is an independent and identically distributed siequence of uniform 
numbers in the range 0-1.  this involves the application of at least two tests, 
one for independence and another for uniformity over the unit interval. One 
concludes that the sequence is IID if the sample output passes the  tests (that 
is, all null hypotheses are accepted) and not IID otherwise.
</p>
<p>The test is set up as follows:
</p>
<p><code class="reqn">H_0</code>: the sequence is IID <br />
<code class="reqn">H_1</code>:  the sequence is not IID
</p>
<p>To simplify the use of the test, correction for multiple testing is 
carried out, which yields a single adjusted p- value.  If this p-value 
is less than the significance level established for the test 
procedure, the null hypothesis of Markovianness is rejected. 
Otherwise, the null hypothesis should be accepted.
</p>
<p>To correctly apply the test, use the <code>type</code> argument to specify at least 
one test of independence and one test of uniformity from the options displayed 
in the following table.
</p>

<table>
<tr>
 <td style="text-align: left;">
<b>Category</b> </td><td style="text-align: left;"> <b>Function</b> </td><td style="text-align: left;"> <b>Test</b> </td>
</tr>
<tr>
 <td style="text-align: left;">
Uniformity </td><td style="text-align: left;"> <code><a href="#topic+ks.unif.test">ks.unif.test</a></code> </td><td style="text-align: left;"> Kolmogorov-Smirnov test for uniform$(0,1)$ data </td>
</tr>
<tr>
 <td style="text-align: left;">
 </td><td style="text-align: left;"> <code><a href="#topic+chisq.unif.test">chisq.unif.test</a></code> </td><td style="text-align: left;"> Pearson's chi-squared test for discrete uniform data, </td>
</tr>
<tr>
 <td style="text-align: left;">
Independence </td><td style="text-align: left;"> <code><a href="#topic+lb.test">lb.test</a></code> </td><td style="text-align: left;"> Ljung-Box $Q$ test for uncorrelated data </td>
</tr>
<tr>
 <td style="text-align: left;">
</td><td style="text-align: left;"> <code><a href="#topic+diffsign.test">diffsign.test</a></code> </td><td style="text-align: left;"> signed difference test of independence </td>
</tr>
<tr>
 <td style="text-align: left;">
</td><td style="text-align: left;"> <code><a href="#topic+turningpoint.test">turningpoint.test</a></code> </td><td style="text-align: left;"> turning point test of independence </td>
</tr>
<tr>
 <td style="text-align: left;">
</td><td style="text-align: left;"> <code><a href="#topic+rank.test">rank.test</a></code> </td><td style="text-align: left;"> rank test of independence </td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>

<p>If <code>type</code> is not specified, <code><a href="#topic+lb.test">lb.test</a></code> and 
<code><a href="#topic+ks.unif.test">ks.unif.test</a></code> are used by default.
</p>
<p>As this procedure performs multiple tests in order to assess if the sequence is 
IID, it is necessary to adjust the p-values for multiple testing.  By default, 
the Holm-Bonferroni method (<code>holm</code>) is used to correct for multiple 
testing, but this can be overridden via the <code>method</code> argument. The adjusted 
p-values are displayed when the result of the test is printed.
</p>
<p>The smallest adjusted p-value constitutes the overall p-value for the test.  If 
this p-value is less than the significance level fixed for the test procedure, 
the null hypothesis of the sequence beingIID is rejected.  Otherwise, the 
null hypothesis should be accepted.
</p>


<h3>Value</h3>

<p>A list with class &quot;multiplehtest&quot; containing the following components:
</p>
<table role = "presentation">
<tr><td><code>method</code></td>
<td>
<p>the character string &ldquo;Composite test for a Bernoulli process&rdquo;.</p>
</td></tr>
<tr><td><code>statistics</code></td>
<td>
<p>the values of the test statistic for all the tests.</p>
</td></tr>
<tr><td><code>parameters</code></td>
<td>
<p>parameters for all the tests.  Exactly one parameter is
recorded for each test, for example, <code>df</code> for <code><a href="#topic+lb.test">lb.test</a></code>. 
Any additional parameters are not saved, for
example, the <code>a</code> and <code>b</code> parameters of <code><a href="#topic+chisq.unif.test">chisq.unif.test</a></code>.</p>
</td></tr>
<tr><td><code>p.values</code></td>
<td>
<p>p-values of all the tests.</p>
</td></tr>
<tr><td><code>methods</code></td>
<td>
<p>a vector of character strings indicating what type of tests were performed.</p>
</td></tr>
<tr><td><code>adjusted.p.values</code></td>
<td>
<p>the adjusted p-values.</p>
</td></tr>
<tr><td><code>data.name</code></td>
<td>
<p>a character string giving the name of the data.</p>
</td></tr>
<tr><td><code>adjust.method</code></td>
<td>
<p>indicates which correction method was used to adjust the p-values for multiple testing.</p>
</td></tr>
<tr><td><code>estimate</code></td>
<td>
<p>the transition matrix estimated to fit a first-order Markov chain to the data and used to generate the infered random disturbance</p>
</td></tr></table>
<p>.
</p>


<h3>Note</h3>

<p>Sometimes, a warning message advising that ties should not be present for the 
Kolmogorov-Smirnov test can arise when analysing long sequences.  If you do 
receive this warning, it means that the results of the Kolmogorov-Smirnov test 
(<code><a href="#topic+ks.unif.test">ks.unif.test</a></code>) should not be trusted.  In this case, Pearson's 
chi-squared test (<code><a href="#topic+chisq.unif.test">chisq.unif.test</a></code>) should be used instead of the 
Kolmogorov-Smirnov test.
</p>


<h3>Author(s)</h3>

<p>Andrew Hart and Servet Martínez
</p>


<h3>References</h3>

<p>Although This test procedure is unpublished, it is derived by making appropriate 
modifications to the test for first-order Markovianness described in the 
following two references.
</p>
<p>Hart, A.G. and Martínez, S. (2011)
Statistical testing of Chargaff's second parity rule in bacterial genome sequences.
<em>Stoch. Models</em> <b>27(2)</b>, 1&ndash;46.
</p>
<p>Hart, A.G. and Martínez, S. (2014) 
Markovianness and Conditional Independence in Annotated Bacterial DNA.  
<em>Stat. Appl. Genet. Mol. Biol.</em> <b>13(6)</b>, 693-716.  arXiv:1311.4411 [q-bio.QM].
</p>


<h3>See Also</h3>

<p><code><a href="#topic+diid.disturbance">diid.disturbance</a></code>, <code><a href="#topic+markov.test">markov.test</a></code>, 
<code><a href="#topic+ks.unif.test">ks.unif.test</a></code>, <code><a href="#topic+chisq.unif.test">chisq.unif.test</a></code>,
<code><a href="#topic+diffsign.test">diffsign.test</a></code>, <code><a href="#topic+turningpoint.test">turningpoint.test</a></code>, <code><a href="#topic+rank.test">rank.test</a></code>, 
<code><a href="#topic+lb.test">lb.test</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#Generate an IID uniform DNA sequence
seq &lt;- simulateMarkovChain(5000, matrix(0.25, 4, 4), states=c("a","c","g","t"))
diid.test(seq)
</code></pre>

<hr>
<h2 id='disambiguate'>
Disambiguate a Nucleic Sequence
</h2><span id='topic+disambiguate'></span><span id='topic+disambiguate.default'></span><span id='topic+disambiguate.SeqFastadna'></span><span id='topic+disambiguate.list'></span>

<h3>Description</h3>

<p>Make a DNA/RNA sequence unambiguous by stripping out all symbols that do 
<b>not</b> uniquely specify nucleic acids.  In other words, remove all symbols 
other than <code>a</code>'s, <code>c</code>'s, <code>g</code>'s, <code>t</code>'s or <code>u</code>'s from the 
sequence.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## Default S3 method:
disambiguate(x, case=c("lower", "upper", "as is"), ...)
## S3 method for class 'SeqFastadna'
disambiguate(x, ...)
## S3 method for class 'list'
disambiguate(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="disambiguate_+3A_x">x</code></td>
<td>

<p>A character vector, an object that can be coersed to a character vector or a 
list of objects that canbe be converted to character vectors.  this argument 
can also be a <code>SeqFastadna</code> object provided by the <span class="pkg">seqinr</span> package.
</p>
</td></tr>
<tr><td><code id="disambiguate_+3A_case">case</code></td>
<td>

<p>Determines how symbols in <code>x</code> should be treated before translating them 
into their complements. &ldquo;<code>lower</code>&rdquo;, the default behaviour, converts 
all symbols to lowercase while &ldquo;<code>upper</code>&rdquo; converts them to 
uppercase.  &ldquo;<code>as is</code>&rdquo; allows the symbols to pass unchanged so that the case 
of each output symbol matches that of the corresponding input symbol.
</p>
</td></tr>
<tr><td><code id="disambiguate_+3A_...">...</code></td>
<td>

<p>Arguments to be passed from or to other functions.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If <code>x</code> is a SeqFastadna object or a character vector in which each element 
is a single nucleobase, then it represents a single sequence. It will be made 
unambiguous and returned in the same form.
</p>
<p>On the other hand, if <code>x</code> is a vector of character strings, each of which 
represents a nucleic sequence, then the result will bea a character vector in 
which each element contains the unambiguous sequence corresponding to the 
element in <code>x</code> as a character string.
</p>


<h3>Value</h3>

<p>According to the input <code>x</code>, a character vector, SeqFastadna object or list 
containing the  completely unambiguous sequence(s) in <code>x</code>.
</p>


<h3>Author(s)</h3>

<p>Andrew Hart and Servet Martínez
</p>

<hr>
<h2 id='estimateMarkovChain'>
Fit a first-Order Markov Chain to a Sequence of Finite Symbols
</h2><span id='topic+estimateMarkovChain'></span>

<h3>Description</h3>

<p>Estimates the transition matrix and stationary distribution of  a first-order
Markov chain from an observed sequence of symbols.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>estimateMarkovChain(x, circular=TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="estimateMarkovChain_+3A_x">x</code></td>
<td>
<p>The sequence of observed symbols as a character vector.</p>
</td></tr>
</table>
<p>purposes  </p>
<table role = "presentation">
<tr><td><code id="estimateMarkovChain_+3A_circular">circular</code></td>
<td>
<p>Should the sequence be treated as circular for the purpose of estimation?  The default is &lsquo;<span class="samp">&#8288;TRUE&#8288;</span>&rsquo;.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with class &lsquo;<span class="samp">&#8288;FiniteStateMarkovChain&#8288;</span>&rsquo; having the following components:
</p>
<table role = "presentation">
<tr><td><code>trans.mat</code></td>
<td>
<p>The stochastic transition matrix estimated from x.</p>
</td></tr>
<tr><td><code>stat.dist</code></td>
<td>
<p>The stationary distribution estimated from x.</p>
</td></tr>
<tr><td><code>states</code></td>
<td>
<p>the state labels</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Andrew Hart and Servet Martínez
</p>


<h3>See Also</h3>

<p><code><a href="#topic+markov.test">markov.test</a></code>, <code><a href="#topic+markov.disturbance">markov.disturbance</a></code>, <code><a href="#topic+simulateMarkovChain">simulateMarkovChain</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#Obtain a random 3 x 3 stochastic matrix with rows and columns labelled "A", "B", "C"
mat &lt;- rstochmat(3, labels=c("A", "B", "C"))
mat

#Simulate a Markov chain of length 500 using mat as the transition matrix
seq &lt;- simulateMarkovChain(500, mat)

#Estimate mat and the stationary distribution for the Markov chain which generated seq
estimateMarkovChain(seq)
</code></pre>

<hr>
<h2 id='ks.unif.test'>
Using <code>ks.test</code> to test for Uniformity on the Unit Interval
</h2><span id='topic+ks.unif.test'></span>

<h3>Description</h3>

<p>Uses <code>ks.test</code> to test that a data vector is uniform on the unit interval.
<code>ks.unif.test(x)</code> is merely convenient shorthand for 
<code>ks.test(x,
punif)</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ks.unif.test(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ks.unif.test_+3A_x">x</code></td>
<td>

<p>a numeric vector or univariate time series.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with class &quot;htest&quot; containing the following components:
</p>
<table role = "presentation">
<tr><td><code>statistic</code></td>
<td>
<p>the value of the test statistic.</p>
</td></tr>
<tr><td><code>p.value</code></td>
<td>
<p>the p-value of the test.</p>
</td></tr>
<tr><td><code>method</code></td>
<td>
<p>a character string indicating what type of test was performed.</p>
</td></tr>
<tr><td><code>data.name</code></td>
<td>
<p>a character string giving the name of the data.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Andrew Hart and Servet Martínez
</p>


<h3>See Also</h3>

<p><code><a href="#topic+chisq.unif.test">chisq.unif.test</a></code>, <code><a href="#topic+markov.test">markov.test</a></code>, <code><a href="#topic+diid.test">diid.test</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#Generate an IID uniform(0,1) sequence
u &lt;- runif(1000)
ks.unif.test(u)
</code></pre>

<hr>
<h2 id='lb.test'>
The Ljung-Box Test for Uncorrelated Data
</h2><span id='topic+lb.test'></span>

<h3>Description</h3>

<p>This function is a convenient wrapper for using <code>Box.test</code> to perform the Ljung-
Box Q test of uncorrelated data without having to specify &lsquo;<span class="samp">&#8288;type&#8288;</span>&rsquo;.  In other
words, <code>lb.test(x, ...)</code> is equivalent to 
<code>Box.test(x, type="Ljung-Box", ...)</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lb.test(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="lb.test_+3A_x">x</code></td>
<td>

<p>a numeric vector or univariate time series.
</p>
</td></tr>
<tr><td><code id="lb.test_+3A_...">...</code></td>
<td>

<p>parameters to pass to <code>Box.test</code>.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with class &quot;htest&quot; containing the following components:
</p>
<table role = "presentation">
<tr><td><code>statistic</code></td>
<td>
<p>the value of the test statistic.</p>
</td></tr>
<tr><td><code>parameter</code></td>
<td>
<p>the degrees of freedom of the approximate chi-squared distribution of the test statistic (taking <code>fitdf</code> into account).</p>
</td></tr>
<tr><td><code>p.value</code></td>
<td>
<p>the p-value of the test.</p>
</td></tr>
<tr><td><code>method</code></td>
<td>
<p>a character string indicating what type of test was performed.</p>
</td></tr>
<tr><td><code>data.name</code></td>
<td>
<p>a character string giving the name of the data.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Andrew Hart and Servet Martínez
</p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+Box.test">Box.test</a></code>, <code><a href="#topic+markov.test">markov.test</a></code>, <code><a href="#topic+diid.test">diid.test</a></code>
<code><a href="#topic+diffsign.test">diffsign.test</a></code>, <code><a href="#topic+turningpoint.test">turningpoint.test</a></code>, <code><a href="#topic+rank.test">rank.test</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#Generate an IID standard normal sequence
n &lt;- rnorm(1000)
lb.test(n)
</code></pre>

<hr>
<h2 id='markov.disturbance'>
Construct feasible Random Noise Generating a First-Order Markov Chain
</h2><span id='topic+markov.disturbance'></span>

<h3>Description</h3>

<p>Produces a sequence of random noise which would generate an observed sequence of
finite symbols provided that the sequence of symbols results from a first-order
Markov chain.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>markov.disturbance(x, chain = NULL, random = TRUE, bandwidth = 1, 
estimates = is.null(chain))
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="markov.disturbance_+3A_x">x</code></td>
<td>

<p>A sequence of finite symbols represented  as a  character vector.
</p>
</td></tr>
<tr><td><code id="markov.disturbance_+3A_chain">chain</code></td>
<td>

<p>A list containing two named components which specify a first-order Markov chain.
The &lsquo;<span class="samp">&#8288;trans.mat&#8288;</span>&rsquo; component holds the stochastic transition matrix for the
chain while the &lsquo;<span class="samp">&#8288;stat.dist&#8288;</span>&rsquo; component holds the stationary distribution of
the chain.  If not specified, &lsquo;<span class="samp">&#8288;chain&#8288;</span>&rsquo; is estimated from &lsquo;<span class="samp">&#8288;x&#8288;</span>&rsquo; using 
<code><a href="#topic+estimateMarkovChain">estimateMarkovChain</a></code>.
</p>
</td></tr>
<tr><td><code id="markov.disturbance_+3A_random">random</code></td>
<td>

<p>This can be a logical value or a number in the range 0-1. If &lsquo;<span class="samp">&#8288;TRUE&#8288;</span>&rsquo;, random
noise will be generated.  If &lsquo;<span class="samp">&#8288;FALSE&#8288;</span>&rsquo;, the constant value 0.5 will be used
as the noise source.  If a value in the range 0-1 is specified, that value will
be used as a constant noise source.  the default value is &lsquo;<span class="samp">&#8288;TRUE&#8288;</span>&rsquo;.
</p>
</td></tr>
<tr><td><code id="markov.disturbance_+3A_bandwidth">bandwidth</code></td>
<td>

<p>This value, which should be in the range 0-1, specifies the maximum peak-to-peak
bandwidth of the random noise generated.  The default value is 1.
</p>
</td></tr>
<tr><td><code id="markov.disturbance_+3A_estimates">estimates</code></td>
<td>

<p>A logical value specifying if the Markov chain estimates should be included in
the return.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>If &lsquo;<span class="samp">&#8288;estimates&#8288;</span>&rsquo; is &lsquo;<span class="samp">&#8288;TRUE&#8288;</span>&rsquo;, returns a list containing the following components:
</p>
<table role = "presentation">
<tr><td><code>disturbance</code></td>
<td>
<p>the sequence of random noise as a numeric vector.</p>
</td></tr>
<tr><td><code>trans.mat</code></td>
<td>
<p>The stochastic transition matrix estimated from x, if
&lsquo;<span class="samp">&#8288;chain&#8288;</span>&rsquo; is NULL; otherwise a copy of &lsquo;<span class="samp">&#8288;trans.mat&#8288;</span>&rsquo; component of
&lsquo;<span class="samp">&#8288;chain&#8288;</span>&rsquo;.</p>
</td></tr>
<tr><td><code>stat.dist</code></td>
<td>
<p>The stationary distribution estimated from x, if
&lsquo;<span class="samp">&#8288;chain&#8288;</span>&rsquo; is NULL; otherwise a copy of the &lsquo;<span class="samp">&#8288;stat.dist&#8288;</span>&rsquo; component of
&lsquo;<span class="samp">&#8288;chain&#8288;</span>&rsquo;.</p>
</td></tr>
</table>
<p>Otherwise, if &lsquo;<span class="samp">&#8288;estimate&#8288;</span>&rsquo; is &lsquo;<span class="samp">&#8288;FALSE&#8288;</span>&rsquo;, returns the sequence of random
noise as a numeric vector.
</p>


<h3>Author(s)</h3>

<p>Andrew Hart and Servet Martínez
</p>


<h3>See Also</h3>

<p><code><a href="#topic+markov.test">markov.test</a></code>, <code><a href="#topic+diid.test">diid.test</a></code>, <code><a href="#topic+diid.disturbance">diid.disturbance</a></code>
</p>

<hr>
<h2 id='markov.test'>
A Test for First-Order Markovianness
</h2><span id='topic+markov.test'></span>

<h3>Description</h3>

<p>Performs a test for first-order Markovianness of a data series by inferring the 
sequence of i.i.d. U(0,1) random noise that might have generated it.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>markov.test(x, type = c("lb", "ks"), method = "holm", lag = 20, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="markov.test_+3A_x">x</code></td>
<td>

<p>the data series as a vector.
</p>
</td></tr>
<tr><td><code id="markov.test_+3A_type">type</code></td>
<td>

<p>the procedures to use to test whether or not the disturbance series is 
independently and identically distributed on the unit interval.  
See &lsquo;Details&rsquo;.
</p>
</td></tr>
<tr><td><code id="markov.test_+3A_method">method</code></td>
<td>

<p>the correction method to be used for adjusting the p-values.  It is identical to the
<code>method</code> argument of the <code><a href="stats.html#topic+p.adjust">p.adjust</a></code> function, which is called
to adjust the p-values.
</p>
</td></tr>
<tr><td><code id="markov.test_+3A_lag">lag</code></td>
<td>

<p>the number of lags to use when applying the Ljung-Box (portmanteau) test (<code>lb.test</code>).
</p>
</td></tr>
<tr><td><code id="markov.test_+3A_...">...</code></td>
<td>

<p>parameters to pass on to functions that can be subsequently called.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function tests a symbolic sequence for first-order Markovianness (also 
known as  the Markov property). It does this by reverse-engineering the sequence 
to obtain a sample of the kind of output from a pseudo-random number generator 
that would have produced the observed sequence if it had been generated by 
simulating a Markov chain .The sample output is then tested to see if it is an 
independent and identically distributed siequence of uniform numbers in the 
range 0-1.  this involves the application of at least two tests, one for 
independence and another for uniformity over the unit interval. One concludes 
that the sequence is Markovian if the sample output passes the  tests (that is, 
all null hypotheses are accepted) and non-Markovian otherwise.
</p>
<p>The test is set up as follows:
</p>
<p><code class="reqn">H_0</code>: the sequence is first-order Markov <br />
<code class="reqn">H_1</code>:  the sequence is not first-order Markov
</p>
<p>To simplify the use of the test, correction for multiple testing is 
carried out, which yields a single adjusted p- value.  If this p-value 
is less than the significance level established for the test 
procedure, the null hypothesis of Markovianness is rejected. 
Otherwise, the null hypothesis should be accepted.
</p>
<p>To correctly apply the test, use the <code>type</code> argument to specify at least 
one test of independence and one test of uniformity from the options displayed 
in the following table.
</p>

<table>
<tr>
 <td style="text-align: left;">
<b>Category</b> </td><td style="text-align: left;"> <b>Function</b> </td><td style="text-align: left;"> <b>Test</b> </td>
</tr>
<tr>
 <td style="text-align: left;">
Uniformity </td><td style="text-align: left;"> <code><a href="#topic+ks.unif.test">ks.unif.test</a></code> </td><td style="text-align: left;"> Kolmogorov-Smirnov test for uniform$(0,1)$ data </td>
</tr>
<tr>
 <td style="text-align: left;">
 </td><td style="text-align: left;"> <code><a href="#topic+chisq.unif.test">chisq.unif.test</a></code> </td><td style="text-align: left;"> Pearson's chi-squared test for discrete uniform data, </td>
</tr>
<tr>
 <td style="text-align: left;">
Independence </td><td style="text-align: left;"> <code><a href="#topic+lb.test">lb.test</a></code> </td><td style="text-align: left;"> Ljung-Box $Q$ test for uncorrelated data </td>
</tr>
<tr>
 <td style="text-align: left;">
</td><td style="text-align: left;"> <code><a href="#topic+diffsign.test">diffsign.test</a></code> </td><td style="text-align: left;"> signed difference test of independence </td>
</tr>
<tr>
 <td style="text-align: left;">
</td><td style="text-align: left;"> <code><a href="#topic+turningpoint.test">turningpoint.test</a></code> </td><td style="text-align: left;"> turning point test of independence </td>
</tr>
<tr>
 <td style="text-align: left;">
</td><td style="text-align: left;"> <code><a href="#topic+rank.test">rank.test</a></code> </td><td style="text-align: left;"> rank test of independence </td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>

<p>If <code>type</code> is not specified, <code><a href="#topic+lb.test">lb.test</a></code> and 
<code><a href="#topic+ks.unif.test">ks.unif.test</a></code> are used by default.
</p>
<p>As this procedure performs multiple tests in order to assess if the sequence has 
a Markovian dependence structure, it is necessary to adjust the p-values for 
multiple testing.  By default, the Holm-Bonferroni method (<code>holm</code>) is used 
to correct for multiple testing, but this can be overridden via the 
<code>method</code> argument. The adjusted p-values are displayed when the result of 
the test is printed.
</p>
<p>The smallest adjusted p-value constitutes the overall p-value for the test.  If 
this p-value is less than the significance level fixed for the test procedure, 
the null hypothesis of first-order Markovianness is rejected.  Otherwise, the 
null hypothesis should be accepted.
</p>


<h3>Value</h3>

<p>A list with class &quot;multiplehtest&quot; containing the following components:
</p>
<table role = "presentation">
<tr><td><code>method</code></td>
<td>
<p>the character string &ldquo;Composite test for a first-order (finite state) Markov chain&rdquo;.</p>
</td></tr>
<tr><td><code>statistics</code></td>
<td>
<p>the values of the test statistic for all the tests.</p>
</td></tr>
<tr><td><code>parameters</code></td>
<td>
<p>parameters for all the tests.  Exactly one parameter is
recorded for each test, for example, <code>df</code> for <code><a href="#topic+lb.test">lb.test</a></code>. 
Any additional parameters are not saved, for
example, the <code>a</code> and <code>b</code> parameters of <code><a href="#topic+chisq.unif.test">chisq.unif.test</a></code>.</p>
</td></tr>
<tr><td><code>p.values</code></td>
<td>
<p>p-values of all the tests.</p>
</td></tr>
<tr><td><code>methods</code></td>
<td>
<p>a vector of character strings indicating what type of tests were performed.</p>
</td></tr>
<tr><td><code>adjusted.p.values</code></td>
<td>
<p>the adjusted p-values.</p>
</td></tr>
<tr><td><code>data.name</code></td>
<td>
<p>a character string giving the name of the data.</p>
</td></tr>
<tr><td><code>adjust.method</code></td>
<td>
<p>indicates which correction method was used to adjust the p-values for multiple testing.</p>
</td></tr>
<tr><td><code>estimate</code></td>
<td>
<p>the transition matrix estimated to fit a first-order Markov chain to the data and used to generate the infered random disturbance.</p>
</td></tr>
</table>


<h3>Note</h3>

<p>Sometimes, a warning message advising that ties should not be present for the 
Kolmogorov-Smirnov test can arise when analysing long sequences.  If you do 
receive this warning, it means that the results of the Kolmogorov-Smirnov test 
(<code><a href="#topic+ks.unif.test">ks.unif.test</a></code>) should not be trusted.  In this case, Pearson's 
chi-squared test (<code><a href="#topic+chisq.unif.test">chisq.unif.test</a></code>) should be used instead of the 
Kolmogorov-Smirnov test.
</p>


<h3>Author(s)</h3>

<p>Andrew Hart and Servet Martínez
</p>


<h3>References</h3>

<p>Hart, A.G. and Martínez, S. (2011)
Statistical testing of Chargaff's second parity rule in bacterial genome sequences.
<em>Stoch. Models</em> <b>27(2)</b>, 1&ndash;46.
</p>
<p>Hart, A.G. and Martínez, S. (2014) 
Markovianness and Conditional Independence in Annotated Bacterial DNA.  
<em>Stat. Appl. Genet. Mol. Biol.</em> <b>13(6)</b>, 693-716.  arXiv:1311.4411 [q-bio.QM].
</p>


<h3>See Also</h3>

<p><code><a href="#topic+markov.disturbance">markov.disturbance</a></code>, <code><a href="#topic+diid.test">diid.test</a></code>, 
<code><a href="#topic+ks.unif.test">ks.unif.test</a></code>, <code><a href="#topic+chisq.unif.test">chisq.unif.test</a></code>,
<code><a href="#topic+diffsign.test">diffsign.test</a></code>, <code><a href="#topic+turningpoint.test">turningpoint.test</a></code>, <code><a href="#topic+rank.test">rank.test</a></code>, 
<code><a href="#topic+lb.test">lb.test</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#Generate an IID uniform DNA sequence
seq &lt;- simulateMarkovChain(5000, matrix(0.25, 4, 4), states=c("a","c","g","t"))
markov.test(seq)
</code></pre>

<hr>
<h2 id='Nanoarchaeum+20equitans+20Kin4-M+20Chromosome'>DNA sequence for the Nanoarchaeum equitans Kin4-M Chromosome</h2><span id='topic+nanoarchaeum'></span>

<h3>Description</h3>

<p>This data set contains the DNA sequence for the chromosome of the <em>Nanoarchaeum 
equitans</em> Kin4-M bacteria.  The Accession number for this sequence is 
NC_005213.1.
</p>


<h3>Format</h3>

<p>a <code><a href="seqinr.html#topic+SeqFastadna">SeqFastadna</a></code> object.</p>


<h3>Source</h3>

<p>The NCBI ftp server at ftp://ftp.ncbi.nlm.nih.gov in the 
/genomes/bacteria directory.</p>


<h3>See Also</h3>

<p><code><a href="#topic+pieris">pieris</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(nanoarchaeum)
pair.counts(nanoarchaeum)
</code></pre>

<hr>
<h2 id='oligoProfile'>
Oligo Profiles and Oligo Profile Correlation Plots of Nucleotide Sequences
</h2><span id='topic+oligoProfile'></span><span id='topic+plot.OligoProfile'></span><span id='topic+print.OligoProfile'></span><span id='topic+oligoCorr'></span>

<h3>Description</h3>

<p>Construct a k-mer oligo profile of a nucleotide sequence and print such a 
profile or its reverse complement.  There is also a plot function for producing 
plots of the profile or its reverse complement and for comparing primary and 
complementary strand profiles.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>oligoProfile(x, k, content=c("dna", "rna"), 
case=c("lower", "upper", "as is"), circular=TRUE, disambiguate=TRUE, 
plot=TRUE, ...)
## S3 method for class 'OligoProfile'
plot(x, which=1L, units=c("percentage", "count", "proportion"),
 main=NULL, xlab=NULL, ylab=NULL, ...)
## S3 method for class 'OligoProfile'
print(x, which=1L, units=c("percentage", "count", "proportion"), 
digits=switch(units, percentage=3L, count=NULL, proportion=3L), ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="oligoProfile_+3A_x">x</code></td>
<td>

<p>a character vector or an object that can be coersed to a character vector.
</p>
</td></tr>
<tr><td><code id="oligoProfile_+3A_k">k</code></td>
<td>

<p>the k-mer profile to produce.
</p>
</td></tr>
<tr><td><code id="oligoProfile_+3A_content">content</code></td>
<td>

<p>The content type (&ldquo;<code>dna</code>&rdquo; or &ldquo;<code>rna</code>&rdquo;) of the input 
sequence.  <code>oligoProfile</code> can often detect this automatically based on 
the presence/absence of <code>t</code>'s or <code>u</code>'s, but if neither is present, 
the <code>content</code> argument is consulted.  The default value is 
&ldquo;<code>dna</code>&rdquo;.
</p>
</td></tr>
<tr><td><code id="oligoProfile_+3A_case">case</code></td>
<td>

<p>determines how labels for the array should be generated: in
lowercase, in uppercase or left as is, in which case labels such as &ldquo;b&rdquo;
and &ldquo;B&rdquo; will be seen as distinct symbols and counted separately.
</p>
</td></tr>
<tr><td><code id="oligoProfile_+3A_circular">circular</code></td>
<td>

<p>Determines if the vector should be treated as circular or not.  The default is 
<code>TRUE</code>, meaning that the start and end of the sequence will be joined 
together for the purpose of counting.
</p>
</td></tr>
<tr><td><code id="oligoProfile_+3A_disambiguate">disambiguate</code></td>
<td>

<p>if set to the default of <code>true</code>, makes the input sequence unambiguous 
before generating the profile.  Otherwise, ambiguous symbols are treated like 
any other symbols and k-mer counts including them will be computed.
</p>
</td></tr>
<tr><td><code id="oligoProfile_+3A_plot">plot</code></td>
<td>

<p>should a plot of the profile be produced?  The default is <code>TRUE</code>.
</p>
</td></tr>
<tr><td><code id="oligoProfile_+3A_which">which</code></td>
<td>

<p>For <code>print</code>, specifies whether to display the profile for the sequence used 
to generate the OligoProfile object (<code>1</code>) or the profile of its reverse 
complement (<code>2</code>).
</p>
<p>For the <code>plot</code> method, <code>which</code> determines what should be plotted. 
Values <code>1</code> and <code>2</code> cause the profile for the original sequence 
(primary strand) or its reverse complement (complementary strand) to be plotted, 
respectively.  Specifying <code>which=3</code> will plot a comparison of the two 
profiles which can be used to assess compliance with Chargaff's second parity 
rule.
</p>
<p>the <code>which</code> argument may also be specified when calling 
<code>oligoProfile</code>, in which case it will be passed on to the <code>plot</code> 
method if the <code>plot</code> argument is set to <code>TRUE</code>. 
</p>
</td></tr>
<tr><td><code id="oligoProfile_+3A_units">units</code></td>
<td>

<p>The oligo profiles can be scaled according to three different units for 
presentation on plots: &ldquo;<code>percentage</code>&rdquo;, &ldquo;<code>count</code>&rdquo; or 
&ldquo;<code>proportion</code>&rdquo;. The default is &ldquo;<code>percentage</code>&rdquo;.
</p>
</td></tr>
<tr><td><code id="oligoProfile_+3A_main">main</code></td>
<td>

<p>The title of the plot.  See <code><a href="graphics.html#topic+plot.default">plot.default</a></code>.  If not specified, an 
appropriate title is automatically generated.
</p>
</td></tr>
<tr><td><code id="oligoProfile_+3A_xlab">xlab</code></td>
<td>

<p>a label for the x-axis of the plot.  See <code><a href="graphics.html#topic+plot.default">plot.default</a></code>.  If not specified, an 
appropriate label is automatically generated.
</p>
</td></tr>
<tr><td><code id="oligoProfile_+3A_ylab">ylab</code></td>
<td>

<p>a label for the y-axis of the plot.  See <code><a href="graphics.html#topic+plot.default">plot.default</a></code>.  If not specified, an 
appropriate label is automatically generated.
</p>
</td></tr>
<tr><td><code id="oligoProfile_+3A_digits">digits</code></td>
<td>

<p>The number of significant digits to print.  The default is <code>0L</code> when <code>units</code> is set to &ldquo;<code>count</code>&rdquo; and <code>3L</code> otherwise.
</p>
</td></tr>
<tr><td><code id="oligoProfile_+3A_...">...</code></td>
<td>

<p>arguments to be passed from or to other functions
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function returns the oligo profile for a sequence in an <code>OligoProfile</code> 
object, which is printed on screen if the <code>plot</code> parameter is <code>FALSE</code>. 
An oligo profile is simply the counts of all <code>k</code>-mers in a sequence for 
some specified value of <code>k</code>.  
</p>
<p>By default, <code>oligoProfile</code> produces a plot of the oligo profile expressed 
in terms of percentages.  The <code>plot</code> argument determines if the plot 
should be generated or not and plotting parameters such as <code>main</code>, 
<code>sub</code>, etc., may be passed as arguments to the function when <code>plot</code> is 
<code>TRUE</code>.  
</p>
<p>The <code>plot</code> method, either called directly or indirectly via the 
<code>oligoProfile</code> function, can produce either the oligo profile of <code>x</code> 
(<code>which = 1</code>), the oligo profile of its reverse complement (<code>which = 
2</code>), or an interstrand k-mer correlation plot comparing the k-oligo profile 
of<code>x</code> with that of its reverse complement (<code>which = 3)</code>.  Such 
</p>
<p>Correlation plots effectively show the relationship between k-mers on the 
primary and complementary strands in a DNA duplex and can be used to assess 
compliance with CSPR.  More precisely, one would conclude that a genomic 
sequence complies with CSPR if all the plotted points lie on a diagonal line 
running from the bottom-left corner to the top-right corner of the graph.
</p>


<h3>Value</h3>

<p>A list with class &ldquo;OligoProfile&rdquo; containing the following components:
</p>
<table role = "presentation">
<tr><td><code>name</code></td>
<td>
<p>a name to identify the source of the profile.</p>
</td></tr>
<tr><td><code>wordLength</code></td>
<td>
<p>the value of k used to derive the k-mer profile.</p>
</td></tr>
<tr><td><code>content</code></td>
<td>
<p>indicates if the profile pertains to a DNA or RNA sequence.</p>
</td></tr>
<tr><td><code>case</code></td>
<td>
<p>indicates how the case of letters was processed before 
producing the profile.</p>
</td></tr>
<tr><td><code>circular</code></td>
<td>
<p>indicates whether or not the sequence was considered circular for the purpose of producing the profile.</p>
</td></tr>
<tr><td><code>disambiguate</code></td>
<td>
<p>indicates if the sequence was made unambiguous before 
producing the profile.</p>
</td></tr>
<tr><td><code>profile</code></td>
<td>
<p>a vector containing the raw counts (frequencies) of all k-mers.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Andrew Hart and Servet Martínez
</p>


<h3>References</h3>

<p>Albrecht-Buehler, G. (2006)  Asymptotically increasing compliance of genomes 
with Chargaff's second parity rules through inversions and inverted 
transpositions. <em>PNAS</em> <b>103(47)</b>, 17828&ndash;17833.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+pair.counts">pair.counts</a></code>, <code><a href="#topic+triple.counts">triple.counts</a></code>, 
<code><a href="#topic+quadruple.counts">quadruple.counts</a></code>, <code><a href="#topic+cylinder.counts">cylinder.counts</a></code>,
<code><a href="#topic+array2vector">array2vector</a></code>, <code><a href="#topic+table2vector">table2vector</a></code>, <code><a href="#topic+disambiguate">disambiguate</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(nanoarchaeum)
#Get the 3-oligo profile of Nanoarchaeum without plotting it
nano.prof &lt;- oligoProfile(nanoarchaeum, 3, plot=FALSE)
nano.prof #print oligo profile as percentages
print(nano.prof, units="count") #print oligo profile as counts
plot(nano.prof) #oligo profile plotted as percentages
plot(nano.prof, units="count") #plot it as counts

#plot the 2-oligo profile of Nanoarchaeum as proportions
oligoProfile(nanoarchaeum, k=3, units="proportion")
</code></pre>

<hr>
<h2 id='pair.counts'>
Count Pairs in Character Vectors
</h2><span id='topic+pair.counts'></span>

<h3>Description</h3>

<p>Count pairs of adjacent symbols/elements in a character vector.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pair.counts(x, case=c("lower", "upper", "as is"), circular=TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="pair.counts_+3A_x">x</code></td>
<td>

<p>a character vector or an object that can be coersed to a character vector.
</p>
</td></tr>
<tr><td><code id="pair.counts_+3A_case">case</code></td>
<td>

<p>determines how labels for the array should be generated: in
'lower'  case, in ' upper'  case or 'as is', in which case labels such as 'b'
and 'B' will be considered as distinct elements and counted separately.
</p>
</td></tr>
<tr><td><code id="pair.counts_+3A_circular">circular</code></td>
<td>

<p>Determines if the vector should be treated as circular or not.  The default is 
<code>TRUE</code>, meaning that the start and end of the sequence will be joined 
together for the purpose of counting.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>When <code>circular</code> is <code>TRUE</code>, the vector is treated as circular so that 
the some of all the counts in the resulting matrix is equal to the length of the 
vector and the row and column sums are equivalent.  When <code>circular</code> is 
<code>FALSE</code>, the sum of all the entries in the counts matrix will be one less 
than the length of the vector and there will be a discrepancy between the row 
and column sums.
</p>


<h3>Value</h3>

<p>A matrix of counts.  The row and column labels correspond to
the first and second element of each pair, respectively.
</p>


<h3>Author(s)</h3>

<p>Andrew Hart and Servet Martínez
</p>


<h3>See Also</h3>

<p><code><a href="#topic+triple.counts">triple.counts</a></code>, <code><a href="#topic+quadruple.counts">quadruple.counts</a></code>,
<code><a href="#topic+cylinder.counts">cylinder.counts</a></code>, 
<code><a href="#topic+array2vector">array2vector</a></code>, <code><a href="#topic+table2vector">table2vector</a></code>
</p>

<hr>
<h2 id='Pieris+20Rapae+20Granulovirus+20Genome'>DNA sequence for the Pieris Rapae Granulovirus Genome</h2><span id='topic+pieris'></span>

<h3>Description</h3>

<p>This data set contains the DNA sequence for the <em>Pieris rapae</em> granulovirus genome.  The Accession number for this sequence is 
NC_013797.1.
</p>


<h3>Format</h3>

<p>a <code><a href="seqinr.html#topic+SeqFastadna">SeqFastadna</a></code> object.</p>


<h3>Source</h3>

<p>The NCBI ftp server at ftp://ftp.ncbi.nlm.nih.gov in the 
/genomes/viruses directory.</p>


<h3>See Also</h3>

<p><code><a href="#topic+nanoarchaeum">nanoarchaeum</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(pieris)
pair.counts(pieris)
</code></pre>

<hr>
<h2 id='quadruple.counts'>
Count Quadruplets in Character Vectors
</h2><span id='topic+quadruple.counts'></span>

<h3>Description</h3>

<p>Count 4-tuples of adjacent symbols/elements in a character vector.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>quadruple.counts(x, case=c("lower", "upper", "as is"), circular=TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="quadruple.counts_+3A_x">x</code></td>
<td>

<p>a character vector or an object that can be coersed to a character vector.
</p>
</td></tr>
<tr><td><code id="quadruple.counts_+3A_case">case</code></td>
<td>

<p>determines how labels for the array should be generated: in
'lower'  case, in ' upper'  case or 'as is', in which case labels such as 'b'
and 'B' will be counted as distinct elements and counted separately.
</p>
</td></tr>
<tr><td><code id="quadruple.counts_+3A_circular">circular</code></td>
<td>

<p>Determines if the vector should be treated as circular or not.  The default is 
<code>TRUE</code>, meaning that the start and end of the sequence will be joined 
together for the purpose of counting.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If <code>circular</code> is <code>TRUE</code>, the vector is treated as circular so that the 
some of all the counts in the resulting array is equal to the length of the 
vector and the sums across all dimentions of the array are equivalent, that is: 
if we write<br />
<code>q &lt;- quadruple.counts(x)</code> <br />
for some character sequence x, then <br />
<code>apply(q,1,sum)</code>, <code>apply(q,2,sum)</code>, <code>apply(q,3,sum)</code> and <code>apply(q,4,sum)</code> <br />
are all identical.
</p>
<p>On the other hand, if <code>circular</code> is <code>FALSE</code>, the sum of all the 
entries in the counts array will be two less than the length of the vector and 
there will be a discrepancy between the sums over the various dimensions.
</p>


<h3>Value</h3>

<p>A 4-dimensional array of counts.  The labels of the <code class="reqn">i</code>-th dimension correspond to
the <code class="reqn">i</code>-th item in each tuple, where <code class="reqn">i</code> is either 1, 2, 3 or 4.
</p>


<h3>Author(s)</h3>

<p>Andrew Hart and Servet Martínez
</p>


<h3>See Also</h3>

<p><code><a href="#topic+pair.counts">pair.counts</a></code>, <code><a href="#topic+triple.counts">triple.counts</a></code>,
<code><a href="#topic+cylinder.counts">cylinder.counts</a></code>, 
<code><a href="#topic+array2vector">array2vector</a></code>, <code><a href="#topic+table2vector">table2vector</a></code>
</p>

<hr>
<h2 id='rank.test'>
The Rank Test of Statistical Independence
</h2><span id='topic+rank.test'></span>

<h3>Description</h3>

<p>Test for a trend in a data series by comparing the number of increasing pairs in the series with the number expected in an i.i.d. series.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rank.test(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="rank.test_+3A_x">x</code></td>
<td>

<p>a numeric vector or univariate time series.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Perform a test for trend based on the number of increasing ordered pairs in a data series.  
Consider pairs of the form (x(i), x(j)), where i&lt;j.  An increasing pair is 
any such pair for which x_i&lt;x_j.  This function counts the number of 
increasing pairs in the data, standardises it to have mean 0 and variance 
1 and asymptotically tests it against a standard normal distribution.
the test statistic is:
</p>
<p>R = (pairs-mu)/sigma, where <br />
pairs is the number of increasing pairs in the data, <br />
mu = n*(n-1)/4, <br />
sigma = sqrt(n*(n-1)*(2*n+5)/72) and <br />
n is the number of data points in the series.
</p>
<p>The test is set up as follows:
</p>
<p><code class="reqn">H_0</code>:  the data series is i.i.d. (not trending) <br />
<code class="reqn">H_1</code>:  the data series is not i.i.d. (trending)
</p>


<h3>Value</h3>

<p>A list with class &quot;htest&quot; containing the following components:
</p>
<table role = "presentation">
<tr><td><code>statistic</code></td>
<td>
<p>the value of the test statistic.</p>
</td></tr>
<tr><td><code>p.value</code></td>
<td>
<p>the p-value of the test.</p>
</td></tr>
<tr><td><code>method</code></td>
<td>
<p>a character string indicating what type of test was performed.</p>
</td></tr>
<tr><td><code>data.name</code></td>
<td>
<p>a character string giving the name of the data.</p>
</td></tr>
<tr><td><code>pairs</code></td>
<td>
<p>the number of increasing pairs counted in the data series.</p>
</td></tr>
<tr><td><code>n</code></td>
<td>
<p>the number of points in the data series.</p>
</td></tr>
<tr><td><code>mu</code></td>
<td>
<p>The expected number of increasing pairs that would be seen in an i.i.d. series.</p>
</td></tr>
<tr><td><code>sigma</code></td>
<td>
<p>The standard deviation of the number of increasing pairs that would be seen in an i.i.d. series.</p>
</td></tr>
</table>


<h3>Warning</h3>

<p>If the spgs shared object was successfully compiled with support for a 
64-bit unsigned integer type, then the following line should yield the value 0:
</p>
<p><kbd>rank.test(1:92683)$pairs-2^32-55607</kbd>
</p>
<p>if not, then the package is only using 32-bit integer arithmetic for computing 
the rank test statistic and this will restrict <code>rank.test</code> to analysing 
series whose length is at most 92682.  In this case, attempting to apply 
<code>rank.test</code> to a series longer than 92682 will result in a warning about an 
integer overflow having occurred and the results of the test should <strong>not</strong> 
be trusted.
</p>


<h3>Note</h3>

<p>Missing values are not handled. 
</p>
<p>Points followed by a point having the exact same value are removed from the data series before computing the test statistic.
</p>
<p>This test is useful for detecting linear trends in  data series.
</p>


<h3>Author(s)</h3>

<p>Andrew Hart and Servet Martínez
</p>


<h3>References</h3>

<p>Brockwell, Peter J., Davis, Richard A. (2002) <em>Introduction to Time Series and Forecasting</em>.
Springer Texts in Statistics, Springer-Verlag, New York.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+diffsign.test">diffsign.test</a></code>, <code><a href="#topic+turningpoint.test">turningpoint.test</a></code>, <code><a href="#topic+lb.test">lb.test</a></code>,
<code><a href="#topic+markov.test">markov.test</a></code>, <code><a href="#topic+diid.test">diid.test</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#Generate an IID standard normal sequence
n &lt;- rnorm(1000)
rank.test(n)
</code></pre>

<hr>
<h2 id='rcspr2mat'>
Random Stochastic Matrices Complying with Chargaff's Second Parity Rule for Dinucleotides
</h2><span id='topic+rcspr2mat'></span>

<h3>Description</h3>

<p>Randomly generate a 4 X 4 stochastic matrix that satisfies Chargaff's second parity rule for dinucleotides.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rcspr2mat(labels=c("a", "c", "g", "t"))
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="rcspr2mat_+3A_labels">labels</code></td>
<td>

<p>a vector of labels for the rows and columns of the matrix.  By
default, this is set to the set of four nucleotides a, c, g and t.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function randomly generates Stochastic matrices of the form 
</p>
<p style="text-align: center;"><code class="reqn">
\left(\begin{array}{cccc}
b_1&amp;b_2&amp;b_3&amp;1-(b_1+b_2+b_3) \\
zb_6&amp;b_4 &amp; 1-(zb_6+b_4+zb_3) &amp; zb_3 \\
zb_5 &amp;1-(zb_5+b_4+zb_2) &amp; b_4&amp;zb_2 \\
1-(b_5+b_6+b_1)&amp;b_5&amp;b_6&amp;b_1
\end{array}\right)
</code>
</p>

<p>where <code class="reqn">b_1</code>, ..., <code class="reqn">b_6</code> are values in the interval (0,1) and
<code class="reqn">z</code> is a positive number.
</p>
<p>Such matrices characterize sequences of DNA that comply with Chargaff's second
parity rule for dinucleotides. See the reference for further information.
</p>


<h3>Value</h3>

<p>A 4 X 4 stochastic matrix satisfying Chargaff's second parity rule.  The rows and columns are labelled according to labels.
</p>


<h3>Note</h3>

<p>This function is only intended for obtaining samples of matrices complying with
CSPR. It doe snot sample uniformly from the set of all such matrices and hence
is not appropriate for simulation experiments requiring uniformly drawn samples.
</p>


<h3>Author(s)</h3>

<p>Andrew Hart and Servet Martínez
</p>


<h3>References</h3>

<p>Hart, A.G. and Martínez, S. (2011)
Statistical testing of Chargaff's second parity rule in bacterial genome sequences.
<em>Stoch. Models</em> <b>27(2)</b>, 1&ndash;46.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+rstochmat">rstochmat</a></code>
</p>

<hr>
<h2 id='reverseComplement'>
Reverse Complement of a DNA/RNA Sequence
</h2><span id='topic+reverseComplement'></span><span id='topic+reverseComplement.default'></span><span id='topic+reverseComplement.SeqFastadna'></span><span id='topic+reverseComplement.list'></span>

<h3>Description</h3>

<p>Compute the reverse complement of a DNA or RNA sequence.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## Default S3 method:
reverseComplement(x, content=c("dna", "rna"), case=c("lower", "upper", "as is"), ...)
## S3 method for class 'SeqFastadna'
reverseComplement(x, ...)
## S3 method for class 'list'
reverseComplement(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="reverseComplement_+3A_x">x</code></td>
<td>

<p>A character vector, an object that can be coersed to a character vector or a 
list of objects that canbe be converted to character vectors.  this argument 
can also be a <code>SeqFastadna</code> object provided by the <span class="pkg">seqinr</span> package.
</p>
</td></tr>
<tr><td><code id="reverseComplement_+3A_content">content</code></td>
<td>

<p>The content type of sequence(s).  At present, supported types include 
&ldquo;<code>dna</code>&rdquo; and &ldquo;<code>rna</code>&rdquo;.  the default type is 
&ldquo;<code>dna</code>&rdquo;. 
</p>
</td></tr>
<tr><td><code id="reverseComplement_+3A_case">case</code></td>
<td>

<p>Determines how symbols in <code>x</code> should be treated before translating them 
into their complements. &ldquo;<code>lower</code>&rdquo;, the default behaviour, converts 
all symbols to lowercase while &ldquo;<code>upper</code>&rdquo; converts them to 
uppercase.  &ldquo;<code>as is</code>&rdquo; allows the symbols to pass unchanged so that the case 
of each output symbol matches that of the corresponding input symbol.
</p>
</td></tr>
<tr><td><code id="reverseComplement_+3A_...">...</code></td>
<td>

<p>Arguments to be passed from or to other functions.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If <code>x</code> is a SeqFastadna object or a character vector in which each element 
is a single nucleobase, then it represents a single sequence and its reverse-
complementary sequence will be returned in the same form.
</p>
<p>On the other hand, if <code>x</code> is a vector of character strings, each of which 
represents a nucleic sequence, then the result will bea a character vector in 
which each element contains the reverse complement of the corresponding element 
in <code>x</code> as a character string.
</p>


<h3>Value</h3>

<p>According to the input <code>x</code>, a character vector, SeqFastadna object or list 
containing the reverse complement(s) of the sequence(s) in <code>x</code>.
</p>


<h3>Author(s)</h3>

<p>Andrew Hart and Servet Martínez
</p>


<h3>See Also</h3>

<p><code><a href="#topic+complement">complement</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>reverseComplement("actg")
reverseComplement(c("t", "g", "a"))

#List of sequences
some.dna &lt;- list("atgcgtcgttaa", c("g", "t", "g", "a", "a", "a"))
reverseComplement(some.dna)

#RNA sequence example
reverseComplement(c("a", "u", "g"), content="rna")

#Examples of lowercase, uppercase and as-is conversion
mixed.case &lt;- c("t", "G", "g", "C", "a")
reverseComplement(mixed.case)
reverseComplement(mixed.case, case="upper")
reverseComplement(mixed.case, case="as is")
</code></pre>

<hr>
<h2 id='rstochmat'>
Random Generation of Stochastic Matrices
</h2><span id='topic+rstochmat'></span>

<h3>Description</h3>

<p>Randomly generates stochastic matrices.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rstochmat(n, labels)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="rstochmat_+3A_n">n</code></td>
<td>
<p>the dimension of the matrix.  If n is not specified, it is inferred from the lenth of &lsquo;<span class="samp">&#8288;labels&#8288;</span>&rsquo;.</p>
</td></tr>
<tr><td><code id="rstochmat_+3A_labels">labels</code></td>
<td>

<p>a vector of labels for the rows and columns of the matrix.  If &lsquo;<span class="samp">&#8288;labels&#8288;</span>&rsquo;
is not specified, &lsquo;<span class="samp">&#8288;n&#8288;</span>&rsquo; must be specified and the value
<code>as.character(1:n)</code> is assumed.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Stochastic matrices are non-negative matrices whose rows all sum to unity.  This
function uniformly generates samples from the set of <code class="reqn">n\times n</code> stochastic matrices.
</p>
<p>At least one of the arguments must be specified.  The missing argument is infered from the other.
</p>


<h3>Value</h3>

<p>An <code class="reqn">n\times n</code> stochastic matrix with rows and columns labelled according to &lsquo;<span class="samp">&#8288;labels&#8288;</span>&rsquo;.
</p>


<h3>Author(s)</h3>

<p>Andrew Hart and Servet Martínez
</p>


<h3>See Also</h3>

<p><code><a href="#topic+rcspr2mat">rcspr2mat</a></code>, <code><a href="#topic+estimateMarkovChain">estimateMarkovChain</a></code>, <code><a href="#topic+simulateMarkovChain">simulateMarkovChain</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>rstochmat(4)
rstochmat(3, c("a", "b", "c"))
rstochmat(labels=c("r", "R"))
</code></pre>

<hr>
<h2 id='rstochvec'>
Random Generation of Stochastic (Probability) Vectors
</h2><span id='topic+rstochvec'></span>

<h3>Description</h3>

<p>Randomly generate probability vectors, that is, non-negative vectors whose 
elements sum to unity.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rstochvec(n, labels)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="rstochvec_+3A_n">n</code></td>
<td>
<p>the length of the vector.  If n is not specified, it is inferred from the lenth of &lsquo;<span class="samp">&#8288;labels&#8288;</span>&rsquo;.</p>
</td></tr>
<tr><td><code id="rstochvec_+3A_labels">labels</code></td>
<td>

<p>a vector of labels for the elements of the vector.  If &lsquo;<span class="samp">&#8288;labels&#8288;</span>&rsquo; is not 
specified, n must be specified and the value <code>as.character(1:n)</code> is assumed.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Stochastic (or probability) vectors are non-negative vectors that sum to unity.
This function uniformly generates samples from the set of probability vector sof
length <code class="reqn">n</code>.
</p>
<p>At least one of the arguments must be specified.  The missing argument is infered from the other.
</p>


<h3>Value</h3>

<p>A probability vector of length <code class="reqn">n</code> with elements named according to &lsquo;<span class="samp">&#8288;labels&#8288;</span>&rsquo;.
</p>


<h3>Author(s)</h3>

<p>Andrew Hart and Servet Martínez
</p>


<h3>Examples</h3>

<pre><code class='language-R'>rstochvec(4)
rstochvec(3, c("a", "b", "c"))
rstochvec(labels=c("r", "R"))
</code></pre>

<hr>
<h2 id='simulateMarkovChain'>
Simulate a first-Order Markov Chain
</h2><span id='topic+simulateMarkovChain'></span>

<h3>Description</h3>

<p>Simulates a first-order Markov chain.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>simulateMarkovChain(n, trans.mat, init.dist=NULL, states=colnames(trans.mat))
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="simulateMarkovChain_+3A_n">n</code></td>
<td>
<p>the length of the sample path to simulate.</p>
</td></tr>
<tr><td><code id="simulateMarkovChain_+3A_trans.mat">trans.mat</code></td>
<td>
<p>The transition matrix of the Markov chain to simulate.</p>
</td></tr>
<tr><td><code id="simulateMarkovChain_+3A_init.dist">init.dist</code></td>
<td>

<p>The initial distribution to use for starting the simulation.  If it is not
specified, the stationary distribution of the Markov chain will be computed from
trans.mat and used to start the simulation in the steady state.
</p>
</td></tr>
<tr><td><code id="simulateMarkovChain_+3A_states">states</code></td>
<td>
<p>This argument can be used to override the labels on the transition matrix (if any) and name the states output on the sample path.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>&lsquo;<span class="samp">&#8288;trans.mat&#8288;</span>&rsquo; must be a stochastic matrix.  It must either have both row and
column names, in which case they must agree, or no row and column names at all.
The row/column names will be used to label the states visited by the Markov
chain in the sample path simulated.  If &lsquo;<span class="samp">&#8288;states&#8288;</span>&rsquo; is specified, it will be
used to label the states of the Markov chain instead of the row/column names of
&lsquo;<span class="samp">&#8288;trans.mat&#8288;</span>&rsquo;, in which the length of &lsquo;<span class="samp">&#8288;states&#8288;</span>&rsquo; must agree with the
dimension of &lsquo;<span class="samp">&#8288;trans.mat&#8288;</span>&rsquo;. If &lsquo;<span class="samp">&#8288;trans.mat&#8288;</span>&rsquo; has no row/column names and
&lsquo;<span class="samp">&#8288;states&#8288;</span>&rsquo; is not specified, then the states of the Markov chain will be
labelled <code class="reqn">1,\ldots,n</code>, where <code class="reqn">n</code> is the dimension of &lsquo;<span class="samp">&#8288;trans.mat&#8288;</span>&rsquo;.
</p>


<h3>Value</h3>

<p>A vector of length n containing a realisation of the specified Markov chain.
</p>


<h3>Author(s)</h3>

<p>Andrew Hart and Servet Martínez
</p>


<h3>See Also</h3>

<p><code><a href="#topic+estimateMarkovChain">estimateMarkovChain</a></code>, <code><a href="#topic+rstochmat">rstochmat</a></code>, <code><a href="#topic+rcspr2mat">rcspr2mat</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>simulateMarkovChain(50, matrix(c(.8, .2, .2, .8), ncol=2))
simulateMarkovChain(50, rstochmat(3), states=c("yes", "no", "maybe"))
</code></pre>

<hr>
<h2 id='triple.counts'>
Count Triplets in Character Vectors
</h2><span id='topic+triple.counts'></span>

<h3>Description</h3>

<p>Count triples of adjacent symbols/elements in a character vector.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>triple.counts(x, case=c("lower", "upper", "as is"), circular=TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="triple.counts_+3A_x">x</code></td>
<td>

<p>a character vector or an object that can be coersed to a character vector.
</p>
</td></tr>
<tr><td><code id="triple.counts_+3A_case">case</code></td>
<td>

<p>determines how labels for the array should be generated: in
'lower'  case, in ' upper'  case or 'as is', in which case labels such as 'b'
and 'B' will be counted as distinct elements and counted separately.
</p>
</td></tr>
<tr><td><code id="triple.counts_+3A_circular">circular</code></td>
<td>

<p>Determines if the vector should be treated as circular or not.  The default is 
<code>TRUE</code>, meaning that the start and end of the sequence will be joined 
together for the purpose of counting.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If <code>circular</code> is <code>TRUE</code>, the vector is treated as circular so that the 
some of all the counts in the resulting array is equal to the length of the 
vector and the sums across all dimentions of the array are equivalent, that is: 
if we write<br />
<code>t &lt;- triple.counts(x)</code> <br />
for some character sequence x, then <br />
<code>apply(t,1,sum)</code>, <code>apply(t,2,sum)</code> and <code>apply(t,3,sum)</code> <br />
are all identical.
</p>
<p>On the other hand, if <code>circular</code> is <code>FALSE</code>, the sum of all the 
entries in the counts array will be two less than the length of the vector and 
there will be a discrepancy between the sums over the various dimensions.
</p>


<h3>Value</h3>

<p>A 3-dimensional array of counts.  The labels of the <code class="reqn">i</code>-th dimension correspond to
the <code class="reqn">i</code>-th element of each triple, where <code class="reqn">i</code> is either 1, 2 or 3.
</p>


<h3>Author(s)</h3>

<p>Andrew Hart and Servet Martínez
</p>


<h3>See Also</h3>

<p><code><a href="#topic+pair.counts">pair.counts</a></code>, <code><a href="#topic+quadruple.counts">quadruple.counts</a></code>,
<code><a href="#topic+cylinder.counts">cylinder.counts</a></code>, 
<code><a href="#topic+array2vector">array2vector</a></code>, <code><a href="#topic+table2vector">table2vector</a></code>
</p>

<hr>
<h2 id='turningpoint.test'>
The Turning Point Test of Statistical Independence
</h2><span id='topic+turningpoint.test'></span>

<h3>Description</h3>

<p>Perform a test of statistical independence of a data series by comparing the number of turning points present in the series with the number of turning points expected to be present in an i.i.d. series.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>turningpoint.test(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="turningpoint.test_+3A_x">x</code></td>
<td>

<p>a numeric vector or univariate time series.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If the data is x[1], x[2], ..., x[n], then there is a turning point at the point i
if either x[i-1]&lt;x[i] and x[i]&gt;x[i+1], or x[i-1]&gt;x[i] and x[i]&lt;x[i+1].
this function counts the number of turning points in the data, standardises 
it to have mean 0 and variance 1 and asymptotically tests it against a 
standard normal distribution. The test statistic is
</p>
<p>T = (tp-mu)/sigma, where <br />
tp is the number of turning points present in the series, <br />
mu = 2*(n-2)/3, <br />
sigma = sqrt((16*n-29)/90) and <br />
n is the number of data points in the series.
</p>
<p>The test is set up as follows:
</p>
<p><code class="reqn">H_0</code>:  the data series is i.i.d. (not trending) <br />
<code class="reqn">H_1</code>:  the data series is not i.i.d. (trending)
</p>


<h3>Value</h3>

<p>A list with class &quot;htest&quot; containing the following components:
</p>
<table role = "presentation">
<tr><td><code>statistic</code></td>
<td>
<p>the value of the test statistic.</p>
</td></tr>
<tr><td><code>p.value</code></td>
<td>
<p>the p-value of the test.</p>
</td></tr>
<tr><td><code>method</code></td>
<td>
<p>a character string indicating what type of test was performed.</p>
</td></tr>
<tr><td><code>data.name</code></td>
<td>
<p>a character string giving the name of the data.</p>
</td></tr>
<tr><td><code>n</code></td>
<td>
<p>the number of points in the data series.</p>
</td></tr>
<tr><td><code>mu</code></td>
<td>
<p>The expected number of turning points that would be seen in an i.i.d. series.</p>
</td></tr>
<tr><td><code>sigma</code></td>
<td>
<p>The standard deviation of the number of turning points that would be seen in an i.i.d. series.</p>
</td></tr>
</table>


<h3>Note</h3>

<p>Missing values are not handled. 
</p>
<p>Points followed by a point having the exact same value are removed from the data series before computing the test statistic.
</p>
<p>This test is useful for detecting cyclic/periodic trends in data series.
</p>


<h3>Author(s)</h3>

<p>Andrew Hart and Servet Martínez
</p>


<h3>References</h3>

<p>Brockwell, Peter J., Davis, Richard A. (2002) <em>Introduction to Time Series and Forecasting</em>.
Springer Texts in Statistics, Springer-Verlag, New York.
</p>
<p>Bienaymé, Irénée-Jules (1874). 
Sur une question de probabilités.
<em>Bull. Math. Soc. Fr.</em>
<b>2</b>, 153-154.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+diffsign.test">diffsign.test</a></code>, <code><a href="#topic+rank.test">rank.test</a></code>, <code><a href="#topic+lb.test">lb.test</a></code>,
<code><a href="#topic+markov.test">markov.test</a></code>, <code><a href="#topic+diid.test">diid.test</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#Generate an IID standard normal sequence
n &lt;- rnorm(1000)
turningpoint.test(n)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
