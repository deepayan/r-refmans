<!DOCTYPE html><html><head><title>Help for package bestridge</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {bestridge}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#bestridge-package'><p>bestridge: A Comprehensive R Package for Best Subset Selection</p></a></li>
<li><a href='#bsrr'><p>Best subset ridge regression</p></a></li>
<li><a href='#coef.bsrr'><p>Provides estimated coefficients from a fitted &quot;bsrr&quot; object.</p></a></li>
<li><a href='#deviance.bsrr'><p>Extract the deviance from a &quot;bsrr.one&quot; object.</p></a></li>
<li><a href='#duke'><p>Duke breast cancer data</p></a></li>
<li><a href='#gen.data'><p>Generate simulated data</p></a></li>
<li><a href='#gravier'><p>breast cancer data set</p></a></li>
<li><a href='#logLik.bsrr'><p>Extract the log-likelihood from a &quot;bsrr.one&quot; object.</p></a></li>
<li><a href='#patient.data'><p>Lymphoma patients data set</p></a></li>
<li><a href='#plot.bsrr'><p>Produces a coefficient profile plot of the coefficient or loss function</p>
paths</a></li>
<li><a href='#predict.bsrr'><p>make predictions from a &quot;bsrr&quot; object.</p></a></li>
<li><a href='#print.bsrr'><p>print method for a &quot;bsrr&quot; object</p></a></li>
<li><a href='#prostate'><p>Factors associated with prostate specific antigen</p></a></li>
<li><a href='#SAheart'><p>Risk factors associated with heart disease</p></a></li>
<li><a href='#summary.bsrr'><p>summary method for a &quot;bsrr&quot; object</p></a></li>
<li><a href='#trim32'><p>The Bardet-Biedl syndrome Gene expression data</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>A Comprehensive R Package for Best Subset Selection</td>
</tr>
<tr>
<td>Version:</td>
<td>1.0.7</td>
</tr>
<tr>
<td>Date:</td>
<td>2021-10-10</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Liyuan Hu &lt;huly5@mail2.sysu.edu.cn&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>The bestridge package is designed to provide a one-stand service for users to successfully carry out best ridge regression in various complex situations via the primal dual active set algorithm proposed by Wen, C., Zhang, A., Quan, S. and Wang, X. (2020) &lt;<a href="https://doi.org/10.18637%2Fjss.v094.i04">doi:10.18637/jss.v094.i04</a>&gt;. This package allows users to perform the regression, classification, count regression and censored regression for (ultra) high dimensional data, and it also supports advanced usages like group variable selection and nuisance variable selection.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.5.0)</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>Imports:</td>
<td>Rcpp (&ge; 1.0.3), Matrix(&ge; 1.2-6), MASS, pheatmap, survival</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>Rcpp, RcppEigen</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.1.1</td>
</tr>
<tr>
<td>Suggests:</td>
<td>knitr, rmarkdown</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2021-10-10 11:12:50 UTC; test</td>
</tr>
<tr>
<td>Author:</td>
<td>Liyuan Hu <a href="https://orcid.org/0000-0003-2064-8990"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [aut,
    cre],
  Jin Zhu <a href="https://orcid.org/0000-0001-8550-5822"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [aut],
  Junxian Zhu [aut],
  Kangkang Jiang [aut],
  Yanhang Zhang [aut],
  Xueqin Wang <a href="https://orcid.org/0000-0001-5205-9950"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [aut],
  Canhong Wen [aut]</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2021-10-10 11:40:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='bestridge-package'>bestridge: A Comprehensive R Package for Best Subset Selection</h2><span id='topic+bestridge'></span><span id='topic+bestridge-package'></span>

<h3>Description</h3>

<p>The bestridge package is designed to provide a one-stand service for users to successfully carry out best ridge regression in various complex situations via the primal dual active set algorithm proposed by Wen, C., Zhang, A., Quan, S. and Wang, X. (2020) &lt;doi:10.18637/jss.v094.i04&gt;. This package allows users to perform the regression, classification, count regression and censored regression for (ultra) high dimensional data, and it also supports advanced usages like group variable selection and nuisance variable selection.
</p>


<h3>Author(s)</h3>

<p>Liyuan Hu, Kangkang Jiang, Yanhang Zhang, Jin Zhu and Xueqin Wang, Canhong Wen.
</p>


<h3>References</h3>

<p>Wen, C., Zhang, A., Quan, S. and Wang, X. (2020). BeSS: An R
Package for Best Subset Selection in Linear, Logistic and Cox Proportional
Hazards Models, <em>Journal of Statistical Software</em>, Vol. 94(4).
doi:10.18637/jss.v094.i04.
</p>

<hr>
<h2 id='bsrr'>Best subset ridge regression</h2><span id='topic+bsrr'></span>

<h3>Description</h3>

<p>Best subset ridge regression for generalized linear model and Cox's proportional
model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bsrr(
  x,
  y,
  family = c("gaussian", "binomial", "poisson", "cox"),
  method = c("pgsection", "sequential", "psequential"),
  tune = c("gic", "ebic", "bic", "aic", "cv"),
  s.list,
  lambda.list = 0,
  s.min,
  s.max,
  lambda.min = 0.001,
  lambda.max = 100,
  nlambda = 100,
  always.include = NULL,
  screening.num = NULL,
  normalize = NULL,
  weight = NULL,
  max.iter = 20,
  warm.start = TRUE,
  nfolds = 5,
  group.index = NULL,
  seed = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bsrr_+3A_x">x</code></td>
<td>
<p>Input matrix, of dimension <code class="reqn">n \times p</code>; each row is an observation
vector and each column is a predictor/feature/variable.</p>
</td></tr>
<tr><td><code id="bsrr_+3A_y">y</code></td>
<td>
<p>The response variable, of <code>n</code> observations. For <code>family = "binomial"</code> should be
a factor with two levels. For <code>family="poisson"</code>, <code>y</code> should be a vector with positive integer.
For <code>family = "cox"</code>, <code>y</code> should be a two-column matrix
with columns named <code>time</code> and <code>status</code>.</p>
</td></tr>
<tr><td><code id="bsrr_+3A_family">family</code></td>
<td>
<p>One of the following models: <code>"gaussian"</code>, <code>"binomial"</code>,
<code>"poisson"</code>, or <code>"cox"</code>. Depending on the response. Any unambiguous substring can be given.</p>
</td></tr>
<tr><td><code id="bsrr_+3A_method">method</code></td>
<td>
<p>The method to be used to select the optimal model size and <code class="reqn">L_2</code> shrinkage. For
<code>method = "sequential"</code>, we solve the best subset ridge regression
problem for each <code>s</code> in <code>1,2,...,s.max</code> and <code class="reqn">\lambda</code> in <code>lambda.list</code>.
For <code>method = "pgsection"</code> and <code>"psequential"</code>, the Powell method is used to
solve the best subset ridge regression problem. Any unambiguous substring can be given.</p>
</td></tr>
<tr><td><code id="bsrr_+3A_tune">tune</code></td>
<td>
<p>The criterion for choosing the model size and <code class="reqn">L_2</code> shrinkage
parameters. Available options are <code>"gic"</code>, <code>"ebic"</code>, <code>"bic"</code>, <code>"aic"</code> and <code>"cv"</code>.
Default is <code>"gic"</code>. <code>"cv"</code> is recommanded for BSRR.</p>
</td></tr>
<tr><td><code id="bsrr_+3A_s.list">s.list</code></td>
<td>
<p>An increasing list of sequential values representing the model
sizes. Only used for <code>method = "sequential"</code>. Default is <code>1:min(p,
round(n/log(n)))</code>.</p>
</td></tr>
<tr><td><code id="bsrr_+3A_lambda.list">lambda.list</code></td>
<td>
<p>A lambda sequence for <code>"bsrr"</code>. Only used for <code>method = "sequential"</code>. Default is
<code>exp(seq(log(100), log(0.01), length.out = 100))</code>.</p>
</td></tr>
<tr><td><code id="bsrr_+3A_s.min">s.min</code></td>
<td>
<p>The minimum value of model sizes. Only used for <code>"psequential"</code> and <code>"pgsection"</code>. Default is 1.</p>
</td></tr>
<tr><td><code id="bsrr_+3A_s.max">s.max</code></td>
<td>
<p>The maximum value of model sizes. Only used for <code>"psequential"</code> and <code>"pgsection"</code>.
Default is <code>min(p, round(n/log(n)))</code>.</p>
</td></tr>
<tr><td><code id="bsrr_+3A_lambda.min">lambda.min</code></td>
<td>
<p>The minimum value of lambda. Only used for <code>method =
"psequential"</code> and <code>"pgsection"</code>. Default is <code>0.001</code>.</p>
</td></tr>
<tr><td><code id="bsrr_+3A_lambda.max">lambda.max</code></td>
<td>
<p>The maximum value of lambda. Only used for <code>method =
"psequential"</code> and <code>"pgsection"</code>. Default is <code>100</code>.</p>
</td></tr>
<tr><td><code id="bsrr_+3A_nlambda">nlambda</code></td>
<td>
<p>The number of <code class="reqn">\lambda</code>s for the Powell path with sequential line search method.
Only valid for <code>method = "psequential"</code>.</p>
</td></tr>
<tr><td><code id="bsrr_+3A_always.include">always.include</code></td>
<td>
<p>An integer vector containing the indexes of variables that should always be included in the model.</p>
</td></tr>
<tr><td><code id="bsrr_+3A_screening.num">screening.num</code></td>
<td>
<p>Users can pre-exclude some irrelevant variables according to maximum marginal likelihood estimators before fitting a
model by passing an integer to <code>screening.num</code> and the sure independence screening will choose a set of variables of this size.
Then the active set updates are restricted on this subset.</p>
</td></tr>
<tr><td><code id="bsrr_+3A_normalize">normalize</code></td>
<td>
<p>Options for normalization. <code>normalize = 0</code> for
no normalization. Setting <code>normalize = 1</code> will
only subtract the mean of columns of <code>x</code>.
<code>normalize = 2</code> for scaling the columns of <code>x</code> to have <code class="reqn">\sqrt n</code> norm.
<code>normalize = 3</code> for subtracting the means of the columns of <code>x</code> and <code>y</code>, and also
normalizing the columns of <code>x</code> to have <code class="reqn">\sqrt n</code> norm.
If <code>normalize = NULL</code>, by default, <code>normalize</code> will be set <code>1</code> for <code>"gaussian"</code>,
<code>2</code> for <code>"binomial"</code> and <code>"poisson"</code>, <code>3</code> for <code>"cox"</code>.</p>
</td></tr>
<tr><td><code id="bsrr_+3A_weight">weight</code></td>
<td>
<p>Observation weights. Default is <code>1</code> for each observation.</p>
</td></tr>
<tr><td><code id="bsrr_+3A_max.iter">max.iter</code></td>
<td>
<p>The maximum number of iterations in the <code>bsrr</code> function.
In most of the case, only a few steps can guarantee the convergence. Default
is <code>20</code>.</p>
</td></tr>
<tr><td><code id="bsrr_+3A_warm.start">warm.start</code></td>
<td>
<p>Whether to use the last solution as a warm start. Default
is <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="bsrr_+3A_nfolds">nfolds</code></td>
<td>
<p>The number of folds in cross-validation. Default is <code>5</code>.</p>
</td></tr>
<tr><td><code id="bsrr_+3A_group.index">group.index</code></td>
<td>
<p>A vector of integers indicating the which group each variable is in.
For variables in the same group, they should be located in adjacent columns of <code>x</code>
and their corresponding index in <code>group.index</code> should be the same.
Denote the first group as <code>1</code>, the second <code>2</code>, etc.
If you do not fit a model with a group structure,
please set <code>group.index = NULL</code>. Default is <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="bsrr_+3A_seed">seed</code></td>
<td>
<p>Seed to be used to divide the sample into K cross-validation folds. Default is <code>NULL</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The best ridge regression problem with model size <code class="reqn">s</code> and the shrinkage parameter <code class="reqn">\lambda</code> is
</p>
<p style="text-align: center;"><code class="reqn">\min_\beta -2 \log L(\beta) + \lambda\Vert\beta\Vert_2^2 \;\;{\rm
s.t.}\;\; \|\beta\|_0 \leq s.</code>
</p>
<p> In the GLM case, <code class="reqn">\log L(\beta)</code> is the
log likelihood function; In the Cox model, <code class="reqn">\log L(\beta)</code> is the log
partial likelihood function.
</p>
<p>The best subset selection problem is a special case of the best ridge regression problem
with the shrinkage <code class="reqn">\lambda=0</code>.
</p>
<p>For each candidate model size and <code class="reqn">\lambda</code>, the best subset ridge regression
problems are solved by the <code class="reqn">L_2</code> penalized primal-dual active set (PDAS) algorithm, see Wen et
al (2020) for details. This algorithm
utilizes an active set updating strategy via primal and dual variables and
fits the sub-model by exploiting the fact that their support sets are
non-overlap and complementary. For the case of <code>method = "sequential"</code>
if <code>warm.start = "TRUE"</code>, we run the PDAS algorithm for a list of
sequential model sizes and use the estimate from the last iteration as a
warm start. For the case of
<code> method = "psequential"</code> and <code>method = "pgsection"</code>, the Powell method
using a sequential line search method or a golden section search technique is
used for parameters determination.
</p>


<h3>Value</h3>

<p>A list with class attribute 'bsrr' and named components:
</p>
<table>
<tr><td><code>beta</code></td>
<td>
<p>The best fitting coefficients.</p>
</td></tr>
<tr><td><code>coef0</code></td>
<td>
<p>The best fitting
intercept.</p>
</td></tr>
<tr><td><code>loss</code></td>
<td>
<p>The training loss of the best fitting model.</p>
</td></tr>
<tr><td><code>ic</code></td>
<td>
<p>The information criterion of the best fitting model when model
selection is based on a certain information criterion.</p>
</td></tr> <tr><td><code>cvm</code></td>
<td>
<p>The mean
cross-validated error for the best fitting model when model selection is
based on the cross-validation.</p>
</td></tr>
<tr><td><code>lambda</code></td>
<td>
<p>The lambda chosen for the best fitting model</p>
</td></tr>
<tr><td><code>beta.all</code></td>
<td>
<p>For <code>bsrr</code> objects obtained by <code>gsection</code>, <code>pgsection</code>
and <code>psequential</code>, <code>beta.all</code> is a matrix with each column be the coefficients
of the model in each iterative step in the tuning path.
For <code>bsrr</code> objects obtained by <code>sequential</code> method,
A list of the best fitting coefficients of size
<code>s=0,1,...,p</code> and <code class="reqn">\lambda</code> in <code>lambda.list</code> with the
smallest loss function. For <code>"bsrr"</code> objects of <code>"bsrr"</code> type, the fitting coefficients of the
<code class="reqn">i^{th} \lambda</code> and the <code class="reqn">j^{th}</code> <code>s</code> are at the <code class="reqn">i^{th}</code>
list component's <code class="reqn">j^{th}</code> column.</p>
</td></tr>
<tr><td><code>coef0.all</code></td>
<td>
<p>For <code>bsrr</code> objects obtained from <code>gsection</code>, <code>pgsection</code> and <code>psequential</code>,
<code>coef0.all</code> contains the intercept for the model in each iterative step in the tuning path.
For <code>bsrr</code> objects obtained from <code>sequential</code> path,
<code>coef0.all</code> contains the best fitting
intercepts of size <code class="reqn">s=0,1,\dots,p</code> and <code class="reqn">\lambda</code> in
<code>lambda.list</code> with the smallest loss function.</p>
</td></tr>
<tr><td><code>loss.all</code></td>
<td>
<p>For <code>bsrr</code> objects obtained from <code>gsection</code>, <code>pgsection</code> and <code>psequential</code>,
<code>loss.all</code> contains the training loss of the model in each iterative step in the tuning path.
For <code>bsrr</code> objects obtained from <code>sequential</code> path, this is a
list of the training loss of the best fitting intercepts of model size
<code class="reqn">s=0,1,\dots,p</code> and <code class="reqn">\lambda</code> in <code>lambda.list</code>. For <code>"bsrr"</code> object obtained by <code>"bsrr"</code>,
the training loss of the <code class="reqn">i^{th} \lambda</code> and the <code class="reqn">j^{th}</code> <code>s</code>
is at the <code class="reqn">i^{th}</code> list component's <code class="reqn">j^{th}</code> entry.</p>
</td></tr>
<tr><td><code>ic.all</code></td>
<td>
<p>For <code>bsrr</code> objects obtained from <code>gsection</code>, <code>pgsection</code> and <code>psequential</code>,
<code>ic.all</code> contains the values of the chosen information criterion of the model in each iterative step in the tuning path.
For <code>bsrr</code> objects obtained from <code>sequential</code> path, this is a
matrix of the values of the chosen information criterion of model size <code class="reqn">s=0,1,\dots,p</code>
and <code class="reqn">\lambda</code> in <code>lambda.list</code> with the smallest loss function. For <code>"bsrr"</code> object obtained by <code>"bsrr"</code>,
the training loss of the <code class="reqn">i^{th} \lambda</code> and the <code class="reqn">j^{th}</code>
<code>s</code> is at the <code class="reqn">i^{th}</code> row <code class="reqn">j^{th}</code> column. Only available when
model selection is based on a certain information criterion.</p>
</td></tr>
<tr><td><code>cvm.all</code></td>
<td>
<p>For <code>bsrr</code> objects obtained from <code>gsection</code>, <code>pgsection</code> and <code>psequential</code>,
<code>cvm.all</code> contains the mean cross-validation error of the model in each iterative step in the tuning path.
For <code>bsrr</code> objects obtained from <code>sequential</code> path, this is a
matrix of the mean cross-validation error of model size
<code class="reqn">s=0,1,\dots,p</code> and <code class="reqn">\lambda</code> in <code>lambda.list</code> with the
smallest loss function. For <code>"bsrr"</code> object obtained by <code>"bsrr"</code>, the training loss of the <code class="reqn">i^{th}
\lambda</code> and the <code class="reqn">j^{th}</code> <code>s</code> is at the <code class="reqn">i^{th}</code> row
<code class="reqn">j^{th}</code> column. Only available when model selection is based on the
cross-validation.</p>
</td></tr>
<tr><td><code>lambda.all</code></td>
<td>
<p>The lambda chosen for each step in <code>pgsection</code> and <code>psequential</code>.</p>
</td></tr>
<tr><td><code>family</code></td>
<td>
<p>Type of the model.</p>
</td></tr>
<tr><td><code>s.list</code></td>
<td>
<p>The input
<code>s.list</code>.</p>
</td></tr> <tr><td><code>nsample</code></td>
<td>
<p>The sample size.</p>
</td></tr>
<tr><td><code>type</code></td>
<td>
<p>Either <code>"bss"</code> or <code>"bsrr"</code>.</p>
</td></tr>
<tr><td><code>method</code></td>
<td>
<p>Method used for tuning parameters selection.</p>
</td></tr>
<tr><td><code>ic.type</code></td>
<td>
<p>The criterion of model selection.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Liyuan Hu, Kangkang Jiang, Yanhang Zhang, Jin Zhu, Canhong Wen and Xueqin Wang.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+plot.bsrr">plot.bsrr</a></code>, <code><a href="#topic+summary.bsrr">summary.bsrr</a></code>,
<code><a href="#topic+coef.bsrr">coef.bsrr</a></code>, <code><a href="#topic+predict.bsrr">predict.bsrr</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
#-------------------linear model----------------------#
# Generate simulated data
n &lt;- 200
p &lt;- 20
k &lt;- 5
rho &lt;- 0.4
seed &lt;- 10
Tbeta &lt;- rep(0, p)
Tbeta[1:k*floor(p/k):floor(p/k)] &lt;- rep(1, k)
Data &lt;- gen.data(n, p, k, rho, family = "gaussian", beta = Tbeta, seed = seed)
x &lt;- Data$x[1:140, ]
y &lt;- Data$y[1:140]
x_new &lt;- Data$x[141:200, ]
y_new &lt;- Data$y[141:200]
lambda.list &lt;- exp(seq(log(5), log(0.1), length.out = 10))
lm.bsrr &lt;- bsrr(x, y, method = "pgsection")
coef(lm.bsrr)
print(lm.bsrr)
summary(lm.bsrr)
pred.bsrr &lt;- predict(lm.bsrr, newx = x_new)

# generate plots
plot(lm.bsrr)
#-------------------logistic model----------------------#
#Generate simulated data
Data &lt;- gen.data(n, p, k, rho, family = "binomial", beta = Tbeta, seed = seed)

x &lt;- Data$x[1:140, ]
y &lt;- Data$y[1:140]
x_new &lt;- Data$x[141:200, ]
y_new &lt;- Data$y[141:200]
lambda.list &lt;- exp(seq(log(5), log(0.1), length.out = 10))
logi.bsrr &lt;- bsrr(x, y, family = "binomial", lambda.list = lambda.list)
coef(logi.bsrr)
print(logi.bsrr)
summary(logi.bsrr)
pred.bsrr &lt;- predict(logi.bsrr, newx = x_new)

# generate plots
plot(logi.bsrr)
#-------------------poisson model----------------------#
Data &lt;- gen.data(n, p, k, rho=0.3, family = "poisson", beta = Tbeta, seed = seed)

x &lt;- Data$x[1:140, ]
y &lt;- Data$y[1:140]
x_new &lt;- Data$x[141:200, ]
y_new &lt;- Data$y[141:200]
lambda.list &lt;- exp(seq(log(5), log(0.1), length.out = 10))
poi.bsrr &lt;- bsrr(x, y, family = "poisson", lambda.list = lambda.list)
coef(poi.bsrr)
print(poi.bsrr)
summary(poi.bsrr)
pred.bsrr &lt;- predict(poi.bsrr, newx = x_new)

# generate plots
plot(poi.bsrr)
#-------------------coxph model----------------------#
#Generate simulated data
Data &lt;- gen.data(n, p, k, rho, family = "cox", scal = 10, beta = Tbeta)

x &lt;- Data$x[1:140, ]
y &lt;- Data$y[1:140, ]
x_new &lt;- Data$x[141:200, ]
y_new &lt;- Data$y[141:200, ]
lambda.list &lt;- exp(seq(log(5), log(0.1), length.out = 10))
cox.bsrr &lt;- bsrr(x, y, family = "cox", lambda.list = lambda.list)
coef(cox.bsrr)
print(cox.bsrr)
summary(cox.bsrr)
pred.bsrr &lt;- predict(cox.bsrr, newx = x_new)

# generate plots
plot(cox.bsrr)

#----------------------High dimensional linear models--------------------#
## Not run: 
data &lt;- gen.data(n, p = 1000, k, family = "gaussian", seed = seed)

# Best subset selection with SIS screening
lm.high &lt;- bsrr(data$x, data$y, screening.num = 100)

## End(Not run)

#-------------------group selection----------------------#
beta &lt;- rep(c(rep(1,2),rep(0,3)), 4)
Data &lt;- gen.data(200, 20, 5, rho=0.4, beta = beta, seed =10)
x &lt;- Data$x
y &lt;- Data$y

group.index &lt;- c(rep(1, 2), rep(2, 3), rep(3, 2), rep(4, 3),
                rep(5, 2), rep(6, 3), rep(7, 2), rep(8, 3))
lm.groupbsrr &lt;- bsrr(x, y, s.min = 1, s.max = 8, group.index = group.index)
coef(lm.groupbsrr)
print(lm.groupbsrr)
summary(lm.groupbsrr)
pred.groupl0l2 &lt;- predict(lm.groupbsrr, newx = x_new)
#-------------------include specified variables----------------------#
Data &lt;- gen.data(n, p, k, rho, family = "gaussian", beta = Tbeta, seed = seed)
lm.bsrr &lt;- bsrr(Data$x, Data$y, always.include = 2)

</code></pre>

<hr>
<h2 id='coef.bsrr'>Provides estimated coefficients from a fitted &quot;bsrr&quot; object.</h2><span id='topic+coef.bsrr'></span>

<h3>Description</h3>

<p>This function provides estimated
coefficients from a fitted &quot;<code>bsrr</code>&quot; object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'bsrr'
coef(object, sparse = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="coef.bsrr_+3A_object">object</code></td>
<td>
<p>A &quot;<code>bsrr</code>&quot; project.</p>
</td></tr>
<tr><td><code id="coef.bsrr_+3A_sparse">sparse</code></td>
<td>
<p>Logical or NULL, specifying whether the coefficients should be
presented as sparse matrix or not.</p>
</td></tr>
<tr><td><code id="coef.bsrr_+3A_...">...</code></td>
<td>
<p>Other arguments.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>If <code>sparse == FALSE</code>, a vector containing the estimated coefficients
from a fitted &quot;<code>bsrr</code>&quot; object is returned. If <code>sparse == TRUE</code>,
a <code>dgCMatrix</code> containing the estimated coefficients
is returned.
</p>


<h3>Author(s)</h3>

<p>Liyuan Hu, Kangkang Jiang, Yanhang Zhang, Jin Zhu, Canhong Wen and Xueqin Wang.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+bsrr">bsrr</a></code>, <code><a href="#topic+print.bsrr">print.bsrr</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Generate simulated data
n &lt;- 200
p &lt;- 20
k &lt;- 5
rho &lt;- 0.4
seed &lt;- 10
Tbeta &lt;- rep(0, p)
Tbeta[1:k*floor(p/k):floor(p/k)] &lt;- rep(1, k)
Data &lt;- gen.data(n, p, k, rho, family = "gaussian", beta = Tbeta, seed = seed)
lambda.list &lt;- exp(seq(log(5), log(0.1), length.out = 10))
lm.bsrr &lt;- bsrr(Data$x, Data$y, method = "pgsection")
coef(lm.bsrr)
</code></pre>

<hr>
<h2 id='deviance.bsrr'>Extract the deviance from a &quot;bsrr.one&quot; object.</h2><span id='topic+deviance.bsrr'></span>

<h3>Description</h3>

<p>Similar to other deviance methods, which returns deviance from a fitted &quot;<code>bsrr.one</code>&quot; object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'bsrr'
deviance(object, best.model = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="deviance.bsrr_+3A_object">object</code></td>
<td>
<p>A &quot;<code>bsrr</code>&quot; object.</p>
</td></tr>
<tr><td><code id="deviance.bsrr_+3A_best.model">best.model</code></td>
<td>
<p>Whether only return the loglikelihood of the best model. Default is <code>TRUE</code>.
If <code>best.model = FALSE</code>, the loglikelihood of the best models with model size and
<code class="reqn">\lambda</code> in the original <code>s.list</code> and <code>lambda.list</code> (for <code>method = "sequential"</code>)
or in the iteration path (for <code>method = "gsection"</code>, <code>method = "pgsection"</code>,
and <code>method = "psequential"</code>) is returned.</p>
</td></tr>
<tr><td><code id="deviance.bsrr_+3A_...">...</code></td>
<td>
<p>additional arguments</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix or vector containing the deviance for each model is returned.
For <code>bsrr</code> object fitted by <code>sequantial</code> method, values in each row in the
returned matrix corresponding to the model size in <code>s.list</code>, and each column the shrinkage parameters
in <code>lambda.list</code>.
</p>
<p>For <code>bsrr</code> object fitted by <code>gsection</code>, <code>pgsection</code> and <code>psequential</code>, the returned vector
contains deviance for fitted models in each iteration. The coefficients of those model can be extracted
from <code>beta.all</code> and <code>coef0.all</code> in the <code>bsrr</code> object.
</p>


<h3>Author(s)</h3>

<p>Liyuan Hu, Kangkang Jiang, Yanhang Zhang, Jin Zhu, Canhong Wen and Xueqin Wang.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+bsrr">bsrr</a></code>, <code><a href="#topic+summary.bsrr">summary.bsrr</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Generate simulated data
n &lt;- 200
p &lt;- 20
k &lt;- 5
rho &lt;- 0.4
seed &lt;- 10
Tbeta &lt;- rep(0, p)
Tbeta[1:k*floor(p/k):floor(p/k)] &lt;- rep(1, k)
Data &lt;- gen.data(n, p, k, rho, family = "gaussian", seed = seed)
lm.bsrr &lt;- bsrr(Data$x, Data$y, method = "sequential")

deviance(lm.bsrr)
deviance(lm.bsrr, best.model = FALSE)
</code></pre>

<hr>
<h2 id='duke'>Duke breast cancer data</h2><span id='topic+duke'></span>

<h3>Description</h3>

<p>This data set details microarray experiment for breast cancer patients.
</p>


<h3>Format</h3>

<p>A data frame with 46 rows and 7130 variables,
where the first variable is the label of estrogen receptor-positive/negative,
and the remaining 7129 variables are 7129 gene.
</p>


<h3>Details</h3>

<p>The binary variable Status is used to classify the patients into
estrogen receptor-positive (y = 0) and estrogen receptor-negative (y = 1).
The other variables contain the expression level of the considered genes.
</p>


<h3>References</h3>

<p>M. West, C. Blanchette, H. Dressman, E. Huang, S. Ishida, R. Spang, H. Zuzan, J.A. Olson, Jr., J.R. Marks and Joseph R. Nevins (2001) &lt;doi:10.1073/pnas.201162998&gt; Predicting the clinical status of human breast cancer by using gene expression profiles, Proceedings of the National Academy of Sciences of the USA, Vol 98(20), 11462-11467.
</p>

<hr>
<h2 id='gen.data'>Generate simulated data</h2><span id='topic+gen.data'></span>

<h3>Description</h3>

<p>Generate data for simulations under the generalized linear model and Cox
model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gen.data(
  n,
  p,
  k = NULL,
  rho = 0,
  family = c("gaussian", "binomial", "poisson", "cox"),
  beta = NULL,
  cortype = 1,
  snr = 10,
  censoring = TRUE,
  c = 1,
  scal,
  sigma = 1,
  seed = 1
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gen.data_+3A_n">n</code></td>
<td>
<p>The number of observations.</p>
</td></tr>
<tr><td><code id="gen.data_+3A_p">p</code></td>
<td>
<p>The number of predictors of interest.</p>
</td></tr>
<tr><td><code id="gen.data_+3A_k">k</code></td>
<td>
<p>The number of nonzero coefficients in the underlying regression
model. Can be omitted if <code>beta</code> is supplied.</p>
</td></tr>
<tr><td><code id="gen.data_+3A_rho">rho</code></td>
<td>
<p>A parameter used to characterize the pairwise correlation in
predictors. Default is <code>0</code>.</p>
</td></tr>
<tr><td><code id="gen.data_+3A_family">family</code></td>
<td>
<p>The distribution of the simulated data. <code>"gaussian"</code> for
gaussian data.<code>"binomial"</code> for binary data. <code>"poisson"</code> for count data. <code>"cox"</code>
for survival data.</p>
</td></tr>
<tr><td><code id="gen.data_+3A_beta">beta</code></td>
<td>
<p>The coefficient values in the underlying regression model.</p>
</td></tr>
<tr><td><code id="gen.data_+3A_cortype">cortype</code></td>
<td>
<p>The correlation structure. <code>cortype = 1</code> denotes the exponential structure,
where the covariance matrix has <code class="reqn">(i,j)</code> entry equals <code class="reqn">rho^{|i-j|}</code>.
codecortype = 2 denotes the constant structure, where the <code class="reqn">(i,j)</code> entry of covariance
matrix is <code class="reqn">rho</code> for every <code class="reqn">i \neq j</code> and 1 elsewhere. <code>cortype = 3</code> denotes the moving average
structure. Details can be found below.</p>
</td></tr>
<tr><td><code id="gen.data_+3A_snr">snr</code></td>
<td>
<p>A numerical value controlling the signal-to-noise ratio (SNR). The SNR is defined as
as the variance of <code class="reqn">x\beta</code> divided
by the variance of a gaussian noise: <code class="reqn">\frac{Var(x\beta)}{\sigma^2}</code>.
The gaussian noise <code class="reqn">\epsilon</code> is set with mean 0 and variance.
The noise is added to the linear predictor <code class="reqn">\eta</code> = <code class="reqn">x\beta</code>. Default is <code>snr = 10</code>.
This option is invalid for <code>cortype = 3</code>.</p>
</td></tr>
<tr><td><code id="gen.data_+3A_censoring">censoring</code></td>
<td>
<p>Whether data is censored or not. Valid only for <code>family = "cox"</code>. Default is <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="gen.data_+3A_c">c</code></td>
<td>
<p>The censoring rate. Default is <code>1</code>.</p>
</td></tr>
<tr><td><code id="gen.data_+3A_scal">scal</code></td>
<td>
<p>A parameter in generating survival time based on the Weibull distribution. Only used for the &quot;<code>cox</code>&quot; family.</p>
</td></tr>
<tr><td><code id="gen.data_+3A_sigma">sigma</code></td>
<td>
<p>A parameter used to control the signal-to-noise ratio. For linear regression,
it is the error variance <code class="reqn">\sigma^2</code>. For logistic regression and Cox's model,
the larger the value of sigma, the higher the signal-to-noise ratio. Valid only for <code>cortype = 3</code>.</p>
</td></tr>
<tr><td><code id="gen.data_+3A_seed">seed</code></td>
<td>
<p>seed to be used in generating the random numbers.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>We generate an <code class="reqn">n \times p</code> random Gaussian matrix
<code class="reqn">X</code> with mean 0 and a covariance matrix with an exponential structure
or a constant structure. For the exponential structure, the covariance matrix
has <code class="reqn">(i,j)</code> entry equals <code class="reqn">rho^{|i-j|}</code>. For the constant structure,
the <code class="reqn">(i,j)</code> entry of the covariance matrix is <code class="reqn">rho</code> for every <code class="reqn">i
\neq j</code> and 1 elsewhere. For the moving average structure,  For the design matrix <code class="reqn">X</code>,
we first generate an <code class="reqn">n \times p</code> random Gaussian matrix <code class="reqn">\bar{X}</code>
whose entries are i.i.d. <code class="reqn">\sim N(0,1)</code> and then normalize its columns
to the <code class="reqn">\sqrt n</code> length. Then the design matrix <code class="reqn">X</code> is generated with
<code class="reqn">X_j = \bar{X}_j + \rho(\bar{X}_{j+1}+\bar{X}_{j-1})</code> for <code class="reqn">j=2,\dots,p-1</code>.
</p>
<p>For <code>family = "gaussian"</code> , the data model is </p>
<p style="text-align: center;"><code class="reqn">Y = X \beta +
\epsilon.</code>
</p>

<p>The underlying regression coefficient <code class="reqn">\beta</code> has uniform distribution [m, 100m], <code class="reqn">m=5 \sqrt{2log(p)/n}.</code>
</p>
<p>For <code>family= "binomial"</code>, the data model is </p>
<p style="text-align: center;"><code class="reqn">Prob(Y = 1) = \exp(X
\beta + \epsilon)/(1 + \exp(X \beta + \epsilon)).</code>
</p>

<p>The underlying regression coefficient <code class="reqn">\beta</code> has uniform distribution [2m, 10m], <code class="reqn">m = 5\sigma \sqrt{2log(p)/n}.</code>
</p>
<p>For <code>family = "poisson"</code> , the data is modeled to have an exponential distribution: </p>
<p style="text-align: center;"><code class="reqn">Y = Exp(\exp(X \beta +
\epsilon)).</code>
</p>

<p>For <code>family = "cox"</code>, the data model is
</p>
<p style="text-align: center;"><code class="reqn">T = (-\log(S(t))/\exp(X \beta))^{1/scal}.</code>
</p>

<p>The centering time is generated from uniform distribution <code class="reqn">[0, c]</code>,
then we define the censor status as <code class="reqn">\delta = I\{T \leq C\}, R = min\{T, C\}</code>.
The underlying regression coefficient <code class="reqn">\beta</code> has uniform distribution [2m, 10m], <code class="reqn">m = 5\sigma \sqrt{2log(p)/n}.</code>
In the above models, <code class="reqn">\epsilon \sim N(0,
\sigma^2 ),</code> where <code class="reqn">\sigma^2</code> is determined by the <code>snr</code>.
</p>


<h3>Value</h3>


<table>
<tr><td><code>x</code></td>
<td>
<p>Design matrix of predictors.</p>
</td></tr> <tr><td><code>y</code></td>
<td>
<p>Response variable.</p>
</td></tr>
<tr><td><code>Tbeta</code></td>
<td>
<p>The coefficients used in the underlying regression model.</p>
</td></tr> 
</table>


<h3>Author(s)</h3>

<p>Liyuan Hu, Kangkang Jiang, Yanhang Zhang, Jin Zhu, Canhong Wen and Xueqin Wang.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+bsrr">bsrr</a></code>, <code><a href="#topic+predict.bsrr">predict.bsrr</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Generate simulated data
n &lt;- 200
p &lt;- 20
k &lt;- 5
rho &lt;- 0.4
SNR &lt;- 10
cortype &lt;- 1
seed &lt;- 10
Data &lt;- gen.data(n, p, k, rho, family = "gaussian", cortype = cortype, snr = SNR, seed = seed)
x &lt;- Data$x[1:140, ]
y &lt;- Data$y[1:140]
x_new &lt;- Data$x[141:200, ]
y_new &lt;- Data$y[141:200]
lambda.list &lt;- exp(seq(log(5), log(0.1), length.out = 10))
lm.bsrr &lt;- bsrr(x, y, method = "pgsection")
</code></pre>

<hr>
<h2 id='gravier'>breast cancer data set</h2><span id='topic+gravier'></span>

<h3>Description</h3>

<p>Gravier et al. (2010) have considered small, invasive ductal carcinomas
without axillary lymph node involvement (T1T2N0) to predict metastasis of
small node-negative breast carcinoma. Using comparative genomic
hybridization arrays, they examined 168 patients over a five-year period.
The 111 patients with no event after diagnosis were labelled good, and the
57 patients with early metastasis were labelled poor.
</p>


<h3>Format</h3>

<p>A list containing the design matrix X and response matrix y
</p>


<h3>Value</h3>

<p>No return value
</p>


<h3>Source</h3>

<p><a href="https://github.com/ramhiser">https://github.com/ramhiser</a>
</p>


<h3>References</h3>

<p>Eleonore Gravier., Gaelle Pierron., and Anne Vincent-Salomon.
(2010). A prognostic DNA signature for T1T2 node-negative breast cancer
patients.
</p>

<hr>
<h2 id='logLik.bsrr'>Extract the log-likelihood from a &quot;bsrr.one&quot; object.</h2><span id='topic+logLik.bsrr'></span>

<h3>Description</h3>

<p>This function returns the log-likelihood for the fitted models.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'bsrr'
logLik(object, best.model = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="logLik.bsrr_+3A_object">object</code></td>
<td>
<p>A &quot;<code>bsrr</code>&quot; object.</p>
</td></tr>
<tr><td><code id="logLik.bsrr_+3A_best.model">best.model</code></td>
<td>
<p>Whether only return the log-likelihood of the best model. Default is <code>TRUE</code>.
If <code>best.model = FALSE</code>, the log-likelihood of the best models with model size and
<code class="reqn">\lambda</code> in the original <code>s.list</code> and <code>lambda.list</code> (for <code>method = "sequential"</code>)
or in the iteration path (for <code>method = "gsection"</code>, <code>method = "pgsection"</code>,
and <code>method = "psequential"</code>) is returned.</p>
</td></tr>
<tr><td><code id="logLik.bsrr_+3A_...">...</code></td>
<td>
<p>additional arguments</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The log-likelihood for the best model chosen by a certain information criterion
or cross-validation corresponding to the call in <code>bsrr</code> or the best models
with model size and <code class="reqn">\lambda</code> in the original <code>s.list</code> and <code>lambda.list</code>
(or the in the iteration path) can be returned.
For &quot;lm&quot; fits it is assumed that the scale has been estimated
(by maximum likelihood or REML),
and all the constants in the log-likelihood are included.
</p>


<h3>Value</h3>

<p>A matrix or vector containing the log-likelihood for each model is returned.
For <code>bsrr</code> objects fitted by <code>sequantial</code> method, values in each row in the
returned matrix corresponding to the model size in <code>s.list</code>, and each column the shrinkage parameters
in <code>lambda.list</code>.
</p>
<p>For <code>bsrr</code> objects fitted by <code>gsection</code>, <code>pgsection</code> and <code>psequential</code>, the returned vector
contains log-likelihood for fitted models in each iteration. The coefficients of those model can be extracted
from <code>beta.all</code> and <code>coef0.all</code> in the <code>bsrr</code> object.
</p>


<h3>Author(s)</h3>

<p>Liyuan Hu, Kangkang Jiang, Yanhang Zhang, Jin Zhu, Canhong Wen and Xueqin Wang.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+bsrr">bsrr</a></code>, <code><a href="#topic+summary.bsrr">summary.bsrr</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Generate simulated data
n &lt;- 200
p &lt;- 20
k &lt;- 5
rho &lt;- 0.4
SNR &lt;- 10
cortype &lt;- 1
seed &lt;- 10
Tbeta &lt;- rep(0, p)
Tbeta[1:k*floor(p/k):floor(p/k)] &lt;- rep(1, k)
Data &lt;- gen.data(n, p, k, rho, family = "gaussian", cortype = cortype, snr = SNR, seed = seed)
lm.bsrr &lt;- bsrr(Data$x, Data$y, method = "sequential")

logLik(lm.bsrr, best.model = FALSE)

</code></pre>

<hr>
<h2 id='patient.data'>Lymphoma patients data set</h2><span id='topic+patient.data'></span>

<h3>Description</h3>

<p>Lymphoma patients data set
</p>


<h3>Format</h3>

<p>patient.data A list with survival times, staus and covariates from patients.
</p>


<h3>Details</h3>

<p>A subset of the data set of lymphoma patients used in the study of Alizadeh et al. (2000) and also Simon et al.
(2011).
</p>


<h3>References</h3>

<p>Alizadeh, A. A., et al. (2000). Distinct types of diffuse large B-cell lymphoma identified by gene
expression profiling. Nature, 403(6769), p.503
Simon, N., Friedman, J., Hastie, T., &amp; Tibshirani, R. (2011). Regularization paths for Cox's proportional hazards model via coordinate descent. Journal of statistical software, 39(5), 1.
</p>

<hr>
<h2 id='plot.bsrr'>Produces a coefficient profile plot of the coefficient or loss function
paths</h2><span id='topic+plot.bsrr'></span>

<h3>Description</h3>

<p>Produces a coefficient profile plot of the coefficient or loss function
paths
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'bsrr'
plot(
  x,
  type = c("tune", "coefficients"),
  lambda = NULL,
  sign.lambda = 0,
  breaks = T,
  K = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.bsrr_+3A_x">x</code></td>
<td>
<p>A <code>"bsrr"</code> object.</p>
</td></tr>
<tr><td><code id="plot.bsrr_+3A_type">type</code></td>
<td>
<p>One of <code>"tune"</code>, <code>"coefficients"</code>, <code>"both"</code>.
For <code>"bsrr"</code> with <code class="reqn">L_2</code> shrinkage:
If (<code>type = "tune"</code>), the path of corresponding information criterion
or cross-validation loss is provided;
If <code>type = "coefficients"</code>, a lambda should be provided and and this funciton provides a coefficient profile plot of the coefficient;
For <code>"bsrr"</code> object without <code class="reqn">L_2</code> shrinkage:
If <code>type = "tune"</code>, a path of lcorresponding information criterion or cross-validation loss is provided.
If <code>type = "coefficients"</code>, it provides a coefficient profile plot of the coefficient.</p>
</td></tr>
<tr><td><code id="plot.bsrr_+3A_lambda">lambda</code></td>
<td>
<p>For <code>"bsrr"</code> with <code class="reqn">L_2</code> shrinkage: To plot the change of coefficients with lambda equals this value for <code>type = "coefficients"</code> or <code>type = "both"</code>.</p>
</td></tr>
<tr><td><code id="plot.bsrr_+3A_sign.lambda">sign.lambda</code></td>
<td>
<p>For <code>"bsrr"</code> with <code class="reqn">L_2</code> shrinkage: A logical value indicating whether to show lambda on log scale. Default is 0.</p>
</td></tr>
<tr><td><code id="plot.bsrr_+3A_breaks">breaks</code></td>
<td>
<p>For <code>"bsrr"</code> object without <code class="reqn">L_2</code> shrinkage: If <code>TRUE</code>, a vertical line is drawn at a specified break point in
the coefficient paths.</p>
</td></tr>
<tr><td><code id="plot.bsrr_+3A_k">K</code></td>
<td>
<p>For <code>"bsrr"</code> object without <code class="reqn">L_2</code> shrinkage: Which break point should the vertical line be drawn at. Default is the optimal model size.</p>
</td></tr>
<tr><td><code id="plot.bsrr_+3A_...">...</code></td>
<td>
<p>Other graphical parameters to plot</p>
</td></tr>
</table>


<h3>Value</h3>

<p>No return value, called for plots generation
</p>


<h3>Author(s)</h3>

<p>Liyuan Hu, Kangkang Jiang, Yanhang Zhang, Jin Zhu, Canhong Wen and Xueqin Wang.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+bsrr">bsrr</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Generate simulated data
n &lt;- 200
p &lt;- 20
k &lt;- 5
rho &lt;- 0.4
seed &lt;- 10
Tbeta &lt;- rep(0, p)
Tbeta[1:k*floor(p/k):floor(p/k)] &lt;- rep(1, k)
Data &lt;- gen.data(n, p, k, rho, family = "gaussian", beta = Tbeta, seed = seed)
lambda.list &lt;- exp(seq(log(5), log(0.1), length.out = 10))
lm.bsrr &lt;- bsrr(Data$x, Data$y, method = "pgsection")

# generate plots
plot(lm.bsrr)

</code></pre>

<hr>
<h2 id='predict.bsrr'>make predictions from a &quot;bsrr&quot; object.</h2><span id='topic+predict.bsrr'></span>

<h3>Description</h3>

<p>Returns predictions from a fitted
&quot;<code>bsrr</code>&quot; object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'bsrr'
predict(object, newx, type = c("link", "response"), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="predict.bsrr_+3A_object">object</code></td>
<td>
<p>Output from the <code>bsrr</code> function.</p>
</td></tr>
<tr><td><code id="predict.bsrr_+3A_newx">newx</code></td>
<td>
<p>New data used for prediction. If omitted, the fitted linear predictors are used.</p>
</td></tr>
<tr><td><code id="predict.bsrr_+3A_type">type</code></td>
<td>
<p><code>type = "link"</code> gives the linear predictors for <code>"binomial"</code>,
<code>"poisson"</code> or <code>"cox"</code> models; for <code>"gaussian"</code> models it gives the
fitted values. <code>type = "response"</code> gives the fitted probabilities for
<code>"binomial"</code>, fitted mean for <code>"poisson"</code> and the fitted relative-risk for
<code>"cox"</code>; for <code>"gaussian"</code>, <code>type = "response"</code> is equivalent to <code>type = "link"</code></p>
</td></tr>
<tr><td><code id="predict.bsrr_+3A_...">...</code></td>
<td>
<p>Additional arguments affecting the predictions produced.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The object returned depends on the types of family.
</p>


<h3>Author(s)</h3>

<p>Liyuan Hu, Kangkang Jiang, Yanhang Zhang, Jin Zhu, Canhong Wen and Xueqin Wang.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+bsrr">bsrr</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
#-------------------linear model----------------------#
# Generate simulated data
n &lt;- 200
p &lt;- 20
k &lt;- 5
rho &lt;- 0.4
seed &lt;- 10
Tbeta &lt;- rep(0, p)
Tbeta[1:k*floor(p/k):floor(p/k)] &lt;- rep(1, k)
Data &lt;- gen.data(n, p, k, rho, family = "gaussian", beta = Tbeta, seed = seed)
x &lt;- Data$x[1:140, ]
y &lt;- Data$y[1:140]
x_new &lt;- Data$x[141:200, ]
y_new &lt;- Data$y[141:200]
lambda.list &lt;- exp(seq(log(5), log(0.1), length.out = 10))
lm.bsrr &lt;- bsrr(x, y, method = "pgsection")

pred.bsrr &lt;- predict(lm.bsrr, newx = x_new)

#-------------------logistic model----------------------#
#Generate simulated data
Data &lt;- gen.data(n, p, k, rho, family = "binomial", beta = Tbeta, seed = seed)

x &lt;- Data$x[1:140, ]
y &lt;- Data$y[1:140]
x_new &lt;- Data$x[141:200, ]
y_new &lt;- Data$y[141:200]
lambda.list &lt;- exp(seq(log(5), log(0.1), length.out = 10))
logi.bsrr &lt;- bsrr(x, y, tune="cv",
                 family = "binomial", lambda.list = lambda.list, method = "sequential")

pred.bsrr &lt;- predict(logi.bsrr, newx = x_new)

#-------------------coxph model----------------------#
#Generate simulated data
Data &lt;- gen.data(n, p, k, rho, family = "cox", beta = Tbeta, scal = 10)

x &lt;- Data$x[1:140, ]
y &lt;- Data$y[1:140, ]
x_new &lt;- Data$x[141:200, ]
y_new &lt;- Data$y[141:200, ]
lambda.list &lt;- exp(seq(log(5), log(0.1), length.out = 10))
cox.bsrr &lt;- bsrr(x, y, family = "cox", lambda.list = lambda.list)

pred.bsrr &lt;- predict(cox.bsrr, newx = x_new)

#-------------------group selection----------------------#
beta &lt;- rep(c(rep(1,2),rep(0,3)), 4)
Data &lt;- gen.data(200, 20, 5, rho=0.4, beta = beta, seed =10)
x &lt;- Data$x
y &lt;- Data$y

group.index &lt;- c(rep(1, 2), rep(2, 3), rep(3, 2), rep(4, 3),
                rep(5, 2), rep(6, 3), rep(7, 2), rep(8, 3))
lm.groupbsrr &lt;- bsrr(x, y, s.min = 1, s.max = 8, group.index = group.index)

pred.groupbsrr &lt;- predict(lm.groupbsrr, newx = x_new)

</code></pre>

<hr>
<h2 id='print.bsrr'>print method for a &quot;bsrr&quot; object</h2><span id='topic+print.bsrr'></span>

<h3>Description</h3>

<p>Print the primary elements of the &quot;<code>bsrr</code>&quot; object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'bsrr'
print(x, digits = max(5, getOption("digits") - 5), nonzero = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.bsrr_+3A_x">x</code></td>
<td>
<p>A &quot;<code>bsrr</code>&quot; object.</p>
</td></tr>
<tr><td><code id="print.bsrr_+3A_digits">digits</code></td>
<td>
<p>Minimum number of significant digits to be used.</p>
</td></tr>
<tr><td><code id="print.bsrr_+3A_nonzero">nonzero</code></td>
<td>
<p>Whether the output should only contain the non-zero coefficients.</p>
</td></tr>
<tr><td><code id="print.bsrr_+3A_...">...</code></td>
<td>
<p>additional print arguments</p>
</td></tr>
</table>


<h3>Details</h3>

<p>prints the fitted model and returns it invisibly.
</p>


<h3>Value</h3>

<p>No return value, called for side effect
</p>


<h3>Author(s)</h3>

<p>Liyuan Hu, Kangkang Jiang, Yanhang Zhang, Jin Zhu, Canhong Wen and Xueqin Wang.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+bsrr">bsrr</a></code>, <code><a href="#topic+coef.bsrr">coef.bsrr</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Generate simulated data
n = 200
p = 20
k = 5
rho = 0.4
seed = 10
Tbeta &lt;- rep(0, p)
Tbeta[1:k*floor(p/k):floor(p/k)] &lt;- rep(1, k)
Data = gen.data(n, p, k, rho, family = "gaussian", beta = Tbeta, seed=seed)
lambda.list = exp(seq(log(5), log(0.1), length.out = 10))
lm.bsrr = bsrr(Data$x, Data$y, lambda.list = lambda.list, method = "sequential")

print(lm.bsrr)

</code></pre>

<hr>
<h2 id='prostate'>Factors associated with prostate specific antigen</h2><span id='topic+prostate'></span>

<h3>Description</h3>

<p>Data from a study by by Stamey et al. (1989) to examine the association
between prostate specific antigen (PSA) and several clinical measures that
are potentially associated with PSA in men who were about to receive a
radical prostatectomy.  The variables are as follows:
</p>
 <ul>
<li><p> lcavol: Log cancer volume </p>
</li>
<li><p> lweight: Log prostate weight
</p>
</li>
<li><p> age: The man's age </p>
</li>
<li><p> lbph: Log of the amount of benign hyperplasia
</p>
</li>
<li><p> svi: Seminal vesicle invasion; 1=Yes, 0=No </p>
</li>
<li><p> lcp: Log of capsular
penetration </p>
</li>
<li><p> gleason: Gleason score </p>
</li>
<li><p> pgg45: Percent of Gleason
scores 4 or 5 </p>
</li>
<li><p> lpsa: Log PSA </p>
</li></ul>



<h3>Format</h3>

<p>A data frame with 97 observations on 9 variables
</p>


<h3>Value</h3>

<p>No return value
</p>


<h3>References</h3>

<p>Stamey, T., Kabalin, J., McNeal, J., Johnstone, I., Freiha, F.,
Redwine, E. and Yang, N. (1989). Prostate specific antigen in the diagnosis
and treatment of adenocarcinoma of the prostate II. Radical prostatectomy
treated patients, Journal of Urology 16: 1076-1083.
</p>

<hr>
<h2 id='SAheart'>Risk factors associated with heart disease</h2><span id='topic+SAheart'></span>

<h3>Description</h3>

<p>Data from a subset of the Coronary Risk-Factor Study baseline survey,
carried out in rural South Africa.
</p>


<h3>Format</h3>

<p>The variables are as follows:
</p>

<ul>
<li><p> sbp: Systolic blood pressure </p>
</li>
<li><p> tobacco: Cumulative tobacco
consumption, in kg </p>
</li>
<li><p> ldl: Low-density lipoprotein cholesterol </p>
</li>
<li>
<p>adiposity: Adipose tissue concentration </p>
</li>
<li><p> famhist: Family history of
heart disease (1=Present, 0=Absent) </p>
</li>
<li><p> typea: Score on test designed to
measure type-A behavior </p>
</li>
<li><p> obesity: Obesity </p>
</li>
<li><p> alcohol: Current
consumption of alcohol </p>
</li>
<li><p> age: Age of subject </p>
</li>
<li><p> chd: Coronary heart
disease at baseline; 1=Yes 0=No</p>
</li></ul>

<p>A data frame with 462 observations on 10 variables
</p>


<h3>Value</h3>

<p>No return value
</p>


<h3>References</h3>

<p>Rousseauw, J., du Plessis, J., Benade, A., Jordaan, P., Kotze,
J. and Ferreira, J. (1983).  Coronary risk factor screening in three rural
communities. South African Medical Journal 64: 430-436.
</p>

<hr>
<h2 id='summary.bsrr'>summary method for a &quot;bsrr&quot; object</h2><span id='topic+summary.bsrr'></span>

<h3>Description</h3>

<p>Print a summary of the &quot;bsrr&quot; object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'bsrr'
summary(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary.bsrr_+3A_object">object</code></td>
<td>
<p>A &quot;bsrr&quot; object.</p>
</td></tr>
<tr><td><code id="summary.bsrr_+3A_...">...</code></td>
<td>
<p>additional print arguments</p>
</td></tr>
</table>


<h3>Value</h3>

<p>No return value
</p>


<h3>Author(s)</h3>

<p>Liyuan Hu, Kangkang Jiang, Yanhang Zhang, Jin Zhu, Canhong Wen and Xueqin Wang.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+bsrr">bsrr</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

#-------------------linear model----------------------#
# Generate simulated data
n &lt;- 200
p &lt;- 20
k &lt;- 5
rho &lt;- 0.4
seed &lt;- 10
Tbeta &lt;- rep(0, p)
Tbeta[1:k*floor(p/k):floor(p/k)] &lt;- rep(1, k)
Data &lt;- gen.data(n, p, k, rho, family = "gaussian", beta = Tbeta, seed = seed)
lambda.list &lt;- exp(seq(log(5), log(0.1), length.out = 10))
lm.bsrr &lt;- bsrr(Data$x, Data$y, method = "pgsection")

summary(lm.bsrr)

#-------------------group selection----------------------#
beta &lt;- rep(c(rep(1,2),rep(0,3)), 4)
Data &lt;- gen.data(200, 20, 5, rho=0.4, beta = beta, snr = 100, seed =10)

group.index &lt;- c(rep(1, 2), rep(2, 3), rep(3, 2), rep(4, 3),
                rep(5, 2), rep(6, 3), rep(7, 2), rep(8, 3))
lm.groupbsrr &lt;- bsrr(Data$x, Data$y, s.min = 1, s.max = 8, group.index = group.index)

summary(lm.groupbsrr)

</code></pre>

<hr>
<h2 id='trim32'>The Bardet-Biedl syndrome Gene expression data</h2><span id='topic+trim32'></span>

<h3>Description</h3>

<p>Gene expression data (500 gene probes for 120 samples) from the microarray experiments of mammalianeye tissue samples of Scheetz et al. (2006).
</p>


<h3>Format</h3>

<p>A data frame with 120 rows and 501 variables, where the first variable is the expression level of TRIM32 gene,
and the remaining 500 variables are 500 gene probes.
</p>


<h3>Details</h3>

<p>In this study, laboratory rats (Rattus norvegicus) were studied to learn about gene expression and regulation in the mammalian eye.
Inbred rat strains were crossed and tissue extracted from the eyes of 120 animals from the F2 generation. Microarrays were used to measure levels of RNA expression in the isolated eye tissues of each subject.
Of the 31,000 different probes, 18,976 were detected at a sufficient level to be considered expressed in the mammalian eye.
For the purposes of this analysis, we treat one of those genes, Trim32, as the outcome.
Trim32 is known to be linked with a genetic disorder called Bardet-Biedl Syndrome (BBS): the mutation (P130S) in Trim32 gives rise to BBS.
</p>


<h3>Note</h3>

<p>This data set contains 120 samples with 500 predictors. The 500 predictors are features with maximum marginal correlation to Trim32 gene.
</p>


<h3>References</h3>

<p>T. Scheetz, k. Kim, R. Swiderski, A. Philp, T. Braun, K. Knudtson, A. Dorrance, G. DiBona, J. Huang, T. Casavant, V. Sheffield, E. Stone. Regulation of gene expression in the mammalian eye and its relevance to eye disease. Proceedings of the National Academy of Sciences of the United States of America, 2006.
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
