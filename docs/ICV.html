<!DOCTYPE html><html lang="en"><head><title>Help for package ICV</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {ICV}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#C_ICV'><p>The ICV rescaling constant.</p></a></li>
<li><a href='#h_ICV'><p>The ICV bandwidth.</p></a></li>
<li><a href='#h_isemixnorm'><p>The ISE-optimal bandwidth in the case when the true density is the specified mixture of normal distributions.</p></a></li>
<li><a href='#ICV'><p>The ICV function.</p></a></li>
<li><a href='#ISE_mixnorm'><p>The ISE function in the case when the underlying density is the specified mixture of normal distributions.</p></a></li>
<li><a href='#KDE_ICV'><p>Computing the kernel density estimate based on the ICV bandwidth.</p></a></li>
<li><a href='#L_ICV'><p>The ICV selection kernel.</p></a></li>
<li><a href='#LocICV'><p>The local ICV function.</p></a></li>
<li><a href='#MISE_mixnorm'><p>The MISE function in the case when the true density is the specified mixture of normal distributions and the selection kernel  <code>L_ICV</code> is used in the cross-validation stage.</p></a></li>
<li><a href='#mixnorm'><p>Generating a random sample from the specified mixture of normal distributions.</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Title:</td>
<td>Indirect Cross-Validation (ICV) for Kernel Density Estimation</td>
</tr>
<tr>
<td>Version:</td>
<td>1.0</td>
</tr>
<tr>
<td>Author:</td>
<td>Olga Savchuk</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Olga Savchuk &lt;olga.y.savchuk@gmail.com&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Functions for computing the global and local Gaussian density estimates based on the ICV bandwidth. See the article of Savchuk, O.Y., Hart, J.D., Sheather, S.J. (2010). Indirect cross-validation for density estimation. Journal of the American Statistical Association, 105(489), 415-423 &lt;<a href="https://doi.org/10.1198%2Fjasa.2010.tm08532">doi:10.1198/jasa.2010.tm08532</a>&gt;.</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.1.1)</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>5.0.1</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2017-01-22 13:15:25 UTC; Olga</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2017-01-22 17:02:12</td>
</tr>
</table>
<hr>
<h2 id='C_ICV'>The ICV rescaling constant.</h2><span id='topic+C_ICV'></span>

<h3>Description</h3>

<p>Computing the ICV rescaling constant defined by expression (3) of Savchuk, Hart, and Sheather (2010).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>C_ICV(alpha, sigma)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="C_ICV_+3A_alpha">alpha</code></td>
<td>
<p>first parameter of the selection kernel,</p>
</td></tr>
<tr><td><code id="C_ICV_+3A_sigma">sigma</code></td>
<td>
<p>second parameter of the selection kernel.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Calculation of the ICV rescaling constant <code class="reqn">C</code> defined by (3) in Savchuk, Hart, and Sheather (2010). The constant is a function of the parameters <code class="reqn">(\alpha,\sigma)</code> of the selection kernel <code><a href="#topic+L_ICV">L_ICV</a></code> defined by expression (4) in the same article. The Gaussian kernel is to be used for computing the ultimate density estimate.
</p>


<h3>Value</h3>

<p>The ICV rescaling constant <code class="reqn">C</code>.
</p>


<h3>References</h3>

<p>Savchuk, O.Y., Hart, J.D., Sheather, S.J. (2010). Indirect cross-validation for density estimation. <em>Journal of the American Statistical Association</em>, 105(489), 415-423.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+ICV">ICV</a></code>, <code><a href="#topic+h_ICV">h_ICV</a></code>, <code><a href="#topic+L_ICV">L_ICV</a></code>, <code><a href="#topic+MISE_mixnorm">MISE_mixnorm</a></code>, <code><a href="#topic+KDE_ICV">KDE_ICV</a></code>, <code><a href="#topic+LocICV">LocICV</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># ICV rescaling constant for the selection kernel with (alpha,sigma)=(2.42,5.06).
C_ICV(2.42,5.06)
</code></pre>

<hr>
<h2 id='h_ICV'>The ICV bandwidth.</h2><span id='topic+h_ICV'></span>

<h3>Description</h3>

<p>Calculation of the ICV bandwidth for the Gaussian density estimator corresponding to expression (12) of Savchuk, Hart, and Sheather (2010).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>h_ICV(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="h_ICV_+3A_x">x</code></td>
<td>
<p>numerical vector of data.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Computing the ICV bandwidth for a univariate numerical data set of size <code class="reqn">n&lt;12,058</code>. The ICV bandwidth is consistent for the MISE optimal bandwidth (see Wand and Jones (1995)). The Gaussian kernel is used for computing the ultimate density estimate. The following values of the paramaters of the selection kernel <code><a href="#topic+L_ICV">L_ICV</a></code> are used: <code class="reqn">(\alpha,\sigma)=(2.42, 5.06)</code>. The ICV bandwidth does not exceed the oversmoothed bandwidth of Terrell (1990). See expression (12) of Savchuk et al. (2010).
</p>


<h3>Value</h3>

<p>The ICV bandwidth.
</p>


<h3>References</h3>


<ul>
<li><p> Savchuk, O.Y., Hart, J.D., Sheather, S.J. (2010). Indirect cross-validation for density estimation. <em>Journal of the American Statistical Association</em>, 105(489), 415-423.
</p>
</li>
<li><p> Wand, M.P. and Jones, M.C. (1995). Kernel Smoothing. Chapman and Hall, London.
</p>
</li>
<li><p> Terrel, G. (1990). The maximum smoothing principle in density estimation. <em>Journal of the American Statistical Association</em>, 85, 470-477.
</p>
</li></ul>



<h3>See Also</h3>

<p><code><a href="#topic+ICV">ICV</a></code>, <code><a href="#topic+C_ICV">C_ICV</a></code>, <code><a href="#topic+L_ICV">L_ICV</a></code>, <code><a href="#topic+MISE_mixnorm">MISE_mixnorm</a></code>, <code><a href="#topic+KDE_ICV">KDE_ICV</a></code>, <code><a href="#topic+LocICV">LocICV</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># ICV bandwidth for a random sample of size n=100 from a N(0,1) density.
h_ICV(rnorm(100))
</code></pre>

<hr>
<h2 id='h_isemixnorm'>The ISE-optimal bandwidth in the case when the true density is the specified mixture of normal distributions.</h2><span id='topic+h_isemixnorm'></span>

<h3>Description</h3>

<p>Computing the ISE-optimal bandwidth in the case when the true density is the specified mixture of normal distributions and the Gaussian kernel is used to compute the ultimate density estimate.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>h_isemixnorm(x, w, mu, sdev)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="h_isemixnorm_+3A_x">x</code></td>
<td>
<p>numerical vector of data,</p>
</td></tr>
<tr><td><code id="h_isemixnorm_+3A_w">w</code></td>
<td>
<p>vector of weighs (positive numbers between 0 and 1 that add up to one),</p>
</td></tr>
<tr><td><code id="h_isemixnorm_+3A_mu">mu</code></td>
<td>
<p>vector of means,</p>
</td></tr>
<tr><td><code id="h_isemixnorm_+3A_sdev">sdev</code></td>
<td>
<p>vector of standard deviations.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Computing the ISE-optimal bandwidth (i.e. the minimizer of the ISE function) in the case when the true density is the mixture of normal distributions defined by the vector of weights <code class="reqn">w</code>, the vector of means <code class="reqn">\mu</code>, and the vector of standard deviations <code class="reqn">\sigma</code>. See expression (2.3) of Marron and Wand (1992). It is assumed that the normals are defined as parsimonious as possible. The normal distributions in the mixture should be ordered such that the means in <code class="reqn">\mu</code> are sorted in a nondecreasing order. The Gaussian kernel is used for computing the ultimate density estimate.
</p>


<h3>Value</h3>

<p>The ISE-optimal bandwidth.
</p>


<h3>References</h3>

<p>Marron, J.S., Wand, M.P. (1992). Exact Mean Integrated Squared Error. <em>The Annals of Statistics</em>, 20(2), 712-736.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+mixnorm">mixnorm</a></code>, <code><a href="#topic+ISE_mixnorm">ISE_mixnorm</a></code>, <code><a href="#topic+MISE_mixnorm">MISE_mixnorm</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># ISE optimal bandwidth for a random sample of size n=100 generated from a normal mixture defined by
# w=c(1/5,1/5,3/5), mu=(0,1/2,13/12), sdev=c(1,2/3,5/9).
# This corresponds to the skewed unimodal density of Marron and Wand (1992).
h_isemixnorm(rnorm(100),c(1/5,1/5,3/5),c(0,1/2,13/12),c(1,2/3,5/9))
</code></pre>

<hr>
<h2 id='ICV'>The ICV function.</h2><span id='topic+ICV'></span>

<h3>Description</h3>

<p>Computing <code class="reqn">ICV(h)</code>, the value of the ICV function, at a given bandwidth <code class="reqn">h</code> (vector) for a data set <code class="reqn">x</code> of size <code class="reqn">n&lt;12,058</code>. See Savchuk, Hart, and Sheather (2010).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ICV(h, x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ICV_+3A_h">h</code></td>
<td>
<p>numerical vector of bandwidth values (in the final scale),</p>
</td></tr>
<tr><td><code id="ICV_+3A_x">x</code></td>
<td>
<p>numerical vecror of data.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Computation of  <code class="reqn">ICV(h)</code> for given <code class="reqn">h</code> (bandwidth vector) and <code class="reqn">x</code> (data vector). The sample size <code class="reqn">n&lt;12,058</code>. The Gaussian kernel is to be used for computing the ultimate kernel density estimate. The parameters of the selection kernel are <code class="reqn">(\alpha,\sigma)=(2.42, 5.06)</code>. The ICV bandwidth <code><a href="#topic+h_ICV">h_ICV</a></code> is the minimizer of the ICV function.
</p>


<h3>Value</h3>

<p>The value of <code class="reqn">ICV(h)</code> for given <code class="reqn">h</code> and data (<code class="reqn">x</code>).
</p>


<h3>References</h3>

<p>Savchuk, O.Y., Hart, J.D., Sheather, S.J. (2010). Indirect cross-validation for density estimation. <em>Journal of the American Statistical Association</em>, 105(489), 415-423.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+h_ICV">h_ICV</a></code>, <code><a href="#topic+C_ICV">C_ICV</a></code>, <code><a href="#topic+L_ICV">L_ICV</a></code>, <code><a href="#topic+MISE_mixnorm">MISE_mixnorm</a></code>, <code><a href="#topic+KDE_ICV">KDE_ICV</a></code>, <code><a href="#topic+LocICV">LocICV</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#Example 1. Computation of ICV(h) at h=0.4 for a random sample of size n=100 from a N(0,1)
#distribution.
ICV(0.4,rnorm(100))

## Not run: 
#Example 2. (Calculations for a random sample of size n=250 from the separated bimodal density).
w=c(1/2,1/2)
mu=c(-3/2,3/2)
sdev=c(1/2,1/2)
# Generating a sample of size n=250 from the separated bimodal density of Marron and Wand (1992).
dat=mixnorm(250,w,mu,sdev)
h_OS=(243/(35*length(dat)*2*sqrt(pi)))^0.2*sd(dat)    # Computing the oversmoothed bandwidth.
h_opt=round(h_ICV(dat),digits=4)
harg=seq(0.1,3,len=100)
dev.new()
plot(harg,ICV(harg,x=dat),'l',lwd=3,xlab="h",ylab="ICV",cex.lab=1.7,cex.axis=1.7)
title(main="ICV(h)",cex.main=1.7)
lines(c(h_OS,h_OS),c(-0.5,0.5),lty="dashed",lwd=3)
legend(0.75,-0.05,legend="Vertical line shows the oversmothed bandwidth")
legend(1.35,0.1,legend=paste("h_ICV=",h_opt),cex=2,bty="n")
# Notice that the scale of the ICV function is such that its minimizer is the ICV bandwidth h_ICV.
# Thus, no additional rescaling of the ICV function's minimizer is needed to obtain the ICV
# bandwidth.
dev.new()
dens=density(dat,bw=h_opt)
plot(dens,main="",cex.lab=1.7,cex.axis=1.7,lwd=3,xlab=paste("n=250,","h=h_ICV=",h_opt),
ylim=c(0,0.45))
title(main="KDE based on h_ICV",cex.main=1.7)
arg=seq(-3.5,3.5,len=1000)
lines(arg,w[1]*dnorm(arg,mu[1],sd=sdev[1])+w[2]*dnorm(arg,mu[2],sd=sdev[2]),lwd=3,lty="dashed")
legend(-1,0.45,lty=c("solid","dashed"),lwd=c(3,3),legend=c("ICV estimate","True density"),bty="n")

## End(Not run)
</code></pre>

<hr>
<h2 id='ISE_mixnorm'>The ISE function in the case when the underlying density is the specified mixture of normal distributions.</h2><span id='topic+ISE_mixnorm'></span>

<h3>Description</h3>

<p>Computing <code class="reqn">ISE(h)</code> for given <code class="reqn">h</code> in the case when the underlying density is the specified mixture of normal distributions and the Gaussian kernel is used to compute the ultimate density estimate.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ISE_mixnorm(h, x, w, mu, sdev)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ISE_mixnorm_+3A_h">h</code></td>
<td>
<p>numerical vector of bandwidth values,</p>
</td></tr>
<tr><td><code id="ISE_mixnorm_+3A_x">x</code></td>
<td>
<p>numerical vector of data,</p>
</td></tr>
<tr><td><code id="ISE_mixnorm_+3A_w">w</code></td>
<td>
<p>vector of weighs (positive numbers between 0 and 1 that add up to one),</p>
</td></tr>
<tr><td><code id="ISE_mixnorm_+3A_mu">mu</code></td>
<td>
<p>vector of means,</p>
</td></tr>
<tr><td><code id="ISE_mixnorm_+3A_sdev">sdev</code></td>
<td>
<p>vector of standard deviations.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Computing <code class="reqn">ISE(h)</code> in the case when the true density is the mixture of normal distributions defined by the vector of weights <code class="reqn">w</code>, the vector of means <code class="reqn">\mu</code>, and the vector of standard deviations <code class="reqn">\sigma</code>. See expression (2.3) of Marron and Wand (1992). It is assumed that the normals are defined as parsimonious as possible. The normal distributions in the mixture should be ordered such that the means in <code class="reqn">\mu</code> are arranged in a nondecreasing order. The Gaussian kernel is to be used for computing the ultimate density estimate.
</p>


<h3>Value</h3>

<p>The vector of ISE values corresponding to the specifies values of <code class="reqn">h</code>.
</p>


<h3>References</h3>

<p>Marron, J.S., Wand, M.P. (1992). Exact Mean Integrated Squared Error. <em>The Annals of Statistics</em>, 20(2), 712-736.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+mixnorm">mixnorm</a></code>, <code><a href="#topic+h_isemixnorm">h_isemixnorm</a></code>, <code><a href="#topic+MISE_mixnorm">MISE_mixnorm</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
harg=seq(0.01,1,len=100)
w=c(3/4,1/4)
mu=c(0,3/2)
sdev=c(1,1/3)
# The vectors w, mu, and sdev define the skewed bimodal density of Marron and Wand (1992).
dat=mixnorm(300,w,mu,sdev)
h_ISE=round(h_isemixnorm(dat,w,mu,sdev),digits=4)
ISEarray=ISE_mixnorm(harg,dat,w,mu,sdev)
dev.new()
plot(harg,ISEarray,'l',lwd=3,xlab="h, n=300",ylab="ISE",cex.lab=1.7,cex.axis=1.7,main="")
title(main="ISE(h)",cex.main=1.7)
legend(0.2,0.08,legend=paste("h_ISE=",h_ISE),cex=2)

## End(Not run)
</code></pre>

<hr>
<h2 id='KDE_ICV'>Computing the kernel density estimate based on the ICV bandwidth.</h2><span id='topic+KDE_ICV'></span>

<h3>Description</h3>

<p>Computing the Gaussian density estimate based on <code><a href="#topic+h_ICV">h_ICV</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>KDE_ICV(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="KDE_ICV_+3A_x">x</code></td>
<td>
<p>numerical vector of data.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Computing the Gaussian density estimate based on <code><a href="#topic+h_ICV">h_ICV</a></code>. The ICV selection kernel <code><a href="#topic+L_ICV">L_ICV</a></code> is based on <code class="reqn">(\alpha,\sigma)=(2.42,5.06)</code>.
</p>


<h3>Value</h3>

<p>A list containing the following components:
</p>

<dl>
<dt><code class="reqn">arg</code></dt><dd><p>vector of sorted values of the argument at which the density estmate is computed,</p>
</dd>
<dt><code class="reqn">y</code></dt><dd><p>vector of density estimates at the corresponding values of the argument.</p>
</dd>
</dl>

<p>The function also produces a graph of the resulting ICV kernel density estimate.
</p>


<h3>References</h3>


<ul>
<li><p> Savchuk, O.Y., Hart, J.D., Sheather, S.J. (2010). Indirect cross-validation for density estimation. <em>Journal of the American Statistical Association</em>, 105(489), 415-423.
</p>
</li>
<li><p> Savchuk, O.Y., Hart, J.D., Sheather, S.J. (2009). An empirical study of indirect cross-validation. <em>Nonparametric Statistics and Mixture Models: A Festschrift in Honor of Thomas P. Hettmansperger.</em> World Scientific Publishing, 288-308.
</p>
</li></ul>



<h3>See Also</h3>

<p><code><a href="#topic+ICV">ICV</a></code>, <code><a href="#topic+h_ICV">h_ICV</a></code>, <code><a href="#topic+L_ICV">L_ICV</a></code>, <code><a href="#topic+LocICV">LocICV</a></code>, <code><a href="#topic+C_ICV">C_ICV</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#Example (Density estimate for eruption duration of the Old Faithful Geyser).
data=faithful[[1]]
dens=KDE_ICV(data)
</code></pre>

<hr>
<h2 id='L_ICV'>The ICV selection kernel.</h2><span id='topic+L_ICV'></span>

<h3>Description</h3>

<p>The ICV selection kernel <code class="reqn">L</code> defined by expression (4) of Savchuk, Hart, and Sheather (2010).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>L_ICV(u, alpha, sigma)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="L_ICV_+3A_u">u</code></td>
<td>
<p>numerical argument of the selection kernel,</p>
</td></tr>
<tr><td><code id="L_ICV_+3A_alpha">alpha</code></td>
<td>
<p>first parameter of the selection kernel,</p>
</td></tr>
<tr><td><code id="L_ICV_+3A_sigma">sigma</code></td>
<td>
<p>second parameter of the selection kernel.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The ICV selection kernel <code class="reqn">L(u;\alpha,\sigma)=(1+\alpha)\phi(u)-\alpha\phi(u/\sigma)/\sigma</code>, where <code class="reqn">\phi</code> denotes the Gaussian kernel.
</p>


<h3>Value</h3>

<p>The value of <code class="reqn">L(u;\alpha,\sigma)</code>.
</p>


<h3>References</h3>

<p>Savchuk, O.Y., Hart, J.D., Sheather, S.J. (2010). Indirect cross-validation for density estimation. <em>Journal of the American Statistical Association</em>, 105(489), 415-423.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+ICV">ICV</a></code>, <code><a href="#topic+h_ICV">h_ICV</a></code>, <code><a href="#topic+C_ICV">C_ICV</a></code>, <code><a href="#topic+MISE_mixnorm">MISE_mixnorm</a></code>, <code><a href="#topic+KDE_ICV">KDE_ICV</a></code>, <code><a href="#topic+LocICV">LocICV</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# Graph of the ICV selection kernel with (alpha,sigma)=(2.42,5.06).
u=seq(-10,10,len=1000)
kern=L_ICV(u,2.42,5.06)
dev.new()
plot(u,kern,'l',lwd=2,ylim=c(-0.2,1.2),ylab="kernel",cex.lab=1.7,cex.axis=1.7,main="")
lines(u,dnorm(u),lwd=3,lty="dashed")
title(main="Selection kernel with (alpha,sigma)=(2.42,5.06)",cex.main=1.6)
legend(-11, 1.2, legend=c("ICV kernel","Gaussian kernel"),lwd=c(3,3),lty=c(1,2),bty="n",cex=1.3)

## End(Not run)
</code></pre>

<hr>
<h2 id='LocICV'>The local ICV function.</h2><span id='topic+LocICV'></span>

<h3>Description</h3>

<p>Computing the local ICV function at the given estimation point, as explained in Section 6 of Savchuk, Hart, and Sheather (2010).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>LocICV(h, xest, x, eta, alpha, sigma)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="LocICV_+3A_h">h</code></td>
<td>
<p>bandwidth (scalar) in the final scale,</p>
</td></tr>
<tr><td><code id="LocICV_+3A_xest">xest</code></td>
<td>
<p>estimation point (scalar),</p>
</td></tr>
<tr><td><code id="LocICV_+3A_x">x</code></td>
<td>
<p>numerical vector of data,</p>
</td></tr>
<tr><td><code id="LocICV_+3A_eta">eta</code></td>
<td>
<p>smoothing parameter,</p>
</td></tr>
<tr><td><code id="LocICV_+3A_alpha">alpha</code></td>
<td>
<p>first parameter of the selection kernel,</p>
</td></tr>
<tr><td><code id="LocICV_+3A_sigma">sigma</code></td>
<td>
<p>second parameter of the selection kernel.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Calculation of the local ICV function at the given estimation point xest. The Gaussian kernel is used for local weighting. The ultimate kernel density estimate is computed based on the Gaussian kernel. The parameters of the selection kernel <code><a href="#topic+L_ICV">L_ICV</a></code> are <code class="reqn">\alpha</code> and <code class="reqn">\sigma</code>. The minimizer of the local ICV function is to be used in computing the ultimate density estimate without additional rescaling. Parameter <code class="reqn">\eta</code> is a smoothing parameter that determines the degree to which the cross-validation is local. A suggested value of <code class="reqn">\eta</code> is <code class="reqn">\eta=R/20</code>, where <code class="reqn">R</code> is the range of data.
</p>


<h3>Value</h3>

<p>The value of the local ICV function at the fixed estimation point and for the specified value of the bandwidth (see Section 6 of Savchuk, Hart, and Sheather (2010)).
</p>


<h3>References</h3>


<ul>
<li><p> Savchuk, O.Y., Hart, J.D., Sheather, S.J. (2010). Indirect cross-validation for density estimation. <em>Journal of the American Statistical Association</em>, 105(489), 415-423.
</p>
</li>
<li><p> Savchuk, O.Y., Hart, J.D., Sheather, S.J. (2009). An empirical study of indirect cross-validation. <em>Nonparametric Statistics and Mixture Models: A Festschrift in Honor of Thomas P. Hettmansperger.</em> World Scientific Publishing, 288-308.
</p>
</li>
<li><p> Hall, P., and Schukany, W. R. (1989). A local cross-validation algorithm. <em>Statistics and Probability Letters</em>, 8, 109-117.
</p>
</li></ul>



<h3>See Also</h3>

<p><code><a href="#topic+h_ICV">h_ICV</a></code>, <code><a href="#topic+C_ICV">C_ICV</a></code>, <code><a href="#topic+L_ICV">L_ICV</a></code>, <code><a href="#topic+MISE_mixnorm">MISE_mixnorm</a></code>, <code><a href="#topic+ICV">ICV</a></code>, <code><a href="#topic+KDE_ICV">KDE_ICV</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# Local ICV function for a random sample of size n=150 from the kurtotic density of Marron and
# Wand (1992).
dat=mixnorm(150,c(2/3,1/3),c(0,0),c(1,1/10))
a=2.42   # alpha
s=5.06   # sigma
harg=seq(0.025,1,len=100)
Xest=0.1    # estimation point
LocICV_Xest=numeric(length(harg))
for(i in 1:length(harg))
  LocICV_Xest[i]=LocICV(harg[i],Xest,dat,0.2,a,s)
h_Xest=optimize(LocICV,c(0.001,0.2),tol=0.001,xest=Xest,eta=0.2,x=dat,alpha=a,sigma=s)$minimum
h_Xest=round(h_Xest,digits=4)
dev.new()
plot(harg,LocICV_Xest,'l',lwd=3,xlab="harg",ylab="LocICV_Xest",main="",cex.lab=1.7, cex.axis=1.7)
title(main=paste("Local ICV function at x=",Xest),cex.main=1.7)
legend(0.1,max(LocICV_Xest),legend=paste("h_x=",h_Xest),cex=1.7)
legend(0.2,max(LocICV_Xest)-0.15,legend="Note: first local minimizer is used", cex=1.5,bty="n")

## End(Not run)
</code></pre>

<hr>
<h2 id='MISE_mixnorm'>The MISE function in the case when the true density is the specified mixture of normal distributions and the selection kernel  <code><a href="#topic+L_ICV">L_ICV</a></code> is used in the cross-validation stage.</h2><span id='topic+MISE_mixnorm'></span>

<h3>Description</h3>

<p>Computing <code class="reqn">MISE(h)</code> for given <code class="reqn">h</code> in the case when the true density is the specified mixture of normal distributions and the kernel is <code><a href="#topic+L_ICV">L_ICV</a></code> defined by expression (4) of Savchuk, Hart, and Sheather (2010).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>MISE_mixnorm(h, n, alpha, sigma, w, mu, sdev)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="MISE_mixnorm_+3A_h">h</code></td>
<td>
<p>numerical vector of bandwidth values,</p>
</td></tr>
<tr><td><code id="MISE_mixnorm_+3A_n">n</code></td>
<td>
<p>sample size,</p>
</td></tr>
<tr><td><code id="MISE_mixnorm_+3A_alpha">alpha</code></td>
<td>
<p>first parameter of the selection kernel,</p>
</td></tr>
<tr><td><code id="MISE_mixnorm_+3A_sigma">sigma</code></td>
<td>
<p>second parameter of the selection kernel,</p>
</td></tr>
<tr><td><code id="MISE_mixnorm_+3A_w">w</code></td>
<td>
<p>vector of weighs (positive numbers between 0 and 1 that add up to one),</p>
</td></tr>
<tr><td><code id="MISE_mixnorm_+3A_mu">mu</code></td>
<td>
<p>vector of means,</p>
</td></tr>
<tr><td><code id="MISE_mixnorm_+3A_sdev">sdev</code></td>
<td>
<p>vector of standard deviations.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Calculation of <code class="reqn">MISE(h)</code> in the case when the true density is the mixture of normal distributions defined by the vector of weights <code class="reqn">w</code>, the vector of means <code class="reqn">\mu</code>, and the vector of standard deviations <code class="reqn">\sigma</code>. See expression (2.3) of Marron and Wand (1992). It is assumed that the normals are defined as parsimonious as possible. The normal distributions in the mixture should be ordered such that the means in <code class="reqn">\mu</code> are arranged in a nondecreasing order. The MISE function is based on the selection kernel <code><a href="#topic+L_ICV">L_ICV</a></code> defined by expression (4) of Savchuk, Hart, and Sheather (2010). Notice that the Gaussian kernel <code class="reqn">\phi</code> is the special case of  <code><a href="#topic+L_ICV">L_ICV</a></code> given that <strong>(Case 1)</strong> <code class="reqn">\alpha=0</code>, <code class="reqn">\sigma&gt;0</code> or <strong>(Case 2)</strong> <code class="reqn">\sigma=1</code>, <code class="reqn">-\infty&lt;\alpha&lt;\infty</code>.
</p>


<h3>Value</h3>

<p>The vector of MISE values corresponding to the specified values of <code class="reqn">h</code>.
</p>


<h3>References</h3>


<ul>
<li><p> Savchuk, O.Y., Hart, J.D., Sheather, S.J. (2010). Indirect cross-validation for density estimation. <em>Journal of the American Statistical Association</em>, 105(489), 415-423.
</p>
</li>
<li><p>  Marron, J.S., Wand, M.P. (1992). Exact Mean Integrated Squared Error. <em>The Annals of Statistics</em>, 20(2), 712-736.
</p>
</li></ul>



<h3>See Also</h3>

<p><code><a href="#topic+mixnorm">mixnorm</a></code>, <code><a href="#topic+ISE_mixnorm">ISE_mixnorm</a></code>, <code><a href="#topic+h_isemixnorm">h_isemixnorm</a></code>, <code><a href="#topic+L_ICV">L_ICV</a></code>, <code><a href="#topic+ICV">ICV</a></code>, <code><a href="#topic+h_ICV">h_ICV</a></code>,  <code><a href="#topic+C_ICV">C_ICV</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# Example 1. MISE for the separated bimodal density of Marron and Wand (1992).
# in the case (alpha,sigma)=(2.42,5.06), n=100.
harray=seq(0.05,1,len=1000)
w=c(1/2,1/2)
m=c(-3/2,3/2)
s=c(1/2,1/2)
MISEarray=MISE_mixnorm(harray,100,2.42,5.06,w,m,s)
hopt=round(optimize(MISE_mixnorm,c(0.01,1),n=100,alpha=2.42,sigma=5.06,w=w,mu=m,sdev=s)$minimum,
digits=4)
dev.new()
plot(harray,MISEarray,'l',lwd=3,xlab="h",ylab="MISE",cex.lab=1.7,cex.axis=1.7,main="")
title(main="MISE(h) for the separated bimodal density",cex.main=1.5)
legend(0.45,0.45,legend=c(paste("h_MISE=",hopt),"n=100"),bty="n",cex=1.7)

# Example 2. MISE for the N(0,1) density in the case of the Gaussian kernel and n=500.
harray=seq(0.03,1,len=1000)
MISEarray=MISE_mixnorm(harray,500,1,1,1,0,1)
hopt=round(optimize(MISE_mixnorm,c(0.01,1),n=500,alpha=1,sigma=1,w=1,mu=0,sdev=1)$minimum,digits=4)
dev.new()
plot(harray,MISEarray,'l',lwd=3,xlab="h",ylab="MISE",cex.lab=1.7,cex.axis=1.7,main="")
title(main="MISE(h) for the standard normal density",cex.main=1.7)
legend(0.2,0.02,legend=c(paste("h_MISE=",hopt),"n=500"),bty="n",cex=1.7)

## End(Not run)
</code></pre>

<hr>
<h2 id='mixnorm'>Generating a random sample from the specified mixture of normal distributions.</h2><span id='topic+mixnorm'></span>

<h3>Description</h3>

<p>Generating a random sample of size <code class="reqn">n</code> from the normal mixture defined by  expression (2.3) of Marron and Wand (1992).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mixnorm(n, w, mu, sdev)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="mixnorm_+3A_n">n</code></td>
<td>
<p>desired sample size,</p>
</td></tr>
<tr><td><code id="mixnorm_+3A_w">w</code></td>
<td>
<p>vector of weighs (positive numbers between 0 and 1 that add up to one),</p>
</td></tr>
<tr><td><code id="mixnorm_+3A_mu">mu</code></td>
<td>
<p>vector of means,</p>
</td></tr>
<tr><td><code id="mixnorm_+3A_sdev">sdev</code></td>
<td>
<p>vector of standard deviations.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Producing a random sample of size <code class="reqn">n</code> from the normal mixture defined by the vector of weights <code class="reqn">w</code>, the vector of means <code class="reqn">\mu</code>, and the vector of standard deviations <code class="reqn">\sigma</code>. See Marron and Wand (1992). It is assumed that the normals are defined as parsimonious as possible. The normal distributions in the mixture should be ordered such that the means in <code class="reqn">\mu</code> are arranged in a nondecreasing order.
</p>


<h3>Value</h3>

<p>A random sample of size <code class="reqn">n</code> from the specified mixture of normals.
</p>


<h3>References</h3>

<p>Marron, J.S., Wand, M.P. (1992). Exact Mean Integrated Squared Error. <em>The Annals of Statistics</em>, 20(2), 712-736.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+ISE_mixnorm">ISE_mixnorm</a></code>, <code><a href="#topic+h_isemixnorm">h_isemixnorm</a></code>, <code><a href="#topic+MISE_mixnorm">MISE_mixnorm</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# Generating a sample of size n=300 from the separated bimodal density of Marron and Wand (1992).
w=c(0.5,0.5)
mu=c(-3/2,3/2)
sdev=c(1/2,1/2)
dat=mixnorm(300,w,mu,sdev) # generated data vector
arg=seq(-4,4,len=1000)  # argument
f=w[1]*dnorm(arg,mu[1],sd=sdev[1])+w[2]*dnorm(arg,mu[2],sd=sdev[2])     # true density
dev.new()
hist(dat,freq=F,ylab="",main="",cex.lab=1.7,cex.axis=1.7,xlim=c(-4,4),lwd=2,ylim=c(0,0.45),
col='grey')
title(main="Separated bimodal density",cex.main=1.7)
legend(-5,0.4,legend="n=300",cex=2,bty="n")
lines(arg,f,lwd=3,'l')

## End(Not run)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
