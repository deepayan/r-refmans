<!DOCTYPE html><html><head><title>Help for package rSPDE</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {rSPDE}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#rSPDE'><p>Rational approximations of fractional SPDEs.</p></a></li>
<li><a href='#augment.rspde_lme'><p>Augment data with information from a <code>rspde_lme</code> object</p></a></li>
<li><a href='#bru_get_mapper.inla_rspde'><p>rSPDE inlabru mapper</p></a></li>
<li><a href='#construct.spde.matern.loglike'><p>Constructor of Matern loglikelihood functions for non-stationary models.</p></a></li>
<li><a href='#cross_validation'><p>Perform cross-validation on a list of fitted models.</p></a></li>
<li><a href='#folded.matern.covariance.1d'><p>The 1d folded Matern covariance function</p></a></li>
<li><a href='#folded.matern.covariance.2d'><p>The 2d folded Matern covariance function</p></a></li>
<li><a href='#fractional.operators'><p>Rational approximations of fractional operators</p></a></li>
<li><a href='#get.initial.values.rSPDE'><p>Initial values for log-likelihood optimization in rSPDE models</p>
with a latent stationary Gaussian Matern model</a></li>
<li><a href='#gg_df'><p>Data frame for result objects from R-INLA fitted models to be used in ggplot2</p></a></li>
<li><a href='#gg_df.rspde_result'><p>Data frame for rspde_result objects to be used in ggplot2</p></a></li>
<li><a href='#glance.rspde_lme'><p>Glance at an <code>rspde_lme</code> object</p></a></li>
<li><a href='#graph_data_rspde'><p>Data extraction from metric graphs for 'rSPDE' models</p></a></li>
<li><a href='#intrinsic.matern.operators'><p>Covariance-based approximations of intrinsic fields</p></a></li>
<li><a href='#matern.covariance'><p>The Matern covariance function</p></a></li>
<li><a href='#matern.operators'><p>Rational approximations of stationary Gaussian Matern random fields</p></a></li>
<li><a href='#operator.operations'><p>Operations with the Pr and Pl operators</p></a></li>
<li><a href='#precision'><p>Get the precision matrix of CBrSPDEobj objects</p></a></li>
<li><a href='#precision.inla_rspde'><p>Get the precision matrix of <code>inla_rspde</code> objects</p></a></li>
<li><a href='#predict.CBrSPDEobj'><p>Prediction of a fractional SPDE using the covariance-based</p>
rational SPDE approximation</a></li>
<li><a href='#predict.rspde_lme'><p>Prediction of a mixed effects regression model on a metric graph.</p></a></li>
<li><a href='#predict.rSPDEobj'><p>Prediction of a fractional SPDE using a rational SPDE approximation</p></a></li>
<li><a href='#rational.order'><p>Get the order of rational approximation.</p></a></li>
<li><a href='#rational.order&lt;-'><p>Changing the order of the rational approximation</p></a></li>
<li><a href='#rational.type'><p>Get type of rational approximation.</p></a></li>
<li><a href='#rational.type&lt;-'><p>Changing the type of the rational approximation</p></a></li>
<li><a href='#require.nowarnings'><p>Warnings free loading of add-on packages</p></a></li>
<li><a href='#rspde_lme'><p>rSPDE linear mixed effects models</p></a></li>
<li><a href='#rSPDE.A1d'><p>Observation matrix for finite element discretization on R</p></a></li>
<li><a href='#rSPDE.construct.matern.loglike'><p>Constructor of Matern loglikelihood functions.</p></a></li>
<li><a href='#rSPDE.fem1d'><p>Finite element calculations for problems on R</p></a></li>
<li><a href='#rSPDE.fem2d'><p>Finite element calculations for problems in 2D</p></a></li>
<li><a href='#rSPDE.loglike'><p>Object-based log-likelihood function for latent Gaussian</p>
fractional SPDE model</a></li>
<li><a href='#rspde.make.A'><p>Observation/prediction matrices for rSPDE models.</p></a></li>
<li><a href='#rspde.make.index'><p>rSPDE model index vector generation</p></a></li>
<li><a href='#rspde.matern'><p>Matern rSPDE model object for INLA</p></a></li>
<li><a href='#rSPDE.matern.loglike'><p>Object-based log-likelihood function for latent Gaussian fractional</p>
SPDE model using the rational approximations</a></li>
<li><a href='#rspde.matern.precision'><p>Precision matrix of the covariance-based rational approximation of</p>
stationary Gaussian Matern random fields</a></li>
<li><a href='#rspde.matern.precision.integer'><p>Precision matrix of stationary Gaussian Matern</p>
random fields with integer covariance exponent</a></li>
<li><a href='#rspde.matern.precision.integer.opt'><p>Optimized precision matrix of stationary Gaussian Matern</p>
random fields with integer covariance exponent</a></li>
<li><a href='#rspde.matern.precision.opt'><p>Optimized precision matrix of the covariance-based rational</p>
approximation</a></li>
<li><a href='#rspde.mesh.project'><p>Calculate a lattice projection to/from an <code>inla.mesh</code> for</p>
rSPDE objects</a></li>
<li><a href='#rspde.metric_graph'><p>Matern rSPDE model object for metric graphs in INLA</p></a></li>
<li><a href='#rspde.result'><p>rSPDE result extraction from INLA estimation results</p></a></li>
<li><a href='#simulate.CBrSPDEobj'><p>Simulation of a fractional SPDE using the</p>
covariance-based rational SPDE approximation</a></li>
<li><a href='#simulate.rSPDEobj'><p>Simulation of a fractional SPDE using a rational SPDE approximation</p></a></li>
<li><a href='#spde.make.A'><p>Observation/prediction matrices for rSPDE models with integer smoothness.</p></a></li>
<li><a href='#spde.matern.loglike'><p>Parameter-based log-likelihood for a latent Gaussian Matern SPDE model</p>
using a rational SPDE approximation</a></li>
<li><a href='#spde.matern.operators'><p>Rational approximations of non-stationary Gaussian SPDE Matern random fields</p></a></li>
<li><a href='#summary.CBrSPDEobj'><p>Summarise CBrSPDE objects</p></a></li>
<li><a href='#summary.rspde_lme'><p>Summary Method for <code>rspde_lme</code> Objects.</p></a></li>
<li><a href='#summary.rspde_result'><p>Summary for posteriors of field parameters for an <code>inla_rspde</code></p>
model from a <code>rspde_result</code> object</a></li>
<li><a href='#summary.rSPDEobj'><p>Summarise rSPDE objects</p></a></li>
<li><a href='#update.CBrSPDEobj'><p>Update parameters of CBrSPDEobj objects</p></a></li>
<li><a href='#update.rSPDEobj'><p>Update parameters of rSPDEobj objects</p></a></li>
<li><a href='#variogram.intrinsic.spde'><p>Variogram of intrinsic SPDE model</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Rational Approximations of Fractional Stochastic Partial
Differential Equations</td>
</tr>
<tr>
<td>Version:</td>
<td>2.3.3</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>David Bolin &lt;davidbolin@gmail.com&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Functions that compute rational approximations of fractional elliptic stochastic partial differential equations. The package also contains functions for common statistical usage of these approximations. The main references for rSPDE are Bolin, Simas and Xiong (2023) &lt;<a href="https://doi.org/10.1080%2F10618600.2023.2231051">doi:10.1080/10618600.2023.2231051</a>&gt; for the covariance-based method and Bolin and Kirchner (2020) &lt;<a href="https://doi.org/10.1080%2F10618600.2019.1665537">doi:10.1080/10618600.2019.1665537</a>&gt; for the operator-based rational approximation. These can be generated by the citation function in R.</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.5.0), Matrix</td>
</tr>
<tr>
<td>Imports:</td>
<td>stats, methods, fmesher, lifecycle, broom</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL (&ge; 3)</a> | file LICENSE</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://davidbolin.github.io/rSPDE/">https://davidbolin.github.io/rSPDE/</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>Suggests:</td>
<td>knitr, rmarkdown, INLA (&ge; 22.12.14), testthat, ggplot2,
lattice, splancs, optimParallel, RSpectra, numDeriv, inlabru
(&ge; 2.7.0), sn, viridis, scoringRules, doParallel, foreach,
tidyr, dplyr</td>
</tr>
<tr>
<td>Additional_repositories:</td>
<td><a href="https://inla.r-inla-download.org/R/testing">https://inla.r-inla-download.org/R/testing</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/davidbolin/rSPDE/issues">https://github.com/davidbolin/rSPDE/issues</a></td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Author:</td>
<td>David Bolin [cre, aut],
  Alexandre Simas [aut],
  Finn Lindgren [ctb]</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-11-05 21:13:12 UTC; debusta</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-11-05 22:30:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='rSPDE'>Rational approximations of fractional SPDEs.</h2><span id='topic+rSPDE'></span><span id='topic+rSPDE-package'></span>

<h3>Description</h3>

<p><code>rSPDE</code> is used for approximating fractional elliptic SPDEs
</p>
<p style="text-align: center;"><code class="reqn">L^\beta (\tau u(s)) = W,</code>
</p>

<p>where <code class="reqn">L</code> is a differential operator and <code class="reqn">\beta&gt;0</code>
is a general fractional power.
</p>


<h3>Details</h3>

<p>The approximation is based on a rational approximation of the
fractional operator, and allows for computationally efficient
inference and simulation.
</p>
<p>The main functions for computing rational approximation objects are:
</p>

<dl>
<dt><code><a href="#topic+fractional.operators">fractional.operators()</a></code></dt><dd><p>works for general
rational operators</p>
</dd>
<dt><code><a href="#topic+matern.operators">matern.operators()</a></code></dt><dd><p> works for random fields with
stationary Matern covariance functions</p>
</dd>
<dt><code><a href="#topic+spde.matern.operators">spde.matern.operators()</a></code></dt><dd><p> works for random fields with
defined as solutions to a possibly non-stationary Matern-type SPDE model.</p>
</dd>
<dt><code><a href="#topic+rspde.matern">rspde.matern()</a></code></dt><dd><p>R-INLA implementation of the
covariance-based rational approximation for random fields with
stationary Matern covariance functions</p>
</dd>
</dl>

<p>Basic statistical operations such as likelihood evaluations (see
<code style="white-space: pre;">&#8288;[rSPDE.loglike], [rSPDE.matern.loglike]&#8288;</code>) and kriging
predictions (see <code style="white-space: pre;">&#8288;[predict.rSPDEobj], [predict.CBrSPDEobj]&#8288;</code>)
using the rational approximations are also implemented.
</p>
<p>For illustration purposes, the package contains a simple FEM implementation
for models on R. For spatial models,
the FEM implementation in the <code>R-INLA</code> package is recommended.
</p>
<p>For a more detailed introduction to the package, see the rSPDE Vignettes.
</p>

<hr>
<h2 id='augment.rspde_lme'>Augment data with information from a <code>rspde_lme</code> object</h2><span id='topic+augment.rspde_lme'></span><span id='topic+augment'></span>

<h3>Description</h3>

<p>Augment accepts a model object and a dataset and adds information about each observation in the dataset. It includes
predicted values in the <code>.fitted</code> column, residuals in the <code>.resid</code> column, and standard errors for the fitted values in a <code>.se.fit</code> column.
It also contains the New columns always begin with a . prefix to avoid overwriting columns in the original dataset.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'rspde_lme'
augment(
  x,
  newdata = NULL,
  loc = NULL,
  mesh = FALSE,
  which_repl = NULL,
  se_fit = FALSE,
  conf_int = FALSE,
  pred_int = FALSE,
  level = 0.95,
  n_samples = 100,
  edge_number = "edge_number",
  distance_on_edge = "distance_on_edge",
  normalized = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="augment.rspde_lme_+3A_x">x</code></td>
<td>
<p>A <code>rspde_lme</code> object.</p>
</td></tr>
<tr><td><code id="augment.rspde_lme_+3A_newdata">newdata</code></td>
<td>
<p>A <code>data.frame</code> or a <code>list</code> containing the covariates, the edge
number and the distance on edge for the locations to obtain the prediction. If <code>NULL</code>, the fitted values will be given for the original locations where the model was fitted.</p>
</td></tr>
<tr><td><code id="augment.rspde_lme_+3A_loc">loc</code></td>
<td>
<p>Prediction locations. Can either be a <code>data.frame</code>, a <code>matrix</code> or a character vector, that contains the names of the columns of the coordinates of the locations. For models using <code>metric_graph</code> objects, plase use <code>edge_number</code> and <code>distance_on_edge</code> instead.</p>
</td></tr>
<tr><td><code id="augment.rspde_lme_+3A_mesh">mesh</code></td>
<td>
<p>Obtain predictions for mesh nodes? The graph must have a mesh, and either <code>only_latent</code> is set to TRUE or the model does not have covariates.</p>
</td></tr>
<tr><td><code id="augment.rspde_lme_+3A_which_repl">which_repl</code></td>
<td>
<p>Which replicates to obtain the prediction. If <code>NULL</code> predictions
will be obtained for all replicates. Default is <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="augment.rspde_lme_+3A_se_fit">se_fit</code></td>
<td>
<p>Logical indicating whether or not a .se.fit column should be added to the augmented output. If TRUE, it only returns a non-NA value if type of prediction is 'link'.</p>
</td></tr>
<tr><td><code id="augment.rspde_lme_+3A_conf_int">conf_int</code></td>
<td>
<p>Logical indicating whether or not confidence intervals for the fitted variable should be built.</p>
</td></tr>
<tr><td><code id="augment.rspde_lme_+3A_pred_int">pred_int</code></td>
<td>
<p>Logical indicating whether or not prediction intervals for future observations should be built.</p>
</td></tr>
<tr><td><code id="augment.rspde_lme_+3A_level">level</code></td>
<td>
<p>Level of confidence and prediction intervals if they are constructed.</p>
</td></tr>
<tr><td><code id="augment.rspde_lme_+3A_n_samples">n_samples</code></td>
<td>
<p>Number of samples when computing prediction intervals.</p>
</td></tr>
<tr><td><code id="augment.rspde_lme_+3A_edge_number">edge_number</code></td>
<td>
<p>Name of the variable that contains the edge number, the default is <code>edge_number</code>.</p>
</td></tr>
<tr><td><code id="augment.rspde_lme_+3A_distance_on_edge">distance_on_edge</code></td>
<td>
<p>Name of the variable that contains the distance on edge, the default is <code>distance_on_edge</code>.</p>
</td></tr>
<tr><td><code id="augment.rspde_lme_+3A_normalized">normalized</code></td>
<td>
<p>Are the distances on edges normalized?</p>
</td></tr>
<tr><td><code id="augment.rspde_lme_+3A_...">...</code></td>
<td>
<p>Additional arguments.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code><a href="tidyr.html#topic+reexports">tidyr::tibble()</a></code> with columns:
</p>

<ul>
<li> <p><code>.fitted</code> Fitted or predicted value.
</p>
</li>
<li> <p><code>.fittedlwrconf</code> Lower bound of the confidence interval, if conf_int = TRUE
</p>
</li>
<li> <p><code>.fitteduprconf</code> Upper bound of the confidence interval, if conf_int = TRUE
</p>
</li>
<li> <p><code>.fittedlwrpred</code> Lower bound of the prediction interval, if pred_int = TRUE
</p>
</li>
<li> <p><code>.fitteduprpred</code> Upper bound of the prediction interval, if pred_int = TRUE
</p>
</li>
<li> <p><code>.fixed</code> Prediction of the fixed effects.
</p>
</li>
<li> <p><code>.random</code> Prediction of the random effects.
</p>
</li>
<li> <p><code>.resid</code> The ordinary residuals, that is, the difference between observed and fitted values.
</p>
</li>
<li> <p><code>.se_fit</code> Standard errors of fitted values, if se_fit = TRUE.
</p>
</li></ul>



<h3>See Also</h3>

<p><a href="#topic+glance.rspde_lme">glance.rspde_lme</a>
</p>

<hr>
<h2 id='bru_get_mapper.inla_rspde'>rSPDE inlabru mapper</h2><span id='topic+bru_get_mapper.inla_rspde'></span><span id='topic+ibm_n.bru_mapper_inla_rspde'></span><span id='topic+ibm_values.bru_mapper_inla_rspde'></span><span id='topic+ibm_jacobian.bru_mapper_inla_rspde'></span>

<h3>Description</h3>

<p>rSPDE inlabru mapper
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bru_get_mapper.inla_rspde(model, ...)

ibm_n.bru_mapper_inla_rspde(mapper, ...)

ibm_values.bru_mapper_inla_rspde(mapper, ...)

ibm_jacobian.bru_mapper_inla_rspde(mapper, input, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bru_get_mapper.inla_rspde_+3A_model">model</code></td>
<td>
<p>An <code>inla_rspde</code> for which to construct or extract a mapper</p>
</td></tr>
<tr><td><code id="bru_get_mapper.inla_rspde_+3A_...">...</code></td>
<td>
<p>Arguments passed on to other methods</p>
</td></tr>
<tr><td><code id="bru_get_mapper.inla_rspde_+3A_mapper">mapper</code></td>
<td>
<p>A <code>bru_mapper_inla_rspde</code> object</p>
</td></tr>
<tr><td><code id="bru_get_mapper.inla_rspde_+3A_input">input</code></td>
<td>
<p>The values for which to produce a mapping matrix</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'> #devel version
if (requireNamespace("INLA", quietly = TRUE) &amp;&amp; 
     requireNamespace("inlabru", quietly = TRUE)){
library(INLA)
library(inlabru)

set.seed(123)
m &lt;- 100
loc_2d_mesh &lt;- matrix(runif(m * 2), m, 2)
mesh_2d &lt;- inla.mesh.2d(
  loc = loc_2d_mesh,
  cutoff = 0.05,
  max.edge = c(0.1, 0.5)
)
sigma &lt;- 1
range &lt;- 0.2
nu &lt;- 0.8
kappa &lt;- sqrt(8 * nu) / range
op &lt;- matern.operators(
  mesh = mesh_2d, nu = nu,
  range = range, sigma = sigma, m = 2,
  parameterization = "matern"
)
u &lt;- simulate(op)
A &lt;- inla.spde.make.A(
  mesh = mesh_2d,
  loc = loc_2d_mesh
)
sigma.e &lt;- 0.1
y &lt;- A %*% u + rnorm(m) * sigma.e
y &lt;- as.vector(y)

data_df &lt;- data.frame(y=y, x1 = loc_2d_mesh[,1],
                       x2 = loc_2d_mesh[,2])
coordinates(data_df) &lt;- c("x1", "x2")
rspde_model &lt;- rspde.matern(
  mesh = mesh_2d,
  nu_upper_bound = 2
)

cmp &lt;- y ~ Intercept(1) + 
           field(coordinates, model = rspde_model)


rspde_fit &lt;- bru(cmp, data = data_df)
summary(rspde_fit)
}
#devel.tag

</code></pre>

<hr>
<h2 id='construct.spde.matern.loglike'>Constructor of Matern loglikelihood functions for non-stationary models.</h2><span id='topic+construct.spde.matern.loglike'></span>

<h3>Description</h3>

<p>This function evaluates the log-likelihood function for observations
of a non-stationary Gaussian process defined as the solution to the SPDE
</p>
<p style="text-align: center;"><code class="reqn">(\kappa(s) - \Delta)^\beta (\tau(s)u(s)) = W.</code>
</p>

<p>The observations are assumed to be generated as
<code class="reqn">Y_i = u(s_i) + \epsilon_i</code>, where
<code class="reqn">\epsilon_i</code> are
iid mean-zero Gaussian variables. The latent model is approximated using a
rational approximation of the fractional SPDE model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>construct.spde.matern.loglike(
  object,
  Y,
  A,
  sigma.e = NULL,
  mu = 0,
  user_nu = NULL,
  user_m = NULL,
  log_scale = TRUE,
  return_negative_likelihood = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="construct.spde.matern.loglike_+3A_object">object</code></td>
<td>
<p>The rational SPDE approximation,
computed using <code><a href="#topic+matern.operators">matern.operators()</a></code></p>
</td></tr>
<tr><td><code id="construct.spde.matern.loglike_+3A_y">Y</code></td>
<td>
<p>The observations, either a vector or a matrix where
the columns correspond to independent replicates of observations.</p>
</td></tr>
<tr><td><code id="construct.spde.matern.loglike_+3A_a">A</code></td>
<td>
<p>An observation matrix that links the measurement location to the
finite element basis.</p>
</td></tr>
<tr><td><code id="construct.spde.matern.loglike_+3A_sigma.e">sigma.e</code></td>
<td>
<p>IF non-null, the standard deviation of the measurement noise will be kept fixed in
the returned likelihood.</p>
</td></tr>
<tr><td><code id="construct.spde.matern.loglike_+3A_mu">mu</code></td>
<td>
<p>Expectation vector of the latent field (default = 0).</p>
</td></tr>
<tr><td><code id="construct.spde.matern.loglike_+3A_user_nu">user_nu</code></td>
<td>
<p>If non-null, the shape parameter will be kept fixed in the returned likelihood.</p>
</td></tr>
<tr><td><code id="construct.spde.matern.loglike_+3A_user_m">user_m</code></td>
<td>
<p>If non-null, update the order of the rational approximation,
which needs to be a positive integer.</p>
</td></tr>
<tr><td><code id="construct.spde.matern.loglike_+3A_log_scale">log_scale</code></td>
<td>
<p>Should the parameters be evaluated in log-scale?</p>
</td></tr>
<tr><td><code id="construct.spde.matern.loglike_+3A_return_negative_likelihood">return_negative_likelihood</code></td>
<td>
<p>Return minus the likelihood to turn the maximization into a minimization?</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The log-likelihood function. The parameters of the returned function
are given in the order theta, nu, sigma.e, whenever they are available.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+matern.operators">matern.operators()</a></code>, <code><a href="#topic+predict.CBrSPDEobj">predict.CBrSPDEobj()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># this example illustrates how the function can be used for maximum
# likelihood estimation
# Sample a Gaussian Matern process on R using a rational approximation
set.seed(123)
sigma.e &lt;- 0.1
n.rep &lt;- 10
n.obs &lt;- 100
n.x &lt;- 51
# create mass and stiffness matrices for a FEM discretization
x &lt;- seq(from = 0, to = 1, length.out = n.x)
fem &lt;- rSPDE.fem1d(x)
tau &lt;- rep(0.5, n.x)
nu &lt;- 0.8
alpha &lt;- nu + 0.5
kappa &lt;- rep(1, n.x)
# Matern parameterization
# compute rational approximation
 op &lt;- spde.matern.operators(
    loc_mesh = x,
   kappa = kappa, tau = tau, alpha = alpha,
   parameterization = "spde", d = 1
 )
# Sample the model
u &lt;- simulate(op, n.rep)
# Create some data
obs.loc &lt;- runif(n = n.obs, min = 0, max = 1)
A &lt;- rSPDE.A1d(x, obs.loc)
noise &lt;- rnorm(n.obs * n.rep)
dim(noise) &lt;- c(n.obs, n.rep)
Y &lt;- as.matrix(A %*% u + sigma.e * noise)
# define negative likelihood function for optimization using matern.loglike
mlik &lt;- construct.spde.matern.loglike(op, Y, A)
#' #The parameters can now be estimated by minimizing mlik with optim

# Choose some reasonable starting values depending on the size of the domain
theta0 &lt;- log(c( 1 / sqrt(var(c(Y))),sqrt(8), 0.9, 0.01))
# run estimation and display the results
theta &lt;- optim(theta0, mlik)
print(data.frame(
  tau = c(tau[1], exp(theta$par[1])), kappa = c(kappa[1], exp(theta$par[2])),
  nu = c(nu, exp(theta$par[3])), sigma.e = c(sigma.e, exp(theta$par[4])),
  row.names = c("Truth", "Estimates")
))


# SPDE parameterization
# compute rational approximation
 op &lt;- spde.matern.operators(
   kappa = kappa, tau = tau, alpha = alpha,
   loc_mesh = x, d = 1, 
   parameterization = "spde"
 )
# Sample the model
u &lt;- simulate(op, n.rep)
# Create some data
obs.loc &lt;- runif(n = n.obs, min = 0, max = 1)
A &lt;- rSPDE.A1d(x, obs.loc)
noise &lt;- rnorm(n.obs * n.rep)
dim(noise) &lt;- c(n.obs, n.rep)
Y &lt;- as.matrix(A %*% u + sigma.e * noise)
# define negative likelihood function for optimization using matern.loglike
mlik &lt;- construct.spde.matern.loglike(op, Y, A)
#' #The parameters can now be estimated by minimizing mlik with optim

# Choose some reasonable starting values depending on the size of the domain
theta0 &lt;- log(c( 1 / sqrt(var(c(Y))),sqrt(8), 0.9, 0.01))
# run estimation and display the results
theta &lt;- optim(theta0, mlik)
print(data.frame(
  tau = c(tau[1], exp(theta$par[1])), kappa = c(kappa[1], exp(theta$par[2])),
  nu = c(nu, exp(theta$par[3])), sigma.e = c(sigma.e, exp(theta$par[4])),
  row.names = c("Truth", "Estimates")
))

</code></pre>

<hr>
<h2 id='cross_validation'>Perform cross-validation on a list of fitted models.</h2><span id='topic+cross_validation'></span>

<h3>Description</h3>

<p>Obtain several scores for a list of fitted models according
to a folding scheme.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cross_validation(
  models,
  model_names = NULL,
  scores = c("mse", "crps", "scrps", "dss"),
  cv_type = c("k-fold", "loo", "lpo"),
  k = 5,
  percentage = 20,
  number_folds = 10,
  n_samples = 1000,
  return_scores_folds = FALSE,
  orientation_results = c("negative", "positive"),
  include_best = TRUE,
  train_test_indexes = NULL,
  return_train_test = FALSE,
  parallelize_RP = FALSE,
  n_cores_RP = parallel::detectCores() - 1,
  true_CV = FALSE,
  save_settings = FALSE,
  print = TRUE,
  fit_verbose = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cross_validation_+3A_models">models</code></td>
<td>
<p>A fitted model obtained from calling the <code>bru()</code> function or a list of models fitted with the <code>bru()</code> function.</p>
</td></tr>
<tr><td><code id="cross_validation_+3A_model_names">model_names</code></td>
<td>
<p>A vector containing the names of the models to appear in the returned <code>data.frame</code>. If <code>NULL</code>, the names will be of the form <code style="white-space: pre;">&#8288;Model 1&#8288;</code>, <code style="white-space: pre;">&#8288;Model 2&#8288;</code>, and so on. By default, it will try to obtain the name from the models list.</p>
</td></tr>
<tr><td><code id="cross_validation_+3A_scores">scores</code></td>
<td>
<p>A vector containing the scores to be computed. The options are &quot;mse&quot;, &quot;crps&quot;, &quot;scrps&quot; and &quot;dss&quot;. By default, all scores are computed.</p>
</td></tr>
<tr><td><code id="cross_validation_+3A_cv_type">cv_type</code></td>
<td>
<p>The type of the folding to be carried out. The options are <code>k-fold</code> for <code>k</code>-fold cross-validation, in which case the parameter <code>k</code> should be provided,
<code>loo</code>, for leave-one-out and <code>lpo</code> for leave-percentage-out, in this case, the parameter <code>percentage</code> should be given, and also the <code>number_folds</code>
with the number of folds to be done. The default is <code>k-fold</code>.</p>
</td></tr>
<tr><td><code id="cross_validation_+3A_k">k</code></td>
<td>
<p>The number of folds to be used in <code>k</code>-fold cross-validation. Will only be used if <code>cv_type</code> is <code>k-fold</code>.</p>
</td></tr>
<tr><td><code id="cross_validation_+3A_percentage">percentage</code></td>
<td>
<p>The percentage (from 1 to 99) of the data to be used to train the model. Will only be used if <code>cv_type</code> is <code>lpo</code>.</p>
</td></tr>
<tr><td><code id="cross_validation_+3A_number_folds">number_folds</code></td>
<td>
<p>Number of folds to be done if <code>cv_type</code> is <code>lpo</code>.</p>
</td></tr>
<tr><td><code id="cross_validation_+3A_n_samples">n_samples</code></td>
<td>
<p>Number of samples to compute the posterior statistics to be used to compute the scores.</p>
</td></tr>
<tr><td><code id="cross_validation_+3A_return_scores_folds">return_scores_folds</code></td>
<td>
<p>If <code>TRUE</code>, the scores for each fold will also be returned.</p>
</td></tr>
<tr><td><code id="cross_validation_+3A_orientation_results">orientation_results</code></td>
<td>
<p>character vector. The options are &quot;negative&quot; and &quot;positive&quot;. If &quot;negative&quot;, the smaller the scores the better. If &quot;positive&quot;, the larger the scores the better.</p>
</td></tr>
<tr><td><code id="cross_validation_+3A_include_best">include_best</code></td>
<td>
<p>Should a row indicating which model was the best for each score be included?</p>
</td></tr>
<tr><td><code id="cross_validation_+3A_train_test_indexes">train_test_indexes</code></td>
<td>
<p>A list containing two entries <code>train</code>, which is a list whose elements are vectors of indexes of the training data, and <code>test</code>, which is a list whose elements are vectors of indexes of the test data.
Typically this will be returned list obtained by setting the argument <code>return_train_test</code> to <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="cross_validation_+3A_return_train_test">return_train_test</code></td>
<td>
<p>Logical. Should the training and test indexes be returned? If 'TRUE' the train and test indexes will the 'train_test' element of the returned list.</p>
</td></tr>
<tr><td><code id="cross_validation_+3A_parallelize_rp">parallelize_RP</code></td>
<td>
<p>Logical. Should the computation of CRPS and SCRPS be parallelized?</p>
</td></tr>
<tr><td><code id="cross_validation_+3A_n_cores_rp">n_cores_RP</code></td>
<td>
<p>Number of cores to be used if <code>parallelize_rp</code> is <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="cross_validation_+3A_true_cv">true_CV</code></td>
<td>
<p>Should a <code>TRUE</code> cross-validation be performed? If <code>TRUE</code> the models will be fitted on the training dataset. If <code>FALSE</code>, the parameters will be kept fixed at the ones obtained in the result object.</p>
</td></tr>
<tr><td><code id="cross_validation_+3A_save_settings">save_settings</code></td>
<td>
<p>Logical. If <code>TRUE</code>, the settings used in the cross-validation will also be returned.</p>
</td></tr>
<tr><td><code id="cross_validation_+3A_print">print</code></td>
<td>
<p>Should partial results be printed throughout the computation?</p>
</td></tr>
<tr><td><code id="cross_validation_+3A_fit_verbose">fit_verbose</code></td>
<td>
<p>Should INLA's run during cross-validation be verbose?</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data.frame with the fitted models and the corresponding scores.
</p>

<hr>
<h2 id='folded.matern.covariance.1d'>The 1d folded Matern covariance function</h2><span id='topic+folded.matern.covariance.1d'></span>

<h3>Description</h3>

<p><code>folded.matern.covariance.1d</code> evaluates the 1d
folded Matern covariance function over an interval <code class="reqn">[0,L]</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>folded.matern.covariance.1d(
  h,
  m,
  kappa,
  nu,
  sigma,
  L = 1,
  N = 10,
  boundary = c("neumann", "dirichlet", "periodic")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="folded.matern.covariance.1d_+3A_h">h</code>, <code id="folded.matern.covariance.1d_+3A_m">m</code></td>
<td>
<p>Vectors of arguments of the covariance function.</p>
</td></tr>
<tr><td><code id="folded.matern.covariance.1d_+3A_kappa">kappa</code></td>
<td>
<p>Range parameter.</p>
</td></tr>
<tr><td><code id="folded.matern.covariance.1d_+3A_nu">nu</code></td>
<td>
<p>Shape parameter.</p>
</td></tr>
<tr><td><code id="folded.matern.covariance.1d_+3A_sigma">sigma</code></td>
<td>
<p>Standard deviation.</p>
</td></tr>
<tr><td><code id="folded.matern.covariance.1d_+3A_l">L</code></td>
<td>
<p>The upper bound of the interval <code class="reqn">[0,L]</code>. By default, <code>L=1</code>.</p>
</td></tr>
<tr><td><code id="folded.matern.covariance.1d_+3A_n">N</code></td>
<td>
<p>The truncation parameter.</p>
</td></tr>
<tr><td><code id="folded.matern.covariance.1d_+3A_boundary">boundary</code></td>
<td>
<p>The boundary condition. The possible conditions
are <code>"neumann"</code> (default), <code>"dirichlet"</code> or
<code>"periodic"</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>folded.matern.covariance.1d</code> evaluates the 1d folded Matern
covariance function over an interval <code class="reqn">[0,L]</code> under different
boundary conditions. For periodic boundary conditions
</p>
<p style="text-align: center;"><code class="reqn">C_{\mathcal{P}}(h,m) = \sum_{k=-\infty}^{\infty} (C(h-m+2kL),</code>
</p>

<p>for Neumann boundary conditions
</p>
<p style="text-align: center;"><code class="reqn">C_{\mathcal{N}}(h,m) = \sum_{k=-\infty}^{\infty}
(C(h-m+2kL)+C(h+m+2kL)),</code>
</p>

<p>and for Dirichlet boundary conditions:
</p>
<p style="text-align: center;"><code class="reqn">C_{\mathcal{D}}(h,m) = \sum_{k=-\infty}^{\infty}
(C(h-m+2kL)-C(h+m+2kL)),</code>
</p>

<p>where <code class="reqn">C(\cdot)</code> is the Matern covariance function:
</p>
<p style="text-align: center;"><code class="reqn">C(h) = \frac{\sigma^2}{2^{\nu-1}\Gamma(\nu)}(\kappa h)^\nu
K_\nu(\kappa h).</code>
</p>

<p>We consider the truncation:
</p>
<p style="text-align: center;"><code class="reqn">C_{{\mathcal{P}},N}(h,m) = \sum_{k=-N}^{N} C(h-m+2kL),
C_{\mathcal{N},N}(h,m) = \sum_{k=-\infty}^{\infty}
(C(h-m+2kL)+C(h+m+2kL)),</code>
</p>

<p>and
</p>
<p style="text-align: center;"><code class="reqn">C_{\mathcal{D},N}(h,m) = \sum_{k=-N}^{N}
(C(h-m+2kL)-C(h+m+2kL)).</code>
</p>



<h3>Value</h3>

<p>A matrix with the corresponding covariance values.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- seq(from = 0, to = 1, length.out = 101)
plot(x, folded.matern.covariance.1d(rep(0.5, length(x)), x,
kappa = 10, nu = 1 / 5, sigma = 1),
  type = "l", ylab = "C(h)", xlab = "h"
)

</code></pre>

<hr>
<h2 id='folded.matern.covariance.2d'>The 2d folded Matern covariance function</h2><span id='topic+folded.matern.covariance.2d'></span>

<h3>Description</h3>

<p><code>folded.matern.covariance.2d</code> evaluates the 2d
folded Matern covariance function over an interval
<code class="reqn">[0,L]\times [0,L]</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>folded.matern.covariance.2d(
  h,
  m,
  kappa,
  nu,
  sigma,
  L = 1,
  N = 10,
  boundary = c("neumann", "dirichlet", "periodic", "R2")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="folded.matern.covariance.2d_+3A_h">h</code>, <code id="folded.matern.covariance.2d_+3A_m">m</code></td>
<td>
<p>Vectors with two coordinates.</p>
</td></tr>
<tr><td><code id="folded.matern.covariance.2d_+3A_kappa">kappa</code></td>
<td>
<p>Range parameter.</p>
</td></tr>
<tr><td><code id="folded.matern.covariance.2d_+3A_nu">nu</code></td>
<td>
<p>Shape parameter.</p>
</td></tr>
<tr><td><code id="folded.matern.covariance.2d_+3A_sigma">sigma</code></td>
<td>
<p>Standard deviation.</p>
</td></tr>
<tr><td><code id="folded.matern.covariance.2d_+3A_l">L</code></td>
<td>
<p>The upper bound of the square <code class="reqn">[0,L]\times [0,L]</code>.
By default, <code>L=1</code>.</p>
</td></tr>
<tr><td><code id="folded.matern.covariance.2d_+3A_n">N</code></td>
<td>
<p>The truncation parameter.</p>
</td></tr>
<tr><td><code id="folded.matern.covariance.2d_+3A_boundary">boundary</code></td>
<td>
<p>The boundary condition. The possible conditions
are <code>"neumann"</code> (default), <code>"dirichlet"</code>,
<code>"periodic"</code> or <code>"R2"</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>folded.matern.covariance.2d</code> evaluates the 1d folded
Matern covariance function over an interval
<code class="reqn">[0,L]\times [0,L]</code> under different boundary conditions.
For periodic boundary conditions
</p>
<p style="text-align: center;"><code class="reqn">C_{\mathcal{P}}((h_1,h_2),(m_1,m_2)) =
\sum_{k_2=-\infty}^\infty \sum_{k_1=-\infty}^{\infty}
(C(\|(h_1-m_1+2k_1L,h_2-m_2+2k_2L)\|),</code>
</p>

<p>for Neumann boundary conditions
</p>
<p style="text-align: center;"><code class="reqn">C_{\mathcal{N}}((h_1,h_2),(m_1,m_2)) =
\sum_{k_2=-\infty}^\infty \sum_{k_1=-\infty}^{\infty}
(C(\|(h_1-m_1+2k_1L,h_2-m_2+2k_2L)\|)+C(\|(h_1-m_1+2k_1L,
h_2+m_2+2k_2L)\|)+C(\|(h_1+m_1+2k_1L,h_2-m_2+2k_2L)\|)+
C(\|(h_1+m_1+2k_1L,h_2+m_2+2k_2L)\|)),</code>
</p>

<p>and for Dirichlet boundary conditions:
</p>
<p style="text-align: center;"><code class="reqn">C_{\mathcal{D}}((h_1,h_2),(m_1,m_2)) = \sum_{k_2=-\infty}^\infty
\sum_{k_1=-\infty}^{\infty} (C(\|(h_1-m_1+2k_1L,h_2-m_2+2k_2L)\|)-
C(\|(h_1-m_1+2k_1L,h_2+m_2+2k_2L)\|)-C(\|(h_1+m_1+2k_1L,
h_2-m_2+2k_2L)\|)+C(\|(h_1+m_1+2k_1L,h_2+m_2+2k_2L)\|)),</code>
</p>

<p>where <code class="reqn">C(\cdot)</code> is the Matern covariance function:
</p>
<p style="text-align: center;"><code class="reqn">C(h) = \frac{\sigma^2}{2^{\nu-1}\Gamma(\nu)}
(\kappa h)^\nu K_\nu(\kappa h).</code>
</p>

<p>We consider the truncation for <code class="reqn">k_1,k_2</code> from <code class="reqn">-N</code> to <code class="reqn">N</code>.
</p>


<h3>Value</h3>

<p>The correspoding covariance.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>h &lt;- c(0.5, 0.5)
m &lt;- c(0.5, 0.5)
folded.matern.covariance.2d(h, m, kappa = 10, nu = 1 / 5, sigma = 1)

</code></pre>

<hr>
<h2 id='fractional.operators'>Rational approximations of fractional operators</h2><span id='topic+fractional.operators'></span>

<h3>Description</h3>

<p><code>fractional.operators</code> is used for computing an approximation,
which can be used for inference and simulation, of the fractional SPDE
</p>
<p style="text-align: center;"><code class="reqn">L^\beta (\tau u(s)) = W.</code>
</p>

<p>Here <code class="reqn">L</code> is a differential operator, <code class="reqn">\beta&gt;0</code> is
the fractional power, <code class="reqn">\tau</code> is a positive scalar or vector that
scales the variance of the solution <code class="reqn">u</code>, and <code class="reqn">W</code> is white noise.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fractional.operators(L, beta, C, scale.factor, m = 1, tau = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fractional.operators_+3A_l">L</code></td>
<td>
<p>A finite element discretization of the operator <code class="reqn">L</code>.</p>
</td></tr>
<tr><td><code id="fractional.operators_+3A_beta">beta</code></td>
<td>
<p>The positive fractional power.</p>
</td></tr>
<tr><td><code id="fractional.operators_+3A_c">C</code></td>
<td>
<p>The mass matrix of the finite element discretization.</p>
</td></tr>
<tr><td><code id="fractional.operators_+3A_scale.factor">scale.factor</code></td>
<td>
<p>A constant <code class="reqn">c</code> is a lower bound for the the smallest
eigenvalue of the non-discretized operator <code class="reqn">L</code>.</p>
</td></tr>
<tr><td><code id="fractional.operators_+3A_m">m</code></td>
<td>
<p>The order of the rational approximation, which needs to be a
positive integer. The default value is 1.
Higer values gives a more accurate approximation, which are more
computationally expensive to use for inference. Currently, the largest value
of m that is implemented is 4.</p>
</td></tr>
<tr><td><code id="fractional.operators_+3A_tau">tau</code></td>
<td>
<p>The constant or vector that scales the variance of the solution.
The default value is 1.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The approximation is based on a rational approximation of
the fractional operator, resulting in an
approximate model on the form </p>
<p style="text-align: center;"><code class="reqn">P_l u(s) = P_r W,</code>
</p>

<p>where <code class="reqn">P_j = p_j(L)</code> are non-fractional operators defined in terms of
polynomials <code class="reqn">p_j</code> for <code class="reqn">j=l,r</code>. The order of <code class="reqn">p_r</code> is given by
<code>m</code> and the order of <code class="reqn">p_l</code> is <code class="reqn">m + m_\beta</code>
where <code class="reqn">m_\beta</code> is the integer part of <code class="reqn">\beta</code> if <code class="reqn">\beta&gt;1</code> and
<code class="reqn">m_\beta = 1</code> otherwise.
</p>
<p>The discrete approximation can be written as <code class="reqn">u = P_r x</code> where
<code class="reqn">x \sim N(0,Q^{-1})</code> and <code class="reqn">Q = P_l^T C^{-1} P_l</code>.
Note that the matrices <code class="reqn">P_r</code> and <code class="reqn">Q</code> may be be ill-conditioned
for <code class="reqn">m&gt;1</code>. In this case, the methods in <code><a href="#topic+operator.operations">operator.operations()</a></code>
should be used for operations involving the matrices, since these methods
are more numerically stable.
</p>


<h3>Value</h3>

<p><code>fractional.operators</code> returns an object of class &quot;rSPDEobj&quot;.
This object contains the following quantities:
</p>
<table>
<tr><td><code>Pl</code></td>
<td>
<p>The operator <code class="reqn">P_l</code>.</p>
</td></tr>
<tr><td><code>Pr</code></td>
<td>
<p>The operator <code class="reqn">P_r</code>.</p>
</td></tr>
<tr><td><code>C</code></td>
<td>
<p>The mass lumped mass matrix.</p>
</td></tr>
<tr><td><code>Ci</code></td>
<td>
<p>The inverse of <code>C</code>.</p>
</td></tr>
<tr><td><code>m</code></td>
<td>
<p>The order of the rational approximation.</p>
</td></tr>
<tr><td><code>beta</code></td>
<td>
<p>The fractional power.</p>
</td></tr>
<tr><td><code>type</code></td>
<td>
<p>String indicating the type of approximation.</p>
</td></tr>
<tr><td><code>Q</code></td>
<td>
<p>The matrix <code>t(Pl) %*% solve(C,Pl)</code>.</p>
</td></tr>
<tr><td><code>type</code></td>
<td>
<p>String indicating the type of approximation.</p>
</td></tr>
<tr><td><code>Pl.factors</code></td>
<td>
<p>List with elements that can be used to assemble <code class="reqn">P_l</code>.</p>
</td></tr>
<tr><td><code>Pr.factors</code></td>
<td>
<p>List with elements that can be used to assemble <code class="reqn">P_r</code>.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+matern.operators">matern.operators()</a></code>, <code><a href="#topic+spde.matern.operators">spde.matern.operators()</a></code>,
<code><a href="#topic+matern.operators">matern.operators()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Compute rational approximation of a Gaussian process with a
# Matern covariance function on R
kappa &lt;- 10
sigma &lt;- 1
nu &lt;- 0.8

# create mass and stiffness matrices for a FEM discretization
x &lt;- seq(from = 0, to = 1, length.out = 101)
fem &lt;- rSPDE.fem1d(x)

# compute rational approximation of covariance function at 0.5
tau &lt;- sqrt(gamma(nu) / (sigma^2 * kappa^(2 * nu) *
  (4 * pi)^(1 / 2) * gamma(nu + 1 / 2)))
op &lt;- fractional.operators(
  L = fem$G + kappa^2 * fem$C, beta = (nu + 1 / 2) / 2,
  C = fem$C, scale.factor = kappa^2, tau = tau
)

v &lt;- t(rSPDE.A1d(x, 0.5))
c.approx &lt;- Sigma.mult(op, v)

# plot the result and compare with the true Matern covariance
plot(x, matern.covariance(abs(x - 0.5), kappa, nu, sigma),
  type = "l", ylab = "C(h)",
  xlab = "h", main = "Matern covariance and rational approximations"
)
lines(x, c.approx, col = 2)

</code></pre>

<hr>
<h2 id='get.initial.values.rSPDE'>Initial values for log-likelihood optimization in rSPDE models
with a latent stationary Gaussian Matern model</h2><span id='topic+get.initial.values.rSPDE'></span>

<h3>Description</h3>

<p>Auxiliar function to obtain domain-based initial values for
log-likelihood optimization in rSPDE models
with a latent stationary Gaussian Matern model
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get.initial.values.rSPDE(
  mesh = NULL,
  mesh.range = NULL,
  graph.obj = NULL,
  n.spde = 1,
  dim = NULL,
  B.tau = NULL,
  B.kappa = NULL,
  B.sigma = NULL,
  B.range = NULL,
  nu = NULL,
  parameterization = c("matern", "spde"),
  include.nu = TRUE,
  log.scale = TRUE,
  nu.upper.bound = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get.initial.values.rSPDE_+3A_mesh">mesh</code></td>
<td>
<p>An in INLA mesh</p>
</td></tr>
<tr><td><code id="get.initial.values.rSPDE_+3A_mesh.range">mesh.range</code></td>
<td>
<p>The range of the mesh.</p>
</td></tr>
<tr><td><code id="get.initial.values.rSPDE_+3A_graph.obj">graph.obj</code></td>
<td>
<p>A <code>metric_graph</code> object. To be used in case both <code>mesh</code> and <code>mesh.range</code> are <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="get.initial.values.rSPDE_+3A_n.spde">n.spde</code></td>
<td>
<p>The number of basis functions in the mesh model.</p>
</td></tr>
<tr><td><code id="get.initial.values.rSPDE_+3A_dim">dim</code></td>
<td>
<p>The dimension of the domain.</p>
</td></tr>
<tr><td><code id="get.initial.values.rSPDE_+3A_b.tau">B.tau</code></td>
<td>
<p>Matrix with specification of log-linear model for <code class="reqn">\tau</code>. Will be used if <code>parameterization = 'spde'</code>.</p>
</td></tr>
<tr><td><code id="get.initial.values.rSPDE_+3A_b.kappa">B.kappa</code></td>
<td>
<p>Matrix with specification of log-linear model for <code class="reqn">\kappa</code>. Will be used if <code>parameterization = 'spde'</code>.</p>
</td></tr>
<tr><td><code id="get.initial.values.rSPDE_+3A_b.sigma">B.sigma</code></td>
<td>
<p>Matrix with specification of log-linear model for <code class="reqn">\sigma</code>. Will be used if <code>parameterization = 'matern'</code>.</p>
</td></tr>
<tr><td><code id="get.initial.values.rSPDE_+3A_b.range">B.range</code></td>
<td>
<p>Matrix with specification of log-linear model for <code class="reqn">\rho</code>, which is a range-like parameter (it is exactly the range parameter in the stationary case). Will be used if <code>parameterization = 'matern'</code>.</p>
</td></tr>
<tr><td><code id="get.initial.values.rSPDE_+3A_nu">nu</code></td>
<td>
<p>The smoothness parameter.</p>
</td></tr>
<tr><td><code id="get.initial.values.rSPDE_+3A_parameterization">parameterization</code></td>
<td>
<p>Which parameterization to use? <code>matern</code> uses range, std. deviation and nu (smoothness). <code>spde</code> uses kappa, tau and nu (smoothness). The default is <code>matern</code>.</p>
</td></tr>
<tr><td><code id="get.initial.values.rSPDE_+3A_include.nu">include.nu</code></td>
<td>
<p>Should we also provide an initial guess for nu?</p>
</td></tr>
<tr><td><code id="get.initial.values.rSPDE_+3A_log.scale">log.scale</code></td>
<td>
<p>Should the results be provided in log scale?</p>
</td></tr>
<tr><td><code id="get.initial.values.rSPDE_+3A_nu.upper.bound">nu.upper.bound</code></td>
<td>
<p>Should an upper bound for nu be considered?</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector of the form (theta_1,theta_2,theta_3) or where
theta_1 is the initial guess for tau, theta_2 is the initial guess for kappa
and theta_3 is the initial guess for nu.
</p>

<hr>
<h2 id='gg_df'>Data frame for result objects from R-INLA fitted models to be used in ggplot2</h2><span id='topic+gg_df'></span>

<h3>Description</h3>

<p>Data frame for result objects from R-INLA fitted models to be used in ggplot2
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gg_df(result, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gg_df_+3A_result">result</code></td>
<td>
<p>a result object for which the data frame is desired</p>
</td></tr>
<tr><td><code id="gg_df_+3A_...">...</code></td>
<td>
<p>further arguments passed to or from other methods.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data frame containing the posterior densities.
</p>

<hr>
<h2 id='gg_df.rspde_result'>Data frame for rspde_result objects to be used in ggplot2</h2><span id='topic+gg_df.rspde_result'></span>

<h3>Description</h3>

<p>Returns a ggplot-friendly data-frame with the marginal posterior densities.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'rspde_result'
gg_df(
  result,
  parameter = result$params,
  transform = TRUE,
  restrict_x_axis = NULL,
  restrict_quantiles = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gg_df.rspde_result_+3A_result">result</code></td>
<td>
<p>An rspde_result object.</p>
</td></tr>
<tr><td><code id="gg_df.rspde_result_+3A_parameter">parameter</code></td>
<td>
<p>Vector. Which parameters to get the posterior density in the data.frame? The options are <code>std.dev</code>, <code>range</code>, <code>tau</code>, <code>kappa</code> and <code>nu</code>.</p>
</td></tr>
<tr><td><code id="gg_df.rspde_result_+3A_transform">transform</code></td>
<td>
<p>Should the posterior density be given in the original scale?</p>
</td></tr>
<tr><td><code id="gg_df.rspde_result_+3A_restrict_x_axis">restrict_x_axis</code></td>
<td>
<p>Variables to restrict the range of x axis based on quantiles.</p>
</td></tr>
<tr><td><code id="gg_df.rspde_result_+3A_restrict_quantiles">restrict_quantiles</code></td>
<td>
<p>Named list of quantiles to restrict x axis. It should contain the name of the parameter
along with a vector with two elements specifying the lower and upper quantiles. The names should be
match the ones in result$params. For example, if we want to restrict nu to the 0.05 and 0.95 quantiles
we do <code>restrict_quantiles = c(0.05, 0.95)</code>.</p>
</td></tr>
<tr><td><code id="gg_df.rspde_result_+3A_...">...</code></td>
<td>
<p>currently not used.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data frame containing the posterior densities.
</p>

<hr>
<h2 id='glance.rspde_lme'>Glance at an <code>rspde_lme</code> object</h2><span id='topic+glance.rspde_lme'></span><span id='topic+glance'></span>

<h3>Description</h3>

<p>Glance accepts a <code>rspde_lme</code> object and returns a
<code><a href="tidyr.html#topic+reexports">tidyr::tibble()</a></code> with exactly one row of model summaries.
The summaries are the square root of the estimated variance of the measurement error, residual
degrees of freedom, AIC, BIC, log-likelihood,
the type of latent model used in the fit and the total number of observations.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'rspde_lme'
glance(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="glance.rspde_lme_+3A_x">x</code></td>
<td>
<p>An <code>rspde_lme</code> object.</p>
</td></tr>
<tr><td><code id="glance.rspde_lme_+3A_...">...</code></td>
<td>
<p>Currently not used.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code><a href="tidyr.html#topic+reexports">tidyr::tibble()</a></code> with exactly one row and columns:
</p>

<ul>
<li> <p><code>nobs</code> Number of observations used.
</p>
</li>
<li> <p><code>sigma</code> the square root of the estimated residual variance
</p>
</li>
<li> <p><code>logLik</code> The log-likelihood of the model.
</p>
</li>
<li> <p><code>AIC</code> Akaike's Information Criterion for the model.
</p>
</li>
<li> <p><code>BIC</code> Bayesian Information Criterion for the model.
</p>
</li>
<li> <p><code>deviance</code> Deviance of the model.
</p>
</li>
<li> <p><code>df.residual</code> Residual degrees of freedom.
</p>
</li>
<li> <p><code>model.type</code> Type of latent model fitted.
</p>
</li></ul>



<h3>See Also</h3>

<p><a href="#topic+augment.rspde_lme">augment.rspde_lme</a>
</p>

<hr>
<h2 id='graph_data_rspde'>Data extraction from metric graphs for 'rSPDE' models</h2><span id='topic+graph_data_rspde'></span>

<h3>Description</h3>

<p>Extracts data from metric graphs to be used by 'INLA' and 'inlabru'.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>graph_data_rspde(
  graph_rspde,
  name = "field",
  repl = NULL,
  group = NULL,
  group_col = NULL,
  only_pred = FALSE,
  loc = NULL,
  loc_name = NULL,
  tibble = FALSE,
  drop_na = FALSE,
  drop_all_na = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="graph_data_rspde_+3A_graph_rspde">graph_rspde</code></td>
<td>
<p>An <code>inla_metric_graph_spde</code> object built with the
<code>rspde.metric_graph()</code> function.</p>
</td></tr>
<tr><td><code id="graph_data_rspde_+3A_name">name</code></td>
<td>
<p>A character string with the base name of the effect.</p>
</td></tr>
<tr><td><code id="graph_data_rspde_+3A_repl">repl</code></td>
<td>
<p>Which replicates? If there is no replicates, one
can set <code>repl</code> to <code>NULL</code>. If one wants all replicates,
then one sets to <code>repl</code> to <code>.all</code>.</p>
</td></tr>
<tr><td><code id="graph_data_rspde_+3A_group">group</code></td>
<td>
<p>Which groups? If there is no groups, one
can set <code>group</code> to <code>NULL</code>. If one wants all groups,
then one sets to <code>group</code> to <code>.all</code>.</p>
</td></tr>
<tr><td><code id="graph_data_rspde_+3A_group_col">group_col</code></td>
<td>
<p>Which &quot;column&quot; of the data contains the group variable?</p>
</td></tr>
<tr><td><code id="graph_data_rspde_+3A_only_pred">only_pred</code></td>
<td>
<p>Should only return the <code>data.frame</code> to the prediction data?</p>
</td></tr>
<tr><td><code id="graph_data_rspde_+3A_loc">loc</code></td>
<td>
<p>Locations. If not given, they will be chosen as the available locations on the metric graph internal dataset.</p>
</td></tr>
<tr><td><code id="graph_data_rspde_+3A_loc_name">loc_name</code></td>
<td>
<p>Character with the name of the location variable to be used in
'inlabru' prediction.</p>
</td></tr>
<tr><td><code id="graph_data_rspde_+3A_tibble">tibble</code></td>
<td>
<p>Should the data be returned as a <code>tidyr::tibble</code>?</p>
</td></tr>
<tr><td><code id="graph_data_rspde_+3A_drop_na">drop_na</code></td>
<td>
<p>Should the rows with at least one NA for one of the columns be removed? DEFAULT is <code>FALSE</code>. This option is turned to <code>FALSE</code> if <code>only_pred</code> is <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="graph_data_rspde_+3A_drop_all_na">drop_all_na</code></td>
<td>
<p>Should the rows with all variables being NA be removed? DEFAULT is <code>TRUE</code>. This option is turned to <code>FALSE</code> if <code>only_pred</code> is <code>TRUE</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An 'INLA' and 'inlabru' friendly list with the data.
</p>

<hr>
<h2 id='intrinsic.matern.operators'>Covariance-based approximations of intrinsic fields</h2><span id='topic+intrinsic.matern.operators'></span>

<h3>Description</h3>

<p><code>intrinsic.matern.operators</code> is used for computing a
covariance-based rational SPDE approximation of intrinsic
fields on <code class="reqn">R^d</code> defined through the SPDE
</p>
<p style="text-align: center;"><code class="reqn">(-\Delta)^{\beta/2}(\kappa^2-\Delta)^{\alpha/2} (\tau u) = \mathcal{W}</code>
</p>



<h3>Usage</h3>

<pre><code class='language-R'>intrinsic.matern.operators(
  kappa,
  tau,
  alpha,
  beta = 1,
  G = NULL,
  C = NULL,
  d = NULL,
  mesh = NULL,
  graph = NULL,
  loc_mesh = NULL,
  m_alpha = 2,
  m_beta = 2,
  compute_higher_order = FALSE,
  return_block_list = FALSE,
  type_rational_approximation = c("chebfun", "brasil", "chebfunLB"),
  fem_mesh_matrices = NULL,
  scaling = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="intrinsic.matern.operators_+3A_kappa">kappa</code></td>
<td>
<p>range parameter</p>
</td></tr>
<tr><td><code id="intrinsic.matern.operators_+3A_tau">tau</code></td>
<td>
<p>precision parameter</p>
</td></tr>
<tr><td><code id="intrinsic.matern.operators_+3A_alpha">alpha</code></td>
<td>
<p>Smoothness parameter</p>
</td></tr>
<tr><td><code id="intrinsic.matern.operators_+3A_beta">beta</code></td>
<td>
<p>Smoothness parameter</p>
</td></tr>
<tr><td><code id="intrinsic.matern.operators_+3A_g">G</code></td>
<td>
<p>The stiffness matrix of a finite element discretization
of the domain of interest.</p>
</td></tr>
<tr><td><code id="intrinsic.matern.operators_+3A_c">C</code></td>
<td>
<p>The mass matrix of a finite element discretization of
the domain of interest.</p>
</td></tr>
<tr><td><code id="intrinsic.matern.operators_+3A_d">d</code></td>
<td>
<p>The dimension of the domain.</p>
</td></tr>
<tr><td><code id="intrinsic.matern.operators_+3A_mesh">mesh</code></td>
<td>
<p>An inla mesh.</p>
</td></tr>
<tr><td><code id="intrinsic.matern.operators_+3A_graph">graph</code></td>
<td>
<p>An optional <code>metric_graph</code> object. Replaces <code>d</code>, <code>C</code> and <code>G</code>.</p>
</td></tr>
<tr><td><code id="intrinsic.matern.operators_+3A_loc_mesh">loc_mesh</code></td>
<td>
<p>locations for the mesh for <code>d=1</code>.</p>
</td></tr>
<tr><td><code id="intrinsic.matern.operators_+3A_m_alpha">m_alpha</code></td>
<td>
<p>The order of the rational approximation for the Matérn part,
which needs to be a positive integer. The default value is 2.</p>
</td></tr>
<tr><td><code id="intrinsic.matern.operators_+3A_m_beta">m_beta</code></td>
<td>
<p>The order of the rational approximation for the intrinsic part,
which needs to be a positive integer. The default value is 2.</p>
</td></tr>
<tr><td><code id="intrinsic.matern.operators_+3A_compute_higher_order">compute_higher_order</code></td>
<td>
<p>Logical. Should the higher order finite
element matrices be computed?</p>
</td></tr>
<tr><td><code id="intrinsic.matern.operators_+3A_return_block_list">return_block_list</code></td>
<td>
<p>Logical. For <code>type = "covariance"</code>,
should the block parts of the precision matrix be returned
separately as a list?</p>
</td></tr>
<tr><td><code id="intrinsic.matern.operators_+3A_type_rational_approximation">type_rational_approximation</code></td>
<td>
<p>Which type of rational
approximation should be used? The current types are
&quot;chebfun&quot;, &quot;brasil&quot; or &quot;chebfunLB&quot;.</p>
</td></tr>
<tr><td><code id="intrinsic.matern.operators_+3A_fem_mesh_matrices">fem_mesh_matrices</code></td>
<td>
<p>A list containing FEM-related matrices.
The list should contain elements c0, g1, g2, g3, etc.</p>
</td></tr>
<tr><td><code id="intrinsic.matern.operators_+3A_scaling">scaling</code></td>
<td>
<p>second lowest eigenvalue of g1</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The covariance operator
</p>
<p style="text-align: center;"><code class="reqn">\tau^{-2}(-\Delta)^{\beta}(\kappa^2-\Delta)^{\alpha}</code>
</p>

<p>is approximated based on rational approximations of the two fractional
components. The Laplacians are equipped with homogeneous Neumann boundary
conditions and a zero-mean constraint is additionally imposed to obtained
a non-intrinsic model.
</p>


<h3>Value</h3>

<p><code>intrinsic.matern.operators</code> returns an object of
class &quot;intrinsicCBrSPDEobj&quot;. This object is a list containing the
following quantities:
</p>
<table>
<tr><td><code>C</code></td>
<td>
<p>The mass lumped mass matrix.</p>
</td></tr>
<tr><td><code>Ci</code></td>
<td>
<p>The inverse of <code>C</code>.</p>
</td></tr>
<tr><td><code>GCi</code></td>
<td>
<p>The stiffness matrix G times <code>Ci</code></p>
</td></tr>
<tr><td><code>Gk</code></td>
<td>
<p>The stiffness matrix G along with the higher-order
FEM-related matrices G2, G3, etc.</p>
</td></tr>
<tr><td><code>fem_mesh_matrices</code></td>
<td>
<p>A list containing the mass lumped mass
matrix, the stiffness matrix and
the higher-order FEM-related matrices.</p>
</td></tr>
<tr><td><code>m_alpha</code></td>
<td>
<p>The order of the rational approximation for the Matérn part.</p>
</td></tr>
<tr><td><code>m_beta</code></td>
<td>
<p>The order of the rational approximation for the intrinsic part.</p>
</td></tr>
<tr><td><code>alpha</code></td>
<td>
<p>The fractional power of the Matérn part of the operator.</p>
</td></tr>
<tr><td><code>beta</code></td>
<td>
<p>The fractional power of the intrinsic part of the operator.</p>
</td></tr>
<tr><td><code>type</code></td>
<td>
<p>String indicating the type of approximation.</p>
</td></tr>
<tr><td><code>d</code></td>
<td>
<p>The dimension of the domain.</p>
</td></tr>
<tr><td><code>A</code></td>
<td>
<p>Matrix that sums the components in the approximation to the mesh nodes.</p>
</td></tr>
<tr><td><code>kappa</code></td>
<td>
<p>Range parameter of the covariance function</p>
</td></tr>
<tr><td><code>tau</code></td>
<td>
<p>Scale parameter of the covariance function.</p>
</td></tr>
<tr><td><code>type</code></td>
<td>
<p>String indicating the type of approximation.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>if (requireNamespace("RSpectra", quietly = TRUE)){
 x &lt;- seq(from = 0, to = 10, length.out = 201)
 beta &lt;- 1
 alpha &lt;- 1
 kappa &lt;- 1
 op &lt;- intrinsic.matern.operators(kappa = kappa, tau = 1, alpha = alpha, 
                                 beta = beta, loc_mesh = x, d=1) 
 # Compute and plot the variogram of the model
 Sigma &lt;- op$A %*% solve(op$Q,t(op$A))
 One &lt;- rep(1, times = ncol(Sigma))
 D &lt;- diag(Sigma)
 Gamma &lt;- 0.5*(One %*% t(D) + D %*% t(One) - 2 * Sigma)
 k &lt;- 100
 plot(x, Gamma[k, ], type = "l")
 lines(x, 
      variogram.intrinsic.spde(x[k], x, kappa, alpha, beta, L = 10, d = 1),
      col=2, lty = 2)
}
</code></pre>

<hr>
<h2 id='matern.covariance'>The Matern covariance function</h2><span id='topic+matern.covariance'></span>

<h3>Description</h3>

<p><code>matern.covariance</code> evaluates the Matern covariance function
</p>
<p style="text-align: center;"><code class="reqn">C(h) = \frac{\sigma^2}{2^{\nu-1}\Gamma(\nu)}(\kappa h)^\nu
K_\nu(\kappa h).</code>
</p>



<h3>Usage</h3>

<pre><code class='language-R'>matern.covariance(h, kappa, nu, sigma)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="matern.covariance_+3A_h">h</code></td>
<td>
<p>Distances to evaluate the covariance function at.</p>
</td></tr>
<tr><td><code id="matern.covariance_+3A_kappa">kappa</code></td>
<td>
<p>Range parameter.</p>
</td></tr>
<tr><td><code id="matern.covariance_+3A_nu">nu</code></td>
<td>
<p>Shape parameter.</p>
</td></tr>
<tr><td><code id="matern.covariance_+3A_sigma">sigma</code></td>
<td>
<p>Standard deviation.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector with the values C(h).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- seq(from = 0, to = 1, length.out = 101)
plot(x, matern.covariance(abs(x - 0.5), kappa = 10, nu = 1 / 5, sigma = 1),
  type = "l", ylab = "C(h)", xlab = "h"
)

</code></pre>

<hr>
<h2 id='matern.operators'>Rational approximations of stationary Gaussian Matern random fields</h2><span id='topic+matern.operators'></span>

<h3>Description</h3>

<p><code>matern.operators</code> is used for computing a rational SPDE approximation
of a stationary Gaussian random fields on <code class="reqn">R^d</code> with a Matern covariance
function
</p>
<p style="text-align: center;"><code class="reqn">C(h) = \frac{\sigma^2}{2^{\nu-1}\Gamma(\nu)}
(\kappa h)^\nu K_\nu(\kappa h)</code>
</p>



<h3>Usage</h3>

<pre><code class='language-R'>matern.operators(
  kappa = NULL,
  tau = NULL,
  alpha = NULL,
  sigma = NULL,
  range = NULL,
  nu = NULL,
  G = NULL,
  C = NULL,
  d = NULL,
  mesh = NULL,
  graph = NULL,
  range_mesh = NULL,
  loc_mesh = NULL,
  m = 1,
  type = c("covariance", "operator"),
  parameterization = c("spde", "matern"),
  compute_higher_order = FALSE,
  return_block_list = FALSE,
  type_rational_approximation = c("chebfun", "brasil", "chebfunLB"),
  fem_mesh_matrices = NULL,
  compute_logdet = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="matern.operators_+3A_kappa">kappa</code></td>
<td>
<p>Parameter kappa of the SPDE representation. If <code>NULL</code>, the range parameter will be used. If the range is also <code>NULL</code>, a starting value based on the mesh will be supplied.</p>
</td></tr>
<tr><td><code id="matern.operators_+3A_tau">tau</code></td>
<td>
<p>Parameter tau of the SPDE representation. If both sigma and tau are <code>NULL</code>, a starting value based on the mesh will be supplied.</p>
</td></tr>
<tr><td><code id="matern.operators_+3A_alpha">alpha</code></td>
<td>
<p>Parameter alpha of the SPDE representation. If <code>alpha</code> is <code>NULL</code>, a starting value will be supplied.</p>
</td></tr>
<tr><td><code id="matern.operators_+3A_sigma">sigma</code></td>
<td>
<p>Standard deviation of the covariance function. Used if <code>parameterization</code> is <code>matern</code>. If <code>NULL</code>, tau will be used. If tau is also <code>NULL</code>, a starting value based on the mesh will be supplied.</p>
</td></tr>
<tr><td><code id="matern.operators_+3A_range">range</code></td>
<td>
<p>Range parameter of the covariance function. Used if <code>parameterization</code> is <code>matern</code>. If range is <code>NULL</code>, a starting value based on the mesh will be supplied.</p>
</td></tr>
<tr><td><code id="matern.operators_+3A_nu">nu</code></td>
<td>
<p>Shape parameter of the covariance function. Used if <code>parameterization</code> is <code>matern</code>. If <code>NULL</code>, a starting value will be supplied.</p>
</td></tr>
<tr><td><code id="matern.operators_+3A_g">G</code></td>
<td>
<p>The stiffness matrix of a finite element discretization of the
domain of interest. Does not need to be given if either <code>mesh</code> or <code>graph</code> is supplied.</p>
</td></tr>
<tr><td><code id="matern.operators_+3A_c">C</code></td>
<td>
<p>The mass matrix of a finite element discretization of the domain
of interest. Does not need to be given if either <code>mesh</code> or <code>graph</code> is supplied.</p>
</td></tr>
<tr><td><code id="matern.operators_+3A_d">d</code></td>
<td>
<p>The dimension of the domain. Does not need to be given if either
<code>mesh</code> or <code>graph</code> is provided.</p>
</td></tr>
<tr><td><code id="matern.operators_+3A_mesh">mesh</code></td>
<td>
<p>An optional fmesher mesh. Replaces <code>d</code>, <code>C</code> and <code>G</code>.</p>
</td></tr>
<tr><td><code id="matern.operators_+3A_graph">graph</code></td>
<td>
<p>An optional <code>metric_graph</code> object. Replaces <code>d</code>, <code>C</code> and <code>G</code>.</p>
</td></tr>
<tr><td><code id="matern.operators_+3A_range_mesh">range_mesh</code></td>
<td>
<p>The range of the mesh. Will be used to provide starting values for the parameters. Will be used if <code>mesh</code> and <code>graph</code> are <code>NULL</code>, and if one of the parameters (kappa or tau for spde parameterization, or sigma or range for matern parameterization) are not provided.</p>
</td></tr>
<tr><td><code id="matern.operators_+3A_loc_mesh">loc_mesh</code></td>
<td>
<p>The mesh locations used to construct the matrices C and G. This option should be provided if one wants to use the <code>rspde_lme()</code> function and will not provide neither graph nor mesh. Only works for 1d data. Does not work for metric graphs. For metric graphs you should supply the graph using the <code>graph</code> argument.</p>
</td></tr>
<tr><td><code id="matern.operators_+3A_m">m</code></td>
<td>
<p>The order of the rational approximation, which needs to be a
positive integer. The default value is 1.</p>
</td></tr>
<tr><td><code id="matern.operators_+3A_type">type</code></td>
<td>
<p>The type of the rational approximation. The options are
&quot;covariance&quot; and &quot;operator&quot;. The default is &quot;covariance&quot;.</p>
</td></tr>
<tr><td><code id="matern.operators_+3A_parameterization">parameterization</code></td>
<td>
<p>Which parameterization to use? <code>matern</code> uses range, std. deviation and nu (smoothness). <code>spde</code> uses kappa, tau and alpha. The default is <code>spde</code>.</p>
</td></tr>
<tr><td><code id="matern.operators_+3A_compute_higher_order">compute_higher_order</code></td>
<td>
<p>Logical. Should the higher order finite
element matrices be computed?</p>
</td></tr>
<tr><td><code id="matern.operators_+3A_return_block_list">return_block_list</code></td>
<td>
<p>Logical. For <code>type = "covariance"</code>,
should the block parts of the precision matrix be returned
separately as a list?</p>
</td></tr>
<tr><td><code id="matern.operators_+3A_type_rational_approximation">type_rational_approximation</code></td>
<td>
<p>Which type of rational
approximation should be used? The current types are
&quot;chebfun&quot;, &quot;brasil&quot; or &quot;chebfunLB&quot;.</p>
</td></tr>
<tr><td><code id="matern.operators_+3A_fem_mesh_matrices">fem_mesh_matrices</code></td>
<td>
<p>A list containing FEM-related matrices.
The list should contain elements c0, g1, g2, g3, etc.</p>
</td></tr>
<tr><td><code id="matern.operators_+3A_compute_logdet">compute_logdet</code></td>
<td>
<p>Should log determinants be computed while building the model? (For covariance-based models)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If <code>type</code> is &quot;covariance&quot;, we use the
covariance-based rational approximation of the fractional operator.
In the SPDE approach, we model <code class="reqn">u</code> as the solution of the following SPDE:
</p>
<p style="text-align: center;"><code class="reqn">L^{\alpha/2}(\tau u) = \mathcal{W},</code>
</p>

<p>where
<code class="reqn">L  = -\Delta +\kappa^2 I</code> and <code class="reqn">\mathcal{W}</code> is the standard
Gaussian white noise. The covariance operator of <code class="reqn">u</code> is given
by <code class="reqn">L^{-\alpha}</code>. Now, let <code class="reqn">L_h</code> be a finite-element
approximation of <code class="reqn">L</code>. We can use
a rational approximation of order <code class="reqn">m</code> on <code class="reqn">L_h^{-\alpha}</code> to
obtain the following approximation:
</p>
<p style="text-align: center;"><code class="reqn">L_{h,m}^{-\alpha} = L_h^{-m_\alpha} p(L_h^{-1})q(L_h^{-1})^{-1},</code>
</p>

<p>where <code class="reqn">m_\alpha = \lfloor \alpha\rfloor</code>, <code class="reqn">p</code> and <code class="reqn">q</code> are
polynomials arising from such rational approximation.
From this approximation we construct an approximate precision
matrix for <code class="reqn">u</code>.
</p>
<p>If <code>type</code> is &quot;operator&quot;, the approximation is based on a
rational approximation of the fractional operator
<code class="reqn">(\kappa^2 -\Delta)^\beta</code>, where <code class="reqn">\beta = (\nu + d/2)/2</code>.
This results in an approximate model of the form </p>
<p style="text-align: center;"><code class="reqn">P_l u(s) = P_r W,</code>
</p>

<p>where <code class="reqn">P_j = p_j(L)</code> are non-fractional operators defined in terms
of polynomials <code class="reqn">p_j</code> for <code class="reqn">j=l,r</code>. The order of <code class="reqn">p_r</code> is given
by <code>m</code> and the order of <code class="reqn">p_l</code> is <code class="reqn">m + m_\beta</code>
where <code class="reqn">m_\beta</code> is the integer part of <code class="reqn">\beta</code> if <code class="reqn">\beta&gt;1</code> and
<code class="reqn">m_\beta = 1</code> otherwise.
</p>
<p>The discrete approximation can be written as <code class="reqn">u = P_r x</code> where
<code class="reqn">x \sim N(0,Q^{-1})</code> and <code class="reqn">Q = P_l^T C^{-1} P_l</code>.
Note that the matrices <code class="reqn">P_r</code> and <code class="reqn">Q</code> may be be
ill-conditioned for <code class="reqn">m&gt;1</code>. In this case, the methods in
<code><a href="#topic+operator.operations">operator.operations()</a></code> should be used for operations involving
the matrices, since these methods are more numerically stable.
</p>


<h3>Value</h3>

<p>If <code>type</code> is &quot;covariance&quot;, then <code>matern.operators</code>
returns an object of class &quot;CBrSPDEobj&quot;.
This object is a list containing the
following quantities:
</p>
<table>
<tr><td><code>C</code></td>
<td>
<p>The mass lumped mass matrix.</p>
</td></tr>
<tr><td><code>Ci</code></td>
<td>
<p>The inverse of <code>C</code>.</p>
</td></tr>
<tr><td><code>GCi</code></td>
<td>
<p>The stiffness matrix G times <code>Ci</code></p>
</td></tr>
<tr><td><code>Gk</code></td>
<td>
<p>The stiffness matrix G along with the higher-order
FEM-related matrices G2, G3, etc.</p>
</td></tr>
<tr><td><code>fem_mesh_matrices</code></td>
<td>
<p>A list containing the mass
lumped mass matrix, the stiffness matrix and
the higher-order FEM-related matrices.</p>
</td></tr>
<tr><td><code>m</code></td>
<td>
<p>The order of the rational approximation.</p>
</td></tr>
<tr><td><code>alpha</code></td>
<td>
<p>The fractional power of the precision operator.</p>
</td></tr>
<tr><td><code>type</code></td>
<td>
<p>String indicating the type of approximation.</p>
</td></tr>
<tr><td><code>d</code></td>
<td>
<p>The dimension of the domain.</p>
</td></tr>
<tr><td><code>nu</code></td>
<td>
<p>Shape parameter of the covariance function.</p>
</td></tr>
<tr><td><code>kappa</code></td>
<td>
<p>Range parameter of the covariance function</p>
</td></tr>
<tr><td><code>tau</code></td>
<td>
<p>Scale parameter of the covariance function.</p>
</td></tr>
<tr><td><code>sigma</code></td>
<td>
<p>Standard deviation of the covariance function.</p>
</td></tr>
<tr><td><code>type</code></td>
<td>
<p>String indicating the type of approximation.</p>
</td></tr>
</table>
<p>If <code>type</code> is &quot;operator&quot;, then <code>matern.operators</code>
returns an object of class &quot;rSPDEobj&quot;. This object contains the
quantities listed in the output of <code><a href="#topic+fractional.operators">fractional.operators()</a></code>,
the <code>G</code> matrix, the dimension of the domain, as well as the
parameters of the covariance function.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+fractional.operators">fractional.operators()</a></code>,
<code><a href="#topic+spde.matern.operators">spde.matern.operators()</a></code>,
<code><a href="#topic+matern.operators">matern.operators()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Compute the covariance-based rational approximation of a
# Gaussian process with a Matern covariance function on R
kappa &lt;- 10
sigma &lt;- 1
nu &lt;- 0.8
range &lt;- sqrt(8*nu)/kappa

# create mass and stiffness matrices for a FEM discretization
nobs &lt;- 101
x &lt;- seq(from = 0, to = 1, length.out = 101)
fem &lt;- rSPDE.fem1d(x)

# compute rational approximation of covariance function at 0.5
op_cov &lt;- matern.operators(
  loc_mesh = x, nu = nu,
  range = range, sigma = sigma, d = 1, m = 2,
  parameterization = "matern"
)

v &lt;- t(rSPDE.A1d(x, 0.5))
# Compute the precision matrix
Q &lt;- op_cov$Q
# A matrix here is the identity matrix
A &lt;- Diagonal(nobs)
# We need to concatenate 3 A's since we are doing a covariance-based rational
# approximation of order 2
Abar &lt;- cbind(A, A, A)
w &lt;- rbind(v, v, v)
# The approximate covariance function:
c_cov.approx &lt;- (Abar) %*% solve(Q, w)
c.true &lt;- folded.matern.covariance.1d(rep(0.5, length(x)),
   abs(x), kappa, nu, sigma)

# plot the result and compare with the true Matern covariance
plot(x, c.true,
  type = "l", ylab = "C(h)",
  xlab = "h", main = "Matern covariance and rational approximations"
)
lines(x, c_cov.approx, col = 2)


# Compute the operator-based rational approximation of a Gaussian
# process with a Matern covariance function on R
kappa &lt;- 10
sigma &lt;- 1
nu &lt;- 0.8
range &lt;- sqrt(8*nu)/kappa

# create mass and stiffness matrices for a FEM discretization
x &lt;- seq(from = 0, to = 1, length.out = 101)
fem &lt;- rSPDE.fem1d(x)

# compute rational approximation of covariance function at 0.5
op &lt;- matern.operators(
  range = range, sigma = sigma, nu = nu,
  loc_mesh = x, d = 1,
  type = "operator",
  parameterization = "matern"
)

v &lt;- t(rSPDE.A1d(x, 0.5))
c.approx &lt;- Sigma.mult(op, v)
c.true &lt;- folded.matern.covariance.1d(rep(0.5, length(x)),
  abs(x), kappa, nu, sigma)

# plot the result and compare with the true Matern covariance
plot(x, c.true,
  type = "l", ylab = "C(h)",
  xlab = "h", main = "Matern covariance and rational approximation"
)
lines(x, c.approx, col = 2)
</code></pre>

<hr>
<h2 id='operator.operations'>Operations with the Pr and Pl operators</h2><span id='topic+operator.operations'></span><span id='topic+Pr.mult'></span><span id='topic+Pr.solve'></span><span id='topic+Pl.mult'></span><span id='topic+Pl.solve'></span><span id='topic+Q.mult'></span><span id='topic+Q.solve'></span><span id='topic+Qsqrt.mult'></span><span id='topic+Qsqrt.solve'></span><span id='topic+Sigma.mult'></span><span id='topic+Sigma.solve'></span>

<h3>Description</h3>

<p>Functions for multiplying and solving with the <code class="reqn">P_r</code>
and <code class="reqn">P_l</code> operators as well as the latent precision
matrix <code class="reqn">Q = P_l C^{-1}P_l</code> and covariance matrix
<code class="reqn">\Sigma = P_r Q^{-1} P_r^T</code>.
These operations are done without first assembling <code class="reqn">P_r</code>,
<code class="reqn">P_l</code> in order to avoid numerical problems caused by
ill-conditioned matrices.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Pr.mult(obj, v, transpose = FALSE)

Pr.solve(obj, v, transpose = FALSE)

Pl.mult(obj, v, transpose = FALSE)

Pl.solve(obj, v, transpose = FALSE)

Q.mult(obj, v)

Q.solve(obj, v)

Qsqrt.mult(obj, v, transpose = FALSE)

Qsqrt.solve(obj, v, transpose = FALSE)

Sigma.mult(obj, v)

Sigma.solve(obj, v)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="operator.operations_+3A_obj">obj</code></td>
<td>
<p>rSPDE object</p>
</td></tr>
<tr><td><code id="operator.operations_+3A_v">v</code></td>
<td>
<p>vector to apply the operation to</p>
</td></tr>
<tr><td><code id="operator.operations_+3A_transpose">transpose</code></td>
<td>
<p>set to TRUE if the operation should be
performed with the transposed object</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>Pl.mult</code>, <code>Pr.mult</code>, and <code>Q.mult</code>
multiplies the vector with the respective object.
Changing <code>mult</code> to <code>solve</code> in the function names
multiplies the vector with the inverse of the object.
<code>Qsqrt.mult</code> and <code>Qsqrt.solve</code> performs the
operations with the square-root type object
<code class="reqn">Q_r = C^{-1/2}P_l</code> defined so that <code class="reqn">Q = Q_r^T Q_r</code>.
</p>


<h3>Value</h3>

<p>A vector with the values of the operation
</p>

<hr>
<h2 id='precision'>Get the precision matrix of CBrSPDEobj objects</h2><span id='topic+precision'></span><span id='topic+precision.CBrSPDEobj'></span>

<h3>Description</h3>

<p>Function to get the precision matrix of a CBrSPDEobj object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>precision(object, ...)

## S3 method for class 'CBrSPDEobj'
precision(
  object,
  user_nu = NULL,
  user_kappa = NULL,
  user_sigma = NULL,
  user_range = NULL,
  user_tau = NULL,
  user_m = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="precision_+3A_object">object</code></td>
<td>
<p>The covariance-based rational SPDE approximation,
computed using <code><a href="#topic+matern.operators">matern.operators()</a></code></p>
</td></tr>
<tr><td><code id="precision_+3A_...">...</code></td>
<td>
<p>Currently not used.</p>
</td></tr>
<tr><td><code id="precision_+3A_user_nu">user_nu</code></td>
<td>
<p>If non-null, update the shape parameter of the
covariance function.</p>
</td></tr>
<tr><td><code id="precision_+3A_user_kappa">user_kappa</code></td>
<td>
<p>If non-null, update the range parameter of
the covariance function.</p>
</td></tr>
<tr><td><code id="precision_+3A_user_sigma">user_sigma</code></td>
<td>
<p>If non-null, update the standard deviation of
the covariance function.</p>
</td></tr>
<tr><td><code id="precision_+3A_user_range">user_range</code></td>
<td>
<p>If non-null, update the range parameter
of the covariance function.</p>
</td></tr>
<tr><td><code id="precision_+3A_user_tau">user_tau</code></td>
<td>
<p>If non-null, update the parameter tau.</p>
</td></tr>
<tr><td><code id="precision_+3A_user_m">user_m</code></td>
<td>
<p>If non-null, update the order of the rational approximation,
which needs to be a positive integer.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The precision matrix.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+simulate.CBrSPDEobj">simulate.CBrSPDEobj()</a></code>, <code><a href="#topic+matern.operators">matern.operators()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Compute the covariance-based rational approximation of a
# Gaussian process with a Matern covariance function on R
kappa &lt;- 10
sigma &lt;- 1
nu &lt;- 0.8
range &lt;- 0.2

# create mass and stiffness matrices for a FEM discretization
x &lt;- seq(from = 0, to = 1, length.out = 101)
fem &lt;- rSPDE.fem1d(x)

# compute rational approximation of covariance function at 0.5
tau &lt;- sqrt(gamma(nu) / (sigma^2 * kappa^(2 * nu) *
(4 * pi)^(1 / 2) * gamma(nu + 1 / 2)))
op_cov &lt;- matern.operators(
  loc_mesh = x, nu = nu,
  range = range, sigma = sigma, d = 1, m = 2,
  parameterization = "matern"
)

# Get the precision matrix:
prec_matrix &lt;- precision(op_cov)

</code></pre>

<hr>
<h2 id='precision.inla_rspde'>Get the precision matrix of <code>inla_rspde</code> objects</h2><span id='topic+precision.inla_rspde'></span>

<h3>Description</h3>

<p>Function to get the precision matrix of an <code>inla_rspde</code> object created with the <code>rspde.matern()</code> function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'inla_rspde'
precision(object, theta = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="precision.inla_rspde_+3A_object">object</code></td>
<td>
<p>The <code>inla_rspde</code> object obtained with the <code>rspde.matern()</code> function.</p>
</td></tr>
<tr><td><code id="precision.inla_rspde_+3A_theta">theta</code></td>
<td>
<p>If null, the starting values for theta will be used. Otherwise, it must be suplied as a vector.
For stationary models, we have <code>theta = c(log(tau), log(kappa), nu)</code>. For nonstationary models, we have
<code>theta = c(theta_1, theta_2, ..., theta_n, nu)</code>.</p>
</td></tr>
<tr><td><code id="precision.inla_rspde_+3A_...">...</code></td>
<td>
<p>Currently not used.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The precision matrix.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+precision.CBrSPDEobj">precision.CBrSPDEobj()</a></code>, <code><a href="#topic+matern.operators">matern.operators()</a></code>
</p>

<hr>
<h2 id='predict.CBrSPDEobj'>Prediction of a fractional SPDE using the covariance-based
rational SPDE approximation</h2><span id='topic+predict.CBrSPDEobj'></span>

<h3>Description</h3>

<p>The function is used for computing kriging predictions based
on data <code class="reqn">Y_i = u(s_i) + \epsilon_i</code>, where <code class="reqn">\epsilon</code>
is mean-zero Gaussian measurement noise and <code class="reqn">u(s)</code> is defined by
a fractional SPDE <code class="reqn">(\kappa^2 I - \Delta)^{\alpha/2} (\tau u(s)) = W</code>,
where <code class="reqn">W</code> is Gaussian white noise and <code class="reqn">\alpha = \nu + d/2</code>,
where <code class="reqn">d</code> is the dimension of the domain.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'CBrSPDEobj'
predict(
  object,
  A,
  Aprd,
  Y,
  sigma.e,
  mu = 0,
  compute.variances = FALSE,
  posterior_samples = FALSE,
  n_samples = 100,
  only_latent = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="predict.CBrSPDEobj_+3A_object">object</code></td>
<td>
<p>The covariance-based rational SPDE approximation,
computed using <code><a href="#topic+matern.operators">matern.operators()</a></code></p>
</td></tr>
<tr><td><code id="predict.CBrSPDEobj_+3A_a">A</code></td>
<td>
<p>A matrix linking the measurement locations to the basis of the FEM
approximation of the latent model.</p>
</td></tr>
<tr><td><code id="predict.CBrSPDEobj_+3A_aprd">Aprd</code></td>
<td>
<p>A matrix linking the prediction locations to the basis of the
FEM approximation of the latent model.</p>
</td></tr>
<tr><td><code id="predict.CBrSPDEobj_+3A_y">Y</code></td>
<td>
<p>A vector with the observed data, can also be a matrix where the
columns are observations
of independent replicates of <code class="reqn">u</code>.</p>
</td></tr>
<tr><td><code id="predict.CBrSPDEobj_+3A_sigma.e">sigma.e</code></td>
<td>
<p>The standard deviation of the Gaussian measurement noise.
Put to zero if the model does not have measurement noise.</p>
</td></tr>
<tr><td><code id="predict.CBrSPDEobj_+3A_mu">mu</code></td>
<td>
<p>Expectation vector of the latent field (default = 0).</p>
</td></tr>
<tr><td><code id="predict.CBrSPDEobj_+3A_compute.variances">compute.variances</code></td>
<td>
<p>Set to also TRUE to compute the kriging variances.</p>
</td></tr>
<tr><td><code id="predict.CBrSPDEobj_+3A_posterior_samples">posterior_samples</code></td>
<td>
<p>If <code>TRUE</code>, posterior samples will be returned.</p>
</td></tr>
<tr><td><code id="predict.CBrSPDEobj_+3A_n_samples">n_samples</code></td>
<td>
<p>Number of samples to be returned. Will only be used if <code>sampling</code> is <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="predict.CBrSPDEobj_+3A_only_latent">only_latent</code></td>
<td>
<p>Should the posterior samples be only given to the laten model?</p>
</td></tr>
<tr><td><code id="predict.CBrSPDEobj_+3A_...">...</code></td>
<td>
<p>further arguments passed to or from other methods.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with elements
</p>
<table>
<tr><td><code>mean</code></td>
<td>
<p>The kriging predictor (the posterior mean of u|Y).</p>
</td></tr>
<tr><td><code>variance</code></td>
<td>
<p>The posterior variances (if computed).</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(123)
# Sample a Gaussian Matern process on R using a rational approximation
kappa &lt;- 10
sigma &lt;- 1
nu &lt;- 0.8
sigma.e &lt;- 0.3
range &lt;- 0.2

# create mass and stiffness matrices for a FEM discretization
x &lt;- seq(from = 0, to = 1, length.out = 101)
fem &lt;- rSPDE.fem1d(x)

tau &lt;- sqrt(gamma(nu) / (sigma^2 * kappa^(2 * nu) *
       (4 * pi)^(1 / 2) * gamma(nu + 1 / 2)))

# Compute the covariance-based rational approximation
op_cov &lt;- matern.operators(
  loc_mesh = x, nu = nu,
  range = range, sigma = sigma, d = 1, m = 2,
  parameterization = "matern"
)

# Sample the model
u &lt;- simulate(op_cov)

# Create some data
obs.loc &lt;- runif(n = 10, min = 0, max = 1)
A &lt;- rSPDE.A1d(x, obs.loc)
Y &lt;- as.vector(A %*% u + sigma.e * rnorm(10))

# compute kriging predictions at the FEM grid
A.krig &lt;- rSPDE.A1d(x, x)
u.krig &lt;- predict(op_cov,
  A = A, Aprd = A.krig, Y = Y, sigma.e = sigma.e,
  compute.variances = TRUE
)

plot(obs.loc, Y,
  ylab = "u(x)", xlab = "x", main = "Data and prediction",
  ylim = c(
    min(u.krig$mean - 2 * sqrt(u.krig$variance)),
    max(u.krig$mean + 2 * sqrt(u.krig$variance))
  )
)
lines(x, u.krig$mean)
lines(x, u.krig$mean + 2 * sqrt(u.krig$variance), col = 2)
lines(x, u.krig$mean - 2 * sqrt(u.krig$variance), col = 2)
</code></pre>

<hr>
<h2 id='predict.rspde_lme'>Prediction of a mixed effects regression model on a metric graph.</h2><span id='topic+predict.rspde_lme'></span>

<h3>Description</h3>

<p>Prediction of a mixed effects regression model on a metric graph.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'rspde_lme'
predict(
  object,
  newdata = NULL,
  loc = NULL,
  mesh = FALSE,
  which_repl = NULL,
  compute_variances = FALSE,
  posterior_samples = FALSE,
  n_samples = 100,
  sample_latent = FALSE,
  edge_number = "edge_number",
  distance_on_edge = "distance_on_edge",
  normalized = FALSE,
  return_as_list = FALSE,
  return_original_order = TRUE,
  ...,
  data = deprecated()
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="predict.rspde_lme_+3A_object">object</code></td>
<td>
<p>The fitted object with the <code>rspde_lme()</code> function</p>
</td></tr>
<tr><td><code id="predict.rspde_lme_+3A_newdata">newdata</code></td>
<td>
<p>A <code>data.frame</code> or a <code>list</code> containing the covariates, the edge number and the distance on edge
for the locations to obtain the prediction.</p>
</td></tr>
<tr><td><code id="predict.rspde_lme_+3A_loc">loc</code></td>
<td>
<p>Prediction locations. Can either be a <code>data.frame</code>, a <code>matrix</code> or a character vector, that contains the names of the columns of the coordinates of the locations. For models using <code>metric_graph</code> objects, plase use <code>edge_number</code> and <code>distance_on_edge</code> instead.</p>
</td></tr>
<tr><td><code id="predict.rspde_lme_+3A_mesh">mesh</code></td>
<td>
<p>Obtain predictions for mesh nodes? The graph must have a mesh, and either <code>only_latent</code> is set to TRUE or the model does not have covariates.</p>
</td></tr>
<tr><td><code id="predict.rspde_lme_+3A_which_repl">which_repl</code></td>
<td>
<p>Which replicates to use? If <code>NULL</code> all replicates will be used.</p>
</td></tr>
<tr><td><code id="predict.rspde_lme_+3A_compute_variances">compute_variances</code></td>
<td>
<p>Set to also TRUE to compute the kriging variances.</p>
</td></tr>
<tr><td><code id="predict.rspde_lme_+3A_posterior_samples">posterior_samples</code></td>
<td>
<p>If <code>TRUE</code>, posterior samples will be returned.</p>
</td></tr>
<tr><td><code id="predict.rspde_lme_+3A_n_samples">n_samples</code></td>
<td>
<p>Number of samples to be returned. Will only be used if <code>sampling</code> is <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="predict.rspde_lme_+3A_sample_latent">sample_latent</code></td>
<td>
<p>Do posterior samples only for the random effects?</p>
</td></tr>
<tr><td><code id="predict.rspde_lme_+3A_edge_number">edge_number</code></td>
<td>
<p>Name of the variable that contains the edge number, the default is <code>edge_number</code>.</p>
</td></tr>
<tr><td><code id="predict.rspde_lme_+3A_distance_on_edge">distance_on_edge</code></td>
<td>
<p>Name of the variable that contains the distance on edge, the default is <code>distance_on_edge</code>.</p>
</td></tr>
<tr><td><code id="predict.rspde_lme_+3A_normalized">normalized</code></td>
<td>
<p>Are the distances on edges normalized?</p>
</td></tr>
<tr><td><code id="predict.rspde_lme_+3A_return_as_list">return_as_list</code></td>
<td>
<p>Should the means of the predictions and the posterior samples be returned as a list, with each replicate being an element?</p>
</td></tr>
<tr><td><code id="predict.rspde_lme_+3A_return_original_order">return_original_order</code></td>
<td>
<p>Should the results be return in the original (input) order or in the order inside the graph?</p>
</td></tr>
<tr><td><code id="predict.rspde_lme_+3A_...">...</code></td>
<td>
<p>Not used.</p>
</td></tr>
<tr><td><code id="predict.rspde_lme_+3A_data">data</code></td>
<td>
<p><a href="https://lifecycle.r-lib.org/articles/stages.html#deprecated"><img src="../help/figures/lifecycle-deprecated.svg" alt='[Deprecated]' /></a> Use <code>newdata</code> instead.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with elements <code>mean</code>, which contains the means of the
predictions, <code>fe_mean</code>, which is the prediction for the fixed effects, <code>re_mean</code>, which is the prediction for the random effects, <code>variance</code> (if <code>compute_variance</code> is <code>TRUE</code>), which contains the
variances of the predictions, <code>samples</code> (if <code>posterior_samples</code> is <code>TRUE</code>),
which contains the posterior samples.
</p>

<hr>
<h2 id='predict.rSPDEobj'>Prediction of a fractional SPDE using a rational SPDE approximation</h2><span id='topic+predict.rSPDEobj'></span>

<h3>Description</h3>

<p>The function is used for computing kriging predictions based on data
<code class="reqn">Y_i = u(s_i) + \epsilon_i</code>,
where <code class="reqn">\epsilon</code> is mean-zero Gaussian measurement noise
and <code class="reqn">u(s)</code> is defined by
a fractional SPDE <code class="reqn">L^\beta u(s) = W</code>, where
<code class="reqn">W</code> is Gaussian white noise.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'rSPDEobj'
predict(
  object,
  A,
  Aprd,
  Y,
  sigma.e,
  compute.variances = FALSE,
  posterior_samples = FALSE,
  n_samples = 100,
  only_latent = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="predict.rSPDEobj_+3A_object">object</code></td>
<td>
<p>The rational SPDE approximation, computed using
<code><a href="#topic+fractional.operators">fractional.operators()</a></code>,
<code><a href="#topic+matern.operators">matern.operators()</a></code>, or <code><a href="#topic+spde.matern.operators">spde.matern.operators()</a></code>.</p>
</td></tr>
<tr><td><code id="predict.rSPDEobj_+3A_a">A</code></td>
<td>
<p>A matrix linking the measurement locations to the basis of the
FEM approximation of the latent model.</p>
</td></tr>
<tr><td><code id="predict.rSPDEobj_+3A_aprd">Aprd</code></td>
<td>
<p>A matrix linking the prediction locations to the basis of the
FEM approximation of the latent model.</p>
</td></tr>
<tr><td><code id="predict.rSPDEobj_+3A_y">Y</code></td>
<td>
<p>A vector with the observed data, can also be a matrix where the
columns are observations
of independent replicates of <code class="reqn">u</code>.</p>
</td></tr>
<tr><td><code id="predict.rSPDEobj_+3A_sigma.e">sigma.e</code></td>
<td>
<p>The standard deviation of the Gaussian measurement noise.
Put to zero if the model
does not have measurement noise.</p>
</td></tr>
<tr><td><code id="predict.rSPDEobj_+3A_compute.variances">compute.variances</code></td>
<td>
<p>Set to also TRUE to compute the kriging variances.</p>
</td></tr>
<tr><td><code id="predict.rSPDEobj_+3A_posterior_samples">posterior_samples</code></td>
<td>
<p>If <code>TRUE</code>, posterior samples will be returned.</p>
</td></tr>
<tr><td><code id="predict.rSPDEobj_+3A_n_samples">n_samples</code></td>
<td>
<p>Number of samples to be returned. Will only be used if <code>sampling</code> is <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="predict.rSPDEobj_+3A_only_latent">only_latent</code></td>
<td>
<p>Should the posterior samples be only given to the latent model?</p>
</td></tr>
<tr><td><code id="predict.rSPDEobj_+3A_...">...</code></td>
<td>
<p>further arguments passed to or from other methods.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with elements
</p>
<table>
<tr><td><code>mean</code></td>
<td>
<p>The kriging predictor (the posterior mean of u|Y).</p>
</td></tr>
<tr><td><code>variance</code></td>
<td>
<p>The posterior variances (if computed).</p>
</td></tr>
<tr><td><code>samples</code></td>
<td>
<p>A matrix containing the samples if <code>sampling</code> is <code>TRUE</code>.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'># Sample a Gaussian Matern process on R using a rational approximation
kappa &lt;- 10
sigma &lt;- 1
nu &lt;- 0.8
sigma.e &lt;- 0.3
range &lt;- sqrt(8*nu)/kappa

# create mass and stiffness matrices for a FEM discretization
x &lt;- seq(from = 0, to = 1, length.out = 101)
fem &lt;- rSPDE.fem1d(x)

# compute rational approximation
op &lt;- matern.operators(
  range = range, sigma = sigma,
  nu = nu, loc_mesh = x, d = 1,
  parameterization = "matern"
)

# Sample the model
u &lt;- simulate(op)

# Create some data
obs.loc &lt;- runif(n = 10, min = 0, max = 1)
A &lt;- rSPDE.A1d(x, obs.loc)
Y &lt;- as.vector(A %*% u + sigma.e * rnorm(10))

# compute kriging predictions at the FEM grid
A.krig &lt;- rSPDE.A1d(x, x)
u.krig &lt;- predict(op,
  A = A, Aprd = A.krig, Y = Y, sigma.e = sigma.e,
  compute.variances = TRUE
)

plot(obs.loc, Y,
  ylab = "u(x)", xlab = "x", main = "Data and prediction",
  ylim = c(
    min(u.krig$mean - 2 * sqrt(u.krig$variance)),
    max(u.krig$mean + 2 * sqrt(u.krig$variance))
  )
)
lines(x, u.krig$mean)
lines(x, u.krig$mean + 2 * sqrt(u.krig$variance), col = 2)
lines(x, u.krig$mean - 2 * sqrt(u.krig$variance), col = 2)
</code></pre>

<hr>
<h2 id='rational.order'>Get the order of rational approximation.</h2><span id='topic+rational.order'></span>

<h3>Description</h3>

<p>Get the order of rational approximation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rational.order(object)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rational.order_+3A_object">object</code></td>
<td>
<p>A <code>CBrSPDEobj</code> object or an <code>inla_rspde</code> object.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The order of rational approximation.
</p>

<hr>
<h2 id='rational.order+26lt+3B-'>Changing the order of the rational approximation</h2><span id='topic+rational.order+3C-'></span>

<h3>Description</h3>

<p>Changing the order of the rational approximation
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rational.order(x) &lt;- value
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rational.order+2B26lt+2B3B-_+3A_x">x</code></td>
<td>
<p>A <code>CBrSPDE</code> or an <code>rpsde.inla</code> object</p>
</td></tr>
<tr><td><code id="rational.order+2B26lt+2B3B-_+3A_value">value</code></td>
<td>
<p>The order of rational approximation.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of the same class with the new order
of rational approximation.
</p>

<hr>
<h2 id='rational.type'>Get type of rational approximation.</h2><span id='topic+rational.type'></span>

<h3>Description</h3>

<p>Get type of rational approximation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rational.type(object)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rational.type_+3A_object">object</code></td>
<td>
<p>A <code>CBrSPDEobj</code> object or an <code>inla_rspde</code> object.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The type of rational approximation.
</p>

<hr>
<h2 id='rational.type+26lt+3B-'>Changing the type of the rational approximation</h2><span id='topic+rational.type+3C-'></span>

<h3>Description</h3>

<p>Changing the type of the rational approximation
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rational.type(x) &lt;- value
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rational.type+2B26lt+2B3B-_+3A_x">x</code></td>
<td>
<p>A <code>CBrSPDE</code> or an <code>rpsde.inla</code> object</p>
</td></tr>
<tr><td><code id="rational.type+2B26lt+2B3B-_+3A_value">value</code></td>
<td>
<p>The type of rational approximation.
The current options are &quot;chebfun&quot;, &quot;brasil&quot; and &quot;chebfunLB&quot;</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of the same class with the new rational approximation.
</p>

<hr>
<h2 id='require.nowarnings'>Warnings free loading of add-on packages</h2><span id='topic+require.nowarnings'></span>

<h3>Description</h3>

<p>Turn off all warnings for require(), to allow clean completion
of examples that require unavailable Suggested packages.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>require.nowarnings(package, lib.loc = NULL, character.only = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="require.nowarnings_+3A_package">package</code></td>
<td>
<p>The name of a package, given as a character string.</p>
</td></tr>
<tr><td><code id="require.nowarnings_+3A_lib.loc">lib.loc</code></td>
<td>
<p>a character vector describing the location of R library trees
to search through, or <code>NULL</code>.  The default value of <code>NULL</code>
corresponds to all libraries currently known to <code>.libPaths()</code>.
Non-existent library trees are silently ignored.</p>
</td></tr>
<tr><td><code id="require.nowarnings_+3A_character.only">character.only</code></td>
<td>
<p>a logical indicating whether <code>package</code> can be
assumed to be a character string.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>require(package)</code> acts the same as
<code>require(package, quietly = TRUE)</code> but with warnings turned off.
In particular, no warning or error is given if the package is unavailable.
Most cases should use <code>requireNamespace(package, quietly = TRUE)</code> instead,
which doesn't produce warnings.
</p>


<h3>Value</h3>

<p><code>require.nowarnings</code> returns (invisibly)
<code>TRUE</code> if it succeeds, otherwise <code>FALSE</code>
</p>


<h3>See Also</h3>

<p><code><a href="base.html#topic+require">require()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## This should produce no output:
if (require.nowarnings(nonexistent)) {
  message("Package loaded successfully")
}

</code></pre>

<hr>
<h2 id='rspde_lme'>rSPDE linear mixed effects models</h2><span id='topic+rspde_lme'></span>

<h3>Description</h3>

<p>Fitting linear mixed effects model with latent Whittle-Matern models.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rspde_lme(
  formula,
  loc,
  data,
  model = NULL,
  repl = NULL,
  which_repl = NULL,
  optim_method = "L-BFGS-B",
  use_data_from_graph = TRUE,
  starting_values_latent = NULL,
  start_sigma_e = NULL,
  start_alpha = NULL,
  alpha = NULL,
  start_nu = NULL,
  nu = NULL,
  nu_upper_bound = 4,
  rspde_order = NULL,
  parallel = FALSE,
  n_cores = parallel::detectCores() - 1,
  optim_controls = list(),
  improve_hessian = FALSE,
  hessian_args = list()
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rspde_lme_+3A_formula">formula</code></td>
<td>
<p>Formula object describing the relation between the response variables and the fixed effects. If the response variable is a matrix, each column of the matrix will be treated as a replicate.</p>
</td></tr>
<tr><td><code id="rspde_lme_+3A_loc">loc</code></td>
<td>
<p>A vector with the names of the columns in <code>data</code> that contain the observation locations, or a <code>matrix</code> or a <code>data.frame</code> containing the observation locations. If the model is of class <code>metric_graph</code>, the locations must be either a <code>matrix</code> or a <code>data.frame</code> with two columns, or a character vector with the names of the two columns. The first column being the number of the edge, and the second column being the normalized position on the edge. If the model is a 2d model, <code>loc</code> must be either a <code>matrix</code> or <code>data.frame</code> with two columns or a character vector with the name of the two columns that contain the location, the first entry corresponding to the <code>x</code> entry and the second corresponding to the <code>y</code> entry.</p>
</td></tr>
<tr><td><code id="rspde_lme_+3A_data">data</code></td>
<td>
<p>A <code>data.frame</code> containing the data to be used.</p>
</td></tr>
<tr><td><code id="rspde_lme_+3A_model">model</code></td>
<td>
<p>Either an object generated by <code>matern.operators()</code> or <code>spde.matern.operators()</code>. If <code>NULL</code>, a simple linear regression will be performed.</p>
</td></tr>
<tr><td><code id="rspde_lme_+3A_repl">repl</code></td>
<td>
<p>Vector indicating the replicate of each observation. If <code>NULL</code> it will assume there is only one replicate.</p>
</td></tr>
<tr><td><code id="rspde_lme_+3A_which_repl">which_repl</code></td>
<td>
<p>Which replicates to use? If <code>NULL</code> all replicates will be used.</p>
</td></tr>
<tr><td><code id="rspde_lme_+3A_optim_method">optim_method</code></td>
<td>
<p>The method to be used with <code>optim</code> function.</p>
</td></tr>
<tr><td><code id="rspde_lme_+3A_use_data_from_graph">use_data_from_graph</code></td>
<td>
<p>Logical. Only for models generated from graphs from <code>metric_graph</code> class. In this case, should the data, the locations and the replicates be obtained from the graph object?</p>
</td></tr>
<tr><td><code id="rspde_lme_+3A_starting_values_latent">starting_values_latent</code></td>
<td>
<p>A vector containing the starting values for the latent model. If the latent model was generated by <code>matern.operators()</code>, then the starting values should be provided as a vector of the form c(tau,kappa). If the model was generated by <code>spde.matern.operators()</code>, then the starting values should be provided as a vector containing the nonstationary parameters.</p>
</td></tr>
<tr><td><code id="rspde_lme_+3A_start_sigma_e">start_sigma_e</code></td>
<td>
<p>Starting value for the standard deviation of the measurament error.</p>
</td></tr>
<tr><td><code id="rspde_lme_+3A_start_alpha">start_alpha</code></td>
<td>
<p>Starting value for the smoothness parameter. Will be used if <code>start_nu</code> is not given.</p>
</td></tr>
<tr><td><code id="rspde_lme_+3A_alpha">alpha</code></td>
<td>
<p>If <code>NULL</code>, the smoothness parameter will be estimated, otherwise the smoothness parameter will be kept fixed at the provided value. Will be used if <code>nu</code> is not given.</p>
</td></tr>
<tr><td><code id="rspde_lme_+3A_start_nu">start_nu</code></td>
<td>
<p>Starting value for the smoothness parameter.</p>
</td></tr>
<tr><td><code id="rspde_lme_+3A_nu">nu</code></td>
<td>
<p>If <code>NULL</code>, the smoothness parameter will be estimated, otherwise the smoothness parameter will be kept fixed at the provided value.</p>
</td></tr>
<tr><td><code id="rspde_lme_+3A_nu_upper_bound">nu_upper_bound</code></td>
<td>
<p>A parameter that limits the maximum value that nu can assume.</p>
</td></tr>
<tr><td><code id="rspde_lme_+3A_rspde_order">rspde_order</code></td>
<td>
<p>The order of the rational approximation to be used while fitting the model. If not given, the order from the model object will be used.</p>
</td></tr>
<tr><td><code id="rspde_lme_+3A_parallel">parallel</code></td>
<td>
<p>logical. Indicating whether to use optimParallel or not.</p>
</td></tr>
<tr><td><code id="rspde_lme_+3A_n_cores">n_cores</code></td>
<td>
<p>Number of cores to be used if parallel is true.</p>
</td></tr>
<tr><td><code id="rspde_lme_+3A_optim_controls">optim_controls</code></td>
<td>
<p>Additional controls to be passed to <code>optim</code> or <code>optimParallel</code>.</p>
</td></tr>
<tr><td><code id="rspde_lme_+3A_improve_hessian">improve_hessian</code></td>
<td>
<p>Should a more precise estimate of the hessian be obtained? Turning on might increase the overall time.</p>
</td></tr>
<tr><td><code id="rspde_lme_+3A_hessian_args">hessian_args</code></td>
<td>
<p>List of controls to be used if <code>improve_hessian</code> is <code>TRUE</code>. The list can contain the arguments to be passed to the <code>method.args</code> argument in the <code>numDeriv::hessian</code> function. See the help of the <code>hessian</code> function in <code>numDeriv</code> package for details. Observe that it only accepts the &quot;Richardson&quot; method for now, the method &quot;complex&quot; is not supported.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list containing the fitted model.
</p>

<hr>
<h2 id='rSPDE.A1d'>Observation matrix for finite element discretization on R</h2><span id='topic+rSPDE.A1d'></span>

<h3>Description</h3>

<p>A finite element discretization on R can be written as
<code class="reqn">u(s) = \sum_i^n u_i \varphi_i(s)</code>
where <code class="reqn">\varphi_i(s)</code> is a piecewise linear
&quot;hat function&quot; centered at location
<code class="reqn">x_i</code>. This function computes an
<code class="reqn">m\times n</code> matrix <code class="reqn">A</code>
that links the basis function in the expansion to specified locations
<code class="reqn">s = (s_1,\ldots, s_m)</code> in the domain through
<code class="reqn">A_ij = \varphi_j(s_i)</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rSPDE.A1d(x, loc)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rSPDE.A1d_+3A_x">x</code></td>
<td>
<p>The locations of the nodes in the FEM discretization.</p>
</td></tr>
<tr><td><code id="rSPDE.A1d_+3A_loc">loc</code></td>
<td>
<p>The locations <code class="reqn">(s_1,\ldots, s_m)</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>The sparse matrix <code>A</code>.
</p>


<h3>Author(s)</h3>

<p>David Bolin <a href="mailto:davidbolin@gmail.com">davidbolin@gmail.com</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+rSPDE.fem1d">rSPDE.fem1d()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># create mass and stiffness matrices for a FEM discretization on [0,1]
x &lt;- seq(from = 0, to = 1, length.out = 101)
fem &lt;- rSPDE.fem1d(x)

# create the observation matrix for some locations in the domain
obs.loc &lt;- runif(n = 10, min = 0, max = 1)
A &lt;- rSPDE.A1d(x, obs.loc)
</code></pre>

<hr>
<h2 id='rSPDE.construct.matern.loglike'>Constructor of Matern loglikelihood functions.</h2><span id='topic+rSPDE.construct.matern.loglike'></span>

<h3>Description</h3>

<p>This function returns a log-likelihood function for a
Gaussian process with a Matern covariance
function, that is observed under Gaussian measurement noise:
<code class="reqn">Y_i = u(s_i) + \epsilon_i</code>, where
<code class="reqn">\epsilon_i</code> are
iid mean-zero Gaussian variables. The latent model is approximated using
the a rational approximation
of the fractional SPDE model corresponding to the Gaussian process.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rSPDE.construct.matern.loglike(
  object,
  Y,
  A,
  sigma.e = NULL,
  mu = 0,
  user_nu = NULL,
  user_tau = NULL,
  user_kappa = NULL,
  user_sigma = NULL,
  user_range = NULL,
  parameterization = c("spde", "matern"),
  user_m = NULL,
  log_scale = TRUE,
  return_negative_likelihood = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rSPDE.construct.matern.loglike_+3A_object">object</code></td>
<td>
<p>The rational SPDE approximation,
computed using <code><a href="#topic+matern.operators">matern.operators()</a></code></p>
</td></tr>
<tr><td><code id="rSPDE.construct.matern.loglike_+3A_y">Y</code></td>
<td>
<p>The observations, either a vector or a matrix where
the columns correspond to independent replicates of observations.</p>
</td></tr>
<tr><td><code id="rSPDE.construct.matern.loglike_+3A_a">A</code></td>
<td>
<p>An observation matrix that links the measurement location to the
finite element basis.</p>
</td></tr>
<tr><td><code id="rSPDE.construct.matern.loglike_+3A_sigma.e">sigma.e</code></td>
<td>
<p>IF non-null, the standard deviation of the measurement noise will be kept fixed in
the returned likelihood.</p>
</td></tr>
<tr><td><code id="rSPDE.construct.matern.loglike_+3A_mu">mu</code></td>
<td>
<p>Expectation vector of the latent field (default = 0).</p>
</td></tr>
<tr><td><code id="rSPDE.construct.matern.loglike_+3A_user_nu">user_nu</code></td>
<td>
<p>If non-null, the shape parameter will be kept fixed in the returned likelihood.</p>
</td></tr>
<tr><td><code id="rSPDE.construct.matern.loglike_+3A_user_tau">user_tau</code></td>
<td>
<p>If non-null, the tau parameter will be kept fixed in the returned likelihood. (Replaces sigma)</p>
</td></tr>
<tr><td><code id="rSPDE.construct.matern.loglike_+3A_user_kappa">user_kappa</code></td>
<td>
<p>If non-null, the range parameter will be kept fixed in the returned likelihood.</p>
</td></tr>
<tr><td><code id="rSPDE.construct.matern.loglike_+3A_user_sigma">user_sigma</code></td>
<td>
<p>If non-null, the standard deviation will be kept fixed in the returned likelihood.</p>
</td></tr>
<tr><td><code id="rSPDE.construct.matern.loglike_+3A_user_range">user_range</code></td>
<td>
<p>If non-null, the range parameter will be kept fixed in the returned likelihood. (Replaces kappa)</p>
</td></tr>
<tr><td><code id="rSPDE.construct.matern.loglike_+3A_parameterization">parameterization</code></td>
<td>
<p>If <code>spde</code>, then one will use the parameters <code>tau</code> and <code>kappa</code>. If <code>matern</code>, then one will use the parameters <code>sigma</code> and <code>range</code>.</p>
</td></tr>
<tr><td><code id="rSPDE.construct.matern.loglike_+3A_user_m">user_m</code></td>
<td>
<p>If non-null, update the order of the rational approximation,
which needs to be a positive integer.</p>
</td></tr>
<tr><td><code id="rSPDE.construct.matern.loglike_+3A_log_scale">log_scale</code></td>
<td>
<p>Should the parameters be evaluated in log-scale?</p>
</td></tr>
<tr><td><code id="rSPDE.construct.matern.loglike_+3A_return_negative_likelihood">return_negative_likelihood</code></td>
<td>
<p>Return minus the likelihood to turn the maximization into a minimization?</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The log-likelihood function. The parameters of the returned function
are given in the order sigma, kappa, nu, sigma.e, whenever they are available.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+matern.operators">matern.operators()</a></code>, <code><a href="#topic+predict.CBrSPDEobj">predict.CBrSPDEobj()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># this example illustrates how the function can be used for maximum
# likelihood estimation

set.seed(123)
# Sample a Gaussian Matern process on R using a rational approximation
nu &lt;- 0.8
sigma &lt;- 1
sigma.e &lt;- 0.1
n.rep &lt;- 10
n.obs &lt;- 200
n.x &lt;- 51
range &lt;- 0.2
# create mass and stiffness matrices for a FEM discretization
x &lt;- seq(from = 0, to = 1, length.out = n.x)
# Compute the covariance-based rational approximation
op_cov &lt;- matern.operators(
  loc_mesh = x, nu = nu,
  range = range, sigma = sigma, d = 1, m = 2,
 parameterization = "matern"
)
# Sample the model
u &lt;- simulate(op_cov, n.rep)
# Create some data
obs.loc &lt;- runif(n = n.obs, min = 0, max = 1)
A &lt;- rSPDE.A1d(x, obs.loc)
noise &lt;- rnorm(n.obs * n.rep)
dim(noise) &lt;- c(n.obs, n.rep)
Y &lt;- as.matrix(A %*% u + sigma.e * noise)

# Define the negative likelihood function for optimization
# using CBrSPDE.matern.loglike
# Matern parameterization
loglike &lt;- rSPDE.construct.matern.loglike(op_cov, Y, A, parameterization = "matern") 

# The parameters can now be estimated by minimizing mlik with optim

# Choose some reasonable starting values depending on the size of the domain
theta0 &lt;- c(get.initial.values.rSPDE(mesh.range = 1, dim = 1), 
                                 log(0.1*sd(as.vector(Y))))
# run estimation and display the results
theta &lt;- optim(theta0, loglike,
  method = "L-BFGS-B"
)
print(data.frame(
  sigma = c(sigma, exp(theta$par[1])), range = c(range, exp(theta$par[2])),
  nu = c(nu, exp(theta$par[3])), sigma.e = c(sigma.e, exp(theta$par[4])),
  row.names = c("Truth", "Estimates")
))


</code></pre>

<hr>
<h2 id='rSPDE.fem1d'>Finite element calculations for problems on R</h2><span id='topic+rSPDE.fem1d'></span>

<h3>Description</h3>

<p>This function computes mass and stiffness matrices
for a FEM approximation on R, assuming
Neumann boundary conditions.
These matrices are needed when discretizing the
operators in rational approximations.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rSPDE.fem1d(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rSPDE.fem1d_+3A_x">x</code></td>
<td>
<p>Locations of the nodes in the FEM approximation.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The function returns a list with the following elements
</p>
<table>
<tr><td><code>G</code></td>
<td>
<p>The stiffness matrix.</p>
</td></tr>
<tr><td><code>C</code></td>
<td>
<p>The mass matrix.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>David Bolin <a href="mailto:davidbolin@gmail.com">davidbolin@gmail.com</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+rSPDE.A1d">rSPDE.A1d()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># create mass and stiffness matrices for a FEM discretization on [0,1]
x &lt;- seq(from = 0, to = 1, length.out = 101)
fem &lt;- rSPDE.fem1d(x)
</code></pre>

<hr>
<h2 id='rSPDE.fem2d'>Finite element calculations for problems in 2D</h2><span id='topic+rSPDE.fem2d'></span>

<h3>Description</h3>

<p>This function computes mass and stiffness matrices for a mesh in 2D, assuming
Neumann boundary conditions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rSPDE.fem2d(FV, P)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rSPDE.fem2d_+3A_fv">FV</code></td>
<td>
<p>Matrix where each row defines a triangle</p>
</td></tr>
<tr><td><code id="rSPDE.fem2d_+3A_p">P</code></td>
<td>
<p>Locations of the nodes in the mesh.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The function returns a list with the following elements
</p>
<table>
<tr><td><code>G</code></td>
<td>
<p>The stiffness matrix with elements <code class="reqn">(\nabla \phi_i, \nabla \phi_j)</code>.</p>
</td></tr>
<tr><td><code>C</code></td>
<td>
<p>The mass matrix with elements <code class="reqn">(\phi_i, \phi_j)</code>.</p>
</td></tr>
<tr><td><code>Cd</code></td>
<td>
<p>The mass lumped matrix with diagonal elements <code class="reqn">(\phi_i, 1)</code>.</p>
</td></tr>
<tr><td><code>Hxx</code></td>
<td>
<p>Matrix with elements <code class="reqn">(\partial_x \phi_i, \partial_x \phi_j)</code>.</p>
</td></tr>
<tr><td><code>Hyy</code></td>
<td>
<p>Matrix with elements <code class="reqn">(\partial_y \phi_i, \partial_y \phi_j)</code>.</p>
</td></tr>
<tr><td><code>Hxy</code></td>
<td>
<p>Matrix with elements <code class="reqn">(\partial_x \phi_i, \partial_y \phi_j)</code>.</p>
</td></tr>
<tr><td><code>Hyx</code></td>
<td>
<p>Matrix with elements <code class="reqn">(\partial_y \phi_i, \partial_x \phi_j)</code>.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>David Bolin <a href="mailto:davidbolin@gmail.com">davidbolin@gmail.com</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+rSPDE.fem1d">rSPDE.fem1d()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>P &lt;- rbind(c(0,0), c(1,0), c(1,1), c(0,1))
FV &lt;- rbind(c(1,2,3), c(2,3,4))
fem &lt;- rSPDE.fem2d(FV,P)
</code></pre>

<hr>
<h2 id='rSPDE.loglike'>Object-based log-likelihood function for latent Gaussian
fractional SPDE model</h2><span id='topic+rSPDE.loglike'></span>

<h3>Description</h3>

<p>This function evaluates the log-likelihood function for a
fractional SPDE model
<code class="reqn">L^\beta u(s) = W</code> that is observed under
Gaussian measurement noise:
<code class="reqn">Y_i = u(s_i) + \epsilon_i</code>,
where <code class="reqn">\epsilon_i</code>
are iid mean-zero Gaussian variables and <code class="reqn">x(s) =
\mu(s) + u(s)</code>, where
<code class="reqn">\mu(s)</code> is the expectation vector of the latent field.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rSPDE.loglike(obj, Y, A, sigma.e, mu = 0)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rSPDE.loglike_+3A_obj">obj</code></td>
<td>
<p>The rational SPDE approximation, computed using
<code><a href="#topic+fractional.operators">fractional.operators()</a></code>,
<code><a href="#topic+matern.operators">matern.operators()</a></code>, or <code><a href="#topic+spde.matern.operators">spde.matern.operators()</a></code>.</p>
</td></tr>
<tr><td><code id="rSPDE.loglike_+3A_y">Y</code></td>
<td>
<p>The observations, either a vector or a matrix where
the columns correspond to independent replicates of observations.</p>
</td></tr>
<tr><td><code id="rSPDE.loglike_+3A_a">A</code></td>
<td>
<p>An observation matrix that links the measurement location
to the finite element basis.</p>
</td></tr>
<tr><td><code id="rSPDE.loglike_+3A_sigma.e">sigma.e</code></td>
<td>
<p>The standard deviation of the measurement noise.</p>
</td></tr>
<tr><td><code id="rSPDE.loglike_+3A_mu">mu</code></td>
<td>
<p>Expectation vector of the latent field (default = 0).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The log-likelihood value.
</p>


<h3>Note</h3>

<p>This example below shows how the function can be used to evaluate
the likelihood of a latent Matern model.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+spde.matern.loglike">spde.matern.loglike()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Sample a Gaussian Matern process on R using a rational approximation
kappa &lt;- 10
sigma &lt;- 1
nu &lt;- 0.8
sigma.e &lt;- 0.3
range &lt;- 0.2

# create mass and stiffness matrices for a FEM discretization
x &lt;- seq(from = 0, to = 1, length.out = 101)
fem &lt;- rSPDE.fem1d(x)

# compute rational approximation
op &lt;- matern.operators(
  range = range, sigma = sigma, nu = nu,
  loc_mesh = x, d = 1,
  type = "operator", parameterization = "matern"
)

# Sample the model
u &lt;- simulate(op)

# Create some data
obs.loc &lt;- runif(n = 10, min = 0, max = 1)
A &lt;- rSPDE.A1d(x, obs.loc)
Y &lt;- as.vector(A %*% u + sigma.e * rnorm(10))

# compute log-likelihood of the data
lik1 &lt;- rSPDE.loglike(op, Y, A, sigma.e)
cat(lik1)
</code></pre>

<hr>
<h2 id='rspde.make.A'>Observation/prediction matrices for rSPDE models.</h2><span id='topic+rspde.make.A'></span>

<h3>Description</h3>

<p>Constructs observation/prediction weight matrices
for rSPDE models based on <code>inla.mesh</code> or
<code>inla.mesh.1d</code> objects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rspde.make.A(
  mesh = NULL,
  loc = NULL,
  A = NULL,
  dim = NULL,
  rspde.order = 2,
  nu = NULL,
  index = NULL,
  group = NULL,
  repl = 1L,
  n.group = NULL,
  n.repl = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rspde.make.A_+3A_mesh">mesh</code></td>
<td>
<p>An <code>inla.mesh</code>,
an <code>inla.mesh.1d</code> object or a <code>metric_graph</code> object.</p>
</td></tr>
<tr><td><code id="rspde.make.A_+3A_loc">loc</code></td>
<td>
<p>Locations, needed if an INLA mesh is provided</p>
</td></tr>
<tr><td><code id="rspde.make.A_+3A_a">A</code></td>
<td>
<p>The A matrix from the standard SPDE approach, such as the matrix
returned by <code>inla.spde.make.A</code>. Should only be provided if
<code>mesh</code> is not provided.</p>
</td></tr>
<tr><td><code id="rspde.make.A_+3A_dim">dim</code></td>
<td>
<p>the dimension. Should only be provided if an
<code>mesh</code> is not provided.</p>
</td></tr>
<tr><td><code id="rspde.make.A_+3A_rspde.order">rspde.order</code></td>
<td>
<p>The order of the covariance-based rational SPDE approach.</p>
</td></tr>
<tr><td><code id="rspde.make.A_+3A_nu">nu</code></td>
<td>
<p>If <code>NULL</code>, then the model will assume that nu will
be estimated. If nu is fixed, you should provide the value of nu.</p>
</td></tr>
<tr><td><code id="rspde.make.A_+3A_index">index</code></td>
<td>
<p>For each observation/prediction value, an index into loc. Default is seq_len(nrow(A.loc)).</p>
</td></tr>
<tr><td><code id="rspde.make.A_+3A_group">group</code></td>
<td>
<p>For each observation/prediction value, an index into
the group model.</p>
</td></tr>
<tr><td><code id="rspde.make.A_+3A_repl">repl</code></td>
<td>
<p>For each observation/prediction value, the replicate index.</p>
</td></tr>
<tr><td><code id="rspde.make.A_+3A_n.group">n.group</code></td>
<td>
<p>The size of the group model.</p>
</td></tr>
<tr><td><code id="rspde.make.A_+3A_n.repl">n.repl</code></td>
<td>
<p>The total number of replicates.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The <code class="reqn">A</code> matrix for rSPDE models.
</p>


<h3>Examples</h3>

<pre><code class='language-R'> #tryCatch version
tryCatch({
if (requireNamespace("INLA", quietly = TRUE)){
library(INLA)

set.seed(123)
loc &lt;- matrix(runif(100 * 2) * 100, 100, 2)
mesh &lt;- inla.mesh.2d(
  loc = loc,
  cutoff = 50,
  max.edge = c(50, 500)
)
A &lt;- rspde.make.A(mesh, loc = loc, rspde.order = 3)
}
#stable.tryCatch
}, error = function(e){print("Could not run the example")})

</code></pre>

<hr>
<h2 id='rspde.make.index'>rSPDE model index vector generation</h2><span id='topic+rspde.make.index'></span>

<h3>Description</h3>

<p>Generates a list of named index vectors for an rSPDE model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rspde.make.index(
  name,
  n.spde = NULL,
  n.group = 1,
  n.repl = 1,
  mesh = NULL,
  rspde.order = 2,
  nu = NULL,
  dim = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rspde.make.index_+3A_name">name</code></td>
<td>
<p>A character string with the base name of the effect.</p>
</td></tr>
<tr><td><code id="rspde.make.index_+3A_n.spde">n.spde</code></td>
<td>
<p>The number of basis functions in the mesh model.</p>
</td></tr>
<tr><td><code id="rspde.make.index_+3A_n.group">n.group</code></td>
<td>
<p>The size of the group model.</p>
</td></tr>
<tr><td><code id="rspde.make.index_+3A_n.repl">n.repl</code></td>
<td>
<p>The total number of replicates.</p>
</td></tr>
<tr><td><code id="rspde.make.index_+3A_mesh">mesh</code></td>
<td>
<p>An <code>inla.mesh</code>,
an <code>inla.mesh.1d</code> object or a <code>metric_graph</code> object.</p>
</td></tr>
<tr><td><code id="rspde.make.index_+3A_rspde.order">rspde.order</code></td>
<td>
<p>The order of the rational approximation</p>
</td></tr>
<tr><td><code id="rspde.make.index_+3A_nu">nu</code></td>
<td>
<p>If <code>NULL</code>, then the model will assume that nu will
be estimated. If nu is fixed, you should provide the value of nu.</p>
</td></tr>
<tr><td><code id="rspde.make.index_+3A_dim">dim</code></td>
<td>
<p>the dimension of the domain. Should only be provided if
<code>mesh</code> is not provided.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of named index vectors.
</p>
<table>
<tr><td><code>name</code></td>
<td>
<p>Indices into the vector of latent variables</p>
</td></tr>
<tr><td><code>name.group</code></td>
<td>
<p>'group' indices</p>
</td></tr>
<tr><td><code>name.repl</code></td>
<td>
<p>Indices for replicates</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'> #tryCatch version
tryCatch({
if (requireNamespace("INLA", quietly = TRUE)){
library(INLA)

set.seed(123)

m &lt;- 100
loc_2d_mesh &lt;- matrix(runif(m * 2), m, 2)
mesh_2d &lt;- inla.mesh.2d(
  loc = loc_2d_mesh,
  cutoff = 0.05,
  max.edge = c(0.1, 0.5)
)
sigma &lt;- 1
range &lt;- 0.2
nu &lt;- 0.8
kappa &lt;- sqrt(8 * nu) / range
op &lt;- matern.operators(
  mesh = mesh_2d, nu = nu,
  range = range, sigma = sigma, m = 2,
  parameterization = "matern"
)
u &lt;- simulate(op)
A &lt;- inla.spde.make.A(
  mesh = mesh_2d,
  loc = loc_2d_mesh
)
sigma.e &lt;- 0.1
y &lt;- A %*% u + rnorm(m) * sigma.e
Abar &lt;- rspde.make.A(mesh = mesh_2d, loc = loc_2d_mesh)
mesh.index &lt;- rspde.make.index(name = "field", mesh = mesh_2d)
st.dat &lt;- inla.stack(
  data = list(y = as.vector(y)),
  A = Abar,
  effects = mesh.index
)
rspde_model &lt;- rspde.matern(
  mesh = mesh_2d,
  nu.upper.bound = 2
)
f &lt;- y ~ -1 + f(field, model = rspde_model)
rspde_fit &lt;- inla(f,
  data = inla.stack.data(st.dat),
  family = "gaussian",
  control.predictor =
    list(A = inla.stack.A(st.dat))
)
result &lt;- rspde.result(rspde_fit, "field", rspde_model)
summary(result)
}
#stable.tryCatch
}, error = function(e){print("Could not run the example")})

</code></pre>

<hr>
<h2 id='rspde.matern'>Matern rSPDE model object for INLA</h2><span id='topic+rspde.matern'></span>

<h3>Description</h3>

<p>Creates an INLA object for a stationary Matern model with
general smoothness parameter.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rspde.matern(
  mesh,
  nu.upper.bound = 4,
  rspde.order = 2,
  nu = NULL,
  B.sigma = matrix(c(0, 1, 0), 1, 3),
  B.range = matrix(c(0, 0, 1), 1, 3),
  parameterization = c("spde", "matern", "matern2"),
  B.tau = matrix(c(0, 1, 0), 1, 3),
  B.kappa = matrix(c(0, 0, 1), 1, 3),
  start.nu = NULL,
  start.theta = NULL,
  prior.nu = NULL,
  theta.prior.mean = NULL,
  theta.prior.prec = 0.1,
  prior.std.dev.nominal = 1,
  prior.range.nominal = NULL,
  prior.kappa.mean = NULL,
  prior.tau.mean = NULL,
  start.lstd.dev = NULL,
  start.lrange = NULL,
  start.ltau = NULL,
  start.lkappa = NULL,
  prior.theta.param = c("theta", "spde"),
  prior.nu.dist = c("beta", "lognormal"),
  nu.prec.inc = 1,
  type.rational.approx = c("chebfun", "brasil", "chebfunLB"),
  debug = FALSE,
  shared_lib = "detect",
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rspde.matern_+3A_mesh">mesh</code></td>
<td>
<p>The mesh to build the model. It can be an <code>inla.mesh</code> or
an <code>inla.mesh.1d</code> object. Otherwise, should be a list containing elements d, the dimension, C, the mass matrix,
and G, the stiffness matrix.</p>
</td></tr>
<tr><td><code id="rspde.matern_+3A_nu.upper.bound">nu.upper.bound</code></td>
<td>
<p>Upper bound for the smoothness parameter.</p>
</td></tr>
<tr><td><code id="rspde.matern_+3A_rspde.order">rspde.order</code></td>
<td>
<p>The order of the covariance-based rational SPDE approach.</p>
</td></tr>
<tr><td><code id="rspde.matern_+3A_nu">nu</code></td>
<td>
<p>If nu is set to a parameter, nu will be kept fixed and will not
be estimated. If nu is <code>NULL</code>, it will be estimated.</p>
</td></tr>
<tr><td><code id="rspde.matern_+3A_b.sigma">B.sigma</code></td>
<td>
<p>Matrix with specification of log-linear model for <code class="reqn">\sigma</code> (for 'matern' parameterization) or for <code class="reqn">\sigma^2</code> (for 'matern2' parameterization). Will be used if <code>parameterization = 'matern'</code> or <code>parameterization = 'matern2'</code>.</p>
</td></tr>
<tr><td><code id="rspde.matern_+3A_b.range">B.range</code></td>
<td>
<p>Matrix with specification of log-linear model for <code class="reqn">\rho</code>, which is a range-like parameter (it is exactly the range parameter in the stationary case). Will be used if <code>parameterization = 'matern'</code> or <code>parameterization = 'matern2'</code>.</p>
</td></tr>
<tr><td><code id="rspde.matern_+3A_parameterization">parameterization</code></td>
<td>
<p>Which parameterization to use? <code>matern</code> uses range, std. deviation and nu (smoothness). <code>spde</code> uses kappa, tau and nu (smoothness). <code>matern2</code> uses range-like (1/kappa), variance and nu (smoothness). The default is <code>spde</code>.</p>
</td></tr>
<tr><td><code id="rspde.matern_+3A_b.tau">B.tau</code></td>
<td>
<p>Matrix with specification of log-linear model for <code class="reqn">\tau</code>. Will be used if <code>parameterization = 'spde'</code>.</p>
</td></tr>
<tr><td><code id="rspde.matern_+3A_b.kappa">B.kappa</code></td>
<td>
<p>Matrix with specification of log-linear model for <code class="reqn">\kappa</code>. Will be used if <code>parameterization = 'spde'</code>.</p>
</td></tr>
<tr><td><code id="rspde.matern_+3A_start.nu">start.nu</code></td>
<td>
<p>Starting value for nu.</p>
</td></tr>
<tr><td><code id="rspde.matern_+3A_start.theta">start.theta</code></td>
<td>
<p>Starting values for the model parameters. In the stationary case, if <code>parameterization='matern'</code>, then <code>theta[1]</code> is the std.dev and <code>theta[2]</code> is the range parameter.
If <code>parameterization = 'spde'</code>, then <code>theta[1]</code> is <code>tau</code> and <code>theta[2]</code> is <code>kappa</code>.</p>
</td></tr>
<tr><td><code id="rspde.matern_+3A_prior.nu">prior.nu</code></td>
<td>
<p>a list containing the elements <code>mean</code> and <code>prec</code>
for beta distribution, or <code>loglocation</code> and <code>logscale</code> for a
truncated lognormal distribution. <code>loglocation</code> stands for
the location parameter of the truncated lognormal distribution in the log
scale. <code>prec</code> stands for the precision of a beta distribution.
<code>logscale</code> stands for the scale of the truncated lognormal
distribution on the log scale. Check details below.</p>
</td></tr>
<tr><td><code id="rspde.matern_+3A_theta.prior.mean">theta.prior.mean</code></td>
<td>
<p>A vector for the mean priors of <code>theta</code>.</p>
</td></tr>
<tr><td><code id="rspde.matern_+3A_theta.prior.prec">theta.prior.prec</code></td>
<td>
<p>A precision matrix for the prior of <code>theta</code>.</p>
</td></tr>
<tr><td><code id="rspde.matern_+3A_prior.std.dev.nominal">prior.std.dev.nominal</code></td>
<td>
<p>Prior std. deviation to be used for the priors and for the starting values.</p>
</td></tr>
<tr><td><code id="rspde.matern_+3A_prior.range.nominal">prior.range.nominal</code></td>
<td>
<p>Prior range to be used for the priors and for the starting values.</p>
</td></tr>
<tr><td><code id="rspde.matern_+3A_prior.kappa.mean">prior.kappa.mean</code></td>
<td>
<p>Prior kappa to be used for the priors and for the starting values.</p>
</td></tr>
<tr><td><code id="rspde.matern_+3A_prior.tau.mean">prior.tau.mean</code></td>
<td>
<p>Prior tau to be used for the priors and for the starting values.</p>
</td></tr>
<tr><td><code id="rspde.matern_+3A_start.lstd.dev">start.lstd.dev</code></td>
<td>
<p>Starting value for log of std. deviation. Will not be used if start.ltau is non-null. Will be only used in the stationary case and if <code>parameterization = 'matern'</code>.</p>
</td></tr>
<tr><td><code id="rspde.matern_+3A_start.lrange">start.lrange</code></td>
<td>
<p>Starting value for log of range. Will not be used if start.lkappa is non-null. Will be only used in the stationary case and if <code>parameterization = 'matern'</code>.</p>
</td></tr>
<tr><td><code id="rspde.matern_+3A_start.ltau">start.ltau</code></td>
<td>
<p>Starting value for log of tau. Will be only used in the stationary case and if <code>parameterization = 'spde'</code>.</p>
</td></tr>
<tr><td><code id="rspde.matern_+3A_start.lkappa">start.lkappa</code></td>
<td>
<p>Starting value for log of kappa. Will be only used in the stationary case and if <code>parameterization = 'spde'</code>.</p>
</td></tr>
<tr><td><code id="rspde.matern_+3A_prior.theta.param">prior.theta.param</code></td>
<td>
<p>Should the lognormal prior be on <code>theta</code> or on the SPDE parameters (<code>tau</code> and <code>kappa</code> on the stationary case)?</p>
</td></tr>
<tr><td><code id="rspde.matern_+3A_prior.nu.dist">prior.nu.dist</code></td>
<td>
<p>The distribution of the smoothness parameter.
The current options are &quot;beta&quot; or &quot;lognormal&quot;. The default is &quot;lognormal&quot;.</p>
</td></tr>
<tr><td><code id="rspde.matern_+3A_nu.prec.inc">nu.prec.inc</code></td>
<td>
<p>Amount to increase the precision in the beta prior
distribution. Check details below.</p>
</td></tr>
<tr><td><code id="rspde.matern_+3A_type.rational.approx">type.rational.approx</code></td>
<td>
<p>Which type of rational approximation
should be used? The current types are &quot;chebfun&quot;, &quot;brasil&quot; or &quot;chebfunLB&quot;.</p>
</td></tr>
<tr><td><code id="rspde.matern_+3A_debug">debug</code></td>
<td>
<p>INLA debug argument</p>
</td></tr>
<tr><td><code id="rspde.matern_+3A_shared_lib">shared_lib</code></td>
<td>
<p>Which shared lib to use for the cgeneric implementation?
If &quot;detect&quot;, it will check if the shared lib exists locally, in which case it will
use it. Otherwise it will use INLA's shared library.
If &quot;INLA&quot;, it will use the shared lib from INLA's installation. If 'rSPDE', then
it will use the local installation (does not work if your installation is from CRAN).
Otherwise, you can directly supply the path of the .so (or .dll) file.</p>
</td></tr>
<tr><td><code id="rspde.matern_+3A_...">...</code></td>
<td>
<p>Only being used internally.</p>
</td></tr>
<tr><td><code id="rspde.matern_+3A_prior.kappa">prior.kappa</code></td>
<td>
<p>a <code>list</code> containing the elements <code>meanlog</code> and
<code>sdlog</code>, that is, the mean and standard deviation on the log scale.</p>
</td></tr>
<tr><td><code id="rspde.matern_+3A_prior.tau">prior.tau</code></td>
<td>
<p>a list containing the elements <code>meanlog</code> and
<code>sdlog</code>, that is, the mean and standard deviation on the log scale.</p>
</td></tr>
<tr><td><code id="rspde.matern_+3A_prior.range">prior.range</code></td>
<td>
<p>a <code>list</code> containing the elements <code>meanlog</code> and
<code>sdlog</code>, that is, the mean and standard deviation on the log scale. Will not be used if prior.kappa is non-null.</p>
</td></tr>
<tr><td><code id="rspde.matern_+3A_prior.std.dev">prior.std.dev</code></td>
<td>
<p>a <code>list</code> containing the elements <code>meanlog</code> and
<code>sdlog</code>, that is, the mean and standard deviation on the log scale. Will not be used if prior.tau is non-null.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An INLA model.
</p>

<hr>
<h2 id='rSPDE.matern.loglike'>Object-based log-likelihood function for latent Gaussian fractional
SPDE model using the rational approximations</h2><span id='topic+rSPDE.matern.loglike'></span>

<h3>Description</h3>

<p>This function evaluates the log-likelihood function for a
Gaussian process with a Matern covariance
function, that is observed under Gaussian measurement noise:
<code class="reqn">Y_i = u(s_i) + \epsilon_i</code>, where
<code class="reqn">\epsilon_i</code> are
iid mean-zero Gaussian variables. The latent model is approximated using
the a rational approximation
of the fractional SPDE model corresponding to the Gaussian process.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rSPDE.matern.loglike(
  object,
  Y,
  A,
  sigma.e,
  mu = 0,
  user_nu = NULL,
  user_kappa = NULL,
  user_sigma = NULL,
  user_range = NULL,
  user_tau = NULL,
  user_m = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rSPDE.matern.loglike_+3A_object">object</code></td>
<td>
<p>The rational SPDE approximation,
computed using <code><a href="#topic+matern.operators">matern.operators()</a></code></p>
</td></tr>
<tr><td><code id="rSPDE.matern.loglike_+3A_y">Y</code></td>
<td>
<p>The observations, either a vector or a matrix where
the columns correspond to independent replicates of observations.</p>
</td></tr>
<tr><td><code id="rSPDE.matern.loglike_+3A_a">A</code></td>
<td>
<p>An observation matrix that links the measurement location to the
finite element basis.</p>
</td></tr>
<tr><td><code id="rSPDE.matern.loglike_+3A_sigma.e">sigma.e</code></td>
<td>
<p>The standard deviation of the measurement noise.</p>
</td></tr>
<tr><td><code id="rSPDE.matern.loglike_+3A_mu">mu</code></td>
<td>
<p>Expectation vector of the latent field (default = 0).</p>
</td></tr>
<tr><td><code id="rSPDE.matern.loglike_+3A_user_nu">user_nu</code></td>
<td>
<p>If non-null, update the shape parameter of the covariance
function.</p>
</td></tr>
<tr><td><code id="rSPDE.matern.loglike_+3A_user_kappa">user_kappa</code></td>
<td>
<p>If non-null, update the range parameter of the covariance
function.</p>
</td></tr>
<tr><td><code id="rSPDE.matern.loglike_+3A_user_sigma">user_sigma</code></td>
<td>
<p>If non-null, update the standard deviation of
the covariance function.</p>
</td></tr>
<tr><td><code id="rSPDE.matern.loglike_+3A_user_range">user_range</code></td>
<td>
<p>If non-null, update the range parameter
of the covariance function.</p>
</td></tr>
<tr><td><code id="rSPDE.matern.loglike_+3A_user_tau">user_tau</code></td>
<td>
<p>If non-null, update the parameter tau.</p>
</td></tr>
<tr><td><code id="rSPDE.matern.loglike_+3A_user_m">user_m</code></td>
<td>
<p>If non-null, update the order of the rational approximation,
which needs to be a positive integer.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The log-likelihood value.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+matern.operators">matern.operators()</a></code>, <code><a href="#topic+predict.CBrSPDEobj">predict.CBrSPDEobj()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># this example illustrates how the function can be used for maximum
# likelihood estimation

set.seed(123)
# Sample a Gaussian Matern process on R using a rational approximation
nu &lt;- 0.8
kappa &lt;- 5
sigma &lt;- 1
sigma.e &lt;- 0.1
n.rep &lt;- 10
n.obs &lt;- 100
n.x &lt;- 51
range &lt;- 0.2

# create mass and stiffness matrices for a FEM discretization
x &lt;- seq(from = 0, to = 1, length.out = n.x)
fem &lt;- rSPDE.fem1d(x)

tau &lt;- sqrt(gamma(nu) / (sigma^2 * kappa^(2 * nu) *
(4 * pi)^(1 / 2) * gamma(nu + 1 / 2)))

# Compute the covariance-based rational approximation
op_cov &lt;- matern.operators(
  loc_mesh = x, nu = nu,
  range = range, sigma = sigma, d = 1, m = 2,
 parameterization = "matern"
)

# Sample the model
u &lt;- simulate(op_cov, n.rep)

# Create some data
obs.loc &lt;- runif(n = n.obs, min = 0, max = 1)
A &lt;- rSPDE.A1d(x, obs.loc)
noise &lt;- rnorm(n.obs * n.rep)
dim(noise) &lt;- c(n.obs, n.rep)
Y &lt;- as.matrix(A %*% u + sigma.e * noise)

# Define the negative likelihood function for optimization
# using CBrSPDE.matern.loglike

# Notice that we are also using sigma instead of tau, so it can be compared
# to matern.loglike()
mlik_cov &lt;- function(theta, Y, A, op_cov) {
  kappa &lt;- exp(theta[1])
  sigma &lt;- exp(theta[2])
  nu &lt;- exp(theta[3])
  return(-rSPDE.matern.loglike(
    object = op_cov, Y = Y,
    A = A, user_kappa = kappa, user_sigma = sigma,
    user_nu = nu, sigma.e = exp(theta[4])
  ))
}

# The parameters can now be estimated by minimizing mlik with optim

# Choose some reasonable starting values depending on the size of the domain
theta0 &lt;- log(c(sqrt(8), 1 / sqrt(var(c(Y))), 0.9, 0.01))

# run estimation and display the results
theta &lt;- optim(theta0, mlik_cov,
  Y = Y, A = A, op_cov = op_cov,
  method = "L-BFGS-B"
)

print(data.frame(
  range = c(range, exp(theta$par[1])), sigma = c(sigma, exp(theta$par[2])),
  nu = c(nu, exp(theta$par[3])), sigma.e = c(sigma.e, exp(theta$par[4])),
  row.names = c("Truth", "Estimates")
))


</code></pre>

<hr>
<h2 id='rspde.matern.precision'>Precision matrix of the covariance-based rational approximation of
stationary Gaussian Matern random fields</h2><span id='topic+rspde.matern.precision'></span>

<h3>Description</h3>

<p><code>rspde.matern.precision</code> is used for computing the
precision matrix of the
covariance-based rational SPDE approximation of a stationary Gaussian random
fields on <code class="reqn">R^d</code> with a Matern covariance function
</p>
<p style="text-align: center;"><code class="reqn">C(h) = \frac{\sigma^2}{2^(\nu-1)\Gamma(\nu)}(\kappa h)^\nu
K_\nu(\kappa h)</code>
</p>



<h3>Usage</h3>

<pre><code class='language-R'>rspde.matern.precision(
  kappa,
  nu,
  tau = NULL,
  sigma = NULL,
  rspde.order,
  dim,
  fem_mesh_matrices,
  only_fractional = FALSE,
  return_block_list = FALSE,
  type_rational_approx = "chebfun"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rspde.matern.precision_+3A_kappa">kappa</code></td>
<td>
<p>Range parameter of the covariance function.</p>
</td></tr>
<tr><td><code id="rspde.matern.precision_+3A_nu">nu</code></td>
<td>
<p>Shape parameter of the covariance function.</p>
</td></tr>
<tr><td><code id="rspde.matern.precision_+3A_tau">tau</code></td>
<td>
<p>Scale parameter of the covariance function. If sigma is
not provided, tau should be provided.</p>
</td></tr>
<tr><td><code id="rspde.matern.precision_+3A_sigma">sigma</code></td>
<td>
<p>Standard deviation of the covariance function. If tau is
not provided, sigma should be provided.</p>
</td></tr>
<tr><td><code id="rspde.matern.precision_+3A_rspde.order">rspde.order</code></td>
<td>
<p>The order of the rational approximation</p>
</td></tr>
<tr><td><code id="rspde.matern.precision_+3A_dim">dim</code></td>
<td>
<p>The dimension of the domain</p>
</td></tr>
<tr><td><code id="rspde.matern.precision_+3A_fem_mesh_matrices">fem_mesh_matrices</code></td>
<td>
<p>A list containing the FEM-related matrices. The
list should contain elements c0, g1, g2, g3, etc.</p>
</td></tr>
<tr><td><code id="rspde.matern.precision_+3A_only_fractional">only_fractional</code></td>
<td>
<p>Logical. Should only the fractional-order part of
the precision matrix be returned?</p>
</td></tr>
<tr><td><code id="rspde.matern.precision_+3A_return_block_list">return_block_list</code></td>
<td>
<p>Logical. For <code>type = "covariance"</code>, should the
block parts of the precision matrix be returned separately as a list?</p>
</td></tr>
<tr><td><code id="rspde.matern.precision_+3A_type_rational_approx">type_rational_approx</code></td>
<td>
<p>Which type of rational approximation should be
used? The current types are &quot;chebfun&quot;, &quot;brasil&quot; or &quot;chebfunLB&quot;.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The precision matrix
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(123)
nobs &lt;- 101
x &lt;- seq(from = 0, to = 1, length.out = nobs)
fem &lt;- rSPDE.fem1d(x)
kappa &lt;- 40
sigma &lt;- 1
d &lt;- 1
nu &lt;- 2.6
tau &lt;- sqrt(gamma(nu) / (kappa^(2 * nu) * (4 * pi)^(d / 2) *
gamma(nu + d / 2)))
range &lt;- sqrt(8*nu)/kappa
op_cov &lt;- matern.operators(
  loc_mesh = x, nu = nu, range = range, sigma = sigma,
  d = 1, m = 2, compute_higher_order = TRUE,
  parameterization = "matern"
)
v &lt;- t(rSPDE.A1d(x, 0.5))
c.true &lt;- matern.covariance(abs(x - 0.5), kappa, nu, sigma)
Q &lt;- rspde.matern.precision(
  kappa = kappa, nu = nu, tau = tau, rspde.order = 2, d = 1,
  fem_mesh_matrices = op_cov$fem_mesh_matrices
)
A &lt;- Diagonal(nobs)
Abar &lt;- cbind(A, A, A)
w &lt;- rbind(v, v, v)
c.approx_cov &lt;- (Abar) %*% solve(Q, w)

# plot the result and compare with the true Matern covariance
plot(x, matern.covariance(abs(x - 0.5), kappa, nu, sigma),
  type = "l", ylab = "C(h)",
  xlab = "h", main = "Matern covariance and rational approximations"
)
lines(x, c.approx_cov, col = 2)
</code></pre>

<hr>
<h2 id='rspde.matern.precision.integer'>Precision matrix of stationary Gaussian Matern
random fields with integer covariance exponent</h2><span id='topic+rspde.matern.precision.integer'></span>

<h3>Description</h3>

<p><code>rspde.matern.precision.integer.opt</code> is
used for computing the precision matrix of stationary
Gaussian random fields on <code class="reqn">R^d</code> with a Matern
covariance function
</p>
<p style="text-align: center;"><code class="reqn">C(h) = \frac{\sigma^2}{2^(\nu-1)\Gamma(\nu)}
(\kappa h)^\nu K_\nu(\kappa h)</code>
</p>
<p>,
where <code class="reqn">\alpha = \nu + d/2</code> is a natural number.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rspde.matern.precision.integer(
  kappa,
  nu,
  tau = NULL,
  sigma = NULL,
  dim,
  fem_mesh_matrices
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rspde.matern.precision.integer_+3A_kappa">kappa</code></td>
<td>
<p>Range parameter of the covariance function.</p>
</td></tr>
<tr><td><code id="rspde.matern.precision.integer_+3A_nu">nu</code></td>
<td>
<p>Shape parameter of the covariance function.</p>
</td></tr>
<tr><td><code id="rspde.matern.precision.integer_+3A_tau">tau</code></td>
<td>
<p>Scale parameter of the covariance function.</p>
</td></tr>
<tr><td><code id="rspde.matern.precision.integer_+3A_sigma">sigma</code></td>
<td>
<p>Standard deviation of the covariance function.
If tau is not provided, sigma should be provided.</p>
</td></tr>
<tr><td><code id="rspde.matern.precision.integer_+3A_dim">dim</code></td>
<td>
<p>The dimension of the domain</p>
</td></tr>
<tr><td><code id="rspde.matern.precision.integer_+3A_fem_mesh_matrices">fem_mesh_matrices</code></td>
<td>
<p>A list containing the FEM-related
matrices. The list should contain elements c0, g1, g2, g3, etc.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The precision matrix
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(123)
nobs &lt;- 101
x &lt;- seq(from = 0, to = 1, length.out = nobs)
fem &lt;- rSPDE.fem1d(x)
kappa &lt;- 40
sigma &lt;- 1
d &lt;- 1
nu &lt;- 0.5
tau &lt;- sqrt(gamma(nu) / (kappa^(2 * nu) *
(4 * pi)^(d / 2) * gamma(nu + d / 2)))
range &lt;- sqrt(8*nu)/kappa
op_cov &lt;- matern.operators(
  loc_mesh = x, nu = nu, range = range, sigma = sigma,
  d = 1, m = 2, parameterization = "matern"
)
v &lt;- t(rSPDE.A1d(x, 0.5))
c.true &lt;- matern.covariance(abs(x - 0.5), kappa, nu, sigma)
Q &lt;- rspde.matern.precision.integer(
  kappa = kappa, nu = nu, tau = tau, d = 1,
  fem_mesh_matrices = op_cov$fem_mesh_matrices
)
A &lt;- Diagonal(nobs)
c.approx_cov &lt;- A %*% solve(Q, v)

# plot the result and compare with the true Matern covariance
plot(x, matern.covariance(abs(x - 0.5), kappa, nu, sigma),
  type = "l", ylab = "C(h)",
  xlab = "h", main = "Matern covariance and rational approximations"
)
lines(x, c.approx_cov, col = 2)
</code></pre>

<hr>
<h2 id='rspde.matern.precision.integer.opt'>Optimized precision matrix of stationary Gaussian Matern
random fields with integer covariance exponent</h2><span id='topic+rspde.matern.precision.integer.opt'></span>

<h3>Description</h3>

<p><code>rspde.matern.precision.integer.opt</code> is used
for computing the optimized version of the precision matrix of
stationary Gaussian random fields on <code class="reqn">R^d</code> with a Matern
covariance function
</p>
<p style="text-align: center;"><code class="reqn">C(h) = \frac{\sigma^2}{2^{\nu-1}\Gamma(\nu)}(\kappa h)^\nu
K_\nu(\kappa h),</code>
</p>

<p>where <code class="reqn">\alpha = \nu + d/2</code> is a natural number.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rspde.matern.precision.integer.opt(
  kappa,
  nu,
  tau,
  d,
  fem_matrices,
  graph = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rspde.matern.precision.integer.opt_+3A_kappa">kappa</code></td>
<td>
<p>Range parameter of the covariance function.</p>
</td></tr>
<tr><td><code id="rspde.matern.precision.integer.opt_+3A_nu">nu</code></td>
<td>
<p>Shape parameter of the covariance function.</p>
</td></tr>
<tr><td><code id="rspde.matern.precision.integer.opt_+3A_tau">tau</code></td>
<td>
<p>Scale parameter of the covariance function.</p>
</td></tr>
<tr><td><code id="rspde.matern.precision.integer.opt_+3A_d">d</code></td>
<td>
<p>The dimension of the domain</p>
</td></tr>
<tr><td><code id="rspde.matern.precision.integer.opt_+3A_fem_matrices">fem_matrices</code></td>
<td>
<p>A list containing the FEM-related matrices.
The list should contain elements C, G, G_2, G_3, etc.</p>
</td></tr>
<tr><td><code id="rspde.matern.precision.integer.opt_+3A_graph">graph</code></td>
<td>
<p>The sparsity graph of the matrices. If NULL, only a vector
of the elements will be returned, if non-NULL, a sparse matrix will
be returned.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The precision matrix
</p>

<hr>
<h2 id='rspde.matern.precision.opt'>Optimized precision matrix of the covariance-based rational
approximation</h2><span id='topic+rspde.matern.precision.opt'></span>

<h3>Description</h3>

<p><code>rspde.matern.precision</code> is used for computing the
optimized version of the precision matrix of the
covariance-based rational SPDE approximation of a stationary Gaussian random
fields on <code class="reqn">R^d</code> with a Matern covariance function
</p>
<p style="text-align: center;"><code class="reqn">C(h) = \frac{\sigma^2}{2^{\nu-1}\Gamma(\nu)}(\kappa h)^\nu
K_\nu(\kappa h).</code>
</p>



<h3>Usage</h3>

<pre><code class='language-R'>rspde.matern.precision.opt(
  kappa,
  nu,
  tau,
  rspde.order,
  dim,
  fem_matrices,
  graph = NULL,
  sharp,
  type_rational_approx
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rspde.matern.precision.opt_+3A_kappa">kappa</code></td>
<td>
<p>Range parameter of the covariance function.</p>
</td></tr>
<tr><td><code id="rspde.matern.precision.opt_+3A_nu">nu</code></td>
<td>
<p>Shape parameter of the covariance function.</p>
</td></tr>
<tr><td><code id="rspde.matern.precision.opt_+3A_tau">tau</code></td>
<td>
<p>Scale parameter of the covariance function.</p>
</td></tr>
<tr><td><code id="rspde.matern.precision.opt_+3A_rspde.order">rspde.order</code></td>
<td>
<p>The order of the rational approximation</p>
</td></tr>
<tr><td><code id="rspde.matern.precision.opt_+3A_dim">dim</code></td>
<td>
<p>The dimension of the domain</p>
</td></tr>
<tr><td><code id="rspde.matern.precision.opt_+3A_fem_matrices">fem_matrices</code></td>
<td>
<p>A list containing the FEM-related matrices.
The list should contain elements C, G, G_2, G_3, etc.</p>
</td></tr>
<tr><td><code id="rspde.matern.precision.opt_+3A_graph">graph</code></td>
<td>
<p>The sparsity graph of the matrices. If NULL, only a vector
of the elements will be returned, if non-NULL, a sparse matrix will
be returned.</p>
</td></tr>
<tr><td><code id="rspde.matern.precision.opt_+3A_sharp">sharp</code></td>
<td>
<p>The sparsity graph should have the correct sparsity (costs
more to perform a sparsity analysis) or an upper bound for the sparsity?</p>
</td></tr>
<tr><td><code id="rspde.matern.precision.opt_+3A_type_rational_approx">type_rational_approx</code></td>
<td>
<p>Which type of rational approximation
should be used? The current types are &quot;chebfun&quot;, &quot;brasil&quot; or &quot;chebfunLB&quot;.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The precision matrix
</p>

<hr>
<h2 id='rspde.mesh.project'>Calculate a lattice projection to/from an <code>inla.mesh</code> for
rSPDE objects</h2><span id='topic+rspde.mesh.project'></span><span id='topic+rspde.mesh.projector'></span><span id='topic+rspde.mesh.project.inla.mesh'></span><span id='topic+rspde.mesh.project.rspde.mesh.projector'></span><span id='topic+rspde.mesh.project.inla.mesh.1d'></span>

<h3>Description</h3>

<p>Calculate a lattice projection to/from an <code>inla.mesh</code> for
rSPDE objects
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rspde.mesh.project(...)

rspde.mesh.projector(
  mesh,
  nu = NULL,
  rspde.order = 2,
  loc = NULL,
  lattice = NULL,
  xlim = NULL,
  ylim = NULL,
  dims = c(100, 100),
  projection = NULL,
  ...
)

## S3 method for class 'inla.mesh'
rspde.mesh.project(
  mesh,
  loc = NULL,
  field = NULL,
  rspde.order = 2,
  nu = NULL,
  ...
)

## S3 method for class 'rspde.mesh.projector'
rspde.mesh.project(projector, field, ...)

## S3 method for class 'inla.mesh.1d'
rspde.mesh.project(mesh, loc, field = NULL, rspde.order = 2, nu = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rspde.mesh.project_+3A_...">...</code></td>
<td>
<p>Additional parameters.</p>
</td></tr>
<tr><td><code id="rspde.mesh.project_+3A_mesh">mesh</code></td>
<td>
<p>An <code>inla.mesh</code> or <code>inla.mesh.1d</code> object.</p>
</td></tr>
<tr><td><code id="rspde.mesh.project_+3A_nu">nu</code></td>
<td>
<p>The smoothness parameter. If <code>NULL</code>, it will be assumed that
nu was estimated.</p>
</td></tr>
<tr><td><code id="rspde.mesh.project_+3A_rspde.order">rspde.order</code></td>
<td>
<p>The order of the rational approximation.</p>
</td></tr>
<tr><td><code id="rspde.mesh.project_+3A_loc">loc</code></td>
<td>
<p>Projection locations. Can be a matrix or a SpatialPoints or a
SpatialPointsDataFrame object.</p>
</td></tr>
<tr><td><code id="rspde.mesh.project_+3A_lattice">lattice</code></td>
<td>
<p>An <code>inla.mesh.lattice</code> object.</p>
</td></tr>
<tr><td><code id="rspde.mesh.project_+3A_xlim">xlim</code></td>
<td>
<p>X-axis limits for a lattice. For R2 meshes, defaults to covering
the domain.</p>
</td></tr>
<tr><td><code id="rspde.mesh.project_+3A_ylim">ylim</code></td>
<td>
<p>Y-axis limits for a lattice. For R2 meshes, defaults to covering
the domain.</p>
</td></tr>
<tr><td><code id="rspde.mesh.project_+3A_dims">dims</code></td>
<td>
<p>Lattice dimensions.</p>
</td></tr>
<tr><td><code id="rspde.mesh.project_+3A_projection">projection</code></td>
<td>
<p>One of c(&quot;default&quot;, &quot;longlat&quot;, &quot;longsinlat&quot;, &quot;mollweide&quot;).</p>
</td></tr>
<tr><td><code id="rspde.mesh.project_+3A_field">field</code></td>
<td>
<p>Basis function weights, one per mesh basis function, describing
the function to be evaluated at the projection locations.</p>
</td></tr>
<tr><td><code id="rspde.mesh.project_+3A_projector">projector</code></td>
<td>
<p>A <code>rspde.mesh.projector</code> object.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is built upon the inla.mesh.project and
inla.mesh.projector functions from INLA.
</p>


<h3>Value</h3>

<p>A list with projection information for rspde.mesh.project. For
rspde.mesh.projector(mesh, ...),
a rspde.mesh.projector object. For rspde.mesh.project(projector, field, ...),
a field projected from the mesh onto the locations
given by the projector object.
</p>

<hr>
<h2 id='rspde.metric_graph'>Matern rSPDE model object for metric graphs in INLA</h2><span id='topic+rspde.metric_graph'></span>

<h3>Description</h3>

<p>Creates an INLA object for a stationary Matern model on a metric graph with
general smoothness parameter.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rspde.metric_graph(
  graph_obj,
  h = NULL,
  nu.upper.bound = 2,
  rspde.order = 2,
  nu = NULL,
  debug = FALSE,
  B.sigma = matrix(c(0, 1, 0), 1, 3),
  B.range = matrix(c(0, 0, 1), 1, 3),
  parameterization = c("matern", "spde"),
  B.tau = matrix(c(0, 1, 0), 1, 3),
  B.kappa = matrix(c(0, 0, 1), 1, 3),
  start.nu = NULL,
  start.theta = NULL,
  prior.nu = NULL,
  theta.prior.mean = NULL,
  theta.prior.prec = 0.1,
  prior.std.dev.nominal = 1,
  prior.range.nominal = NULL,
  prior.kappa.mean = NULL,
  prior.tau.mean = NULL,
  start.lstd.dev = NULL,
  start.lrange = NULL,
  start.ltau = NULL,
  start.lkappa = NULL,
  prior.theta.param = c("theta", "spde"),
  prior.nu.dist = c("lognormal", "beta"),
  nu.prec.inc = 1,
  type.rational.approx = c("chebfun", "brasil", "chebfunLB"),
  shared_lib = "INLA"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rspde.metric_graph_+3A_graph_obj">graph_obj</code></td>
<td>
<p>The graph object to build the model. Needs to be of class <code>metric_graph</code>. It should have a built mesh.
If the mesh is not built, one will be built using h=0.01 as default.</p>
</td></tr>
<tr><td><code id="rspde.metric_graph_+3A_h">h</code></td>
<td>
<p>The width of the mesh in case the mesh was not built.</p>
</td></tr>
<tr><td><code id="rspde.metric_graph_+3A_nu.upper.bound">nu.upper.bound</code></td>
<td>
<p>Upper bound for the smoothness parameter.</p>
</td></tr>
<tr><td><code id="rspde.metric_graph_+3A_rspde.order">rspde.order</code></td>
<td>
<p>The order of the covariance-based rational SPDE approach.</p>
</td></tr>
<tr><td><code id="rspde.metric_graph_+3A_nu">nu</code></td>
<td>
<p>If nu is set to a parameter, nu will be kept fixed and will not
be estimated. If nu is <code>NULL</code>, it will be estimated.</p>
</td></tr>
<tr><td><code id="rspde.metric_graph_+3A_debug">debug</code></td>
<td>
<p>INLA debug argument</p>
</td></tr>
<tr><td><code id="rspde.metric_graph_+3A_b.sigma">B.sigma</code></td>
<td>
<p>Matrix with specification of log-linear model for <code class="reqn">\sigma</code>. Will be used if <code>parameterization = 'matern'</code>.</p>
</td></tr>
<tr><td><code id="rspde.metric_graph_+3A_b.range">B.range</code></td>
<td>
<p>Matrix with specification of log-linear model for <code class="reqn">\rho</code>, which is a range-like parameter (it is exactly the range parameter in the stationary case). Will be used if <code>parameterization = 'matern'</code>.</p>
</td></tr>
<tr><td><code id="rspde.metric_graph_+3A_parameterization">parameterization</code></td>
<td>
<p>Which parameterization to use? <code>matern</code> uses range, std. deviation and nu (smoothness). <code>spde</code> uses kappa, tau and nu (smoothness). The default is <code>matern</code>.</p>
</td></tr>
<tr><td><code id="rspde.metric_graph_+3A_b.tau">B.tau</code></td>
<td>
<p>Matrix with specification of log-linear model for <code class="reqn">\tau</code>. Will be used if <code>parameterization = 'spde'</code>.</p>
</td></tr>
<tr><td><code id="rspde.metric_graph_+3A_b.kappa">B.kappa</code></td>
<td>
<p>Matrix with specification of log-linear model for <code class="reqn">\kappa</code>. Will be used if <code>parameterization = 'spde'</code>.</p>
</td></tr>
<tr><td><code id="rspde.metric_graph_+3A_start.nu">start.nu</code></td>
<td>
<p>Starting value for nu.</p>
</td></tr>
<tr><td><code id="rspde.metric_graph_+3A_start.theta">start.theta</code></td>
<td>
<p>Starting values for the model parameters. In the stationary case, if <code>parameterization='matern'</code>, then <code>theta[1]</code> is the std.dev and <code>theta[2]</code> is the range parameter.
If <code>parameterization = 'spde'</code>, then <code>theta[1]</code> is <code>tau</code> and <code>theta[2]</code> is <code>kappa</code>.</p>
</td></tr>
<tr><td><code id="rspde.metric_graph_+3A_prior.nu">prior.nu</code></td>
<td>
<p>a list containing the elements <code>mean</code> and <code>prec</code>
for beta distribution, or <code>loglocation</code> and <code>logscale</code> for a
truncated lognormal distribution. <code>loglocation</code> stands for
the location parameter of the truncated lognormal distribution in the log
scale. <code>prec</code> stands for the precision of a beta distribution.
<code>logscale</code> stands for the scale of the truncated lognormal
distribution on the log scale. Check details below.</p>
</td></tr>
<tr><td><code id="rspde.metric_graph_+3A_theta.prior.mean">theta.prior.mean</code></td>
<td>
<p>A vector for the mean priors of <code>theta</code>.</p>
</td></tr>
<tr><td><code id="rspde.metric_graph_+3A_theta.prior.prec">theta.prior.prec</code></td>
<td>
<p>A precision matrix for the prior of <code>theta</code>.</p>
</td></tr>
<tr><td><code id="rspde.metric_graph_+3A_prior.std.dev.nominal">prior.std.dev.nominal</code></td>
<td>
<p>Prior std. deviation to be used for the priors and for the starting values.</p>
</td></tr>
<tr><td><code id="rspde.metric_graph_+3A_prior.range.nominal">prior.range.nominal</code></td>
<td>
<p>Prior range to be used for the priors and for the starting values.</p>
</td></tr>
<tr><td><code id="rspde.metric_graph_+3A_prior.kappa.mean">prior.kappa.mean</code></td>
<td>
<p>Prior kappa to be used for the priors and for the starting values.</p>
</td></tr>
<tr><td><code id="rspde.metric_graph_+3A_prior.tau.mean">prior.tau.mean</code></td>
<td>
<p>Prior tau to be used for the priors and for the starting values.</p>
</td></tr>
<tr><td><code id="rspde.metric_graph_+3A_start.lstd.dev">start.lstd.dev</code></td>
<td>
<p>Starting value for log of std. deviation. Will not be used if start.ltau is non-null. Will be only used in the stationary case and if <code>parameterization = 'matern'</code>.</p>
</td></tr>
<tr><td><code id="rspde.metric_graph_+3A_start.lrange">start.lrange</code></td>
<td>
<p>Starting value for log of range. Will not be used if start.lkappa is non-null. Will be only used in the stationary case and if <code>parameterization = 'matern'</code>.</p>
</td></tr>
<tr><td><code id="rspde.metric_graph_+3A_start.ltau">start.ltau</code></td>
<td>
<p>Starting value for log of tau. Will be only used in the stationary case and if <code>parameterization = 'spde'</code>.</p>
</td></tr>
<tr><td><code id="rspde.metric_graph_+3A_start.lkappa">start.lkappa</code></td>
<td>
<p>Starting value for log of kappa. Will be only used in the stationary case and if <code>parameterization = 'spde'</code>.</p>
</td></tr>
<tr><td><code id="rspde.metric_graph_+3A_prior.theta.param">prior.theta.param</code></td>
<td>
<p>Should the lognormal prior be on <code>theta</code> or on the SPDE parameters (<code>tau</code> and <code>kappa</code> on the stationary case)?</p>
</td></tr>
<tr><td><code id="rspde.metric_graph_+3A_prior.nu.dist">prior.nu.dist</code></td>
<td>
<p>The distribution of the smoothness parameter.
The current options are &quot;beta&quot; or &quot;lognormal&quot;. The default is &quot;lognormal&quot;.</p>
</td></tr>
<tr><td><code id="rspde.metric_graph_+3A_nu.prec.inc">nu.prec.inc</code></td>
<td>
<p>Amount to increase the precision in the beta prior
distribution. Check details below.</p>
</td></tr>
<tr><td><code id="rspde.metric_graph_+3A_type.rational.approx">type.rational.approx</code></td>
<td>
<p>Which type of rational approximation
should be used? The current types are &quot;chebfun&quot;, &quot;brasil&quot; or &quot;chebfunLB&quot;.</p>
</td></tr>
<tr><td><code id="rspde.metric_graph_+3A_shared_lib">shared_lib</code></td>
<td>
<p>Which shared lib to use for the cgeneric implementation?
If &quot;INLA&quot;, it will use the shared lib from INLA's installation. If 'rSPDE', then
it will use the local installation (does not work if your installation is from CRAN).
Otherwise, you can directly supply the path of the .so (or .dll) file.</p>
</td></tr>
<tr><td><code id="rspde.metric_graph_+3A_prior.kappa">prior.kappa</code></td>
<td>
<p>a <code>list</code> containing the elements <code>meanlog</code> and
<code>sdlog</code>, that is, the mean and standard deviation on the log scale.</p>
</td></tr>
<tr><td><code id="rspde.metric_graph_+3A_prior.tau">prior.tau</code></td>
<td>
<p>a list containing the elements <code>meanlog</code> and
<code>sdlog</code>, that is, the mean and standard deviation on the log scale.</p>
</td></tr>
<tr><td><code id="rspde.metric_graph_+3A_prior.range">prior.range</code></td>
<td>
<p>a <code>list</code> containing the elements <code>meanlog</code> and
<code>sdlog</code>, that is, the mean and standard deviation on the log scale. Will not be used if prior.kappa is non-null.</p>
</td></tr>
<tr><td><code id="rspde.metric_graph_+3A_prior.std.dev">prior.std.dev</code></td>
<td>
<p>a <code>list</code> containing the elements <code>meanlog</code> and
<code>sdlog</code>, that is, the mean and standard deviation on the log scale. Will not be used if prior.tau is non-null.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An INLA model.
</p>

<hr>
<h2 id='rspde.result'>rSPDE result extraction from INLA estimation results</h2><span id='topic+rspde.result'></span>

<h3>Description</h3>

<p>Extract field and parameter values and distributions
for an rspde effect from an inla result object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rspde.result(
  inla,
  name,
  rspde,
  compute.summary = TRUE,
  parameterization = "detect",
  n_samples = 5000,
  n_density = 1024
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rspde.result_+3A_inla">inla</code></td>
<td>
<p>An <code>inla</code> object obtained from a call to
<code>inla()</code>.</p>
</td></tr>
<tr><td><code id="rspde.result_+3A_name">name</code></td>
<td>
<p>A character string with the name of the rSPDE effect
in the inla formula.</p>
</td></tr>
<tr><td><code id="rspde.result_+3A_rspde">rspde</code></td>
<td>
<p>The <code>inla_rspde</code> object used for the effect in
the inla formula.</p>
</td></tr>
<tr><td><code id="rspde.result_+3A_compute.summary">compute.summary</code></td>
<td>
<p>Should the summary be computed?</p>
</td></tr>
<tr><td><code id="rspde.result_+3A_parameterization">parameterization</code></td>
<td>
<p>If 'detect', the parameterization from the model will be used. Otherwise, the options are 'spde', 'matern' and 'matern2'.</p>
</td></tr>
<tr><td><code id="rspde.result_+3A_n_samples">n_samples</code></td>
<td>
<p>The number of samples to be used if parameterization is different from the one used to fit the model.</p>
</td></tr>
<tr><td><code id="rspde.result_+3A_n_density">n_density</code></td>
<td>
<p>The number of equally spaced points to estimate the density.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>If the model was fitted with <code>matern</code> parameterization (the default), it returns a list containing:
</p>
<table>
<tr><td><code>marginals.range</code></td>
<td>
<p>Marginal densities for the range parameter</p>
</td></tr>
<tr><td><code>marginals.log.range</code></td>
<td>
<p>Marginal densities for log(range)</p>
</td></tr>
<tr><td><code>marginals.std.dev</code></td>
<td>
<p>Marginal densities for std. deviation</p>
</td></tr>
<tr><td><code>marginals.log.std.dev</code></td>
<td>
<p>Marginal densities for log(std. deviation)</p>
</td></tr>
<tr><td><code>marginals.values</code></td>
<td>
<p>Marginal densities for the field values</p>
</td></tr>
<tr><td><code>summary.log.range</code></td>
<td>
<p>Summary statistics for log(range)</p>
</td></tr>
<tr><td><code>summary.log.std.dev</code></td>
<td>
<p>Summary statistics for log(std. deviation)</p>
</td></tr>
<tr><td><code>summary.values</code></td>
<td>
<p>Summary statistics for the field values</p>
</td></tr>
</table>
<p>If <code>compute.summary</code> is <code>TRUE</code>, then the list will also contain
</p>
<table>
<tr><td><code>summary.kappa</code></td>
<td>
<p>Summary statistics for kappa</p>
</td></tr>
<tr><td><code>summary.tau</code></td>
<td>
<p>Summary statistics for tau</p>
</td></tr>
</table>
<p>If the model was fitted with the <code>spde</code> parameterization, it returns a list containing:
</p>
<table>
<tr><td><code>marginals.kappa</code></td>
<td>
<p>Marginal densities for kappa</p>
</td></tr>
<tr><td><code>marginals.log.kappa</code></td>
<td>
<p>Marginal densities for log(kappa)</p>
</td></tr>
<tr><td><code>marginals.log.tau</code></td>
<td>
<p>Marginal densities for log(tau)</p>
</td></tr>
<tr><td><code>marginals.tau</code></td>
<td>
<p>Marginal densities for tau</p>
</td></tr>
<tr><td><code>marginals.values</code></td>
<td>
<p>Marginal densities for the field values</p>
</td></tr>
<tr><td><code>summary.log.kappa</code></td>
<td>
<p>Summary statistics for log(kappa)</p>
</td></tr>
<tr><td><code>summary.log.tau</code></td>
<td>
<p>Summary statistics for log(tau)</p>
</td></tr>
<tr><td><code>summary.values</code></td>
<td>
<p>Summary statistics for the field values</p>
</td></tr>
</table>
<p>If <code>compute.summary</code> is <code>TRUE</code>, then the list will also contain
</p>
<table>
<tr><td><code>summary.kappa</code></td>
<td>
<p>Summary statistics for kappa</p>
</td></tr>
<tr><td><code>summary.tau</code></td>
<td>
<p>Summary statistics for tau</p>
</td></tr>
</table>
<p>For both cases, if nu was estimated, then the list will also contain
</p>
<table>
<tr><td><code>marginals.nu</code></td>
<td>
<p>Marginal densities for nu</p>
</td></tr>
</table>
<p>If nu was estimated and a beta prior was used, then the list will
also contain
</p>
<table>
<tr><td><code>marginals.logit.nu</code></td>
<td>
<p>Marginal densities for logit(nu)</p>
</td></tr>
<tr><td><code>summary.logit.nu</code></td>
<td>
<p>Marginal densities for logit(nu)</p>
</td></tr>
</table>
<p>If nu was estimated and a truncated lognormal prior was used,
then the list will also contain
</p>
<table>
<tr><td><code>marginals.log.nu</code></td>
<td>
<p>Marginal densities for log(nu)</p>
</td></tr>
<tr><td><code>summary.log.nu</code></td>
<td>
<p>Marginal densities for log(nu)</p>
</td></tr>
</table>
<p>If nu was estimated and <code>compute.summary</code> is <code>TRUE</code>,
then the list will also contain
</p>
<table>
<tr><td><code>summary.nu</code></td>
<td>
<p>Summary statistics for nu</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'> #tryCatch version
tryCatch({
if (requireNamespace("INLA", quietly = TRUE)){
library(INLA)

set.seed(123)

m &lt;- 100
loc_2d_mesh &lt;- matrix(runif(m * 2), m, 2)
mesh_2d &lt;- inla.mesh.2d(
  loc = loc_2d_mesh,
  cutoff = 0.05,
  max.edge = c(0.1, 0.5)
)
sigma &lt;- 1
range &lt;- 0.2
nu &lt;- 0.8
kappa &lt;- sqrt(8 * nu) / range
op &lt;- matern.operators(
  mesh = mesh_2d, nu = nu,
  range = range, sigma = sigma, m = 2,
  parameterization = "matern"
)
u &lt;- simulate(op)
A &lt;- inla.spde.make.A(
  mesh = mesh_2d,
  loc = loc_2d_mesh
)
sigma.e &lt;- 0.1
y &lt;- A %*% u + rnorm(m) * sigma.e
Abar &lt;- rspde.make.A(mesh = mesh_2d, loc = loc_2d_mesh)
mesh.index &lt;- rspde.make.index(name = "field", mesh = mesh_2d)
st.dat &lt;- inla.stack(
  data = list(y = as.vector(y)),
  A = Abar,
  effects = mesh.index
)
rspde_model &lt;- rspde.matern(
  mesh = mesh_2d,
  nu.upper.bound = 2
)
f &lt;- y ~ -1 + f(field, model = rspde_model)
rspde_fit &lt;- inla(f,
  data = inla.stack.data(st.dat),
  family = "gaussian",
  control.predictor =
    list(A = inla.stack.A(st.dat))
)
result &lt;- rspde.result(rspde_fit, "field", rspde_model)
summary(result)
}
#stable.tryCatch
}, error = function(e){print("Could not run the example")})

</code></pre>

<hr>
<h2 id='simulate.CBrSPDEobj'>Simulation of a fractional SPDE using the
covariance-based rational SPDE approximation</h2><span id='topic+simulate.CBrSPDEobj'></span>

<h3>Description</h3>

<p>The function samples a Gaussian random field based using the
covariance-based rational SPDE approximation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'CBrSPDEobj'
simulate(
  object,
  nsim = 1,
  seed = NULL,
  user_nu = NULL,
  user_kappa = NULL,
  user_sigma = NULL,
  user_range = NULL,
  user_tau = NULL,
  user_theta = NULL,
  user_m = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="simulate.CBrSPDEobj_+3A_object">object</code></td>
<td>
<p>The covariance-based rational SPDE approximation,
computed using <code><a href="#topic+matern.operators">matern.operators()</a></code></p>
</td></tr>
<tr><td><code id="simulate.CBrSPDEobj_+3A_nsim">nsim</code></td>
<td>
<p>The number of simulations.</p>
</td></tr>
<tr><td><code id="simulate.CBrSPDEobj_+3A_seed">seed</code></td>
<td>
<p>An object specifying if and how the random number generator should be initialized (‘seeded’).</p>
</td></tr>
<tr><td><code id="simulate.CBrSPDEobj_+3A_user_nu">user_nu</code></td>
<td>
<p>If non-null, update the shape parameter of the
covariance function.</p>
</td></tr>
<tr><td><code id="simulate.CBrSPDEobj_+3A_user_kappa">user_kappa</code></td>
<td>
<p>If non-null, update the range parameter
of the covariance function.</p>
</td></tr>
<tr><td><code id="simulate.CBrSPDEobj_+3A_user_sigma">user_sigma</code></td>
<td>
<p>If non-null, update the standard deviation of
the covariance function.</p>
</td></tr>
<tr><td><code id="simulate.CBrSPDEobj_+3A_user_range">user_range</code></td>
<td>
<p>If non-null, update the range parameter
of the covariance function.</p>
</td></tr>
<tr><td><code id="simulate.CBrSPDEobj_+3A_user_tau">user_tau</code></td>
<td>
<p>If non-null, update the parameter tau.</p>
</td></tr>
<tr><td><code id="simulate.CBrSPDEobj_+3A_user_theta">user_theta</code></td>
<td>
<p>For non-stationary models. If non-null, update the vector of parameters.</p>
</td></tr>
<tr><td><code id="simulate.CBrSPDEobj_+3A_user_m">user_m</code></td>
<td>
<p>If non-null, update the order of the rational
approximation, which needs to be a positive integer.</p>
</td></tr>
<tr><td><code id="simulate.CBrSPDEobj_+3A_...">...</code></td>
<td>
<p>Currently not used.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix with the <code>n</code> samples as columns.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Sample a Gaussian Matern process on R using a rational approximation
kappa &lt;- 10
sigma &lt;- 1
nu &lt;- 0.8
range &lt;- sqrt(8*nu)/kappa

# create mass and stiffness matrices for a FEM discretization
x &lt;- seq(from = 0, to = 1, length.out = 101)
fem &lt;- rSPDE.fem1d(x)

# compute rational approximation of covariance function at 0.5
tau &lt;- sqrt(gamma(nu) / (sigma^2 * kappa^(2 * nu) *
(4 * pi)^(1 / 2) * gamma(nu + 1 / 2)))
op_cov &lt;- matern.operators(
  loc_mesh = x, nu = nu,
  range = range, sigma = sigma, d = 1, m = 2,
  parameterization = "matern"
)

# Sample the model and plot the result
Y &lt;- simulate(op_cov)
plot(x, Y, type = "l", ylab = "u(x)", xlab = "x")

</code></pre>

<hr>
<h2 id='simulate.rSPDEobj'>Simulation of a fractional SPDE using a rational SPDE approximation</h2><span id='topic+simulate.rSPDEobj'></span>

<h3>Description</h3>

<p>The function samples a Gaussian random field based on a
pre-computed rational SPDE approximation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'rSPDEobj'
simulate(object, nsim = 1, seed = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="simulate.rSPDEobj_+3A_object">object</code></td>
<td>
<p>The rational SPDE approximation, computed
using <code><a href="#topic+fractional.operators">fractional.operators()</a></code>,
<code><a href="#topic+matern.operators">matern.operators()</a></code>, or <code><a href="#topic+spde.matern.operators">spde.matern.operators()</a></code>.</p>
</td></tr>
<tr><td><code id="simulate.rSPDEobj_+3A_nsim">nsim</code></td>
<td>
<p>The number of simulations.</p>
</td></tr>
<tr><td><code id="simulate.rSPDEobj_+3A_seed">seed</code></td>
<td>
<p>an object specifying if and how the random number generator should be initialized (‘seeded’).</p>
</td></tr>
<tr><td><code id="simulate.rSPDEobj_+3A_...">...</code></td>
<td>
<p>Currently not used.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix with the <code>n</code> samples as columns.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+simulate.CBrSPDEobj">simulate.CBrSPDEobj()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Sample a Gaussian Matern process on R using a rational approximation
kappa &lt;- 10
sigma &lt;- 1
nu &lt;- 0.8
range &lt;- sqrt(8*nu)/kappa

# create mass and stiffness matrices for a FEM discretization
x &lt;- seq(from = 0, to = 1, length.out = 101)
fem &lt;- rSPDE.fem1d(x)

# compute rational approximation
op &lt;- matern.operators(
  range = range, sigma = sigma,
  nu = nu, loc_mesh = x, d = 1,
  parameterization = "matern"
)

# Sample the model and plot the result
Y &lt;- simulate(op)
plot(x, Y, type = "l", ylab = "u(x)", xlab = "x")

</code></pre>

<hr>
<h2 id='spde.make.A'>Observation/prediction matrices for rSPDE models with integer smoothness.</h2><span id='topic+spde.make.A'></span>

<h3>Description</h3>

<p>Constructs observation/prediction weight matrices
for rSPDE models with integer smoothness based on <code>inla.mesh</code> or
<code>inla.mesh.1d</code> objects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>spde.make.A(
  mesh = NULL,
  loc = NULL,
  A = NULL,
  index = NULL,
  group = NULL,
  repl = 1L,
  n.group = NULL,
  n.repl = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="spde.make.A_+3A_mesh">mesh</code></td>
<td>
<p>An <code>inla.mesh</code>,
an <code>inla.mesh.1d</code> object or a <code>metric_graph</code> object.</p>
</td></tr>
<tr><td><code id="spde.make.A_+3A_loc">loc</code></td>
<td>
<p>Locations, needed if an INLA mesh is provided</p>
</td></tr>
<tr><td><code id="spde.make.A_+3A_a">A</code></td>
<td>
<p>The A matrix from the standard SPDE approach, such as the matrix
returned by <code>inla.spde.make.A</code>. Should only be provided if
<code>mesh</code> is not provided.</p>
</td></tr>
<tr><td><code id="spde.make.A_+3A_index">index</code></td>
<td>
<p>For each observation/prediction value, an index into loc. Default is seq_len(nrow(A.loc)).</p>
</td></tr>
<tr><td><code id="spde.make.A_+3A_group">group</code></td>
<td>
<p>For each observation/prediction value, an index into
the group model.</p>
</td></tr>
<tr><td><code id="spde.make.A_+3A_repl">repl</code></td>
<td>
<p>For each observation/prediction value, the replicate index.</p>
</td></tr>
<tr><td><code id="spde.make.A_+3A_n.group">n.group</code></td>
<td>
<p>The size of the group model.</p>
</td></tr>
<tr><td><code id="spde.make.A_+3A_n.repl">n.repl</code></td>
<td>
<p>The total number of replicates.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The <code class="reqn">A</code> matrix for rSPDE models.
</p>


<h3>Examples</h3>

<pre><code class='language-R'> #tryCatch version
tryCatch({
if (requireNamespace("fmesher", quietly = TRUE)){
library(fmesher)

set.seed(123)
loc &lt;- matrix(runif(100 * 2) * 100, 100, 2)
mesh &lt;- fm_mesh_2d(
  loc = loc,
  cutoff = 50,
  max.edge = c(50, 500)
)
A &lt;- spde.make.A(mesh, loc = loc)
}
#stable.tryCatch
}, error = function(e){print("Could not run the example")})

</code></pre>

<hr>
<h2 id='spde.matern.loglike'>Parameter-based log-likelihood for a latent Gaussian Matern SPDE model
using a rational SPDE approximation</h2><span id='topic+spde.matern.loglike'></span>

<h3>Description</h3>

<p>This function evaluates the log-likelihood function for observations
of a Gaussian process defined as the solution to the SPDE
</p>
<p style="text-align: center;"><code class="reqn">(\kappa(s) - \Delta)^\beta (\tau(s)u(s)) = W.</code>
</p>



<h3>Usage</h3>

<pre><code class='language-R'>spde.matern.loglike(
  object,
  Y,
  A,
  sigma.e,
  mu = 0,
  user_nu = NULL,
  user_kappa = NULL,
  user_tau = NULL,
  user_theta = NULL,
  user_m = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="spde.matern.loglike_+3A_object">object</code></td>
<td>
<p>The rational SPDE approximation,
computed using <code><a href="#topic+spde.matern.operators">spde.matern.operators()</a></code></p>
</td></tr>
<tr><td><code id="spde.matern.loglike_+3A_y">Y</code></td>
<td>
<p>The observations, either a vector or a matrix where
the columns correspond to independent replicates of observations.</p>
</td></tr>
<tr><td><code id="spde.matern.loglike_+3A_a">A</code></td>
<td>
<p>An observation matrix that links the measurement location to the
finite element basis.</p>
</td></tr>
<tr><td><code id="spde.matern.loglike_+3A_sigma.e">sigma.e</code></td>
<td>
<p>IF non-null, the standard deviation of the measurement noise will be kept fixed in
the returned likelihood.</p>
</td></tr>
<tr><td><code id="spde.matern.loglike_+3A_mu">mu</code></td>
<td>
<p>Expectation vector of the latent field (default = 0).</p>
</td></tr>
<tr><td><code id="spde.matern.loglike_+3A_user_nu">user_nu</code></td>
<td>
<p>If non-null, the shape parameter will be kept fixed in the returned likelihood.</p>
</td></tr>
<tr><td><code id="spde.matern.loglike_+3A_user_kappa">user_kappa</code></td>
<td>
<p>If non-null, updates the range parameter.</p>
</td></tr>
<tr><td><code id="spde.matern.loglike_+3A_user_tau">user_tau</code></td>
<td>
<p>If non-null, updates the parameter tau.</p>
</td></tr>
<tr><td><code id="spde.matern.loglike_+3A_user_theta">user_theta</code></td>
<td>
<p>If non-null, updates the parameter theta (that connects tau and kappa to the model matrices in <code>object</code>).</p>
</td></tr>
<tr><td><code id="spde.matern.loglike_+3A_user_m">user_m</code></td>
<td>
<p>If non-null, update the order of the rational approximation,
which needs to be a positive integer.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The observations are assumed to be generated as
<code class="reqn">Y_i = u(s_i) + \epsilon_i</code>, where
<code class="reqn">\epsilon_i</code> are
iid mean-zero Gaussian variables. The latent model is approximated using a
rational approximation of the fractional SPDE model.
</p>


<h3>Value</h3>

<p>The log-likelihood value.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+rSPDE.loglike">rSPDE.loglike()</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># this example illustrates how the function can be used for maximum
# likelihood estimation
# Sample a Gaussian Matern process on R using a rational approximation
sigma.e &lt;- 0.1
n.rep &lt;- 10
n.obs &lt;- 100
n.x &lt;- 51
# create mass and stiffness matrices for a FEM discretization
x &lt;- seq(from = 0, to = 1, length.out = n.x)
fem &lt;- rSPDE.fem1d(x)
tau &lt;- rep(0.5, n.x)
nu &lt;- 0.8
alpha &lt;- nu + 1/2
kappa &lt;- rep(1, n.x)
# compute rational approximation
op &lt;- spde.matern.operators(
  kappa = kappa, tau = tau, alpha = alpha,
  parameterization = "spde", d = 1,
  loc_mesh = x
)
# Sample the model
u &lt;- simulate(op, n.rep)
# Create some data
obs.loc &lt;- runif(n = n.obs, min = 0, max = 1)
A &lt;- rSPDE.A1d(x, obs.loc)
noise &lt;- rnorm(n.obs * n.rep)
dim(noise) &lt;- c(n.obs, n.rep)
Y &lt;- as.matrix(A %*% u + sigma.e * noise)
# define negative likelihood function for optimization using matern.loglike
mlik &lt;- function(theta) {
  return(-spde.matern.loglike(op, Y, A, sigma.e = exp(theta[4]),
                                 user_nu = exp(theta[3]),
                                 user_kappa = exp(theta[2]),
                                 user_tau = exp(theta[1])))
}
#' #The parameters can now be estimated by minimizing mlik with optim

# Choose some reasonable starting values depending on the size of the domain
theta0 &lt;- log(c(1 / sqrt(var(c(Y))), sqrt(8), 0.9, 0.01))
# run estimation and display the results
theta &lt;- optim(theta0, mlik)
print(data.frame(
  tau = c(tau[1], exp(theta$par[1])), kappa = c(kappa[1], exp(theta$par[2])),
  nu = c(nu, exp(theta$par[3])), sigma.e = c(sigma.e, exp(theta$par[4])),
  row.names = c("Truth", "Estimates")
))

</code></pre>

<hr>
<h2 id='spde.matern.operators'>Rational approximations of non-stationary Gaussian SPDE Matern random fields</h2><span id='topic+spde.matern.operators'></span>

<h3>Description</h3>

<p><code>spde.matern.operators</code> is used for computing a rational SPDE
approximation of a Gaussian random
fields on <code class="reqn">R^d</code> defined as a solution to the SPDE
</p>
<p style="text-align: center;"><code class="reqn">(\kappa(s) - \Delta)^\beta (\tau(s)u(s)) = W.</code>
</p>



<h3>Usage</h3>

<pre><code class='language-R'>spde.matern.operators(
  kappa = NULL,
  tau = NULL,
  theta = NULL,
  B.tau = matrix(c(0, 1, 0), 1, 3),
  B.kappa = matrix(c(0, 0, 1), 1, 3),
  B.sigma = matrix(c(0, 1, 0), 1, 3),
  B.range = matrix(c(0, 0, 1), 1, 3),
  alpha = NULL,
  nu = NULL,
  parameterization = c("spde", "matern"),
  G = NULL,
  C = NULL,
  d = NULL,
  graph = NULL,
  mesh = NULL,
  range_mesh = NULL,
  loc_mesh = NULL,
  m = 1,
  type = c("covariance", "operator"),
  type_rational_approximation = c("chebfun", "brasil", "chebfunLB")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="spde.matern.operators_+3A_kappa">kappa</code></td>
<td>
<p>Vector with the, possibly spatially varying, range parameter
evaluated at the locations of the mesh used for the finite element
discretization of the SPDE.</p>
</td></tr>
<tr><td><code id="spde.matern.operators_+3A_tau">tau</code></td>
<td>
<p>Vector with the, possibly spatially varying, precision
parameter evaluated at the locations
of the mesh used for the finite element discretization of the SPDE.</p>
</td></tr>
<tr><td><code id="spde.matern.operators_+3A_theta">theta</code></td>
<td>
<p>Theta parameter that connects B.tau and B.kappa to tau and kappa through a log-linear regression, in case the parameterization is <code>spde</code>,
and that connects B.sigma and B.range to tau and kappa in case the parameterization is <code>matern</code>.</p>
</td></tr>
<tr><td><code id="spde.matern.operators_+3A_b.tau">B.tau</code></td>
<td>
<p>Matrix with specification of log-linear model for <code class="reqn">\tau</code>. Will be used if <code>parameterization = 'spde'</code>.</p>
</td></tr>
<tr><td><code id="spde.matern.operators_+3A_b.kappa">B.kappa</code></td>
<td>
<p>Matrix with specification of log-linear model for <code class="reqn">\kappa</code>. Will be used if <code>parameterization = 'spde'</code>.</p>
</td></tr>
<tr><td><code id="spde.matern.operators_+3A_b.sigma">B.sigma</code></td>
<td>
<p>Matrix with specification of log-linear model for <code class="reqn">\sigma</code>. Will be used if <code>parameterization = 'matern'</code>.</p>
</td></tr>
<tr><td><code id="spde.matern.operators_+3A_b.range">B.range</code></td>
<td>
<p>Matrix with specification of log-linear model for <code class="reqn">\rho</code>, which is a range-like parameter (it is exactly the range parameter in the stationary case). Will be used if <code>parameterization = 'matern'</code>.</p>
</td></tr>
<tr><td><code id="spde.matern.operators_+3A_alpha">alpha</code></td>
<td>
<p>smoothness parameter. Will be used if the parameterization is 'spde'.</p>
</td></tr>
<tr><td><code id="spde.matern.operators_+3A_nu">nu</code></td>
<td>
<p>Shape parameter of the covariance function. Will be used if the parameterization is 'matern'.</p>
</td></tr>
<tr><td><code id="spde.matern.operators_+3A_parameterization">parameterization</code></td>
<td>
<p>Which parameterization to use? <code>matern</code> uses range, std. deviation and nu (smoothness). <code>spde</code> uses kappa, tau and nu (smoothness). The default is <code>matern</code>.</p>
</td></tr>
<tr><td><code id="spde.matern.operators_+3A_g">G</code></td>
<td>
<p>The stiffness matrix of a finite element discretization of
the domain of interest.</p>
</td></tr>
<tr><td><code id="spde.matern.operators_+3A_c">C</code></td>
<td>
<p>The mass matrix of a finite element discretization of the
domain of interest.</p>
</td></tr>
<tr><td><code id="spde.matern.operators_+3A_d">d</code></td>
<td>
<p>The dimension of the domain. Does not need to be given if
<code>mesh</code> is used.</p>
</td></tr>
<tr><td><code id="spde.matern.operators_+3A_graph">graph</code></td>
<td>
<p>An optional <code>metric_graph</code> object. Replaces <code>d</code>, <code>C</code> and <code>G</code>.</p>
</td></tr>
<tr><td><code id="spde.matern.operators_+3A_mesh">mesh</code></td>
<td>
<p>An optional inla mesh. <code>d</code>, <code>C</code> and <code>G</code>
must be given if <code>mesh</code> is not given.</p>
</td></tr>
<tr><td><code id="spde.matern.operators_+3A_range_mesh">range_mesh</code></td>
<td>
<p>The range of the mesh. Will be used to provide starting values for the parameters. Will be used if <code>mesh</code> and <code>graph</code> are <code>NULL</code>, and if one of the parameters (kappa or tau for spde parameterization, or sigma or range for matern parameterization) are not provided.</p>
</td></tr>
<tr><td><code id="spde.matern.operators_+3A_loc_mesh">loc_mesh</code></td>
<td>
<p>The mesh locations used to construct the matrices C and G. This option should be provided if one wants to use the <code>rspde_lme()</code> function and will not provide neither graph nor mesh. Only works for 1d data. Does not work for metric graphs. For metric graphs you should supply the graph using the <code>graph</code> argument.</p>
</td></tr>
<tr><td><code id="spde.matern.operators_+3A_m">m</code></td>
<td>
<p>The order of the rational approximation, which needs to be a
positive integer. The default value is 1.</p>
</td></tr>
<tr><td><code id="spde.matern.operators_+3A_type">type</code></td>
<td>
<p>The type of the rational approximation. The options are
&quot;covariance&quot; and &quot;operator&quot;. The default is &quot;covariance&quot;.</p>
</td></tr>
<tr><td><code id="spde.matern.operators_+3A_type_rational_approximation">type_rational_approximation</code></td>
<td>
<p>Which type of rational
approximation should be used? The current types are
&quot;chebfun&quot;, &quot;brasil&quot; or &quot;chebfunLB&quot;.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The approximation is based on a rational approximation of the
fractional operator <code class="reqn">(\kappa(s)^2 -\Delta)^\beta</code>, where
<code class="reqn">\beta = (\nu + d/2)/2</code>. This results in an approximate model
on the form </p>
<p style="text-align: center;"><code class="reqn">P_l u(s) = P_r W,</code>
</p>
<p> where <code class="reqn">P_j = p_j(L)</code> are
non-fractional operators defined in terms of polynomials <code class="reqn">p_j</code> for
<code class="reqn">j=l,r</code>. The order of <code class="reqn">p_r</code> is given by <code>m</code> and the order
of <code class="reqn">p_l</code> is <code class="reqn">m + m_\beta</code> where <code class="reqn">m_\beta</code> is the integer
part of <code class="reqn">\beta</code> if <code class="reqn">\beta&gt;1</code> and <code class="reqn">m_\beta = 1</code> otherwise.
</p>
<p>The discrete approximation can be written as <code class="reqn">u = P_r x</code> where
<code class="reqn">x \sim N(0,Q^{-1})</code>
and <code class="reqn">Q = P_l^T C^{-1} P_l</code>. Note that the matrices <code class="reqn">P_r</code> and
<code class="reqn">Q</code> may be be ill-conditioned for <code class="reqn">m&gt;1</code>.
In this case, the metehods in <code><a href="#topic+operator.operations">operator.operations()</a></code>
should be used for operations involving the matrices, since
these methods are more numerically stable.
</p>


<h3>Value</h3>

<p><code>spde.matern.operators</code> returns an object of
class &quot;rSPDEobj. This object contains the
quantities listed in the output of <code><a href="#topic+fractional.operators">fractional.operators()</a></code>
as well as the smoothness parameter <code class="reqn">\nu</code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+fractional.operators">fractional.operators()</a></code>,
<code><a href="#topic+spde.matern.operators">spde.matern.operators()</a></code>,
<code><a href="#topic+matern.operators">matern.operators()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Sample non-stationary Matern field on R
tau &lt;- 1
nu &lt;- 0.8

# create mass and stiffness matrices for a FEM discretization
x &lt;- seq(from = 0, to = 1, length.out = 101)
fem &lt;- rSPDE.fem1d(x)

# define a non-stationary range parameter
kappa &lt;- seq(from = 2, to = 20, length.out = length(x))
alpha &lt;- nu + 1/2
# compute rational approximation
op &lt;- spde.matern.operators(
  kappa = kappa, tau = tau, alpha = alpha,
  G = fem$G, C = fem$C, d = 1
)

# sample the field
u &lt;- simulate(op)

# plot the sample
plot(x, u, type = "l", ylab = "u(s)", xlab = "s")

</code></pre>

<hr>
<h2 id='summary.CBrSPDEobj'>Summarise CBrSPDE objects</h2><span id='topic+summary.CBrSPDEobj'></span><span id='topic+print.summary.CBrSPDEobj'></span><span id='topic+print.CBrSPDEobj'></span>

<h3>Description</h3>

<p>Summary method for class &quot;CBrSPDEobj&quot;
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'CBrSPDEobj'
summary(object, ...)

## S3 method for class 'summary.CBrSPDEobj'
print(x, ...)

## S3 method for class 'CBrSPDEobj'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary.CBrSPDEobj_+3A_object">object</code></td>
<td>
<p>an object of class &quot;CBrSPDEobj&quot;, usually, a result of a call
to <code><a href="#topic+matern.operators">matern.operators()</a></code>.</p>
</td></tr>
<tr><td><code id="summary.CBrSPDEobj_+3A_...">...</code></td>
<td>
<p>further arguments passed to or from other methods.</p>
</td></tr>
<tr><td><code id="summary.CBrSPDEobj_+3A_x">x</code></td>
<td>
<p>an object of class &quot;summary.CBrSPDEobj&quot;, usually, a result of a call
to <code><a href="#topic+summary.CBrSPDEobj">summary.CBrSPDEobj()</a></code>.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'># Compute the covariance-based rational approximation of a
# Gaussian process with a Matern covariance function on R
kappa &lt;- 10
sigma &lt;- 1
nu &lt;- 0.8
range &lt;- sqrt(8*nu)/kappa

# create mass and stiffness matrices for a FEM discretization
x &lt;- seq(from = 0, to = 1, length.out = 101)
fem &lt;- rSPDE.fem1d(x)

# compute rational approximation of covariance function at 0.5
tau &lt;- sqrt(gamma(nu) / (sigma^2 * kappa^(2 * nu) *
(4 * pi)^(1 / 2) * gamma(nu + 1 / 2)))
op_cov &lt;- matern.operators(
  loc_mesh = x, nu = nu,
  range = range, sigma = sigma, d = 1, m = 2,
  parameterization = "matern"
)

op_cov
</code></pre>

<hr>
<h2 id='summary.rspde_lme'>Summary Method for <code>rspde_lme</code> Objects.</h2><span id='topic+summary.rspde_lme'></span>

<h3>Description</h3>

<p>Function providing a summary of results related to mixed effects regression models with Whittle-Matern latent models.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'rspde_lme'
summary(object, all_times = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary.rspde_lme_+3A_object">object</code></td>
<td>
<p>an object of class &quot;rspde_lme&quot; containing results from the fitted model.</p>
</td></tr>
<tr><td><code id="summary.rspde_lme_+3A_all_times">all_times</code></td>
<td>
<p>Show all computed times.</p>
</td></tr>
<tr><td><code id="summary.rspde_lme_+3A_...">...</code></td>
<td>
<p>not used.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <code>summary_rspde_lme</code> containing several
informations of a <em>rspde_lme</em> object.
</p>

<hr>
<h2 id='summary.rspde_result'>Summary for posteriors of field parameters for an <code>inla_rspde</code>
model from a <code>rspde_result</code> object</h2><span id='topic+summary.rspde_result'></span>

<h3>Description</h3>

<p>Summary for posteriors of rSPDE field parameters in
their original scales.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'rspde_result'
summary(object, digits = 6, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary.rspde_result_+3A_object">object</code></td>
<td>
<p>A <code>rspde_result</code> object.</p>
</td></tr>
<tr><td><code id="summary.rspde_result_+3A_digits">digits</code></td>
<td>
<p>integer, used for number formatting with signif()</p>
</td></tr>
<tr><td><code id="summary.rspde_result_+3A_...">...</code></td>
<td>
<p>Currently not used.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a <code>data.frame</code>
containing the summary.
</p>


<h3>Examples</h3>

<pre><code class='language-R'> #tryCatch version
tryCatch({
if (requireNamespace("INLA", quietly = TRUE)){
library(INLA)

set.seed(123)

m &lt;- 100
loc_2d_mesh &lt;- matrix(runif(m * 2), m, 2)
mesh_2d &lt;- inla.mesh.2d(
  loc = loc_2d_mesh,
  cutoff = 0.05,
  max.edge = c(0.1, 0.5)
)
sigma &lt;- 1
range &lt;- 0.2
nu &lt;- 0.8
kappa &lt;- sqrt(8 * nu) / range
op &lt;- matern.operators(
  mesh = mesh_2d, nu = nu,
  range = range, sigma = sigma, m = 2,
  parameterization = "matern"
)
u &lt;- simulate(op)
A &lt;- inla.spde.make.A(
  mesh = mesh_2d,
  loc = loc_2d_mesh
)
sigma.e &lt;- 0.1
y &lt;- A %*% u + rnorm(m) * sigma.e
Abar &lt;- rspde.make.A(mesh = mesh_2d, loc = loc_2d_mesh)
mesh.index &lt;- rspde.make.index(name = "field", mesh = mesh_2d)
st.dat &lt;- inla.stack(
  data = list(y = as.vector(y)),
  A = Abar,
  effects = mesh.index
)
rspde_model &lt;- rspde.matern(
  mesh = mesh_2d,
  nu.upper.bound = 2
)
f &lt;- y ~ -1 + f(field, model = rspde_model)
rspde_fit &lt;- inla(f,
  data = inla.stack.data(st.dat),
  family = "gaussian",
  control.predictor =
    list(A = inla.stack.A(st.dat))
)
result &lt;- rspde.result(rspde_fit, "field", rspde_model)
summary(result)
}
#stable.tryCatch
}, error = function(e){print("Could not run the example")})


</code></pre>

<hr>
<h2 id='summary.rSPDEobj'>Summarise rSPDE objects</h2><span id='topic+summary.rSPDEobj'></span><span id='topic+print.summary.rSPDEobj'></span><span id='topic+print.rSPDEobj'></span>

<h3>Description</h3>

<p>Summary method for class &quot;rSPDEobj&quot;
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'rSPDEobj'
summary(object, ...)

## S3 method for class 'summary.rSPDEobj'
print(x, ...)

## S3 method for class 'rSPDEobj'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary.rSPDEobj_+3A_object">object</code></td>
<td>
<p>an object of class &quot;rSPDEobj&quot;, usually, a result of a call
to <code><a href="#topic+fractional.operators">fractional.operators()</a></code>, <code><a href="#topic+matern.operators">matern.operators()</a></code>, or
<code><a href="#topic+spde.matern.operators">spde.matern.operators()</a></code>.</p>
</td></tr>
<tr><td><code id="summary.rSPDEobj_+3A_...">...</code></td>
<td>
<p>further arguments passed to or from other methods.</p>
</td></tr>
<tr><td><code id="summary.rSPDEobj_+3A_x">x</code></td>
<td>
<p>an object of class &quot;summary.rSPDEobj&quot;, usually, a result of a call
to <code><a href="#topic+summary.rSPDEobj">summary.rSPDEobj()</a></code>.</p>
</td></tr>
</table>

<hr>
<h2 id='update.CBrSPDEobj'>Update parameters of CBrSPDEobj objects</h2><span id='topic+update.CBrSPDEobj'></span>

<h3>Description</h3>

<p>Function to change the parameters of a CBrSPDEobj object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'CBrSPDEobj'
update(
  object,
  user_nu = NULL,
  user_alpha = NULL,
  user_kappa = NULL,
  user_tau = NULL,
  user_sigma = NULL,
  user_range = NULL,
  user_theta = NULL,
  user_m = NULL,
  mesh = NULL,
  loc_mesh = NULL,
  graph = NULL,
  range_mesh = NULL,
  compute_higher_order = object$higher_order,
  parameterization = NULL,
  type_rational_approximation = object$type_rational_approximation,
  return_block_list = object$return_block_list,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="update.CBrSPDEobj_+3A_object">object</code></td>
<td>
<p>The covariance-based rational SPDE approximation,
computed using <code><a href="#topic+matern.operators">matern.operators()</a></code></p>
</td></tr>
<tr><td><code id="update.CBrSPDEobj_+3A_user_nu">user_nu</code></td>
<td>
<p>If non-null, update the shape parameter of the
covariance function. Will be used if parameterization is 'matern'.</p>
</td></tr>
<tr><td><code id="update.CBrSPDEobj_+3A_user_alpha">user_alpha</code></td>
<td>
<p>If non-null, update the fractional SPDE order parameter. Will be used if parameterization is 'spde'.</p>
</td></tr>
<tr><td><code id="update.CBrSPDEobj_+3A_user_kappa">user_kappa</code></td>
<td>
<p>If non-null, update the parameter kappa of the SPDE. Will be used if parameterization is 'spde'.</p>
</td></tr>
<tr><td><code id="update.CBrSPDEobj_+3A_user_tau">user_tau</code></td>
<td>
<p>If non-null, update the parameter tau of the SPDE. Will be used if parameterization is 'spde'.</p>
</td></tr>
<tr><td><code id="update.CBrSPDEobj_+3A_user_sigma">user_sigma</code></td>
<td>
<p>If non-null, update the standard deviation of
the covariance function. Will be used if parameterization is 'matern'.</p>
</td></tr>
<tr><td><code id="update.CBrSPDEobj_+3A_user_range">user_range</code></td>
<td>
<p>If non-null, update the range parameter
of the covariance function. Will be used if parameterization is 'matern'.</p>
</td></tr>
<tr><td><code id="update.CBrSPDEobj_+3A_user_theta">user_theta</code></td>
<td>
<p>For non-stationary models. If non-null, update the vector of parameters.</p>
</td></tr>
<tr><td><code id="update.CBrSPDEobj_+3A_user_m">user_m</code></td>
<td>
<p>If non-null, update the order of the rational
approximation, which needs to be a positive integer.</p>
</td></tr>
<tr><td><code id="update.CBrSPDEobj_+3A_mesh">mesh</code></td>
<td>
<p>An optional inla mesh. Replaces <code>d</code>, <code>C</code> and <code>G</code>.</p>
</td></tr>
<tr><td><code id="update.CBrSPDEobj_+3A_loc_mesh">loc_mesh</code></td>
<td>
<p>The mesh locations used to construct the matrices C and G. This option should be provided if one wants to use the <code>rspde_lme()</code> function and will not provide neither graph nor mesh. Only works for 1d data. Does not work for metric graphs. For metric graphs you should supply the graph using the <code>graph</code> argument.</p>
</td></tr>
<tr><td><code id="update.CBrSPDEobj_+3A_graph">graph</code></td>
<td>
<p>An optional <code>metric_graph</code> object. Replaces <code>d</code>, <code>C</code> and <code>G</code>.</p>
</td></tr>
<tr><td><code id="update.CBrSPDEobj_+3A_range_mesh">range_mesh</code></td>
<td>
<p>The range of the mesh. Will be used to provide starting values for the parameters. Will be used if <code>mesh</code> and <code>graph</code> are <code>NULL</code>, and if one of the parameters (kappa or tau for spde parameterization, or sigma or range for matern parameterization) are not provided.</p>
</td></tr>
<tr><td><code id="update.CBrSPDEobj_+3A_compute_higher_order">compute_higher_order</code></td>
<td>
<p>Logical. Should the higher order
finite element matrices be computed?</p>
</td></tr>
<tr><td><code id="update.CBrSPDEobj_+3A_parameterization">parameterization</code></td>
<td>
<p>If non-null, update the parameterization. Only works for stationary models.</p>
</td></tr>
<tr><td><code id="update.CBrSPDEobj_+3A_type_rational_approximation">type_rational_approximation</code></td>
<td>
<p>Which type of rational
approximation should be used? The current types are &quot;chebfun&quot;,
&quot;brasil&quot; or &quot;chebfunLB&quot;.</p>
</td></tr>
<tr><td><code id="update.CBrSPDEobj_+3A_return_block_list">return_block_list</code></td>
<td>
<p>Logical. For <code>type = "covariance"</code>,
should the block parts of the precision matrix be returned
separately as a list?</p>
</td></tr>
<tr><td><code id="update.CBrSPDEobj_+3A_...">...</code></td>
<td>
<p>Currently not used.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>It returns an object of class &quot;CBrSPDEobj. This object contains the
same quantities listed in the output of <code><a href="#topic+matern.operators">matern.operators()</a></code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+simulate.CBrSPDEobj">simulate.CBrSPDEobj()</a></code>, <code><a href="#topic+matern.operators">matern.operators()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Compute the covariance-based rational approximation of a
# Gaussian process with a Matern covariance function on R
kappa &lt;- 10
sigma &lt;- 1
nu &lt;- 0.8
range &lt;- sqrt(8*nu)/kappa

# create mass and stiffness matrices for a FEM discretization
x &lt;- seq(from = 0, to = 1, length.out = 101)
fem &lt;- rSPDE.fem1d(x)

# compute rational approximation of covariance function at 0.5
op_cov &lt;- matern.operators(
  loc_mesh = x, nu = nu,
  range = range, sigma = sigma, d = 1, m = 2,
  parameterization = "matern"
)
op_cov

# Update the range parameter of the model:
op_cov &lt;- update(op_cov, user_kappa = 20)
op_cov

</code></pre>

<hr>
<h2 id='update.rSPDEobj'>Update parameters of rSPDEobj objects</h2><span id='topic+update.rSPDEobj'></span>

<h3>Description</h3>

<p>Function to change the parameters of a rSPDEobj object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'rSPDEobj'
update(
  object,
  user_nu = NULL,
  user_alpha = NULL,
  user_kappa = NULL,
  user_sigma = NULL,
  user_range = NULL,
  user_tau = NULL,
  user_theta = NULL,
  user_m = NULL,
  mesh = NULL,
  loc_mesh = NULL,
  graph = NULL,
  range_mesh = NULL,
  parameterization = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="update.rSPDEobj_+3A_object">object</code></td>
<td>
<p>The operator-based rational SPDE approximation,
computed using <code><a href="#topic+matern.operators">matern.operators()</a></code> with <code>type="operator"</code></p>
</td></tr>
<tr><td><code id="update.rSPDEobj_+3A_user_nu">user_nu</code></td>
<td>
<p>If non-null, update the shape parameter
of the covariance function.</p>
</td></tr>
<tr><td><code id="update.rSPDEobj_+3A_user_alpha">user_alpha</code></td>
<td>
<p>If non-null, update the fractional order.</p>
</td></tr>
<tr><td><code id="update.rSPDEobj_+3A_user_kappa">user_kappa</code></td>
<td>
<p>If non-null, update the range parameter
of the covariance function.</p>
</td></tr>
<tr><td><code id="update.rSPDEobj_+3A_user_sigma">user_sigma</code></td>
<td>
<p>If non-null, update the standard deviation of
the covariance function.</p>
</td></tr>
<tr><td><code id="update.rSPDEobj_+3A_user_range">user_range</code></td>
<td>
<p>If non-null, update the range parameter
of the covariance function.</p>
</td></tr>
<tr><td><code id="update.rSPDEobj_+3A_user_tau">user_tau</code></td>
<td>
<p>If non-null, update the parameter tau.</p>
</td></tr>
<tr><td><code id="update.rSPDEobj_+3A_user_theta">user_theta</code></td>
<td>
<p>If non-null, update the parameter theta, that connects
tau and kappa to the model matrices.</p>
</td></tr>
<tr><td><code id="update.rSPDEobj_+3A_user_m">user_m</code></td>
<td>
<p>If non-null, update the order of the rational
approximation, which needs to be a positive integer.</p>
</td></tr>
<tr><td><code id="update.rSPDEobj_+3A_mesh">mesh</code></td>
<td>
<p>An optional inla mesh. Replaces <code>d</code>, <code>C</code> and <code>G</code>.</p>
</td></tr>
<tr><td><code id="update.rSPDEobj_+3A_loc_mesh">loc_mesh</code></td>
<td>
<p>The mesh locations used to construct the matrices C and G. This option should be provided if one wants to use the <code>rspde_lme()</code> function and will not provide neither graph nor mesh. Only works for 1d data. Does not work for metric graphs. For metric graphs you should supply the graph using the <code>graph</code> argument.</p>
</td></tr>
<tr><td><code id="update.rSPDEobj_+3A_graph">graph</code></td>
<td>
<p>An optional <code>metric_graph</code> object. Replaces <code>d</code>, <code>C</code> and <code>G</code>.</p>
</td></tr>
<tr><td><code id="update.rSPDEobj_+3A_range_mesh">range_mesh</code></td>
<td>
<p>The range of the mesh. Will be used to provide starting values for the parameters. Will be used if <code>mesh</code> and <code>graph</code> are <code>NULL</code>, and if one of the parameters (kappa or tau for spde parameterization, or sigma or range for matern parameterization) are not provided.</p>
</td></tr>
<tr><td><code id="update.rSPDEobj_+3A_parameterization">parameterization</code></td>
<td>
<p>If non-null, update the parameterization. Only works for stationary models.</p>
</td></tr>
<tr><td><code id="update.rSPDEobj_+3A_...">...</code></td>
<td>
<p>Currently not used.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>It returns an object of class &quot;rSPDEobj. This object contains the
same quantities listed in the output of <code><a href="#topic+matern.operators">matern.operators()</a></code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+simulate.rSPDEobj">simulate.rSPDEobj()</a></code>, <code><a href="#topic+matern.operators">matern.operators()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Compute the operator-based rational approximation of a
# Gaussian process with a Matern covariance function on R
kappa &lt;- 10
sigma &lt;- 1
nu &lt;- 0.8
range &lt;- sqrt(8*nu)/kappa

# create mass and stiffness matrices for a FEM discretization
x &lt;- seq(from = 0, to = 1, length.out = 101)
fem &lt;- rSPDE.fem1d(x)

# compute rational approximation of covariance function at 0.5
op &lt;- matern.operators(
  loc_mesh = x, nu = nu,
  range = range, sigma = sigma, d = 1, m = 2, type = "operator",
  parameterization = "matern"
)
op

# Update the range parameter of the model:
op &lt;- update(op, user_kappa = 20)
op

</code></pre>

<hr>
<h2 id='variogram.intrinsic.spde'>Variogram of intrinsic SPDE model</h2><span id='topic+variogram.intrinsic.spde'></span>

<h3>Description</h3>

<p>Variogram <code class="reqn">\gamma(s_0,s)</code> of intrinsic SPDE
model
</p>
<p style="text-align: center;"><code class="reqn">(-\Delta)^{\beta/2}(\kappa^2-\Delta)^{\alpha/2} (\tau u) = \mathcal{W}</code>
</p>

<p>with Neumann boundary conditions and a mean-zero constraint on a
square <code class="reqn">[0,L]^d</code> for <code class="reqn">d=1</code> or <code class="reqn">d=2</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>variogram.intrinsic.spde(
  s0 = NULL,
  s = NULL,
  kappa = NULL,
  alpha = NULL,
  beta = NULL,
  tau = 1,
  L = NULL,
  N = 100,
  d = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="variogram.intrinsic.spde_+3A_s0">s0</code></td>
<td>
<p>The location where the variogram should be evaluated, either
a double for 1d or a vector for 2d</p>
</td></tr>
<tr><td><code id="variogram.intrinsic.spde_+3A_s">s</code></td>
<td>
<p>A vector (in 1d) or matrix (in 2d) with all locations where the
variogram is computed</p>
</td></tr>
<tr><td><code id="variogram.intrinsic.spde_+3A_kappa">kappa</code></td>
<td>
<p>Range parameter.</p>
</td></tr>
<tr><td><code id="variogram.intrinsic.spde_+3A_alpha">alpha</code></td>
<td>
<p>Smoothness parameter.</p>
</td></tr>
<tr><td><code id="variogram.intrinsic.spde_+3A_beta">beta</code></td>
<td>
<p>Smoothness parameter.</p>
</td></tr>
<tr><td><code id="variogram.intrinsic.spde_+3A_tau">tau</code></td>
<td>
<p>Precision parameter.</p>
</td></tr>
<tr><td><code id="variogram.intrinsic.spde_+3A_l">L</code></td>
<td>
<p>The side length of the square domain.</p>
</td></tr>
<tr><td><code id="variogram.intrinsic.spde_+3A_n">N</code></td>
<td>
<p>The number of terms in the Karhunen-Loeve expansion.</p>
</td></tr>
<tr><td><code id="variogram.intrinsic.spde_+3A_d">d</code></td>
<td>
<p>The dimension (1 or 2).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The variogram is computed based on a Karhunen-Loeve expansion of the
covariance function.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+intrinsic.matern.operators">intrinsic.matern.operators()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if (requireNamespace("RSpectra", quietly = TRUE)){
 x &lt;- seq(from = 0, to = 10, length.out = 201)
 beta &lt;- 1
 alpha &lt;- 1
 kappa &lt;- 1
 op &lt;- intrinsic.matern.operators(kappa = kappa, tau = 1, alpha = alpha, 
                                 beta = beta, loc_mesh = x, d=1) 
 # Compute and plot the variogram of the model
 Sigma &lt;- op$A %*% solve(op$Q,t(op$A))
 One &lt;- rep(1, times = ncol(Sigma))
 D &lt;- diag(Sigma)
 Gamma &lt;- 0.5*(One %*% t(D) + D %*% t(One) - 2 * Sigma)
 k &lt;- 100
 plot(x, Gamma[k, ], type = "l")
 lines(x, 
      variogram.intrinsic.spde(x[k], x, kappa, alpha, beta, L = 10, d = 1),
      col=2, lty = 2)
}
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
