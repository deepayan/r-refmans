<!DOCTYPE html><html lang="en"><head><title>Help for package rSPDE</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {rSPDE}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#rSPDE-package'><p>Rational approximations of fractional SPDEs.</p></a></li>
<li><a href='#augment.rspde_lme'><p>Augment data with information from a <code>rspde_lme</code> object</p></a></li>
<li><a href='#bru_get_mapper.inla_rspde'><p>rSPDE inlabru mapper</p></a></li>
<li><a href='#bru_get_mapper.inla_rspde_anisotropic2d'><p>rSPDE anisotropic inlabru mapper</p></a></li>
<li><a href='#bru_get_mapper.inla_rspde_matern1d'><p>rSPDE stationary inlabru mapper</p></a></li>
<li><a href='#bru_get_mapper.inla_rspde_spacetime'><p>rSPDE space time inlabru mapper</p></a></li>
<li><a href='#construct.spde.matern.loglike'><p>Constructor of Matern loglikelihood functions for non-stationary models.</p></a></li>
<li><a href='#create_train_test_indices'><p>Create train and test splits to be used in the <code>cross_validation</code> function</p></a></li>
<li><a href='#cross_validation'><p>Perform cross-validation on a list of fitted models.</p></a></li>
<li><a href='#folded.matern.covariance.1d'><p>The 1d folded Matern covariance function</p></a></li>
<li><a href='#folded.matern.covariance.2d'><p>The 2d folded Matern covariance function</p></a></li>
<li><a href='#fractional.operators'><p>Rational approximations of fractional operators</p></a></li>
<li><a href='#get.initial.values.rSPDE'><p>Initial values for log-likelihood optimization in rSPDE models</p>
with a latent stationary Gaussian Matern model</a></li>
<li><a href='#gg_df'><p>Data frame for result objects from R-INLA fitted models to be used in ggplot2</p></a></li>
<li><a href='#gg_df.rspde_result'><p>Data frame for rspde_result objects to be used in ggplot2</p></a></li>
<li><a href='#glance.rspde_lme'><p>Glance at an <code>rspde_lme</code> object</p></a></li>
<li><a href='#graph_data_rspde'><p>Data extraction from metric graphs for 'rSPDE' models</p></a></li>
<li><a href='#group_predict'><p>Perform prediction on a testing set based on a training set</p></a></li>
<li><a href='#intrinsic.matern.operators'><p>Covariance-based approximations of intrinsic fields</p></a></li>
<li><a href='#matern.covariance'><p>The Matern covariance function</p></a></li>
<li><a href='#matern.operators'><p>Rational approximations of stationary Gaussian Matern random fields</p></a></li>
<li><a href='#matern.rational'><p>Rational approximation of the Matern fields on intervals and metric graphs</p></a></li>
<li><a href='#matern.rational.cov'><p>Rational approximation of the Matern covariance</p></a></li>
<li><a href='#matern2d.operators'><p>Rational approximations of stationary anisotropic Gaussian Matern random fields</p></a></li>
<li><a href='#operator.operations'><p>Operations with the Pr and Pl operators</p></a></li>
<li><a href='#precision'><p>Get the precision matrix of CBrSPDEobj objects</p></a></li>
<li><a href='#precision.CBrSPDEobj2d'><p>Get the precision matrix of CBrSPDEobj2d objects</p></a></li>
<li><a href='#precision.inla_rspde'><p>Get the precision matrix of <code>inla_rspde</code> objects</p></a></li>
<li><a href='#precision.rSPDEobj1d'><p>Get the precision matrix of rSPDEobj1d objects</p></a></li>
<li><a href='#precision.spacetimeobj'><p>Get the precision matrix of spacetimeobj objects</p></a></li>
<li><a href='#predict.CBrSPDEobj'><p>Prediction of a fractional SPDE using the covariance-based</p>
rational SPDE approximation</a></li>
<li><a href='#predict.CBrSPDEobj2d'><p>Prediction of an anisotropic Whittle-Matern field</p></a></li>
<li><a href='#predict.inla_rspde_matern1d'><p>Predict method for 'inlabru' stationary Matern 1d models</p></a></li>
<li><a href='#predict.rspde_lme'><p>Prediction of a mixed effects regression model on a metric graph.</p></a></li>
<li><a href='#predict.rSPDEobj'><p>Prediction of a fractional SPDE using a rational SPDE approximation</p></a></li>
<li><a href='#predict.spacetimeobj'><p>Prediction of a space-time SPDE</p></a></li>
<li><a href='#rational.order'><p>Get the order of rational approximation.</p></a></li>
<li><a href='#rational.order+26lt+3B-'><p>Changing the order of the rational approximation</p></a></li>
<li><a href='#rational.type'><p>Get type of rational approximation.</p></a></li>
<li><a href='#rational.type+26lt+3B-'><p>Changing the type of the rational approximation</p></a></li>
<li><a href='#require.nowarnings'><p>Warnings free loading of add-on packages</p></a></li>
<li><a href='#rspde_lme'><p>rSPDE linear mixed effects models</p></a></li>
<li><a href='#rSPDE.A1d'><p>Observation matrix for finite element discretization on R</p></a></li>
<li><a href='#rspde.anistropic2d'><p>Rational approximations of stationary anisotropic Gaussian Matern random fields</p></a></li>
<li><a href='#rSPDE.Ast'><p>Observation matrix for space-time models</p></a></li>
<li><a href='#rSPDE.construct.matern.loglike'><p>Constructor of Matern loglikelihood functions.</p></a></li>
<li><a href='#rSPDE.fem1d'><p>Finite element calculations for problems on R</p></a></li>
<li><a href='#rSPDE.fem2d'><p>Finite element calculations for problems in 2D</p></a></li>
<li><a href='#rSPDE.loglike'><p>Object-based log-likelihood function for latent Gaussian</p>
fractional SPDE model</a></li>
<li><a href='#rspde.make.A'><p>Observation/prediction matrices for rSPDE models.</p></a></li>
<li><a href='#rspde.make.index'><p>rSPDE model index vector generation</p></a></li>
<li><a href='#rspde.matern'><p>Matern rSPDE model object for INLA</p></a></li>
<li><a href='#rspde.matern.intrinsic'><p>Intrinsic Matern rSPDE model object for INLA</p></a></li>
<li><a href='#rSPDE.matern.loglike'><p>Object-based log-likelihood function for latent Gaussian fractional</p>
SPDE model using the rational approximations</a></li>
<li><a href='#rspde.matern.precision'><p>Precision matrix of the covariance-based rational approximation of</p>
stationary Gaussian Matern random fields</a></li>
<li><a href='#rspde.matern.precision.integer'><p>Precision matrix of stationary Gaussian Matern</p>
random fields with integer covariance exponent</a></li>
<li><a href='#rspde.matern.precision.integer.opt'><p>Optimized precision matrix of stationary Gaussian Matern</p>
random fields with integer covariance exponent</a></li>
<li><a href='#rspde.matern.precision.opt'><p>Optimized precision matrix of the covariance-based rational</p>
approximation</a></li>
<li><a href='#rspde.matern1d'><p>Matern rSPDE model object for INLA</p></a></li>
<li><a href='#rspde.mesh.project'><p>Calculate a lattice projection to/from an <code>inla.mesh</code> for</p>
rSPDE objects</a></li>
<li><a href='#rspde.metric_graph'><p>Matern rSPDE model object for metric graphs in INLA</p></a></li>
<li><a href='#rspde.result'><p>rSPDE result extraction from INLA estimation results</p></a></li>
<li><a href='#rspde.spacetime'><p>Space-Time Random Fields via SPDE Approximation</p></a></li>
<li><a href='#simulate.CBrSPDEobj'><p>Simulation of a fractional SPDE using the</p>
covariance-based rational SPDE approximation</a></li>
<li><a href='#simulate.CBrSPDEobj2d'><p>Simulation of a fractional SPDE using the</p>
covariance-based rational SPDE approximation</a></li>
<li><a href='#simulate.intrinsicCBrSPDEobj'><p>Simulation of a fractional intrinsic SPDE using the</p>
covariance-based rational SPDE approximation</a></li>
<li><a href='#simulate.rSPDEobj'><p>Simulation of a fractional SPDE using a rational SPDE approximation</p></a></li>
<li><a href='#simulate.rSPDEobj1d'><p>Simulation of a Matern field using a rational SPDE approximation</p></a></li>
<li><a href='#simulate.spacetimeobj'><p>Simulation of space-time models</p></a></li>
<li><a href='#spacetime.operators'><p>Space-time random fields</p></a></li>
<li><a href='#spde.make.A'><p>Observation/prediction matrices for rSPDE models with integer smoothness.</p></a></li>
<li><a href='#spde.matern.loglike'><p>Parameter-based log-likelihood for a latent Gaussian Matern SPDE model</p>
using a rational SPDE approximation</a></li>
<li><a href='#spde.matern.operators'><p>Rational approximations of non-stationary Gaussian SPDE Matern random fields</p></a></li>
<li><a href='#summary.CBrSPDEobj'><p>Summarise CBrSPDE objects</p></a></li>
<li><a href='#summary.CBrSPDEobj2d'><p>Summarise CBrSPDEobj2d objects</p></a></li>
<li><a href='#summary.rspde_lme'><p>Summary Method for <code>rspde_lme</code> Objects.</p></a></li>
<li><a href='#summary.rspde_result'><p>Summary for posteriors of field parameters for an <code>inla_rspde</code></p>
model from a <code>rspde_result</code> object</a></li>
<li><a href='#summary.rSPDEobj'><p>Summarise rSPDE objects</p></a></li>
<li><a href='#summary.rSPDEobj1d'><p>Summarise rSPDE objects without FEM</p></a></li>
<li><a href='#summary.spacetimeobj'><p>Summarise spacetime objects</p></a></li>
<li><a href='#transform_parameters_anisotropic'><p>Transform Anisotropic SPDE Model Parameters to Original Scale</p></a></li>
<li><a href='#transform_parameters_spacetime'><p>Transform Spacetime SPDE Model Parameters to Original Scale</p></a></li>
<li><a href='#update.CBrSPDEobj'><p>Update parameters of CBrSPDEobj objects</p></a></li>
<li><a href='#update.CBrSPDEobj2d'><p>Update parameters of CBrSPDEobj2d objects</p></a></li>
<li><a href='#update.rSPDEobj'><p>Update parameters of rSPDEobj objects</p></a></li>
<li><a href='#update.rSPDEobj1d'><p>Update parameters of rSPDEobj1d objects</p></a></li>
<li><a href='#update.spacetimeobj'><p>Update parameters of spacetimeobj objects</p></a></li>
<li><a href='#variogram.intrinsic.spde'><p>Variogram of intrinsic SPDE model</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Rational Approximations of Fractional Stochastic Partial
Differential Equations</td>
</tr>
<tr>
<td>Version:</td>
<td>2.4.0</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>David Bolin &lt;davidbolin@gmail.com&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Functions that compute rational approximations of fractional elliptic stochastic partial differential equations. The package also contains functions for common statistical usage of these approximations. The main references for rSPDE are Bolin, Simas and Xiong (2023) &lt;<a href="https://doi.org/10.1080%2F10618600.2023.2231051">doi:10.1080/10618600.2023.2231051</a>&gt; for the covariance-based method and Bolin and Kirchner (2020) &lt;<a href="https://doi.org/10.1080%2F10618600.2019.1665537">doi:10.1080/10618600.2019.1665537</a>&gt; for the operator-based rational approximation. These can be generated by the citation function in R.</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.5.0), Matrix</td>
</tr>
<tr>
<td>Imports:</td>
<td>stats, methods, fmesher (&ge; 0.2.0), lifecycle, broom</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL (&ge; 3)</a> | file LICENSE</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://davidbolin.github.io/rSPDE/">https://davidbolin.github.io/rSPDE/</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.3.2</td>
</tr>
<tr>
<td>Suggests:</td>
<td>knitr, rmarkdown, INLA (&ge; 24.12.01), testthat, ggplot2,
lattice, splancs, optimParallel, RSpectra, numDeriv, inlabru
(&ge; 2.12.0), sn, viridis, doParallel, foreach, tidyr, dplyr,
GeneralizedHyperbolic, gridExtra, MetricGraph, sf</td>
</tr>
<tr>
<td>Additional_repositories:</td>
<td><a href="https://inla.r-inla-download.org/R/testing">https://inla.r-inla-download.org/R/testing</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/davidbolin/rSPDE/issues">https://github.com/davidbolin/rSPDE/issues</a></td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Author:</td>
<td>David Bolin [cre, aut],
  Alexandre Simas [aut],
  Finn Lindgren [ctb]</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-12-02 01:08:23 UTC; debusta</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-12-02 15:40:01 UTC</td>
</tr>
</table>
<hr>
<h2 id='rSPDE-package'>Rational approximations of fractional SPDEs.</h2><span id='topic+rSPDE'></span><span id='topic+rSPDE-package'></span>

<h3>Description</h3>

<p><code>rSPDE</code> is used for approximating fractional elliptic SPDEs
</p>
<p style="text-align: center;"><code class="reqn">L^\beta (\tau u(s)) = W,</code>
</p>

<p>where <code class="reqn">L</code> is a differential operator and <code class="reqn">\beta&gt;0</code>
is a general fractional power.
</p>


<h3>Details</h3>

<p>The approximation is based on a rational approximation of the
fractional operator, and allows for computationally efficient
inference and simulation.
</p>
<p>The main functions for computing rational approximation objects are:
</p>

<dl>
<dt><code><a href="#topic+fractional.operators">fractional.operators()</a></code></dt><dd><p>works for general
rational operators</p>
</dd>
<dt><code><a href="#topic+matern.operators">matern.operators()</a></code></dt><dd><p> works for random fields with
stationary Matern covariance functions</p>
</dd>
<dt><code><a href="#topic+spde.matern.operators">spde.matern.operators()</a></code></dt><dd><p> works for random fields with
defined as solutions to a possibly non-stationary Matern-type SPDE model.</p>
</dd>
<dt><code><a href="#topic+rspde.matern">rspde.matern()</a></code></dt><dd><p>R-INLA implementation of the
covariance-based rational approximation for random fields with
stationary Matern covariance functions</p>
</dd>
</dl>

<p>Basic statistical operations such as likelihood evaluations (see
<code style="white-space: pre;">&#8288;[rSPDE.loglike], [rSPDE.matern.loglike]&#8288;</code>) and kriging
predictions (see <code style="white-space: pre;">&#8288;[predict.rSPDEobj], [predict.CBrSPDEobj]&#8288;</code>)
using the rational approximations are also implemented.
</p>
<p>For illustration purposes, the package contains a simple FEM implementation
for models on R. For spatial models,
the FEM implementation in the <code>R-INLA</code> package is recommended.
</p>
<p>For a more detailed introduction to the package, see the rSPDE Vignettes.
</p>


<h3>Author(s)</h3>

<p><strong>Maintainer</strong>: David Bolin <a href="mailto:davidbolin@gmail.com">davidbolin@gmail.com</a>
</p>
<p>Authors:
</p>

<ul>
<li><p> Alexandre Simas <a href="mailto:alexandre.impa@gmail.com">alexandre.impa@gmail.com</a>
</p>
</li></ul>

<p>Other contributors:
</p>

<ul>
<li><p> Finn Lindgren <a href="mailto:finn.lindgren@ed.ac.uk">finn.lindgren@ed.ac.uk</a> [contributor]
</p>
</li></ul>



<h3>See Also</h3>

<p>Useful links:
</p>

<ul>
<li> <p><a href="https://davidbolin.github.io/rSPDE/">https://davidbolin.github.io/rSPDE/</a>
</p>
</li>
<li><p> Report bugs at <a href="https://github.com/davidbolin/rSPDE/issues">https://github.com/davidbolin/rSPDE/issues</a>
</p>
</li></ul>


<hr>
<h2 id='augment.rspde_lme'>Augment data with information from a <code>rspde_lme</code> object</h2><span id='topic+augment.rspde_lme'></span><span id='topic+augment'></span>

<h3>Description</h3>

<p>Augment accepts a model object and a dataset and adds information about each observation in the dataset. It includes
predicted values in the <code>.fitted</code> column, residuals in the <code>.resid</code> column, and standard errors for the fitted values in a <code>.se.fit</code> column.
It also contains the New columns always begin with a . prefix to avoid overwriting columns in the original dataset.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'rspde_lme'
augment(
  x,
  newdata = NULL,
  loc = NULL,
  mesh = FALSE,
  which_repl = NULL,
  se_fit = FALSE,
  conf_int = FALSE,
  pred_int = FALSE,
  level = 0.95,
  n_samples = 100,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="augment.rspde_lme_+3A_x">x</code></td>
<td>
<p>A <code>rspde_lme</code> object.</p>
</td></tr>
<tr><td><code id="augment.rspde_lme_+3A_newdata">newdata</code></td>
<td>
<p>A <code>data.frame</code> or a <code>list</code> containing the covariates, the edge
number and the distance on edge for the locations to obtain the prediction. If <code>NULL</code>, the fitted values will be given for the original locations where the model was fitted.</p>
</td></tr>
<tr><td><code id="augment.rspde_lme_+3A_loc">loc</code></td>
<td>
<p>Prediction locations. Can either be a <code>data.frame</code>, a <code>matrix</code> or a character vector, that contains the names of the columns of the coordinates of the locations. For models using <code>metric_graph</code> objects, plase use <code>edge_number</code> and <code>distance_on_edge</code> instead.</p>
</td></tr>
<tr><td><code id="augment.rspde_lme_+3A_mesh">mesh</code></td>
<td>
<p>Obtain predictions for mesh nodes? The graph must have a mesh, and either <code>only_latent</code> is set to TRUE or the model does not have covariates.</p>
</td></tr>
<tr><td><code id="augment.rspde_lme_+3A_which_repl">which_repl</code></td>
<td>
<p>Which replicates to obtain the prediction. If <code>NULL</code> predictions
will be obtained for all replicates. Default is <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="augment.rspde_lme_+3A_se_fit">se_fit</code></td>
<td>
<p>Logical indicating whether or not a .se.fit column should be added to the augmented output. If TRUE, it only returns a non-NA value if type of prediction is 'link'.</p>
</td></tr>
<tr><td><code id="augment.rspde_lme_+3A_conf_int">conf_int</code></td>
<td>
<p>Logical indicating whether or not confidence intervals for the fitted variable should be built.</p>
</td></tr>
<tr><td><code id="augment.rspde_lme_+3A_pred_int">pred_int</code></td>
<td>
<p>Logical indicating whether or not prediction intervals for future observations should be built.</p>
</td></tr>
<tr><td><code id="augment.rspde_lme_+3A_level">level</code></td>
<td>
<p>Level of confidence and prediction intervals if they are constructed.</p>
</td></tr>
<tr><td><code id="augment.rspde_lme_+3A_n_samples">n_samples</code></td>
<td>
<p>Number of samples when computing prediction intervals.</p>
</td></tr>
<tr><td><code id="augment.rspde_lme_+3A_...">...</code></td>
<td>
<p>Additional arguments. Expert use only.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code><a href="tidyr.html#topic+reexports">tidyr::tibble()</a></code> with columns:
</p>

<ul>
<li> <p><code>.fitted</code> Fitted or predicted value.
</p>
</li>
<li> <p><code>.fittedlwrconf</code> Lower bound of the confidence interval, if conf_int = TRUE
</p>
</li>
<li> <p><code>.fitteduprconf</code> Upper bound of the confidence interval, if conf_int = TRUE
</p>
</li>
<li> <p><code>.fittedlwrpred</code> Lower bound of the prediction interval, if pred_int = TRUE
</p>
</li>
<li> <p><code>.fitteduprpred</code> Upper bound of the prediction interval, if pred_int = TRUE
</p>
</li>
<li> <p><code>.fixed</code> Prediction of the fixed effects.
</p>
</li>
<li> <p><code>.random</code> Prediction of the random effects.
</p>
</li>
<li> <p><code>.resid</code> The ordinary residuals, that is, the difference between observed and fitted values.
</p>
</li>
<li> <p><code>.se_fit</code> Standard errors of fitted values, if se_fit = TRUE.
</p>
</li></ul>



<h3>See Also</h3>

<p><a href="#topic+glance.rspde_lme">glance.rspde_lme</a>
</p>

<hr>
<h2 id='bru_get_mapper.inla_rspde'>rSPDE inlabru mapper</h2><span id='topic+bru_get_mapper.inla_rspde'></span><span id='topic+ibm_n.bru_mapper_inla_rspde'></span><span id='topic+ibm_values.bru_mapper_inla_rspde'></span><span id='topic+ibm_jacobian.bru_mapper_inla_rspde'></span>

<h3>Description</h3>

<p>rSPDE inlabru mapper
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bru_get_mapper.inla_rspde(model, ...)

ibm_n.bru_mapper_inla_rspde(mapper, ...)

ibm_values.bru_mapper_inla_rspde(mapper, ...)

ibm_jacobian.bru_mapper_inla_rspde(mapper, input, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="bru_get_mapper.inla_rspde_+3A_model">model</code></td>
<td>
<p>An <code>inla_rspde</code> object for which to construct or extract a mapper</p>
</td></tr>
<tr><td><code id="bru_get_mapper.inla_rspde_+3A_...">...</code></td>
<td>
<p>Arguments passed on to other methods</p>
</td></tr>
<tr><td><code id="bru_get_mapper.inla_rspde_+3A_mapper">mapper</code></td>
<td>
<p>A <code>bru_mapper_inla_rspde</code> object</p>
</td></tr>
<tr><td><code id="bru_get_mapper.inla_rspde_+3A_input">input</code></td>
<td>
<p>The values for which to produce a mapping matrix</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'> #tryCatch version
tryCatch({
if (requireNamespace("INLA", quietly = TRUE) &amp;&amp;
  requireNamespace("inlabru", quietly = TRUE)) {
  library(INLA)
  library(inlabru)

  set.seed(123)
  m &lt;- 100
  loc_2d_mesh &lt;- matrix(runif(m * 2), m, 2)
  mesh_2d &lt;- inla.mesh.2d(
    loc = loc_2d_mesh,
    cutoff = 0.05,
    max.edge = c(0.1, 0.5)
  )
  sigma &lt;- 1
  range &lt;- 0.2
  nu &lt;- 0.8
  kappa &lt;- sqrt(8 * nu) / range
  op &lt;- matern.operators(
    mesh = mesh_2d, nu = nu,
    range = range, sigma = sigma, m = 2,
    parameterization = "matern"
  )
  u &lt;- simulate(op)
  A &lt;- inla.spde.make.A(
    mesh = mesh_2d,
    loc = loc_2d_mesh
  )
  sigma.e &lt;- 0.1
  y &lt;- A %*% u + rnorm(m) * sigma.e
  y &lt;- as.vector(y)

  data_df &lt;- data.frame(
    y = y, x1 = loc_2d_mesh[, 1],
    x2 = loc_2d_mesh[, 2]
  )
  rspde_model &lt;- rspde.matern(
    mesh = mesh_2d,
    nu_upper_bound = 2
  )

  cmp &lt;- y ~ Intercept(1) +
    field(cbind(x1,x2), model = rspde_model)


  rspde_fit &lt;- bru(cmp, data = data_df)
  summary(rspde_fit)
}
#stable.tryCatch
}, error = function(e){print("Could not run the example")})

</code></pre>

<hr>
<h2 id='bru_get_mapper.inla_rspde_anisotropic2d'>rSPDE anisotropic inlabru mapper</h2><span id='topic+bru_get_mapper.inla_rspde_anisotropic2d'></span>

<h3>Description</h3>

<p>rSPDE anisotropic inlabru mapper
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bru_get_mapper.inla_rspde_anisotropic2d(model, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="bru_get_mapper.inla_rspde_anisotropic2d_+3A_model">model</code></td>
<td>
<p>An <code>inla_rspde_anisotropic2d</code> object for which to construct or extract a mapper</p>
</td></tr>
<tr><td><code id="bru_get_mapper.inla_rspde_anisotropic2d_+3A_...">...</code></td>
<td>
<p>Arguments passed on to other methods</p>
</td></tr>
</table>

<hr>
<h2 id='bru_get_mapper.inla_rspde_matern1d'>rSPDE stationary inlabru mapper</h2><span id='topic+bru_get_mapper.inla_rspde_matern1d'></span><span id='topic+ibm_n.bru_mapper_inla_rspde_matern1d'></span><span id='topic+ibm_values.bru_mapper_inla_rspde_matern1d'></span><span id='topic+ibm_jacobian.bru_mapper_inla_rspde_matern1d'></span>

<h3>Description</h3>

<p>rSPDE stationary inlabru mapper
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bru_get_mapper.inla_rspde_matern1d(model, ...)

ibm_n.bru_mapper_inla_rspde_matern1d(mapper, ...)

ibm_values.bru_mapper_inla_rspde_matern1d(mapper, ...)

ibm_jacobian.bru_mapper_inla_rspde_matern1d(mapper, input, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="bru_get_mapper.inla_rspde_matern1d_+3A_model">model</code></td>
<td>
<p>An <code>inla_rspde_matern1d</code> object for which to construct or extract a mapper</p>
</td></tr>
<tr><td><code id="bru_get_mapper.inla_rspde_matern1d_+3A_...">...</code></td>
<td>
<p>Arguments passed on to other methods</p>
</td></tr>
<tr><td><code id="bru_get_mapper.inla_rspde_matern1d_+3A_mapper">mapper</code></td>
<td>
<p>A <code>bru_mapper_inla_rspde_matern1d</code> object</p>
</td></tr>
<tr><td><code id="bru_get_mapper.inla_rspde_matern1d_+3A_input">input</code></td>
<td>
<p>The values for which to produce a mapping matrix</p>
</td></tr>
</table>

<hr>
<h2 id='bru_get_mapper.inla_rspde_spacetime'>rSPDE space time inlabru mapper</h2><span id='topic+bru_get_mapper.inla_rspde_spacetime'></span>

<h3>Description</h3>

<p>rSPDE space time inlabru mapper
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bru_get_mapper.inla_rspde_spacetime(model, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="bru_get_mapper.inla_rspde_spacetime_+3A_model">model</code></td>
<td>
<p>An <code>inla_rspde_spacetime</code> object for which to construct or extract a mapper</p>
</td></tr>
<tr><td><code id="bru_get_mapper.inla_rspde_spacetime_+3A_...">...</code></td>
<td>
<p>Arguments passed on to other methods</p>
</td></tr>
</table>

<hr>
<h2 id='construct.spde.matern.loglike'>Constructor of Matern loglikelihood functions for non-stationary models.</h2><span id='topic+construct.spde.matern.loglike'></span>

<h3>Description</h3>

<p>This function evaluates the log-likelihood function for observations
of a non-stationary Gaussian process defined as the solution to the SPDE
</p>
<p style="text-align: center;"><code class="reqn">(\kappa(s) - \Delta)^\beta (\tau(s)u(s)) = W.</code>
</p>

<p>The observations are assumed to be generated as
<code class="reqn">Y_i = u(s_i) + \epsilon_i</code>, where
<code class="reqn">\epsilon_i</code> are
iid mean-zero Gaussian variables. The latent model is approximated using a
rational approximation of the fractional SPDE model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>construct.spde.matern.loglike(
  object,
  Y,
  A,
  sigma.e = NULL,
  mu = 0,
  nu = NULL,
  m = NULL,
  log_scale = TRUE,
  return_negative_likelihood = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="construct.spde.matern.loglike_+3A_object">object</code></td>
<td>
<p>The rational SPDE approximation,
computed using <code><a href="#topic+matern.operators">matern.operators()</a></code></p>
</td></tr>
<tr><td><code id="construct.spde.matern.loglike_+3A_y">Y</code></td>
<td>
<p>The observations, either a vector or a matrix where
the columns correspond to independent replicates of observations.</p>
</td></tr>
<tr><td><code id="construct.spde.matern.loglike_+3A_a">A</code></td>
<td>
<p>An observation matrix that links the measurement location to the
finite element basis.</p>
</td></tr>
<tr><td><code id="construct.spde.matern.loglike_+3A_sigma.e">sigma.e</code></td>
<td>
<p>IF non-null, the standard deviation of the measurement noise will be kept fixed in
the returned likelihood.</p>
</td></tr>
<tr><td><code id="construct.spde.matern.loglike_+3A_mu">mu</code></td>
<td>
<p>Expectation vector of the latent field (default = 0).</p>
</td></tr>
<tr><td><code id="construct.spde.matern.loglike_+3A_nu">nu</code></td>
<td>
<p>If non-null, the shape parameter will be kept fixed in the returned likelihood.</p>
</td></tr>
<tr><td><code id="construct.spde.matern.loglike_+3A_m">m</code></td>
<td>
<p>If non-null, update the order of the rational approximation,
which needs to be a positive integer.</p>
</td></tr>
<tr><td><code id="construct.spde.matern.loglike_+3A_log_scale">log_scale</code></td>
<td>
<p>Should the parameters be evaluated in log-scale?</p>
</td></tr>
<tr><td><code id="construct.spde.matern.loglike_+3A_return_negative_likelihood">return_negative_likelihood</code></td>
<td>
<p>Return minus the likelihood to turn the maximization into a minimization?</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The log-likelihood function. The parameters of the returned function
are given in the order theta, nu, sigma.e, whenever they are available.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+matern.operators">matern.operators()</a></code>, <code><a href="#topic+predict.CBrSPDEobj">predict.CBrSPDEobj()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># this example illustrates how the function can be used for maximum
# likelihood estimation
# Sample a Gaussian Matern process on R using a rational approximation
set.seed(123)
sigma.e &lt;- 0.1
n.rep &lt;- 10
n.obs &lt;- 100
n.x &lt;- 51
# create mass and stiffness matrices for a FEM discretization
x &lt;- seq(from = 0, to = 1, length.out = n.x)
fem &lt;- rSPDE.fem1d(x)
tau &lt;- rep(0.5, n.x)
nu &lt;- 0.8
alpha &lt;- nu + 0.5
kappa &lt;- rep(1, n.x)
# Matern parameterization
# compute rational approximation
op &lt;- spde.matern.operators(
  loc_mesh = x,
  kappa = kappa, tau = tau, alpha = alpha,
  parameterization = "spde", d = 1
)
# Sample the model
u &lt;- simulate(op, n.rep)
# Create some data
obs.loc &lt;- runif(n = n.obs, min = 0, max = 1)
A &lt;- rSPDE.A1d(x, obs.loc)
noise &lt;- rnorm(n.obs * n.rep)
dim(noise) &lt;- c(n.obs, n.rep)
Y &lt;- as.matrix(A %*% u + sigma.e * noise)
# define negative likelihood function for optimization using matern.loglike
mlik &lt;- construct.spde.matern.loglike(op, Y, A)
#' #The parameters can now be estimated by minimizing mlik with optim

# Choose some reasonable starting values depending on the size of the domain
theta0 &lt;- log(c(1 / sqrt(var(c(Y))), sqrt(8), 0.9, 0.01))
# run estimation and display the results
theta &lt;- optim(theta0, mlik)
print(data.frame(
  tau = c(tau[1], exp(theta$par[1])), kappa = c(kappa[1], exp(theta$par[2])),
  nu = c(nu, exp(theta$par[3])), sigma.e = c(sigma.e, exp(theta$par[4])),
  row.names = c("Truth", "Estimates")
))


# SPDE parameterization
# compute rational approximation
op &lt;- spde.matern.operators(
  kappa = kappa, tau = tau, alpha = alpha,
  loc_mesh = x, d = 1,
  parameterization = "spde"
)
# Sample the model
u &lt;- simulate(op, n.rep)
# Create some data
obs.loc &lt;- runif(n = n.obs, min = 0, max = 1)
A &lt;- rSPDE.A1d(x, obs.loc)
noise &lt;- rnorm(n.obs * n.rep)
dim(noise) &lt;- c(n.obs, n.rep)
Y &lt;- as.matrix(A %*% u + sigma.e * noise)
# define negative likelihood function for optimization using matern.loglike
mlik &lt;- construct.spde.matern.loglike(op, Y, A)
#' #The parameters can now be estimated by minimizing mlik with optim

# Choose some reasonable starting values depending on the size of the domain
theta0 &lt;- log(c(1 / sqrt(var(c(Y))), sqrt(8), 0.9, 0.01))
# run estimation and display the results
theta &lt;- optim(theta0, mlik)
print(data.frame(
  tau = c(tau[1], exp(theta$par[1])), kappa = c(kappa[1], exp(theta$par[2])),
  nu = c(nu, exp(theta$par[3])), sigma.e = c(sigma.e, exp(theta$par[4])),
  row.names = c("Truth", "Estimates")
))

</code></pre>

<hr>
<h2 id='create_train_test_indices'>Create train and test splits to be used in the <code>cross_validation</code> function</h2><span id='topic+create_train_test_indices'></span>

<h3>Description</h3>

<p>Train and test splits
</p>


<h3>Usage</h3>

<pre><code class='language-R'>create_train_test_indices(
  data,
  cv_type = c("k-fold", "loo", "lpo"),
  k = 5,
  percentage = 20,
  number_folds = 10
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="create_train_test_indices_+3A_data">data</code></td>
<td>
<p>A <code>list</code>, <code>data.frame</code>, <code>SpatialPointsDataFrame</code> or <code>metric_graph_data</code> objects.</p>
</td></tr>
<tr><td><code id="create_train_test_indices_+3A_cv_type">cv_type</code></td>
<td>
<p>The type of the folding to be carried out. The options are <code>k-fold</code> for <code>k</code>-fold cross-validation, in which case the parameter <code>k</code> should be provided,
<code>loo</code>, for leave-one-out and <code>lpo</code> for leave-percentage-out, in this case, the parameter <code>percentage</code> should be given, and also the <code>number_folds</code>
with the number of folds to be done. The default is <code>k-fold</code>.</p>
</td></tr>
<tr><td><code id="create_train_test_indices_+3A_k">k</code></td>
<td>
<p>The number of folds to be used in <code>k</code>-fold cross-validation. Will only be used if <code>cv_type</code> is <code>k-fold</code>.</p>
</td></tr>
<tr><td><code id="create_train_test_indices_+3A_percentage">percentage</code></td>
<td>
<p>The percentage (from 1 to 99) of the data to be used to train the model. Will only be used if <code>cv_type</code> is <code>lpo</code>.</p>
</td></tr>
<tr><td><code id="create_train_test_indices_+3A_number_folds">number_folds</code></td>
<td>
<p>Number of folds to be done if <code>cv_type</code> is <code>lpo</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with two elements, <code>train</code> containing the training indices and <code>test</code> containing indices.
</p>

<hr>
<h2 id='cross_validation'>Perform cross-validation on a list of fitted models.</h2><span id='topic+cross_validation'></span>

<h3>Description</h3>

<p>Obtain several scores for a list of fitted models according
to a folding scheme.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cross_validation(
  models,
  model_names = NULL,
  scores = c("mse", "crps", "scrps", "dss"),
  cv_type = c("k-fold", "loo", "lpo"),
  k = 5,
  percentage = 20,
  number_folds = 10,
  n_samples = 1000,
  return_scores_folds = FALSE,
  orientation_results = c("negative", "positive"),
  include_best = TRUE,
  train_test_indexes = NULL,
  return_train_test = FALSE,
  return_post_samples = FALSE,
  return_true_test_values = FALSE,
  parallelize_RP = FALSE,
  n_cores_RP = parallel::detectCores() - 1,
  true_CV = TRUE,
  save_settings = FALSE,
  print = TRUE,
  fit_verbose = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="cross_validation_+3A_models">models</code></td>
<td>
<p>A fitted model obtained from calling the <code>bru()</code> function or a list of models fitted with the <code>bru()</code> function.</p>
</td></tr>
<tr><td><code id="cross_validation_+3A_model_names">model_names</code></td>
<td>
<p>A vector containing the names of the models to appear in the returned <code>data.frame</code>. If <code>NULL</code>, the names will be of the form <code style="white-space: pre;">&#8288;Model 1&#8288;</code>, <code style="white-space: pre;">&#8288;Model 2&#8288;</code>, and so on. By default, it will try to obtain the name from the models list.</p>
</td></tr>
<tr><td><code id="cross_validation_+3A_scores">scores</code></td>
<td>
<p>A vector containing the scores to be computed. The options are &quot;mse&quot;, &quot;crps&quot;, &quot;scrps&quot; and &quot;dss&quot;. By default, all scores are computed.</p>
</td></tr>
<tr><td><code id="cross_validation_+3A_cv_type">cv_type</code></td>
<td>
<p>The type of the folding to be carried out. The options are <code>k-fold</code> for <code>k</code>-fold cross-validation, in which case the parameter <code>k</code> should be provided,
<code>loo</code>, for leave-one-out and <code>lpo</code> for leave-percentage-out, in this case, the parameter <code>percentage</code> should be given, and also the <code>number_folds</code>
with the number of folds to be done. The default is <code>k-fold</code>.</p>
</td></tr>
<tr><td><code id="cross_validation_+3A_k">k</code></td>
<td>
<p>The number of folds to be used in <code>k</code>-fold cross-validation. Will only be used if <code>cv_type</code> is <code>k-fold</code>.</p>
</td></tr>
<tr><td><code id="cross_validation_+3A_percentage">percentage</code></td>
<td>
<p>The percentage (from 1 to 99) of the data to be used to train the model. Will only be used if <code>cv_type</code> is <code>lpo</code>.</p>
</td></tr>
<tr><td><code id="cross_validation_+3A_number_folds">number_folds</code></td>
<td>
<p>Number of folds to be done if <code>cv_type</code> is <code>lpo</code>.</p>
</td></tr>
<tr><td><code id="cross_validation_+3A_n_samples">n_samples</code></td>
<td>
<p>Number of samples to compute the posterior statistics to be used to compute the scores.</p>
</td></tr>
<tr><td><code id="cross_validation_+3A_return_scores_folds">return_scores_folds</code></td>
<td>
<p>If <code>TRUE</code>, the scores for each fold will also be returned.</p>
</td></tr>
<tr><td><code id="cross_validation_+3A_orientation_results">orientation_results</code></td>
<td>
<p>character vector. The options are &quot;negative&quot; and &quot;positive&quot;. If &quot;negative&quot;, the smaller the scores the better. If &quot;positive&quot;, the larger the scores the better.</p>
</td></tr>
<tr><td><code id="cross_validation_+3A_include_best">include_best</code></td>
<td>
<p>Should a row indicating which model was the best for each score be included?</p>
</td></tr>
<tr><td><code id="cross_validation_+3A_train_test_indexes">train_test_indexes</code></td>
<td>
<p>A list containing two entries <code>train</code>, which is a list whose elements are vectors of indexes of the training data, and <code>test</code>, which is a list whose elements are vectors of indexes of the test data.
Typically this will be returned list obtained by setting the argument <code>return_train_test</code> to <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="cross_validation_+3A_return_train_test">return_train_test</code></td>
<td>
<p>Logical. Should the training and test indexes be returned? If 'TRUE' the train and test indexes will the 'train_test' element of the returned list.</p>
</td></tr>
<tr><td><code id="cross_validation_+3A_return_post_samples">return_post_samples</code></td>
<td>
<p>If <code>TRUE</code> the posterior samples will be included in the returned list.</p>
</td></tr>
<tr><td><code id="cross_validation_+3A_return_true_test_values">return_true_test_values</code></td>
<td>
<p>If <code>TRUE</code> the true test values will be included in the returned list.</p>
</td></tr>
<tr><td><code id="cross_validation_+3A_parallelize_rp">parallelize_RP</code></td>
<td>
<p>Logical. Should the computation of CRPS and SCRPS (and for some cases, DSS) be parallelized?</p>
</td></tr>
<tr><td><code id="cross_validation_+3A_n_cores_rp">n_cores_RP</code></td>
<td>
<p>Number of cores to be used if <code>parallelize_rp</code> is <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="cross_validation_+3A_true_cv">true_CV</code></td>
<td>
<p>Should a <code>TRUE</code> cross-validation be performed? If <code>TRUE</code> the models will be fitted on the training dataset. If <code>FALSE</code>, the parameters will be kept fixed at the ones obtained in the result object.</p>
</td></tr>
<tr><td><code id="cross_validation_+3A_save_settings">save_settings</code></td>
<td>
<p>Logical. If <code>TRUE</code>, the settings used in the cross-validation will also be returned.</p>
</td></tr>
<tr><td><code id="cross_validation_+3A_print">print</code></td>
<td>
<p>Should partial results be printed throughout the computation?</p>
</td></tr>
<tr><td><code id="cross_validation_+3A_fit_verbose">fit_verbose</code></td>
<td>
<p>Should INLA's run during cross-validation be verbose?</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data.frame with the fitted models and the corresponding scores.
</p>

<hr>
<h2 id='folded.matern.covariance.1d'>The 1d folded Matern covariance function</h2><span id='topic+folded.matern.covariance.1d'></span>

<h3>Description</h3>

<p><code>folded.matern.covariance.1d</code> evaluates the 1d
folded Matern covariance function over an interval <code class="reqn">[0,L]</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>folded.matern.covariance.1d(
  h,
  m,
  kappa,
  nu,
  sigma,
  L = 1,
  N = 10,
  boundary = c("neumann", "dirichlet", "periodic")
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="folded.matern.covariance.1d_+3A_h">h</code>, <code id="folded.matern.covariance.1d_+3A_m">m</code></td>
<td>
<p>Vectors of arguments of the covariance function.</p>
</td></tr>
<tr><td><code id="folded.matern.covariance.1d_+3A_kappa">kappa</code></td>
<td>
<p>Range parameter.</p>
</td></tr>
<tr><td><code id="folded.matern.covariance.1d_+3A_nu">nu</code></td>
<td>
<p>Shape parameter.</p>
</td></tr>
<tr><td><code id="folded.matern.covariance.1d_+3A_sigma">sigma</code></td>
<td>
<p>Standard deviation.</p>
</td></tr>
<tr><td><code id="folded.matern.covariance.1d_+3A_l">L</code></td>
<td>
<p>The upper bound of the interval <code class="reqn">[0,L]</code>. By default, <code>L=1</code>.</p>
</td></tr>
<tr><td><code id="folded.matern.covariance.1d_+3A_n">N</code></td>
<td>
<p>The truncation parameter.</p>
</td></tr>
<tr><td><code id="folded.matern.covariance.1d_+3A_boundary">boundary</code></td>
<td>
<p>The boundary condition. The possible conditions
are <code>"neumann"</code> (default), <code>"dirichlet"</code> or
<code>"periodic"</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>folded.matern.covariance.1d</code> evaluates the 1d folded Matern
covariance function over an interval <code class="reqn">[0,L]</code> under different
boundary conditions. For periodic boundary conditions
</p>
<p style="text-align: center;"><code class="reqn">C_{\mathcal{P}}(h,m) = \sum_{k=-\infty}^{\infty} (C(h-m+2kL),</code>
</p>

<p>for Neumann boundary conditions
</p>
<p style="text-align: center;"><code class="reqn">C_{\mathcal{N}}(h,m) = \sum_{k=-\infty}^{\infty}
(C(h-m+2kL)+C(h+m+2kL)),</code>
</p>

<p>and for Dirichlet boundary conditions:
</p>
<p style="text-align: center;"><code class="reqn">C_{\mathcal{D}}(h,m) = \sum_{k=-\infty}^{\infty}
(C(h-m+2kL)-C(h+m+2kL)),</code>
</p>

<p>where <code class="reqn">C(\cdot)</code> is the Matern covariance function:
</p>
<p style="text-align: center;"><code class="reqn">C(h) = \frac{\sigma^2}{2^{\nu-1}\Gamma(\nu)}(\kappa h)^\nu
K_\nu(\kappa h).</code>
</p>

<p>We consider the truncation:
</p>
<p style="text-align: center;"><code class="reqn">C_{{\mathcal{P}},N}(h,m) = \sum_{k=-N}^{N} C(h-m+2kL),
C_{\mathcal{N},N}(h,m) = \sum_{k=-\infty}^{\infty}
(C(h-m+2kL)+C(h+m+2kL)),</code>
</p>

<p>and
</p>
<p style="text-align: center;"><code class="reqn">C_{\mathcal{D},N}(h,m) = \sum_{k=-N}^{N}
(C(h-m+2kL)-C(h+m+2kL)).</code>
</p>



<h3>Value</h3>

<p>A matrix with the corresponding covariance values.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- seq(from = 0, to = 1, length.out = 101)
plot(x, folded.matern.covariance.1d(rep(0.5, length(x)), x,
  kappa = 10, nu = 1 / 5, sigma = 1
),
type = "l", ylab = "C(h)", xlab = "h"
)

</code></pre>

<hr>
<h2 id='folded.matern.covariance.2d'>The 2d folded Matern covariance function</h2><span id='topic+folded.matern.covariance.2d'></span>

<h3>Description</h3>

<p><code>folded.matern.covariance.2d</code> evaluates the 2d
folded Matern covariance function over an interval
<code class="reqn">[0,L]\times [0,L]</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>folded.matern.covariance.2d(
  h,
  m,
  kappa,
  nu,
  sigma,
  L = 1,
  N = 10,
  boundary = c("neumann", "dirichlet", "periodic", "R2")
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="folded.matern.covariance.2d_+3A_h">h</code>, <code id="folded.matern.covariance.2d_+3A_m">m</code></td>
<td>
<p>Vectors with two coordinates.</p>
</td></tr>
<tr><td><code id="folded.matern.covariance.2d_+3A_kappa">kappa</code></td>
<td>
<p>Range parameter.</p>
</td></tr>
<tr><td><code id="folded.matern.covariance.2d_+3A_nu">nu</code></td>
<td>
<p>Shape parameter.</p>
</td></tr>
<tr><td><code id="folded.matern.covariance.2d_+3A_sigma">sigma</code></td>
<td>
<p>Standard deviation.</p>
</td></tr>
<tr><td><code id="folded.matern.covariance.2d_+3A_l">L</code></td>
<td>
<p>The upper bound of the square <code class="reqn">[0,L]\times [0,L]</code>.
By default, <code>L=1</code>.</p>
</td></tr>
<tr><td><code id="folded.matern.covariance.2d_+3A_n">N</code></td>
<td>
<p>The truncation parameter.</p>
</td></tr>
<tr><td><code id="folded.matern.covariance.2d_+3A_boundary">boundary</code></td>
<td>
<p>The boundary condition. The possible conditions
are <code>"neumann"</code> (default), <code>"dirichlet"</code>,
<code>"periodic"</code> or <code>"R2"</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>folded.matern.covariance.2d</code> evaluates the 1d folded
Matern covariance function over an interval
<code class="reqn">[0,L]\times [0,L]</code> under different boundary conditions.
For periodic boundary conditions
</p>
<p style="text-align: center;"><code class="reqn">C_{\mathcal{P}}((h_1,h_2),(m_1,m_2)) =
\sum_{k_2=-\infty}^\infty \sum_{k_1=-\infty}^{\infty}
(C(\|(h_1-m_1+2k_1L,h_2-m_2+2k_2L)\|),</code>
</p>

<p>for Neumann boundary conditions
</p>
<p style="text-align: center;"><code class="reqn">C_{\mathcal{N}}((h_1,h_2),(m_1,m_2)) =
\sum_{k_2=-\infty}^\infty \sum_{k_1=-\infty}^{\infty}
(C(\|(h_1-m_1+2k_1L,h_2-m_2+2k_2L)\|)+C(\|(h_1-m_1+2k_1L,
h_2+m_2+2k_2L)\|)+C(\|(h_1+m_1+2k_1L,h_2-m_2+2k_2L)\|)+
C(\|(h_1+m_1+2k_1L,h_2+m_2+2k_2L)\|)),</code>
</p>

<p>and for Dirichlet boundary conditions:
</p>
<p style="text-align: center;"><code class="reqn">C_{\mathcal{D}}((h_1,h_2),(m_1,m_2)) = \sum_{k_2=-\infty}^\infty
\sum_{k_1=-\infty}^{\infty} (C(\|(h_1-m_1+2k_1L,h_2-m_2+2k_2L)\|)-
C(\|(h_1-m_1+2k_1L,h_2+m_2+2k_2L)\|)-C(\|(h_1+m_1+2k_1L,
h_2-m_2+2k_2L)\|)+C(\|(h_1+m_1+2k_1L,h_2+m_2+2k_2L)\|)),</code>
</p>

<p>where <code class="reqn">C(\cdot)</code> is the Matern covariance function:
</p>
<p style="text-align: center;"><code class="reqn">C(h) = \frac{\sigma^2}{2^{\nu-1}\Gamma(\nu)}
(\kappa h)^\nu K_\nu(\kappa h).</code>
</p>

<p>We consider the truncation for <code class="reqn">k_1,k_2</code> from <code class="reqn">-N</code> to <code class="reqn">N</code>.
</p>


<h3>Value</h3>

<p>The correspoding covariance.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>h &lt;- c(0.5, 0.5)
m &lt;- c(0.5, 0.5)
folded.matern.covariance.2d(h, m, kappa = 10, nu = 1 / 5, sigma = 1)

</code></pre>

<hr>
<h2 id='fractional.operators'>Rational approximations of fractional operators</h2><span id='topic+fractional.operators'></span>

<h3>Description</h3>

<p><code>fractional.operators</code> is used for computing an approximation,
which can be used for inference and simulation, of the fractional SPDE
</p>
<p style="text-align: center;"><code class="reqn">L^\beta (\tau u(s)) = W.</code>
</p>

<p>Here <code class="reqn">L</code> is a differential operator, <code class="reqn">\beta&gt;0</code> is
the fractional power, <code class="reqn">\tau</code> is a positive scalar or vector that
scales the variance of the solution <code class="reqn">u</code>, and <code class="reqn">W</code> is white noise.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fractional.operators(L, beta, C, scale.factor, m = 1, tau = 1)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="fractional.operators_+3A_l">L</code></td>
<td>
<p>A finite element discretization of the operator <code class="reqn">L</code>.</p>
</td></tr>
<tr><td><code id="fractional.operators_+3A_beta">beta</code></td>
<td>
<p>The positive fractional power.</p>
</td></tr>
<tr><td><code id="fractional.operators_+3A_c">C</code></td>
<td>
<p>The mass matrix of the finite element discretization.</p>
</td></tr>
<tr><td><code id="fractional.operators_+3A_scale.factor">scale.factor</code></td>
<td>
<p>A constant <code class="reqn">c</code> is a lower bound for the the smallest
eigenvalue of the non-discretized operator <code class="reqn">L</code>.</p>
</td></tr>
<tr><td><code id="fractional.operators_+3A_m">m</code></td>
<td>
<p>The order of the rational approximation, which needs to be a
positive integer. The default value is 1.
Higer values gives a more accurate approximation, which are more
computationally expensive to use for inference. Currently, the largest value
of m that is implemented is 4.</p>
</td></tr>
<tr><td><code id="fractional.operators_+3A_tau">tau</code></td>
<td>
<p>The constant or vector that scales the variance of the solution.
The default value is 1.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The approximation is based on a rational approximation of
the fractional operator, resulting in an
approximate model on the form </p>
<p style="text-align: center;"><code class="reqn">P_l u(s) = P_r W,</code>
</p>

<p>where <code class="reqn">P_j = p_j(L)</code> are non-fractional operators defined in terms of
polynomials <code class="reqn">p_j</code> for <code class="reqn">j=l,r</code>. The order of <code class="reqn">p_r</code> is given by
<code>m</code> and the order of <code class="reqn">p_l</code> is <code class="reqn">m + m_\beta</code>
where <code class="reqn">m_\beta</code> is the integer part of <code class="reqn">\beta</code> if <code class="reqn">\beta&gt;1</code> and
<code class="reqn">m_\beta = 1</code> otherwise.
</p>
<p>The discrete approximation can be written as <code class="reqn">u = P_r x</code> where
<code class="reqn">x \sim N(0,Q^{-1})</code> and <code class="reqn">Q = P_l^T C^{-1} P_l</code>.
Note that the matrices <code class="reqn">P_r</code> and <code class="reqn">Q</code> may be be ill-conditioned
for <code class="reqn">m&gt;1</code>. In this case, the methods in <code><a href="#topic+operator.operations">operator.operations()</a></code>
should be used for operations involving the matrices, since these methods
are more numerically stable.
</p>


<h3>Value</h3>

<p><code>fractional.operators</code> returns an object of class &quot;rSPDEobj&quot;.
This object contains the following quantities:
</p>
<table role = "presentation">
<tr><td><code>Pl</code></td>
<td>
<p>The operator <code class="reqn">P_l</code>.</p>
</td></tr>
<tr><td><code>Pr</code></td>
<td>
<p>The operator <code class="reqn">P_r</code>.</p>
</td></tr>
<tr><td><code>C</code></td>
<td>
<p>The mass lumped mass matrix.</p>
</td></tr>
<tr><td><code>Ci</code></td>
<td>
<p>The inverse of <code>C</code>.</p>
</td></tr>
<tr><td><code>m</code></td>
<td>
<p>The order of the rational approximation.</p>
</td></tr>
<tr><td><code>beta</code></td>
<td>
<p>The fractional power.</p>
</td></tr>
<tr><td><code>type</code></td>
<td>
<p>String indicating the type of approximation.</p>
</td></tr>
<tr><td><code>Q</code></td>
<td>
<p>The matrix <code>t(Pl) %*% solve(C,Pl)</code>.</p>
</td></tr>
<tr><td><code>type</code></td>
<td>
<p>String indicating the type of approximation.</p>
</td></tr>
<tr><td><code>Pl.factors</code></td>
<td>
<p>List with elements that can be used to assemble <code class="reqn">P_l</code>.</p>
</td></tr>
<tr><td><code>Pr.factors</code></td>
<td>
<p>List with elements that can be used to assemble <code class="reqn">P_r</code>.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+matern.operators">matern.operators()</a></code>, <code><a href="#topic+spde.matern.operators">spde.matern.operators()</a></code>,
<code><a href="#topic+matern.operators">matern.operators()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Compute rational approximation of a Gaussian process with a
# Matern covariance function on R
kappa &lt;- 10
sigma &lt;- 1
nu &lt;- 0.8

# create mass and stiffness matrices for a FEM discretization
x &lt;- seq(from = 0, to = 1, length.out = 101)
fem &lt;- rSPDE.fem1d(x)

# compute rational approximation of covariance function at 0.5
tau &lt;- sqrt(gamma(nu) / (sigma^2 * kappa^(2 * nu) *
  (4 * pi)^(1 / 2) * gamma(nu + 1 / 2)))
op &lt;- fractional.operators(
  L = fem$G + kappa^2 * fem$C, beta = (nu + 1 / 2) / 2,
  C = fem$C, scale.factor = kappa^2, tau = tau
)

v &lt;- t(rSPDE.A1d(x, 0.5))
c.approx &lt;- Sigma.mult(op, v)

# plot the result and compare with the true Matern covariance
plot(x, matern.covariance(abs(x - 0.5), kappa, nu, sigma),
  type = "l", ylab = "C(h)",
  xlab = "h", main = "Matern covariance and rational approximations"
)
lines(x, c.approx, col = 2)

</code></pre>

<hr>
<h2 id='get.initial.values.rSPDE'>Initial values for log-likelihood optimization in rSPDE models
with a latent stationary Gaussian Matern model</h2><span id='topic+get.initial.values.rSPDE'></span>

<h3>Description</h3>

<p>Auxiliar function to obtain domain-based initial values for
log-likelihood optimization in rSPDE models
with a latent stationary Gaussian Matern model
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get.initial.values.rSPDE(
  mesh = NULL,
  mesh.range = NULL,
  graph.obj = NULL,
  n.spde = 1,
  dim = NULL,
  B.tau = NULL,
  B.kappa = NULL,
  B.sigma = NULL,
  B.range = NULL,
  nu = NULL,
  parameterization = c("matern", "spde"),
  include.nu = TRUE,
  log.scale = TRUE,
  nu.upper.bound = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="get.initial.values.rSPDE_+3A_mesh">mesh</code></td>
<td>
<p>An in INLA mesh</p>
</td></tr>
<tr><td><code id="get.initial.values.rSPDE_+3A_mesh.range">mesh.range</code></td>
<td>
<p>The range of the mesh.</p>
</td></tr>
<tr><td><code id="get.initial.values.rSPDE_+3A_graph.obj">graph.obj</code></td>
<td>
<p>A <code>metric_graph</code> object. To be used in case both <code>mesh</code> and <code>mesh.range</code> are <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="get.initial.values.rSPDE_+3A_n.spde">n.spde</code></td>
<td>
<p>The number of basis functions in the mesh model.</p>
</td></tr>
<tr><td><code id="get.initial.values.rSPDE_+3A_dim">dim</code></td>
<td>
<p>The dimension of the domain.</p>
</td></tr>
<tr><td><code id="get.initial.values.rSPDE_+3A_b.tau">B.tau</code></td>
<td>
<p>Matrix with specification of log-linear model for <code class="reqn">\tau</code>. Will be used if <code>parameterization = 'spde'</code>.</p>
</td></tr>
<tr><td><code id="get.initial.values.rSPDE_+3A_b.kappa">B.kappa</code></td>
<td>
<p>Matrix with specification of log-linear model for <code class="reqn">\kappa</code>. Will be used if <code>parameterization = 'spde'</code>.</p>
</td></tr>
<tr><td><code id="get.initial.values.rSPDE_+3A_b.sigma">B.sigma</code></td>
<td>
<p>Matrix with specification of log-linear model for <code class="reqn">\sigma</code>. Will be used if <code>parameterization = 'matern'</code>.</p>
</td></tr>
<tr><td><code id="get.initial.values.rSPDE_+3A_b.range">B.range</code></td>
<td>
<p>Matrix with specification of log-linear model for <code class="reqn">\rho</code>, which is a range-like parameter (it is exactly the range parameter in the stationary case). Will be used if <code>parameterization = 'matern'</code>.</p>
</td></tr>
<tr><td><code id="get.initial.values.rSPDE_+3A_nu">nu</code></td>
<td>
<p>The smoothness parameter.</p>
</td></tr>
<tr><td><code id="get.initial.values.rSPDE_+3A_parameterization">parameterization</code></td>
<td>
<p>Which parameterization to use? <code>matern</code> uses range, std. deviation and nu (smoothness). <code>spde</code> uses kappa, tau and nu (smoothness). The default is <code>matern</code>.</p>
</td></tr>
<tr><td><code id="get.initial.values.rSPDE_+3A_include.nu">include.nu</code></td>
<td>
<p>Should we also provide an initial guess for nu?</p>
</td></tr>
<tr><td><code id="get.initial.values.rSPDE_+3A_log.scale">log.scale</code></td>
<td>
<p>Should the results be provided in log scale?</p>
</td></tr>
<tr><td><code id="get.initial.values.rSPDE_+3A_nu.upper.bound">nu.upper.bound</code></td>
<td>
<p>Should an upper bound for nu be considered?</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector of the form (theta_1,theta_2,theta_3) or where
theta_1 is the initial guess for tau, theta_2 is the initial guess for kappa
and theta_3 is the initial guess for nu.
</p>

<hr>
<h2 id='gg_df'>Data frame for result objects from R-INLA fitted models to be used in ggplot2</h2><span id='topic+gg_df'></span>

<h3>Description</h3>

<p>Data frame for result objects from R-INLA fitted models to be used in ggplot2
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gg_df(result, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="gg_df_+3A_result">result</code></td>
<td>
<p>a result object for which the data frame is desired</p>
</td></tr>
<tr><td><code id="gg_df_+3A_...">...</code></td>
<td>
<p>further arguments passed to or from other methods.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data frame containing the posterior densities.
</p>

<hr>
<h2 id='gg_df.rspde_result'>Data frame for rspde_result objects to be used in ggplot2</h2><span id='topic+gg_df.rspde_result'></span>

<h3>Description</h3>

<p>Returns a ggplot-friendly data-frame with the marginal posterior densities.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'rspde_result'
gg_df(
  result,
  parameter = result$params,
  transform = TRUE,
  restrict_x_axis = NULL,
  restrict_quantiles = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="gg_df.rspde_result_+3A_result">result</code></td>
<td>
<p>An rspde_result object.</p>
</td></tr>
<tr><td><code id="gg_df.rspde_result_+3A_parameter">parameter</code></td>
<td>
<p>Vector. Which parameters to get the posterior density in the data.frame? The options are <code>std.dev</code>, <code>range</code>, <code>tau</code>, <code>kappa</code> and <code>nu</code>.</p>
</td></tr>
<tr><td><code id="gg_df.rspde_result_+3A_transform">transform</code></td>
<td>
<p>Should the posterior density be given in the original scale?</p>
</td></tr>
<tr><td><code id="gg_df.rspde_result_+3A_restrict_x_axis">restrict_x_axis</code></td>
<td>
<p>Variables to restrict the range of x axis based on quantiles.</p>
</td></tr>
<tr><td><code id="gg_df.rspde_result_+3A_restrict_quantiles">restrict_quantiles</code></td>
<td>
<p>Named list of quantiles to restrict x axis. It should contain the name of the parameter
along with a vector with two elements specifying the lower and upper quantiles. The names should be
match the ones in result$params. For example, if we want to restrict nu to the 0.05 and 0.95 quantiles
we do <code>restrict_quantiles = c(0.05, 0.95)</code>.</p>
</td></tr>
<tr><td><code id="gg_df.rspde_result_+3A_...">...</code></td>
<td>
<p>currently not used.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data frame containing the posterior densities.
</p>

<hr>
<h2 id='glance.rspde_lme'>Glance at an <code>rspde_lme</code> object</h2><span id='topic+glance.rspde_lme'></span><span id='topic+glance'></span>

<h3>Description</h3>

<p>Glance accepts a <code>rspde_lme</code> object and returns a
<code><a href="tidyr.html#topic+reexports">tidyr::tibble()</a></code> with exactly one row of model summaries.
The summaries are the square root of the estimated variance of the measurement error, residual
degrees of freedom, AIC, BIC, log-likelihood,
the type of latent model used in the fit and the total number of observations.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'rspde_lme'
glance(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="glance.rspde_lme_+3A_x">x</code></td>
<td>
<p>An <code>rspde_lme</code> object.</p>
</td></tr>
<tr><td><code id="glance.rspde_lme_+3A_...">...</code></td>
<td>
<p>Currently not used.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code><a href="tidyr.html#topic+reexports">tidyr::tibble()</a></code> with exactly one row and columns:
</p>

<ul>
<li> <p><code>nobs</code> Number of observations used.
</p>
</li>
<li> <p><code>sigma</code> the square root of the estimated residual variance
</p>
</li>
<li> <p><code>logLik</code> The log-likelihood of the model.
</p>
</li>
<li> <p><code>AIC</code> Akaike's Information Criterion for the model.
</p>
</li>
<li> <p><code>BIC</code> Bayesian Information Criterion for the model.
</p>
</li>
<li> <p><code>deviance</code> Deviance of the model.
</p>
</li>
<li> <p><code>df.residual</code> Residual degrees of freedom.
</p>
</li>
<li> <p><code>model.type</code> Type of latent model fitted.
</p>
</li></ul>



<h3>See Also</h3>

<p><a href="#topic+augment.rspde_lme">augment.rspde_lme</a>
</p>

<hr>
<h2 id='graph_data_rspde'>Data extraction from metric graphs for 'rSPDE' models</h2><span id='topic+graph_data_rspde'></span>

<h3>Description</h3>

<p>Extracts data from metric graphs to be used by 'INLA' and 'inlabru'.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>graph_data_rspde(
  graph_rspde,
  name = "field",
  repl = NULL,
  repl_col = NULL,
  group = NULL,
  group_col = NULL,
  only_pred = FALSE,
  time = NULL,
  bru = FALSE,
  tibble = FALSE,
  drop_na = FALSE,
  drop_all_na = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="graph_data_rspde_+3A_graph_rspde">graph_rspde</code></td>
<td>
<p>An <code>inla_metric_graph_spde</code> or <code>inla_rspde_spacetime</code> object built with the
<code>rspde.metric_graph()</code> or <code>rspde.spacetime()</code> function.</p>
</td></tr>
<tr><td><code id="graph_data_rspde_+3A_name">name</code></td>
<td>
<p>A character string with the base name of the effect.</p>
</td></tr>
<tr><td><code id="graph_data_rspde_+3A_repl">repl</code></td>
<td>
<p>Which replicates? If there is no replicates, one
can set <code>repl</code> to <code>NULL</code>. If one wants all replicates,
then one sets to <code>repl</code> to <code>.all</code>.</p>
</td></tr>
<tr><td><code id="graph_data_rspde_+3A_repl_col">repl_col</code></td>
<td>
<p>Which &quot;column&quot; of the data contains the replicate variable?</p>
</td></tr>
<tr><td><code id="graph_data_rspde_+3A_group">group</code></td>
<td>
<p>Which groups? If there is no groups, one
can set <code>group</code> to <code>NULL</code>. If one wants all groups,
then one sets to <code>group</code> to <code>.all</code>.</p>
</td></tr>
<tr><td><code id="graph_data_rspde_+3A_group_col">group_col</code></td>
<td>
<p>Which &quot;column&quot; of the data contains the group variable?</p>
</td></tr>
<tr><td><code id="graph_data_rspde_+3A_only_pred">only_pred</code></td>
<td>
<p>Should only return the <code>data.frame</code> to the prediction data?</p>
</td></tr>
<tr><td><code id="graph_data_rspde_+3A_time">time</code></td>
<td>
<p>Column containing times for space time models. Not needed when using inlabru. Only for INLA implementation of space time model.</p>
</td></tr>
<tr><td><code id="graph_data_rspde_+3A_bru">bru</code></td>
<td>
<p>Should the data be processed for <code>inlabru</code>?</p>
</td></tr>
<tr><td><code id="graph_data_rspde_+3A_tibble">tibble</code></td>
<td>
<p>Should the data be returned as a <code>tidyr::tibble</code>?</p>
</td></tr>
<tr><td><code id="graph_data_rspde_+3A_drop_na">drop_na</code></td>
<td>
<p>Should the rows with at least one NA for one of the columns be removed? DEFAULT is <code>FALSE</code>. This option is turned to <code>FALSE</code> if <code>only_pred</code> is <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="graph_data_rspde_+3A_drop_all_na">drop_all_na</code></td>
<td>
<p>Should the rows with all variables being NA be removed? DEFAULT is <code>TRUE</code>. This option is turned to <code>FALSE</code> if <code>only_pred</code> is <code>TRUE</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An 'INLA' and 'inlabru' friendly list with the data.
</p>

<hr>
<h2 id='group_predict'>Perform prediction on a testing set based on a training set</h2><span id='topic+group_predict'></span>

<h3>Description</h3>

<p>Compute prediction of a formula-based expression on a testing set based on a training set.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>group_predict(
  models,
  model_names = NULL,
  formula = NULL,
  train_indices,
  test_indices,
  n_samples = 1000,
  pseudo_predict = TRUE,
  return_samples = FALSE,
  return_hyper_samples = FALSE,
  n_hyper_samples = 1,
  compute_posterior_means = TRUE,
  print = TRUE,
  fit_verbose = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="group_predict_+3A_models">models</code></td>
<td>
<p>A fitted model obtained from calling the <code>bru()</code> function or a list of models fitted with the <code>bru()</code> function.</p>
</td></tr>
<tr><td><code id="group_predict_+3A_model_names">model_names</code></td>
<td>
<p>A vector containing the names of the models to appear in the returned <code>data.frame</code>. If <code>NULL</code>, the names will be of the form <code style="white-space: pre;">&#8288;Model 1&#8288;</code>, <code style="white-space: pre;">&#8288;Model 2&#8288;</code>, and so on. By default, it will try to obtain the name from the models list.</p>
</td></tr>
<tr><td><code id="group_predict_+3A_formula">formula</code></td>
<td>
<p>A formula where the right hand side defines an R expression to evaluate for each generated sample. If <code style="white-space: pre;">&#8288;NULL``, the latent and hyperparameter states are returned as named list elements. See the manual for the &#8288;</code>predict<code style="white-space: pre;">&#8288;method in the&#8288;</code>inlabru' package.</p>
</td></tr>
<tr><td><code id="group_predict_+3A_train_indices">train_indices</code></td>
<td>
<p>A list containing the indices of the observations for the model to be trained, or a numerical vector containing the indices.</p>
</td></tr>
<tr><td><code id="group_predict_+3A_test_indices">test_indices</code></td>
<td>
<p>A list containing the indices of the test data, where the prediction will be done, or a numerical vector containing the indices.</p>
</td></tr>
<tr><td><code id="group_predict_+3A_n_samples">n_samples</code></td>
<td>
<p>Number of samples to compute the posterior statistics to be used to compute the scores.</p>
</td></tr>
<tr><td><code id="group_predict_+3A_pseudo_predict">pseudo_predict</code></td>
<td>
<p>If <code>TRUE</code>, the models will NOT be refitted on the training data, and the parameters obtained on the entire dataset will be used. If <code>FALSE</code>, the models will be refitted on the training data.</p>
</td></tr>
<tr><td><code id="group_predict_+3A_return_samples">return_samples</code></td>
<td>
<p>Should the posterior samples be returned?</p>
</td></tr>
<tr><td><code id="group_predict_+3A_return_hyper_samples">return_hyper_samples</code></td>
<td>
<p>Should samples for the hyperparameters be obtained?</p>
</td></tr>
<tr><td><code id="group_predict_+3A_n_hyper_samples">n_hyper_samples</code></td>
<td>
<p>Number of independent samples of the hyper parameters of size <code>n_samples</code>.</p>
</td></tr>
<tr><td><code id="group_predict_+3A_compute_posterior_means">compute_posterior_means</code></td>
<td>
<p>Should the posterior means be computed from the posterior samples?</p>
</td></tr>
<tr><td><code id="group_predict_+3A_print">print</code></td>
<td>
<p>Should partial results be printed throughout the computation?</p>
</td></tr>
<tr><td><code id="group_predict_+3A_fit_verbose">fit_verbose</code></td>
<td>
<p>Should INLA's run during the prediction be verbose?</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data.frame with the fitted models and the corresponding scores.
</p>

<hr>
<h2 id='intrinsic.matern.operators'>Covariance-based approximations of intrinsic fields</h2><span id='topic+intrinsic.matern.operators'></span>

<h3>Description</h3>

<p><code>intrinsic.matern.operators</code> is used for computing a
covariance-based rational SPDE approximation of intrinsic
fields on <code class="reqn">R^d</code> defined through the SPDE
</p>
<p style="text-align: center;"><code class="reqn">(-\Delta)^{\beta/2}(\kappa^2-\Delta)^{\alpha/2} (\tau u) = \mathcal{W}</code>
</p>



<h3>Usage</h3>

<pre><code class='language-R'>intrinsic.matern.operators(
  kappa,
  tau,
  alpha,
  beta = 1,
  G = NULL,
  C = NULL,
  d = NULL,
  mesh = NULL,
  graph = NULL,
  loc_mesh = NULL,
  m_alpha = 2,
  m_beta = 2,
  compute_higher_order = FALSE,
  return_block_list = FALSE,
  type_rational_approximation = c("chebfun", "brasil", "chebfunLB"),
  fem_mesh_matrices = NULL,
  scaling = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="intrinsic.matern.operators_+3A_kappa">kappa</code></td>
<td>
<p>range parameter</p>
</td></tr>
<tr><td><code id="intrinsic.matern.operators_+3A_tau">tau</code></td>
<td>
<p>precision parameter</p>
</td></tr>
<tr><td><code id="intrinsic.matern.operators_+3A_alpha">alpha</code></td>
<td>
<p>Smoothness parameter</p>
</td></tr>
<tr><td><code id="intrinsic.matern.operators_+3A_beta">beta</code></td>
<td>
<p>Smoothness parameter</p>
</td></tr>
<tr><td><code id="intrinsic.matern.operators_+3A_g">G</code></td>
<td>
<p>The stiffness matrix of a finite element discretization
of the domain of interest.</p>
</td></tr>
<tr><td><code id="intrinsic.matern.operators_+3A_c">C</code></td>
<td>
<p>The mass matrix of a finite element discretization of
the domain of interest.</p>
</td></tr>
<tr><td><code id="intrinsic.matern.operators_+3A_d">d</code></td>
<td>
<p>The dimension of the domain.</p>
</td></tr>
<tr><td><code id="intrinsic.matern.operators_+3A_mesh">mesh</code></td>
<td>
<p>An inla mesh.</p>
</td></tr>
<tr><td><code id="intrinsic.matern.operators_+3A_graph">graph</code></td>
<td>
<p>An optional <code>metric_graph</code> object. Replaces <code>d</code>, <code>C</code> and <code>G</code>.</p>
</td></tr>
<tr><td><code id="intrinsic.matern.operators_+3A_loc_mesh">loc_mesh</code></td>
<td>
<p>locations for the mesh for <code>d=1</code>.</p>
</td></tr>
<tr><td><code id="intrinsic.matern.operators_+3A_m_alpha">m_alpha</code></td>
<td>
<p>The order of the rational approximation for the Matrn part,
which needs to be a positive integer. The default value is 2.</p>
</td></tr>
<tr><td><code id="intrinsic.matern.operators_+3A_m_beta">m_beta</code></td>
<td>
<p>The order of the rational approximation for the intrinsic part,
which needs to be a positive integer. The default value is 2.</p>
</td></tr>
<tr><td><code id="intrinsic.matern.operators_+3A_compute_higher_order">compute_higher_order</code></td>
<td>
<p>Logical. Should the higher order finite
element matrices be computed?</p>
</td></tr>
<tr><td><code id="intrinsic.matern.operators_+3A_return_block_list">return_block_list</code></td>
<td>
<p>Logical. For <code>type = "covariance"</code>,
should the block parts of the precision matrix be returned
separately as a list?</p>
</td></tr>
<tr><td><code id="intrinsic.matern.operators_+3A_type_rational_approximation">type_rational_approximation</code></td>
<td>
<p>Which type of rational
approximation should be used? The current types are
&quot;chebfun&quot;, &quot;brasil&quot; or &quot;chebfunLB&quot;.</p>
</td></tr>
<tr><td><code id="intrinsic.matern.operators_+3A_fem_mesh_matrices">fem_mesh_matrices</code></td>
<td>
<p>A list containing FEM-related matrices.
The list should contain elements c0, g1, g2, g3, etc.</p>
</td></tr>
<tr><td><code id="intrinsic.matern.operators_+3A_scaling">scaling</code></td>
<td>
<p>second lowest eigenvalue of g1</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The covariance operator
</p>
<p style="text-align: center;"><code class="reqn">\tau^{-2}(-\Delta)^{\beta}(\kappa^2-\Delta)^{\alpha}</code>
</p>

<p>is approximated based on rational approximations of the two fractional
components. The Laplacians are equipped with homogeneous Neumann boundary
conditions and a zero-mean constraint is additionally imposed to obtained
a non-intrinsic model.
</p>


<h3>Value</h3>

<p><code>intrinsic.matern.operators</code> returns an object of
class &quot;intrinsicCBrSPDEobj&quot;. This object is a list containing the
following quantities:
</p>
<table role = "presentation">
<tr><td><code>C</code></td>
<td>
<p>The mass lumped mass matrix.</p>
</td></tr>
<tr><td><code>Ci</code></td>
<td>
<p>The inverse of <code>C</code>.</p>
</td></tr>
<tr><td><code>GCi</code></td>
<td>
<p>The stiffness matrix G times <code>Ci</code></p>
</td></tr>
<tr><td><code>Gk</code></td>
<td>
<p>The stiffness matrix G along with the higher-order
FEM-related matrices G2, G3, etc.</p>
</td></tr>
<tr><td><code>fem_mesh_matrices</code></td>
<td>
<p>A list containing the mass lumped mass
matrix, the stiffness matrix and
the higher-order FEM-related matrices.</p>
</td></tr>
<tr><td><code>m_alpha</code></td>
<td>
<p>The order of the rational approximation for the Matrn part.</p>
</td></tr>
<tr><td><code>m_beta</code></td>
<td>
<p>The order of the rational approximation for the intrinsic part.</p>
</td></tr>
<tr><td><code>alpha</code></td>
<td>
<p>The fractional power of the Matrn part of the operator.</p>
</td></tr>
<tr><td><code>beta</code></td>
<td>
<p>The fractional power of the intrinsic part of the operator.</p>
</td></tr>
<tr><td><code>type</code></td>
<td>
<p>String indicating the type of approximation.</p>
</td></tr>
<tr><td><code>d</code></td>
<td>
<p>The dimension of the domain.</p>
</td></tr>
<tr><td><code>A</code></td>
<td>
<p>Matrix that sums the components in the approximation to the mesh nodes.</p>
</td></tr>
<tr><td><code>kappa</code></td>
<td>
<p>Range parameter of the covariance function</p>
</td></tr>
<tr><td><code>tau</code></td>
<td>
<p>Scale parameter of the covariance function.</p>
</td></tr>
<tr><td><code>type</code></td>
<td>
<p>String indicating the type of approximation.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>if (requireNamespace("RSpectra", quietly = TRUE)) {
  x &lt;- seq(from = 0, to = 10, length.out = 201)
  beta &lt;- 1
  alpha &lt;- 1
  kappa &lt;- 1
  op &lt;- intrinsic.matern.operators(
    kappa = kappa, tau = 1, alpha = alpha,
    beta = beta, loc_mesh = x, d = 1
  )
  # Compute and plot the variogram of the model
  Sigma &lt;- op$A[,-1] %*% solve(op$Q[-1,-1], t(op$A[,-1]))
  One &lt;- rep(1, times = ncol(Sigma))
  D &lt;- diag(Sigma)
  Gamma &lt;- 0.5 * (One %*% t(D) + D %*% t(One) - 2 * Sigma)
  k &lt;- 100
  plot(x, Gamma[k, ], type = "l")
  lines(x,
    variogram.intrinsic.spde(x[k], x, kappa, alpha, beta, L = 10, d = 1),
    col = 2, lty = 2
  )
}
</code></pre>

<hr>
<h2 id='matern.covariance'>The Matern covariance function</h2><span id='topic+matern.covariance'></span>

<h3>Description</h3>

<p><code>matern.covariance</code> evaluates the Matern covariance function
</p>
<p style="text-align: center;"><code class="reqn">C(h) = \frac{\sigma^2}{2^{\nu-1}\Gamma(\nu)}(\kappa h)^\nu
K_\nu(\kappa h).</code>
</p>



<h3>Usage</h3>

<pre><code class='language-R'>matern.covariance(h, kappa, nu, sigma)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="matern.covariance_+3A_h">h</code></td>
<td>
<p>Distances to evaluate the covariance function at.</p>
</td></tr>
<tr><td><code id="matern.covariance_+3A_kappa">kappa</code></td>
<td>
<p>Range parameter.</p>
</td></tr>
<tr><td><code id="matern.covariance_+3A_nu">nu</code></td>
<td>
<p>Shape parameter.</p>
</td></tr>
<tr><td><code id="matern.covariance_+3A_sigma">sigma</code></td>
<td>
<p>Standard deviation.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector with the values C(h).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- seq(from = 0, to = 1, length.out = 101)
plot(x, matern.covariance(abs(x - 0.5), kappa = 10, nu = 1 / 5, sigma = 1),
  type = "l", ylab = "C(h)", xlab = "h"
)

</code></pre>

<hr>
<h2 id='matern.operators'>Rational approximations of stationary Gaussian Matern random fields</h2><span id='topic+matern.operators'></span>

<h3>Description</h3>

<p><code>matern.operators</code> is used for computing a rational SPDE approximation
of a stationary Gaussian random fields on <code class="reqn">R^d</code> with a Matern covariance
function
</p>
<p style="text-align: center;"><code class="reqn">C(h) = \frac{\sigma^2}{2^{\nu-1}\Gamma(\nu)}
(\kappa h)^\nu K_\nu(\kappa h)</code>
</p>



<h3>Usage</h3>

<pre><code class='language-R'>matern.operators(
  kappa = NULL,
  tau = NULL,
  alpha = NULL,
  sigma = NULL,
  range = NULL,
  nu = NULL,
  G = NULL,
  C = NULL,
  d = NULL,
  mesh = NULL,
  graph = NULL,
  range_mesh = NULL,
  loc_mesh = NULL,
  m = 1,
  type = c("covariance", "operator"),
  parameterization = c("spde", "matern"),
  compute_higher_order = FALSE,
  return_block_list = FALSE,
  type_rational_approximation = c("chebfun", "brasil", "chebfunLB"),
  compute_logdet = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="matern.operators_+3A_kappa">kappa</code></td>
<td>
<p>Parameter kappa of the SPDE representation. If <code>NULL</code>, the range parameter will be used. If the range is also <code>NULL</code>, a starting value based on the mesh will be supplied.</p>
</td></tr>
<tr><td><code id="matern.operators_+3A_tau">tau</code></td>
<td>
<p>Parameter tau of the SPDE representation. If both sigma and tau are <code>NULL</code>, a starting value based on the mesh will be supplied.</p>
</td></tr>
<tr><td><code id="matern.operators_+3A_alpha">alpha</code></td>
<td>
<p>Parameter alpha of the SPDE representation. If <code>alpha</code> is <code>NULL</code>, a starting value will be supplied.</p>
</td></tr>
<tr><td><code id="matern.operators_+3A_sigma">sigma</code></td>
<td>
<p>Standard deviation of the covariance function. Used if <code>parameterization</code> is <code>matern</code>. If <code>NULL</code>, tau will be used. If tau is also <code>NULL</code>, a starting value based on the mesh will be supplied.</p>
</td></tr>
<tr><td><code id="matern.operators_+3A_range">range</code></td>
<td>
<p>Range parameter of the covariance function. Used if <code>parameterization</code> is <code>matern</code>. If range is <code>NULL</code>, a starting value based on the mesh will be supplied.</p>
</td></tr>
<tr><td><code id="matern.operators_+3A_nu">nu</code></td>
<td>
<p>Shape parameter of the covariance function. Used if <code>parameterization</code> is <code>matern</code>. If <code>NULL</code>, a starting value will be supplied.</p>
</td></tr>
<tr><td><code id="matern.operators_+3A_g">G</code></td>
<td>
<p>The stiffness matrix of a finite element discretization of the
domain of interest. Does not need to be given if either <code>mesh</code> or <code>graph</code> is supplied.</p>
</td></tr>
<tr><td><code id="matern.operators_+3A_c">C</code></td>
<td>
<p>The mass matrix of a finite element discretization of the domain
of interest. Does not need to be given if either <code>mesh</code> or <code>graph</code> is supplied.</p>
</td></tr>
<tr><td><code id="matern.operators_+3A_d">d</code></td>
<td>
<p>The dimension of the domain. Does not need to be given if either
<code>mesh</code> or <code>graph</code> is provided.</p>
</td></tr>
<tr><td><code id="matern.operators_+3A_mesh">mesh</code></td>
<td>
<p>An optional fmesher mesh. Replaces <code>d</code>, <code>C</code> and <code>G</code>.</p>
</td></tr>
<tr><td><code id="matern.operators_+3A_graph">graph</code></td>
<td>
<p>An optional <code>metric_graph</code> object. Replaces <code>d</code>, <code>C</code> and <code>G</code>.</p>
</td></tr>
<tr><td><code id="matern.operators_+3A_range_mesh">range_mesh</code></td>
<td>
<p>The range of the mesh. Will be used to provide starting values for the parameters. Will be used if <code>mesh</code> and <code>graph</code> are <code>NULL</code>, and if one of the parameters (kappa or tau for spde parameterization, or sigma or range for matern parameterization) are not provided.</p>
</td></tr>
<tr><td><code id="matern.operators_+3A_loc_mesh">loc_mesh</code></td>
<td>
<p>The mesh locations used to construct the matrices C and G. This option should be provided if one wants to use the <code>rspde_lme()</code> function and will not provide neither graph nor mesh. Only works for 1d data. Does not work for metric graphs. For metric graphs you should supply the graph using the <code>graph</code> argument.</p>
</td></tr>
<tr><td><code id="matern.operators_+3A_m">m</code></td>
<td>
<p>The order of the rational approximation, which needs to be a
positive integer. The default value is 1.</p>
</td></tr>
<tr><td><code id="matern.operators_+3A_type">type</code></td>
<td>
<p>The type of the rational approximation. The options are
&quot;covariance&quot; and &quot;operator&quot;. The default is &quot;covariance&quot;.</p>
</td></tr>
<tr><td><code id="matern.operators_+3A_parameterization">parameterization</code></td>
<td>
<p>Which parameterization to use? <code>matern</code> uses range, std. deviation and nu (smoothness). <code>spde</code> uses kappa, tau and alpha. The default is <code>spde</code>.</p>
</td></tr>
<tr><td><code id="matern.operators_+3A_compute_higher_order">compute_higher_order</code></td>
<td>
<p>Logical. Should the higher order finite
element matrices be computed?</p>
</td></tr>
<tr><td><code id="matern.operators_+3A_return_block_list">return_block_list</code></td>
<td>
<p>Logical. For <code>type = "covariance"</code>,
should the block parts of the precision matrix be returned
separately as a list?</p>
</td></tr>
<tr><td><code id="matern.operators_+3A_type_rational_approximation">type_rational_approximation</code></td>
<td>
<p>Which type of rational
approximation should be used? The current types are
&quot;chebfun&quot;, &quot;brasil&quot; or &quot;chebfunLB&quot;.</p>
</td></tr>
<tr><td><code id="matern.operators_+3A_compute_logdet">compute_logdet</code></td>
<td>
<p>Should log determinants be computed while building the model? (For covariance-based models)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If <code>type</code> is &quot;covariance&quot;, we use the
covariance-based rational approximation of the fractional operator.
In the SPDE approach, we model <code class="reqn">u</code> as the solution of the following SPDE:
</p>
<p style="text-align: center;"><code class="reqn">L^{\alpha/2}(\tau u) = \mathcal{W},</code>
</p>

<p>where
<code class="reqn">L  = -\Delta +\kappa^2 I</code> and <code class="reqn">\mathcal{W}</code> is the standard
Gaussian white noise. The covariance operator of <code class="reqn">u</code> is given
by <code class="reqn">L^{-\alpha}</code>. Now, let <code class="reqn">L_h</code> be a finite-element
approximation of <code class="reqn">L</code>. We can use
a rational approximation of order <code class="reqn">m</code> on <code class="reqn">L_h^{-\alpha}</code> to
obtain the following approximation:
</p>
<p style="text-align: center;"><code class="reqn">L_{h,m}^{-\alpha} = L_h^{-m_\alpha} p(L_h^{-1})q(L_h^{-1})^{-1},</code>
</p>

<p>where <code class="reqn">m_\alpha = \lfloor \alpha\rfloor</code>, <code class="reqn">p</code> and <code class="reqn">q</code> are
polynomials arising from such rational approximation.
From this approximation we construct an approximate precision
matrix for <code class="reqn">u</code>.
</p>
<p>If <code>type</code> is &quot;operator&quot;, the approximation is based on a
rational approximation of the fractional operator
<code class="reqn">(\kappa^2 -\Delta)^\beta</code>, where <code class="reqn">\beta = (\nu + d/2)/2</code>.
This results in an approximate model of the form </p>
<p style="text-align: center;"><code class="reqn">P_l u(s) = P_r W,</code>
</p>

<p>where <code class="reqn">P_j = p_j(L)</code> are non-fractional operators defined in terms
of polynomials <code class="reqn">p_j</code> for <code class="reqn">j=l,r</code>. The order of <code class="reqn">p_r</code> is given
by <code>m</code> and the order of <code class="reqn">p_l</code> is <code class="reqn">m + m_\beta</code>
where <code class="reqn">m_\beta</code> is the integer part of <code class="reqn">\beta</code> if <code class="reqn">\beta&gt;1</code> and
<code class="reqn">m_\beta = 1</code> otherwise.
</p>
<p>The discrete approximation can be written as <code class="reqn">u = P_r x</code> where
<code class="reqn">x \sim N(0,Q^{-1})</code> and <code class="reqn">Q = P_l^T C^{-1} P_l</code>.
Note that the matrices <code class="reqn">P_r</code> and <code class="reqn">Q</code> may be be
ill-conditioned for <code class="reqn">m&gt;1</code>. In this case, the methods in
<code><a href="#topic+operator.operations">operator.operations()</a></code> should be used for operations involving
the matrices, since these methods are more numerically stable.
</p>


<h3>Value</h3>

<p>If <code>type</code> is &quot;covariance&quot;, then <code>matern.operators</code>
returns an object of class &quot;CBrSPDEobj&quot;.
This object is a list containing the
following quantities:
</p>
<table role = "presentation">
<tr><td><code>C</code></td>
<td>
<p>The mass lumped mass matrix.</p>
</td></tr>
<tr><td><code>Ci</code></td>
<td>
<p>The inverse of <code>C</code>.</p>
</td></tr>
<tr><td><code>GCi</code></td>
<td>
<p>The stiffness matrix G times <code>Ci</code></p>
</td></tr>
<tr><td><code>Gk</code></td>
<td>
<p>The stiffness matrix G along with the higher-order
FEM-related matrices G2, G3, etc.</p>
</td></tr>
<tr><td><code>fem_mesh_matrices</code></td>
<td>
<p>A list containing the mass
lumped mass matrix, the stiffness matrix and
the higher-order FEM-related matrices.</p>
</td></tr>
<tr><td><code>m</code></td>
<td>
<p>The order of the rational approximation.</p>
</td></tr>
<tr><td><code>alpha</code></td>
<td>
<p>The fractional power of the precision operator.</p>
</td></tr>
<tr><td><code>type</code></td>
<td>
<p>String indicating the type of approximation.</p>
</td></tr>
<tr><td><code>d</code></td>
<td>
<p>The dimension of the domain.</p>
</td></tr>
<tr><td><code>nu</code></td>
<td>
<p>Shape parameter of the covariance function.</p>
</td></tr>
<tr><td><code>kappa</code></td>
<td>
<p>Range parameter of the covariance function</p>
</td></tr>
<tr><td><code>tau</code></td>
<td>
<p>Scale parameter of the covariance function.</p>
</td></tr>
<tr><td><code>sigma</code></td>
<td>
<p>Standard deviation of the covariance function.</p>
</td></tr>
<tr><td><code>type</code></td>
<td>
<p>String indicating the type of approximation.</p>
</td></tr>
</table>
<p>If <code>type</code> is &quot;operator&quot;, then <code>matern.operators</code>
returns an object of class &quot;rSPDEobj&quot;. This object contains the
quantities listed in the output of <code><a href="#topic+fractional.operators">fractional.operators()</a></code>,
the <code>G</code> matrix, the dimension of the domain, as well as the
parameters of the covariance function.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+fractional.operators">fractional.operators()</a></code>,
<code><a href="#topic+spde.matern.operators">spde.matern.operators()</a></code>,
<code><a href="#topic+matern.operators">matern.operators()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Compute the covariance-based rational approximation of a
# Gaussian process with a Matern covariance function on R
kappa &lt;- 10
sigma &lt;- 1
nu &lt;- 0.8
range &lt;- sqrt(8 * nu) / kappa

# create mass and stiffness matrices for a FEM discretization
nobs &lt;- 101
x &lt;- seq(from = 0, to = 1, length.out = 101)
fem &lt;- rSPDE.fem1d(x)

# compute rational approximation of covariance function at 0.5
op_cov &lt;- matern.operators(
  loc_mesh = x, nu = nu,
  range = range, sigma = sigma, d = 1, m = 2,
  parameterization = "matern"
)

v &lt;- t(rSPDE.A1d(x, 0.5))
# Compute the precision matrix
Q &lt;- op_cov$Q
# A matrix here is the identity matrix
A &lt;- Diagonal(nobs)
# We need to concatenate 3 A's since we are doing a covariance-based rational
# approximation of order 2
Abar &lt;- cbind(A, A, A)
w &lt;- rbind(v, v, v)
# The approximate covariance function:
c_cov.approx &lt;- (Abar) %*% solve(Q, w)
c.true &lt;- folded.matern.covariance.1d(
  rep(0.5, length(x)),
  abs(x), kappa, nu, sigma
)

# plot the result and compare with the true Matern covariance
plot(x, c.true,
  type = "l", ylab = "C(h)",
  xlab = "h", main = "Matern covariance and rational approximations"
)
lines(x, c_cov.approx, col = 2)


# Compute the operator-based rational approximation of a Gaussian
# process with a Matern covariance function on R
kappa &lt;- 10
sigma &lt;- 1
nu &lt;- 0.8
range &lt;- sqrt(8 * nu) / kappa

# create mass and stiffness matrices for a FEM discretization
x &lt;- seq(from = 0, to = 1, length.out = 101)
fem &lt;- rSPDE.fem1d(x)

# compute rational approximation of covariance function at 0.5
op &lt;- matern.operators(
  range = range, sigma = sigma, nu = nu,
  loc_mesh = x, d = 1,
  type = "operator",
  parameterization = "matern"
)

v &lt;- t(rSPDE.A1d(x, 0.5))
c.approx &lt;- Sigma.mult(op, v)
c.true &lt;- folded.matern.covariance.1d(
  rep(0.5, length(x)),
  abs(x), kappa, nu, sigma
)

# plot the result and compare with the true Matern covariance
plot(x, c.true,
  type = "l", ylab = "C(h)",
  xlab = "h", main = "Matern covariance and rational approximation"
)
lines(x, c.approx, col = 2)
</code></pre>

<hr>
<h2 id='matern.rational'>Rational approximation of the Matern fields on intervals and metric graphs</h2><span id='topic+matern.rational'></span>

<h3>Description</h3>

<p>The function is used for computing an approximation,
which can be used for inference and simulation, of the fractional SPDE
</p>
<p style="text-align: center;"><code class="reqn">(\kappa^2 - \Delta)^{\alpha/2} (\tau u(s)) = W</code>
</p>

<p>on intervals or metric graphs. Here <code class="reqn">W</code> is Gaussian white noise,
<code class="reqn">\kappa</code> controls the range, <code class="reqn">\alpha = \nu + 1/2</code> with <code class="reqn">\nu&gt;0</code>
controls the smoothness and <code class="reqn">\tau</code> is related to the marginal variances
through
</p>
<p style="text-align: center;"><code class="reqn">\sigma^2 = \frac{\Gamma(\nu)}{\tau^2\Gamma(\alpha)2\sqrt{\pi}\kappa^{2\nu}}.</code>
</p>



<h3>Usage</h3>

<pre><code class='language-R'>matern.rational(
  graph = NULL,
  loc = NULL,
  bc = c("free", "Neumann", "Dirichlet"),
  kappa = NULL,
  range = NULL,
  nu = NULL,
  sigma = NULL,
  tau = NULL,
  alpha = NULL,
  m = 2,
  parameterization = c("matern", "spde"),
  type_rational_approximation = "brasil",
  type_interp = "spline"
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="matern.rational_+3A_graph">graph</code></td>
<td>
<p>Metric graph object. The default is NULL, which means that a stationary
Matern model on the line is created.</p>
</td></tr>
<tr><td><code id="matern.rational_+3A_loc">loc</code></td>
<td>
<p>Locations where to evaluate the model.</p>
</td></tr>
<tr><td><code id="matern.rational_+3A_bc">bc</code></td>
<td>
<p>Specifies the boundary conditions. The default is &quot;free&quot; which gives
stationary Matern models on intervals. Other options are &quot;Neumann&quot; or &quot;Dirichlet&quot;.</p>
</td></tr>
<tr><td><code id="matern.rational_+3A_kappa">kappa</code></td>
<td>
<p>Range parameter</p>
</td></tr>
<tr><td><code id="matern.rational_+3A_range">range</code></td>
<td>
<p>practical correlation range</p>
</td></tr>
<tr><td><code id="matern.rational_+3A_nu">nu</code></td>
<td>
<p>Smoothness parameter</p>
</td></tr>
<tr><td><code id="matern.rational_+3A_sigma">sigma</code></td>
<td>
<p>Standard deviation</p>
</td></tr>
<tr><td><code id="matern.rational_+3A_tau">tau</code></td>
<td>
<p>Precision parameter</p>
</td></tr>
<tr><td><code id="matern.rational_+3A_alpha">alpha</code></td>
<td>
<p>Smoothness parameter</p>
</td></tr>
<tr><td><code id="matern.rational_+3A_m">m</code></td>
<td>
<p>The order of the approximation</p>
</td></tr>
<tr><td><code id="matern.rational_+3A_parameterization">parameterization</code></td>
<td>
<p>Which parameterization to use? <code>matern</code> uses range, std. deviation and nu
(smoothness). <code>spde</code> uses kappa, tau and alpha. The default is <code>matern</code>.</p>
</td></tr>
<tr><td><code id="matern.rational_+3A_type_rational_approximation">type_rational_approximation</code></td>
<td>
<p>Method used to compute the coefficients of the rational approximation.</p>
</td></tr>
<tr><td><code id="matern.rational_+3A_type_interp">type_interp</code></td>
<td>
<p>Interpolation method for the rational coefficients.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A model object for the the approximation
</p>


<h3>Examples</h3>

<pre><code class='language-R'>s &lt;- seq(from = 0, to = 1, length.out = 101)
kappa &lt;- 20
sigma &lt;- 2
nu &lt;- 0.8
r &lt;- sqrt(8*nu)/kappa #range parameter
op_cov &lt;- matern.rational(loc = s, nu = nu, range = r, sigma = sigma, m = 2, 
parameterization = "matern")
cov.true &lt;- matern.covariance(abs(s-s[1]), kappa = kappa, sigma = sigma, nu = nu)
cov.approx &lt;- op_cov$covariance(ind = 1)

plot(s, cov.true)
lines(s, cov.approx, col = 2)
</code></pre>

<hr>
<h2 id='matern.rational.cov'>Rational approximation of the Matern covariance</h2><span id='topic+matern.rational.cov'></span>

<h3>Description</h3>

<p>Computes a rational approximation of the Matern covariance function on intervals.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>matern.rational.cov(
  h,
  order,
  kappa,
  nu,
  sigma,
  type_rational = "brasil",
  type_interp = "linear"
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="matern.rational.cov_+3A_h">h</code></td>
<td>
<p>Distances to compute the covariance for</p>
</td></tr>
<tr><td><code id="matern.rational.cov_+3A_order">order</code></td>
<td>
<p>The order of the approximation</p>
</td></tr>
<tr><td><code id="matern.rational.cov_+3A_kappa">kappa</code></td>
<td>
<p>Range parameter</p>
</td></tr>
<tr><td><code id="matern.rational.cov_+3A_nu">nu</code></td>
<td>
<p>Smoothness parameter</p>
</td></tr>
<tr><td><code id="matern.rational.cov_+3A_sigma">sigma</code></td>
<td>
<p>Standard deviation</p>
</td></tr>
<tr><td><code id="matern.rational.cov_+3A_type_rational">type_rational</code></td>
<td>
<p>Method used to compute the coefficients of the rational approximation.</p>
</td></tr>
<tr><td><code id="matern.rational.cov_+3A_type_interp">type_interp</code></td>
<td>
<p>Interpolation method for the rational coefficients.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The covariance matrix of the approximation
</p>


<h3>Examples</h3>

<pre><code class='language-R'>h &lt;- seq(from = 0, to = 1, length.out = 100)
cov.true &lt;- matern.covariance(h, kappa = 10, sigma = 1, nu = 0.8)
cov.approx &lt;- matern.rational.cov(h, kappa = 10, sigma = 1, nu = 0.8, order = 2)

plot(h, cov.true)
lines(h, cov.approx, col = 2)
 
</code></pre>

<hr>
<h2 id='matern2d.operators'>Rational approximations of stationary anisotropic Gaussian Matern random fields</h2><span id='topic+matern2d.operators'></span>

<h3>Description</h3>

<p><code>matern2d.operators</code> is used for computing a rational SPDE approximation
of a stationary Gaussian random fields on <code class="reqn">R^d</code> with a Matern covariance
function
</p>
<p style="text-align: center;"><code class="reqn">C(h) = \frac{\sigma^2}{2^{\nu-1}\Gamma(\nu)}(\sqrt{h^T H^{-1}h})^\nu K_\nu(\sqrt{h^T H^{-1}h})</code>
</p>
<p>,
based on a SPDE representation of the form
</p>
<p style="text-align: center;"><code class="reqn">(I - \nabla\cdot(H\nabla))^{(\nu+1)/2}u = c\sigma W</code>
</p>
<p>,
where $c&gt;0$ is a constant. The matrix <code class="reqn">H</code> is defined as
</p>
<p style="text-align: center;"><code class="reqn">\begin{bmatrix}
h_x^2 &amp; h_xh_yh_{xy} \\
h_xh_yh_{xy} &amp; h_y^2
\end{bmatrix}</code>
</p>



<h3>Usage</h3>

<pre><code class='language-R'>matern2d.operators(
  hx = NULL,
  hy = NULL,
  hxy = NULL,
  nu = NULL,
  sigma = NULL,
  mesh = NULL,
  fem = NULL,
  m = 1,
  type_rational_approximation = c("chebfun", "brasil", "chebfunLB"),
  return_fem_matrices = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="matern2d.operators_+3A_hx">hx</code></td>
<td>
<p>Parameter in the H matrix.</p>
</td></tr>
<tr><td><code id="matern2d.operators_+3A_hy">hy</code></td>
<td>
<p>Parameter in the H matrix.</p>
</td></tr>
<tr><td><code id="matern2d.operators_+3A_hxy">hxy</code></td>
<td>
<p>Parameter in the H matrix.</p>
</td></tr>
<tr><td><code id="matern2d.operators_+3A_nu">nu</code></td>
<td>
<p>Smoothness parameter.</p>
</td></tr>
<tr><td><code id="matern2d.operators_+3A_sigma">sigma</code></td>
<td>
<p>standard deviation parameter.</p>
</td></tr>
<tr><td><code id="matern2d.operators_+3A_mesh">mesh</code></td>
<td>
<p>An <code>fmesher</code> mesh.</p>
</td></tr>
<tr><td><code id="matern2d.operators_+3A_fem">fem</code></td>
<td>
<p>Optional precomputed FEM matrices.</p>
</td></tr>
<tr><td><code id="matern2d.operators_+3A_m">m</code></td>
<td>
<p>The order of the rational approximation, which needs to be a
positive integer. The default value is 1.</p>
</td></tr>
<tr><td><code id="matern2d.operators_+3A_type_rational_approximation">type_rational_approximation</code></td>
<td>
<p>Which type of rational
approximation should be used? The current types are
&quot;chebfun&quot;, &quot;brasil&quot; or &quot;chebfunLB&quot;.</p>
</td></tr>
<tr><td><code id="matern2d.operators_+3A_return_fem_matrices">return_fem_matrices</code></td>
<td>
<p>Should the FEM matrices be returned?</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of type <code>CBrSPDEobj2d</code>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+fractional.operators">fractional.operators()</a></code>,
<code><a href="#topic+spde.matern.operators">spde.matern.operators()</a></code>,
<code><a href="#topic+matern.operators">matern.operators()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(fmesher)
n_loc &lt;- 2000
loc_2d_mesh &lt;- matrix(runif(n_loc * 2), n_loc, 2)
mesh_2d &lt;- fm_mesh_2d(loc = loc_2d_mesh, cutoff = 0.03, max.edge = c(0.1, 0.5))
op &lt;- matern2d.operators(mesh = mesh_2d)
</code></pre>

<hr>
<h2 id='operator.operations'>Operations with the Pr and Pl operators</h2><span id='topic+operator.operations'></span><span id='topic+Pr.mult'></span><span id='topic+Pr.solve'></span><span id='topic+Pl.mult'></span><span id='topic+Pl.solve'></span><span id='topic+Q.mult'></span><span id='topic+Q.solve'></span><span id='topic+Qsqrt.mult'></span><span id='topic+Qsqrt.solve'></span><span id='topic+Sigma.mult'></span><span id='topic+Sigma.solve'></span>

<h3>Description</h3>

<p>Functions for multiplying and solving with the <code class="reqn">P_r</code>
and <code class="reqn">P_l</code> operators as well as the latent precision
matrix <code class="reqn">Q = P_l C^{-1}P_l</code> and covariance matrix
<code class="reqn">\Sigma = P_r Q^{-1} P_r^T</code>.
These operations are done without first assembling <code class="reqn">P_r</code>,
<code class="reqn">P_l</code> in order to avoid numerical problems caused by
ill-conditioned matrices.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Pr.mult(obj, v, transpose = FALSE)

Pr.solve(obj, v, transpose = FALSE)

Pl.mult(obj, v, transpose = FALSE)

Pl.solve(obj, v, transpose = FALSE)

Q.mult(obj, v)

Q.solve(obj, v)

Qsqrt.mult(obj, v, transpose = FALSE)

Qsqrt.solve(obj, v, transpose = FALSE)

Sigma.mult(obj, v)

Sigma.solve(obj, v)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="operator.operations_+3A_obj">obj</code></td>
<td>
<p>rSPDE object</p>
</td></tr>
<tr><td><code id="operator.operations_+3A_v">v</code></td>
<td>
<p>vector to apply the operation to</p>
</td></tr>
<tr><td><code id="operator.operations_+3A_transpose">transpose</code></td>
<td>
<p>set to TRUE if the operation should be
performed with the transposed object</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>Pl.mult</code>, <code>Pr.mult</code>, and <code>Q.mult</code>
multiplies the vector with the respective object.
Changing <code>mult</code> to <code>solve</code> in the function names
multiplies the vector with the inverse of the object.
<code>Qsqrt.mult</code> and <code>Qsqrt.solve</code> performs the
operations with the square-root type object
<code class="reqn">Q_r = C^{-1/2}P_l</code> defined so that <code class="reqn">Q = Q_r^T Q_r</code>.
</p>


<h3>Value</h3>

<p>A vector with the values of the operation
</p>

<hr>
<h2 id='precision'>Get the precision matrix of CBrSPDEobj objects</h2><span id='topic+precision'></span><span id='topic+precision.CBrSPDEobj'></span>

<h3>Description</h3>

<p>Function to get the precision matrix of a CBrSPDEobj object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>precision(object, ...)

## S3 method for class 'CBrSPDEobj'
precision(
  object,
  nu = NULL,
  kappa = NULL,
  sigma = NULL,
  range = NULL,
  tau = NULL,
  m = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="precision_+3A_object">object</code></td>
<td>
<p>The covariance-based rational SPDE approximation,
computed using <code><a href="#topic+matern.operators">matern.operators()</a></code></p>
</td></tr>
<tr><td><code id="precision_+3A_...">...</code></td>
<td>
<p>Currently not used.</p>
</td></tr>
<tr><td><code id="precision_+3A_nu">nu</code></td>
<td>
<p>If non-null, update the shape parameter of the
covariance function.</p>
</td></tr>
<tr><td><code id="precision_+3A_kappa">kappa</code></td>
<td>
<p>If non-null, update the range parameter of
the covariance function.</p>
</td></tr>
<tr><td><code id="precision_+3A_sigma">sigma</code></td>
<td>
<p>If non-null, update the standard deviation of
the covariance function.</p>
</td></tr>
<tr><td><code id="precision_+3A_range">range</code></td>
<td>
<p>If non-null, update the range parameter
of the covariance function.</p>
</td></tr>
<tr><td><code id="precision_+3A_tau">tau</code></td>
<td>
<p>If non-null, update the parameter tau.</p>
</td></tr>
<tr><td><code id="precision_+3A_m">m</code></td>
<td>
<p>If non-null, update the order of the rational approximation,
which needs to be a positive integer.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The precision matrix.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+simulate.CBrSPDEobj">simulate.CBrSPDEobj()</a></code>, <code><a href="#topic+matern.operators">matern.operators()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Compute the covariance-based rational approximation of a
# Gaussian process with a Matern covariance function on R
kappa &lt;- 10
sigma &lt;- 1
nu &lt;- 0.8
range &lt;- 0.2

# create mass and stiffness matrices for a FEM discretization
x &lt;- seq(from = 0, to = 1, length.out = 101)
fem &lt;- rSPDE.fem1d(x)

# compute rational approximation of covariance function at 0.5
tau &lt;- sqrt(gamma(nu) / (sigma^2 * kappa^(2 * nu) *
  (4 * pi)^(1 / 2) * gamma(nu + 1 / 2)))
op_cov &lt;- matern.operators(
  loc_mesh = x, nu = nu,
  range = range, sigma = sigma, d = 1, m = 2,
  parameterization = "matern"
)

# Get the precision matrix:
prec_matrix &lt;- precision(op_cov)

</code></pre>

<hr>
<h2 id='precision.CBrSPDEobj2d'>Get the precision matrix of CBrSPDEobj2d objects</h2><span id='topic+precision.CBrSPDEobj2d'></span>

<h3>Description</h3>

<p>Function to get the precision matrix of a CBrSPDEobj2d object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'CBrSPDEobj2d'
precision(
  object,
  nu = NULL,
  hx = NULL,
  hy = NULL,
  hxy = NULL,
  sigma = NULL,
  m = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="precision.CBrSPDEobj2d_+3A_object">object</code></td>
<td>
<p>The covariance-based rational SPDE approximation,
computed using <code><a href="#topic+matern2d.operators">matern2d.operators()</a></code></p>
</td></tr>
<tr><td><code id="precision.CBrSPDEobj2d_+3A_nu">nu</code></td>
<td>
<p>If non-null, update the shape parameter of the
covariance function.</p>
</td></tr>
<tr><td><code id="precision.CBrSPDEobj2d_+3A_hx">hx</code></td>
<td>
<p>If non-null, update the hx parameter.</p>
</td></tr>
<tr><td><code id="precision.CBrSPDEobj2d_+3A_hy">hy</code></td>
<td>
<p>If non-null, update the hy parameter.</p>
</td></tr>
<tr><td><code id="precision.CBrSPDEobj2d_+3A_hxy">hxy</code></td>
<td>
<p>If non-null, update the hxy parameter.</p>
</td></tr>
<tr><td><code id="precision.CBrSPDEobj2d_+3A_sigma">sigma</code></td>
<td>
<p>If non-null, update the standard deviation of
the covariance function.</p>
</td></tr>
<tr><td><code id="precision.CBrSPDEobj2d_+3A_m">m</code></td>
<td>
<p>If non-null, update the order of the rational approximation,
which needs to be a positive integer.</p>
</td></tr>
<tr><td><code id="precision.CBrSPDEobj2d_+3A_...">...</code></td>
<td>
<p>Currently not used.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The precision matrix.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+simulate.CBrSPDEobj2d">simulate.CBrSPDEobj2d()</a></code>, <code><a href="#topic+matern2d.operators">matern2d.operators()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(fmesher)
n_loc &lt;- 2000
loc_2d_mesh &lt;- matrix(runif(n_loc * 2), n_loc, 2)
mesh_2d &lt;- fm_mesh_2d(loc = loc_2d_mesh, cutoff = 0.03, max.edge = c(0.1, 0.5))
op &lt;- matern2d.operators(mesh = mesh_2d)
Q &lt;- precision(op)
</code></pre>

<hr>
<h2 id='precision.inla_rspde'>Get the precision matrix of <code>inla_rspde</code> objects</h2><span id='topic+precision.inla_rspde'></span>

<h3>Description</h3>

<p>Function to get the precision matrix of an <code>inla_rspde</code> object created with the <code>rspde.matern()</code> function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'inla_rspde'
precision(object, theta = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="precision.inla_rspde_+3A_object">object</code></td>
<td>
<p>The <code>inla_rspde</code> object obtained with the <code>rspde.matern()</code> function.</p>
</td></tr>
<tr><td><code id="precision.inla_rspde_+3A_theta">theta</code></td>
<td>
<p>If null, the starting values for theta will be used. Otherwise, it must be suplied as a vector.
For stationary models, we have <code>theta = c(log(tau), log(kappa), nu)</code>. For nonstationary models, we have
<code>theta = c(theta_1, theta_2, ..., theta_n, nu)</code>.</p>
</td></tr>
<tr><td><code id="precision.inla_rspde_+3A_...">...</code></td>
<td>
<p>Currently not used.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The precision matrix.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+precision.CBrSPDEobj">precision.CBrSPDEobj()</a></code>, <code><a href="#topic+matern.operators">matern.operators()</a></code>
</p>

<hr>
<h2 id='precision.rSPDEobj1d'>Get the precision matrix of rSPDEobj1d objects</h2><span id='topic+precision.rSPDEobj1d'></span>

<h3>Description</h3>

<p>Function to get the precision matrix of a rSPDEobj1d object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'rSPDEobj1d'
precision(
  object,
  loc = NULL,
  nu = NULL,
  kappa = NULL,
  sigma = NULL,
  range = NULL,
  tau = NULL,
  m = NULL,
  ordering = c("field", "location"),
  ldl = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="precision.rSPDEobj1d_+3A_object">object</code></td>
<td>
<p>The covariance-based rational SPDE approximation,
computed using <code><a href="#topic+matern.rational">matern.rational()</a></code></p>
</td></tr>
<tr><td><code id="precision.rSPDEobj1d_+3A_loc">loc</code></td>
<td>
<p>If non-null, update the locations where to evaluate the model.</p>
</td></tr>
<tr><td><code id="precision.rSPDEobj1d_+3A_nu">nu</code></td>
<td>
<p>If non-null, update the shape parameter of the
covariance function.</p>
</td></tr>
<tr><td><code id="precision.rSPDEobj1d_+3A_kappa">kappa</code></td>
<td>
<p>If non-null, update the range parameter of
the covariance function.</p>
</td></tr>
<tr><td><code id="precision.rSPDEobj1d_+3A_sigma">sigma</code></td>
<td>
<p>If non-null, update the standard deviation of
the covariance function.</p>
</td></tr>
<tr><td><code id="precision.rSPDEobj1d_+3A_range">range</code></td>
<td>
<p>If non-null, update the range parameter
of the covariance function.</p>
</td></tr>
<tr><td><code id="precision.rSPDEobj1d_+3A_tau">tau</code></td>
<td>
<p>If non-null, update the parameter tau.</p>
</td></tr>
<tr><td><code id="precision.rSPDEobj1d_+3A_m">m</code></td>
<td>
<p>If non-null, update the order of the rational approximation,
which needs to be a positive integer.</p>
</td></tr>
<tr><td><code id="precision.rSPDEobj1d_+3A_ordering">ordering</code></td>
<td>
<p>Return the matrices ordered by field or by location?</p>
</td></tr>
<tr><td><code id="precision.rSPDEobj1d_+3A_ldl">ldl</code></td>
<td>
<p>Directly build the LDL factorization of the precision matrix?</p>
</td></tr>
<tr><td><code id="precision.rSPDEobj1d_+3A_...">...</code></td>
<td>
<p>Currently not used.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list containing the precision matrix <code>Q</code> of the process and its derivatives if they exist, and
a matrix <code>A</code> that extracts the elements corresponding to the process. If <code>ldl=TRUE</code>, the LDL factorization
is returned instead of <code>Q</code>. If the locations are not ordered, the precision matrix is given for the ordered locations,
but the <code>A</code> matrix returns to the original order.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+simulate.rSPDEobj1d">simulate.rSPDEobj1d()</a></code>, <code><a href="#topic+matern.rational">matern.rational()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Compute the covariance-based rational approximation of a
# Gaussian process with a Matern covariance function on R
sigma &lt;- 1
nu &lt;- 0.8
range &lt;- 0.2

# create mass and stiffness matrices for a FEM discretization
x &lt;- seq(from = 0, to = 1, length.out = 101)

op_cov &lt;- matern.rational(
  loc = x, nu = nu,
  range = range, sigma = sigma, m = 2,
  parameterization = "matern"
)

# Get the precision matrix:
prec_matrix &lt;- precision(op_cov)

</code></pre>

<hr>
<h2 id='precision.spacetimeobj'>Get the precision matrix of spacetimeobj objects</h2><span id='topic+precision.spacetimeobj'></span>

<h3>Description</h3>

<p>Function to get the precision matrix of a spacetimeobj object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'spacetimeobj'
precision(object, kappa = NULL, sigma = NULL, gamma = NULL, rho = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="precision.spacetimeobj_+3A_object">object</code></td>
<td>
<p>The model object computed using <code><a href="#topic+spacetime.operators">spacetime.operators()</a></code></p>
</td></tr>
<tr><td><code id="precision.spacetimeobj_+3A_kappa">kappa</code></td>
<td>
<p>If non-null, update the range parameter of
the covariance function.</p>
</td></tr>
<tr><td><code id="precision.spacetimeobj_+3A_sigma">sigma</code></td>
<td>
<p>If non-null, update the standard deviation of
the covariance function.</p>
</td></tr>
<tr><td><code id="precision.spacetimeobj_+3A_gamma">gamma</code></td>
<td>
<p>If non-null, update the temporal range parameter
of the covariance function.</p>
</td></tr>
<tr><td><code id="precision.spacetimeobj_+3A_rho">rho</code></td>
<td>
<p>If non-null, update the drift parameter of the
covariance function.</p>
</td></tr>
<tr><td><code id="precision.spacetimeobj_+3A_...">...</code></td>
<td>
<p>Currently not used.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The precision matrix.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+simulate.spacetimeobj">simulate.spacetimeobj()</a></code>, <code><a href="#topic+spacetime.operators">spacetime.operators()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>s &lt;- seq(from = 0, to = 20, length.out = 101)
t &lt;- seq(from = 0, to = 20, length.out = 31)

op_cov &lt;- spacetime.operators(space_loc = s, time_loc = t,
                             kappa = 5, sigma = 10, alpha = 1,
                             beta = 2, rho = 1, gamma = 0.05)
prec_matrix &lt;- precision(op_cov)
</code></pre>

<hr>
<h2 id='predict.CBrSPDEobj'>Prediction of a fractional SPDE using the covariance-based
rational SPDE approximation</h2><span id='topic+predict.CBrSPDEobj'></span>

<h3>Description</h3>

<p>The function is used for computing kriging predictions based
on data <code class="reqn">Y_i = u(s_i) + \epsilon_i</code>, where <code class="reqn">\epsilon</code>
is mean-zero Gaussian measurement noise and <code class="reqn">u(s)</code> is defined by
a fractional SPDE <code class="reqn">(\kappa^2 I - \Delta)^{\alpha/2} (\tau u(s)) = W</code>,
where <code class="reqn">W</code> is Gaussian white noise and <code class="reqn">\alpha = \nu + d/2</code>,
where <code class="reqn">d</code> is the dimension of the domain.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'CBrSPDEobj'
predict(
  object,
  A,
  Aprd,
  Y,
  sigma.e,
  mu = 0,
  compute.variances = FALSE,
  posterior_samples = FALSE,
  n_samples = 100,
  only_latent = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="predict.CBrSPDEobj_+3A_object">object</code></td>
<td>
<p>The covariance-based rational SPDE approximation,
computed using <code><a href="#topic+matern.operators">matern.operators()</a></code></p>
</td></tr>
<tr><td><code id="predict.CBrSPDEobj_+3A_a">A</code></td>
<td>
<p>A matrix linking the measurement locations to the basis of the FEM
approximation of the latent model.</p>
</td></tr>
<tr><td><code id="predict.CBrSPDEobj_+3A_aprd">Aprd</code></td>
<td>
<p>A matrix linking the prediction locations to the basis of the
FEM approximation of the latent model.</p>
</td></tr>
<tr><td><code id="predict.CBrSPDEobj_+3A_y">Y</code></td>
<td>
<p>A vector with the observed data, can also be a matrix where the
columns are observations
of independent replicates of <code class="reqn">u</code>.</p>
</td></tr>
<tr><td><code id="predict.CBrSPDEobj_+3A_sigma.e">sigma.e</code></td>
<td>
<p>The standard deviation of the Gaussian measurement noise.
Put to zero if the model does not have measurement noise.</p>
</td></tr>
<tr><td><code id="predict.CBrSPDEobj_+3A_mu">mu</code></td>
<td>
<p>Expectation vector of the latent field (default = 0).</p>
</td></tr>
<tr><td><code id="predict.CBrSPDEobj_+3A_compute.variances">compute.variances</code></td>
<td>
<p>Set to also TRUE to compute the kriging variances.</p>
</td></tr>
<tr><td><code id="predict.CBrSPDEobj_+3A_posterior_samples">posterior_samples</code></td>
<td>
<p>If <code>TRUE</code>, posterior samples will be returned.</p>
</td></tr>
<tr><td><code id="predict.CBrSPDEobj_+3A_n_samples">n_samples</code></td>
<td>
<p>Number of samples to be returned. Will only be used if <code>sampling</code> is <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="predict.CBrSPDEobj_+3A_only_latent">only_latent</code></td>
<td>
<p>Should the posterior samples be only given to the laten model?</p>
</td></tr>
<tr><td><code id="predict.CBrSPDEobj_+3A_...">...</code></td>
<td>
<p>further arguments passed to or from other methods.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with elements
</p>
<table role = "presentation">
<tr><td><code>mean</code></td>
<td>
<p>The kriging predictor (the posterior mean of u|Y).</p>
</td></tr>
<tr><td><code>variance</code></td>
<td>
<p>The posterior variances (if computed).</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(123)
# Sample a Gaussian Matern process on R using a rational approximation
kappa &lt;- 10
sigma &lt;- 1
nu &lt;- 0.8
sigma.e &lt;- 0.3
range &lt;- 0.2

# create mass and stiffness matrices for a FEM discretization
x &lt;- seq(from = 0, to = 1, length.out = 101)
fem &lt;- rSPDE.fem1d(x)

tau &lt;- sqrt(gamma(nu) / (sigma^2 * kappa^(2 * nu) *
  (4 * pi)^(1 / 2) * gamma(nu + 1 / 2)))

# Compute the covariance-based rational approximation
op_cov &lt;- matern.operators(
  loc_mesh = x, nu = nu,
  range = range, sigma = sigma, d = 1, m = 2,
  parameterization = "matern"
)

# Sample the model
u &lt;- simulate(op_cov)

# Create some data
obs.loc &lt;- runif(n = 10, min = 0, max = 1)
A &lt;- rSPDE.A1d(x, obs.loc)
Y &lt;- as.vector(A %*% u + sigma.e * rnorm(10))

# compute kriging predictions at the FEM grid
A.krig &lt;- rSPDE.A1d(x, x)
u.krig &lt;- predict(op_cov,
  A = A, Aprd = A.krig, Y = Y, sigma.e = sigma.e,
  compute.variances = TRUE
)

plot(obs.loc, Y,
  ylab = "u(x)", xlab = "x", main = "Data and prediction",
  ylim = c(
    min(u.krig$mean - 2 * sqrt(u.krig$variance)),
    max(u.krig$mean + 2 * sqrt(u.krig$variance))
  )
)
lines(x, u.krig$mean)
lines(x, u.krig$mean + 2 * sqrt(u.krig$variance), col = 2)
lines(x, u.krig$mean - 2 * sqrt(u.krig$variance), col = 2)
</code></pre>

<hr>
<h2 id='predict.CBrSPDEobj2d'>Prediction of an anisotropic Whittle-Matern field</h2><span id='topic+predict.CBrSPDEobj2d'></span>

<h3>Description</h3>

<p>The function is used for computing kriging predictions based
on data <code class="reqn">Y_i = u(s_i) + \epsilon_i</code>, where <code class="reqn">\epsilon</code>
is mean-zero Gaussian measurement noise and <code class="reqn">u(s)</code> is defined by
a SPDE as described in <code><a href="#topic+matern2d.operators">matern2d.operators()</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'CBrSPDEobj2d'
predict(
  object,
  A,
  Aprd,
  Y,
  sigma.e,
  mu = 0,
  compute.variances = FALSE,
  posterior_samples = FALSE,
  n_samples = 100,
  only_latent = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="predict.CBrSPDEobj2d_+3A_object">object</code></td>
<td>
<p>The covariance-based rational SPDE approximation,
computed using <code><a href="#topic+matern2d.operators">matern2d.operators()</a></code></p>
</td></tr>
<tr><td><code id="predict.CBrSPDEobj2d_+3A_a">A</code></td>
<td>
<p>A matrix linking the measurement locations to the basis of the FEM
approximation of the latent model.</p>
</td></tr>
<tr><td><code id="predict.CBrSPDEobj2d_+3A_aprd">Aprd</code></td>
<td>
<p>A matrix linking the prediction locations to the basis of the
FEM approximation of the latent model.</p>
</td></tr>
<tr><td><code id="predict.CBrSPDEobj2d_+3A_y">Y</code></td>
<td>
<p>A vector with the observed data, can also be a matrix where the
columns are observations
of independent replicates of <code class="reqn">u</code>.</p>
</td></tr>
<tr><td><code id="predict.CBrSPDEobj2d_+3A_sigma.e">sigma.e</code></td>
<td>
<p>The standard deviation of the Gaussian measurement noise.
Put to zero if the model does not have measurement noise.</p>
</td></tr>
<tr><td><code id="predict.CBrSPDEobj2d_+3A_mu">mu</code></td>
<td>
<p>Expectation vector of the latent field (default = 0).</p>
</td></tr>
<tr><td><code id="predict.CBrSPDEobj2d_+3A_compute.variances">compute.variances</code></td>
<td>
<p>Set to also TRUE to compute the kriging variances.</p>
</td></tr>
<tr><td><code id="predict.CBrSPDEobj2d_+3A_posterior_samples">posterior_samples</code></td>
<td>
<p>If <code>TRUE</code>, posterior samples will be returned.</p>
</td></tr>
<tr><td><code id="predict.CBrSPDEobj2d_+3A_n_samples">n_samples</code></td>
<td>
<p>Number of samples to be returned. Will only be used if <code>sampling</code> is <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="predict.CBrSPDEobj2d_+3A_only_latent">only_latent</code></td>
<td>
<p>Should the posterior samples be only given to the laten model?</p>
</td></tr>
<tr><td><code id="predict.CBrSPDEobj2d_+3A_...">...</code></td>
<td>
<p>further arguments passed to or from other methods.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with elements
</p>
<table role = "presentation">
<tr><td><code>mean</code></td>
<td>
<p>The kriging predictor (the posterior mean of u|Y).</p>
</td></tr>
<tr><td><code>variance</code></td>
<td>
<p>The posterior variances (if computed).</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'> library(fmesher)
 n_loc &lt;- 2000
 loc_2d_mesh &lt;- matrix(runif(n_loc * 2), n_loc, 2)
 mesh_2d &lt;- fm_mesh_2d(loc = loc_2d_mesh, cutoff = 0.01, max.edge = c(0.1, 0.5))
 op &lt;- matern2d.operators(hx = 0.08, hy = 0.08, hxy = 0.5, nu = 0.5, 
 sigma = 1, mesh = mesh_2d)
 u &lt;- simulate(op)
 n.obs &lt;- 2000
 obs.loc &lt;- cbind(runif(n.obs),runif(n.obs))
 A &lt;- fm_basis(mesh_2d,obs.loc)
 sigma.e &lt;- 0.1
 Y &lt;- as.vector(A%*%u + sigma.e*rnorm(n.obs))
 A &lt;- op$make_A(obs.loc)
 proj &lt;- fm_evaluator(mesh_2d, dims = c(100, 100),
             xlim = c(0,1), ylim = c(0,1))
 Aprd &lt;- op$make_A(proj$lattice$loc)
 u.krig &lt;- predict(op, A = A, Aprd = Aprd, Y = Y, sigma.e = sigma.e)
</code></pre>

<hr>
<h2 id='predict.inla_rspde_matern1d'>Predict method for 'inlabru' stationary Matern 1d models</h2><span id='topic+predict.inla_rspde_matern1d'></span>

<h3>Description</h3>

<p>Auxiliar function to obtain predictions of the stationary Matern 1d models
using 'inlabru'.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'inla_rspde_matern1d'
predict(
  object,
  cmp,
  bru_fit,
  newdata = NULL,
  formula = NULL,
  n.samples = 100,
  seed = 0L,
  probs = c(0.025, 0.5, 0.975),
  return_original_order = TRUE,
  num.threads = NULL,
  include = NULL,
  exclude = NULL,
  drop = FALSE,
  tolerance = 1e-04,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="predict.inla_rspde_matern1d_+3A_object">object</code></td>
<td>
<p>An <code>inla_rspde_matern1d</code> object built with the <code>rspde.matern1d()</code>
function.</p>
</td></tr>
<tr><td><code id="predict.inla_rspde_matern1d_+3A_cmp">cmp</code></td>
<td>
<p>The 'inlabru' component used to fit the model.</p>
</td></tr>
<tr><td><code id="predict.inla_rspde_matern1d_+3A_bru_fit">bru_fit</code></td>
<td>
<p>A fitted model using 'inlabru' or 'INLA'.</p>
</td></tr>
<tr><td><code id="predict.inla_rspde_matern1d_+3A_newdata">newdata</code></td>
<td>
<p>A data.frame of covariates needed for the prediction.</p>
</td></tr>
<tr><td><code id="predict.inla_rspde_matern1d_+3A_formula">formula</code></td>
<td>
<p>A formula where the right hand side defines an R expression to
evaluate for each generated sample. If NULL, the latent and hyperparameter
states are returned as named list elements. See Details for more information.</p>
</td></tr>
<tr><td><code id="predict.inla_rspde_matern1d_+3A_n.samples">n.samples</code></td>
<td>
<p>Integer setting the number of samples to draw in order to
calculate the posterior statistics. The default is rather low but provides a
quick approximate result.</p>
</td></tr>
<tr><td><code id="predict.inla_rspde_matern1d_+3A_seed">seed</code></td>
<td>
<p>Random number generator seed passed on to <code>inla.posterior.sample()</code></p>
</td></tr>
<tr><td><code id="predict.inla_rspde_matern1d_+3A_probs">probs</code></td>
<td>
<p>A numeric vector of probabilities with values in the standard
unit interval to be passed to stats::quantile</p>
</td></tr>
<tr><td><code id="predict.inla_rspde_matern1d_+3A_return_original_order">return_original_order</code></td>
<td>
<p>Should the predictions be returned in the
original order?</p>
</td></tr>
<tr><td><code id="predict.inla_rspde_matern1d_+3A_num.threads">num.threads</code></td>
<td>
<p>Specification of desired number of threads for parallel
computations. Default NULL, leaves it up to 'INLA'. When seed != 0, overridden to &quot;1:1&quot;</p>
</td></tr>
<tr><td><code id="predict.inla_rspde_matern1d_+3A_include">include</code></td>
<td>
<p>Character vector of component labels that are needed by the
predictor expression; Default: NULL (include all components that are not
explicitly excluded)</p>
</td></tr>
<tr><td><code id="predict.inla_rspde_matern1d_+3A_exclude">exclude</code></td>
<td>
<p>Character vector of component labels that are not used by the
predictor expression. The exclusion list is applied to the list as determined
by the include parameter; Default: NULL (do not remove any components from
the inclusion list)</p>
</td></tr>
<tr><td><code id="predict.inla_rspde_matern1d_+3A_drop">drop</code></td>
<td>
<p>logical; If keep=FALSE, data is a SpatialDataFrame, and the
prediciton summary has the same number of rows as data, then the output is a
SpatialDataFrame object. Default FALSE.</p>
</td></tr>
<tr><td><code id="predict.inla_rspde_matern1d_+3A_tolerance">tolerance</code></td>
<td>
<p>Tolerance for merging locations.</p>
</td></tr>
<tr><td><code id="predict.inla_rspde_matern1d_+3A_...">...</code></td>
<td>
<p>Additional arguments passed on to <code>inla.posterior.sample()</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with predictions.
</p>

<hr>
<h2 id='predict.rspde_lme'>Prediction of a mixed effects regression model on a metric graph.</h2><span id='topic+predict.rspde_lme'></span>

<h3>Description</h3>

<p>Prediction of a mixed effects regression model on a metric graph.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'rspde_lme'
predict(
  object,
  newdata = NULL,
  loc = NULL,
  time = NULL,
  mesh = FALSE,
  which_repl = NULL,
  compute_variances = FALSE,
  posterior_samples = FALSE,
  n_samples = 100,
  sample_latent = FALSE,
  return_as_list = FALSE,
  return_original_order = TRUE,
  ...,
  data = deprecated()
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="predict.rspde_lme_+3A_object">object</code></td>
<td>
<p>The fitted object with the <code>rspde_lme()</code> function</p>
</td></tr>
<tr><td><code id="predict.rspde_lme_+3A_newdata">newdata</code></td>
<td>
<p>A <code>data.frame</code> or a <code>list</code> containing the covariates, the edge
number and the distance on edge for the locations to obtain the prediction.</p>
</td></tr>
<tr><td><code id="predict.rspde_lme_+3A_loc">loc</code></td>
<td>
<p>Prediction locations. Can either be a <code>data.frame</code>, a <code>matrix</code> or
a character vector, that contains the names of the columns of the coordinates
of the locations. For models using <code>metric_graph</code> objects, plase use
<code>edge_number</code> and <code>distance_on_edge</code> instead.</p>
</td></tr>
<tr><td><code id="predict.rspde_lme_+3A_time">time</code></td>
<td>
<p>Prediction times for spatio-temporal models.</p>
</td></tr>
<tr><td><code id="predict.rspde_lme_+3A_mesh">mesh</code></td>
<td>
<p>Obtain predictions for mesh nodes? The graph must have a mesh, and
either <code>only_latent</code> is set to TRUE or the model does not have covariates.</p>
</td></tr>
<tr><td><code id="predict.rspde_lme_+3A_which_repl">which_repl</code></td>
<td>
<p>Which replicates to use? If <code>NULL</code> all replicates will be used.</p>
</td></tr>
<tr><td><code id="predict.rspde_lme_+3A_compute_variances">compute_variances</code></td>
<td>
<p>Set to also TRUE to compute the kriging variances.</p>
</td></tr>
<tr><td><code id="predict.rspde_lme_+3A_posterior_samples">posterior_samples</code></td>
<td>
<p>If <code>TRUE</code>, posterior samples will be returned.</p>
</td></tr>
<tr><td><code id="predict.rspde_lme_+3A_n_samples">n_samples</code></td>
<td>
<p>Number of samples to be returned. Will only be used if
<code>sampling</code> is <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="predict.rspde_lme_+3A_sample_latent">sample_latent</code></td>
<td>
<p>Do posterior samples only for the random effects?</p>
</td></tr>
<tr><td><code id="predict.rspde_lme_+3A_return_as_list">return_as_list</code></td>
<td>
<p>Should the means of the predictions and the posterior
samples be returned as a list, with each replicate being an element?</p>
</td></tr>
<tr><td><code id="predict.rspde_lme_+3A_return_original_order">return_original_order</code></td>
<td>
<p>Should the results be return in the original
(input) order or in the order inside the graph?</p>
</td></tr>
<tr><td><code id="predict.rspde_lme_+3A_...">...</code></td>
<td>
<p>Additional arguments. Expert use only.</p>
</td></tr>
<tr><td><code id="predict.rspde_lme_+3A_data">data</code></td>
<td>
<p><a href="https://lifecycle.r-lib.org/articles/stages.html#deprecated"><img src="../help/figures/lifecycle-deprecated.svg" alt='[Deprecated]' /></a> Use <code>newdata</code> instead.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with elements <code>mean</code>, which contains the means of the
predictions, <code>fe_mean</code>, which is the prediction for the fixed effects,
<code>re_mean</code>, which is the prediction for the random effects, <code>variance</code> (if
<code>compute_variance</code> is <code>TRUE</code>), which contains the variances of the predictions,
<code>samples</code> (if <code>posterior_samples</code> is <code>TRUE</code>), which contains the posterior samples.
</p>

<hr>
<h2 id='predict.rSPDEobj'>Prediction of a fractional SPDE using a rational SPDE approximation</h2><span id='topic+predict.rSPDEobj'></span>

<h3>Description</h3>

<p>The function is used for computing kriging predictions based on data
<code class="reqn">Y_i = u(s_i) + \epsilon_i</code>,
where <code class="reqn">\epsilon</code> is mean-zero Gaussian measurement noise
and <code class="reqn">u(s)</code> is defined by
a fractional SPDE <code class="reqn">L^\beta u(s) = W</code>, where
<code class="reqn">W</code> is Gaussian white noise.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'rSPDEobj'
predict(
  object,
  A,
  Aprd,
  Y,
  sigma.e,
  compute.variances = FALSE,
  posterior_samples = FALSE,
  n_samples = 100,
  only_latent = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="predict.rSPDEobj_+3A_object">object</code></td>
<td>
<p>The rational SPDE approximation, computed using
<code><a href="#topic+fractional.operators">fractional.operators()</a></code>,
<code><a href="#topic+matern.operators">matern.operators()</a></code>, or <code><a href="#topic+spde.matern.operators">spde.matern.operators()</a></code>.</p>
</td></tr>
<tr><td><code id="predict.rSPDEobj_+3A_a">A</code></td>
<td>
<p>A matrix linking the measurement locations to the basis of the
FEM approximation of the latent model.</p>
</td></tr>
<tr><td><code id="predict.rSPDEobj_+3A_aprd">Aprd</code></td>
<td>
<p>A matrix linking the prediction locations to the basis of the
FEM approximation of the latent model.</p>
</td></tr>
<tr><td><code id="predict.rSPDEobj_+3A_y">Y</code></td>
<td>
<p>A vector with the observed data, can also be a matrix where the
columns are observations
of independent replicates of <code class="reqn">u</code>.</p>
</td></tr>
<tr><td><code id="predict.rSPDEobj_+3A_sigma.e">sigma.e</code></td>
<td>
<p>The standard deviation of the Gaussian measurement noise.
Put to zero if the model
does not have measurement noise.</p>
</td></tr>
<tr><td><code id="predict.rSPDEobj_+3A_compute.variances">compute.variances</code></td>
<td>
<p>Set to also TRUE to compute the kriging variances.</p>
</td></tr>
<tr><td><code id="predict.rSPDEobj_+3A_posterior_samples">posterior_samples</code></td>
<td>
<p>If <code>TRUE</code>, posterior samples will be returned.</p>
</td></tr>
<tr><td><code id="predict.rSPDEobj_+3A_n_samples">n_samples</code></td>
<td>
<p>Number of samples to be returned. Will only be used if <code>sampling</code> is <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="predict.rSPDEobj_+3A_only_latent">only_latent</code></td>
<td>
<p>Should the posterior samples be only given to the latent model?</p>
</td></tr>
<tr><td><code id="predict.rSPDEobj_+3A_...">...</code></td>
<td>
<p>further arguments passed to or from other methods.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with elements
</p>
<table role = "presentation">
<tr><td><code>mean</code></td>
<td>
<p>The kriging predictor (the posterior mean of u|Y).</p>
</td></tr>
<tr><td><code>variance</code></td>
<td>
<p>The posterior variances (if computed).</p>
</td></tr>
<tr><td><code>samples</code></td>
<td>
<p>A matrix containing the samples if <code>sampling</code> is <code>TRUE</code>.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'># Sample a Gaussian Matern process on R using a rational approximation
kappa &lt;- 10
sigma &lt;- 1
nu &lt;- 0.8
sigma.e &lt;- 0.3
range &lt;- sqrt(8 * nu) / kappa

# create mass and stiffness matrices for a FEM discretization
x &lt;- seq(from = 0, to = 1, length.out = 101)
fem &lt;- rSPDE.fem1d(x)

# compute rational approximation
op &lt;- matern.operators(
  range = range, sigma = sigma,
  nu = nu, loc_mesh = x, d = 1,
  parameterization = "matern"
)

# Sample the model
u &lt;- simulate(op)

# Create some data
obs.loc &lt;- runif(n = 10, min = 0, max = 1)
A &lt;- rSPDE.A1d(x, obs.loc)
Y &lt;- as.vector(A %*% u + sigma.e * rnorm(10))

# compute kriging predictions at the FEM grid
A.krig &lt;- rSPDE.A1d(x, x)
u.krig &lt;- predict(op,
  A = A, Aprd = A.krig, Y = Y, sigma.e = sigma.e,
  compute.variances = TRUE
)

plot(obs.loc, Y,
  ylab = "u(x)", xlab = "x", main = "Data and prediction",
  ylim = c(
    min(u.krig$mean - 2 * sqrt(u.krig$variance)),
    max(u.krig$mean + 2 * sqrt(u.krig$variance))
  )
)
lines(x, u.krig$mean)
lines(x, u.krig$mean + 2 * sqrt(u.krig$variance), col = 2)
lines(x, u.krig$mean - 2 * sqrt(u.krig$variance), col = 2)
</code></pre>

<hr>
<h2 id='predict.spacetimeobj'>Prediction of a space-time SPDE</h2><span id='topic+predict.spacetimeobj'></span>

<h3>Description</h3>

<p>The function is used for computing kriging predictions based
on data <code class="reqn">Y_i = u(s_i,t_i) + \epsilon_i</code>, where <code class="reqn">\epsilon</code>
is mean-zero Gaussian measurement noise and <code class="reqn">u(s,t)</code> is defined by
a spatio-temporal SPDE as described in <code><a href="#topic+spacetime.operators">spacetime.operators()</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'spacetimeobj'
predict(
  object,
  A,
  Aprd,
  Y,
  sigma.e,
  mu = 0,
  compute.variances = FALSE,
  posterior_samples = FALSE,
  n_samples = 100,
  only_latent = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="predict.spacetimeobj_+3A_object">object</code></td>
<td>
<p>The covariance-based rational SPDE approximation,
computed using <code><a href="#topic+spacetime.operators">spacetime.operators()</a></code></p>
</td></tr>
<tr><td><code id="predict.spacetimeobj_+3A_a">A</code></td>
<td>
<p>A matrix linking the measurement locations to the basis of the FEM
approximation of the latent model.</p>
</td></tr>
<tr><td><code id="predict.spacetimeobj_+3A_aprd">Aprd</code></td>
<td>
<p>A matrix linking the prediction locations to the basis of the
FEM approximation of the latent model.</p>
</td></tr>
<tr><td><code id="predict.spacetimeobj_+3A_y">Y</code></td>
<td>
<p>A vector with the observed data, can also be a matrix where the
columns are observations
of independent replicates of <code class="reqn">u</code>.</p>
</td></tr>
<tr><td><code id="predict.spacetimeobj_+3A_sigma.e">sigma.e</code></td>
<td>
<p>The standard deviation of the Gaussian measurement noise.
Put to zero if the model does not have measurement noise.</p>
</td></tr>
<tr><td><code id="predict.spacetimeobj_+3A_mu">mu</code></td>
<td>
<p>Expectation vector of the latent field (default = 0).</p>
</td></tr>
<tr><td><code id="predict.spacetimeobj_+3A_compute.variances">compute.variances</code></td>
<td>
<p>Set to also TRUE to compute the kriging variances.</p>
</td></tr>
<tr><td><code id="predict.spacetimeobj_+3A_posterior_samples">posterior_samples</code></td>
<td>
<p>If <code>TRUE</code>, posterior samples will be returned.</p>
</td></tr>
<tr><td><code id="predict.spacetimeobj_+3A_n_samples">n_samples</code></td>
<td>
<p>Number of samples to be returned. Will only be used if <code>sampling</code> is <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="predict.spacetimeobj_+3A_only_latent">only_latent</code></td>
<td>
<p>Should the posterior samples be only given to the laten model?</p>
</td></tr>
<tr><td><code id="predict.spacetimeobj_+3A_...">...</code></td>
<td>
<p>further arguments passed to or from other methods.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with elements
</p>
<table role = "presentation">
<tr><td><code>mean</code></td>
<td>
<p>The kriging predictor (the posterior mean of u|Y).</p>
</td></tr>
<tr><td><code>variance</code></td>
<td>
<p>The posterior variances (if computed).</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>s &lt;- seq(from = 0, to = 20, length.out = 101)
t &lt;- seq(from = 0, to = 20, length.out = 31)

op_cov &lt;- spacetime.operators(space_loc = s, time_loc = t,
                             kappa = 5, sigma = 10, alpha = 1,
                             beta = 2, rho = 1, gamma = 0.05)
# generate data
sigma.e &lt;- 0.01
n.obs &lt;- 500
obs.loc &lt;- data.frame(x = max(s)*runif(n.obs), 
                     t = max(t)*runif(n.obs))
A &lt;- rSPDE.Ast(space_loc = s, time_loc = t, obs.s = obs.loc$x, obs.t = obs.loc$t)
Aprd &lt;- Diagonal(dim(A)[2])
x &lt;- simulate(op_cov, nsim = 1) 
Y &lt;- A%*%x + sigma.e*rnorm(n.obs)
u.krig &lt;- predict(op_cov, A, Aprd, Y, sigma.e)
</code></pre>

<hr>
<h2 id='rational.order'>Get the order of rational approximation.</h2><span id='topic+rational.order'></span>

<h3>Description</h3>

<p>Get the order of rational approximation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rational.order(object)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="rational.order_+3A_object">object</code></td>
<td>
<p>A <code>CBrSPDEobj</code> object or an <code>inla_rspde</code> object.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The order of rational approximation.
</p>

<hr>
<h2 id='rational.order+26lt+3B-'>Changing the order of the rational approximation</h2><span id='topic+rational.order+3C-'></span>

<h3>Description</h3>

<p>Changing the order of the rational approximation
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rational.order(x) &lt;- value
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="rational.order+2B26lt+2B3B-_+3A_x">x</code></td>
<td>
<p>A <code>CBrSPDE</code> or an <code>rpsde.inla</code> object</p>
</td></tr>
<tr><td><code id="rational.order+2B26lt+2B3B-_+3A_value">value</code></td>
<td>
<p>The order of rational approximation.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of the same class with the new order
of rational approximation.
</p>

<hr>
<h2 id='rational.type'>Get type of rational approximation.</h2><span id='topic+rational.type'></span>

<h3>Description</h3>

<p>Get type of rational approximation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rational.type(object)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="rational.type_+3A_object">object</code></td>
<td>
<p>A <code>CBrSPDEobj</code> object or an <code>inla_rspde</code> object.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The type of rational approximation.
</p>

<hr>
<h2 id='rational.type+26lt+3B-'>Changing the type of the rational approximation</h2><span id='topic+rational.type+3C-'></span>

<h3>Description</h3>

<p>Changing the type of the rational approximation
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rational.type(x) &lt;- value
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="rational.type+2B26lt+2B3B-_+3A_x">x</code></td>
<td>
<p>A <code>CBrSPDE</code> or an <code>rpsde.inla</code> object</p>
</td></tr>
<tr><td><code id="rational.type+2B26lt+2B3B-_+3A_value">value</code></td>
<td>
<p>The type of rational approximation.
The current options are &quot;chebfun&quot;, &quot;brasil&quot; and &quot;chebfunLB&quot;</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of the same class with the new rational approximation.
</p>

<hr>
<h2 id='require.nowarnings'>Warnings free loading of add-on packages</h2><span id='topic+require.nowarnings'></span>

<h3>Description</h3>

<p>Turn off all warnings for require(), to allow clean completion
of examples that require unavailable Suggested packages.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>require.nowarnings(package, lib.loc = NULL, character.only = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="require.nowarnings_+3A_package">package</code></td>
<td>
<p>The name of a package, given as a character string.</p>
</td></tr>
<tr><td><code id="require.nowarnings_+3A_lib.loc">lib.loc</code></td>
<td>
<p>a character vector describing the location of R library trees
to search through, or <code>NULL</code>.  The default value of <code>NULL</code>
corresponds to all libraries currently known to <code>.libPaths()</code>.
Non-existent library trees are silently ignored.</p>
</td></tr>
<tr><td><code id="require.nowarnings_+3A_character.only">character.only</code></td>
<td>
<p>a logical indicating whether <code>package</code> can be
assumed to be a character string.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>require(package)</code> acts the same as
<code>require(package, quietly = TRUE)</code> but with warnings turned off.
In particular, no warning or error is given if the package is unavailable.
Most cases should use <code>requireNamespace(package, quietly = TRUE)</code> instead,
which doesn't produce warnings.
</p>


<h3>Value</h3>

<p><code>require.nowarnings</code> returns (invisibly)
<code>TRUE</code> if it succeeds, otherwise <code>FALSE</code>
</p>


<h3>See Also</h3>

<p><code><a href="base.html#topic+require">require()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## This should produce no output:
if (require.nowarnings(nonexistent)) {
  message("Package loaded successfully")
}

</code></pre>

<hr>
<h2 id='rspde_lme'>rSPDE linear mixed effects models</h2><span id='topic+rspde_lme'></span>

<h3>Description</h3>

<p>Fitting linear mixed effects model with latent Whittle-Matern models.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rspde_lme(
  formula,
  loc,
  loc_time = NULL,
  data,
  model = NULL,
  repl = NULL,
  which_repl = NULL,
  optim_method = "L-BFGS-B",
  use_data_from_graph = TRUE,
  starting_values_latent = NULL,
  start_sigma_e = NULL,
  start_alpha = NULL,
  alpha = NULL,
  start_nu = NULL,
  nu = NULL,
  nu_upper_bound = 4,
  rspde_order = NULL,
  parallel = FALSE,
  n_cores = parallel::detectCores() - 1,
  optim_controls = list(),
  improve_hessian = FALSE,
  hessian_args = list()
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="rspde_lme_+3A_formula">formula</code></td>
<td>
<p>Formula object describing the relation between the response
variables and the fixed effects. If the response variable is a matrix, each
column of the matrix will be treated as a replicate.</p>
</td></tr>
<tr><td><code id="rspde_lme_+3A_loc">loc</code></td>
<td>
<p>A vector with the names of the columns in <code>data</code> that contain the
observation locations, or a <code>matrix</code> or a <code>data.frame</code> containing the
observation locations. If the model is of class <code>metric_graph</code>, the locations
must be either a <code>matrix</code> or a <code>data.frame</code> with two columns, or a character
vector with the names of the two columns. The first column being the number of
the edge, and the second column being the normalized position on the edge.
If the model is a 2d model, <code>loc</code> must be either a <code>matrix</code> or <code>data.frame</code>
with two columns or a character vector with the name of the two columns that
contain the location, the first entry corresponding to the <code>x</code> entry and the
second corresponding to the <code>y</code> entry.</p>
</td></tr>
<tr><td><code id="rspde_lme_+3A_loc_time">loc_time</code></td>
<td>
<p>For spatio-temporal models, the name of the column in <code>data</code> that
is the time variable, or a <code>matrix</code> or <code>vector</code> containing the observation time
points.</p>
</td></tr>
<tr><td><code id="rspde_lme_+3A_data">data</code></td>
<td>
<p>A <code>data.frame</code> containing the data to be used.</p>
</td></tr>
<tr><td><code id="rspde_lme_+3A_model">model</code></td>
<td>
<p>Object generated by <code>matern.operators()</code>, <code>spde.matern.operators()</code>
or <code>spacetime.operators()</code>. If <code>NULL</code>, simple linear regression will be performed.</p>
</td></tr>
<tr><td><code id="rspde_lme_+3A_repl">repl</code></td>
<td>
<p>Vector indicating the replicate of each observation.
If <code>NULL</code> it will assume there is only one replicate. If the model is generated from graphs from
<code>metric_graph</code> class and <code>use_data_from_graph</code> is <code>TRUE</code>, <code>repl</code> needs to be the name of the
column inside the metric graph data that contains the replicate. If <code>NULL</code> it will assume there is only
one replicate.</p>
</td></tr>
<tr><td><code id="rspde_lme_+3A_which_repl">which_repl</code></td>
<td>
<p>Which replicates to use? If <code>NULL</code> all replicates will be used.</p>
</td></tr>
<tr><td><code id="rspde_lme_+3A_optim_method">optim_method</code></td>
<td>
<p>The method to be used with <code>optim</code> function.</p>
</td></tr>
<tr><td><code id="rspde_lme_+3A_use_data_from_graph">use_data_from_graph</code></td>
<td>
<p>Logical. Only for models generated from graphs from
<code>metric_graph</code> class. In this case, should the data, the locations and the
replicates be obtained from the graph object?</p>
</td></tr>
<tr><td><code id="rspde_lme_+3A_starting_values_latent">starting_values_latent</code></td>
<td>
<p>A vector containing the starting values for the
latent model. If the latent model is generated by <code>matern.operators()</code>, then
the vector should be on the form c(tau,kappa). If the model is generated by
<code>spde.matern.operators()</code>, the vector should contain the nonstationary parameters.
If the model is generated by <code>spacetime.operators()</code>, the vector should be on
the form c(kappa,sigma,gamma,rho).</p>
</td></tr>
<tr><td><code id="rspde_lme_+3A_start_sigma_e">start_sigma_e</code></td>
<td>
<p>Starting value for the standard deviation of the
measurement error.</p>
</td></tr>
<tr><td><code id="rspde_lme_+3A_start_alpha">start_alpha</code></td>
<td>
<p>Starting value for the smoothness parameter of spatial
models. Will be used if <code>start_nu</code> is not given. Not used for spatio-temporal
models.</p>
</td></tr>
<tr><td><code id="rspde_lme_+3A_alpha">alpha</code></td>
<td>
<p>If <code>NULL</code>, the smoothness parameter will be estimated for spatial
models, otherwise it is kept fixed at the provided value. Will be used if <code>nu</code>
is not given. Not used for spatio-temporal models.
returned as component of the returned value.</p>
</td></tr>
<tr><td><code id="rspde_lme_+3A_start_nu">start_nu</code></td>
<td>
<p>Starting value for the smoothness parameter of spatial models.
Not used for spatio-temporal models.</p>
</td></tr>
<tr><td><code id="rspde_lme_+3A_nu">nu</code></td>
<td>
<p>If <code>NULL</code>, the smoothness parameter will be estimated for spatial
models, otherwise the smoothness parameter will be kept fixed at the provided
value. Not used for spatio-temporal models.</p>
</td></tr>
<tr><td><code id="rspde_lme_+3A_nu_upper_bound">nu_upper_bound</code></td>
<td>
<p>A parameter that limits the maximum value that nu can
assume. Not used for spatio-temporal models.</p>
</td></tr>
<tr><td><code id="rspde_lme_+3A_rspde_order">rspde_order</code></td>
<td>
<p>The order of the rational approximation to be used while
fitting the model. If not given, the order from the model object will be used.
Not used for spatio-temporal models.</p>
</td></tr>
<tr><td><code id="rspde_lme_+3A_parallel">parallel</code></td>
<td>
<p>logical. Indicating whether to use optimParallel or not.</p>
</td></tr>
<tr><td><code id="rspde_lme_+3A_n_cores">n_cores</code></td>
<td>
<p>Number of cores to be used if parallel is true.</p>
</td></tr>
<tr><td><code id="rspde_lme_+3A_optim_controls">optim_controls</code></td>
<td>
<p>Additional controls to be passed to <code>optim</code> or <code>optimParallel</code>.</p>
</td></tr>
<tr><td><code id="rspde_lme_+3A_improve_hessian">improve_hessian</code></td>
<td>
<p>Should a more precise estimate of the hessian be obtained?
Turning on might increase the overall time.</p>
</td></tr>
<tr><td><code id="rspde_lme_+3A_hessian_args">hessian_args</code></td>
<td>
<p>List of controls to be used if <code>improve_hessian</code> is <code>TRUE</code>.
The list can contain the arguments to be passed to the <code>method.args</code> argument
in the <code>numDeriv::hessian</code> function. See the help of the <code>hessian</code> function in
<code>numDeriv</code> package for details. Observe that it only accepts the &quot;Richardson&quot;
method for now, the method &quot;complex&quot; is not supported.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list containing the fitted model.
</p>

<hr>
<h2 id='rSPDE.A1d'>Observation matrix for finite element discretization on R</h2><span id='topic+rSPDE.A1d'></span>

<h3>Description</h3>

<p>A finite element discretization on R can be written as
<code class="reqn">u(s) = \sum_i^n u_i \varphi_i(s)</code>
where <code class="reqn">\varphi_i(s)</code> is a piecewise linear
&quot;hat function&quot; centered at location
<code class="reqn">x_i</code>. This function computes an
<code class="reqn">m\times n</code> matrix <code class="reqn">A</code>
that links the basis function in the expansion to specified locations
<code class="reqn">s = (s_1,\ldots, s_m)</code> in the domain through
<code class="reqn">A_ij = \varphi_j(s_i)</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rSPDE.A1d(x, loc)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="rSPDE.A1d_+3A_x">x</code></td>
<td>
<p>The locations of the nodes in the FEM discretization.</p>
</td></tr>
<tr><td><code id="rSPDE.A1d_+3A_loc">loc</code></td>
<td>
<p>The locations <code class="reqn">(s_1,\ldots, s_m)</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>The sparse matrix <code>A</code>.
</p>


<h3>Author(s)</h3>

<p>David Bolin <a href="mailto:davidbolin@gmail.com">davidbolin@gmail.com</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+rSPDE.fem1d">rSPDE.fem1d()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># create mass and stiffness matrices for a FEM discretization on [0,1]
x &lt;- seq(from = 0, to = 1, length.out = 101)
fem &lt;- rSPDE.fem1d(x)

# create the observation matrix for some locations in the domain
obs.loc &lt;- runif(n = 10, min = 0, max = 1)
A &lt;- rSPDE.A1d(x, obs.loc)
</code></pre>

<hr>
<h2 id='rspde.anistropic2d'>Rational approximations of stationary anisotropic Gaussian Matern random fields</h2><span id='topic+rspde.anistropic2d'></span>

<h3>Description</h3>

<p><code>rspde.anistropic2d</code> computes a Finite Element Method (FEM) approximation of a
Gaussian random field defined as the solution to the stochastic partial
differential equation (SPDE):
</p>
<p style="text-align: center;"><code class="reqn">C(h) = \frac{\sigma^2}{2^{\nu-1}\Gamma(\nu)}(\sqrt{h^T H^{-1}h})^\nu K_\nu(\sqrt{h^T H^{-1}h})</code>
</p>
<p>,
based on a SPDE representation of the form
</p>
<p style="text-align: center;"><code class="reqn">(I - \nabla\cdot(H\nabla))^{(\nu+1)/2}u = c\sigma W</code>
</p>
<p>,
where $c&gt;0$ is a constant. The matrix <code class="reqn">H</code> is defined as
</p>
<p style="text-align: center;"><code class="reqn">\begin{bmatrix}
h_x^2 &amp; h_xh_yh_{xy} \\
h_xh_yh_{xy} &amp; h_y^2
\end{bmatrix}</code>
</p>



<h3>Usage</h3>

<pre><code class='language-R'>rspde.anistropic2d(
  mesh,
  nu = NULL,
  nu.upper.bound = 2,
  rspde.order = 1,
  prior.hx = NULL,
  prior.hy = NULL,
  prior.hxy = NULL,
  prior.sigma = NULL,
  prior.precision = NULL,
  prior.nu = NULL,
  prior.nu.dist = "lognormal",
  nu.prec.inc = 0.01,
  type.rational.approx = "chebfun",
  shared_lib = "detect",
  debug = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="rspde.anistropic2d_+3A_mesh">mesh</code></td>
<td>
<p>Spatial mesh for the FEM approximation.</p>
</td></tr>
<tr><td><code id="rspde.anistropic2d_+3A_nu">nu</code></td>
<td>
<p>If nu is set to a parameter, nu will be kept fixed and will not
be estimated. If nu is <code>NULL</code>, it will be estimated.</p>
</td></tr>
<tr><td><code id="rspde.anistropic2d_+3A_nu.upper.bound">nu.upper.bound</code></td>
<td>
<p>Upper bound for the smoothness parameter <code class="reqn">\nu</code>. If <code>NULL</code>, it will be set to 2.</p>
</td></tr>
<tr><td><code id="rspde.anistropic2d_+3A_rspde.order">rspde.order</code></td>
<td>
<p>The order of the covariance-based rational SPDE approach. The default order is 1.</p>
</td></tr>
<tr><td><code id="rspde.anistropic2d_+3A_prior.hx">prior.hx</code></td>
<td>
<p>A list specifying the prior for the parameter <code class="reqn">h_x</code> in the matrix <code class="reqn">H</code>. This list may contain two elements: <code>mean</code> and/or <code>precision</code>, both of which must be numeric scalars. The precision refers to the prior on <code class="reqn">\log(h_x)</code>. If <code>NULL</code>, default values will be used. The <code>mean</code> value is also used as starting value for hx.</p>
</td></tr>
<tr><td><code id="rspde.anistropic2d_+3A_prior.hy">prior.hy</code></td>
<td>
<p>A list specifying the prior for the parameter <code class="reqn">h_y</code> in the matrix <code class="reqn">H</code>. This list may contain two elements: <code>mean</code> and/or <code>precision</code>, both of which must be numeric scalars. The precision refers to the prior on <code class="reqn">\log(h_x)</code>. If <code>NULL</code>, default values will be used. The <code>mean</code> value is also used as starting value for hy.</p>
</td></tr>
<tr><td><code id="rspde.anistropic2d_+3A_prior.hxy">prior.hxy</code></td>
<td>
<p>A list specifying the prior for the parameter <code class="reqn">h_x</code> in the matrix <code class="reqn">H</code>. This list may contain two elements: <code>mean</code> and/or <code>precision</code>, both of which must be numeric scalars. The precision refers to the prior on <code class="reqn">\log((h_{xy}+1)/(1-h_{xy}))</code>. If <code>NULL</code>, default values will be used. The <code>mean</code> value is also used as starting value for hxy.</p>
</td></tr>
<tr><td><code id="rspde.anistropic2d_+3A_prior.sigma">prior.sigma</code></td>
<td>
<p>A list specifying the prior for the variance parameter <code class="reqn">\sigma</code>.
This list may contain two elements: <code>mean</code> and/or <code>precision</code>, both of which must
be numeric scalars. The precision refers to the prior on <code class="reqn">\log(\sigma)</code>. If <code>NULL</code>,
default values will be used. The <code>mean</code> value is also used as starting value for sigma.</p>
</td></tr>
<tr><td><code id="rspde.anistropic2d_+3A_prior.precision">prior.precision</code></td>
<td>
<p>A precision matrix for <code class="reqn">\log(h_x), \log(h_y), \log((h_{xy}+1)/(1-h_{xy})), \log(\sigma)</code>. This matrix replaces the precision
element from <code>prior.kappa</code>, <code>prior.sigma</code>, <code>prior.gamma</code>, and <code>prior.rho</code> respectively. For dimension 1 <code>prior.precision</code> must be a 4x4 matrix. For dimension 2, <code class="reqn">\rho</code> is a vector of length 2, so in this case <code>prior.precision</code> must be a 5x5 matrix. If <code>NULL</code>, a diagonal precision matrix with default values will be used.</p>
</td></tr>
<tr><td><code id="rspde.anistropic2d_+3A_prior.nu">prior.nu</code></td>
<td>
<p>a list containing the elements <code>mean</code> and <code>prec</code>
for beta distribution, or <code>loglocation</code> and <code>logscale</code> for a
truncated lognormal distribution. <code>loglocation</code> stands for
the location parameter of the truncated lognormal distribution in the log
scale. <code>prec</code> stands for the precision of a beta distribution.
<code>logscale</code> stands for the scale of the truncated lognormal
distribution on the log scale. Check details below.</p>
</td></tr>
<tr><td><code id="rspde.anistropic2d_+3A_prior.nu.dist">prior.nu.dist</code></td>
<td>
<p>The distribution of the smoothness parameter.
The current options are &quot;beta&quot; or &quot;lognormal&quot;. The default is &quot;lognormal&quot;.</p>
</td></tr>
<tr><td><code id="rspde.anistropic2d_+3A_nu.prec.inc">nu.prec.inc</code></td>
<td>
<p>Amount to increase the precision in the beta prior
distribution. Check details below.</p>
</td></tr>
<tr><td><code id="rspde.anistropic2d_+3A_type.rational.approx">type.rational.approx</code></td>
<td>
<p>Which type of rational approximation
should be used? The current types are &quot;chebfun&quot;, &quot;brasil&quot; or &quot;chebfunLB&quot;.</p>
</td></tr>
<tr><td><code id="rspde.anistropic2d_+3A_shared_lib">shared_lib</code></td>
<td>
<p>String specifying which shared library to use for the Cgeneric
implementation. Options are &quot;detect&quot;, &quot;INLA&quot;, or &quot;rSPDE&quot;. You may also specify the
direct path to a .so (or .dll) file.</p>
</td></tr>
<tr><td><code id="rspde.anistropic2d_+3A_debug">debug</code></td>
<td>
<p>Logical value indicating whether to enable INLA debug mode.</p>
</td></tr>
<tr><td><code id="rspde.anistropic2d_+3A_...">...</code></td>
<td>
<p>Additional arguments passed internally for configuration purposes.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <code>inla_rspde_spacetime</code> representing the FEM approximation of
the space-time Gaussian random field.
</p>

<hr>
<h2 id='rSPDE.Ast'>Observation matrix for space-time models</h2><span id='topic+rSPDE.Ast'></span>

<h3>Description</h3>

<p>Observation matrix for space-time models
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rSPDE.Ast(
  mesh_space = NULL,
  space_loc = NULL,
  mesh_time = NULL,
  time_loc = NULL,
  graph = NULL,
  obs.s = NULL,
  obs.t = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="rSPDE.Ast_+3A_mesh_space">mesh_space</code></td>
<td>
<p>mesh object for models on 1d or 2d domains</p>
</td></tr>
<tr><td><code id="rSPDE.Ast_+3A_space_loc">space_loc</code></td>
<td>
<p>mesh locations for models on 1d domains</p>
</td></tr>
<tr><td><code id="rSPDE.Ast_+3A_mesh_time">mesh_time</code></td>
<td>
<p>mesh object for time discretization</p>
</td></tr>
<tr><td><code id="rSPDE.Ast_+3A_time_loc">time_loc</code></td>
<td>
<p>mesh locations for time discretization</p>
</td></tr>
<tr><td><code id="rSPDE.Ast_+3A_graph">graph</code></td>
<td>
<p>MetricGraph object for models on metric graphs</p>
</td></tr>
<tr><td><code id="rSPDE.Ast_+3A_obs.s">obs.s</code></td>
<td>
<p>spatial locations of observations</p>
</td></tr>
<tr><td><code id="rSPDE.Ast_+3A_obs.t">obs.t</code></td>
<td>
<p>time points for observations</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Observation matrix linking observation locations to mesh nodes
</p>


<h3>Examples</h3>

<pre><code class='language-R'>s &lt;- seq(from = 0, to = 20, length.out = 11)
t &lt;- seq(from = 0, to = 20, length.out = 5)
n.obs &lt;- 10
obs.loc &lt;- data.frame(x = max(s)*runif(n.obs), 
t = max(t)*runif(n.obs))
A &lt;- rSPDE.Ast(space_loc = s,time_loc = t, 
               obs.s = obs.loc$x, obs.t = obs.loc$t)
</code></pre>

<hr>
<h2 id='rSPDE.construct.matern.loglike'>Constructor of Matern loglikelihood functions.</h2><span id='topic+rSPDE.construct.matern.loglike'></span>

<h3>Description</h3>

<p>This function returns a log-likelihood function for a
Gaussian process with a Matern covariance
function, that is observed under Gaussian measurement noise:
<code class="reqn">Y_i = u(s_i) + \epsilon_i</code>, where
<code class="reqn">\epsilon_i</code> are
iid mean-zero Gaussian variables. The latent model is approximated using
the a rational approximation
of the fractional SPDE model corresponding to the Gaussian process.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rSPDE.construct.matern.loglike(
  object,
  Y,
  A,
  sigma.e = NULL,
  mu = 0,
  nu = NULL,
  tau = NULL,
  kappa = NULL,
  sigma = NULL,
  range = NULL,
  parameterization = c("spde", "matern"),
  m = NULL,
  log_scale = TRUE,
  return_negative_likelihood = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="rSPDE.construct.matern.loglike_+3A_object">object</code></td>
<td>
<p>The rational SPDE approximation,
computed using <code><a href="#topic+matern.operators">matern.operators()</a></code></p>
</td></tr>
<tr><td><code id="rSPDE.construct.matern.loglike_+3A_y">Y</code></td>
<td>
<p>The observations, either a vector or a matrix where
the columns correspond to independent replicates of observations.</p>
</td></tr>
<tr><td><code id="rSPDE.construct.matern.loglike_+3A_a">A</code></td>
<td>
<p>An observation matrix that links the measurement location to the
finite element basis.</p>
</td></tr>
<tr><td><code id="rSPDE.construct.matern.loglike_+3A_sigma.e">sigma.e</code></td>
<td>
<p>IF non-null, the standard deviation of the measurement noise will be kept fixed in
the returned likelihood.</p>
</td></tr>
<tr><td><code id="rSPDE.construct.matern.loglike_+3A_mu">mu</code></td>
<td>
<p>Expectation vector of the latent field (default = 0).</p>
</td></tr>
<tr><td><code id="rSPDE.construct.matern.loglike_+3A_nu">nu</code></td>
<td>
<p>If non-null, the shape parameter will be kept fixed in the returned likelihood.</p>
</td></tr>
<tr><td><code id="rSPDE.construct.matern.loglike_+3A_tau">tau</code></td>
<td>
<p>If non-null, the tau parameter will be kept fixed in the returned likelihood. (Replaces sigma)</p>
</td></tr>
<tr><td><code id="rSPDE.construct.matern.loglike_+3A_kappa">kappa</code></td>
<td>
<p>If non-null, the range parameter will be kept fixed in the returned likelihood.</p>
</td></tr>
<tr><td><code id="rSPDE.construct.matern.loglike_+3A_sigma">sigma</code></td>
<td>
<p>If non-null, the standard deviation will be kept fixed in the returned likelihood.</p>
</td></tr>
<tr><td><code id="rSPDE.construct.matern.loglike_+3A_range">range</code></td>
<td>
<p>If non-null, the range parameter will be kept fixed in the returned likelihood. (Replaces kappa)</p>
</td></tr>
<tr><td><code id="rSPDE.construct.matern.loglike_+3A_parameterization">parameterization</code></td>
<td>
<p>If <code>spde</code>, then one will use the parameters <code>tau</code> and <code>kappa</code>. If <code>matern</code>, then one will use the parameters <code>sigma</code> and <code>range</code>.</p>
</td></tr>
<tr><td><code id="rSPDE.construct.matern.loglike_+3A_m">m</code></td>
<td>
<p>If non-null, update the order of the rational approximation,
which needs to be a positive integer.</p>
</td></tr>
<tr><td><code id="rSPDE.construct.matern.loglike_+3A_log_scale">log_scale</code></td>
<td>
<p>Should the parameters be evaluated in log-scale?</p>
</td></tr>
<tr><td><code id="rSPDE.construct.matern.loglike_+3A_return_negative_likelihood">return_negative_likelihood</code></td>
<td>
<p>Return minus the likelihood to turn the maximization into a minimization?</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The log-likelihood function. The parameters of the returned function
are given in the order sigma, kappa, nu, sigma.e, whenever they are available.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+matern.operators">matern.operators()</a></code>, <code><a href="#topic+predict.CBrSPDEobj">predict.CBrSPDEobj()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># this example illustrates how the function can be used for maximum
# likelihood estimation

set.seed(123)
# Sample a Gaussian Matern process on R using a rational approximation
nu &lt;- 0.8
sigma &lt;- 1
sigma.e &lt;- 0.1
n.rep &lt;- 10
n.obs &lt;- 200
n.x &lt;- 51
range &lt;- 0.2
# create mass and stiffness matrices for a FEM discretization
x &lt;- seq(from = 0, to = 1, length.out = n.x)
# Compute the covariance-based rational approximation
op_cov &lt;- matern.operators(
  loc_mesh = x, nu = nu,
  range = range, sigma = sigma, d = 1, m = 2,
  parameterization = "matern"
)
# Sample the model
u &lt;- simulate(op_cov, n.rep)
# Create some data
obs.loc &lt;- runif(n = n.obs, min = 0, max = 1)
A &lt;- rSPDE.A1d(x, obs.loc)
noise &lt;- rnorm(n.obs * n.rep)
dim(noise) &lt;- c(n.obs, n.rep)
Y &lt;- as.matrix(A %*% u + sigma.e * noise)

# Define the negative likelihood function for optimization
# using CBrSPDE.matern.loglike
# Matern parameterization
loglike &lt;- rSPDE.construct.matern.loglike(op_cov, Y, A, parameterization = "matern")

# The parameters can now be estimated by minimizing mlik with optim

# Choose some reasonable starting values depending on the size of the domain
theta0 &lt;- c(
  get.initial.values.rSPDE(mesh.range = 1, dim = 1),
  log(0.1 * sd(as.vector(Y)))
)
# run estimation and display the results
theta &lt;- optim(theta0, loglike,
  method = "L-BFGS-B"
)
print(data.frame(
  sigma = c(sigma, exp(theta$par[1])), range = c(range, exp(theta$par[2])),
  nu = c(nu, exp(theta$par[3])), sigma.e = c(sigma.e, exp(theta$par[4])),
  row.names = c("Truth", "Estimates")
))

</code></pre>

<hr>
<h2 id='rSPDE.fem1d'>Finite element calculations for problems on R</h2><span id='topic+rSPDE.fem1d'></span>

<h3>Description</h3>

<p>This function computes mass and stiffness matrices
for a FEM approximation on R, assuming
Neumann boundary conditions.
These matrices are needed when discretizing the
operators in rational approximations.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rSPDE.fem1d(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="rSPDE.fem1d_+3A_x">x</code></td>
<td>
<p>Locations of the nodes in the FEM approximation.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The function returns a list with the following elements
</p>
<table role = "presentation">
<tr><td><code>G</code></td>
<td>
<p>The stiffness matrix with elements <code class="reqn">(\nabla \phi_i, \nabla \phi_j)</code>.</p>
</td></tr>
<tr><td><code>C</code></td>
<td>
<p>The mass matrix with elements <code class="reqn">(\phi_i, \phi_j)</code>.</p>
</td></tr>
<tr><td><code>Cd</code></td>
<td>
<p>Mass lumped mass matrix.</p>
</td></tr>
<tr><td><code>B</code></td>
<td>
<p>Matrix with elements <code class="reqn">(\nabla \phi_i, \phi_j)</code>.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>David Bolin <a href="mailto:davidbolin@gmail.com">davidbolin@gmail.com</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+rSPDE.A1d">rSPDE.A1d()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># create mass and stiffness matrices for a FEM discretization on [0,1]
x &lt;- seq(from = 0, to = 1, length.out = 101)
fem &lt;- rSPDE.fem1d(x)
</code></pre>

<hr>
<h2 id='rSPDE.fem2d'>Finite element calculations for problems in 2D</h2><span id='topic+rSPDE.fem2d'></span>

<h3>Description</h3>

<p>This function computes mass and stiffness matrices for a mesh in 2D, assuming
Neumann boundary conditions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rSPDE.fem2d(FV, P)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="rSPDE.fem2d_+3A_fv">FV</code></td>
<td>
<p>Matrix where each row defines a triangle</p>
</td></tr>
<tr><td><code id="rSPDE.fem2d_+3A_p">P</code></td>
<td>
<p>Locations of the nodes in the mesh.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The function returns a list with the following elements
</p>
<table role = "presentation">
<tr><td><code>G</code></td>
<td>
<p>The stiffness matrix with elements <code class="reqn">(\nabla \phi_i, \nabla \phi_j)</code>.</p>
</td></tr>
<tr><td><code>C</code></td>
<td>
<p>The mass matrix with elements <code class="reqn">(\phi_i, \phi_j)</code>.</p>
</td></tr>
<tr><td><code>Cd</code></td>
<td>
<p>The mass lumped matrix with diagonal elements <code class="reqn">(\phi_i, 1)</code>.</p>
</td></tr>
<tr><td><code>Hxx</code></td>
<td>
<p>Matrix with elements <code class="reqn">(\partial_x \phi_i, \partial_x \phi_j)</code>.</p>
</td></tr>
<tr><td><code>Hyy</code></td>
<td>
<p>Matrix with elements <code class="reqn">(\partial_y \phi_i, \partial_y \phi_j)</code>.</p>
</td></tr>
<tr><td><code>Hxy</code></td>
<td>
<p>Matrix with elements <code class="reqn">(\partial_x \phi_i, \partial_y \phi_j)</code>.</p>
</td></tr>
<tr><td><code>Hyx</code></td>
<td>
<p>Matrix with elements <code class="reqn">(\partial_y \phi_i, \partial_x \phi_j)</code>.</p>
</td></tr>
<tr><td><code>Bx</code></td>
<td>
<p>Matrix with elements <code class="reqn">(\partial_x \phi_i, \phi_j)</code>.</p>
</td></tr>
<tr><td><code>By</code></td>
<td>
<p>Matrix with elements <code class="reqn">(\partial_y \phi_i, \phi_j)</code>.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>David Bolin <a href="mailto:davidbolin@gmail.com">davidbolin@gmail.com</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+rSPDE.fem1d">rSPDE.fem1d()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>P &lt;- rbind(c(0, 0), c(1, 0), c(1, 1), c(0, 1))
FV &lt;- rbind(c(1, 2, 3), c(2, 3, 4))
fem &lt;- rSPDE.fem2d(FV, P)
</code></pre>

<hr>
<h2 id='rSPDE.loglike'>Object-based log-likelihood function for latent Gaussian
fractional SPDE model</h2><span id='topic+rSPDE.loglike'></span>

<h3>Description</h3>

<p>This function evaluates the log-likelihood function for a
fractional SPDE model
<code class="reqn">L^\beta u(s) = W</code> that is observed under
Gaussian measurement noise:
<code class="reqn">Y_i = u(s_i) + \epsilon_i</code>,
where <code class="reqn">\epsilon_i</code>
are iid mean-zero Gaussian variables and <code class="reqn">x(s) =
\mu(s) + u(s)</code>, where
<code class="reqn">\mu(s)</code> is the expectation vector of the latent field.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rSPDE.loglike(obj, Y, A, sigma.e, mu = 0)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="rSPDE.loglike_+3A_obj">obj</code></td>
<td>
<p>The rational SPDE approximation, computed using
<code><a href="#topic+fractional.operators">fractional.operators()</a></code>,
<code><a href="#topic+matern.operators">matern.operators()</a></code>, or <code><a href="#topic+spde.matern.operators">spde.matern.operators()</a></code>.</p>
</td></tr>
<tr><td><code id="rSPDE.loglike_+3A_y">Y</code></td>
<td>
<p>The observations, either a vector or a matrix where
the columns correspond to independent replicates of observations.</p>
</td></tr>
<tr><td><code id="rSPDE.loglike_+3A_a">A</code></td>
<td>
<p>An observation matrix that links the measurement location
to the finite element basis.</p>
</td></tr>
<tr><td><code id="rSPDE.loglike_+3A_sigma.e">sigma.e</code></td>
<td>
<p>The standard deviation of the measurement noise.</p>
</td></tr>
<tr><td><code id="rSPDE.loglike_+3A_mu">mu</code></td>
<td>
<p>Expectation vector of the latent field (default = 0).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The log-likelihood value.
</p>


<h3>Note</h3>

<p>This example below shows how the function can be used to evaluate the likelihood of a latent Matern model.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+spde.matern.loglike">spde.matern.loglike()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Sample a Gaussian Matern process on R using a rational approximation
kappa &lt;- 10
sigma &lt;- 1
nu &lt;- 0.8
sigma.e &lt;- 0.3
range &lt;- 0.2

# create mass and stiffness matrices for a FEM discretization
x &lt;- seq(from = 0, to = 1, length.out = 101)
fem &lt;- rSPDE.fem1d(x)

# compute rational approximation
op &lt;- matern.operators(
  range = range, sigma = sigma, nu = nu,
  loc_mesh = x, d = 1,
  type = "operator", parameterization = "matern"
)

# Sample the model
u &lt;- simulate(op)

# Create some data
obs.loc &lt;- runif(n = 10, min = 0, max = 1)
A &lt;- rSPDE.A1d(x, obs.loc)
Y &lt;- as.vector(A %*% u + sigma.e * rnorm(10))

# compute log-likelihood of the data
lik1 &lt;- rSPDE.loglike(op, Y, A, sigma.e)
cat(lik1)
</code></pre>

<hr>
<h2 id='rspde.make.A'>Observation/prediction matrices for rSPDE models.</h2><span id='topic+rspde.make.A'></span>

<h3>Description</h3>

<p>Constructs observation/prediction weight matrices
for rSPDE models based on <code>inla.mesh</code> or
<code>inla.mesh.1d</code> objects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rspde.make.A(
  mesh = NULL,
  loc = NULL,
  A = NULL,
  dim = NULL,
  rspde.order = 1,
  nu = NULL,
  index = NULL,
  group = NULL,
  repl = 1L,
  n.group = NULL,
  n.repl = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="rspde.make.A_+3A_mesh">mesh</code></td>
<td>
<p>An <code>inla.mesh</code>,
an <code>inla.mesh.1d</code> object or a <code>metric_graph</code> object.</p>
</td></tr>
<tr><td><code id="rspde.make.A_+3A_loc">loc</code></td>
<td>
<p>Locations, needed if an INLA mesh is provided</p>
</td></tr>
<tr><td><code id="rspde.make.A_+3A_a">A</code></td>
<td>
<p>The A matrix from the standard SPDE approach, such as the matrix
returned by <code>inla.spde.make.A</code>. Should only be provided if
<code>mesh</code> is not provided.</p>
</td></tr>
<tr><td><code id="rspde.make.A_+3A_dim">dim</code></td>
<td>
<p>the dimension. Should only be provided if an
<code>mesh</code> is not provided.</p>
</td></tr>
<tr><td><code id="rspde.make.A_+3A_rspde.order">rspde.order</code></td>
<td>
<p>The order of the covariance-based rational SPDE approach.</p>
</td></tr>
<tr><td><code id="rspde.make.A_+3A_nu">nu</code></td>
<td>
<p>If <code>NULL</code>, then the model will assume that nu will
be estimated. If nu is fixed, you should provide the value of nu.</p>
</td></tr>
<tr><td><code id="rspde.make.A_+3A_index">index</code></td>
<td>
<p>For each observation/prediction value, an index into loc. Default is seq_len(nrow(A.loc)).</p>
</td></tr>
<tr><td><code id="rspde.make.A_+3A_group">group</code></td>
<td>
<p>For each observation/prediction value, an index into
the group model.</p>
</td></tr>
<tr><td><code id="rspde.make.A_+3A_repl">repl</code></td>
<td>
<p>For each observation/prediction value, the replicate index.</p>
</td></tr>
<tr><td><code id="rspde.make.A_+3A_n.group">n.group</code></td>
<td>
<p>The size of the group model.</p>
</td></tr>
<tr><td><code id="rspde.make.A_+3A_n.repl">n.repl</code></td>
<td>
<p>The total number of replicates.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The <code class="reqn">A</code> matrix for rSPDE models.
</p>


<h3>Examples</h3>

<pre><code class='language-R'> #tryCatch version
tryCatch({
if (requireNamespace("INLA", quietly = TRUE)) {
  library(INLA)

  set.seed(123)
  loc &lt;- matrix(runif(100 * 2) * 100, 100, 2)
  mesh &lt;- inla.mesh.2d(
    loc = loc,
    cutoff = 50,
    max.edge = c(50, 500)
  )
  A &lt;- rspde.make.A(mesh, loc = loc, rspde.order = 3)
}
#stable.tryCatch
}, error = function(e){print("Could not run the example")})

</code></pre>

<hr>
<h2 id='rspde.make.index'>rSPDE model index vector generation</h2><span id='topic+rspde.make.index'></span>

<h3>Description</h3>

<p>Generates a list of named index vectors for an rSPDE model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rspde.make.index(
  name,
  n.spde = NULL,
  n.group = 1,
  n.repl = 1,
  mesh = NULL,
  rspde.order = 1,
  nu = NULL,
  dim = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="rspde.make.index_+3A_name">name</code></td>
<td>
<p>A character string with the base name of the effect.</p>
</td></tr>
<tr><td><code id="rspde.make.index_+3A_n.spde">n.spde</code></td>
<td>
<p>The number of basis functions in the mesh model.</p>
</td></tr>
<tr><td><code id="rspde.make.index_+3A_n.group">n.group</code></td>
<td>
<p>The size of the group model.</p>
</td></tr>
<tr><td><code id="rspde.make.index_+3A_n.repl">n.repl</code></td>
<td>
<p>The total number of replicates.</p>
</td></tr>
<tr><td><code id="rspde.make.index_+3A_mesh">mesh</code></td>
<td>
<p>An <code>inla.mesh</code>,
an <code>inla.mesh.1d</code> object or a <code>metric_graph</code> object.</p>
</td></tr>
<tr><td><code id="rspde.make.index_+3A_rspde.order">rspde.order</code></td>
<td>
<p>The order of the rational approximation</p>
</td></tr>
<tr><td><code id="rspde.make.index_+3A_nu">nu</code></td>
<td>
<p>If <code>NULL</code>, then the model will assume that nu will
be estimated. If nu is fixed, you should provide the value of nu.</p>
</td></tr>
<tr><td><code id="rspde.make.index_+3A_dim">dim</code></td>
<td>
<p>the dimension of the domain. Should only be provided if
<code>mesh</code> is not provided.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of named index vectors.
</p>
<table role = "presentation">
<tr><td><code>name</code></td>
<td>
<p>Indices into the vector of latent variables</p>
</td></tr>
<tr><td><code>name.group</code></td>
<td>
<p>'group' indices</p>
</td></tr>
<tr><td><code>name.repl</code></td>
<td>
<p>Indices for replicates</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'> #tryCatch version
tryCatch({
if (requireNamespace("INLA", quietly = TRUE)) {
  library(INLA)

  set.seed(123)

  m &lt;- 100
  loc_2d_mesh &lt;- matrix(runif(m * 2), m, 2)
  mesh_2d &lt;- inla.mesh.2d(
    loc = loc_2d_mesh,
    cutoff = 0.05,
    max.edge = c(0.1, 0.5)
  )
  sigma &lt;- 1
  range &lt;- 0.2
  nu &lt;- 0.8
  kappa &lt;- sqrt(8 * nu) / range
  op &lt;- matern.operators(
    mesh = mesh_2d, nu = nu,
    range = range, sigma = sigma, m = 2,
    parameterization = "matern"
  )
  u &lt;- simulate(op)
  A &lt;- inla.spde.make.A(
    mesh = mesh_2d,
    loc = loc_2d_mesh
  )
  sigma.e &lt;- 0.1
  y &lt;- A %*% u + rnorm(m) * sigma.e
  Abar &lt;- rspde.make.A(mesh = mesh_2d, loc = loc_2d_mesh)
  mesh.index &lt;- rspde.make.index(name = "field", mesh = mesh_2d)
  st.dat &lt;- inla.stack(
    data = list(y = as.vector(y)),
    A = Abar,
    effects = mesh.index
  )
  rspde_model &lt;- rspde.matern(
    mesh = mesh_2d,
    nu.upper.bound = 2
  )
  f &lt;- y ~ -1 + f(field, model = rspde_model)
  rspde_fit &lt;- inla(f,
    data = inla.stack.data(st.dat),
    family = "gaussian",
    control.predictor =
      list(A = inla.stack.A(st.dat))
  )
  result &lt;- rspde.result(rspde_fit, "field", rspde_model)
  summary(result)
}
#stable.tryCatch
}, error = function(e){print("Could not run the example")})

</code></pre>

<hr>
<h2 id='rspde.matern'>Matern rSPDE model object for INLA</h2><span id='topic+rspde.matern'></span>

<h3>Description</h3>

<p>Creates an INLA object for a stationary Matern model with
general smoothness parameter.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rspde.matern(
  mesh,
  nu.upper.bound = NULL,
  rspde.order = 1,
  nu = NULL,
  B.sigma = matrix(c(0, 1, 0), 1, 3),
  B.range = matrix(c(0, 0, 1), 1, 3),
  parameterization = c("spde", "matern", "matern2"),
  B.tau = matrix(c(0, 1, 0), 1, 3),
  B.kappa = matrix(c(0, 0, 1), 1, 3),
  start.nu = NULL,
  start.theta = NULL,
  prior.nu = NULL,
  theta.prior.mean = NULL,
  theta.prior.prec = 0.1,
  prior.std.dev.nominal = 1,
  prior.range.nominal = NULL,
  prior.kappa.mean = NULL,
  prior.tau.mean = NULL,
  start.lstd.dev = NULL,
  start.lrange = NULL,
  start.ltau = NULL,
  start.lkappa = NULL,
  prior.theta.param = c("theta", "spde"),
  prior.nu.dist = c("beta", "lognormal"),
  nu.prec.inc = 1,
  type.rational.approx = c("chebfun", "brasil", "chebfunLB"),
  debug = FALSE,
  shared_lib = "detect",
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="rspde.matern_+3A_mesh">mesh</code></td>
<td>
<p>The mesh to build the model. It can be an <code>inla.mesh</code> or
an <code>inla.mesh.1d</code> object. Otherwise, should be a list containing elements d, the dimension, C, the mass matrix,
and G, the stiffness matrix.</p>
</td></tr>
<tr><td><code id="rspde.matern_+3A_nu.upper.bound">nu.upper.bound</code></td>
<td>
<p>Upper bound for the smoothness parameter. If <code>NULL</code>, it will be set to 2.</p>
</td></tr>
<tr><td><code id="rspde.matern_+3A_rspde.order">rspde.order</code></td>
<td>
<p>The order of the covariance-based rational SPDE approach. The default order is 1.</p>
</td></tr>
<tr><td><code id="rspde.matern_+3A_nu">nu</code></td>
<td>
<p>If nu is set to a parameter, nu will be kept fixed and will not
be estimated. If nu is <code>NULL</code>, it will be estimated.</p>
</td></tr>
<tr><td><code id="rspde.matern_+3A_b.sigma">B.sigma</code></td>
<td>
<p>Matrix with specification of log-linear model for <code class="reqn">\sigma</code> (for 'matern' parameterization) or for <code class="reqn">\sigma^2</code> (for 'matern2' parameterization). Will be used if <code>parameterization = 'matern'</code> or <code>parameterization = 'matern2'</code>.</p>
</td></tr>
<tr><td><code id="rspde.matern_+3A_b.range">B.range</code></td>
<td>
<p>Matrix with specification of log-linear model for <code class="reqn">\rho</code>, which is a range-like parameter (it is exactly the range parameter in the stationary case). Will be used if <code>parameterization = 'matern'</code> or <code>parameterization = 'matern2'</code>.</p>
</td></tr>
<tr><td><code id="rspde.matern_+3A_parameterization">parameterization</code></td>
<td>
<p>Which parameterization to use? <code>matern</code> uses range, std. deviation and nu (smoothness). <code>spde</code> uses kappa, tau and nu (smoothness). <code>matern2</code> uses range-like (1/kappa), variance and nu (smoothness). The default is <code>spde</code>.</p>
</td></tr>
<tr><td><code id="rspde.matern_+3A_b.tau">B.tau</code></td>
<td>
<p>Matrix with specification of log-linear model for <code class="reqn">\tau</code>. Will be used if <code>parameterization = 'spde'</code>.</p>
</td></tr>
<tr><td><code id="rspde.matern_+3A_b.kappa">B.kappa</code></td>
<td>
<p>Matrix with specification of log-linear model for <code class="reqn">\kappa</code>. Will be used if <code>parameterization = 'spde'</code>.</p>
</td></tr>
<tr><td><code id="rspde.matern_+3A_start.nu">start.nu</code></td>
<td>
<p>Starting value for nu.</p>
</td></tr>
<tr><td><code id="rspde.matern_+3A_start.theta">start.theta</code></td>
<td>
<p>Starting values for the model parameters. In the stationary case, if <code>parameterization='matern'</code>, then <code>theta[1]</code> is the std.dev and <code>theta[2]</code> is the range parameter.
If <code>parameterization = 'spde'</code>, then <code>theta[1]</code> is <code>tau</code> and <code>theta[2]</code> is <code>kappa</code>.</p>
</td></tr>
<tr><td><code id="rspde.matern_+3A_prior.nu">prior.nu</code></td>
<td>
<p>a list containing the elements <code>mean</code> and <code>prec</code>
for beta distribution, or <code>loglocation</code> and <code>logscale</code> for a
truncated lognormal distribution. <code>loglocation</code> stands for
the location parameter of the truncated lognormal distribution in the log
scale. <code>prec</code> stands for the precision of a beta distribution.
<code>logscale</code> stands for the scale of the truncated lognormal
distribution on the log scale. Check details below.</p>
</td></tr>
<tr><td><code id="rspde.matern_+3A_theta.prior.mean">theta.prior.mean</code></td>
<td>
<p>A vector for the mean priors of <code>theta</code>.</p>
</td></tr>
<tr><td><code id="rspde.matern_+3A_theta.prior.prec">theta.prior.prec</code></td>
<td>
<p>A precision matrix for the prior of <code>theta</code>.</p>
</td></tr>
<tr><td><code id="rspde.matern_+3A_prior.std.dev.nominal">prior.std.dev.nominal</code></td>
<td>
<p>Prior std. deviation to be used for the priors and for the starting values.</p>
</td></tr>
<tr><td><code id="rspde.matern_+3A_prior.range.nominal">prior.range.nominal</code></td>
<td>
<p>Prior range to be used for the priors and for the starting values.</p>
</td></tr>
<tr><td><code id="rspde.matern_+3A_prior.kappa.mean">prior.kappa.mean</code></td>
<td>
<p>Prior kappa to be used for the priors and for the starting values.</p>
</td></tr>
<tr><td><code id="rspde.matern_+3A_prior.tau.mean">prior.tau.mean</code></td>
<td>
<p>Prior tau to be used for the priors and for the starting values.</p>
</td></tr>
<tr><td><code id="rspde.matern_+3A_start.lstd.dev">start.lstd.dev</code></td>
<td>
<p>Starting value for log of std. deviation. Will not be used if start.ltau is non-null. Will be only used in the stationary case and if <code>parameterization = 'matern'</code>.</p>
</td></tr>
<tr><td><code id="rspde.matern_+3A_start.lrange">start.lrange</code></td>
<td>
<p>Starting value for log of range. Will not be used if start.lkappa is non-null. Will be only used in the stationary case and if <code>parameterization = 'matern'</code>.</p>
</td></tr>
<tr><td><code id="rspde.matern_+3A_start.ltau">start.ltau</code></td>
<td>
<p>Starting value for log of tau. Will be only used in the stationary case and if <code>parameterization = 'spde'</code>.</p>
</td></tr>
<tr><td><code id="rspde.matern_+3A_start.lkappa">start.lkappa</code></td>
<td>
<p>Starting value for log of kappa. Will be only used in the stationary case and if <code>parameterization = 'spde'</code>.</p>
</td></tr>
<tr><td><code id="rspde.matern_+3A_prior.theta.param">prior.theta.param</code></td>
<td>
<p>Should the lognormal prior be on <code>theta</code> or on the SPDE parameters (<code>tau</code> and <code>kappa</code> on the stationary case)?</p>
</td></tr>
<tr><td><code id="rspde.matern_+3A_prior.nu.dist">prior.nu.dist</code></td>
<td>
<p>The distribution of the smoothness parameter.
The current options are &quot;beta&quot; or &quot;lognormal&quot;. The default is &quot;lognormal&quot;.</p>
</td></tr>
<tr><td><code id="rspde.matern_+3A_nu.prec.inc">nu.prec.inc</code></td>
<td>
<p>Amount to increase the precision in the beta prior
distribution. Check details below.</p>
</td></tr>
<tr><td><code id="rspde.matern_+3A_type.rational.approx">type.rational.approx</code></td>
<td>
<p>Which type of rational approximation
should be used? The current types are &quot;chebfun&quot;, &quot;brasil&quot; or &quot;chebfunLB&quot;.</p>
</td></tr>
<tr><td><code id="rspde.matern_+3A_debug">debug</code></td>
<td>
<p>INLA debug argument</p>
</td></tr>
<tr><td><code id="rspde.matern_+3A_shared_lib">shared_lib</code></td>
<td>
<p>Which shared lib to use for the cgeneric implementation?
If &quot;detect&quot;, it will check if the shared lib exists locally, in which case it will
use it. Otherwise it will use INLA's shared library.
If &quot;INLA&quot;, it will use the shared lib from INLA's installation. If 'rSPDE', then
it will use the local installation (does not work if your installation is from CRAN).
Otherwise, you can directly supply the path of the .so (or .dll) file.</p>
</td></tr>
<tr><td><code id="rspde.matern_+3A_...">...</code></td>
<td>
<p>Only being used internally.</p>
</td></tr>
<tr><td><code id="rspde.matern_+3A_prior.kappa">prior.kappa</code></td>
<td>
<p>a <code>list</code> containing the elements <code>meanlog</code> and
<code>sdlog</code>, that is, the mean and standard deviation on the log scale.</p>
</td></tr>
<tr><td><code id="rspde.matern_+3A_prior.tau">prior.tau</code></td>
<td>
<p>a list containing the elements <code>meanlog</code> and
<code>sdlog</code>, that is, the mean and standard deviation on the log scale.</p>
</td></tr>
<tr><td><code id="rspde.matern_+3A_prior.range">prior.range</code></td>
<td>
<p>a <code>list</code> containing the elements <code>meanlog</code> and
<code>sdlog</code>, that is, the mean and standard deviation on the log scale. Will not be used if prior.kappa is non-null.</p>
</td></tr>
<tr><td><code id="rspde.matern_+3A_prior.std.dev">prior.std.dev</code></td>
<td>
<p>a <code>list</code> containing the elements <code>meanlog</code> and
<code>sdlog</code>, that is, the mean and standard deviation on the log scale. Will not be used if prior.tau is non-null.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An INLA model.
</p>

<hr>
<h2 id='rspde.matern.intrinsic'>Intrinsic Matern rSPDE model object for INLA</h2><span id='topic+rspde.matern.intrinsic'></span><span id='topic+rspde.intrinsic.matern'></span>

<h3>Description</h3>

<p>Creates an INLA object for a stationary intrinsic Matern model.
Currently, alpha is fixed to 2 and beta is fixed to 1.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rspde.intrinsic.matern(
  mesh,
  alpha = 2,
  mean.correction = FALSE,
  prior.lkappa.mean = NULL,
  prior.ltau.mean = 1,
  prior.lkappa.prec = 0.1,
  prior.ltau.prec = 0.1,
  start.ltau = NULL,
  start.lkappa = NULL,
  true.scaling = TRUE,
  diagonal = 0,
  debug = FALSE,
  shared_lib = "detect",
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="rspde.matern.intrinsic_+3A_mesh">mesh</code></td>
<td>
<p>The mesh to build the model. It can be an <code>inla.mesh</code> or
an <code>inla.mesh.1d</code> object. Otherwise, should be a list containing elements d, the dimension, C, the mass matrix,
and G, the stiffness matrix.</p>
</td></tr>
<tr><td><code id="rspde.matern.intrinsic_+3A_alpha">alpha</code></td>
<td>
<p>Smoothness parameter, need to be 1 or 2.</p>
</td></tr>
<tr><td><code id="rspde.matern.intrinsic_+3A_mean.correction">mean.correction</code></td>
<td>
<p>Add mean correction for extreme value models?</p>
</td></tr>
<tr><td><code id="rspde.matern.intrinsic_+3A_prior.lkappa.mean">prior.lkappa.mean</code></td>
<td>
<p>Prior on log kappa to be used for the priors and for the starting values.</p>
</td></tr>
<tr><td><code id="rspde.matern.intrinsic_+3A_prior.ltau.mean">prior.ltau.mean</code></td>
<td>
<p>Prior on log tau to be used for the priors and for the starting values.</p>
</td></tr>
<tr><td><code id="rspde.matern.intrinsic_+3A_prior.lkappa.prec">prior.lkappa.prec</code></td>
<td>
<p>Precision to be used on the prior on log kappa to be used for the priors and for the starting values.</p>
</td></tr>
<tr><td><code id="rspde.matern.intrinsic_+3A_prior.ltau.prec">prior.ltau.prec</code></td>
<td>
<p>Precision to be used on the prior on log tau to be used for the priors and for the starting values.</p>
</td></tr>
<tr><td><code id="rspde.matern.intrinsic_+3A_start.ltau">start.ltau</code></td>
<td>
<p>Starting value for log of tau.</p>
</td></tr>
<tr><td><code id="rspde.matern.intrinsic_+3A_start.lkappa">start.lkappa</code></td>
<td>
<p>Starting value for log of kappa.</p>
</td></tr>
<tr><td><code id="rspde.matern.intrinsic_+3A_true.scaling">true.scaling</code></td>
<td>
<p>Compute the true normalizing constant manually? Default <code>TRUE</code>.
The alternative is to set this to <code>FALSE</code> and set the <code>diagonal</code> argument to some small
positive value. In the latter case, the model is approximated by a non-intrinsic model
with a precision matrix that has the <code>diagonal</code> value added to the diagonal.</p>
</td></tr>
<tr><td><code id="rspde.matern.intrinsic_+3A_diagonal">diagonal</code></td>
<td>
<p>Value of diagonal correction for INLA stability. Default 0.</p>
</td></tr>
<tr><td><code id="rspde.matern.intrinsic_+3A_debug">debug</code></td>
<td>
<p>INLA debug argument</p>
</td></tr>
<tr><td><code id="rspde.matern.intrinsic_+3A_shared_lib">shared_lib</code></td>
<td>
<p>Which shared lib to use for the cgeneric implementation?
If &quot;detect&quot;, it will check if the shared lib exists locally, in which case it will
use it. Otherwise it will use INLA's shared library.
If &quot;INLA&quot;, it will use the shared lib from INLA's installation. If 'rSPDE', then
it will use the local installation (does not work if your installation is from CRAN).
Otherwise, you can directly supply the path of the .so (or .dll) file.</p>
</td></tr>
<tr><td><code id="rspde.matern.intrinsic_+3A_...">...</code></td>
<td>
<p>Only being used internally.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An INLA model.
</p>

<hr>
<h2 id='rSPDE.matern.loglike'>Object-based log-likelihood function for latent Gaussian fractional
SPDE model using the rational approximations</h2><span id='topic+rSPDE.matern.loglike'></span>

<h3>Description</h3>

<p>This function evaluates the log-likelihood function for a
Gaussian process with a Matern covariance
function, that is observed under Gaussian measurement noise:
<code class="reqn">Y_i = u(s_i) + \epsilon_i</code>, where
<code class="reqn">\epsilon_i</code> are
iid mean-zero Gaussian variables. The latent model is approximated using
the a rational approximation
of the fractional SPDE model corresponding to the Gaussian process.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rSPDE.matern.loglike(
  object,
  Y,
  A,
  sigma.e,
  mu = 0,
  nu = NULL,
  kappa = NULL,
  sigma = NULL,
  range = NULL,
  tau = NULL,
  m = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="rSPDE.matern.loglike_+3A_object">object</code></td>
<td>
<p>The rational SPDE approximation,
computed using <code><a href="#topic+matern.operators">matern.operators()</a></code></p>
</td></tr>
<tr><td><code id="rSPDE.matern.loglike_+3A_y">Y</code></td>
<td>
<p>The observations, either a vector or a matrix where
the columns correspond to independent replicates of observations.</p>
</td></tr>
<tr><td><code id="rSPDE.matern.loglike_+3A_a">A</code></td>
<td>
<p>An observation matrix that links the measurement location to the
finite element basis.</p>
</td></tr>
<tr><td><code id="rSPDE.matern.loglike_+3A_sigma.e">sigma.e</code></td>
<td>
<p>The standard deviation of the measurement noise.</p>
</td></tr>
<tr><td><code id="rSPDE.matern.loglike_+3A_mu">mu</code></td>
<td>
<p>Expectation vector of the latent field (default = 0).</p>
</td></tr>
<tr><td><code id="rSPDE.matern.loglike_+3A_nu">nu</code></td>
<td>
<p>If non-null, update the shape parameter of the covariance
function.</p>
</td></tr>
<tr><td><code id="rSPDE.matern.loglike_+3A_kappa">kappa</code></td>
<td>
<p>If non-null, update the range parameter of the covariance
function.</p>
</td></tr>
<tr><td><code id="rSPDE.matern.loglike_+3A_sigma">sigma</code></td>
<td>
<p>If non-null, update the standard deviation of
the covariance function.</p>
</td></tr>
<tr><td><code id="rSPDE.matern.loglike_+3A_range">range</code></td>
<td>
<p>If non-null, update the range parameter
of the covariance function.</p>
</td></tr>
<tr><td><code id="rSPDE.matern.loglike_+3A_tau">tau</code></td>
<td>
<p>If non-null, update the parameter tau.</p>
</td></tr>
<tr><td><code id="rSPDE.matern.loglike_+3A_m">m</code></td>
<td>
<p>If non-null, update the order of the rational approximation,
which needs to be a positive integer.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The log-likelihood value.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+matern.operators">matern.operators()</a></code>, <code><a href="#topic+predict.CBrSPDEobj">predict.CBrSPDEobj()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># this example illustrates how the function can be used for maximum likelihood estimation

set.seed(123)
# Sample a Gaussian Matern process on R using a rational approximation
nu &lt;- 0.8
kappa &lt;- 5
sigma &lt;- 1
sigma.e &lt;- 0.1
n.rep &lt;- 10
n.obs &lt;- 100
n.x &lt;- 51
range &lt;- 0.2

# create mass and stiffness matrices for a FEM discretization
x &lt;- seq(from = 0, to = 1, length.out = n.x)
fem &lt;- rSPDE.fem1d(x)

tau &lt;- sqrt(gamma(nu) / (sigma^2 * kappa^(2 * nu) *
  (4 * pi)^(1 / 2) * gamma(nu + 1 / 2)))

# Compute the covariance-based rational approximation
op_cov &lt;- matern.operators(
  loc_mesh = x, nu = nu,
  range = range, sigma = sigma, d = 1, m = 2,
  parameterization = "matern"
)

# Sample the model
u &lt;- simulate(op_cov, n.rep)

# Create some data
obs.loc &lt;- runif(n = n.obs, min = 0, max = 1)
A &lt;- rSPDE.A1d(x, obs.loc)
noise &lt;- rnorm(n.obs * n.rep)
dim(noise) &lt;- c(n.obs, n.rep)
Y &lt;- as.matrix(A %*% u + sigma.e * noise)

# Define the negative likelihood function for optimization
# using CBrSPDE.matern.loglike

# Notice that we are also using sigma instead of tau, so it can be compared
# to matern.loglike()
mlik_cov &lt;- function(theta, Y, A, op_cov) {
  kappa &lt;- exp(theta[1])
  sigma &lt;- exp(theta[2])
  nu &lt;- exp(theta[3])
  return(-rSPDE.matern.loglike(
    object = op_cov, Y = Y,
    A = A, kappa = kappa, sigma = sigma,
    nu = nu, sigma.e = exp(theta[4])
  ))
}

# The parameters can now be estimated by minimizing mlik with optim

# Choose some reasonable starting values depending on the size of the domain
theta0 &lt;- log(c(sqrt(8), 1 / sqrt(var(c(Y))), 0.9, 0.01))

# run estimation and display the results
theta &lt;- optim(theta0, mlik_cov,
  Y = Y, A = A, op_cov = op_cov,
  method = "L-BFGS-B"
)

print(data.frame(
  range = c(range, exp(theta$par[1])), sigma = c(sigma, exp(theta$par[2])),
  nu = c(nu, exp(theta$par[3])), sigma.e = c(sigma.e, exp(theta$par[4])),
  row.names = c("Truth", "Estimates")
))


</code></pre>

<hr>
<h2 id='rspde.matern.precision'>Precision matrix of the covariance-based rational approximation of
stationary Gaussian Matern random fields</h2><span id='topic+rspde.matern.precision'></span>

<h3>Description</h3>

<p><code>rspde.matern.precision</code> is used for computing the
precision matrix of the
covariance-based rational SPDE approximation of a stationary Gaussian random
fields on <code class="reqn">R^d</code> with a Matern covariance function
</p>
<p style="text-align: center;"><code class="reqn">C(h) = \frac{\sigma^2}{2^(\nu-1)\Gamma(\nu)}(\kappa h)^\nu
K_\nu(\kappa h)</code>
</p>



<h3>Usage</h3>

<pre><code class='language-R'>rspde.matern.precision(
  kappa,
  nu,
  tau = NULL,
  sigma = NULL,
  rspde.order,
  dim,
  fem_mesh_matrices,
  only_fractional = FALSE,
  return_block_list = FALSE,
  type_rational_approx = "chebfun"
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="rspde.matern.precision_+3A_kappa">kappa</code></td>
<td>
<p>Range parameter of the covariance function.</p>
</td></tr>
<tr><td><code id="rspde.matern.precision_+3A_nu">nu</code></td>
<td>
<p>Shape parameter of the covariance function.</p>
</td></tr>
<tr><td><code id="rspde.matern.precision_+3A_tau">tau</code></td>
<td>
<p>Scale parameter of the covariance function. If sigma is
not provided, tau should be provided.</p>
</td></tr>
<tr><td><code id="rspde.matern.precision_+3A_sigma">sigma</code></td>
<td>
<p>Standard deviation of the covariance function. If tau is
not provided, sigma should be provided.</p>
</td></tr>
<tr><td><code id="rspde.matern.precision_+3A_rspde.order">rspde.order</code></td>
<td>
<p>The order of the rational approximation</p>
</td></tr>
<tr><td><code id="rspde.matern.precision_+3A_dim">dim</code></td>
<td>
<p>The dimension of the domain</p>
</td></tr>
<tr><td><code id="rspde.matern.precision_+3A_fem_mesh_matrices">fem_mesh_matrices</code></td>
<td>
<p>A list containing the FEM-related matrices. The
list should contain elements c0, g1, g2, g3, etc.</p>
</td></tr>
<tr><td><code id="rspde.matern.precision_+3A_only_fractional">only_fractional</code></td>
<td>
<p>Logical. Should only the fractional-order part of
the precision matrix be returned?</p>
</td></tr>
<tr><td><code id="rspde.matern.precision_+3A_return_block_list">return_block_list</code></td>
<td>
<p>Logical. For <code>type = "covariance"</code>, should the
block parts of the precision matrix be returned separately as a list?</p>
</td></tr>
<tr><td><code id="rspde.matern.precision_+3A_type_rational_approx">type_rational_approx</code></td>
<td>
<p>Which type of rational approximation should be
used? The current types are &quot;chebfun&quot;, &quot;brasil&quot; or &quot;chebfunLB&quot;.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The precision matrix
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(123)
nobs &lt;- 101
x &lt;- seq(from = 0, to = 1, length.out = nobs)
fem &lt;- rSPDE.fem1d(x)
kappa &lt;- 40
sigma &lt;- 1
d &lt;- 1
nu &lt;- 2.6
tau &lt;- sqrt(gamma(nu) / (kappa^(2 * nu) * (4 * pi)^(d / 2) *
  gamma(nu + d / 2)))
range &lt;- sqrt(8 * nu) / kappa
op_cov &lt;- matern.operators(
  loc_mesh = x, nu = nu, range = range, sigma = sigma,
  d = 1, m = 2, compute_higher_order = TRUE,
  parameterization = "matern"
)
v &lt;- t(rSPDE.A1d(x, 0.5))
c.true &lt;- matern.covariance(abs(x - 0.5), kappa, nu, sigma)
Q &lt;- rspde.matern.precision(
  kappa = kappa, nu = nu, tau = tau, rspde.order = 2, d = 1,
  fem_mesh_matrices = op_cov$fem_mesh_matrices
)
A &lt;- Diagonal(nobs)
Abar &lt;- cbind(A, A, A)
w &lt;- rbind(v, v, v)
c.approx_cov &lt;- (Abar) %*% solve(Q, w)

# plot the result and compare with the true Matern covariance
plot(x, matern.covariance(abs(x - 0.5), kappa, nu, sigma),
  type = "l", ylab = "C(h)",
  xlab = "h", main = "Matern covariance and rational approximations"
)
lines(x, c.approx_cov, col = 2)
</code></pre>

<hr>
<h2 id='rspde.matern.precision.integer'>Precision matrix of stationary Gaussian Matern
random fields with integer covariance exponent</h2><span id='topic+rspde.matern.precision.integer'></span>

<h3>Description</h3>

<p><code>rspde.matern.precision.integer.opt</code> is
used for computing the precision matrix of stationary
Gaussian random fields on <code class="reqn">R^d</code> with a Matern
covariance function
</p>
<p style="text-align: center;"><code class="reqn">C(h) = \frac{\sigma^2}{2^(\nu-1)\Gamma(\nu)}
(\kappa h)^\nu K_\nu(\kappa h)</code>
</p>
<p>,
where <code class="reqn">\alpha = \nu + d/2</code> is a natural number.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rspde.matern.precision.integer(
  kappa,
  nu,
  tau = NULL,
  sigma = NULL,
  dim,
  fem_mesh_matrices
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="rspde.matern.precision.integer_+3A_kappa">kappa</code></td>
<td>
<p>Range parameter of the covariance function.</p>
</td></tr>
<tr><td><code id="rspde.matern.precision.integer_+3A_nu">nu</code></td>
<td>
<p>Shape parameter of the covariance function.</p>
</td></tr>
<tr><td><code id="rspde.matern.precision.integer_+3A_tau">tau</code></td>
<td>
<p>Scale parameter of the covariance function.</p>
</td></tr>
<tr><td><code id="rspde.matern.precision.integer_+3A_sigma">sigma</code></td>
<td>
<p>Standard deviation of the covariance function.
If tau is not provided, sigma should be provided.</p>
</td></tr>
<tr><td><code id="rspde.matern.precision.integer_+3A_dim">dim</code></td>
<td>
<p>The dimension of the domain</p>
</td></tr>
<tr><td><code id="rspde.matern.precision.integer_+3A_fem_mesh_matrices">fem_mesh_matrices</code></td>
<td>
<p>A list containing the FEM-related
matrices. The list should contain elements c0, g1, g2, g3, etc.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The precision matrix
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(123)
nobs &lt;- 101
x &lt;- seq(from = 0, to = 1, length.out = nobs)
fem &lt;- rSPDE.fem1d(x)
kappa &lt;- 40
sigma &lt;- 1
d &lt;- 1
nu &lt;- 0.5
tau &lt;- sqrt(gamma(nu) / (kappa^(2 * nu) *
  (4 * pi)^(d / 2) * gamma(nu + d / 2)))
range &lt;- sqrt(8 * nu) / kappa
op_cov &lt;- matern.operators(
  loc_mesh = x, nu = nu, range = range, sigma = sigma,
  d = 1, m = 2, parameterization = "matern"
)
v &lt;- t(rSPDE.A1d(x, 0.5))
c.true &lt;- matern.covariance(abs(x - 0.5), kappa, nu, sigma)
Q &lt;- rspde.matern.precision.integer(
  kappa = kappa, nu = nu, tau = tau, d = 1,
  fem_mesh_matrices = op_cov$fem_mesh_matrices
)
A &lt;- Diagonal(nobs)
c.approx_cov &lt;- A %*% solve(Q, v)

# plot the result and compare with the true Matern covariance
plot(x, matern.covariance(abs(x - 0.5), kappa, nu, sigma),
  type = "l", ylab = "C(h)",
  xlab = "h", main = "Matern covariance and rational approximations"
)
lines(x, c.approx_cov, col = 2)
</code></pre>

<hr>
<h2 id='rspde.matern.precision.integer.opt'>Optimized precision matrix of stationary Gaussian Matern
random fields with integer covariance exponent</h2><span id='topic+rspde.matern.precision.integer.opt'></span>

<h3>Description</h3>

<p><code>rspde.matern.precision.integer.opt</code> is used
for computing the optimized version of the precision matrix of
stationary Gaussian random fields on <code class="reqn">R^d</code> with a Matern
covariance function
</p>
<p style="text-align: center;"><code class="reqn">C(h) = \frac{\sigma^2}{2^{\nu-1}\Gamma(\nu)}(\kappa h)^\nu
K_\nu(\kappa h),</code>
</p>

<p>where <code class="reqn">\alpha = \nu + d/2</code> is a natural number.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rspde.matern.precision.integer.opt(
  kappa,
  nu,
  tau,
  d,
  fem_matrices,
  graph = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="rspde.matern.precision.integer.opt_+3A_kappa">kappa</code></td>
<td>
<p>Range parameter of the covariance function.</p>
</td></tr>
<tr><td><code id="rspde.matern.precision.integer.opt_+3A_nu">nu</code></td>
<td>
<p>Shape parameter of the covariance function.</p>
</td></tr>
<tr><td><code id="rspde.matern.precision.integer.opt_+3A_tau">tau</code></td>
<td>
<p>Scale parameter of the covariance function.</p>
</td></tr>
<tr><td><code id="rspde.matern.precision.integer.opt_+3A_d">d</code></td>
<td>
<p>The dimension of the domain</p>
</td></tr>
<tr><td><code id="rspde.matern.precision.integer.opt_+3A_fem_matrices">fem_matrices</code></td>
<td>
<p>A list containing the FEM-related matrices.
The list should contain elements C, G, G_2, G_3, etc.</p>
</td></tr>
<tr><td><code id="rspde.matern.precision.integer.opt_+3A_graph">graph</code></td>
<td>
<p>The sparsity graph of the matrices. If NULL, only a vector
of the elements will be returned, if non-NULL, a sparse matrix will
be returned.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The precision matrix
</p>

<hr>
<h2 id='rspde.matern.precision.opt'>Optimized precision matrix of the covariance-based rational
approximation</h2><span id='topic+rspde.matern.precision.opt'></span>

<h3>Description</h3>

<p><code>rspde.matern.precision</code> is used for computing the
optimized version of the precision matrix of the
covariance-based rational SPDE approximation of a stationary Gaussian random
fields on <code class="reqn">R^d</code> with a Matern covariance function
</p>
<p style="text-align: center;"><code class="reqn">C(h) = \frac{\sigma^2}{2^{\nu-1}\Gamma(\nu)}(\kappa h)^\nu
K_\nu(\kappa h).</code>
</p>



<h3>Usage</h3>

<pre><code class='language-R'>rspde.matern.precision.opt(
  kappa,
  nu,
  tau,
  rspde.order,
  dim,
  fem_matrices,
  graph = NULL,
  sharp,
  type_rational_approx
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="rspde.matern.precision.opt_+3A_kappa">kappa</code></td>
<td>
<p>Range parameter of the covariance function.</p>
</td></tr>
<tr><td><code id="rspde.matern.precision.opt_+3A_nu">nu</code></td>
<td>
<p>Shape parameter of the covariance function.</p>
</td></tr>
<tr><td><code id="rspde.matern.precision.opt_+3A_tau">tau</code></td>
<td>
<p>Scale parameter of the covariance function.</p>
</td></tr>
<tr><td><code id="rspde.matern.precision.opt_+3A_rspde.order">rspde.order</code></td>
<td>
<p>The order of the rational approximation</p>
</td></tr>
<tr><td><code id="rspde.matern.precision.opt_+3A_dim">dim</code></td>
<td>
<p>The dimension of the domain</p>
</td></tr>
<tr><td><code id="rspde.matern.precision.opt_+3A_fem_matrices">fem_matrices</code></td>
<td>
<p>A list containing the FEM-related matrices.
The list should contain elements C, G, G_2, G_3, etc.</p>
</td></tr>
<tr><td><code id="rspde.matern.precision.opt_+3A_graph">graph</code></td>
<td>
<p>The sparsity graph of the matrices. If NULL, only a vector
of the elements will be returned, if non-NULL, a sparse matrix will
be returned.</p>
</td></tr>
<tr><td><code id="rspde.matern.precision.opt_+3A_sharp">sharp</code></td>
<td>
<p>The sparsity graph should have the correct sparsity (costs
more to perform a sparsity analysis) or an upper bound for the sparsity?</p>
</td></tr>
<tr><td><code id="rspde.matern.precision.opt_+3A_type_rational_approx">type_rational_approx</code></td>
<td>
<p>Which type of rational approximation
should be used? The current types are &quot;chebfun&quot;, &quot;brasil&quot; or &quot;chebfunLB&quot;.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The precision matrix
</p>

<hr>
<h2 id='rspde.matern1d'>Matern rSPDE model object for INLA</h2><span id='topic+rspde.matern1d'></span>

<h3>Description</h3>

<p>Creates an INLA object for a stationary Matern model with
general smoothness parameter.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rspde.matern1d(
  loc,
  nu.upper.bound = NULL,
  rspde.order = 1,
  nu = NULL,
  parameterization = c("spde", "matern", "matern2"),
  start.nu = NULL,
  start.theta = NULL,
  prior.nu = NULL,
  theta.prior.mean = NULL,
  theta.prior.prec = 0.1,
  prior.std.dev.nominal = 1,
  prior.range.nominal = NULL,
  prior.kappa.mean = NULL,
  prior.tau.mean = NULL,
  start.lstd.dev = NULL,
  start.lrange = NULL,
  start.ltau = NULL,
  start.lkappa = NULL,
  prior.theta.param = c("theta", "spde"),
  prior.nu.dist = c("beta", "lognormal"),
  nu.prec.inc = 1,
  type.rational.approx = c("chebfun", "brasil", "chebfunLB"),
  debug = FALSE,
  shared_lib = "detect",
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="rspde.matern1d_+3A_loc">loc</code></td>
<td>
<p>A vector of spatial locations.</p>
</td></tr>
<tr><td><code id="rspde.matern1d_+3A_nu.upper.bound">nu.upper.bound</code></td>
<td>
<p>Upper bound for the smoothness parameter. If <code>NULL</code>, it will be set to 2.</p>
</td></tr>
<tr><td><code id="rspde.matern1d_+3A_rspde.order">rspde.order</code></td>
<td>
<p>The order of the covariance-based rational SPDE approach. The default order is 1.</p>
</td></tr>
<tr><td><code id="rspde.matern1d_+3A_nu">nu</code></td>
<td>
<p>If nu is set to a parameter, nu will be kept fixed and will not
be estimated. If nu is <code>NULL</code>, it will be estimated.</p>
</td></tr>
<tr><td><code id="rspde.matern1d_+3A_parameterization">parameterization</code></td>
<td>
<p>Which parameterization to use? <code>matern</code> uses range, std. deviation and nu (smoothness). <code>spde</code> uses kappa, tau and nu (smoothness). <code>matern2</code> uses range-like (1/kappa), variance and nu (smoothness). The default is <code>spde</code>.</p>
</td></tr>
<tr><td><code id="rspde.matern1d_+3A_start.nu">start.nu</code></td>
<td>
<p>Starting value for nu.</p>
</td></tr>
<tr><td><code id="rspde.matern1d_+3A_start.theta">start.theta</code></td>
<td>
<p>Starting values for the model parameters. In the stationary case, if <code>parameterization='matern'</code>, then <code>theta[1]</code> is the std.dev and <code>theta[2]</code> is the range parameter.
If <code>parameterization = 'spde'</code>, then <code>theta[1]</code> is <code>tau</code> and <code>theta[2]</code> is <code>kappa</code>.</p>
</td></tr>
<tr><td><code id="rspde.matern1d_+3A_prior.nu">prior.nu</code></td>
<td>
<p>a list containing the elements <code>mean</code> and <code>prec</code>
for beta distribution, or <code>loglocation</code> and <code>logscale</code> for a
truncated lognormal distribution. <code>loglocation</code> stands for
the location parameter of the truncated lognormal distribution in the log
scale. <code>prec</code> stands for the precision of a beta distribution.
<code>logscale</code> stands for the scale of the truncated lognormal
distribution on the log scale. Check details below.</p>
</td></tr>
<tr><td><code id="rspde.matern1d_+3A_theta.prior.mean">theta.prior.mean</code></td>
<td>
<p>A vector for the mean priors of <code>theta</code>.</p>
</td></tr>
<tr><td><code id="rspde.matern1d_+3A_theta.prior.prec">theta.prior.prec</code></td>
<td>
<p>A precision matrix for the prior of <code>theta</code>.</p>
</td></tr>
<tr><td><code id="rspde.matern1d_+3A_prior.std.dev.nominal">prior.std.dev.nominal</code></td>
<td>
<p>Prior std. deviation to be used for the priors and for the starting values.</p>
</td></tr>
<tr><td><code id="rspde.matern1d_+3A_prior.range.nominal">prior.range.nominal</code></td>
<td>
<p>Prior range to be used for the priors and for the starting values.</p>
</td></tr>
<tr><td><code id="rspde.matern1d_+3A_prior.kappa.mean">prior.kappa.mean</code></td>
<td>
<p>Prior kappa to be used for the priors and for the starting values.</p>
</td></tr>
<tr><td><code id="rspde.matern1d_+3A_prior.tau.mean">prior.tau.mean</code></td>
<td>
<p>Prior tau to be used for the priors and for the starting values.</p>
</td></tr>
<tr><td><code id="rspde.matern1d_+3A_start.lstd.dev">start.lstd.dev</code></td>
<td>
<p>Starting value for log of std. deviation. Will not be used if start.ltau is non-null. Will be only used in the stationary case and if <code>parameterization = 'matern'</code>.</p>
</td></tr>
<tr><td><code id="rspde.matern1d_+3A_start.lrange">start.lrange</code></td>
<td>
<p>Starting value for log of range. Will not be used if start.lkappa is non-null. Will be only used in the stationary case and if <code>parameterization = 'matern'</code>.</p>
</td></tr>
<tr><td><code id="rspde.matern1d_+3A_start.ltau">start.ltau</code></td>
<td>
<p>Starting value for log of tau. Will be only used in the stationary case and if <code>parameterization = 'spde'</code>.</p>
</td></tr>
<tr><td><code id="rspde.matern1d_+3A_start.lkappa">start.lkappa</code></td>
<td>
<p>Starting value for log of kappa. Will be only used in the stationary case and if <code>parameterization = 'spde'</code>.</p>
</td></tr>
<tr><td><code id="rspde.matern1d_+3A_prior.theta.param">prior.theta.param</code></td>
<td>
<p>Should the lognormal prior be on <code>theta</code> or on the SPDE parameters (<code>tau</code> and <code>kappa</code> on the stationary case)?</p>
</td></tr>
<tr><td><code id="rspde.matern1d_+3A_prior.nu.dist">prior.nu.dist</code></td>
<td>
<p>The distribution of the smoothness parameter.
The current options are &quot;beta&quot; or &quot;lognormal&quot;. The default is &quot;lognormal&quot;.</p>
</td></tr>
<tr><td><code id="rspde.matern1d_+3A_nu.prec.inc">nu.prec.inc</code></td>
<td>
<p>Amount to increase the precision in the beta prior
distribution.</p>
</td></tr>
<tr><td><code id="rspde.matern1d_+3A_type.rational.approx">type.rational.approx</code></td>
<td>
<p>Which type of rational approximation
should be used? The current types are &quot;chebfun&quot;, &quot;brasil&quot; or &quot;chebfunLB&quot;.</p>
</td></tr>
<tr><td><code id="rspde.matern1d_+3A_debug">debug</code></td>
<td>
<p>INLA debug argument</p>
</td></tr>
<tr><td><code id="rspde.matern1d_+3A_shared_lib">shared_lib</code></td>
<td>
<p>Which shared lib to use for the cgeneric implementation?
If &quot;detect&quot;, it will check if the shared lib exists locally, in which case it will
use it. Otherwise it will use INLA's shared library.
If &quot;INLA&quot;, it will use the shared lib from INLA's installation. If 'rSPDE', then
it will use the local installation (does not work if your installation is from CRAN).
Otherwise, you can directly supply the path of the .so (or .dll) file.</p>
</td></tr>
<tr><td><code id="rspde.matern1d_+3A_...">...</code></td>
<td>
<p>Only being used internally.</p>
</td></tr>
<tr><td><code id="rspde.matern1d_+3A_prior.kappa">prior.kappa</code></td>
<td>
<p>a <code>list</code> containing the elements <code>meanlog</code> and
<code>sdlog</code>, that is, the mean and standard deviation on the log scale.</p>
</td></tr>
<tr><td><code id="rspde.matern1d_+3A_prior.tau">prior.tau</code></td>
<td>
<p>a list containing the elements <code>meanlog</code> and
<code>sdlog</code>, that is, the mean and standard deviation on the log scale.</p>
</td></tr>
<tr><td><code id="rspde.matern1d_+3A_prior.range">prior.range</code></td>
<td>
<p>a <code>list</code> containing the elements <code>meanlog</code> and
<code>sdlog</code>, that is, the mean and standard deviation on the log scale. Will not be used if prior.kappa is non-null.</p>
</td></tr>
<tr><td><code id="rspde.matern1d_+3A_prior.std.dev">prior.std.dev</code></td>
<td>
<p>a <code>list</code> containing the elements <code>meanlog</code> and
<code>sdlog</code>, that is, the mean and standard deviation on the log scale. Will not be used if prior.tau is non-null.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An INLA model.
</p>

<hr>
<h2 id='rspde.mesh.project'>Calculate a lattice projection to/from an <code>inla.mesh</code> for
rSPDE objects</h2><span id='topic+rspde.mesh.project'></span><span id='topic+rspde.mesh.projector'></span><span id='topic+rspde.mesh.project.inla.mesh'></span><span id='topic+rspde.mesh.project.rspde.mesh.projector'></span><span id='topic+rspde.mesh.project.inla.mesh.1d'></span>

<h3>Description</h3>

<p>Calculate a lattice projection to/from an <code>inla.mesh</code> for
rSPDE objects
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rspde.mesh.project(...)

rspde.mesh.projector(
  mesh,
  nu = NULL,
  rspde.order = 1,
  loc = NULL,
  lattice = NULL,
  xlim = NULL,
  ylim = NULL,
  dims = c(100, 100),
  projection = NULL,
  ...
)

## S3 method for class 'inla.mesh'
rspde.mesh.project(
  mesh,
  loc = NULL,
  field = NULL,
  rspde.order = 1,
  nu = NULL,
  ...
)

## S3 method for class 'rspde.mesh.projector'
rspde.mesh.project(projector, field, ...)

## S3 method for class 'inla.mesh.1d'
rspde.mesh.project(mesh, loc, field = NULL, rspde.order = 1, nu = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="rspde.mesh.project_+3A_...">...</code></td>
<td>
<p>Additional parameters.</p>
</td></tr>
<tr><td><code id="rspde.mesh.project_+3A_mesh">mesh</code></td>
<td>
<p>An <code>inla.mesh</code> or <code>inla.mesh.1d</code> object.</p>
</td></tr>
<tr><td><code id="rspde.mesh.project_+3A_nu">nu</code></td>
<td>
<p>The smoothness parameter. If <code>NULL</code>, it will be assumed that
nu was estimated.</p>
</td></tr>
<tr><td><code id="rspde.mesh.project_+3A_rspde.order">rspde.order</code></td>
<td>
<p>The order of the rational approximation.</p>
</td></tr>
<tr><td><code id="rspde.mesh.project_+3A_loc">loc</code></td>
<td>
<p>Projection locations. Can be a matrix or a SpatialPoints or a
SpatialPointsDataFrame object.</p>
</td></tr>
<tr><td><code id="rspde.mesh.project_+3A_lattice">lattice</code></td>
<td>
<p>An <code>inla.mesh.lattice</code> object.</p>
</td></tr>
<tr><td><code id="rspde.mesh.project_+3A_xlim">xlim</code></td>
<td>
<p>X-axis limits for a lattice. For R2 meshes, defaults to covering
the domain.</p>
</td></tr>
<tr><td><code id="rspde.mesh.project_+3A_ylim">ylim</code></td>
<td>
<p>Y-axis limits for a lattice. For R2 meshes, defaults to covering
the domain.</p>
</td></tr>
<tr><td><code id="rspde.mesh.project_+3A_dims">dims</code></td>
<td>
<p>Lattice dimensions.</p>
</td></tr>
<tr><td><code id="rspde.mesh.project_+3A_projection">projection</code></td>
<td>
<p>One of c(&quot;default&quot;, &quot;longlat&quot;, &quot;longsinlat&quot;, &quot;mollweide&quot;).</p>
</td></tr>
<tr><td><code id="rspde.mesh.project_+3A_field">field</code></td>
<td>
<p>Basis function weights, one per mesh basis function, describing
the function to be evaluated at the projection locations.</p>
</td></tr>
<tr><td><code id="rspde.mesh.project_+3A_projector">projector</code></td>
<td>
<p>A <code>rspde.mesh.projector</code> object.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is built upon the inla.mesh.project and
inla.mesh.projector functions from INLA.
</p>


<h3>Value</h3>

<p>A list with projection information for rspde.mesh.project. For
rspde.mesh.projector(mesh, ...),
a rspde.mesh.projector object. For rspde.mesh.project(projector, field, ...),
a field projected from the mesh onto the locations
given by the projector object.
</p>

<hr>
<h2 id='rspde.metric_graph'>Matern rSPDE model object for metric graphs in INLA</h2><span id='topic+rspde.metric_graph'></span>

<h3>Description</h3>

<p>Creates an INLA object for a stationary Matern model on a metric graph with
general smoothness parameter.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rspde.metric_graph(
  graph_obj,
  h = NULL,
  nu.upper.bound = 2,
  rspde.order = 1,
  nu = NULL,
  debug = FALSE,
  B.sigma = matrix(c(0, 1, 0), 1, 3),
  B.range = matrix(c(0, 0, 1), 1, 3),
  parameterization = c("matern", "spde"),
  B.tau = matrix(c(0, 1, 0), 1, 3),
  B.kappa = matrix(c(0, 0, 1), 1, 3),
  start.nu = NULL,
  start.theta = NULL,
  prior.nu = NULL,
  theta.prior.mean = NULL,
  theta.prior.prec = 0.1,
  prior.std.dev.nominal = 1,
  prior.range.nominal = NULL,
  prior.kappa.mean = NULL,
  prior.tau.mean = NULL,
  start.lstd.dev = NULL,
  start.lrange = NULL,
  start.ltau = NULL,
  start.lkappa = NULL,
  prior.theta.param = c("theta", "spde"),
  prior.nu.dist = c("lognormal", "beta"),
  nu.prec.inc = 1,
  type.rational.approx = c("chebfun", "brasil", "chebfunLB"),
  shared_lib = "INLA"
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="rspde.metric_graph_+3A_graph_obj">graph_obj</code></td>
<td>
<p>The graph object to build the model. Needs to be of class <code>metric_graph</code>. It should have a built mesh.
If the mesh is not built, one will be built using h=0.01 as default.</p>
</td></tr>
<tr><td><code id="rspde.metric_graph_+3A_h">h</code></td>
<td>
<p>The width of the mesh in case the mesh was not built.</p>
</td></tr>
<tr><td><code id="rspde.metric_graph_+3A_nu.upper.bound">nu.upper.bound</code></td>
<td>
<p>Upper bound for the smoothness parameter.</p>
</td></tr>
<tr><td><code id="rspde.metric_graph_+3A_rspde.order">rspde.order</code></td>
<td>
<p>The order of the covariance-based rational SPDE approach.</p>
</td></tr>
<tr><td><code id="rspde.metric_graph_+3A_nu">nu</code></td>
<td>
<p>If nu is set to a parameter, nu will be kept fixed and will not
be estimated. If nu is <code>NULL</code>, it will be estimated.</p>
</td></tr>
<tr><td><code id="rspde.metric_graph_+3A_debug">debug</code></td>
<td>
<p>INLA debug argument</p>
</td></tr>
<tr><td><code id="rspde.metric_graph_+3A_b.sigma">B.sigma</code></td>
<td>
<p>Matrix with specification of log-linear model for <code class="reqn">\sigma</code>. Will be used if <code>parameterization = 'matern'</code>.</p>
</td></tr>
<tr><td><code id="rspde.metric_graph_+3A_b.range">B.range</code></td>
<td>
<p>Matrix with specification of log-linear model for <code class="reqn">\rho</code>, which is a range-like parameter (it is exactly the range parameter in the stationary case). Will be used if <code>parameterization = 'matern'</code>.</p>
</td></tr>
<tr><td><code id="rspde.metric_graph_+3A_parameterization">parameterization</code></td>
<td>
<p>Which parameterization to use? <code>matern</code> uses range, std. deviation and nu (smoothness). <code>spde</code> uses kappa, tau and nu (smoothness). The default is <code>matern</code>.</p>
</td></tr>
<tr><td><code id="rspde.metric_graph_+3A_b.tau">B.tau</code></td>
<td>
<p>Matrix with specification of log-linear model for <code class="reqn">\tau</code>. Will be used if <code>parameterization = 'spde'</code>.</p>
</td></tr>
<tr><td><code id="rspde.metric_graph_+3A_b.kappa">B.kappa</code></td>
<td>
<p>Matrix with specification of log-linear model for <code class="reqn">\kappa</code>. Will be used if <code>parameterization = 'spde'</code>.</p>
</td></tr>
<tr><td><code id="rspde.metric_graph_+3A_start.nu">start.nu</code></td>
<td>
<p>Starting value for nu.</p>
</td></tr>
<tr><td><code id="rspde.metric_graph_+3A_start.theta">start.theta</code></td>
<td>
<p>Starting values for the model parameters. In the stationary case, if <code>parameterization='matern'</code>, then <code>theta[1]</code> is the std.dev and <code>theta[2]</code> is the range parameter.
If <code>parameterization = 'spde'</code>, then <code>theta[1]</code> is <code>tau</code> and <code>theta[2]</code> is <code>kappa</code>.</p>
</td></tr>
<tr><td><code id="rspde.metric_graph_+3A_prior.nu">prior.nu</code></td>
<td>
<p>a list containing the elements <code>mean</code> and <code>prec</code>
for beta distribution, or <code>loglocation</code> and <code>logscale</code> for a
truncated lognormal distribution. <code>loglocation</code> stands for
the location parameter of the truncated lognormal distribution in the log
scale. <code>prec</code> stands for the precision of a beta distribution.
<code>logscale</code> stands for the scale of the truncated lognormal
distribution on the log scale. Check details below.</p>
</td></tr>
<tr><td><code id="rspde.metric_graph_+3A_theta.prior.mean">theta.prior.mean</code></td>
<td>
<p>A vector for the mean priors of <code>theta</code>.</p>
</td></tr>
<tr><td><code id="rspde.metric_graph_+3A_theta.prior.prec">theta.prior.prec</code></td>
<td>
<p>A precision matrix for the prior of <code>theta</code>.</p>
</td></tr>
<tr><td><code id="rspde.metric_graph_+3A_prior.std.dev.nominal">prior.std.dev.nominal</code></td>
<td>
<p>Prior std. deviation to be used for the priors and for the starting values.</p>
</td></tr>
<tr><td><code id="rspde.metric_graph_+3A_prior.range.nominal">prior.range.nominal</code></td>
<td>
<p>Prior range to be used for the priors and for the starting values.</p>
</td></tr>
<tr><td><code id="rspde.metric_graph_+3A_prior.kappa.mean">prior.kappa.mean</code></td>
<td>
<p>Prior kappa to be used for the priors and for the starting values.</p>
</td></tr>
<tr><td><code id="rspde.metric_graph_+3A_prior.tau.mean">prior.tau.mean</code></td>
<td>
<p>Prior tau to be used for the priors and for the starting values.</p>
</td></tr>
<tr><td><code id="rspde.metric_graph_+3A_start.lstd.dev">start.lstd.dev</code></td>
<td>
<p>Starting value for log of std. deviation. Will not be used if start.ltau is non-null. Will be only used in the stationary case and if <code>parameterization = 'matern'</code>.</p>
</td></tr>
<tr><td><code id="rspde.metric_graph_+3A_start.lrange">start.lrange</code></td>
<td>
<p>Starting value for log of range. Will not be used if start.lkappa is non-null. Will be only used in the stationary case and if <code>parameterization = 'matern'</code>.</p>
</td></tr>
<tr><td><code id="rspde.metric_graph_+3A_start.ltau">start.ltau</code></td>
<td>
<p>Starting value for log of tau. Will be only used in the stationary case and if <code>parameterization = 'spde'</code>.</p>
</td></tr>
<tr><td><code id="rspde.metric_graph_+3A_start.lkappa">start.lkappa</code></td>
<td>
<p>Starting value for log of kappa. Will be only used in the stationary case and if <code>parameterization = 'spde'</code>.</p>
</td></tr>
<tr><td><code id="rspde.metric_graph_+3A_prior.theta.param">prior.theta.param</code></td>
<td>
<p>Should the lognormal prior be on <code>theta</code> or on the SPDE parameters (<code>tau</code> and <code>kappa</code> on the stationary case)?</p>
</td></tr>
<tr><td><code id="rspde.metric_graph_+3A_prior.nu.dist">prior.nu.dist</code></td>
<td>
<p>The distribution of the smoothness parameter.
The current options are &quot;beta&quot; or &quot;lognormal&quot;. The default is &quot;beta&quot;.</p>
</td></tr>
<tr><td><code id="rspde.metric_graph_+3A_nu.prec.inc">nu.prec.inc</code></td>
<td>
<p>Amount to increase the precision in the beta prior
distribution. Check details below.</p>
</td></tr>
<tr><td><code id="rspde.metric_graph_+3A_type.rational.approx">type.rational.approx</code></td>
<td>
<p>Which type of rational approximation
should be used? The current types are &quot;chebfun&quot;, &quot;brasil&quot; or &quot;chebfunLB&quot;.</p>
</td></tr>
<tr><td><code id="rspde.metric_graph_+3A_shared_lib">shared_lib</code></td>
<td>
<p>Which shared lib to use for the cgeneric implementation?
If &quot;INLA&quot;, it will use the shared lib from INLA's installation. If 'rSPDE', then
it will use the local installation (does not work if your installation is from CRAN).
Otherwise, you can directly supply the path of the .so (or .dll) file.</p>
</td></tr>
<tr><td><code id="rspde.metric_graph_+3A_prior.kappa">prior.kappa</code></td>
<td>
<p>a <code>list</code> containing the elements <code>meanlog</code> and
<code>sdlog</code>, that is, the mean and standard deviation on the log scale.</p>
</td></tr>
<tr><td><code id="rspde.metric_graph_+3A_prior.tau">prior.tau</code></td>
<td>
<p>a list containing the elements <code>meanlog</code> and
<code>sdlog</code>, that is, the mean and standard deviation on the log scale.</p>
</td></tr>
<tr><td><code id="rspde.metric_graph_+3A_prior.range">prior.range</code></td>
<td>
<p>a <code>list</code> containing the elements <code>meanlog</code> and
<code>sdlog</code>, that is, the mean and standard deviation on the log scale. Will not be used if prior.kappa is non-null.</p>
</td></tr>
<tr><td><code id="rspde.metric_graph_+3A_prior.std.dev">prior.std.dev</code></td>
<td>
<p>a <code>list</code> containing the elements <code>meanlog</code> and
<code>sdlog</code>, that is, the mean and standard deviation on the log scale. Will not be used if prior.tau is non-null.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An INLA model.
</p>

<hr>
<h2 id='rspde.result'>rSPDE result extraction from INLA estimation results</h2><span id='topic+rspde.result'></span>

<h3>Description</h3>

<p>Extract field and parameter values and distributions
for an rspde effect from an inla result object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rspde.result(
  inla,
  name,
  rspde,
  compute.summary = TRUE,
  parameterization = "detect",
  n_samples = 5000,
  n_density = 1024
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="rspde.result_+3A_inla">inla</code></td>
<td>
<p>An <code>inla</code> object obtained from a call to
<code>inla()</code>.</p>
</td></tr>
<tr><td><code id="rspde.result_+3A_name">name</code></td>
<td>
<p>A character string with the name of the rSPDE effect
in the inla formula.</p>
</td></tr>
<tr><td><code id="rspde.result_+3A_rspde">rspde</code></td>
<td>
<p>The <code>inla_rspde</code> object used for the effect in
the inla formula.</p>
</td></tr>
<tr><td><code id="rspde.result_+3A_compute.summary">compute.summary</code></td>
<td>
<p>Should the summary be computed?</p>
</td></tr>
<tr><td><code id="rspde.result_+3A_parameterization">parameterization</code></td>
<td>
<p>If 'detect', the parameterization from the model will be used. Otherwise, the options are 'spde', 'matern' and 'matern2'.</p>
</td></tr>
<tr><td><code id="rspde.result_+3A_n_samples">n_samples</code></td>
<td>
<p>The number of samples to be used if parameterization is different from the one used to fit the model.</p>
</td></tr>
<tr><td><code id="rspde.result_+3A_n_density">n_density</code></td>
<td>
<p>The number of equally spaced points to estimate the density.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>If the model was fitted with <code>matern</code> parameterization (the default), it returns a list containing:
</p>
<table role = "presentation">
<tr><td><code>marginals.range</code></td>
<td>
<p>Marginal densities for the range parameter</p>
</td></tr>
<tr><td><code>marginals.log.range</code></td>
<td>
<p>Marginal densities for log(range)</p>
</td></tr>
<tr><td><code>marginals.std.dev</code></td>
<td>
<p>Marginal densities for std. deviation</p>
</td></tr>
<tr><td><code>marginals.log.std.dev</code></td>
<td>
<p>Marginal densities for log(std. deviation)</p>
</td></tr>
<tr><td><code>marginals.values</code></td>
<td>
<p>Marginal densities for the field values</p>
</td></tr>
<tr><td><code>summary.log.range</code></td>
<td>
<p>Summary statistics for log(range)</p>
</td></tr>
<tr><td><code>summary.log.std.dev</code></td>
<td>
<p>Summary statistics for log(std. deviation)</p>
</td></tr>
<tr><td><code>summary.values</code></td>
<td>
<p>Summary statistics for the field values</p>
</td></tr>
</table>
<p>If <code>compute.summary</code> is <code>TRUE</code>, then the list will also contain
</p>
<table role = "presentation">
<tr><td><code>summary.kappa</code></td>
<td>
<p>Summary statistics for kappa</p>
</td></tr>
<tr><td><code>summary.tau</code></td>
<td>
<p>Summary statistics for tau</p>
</td></tr>
</table>
<p>If the model was fitted with the <code>spde</code> parameterization, it returns a list containing:
</p>
<table role = "presentation">
<tr><td><code>marginals.kappa</code></td>
<td>
<p>Marginal densities for kappa</p>
</td></tr>
<tr><td><code>marginals.log.kappa</code></td>
<td>
<p>Marginal densities for log(kappa)</p>
</td></tr>
<tr><td><code>marginals.log.tau</code></td>
<td>
<p>Marginal densities for log(tau)</p>
</td></tr>
<tr><td><code>marginals.tau</code></td>
<td>
<p>Marginal densities for tau</p>
</td></tr>
<tr><td><code>marginals.values</code></td>
<td>
<p>Marginal densities for the field values</p>
</td></tr>
<tr><td><code>summary.log.kappa</code></td>
<td>
<p>Summary statistics for log(kappa)</p>
</td></tr>
<tr><td><code>summary.log.tau</code></td>
<td>
<p>Summary statistics for log(tau)</p>
</td></tr>
<tr><td><code>summary.values</code></td>
<td>
<p>Summary statistics for the field values</p>
</td></tr>
</table>
<p>If <code>compute.summary</code> is <code>TRUE</code>, then the list will also contain
</p>
<table role = "presentation">
<tr><td><code>summary.kappa</code></td>
<td>
<p>Summary statistics for kappa</p>
</td></tr>
<tr><td><code>summary.tau</code></td>
<td>
<p>Summary statistics for tau</p>
</td></tr>
</table>
<p>For both cases, if nu was estimated, then the list will also contain
</p>
<table role = "presentation">
<tr><td><code>marginals.nu</code></td>
<td>
<p>Marginal densities for nu</p>
</td></tr>
</table>
<p>If nu was estimated and a beta prior was used, then the list will
also contain
</p>
<table role = "presentation">
<tr><td><code>marginals.logit.nu</code></td>
<td>
<p>Marginal densities for logit(nu)</p>
</td></tr>
<tr><td><code>summary.logit.nu</code></td>
<td>
<p>Marginal densities for logit(nu)</p>
</td></tr>
</table>
<p>If nu was estimated and a truncated lognormal prior was used,
then the list will also contain
</p>
<table role = "presentation">
<tr><td><code>marginals.log.nu</code></td>
<td>
<p>Marginal densities for log(nu)</p>
</td></tr>
<tr><td><code>summary.log.nu</code></td>
<td>
<p>Marginal densities for log(nu)</p>
</td></tr>
</table>
<p>If nu was estimated and <code>compute.summary</code> is <code>TRUE</code>,
then the list will also contain
</p>
<table role = "presentation">
<tr><td><code>summary.nu</code></td>
<td>
<p>Summary statistics for nu</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'> #tryCatch version
tryCatch({
if (requireNamespace("INLA", quietly = TRUE)) {
  library(INLA)

  set.seed(123)

  m &lt;- 100
  loc_2d_mesh &lt;- matrix(runif(m * 2), m, 2)
  mesh_2d &lt;- inla.mesh.2d(
    loc = loc_2d_mesh,
    cutoff = 0.05,
    max.edge = c(0.1, 0.5)
  )
  sigma &lt;- 1
  range &lt;- 0.2
  nu &lt;- 0.8
  kappa &lt;- sqrt(8 * nu) / range
  op &lt;- matern.operators(
    mesh = mesh_2d, nu = nu,
    range = range, sigma = sigma, m = 2,
    parameterization = "matern"
  )
  u &lt;- simulate(op)
  A &lt;- inla.spde.make.A(
    mesh = mesh_2d,
    loc = loc_2d_mesh
  )
  sigma.e &lt;- 0.1
  y &lt;- A %*% u + rnorm(m) * sigma.e
  Abar &lt;- rspde.make.A(mesh = mesh_2d, loc = loc_2d_mesh)
  mesh.index &lt;- rspde.make.index(name = "field", mesh = mesh_2d)
  st.dat &lt;- inla.stack(
    data = list(y = as.vector(y)),
    A = Abar,
    effects = mesh.index
  )
  rspde_model &lt;- rspde.matern(
    mesh = mesh_2d,
    nu.upper.bound = 2
  )
  f &lt;- y ~ -1 + f(field, model = rspde_model)
  rspde_fit &lt;- inla(f,
    data = inla.stack.data(st.dat),
    family = "gaussian",
    control.predictor =
      list(A = inla.stack.A(st.dat))
  )
  result &lt;- rspde.result(rspde_fit, "field", rspde_model)
  summary(result)
}
#stable.tryCatch
}, error = function(e){print("Could not run the example")})

</code></pre>

<hr>
<h2 id='rspde.spacetime'>Space-Time Random Fields via SPDE Approximation</h2><span id='topic+rspde.spacetime'></span>

<h3>Description</h3>

<p><code>rspde.spacetime</code> computes a Finite Element Method (FEM) approximation of a
Gaussian random field defined as the solution to the stochastic partial
differential equation (SPDE):
</p>
<p style="text-align: center;"><code class="reqn">d u + \gamma(\kappa^2 + \kappa^{d/2}\rho\cdot\nabla - \Delta)^\alpha u = \sigma dW_C</code>
</p>

<p>where <code class="reqn">C</code> is a Whittle-Matrn covariance operator with smoothness parameter
<code class="reqn">\beta</code> and range parameter <code class="reqn">\kappa</code>. This function is designed to handle
space-time random fields using either 1D spatial models or higher-dimensional
FEM-based approaches.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rspde.spacetime(
  mesh_space = NULL,
  mesh_time = NULL,
  space_loc = NULL,
  time_loc = NULL,
  drift = TRUE,
  alpha,
  beta,
  prior.kappa = NULL,
  prior.sigma = NULL,
  prior.rho = NULL,
  prior.gamma = NULL,
  prior.precision = NULL,
  bounded_rho = TRUE,
  shared_lib = "detect",
  debug = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="rspde.spacetime_+3A_mesh_space">mesh_space</code></td>
<td>
<p>Spatial mesh for the FEM approximation, or a <code>metric_graph</code>
object for handling models on metric graphs.</p>
</td></tr>
<tr><td><code id="rspde.spacetime_+3A_mesh_time">mesh_time</code></td>
<td>
<p>Temporal mesh for the FEM approximation.</p>
</td></tr>
<tr><td><code id="rspde.spacetime_+3A_space_loc">space_loc</code></td>
<td>
<p>A vector of spatial locations for mesh nodes in 1D spatial models.
This should be provided when <code>mesh_space</code> is not specified.</p>
</td></tr>
<tr><td><code id="rspde.spacetime_+3A_time_loc">time_loc</code></td>
<td>
<p>A vector of temporal locations for mesh nodes. This should be
provided when <code>mesh_time</code> is not specified.</p>
</td></tr>
<tr><td><code id="rspde.spacetime_+3A_drift">drift</code></td>
<td>
<p>Logical value indicating whether the drift term should be included.
If <code>FALSE</code>, the drift coefficient <code class="reqn">\rho</code> is set to zero.</p>
</td></tr>
<tr><td><code id="rspde.spacetime_+3A_alpha">alpha</code></td>
<td>
<p>Integer smoothness parameter <code class="reqn">\alpha</code>.</p>
</td></tr>
<tr><td><code id="rspde.spacetime_+3A_beta">beta</code></td>
<td>
<p>Integer smoothness parameter <code class="reqn">\beta</code>.</p>
</td></tr>
<tr><td><code id="rspde.spacetime_+3A_prior.kappa">prior.kappa</code></td>
<td>
<p>A list specifying the prior for the range parameter <code class="reqn">\kappa</code>.
This list may contain two elements: <code>mean</code> and/or <code>precision</code>, both of which must
be numeric scalars (numeric vectors of length 1). The precision refers to the prior
on <code class="reqn">\log(\kappa)</code>. If <code>NULL</code>, default values will be used. The <code>mean</code> value is also used as starting value for kappa.</p>
</td></tr>
<tr><td><code id="rspde.spacetime_+3A_prior.sigma">prior.sigma</code></td>
<td>
<p>A list specifying the prior for the variance parameter <code class="reqn">\sigma</code>.
This list may contain two elements: <code>mean</code> and/or <code>precision</code>, both of which must
be numeric scalars. The precision refers to the prior on <code class="reqn">\log(\sigma)</code>. If <code>NULL</code>,
default values will be used. The <code>mean</code> value is also used as starting value for sigma.</p>
</td></tr>
<tr><td><code id="rspde.spacetime_+3A_prior.rho">prior.rho</code></td>
<td>
<p>A list specifying the prior for the drift coefficient <code class="reqn">\rho</code>.
This list may contain two elements: <code>mean</code> and/or <code>precision</code>, both of which must
be numeric scalars if dimension is one, and numeric vectors of length 2 if dimension is 2.
The precision applies directly to <code class="reqn">\rho</code> without log transformation.
If <code>NULL</code>, default values will be used. Will not be used if <code>drift = FALSE</code>. The <code>mean</code> value is also used as starting value for rho.</p>
</td></tr>
<tr><td><code id="rspde.spacetime_+3A_prior.gamma">prior.gamma</code></td>
<td>
<p>A list specifying the prior for the weight <code class="reqn">\gamma</code> in the SPDE
operator. This list may contain two elements: <code>mean</code> and/or <code>precision</code>, both of which
must be numeric scalars. The precision refers to the prior on <code class="reqn">\log(\gamma)</code>. If <code>NULL</code>,
default values will be used. The <code>mean</code> value is also used as starting value for gamma.</p>
</td></tr>
<tr><td><code id="rspde.spacetime_+3A_prior.precision">prior.precision</code></td>
<td>
<p>A precision matrix for <code class="reqn">\log(\kappa), \log(\sigma), \log(\gamma), \rho</code>. This matrix replaces the precision
element from <code>prior.kappa</code>, <code>prior.sigma</code>, <code>prior.gamma</code>, and <code>prior.rho</code> respectively. For dimension 1 <code>prior.precision</code> must be a 4x4 matrix. For dimension 2, <code class="reqn">\rho</code> is a vector of length 2, so in this case <code>prior.precision</code> must be a 5x5 matrix. If <code>NULL</code>, a diagonal precision matrix with default values will be used.</p>
</td></tr>
<tr><td><code id="rspde.spacetime_+3A_bounded_rho">bounded_rho</code></td>
<td>
<p>Logical. Should <code>rho</code> be bounded to ensure the existence, uniqueness, and well-posedness of the solution? Defaults to <code>TRUE</code>.
Note that this bounding is not a strict condition; there may exist values of rho beyond the upper bound that still satisfy these properties.
When <code>bounded_rho = TRUE</code>, the <code>rspde_lme</code> models enforce bounded <code>rho</code> for consistency.
If the estimated value of <code>rho</code> approaches the upper bound too closely, we recommend refitting the model with <code>bounded_rho = FALSE</code>. However, this should be done with caution, as it may lead to instability in some cases, though it can also result in a better model fit.
The actual bound used for <code>rho</code> can be accessed from the <code>bound_rho</code> element of the returned object.</p>
</td></tr>
<tr><td><code id="rspde.spacetime_+3A_shared_lib">shared_lib</code></td>
<td>
<p>String specifying which shared library to use for the Cgeneric
implementation. Options are &quot;detect&quot;, &quot;INLA&quot;, or &quot;rSPDE&quot;. You may also specify the
direct path to a .so (or .dll) file.</p>
</td></tr>
<tr><td><code id="rspde.spacetime_+3A_debug">debug</code></td>
<td>
<p>Logical value indicating whether to enable INLA debug mode.</p>
</td></tr>
<tr><td><code id="rspde.spacetime_+3A_...">...</code></td>
<td>
<p>Additional arguments passed internally for configuration purposes.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <code>inla_rspde_spacetime</code> representing the FEM approximation of
the space-time Gaussian random field.
</p>

<hr>
<h2 id='simulate.CBrSPDEobj'>Simulation of a fractional SPDE using the
covariance-based rational SPDE approximation</h2><span id='topic+simulate.CBrSPDEobj'></span>

<h3>Description</h3>

<p>The function samples a Gaussian random field based using the
covariance-based rational SPDE approximation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'CBrSPDEobj'
simulate(
  object,
  nsim = 1,
  seed = NULL,
  nu = NULL,
  kappa = NULL,
  sigma = NULL,
  range = NULL,
  tau = NULL,
  theta = NULL,
  m = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="simulate.CBrSPDEobj_+3A_object">object</code></td>
<td>
<p>The covariance-based rational SPDE approximation,
computed using <code><a href="#topic+matern.operators">matern.operators()</a></code></p>
</td></tr>
<tr><td><code id="simulate.CBrSPDEobj_+3A_nsim">nsim</code></td>
<td>
<p>The number of simulations.</p>
</td></tr>
<tr><td><code id="simulate.CBrSPDEobj_+3A_seed">seed</code></td>
<td>
<p>An object specifying if and how the random number generator should be initialized (seeded).</p>
</td></tr>
<tr><td><code id="simulate.CBrSPDEobj_+3A_nu">nu</code></td>
<td>
<p>If non-null, update the shape parameter of the
covariance function.</p>
</td></tr>
<tr><td><code id="simulate.CBrSPDEobj_+3A_kappa">kappa</code></td>
<td>
<p>If non-null, update the range parameter
of the covariance function.</p>
</td></tr>
<tr><td><code id="simulate.CBrSPDEobj_+3A_sigma">sigma</code></td>
<td>
<p>If non-null, update the standard deviation of
the covariance function.</p>
</td></tr>
<tr><td><code id="simulate.CBrSPDEobj_+3A_range">range</code></td>
<td>
<p>If non-null, update the range parameter
of the covariance function.</p>
</td></tr>
<tr><td><code id="simulate.CBrSPDEobj_+3A_tau">tau</code></td>
<td>
<p>If non-null, update the parameter tau.</p>
</td></tr>
<tr><td><code id="simulate.CBrSPDEobj_+3A_theta">theta</code></td>
<td>
<p>For non-stationary models. If non-null, update the vector of parameters.</p>
</td></tr>
<tr><td><code id="simulate.CBrSPDEobj_+3A_m">m</code></td>
<td>
<p>If non-null, update the order of the rational
approximation, which needs to be a positive integer.</p>
</td></tr>
<tr><td><code id="simulate.CBrSPDEobj_+3A_...">...</code></td>
<td>
<p>Currently not used.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix with the <code>n</code> samples as columns.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Sample a Gaussian Matern process on R using a rational approximation
kappa &lt;- 10
sigma &lt;- 1
nu &lt;- 0.8
range &lt;- sqrt(8 * nu) / kappa

# create mass and stiffness matrices for a FEM discretization
x &lt;- seq(from = 0, to = 1, length.out = 101)
fem &lt;- rSPDE.fem1d(x)

# compute rational approximation of covariance function at 0.5
tau &lt;- sqrt(gamma(nu) / (sigma^2 * kappa^(2 * nu) *
  (4 * pi)^(1 / 2) * gamma(nu + 1 / 2)))
op_cov &lt;- matern.operators(
  loc_mesh = x, nu = nu,
  range = range, sigma = sigma, d = 1, m = 2,
  parameterization = "matern"
)

# Sample the model and plot the result
Y &lt;- simulate(op_cov)
plot(x, Y, type = "l", ylab = "u(x)", xlab = "x")

</code></pre>

<hr>
<h2 id='simulate.CBrSPDEobj2d'>Simulation of a fractional SPDE using the
covariance-based rational SPDE approximation</h2><span id='topic+simulate.CBrSPDEobj2d'></span>

<h3>Description</h3>

<p>The function samples a Gaussian random field based using the
covariance-based rational SPDE approximation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'CBrSPDEobj2d'
simulate(
  object,
  nsim = 1,
  seed = NULL,
  nu = NULL,
  hx = NULL,
  hy = NULL,
  hxy = NULL,
  sigma = NULL,
  m = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="simulate.CBrSPDEobj2d_+3A_object">object</code></td>
<td>
<p>The covariance-based rational SPDE approximation,
computed using <code><a href="#topic+matern2d.operators">matern2d.operators()</a></code></p>
</td></tr>
<tr><td><code id="simulate.CBrSPDEobj2d_+3A_nsim">nsim</code></td>
<td>
<p>The number of simulations.</p>
</td></tr>
<tr><td><code id="simulate.CBrSPDEobj2d_+3A_seed">seed</code></td>
<td>
<p>An object specifying if and how the random number generator should be initialized (seeded).</p>
</td></tr>
<tr><td><code id="simulate.CBrSPDEobj2d_+3A_nu">nu</code></td>
<td>
<p>If non-null, update the shape parameter of the
covariance function.</p>
</td></tr>
<tr><td><code id="simulate.CBrSPDEobj2d_+3A_hx">hx</code></td>
<td>
<p>If non-null, update the hx parameter.</p>
</td></tr>
<tr><td><code id="simulate.CBrSPDEobj2d_+3A_hy">hy</code></td>
<td>
<p>If non-null, update the hy parameter.</p>
</td></tr>
<tr><td><code id="simulate.CBrSPDEobj2d_+3A_hxy">hxy</code></td>
<td>
<p>If non-null, update the hxy parameter.</p>
</td></tr>
<tr><td><code id="simulate.CBrSPDEobj2d_+3A_sigma">sigma</code></td>
<td>
<p>If non-null, update the standard deviation of
the covariance function.</p>
</td></tr>
<tr><td><code id="simulate.CBrSPDEobj2d_+3A_m">m</code></td>
<td>
<p>If non-null, update the order of the rational
approximation, which needs to be a positive integer.</p>
</td></tr>
<tr><td><code id="simulate.CBrSPDEobj2d_+3A_...">...</code></td>
<td>
<p>Currently not used.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix with the <code>n</code> samples as columns.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(fmesher)
n_loc &lt;- 2000
loc_2d_mesh &lt;- matrix(runif(n_loc * 2), n_loc, 2)
mesh_2d &lt;- fm_mesh_2d(loc = loc_2d_mesh, cutoff = 0.03, max.edge = c(0.1, 0.5))
op &lt;- matern2d.operators(mesh = mesh_2d, sigma = 1, nu = 1, hx = 0.1, hy = 0.1, hxy = 0)
u &lt;- simulate(op)
</code></pre>

<hr>
<h2 id='simulate.intrinsicCBrSPDEobj'>Simulation of a fractional intrinsic SPDE using the
covariance-based rational SPDE approximation</h2><span id='topic+simulate.intrinsicCBrSPDEobj'></span>

<h3>Description</h3>

<p>The function samples a Gaussian random field based using the
covariance-based rational SPDE approximation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'intrinsicCBrSPDEobj'
simulate(object, nsim = 1, seed = NULL, integral.constraint = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="simulate.intrinsicCBrSPDEobj_+3A_object">object</code></td>
<td>
<p>The covariance-based rational SPDE approximation,
computed using <code><a href="#topic+intrinsic.matern.operators">intrinsic.matern.operators()</a></code></p>
</td></tr>
<tr><td><code id="simulate.intrinsicCBrSPDEobj_+3A_nsim">nsim</code></td>
<td>
<p>The number of simulations.</p>
</td></tr>
<tr><td><code id="simulate.intrinsicCBrSPDEobj_+3A_seed">seed</code></td>
<td>
<p>An object specifying if and how the random number generator should be initialized (seeded).</p>
</td></tr>
<tr><td><code id="simulate.intrinsicCBrSPDEobj_+3A_integral.constraint">integral.constraint</code></td>
<td>
<p>Should the contraint on the integral be done?</p>
</td></tr>
<tr><td><code id="simulate.intrinsicCBrSPDEobj_+3A_...">...</code></td>
<td>
<p>Currently not used.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix with the <code>nsim</code> samples as columns.
</p>

<hr>
<h2 id='simulate.rSPDEobj'>Simulation of a fractional SPDE using a rational SPDE approximation</h2><span id='topic+simulate.rSPDEobj'></span>

<h3>Description</h3>

<p>The function samples a Gaussian random field based on a
pre-computed rational SPDE approximation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'rSPDEobj'
simulate(object, nsim = 1, seed = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="simulate.rSPDEobj_+3A_object">object</code></td>
<td>
<p>The rational SPDE approximation, computed
using <code><a href="#topic+fractional.operators">fractional.operators()</a></code>,
<code><a href="#topic+matern.operators">matern.operators()</a></code>, or <code><a href="#topic+spde.matern.operators">spde.matern.operators()</a></code>.</p>
</td></tr>
<tr><td><code id="simulate.rSPDEobj_+3A_nsim">nsim</code></td>
<td>
<p>The number of simulations.</p>
</td></tr>
<tr><td><code id="simulate.rSPDEobj_+3A_seed">seed</code></td>
<td>
<p>an object specifying if and how the random number generator should be initialized (seeded).</p>
</td></tr>
<tr><td><code id="simulate.rSPDEobj_+3A_...">...</code></td>
<td>
<p>Currently not used.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix with the <code>n</code> samples as columns.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+simulate.CBrSPDEobj">simulate.CBrSPDEobj()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Sample a Gaussian Matern process on R using a rational approximation
kappa &lt;- 10
sigma &lt;- 1
nu &lt;- 0.8
range &lt;- sqrt(8 * nu) / kappa

# create mass and stiffness matrices for a FEM discretization
x &lt;- seq(from = 0, to = 1, length.out = 101)
fem &lt;- rSPDE.fem1d(x)

# compute rational approximation
op &lt;- matern.operators(
  range = range, sigma = sigma,
  nu = nu, loc_mesh = x, d = 1,
  parameterization = "matern"
)

# Sample the model and plot the result
Y &lt;- simulate(op)
plot(x, Y, type = "l", ylab = "u(x)", xlab = "x")

</code></pre>

<hr>
<h2 id='simulate.rSPDEobj1d'>Simulation of a Matern field using a rational SPDE approximation</h2><span id='topic+simulate.rSPDEobj1d'></span>

<h3>Description</h3>

<p>The function samples a Gaussian random field based on a
pre-computed rational SPDE approximation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'rSPDEobj1d'
simulate(object, nsim = 1, seed = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="simulate.rSPDEobj1d_+3A_object">object</code></td>
<td>
<p>The rational SPDE approximation, computed
using <code><a href="#topic+matern.rational">matern.rational()</a></code>.</p>
</td></tr>
<tr><td><code id="simulate.rSPDEobj1d_+3A_nsim">nsim</code></td>
<td>
<p>The number of simulations.</p>
</td></tr>
<tr><td><code id="simulate.rSPDEobj1d_+3A_seed">seed</code></td>
<td>
<p>an object specifying if and how the random number generator should be initialized (seeded).</p>
</td></tr>
<tr><td><code id="simulate.rSPDEobj1d_+3A_...">...</code></td>
<td>
<p>Currently not used.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix with the <code>n</code> samples as columns.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+matern.rational">matern.rational()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Sample a Gaussian Matern process on R using a rational approximation
range &lt;- 0.2
sigma &lt;- 1
nu &lt;- 0.8

# compute rational approximation
x &lt;- seq(from = 0, to = 1, length.out = 100)
op &lt;- matern.rational(
  range = range, sigma = sigma,
  nu = nu, loc = x
)

# Sample the model and plot the result
Y &lt;- simulate(op)
plot(x, Y, type = "l", ylab = "u(x)", xlab = "x")

</code></pre>

<hr>
<h2 id='simulate.spacetimeobj'>Simulation of space-time models</h2><span id='topic+simulate.spacetimeobj'></span>

<h3>Description</h3>

<p>Simulation of space-time models
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'spacetimeobj'
simulate(
  object,
  nsim = 1,
  seed = NULL,
  kappa = NULL,
  sigma = NULL,
  gamma = NULL,
  rho = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="simulate.spacetimeobj_+3A_object">object</code></td>
<td>
<p>Space-time object created by <code><a href="#topic+spacetime.operators">spacetime.operators()</a></code></p>
</td></tr>
<tr><td><code id="simulate.spacetimeobj_+3A_nsim">nsim</code></td>
<td>
<p>The number of simulations.</p>
</td></tr>
<tr><td><code id="simulate.spacetimeobj_+3A_seed">seed</code></td>
<td>
<p>an object specifying if and how the random number generator should be initialized (seeded).</p>
</td></tr>
<tr><td><code id="simulate.spacetimeobj_+3A_kappa">kappa</code></td>
<td>
<p>kappa parameter if it should be updated</p>
</td></tr>
<tr><td><code id="simulate.spacetimeobj_+3A_sigma">sigma</code></td>
<td>
<p>sigma parameter if it should be updated</p>
</td></tr>
<tr><td><code id="simulate.spacetimeobj_+3A_gamma">gamma</code></td>
<td>
<p>gamma parameter if it should be updated</p>
</td></tr>
<tr><td><code id="simulate.spacetimeobj_+3A_rho">rho</code></td>
<td>
<p>rho parameter if it should be updated</p>
</td></tr>
<tr><td><code id="simulate.spacetimeobj_+3A_...">...</code></td>
<td>
<p>Currently not used.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix with the simulations as columns.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>s &lt;- seq(from = 0, to = 20, length.out = 101)
t &lt;- seq(from = 0, to = 20, length.out = 31)

op_cov &lt;- spacetime.operators(space_loc = s, time_loc = t,
                             kappa = 5, sigma = 10, alpha = 1,
                             beta = 2, rho = 1, gamma = 0.05)
x &lt;- simulate(op_cov, nsim = 1) 
image(matrix(x, nrow = length(s), ncol = length(t)))                              
</code></pre>

<hr>
<h2 id='spacetime.operators'>Space-time random fields</h2><span id='topic+spacetime.operators'></span>

<h3>Description</h3>

<p><code>spacetime.operators</code> is used for computing a FEM approximation of a Gaussian
random field defined as a solution to the SPDE
</p>
<p style="text-align: center;"><code class="reqn">d u + \gamma(\kappa^2 + \kappa^{d/2}\rho \cdot\nabla - \Delta)^\alpha u = \sigma dW_C.</code>
</p>

<p>where C is a Whittle-Matern covariance operator with smoothness parameter
<code class="reqn">\beta</code> and range parameter <code class="reqn">\kappa</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>spacetime.operators(
  mesh_space = NULL,
  mesh_time = NULL,
  space_loc = NULL,
  time_loc = NULL,
  graph = NULL,
  kappa = NULL,
  sigma = NULL,
  gamma = NULL,
  rho = NULL,
  alpha = NULL,
  beta = NULL,
  bounded_rho = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="spacetime.operators_+3A_mesh_space">mesh_space</code></td>
<td>
<p>Spatial mesh for FEM approximation</p>
</td></tr>
<tr><td><code id="spacetime.operators_+3A_mesh_time">mesh_time</code></td>
<td>
<p>Temporal mesh for FEM approximation</p>
</td></tr>
<tr><td><code id="spacetime.operators_+3A_space_loc">space_loc</code></td>
<td>
<p>Locations of mesh nodes for spatial mesh for 1d models.</p>
</td></tr>
<tr><td><code id="spacetime.operators_+3A_time_loc">time_loc</code></td>
<td>
<p>Locations of temporal mesh nodes.</p>
</td></tr>
<tr><td><code id="spacetime.operators_+3A_graph">graph</code></td>
<td>
<p>An optional <code>metric_graph</code> object. Replaces <code>mesh</code> for models on
metric graphs.</p>
</td></tr>
<tr><td><code id="spacetime.operators_+3A_kappa">kappa</code></td>
<td>
<p>Positive spatial range parameter</p>
</td></tr>
<tr><td><code id="spacetime.operators_+3A_sigma">sigma</code></td>
<td>
<p>Positive variance parameter</p>
</td></tr>
<tr><td><code id="spacetime.operators_+3A_gamma">gamma</code></td>
<td>
<p>Temporal range parameter.</p>
</td></tr>
<tr><td><code id="spacetime.operators_+3A_rho">rho</code></td>
<td>
<p>Drift parameter. Real number on metric graphs and
one-dimensional spatial domains, a vector with two number on 2d domains.</p>
</td></tr>
<tr><td><code id="spacetime.operators_+3A_alpha">alpha</code></td>
<td>
<p>Integer smoothness parameter alpha.</p>
</td></tr>
<tr><td><code id="spacetime.operators_+3A_beta">beta</code></td>
<td>
<p>Integer smoothness parameter beta.</p>
</td></tr>
<tr><td><code id="spacetime.operators_+3A_bounded_rho">bounded_rho</code></td>
<td>
<p>Logical. Specifies whether <code>rho</code> should be bounded to ensure the existence, uniqueness, and well-posedness of the solution. Defaults to <code>TRUE</code>.
Note that this bounding is not a strict condition; there may exist values of rho beyond the upper bound that still satisfy these properties.
When <code>bounded_rho = TRUE</code>, the <code>rspde_lme</code> models enforce bounded <code>rho</code> for consistency.
If the estimated value of <code>rho</code> approaches the upper bound too closely, we recommend refitting the model with <code>bounded_rho = FALSE</code>. However, this should be done with caution, as it may lead to instability in some cases, though it can also result in a better model fit.
The actual bound used for <code>rho</code> can be accessed from the <code>bound_rho</code> element of the returned object.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of type spacetimeobj.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>s &lt;- seq(from = 0, to = 20, length.out = 101)
t &lt;- seq(from = 0, to = 20, length.out = 31)

op_cov &lt;- spacetime.operators(space_loc = s, time_loc = t,
                             kappa = 5, sigma = 10, alpha = 1,
                             beta = 2, rho = 1, gamma = 0.05)
Q &lt;- op_cov$Q
v &lt;- rep(0,dim(Q)[1])
v[1565] &lt;- 1
Sigma &lt;- solve(Q,v)

image(matrix(Sigma, nrow=length(s), ncol = length(t)))
</code></pre>

<hr>
<h2 id='spde.make.A'>Observation/prediction matrices for rSPDE models with integer smoothness.</h2><span id='topic+spde.make.A'></span>

<h3>Description</h3>

<p>Constructs observation/prediction weight matrices
for rSPDE models with integer smoothness based on <code>inla.mesh</code> or
<code>inla.mesh.1d</code> objects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>spde.make.A(
  mesh = NULL,
  loc = NULL,
  A = NULL,
  index = NULL,
  group = NULL,
  repl = 1L,
  n.group = NULL,
  n.repl = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="spde.make.A_+3A_mesh">mesh</code></td>
<td>
<p>An <code>inla.mesh</code>,
an <code>inla.mesh.1d</code> object or a <code>metric_graph</code> object.</p>
</td></tr>
<tr><td><code id="spde.make.A_+3A_loc">loc</code></td>
<td>
<p>Locations, needed if an INLA mesh is provided</p>
</td></tr>
<tr><td><code id="spde.make.A_+3A_a">A</code></td>
<td>
<p>The A matrix from the standard SPDE approach, such as the matrix
returned by <code>inla.spde.make.A</code>. Should only be provided if
<code>mesh</code> is not provided.</p>
</td></tr>
<tr><td><code id="spde.make.A_+3A_index">index</code></td>
<td>
<p>For each observation/prediction value, an index into loc. Default is seq_len(nrow(A.loc)).</p>
</td></tr>
<tr><td><code id="spde.make.A_+3A_group">group</code></td>
<td>
<p>For each observation/prediction value, an index into
the group model.</p>
</td></tr>
<tr><td><code id="spde.make.A_+3A_repl">repl</code></td>
<td>
<p>For each observation/prediction value, the replicate index.</p>
</td></tr>
<tr><td><code id="spde.make.A_+3A_n.group">n.group</code></td>
<td>
<p>The size of the group model.</p>
</td></tr>
<tr><td><code id="spde.make.A_+3A_n.repl">n.repl</code></td>
<td>
<p>The total number of replicates.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The <code class="reqn">A</code> matrix for rSPDE models.
</p>


<h3>Examples</h3>

<pre><code class='language-R'> #tryCatch version
tryCatch({
if (requireNamespace("fmesher", quietly = TRUE)) {
  library(fmesher)

  set.seed(123)
  loc &lt;- matrix(runif(100 * 2) * 100, 100, 2)
  mesh &lt;- fm_mesh_2d(
    loc = loc,
    cutoff = 50,
    max.edge = c(50, 500)
  )
  A &lt;- spde.make.A(mesh, loc = loc)
}
#stable.tryCatch
}, error = function(e){print("Could not run the example")})

</code></pre>

<hr>
<h2 id='spde.matern.loglike'>Parameter-based log-likelihood for a latent Gaussian Matern SPDE model
using a rational SPDE approximation</h2><span id='topic+spde.matern.loglike'></span>

<h3>Description</h3>

<p>This function evaluates the log-likelihood function for observations
of a Gaussian process defined as the solution to the SPDE
</p>
<p style="text-align: center;"><code class="reqn">(\kappa(s) - \Delta)^\beta (\tau(s)u(s)) = W.</code>
</p>



<h3>Usage</h3>

<pre><code class='language-R'>spde.matern.loglike(
  object,
  Y,
  A,
  sigma.e,
  mu = 0,
  nu = NULL,
  kappa = NULL,
  tau = NULL,
  theta = NULL,
  m = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="spde.matern.loglike_+3A_object">object</code></td>
<td>
<p>The rational SPDE approximation,
computed using <code><a href="#topic+spde.matern.operators">spde.matern.operators()</a></code></p>
</td></tr>
<tr><td><code id="spde.matern.loglike_+3A_y">Y</code></td>
<td>
<p>The observations, either a vector or a matrix where
the columns correspond to independent replicates of observations.</p>
</td></tr>
<tr><td><code id="spde.matern.loglike_+3A_a">A</code></td>
<td>
<p>An observation matrix that links the measurement location to the
finite element basis.</p>
</td></tr>
<tr><td><code id="spde.matern.loglike_+3A_sigma.e">sigma.e</code></td>
<td>
<p>IF non-null, the standard deviation of the measurement noise will be kept fixed in
the returned likelihood.</p>
</td></tr>
<tr><td><code id="spde.matern.loglike_+3A_mu">mu</code></td>
<td>
<p>Expectation vector of the latent field (default = 0).</p>
</td></tr>
<tr><td><code id="spde.matern.loglike_+3A_nu">nu</code></td>
<td>
<p>If non-null, the shape parameter will be kept fixed in the returned likelihood.</p>
</td></tr>
<tr><td><code id="spde.matern.loglike_+3A_kappa">kappa</code></td>
<td>
<p>If non-null, updates the range parameter.</p>
</td></tr>
<tr><td><code id="spde.matern.loglike_+3A_tau">tau</code></td>
<td>
<p>If non-null, updates the parameter tau.</p>
</td></tr>
<tr><td><code id="spde.matern.loglike_+3A_theta">theta</code></td>
<td>
<p>If non-null, updates the parameter theta (that connects tau and kappa to the model matrices in <code>object</code>).</p>
</td></tr>
<tr><td><code id="spde.matern.loglike_+3A_m">m</code></td>
<td>
<p>If non-null, update the order of the rational approximation,
which needs to be a positive integer.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The observations are assumed to be generated as
<code class="reqn">Y_i = u(s_i) + \epsilon_i</code>, where
<code class="reqn">\epsilon_i</code> are
iid mean-zero Gaussian variables. The latent model is approximated using a
rational approximation of the fractional SPDE model.
</p>


<h3>Value</h3>

<p>The log-likelihood value.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+rSPDE.loglike">rSPDE.loglike()</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># this example illustrates how the function can be used for maximum
# likelihood estimation
# Sample a Gaussian Matern process on R using a rational approximation
sigma.e &lt;- 0.1
n.rep &lt;- 10
n.obs &lt;- 100
n.x &lt;- 51
# create mass and stiffness matrices for a FEM discretization
x &lt;- seq(from = 0, to = 1, length.out = n.x)
fem &lt;- rSPDE.fem1d(x)
tau &lt;- rep(0.5, n.x)
nu &lt;- 0.8
alpha &lt;- nu + 1 / 2
kappa &lt;- rep(1, n.x)
# compute rational approximation
op &lt;- spde.matern.operators(
  kappa = kappa, tau = tau, alpha = alpha,
  parameterization = "spde", d = 1,
  loc_mesh = x
)
# Sample the model
u &lt;- simulate(op, n.rep)
# Create some data
obs.loc &lt;- runif(n = n.obs, min = 0, max = 1)
A &lt;- rSPDE.A1d(x, obs.loc)
noise &lt;- rnorm(n.obs * n.rep)
dim(noise) &lt;- c(n.obs, n.rep)
Y &lt;- as.matrix(A %*% u + sigma.e * noise)
# define negative likelihood function for optimization using matern.loglike
mlik &lt;- function(theta) {
  return(-spde.matern.loglike(op, Y, A,
    sigma.e = exp(theta[4]),
    nu = exp(theta[3]),
    kappa = exp(theta[2]),
    tau = exp(theta[1])
  ))
}
#' #The parameters can now be estimated by minimizing mlik with optim

# Choose some reasonable starting values depending on the size of the domain
theta0 &lt;- log(c(1 / sqrt(var(c(Y))), sqrt(8), 0.9, 0.01))
# run estimation and display the results
theta &lt;- optim(theta0, mlik)
print(data.frame(
  tau = c(tau[1], exp(theta$par[1])), kappa = c(kappa[1], exp(theta$par[2])),
  nu = c(nu, exp(theta$par[3])), sigma.e = c(sigma.e, exp(theta$par[4])),
  row.names = c("Truth", "Estimates")
))

</code></pre>

<hr>
<h2 id='spde.matern.operators'>Rational approximations of non-stationary Gaussian SPDE Matern random fields</h2><span id='topic+spde.matern.operators'></span>

<h3>Description</h3>

<p><code>spde.matern.operators</code> is used for computing a rational SPDE
approximation of a Gaussian random
fields on <code class="reqn">R^d</code> defined as a solution to the SPDE
</p>
<p style="text-align: center;"><code class="reqn">(\kappa(s) - \Delta)^\beta (\tau(s)u(s)) = W.</code>
</p>



<h3>Usage</h3>

<pre><code class='language-R'>spde.matern.operators(
  kappa = NULL,
  tau = NULL,
  theta = NULL,
  B.tau = matrix(c(0, 1, 0), 1, 3),
  B.kappa = matrix(c(0, 0, 1), 1, 3),
  B.sigma = matrix(c(0, 1, 0), 1, 3),
  B.range = matrix(c(0, 0, 1), 1, 3),
  alpha = NULL,
  nu = NULL,
  parameterization = c("spde", "matern"),
  G = NULL,
  C = NULL,
  d = NULL,
  graph = NULL,
  mesh = NULL,
  range_mesh = NULL,
  loc_mesh = NULL,
  m = 1,
  type = c("covariance", "operator"),
  type_rational_approximation = c("chebfun", "brasil", "chebfunLB")
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="spde.matern.operators_+3A_kappa">kappa</code></td>
<td>
<p>Vector with the, possibly spatially varying, range parameter
evaluated at the locations of the mesh used for the finite element
discretization of the SPDE.</p>
</td></tr>
<tr><td><code id="spde.matern.operators_+3A_tau">tau</code></td>
<td>
<p>Vector with the, possibly spatially varying, precision
parameter evaluated at the locations
of the mesh used for the finite element discretization of the SPDE.</p>
</td></tr>
<tr><td><code id="spde.matern.operators_+3A_theta">theta</code></td>
<td>
<p>Theta parameter that connects B.tau and B.kappa to tau and kappa through a log-linear regression, in case the parameterization is <code>spde</code>,
and that connects B.sigma and B.range to tau and kappa in case the parameterization is <code>matern</code>.</p>
</td></tr>
<tr><td><code id="spde.matern.operators_+3A_b.tau">B.tau</code></td>
<td>
<p>Matrix with specification of log-linear model for <code class="reqn">\tau</code>. Will be used if <code>parameterization = 'spde'</code>.</p>
</td></tr>
<tr><td><code id="spde.matern.operators_+3A_b.kappa">B.kappa</code></td>
<td>
<p>Matrix with specification of log-linear model for <code class="reqn">\kappa</code>. Will be used if <code>parameterization = 'spde'</code>.</p>
</td></tr>
<tr><td><code id="spde.matern.operators_+3A_b.sigma">B.sigma</code></td>
<td>
<p>Matrix with specification of log-linear model for <code class="reqn">\sigma</code>. Will be used if <code>parameterization = 'matern'</code>.</p>
</td></tr>
<tr><td><code id="spde.matern.operators_+3A_b.range">B.range</code></td>
<td>
<p>Matrix with specification of log-linear model for <code class="reqn">\rho</code>, which is a range-like parameter (it is exactly the range parameter in the stationary case). Will be used if <code>parameterization = 'matern'</code>.</p>
</td></tr>
<tr><td><code id="spde.matern.operators_+3A_alpha">alpha</code></td>
<td>
<p>smoothness parameter. Will be used if the parameterization is 'spde'.</p>
</td></tr>
<tr><td><code id="spde.matern.operators_+3A_nu">nu</code></td>
<td>
<p>Shape parameter of the covariance function. Will be used if the parameterization is 'matern'.</p>
</td></tr>
<tr><td><code id="spde.matern.operators_+3A_parameterization">parameterization</code></td>
<td>
<p>Which parameterization to use? <code>matern</code> uses range, std. deviation and nu (smoothness). <code>spde</code> uses kappa, tau and nu (smoothness). The default is <code>matern</code>.</p>
</td></tr>
<tr><td><code id="spde.matern.operators_+3A_g">G</code></td>
<td>
<p>The stiffness matrix of a finite element discretization of
the domain of interest.</p>
</td></tr>
<tr><td><code id="spde.matern.operators_+3A_c">C</code></td>
<td>
<p>The mass matrix of a finite element discretization of the
domain of interest.</p>
</td></tr>
<tr><td><code id="spde.matern.operators_+3A_d">d</code></td>
<td>
<p>The dimension of the domain. Does not need to be given if
<code>mesh</code> is used.</p>
</td></tr>
<tr><td><code id="spde.matern.operators_+3A_graph">graph</code></td>
<td>
<p>An optional <code>metric_graph</code> object. Replaces <code>d</code>, <code>C</code> and <code>G</code>.</p>
</td></tr>
<tr><td><code id="spde.matern.operators_+3A_mesh">mesh</code></td>
<td>
<p>An optional inla mesh. <code>d</code>, <code>C</code> and <code>G</code>
must be given if <code>mesh</code> is not given.</p>
</td></tr>
<tr><td><code id="spde.matern.operators_+3A_range_mesh">range_mesh</code></td>
<td>
<p>The range of the mesh. Will be used to provide starting values for the parameters. Will be used if <code>mesh</code> and <code>graph</code> are <code>NULL</code>, and if one of the parameters (kappa or tau for spde parameterization, or sigma or range for matern parameterization) are not provided.</p>
</td></tr>
<tr><td><code id="spde.matern.operators_+3A_loc_mesh">loc_mesh</code></td>
<td>
<p>The mesh locations used to construct the matrices C and G. This option should be provided if one wants to use the <code>rspde_lme()</code> function and will not provide neither graph nor mesh. Only works for 1d data. Does not work for metric graphs. For metric graphs you should supply the graph using the <code>graph</code> argument.</p>
</td></tr>
<tr><td><code id="spde.matern.operators_+3A_m">m</code></td>
<td>
<p>The order of the rational approximation, which needs to be a
positive integer. The default value is 1.</p>
</td></tr>
<tr><td><code id="spde.matern.operators_+3A_type">type</code></td>
<td>
<p>The type of the rational approximation. The options are
&quot;covariance&quot; and &quot;operator&quot;. The default is &quot;covariance&quot;.</p>
</td></tr>
<tr><td><code id="spde.matern.operators_+3A_type_rational_approximation">type_rational_approximation</code></td>
<td>
<p>Which type of rational
approximation should be used? The current types are
&quot;chebfun&quot;, &quot;brasil&quot; or &quot;chebfunLB&quot;.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The approximation is based on a rational approximation of the
fractional operator <code class="reqn">(\kappa(s)^2 -\Delta)^\beta</code>, where
<code class="reqn">\beta = (\nu + d/2)/2</code>. This results in an approximate model
on the form </p>
<p style="text-align: center;"><code class="reqn">P_l u(s) = P_r W,</code>
</p>
<p> where <code class="reqn">P_j = p_j(L)</code> are
non-fractional operators defined in terms of polynomials <code class="reqn">p_j</code> for
<code class="reqn">j=l,r</code>. The order of <code class="reqn">p_r</code> is given by <code>m</code> and the order
of <code class="reqn">p_l</code> is <code class="reqn">m + m_\beta</code> where <code class="reqn">m_\beta</code> is the integer
part of <code class="reqn">\beta</code> if <code class="reqn">\beta&gt;1</code> and <code class="reqn">m_\beta = 1</code> otherwise.
</p>
<p>The discrete approximation can be written as <code class="reqn">u = P_r x</code> where
<code class="reqn">x \sim N(0,Q^{-1})</code>
and <code class="reqn">Q = P_l^T C^{-1} P_l</code>. Note that the matrices <code class="reqn">P_r</code> and
<code class="reqn">Q</code> may be be ill-conditioned for <code class="reqn">m&gt;1</code>.
In this case, the metehods in <code><a href="#topic+operator.operations">operator.operations()</a></code>
should be used for operations involving the matrices, since
these methods are more numerically stable.
</p>


<h3>Value</h3>

<p><code>spde.matern.operators</code> returns an object of
class &quot;rSPDEobj. This object contains the
quantities listed in the output of <code><a href="#topic+fractional.operators">fractional.operators()</a></code>
as well as the smoothness parameter <code class="reqn">\nu</code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+fractional.operators">fractional.operators()</a></code>,
<code><a href="#topic+spde.matern.operators">spde.matern.operators()</a></code>,
<code><a href="#topic+matern.operators">matern.operators()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Sample non-stationary Matern field on R
tau &lt;- 1
nu &lt;- 0.8

# create mass and stiffness matrices for a FEM discretization
x &lt;- seq(from = 0, to = 1, length.out = 101)
fem &lt;- rSPDE.fem1d(x)

# define a non-stationary range parameter
kappa &lt;- seq(from = 2, to = 20, length.out = length(x))
alpha &lt;- nu + 1 / 2
# compute rational approximation
op &lt;- spde.matern.operators(
  kappa = kappa, tau = tau, alpha = alpha,
  G = fem$G, C = fem$C, d = 1
)

# sample the field
u &lt;- simulate(op)

# plot the sample
plot(x, u, type = "l", ylab = "u(s)", xlab = "s")

</code></pre>

<hr>
<h2 id='summary.CBrSPDEobj'>Summarise CBrSPDE objects</h2><span id='topic+summary.CBrSPDEobj'></span><span id='topic+print.summary.CBrSPDEobj'></span><span id='topic+print.CBrSPDEobj'></span>

<h3>Description</h3>

<p>Summary method for class &quot;CBrSPDEobj&quot;
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'CBrSPDEobj'
summary(object, ...)

## S3 method for class 'summary.CBrSPDEobj'
print(x, ...)

## S3 method for class 'CBrSPDEobj'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="summary.CBrSPDEobj_+3A_object">object</code></td>
<td>
<p>an object of class &quot;CBrSPDEobj&quot;, usually, a result of a call
to <code><a href="#topic+matern.operators">matern.operators()</a></code>.</p>
</td></tr>
<tr><td><code id="summary.CBrSPDEobj_+3A_...">...</code></td>
<td>
<p>further arguments passed to or from other methods.</p>
</td></tr>
<tr><td><code id="summary.CBrSPDEobj_+3A_x">x</code></td>
<td>
<p>an object of class &quot;summary.CBrSPDEobj&quot;, usually, a result of a call
to <code><a href="#topic+summary.CBrSPDEobj">summary.CBrSPDEobj()</a></code>.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'># Compute the covariance-based rational approximation of a
# Gaussian process with a Matern covariance function on R
kappa &lt;- 10
sigma &lt;- 1
nu &lt;- 0.8
range &lt;- sqrt(8 * nu) / kappa

# create mass and stiffness matrices for a FEM discretization
x &lt;- seq(from = 0, to = 1, length.out = 101)
fem &lt;- rSPDE.fem1d(x)

# compute rational approximation of covariance function at 0.5
tau &lt;- sqrt(gamma(nu) / (sigma^2 * kappa^(2 * nu) *
  (4 * pi)^(1 / 2) * gamma(nu + 1 / 2)))
op_cov &lt;- matern.operators(
  loc_mesh = x, nu = nu,
  range = range, sigma = sigma, d = 1, m = 2,
  parameterization = "matern"
)

op_cov
</code></pre>

<hr>
<h2 id='summary.CBrSPDEobj2d'>Summarise CBrSPDEobj2d objects</h2><span id='topic+summary.CBrSPDEobj2d'></span><span id='topic+print.summary.CBrSPDEobj2d'></span><span id='topic+print.CBrSPDEobj2d'></span>

<h3>Description</h3>

<p>Summary method for class &quot;CBrSPDEobj2d&quot;
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'CBrSPDEobj2d'
summary(object, ...)

## S3 method for class 'summary.CBrSPDEobj2d'
print(x, ...)

## S3 method for class 'CBrSPDEobj2d'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="summary.CBrSPDEobj2d_+3A_object">object</code></td>
<td>
<p>an object of class &quot;CBrSPDEobj2d&quot;, usually, a result of a call
to <code><a href="#topic+matern2d.operators">matern2d.operators()</a></code>.</p>
</td></tr>
<tr><td><code id="summary.CBrSPDEobj2d_+3A_...">...</code></td>
<td>
<p>further arguments passed to or from other methods.</p>
</td></tr>
<tr><td><code id="summary.CBrSPDEobj2d_+3A_x">x</code></td>
<td>
<p>an object of class &quot;summary.CBrSPDEobj2d&quot;, usually, a result of a call
to <code><a href="#topic+summary.CBrSPDEobj2d">summary.CBrSPDEobj2d()</a></code>.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>library(fmesher)
n_loc &lt;- 2000
loc_2d_mesh &lt;- matrix(runif(n_loc * 2), n_loc, 2)
mesh_2d &lt;- fm_mesh_2d(loc = loc_2d_mesh, cutoff = 0.03, max.edge = c(0.1, 0.5))
op &lt;- matern2d.operators(mesh = mesh_2d)
op
</code></pre>

<hr>
<h2 id='summary.rspde_lme'>Summary Method for <code>rspde_lme</code> Objects.</h2><span id='topic+summary.rspde_lme'></span>

<h3>Description</h3>

<p>Function providing a summary of results related to mixed effects regression models with Whittle-Matern latent models.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'rspde_lme'
summary(object, all_times = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="summary.rspde_lme_+3A_object">object</code></td>
<td>
<p>an object of class &quot;rspde_lme&quot; containing results from the fitted model.</p>
</td></tr>
<tr><td><code id="summary.rspde_lme_+3A_all_times">all_times</code></td>
<td>
<p>Show all computed times.</p>
</td></tr>
<tr><td><code id="summary.rspde_lme_+3A_...">...</code></td>
<td>
<p>not used.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <code>summary_rspde_lme</code> containing several
informations of a <em>rspde_lme</em> object.
</p>

<hr>
<h2 id='summary.rspde_result'>Summary for posteriors of field parameters for an <code>inla_rspde</code>
model from a <code>rspde_result</code> object</h2><span id='topic+summary.rspde_result'></span>

<h3>Description</h3>

<p>Summary for posteriors of rSPDE field parameters in
their original scales.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'rspde_result'
summary(object, digits = 6, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="summary.rspde_result_+3A_object">object</code></td>
<td>
<p>A <code>rspde_result</code> object.</p>
</td></tr>
<tr><td><code id="summary.rspde_result_+3A_digits">digits</code></td>
<td>
<p>integer, used for number formatting with signif()</p>
</td></tr>
<tr><td><code id="summary.rspde_result_+3A_...">...</code></td>
<td>
<p>Currently not used.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a <code>data.frame</code>
containing the summary.
</p>


<h3>Examples</h3>

<pre><code class='language-R'> #tryCatch version
tryCatch({
if (requireNamespace("INLA", quietly = TRUE)) {
  library(INLA)

  set.seed(123)

  m &lt;- 100
  loc_2d_mesh &lt;- matrix(runif(m * 2), m, 2)
  mesh_2d &lt;- inla.mesh.2d(
    loc = loc_2d_mesh,
    cutoff = 0.05,
    max.edge = c(0.1, 0.5)
  )
  sigma &lt;- 1
  range &lt;- 0.2
  nu &lt;- 0.8
  kappa &lt;- sqrt(8 * nu) / range
  op &lt;- matern.operators(
    mesh = mesh_2d, nu = nu,
    range = range, sigma = sigma, m = 2,
    parameterization = "matern"
  )
  u &lt;- simulate(op)
  A &lt;- inla.spde.make.A(
    mesh = mesh_2d,
    loc = loc_2d_mesh
  )
  sigma.e &lt;- 0.1
  y &lt;- A %*% u + rnorm(m) * sigma.e
  Abar &lt;- rspde.make.A(mesh = mesh_2d, loc = loc_2d_mesh)
  mesh.index &lt;- rspde.make.index(name = "field", mesh = mesh_2d)
  st.dat &lt;- inla.stack(
    data = list(y = as.vector(y)),
    A = Abar,
    effects = mesh.index
  )
  rspde_model &lt;- rspde.matern(
    mesh = mesh_2d,
    nu.upper.bound = 2
  )
  f &lt;- y ~ -1 + f(field, model = rspde_model)
  rspde_fit &lt;- inla(f,
    data = inla.stack.data(st.dat),
    family = "gaussian",
    control.predictor =
      list(A = inla.stack.A(st.dat))
  )
  result &lt;- rspde.result(rspde_fit, "field", rspde_model)
  summary(result)
}
#stable.tryCatch
}, error = function(e){print("Could not run the example")})


</code></pre>

<hr>
<h2 id='summary.rSPDEobj'>Summarise rSPDE objects</h2><span id='topic+summary.rSPDEobj'></span><span id='topic+print.summary.rSPDEobj'></span><span id='topic+print.rSPDEobj'></span>

<h3>Description</h3>

<p>Summary method for class &quot;rSPDEobj&quot;
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'rSPDEobj'
summary(object, ...)

## S3 method for class 'summary.rSPDEobj'
print(x, ...)

## S3 method for class 'rSPDEobj'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="summary.rSPDEobj_+3A_object">object</code></td>
<td>
<p>an object of class &quot;rSPDEobj&quot;, usually, a result of a call
to <code><a href="#topic+fractional.operators">fractional.operators()</a></code>, <code><a href="#topic+matern.operators">matern.operators()</a></code>, or
<code><a href="#topic+spde.matern.operators">spde.matern.operators()</a></code>.</p>
</td></tr>
<tr><td><code id="summary.rSPDEobj_+3A_...">...</code></td>
<td>
<p>further arguments passed to or from other methods.</p>
</td></tr>
<tr><td><code id="summary.rSPDEobj_+3A_x">x</code></td>
<td>
<p>an object of class &quot;summary.rSPDEobj&quot;, usually, a result of a call
to <code><a href="#topic+summary.rSPDEobj">summary.rSPDEobj()</a></code>.</p>
</td></tr>
</table>

<hr>
<h2 id='summary.rSPDEobj1d'>Summarise rSPDE objects without FEM</h2><span id='topic+summary.rSPDEobj1d'></span><span id='topic+print.summary.rSPDEobj1d'></span><span id='topic+print.rSPDEobj1d'></span>

<h3>Description</h3>

<p>Summary method for class &quot;rSPDEobj1d&quot;
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'rSPDEobj1d'
summary(object, ...)

## S3 method for class 'summary.rSPDEobj1d'
print(x, ...)

## S3 method for class 'rSPDEobj1d'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="summary.rSPDEobj1d_+3A_object">object</code></td>
<td>
<p>an object of class &quot;rSPDEobj1d&quot;, usually, a result of a call
to <code><a href="#topic+matern.rational">matern.rational()</a></code>.</p>
</td></tr>
<tr><td><code id="summary.rSPDEobj1d_+3A_...">...</code></td>
<td>
<p>further arguments passed to or from other methods.</p>
</td></tr>
<tr><td><code id="summary.rSPDEobj1d_+3A_x">x</code></td>
<td>
<p>an object of class &quot;summary.rSPDEobj1d&quot;, usually, a result of a call
to <code><a href="#topic+summary.rSPDEobj1d">summary.rSPDEobj1d()</a></code>.</p>
</td></tr>
</table>

<hr>
<h2 id='summary.spacetimeobj'>Summarise spacetime objects</h2><span id='topic+summary.spacetimeobj'></span><span id='topic+print.summary.spacetimeobj'></span><span id='topic+print.spacetimeobj'></span>

<h3>Description</h3>

<p>Summary method for class &quot;spacetimeobj&quot;
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'spacetimeobj'
summary(object, ...)

## S3 method for class 'summary.spacetimeobj'
print(x, ...)

## S3 method for class 'spacetimeobj'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="summary.spacetimeobj_+3A_object">object</code></td>
<td>
<p>an object of class &quot;spacetimeobj&quot;, usually, a result of a call
to <code><a href="#topic+spacetime.operators">spacetime.operators()</a></code>.</p>
</td></tr>
<tr><td><code id="summary.spacetimeobj_+3A_...">...</code></td>
<td>
<p>further arguments passed to or from other methods.</p>
</td></tr>
<tr><td><code id="summary.spacetimeobj_+3A_x">x</code></td>
<td>
<p>an object of class &quot;summary.spacetimeobj&quot;, usually, a result of a call
to <code><a href="#topic+summary.spacetimeobj">summary.spacetimeobj()</a></code>.</p>
</td></tr>
</table>

<hr>
<h2 id='transform_parameters_anisotropic'>Transform Anisotropic SPDE Model Parameters to Original Scale</h2><span id='topic+transform_parameters_anisotropic'></span>

<h3>Description</h3>

<p>This function takes a vector of transformed parameters and applies the appropriate
transformations to return them in the original scale for use in anisotropic SPDE models.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>transform_parameters_anisotropic(theta, nu_upper_bound = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="transform_parameters_anisotropic_+3A_theta">theta</code></td>
<td>
<p>A numeric vector of length 4 or 5, containing the transformed parameters in this order:
</p>

<dl>
<dt>lhx</dt><dd><p>The logarithmic representation of hx.</p>
</dd>
<dt>lhy</dt><dd><p>The logarithmic representation of hy.</p>
</dd>
<dt>logit_hxy</dt><dd><p>The logit-transformed representation of hxy.</p>
</dd>
<dt>lsigma</dt><dd><p>The logarithmic representation of sigma.</p>
</dd>
<dt>lnu (optional)</dt><dd><p>The logarithmic representation of nu. If not provided, nu is not returned.</p>
</dd>
</dl>
</td></tr>
<tr><td><code id="transform_parameters_anisotropic_+3A_nu_upper_bound">nu_upper_bound</code></td>
<td>
<p>(optional) A numeric value representing the upper bound for the smoothness parameter nu.
This is only used, and must be provided, if <code>lnu</code> is provided.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A named list with the parameters in the original scale:
</p>

<dl>
<dt>hx</dt><dd><p>The original scale for hx (exponential of lhx).</p>
</dd>
<dt>hy</dt><dd><p>The original scale for hy (exponential of lhy).</p>
</dd>
<dt>hxy</dt><dd><p>The original scale for hxy (inverse logit transformation of logit_hxy).</p>
</dd>
<dt>sigma</dt><dd><p>The original scale for sigma (exponential of lsigma).</p>
</dd>
<dt>nu (optional)</dt><dd><p>The original scale for nu (using the forward_nu transformation). Only included if <code>lnu</code> is provided.</p>
</dd>
</dl>



<h3>Examples</h3>

<pre><code class='language-R'># With lnu
theta &lt;- c(log(0.1), log(0.2), log((0.3 + 1) / (1 - 0.3)), log(0.5), log(1))
nu_upper_bound &lt;- 2
transform_parameters_anisotropic(theta, nu_upper_bound)

# Without lnu
theta &lt;- c(log(0.1), log(0.2), log((0.3 + 1) / (1 - 0.3)), log(0.5))
transform_parameters_anisotropic(theta)
</code></pre>

<hr>
<h2 id='transform_parameters_spacetime'>Transform Spacetime SPDE Model Parameters to Original Scale</h2><span id='topic+transform_parameters_spacetime'></span>

<h3>Description</h3>

<p>This function takes a vector of transformed parameters and applies the appropriate
transformations to return them in the original scale for use in spacetime SPDE models.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>transform_parameters_spacetime(theta, st_model)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="transform_parameters_spacetime_+3A_theta">theta</code></td>
<td>
<p>A numeric vector containing the transformed parameters in this order:
</p>

<dl>
<dt>lkappa</dt><dd><p>The logarithmic representation of kappa.</p>
</dd>
<dt>lsigma</dt><dd><p>The logarithmic representation of sigma.</p>
</dd>
<dt>lgamma</dt><dd><p>The logarithmic representation of gamma.</p>
</dd>
<dt>logit_rho (optional)</dt><dd><p>The logit-transformed representation of rho, if drift = 1.</p>
</dd>
<dt>logit_rho2 (optional)</dt><dd><p>The logit-transformed representation of rho2, if drift = 1 and d = 2.</p>
</dd>
</dl>
</td></tr>
<tr><td><code id="transform_parameters_spacetime_+3A_st_model">st_model</code></td>
<td>
<p>A list containing the spacetime model parameters:
</p>

<dl>
<dt>d</dt><dd><p>The dimension (e.g., 1 or 2).</p>
</dd>
<dt>bound</dt><dd><p>The bound for rho and rho2.</p>
</dd>
<dt>is_bounded</dt><dd><p>A logical value indicating if rho and rho2 are bounded.</p>
</dd>
<dt>drift</dt><dd><p>A logical value indicating if drift is included in the model.</p>
</dd>
</dl>
</td></tr>
</table>


<h3>Value</h3>

<p>A named list with the parameters in the original scale:
</p>

<dl>
<dt>kappa</dt><dd><p>The original scale for kappa (exponential of lkappa).</p>
</dd>
<dt>sigma</dt><dd><p>The original scale for sigma (exponential of lsigma).</p>
</dd>
<dt>gamma</dt><dd><p>The original scale for gamma (exponential of lgamma).</p>
</dd>
<dt>rho (optional)</dt><dd><p>The original scale for rho.</p>
</dd>
<dt>rho2 (optional)</dt><dd><p>The original scale for rho2, if d = 2.</p>
</dd>
</dl>


<hr>
<h2 id='update.CBrSPDEobj'>Update parameters of CBrSPDEobj objects</h2><span id='topic+update.CBrSPDEobj'></span>

<h3>Description</h3>

<p>Function to change the parameters of a CBrSPDEobj object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'CBrSPDEobj'
update(
  object,
  nu = NULL,
  alpha = NULL,
  kappa = NULL,
  tau = NULL,
  sigma = NULL,
  range = NULL,
  theta = NULL,
  m = NULL,
  mesh = NULL,
  loc_mesh = NULL,
  graph = NULL,
  range_mesh = NULL,
  compute_higher_order = object$higher_order,
  parameterization = NULL,
  type_rational_approximation = object$type_rational_approximation,
  return_block_list = object$return_block_list,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="update.CBrSPDEobj_+3A_object">object</code></td>
<td>
<p>The covariance-based rational SPDE approximation,
computed using <code><a href="#topic+matern.operators">matern.operators()</a></code></p>
</td></tr>
<tr><td><code id="update.CBrSPDEobj_+3A_nu">nu</code></td>
<td>
<p>If non-null, update the shape parameter of the
covariance function. Will be used if parameterization is 'matern'.</p>
</td></tr>
<tr><td><code id="update.CBrSPDEobj_+3A_alpha">alpha</code></td>
<td>
<p>If non-null, update the fractional SPDE order parameter. Will be used if parameterization is 'spde'.</p>
</td></tr>
<tr><td><code id="update.CBrSPDEobj_+3A_kappa">kappa</code></td>
<td>
<p>If non-null, update the parameter kappa of the SPDE. Will be used if parameterization is 'spde'.</p>
</td></tr>
<tr><td><code id="update.CBrSPDEobj_+3A_tau">tau</code></td>
<td>
<p>If non-null, update the parameter tau of the SPDE. Will be used if parameterization is 'spde'.</p>
</td></tr>
<tr><td><code id="update.CBrSPDEobj_+3A_sigma">sigma</code></td>
<td>
<p>If non-null, update the standard deviation of
the covariance function. Will be used if parameterization is 'matern'.</p>
</td></tr>
<tr><td><code id="update.CBrSPDEobj_+3A_range">range</code></td>
<td>
<p>If non-null, update the range parameter
of the covariance function. Will be used if parameterization is 'matern'.</p>
</td></tr>
<tr><td><code id="update.CBrSPDEobj_+3A_theta">theta</code></td>
<td>
<p>For non-stationary models. If non-null, update the vector of parameters.</p>
</td></tr>
<tr><td><code id="update.CBrSPDEobj_+3A_m">m</code></td>
<td>
<p>If non-null, update the order of the rational
approximation, which needs to be a positive integer.</p>
</td></tr>
<tr><td><code id="update.CBrSPDEobj_+3A_mesh">mesh</code></td>
<td>
<p>An optional inla mesh. Replaces <code>d</code>, <code>C</code> and <code>G</code>.</p>
</td></tr>
<tr><td><code id="update.CBrSPDEobj_+3A_loc_mesh">loc_mesh</code></td>
<td>
<p>The mesh locations used to construct the matrices C and G. This option should be provided if one wants to use the <code>rspde_lme()</code> function and will not provide neither graph nor mesh. Only works for 1d data. Does not work for metric graphs. For metric graphs you should supply the graph using the <code>graph</code> argument.</p>
</td></tr>
<tr><td><code id="update.CBrSPDEobj_+3A_graph">graph</code></td>
<td>
<p>An optional <code>metric_graph</code> object. Replaces <code>d</code>, <code>C</code> and <code>G</code>.</p>
</td></tr>
<tr><td><code id="update.CBrSPDEobj_+3A_range_mesh">range_mesh</code></td>
<td>
<p>The range of the mesh. Will be used to provide starting values for the parameters. Will be used if <code>mesh</code> and <code>graph</code> are <code>NULL</code>, and if one of the parameters (kappa or tau for spde parameterization, or sigma or range for matern parameterization) are not provided.</p>
</td></tr>
<tr><td><code id="update.CBrSPDEobj_+3A_compute_higher_order">compute_higher_order</code></td>
<td>
<p>Logical. Should the higher order
finite element matrices be computed?</p>
</td></tr>
<tr><td><code id="update.CBrSPDEobj_+3A_parameterization">parameterization</code></td>
<td>
<p>If non-null, update the parameterization. Only works for stationary models.</p>
</td></tr>
<tr><td><code id="update.CBrSPDEobj_+3A_type_rational_approximation">type_rational_approximation</code></td>
<td>
<p>Which type of rational
approximation should be used? The current types are &quot;chebfun&quot;,
&quot;brasil&quot; or &quot;chebfunLB&quot;.</p>
</td></tr>
<tr><td><code id="update.CBrSPDEobj_+3A_return_block_list">return_block_list</code></td>
<td>
<p>Logical. For <code>type = "covariance"</code>,
should the block parts of the precision matrix be returned
separately as a list?</p>
</td></tr>
<tr><td><code id="update.CBrSPDEobj_+3A_...">...</code></td>
<td>
<p>Currently not used.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>It returns an object of class &quot;CBrSPDEobj. This object contains the
same quantities listed in the output of <code><a href="#topic+matern.operators">matern.operators()</a></code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+simulate.CBrSPDEobj">simulate.CBrSPDEobj()</a></code>, <code><a href="#topic+matern.operators">matern.operators()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Compute the covariance-based rational approximation of a
# Gaussian process with a Matern covariance function on R
kappa &lt;- 10
sigma &lt;- 1
nu &lt;- 0.8
range &lt;- sqrt(8 * nu) / kappa

# create mass and stiffness matrices for a FEM discretization
x &lt;- seq(from = 0, to = 1, length.out = 101)
fem &lt;- rSPDE.fem1d(x)

# compute rational approximation of covariance function at 0.5
op_cov &lt;- matern.operators(
  loc_mesh = x, nu = nu,
  range = range, sigma = sigma, d = 1, m = 2,
  parameterization = "matern"
)
op_cov

# Update the range parameter of the model:
op_cov &lt;- update(op_cov, kappa = 20)
op_cov

</code></pre>

<hr>
<h2 id='update.CBrSPDEobj2d'>Update parameters of CBrSPDEobj2d objects</h2><span id='topic+update.CBrSPDEobj2d'></span>

<h3>Description</h3>

<p>Function to change the parameters of a CBrSPDEobj object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'CBrSPDEobj2d'
update(
  object,
  hx = NULL,
  hy = NULL,
  hxy = NULL,
  sigma = NULL,
  nu = NULL,
  m = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="update.CBrSPDEobj2d_+3A_object">object</code></td>
<td>
<p>The covariance-based rational SPDE approximation,
computed using <code><a href="#topic+matern2d.operators">matern2d.operators()</a></code></p>
</td></tr>
<tr><td><code id="update.CBrSPDEobj2d_+3A_hx">hx</code></td>
<td>
<p>If non-null, update the hx parameter.</p>
</td></tr>
<tr><td><code id="update.CBrSPDEobj2d_+3A_hy">hy</code></td>
<td>
<p>If non-null, update the hy parameter.</p>
</td></tr>
<tr><td><code id="update.CBrSPDEobj2d_+3A_hxy">hxy</code></td>
<td>
<p>If non-null, update the hxy parameter.</p>
</td></tr>
<tr><td><code id="update.CBrSPDEobj2d_+3A_sigma">sigma</code></td>
<td>
<p>If non-null, update the standard deviation of
the covariance function.</p>
</td></tr>
<tr><td><code id="update.CBrSPDEobj2d_+3A_nu">nu</code></td>
<td>
<p>If non-null, update the shape parameter of the
covariance function. Will be used if parameterization is 'matern'.</p>
</td></tr>
<tr><td><code id="update.CBrSPDEobj2d_+3A_m">m</code></td>
<td>
<p>If non-null, update the order of the rational
approximation, which needs to be a positive integer.</p>
</td></tr>
<tr><td><code id="update.CBrSPDEobj2d_+3A_...">...</code></td>
<td>
<p>Currently not used.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>It returns an object of class &quot;CBrSPDEobj2d.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+simulate.CBrSPDEobj2d">simulate.CBrSPDEobj2d()</a></code>, <code><a href="#topic+matern2d.operators">matern2d.operators()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(fmesher)
n_loc &lt;- 2000
loc_2d_mesh &lt;- matrix(runif(n_loc * 2), n_loc, 2)
mesh_2d &lt;- fm_mesh_2d(loc = loc_2d_mesh, cutoff = 0.03, max.edge = c(0.1, 0.5))
op &lt;- matern2d.operators(mesh = mesh_2d)
op &lt;- update(op, nu = 0.5)
</code></pre>

<hr>
<h2 id='update.rSPDEobj'>Update parameters of rSPDEobj objects</h2><span id='topic+update.rSPDEobj'></span>

<h3>Description</h3>

<p>Function to change the parameters of a rSPDEobj object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'rSPDEobj'
update(
  object,
  nu = NULL,
  alpha = NULL,
  kappa = NULL,
  sigma = NULL,
  range = NULL,
  tau = NULL,
  theta = NULL,
  m = NULL,
  mesh = NULL,
  loc_mesh = NULL,
  graph = NULL,
  range_mesh = NULL,
  parameterization = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="update.rSPDEobj_+3A_object">object</code></td>
<td>
<p>The operator-based rational SPDE approximation,
computed using <code><a href="#topic+matern.operators">matern.operators()</a></code> with <code>type="operator"</code></p>
</td></tr>
<tr><td><code id="update.rSPDEobj_+3A_nu">nu</code></td>
<td>
<p>If non-null, update the shape parameter
of the covariance function.</p>
</td></tr>
<tr><td><code id="update.rSPDEobj_+3A_alpha">alpha</code></td>
<td>
<p>If non-null, update the fractional order.</p>
</td></tr>
<tr><td><code id="update.rSPDEobj_+3A_kappa">kappa</code></td>
<td>
<p>If non-null, update the range parameter
of the covariance function.</p>
</td></tr>
<tr><td><code id="update.rSPDEobj_+3A_sigma">sigma</code></td>
<td>
<p>If non-null, update the standard deviation of
the covariance function.</p>
</td></tr>
<tr><td><code id="update.rSPDEobj_+3A_range">range</code></td>
<td>
<p>If non-null, update the range parameter
of the covariance function.</p>
</td></tr>
<tr><td><code id="update.rSPDEobj_+3A_tau">tau</code></td>
<td>
<p>If non-null, update the parameter tau.</p>
</td></tr>
<tr><td><code id="update.rSPDEobj_+3A_theta">theta</code></td>
<td>
<p>If non-null, update the parameter theta, that connects
tau and kappa to the model matrices.</p>
</td></tr>
<tr><td><code id="update.rSPDEobj_+3A_m">m</code></td>
<td>
<p>If non-null, update the order of the rational
approximation, which needs to be a positive integer.</p>
</td></tr>
<tr><td><code id="update.rSPDEobj_+3A_mesh">mesh</code></td>
<td>
<p>An optional inla mesh. Replaces <code>d</code>, <code>C</code> and <code>G</code>.</p>
</td></tr>
<tr><td><code id="update.rSPDEobj_+3A_loc_mesh">loc_mesh</code></td>
<td>
<p>The mesh locations used to construct the matrices C and G. This option should be provided if one wants to use the <code>rspde_lme()</code> function and will not provide neither graph nor mesh. Only works for 1d data. Does not work for metric graphs. For metric graphs you should supply the graph using the <code>graph</code> argument.</p>
</td></tr>
<tr><td><code id="update.rSPDEobj_+3A_graph">graph</code></td>
<td>
<p>An optional <code>metric_graph</code> object. Replaces <code>d</code>, <code>C</code> and <code>G</code>.</p>
</td></tr>
<tr><td><code id="update.rSPDEobj_+3A_range_mesh">range_mesh</code></td>
<td>
<p>The range of the mesh. Will be used to provide starting values for the parameters. Will be used if <code>mesh</code> and <code>graph</code> are <code>NULL</code>, and if one of the parameters (kappa or tau for spde parameterization, or sigma or range for matern parameterization) are not provided.</p>
</td></tr>
<tr><td><code id="update.rSPDEobj_+3A_parameterization">parameterization</code></td>
<td>
<p>If non-null, update the parameterization. Only works for stationary models.</p>
</td></tr>
<tr><td><code id="update.rSPDEobj_+3A_...">...</code></td>
<td>
<p>Currently not used.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>It returns an object of class &quot;rSPDEobj. This object contains the
same quantities listed in the output of <code><a href="#topic+matern.operators">matern.operators()</a></code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+simulate.rSPDEobj">simulate.rSPDEobj()</a></code>, <code><a href="#topic+matern.operators">matern.operators()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Compute the operator-based rational approximation of a
# Gaussian process with a Matern covariance function on R
kappa &lt;- 10
sigma &lt;- 1
nu &lt;- 0.8
range &lt;- sqrt(8 * nu) / kappa

# create mass and stiffness matrices for a FEM discretization
x &lt;- seq(from = 0, to = 1, length.out = 101)
fem &lt;- rSPDE.fem1d(x)

# compute rational approximation of covariance function at 0.5
op &lt;- matern.operators(
  loc_mesh = x, nu = nu,
  range = range, sigma = sigma, d = 1, m = 2, type = "operator",
  parameterization = "matern"
)
op

# Update the range parameter of the model:
op &lt;- update(op, kappa = 20)
op

</code></pre>

<hr>
<h2 id='update.rSPDEobj1d'>Update parameters of rSPDEobj1d objects</h2><span id='topic+update.rSPDEobj1d'></span>

<h3>Description</h3>

<p>Function to change the parameters of a rSPDEobj1d object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'rSPDEobj1d'
update(
  object,
  nu = NULL,
  alpha = NULL,
  kappa = NULL,
  tau = NULL,
  sigma = NULL,
  range = NULL,
  theta = NULL,
  m = NULL,
  loc = NULL,
  graph = NULL,
  parameterization = NULL,
  type_rational_approximation = object$type_rational_approximation,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="update.rSPDEobj1d_+3A_object">object</code></td>
<td>
<p>The covariance-based rational SPDE approximation,
computed using <code><a href="#topic+matern.rational">matern.rational()</a></code></p>
</td></tr>
<tr><td><code id="update.rSPDEobj1d_+3A_nu">nu</code></td>
<td>
<p>If non-null, update the shape parameter of the
covariance function. Will be used if parameterization is 'matern'.</p>
</td></tr>
<tr><td><code id="update.rSPDEobj1d_+3A_alpha">alpha</code></td>
<td>
<p>If non-null, update the fractional SPDE order parameter. Will be used if parameterization is 'spde'.</p>
</td></tr>
<tr><td><code id="update.rSPDEobj1d_+3A_kappa">kappa</code></td>
<td>
<p>If non-null, update the parameter kappa of the SPDE. Will be used if parameterization is 'spde'.</p>
</td></tr>
<tr><td><code id="update.rSPDEobj1d_+3A_tau">tau</code></td>
<td>
<p>If non-null, update the parameter tau of the SPDE. Will be used if parameterization is 'spde'.</p>
</td></tr>
<tr><td><code id="update.rSPDEobj1d_+3A_sigma">sigma</code></td>
<td>
<p>If non-null, update the standard deviation of
the covariance function. Will be used if parameterization is 'matern'.</p>
</td></tr>
<tr><td><code id="update.rSPDEobj1d_+3A_range">range</code></td>
<td>
<p>If non-null, update the range parameter
of the covariance function. Will be used if parameterization is 'matern'.</p>
</td></tr>
<tr><td><code id="update.rSPDEobj1d_+3A_theta">theta</code></td>
<td>
<p>For non-stationary models. If non-null, update the vector of parameters.</p>
</td></tr>
<tr><td><code id="update.rSPDEobj1d_+3A_m">m</code></td>
<td>
<p>If non-null, update the order of the rational
approximation, which needs to be a positive integer.</p>
</td></tr>
<tr><td><code id="update.rSPDEobj1d_+3A_loc">loc</code></td>
<td>
<p>The locations of interest for evaluating the model.</p>
</td></tr>
<tr><td><code id="update.rSPDEobj1d_+3A_graph">graph</code></td>
<td>
<p>An optional <code>metric_graph</code> object.</p>
</td></tr>
<tr><td><code id="update.rSPDEobj1d_+3A_parameterization">parameterization</code></td>
<td>
<p>If non-null, update the parameterization.</p>
</td></tr>
<tr><td><code id="update.rSPDEobj1d_+3A_type_rational_approximation">type_rational_approximation</code></td>
<td>
<p>Which type of rational
approximation should be used? The current types are &quot;chebfun&quot;,
&quot;brasil&quot; or &quot;chebfunLB&quot;.</p>
</td></tr>
<tr><td><code id="update.rSPDEobj1d_+3A_...">...</code></td>
<td>
<p>Currently not used.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>It returns an object of class &quot;rSPDEobj1d&quot;. This object contains the
same quantities listed in the output of <code><a href="#topic+matern.rational">matern.rational()</a></code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+simulate.rSPDEobj1d">simulate.rSPDEobj1d()</a></code>, <code><a href="#topic+matern.rational">matern.rational()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
s &lt;- seq(from = 0, to = 1, length.out = 101)
kappa &lt;- 20
sigma &lt;- 2
nu &lt;- 0.8
r &lt;- sqrt(8*nu)/kappa #range parameter
op_cov &lt;- matern.rational(loc = s, nu = nu, range = r, sigma = sigma, m = 2, 
parameterization = "matern")
cov1 &lt;- op_cov$covariance(ind = 1)
op_cov &lt;- update(op_cov, range = 0.2)
cov2 &lt;- op_cov$covariance(ind = 1)
plot(s, cov1, type = "l")
lines(s, cov2, col = 2)
</code></pre>

<hr>
<h2 id='update.spacetimeobj'>Update parameters of spacetimeobj objects</h2><span id='topic+update.spacetimeobj'></span>

<h3>Description</h3>

<p>Function to change the parameters of a spacetimeobj object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'spacetimeobj'
update(object, kappa = NULL, sigma = NULL, gamma = NULL, rho = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="update.spacetimeobj_+3A_object">object</code></td>
<td>
<p>Space-time object created by <code><a href="#topic+spacetime.operators">spacetime.operators()</a></code></p>
</td></tr>
<tr><td><code id="update.spacetimeobj_+3A_kappa">kappa</code></td>
<td>
<p>kappa value to be updated.</p>
</td></tr>
<tr><td><code id="update.spacetimeobj_+3A_sigma">sigma</code></td>
<td>
<p>sigma value to be updated.</p>
</td></tr>
<tr><td><code id="update.spacetimeobj_+3A_gamma">gamma</code></td>
<td>
<p>gamma value to be updated.</p>
</td></tr>
<tr><td><code id="update.spacetimeobj_+3A_rho">rho</code></td>
<td>
<p>rho value to be updated.</p>
</td></tr>
<tr><td><code id="update.spacetimeobj_+3A_...">...</code></td>
<td>
<p>currently not used.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of type spacetimeobj with updated parameters.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>s &lt;- seq(from = 0, to = 20, length.out = 101)
t &lt;- seq(from = 0, to = 20, length.out = 31)

op_cov &lt;- spacetime.operators(space_loc = s, time_loc = t,
                             kappa = 5, sigma = 10, alpha = 1,
                             beta = 2, rho = 1, gamma = 0.05)
op_cov &lt;- update(op_cov, kappa = 4, 
                             sigma = 2, gamma = 0.1)      
</code></pre>

<hr>
<h2 id='variogram.intrinsic.spde'>Variogram of intrinsic SPDE model</h2><span id='topic+variogram.intrinsic.spde'></span>

<h3>Description</h3>

<p>Variogram <code class="reqn">\gamma(s_0,s)</code> of intrinsic SPDE
model
</p>
<p style="text-align: center;"><code class="reqn">(-\Delta)^{\beta/2}(\kappa^2-\Delta)^{\alpha/2} (\tau u) = \mathcal{W}</code>
</p>

<p>with Neumann boundary conditions and a mean-zero constraint on a
square <code class="reqn">[0,L]^d</code> for <code class="reqn">d=1</code> or <code class="reqn">d=2</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>variogram.intrinsic.spde(
  s0 = NULL,
  s = NULL,
  kappa = NULL,
  alpha = NULL,
  beta = NULL,
  tau = 1,
  L = NULL,
  N = 100,
  d = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="variogram.intrinsic.spde_+3A_s0">s0</code></td>
<td>
<p>The location where the variogram should be evaluated, either
a double for 1d or a vector for 2d</p>
</td></tr>
<tr><td><code id="variogram.intrinsic.spde_+3A_s">s</code></td>
<td>
<p>A vector (in 1d) or matrix (in 2d) with all locations where the
variogram is computed</p>
</td></tr>
<tr><td><code id="variogram.intrinsic.spde_+3A_kappa">kappa</code></td>
<td>
<p>Range parameter.</p>
</td></tr>
<tr><td><code id="variogram.intrinsic.spde_+3A_alpha">alpha</code></td>
<td>
<p>Smoothness parameter.</p>
</td></tr>
<tr><td><code id="variogram.intrinsic.spde_+3A_beta">beta</code></td>
<td>
<p>Smoothness parameter.</p>
</td></tr>
<tr><td><code id="variogram.intrinsic.spde_+3A_tau">tau</code></td>
<td>
<p>Precision parameter.</p>
</td></tr>
<tr><td><code id="variogram.intrinsic.spde_+3A_l">L</code></td>
<td>
<p>The side length of the square domain.</p>
</td></tr>
<tr><td><code id="variogram.intrinsic.spde_+3A_n">N</code></td>
<td>
<p>The number of terms in the Karhunen-Loeve expansion.</p>
</td></tr>
<tr><td><code id="variogram.intrinsic.spde_+3A_d">d</code></td>
<td>
<p>The dimension (1 or 2).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The variogram is computed based on a Karhunen-Loeve expansion of the
covariance function.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+intrinsic.matern.operators">intrinsic.matern.operators()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if (requireNamespace("RSpectra", quietly = TRUE)) {
  x &lt;- seq(from = 0, to = 10, length.out = 201)
  beta &lt;- 1
  alpha &lt;- 1
  kappa &lt;- 1
  op &lt;- intrinsic.matern.operators(
    kappa = kappa, tau = 1, alpha = alpha,
    beta = beta, loc_mesh = x, d = 1
  )
  # Compute and plot the variogram of the model
  Sigma &lt;- op$A[,-1] %*% solve(op$Q[-1,-1], t(op$A[,-1]))
  One &lt;- rep(1, times = ncol(Sigma))
  D &lt;- diag(Sigma)
  Gamma &lt;- 0.5 * (One %*% t(D) + D %*% t(One) - 2 * Sigma)
  k &lt;- 100
  plot(x, Gamma[k, ], type = "l")
  lines(x,
    variogram.intrinsic.spde(x[k], x, kappa, alpha, beta, L = 10, d = 1),
    col = 2, lty = 2
  )
}
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
