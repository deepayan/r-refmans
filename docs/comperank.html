<!DOCTYPE html><html><head><title>Help for package comperank</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {comperank}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#colley'><p>Colley method</p></a></li>
<li><a href='#comperank-package'><p>comperank: Ranking and Rating Methods for Competition Results</p></a></li>
<li><a href='#compute_iterative_ratings'><p>Internal function to compute iterative ratings</p></a></li>
<li><a href='#elo'><p>Elo method</p></a></li>
<li><a href='#get_pf_vec'><p>Compute Perron-Frobenius vector</p></a></li>
<li><a href='#iterative'><p>Iterative rating method</p></a></li>
<li><a href='#keener'><p>Keener method</p></a></li>
<li><a href='#markov'><p>Markov method</p></a></li>
<li><a href='#massey'><p>Massey method</p></a></li>
<li><a href='#offense-defense'><p>Offense-Defense method</p></a></li>
<li><a href='#rating-ranking'><p>Definition of Rating and Ranking</p></a></li>
<li><a href='#round_rank'><p>Rank vector after rounding</p></a></li>
<li><a href='#snooker_events'><p>Snooker events</p></a></li>
<li><a href='#snooker_matches'><p>Snooker matches</p></a></li>
<li><a href='#snooker_players'><p>Snooker players</p></a></li>
<li><a href='#stoch-modifiers'><p>Stochastic matrix modifiers</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Title:</td>
<td>Ranking Methods for Competition Results</td>
</tr>
<tr>
<td>Version:</td>
<td>0.1.1</td>
</tr>
<tr>
<td>Description:</td>
<td>Compute ranking and rating based on competition
    results. Methods of different nature are implemented: with fixed
    Head-to-Head structure, with variable Head-to-Head structure and with
    iterative nature. All algorithms are taken from the book 'Who’s #1?:
    The science of rating and ranking' by Amy N. Langville and Carl D.
    Meyer (2012, ISBN:978-0-691-15422-0).</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://opensource.org/licenses/mit-license.php">MIT</a> + file LICENSE</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/echasnovski/comperank">https://github.com/echasnovski/comperank</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/echasnovski/comperank/issues">https://github.com/echasnovski/comperank/issues</a></td>
</tr>
<tr>
<td>Depends:</td>
<td>comperes (&ge; 0.1.0), R (&ge; 3.4.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>dplyr (&ge; 0.6.0), Rcpp, rlang (&ge; 0.2.0), tibble</td>
</tr>
<tr>
<td>Suggests:</td>
<td>covr, knitr, rmarkdown, testthat</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>Rcpp</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.0.2</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2020-03-03 21:14:32 UTC; evgeni</td>
</tr>
<tr>
<td>Author:</td>
<td>Evgeni Chasnovski [aut, cre]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Evgeni Chasnovski &lt;evgeni.chasnovski@gmail.com&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2020-03-03 23:10:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='colley'>Colley method</h2><span id='topic+colley'></span><span id='topic+rate_colley'></span><span id='topic+rank_colley'></span>

<h3>Description</h3>

<p>Functions to compute <a href="#topic+rating-ranking">rating</a> and <a href="#topic+rating-ranking">ranking</a>
using Colley method.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rate_colley(cr_data)

rank_colley(cr_data, keep_rating = FALSE, ties = c("average", "first",
  "last", "random", "max", "min"), round_digits = 7)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="colley_+3A_cr_data">cr_data</code></td>
<td>
<p>Competition results in format ready for
<a href="comperes.html#topic+as_longcr">as_longcr()</a>.</p>
</td></tr>
<tr><td><code id="colley_+3A_keep_rating">keep_rating</code></td>
<td>
<p>Whether to keep rating column in ranking output.</p>
</td></tr>
<tr><td><code id="colley_+3A_ties">ties</code></td>
<td>
<p>Value for <code>ties</code> in <code><a href="#topic+round_rank">round_rank()</a></code>.</p>
</td></tr>
<tr><td><code id="colley_+3A_round_digits">round_digits</code></td>
<td>
<p>Value for <code>round_digits</code> in <code><a href="#topic+round_rank">round_rank()</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This rating method was initially designed for games between two
players. There will be an error if in <code>cr_data</code> there is a game not between
two players. Convert input competition results manually or with
<a href="comperes.html#topic+to_pairgames">to_pairgames()</a> from <code>comperes</code> package.
</p>
<p>It is assumed that score is numeric and higher values are better for the
player.
</p>
<p>Computation is done based only on the games between players of interest (see
Players). <strong>Note</strong> that it isn't necessary for all players of interest to be
present in <code>cr_data</code> but it might be a good idea in order to obtain plausible
outcome rating.
</p>
<p>The outline of the Colley method is as follows:
</p>

<ol>
<li><p> Compute Colley matrix: diagonal elements are equal to number of games
played by certain player <em>plus 2</em>, off-diagonal are equal to minus number of
common games played. This matrix will be the matrix of system of linear
equations (SLE).
</p>
</li>
<li><p> Compute right-hand side of SLE as 1 + 0.5*(&quot;number of player's wins&quot; -
&quot;number of player's losses&quot;).
</p>
</li>
<li><p> Solve the SLE. The solution is the Colley rating.
</p>
</li></ol>



<h3>Value</h3>

<p><code>rate_colley()</code> returns a <a href="tibble.html#topic+tibble">tibble</a> with columns
<code>player</code> (player identifier) and <code>rating_colley</code> (Colley
<a href="#topic+rating-ranking">rating</a>). The mean rating should be 0.5. <strong>Bigger value
indicates better player performance</strong>.
</p>
<p><code>rank_colley()</code> returns a <code>tibble</code> with columns <code>player</code>, <code>rating_colley</code> (if
<code>keep_rating = TRUE</code>) and <code>ranking_colley</code> (Colley <a href="#topic+rating-ranking">ranking</a>
computed with <code><a href="#topic+round_rank">round_rank()</a></code>).
</p>


<h3>Players</h3>

<p><code>comperank</code> offers a possibility to handle certain set of players. It is done
by having <code>player</code> column (in <a href="comperes.html#topic+as_longcr">longcr</a> format) as factor
with levels specifying all players of interest. In case of factor the result
is returned only for players from its levels. Otherwise - for all present
players.
</p>


<h3>References</h3>

<p>Wesley N. Colley (2002) <em>Colley’s Bias Free College Football
Ranking Method: The Colley Matrix Explained</em>. Available online at
<a href="http://www.colleyrankings.com">http://www.colleyrankings.com</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>rate_colley(ncaa2005)

rank_colley(ncaa2005)

rank_colley(ncaa2005, keep_rating = TRUE)

</code></pre>

<hr>
<h2 id='comperank-package'>comperank: Ranking and Rating Methods for Competition Results</h2><span id='topic+comperank'></span><span id='topic+comperank-package'></span>

<h3>Description</h3>

<p><code>comperank</code> provides tools for computing ranking and rating based on
competition results. It is tightly connected to its data infrastructure
package <a href="comperes.html#topic+comperes-package">comperes</a>. Basic knowledge about
creating valid competition results and Head-to-Head expressions with
<code>comperes</code> is needed in order to efficiently use <code>comperank</code>.
</p>


<h3>Details</h3>

<p><code>comperank</code> leverages the <a href="https://www.tidyverse.org/">tidyverse</a> ecosystem
of R packages. Among other things, it means that the main output format is
<a href="tibble.html#topic+tibble">tibble</a>.
</p>
<p><code>comperank</code> gets inspiration from the book <a href="https://www.amazon.com/Whos-1-Science-Rating-Ranking/dp/069116231X">&quot;Who's #1&quot;</a> by
Langville and Meyer. It provides functionality for the following rating
algorithms:
</p>

<ul>
<li><p> Algorithms with <strong>fixed Head-to-Head structure</strong>:
</p>

<ul>
<li><p> Simplified Massey method with <code><a href="#topic+rate_massey">rate_massey()</a></code> and <code><a href="#topic+rank_massey">rank_massey()</a></code>.
</p>
</li>
<li><p> Simplified Colley method with <code><a href="#topic+rate_colley">rate_colley()</a></code> and <code><a href="#topic+rank_colley">rank_colley()</a></code>.
</p>
</li></ul>

</li>
<li><p> Algorithms with <strong>variable Head-to-Head structure</strong>:
</p>

<ul>
<li><p> Keener method with <code><a href="#topic+rate_keener">rate_keener()</a></code> and <code><a href="#topic+rank_keener">rank_keener()</a></code>.
</p>
</li>
<li><p> Markov method with <code><a href="#topic+rate_markov">rate_markov()</a></code> and <code><a href="#topic+rank_markov">rank_markov()</a></code>.
</p>
</li>
<li><p> Offense-Defense method with <code><a href="#topic+rate_od">rate_od()</a></code> and <code><a href="#topic+rank_od">rank_od()</a></code>.
</p>
</li></ul>

</li>
<li><p> Algorithms with <strong>iterative nature</strong>:
</p>

<ul>
<li><p> General Iterative ratings with <code><a href="#topic+rate_iterative">rate_iterative()</a></code>, <code><a href="#topic+rank_iterative">rank_iterative()</a></code>,
and <code><a href="#topic+add_iterative_ratings">add_iterative_ratings()</a></code>.
</p>
</li>
<li><p> Elo ratings with <code><a href="#topic+rate_elo">rate_elo()</a></code>, <code><a href="#topic+rank_elo">rank_elo()</a></code>, and <code><a href="#topic+add_elo_ratings">add_elo_ratings()</a></code>.
</p>
</li></ul>

</li></ul>

<p><code>comperank</code> also offers data sets describing professional snooker in seasons
2016/2017 and 2017/2018. See <a href="#topic+snooker_events">snooker_events</a>, <a href="#topic+snooker_players">snooker_players</a>,
<a href="#topic+snooker_matches">snooker_matches</a>.
</p>
<p>To learn more about <code>comperank</code> browse vignettes with browseVignettes(package
= &quot;comperank&quot;).
</p>


<h3>Author(s)</h3>

<p><strong>Maintainer</strong>: Evgeni Chasnovski <a href="mailto:evgeni.chasnovski@gmail.com">evgeni.chasnovski@gmail.com</a>
</p>


<h3>See Also</h3>

<p>Useful links:
</p>

<ul>
<li> <p><a href="https://github.com/echasnovski/comperank">https://github.com/echasnovski/comperank</a>
</p>
</li>
<li><p> Report bugs at <a href="https://github.com/echasnovski/comperank/issues">https://github.com/echasnovski/comperank/issues</a>
</p>
</li></ul>


<hr>
<h2 id='compute_iterative_ratings'>Internal function to compute iterative ratings</h2><span id='topic+compute_iterative_ratings'></span>

<h3>Description</h3>

<p>C++ implementation of iterative computations.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>compute_iterative_ratings(rate_fun, player1_id, score1, player2_id, score2,
  initial_ratings)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="compute_iterative_ratings_+3A_rate_fun">rate_fun</code></td>
<td>
<p>Rating function (see Details).</p>
</td></tr>
<tr><td><code id="compute_iterative_ratings_+3A_player1_id">player1_id</code></td>
<td>
<p>Integer vector of player1 identifiers.</p>
</td></tr>
<tr><td><code id="compute_iterative_ratings_+3A_score1">score1</code></td>
<td>
<p>Numeric vector of player1 score in games.</p>
</td></tr>
<tr><td><code id="compute_iterative_ratings_+3A_player2_id">player2_id</code></td>
<td>
<p>Integer vector of player2 identifiers.</p>
</td></tr>
<tr><td><code id="compute_iterative_ratings_+3A_score2">score2</code></td>
<td>
<p>Numeric vector of player2 score in games.</p>
</td></tr>
<tr><td><code id="compute_iterative_ratings_+3A_initial_ratings">initial_ratings</code></td>
<td>
<p>Numeric vector of initial ratings (see Details).</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>rate_fun</code> - function that takes arguments:
</p>

<ul>
<li><p> rating1 - rating of player1 before game;
</p>
</li>
<li><p> score1 - numeric score of player1 in the game;
</p>
</li>
<li><p> rating2 - rating of player2 before game;
</p>
</li>
<li><p> score2 - numeric score of player2 in the game.
</p>
</li></ul>

<p>This function should return numeric vector of length 2: rating of player1
and player2 after the game.
</p>
<p><code>player1_id</code>, <code>player2_id</code> - integer vectors of identifiers of
players in a form of increasing numbers (1, 2, ...). Identifier 0 is
reserved for 'ghost' player. His/her rating is taken as current rating of
opponent. For two 'ghost' players ratings before and after are 0.
</p>
<p><code>initial_ratings</code> - numeric vector of length equal to number of unique
players in <code>player1_id</code> and <code>player2_id</code>. In
<code>initial_ratings[player_id - 1]</code> (indexing from zero) initial rating of
player with identifier 'player_id' is stored.
</p>


<h3>Value</h3>

<p>A list:
</p>

<ul>
<li><p> rating1Before - rating of player 1 before the game;
</p>
</li>
<li><p> rating2Before - rating of player 2 before the game;
</p>
</li>
<li><p> rating1After - rating of player 1 after the game;
</p>
</li>
<li><p> rating2After - rating of player 2 after the game.
</p>
</li></ul>


<hr>
<h2 id='elo'>Elo method</h2><span id='topic+elo'></span><span id='topic+rate_elo'></span><span id='topic+rank_elo'></span><span id='topic+add_elo_ratings'></span>

<h3>Description</h3>

<p>Functions to compute <a href="#topic+rating-ranking">rating</a> and <a href="#topic+rating-ranking">ranking</a>
using Elo method.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rate_elo(cr_data, K = 30, ksi = 400, initial_ratings = 0)

rank_elo(cr_data, K = 30, ksi = 400, initial_ratings = 0,
  keep_rating = FALSE, ties = c("average", "first", "last", "random", "max",
  "min"), round_digits = 7)

add_elo_ratings(cr_data, K = 30, ksi = 400, initial_ratings = 0)

elo(rating1, score1, rating2, score2, K = 30, ksi = 400)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="elo_+3A_cr_data">cr_data</code></td>
<td>
<p>Competition results in format ready for
<a href="comperes.html#topic+as_longcr">as_longcr()</a>.</p>
</td></tr>
<tr><td><code id="elo_+3A_k">K</code></td>
<td>
<p>K-factor for Elo formula.</p>
</td></tr>
<tr><td><code id="elo_+3A_ksi">ksi</code></td>
<td>
<p>Normalization coefficient for Elo formula.</p>
</td></tr>
<tr><td><code id="elo_+3A_initial_ratings">initial_ratings</code></td>
<td>
<p>Initial ratings (see <a href="#topic+iterative">Iterative ratings</a>).</p>
</td></tr>
<tr><td><code id="elo_+3A_keep_rating">keep_rating</code></td>
<td>
<p>Whether to keep rating column in ranking output.</p>
</td></tr>
<tr><td><code id="elo_+3A_ties">ties</code></td>
<td>
<p>Value for <code>ties</code> in <code><a href="#topic+round_rank">round_rank()</a></code>.</p>
</td></tr>
<tr><td><code id="elo_+3A_round_digits">round_digits</code></td>
<td>
<p>Value for <code>round_digits</code> in <code><a href="#topic+round_rank">round_rank()</a></code>.</p>
</td></tr>
<tr><td><code id="elo_+3A_rating1">rating1</code></td>
<td>
<p>Rating of player1 before the game.</p>
</td></tr>
<tr><td><code id="elo_+3A_score1">score1</code></td>
<td>
<p>Score of player1 in the game.</p>
</td></tr>
<tr><td><code id="elo_+3A_rating2">rating2</code></td>
<td>
<p>Rating of player2 before the game.</p>
</td></tr>
<tr><td><code id="elo_+3A_score2">score2</code></td>
<td>
<p>Score of player2 in the game.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>rate_elo()</code> and <code>add_elo_ratings()</code> are wrappers for
<code><a href="#topic+rate_iterative">rate_iterative()</a></code> and <code><a href="#topic+add_iterative_ratings">add_iterative_ratings()</a></code> correspondingly. Rate
function is based on Elo algorithm of updating ratings:
</p>

<ol>
<li><p> Probability of player1 (with rating r1) winning against player2 (with
rating r2) is computed based on rating difference and sigmoid function:
<code>P = 1 / (1 + 10^( (r2 - r1) / ksi ) )</code>. <code>ksi</code> defines the spread of ratings.
</p>
</li>
<li><p> Result of the game from player1 perspective is computed based on rule:
<code>S = 1</code> (if <code>score1</code> &gt; <code>score2</code>), <code>S = 0.5</code> (if <code>score1</code> == <code>score2</code>) and
<code>S = 0</code> (if <code>score1</code> &lt; <code>score2</code>).
</p>
</li>
<li><p> Rating delta is computed: <code>d = K * (S - P)</code>. The more the <code>K</code> the more the
delta (with other being equal).
</p>
</li>
<li><p> New ratings are computed: <code>r1_new = r1 + d</code>, <code>r2_new = r2 - d</code>.
</p>
</li></ol>

<p><code>elo()</code> function implements this algorithm. It is vectorized over all its
arguments with standard R recycling functionality. <strong>Note</strong> that not this
function is used in <code>rate_elo()</code> and <code>add_elo_ratings()</code> because of its not
appropriate output format, but rather its non-vectorized reimplementation is.
</p>
<p>Ratings are computed based only on games between players of interest (see
Players) and <code>NA</code> values.
</p>


<h3>Value</h3>

<p><code>rate_elo()</code> returns a <a href="tibble.html#topic+tibble">tibble</a> with columns
<code>player</code> (player identifier) and <code>rating_elo</code> (Elo
<a href="#topic+rating-ranking">ratings</a>, based on row order, by the end of competition
results). <strong>Bigger value indicates better player performance</strong>.
</p>
<p><code>rank_elo()</code> returns a <code>tibble</code> with columns <code>player</code>, <code>rating_elo</code> (if
<code>keep_rating = TRUE</code>) and <code>ranking_elo</code> (Elo <a href="#topic+rating-ranking">ranking</a>
computed with <code><a href="#topic+round_rank">round_rank()</a></code>).
</p>
<p><code>add_elo_ratings()</code> returns a <a href="comperes.html#topic+widecr">widecr</a> form of <code>cr_data</code>
with four rating columns added:
</p>

<ul>
<li> <p><strong>rating1Before</strong> - Rating of player1 before the game.
</p>
</li>
<li> <p><strong>rating2Before</strong> - Rating of player2 before the game.
</p>
</li>
<li> <p><strong>rating1After</strong> - Rating of player1 after the game.
</p>
</li>
<li> <p><strong>rating2After</strong> - Rating of player2 after the game.
</p>
</li></ul>

<p><code>elo()</code> always returns a matrix with two columns containing ratings after the
game. Rows represent games, columns - players.
</p>


<h3>Players</h3>

<p><code>comperank</code> offers a possibility to handle certain set of players. It is done
by having <code>player</code> column (in <a href="comperes.html#topic+as_longcr">longcr</a> format) as factor
with levels specifying all players of interest. In case of factor the result
is returned only for players from its levels. Otherwise - for all present
players.
</p>


<h3>References</h3>

<p><a href="https://en.wikipedia.org/wiki/Elo_rating_system">Wikipedia
page</a> for Elo rating system.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Elo ratings
rate_elo(ncaa2005)

rank_elo(ncaa2005)

rank_elo(ncaa2005, keep_rating = TRUE)

add_elo_ratings(ncaa2005, initial_ratings = 100)

# Elo function
elo((0:12)*100, 1, 0, 0)
elo((0:12)*100, 1, 0, 0, K = 10)
elo((0:12)*10, 1, 0, 0, ksi = 40)

</code></pre>

<hr>
<h2 id='get_pf_vec'>Compute Perron-Frobenius vector</h2><span id='topic+get_pf_vec'></span>

<h3>Description</h3>

<p>Function to compute Perron-Frobenius vector.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_pf_vec(mat)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_pf_vec_+3A_mat">mat</code></td>
<td>
<p>Square matrix</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Perron-Frobenius vector which values sum to 1
</p>

<hr>
<h2 id='iterative'>Iterative rating method</h2><span id='topic+iterative'></span><span id='topic+rate_iterative'></span><span id='topic+rank_iterative'></span><span id='topic+add_iterative_ratings'></span>

<h3>Description</h3>

<p>Functions to compute Iterative numeric <a href="#topic+rating-ranking">ratings</a>, i.e. which
are recomputed after every game, and corresponding
<a href="#topic+rating-ranking">rankings</a>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rate_iterative(cr_data, rate_fun, initial_ratings = 0)

rank_iterative(cr_data, rate_fun, initial_ratings = 0, keep_rating = FALSE,
  type = "desc", ties = c("average", "first", "last", "random", "max",
  "min"), round_digits = 7)

add_iterative_ratings(cr_data, rate_fun, initial_ratings = 0)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="iterative_+3A_cr_data">cr_data</code></td>
<td>
<p>Competition results in format ready for
<a href="comperes.html#topic+as_longcr">as_longcr()</a>.</p>
</td></tr>
<tr><td><code id="iterative_+3A_rate_fun">rate_fun</code></td>
<td>
<p>Rating function (see Details).</p>
</td></tr>
<tr><td><code id="iterative_+3A_initial_ratings">initial_ratings</code></td>
<td>
<p>Initial ratings (see Details).</p>
</td></tr>
<tr><td><code id="iterative_+3A_keep_rating">keep_rating</code></td>
<td>
<p>Whether to keep rating column in ranking output.</p>
</td></tr>
<tr><td><code id="iterative_+3A_type">type</code></td>
<td>
<p>Value for <code>type</code> in <code><a href="#topic+round_rank">round_rank()</a></code>: <code>"desc"</code> or <code>"asc"</code>.</p>
</td></tr>
<tr><td><code id="iterative_+3A_ties">ties</code></td>
<td>
<p>Value for <code>ties</code> in <code><a href="#topic+round_rank">round_rank()</a></code>.</p>
</td></tr>
<tr><td><code id="iterative_+3A_round_digits">round_digits</code></td>
<td>
<p>Value for <code>round_digits</code> in <code><a href="#topic+round_rank">round_rank()</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Iterative ratings of group of players are recomputed after every
game based on players' game scores and their ratings just before the game.
Theoretically this kind of ratings can be non-numeric and be computed on
competition results with variable number of players but they rarely do. This
package provides functions for computing iterative <strong>numeric</strong> ratings for
<a href="comperes.html#topic+to_pairgames">pairgames</a> (competition results with games only
between two players). Error is thrown if <code>cr_data</code> is not pairgames.
</p>
<p>Games in <a href="comperes.html#topic+widecr">widecr</a> form are arranged in increasing order
of values in column <code>game</code> (if it is present) and processed from first to
last row.
</p>
<p><code>NA</code> values in column <code>player</code> are allowed. These players are treated as
'ghosts': players of the same rating as opponent before the game. 'Ghosts'
are not actual players so they don't appear in the output of
<code>rate_iterative()</code>. For games between two 'ghosts' ratings before and after
the game are set to 0.
</p>
<p>The core of the rating system is <code>rate_fun</code>. It should take the
following arguments:
</p>

<ul>
<li> <p><strong>rating1</strong> - Rating of player1 before the game.
</p>
</li>
<li> <p><strong>score1</strong> - Score of player1 in the game.
</p>
</li>
<li> <p><strong>rating2</strong> - Rating of player2 before the game.
</p>
</li>
<li> <p><strong>score2</strong> - Score of player2 in the game.
</p>
</li></ul>

<p><code>rate_fun</code> should return a numeric vector of length 2: first element being a
rating of player1 after the game, second - of player2.
</p>
<p>Ratings are computed based only on games between players of interest (see
Players) and <code>NA</code> values.
</p>
<p>Initial ratings should be defined with argument <code>initial_ratings</code>. It
can be:
</p>

<ul>
<li><p> A single numeric value. In this case initial ratings for all players are
set to this value.
</p>
</li>
<li><p> A named vector of ratings. All non-<code>NA</code> players, for which rating is
computed, should be present in its names (as character representation of
players' actual identifiers).
</p>
</li>
<li><p> A data frame with first column representing player and second - initial
rating. It will be converted to named vector with
<a href="tibble.html#topic+deframe">deframe()</a> from <code>tibble</code> package.
</p>
</li></ul>



<h3>Value</h3>

<p><code>rate_iterative()</code> returns a <a href="tibble.html#topic+tibble">tibble</a> with columns
<code>player</code> (player identifier) and <code>rating_iterative</code> (Iterative
<a href="#topic+rating-ranking">ratings</a>, based on row order, by the end of competition
results). <strong>Interpretation of numbers depends on rating function
<code>rate_fun</code></strong>.
</p>
<p><code>rank_iterative()</code> returns a <code>tibble</code> with columns <code>player</code>,
<code>rating_iterative</code> (if <code>keep_rating = TRUE</code>) and <code>ranking_iterative</code>
(Iterative <a href="#topic+rating-ranking">ranking</a> computed with <code><a href="#topic+round_rank">round_rank()</a></code> based on
specified <code>type</code>).
</p>
<p><code>add_iterative_ratings()</code> returns a <a href="comperes.html#topic+widecr">widecr</a> form of
<code>cr_data</code> with four rating columns added:
</p>

<ul>
<li> <p><strong>rating1Before</strong> - Rating of player1 before the game.
</p>
</li>
<li> <p><strong>rating2Before</strong> - Rating of player2 before the game.
</p>
</li>
<li> <p><strong>rating1After</strong> - Rating of player1 after the game.
</p>
</li>
<li> <p><strong>rating2After</strong> - Rating of player2 after the game.
</p>
</li></ul>



<h3>Players</h3>

<p><code>comperank</code> offers a possibility to handle certain set of players. It is done
by having <code>player</code> column (in <a href="comperes.html#topic+as_longcr">longcr</a> format) as factor
with levels specifying all players of interest. In case of factor the result
is returned only for players from its levels. Otherwise - for all present
players.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>test_rate_fun &lt;- function(rating1, score1, rating2, score2) {
  c(rating1, rating2) + ((score1 &gt;= score2) * 2 - 1) * c(1, -1)
}
set.seed(1002)
cr_data &lt;- data.frame(
  game = rep(1:10, each = 2),
  player = rep(1:5, times = 4),
  score = runif(20)
)
cr_data$player[c(6, 8)] &lt;- NA

# Different settings of add_iterative_ratings
add_iterative_ratings(cr_data, test_rate_fun)

add_iterative_ratings(cr_data, test_rate_fun, initial_ratings = 10)

add_iterative_ratings(
  cr_data, test_rate_fun,
  initial_ratings = c("1" = 1, "2" = 2, "3" = 3, "4" = 4, "5" = 5)
)

add_iterative_ratings(
  cr_data, test_rate_fun,
  initial_ratings = data.frame(1:5, 0:4)
)

# Ratings and ranking at the end of competition results.
rate_iterative(cr_data, test_rate_fun)

rank_iterative(cr_data, test_rate_fun, type = "desc")

rank_iterative(cr_data, test_rate_fun, type = "desc", keep_rating = TRUE)

</code></pre>

<hr>
<h2 id='keener'>Keener method</h2><span id='topic+keener'></span><span id='topic+rate_keener'></span><span id='topic+rank_keener'></span><span id='topic+skew_keener'></span><span id='topic+normalize_keener'></span>

<h3>Description</h3>

<p>Functions to compute <a href="#topic+rating-ranking">rating</a> and <a href="#topic+rating-ranking">ranking</a>
using Keener method.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rate_keener(cr_data, ..., fill = 0, force_nonneg_h2h = TRUE,
  skew_fun = skew_keener, normalize_fun = normalize_keener, eps = 0.001)

rank_keener(cr_data, ..., fill = 0, force_nonneg_h2h = TRUE,
  skew_fun = skew_keener, normalize_fun = normalize_keener, eps = 0.001,
  keep_rating = FALSE, ties = c("average", "first", "last", "random", "max",
  "min"), round_digits = 7)

skew_keener(x)

normalize_keener(mat, cr_data)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="keener_+3A_cr_data">cr_data</code></td>
<td>
<p>Competition results in format ready for
<a href="comperes.html#topic+as_longcr">as_longcr()</a>.</p>
</td></tr>
<tr><td><code id="keener_+3A_...">...</code></td>
<td>
<p>Head-to-Head expression (see <a href="comperes.html#topic+h2h_mat">h2h_mat()</a>).</p>
</td></tr>
<tr><td><code id="keener_+3A_fill">fill</code></td>
<td>
<p>A single value to use instead of NA for missing pairs.</p>
</td></tr>
<tr><td><code id="keener_+3A_force_nonneg_h2h">force_nonneg_h2h</code></td>
<td>
<p>Whether to force nonnegative values in Head-to-Head
matrix.</p>
</td></tr>
<tr><td><code id="keener_+3A_skew_fun">skew_fun</code></td>
<td>
<p>Skew function.</p>
</td></tr>
<tr><td><code id="keener_+3A_normalize_fun">normalize_fun</code></td>
<td>
<p>Normalization function.</p>
</td></tr>
<tr><td><code id="keener_+3A_eps">eps</code></td>
<td>
<p>Coefficient for forcing irreducibility.</p>
</td></tr>
<tr><td><code id="keener_+3A_keep_rating">keep_rating</code></td>
<td>
<p>Whether to keep rating column in ranking output.</p>
</td></tr>
<tr><td><code id="keener_+3A_ties">ties</code></td>
<td>
<p>Value for <code>ties</code> in <code><a href="#topic+round_rank">round_rank()</a></code>.</p>
</td></tr>
<tr><td><code id="keener_+3A_round_digits">round_digits</code></td>
<td>
<p>Value for <code>round_digits</code> in <code><a href="#topic+round_rank">round_rank()</a></code>.</p>
</td></tr>
<tr><td><code id="keener_+3A_x">x</code></td>
<td>
<p>Argument for <code>skew_keener()</code>.</p>
</td></tr>
<tr><td><code id="keener_+3A_mat">mat</code></td>
<td>
<p>Argument for <code>normalize_keener()</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Keener rating method is based on Head-to-Head matrix of the
competition results. Therefore it can be used for competitions with
variable number of players. Its algorithm is as follows:
</p>

<ol>
<li><p> Compute Head-to-Head matrix of competition results based on Head-to-Head
expression supplied in <code>...</code> (see <a href="comperes.html#topic+h2h_mat">h2h_mat()</a> for
technical details and section <strong>Design of Head-to-Head values</strong> for design
details). Head-to-Head values are computed based only on the games between
players of interest (see Players). Ensure that there are no <code>NA</code>s by using
<code>fill</code> argument. If <code>force_nonneg_h2h</code> is <code>TRUE</code> then the minimum value is
subtracted (in case some Head-to-Head value is strictly negative).
</p>
</li>
<li><p> Update raw Head-to-Head values (denoted as S) with the pair-normalization:
a_ij = (S_ij + 1) / (S_ij + S_ji + 2). This step should make comparing
different players more reasonable.
</p>
</li>
<li><p> Skew Head-to-Head values with applying <code>skew_fun</code> to them. <code>skew_fun</code>
should take numeric vector as only argument. It should return skewed vector.
The default skew function is <code>skew_keener()</code>. This step should make abnormal
results not very abnormal. To omit this step supply <code>skew_fun = NULL</code>.
</p>
</li>
<li><p> Normalize Head-to-Head values with <code>normalize_fun</code> using <code>cr_data</code>.
<code>normalize_fun</code> should take Head-to-Head matrix as the first argument and
<code>cr_data</code> as second. It should return normalized matrix. The default
normalization is <code>normalize_keener()</code> which divides Head-to-Head value of
'player1'-'player2' matchup divided by the number of games played by
'player1' (error is thrown if there are no games). This step should take into
account possibly not equal number of games played by players. To omit this
step supply <code>normalize_keener = NULL</code>.
</p>
</li>
<li><p> Add small value to Head-to-Head matrix to ensure its irreducibility. If
all values are strictly positive then this step is omitted. In other case
small value is computed as the smallest non-zero Head-to-Head value
multiplied by <code>eps</code>. This step is done to ensure applicability of
Perron-Frobenius theorem.
</p>
</li>
<li><p> Compute Perron-Frobenius vector of the resultant matrix, i.e. the strictly
positive real eigenvector (which values sum to 1) for eigenvalue (which is
real) of the maximum absolute value. This vector is Keener rating vector.
</p>
</li></ol>

<p>If using <code>normalize_keener()</code> in normalization step, ensure to analyze
players which actually played games (as division by a number of played games
is made). If some player didn't play any game, en error is thrown.
</p>


<h3>Value</h3>

<p><code>rate_keener()</code> returns a <a href="tibble.html#topic+tibble">tibble</a> with columns
<code>player</code> (player identifier) and <code>rating_keener</code> (Keener
<a href="#topic+rating-ranking">rating</a>). Sum of all ratings should be equal to 1. <strong>Bigger
value indicates better player performance</strong>.
</p>
<p><code>rank_keener()</code> returns a <code>tibble</code> with columns <code>player</code>, <code>rating_keener</code> (if
<code>keep_rating = TRUE</code>) and <code>ranking_keener</code> (Keener <a href="#topic+rating-ranking">ranking</a>
computed with <code><a href="#topic+round_rank">round_rank()</a></code>).
</p>
<p><code>skew_keener()</code> returns skewed vector of the same length as <code>x</code>.
</p>
<p><code>normalize_keener()</code> returns normalized matrix with the same dimensions as
<code>mat</code>.
</p>


<h3>Design of Head-to-Head values</h3>

<p>Head-to-Head values in these functions are assumed to follow the property
which can be <em>equivalently</em> described in two ways:
</p>

<ul>
<li><p> In terms of <a href="comperes.html#topic+h2h_mat">matrix format</a>: <strong>the more Head-to-Head
value in row <em>i</em> and column <em>j</em> the better player from row <em>i</em> performed than
player from column <em>j</em></strong>.
</p>
</li>
<li><p> In terms of <a href="comperes.html#topic+h2h_long">long format</a>: <strong>the more Head-to-Head
value the better player1 performed than player2</strong>.
</p>
</li></ul>

<p>This design is chosen because in most competitions the goal is to score
<strong>more points</strong> and not less. Also it allows for more smooth use of
<a href="comperes.html#topic+h2h_funs">h2h_funs</a> from <code>comperes</code> package.
</p>


<h3>Players</h3>

<p><code>comperank</code> offers a possibility to handle certain set of players. It is done
by having <code>player</code> column (in <a href="comperes.html#topic+as_longcr">longcr</a> format) as factor
with levels specifying all players of interest. In case of factor the result
is returned only for players from its levels. Otherwise - for all present
players.
</p>


<h3>References</h3>

<p>James P. Keener (1993) <em>The Perron-Frobenius theorem and the
ranking of football teams</em>. SIAM Review, 35(1):80–93, 1993.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>rate_keener(ncaa2005, sum(score1))

rank_keener(ncaa2005, sum(score1))

rank_keener(ncaa2005, sum(score1), keep_rating = TRUE)

# Impact of skewing
rate_keener(ncaa2005, sum(score1), skew_fun = NULL)

# Impact of normalization.
rate_keener(ncaa2005[-(1:2), ], sum(score1))

rate_keener(ncaa2005[-(1:2), ], sum(score1), normalize_fun = NULL)

</code></pre>

<hr>
<h2 id='markov'>Markov method</h2><span id='topic+markov'></span><span id='topic+rate_markov'></span><span id='topic+rank_markov'></span>

<h3>Description</h3>

<p>Functions to compute <a href="#topic+rating-ranking">rating</a> and <a href="#topic+rating-ranking">ranking</a>
using Markov method.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rate_markov(cr_data, ..., fill = list(), stoch_modify = teleport(0.15),
  weights = 1, force_nonneg_h2h = TRUE)

rank_markov(cr_data, ..., fill = list(), stoch_modify = teleport(0.15),
  weights = 1, force_nonneg_h2h = TRUE, keep_rating = FALSE,
  ties = c("average", "first", "last", "random", "max", "min"),
  round_digits = 7)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="markov_+3A_cr_data">cr_data</code></td>
<td>
<p>Competition results in format ready for
<a href="comperes.html#topic+as_longcr">as_longcr()</a>.</p>
</td></tr>
<tr><td><code id="markov_+3A_...">...</code></td>
<td>
<p>Name-value pairs of Head-to-Head functions (see
<a href="comperes.html#topic+h2h_long">h2h_long()</a>).</p>
</td></tr>
<tr><td><code id="markov_+3A_fill">fill</code></td>
<td>
<p>A named list that for each Head-to-Head function supplies a
single value to use instead of NA for missing pairs (see
<a href="comperes.html#topic+h2h_long">h2h_long()</a>).</p>
</td></tr>
<tr><td><code id="markov_+3A_stoch_modify">stoch_modify</code></td>
<td>
<p>A single function to modify column-stochastic matrix or a
list of them (see <a href="#topic+stoch-modifiers">Stochastic matrix modifiers</a>).</p>
</td></tr>
<tr><td><code id="markov_+3A_weights">weights</code></td>
<td>
<p>Weights for different stochastic matrices.</p>
</td></tr>
<tr><td><code id="markov_+3A_force_nonneg_h2h">force_nonneg_h2h</code></td>
<td>
<p>Whether to force nonnegative values in Head-to-Head
matrix.</p>
</td></tr>
<tr><td><code id="markov_+3A_keep_rating">keep_rating</code></td>
<td>
<p>Whether to keep rating column in ranking output.</p>
</td></tr>
<tr><td><code id="markov_+3A_ties">ties</code></td>
<td>
<p>Value for <code>ties</code> in <code><a href="#topic+round_rank">round_rank()</a></code>.</p>
</td></tr>
<tr><td><code id="markov_+3A_round_digits">round_digits</code></td>
<td>
<p>Value for <code>round_digits</code> in <code><a href="#topic+round_rank">round_rank()</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Markov ratings are based on players 'voting' for other players being
better. Algorithm is as follows:
</p>

<ol>
<li><p> 'Voting' is done with Head-to-Head values supplied in <code>...</code> (see
<a href="comperes.html#topic+h2h_mat">h2h_mat()</a> for technical details and section <strong>Design
of Head-to-Head values</strong> for design details). Take special care of
Head-to-Head values for self plays (when player1 equals player2). <strong>Note</strong>
that Head-to-Head values should be non-negative. Use <code>force_nonneg_h2h = TRUE</code> to force that by subtracting minimum Head-to-Head value (in case some
Head-to-Head value is strictly negative).
</p>
</li>
<li><p> Head-to-Head values are transformed into matrix which is normalized to be
column-stochastic (sum of every column should be equal to 1) Markov matrix
<em>S</em>. <strong>Note</strong> that all missing values are converted into 0. To specify other
value use <code>fill</code> argument.
</p>
</li>
<li> <p><em>S</em> is modified with <code>stoch_modify</code> to deal with possible problems behind
<em>S</em>, such as reducibility and rows with all 0.
</p>
</li>
<li><p> Stationary vector is computed based on <em>S</em> as probability transition
matrix of Markov chain process (transition probabilities from state <strong>i</strong> are
elements from column <strong>i</strong>). The result is declared as Markov ratings.
</p>
</li></ol>

<p>Considering common values and structure of stochastic matrices one can
naturally combine different 'votings' in one stochastic matrix:
</p>

<ol>
<li> <p><a href="comperes.html#topic+h2h_long">Long format</a> of Head-to-Head values is computed
using <code>...</code> (which in this case should be several expressions for
Head-to-Head functions).
</p>
</li>
<li><p> Each set of Head-to-Head values is transformed into matrix which is
normalized to column-stochastic.
</p>
</li>
<li><p> Each stochastic matrix is modified with respective modifier which is
stored in <code>stoch_modify</code> (which can be a list of functions).
</p>
</li>
<li><p> The resulting stochastic matrix is computed as weighted average of
modified stochastic matrices.
</p>
</li></ol>

<p>For Head-to-Head functions in <code>...</code> (considered as list) and argument
<code>stoch_modify</code> general R recycling rule is applied. If <code>stoch_modify</code> is a
function it is transformed to list with one function.
</p>
<p><code>weights</code> is recycled to the maximum length of two mentioned recycled
elements and then is normalized to sum to 1.
</p>
<p>Ratings are computed based only on games between players of interest (see
Players).
</p>


<h3>Value</h3>

<p><code>rate_markov()</code> returns a <a href="tibble.html#topic+tibble">tibble</a> with columns
<code>player</code> (player identifier) and <code>rating_markov</code> (Markov
<a href="#topic+rating-ranking">rating</a>). The sum of all ratings should be equal to 1.
<strong>Bigger value indicates better player performance</strong>.
</p>
<p><code>rank_markov</code> returns a <code>tibble</code> with columns <code>player</code>, <code>rating_markov</code> (if
<code>keep_rating = TRUE</code>) and <code>ranking_markov</code> (Markov <a href="#topic+rating-ranking">ranking</a>
computed with <code><a href="#topic+round_rank">round_rank()</a></code>).
</p>


<h3>Design of Head-to-Head values</h3>

<p>Head-to-Head values in these functions are assumed to follow the property
which can be <em>equivalently</em> described in two ways:
</p>

<ul>
<li><p> In terms of <a href="comperes.html#topic+h2h_mat">matrix format</a>: <strong>the more Head-to-Head
value in row <em>i</em> and column <em>j</em> the better player from row <em>i</em> performed than
player from column <em>j</em></strong>.
</p>
</li>
<li><p> In terms of <a href="comperes.html#topic+h2h_long">long format</a>: <strong>the more Head-to-Head
value the better player1 performed than player2</strong>.
</p>
</li></ul>

<p>This design is chosen because in most competitions the goal is to score
<strong>more points</strong> and not less. Also it allows for more smooth use of
<a href="comperes.html#topic+h2h_funs">h2h_funs</a> from <code>comperes</code> package.
</p>


<h3>Players</h3>

<p><code>comperank</code> offers a possibility to handle certain set of players. It is done
by having <code>player</code> column (in <a href="comperes.html#topic+as_longcr">longcr</a> format) as factor
with levels specifying all players of interest. In case of factor the result
is returned only for players from its levels. Otherwise - for all present
players.
</p>


<h3>References</h3>

<p><a href="https://en.wikipedia.org/wiki/Markov_chain">Wikipedia
page</a> for Markov chain.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>rate_markov(
  cr_data = ncaa2005,
  # player2 "votes" for player1 if player1 won
  comperes::num_wins(score1, score2, half_for_draw = FALSE),
  stoch_modify = vote_equal
)

rank_markov(
  cr_data = ncaa2005,
  comperes::num_wins(score1, score2, half_for_draw = FALSE),
  stoch_modify = vote_equal
)

rank_markov(
  cr_data = ncaa2005,
  comperes::num_wins(score1, score2, half_for_draw = FALSE),
  stoch_modify = vote_equal,
  keep_rating = TRUE
)

# Combine multiple stochastic matrices and
# use inappropriate `fill` which misrepresents reality
rate_markov(
  cr_data = ncaa2005[-(1:2), ],
  win = comperes::num_wins(score1, score2, half_for_draw = FALSE),
  # player2 "votes" for player1 proportionally to the amount player1 scored
  # more in direct confrontations
  score_diff = max(mean(score1 - score2), 0),
  fill = list(win = 0.5, score_diff = 10),
  stoch_modify = list(vote_equal, teleport(0.15)),
  weights = c(0.8, 0.2)
)

</code></pre>

<hr>
<h2 id='massey'>Massey method</h2><span id='topic+massey'></span><span id='topic+rate_massey'></span><span id='topic+rank_massey'></span>

<h3>Description</h3>

<p>Functions to compute <a href="#topic+rating-ranking">rating</a> and <a href="#topic+rating-ranking">ranking</a>
using Massey method.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rate_massey(cr_data)

rank_massey(cr_data, keep_rating = FALSE, ties = c("average", "first",
  "last", "random", "max", "min"), round_digits = 7)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="massey_+3A_cr_data">cr_data</code></td>
<td>
<p>Competition results in format ready for
<a href="comperes.html#topic+as_longcr">as_longcr()</a>.</p>
</td></tr>
<tr><td><code id="massey_+3A_keep_rating">keep_rating</code></td>
<td>
<p>Whether to keep rating column in ranking output.</p>
</td></tr>
<tr><td><code id="massey_+3A_ties">ties</code></td>
<td>
<p>Value for <code>ties</code> in <code><a href="#topic+round_rank">round_rank()</a></code>.</p>
</td></tr>
<tr><td><code id="massey_+3A_round_digits">round_digits</code></td>
<td>
<p>Value for <code>round_digits</code> in <code><a href="#topic+round_rank">round_rank()</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This rating method was initially designed for games between two
players. There will be an error if in <code>cr_data</code> there is a game not between
two players. Convert input competition results manually or with
<a href="comperes.html#topic+to_pairgames">to_pairgames()</a> from <code>comperes</code> package.
</p>
<p>It is assumed that score is numeric and higher values are better for the
player.
</p>
<p>Computation is done based only on the games between players of interest (see
Players). <strong>Note</strong> that all those players should be present in <code>cr_data</code>
because otherwise there will be an error during solving linear system
described below. Message is given if there are players absent in <code>cr_data</code>.
</p>
<p>The outline of Massey rating method is as follows:
</p>

<ol>
<li><p> Compute Massey matrix: diagonal elements are equal to number of games
played by certain player, off-diagonal are equal to minus number of common
games played. This matrix will be the matrix of system of linear equations
(SLE).
</p>
</li>
<li><p> Compute right-hand side of SLE as cumulative score differences of players,
i.e. sum of all scores <em>for</em> the player minus sum of all scores <em>against</em> the
player.
</p>
</li>
<li><p> Make adjustment for solvability of SLE. Modify the last row of Massey
matrix so that all its cells are equal to 1. Also change the last cell in
right-hand side to 0. This adjustment ensures that sum of all outcome ratings
will be 0.
</p>
</li>
<li><p> Solve the SLE. The solution is the Massey rating.
</p>
</li></ol>



<h3>Value</h3>

<p><code>rate_massey()</code> returns a <a href="tibble.html#topic+tibble">tibble</a> with columns
<code>player</code> (player identifier) and <code>rating_massey</code> (Massey
<a href="#topic+rating-ranking">rating</a>). The sum of all ratings should be equal to 0.
<strong>Bigger value indicates better player performance</strong>.
</p>
<p><code>rank_massey()</code> returns a <code>tibble</code> with columns <code>player</code>, <code>rating_massey</code> (if
<code>keep_rating = TRUE</code>) and <code>ranking_massey</code> (Massey <a href="#topic+rating-ranking">ranking</a>
computed with <code><a href="#topic+round_rank">round_rank()</a></code>).
</p>


<h3>Players</h3>

<p><code>comperank</code> offers a possibility to handle certain set of players. It is done
by having <code>player</code> column (in <a href="comperes.html#topic+as_longcr">longcr</a> format) as factor
with levels specifying all players of interest. In case of factor the result
is returned only for players from its levels. Otherwise - for all present
players.
</p>


<h3>References</h3>

<p>Kenneth Massey (1997) <em>Statistical models applied to the
rating of sports teams</em>. Bachelor’s thesis, Bluefield College.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>rate_massey(ncaa2005)

rank_massey(ncaa2005)

rank_massey(ncaa2005, keep_rating = TRUE)

</code></pre>

<hr>
<h2 id='offense-defense'>Offense-Defense method</h2><span id='topic+offense-defense'></span><span id='topic+rate_od'></span><span id='topic+rank_od'></span>

<h3>Description</h3>

<p>Functions to compute <a href="#topic+rating-ranking">rating</a> and <a href="#topic+rating-ranking">ranking</a>
using Offense-Defense method.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rate_od(cr_data, ..., force_nonneg_h2h = TRUE, eps = 0.001, tol = 1e-04,
  max_iterations = 100)

rank_od(cr_data, ..., force_nonneg_h2h = TRUE, eps = 0.001, tol = 1e-04,
  max_iterations = 100, keep_rating = FALSE, ties = c("average", "first",
  "last", "random", "max", "min"), round_digits = 7)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="offense-defense_+3A_cr_data">cr_data</code></td>
<td>
<p>Competition results in format ready for
<a href="comperes.html#topic+as_longcr">as_longcr()</a>.</p>
</td></tr>
<tr><td><code id="offense-defense_+3A_...">...</code></td>
<td>
<p>Head-to-Head expression (see <a href="comperes.html#topic+h2h_mat">h2h_mat()</a>).</p>
</td></tr>
<tr><td><code id="offense-defense_+3A_force_nonneg_h2h">force_nonneg_h2h</code></td>
<td>
<p>Whether to force nonnegative values in Head-to-Head
matrix.</p>
</td></tr>
<tr><td><code id="offense-defense_+3A_eps">eps</code></td>
<td>
<p>Coefficient for total support.</p>
</td></tr>
<tr><td><code id="offense-defense_+3A_tol">tol</code></td>
<td>
<p>Tolerance value for iterative algorithm.</p>
</td></tr>
<tr><td><code id="offense-defense_+3A_max_iterations">max_iterations</code></td>
<td>
<p>Maximum number of iterations for iterative algorithm.</p>
</td></tr>
<tr><td><code id="offense-defense_+3A_keep_rating">keep_rating</code></td>
<td>
<p>Whether to keep rating columns in ranking output.</p>
</td></tr>
<tr><td><code id="offense-defense_+3A_ties">ties</code></td>
<td>
<p>Value for <code>ties</code> in <code><a href="#topic+round_rank">round_rank()</a></code>.</p>
</td></tr>
<tr><td><code id="offense-defense_+3A_round_digits">round_digits</code></td>
<td>
<p>Value for <code>round_digits</code> in <code><a href="#topic+round_rank">round_rank()</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Offense-Defense (OD) rating is designed for games in which player's
goal is to make higher score than opponent(s). To describe competition
results Head-to-Head matrix is computed using <code>...</code> (see
<a href="comperes.html#topic+h2h_mat">h2h_mat()</a> for technical details and section <strong>Design
of Head-to-Head values</strong> for design details). For pairs of players without
common games Head-to-Head value is computed to 0 (not <code>NA</code>). <strong>Note</strong> that
values should be non-negative and non-NA. This can be ensured with setting
<code>force_nonneg_h2h</code> to <code>TRUE</code>.
</p>
<p>For player which can achieve <em>high</em> Head-to-Head value (even against the
player with strong defense) it is said that he/she has <strong>strong offense</strong>
which results into <em>high</em> offensive rating. For player which can force their
opponents into achieving <em>low</em> Head-to-Head value (even if they have strong
offense) it is said that he/she has <strong>strong defense</strong> which results into
<em>low</em> defensive rating.
</p>
<p>Offensive and defensive ratings describe different skills of players. In
order to fully rate players, OD ratings are computed: offensive ratings
divided by defensive. The more OD rating the better player performance.
</p>
<p>Algorithm for OD ratings is as follows:
</p>

<ol>
<li><p> Compute Head-to-Head matrix using <code>...</code>.
</p>
</li>
<li><p> Add small value to Head-to-Head matrix to ensure convergence of the
iterative algorithm in the next step. If all values are strictly positive
then this step is omitted. In other case small value is computed as the
smallest non-zero Head-to-Head value multiplied by <code>eps</code>.
</p>
</li>
<li><p> Perform iterative fixed point search with the following recurrent formula:
<code>def_{k+1} = t(A) %*% inv(A %*% inv(def_{k}))</code> where <code style="white-space: pre;">&#8288;def_{k}&#8288;</code>
is a vector of defensive ratings at iteration <code>k</code>, <code>A</code> is a perturbed
Head-to-Head matrix, <code>inv(x) = 1 / x</code>. Iterative search stops if at least one
of two conditions is met:
</p>

<ul>
<li> <p><code style="white-space: pre;">&#8288;sum(abs(def_{k+1} / def_{k} - 1)) &lt; tol&#8288;</code>.
</p>
</li>
<li><p> Number of iterations exceeds maximum number of iterations
<code>max_iterations</code>.
</p>
</li></ul>

</li>
<li><p> Compute offensive ratings: <code>off = A %*% inv(def)</code>.
</p>
</li>
<li><p> Compute OD ratings: <code>od = off / def</code>.
</p>
</li></ol>

<p>Ratings are computed based only on games between players of interest (see
Players). However, be careful with OD ratings for players with no games:
they will have weak offense (because they &quot;scored&quot; 0 in all games) but
strong defense (because all their opponents also &quot;scored&quot; 0 in all common
games). Therefore accounting for missing players might be not a very good
idea.
</p>


<h3>Value</h3>

<p><code>rate_od()</code> returns a <a href="tibble.html#topic+tibble">tibble</a> with the following
columns:
</p>

<ul>
<li> <p><strong>player</strong> - player identifier.
</p>
</li>
<li> <p><strong>rating_off</strong> - offensive <a href="#topic+rating-ranking">rating</a> of player. <strong>Bigger
value indicates better player performance</strong>.
</p>
</li>
<li> <p><strong>rating_def</strong> - defensive rating of player. <strong>Smaller value indicates
better player performance</strong>.
</p>
</li>
<li> <p><strong>rating_od</strong> - Offense-Defense rating of player. <strong>Bigger value indicates
better player performance</strong>.
</p>
</li></ul>

<p><code>rank_od()</code> returns a <code>tibble</code> of the similar structure as <code>rate_od()</code>:
</p>

<ul>
<li> <p><strong>player</strong> - player identifier.
</p>
</li>
<li> <p><strong>rating_off</strong>, <strong>rating_def</strong>, <strong>rating_od</strong> - ratings (if
<code>keep_rating = TRUE</code>).
</p>
</li>
<li> <p><strong>ranking_off</strong>, <strong>ranking_def</strong>, <strong>ranking_od</strong> -
<a href="#topic+rating-ranking">rankings</a> computed with <code><a href="#topic+round_rank">round_rank()</a></code>.
</p>
</li></ul>



<h3>Design of Head-to-Head values</h3>

<p>Head-to-Head values in these functions are assumed to follow the property
which can be <em>equivalently</em> described in two ways:
</p>

<ul>
<li><p> In terms of <a href="comperes.html#topic+h2h_mat">matrix format</a>: <strong>the more Head-to-Head
value in row <em>i</em> and column <em>j</em> the better player from row <em>i</em> performed than
player from column <em>j</em></strong>.
</p>
</li>
<li><p> In terms of <a href="comperes.html#topic+h2h_long">long format</a>: <strong>the more Head-to-Head
value the better player1 performed than player2</strong>.
</p>
</li></ul>

<p>This design is chosen because in most competitions the goal is to score
<strong>more points</strong> and not less. Also it allows for more smooth use of
<a href="comperes.html#topic+h2h_funs">h2h_funs</a> from <code>comperes</code> package.
</p>


<h3>Players</h3>

<p><code>comperank</code> offers a possibility to handle certain set of players. It is done
by having <code>player</code> column (in <a href="comperes.html#topic+as_longcr">longcr</a> format) as factor
with levels specifying all players of interest. In case of factor the result
is returned only for players from its levels. Otherwise - for all present
players.
</p>


<h3>References</h3>

<p>Amy N. Langville, Carl D. Meyer (2012) <em>Who’s #1?: The
science of rating and ranking</em>.
</p>
<p>Philip A. Knight (2008) <em>The Sinkhorn-Knopp algorithm:
Convergence and applications.</em>. SIAM Journal of Matrix Analysis,
30(1):261–275, 2008 (For stopping rule of iterative algorithm).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>rate_od(ncaa2005, mean(score1))

rank_od(ncaa2005, mean(score1))

rank_od(ncaa2005, mean(score1), keep_rating = TRUE)

# Account for self play
rate_od(ncaa2005, if(player1[1] == player2[1]) 0 else mean(score1))

</code></pre>

<hr>
<h2 id='rating-ranking'>Definition of Rating and Ranking</h2><span id='topic+rating-ranking'></span>

<h3>Description</h3>


<ul>
<li> <p><strong>Rating</strong> - List (in the ordinary sense) of numerical values, one for each
player, or the numerical value itself. Its interpretation depends on rating
method: either bigger value indicates better player performance or otherwise.
</p>
</li>
<li> <p><strong>Ranking</strong> - Rank-ordered list (in the ordinary sense) of players: rank 1
indicates player with best performance.
</p>
</li></ul>


<hr>
<h2 id='round_rank'>Rank vector after rounding</h2><span id='topic+round_rank'></span>

<h3>Description</h3>

<p>Function for ranking vector after rounding.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>round_rank(x, type = "desc", na.last = TRUE, ties = c("average", "first",
  "last", "random", "max", "min"), round_digits = 7)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="round_rank_+3A_x">x</code></td>
<td>
<p>A numeric, complex, character or logical vector.</p>
</td></tr>
<tr><td><code id="round_rank_+3A_type">type</code></td>
<td>
<p>Type of ranking: <code>"desc"</code> or <code>"asc"</code> (see Details).</p>
</td></tr>
<tr><td><code id="round_rank_+3A_na.last">na.last</code></td>
<td>
<p>For controlling the treatment of <code>NA</code>s. If <code>TRUE</code>, missing
values in the data are put last; if <code>FALSE</code>, they are put first; if <code>NA</code>,
they are removed; if <code>"keep"</code> they are kept with rank <code>NA</code>.</p>
</td></tr>
<tr><td><code id="round_rank_+3A_ties">ties</code></td>
<td>
<p>A character string specifying how ties are treated (see Details).
Can be abbreviated.</p>
</td></tr>
<tr><td><code id="round_rank_+3A_round_digits">round_digits</code></td>
<td>
<p>Value of <code>digits</code> for <code><a href="base.html#topic+round">round()</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This is basically a wrapper around <code><a href="base.html#topic+rank">rank()</a></code> in which <code>x</code> is
pre-modified by rounding to specific number of digits <code>round_digits</code>.
</p>
<p><code>type</code> can have two values: <code>"desc"</code> for ranking in descending order (rank 1
is given to the biggest value in <code>x</code>) and <code>"asc"</code> (rank 1 is given to the
smallest value in <code>x</code>). Any other value will cause error.
</p>


<h3>Value</h3>

<p>A numeric vector of the same length as <code>x</code> with names copied from <code>x</code>
(unless <code>na.last = NA</code>, when missing values are removed). The vector is of
integer type unless <code>x</code> is a long vector or <code>ties = "average"</code> when it is of
double type (whether or not there are any ties).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>round_rank(10:1, type = "desc")
round_rank(10:1, type = "asc")

set.seed(334)
x &lt;- 10^(-10) * runif(10)
round_rank(x)

</code></pre>

<hr>
<h2 id='snooker_events'>Snooker events</h2><span id='topic+snooker_events'></span>

<h3>Description</h3>

<p>Data set describing snooker events in seasons 2016/2017 and 2017/2018.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>snooker_events
</code></pre>


<h3>Format</h3>

<p>A <a href="tibble.html#topic+tibble">tibble</a> with one row per event and the following
columns:
</p>

<ul>
<li> <p><strong>id</strong> <code style="white-space: pre;">&#8288;&lt;int&gt;&#8288;</code> : Event identifier in snooker.org database (used in <code>eventId</code>
column of <a href="#topic+snooker_matches">snooker_matches</a>).
</p>
</li>
<li> <p><strong>season</strong> <code style="white-space: pre;">&#8288;&lt;int&gt;&#8288;</code> : Season identifier (by the year of season start).
</p>
</li>
<li> <p><strong>name</strong> <code style="white-space: pre;">&#8288;&lt;chr&gt;&#8288;</code> : Event name.
</p>
</li>
<li> <p><strong>startDate</strong> <code style="white-space: pre;">&#8288;&lt;dttm&gt;&#8288;</code> : Start date of event.
</p>
</li>
<li> <p><strong>endDate</strong> <code style="white-space: pre;">&#8288;&lt;dttm&gt;&#8288;</code> : End date of event.
</p>
</li>
<li> <p><strong>sponsor</strong> <code style="white-space: pre;">&#8288;&lt;chr&gt;&#8288;</code> : Event sponsor name.
</p>
</li>
<li> <p><strong>type</strong> <code style="white-space: pre;">&#8288;&lt;chr&gt;&#8288;</code> : Event type (&quot;Invitational&quot;, &quot;Qualifying&quot;, or &quot;Ranking&quot;).
</p>
</li>
<li> <p><strong>venue</strong> <code style="white-space: pre;">&#8288;&lt;chr&gt;&#8288;</code> : Venue name event was played.
</p>
</li>
<li> <p><strong>city</strong> <code style="white-space: pre;">&#8288;&lt;chr&gt;&#8288;</code> : City name event was played.
</p>
</li>
<li> <p><strong>country</strong> <code style="white-space: pre;">&#8288;&lt;chr&gt;&#8288;</code> : Country name event was played.
</p>
</li></ul>


<h3>Details</h3>

<p>Data is taken from snooker.org (http://www.snooker.org/) API.
</p>
<p>This data set has information about events that have all following qualities:
</p>

<ul>
<li><p> It has &quot;Invitational&quot;, &quot;Qualifying&quot;, or &quot;Ranking&quot; type.
</p>
</li>
<li><p> It describes traditional snooker (not 6 Red or Power Snooker) between
individual players (not teams).
</p>
</li>
<li><p> Both genders can take part (not only men or women).
</p>
</li>
<li><p> Players of all ages can take part (not only seniors or under 21).
</p>
</li>
<li><p> It is not &quot;Shoot-Out&quot; as those events are treated differently in
snooker.org database.
</p>
</li></ul>



<h3>See Also</h3>

<p><a href="#topic+snooker_players">Snooker players</a>,
<a href="#topic+snooker_matches">snooker matches</a>
</p>

<hr>
<h2 id='snooker_matches'>Snooker matches</h2><span id='topic+snooker_matches'></span>

<h3>Description</h3>

<p>Data set describing snooker matches in seasons 2016/2017 and 2017/2018.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>snooker_matches
</code></pre>


<h3>Format</h3>

<p>A <a href="tibble.html#topic+tibble">tibble</a> with one row per match and the following
columns:
</p>

<ul>
<li> <p><strong>id</strong> <code style="white-space: pre;">&#8288;&lt;int&gt;&#8288;</code> : Match identifier in snooker.org database.
</p>
</li>
<li> <p><strong>eventId</strong> <code style="white-space: pre;">&#8288;&lt;int&gt;&#8288;</code> : Match's event identifier (taken from <code>id</code> column of
<a href="#topic+snooker_events">snooker_events</a>)
</p>
</li>
<li> <p><strong>round</strong> <code style="white-space: pre;">&#8288;&lt;int&gt;&#8288;</code> : Round number of event in which match was played.
<em>Usually</em> event's structure is organized in rounds: sets of matches with
roughly &quot;the same importance&quot;. <em>Usually</em> the more round number the &quot;more
important&quot; matches are played. However, there are many exceptions.
</p>
</li>
<li> <p><strong>player1Id</strong> <code style="white-space: pre;">&#8288;&lt;int&gt;&#8288;</code> : Identifier of first player in match (taken from <code>id</code>
column of <a href="#topic+snooker_players">snooker_players</a>).
</p>
</li>
<li> <p><strong>score1</strong> <code style="white-space: pre;">&#8288;&lt;int&gt;&#8288;</code> : Number of won frames (individual games) by first player.
</p>
</li>
<li> <p><strong>walkover1</strong> <code style="white-space: pre;">&#8288;&lt;lgl&gt;&#8288;</code> : Whether the win of first player was scored by the
technical reasons.
</p>
</li>
<li> <p><strong>player2Id</strong> <code style="white-space: pre;">&#8288;&lt;int&gt;&#8288;</code> : Identifier of second player in match (taken from <code>id</code>
column of <a href="#topic+snooker_players">snooker_players</a>).
</p>
</li>
<li> <p><strong>score2</strong> <code style="white-space: pre;">&#8288;&lt;int&gt;&#8288;</code> : Number of won frames (individual games) by second
player.
</p>
</li>
<li> <p><strong>walkover2</strong> <code style="white-space: pre;">&#8288;&lt;lgl&gt;&#8288;</code> : Whether the win of second player was scored by the
technical reasons.
</p>
</li>
<li> <p><strong>winnerId</strong> <code style="white-space: pre;">&#8288;&lt;int&gt;&#8288;</code> : Identifier of match's winner (taken from either
<code>player1Id</code> or <code>player2Id</code> columns).
</p>
</li>
<li> <p><strong>startDate</strong> <code style="white-space: pre;">&#8288;&lt;dttm&gt;&#8288;</code> : Time at which match started.
</p>
</li>
<li> <p><strong>endDate</strong> <code style="white-space: pre;">&#8288;&lt;dttm&gt;&#8288;</code> : Time at which match ended.
</p>
</li>
<li> <p><strong>scheduledDate</strong> <code style="white-space: pre;">&#8288;&lt;dttm&gt;&#8288;</code> : Time at which match was scheduled to start.
</p>
</li>
<li> <p><strong>frameScores</strong> <code style="white-space: pre;">&#8288;&lt;chr&gt;&#8288;</code> : Scores of players in frames. Usually is missing,
present only for important matches.
</p>
</li></ul>


<h3>Details</h3>

<p>Data is taken from snooker.org (http://www.snooker.org/) API.
</p>
<p>Matches are present only for tracked <a href="#topic+snooker_events">snooker events</a>.
</p>


<h3>See Also</h3>

<p><a href="#topic+snooker_events">Snooker events</a>, <a href="#topic+snooker_players">snooker players</a>
</p>

<hr>
<h2 id='snooker_players'>Snooker players</h2><span id='topic+snooker_players'></span>

<h3>Description</h3>

<p>Data set describing snooker players in seasons 2016/2017 and 2017/2018.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>snooker_players
</code></pre>


<h3>Format</h3>

<p>A <a href="tibble.html#topic+tibble">tibble</a> with one row per player and the following
columns:
</p>

<ul>
<li> <p><strong>id</strong> <code style="white-space: pre;">&#8288;&lt;int&gt;&#8288;</code> : Player identifier in snooker.org database (used in
<code>player1Id</code>, <code>player2Id</code> and <code>winnerId</code> columns of <a href="#topic+snooker_matches">snooker_matches</a>).
</p>
</li>
<li> <p><strong>name</strong> <code style="white-space: pre;">&#8288;&lt;chr&gt;&#8288;</code> : Player full name.
</p>
</li>
<li> <p><strong>nationality</strong> <code style="white-space: pre;">&#8288;&lt;chr&gt;&#8288;</code> : Player nationality.
</p>
</li>
<li> <p><strong>sex</strong> <code style="white-space: pre;">&#8288;&lt;chr&gt;&#8288;</code> : Player gender (&quot;F&quot; for female, &quot;M&quot; for male, and
&quot;Unknown&quot;).
</p>
</li>
<li> <p><strong>born</strong> <code style="white-space: pre;">&#8288;&lt;dttm&gt;&#8288;</code> : Player date of birth.
</p>
</li>
<li> <p><strong>status</strong> <code style="white-space: pre;">&#8288;&lt;chr&gt;&#8288;</code> : Player status in season 2017/2018 (&quot;pro&quot; for
professional, &quot;ama&quot; for amateur).
</p>
</li></ul>


<h3>Details</h3>

<p>Data is taken from snooker.org (http://www.snooker.org/) API.
</p>
<p>Data is present only for players who played at least one game in tracked
<a href="#topic+snooker_events">snooker events</a> in seasons 2016/2017 and 2017/2018.
</p>


<h3>See Also</h3>

<p><a href="#topic+snooker_events">Snooker events</a>, <a href="#topic+snooker_matches">snooker matches</a>
</p>

<hr>
<h2 id='stoch-modifiers'>Stochastic matrix modifiers</h2><span id='topic+stoch-modifiers'></span><span id='topic+teleport'></span><span id='topic+vote_equal'></span><span id='topic+vote_self'></span>

<h3>Description</h3>

<p>Functions for stochastic matrix modifications.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>teleport(teleport_prob = 0.15)

vote_equal(stoch)

vote_self(stoch)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="stoch-modifiers_+3A_teleport_prob">teleport_prob</code></td>
<td>
<p>Probability of 'teleportation'.</p>
</td></tr>
<tr><td><code id="stoch-modifiers_+3A_stoch">stoch</code></td>
<td>
<p>Input stochastic matrix.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Modification logic behind <code>teleport()</code> assumes that at each step
of Markov chain (described by column-stochastic matrix) the decision is made
whether to change state according to stochastic matrix or to 'teleport' to
any state with equal probability. Probability of 'teleport' is
<code>teleport_prob</code>. This modification is useful because it ensures
irreducibility of stochastic matrix (with <code>teleport_prob</code> in (0; 1)).
<strong>Note</strong> that in order to obtain modifier one should call function
<code>teleport()</code> with some parameter.
</p>
<p><code>vote_equal()</code> and <code>vote_self()</code> modify columns with elements only equal to
0. The former fills them with <code>1/nrow(stoch)</code> and the latter changes only the
respective diagonal element to 1. This is equivalent to jump to any state
with equal probability and to stay in the current state respectively.
</p>


<h3>Value</h3>

<p><code>teleport()</code> returns a modifier function.
</p>
<p><code>vote_equal()</code> and <code>vote_self()</code> are modifier functions and return modified
version of input stochastic matrix.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>input_stoch &lt;- matrix(c(0, 0.3,
                        0, 0.7),
                      ncol = 2, byrow = TRUE)
teleport(0.15)(input_stoch)

vote_equal(input_stoch)

vote_self(input_stoch)

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
