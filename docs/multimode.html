<!DOCTYPE html><html><head><title>Help for package multimode</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {multimode}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#multimode-package'>
<p>Mode testing and exploring.</p></a></li>
<li><a href='#acidity'><p> Acid-neutralizing capacity</p></a></li>
<li><a href='#bw.crit'><p> Critical bandwidth</p></a></li>
<li><a href='#chondrite'><p> Percentage of silica in chondrite meteors</p></a></li>
<li><a href='#enzyme'><p> Blood enzymatic activity</p></a></li>
<li><a href='#excessmass'><p> Excess mass</p></a></li>
<li><a href='#galaxy'><p> Velocities of galaxies diverging away from our own galaxy</p></a></li>
<li><a href='#geyser'><p> Waiting time between geyser eruptions</p></a></li>
<li><a href='#locmodes'><p> Location of modes and antimodes</p></a></li>
<li><a href='#modeforest'><p> Mode forest</p></a></li>
<li><a href='#modetest'><p> Test for the number of modes</p></a></li>
<li><a href='#modetree'><p> Mode tree</p></a></li>
<li><a href='#nmodes'><p> Number of modes</p></a></li>
<li><a href='#plot.gtmod'>
<p>Plot, print and summarize a <code>"gtmod"</code> object</p></a></li>
<li><a href='#sizer'><p> SIgnificant ZERo crossing</p></a></li>
<li><a href='#stamps'><p> Stamps thickness</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Mode Testing and Exploring</td>
</tr>
<tr>
<td>Version:</td>
<td>1.5</td>
</tr>
<tr>
<td>Date:</td>
<td>2021-03-17</td>
</tr>
<tr>
<td>Author:</td>
<td>Jose Ameijeiras-Alonso [aut,cre],
  Rosa M. Crujeiras [aut], 
  Alberto Rodríguez-Casal [aut],
  The R Core Team 1996-2012 [ctb,cph] (C function 'BinDist2' obtained from package 'stats'),
  The R Foundation 2005 [ctb,cph] (C function 'BinDist2' obtained from package 'stats')</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Jose Ameijeiras-Alonso &lt;jose.ameijeiras@usc.es&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Different examples and methods for testing (including different proposals described in Ameijeiras-Alonso et al., 2019 &lt;<a href="https://doi.org/10.1007%2Fs11749-018-0611-5">doi:10.1007/s11749-018-0611-5</a>&gt;) and exploring (including the mode tree, mode forest and SiZer) the number of modes using nonparametric techniques &lt;<a href="https://doi.org/10.18637%2Fjss.v097.i09">doi:10.18637/jss.v097.i09</a>&gt;.</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 2.10.0)</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>LazyData:</td>
<td>TRUE</td>
</tr>
<tr>
<td>Imports:</td>
<td>diptest, ks, rootSolve</td>
</tr>
<tr>
<td>Suggests:</td>
<td>nor1mix</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://doi.org/10.18637/jss.v097.i09">https://doi.org/10.18637/jss.v097.i09</a></td>
</tr>
<tr>
<td>Packaged:</td>
<td>2021-03-18 09:52:46 UTC; Jose</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2021-03-20 23:20:09 UTC</td>
</tr>
</table>
<hr>
<h2 id='multimode-package'>
Mode testing and exploring.
</h2><span id='topic+multimode-package'></span><span id='topic+multimode'></span>

<h3>Description</h3>

<p>Different examples and methods for testing (including different proposals described in Ameijeiras-Alonso et al., 2019 &lt;DOI:10.1007/s11749-018-0611-5&gt;) and exploring (including the mode tree, mode forest and SiZer map) the number of modes using nonparametric techniques &lt;DOI:10.18637/jss.v097.i09&gt;.
</p>


<h3>Details</h3>


<table>
<tr>
 <td style="text-align: left;">
Package: </td><td style="text-align: left;"> multimode</td>
</tr>
<tr>
 <td style="text-align: left;">
Type: </td><td style="text-align: left;"> Package</td>
</tr>
<tr>
 <td style="text-align: left;">
Version: </td><td style="text-align: left;"> 1.5</td>
</tr>
<tr>
 <td style="text-align: left;">
Date: </td><td style="text-align: left;"> 2021-03-17</td>
</tr>
<tr>
 <td style="text-align: left;">
License: </td><td style="text-align: left;"> GPL-3</td>
</tr>
<tr>
 <td style="text-align: left;">
NeedsCompilation: </td><td style="text-align: left;"> yes</td>
</tr>
<tr>
 <td style="text-align: left;">
LazyData: </td><td style="text-align: left;"> yes</td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>

<p>This package incorporates the function <code>modetest</code> which tests if the number of modes of a sample is equal to a given number (against if it is greater).
Functions <code>bw.crit</code> and <code>excessmass</code> provide the critical bandwidth and the excess mass statistic, respectively.
Function <code>nmodes</code> computes the number of modes for a given bandwidth. Given a certain number of modes, function <code>locmodes</code> provides the estimation of the locations of modes and antimodes and their density value.
Functions <code>modetree</code> and <code>modeforest</code> provide the mode tree and forest, respectively; they represent the estimated mode locations for different bandwidths. Function <code>sizer</code> can be used for determining where the smoothed curve is significantly increasing or decreasing. Registries with missing data are removed.
For a complete list of functions, use <code>library(help="multimode")</code>.
</p>


<h3>Acknowledgements</h3>

<p> This work has been supported by Projects MTM2016&ndash;76969&ndash;P (Spanish State Research Agency, AEI) and MTM2013&ndash;41383&ndash;P (Spanish Ministry of Economy, Industry and Competitiveness), both co&ndash;funded by the European Regional Development Fund (ERDF), IAP network (Developing crucial Statistical methods for Understanding major complex Dynamic Systems in natural, biomedical and social sciences, StUDyS) from Belgian Science Policy. Work of J. Ameijeiras-Alonso has been supported by the PhD grant BES-2014-071006 from the Spanish Ministry of Economy and Competitiveness.</p>


<h3>References</h3>

<p>Ameijeiras-Alonso, J., Crujeiras, R.M. and Rodríguez-Casal, A. (2019). Mode testing, critical bandwidth and excess mass, <em>Test</em>, <b>28</b>, 900&ndash;919.
</p>
<p>Ameijeiras-Alonso, J., Crujeiras, R.M. and Rodríguez-Casal, A. (2021). multimode: An R Package for Mode Assessment, <em>Journal of Statistical Software</em>, <b>97</b>, 1&ndash;32.
</p>
<p>Chaudhuri, P. and Marron, J. S. (1999). SiZer for exploration of structures in curves, <em>Journal of the American Statistical Association</em>, <b>94</b>, 807&ndash;823.
</p>
<p>Minnotte, M. C., Marchette, D. J. and Wegman, E. J. (1998). The bumpy road to the mode forest, <em>Journal of Computational and Graphical Statistics</em>, <b>7</b>, 239&ndash;251.
</p>

<hr>
<h2 id='acidity'> Acid-neutralizing capacity </h2><span id='topic+acidity'></span>

<h3>Description</h3>

<p>This dataset, analyzed by Crawford (1994), contains the Acid-Neutralizing Capacity (ANC) measured in a sample of 155
lakes in North-Central Wisconsin (USA). ANC describes the capability of a lake to absorb acid, where low ANC values may lead to a loss of biological resources.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(acidity)
</code></pre>


<h3>Format</h3>

<p><code>acidity</code> includes an acidity index of lakes in north-central Wisconsin on the log scale, in particular, it is provided the log(ANC+50) as in Crawford (1994).
</p>


<h3>Details</h3>

<p>This is a classic example for determining the number of modes.
</p>


<h3>Source</h3>

<p>Obtained from the Supplementary material of Richardson and Green (1997), available in <a href="http://www.stats.bris.ac.uk/~peter/mixdata">http://www.stats.bris.ac.uk/~peter/mixdata</a>.
</p>


<h3>References</h3>

<p>Crawford (1994). An application of the Laplace method to finite mixture distributions. <em>Journal of the American Statistical Association</em>, <b>89</b>, 259&ndash;267.
</p>
<p>Richardson, S. and Green, P. J. (1997). On Bayesian analysis of mixtures with unknown number of components (with discussion). <em>Journal of the Royal Statistical Society, Series B</em>, <b>59</b>, 731&ndash;792.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("acidity")
# Kernel density estimation with two modes and SiZer
locmodes(acidity,mod0=2,display=TRUE,xlab="log(ANC+50)")
sizer(acidity,bws=c(0.1,1),xlab="log(ANC+50)")
</code></pre>

<hr>
<h2 id='bw.crit'> Critical bandwidth </h2><span id='topic+bw.crit'></span>

<h3>Description</h3>

<p>This function computes the critical bandwidth for a specified number of modes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bw.crit(data,mod0=1,lowsup=-Inf,uppsup=Inf,n=2^15,tol=10^(-5),full.result=F)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bw.crit_+3A_data">data</code></td>
<td>
<p> Sample for computing the critical bandwidth.</p>
</td></tr>
<tr><td><code id="bw.crit_+3A_mod0">mod0</code></td>
<td>
<p> Number of modes for which the critical bandwidth is calculated. Default <code>mod0=1</code>.</p>
</td></tr>
<tr><td><code id="bw.crit_+3A_lowsup">lowsup</code></td>
<td>
<p> Lower limit for the random variable support in the computation of the  critical bandwidth. Default is <code>-Inf</code>.</p>
</td></tr>
<tr><td><code id="bw.crit_+3A_uppsup">uppsup</code></td>
<td>
<p> Upper limit for the random variable support in the computation of the critical bandwidth. Default is <code>Inf</code>.</p>
</td></tr>
<tr><td><code id="bw.crit_+3A_n">n</code></td>
<td>
<p> The number of equally spaced points at which the density is estimated. When n &gt; 512, it is rounded up to a power of 2 as in the <code><a href="stats.html#topic+density">density</a></code> function. Default <code>n=2^15</code>.</p>
</td></tr>
<tr><td><code id="bw.crit_+3A_tol">tol</code></td>
<td>
<p> Accuracy requested in the computation of the critical bandwidth. Default value of <code>tol</code> is <code>10^(-5)</code>.</p>
</td></tr>
<tr><td><code id="bw.crit_+3A_full.result">full.result</code></td>
<td>
<p> If this argument is TRUE then it returns the full result list, see below. Default <code>full.result=FALSE</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>With <code>bw.crit</code> the critical bandwidth for the number of modes specified in <code>mod0</code> is calculated, e.g., the smallest bandwidth such that the kernel density estimator has at most <code>mod0</code> modes. If the compact support is unknown, the critical bandwidth introduced by Silverman (1981) is computed and if it is provided that one of Hall and York (2001) is calculated.
</p>
<p>Since a dichotomy method is employed for computing the critical bandwidth, the parameter <code>tol</code> is used to determine a stopping time in such a way that the error committed in the computation of the critical bandwidth is less than <code>tol</code>.
</p>
<p>The NAs will be automatically removed.
</p>


<h3>Value</h3>

<p>Depending on <code>full.result</code> either a number, the critical bandwidth of the sample for <code>mod0</code> modes, or an object of class <code>"estmod"</code> which is a <code>list</code> containing the following components:
</p>
<table>
<tr><td><code>nmodes</code></td>
<td>
<p> The specified hypothesized value of the number of modes.</p>
</td></tr>
<tr><td><code>sample.size</code></td>
<td>
<p> The number of non-missing observations in the sample used for computing the number of modes.</p>
</td></tr>
<tr><td><code>bw</code></td>
<td>
<p> Value of the critical bandwidth test statistic.</p>
</td></tr>
<tr><td><code>lowsup</code></td>
<td>
<p> Lower limit of the support where the critical bandwidth is computed.</p>
</td></tr>
<tr><td><code>ippsup</code></td>
<td>
<p> Upper limit of the support where the critical bandwidth is computed.</p>
</td></tr>
<tr><td><code>fnx</code></td>
<td>
<p> The <code>n</code> coordinates of the points where the density is estimated for computing the critical bandwidth.</p>
</td></tr>
<tr><td><code>fny</code></td>
<td>
<p> The estimated density values.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p> Jose Ameijeiras-Alonso, Rosa M. Crujeiras and Alberto Rodríguez-Casal</p>


<h3>References</h3>

<p>Hall, P. and York, M. (2001).  On the calibration of Silverman's test for multimodality, <em>Statistica Sinica</em>, <b>11</b>, 515&ndash;536.
</p>
<p>Silverman, B. W. (1981). Using kernel density estimates to investigate multimodality, <em>Journal of the Royal Statistical Society. Series B</em>, <b>43</b>, 97&ndash;99.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Critical bandwidth of Silverman (1981) for one mode.
set.seed(2016)
data=rnorm(50)
bw.crit(data)
# Critical bandwidth of Hall and York for two modes in the interval (-1.5,1.5).
set.seed(2016)
data=rnorm(50)
bw.crit(data,mod0=2,lowsup=-1.5,uppsup=1.5)
</code></pre>

<hr>
<h2 id='chondrite'> Percentage of silica in chondrite meteors </h2><span id='topic+chondrite'></span><span id='topic+chondritegg'></span><span id='topic+chondritel'></span>

<h3>Description</h3>

<p>This dataset contains the percentage silica (in %) in 22 chondrite meteors.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(chondrite)
</code></pre>


<h3>Format</h3>

<p><code>chondrite</code> and <code>chondritegg</code> include the data provided in Good and Gaskins  (1980). In <code>chondrite</code>, the typo in the 9th observation was corrected while <code>chondritegg</code> includes the original dataset. In <code>chondritel</code> is included the scaled data used by Leonard (1978).
</p>


<h3>Details</h3>

<p>This is a classic example for determining the number of modes.
</p>


<h3>Source</h3>

<p>Obtained from the Table 2 of Good and Gaskins (1980).
</p>


<h3>References</h3>

<p>Good, I. J. and Gaskins, R. A. (1980). Density estimation and bump-hunting by the penalized likelihood method exemplified by scattering and meteorite data. <em>Journal of the American Statistical Association</em>, <b>75</b>, 42&ndash;56.
</p>
<p>Leonard, T. (1978). Density estimation, stochastic processes and prior information. <em>Journal of the Royal Statistical Society. Series B (Methodological)</em>, <b>40</b>, 113&ndash;146.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("chondrite")
# SiZer between the critical bandwidths for one and six modes
sizer(chondrite,cbw1=1,cbw2=6)

</code></pre>

<hr>
<h2 id='enzyme'> Blood enzymatic activity </h2><span id='topic+enzyme'></span>

<h3>Description</h3>

<p>This dataset concerns the distribution of enzymatic activity in the blood, for an enzyme involved in the metabolism of carcinogenic substances.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(enzyme)
</code></pre>


<h3>Format</h3>

<p><code>enzyme</code> includes the values of the urinary metabolic ratio of 5&ndash;acetylamino&ndash;6&ndash;formylamino&ndash;3&ndash;methyluracil to 1&ndash;methylxanthine (AFMU/1X) after oral administration of caffeine.
</p>


<h3>Details</h3>

<p>This is a classic example for determining the number of modes.
</p>


<h3>Source</h3>

<p>Obtained from the Supplementary material of Richardson and Green (1997), available in <a href="http://www.stats.bris.ac.uk/~peter/mixdata">http://www.stats.bris.ac.uk/~peter/mixdata</a>.
</p>


<h3>References</h3>

<p>Bechtel, Y. C., Bonaiti-Pellie, C., Poisson, N., Magnette, J. and Bechtel, P. R. (1993). A population and family study N&ndash;acetyltransferase using caffeine urinary metabolites. <em>Clinical Pharmacology and Therapeutics</em>, <b>54</b>, 134&ndash;141.
</p>
<p>Richardson, S. and Green, P. J. (1997). On Bayesian analysis of mixtures with unknown number of components (with discussion). <em>Journal of the Royal Statistical Society, Series B</em>, <b>59</b>, 731&ndash;792.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("enzyme")
# It can be seen that there are two groups in this dataset
# Via exploratory tools
sizer(enzyme,bws=c(0.03,1))
modetree(enzyme,bws=c(0.02,1),logbw=TRUE,addplot=TRUE,col.lines="white")
#Via mode testing
modetest(enzyme)
## Not run: 
modetest(enzyme,mod0=2)

## End(Not run)
</code></pre>

<hr>
<h2 id='excessmass'> Excess mass </h2><span id='topic+excessmass'></span>

<h3>Description</h3>

<p>This function computes the excess mass statistic.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>excessmass(data,mod0=1,approximate=FALSE,gridsize=NULL,full.result=F)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="excessmass_+3A_data">data</code></td>
<td>
<p> Sample for computing the excess mass.</p>
</td></tr>
<tr><td><code id="excessmass_+3A_mod0">mod0</code></td>
<td>
<p> Number of modes for which the excess mass is calculated. Default <code>mod0=1</code>.</p>
</td></tr>
<tr><td><code id="excessmass_+3A_approximate">approximate</code></td>
<td>
<p> If this argument is TRUE then the excess mass value is approximated. Default <code>approximate=FALSE</code>.</p>
</td></tr>
<tr><td><code id="excessmass_+3A_gridsize">gridsize</code></td>
<td>
<p> When <code>approximate=TRUE</code>, number of endpoints at which the <code class="reqn">C_m(\lambda)</code> sets are estimated (first element) and number of possible values of <code class="reqn">\lambda</code> (second element). Default is <code>gridsize=c(20,20)</code>.</p>
</td></tr>
<tr><td><code id="excessmass_+3A_full.result">full.result</code></td>
<td>
<p> If this argument is TRUE then it returns the full result list, see below. Default <code>full.result=FALSE</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>With <code>excessmass</code>, the excess mass test statistic, introduced by Müller and Sawitzki (1991), for the integer number of modes specified in <code>mod0</code> is computed.
</p>
<p>The excess mass test statistic for k modes is defined as <code class="reqn">\max_{\lambda} \{D_{n,k+1}(\lambda)\}</code>, where <code class="reqn">D_{n,k+1}(\lambda)=(E_{n,k+1}(P_n,\lambda)-E_{n,k}(P_n,\lambda))</code>. The empirical excess mass function for <code class="reqn">k</code> modes is defined as <code class="reqn">E_{n,k}(P_n,\lambda)=\sup_{C_1(\lambda),\ldots,C_k(\lambda)} \{\sum_{m=1}^k P_n (C_m(\lambda)) - \lambda ||C_m(\lambda)|| \}</code>, being the sets <code class="reqn">C_m(\lambda)</code> closed intervals with endpoints the data points.
</p>
<p>When <code>mod0&gt;1</code> and the sample size is <em>large</em>, a two-steps approximation (<code>approximate=TRUE</code>) can be performed in order to improve the computing time efficiency. First, since the possible <code class="reqn">\lambda</code> candidates to maximize <code class="reqn">D_{n,k+1}(\lambda)</code> can be directly obtained from the sets that maximize <code class="reqn">E_{n,k+1}</code> and <code class="reqn">E_{n,k}</code> (see Section SM5 of Supplementary Material in Ameijeiras-Alonso <em>et al.</em>, 2019), the possible values of <code class="reqn">\lambda</code> are computed by looking to the empirical excess mass function in <code>gridsize[1]</code> endpoints candidates for <code class="reqn">C_m(\lambda)</code> and also in the <code class="reqn">\lambda</code> values associated to the empirical excess mass for one mode. Once a <code class="reqn">\lambda</code> maximizing the approximated values of <code class="reqn">D_{n,k+1}(\lambda)</code> is chosen, in order to obtain the approximation of the excess mass test statistic, in its neighborhood, a grid of possible values of <code class="reqn">\lambda</code> is created, being its length equal to <code>gridsize[2]</code>, and the exact value of <code class="reqn">D_{n,k+1}(\lambda)</code> is calculated for these values of <code class="reqn">\lambda</code> (using the algorithm proposed by Müller and Sawitzki, 1991).
</p>
<p>If there are repeated data in the sample or the distance between different pairs of data points shows ties, a data perturbation is applied. This modification is made in order to avoid the discretization of the data which has important effects on the computation of the test statistic. The perturbed sample is obtained by adding a sample from the uniform distribution in minus/plus a half of the minimum of the positive distances between two sample points.
</p>
<p>The NAs will be automatically removed.
</p>


<h3>Value</h3>

<p>Depending on <code>full.result</code> either a number, the excess mass statistic for <code>mod0</code> modes, or an object of class <code>"estmod"</code> which is a <code>list</code> containing the following components:
</p>
<table>
<tr><td><code>nmodes</code></td>
<td>
<p> The specified hypothesized value of the number of modes.</p>
</td></tr>
<tr><td><code>sample.size</code></td>
<td>
<p> The number of non-missing observations in the sample used for computing the excess mass.</p>
</td></tr>
<tr><td><code>excess.mass</code></td>
<td>
<p> Value of the excess mass test statistic.</p>
</td></tr>
<tr><td><code>approximate</code></td>
<td>
<p> A logical value indicating if the excess mass was approximated.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p> Jose Ameijeiras-Alonso, Rosa M. Crujeiras and Alberto Rodríguez-Casal</p>


<h3>References</h3>

<p>Ameijeiras-Alonso, J., Crujeiras, R.M. and Rodríguez-Casal, A. (2019). Mode testing, critical bandwidth and excess mass, <em>Test</em>, <b>28</b>, 900&ndash;919.
</p>
<p>Ameijeiras-Alonso, J., Crujeiras, R.M. and Rodríguez-Casal, A. (2021). multimode: An R Package for Mode Assessment, <em>Journal of Statistical Software</em>, <b>97</b>, 1&ndash;32.
</p>
<p>Müller, D. W. and Sawitzki, G. (1991). Excess mass estimates and tests for multimodality, <em>The Annals of Statistics</em>, <b>13</b>, 70&ndash;84.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Excess mass statistic for one mode
set.seed(2016)
data=rnorm(50)
excessmass(data)
</code></pre>

<hr>
<h2 id='galaxy'> Velocities of galaxies diverging away from our own galaxy </h2><span id='topic+galaxy'></span><span id='topic+galaxyp'></span><span id='topic+galaxyrg'></span>

<h3>Description</h3>

<p>This dataset contains the velocities in km/sec of different galaxies from the unfilled survey of the Corona Borealis region.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(galaxy)
</code></pre>


<h3>Format</h3>

<p><code>galaxy</code> includes the original measures in Roeder (1990). <code>galaxyrg</code> includes the data provided in the Supplementary material of Richardson and Green (1997), where the velocities are divided by 1000 and the 78th observation was replaced by 26690 km/sec. <code>galaxyp</code> add a measurement of 5607 km/sec included in Postman <em>et al.</em> (1986).
</p>


<h3>Details</h3>

<p>This is a classic example for determining the number of modes.
</p>


<h3>Source</h3>

<p>Obtained from the Table 1 of Postman <em>et al.</em> (1986), Table 1 of Roeder (1990) and the Supplementary material of Richardson and Green (1997), available in <a href="http://www.stats.bris.ac.uk/~peter/mixdata">http://www.stats.bris.ac.uk/~peter/mixdata</a>.
</p>


<h3>References</h3>

<p>Postman, M., Huchra, J. P. and Geller, M. J. (1986). Probes of large-scale structures in the Corona Borealis region. <em>Astronomical Journal</em>, <b>92</b>, 1238&ndash;1247.
</p>
<p>Richardson, S. and Green, P. J. (1997). On Bayesian analysis of mixtures with unknown number of components (with discussion). <em>Journal of the Royal Statistical Society, Series B</em>, <b>59</b>, 731&ndash;792.
</p>
<p>Roeder, K. (1990). Density estimation with confidence sets exemplified by superclusters and voids in the galaxies. <em>Journal of the American Statistical Association</em>, <b>85</b>, 617&ndash;624.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("galaxy")
# Mode tree between the critical bandwidths for one and six modes
modetree(galaxy,cbw1=1,cbw2=6)

</code></pre>

<hr>
<h2 id='geyser'> Waiting time between geyser eruptions </h2><span id='topic+geyser'></span><span id='topic+geyserab'></span><span id='topic+geyserh'></span><span id='topic+geyserw'></span>

<h3>Description</h3>

<p>This dataset contains the interval times between the starts of the geyser eruptions on the Old Faithful Geyser in Yellowstone National Park, Wyoming, USA.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(geyser)
data(geyserab)
data(geyserh)
data(geyserw)
</code></pre>


<h3>Format</h3>

<p><code>geyser</code>, <code>geyserh</code> and <code>geyserw</code> include data collected in October 1980. <code>geyser</code> and <code>geyserh</code> were obtained from Table 3 of Härdle (2012), in <code>geyser</code> some repeated data are removed. <code>geyserw</code> was obtained from the Supplementary material of Weisberg (2005). <code>geyserab</code> include data collected in August 1985 from Table 1 in Azzalini and Bowman (1990).
</p>


<h3>Details</h3>

<p>This is a classic example for estimating the density.
</p>


<h3>Source</h3>

<p>Obtained from the original tables in Azzalini and Bowman (1990), Härdle (2012) and Supplementary material of Weisberg (2005).
</p>


<h3>References</h3>

<p>Azzalini, A. and Bowman, A. W. (1990). A look at some data on the Old Faithful geyser. <em>Applied Statistics</em>, <b>39</b>, 357&ndash;365.
</p>
<p>Härdle, W. (1991). <em>Smoothing techniques: with implementation in S</em>. New York: Springer-Verlag.
</p>
<p>Weisberg, S. (2005). <em>Applied Linear Regression</em>. New York: Wiley.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("geyser")
# Kernel density estimation with two modes
locmodes(geyser,mod0=2,display=TRUE)

</code></pre>

<hr>
<h2 id='locmodes'> Location of modes and antimodes </h2><span id='topic+locmodes'></span><span id='topic+plot.locmod'></span><span id='topic+print.locmod'></span>

<h3>Description</h3>

<p>Given a certain number of modes, this function provides the estimation of the location of modes and antimodes and their density value.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>locmodes(data,mod0=1,lowsup=-Inf,uppsup=Inf,n=2^15,tol=10^(-5),display=F,...)

## S3 method for class 'locmod'
plot(x,addplot=NULL,xlab=NULL,ylab=NULL,addLegend=NULL,posLegend=NULL,...)

## S3 method for class 'locmod'
print(x,digits=getOption("digits"), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="locmodes_+3A_data">data</code></td>
<td>
<p> Sample in which the critical bandwidth is computed.</p>
</td></tr>
<tr><td><code id="locmodes_+3A_mod0">mod0</code></td>
<td>
<p> Number of modes for which the critical bandwidth is calculated. Default <code>mod0=1</code>.</p>
</td></tr>
<tr><td><code id="locmodes_+3A_lowsup">lowsup</code></td>
<td>
<p> Lower limit for the random variable support in the computation of the  critical bandwidth. Default is <code>-Inf</code>.</p>
</td></tr>
<tr><td><code id="locmodes_+3A_uppsup">uppsup</code></td>
<td>
<p> Upper limit for the random variable support in the computation of the critical bandwidth. Default is <code>Inf</code>.</p>
</td></tr>
<tr><td><code id="locmodes_+3A_n">n</code></td>
<td>
<p> The number of equally spaced points at which the density is to be estimated. When n &gt; 512, it is rounded up to a power of 2 as in the <code>density</code> function. Default <code>n=2^15</code>.</p>
</td></tr>
<tr><td><code id="locmodes_+3A_tol">tol</code></td>
<td>
<p> Accuracy requested in the computation of the critical bandwidth. Default value <code>tol=10^(-5)</code>.</p>
</td></tr>
<tr><td><code id="locmodes_+3A_display">display</code></td>
<td>
<p> Logical, if <code>TRUE</code> the kernel density estimation is plotted adding the estimated location of the modes and the antimodes. Default is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="locmodes_+3A_...">...</code></td>
<td>
<p> Arguments to be passed to subsequent methods, <code><a href="graphics.html#topic+plot.default">plot.default</a></code> for the <code>plot</code> method and <code><a href="base.html#topic+formatC">formatC</a></code> for the <code>print</code> method.</p>
</td></tr>
<tr><td><code id="locmodes_+3A_x">x</code></td>
<td>
<p> An object inheriting from class <code>"locmod"</code>.</p>
</td></tr>
<tr><td><code id="locmodes_+3A_addplot">addplot</code></td>
<td>
<p> Logical, if <code>TRUE</code> the plot is added to the current one. Default is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="locmodes_+3A_xlab">xlab</code></td>
<td>
<p> A title for the x axis. See <code>title</code>.</p>
</td></tr>
<tr><td><code id="locmodes_+3A_ylab">ylab</code></td>
<td>
<p> A title for the y axis. See <code>title</code>.</p>
</td></tr>
<tr><td><code id="locmodes_+3A_addlegend">addLegend</code></td>
<td>
<p> Logical, if <code>TRUE</code> the legend is added in the plot. Default is <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="locmodes_+3A_poslegend">posLegend</code></td>
<td>
<p> The vector of two elements of coordinates to be used to position the legend. It can be specified by keyword as in the function <code>legend</code>. Default is <code>"topright"</code>.</p>
</td></tr>
<tr><td><code id="locmodes_+3A_digits">digits</code></td>
<td>
<p> Number of significant digits to use, see <code><a href="base.html#topic+formatC">formatC</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Given a certain number of modes, <code>mod0</code>, with <code>locmodes</code> the estimation of the location of modes and antimodes, their density value and the corresponding critical bandwidth is provided. To obtain these estimates, the kernel density estimation with gaussian kernel and the critical bandwidth for <code>mod0</code> modes is employed. If the compact support is unknown, the critical bandwidth of Silverman (1981) is computed and if such a support is provided, then the one proposed by Hall and York (2001) is calculated. Note that when the support is unknown the critical bandwidth may create artificial modes in the tails.
</p>
<p>Since a dichotomy method is employed for computing the critical bandwidth, the parameter <code>tol</code> is used to determine a stopping time in such a way that the error committed in the computation of the critical bandwidth is less than <code>tol</code>.
</p>
<p>If <code>display=TRUE</code>, then the kernel density estimation using the critical bandwidth for <code>mod0</code> modes is plotted. Additionally, the estimated location of modes (dashed lines), antimodes (point lines) and support (solid lines) can be also plotted. If <code>addLegend=TRUE</code>, a legend (in the position <code>posLegend</code>) with this information is included.
</p>
<p>The NAs will be automatically removed.
</p>


<h3>Value</h3>

<p>A list with class <code>"locmod"</code> containing the following components:
</p>
<table>
<tr><td><code>locations</code></td>
<td>
<p> Vector with the estimated locations of modes (odd positions of the vector) and antimodes (even positions). </p>
</td></tr>
<tr><td><code>fvalue</code></td>
<td>
<p> Vector with estimated density values at modes (odd positions of the vector) and antimodes (even positions).</p>
</td></tr>
<tr><td><code>cbw</code></td>
<td>
<p> A list with class <code>"estmod"</code> which contains the critical bandwidth of the sample for <code>mod0</code> modes, see <code><a href="#topic+bw.crit">bw.crit</a></code>.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p> Jose Ameijeiras-Alonso, Rosa M. Crujeiras and Alberto Rodríguez-Casal</p>


<h3>References</h3>

<p>Ameijeiras-Alonso, J., Crujeiras, R.M. and Rodríguez-Casal, A. (2019). Mode testing, critical bandwidth and excess mass, <em>Test</em>, <b>28</b>, 900&ndash;919.
</p>
<p>Ameijeiras-Alonso, J., Crujeiras, R.M. and Rodríguez-Casal, A. (2021). multimode: An R Package for Mode Assessment, <em>Journal of Statistical Software</em>, <b>97</b>, 1&ndash;32.
</p>
<p>Hall, P. and York, M. (2001).  On the calibration of Silverman's test for multimodality, <em>Statistica Sinica</em>, <b>11</b>, 515&ndash;536.
</p>
<p>Silverman, B. W. (1981). Using kernel density estimates to investigate multimodality, <em>Journal of the Royal Statistical Society. Series B</em>, <b>43</b>, 97&ndash;99.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Testing for unimodality
set.seed(2016)
data=rnorm(50)
modetest(data)
#There is no evidence to reject the null hypothesis of unimodality
#Estimated location of the mode and its density value
locmodes(data)
## Not run: 
#Estimated locations of the five modes in the claw of Marron and Wand (1992)
library(nor1mix)
set.seed(2016)
n&lt;-200
data&lt;-nor1mix::rnorMix(n,MW.nm10)
#Adding the plot of the estimated locations
locmodes(data,5,display=T)
#Assuming that the compact support is [-1.5,1.5]
locmodes(data,5,-1.5,1.5,display=T)

## End(Not run)
</code></pre>

<hr>
<h2 id='modeforest'> Mode forest </h2><span id='topic+modeforest'></span>

<h3>Description</h3>

<p>This function provides the mode forest.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>modeforest(data,bws=NULL,gridsize=NULL,B=99,n=512,cbw1=NULL,cbw2=NULL,
display=TRUE,logbw=FALSE,from=NULL,to=NULL,logbw.regulargrid=NULL,...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="modeforest_+3A_data">data</code></td>
<td>
<p> Sample in which the mode forest is computed.</p>
</td></tr>
<tr><td><code id="modeforest_+3A_bws">bws</code></td>
<td>
<p> Vector or range of bandwidths. If it is a vector of size two, then it is used a grid of bandwidths between the given values. Default lower bandwidth is twice the distance between the grid points used for estimating the density and upper bandwidth equal to the range of the data. Unless it is specified a vector of size greater than two, the number of bandwidths employed is equal to the second element of <code>gridsize</code>.</p>
</td></tr>
<tr><td><code id="modeforest_+3A_gridsize">gridsize</code></td>
<td>
<p> Number of grid points in the horizontal (values of the variable, first element) and vertical (bandwidths, second element) axis. Default is <code>c(100,151)</code>.</p>
</td></tr>
<tr><td><code id="modeforest_+3A_b">B</code></td>
<td>
<p> Number of replicates used for generating the mode forest. Default <code>B=99</code>.</p>
</td></tr>
<tr><td><code id="modeforest_+3A_n">n</code></td>
<td>
<p> The number of equally spaced points at which the density is to be estimated. When n &gt; 512, it is rounded up to a power of 2 as in the <code>density</code> function. Default <code>n=512</code>.</p>
</td></tr>
<tr><td><code id="modeforest_+3A_cbw1">cbw1</code></td>
<td>
<p> Number of modes for which the first critical bandwidth is calculated. This is the first bandwidth used to compute the mode tree when <code>bws</code> is not specified.</p>
</td></tr>
<tr><td><code id="modeforest_+3A_cbw2">cbw2</code></td>
<td>
<p> Number of modes for which the second critical bandwidth is calculated. This is the last bandwidth used to compute the mode tree when <code>bws</code> is not specified.</p>
</td></tr>
<tr><td><code id="modeforest_+3A_display">display</code></td>
<td>
<p> Logical, if <code>TRUE</code> the mode tree plot is plotted. Default <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="modeforest_+3A_logbw">logbw</code></td>
<td>
<p> Logical, if <code>TRUE</code> the plot displays and returns the log10 bandwidths. Default <code>logbw=FALSE</code>.</p>
</td></tr>
<tr><td><code id="modeforest_+3A_from">from</code></td>
<td>
<p> First plotted value of the variable. Default is below the data minimum.</p>
</td></tr>
<tr><td><code id="modeforest_+3A_to">to</code></td>
<td>
<p> Last plotted value of the variable. Default is above the data maximum.</p>
</td></tr>
<tr><td><code id="modeforest_+3A_logbw.regulargrid">logbw.regulargrid</code></td>
<td>
<p> Logical, if <code>TRUE</code> a regular grid of bandwidths is created over the log10 scale. Default <code>logbw.regulargrid=FALSE</code>.</p>
</td></tr>
<tr><td><code id="modeforest_+3A_...">...</code></td>
<td>
<p> Arguments to be passed to subsequent methods, <code><a href="#topic+plot.gtmod">plot.gtmod</a></code> for the <code>plot</code>, <code>print</code> and <code>summary</code> methods.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The mode forest for the sample given in <code>data</code> is computed. For this calculation, a kernel density estimator with Gaussian kernel and bandwidths <code>bws</code> is used. The mode forest is generated by looking simultaneously at a collection of mode trees generated by the original sample and <code>B</code> random resamples drawn with replacement from <code>data</code>. When the mode forest is plotted, this tool represents the number of times an estimated mode falls in each location-bandwidth (horizontal-vertical axis) pixel. The pixels are then shaded  proportionally to counts (large counts corresponding to darker pixels and low counts to lighter ones).
</p>
<p>The NAs will be automatically removed.
</p>


<h3>Value</h3>

<p>A list with class <code>"gtmod"</code> containing the following components:
</p>
<table>
<tr><td><code>modeforest</code></td>
<td>
<p> Matrix including the percentage of times that a mode tree falls in each location-bandwidth pixel.</p>
</td></tr>
<tr><td><code>range.x</code></td>
<td>
<p> Employed location values to represent the mode forest.</p>
</td></tr>
<tr><td><code>range.bws</code></td>
<td>
<p> Employed bandwidths to compute the different mode trees.</p>
</td></tr>
<tr><td><code>logbw</code></td>
<td>
<p> Logical value indicating if the bandwidths are given in the log10 scale.</p>
</td></tr>
<tr><td><code>sample.size</code></td>
<td>
<p> The number of non-missing observations in the sample used for obtaining the mode forest.</p>
</td></tr>
<tr><td><code>call</code></td>
<td>
<p> The unevaluated expression, which consists of the named function applied to the given arguments.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p> Jose Ameijeiras-Alonso, Rosa M. Crujeiras and Alberto Rodríguez-Casal</p>


<h3>References</h3>

<p>Minnotte, M. C., Marchette, D. J. and Wegman, E. J. (1998). The bumpy road to the mode forest, <em>Journal of Computational and Graphical Statistics</em>, <b>7</b>, 239&ndash;251.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#Mode forest using a grid of bandwidths between 0.2 and 0.5 and 29 bootstrap replicas
set.seed(2016)
data=rnorm(50)
modeforest(data,bws=c(0.2,0.5),B=29)
#Original mode tree for this sample
modetree(data,bws=c(0.2,0.5),addplot=TRUE,col.lines="red")
</code></pre>

<hr>
<h2 id='modetest'> Test for the number of modes </h2><span id='topic+modetest'></span>

<h3>Description</h3>

<p>This function tests the number of modes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>modetest(data,mod0=1,method="ACR",B=500,lowsup=-Inf,uppsup=Inf,
submethod=NULL,n=NULL,tol=NULL,tol2=NULL,gridsize=NULL,alpha=NULL,
nMC=NULL,BMC=NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="modetest_+3A_data">data</code></td>
<td>
<p> Sample to be tested.</p>
</td></tr>
<tr><td><code id="modetest_+3A_mod0">mod0</code></td>
<td>
<p> The maximum number of modes in the null hypothesis. Default <code>mod0=1</code> (unimodality vs. multimodality test).</p>
</td></tr>
<tr><td><code id="modetest_+3A_method">method</code></td>
<td>
<p> The method employed for testing the number of modes. Available methods are: SI (Silverman, 1981), HY (Hall and York, 2001), FM (Fisher and Marron, 2001), HH (Hartigan and Hartigan, 1985), CH (Cheng and Hall,1998), ACR (Ameijeiras-Alonso <em>et al.</em>, 2019). Default <code>method="ACR"</code>.</p>
</td></tr>
<tr><td><code id="modetest_+3A_b">B</code></td>
<td>
<p> Number of replicates used in the test. Default <code>B=500</code>.</p>
</td></tr>
<tr><td><code id="modetest_+3A_lowsup">lowsup</code></td>
<td>
<p> Lower limit for the random variable support in the computation of the  critical bandwidth. Default is <code>-Inf</code>.</p>
</td></tr>
<tr><td><code id="modetest_+3A_uppsup">uppsup</code></td>
<td>
<p> Upper limit for the random variable support in the computation of the critical bandwidth. Default is <code>Inf</code>.</p>
</td></tr>
<tr><td><code id="modetest_+3A_submethod">submethod</code></td>
<td>
<p> Different approaches when using <code>method</code> SI, HY or ACR. Available submethods are: 1 and 2, see Details below for more information. Default <code>submethod=1</code>, except when <code>mod0</code>&gt;1, <code>method</code> is ACR and the sample size is greater than 200.</p>
</td></tr>
<tr><td><code id="modetest_+3A_n">n</code></td>
<td>
<p> The number of equally spaced points at which the density is to be estimated. When n &gt; 512, it is rounded up to a power of 2 as for <code><a href="stats.html#topic+density">density</a></code> function. Default is <code>n=2^10</code> when <code>method</code> is SI, HY or FM and <code>n=2^15</code> when the <code>method</code> is CH or ACR. Argument not used for other methods.</p>
</td></tr>
<tr><td><code id="modetest_+3A_tol">tol</code></td>
<td>
<p> Accuracy for computing the critical bandwidth. Default <code>tol=10^(-5)</code>.</p>
</td></tr>
<tr><td><code id="modetest_+3A_tol2">tol2</code></td>
<td>
<p> Accuracy for integration of the calibration function in the <code>method</code> ACR when the support is known. Default <code>tol2=10^(-5)</code>.</p>
</td></tr>
<tr><td><code id="modetest_+3A_gridsize">gridsize</code></td>
<td>
<p> When the approximated version of the excess mass is employed in <code>method</code> ACR, number of endpoints at which the <code class="reqn">C_m(\lambda)</code> sets are estimated (first element) and number of possible values of <code class="reqn">\lambda</code> (second element). Default is <code>gridsize=c(20,20)</code>.</p>
</td></tr>
<tr><td><code id="modetest_+3A_alpha">alpha</code></td>
<td>
<p> Significance level employed for testing unimodality when method 1 of Hall and York (2001) is used. Default <code>alpha=0.05</code>.</p>
</td></tr>
<tr><td><code id="modetest_+3A_nmc">nMC</code></td>
<td>
<p> Number of Monte Carlo replicates used to approximate the p-value in the method 2 of Hall and York (2001). Default <code>nMC=100</code>.</p>
</td></tr>
<tr><td><code id="modetest_+3A_bmc">BMC</code></td>
<td>
<p> Number of bootstrap replicas used for computing the p-value in each Monte Carlo replicate of the Hall and York (2001) method 2. Default <code>BMC=100</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The number of modes for the underlying density of a sample given by <code>data</code> can be tested with <code>modetest</code>. The null hypothesis states that the sample has <code>mod0</code> modes, and the alternative hypothesis is if it has more modes. The test used for calculating the p-value is specified in <code>method</code>. All the available proposals require bootstrap or Monte Carlo resamples (number specified in <code>B</code>).
</p>
<p>Except when the support is employed, the typical usages are
</p>
<pre>
modetest(data,...)
modetest(data,mod0=1,method="ACR",B=500,...)
</pre>
<p>Since a dichotomy algorithm is employed for computing the critical bandwidth (methods SI, HY, FM, ACR), the parameter <code>tol</code> is used to determine a stopping time in such a way that the error committed in the computation of the critical bandwidth is less than <code>tol</code>.
</p>
<p>The sample data can be perturbed in the methods using the excess mass or the dip statistic (HH, CH and ACR) in order to avoid important effects on the computation of the test statistic. In general, the exact excess mass/dip value is employed, but also its approximated version can be used by setting <code>submethod=2</code> in <code>method</code> ACR. See <code><a href="#topic+excessmass">excessmass</a></code> Details for more information.
</p>
<p>Typical usages are
</p>
<pre>
modetest(data,mod0=1,method="ACR",B=500,submethod=1,n=NULL,tol=NULL)
modetest(data,mod0=1,method="ACR",B=500,submethod=2,n=NULL,tol=NULL,
gridsize=NULL)
</pre>
<p>When employing SI method, two ways of computing the resamples are available. If <code>submethod=1</code>, the resamples are generated from the rescaled bootstrap resamples as proposed by Silverman (1981). If <code>submethod=2</code>, as in <code>method</code> HY, the resamples are generated from the distribution that is associated to the kernel density estimation with the critical bandwidth.
</p>
<p>Typical usage is
</p>
<pre>
modetest(data,mod0=1,method="SI",B=500,submethod=NULL,n=NULL,tol=NULL)
</pre>
<p>If a compact support containing a mode is known, it can be used to compute the Hall and York (2001) critical bandwidth. Note that in the case of the test proposed by Hall and York (2001), this support should be known, unless the support of the density function is bounded. For their proposal, two methods are implemented. <code>submethod</code> 1 is an asymptotic correction of Silverman (1981) test based on the limiting distribution of the test statistic. When <code>submethod=1</code>, the significance level must be previously determined with <code>alpha</code>. <code>submethod</code> 2 is based on Monte Carlo techniques. For this reason, when <code>submethod=2</code>, the number of replicates (<code>nMC</code>) and the number of bootstrap replicates (<code>BMC</code>) used for computing the p-value in each Monte Carlo replicate are needed.
</p>
<p>Typical usages are
</p>
<pre>
modetest(data,method="HY",lowsup=-1.5,uppsup=1.5,...)
modetest(data,method="HY",B=500,lowsup=-1.5,uppsup=1.5,submethod=1,
n=NULL,tol=NULL,alpha=NULL)
modetest(data,method="HY",B=500,lowsup=-1.5,uppsup=1.5,submethod=2,
n=NULL,tol=NULL,nMC=NULL,BMC=NULL)
</pre>
<p>A modification of the proposal of Ameijeiras-Alonso <em>et al.</em> (2019) can be also applied, by setting <code>method=ACR</code> and including a known compact support for detecting the modes. The parameter <code>tol2</code> is the accuracy required in the integration of the calibration function. For more information, see Ameijeiras-Alonso <em>et al.</em> (2019), the default approach, when the support is unknown, is given in Section 2.3 and, when it is provided, the approach shown in the Appendix B is employed.
</p>
<p>Typical usage is
</p>
<pre>
modetest(data,mod0=1,method="ACR",B=500,lowsup=-1.5,uppsup=1.5,
submethod=NULL,n=NULL,tol=NULL,tol2=NULL,gridsize=NULL)
</pre>
<p>The NAs will be automatically removed.
</p>


<h3>Value</h3>

<p>A list with class <code>"htest"</code> containing the following components:
</p>
<table>
<tr><td><code>p.value</code></td>
<td>
<p> P-value obtained after applying the test.</p>
</td></tr>
<tr><td><code>statistic</code></td>
<td>
<p> Value of the test statistic. Critical bandwidth if the <code>method</code> is SI or HY; Cramer-von Mises statistic if the <code>method</code> is FM; the dip statistic if the <code>method</code> is HH, and the excess mass when the <code>method</code> is CH or ACR.</p>
</td></tr>
<tr><td><code>null.value</code></td>
<td>
<p> The specified hypothesized value of the number of modes.</p>
</td></tr>
<tr><td><code>alternative</code></td>
<td>
<p> A character string describing the alternative hypothesis, which is always <code>"greater"</code>.</p>
</td></tr>
<tr><td><code>method</code></td>
<td>
<p> A character string indicating what type of multimodality test was performed.</p>
</td></tr>
<tr><td><code>sample.size</code></td>
<td>
<p> The number of non-missing observations in the sample used for the hypothesis test.</p>
</td></tr>
<tr><td><code>data.name</code></td>
<td>
<p> A character string giving the name of the data.</p>
</td></tr>
<tr><td><code>bad.obs</code></td>
<td>
<p> The number of missing values that were removed from the data object prior to performing the hypothesis test.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p> Jose Ameijeiras-Alonso, Rosa M. Crujeiras and Alberto Rodríguez-Casal</p>


<h3>References</h3>

<p>Ameijeiras-Alonso, J., Crujeiras, R.M. and Rodríguez-Casal, A. (2019). Mode testing, critical bandwidth and excess mass, <em>Test</em>, <b>28</b>, 900&ndash;919.
</p>
<p>Ameijeiras-Alonso, J., Crujeiras, R.M. and Rodríguez-Casal, A. (2021). multimode: An R Package for Mode Assessment, <em>Journal of Statistical Software</em>, <b>97</b>, 1&ndash;32.
</p>
<p>Cheng, M. Y. and Hall, P. (1998). Calibrating the excess mass and dip tests of modality, <em>Journal of the Royal Statistical Society. Series B</em>, <b>60</b>, 579&ndash;589.
</p>
<p>Fisher, N.I. and Marron, J. S. (2001). Mode testing via the excess mass estimate,
<em>Biometrika</em>, <b>88</b>, 419&ndash;517.
</p>
<p>Hall, P. and York, M. (2001).  On the calibration of Silverman's test for multimodality, <em>Statistica Sinica</em>, <b>11</b>, 515&ndash;536.
</p>
<p>Hartigan, J. A. and Hartigan, P. M. (1985). The Dip Test of Unimodality,
<em>Journal of the American Statistical Association</em>, <b>86</b>, 738&ndash;746.
</p>
<p>Silverman, B. W. (1981). Using kernel density estimates to investigate multimodality, <em>Journal of the Royal Statistical Society. Series B</em>, <b>43</b>, 97&ndash;99.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Testing for unimodality
data(geyser)
data=geyser
modetest(data)
## Not run: 
# Testing bimodality using B=100 bootstrap replicas
modetest(data,mod0=2,B=100)
#There is no evidence to reject the null hypothesis of bimodality
locmodes(data,mod0=2,display=TRUE)

## End(Not run)
</code></pre>

<hr>
<h2 id='modetree'> Mode tree </h2><span id='topic+modetree'></span>

<h3>Description</h3>

<p>This function provides the mode tree.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>modetree(data,bws=NULL,gridsize=NULL,cbw1=NULL,cbw2=NULL,display=TRUE,
logbw=FALSE,logbw.regulargrid=NULL,...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="modetree_+3A_data">data</code></td>
<td>
<p> Sample in which the mode tree is computed.</p>
</td></tr>
<tr><td><code id="modetree_+3A_bws">bws</code></td>
<td>
<p> Vector or range of bandwidths. If it is a vector of size two, then it is used a grid of bandwidths between the given values. Default lower bandwidth is twice the distance between the grid points used for estimating the density and upper bandwidth equal to the range of the data. Unless it is specified a vector of size greater than two, the number of bandwidths employed is equal to the second element of <code>gridsize</code>.</p>
</td></tr>
<tr><td><code id="modetree_+3A_gridsize">gridsize</code></td>
<td>
<p> Number of equally spaced points at which the density is to be estimated (first element) and bandwidths used to compute the mode tree (second element). Default is <code>gridsize=c(512,151)</code>.</p>
</td></tr>
<tr><td><code id="modetree_+3A_cbw1">cbw1</code></td>
<td>
<p> Number of modes for which the first critical bandwidth is calculated. This is the first bandwidth used to compute the mode tree when <code>bws</code> is not specified.</p>
</td></tr>
<tr><td><code id="modetree_+3A_cbw2">cbw2</code></td>
<td>
<p> Number of modes for which the second critical bandwidth is calculated. This is the last bandwidth used to compute the mode tree when <code>bws</code> is not specified.</p>
</td></tr>
<tr><td><code id="modetree_+3A_display">display</code></td>
<td>
<p> Logical, if <code>TRUE</code> the mode tree plot is plotted. Default <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="modetree_+3A_logbw">logbw</code></td>
<td>
<p> Logical, if <code>TRUE</code> the plot displays and returns the log10 bandwidths. Default <code>logbw=FALSE</code>.</p>
</td></tr>
<tr><td><code id="modetree_+3A_logbw.regulargrid">logbw.regulargrid</code></td>
<td>
<p> Logical, if <code>TRUE</code> a regular grid of bandwidths is created over the log10 scale. Default <code>logbw.regulargrid=FALSE</code>.</p>
</td></tr>
<tr><td><code id="modetree_+3A_...">...</code></td>
<td>
<p> Arguments to be passed to subsequent methods, <code><a href="#topic+plot.gtmod">plot.gtmod</a></code> for the <code>plot</code>, <code>print</code> and <code>summary</code> methods.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The mode tree for the sample given in <code>data</code> is computed. For this calculation, a kernel density estimator with Gaussian kernel and bandwidths <code>bws</code> is used. When it is plotted, it shows with the continuous lines the estimated mode locations at each bandwidth. The horizontal dashed lines indicate the splitting of a mode in more modes.
</p>
<p>The NAs will be automatically removed.
</p>


<h3>Value</h3>

<p>A list with class <code>"gtmod"</code> containing the following components:
</p>
<table>
<tr><td><code>locations</code></td>
<td>
<p> Estimated mode locations for the bandwidths given in the row names.</p>
</td></tr>
<tr><td><code>range.x</code></td>
<td>
<p> The data range, employed to represent the mode tree.</p>
</td></tr>
<tr><td><code>range.bws</code></td>
<td>
<p> Employed bandwidths to compute the mode tree.</p>
</td></tr>
<tr><td><code>logbw</code></td>
<td>
<p> Logical value indicating if the bandwidths are given in the log10 scale.</p>
</td></tr>
<tr><td><code>sample.size</code></td>
<td>
<p> The number of non-missing observations in the sample used for obtaining the mode tree.</p>
</td></tr>
<tr><td><code>call</code></td>
<td>
<p> The unevaluated expression, which consists of the named function applied to the given arguments.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p> Jose Ameijeiras-Alonso, Rosa M. Crujeiras and Alberto Rodríguez-Casal</p>


<h3>References</h3>

<p>Minnotte, M. C. and Scott, D. W. (1993). The mode tree: A tool for visualization of nonparametric density features, <em>Journal of Computational and Graphical Statistics</em>, <b>2</b>, 51&ndash;68.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#Mode tree using a grid of bandwidths between 0.2 and 0.5
set.seed(2016)
data=rnorm(50)
modetree(data,bws=c(0.2,0.5))
## Not run: 
#Estimated locations of the five modes in the claw of Marron and Wand (1992)
library(nor1mix)
set.seed(2016)
n&lt;-200
data&lt;-nor1mix::rnorMix(n,MW.nm10)
#Mode tree between the critical bandwidths for 1 and 8 modes
modetree(data,cbw1=1,cbw2=8)
abline(v=1.5);abline(v=-1.5)

## End(Not run)
</code></pre>

<hr>
<h2 id='nmodes'> Number of modes </h2><span id='topic+nmodes'></span>

<h3>Description</h3>

<p>This function computes the number of modes in a kernel density estimator using the Gaussian kernel and a given bandwidth parameter.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>nmodes(data,bw,lowsup=-Inf,uppsup=Inf,n=2^15,full.result=F)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="nmodes_+3A_data">data</code></td>
<td>
<p> Sample for computing a kernel density estimator and determine the number of modes.</p>
</td></tr>
<tr><td><code id="nmodes_+3A_bw">bw</code></td>
<td>
<p> Bandwidth parameter for kernel density estimation.</p>
</td></tr>
<tr><td><code id="nmodes_+3A_lowsup">lowsup</code></td>
<td>
<p> Lower limit for the random variable support. Just the number of modes greater than <code>lowsup</code> are taken into account. Default is <code>-Inf</code>.</p>
</td></tr>
<tr><td><code id="nmodes_+3A_uppsup">uppsup</code></td>
<td>
<p> Upper limit for the random variable support. Just the number of modes greater than <code>lowsup</code> are taken into account. Default is <code>Inf</code>.</p>
</td></tr>
<tr><td><code id="nmodes_+3A_n">n</code></td>
<td>
<p> The number of equally spaced points at which the density is to be estimated. When n &gt; 512, it is rounded up to a power of 2 as in the <code><a href="stats.html#topic+density">density</a></code> function. Default <code>n=2^15</code>.</p>
</td></tr>
<tr><td><code id="nmodes_+3A_full.result">full.result</code></td>
<td>
<p> If this argument is TRUE then it returns the full result list, see below. Default <code>full.result=FALSE</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The number of modes in the interval provided by <code>lowsup</code> and <code>uppsup</code> is computed. For this calculation, a kernel density estimator with Gaussian kernel and bandwidth <code>bw</code> is used.
</p>
<p>The NAs will be automatically removed.
</p>


<h3>Value</h3>

<p>Depending on <code>full.result</code> either a number, the number of modes for the bandwidth provided in <code>bw</code>, or an object of class <code>"estmod"</code> which is a <code>list</code> containing the following components:
</p>
<table>
<tr><td><code>nmodes</code></td>
<td>
<p> The number of modes for the bandwidth provided in <code>bw</code>.</p>
</td></tr>
<tr><td><code>sample.size</code></td>
<td>
<p> The number of non-missing observations in the sample used for computing the number of modes.</p>
</td></tr>
<tr><td><code>bw</code></td>
<td>
<p> Employed bandwidth for  kernel density estimation.</p>
</td></tr>
<tr><td><code>lowsup</code></td>
<td>
<p> Lower limit of the support where the number of modes are computed.</p>
</td></tr>
<tr><td><code>ippsup</code></td>
<td>
<p> Upper limit of the support where the number of modes are computed.</p>
</td></tr>
<tr><td><code>fnx</code></td>
<td>
<p> The <code>n</code> coordinates of the points where the density is estimated for computing the number of modes.</p>
</td></tr>
<tr><td><code>fny</code></td>
<td>
<p> The estimated density values.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p> Jose Ameijeiras-Alonso, Rosa M. Crujeiras and Alberto Rodríguez-Casal</p>


<h3>References</h3>

<p>Ameijeiras-Alonso, J., Crujeiras, R.M. and Rodríguez-Casal, A. (2021). multimode: An R Package for Mode Assessment, <em>Journal of Statistical Software</em>, <b>97</b>, 1&ndash;32.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Number of modes in the interval (-1.5,1.5), using the bandwidth 0.5.
set.seed(2016)
data=rnorm(50)
nmodes(data,0.5,-1.5,1.5)
</code></pre>

<hr>
<h2 id='plot.gtmod'>
Plot, print and summarize a <code>"gtmod"</code> object
</h2><span id='topic+plot.gtmod'></span><span id='topic+print.gtmod'></span><span id='topic+summary.gtmod'></span>

<h3>Description</h3>

<p>Plot, print and summarize methods for <code>"gtmod"</code> objects, i.e., the results of the graphical tools for exploring the number of modes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'gtmod'
plot(x, addplot = FALSE, xlab = NULL, ylab = NULL,
col.lines = "black", col.sizer = NULL, addlegend = TRUE,
poslegend = "topright", ...)

## S3 method for class 'gtmod'
print(x,digits=getOption("digits"), ...)

## S3 method for class 'gtmod'
summary(object, bandwidths=TRUE, digits = getOption("digits"), width=1, levelmf=NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.gtmod_+3A_x">x</code></td>
<td>
<p> An object inheriting from class <code>"gtmod"</code>.</p>
</td></tr>
<tr><td><code id="plot.gtmod_+3A_object">object</code></td>
<td>
<p> An object of class <code>"gtmod"</code> for which a summary is desired.</p>
</td></tr>
<tr><td><code id="plot.gtmod_+3A_addplot">addplot</code></td>
<td>
<p> Logical, if <code>TRUE</code> the <code><a href="#topic+modetree">modetree</a></code> plot is added to the current one. Default is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="plot.gtmod_+3A_xlab">xlab</code></td>
<td>
<p> A title for the x axis. See <code>title</code>.</p>
</td></tr>
<tr><td><code id="plot.gtmod_+3A_ylab">ylab</code></td>
<td>
<p> A title for the y axis. See <code>title</code>.</p>
</td></tr>
<tr><td><code id="plot.gtmod_+3A_col.lines">col.lines</code></td>
<td>
<p> Colors employed in the <code><a href="#topic+modetree">modetree</a></code>. If the length is two, the first color is employed for representing the location of the modes and the second one for the splitting of the modes. Default is <code>col.lines="black"</code>.</p>
</td></tr>
<tr><td><code id="plot.gtmod_+3A_col.sizer">col.sizer</code></td>
<td>
<p> Colors employed in the <code><a href="#topic+sizer">sizer</a></code> for indicating the behaviour of the smoothed curve. The first color indicates where it is significantly increasing, the second where it is not significantly different from zero, the third where it is significantly negative and the forth where the data are too sparse for meaningful inference. Default <code>col.sizer=c("red","orchid","blue","grey")</code>.</p>
</td></tr>
<tr><td><code id="plot.gtmod_+3A_addlegend">addlegend</code></td>
<td>
<p> Logical, if <code>TRUE</code> the legend is displayed in the <code><a href="#topic+sizer">sizer</a></code>. Default <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="plot.gtmod_+3A_poslegend">poslegend</code></td>
<td>
<p> Position where the legend in the <code><a href="#topic+sizer">sizer</a></code> should be displayed. Default <code>posLegend="topright"</code>.</p>
</td></tr>
<tr><td><code id="plot.gtmod_+3A_digits">digits</code></td>
<td>
<p> Number of significant digits to use, see <code><a href="base.html#topic+formatC">formatC</a></code>.</p>
</td></tr>
<tr><td><code id="plot.gtmod_+3A_bandwidths">bandwidths</code></td>
<td>
<p> Logical, if <code>TRUE</code> the bandwidths range for which the modes are estimated is showed. Default <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="plot.gtmod_+3A_width">width</code></td>
<td>
<p> The total field width in each showed number, see <code><a href="base.html#topic+formatC">formatC</a></code>.</p>
</td></tr>
<tr><td><code id="plot.gtmod_+3A_levelmf">levelmf</code></td>
<td>
<p> In the <code><a href="#topic+modeforest">modeforest</a></code>, just the pixels with a percentage (of times that an estimated mode falls on them) greater than this value will be considered. Default is <code>levelmf=0.5</code>.</p>
</td></tr>
<tr><td><code id="plot.gtmod_+3A_...">...</code></td>
<td>
<p> Arguments to be passed to subsequent methods, <code><a href="graphics.html#topic+plot.default">plot.default</a></code> (<code><a href="#topic+modetree">modetree</a></code>) or <code><a href="graphics.html#topic+image.default">image.default</a></code> (<code><a href="#topic+modeforest">modeforest</a></code> and <code><a href="#topic+sizer">sizer</a></code>) for the <code>plot</code> method and <code><a href="base.html#topic+formatC">formatC</a></code> for the <code>print</code> and the <code>summary</code> method.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p> Jose Ameijeiras-Alonso, Rosa M. Crujeiras and Alberto Rodríguez-Casal</p>


<h3>References</h3>

<p>Ameijeiras-Alonso, J., Crujeiras, R.M. and Rodríguez-Casal, A. (2021). multimode: An R Package for Mode Assessment, <em>Journal of Statistical Software</em>, <b>97</b>, 1&ndash;32.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+modetree">modetree</a></code>, <code><a href="#topic+modeforest">modeforest</a></code> and <code><a href="#topic+sizer">sizer</a></code>, also for examples.
</p>

<hr>
<h2 id='sizer'> SIgnificant ZERo crossing </h2><span id='topic+sizer'></span>

<h3>Description</h3>

<p>This function provides the SiZer map.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sizer(data,method=2,bws=NULL,gridsize=NULL,alpha=0.05,B=NULL,n0=NULL,
cbw1=NULL,cbw2=NULL,display=TRUE,logbw=TRUE,from=NULL,to=NULL,logbw.regulargrid=NULL,...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sizer_+3A_data">data</code></td>
<td>
<p> Sample in which the SiZer map is computed.</p>
</td></tr>
<tr><td><code id="sizer_+3A_method">method</code></td>
<td>
<p> The method employed for computing the SiZer map. Available methods are: 1 (q1, pointwise Gaussian quantiles), 2 (q2, approximate simultaneous over x Gaussian quantiles), 3 (q3, bootstrap quantile simultaneous over x) and 4 (q4, bootstrap quantile simultaneous over x and h). Default <code>method=2</code>.</p>
</td></tr>
<tr><td><code id="sizer_+3A_bws">bws</code></td>
<td>
<p> Vector or range of bandwidths. If it is a vector of size two, then it is used a grid of bandwidths between the given values. Default lower bandwidth is twice the grid size used for estimating the density and upper bandwidth equal to the range of the data. Unless it is specified a vector of size greater than two, the number of bandwidths employed is equal to the second element of <code>gridsize</code>.</p>
</td></tr>
<tr><td><code id="sizer_+3A_gridsize">gridsize</code></td>
<td>
<p> Number of grid points in the horizontal (values of the variable, first element) and vertical (bandwidths, second element) axis. Default is <code>c(512,151)</code>.</p>
</td></tr>
<tr><td><code id="sizer_+3A_alpha">alpha</code></td>
<td>
<p> Significance level employed for determining the significant features. Default <code>alpha=0.05</code>.</p>
</td></tr>
<tr><td><code id="sizer_+3A_b">B</code></td>
<td>
<p> Number of replicates used for generating the SiZer map when method q3 or q4 are used. Default <code>B=100</code>.</p>
</td></tr>
<tr><td><code id="sizer_+3A_n0">n0</code></td>
<td>
<p> When the effective sample size is below this quantity, the pixel in the SiZer map is shaded grey. Default <code>n0=5</code>.</p>
</td></tr>
<tr><td><code id="sizer_+3A_cbw1">cbw1</code></td>
<td>
<p> Number of modes for which the first critical bandwidth is calculated. This is the first bandwidth used to compute the SiZer map when <code>bws</code> is not specified.</p>
</td></tr>
<tr><td><code id="sizer_+3A_cbw2">cbw2</code></td>
<td>
<p> Number of modes for which the second critical bandwidth is calculated. This is the last bandwidth used to compute the SiZer map when <code>bws</code> is not specified.</p>
</td></tr>
<tr><td><code id="sizer_+3A_display">display</code></td>
<td>
<p> Logical, if <code>TRUE</code> the SiZer map is plotted. Default <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="sizer_+3A_logbw">logbw</code></td>
<td>
<p> Logical, if <code>TRUE</code> the plot displays and returns the log10 bandwidths. Default <code>logbw=TRUE</code>.</p>
</td></tr>
<tr><td><code id="sizer_+3A_from">from</code></td>
<td>
<p> First plotted value of the variable. Default is below the data minimum.</p>
</td></tr>
<tr><td><code id="sizer_+3A_to">to</code></td>
<td>
<p> Last plotted value of the variable. Default is above the data maximum.</p>
</td></tr>
<tr><td><code id="sizer_+3A_logbw.regulargrid">logbw.regulargrid</code></td>
<td>
<p> Logical, if <code>TRUE</code> a regular grid of bandwidths is created over the log10 scale. Default <code>logbw.regulargrid=FALSE</code>.</p>
</td></tr>
<tr><td><code id="sizer_+3A_...">...</code></td>
<td>
<p> Arguments to be passed to subsequent methods, <code><a href="#topic+plot.gtmod">plot.gtmod</a></code> for the <code>plot</code>, <code>print</code> and <code>summary</code> methods.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>With this function the assessment of SIgnificant ZERo crossing of the derivative of the smoothed curve are computed for the sample given in <code>data</code>. For this calculation, a kernel density estimator with Gaussian kernel and bandwidths <code>bws</code> is used. When it is plotted, at a given location (horizontal axis) and using a specified bandwidth parameter (vertical axis), the SiZer map represents where the curve is significantly increasing (blue color by default), decreasing (red by default) or not significantly different from zero (orchid, a light tone of purple, by default). Thus, for a given bandwidth, a region significantly increasing followed by a region significantly decreasing (blue-red pattern by default) indicates where there is a significant peak.
</p>
<p>For methods q2, q3 and q4, it is calculated where the data are too sparse for meaningful inference (grey color by default). A location-bandwidth pixel is classified in this last category when the estimated Effective Sample Size is less than <code>n0</code>. For more information, see Chaudhuri and Marron (1999).
</p>
<p>For methods q3 and q4, the bootstrap quantiles are computed generating <code>B</code> random samples drawn with replacement from <code>data</code>.
</p>
<p>The NAs will be automatically removed.
</p>


<h3>Value</h3>

<p>A list with class <code>"gtmod"</code> containing the following components:
</p>
<table>
<tr><td><code>sizer</code></td>
<td>
<p> Matrix indicating the significant behavior of the smoothed curve in each location-bandwidth pixel. One indicates significantly decreasing; two, not significantly different from zero; three, significantly increasing and four where the data are too sparse for meaningful inference.</p>
</td></tr>
<tr><td><code>method</code></td>
<td>
<p> A number indicating what type of quantile was performed.</p>
</td></tr>
<tr><td><code>lower.CI</code></td>
<td>
<p> Matrix containig the lower limit of the confidence interval in each location-bandwidth pixel.</p>
</td></tr>
<tr><td><code>estimate</code></td>
<td>
<p> Matrix containing the derivative values of the kernel density estimation in each location-bandwidth pixel.</p>
</td></tr>
<tr><td><code>upper.CI</code></td>
<td>
<p> Matrix containig the upper limit of the confidence interval in each location-bandwidth pixel.</p>
</td></tr>
<tr><td><code>ESS</code></td>
<td>
<p> Matrix containing the Effective Sample Size in each location-bandwidth pixel.</p>
</td></tr>
<tr><td><code>range.x</code></td>
<td>
<p> Employed location values to represent the SiZer map.</p>
</td></tr>
<tr><td><code>range.bws</code></td>
<td>
<p> Employed bandwidths to compute the SiZer map.</p>
</td></tr>
<tr><td><code>logbw</code></td>
<td>
<p> Logical value indicating if the bandwidths are given in the log10 scale.</p>
</td></tr>
<tr><td><code>sample.size</code></td>
<td>
<p> The number of non-missing observations in the sample used for obtaining the SiZer map.</p>
</td></tr>
<tr><td><code>call</code></td>
<td>
<p> The unevaluated expression, which consists of the named function applied to the given arguments.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p> Jose Ameijeiras-Alonso, Rosa M. Crujeiras and Alberto Rodríguez-Casal</p>


<h3>References</h3>

<p>Ameijeiras-Alonso, J., Crujeiras, R.M. and Rodríguez-Casal, A. (2021). multimode: An R Package for Mode Assessment, <em>Journal of Statistical Software</em>, <b>97</b>, 1&ndash;32.
</p>
<p>Chaudhuri, P. and Marron, J. S. (1999). SiZer for exploration of structures in curves, <em> Journal of the American Statistical Association</em>, <b>94</b>, 807&ndash;823.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#SiZer map using a grid of bandwidths between 1 and 10
data(geyser)
data=geyser
sizer(data,bws=c(1,10))

## Not run: 
#Different methods for calculating the confidence limits

#Pointwise Gaussian quantiles
sizer(data,method=1,bws=c(1,10))

#Approximate simultaneous over x Gaussian quantiles
sizer(data,method=2,bws=c(1,10))

#Bootstrap quantile simultaneous over x
sizer(data,method=3,bws=c(1,10))

#Bootstrap quantile simultaneous over x and h
sizer(data,method=4,bws=c(1,10))

## End(Not run)

#Adding the original mode tree for this sample
modetree(data,bws=c(0.8,10),logbw=TRUE,addplot=TRUE,col.lines="white")

</code></pre>

<hr>
<h2 id='stamps'> Stamps thickness
</h2><span id='topic+stamps'></span><span id='topic+stamps1'></span><span id='topic+stamps2'></span><span id='topic+stampstable'></span>

<h3>Description</h3>

<p>This dataset, analysed in Izenman and Sommer (1988) and Ameijeiras-Alonso <em>et al.</em> (2019), consists of thickness measurements (in millimeters) of 485 unwatermarked used white wove stamps of the 1872 Hidalgo stamp issue of Mexico. All of them had an overprint with the year (1872 or either an 1873 or 1874) and some of them were watermarked (Papel Sellado or LA+-F).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(stamps)
data(stamps1)
data(stamps2)
data(stampstable)
</code></pre>


<h3>Format</h3>

<p><code>stamps</code> includes the thickness (in millimeters) of the different stamps in the 1872 Hidalgo stamp issue. <code>stampstable</code> reproduces the original frequency table in Izenman and Sommer (1988), including the <code>thickness</code>, the overprinted years (<code>1872</code> or <code>1873-1874</code>) and the watermarks (<code>Papel Sellado</code> or <code>LA+-F</code>). <code>stamps1</code> includes both the <code>thickness</code> and the overprinted <code>year</code>. <code>stamps2</code> includes both the <code>thickness</code> and the <code>watermark</code>. Note that the stamp with a thickness equal to 0.118 and the watermark <code>"Papel Sellado"</code> was removed in <code>stamps2</code> since it does not have a corresponding year, probably this watermark is associated with the observation of <code>thickness</code> 0.117 or 0.119.
</p>


<h3>Details</h3>

<p>This is a classic example for determining the number of modes.
</p>


<h3>Source</h3>

<p>Obtained from the original table in Izenman and Sommer (1988).
</p>


<h3>References</h3>

<p>Ameijeiras-Alonso, J., Crujeiras, R.M. and Rodríguez-Casal, A. (2019). Mode testing, critical bandwidth and excess mass, <em>Test</em>, <b>28</b>, 900&ndash;919.
</p>
<p>Ameijeiras-Alonso, J., Crujeiras, R.M. and Rodríguez-Casal, A. (2021). multimode: An R Package for Mode Assessment, <em>Journal of Statistical Software</em>, <b>97</b>, 1&ndash;32.
</p>
<p>Izenman, A. J., and Sommer, C. J. (1988). Philatelic mixtures and multimodal densities. <em>Journal of the American Statistical association</em>, <b>83</b>, 941&ndash;953.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("stamps")
# Histogram of Wilson (bin width 0.008)
seqx=seq(0.0585,0.1385,by=0.008)
hist(stamps,breaks=seqx)
# Histogram of Figure 1, Izenman and Sommer (bin width 0.002)
seqx=seq(0.0585,0.1385,by=0.002)
hist(stamps,breaks=seqx)

# Kernel density estimation of Izenman and Sommer (number of modes: 7)
locmodes(stamps,mod0=7,lowsup=0.04,uppsup=0.15,display=TRUE)
# Kernel density estimation of Ameijeiras-Alonso et al. (number of modes: 4)
locmodes(stamps,mod0=4,lowsup=0.04,uppsup=0.15,display=TRUE)

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
