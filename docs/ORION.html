<!DOCTYPE html><html><head><title>Help for package ORION</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {ORION}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#as.edgedataframe'><p>Coerce to an Edge List</p></a></li>
<li><a href='#as.subcascades'><p>Coerce to a Subcascades Object</p></a></li>
<li><a href='#conf'><p>Construction of Binary Classifier Sensitivities</p></a></li>
<li><a href='#confusionTable'><p>Construction of a Confusion Table</p></a></li>
<li><a href='#dropSets'><p>Filter out Subcascades</p></a></li>
<li><a href='#dropSize'><p>Filters for size</p></a></li>
<li><a href='#dropThreshold'><p>Exclude Cascades Based on Threshold</p></a></li>
<li><a href='#esl'><p>ESL Dataset</p></a></li>
<li><a href='#esl_org'><p>ESL Dataset</p></a></li>
<li><a href='#groupwise'><p>Coerce to a Groupwise object</p></a></li>
<li><a href='#keepSets'><p>Filter Subcascades</p></a></li>
<li><a href='#keepSize'><p>Filter for Size</p></a></li>
<li><a href='#keepThreshold'><p>Filters for Threshold</p></a></li>
<li><a href='#mergeSubcascades'><p>Merge Subcascades</p></a></li>
<li><a href='#nonOrdinalData'><p>non-ordinal data</p></a></li>
<li><a href='#ordinalData'><p>ordinal data</p></a></li>
<li><a href='#plot.Conf'><p>Base Classifier Performance Heatmap</p></a></li>
<li><a href='#plot.ConfusionTable'><p>Extended Confusion Table Plot</p></a></li>
<li><a href='#plot.Groupwise'><p>Heatmap of a Groupwise Object</p></a></li>
<li><a href='#plot.PredictionMap'><p>Heatmap of a PredictionMap Object</p></a></li>
<li><a href='#plot.Subcascades'><p>Heatmap of a Subcascades Object</p></a></li>
<li><a href='#plotBaseClassifier'><p>Base Classifier Performance Heatmap</p></a></li>
<li><a href='#plotConf'><p>Base Classifier Performance Heatmap</p></a></li>
<li><a href='#predictionMap'><p>Construction of a Prediction Map Object</p></a></li>
<li><a href='#print.Conf'><p>Prints all details about a Conf object.</p></a></li>
<li><a href='#print.ConfusionTable'><p>Prints all details about a ConfusionTable object.</p></a></li>
<li><a href='#print.Groupwise'><p>Prints all details about a Groupwise object.</p></a></li>
<li><a href='#print.PredictionMap'><p>Prints all details about a PredictionMap object.</p></a></li>
<li><a href='#print.Subcascades'><p>Prints all details about a Subcascades object.</p></a></li>
<li><a href='#screeningData'><p>screening data</p></a></li>
<li><a href='#subcascades'><p>Subcascades Evaluation</p></a></li>
<li><a href='#summary.Conf'><p>Summary of conf</p></a></li>
<li><a href='#summary.ConfusionTable'><p>Summary of confusion tables</p></a></li>
<li><a href='#summary.Groupwise'><p>Overview Class Groups</p></a></li>
<li><a href='#summary.PredictionMap'><p>Summary of prediction maps</p></a></li>
<li><a href='#summary.Subcascades'><p>Summary Subcascades Characteristics</p></a></li>
<li><a href='#summaryClasses'><p>Occurrence of Classes by Size</p></a></li>
<li><a href='#summarySubcascades'><p>Overview Subcascades</p></a></li>
<li><a href='#tunePareto.occ'><p>Ordinal Classifier Cascade Tune Pareto Object</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Ordinal Relations</td>
</tr>
<tr>
<td>Version:</td>
<td>1.0.3</td>
</tr>
<tr>
<td>Date:</td>
<td>2022-02-04</td>
</tr>
<tr>
<td>Author:</td>
<td>L Lausser, LM Schaefer, R Szekely, HA Kestler</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>HA Kestler &lt;hans.kestler@uni-ulm.de&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Functions to handle ordinal relations reflected within the feature space. Those function allow to search for ordinal relations in multi-class datasets. One can check whether proposed relations are reflected in a specific feature representation. Furthermore, it provides functions to filter, organize and further analyze those ordinal relations. </td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a></td>
</tr>
<tr>
<td>LazyLoad:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2022-02-07 09:32:31 UTC; lausser</td>
</tr>
<tr>
<td>Imports:</td>
<td>e1071, knitr, rmarkdown, doParallel, igraph, foreach,
randomForest</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.5.0), TunePareto</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.1.2</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2022-02-07 10:30:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='as.edgedataframe'>Coerce to an Edge List</h2><span id='topic+as.edgedataframe'></span>

<h3>Description</h3>

<p>Converts from a Subcascades object to a weighted edge list.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>as.edgedataframe(subcascades)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="as.edgedataframe_+3A_subcascades">subcascades</code></td>
<td>
<p>A Subcascades object as it is returned by <code><a href="#topic+subcascades">subcascades</a></code>-function.
The Subcascades object is made up of a list of matrices. 
Each matrix comprises the evaluation results of cascades of a specific length and 
is sorted row-wise according to the achieved minimal classwise sensitivities of the cascades (decreasing).
The rownames show the class order by a character string of type '1&gt;2&gt;3' and the entries the sensitivity for each position of the cascade.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Converts a Subcascades object to a data.frame that can be used to generate a graph.
</p>


<h3>Value</h3>

<p>A data.frame that can be used to generate a graph. 
The first and second column correspond to all pairwise relations (from - to) of the cascades within the
Subcascades object. The 'CASC_ID' column contains the same ID for all edges belonging to the same cascade.
The 'SIZE' column gives the size of the cascade to which the repective column bleongs.
The method returns NULL if the object subcascades is empty.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+groupwise">groupwise</a></code>, <code><a href="#topic+as.subcascades">as.subcascades</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(TunePareto)
library(igraph)
data(esl)
data = esl$data
labels = esl$labels
predMap = predictionMap(data, labels, 
                       classifier = tunePareto.svm(), kernel='linear')

# generate a dataframe
subcascades = subcascades(predMap,thresh=0.65,size=4)
edges = as.edgedataframe(subcascades)
g = graph_from_data_frame(edges[,c(1,2)], directed = TRUE)
E(g)$weight = edges[,3]
plot(g,edge.color=edges[,3],edge.arrow.size=0.5,
     edge.curved =seq(-0.5, 1, length = ecount(g)))
</code></pre>

<hr>
<h2 id='as.subcascades'>Coerce to a Subcascades Object</h2><span id='topic+as.subcascades'></span>

<h3>Description</h3>

<p>Converts from a Groupwise object to a Subcascades object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>as.subcascades(groupwise = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="as.subcascades_+3A_groupwise">groupwise</code></td>
<td>
<p>A Groupwise object, which comprises a two-leveled list. The first level collects cascades of the same size.
The second level contains a list of unique class combinations, labelled as a character string with '-' separating the different classes. 
For each unique set of class combinations the corresponding orders and their performance are given as a matrix, 
where each row contains a cascade, given as a character string of type '1&gt;2&gt;3', and the columns the sensitivity for the class at the corresponding position.
Each matrix is sorted row-wise according to the achieved minimal classwise sensitivites of the cascades (decreasing).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Converts a Groupwise object to a Subcascades object.
</p>


<h3>Value</h3>

<p>A Subcascades object comprising the evaluated cascades and their performances. 
The Subcascades object is made up of a list of matrices. 
Each matrix comprises the evaluation results of cascades of a specific length and 
is sorted row-wise according to the achieved minimal classwise sensitivities of the cascades (decreasing).
The rownames show the class order by a character string of type '1&gt;2&gt;3' and the entries the sensitivity for each position of the cascade.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+groupwise">groupwise</a></code>, <code><a href="#topic+as.edgedataframe">as.edgedataframe</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(TunePareto)
data(esl)
data = esl$data
labels = esl$labels
foldList = generateCVRuns(labels  = labels,
                          ntimes      = 2,
                          nfold       = 2,
                          leaveOneOut = FALSE,
                          stratified  = TRUE)
predMap = predictionMap(data, labels, foldList = foldList, 
                       classifier = tunePareto.svm(), kernel='linear')

# generate a Groupwise object
subc = subcascades(predMap,thresh=0.7)
groupwise = groupwise(subc)

#convert it to a Subcascades object
converted.subcascades = as.subcascades(groupwise)
</code></pre>

<hr>
<h2 id='conf'>Construction of Binary Classifier Sensitivities</h2><span id='topic+conf'></span>

<h3>Description</h3>

<p>Sensitivities of all pairwise binary classifiers for all classes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>conf(predictionMap = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="conf_+3A_predictionmap">predictionMap</code></td>
<td>
<p>A PredictionMap object as it is returned by <code><a href="#topic+predictionMap">predictionMap</a></code>-function. 
It is made up of a list of two matrices(pred and meta). Both matrices provide information on individual samples column-wise.
The rownames of the pred-matrix (e.g. [0vs1]) show the classes of the binary base classifier. The elements are the prediction result of a specific training.
The rows that correspond to base classifiers that would separate the same class consists of -1. Those rows are not used within the analysis.
The meta information connects the values in the pred-matrix to a specific fold, run and contains the original label.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The Conf object contains all class sensitivities for each binary trained classifiers. 
The $fC-part is a matrix with one column and contains the sensitivities for the first class 
of each pairwise classifier. The rows stand for the pairwise classifiers, whereby 
0vs1 means that this classifier was trained for class 0 against class 1, with 
class 0 being the first class. The number '-1' is used as placeholder. 
The $sC-part is a matrix and contains the preformance measures for all second classes, 
which are meant here as all classes except the first class. The rows correspond 
to the binary classifiers and the columns to the classes.
</p>


<h3>Value</h3>

<p>Object of class Conf. Consists of a list of two numeric matrices fC and sC.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+summary.Conf">summary.Conf</a></code>, <code><a href="#topic+print.Conf">print.Conf</a></code>, <code><a href="#topic+plot.Conf">plot.Conf</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(TunePareto)
data(esl)
data = esl$data
labels = esl$labels
foldList = generateCVRuns(labels  = labels,
                          ntimes      = 2,
                          nfold       = 2,
                          leaveOneOut = FALSE,
                          stratified  = TRUE)
predMap = predictionMap(data, labels, foldList = foldList, 
                       classifier = tunePareto.svm(), kernel='linear')

conf = conf(predMap)
</code></pre>

<hr>
<h2 id='confusionTable'>Construction of a Confusion Table</h2><span id='topic+confusionTable'></span>

<h3>Description</h3>

<p>Confusion table and class assignments of one cascade.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>confusionTable(
  predictionMap = NULL,
  cascade = NULL,
  other.classes = NULL,
  sort = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="confusionTable_+3A_predictionmap">predictionMap</code></td>
<td>
<p>A PredictionMap object as it is returned by <code><a href="#topic+predictionMap">predictionMap</a></code>-function. 
It is made up of a list of two matrices(pred and meta). Both matrices provide information on individual samples column-wise.
The rownames of the pred-matrix (e.g. [0vs1]) show the classes of the binary base classifier. The elements are the prediction result of a specific training.
The rows that correspond to base classifiers that would separate the same class consists of -1. Those rows are not used within the analysis.
The meta information connects the values in the pred-matrix to a specific fold, run and contains the original label.</p>
</td></tr>
<tr><td><code id="confusionTable_+3A_cascade">cascade</code></td>
<td>
<p>A numeric vector of classes or a character string of type '1&gt;2&gt;3' of at least two class labels reflected in 'predictionMap'.</p>
</td></tr>
<tr><td><code id="confusionTable_+3A_other.classes">other.classes</code></td>
<td>
<p>This parameter can be either NULL, 'all' or a numeric vector of classes that are not part of the cascade parameter.
If other.classes is:
- NULL, only the cascade classes are evaluated. 
- 'all', all remaining classes are evaluated. 
-  a vector of classes, those classes are evaluated.</p>
</td></tr>
<tr><td><code id="confusionTable_+3A_sort">sort</code></td>
<td>
<p>If TRUE (default) the classes that are not part of cascade are sorted based on their confusion.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of type ConfusionTable including the sensitivities, with the label of the predicted classes in the rows and the labels of the original class in the columns.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+summary.ConfusionTable">summary.ConfusionTable</a></code>, <code><a href="#topic+print.ConfusionTable">print.ConfusionTable</a></code>, <code><a href="#topic+plot.ConfusionTable">plot.ConfusionTable</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(TunePareto)
data(esl)
data = esl$data
labels = esl$labels
foldList = generateCVRuns(labels  = labels,
                          ntimes      = 2,
                          nfold       = 2,
                          leaveOneOut = FALSE,
                          stratified  = TRUE)
predMap = predictionMap(data, labels, foldList = foldList, 
                       classifier = tunePareto.svm(), kernel='linear')

# Calculation of the confusion matrix for '0&gt;2&gt;3&gt;4'.
confTable = confusionTable(predMap, cascade = '0&gt;2&gt;3&gt;4')
# Calculation of the confusion matrix for '0&gt;2&gt;3&gt;4' 
# and the assignment of all samples of the other classes.
confTable = confusionTable(predMap, cascade = '0&gt;2&gt;3&gt;4', 
                other.classes='all', sort = TRUE)
</code></pre>

<hr>
<h2 id='dropSets'>Filter out Subcascades</h2><span id='topic+dropSets'></span>

<h3>Description</h3>

<p><code>dropSets</code> filters out specific cascade sets.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dropSets(
  subcascades = NULL,
  sets = NULL,
  direction = "sub",
  ordered = FALSE,
  neighborhood = "direct",
  type = "any"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dropSets_+3A_subcascades">subcascades</code></td>
<td>
<p>A Subcascades object as it is returned by <code><a href="#topic+subcascades">subcascades</a></code>-function.
The Subcascades object is made up of a list of matrices. 
Each matrix comprises the evaluation results of cascades of a specific length and 
is sorted row-wise according to the achieved minimal classwise sensitivities of the cascades (decreasing).
The rownames show the class order by a character string of type '1&gt;2&gt;3' and the entries the sensitivity for each position of the cascade.</p>
</td></tr>
<tr><td><code id="dropSets_+3A_sets">sets</code></td>
<td>
<p>Contains the set used for filtering. It is either a list of numeric vectors, a numeric vector, 
or a vector of characters representing a cascade of the following format '1&gt;2&gt;4'. Empty vectors are not allowed.</p>
</td></tr>
<tr><td><code id="dropSets_+3A_direction">direction</code></td>
<td>
<p>Either 'sub','super' or 'exact', indicating whether the subset, the superset or the exact set is filtered. 
The 'exact' case filters exactly the cascades defined in <code>sets</code>. Please refer to the details section for a detailed description.</p>
</td></tr>
<tr><td><code id="dropSets_+3A_ordered">ordered</code></td>
<td>
<p>Either TRUE or FALSE indicating whether the order of the classes in sets is considered or not.</p>
</td></tr>
<tr><td><code id="dropSets_+3A_neighborhood">neighborhood</code></td>
<td>
<p>Either 'direct' or 'indirect' defines whether the given classes have to be direct neighbors ('direct') or there are other classes allowed inbetween ('indirect').</p>
</td></tr>
<tr><td><code id="dropSets_+3A_type">type</code></td>
<td>
<p>If more than one cascade is defined in sets, this parameter defines whether the filtered cascade has to
fit to at least one of the sets ('any') or to all of the given sets ('all').</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function allows for filtering the Subcascades object. 
</p>
<p>If <code>direction</code> is set to 'exact' the parameter <code>neighborhood</code> is ignored and the parameter <code>type</code> is used as its default and cannot be changed.
There has to be an exact match between the classes of the sets parameter cascades and the cascade of the Subcascades object, 
so not more but also not less classes are allowed. If the <code>ordered</code> parameter is set to TRUE also the order of the classes within the 
<code>sets</code> parameter and within the Subcascades object has be be exactly the same.
</p>
<p>If <code>direction</code> is set to 'sub' the Subcascades object is filtered for subsets of the given cascades. 
If the <code>type</code> parameter is set to 'any' each cascade is considered individually otherwise all cascades are used as reference for filtering.
This means that either for each cascade of the <code>sets</code> parameter individually or for taking all together the Subcascades object is filtered for cascades that are 
made up of the same classes, a subset of classes (<code>ordered = FALSE</code>) or a cascade, part of a cascade (<code>ordered = TRUE</code>), 
resulting in a set of cascades that might contain less classes.
The parameter <code>neighbourhood</code> is not considered.
</p>
<p>If <code>direction</code> is set to 'super' the Subcascades object is filtered for a superset of the given cascades. 
If the <code>type</code> parameter is set to 'any' each cascade is considered individually otherwise all cascades are used as reference for filtering.
A superset are cascades that are made up of (parts) of the given cascades (<code>ordered = TRUE</code>) or classes (<code>ordered=FALSE</code>) but can contain also more classes. 
Depending on the parameter <code>neighborhood</code> only classes defined in the <code>sets</code> parameter are allowed as neighbors ('direct').
If <code>neighborhood</code> is set to 'indirect' the filtering is less strict and the direct neighborhood defined in <code>sets</code> is not considered.
</p>


<h3>Value</h3>

<p>A Subcascades object comprising the evaluated cascades and their performances. 
The Subcascades object is made up of a list of matrices. 
Each matrix comprises the evaluation results of cascades of a specific length and 
is sorted row-wise according to the achieved minimal classwise sensitivities of the cascades (decreasing).
The rownames show the class order by a character string of type '1&gt;2&gt;3' and the entries the sensitivity for each position of the cascade.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+dropSize">dropSize</a></code>, <code><a href="#topic+keepSize">keepSize</a></code>, <code><a href="#topic+keepSets">keepSets</a></code>, <code><a href="#topic+dropThreshold">dropThreshold</a></code>, <code><a href="#topic+keepThreshold">keepThreshold</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(TunePareto)
data(esl)
data = esl$data
labels = esl$labels
foldList = generateCVRuns(labels  = labels,
                          ntimes      = 2,
                          nfold       = 2,
                          leaveOneOut = FALSE,
                          stratified  = TRUE)
predMap = predictionMap(data, labels, foldList = foldList, 
                       classifier = tunePareto.svm(), kernel='linear')
# generate Subcascades object
subc = subcascades(predMap,thresh=0.7)

#define sets
set1 = list(c(1,2,3),c(2,3,4))
set2 = c('1&gt;2&gt;3','2&gt;3&gt;4')

# filter for the subset cascades that contain either the classes 
# {1,2,3} or {2,3,4} independent of the order, but neighbored
dropSets(subc, sets = set1, direction = 'sub', 
         ordered = FALSE, neighborhood = 'direct')
dropSets(subc, sets = set2, direction = 'sub', 
         ordered = FALSE, neighborhood = 'direct')

# filter for the superset cascades that contain either the classes 
# {1,2,3} or {2,3,4} independent of the order, but neighbored
dropSets(subc, sets = set1, direction = 'super', 
         ordered = FALSE, neighborhood = 'direct')
dropSets(subc, sets = set2, direction = 'super', 
         ordered = FALSE, neighborhood = 'direct')

# filter for the superset cascades that contain both the classes 
# {1,2,3} and {2,3,4} in exactly the given order, but allowing 
# for other classes inbetween
dropSets(subc, sets = set1, direction = 'super', 
        ordered = TRUE, neighborhood = 'indirect', type = 'all')
dropSets(subc, sets = set2, direction = 'super',
        ordered = TRUE, neighborhood = 'indirect', type = 'all')
         
# filter for the exact cascades
# sets can be a numeric list
result &lt;- dropSets(subc, list(c(0,1,2),c(2,3,4,1)),
                   direction = 'exact', ordered=TRUE)
unlist(t(lapply(result,rownames)))
# or sets can be a character vector
result &lt;- dropSets(subc, c('0&gt;1&gt;2','2&gt;3&gt;4&gt;1'),
                   direction = 'exact',ordered=TRUE)
unlist(t(lapply(result,rownames)))         
</code></pre>

<hr>
<h2 id='dropSize'>Filters for size</h2><span id='topic+dropSize'></span>

<h3>Description</h3>

<p>Filters out the Subcascades object for the given sizes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dropSize(subcascades = NULL, size = NA)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dropSize_+3A_subcascades">subcascades</code></td>
<td>
<p>A Subcascades object as it is returned by <code><a href="#topic+subcascades">subcascades</a></code>-function.
The Subcascades object is made up of a list of matrices. 
Each matrix comprises the evaluation results of cascades of a specific length and 
is sorted row-wise according to the achieved minimal classwise sensitivities of the cascades (decreasing).
The rownames show the class order by a character string of type '1&gt;2&gt;3' and the entries the sensitivity for each position of the cascade.</p>
</td></tr>
<tr><td><code id="dropSize_+3A_size">size</code></td>
<td>
<p>A numeric value that defines the size of the cascades that should be returned. 
The smallest size is 2 and the largest the maximal number of classes of the current dataset.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A Subcascades object as in <code><a href="#topic+subcascades">subcascades</a></code>, that does not include cascades of the specific lengths that hve been filtered.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+keepSize">keepSize</a></code>, <code><a href="#topic+dropSets">dropSets</a></code>, <code><a href="#topic+keepSets">keepSets</a></code>, <code><a href="#topic+dropThreshold">dropThreshold</a></code>, <code><a href="#topic+keepThreshold">keepThreshold</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(TunePareto)
data(esl)
data = esl$data
labels = esl$labels
foldList = generateCVRuns(labels  = labels,
                          ntimes      = 2,
                          nfold       = 2,
                          leaveOneOut = FALSE,
                          stratified  = TRUE)
predMap = predictionMap(data, labels, foldList = foldList, 
                       classifier = tunePareto.svm(), kernel='linear')
# generate Subcascades object
subc = subcascades(predMap,thresh=0.7)

# filters out cascades that have a length of 3
dropSize(subc,size=3)
# filters out cascades that have a length of 3 or 4
dropSize(subc, size=c(3,4))
</code></pre>

<hr>
<h2 id='dropThreshold'>Exclude Cascades Based on Threshold</h2><span id='topic+dropThreshold'></span>

<h3>Description</h3>

<p>Filters out all cascades that match the comparison with a minimal classwise sensitivity threshold.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dropThreshold(subcascades = NULL, comparison = "&gt;=", thresh = 0)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dropThreshold_+3A_subcascades">subcascades</code></td>
<td>
<p>A Subcascades object as it is returned by <code><a href="#topic+subcascades">subcascades</a></code>-function.
The Subcascades object is made up of a list of matrices. 
Each matrix comprises the evaluation results of cascades of a specific length and 
is sorted row-wise according to the achieved minimal classwise sensitivities of the cascades (decreasing).
The rownames show the class order by a character string of type '1&gt;2&gt;3' and the entries the sensitivity for each position of the cascade.</p>
</td></tr>
<tr><td><code id="dropThreshold_+3A_comparison">comparison</code></td>
<td>
<p>Defines the comparison type (&lt;,&gt;,&lt;=,&gt;=) for the threshold.</p>
</td></tr>
<tr><td><code id="dropThreshold_+3A_thresh">thresh</code></td>
<td>
<p>A numeric value between 0 and 1.
The minimal sensitivity threshold used to filter the returned cascades. 
Only cascades that pass this threshold are returned. 
If 0 is used the returned cascades are filtered for &gt;0 and otherwise &gt;= thresh.
For low thresholds the calculation lasts longer.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A Subcascades object comprising the evaluated cascades and their performances. 
The Subcascades object is made up of a list of matrices. 
Each matrix comprises the evaluation results of cascades of a specific length and 
is sorted row-wise according to the achieved minimal classwise sensitivities of the cascades (decreasing).
The rownames show the class order by a character string of type '1&gt;2&gt;3' and the entries the sensitivity for each position of the cascade.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+dropSize">dropSize</a></code>, <code><a href="#topic+keepSize">keepSize</a></code>, <code><a href="#topic+dropSets">dropSets</a></code>, <code><a href="#topic+keepSets">keepSets</a></code>, <code><a href="#topic+keepThreshold">keepThreshold</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(TunePareto)
data(esl)
data = esl$data
labels = esl$labels
foldList = generateCVRuns(labels  = labels,
                          ntimes      = 2,
                          nfold       = 2,
                          leaveOneOut = FALSE,
                          stratified  = TRUE)
predMap = predictionMap(data, labels, foldList = foldList, 
                       classifier = tunePareto.svm(), kernel='linear')
# generate Subcascades object
subc = subcascades(predMap,thresh=0.5)

# filters for cascades that 
# 1. have a minimal classwise sensitivity &gt;= 0.6
dropThreshold(subc,thresh=0.6)
# 2. have a minimal classwise sensitivity &lt;= 0.6
dropThreshold(subc, comparison = '&lt;=', thresh=0.6)
</code></pre>

<hr>
<h2 id='esl'>ESL Dataset</h2><span id='topic+esl'></span>

<h3>Description</h3>

<p>The original ESL data set contains 488 profiles of applicants for certain industrial
jobs.  Expert psychologists of a recruiting company, based upon psychometric
test results and interviews with the candidates, determined the values of the
input attributes. The output is the an overall score corresponding to the
degree of fitness of the candidate to this type of job.
Here classes 1-3 are merged to one group and all classes &gt;6 are merged to one group.
Furtheremore, the data is relabeled to start at 0 and only 20 samples per class are
included.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(esl)
</code></pre>


<h3>Format</h3>

<p>An object of class <code>list</code> of length 2.
</p>


<h3>Source</h3>

<p><a href="https://waikato.github.io/weka-wiki/datasets/">Weka dataset</a>
(datasets-arie_ben_david.tar.gz, 11,348 Bytes)
</p>


<h3>References</h3>

<p>ordinal, real-world datasets donated by Dr. Arie Ben David (Holon Inst. of Technology/Israel)
Donor: Arie Ben David
MIS, Dept. of Technology Management 
Holon Academic Inst. of Technology
52 Golomb St.
Holon 58102
Israel
abendav@hait.ac.il
Owner: Yoav Ganzah
Business Administration School
Tel Aviv Univerity
Ramat Aviv 69978
Israel
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(esl)

</code></pre>

<hr>
<h2 id='esl_org'>ESL Dataset</h2><span id='topic+esl_org'></span>

<h3>Description</h3>

<p>The ESL data set contains 488 profiles of applicants for certain industrial
jobs.  Expert psychologists of a recruiting company, based upon psychometric
test results and interviews with the candidates, determined the values of the
input attributes. The output is the an overall score corresponding to the
degree of fitness of the candidate to this type of job.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(esl_org)
</code></pre>


<h3>Format</h3>

<p>An object of class <code>data.frame</code> with 488 rows and 5 columns.
</p>


<h3>Source</h3>

<p><a href="https://waikato.github.io/weka-wiki/datasets/">Weka dataset</a>
(datasets-arie_ben_david.tar.gz, 11,348 Bytes)
</p>


<h3>References</h3>

<p>ordinal, real-world datasets donated by Dr. Arie Ben David (Holon Inst. of Technology/Israel)
Donor: Arie Ben David
MIS, Dept. of Technology Management 
Holon Academic Inst. of Technology
52 Golomb St.
Holon 58102
Israel
abendav@hait.ac.il
Owner: Yoav Ganzah
Business Administration School
Tel Aviv Univerity
Ramat Aviv 69978
Israel
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(esl_org)

</code></pre>

<hr>
<h2 id='groupwise'>Coerce to a Groupwise object</h2><span id='topic+groupwise'></span>

<h3>Description</h3>

<p>Converts from a Subcascades object to a Groupwise object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>groupwise(subcascades = NULL, maxCl = 50)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="groupwise_+3A_subcascades">subcascades</code></td>
<td>
<p>A Subcascades object as it is returned by <code><a href="#topic+subcascades">subcascades</a></code>-function.
The Subcascades object is made up of a list of matrices. 
Each matrix comprises the evaluation results of cascades of a specific length and 
is sorted row-wise according to the achieved minimal classwise sensitivities of the cascades (decreasing).
The rownames show the class order by a character string of type '1&gt;2&gt;3' and the entries the sensitivity for each position of the cascade.</p>
</td></tr>
<tr><td><code id="groupwise_+3A_maxcl">maxCl</code></td>
<td>
<p>An integer defining the lower bound for the maximal number of classes. Has only to be set if the analyzed dataset has more than 50 classes.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function re-sorts the Subcascades object in a way that the cascades made up of the same classes are grouped.
</p>


<h3>Value</h3>

<p>A Groupwise object, which comprises a two-leveled list. The first level collects cascades of the same size.
The second level contains a list of unique class combinations, labelled as a character string with '-' separating the different classes. 
For each unique set of class combinations the corresponding orders and their performance are given as a matrix, 
where each row contains a cascade, given as a character string of type '1&gt;2&gt;3', and the columns the sensitivity for the class at the corresponding position.
Each matrix is sorted row-wise according to the achieved minimal classwise sensitivites of the cascades (decreasing).
</p>


<h3>See Also</h3>

<p><code><a href="#topic+as.subcascades">as.subcascades</a></code>, <code><a href="#topic+summary.Groupwise">summary.Groupwise</a></code>, <code><a href="#topic+print.Groupwise">print.Groupwise</a></code>, <code><a href="#topic+plot.Groupwise">plot.Groupwise</a></code>, <code><a href="#topic+as.edgedataframe">as.edgedataframe</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
library(TunePareto)
data(esl)
data = esl$data
labels = esl$labels
foldList = generateCVRuns(labels  = labels,
                          ntimes      = 2,
                          nfold       = 2,
                          leaveOneOut = FALSE,
                          stratified  = TRUE)
predMap = predictionMap(data, labels, foldList = foldList, 
                       classifier = tunePareto.svm(), kernel='linear')
# generate Subcascades object
subcascades = subcascades(predMap,thresh=0.7)

#create a Groupwise object
groupwise = groupwise(subcascades)
</code></pre>

<hr>
<h2 id='keepSets'>Filter Subcascades</h2><span id='topic+keepSets'></span>

<h3>Description</h3>

<p><code>keepSets</code> filters specific cascade sets.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>keepSets(
  subcascades = NULL,
  sets = NULL,
  direction = "sub",
  ordered = FALSE,
  neighborhood = "direct",
  type = "any"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="keepSets_+3A_subcascades">subcascades</code></td>
<td>
<p>A Subcascades object as it is returned by <code><a href="#topic+subcascades">subcascades</a></code>-function.
The Subcascades object is made up of a list of matrices. 
Each matrix comprises the evaluation results of cascades of a specific length and 
is sorted row-wise according to the achieved minimal classwise sensitivities of the cascades (decreasing).
The rownames show the class order by a character string of type '1&gt;2&gt;3' and the entries the sensitivity for each position of the cascade.</p>
</td></tr>
<tr><td><code id="keepSets_+3A_sets">sets</code></td>
<td>
<p>Contains the set used for filtering. It is either a list of numeric vectors, a numeric vector, 
or a vector of characters representing a cascade of the following format '1&gt;2&gt;4'. Empty vectors are not allowed.</p>
</td></tr>
<tr><td><code id="keepSets_+3A_direction">direction</code></td>
<td>
<p>Either 'sub','super' or 'exact', indicating whether the subset, the superset or the exact set is filtered. 
The 'exact' case filters exactly the cascades defined in <code>sets</code>. Please refer to the details section for a detailed description.</p>
</td></tr>
<tr><td><code id="keepSets_+3A_ordered">ordered</code></td>
<td>
<p>Either TRUE or FALSE indicating whether the order of the classes in sets is considered or not.</p>
</td></tr>
<tr><td><code id="keepSets_+3A_neighborhood">neighborhood</code></td>
<td>
<p>Either 'direct' or 'indirect' defines whether the given classes have to be direct neighbors ('direct') or there are other classes allowed inbetween ('indirect').</p>
</td></tr>
<tr><td><code id="keepSets_+3A_type">type</code></td>
<td>
<p>If more than one cascade is defined in sets, this parameter defines whether the filtered cascade has to
fit to at least one of the sets ('any') or to all of the given sets ('all').</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function allows for filtering the Subcascades object. 
</p>
<p>If <code>direction</code> is set to 'exact' the parameter <code>neighborhood</code> is ignored and the parameter <code>type</code> is used as its default and cannot be changed.
There has to be an exact match between the classes of the sets parameter cascades and the cascade of the Subcascades object, 
so not more but also not less classes are allowed. If the <code>ordered</code> parameter is set to TRUE also the order of the classes within the 
<code>sets</code> parameter and within the Subcascades object has be be exactly the same.
</p>
<p>If <code>direction</code> is set to 'sub' the Subcascades object is filtered for subsets of the given cascades. 
If the <code>type</code> parameter is set to 'any' each cascade is considered individually otherwise all cascades are used as reference for filtering.
This means that either for each cascade of the <code>sets</code> parameter individually or for taking all together the Subcascades object is filtered for cascades that are 
made up of the same classes, a subset of classes (<code>ordered = FALSE</code>) or a cascade, part of a cascade (<code>ordered = TRUE</code>), 
resulting in a set of cascades that might contain less classes.
The parameter <code>neighbourhood</code> is not considered.
</p>
<p>If <code>direction</code> is set to 'super' the Subcascades object is filtered for a superset of the given cascades. 
If the <code>type</code> parameter is set to 'any' each cascade is considered individually otherwise all cascades are used as reference for filtering.
A superset are cascades that are made up of (parts) of the given cascades (<code>ordered = TRUE</code>) or classes (<code>ordered=FALSE</code>) but can contain also more classes. 
Depending on the parameter <code>neighborhood</code> only classes defined in the <code>sets</code> parameter are allowed as neighbors ('direct').
If <code>neighborhood</code> is set to 'indirect' the filtering is less strict and the direct neighborhood defined in <code>sets</code> is not considered.
</p>


<h3>Value</h3>

<p>A Subcascades object comprising the evaluated cascades and their performances. 
The Subcascades object is made up of a list of matrices. 
Each matrix comprises the evaluation results of cascades of a specific length and 
is sorted row-wise according to the achieved minimal classwise sensitivities of the cascades (decreasing).
The rownames show the class order by a character string of type '1&gt;2&gt;3' and the entries the sensitivity for each position of the cascade.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+dropSize">dropSize</a></code>, <code><a href="#topic+keepSize">keepSize</a></code>, <code><a href="#topic+dropSets">dropSets</a></code>, <code><a href="#topic+dropThreshold">dropThreshold</a></code>, <code><a href="#topic+keepThreshold">keepThreshold</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(TunePareto)
data(esl)
data = esl$data
labels = esl$labels
foldList = generateCVRuns(labels  = labels,
                          ntimes      = 2,
                          nfold       = 2,
                          leaveOneOut = FALSE,
                          stratified  = TRUE)
predMap = predictionMap(data, labels, foldList = foldList, 
                       classifier = tunePareto.svm(), kernel='linear')
# generate Subcascades object
subc = subcascades(predMap,thresh=0.7)

#define sets
set1 = list(c(1,2,3),c(2,3,4))
set2 = c('1&gt;2&gt;3','2&gt;3&gt;4')

# filter for the subset cascades that contain either the classes 
# {1,2,3} or {2,3,4} independent of the order, but neighbored
keepSets(subc, sets = set1, direction = 'sub', 
         ordered = FALSE, neighborhood = 'direct')
keepSets(subc, sets = set2, direction = 'sub', 
         ordered = FALSE, neighborhood = 'direct')

# filter for the superset cascades that contain either the classes 
# {1,2,3} or {2,3,4} independent of the order, but neighbored
keepSets(subc, sets = set1, direction = 'super', 
         ordered = FALSE, neighborhood = 'direct')
keepSets(subc, sets = set2, direction = 'super', 
         ordered = FALSE, neighborhood = 'direct')

# filter for the superset cascades that contain both the classes 
# {1,2,3} and {2,3,4} in exactly the given order, but allowing 
# for other classes inbetween
keepSets(subc, sets = set1, direction = 'super', 
        ordered = TRUE, neighborhood = 'indirect', type = 'all')
keepSets(subc, sets = set2, direction = 'super',
        ordered = TRUE, neighborhood = 'indirect', type = 'all')
         
# filter for the exact cascades
# sets can be a numeric list
result &lt;- keepSets(subc, list(c(0,1,2),c(2,3,4,1)),
                   direction = 'exact', ordered=TRUE)
unlist(t(lapply(result,rownames)))
# or sets can be a character vector
result &lt;- keepSets(subc, c('0&gt;1&gt;2','2&gt;3&gt;4&gt;1'),
                   direction = 'exact',ordered=TRUE)
unlist(t(lapply(result,rownames)))         
 
</code></pre>

<hr>
<h2 id='keepSize'>Filter for Size</h2><span id='topic+keepSize'></span>

<h3>Description</h3>

<p>Filters the Subcascades object for cascades of the given sizes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>keepSize(subcascades = NULL, size = NA)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="keepSize_+3A_subcascades">subcascades</code></td>
<td>
<p>A Subcascades object as it is returned by <code><a href="#topic+subcascades">subcascades</a></code>-function.
The Subcascades object is made up of a list of matrices. 
Each matrix comprises the evaluation results of cascades of a specific length and 
is sorted row-wise according to the achieved minimal classwise sensitivities of the cascades (decreasing).
The rownames show the class order by a character string of type '1&gt;2&gt;3' and the entries the sensitivity for each position of the cascade.</p>
</td></tr>
<tr><td><code id="keepSize_+3A_size">size</code></td>
<td>
<p>A numeric value that defines the size of the cascades that should be returned. 
The smallest size is 2 and the largest the maximal number of classes of the current dataset.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A Subcascades object as in <code><a href="#topic+subcascades">subcascades</a></code>, that only includes cascades of specific lengths.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+dropSize">dropSize</a></code>, <code><a href="#topic+dropSets">dropSets</a></code>, <code><a href="#topic+keepSets">keepSets</a></code>, <code><a href="#topic+dropThreshold">dropThreshold</a></code>, <code><a href="#topic+keepThreshold">keepThreshold</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(TunePareto)
data(esl)
data = esl$data
labels = esl$labels
foldList = generateCVRuns(labels  = labels,
                          ntimes      = 2,
                          nfold       = 2,
                          leaveOneOut = FALSE,
                          stratified  = TRUE)
predMap = predictionMap(data, labels, foldList = foldList, 
                       classifier = tunePareto.svm(), kernel='linear')
# generate Subcascades object
subc = subcascades(predMap,thresh=0.7)

# filters for cascades that have a length of 3
keepSize(subc,size=3)
# filters for cascades that have a length of 3 or 4
keepSize(subc, size=c(3,4))
</code></pre>

<hr>
<h2 id='keepThreshold'>Filters for Threshold</h2><span id='topic+keepThreshold'></span>

<h3>Description</h3>

<p>Filters for all cascades that match the comparison with a minimal classwise sensitivity threshold.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>keepThreshold(subcascades = NULL, thresh = 0, comparison = "&gt;=")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="keepThreshold_+3A_subcascades">subcascades</code></td>
<td>
<p>A Subcascades object as it is returned by <code><a href="#topic+subcascades">subcascades</a></code>-function.
The Subcascades object is made up of a list of matrices. 
Each matrix comprises the evaluation results of cascades of a specific length and 
is sorted row-wise according to the achieved minimal classwise sensitivities of the cascades (decreasing).
The rownames show the class order by a character string of type '1&gt;2&gt;3' and the entries the sensitivity for each position of the cascade.</p>
</td></tr>
<tr><td><code id="keepThreshold_+3A_thresh">thresh</code></td>
<td>
<p>A numeric value between 0 and 1.
The minimal sensitivity threshold used to filter the returned cascades. 
Only cascades that pass this threshold are returned. 
If 0 is used the returned cascades are filtered for &gt;0 and otherwise &gt;= thresh.
For low thresholds the calculation lasts longer.</p>
</td></tr>
<tr><td><code id="keepThreshold_+3A_comparison">comparison</code></td>
<td>
<p>Defines the comparison type (&lt;,&gt;,&lt;=,&gt;=) for the threshold.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A Subcascades object comprising the evaluated cascades and their performances. 
The Subcascades object is made up of a list of matrices. 
Each matrix comprises the evaluation results of cascades of a specific length and 
is sorted row-wise according to the achieved minimal classwise sensitivities of the cascades (decreasing).
The rownames show the class order by a character string of type '1&gt;2&gt;3' and the entries the sensitivity for each position of the cascade.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+dropSize">dropSize</a></code>, <code><a href="#topic+keepSize">keepSize</a></code>, <code><a href="#topic+dropSets">dropSets</a></code>, <code><a href="#topic+keepSets">keepSets</a></code>, <code><a href="#topic+dropThreshold">dropThreshold</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(TunePareto)
data(esl)
data = esl$data
labels = esl$labels
foldList = generateCVRuns(labels  = labels,
                          ntimes      = 2,
                          nfold       = 2,
                          leaveOneOut = FALSE,
                          stratified  = TRUE)
predMap = predictionMap(data, labels, foldList = foldList, 
                       classifier = tunePareto.svm(), kernel='linear')
# generate Subcascades object
subc = subcascades(predMap,thresh=0.5)

# filters for cascades that 
# 1. have a minimal classwise sensitivity &gt;= 0.6
keepThreshold(subc,thresh=0.6)
# 2. have a minimal classwise sensitivity &lt;= 0.6
keepThreshold(subc, comparison = '&lt;=', thresh=0.6)
</code></pre>

<hr>
<h2 id='mergeSubcascades'>Merge Subcascades</h2><span id='topic+mergeSubcascades'></span>

<h3>Description</h3>

<p><code>mergeSubcascades</code> adds the cascades from subcascades2 to the subcascades1, that have not been part of subcascades1.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mergeSubcascades(subcascades1 = NULL, subcascades2 = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mergeSubcascades_+3A_subcascades1">subcascades1</code></td>
<td>
<p>A Subcascades object as it is returned by <code><a href="#topic+subcascades">subcascades</a></code>-function.
The Subcascades object is made up of a list of matrices. 
Each matrix comprises the evaluation results of cascades of a specific length. 
The rownames show the class order and the entries the sensitivity for each position of the cascade.</p>
</td></tr>
<tr><td><code id="mergeSubcascades_+3A_subcascades2">subcascades2</code></td>
<td>
<p>A Subcascades object like subcascades1</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A Subcascades object comprising the evaluated cascades and their performances. 
The Subcascades object is made up of a list of matrices. 
Each matrix comprises the evaluation results of cascades of a specific length and 
is sorted row-wise according to the achieved minimal classwise sensitivities of the cascades (decreasing).
The rownames show the class order by a character string of type '1&gt;2&gt;3' and the entries the sensitivity for each position of the cascade.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(TunePareto)
data(esl)
data = esl$data
labels = esl$labels
foldList = generateCVRuns(labels  = labels,
                          ntimes      = 2,
                          nfold       = 2,
                          leaveOneOut = FALSE,
                          stratified  = TRUE)
predMap = predictionMap(data, labels, foldList = foldList, 
                       classifier = tunePareto.svm(), kernel='linear')

# make two Subcascades objects
subc1 = subcascades(predMap, size = c(3,4), thresh = 0.6)
subc2 = subcascades(predMap, size = c(4), thresh = 0.5)
# add the cascades of subcascades2 to subcascades1
mergeSubcascades(subc1, subc2)
</code></pre>

<hr>
<h2 id='nonOrdinalData'>non-ordinal data</h2><span id='topic+nonOrdinalData'></span>

<h3>Description</h3>

<p>It comprises a list of two elements: A data matrix (&quot;data&quot;) and 
a label vector (&quot;labels&quot;). The samples are given in the rows
and the features in the columns of the matrix.
The sampled dataset comprises 5 classes with 40 samples, each. 
It is embedded in a two dimensional feature space 
and contains 5 classes with no ordinal sequence.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(nonOrdinalData)
</code></pre>


<h3>Format</h3>

<p>An object of class <code>list</code> of length 2.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(nonOrdinalData)

</code></pre>

<hr>
<h2 id='ordinalData'>ordinal data</h2><span id='topic+ordinalData'></span>

<h3>Description</h3>

<p>It comprises a list of two elements: A data matrix (&quot;data&quot;) and 
a label vector (&quot;labels&quot;). The samples are given in the rows
and the features in the columns of the matrix.
The sampled dataset comprises 5 classes with 40 samples, each. 
It is embedded in a two dimensional feature space 
and contains 1 ordinal sequence with 5 classes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(ordinalData)
</code></pre>


<h3>Format</h3>

<p>An object of class <code>list</code> of length 2.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(ordinalData)

</code></pre>

<hr>
<h2 id='plot.Conf'>Base Classifier Performance Heatmap</h2><span id='topic+plot.Conf'></span>

<h3>Description</h3>

<p>Plots a heatmap that shows base classifier performance.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'Conf'
plot(
  x = NULL,
  classNames = NULL,
  onlySens = FALSE,
  symmetric = FALSE,
  main = "summary of base classifiers",
  xlab = "classes",
  ylab = "base classifiers",
  digits = 3,
  ignore = 0,
  first.colors = c("#f5f5f5", "#b2182b"),
  second.colors = c("#f5f5f5", "#2166ac"),
  other.colors = c("#f5f5f5", "#1b7837"),
  na.color = c("yellow"),
  las = 1,
  srt = 30,
  color.key = FALSE,
  cex = 1,
  cex.lab = 1,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.Conf_+3A_x">x</code></td>
<td>
<p>A Conf object as it is returned by <code><a href="#topic+conf">conf</a></code>-function.</p>
</td></tr>
<tr><td><code id="plot.Conf_+3A_classnames">classNames</code></td>
<td>
<p>Vector of the original class names. If not given the class number is used instead.</p>
</td></tr>
<tr><td><code id="plot.Conf_+3A_onlysens">onlySens</code></td>
<td>
<p>A logical indicating if the plot should should be restricted to the class-wise sensitivities of the base classifiers.</p>
</td></tr>
<tr><td><code id="plot.Conf_+3A_symmetric">symmetric</code></td>
<td>
<p>Logical indicating whether a symmetric base classifier (TRUE) is used. Only used when onlySens is TRUE.</p>
</td></tr>
<tr><td><code id="plot.Conf_+3A_main">main</code></td>
<td>
<p>See <code><a href="graphics.html#topic+plot">plot</a></code>.</p>
</td></tr>
<tr><td><code id="plot.Conf_+3A_xlab">xlab</code></td>
<td>
<p>A title for the x axis (see <code><a href="graphics.html#topic+plot">plot</a></code>).</p>
</td></tr>
<tr><td><code id="plot.Conf_+3A_ylab">ylab</code></td>
<td>
<p>A title for the y axis (see <code><a href="graphics.html#topic+plot">plot</a></code>).</p>
</td></tr>
<tr><td><code id="plot.Conf_+3A_digits">digits</code></td>
<td>
<p>Integer indicating the number of decimal places to be used (see <code><a href="base.html#topic+round">round</a></code>).</p>
</td></tr>
<tr><td><code id="plot.Conf_+3A_ignore">ignore</code></td>
<td>
<p>A numeric value between 0 and 1. 
All confusion and purity values below this number are not written as string into the corresponding element.</p>
</td></tr>
<tr><td><code id="plot.Conf_+3A_first.colors">first.colors</code></td>
<td>
<p>A 2-element vector of the color for the minimal and maximal class-wise sensitivity of the first class.
The color palette is calcuated by an interpolation between the 2 given colors.</p>
</td></tr>
<tr><td><code id="plot.Conf_+3A_second.colors">second.colors</code></td>
<td>
<p>A 2-element vector of the color for the minimal and maximal class-wise sensitivity of the second class.
The color palette is calcuated by an interpolation between the 2 given colors.</p>
</td></tr>
<tr><td><code id="plot.Conf_+3A_other.colors">other.colors</code></td>
<td>
<p>A 2-element vector of the color for the minimal and maximal class-wise sensitivity of the other class.
The color palette is calcuated by an interpolation between the 2 given colors.</p>
</td></tr>
<tr><td><code id="plot.Conf_+3A_na.color">na.color</code></td>
<td>
<p>Color, which is used for indicating the empty elements (if the given class is not part of the cascade).</p>
</td></tr>
<tr><td><code id="plot.Conf_+3A_las">las</code></td>
<td>
<p>See <code><a href="graphics.html#topic+par">par</a></code>.</p>
</td></tr>
<tr><td><code id="plot.Conf_+3A_srt">srt</code></td>
<td>
<p>Angle used to rotate the strings of the x-axis and y-axis labels (see <code><a href="graphics.html#topic+par">par</a></code>).</p>
</td></tr>
<tr><td><code id="plot.Conf_+3A_color.key">color.key</code></td>
<td>
<p>Specifies whether a color key is drawn (TRUE) or not (FALSE).</p>
</td></tr>
<tr><td><code id="plot.Conf_+3A_cex">cex</code></td>
<td>
<p>See <code><a href="graphics.html#topic+par">par</a></code>.</p>
</td></tr>
<tr><td><code id="plot.Conf_+3A_cex.lab">cex.lab</code></td>
<td>
<p>See <code><a href="graphics.html#topic+par">par</a></code>.</p>
</td></tr>
<tr><td><code id="plot.Conf_+3A_...">...</code></td>
<td>
<p>Further arguments passed from other methods.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function plots a heatmap of the base classifier performance.
</p>


<h3>Value</h3>

<p>No return value, called to generate the heatmap plot.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+conf">conf</a></code>, <code><a href="#topic+plot.Subcascades">plot.Subcascades</a></code>, <code><a href="#topic+plot.ConfusionTable">plot.ConfusionTable</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(TunePareto)
data(esl)
data &lt;- esl$data
labels &lt;- esl$labels
foldList &lt;- generateCVRuns(labels  = labels,
                          ntimes      = 2,
                          nfold       = 2,
                          leaveOneOut = FALSE,
                          stratified  = TRUE)
predMap &lt;- predictionMap(data, labels, foldList = foldList, 
                        classifier = tunePareto.svm(), kernel='linear')
# generate Subcascades object
conf &lt;- conf(predMap)

plot(conf, onlySens=TRUE, symmetric=TRUE)
</code></pre>

<hr>
<h2 id='plot.ConfusionTable'>Extended Confusion Table Plot</h2><span id='topic+plot.ConfusionTable'></span>

<h3>Description</h3>

<p>Plots an extended confusion table.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'ConfusionTable'
plot(
  x = NULL,
  classNames = NULL,
  main = "extended confusion table",
  xlab = "original class labels",
  ylab = "predicted class labels",
  cascLab = "inner classes",
  otherLab = "outer classes",
  digits = 3,
  ignore = 0,
  casc.colors = c("#f5f5f5", "#8c510a"),
  other.colors = c("#f5f5f5", "#01665e"),
  colSep = "#b2182b",
  las = 1,
  color.key = TRUE,
  cex = 1,
  cex.lab = 1,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.ConfusionTable_+3A_x">x</code></td>
<td>
<p>A ConfusionTable object as it is returned by <code><a href="#topic+confusionTable">confusionTable</a></code>-function.</p>
</td></tr>
<tr><td><code id="plot.ConfusionTable_+3A_classnames">classNames</code></td>
<td>
<p>Vector of the original class names. If not given the class number is used instead.</p>
</td></tr>
<tr><td><code id="plot.ConfusionTable_+3A_main">main</code></td>
<td>
<p>See <code><a href="graphics.html#topic+plot">plot</a></code>.</p>
</td></tr>
<tr><td><code id="plot.ConfusionTable_+3A_xlab">xlab</code></td>
<td>
<p>A title for the x axis (see <code><a href="graphics.html#topic+plot">plot</a></code>).</p>
</td></tr>
<tr><td><code id="plot.ConfusionTable_+3A_ylab">ylab</code></td>
<td>
<p>A title for the y axis (see <code><a href="graphics.html#topic+plot">plot</a></code>).</p>
</td></tr>
<tr><td><code id="plot.ConfusionTable_+3A_casclab">cascLab</code></td>
<td>
<p>Character string used as header for the cascade part of the extended confusion table.</p>
</td></tr>
<tr><td><code id="plot.ConfusionTable_+3A_otherlab">otherLab</code></td>
<td>
<p>Character string used as header for the other class part of the extended confusion table.</p>
</td></tr>
<tr><td><code id="plot.ConfusionTable_+3A_digits">digits</code></td>
<td>
<p>Integer indicating the number of decimal places to be used (see <code><a href="base.html#topic+round">round</a></code>).</p>
</td></tr>
<tr><td><code id="plot.ConfusionTable_+3A_ignore">ignore</code></td>
<td>
<p>A numeric value between 0 and 1. 
All confusion and purity values below this number are not written as string into the corresponding element.</p>
</td></tr>
<tr><td><code id="plot.ConfusionTable_+3A_casc.colors">casc.colors</code></td>
<td>
<p>A 2-element vector of the color for the minimal and maximal class-wise sensitivity of the first class.
The color palette is calcuated by an interpolation between the 2 given colors.</p>
</td></tr>
<tr><td><code id="plot.ConfusionTable_+3A_other.colors">other.colors</code></td>
<td>
<p>A 2-element vector of the color for the minimal and maximal class-wise sensitivity of the second class.
The color palette is calcuated by an interpolation between the 2 given colors.</p>
</td></tr>
<tr><td><code id="plot.ConfusionTable_+3A_colsep">colSep</code></td>
<td>
<p>Color, which is used for the vertical line separating the cascade classes and the other classes.</p>
</td></tr>
<tr><td><code id="plot.ConfusionTable_+3A_las">las</code></td>
<td>
<p>See <code><a href="graphics.html#topic+par">par</a></code>.</p>
</td></tr>
<tr><td><code id="plot.ConfusionTable_+3A_color.key">color.key</code></td>
<td>
<p>Specifies whether a color key is drawn (TRUE) or not (FALSE).</p>
</td></tr>
<tr><td><code id="plot.ConfusionTable_+3A_cex">cex</code></td>
<td>
<p>See <code><a href="graphics.html#topic+par">par</a></code>.</p>
</td></tr>
<tr><td><code id="plot.ConfusionTable_+3A_cex.lab">cex.lab</code></td>
<td>
<p>See <code><a href="graphics.html#topic+par">par</a></code>.</p>
</td></tr>
<tr><td><code id="plot.ConfusionTable_+3A_...">...</code></td>
<td>
<p>Further arguments passed from other methods.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>No return value, called to generate the confusion table plot.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+confusionTable">confusionTable</a></code>, <code><a href="#topic+plot.Subcascades">plot.Subcascades</a></code>, <code><a href="#topic+plot.Conf">plot.Conf</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(TunePareto)
data(esl)
data &lt;- esl$data
labels &lt;- esl$labels
foldList &lt;- generateCVRuns(labels  = labels,
                          ntimes      = 2,
                          nfold       = 2,
                          leaveOneOut = FALSE,
                          stratified  = TRUE)
predMap &lt;- predictionMap(data, labels, foldList = foldList, 
                        classifier = tunePareto.svm(), kernel='linear')
# generate Subcascades object
conf.table &lt;- confusionTable(predMap,cascade='0&gt;1&gt;3&gt;4',other.classes = 'all')

plot(conf.table)
</code></pre>

<hr>
<h2 id='plot.Groupwise'>Heatmap of a Groupwise Object</h2><span id='topic+plot.Groupwise'></span>

<h3>Description</h3>

<p>Plots a heatmap, that shows the performance of cascades of a Groupwise object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'Groupwise'
plot(
  x = NULL,
  class.sort = "",
  row.sort = "sens",
  main = "groupwise",
  xlab = "classes",
  ylab = "cascades",
  digits = 3,
  ignore = 0,
  casc.colors = c("#f5f5f5", "#01665e"),
  na.color = c("#f5f5f5"),
  color.key = TRUE,
  las = 1,
  cex = 1,
  cex.lab = 1,
  srt = 30,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.Groupwise_+3A_x">x</code></td>
<td>
<p>A Groupwise object as it is returned by <code><a href="#topic+groupwise">groupwise</a></code>-function.</p>
</td></tr>
<tr><td><code id="plot.Groupwise_+3A_class.sort">class.sort</code></td>
<td>
<p>The classes can be sorted either according to the first cascade in the Groupwise object (&rdquo;), 
or based on the class frequency ('max').</p>
</td></tr>
<tr><td><code id="plot.Groupwise_+3A_row.sort">row.sort</code></td>
<td>
<p>The cascade can be sorted either based on the maximal-minimal class-wise sensitivity ('sens') or 
according the class frequency.</p>
</td></tr>
<tr><td><code id="plot.Groupwise_+3A_main">main</code></td>
<td>
<p>See <code><a href="graphics.html#topic+plot">plot</a></code>.</p>
</td></tr>
<tr><td><code id="plot.Groupwise_+3A_xlab">xlab</code></td>
<td>
<p>A title for the x axis (see <code><a href="graphics.html#topic+plot">plot</a></code>).</p>
</td></tr>
<tr><td><code id="plot.Groupwise_+3A_ylab">ylab</code></td>
<td>
<p>A title for the y axis (see <code><a href="graphics.html#topic+plot">plot</a></code>).</p>
</td></tr>
<tr><td><code id="plot.Groupwise_+3A_digits">digits</code></td>
<td>
<p>Integer indicating the number of decimal places to be used (see <code><a href="base.html#topic+round">round</a></code>).</p>
</td></tr>
<tr><td><code id="plot.Groupwise_+3A_ignore">ignore</code></td>
<td>
<p>A numeric value between 0 and 1. 
All confusion and purity values below this number are not written as string into the corresponding element.</p>
</td></tr>
<tr><td><code id="plot.Groupwise_+3A_casc.colors">casc.colors</code></td>
<td>
<p>A 2-element vector of the color for the minimal and maximal class-wise sensitivity. 
The color palette is calcuated by an interpolation between the 2 given colors.</p>
</td></tr>
<tr><td><code id="plot.Groupwise_+3A_na.color">na.color</code></td>
<td>
<p>Color, which is used for indicating the empty elements (if the given class is not part of the cascade).</p>
</td></tr>
<tr><td><code id="plot.Groupwise_+3A_color.key">color.key</code></td>
<td>
<p>Specifies whether a color key is drawn (TRUE) or not (FALSE).</p>
</td></tr>
<tr><td><code id="plot.Groupwise_+3A_las">las</code></td>
<td>
<p>See <code><a href="graphics.html#topic+par">par</a></code>.</p>
</td></tr>
<tr><td><code id="plot.Groupwise_+3A_cex">cex</code></td>
<td>
<p>See <code><a href="graphics.html#topic+par">par</a></code>.</p>
</td></tr>
<tr><td><code id="plot.Groupwise_+3A_cex.lab">cex.lab</code></td>
<td>
<p>See <code><a href="graphics.html#topic+par">par</a></code>.</p>
</td></tr>
<tr><td><code id="plot.Groupwise_+3A_srt">srt</code></td>
<td>
<p>Angle used to rotate the strings of the x-axis and y-axis labels (see <code><a href="graphics.html#topic+par">par</a></code>).</p>
</td></tr>
<tr><td><code id="plot.Groupwise_+3A_...">...</code></td>
<td>
<p>Further arguments passed from other methods.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function plots a heatmap with the cascades of the Groupwise object in the rows 
and all classes present in any of the cascades in the columns. 
The colors indicate whether a given class is present in the corresponding cascade and with which sensitivity.
Internally converts the Groupwise object to a Subcascades object and plots the corresponding heatmap.
</p>


<h3>Value</h3>

<p>No return value, called to generate the heatmap plot of the Groupwise Object.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+groupwise">groupwise</a></code>, <code><a href="#topic+subcascades">subcascades</a></code>, <code><a href="#topic+plot.Subcascades">plot.Subcascades</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(TunePareto)
data(esl)
data &lt;- esl$data
labels &lt;- esl$labels
foldList &lt;- generateCVRuns(labels  = labels,
                          ntimes      = 2,
                          nfold       = 2,
                          leaveOneOut = FALSE,
                          stratified  = TRUE)
predMap &lt;- predictionMap(data, labels, foldList = foldList, 
                        classifier = tunePareto.svm(), kernel='linear')
# generate Subcascades object
subc &lt;- subcascades(predMap,thresh=0.7,size=c(3,4))
groupwise &lt;- groupwise(subc)

plot(groupwise,row.sort='max')

</code></pre>

<hr>
<h2 id='plot.PredictionMap'>Heatmap of a PredictionMap Object</h2><span id='topic+plot.PredictionMap'></span>

<h3>Description</h3>

<p>Plots a heatmap, that shows the predictions of a PredictionMap object and 
the real labels in a cross-validation or reclassification experiment.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'PredictionMap'
plot(
  x = NULL,
  xlab = "samples",
  ylab = "base classifiers",
  main = "Prediction map",
  las = 1,
  srt = 30,
  cex = 1,
  cex.lab = 1,
  label.colors = NULL,
  plot.sampleIDs = FALSE,
  plot.cv.runs = TRUE,
  plot.class.labels = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.PredictionMap_+3A_x">x</code></td>
<td>
<p>A PredictonMap object as it is returned by <code><a href="#topic+predictionMap">predictionMap</a></code>-function.</p>
</td></tr>
<tr><td><code id="plot.PredictionMap_+3A_xlab">xlab</code></td>
<td>
<p>A title for the x axis (see <code><a href="graphics.html#topic+plot">plot</a></code>).</p>
</td></tr>
<tr><td><code id="plot.PredictionMap_+3A_ylab">ylab</code></td>
<td>
<p>A title for the y axis (see <code><a href="graphics.html#topic+plot">plot</a></code>).</p>
</td></tr>
<tr><td><code id="plot.PredictionMap_+3A_main">main</code></td>
<td>
<p>See <code><a href="graphics.html#topic+plot">plot</a></code>.</p>
</td></tr>
<tr><td><code id="plot.PredictionMap_+3A_las">las</code></td>
<td>
<p>See <code><a href="graphics.html#topic+par">par</a></code>.</p>
</td></tr>
<tr><td><code id="plot.PredictionMap_+3A_srt">srt</code></td>
<td>
<p>Angle used to rotate the strings of the x-axis and y-axis labels (see <code><a href="graphics.html#topic+par">par</a></code>).</p>
</td></tr>
<tr><td><code id="plot.PredictionMap_+3A_cex">cex</code></td>
<td>
<p>See <code><a href="graphics.html#topic+par">par</a></code>.</p>
</td></tr>
<tr><td><code id="plot.PredictionMap_+3A_cex.lab">cex.lab</code></td>
<td>
<p>See <code><a href="graphics.html#topic+par">par</a></code>.</p>
</td></tr>
<tr><td><code id="plot.PredictionMap_+3A_label.colors">label.colors</code></td>
<td>
<p>A vector of the color for the class labels. 
If NULL, automatically use rainbow color scheme.</p>
</td></tr>
<tr><td><code id="plot.PredictionMap_+3A_plot.sampleids">plot.sampleIDs</code></td>
<td>
<p>Specifices if the sample IDs should be plotted along the x axis (TRUE or FALSE).</p>
</td></tr>
<tr><td><code id="plot.PredictionMap_+3A_plot.cv.runs">plot.cv.runs</code></td>
<td>
<p>Specifices if the cross-validation runs should be plotted (TRUE or FALSE). 
Cross-validation runs are visually separated by straight lines.</p>
</td></tr>
<tr><td><code id="plot.PredictionMap_+3A_plot.class.labels">plot.class.labels</code></td>
<td>
<p>Specificies if the numerical class labels should additionally plotted (TRUE or FALSE).</p>
</td></tr>
<tr><td><code id="plot.PredictionMap_+3A_...">...</code></td>
<td>
<p>Further arguments passed from other methods.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function plots a heatmap with color-decoded predictions made by the 
specified classifier.
Here, the rows indicate the different binary base classifiers and the columns the samples 
in the specified resampling experiment (reclassification or cross-validation).
Labels are visualized in the top row and decoded color-wise.
</p>


<h3>Value</h3>

<p>No return value, called to a heatmap plot of the predictionMap Object.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+predictionMap">predictionMap</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(TunePareto)
data(esl)
data &lt;- esl$data
labels &lt;- esl$labels
foldList &lt;- generateCVRuns(labels  = labels,
                          ntimes      = 2,
                          nfold       = 2,
                          leaveOneOut = FALSE,
                          stratified  = TRUE)
predMap &lt;- predictionMap(data, labels, foldList = foldList, 
                        classifier = tunePareto.svm(), kernel='linear')

plot(predMap)

</code></pre>

<hr>
<h2 id='plot.Subcascades'>Heatmap of a Subcascades Object</h2><span id='topic+plot.Subcascades'></span>

<h3>Description</h3>

<p>Plots a heatmap, that shows the performance of cascades of a Subcascades object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'Subcascades'
plot(
  x = NULL,
  classNames = NULL,
  class.sort = "",
  row.sort = "",
  main = "subcascades",
  xlab = "classes",
  ylab = "cascades",
  digits = 3,
  ignore = 0,
  casc.colors = c("#f5f5f5", "#01665e"),
  na.color = c("#f5f5f5"),
  color.key = TRUE,
  las = 1,
  cex = 1,
  cex.lab = 1,
  srt = 30,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.Subcascades_+3A_x">x</code></td>
<td>
<p>A Subcascades object as it is returned by <code><a href="#topic+subcascades">subcascades</a></code>-function.</p>
</td></tr>
<tr><td><code id="plot.Subcascades_+3A_classnames">classNames</code></td>
<td>
<p>Character vector including the names of the classes.</p>
</td></tr>
<tr><td><code id="plot.Subcascades_+3A_class.sort">class.sort</code></td>
<td>
<p>The classes can be sorted either by:
&quot;&quot; = unsorted, &quot;max&quot;: sorted according to maximal occurrence of a class or 
&quot;sens&quot;: sorted according to highest class-wise sensitivity</p>
</td></tr>
<tr><td><code id="plot.Subcascades_+3A_row.sort">row.sort</code></td>
<td>
<p>The cascade can be sorted by:
&quot;&quot; = unsorted, &quot;max&quot;: sorted according to maximal occurrence of maximal length or 
&quot;sens&quot;: sorted according to highest class-wise sensitivity</p>
</td></tr>
<tr><td><code id="plot.Subcascades_+3A_main">main</code></td>
<td>
<p>See <code><a href="graphics.html#topic+plot">plot</a></code>.</p>
</td></tr>
<tr><td><code id="plot.Subcascades_+3A_xlab">xlab</code></td>
<td>
<p>A title for the x axis (see <code><a href="graphics.html#topic+plot">plot</a></code>).</p>
</td></tr>
<tr><td><code id="plot.Subcascades_+3A_ylab">ylab</code></td>
<td>
<p>A title for the y axis (see <code><a href="graphics.html#topic+plot">plot</a></code>).</p>
</td></tr>
<tr><td><code id="plot.Subcascades_+3A_digits">digits</code></td>
<td>
<p>Integer indicating the number of decimal places to be used (see <code><a href="base.html#topic+round">round</a></code>).</p>
</td></tr>
<tr><td><code id="plot.Subcascades_+3A_ignore">ignore</code></td>
<td>
<p>A numeric value between 0 and 1. 
All confusion and purity values below this number are not written as string into the corresponding element.</p>
</td></tr>
<tr><td><code id="plot.Subcascades_+3A_casc.colors">casc.colors</code></td>
<td>
<p>A 2-element vector of the color for the minimal and maximal class-wise sensitivity. 
The color palette is calcuated by an interpolation between the 2 given colors.</p>
</td></tr>
<tr><td><code id="plot.Subcascades_+3A_na.color">na.color</code></td>
<td>
<p>Color, which is used for indicating the empty elements (if the given class is not part of the cascade).</p>
</td></tr>
<tr><td><code id="plot.Subcascades_+3A_color.key">color.key</code></td>
<td>
<p>Specifies whether a color key is drawn (TRUE) or not (FALSE).</p>
</td></tr>
<tr><td><code id="plot.Subcascades_+3A_las">las</code></td>
<td>
<p>See <code><a href="graphics.html#topic+par">par</a></code>.</p>
</td></tr>
<tr><td><code id="plot.Subcascades_+3A_cex">cex</code></td>
<td>
<p>See <code><a href="graphics.html#topic+par">par</a></code>.</p>
</td></tr>
<tr><td><code id="plot.Subcascades_+3A_cex.lab">cex.lab</code></td>
<td>
<p>See <code><a href="graphics.html#topic+par">par</a></code>.</p>
</td></tr>
<tr><td><code id="plot.Subcascades_+3A_srt">srt</code></td>
<td>
<p>Angle used to rotate the strings of the x-axis and y-axis labels (see <code><a href="graphics.html#topic+par">par</a></code>).</p>
</td></tr>
<tr><td><code id="plot.Subcascades_+3A_...">...</code></td>
<td>
<p>Further arguments passed from other methods.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function plots a heatmap with the cascades of the Subcascades object in the rows 
and all classes present in any of the cascades in the columns. 
The colors indicate whether a given class is present in the corresponding cascade and with which sensitivity.
</p>


<h3>Value</h3>

<p>No return value, called to generate the heatmap plot of the subcascades Object.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+subcascades">subcascades</a></code>, <code><a href="#topic+plot.Conf">plot.Conf</a></code>, <code><a href="#topic+plot.ConfusionTable">plot.ConfusionTable</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(TunePareto)
data(esl)
data &lt;- esl$data
labels &lt;- esl$labels
foldList &lt;- generateCVRuns(labels  = labels,
                          ntimes      = 2,
                          nfold       = 2,
                          leaveOneOut = FALSE,
                          stratified  = TRUE)
predMap &lt;- predictionMap(data, labels, foldList = foldList, 
                        classifier = tunePareto.svm(), kernel='linear')
# generate Subcascades object
subc &lt;- subcascades(predMap,thresh=0.7,size=c(3,4))

plot(subc,row.sort='max')

</code></pre>

<hr>
<h2 id='plotBaseClassifier'>Base Classifier Performance Heatmap</h2><span id='topic+plotBaseClassifier'></span>

<h3>Description</h3>

<p>Plots a heatmap that shows base classifier performance.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plotBaseClassifier(
  x = NULL,
  classNames = NULL,
  symmetric = FALSE,
  main = "summary of base classifiers",
  xlab = "second class",
  ylab = "first class",
  digits = 3,
  ignore = 0,
  first.colors = c("#f5f5f5", "#8c510a"),
  second.colors = c("#f5f5f5", "#01665e"),
  na.color = c("yellow"),
  las = 1,
  color.key = TRUE,
  cex = 1,
  cex.lab = 1,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plotBaseClassifier_+3A_x">x</code></td>
<td>
<p>A Conf object as it is returned by <code><a href="#topic+conf">conf</a></code>-function.</p>
</td></tr>
<tr><td><code id="plotBaseClassifier_+3A_classnames">classNames</code></td>
<td>
<p>Vector of the original class names. If not given the class number is used instead.</p>
</td></tr>
<tr><td><code id="plotBaseClassifier_+3A_symmetric">symmetric</code></td>
<td>
<p>Logical indicating whether a symmetric base classifier (TRUE) is used.</p>
</td></tr>
<tr><td><code id="plotBaseClassifier_+3A_main">main</code></td>
<td>
<p>See <code><a href="graphics.html#topic+plot">plot</a></code>.</p>
</td></tr>
<tr><td><code id="plotBaseClassifier_+3A_xlab">xlab</code></td>
<td>
<p>A title for the x axis (see <code><a href="graphics.html#topic+plot">plot</a></code>).</p>
</td></tr>
<tr><td><code id="plotBaseClassifier_+3A_ylab">ylab</code></td>
<td>
<p>A title for the y axis (see <code><a href="graphics.html#topic+plot">plot</a></code>).</p>
</td></tr>
<tr><td><code id="plotBaseClassifier_+3A_digits">digits</code></td>
<td>
<p>Integer indicating the number of decimal places to be used (see <code><a href="base.html#topic+round">round</a></code>).</p>
</td></tr>
<tr><td><code id="plotBaseClassifier_+3A_ignore">ignore</code></td>
<td>
<p>A numeric value between 0 and 1. 
All confusion and purity values below this number are not written as string into the corresponding element.</p>
</td></tr>
<tr><td><code id="plotBaseClassifier_+3A_first.colors">first.colors</code></td>
<td>
<p>A 2-element vector of the color for the minimal and maximal class-wise sensitivity of the first class.
The color palette is calcuated by an interpolation between the 2 given colors.</p>
</td></tr>
<tr><td><code id="plotBaseClassifier_+3A_second.colors">second.colors</code></td>
<td>
<p>A 2-element vector of the color for the minimal and maximal class-wise sensitivity of the second class.
The color palette is calcuated by an interpolation between the 2 given colors.</p>
</td></tr>
<tr><td><code id="plotBaseClassifier_+3A_na.color">na.color</code></td>
<td>
<p>Color, which is used for indicating the empty elements (if the given class is not part of the cascade).</p>
</td></tr>
<tr><td><code id="plotBaseClassifier_+3A_las">las</code></td>
<td>
<p>See <code><a href="graphics.html#topic+par">par</a></code>.</p>
</td></tr>
<tr><td><code id="plotBaseClassifier_+3A_color.key">color.key</code></td>
<td>
<p>Specifies whether a color key is drawn (TRUE) or not (FALSE).</p>
</td></tr>
<tr><td><code id="plotBaseClassifier_+3A_cex">cex</code></td>
<td>
<p>See <code><a href="graphics.html#topic+par">par</a></code>.</p>
</td></tr>
<tr><td><code id="plotBaseClassifier_+3A_cex.lab">cex.lab</code></td>
<td>
<p>See <code><a href="graphics.html#topic+par">par</a></code>.</p>
</td></tr>
<tr><td><code id="plotBaseClassifier_+3A_...">...</code></td>
<td>
<p>Further arguments passed from other methods.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function plots a heatmap of the base classifier performance.
</p>


<h3>Value</h3>

<p>No return value, called to generate the heatmap plot.
</p>

<hr>
<h2 id='plotConf'>Base Classifier Performance Heatmap</h2><span id='topic+plotConf'></span>

<h3>Description</h3>

<p>Plots a heatmap that shows base classifier performance.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plotConf(
  x = NULL,
  classNames = NULL,
  main = "summary of base classifiers",
  xlab = "classes",
  ylab = "base classifiers",
  digits = 3,
  ignore = 0,
  first.colors = c("#f5f5f5", "#b2182b"),
  second.colors = c("#f5f5f5", "#2166ac"),
  other.colors = c("#f5f5f5", "#1b7837"),
  las = 1,
  srt = 30,
  color.key = FALSE,
  cex = 1,
  cex.lab = 1,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plotConf_+3A_x">x</code></td>
<td>
<p>A Conf object as it is returned by <code><a href="#topic+conf">conf</a></code>-function.</p>
</td></tr>
<tr><td><code id="plotConf_+3A_classnames">classNames</code></td>
<td>
<p>Vector of the original class names. If not given the class number is used instead.</p>
</td></tr>
<tr><td><code id="plotConf_+3A_main">main</code></td>
<td>
<p>See <code><a href="graphics.html#topic+plot">plot</a></code>.</p>
</td></tr>
<tr><td><code id="plotConf_+3A_xlab">xlab</code></td>
<td>
<p>A title for the x axis (see <code><a href="graphics.html#topic+plot">plot</a></code>).</p>
</td></tr>
<tr><td><code id="plotConf_+3A_ylab">ylab</code></td>
<td>
<p>A title for the y axis (see <code><a href="graphics.html#topic+plot">plot</a></code>).</p>
</td></tr>
<tr><td><code id="plotConf_+3A_digits">digits</code></td>
<td>
<p>Integer indicating the number of decimal places to be used (see <code><a href="base.html#topic+round">round</a></code>).</p>
</td></tr>
<tr><td><code id="plotConf_+3A_ignore">ignore</code></td>
<td>
<p>A numeric value between 0 and 1. 
All confusion and purity values below this number are not written as string into the corresponding element.</p>
</td></tr>
<tr><td><code id="plotConf_+3A_first.colors">first.colors</code></td>
<td>
<p>A 2-element vector of the color for the minimal and maximal class-wise sensitivity of the first class.
The color palette is calcuated by an interpolation between the 2 given colors.</p>
</td></tr>
<tr><td><code id="plotConf_+3A_second.colors">second.colors</code></td>
<td>
<p>A 2-element vector of the color for the minimal and maximal class-wise sensitivity of the second class.
The color palette is calcuated by an interpolation between the 2 given colors.</p>
</td></tr>
<tr><td><code id="plotConf_+3A_other.colors">other.colors</code></td>
<td>
<p>A 2-element vector of the color for the minimal and maximal class-wise sensitivity of the other class.
The color palette is calcuated by an interpolation between the 2 given colors.</p>
</td></tr>
<tr><td><code id="plotConf_+3A_las">las</code></td>
<td>
<p>See <code><a href="graphics.html#topic+par">par</a></code>.</p>
</td></tr>
<tr><td><code id="plotConf_+3A_srt">srt</code></td>
<td>
<p>Angle used to rotate the strings of the x-axis and y-axis labels (see <code><a href="graphics.html#topic+par">par</a></code>).</p>
</td></tr>
<tr><td><code id="plotConf_+3A_color.key">color.key</code></td>
<td>
<p>Specifies whether a color key is drawn (TRUE) or not (FALSE).</p>
</td></tr>
<tr><td><code id="plotConf_+3A_cex">cex</code></td>
<td>
<p>See <code><a href="graphics.html#topic+par">par</a></code>.</p>
</td></tr>
<tr><td><code id="plotConf_+3A_cex.lab">cex.lab</code></td>
<td>
<p>See <code><a href="graphics.html#topic+par">par</a></code>.</p>
</td></tr>
<tr><td><code id="plotConf_+3A_...">...</code></td>
<td>
<p>Further arguments passed from other methods.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function plots a heatmap of the base classifier performance.
</p>


<h3>Value</h3>

<p>No return value, called to generate the heatmap plot.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+conf">conf</a></code>, <code><a href="#topic+plot.Subcascades">plot.Subcascades</a></code>, <code><a href="#topic+plot.ConfusionTable">plot.ConfusionTable</a></code>
</p>

<hr>
<h2 id='predictionMap'>Construction of a Prediction Map Object</h2><span id='topic+predictionMap'></span>

<h3>Description</h3>

<p>Makes a PredictionMap object for the given data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>predictionMap(
  data = NULL,
  labels = NULL,
  foldList = NULL,
  parallel = FALSE,
  classifier = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="predictionMap_+3A_data">data</code></td>
<td>
<p>The data either as matrix or data.frame with samples in rows and features in columns.</p>
</td></tr>
<tr><td><code id="predictionMap_+3A_labels">labels</code></td>
<td>
<p>A vector of labels of data, consecutively labelled starting with 0.</p>
</td></tr>
<tr><td><code id="predictionMap_+3A_foldlist">foldList</code></td>
<td>
<p>A set of partitions for a cross-validation experiment. 
This list comprises as many elements as cross-validation runs. 
Each run is a list of as many vectors as folds. The entries are the indices of the samples that are left out in the folds.
This fold list can be generated by using <code>TunePareto::generateCVRuns</code>.
If the foldList is set to <code>NULL</code> (default) reclassification is performed.</p>
</td></tr>
<tr><td><code id="predictionMap_+3A_parallel">parallel</code></td>
<td>
<p>Either TRUE or FALSE (default). If TRUE the pairwise training is performed parallelized.</p>
</td></tr>
<tr><td><code id="predictionMap_+3A_classifier">classifier</code></td>
<td>
<p>A TunePareto classifier object. <br /> 
For detailed information refer to <code>TunePareto::tuneParetoClassifier</code>.</p>
</td></tr>
<tr><td><code id="predictionMap_+3A_...">...</code></td>
<td>
<p>Further parameters of the classifier object.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Using a reclassification or a cross-validation set up this function performs a pairwise training for all class combinations and evaluates all samples using the trained classifiers.
This means that for each run, fold and binary classifier the predicted class for each sample is calculated.
</p>


<h3>Value</h3>

<p>A PredictionMap object.
It is made up of a list of two matrices, which are called meta and pred. Both matrices provide information for individual samples column-wise. The meta information in meta connects the values in the pred-matrix to a specific fold, run, sample and contains the original label.
The rownames of the pred-matrix (e.g. [0vs1]) show the classes of the binary base classifier. The elements are the prediction result of a specific training.
The rows that correspond to base classifiers that would separate the same class consists of -1. Those rows are not used within the analysis.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+summary.PredictionMap">summary.PredictionMap</a></code>, <code><a href="#topic+print.PredictionMap">print.PredictionMap</a></code>, <code><a href="#topic+plot.PredictionMap">plot.PredictionMap</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(TunePareto)
data(esl)
data = esl$data
labels = esl$labels
foldList = generateCVRuns(labels  = labels,
                          ntimes      = 2,
                          nfold       = 2,
                          leaveOneOut = FALSE,
                          stratified  = TRUE)
                          
# svm with linear kernel
predMap = predictionMap(data, labels, foldList = foldList, 
                       classifier = tunePareto.svm(), kernel='linear')

# knn with k = 3
predMap = predictionMap(data, labels, foldList = foldList, 
                       classifier = tunePareto.knn(), k = 3)
# randomForest
predMap = predictionMap(data, labels, foldList = foldList, 
                       classifier = tunePareto.randomForest())
                           
</code></pre>

<hr>
<h2 id='print.Conf'>Prints all details about a Conf object.</h2><span id='topic+print.Conf'></span>

<h3>Description</h3>

<p>Prints all details about a Conf object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'Conf'
print(x, printfC = TRUE, printsC = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.Conf_+3A_x">x</code></td>
<td>
<p>A Conf object as it is returned by <code><a href="#topic+conf">conf</a></code>-function.</p>
</td></tr>
<tr><td><code id="print.Conf_+3A_printfc">printfC</code></td>
<td>
<p>If TRUE, the sensitivities of the first classes are printed (TP = true positives).</p>
</td></tr>
<tr><td><code id="print.Conf_+3A_printsc">printsC</code></td>
<td>
<p>If TRUE, the values of sC are printed (TN = true negatives). The values of sC 
correspond to the rate of samples of a given class (column), which are assigned to the 
second class of the base classifier (row).</p>
</td></tr>
<tr><td><code id="print.Conf_+3A_...">...</code></td>
<td>
<p>Further parameters</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Prints all details about a given Conf object. 
A Conf object provides the conditional prediction rates of all base classifiers applied to all classes.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(TunePareto)
data(esl)
data = esl$data
labels = esl$labels
foldList = generateCVRuns(labels  = labels,
                          ntimes      = 2,
                          nfold       = 2,
                          leaveOneOut = FALSE,
                          stratified  = TRUE)
predMap = predictionMap(data, labels, foldList = foldList, 
                       classifier = tunePareto.svm(), kernel='linear')

conf = conf(predMap)

print(conf)
</code></pre>

<hr>
<h2 id='print.ConfusionTable'>Prints all details about a ConfusionTable object.</h2><span id='topic+print.ConfusionTable'></span>

<h3>Description</h3>

<p>Prints all details about a ConfusionTable object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'ConfusionTable'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.ConfusionTable_+3A_x">x</code></td>
<td>
<p>A ConfusionTable object as it is returned by <code><a href="#topic+confusionTable">confusionTable</a></code>-function.</p>
</td></tr>
<tr><td><code id="print.ConfusionTable_+3A_...">...</code></td>
<td>
<p>Further parameters</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Prints all conditional prediction rates for the specified cascade.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(TunePareto)
data(esl)
data = esl$data
labels = esl$labels
foldList = generateCVRuns(labels  = labels,
                          ntimes      = 2,
                          nfold       = 2,
                          leaveOneOut = FALSE,
                          stratified  = TRUE)
predMap = predictionMap(data, labels, foldList = foldList, 
                       classifier = tunePareto.svm(), kernel='linear')

# Calculation of the confusion matrix for '0&gt;2&gt;3&gt;4'.
confTable = confusionTable(predMap, cascade = '0&gt;2&gt;3&gt;4')

print(confTable)
</code></pre>

<hr>
<h2 id='print.Groupwise'>Prints all details about a Groupwise object.</h2><span id='topic+print.Groupwise'></span>

<h3>Description</h3>

<p>Prints all details about a Groupwise object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'Groupwise'
print(x, printSizes = length(x), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.Groupwise_+3A_x">x</code></td>
<td>
<p>A Groupwise object as it is returned by <code><a href="#topic+groupwise">groupwise</a></code>-function.</p>
</td></tr>
<tr><td><code id="print.Groupwise_+3A_printsizes">printSizes</code></td>
<td>
<p>Integer that specifies how many of the cascade sizes (starting with the largest cascades) 
should be printed.</p>
</td></tr>
<tr><td><code id="print.Groupwise_+3A_...">...</code></td>
<td>
<p>Further parameters</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Prints all details about a given Groupwise object. 
A Groupwise object re-sorts a Subcascades object 
in a way that the cascades made up of the same classes are grouped. 
The printSizes parameter can be used to control the cascade sizes to be printed.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(TunePareto)
data(esl)
data = esl$data
labels = esl$labels
foldList = generateCVRuns(labels  = labels,
                          ntimes      = 2,
                          nfold       = 2,
                          leaveOneOut = FALSE,
                          stratified  = TRUE)
predMap = predictionMap(data, labels, foldList = foldList, 
                       classifier = tunePareto.svm(), kernel='linear')

# generate Subcascades object
subc = subcascades(predMap,thresh=0.7)

#create a Groupwise object
groupwise = groupwise(subc)

print(groupwise, printSizes = 2)
</code></pre>

<hr>
<h2 id='print.PredictionMap'>Prints all details about a PredictionMap object.</h2><span id='topic+print.PredictionMap'></span>

<h3>Description</h3>

<p>Prints all details about a PredictionMap object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'PredictionMap'
print(x, showMeta = TRUE, showPred = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.PredictionMap_+3A_x">x</code></td>
<td>
<p>A PredictionMap object generated by <code><a href="#topic+predictionMap">predictionMap</a></code>.</p>
</td></tr>
<tr><td><code id="print.PredictionMap_+3A_showmeta">showMeta</code></td>
<td>
<p>If TRUE the meta data of the PredictionMap object will be printed.</p>
</td></tr>
<tr><td><code id="print.PredictionMap_+3A_showpred">showPred</code></td>
<td>
<p>If TRUE the predictions of the PredictionMap object will be printed.</p>
</td></tr>
<tr><td><code id="print.PredictionMap_+3A_...">...</code></td>
<td>
<p>Further parameters</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Prints all details about a given PredictionMap object and information about the meta information as well as the predictions.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(TunePareto)
data(esl)
data = esl$data
labels = esl$labels
foldList = generateCVRuns(labels  = labels,
                          ntimes      = 2,
                          nfold       = 2,
                          leaveOneOut = FALSE,
                          stratified  = TRUE)
                          
# svm with linear kernel
predMap = predictionMap(data, labels, foldList = foldList, 
                       classifier = tunePareto.svm(), kernel='linear')
                           
print(predMap, showMeta=TRUE, showPred=TRUE)
</code></pre>

<hr>
<h2 id='print.Subcascades'>Prints all details about a Subcascades object.</h2><span id='topic+print.Subcascades'></span>

<h3>Description</h3>

<p>Prints all details about a Subcascades object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'Subcascades'
print(x, printSizes = length(x), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.Subcascades_+3A_x">x</code></td>
<td>
<p>A Subcascades object generated by <code><a href="#topic+subcascades">subcascades</a></code>.</p>
</td></tr>
<tr><td><code id="print.Subcascades_+3A_printsizes">printSizes</code></td>
<td>
<p>Integer specifying how many elements of a Subcascades object should be printed, 
sorted decreasingly after cascade length.</p>
</td></tr>
<tr><td><code id="print.Subcascades_+3A_...">...</code></td>
<td>
<p>Further parameters</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Prints all details about a given Subcascades object.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(TunePareto)
data(esl)
data = esl$data
labels = esl$labels
foldList = generateCVRuns(labels  = labels,
                          ntimes      = 2,
                          nfold       = 2,
                          leaveOneOut = FALSE,
                          stratified  = TRUE)
predMap = predictionMap(data, labels, foldList = foldList, 
                       classifier = tunePareto.svm(),  kernel='linear')

# use default parameter settings 
# -&gt; returns cascades of all lengths that show a minimal classwise sensitivity &gt;0.
subc = subcascades(predMap)

# print subcascades for the largest 2 sizes
print(subc, printSize=2)
</code></pre>

<hr>
<h2 id='screeningData'>screening data</h2><span id='topic+screeningData'></span>

<h3>Description</h3>

<p>It comprises a list of two elements: A data matrix (&quot;data&quot;) and 
a label vector (&quot;labels&quot;). The samples are given in the rows
and the features in the columns of the matrix.
The sampled dataset comprises 6 classes with 40 samples, each. 
It is embedded in a two dimensional feature space 
and contains 2 ordinal sequences with 5 classes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(screeningData)
</code></pre>


<h3>Format</h3>

<p>An object of class <code>list</code> of length 2.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(screeningData)

</code></pre>

<hr>
<h2 id='subcascades'>Subcascades Evaluation</h2><span id='topic+subcascades'></span>

<h3>Description</h3>

<p><code>Subcascades</code> returns all cascades found within the data or evaluates a set of specific cascades.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>subcascades(
  predictionMap = NULL,
  sets = NULL,
  thresh = 0,
  size = NA,
  numSol = 1000
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="subcascades_+3A_predictionmap">predictionMap</code></td>
<td>
<p>A PredictionMap object as it is returned by <code><a href="#topic+predictionMap">predictionMap</a></code>-function. 
It is made up of a list of two matrices(pred and meta). Both matrices provide information on individual samples column-wise.
The rownames of the pred-matrix (e.g. [0vs1]) show the classes of the binary base classifier. The elements are the prediction result of a specific training.
The rows that correspond to base classifiers that would separate the same class consists of -1. Those rows are not used within the analysis.
The meta information connects the values in the pred-matrix to a specific fold, run and contains the original label.</p>
</td></tr>
<tr><td><code id="subcascades_+3A_sets">sets</code></td>
<td>
<p>Contains the set used for filtering. It is either a list of numeric vectors, a numeric vector, 
or a vector of characters representing a cascade of the following format '1&gt;2&gt;4'. Empty vectors are not allowed.</p>
</td></tr>
<tr><td><code id="subcascades_+3A_thresh">thresh</code></td>
<td>
<p>A numeric value between 0 and 1.
The minimal sensitivity threshold used to filter the returned cascades. 
Only cascades that pass this threshold are returned. 
If 0 is used the returned cascades are filtered for &gt;0 and otherwise &gt;= thresh.
For low thresholds the calculation lasts longer.</p>
</td></tr>
<tr><td><code id="subcascades_+3A_size">size</code></td>
<td>
<p>A numeric value that defines the size of the cascades that should be returned. 
The smallest size is 2 and the largest the maximal number of classes of the current dataset.
If size is NA (the default setting), all cascades from 2 to the maximal number of classes are evaluated.</p>
</td></tr>
<tr><td><code id="subcascades_+3A_numsol">numSol</code></td>
<td>
<p>The maximum number of cascades that should pass the first sensitivity bound and are 
further evaluated.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function can either be used to evaluate the performance of a specific cascade, a set of cascades or 
to filter out the set of cascades of a specific size and passing a given threshold. 
If the sets-variable is given no size can be set.
</p>


<h3>Value</h3>

<p>A Subcascades object comprising the evaluated cascades and their performances. 
The Subcascades object is made up of a list of matrices. 
Each matrix comprises the evaluation results of cascades of a specific length and 
is sorted row-wise according to the achieved minimal classwise sensitivities of the cascades (decreasing).
The rownames show the class order by a character string of type '1&gt;2&gt;3' and the entries the sensitivity for each position of the cascade.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+print.Subcascades">print.Subcascades</a></code>, <code><a href="#topic+plot.Subcascades">plot.Subcascades</a></code>, <code><a href="#topic+summary.Subcascades">summary.Subcascades</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(TunePareto)
data(esl)
data = esl$data
labels = esl$labels
foldList = generateCVRuns(labels  = labels,
                          ntimes      = 2,
                          nfold       = 2,
                          leaveOneOut = FALSE,
                          stratified  = TRUE)
predMap = predictionMap(data, labels, foldList = foldList, 
                       classifier = tunePareto.svm(),  kernel='linear')

# use default parameter settings 
# -&gt; returns cascades of all lengths that show a minimal classwise sensitivity &gt;0.
subc = subcascades(predMap)
# change the threshold 
# -&gt; returns cascades of all lengths that show a minimal classwise sensitivity &gt;=0.6.
subc = subcascades(predMap, thresh=0.6)
# search only for cascades of length 2 and 4 
# -&gt; returns cascades of length 2 and 4 that show a minimal classwise sensitivity &gt;=0.6.
subc = subcascades(predMap, thresh=0.6, size=c(2,4))
# evaluates the performance of the cascade '0&gt;1&gt;2&gt;3&gt;4'.
subc = subcascades(predMap, sets = c('0&gt;1&gt;2&gt;3&gt;4'))
</code></pre>

<hr>
<h2 id='summary.Conf'>Summary of conf</h2><span id='topic+summary.Conf'></span>

<h3>Description</h3>

<p><code>summary.Conf</code> returns a summarizing overview of a Conf object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'Conf'
summary(object = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary.Conf_+3A_object">object</code></td>
<td>
<p>A Conf object as it is returned by <code><a href="#topic+conf">conf</a></code>-function.</p>
</td></tr>
<tr><td><code id="summary.Conf_+3A_...">...</code></td>
<td>
<p>Further arguments passed from other methods.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function gives an overview of the Conf object. 
The overall number of classes, the highest and lowest sensitivities of the first class as well as the highest and lowest performance of the second class are recorded.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+conf">conf</a></code>, <code><a href="#topic+summary.PredictionMap">summary.PredictionMap</a></code>, <code><a href="#topic+summary.Subcascades">summary.Subcascades</a></code>, <code><a href="#topic+summary.Groupwise">summary.Groupwise</a></code>, <code><a href="#topic+summary.ConfusionTable">summary.ConfusionTable</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(TunePareto)
data(esl)
data = esl$data
labels = esl$labels
foldList = generateCVRuns(labels  = labels,
                          ntimes      = 2,
                          nfold       = 2,
                          leaveOneOut = FALSE,
                          stratified  = TRUE)
predMap = predictionMap(data, labels, foldList = foldList, 
                       classifier = tunePareto.svm(), kernel='linear')

conf = conf(predMap)

summary(conf)
</code></pre>

<hr>
<h2 id='summary.ConfusionTable'>Summary of confusion tables</h2><span id='topic+summary.ConfusionTable'></span>

<h3>Description</h3>

<p><code>summary.ConfusionTable</code> returns a summarizing overview.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'ConfusionTable'
summary(object = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary.ConfusionTable_+3A_object">object</code></td>
<td>
<p>A ConfusionTable object as it is returned by <code><a href="#topic+confusionTable">confusionTable</a></code>-function.</p>
</td></tr>
<tr><td><code id="summary.ConfusionTable_+3A_...">...</code></td>
<td>
<p>Further arguments passed from other methods.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function gives an overview of the characteristics of the ConfusionTable object. 
The cascade with the corresponding mean accuracy are given.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+confusionTable">confusionTable</a></code>, <code><a href="#topic+summary.PredictionMap">summary.PredictionMap</a></code>, <code><a href="#topic+summary.Subcascades">summary.Subcascades</a></code>, <code><a href="#topic+summary.Groupwise">summary.Groupwise</a></code>, <code><a href="#topic+summary.Conf">summary.Conf</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(TunePareto)
data(esl)
data = esl$data
labels = esl$labels
foldList = generateCVRuns(labels  = labels,
                          ntimes      = 2,
                          nfold       = 2,
                          leaveOneOut = FALSE,
                          stratified  = TRUE)
predMap = predictionMap(data, labels, foldList = foldList, 
                       classifier = tunePareto.svm(), kernel='linear')

# Calculation of the confusion matrix for '0&gt;2&gt;3&gt;4'.
confusionTable = confusionTable(predMap, cascade = '0&gt;2&gt;3&gt;4')

summary(confusionTable)
</code></pre>

<hr>
<h2 id='summary.Groupwise'>Overview Class Groups</h2><span id='topic+summary.Groupwise'></span>

<h3>Description</h3>

<p><code>summary.Groupwise</code> returns a summarizing overview. For each length the number of permutations consisting of the same set of classes is given.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'Groupwise'
summary(object = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary.Groupwise_+3A_object">object</code></td>
<td>
<p>A Groupwise object as it is returned by <code><a href="#topic+groupwise">groupwise</a></code>-function.</p>
</td></tr>
<tr><td><code id="summary.Groupwise_+3A_...">...</code></td>
<td>
<p>Further arguments passed from other methods.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function gives an overview of the characteristics of the Groupwise object. 
The number of permutations per size is given. A permutation means that the corresponding cascades contain the same classes but with different order.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+groupwise">groupwise</a></code>, <code><a href="#topic+summary.PredictionMap">summary.PredictionMap</a></code>, <code><a href="#topic+summary.Subcascades">summary.Subcascades</a></code>, <code><a href="#topic+summary.Conf">summary.Conf</a></code>, <code><a href="#topic+summary.ConfusionTable">summary.ConfusionTable</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(TunePareto)
data(esl)
data = esl$data
labels = esl$labels
foldList = generateCVRuns(labels  = labels,
                          ntimes      = 2,
                          nfold       = 2,
                          leaveOneOut = FALSE,
                          stratified  = TRUE)
predMap = predictionMap(data, labels, foldList = foldList, 
                       classifier = tunePareto.svm(), kernel='linear')
# generate Subcascades object
subc = subcascades(predMap,thresh=0.7)
groupwise = groupwise(subc,maxCl=50)

summary(groupwise)
</code></pre>

<hr>
<h2 id='summary.PredictionMap'>Summary of prediction maps</h2><span id='topic+summary.PredictionMap'></span>

<h3>Description</h3>

<p><code>summary.PredictionMap</code> returns a summarizing overview of a PredictionMap object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'PredictionMap'
summary(object = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary.PredictionMap_+3A_object">object</code></td>
<td>
<p>A PredictionMap object as it is returned by <code><a href="#topic+predictionMap">predictionMap</a></code>-function.</p>
</td></tr>
<tr><td><code id="summary.PredictionMap_+3A_...">...</code></td>
<td>
<p>Further arguments passed from other methods.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function gives an overview of the PredictionMap object. 
A short summary about the utilized data and labels is given as well as the number of runs and folds of the cross-validation.
The summary also includes if the prediction map was generated in parallel and the name of the utilized TunePareto classifier as well as its specified parameters.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+predictionMap">predictionMap</a></code>, <code><a href="#topic+summary.Subcascades">summary.Subcascades</a></code>, <code><a href="#topic+summary.Groupwise">summary.Groupwise</a></code>, <code><a href="#topic+summary.Conf">summary.Conf</a></code>, <code><a href="#topic+summary.ConfusionTable">summary.ConfusionTable</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(TunePareto)
data(esl)
data = esl$data
labels = esl$labels
foldList = generateCVRuns(labels  = labels,
                          ntimes      = 2,
                          nfold       = 2,
                          leaveOneOut = FALSE,
                          stratified  = TRUE)
predMap = predictionMap(data, labels, foldList = foldList, 
                       classifier = tunePareto.svm(), kernel='linear')

summary(predMap)
</code></pre>

<hr>
<h2 id='summary.Subcascades'>Summary Subcascades Characteristics</h2><span id='topic+summary.Subcascades'></span>

<h3>Description</h3>

<p>Generates a general overview of the characteristics of the Subcascades object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'Subcascades'
summary(object = NULL, includeClassSummary = TRUE, digits = 3, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary.Subcascades_+3A_object">object</code></td>
<td>
<p>A Subcascades object as it is returned by <code><a href="#topic+subcascades">subcascades</a></code>-function.</p>
</td></tr>
<tr><td><code id="summary.Subcascades_+3A_includeclasssummary">includeClassSummary</code></td>
<td>
<p>Boolean indicating if the occurrence of classes by size should be included in the summary.</p>
</td></tr>
<tr><td><code id="summary.Subcascades_+3A_digits">digits</code></td>
<td>
<p>Integer defining the number of decimal places as it is used in the <code>round</code>-function.</p>
</td></tr>
<tr><td><code id="summary.Subcascades_+3A_...">...</code></td>
<td>
<p>Further arguments passed from other methods.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function gives a general overview of characteristics of the Subcascades object, like number of cascades or maximal cascade length.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+subcascades">subcascades</a></code>, <code><a href="#topic+summary.PredictionMap">summary.PredictionMap</a></code>, <code><a href="#topic+summary.Groupwise">summary.Groupwise</a></code>, <code><a href="#topic+summary.Conf">summary.Conf</a></code>, <code><a href="#topic+summary.ConfusionTable">summary.ConfusionTable</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(TunePareto)
data(esl)
data &lt;- esl$data
labels &lt;- esl$labels
foldList &lt;- generateCVRuns(labels  = labels,
                          ntimes      = 2,
                          nfold       = 2,
                          leaveOneOut = FALSE,
                          stratified  = TRUE)
predMap &lt;- predictionMap(data, labels, foldList = foldList, 
                        classifier = tunePareto.svm(), kernel='linear')
# generate Subcascades object
subc &lt;- subcascades(predMap,thresh=0.7,numSol=10000)

summary(subc)
</code></pre>

<hr>
<h2 id='summaryClasses'>Occurrence of Classes by Size</h2><span id='topic+summaryClasses'></span>

<h3>Description</h3>

<p><code>summaryClasses</code> returns the occurrence of classes by size
</p>


<h3>Usage</h3>

<pre><code class='language-R'>summaryClasses(subcascades = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summaryClasses_+3A_subcascades">subcascades</code></td>
<td>
<p>A Subcascades object as it is returned by <code><a href="#topic+subcascades">subcascades</a></code>-function.
The Subcascades object is made up of a list of matrices. 
Each matrix comprises the evaluation results of cascades of a specific length and 
is sorted row-wise according to the achieved minimal classwise sensitivities of the cascades (decreasing).
The rownames show the class order by a character string of type '1&gt;2&gt;3' and the entries the sensitivity for each position of the cascade.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function gives an overview of the classes of the Subcascades object. For each length in 
the Subcascades object the occurence of classes is given.
</p>


<h3>Value</h3>

<p>A matrix summarizing the overview characteristics of the Subcascades object.
</p>

<hr>
<h2 id='summarySubcascades'>Overview Subcascades</h2><span id='topic+summarySubcascades'></span>

<h3>Description</h3>

<p><code>summarySubcascades</code> returns a summarizing overview. For each length the number of cascades and the minimal class-wise sensitivity is given.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>summarySubcascades(subcascades = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summarySubcascades_+3A_subcascades">subcascades</code></td>
<td>
<p>A Subcascades object as it is returned by <code><a href="#topic+subcascades">subcascades</a></code>-function.
The Subcascades object is made up of a list of matrices. 
Each matrix comprises the evaluation results of cascades of a specific length and 
is sorted row-wise according to the achieved minimal classwise sensitivities of the cascades (decreasing).
The rownames show the class order by a character string of type '1&gt;2&gt;3' and the entries the sensitivity for each position of the cascade.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function gives an overview of the Subcascades object. For each length in 
the Subcascades object the number of cascades of that length, as well as their 
minimal classwise sensitivity is given.
</p>


<h3>Value</h3>

<p>A matrix summarizing the overview characteristics of the Subcascades object. 
For each size (rows) the number of cascades within the Subcascades object (number) and the minimal classwise sensitivity (min.class.sens) are given.
</p>

<hr>
<h2 id='tunePareto.occ'>Ordinal Classifier Cascade Tune Pareto Object</h2><span id='topic+tunePareto.occ'></span>

<h3>Description</h3>

<p>TunePareto wrapper for the ordinal classifier cascade.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tunePareto.occ(base.classifier)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tunePareto.occ_+3A_base.classifier">base.classifier</code></td>
<td>
<p>A predefined TuneParetoClassifier object used as binary classifier 
for the ordinal classifier cascade. There exist five classifier types that 
can be used: tunePareto.knn(), tunePareto.svm(), tunePareto.tree(), tunePareto.randomForest(),
tunePareto.NaiveBayes(). For more information about these classifier functions please refer to 
the corresponding help page of like <code>TunePareto::tunePareto.knn</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The &quot;tunePareto.occ&quot; encapsulates the classifier of an ordinal classifier cascade.
Additionally, to the parameters of the corresponding base classifier the &quot;class.order&quot;
parameter can be provided. It is either a character vector, a numeric vector, 
or a vector representing a cascade of the following format '1&gt;2&gt;4'.
</p>


<h3>Value</h3>

<p>Returns an object of class TuneParetoClassifier (see: <code>TunePareto::tuneParetoClassifier</code>). 
This can be passed to the function trainTuneParetoClassifier (see: <code>TunePareto::trainTuneParetoClassifier</code>).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(TunePareto)
data(esl)
data = esl$data
labels = esl$labels
# train classifier
model &lt;- trainTuneParetoClassifier( 
         classifier  = tunePareto.occ( base.classifier = tunePareto.svm()),
         trainData   = data,
         trainLabels = labels,
         class.order = as.character(c(4,3,1,0)),
         kernel      = "linear",
         cost        = 1)
         
# predict labels
prediction &lt;- predict(object = model, newdata = data)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
