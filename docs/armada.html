<!DOCTYPE html><html><head><title>Help for package armada</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {armada}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#ARMADA'><p>Scores of all the covariates present in X, given the vector Y of the response.</p></a></li>
<li><a href='#ARMADA.heatmap'><p>Heatmap of the selected covariates.</p></a></li>
<li><a href='#ARMADA.select'><p>Covariates selection via 8 selection methods</p></a></li>
<li><a href='#ARMADA.summary'><p>Scores of the covariates X</p></a></li>
<li><a href='#clustering'><p>To obtain the dendrogram of the covariates contained in the data.frame X, and a proposition for the number of clusters of covariates in X.</p></a></li>
<li><a href='#covariables'><p>concatenation of the rownames of X and of the response vector Y.</p></a></li>
<li><a href='#toys.data'><p>Toys data</p></a></li>
<li><a href='#toys.data.multi'><p>Toys data in multinomial case</p></a></li>
<li><a href='#toys.data.reg'><p>Toys data in regression case</p></a></li>
<li><a href='#X_decor'><p>Decorrelation of a matrix X, given a response variable Y.</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>A Statistical Methodology to Select Covariates in
High-Dimensional Data under Dependence</td>
</tr>
<tr>
<td>Version:</td>
<td>0.1.0</td>
</tr>
<tr>
<td>Description:</td>
<td>Two steps variable selection procedure in a context of high-dimensional dependent data
  but few observations. First step is dedicated to eliminate dependence between variables (clustering
  of variables, followed by factor analysis inside each cluster).
  Second step is a variable selection using by aggregation of adapted methods.
  Bastien B., Chakir H., Gegout-Petit A., Muller-Gueudin A., Shi Y.
  A statistical methodology to select covariates in high-dimensional data under dependence.
  Application to the classification of genetic profiles associated with outcome of a non-small-cell
  lung cancer treatment. 2018. <a href="https://hal.archives-ouvertes.fr/hal-01939694">https://hal.archives-ouvertes.fr/hal-01939694</a>.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>6.1.1</td>
</tr>
<tr>
<td>Imports:</td>
<td>stats, mvtnorm, ClustOfVar, FAMT, graphics, VSURF, glmnet,
anapuce, qvalue, parallel, doParallel, impute, ComplexHeatmap,
circlize</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2019-04-04 13:14:39 UTC; muller16</td>
</tr>
<tr>
<td>Author:</td>
<td>Aurelie Gueudin [aut, cre],
  Anne Gegout-Petit [aut]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Aurelie Gueudin &lt;aurelie.gueudin@univ-lorraine.fr&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2019-04-04 16:00:06 UTC</td>
</tr>
</table>
<hr>
<h2 id='ARMADA'>Scores of all the covariates present in X, given the vector Y of the response.</h2><span id='topic+ARMADA'></span>

<h3>Description</h3>

<p>Scores of all the covariates present in X, given the vector Y of the response.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ARMADA(X, Y, nclust = NULL, clusterType = c("PSOCK", "FORK"),
  parallel = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ARMADA_+3A_x">X</code></td>
<td>
<p>the matrix (or data.frame) of covariates, dimension n*p (n is the sample size, p the number of covariates). X must have rownames, which are the names of the n subjects (i.e. the user ID of the n subjects). X must have colnames, which are the names of the p covariates.</p>
</td></tr>
<tr><td><code id="ARMADA_+3A_y">Y</code></td>
<td>
<p>the vector of the response, length n.</p>
</td></tr>
<tr><td><code id="ARMADA_+3A_nclust">nclust</code></td>
<td>
<p>the number of clusters in the covariates dataset X.</p>
</td></tr>
<tr><td><code id="ARMADA_+3A_clustertype">clusterType</code></td>
<td>
<p>to precise the type of cluster of the machine. Possible choices: &quot;PSOCK&quot;, or &quot;FORK&quot; (for UNIX or MAC systems, but not for WINDOWS).</p>
</td></tr>
<tr><td><code id="ARMADA_+3A_parallel">parallel</code></td>
<td>
<p>=  TRUE if the calculus are made in parallel (default choice is FALSE).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a 3-list with: &quot;tree&quot; which is the dendrogram of the data X, &quot;nclust&quot; which is a proposition of the number of clusters in the data X, &quot;result&quot; which is a data.frame with p rows and 2 columns, the first column gives the names of the covariates, the second column is the scores of the covariates.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(ClustOfVar)
library(impute)
library(FAMT)
library(VSURF)
library(glmnet)
library(anapuce)
library(qvalue)

set.seed(1)
p &lt;- 40
n &lt;- 30
indexRow &lt;- paste0("patient",1:n)
indexCol &lt;- paste0("G",1:p)
X &lt;- matrix(rnorm(p*n),ncol=p)
colnames(X) &lt;- indexCol
rownames(X) &lt;- indexRow
Y &lt;- c(rep(-1,n/2), rep(1,n/2))
X[,1:4] &lt;-  X[,1:4] + matrix(rnorm(n*4, mean=2*Y, sd=1), ncol=4)
Y&lt;-as.factor(Y)
resultat &lt;- ARMADA(X,Y, nclust=1)
## Not run: 
X&lt;-toys.data$x
Y&lt;-toys.data$Y
result&lt;-ARMADA(X,Y, nclust=2)

## End(Not run)
</code></pre>

<hr>
<h2 id='ARMADA.heatmap'>Heatmap of the selected covariates.</h2><span id='topic+ARMADA.heatmap'></span>

<h3>Description</h3>

<p>Heatmap of the selected covariates.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ARMADA.heatmap(X, Y, res.ARMADA.summary, threshold = 5)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ARMADA.heatmap_+3A_x">X</code></td>
<td>
<p>the matrix (or data.frame) of covariates, dimension n*p (n is the sample size, p the number of covariates). X must have rownames, which are the names of the n subjects (i.e. the user ID of the n subjects). X must have colnames, which are the names of the p covariates.</p>
</td></tr>
<tr><td><code id="ARMADA.heatmap_+3A_y">Y</code></td>
<td>
<p>the vector of the response, length n.</p>
</td></tr>
<tr><td><code id="ARMADA.heatmap_+3A_res.armada.summary">res.ARMADA.summary</code></td>
<td>
<p>the result of the function ARMADA, or output of the function ARMADA.summary.</p>
</td></tr>
<tr><td><code id="ARMADA.heatmap_+3A_threshold">threshold</code></td>
<td>
<p>an integer between 0 and 8: the selected covariates are those which have a score greater or equal to &quot;threshold.&quot;</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function plots the heatmap of the covariates which have a score higher than some threshold chosen by the user, with respect to the values of Y.
</p>


<h3>Value</h3>

<p>the plot of the heatmap, and a data.frame of the selected covariables.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(ClustOfVar)
library(impute)
library(FAMT)
library(VSURF)
library(glmnet)
library(anapuce)
library(qvalue)
library(ComplexHeatmap)
library(circlize)
set.seed(1)
p &lt;- 40
n &lt;- 30
indexRow &lt;- paste0("patient",1:n)
indexCol &lt;- paste0("G",1:p)
X &lt;- matrix(rnorm(p*n),ncol=p)
colnames(X) &lt;- indexCol
rownames(X) &lt;- indexRow
Y &lt;- c(rep(-1,n/2), rep(1,n/2))
X[,1:4] &lt;-  X[,1:4] + matrix(rnorm(n*4, mean=2*Y, sd=1), ncol=4)
Y&lt;-as.factor(Y)
resultat &lt;- ARMADA(X,Y, nclust=1)
tracer &lt;- ARMADA.heatmap(X, Y, resultat[[3]], threshold=5)
## Not run: 
X&lt;-toys.data$x
Y&lt;-toys.data$Y
result&lt;-ARMADA(X,Y, nclust=2)
select&lt;-ARMADA.heatmap(X, Y,  result[[3]], threshold=5)

## End(Not run)
</code></pre>

<hr>
<h2 id='ARMADA.select'>Covariates selection via 8 selection methods</h2><span id='topic+ARMADA.select'></span>

<h3>Description</h3>

<p>Covariates selection via 8 selection methods
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ARMADA.select(X, X.decorrele, Y, test, type.cor.test = NULL,
  type.measure_glmnet = c("deviance", "class"),
  family_glmnet = c("gaussian", "binomial", "multinomial"),
  clusterType = c("PSOCK", "FORK"), parallel = c(FALSE, TRUE))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ARMADA.select_+3A_x">X</code></td>
<td>
<p>the matrix (or data.frame) of covariates, dimension n*p (n is the sample size, p the number of covariates). X must have rownames and colnames.</p>
</td></tr>
<tr><td><code id="ARMADA.select_+3A_x.decorrele">X.decorrele</code></td>
<td>
<p>the matrix of decorrelated covariates, dimension n*p (n is the sample size, p the number of covariates). X.decorrele has been obtained by the function X_decor.</p>
</td></tr>
<tr><td><code id="ARMADA.select_+3A_y">Y</code></td>
<td>
<p>the vector of the response, length n.</p>
</td></tr>
<tr><td><code id="ARMADA.select_+3A_test">test</code></td>
<td>
<p>the type of test to apply (&quot;wilox.test&quot; or &quot;t.test&quot; if Y is a binary variable; &quot;kruskal.test&quot; or &quot;anova&quot; if Y is a factor with more than 2 levels; &quot;cor.test&quot; if Y is a continuous variable).</p>
</td></tr>
<tr><td><code id="ARMADA.select_+3A_type.cor.test">type.cor.test</code></td>
<td>
<p>if test=&quot;cor.test&quot;, precise the type of test (possible choices: &quot;pearson&quot;,&quot;kendall&quot;, &quot;spearman&quot;). Default value is NULL, which corresponds to &quot;pearson&quot;.</p>
</td></tr>
<tr><td><code id="ARMADA.select_+3A_type.measure_glmnet">type.measure_glmnet</code></td>
<td>
<p>argument for the lasso regression. The lasso regression is done with the function cv.glmnet (package glmnet), and you can precise the type of data in cv.glmnet. Possible choices for type.measure_glmnet: &quot;deviance&quot; (for gaussian models, logistic, regression and Cox), &quot;class&quot; (for binomial or multinomial regression).</p>
</td></tr>
<tr><td><code id="ARMADA.select_+3A_family_glmnet">family_glmnet</code></td>
<td>
<p>argument for the lasso regression. The lasso regression is done with the function glmnet. Possible choices for family_glmnet: &quot;gaussian&quot; (if Y is quantitative), &quot;binomial&quot; (if Y is a factor with two levels), &quot;multinomial&quot; (if Y is a factor with more than two levels).</p>
</td></tr>
<tr><td><code id="ARMADA.select_+3A_clustertype">clusterType</code></td>
<td>
<p>to precise the type of cluster of the machine. Possible choices: &quot;PSOCK&quot; or &quot;FORK&quot; (for UNIX or MAC systems, but not for WINDOWS).</p>
</td></tr>
<tr><td><code id="ARMADA.select_+3A_parallel">parallel</code></td>
<td>
<p>TRUE if the calculus are made in parallel.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function ARMADA.select applies 8 selection methods on the decorrelated covariates (named X.decorrele), given the variable of interest Y. It resturns a list of 8 vectors of the selected covariates, each vector correspond to one selection method. The methods are (in the order): Random forest (threshold step), Random forest (interpretation step), Lasso, multiple testing with Bonferroni, multiple testing with Benjamini-Hochberg, multiple testing with qvalues, multiple testing with localfdr, FAMT.
</p>


<h3>Value</h3>

<p>a list  with 8 vectors, called: genes_rf_thres, genes_rf_interp, genes_lasso, genes_bonferroni, genes_BH, genes_qvalues, genes_localfdr, genes_FAMT. The 8 vectors are the selected covariates by the corresponding selection methods.
</p>

<hr>
<h2 id='ARMADA.summary'>Scores of the covariates X</h2><span id='topic+ARMADA.summary'></span>

<h3>Description</h3>

<p>Scores of the covariates X
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ARMADA.summary(X, resultat.ARMADA.select)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ARMADA.summary_+3A_x">X</code></td>
<td>
<p>the matrix (or data.frame) of covariates, dimension n*p (n is the sample size, p the number of covariates). X must have colnames.</p>
</td></tr>
<tr><td><code id="ARMADA.summary_+3A_resultat.armada.select">resultat.ARMADA.select</code></td>
<td>
<p>the output of the ARMADA.select function: a list  with 8 vectors, called: genes_rf_thres, genes_rf_interp, genes_lasso, genes_bonferroni, genes_BH, genes_qvalues, genes_localfdr, genes_FAMT. The 8 vectors are the selected covariates by the corresponding selection methods.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function ARMADA.summary gives the scores of all the covariates. The score of a variable is an integer between 0 and 8, and represents the number of selections of this variable by the 8 selection methods.
</p>


<h3>Value</h3>

<p>gene_list: data.frame with p rows and 2 columns, the first column gives the names of the covariates, the second column is the scores of the covariates.
</p>

<hr>
<h2 id='clustering'>To obtain the dendrogram of the covariates contained in the data.frame X, and a proposition for the number of clusters of covariates in X.</h2><span id='topic+clustering'></span>

<h3>Description</h3>

<p>To obtain the dendrogram of the covariates contained in the data.frame X, and a proposition for the number of clusters of covariates in X.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>clustering(X, plot = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="clustering_+3A_x">X</code></td>
<td>
<p>the matrix (or data.frame) of covariates, dimension n*p (n is the sample size, p the number of covariates).</p>
</td></tr>
<tr><td><code id="clustering_+3A_plot">plot</code></td>
<td>
<p>if plot = TRUE&quot; (default value): it gives the dendrogram and the plot of the height versus the number of clusters, for the 30 first clusters.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a 2-list composed by: &quot;tree&quot; (the dendrogram of X), and &quot;nclust&quot; which is a proposition of the number of clusters. The proposed number of clusters is calculated as following: in the graph of the decreasing height versus the number of clusters, we define variation_height = (height[1:29]-height[2:30])/height[2:30], and our proposition is nclust=min(which(variation_height&lt;0.05)). It is preferable that the user chooses its own number of clusters. Warning: nclust must be not too high. Indeed, if nclust is too high, the clusters contain a small number of covariates, and it is then possible that all the covariates of one or several cluster(s) are included in H0. In that case, the FAMT procedure will have a dysfunction.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>toys.data
X&lt;-toys.data$x
clustering(X)

</code></pre>

<hr>
<h2 id='covariables'>concatenation of the rownames of X and of the response vector Y.</h2><span id='topic+covariables'></span>

<h3>Description</h3>

<p>concatenation of the rownames of X and of the response vector Y.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>covariables(X, Y)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="covariables_+3A_x">X</code></td>
<td>
<p>the matrix (or data.frame) of covariates, dimension n*p (n is the sample size, p the number of covariates). X must have rownames, which are the names of the n subjects (i.e. the user ID of the n subjects).</p>
</td></tr>
<tr><td><code id="covariables_+3A_y">Y</code></td>
<td>
<p>the vector of the response, length n.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>internal function. Concatenation of the rownames of X (X is the matrix n*p of the covariates), and of the response vector Y. X must have rownames, which are the names of the n subjects (i.e. the user ID of the n subjects).
</p>


<h3>Value</h3>

<p>a data.frame with dimension n*2: the first column gives the names of the subjects, and the second column is Y.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>X&lt;-matrix(rnorm(50),nrow=10)
rownames(X)&lt;-letters[1:10]
covariables(X, 1:10)
</code></pre>

<hr>
<h2 id='toys.data'>Toys data</h2><span id='topic+toys.data'></span>

<h3>Description</h3>

<p>toys.data is a simple simulated dataset of a binary classification problem, introduced by Weston et.al..
</p>


<h3>Usage</h3>

<pre><code class='language-R'>toys.data
</code></pre>


<h3>Format</h3>

<p>An object of class <code>list</code> of length 2.</p>


<h3>Details</h3>


<ul>
<li><p> $Y: output variable: a factor with 2 levels &quot;-1&quot; and &quot;1&quot;;
</p>
</li>
<li><p> $x  A data-frame containing input variables: with 30 obs. of 50 variables.
</p>
</li></ul>

<p>The data-frame x is composed by 2 independant clusters, each cluster contains 25 correlated variables. It is an equiprobable two class problem, Y belongs to -1,1, with 12 true variables (6 true variables in each cluster), the others being noise. The simulation model is defined through the conditional distribution of the X^j for Y=y. In the first cluster, the X^j are simulated in the following way:
</p>

<ul>
<li><p> with probability 0.7, X^j ~N(y,2) for j=1,2,3, and X^j ~ N(0,2) for j=4,5,6 ;
</p>
</li>
<li><p>  with probability 0.3, X^j ~ N(0,2) for j=1,2,3, and X^j ~ N(y(j-3),2) for j=4,5,6 ;
</p>
</li>
<li><p> the other variables are noise, X^j ~ N(0,1) for j=7,. . . ,25.
</p>
</li></ul>

<p>The second cluster of 25 variables is simulated in a similar way.
</p>


<h3>Source</h3>

<p>Weston, J., Elisseff, A., Schoelkopf, B., Tipping, M. (2003), Use of the zero norm with linear models and Kernel methods, J. Machine Learn. Res. 3, 1439-14611
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(ClustOfVar)
library(impute)
library(FAMT)
library(VSURF)
library(glmnet)
library(anapuce)
library(qvalue)
X&lt;-toys.data$x
Y&lt;-toys.data$Y
scoreX&lt;-data.frame(c(rep(8,6),rep(0,19),rep(8,6),rep(0,19)))
rownames(scoreX)&lt;-colnames(X)
select&lt;-ARMADA.heatmap(X, Y,  scoreX, threshold=1)
 ## Not run: 
result&lt;-ARMADA(X,Y, nclust=2)
select&lt;-ARMADA.heatmap(X, Y,  result[[3]], threshold=5)

## End(Not run)
</code></pre>

<hr>
<h2 id='toys.data.multi'>Toys data in multinomial case</h2><span id='topic+toys.data.multi'></span>

<h3>Description</h3>

<p>toys.data.multi is a simple simulated dataset of a multinomial classification problem.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>toys.data.multi
</code></pre>


<h3>Format</h3>

<p>An object of class <code>list</code> of length 2.</p>


<h3>Details</h3>


<ul>
<li><p> $Y: output variable: a factor with 3 levels &quot;-1&quot;, &quot;0&quot;, and &quot;2&quot;;
</p>
</li>
<li><p> $x  A data-frame containing input variables: with 60 obs. of 50 variables.
</p>
</li></ul>

<p>The data-frame x is composed by 2 independant clusters, each cluster contains 25 correlated variables. It is an equiprobable three class problem, Y belongs to -1,0,1. There is only 6 true variables, that are in the first cluster, the others being noise. The simulation model is defined through the conditional distribution of the X^j for Y=y. In the first cluster, the X^j are simulated in the following way:
</p>

<ul>
<li><p> X^j ~ N(2*y,2) for j=1,2,3,4,5,6;
</p>
</li>
<li><p> the other variables are noise, X^j ~ N(0,1) for j=7,. . . ,25.
</p>
</li></ul>

<p>The second cluster of 25 variables contains only noise variables.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(ClustOfVar)
library(impute)
library(FAMT)
library(VSURF)
library(glmnet)
library(anapuce)
library(qvalue)
X&lt;-toys.data.multi$x
Y&lt;-toys.data.multi$Y
scoreX&lt;-data.frame(c(rep(8,6),rep(0,44)))
rownames(scoreX)&lt;-colnames(X)
select&lt;-ARMADA.heatmap(X, Y,  scoreX, threshold=1)
## Not run: 
result&lt;-ARMADA(X,Y, nclust=2)
select&lt;-ARMADA.heatmap(X, Y,  result[[3]], threshold=5)

## End(Not run)
</code></pre>

<hr>
<h2 id='toys.data.reg'>Toys data in regression case</h2><span id='topic+toys.data.reg'></span>

<h3>Description</h3>

<p>toys.data.reg is a simple simulated dataset of a regression problem.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>toys.data.reg
</code></pre>


<h3>Format</h3>

<p>An object of class <code>list</code> of length 2.</p>


<h3>Details</h3>


<ul>
<li><p> $Y: output variable;
</p>
</li>
<li><p> $x  A data-frame containing input variables: with 30 obs. of 50 variables.
</p>
</li></ul>

<p>The data-frame x is composed by 2 independant clusters, each cluster contains 25 correlated variables. There is only 5 true variables, that are in the first cluster : Y =50*(x[,1]+x[,2]+x[,3]+x[,4]+x[,5]). The other variables are noise.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(ClustOfVar)
library(impute)
library(FAMT)
library(VSURF)
library(glmnet)
library(anapuce)
library(qvalue)
X&lt;-toys.data.reg$x
Y&lt;-toys.data.reg$Y
scoreX&lt;-data.frame(c(rep(8,5),rep(0,45)))
rownames(scoreX)&lt;-colnames(X)
select&lt;-ARMADA.heatmap(X, Y,  scoreX, threshold=1)
## Not run: 
result&lt;-ARMADA(X,Y, nclust=2)
select&lt;-ARMADA.heatmap(X, Y,  result[[3]], threshold=5)

## End(Not run)
</code></pre>

<hr>
<h2 id='X_decor'>Decorrelation of a matrix X, given a response variable Y.</h2><span id='topic+X_decor'></span>

<h3>Description</h3>

<p>Decorrelation of a matrix X, given a response variable Y.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>X_decor(X, Y, tree = NULL, nclust = 1, maxnbfactors = 10)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="X_decor_+3A_x">X</code></td>
<td>
<p>the matrix (or data.frame) of covariates, dimension n*p (n is the sample size, p the number of covariates). X must have colnames and rownames.</p>
</td></tr>
<tr><td><code id="X_decor_+3A_y">Y</code></td>
<td>
<p>the vector of the response, length n.</p>
</td></tr>
<tr><td><code id="X_decor_+3A_tree">tree</code></td>
<td>
<p>the dendrogram of the covariates (object obtained before by the function clustering). By default, tree=NULL.</p>
</td></tr>
<tr><td><code id="X_decor_+3A_nclust">nclust</code></td>
<td>
<p>integer, the number of clusters in the covariates (1  by default).</p>
</td></tr>
<tr><td><code id="X_decor_+3A_maxnbfactors">maxnbfactors</code></td>
<td>
<p>integer, the maximum number of factors in the clusters. By default: maxnbfactors=10.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function X_decor applies the factor analysis method FAMT in the different clusters of variables. The clusters must have been defined before (with the function &quot;clustering&quot;).
</p>


<h3>Value</h3>

<p>a matrix X.decorrele, with the same dimension, same rownames and same colnames than X.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>toys.data
X&lt;-toys.data$x
Y&lt;-toys.data$Y
Tree &lt;- clustering(X,plot=FALSE)
nclust &lt;- Tree[[2]]
tree &lt;- Tree[[1]]
library(ClustOfVar)
library(FAMT)
X.deco&lt;- X_decor(X, Y, tree, nclust, maxnbfactors=10)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
