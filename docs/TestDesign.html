<!DOCTYPE html><html><head><title>Help for package TestDesign</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {TestDesign}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#a_to_alpha'><p>Calculate alpha angles from a-parameters</p></a></li>
<li><a href='#app'><p>Open TestDesign app</p></a></li>
<li><a href='#buildConstraints'><p>Build constraints (shortcut to other loading functions)</p></a></li>
<li><a href='#calc_info'><p>(C++) For multiple items, calculate Fisher information</p></a></li>
<li><a href='#calc_info_EB'><p>Calculate the Fisher information using empirical Bayes</p></a></li>
<li><a href='#calc_info_FB'><p>Calculate the Fisher information using full Bayesian</p></a></li>
<li><a href='#calc_likelihood'><p>(C++) For multiple items, calculate likelihoods</p></a></li>
<li><a href='#calc_MI_FB'><p>Calculate the mutual information using full Bayesian</p></a></li>
<li><a href='#calc_posterior'><p>Calculate a posterior value of theta</p></a></li>
<li><a href='#calc_posterior_function'><p>Calculate a posterior distribution of theta</p></a></li>
<li><a href='#calc_posterior_single'><p>Calculate a posterior value of theta for a single item</p></a></li>
<li><a href='#calcEscore'><p>Calculate expected scores</p></a></li>
<li><a href='#calcFisher'><p>Calculate Fisher information</p></a></li>
<li><a href='#calcHessian'><p>Calculate second derivative of log-likelihood</p></a></li>
<li><a href='#calcJacobian'><p>Calculate first derivative of log-likelihood</p></a></li>
<li><a href='#calcLocation-methods'><p>Calculate central location (overall difficulty)</p></a></li>
<li><a href='#calcLogLikelihood'><p>Calculate log-likelihood</p></a></li>
<li><a href='#calcProb-methods'><p>Calculate item response probabilities</p></a></li>
<li><a href='#checkConstraints'><p>Check the consistency of constraints and item usage</p></a></li>
<li><a href='#config_Shadow-class'><p>Create a config_Shadow object</p></a></li>
<li><a href='#config_Static-class'><p>Create a config_Static object</p></a></li>
<li><a href='#constraint-class'><p>Class 'constraint': a single constraint</p></a></li>
<li><a href='#constraints-class'><p>Class 'constraints': a set of constraints</p></a></li>
<li><a href='#constraints-operators'><p>Basic operators for constraints objects</p></a></li>
<li><a href='#dataset_bayes'><p>Bayes dataset</p></a></li>
<li><a href='#dataset_fatigue'><p>Fatigue dataset</p></a></li>
<li><a href='#dataset_reading'><p>Reading dataset</p></a></li>
<li><a href='#dataset_science'><p>Science dataset</p></a></li>
<li><a href='#detectBestSolver'><p>Detect best solver</p></a></li>
<li><a href='#e_item'><p>(C++) Calculate expected scores</p></a></li>
<li><a href='#eap'><p>Compute expected a posteriori estimates of theta</p></a></li>
<li><a href='#find_segment'><p>(C++) Classify theta values into segments using cutpoints</p></a></li>
<li><a href='#getSolution'><p>Print solution items</p></a></li>
<li><a href='#getSolutionAttributes'><p>Retrieve constraints-related attributes from solution</p></a></li>
<li><a href='#h_item'><p>(C++) Calculate second derivative of log-likelihood</p></a></li>
<li><a href='#info_item'><p>(C++) Calculate Fisher information</p></a></li>
<li><a href='#iparPosteriorSample'><p>Generate item parameter samples using standard errors</p></a></li>
<li><a href='#item_attrib-class'><p>Load item attributes</p></a></li>
<li><a href='#item_attrib-operators'><p>Basic functions for item attribute objects</p></a></li>
<li><a href='#item_pool_cluster-class'><p>Class 'item_pool_cluster': an item pool</p></a></li>
<li><a href='#item_pool-class'><p>Class 'item_pool': an item pool</p></a></li>
<li><a href='#item_pool-operators'><p>Basic operators for item pool objects</p></a></li>
<li><a href='#item-classes'><p>Item classes</p></a></li>
<li><a href='#j_item'><p>(C++) Calculate first derivative of log-likelihood</p></a></li>
<li><a href='#lnHyperPars'><p>Convert mean and standard deviation into log-normal distribution parameters</p></a></li>
<li><a href='#loadConstraints'><p>Load constraints</p></a></li>
<li><a href='#loadItemPool'><p>Load item pool</p></a></li>
<li><a href='#logitHyperPars'><p>Convert mean and standard deviation into logit-normal distribution parameters</p></a></li>
<li><a href='#makeItemPoolCluster'><p>Create an item pool cluster object</p></a></li>
<li><a href='#makeSimulationDataCache'><p>Create a simulation data cache object</p></a></li>
<li><a href='#makeTest'><p>Create a test object</p></a></li>
<li><a href='#makeTestCluster'><p>Create a test cluster object</p></a></li>
<li><a href='#mle'><p>Compute maximum likelihood estimates of theta</p></a></li>
<li><a href='#mlef'><p>Compute maximum likelihood estimates of theta using fence items</p></a></li>
<li><a href='#output_Shadow_all-class'><p>Class 'output_Shadow_all': a set of adaptive assembly solutions</p></a></li>
<li><a href='#output_Shadow-class'><p>Class 'output_Shadow': adaptive assembly solution for one simulee</p></a></li>
<li><a href='#output_Split-class'><p>Class 'output_Split': partitioning solution</p></a></li>
<li><a href='#output_Static-class'><p>Class 'output_Static': fixed-form assembly solution</p></a></li>
<li><a href='#p_item'><p>(C++) Calculate item response probability</p></a></li>
<li><a href='#plot'><p>Extension of plot() for objects in TestDesign package</p></a></li>
<li><a href='#print'><p>Extension of print() for objects in TestDesign package</p></a></li>
<li><a href='#RE'><p>Calculate Relative Errors</p></a></li>
<li><a href='#RMSE'><p>Calculate Root Mean Squared Error</p></a></li>
<li><a href='#runAssembly'><p>Run Test Assembly</p></a></li>
<li><a href='#Shadow'><p>Run adaptive test assembly</p></a></li>
<li><a href='#show'><p>Extension of show() for objects in TestDesign package</p></a></li>
<li><a href='#simResp'><p>Simulate item response data</p></a></li>
<li><a href='#simulation_data_cache-class'><p>Class 'simulation_data_cache': data cache for Shadow()</p></a></li>
<li><a href='#Split'><p>Split an item pool into partitions</p></a></li>
<li><a href='#st_attrib-class'><p>Load set/stimulus/passage attributes</p></a></li>
<li><a href='#st_attrib-operators'><p>Basic functions for stimulus attribute objects</p></a></li>
<li><a href='#Static'><p>Run fixed-form test assembly</p></a></li>
<li><a href='#summary'><p>Extension of summary() for objects in TestDesign package</p></a></li>
<li><a href='#summary-classes'><p>Summary classes</p></a></li>
<li><a href='#test_cluster-class'><p>Class 'test_cluster': data cache for simulations</p></a></li>
<li><a href='#test_operators'><p>Basic operators for test objects</p></a></li>
<li><a href='#test-class'><p>Class 'test': data cache for simulations</p></a></li>
<li><a href='#TestDesign'><p>Open TestDesign app</p></a></li>
<li><a href='#testSolver'><p>Test solver</p></a></li>
<li><a href='#theta_EAP'><p>(C++) Calculate a theta estimate using EAP (expected a posteriori) method</p></a></li>
<li><a href='#theta_EB'><p>(C++) Calculate a theta estimate using EB (Empirical Bayes) method</p></a></li>
<li><a href='#theta_FB'><p>(C++) Calculate a theta estimate using FB (Full Bayes) method</p></a></li>
<li><a href='#toggleConstraints'><p>Toggle constraints</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Optimal Test Design Approach to Fixed and Adaptive Test
Construction</td>
</tr>
<tr>
<td>Version:</td>
<td>1.5.1</td>
</tr>
<tr>
<td>Date:</td>
<td>2023-1-26</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Seung W. Choi &lt;schoi@austin.utexas.edu&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Uses the optimal test design approach by Birnbaum (1968, ISBN:9781593119348) and
    van der Linden (2018) &lt;<a href="https://doi.org/10.1201%2F9781315117430">doi:10.1201/9781315117430</a>&gt; to construct fixed, adaptive, and parallel tests.
    Supports the following mixed-integer programming (MIP) solver packages: 'Rsymphony',
    'gurobi', 'lpSolve', and 'Rglpk'. The 'gurobi' package is not available from CRAN; see <a href="https://www.gurobi.com/downloads/">https://www.gurobi.com/downloads/</a>.</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://choi-phd.github.io/TestDesign/">https://choi-phd.github.io/TestDesign/</a> (documentation)</td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/choi-phd/TestDesign/issues/">https://github.com/choi-phd/TestDesign/issues/</a></td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 2.10)</td>
</tr>
<tr>
<td>Imports:</td>
<td>Rcpp (&ge; 1.0.0), methods, lpSolve, foreach, logitnorm, crayon</td>
</tr>
<tr>
<td>SystemRequirements:</td>
<td>C++17</td>
</tr>
<tr>
<td>Suggests:</td>
<td>Rsymphony, gurobi, Rglpk, mirt, mirtCAT, progress, shiny,
shinythemes, shinyWidgets, shinyjs, DT, knitr, rmarkdown,
kableExtra, testthat (&ge; 2.1.0), pkgdown, pkgload</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>Rcpp, RcppArmadillo</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>Collate:</td>
<td>'RcppExports.R' 'import.R' 'extensions.R' 'item_class.R'
'calc_prob_functions.r' 'calc_escore_functions.r'
'calc_location_functions.r' 'calc_fisher_functions.r'
'calc_loglikelihood_functions.r' 'calc_jacobian_functions.r'
'calc_hessian_functions.r' 'sim_resp_functions.r'
'loading_functions.R' 'static_class.R' 'shadow_class.R'
'item_pool_operators.R' 'item_attrib_operators.R'
'st_attrib_operators.R' 'constraints_operators.R'
'static_functions.R' 'shadow_functions.R' 'bayes_functions.R'
'constraint_functions.R' 'cpp_calc_documents.r'
'cpp_core_documents.r' 'cpp_theta_documents.r' 'datasets.R'
'eligibility_functions.R' 'exposure_control_functions.R'
'solver_functions.R' 'helper_functions.R'
'item_pool_cluster_operators.R' 'other_functions.R'
'partitioning_class.r' 'partitioning_functions.r'
'plot_functions.R' 'summary_class.R' 'print_functions.R'
'runshiny.R' 'shadowtest_functions.R' 'summary_functions.R'
'show_functions.R' 'simulation_data_cache_class.r'
'simulation_data_cache_operators.r' 'theta_functions.R'
'xdata_functions.R'</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-01-30 14:01:36 UTC; chois1</td>
</tr>
<tr>
<td>Author:</td>
<td>Seung W. Choi <a href="https://orcid.org/0000-0003-4777-5420"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cre],
  Sangdon Lim <a href="https://orcid.org/0000-0002-2988-014X"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [aut]</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-01-30 15:40:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='a_to_alpha'>Calculate alpha angles from a-parameters</h2><span id='topic+a_to_alpha'></span>

<h3>Description</h3>

<p><code>a_to_alpha</code> is a function for converting an a-parameter vector to an alpha angle vector.
The returned values are in the radian metric.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>a_to_alpha(a)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="a_to_alpha_+3A_a">a</code></td>
<td>
<p>the <em>a</em>-parameter vector.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>a_to_alpha(c(1, 1))

</code></pre>

<hr>
<h2 id='app'>Open TestDesign app</h2><span id='topic+app'></span><span id='topic+OAT'></span>

<h3>Description</h3>

<p><code><a href="#topic+app">app</a></code> and <code><a href="#topic+OAT">OAT</a></code> are aliases of <code><a href="#topic+TestDesign">TestDesign</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>app()

OAT()
</code></pre>


<h3>Details</h3>

<p><code><a href="#topic+TestDesign">TestDesign</a></code> is a caller function to open the Shiny interface of TestDesign package.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Not run: 
if (interactive()) {
  TestDesign()
}

## End(Not run)

</code></pre>

<hr>
<h2 id='buildConstraints'>Build constraints (shortcut to other loading functions)</h2><span id='topic+buildConstraints'></span>

<h3>Description</h3>

<p><code><a href="#topic+buildConstraints">buildConstraints</a></code> is a data loading function to create a <code><a href="#topic+constraints-class">constraints</a></code> object.
<code><a href="#topic+buildConstraints">buildConstraints</a></code> is a shortcut that calls other data loading functions.
The constraints must be in the expected format; see the vignette in <code>vignette("constraints")</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>buildConstraints(
  object,
  item_pool,
  item_attrib,
  st_attrib = NULL,
  pool = NULL,
  constraints = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="buildConstraints_+3A_object">object</code></td>
<td>
<p>constraint specifications. Can be a data.frame or the file path of a .csv file. See the vignette for the expected format.</p>
</td></tr>
<tr><td><code id="buildConstraints_+3A_item_pool">item_pool</code></td>
<td>
<p>item parameters. Can be a <code><a href="#topic+item_pool-class">item_pool</a></code> object, a data.frame or the file path of a .csv file.</p>
</td></tr>
<tr><td><code id="buildConstraints_+3A_item_attrib">item_attrib</code></td>
<td>
<p>item attributes. Can be an <code><a href="#topic+item_attrib-class">item_attrib</a></code> object, a data.frame or the file path of a .csv file.</p>
</td></tr>
<tr><td><code id="buildConstraints_+3A_st_attrib">st_attrib</code></td>
<td>
<p>(optional) stimulus attributes. Can be an <code><a href="#topic+st_attrib-class">st_attrib</a></code> object, a data.frame or the file path of a .csv file.</p>
</td></tr>
<tr><td><code id="buildConstraints_+3A_pool">pool</code></td>
<td>
<p>(deprecated) use <code>item_pool</code> argument instead.</p>
</td></tr>
<tr><td><code id="buildConstraints_+3A_constraints">constraints</code></td>
<td>
<p>(deprecated) use <code>object</code> argument instead.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code><a href="#topic+buildConstraints">buildConstraints</a></code> returns a <code><a href="#topic+constraints-class">constraints</a></code> object. This object is used in <code><a href="#topic+Static">Static</a></code> and <code><a href="#topic+Shadow">Shadow</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Read from objects:
constraints_science &lt;- buildConstraints(constraints_science_data,
  itempool_science, itemattrib_science)
constraints_reading &lt;- buildConstraints(constraints_reading_data,
  itempool_reading, itemattrib_reading, stimattrib_reading)

## Read from data.frame:
constraints_science &lt;- buildConstraints(constraints_science_data,
  itempool_science_data, itemattrib_science_data)
constraints_reading &lt;- buildConstraints(constraints_reading_data,
  itempool_reading_data, itemattrib_reading_data, stimattrib_reading_data)

## Read from file: write to tempdir() for illustration and clean afterwards
f1 &lt;- file.path(tempdir(), "constraints_science.csv")
f2 &lt;- file.path(tempdir(), "itempool_science.csv")
f3 &lt;- file.path(tempdir(), "itemattrib_science.csv")
write.csv(constraints_science_data, f1, row.names = FALSE)
write.csv(itempool_science_data   , f2, row.names = FALSE)
write.csv(itemattrib_science_data , f3, row.names = FALSE)
constraints_science &lt;- buildConstraints(f1, f2, f3)
file.remove(f1)
file.remove(f2)
file.remove(f3)
</code></pre>

<hr>
<h2 id='calc_info'>(C++) For multiple items, calculate Fisher information</h2><span id='topic+calc_info'></span><span id='topic+calc_info_matrix'></span>

<h3>Description</h3>

<p><code>calc_info()</code> and <code>calc_info_matrix()</code> are functions for calculating Fisher information.
These functions are designed for multiple items.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>calc_info(x, item_parm, ncat, model)

calc_info_matrix(x, item_parm, ncat, model)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="calc_info_+3A_x">x</code></td>
<td>
<p>the theta value. This must be a column vector in matrix form for <code>calc_info_matrix()</code>.</p>
</td></tr>
<tr><td><code id="calc_info_+3A_item_parm">item_parm</code></td>
<td>
<p>a matrix containing item parameters. Each row should represent an item.</p>
</td></tr>
<tr><td><code id="calc_info_+3A_ncat">ncat</code></td>
<td>
<p>a vector containing the number of response categories of each item.</p>
</td></tr>
<tr><td><code id="calc_info_+3A_model">model</code></td>
<td>
<p>a vector indicating item models of each item, using </p>

<ul>
<li><p><code>1</code>: 1PL model
</p>
</li>
<li><p><code>2</code>: 2PL model
</p>
</li>
<li><p><code>3</code>: 3PL model
</p>
</li>
<li><p><code>4</code>: PC model
</p>
</li>
<li><p><code>5</code>: GPC model
</p>
</li>
<li><p><code>6</code>: GR model
</p>
</li></ul>
</td></tr>
</table>


<h3>Details</h3>

<p><code>calc_info()</code> accepts a single theta value, and <code>calc_info_matrix()</code> accepts multiple theta values.
</p>
<p>Currently supports unidimensional models.
</p>


<h3>References</h3>

<p>Rasch, G. (1960). <em>Probabilistic models for some intelligence and attainment tests.</em>
Copenhagen: Danish Institute for Educational Research.
</p>
<p>Lord, F. M. (1952). A theory of test scores (Psychometric Monograph No. 7). Richmond, VA: Psychometric Corporation.
</p>
<p>Birnbaum, A. (1957). <em>Efficient design and use of tests of mental ability for various decision-making problems</em>
(Series Report No. 58-16. Project No. 7755-23).
Randolph Air Force Base, TX: USAF School of Aviation Medicine.
</p>
<p>Birnbaum, A. (1958). <em>On the estimation of mental ability</em>
(Series Report No. 15. Project No. 7755-23).
Randolph Air Force Base, TX: USAF School of Aviation Medicine.
</p>
<p>Birnbaum, A. (1958). <em>Further considerations of efficiency in tests of a mental ability</em>
(Series Report No. 17. Project No. 7755-23).
Randolph Air Force Base, TX: USAF School of Aviation Medicine.
</p>
<p>Birnbaum, A. (1968). Some latent trait models and their use in inferring an examinee's ability.
In Lord, F. M., Novick, M. R. (eds.), <em>Statistical Theories of Mental Test Scores</em>, 397-479.
Reading, MA: Addison-Wesley.
</p>
<p>Masters, G. N. (1982). A Rasch model for partial credit scoring.
<em>Psychometrika, 47</em>(2), 149-174.
</p>
<p>Andrich, D. (1978). A rating formulation for ordered response categories.
<em>Psychometrika, 43</em>(4), 561-573.
</p>
<p>Muraki, E. (1992). A generalized partial credit model: Application of an EM algorithm.
<em>Applied Psychological Measurement, 16</em>(2), 159-176.
</p>
<p>Samejima, F. (1969). Estimation of latent ability using a response pattern of graded scores.
<em>Psychometrika Monograph, 17</em>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># item parameters
item_parm &lt;- matrix(c(
  1, NA,   NA,
  1,  2,   NA,
  1,  2, 0.25,
  0,  1,   NA,
  2,  0,    1,
  2,  0,    2),
  nrow = 6,
  byrow = TRUE
)

ncat  &lt;- c(2, 2, 2, 3, 3, 3)
model &lt;- c(1, 2, 3, 4, 5, 6)

# single theta example
x &lt;- 0.5
calc_info(x, item_parm, ncat, model)

# multiple thetas example
x &lt;- matrix(seq(0.1, 0.5, 0.1)) # column vector in matrix form
calc_info_matrix(x, item_parm, ncat, model)

</code></pre>

<hr>
<h2 id='calc_info_EB'>Calculate the Fisher information using empirical Bayes</h2><span id='topic+calc_info_EB'></span>

<h3>Description</h3>

<p>Calculate the Fisher information using empirical Bayes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>calc_info_EB(x, item_parm, ncat, model)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="calc_info_EB_+3A_x">x</code></td>
<td>
<p>A numeric vector of MCMC sampled theta values.</p>
</td></tr>
<tr><td><code id="calc_info_EB_+3A_item_parm">item_parm</code></td>
<td>
<p>A numeric matrix of item parameters.</p>
</td></tr>
<tr><td><code id="calc_info_EB_+3A_ncat">ncat</code></td>
<td>
<p>a numeric vector specifying the number of response categories in each item.</p>
</td></tr>
<tr><td><code id="calc_info_EB_+3A_model">model</code></td>
<td>
<p>a numeric vector indicating the IRT models of each item (1: 1PL, 2: 2PL, 3: 3PL, 4: PC, 5: GPC, 6: GR).</p>
</td></tr>
</table>

<hr>
<h2 id='calc_info_FB'>Calculate the Fisher information using full Bayesian</h2><span id='topic+calc_info_FB'></span>

<h3>Description</h3>

<p>Calculate the Fisher information using full Bayesian.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>calc_info_FB(x, items_list, ncat, model, useEAP = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="calc_info_FB_+3A_x">x</code></td>
<td>
<p>A numeric vector of MCMC sampled theta values.</p>
</td></tr>
<tr><td><code id="calc_info_FB_+3A_items_list">items_list</code></td>
<td>
<p>A list of item parameter matrices.</p>
</td></tr>
<tr><td><code id="calc_info_FB_+3A_ncat">ncat</code></td>
<td>
<p>a numeric vector specifying the number of response categories in each item.</p>
</td></tr>
<tr><td><code id="calc_info_FB_+3A_model">model</code></td>
<td>
<p>a numeric vector indicating the IRT models of each item (1: 1PL, 2: 2PL, 3: 3PL, 4: PC, 5: GPC, 6: GR).</p>
</td></tr>
<tr><td><code id="calc_info_FB_+3A_useeap">useEAP</code></td>
<td>
<p><code>TRUE</code> to use the mean of MCMC theta draws.</p>
</td></tr>
</table>

<hr>
<h2 id='calc_likelihood'>(C++) For multiple items, calculate likelihoods</h2><span id='topic+calc_likelihood'></span><span id='topic+calc_likelihood_function'></span><span id='topic+calc_log_likelihood'></span><span id='topic+calc_log_likelihood_function'></span>

<h3>Description</h3>

<p><code>calc_likelihood()</code> and <code>calc_likelihood_function()</code> are functions for calculating likelihoods.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>calc_likelihood(x, item_parm, resp, ncat, model)

calc_likelihood_function(theta_grid, item_parm, resp, ncat, model)

calc_log_likelihood(x, item_parm, resp, ncat, model, prior, prior_parm)

calc_log_likelihood_function(
  theta_grid,
  item_parm,
  resp,
  ncat,
  model,
  prior,
  prior_parm
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="calc_likelihood_+3A_x">x</code>, <code id="calc_likelihood_+3A_theta_grid">theta_grid</code></td>
<td>
<p>the theta value. This must be a column vector in matrix form for <code>calc_*_function()</code> functions.</p>
</td></tr>
<tr><td><code id="calc_likelihood_+3A_item_parm">item_parm</code></td>
<td>
<p>a matrix containing item parameters. Each row should represent an item.</p>
</td></tr>
<tr><td><code id="calc_likelihood_+3A_resp">resp</code></td>
<td>
<p>a vector containing responses on each item.</p>
</td></tr>
<tr><td><code id="calc_likelihood_+3A_ncat">ncat</code></td>
<td>
<p>a vector containing the number of response categories of each item.</p>
</td></tr>
<tr><td><code id="calc_likelihood_+3A_model">model</code></td>
<td>
<p>a vector indicating item models of each item, using </p>

<ul>
<li><p><code>1</code>: 1PL model
</p>
</li>
<li><p><code>2</code>: 2PL model
</p>
</li>
<li><p><code>3</code>: 3PL model
</p>
</li>
<li><p><code>4</code>: PC model
</p>
</li>
<li><p><code>5</code>: GPC model
</p>
</li>
<li><p><code>6</code>: GR model
</p>
</li></ul>
</td></tr>
<tr><td><code id="calc_likelihood_+3A_prior">prior</code></td>
<td>
<p>an integer indicating the type of prior distribution, using </p>

<ul>
<li><p><code>1</code>: normal distribution
</p>
</li>
<li><p><code>2</code>: uniform distribution
</p>
</li></ul>
</td></tr>
<tr><td><code id="calc_likelihood_+3A_prior_parm">prior_parm</code></td>
<td>
<p>a vector containing parameters for the prior distribution.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>calc_log_likelihood()</code> and <code>calc_log_likelihood_function()</code> are functions for calculating log likelihoods.
</p>
<p>These functions are designed for multiple items.
</p>
<p><code>calc_*()</code> functions accept a single theta value, and <code>calc_*_function()</code> functions accept multiple theta values.
</p>
<p>Currently supports unidimensional models.
</p>


<h3>References</h3>

<p>Rasch, G. (1960). <em>Probabilistic models for some intelligence and attainment tests.</em>
Copenhagen: Danish Institute for Educational Research.
</p>
<p>Lord, F. M. (1952). A theory of test scores (Psychometric Monograph No. 7). Richmond, VA: Psychometric Corporation.
</p>
<p>Birnbaum, A. (1957). <em>Efficient design and use of tests of mental ability for various decision-making problems</em>
(Series Report No. 58-16. Project No. 7755-23).
Randolph Air Force Base, TX: USAF School of Aviation Medicine.
</p>
<p>Birnbaum, A. (1958). <em>On the estimation of mental ability</em>
(Series Report No. 15. Project No. 7755-23).
Randolph Air Force Base, TX: USAF School of Aviation Medicine.
</p>
<p>Birnbaum, A. (1958). <em>Further considerations of efficiency in tests of a mental ability</em>
(Series Report No. 17. Project No. 7755-23).
Randolph Air Force Base, TX: USAF School of Aviation Medicine.
</p>
<p>Birnbaum, A. (1968). Some latent trait models and their use in inferring an examinee's ability.
In Lord, F. M., Novick, M. R. (eds.), <em>Statistical Theories of Mental Test Scores</em>, 397-479.
Reading, MA: Addison-Wesley.
</p>
<p>Masters, G. N. (1982). A Rasch model for partial credit scoring.
<em>Psychometrika, 47</em>(2), 149-174.
</p>
<p>Andrich, D. (1978). A rating formulation for ordered response categories.
<em>Psychometrika, 43</em>(4), 561-573.
</p>
<p>Muraki, E. (1992). A generalized partial credit model: Application of an EM algorithm.
<em>Applied Psychological Measurement, 16</em>(2), 159-176.
</p>
<p>Samejima, F. (1969). Estimation of latent ability using a response pattern of graded scores.
<em>Psychometrika Monograph, 17</em>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># item parameters
item_parm &lt;- matrix(c(
  1, NA,   NA,
  1,  2,   NA,
  1,  2, 0.25,
  0,  1,   NA,
  2,  0,    1,
  2,  0,    2),
  nrow = 6,
  byrow = TRUE
)

ncat  &lt;- c(2, 2, 2, 3, 3, 3)
model &lt;- c(1, 2, 3, 4, 5, 6)
resp  &lt;- c(0, 1, 0, 1, 0, 1)

x &lt;- 3
l  &lt;- calc_likelihood(x, item_parm, resp, ncat, model)
ll &lt;- calc_log_likelihood(x, item_parm, resp, ncat, model, 2, NA)
log(l) == ll

x &lt;- matrix(seq(-3, 3, .1))
l  &lt;- calc_likelihood_function(x, item_parm, resp, ncat, model)
ll &lt;- calc_log_likelihood_function(x, item_parm, resp, ncat, model, 2, NA)
all(log(l) == ll)

</code></pre>

<hr>
<h2 id='calc_MI_FB'>Calculate the mutual information using full Bayesian</h2><span id='topic+calc_MI_FB'></span>

<h3>Description</h3>

<p>Calculate the mutual information using full Bayesian.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>calc_MI_FB(x, items_list, ncat, model)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="calc_MI_FB_+3A_x">x</code></td>
<td>
<p>A numeric vector of MCMC sampled theta values.</p>
</td></tr>
<tr><td><code id="calc_MI_FB_+3A_items_list">items_list</code></td>
<td>
<p>A list of item parameter matrices.</p>
</td></tr>
<tr><td><code id="calc_MI_FB_+3A_ncat">ncat</code></td>
<td>
<p>a numeric vector specifying the number of response categories in each item.</p>
</td></tr>
<tr><td><code id="calc_MI_FB_+3A_model">model</code></td>
<td>
<p>a numeric vector indicating the IRT models of each item (1: 1PL, 2: 2PL, 3: 3PL, 4: PC, 5: GPC, 6: GR).</p>
</td></tr>
</table>

<hr>
<h2 id='calc_posterior'>Calculate a posterior value of theta</h2><span id='topic+calc_posterior'></span>

<h3>Description</h3>

<p>Calculate a posterior value of theta.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>calc_posterior(x, item_parm, resp, ncat, model, prior, prior_parm)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="calc_posterior_+3A_x">x</code></td>
<td>
<p>A length-one numeric vector for a theta value.</p>
</td></tr>
<tr><td><code id="calc_posterior_+3A_item_parm">item_parm</code></td>
<td>
<p>A numeric matrix of item parameters.</p>
</td></tr>
<tr><td><code id="calc_posterior_+3A_resp">resp</code></td>
<td>
<p>a numeric vector containing item responses.</p>
</td></tr>
<tr><td><code id="calc_posterior_+3A_ncat">ncat</code></td>
<td>
<p>A numeric vector of the number of response categories by item.</p>
</td></tr>
<tr><td><code id="calc_posterior_+3A_model">model</code></td>
<td>
<p>A numeric vector indicating the IRT models of each item (1: 1PL, 2: 2PL, 3: 3PL, 4: PC, 5: GPC, 6: GR).</p>
</td></tr>
<tr><td><code id="calc_posterior_+3A_prior">prior</code></td>
<td>
<p>The type of prior distribution (1: normal, 2: uniform).</p>
</td></tr>
<tr><td><code id="calc_posterior_+3A_prior_parm">prior_parm</code></td>
<td>
<p>A numeric vector of hyperparameters for the prior distribution, c(mu, sigma) or c(ll, ul).</p>
</td></tr>
</table>

<hr>
<h2 id='calc_posterior_function'>Calculate a posterior distribution of theta</h2><span id='topic+calc_posterior_function'></span>

<h3>Description</h3>

<p>Calculate a posterior distribution of theta.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>calc_posterior_function(
  theta_grid,
  item_parm,
  resp,
  ncat,
  model,
  prior,
  prior_parm
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="calc_posterior_function_+3A_theta_grid">theta_grid</code></td>
<td>
<p>An equi-spaced grid of theta values.</p>
</td></tr>
<tr><td><code id="calc_posterior_function_+3A_item_parm">item_parm</code></td>
<td>
<p>A numeric matrix of item parameters.</p>
</td></tr>
<tr><td><code id="calc_posterior_function_+3A_resp">resp</code></td>
<td>
<p>a numeric vector containing item responses.</p>
</td></tr>
<tr><td><code id="calc_posterior_function_+3A_ncat">ncat</code></td>
<td>
<p>A numeric vector of the number of response categories by item.</p>
</td></tr>
<tr><td><code id="calc_posterior_function_+3A_model">model</code></td>
<td>
<p>A numeric vector indicating the IRT models of each item (1: 1PL, 2: 2PL, 3: 3PL, 4: PC, 5: GPC, 6: GR).</p>
</td></tr>
<tr><td><code id="calc_posterior_function_+3A_prior">prior</code></td>
<td>
<p>The type of prior distribution (1: normal, 2: uniform).</p>
</td></tr>
<tr><td><code id="calc_posterior_function_+3A_prior_parm">prior_parm</code></td>
<td>
<p>A numeric vector of hyperparameters for the prior distribution, c(mu, sigma) or c(ll, ul).</p>
</td></tr>
</table>

<hr>
<h2 id='calc_posterior_single'>Calculate a posterior value of theta for a single item</h2><span id='topic+calc_posterior_single'></span>

<h3>Description</h3>

<p>Calculate a posterior value of theta for a single item.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>calc_posterior_single(x, item_parm, resp, ncat, model, prior, prior_parm)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="calc_posterior_single_+3A_x">x</code></td>
<td>
<p>A length-one numeric vector for a theta value.</p>
</td></tr>
<tr><td><code id="calc_posterior_single_+3A_item_parm">item_parm</code></td>
<td>
<p>A numeric vector of item parameters (for one item).</p>
</td></tr>
<tr><td><code id="calc_posterior_single_+3A_resp">resp</code></td>
<td>
<p>A length-one numeric vector of item responses.</p>
</td></tr>
<tr><td><code id="calc_posterior_single_+3A_ncat">ncat</code></td>
<td>
<p>A length-one numeric vector of the number of response categories by item.</p>
</td></tr>
<tr><td><code id="calc_posterior_single_+3A_model">model</code></td>
<td>
<p>A length-one numeric vector of the IRT model by item (1: 1PL, 2: 2PL, 3: 3PL, 4: PC, 5: GPC, 6: GR).</p>
</td></tr>
<tr><td><code id="calc_posterior_single_+3A_prior">prior</code></td>
<td>
<p>The type of prior distribution (1: normal, 2: uniform).</p>
</td></tr>
<tr><td><code id="calc_posterior_single_+3A_prior_parm">prior_parm</code></td>
<td>
<p>A numeric vector of hyperparameters for the prior distribution, c(mu, sigma) or c(ll, ul).</p>
</td></tr>
</table>

<hr>
<h2 id='calcEscore'>Calculate expected scores</h2><span id='topic+calcEscore'></span><span id='topic+calcEscore+2Citem_1PL+2Cnumeric-method'></span><span id='topic+calcEscore+2Citem_2PL+2Cnumeric-method'></span><span id='topic+calcEscore+2Citem_3PL+2Cnumeric-method'></span><span id='topic+calcEscore+2Citem_PC+2Cnumeric-method'></span><span id='topic+calcEscore+2Citem_GPC+2Cnumeric-method'></span><span id='topic+calcEscore+2Citem_GR+2Cnumeric-method'></span><span id='topic+calcEscore+2Citem_pool+2Cnumeric-method'></span><span id='topic+calcEscore+2Citem_1PL+2Cmatrix-method'></span><span id='topic+calcEscore+2Citem_2PL+2Cmatrix-method'></span><span id='topic+calcEscore+2Citem_3PL+2Cmatrix-method'></span><span id='topic+calcEscore+2Citem_PC+2Cmatrix-method'></span><span id='topic+calcEscore+2Citem_GPC+2Cmatrix-method'></span><span id='topic+calcEscore+2Citem_GR+2Cmatrix-method'></span><span id='topic+calcEscore+2Citem_pool+2Cmatrix-method'></span><span id='topic+calcEscore+2Citem_pool_cluster+2Cnumeric-method'></span>

<h3>Description</h3>

<p><code><a href="#topic+calcEscore">calcEscore</a></code> is a function for calculating expected scores.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>calcEscore(object, theta)

## S4 method for signature 'item_1PL,numeric'
calcEscore(object, theta)

## S4 method for signature 'item_2PL,numeric'
calcEscore(object, theta)

## S4 method for signature 'item_3PL,numeric'
calcEscore(object, theta)

## S4 method for signature 'item_PC,numeric'
calcEscore(object, theta)

## S4 method for signature 'item_GPC,numeric'
calcEscore(object, theta)

## S4 method for signature 'item_GR,numeric'
calcEscore(object, theta)

## S4 method for signature 'item_pool,numeric'
calcEscore(object, theta)

## S4 method for signature 'item_1PL,matrix'
calcEscore(object, theta)

## S4 method for signature 'item_2PL,matrix'
calcEscore(object, theta)

## S4 method for signature 'item_3PL,matrix'
calcEscore(object, theta)

## S4 method for signature 'item_PC,matrix'
calcEscore(object, theta)

## S4 method for signature 'item_GPC,matrix'
calcEscore(object, theta)

## S4 method for signature 'item_GR,matrix'
calcEscore(object, theta)

## S4 method for signature 'item_pool,matrix'
calcEscore(object, theta)

## S4 method for signature 'item_pool_cluster,numeric'
calcEscore(object, theta)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="calcEscore_+3A_object">object</code></td>
<td>
<p>an <code><a href="#topic+item">item</a></code> or an <code><a href="#topic+item_pool-class">item_pool</a></code> object.</p>
</td></tr>
<tr><td><code id="calcEscore_+3A_theta">theta</code></td>
<td>
<p>theta values to use.</p>
</td></tr>
</table>


<h3>Value</h3>


<dl>
<dt><code><a href="#topic+item">item</a></code> object:</dt><dd><p><code><a href="#topic+calcEscore">calcEscore</a></code> a vector containing expected score of the item at the theta values.</p>
</dd>
<dt><code><a href="#topic+item_pool-class">item_pool</a></code> object:</dt><dd><p><code><a href="#topic+calcEscore">calcEscore</a></code> returns a vector containing the pool-level expected score at the theta values.</p>
</dd>
</dl>



<h3>References</h3>

<p>Rasch, G. (1960). <em>Probabilistic models for some intelligence and attainment tests.</em>
Copenhagen: Danish Institute for Educational Research.
</p>
<p>Lord, F. M. (1952). A theory of test scores (Psychometric Monograph No. 7). Richmond, VA: Psychometric Corporation.
</p>
<p>Birnbaum, A. (1957). <em>Efficient design and use of tests of mental ability for various decision-making problems</em>
(Series Report No. 58-16. Project No. 7755-23).
Randolph Air Force Base, TX: USAF School of Aviation Medicine.
</p>
<p>Birnbaum, A. (1958). <em>On the estimation of mental ability</em>
(Series Report No. 15. Project No. 7755-23).
Randolph Air Force Base, TX: USAF School of Aviation Medicine.
</p>
<p>Birnbaum, A. (1958). <em>Further considerations of efficiency in tests of a mental ability</em>
(Series Report No. 17. Project No. 7755-23).
Randolph Air Force Base, TX: USAF School of Aviation Medicine.
</p>
<p>Birnbaum, A. (1968). Some latent trait models and their use in inferring an examinee's ability.
In Lord, F. M., Novick, M. R. (eds.), <em>Statistical Theories of Mental Test Scores</em>, 397-479.
Reading, MA: Addison-Wesley.
</p>
<p>Masters, G. N. (1982). A Rasch model for partial credit scoring.
<em>Psychometrika, 47</em>(2), 149-174.
</p>
<p>Andrich, D. (1978). A rating formulation for ordered response categories.
<em>Psychometrika, 43</em>(4), 561-573.
</p>
<p>Muraki, E. (1992). A generalized partial credit model: Application of an EM algorithm.
<em>Applied Psychological Measurement, 16</em>(2), 159-176.
</p>
<p>Samejima, F. (1969). Estimation of latent ability using a response pattern of graded scores.
<em>Psychometrika Monograph, 17</em>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>item_1     &lt;- new("item_1PL", difficulty = 0.5)
item_2     &lt;- new("item_2PL", slope = 1.0, difficulty = 0.5)
item_3     &lt;- new("item_3PL", slope = 1.0, difficulty = 0.5, guessing = 0.2)
item_4     &lt;- new("item_PC", threshold = c(-1, 0, 1), ncat = 4)
item_5     &lt;- new("item_GPC", slope = 1.2, threshold = c(-0.8, -1.0, 0.5), ncat = 4)
item_6     &lt;- new("item_GR", slope = 0.9, category = c(-1, 0, 1), ncat = 4)

ICC_item_1 &lt;- calcEscore(item_1, seq(-3, 3, 1))
ICC_item_2 &lt;- calcEscore(item_2, seq(-3, 3, 1))
ICC_item_3 &lt;- calcEscore(item_3, seq(-3, 3, 1))
ICC_item_4 &lt;- calcEscore(item_4, seq(-3, 3, 1))
ICC_item_5 &lt;- calcEscore(item_5, seq(-3, 3, 1))
ICC_item_6 &lt;- calcEscore(item_6, seq(-3, 3, 1))
TCC_pool   &lt;- calcEscore(itempool_science, seq(-3, 3, 1))

</code></pre>

<hr>
<h2 id='calcFisher'>Calculate Fisher information</h2><span id='topic+calcFisher'></span><span id='topic+calcFisher+2Citem_1PL+2Cnumeric-method'></span><span id='topic+calcFisher+2Citem_2PL+2Cnumeric-method'></span><span id='topic+calcFisher+2Citem_3PL+2Cnumeric-method'></span><span id='topic+calcFisher+2Citem_PC+2Cnumeric-method'></span><span id='topic+calcFisher+2Citem_GPC+2Cnumeric-method'></span><span id='topic+calcFisher+2Citem_GR+2Cnumeric-method'></span><span id='topic+calcFisher+2Citem_pool+2Cnumeric-method'></span><span id='topic+calcFisher+2Citem_1PL+2Cmatrix-method'></span><span id='topic+calcFisher+2Citem_2PL+2Cmatrix-method'></span><span id='topic+calcFisher+2Citem_3PL+2Cmatrix-method'></span><span id='topic+calcFisher+2Citem_PC+2Cmatrix-method'></span><span id='topic+calcFisher+2Citem_GPC+2Cmatrix-method'></span><span id='topic+calcFisher+2Citem_GR+2Cmatrix-method'></span><span id='topic+calcFisher+2Citem_pool+2Cmatrix-method'></span><span id='topic+calcFisher+2Citem_pool_cluster+2Cnumeric-method'></span>

<h3>Description</h3>

<p><code><a href="#topic+calcFisher">calcFisher</a></code> is a function to calculate Fisher information.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>calcFisher(object, theta)

## S4 method for signature 'item_1PL,numeric'
calcFisher(object, theta)

## S4 method for signature 'item_2PL,numeric'
calcFisher(object, theta)

## S4 method for signature 'item_3PL,numeric'
calcFisher(object, theta)

## S4 method for signature 'item_PC,numeric'
calcFisher(object, theta)

## S4 method for signature 'item_GPC,numeric'
calcFisher(object, theta)

## S4 method for signature 'item_GR,numeric'
calcFisher(object, theta)

## S4 method for signature 'item_pool,numeric'
calcFisher(object, theta)

## S4 method for signature 'item_1PL,matrix'
calcFisher(object, theta)

## S4 method for signature 'item_2PL,matrix'
calcFisher(object, theta)

## S4 method for signature 'item_3PL,matrix'
calcFisher(object, theta)

## S4 method for signature 'item_PC,matrix'
calcFisher(object, theta)

## S4 method for signature 'item_GPC,matrix'
calcFisher(object, theta)

## S4 method for signature 'item_GR,matrix'
calcFisher(object, theta)

## S4 method for signature 'item_pool,matrix'
calcFisher(object, theta)

## S4 method for signature 'item_pool_cluster,numeric'
calcFisher(object, theta)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="calcFisher_+3A_object">object</code></td>
<td>
<p>an <code><a href="#topic+item">item</a></code> or an <code><a href="#topic+item_pool-class">item_pool</a></code> object.</p>
</td></tr>
<tr><td><code id="calcFisher_+3A_theta">theta</code></td>
<td>
<p>theta values to use.</p>
</td></tr>
</table>


<h3>Value</h3>


<dl>
<dt><code><a href="#topic+item">item</a></code> object:</dt><dd><p><code><a href="#topic+calcFisher">calcFisher</a></code> returns a (<em>nq</em>, <em>1</em>) matrix of information values.</p>
</dd>
<dt><code><a href="#topic+item_pool-class">item_pool</a></code> object:</dt><dd><p><code><a href="#topic+calcProb">calcProb</a></code> returns a (<em>nq</em>, <em>ni</em>) matrix of information values.</p>
</dd>
</dl>


<dl>
<dt><em>notations</em></dt><dd>
<ul>
<li><p><em>nq</em> denotes the number of theta values.
</p>
</li>
<li><p><em>ni</em> denotes the number of items in the <code><a href="#topic+item_pool-class">item_pool</a></code> object.
</p>
</li></ul>
</dd>
</dl>

<p>A vector of Fisher information values over theta (nq values) for a single item or a matrix of dimension (nq, ni) for an &quot;item_pool&quot;.
</p>


<h3>References</h3>

<p>Rasch, G. (1960). <em>Probabilistic models for some intelligence and attainment tests.</em>
Copenhagen: Danish Institute for Educational Research.
</p>
<p>Lord, F. M. (1952). A theory of test scores (Psychometric Monograph No. 7). Richmond, VA: Psychometric Corporation.
</p>
<p>Birnbaum, A. (1957). <em>Efficient design and use of tests of mental ability for various decision-making problems</em>
(Series Report No. 58-16. Project No. 7755-23).
Randolph Air Force Base, TX: USAF School of Aviation Medicine.
</p>
<p>Birnbaum, A. (1958). <em>On the estimation of mental ability</em>
(Series Report No. 15. Project No. 7755-23).
Randolph Air Force Base, TX: USAF School of Aviation Medicine.
</p>
<p>Birnbaum, A. (1958). <em>Further considerations of efficiency in tests of a mental ability</em>
(Series Report No. 17. Project No. 7755-23).
Randolph Air Force Base, TX: USAF School of Aviation Medicine.
</p>
<p>Birnbaum, A. (1968). Some latent trait models and their use in inferring an examinee's ability.
In Lord, F. M., Novick, M. R. (eds.), <em>Statistical Theories of Mental Test Scores</em>, 397-479.
Reading, MA: Addison-Wesley.
</p>
<p>Masters, G. N. (1982). A Rasch model for partial credit scoring.
<em>Psychometrika, 47</em>(2), 149-174.
</p>
<p>Andrich, D. (1978). A rating formulation for ordered response categories.
<em>Psychometrika, 43</em>(4), 561-573.
</p>
<p>Muraki, E. (1992). A generalized partial credit model: Application of an EM algorithm.
<em>Applied Psychological Measurement, 16</em>(2), 159-176.
</p>
<p>Samejima, F. (1969). Estimation of latent ability using a response pattern of graded scores.
<em>Psychometrika Monograph, 17</em>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>item_1      &lt;- new("item_1PL", difficulty = 0.5)
item_2      &lt;- new("item_2PL", slope = 1.0, difficulty = 0.5)
item_3      &lt;- new("item_3PL", slope = 1.0, difficulty = 0.5, guessing = 0.2)
item_4      &lt;- new("item_PC", threshold = c(-1, 0, 1), ncat = 4)
item_5      &lt;- new("item_GPC", slope = 1.2, threshold = c(-0.8, -1.0, 0.5), ncat = 4)
item_6      &lt;- new("item_GR", slope = 0.9, category = c(-1, 0, 1), ncat = 4)

info_item_1 &lt;- calcFisher(item_1, seq(-3, 3, 1))
info_item_2 &lt;- calcFisher(item_2, seq(-3, 3, 1))
info_item_3 &lt;- calcFisher(item_3, seq(-3, 3, 1))
info_item_4 &lt;- calcFisher(item_4, seq(-3, 3, 1))
info_item_5 &lt;- calcFisher(item_5, seq(-3, 3, 1))
info_item_6 &lt;- calcFisher(item_6, seq(-3, 3, 1))
info_pool   &lt;- calcFisher(itempool_science, seq(-3, 3, 1))

</code></pre>

<hr>
<h2 id='calcHessian'>Calculate second derivative of log-likelihood</h2><span id='topic+calcHessian'></span><span id='topic+calcHessian+2Citem_1PL+2Cnumeric+2Cnumeric-method'></span><span id='topic+calcHessian+2Citem_1PL+2Cnumeric-method'></span><span id='topic+calcHessian+2Citem_2PL+2Cnumeric+2Cnumeric-method'></span><span id='topic+calcHessian+2Citem_2PL+2Cnumeric-method'></span><span id='topic+calcHessian+2Citem_3PL+2Cnumeric+2Cnumeric-method'></span><span id='topic+calcHessian+2Citem_3PL+2Cnumeric-method'></span><span id='topic+calcHessian+2Citem_PC+2Cnumeric+2Cnumeric-method'></span><span id='topic+calcHessian+2Citem_PC+2Cnumeric-method'></span><span id='topic+calcHessian+2Citem_GPC+2Cnumeric+2Cnumeric-method'></span><span id='topic+calcHessian+2Citem_GPC+2Cnumeric-method'></span><span id='topic+calcHessian+2Citem_GR+2Cnumeric+2Cnumeric-method'></span><span id='topic+calcHessian+2Citem_GR+2Cnumeric-method'></span><span id='topic+calcHessian+2Citem_1PL+2Cmatrix+2Cnumeric-method'></span><span id='topic+calcHessian+2Citem_1PL+2Cmatrix-method'></span><span id='topic+calcHessian+2Citem_2PL+2Cmatrix+2Cnumeric-method'></span><span id='topic+calcHessian+2Citem_2PL+2Cmatrix-method'></span><span id='topic+calcHessian+2Citem_3PL+2Cmatrix+2Cnumeric-method'></span><span id='topic+calcHessian+2Citem_3PL+2Cmatrix-method'></span><span id='topic+calcHessian+2Citem_PC+2Cmatrix+2Cnumeric-method'></span><span id='topic+calcHessian+2Citem_PC+2Cmatrix-method'></span><span id='topic+calcHessian+2Citem_GPC+2Cmatrix+2Cnumeric-method'></span><span id='topic+calcHessian+2Citem_GPC+2Cmatrix-method'></span><span id='topic+calcHessian+2Citem_GR+2Cmatrix+2Cnumeric-method'></span><span id='topic+calcHessian+2Citem_GR+2Cmatrix-method'></span><span id='topic+calcHessian+2Citem_pool+2Cnumeric+2Cnumeric-method'></span><span id='topic+calcHessian+2Citem_pool+2Cnumeric-method'></span><span id='topic+calcHessian+2Citem_pool_cluster+2Cnumeric+2Clist-method'></span><span id='topic+calcHessian+2Citem_pool_cluster+2Cnumeric-method'></span>

<h3>Description</h3>

<p><code><a href="#topic+calcHessian">calcHessian</a></code> is a function to calculate the second derivative of the log-likelihood function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>calcHessian(object, theta, resp)

## S4 method for signature 'item_1PL,numeric,numeric'
calcHessian(object, theta, resp)

## S4 method for signature 'item_2PL,numeric,numeric'
calcHessian(object, theta, resp)

## S4 method for signature 'item_3PL,numeric,numeric'
calcHessian(object, theta, resp)

## S4 method for signature 'item_PC,numeric,numeric'
calcHessian(object, theta, resp)

## S4 method for signature 'item_GPC,numeric,numeric'
calcHessian(object, theta, resp)

## S4 method for signature 'item_GR,numeric,numeric'
calcHessian(object, theta, resp)

## S4 method for signature 'item_1PL,matrix,numeric'
calcHessian(object, theta, resp)

## S4 method for signature 'item_2PL,matrix,numeric'
calcHessian(object, theta, resp)

## S4 method for signature 'item_3PL,matrix,numeric'
calcHessian(object, theta, resp)

## S4 method for signature 'item_PC,matrix,numeric'
calcHessian(object, theta, resp)

## S4 method for signature 'item_GPC,matrix,numeric'
calcHessian(object, theta, resp)

## S4 method for signature 'item_GR,matrix,numeric'
calcHessian(object, theta, resp)

## S4 method for signature 'item_pool,numeric,numeric'
calcHessian(object, theta, resp)

## S4 method for signature 'item_pool_cluster,numeric,list'
calcHessian(object, theta, resp)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="calcHessian_+3A_object">object</code></td>
<td>
<p>an <code><a href="#topic+item">item</a></code> or an <code><a href="#topic+item_pool-class">item_pool</a></code> object.</p>
</td></tr>
<tr><td><code id="calcHessian_+3A_theta">theta</code></td>
<td>
<p>theta values to use.</p>
</td></tr>
<tr><td><code id="calcHessian_+3A_resp">resp</code></td>
<td>
<p>the response data to use. This must be a single value for an <code><a href="#topic+item">item</a></code>, or a length <em>ni</em> vector for an <code><a href="#topic+item_pool-class">item_pool</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>


<dl>
<dt><em>notations</em></dt><dd>
<ul>
<li><p><em>nq</em> denotes the number of theta values.
</p>
</li>
<li><p><em>ni</em> denotes the number of items in the <code><a href="#topic+item_pool-class">item_pool</a></code> object.
</p>
</li></ul>
</dd>
</dl>



<h3>Value</h3>


<dl>
<dt><code><a href="#topic+item">item</a></code> object:</dt><dd><p><code><a href="#topic+calcHessian">calcHessian</a></code> returns a length <em>nq</em> vector containing the second derivative of the log-likelihood function, of observing the response at each theta.</p>
</dd>
<dt><code><a href="#topic+item_pool-class">item_pool</a></code> object:</dt><dd><p><code><a href="#topic+calcHessian">calcHessian</a></code> returns a (<em>nq</em>, <em>ni</em>) matrix containing the second derivative of the log-likelihood function, of observing the response at each theta.</p>
</dd>
</dl>



<h3>References</h3>

<p>Rasch, G. (1960). <em>Probabilistic models for some intelligence and attainment tests.</em>
Copenhagen: Danish Institute for Educational Research.
</p>
<p>Lord, F. M. (1952). A theory of test scores (Psychometric Monograph No. 7). Richmond, VA: Psychometric Corporation.
</p>
<p>Birnbaum, A. (1957). <em>Efficient design and use of tests of mental ability for various decision-making problems</em>
(Series Report No. 58-16. Project No. 7755-23).
Randolph Air Force Base, TX: USAF School of Aviation Medicine.
</p>
<p>Birnbaum, A. (1958). <em>On the estimation of mental ability</em>
(Series Report No. 15. Project No. 7755-23).
Randolph Air Force Base, TX: USAF School of Aviation Medicine.
</p>
<p>Birnbaum, A. (1958). <em>Further considerations of efficiency in tests of a mental ability</em>
(Series Report No. 17. Project No. 7755-23).
Randolph Air Force Base, TX: USAF School of Aviation Medicine.
</p>
<p>Birnbaum, A. (1968). Some latent trait models and their use in inferring an examinee's ability.
In Lord, F. M., Novick, M. R. (eds.), <em>Statistical Theories of Mental Test Scores</em>, 397-479.
Reading, MA: Addison-Wesley.
</p>
<p>Masters, G. N. (1982). A Rasch model for partial credit scoring.
<em>Psychometrika, 47</em>(2), 149-174.
</p>
<p>Andrich, D. (1978). A rating formulation for ordered response categories.
<em>Psychometrika, 43</em>(4), 561-573.
</p>
<p>Muraki, E. (1992). A generalized partial credit model: Application of an EM algorithm.
<em>Applied Psychological Measurement, 16</em>(2), 159-176.
</p>
<p>Samejima, F. (1969). Estimation of latent ability using a response pattern of graded scores.
<em>Psychometrika Monograph, 17</em>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
item_1    &lt;- new("item_1PL", difficulty = 0.5)
item_2    &lt;- new("item_2PL", slope = 1.0, difficulty = 0.5)
item_3    &lt;- new("item_3PL", slope = 1.0, difficulty = 0.5, guessing = 0.2)
item_4    &lt;- new("item_PC", threshold = c(-1, 0, 1), ncat = 4)
item_5    &lt;- new("item_GPC", slope = 1.2, threshold = c(-0.8, -1.0, 0.5), ncat = 4)
item_6    &lt;- new("item_GR", slope = 0.9, category = c(-1, 0, 1), ncat = 4)

h_item_1 &lt;- calcHessian(item_1, seq(-3, 3, 1), 0)
h_item_2 &lt;- calcHessian(item_2, seq(-3, 3, 1), 0)
h_item_3 &lt;- calcHessian(item_3, seq(-3, 3, 1), 0)
h_item_4 &lt;- calcHessian(item_4, seq(-3, 3, 1), 0)
h_item_5 &lt;- calcHessian(item_5, seq(-3, 3, 1), 0)
h_item_6 &lt;- calcHessian(item_6, seq(-3, 3, 1), 0)
h_pool   &lt;- calcHessian(
  itempool_science, seq(-3, 3, 1),
  rep(0, itempool_science@ni)
)

</code></pre>

<hr>
<h2 id='calcJacobian'>Calculate first derivative of log-likelihood</h2><span id='topic+calcJacobian'></span><span id='topic+calcJacobian+2Citem_1PL+2Cnumeric+2Cnumeric-method'></span><span id='topic+calcJacobian+2Citem_1PL+2Cnumeric-method'></span><span id='topic+calcJacobian+2Citem_2PL+2Cnumeric+2Cnumeric-method'></span><span id='topic+calcJacobian+2Citem_2PL+2Cnumeric-method'></span><span id='topic+calcJacobian+2Citem_3PL+2Cnumeric+2Cnumeric-method'></span><span id='topic+calcJacobian+2Citem_3PL+2Cnumeric-method'></span><span id='topic+calcJacobian+2Citem_PC+2Cnumeric+2Cnumeric-method'></span><span id='topic+calcJacobian+2Citem_PC+2Cnumeric-method'></span><span id='topic+calcJacobian+2Citem_GPC+2Cnumeric+2Cnumeric-method'></span><span id='topic+calcJacobian+2Citem_GPC+2Cnumeric-method'></span><span id='topic+calcJacobian+2Citem_GR+2Cnumeric+2Cnumeric-method'></span><span id='topic+calcJacobian+2Citem_GR+2Cnumeric-method'></span><span id='topic+calcJacobian+2Citem_1PL+2Cmatrix+2Cnumeric-method'></span><span id='topic+calcJacobian+2Citem_1PL+2Cmatrix-method'></span><span id='topic+calcJacobian+2Citem_2PL+2Cmatrix+2Cnumeric-method'></span><span id='topic+calcJacobian+2Citem_2PL+2Cmatrix-method'></span><span id='topic+calcJacobian+2Citem_3PL+2Cmatrix+2Cnumeric-method'></span><span id='topic+calcJacobian+2Citem_3PL+2Cmatrix-method'></span><span id='topic+calcJacobian+2Citem_PC+2Cmatrix+2Cnumeric-method'></span><span id='topic+calcJacobian+2Citem_PC+2Cmatrix-method'></span><span id='topic+calcJacobian+2Citem_GPC+2Cmatrix+2Cnumeric-method'></span><span id='topic+calcJacobian+2Citem_GPC+2Cmatrix-method'></span><span id='topic+calcJacobian+2Citem_GR+2Cmatrix+2Cnumeric-method'></span><span id='topic+calcJacobian+2Citem_GR+2Cmatrix-method'></span><span id='topic+calcJacobian+2Citem_pool+2Cnumeric+2Cnumeric-method'></span><span id='topic+calcJacobian+2Citem_pool+2Cnumeric-method'></span><span id='topic+calcJacobian+2Citem_pool_cluster+2Cnumeric+2Clist-method'></span><span id='topic+calcJacobian+2Citem_pool_cluster+2Cnumeric-method'></span>

<h3>Description</h3>

<p><code><a href="#topic+calcJacobian">calcJacobian</a></code> is a function for calculating the first derivative of the log-likelihood function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>calcJacobian(object, theta, resp)

## S4 method for signature 'item_1PL,numeric,numeric'
calcJacobian(object, theta, resp)

## S4 method for signature 'item_2PL,numeric,numeric'
calcJacobian(object, theta, resp)

## S4 method for signature 'item_3PL,numeric,numeric'
calcJacobian(object, theta, resp)

## S4 method for signature 'item_PC,numeric,numeric'
calcJacobian(object, theta, resp)

## S4 method for signature 'item_GPC,numeric,numeric'
calcJacobian(object, theta, resp)

## S4 method for signature 'item_GR,numeric,numeric'
calcJacobian(object, theta, resp)

## S4 method for signature 'item_1PL,matrix,numeric'
calcJacobian(object, theta, resp)

## S4 method for signature 'item_2PL,matrix,numeric'
calcJacobian(object, theta, resp)

## S4 method for signature 'item_3PL,matrix,numeric'
calcJacobian(object, theta, resp)

## S4 method for signature 'item_PC,matrix,numeric'
calcJacobian(object, theta, resp)

## S4 method for signature 'item_GPC,matrix,numeric'
calcJacobian(object, theta, resp)

## S4 method for signature 'item_GR,matrix,numeric'
calcJacobian(object, theta, resp)

## S4 method for signature 'item_pool,numeric,numeric'
calcJacobian(object, theta, resp)

## S4 method for signature 'item_pool_cluster,numeric,list'
calcJacobian(object, theta, resp)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="calcJacobian_+3A_object">object</code></td>
<td>
<p>an <code><a href="#topic+item">item</a></code> or an <code><a href="#topic+item_pool-class">item_pool</a></code> object.</p>
</td></tr>
<tr><td><code id="calcJacobian_+3A_theta">theta</code></td>
<td>
<p>theta values to use.</p>
</td></tr>
<tr><td><code id="calcJacobian_+3A_resp">resp</code></td>
<td>
<p>the response value to use for each item.</p>
</td></tr>
</table>


<h3>Value</h3>


<dl>
<dt><code><a href="#topic+item">item</a></code> object:</dt><dd><p><code><a href="#topic+calcJacobian">calcJacobian</a></code> returns a length <em>nq</em> vector containing the first derivative of the log-likelihood function, of observing the response at each theta.</p>
</dd>
<dt><code><a href="#topic+item_pool-class">item_pool</a></code> object:</dt><dd><p><code><a href="#topic+calcJacobian">calcJacobian</a></code> returns a (<em>nq</em>, <em>ni</em>) matrix containing the first derivative of the log-likelihood function, of observing the response at each theta.</p>
</dd>
</dl>


<dl>
<dt><em>notations</em></dt><dd>
<ul>
<li><p><em>nq</em> denotes the number of theta values.
</p>
</li>
<li><p><em>ni</em> denotes the number of items in the <code><a href="#topic+item_pool-class">item_pool</a></code> object.
</p>
</li></ul>
</dd>
</dl>



<h3>References</h3>

<p>Rasch, G. (1960). <em>Probabilistic models for some intelligence and attainment tests.</em>
Copenhagen: Danish Institute for Educational Research.
</p>
<p>Lord, F. M. (1952). A theory of test scores (Psychometric Monograph No. 7). Richmond, VA: Psychometric Corporation.
</p>
<p>Birnbaum, A. (1957). <em>Efficient design and use of tests of mental ability for various decision-making problems</em>
(Series Report No. 58-16. Project No. 7755-23).
Randolph Air Force Base, TX: USAF School of Aviation Medicine.
</p>
<p>Birnbaum, A. (1958). <em>On the estimation of mental ability</em>
(Series Report No. 15. Project No. 7755-23).
Randolph Air Force Base, TX: USAF School of Aviation Medicine.
</p>
<p>Birnbaum, A. (1958). <em>Further considerations of efficiency in tests of a mental ability</em>
(Series Report No. 17. Project No. 7755-23).
Randolph Air Force Base, TX: USAF School of Aviation Medicine.
</p>
<p>Birnbaum, A. (1968). Some latent trait models and their use in inferring an examinee's ability.
In Lord, F. M., Novick, M. R. (eds.), <em>Statistical Theories of Mental Test Scores</em>, 397-479.
Reading, MA: Addison-Wesley.
</p>
<p>Masters, G. N. (1982). A Rasch model for partial credit scoring.
<em>Psychometrika, 47</em>(2), 149-174.
</p>
<p>Andrich, D. (1978). A rating formulation for ordered response categories.
<em>Psychometrika, 43</em>(4), 561-573.
</p>
<p>Muraki, E. (1992). A generalized partial credit model: Application of an EM algorithm.
<em>Applied Psychological Measurement, 16</em>(2), 159-176.
</p>
<p>Samejima, F. (1969). Estimation of latent ability using a response pattern of graded scores.
<em>Psychometrika Monograph, 17</em>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>item_1    &lt;- new("item_1PL", difficulty = 0.5)
item_2    &lt;- new("item_2PL", slope = 1.0, difficulty = 0.5)
item_3    &lt;- new("item_3PL", slope = 1.0, difficulty = 0.5, guessing = 0.2)
item_4    &lt;- new("item_PC", threshold = c(-1, 0, 1), ncat = 4)
item_5    &lt;- new("item_GPC", slope = 1.2, threshold = c(-0.8, -1.0, 0.5), ncat = 4)
item_6    &lt;- new("item_GR", slope = 0.9, category = c(-1, 0, 1), ncat = 4)

j_item_1 &lt;- calcJacobian(item_1, seq(-3, 3, 1), 0)
j_item_2 &lt;- calcJacobian(item_2, seq(-3, 3, 1), 0)
j_item_3 &lt;- calcJacobian(item_3, seq(-3, 3, 1), 0)
j_item_4 &lt;- calcJacobian(item_4, seq(-3, 3, 1), 0)
j_item_5 &lt;- calcJacobian(item_5, seq(-3, 3, 1), 0)
j_item_6 &lt;- calcJacobian(item_6, seq(-3, 3, 1), 0)
j_pool   &lt;- calcJacobian(
  itempool_science, seq(-3, 3, 1),
  rep(0, itempool_science@ni)
)

</code></pre>

<hr>
<h2 id='calcLocation-methods'>Calculate central location (overall difficulty)</h2><span id='topic+calcLocation-methods'></span><span id='topic+calcLocation'></span><span id='topic+calcLocation+2Citem_1PL-method'></span><span id='topic+calcLocation+2Citem_2PL-method'></span><span id='topic+calcLocation+2Citem_3PL-method'></span><span id='topic+calcLocation+2Citem_PC-method'></span><span id='topic+calcLocation+2Citem_GPC-method'></span><span id='topic+calcLocation+2Citem_GR-method'></span><span id='topic+calcLocation+2Citem_pool-method'></span>

<h3>Description</h3>

<p><code><a href="#topic+calcLocation">calcLocation</a></code> is a function to calculate the central location (overall difficulty) of items.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>calcLocation(object)

## S4 method for signature 'item_1PL'
calcLocation(object)

## S4 method for signature 'item_2PL'
calcLocation(object)

## S4 method for signature 'item_3PL'
calcLocation(object)

## S4 method for signature 'item_PC'
calcLocation(object)

## S4 method for signature 'item_GPC'
calcLocation(object)

## S4 method for signature 'item_GR'
calcLocation(object)

## S4 method for signature 'item_pool'
calcLocation(object)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="calcLocation-methods_+3A_object">object</code></td>
<td>
<p>an <code><a href="#topic+item">item</a></code> or an <code><a href="#topic+item_pool-class">item_pool</a></code> object.</p>
</td></tr>
</table>


<h3>Value</h3>


<dl>
<dt><code><a href="#topic+item">item</a></code> object:</dt><dd><p><code><a href="#topic+calcLocation">calcLocation</a></code> returns a theta value representing the central location.</p>
</dd>
<dt><code><a href="#topic+item_pool-class">item_pool</a></code> object:</dt><dd><p><code><a href="#topic+calcProb">calcProb</a></code> returns a length <em>ni</em> list, each containing the central location of the item.</p>
</dd>
</dl>


<dl>
<dt><em>notations</em></dt><dd>
<ul>
<li><p><em>ni</em> denotes the number of items in the <code><a href="#topic+item_pool-class">item_pool</a></code> object.
</p>
</li></ul>
</dd>
</dl>



<h3>References</h3>

<p>Rasch, G. (1960). <em>Probabilistic models for some intelligence and attainment tests.</em>
Copenhagen: Danish Institute for Educational Research.
</p>
<p>Lord, F. M. (1952). A theory of test scores (Psychometric Monograph No. 7). Richmond, VA: Psychometric Corporation.
</p>
<p>Birnbaum, A. (1957). <em>Efficient design and use of tests of mental ability for various decision-making problems</em>
(Series Report No. 58-16. Project No. 7755-23).
Randolph Air Force Base, TX: USAF School of Aviation Medicine.
</p>
<p>Birnbaum, A. (1958). <em>On the estimation of mental ability</em>
(Series Report No. 15. Project No. 7755-23).
Randolph Air Force Base, TX: USAF School of Aviation Medicine.
</p>
<p>Birnbaum, A. (1958). <em>Further considerations of efficiency in tests of a mental ability</em>
(Series Report No. 17. Project No. 7755-23).
Randolph Air Force Base, TX: USAF School of Aviation Medicine.
</p>
<p>Birnbaum, A. (1968). Some latent trait models and their use in inferring an examinee's ability.
In Lord, F. M., Novick, M. R. (eds.), <em>Statistical Theories of Mental Test Scores</em>, 397-479.
Reading, MA: Addison-Wesley.
</p>
<p>Masters, G. N. (1982). A Rasch model for partial credit scoring.
<em>Psychometrika, 47</em>(2), 149-174.
</p>
<p>Andrich, D. (1978). A rating formulation for ordered response categories.
<em>Psychometrika, 43</em>(4), 561-573.
</p>
<p>Muraki, E. (1992). A generalized partial credit model: Application of an EM algorithm.
<em>Applied Psychological Measurement, 16</em>(2), 159-176.
</p>
<p>Samejima, F. (1969). Estimation of latent ability using a response pattern of graded scores.
<em>Psychometrika Monograph, 17</em>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>item_1      &lt;- new("item_1PL", difficulty = 0.5)
item_2      &lt;- new("item_2PL", slope = 1.0, difficulty = 0.5)
item_3      &lt;- new("item_3PL", slope = 1.0, difficulty = 0.5, guessing = 0.2)
item_4      &lt;- new("item_PC", threshold = c(-1, 0, 1), ncat = 4)
item_5      &lt;- new("item_GPC", slope = 1.2, threshold = c(-0.8, -1.0, 0.5), ncat = 4)
item_6      &lt;- new("item_GR", slope = 0.9, category = c(-1, 0, 1), ncat = 4)

loc_item_1 &lt;- calcLocation(item_1)
loc_item_2 &lt;- calcLocation(item_2)
loc_item_3 &lt;- calcLocation(item_3)
loc_item_4 &lt;- calcLocation(item_4)
loc_item_5 &lt;- calcLocation(item_5)
loc_item_6 &lt;- calcLocation(item_6)
loc_pool   &lt;- calcLocation(itempool_science)

</code></pre>

<hr>
<h2 id='calcLogLikelihood'>Calculate log-likelihood</h2><span id='topic+calcLogLikelihood'></span><span id='topic+calcLogLikelihood+2Citem_pool+2Cnumeric+2Cnumeric-method'></span><span id='topic+calcLogLikelihood+2Citem_pool+2Cnumeric+2Cmatrix-method'></span><span id='topic+calcLogLikelihood+2Citem_pool+2Cmatrix+2Cnumeric-method'></span><span id='topic+calcLogLikelihood+2Citem_pool+2Cmatrix+2Cmatrix-method'></span>

<h3>Description</h3>

<p><code><a href="#topic+calcLogLikelihood">calcLogLikelihood</a></code> is a function to calculate log-likelihood values.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>calcLogLikelihood(object, theta, resp)

## S4 method for signature 'item_pool,numeric,numeric'
calcLogLikelihood(object, theta, resp)

## S4 method for signature 'item_pool,numeric,matrix'
calcLogLikelihood(object, theta, resp)

## S4 method for signature 'item_pool,matrix,numeric'
calcLogLikelihood(object, theta, resp)

## S4 method for signature 'item_pool,matrix,matrix'
calcLogLikelihood(object, theta, resp)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="calcLogLikelihood_+3A_object">object</code></td>
<td>
<p>an <code><a href="#topic+item_pool-class">item_pool</a></code> object.</p>
</td></tr>
<tr><td><code id="calcLogLikelihood_+3A_theta">theta</code></td>
<td>
<p>theta values to use.</p>
</td></tr>
<tr><td><code id="calcLogLikelihood_+3A_resp">resp</code></td>
<td>
<p>the response data to use.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code><a href="#topic+calcLogLikelihood">calcLogLikelihood</a></code> returns values of log-likelihoods.
</p>


<h3>References</h3>

<p>Rasch, G. (1960). <em>Probabilistic models for some intelligence and attainment tests.</em>
Copenhagen: Danish Institute for Educational Research.
</p>
<p>Lord, F. M. (1952). A theory of test scores (Psychometric Monograph No. 7). Richmond, VA: Psychometric Corporation.
</p>
<p>Birnbaum, A. (1957). <em>Efficient design and use of tests of mental ability for various decision-making problems</em>
(Series Report No. 58-16. Project No. 7755-23).
Randolph Air Force Base, TX: USAF School of Aviation Medicine.
</p>
<p>Birnbaum, A. (1958). <em>On the estimation of mental ability</em>
(Series Report No. 15. Project No. 7755-23).
Randolph Air Force Base, TX: USAF School of Aviation Medicine.
</p>
<p>Birnbaum, A. (1958). <em>Further considerations of efficiency in tests of a mental ability</em>
(Series Report No. 17. Project No. 7755-23).
Randolph Air Force Base, TX: USAF School of Aviation Medicine.
</p>
<p>Birnbaum, A. (1968). Some latent trait models and their use in inferring an examinee's ability.
In Lord, F. M., Novick, M. R. (eds.), <em>Statistical Theories of Mental Test Scores</em>, 397-479.
Reading, MA: Addison-Wesley.
</p>
<p>Masters, G. N. (1982). A Rasch model for partial credit scoring.
<em>Psychometrika, 47</em>(2), 149-174.
</p>
<p>Andrich, D. (1978). A rating formulation for ordered response categories.
<em>Psychometrika, 43</em>(4), 561-573.
</p>
<p>Muraki, E. (1992). A generalized partial credit model: Application of an EM algorithm.
<em>Applied Psychological Measurement, 16</em>(2), 159-176.
</p>
<p>Samejima, F. (1969). Estimation of latent ability using a response pattern of graded scores.
<em>Psychometrika Monograph, 17</em>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>j_pool   &lt;- calcLogLikelihood(itempool_science, seq(-3, 3, 1), 0)

</code></pre>

<hr>
<h2 id='calcProb-methods'>Calculate item response probabilities</h2><span id='topic+calcProb-methods'></span><span id='topic+calcProb'></span><span id='topic+calcProb+2Citem_1PL+2Cnumeric-method'></span><span id='topic+calcProb+2Citem_2PL+2Cnumeric-method'></span><span id='topic+calcProb+2Citem_3PL+2Cnumeric-method'></span><span id='topic+calcProb+2Citem_PC+2Cnumeric-method'></span><span id='topic+calcProb+2Citem_GPC+2Cnumeric-method'></span><span id='topic+calcProb+2Citem_GR+2Cnumeric-method'></span><span id='topic+calcProb+2Citem_pool+2Cnumeric-method'></span><span id='topic+calcProb+2Citem_1PL+2Cmatrix-method'></span><span id='topic+calcProb+2Citem_2PL+2Cmatrix-method'></span><span id='topic+calcProb+2Citem_3PL+2Cmatrix-method'></span><span id='topic+calcProb+2Citem_PC+2Cmatrix-method'></span><span id='topic+calcProb+2Citem_GPC+2Cmatrix-method'></span><span id='topic+calcProb+2Citem_GR+2Cmatrix-method'></span><span id='topic+calcProb+2Citem_pool+2Cmatrix-method'></span><span id='topic+calcProb+2Citem_pool_cluster+2Cnumeric-method'></span>

<h3>Description</h3>

<p><code><a href="#topic+calcProb">calcProb</a></code> is a function to calculate item response probabilities.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>calcProb(object, theta)

## S4 method for signature 'item_1PL,numeric'
calcProb(object, theta)

## S4 method for signature 'item_2PL,numeric'
calcProb(object, theta)

## S4 method for signature 'item_3PL,numeric'
calcProb(object, theta)

## S4 method for signature 'item_PC,numeric'
calcProb(object, theta)

## S4 method for signature 'item_GPC,numeric'
calcProb(object, theta)

## S4 method for signature 'item_GR,numeric'
calcProb(object, theta)

## S4 method for signature 'item_pool,numeric'
calcProb(object, theta)

## S4 method for signature 'item_1PL,matrix'
calcProb(object, theta)

## S4 method for signature 'item_2PL,matrix'
calcProb(object, theta)

## S4 method for signature 'item_3PL,matrix'
calcProb(object, theta)

## S4 method for signature 'item_PC,matrix'
calcProb(object, theta)

## S4 method for signature 'item_GPC,matrix'
calcProb(object, theta)

## S4 method for signature 'item_GR,matrix'
calcProb(object, theta)

## S4 method for signature 'item_pool,matrix'
calcProb(object, theta)

## S4 method for signature 'item_pool_cluster,numeric'
calcProb(object, theta)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="calcProb-methods_+3A_object">object</code></td>
<td>
<p>an <code><a href="#topic+item">item</a></code> or an <code><a href="#topic+item_pool-class">item_pool</a></code> object.</p>
</td></tr>
<tr><td><code id="calcProb-methods_+3A_theta">theta</code></td>
<td>
<p>theta values to use.</p>
</td></tr>
</table>


<h3>Value</h3>


<dl>
<dt><code><a href="#topic+item">item</a></code> object:</dt><dd><p><code><a href="#topic+calcProb">calcProb</a></code> returns a (<em>nq</em>, <em>ncat</em>) matrix of probability values.</p>
</dd>
<dt><code><a href="#topic+item_pool-class">item_pool</a></code> object:</dt><dd><p><code><a href="#topic+calcProb">calcProb</a></code> returns a length <em>ni</em> list, each containing a matrix of probability values.</p>
</dd>
</dl>


<dl>
<dt><em>notations</em></dt><dd>
<ul>
<li><p><em>nq</em> denotes the number of theta values.
</p>
</li>
<li><p><em>ncat</em> denotes the number of response categories.
</p>
</li>
<li><p><em>ni</em> denotes the number of items in the <code><a href="#topic+item_pool-class">item_pool</a></code> object.
</p>
</li></ul>
</dd>
</dl>



<h3>References</h3>

<p>Rasch, G. (1960). <em>Probabilistic models for some intelligence and attainment tests.</em>
Copenhagen: Danish Institute for Educational Research.
</p>
<p>Lord, F. M. (1952). A theory of test scores (Psychometric Monograph No. 7). Richmond, VA: Psychometric Corporation.
</p>
<p>Birnbaum, A. (1957). <em>Efficient design and use of tests of mental ability for various decision-making problems</em>
(Series Report No. 58-16. Project No. 7755-23).
Randolph Air Force Base, TX: USAF School of Aviation Medicine.
</p>
<p>Birnbaum, A. (1958). <em>On the estimation of mental ability</em>
(Series Report No. 15. Project No. 7755-23).
Randolph Air Force Base, TX: USAF School of Aviation Medicine.
</p>
<p>Birnbaum, A. (1958). <em>Further considerations of efficiency in tests of a mental ability</em>
(Series Report No. 17. Project No. 7755-23).
Randolph Air Force Base, TX: USAF School of Aviation Medicine.
</p>
<p>Birnbaum, A. (1968). Some latent trait models and their use in inferring an examinee's ability.
In Lord, F. M., Novick, M. R. (eds.), <em>Statistical Theories of Mental Test Scores</em>, 397-479.
Reading, MA: Addison-Wesley.
</p>
<p>Masters, G. N. (1982). A Rasch model for partial credit scoring.
<em>Psychometrika, 47</em>(2), 149-174.
</p>
<p>Andrich, D. (1978). A rating formulation for ordered response categories.
<em>Psychometrika, 43</em>(4), 561-573.
</p>
<p>Muraki, E. (1992). A generalized partial credit model: Application of an EM algorithm.
<em>Applied Psychological Measurement, 16</em>(2), 159-176.
</p>
<p>Samejima, F. (1969). Estimation of latent ability using a response pattern of graded scores.
<em>Psychometrika Monograph, 17</em>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>item_1      &lt;- new("item_1PL", difficulty = 0.5)
item_2      &lt;- new("item_2PL", slope = 1.0, difficulty = 0.5)
item_3      &lt;- new("item_3PL", slope = 1.0, difficulty = 0.5, guessing = 0.2)
item_4      &lt;- new("item_PC", threshold = c(-1, 0, 1), ncat = 4)
item_5      &lt;- new("item_GPC", slope = 1.2, threshold = c(-0.8, -1.0, 0.5), ncat = 4)
item_6      &lt;- new("item_GR", slope = 0.9, category = c(-1, 0, 1), ncat = 4)

prob_item_1 &lt;- calcProb(item_1, seq(-3, 3, 1))
prob_item_2 &lt;- calcProb(item_2, seq(-3, 3, 1))
prob_item_3 &lt;- calcProb(item_3, seq(-3, 3, 1))
prob_item_4 &lt;- calcProb(item_4, seq(-3, 3, 1))
prob_item_5 &lt;- calcProb(item_5, seq(-3, 3, 1))
prob_item_6 &lt;- calcProb(item_6, seq(-3, 3, 1))
prob_pool   &lt;- calcProb(itempool_science, seq(-3, 3, 1))

</code></pre>

<hr>
<h2 id='checkConstraints'>Check the consistency of constraints and item usage</h2><span id='topic+checkConstraints'></span>

<h3>Description</h3>

<p>Check the consistency of constraints and item usage.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>checkConstraints(constraints, usage_matrix, true_theta = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="checkConstraints_+3A_constraints">constraints</code></td>
<td>
<p>A <code><a href="#topic+constraints-class">constraints</a></code> object generated by <code><a href="#topic+loadConstraints">loadConstraints</a></code>.</p>
</td></tr>
<tr><td><code id="checkConstraints_+3A_usage_matrix">usage_matrix</code></td>
<td>
<p>A matrix of item usage data from <code><a href="#topic+Shadow">Shadow</a></code>.</p>
</td></tr>
<tr><td><code id="checkConstraints_+3A_true_theta">true_theta</code></td>
<td>
<p>A vector of true theta values.</p>
</td></tr>
</table>

<hr>
<h2 id='config_Shadow-class'>Create a config_Shadow object</h2><span id='topic+config_Shadow-class'></span><span id='topic+createShadowTestConfig'></span>

<h3>Description</h3>

<p><code><a href="#topic+createShadowTestConfig">createShadowTestConfig</a></code> is a config function to create a <code><a href="#topic+config_Shadow-class">config_Shadow</a></code> object for Shadow test assembly.
Default values are used for any unspecified parameters/slots.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>createShadowTestConfig(
  item_selection = NULL,
  content_balancing = NULL,
  MIP = NULL,
  MCMC = NULL,
  exclude_policy = NULL,
  refresh_policy = NULL,
  exposure_control = NULL,
  stopping_criterion = NULL,
  interim_theta = NULL,
  final_theta = NULL,
  theta_grid = seq(-4, 4, 0.1)
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="config_Shadow-class_+3A_item_selection">item_selection</code></td>
<td>
<p>a named list containing item selection criteria.
</p>

<ul>
<li><p><code>method</code> the type of selection criteria. Accepts <code>MFI, MPWI, FB, EB, GFI</code>. (default = <code>MFI</code>)
</p>
</li>
<li><p><code>info_type</code> the type of information. Accepts <code>FISHER</code>. (default = <code>FISHER</code>)
</p>
</li>
<li><p><code>initial_theta</code> (optional) initial theta values to use.
</p>
</li>
<li><p><code>fixed_theta</code> (optional) fixed theta values to use throughout all item positions.
</p>
</li>
<li><p><code>target_value</code> (optional) the target value to use for <code>method = 'GFI'</code>.
</p>
</li></ul>
</td></tr>
<tr><td><code id="config_Shadow-class_+3A_content_balancing">content_balancing</code></td>
<td>
<p>a named list containing content balancing options.
</p>

<ul>
<li><p><code>method</code> the type of balancing method. Accepts <code>NONE, STA</code>. (default = <code>STA</code>)
</p>
</li></ul>
</td></tr>
<tr><td><code id="config_Shadow-class_+3A_mip">MIP</code></td>
<td>
<p>a named list containing solver options.
</p>

<ul>
<li><p><code>solver</code> the type of solver. Accepts <code>Rsymphony, gurobi, lpSolve, Rglpk</code>. (default = <code>LPSOLVE</code>)
</p>
</li>
<li><p><code>verbosity</code> verbosity level of the solver. (default = <code>-2</code>)
</p>
</li>
<li><p><code>time_limit</code> time limit in seconds. Used in solvers <code>Rsymphony, gurobi, Rglpk</code>. (default = <code>60</code>)
</p>
</li>
<li><p><code>gap_limit</code> search termination criterion. Gap limit in relative scale passed onto the solver. Used in solver <code>gurobi</code>. (default = <code>.05</code>)
</p>
</li>
<li><p><code>gap_limit_abs</code> search termination criterion. Gap limit in absolute scale passed onto the solver. Used in solvers <code>Rsymphony</code>. (default = <code>0.05</code>)
</p>
</li>
<li><p><code>obj_tol</code> search termination criterion. The lower bound to use on the minimax deviation variable. Used when <code>item_selection$method</code> is <code>GFI</code>, and ignored otherwise. (default = <code>0.05</code>)
</p>
</li>
<li><p><code>retry</code> number of times to retry running the solver if the solver returns no solution. Some solvers incorrectly return no solution even when a solution exists. This is the number of attempts to verify that the problem is indeed infeasible in such cases. Set to <code>0</code> to not retry. (default = <code>5</code>)
</p>
</li></ul>
</td></tr>
<tr><td><code id="config_Shadow-class_+3A_mcmc">MCMC</code></td>
<td>
<p>a named list containing Markov-chain Monte Carlo configurations for obtaining posterior samples.
</p>

<ul>
<li><p><code>burn_in</code> the number of chains from the start to discard. (default = <code>100</code>)
</p>
</li>
<li><p><code>post_burn_in</code> the number of chains to use after discarding the first <code>burn_in</code> chains. (default = <code>500</code>)
</p>
</li>
<li><p><code>thin</code> thinning interval to apply. <code>1</code> represents no thinning. (default = <code>1</code>)
</p>
</li>
<li><p><code>jump_factor</code> the jump (scaling) factor for the proposal distribution. <code>1</code> represents no jumping. (default = <code>2.4</code>)
</p>
</li></ul>
</td></tr>
<tr><td><code id="config_Shadow-class_+3A_exclude_policy">exclude_policy</code></td>
<td>
<p>a named list containing the exclude policy for use with the <code>exclude</code> argument in <code><a href="#topic+Shadow">Shadow</a></code>.
</p>

<ul>
<li><p><code>method</code> the type of policy. Accepts <code>HARD, SOFT</code>. (default = <code>HARD</code>)
</p>
</li>
<li><p><code>M</code> the Big M penalty to use on item information. Used in the <code>SOFT</code> method.
</p>
</li></ul>
</td></tr>
<tr><td><code id="config_Shadow-class_+3A_refresh_policy">refresh_policy</code></td>
<td>
<p>a named list containing the refresh policy for when to obtain a new shadow test.
</p>

<ul>
<li><p><code>method</code> the type of policy. Accepts <code>ALWAYS, POSITION, INTERVAL, THRESHOLD, INTERVAL-THRESHOLD, STIMULUS, SET, PASSAGE</code>. (default = <code>ALWAYS</code>)
</p>
</li>
<li><p><code>interval</code> used in methods <code>INTERVAL, INTERVAL-THRESHOLD</code>. Set to 1 to refresh at each position, 2 to refresh at every two positions, and so on. (default = <code>1</code>)
</p>
</li>
<li><p><code>threshold</code> used in methods <code>THRESHOLD, INTERVAL-THRESHOLD</code>. The absolute change in between interim theta estimates to trigger the refresh. (default = <code>0.1</code>)
</p>
</li>
<li><p><code>position</code> used in methods <code>POSITION</code>. Item positions to trigger the refresh. (default = <code>1</code>)
</p>
</li></ul>
</td></tr>
<tr><td><code id="config_Shadow-class_+3A_exposure_control">exposure_control</code></td>
<td>
<p>a named list containing exposure control settings.
</p>

<ul>
<li><p><code>method</code> the type of exposure control method. Accepts <code>NONE, ELIGIBILITY, BIGM, BIGM-BAYESIAN</code>. (default = <code>ELIGIBILITY</code>)
</p>
</li>
<li><p><code>M</code> used in methods <code>BIGM, BIGM-BAYESIAN</code>. the Big M penalty to use on item information.
</p>
</li>
<li><p><code>max_exposure_rate</code> target exposure rates for each segment. (default = <code>rep(0.25, 7)</code>)
</p>
</li>
<li><p><code>acceleration_factor</code> the acceleration factor to apply. (default = <code>1</code>)
</p>
</li>
<li><p><code>n_segment</code> the number of theta segments to use. (default = <code>7</code>)
</p>
</li>
<li><p><code>first_segment</code> (optional) the theta segment assumed at the beginning of test for all participants.
</p>
</li>
<li><p><code>segment_cut</code> theta segment cuts. (default = <code>c(-Inf, seq(-2.5, 2.5, 1), Inf)</code>)
</p>
</li>
<li><p><code>initial_eligibility_stats</code> (optional) initial eligibility statistics to use.
</p>
</li>
<li><p><code>fading_factor</code> the fading factor to apply. (default = <code>.999</code>)
</p>
</li>
<li><p><code>diagnostic_stats</code> set to <code>TRUE</code> to generate segment-wise diagnostic statistics. (default = <code>FALSE</code>)
</p>
</li></ul>
</td></tr>
<tr><td><code id="config_Shadow-class_+3A_stopping_criterion">stopping_criterion</code></td>
<td>
<p>a named list containing stopping criterion.
</p>

<ul>
<li><p><code>method</code> the type of stopping criterion. Accepts <code>FIXED</code>. (default = <code>FIXED</code>)
</p>
</li>
<li><p><code>test_length</code> test length.
</p>
</li>
<li><p><code>min_ni</code> the maximum number of items to administer.
</p>
</li>
<li><p><code>max_ni</code> the minimum number of items to administer.
</p>
</li>
<li><p><code>se_threshold</code> standard error threshold. Item administration is stopped when theta estimate standard error becomes lower than this value.
</p>
</li></ul>
</td></tr>
<tr><td><code id="config_Shadow-class_+3A_interim_theta">interim_theta</code></td>
<td>
<p>a named list containing interim theta estimation options.
</p>

<ul>
<li><p><code>method</code> the type of estimation. Accepts <code>EAP, MLE, MLEF, EB, FB</code>. (default = <code>EAP</code>)
</p>
</li>
<li><p><code>shrinkage_correction</code> set <code>TRUE</code> to apply shrinkage correction. Used when <code>method</code> is <code>EAP</code>. (default = <code>FALSE</code>)
</p>
</li>
<li><p><code>prior_dist</code> the type of prior distribution. Accepts <code>NORMAL, UNIFORM</code>. (default = <code>NORMAL</code>)
</p>
</li>
<li><p><code>prior_par</code> distribution parameters for <code>prior_dist</code>. (default = <code>c(0, 1)</code>)
</p>
</li>
<li><p><code>bound_ML</code> theta bound in <code>c(lower_bound, upper_bound)</code> format. Used when <code>method</code> is <code>MLE</code>. (default = <code>-4, 4</code>)
</p>
</li>
<li><p><code>truncate_ML</code> set <code>TRUE</code> to truncate ML estimate within <code>bound_ML</code>. (default = <code>FALSE</code>)
</p>
</li>
<li><p><code>max_iter</code> maximum number of Newton-Raphson iterations. Used when <code>method</code> is <code>MLE</code>. (default = <code>50</code>)
</p>
</li>
<li><p><code>crit</code> convergence criterion. Used when <code>method</code> is <code>MLE</code>. (default = <code>1e-03</code>)
</p>
</li>
<li><p><code>max_change</code> maximum change in ML estimates between iterations. Changes exceeding this value is clipped to this value. Used when <code>method</code> is <code>MLE</code>. (default = <code>1.0</code>)
</p>
</li>
<li><p><code>use_step_size</code> set <code>TRUE</code> to use <code>step_size</code>. Used when <code>method</code> is <code>MLE</code> or <code>MLEF</code>. (default = <code>FALSE</code>)
</p>
</li>
<li><p><code>step_size</code> upper bound to impose on the absolute change in initial theta and estimated theta. Absolute changes exceeding this value will be capped to <code>step_size</code>. Used when <code>method</code> is <code>MLE</code> or <code>MLEF</code>. (default = <code>0.5</code>)
</p>
</li>
<li><p><code>do_Fisher</code> set <code>TRUE</code> to use Fisher's method of scoring. Used when <code>method</code> is <code>MLE</code>. (default = <code>TRUE</code>)
</p>
</li>
<li><p><code>fence_slope</code> slope parameter to use for <code>method = 'MLEF'</code>. This must have two values in total, for the lower and upper bound item respectively. Use one value to use the same value for both bounds. (default = <code>5</code>)
</p>
</li>
<li><p><code>fence_difficulty</code> difficulty parameters to use for <code>method = 'MLEF'</code>. This must have two values in total, for the lower and upper bound item respectively. (default = <code>c(-5, 5)</code>)
</p>
</li>
<li><p><code>hand_scored_attribute</code> (optional) the item attribute name for whether each item is hand-scored or not. The attribute should have <code>TRUE</code> (hand-scored) and <code>FALSE</code> (machine-scored) values. If a hand-scored item is administered to an examinee, the previous interim theta (or the starting theta if this occurs for the first item) is reused without updating the estimate.
</p>
</li></ul>
</td></tr>
<tr><td><code id="config_Shadow-class_+3A_final_theta">final_theta</code></td>
<td>
<p>a named list containing final theta estimation options.
</p>

<ul>
<li><p><code>method</code> the type of estimation. Accepts <code>EAP, MLE, MLEF, EB, FB</code>. (default = <code>EAP</code>)
</p>
</li>
<li><p><code>shrinkage_correction</code> set <code>TRUE</code> to apply shrinkage correction. Used when <code>method</code> is <code>EAP</code>. (default = <code>FALSE</code>)
</p>
</li>
<li><p><code>prior_dist</code> the type of prior distribution. Accepts <code>NORMAL, UNIFORM</code>. (default = <code>NORMAL</code>)
</p>
</li>
<li><p><code>prior_par</code> distribution parameters for <code>prior_dist</code>. (default = <code>c(0, 1)</code>)
</p>
</li>
<li><p><code>bound_ML</code> theta bound in <code>c(lower_bound, upper_bound)</code> format. Used when <code>method</code> is <code>MLE</code>. (default = <code>-4, 4</code>)
</p>
</li>
<li><p><code>truncate_ML</code> set <code>TRUE</code> to truncate ML estimate within <code>bound_ML</code>. (default = <code>FALSE</code>)
</p>
</li>
<li><p><code>max_iter</code> maximum number of Newton-Raphson iterations. Used when <code>method</code> is <code>MLE</code>. (default = <code>50</code>)
</p>
</li>
<li><p><code>crit</code> convergence criterion. Used when <code>method</code> is <code>MLE</code>. (default = <code>1e-03</code>)
</p>
</li>
<li><p><code>max_change</code> maximum change in ML estimates between iterations. Changes exceeding this value is clipped to this value. Used when <code>method</code> is <code>MLE</code>. (default = <code>1.0</code>)
</p>
</li>
<li><p><code>use_step_size</code> set <code>TRUE</code> to use <code>step_size</code>. Used when <code>method</code> is <code>MLE</code> or <code>MLEF</code>.  (default = <code>FALSE</code>)
</p>
</li>
<li><p><code>step_size</code> upper bound to impose on the absolute change in initial theta and estimated theta. Absolute changes exceeding this value will be capped to <code>step_size</code>. Used when <code>method</code> is <code>MLE</code> or <code>MLEF</code>. (default = <code>0.5</code>)
</p>
</li>
<li><p><code>do_Fisher</code> set <code>TRUE</code> to use Fisher's method of scoring. Used when <code>method</code> is <code>MLE</code>. (default = <code>TRUE</code>)
</p>
</li>
<li><p><code>fence_slope</code> slope parameter to use for <code>method = 'MLEF'</code>. This must have two values in total, for the lower and upper bound item respectively. Use one value to use the same value for both bounds. (default = <code>5</code>)
</p>
</li>
<li><p><code>fence_difficulty</code> difficulty parameters to use for <code>method = 'MLEF'</code>. This must have two values in total, for the lower and upper bound item respectively. (default = <code>c(-5, 5)</code>)
</p>
</li></ul>
</td></tr>
<tr><td><code id="config_Shadow-class_+3A_theta_grid">theta_grid</code></td>
<td>
<p>the theta grid to use as quadrature points.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>cfg1 &lt;- createShadowTestConfig(refresh_policy = list(
  method = "STIMULUS"
))
cfg2 &lt;- createShadowTestConfig(refresh_policy = list(
  method = "POSITION",
  position = c(1, 5, 9)
))
</code></pre>

<hr>
<h2 id='config_Static-class'>Create a config_Static object</h2><span id='topic+config_Static-class'></span><span id='topic+createStaticTestConfig'></span>

<h3>Description</h3>

<p><code><a href="#topic+createStaticTestConfig">createStaticTestConfig</a></code> is a config function to create a <code><a href="#topic+config_Static-class">config_Static</a></code> object for Static (fixed-form) test assembly.
Default values are used for any unspecified parameters/slots.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>createStaticTestConfig(item_selection = NULL, MIP = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="config_Static-class_+3A_item_selection">item_selection</code></td>
<td>
<p>a named list containing item selection criteria.
</p>

<ul>
<li><p><code>method</code> the type of selection criteria. Accepts <code>MAXINFO, TIF, TCC</code>. (default = <code>MAXINFO</code>)
</p>
</li>
<li><p><code>info_type</code> the type of information. Accepts <code>FISHER</code>. (default = <code>FISHER</code>)
</p>
</li>
<li><p><code>target_location</code> a numeric vector containing the locations of target theta points. (e.g. <code>c(-1, 0, 1)</code>) (default = <code>c(-1.2, 0, 1.2)</code>)
</p>
</li>
<li><p><code>target_value</code> a numeric vector containing the target values at each theta location. This should have the same length with <code>target_location</code>. Ignored if method is <code>MAXINFO</code>. (default = <code>NULL</code>)
</p>
</li>
<li><p><code>target_weight</code> a numeric vector containing the weights for each theta location. This should have the same length with <code>target_location</code>. (default = <code>rep(1, length(target_location))</code>
</p>
</li></ul>
</td></tr>
<tr><td><code id="config_Static-class_+3A_mip">MIP</code></td>
<td>
<p>a named list containing solver options.
</p>

<ul>
<li><p><code>solver</code> the type of solver. Accepts <code>Rsymphony, gurobi, lpSolve, Rglpk</code>. (default = <code>LPSOLVE</code>)
</p>
</li>
<li><p><code>verbosity</code> verbosity level of the solver. (default = <code>-2</code>)
</p>
</li>
<li><p><code>time_limit</code> time limit in seconds. Used in solvers <code>Rsymphony, gurobi, Rglpk</code>. (default = <code>60</code>)
</p>
</li>
<li><p><code>gap_limit</code> search termination criterion. Gap limit in relative scale passed onto the solver. Used in solver <code>gurobi</code>. (default = <code>.05</code>)
</p>
</li>
<li><p><code>gap_limit_abs</code> search termination criterion. Gap limit in absolute scale passed onto the solver. Used in solvers <code>Rsymphony</code>. (default = <code>0.05</code>)
</p>
</li>
<li><p><code>obj_tol</code> search termination criterion. The lower bound to use on the minimax deviation variable. Used when <code>item_selection$method</code> is <code>TIF</code> or <code>TCC</code>. (default = <code>0.05</code>)
</p>
</li>
<li><p><code>retry</code> number of times to retry running the solver if the solver returns no solution. Some solvers incorrectly return no solution even when a solution exists. This is the number of attempts to verify that the problem is indeed infeasible in such cases. Set to <code>0</code> to not retry. (default = <code>5</code>)
</p>
</li></ul>
</td></tr>
</table>


<h3>Value</h3>

<p><code><a href="#topic+createStaticTestConfig">createStaticTestConfig</a></code> returns a <code><a href="#topic+config_Static-class">config_Static</a></code> object. This object is used in <code><a href="#topic+Static">Static</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>cfg1 &lt;- createStaticTestConfig(
  list(
    method = "MAXINFO",
    info_type = "FISHER",
    target_location = c(-1, 0, 1),
    target_weight = c(1, 1, 1)
  )
)

cfg2 &lt;- createStaticTestConfig(
  list(
    method = "TIF",
    info_type = "FISHER",
    target_location = c(-1, 0, 1),
    target_weight = c(1, 1, 1),
    target_value = c(8, 10, 12)
  )
)

cfg3 &lt;- createStaticTestConfig(
  list(
    method = "TCC",
    info_type = "FISHER",
    target_location = c(-1, 0, 1),
    target_weight = c(1, 1, 1),
    target_value = c(10, 15, 20)
  )
)
</code></pre>

<hr>
<h2 id='constraint-class'>Class 'constraint': a single constraint</h2><span id='topic+constraint-class'></span>

<h3>Description</h3>

<p><code><a href="#topic+constraint-class">constraint</a></code> is an S4 class to represent a single constraint.
</p>


<h3>Slots</h3>


<dl>
<dt><code>constraint</code></dt><dd><p>the numeric index of the constraint.</p>
</dd>
<dt><code>constraint_id</code></dt><dd><p>the character ID of the constraint.</p>
</dd>
<dt><code>nc</code></dt><dd><p>the number of MIP-format constraints translated from this constraint.</p>
</dd>
<dt><code>mat,dir,rhs</code></dt><dd><p>these represent MIP-format constraints. A single MIP-format constraint is associated with a row in <code>mat</code>, a value in <code>rhs</code>, and a value in <code>dir</code>.
</p>

<ul>
<li><p>the <em>i</em>-th row of <code>mat</code> represents LHS coefficients to use on decision variables in the <em>i</em>-th MIP-format constraint.
</p>
</li>
<li><p>the <em>i</em>-th value of <code>rhs</code> represents RHS values to use in the <em>i</em>-th MIP-format constraint.
</p>
</li>
<li><p>the <em>i</em>-th value of <code>dir</code> represents the imposed constraint between LHS and RHS.
</p>
</li></ul>
</dd>
<dt><code>suspend</code></dt><dd><p><code>TRUE</code> if the constraint is not to be imposed.</p>
</dd>
</dl>

<hr>
<h2 id='constraints-class'>Class 'constraints': a set of constraints</h2><span id='topic+constraints-class'></span>

<h3>Description</h3>

<p><code><a href="#topic+constraints-class">constraints</a></code> is an S4 class to represent a set of constraints and its associated objects.
</p>


<h3>Details</h3>

<p>See <code><a href="#topic+constraints-operators">constraints-operators</a></code> for object manipulation functions.
</p>


<h3>Slots</h3>


<dl>
<dt><code>constraints</code></dt><dd><p>a <code><a href="base.html#topic+data.frame">data.frame</a></code> containing the constraint specifications.</p>
</dd>
<dt><code>list_constraints</code></dt><dd><p>a list containing the <code><a href="#topic+constraint-class">constraint</a></code> object representation of each constraint.</p>
</dd>
<dt><code>pool</code></dt><dd><p>the <code><a href="#topic+item_pool-class">item_pool</a></code> object associated with the constraints.</p>
</dd>
<dt><code>item_attrib</code></dt><dd><p>the <code><a href="#topic+item_attrib-class">item_attrib</a></code> object associated with the constraints.</p>
</dd>
<dt><code>st_attrib</code></dt><dd><p>the <code><a href="#topic+st_attrib-class">st_attrib</a></code> object associated with the constraints.</p>
</dd>
<dt><code>test_length</code></dt><dd><p>the test length specified in the constraints.</p>
</dd>
<dt><code>nv</code></dt><dd><p>the number of decision variables. Equals <code>ni + ns</code>.</p>
</dd>
<dt><code>ni</code></dt><dd><p>the number of items to search from.</p>
</dd>
<dt><code>ns</code></dt><dd><p>the number of stimulus to search from.</p>
</dd>
<dt><code>id</code></dt><dd><p>the item/stimulus ID string of each item/stimulus.</p>
</dd>
<dt><code>index,mat,dir,rhs</code></dt><dd><p>these represent MIP-format constraints. A single MIP-format constraint is associated with a value in <code>index</code>, a row in <code>mat</code>, a value in <code>rhs</code>, and a value in <code>dir</code>.
</p>

<ul>
<li><p>the <em>i</em>-th value of <code>index</code> represents which constraint specification in the <code>constraints</code> argument it was translated from.
</p>
</li>
<li><p>the <em>i</em>-th row of <code>mat</code> represents LHS coefficients to use on decision variables in the <em>i</em>-th MIP-format constraint.
</p>
</li>
<li><p>the <em>i</em>-th value of <code>rhs</code> represents RHS values to use in the <em>i</em>-th MIP-format constraint.
</p>
</li>
<li><p>the <em>i</em>-th value of <code>dir</code> represents the imposed constraint between LHS and RHS.
</p>
</li></ul>
</dd>
<dt><code>set_based</code></dt><dd><p><code>TRUE</code> if the constraint is set-based. <code>FALSE</code> otherwise.</p>
</dd>
<dt><code>item_order</code></dt><dd><p>the item attribute of each item to use in imposing an item order constraint, if any.</p>
</dd>
<dt><code>item_order_by</code></dt><dd><p>the name of the item attribute to use in imposing an item order constraint, if any.</p>
</dd>
<dt><code>stim_order</code></dt><dd><p>the stimulus attribute of each stimulus to use in imposing a stimulus order constraint, if any.</p>
</dd>
<dt><code>stim_order_by</code></dt><dd><p>the name of the stimulus attribute to use in imposing a stimulus order constraint, if any.</p>
</dd>
<dt><code>item_index_by_stimulus</code></dt><dd><p>a list containing item indices of each stimulus.</p>
</dd>
<dt><code>stimulus_index_by_item</code></dt><dd><p>the stimulus indices of each item.</p>
</dd>
</dl>

<hr>
<h2 id='constraints-operators'>Basic operators for constraints objects</h2><span id='topic+constraints-operators'></span><span id='topic+subsetConstraints'></span><span id='topic+combineConstraints'></span><span id='topic++5B+2Cconstraints+2Cnumeric-method'></span><span id='topic++5B+2Cconstraints+2Cnumeric+2CANY+2CANY-method'></span><span id='topic+c+2Cconstraints-method'></span>

<h3>Description</h3>

<p>Create a subset of a <code><a href="#topic+constraints-class">constraints</a></code> object:
</p>

<ul>
<li><p><code>constraints[i]</code>
</p>
</li>
<li><p><code>subsetConstraints(constraints, 1:10)</code>
</p>
</li></ul>

<p>Combine two <code><a href="#topic+constraints-class">constraints</a></code> objects:
</p>

<ul>
<li><p><code>c(constraints1, constraints2)</code>
</p>
</li>
<li><p><code>combineConstraints(constraints1, constraints2)</code>
</p>
</li></ul>



<h3>Usage</h3>

<pre><code class='language-R'>subsetConstraints(x, i = NULL)

combineConstraints(x1, x2)

## S4 method for signature 'constraints,numeric'
x[i, j, ..., drop = TRUE]

## S4 method for signature 'constraints'
c(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="constraints-operators_+3A_x">x</code>, <code id="constraints-operators_+3A_x1">x1</code>, <code id="constraints-operators_+3A_x2">x2</code></td>
<td>
<p>a <code><a href="#topic+constraints-class">constraints</a></code> object.</p>
</td></tr>
<tr><td><code id="constraints-operators_+3A_i">i</code>, <code id="constraints-operators_+3A_j">j</code></td>
<td>
<p>indices to use in subsetting.</p>
</td></tr>
<tr><td><code id="constraints-operators_+3A_...">...</code></td>
<td>
<p>not used, exists for compatibility.</p>
</td></tr>
<tr><td><code id="constraints-operators_+3A_drop">drop</code></td>
<td>
<p>not used, exists for compatibility.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>c1 &lt;- constraints_science
c2 &lt;- c1[1:10]
c3 &lt;- c1[c(1, 11:36)] # keep constraint 1 for test length
c4 &lt;- c(c2, c3)

</code></pre>

<hr>
<h2 id='dataset_bayes'>Bayes dataset</h2><span id='topic+dataset_bayes'></span><span id='topic+itempool_bayes_data'></span><span id='topic+itempool_se_bayes_data'></span><span id='topic+itemattrib_bayes_data'></span><span id='topic+constraints_bayes_data'></span><span id='topic+itempool_bayes'></span><span id='topic+itemattrib_bayes'></span><span id='topic+constraints_bayes'></span>

<h3>Description</h3>

<p>Item-based example item pool with standard errors (320 items).
</p>


<h3>Details</h3>

<p>This pool is associated with the following objects:
</p>

<ul>
<li> <p><code>itempool_bayes</code> an <code><a href="#topic+item_pool-class">item_pool</a></code> object containing 320 items.
</p>
</li>
<li> <p><code>itemattrib_bayes</code> a <code><a href="#topic+item_attrib-class">item_attrib</a></code> object containing 5 item-level attributes.
</p>
</li>
<li> <p><code>constraints_bayes</code> a <code><a href="#topic+constraints-class">constraints</a></code> object containing 14 constraints.
</p>
</li></ul>

<p>Also, the following objects are intended for illustrating expected data structures.
</p>

<ul>
<li> <p><code>itempool_bayes_data</code> a <code><a href="base.html#topic+data.frame">data.frame</a></code> containing item parameters.
</p>
</li>
<li> <p><code>itempool_se_bayes_data</code> a <code><a href="base.html#topic+data.frame">data.frame</a></code> containing item parameter standard errors.
</p>
</li>
<li> <p><code>itemattrib_bayes_data</code> a <code><a href="base.html#topic+data.frame">data.frame</a></code> containing item attributes.
</p>
</li>
<li> <p><code>constraints_bayes_data</code> a <code><a href="base.html#topic+data.frame">data.frame</a></code> containing constraint specifications.
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>itempool_bayes    &lt;- loadItemPool(itempool_bayes_data, itempool_se_bayes_data)
itemattrib_bayes  &lt;- loadItemAttrib(itemattrib_bayes_data, itempool_bayes)
constraints_bayes &lt;- loadConstraints(constraints_bayes_data,
  itempool_bayes, itemattrib_bayes)

</code></pre>

<hr>
<h2 id='dataset_fatigue'>Fatigue dataset</h2><span id='topic+dataset_fatigue'></span><span id='topic+itempool_fatigue_data'></span><span id='topic+itemattrib_fatigue_data'></span><span id='topic+itemtext_fatigue_data'></span><span id='topic+constraints_fatigue_data'></span><span id='topic+resp_fatigue_data'></span><span id='topic+itempool_fatigue'></span><span id='topic+itemattrib_fatigue'></span><span id='topic+constraints_fatigue'></span>

<h3>Description</h3>

<p>Item-based example pool with item contents (95 items).
</p>


<h3>Details</h3>

<p>This pool is associated with the following objects:
</p>

<ul>
<li> <p><code>itempool_fatigue</code> an <code><a href="#topic+item_pool-class">item_pool</a></code> object containing 95 items.
</p>
</li>
<li> <p><code>itemattrib_fatigue</code> an <code><a href="#topic+item_attrib-class">item_attrib</a></code> object containing 7 item-level attributes.
</p>
</li>
<li> <p><code>constraints_fatigue</code> a <code><a href="#topic+constraints-class">constraints</a></code> object containing 111 constraints.
</p>
</li></ul>

<p>Also, the following objects are intended for illustrating expected data structures.
</p>

<ul>
<li> <p><code>itempool_fatigue_data</code> a <code><a href="base.html#topic+data.frame">data.frame</a></code> containing item parameters.
</p>
</li>
<li> <p><code>itemattrib_fatigue_data</code> a <code><a href="base.html#topic+data.frame">data.frame</a></code> containing item attributes.
</p>
</li>
<li> <p><code>itemtext_fatigue_data</code> a <code><a href="base.html#topic+data.frame">data.frame</a></code> containing item texts.
</p>
</li>
<li> <p><code>constraints_fatigue_data</code> a <code><a href="base.html#topic+data.frame">data.frame</a></code> containing constraint specifications.
</p>
</li>
<li> <p><code>resp_fatigue_data</code> a <code><a href="base.html#topic+data.frame">data.frame</a></code> containing raw response data.
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>itempool_fatigue   &lt;- loadItemPool(itempool_fatigue_data)
itemattrib_fatigue &lt;- loadItemAttrib(itemattrib_fatigue_data, itempool_fatigue)
constraints_fatigue &lt;- loadConstraints(constraints_fatigue_data,
  itempool_fatigue, itemattrib_fatigue)

</code></pre>

<hr>
<h2 id='dataset_reading'>Reading dataset</h2><span id='topic+dataset_reading'></span><span id='topic+itempool_reading_data'></span><span id='topic+itemattrib_reading_data'></span><span id='topic+stimattrib_reading_data'></span><span id='topic+constraints_reading_data'></span><span id='topic+itempool_reading'></span><span id='topic+itemattrib_reading'></span><span id='topic+stimattrib_reading'></span><span id='topic+constraints_reading'></span>

<h3>Description</h3>

<p>Stimulus-based example item pool (303 items, 35 stimuli).
</p>


<h3>Details</h3>

<p>This pool is associated with the following objects:
</p>

<ul>
<li> <p><code>itempool_reading</code> an <code><a href="#topic+item_pool-class">item_pool</a></code> object containing 303 items.
</p>
</li>
<li> <p><code>itemattrib_reading</code> an <code><a href="#topic+item_attrib-class">item_attrib</a></code> object containing 12 item-level attributes.
</p>
</li>
<li> <p><code>stimattrib_reading</code> a <code><a href="#topic+st_attrib-class">st_attrib</a></code> object containing 4 stimulus-level attributes.
</p>
</li>
<li> <p><code>constraints_reading</code> a <code><a href="#topic+constraints-class">constraints</a></code> object containing 18 constraints.
</p>
</li></ul>

<p>Also, the following objects are intended for illustrating expected data structures.
</p>

<ul>
<li> <p><code>itempool_reading_data</code> a <code><a href="base.html#topic+data.frame">data.frame</a></code> containing item parameters.
</p>
</li>
<li> <p><code>itemattrib_reading_data</code> a <code><a href="base.html#topic+data.frame">data.frame</a></code> containing item attributes.
</p>
</li>
<li> <p><code>stimattrib_reading_data</code> a <code><a href="base.html#topic+data.frame">data.frame</a></code> containing stimulus attributes.
</p>
</li>
<li> <p><code>constraints_reading_data</code> a <code><a href="base.html#topic+data.frame">data.frame</a></code> containing constraint specifications.
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>itempool_reading    &lt;- loadItemPool(itempool_reading_data)
itemattrib_reading  &lt;- loadItemAttrib(itemattrib_reading_data, itempool_reading)
stimattrib_reading  &lt;- loadStAttrib(stimattrib_reading_data, itemattrib_reading)
constraints_reading &lt;- loadConstraints(constraints_reading_data,
  itempool_reading, itemattrib_reading, stimattrib_reading)

</code></pre>

<hr>
<h2 id='dataset_science'>Science dataset</h2><span id='topic+dataset_science'></span><span id='topic+itempool_science_data'></span><span id='topic+itemattrib_science_data'></span><span id='topic+constraints_science_data'></span><span id='topic+itempool_science'></span><span id='topic+itemattrib_science'></span><span id='topic+constraints_science'></span>

<h3>Description</h3>

<p>Item-based example item pool (1000 items).
</p>


<h3>Details</h3>

<p>This pool is associated with the following objects:
</p>

<ul>
<li> <p><code>itempool_science</code> an <code><a href="#topic+item_pool-class">item_pool</a></code> object containing 1000 items.
</p>
</li>
<li> <p><code>itemattrib_science</code> an <code><a href="#topic+item_attrib-class">item_attrib</a></code> object containing 9 item-level attributes.
</p>
</li>
<li> <p><code>constraints_science</code> a <code><a href="#topic+constraints-class">constraints</a></code> object containing 36 constraints.
</p>
</li></ul>

<p>Also, the following objects are intended for illustrating expected data structures.
</p>

<ul>
<li> <p><code>itempool_science_data</code> a <code><a href="base.html#topic+data.frame">data.frame</a></code> containing item parameters.
</p>
</li>
<li> <p><code>itemattrib_science_data</code> a <code><a href="base.html#topic+data.frame">data.frame</a></code> containing item attributes.
</p>
</li>
<li> <p><code>constraints_science_data</code> a <code><a href="base.html#topic+data.frame">data.frame</a></code> containing constraint specifications.
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>itempool_science    &lt;- loadItemPool(itempool_science_data)
itemattrib_science  &lt;- loadItemAttrib(itemattrib_science_data, itempool_science)
constraints_science &lt;- loadConstraints(constraints_science_data,
  itempool_science, itemattrib_science)

</code></pre>

<hr>
<h2 id='detectBestSolver'>Detect best solver</h2><span id='topic+detectBestSolver'></span>

<h3>Description</h3>

<p>Detect best solver
</p>


<h3>Usage</h3>

<pre><code class='language-R'>detectBestSolver()
</code></pre>


<h3>Value</h3>

<p>the package name of the best available solver on the system.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>solver &lt;- detectBestSolver()
cfg &lt;- createStaticTestConfig(MIP = list(solver = solver))
cfg &lt;- createShadowTestConfig(MIP = list(solver = solver))

</code></pre>

<hr>
<h2 id='e_item'>(C++) Calculate expected scores</h2><span id='topic+e_item'></span><span id='topic+e_1pl'></span><span id='topic+e_2pl'></span><span id='topic+e_m_2pl'></span><span id='topic+e_3pl'></span><span id='topic+e_m_3pl'></span><span id='topic+e_pc'></span><span id='topic+e_gpc'></span><span id='topic+e_m_gpc'></span><span id='topic+e_gr'></span><span id='topic+e_m_gr'></span><span id='topic+array_e_1pl'></span><span id='topic+array_e_2pl'></span><span id='topic+array_e_3pl'></span><span id='topic+array_e_pc'></span><span id='topic+array_e_gpc'></span><span id='topic+array_e_gr'></span>

<h3>Description</h3>

<p><code>e_*()</code> and <code>array_e_*()</code> are C++ functions for calculating expected scores.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>e_1pl(x, b)

e_2pl(x, a, b)

e_m_2pl(x, a, d)

e_3pl(x, a, b, c)

e_m_3pl(x, a, d, c)

e_pc(x, b)

e_gpc(x, a, b)

e_m_gpc(x, a, d)

e_gr(x, a, b)

e_m_gr(x, a, d)

array_e_1pl(x, b)

array_e_2pl(x, a, b)

array_e_3pl(x, a, b, c)

array_e_pc(x, b)

array_e_gpc(x, a, b)

array_e_gr(x, a, b)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="e_item_+3A_x">x</code></td>
<td>
<p>the theta value. The number of columns should correspond to the number of dimensions.
For <code>array_*()</code> functions, the number of theta values must correspond to the number of rows.</p>
</td></tr>
<tr><td><code id="e_item_+3A_b">b</code>, <code id="e_item_+3A_d">d</code></td>
<td>
<p>the difficulty parameter. <code>b</code> is used for unidimensional items, and <code>d</code> is used for multidimensional items.</p>
</td></tr>
<tr><td><code id="e_item_+3A_a">a</code></td>
<td>
<p>the <em>a</em>-parameter.</p>
</td></tr>
<tr><td><code id="e_item_+3A_c">c</code></td>
<td>
<p>the <em>c</em>-parameter.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>e_*()</code> functions accept a single theta value, and <code>array_p_*()</code> functions accept multiple theta values.
</p>
<p>Supports unidimensional and multidimensional models.
</p>

<ul>
<li><p><code>e_1pl()</code>, <code>array_e_1pl()</code>: 1PL models
</p>
</li>
<li><p><code>e_2pl()</code>, <code>array_e_2pl()</code>: 2PL models
</p>
</li>
<li><p><code>e_3pl()</code>, <code>array_e_3pl()</code>: 3PL models
</p>
</li>
<li><p><code>e_pc()</code>, <code>array_e_pc()</code>: PC (partial credit) models
</p>
</li>
<li><p><code>e_gpc()</code>, <code>array_e_gpc()</code>: GPC (generalized partial credit) models
</p>
</li>
<li><p><code>e_gr()</code>, <code>array_e_gr()</code>: GR (graded response) models
</p>
</li>
<li><p><code>e_m_2pl()</code>, <code>array_e_m_2pl()</code>: multidimensional 2PL models
</p>
</li>
<li><p><code>e_m_3pl()</code>, <code>array_e_m_3pl()</code>: multidimensional 3PL models
</p>
</li>
<li><p><code>e_m_gpc()</code>, <code>array_e_m_gpc()</code>: multidimensional GPC models
</p>
</li>
<li><p><code>e_m_gr()</code>, <code>array_e_m_gr()</code>: multidimensional GR models
</p>
</li></ul>



<h3>References</h3>

<p>Rasch, G. (1960). <em>Probabilistic models for some intelligence and attainment tests.</em>
Copenhagen: Danish Institute for Educational Research.
</p>
<p>Lord, F. M. (1952). A theory of test scores (Psychometric Monograph No. 7). Richmond, VA: Psychometric Corporation.
</p>
<p>Birnbaum, A. (1957). <em>Efficient design and use of tests of mental ability for various decision-making problems</em>
(Series Report No. 58-16. Project No. 7755-23).
Randolph Air Force Base, TX: USAF School of Aviation Medicine.
</p>
<p>Birnbaum, A. (1958). <em>On the estimation of mental ability</em>
(Series Report No. 15. Project No. 7755-23).
Randolph Air Force Base, TX: USAF School of Aviation Medicine.
</p>
<p>Birnbaum, A. (1958). <em>Further considerations of efficiency in tests of a mental ability</em>
(Series Report No. 17. Project No. 7755-23).
Randolph Air Force Base, TX: USAF School of Aviation Medicine.
</p>
<p>Birnbaum, A. (1968). Some latent trait models and their use in inferring an examinee's ability.
In Lord, F. M., Novick, M. R. (eds.), <em>Statistical Theories of Mental Test Scores</em>, 397-479.
Reading, MA: Addison-Wesley.
</p>
<p>Masters, G. N. (1982). A Rasch model for partial credit scoring.
<em>Psychometrika, 47</em>(2), 149-174.
</p>
<p>Andrich, D. (1978). A rating formulation for ordered response categories.
<em>Psychometrika, 43</em>(4), 561-573.
</p>
<p>Muraki, E. (1992). A generalized partial credit model: Application of an EM algorithm.
<em>Applied Psychological Measurement, 16</em>(2), 159-176.
</p>
<p>Samejima, F. (1969). Estimation of latent ability using a response pattern of graded scores.
<em>Psychometrika Monograph, 17</em>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- 0.5

e_1pl(x, 1)
e_2pl(x, 1, 2)
e_3pl(x, 1, 2, 0.25)
e_pc(x, c(0, 1))
e_gpc(x, 2, c(0, 1))
e_gr(x, 2, c(0, 2))

x &lt;- matrix(seq(-3, 3, 1)) # three theta values, unidimensional

array_e_1pl(x, 1)
array_e_2pl(x, 1, 2)
array_e_3pl(x, 1, 2, 0.25)
array_e_pc(x, c(0, 1))
array_e_gpc(x, 2, c(0, 1))
array_e_gr(x, 2, c(0, 2))

</code></pre>

<hr>
<h2 id='eap'>Compute expected a posteriori estimates of theta</h2><span id='topic+eap'></span><span id='topic+eap+2Citem_pool-method'></span><span id='topic+EAP'></span><span id='topic+EAP+2Ctest-method'></span><span id='topic+EAP+2Ctest_cluster-method'></span>

<h3>Description</h3>

<p><code><a href="#topic+eap">eap</a></code> is a function to compute expected a posteriori estimates of theta.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>eap(
  object,
  select = NULL,
  resp,
  theta_grid = seq(-4, 4, 0.1),
  prior = rep(1/81, 81)
)

## S4 method for signature 'item_pool'
eap(
  object,
  select = NULL,
  resp,
  theta_grid = seq(-4, 4, 0.1),
  prior = rep(1/81, 81)
)

EAP(object, select = NULL, prior, reset_prior = FALSE)

## S4 method for signature 'test'
EAP(object, select = NULL, prior, reset_prior = FALSE)

## S4 method for signature 'test_cluster'
EAP(object, select = NULL, prior, reset_prior = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="eap_+3A_object">object</code></td>
<td>
<p>an <code><a href="#topic+item_pool-class">item_pool</a></code> object.</p>
</td></tr>
<tr><td><code id="eap_+3A_select">select</code></td>
<td>
<p>(optional) if item indices are supplied, only the specified items are used.</p>
</td></tr>
<tr><td><code id="eap_+3A_resp">resp</code></td>
<td>
<p>item response on all (or selected) items in the <code>object</code> argument. Can be a vector, a matrix, or a data frame. <code>length(resp)</code> or <code>ncol(resp)</code> must be equal to the number of all (or selected) items.</p>
</td></tr>
<tr><td><code id="eap_+3A_theta_grid">theta_grid</code></td>
<td>
<p>the theta grid to use as quadrature points. (default = <code>seq(-4, 4, .1)</code>)</p>
</td></tr>
<tr><td><code id="eap_+3A_prior">prior</code></td>
<td>
<p>a prior distribution, a numeric vector for a common prior or a matrix for individualized priors. (default = <code>rep(1 / 81, 81)</code>)</p>
</td></tr>
<tr><td><code id="eap_+3A_reset_prior">reset_prior</code></td>
<td>
<p>used for <code><a href="#topic+test_cluster-class">test_cluster</a></code> objects. If <code>TRUE</code>, reset the prior distribution for each <code><a href="#topic+test-class">test</a></code> object.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code><a href="#topic+eap">eap</a></code> returns a list containing estimated values.
</p>

<ul>
<li><p><code>th</code> theta value.
</p>
</li>
<li><p><code>se</code> standard error.
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>eap(itempool_fatigue, resp = resp_fatigue_data[10, ])
eap(itempool_fatigue, select = 1:20, resp = resp_fatigue_data[10, 1:20])

</code></pre>

<hr>
<h2 id='find_segment'>(C++) Classify theta values into segments using cutpoints</h2><span id='topic+find_segment'></span>

<h3>Description</h3>

<p><code>find_segment()</code> is a function to classify theta values into segments based on supplied cutpoints.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>find_segment(x, segment)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="find_segment_+3A_x">x</code></td>
<td>
<p>the theta value. This can be a vector.</p>
</td></tr>
<tr><td><code id="find_segment_+3A_segment">segment</code></td>
<td>
<p>segment cutpoints. Values of <code>-Inf, Inf</code> are not implied and must be explicitly supplied if intended.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>cuts &lt;- c(-Inf, -2, 0, 2, Inf)

find_segment(-3, cuts)
find_segment(-1, cuts)
find_segment(1, cuts)
find_segment(3, cuts)
find_segment(seq(-3, 3, 2), cuts)

</code></pre>

<hr>
<h2 id='getSolution'>Print solution items</h2><span id='topic+getSolution'></span><span id='topic+getSolution+2Clist-method'></span><span id='topic+getSolution+2Coutput_Static-method'></span>

<h3>Description</h3>

<p>Print solution items
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getSolution(object, examinee = NA, position = NA, index_only = TRUE)

## S4 method for signature 'list'
getSolution(object, examinee = NA, position = NA, index_only = TRUE)

## S4 method for signature 'output_Static'
getSolution(object, examinee = NA, position = NA, index_only = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getSolution_+3A_object">object</code></td>
<td>
<p>an <code><a href="#topic+output_Static-class">output_Static</a></code> object or an <code><a href="#topic+output_Shadow-class">output_Shadow</a></code> object.</p>
</td></tr>
<tr><td><code id="getSolution_+3A_examinee">examinee</code></td>
<td>
<p>(optional) the examinee index to display the solution. Used when the 'object' argument is an <code><a href="#topic+output_Shadow-class">output_Shadow</a></code> object.</p>
</td></tr>
<tr><td><code id="getSolution_+3A_position">position</code></td>
<td>
<p>(optional) if supplied, display the item attributes of the assembled test at that item position. If not supplied, display the item attributes of the administered items. Used when the 'object' argument is an <code><a href="#topic+output_Shadow-class">output_Shadow</a></code> object.</p>
</td></tr>
<tr><td><code id="getSolution_+3A_index_only">index_only</code></td>
<td>
<p>if <code>TRUE</code>, only print item indices. if <code>FALSE</code>, print all item attributes. (default = TRUE)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Item attributes of solution items.
</p>

<hr>
<h2 id='getSolutionAttributes'>Retrieve constraints-related attributes from solution</h2><span id='topic+getSolutionAttributes'></span>

<h3>Description</h3>

<p><code><a href="#topic+getSolutionAttributes">getSolutionAttributes</a></code> is a helper function to retrieve constraints-related attributes from a solution.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getSolutionAttributes(constraints, item_idx, all_values = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getSolutionAttributes_+3A_constraints">constraints</code></td>
<td>
<p>a <code><a href="#topic+constraints-class">constraints</a></code> object.</p>
</td></tr>
<tr><td><code id="getSolutionAttributes_+3A_item_idx">item_idx</code></td>
<td>
<p>item indices from a solution.</p>
</td></tr>
<tr><td><code id="getSolutionAttributes_+3A_all_values">all_values</code></td>
<td>
<p>if <code>TRUE</code>, return all values as-is without taking the mean when there are multiple values. If <code>FALSE</code>, return the mean when there are multiple values.
This has an effect when there is a constraint on items per stimulus, where there are multiple values of number of items per stimulus.
In this case, if <code>TRUE</code>, the number of items for every stimuli are returned as-is. If <code>FALSE</code>, the average number of items across stimuli is returned.
(default = <code>FALSE</code>)</p>
</td></tr>
</table>


<h3>Value</h3>


<ul>
<li><p>If <code>all_values == FALSE</code>, <code><a href="#topic+getSolutionAttributes">getSolutionAttributes</a></code> returns a <code><a href="base.html#topic+data.frame">data.frame</a></code> containing constraints data and their associated attributes.
</p>
</li>
<li><p>If <code>all_values == TRUE</code>, <code><a href="#topic+getSolutionAttributes">getSolutionAttributes</a></code> returns a <code><a href="base.html#topic+list">list</a></code> containing attributes associated to each constraint.
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>item_idx &lt;-
  c( 29,  33,  26,  36,  34,
    295, 289, 296, 291, 126,
    133, 124, 134, 129,  38,
     47,  39,  41,  46,  45,
    167, 166, 170, 168, 113,
    116, 119, 117, 118, 114)

getSolutionAttributes(constraints_reading, item_idx, FALSE)
getSolutionAttributes(constraints_reading, item_idx, TRUE)

</code></pre>

<hr>
<h2 id='h_item'>(C++) Calculate second derivative of log-likelihood</h2><span id='topic+h_item'></span><span id='topic+h_1pl'></span><span id='topic+h_2pl'></span><span id='topic+h_m_2pl'></span><span id='topic+h_3pl'></span><span id='topic+h_m_3pl'></span><span id='topic+h_pc'></span><span id='topic+h_gpc'></span><span id='topic+h_m_gpc'></span><span id='topic+h_gr'></span><span id='topic+h_m_gr'></span><span id='topic+array_h_1pl'></span><span id='topic+array_h_2pl'></span><span id='topic+array_h_3pl'></span><span id='topic+array_h_pc'></span><span id='topic+array_h_gpc'></span><span id='topic+array_h_gr'></span>

<h3>Description</h3>

<p><code>h_*()</code> and <code>array_h_*()</code> are C++ functions for calculating the second derivative of the log-likelihood function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>h_1pl(x, b, u)

h_2pl(x, a, b, u)

h_m_2pl(x, a, d, u)

h_3pl(x, a, b, c, u)

h_m_3pl(x, a, d, c, u)

h_pc(x, b, u)

h_gpc(x, a, b, u)

h_m_gpc(x, a, d, u)

h_gr(x, a, b, u)

h_m_gr(x, a, d, u)

array_h_1pl(x, b, u)

array_h_2pl(x, a, b, u)

array_h_3pl(x, a, b, c, u)

array_h_pc(x, b, u)

array_h_gpc(x, a, b, u)

array_h_gr(x, a, b, u)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="h_item_+3A_x">x</code></td>
<td>
<p>the theta value. The number of columns should correspond to the number of dimensions.
For <code>array_*()</code> functions, the number of theta values must correspond to the number of rows.</p>
</td></tr>
<tr><td><code id="h_item_+3A_b">b</code>, <code id="h_item_+3A_d">d</code></td>
<td>
<p>the difficulty parameter. <code>b</code> is used for unidimensional items, and <code>d</code> is used for multidimensional items.</p>
</td></tr>
<tr><td><code id="h_item_+3A_u">u</code></td>
<td>
<p>the response value.</p>
</td></tr>
<tr><td><code id="h_item_+3A_a">a</code></td>
<td>
<p>the <em>a</em>-parameter.</p>
</td></tr>
<tr><td><code id="h_item_+3A_c">c</code></td>
<td>
<p>the <em>c</em>-parameter.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>h_*()</code> functions accept a single theta value, and <code>array_h_*()</code> functions accept multiple theta values.
</p>
<p>Supports unidimensional and multidimensional models.
</p>

<ul>
<li><p><code>h_1pl()</code>, <code>array_h_1pl()</code>: 1PL models
</p>
</li>
<li><p><code>h_2pl()</code>, <code>array_h_2pl()</code>: 2PL models
</p>
</li>
<li><p><code>h_3pl()</code>, <code>array_h_3pl()</code>: 3PL models
</p>
</li>
<li><p><code>h_pc()</code>, <code>array_h_pc()</code>: PC (partial credit) models
</p>
</li>
<li><p><code>h_gpc()</code>, <code>array_h_gpc()</code>: GPC (generalized partial credit) models
</p>
</li>
<li><p><code>h_gr()</code>, <code>array_h_gr()</code>: GR (graded response) models
</p>
</li>
<li><p><code>h_m_2pl()</code>, <code>array_h_m_2pl()</code>: multidimensional 2PL models
</p>
</li>
<li><p><code>h_m_3pl()</code>, <code>array_h_m_3pl()</code>: multidimensional 3PL models
</p>
</li>
<li><p><code>h_m_gpc()</code>, <code>array_h_m_gpc()</code>: multidimensional GPC models
</p>
</li>
<li><p><code>h_m_gr()</code>, <code>array_h_m_gr()</code>: multidimensional GR models
</p>
</li></ul>



<h3>References</h3>

<p>Rasch, G. (1960). <em>Probabilistic models for some intelligence and attainment tests.</em>
Copenhagen: Danish Institute for Educational Research.
</p>
<p>Lord, F. M. (1952). A theory of test scores (Psychometric Monograph No. 7). Richmond, VA: Psychometric Corporation.
</p>
<p>Birnbaum, A. (1957). <em>Efficient design and use of tests of mental ability for various decision-making problems</em>
(Series Report No. 58-16. Project No. 7755-23).
Randolph Air Force Base, TX: USAF School of Aviation Medicine.
</p>
<p>Birnbaum, A. (1958). <em>On the estimation of mental ability</em>
(Series Report No. 15. Project No. 7755-23).
Randolph Air Force Base, TX: USAF School of Aviation Medicine.
</p>
<p>Birnbaum, A. (1958). <em>Further considerations of efficiency in tests of a mental ability</em>
(Series Report No. 17. Project No. 7755-23).
Randolph Air Force Base, TX: USAF School of Aviation Medicine.
</p>
<p>Birnbaum, A. (1968). Some latent trait models and their use in inferring an examinee's ability.
In Lord, F. M., Novick, M. R. (eds.), <em>Statistical Theories of Mental Test Scores</em>, 397-479.
Reading, MA: Addison-Wesley.
</p>
<p>Masters, G. N. (1982). A Rasch model for partial credit scoring.
<em>Psychometrika, 47</em>(2), 149-174.
</p>
<p>Andrich, D. (1978). A rating formulation for ordered response categories.
<em>Psychometrika, 43</em>(4), 561-573.
</p>
<p>Muraki, E. (1992). A generalized partial credit model: Application of an EM algorithm.
<em>Applied Psychological Measurement, 16</em>(2), 159-176.
</p>
<p>Samejima, F. (1969). Estimation of latent ability using a response pattern of graded scores.
<em>Psychometrika Monograph, 17</em>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>u &lt;- 1

x &lt;- 0.5
h_1pl(x, 1, u)
h_2pl(x, 1, 2, u)
h_3pl(x, 1, 2, 0.25, u)
h_pc(x, c(0, 1), u)
h_gpc(x, 2, c(0, 1), u)
h_gr(x, 2, c(0, 2), u)

x &lt;- matrix(seq(-3, 3, 1)) # three theta values, unidimensional
array_h_1pl(x, 1, u)
array_h_2pl(x, 1, 2, u)
array_h_3pl(x, 1, 2, 0.25, u)
array_h_pc(x, c(0, 1), u)
array_h_gpc(x, 2, c(0, 1), u)
array_h_gr(x, 2, c(0, 2), u)

</code></pre>

<hr>
<h2 id='info_item'>(C++) Calculate Fisher information</h2><span id='topic+info_item'></span><span id='topic+info_1pl'></span><span id='topic+info_2pl'></span><span id='topic+info_m_2pl'></span><span id='topic+dirinfo_m_2pl'></span><span id='topic+thisdirinfo_m_2pl'></span><span id='topic+info_3pl'></span><span id='topic+info_m_3pl'></span><span id='topic+dirinfo_m_3pl'></span><span id='topic+thisdirinfo_m_3pl'></span><span id='topic+info_pc'></span><span id='topic+info_gpc'></span><span id='topic+info_m_gpc'></span><span id='topic+dirinfo_m_gpc'></span><span id='topic+thisdirinfo_m_gpc'></span><span id='topic+info_gr'></span><span id='topic+info_m_gr'></span><span id='topic+dirinfo_m_gr'></span><span id='topic+thisdirinfo_m_gr'></span><span id='topic+array_info_1pl'></span><span id='topic+array_info_2pl'></span><span id='topic+array_info_m_2pl'></span><span id='topic+array_dirinfo_m_2pl'></span><span id='topic+array_thisdirinfo_m_2pl'></span><span id='topic+array_info_3pl'></span><span id='topic+array_info_m_3pl'></span><span id='topic+array_dirinfo_m_3pl'></span><span id='topic+array_thisdirinfo_m_3pl'></span><span id='topic+array_info_pc'></span><span id='topic+array_info_gpc'></span><span id='topic+array_info_m_gpc'></span><span id='topic+array_dirinfo_m_gpc'></span><span id='topic+array_thisdirinfo_m_gpc'></span><span id='topic+array_info_gr'></span><span id='topic+array_info_m_gr'></span><span id='topic+array_dirinfo_m_gr'></span><span id='topic+array_thisdirinfo_m_gr'></span>

<h3>Description</h3>

<p><code>info_*()</code> and <code>array_info_*()</code> are functions for calculating Fisher information.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>info_1pl(x, b)

info_2pl(x, a, b)

info_m_2pl(x, a, d)

dirinfo_m_2pl(x, a, d)

thisdirinfo_m_2pl(x, alpha_vec, a, d)

info_3pl(x, a, b, c)

info_m_3pl(x, a, d, c)

dirinfo_m_3pl(x, a, d, c)

thisdirinfo_m_3pl(x, alpha_vec, a, d, c)

info_pc(x, b)

info_gpc(x, a, b)

info_m_gpc(x, a, d)

dirinfo_m_gpc(x, a, d)

thisdirinfo_m_gpc(x, alpha_vec, a, d)

info_gr(x, a, b)

info_m_gr(x, a, d)

dirinfo_m_gr(x, a, d)

thisdirinfo_m_gr(x, alpha_vec, a, d)

array_info_1pl(x, b)

array_info_2pl(x, a, b)

array_info_m_2pl(x, a, d)

array_dirinfo_m_2pl(x, a, d)

array_thisdirinfo_m_2pl(x, alpha_vec, a, d)

array_info_3pl(x, a, b, c)

array_info_m_3pl(x, a, d, c)

array_dirinfo_m_3pl(x, a, d, c)

array_thisdirinfo_m_3pl(x, alpha_vec, a, d, c)

array_info_pc(x, b)

array_info_gpc(x, a, b)

array_info_m_gpc(x, a, d)

array_dirinfo_m_gpc(x, a, d)

array_thisdirinfo_m_gpc(x, alpha_vec, a, d)

array_info_gr(x, a, b)

array_info_m_gr(x, a, d)

array_dirinfo_m_gr(x, a, d)

array_thisdirinfo_m_gr(x, alpha_vec, a, d)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="info_item_+3A_x">x</code></td>
<td>
<p>the theta value. The number of columns should correspond to the number of dimensions.
For <code>array_*()</code> functions, the number of theta values must correspond to the number of rows.</p>
</td></tr>
<tr><td><code id="info_item_+3A_b">b</code>, <code id="info_item_+3A_d">d</code></td>
<td>
<p>the difficulty parameter. <code>b</code> is used for unidimensional items, and <code>d</code> is used for multidimensional items.</p>
</td></tr>
<tr><td><code id="info_item_+3A_a">a</code></td>
<td>
<p>the <em>a</em>-parameter.</p>
</td></tr>
<tr><td><code id="info_item_+3A_alpha_vec">alpha_vec</code></td>
<td>
<p>the alpha angle vector. Used for directional information in <code>thisdirinfo_*()</code> and <code>array_thisdirinfo_*()</code>.</p>
</td></tr>
<tr><td><code id="info_item_+3A_c">c</code></td>
<td>
<p>the <em>c</em>-parameter.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>info_*()</code> functions accept a single theta value, and <code>array_info_*</code> functions accept multiple theta values.
</p>
<p>Supports unidimensional and multidimensional models.
</p>

<ul>
<li><p><code>info_1pl()</code>, <code>array_info_1pl()</code>: 1PL models
</p>
</li>
<li><p><code>info_2pl()</code>, <code>array_info_2pl()</code>: 2PL models
</p>
</li>
<li><p><code>info_3pl()</code>, <code>array_info_3pl()</code>: 3PL models
</p>
</li>
<li><p><code>info_pc()</code>, <code>array_info_pc()</code>: PC (partial credit) models
</p>
</li>
<li><p><code>info_gpc()</code>, <code>array_info_gpc()</code>: GPC (generalized partial credit) models
</p>
</li>
<li><p><code>info_gr()</code>, <code>array_info_gr()</code>: GR (graded response) models
</p>
</li>
<li><p><code>info_m_2pl()</code>, <code>array_info_m_2pl()</code>: multidimensional 2PL models
</p>
</li>
<li><p><code>info_m_3pl()</code>, <code>array_info_m_3pl()</code>: multidimensional 3PL models
</p>
</li>
<li><p><code>info_m_gpc()</code>, <code>array_info_m_gpc()</code>: multidimensional GPC models
</p>
</li>
<li><p><code>info_m_gr()</code>, <code>array_info_m_gr()</code>: multidimensional GR models
</p>
</li>
<li><p>Directional information for a specific angle
</p>

<ul>
<li><p><code>thisdirinfo_m_2pl()</code>, <code>array_thisdirinfo_m_2pl()</code>: multidimensional 2PL models
</p>
</li>
<li><p><code>thisdirinfo_m_3pl()</code>, <code>array_thisdirinfo_m_3pl()</code>: multidimensional 3PL models
</p>
</li>
<li><p><code>thisdirinfo_m_gpc()</code>, <code>array_thisdirinfo_m_gpc()</code>: multidimensional GPC models
</p>
</li>
<li><p><code>thisdirinfo_m_gr()</code>, <code>array_thisdirinfo_m_gr()</code>: multidimensional GR models
</p>
</li></ul>

</li></ul>



<h3>References</h3>

<p>Rasch, G. (1960). <em>Probabilistic models for some intelligence and attainment tests.</em>
Copenhagen: Danish Institute for Educational Research.
</p>
<p>Lord, F. M. (1952). A theory of test scores (Psychometric Monograph No. 7). Richmond, VA: Psychometric Corporation.
</p>
<p>Birnbaum, A. (1957). <em>Efficient design and use of tests of mental ability for various decision-making problems</em>
(Series Report No. 58-16. Project No. 7755-23).
Randolph Air Force Base, TX: USAF School of Aviation Medicine.
</p>
<p>Birnbaum, A. (1958). <em>On the estimation of mental ability</em>
(Series Report No. 15. Project No. 7755-23).
Randolph Air Force Base, TX: USAF School of Aviation Medicine.
</p>
<p>Birnbaum, A. (1958). <em>Further considerations of efficiency in tests of a mental ability</em>
(Series Report No. 17. Project No. 7755-23).
Randolph Air Force Base, TX: USAF School of Aviation Medicine.
</p>
<p>Birnbaum, A. (1968). Some latent trait models and their use in inferring an examinee's ability.
In Lord, F. M., Novick, M. R. (eds.), <em>Statistical Theories of Mental Test Scores</em>, 397-479.
Reading, MA: Addison-Wesley.
</p>
<p>Masters, G. N. (1982). A Rasch model for partial credit scoring.
<em>Psychometrika, 47</em>(2), 149-174.
</p>
<p>Andrich, D. (1978). A rating formulation for ordered response categories.
<em>Psychometrika, 43</em>(4), 561-573.
</p>
<p>Muraki, E. (1992). A generalized partial credit model: Application of an EM algorithm.
<em>Applied Psychological Measurement, 16</em>(2), 159-176.
</p>
<p>Samejima, F. (1969). Estimation of latent ability using a response pattern of graded scores.
<em>Psychometrika Monograph, 17</em>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- 0.5

info_1pl(x, 1)
info_2pl(x, 1, 2)
info_3pl(x, 1, 2, 0.25)
info_pc(x, c(0, 1))
info_gpc(x, 2, c(0, 1))
info_gr(x, 2, c(0, 2))

x &lt;- matrix(seq(0.1, 0.5, 0.1)) # three theta values, unidimensional

array_info_1pl(x, 1)
array_info_2pl(x, 1, 2)
array_info_3pl(x, 1, 2, 0.25)
array_info_pc(x, c(0, 1))
array_info_gpc(x, 2, c(0, 1))
array_info_gr(x, 2, c(0, 2))

</code></pre>

<hr>
<h2 id='iparPosteriorSample'>Generate item parameter samples using standard errors</h2><span id='topic+iparPosteriorSample'></span>

<h3>Description</h3>

<p><code><a href="#topic+iparPosteriorSample">iparPosteriorSample</a></code> is a function for generating item parameter samples.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>iparPosteriorSample(pool, n_sample = 500)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="iparPosteriorSample_+3A_pool">pool</code></td>
<td>
<p>an <code><a href="#topic+item_pool-class">item_pool</a></code> object.</p>
</td></tr>
<tr><td><code id="iparPosteriorSample_+3A_n_sample">n_sample</code></td>
<td>
<p>the number of samples to draw.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code><a href="#topic+iparPosteriorSample">iparPosteriorSample</a></code> returns a length-<em>ni</em> list of item parameter matrices, with each matrix having <code>n_sample</code> rows.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>ipar &lt;- iparPosteriorSample(itempool_bayes, 5)

</code></pre>

<hr>
<h2 id='item_attrib-class'>Load item attributes</h2><span id='topic+item_attrib-class'></span><span id='topic+loadItemAttrib'></span>

<h3>Description</h3>

<p><code><a href="#topic+loadItemAttrib">loadItemAttrib</a></code> is a data loading function to create an <code><a href="#topic+item_attrib-class">item_attrib</a></code> object.
<code><a href="#topic+loadItemAttrib">loadItemAttrib</a></code> can read item attributes a <code><a href="base.html#topic+data.frame">data.frame</a></code> or a .csv file.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>loadItemAttrib(object, pool, file = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="item_attrib-class_+3A_object">object</code></td>
<td>
<p>item attributes. Can be a <code><a href="base.html#topic+data.frame">data.frame</a></code> or the file path of a .csv file. The content should at least include column 'ID' that matches with the <code><a href="#topic+item_pool-class">item_pool</a></code> object.</p>
</td></tr>
<tr><td><code id="item_attrib-class_+3A_pool">pool</code></td>
<td>
<p>an <code><a href="#topic+item_pool-class">item_pool</a></code> object. Use <code><a href="#topic+loadItemPool">loadItemPool</a></code> for this.</p>
</td></tr>
<tr><td><code id="item_attrib-class_+3A_file">file</code></td>
<td>
<p>(deprecated) use <code>object</code> argument instead.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code><a href="#topic+loadItemAttrib">loadItemAttrib</a></code> returns an <code><a href="#topic+item_attrib-class">item_attrib</a></code> object.
</p>

<ul>
<li><p><code>data</code> a <code><a href="base.html#topic+data.frame">data.frame</a></code> containing item attributes.
</p>
</li></ul>



<h3>See Also</h3>

<p><code><a href="#topic+dataset_science">dataset_science</a></code>, <code><a href="#topic+dataset_reading">dataset_reading</a></code>, <code><a href="#topic+dataset_fatigue">dataset_fatigue</a></code>, <code><a href="#topic+dataset_bayes">dataset_bayes</a></code> for examples.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Read from data.frame:
itempool_science   &lt;- loadItemPool(itempool_science_data)
itemattrib_science &lt;- loadItemAttrib(itemattrib_science_data, itempool_science)

## Read from file: write to tempdir() for illustration and clean afterwards
f &lt;- file.path(tempdir(), "itemattrib_science.csv")
write.csv(itemattrib_science_data, f, row.names = FALSE)
itemattrib_science &lt;- loadItemAttrib(f, itempool_science)
file.remove(f)

## TestDesign 1.1.0 - Deprecated arguments
## Not run: 
loadItemAttrib(object = "iatt.csv", pool) # is equivalent to
loadItemAttrib(file   = "iatt.csv", pool) # pre 1.1.0

## End(Not run)

</code></pre>

<hr>
<h2 id='item_attrib-operators'>Basic functions for item attribute objects</h2><span id='topic+item_attrib-operators'></span><span id='topic++5B+2Citem_attrib+2Cnumeric-method'></span><span id='topic++5B+2Citem_attrib+2Cnumeric+2CANY+2CANY-method'></span><span id='topic+dim+2Citem_attrib-method'></span><span id='topic+colnames+2Citem_attrib-method'></span><span id='topic+rownames+2Citem_attrib-method'></span><span id='topic+names+2Citem_attrib-method'></span><span id='topic+as.data.frame+2Citem_attrib-method'></span>

<h3>Description</h3>

<p>Basic functions for item attribute objects
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'item_attrib,numeric'
x[i, j, ..., drop = TRUE]

## S4 method for signature 'item_attrib'
dim(x)

## S4 method for signature 'item_attrib'
colnames(x)

## S4 method for signature 'item_attrib'
rownames(x)

## S4 method for signature 'item_attrib'
names(x)

## S4 method for signature 'item_attrib'
as.data.frame(x, row.names = NULL, optional = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="item_attrib-operators_+3A_x">x</code></td>
<td>
<p>an <code><a href="#topic+item_attrib-class">item_attrib</a></code> object.</p>
</td></tr>
<tr><td><code id="item_attrib-operators_+3A_i">i</code>, <code id="item_attrib-operators_+3A_j">j</code></td>
<td>
<p>indices to use in subsetting.</p>
</td></tr>
<tr><td><code id="item_attrib-operators_+3A_...">...</code></td>
<td>
<p>not used, exists for compatibility.</p>
</td></tr>
<tr><td><code id="item_attrib-operators_+3A_drop">drop</code></td>
<td>
<p>not used, exists for compatibility.</p>
</td></tr>
<tr><td><code id="item_attrib-operators_+3A_row.names">row.names</code></td>
<td>
<p>not used, exists for compatibility.</p>
</td></tr>
<tr><td><code id="item_attrib-operators_+3A_optional">optional</code></td>
<td>
<p>not used, exists for compatibility.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- itemattrib_science
x[1:10]
dim(x)
ncol(x)
nrow(x)
colnames(x)
rownames(x)
names(x)
as.data.frame(x)

</code></pre>

<hr>
<h2 id='item_pool_cluster-class'>Class 'item_pool_cluster': an item pool</h2><span id='topic+item_pool_cluster-class'></span>

<h3>Description</h3>

<p><code><a href="#topic+item_pool_cluster-class">item_pool_cluster</a></code> is an S4 class to represent a group of item pools.
</p>


<h3>Slots</h3>


<dl>
<dt><code>np</code></dt><dd><p>the number of item pools.</p>
</dd>
<dt><code>pools</code></dt><dd><p>a list of <code><a href="#topic+item_pool-class">item_pool</a></code> objects.</p>
</dd>
<dt><code>names</code></dt><dd><p>a vector containing item pool names.</p>
</dd>
</dl>

<hr>
<h2 id='item_pool-class'>Class 'item_pool': an item pool</h2><span id='topic+item_pool-class'></span>

<h3>Description</h3>

<p><code><a href="#topic+item_pool-class">item_pool</a></code> is an S4 class to represent an item pool.
</p>


<h3>Details</h3>

<p>See <code><a href="#topic+item_pool-operators">item_pool-operators</a></code> for object manipulation functions.
</p>


<h3>Slots</h3>


<dl>
<dt><code>ni</code></dt><dd><p>the number of items in the pool.</p>
</dd>
<dt><code>max_cat</code></dt><dd><p>the maximum number of response categories across the pool.</p>
</dd>
<dt><code>index</code></dt><dd><p>the numeric index of each item.</p>
</dd>
<dt><code>id</code></dt><dd><p>the ID string of each item.</p>
</dd>
<dt><code>model</code></dt><dd><p>the item class name of each item. See <code><a href="#topic+item-classes">item-classes</a></code>.</p>
</dd>
<dt><code>NCAT</code></dt><dd><p>the number of response categories of each item.</p>
</dd>
<dt><code>parms</code></dt><dd><p>a list containing item class objects. See <code><a href="#topic+item-classes">item-classes</a></code>.</p>
</dd>
<dt><code>ipar</code></dt><dd><p>a matrix containing item parameters.</p>
</dd>
<dt><code>se</code></dt><dd><p>a matrix containing item parameter standard errors.</p>
</dd>
<dt><code>raw</code></dt><dd><p>the raw input <code><a href="base.html#topic+data.frame">data.frame</a></code> used in <code><a href="#topic+loadItemPool">loadItemPool</a></code> to create this object.</p>
</dd>
<dt><code>raw_se</code></dt><dd><p>the raw input <code><a href="base.html#topic+data.frame">data.frame</a></code> used in <code><a href="#topic+loadItemPool">loadItemPool</a></code> to create this object.</p>
</dd>
<dt><code>unique</code></dt><dd><p>whether item IDs must be unique for this object to be a valid object.</p>
</dd>
</dl>

<hr>
<h2 id='item_pool-operators'>Basic operators for item pool objects</h2><span id='topic+item_pool-operators'></span><span id='topic+subsetItemPool'></span><span id='topic+combineItemPool'></span><span id='topic++5B+2Citem_pool+2Cnumeric-method'></span><span id='topic++5B+2Citem_pool+2Cnumeric+2CANY+2CANY-method'></span><span id='topic+c+2Citem_pool-method'></span><span id='topic++2B.item_pool'></span><span id='topic+-.item_pool'></span><span id='topic++3D+3D.item_pool'></span>

<h3>Description</h3>

<p>Create a subset of an <code><a href="#topic+item_pool-class">item_pool</a></code> object:
</p>

<ul>
<li><p><code>pool[i]</code>
</p>
</li>
<li><p><code>subsetItemPool(pool, i)</code>
</p>
</li></ul>

<p>Combine two <code><a href="#topic+item_pool-class">item_pool</a></code> objects:
</p>

<ul>
<li><p><code>c(pool1, pool2)</code>
</p>
</li>
<li><p><code>combineItemPool(pool1, pool2)</code>
</p>
</li>
<li><p><code>pool1 + pool2</code>
</p>
</li></ul>

<p><code>pool1 - pool2</code> excludes items in <code>pool2</code> from <code>pool1</code>.
</p>
<p><code>pool1 == pool2</code> tests whether two <code><a href="#topic+item_pool-class">item_pool</a></code> objects are identical.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>subsetItemPool(x, i = NULL)

combineItemPool(x1, x2, unique = TRUE, verbose = TRUE)

## S4 method for signature 'item_pool,numeric'
x[i, j, ..., drop = TRUE]

## S4 method for signature 'item_pool'
c(x, ...)

## S3 method for class 'item_pool'
x1 + x2

## S3 method for class 'item_pool'
x1 - x2

## S3 method for class 'item_pool'
x1 == x2
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="item_pool-operators_+3A_x">x</code>, <code id="item_pool-operators_+3A_x1">x1</code>, <code id="item_pool-operators_+3A_x2">x2</code></td>
<td>
<p>an <code><a href="#topic+item_pool-class">item_pool</a></code> object.</p>
</td></tr>
<tr><td><code id="item_pool-operators_+3A_i">i</code></td>
<td>
<p>item indices to use in subsetting.</p>
</td></tr>
<tr><td><code id="item_pool-operators_+3A_unique">unique</code></td>
<td>
<p>if <code>TRUE</code>, remove items with duplicate IDs after combining. (default = <code>TRUE</code>)</p>
</td></tr>
<tr><td><code id="item_pool-operators_+3A_verbose">verbose</code></td>
<td>
<p>if <code>TRUE</code>, raise a warning if duplicate IDs are found after combining. (default = <code>TRUE</code>)</p>
</td></tr>
<tr><td><code id="item_pool-operators_+3A_j">j</code>, <code id="item_pool-operators_+3A_drop">drop</code>, <code id="item_pool-operators_+3A_...">...</code></td>
<td>
<p>not used, exists for compatibility.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>p1 &lt;- itempool_science[1:100]
p2 &lt;- c(itempool_science, itempool_reading)
p3 &lt;- p2 - p1

p1 &lt;- itempool_science[1:500]
p2 &lt;- itempool_science - p1
p3 &lt;- itempool_science[501:1000]
identical(p2, p3)  ## TRUE

p &lt;- p1 + p3
p == itempool_science ## TRUE

</code></pre>

<hr>
<h2 id='item-classes'>Item classes</h2><span id='topic+item-classes'></span><span id='topic+item'></span><span id='topic+item_1PL-class'></span><span id='topic+item_2PL-class'></span><span id='topic+item_3PL-class'></span><span id='topic+item_PC-class'></span><span id='topic+item_GPC-class'></span><span id='topic+item_GR-class'></span>

<h3>Description</h3>


<ul>
<li><p><code><a href="#topic+item_1PL-class">item_1PL</a></code> class represents a 1PL item.
</p>
</li>
<li><p><code><a href="#topic+item_2PL-class">item_2PL</a></code> class represents a 2PL item.
</p>
</li>
<li><p><code><a href="#topic+item_3PL-class">item_3PL</a></code> class represents a 3PL item.
</p>
</li>
<li><p><code><a href="#topic+item_PC-class">item_PC</a></code> class represents a partial credit item.
</p>
</li>
<li><p><code><a href="#topic+item_GPC-class">item_GPC</a></code> class represents a generalized partial credit item.
</p>
</li>
<li><p><code><a href="#topic+item_GR-class">item_GR</a></code> class represents a graded response item.
</p>
</li></ul>



<h3>Slots</h3>


<dl>
<dt><code>slope</code></dt><dd><p>a slope parameter value</p>
</dd>
<dt><code>difficulty</code></dt><dd><p>a difficulty parameter value</p>
</dd>
<dt><code>guessing</code></dt><dd><p>a guessing parameter value</p>
</dd>
<dt><code>threshold</code></dt><dd><p>a vector of threshold parameter values</p>
</dd>
<dt><code>category</code></dt><dd><p>a vector of category boundary values</p>
</dd>
<dt><code>ncat</code></dt><dd><p>the number of response categories</p>
</dd>
</dl>


<h3>References</h3>

<p>Rasch, G. (1960). <em>Probabilistic models for some intelligence and attainment tests.</em>
Copenhagen: Danish Institute for Educational Research.
</p>
<p>Lord, F. M. (1952). A theory of test scores (Psychometric Monograph No. 7). Richmond, VA: Psychometric Corporation.
</p>
<p>Birnbaum, A. (1957). <em>Efficient design and use of tests of mental ability for various decision-making problems</em>
(Series Report No. 58-16. Project No. 7755-23).
Randolph Air Force Base, TX: USAF School of Aviation Medicine.
</p>
<p>Birnbaum, A. (1958). <em>On the estimation of mental ability</em>
(Series Report No. 15. Project No. 7755-23).
Randolph Air Force Base, TX: USAF School of Aviation Medicine.
</p>
<p>Birnbaum, A. (1958). <em>Further considerations of efficiency in tests of a mental ability</em>
(Series Report No. 17. Project No. 7755-23).
Randolph Air Force Base, TX: USAF School of Aviation Medicine.
</p>
<p>Birnbaum, A. (1968). Some latent trait models and their use in inferring an examinee's ability.
In Lord, F. M., Novick, M. R. (eds.), <em>Statistical Theories of Mental Test Scores</em>, 397-479.
Reading, MA: Addison-Wesley.
</p>
<p>Masters, G. N. (1982). A Rasch model for partial credit scoring.
<em>Psychometrika, 47</em>(2), 149-174.
</p>
<p>Andrich, D. (1978). A rating formulation for ordered response categories.
<em>Psychometrika, 43</em>(4), 561-573.
</p>
<p>Muraki, E. (1992). A generalized partial credit model: Application of an EM algorithm.
<em>Applied Psychological Measurement, 16</em>(2), 159-176.
</p>
<p>Samejima, F. (1969). Estimation of latent ability using a response pattern of graded scores.
<em>Psychometrika Monograph, 17</em>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>item_1 &lt;- new("item_1PL", difficulty = 0.5)
item_2 &lt;- new("item_2PL", slope = 1.0, difficulty = 0.5)
item_3 &lt;- new("item_3PL", slope = 1.0, difficulty = 0.5, guessing = 0.2)
item_4 &lt;- new("item_PC", threshold = c(-0.5, 0.5), ncat = 3)
item_5 &lt;- new("item_GPC", slope = 1.0, threshold = c(-0.5, 0.0, 0.5), ncat = 4)
item_6 &lt;- new("item_GR", slope = 1.0, category = c(-2.0, -1.0, 0, 1.0, 2.0), ncat = 6)

</code></pre>

<hr>
<h2 id='j_item'>(C++) Calculate first derivative of log-likelihood</h2><span id='topic+j_item'></span><span id='topic+j_1pl'></span><span id='topic+j_2pl'></span><span id='topic+j_m_2pl'></span><span id='topic+j_3pl'></span><span id='topic+j_m_3pl'></span><span id='topic+j_pc'></span><span id='topic+j_gpc'></span><span id='topic+j_m_gpc'></span><span id='topic+j_gr'></span><span id='topic+j_m_gr'></span><span id='topic+array_j_1pl'></span><span id='topic+array_j_2pl'></span><span id='topic+array_j_3pl'></span><span id='topic+array_j_pc'></span><span id='topic+array_j_gpc'></span><span id='topic+array_j_gr'></span>

<h3>Description</h3>

<p><code>j_*()</code> and <code>array_j_*()</code> are C++ functions for calculating the first derivative of the log-likelihood function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>j_1pl(x, b, u)

j_2pl(x, a, b, u)

j_m_2pl(x, a, d, u)

j_3pl(x, a, b, c, u)

j_m_3pl(x, a, d, c, u)

j_pc(x, b, u)

j_gpc(x, a, b, u)

j_m_gpc(x, a, d, u)

j_gr(x, a, b, u)

j_m_gr(x, a, d, u)

array_j_1pl(x, b, u)

array_j_2pl(x, a, b, u)

array_j_3pl(x, a, b, c, u)

array_j_pc(x, b, u)

array_j_gpc(x, a, b, u)

array_j_gr(x, a, b, u)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="j_item_+3A_x">x</code></td>
<td>
<p>the theta value. The number of columns should correspond to the number of dimensions.
For <code>array_*()</code> functions, the number of theta values must correspond to the number of rows.</p>
</td></tr>
<tr><td><code id="j_item_+3A_b">b</code>, <code id="j_item_+3A_d">d</code></td>
<td>
<p>the difficulty parameter. <code>b</code> is used for unidimensional items, and <code>d</code> is used for multidimensional items.</p>
</td></tr>
<tr><td><code id="j_item_+3A_u">u</code></td>
<td>
<p>the response value.</p>
</td></tr>
<tr><td><code id="j_item_+3A_a">a</code></td>
<td>
<p>the <em>a</em>-parameter.</p>
</td></tr>
<tr><td><code id="j_item_+3A_c">c</code></td>
<td>
<p>the <em>c</em>-parameter.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>j_*()</code> functions accept a single theta value, and <code>array_j_*()</code> functions accept multiple theta values.
</p>
<p>Supports unidimensional and multidimensional models.
</p>

<ul>
<li><p><code>j_1pl()</code>, <code>array_j_1pl()</code>: 1PL models
</p>
</li>
<li><p><code>j_2pl()</code>, <code>array_j_2pl()</code>: 2PL models
</p>
</li>
<li><p><code>j_3pl()</code>, <code>array_j_3pl()</code>: 3PL models
</p>
</li>
<li><p><code>j_pc()</code>, <code>array_j_pc()</code>: PC (partial credit) models
</p>
</li>
<li><p><code>j_gpc()</code>, <code>array_j_gpc()</code>: GPC (generalized partial credit) models
</p>
</li>
<li><p><code>j_gr()</code>, <code>array_j_gr()</code>: GR (graded response) models
</p>
</li>
<li><p><code>j_m_2pl()</code>, <code>array_j_m_2pl()</code>: multidimensional 2PL models
</p>
</li>
<li><p><code>j_m_3pl()</code>, <code>array_j_m_3pl()</code>: multidimensional 3PL models
</p>
</li>
<li><p><code>j_m_gpc()</code>, <code>array_j_m_gpc()</code>: multidimensional GPC models
</p>
</li>
<li><p><code>j_m_gr()</code>, <code>array_j_m_gr()</code>: multidimensional GR models
</p>
</li></ul>



<h3>References</h3>

<p>Rasch, G. (1960). <em>Probabilistic models for some intelligence and attainment tests.</em>
Copenhagen: Danish Institute for Educational Research.
</p>
<p>Lord, F. M. (1952). A theory of test scores (Psychometric Monograph No. 7). Richmond, VA: Psychometric Corporation.
</p>
<p>Birnbaum, A. (1957). <em>Efficient design and use of tests of mental ability for various decision-making problems</em>
(Series Report No. 58-16. Project No. 7755-23).
Randolph Air Force Base, TX: USAF School of Aviation Medicine.
</p>
<p>Birnbaum, A. (1958). <em>On the estimation of mental ability</em>
(Series Report No. 15. Project No. 7755-23).
Randolph Air Force Base, TX: USAF School of Aviation Medicine.
</p>
<p>Birnbaum, A. (1958). <em>Further considerations of efficiency in tests of a mental ability</em>
(Series Report No. 17. Project No. 7755-23).
Randolph Air Force Base, TX: USAF School of Aviation Medicine.
</p>
<p>Birnbaum, A. (1968). Some latent trait models and their use in inferring an examinee's ability.
In Lord, F. M., Novick, M. R. (eds.), <em>Statistical Theories of Mental Test Scores</em>, 397-479.
Reading, MA: Addison-Wesley.
</p>
<p>Masters, G. N. (1982). A Rasch model for partial credit scoring.
<em>Psychometrika, 47</em>(2), 149-174.
</p>
<p>Andrich, D. (1978). A rating formulation for ordered response categories.
<em>Psychometrika, 43</em>(4), 561-573.
</p>
<p>Muraki, E. (1992). A generalized partial credit model: Application of an EM algorithm.
<em>Applied Psychological Measurement, 16</em>(2), 159-176.
</p>
<p>Samejima, F. (1969). Estimation of latent ability using a response pattern of graded scores.
<em>Psychometrika Monograph, 17</em>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>u &lt;- 1

x &lt;- 0.5
j_1pl(x, 1, u)
j_2pl(x, 1, 2, u)
j_3pl(x, 1, 2, 0.25, u)
j_pc(x, c(0, 1), u)
j_gpc(x, 2, c(0, 1), u)
j_gr(x, 2, c(0, 2), u)

x &lt;- matrix(seq(-3, 3, 1)) # three theta values, unidimensional
array_j_1pl(x, 1, u)
array_j_2pl(x, 1, 2, u)
array_j_3pl(x, 1, 2, 0.25, u)
array_j_pc(x, c(0, 1), u)
array_j_gpc(x, 2, c(0, 1), u)
array_j_gr(x, 2, c(0, 2), u)

</code></pre>

<hr>
<h2 id='lnHyperPars'>Convert mean and standard deviation into log-normal distribution parameters</h2><span id='topic+lnHyperPars'></span>

<h3>Description</h3>

<p><code><a href="#topic+lnHyperPars">lnHyperPars</a></code> is a function for calculating parameters for a log-normal distribution, such that the distribution yields desired mean and standard deviation.
Used for sampling the a-parameter.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lnHyperPars(mean, sd)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="lnHyperPars_+3A_mean">mean</code></td>
<td>
<p>the desired mean.</p>
</td></tr>
<tr><td><code id="lnHyperPars_+3A_sd">sd</code></td>
<td>
<p>the desired standard deviation.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code><a href="#topic+lnHyperPars">lnHyperPars</a></code> returns two values. These can be directly supplied to <code><a href="stats.html#topic+rlnorm">rlnorm</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>pars &lt;- lnHyperPars(2, 4)
x &lt;- rlnorm(1000000, pars[1], pars[2])
mean(x) # close to 2
sd(x)   # close to 4

</code></pre>

<hr>
<h2 id='loadConstraints'>Load constraints</h2><span id='topic+loadConstraints'></span>

<h3>Description</h3>

<p><code><a href="#topic+loadConstraints">loadConstraints</a></code> is a data loading function to create a <code><a href="#topic+constraints-class">constraints</a></code> object.
<code><a href="#topic+loadConstraints">loadConstraints</a></code> can read constraints from a data.frame or a .csv file.
The contents must be in the expected format; see the vignette in <code>vignette("constraints")</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>loadConstraints(object, pool, item_attrib, st_attrib = NULL, file = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="loadConstraints_+3A_object">object</code></td>
<td>
<p>constraint specifications. Can be a <code><a href="base.html#topic+data.frame">data.frame</a></code> or the file path of a .csv file. See the vignette for the expected format.</p>
</td></tr>
<tr><td><code id="loadConstraints_+3A_pool">pool</code></td>
<td>
<p>an <code><a href="#topic+item_pool-class">item_pool</a></code> object. Use <code><a href="#topic+loadItemPool">loadItemPool</a></code> for this.</p>
</td></tr>
<tr><td><code id="loadConstraints_+3A_item_attrib">item_attrib</code></td>
<td>
<p>an <code><a href="#topic+item_attrib-class">item_attrib</a></code> object. Use <code><a href="#topic+loadItemAttrib">loadItemAttrib</a></code> for this.</p>
</td></tr>
<tr><td><code id="loadConstraints_+3A_st_attrib">st_attrib</code></td>
<td>
<p>(optional) an <code><a href="#topic+st_attrib-class">st_attrib</a></code> object. Use <code><a href="#topic+loadStAttrib">loadStAttrib</a></code> for this.</p>
</td></tr>
<tr><td><code id="loadConstraints_+3A_file">file</code></td>
<td>
<p>(deprecated) use <code>object</code> argument instead.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code><a href="#topic+loadConstraints">loadConstraints</a></code> returns a <code><a href="#topic+constraints-class">constraints</a></code> object. This object is used in <code><a href="#topic+Static">Static</a></code> and <code><a href="#topic+Shadow">Shadow</a></code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+dataset_science">dataset_science</a></code>, <code><a href="#topic+dataset_reading">dataset_reading</a></code>, <code><a href="#topic+dataset_fatigue">dataset_fatigue</a></code>, <code><a href="#topic+dataset_bayes">dataset_bayes</a></code> for examples.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Read from data.frame:
itempool_science    &lt;- loadItemPool(itempool_science_data)
itemattrib_science  &lt;- loadItemAttrib(itemattrib_science_data, itempool_science)
constraints_science &lt;- loadConstraints(constraints_science_data,
  itempool_science, itemattrib_science)

## Read from file: write to tempdir() for illustration and clean afterwards
f &lt;- file.path(tempdir(), "constraints_science.csv")
write.csv(constraints_science_data, f, row.names = FALSE)
constraints_science &lt;- loadConstraints(f,
  itempool_science, itemattrib_science)
file.remove(f)

## TestDesign 1.1.0 - Deprecated arguments
## Not run: 
loadConstraints(object = "consts.csv", pool, item_attrib) # is equivalent to
loadConstraints(file   = "consts.csv", pool, item_attrib) # pre 1.1.0

## End(Not run)

</code></pre>

<hr>
<h2 id='loadItemPool'>Load item pool</h2><span id='topic+loadItemPool'></span>

<h3>Description</h3>

<p><code><a href="#topic+loadItemPool">loadItemPool</a></code> is a data loading function to create an <code><a href="#topic+item_pool-class">item_pool</a></code> object.
<code><a href="#topic+loadItemPool">loadItemPool</a></code> can read item parameters and standard errors from a <code><a href="base.html#topic+data.frame">data.frame</a></code> or a .csv file.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>loadItemPool(ipar, ipar_se = NULL, file = NULL, se_file = NULL, unique = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="loadItemPool_+3A_ipar">ipar</code></td>
<td>
<p>item parameters. Can be a <code><a href="base.html#topic+data.frame">data.frame</a></code> or the file path of a .csv file. The content should at least include columns 'ID' and 'MODEL'.</p>
</td></tr>
<tr><td><code id="loadItemPool_+3A_ipar_se">ipar_se</code></td>
<td>
<p>(optional) standard errors. Can be a <code><a href="base.html#topic+data.frame">data.frame</a></code> or the file path of a .csv file.</p>
</td></tr>
<tr><td><code id="loadItemPool_+3A_file">file</code></td>
<td>
<p>(deprecated) use <code>ipar</code> argument instead.</p>
</td></tr>
<tr><td><code id="loadItemPool_+3A_se_file">se_file</code></td>
<td>
<p>(deprecated) use <code>ipar_se</code> argument instead.</p>
</td></tr>
<tr><td><code id="loadItemPool_+3A_unique">unique</code></td>
<td>
<p>if <code>TRUE</code>, item IDs must be unique to create a valid <code><a href="#topic+item_pool-class">item_pool</a></code> object. (default = <code>FALSE</code>)</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code><a href="#topic+loadItemPool">loadItemPool</a></code> returns an <code><a href="#topic+item_pool-class">item_pool</a></code> object.
</p>

<ul>
<li><p><code>ni</code> the number of items in the pool.
</p>
</li>
<li><p><code>max_cat</code> the maximum number of response categories across all items in the pool.
</p>
</li>
<li><p><code>index</code> the numeric item index of each item.
</p>
</li>
<li><p><code>id</code> the item ID string of each item.
</p>
</li>
<li><p><code>model</code> the object class names of each item representing an item model type.
Can be <code><a href="#topic+item_1PL-class">item_1PL</a></code>, <code><a href="#topic+item_2PL-class">item_2PL</a></code>, <code><a href="#topic+item_3PL-class">item_3PL</a></code>,
<code><a href="#topic+item_PC-class">item_PC</a></code>, <code><a href="#topic+item_GPC-class">item_GPC</a></code>, or <code><a href="#topic+item_GR-class">item_GR</a></code>.
</p>
</li>
<li><p><code>NCAT</code> the number of response categories of each item.
</p>
</li>
<li><p><code>parms</code> a list containing the item object of each item.
</p>
</li>
<li><p><code>ipar</code> a matrix containing all item parameters.
</p>
</li>
<li><p><code>se</code> a matrix containing all item parameter standard errors. The values will be 0 if the argument <code>ipar_se</code> was not supplied.
</p>
</li>
<li><p><code>raw</code> the original input <code><a href="base.html#topic+data.frame">data.frame</a></code> used to create this object.
</p>
</li></ul>



<h3>See Also</h3>

<p><code><a href="#topic+dataset_science">dataset_science</a></code>, <code><a href="#topic+dataset_reading">dataset_reading</a></code>, <code><a href="#topic+dataset_fatigue">dataset_fatigue</a></code>, <code><a href="#topic+dataset_bayes">dataset_bayes</a></code> for examples.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Read from data.frame:
itempool_science &lt;- loadItemPool(itempool_science_data)

## Read from file: write to tempdir() for illustration and clean afterwards
f &lt;- file.path(tempdir(), "itempool_science.csv")
write.csv(itempool_science_data, f, row.names = FALSE)
itempool_science &lt;- loadItemPool(f)
file.remove(f)

## TestDesign 1.1.0 - Deprecated arguments
## Not run: 
loadItemPool(ipar = "ipar.csv", ipar_se = "se.csv") # is equivalent to
loadItemPool(file = "ipar.csv", se_file = "se.csv") # pre 1.1.0

## End(Not run)

</code></pre>

<hr>
<h2 id='logitHyperPars'>Convert mean and standard deviation into logit-normal distribution parameters</h2><span id='topic+logitHyperPars'></span>

<h3>Description</h3>

<p><code><a href="#topic+logitHyperPars">logitHyperPars</a></code> is a function for calculating parameters for a logit-normal distribution, such that the distribution yields desired mean and standard deviation.
Used for sampling the c-parameter.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>logitHyperPars(mean, sd)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="logitHyperPars_+3A_mean">mean</code></td>
<td>
<p>the desired mean.</p>
</td></tr>
<tr><td><code id="logitHyperPars_+3A_sd">sd</code></td>
<td>
<p>the desired standard deviation.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code><a href="#topic+logitHyperPars">logitHyperPars</a></code> returns two values. These can be directly supplied to <code><a href="logitnorm.html#topic+rlogitnorm">rlogitnorm</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>pars &lt;- logitHyperPars(0.2, 0.1)
x &lt;- logitnorm::rlogitnorm(1000000, pars[1], pars[2])
mean(x) # close to 0.2
sd(x)   # close to 0.1

</code></pre>

<hr>
<h2 id='makeItemPoolCluster'>Create an item pool cluster object</h2><span id='topic+makeItemPoolCluster'></span><span id='topic+makeItemPoolCluster+2Citem_pool-method'></span><span id='topic++3D+3D.item_pool_cluster'></span>

<h3>Description</h3>

<p>Create a <code><a href="#topic+item_pool_cluster-class">item_pool_cluster</a></code> object.
</p>
<p><code>item_pool_cluster1 == item_pool_cluster2</code> tests equality of two item_pool_cluster objects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>makeItemPoolCluster(x, ..., names = NULL)

## S4 method for signature 'item_pool'
makeItemPoolCluster(x, ..., names = NULL)

## S3 method for class 'item_pool_cluster'
item_pool_cluster1 == item_pool_cluster2
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="makeItemPoolCluster_+3A_x">x</code>, <code id="makeItemPoolCluster_+3A_...">...</code></td>
<td>
<p><code><a href="#topic+item_pool-class">item_pool</a></code> objects.</p>
</td></tr>
<tr><td><code id="makeItemPoolCluster_+3A_names">names</code></td>
<td>
<p>(optional) names to use for <code><a href="#topic+item_pool-class">item_pool</a></code>.</p>
</td></tr>
<tr><td><code id="makeItemPoolCluster_+3A_item_pool_cluster1">item_pool_cluster1</code></td>
<td>
<p>an <code><a href="#topic+item_pool_cluster-class">item_pool_cluster</a></code> object.</p>
</td></tr>
<tr><td><code id="makeItemPoolCluster_+3A_item_pool_cluster2">item_pool_cluster2</code></td>
<td>
<p>an <code><a href="#topic+item_pool_cluster-class">item_pool_cluster</a></code> object.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>
cluster &lt;- makeItemPoolCluster(itempool_science, itempool_reading)
cluster1 &lt;- makeItemPoolCluster(itempool_science, itempool_reading)
cluster2 &lt;- makeItemPoolCluster(cluster1@pools[[1]], cluster1@pools[[2]])
cluster1 == cluster2  ## TRUE

</code></pre>

<hr>
<h2 id='makeSimulationDataCache'>Create a simulation data cache object</h2><span id='topic+makeSimulationDataCache'></span><span id='topic+makeSimulationDataCache+2Citem_pool-method'></span>

<h3>Description</h3>

<p><code><a href="#topic+makeSimulationDataCache">makeSimulationDataCache</a></code> is a function for creating a <code><a href="#topic+simulation_data_cache-class">simulation_data_cache</a></code> object.
This is used in <code><a href="#topic+Shadow">Shadow</a></code> to make all necessary data (e.g., item information, response data) prior to the main simulation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>makeSimulationDataCache(
  item_pool,
  info_type = "FISHER",
  theta_grid = seq(-4, 4, 0.1),
  seed = NULL,
  true_theta = NULL,
  response_data = NULL
)

## S4 method for signature 'item_pool'
makeSimulationDataCache(
  item_pool,
  info_type = "FISHER",
  theta_grid = seq(-4, 4, 0.1),
  seed = NULL,
  true_theta = NULL,
  response_data = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="makeSimulationDataCache_+3A_item_pool">item_pool</code></td>
<td>
<p>an <code><a href="#topic+item_pool-class">item_pool</a></code> object.</p>
</td></tr>
<tr><td><code id="makeSimulationDataCache_+3A_info_type">info_type</code></td>
<td>
<p>the type of information.</p>
</td></tr>
<tr><td><code id="makeSimulationDataCache_+3A_theta_grid">theta_grid</code></td>
<td>
<p>a grid of theta values.</p>
</td></tr>
<tr><td><code id="makeSimulationDataCache_+3A_seed">seed</code></td>
<td>
<p>(optional) seed to use for generating response data if needed.</p>
</td></tr>
<tr><td><code id="makeSimulationDataCache_+3A_true_theta">true_theta</code></td>
<td>
<p>(optional) true theta values of all simulees.</p>
</td></tr>
<tr><td><code id="makeSimulationDataCache_+3A_response_data">response_data</code></td>
<td>
<p>(optional) response data on all items for all simulees.</p>
</td></tr>
</table>

<hr>
<h2 id='makeTest'>Create a test object</h2><span id='topic+makeTest'></span><span id='topic+makeTest+2Citem_pool-method'></span>

<h3>Description</h3>

<p><code><a href="#topic+makeTest">makeTest</a></code> is a function for creating a <code><a href="#topic+test-class">test</a></code> object.
This is used to make all necessary data (e.g., item information, response data) prior to the main simulation.
This function is only kept for backwards compatibility.
The functionality of this function is superseded by <code><a href="#topic+makeSimulationDataCache">makeSimulationDataCache</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>makeTest(
  object,
  theta = seq(-4, 4, 0.1),
  info_type = "FISHER",
  true_theta = NULL
)

## S4 method for signature 'item_pool'
makeTest(
  object,
  theta = seq(-4, 4, 0.1),
  info_type = "FISHER",
  true_theta = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="makeTest_+3A_object">object</code></td>
<td>
<p>an <code><a href="#topic+item_pool-class">item_pool</a></code> object.</p>
</td></tr>
<tr><td><code id="makeTest_+3A_theta">theta</code></td>
<td>
<p>a grid of theta values.</p>
</td></tr>
<tr><td><code id="makeTest_+3A_info_type">info_type</code></td>
<td>
<p>the type of information.</p>
</td></tr>
<tr><td><code id="makeTest_+3A_true_theta">true_theta</code></td>
<td>
<p>(optional) true theta values to simulate response data.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>test &lt;- makeTest(itempool_science, seq(-3, 3, 1))
</code></pre>

<hr>
<h2 id='makeTestCluster'>Create a test cluster object</h2><span id='topic+makeTestCluster'></span><span id='topic+makeTestCluster+2Citem_pool_cluster+2Cnumeric+2Cnumeric-method'></span><span id='topic+makeTestCluster+2Citem_pool_cluster+2Cnumeric+2Clist-method'></span>

<h3>Description</h3>

<p><code><a href="#topic+makeTestCluster">makeTestCluster</a></code> is a function for creating a <code><a href="#topic+test_cluster-class">test_cluster</a></code> object.
This is used to make all necessary data (e.g., item information, response data) prior to the main simulation.
This function is only kept for backwards compatibility.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>makeTestCluster(object, theta, true_theta)

## S4 method for signature 'item_pool_cluster,numeric,numeric'
makeTestCluster(object, theta, true_theta)

## S4 method for signature 'item_pool_cluster,numeric,list'
makeTestCluster(object, theta, true_theta)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="makeTestCluster_+3A_object">object</code></td>
<td>
<p>an <code><a href="#topic+item_pool_cluster-class">item_pool_cluster</a></code> object.</p>
</td></tr>
<tr><td><code id="makeTestCluster_+3A_theta">theta</code></td>
<td>
<p>a grid of theta values.</p>
</td></tr>
<tr><td><code id="makeTestCluster_+3A_true_theta">true_theta</code></td>
<td>
<p>an optional vector of true theta values to simulate response data.</p>
</td></tr>
</table>

<hr>
<h2 id='mle'>Compute maximum likelihood estimates of theta</h2><span id='topic+mle'></span><span id='topic+mle+2Citem_pool-method'></span><span id='topic+MLE'></span><span id='topic+MLE+2Ctest-method'></span><span id='topic+MLE+2Ctest_cluster-method'></span>

<h3>Description</h3>

<p><code><a href="#topic+mle">mle</a></code> is a function to compute maximum likelihood estimates of theta.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mle(
  object,
  select = NULL,
  resp,
  start_theta = NULL,
  max_iter = 100,
  crit = 0.001,
  truncate = FALSE,
  theta_range = c(-4, 4),
  max_change = 1,
  use_step_size = FALSE,
  step_size = 0.5,
  do_Fisher = TRUE
)

## S4 method for signature 'item_pool'
mle(
  object,
  select = NULL,
  resp,
  start_theta = NULL,
  max_iter = 50,
  crit = 0.005,
  truncate = FALSE,
  theta_range = c(-4, 4),
  max_change = 1,
  use_step_size = FALSE,
  step_size = 0.5,
  do_Fisher = TRUE
)

MLE(
  object,
  select = NULL,
  start_theta = NULL,
  max_iter = 100,
  crit = 0.001,
  theta_range = c(-4, 4),
  truncate = FALSE,
  max_change = 1,
  do_Fisher = TRUE
)

## S4 method for signature 'test'
MLE(
  object,
  select = NULL,
  start_theta = NULL,
  max_iter = 100,
  crit = 0.001,
  theta_range = c(-4, 4),
  truncate = FALSE,
  max_change = 1,
  do_Fisher = TRUE
)

## S4 method for signature 'test_cluster'
MLE(object, select = NULL, start_theta = NULL, max_iter = 100, crit = 0.001)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mle_+3A_object">object</code></td>
<td>
<p>an <code><a href="#topic+item_pool-class">item_pool</a></code> object.</p>
</td></tr>
<tr><td><code id="mle_+3A_select">select</code></td>
<td>
<p>(optional) if item indices are supplied, only the specified items are used.</p>
</td></tr>
<tr><td><code id="mle_+3A_resp">resp</code></td>
<td>
<p>item response on all (or selected) items in the <code>object</code> argument. Can be a vector, a matrix, or a data frame. <code>length(resp)</code> or <code>ncol(resp)</code> must be equal to the number of all (or selected) items.</p>
</td></tr>
<tr><td><code id="mle_+3A_start_theta">start_theta</code></td>
<td>
<p>(optional) initial theta values. If not supplied, EAP estimates using uniform priors are used as initial values. Uniform priors are computed using the <code>theta_range</code> argument below, with increments of <code>.1</code>.</p>
</td></tr>
<tr><td><code id="mle_+3A_max_iter">max_iter</code></td>
<td>
<p>maximum number of iterations. (default = <code>100</code>)</p>
</td></tr>
<tr><td><code id="mle_+3A_crit">crit</code></td>
<td>
<p>convergence criterion to use. (default = <code>0.001</code>)</p>
</td></tr>
<tr><td><code id="mle_+3A_truncate">truncate</code></td>
<td>
<p>set <code>TRUE</code> to impose a bound using <code>theta_range</code> on the estimate. (default = <code>FALSE</code>)</p>
</td></tr>
<tr><td><code id="mle_+3A_theta_range">theta_range</code></td>
<td>
<p>a range of theta values to bound the estimate. Only effective when <code>truncate</code> is <code>TRUE</code>. (default = <code>c(-4, 4)</code>)</p>
</td></tr>
<tr><td><code id="mle_+3A_max_change">max_change</code></td>
<td>
<p>upper bound to impose on the absolute change in theta between iterations. Absolute changes exceeding this value will be capped to <code>max_change</code>. (default = <code>1.0</code>)</p>
</td></tr>
<tr><td><code id="mle_+3A_use_step_size">use_step_size</code></td>
<td>
<p>set <code>TRUE</code> to use <code>step_size</code>. (default = <code>FALSE</code>)</p>
</td></tr>
<tr><td><code id="mle_+3A_step_size">step_size</code></td>
<td>
<p>upper bound to impose on the absolute change in initial theta and estimated theta. Absolute changes exceeding this value will be capped to <code>step_size</code>. (default = <code>0.5</code>)</p>
</td></tr>
<tr><td><code id="mle_+3A_do_fisher">do_Fisher</code></td>
<td>
<p>set <code>TRUE</code> to use Fisher scoring instead of Newton-Raphson method. (default = <code>TRUE</code>)</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code><a href="#topic+mle">mle</a></code> returns a list containing estimated values.
</p>

<ul>
<li><p><code>th</code> theta value.
</p>
</li>
<li><p><code>se</code> standard error.
</p>
</li>
<li><p><code>conv</code> <code>TRUE</code> if estimation converged.
</p>
</li>
<li><p><code>trunc</code> <code>TRUE</code> if truncation was applied on <code>th</code>.
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>mle(itempool_fatigue, resp = resp_fatigue_data[10, ])
mle(itempool_fatigue, select = 1:20, resp = resp_fatigue_data[10, 1:20])
</code></pre>

<hr>
<h2 id='mlef'>Compute maximum likelihood estimates of theta using fence items</h2><span id='topic+mlef'></span><span id='topic+mlef+2Citem_pool-method'></span>

<h3>Description</h3>

<p><code><a href="#topic+mlef">mlef</a></code> is a function to compute maximum likelihood estimates of theta using fence items.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mlef(
  object,
  select = NULL,
  resp,
  fence_slope = 5,
  fence_difficulty = c(-5, 5),
  start_theta = NULL,
  max_iter = 100,
  crit = 0.001,
  truncate = FALSE,
  theta_range = c(-4, 4),
  max_change = 1,
  use_step_size = FALSE,
  step_size = 0.5,
  do_Fisher = TRUE
)

## S4 method for signature 'item_pool'
mlef(
  object,
  select = NULL,
  resp,
  fence_slope = 5,
  fence_difficulty = c(-5, 5),
  start_theta = NULL,
  max_iter = 50,
  crit = 0.005,
  truncate = FALSE,
  theta_range = c(-4, 4),
  max_change = 1,
  use_step_size = FALSE,
  step_size = 0.5,
  do_Fisher = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mlef_+3A_object">object</code></td>
<td>
<p>an <code><a href="#topic+item_pool-class">item_pool</a></code> object.</p>
</td></tr>
<tr><td><code id="mlef_+3A_select">select</code></td>
<td>
<p>(optional) if item indices are supplied, only the specified items are used.</p>
</td></tr>
<tr><td><code id="mlef_+3A_resp">resp</code></td>
<td>
<p>item response on all (or selected) items in the <code>object</code> argument. Can be a vector, a matrix, or a data frame. <code>length(resp)</code> or <code>ncol(resp)</code> must be equal to the number of all (or selected) items.</p>
</td></tr>
<tr><td><code id="mlef_+3A_fence_slope">fence_slope</code></td>
<td>
<p>the slope parameter to use on fence items. Can be one value, or two values for the lower and the upper fence respectively. (default = <code>5</code>)</p>
</td></tr>
<tr><td><code id="mlef_+3A_fence_difficulty">fence_difficulty</code></td>
<td>
<p>the difficulty parameter to use on fence items. Must have two values for the lower and the upper fence respectively. (default = <code>c(-5, 5)</code>)</p>
</td></tr>
<tr><td><code id="mlef_+3A_start_theta">start_theta</code></td>
<td>
<p>(optional) initial theta values. If not supplied, EAP estimates using uniform priors are used as initial values. Uniform priors are computed using the <code>theta_range</code> argument below, with increments of <code>.1</code>.</p>
</td></tr>
<tr><td><code id="mlef_+3A_max_iter">max_iter</code></td>
<td>
<p>maximum number of iterations. (default = <code>100</code>)</p>
</td></tr>
<tr><td><code id="mlef_+3A_crit">crit</code></td>
<td>
<p>convergence criterion to use. (default = <code>0.001</code>)</p>
</td></tr>
<tr><td><code id="mlef_+3A_truncate">truncate</code></td>
<td>
<p>set <code>TRUE</code> to impose a bound using <code>theta_range</code> on the estimate. (default = <code>FALSE</code>)</p>
</td></tr>
<tr><td><code id="mlef_+3A_theta_range">theta_range</code></td>
<td>
<p>a range of theta values to bound the estimate. Only effective when <code>truncate</code> is <code>TRUE</code>. (default = <code>c(-4, 4)</code>)</p>
</td></tr>
<tr><td><code id="mlef_+3A_max_change">max_change</code></td>
<td>
<p>upper bound to impose on the absolute change in theta between iterations. Absolute changes exceeding this value will be capped to <code>max_change</code>. (default = <code>1.0</code>)</p>
</td></tr>
<tr><td><code id="mlef_+3A_use_step_size">use_step_size</code></td>
<td>
<p>set <code>TRUE</code> to use <code>step_size</code>. (default = <code>FALSE</code>)</p>
</td></tr>
<tr><td><code id="mlef_+3A_step_size">step_size</code></td>
<td>
<p>upper bound to impose on the absolute change in initial theta and estimated theta. Absolute changes exceeding this value will be capped to <code>step_size</code>. (default = <code>0.5</code>)</p>
</td></tr>
<tr><td><code id="mlef_+3A_do_fisher">do_Fisher</code></td>
<td>
<p>set <code>TRUE</code> to use Fisher scoring instead of Newton-Raphson method. (default = <code>TRUE</code>)</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code><a href="#topic+mlef">mlef</a></code> returns a list containing estimated values.
</p>

<ul>
<li><p><code>th</code> theta value.
</p>
</li>
<li><p><code>se</code> standard error.
</p>
</li>
<li><p><code>conv</code> <code>TRUE</code> if estimation converged.
</p>
</li>
<li><p><code>trunc</code> <code>TRUE</code> if truncation was applied on <code>th</code>.
</p>
</li></ul>



<h3>References</h3>

<p>Han, K. T. (2016). Maximum likelihood score estimation method with fences for short-length tests and computerized adaptive tests.
<em>Applied Psychological Measurement, 40</em>(4), 289-301.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>mlef(itempool_fatigue, resp = resp_fatigue_data[10, ])
mlef(itempool_fatigue, select = 1:20, resp = resp_fatigue_data[10, 1:20])
</code></pre>

<hr>
<h2 id='output_Shadow_all-class'>Class 'output_Shadow_all': a set of adaptive assembly solutions</h2><span id='topic+output_Shadow_all-class'></span>

<h3>Description</h3>

<p><code><a href="#topic+output_Shadow_all-class">output_Shadow_all</a></code> is an S4 class to represent a set of adaptive assembly solutions.
</p>


<h3>Details</h3>


<dl>
<dt><em>notations</em></dt><dd>
<ul>
<li><p><em>ni</em> denotes the number of items in the <code><a href="#topic+item_pool-class">item_pool</a></code> object.
</p>
</li>
<li><p><em>ns</em> denotes the number of stimuli.
</p>
</li>
<li><p><em>nj</em> denotes the number of participants.
</p>
</li></ul>
</dd>
</dl>



<h3>Slots</h3>


<dl>
<dt><code>output</code></dt><dd><p>a length-*nj* list of <code><a href="#topic+output_Shadow-class">output_Shadow</a></code> objects, containing the assembly results for each participant.</p>
</dd>
<dt><code>final_theta_est</code></dt><dd><p>a length-*nj* vector containing final theta estimates for each participant.</p>
</dd>
<dt><code>final_se_est</code></dt><dd><p>a length-*nj* vector standard errors of the final theta estimates for each participant.</p>
</dd>
<dt><code>exposure_rate</code></dt><dd><p>a matrix containing item-level exposure rates of all items in the pool. Also contains stimulus-level exposure rates if the assembly was set-based.</p>
</dd>
<dt><code>usage_matrix</code></dt><dd><p>a *nj* by (*ni* + *ns*) matrix representing whether the item/stimulus was administered to each participant. Stimuli representations are appended to the right side of the matrix.</p>
</dd>
<dt><code>true_segment_count</code></dt><dd><p>a length-*nj* vector containing the how many examinees are now in their segment based on the true theta. This will tend to increase. This can be reproduced with true theta values alone.</p>
</dd>
<dt><code>est_segment_count</code></dt><dd><p>a length-*nj* vector containing the how many examinees are now in their segment based on the estimated theta. This will tend to increase. This can be reproduced with estimated theta values alone.</p>
</dd>
<dt><code>eligibility_stats</code></dt><dd><p>exposure record for diagnostics.</p>
</dd>
<dt><code>check_eligibility_stats</code></dt><dd><p>detailed segment-wise exposure record for diagnostics. available when <code>config_Shadow@exposure_control$diagnostic_stats</code> is <code>TRUE</code>.</p>
</dd>
<dt><code>no_fading_eligibility_stats</code></dt><dd><p>detailed segment-wise exposure record without fading for diagnostics. available when <code>config_Shadow@exposure_control$diagnostic_stats</code> is <code>TRUE</code>.</p>
</dd>
<dt><code>freq_infeasible</code></dt><dd><p>a table representing the number of times the assembly was initially infeasible.</p>
</dd>
<dt><code>pool</code></dt><dd><p>the <code><a href="#topic+item_pool-class">item_pool</a></code> used in the assembly.</p>
</dd>
<dt><code>config</code></dt><dd><p>the <code><a href="#topic+config_Shadow-class">config_Shadow</a></code> used in the assembly.</p>
</dd>
<dt><code>constraints</code></dt><dd><p>the <code><a href="#topic+constraints-class">constraints</a></code> used in the assembly.</p>
</dd>
<dt><code>true_theta</code></dt><dd><p>the <code>true_theta</code> argument used in the assembly.</p>
</dd>
<dt><code>data</code></dt><dd><p>the <code>data</code> argument used in the assembly.</p>
</dd>
<dt><code>prior</code></dt><dd><p>the <code>prior</code> argument used in the assembly.</p>
</dd>
<dt><code>prior_par</code></dt><dd><p>the <code>prior_par</code> argument used in the assembly.</p>
</dd>
</dl>

<hr>
<h2 id='output_Shadow-class'>Class 'output_Shadow': adaptive assembly solution for one simulee</h2><span id='topic+output_Shadow-class'></span>

<h3>Description</h3>

<p><code><a href="#topic+output_Shadow-class">output_Shadow</a></code> is an S4 class to represent the adaptive assembly solution for one simulee.
</p>


<h3>Slots</h3>


<dl>
<dt><code>simulee_id</code></dt><dd><p>the numeric ID of the simulee.</p>
</dd>
<dt><code>true_theta</code></dt><dd><p>the true theta of the simulee, if was specified.</p>
</dd>
<dt><code>true_theta_segment</code></dt><dd><p>the segment number of the true theta.</p>
</dd>
<dt><code>final_theta_est</code></dt><dd><p>final theta estimate.</p>
</dd>
<dt><code>final_se_est</code></dt><dd><p>the standard error of <code>final_theta_est</code>.</p>
</dd>
<dt><code>administered_item_index</code></dt><dd><p>item IDs administered at each position.</p>
</dd>
<dt><code>administered_item_resp</code></dt><dd><p>item responses from the simulee at each position.</p>
</dd>
<dt><code>administered_item_ncat</code></dt><dd><p>the number of categories of each administered item.</p>
</dd>
<dt><code>administered_stimulus_index</code></dt><dd><p>stimulus IDs administered at each position.</p>
</dd>
<dt><code>shadow_test_refreshed</code></dt><dd><p><code>TRUE</code> indicates the shadow test was refreshed for the position.</p>
</dd>
<dt><code>shadow_test_feasible</code></dt><dd><p><code>TRUE</code> indicates the MIP was feasible with all constraints.</p>
</dd>
<dt><code>solve_time</code></dt><dd><p>elapsed time in running the solver at each position.</p>
</dd>
<dt><code>initial_theta_est</code></dt><dd><p>initial theta estimate.</p>
</dd>
<dt><code>interim_theta_est</code></dt><dd><p>interim theta estimates at each position.</p>
</dd>
<dt><code>interim_se_est</code></dt><dd><p>the standard error of the interim estimate at each position.</p>
</dd>
<dt><code>theta_segment_index</code></dt><dd><p>segment numbers of interim theta estimates.</p>
</dd>
<dt><code>prior</code></dt><dd><p>prior distribution, if was specified.</p>
</dd>
<dt><code>prior_par</code></dt><dd><p>prior parameters, if were specified.</p>
</dd>
<dt><code>posterior</code></dt><dd><p>the posterior distribution after completing test.</p>
</dd>
<dt><code>posterior_sample</code></dt><dd><p>posterior samples of interim theta before the estimation of final theta. <code>mean(posterior_sample) == interim_theta_est[test_length]</code> holds.</p>
</dd>
<dt><code>likelihood</code></dt><dd><p>the likelihood distribution after completing test.</p>
</dd>
<dt><code>shadow_test</code></dt><dd><p>the list containing the item IDs within the shadow test used in each position.</p>
</dd>
<dt><code>max_cat_pool</code></dt><dd><p>the maximum number of response categories the item pool had.</p>
</dd>
<dt><code>ni_pool</code></dt><dd><p>the total number of items the item pool had.</p>
</dd>
<dt><code>ns_pool</code></dt><dd><p>the total number of stimuli the item pool had.</p>
</dd>
<dt><code>test_length_constraints</code></dt><dd><p>the test length constraint used in assembly.</p>
</dd>
<dt><code>set_based</code></dt><dd><p>whether the item pool was set-based.</p>
</dd>
<dt><code>item_index_by_stimulus</code></dt><dd><p>the list of items by each stimulus the item pool had.</p>
</dd>
</dl>

<hr>
<h2 id='output_Split-class'>Class 'output_Split': partitioning solution</h2><span id='topic+output_Split-class'></span>

<h3>Description</h3>

<p><code><a href="#topic+output_Split-class">output_Split</a></code> is an S4 class to represent the partitioning solution of an item pool.
</p>


<h3>Slots</h3>


<dl>
<dt><code>output</code></dt><dd><p>a list containing item/set indices of each partition.</p>
</dd>
<dt><code>feasible</code></dt><dd><p>for partitioning into sub-pools, <code>TRUE</code> indicates the complete assignment problem was feasible.</p>
</dd>
<dt><code>solve_time</code></dt><dd><p>elapsed time in running the solver.</p>
</dd>
<dt><code>set_based</code></dt><dd><p>whether the item pool is set-based.</p>
</dd>
<dt><code>config</code></dt><dd><p>the <code><a href="#topic+config_Static-class">config_Static</a></code> used in the assembly.</p>
</dd>
<dt><code>constraints</code></dt><dd><p>the <code><a href="#topic+constraints-class">constraints</a></code> used in the assembly.</p>
</dd>
<dt><code>partition_size_range</code></dt><dd><p>the partition size range for splitting into sub-pools.</p>
</dd>
<dt><code>partition_type</code></dt><dd><p>the partition type. Can be a <code>test</code> or a <code>pool</code>.</p>
</dd>
</dl>

<hr>
<h2 id='output_Static-class'>Class 'output_Static': fixed-form assembly solution</h2><span id='topic+output_Static-class'></span>

<h3>Description</h3>

<p><code><a href="#topic+output_Static-class">output_Static</a></code> is an S4 class to represent a fixed-form assembly solution.
</p>


<h3>Slots</h3>


<dl>
<dt><code>MIP</code></dt><dd><p>a list containing the result from MIP solver.</p>
</dd>
<dt><code>selected</code></dt><dd><p>a <code><a href="base.html#topic+data.frame">data.frame</a></code> containing the selected items and their attributes.</p>
</dd>
<dt><code>obj_value</code></dt><dd><p>the objective value of the solution.</p>
</dd>
<dt><code>solve_time</code></dt><dd><p>the elapsed time in running the solver.</p>
</dd>
<dt><code>achieved</code></dt><dd><p>a <code><a href="base.html#topic+data.frame">data.frame</a></code> containing attributes of the assembled test, by each constraint.</p>
</dd>
<dt><code>pool</code></dt><dd><p>the <code><a href="#topic+item_pool-class">item_pool</a></code> used in the assembly.</p>
</dd>
<dt><code>config</code></dt><dd><p>the <code><a href="#topic+config_Static-class">config_Static</a></code> used in the assembly.</p>
</dd>
<dt><code>constraints</code></dt><dd><p>the <code><a href="#topic+constraints-class">constraints</a></code> used in the assembly.</p>
</dd>
</dl>

<hr>
<h2 id='p_item'>(C++) Calculate item response probability</h2><span id='topic+p_item'></span><span id='topic+p_1pl'></span><span id='topic+p_2pl'></span><span id='topic+p_m_2pl'></span><span id='topic+p_3pl'></span><span id='topic+p_m_3pl'></span><span id='topic+p_pc'></span><span id='topic+p_gpc'></span><span id='topic+p_m_gpc'></span><span id='topic+p_gr'></span><span id='topic+p_m_gr'></span><span id='topic+array_p_1pl'></span><span id='topic+array_p_2pl'></span><span id='topic+array_p_m_2pl'></span><span id='topic+array_p_3pl'></span><span id='topic+array_p_m_3pl'></span><span id='topic+array_p_pc'></span><span id='topic+array_p_gpc'></span><span id='topic+array_p_m_gpc'></span><span id='topic+array_p_gr'></span><span id='topic+array_p_m_gr'></span>

<h3>Description</h3>

<p><code>p_*()</code> and <code>array_p_*()</code> are C++ functions for calculating item response probability.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>p_1pl(x, b)

p_2pl(x, a, b)

p_m_2pl(x, a, d)

p_3pl(x, a, b, c)

p_m_3pl(x, a, d, c)

p_pc(x, b)

p_gpc(x, a, b)

p_m_gpc(x, a, d)

p_gr(x, a, b)

p_m_gr(x, a, d)

array_p_1pl(x, b)

array_p_2pl(x, a, b)

array_p_m_2pl(x, a, d)

array_p_3pl(x, a, b, c)

array_p_m_3pl(x, a, d, c)

array_p_pc(x, b)

array_p_gpc(x, a, b)

array_p_m_gpc(x, a, d)

array_p_gr(x, a, b)

array_p_m_gr(x, a, d)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="p_item_+3A_x">x</code></td>
<td>
<p>the theta value. The number of columns should correspond to the number of dimensions.
For <code>array_*()</code> functions, the number of theta values must correspond to the number of rows.</p>
</td></tr>
<tr><td><code id="p_item_+3A_b">b</code>, <code id="p_item_+3A_d">d</code></td>
<td>
<p>the difficulty parameter. <code>b</code> is used for unidimensional items, and <code>d</code> is used for multidimensional items.</p>
</td></tr>
<tr><td><code id="p_item_+3A_a">a</code></td>
<td>
<p>the <em>a</em>-parameter.</p>
</td></tr>
<tr><td><code id="p_item_+3A_c">c</code></td>
<td>
<p>the <em>c</em>-parameter.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>p_*()</code> functions accept a single theta value, and <code>array_p_*()</code> functions accept multiple theta values.
</p>
<p>Supports unidimensional and multidimensional models.
</p>

<ul>
<li><p><code>p_1pl()</code>, <code>array_p_1pl()</code>: 1PL models
</p>
</li>
<li><p><code>p_2pl()</code>, <code>array_p_2pl()</code>: 2PL models
</p>
</li>
<li><p><code>p_3pl()</code>, <code>array_p_3pl()</code>: 3PL models
</p>
</li>
<li><p><code>p_pc()</code>, <code>array_p_pc()</code>: PC (partial credit) models
</p>
</li>
<li><p><code>p_gpc()</code>, <code>array_p_gpc()</code>: GPC (generalized partial credit) models
</p>
</li>
<li><p><code>p_gr()</code>, <code>array_p_gr()</code>: GR (graded response) models
</p>
</li>
<li><p><code>p_m_2pl()</code>, <code>array_p_m_2pl()</code>: multidimensional 2PL models
</p>
</li>
<li><p><code>p_m_3pl()</code>, <code>array_p_m_3pl()</code>: multidimensional 3PL models
</p>
</li>
<li><p><code>p_m_gpc()</code>, <code>array_p_m_gpc()</code>: multidimensional GPC models
</p>
</li>
<li><p><code>p_m_gr()</code>, <code>array_p_m_gr()</code>: multidimensional GR models
</p>
</li></ul>



<h3>References</h3>

<p>Rasch, G. (1960). <em>Probabilistic models for some intelligence and attainment tests.</em>
Copenhagen: Danish Institute for Educational Research.
</p>
<p>Lord, F. M. (1952). A theory of test scores (Psychometric Monograph No. 7). Richmond, VA: Psychometric Corporation.
</p>
<p>Birnbaum, A. (1957). <em>Efficient design and use of tests of mental ability for various decision-making problems</em>
(Series Report No. 58-16. Project No. 7755-23).
Randolph Air Force Base, TX: USAF School of Aviation Medicine.
</p>
<p>Birnbaum, A. (1958). <em>On the estimation of mental ability</em>
(Series Report No. 15. Project No. 7755-23).
Randolph Air Force Base, TX: USAF School of Aviation Medicine.
</p>
<p>Birnbaum, A. (1958). <em>Further considerations of efficiency in tests of a mental ability</em>
(Series Report No. 17. Project No. 7755-23).
Randolph Air Force Base, TX: USAF School of Aviation Medicine.
</p>
<p>Birnbaum, A. (1968). Some latent trait models and their use in inferring an examinee's ability.
In Lord, F. M., Novick, M. R. (eds.), <em>Statistical Theories of Mental Test Scores</em>, 397-479.
Reading, MA: Addison-Wesley.
</p>
<p>Masters, G. N. (1982). A Rasch model for partial credit scoring.
<em>Psychometrika, 47</em>(2), 149-174.
</p>
<p>Andrich, D. (1978). A rating formulation for ordered response categories.
<em>Psychometrika, 43</em>(4), 561-573.
</p>
<p>Muraki, E. (1992). A generalized partial credit model: Application of an EM algorithm.
<em>Applied Psychological Measurement, 16</em>(2), 159-176.
</p>
<p>Samejima, F. (1969). Estimation of latent ability using a response pattern of graded scores.
<em>Psychometrika Monograph, 17</em>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- 0.5

p_1pl(x, 1)
p_2pl(x, 1, 2)
p_3pl(x, 1, 2, 0.25)
p_pc(x, c(0, 1))
p_gpc(x, 2, c(0, 1))
p_gr(x, 2, c(0, 2))

x &lt;- matrix(seq(0.1, 0.5, 0.1)) # three theta values, unidimensional

array_p_1pl(x, 1)
array_p_2pl(x, 1, 2)
array_p_3pl(x, 1, 2, 0.25)
array_p_pc(x, c(0, 1))
array_p_gpc(x, 2, c(0, 1))
array_p_gr(x, 2, c(0, 2))

</code></pre>

<hr>
<h2 id='plot'>Extension of plot() for objects in TestDesign package</h2><span id='topic+plot'></span><span id='topic+plot+2Citem_pool-method'></span><span id='topic+plot+2Coutput_Static-method'></span><span id='topic+plot+2Cconstraints-method'></span><span id='topic+plot+2Coutput_Shadow-method'></span><span id='topic+plot+2Coutput_Shadow_all-method'></span><span id='topic+plot+2Coutput_Split-method'></span>

<h3>Description</h3>

<p>Extension of plot() for objects in TestDesign package
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'item_pool'
plot(
  x,
  y,
  type = "info",
  theta = seq(-3, 3, 0.1),
  info_type = "FISHER",
  plot_sum = TRUE,
  select = NULL,
  examinee_id = 1,
  position = NULL,
  theta_range = c(-5, 5),
  ylim = NULL,
  color = "blue",
  z_ci = 1.96,
  simple = TRUE,
  theta_type = "Estimated",
  color_final = "blue",
  segment = NULL,
  rmse = FALSE,
  use_segment_label = TRUE,
  use_par = TRUE,
  ...
)

## S4 method for signature 'output_Static'
plot(
  x,
  y,
  type = NULL,
  theta = seq(-3, 3, 0.1),
  info_type = "FISHER",
  plot_sum = TRUE,
  select = NULL,
  examinee_id = 1,
  position = NULL,
  theta_range = c(-5, 5),
  ylim = NULL,
  color = "blue",
  z_ci = 1.96,
  simple = TRUE,
  use_par = TRUE,
  ...
)

## S4 method for signature 'constraints'
plot(
  x,
  y,
  type = "info",
  theta = seq(-3, 3, 0.1),
  info_type = "FISHER",
  plot_sum = TRUE,
  select = NULL,
  examinee_id = 1,
  position = NULL,
  theta_range = c(-5, 5),
  ylim = NULL,
  color = "blue",
  z_ci = 1.96,
  simple = TRUE,
  use_par = TRUE,
  ...
)

## S4 method for signature 'output_Shadow'
plot(
  x,
  y,
  type = "audit",
  theta = seq(-3, 3, 0.1),
  info_type = "FISHER",
  plot_sum = TRUE,
  select = NULL,
  examinee_id = 1,
  theta_range = c(-5, 5),
  ylim = NULL,
  color = "blue",
  z_ci = 1.96,
  simple = FALSE,
  theta_type = "Estimated",
  use_par = TRUE,
  ...
)

## S4 method for signature 'output_Shadow_all'
plot(
  x,
  y,
  type = "audit",
  theta = seq(-3, 3, 0.1),
  info_type = "FISHER",
  plot_sum = TRUE,
  select = NULL,
  examinee_id = 1,
  position = NULL,
  theta_range = c(-5, 5),
  ylim = NULL,
  color = "blue",
  z_ci = 1.96,
  simple = FALSE,
  theta_type = "Estimated",
  color_final = "blue",
  segment = NULL,
  rmse = FALSE,
  use_segment_label = TRUE,
  use_par = TRUE,
  theta_segment = NULL,
  ...
)

## S4 method for signature 'output_Split'
plot(
  x,
  y,
  type = NULL,
  theta = seq(-3, 3, 0.1),
  info_type = "FISHER",
  plot_sum = TRUE,
  select = NULL,
  examinee_id = 1,
  position = NULL,
  theta_range = c(-5, 5),
  ylim = NULL,
  color = "blue",
  z_ci = 1.96,
  simple = TRUE,
  use_par = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot_+3A_x">x</code></td>
<td>
<p>accepts the following signatures:
</p>

<ul>
<li><p><code><a href="#topic+item_pool-class">item_pool</a></code>: plot information and expected scores.
</p>
</li>
<li><p><code><a href="#topic+constraints-class">constraints</a></code>: plot information range based on the test length constraint.
</p>
</li>
<li><p><code><a href="#topic+output_Static-class">output_Static</a></code>: plot information and expected scores based on the fixed assembly solution.
</p>
</li>
<li><p><code><a href="#topic+output_Shadow_all-class">output_Shadow_all</a></code>: plot audit trail, shadow test chart, and exposure rates from the adaptive assembly solution.
</p>
</li>
<li><p><code><a href="#topic+output_Shadow-class">output_Shadow</a></code>: plot audit trail and shadow test chart from the adaptive assembly solution.
</p>
</li></ul>
</td></tr>
<tr><td><code id="plot_+3A_y">y</code></td>
<td>
<p>not used, exists for compatibility with <code><a href="graphics.html#topic+plot">plot</a></code> in the base R package.</p>
</td></tr>
<tr><td><code id="plot_+3A_type">type</code></td>
<td>
<p>the type of plot.
</p>

<ul>
<li><p><code>info</code> plots information from <code><a href="#topic+item_pool-class">item_pool</a></code>, <code><a href="#topic+output_Static-class">output_Static</a></code>, and <code><a href="#topic+output_Shadow_all-class">output_Shadow_all</a></code>.
</p>
</li>
<li><p><code>score</code> plots expected scores from <code><a href="#topic+item_pool-class">item_pool</a></code> and <code><a href="#topic+output_Static-class">output_Static</a></code>.
</p>
</li>
<li><p><code>audit</code> plots audit trail from <code><a href="#topic+output_Shadow_all-class">output_Shadow_all</a></code> and <code><a href="#topic+output_Shadow-class">output_Shadow</a></code>.
</p>
</li>
<li><p><code>shadow</code> plots shadow test chart from <code><a href="#topic+output_Shadow_all-class">output_Shadow_all</a></code> and <code><a href="#topic+output_Shadow-class">output_Shadow</a></code>.
</p>
</li>
<li><p><code>exposure</code> plots exposure rates from <code><a href="#topic+output_Shadow_all-class">output_Shadow_all</a></code>.
</p>
</li></ul>
</td></tr>
<tr><td><code id="plot_+3A_theta">theta</code></td>
<td>
<p>the theta grid to use in plotting. (default = <code>seq(-3, 3, .1)</code>)</p>
</td></tr>
<tr><td><code id="plot_+3A_info_type">info_type</code></td>
<td>
<p>the type of information. Currently accepts <code>FISHER</code>. (default = <code>FISHER</code>)</p>
</td></tr>
<tr><td><code id="plot_+3A_plot_sum">plot_sum</code></td>
<td>
<p>used in <code><a href="#topic+item_pool-class">item_pool</a></code> objects.
</p>

<ul>
<li><p>if <code>TRUE</code> then plot pool-level values.
</p>
</li>
<li><p>if <code>FALSE</code> then plot item-level values, and repeat for all items in the pool.
</p>
</li>
<li><p>(default = <code>TRUE</code>)
</p>
</li></ul>
</td></tr>
<tr><td><code id="plot_+3A_select">select</code></td>
<td>
<p>used in <code><a href="#topic+item_pool-class">item_pool</a></code> objects. Item indices to subset.</p>
</td></tr>
<tr><td><code id="plot_+3A_examinee_id">examinee_id</code></td>
<td>
<p>used in <code><a href="#topic+output_Shadow-class">output_Shadow</a></code> and <code><a href="#topic+output_Shadow_all-class">output_Shadow_all</a></code> with <code>type = 'audit'</code> and <code>type = 'shadow'</code>. The examinee numeric ID to draw the plot.</p>
</td></tr>
<tr><td><code id="plot_+3A_position">position</code></td>
<td>
<p>used in <code><a href="#topic+output_Shadow_all-class">output_Shadow_all</a></code> with <code>type = 'info'</code>. The item position to draw the plot.</p>
</td></tr>
<tr><td><code id="plot_+3A_theta_range">theta_range</code></td>
<td>
<p>used in <code><a href="#topic+output_Shadow-class">output_Shadow</a></code> and <code><a href="#topic+output_Shadow_all-class">output_Shadow_all</a></code> with <code>type = 'audit'</code>. The theta range to plot. (default = <code>c(-5, 5)</code>)</p>
</td></tr>
<tr><td><code id="plot_+3A_ylim">ylim</code></td>
<td>
<p>(optional) the y-axis plot range. Used in most plot types.</p>
</td></tr>
<tr><td><code id="plot_+3A_color">color</code></td>
<td>
<p>the color of the curve.</p>
</td></tr>
<tr><td><code id="plot_+3A_z_ci">z_ci</code></td>
<td>
<p>used in <code><a href="#topic+output_Shadow-class">output_Shadow</a></code> and <code><a href="#topic+output_Shadow_all-class">output_Shadow_all</a></code> with <code>type = 'audit'</code>. The range to use for confidence intervals. (default = <code>1.96</code>)</p>
</td></tr>
<tr><td><code id="plot_+3A_simple">simple</code></td>
<td>
<p>used in <code><a href="#topic+output_Shadow-class">output_Shadow</a></code> and <code><a href="#topic+output_Shadow_all-class">output_Shadow_all</a></code> with <code>type = 'shadow'</code>. If <code>TRUE</code>, simplify the chart by hiding unused items.</p>
</td></tr>
<tr><td><code id="plot_+3A_theta_type">theta_type</code></td>
<td>
<p>used in <code><a href="#topic+output_Shadow_all-class">output_Shadow_all</a></code> with <code>type = 'exposure'</code>. The type of theta to determine exposure segments. Accepts <code>Estimated</code> or <code>True</code>. (default = <code>Estimated</code>)</p>
</td></tr>
<tr><td><code id="plot_+3A_color_final">color_final</code></td>
<td>
<p>used in <code><a href="#topic+output_Shadow_all-class">output_Shadow_all</a></code> with <code>type = 'exposure'</code>. The color of item-wise exposure rates, only counting the items administered in the final theta segment as exposed.</p>
</td></tr>
<tr><td><code id="plot_+3A_segment">segment</code></td>
<td>
<p>used in <code><a href="#topic+output_Shadow_all-class">output_Shadow_all</a></code> with <code>type = 'exposure'</code>. (optional) The segment index to draw the plot. Leave empty to use all segments.</p>
</td></tr>
<tr><td><code id="plot_+3A_rmse">rmse</code></td>
<td>
<p>used in <code><a href="#topic+output_Shadow_all-class">output_Shadow_all</a></code> with <code>type = 'exposure'</code>. If <code>TRUE</code>, display the RMSE value for each segment. (default = <code>FALSE</code>)</p>
</td></tr>
<tr><td><code id="plot_+3A_use_segment_label">use_segment_label</code></td>
<td>
<p>used in <code><a href="#topic+output_Shadow_all-class">output_Shadow_all</a></code> with <code>type = 'exposure'</code>. If <code>TRUE</code>, display the segment label for each segment. (default = <code>TRUE</code>)</p>
</td></tr>
<tr><td><code id="plot_+3A_use_par">use_par</code></td>
<td>
<p>if <code>FALSE</code>, graphical parameters are not overridden inside the function. (default = <code>TRUE</code>)</p>
</td></tr>
<tr><td><code id="plot_+3A_...">...</code></td>
<td>
<p>arguments to pass onto <code><a href="graphics.html#topic+plot">plot</a></code>.</p>
</td></tr>
<tr><td><code id="plot_+3A_theta_segment">theta_segment</code></td>
<td>
<p>(deprecated) use <code>theta_type</code> argument instead.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>
subitempool &lt;- itempool_science[1:8]

## Plot item information of a pool
plot(subitempool)
plot(itempool_science, select = 1:8)

## Plot expected score of a pool
plot(subitempool, type = "score")
plot(itempool_science, type = "score", select = 1:8)

## Plot assembly results from Static()
cfg &lt;- createStaticTestConfig()
solution &lt;- Static(cfg, constraints_science)
plot(solution)                 # defaults to the objective type
plot(solution, type = "score") # plot expected scores

## Plot attainable information range from constraints
plot(constraints_science)

## Plot assembly results from Shadow()
cfg &lt;- createShadowTestConfig()
set.seed(1)
solution &lt;- Shadow(cfg, constraints_science, true_theta = rnorm(1))
plot(solution, type = 'audit' , examinee_id = 1)
plot(solution, type = 'shadow', examinee_id = 1, simple = TRUE)

## plot(solution, type = 'exposure')

</code></pre>

<hr>
<h2 id='print'>Extension of print() for objects in TestDesign package</h2><span id='topic+print'></span><span id='topic+print+2Citem_1PL-method'></span><span id='topic+print+2Citem_2PL-method'></span><span id='topic+print+2Citem_3PL-method'></span><span id='topic+print+2Citem_PC-method'></span><span id='topic+print+2Citem_GPC-method'></span><span id='topic+print+2Citem_GR-method'></span><span id='topic+print+2Citem_pool-method'></span><span id='topic+print+2Citem_attrib-method'></span><span id='topic+print+2Cst_attrib-method'></span><span id='topic+print+2Csummary_item_attrib-method'></span><span id='topic+print+2Csummary_st_attrib-method'></span><span id='topic+print+2Cconstraints-method'></span><span id='topic+print+2Cconfig_Static-method'></span><span id='topic+print+2Cconfig_Shadow-method'></span><span id='topic+print+2Coutput_Static-method'></span><span id='topic+print+2Coutput_Shadow-method'></span><span id='topic+print+2Coutput_Shadow_all-method'></span><span id='topic+print+2Cexposure_rate_plot-method'></span><span id='topic+print+2Csummary_item_pool-method'></span><span id='topic+print+2Csummary_constraints-method'></span><span id='topic+print+2Csummary_output_Static-method'></span><span id='topic+print+2Csummary_output_Shadow_all-method'></span>

<h3>Description</h3>

<p>Extension of print() for objects in TestDesign package
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'item_1PL'
print(x)

## S4 method for signature 'item_2PL'
print(x)

## S4 method for signature 'item_3PL'
print(x)

## S4 method for signature 'item_PC'
print(x)

## S4 method for signature 'item_GPC'
print(x)

## S4 method for signature 'item_GR'
print(x)

## S4 method for signature 'item_pool'
print(x)

## S4 method for signature 'item_attrib'
print(x)

## S4 method for signature 'st_attrib'
print(x)

## S4 method for signature 'summary_item_attrib'
print(x)

## S4 method for signature 'summary_st_attrib'
print(x)

## S4 method for signature 'constraints'
print(x)

## S4 method for signature 'config_Static'
print(x)

## S4 method for signature 'config_Shadow'
print(x)

## S4 method for signature 'output_Static'
print(x, index_only = TRUE)

## S4 method for signature 'output_Shadow'
print(x)

## S4 method for signature 'output_Shadow_all'
print(x)

## S4 method for signature 'exposure_rate_plot'
print(x)

## S4 method for signature 'summary_item_pool'
print(x)

## S4 method for signature 'summary_constraints'
print(x)

## S4 method for signature 'summary_output_Static'
print(x, digits = 3)

## S4 method for signature 'summary_output_Shadow_all'
print(x, digits = 3)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print_+3A_x">x</code></td>
<td>
<p>an object to print.</p>
</td></tr>
<tr><td><code id="print_+3A_index_only">index_only</code></td>
<td>
<p>if <code>TRUE</code> then only print item indices. If <code>FALSE</code> then print all item attributes. (default = <code>TRUE</code>)</p>
</td></tr>
<tr><td><code id="print_+3A_digits">digits</code></td>
<td>
<p>minimal number of *significant* digits. See <code><a href="base.html#topic+print.default">print.default</a></code>.</p>
</td></tr>
</table>

<hr>
<h2 id='RE'>Calculate Relative Errors</h2><span id='topic+RE'></span>

<h3>Description</h3>

<p>Calculate Relative Errors.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>RE(RMSE_foc, RMSE_ref)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="RE_+3A_rmse_foc">RMSE_foc</code></td>
<td>
<p>A vector of RMSE values for the focal group.</p>
</td></tr>
<tr><td><code id="RE_+3A_rmse_ref">RMSE_ref</code></td>
<td>
<p>A vector of RMSE values for the reference group.</p>
</td></tr>
</table>

<hr>
<h2 id='RMSE'>Calculate Root Mean Squared Error</h2><span id='topic+RMSE'></span>

<h3>Description</h3>

<p>Calculate Root Mean Squared Error.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>RMSE(x, y, conditional = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="RMSE_+3A_x">x</code></td>
<td>
<p>A vector of values.</p>
</td></tr>
<tr><td><code id="RMSE_+3A_y">y</code></td>
<td>
<p>A vector of values.</p>
</td></tr>
<tr><td><code id="RMSE_+3A_conditional">conditional</code></td>
<td>
<p>If <code>TRUE</code>, calculate RMSE conditional on x.</p>
</td></tr>
</table>

<hr>
<h2 id='runAssembly'>Run Test Assembly</h2><span id='topic+runAssembly'></span>

<h3>Description</h3>

<p><code><a href="#topic+runAssembly">runAssembly</a></code> is a function to perform test assembly. This function is used internally in <code><a href="#topic+Static">Static</a></code> and <code><a href="#topic+Shadow">Shadow</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>runAssembly(config, constraints, xdata = NULL, objective = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="runAssembly_+3A_config">config</code></td>
<td>
<p>a <code><a href="#topic+config_Static-class">config_Static</a></code> or a <code><a href="#topic+config_Shadow-class">config_Shadow</a></code> object containing configuration options. Use <code><a href="#topic+createStaticTestConfig">createStaticTestConfig</a></code> and <code><a href="#topic+createShadowTestConfig">createShadowTestConfig</a></code> for this.</p>
</td></tr>
<tr><td><code id="runAssembly_+3A_constraints">constraints</code></td>
<td>
<p>a <code><a href="#topic+constraints-class">constraints</a></code> object. Use <code><a href="#topic+loadConstraints">loadConstraints</a></code> for this.</p>
</td></tr>
<tr><td><code id="runAssembly_+3A_xdata">xdata</code></td>
<td>
<p>a list containing extra constraints in MIP form, to force-include previously administered items.</p>
</td></tr>
<tr><td><code id="runAssembly_+3A_objective">objective</code></td>
<td>
<p>the information value for each item in the pool.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list containing the following entries:
</p>

<ul>
<li><p><code>MIP</code> a list containing the result from MIP solver.
</p>
</li>
<li><p><code>status</code> the MIP status value, indicating whether an optimal solution was found.
</p>
</li>
<li><p><code>shadow_test</code> the attributes of the selected items.
</p>
</li>
<li><p><code>obj_value</code> the objective value of the solution.
</p>
</li>
<li><p><code>solve_time</code> the elapsed time in running the solver.
</p>
</li></ul>



<h3>References</h3>

<p>van der Linden, W. J. (2005).
<em>Linear models for optimal test design.</em>
Springer Science &amp; Business Media.
</p>

<hr>
<h2 id='Shadow'>Run adaptive test assembly</h2><span id='topic+Shadow'></span><span id='topic+Shadow+2Cconfig_Shadow-method'></span>

<h3>Description</h3>

<p><code><a href="#topic+Shadow">Shadow</a></code> is a test assembly function to perform adaptive test assembly based on the generalized shadow-test framework.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Shadow(
  config,
  constraints = NULL,
  true_theta = NULL,
  data = NULL,
  prior = NULL,
  prior_par = NULL,
  exclude = NULL,
  include_items_for_estimation = NULL,
  force_solver = FALSE,
  session = NULL,
  seed = NULL
)

## S4 method for signature 'config_Shadow'
Shadow(
  config,
  constraints = NULL,
  true_theta = NULL,
  data = NULL,
  prior = NULL,
  prior_par = NULL,
  exclude = NULL,
  include_items_for_estimation = NULL,
  force_solver = FALSE,
  session = NULL,
  seed = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Shadow_+3A_config">config</code></td>
<td>
<p>a <code><a href="#topic+config_Shadow-class">config_Shadow</a></code> object. Use <code><a href="#topic+createShadowTestConfig">createShadowTestConfig</a></code> for this.</p>
</td></tr>
<tr><td><code id="Shadow_+3A_constraints">constraints</code></td>
<td>
<p>a <code><a href="#topic+constraints-class">constraints</a></code> object representing test specifications. Use <code><a href="#topic+loadConstraints">loadConstraints</a></code> for this.</p>
</td></tr>
<tr><td><code id="Shadow_+3A_true_theta">true_theta</code></td>
<td>
<p>(optional) true theta values to use in simulation. Either <code>true_theta</code> or <code>data</code> must be supplied.</p>
</td></tr>
<tr><td><code id="Shadow_+3A_data">data</code></td>
<td>
<p>(optional) a matrix containing item response data to use in simulation. Either <code>true_theta</code> or <code>data</code> must be supplied.</p>
</td></tr>
<tr><td><code id="Shadow_+3A_prior">prior</code></td>
<td>
<p>(optional) density at each <code>config@theta_grid</code> to use as prior.
Must be a length-<em>nq</em> vector or a <em>nj * nq</em> matrix.
This overrides <code>prior_dist</code> and <code>prior_par</code> in the config.
<code>prior</code> and <code>prior_par</code> cannot be used simultaneously.</p>
</td></tr>
<tr><td><code id="Shadow_+3A_prior_par">prior_par</code></td>
<td>
<p>(optional) normal distribution parameters <code>c(mean, sd)</code> to use as prior.
Must be a length-<em>nq</em> vector or a <em>nj * nq</em> matrix.
This overrides <code>prior_dist</code> and <code>prior_par</code> in the config.
<code>prior</code> and <code>prior_par</code> cannot be used simultaneously.</p>
</td></tr>
<tr><td><code id="Shadow_+3A_exclude">exclude</code></td>
<td>
<p>(optional) a list containing item names in <code>$i</code> and set names in <code>$s</code> to exclude from selection for each participant. The length of the list must be equal to the number of participants.</p>
</td></tr>
<tr><td><code id="Shadow_+3A_include_items_for_estimation">include_items_for_estimation</code></td>
<td>
<p>(optional) an examinee-wise list containing:
</p>

<ul>
<li><p><code>administered_item_pool</code> items to include in theta estimation as <code><a href="#topic+item_pool-class">item_pool</a></code> object.
</p>
</li>
<li><p><code>administered_item_resp</code> item responses to include in theta estimation.
</p>
</li></ul>
</td></tr>
<tr><td><code id="Shadow_+3A_force_solver">force_solver</code></td>
<td>
<p>if <code>TRUE</code>, do not check whether the solver is one of recommended solvers for complex problems (set-based assembly, partitioning). (default = <code>FALSE</code>)</p>
</td></tr>
<tr><td><code id="Shadow_+3A_session">session</code></td>
<td>
<p>(optional) used to communicate with Shiny app <code><a href="#topic+TestDesign">TestDesign</a></code>.</p>
</td></tr>
<tr><td><code id="Shadow_+3A_seed">seed</code></td>
<td>
<p>(optional) used to perform data generation internally.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code><a href="#topic+Shadow">Shadow</a></code> returns an <code><a href="#topic+output_Shadow_all-class">output_Shadow_all</a></code> object containing assembly results.
</p>


<h3>References</h3>

<p>van der Linden, W. J., Reese, L. M. (1998).
A model for optimal constrained adaptive testing.
<em>Applied Psychological Measurement, 22</em>, 259-270.
</p>
<p>van der Linden, W. J. (1998).
Optimal assembly of psychological and educational tests.
<em>Applied Psychological Measurement, 22</em>, 195-211.
</p>
<p>van der Linden, W. J. (2000).
Optimal assembly of tests with item sets.
<em>Applied Psychological Measurement, 24</em>, 225-240.
</p>
<p>van der Linden, W. J. (2005).
<em>Linear models for optimal test design.</em>
Springer Science &amp; Business Media.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>config &lt;- createShadowTestConfig()
true_theta &lt;- rnorm(1)
solution &lt;- Shadow(config, constraints_science, true_theta)
solution@output
</code></pre>

<hr>
<h2 id='show'>Extension of show() for objects in TestDesign package</h2><span id='topic+show'></span><span id='topic+show+2Citem_1PL-method'></span><span id='topic+show+2Citem_2PL-method'></span><span id='topic+show+2Citem_3PL-method'></span><span id='topic+show+2Citem_PC-method'></span><span id='topic+show+2Citem_GPC-method'></span><span id='topic+show+2Citem_GR-method'></span><span id='topic+show+2Citem_pool-method'></span><span id='topic+show+2Citem_pool_cluster-method'></span><span id='topic+show+2Cpool_cluster-method'></span><span id='topic+show+2Citem_attrib-method'></span><span id='topic+show+2Cst_attrib-method'></span><span id='topic+show+2Cconstraints-method'></span><span id='topic+show+2Csummary_item_pool-method'></span><span id='topic+show+2Csummary_item_attrib-method'></span><span id='topic+show+2Csummary_st_attrib-method'></span><span id='topic+show+2Csummary_constraints-method'></span><span id='topic+show+2Cconfig_Static-method'></span><span id='topic+show+2Cconfig_Shadow-method'></span><span id='topic+show+2Coutput_Static-method'></span><span id='topic+show+2Coutput_Shadow-method'></span><span id='topic+show+2Coutput_Shadow_all-method'></span><span id='topic+show+2Csummary_output_Static-method'></span><span id='topic+show+2Csummary_output_Shadow_all-method'></span><span id='topic+show+2Cexposure_rate_plot-method'></span>

<h3>Description</h3>

<p>Extension of show() for objects in TestDesign package
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'item_1PL'
show(object)

## S4 method for signature 'item_2PL'
show(object)

## S4 method for signature 'item_3PL'
show(object)

## S4 method for signature 'item_PC'
show(object)

## S4 method for signature 'item_GPC'
show(object)

## S4 method for signature 'item_GR'
show(object)

## S4 method for signature 'item_pool'
show(object)

## S4 method for signature 'item_pool_cluster'
show(object)

## S4 method for signature 'item_attrib'
show(object)

## S4 method for signature 'st_attrib'
show(object)

## S4 method for signature 'constraints'
show(object)

## S4 method for signature 'summary_item_pool'
show(object)

## S4 method for signature 'summary_item_attrib'
show(object)

## S4 method for signature 'summary_st_attrib'
show(object)

## S4 method for signature 'summary_constraints'
show(object)

## S4 method for signature 'config_Static'
show(object)

## S4 method for signature 'config_Shadow'
show(object)

## S4 method for signature 'output_Static'
show(object)

## S4 method for signature 'output_Shadow'
show(object)

## S4 method for signature 'output_Shadow_all'
show(object)

## S4 method for signature 'summary_output_Static'
show(object)

## S4 method for signature 'summary_output_Shadow_all'
show(object)

## S4 method for signature 'exposure_rate_plot'
show(object)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="show_+3A_object">object</code></td>
<td>
<p>an object to display.</p>
</td></tr>
</table>

<hr>
<h2 id='simResp'>Simulate item response data</h2><span id='topic+simResp'></span><span id='topic+simResp+2Citem_1PL+2Cnumeric-method'></span><span id='topic+simResp+2Citem_1PL+2Cmatrix-method'></span><span id='topic+simResp+2Citem_2PL+2Cnumeric-method'></span><span id='topic+simResp+2Citem_2PL+2Cmatrix-method'></span><span id='topic+simResp+2Citem_3PL+2Cnumeric-method'></span><span id='topic+simResp+2Citem_3PL+2Cmatrix-method'></span><span id='topic+simResp+2Citem_PC+2Cnumeric-method'></span><span id='topic+simResp+2Citem_PC+2Cmatrix-method'></span><span id='topic+simResp+2Citem_GPC+2Cnumeric-method'></span><span id='topic+simResp+2Citem_GPC+2Cmatrix-method'></span><span id='topic+simResp+2Citem_GR+2Cnumeric-method'></span><span id='topic+simResp+2Citem_GR+2Cmatrix-method'></span><span id='topic+simResp+2Citem_pool+2Cnumeric-method'></span><span id='topic+simResp+2Citem_pool+2Cmatrix-method'></span><span id='topic+simResp+2Citem_pool_cluster+2Cnumeric-method'></span><span id='topic+simResp+2Citem_pool_cluster+2Clist-method'></span>

<h3>Description</h3>

<p><code><a href="#topic+simResp">simResp</a></code> is a function to simulate item response data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>simResp(object, theta)

## S4 method for signature 'item_1PL,numeric'
simResp(object, theta)

## S4 method for signature 'item_1PL,matrix'
simResp(object, theta)

## S4 method for signature 'item_2PL,numeric'
simResp(object, theta)

## S4 method for signature 'item_2PL,matrix'
simResp(object, theta)

## S4 method for signature 'item_3PL,numeric'
simResp(object, theta)

## S4 method for signature 'item_3PL,matrix'
simResp(object, theta)

## S4 method for signature 'item_PC,numeric'
simResp(object, theta)

## S4 method for signature 'item_PC,matrix'
simResp(object, theta)

## S4 method for signature 'item_GPC,numeric'
simResp(object, theta)

## S4 method for signature 'item_GPC,matrix'
simResp(object, theta)

## S4 method for signature 'item_GR,numeric'
simResp(object, theta)

## S4 method for signature 'item_GR,matrix'
simResp(object, theta)

## S4 method for signature 'item_pool,numeric'
simResp(object, theta)

## S4 method for signature 'item_pool,matrix'
simResp(object, theta)

## S4 method for signature 'item_pool_cluster,numeric'
simResp(object, theta)

## S4 method for signature 'item_pool_cluster,list'
simResp(object, theta)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="simResp_+3A_object">object</code></td>
<td>
<p>an <code><a href="#topic+item">item</a></code> or an <code><a href="#topic+item_pool-class">item_pool</a></code> object.</p>
</td></tr>
<tr><td><code id="simResp_+3A_theta">theta</code></td>
<td>
<p>theta values to use.</p>
</td></tr>
</table>


<h3>Details</h3>


<dl>
<dt><em>notations</em></dt><dd>
<ul>
<li><p><em>nq</em> denotes the number of theta values.
</p>
</li>
<li><p><em>ni</em> denotes the number of items in the <code><a href="#topic+item_pool-class">item_pool</a></code> object.
</p>
</li></ul>
</dd>
</dl>



<h3>Value</h3>


<dl>
<dt><code><a href="#topic+item">item</a></code> object:</dt><dd><p><code><a href="#topic+simResp">simResp</a></code> returns a length <em>nq</em> vector containing simulated item response data.</p>
</dd>
<dt><code><a href="#topic+item_pool-class">item_pool</a></code> object:</dt><dd><p><code><a href="#topic+simResp">simResp</a></code> returns a (<em>nq</em>, <em>ni</em>) matrix containing simulated item response data.</p>
</dd>
</dl>



<h3>References</h3>

<p>Rasch, G. (1960). <em>Probabilistic models for some intelligence and attainment tests.</em>
Copenhagen: Danish Institute for Educational Research.
</p>
<p>Lord, F. M. (1952). A theory of test scores (Psychometric Monograph No. 7). Richmond, VA: Psychometric Corporation.
</p>
<p>Birnbaum, A. (1957). <em>Efficient design and use of tests of mental ability for various decision-making problems</em>
(Series Report No. 58-16. Project No. 7755-23).
Randolph Air Force Base, TX: USAF School of Aviation Medicine.
</p>
<p>Birnbaum, A. (1958). <em>On the estimation of mental ability</em>
(Series Report No. 15. Project No. 7755-23).
Randolph Air Force Base, TX: USAF School of Aviation Medicine.
</p>
<p>Birnbaum, A. (1958). <em>Further considerations of efficiency in tests of a mental ability</em>
(Series Report No. 17. Project No. 7755-23).
Randolph Air Force Base, TX: USAF School of Aviation Medicine.
</p>
<p>Birnbaum, A. (1968). Some latent trait models and their use in inferring an examinee's ability.
In Lord, F. M., Novick, M. R. (eds.), <em>Statistical Theories of Mental Test Scores</em>, 397-479.
Reading, MA: Addison-Wesley.
</p>
<p>Masters, G. N. (1982). A Rasch model for partial credit scoring.
<em>Psychometrika, 47</em>(2), 149-174.
</p>
<p>Andrich, D. (1978). A rating formulation for ordered response categories.
<em>Psychometrika, 43</em>(4), 561-573.
</p>
<p>Muraki, E. (1992). A generalized partial credit model: Application of an EM algorithm.
<em>Applied Psychological Measurement, 16</em>(2), 159-176.
</p>
<p>Samejima, F. (1969). Estimation of latent ability using a response pattern of graded scores.
<em>Psychometrika Monograph, 17</em>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
item_1    &lt;- new("item_1PL", difficulty = 0.5)
item_2    &lt;- new("item_2PL", slope = 1.0, difficulty = 0.5)
item_3    &lt;- new("item_3PL", slope = 1.0, difficulty = 0.5, guessing = 0.2)
item_4    &lt;- new("item_PC", threshold = c(-1, 0, 1), ncat = 4)
item_5    &lt;- new("item_GPC", slope = 1.2, threshold = c(-0.8, -1.0, 0.5), ncat = 4)
item_6    &lt;- new("item_GR", slope = 0.9, category = c(-1, 0, 1), ncat = 4)

sim_item_1 &lt;- simResp(item_1, seq(-3, 3, 1))
sim_item_2 &lt;- simResp(item_2, seq(-3, 3, 1))
sim_item_3 &lt;- simResp(item_3, seq(-3, 3, 1))
sim_item_4 &lt;- simResp(item_4, seq(-3, 3, 1))
sim_item_5 &lt;- simResp(item_5, seq(-3, 3, 1))
sim_item_6 &lt;- simResp(item_6, seq(-3, 3, 1))
sim_pool   &lt;- simResp(itempool_science, seq(-3, 3, 1))

</code></pre>

<hr>
<h2 id='simulation_data_cache-class'>Class 'simulation_data_cache': data cache for Shadow()</h2><span id='topic+simulation_data_cache-class'></span>

<h3>Description</h3>

<p><code><a href="#topic+simulation_data_cache-class">simulation_data_cache</a></code> is an S4 class to represent data cache for Shadow().
</p>


<h3>Slots</h3>


<dl>
<dt><code>item_pool</code></dt><dd><p>the <code><a href="#topic+item_pool-class">item_pool</a></code> object.</p>
</dd>
<dt><code>theta_grid</code></dt><dd><p>the theta grid to use as quadrature points.</p>
</dd>
<dt><code>prob_grid</code></dt><dd><p>the list containing item response probabilities at theta quadratures.</p>
</dd>
<dt><code>info_grid</code></dt><dd><p>the matrix containing item information values at theta quadratures.</p>
</dd>
<dt><code>max_info</code></dt><dd><p>the maximum value of <code>info_grid</code>.</p>
</dd>
<dt><code>true_theta</code></dt><dd><p>(optional) the true theta values.</p>
</dd>
<dt><code>response_data</code></dt><dd><p>(optional) the matrix containing item responses.</p>
</dd>
</dl>

<hr>
<h2 id='Split'>Split an item pool into partitions</h2><span id='topic+Split'></span><span id='topic+Split+2Cconfig_Static-method'></span>

<h3>Description</h3>

<p><code><a href="#topic+Split">Split</a></code> is a function to split a pool into multiple parallel tests or pools.
When constructing parallel tests, each test is constructed to satisfy all constraints.
When constructing parallel pools, each pool is constructed so that it contains a test that satisfies all constraints.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Split(
  config,
  constraints,
  n_partition,
  partition_type,
  partition_size_range = NULL,
  force_solver = FALSE
)

## S4 method for signature 'config_Static'
Split(
  config,
  constraints,
  n_partition,
  partition_type,
  partition_size_range = NULL,
  force_solver = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Split_+3A_config">config</code></td>
<td>
<p>a <code><a href="#topic+config_Static-class">config_Static</a></code> object. Use <code><a href="#topic+createStaticTestConfig">createStaticTestConfig</a></code> for this.</p>
</td></tr>
<tr><td><code id="Split_+3A_constraints">constraints</code></td>
<td>
<p>a <code><a href="#topic+constraints-class">constraints</a></code> object representing test specifications. Use <code><a href="#topic+loadConstraints">loadConstraints</a></code> for this.</p>
</td></tr>
<tr><td><code id="Split_+3A_n_partition">n_partition</code></td>
<td>
<p>the number of partitions to create.</p>
</td></tr>
<tr><td><code id="Split_+3A_partition_type">partition_type</code></td>
<td>
<p><code>test</code> to create tests, or <code>pool</code> to create pools.</p>
</td></tr>
<tr><td><code id="Split_+3A_partition_size_range">partition_size_range</code></td>
<td>
<p>(optional) two integer values for the desired range for the size of a partition. Has no effect when <code>partition_type</code> is <code>test</code>.
For discrete item pools, the default partition size is (pool size / number of partitions).
For set-based item pools, the default partition size is (pool size / number of partitions) +/- smallest set size.</p>
</td></tr>
<tr><td><code id="Split_+3A_force_solver">force_solver</code></td>
<td>
<p>if <code>TRUE</code>, do not check whether the solver is one of recommended solvers for complex problems (set-based assembly, partitioning). (default = <code>FALSE</code>)</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code><a href="cluster.html#topic+partition">partition</a></code> returns an <code><a href="#topic+output_Split-class">output_Split</a></code> object containing item/set indices of created tests/pools.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
config &lt;- createStaticTestConfig(MIP = list(solver = "RSYMPHONY"))
constraints &lt;- constraints_science[1:10]

solution &lt;- Split(config, constraints, n_partition = 4, partition_type = "test"))
plot(solution)
solution &lt;- Split(config, constraints, n_partition = 4, partition_type = "pool"))
plot(solution)

## End(Not run)
</code></pre>

<hr>
<h2 id='st_attrib-class'>Load set/stimulus/passage attributes</h2><span id='topic+st_attrib-class'></span><span id='topic+loadStAttrib'></span>

<h3>Description</h3>

<p><code><a href="#topic+loadStAttrib">loadStAttrib</a></code> is a data loading function to create an <code><a href="#topic+st_attrib-class">st_attrib</a></code> object.
<code><a href="#topic+loadStAttrib">loadStAttrib</a></code> can read stimulus attributes a <code><a href="base.html#topic+data.frame">data.frame</a></code> or a .csv file.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>loadStAttrib(object, item_attrib, file = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="st_attrib-class_+3A_object">object</code></td>
<td>
<p>set attributes. Can be a <code><a href="base.html#topic+data.frame">data.frame</a></code> or the file path of a .csv file. The content should at least include the column 'STID' referring to the column 'STID' in the <code>data</code> slot of the <code><a href="#topic+item_attrib-class">item_attrib</a></code> object.</p>
</td></tr>
<tr><td><code id="st_attrib-class_+3A_item_attrib">item_attrib</code></td>
<td>
<p>an <code><a href="#topic+item_attrib-class">item_attrib</a></code> object. Use <code><a href="#topic+loadItemAttrib">loadItemAttrib</a></code> for this.</p>
</td></tr>
<tr><td><code id="st_attrib-class_+3A_file">file</code></td>
<td>
<p>(deprecated) use <code>object</code> argument instead.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code><a href="#topic+loadStAttrib">loadStAttrib</a></code> returns a <code><a href="#topic+st_attrib-class">st_attrib</a></code> object.
</p>

<ul>
<li><p><code>data</code> a <code><a href="base.html#topic+data.frame">data.frame</a></code> containing stimulus attributes.
</p>
</li></ul>



<h3>See Also</h3>

<p><code><a href="#topic+dataset_reading">dataset_reading</a></code> for examples.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Read from data.frame:
itempool_reading   &lt;- loadItemPool(itempool_reading_data)
itemattrib_reading &lt;- loadItemAttrib(itemattrib_reading_data, itempool_reading)
stimattrib_reading &lt;- loadStAttrib(stimattrib_reading_data, itemattrib_reading)

## Read from file: write to tempdir() for illustration and clean afterwards
f &lt;- file.path(tempdir(), "stimattrib_reading.csv")
write.csv(stimattrib_reading_data, f, row.names = FALSE)
stimattrib_reading &lt;- loadStAttrib(f, itemattrib_reading)
file.remove(f)

## TestDesign 1.1.0 - Deprecated arguments
## Not run: 
loadStAttrib(object = "satt.csv", item_attrib) # is equivalent to
loadStAttrib(file   = "satt.csv", item_attrib) # pre 1.1.0

## End(Not run)

</code></pre>

<hr>
<h2 id='st_attrib-operators'>Basic functions for stimulus attribute objects</h2><span id='topic+st_attrib-operators'></span><span id='topic++5B+2Cst_attrib+2Cnumeric-method'></span><span id='topic++5B+2Cst_attrib+2Cnumeric+2CANY+2CANY-method'></span><span id='topic+dim+2Cst_attrib-method'></span><span id='topic+colnames+2Cst_attrib-method'></span><span id='topic+rownames+2Cst_attrib-method'></span><span id='topic+names+2Cst_attrib-method'></span><span id='topic+as.data.frame+2Cst_attrib-method'></span>

<h3>Description</h3>

<p>Basic functions for stimulus attribute objects
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'st_attrib,numeric'
x[i, j, ..., drop = TRUE]

## S4 method for signature 'st_attrib'
dim(x)

## S4 method for signature 'st_attrib'
colnames(x)

## S4 method for signature 'st_attrib'
rownames(x)

## S4 method for signature 'st_attrib'
names(x)

## S4 method for signature 'st_attrib'
as.data.frame(x, row.names = NULL, optional = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="st_attrib-operators_+3A_x">x</code></td>
<td>
<p>a <code><a href="#topic+st_attrib-class">st_attrib</a></code> object.</p>
</td></tr>
<tr><td><code id="st_attrib-operators_+3A_i">i</code>, <code id="st_attrib-operators_+3A_j">j</code></td>
<td>
<p>indices to use in subsetting.</p>
</td></tr>
<tr><td><code id="st_attrib-operators_+3A_...">...</code></td>
<td>
<p>not used, exists for compatibility.</p>
</td></tr>
<tr><td><code id="st_attrib-operators_+3A_drop">drop</code></td>
<td>
<p>not used, exists for compatibility.</p>
</td></tr>
<tr><td><code id="st_attrib-operators_+3A_row.names">row.names</code></td>
<td>
<p>not used, exists for compatibility.</p>
</td></tr>
<tr><td><code id="st_attrib-operators_+3A_optional">optional</code></td>
<td>
<p>not used, exists for compatibility.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- stimattrib_reading
x[1:10]
dim(x)
ncol(x)
nrow(x)
colnames(x)
rownames(x)
names(x)
as.data.frame(x)

</code></pre>

<hr>
<h2 id='Static'>Run fixed-form test assembly</h2><span id='topic+Static'></span><span id='topic+Static+2Cconfig_Static-method'></span>

<h3>Description</h3>

<p><code><a href="#topic+Static">Static</a></code> is a test assembly function to perform fixed-form test assembly based on the generalized shadow-test framework.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Static(config, constraints, force_solver = FALSE)

## S4 method for signature 'config_Static'
Static(config, constraints, force_solver = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Static_+3A_config">config</code></td>
<td>
<p>a <code><a href="#topic+config_Static-class">config_Static</a></code> object. Use <code><a href="#topic+createStaticTestConfig">createStaticTestConfig</a></code> for this.</p>
</td></tr>
<tr><td><code id="Static_+3A_constraints">constraints</code></td>
<td>
<p>a <code><a href="#topic+constraints-class">constraints</a></code> object representing test specifications. Use <code><a href="#topic+loadConstraints">loadConstraints</a></code> for this.</p>
</td></tr>
<tr><td><code id="Static_+3A_force_solver">force_solver</code></td>
<td>
<p>if <code>TRUE</code>, do not check whether the solver is one of recommended solvers for complex problems (set-based assembly, partitioning). (default = <code>FALSE</code>)</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code><a href="#topic+Static">Static</a></code> returns a <code><a href="#topic+output_Static-class">output_Static</a></code> object containing the selected items.
</p>


<h3>References</h3>

<p>van der Linden, W. J. (2005).
<em>Linear models for optimal test design.</em>
Springer Science &amp; Business Media.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>config_science &lt;- createStaticTestConfig(
  list(
    method = "MAXINFO",
    target_location = c(-1, 1)
  )
)
solution &lt;- Static(config_science, constraints_science)

</code></pre>

<hr>
<h2 id='summary'>Extension of summary() for objects in TestDesign package</h2><span id='topic+summary'></span><span id='topic+summary+2Citem_pool-method'></span><span id='topic+summary+2Citem_attrib-method'></span><span id='topic+summary+2Cst_attrib-method'></span><span id='topic+summary+2Cconstraints-method'></span><span id='topic+summary+2Coutput_Static-method'></span><span id='topic+summary+2Coutput_Shadow_all-method'></span>

<h3>Description</h3>

<p>Extension of summary() for objects in TestDesign package
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'item_pool'
summary(object)

## S4 method for signature 'item_attrib'
summary(object)

## S4 method for signature 'st_attrib'
summary(object)

## S4 method for signature 'constraints'
summary(object)

## S4 method for signature 'output_Static'
summary(object, simple = FALSE)

## S4 method for signature 'output_Shadow_all'
summary(object, simple = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary_+3A_object">object</code></td>
<td>
<p>an object to summarize.</p>
</td></tr>
<tr><td><code id="summary_+3A_simple">simple</code></td>
<td>
<p>if <code>TRUE</code>, do not print constraints. (default = <code>FALSE</code>)</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>summary(itempool_science)
summary(itemattrib_science)

cfg &lt;- createStaticTestConfig()
solution &lt;- Static(cfg, constraints_science)
summary(solution)
summary(solution, simple = TRUE)

cfg &lt;- createShadowTestConfig()
solution &lt;- Shadow(cfg, constraints_science, true_theta = seq(-1, 1, 1))
summary(solution)
summary(solution, simple = TRUE)

</code></pre>

<hr>
<h2 id='summary-classes'>Summary classes</h2><span id='topic+summary-classes'></span><span id='topic+summary_item_pool-class'></span><span id='topic+summary_item_attrib-class'></span><span id='topic+summary_st_attrib-class'></span><span id='topic+summary_constraints-class'></span><span id='topic+summary_output_Static-class'></span><span id='topic+summary_output_Shadow_all-class'></span>

<h3>Description</h3>

<p>Summary classes
</p>

<hr>
<h2 id='test_cluster-class'>Class 'test_cluster': data cache for simulations</h2><span id='topic+test_cluster-class'></span>

<h3>Description</h3>

<p><code><a href="#topic+test_cluster-class">test_cluster</a></code> is an S4 class to represent data cache for running simulations.
Despite the name, this class does not represent a series of tests and is not related to a series of tests. That is, test length is not stored in this class.
This class is only kept for backwards compatibility.
</p>


<h3>Slots</h3>


<dl>
<dt><code>nt</code></dt><dd><p>the number of <code><a href="#topic+test-class">test</a></code> objects in this cluster.</p>
</dd>
<dt><code>tests</code></dt><dd><p>the list containing <code><a href="#topic+test-class">test</a></code> objects.</p>
</dd>
<dt><code>names</code></dt><dd><p>test ID strings for each <code><a href="#topic+test-class">test</a></code> object.</p>
</dd>
</dl>

<hr>
<h2 id='test_operators'>Basic operators for test objects</h2><span id='topic+test_operators'></span><span id='topic+subsetTest'></span><span id='topic++5B+2Ctest+2CANY-method'></span><span id='topic++5B+2Ctest+2Cnumeric+2CANY+2CANY-method'></span>

<h3>Description</h3>

<p>Create a subset of a <code><a href="#topic+test-class">test</a></code> object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>subsetTest(x, i = NULL)

## S4 method for signature 'test,ANY'
x[i, j, ..., drop = TRUE]
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="test_operators_+3A_x">x</code></td>
<td>
<p>a <code><a href="#topic+test-class">test</a></code> object.</p>
</td></tr>
<tr><td><code id="test_operators_+3A_i">i</code></td>
<td>
<p>item indices to use in subsetting.</p>
</td></tr>
<tr><td><code id="test_operators_+3A_j">j</code>, <code id="test_operators_+3A_drop">drop</code>, <code id="test_operators_+3A_...">...</code></td>
<td>
<p>not used, exists for compatibility.</p>
</td></tr>
</table>

<hr>
<h2 id='test-class'>Class 'test': data cache for simulations</h2><span id='topic+test-class'></span>

<h3>Description</h3>

<p><code><a href="#topic+test-class">test</a></code> is an S4 class to represent data cache for running simulations.
Despite the name, this class does not represent a test and is not related to a test. That is, test length is not stored in this class.
This class is only kept for backwards compatibility.
The functionality of this class is superseded by <code><a href="#topic+simulation_data_cache-class">simulation_data_cache</a></code>.
</p>


<h3>Slots</h3>


<dl>
<dt><code>pool</code></dt><dd><p>the <code><a href="#topic+item_pool-class">item_pool</a></code> object.</p>
</dd>
<dt><code>theta</code></dt><dd><p>the theta grid to use as quadrature points.</p>
</dd>
<dt><code>prob</code></dt><dd><p>the list containing item response probabilities.</p>
</dd>
<dt><code>info</code></dt><dd><p>the matrix containing item information values.</p>
</dd>
<dt><code>true_theta</code></dt><dd><p>(optional) the true theta values.</p>
</dd>
<dt><code>data</code></dt><dd><p>(optional) the matrix containing item responses.</p>
</dd>
</dl>

<hr>
<h2 id='TestDesign'>Open TestDesign app</h2><span id='topic+TestDesign'></span>

<h3>Description</h3>

<p><code><a href="#topic+TestDesign">TestDesign</a></code> is a caller function to open the Shiny interface of TestDesign package.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>TestDesign()
</code></pre>


<h3>Examples</h3>

<pre><code class='language-R'>
## Not run: 
if (interactive()) {
  TestDesign()
}

## End(Not run)

</code></pre>

<hr>
<h2 id='testSolver'>Test solver</h2><span id='topic+testSolver'></span>

<h3>Description</h3>

<p>Test solver
</p>


<h3>Usage</h3>

<pre><code class='language-R'>testSolver(solver)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="testSolver_+3A_solver">solver</code></td>
<td>
<p>a solver package name. Accepts <code>lpSolve, Rsymphony, gurobi, Rglpk</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>empty string <code>""</code> if solver works. A string containing error messages otherwise.
</p>

<hr>
<h2 id='theta_EAP'>(C++) Calculate a theta estimate using EAP (expected a posteriori) method</h2><span id='topic+theta_EAP'></span><span id='topic+theta_EAP_matrix'></span>

<h3>Description</h3>

<p><code>theta_EAP()</code> and <code>theta_EAP_matrix()</code> are functions for calculating a theta estimate using EAP (expected a posteriori) method.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>theta_EAP(theta_grid, item_parm, resp, ncat, model, prior, prior_parm)

theta_EAP_matrix(theta_grid, item_parm, resp, ncat, model, prior, prior_parm)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="theta_EAP_+3A_theta_grid">theta_grid</code></td>
<td>
<p>theta quadrature points.</p>
</td></tr>
<tr><td><code id="theta_EAP_+3A_item_parm">item_parm</code></td>
<td>
<p>a matrix containing item parameters.</p>
</td></tr>
<tr><td><code id="theta_EAP_+3A_resp">resp</code></td>
<td>
<p>responses on each item. Must be a vector for <code>theta_EAP()</code>, and a matrix for <code>theta_EAP_matrix()</code>. Each row should represent an examinee.</p>
</td></tr>
<tr><td><code id="theta_EAP_+3A_ncat">ncat</code></td>
<td>
<p>a vector containing the number of response categories of each item.</p>
</td></tr>
<tr><td><code id="theta_EAP_+3A_model">model</code></td>
<td>
<p>a vector indicating item models of each item, using </p>

<ul>
<li><p><code>1</code>: 1PL model
</p>
</li>
<li><p><code>2</code>: 2PL model
</p>
</li>
<li><p><code>3</code>: 3PL model
</p>
</li>
<li><p><code>4</code>: PC model
</p>
</li>
<li><p><code>5</code>: GPC model
</p>
</li>
<li><p><code>6</code>: GR model
</p>
</li></ul>
</td></tr>
<tr><td><code id="theta_EAP_+3A_prior">prior</code></td>
<td>
<p>an integer indicating the type of prior distribution, using </p>

<ul>
<li><p><code>1</code>: normal distribution
</p>
</li>
<li><p><code>2</code>: uniform distribution
</p>
</li></ul>
</td></tr>
<tr><td><code id="theta_EAP_+3A_prior_parm">prior_parm</code></td>
<td>
<p>a vector containing parameters for the prior distribution.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>theta_EAP()</code> and <code>theta_EAP_matrix()</code> are designed for multiple items.
</p>
<p><code>theta_EAP()</code> is designed for one examinee, and <code>theta_EAP_matrix()</code> is designed for multiple examinees.
</p>
<p>Currently supports unidimensional models.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># item parameters
item_parm &lt;- matrix(c(
  1, NA,   NA,
  1,  2,   NA,
  1,  2, 0.25,
  0,  1,   NA,
  2,  0,    1,
  2,  0,    2),
  nrow = 6,
  byrow = TRUE
)

ncat  &lt;- c(2, 2, 2, 3, 3, 3)
model &lt;- c(1, 2, 3, 4, 5, 6)

# simulate response
item_parm &lt;- as.data.frame(item_parm)
item_parm &lt;- cbind(101:106, 1:6, item_parm)
pool &lt;- loadItemPool(item_parm)
true_theta &lt;- seq(-3, 3, 1)
resp &lt;- simResp(pool, true_theta)

theta_grid &lt;- matrix(seq(-3, 3, .1), , 1)

theta_EAP(theta_grid, pool@ipar, resp[1, ], ncat, model, 1, c(1, 2))
theta_EAP_matrix(theta_grid, pool@ipar, resp, ncat, model, 1, c(1, 2))

</code></pre>

<hr>
<h2 id='theta_EB'>(C++) Calculate a theta estimate using EB (Empirical Bayes) method</h2><span id='topic+theta_EB'></span><span id='topic+theta_EB_single'></span>

<h3>Description</h3>

<p><code>theta_EB_single()</code> and <code>theta_EB()</code> are functions to calculate a theta estimate using EB (Empirical Bayes) method.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>theta_EB(
  nx,
  theta_init,
  theta_prop,
  item_parm,
  resp,
  ncat,
  model,
  prior,
  prior_parm
)

theta_EB_single(
  nx,
  theta_init,
  theta_prop,
  item_parm,
  resp,
  ncat,
  model,
  prior,
  prior_parm
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="theta_EB_+3A_nx">nx</code></td>
<td>
<p>the number of MCMC draws.</p>
</td></tr>
<tr><td><code id="theta_EB_+3A_theta_init">theta_init</code></td>
<td>
<p>the initial estimate to use.</p>
</td></tr>
<tr><td><code id="theta_EB_+3A_theta_prop">theta_prop</code></td>
<td>
<p>the SD of the proposal distribution.</p>
</td></tr>
<tr><td><code id="theta_EB_+3A_item_parm">item_parm</code></td>
<td>
<p>a matrix containing item parameters. Each row should represent an item.</p>
</td></tr>
<tr><td><code id="theta_EB_+3A_resp">resp</code></td>
<td>
<p>a vector containing responses on each item.</p>
</td></tr>
<tr><td><code id="theta_EB_+3A_ncat">ncat</code></td>
<td>
<p>a vector containing the number of response categories of each item.</p>
</td></tr>
<tr><td><code id="theta_EB_+3A_model">model</code></td>
<td>
<p>a vector indicating item models of each item, using </p>

<ul>
<li><p><code>1</code>: 1PL model
</p>
</li>
<li><p><code>2</code>: 2PL model
</p>
</li>
<li><p><code>3</code>: 3PL model
</p>
</li>
<li><p><code>4</code>: PC model
</p>
</li>
<li><p><code>5</code>: GPC model
</p>
</li>
<li><p><code>6</code>: GR model
</p>
</li></ul>
</td></tr>
<tr><td><code id="theta_EB_+3A_prior">prior</code></td>
<td>
<p>an integer indicating the type of prior distribution, using </p>

<ul>
<li><p><code>1</code>: normal distribution
</p>
</li>
<li><p><code>2</code>: uniform distribution
</p>
</li></ul>
</td></tr>
<tr><td><code id="theta_EB_+3A_prior_parm">prior_parm</code></td>
<td>
<p>a vector containing parameters for the prior distribution.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>theta_EB_single()</code> is designed for one item, and <code>theta_EB()</code> is designed for multiple items.
</p>
<p>Currently supports unidimensional models.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># item parameters
item_parm &lt;- matrix(c(
  1, NA,   NA,
  1,  2,   NA,
  1,  2, 0.25,
  0,  1,   NA,
  2,  0,    1,
  2,  0,    2),
  nrow = 6,
  byrow = TRUE
)

ncat  &lt;- c(2, 2, 2, 3, 3, 3)
model &lt;- c(1, 2, 3, 4, 5, 6)
resp  &lt;- c(0, 1, 0, 1, 0, 1)

nx &lt;- 100
theta_init &lt;- 0
theta_prop &lt;- 1.0
set.seed(1)
theta_EB_single(nx, theta_init, theta_prop, item_parm[1, ], resp[1], ncat[1], model[1], 1, c(0, 1))
theta_EB(nx, theta_init, theta_prop, item_parm, resp, ncat, model, 1, c(0, 1))

</code></pre>

<hr>
<h2 id='theta_FB'>(C++) Calculate a theta estimate using FB (Full Bayes) method</h2><span id='topic+theta_FB'></span><span id='topic+theta_FB_single'></span>

<h3>Description</h3>

<p><code>theta_FB_single()</code> and <code>theta_FB()</code> are functions to calculate a theta estimate using FB (Full Bayes) method.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>theta_FB(
  nx,
  theta_init,
  theta_prop,
  items_list,
  item_init,
  resp,
  ncat,
  model,
  prior,
  prior_parm
)

theta_FB_single(
  nx,
  theta_init,
  theta_prop,
  item_mcmc,
  item_init,
  resp,
  ncat,
  model,
  prior,
  prior_parm
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="theta_FB_+3A_nx">nx</code></td>
<td>
<p>the number of MCMC draws.</p>
</td></tr>
<tr><td><code id="theta_FB_+3A_theta_init">theta_init</code></td>
<td>
<p>the initial estimate to use.</p>
</td></tr>
<tr><td><code id="theta_FB_+3A_theta_prop">theta_prop</code></td>
<td>
<p>the SD of the proposal distribution.</p>
</td></tr>
<tr><td><code id="theta_FB_+3A_item_init">item_init</code></td>
<td>
<p>item parameter estimates. Must be a vector for <code>theta_FB_single()</code>, and a matrix for <code>theta_FB()</code>.</p>
</td></tr>
<tr><td><code id="theta_FB_+3A_resp">resp</code></td>
<td>
<p>a vector containing responses on each item.</p>
</td></tr>
<tr><td><code id="theta_FB_+3A_ncat">ncat</code></td>
<td>
<p>a vector containing the number of response categories of each item.</p>
</td></tr>
<tr><td><code id="theta_FB_+3A_model">model</code></td>
<td>
<p>a vector indicating item models of each item, using </p>

<ul>
<li><p><code>1</code>: 1PL model
</p>
</li>
<li><p><code>2</code>: 2PL model
</p>
</li>
<li><p><code>3</code>: 3PL model
</p>
</li>
<li><p><code>4</code>: PC model
</p>
</li>
<li><p><code>5</code>: GPC model
</p>
</li>
<li><p><code>6</code>: GR model
</p>
</li></ul>
</td></tr>
<tr><td><code id="theta_FB_+3A_prior">prior</code></td>
<td>
<p>an integer indicating the type of prior distribution, using </p>

<ul>
<li><p><code>1</code>: normal distribution
</p>
</li>
<li><p><code>2</code>: uniform distribution
</p>
</li></ul>
</td></tr>
<tr><td><code id="theta_FB_+3A_prior_parm">prior_parm</code></td>
<td>
<p>a vector containing parameters for the prior distribution.</p>
</td></tr>
<tr><td><code id="theta_FB_+3A_item_mcmc">item_mcmc</code>, <code id="theta_FB_+3A_items_list">items_list</code></td>
<td>
<p>sampled item parameters. Must be a matrix for <code>theta_FB_single()</code>, and a list of matrices for <code>theta_FB()</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>theta_FB_single()</code> is designed for one item, and <code>theta_FB()</code> is designed for multiple items.
</p>
<p>Currently supports unidimensional models.
</p>

<hr>
<h2 id='toggleConstraints'>Toggle constraints</h2><span id='topic+toggleConstraints'></span>

<h3>Description</h3>

<p><code><a href="#topic+toggleConstraints">toggleConstraints</a></code> is a function to toggle individual constraints in a <code><a href="#topic+constraints-class">constraints</a></code> object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>toggleConstraints(object, on = NULL, off = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="toggleConstraints_+3A_object">object</code></td>
<td>
<p>a <code><a href="#topic+constraints-class">constraints</a></code> object from <code><a href="#topic+loadConstraints">loadConstraints</a></code>.</p>
</td></tr>
<tr><td><code id="toggleConstraints_+3A_on">on</code></td>
<td>
<p>constraint indices to mark as active. Also accepts character IDs.</p>
</td></tr>
<tr><td><code id="toggleConstraints_+3A_off">off</code></td>
<td>
<p>constraint indices to mark as inactive. Also accepts character IDs.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code><a href="#topic+toggleConstraints">toggleConstraints</a></code> returns the updated <code><a href="#topic+constraints-class">constraints</a></code> object.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>constraints_science2 &lt;- toggleConstraints(constraints_science, off = 32:36)
constraints_science3 &lt;- toggleConstraints(constraints_science2, on = 32:36)
constraints_science4 &lt;- toggleConstraints(constraints_science, off = "C32")

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
