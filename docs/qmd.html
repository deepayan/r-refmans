<!DOCTYPE html><html><head><title>Help for package qmd</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {qmd}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#.adaptive_masses'><p>Returns the sizes of the adaptive bins used for the adaptive ECBC for one vector.</p></a></li>
<li><a href='#.CB_make_cumulative_df'><p>Returns a list of reverse cumulative margins of a CB copula. The nth entry is thus the copula of X1,...,Xn</p></a></li>
<li><a href='#.EACBC'><p>Calculates an empirical CB approximation with adaptive bin sizes. This will be faster on data with many ties.</p></a></li>
<li><a href='#.EACBC_nonzero'><p>Returns non 0 entries of the EACBC</p></a></li>
<li><a href='#.ECBC'><p>Calculates the empirical checkerboard approximation to some data.</p></a></li>
<li><a href='#.local_kernel_integral'><p>Computes the D1-difference of two CB matrizes on a local CB dimension</p></a></li>
<li><a href='#.random_CB'><p>Creates a random CB copula of resolution 2^steps</p></a></li>
<li><a href='#.sample_CB'><p>Generate a sample of some CB copula-</p></a></li>
<li><a href='#ECBC'><p>Compute empirical checkerboard copula in arbitrary dimension</p></a></li>
<li><a href='#feature_selection'><p>Variable selection using the qmd-dependence values</p></a></li>
<li><a href='#qmd'><p>Quantification of Multivariate Dependence</p></a></li>
<li><a href='#qmdrank'><p>Equivalent to rank(x, ties.method = &quot;max&quot;) but not as stupidly slow</p></a></li>
<li><a href='#seq_until_changes'><p>Returns a vector</p></a></li>
<li><a href='#zeta1'><p>Multivariate dependence measure</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Quantification of Multivariate Dependence</td>
</tr>
<tr>
<td>Version:</td>
<td>1.1.2</td>
</tr>
<tr>
<td>Description:</td>
<td>A multivariate copula-based dependence measure. For more information, see Griessenberger, Junker, Trutschnig (2022), On a multivariate copula-based dependence measure and its estimation, Electronic Journal of Statistics, 16, 2206-2251. </td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>Imports:</td>
<td>qad, Rcpp (&ge; 1.0.6), ggplot2, cowplot, dplyr, utils</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.1.2</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>Rcpp</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2022-08-22 06:48:50 UTC; HP</td>
</tr>
<tr>
<td>Author:</td>
<td>Nicolas Dietrich [aut, cre],
  Florian Griessenberger [aut],
  Robert R. Junker [aut],
  Valentin Petztel [aut],
  Wolfgang Trutschnig [aut]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Nicolas Dietrich &lt;nicolaspascal.dietrich@plus.ac.at&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2022-08-22 09:20:05 UTC</td>
</tr>
</table>
<hr>
<h2 id='.adaptive_masses'>Returns the sizes of the adaptive bins used for the adaptive ECBC for one vector.</h2><span id='topic+.adaptive_masses'></span>

<h3>Description</h3>

<p>Returns the sizes of the adaptive bins used for the adaptive ECBC for one vector.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.adaptive_masses(X, resolution)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id=".adaptive_masses_+3A_x">X</code></td>
<td>
<p>A vector, representing one sample of one variable</p>
</td></tr>
<tr><td><code id=".adaptive_masses_+3A_resolution">resolution</code></td>
<td>
<p>The resolution of the CB approximation</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A numeric vector of bin sizes
</p>

<hr>
<h2 id='.CB_make_cumulative_df'>Returns a list of reverse cumulative margins of a CB copula. The nth entry is thus the copula of X1,...,Xn</h2><span id='topic+.CB_make_cumulative_df'></span>

<h3>Description</h3>

<p>Returns a list of reverse cumulative margins of a CB copula. The nth entry is thus the copula of X1,...,Xn
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.CB_make_cumulative_df(CB)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id=".CB_make_cumulative_df_+3A_cb">CB</code></td>
<td>
<p>A matrix of CB weights.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of CB weight matrixes of ascending dimension
</p>

<hr>
<h2 id='.EACBC'>Calculates an empirical CB approximation with adaptive bin sizes. This will be faster on data with many ties.</h2><span id='topic+.EACBC'></span>

<h3>Description</h3>

<p>Calculates an empirical CB approximation with adaptive bin sizes. This will be faster on data with many ties.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.EACBC(X, resolution)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id=".EACBC_+3A_x">X</code></td>
<td>
<p>A nxrho matrix of n samples of rho variables</p>
</td></tr>
<tr><td><code id=".EACBC_+3A_resolution">resolution</code></td>
<td>
<p>The resolution of the CB approximation</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix of dimension resolution^rho
</p>

<hr>
<h2 id='.EACBC_nonzero'>Returns non 0 entries of the EACBC</h2><span id='topic+.EACBC_nonzero'></span>

<h3>Description</h3>

<p>Returns non 0 entries of the EACBC
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.EACBC_nonzero(X, resolution)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id=".EACBC_nonzero_+3A_x">X</code></td>
<td>
<p>A nxrho matrix of n samples of rho variables</p>
</td></tr>
<tr><td><code id=".EACBC_nonzero_+3A_resolution">resolution</code></td>
<td>
<p>The resolution of the CB approximation</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of local kernel masses
</p>

<hr>
<h2 id='.ECBC'>Calculates the empirical checkerboard approximation to some data.</h2><span id='topic+.ECBC'></span>

<h3>Description</h3>

<p>Calculates the empirical checkerboard approximation to some data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.ECBC(X, resolution)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id=".ECBC_+3A_x">X</code></td>
<td>
<p>A nxrho matrix of n samples of rho variables</p>
</td></tr>
<tr><td><code id=".ECBC_+3A_resolution">resolution</code></td>
<td>
<p>The resolution of the CB approximation</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix of dimension resolution^rho
</p>

<hr>
<h2 id='.local_kernel_integral'>Computes the D1-difference of two CB matrizes on a local CB dimension</h2><span id='topic+.local_kernel_integral'></span>

<h3>Description</h3>

<p>Computes the D1-difference of two CB matrizes on a local CB dimension
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.local_kernel_integral(k1, k2, y)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id=".local_kernel_integral_+3A_k1">k1</code></td>
<td>
<p>Vector of local CB weights of first matrix</p>
</td></tr>
<tr><td><code id=".local_kernel_integral_+3A_k2">k2</code></td>
<td>
<p>Vector of local CB weights of second matrix</p>
</td></tr>
<tr><td><code id=".local_kernel_integral_+3A_y">y</code></td>
<td>
<p>Vector indicating the bin sizes of the local dimension</p>
</td></tr>
</table>


<h3>Value</h3>

<p>number indicating the difference between k1 and k2
</p>

<hr>
<h2 id='.random_CB'>Creates a random CB copula of resolution 2^steps</h2><span id='topic+.random_CB'></span>

<h3>Description</h3>

<p>Creates a random CB copula of resolution 2^steps
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.random_CB(rho, steps, de, ie)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id=".random_CB_+3A_rho">rho</code></td>
<td>
<p>The number of variables</p>
</td></tr>
<tr><td><code id=".random_CB_+3A_steps">steps</code></td>
<td>
<p>Number of iteration steps, the final resolution will be 2^steps</p>
</td></tr>
<tr><td><code id=".random_CB_+3A_de">de</code></td>
<td>
<p>Exponent to increase dependence</p>
</td></tr>
<tr><td><code id=".random_CB_+3A_ie">ie</code></td>
<td>
<p>Exponent to increase independence</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix of dimension (2^steps)^rho
</p>

<hr>
<h2 id='.sample_CB'>Generate a sample of some CB copula-</h2><span id='topic+.sample_CB'></span>

<h3>Description</h3>

<p>Generate a sample of some CB copula-
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.sample_CB(CB, n)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id=".sample_CB_+3A_cb">CB</code></td>
<td>
<p>A weight matrix of a CB copula</p>
</td></tr>
<tr><td><code id=".sample_CB_+3A_n">n</code></td>
<td>
<p>The number of samples to be generated</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Matrix of dimension nxm where m is the dimension of CB
</p>

<hr>
<h2 id='ECBC'>Compute empirical checkerboard copula in arbitrary dimension</h2><span id='topic+ECBC'></span>

<h3>Description</h3>

<p>The function ECBC computes the mass distribution of the empirical (checkerboard) copula,
given a rho-dimensional sample X. If resolution equals sample size, the bi-linearly extended empirical copula is returned.
Note, if there are ties in the sample an adjusted empirical copula is calculated.
If bin.size is set to &quot;adaptive&quot; the sizes of the bins will be adjusted to fit the data without overspilling into neighboring bins.
This might affects the result, but is more efficient with samples having many ties as no adjustment is needed.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ECBC(X, resolution, bin.size = "fixed")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ECBC_+3A_x">X</code></td>
<td>
<p>a numeric matrix of dimension rho indicating a sample of rho variables</p>
</td></tr>
<tr><td><code id="ECBC_+3A_resolution">resolution</code></td>
<td>
<p>an integer indicating the resolution N of the checkerboard copula</p>
</td></tr>
<tr><td><code id="ECBC_+3A_bin.size">bin.size</code></td>
<td>
<p>either &quot;fixed&quot; or &quot;adaptive&quot;, indicating whether the checkerboard copula may vary its bin sizes (defaults to &quot;fixed&quot;)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>array of dimension resolution^rho.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>n &lt;- 1000
x1 &lt;- runif(n)
x2 &lt;- runif(n)
y &lt;- x1 + x2 + rnorm(n)
M &lt;- ECBC(X = cbind(x1,x2,y), resolution = 8)

</code></pre>

<hr>
<h2 id='feature_selection'>Variable selection using the qmd-dependence values</h2><span id='topic+feature_selection'></span>

<h3>Description</h3>

<p>Given a d-dimensional random vector X containing the explanatory variables and a uni-variate response variable y,
this function uses the qmd-dependence values to select the most relevant (influential) explanatory variables.
Two different methods are available and are explained in the section Details.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>feature_selection(
  X,
  y,
  method = "combVar",
  bin.size = "fixed",
  plot = TRUE,
  na.exclude = FALSE,
  max_num_features = NULL,
  plot.title = NULL,
  plot.color = "hotpink"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="feature_selection_+3A_x">X</code></td>
<td>
<p>a numeric matrix or data.frame of dimension d containing the explanatory variables</p>
</td></tr>
<tr><td><code id="feature_selection_+3A_y">y</code></td>
<td>
<p>a numeric vector containing the uni-variate response variable</p>
</td></tr>
<tr><td><code id="feature_selection_+3A_method">method</code></td>
<td>
<p>possible options are c(&quot;combVar&quot;, &quot;addVar&quot;), see Details.</p>
</td></tr>
<tr><td><code id="feature_selection_+3A_bin.size">bin.size</code></td>
<td>
<p>either &quot;fixed&quot;, &quot;adaptive&quot; or &quot;sparse.adaptive&quot;, indicating whether the checkerboard copula may vary its bin sizes (defaults to &quot;fixed&quot;). Setting this to &quot;adaptive&quot; might affect the results but will be faster if the sample has many ties.</p>
</td></tr>
<tr><td><code id="feature_selection_+3A_plot">plot</code></td>
<td>
<p>logical indicating whether the feature selection plot is printed</p>
</td></tr>
<tr><td><code id="feature_selection_+3A_na.exclude">na.exclude</code></td>
<td>
<p>logical if all rows containing NAs should be removed.</p>
</td></tr>
<tr><td><code id="feature_selection_+3A_max_num_features">max_num_features</code></td>
<td>
<p>maximal number of explanatory variables to be selected</p>
</td></tr>
<tr><td><code id="feature_selection_+3A_plot.title">plot.title</code></td>
<td>
<p>a label for the title</p>
</td></tr>
<tr><td><code id="feature_selection_+3A_plot.color">plot.color</code></td>
<td>
<p>a colour for the selected variables</p>
</td></tr>
</table>


<h3>Details</h3>

<p>method 1 (default) - &quot;combVar&quot;: computes all qmd-dependence scores, i.e., calculates the dependence of every combination of explanatory variables to the response variable y and selects for each number of explanatory variables the combination with the greatest dependence score. This procedure is computational expensive and is only available up to 15 explanatory variables.
</p>
<p>method 2 - &quot;addVar&quot;: stepwise procedure which calculates all bi-variate dependence values q(X_i,Y) and selects the variable X_j exhibiting the greatest dependence value. In the next step all three-dimensional combinations q((X_j, X_i), Y) (for every i =1,..., d and i not j) are computed and the variable exhibiting again the greatest dependence score is added. In this manner the procedure works up to dimension d.
</p>


<h3>Value</h3>

<p>a list containing a data.frame (result) and the corresponding plots.
The data.frame result contains the number of explanatory variables (nVars),
the combination of selected variables (selVars),
the dependence measure zeta1 (qmd) of the selected variables to the response y
and the resolution of the empirical checkerboard copula (ECBC_resolution).
For the method &quot;combVar&quot; the dependence value zeta1 (qmd) is returned for all combinations of explanatory variables and is sorted in decreasing order according to zeta1.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>n &lt;- 1000
x1 &lt;- runif(n)
x2 &lt;- rexp(n)
x3 &lt;- x1 + log(x2) + rnorm(n)
x4 &lt;- rnorm(n)
x5 &lt;- x4^2
x6 &lt;- x1 + x5 + rnorm(n)
x7 &lt;- 1:n
y &lt;- x2 + x4*x7 + runif(n)
X &lt;- data.frame(x1,x2,x3,x4,x5,x6,x7)
fit &lt;- feature_selection(X, y, method = "combVar", plot = TRUE)
fit &lt;- feature_selection(X, y, method = "addVar", plot = TRUE)
</code></pre>

<hr>
<h2 id='qmd'>Quantification of Multivariate Dependence</h2><span id='topic+qmd'></span>

<h3>Description</h3>

<p>Function for estimating the non-parametric copula-based multivariate measure of dependence <code class="reqn">\zeta</code>1.
This measure quantifies the extent of dependence between a d-dimensional random vector X and a uni-variate random variable y (i.e.,
it measures the influence of d explanatory variables X1,...,Xd on a univariate variable y). Further details can be found in the section Details and the corresponding references.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>qmd(
  X,
  y,
  ties.correction = FALSE,
  resolution = NULL,
  p.value = FALSE,
  R = 1000,
  print = TRUE,
  na.exclude = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="qmd_+3A_x">X</code></td>
<td>
<p>a numeric matrix or data.frame of dimension d containing the explanatory variables</p>
</td></tr>
<tr><td><code id="qmd_+3A_y">y</code></td>
<td>
<p>a numeric vector containing the uni-variate response variable</p>
</td></tr>
<tr><td><code id="qmd_+3A_ties.correction">ties.correction</code></td>
<td>
<p>logical indicating if the measure of dependence should be calculated with ties-correction (experimental version). Default = FALSE.</p>
</td></tr>
<tr><td><code id="qmd_+3A_resolution">resolution</code></td>
<td>
<p>an integer indicating the resolution N of the checkerboard aggregation. We recommend to use the default configuration (resolution = NULL), which uses the resolution N(n) = floor(n^(1/(d+1))), where d denotes the number of explanatory variables.</p>
</td></tr>
<tr><td><code id="qmd_+3A_p.value">p.value</code></td>
<td>
<p>logical indicating if a p-value is returned using permutations of Y</p>
</td></tr>
<tr><td><code id="qmd_+3A_r">R</code></td>
<td>
<p>integer indicating the number of repetitions for the calculation of the p-value (default = 1000)</p>
</td></tr>
<tr><td><code id="qmd_+3A_print">print</code></td>
<td>
<p>logical indicating whether the results of the function are printed</p>
</td></tr>
<tr><td><code id="qmd_+3A_na.exclude">na.exclude</code></td>
<td>
<p>logical if all rows containing NAs should be removed.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>In the following we will simply write q for the dependence measure <code class="reqn">\zeta</code>1. Furthermore, X denotes a random vector consisting of d random variables and y denotes a univariate random variable.
Then the theoretical dependence measure q fulfills the following essential properties of a dependence measure:
</p>

<ul>
<li><p>[N]  q(X,y) attains values in [0,1] (normalization).
</p>
</li>
<li><p>[I]  q(X,y) = 0 if and only if X and y are independent (independence).
</p>
</li>
<li><p>[C]  q(X,y) = 1 if and only if y is a function of X (complete dependence).
</p>
</li></ul>

<p>Further properties of q and the exact mathematical definition can be found in Griessenberger et al. (2022). This function qmd() contains
the empirical checkerboard-estimator (ECB-estimator), which is strongly consistent and attains always positive values between 0 and 1.
Note, that interpretation of low values has to be done with care and always under consideration of the sample size. For instance, values of 0.2 can point towards independence in small sample settings.
An additional p-value (testing for independence and being based on permutations of y) helps in order to correctly understand the dependence values.
Since independence constitutes the null hypothesis a p-value above the significance level (e.g., 0.05) indicates independence between X and y.
</p>


<h3>Value</h3>

<p>qmd returns a list object containing the following components:
</p>

<ul>
<li><p> input: data containing the explanatory variables (X)
</p>
</li>
<li><p> output: data containing the response (y)
</p>
</li>
<li><p> q(X,y): dependence measure indicating the extent of dependence between X and y
</p>
</li>
<li><p> results: data.frame containing the dependence measure and the corresponding p-value
</p>
</li>
<li><p> resolution: an integer indicating the resolution of the aggregated checkerboard copula
</p>
</li>
<li><p> Sample size
</p>
</li></ul>



<h3>References</h3>

<p>Griessenberger, F., Junker, R.R. and Trutschnig, W. (2022). On a multivariate copula-based dependence measure and its estimation, Electronic Journal of Statistics, 16, 2206-2251.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#(complete dependence for dimension 4)
n &lt;- 300
x1 &lt;- runif(n)
x2 &lt;- runif(n)
x3 &lt;- x1 + x2 + rnorm(n)
y &lt;- x1 + x2 + x3
qmd(X = cbind(x1,x2,x3), y = y, p.value = TRUE)

#(independence for dimension 4)
n &lt;- 500
x1 &lt;- runif(n)
x2 &lt;- runif(n)
x3 &lt;- x1 + x2 + rnorm(n)
y &lt;- runif(n)
qmd(X = cbind(x1,x2,x3), y = y, p.value = TRUE)

#(binary output (classification) for dimension 3)
n &lt;- 500
x1 &lt;- runif(n)
x2 &lt;- runif(n)
y &lt;- ifelse(x1 + x2 &lt; 1, 0, 1)
qmd(X = cbind(x1,x2), y = y, p.value = TRUE)
#(independence)
y &lt;- runif(n)
qmd(X = cbind(x1,x2), y = y, p.value = TRUE)
</code></pre>

<hr>
<h2 id='qmdrank'>Equivalent to rank(x, ties.method = &quot;max&quot;) but not as stupidly slow</h2><span id='topic+qmdrank'></span>

<h3>Description</h3>

<p>Equivalent to rank(x, ties.method = &quot;max&quot;) but not as stupidly slow
</p>


<h3>Usage</h3>

<pre><code class='language-R'>qmdrank(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="qmdrank_+3A_x">x</code></td>
<td>
<p>A numeric vector</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An integer vector specifying for each value in x the rank
within x. If one value appears multiple time the maximum
is used.
</p>

<hr>
<h2 id='seq_until_changes'>Returns a vector</h2><span id='topic+seq_until_changes'></span>

<h3>Description</h3>

<p>Returns a vector
</p>


<h3>Usage</h3>

<pre><code class='language-R'>seq_until_changes(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="seq_until_changes_+3A_x">x</code></td>
<td>
<p>A usually sorted vector</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A sequence along x. If consecutive values in x are equal the maximal value is used.
</p>

<hr>
<h2 id='zeta1'>Multivariate dependence measure</h2><span id='topic+zeta1'></span>

<h3>Description</h3>

<p>Function for estimating the non-parametric copula-based multivariate measure of dependence <code class="reqn">\zeta</code>1.
This measure quantifies the extent of dependence between a d-dimensional random vector X and a uni-variate random variable y (i.e.,
it measures the influence of d explanatory variables X1,...,Xd on a univariate variable y).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>zeta1(X, y, ties.correction = FALSE, bin.size = "fixed", resolution = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="zeta1_+3A_x">X</code></td>
<td>
<p>a numeric matrix or data.frame of dimension d containing the explanatory variables</p>
</td></tr>
<tr><td><code id="zeta1_+3A_y">y</code></td>
<td>
<p>a numeric vector containing the uni-variate response variable</p>
</td></tr>
<tr><td><code id="zeta1_+3A_ties.correction">ties.correction</code></td>
<td>
<p>logical indicating if the measure of dependence should be calculated with ties-correction (experimental version). Default = FALSE.</p>
</td></tr>
<tr><td><code id="zeta1_+3A_bin.size">bin.size</code></td>
<td>
<p>either &quot;fixed&quot;, &quot;adaptive&quot; or &quot;sparse.adaptive&quot;, indicating whether the checkerboard copula may vary its bin sizes (defaults to &quot;fixed&quot;). Setting this to &quot;adaptive&quot; might affect the results but will be faster if the sample has many ties.</p>
</td></tr>
<tr><td><code id="zeta1_+3A_resolution">resolution</code></td>
<td>
<p>an integer indicating the resolution N of the checkerboard aggregation. We recommend to use the default configuration (resolution = NULL), which uses the resolution N(n) = floor(n^(1/(d+1))), where d denotes the number of explanatory variables.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>see function qmd(...).
</p>


<h3>Value</h3>

<p>A numeric value indicating the extent of dependence between the vector X and the variable y (or, equivalently, the influence of X on y).
</p>


<h3>References</h3>

<p>Griessenberger, F., Junker, R.R. and Trutschnig, W. (2022). On a multivariate copula-based dependence measure and its estimation, Electronic Journal of Statistics, 16, 2206-2251.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#(complete dependence for dimension 4)
n &lt;- 300
x1 &lt;- runif(n)
x2 &lt;- runif(n)
x3 &lt;- x1 + x2 + rnorm(n)
y &lt;- x1 + x2 + x3
zeta1(X = cbind(x1,x2,x3), y = y)

#(independence for dimension 4)
n &lt;- 500
x1 &lt;- runif(n)
x2 &lt;- runif(n)
x3 &lt;- x1 + x2 + rnorm(n)
y &lt;- runif(n)
zeta1(X = cbind(x1,x2,x3), y = y)

#(binary output for dimension 3)
n &lt;- 500
x1 &lt;- runif(n)
x2 &lt;- runif(n)
y &lt;- ifelse(x1 + x2 &lt; 1, 0, 1)
zeta1(X = cbind(x1,x2), y = y)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
