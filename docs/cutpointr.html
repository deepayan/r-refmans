<!DOCTYPE html><html><head><title>Help for package cutpointr</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {cutpointr}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#abs_d_ppv_npv'><p>Calculate the absolute difference of positive and negative predictive value</p></a></li>
<li><a href='#abs_d_sens_spec'><p>Calculate the absolute difference of sensitivity and specificity</p></a></li>
<li><a href='#accuracy'><p>Calculate accuracy</p></a></li>
<li><a href='#add_metric'><p>Add metrics to a cutpointr or roc_cutpointr object</p></a></li>
<li><a href='#auc'><p>Calculate AUC from a roc_cutpointr or cutpointr object</p></a></li>
<li><a href='#boot_ci'><p>Calculate bootstrap confidence intervals from a cutpointr object</p></a></li>
<li><a href='#boot_test'><p>Test for equivalence of a metric</p></a></li>
<li><a href='#cohens_kappa'><p>Calculate Cohen's Kappa</p></a></li>
<li><a href='#cutpoint'><p>Extract the cutpoints from a ROC curve generated by cutpointr</p></a></li>
<li><a href='#cutpoint_knots'><p>Calculate number of knots to use in spline smoothing</p></a></li>
<li><a href='#cutpointr'><p>Determine and evaluate optimal cutpoints</p></a></li>
<li><a href='#cutpointr_'><p>The standard evaluation version of cutpointr (deprecated)</p></a></li>
<li><a href='#F1_score'><p>Calculate the F1-score</p></a></li>
<li><a href='#false_omission_rate'><p>Calculate the false omission and false discovery rate</p></a></li>
<li><a href='#Jaccard'><p>Calculate the Jaccard Index</p></a></li>
<li><a href='#maximize_boot_metric'><p>Optimize a metric function in binary classification after bootstrapping</p></a></li>
<li><a href='#maximize_gam_metric'><p>Optimize a metric function in binary classification after smoothing via</p>
generalized additive models</a></li>
<li><a href='#maximize_loess_metric'><p>Optimize a metric function in binary classification after LOESS smoothing</p></a></li>
<li><a href='#maximize_metric'><p>Optimize a metric function in binary classification</p></a></li>
<li><a href='#maximize_spline_metric'><p>Optimize a metric function in binary classification after spline smoothing</p></a></li>
<li><a href='#metric_constrain'><p>Metrics that are constrained by another metric</p></a></li>
<li><a href='#misclassification_cost'><p>Calculate the misclassification cost</p></a></li>
<li><a href='#multi_cutpointr'><p>Calculate optimal cutpoints and further statistics for multiple predictors</p></a></li>
<li><a href='#npv'><p>Calculate the negative predictive value</p></a></li>
<li><a href='#oc_manual'><p>Set a manual cutpoint for use with cutpointr</p></a></li>
<li><a href='#oc_mean'><p>Use the sample mean as cutpoint</p></a></li>
<li><a href='#oc_median'><p>Use the sample median as cutpoint</p></a></li>
<li><a href='#oc_youden_kernel'><p>Determine an optimal cutpoint maximizing the Youden-Index based on kernel smoothed densities</p></a></li>
<li><a href='#oc_youden_normal'><p>Determine an optimal cutpoint for the Youden-Index assuming normal distributions</p></a></li>
<li><a href='#odds_ratio'><p>Calculate the odds ratio</p></a></li>
<li><a href='#p_chisquared'><p>Calculate the p-value of a chi-squared test</p></a></li>
<li><a href='#plot_cut_boot'><p>Plot the bootstrapped distribution of optimal cutpoints from a cutpointr object</p></a></li>
<li><a href='#plot_cutpointr'><p>General purpose plotting function for cutpointr or roc_cutpointr objects</p></a></li>
<li><a href='#plot_metric'><p>Plot a metric over all possible cutoffs from a cutpointr object</p></a></li>
<li><a href='#plot_metric_boot'><p>Plot the bootstrapped metric distribution from a cutpointr object</p></a></li>
<li><a href='#plot_precision_recall'><p>Precision recall plot from a cutpointr object</p></a></li>
<li><a href='#plot_roc'><p>Plot ROC curve from a cutpointr or roc_cutpointr object</p></a></li>
<li><a href='#plot_sensitivity_specificity'><p>Sensitivity and specificity plot from a cutpointr object</p></a></li>
<li><a href='#plot_x'><p>Plot the distribution of the independent variable per class from a cutpointr object</p></a></li>
<li><a href='#plot.cutpointr'><p>Plot cutpointr objects</p></a></li>
<li><a href='#plot.multi_cutpointr'><p>Plotting multi_cutpointr objects is currently not supported</p></a></li>
<li><a href='#plot.roc_cutpointr'><p>Plot ROC curve from a cutpointr or roc_cutpointr object</p></a></li>
<li><a href='#plr'><p>Calculate the positive or negative likelihood ratio</p></a></li>
<li><a href='#ppv'><p>Calculate the positive predictive value</p></a></li>
<li><a href='#precision'><p>Calculate precision</p></a></li>
<li><a href='#predict.cutpointr'><p>Predict using a cutpointr object</p></a></li>
<li><a href='#print.cutpointr'><p>Print cutpointr objects</p></a></li>
<li><a href='#print.multi_cutpointr'><p>Print multi_cutpointr objects</p></a></li>
<li><a href='#prod_ppv_npv'><p>Calculate the product of positive and negative predictive value</p></a></li>
<li><a href='#prod_sens_spec'><p>Calculate the product of sensitivity and specificity</p></a></li>
<li><a href='#prostate_nodal'><p>Nodal involvement and acid phosphatase levels in 53 prostate cancer patients</p></a></li>
<li><a href='#recall'><p>Calculate recall</p></a></li>
<li><a href='#risk_ratio'><p>Calculate the risk ratio (relative risk)</p></a></li>
<li><a href='#roc'><p>Calculate a ROC curve</p></a></li>
<li><a href='#roc01'><p>Calculate the distance between points on the ROC curve and (0,1)</p></a></li>
<li><a href='#sensitivity'><p>Calculate sensitivity</p></a></li>
<li><a href='#specificity'><p>Calculate specificity</p></a></li>
<li><a href='#suicide'><p>Suicide attempts and DSI sum scores of 532 subjects</p></a></li>
<li><a href='#sum_ppv_npv'><p>Calculate the sum of positive and negative predictive value</p></a></li>
<li><a href='#sum_sens_spec'><p>Calculate the sum of sensitivity and specificity</p></a></li>
<li><a href='#total_utility'><p>Calculate the total utility</p></a></li>
<li><a href='#tp'><p>Extract number true / false positives / negatives</p></a></li>
<li><a href='#tpr'><p>Calculate true / false positive / negative rate</p></a></li>
<li><a href='#user_span_cutpointr'><p>Calculate bandwidth for LOESS smoothing of metric functions by rule of thumb</p></a></li>
<li><a href='#youden'><p>Calculate the Youden-Index</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Determine and Evaluate Optimal Cutpoints in Binary
Classification Tasks</td>
</tr>
<tr>
<td>Version:</td>
<td>1.1.2</td>
</tr>
<tr>
<td>Date:</td>
<td>2022-04-13</td>
</tr>
<tr>
<td>Description:</td>
<td>Estimate cutpoints that optimize a specified metric in binary classification tasks
    and validate performance using bootstrapping. Some methods for more robust cutpoint
    estimation are supported, e.g. a parametric method assuming normal distributions,
    bootstrapped cutpoints, and smoothing of the metric values per cutpoint using
    Generalized Additive Models. Various plotting functions are included. For an overview
    of the package see Thiele and Hirschfeld (2021) &lt;<a href="https://doi.org/10.18637%2Fjss.v098.i11">doi:10.18637/jss.v098.i11</a>&gt;.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/thie1e/cutpointr">https://github.com/thie1e/cutpointr</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/thie1e/cutpointr/issues">https://github.com/thie1e/cutpointr/issues</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.5.0)</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>Rcpp</td>
</tr>
<tr>
<td>Imports:</td>
<td>gridExtra (&ge; 2.2.1), foreach (&ge; 1.4.3), dplyr (&ge; 0.8.0),
tidyselect (&ge; 1.1.0), tidyr (&ge; 1.0.0), purrr (&ge; 0.3.0),
tibble (&ge; 3.0.0), ggplot2 (&ge; 3.0.0), Rcpp (&ge; 0.12.12),
stats, utils, rlang (&ge; 0.4.0)</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.1.2</td>
</tr>
<tr>
<td>Suggests:</td>
<td>KernSmooth (&ge; 2.23-15), fANCOVA (&ge; 0.5-1), testthat (&ge;
1.0.2), doRNG (&ge; 1.6), doParallel (&ge; 1.0.11), knitr,
rmarkdown, mgcv (&ge; 1.8), crayon (&ge; 1.3.4), registry (&ge;
0.5-1), pkgmaker(&ge; 0.31.1), vctrs (&ge; 0.2.4)</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2022-04-13 17:35:21 UTC; Khl4v</td>
</tr>
<tr>
<td>Author:</td>
<td>Christian Thiele <a href="https://orcid.org/0000-0002-1156-5117"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [cre, aut]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Christian Thiele &lt;c.thiele@gmx-topmail.de&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2022-04-13 18:12:29 UTC</td>
</tr>
</table>
<hr>
<h2 id='abs_d_ppv_npv'>Calculate the absolute difference of positive and negative predictive value</h2><span id='topic+abs_d_ppv_npv'></span>

<h3>Description</h3>

<p>Calculate the absolute difference of positive predictive value (PPV) and
negative predictive value (NPV) from
true positives, false positives, true negatives and false negatives.
The inputs must be vectors of equal length. <br /> <br />
ppv = tp / (tp + fp) <br />
npv = tn / (tn + fn) <br />
abs\_d\_ppv\_npv = |ppv - npv| <br />
</p>


<h3>Usage</h3>

<pre><code class='language-R'>abs_d_ppv_npv(tp, fp, tn, fn, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="abs_d_ppv_npv_+3A_tp">tp</code></td>
<td>
<p>(numeric) number of true positives.</p>
</td></tr>
<tr><td><code id="abs_d_ppv_npv_+3A_fp">fp</code></td>
<td>
<p>(numeric) number of false positives.</p>
</td></tr>
<tr><td><code id="abs_d_ppv_npv_+3A_tn">tn</code></td>
<td>
<p>(numeric) number of true negatives.</p>
</td></tr>
<tr><td><code id="abs_d_ppv_npv_+3A_fn">fn</code></td>
<td>
<p>(numeric) number of false negatives.</p>
</td></tr>
<tr><td><code id="abs_d_ppv_npv_+3A_...">...</code></td>
<td>
<p>for capturing additional arguments passed by method.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p>Other metric functions: 
<code><a href="#topic+F1_score">F1_score</a>()</code>,
<code><a href="#topic+Jaccard">Jaccard</a>()</code>,
<code><a href="#topic+abs_d_sens_spec">abs_d_sens_spec</a>()</code>,
<code><a href="#topic+accuracy">accuracy</a>()</code>,
<code><a href="#topic+cohens_kappa">cohens_kappa</a>()</code>,
<code><a href="#topic+cutpoint">cutpoint</a>()</code>,
<code><a href="#topic+false_omission_rate">false_omission_rate</a>()</code>,
<code><a href="#topic+metric_constrain">metric_constrain</a>()</code>,
<code><a href="#topic+misclassification_cost">misclassification_cost</a>()</code>,
<code><a href="#topic+npv">npv</a>()</code>,
<code><a href="#topic+odds_ratio">odds_ratio</a>()</code>,
<code><a href="#topic+p_chisquared">p_chisquared</a>()</code>,
<code><a href="#topic+plr">plr</a>()</code>,
<code><a href="#topic+ppv">ppv</a>()</code>,
<code><a href="#topic+precision">precision</a>()</code>,
<code><a href="#topic+prod_ppv_npv">prod_ppv_npv</a>()</code>,
<code><a href="#topic+prod_sens_spec">prod_sens_spec</a>()</code>,
<code><a href="#topic+recall">recall</a>()</code>,
<code><a href="#topic+risk_ratio">risk_ratio</a>()</code>,
<code><a href="#topic+roc01">roc01</a>()</code>,
<code><a href="#topic+sensitivity">sensitivity</a>()</code>,
<code><a href="#topic+specificity">specificity</a>()</code>,
<code><a href="#topic+sum_ppv_npv">sum_ppv_npv</a>()</code>,
<code><a href="#topic+sum_sens_spec">sum_sens_spec</a>()</code>,
<code><a href="#topic+total_utility">total_utility</a>()</code>,
<code><a href="#topic+tpr">tpr</a>()</code>,
<code><a href="#topic+tp">tp</a>()</code>,
<code><a href="#topic+youden">youden</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>abs_d_ppv_npv(10, 5, 20, 10)
abs_d_ppv_npv(c(10, 8), c(5, 7), c(20, 12), c(10, 18))
</code></pre>

<hr>
<h2 id='abs_d_sens_spec'>Calculate the absolute difference of sensitivity and specificity</h2><span id='topic+abs_d_sens_spec'></span>

<h3>Description</h3>

<p>Calculate the absolute difference of sensitivity and specificity
from true positives, false positives, true negatives and false negatives.
The inputs must be vectors of equal length. <br />
<br />
sensitivity = tp / (tp + fn) <br />
specificity = tn / (tn + fp) <br />
abs_d_sens_spec = |sensitivity - specificity| <br />
</p>


<h3>Usage</h3>

<pre><code class='language-R'>abs_d_sens_spec(tp, fp, tn, fn, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="abs_d_sens_spec_+3A_tp">tp</code></td>
<td>
<p>(numeric) number of true positives.</p>
</td></tr>
<tr><td><code id="abs_d_sens_spec_+3A_fp">fp</code></td>
<td>
<p>(numeric) number of false positives.</p>
</td></tr>
<tr><td><code id="abs_d_sens_spec_+3A_tn">tn</code></td>
<td>
<p>(numeric) number of true negatives.</p>
</td></tr>
<tr><td><code id="abs_d_sens_spec_+3A_fn">fn</code></td>
<td>
<p>(numeric) number of false negatives.</p>
</td></tr>
<tr><td><code id="abs_d_sens_spec_+3A_...">...</code></td>
<td>
<p>for capturing additional arguments passed by method.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p>Other metric functions: 
<code><a href="#topic+F1_score">F1_score</a>()</code>,
<code><a href="#topic+Jaccard">Jaccard</a>()</code>,
<code><a href="#topic+abs_d_ppv_npv">abs_d_ppv_npv</a>()</code>,
<code><a href="#topic+accuracy">accuracy</a>()</code>,
<code><a href="#topic+cohens_kappa">cohens_kappa</a>()</code>,
<code><a href="#topic+cutpoint">cutpoint</a>()</code>,
<code><a href="#topic+false_omission_rate">false_omission_rate</a>()</code>,
<code><a href="#topic+metric_constrain">metric_constrain</a>()</code>,
<code><a href="#topic+misclassification_cost">misclassification_cost</a>()</code>,
<code><a href="#topic+npv">npv</a>()</code>,
<code><a href="#topic+odds_ratio">odds_ratio</a>()</code>,
<code><a href="#topic+p_chisquared">p_chisquared</a>()</code>,
<code><a href="#topic+plr">plr</a>()</code>,
<code><a href="#topic+ppv">ppv</a>()</code>,
<code><a href="#topic+precision">precision</a>()</code>,
<code><a href="#topic+prod_ppv_npv">prod_ppv_npv</a>()</code>,
<code><a href="#topic+prod_sens_spec">prod_sens_spec</a>()</code>,
<code><a href="#topic+recall">recall</a>()</code>,
<code><a href="#topic+risk_ratio">risk_ratio</a>()</code>,
<code><a href="#topic+roc01">roc01</a>()</code>,
<code><a href="#topic+sensitivity">sensitivity</a>()</code>,
<code><a href="#topic+specificity">specificity</a>()</code>,
<code><a href="#topic+sum_ppv_npv">sum_ppv_npv</a>()</code>,
<code><a href="#topic+sum_sens_spec">sum_sens_spec</a>()</code>,
<code><a href="#topic+total_utility">total_utility</a>()</code>,
<code><a href="#topic+tpr">tpr</a>()</code>,
<code><a href="#topic+tp">tp</a>()</code>,
<code><a href="#topic+youden">youden</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>abs_d_sens_spec(10, 5, 20, 10)
abs_d_sens_spec(c(10, 8), c(5, 7), c(20, 12), c(10, 18))
</code></pre>

<hr>
<h2 id='accuracy'>Calculate accuracy</h2><span id='topic+accuracy'></span>

<h3>Description</h3>

<p>Calculate accuracy from
true positives, false positives, true negatives and false negatives.
The inputs must be vectors of equal length. <br /> <br />
accuracy = (tp + tn) / (tp + fp + tn + fn)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>accuracy(tp, fp, tn, fn, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="accuracy_+3A_tp">tp</code></td>
<td>
<p>(numeric) number of true positives.</p>
</td></tr>
<tr><td><code id="accuracy_+3A_fp">fp</code></td>
<td>
<p>(numeric) number of false positives.</p>
</td></tr>
<tr><td><code id="accuracy_+3A_tn">tn</code></td>
<td>
<p>(numeric) number of true negatives.</p>
</td></tr>
<tr><td><code id="accuracy_+3A_fn">fn</code></td>
<td>
<p>(numeric) number of false negatives.</p>
</td></tr>
<tr><td><code id="accuracy_+3A_...">...</code></td>
<td>
<p>for capturing additional arguments passed by method.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p>Other metric functions: 
<code><a href="#topic+F1_score">F1_score</a>()</code>,
<code><a href="#topic+Jaccard">Jaccard</a>()</code>,
<code><a href="#topic+abs_d_ppv_npv">abs_d_ppv_npv</a>()</code>,
<code><a href="#topic+abs_d_sens_spec">abs_d_sens_spec</a>()</code>,
<code><a href="#topic+cohens_kappa">cohens_kappa</a>()</code>,
<code><a href="#topic+cutpoint">cutpoint</a>()</code>,
<code><a href="#topic+false_omission_rate">false_omission_rate</a>()</code>,
<code><a href="#topic+metric_constrain">metric_constrain</a>()</code>,
<code><a href="#topic+misclassification_cost">misclassification_cost</a>()</code>,
<code><a href="#topic+npv">npv</a>()</code>,
<code><a href="#topic+odds_ratio">odds_ratio</a>()</code>,
<code><a href="#topic+p_chisquared">p_chisquared</a>()</code>,
<code><a href="#topic+plr">plr</a>()</code>,
<code><a href="#topic+ppv">ppv</a>()</code>,
<code><a href="#topic+precision">precision</a>()</code>,
<code><a href="#topic+prod_ppv_npv">prod_ppv_npv</a>()</code>,
<code><a href="#topic+prod_sens_spec">prod_sens_spec</a>()</code>,
<code><a href="#topic+recall">recall</a>()</code>,
<code><a href="#topic+risk_ratio">risk_ratio</a>()</code>,
<code><a href="#topic+roc01">roc01</a>()</code>,
<code><a href="#topic+sensitivity">sensitivity</a>()</code>,
<code><a href="#topic+specificity">specificity</a>()</code>,
<code><a href="#topic+sum_ppv_npv">sum_ppv_npv</a>()</code>,
<code><a href="#topic+sum_sens_spec">sum_sens_spec</a>()</code>,
<code><a href="#topic+total_utility">total_utility</a>()</code>,
<code><a href="#topic+tpr">tpr</a>()</code>,
<code><a href="#topic+tp">tp</a>()</code>,
<code><a href="#topic+youden">youden</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>accuracy(10, 5, 20, 10)
accuracy(c(10, 8), c(5, 7), c(20, 12), c(10, 18))
</code></pre>

<hr>
<h2 id='add_metric'>Add metrics to a cutpointr or roc_cutpointr object</h2><span id='topic+add_metric'></span><span id='topic+add_metric.cutpointr'></span><span id='topic+add_metric.multi_cutpointr'></span><span id='topic+add_metric.roc_cutpointr'></span>

<h3>Description</h3>

<p>By default, the output of cutpointr includes the optimized metric and several
other metrics. This function adds further metrics. Suitable metric functions
are all metric functions that are included in the package or that comply
with those standards.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>add_metric(object, metric)

## S3 method for class 'cutpointr'
add_metric(object, metric)

## S3 method for class 'multi_cutpointr'
add_metric(object, metric)

## S3 method for class 'roc_cutpointr'
add_metric(object, metric)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="add_metric_+3A_object">object</code></td>
<td>
<p>A cutpointr or roc_cutpointr object.</p>
</td></tr>
<tr><td><code id="add_metric_+3A_metric">metric</code></td>
<td>
<p>(list) A list of metric functions to be added.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A cutpointr or roc_cutpointr object (a data.frame) with one or more added columns.
</p>


<h3>See Also</h3>

<p>Other main cutpointr functions: 
<code><a href="#topic+boot_ci">boot_ci</a>()</code>,
<code><a href="#topic+boot_test">boot_test</a>()</code>,
<code><a href="#topic+cutpointr">cutpointr</a>()</code>,
<code><a href="#topic+multi_cutpointr">multi_cutpointr</a>()</code>,
<code><a href="#topic+predict.cutpointr">predict.cutpointr</a>()</code>,
<code><a href="#topic+roc">roc</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(dplyr)
library(cutpointr)
cutpointr(suicide, dsi, suicide, gender) %&gt;%
  add_metric(list(ppv, npv)) %&gt;%
  select(optimal_cutpoint, subgroup, AUC, sum_sens_spec, ppv, npv)
</code></pre>

<hr>
<h2 id='auc'>Calculate AUC from a roc_cutpointr or cutpointr object</h2><span id='topic+auc'></span><span id='topic+auc.roc_cutpointr'></span><span id='topic+auc.cutpointr'></span>

<h3>Description</h3>

<p>Calculate the area under the ROC curve using the trapezoidal rule.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>auc(x)

## S3 method for class 'roc_cutpointr'
auc(x)

## S3 method for class 'cutpointr'
auc(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="auc_+3A_x">x</code></td>
<td>
<p>Data frame resulting from the roc() or cutpointr() function.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Numeric vector of AUC values
</p>


<h3>Source</h3>

<p>Forked from the AUC package
</p>

<hr>
<h2 id='boot_ci'>Calculate bootstrap confidence intervals from a cutpointr object</h2><span id='topic+boot_ci'></span>

<h3>Description</h3>

<p>Given a <code>cutpointr</code> object that includes bootstrap results
this function calculates a bootstrap
confidence interval for a selected variable.
Missing values are removed before calculating the quantiles. In the case
of multiple optimal cutpoints all cutpoints / metric values are included
in the calculation.
Values of the selected variable are returned for the percentiles alpha / 2
and 1 - alpha / 2. The metrics in the bootstrap data frames of
<code>cutpointr</code> are suffixed with <code>_b</code> and <code>_oob</code> to indicate
in-bag and out-of-bag, respectively. For example, to calculate quantiles
of the in-bag AUC <code>variable = AUC_b</code> should be set.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>boot_ci(x, variable, in_bag = TRUE, alpha = 0.05)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="boot_ci_+3A_x">x</code></td>
<td>
<p>A cutpointr object with bootstrap results</p>
</td></tr>
<tr><td><code id="boot_ci_+3A_variable">variable</code></td>
<td>
<p>Variable to calculate CI for</p>
</td></tr>
<tr><td><code id="boot_ci_+3A_in_bag">in_bag</code></td>
<td>
<p>Whether the in-bag or out-of-bag results should be used for testing</p>
</td></tr>
<tr><td><code id="boot_ci_+3A_alpha">alpha</code></td>
<td>
<p>Alpha level. Quantiles of the bootstrapped values are returned
for (alpha / 2) and 1 - (alpha / 2).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data frame with the columns quantile and value
</p>


<h3>See Also</h3>

<p>Other main cutpointr functions: 
<code><a href="#topic+add_metric">add_metric</a>()</code>,
<code><a href="#topic+boot_test">boot_test</a>()</code>,
<code><a href="#topic+cutpointr">cutpointr</a>()</code>,
<code><a href="#topic+multi_cutpointr">multi_cutpointr</a>()</code>,
<code><a href="#topic+predict.cutpointr">predict.cutpointr</a>()</code>,
<code><a href="#topic+roc">roc</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
opt_cut &lt;- cutpointr(suicide, dsi, suicide, gender,
  metric = youden, boot_runs = 1000)
boot_ci(opt_cut, optimal_cutpoint, in_bag = FALSE, alpha = 0.05)
boot_ci(opt_cut, acc, in_bag = FALSE, alpha = 0.05)
boot_ci(opt_cut, cohens_kappa, in_bag = FALSE, alpha = 0.05)
boot_ci(opt_cut, AUC, in_bag = TRUE, alpha = 0.05)

## End(Not run)
</code></pre>

<hr>
<h2 id='boot_test'>Test for equivalence of a metric</h2><span id='topic+boot_test'></span>

<h3>Description</h3>

<p>This function performs a significance test based on the bootstrap results
of cutpointr to test whether a chosen metric is equal between subgroups
or between two cutpointr objects. The test statistic is calculated as
the standardized difference of the metric between groups. If <code>x</code>
contains subgroups, the test is run on all possible pairings of subgroups.
An additional adjusted p-value is returned in that case.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>boot_test(x, y = NULL, variable = "AUC", in_bag = TRUE, correction = "holm")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="boot_test_+3A_x">x</code></td>
<td>
<p>A cutpointr object with bootstrap results</p>
</td></tr>
<tr><td><code id="boot_test_+3A_y">y</code></td>
<td>
<p>If x does not contain subgroups another cutpointr object</p>
</td></tr>
<tr><td><code id="boot_test_+3A_variable">variable</code></td>
<td>
<p>The variable for testing</p>
</td></tr>
<tr><td><code id="boot_test_+3A_in_bag">in_bag</code></td>
<td>
<p>Whether the in-bag or out-of-bag results should be used for testing</p>
</td></tr>
<tr><td><code id="boot_test_+3A_correction">correction</code></td>
<td>
<p>The type of correction for multiple testing. Possible
values are as in p.adjust.methods</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The variable name is looked up in the columns of the bootstrap results
where the suffixes _b and _oob indicate in-bag and out-of-bag estimates,
respectively (controlled via the <code>in_bag</code> argument).
Possible values are optimal_cutpoint, AUC,
acc, sensitivity, specificity, and the metric that was selected
in <code>cutpointr</code>. Note that there is no &quot;out-of-bag optimal cutpoint&quot;, so
when selecting <code>variable = optimal_cutpoint</code> the test will be based on
the in-bag data.
</p>
<p>The test statistic is calculated as z = (t1 - t2) / sd(t1 - t2) where t1 and
t2 are the metric values on the full sample and sd(t1 - t2) is the standard
deviation of the differences of the metric values per bootstrap repetition.
The test is two-sided.
</p>
<p>If two cutpointr objects are compared and the numbers of bootstrap repetitions
differ, the smaller number will be used.
</p>
<p>Since pairwise differences are calculated for this test, the test function
does not support multiple optimal cutpoints, because it is unclear how the
differences should be calculated in that case.
</p>


<h3>Value</h3>

<p>A data.frame (a tibble) with the columns test_var, p, d, sd_d, z
and in_bag. If a grouped cutpointr object was tested, the additional
columns subgroup1, subgroup2 and p_adj are returned.
</p>


<h3>Source</h3>

<p>Robin, X., Turck, N., Hainard, A., Tiberti, N., Lisacek, F.,
Sanchez, J.-C., &amp; Müller, M. (2011). pROC: An open-source package for R
and S+ to analyze and compare ROC curves. BMC Bioinformatics, 12(1), 77.
https://doi.org/10.1186/1471-2105-12-77
</p>


<h3>See Also</h3>

<p>Other main cutpointr functions: 
<code><a href="#topic+add_metric">add_metric</a>()</code>,
<code><a href="#topic+boot_ci">boot_ci</a>()</code>,
<code><a href="#topic+cutpointr">cutpointr</a>()</code>,
<code><a href="#topic+multi_cutpointr">multi_cutpointr</a>()</code>,
<code><a href="#topic+predict.cutpointr">predict.cutpointr</a>()</code>,
<code><a href="#topic+roc">roc</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
library(cutpointr)
library(dplyr)
set.seed(734)
cp_f &lt;- cutpointr(suicide %&gt;% filter(gender == "female"), dsi, suicide,
  boot_runs = 1000, boot_stratify = TRUE)
set.seed(928)
cp_m &lt;- cutpointr(suicide %&gt;% filter(gender == "male"), dsi, suicide,
  boot_runs = 1000, boot_stratify = TRUE)
# No significant differences:
boot_test(cp_f, cp_m, AUC, in_bag = TRUE)
boot_test(cp_f, cp_m, sum_sens_spec, in_bag = FALSE)

set.seed(135)
cp &lt;- cutpointr(suicide, dsi, suicide, gender, boot_runs = 1000,
  boot_stratify = TRUE)
# Roughly same result as above:
boot_test(cp, variable = AUC, in_bag = TRUE)
boot_test(cp, variable = sum_sens_spec, in_bag = FALSE)

## End(Not run)

</code></pre>

<hr>
<h2 id='cohens_kappa'>Calculate Cohen's Kappa</h2><span id='topic+cohens_kappa'></span>

<h3>Description</h3>

<p>Calculate the Kappa metric from
true positives, false positives, true negatives and false negatives.
The inputs must be vectors of equal length. <br /> <br />
mrg_a = ((tp + fn) * (tp + fp)) / (tp + fn + fp + tn) <br />
mrg_b = ((fp + tn) * (fn + tn)) / (tp + fn + fp + tn) <br />
expec_agree = (mrg_a + mrg_b) / (tp + fn + fp + tn) <br />
obs_agree = (tp + tn) / (tp + fn + fp + tn) <br />
cohens_kappa = (obs_agree - expec_agree) / (1 - expec_agree) <br />
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cohens_kappa(tp, fp, tn, fn, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cohens_kappa_+3A_tp">tp</code></td>
<td>
<p>(numeric) number of true positives.</p>
</td></tr>
<tr><td><code id="cohens_kappa_+3A_fp">fp</code></td>
<td>
<p>(numeric) number of false positives.</p>
</td></tr>
<tr><td><code id="cohens_kappa_+3A_tn">tn</code></td>
<td>
<p>(numeric) number of true negatives.</p>
</td></tr>
<tr><td><code id="cohens_kappa_+3A_fn">fn</code></td>
<td>
<p>(numeric) number of false negatives.</p>
</td></tr>
<tr><td><code id="cohens_kappa_+3A_...">...</code></td>
<td>
<p>for capturing additional arguments passed by method.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A numeric matrix with the column name &quot;cohens_kappa&quot;.
</p>


<h3>See Also</h3>

<p>Other metric functions: 
<code><a href="#topic+F1_score">F1_score</a>()</code>,
<code><a href="#topic+Jaccard">Jaccard</a>()</code>,
<code><a href="#topic+abs_d_ppv_npv">abs_d_ppv_npv</a>()</code>,
<code><a href="#topic+abs_d_sens_spec">abs_d_sens_spec</a>()</code>,
<code><a href="#topic+accuracy">accuracy</a>()</code>,
<code><a href="#topic+cutpoint">cutpoint</a>()</code>,
<code><a href="#topic+false_omission_rate">false_omission_rate</a>()</code>,
<code><a href="#topic+metric_constrain">metric_constrain</a>()</code>,
<code><a href="#topic+misclassification_cost">misclassification_cost</a>()</code>,
<code><a href="#topic+npv">npv</a>()</code>,
<code><a href="#topic+odds_ratio">odds_ratio</a>()</code>,
<code><a href="#topic+p_chisquared">p_chisquared</a>()</code>,
<code><a href="#topic+plr">plr</a>()</code>,
<code><a href="#topic+ppv">ppv</a>()</code>,
<code><a href="#topic+precision">precision</a>()</code>,
<code><a href="#topic+prod_ppv_npv">prod_ppv_npv</a>()</code>,
<code><a href="#topic+prod_sens_spec">prod_sens_spec</a>()</code>,
<code><a href="#topic+recall">recall</a>()</code>,
<code><a href="#topic+risk_ratio">risk_ratio</a>()</code>,
<code><a href="#topic+roc01">roc01</a>()</code>,
<code><a href="#topic+sensitivity">sensitivity</a>()</code>,
<code><a href="#topic+specificity">specificity</a>()</code>,
<code><a href="#topic+sum_ppv_npv">sum_ppv_npv</a>()</code>,
<code><a href="#topic+sum_sens_spec">sum_sens_spec</a>()</code>,
<code><a href="#topic+total_utility">total_utility</a>()</code>,
<code><a href="#topic+tpr">tpr</a>()</code>,
<code><a href="#topic+tp">tp</a>()</code>,
<code><a href="#topic+youden">youden</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>cohens_kappa(10, 5, 20, 10)
cohens_kappa(c(10, 8), c(5, 7), c(20, 12), c(10, 18))
</code></pre>

<hr>
<h2 id='cutpoint'>Extract the cutpoints from a ROC curve generated by cutpointr</h2><span id='topic+cutpoint'></span><span id='topic+cutpoints'></span>

<h3>Description</h3>

<p>This is a utility function for extracting the cutpoints from a <code>roc_cutpointr</code>
object. Mainly useful in conjunction with the <code>plot_cutpointr</code> function if
cutpoints are to be plotted on the x-axis.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cutpoint(x, ...)

cutpoints(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cutpoint_+3A_x">x</code></td>
<td>
<p>A roc_cutpointr object.</p>
</td></tr>
<tr><td><code id="cutpoint_+3A_...">...</code></td>
<td>
<p>Further arguments.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p>Other metric functions: 
<code><a href="#topic+F1_score">F1_score</a>()</code>,
<code><a href="#topic+Jaccard">Jaccard</a>()</code>,
<code><a href="#topic+abs_d_ppv_npv">abs_d_ppv_npv</a>()</code>,
<code><a href="#topic+abs_d_sens_spec">abs_d_sens_spec</a>()</code>,
<code><a href="#topic+accuracy">accuracy</a>()</code>,
<code><a href="#topic+cohens_kappa">cohens_kappa</a>()</code>,
<code><a href="#topic+false_omission_rate">false_omission_rate</a>()</code>,
<code><a href="#topic+metric_constrain">metric_constrain</a>()</code>,
<code><a href="#topic+misclassification_cost">misclassification_cost</a>()</code>,
<code><a href="#topic+npv">npv</a>()</code>,
<code><a href="#topic+odds_ratio">odds_ratio</a>()</code>,
<code><a href="#topic+p_chisquared">p_chisquared</a>()</code>,
<code><a href="#topic+plr">plr</a>()</code>,
<code><a href="#topic+ppv">ppv</a>()</code>,
<code><a href="#topic+precision">precision</a>()</code>,
<code><a href="#topic+prod_ppv_npv">prod_ppv_npv</a>()</code>,
<code><a href="#topic+prod_sens_spec">prod_sens_spec</a>()</code>,
<code><a href="#topic+recall">recall</a>()</code>,
<code><a href="#topic+risk_ratio">risk_ratio</a>()</code>,
<code><a href="#topic+roc01">roc01</a>()</code>,
<code><a href="#topic+sensitivity">sensitivity</a>()</code>,
<code><a href="#topic+specificity">specificity</a>()</code>,
<code><a href="#topic+sum_ppv_npv">sum_ppv_npv</a>()</code>,
<code><a href="#topic+sum_sens_spec">sum_sens_spec</a>()</code>,
<code><a href="#topic+total_utility">total_utility</a>()</code>,
<code><a href="#topic+tpr">tpr</a>()</code>,
<code><a href="#topic+tp">tp</a>()</code>,
<code><a href="#topic+youden">youden</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>oc &lt;- cutpointr(suicide, dsi, suicide, gender)
plot_cutpointr(oc, cutpoint, accuracy)

</code></pre>

<hr>
<h2 id='cutpoint_knots'>Calculate number of knots to use in spline smoothing</h2><span id='topic+cutpoint_knots'></span>

<h3>Description</h3>

<p>This function calculates the number of knots
when using smoothing splines for smoothing a function of metric values per
cutpoint value. The function for calculating the number of knots is equal
to <code>stats::.nknots_smspl</code> but uses the number of unique cutpoints
in the data as n.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cutpoint_knots(data, x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cutpoint_knots_+3A_data">data</code></td>
<td>
<p>A data frame</p>
</td></tr>
<tr><td><code id="cutpoint_knots_+3A_x">x</code></td>
<td>
<p>(character) The name of the predictor variable</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>cutpoint_knots(suicide, "dsi")
</code></pre>

<hr>
<h2 id='cutpointr'>Determine and evaluate optimal cutpoints</h2><span id='topic+cutpointr'></span><span id='topic+cutpointr.default'></span><span id='topic+cutpointr.numeric'></span>

<h3>Description</h3>

<p>Using predictions (or e.g. biological marker values) and binary class labels, this function
will determine &quot;optimal&quot; cutpoints using various selectable methods. The
methods for cutpoint determination can be evaluated using bootstrapping. An
estimate of the cutpoint variability and the out-of-sample performance can then
be returned with <code>summary</code> or <code>plot</code>. For an introduction to the
package please see <code>vignette("cutpointr", package = "cutpointr")</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cutpointr(...)

## Default S3 method:
cutpointr(
  data,
  x,
  class,
  subgroup = NULL,
  method = maximize_metric,
  metric = sum_sens_spec,
  pos_class = NULL,
  neg_class = NULL,
  direction = NULL,
  boot_runs = 0,
  boot_stratify = FALSE,
  use_midpoints = FALSE,
  break_ties = median,
  na.rm = FALSE,
  allowParallel = FALSE,
  silent = FALSE,
  tol_metric = 1e-06,
  ...
)

## S3 method for class 'numeric'
cutpointr(
  x,
  class,
  subgroup = NULL,
  method = maximize_metric,
  metric = sum_sens_spec,
  pos_class = NULL,
  neg_class = NULL,
  direction = NULL,
  boot_runs = 0,
  boot_stratify = FALSE,
  use_midpoints = FALSE,
  break_ties = median,
  na.rm = FALSE,
  allowParallel = FALSE,
  silent = FALSE,
  tol_metric = 1e-06,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cutpointr_+3A_...">...</code></td>
<td>
<p>Further optional arguments that will be passed to method.
minimize_metric and maximize_metric pass ... to metric.</p>
</td></tr>
<tr><td><code id="cutpointr_+3A_data">data</code></td>
<td>
<p>A data.frame with the data needed for x, class and optionally
subgroup.</p>
</td></tr>
<tr><td><code id="cutpointr_+3A_x">x</code></td>
<td>
<p>The variable name to be used for classification,
e.g. predictions. The raw vector of values if the data argument
is unused.</p>
</td></tr>
<tr><td><code id="cutpointr_+3A_class">class</code></td>
<td>
<p>The variable name indicating class membership.
If the data argument is unused, the vector of raw numeric values.</p>
</td></tr>
<tr><td><code id="cutpointr_+3A_subgroup">subgroup</code></td>
<td>
<p>An additional covariate that identifies subgroups or the raw data if
data = NULL. Separate optimal cutpoints will be determined per group.
Numeric, character and factor are allowed.</p>
</td></tr>
<tr><td><code id="cutpointr_+3A_method">method</code></td>
<td>
<p>(function) A function for determining cutpoints. Can
be user supplied or use some of the built in methods. See details.</p>
</td></tr>
<tr><td><code id="cutpointr_+3A_metric">metric</code></td>
<td>
<p>(function) The function for computing a metric when using
maximize_metric or minimize_metric as method and and for the
out-of-bag values during bootstrapping. A way of internally validating the performance.
User defined functions can be supplied, see details.</p>
</td></tr>
<tr><td><code id="cutpointr_+3A_pos_class">pos_class</code></td>
<td>
<p>(optional) The value of class that indicates the positive class.</p>
</td></tr>
<tr><td><code id="cutpointr_+3A_neg_class">neg_class</code></td>
<td>
<p>(optional) The value of class that indicates the negative class.</p>
</td></tr>
<tr><td><code id="cutpointr_+3A_direction">direction</code></td>
<td>
<p>(character, optional) Use &quot;&gt;=&quot; or &quot;&lt;=&quot; to indicate whether x
is supposed to be larger or smaller for the positive class.</p>
</td></tr>
<tr><td><code id="cutpointr_+3A_boot_runs">boot_runs</code></td>
<td>
<p>(numerical) If positive, this number of bootstrap samples
will be used to assess the variability and the out-of-sample performance.</p>
</td></tr>
<tr><td><code id="cutpointr_+3A_boot_stratify">boot_stratify</code></td>
<td>
<p>(logical) If the bootstrap is stratified, bootstrap
samples are drawn separately in both classes and then combined, keeping the
proportion of positives and negatives constant in every resample.</p>
</td></tr>
<tr><td><code id="cutpointr_+3A_use_midpoints">use_midpoints</code></td>
<td>
<p>(logical) If TRUE (default FALSE) the returned optimal
cutpoint will be the mean of the optimal cutpoint and the next highest
observation (for direction = &quot;&gt;=&quot;) or the next lowest observation
(for direction = &quot;&lt;=&quot;) which avoids biasing the optimal cutpoint.</p>
</td></tr>
<tr><td><code id="cutpointr_+3A_break_ties">break_ties</code></td>
<td>
<p>If multiple cutpoints are found, they can be summarized using
this function, e.g. mean or median. To return all cutpoints use c as the function.</p>
</td></tr>
<tr><td><code id="cutpointr_+3A_na.rm">na.rm</code></td>
<td>
<p>(logical) Set to TRUE (default FALSE) to keep only complete
cases of x, class and subgroup (if specified). Missing values with
na.rm = FALSE will raise an error.</p>
</td></tr>
<tr><td><code id="cutpointr_+3A_allowparallel">allowParallel</code></td>
<td>
<p>(logical) If TRUE, the bootstrapping will be parallelized
using foreach. A local cluster, for example, should be started manually
beforehand.</p>
</td></tr>
<tr><td><code id="cutpointr_+3A_silent">silent</code></td>
<td>
<p>(logical) If TRUE suppresses all messages.</p>
</td></tr>
<tr><td><code id="cutpointr_+3A_tol_metric">tol_metric</code></td>
<td>
<p>All cutpoints will be returned that lead to a metric
value in the interval [m_max - tol_metric, m_max + tol_metric] where
m_max is the maximum achievable metric value. This can be used to return
multiple decent cutpoints and to avoid floating-point problems. Not supported
by all <code>method</code> functions, see details.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If <code>direction</code> and/or <code>pos_class</code> and <code>neg_class</code> are not given, the function will
assume that higher values indicate the positive class and use the class
with a higher median as the positive class.
</p>
<p>This function uses tidyeval to support unquoted arguments. For programming
with <code>cutpointr</code> the operator <code>!!</code> can be used to unquote an argument, see the
examples.
</p>
<p>Different methods can be selected for determining the optimal cutpoint via
the method argument. The package includes the following method functions:
</p>

<ul>
<li> <p><code>maximize_metric</code>: Maximize the metric function
</p>
</li>
<li> <p><code>minimize_metric</code>: Minimize the metric function
</p>
</li>
<li> <p><code>maximize_loess_metric</code>: Maximize the metric function after LOESS
smoothing
</p>
</li>
<li> <p><code>minimize_loess_metric</code>: Minimize the metric function after LOESS
smoothing
</p>
</li>
<li> <p><code>maximize_spline_metric</code>: Maximize the metric function after spline
smoothing
</p>
</li>
<li> <p><code>minimize_spline_metric</code>: Minimize the metric function after spline
smoothing
</p>
</li>
<li> <p><code>maximize_boot_metric</code>: Maximize the metric function as a summary of
the optimal cutpoints in bootstrapped samples
</p>
</li>
<li> <p><code>minimize_boot_metric</code>: Minimize the metric function as a summary of
the optimal cutpoints in bootstrapped samples
</p>
</li>
<li> <p><code>oc_youden_kernel</code>: Maximize the Youden-Index after kernel smoothing
the distributions of the two classes
</p>
</li>
<li> <p><code>oc_youden_normal</code>: Maximize the Youden-Index parametrically
assuming normally distributed data in both classes
</p>
</li>
<li> <p><code>oc_manual</code>: Specify the cutpoint manually
</p>
</li></ul>

<p>User-defined functions can be supplied to method, too. As a reference,
the code of all included method functions can be accessed by simply typing
their name. To define a new method function, create a function that may take
as input(s):
</p>

<ul>
<li> <p><code>data</code>: A <code>data.frame</code> or <code>tbl_df</code>
</p>
</li>
<li> <p><code>x</code>: (character) The name of the predictor or independent variable
</p>
</li>
<li> <p><code>class</code>: (character) The name of the class or dependent variable
</p>
</li>
<li> <p><code>metric_func</code>: A function for calculating a metric, e.g. accuracy
</p>
</li>
<li> <p><code>pos_class</code>: The positive class
</p>
</li>
<li> <p><code>neg_class</code>: The negative class
</p>
</li>
<li> <p><code>direction</code>: &quot;&gt;=&quot; if the positive class has higher x values, &quot;&lt;=&quot; otherwise
</p>
</li>
<li> <p><code>tol_metric</code>: (numeric) In the built-in methods a tolerance around
the optimal metric value
</p>
</li>
<li> <p><code>use_midpoints</code>: (logical) In the built-in methods whether to
use midpoints instead of exact optimal cutpoints
</p>
</li>
<li> <p><code>...</code> Further arguments
</p>
</li></ul>

<p>The <code>...</code> argument can be used to avoid an error if not all of the above
arguments are needed or in order to pass additional arguments to method.
The function should return a <code>data.frame</code> or <code>tbl_df</code> with
one row, the column &quot;optimal_cutpoint&quot;, and an optional column with an arbitrary name
with the metric value at the optimal cutpoint.
</p>
<p>Built-in metric functions include:
</p>

<ul>
<li> <p><code>accuracy</code>: Fraction correctly classified
</p>
</li>
<li> <p><code>youden</code>: Youden- or J-Index = sensitivity + specificity - 1
</p>
</li>
<li> <p><code>sum_sens_spec</code>: sensitivity + specificity
</p>
</li>
<li> <p><code>sum_ppv_npv</code>: The sum of positive predictive value (PPV) and negative
predictive value (NPV)
</p>
</li>
<li> <p><code>prod_sens_spec</code>: sensitivity * specificity
</p>
</li>
<li> <p><code>prod_ppv_npv</code>: The product of positive predictive value (PPV) and
negative predictive value (NPV)
</p>
</li>
<li> <p><code>cohens_kappa</code>: Cohen's Kappa
</p>
</li>
<li> <p><code>abs_d_sens_spec</code>: The absolute difference between
sensitivity and specificity
</p>
</li>
<li> <p><code>roc01</code>: Distance to the point (0,1) on ROC space
</p>
</li>
<li> <p><code>abs_d_ppv_npv</code>: The absolute difference between positive predictive
value (PPV) and negative predictive value (NPV)
</p>
</li>
<li> <p><code>p_chisquared</code>: The p-value of a chi-squared test on the confusion
matrix of predictions and observations
</p>
</li>
<li> <p><code>odds_ratio</code>: The odds ratio calculated as (TP / FP) / (FN / TN)
</p>
</li>
<li> <p><code>risk_ratio</code>: The risk ratio (relative risk) calculated as
(TP / (TP + FN)) / (FP / (FP + TN))
</p>
</li>
<li><p> positive and negative likelihood ratio calculated as
<code>plr</code> = true positive rate / false positive rate and
<code>nlr</code> = false negative rate / true negative rate
</p>
</li>
<li> <p><code>misclassification_cost</code>: The sum of the misclassification cost of
false positives and false negatives fp * cost_fp + fn * cost_fn.
Additional arguments to cutpointr: <code>cost_fp</code>, <code>cost_fn</code>
</p>
</li>
<li> <p><code>total_utility</code>: The total utility of true / false positives / negatives
calculated as utility_tp * TP + utility_tn * TN - cost_fp * FP - cost_fn * FN.
Additional arguments to cutpointr: <code>utility_tp</code>, <code>utility_tn</code>,
<code>cost_fp</code>, <code>cost_fn</code>
</p>
</li>
<li> <p><code>F1_score</code>: The F1-score (2 * TP) / (2 * TP + FP + FN)
</p>
</li>
<li> <p><code>sens_constrain</code>: Maximize sensitivity given a minimal value of
specificity
</p>
</li>
<li> <p><code>spec_constrain</code>: Maximize specificity given a minimal value of
sensitivity
</p>
</li>
<li> <p><code>metric_constrain</code>: Maximize a selected metric given a minimal
value of another selected metric
</p>
</li></ul>

<p>Furthermore, the following functions are included which can be used as metric
functions but are more useful for plotting purposes, for example in
plot_cutpointr, or for defining new metric functions:
<code>tp</code>, <code>fp</code>, <code>tn</code>, <code>fn</code>, <code>tpr</code>, <code>fpr</code>,
<code>tnr</code>, <code>fnr</code>, <code>false_omission_rate</code>,
<code>false_discovery_rate</code>, <code>ppv</code>, <code>npv</code>, <code>precision</code>,
<code>recall</code>, <code>sensitivity</code>, and <code>specificity</code>.
</p>
<p>User defined metric functions can be created as well which can accept the following
inputs as vectors:
</p>

<ul>
<li> <p><code>tp</code>: Vector of true positives
</p>
</li>
<li> <p><code>fp</code>: Vector of false positives
</p>
</li>
<li> <p><code>tn</code>: Vector of true negatives
</p>
</li>
<li> <p><code>fn</code>: Vector of false negatives
</p>
</li>
<li> <p><code>...</code> If the metric function is used in conjunction with any of the
maximize / minimize methods, further arguments can be passed
</p>
</li></ul>

<p>The function should return a numeric vector or a matrix or a <code>data.frame</code>
with one column. If the column is named,
the name will be included in the output and plots. Avoid using names that
are identical to the column names that are by default returned by <span class="pkg">cutpointr</span>.
</p>
<p>If <code>boot_runs</code> is positive, that number of bootstrap samples will be drawn
and the optimal cutpoint using <code>method</code> will be determined. Additionally,
as a way of internal validation, the function in <code>metric</code> will be used to
score the out-of-bag predictions using the cutpoints determined by
<code>method</code>. Various default metrics are always included in the bootstrap results.
</p>
<p>If multiple optimal cutpoints are found, the column optimal_cutpoint becomes a
list that contains the vector(s) of the optimal cutpoints.
</p>
<p>If <code>use_midpoints = TRUE</code> the mean of the optimal cutpoint and the next
highest or lowest possible cutpoint is returned, depending on <code>direction</code>.
</p>
<p>The <code>tol_metric</code> argument can be used to avoid floating-point problems
that may lead to exclusion of cutpoints that achieve the optimally achievable
metric value. Additionally, by selecting a large tolerance multiple cutpoints
can be returned that lead to decent metric values in the vicinity of the
optimal metric value. <code>tol_metric</code> is passed to metric and is only
supported by the maximization and minimization functions, i.e.
<code>maximize_metric</code>, <code>minimize_metric</code>, <code>maximize_loess_metric</code>,
<code>minimize_loess_metric</code>, <code>maximize_spline_metric</code>, and
<code>minimize_spline_metric</code>. In <code>maximize_boot_metric</code> and
<code>minimize_boot_metric</code> multiple optimal cutpoints will be passed to the
<code>summary_func</code> of these two functions.
</p>


<h3>Value</h3>

<p>A cutpointr object which is also a data.frame and tbl_df.
</p>


<h3>See Also</h3>

<p>Other main cutpointr functions: 
<code><a href="#topic+add_metric">add_metric</a>()</code>,
<code><a href="#topic+boot_ci">boot_ci</a>()</code>,
<code><a href="#topic+boot_test">boot_test</a>()</code>,
<code><a href="#topic+multi_cutpointr">multi_cutpointr</a>()</code>,
<code><a href="#topic+predict.cutpointr">predict.cutpointr</a>()</code>,
<code><a href="#topic+roc">roc</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(cutpointr)

## Optimal cutpoint for dsi
data(suicide)
opt_cut &lt;- cutpointr(suicide, dsi, suicide)
opt_cut
s_opt_cut &lt;- summary(opt_cut)
plot(opt_cut)

## Not run: 
## Predict class for new observations
predict(opt_cut, newdata = data.frame(dsi = 0:5))

## Supplying raw data, same result
cutpointr(x = suicide$dsi, class = suicide$suicide)

## direction, class labels, method and metric can be defined manually
## Again, same result
cutpointr(suicide, dsi, suicide, direction = "&gt;=", pos_class = "yes",
          method = maximize_metric, metric = youden)

## Optimal cutpoint for dsi, as before, but for the separate subgroups
opt_cut &lt;- cutpointr(suicide, dsi, suicide, gender)
opt_cut
(s_opt_cut &lt;- summary(opt_cut))
tibble:::print.tbl(s_opt_cut)

## Bootstrapping also works on individual subgroups
set.seed(30)
opt_cut &lt;- cutpointr(suicide, dsi, suicide, gender, boot_runs = 1000,
  boot_stratify = TRUE)
opt_cut
summary(opt_cut)
plot(opt_cut)

## Parallelized bootstrapping
  library(doParallel)
  library(doRNG)
  cl &lt;- makeCluster(2) # 2 cores
  registerDoParallel(cl)
  registerDoRNG(12) # Reproducible parallel loops using doRNG
  opt_cut &lt;- cutpointr(suicide, dsi, suicide, gender,
                       boot_runs = 1000, allowParallel = TRUE)
  stopCluster(cl)
  opt_cut
  plot(opt_cut)

## Robust cutpoint method using kernel smoothing for optimizing Youden-Index
opt_cut &lt;- cutpointr(suicide, dsi, suicide, gender,
                     method = oc_youden_kernel)
opt_cut

## End(Not run)



</code></pre>

<hr>
<h2 id='cutpointr_'>The standard evaluation version of cutpointr (deprecated)</h2><span id='topic+cutpointr_'></span>

<h3>Description</h3>

<p>This function is equivalent to <code>cutpointr</code> but takes only quoted arguments
for <code>x</code>, <code>class</code> and <code>subgroup</code>. This was useful before
<code>cutpointr</code> supported tidyeval.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cutpointr_(
  data,
  x,
  class,
  subgroup = NULL,
  method = maximize_metric,
  metric = sum_sens_spec,
  pos_class = NULL,
  neg_class = NULL,
  direction = NULL,
  boot_runs = 0,
  boot_stratify = FALSE,
  use_midpoints = FALSE,
  break_ties = median,
  na.rm = FALSE,
  allowParallel = FALSE,
  silent = FALSE,
  tol_metric = 1e-06,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cutpointr__+3A_data">data</code></td>
<td>
<p>A data.frame with the data needed for x, class and optionally
subgroup.</p>
</td></tr>
<tr><td><code id="cutpointr__+3A_x">x</code></td>
<td>
<p>(character) The variable name to be used for
classification, e.g. predictions or test values.</p>
</td></tr>
<tr><td><code id="cutpointr__+3A_class">class</code></td>
<td>
<p>(character) The variable name indicating class membership.</p>
</td></tr>
<tr><td><code id="cutpointr__+3A_subgroup">subgroup</code></td>
<td>
<p>(character) The variable name
of an additional covariate that identifies subgroups. Separate
optimal cutpoints will be determined per group.</p>
</td></tr>
<tr><td><code id="cutpointr__+3A_method">method</code></td>
<td>
<p>(function) A function for determining cutpoints. Can
be user supplied or use some of the built in methods. See details.</p>
</td></tr>
<tr><td><code id="cutpointr__+3A_metric">metric</code></td>
<td>
<p>(function) The function for computing a metric when using
maximize_metric or minimize_metric as method and and for the
out-of-bag values during bootstrapping. A way of internally validating the performance.
User defined functions can be supplied, see details.</p>
</td></tr>
<tr><td><code id="cutpointr__+3A_pos_class">pos_class</code></td>
<td>
<p>(optional) The value of class that indicates the positive class.</p>
</td></tr>
<tr><td><code id="cutpointr__+3A_neg_class">neg_class</code></td>
<td>
<p>(optional) The value of class that indicates the negative class.</p>
</td></tr>
<tr><td><code id="cutpointr__+3A_direction">direction</code></td>
<td>
<p>(character, optional) Use &quot;&gt;=&quot; or &quot;&lt;=&quot; to indicate whether x
is supposed to be larger or smaller for the positive class.</p>
</td></tr>
<tr><td><code id="cutpointr__+3A_boot_runs">boot_runs</code></td>
<td>
<p>(numerical) If positive, this number of bootstrap samples
will be used to assess the variability and the out-of-sample performance.</p>
</td></tr>
<tr><td><code id="cutpointr__+3A_boot_stratify">boot_stratify</code></td>
<td>
<p>(logical) If the bootstrap is stratified, bootstrap
samples are drawn separately in both classes and then combined, keeping the
proportion of positives and negatives constant in every resample.</p>
</td></tr>
<tr><td><code id="cutpointr__+3A_use_midpoints">use_midpoints</code></td>
<td>
<p>(logical) If TRUE (default FALSE) the returned optimal
cutpoint will be the mean of the optimal cutpoint and the next highest
observation (for direction = &quot;&gt;=&quot;) or the next lowest observation
(for direction = &quot;&lt;=&quot;) which avoids biasing the optimal cutpoint.</p>
</td></tr>
<tr><td><code id="cutpointr__+3A_break_ties">break_ties</code></td>
<td>
<p>If multiple cutpoints are found, they can be summarized using
this function, e.g. mean or median. To return all cutpoints use c as the function.</p>
</td></tr>
<tr><td><code id="cutpointr__+3A_na.rm">na.rm</code></td>
<td>
<p>(logical) Set to TRUE (default FALSE) to keep only complete
cases of x, class and subgroup (if specified). Missing values with
na.rm = FALSE will raise an error.</p>
</td></tr>
<tr><td><code id="cutpointr__+3A_allowparallel">allowParallel</code></td>
<td>
<p>(logical) If TRUE, the bootstrapping will be parallelized
using foreach. A local cluster, for example, should be started manually
beforehand.</p>
</td></tr>
<tr><td><code id="cutpointr__+3A_silent">silent</code></td>
<td>
<p>(logical) If TRUE suppresses all messages.</p>
</td></tr>
<tr><td><code id="cutpointr__+3A_tol_metric">tol_metric</code></td>
<td>
<p>All cutpoints will be returned that lead to a metric
value in the interval [m_max - tol_metric, m_max + tol_metric] where
m_max is the maximum achievable metric value. This can be used to return
multiple decent cutpoints and to avoid floating-point problems. Not supported
by all <code>method</code> functions, see details.</p>
</td></tr>
<tr><td><code id="cutpointr__+3A_...">...</code></td>
<td>
<p>Further optional arguments that will be passed to method.
minimize_metric and maximize_metric pass ... to metric.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>library(cutpointr)

## Optimal cutpoint for dsi
data(suicide)
opt_cut &lt;- cutpointr_(suicide, "dsi", "suicide")
opt_cut
summary(opt_cut)
plot(opt_cut)
predict(opt_cut, newdata = data.frame(dsi = 0:5))
</code></pre>

<hr>
<h2 id='F1_score'>Calculate the F1-score</h2><span id='topic+F1_score'></span>

<h3>Description</h3>

<p>Calculate the F1-score from
true positives, false positives, true negatives and false negatives.
The inputs must be vectors of equal length. <br /> <br />
F1_score = (2 * tp) / (2 * tp + fp + fn) <br />
</p>


<h3>Usage</h3>

<pre><code class='language-R'>F1_score(tp, fp, tn, fn, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="F1_score_+3A_tp">tp</code></td>
<td>
<p>(numeric) number of true positives.</p>
</td></tr>
<tr><td><code id="F1_score_+3A_fp">fp</code></td>
<td>
<p>(numeric) number of false positives.</p>
</td></tr>
<tr><td><code id="F1_score_+3A_tn">tn</code></td>
<td>
<p>(numeric) number of true negatives.</p>
</td></tr>
<tr><td><code id="F1_score_+3A_fn">fn</code></td>
<td>
<p>(numeric) number of false negatives.</p>
</td></tr>
<tr><td><code id="F1_score_+3A_...">...</code></td>
<td>
<p>for capturing additional arguments passed by method.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p>Other metric functions: 
<code><a href="#topic+Jaccard">Jaccard</a>()</code>,
<code><a href="#topic+abs_d_ppv_npv">abs_d_ppv_npv</a>()</code>,
<code><a href="#topic+abs_d_sens_spec">abs_d_sens_spec</a>()</code>,
<code><a href="#topic+accuracy">accuracy</a>()</code>,
<code><a href="#topic+cohens_kappa">cohens_kappa</a>()</code>,
<code><a href="#topic+cutpoint">cutpoint</a>()</code>,
<code><a href="#topic+false_omission_rate">false_omission_rate</a>()</code>,
<code><a href="#topic+metric_constrain">metric_constrain</a>()</code>,
<code><a href="#topic+misclassification_cost">misclassification_cost</a>()</code>,
<code><a href="#topic+npv">npv</a>()</code>,
<code><a href="#topic+odds_ratio">odds_ratio</a>()</code>,
<code><a href="#topic+p_chisquared">p_chisquared</a>()</code>,
<code><a href="#topic+plr">plr</a>()</code>,
<code><a href="#topic+ppv">ppv</a>()</code>,
<code><a href="#topic+precision">precision</a>()</code>,
<code><a href="#topic+prod_ppv_npv">prod_ppv_npv</a>()</code>,
<code><a href="#topic+prod_sens_spec">prod_sens_spec</a>()</code>,
<code><a href="#topic+recall">recall</a>()</code>,
<code><a href="#topic+risk_ratio">risk_ratio</a>()</code>,
<code><a href="#topic+roc01">roc01</a>()</code>,
<code><a href="#topic+sensitivity">sensitivity</a>()</code>,
<code><a href="#topic+specificity">specificity</a>()</code>,
<code><a href="#topic+sum_ppv_npv">sum_ppv_npv</a>()</code>,
<code><a href="#topic+sum_sens_spec">sum_sens_spec</a>()</code>,
<code><a href="#topic+total_utility">total_utility</a>()</code>,
<code><a href="#topic+tpr">tpr</a>()</code>,
<code><a href="#topic+tp">tp</a>()</code>,
<code><a href="#topic+youden">youden</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>F1_score(10, 5, 20, 10)
F1_score(c(10, 8), c(5, 7), c(20, 12), c(10, 18))
</code></pre>

<hr>
<h2 id='false_omission_rate'>Calculate the false omission and false discovery rate</h2><span id='topic+false_omission_rate'></span><span id='topic+false_discovery_rate'></span>

<h3>Description</h3>

<p>Calculate the false omission rate or false discovery rate
from true positives, false positives, true negatives and false negatives.
The inputs must be vectors of equal length. <br /> <br />
false_omission_rate = fn / (tn + fn) = 1 - npv
false_discovery_rate = fp / (tp + fp) = 1 - ppv
</p>


<h3>Usage</h3>

<pre><code class='language-R'>false_omission_rate(tp, fp, tn, fn, ...)

false_discovery_rate(tp, fp, tn, fn, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="false_omission_rate_+3A_tp">tp</code></td>
<td>
<p>(numeric) number of true positives.</p>
</td></tr>
<tr><td><code id="false_omission_rate_+3A_fp">fp</code></td>
<td>
<p>(numeric) number of false positives.</p>
</td></tr>
<tr><td><code id="false_omission_rate_+3A_tn">tn</code></td>
<td>
<p>(numeric) number of true negatives.</p>
</td></tr>
<tr><td><code id="false_omission_rate_+3A_fn">fn</code></td>
<td>
<p>(numeric) number of false negatives.</p>
</td></tr>
<tr><td><code id="false_omission_rate_+3A_...">...</code></td>
<td>
<p>for capturing additional arguments passed by method.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p>Other metric functions: 
<code><a href="#topic+F1_score">F1_score</a>()</code>,
<code><a href="#topic+Jaccard">Jaccard</a>()</code>,
<code><a href="#topic+abs_d_ppv_npv">abs_d_ppv_npv</a>()</code>,
<code><a href="#topic+abs_d_sens_spec">abs_d_sens_spec</a>()</code>,
<code><a href="#topic+accuracy">accuracy</a>()</code>,
<code><a href="#topic+cohens_kappa">cohens_kappa</a>()</code>,
<code><a href="#topic+cutpoint">cutpoint</a>()</code>,
<code><a href="#topic+metric_constrain">metric_constrain</a>()</code>,
<code><a href="#topic+misclassification_cost">misclassification_cost</a>()</code>,
<code><a href="#topic+npv">npv</a>()</code>,
<code><a href="#topic+odds_ratio">odds_ratio</a>()</code>,
<code><a href="#topic+p_chisquared">p_chisquared</a>()</code>,
<code><a href="#topic+plr">plr</a>()</code>,
<code><a href="#topic+ppv">ppv</a>()</code>,
<code><a href="#topic+precision">precision</a>()</code>,
<code><a href="#topic+prod_ppv_npv">prod_ppv_npv</a>()</code>,
<code><a href="#topic+prod_sens_spec">prod_sens_spec</a>()</code>,
<code><a href="#topic+recall">recall</a>()</code>,
<code><a href="#topic+risk_ratio">risk_ratio</a>()</code>,
<code><a href="#topic+roc01">roc01</a>()</code>,
<code><a href="#topic+sensitivity">sensitivity</a>()</code>,
<code><a href="#topic+specificity">specificity</a>()</code>,
<code><a href="#topic+sum_ppv_npv">sum_ppv_npv</a>()</code>,
<code><a href="#topic+sum_sens_spec">sum_sens_spec</a>()</code>,
<code><a href="#topic+total_utility">total_utility</a>()</code>,
<code><a href="#topic+tpr">tpr</a>()</code>,
<code><a href="#topic+tp">tp</a>()</code>,
<code><a href="#topic+youden">youden</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>false_omission_rate(10, 5, 20, 10)
false_omission_rate(c(10, 8), c(5, 7), c(20, 12), c(10, 18))
</code></pre>

<hr>
<h2 id='Jaccard'>Calculate the Jaccard Index</h2><span id='topic+Jaccard'></span>

<h3>Description</h3>

<p>Calculate the Jaccard Index from
true positives, false positives, true negatives and false negatives.
The inputs must be vectors of equal length. <br /> <br />
Jaccard = (tp) / (tp + fp + fn) <br />
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Jaccard(tp, fp, tn, fn, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Jaccard_+3A_tp">tp</code></td>
<td>
<p>(numeric) number of true positives.</p>
</td></tr>
<tr><td><code id="Jaccard_+3A_fp">fp</code></td>
<td>
<p>(numeric) number of false positives.</p>
</td></tr>
<tr><td><code id="Jaccard_+3A_tn">tn</code></td>
<td>
<p>(numeric) number of true negatives.</p>
</td></tr>
<tr><td><code id="Jaccard_+3A_fn">fn</code></td>
<td>
<p>(numeric) number of false negatives.</p>
</td></tr>
<tr><td><code id="Jaccard_+3A_...">...</code></td>
<td>
<p>for capturing additional arguments passed by method.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p>Other metric functions: 
<code><a href="#topic+F1_score">F1_score</a>()</code>,
<code><a href="#topic+abs_d_ppv_npv">abs_d_ppv_npv</a>()</code>,
<code><a href="#topic+abs_d_sens_spec">abs_d_sens_spec</a>()</code>,
<code><a href="#topic+accuracy">accuracy</a>()</code>,
<code><a href="#topic+cohens_kappa">cohens_kappa</a>()</code>,
<code><a href="#topic+cutpoint">cutpoint</a>()</code>,
<code><a href="#topic+false_omission_rate">false_omission_rate</a>()</code>,
<code><a href="#topic+metric_constrain">metric_constrain</a>()</code>,
<code><a href="#topic+misclassification_cost">misclassification_cost</a>()</code>,
<code><a href="#topic+npv">npv</a>()</code>,
<code><a href="#topic+odds_ratio">odds_ratio</a>()</code>,
<code><a href="#topic+p_chisquared">p_chisquared</a>()</code>,
<code><a href="#topic+plr">plr</a>()</code>,
<code><a href="#topic+ppv">ppv</a>()</code>,
<code><a href="#topic+precision">precision</a>()</code>,
<code><a href="#topic+prod_ppv_npv">prod_ppv_npv</a>()</code>,
<code><a href="#topic+prod_sens_spec">prod_sens_spec</a>()</code>,
<code><a href="#topic+recall">recall</a>()</code>,
<code><a href="#topic+risk_ratio">risk_ratio</a>()</code>,
<code><a href="#topic+roc01">roc01</a>()</code>,
<code><a href="#topic+sensitivity">sensitivity</a>()</code>,
<code><a href="#topic+specificity">specificity</a>()</code>,
<code><a href="#topic+sum_ppv_npv">sum_ppv_npv</a>()</code>,
<code><a href="#topic+sum_sens_spec">sum_sens_spec</a>()</code>,
<code><a href="#topic+total_utility">total_utility</a>()</code>,
<code><a href="#topic+tpr">tpr</a>()</code>,
<code><a href="#topic+tp">tp</a>()</code>,
<code><a href="#topic+youden">youden</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>Jaccard(10, 5, 20, 10)
Jaccard(c(10, 8), c(5, 7), c(20, 12), c(10, 18))
</code></pre>

<hr>
<h2 id='maximize_boot_metric'>Optimize a metric function in binary classification after bootstrapping</h2><span id='topic+maximize_boot_metric'></span><span id='topic+minimize_boot_metric'></span>

<h3>Description</h3>

<p>Given a function for computing a metric in <code>metric_func</code>, these functions
bootstrap the data <code>boot_cut</code> times and
maximize or minimize the metric by selecting an optimal cutpoint. The returned
optimal cutpoint is the result of applying <code>summary_func</code>, e.g. the mean,
to all optimal cutpoints that were determined in the bootstrap samples.
The <code>metric</code> function should accept the following inputs:
</p>

<ul>
<li> <p><code>tp</code>: vector of number of true positives
</p>
</li>
<li> <p><code>fp</code>: vector of number of false positives
</p>
</li>
<li> <p><code>tn</code>: vector of number of true negatives
</p>
</li>
<li> <p><code>fn</code>: vector of number of false negatives
</p>
</li></ul>



<h3>Usage</h3>

<pre><code class='language-R'>maximize_boot_metric(
  data,
  x,
  class,
  metric_func = youden,
  pos_class = NULL,
  neg_class = NULL,
  direction,
  summary_func = mean,
  boot_cut = 50,
  boot_stratify,
  inf_rm = TRUE,
  tol_metric,
  use_midpoints,
  ...
)

minimize_boot_metric(
  data,
  x,
  class,
  metric_func = youden,
  pos_class = NULL,
  neg_class = NULL,
  direction,
  summary_func = mean,
  boot_cut = 50,
  boot_stratify,
  inf_rm = TRUE,
  tol_metric,
  use_midpoints,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="maximize_boot_metric_+3A_data">data</code></td>
<td>
<p>A data frame or tibble in which the columns that are given in x
and class can be found.</p>
</td></tr>
<tr><td><code id="maximize_boot_metric_+3A_x">x</code></td>
<td>
<p>(character) The variable name to be used for classification,
e.g. predictions or test values.</p>
</td></tr>
<tr><td><code id="maximize_boot_metric_+3A_class">class</code></td>
<td>
<p>(character) The variable name indicating class membership.</p>
</td></tr>
<tr><td><code id="maximize_boot_metric_+3A_metric_func">metric_func</code></td>
<td>
<p>(function) A function that computes a single number
metric to be maximized. See description.</p>
</td></tr>
<tr><td><code id="maximize_boot_metric_+3A_pos_class">pos_class</code></td>
<td>
<p>The value of class that indicates the positive class.</p>
</td></tr>
<tr><td><code id="maximize_boot_metric_+3A_neg_class">neg_class</code></td>
<td>
<p>The value of class that indicates the negative class.</p>
</td></tr>
<tr><td><code id="maximize_boot_metric_+3A_direction">direction</code></td>
<td>
<p>(character) Use &quot;&gt;=&quot; or &quot;&lt;=&quot; to select whether an x value
&gt;= or &lt;= the cutoff predicts the positive class.</p>
</td></tr>
<tr><td><code id="maximize_boot_metric_+3A_summary_func">summary_func</code></td>
<td>
<p>(function) After obtaining the bootstrapped optimal
cutpoints this function, e.g. mean or median, is applied to arrive at a single cutpoint.</p>
</td></tr>
<tr><td><code id="maximize_boot_metric_+3A_boot_cut">boot_cut</code></td>
<td>
<p>(numeric) Number of bootstrap repetitions over which the mean
optimal cutpoint is calculated.</p>
</td></tr>
<tr><td><code id="maximize_boot_metric_+3A_boot_stratify">boot_stratify</code></td>
<td>
<p>(logical) If the bootstrap is stratified, bootstrap
samples are drawn in both classes and then combined, keeping the number of
positives and negatives constant in every resample.</p>
</td></tr>
<tr><td><code id="maximize_boot_metric_+3A_inf_rm">inf_rm</code></td>
<td>
<p>(logical) whether to remove infinite cutpoints before
calculating the summary.</p>
</td></tr>
<tr><td><code id="maximize_boot_metric_+3A_tol_metric">tol_metric</code></td>
<td>
<p>All cutpoints will be passed to <code>summary_func</code>
that lead to a metric
value in the interval [m_max - tol_metric, m_max + tol_metric] where
m_max is the maximum achievable metric value. This can be used to return
multiple decent cutpoints and to avoid floating-point problems.</p>
</td></tr>
<tr><td><code id="maximize_boot_metric_+3A_use_midpoints">use_midpoints</code></td>
<td>
<p>(logical) If TRUE (default FALSE) the returned optimal
cutpoint will be the mean of the optimal cutpoint and the next highest
observation (for direction = &quot;&gt;&quot;) or the next lowest observation
(for direction = &quot;&lt;&quot;) which avoids biasing the optimal cutpoint.</p>
</td></tr>
<tr><td><code id="maximize_boot_metric_+3A_...">...</code></td>
<td>
<p>To capture further arguments that are always passed to the method
function by cutpointr. The cutpointr function passes data, x, class,
metric_func, direction, pos_class and neg_class to the method function.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The above inputs are arrived at by using all unique values in <code>x</code>, Inf, and
-Inf as possible cutpoints for classifying the variable in class.
The reported metric represents the usual in-sample performance of the
determined cutpoint.
</p>


<h3>Value</h3>

<p>A tibble with the column <code>optimal_cutpoint</code>
</p>


<h3>See Also</h3>

<p>Other method functions: 
<code><a href="#topic+maximize_gam_metric">maximize_gam_metric</a>()</code>,
<code><a href="#topic+maximize_loess_metric">maximize_loess_metric</a>()</code>,
<code><a href="#topic+maximize_metric">maximize_metric</a>()</code>,
<code><a href="#topic+maximize_spline_metric">maximize_spline_metric</a>()</code>,
<code><a href="#topic+oc_manual">oc_manual</a>()</code>,
<code><a href="#topic+oc_mean">oc_mean</a>()</code>,
<code><a href="#topic+oc_median">oc_median</a>()</code>,
<code><a href="#topic+oc_youden_kernel">oc_youden_kernel</a>()</code>,
<code><a href="#topic+oc_youden_normal">oc_youden_normal</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(100)
cutpointr(suicide, dsi, suicide, method = maximize_boot_metric,
          metric = accuracy, boot_cut = 30)
set.seed(100)
cutpointr(suicide, dsi, suicide, method = minimize_boot_metric,
          metric = abs_d_sens_spec, boot_cut = 30)
</code></pre>

<hr>
<h2 id='maximize_gam_metric'>Optimize a metric function in binary classification after smoothing via
generalized additive models</h2><span id='topic+maximize_gam_metric'></span><span id='topic+minimize_gam_metric'></span>

<h3>Description</h3>

<p>Given a function for computing a metric in <code>metric_func</code>, these functions
smooth the function of metric value per cutpoint using generalized additive
models (as implemented in <span class="pkg">mgcv</span>), then
maximize or minimize the metric by selecting an optimal cutpoint. For further details
on the GAM smoothing see <code>?mgcv::gam</code>.
The <code>metric</code> function should accept the following inputs:
</p>

<ul>
<li> <p><code>tp</code>: vector of number of true positives
</p>
</li>
<li> <p><code>fp</code>: vector of number of false positives
</p>
</li>
<li> <p><code>tn</code>: vector of number of true negatives
</p>
</li>
<li> <p><code>fn</code>: vector of number of false negatives
</p>
</li></ul>



<h3>Usage</h3>

<pre><code class='language-R'>maximize_gam_metric(
  data,
  x,
  class,
  metric_func = youden,
  pos_class = NULL,
  neg_class = NULL,
  direction,
  formula = m ~ s(x.sorted),
  optimizer = c("outer", "newton"),
  tol_metric,
  use_midpoints,
  ...
)

minimize_gam_metric(
  data,
  x,
  class,
  metric_func = youden,
  pos_class = NULL,
  neg_class = NULL,
  direction,
  formula = m ~ s(x.sorted),
  optimizer = c("outer", "newton"),
  tol_metric,
  use_midpoints,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="maximize_gam_metric_+3A_data">data</code></td>
<td>
<p>A data frame or tibble in which the columns that are given in x
and class can be found.</p>
</td></tr>
<tr><td><code id="maximize_gam_metric_+3A_x">x</code></td>
<td>
<p>(character) The variable name to be used for classification,
e.g. predictions or test values.</p>
</td></tr>
<tr><td><code id="maximize_gam_metric_+3A_class">class</code></td>
<td>
<p>(character) The variable name indicating class membership.</p>
</td></tr>
<tr><td><code id="maximize_gam_metric_+3A_metric_func">metric_func</code></td>
<td>
<p>(function) A function that computes a
metric to be maximized. See description.</p>
</td></tr>
<tr><td><code id="maximize_gam_metric_+3A_pos_class">pos_class</code></td>
<td>
<p>The value of class that indicates the positive class.</p>
</td></tr>
<tr><td><code id="maximize_gam_metric_+3A_neg_class">neg_class</code></td>
<td>
<p>The value of class that indicates the negative class.</p>
</td></tr>
<tr><td><code id="maximize_gam_metric_+3A_direction">direction</code></td>
<td>
<p>(character) Use &quot;&gt;=&quot; or &quot;&lt;=&quot; to select whether an x value
&gt;= or &lt;= the cutoff predicts the positive class.</p>
</td></tr>
<tr><td><code id="maximize_gam_metric_+3A_formula">formula</code></td>
<td>
<p>A GAM formula. See <code>help("gam", package = "mgcv")</code> for
details.</p>
</td></tr>
<tr><td><code id="maximize_gam_metric_+3A_optimizer">optimizer</code></td>
<td>
<p>An array specifying the numerical optimization method to
use to optimize the smoothing parameter estimation criterion (given by method).
See <code>help("gam", package = "mgcv")</code> for details.</p>
</td></tr>
<tr><td><code id="maximize_gam_metric_+3A_tol_metric">tol_metric</code></td>
<td>
<p>All cutpoints will be returned that lead to a metric
value in the interval [m_max - tol_metric, m_max + tol_metric] where
m_max is the maximum achievable metric value. This can be used to return
multiple decent cutpoints and to avoid floating-point problems.</p>
</td></tr>
<tr><td><code id="maximize_gam_metric_+3A_use_midpoints">use_midpoints</code></td>
<td>
<p>(logical) If TRUE (default FALSE) the returned optimal
cutpoint will be the mean of the optimal cutpoint and the next highest
observation (for direction = &quot;&gt;&quot;) or the next lowest observation
(for direction = &quot;&lt;&quot;) which avoids biasing the optimal cutpoint.</p>
</td></tr>
<tr><td><code id="maximize_gam_metric_+3A_...">...</code></td>
<td>
<p>Further arguments that will be passed to metric_func or the
GAM smoother.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The above inputs are arrived at by using all unique values in <code>x</code>, Inf, and
-Inf as possible cutpoints for classifying the variable in class.
</p>


<h3>Value</h3>

<p>A tibble with the columns <code>optimal_cutpoint</code>, the corresponding metric
value and <code>roc_curve</code>, a nested tibble that includes all possible cutoffs
and the corresponding numbers of true and false positives / negatives and
all corresponding metric values.
</p>


<h3>See Also</h3>

<p>Other method functions: 
<code><a href="#topic+maximize_boot_metric">maximize_boot_metric</a>()</code>,
<code><a href="#topic+maximize_loess_metric">maximize_loess_metric</a>()</code>,
<code><a href="#topic+maximize_metric">maximize_metric</a>()</code>,
<code><a href="#topic+maximize_spline_metric">maximize_spline_metric</a>()</code>,
<code><a href="#topic+oc_manual">oc_manual</a>()</code>,
<code><a href="#topic+oc_mean">oc_mean</a>()</code>,
<code><a href="#topic+oc_median">oc_median</a>()</code>,
<code><a href="#topic+oc_youden_kernel">oc_youden_kernel</a>()</code>,
<code><a href="#topic+oc_youden_normal">oc_youden_normal</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>oc &lt;- cutpointr(suicide, dsi, suicide, gender, method = maximize_gam_metric,
metric = accuracy)
plot_metric(oc)
oc &lt;- cutpointr(suicide, dsi, suicide, gender, method = minimize_gam_metric,
metric = abs_d_sens_spec)
plot_metric(oc)
</code></pre>

<hr>
<h2 id='maximize_loess_metric'>Optimize a metric function in binary classification after LOESS smoothing</h2><span id='topic+maximize_loess_metric'></span><span id='topic+minimize_loess_metric'></span>

<h3>Description</h3>

<p>Given a function for computing a metric in <code>metric_func</code>, these functions
smooth the function of metric value per cutpoint using LOESS, then
maximize or minimize the metric by selecting an optimal cutpoint. For further details
on the LOESS smoothing see <code>?fANCOVA::loess.as</code>.
The <code>metric</code> function should accept the following inputs:
</p>

<ul>
<li> <p><code>tp</code>: vector of number of true positives
</p>
</li>
<li> <p><code>fp</code>: vector of number of false positives
</p>
</li>
<li> <p><code>tn</code>: vector of number of true negatives
</p>
</li>
<li> <p><code>fn</code>: vector of number of false negatives
</p>
</li></ul>



<h3>Usage</h3>

<pre><code class='language-R'>maximize_loess_metric(
  data,
  x,
  class,
  metric_func = youden,
  pos_class = NULL,
  neg_class = NULL,
  direction,
  criterion = "aicc",
  degree = 1,
  family = "symmetric",
  user.span = NULL,
  tol_metric,
  use_midpoints,
  ...
)

minimize_loess_metric(
  data,
  x,
  class,
  metric_func = youden,
  pos_class = NULL,
  neg_class = NULL,
  direction,
  criterion = "aicc",
  degree = 1,
  family = "symmetric",
  user.span = NULL,
  tol_metric,
  use_midpoints,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="maximize_loess_metric_+3A_data">data</code></td>
<td>
<p>A data frame or tibble in which the columns that are given in x
and class can be found.</p>
</td></tr>
<tr><td><code id="maximize_loess_metric_+3A_x">x</code></td>
<td>
<p>(character) The variable name to be used for classification,
e.g. predictions or test values.</p>
</td></tr>
<tr><td><code id="maximize_loess_metric_+3A_class">class</code></td>
<td>
<p>(character) The variable name indicating class membership.</p>
</td></tr>
<tr><td><code id="maximize_loess_metric_+3A_metric_func">metric_func</code></td>
<td>
<p>(function) A function that computes a
metric to be maximized. See description.</p>
</td></tr>
<tr><td><code id="maximize_loess_metric_+3A_pos_class">pos_class</code></td>
<td>
<p>The value of class that indicates the positive class.</p>
</td></tr>
<tr><td><code id="maximize_loess_metric_+3A_neg_class">neg_class</code></td>
<td>
<p>The value of class that indicates the negative class.</p>
</td></tr>
<tr><td><code id="maximize_loess_metric_+3A_direction">direction</code></td>
<td>
<p>(character) Use &quot;&gt;=&quot; or &quot;&lt;=&quot; to select whether an x value
&gt;= or &lt;= the cutoff predicts the positive class.</p>
</td></tr>
<tr><td><code id="maximize_loess_metric_+3A_criterion">criterion</code></td>
<td>
<p>the criterion for automatic smoothing parameter selection:
&quot;aicc&quot; denotes bias-corrected AIC criterion, &quot;gcv&quot; denotes generalized
cross-validation.</p>
</td></tr>
<tr><td><code id="maximize_loess_metric_+3A_degree">degree</code></td>
<td>
<p>the degree of the local polynomials to be used. It can be
0, 1 or 2.</p>
</td></tr>
<tr><td><code id="maximize_loess_metric_+3A_family">family</code></td>
<td>
<p>if &quot;gaussian&quot; fitting is by least-squares, and if &quot;symmetric&quot;
a re-descending M estimator is used with Tukey's biweight function.</p>
</td></tr>
<tr><td><code id="maximize_loess_metric_+3A_user.span">user.span</code></td>
<td>
<p>The user-defined parameter which controls the degree of
smoothing</p>
</td></tr>
<tr><td><code id="maximize_loess_metric_+3A_tol_metric">tol_metric</code></td>
<td>
<p>All cutpoints will be returned that lead to a metric
value in the interval [m_max - tol_metric, m_max + tol_metric] where
m_max is the maximum achievable metric value. This can be used to return
multiple decent cutpoints and to avoid floating-point problems.</p>
</td></tr>
<tr><td><code id="maximize_loess_metric_+3A_use_midpoints">use_midpoints</code></td>
<td>
<p>(logical) If TRUE (default FALSE) the returned optimal
cutpoint will be the mean of the optimal cutpoint and the next highest
observation (for direction = &quot;&gt;&quot;) or the next lowest observation
(for direction = &quot;&lt;&quot;) which avoids biasing the optimal cutpoint.</p>
</td></tr>
<tr><td><code id="maximize_loess_metric_+3A_...">...</code></td>
<td>
<p>Further arguments that will be passed to metric_func or the
loess smoother.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The above inputs are arrived at by using all unique values in <code>x</code>, Inf, and
-Inf as possible cutpoints for classifying the variable in class.
</p>


<h3>Value</h3>

<p>A tibble with the columns <code>optimal_cutpoint</code>, the corresponding metric
value and <code>roc_curve</code>, a nested tibble that includes all possible cutoffs
and the corresponding numbers of true and false positives / negatives and
all corresponding metric values.
</p>


<h3>Source</h3>

<p>Xiao-Feng Wang (2010). fANCOVA: Nonparametric Analysis of Covariance.
https://CRAN.R-project.org/package=fANCOVA
</p>
<p>Leeflang, M. M., Moons, K. G., Reitsma, J. B., &amp; Zwinderman, A. H.
(2008). Bias in sensitivity and specificity caused by data-driven selection
of optimal cutoff values: mechanisms, magnitude, and solutions.
Clinical Chemistry, (4), 729–738.
</p>


<h3>See Also</h3>

<p>Other method functions: 
<code><a href="#topic+maximize_boot_metric">maximize_boot_metric</a>()</code>,
<code><a href="#topic+maximize_gam_metric">maximize_gam_metric</a>()</code>,
<code><a href="#topic+maximize_metric">maximize_metric</a>()</code>,
<code><a href="#topic+maximize_spline_metric">maximize_spline_metric</a>()</code>,
<code><a href="#topic+oc_manual">oc_manual</a>()</code>,
<code><a href="#topic+oc_mean">oc_mean</a>()</code>,
<code><a href="#topic+oc_median">oc_median</a>()</code>,
<code><a href="#topic+oc_youden_kernel">oc_youden_kernel</a>()</code>,
<code><a href="#topic+oc_youden_normal">oc_youden_normal</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>oc &lt;- cutpointr(suicide, dsi, suicide, gender, method = maximize_loess_metric,
criterion = "aicc", family = "symmetric", degree = 2, user.span = 0.7,
metric = accuracy)
plot_metric(oc)
oc &lt;- cutpointr(suicide, dsi, suicide, gender, method = minimize_loess_metric,
criterion = "aicc", family = "symmetric", degree = 2, user.span = 0.7,
metric = misclassification_cost, cost_fp = 1, cost_fn = 10)
plot_metric(oc)
</code></pre>

<hr>
<h2 id='maximize_metric'>Optimize a metric function in binary classification</h2><span id='topic+maximize_metric'></span><span id='topic+minimize_metric'></span>

<h3>Description</h3>

<p>Given a function for computing a metric in <code>metric_func</code>, these functions
maximize or minimize that metric by selecting an optimal cutpoint.
The metric function should accept the following inputs:
</p>

<ul>
<li> <p><code>tp</code>: vector of number of true positives
</p>
</li>
<li> <p><code>fp</code>: vector of number of false positives
</p>
</li>
<li> <p><code>tn</code>: vector of number of true negatives
</p>
</li>
<li> <p><code>fn</code>: vector of number of false negatives
</p>
</li></ul>



<h3>Usage</h3>

<pre><code class='language-R'>maximize_metric(
  data,
  x,
  class,
  metric_func = youden,
  pos_class = NULL,
  neg_class = NULL,
  direction,
  tol_metric,
  use_midpoints,
  ...
)

minimize_metric(
  data,
  x,
  class,
  metric_func = youden,
  pos_class = NULL,
  neg_class = NULL,
  direction,
  tol_metric,
  use_midpoints,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="maximize_metric_+3A_data">data</code></td>
<td>
<p>A data frame or tibble in which the columns that are given in x
and class can be found.</p>
</td></tr>
<tr><td><code id="maximize_metric_+3A_x">x</code></td>
<td>
<p>(character) The variable name to be used for classification,
e.g. predictions or test values.</p>
</td></tr>
<tr><td><code id="maximize_metric_+3A_class">class</code></td>
<td>
<p>(character) The variable name indicating class membership.</p>
</td></tr>
<tr><td><code id="maximize_metric_+3A_metric_func">metric_func</code></td>
<td>
<p>(function) A function that computes a
metric to be maximized. See description.</p>
</td></tr>
<tr><td><code id="maximize_metric_+3A_pos_class">pos_class</code></td>
<td>
<p>The value of class that indicates the positive class.</p>
</td></tr>
<tr><td><code id="maximize_metric_+3A_neg_class">neg_class</code></td>
<td>
<p>The value of class that indicates the negative class.</p>
</td></tr>
<tr><td><code id="maximize_metric_+3A_direction">direction</code></td>
<td>
<p>(character) Use &quot;&gt;=&quot; or &quot;&lt;=&quot; to select whether an x value
&gt;= or &lt;= the cutoff predicts the positive class.</p>
</td></tr>
<tr><td><code id="maximize_metric_+3A_tol_metric">tol_metric</code></td>
<td>
<p>All cutpoints will be returned that lead to a metric
value in the interval [m_max - tol_metric, m_max + tol_metric] where
m_max is the maximum achievable metric value. This can be used to return
multiple decent cutpoints and to avoid floating-point problems.</p>
</td></tr>
<tr><td><code id="maximize_metric_+3A_use_midpoints">use_midpoints</code></td>
<td>
<p>(logical) If TRUE (default FALSE) the returned optimal
cutpoint will be the mean of the optimal cutpoint and the next highest
observation (for direction = &quot;&gt;&quot;) or the next lowest observation
(for direction = &quot;&lt;&quot;) which avoids biasing the optimal cutpoint.</p>
</td></tr>
<tr><td><code id="maximize_metric_+3A_...">...</code></td>
<td>
<p>Further arguments that will be passed to <code>metric_func</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The above inputs are arrived at by using all unique values in <code>x</code>, Inf, or
-Inf as possible cutpoints for classifying the variable in class.
</p>


<h3>Value</h3>

<p>A tibble with the columns <code>optimal_cutpoint</code>, the corresponding metric
value and <code>roc_curve</code>, a nested tibble that includes all possible cutoffs
and the corresponding numbers of true and false positives / negatives and
all corresponding metric values.
</p>


<h3>See Also</h3>

<p>Other method functions: 
<code><a href="#topic+maximize_boot_metric">maximize_boot_metric</a>()</code>,
<code><a href="#topic+maximize_gam_metric">maximize_gam_metric</a>()</code>,
<code><a href="#topic+maximize_loess_metric">maximize_loess_metric</a>()</code>,
<code><a href="#topic+maximize_spline_metric">maximize_spline_metric</a>()</code>,
<code><a href="#topic+oc_manual">oc_manual</a>()</code>,
<code><a href="#topic+oc_mean">oc_mean</a>()</code>,
<code><a href="#topic+oc_median">oc_median</a>()</code>,
<code><a href="#topic+oc_youden_kernel">oc_youden_kernel</a>()</code>,
<code><a href="#topic+oc_youden_normal">oc_youden_normal</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>cutpointr(suicide, dsi, suicide, method = maximize_metric, metric = accuracy)
cutpointr(suicide, dsi, suicide, method = minimize_metric, metric = abs_d_sens_spec)
</code></pre>

<hr>
<h2 id='maximize_spline_metric'>Optimize a metric function in binary classification after spline smoothing</h2><span id='topic+maximize_spline_metric'></span><span id='topic+minimize_spline_metric'></span>

<h3>Description</h3>

<p>Given a function for computing a metric in <code>metric_func</code>, this function
smoothes the function of metric value per cutpoint using smoothing splines. Then it
optimizes the metric by selecting an optimal cutpoint. For further details
on the smoothing spline see <code>?stats::smooth.spline</code>.
The <code>metric</code> function should accept the following inputs:
</p>

<ul>
<li> <p><code>tp</code>: vector of number of true positives
</p>
</li>
<li> <p><code>fp</code>: vector of number of false positives
</p>
</li>
<li> <p><code>tn</code>: vector of number of true negatives
</p>
</li>
<li> <p><code>fn</code>: vector of number of false negatives
</p>
</li></ul>



<h3>Usage</h3>

<pre><code class='language-R'>maximize_spline_metric(
  data,
  x,
  class,
  metric_func = youden,
  pos_class = NULL,
  neg_class = NULL,
  direction,
  w = NULL,
  df = NULL,
  spar = 1,
  nknots = cutpoint_knots,
  df_offset = NULL,
  penalty = 1,
  control_spar = list(),
  tol_metric,
  use_midpoints,
  ...
)

minimize_spline_metric(
  data,
  x,
  class,
  metric_func = youden,
  pos_class = NULL,
  neg_class = NULL,
  direction,
  w = NULL,
  df = NULL,
  spar = 1,
  nknots = cutpoint_knots,
  df_offset = NULL,
  penalty = 1,
  control_spar = list(),
  tol_metric,
  use_midpoints,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="maximize_spline_metric_+3A_data">data</code></td>
<td>
<p>A data frame or tibble in which the columns that are given in x
and class can be found.</p>
</td></tr>
<tr><td><code id="maximize_spline_metric_+3A_x">x</code></td>
<td>
<p>(character) The variable name to be used for classification,
e.g. predictions or test values.</p>
</td></tr>
<tr><td><code id="maximize_spline_metric_+3A_class">class</code></td>
<td>
<p>(character) The variable name indicating class membership.</p>
</td></tr>
<tr><td><code id="maximize_spline_metric_+3A_metric_func">metric_func</code></td>
<td>
<p>(function) A function that computes a
metric to be optimized. See description.</p>
</td></tr>
<tr><td><code id="maximize_spline_metric_+3A_pos_class">pos_class</code></td>
<td>
<p>The value of class that indicates the positive class.</p>
</td></tr>
<tr><td><code id="maximize_spline_metric_+3A_neg_class">neg_class</code></td>
<td>
<p>The value of class that indicates the negative class.</p>
</td></tr>
<tr><td><code id="maximize_spline_metric_+3A_direction">direction</code></td>
<td>
<p>(character) Use &quot;&gt;=&quot; or &quot;&lt;=&quot; to select whether an x value
&gt;= or &lt;= the cutoff predicts the positive class.</p>
</td></tr>
<tr><td><code id="maximize_spline_metric_+3A_w">w</code></td>
<td>
<p>Optional vector of weights of the same length as x; defaults to all 1.</p>
</td></tr>
<tr><td><code id="maximize_spline_metric_+3A_df">df</code></td>
<td>
<p>The desired equivalent number of degrees of freedom
(trace of the smoother matrix). Must be in (1,nx], nx the number of
unique x values.</p>
</td></tr>
<tr><td><code id="maximize_spline_metric_+3A_spar">spar</code></td>
<td>
<p>Smoothing parameter, typically (but not necessarily) in (0,1].
When spar is specified, the coefficient lambda of the integral of the squared
second derivative in the fit (penalized log likelihood) criterion is a
monotone function of spar.</p>
</td></tr>
<tr><td><code id="maximize_spline_metric_+3A_nknots">nknots</code></td>
<td>
<p>Integer or function giving the number of knots. The function
should accept data and x (the name of the predictor variable) as inputs.
By default nknots = 0.1 * log(n_dat / n_cut) * n_cut where n_dat is the
number of observations and n_cut the number of unique predictor values.</p>
</td></tr>
<tr><td><code id="maximize_spline_metric_+3A_df_offset">df_offset</code></td>
<td>
<p>Allows the degrees of freedom to be increased by df_offset
in the GCV criterion.</p>
</td></tr>
<tr><td><code id="maximize_spline_metric_+3A_penalty">penalty</code></td>
<td>
<p>The coefficient of the penalty for degrees of freedom in the
GCV criterion.</p>
</td></tr>
<tr><td><code id="maximize_spline_metric_+3A_control_spar">control_spar</code></td>
<td>
<p>Optional list with named components controlling the root
finding when the smoothing parameter spar is computed, i.e., NULL. See
help(&quot;smooth.spline&quot;) for further information.</p>
</td></tr>
<tr><td><code id="maximize_spline_metric_+3A_tol_metric">tol_metric</code></td>
<td>
<p>All cutpoints will be returned that lead to a metric
value in the interval [m_max - tol_metric, m_max + tol_metric] where
m_max is the maximum achievable metric value. This can be used to return
multiple decent cutpoints and to avoid floating-point problems.</p>
</td></tr>
<tr><td><code id="maximize_spline_metric_+3A_use_midpoints">use_midpoints</code></td>
<td>
<p>(logical) If TRUE (default FALSE) the returned optimal
cutpoint will be the mean of the optimal cutpoint and the next highest
observation (for direction = &quot;&gt;&quot;) or the next lowest observation
(for direction = &quot;&lt;&quot;) which avoids biasing the optimal cutpoint.</p>
</td></tr>
<tr><td><code id="maximize_spline_metric_+3A_...">...</code></td>
<td>
<p>Further arguments that will be passed to metric_func.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The above inputs are arrived at by using all unique values in <code>x</code>, Inf, and
-Inf as possible cutpoints for classifying the variable in class.
</p>


<h3>Value</h3>

<p>A tibble with the columns <code>optimal_cutpoint</code>, the corresponding metric
value and <code>roc_curve</code>, a nested tibble that includes all possible cutoffs
and the corresponding numbers of true and false positives / negatives and
all corresponding metric values.
</p>


<h3>See Also</h3>

<p>Other method functions: 
<code><a href="#topic+maximize_boot_metric">maximize_boot_metric</a>()</code>,
<code><a href="#topic+maximize_gam_metric">maximize_gam_metric</a>()</code>,
<code><a href="#topic+maximize_loess_metric">maximize_loess_metric</a>()</code>,
<code><a href="#topic+maximize_metric">maximize_metric</a>()</code>,
<code><a href="#topic+oc_manual">oc_manual</a>()</code>,
<code><a href="#topic+oc_mean">oc_mean</a>()</code>,
<code><a href="#topic+oc_median">oc_median</a>()</code>,
<code><a href="#topic+oc_youden_kernel">oc_youden_kernel</a>()</code>,
<code><a href="#topic+oc_youden_normal">oc_youden_normal</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>oc &lt;- cutpointr(suicide, dsi, suicide, gender, method = maximize_spline_metric,
df = 5, metric = accuracy)
plot_metric(oc)
</code></pre>

<hr>
<h2 id='metric_constrain'>Metrics that are constrained by another metric</h2><span id='topic+metric_constrain'></span><span id='topic+sens_constrain'></span><span id='topic+spec_constrain'></span><span id='topic+acc_constrain'></span>

<h3>Description</h3>

<p>For example, calculate sensitivity where
a lower bound (minimal desired value) for specificty can be defined. All returned
metric values for cutpoints that lead to values of the constraining metric
below the specified minimum will be zero.
The inputs must be vectors of equal length.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>metric_constrain(
  tp,
  fp,
  tn,
  fn,
  main_metric = sensitivity,
  constrain_metric = specificity,
  min_constrain = 0.5,
  suffix = "_constrain",
  ...
)

sens_constrain(
  tp,
  fp,
  tn,
  fn,
  constrain_metric = specificity,
  min_constrain = 0.5,
  ...
)

spec_constrain(
  tp,
  fp,
  tn,
  fn,
  constrain_metric = sensitivity,
  min_constrain = 0.5,
  ...
)

acc_constrain(
  tp,
  fp,
  tn,
  fn,
  constrain_metric = sensitivity,
  min_constrain = 0.5,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="metric_constrain_+3A_tp">tp</code></td>
<td>
<p>(numeric) number of true positives.</p>
</td></tr>
<tr><td><code id="metric_constrain_+3A_fp">fp</code></td>
<td>
<p>(numeric) number of false positives.</p>
</td></tr>
<tr><td><code id="metric_constrain_+3A_tn">tn</code></td>
<td>
<p>(numeric) number of true negatives.</p>
</td></tr>
<tr><td><code id="metric_constrain_+3A_fn">fn</code></td>
<td>
<p>(numeric) number of false negatives.</p>
</td></tr>
<tr><td><code id="metric_constrain_+3A_main_metric">main_metric</code></td>
<td>
<p>Metric to be optimized.</p>
</td></tr>
<tr><td><code id="metric_constrain_+3A_constrain_metric">constrain_metric</code></td>
<td>
<p>Metric for constraint.</p>
</td></tr>
<tr><td><code id="metric_constrain_+3A_min_constrain">min_constrain</code></td>
<td>
<p>Minimum desired value of constrain_metric.</p>
</td></tr>
<tr><td><code id="metric_constrain_+3A_suffix">suffix</code></td>
<td>
<p>Character string to be added to the name of main_metric.</p>
</td></tr>
<tr><td><code id="metric_constrain_+3A_...">...</code></td>
<td>
<p>for capturing additional arguments passed by method.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p>Other metric functions: 
<code><a href="#topic+F1_score">F1_score</a>()</code>,
<code><a href="#topic+Jaccard">Jaccard</a>()</code>,
<code><a href="#topic+abs_d_ppv_npv">abs_d_ppv_npv</a>()</code>,
<code><a href="#topic+abs_d_sens_spec">abs_d_sens_spec</a>()</code>,
<code><a href="#topic+accuracy">accuracy</a>()</code>,
<code><a href="#topic+cohens_kappa">cohens_kappa</a>()</code>,
<code><a href="#topic+cutpoint">cutpoint</a>()</code>,
<code><a href="#topic+false_omission_rate">false_omission_rate</a>()</code>,
<code><a href="#topic+misclassification_cost">misclassification_cost</a>()</code>,
<code><a href="#topic+npv">npv</a>()</code>,
<code><a href="#topic+odds_ratio">odds_ratio</a>()</code>,
<code><a href="#topic+p_chisquared">p_chisquared</a>()</code>,
<code><a href="#topic+plr">plr</a>()</code>,
<code><a href="#topic+ppv">ppv</a>()</code>,
<code><a href="#topic+precision">precision</a>()</code>,
<code><a href="#topic+prod_ppv_npv">prod_ppv_npv</a>()</code>,
<code><a href="#topic+prod_sens_spec">prod_sens_spec</a>()</code>,
<code><a href="#topic+recall">recall</a>()</code>,
<code><a href="#topic+risk_ratio">risk_ratio</a>()</code>,
<code><a href="#topic+roc01">roc01</a>()</code>,
<code><a href="#topic+sensitivity">sensitivity</a>()</code>,
<code><a href="#topic+specificity">specificity</a>()</code>,
<code><a href="#topic+sum_ppv_npv">sum_ppv_npv</a>()</code>,
<code><a href="#topic+sum_sens_spec">sum_sens_spec</a>()</code>,
<code><a href="#topic+total_utility">total_utility</a>()</code>,
<code><a href="#topic+tpr">tpr</a>()</code>,
<code><a href="#topic+tp">tp</a>()</code>,
<code><a href="#topic+youden">youden</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Maximum sensitivity when Positive Predictive Value (PPV) is at least 75%
library(dplyr)
library(purrr)
library(cutpointr)
cp &lt;- cutpointr(data = suicide, x = dsi, class = suicide,
method = maximize_metric,
metric = sens_constrain,
constrain_metric = ppv,
min_constrain = 0.75)
## All metric values (m) where PPV &lt; 0.75 are zero
plot_metric(cp)
cp$roc_curve
## We can confirm that PPV is indeed &gt;= 0.75
cp %&gt;%
    add_metric(list(ppv))
## We can also do so for the complete ROC curve(s)
cp %&gt;%
    pull(roc_curve) %&gt;%
    map(~ add_metric(., list(sensitivity, ppv)))

## Use the metric_constrain function for a combination of any two metrics
## Estimate optimal cutpoint for precision given a recall of at least 70%
cp &lt;- cutpointr(data = suicide, x = dsi, class = suicide,
                subgroup = gender,
                method = maximize_metric,
                metric = metric_constrain,
                main_metric = precision,
                suffix = "_constrained",
                constrain_metric = recall,
                min_constrain = 0.70)
## All metric values (m) where recall &lt; 0.7 are zero
plot_metric(cp)
## We can confirm that recall is indeed &gt;= 0.70 and that precision_constrain
## is identical to precision for the estimated cutpoint
cp %&gt;%
    add_metric(list(recall, precision))
## We can also do so for the complete ROC curve(s)
cp %&gt;%
    pull(roc_curve) %&gt;%
    map(~ add_metric(., list(recall, precision)))
</code></pre>

<hr>
<h2 id='misclassification_cost'>Calculate the misclassification cost</h2><span id='topic+misclassification_cost'></span>

<h3>Description</h3>

<p>Calculate the misclassification cost from
true positives, false positives, true negatives and false negatives.
The inputs must be vectors of equal length. <br /> <br />
misclassification_cost = cost_fp * fp + cost_fn * fn <br />
</p>


<h3>Usage</h3>

<pre><code class='language-R'>misclassification_cost(tp, fp, tn, fn, cost_fp = 1, cost_fn = 1, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="misclassification_cost_+3A_tp">tp</code></td>
<td>
<p>(numeric) number of true positives.</p>
</td></tr>
<tr><td><code id="misclassification_cost_+3A_fp">fp</code></td>
<td>
<p>(numeric) number of false positives.</p>
</td></tr>
<tr><td><code id="misclassification_cost_+3A_tn">tn</code></td>
<td>
<p>(numeric) number of true negatives.</p>
</td></tr>
<tr><td><code id="misclassification_cost_+3A_fn">fn</code></td>
<td>
<p>(numeric) number of false negatives.</p>
</td></tr>
<tr><td><code id="misclassification_cost_+3A_cost_fp">cost_fp</code></td>
<td>
<p>(numeric) the cost of a false positive</p>
</td></tr>
<tr><td><code id="misclassification_cost_+3A_cost_fn">cost_fn</code></td>
<td>
<p>(numeric) the cost of a false negative</p>
</td></tr>
<tr><td><code id="misclassification_cost_+3A_...">...</code></td>
<td>
<p>for capturing additional arguments passed by method.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p>Other metric functions: 
<code><a href="#topic+F1_score">F1_score</a>()</code>,
<code><a href="#topic+Jaccard">Jaccard</a>()</code>,
<code><a href="#topic+abs_d_ppv_npv">abs_d_ppv_npv</a>()</code>,
<code><a href="#topic+abs_d_sens_spec">abs_d_sens_spec</a>()</code>,
<code><a href="#topic+accuracy">accuracy</a>()</code>,
<code><a href="#topic+cohens_kappa">cohens_kappa</a>()</code>,
<code><a href="#topic+cutpoint">cutpoint</a>()</code>,
<code><a href="#topic+false_omission_rate">false_omission_rate</a>()</code>,
<code><a href="#topic+metric_constrain">metric_constrain</a>()</code>,
<code><a href="#topic+npv">npv</a>()</code>,
<code><a href="#topic+odds_ratio">odds_ratio</a>()</code>,
<code><a href="#topic+p_chisquared">p_chisquared</a>()</code>,
<code><a href="#topic+plr">plr</a>()</code>,
<code><a href="#topic+ppv">ppv</a>()</code>,
<code><a href="#topic+precision">precision</a>()</code>,
<code><a href="#topic+prod_ppv_npv">prod_ppv_npv</a>()</code>,
<code><a href="#topic+prod_sens_spec">prod_sens_spec</a>()</code>,
<code><a href="#topic+recall">recall</a>()</code>,
<code><a href="#topic+risk_ratio">risk_ratio</a>()</code>,
<code><a href="#topic+roc01">roc01</a>()</code>,
<code><a href="#topic+sensitivity">sensitivity</a>()</code>,
<code><a href="#topic+specificity">specificity</a>()</code>,
<code><a href="#topic+sum_ppv_npv">sum_ppv_npv</a>()</code>,
<code><a href="#topic+sum_sens_spec">sum_sens_spec</a>()</code>,
<code><a href="#topic+total_utility">total_utility</a>()</code>,
<code><a href="#topic+tpr">tpr</a>()</code>,
<code><a href="#topic+tp">tp</a>()</code>,
<code><a href="#topic+youden">youden</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>misclassification_cost(10, 5, 20, 10, cost_fp = 1, cost_fn = 5)
misclassification_cost(c(10, 8), c(5, 7), c(20, 12), c(10, 18),
                       cost_fp = 1, cost_fn = 5)
</code></pre>

<hr>
<h2 id='multi_cutpointr'>Calculate optimal cutpoints and further statistics for multiple predictors</h2><span id='topic+multi_cutpointr'></span>

<h3>Description</h3>

<p>Runs <code>cutpointr</code> over multiple predictor variables. Tidyeval via
<code>!!</code> is supported for <code>class</code> and <code>subgroup</code>. If
<code>x = NULL</code>, <code>cutpointr</code> will be run using all numeric columns
in the data set as predictors except for the
variable in <code>class</code> and, if given, <code>subgroup</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>multi_cutpointr(data, x = NULL, class, subgroup = NULL, silent = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="multi_cutpointr_+3A_data">data</code></td>
<td>
<p>A data frame.</p>
</td></tr>
<tr><td><code id="multi_cutpointr_+3A_x">x</code></td>
<td>
<p>Character vector of predictor variables. If NULL all numeric columns.</p>
</td></tr>
<tr><td><code id="multi_cutpointr_+3A_class">class</code></td>
<td>
<p>The name of the outcome / independent variable.</p>
</td></tr>
<tr><td><code id="multi_cutpointr_+3A_subgroup">subgroup</code></td>
<td>
<p>An additional covariate that identifies subgroups. Separate
optimal cutpoints will be determined per group.</p>
</td></tr>
<tr><td><code id="multi_cutpointr_+3A_silent">silent</code></td>
<td>
<p>Whether to suppress messages.</p>
</td></tr>
<tr><td><code id="multi_cutpointr_+3A_...">...</code></td>
<td>
<p>Further arguments to be passed to cutpointr, e.g., boot_runs</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The automatic determination of positive / negative classes and <code>direction</code>
will be carried out separately for every predictor variable. That way, if
<code>direction</code> and the classes are not specified, the reported AUC for every
variable will be &gt;= 0.5. AUC may be &lt; 0.5 if subgroups are specified as
<code>direction</code> is equal within every subgroup.
</p>


<h3>Value</h3>

<p>A data frame.
</p>


<h3>See Also</h3>

<p>Other main cutpointr functions: 
<code><a href="#topic+add_metric">add_metric</a>()</code>,
<code><a href="#topic+boot_ci">boot_ci</a>()</code>,
<code><a href="#topic+boot_test">boot_test</a>()</code>,
<code><a href="#topic+cutpointr">cutpointr</a>()</code>,
<code><a href="#topic+predict.cutpointr">predict.cutpointr</a>()</code>,
<code><a href="#topic+roc">roc</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(cutpointr)

multi_cutpointr(suicide, x = c("age", "dsi"), class = suicide,
                pos_class = "yes")

mcp &lt;- multi_cutpointr(suicide, x = c("age", "dsi"), class = suicide,
                       subgroup = gender, pos_class = "yes")
mcp

(scp &lt;- summary(mcp))
## Not run: 
## The result is a data frame
tibble:::print.tbl(scp)

## End(Not run)

</code></pre>

<hr>
<h2 id='npv'>Calculate the negative predictive value</h2><span id='topic+npv'></span>

<h3>Description</h3>

<p>Calculate the negative predictive value (NPV)
from true positives, false positives, true negatives and false negatives.
The inputs must be vectors of equal length. <br /> <br />
npv = tn / (tn + fn) <br />
</p>


<h3>Usage</h3>

<pre><code class='language-R'>npv(tp, fp, tn, fn, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="npv_+3A_tp">tp</code></td>
<td>
<p>(numeric) number of true positives.</p>
</td></tr>
<tr><td><code id="npv_+3A_fp">fp</code></td>
<td>
<p>(numeric) number of false positives.</p>
</td></tr>
<tr><td><code id="npv_+3A_tn">tn</code></td>
<td>
<p>(numeric) number of true negatives.</p>
</td></tr>
<tr><td><code id="npv_+3A_fn">fn</code></td>
<td>
<p>(numeric) number of false negatives.</p>
</td></tr>
<tr><td><code id="npv_+3A_...">...</code></td>
<td>
<p>for capturing additional arguments passed by method.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p>Other metric functions: 
<code><a href="#topic+F1_score">F1_score</a>()</code>,
<code><a href="#topic+Jaccard">Jaccard</a>()</code>,
<code><a href="#topic+abs_d_ppv_npv">abs_d_ppv_npv</a>()</code>,
<code><a href="#topic+abs_d_sens_spec">abs_d_sens_spec</a>()</code>,
<code><a href="#topic+accuracy">accuracy</a>()</code>,
<code><a href="#topic+cohens_kappa">cohens_kappa</a>()</code>,
<code><a href="#topic+cutpoint">cutpoint</a>()</code>,
<code><a href="#topic+false_omission_rate">false_omission_rate</a>()</code>,
<code><a href="#topic+metric_constrain">metric_constrain</a>()</code>,
<code><a href="#topic+misclassification_cost">misclassification_cost</a>()</code>,
<code><a href="#topic+odds_ratio">odds_ratio</a>()</code>,
<code><a href="#topic+p_chisquared">p_chisquared</a>()</code>,
<code><a href="#topic+plr">plr</a>()</code>,
<code><a href="#topic+ppv">ppv</a>()</code>,
<code><a href="#topic+precision">precision</a>()</code>,
<code><a href="#topic+prod_ppv_npv">prod_ppv_npv</a>()</code>,
<code><a href="#topic+prod_sens_spec">prod_sens_spec</a>()</code>,
<code><a href="#topic+recall">recall</a>()</code>,
<code><a href="#topic+risk_ratio">risk_ratio</a>()</code>,
<code><a href="#topic+roc01">roc01</a>()</code>,
<code><a href="#topic+sensitivity">sensitivity</a>()</code>,
<code><a href="#topic+specificity">specificity</a>()</code>,
<code><a href="#topic+sum_ppv_npv">sum_ppv_npv</a>()</code>,
<code><a href="#topic+sum_sens_spec">sum_sens_spec</a>()</code>,
<code><a href="#topic+total_utility">total_utility</a>()</code>,
<code><a href="#topic+tpr">tpr</a>()</code>,
<code><a href="#topic+tp">tp</a>()</code>,
<code><a href="#topic+youden">youden</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>npv(10, 5, 20, 10)
npv(c(10, 8), c(5, 7), c(20, 12), c(10, 18))
</code></pre>

<hr>
<h2 id='oc_manual'>Set a manual cutpoint for use with cutpointr</h2><span id='topic+oc_manual'></span>

<h3>Description</h3>

<p>This function simply returns <code>cutpoint</code> as the optimal cutpoint.
Mainly useful if bootstrap estimates of the out-of-bag performance of a
given cutpoint are desired, e.g. taking a cutpoint value from the literature.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>oc_manual(cutpoint, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="oc_manual_+3A_cutpoint">cutpoint</code></td>
<td>
<p>(numeric) The fixed cutpoint.</p>
</td></tr>
<tr><td><code id="oc_manual_+3A_...">...</code></td>
<td>
<p>To capture further arguments that are always passed to the method
function by cutpointr. The cutpointr function passes data, x, class,
metric_func, direction, pos_class and neg_class to the method function.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p>Other method functions: 
<code><a href="#topic+maximize_boot_metric">maximize_boot_metric</a>()</code>,
<code><a href="#topic+maximize_gam_metric">maximize_gam_metric</a>()</code>,
<code><a href="#topic+maximize_loess_metric">maximize_loess_metric</a>()</code>,
<code><a href="#topic+maximize_metric">maximize_metric</a>()</code>,
<code><a href="#topic+maximize_spline_metric">maximize_spline_metric</a>()</code>,
<code><a href="#topic+oc_mean">oc_mean</a>()</code>,
<code><a href="#topic+oc_median">oc_median</a>()</code>,
<code><a href="#topic+oc_youden_kernel">oc_youden_kernel</a>()</code>,
<code><a href="#topic+oc_youden_normal">oc_youden_normal</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>cutpointr(suicide, dsi, suicide, method = oc_manual, cutpoint = 4)
</code></pre>

<hr>
<h2 id='oc_mean'>Use the sample mean as cutpoint</h2><span id='topic+oc_mean'></span>

<h3>Description</h3>

<p>The sample mean is calculated and returned as the optimal cutpoint.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>oc_mean(data, x, trim = 0, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="oc_mean_+3A_data">data</code></td>
<td>
<p>A data frame or tibble in which the columns that are given in x
and class can be found.</p>
</td></tr>
<tr><td><code id="oc_mean_+3A_x">x</code></td>
<td>
<p>(character) The variable name to be used for classification,
e.g. predictions or test values.</p>
</td></tr>
<tr><td><code id="oc_mean_+3A_trim">trim</code></td>
<td>
<p>The fraction (0 to 0.5) of observations to be trimmed from each
end of x before the mean is computed. Values of trim outside that range are
taken as the nearest endpoint.</p>
</td></tr>
<tr><td><code id="oc_mean_+3A_...">...</code></td>
<td>
<p>To capture further arguments that are always passed to the method
function by cutpointr. The cutpointr function passes data, x, class,
metric_func, direction, pos_class and neg_class to the method function.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p>Other method functions: 
<code><a href="#topic+maximize_boot_metric">maximize_boot_metric</a>()</code>,
<code><a href="#topic+maximize_gam_metric">maximize_gam_metric</a>()</code>,
<code><a href="#topic+maximize_loess_metric">maximize_loess_metric</a>()</code>,
<code><a href="#topic+maximize_metric">maximize_metric</a>()</code>,
<code><a href="#topic+maximize_spline_metric">maximize_spline_metric</a>()</code>,
<code><a href="#topic+oc_manual">oc_manual</a>()</code>,
<code><a href="#topic+oc_median">oc_median</a>()</code>,
<code><a href="#topic+oc_youden_kernel">oc_youden_kernel</a>()</code>,
<code><a href="#topic+oc_youden_normal">oc_youden_normal</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(suicide)
oc_mean(suicide, "dsi")
cutpointr(suicide, dsi, suicide, method = oc_mean)
</code></pre>

<hr>
<h2 id='oc_median'>Use the sample median as cutpoint</h2><span id='topic+oc_median'></span>

<h3>Description</h3>

<p>The sample median is calculated and returned as the optimal cutpoint.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>oc_median(data, x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="oc_median_+3A_data">data</code></td>
<td>
<p>A data frame or tibble in which the columns that are given in x
and class can be found.</p>
</td></tr>
<tr><td><code id="oc_median_+3A_x">x</code></td>
<td>
<p>(character) The variable name to be used for classification,
e.g. predictions or test values.</p>
</td></tr>
<tr><td><code id="oc_median_+3A_...">...</code></td>
<td>
<p>To capture further arguments that are always passed to the method
function by cutpointr. The cutpointr function passes data, x, class,
metric_func, direction, pos_class and neg_class to the method function.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p>Other method functions: 
<code><a href="#topic+maximize_boot_metric">maximize_boot_metric</a>()</code>,
<code><a href="#topic+maximize_gam_metric">maximize_gam_metric</a>()</code>,
<code><a href="#topic+maximize_loess_metric">maximize_loess_metric</a>()</code>,
<code><a href="#topic+maximize_metric">maximize_metric</a>()</code>,
<code><a href="#topic+maximize_spline_metric">maximize_spline_metric</a>()</code>,
<code><a href="#topic+oc_manual">oc_manual</a>()</code>,
<code><a href="#topic+oc_mean">oc_mean</a>()</code>,
<code><a href="#topic+oc_youden_kernel">oc_youden_kernel</a>()</code>,
<code><a href="#topic+oc_youden_normal">oc_youden_normal</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(suicide)
oc_median(suicide, "dsi")
cutpointr(suicide, dsi, suicide, method = oc_median)
</code></pre>

<hr>
<h2 id='oc_youden_kernel'>Determine an optimal cutpoint maximizing the Youden-Index based on kernel smoothed densities</h2><span id='topic+oc_youden_kernel'></span>

<h3>Description</h3>

<p>Instead of searching for an optimal cutpoint to maximize (sensitivity +
specificity - 1) on the ROC curve, this function first smoothes the empirical
distributions of <code>x</code> per class. The smoothing is done using a binned kernel
density estimate. The bandwidth is automatically selected using the direct
plug-in method.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>oc_youden_kernel(data, x, class, pos_class, neg_class, direction, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="oc_youden_kernel_+3A_data">data</code></td>
<td>
<p>A data frame or tibble in which the columns that are given in x
and class can be found.</p>
</td></tr>
<tr><td><code id="oc_youden_kernel_+3A_x">x</code></td>
<td>
<p>(character) The variable name to be used for classification,
e.g. predictions or test values.</p>
</td></tr>
<tr><td><code id="oc_youden_kernel_+3A_class">class</code></td>
<td>
<p>(character) The variable name indicating class membership.</p>
</td></tr>
<tr><td><code id="oc_youden_kernel_+3A_pos_class">pos_class</code></td>
<td>
<p>The value of class that indicates the positive class.</p>
</td></tr>
<tr><td><code id="oc_youden_kernel_+3A_neg_class">neg_class</code></td>
<td>
<p>The value of class that indicates the negative class.</p>
</td></tr>
<tr><td><code id="oc_youden_kernel_+3A_direction">direction</code></td>
<td>
<p>(character) Use &quot;&gt;=&quot; or &quot;&lt;=&quot; to select whether an x value
&gt;= or &lt;= the cutoff predicts the positive class.</p>
</td></tr>
<tr><td><code id="oc_youden_kernel_+3A_...">...</code></td>
<td>
<p>To capture further arguments that are always passed to the method
function by cutpointr. The cutpointr function passes data, x, class,
metric_func, direction, pos_class and neg_class to the method function.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The functions for calculating the kernel density estimate and the bandwidth
are both from <span class="pkg">KernSmooth</span> with default parameters, except for
the bandwidth selection, which uses the standard deviation as scale estimate.
</p>
<p>The cutpoint is estimated as the cutpoint that maximizes the Youden-Index
given by <code class="reqn">J = max_c {F_N(c) - G_N(c) }</code> where
<code class="reqn">J</code> and <code class="reqn">G</code> are the smoothed distribution functions.
</p>


<h3>Source</h3>

<p>Fluss, R., Faraggi, D., &amp; Reiser, B. (2005). Estimation of the
Youden Index and its associated cutoff point. Biometrical Journal, 47(4), 458–472.
</p>
<p>Matt Wand (2015). KernSmooth: Functions for Kernel Smoothing
Supporting Wand &amp; Jones (1995). R package version 2.23-15.
https://CRAN.R-project.org/package=KernSmooth
</p>


<h3>See Also</h3>

<p>Other method functions: 
<code><a href="#topic+maximize_boot_metric">maximize_boot_metric</a>()</code>,
<code><a href="#topic+maximize_gam_metric">maximize_gam_metric</a>()</code>,
<code><a href="#topic+maximize_loess_metric">maximize_loess_metric</a>()</code>,
<code><a href="#topic+maximize_metric">maximize_metric</a>()</code>,
<code><a href="#topic+maximize_spline_metric">maximize_spline_metric</a>()</code>,
<code><a href="#topic+oc_manual">oc_manual</a>()</code>,
<code><a href="#topic+oc_mean">oc_mean</a>()</code>,
<code><a href="#topic+oc_median">oc_median</a>()</code>,
<code><a href="#topic+oc_youden_normal">oc_youden_normal</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(suicide)
if (require(KernSmooth)) {
  oc_youden_kernel(suicide, "dsi", "suicide", oc_metric = "Youden",
  pos_class = "yes", neg_class = "no", direction = "&gt;=")
  ## Within cutpointr
  cutpointr(suicide, dsi, suicide, method = oc_youden_kernel)
}
</code></pre>

<hr>
<h2 id='oc_youden_normal'>Determine an optimal cutpoint for the Youden-Index assuming normal distributions</h2><span id='topic+oc_youden_normal'></span>

<h3>Description</h3>

<p>An optimal cutpoint maximizing the Youden- or J-Index
(sensitivity + specificity - 1) is calculated parametrically assuming
normal distributions per class.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>oc_youden_normal(
  data,
  x,
  class,
  pos_class = NULL,
  neg_class = NULL,
  direction,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="oc_youden_normal_+3A_data">data</code></td>
<td>
<p>A data frame or tibble in which the columns that are given in x
and class can be found.</p>
</td></tr>
<tr><td><code id="oc_youden_normal_+3A_x">x</code></td>
<td>
<p>(character) The variable name to be used for classification,
e.g. predictions or test values.</p>
</td></tr>
<tr><td><code id="oc_youden_normal_+3A_class">class</code></td>
<td>
<p>(character) The variable name indicating class membership.</p>
</td></tr>
<tr><td><code id="oc_youden_normal_+3A_pos_class">pos_class</code></td>
<td>
<p>The value of class that indicates the positive class.</p>
</td></tr>
<tr><td><code id="oc_youden_normal_+3A_neg_class">neg_class</code></td>
<td>
<p>The value of class that indicates the negative class.</p>
</td></tr>
<tr><td><code id="oc_youden_normal_+3A_direction">direction</code></td>
<td>
<p>(character) Use &quot;&gt;=&quot; or &quot;&lt;=&quot; to select whether an x value
&gt;= or &lt;= the cutoff predicts the positive class.</p>
</td></tr>
<tr><td><code id="oc_youden_normal_+3A_...">...</code></td>
<td>
<p>To capture further arguments that are always passed to the method
function by cutpointr. The cutpointr function passes data, x, class,
metric_func, direction, pos_class and neg_class to the method function.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p>Other method functions: 
<code><a href="#topic+maximize_boot_metric">maximize_boot_metric</a>()</code>,
<code><a href="#topic+maximize_gam_metric">maximize_gam_metric</a>()</code>,
<code><a href="#topic+maximize_loess_metric">maximize_loess_metric</a>()</code>,
<code><a href="#topic+maximize_metric">maximize_metric</a>()</code>,
<code><a href="#topic+maximize_spline_metric">maximize_spline_metric</a>()</code>,
<code><a href="#topic+oc_manual">oc_manual</a>()</code>,
<code><a href="#topic+oc_mean">oc_mean</a>()</code>,
<code><a href="#topic+oc_median">oc_median</a>()</code>,
<code><a href="#topic+oc_youden_kernel">oc_youden_kernel</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(suicide)
oc_youden_normal(suicide, "dsi", "suicide",
  pos_class = "yes", neg_class = "no", direction = "&gt;=")
cutpointr(suicide, dsi, suicide, method = oc_youden_normal)
</code></pre>

<hr>
<h2 id='odds_ratio'>Calculate the odds ratio</h2><span id='topic+odds_ratio'></span>

<h3>Description</h3>

<p>Calculate the (diagnostic) odds ratio from
true positives, false positives, true negatives and false negatives.
The inputs must be vectors of equal length. <br /> <br />
odds_ratio = (tp / fp) / (fn / tn) <br />
</p>


<h3>Usage</h3>

<pre><code class='language-R'>odds_ratio(tp, fp, tn, fn, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="odds_ratio_+3A_tp">tp</code></td>
<td>
<p>(numeric) number of true positives.</p>
</td></tr>
<tr><td><code id="odds_ratio_+3A_fp">fp</code></td>
<td>
<p>(numeric) number of false positives.</p>
</td></tr>
<tr><td><code id="odds_ratio_+3A_tn">tn</code></td>
<td>
<p>(numeric) number of true negatives.</p>
</td></tr>
<tr><td><code id="odds_ratio_+3A_fn">fn</code></td>
<td>
<p>(numeric) number of false negatives.</p>
</td></tr>
<tr><td><code id="odds_ratio_+3A_...">...</code></td>
<td>
<p>for capturing additional arguments passed by method.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p>Other metric functions: 
<code><a href="#topic+F1_score">F1_score</a>()</code>,
<code><a href="#topic+Jaccard">Jaccard</a>()</code>,
<code><a href="#topic+abs_d_ppv_npv">abs_d_ppv_npv</a>()</code>,
<code><a href="#topic+abs_d_sens_spec">abs_d_sens_spec</a>()</code>,
<code><a href="#topic+accuracy">accuracy</a>()</code>,
<code><a href="#topic+cohens_kappa">cohens_kappa</a>()</code>,
<code><a href="#topic+cutpoint">cutpoint</a>()</code>,
<code><a href="#topic+false_omission_rate">false_omission_rate</a>()</code>,
<code><a href="#topic+metric_constrain">metric_constrain</a>()</code>,
<code><a href="#topic+misclassification_cost">misclassification_cost</a>()</code>,
<code><a href="#topic+npv">npv</a>()</code>,
<code><a href="#topic+p_chisquared">p_chisquared</a>()</code>,
<code><a href="#topic+plr">plr</a>()</code>,
<code><a href="#topic+ppv">ppv</a>()</code>,
<code><a href="#topic+precision">precision</a>()</code>,
<code><a href="#topic+prod_ppv_npv">prod_ppv_npv</a>()</code>,
<code><a href="#topic+prod_sens_spec">prod_sens_spec</a>()</code>,
<code><a href="#topic+recall">recall</a>()</code>,
<code><a href="#topic+risk_ratio">risk_ratio</a>()</code>,
<code><a href="#topic+roc01">roc01</a>()</code>,
<code><a href="#topic+sensitivity">sensitivity</a>()</code>,
<code><a href="#topic+specificity">specificity</a>()</code>,
<code><a href="#topic+sum_ppv_npv">sum_ppv_npv</a>()</code>,
<code><a href="#topic+sum_sens_spec">sum_sens_spec</a>()</code>,
<code><a href="#topic+total_utility">total_utility</a>()</code>,
<code><a href="#topic+tpr">tpr</a>()</code>,
<code><a href="#topic+tp">tp</a>()</code>,
<code><a href="#topic+youden">youden</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>odds_ratio(10, 5, 20, 10)
odds_ratio(c(10, 8), c(5, 7), c(20, 12), c(10, 18))
</code></pre>

<hr>
<h2 id='p_chisquared'>Calculate the p-value of a chi-squared test</h2><span id='topic+p_chisquared'></span>

<h3>Description</h3>

<p>Calculate the p-value of a chi-squared test from
true positives, false positives, true negatives and false negatives.
The inputs must be vectors of equal length.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>p_chisquared(tp, fp, tn, fn, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="p_chisquared_+3A_tp">tp</code></td>
<td>
<p>(numeric) number of true positives.</p>
</td></tr>
<tr><td><code id="p_chisquared_+3A_fp">fp</code></td>
<td>
<p>(numeric) number of false positives.</p>
</td></tr>
<tr><td><code id="p_chisquared_+3A_tn">tn</code></td>
<td>
<p>(numeric) number of true negatives.</p>
</td></tr>
<tr><td><code id="p_chisquared_+3A_fn">fn</code></td>
<td>
<p>(numeric) number of false negatives.</p>
</td></tr>
<tr><td><code id="p_chisquared_+3A_...">...</code></td>
<td>
<p>for capturing additional arguments passed by method.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p>Other metric functions: 
<code><a href="#topic+F1_score">F1_score</a>()</code>,
<code><a href="#topic+Jaccard">Jaccard</a>()</code>,
<code><a href="#topic+abs_d_ppv_npv">abs_d_ppv_npv</a>()</code>,
<code><a href="#topic+abs_d_sens_spec">abs_d_sens_spec</a>()</code>,
<code><a href="#topic+accuracy">accuracy</a>()</code>,
<code><a href="#topic+cohens_kappa">cohens_kappa</a>()</code>,
<code><a href="#topic+cutpoint">cutpoint</a>()</code>,
<code><a href="#topic+false_omission_rate">false_omission_rate</a>()</code>,
<code><a href="#topic+metric_constrain">metric_constrain</a>()</code>,
<code><a href="#topic+misclassification_cost">misclassification_cost</a>()</code>,
<code><a href="#topic+npv">npv</a>()</code>,
<code><a href="#topic+odds_ratio">odds_ratio</a>()</code>,
<code><a href="#topic+plr">plr</a>()</code>,
<code><a href="#topic+ppv">ppv</a>()</code>,
<code><a href="#topic+precision">precision</a>()</code>,
<code><a href="#topic+prod_ppv_npv">prod_ppv_npv</a>()</code>,
<code><a href="#topic+prod_sens_spec">prod_sens_spec</a>()</code>,
<code><a href="#topic+recall">recall</a>()</code>,
<code><a href="#topic+risk_ratio">risk_ratio</a>()</code>,
<code><a href="#topic+roc01">roc01</a>()</code>,
<code><a href="#topic+sensitivity">sensitivity</a>()</code>,
<code><a href="#topic+specificity">specificity</a>()</code>,
<code><a href="#topic+sum_ppv_npv">sum_ppv_npv</a>()</code>,
<code><a href="#topic+sum_sens_spec">sum_sens_spec</a>()</code>,
<code><a href="#topic+total_utility">total_utility</a>()</code>,
<code><a href="#topic+tpr">tpr</a>()</code>,
<code><a href="#topic+tp">tp</a>()</code>,
<code><a href="#topic+youden">youden</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>p_chisquared(10, 5, 20, 10)
p_chisquared(c(10, 8), c(5, 7), c(20, 12), c(10, 18))
</code></pre>

<hr>
<h2 id='plot_cut_boot'>Plot the bootstrapped distribution of optimal cutpoints from a cutpointr object</h2><span id='topic+plot_cut_boot'></span>

<h3>Description</h3>

<p>Given a cutpointr object this function plots the bootstrapped distribution
of optimal cutpoints. <code>cutpointr</code> has to be run with <code>boot_runs</code>' &gt; 0
to enable bootstrapping.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot_cut_boot(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot_cut_boot_+3A_x">x</code></td>
<td>
<p>A cutpointr object.</p>
</td></tr>
<tr><td><code id="plot_cut_boot_+3A_...">...</code></td>
<td>
<p>Additional arguments (unused).</p>
</td></tr>
</table>


<h3>See Also</h3>

<p>Other cutpointr plotting functions: 
<code><a href="#topic+plot.cutpointr">plot.cutpointr</a>()</code>,
<code><a href="#topic+plot_cutpointr">plot_cutpointr</a>()</code>,
<code><a href="#topic+plot_metric_boot">plot_metric_boot</a>()</code>,
<code><a href="#topic+plot_metric">plot_metric</a>()</code>,
<code><a href="#topic+plot_precision_recall">plot_precision_recall</a>()</code>,
<code><a href="#topic+plot_roc">plot_roc</a>()</code>,
<code><a href="#topic+plot_sensitivity_specificity">plot_sensitivity_specificity</a>()</code>,
<code><a href="#topic+plot_x">plot_x</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(100)
opt_cut &lt;- cutpointr(suicide, dsi, suicide, boot_runs = 10)
plot_cut_boot(opt_cut)
</code></pre>

<hr>
<h2 id='plot_cutpointr'>General purpose plotting function for cutpointr or roc_cutpointr objects</h2><span id='topic+plot_cutpointr'></span>

<h3>Description</h3>

<p>Flexibly plot various metrics against all cutpoints or any other metric.
The function can plot any metric based on a <code>cutpointr</code> or <code>roc_cutpointr</code>
object. If <code>cutpointr</code> was run with bootstrapping, bootstrapped confidence
intervals can be plotted. These represent the quantiles of the distribution
of the y-variable grouped by x-variable over all bootstrap repetitions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot_cutpointr(
  x,
  xvar = cutpoint,
  yvar = sum_sens_spec,
  conf_lvl = 0.95,
  aspect_ratio = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot_cutpointr_+3A_x">x</code></td>
<td>
<p>A <code>cutpointr</code> or <code>roc_cutpointr</code> object.</p>
</td></tr>
<tr><td><code id="plot_cutpointr_+3A_xvar">xvar</code></td>
<td>
<p>A function, typically <code>cutpoint</code> or a metric function.</p>
</td></tr>
<tr><td><code id="plot_cutpointr_+3A_yvar">yvar</code></td>
<td>
<p>A function, typically a metric function.</p>
</td></tr>
<tr><td><code id="plot_cutpointr_+3A_conf_lvl">conf_lvl</code></td>
<td>
<p>(numeric) If bootstrapping was run and x is a cutpointr object,
a confidence interval at the level of conf_lvl can be plotted. To plot no
confidence interval set conf_lvl = 0.</p>
</td></tr>
<tr><td><code id="plot_cutpointr_+3A_aspect_ratio">aspect_ratio</code></td>
<td>
<p>(numeric) Set to 1 to obtain a quadratic plot, e.g. for
plotting a ROC curve.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The arguments to <code>xvar</code> and <code>yvar</code> should be metric functions. Any metric
function that is suitable for <code>cutpointr</code> can also be used in <code>plot_cutpointr</code>.
Anonymous functions are also allowed.
To plot all possible cutpoints, the utility function <code>cutpoint</code> can be used.
</p>
<p>The functions for <code>xvar</code> and <code>yvar</code> may accept any or all of the arguments
<code>tp</code>, <code>fp</code>, <code>tn</code>, or <code>fn</code> and return a numeric vector,
a matrix or a <code>data.frame</code>.
For more details on metric functions see <code>vignette("cutpointr")</code>.
</p>
<p>Note that confidence intervals can only be correctly plotted if the values of <code>xvar</code>
are constant across bootstrap samples. For example, confidence intervals for
<code>tpr</code> by <code>fpr</code> (a ROC curve) cannot be plotted, as the values of the false positive
rate vary per bootstrap sample.
</p>


<h3>See Also</h3>

<p>Other cutpointr plotting functions: 
<code><a href="#topic+plot.cutpointr">plot.cutpointr</a>()</code>,
<code><a href="#topic+plot_cut_boot">plot_cut_boot</a>()</code>,
<code><a href="#topic+plot_metric_boot">plot_metric_boot</a>()</code>,
<code><a href="#topic+plot_metric">plot_metric</a>()</code>,
<code><a href="#topic+plot_precision_recall">plot_precision_recall</a>()</code>,
<code><a href="#topic+plot_roc">plot_roc</a>()</code>,
<code><a href="#topic+plot_sensitivity_specificity">plot_sensitivity_specificity</a>()</code>,
<code><a href="#topic+plot_x">plot_x</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(1)
oc &lt;- cutpointr(suicide, dsi, suicide, boot_runs = 10)

plot_cutpointr(oc, cutpoint, F1_score)

## ROC curve
plot_cutpointr(oc, fpr, tpr, aspect_ratio = 1)

## Custom function
plot_cutpointr(oc, cutpoint, function(tp, tn, fp, fn, ...) tp / fp) +
  ggplot2::ggtitle("Custom metric") + ggplot2::ylab("value")

</code></pre>

<hr>
<h2 id='plot_metric'>Plot a metric over all possible cutoffs from a cutpointr object</h2><span id='topic+plot_metric'></span>

<h3>Description</h3>

<p>If <code>maximize_metric</code> is used as <code>method</code> function in cutpointr the computed
metric values over all possible cutoffs can be plotted. Generally, this
works for method functions that return a ROC-curve including the metric
value for every cutpoint along with the optimal cutpoint.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot_metric(x, conf_lvl = 0.95, add_unsmoothed = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot_metric_+3A_x">x</code></td>
<td>
<p>A cutpointr object.</p>
</td></tr>
<tr><td><code id="plot_metric_+3A_conf_lvl">conf_lvl</code></td>
<td>
<p>The confidence level of the bootstrap confidence interval.
Set to 0 to draw no bootstrap confidence interval.</p>
</td></tr>
<tr><td><code id="plot_metric_+3A_add_unsmoothed">add_unsmoothed</code></td>
<td>
<p>Add the line of unsmoothed metric values to the plot.
Applicable for some smoothing methods, e.g. maximize_gam_metric.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p>Other cutpointr plotting functions: 
<code><a href="#topic+plot.cutpointr">plot.cutpointr</a>()</code>,
<code><a href="#topic+plot_cut_boot">plot_cut_boot</a>()</code>,
<code><a href="#topic+plot_cutpointr">plot_cutpointr</a>()</code>,
<code><a href="#topic+plot_metric_boot">plot_metric_boot</a>()</code>,
<code><a href="#topic+plot_precision_recall">plot_precision_recall</a>()</code>,
<code><a href="#topic+plot_roc">plot_roc</a>()</code>,
<code><a href="#topic+plot_sensitivity_specificity">plot_sensitivity_specificity</a>()</code>,
<code><a href="#topic+plot_x">plot_x</a>()</code>
</p>
<p>Other cutpointr plotting functions: 
<code><a href="#topic+plot.cutpointr">plot.cutpointr</a>()</code>,
<code><a href="#topic+plot_cut_boot">plot_cut_boot</a>()</code>,
<code><a href="#topic+plot_cutpointr">plot_cutpointr</a>()</code>,
<code><a href="#topic+plot_metric_boot">plot_metric_boot</a>()</code>,
<code><a href="#topic+plot_precision_recall">plot_precision_recall</a>()</code>,
<code><a href="#topic+plot_roc">plot_roc</a>()</code>,
<code><a href="#topic+plot_sensitivity_specificity">plot_sensitivity_specificity</a>()</code>,
<code><a href="#topic+plot_x">plot_x</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>opt_cut &lt;- cutpointr(suicide, dsi, suicide)
plot_metric(opt_cut)
</code></pre>

<hr>
<h2 id='plot_metric_boot'>Plot the bootstrapped metric distribution from a cutpointr object</h2><span id='topic+plot_metric_boot'></span>

<h3>Description</h3>

<p>Given a <code>cutpointr</code> object this function plots the bootstrapped metric distribution,
i.e. the distribution of out-of-bag metric values.
The metric depends on the function that was supplied to <code>metric</code> in the
call to <code>cutpointr</code>.
The <code>cutpointr</code> function has to be run with <code>boot_runs</code>' &gt; 0 to enable bootstrapping.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot_metric_boot(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot_metric_boot_+3A_x">x</code></td>
<td>
<p>A cutpointr object.</p>
</td></tr>
<tr><td><code id="plot_metric_boot_+3A_...">...</code></td>
<td>
<p>Additional arguments (unused)</p>
</td></tr>
</table>


<h3>See Also</h3>

<p>Other cutpointr plotting functions: 
<code><a href="#topic+plot.cutpointr">plot.cutpointr</a>()</code>,
<code><a href="#topic+plot_cut_boot">plot_cut_boot</a>()</code>,
<code><a href="#topic+plot_cutpointr">plot_cutpointr</a>()</code>,
<code><a href="#topic+plot_metric">plot_metric</a>()</code>,
<code><a href="#topic+plot_precision_recall">plot_precision_recall</a>()</code>,
<code><a href="#topic+plot_roc">plot_roc</a>()</code>,
<code><a href="#topic+plot_sensitivity_specificity">plot_sensitivity_specificity</a>()</code>,
<code><a href="#topic+plot_x">plot_x</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(300)
opt_cut &lt;- cutpointr(suicide, dsi, suicide, boot_runs = 10)
plot_metric_boot(opt_cut)
</code></pre>

<hr>
<h2 id='plot_precision_recall'>Precision recall plot from a cutpointr object</h2><span id='topic+plot_precision_recall'></span>

<h3>Description</h3>

<p>Given a <code>cutpointr</code> object this function plots the precision recall curve(s)
per subgroup, if given.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot_precision_recall(x, display_cutpoint = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot_precision_recall_+3A_x">x</code></td>
<td>
<p>A cutpointr object.</p>
</td></tr>
<tr><td><code id="plot_precision_recall_+3A_display_cutpoint">display_cutpoint</code></td>
<td>
<p>(logical) Whether or not to display the optimal
cutpoint as a dot on the precision recall curve.</p>
</td></tr>
<tr><td><code id="plot_precision_recall_+3A_...">...</code></td>
<td>
<p>Additional arguments (unused).</p>
</td></tr>
</table>


<h3>See Also</h3>

<p>Other cutpointr plotting functions: 
<code><a href="#topic+plot.cutpointr">plot.cutpointr</a>()</code>,
<code><a href="#topic+plot_cut_boot">plot_cut_boot</a>()</code>,
<code><a href="#topic+plot_cutpointr">plot_cutpointr</a>()</code>,
<code><a href="#topic+plot_metric_boot">plot_metric_boot</a>()</code>,
<code><a href="#topic+plot_metric">plot_metric</a>()</code>,
<code><a href="#topic+plot_roc">plot_roc</a>()</code>,
<code><a href="#topic+plot_sensitivity_specificity">plot_sensitivity_specificity</a>()</code>,
<code><a href="#topic+plot_x">plot_x</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(cutpointr)

## Optimal cutpoint for dsi
data(suicide)
opt_cut &lt;- cutpointr(suicide, dsi, suicide)
plot_precision_recall(opt_cut)
</code></pre>

<hr>
<h2 id='plot_roc'>Plot ROC curve from a cutpointr or roc_cutpointr object</h2><span id='topic+plot_roc'></span><span id='topic+plot_roc.cutpointr'></span><span id='topic+plot_roc.roc_cutpointr'></span>

<h3>Description</h3>

<p>Given a <code>cutpointr</code> object this function plots the ROC curve(s)
per subgroup, if given. Also plots a ROC curve from the output of <code>roc()</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot_roc(x, ...)

## S3 method for class 'cutpointr'
plot_roc(x, display_cutpoint = TRUE, type = "line", ...)

## S3 method for class 'roc_cutpointr'
plot_roc(x, type = "line", ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot_roc_+3A_x">x</code></td>
<td>
<p>A cutpointr or roc_cutpointr object.</p>
</td></tr>
<tr><td><code id="plot_roc_+3A_...">...</code></td>
<td>
<p>Additional arguments (unused).</p>
</td></tr>
<tr><td><code id="plot_roc_+3A_display_cutpoint">display_cutpoint</code></td>
<td>
<p>(logical) Whether or not to display the optimal
cutpoint as a dot on the ROC curve for cutpointr objects.</p>
</td></tr>
<tr><td><code id="plot_roc_+3A_type">type</code></td>
<td>
<p>&quot;line&quot; for line plot (default) or &quot;step&quot; for step plot.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p>Other cutpointr plotting functions: 
<code><a href="#topic+plot.cutpointr">plot.cutpointr</a>()</code>,
<code><a href="#topic+plot_cut_boot">plot_cut_boot</a>()</code>,
<code><a href="#topic+plot_cutpointr">plot_cutpointr</a>()</code>,
<code><a href="#topic+plot_metric_boot">plot_metric_boot</a>()</code>,
<code><a href="#topic+plot_metric">plot_metric</a>()</code>,
<code><a href="#topic+plot_precision_recall">plot_precision_recall</a>()</code>,
<code><a href="#topic+plot_sensitivity_specificity">plot_sensitivity_specificity</a>()</code>,
<code><a href="#topic+plot_x">plot_x</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>opt_cut &lt;- cutpointr(suicide, dsi, suicide)
plot_roc(opt_cut, display_cutpoint = FALSE)

opt_cut_2groups &lt;- cutpointr(suicide, dsi, suicide, gender)
plot_roc(opt_cut_2groups, display_cutpoint = TRUE)

roc_curve &lt;- roc(suicide, x = dsi, class = suicide, pos_class = "yes",
  neg_class = "no", direction = "&gt;=")
plot(roc_curve)
auc(roc_curve)
</code></pre>

<hr>
<h2 id='plot_sensitivity_specificity'>Sensitivity and specificity plot from a cutpointr object</h2><span id='topic+plot_sensitivity_specificity'></span>

<h3>Description</h3>

<p>Given a <code>cutpointr</code> object this function plots the sensitivity and specificity
curve(s) per subgroup, if the latter is given.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot_sensitivity_specificity(x, display_cutpoint = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot_sensitivity_specificity_+3A_x">x</code></td>
<td>
<p>A cutpointr object.</p>
</td></tr>
<tr><td><code id="plot_sensitivity_specificity_+3A_display_cutpoint">display_cutpoint</code></td>
<td>
<p>(logical) Whether or not to display the optimal
cutpoint as a dot on the precision recall curve.</p>
</td></tr>
<tr><td><code id="plot_sensitivity_specificity_+3A_...">...</code></td>
<td>
<p>Additional arguments (unused).</p>
</td></tr>
</table>


<h3>See Also</h3>

<p>Other cutpointr plotting functions: 
<code><a href="#topic+plot.cutpointr">plot.cutpointr</a>()</code>,
<code><a href="#topic+plot_cut_boot">plot_cut_boot</a>()</code>,
<code><a href="#topic+plot_cutpointr">plot_cutpointr</a>()</code>,
<code><a href="#topic+plot_metric_boot">plot_metric_boot</a>()</code>,
<code><a href="#topic+plot_metric">plot_metric</a>()</code>,
<code><a href="#topic+plot_precision_recall">plot_precision_recall</a>()</code>,
<code><a href="#topic+plot_roc">plot_roc</a>()</code>,
<code><a href="#topic+plot_x">plot_x</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(cutpointr)

## Optimal cutpoint for dsi
data(suicide)
opt_cut &lt;- cutpointr(suicide, dsi, suicide)
plot_sensitivity_specificity(opt_cut)
</code></pre>

<hr>
<h2 id='plot_x'>Plot the distribution of the independent variable per class from a cutpointr object</h2><span id='topic+plot_x'></span>

<h3>Description</h3>

<p>Given a <code>cutpointr</code> object this function plots the distribution(s) of the
independent variable(s) and the respective cutpoints per class.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot_x(x, display_cutpoint = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot_x_+3A_x">x</code></td>
<td>
<p>A cutpointr object.</p>
</td></tr>
<tr><td><code id="plot_x_+3A_display_cutpoint">display_cutpoint</code></td>
<td>
<p>(logical) Whether or not to display the optimal
cutpoint as a vertical line.</p>
</td></tr>
<tr><td><code id="plot_x_+3A_...">...</code></td>
<td>
<p>Additional arguments (unused).</p>
</td></tr>
</table>


<h3>See Also</h3>

<p>Other cutpointr plotting functions: 
<code><a href="#topic+plot.cutpointr">plot.cutpointr</a>()</code>,
<code><a href="#topic+plot_cut_boot">plot_cut_boot</a>()</code>,
<code><a href="#topic+plot_cutpointr">plot_cutpointr</a>()</code>,
<code><a href="#topic+plot_metric_boot">plot_metric_boot</a>()</code>,
<code><a href="#topic+plot_metric">plot_metric</a>()</code>,
<code><a href="#topic+plot_precision_recall">plot_precision_recall</a>()</code>,
<code><a href="#topic+plot_roc">plot_roc</a>()</code>,
<code><a href="#topic+plot_sensitivity_specificity">plot_sensitivity_specificity</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>opt_cut &lt;- cutpointr(suicide, dsi, suicide)
plot_x(opt_cut)

## With subgroup
opt_cut_2groups &lt;- cutpointr(suicide, dsi, suicide, gender)
plot_x(opt_cut_2groups)
</code></pre>

<hr>
<h2 id='plot.cutpointr'>Plot cutpointr objects</h2><span id='topic+plot.cutpointr'></span>

<h3>Description</h3>

<p>The plot layout depends on whether subgroups were defined and whether
bootstrapping was run.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'cutpointr'
plot(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.cutpointr_+3A_x">x</code></td>
<td>
<p>A cutpointr object.</p>
</td></tr>
<tr><td><code id="plot.cutpointr_+3A_...">...</code></td>
<td>
<p>Further arguments.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>...</code> argument can be used to apply <span class="pkg">ggplot2</span> functions to every individual
plot, for example for changing the theme.
</p>


<h3>See Also</h3>

<p>Other cutpointr plotting functions: 
<code><a href="#topic+plot_cut_boot">plot_cut_boot</a>()</code>,
<code><a href="#topic+plot_cutpointr">plot_cutpointr</a>()</code>,
<code><a href="#topic+plot_metric_boot">plot_metric_boot</a>()</code>,
<code><a href="#topic+plot_metric">plot_metric</a>()</code>,
<code><a href="#topic+plot_precision_recall">plot_precision_recall</a>()</code>,
<code><a href="#topic+plot_roc">plot_roc</a>()</code>,
<code><a href="#topic+plot_sensitivity_specificity">plot_sensitivity_specificity</a>()</code>,
<code><a href="#topic+plot_x">plot_x</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>opt_cut &lt;- cutpointr(suicide, dsi, suicide, gender)
plot(opt_cut)
plot(opt_cut, ggplot2::theme_bw())
</code></pre>

<hr>
<h2 id='plot.multi_cutpointr'>Plotting multi_cutpointr objects is currently not supported</h2><span id='topic+plot.multi_cutpointr'></span>

<h3>Description</h3>

<p>You can try plotting the data manually instead.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'multi_cutpointr'
plot(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.multi_cutpointr_+3A_x">x</code></td>
<td>
<p>A multi_cutpointr object.</p>
</td></tr>
<tr><td><code id="plot.multi_cutpointr_+3A_...">...</code></td>
<td>
<p>Further arguments.</p>
</td></tr>
</table>

<hr>
<h2 id='plot.roc_cutpointr'>Plot ROC curve from a cutpointr or roc_cutpointr object</h2><span id='topic+plot.roc_cutpointr'></span>

<h3>Description</h3>

<p>Given a <code>cutpointr</code> object this function plots the ROC curve(s)
per subgroup, if given. Also plots a ROC curve from the output of <code>roc()</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'roc_cutpointr'
plot(x, type = "line", ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.roc_cutpointr_+3A_x">x</code></td>
<td>
<p>A cutpointr or roc_cutpointr object.</p>
</td></tr>
<tr><td><code id="plot.roc_cutpointr_+3A_type">type</code></td>
<td>
<p>&quot;line&quot; for line plot (default) or &quot;step&quot; for step plot.</p>
</td></tr>
<tr><td><code id="plot.roc_cutpointr_+3A_...">...</code></td>
<td>
<p>Additional arguments (unused).</p>
</td></tr>
</table>


<h3>See Also</h3>

<p>Other cutpointr plotting functions: 
<code><a href="#topic+plot.cutpointr">plot.cutpointr</a>()</code>,
<code><a href="#topic+plot_cut_boot">plot_cut_boot</a>()</code>,
<code><a href="#topic+plot_cutpointr">plot_cutpointr</a>()</code>,
<code><a href="#topic+plot_metric_boot">plot_metric_boot</a>()</code>,
<code><a href="#topic+plot_metric">plot_metric</a>()</code>,
<code><a href="#topic+plot_precision_recall">plot_precision_recall</a>()</code>,
<code><a href="#topic+plot_sensitivity_specificity">plot_sensitivity_specificity</a>()</code>,
<code><a href="#topic+plot_x">plot_x</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>opt_cut &lt;- cutpointr(suicide, dsi, suicide)
plot_roc(opt_cut, display_cutpoint = FALSE)

opt_cut_2groups &lt;- cutpointr(suicide, dsi, suicide, gender)
plot_roc(opt_cut_2groups, display_cutpoint = TRUE)

roc_curve &lt;- roc(suicide, x = dsi, class = suicide, pos_class = "yes",
  neg_class = "no", direction = "&gt;=")
plot(roc_curve)
auc(roc_curve)
</code></pre>

<hr>
<h2 id='plr'>Calculate the positive or negative likelihood ratio</h2><span id='topic+plr'></span><span id='topic+nlr'></span>

<h3>Description</h3>

<p>Calculate the positive or negative likelihood ratio
from true positives, false positives, true negatives and false negatives.
The inputs must be vectors of equal length. <br /> <br />
plr = tpr / fpr <br />
nlr = fnr / tnr <br />
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plr(tp, fp, tn, fn, ...)

nlr(tp, fp, tn, fn, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plr_+3A_tp">tp</code></td>
<td>
<p>(numeric) number of true positives.</p>
</td></tr>
<tr><td><code id="plr_+3A_fp">fp</code></td>
<td>
<p>(numeric) number of false positives.</p>
</td></tr>
<tr><td><code id="plr_+3A_tn">tn</code></td>
<td>
<p>(numeric) number of true negatives.</p>
</td></tr>
<tr><td><code id="plr_+3A_fn">fn</code></td>
<td>
<p>(numeric) number of false negatives.</p>
</td></tr>
<tr><td><code id="plr_+3A_...">...</code></td>
<td>
<p>for capturing additional arguments passed by method.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p>Other metric functions: 
<code><a href="#topic+F1_score">F1_score</a>()</code>,
<code><a href="#topic+Jaccard">Jaccard</a>()</code>,
<code><a href="#topic+abs_d_ppv_npv">abs_d_ppv_npv</a>()</code>,
<code><a href="#topic+abs_d_sens_spec">abs_d_sens_spec</a>()</code>,
<code><a href="#topic+accuracy">accuracy</a>()</code>,
<code><a href="#topic+cohens_kappa">cohens_kappa</a>()</code>,
<code><a href="#topic+cutpoint">cutpoint</a>()</code>,
<code><a href="#topic+false_omission_rate">false_omission_rate</a>()</code>,
<code><a href="#topic+metric_constrain">metric_constrain</a>()</code>,
<code><a href="#topic+misclassification_cost">misclassification_cost</a>()</code>,
<code><a href="#topic+npv">npv</a>()</code>,
<code><a href="#topic+odds_ratio">odds_ratio</a>()</code>,
<code><a href="#topic+p_chisquared">p_chisquared</a>()</code>,
<code><a href="#topic+ppv">ppv</a>()</code>,
<code><a href="#topic+precision">precision</a>()</code>,
<code><a href="#topic+prod_ppv_npv">prod_ppv_npv</a>()</code>,
<code><a href="#topic+prod_sens_spec">prod_sens_spec</a>()</code>,
<code><a href="#topic+recall">recall</a>()</code>,
<code><a href="#topic+risk_ratio">risk_ratio</a>()</code>,
<code><a href="#topic+roc01">roc01</a>()</code>,
<code><a href="#topic+sensitivity">sensitivity</a>()</code>,
<code><a href="#topic+specificity">specificity</a>()</code>,
<code><a href="#topic+sum_ppv_npv">sum_ppv_npv</a>()</code>,
<code><a href="#topic+sum_sens_spec">sum_sens_spec</a>()</code>,
<code><a href="#topic+total_utility">total_utility</a>()</code>,
<code><a href="#topic+tpr">tpr</a>()</code>,
<code><a href="#topic+tp">tp</a>()</code>,
<code><a href="#topic+youden">youden</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>plr(10, 5, 20, 10)
plr(c(10, 8), c(5, 7), c(20, 12), c(10, 18))
</code></pre>

<hr>
<h2 id='ppv'>Calculate the positive predictive value</h2><span id='topic+ppv'></span>

<h3>Description</h3>

<p>Calculate the positive predictive value (PPV) from
true positives, false positives, true negatives and false negatives.
The inputs must be vectors of equal length. <br /> <br />
ppv = tp / (tp + fp) <br />
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ppv(tp, fp, tn, fn, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ppv_+3A_tp">tp</code></td>
<td>
<p>(numeric) number of true positives.</p>
</td></tr>
<tr><td><code id="ppv_+3A_fp">fp</code></td>
<td>
<p>(numeric) number of false positives.</p>
</td></tr>
<tr><td><code id="ppv_+3A_tn">tn</code></td>
<td>
<p>(numeric) number of true negatives.</p>
</td></tr>
<tr><td><code id="ppv_+3A_fn">fn</code></td>
<td>
<p>(numeric) number of false negatives.</p>
</td></tr>
<tr><td><code id="ppv_+3A_...">...</code></td>
<td>
<p>for capturing additional arguments passed by method.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p>Other metric functions: 
<code><a href="#topic+F1_score">F1_score</a>()</code>,
<code><a href="#topic+Jaccard">Jaccard</a>()</code>,
<code><a href="#topic+abs_d_ppv_npv">abs_d_ppv_npv</a>()</code>,
<code><a href="#topic+abs_d_sens_spec">abs_d_sens_spec</a>()</code>,
<code><a href="#topic+accuracy">accuracy</a>()</code>,
<code><a href="#topic+cohens_kappa">cohens_kappa</a>()</code>,
<code><a href="#topic+cutpoint">cutpoint</a>()</code>,
<code><a href="#topic+false_omission_rate">false_omission_rate</a>()</code>,
<code><a href="#topic+metric_constrain">metric_constrain</a>()</code>,
<code><a href="#topic+misclassification_cost">misclassification_cost</a>()</code>,
<code><a href="#topic+npv">npv</a>()</code>,
<code><a href="#topic+odds_ratio">odds_ratio</a>()</code>,
<code><a href="#topic+p_chisquared">p_chisquared</a>()</code>,
<code><a href="#topic+plr">plr</a>()</code>,
<code><a href="#topic+precision">precision</a>()</code>,
<code><a href="#topic+prod_ppv_npv">prod_ppv_npv</a>()</code>,
<code><a href="#topic+prod_sens_spec">prod_sens_spec</a>()</code>,
<code><a href="#topic+recall">recall</a>()</code>,
<code><a href="#topic+risk_ratio">risk_ratio</a>()</code>,
<code><a href="#topic+roc01">roc01</a>()</code>,
<code><a href="#topic+sensitivity">sensitivity</a>()</code>,
<code><a href="#topic+specificity">specificity</a>()</code>,
<code><a href="#topic+sum_ppv_npv">sum_ppv_npv</a>()</code>,
<code><a href="#topic+sum_sens_spec">sum_sens_spec</a>()</code>,
<code><a href="#topic+total_utility">total_utility</a>()</code>,
<code><a href="#topic+tpr">tpr</a>()</code>,
<code><a href="#topic+tp">tp</a>()</code>,
<code><a href="#topic+youden">youden</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>ppv(10, 5, 20, 10)
ppv(c(10, 8), c(5, 7), c(20, 12), c(10, 18))
</code></pre>

<hr>
<h2 id='precision'>Calculate precision</h2><span id='topic+precision'></span>

<h3>Description</h3>

<p>Calculate precision (equal to the positive predictive value)
from true positives, false positives, true negatives and false negatives.
The inputs must be vectors of equal length. <br /> <br />
precision = tp / (tp + fp) <br />
</p>


<h3>Usage</h3>

<pre><code class='language-R'>precision(tp, fp, tn, fn, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="precision_+3A_tp">tp</code></td>
<td>
<p>(numeric) number of true positives.</p>
</td></tr>
<tr><td><code id="precision_+3A_fp">fp</code></td>
<td>
<p>(numeric) number of false positives.</p>
</td></tr>
<tr><td><code id="precision_+3A_tn">tn</code></td>
<td>
<p>(numeric) number of true negatives.</p>
</td></tr>
<tr><td><code id="precision_+3A_fn">fn</code></td>
<td>
<p>(numeric) number of false negatives.</p>
</td></tr>
<tr><td><code id="precision_+3A_...">...</code></td>
<td>
<p>for capturing additional arguments passed by method.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p>Other metric functions: 
<code><a href="#topic+F1_score">F1_score</a>()</code>,
<code><a href="#topic+Jaccard">Jaccard</a>()</code>,
<code><a href="#topic+abs_d_ppv_npv">abs_d_ppv_npv</a>()</code>,
<code><a href="#topic+abs_d_sens_spec">abs_d_sens_spec</a>()</code>,
<code><a href="#topic+accuracy">accuracy</a>()</code>,
<code><a href="#topic+cohens_kappa">cohens_kappa</a>()</code>,
<code><a href="#topic+cutpoint">cutpoint</a>()</code>,
<code><a href="#topic+false_omission_rate">false_omission_rate</a>()</code>,
<code><a href="#topic+metric_constrain">metric_constrain</a>()</code>,
<code><a href="#topic+misclassification_cost">misclassification_cost</a>()</code>,
<code><a href="#topic+npv">npv</a>()</code>,
<code><a href="#topic+odds_ratio">odds_ratio</a>()</code>,
<code><a href="#topic+p_chisquared">p_chisquared</a>()</code>,
<code><a href="#topic+plr">plr</a>()</code>,
<code><a href="#topic+ppv">ppv</a>()</code>,
<code><a href="#topic+prod_ppv_npv">prod_ppv_npv</a>()</code>,
<code><a href="#topic+prod_sens_spec">prod_sens_spec</a>()</code>,
<code><a href="#topic+recall">recall</a>()</code>,
<code><a href="#topic+risk_ratio">risk_ratio</a>()</code>,
<code><a href="#topic+roc01">roc01</a>()</code>,
<code><a href="#topic+sensitivity">sensitivity</a>()</code>,
<code><a href="#topic+specificity">specificity</a>()</code>,
<code><a href="#topic+sum_ppv_npv">sum_ppv_npv</a>()</code>,
<code><a href="#topic+sum_sens_spec">sum_sens_spec</a>()</code>,
<code><a href="#topic+total_utility">total_utility</a>()</code>,
<code><a href="#topic+tpr">tpr</a>()</code>,
<code><a href="#topic+tp">tp</a>()</code>,
<code><a href="#topic+youden">youden</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>precision(10, 5, 20, 10)
precision(c(10, 8), c(5, 7), c(20, 12), c(10, 18))
</code></pre>

<hr>
<h2 id='predict.cutpointr'>Predict using a cutpointr object</h2><span id='topic+predict.cutpointr'></span>

<h3>Description</h3>

<p>Predictions are made on the <code>data.frame</code> in <code>newdata</code>
using either the variable name or by applying the same transformation to
the data as in <code>cutpointr</code>. The class of the output will be identical to the class
of the predictor.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'cutpointr'
predict(object, newdata, cutpoint_nr = 1, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="predict.cutpointr_+3A_object">object</code></td>
<td>
<p>a cutpointr object.</p>
</td></tr>
<tr><td><code id="predict.cutpointr_+3A_newdata">newdata</code></td>
<td>
<p>a data.frame with a column that contains the predictor
variable.</p>
</td></tr>
<tr><td><code id="predict.cutpointr_+3A_cutpoint_nr">cutpoint_nr</code></td>
<td>
<p>if multiple optimal cutpoints were found this parameter
defines which one should be used for predictions. Can be a vector if
different cutpoint numbers are desired for different subgroups.</p>
</td></tr>
<tr><td><code id="predict.cutpointr_+3A_...">...</code></td>
<td>
<p>further arguments.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p>Other main cutpointr functions: 
<code><a href="#topic+add_metric">add_metric</a>()</code>,
<code><a href="#topic+boot_ci">boot_ci</a>()</code>,
<code><a href="#topic+boot_test">boot_test</a>()</code>,
<code><a href="#topic+cutpointr">cutpointr</a>()</code>,
<code><a href="#topic+multi_cutpointr">multi_cutpointr</a>()</code>,
<code><a href="#topic+roc">roc</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>oc &lt;- cutpointr(suicide, dsi, suicide)
## Return in-sample predictions
predict(oc, newdata = data.frame(dsi = oc$data[[1]]$dsi))
</code></pre>

<hr>
<h2 id='print.cutpointr'>Print cutpointr objects</h2><span id='topic+print.cutpointr'></span>

<h3>Description</h3>

<p>Prints the <code>cutpointr</code> object with full width like a <code>tbl_df</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'cutpointr'
print(x, width = 1000, n = 50, sigfig = 6, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.cutpointr_+3A_x">x</code></td>
<td>
<p>a cutpointr object.</p>
</td></tr>
<tr><td><code id="print.cutpointr_+3A_width">width</code></td>
<td>
<p>width of output.</p>
</td></tr>
<tr><td><code id="print.cutpointr_+3A_n">n</code></td>
<td>
<p>number of rows to print.</p>
</td></tr>
<tr><td><code id="print.cutpointr_+3A_sigfig">sigfig</code></td>
<td>
<p>Number of significant digits to print. Temporarily
overrides options(&quot;pillar.sigfig&quot;).</p>
</td></tr>
<tr><td><code id="print.cutpointr_+3A_...">...</code></td>
<td>
<p>further arguments.</p>
</td></tr>
</table>


<h3>Source</h3>

<p>Kirill Müller and Hadley Wickham (2017). tibble: Simple Data Frames.
https://CRAN.R-project.org/package=tibble
</p>

<hr>
<h2 id='print.multi_cutpointr'>Print multi_cutpointr objects</h2><span id='topic+print.multi_cutpointr'></span>

<h3>Description</h3>

<p>Prints the <code>multi_cutpointr</code> object with infinite width like a <code>tbl_df</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'multi_cutpointr'
print(x, n = Inf, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.multi_cutpointr_+3A_x">x</code></td>
<td>
<p>a multi_cutpointr object.</p>
</td></tr>
<tr><td><code id="print.multi_cutpointr_+3A_n">n</code></td>
<td>
<p>number of rows to print.</p>
</td></tr>
<tr><td><code id="print.multi_cutpointr_+3A_...">...</code></td>
<td>
<p>further arguments.</p>
</td></tr>
</table>


<h3>Source</h3>

<p>Kirill Müller and Hadley Wickham (2017). tibble: Simple Data Frames.
https://CRAN.R-project.org/package=tibble
</p>

<hr>
<h2 id='prod_ppv_npv'>Calculate the product of positive and negative predictive value</h2><span id='topic+prod_ppv_npv'></span>

<h3>Description</h3>

<p>Calculate the product of positive predictive value (PPV) and
negative predictive value (NPV) from
true positives, false positives, true negatives and false negatives.
The inputs must be vectors of equal length. <br /> <br />
ppv = tp / (tp + fp) <br />
npv = tn / (tn + fn) <br />
prod_ppv_npv = ppv * npv <br />
</p>


<h3>Usage</h3>

<pre><code class='language-R'>prod_ppv_npv(tp, fp, tn, fn, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="prod_ppv_npv_+3A_tp">tp</code></td>
<td>
<p>(numeric) number of true positives.</p>
</td></tr>
<tr><td><code id="prod_ppv_npv_+3A_fp">fp</code></td>
<td>
<p>(numeric) number of false positives.</p>
</td></tr>
<tr><td><code id="prod_ppv_npv_+3A_tn">tn</code></td>
<td>
<p>(numeric) number of true negatives.</p>
</td></tr>
<tr><td><code id="prod_ppv_npv_+3A_fn">fn</code></td>
<td>
<p>(numeric) number of false negatives.</p>
</td></tr>
<tr><td><code id="prod_ppv_npv_+3A_...">...</code></td>
<td>
<p>for capturing additional arguments passed by method.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p>Other metric functions: 
<code><a href="#topic+F1_score">F1_score</a>()</code>,
<code><a href="#topic+Jaccard">Jaccard</a>()</code>,
<code><a href="#topic+abs_d_ppv_npv">abs_d_ppv_npv</a>()</code>,
<code><a href="#topic+abs_d_sens_spec">abs_d_sens_spec</a>()</code>,
<code><a href="#topic+accuracy">accuracy</a>()</code>,
<code><a href="#topic+cohens_kappa">cohens_kappa</a>()</code>,
<code><a href="#topic+cutpoint">cutpoint</a>()</code>,
<code><a href="#topic+false_omission_rate">false_omission_rate</a>()</code>,
<code><a href="#topic+metric_constrain">metric_constrain</a>()</code>,
<code><a href="#topic+misclassification_cost">misclassification_cost</a>()</code>,
<code><a href="#topic+npv">npv</a>()</code>,
<code><a href="#topic+odds_ratio">odds_ratio</a>()</code>,
<code><a href="#topic+p_chisquared">p_chisquared</a>()</code>,
<code><a href="#topic+plr">plr</a>()</code>,
<code><a href="#topic+ppv">ppv</a>()</code>,
<code><a href="#topic+precision">precision</a>()</code>,
<code><a href="#topic+prod_sens_spec">prod_sens_spec</a>()</code>,
<code><a href="#topic+recall">recall</a>()</code>,
<code><a href="#topic+risk_ratio">risk_ratio</a>()</code>,
<code><a href="#topic+roc01">roc01</a>()</code>,
<code><a href="#topic+sensitivity">sensitivity</a>()</code>,
<code><a href="#topic+specificity">specificity</a>()</code>,
<code><a href="#topic+sum_ppv_npv">sum_ppv_npv</a>()</code>,
<code><a href="#topic+sum_sens_spec">sum_sens_spec</a>()</code>,
<code><a href="#topic+total_utility">total_utility</a>()</code>,
<code><a href="#topic+tpr">tpr</a>()</code>,
<code><a href="#topic+tp">tp</a>()</code>,
<code><a href="#topic+youden">youden</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>prod_ppv_npv(10, 5, 20, 10)
prod_ppv_npv(c(10, 8), c(5, 7), c(20, 12), c(10, 18))
</code></pre>

<hr>
<h2 id='prod_sens_spec'>Calculate the product of sensitivity and specificity</h2><span id='topic+prod_sens_spec'></span>

<h3>Description</h3>

<p>Calculate the product of sensitivity and specificity from
true positives, false positives, true negatives and false negatives.
The inputs must be vectors of equal length. <br /> <br />
sensitivity = tp / (tp + fn) <br />
specificity = tn / (tn + fp) <br />
prod_sens_spec = sensitivity * specificity <br />
</p>


<h3>Usage</h3>

<pre><code class='language-R'>prod_sens_spec(tp, fp, tn, fn, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="prod_sens_spec_+3A_tp">tp</code></td>
<td>
<p>(numeric) number of true positives.</p>
</td></tr>
<tr><td><code id="prod_sens_spec_+3A_fp">fp</code></td>
<td>
<p>(numeric) number of false positives.</p>
</td></tr>
<tr><td><code id="prod_sens_spec_+3A_tn">tn</code></td>
<td>
<p>(numeric) number of true negatives.</p>
</td></tr>
<tr><td><code id="prod_sens_spec_+3A_fn">fn</code></td>
<td>
<p>(numeric) number of false negatives.</p>
</td></tr>
<tr><td><code id="prod_sens_spec_+3A_...">...</code></td>
<td>
<p>for capturing additional arguments passed by method.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p>Other metric functions: 
<code><a href="#topic+F1_score">F1_score</a>()</code>,
<code><a href="#topic+Jaccard">Jaccard</a>()</code>,
<code><a href="#topic+abs_d_ppv_npv">abs_d_ppv_npv</a>()</code>,
<code><a href="#topic+abs_d_sens_spec">abs_d_sens_spec</a>()</code>,
<code><a href="#topic+accuracy">accuracy</a>()</code>,
<code><a href="#topic+cohens_kappa">cohens_kappa</a>()</code>,
<code><a href="#topic+cutpoint">cutpoint</a>()</code>,
<code><a href="#topic+false_omission_rate">false_omission_rate</a>()</code>,
<code><a href="#topic+metric_constrain">metric_constrain</a>()</code>,
<code><a href="#topic+misclassification_cost">misclassification_cost</a>()</code>,
<code><a href="#topic+npv">npv</a>()</code>,
<code><a href="#topic+odds_ratio">odds_ratio</a>()</code>,
<code><a href="#topic+p_chisquared">p_chisquared</a>()</code>,
<code><a href="#topic+plr">plr</a>()</code>,
<code><a href="#topic+ppv">ppv</a>()</code>,
<code><a href="#topic+precision">precision</a>()</code>,
<code><a href="#topic+prod_ppv_npv">prod_ppv_npv</a>()</code>,
<code><a href="#topic+recall">recall</a>()</code>,
<code><a href="#topic+risk_ratio">risk_ratio</a>()</code>,
<code><a href="#topic+roc01">roc01</a>()</code>,
<code><a href="#topic+sensitivity">sensitivity</a>()</code>,
<code><a href="#topic+specificity">specificity</a>()</code>,
<code><a href="#topic+sum_ppv_npv">sum_ppv_npv</a>()</code>,
<code><a href="#topic+sum_sens_spec">sum_sens_spec</a>()</code>,
<code><a href="#topic+total_utility">total_utility</a>()</code>,
<code><a href="#topic+tpr">tpr</a>()</code>,
<code><a href="#topic+tp">tp</a>()</code>,
<code><a href="#topic+youden">youden</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>prod_sens_spec(10, 5, 20, 10)
prod_sens_spec(c(10, 8), c(5, 7), c(20, 12), c(10, 18))
</code></pre>

<hr>
<h2 id='prostate_nodal'>Nodal involvement and acid phosphatase levels in 53 prostate cancer patients</h2><span id='topic+prostate_nodal'></span>

<h3>Description</h3>

<p>Prostatic acid phosphatase (PAP) emerged as the first clinically
useful tumor marker in the 1940s and 1950s. This data set contains the
serum levels of acid phosphatase of 53 patients that were confirmed to
have prostate cancer and whether the neighboring lymph nodes were involved.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>prostate_nodal
</code></pre>


<h3>Format</h3>

<p>A data frame with 53 rows and 2 variables:
</p>

<dl>
<dt>acid_phosphatase</dt><dd><p>(numeric) Blood serum level of acid phosphatase</p>
</dd>
<dt>nodal_involvement</dt><dd><p>(logical) Whether neighboring lymph nodes were involved</p>
</dd>
</dl>



<h3>Source</h3>

<p>Le CT (2006). A solution for the most basic optimization problem associated with an ROC curve. Statistical methods in medical research 15: 571–584
</p>

<hr>
<h2 id='recall'>Calculate recall</h2><span id='topic+recall'></span>

<h3>Description</h3>

<p>Calculate recall (equal to sensitivity) from
true positives, false positives, true negatives and false negatives.
The inputs must be vectors of equal length. <br /> <br />
recall = tp / (tp + fn) <br />
</p>


<h3>Usage</h3>

<pre><code class='language-R'>recall(tp, fp, tn, fn, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="recall_+3A_tp">tp</code></td>
<td>
<p>(numeric) number of true positives.</p>
</td></tr>
<tr><td><code id="recall_+3A_fp">fp</code></td>
<td>
<p>(numeric) number of false positives.</p>
</td></tr>
<tr><td><code id="recall_+3A_tn">tn</code></td>
<td>
<p>(numeric) number of true negatives.</p>
</td></tr>
<tr><td><code id="recall_+3A_fn">fn</code></td>
<td>
<p>(numeric) number of false negatives.</p>
</td></tr>
<tr><td><code id="recall_+3A_...">...</code></td>
<td>
<p>for capturing additional arguments passed by method.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p>Other metric functions: 
<code><a href="#topic+F1_score">F1_score</a>()</code>,
<code><a href="#topic+Jaccard">Jaccard</a>()</code>,
<code><a href="#topic+abs_d_ppv_npv">abs_d_ppv_npv</a>()</code>,
<code><a href="#topic+abs_d_sens_spec">abs_d_sens_spec</a>()</code>,
<code><a href="#topic+accuracy">accuracy</a>()</code>,
<code><a href="#topic+cohens_kappa">cohens_kappa</a>()</code>,
<code><a href="#topic+cutpoint">cutpoint</a>()</code>,
<code><a href="#topic+false_omission_rate">false_omission_rate</a>()</code>,
<code><a href="#topic+metric_constrain">metric_constrain</a>()</code>,
<code><a href="#topic+misclassification_cost">misclassification_cost</a>()</code>,
<code><a href="#topic+npv">npv</a>()</code>,
<code><a href="#topic+odds_ratio">odds_ratio</a>()</code>,
<code><a href="#topic+p_chisquared">p_chisquared</a>()</code>,
<code><a href="#topic+plr">plr</a>()</code>,
<code><a href="#topic+ppv">ppv</a>()</code>,
<code><a href="#topic+precision">precision</a>()</code>,
<code><a href="#topic+prod_ppv_npv">prod_ppv_npv</a>()</code>,
<code><a href="#topic+prod_sens_spec">prod_sens_spec</a>()</code>,
<code><a href="#topic+risk_ratio">risk_ratio</a>()</code>,
<code><a href="#topic+roc01">roc01</a>()</code>,
<code><a href="#topic+sensitivity">sensitivity</a>()</code>,
<code><a href="#topic+specificity">specificity</a>()</code>,
<code><a href="#topic+sum_ppv_npv">sum_ppv_npv</a>()</code>,
<code><a href="#topic+sum_sens_spec">sum_sens_spec</a>()</code>,
<code><a href="#topic+total_utility">total_utility</a>()</code>,
<code><a href="#topic+tpr">tpr</a>()</code>,
<code><a href="#topic+tp">tp</a>()</code>,
<code><a href="#topic+youden">youden</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>recall(10, 5, 20, 10)
recall(c(10, 8), c(5, 7), c(20, 12), c(10, 18))
</code></pre>

<hr>
<h2 id='risk_ratio'>Calculate the risk ratio (relative risk)</h2><span id='topic+risk_ratio'></span>

<h3>Description</h3>

<p>Calculate the risk ratio (or relative risk) from
true positives, false positives, true negatives and false negatives.
The inputs must be vectors of equal length. <br /> <br />
risk_ratio = (tp / (tp + fn)) / (fp / (fp + tn)) <br />
</p>


<h3>Usage</h3>

<pre><code class='language-R'>risk_ratio(tp, fp, tn, fn, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="risk_ratio_+3A_tp">tp</code></td>
<td>
<p>(numeric) number of true positives.</p>
</td></tr>
<tr><td><code id="risk_ratio_+3A_fp">fp</code></td>
<td>
<p>(numeric) number of false positives.</p>
</td></tr>
<tr><td><code id="risk_ratio_+3A_tn">tn</code></td>
<td>
<p>(numeric) number of true negatives.</p>
</td></tr>
<tr><td><code id="risk_ratio_+3A_fn">fn</code></td>
<td>
<p>(numeric) number of false negatives.</p>
</td></tr>
<tr><td><code id="risk_ratio_+3A_...">...</code></td>
<td>
<p>for capturing additional arguments passed by method.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p>Other metric functions: 
<code><a href="#topic+F1_score">F1_score</a>()</code>,
<code><a href="#topic+Jaccard">Jaccard</a>()</code>,
<code><a href="#topic+abs_d_ppv_npv">abs_d_ppv_npv</a>()</code>,
<code><a href="#topic+abs_d_sens_spec">abs_d_sens_spec</a>()</code>,
<code><a href="#topic+accuracy">accuracy</a>()</code>,
<code><a href="#topic+cohens_kappa">cohens_kappa</a>()</code>,
<code><a href="#topic+cutpoint">cutpoint</a>()</code>,
<code><a href="#topic+false_omission_rate">false_omission_rate</a>()</code>,
<code><a href="#topic+metric_constrain">metric_constrain</a>()</code>,
<code><a href="#topic+misclassification_cost">misclassification_cost</a>()</code>,
<code><a href="#topic+npv">npv</a>()</code>,
<code><a href="#topic+odds_ratio">odds_ratio</a>()</code>,
<code><a href="#topic+p_chisquared">p_chisquared</a>()</code>,
<code><a href="#topic+plr">plr</a>()</code>,
<code><a href="#topic+ppv">ppv</a>()</code>,
<code><a href="#topic+precision">precision</a>()</code>,
<code><a href="#topic+prod_ppv_npv">prod_ppv_npv</a>()</code>,
<code><a href="#topic+prod_sens_spec">prod_sens_spec</a>()</code>,
<code><a href="#topic+recall">recall</a>()</code>,
<code><a href="#topic+roc01">roc01</a>()</code>,
<code><a href="#topic+sensitivity">sensitivity</a>()</code>,
<code><a href="#topic+specificity">specificity</a>()</code>,
<code><a href="#topic+sum_ppv_npv">sum_ppv_npv</a>()</code>,
<code><a href="#topic+sum_sens_spec">sum_sens_spec</a>()</code>,
<code><a href="#topic+total_utility">total_utility</a>()</code>,
<code><a href="#topic+tpr">tpr</a>()</code>,
<code><a href="#topic+tp">tp</a>()</code>,
<code><a href="#topic+youden">youden</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>risk_ratio(10, 5, 20, 10)
risk_ratio(c(10, 8), c(5, 7), c(20, 12), c(10, 18))
</code></pre>

<hr>
<h2 id='roc'>Calculate a ROC curve</h2><span id='topic+roc'></span>

<h3>Description</h3>

<p>Given a <code>data.frame</code> with a numeric predictor variable and a binary outcome
variable this function returns a <code>data.frame</code> that includes all elements of
the confusion matrix (true positives, false positives, true negatives,
and false negatives) for every unique value of the predictor variable.
Additionally, the true positive rate (tpr), false positive rate (fpr),
true negative rate (tnr) and false negative rate (fnr) are returned.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>roc(data, x, class, pos_class, neg_class, direction = "&gt;=", silent = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="roc_+3A_data">data</code></td>
<td>
<p>A data.frame or matrix. Will be converted to a data.frame.</p>
</td></tr>
<tr><td><code id="roc_+3A_x">x</code></td>
<td>
<p>The name of the numeric predictor variable.</p>
</td></tr>
<tr><td><code id="roc_+3A_class">class</code></td>
<td>
<p>The name of the binary outcome variable.</p>
</td></tr>
<tr><td><code id="roc_+3A_pos_class">pos_class</code></td>
<td>
<p>The value of 'class' that represents the positive cases.</p>
</td></tr>
<tr><td><code id="roc_+3A_neg_class">neg_class</code></td>
<td>
<p>The value of 'class' that represents the negative cases.</p>
</td></tr>
<tr><td><code id="roc_+3A_direction">direction</code></td>
<td>
<p>(character) One of &quot;&gt;=&quot; or &quot;&lt;=&quot;. Specifies if the positive
class is associated with higher values of x (default).</p>
</td></tr>
<tr><td><code id="roc_+3A_silent">silent</code></td>
<td>
<p>If FALSE and the ROC curve contains no positives or negatives,
a warning is generated.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>To enable classifying all observations as belonging to only one class the
predictor values will be augmented by Inf or -Inf. The returned object can
be plotted with plot_roc.
</p>
<p>This function uses tidyeval to support unquoted arguments. For programming
with <code>roc</code> the operator <code>!!</code> can be used to unquote an argument,
see the examples.
</p>


<h3>Value</h3>

<p>A data frame with the columns x.sorted, tp, fp, tn, fn, tpr, tnr, fpr,
and fnr.
</p>


<h3>Source</h3>

<p>Forked from the <span class="pkg">ROCR</span> package
</p>


<h3>See Also</h3>

<p>Other main cutpointr functions: 
<code><a href="#topic+add_metric">add_metric</a>()</code>,
<code><a href="#topic+boot_ci">boot_ci</a>()</code>,
<code><a href="#topic+boot_test">boot_test</a>()</code>,
<code><a href="#topic+cutpointr">cutpointr</a>()</code>,
<code><a href="#topic+multi_cutpointr">multi_cutpointr</a>()</code>,
<code><a href="#topic+predict.cutpointr">predict.cutpointr</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>roc_curve &lt;- roc(data = suicide, x = dsi, class = suicide,
  pos_class = "yes", neg_class = "no", direction = "&gt;=")
roc_curve
plot_roc(roc_curve)
auc(roc_curve)

## Unquoting an argument
myvar &lt;- "dsi"
roc(suicide, x = !!myvar, suicide, pos_class = "yes", neg_class = "no")
</code></pre>

<hr>
<h2 id='roc01'>Calculate the distance between points on the ROC curve and (0,1)</h2><span id='topic+roc01'></span>

<h3>Description</h3>

<p>Calculate the distance on the ROC space between points on the ROC curve
and the point of perfect discrimination
from true positives, false positives, true negatives and false negatives.
The inputs must be vectors of equal length. To be used with
<code>method = minimize_metric</code>. <br />
<br />
sensitivity = tp / (tp + fn) <br />
specificity = tn / (tn + fp) <br />
roc01 = sqrt((1 - sensitivity)^2 + (1 - specificity)^2) <br />
</p>


<h3>Usage</h3>

<pre><code class='language-R'>roc01(tp, fp, tn, fn, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="roc01_+3A_tp">tp</code></td>
<td>
<p>(numeric) number of true positives.</p>
</td></tr>
<tr><td><code id="roc01_+3A_fp">fp</code></td>
<td>
<p>(numeric) number of false positives.</p>
</td></tr>
<tr><td><code id="roc01_+3A_tn">tn</code></td>
<td>
<p>(numeric) number of true negatives.</p>
</td></tr>
<tr><td><code id="roc01_+3A_fn">fn</code></td>
<td>
<p>(numeric) number of false negatives.</p>
</td></tr>
<tr><td><code id="roc01_+3A_...">...</code></td>
<td>
<p>for capturing additional arguments passed by method.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p>Other metric functions: 
<code><a href="#topic+F1_score">F1_score</a>()</code>,
<code><a href="#topic+Jaccard">Jaccard</a>()</code>,
<code><a href="#topic+abs_d_ppv_npv">abs_d_ppv_npv</a>()</code>,
<code><a href="#topic+abs_d_sens_spec">abs_d_sens_spec</a>()</code>,
<code><a href="#topic+accuracy">accuracy</a>()</code>,
<code><a href="#topic+cohens_kappa">cohens_kappa</a>()</code>,
<code><a href="#topic+cutpoint">cutpoint</a>()</code>,
<code><a href="#topic+false_omission_rate">false_omission_rate</a>()</code>,
<code><a href="#topic+metric_constrain">metric_constrain</a>()</code>,
<code><a href="#topic+misclassification_cost">misclassification_cost</a>()</code>,
<code><a href="#topic+npv">npv</a>()</code>,
<code><a href="#topic+odds_ratio">odds_ratio</a>()</code>,
<code><a href="#topic+p_chisquared">p_chisquared</a>()</code>,
<code><a href="#topic+plr">plr</a>()</code>,
<code><a href="#topic+ppv">ppv</a>()</code>,
<code><a href="#topic+precision">precision</a>()</code>,
<code><a href="#topic+prod_ppv_npv">prod_ppv_npv</a>()</code>,
<code><a href="#topic+prod_sens_spec">prod_sens_spec</a>()</code>,
<code><a href="#topic+recall">recall</a>()</code>,
<code><a href="#topic+risk_ratio">risk_ratio</a>()</code>,
<code><a href="#topic+sensitivity">sensitivity</a>()</code>,
<code><a href="#topic+specificity">specificity</a>()</code>,
<code><a href="#topic+sum_ppv_npv">sum_ppv_npv</a>()</code>,
<code><a href="#topic+sum_sens_spec">sum_sens_spec</a>()</code>,
<code><a href="#topic+total_utility">total_utility</a>()</code>,
<code><a href="#topic+tpr">tpr</a>()</code>,
<code><a href="#topic+tp">tp</a>()</code>,
<code><a href="#topic+youden">youden</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>roc01(10, 5, 20, 10)
roc01(c(10, 8), c(5, 7), c(20, 12), c(10, 18))
oc &lt;- cutpointr(suicide, dsi, suicide,
  method = minimize_metric, metric = roc01)
plot_roc(oc)
</code></pre>

<hr>
<h2 id='sensitivity'>Calculate sensitivity</h2><span id='topic+sensitivity'></span>

<h3>Description</h3>

<p>Calculate sensitivity from
true positives, false positives, true negatives and false negatives.
The inputs must be vectors of equal length. <br /> <br />
sensitivity = tp / (tp + fn) <br />
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sensitivity(tp, fn, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sensitivity_+3A_tp">tp</code></td>
<td>
<p>(numeric) number of true positives.</p>
</td></tr>
<tr><td><code id="sensitivity_+3A_fn">fn</code></td>
<td>
<p>(numeric) number of false negatives.</p>
</td></tr>
<tr><td><code id="sensitivity_+3A_...">...</code></td>
<td>
<p>for capturing additional arguments passed by method.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p>Other metric functions: 
<code><a href="#topic+F1_score">F1_score</a>()</code>,
<code><a href="#topic+Jaccard">Jaccard</a>()</code>,
<code><a href="#topic+abs_d_ppv_npv">abs_d_ppv_npv</a>()</code>,
<code><a href="#topic+abs_d_sens_spec">abs_d_sens_spec</a>()</code>,
<code><a href="#topic+accuracy">accuracy</a>()</code>,
<code><a href="#topic+cohens_kappa">cohens_kappa</a>()</code>,
<code><a href="#topic+cutpoint">cutpoint</a>()</code>,
<code><a href="#topic+false_omission_rate">false_omission_rate</a>()</code>,
<code><a href="#topic+metric_constrain">metric_constrain</a>()</code>,
<code><a href="#topic+misclassification_cost">misclassification_cost</a>()</code>,
<code><a href="#topic+npv">npv</a>()</code>,
<code><a href="#topic+odds_ratio">odds_ratio</a>()</code>,
<code><a href="#topic+p_chisquared">p_chisquared</a>()</code>,
<code><a href="#topic+plr">plr</a>()</code>,
<code><a href="#topic+ppv">ppv</a>()</code>,
<code><a href="#topic+precision">precision</a>()</code>,
<code><a href="#topic+prod_ppv_npv">prod_ppv_npv</a>()</code>,
<code><a href="#topic+prod_sens_spec">prod_sens_spec</a>()</code>,
<code><a href="#topic+recall">recall</a>()</code>,
<code><a href="#topic+risk_ratio">risk_ratio</a>()</code>,
<code><a href="#topic+roc01">roc01</a>()</code>,
<code><a href="#topic+specificity">specificity</a>()</code>,
<code><a href="#topic+sum_ppv_npv">sum_ppv_npv</a>()</code>,
<code><a href="#topic+sum_sens_spec">sum_sens_spec</a>()</code>,
<code><a href="#topic+total_utility">total_utility</a>()</code>,
<code><a href="#topic+tpr">tpr</a>()</code>,
<code><a href="#topic+tp">tp</a>()</code>,
<code><a href="#topic+youden">youden</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>sensitivity(10, 5, 20, 10)
sensitivity(c(10, 8), c(5, 7), c(20, 12), c(10, 18))
</code></pre>

<hr>
<h2 id='specificity'>Calculate specificity</h2><span id='topic+specificity'></span>

<h3>Description</h3>

<p>Calculate specificity from true positives, false positives, true negatives and false negatives.
The inputs must be vectors of equal length. <br /> <br />
specificity = tn / (tn + fp) <br />
</p>


<h3>Usage</h3>

<pre><code class='language-R'>specificity(fp, tn, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="specificity_+3A_fp">fp</code></td>
<td>
<p>(numeric) number of false positives.</p>
</td></tr>
<tr><td><code id="specificity_+3A_tn">tn</code></td>
<td>
<p>(numeric) number of true negatives.</p>
</td></tr>
<tr><td><code id="specificity_+3A_...">...</code></td>
<td>
<p>for capturing additional arguments passed by method.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p>Other metric functions: 
<code><a href="#topic+F1_score">F1_score</a>()</code>,
<code><a href="#topic+Jaccard">Jaccard</a>()</code>,
<code><a href="#topic+abs_d_ppv_npv">abs_d_ppv_npv</a>()</code>,
<code><a href="#topic+abs_d_sens_spec">abs_d_sens_spec</a>()</code>,
<code><a href="#topic+accuracy">accuracy</a>()</code>,
<code><a href="#topic+cohens_kappa">cohens_kappa</a>()</code>,
<code><a href="#topic+cutpoint">cutpoint</a>()</code>,
<code><a href="#topic+false_omission_rate">false_omission_rate</a>()</code>,
<code><a href="#topic+metric_constrain">metric_constrain</a>()</code>,
<code><a href="#topic+misclassification_cost">misclassification_cost</a>()</code>,
<code><a href="#topic+npv">npv</a>()</code>,
<code><a href="#topic+odds_ratio">odds_ratio</a>()</code>,
<code><a href="#topic+p_chisquared">p_chisquared</a>()</code>,
<code><a href="#topic+plr">plr</a>()</code>,
<code><a href="#topic+ppv">ppv</a>()</code>,
<code><a href="#topic+precision">precision</a>()</code>,
<code><a href="#topic+prod_ppv_npv">prod_ppv_npv</a>()</code>,
<code><a href="#topic+prod_sens_spec">prod_sens_spec</a>()</code>,
<code><a href="#topic+recall">recall</a>()</code>,
<code><a href="#topic+risk_ratio">risk_ratio</a>()</code>,
<code><a href="#topic+roc01">roc01</a>()</code>,
<code><a href="#topic+sensitivity">sensitivity</a>()</code>,
<code><a href="#topic+sum_ppv_npv">sum_ppv_npv</a>()</code>,
<code><a href="#topic+sum_sens_spec">sum_sens_spec</a>()</code>,
<code><a href="#topic+total_utility">total_utility</a>()</code>,
<code><a href="#topic+tpr">tpr</a>()</code>,
<code><a href="#topic+tp">tp</a>()</code>,
<code><a href="#topic+youden">youden</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>specificity(10, 5, 20, 10)
specificity(c(10, 8), c(5, 7), c(20, 12), c(10, 18))
</code></pre>

<hr>
<h2 id='suicide'>Suicide attempts and DSI sum scores of 532 subjects</h2><span id='topic+suicide'></span>

<h3>Description</h3>

<p>Various personality and clinical psychological characteristics were assessed
as part of an online-study preventing suicide. To identify persons at risk
for attempting suicide, various demographic and clinical characteristics
were assessed. Depressive Symptom Inventory - Suicidality Subscale
(DSA-SS) sum scores and past suicide attempts from 532 subjects are
included as a demonstration set to calculate optimal cutpoints. Two
additional demographic variables (age, gender) are also included to test
for group differences.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>suicide
</code></pre>


<h3>Format</h3>

<p>A data frame with 532 rows and 4 variables:
</p>

<dl>
<dt>age</dt><dd><p>(numeric) Age of participants in years</p>
</dd>
<dt>gender</dt><dd><p>(factor) Gender</p>
</dd>
<dt>dsi</dt><dd><p>(numeric) Sum-score (0 = low suicidality, 12 = high suicidality)</p>
</dd>
<dt>suicide</dt><dd><p>(factor) Past suicide attempt (no = no attempt, yes = at least one attempt)</p>
</dd>
</dl>



<h3>Source</h3>

<p>von Glischinski, M., Teisman, T., Prinz, S., Gebauer, J., and Hirschfeld, G. (2017). Depressive Symptom Inventory- Suicidality Subscale: Optimal cut points for clinical and non-clinical samples. Clinical Psychology &amp; Psychotherapy
</p>

<hr>
<h2 id='sum_ppv_npv'>Calculate the sum of positive and negative predictive value</h2><span id='topic+sum_ppv_npv'></span>

<h3>Description</h3>

<p>Calculate the sum of positive predictive value (PPV) and
negative predictive value (NPV) from
true positives, false positives, true negatives and false negatives.
The inputs must be vectors of equal length. <br /> <br />
ppv = tp / (tp + fp) <br />
npv = tn / (tn + fn) <br />
sum_ppv_npv = ppv + npv <br />
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sum_ppv_npv(tp, fp, tn, fn, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sum_ppv_npv_+3A_tp">tp</code></td>
<td>
<p>(numeric) number of true positives.</p>
</td></tr>
<tr><td><code id="sum_ppv_npv_+3A_fp">fp</code></td>
<td>
<p>(numeric) number of false positives.</p>
</td></tr>
<tr><td><code id="sum_ppv_npv_+3A_tn">tn</code></td>
<td>
<p>(numeric) number of true negatives.</p>
</td></tr>
<tr><td><code id="sum_ppv_npv_+3A_fn">fn</code></td>
<td>
<p>(numeric) number of false negatives.</p>
</td></tr>
<tr><td><code id="sum_ppv_npv_+3A_...">...</code></td>
<td>
<p>for capturing additional arguments passed by method.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p>Other metric functions: 
<code><a href="#topic+F1_score">F1_score</a>()</code>,
<code><a href="#topic+Jaccard">Jaccard</a>()</code>,
<code><a href="#topic+abs_d_ppv_npv">abs_d_ppv_npv</a>()</code>,
<code><a href="#topic+abs_d_sens_spec">abs_d_sens_spec</a>()</code>,
<code><a href="#topic+accuracy">accuracy</a>()</code>,
<code><a href="#topic+cohens_kappa">cohens_kappa</a>()</code>,
<code><a href="#topic+cutpoint">cutpoint</a>()</code>,
<code><a href="#topic+false_omission_rate">false_omission_rate</a>()</code>,
<code><a href="#topic+metric_constrain">metric_constrain</a>()</code>,
<code><a href="#topic+misclassification_cost">misclassification_cost</a>()</code>,
<code><a href="#topic+npv">npv</a>()</code>,
<code><a href="#topic+odds_ratio">odds_ratio</a>()</code>,
<code><a href="#topic+p_chisquared">p_chisquared</a>()</code>,
<code><a href="#topic+plr">plr</a>()</code>,
<code><a href="#topic+ppv">ppv</a>()</code>,
<code><a href="#topic+precision">precision</a>()</code>,
<code><a href="#topic+prod_ppv_npv">prod_ppv_npv</a>()</code>,
<code><a href="#topic+prod_sens_spec">prod_sens_spec</a>()</code>,
<code><a href="#topic+recall">recall</a>()</code>,
<code><a href="#topic+risk_ratio">risk_ratio</a>()</code>,
<code><a href="#topic+roc01">roc01</a>()</code>,
<code><a href="#topic+sensitivity">sensitivity</a>()</code>,
<code><a href="#topic+specificity">specificity</a>()</code>,
<code><a href="#topic+sum_sens_spec">sum_sens_spec</a>()</code>,
<code><a href="#topic+total_utility">total_utility</a>()</code>,
<code><a href="#topic+tpr">tpr</a>()</code>,
<code><a href="#topic+tp">tp</a>()</code>,
<code><a href="#topic+youden">youden</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>sum_ppv_npv(10, 5, 20, 10)
sum_ppv_npv(c(10, 8), c(5, 7), c(20, 12), c(10, 18))
</code></pre>

<hr>
<h2 id='sum_sens_spec'>Calculate the sum of sensitivity and specificity</h2><span id='topic+sum_sens_spec'></span>

<h3>Description</h3>

<p>Calculate the sum of sensitivity and specificity from
true positives, false positives, true negatives and false negatives.
The inputs must be vectors of equal length. <br /> <br />
sensitivity = tp / (tp + fn) <br />
specificity = tn / (tn + fp) <br />
sum_sens_spec = sensitivity + specificity <br />
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sum_sens_spec(tp, fp, tn, fn, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sum_sens_spec_+3A_tp">tp</code></td>
<td>
<p>(numeric) number of true positives.</p>
</td></tr>
<tr><td><code id="sum_sens_spec_+3A_fp">fp</code></td>
<td>
<p>(numeric) number of false positives.</p>
</td></tr>
<tr><td><code id="sum_sens_spec_+3A_tn">tn</code></td>
<td>
<p>(numeric) number of true negatives.</p>
</td></tr>
<tr><td><code id="sum_sens_spec_+3A_fn">fn</code></td>
<td>
<p>(numeric) number of false negatives.</p>
</td></tr>
<tr><td><code id="sum_sens_spec_+3A_...">...</code></td>
<td>
<p>for capturing additional arguments passed by method.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p>Other metric functions: 
<code><a href="#topic+F1_score">F1_score</a>()</code>,
<code><a href="#topic+Jaccard">Jaccard</a>()</code>,
<code><a href="#topic+abs_d_ppv_npv">abs_d_ppv_npv</a>()</code>,
<code><a href="#topic+abs_d_sens_spec">abs_d_sens_spec</a>()</code>,
<code><a href="#topic+accuracy">accuracy</a>()</code>,
<code><a href="#topic+cohens_kappa">cohens_kappa</a>()</code>,
<code><a href="#topic+cutpoint">cutpoint</a>()</code>,
<code><a href="#topic+false_omission_rate">false_omission_rate</a>()</code>,
<code><a href="#topic+metric_constrain">metric_constrain</a>()</code>,
<code><a href="#topic+misclassification_cost">misclassification_cost</a>()</code>,
<code><a href="#topic+npv">npv</a>()</code>,
<code><a href="#topic+odds_ratio">odds_ratio</a>()</code>,
<code><a href="#topic+p_chisquared">p_chisquared</a>()</code>,
<code><a href="#topic+plr">plr</a>()</code>,
<code><a href="#topic+ppv">ppv</a>()</code>,
<code><a href="#topic+precision">precision</a>()</code>,
<code><a href="#topic+prod_ppv_npv">prod_ppv_npv</a>()</code>,
<code><a href="#topic+prod_sens_spec">prod_sens_spec</a>()</code>,
<code><a href="#topic+recall">recall</a>()</code>,
<code><a href="#topic+risk_ratio">risk_ratio</a>()</code>,
<code><a href="#topic+roc01">roc01</a>()</code>,
<code><a href="#topic+sensitivity">sensitivity</a>()</code>,
<code><a href="#topic+specificity">specificity</a>()</code>,
<code><a href="#topic+sum_ppv_npv">sum_ppv_npv</a>()</code>,
<code><a href="#topic+total_utility">total_utility</a>()</code>,
<code><a href="#topic+tpr">tpr</a>()</code>,
<code><a href="#topic+tp">tp</a>()</code>,
<code><a href="#topic+youden">youden</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>sum_sens_spec(10, 5, 20, 10)
sum_sens_spec(c(10, 8), c(5, 7), c(20, 12), c(10, 18))
</code></pre>

<hr>
<h2 id='total_utility'>Calculate the total utility</h2><span id='topic+total_utility'></span>

<h3>Description</h3>

<p>Calculate the total utility from
true positives, false positives, true negatives and false negatives. <br /> <br />
total_utility = utility_tp * tp + utility_tn * tn - cost_fp * fp - cost_fn * fn <br /> <br />
The inputs must be vectors of equal length.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>total_utility(
  tp,
  fp,
  tn,
  fn,
  utility_tp = 1,
  utility_tn = 1,
  cost_fp = 1,
  cost_fn = 1,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="total_utility_+3A_tp">tp</code></td>
<td>
<p>(numeric) number of true positives.</p>
</td></tr>
<tr><td><code id="total_utility_+3A_fp">fp</code></td>
<td>
<p>(numeric) number of false positives.</p>
</td></tr>
<tr><td><code id="total_utility_+3A_tn">tn</code></td>
<td>
<p>(numeric) number of true negatives.</p>
</td></tr>
<tr><td><code id="total_utility_+3A_fn">fn</code></td>
<td>
<p>(numeric) number of false negatives.</p>
</td></tr>
<tr><td><code id="total_utility_+3A_utility_tp">utility_tp</code></td>
<td>
<p>(numeric) the utility of a true positive</p>
</td></tr>
<tr><td><code id="total_utility_+3A_utility_tn">utility_tn</code></td>
<td>
<p>(numeric) the utility of a true negative</p>
</td></tr>
<tr><td><code id="total_utility_+3A_cost_fp">cost_fp</code></td>
<td>
<p>(numeric) the cost of a false positive</p>
</td></tr>
<tr><td><code id="total_utility_+3A_cost_fn">cost_fn</code></td>
<td>
<p>(numeric) the cost of a false negative</p>
</td></tr>
<tr><td><code id="total_utility_+3A_...">...</code></td>
<td>
<p>for capturing additional arguments passed by method.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p>Other metric functions: 
<code><a href="#topic+F1_score">F1_score</a>()</code>,
<code><a href="#topic+Jaccard">Jaccard</a>()</code>,
<code><a href="#topic+abs_d_ppv_npv">abs_d_ppv_npv</a>()</code>,
<code><a href="#topic+abs_d_sens_spec">abs_d_sens_spec</a>()</code>,
<code><a href="#topic+accuracy">accuracy</a>()</code>,
<code><a href="#topic+cohens_kappa">cohens_kappa</a>()</code>,
<code><a href="#topic+cutpoint">cutpoint</a>()</code>,
<code><a href="#topic+false_omission_rate">false_omission_rate</a>()</code>,
<code><a href="#topic+metric_constrain">metric_constrain</a>()</code>,
<code><a href="#topic+misclassification_cost">misclassification_cost</a>()</code>,
<code><a href="#topic+npv">npv</a>()</code>,
<code><a href="#topic+odds_ratio">odds_ratio</a>()</code>,
<code><a href="#topic+p_chisquared">p_chisquared</a>()</code>,
<code><a href="#topic+plr">plr</a>()</code>,
<code><a href="#topic+ppv">ppv</a>()</code>,
<code><a href="#topic+precision">precision</a>()</code>,
<code><a href="#topic+prod_ppv_npv">prod_ppv_npv</a>()</code>,
<code><a href="#topic+prod_sens_spec">prod_sens_spec</a>()</code>,
<code><a href="#topic+recall">recall</a>()</code>,
<code><a href="#topic+risk_ratio">risk_ratio</a>()</code>,
<code><a href="#topic+roc01">roc01</a>()</code>,
<code><a href="#topic+sensitivity">sensitivity</a>()</code>,
<code><a href="#topic+specificity">specificity</a>()</code>,
<code><a href="#topic+sum_ppv_npv">sum_ppv_npv</a>()</code>,
<code><a href="#topic+sum_sens_spec">sum_sens_spec</a>()</code>,
<code><a href="#topic+tpr">tpr</a>()</code>,
<code><a href="#topic+tp">tp</a>()</code>,
<code><a href="#topic+youden">youden</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>total_utility(10, 5, 20, 10, utility_tp = 3, utility_tn = 3, cost_fp = 1, cost_fn = 5)
total_utility(c(10, 8), c(5, 7), c(20, 12), c(10, 18),
              utility_tp = 3, utility_tn = 3, cost_fp = 1, cost_fn = 5)
</code></pre>

<hr>
<h2 id='tp'>Extract number true / false positives / negatives</h2><span id='topic+tp'></span><span id='topic+tn'></span><span id='topic+fp'></span><span id='topic+fn'></span>

<h3>Description</h3>

<p>Extract the number of true positives (tp), false positives (fp),
true negatives (tn), or false negatives (fn).
The inputs must be vectors of equal length. Mainly useful for <code>plot_cutpointr</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tp(tp, ...)

tn(tn, ...)

fp(fp, ...)

fn(fn, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tp_+3A_tp">tp</code></td>
<td>
<p>(numeric) number of true positives.</p>
</td></tr>
<tr><td><code id="tp_+3A_...">...</code></td>
<td>
<p>for capturing additional arguments passed by method.</p>
</td></tr>
<tr><td><code id="tp_+3A_tn">tn</code></td>
<td>
<p>(numeric) number of true negatives.</p>
</td></tr>
<tr><td><code id="tp_+3A_fp">fp</code></td>
<td>
<p>(numeric) number of false positives.</p>
</td></tr>
<tr><td><code id="tp_+3A_fn">fn</code></td>
<td>
<p>(numeric) number of false negatives.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p>Other metric functions: 
<code><a href="#topic+F1_score">F1_score</a>()</code>,
<code><a href="#topic+Jaccard">Jaccard</a>()</code>,
<code><a href="#topic+abs_d_ppv_npv">abs_d_ppv_npv</a>()</code>,
<code><a href="#topic+abs_d_sens_spec">abs_d_sens_spec</a>()</code>,
<code><a href="#topic+accuracy">accuracy</a>()</code>,
<code><a href="#topic+cohens_kappa">cohens_kappa</a>()</code>,
<code><a href="#topic+cutpoint">cutpoint</a>()</code>,
<code><a href="#topic+false_omission_rate">false_omission_rate</a>()</code>,
<code><a href="#topic+metric_constrain">metric_constrain</a>()</code>,
<code><a href="#topic+misclassification_cost">misclassification_cost</a>()</code>,
<code><a href="#topic+npv">npv</a>()</code>,
<code><a href="#topic+odds_ratio">odds_ratio</a>()</code>,
<code><a href="#topic+p_chisquared">p_chisquared</a>()</code>,
<code><a href="#topic+plr">plr</a>()</code>,
<code><a href="#topic+ppv">ppv</a>()</code>,
<code><a href="#topic+precision">precision</a>()</code>,
<code><a href="#topic+prod_ppv_npv">prod_ppv_npv</a>()</code>,
<code><a href="#topic+prod_sens_spec">prod_sens_spec</a>()</code>,
<code><a href="#topic+recall">recall</a>()</code>,
<code><a href="#topic+risk_ratio">risk_ratio</a>()</code>,
<code><a href="#topic+roc01">roc01</a>()</code>,
<code><a href="#topic+sensitivity">sensitivity</a>()</code>,
<code><a href="#topic+specificity">specificity</a>()</code>,
<code><a href="#topic+sum_ppv_npv">sum_ppv_npv</a>()</code>,
<code><a href="#topic+sum_sens_spec">sum_sens_spec</a>()</code>,
<code><a href="#topic+total_utility">total_utility</a>()</code>,
<code><a href="#topic+tpr">tpr</a>()</code>,
<code><a href="#topic+youden">youden</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>tp(10, 5, 20, 10)
tp(c(10, 8), c(5, 7), c(20, 12), c(10, 18))
fp(10, 5, 20, 10)
tn(10, 5, 20, 10)
fn(10, 5, 20, 10)
</code></pre>

<hr>
<h2 id='tpr'>Calculate true / false positive / negative rate</h2><span id='topic+tpr'></span><span id='topic+fpr'></span><span id='topic+tnr'></span><span id='topic+fnr'></span>

<h3>Description</h3>

<p>Calculate the true positive rate (tpr, equal to sensitivity and recall),
the false positive rate (fpr, equal to fall-out),
the true negative rate (tnr, equal to specificity),
or the false negative rate (fnr) from
true positives, false positives, true negatives and false negatives.
The inputs must be vectors of equal length. <br /> <br />
tpr = tp / (tp + fn) <br />
fpr = fp / (fp + tn) <br />
tnr = tn / (tn + fp) <br />
fnr = fn / (fn + tp) <br />
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tpr(tp, fn, ...)

fpr(fp, tn, ...)

tnr(fp, tn, ...)

fnr(tp, fn, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tpr_+3A_tp">tp</code></td>
<td>
<p>(numeric) number of true positives.</p>
</td></tr>
<tr><td><code id="tpr_+3A_fn">fn</code></td>
<td>
<p>(numeric) number of false negatives.</p>
</td></tr>
<tr><td><code id="tpr_+3A_...">...</code></td>
<td>
<p>for capturing additional arguments passed by method.</p>
</td></tr>
<tr><td><code id="tpr_+3A_fp">fp</code></td>
<td>
<p>(numeric) number of false positives.</p>
</td></tr>
<tr><td><code id="tpr_+3A_tn">tn</code></td>
<td>
<p>(numeric) number of true negatives.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p>Other metric functions: 
<code><a href="#topic+F1_score">F1_score</a>()</code>,
<code><a href="#topic+Jaccard">Jaccard</a>()</code>,
<code><a href="#topic+abs_d_ppv_npv">abs_d_ppv_npv</a>()</code>,
<code><a href="#topic+abs_d_sens_spec">abs_d_sens_spec</a>()</code>,
<code><a href="#topic+accuracy">accuracy</a>()</code>,
<code><a href="#topic+cohens_kappa">cohens_kappa</a>()</code>,
<code><a href="#topic+cutpoint">cutpoint</a>()</code>,
<code><a href="#topic+false_omission_rate">false_omission_rate</a>()</code>,
<code><a href="#topic+metric_constrain">metric_constrain</a>()</code>,
<code><a href="#topic+misclassification_cost">misclassification_cost</a>()</code>,
<code><a href="#topic+npv">npv</a>()</code>,
<code><a href="#topic+odds_ratio">odds_ratio</a>()</code>,
<code><a href="#topic+p_chisquared">p_chisquared</a>()</code>,
<code><a href="#topic+plr">plr</a>()</code>,
<code><a href="#topic+ppv">ppv</a>()</code>,
<code><a href="#topic+precision">precision</a>()</code>,
<code><a href="#topic+prod_ppv_npv">prod_ppv_npv</a>()</code>,
<code><a href="#topic+prod_sens_spec">prod_sens_spec</a>()</code>,
<code><a href="#topic+recall">recall</a>()</code>,
<code><a href="#topic+risk_ratio">risk_ratio</a>()</code>,
<code><a href="#topic+roc01">roc01</a>()</code>,
<code><a href="#topic+sensitivity">sensitivity</a>()</code>,
<code><a href="#topic+specificity">specificity</a>()</code>,
<code><a href="#topic+sum_ppv_npv">sum_ppv_npv</a>()</code>,
<code><a href="#topic+sum_sens_spec">sum_sens_spec</a>()</code>,
<code><a href="#topic+total_utility">total_utility</a>()</code>,
<code><a href="#topic+tp">tp</a>()</code>,
<code><a href="#topic+youden">youden</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>tpr(10, 5, 20, 10)
tpr(c(10, 8), c(5, 7), c(20, 12), c(10, 18))
</code></pre>

<hr>
<h2 id='user_span_cutpointr'>Calculate bandwidth for LOESS smoothing of metric functions by rule of thumb</h2><span id='topic+user_span_cutpointr'></span>

<h3>Description</h3>

<p>This function implements a rule of thumb for selecting the bandwidth when
smoothing a function of metric values per cutpoint value, particularly
in <code>maximize_loess_metric</code> and <code>minimize_loess_metric</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>user_span_cutpointr(data, x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="user_span_cutpointr_+3A_data">data</code></td>
<td>
<p>A data frame</p>
</td></tr>
<tr><td><code id="user_span_cutpointr_+3A_x">x</code></td>
<td>
<p>The predictor variable</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function used for calculating the bandwidth is 0.1 * xsd / sqrt(xn),
where xsd is the standard deviation of the unique values of the predictor
variable (i.e. all cutpoints) and xn is the number of unique predictor values.
</p>

<hr>
<h2 id='youden'>Calculate the Youden-Index</h2><span id='topic+youden'></span>

<h3>Description</h3>

<p>Calculate the Youden-Index (J-Index) from
true positives, false positives, true negatives and false negatives.
The inputs must be vectors of equal length. <br /> <br />
sensitivity = tp / (tp + fn) <br />
specificity = tn / (tn + fp) <br />
youden_index = sensitivity + specificity - 1 <br />
</p>


<h3>Usage</h3>

<pre><code class='language-R'>youden(tp, fp, tn, fn, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="youden_+3A_tp">tp</code></td>
<td>
<p>(numeric) number of true positives.</p>
</td></tr>
<tr><td><code id="youden_+3A_fp">fp</code></td>
<td>
<p>(numeric) number of false positives.</p>
</td></tr>
<tr><td><code id="youden_+3A_tn">tn</code></td>
<td>
<p>(numeric) number of true negatives.</p>
</td></tr>
<tr><td><code id="youden_+3A_fn">fn</code></td>
<td>
<p>(numeric) number of false negatives.</p>
</td></tr>
<tr><td><code id="youden_+3A_...">...</code></td>
<td>
<p>for capturing additional arguments passed by method.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p>Other metric functions: 
<code><a href="#topic+F1_score">F1_score</a>()</code>,
<code><a href="#topic+Jaccard">Jaccard</a>()</code>,
<code><a href="#topic+abs_d_ppv_npv">abs_d_ppv_npv</a>()</code>,
<code><a href="#topic+abs_d_sens_spec">abs_d_sens_spec</a>()</code>,
<code><a href="#topic+accuracy">accuracy</a>()</code>,
<code><a href="#topic+cohens_kappa">cohens_kappa</a>()</code>,
<code><a href="#topic+cutpoint">cutpoint</a>()</code>,
<code><a href="#topic+false_omission_rate">false_omission_rate</a>()</code>,
<code><a href="#topic+metric_constrain">metric_constrain</a>()</code>,
<code><a href="#topic+misclassification_cost">misclassification_cost</a>()</code>,
<code><a href="#topic+npv">npv</a>()</code>,
<code><a href="#topic+odds_ratio">odds_ratio</a>()</code>,
<code><a href="#topic+p_chisquared">p_chisquared</a>()</code>,
<code><a href="#topic+plr">plr</a>()</code>,
<code><a href="#topic+ppv">ppv</a>()</code>,
<code><a href="#topic+precision">precision</a>()</code>,
<code><a href="#topic+prod_ppv_npv">prod_ppv_npv</a>()</code>,
<code><a href="#topic+prod_sens_spec">prod_sens_spec</a>()</code>,
<code><a href="#topic+recall">recall</a>()</code>,
<code><a href="#topic+risk_ratio">risk_ratio</a>()</code>,
<code><a href="#topic+roc01">roc01</a>()</code>,
<code><a href="#topic+sensitivity">sensitivity</a>()</code>,
<code><a href="#topic+specificity">specificity</a>()</code>,
<code><a href="#topic+sum_ppv_npv">sum_ppv_npv</a>()</code>,
<code><a href="#topic+sum_sens_spec">sum_sens_spec</a>()</code>,
<code><a href="#topic+total_utility">total_utility</a>()</code>,
<code><a href="#topic+tpr">tpr</a>()</code>,
<code><a href="#topic+tp">tp</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>youden(10, 5, 20, 10)
youden(c(10, 8), c(5, 7), c(20, 12), c(10, 18))
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
