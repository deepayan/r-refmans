<!DOCTYPE html><html lang="en"><head><title>Help for package mappeR</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {mappeR}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#mappeR-package'><p>mappeR: Construct and Visualize TDA Mapper Graphs</p></a></li>
<li><a href='#assemble_mapper_object'><p>Construct mapper graph from data</p></a></li>
<li><a href='#check_in_interval'><p>Get a tester function for an interval.</p></a></li>
<li><a href='#compute_tightness'><p>Compute dispersion of a single cluster</p></a></li>
<li><a href='#convert_to_clusters'><p>&quot;Clustering&quot; for ballmapper just means treating each bin as its own cluster.</p></a></li>
<li><a href='#create_1D_mapper_object'><p>Run 1D mapper</p></a></li>
<li><a href='#create_ball_mapper_object'><p>Run mapper using a trivial filter, a cover of balls, and no clustering algorithm.</p></a></li>
<li><a href='#create_balls'><p>Make a cover of balls</p></a></li>
<li><a href='#create_bins'><p>Create bins of data</p></a></li>
<li><a href='#create_clusterball_mapper_object'><p>Run clusterball mapper</p></a></li>
<li><a href='#create_mapper_object'><p>Create a mapper object</p></a></li>
<li><a href='#create_single_bin'><p>Create a bin of data</p></a></li>
<li><a href='#create_width_balanced_cover'><p>Generate an overlapping cover of an interval</p></a></li>
<li><a href='#cut_dendrogram'><p>Cut a dendrogram in context</p></a></li>
<li><a href='#eccentricity_filter'><p>Compute eccentricity of data points</p></a></li>
<li><a href='#get_bin_vector'><p>Recover bins</p></a></li>
<li><a href='#get_cluster_sizes'><p>Compute cluster sizes</p></a></li>
<li><a href='#get_cluster_tightness_vector'><p>Compute dispersion measures of a list of clusters</p></a></li>
<li><a href='#get_clustered_data'><p>Get data within a cluster</p></a></li>
<li><a href='#get_clusters'><p>Perform the clustering step in mapper</p></a></li>
<li><a href='#get_edge_weights'><p>Calculate edge weights</p></a></li>
<li><a href='#get_edgelist_from_overlaps'><p>Obtain edge list from cluster intersections</p></a></li>
<li><a href='#get_hierarchical_clusters'><p>Perform single-linkage hierarchical clustering and process dendrograms in a semi-global context.</p></a></li>
<li><a href='#get_overlaps'><p>Get cluster overlaps</p></a></li>
<li><a href='#get_raw_clusters'><p>Ship data off to the clustering goblins</p></a></li>
<li><a href='#get_tallest_branch'><p>Find the tallest branch of a dendrogram</p></a></li>
<li><a href='#hierarchical_clusterer'><p>Create a little dude to perform hierarchical clustering in a semi-global context using the hclust package.</p></a></li>
<li><a href='#is_in_ball'><p>Get a tester function for a ball.</p></a></li>
<li><a href='#mapper_object_to_igraph'><p>make igraph</p></a></li>
<li><a href='#next_triangular'><p>Find which triangular number you're on</p></a></li>
<li><a href='#process_dendrograms'><p>Cut many dendrograms in context</p></a></li>
<li><a href='#run_link'><p>Perform agglomerative clustering on a single distance matrix.</p></a></li>
<li><a href='#subset_dists'><p>Subset a distance matrix</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Construct and Visualize TDA Mapper Graphs</td>
</tr>
<tr>
<td>Description:</td>
<td>Topological data analysis (TDA) is a method of data analysis that 
  uses techniques from topology to analyze high-dimensional data. Here we
  implement Mapper, an algorithm from this area developed by Singh, Mémoli and 
  Carlsson (2007) which generalizes the concept of a 
  Reeb graph <a href="https://en.wikipedia.org/wiki/Reeb_graph">https://en.wikipedia.org/wiki/Reeb_graph</a>.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://opensource.org/licenses/mit-license.php">MIT</a> + file LICENSE</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/Uiowa-Applied-Topology/mappeR">https://github.com/Uiowa-Applied-Topology/mappeR</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/Uiowa-Applied-Topology/mappeR/issues">https://github.com/Uiowa-Applied-Topology/mappeR/issues</a></td>
</tr>
<tr>
<td>Version:</td>
<td>2.0.2</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>Imports:</td>
<td>fastcluster, grDevices, igraph, stats, utils</td>
</tr>
<tr>
<td>Suggests:</td>
<td>testthat (&ge; 3.0.0)</td>
</tr>
<tr>
<td>Config/testthat/edition:</td>
<td>3</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.3.2</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2025-02-20 15:19:48 UTC; gergill</td>
</tr>
<tr>
<td>Author:</td>
<td>George Clare Kennedy [aut, cre]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>George Clare Kennedy &lt;george-clarekennedy@uiowa.edu&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2025-02-20 18:10:05 UTC</td>
</tr>
</table>
<hr>
<h2 id='mappeR-package'>mappeR: Construct and Visualize TDA Mapper Graphs</h2><span id='topic+mappeR'></span><span id='topic+mappeR-package'></span>

<h3>Description</h3>

<p>Topological data analysis (TDA) is a method of data analysis that uses techniques from topology to analyze high-dimensional data. Here we implement Mapper, an algorithm from this area developed by Singh, Mémoli and Carlsson (2007) which generalizes the concept of a Reeb graph <a href="https://en.wikipedia.org/wiki/Reeb_graph">https://en.wikipedia.org/wiki/Reeb_graph</a>.
</p>


<h3>Author(s)</h3>

<p><strong>Maintainer</strong>: George Clare Kennedy <a href="mailto:george-clarekennedy@uiowa.edu">george-clarekennedy@uiowa.edu</a>
</p>


<h3>See Also</h3>

<p>Useful links:
</p>

<ul>
<li> <p><a href="https://github.com/Uiowa-Applied-Topology/mappeR">https://github.com/Uiowa-Applied-Topology/mappeR</a>
</p>
</li>
<li><p> Report bugs at <a href="https://github.com/Uiowa-Applied-Topology/mappeR/issues">https://github.com/Uiowa-Applied-Topology/mappeR/issues</a>
</p>
</li></ul>


<hr>
<h2 id='assemble_mapper_object'>Construct mapper graph from data</h2><span id='topic+assemble_mapper_object'></span>

<h3>Description</h3>

<p>Construct mapper graph from data
</p>


<h3>Usage</h3>

<pre><code class='language-R'>assemble_mapper_object(binclust_data, dists, binning = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="assemble_mapper_object_+3A_binclust_data">binclust_data</code></td>
<td>
<p>A list of bins, each containing named vectors whose names are those of data points and whose values are cluster ids</p>
</td></tr>
<tr><td><code id="assemble_mapper_object_+3A_dists">dists</code></td>
<td>
<p>A distance matrix for the data that has been binned and clustered.</p>
</td></tr>
<tr><td><code id="assemble_mapper_object_+3A_binning">binning</code></td>
<td>
<p>Whether the output dataframe should sort vertices into &quot;bins&quot; or not. Should be true if using clustering, leave false otherwise</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of two dataframes, one with node data containing bin membership,
datapoints per cluster, and cluster dispersion, and one with edge data
containing sources, targets, and weights representing overlap strength.
</p>

<hr>
<h2 id='check_in_interval'>Get a tester function for an interval.</h2><span id='topic+check_in_interval'></span>

<h3>Description</h3>

<p>Get a tester function for an interval.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>check_in_interval(endpoints)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="check_in_interval_+3A_endpoints">endpoints</code></td>
<td>
<p>A vector of interval endpoints, namely a left and a right. Must be in order.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A function that eats a data point and outputs TRUE if the datapoint is in the interval and FALSE if not.
</p>

<hr>
<h2 id='compute_tightness'>Compute dispersion of a single cluster</h2><span id='topic+compute_tightness'></span>

<h3>Description</h3>

<p>Compute dispersion of a single cluster
</p>


<h3>Usage</h3>

<pre><code class='language-R'>compute_tightness(dists, cluster)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="compute_tightness_+3A_dists">dists</code></td>
<td>
<p>A distance matrix for points in the cluster.</p>
</td></tr>
<tr><td><code id="compute_tightness_+3A_cluster">cluster</code></td>
<td>
<p>A list containing named vectors, whose names are data point names and whose values are cluster labels</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This method computes a measure of cluster dispersion. It finds the medoid of the input data set and returns the average distance to the medoid. Formally, we say the tightness <code class="reqn">\tau</code> of a cluster <code class="reqn">C</code> is given by </p>
<p style="text-align: center;"><code class="reqn">\tau(C) = \dfrac{1}{\left(|C|-1\right)}\displaystyle\sum_{i}\text{dist}(x_i, x_j)</code>
</p>
<p> where </p>
<p style="text-align: center;"><code class="reqn">x_j = \text{arg}\,\min\limits_{x_j\in C}\, \sum_{x_i \in C, i\neq j}\text{dist}(x_i, x_j)</code>
</p>
<p> A smaller value indicates a tighter cluster based on this metric.
</p>


<h3>Value</h3>

<p>A real number in <code class="reqn">[0,1]</code> representing a measure of dispersion of a cluster.
</p>

<hr>
<h2 id='convert_to_clusters'>&quot;Clustering&quot; for ballmapper just means treating each bin as its own cluster.</h2><span id='topic+convert_to_clusters'></span>

<h3>Description</h3>

<p>&quot;Clustering&quot; for ballmapper just means treating each bin as its own cluster.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>convert_to_clusters(bins)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="convert_to_clusters_+3A_bins">bins</code></td>
<td>
<p>A list of bins, each containing names of data from some data frame.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A named vector whose names are data point names and whose values are cluster labels
</p>

<hr>
<h2 id='create_1D_mapper_object'>Run 1D mapper</h2><span id='topic+create_1D_mapper_object'></span>

<h3>Description</h3>

<p>Run mapper using a one-dimensional filter, a cover of intervals, and a clustering algorithm.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>create_1D_mapper_object(
  data,
  dists,
  filtered_data,
  cover,
  clusterer = hierarchical_clusterer("single")
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="create_1D_mapper_object_+3A_data">data</code></td>
<td>
<p>A data frame.</p>
</td></tr>
<tr><td><code id="create_1D_mapper_object_+3A_dists">dists</code></td>
<td>
<p>A distance matrix for the data frame.</p>
</td></tr>
<tr><td><code id="create_1D_mapper_object_+3A_filtered_data">filtered_data</code></td>
<td>
<p>The result of a function applied to the data frame; there should be one filter value per observation in the original data frame.</p>
</td></tr>
<tr><td><code id="create_1D_mapper_object_+3A_cover">cover</code></td>
<td>
<p>A 2D array of interval left and right endpoints; rows should be intervals and columns left and right endpoints (in that order).</p>
</td></tr>
<tr><td><code id="create_1D_mapper_object_+3A_clusterer">clusterer</code></td>
<td>
<p>A function which accepts a list of distance matrices as input, and returns the results of clustering done on each distance matrix.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of two data frames, one with node data containing bin membership,
data points per cluster, and cluster dispersion, and one with edge data
containing sources, targets, and weights representing overlap strength.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data = data.frame(x = sapply(1:100, function(x) cos(x)), y = sapply(1:100, function(x) sin(x)))
projx = data$x

num_bins = 10
percent_overlap = 25

cover = create_width_balanced_cover(min(projx), max(projx), num_bins, percent_overlap)

create_1D_mapper_object(data, dist(data), projx, cover)
</code></pre>

<hr>
<h2 id='create_ball_mapper_object'>Run mapper using a trivial filter, a cover of balls, and no clustering algorithm.</h2><span id='topic+create_ball_mapper_object'></span>

<h3>Description</h3>

<p>Run mapper using an <code class="reqn">\varepsilon</code>-net cover (greedily generated) and the 2D inclusion function as a filter.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>create_ball_mapper_object(data, dists, eps)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="create_ball_mapper_object_+3A_data">data</code></td>
<td>
<p>A data frame.</p>
</td></tr>
<tr><td><code id="create_ball_mapper_object_+3A_dists">dists</code></td>
<td>
<p>A distance matrix for the data frame.</p>
</td></tr>
<tr><td><code id="create_ball_mapper_object_+3A_eps">eps</code></td>
<td>
<p>A positive real number for your desired ball radius.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of two data frames, one with node data containing ball size,
data points per ball, ball tightness, and one with edge data
containing sources, targets, and weights representing overlap strength.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data = data.frame(x = sapply(1:100, function(x) cos(x)), y = sapply(1:100, function(x) sin(x)))
eps = .5

create_ball_mapper_object(data, dist(data), eps)
</code></pre>

<hr>
<h2 id='create_balls'>Make a cover of balls</h2><span id='topic+create_balls'></span>

<h3>Description</h3>

<p>Make a cover of balls
</p>


<h3>Usage</h3>

<pre><code class='language-R'>create_balls(data, dists, eps)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="create_balls_+3A_data">data</code></td>
<td>
<p>A data frame.</p>
</td></tr>
<tr><td><code id="create_balls_+3A_dists">dists</code></td>
<td>
<p>A distance matrix for the data frame.</p>
</td></tr>
<tr><td><code id="create_balls_+3A_eps">eps</code></td>
<td>
<p>A positive real number.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of vectors of data point names, one list element per ball. The output is such that every data point is contained in a ball of radius <code class="reqn">\varepsilon</code>, and no ball center is contained in more than one ball. The centers are datapoints themselves.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>num_points = 5000

P.data = data.frame(
  x = sapply(1:num_points, function(x)
    sin(x) * 10) + rnorm(num_points, 0, 0.1),
  y = sapply(1:num_points, function(x)
    cos(x) ^ 2 * sin(x) * 10) + rnorm(num_points, 0, 0.1),
  z = sapply(1:num_points, function(x)
    10 * sin(x) ^ 2 * cos(x)) + rnorm(num_points, 0, 0.1)
)

P.dist = dist(P.data)
balls = create_balls(data = P.data, dists = P.dist, eps = .25)
</code></pre>

<hr>
<h2 id='create_bins'>Create bins of data</h2><span id='topic+create_bins'></span>

<h3>Description</h3>

<p>Create bins of data
</p>


<h3>Usage</h3>

<pre><code class='language-R'>create_bins(data, filtered_data, cover_element_tests)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="create_bins_+3A_data">data</code></td>
<td>
<p>A data frame.</p>
</td></tr>
<tr><td><code id="create_bins_+3A_filtered_data">filtered_data</code></td>
<td>
<p>The result of a function applied to the data frame; there should be one filter value per observation in the original data frame.</p>
</td></tr>
<tr><td><code id="create_bins_+3A_cover_element_tests">cover_element_tests</code></td>
<td>
<p>A list of membership test functions for a set of cover elements. In other words, each element of <code>cover_element_tests</code> is a function that returns <code>TRUE</code> or <code>FALSE</code> when given a filter value.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of level sets, each containing a vector of the names of the data inside it.
</p>

<hr>
<h2 id='create_clusterball_mapper_object'>Run clusterball mapper</h2><span id='topic+create_clusterball_mapper_object'></span>

<h3>Description</h3>

<p>Run ball mapper, but additionally cluster within the balls. Can use two different distance matrices to accomplish this.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>create_clusterball_mapper_object(
  data,
  dist1,
  dist2,
  eps,
  clusterer = hierarchical_clusterer("single")
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="create_clusterball_mapper_object_+3A_data">data</code></td>
<td>
<p>A data frame.</p>
</td></tr>
<tr><td><code id="create_clusterball_mapper_object_+3A_dist1">dist1</code></td>
<td>
<p>A distance matrix for the data frame; this will be used to ball the data.</p>
</td></tr>
<tr><td><code id="create_clusterball_mapper_object_+3A_dist2">dist2</code></td>
<td>
<p>Another distance matrix for the data frame; this will be used to cluster the data after balling.</p>
</td></tr>
<tr><td><code id="create_clusterball_mapper_object_+3A_eps">eps</code></td>
<td>
<p>A positive real number for your desired ball radius.</p>
</td></tr>
<tr><td><code id="create_clusterball_mapper_object_+3A_clusterer">clusterer</code></td>
<td>
<p>A function which accepts a list of distance matrices as input, and returns the results of clustering done on each distance matrix.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of two dataframes, one with node data containing bin membership,
datapoints per cluster, and cluster dispersion, and one with edge data
containing sources, targets, and weights representing overlap strength.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data = data.frame(x = sapply(1:100, function(x) cos(x)), y = sapply(1:100, function(x) sin(x)))
data.dists = dist(data)
eps = 1

create_clusterball_mapper_object(data, data.dists, data.dists, eps)
</code></pre>

<hr>
<h2 id='create_mapper_object'>Create a mapper object</h2><span id='topic+create_mapper_object'></span>

<h3>Description</h3>

<p>Run the mapper algorithm on a data frame.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>create_mapper_object(
  data,
  dists,
  filtered_data,
  cover_element_tests,
  clusterer = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="create_mapper_object_+3A_data">data</code></td>
<td>
<p>A data frame.</p>
</td></tr>
<tr><td><code id="create_mapper_object_+3A_dists">dists</code></td>
<td>
<p>A distance matrix for the data frame.</p>
</td></tr>
<tr><td><code id="create_mapper_object_+3A_filtered_data">filtered_data</code></td>
<td>
<p>The result of a function applied to the data frame; there should be one filter value per observation in the original data frame.</p>
</td></tr>
<tr><td><code id="create_mapper_object_+3A_cover_element_tests">cover_element_tests</code></td>
<td>
<p>A list of membership test functions for a set of cover elements. In other words, each element of <code>cover_element_tests</code> is a function that returns <code>TRUE</code> or <code>FALSE</code> when given a filter value.</p>
</td></tr>
<tr><td><code id="create_mapper_object_+3A_clusterer">clusterer</code></td>
<td>
<p>A function which accepts a list of distance matrices as input, and returns the results of clustering done on each distance matrix. Defaults to <code>NULL</code>, meaning no all data in each bin will be lumped into a single cluster.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of two dataframes, one with node data and one with edge data.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data = data.frame(x = sapply(1:100, function(x) cos(x)), y = sapply(1:100, function(x) sin(x)))
projx = data$x

num_bins = 10
percent_overlap = 25
xcover = create_width_balanced_cover(min(projx), max(projx), num_bins, percent_overlap)

check_in_interval &lt;- function(endpoints) {
 return(function(x) (endpoints[1] - x &lt;= 0) &amp; (endpoints[2] - x &gt;= 0))
}

# each of the "cover" elements will really be a function that checks if a data point lives in it
xcovercheck = apply(xcover, 1, check_in_interval)

# build the mapper object
xmapper = create_mapper_object(
  data = data,
  dists = dist(data),
  filtered_data = projx,
  cover_element_tests = xcovercheck
)
</code></pre>

<hr>
<h2 id='create_single_bin'>Create a bin of data</h2><span id='topic+create_single_bin'></span>

<h3>Description</h3>

<p>Create a bin of data
</p>


<h3>Usage</h3>

<pre><code class='language-R'>create_single_bin(data, filtered_data, cover_element_test)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="create_single_bin_+3A_data">data</code></td>
<td>
<p>A data frame.</p>
</td></tr>
<tr><td><code id="create_single_bin_+3A_filtered_data">filtered_data</code></td>
<td>
<p>The result of a function applied to the data frame; there should be one filter value per observation in the original data frame.</p>
</td></tr>
<tr><td><code id="create_single_bin_+3A_cover_element_test">cover_element_test</code></td>
<td>
<p>A membership test function for a cover element. It should return <code>TRUE</code> or <code>FALSE</code> when given a filtered data point.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector of names of points from the data frame, representing a level set.
</p>

<hr>
<h2 id='create_width_balanced_cover'>Generate an overlapping cover of an interval</h2><span id='topic+create_width_balanced_cover'></span>

<h3>Description</h3>

<p>This is a function that generates a cover of an interval <code class="reqn">[a,b]</code> with
some number of (possibly) overlapping, evenly spaced, identical width subintervals.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>create_width_balanced_cover(min_val, max_val, num_bins, percent_overlap)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="create_width_balanced_cover_+3A_min_val">min_val</code></td>
<td>
<p>The left endpoint <code class="reqn">a</code>. A real number.</p>
</td></tr>
<tr><td><code id="create_width_balanced_cover_+3A_max_val">max_val</code></td>
<td>
<p>The right endpoint <code class="reqn">b</code>. A real number.</p>
</td></tr>
<tr><td><code id="create_width_balanced_cover_+3A_num_bins">num_bins</code></td>
<td>
<p>The number of cover intervals with which to cover the interval. A positive integer.</p>
</td></tr>
<tr><td><code id="create_width_balanced_cover_+3A_percent_overlap">percent_overlap</code></td>
<td>
<p>How much overlap desired between the cover intervals
(the percent of the intersection of each interval with its immediate
neighbor relative to its length, e.g., <code class="reqn">[0,2]</code> and <code class="reqn">[1,3]</code> would have <code class="reqn">50\%</code> overlap).
A real number between 0 and 100, inclusive.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A 2D numeric array.
</p>

<ul>
<li><p> left_ends - The left endpoints of the cover intervals.
</p>
</li>
<li><p> right_ends - The right endpoints of the cover intervals.
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>create_width_balanced_cover(min_val=0, max_val=100, num_bins=10, percent_overlap=15)
create_width_balanced_cover(-11.5, 10.33, 100, 2)
</code></pre>

<hr>
<h2 id='cut_dendrogram'>Cut a dendrogram in context</h2><span id='topic+cut_dendrogram'></span>

<h3>Description</h3>

<p>Cut a dendrogram in context
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cut_dendrogram(dend, threshold)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="cut_dendrogram_+3A_dend">dend</code></td>
<td>
<p>A single dendrogram.</p>
</td></tr>
<tr><td><code id="cut_dendrogram_+3A_threshold">threshold</code></td>
<td>
<p>A mininum tallest branch value.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The number of clusters is determined to be 1 if the tallest branch of the dendrogram is less than the threshold, or if the index of dispersion (standard deviation squared divided by mean) of the branch heights is below 0.015. Otherwise, we cut at the longest branch of the dendrogram to determine the number of clusters.
</p>


<h3>Value</h3>

<p>A named vector whose names are data point names and whose values are cluster labels.
</p>

<hr>
<h2 id='eccentricity_filter'>Compute eccentricity of data points</h2><span id='topic+eccentricity_filter'></span>

<h3>Description</h3>

<p>Compute eccentricity of data points
</p>


<h3>Usage</h3>

<pre><code class='language-R'>eccentricity_filter(dists)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="eccentricity_filter_+3A_dists">dists</code></td>
<td>
<p>A distance matrix associated to a data frame.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector of centrality measures, calculated per data point as the sum of its distances to every other data point, divided by the number of points.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>num_points = 100

P.data = data.frame(
  x = sapply(1:num_points, function(x)
    sin(x) * 10) + rnorm(num_points, 0, 0.1),
  y = sapply(1:num_points, function(x)
    cos(x) ^ 2 * sin(x) * 10) + rnorm(num_points, 0, 0.1)
)

P.dist = dist(P.data)
eccentricity = eccentricity_filter(P.dist)
</code></pre>

<hr>
<h2 id='get_bin_vector'>Recover bins</h2><span id='topic+get_bin_vector'></span>

<h3>Description</h3>

<p>Recover bins
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_bin_vector(binclust_data)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="get_bin_vector_+3A_binclust_data">binclust_data</code></td>
<td>
<p>A list of bins, each containing named vectors whose names are those of data points and whose values are cluster ids.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector of integers equal in length to the number of clusters, whose members identify which bin that cluster belongs to.
</p>

<hr>
<h2 id='get_cluster_sizes'>Compute cluster sizes</h2><span id='topic+get_cluster_sizes'></span>

<h3>Description</h3>

<p>Compute cluster sizes
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_cluster_sizes(binclust_data)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="get_cluster_sizes_+3A_binclust_data">binclust_data</code></td>
<td>
<p>A list of bins, each containing named vectors whose names are those of data points and whose values are cluster ids.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector of integers representing the lengths of the clusters in the input data.
</p>

<hr>
<h2 id='get_cluster_tightness_vector'>Compute dispersion measures of a list of clusters</h2><span id='topic+get_cluster_tightness_vector'></span>

<h3>Description</h3>

<p>Compute dispersion measures of a list of clusters
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_cluster_tightness_vector(dists, binclust_data)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="get_cluster_tightness_vector_+3A_dists">dists</code></td>
<td>
<p>A distance matrix for the data points inside all the input clusters</p>
</td></tr>
<tr><td><code id="get_cluster_tightness_vector_+3A_binclust_data">binclust_data</code></td>
<td>
<p>A list of named vectors whose names are those of data points and whose values are cluster ids</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector of real numbers in <code class="reqn">(0,\infty)</code> representing a measure of dispersion of a cluster, calculated according to <a href="#topic+compute_tightness">compute_tightness</a>.
</p>

<hr>
<h2 id='get_clustered_data'>Get data within a cluster</h2><span id='topic+get_clustered_data'></span>

<h3>Description</h3>

<p>Get data within a cluster
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_clustered_data(binclust_data)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="get_clustered_data_+3A_binclust_data">binclust_data</code></td>
<td>
<p>A list of bins, each containing named vectors whose names are those of data points and whose values are cluster ids</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of strings, each a comma separated list of the toString values of the data point names.
</p>

<hr>
<h2 id='get_clusters'>Perform the clustering step in mapper</h2><span id='topic+get_clusters'></span>

<h3>Description</h3>

<p>This function processes the binned data and global distance matrix to return freshly clustered data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_clusters(bins, dists, clusterer)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="get_clusters_+3A_bins">bins</code></td>
<td>
<p>A list containing &quot;bins&quot; of vectors of names of data points.</p>
</td></tr>
<tr><td><code id="get_clusters_+3A_dists">dists</code></td>
<td>
<p>A distance matrix containing pairwise distances between named data points.</p>
</td></tr>
<tr><td><code id="get_clusters_+3A_clusterer">clusterer</code></td>
<td>
<p>A function which accepts a list of distance matrices as input, and returns the results of clustering done on each distance matrix.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The output of <code>clusterer</code> applied to a list of distance matrices, which should be a list containing named vectors (one per bin), whose names are data point names and whose values are cluster labels.
</p>

<hr>
<h2 id='get_edge_weights'>Calculate edge weights</h2><span id='topic+get_edge_weights'></span>

<h3>Description</h3>

<p>Calculate edge weights
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_edge_weights(overlap_lengths, cluster_sizes, edges)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="get_edge_weights_+3A_overlap_lengths">overlap_lengths</code></td>
<td>
<p>A named vector of cluster overlap lengths, obtained by calling <code><a href="base.html#topic+length">length()</a></code> on the output from <code>[get_overlaps()]</code>.</p>
</td></tr>
<tr><td><code id="get_edge_weights_+3A_cluster_sizes">cluster_sizes</code></td>
<td>
<p>A vector of cluster sizes.</p>
</td></tr>
<tr><td><code id="get_edge_weights_+3A_edges">edges</code></td>
<td>
<p>A 2D array of source and target nodes, representing an edge list. Should be ordered consistently with the <code>overlap_lengths</code> parameter.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This value is calculated per edge by dividing the number of data points in the overlap by the number of points in the cluster on either end, and taking the maximum value. Formally, </p>
<p style="text-align: center;"><code class="reqn">w(\{c_i, c_j\}) = \displaystyle\max\left\{\dfrac{|c_i \cap c_j|}{|c_i|}, \dfrac{|c_i\cap c_j|}{|c_j|}\right\}</code>
</p>



<h3>Value</h3>

<p>A vector of real numbers representing cluster overlap strength.
</p>

<hr>
<h2 id='get_edgelist_from_overlaps'>Obtain edge list from cluster intersections</h2><span id='topic+get_edgelist_from_overlaps'></span>

<h3>Description</h3>

<p>Obtain edge list from cluster intersections
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_edgelist_from_overlaps(overlaps, num_vertices)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="get_edgelist_from_overlaps_+3A_overlaps">overlaps</code></td>
<td>
<p>A named list of edges, whose elements contain the names of clusters in the overlap represented by that edge; output of <code><a href="#topic+get_overlaps">get_overlaps()</a></code>.</p>
</td></tr>
<tr><td><code id="get_edgelist_from_overlaps_+3A_num_vertices">num_vertices</code></td>
<td>
<p>The number of vertices in the graph.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A 2D array representing the edge list of a graph.
</p>

<hr>
<h2 id='get_hierarchical_clusters'>Perform single-linkage hierarchical clustering and process dendrograms in a semi-global context.</h2><span id='topic+get_hierarchical_clusters'></span>

<h3>Description</h3>

<p>Perform single-linkage hierarchical clustering and process dendrograms in a semi-global context.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_hierarchical_clusters(dist_mats, method)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="get_hierarchical_clusters_+3A_dist_mats">dist_mats</code></td>
<td>
<p>A list of distance matrices to be used for clustering.</p>
</td></tr>
<tr><td><code id="get_hierarchical_clusters_+3A_method">method</code></td>
<td>
<p>A string to pass to <a href="stats.html#topic+hclust">hclust</a> to tell it what kind of clustering to do.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list containing named vectors (one per dendrogram), whose names are data point names and whose values are cluster labels.
</p>

<hr>
<h2 id='get_overlaps'>Get cluster overlaps</h2><span id='topic+get_overlaps'></span>

<h3>Description</h3>

<p>Get cluster overlaps
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_overlaps(binclust_data)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="get_overlaps_+3A_binclust_data">binclust_data</code></td>
<td>
<p>A list of bins, each containing named vectors whose names are those of data points and whose values are cluster ids.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A named list of edges, whose elements contain the names of clusters in the overlap represented by that edge.
</p>

<hr>
<h2 id='get_raw_clusters'>Ship data off to the clustering goblins</h2><span id='topic+get_raw_clusters'></span>

<h3>Description</h3>

<p>This function tells the computer to look away for a second, so the goblins come and cluster your data while it's not watching.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_raw_clusters(dist_mats, clusterer)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="get_raw_clusters_+3A_dist_mats">dist_mats</code></td>
<td>
<p>A list of distance matrices of each bin that is to be clustered.</p>
</td></tr>
<tr><td><code id="get_raw_clusters_+3A_clusterer">clusterer</code></td>
<td>
<p>A function which accepts a list of distance matrices as input, and returns the results of clustering done on each distance matrix in a list.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The output of <code>clusterer(dist_mats)</code>, which needs to be a list containing named vectors (one per bin), whose names are data point names and whose values are cluster labels (within each bin)
</p>

<hr>
<h2 id='get_tallest_branch'>Find the tallest branch of a dendrogram</h2><span id='topic+get_tallest_branch'></span>

<h3>Description</h3>

<p>Find the tallest branch of a dendrogram
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_tallest_branch(dend)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="get_tallest_branch_+3A_dend">dend</code></td>
<td>
<p>A single dendrogram.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The height of the tallest branch (longest time between merge heights) of the input dendrogram.
</p>

<hr>
<h2 id='hierarchical_clusterer'>Create a little dude to perform hierarchical clustering in a semi-global context using the <a href="stats.html#topic+hclust">hclust</a> package.</h2><span id='topic+hierarchical_clusterer'></span>

<h3>Description</h3>

<p>Create a little dude to perform hierarchical clustering in a semi-global context using the <a href="stats.html#topic+hclust">hclust</a> package.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>hierarchical_clusterer(method)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="hierarchical_clusterer_+3A_method">method</code></td>
<td>
<p>A string to pass to <a href="stats.html#topic+hclust">hclust</a> to tell it what kind of clustering to do.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This clusterer determines cutting heights for bin dendrograms generated by <a href="stats.html#topic+hclust">hclust</a> by first considering the tallest branches across all dendrograms; if all branch heights of a given dendrogram are below a threshold (10 percent of the global tallest), that dendrogram will be considered to describe a single cluster. Additionally, if the index of dispersion of the branch heights of a dendrogram are below 0.015, we will also consider it as describing a single cluster. If neither of these are true, then we will cut the dendrogram at its longest branch.
</p>


<h3>Value</h3>

<p>A function that inputs a list of distance matrices and returns a list containing one vector per bin, whose element names are data point names and whose values are cluster labels (within each bin).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data = data.frame(x = sapply(1:100, function(x) cos(x)), y = sapply(1:100, function(x) sin(x)))
projx = data$x

num_bins = 10
percent_overlap = 25

cover = create_width_balanced_cover(min(projx), max(projx), num_bins, percent_overlap)

create_1D_mapper_object(data, dist(data), projx, cover, hierarchical_clusterer("mcquitty"))
</code></pre>

<hr>
<h2 id='is_in_ball'>Get a tester function for a ball.</h2><span id='topic+is_in_ball'></span>

<h3>Description</h3>

<p>Get a tester function for a ball.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is_in_ball(ball)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="is_in_ball_+3A_ball">ball</code></td>
<td>
<p>A list of data points.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A function that eats a data point and returns TRUE or FALSE depending if the point is in the ball or not.
</p>

<hr>
<h2 id='mapper_object_to_igraph'>make igraph</h2><span id='topic+mapper_object_to_igraph'></span>

<h3>Description</h3>

<p>make igraph
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mapper_object_to_igraph(mapperobject)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="mapper_object_to_igraph_+3A_mapperobject">mapperobject</code></td>
<td>
<p>mapper object generated by mappeR</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an igraph object
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data = data.frame(x = sapply(1:100, function(x) cos(x)), y = sapply(1:100, function(x) sin(x)))

projy = data$y

cover = create_width_balanced_cover(min(projy), max(projy), 10, 25)

mapperobj = create_1D_mapper_object(data, dist(data), data$y, cover)

mapper_object_to_igraph(mapperobj)
</code></pre>

<hr>
<h2 id='next_triangular'>Find which triangular number you're on</h2><span id='topic+next_triangular'></span>

<h3>Description</h3>

<p>Find which triangular number you're on
</p>


<h3>Usage</h3>

<pre><code class='language-R'>next_triangular(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="next_triangular_+3A_x">x</code></td>
<td>
<p>A positive integer.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The index of the next greatest or equal triangular number to <code class="reqn">x</code>.
</p>

<hr>
<h2 id='process_dendrograms'>Cut many dendrograms in context</h2><span id='topic+process_dendrograms'></span>

<h3>Description</h3>

<p>Cut many dendrograms in context
</p>


<h3>Usage</h3>

<pre><code class='language-R'>process_dendrograms(dends, semi_local_clustering = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="process_dendrograms_+3A_dends">dends</code></td>
<td>
<p>A list of dendrograms to be cut.</p>
</td></tr>
<tr><td><code id="process_dendrograms_+3A_semi_local_clustering">semi_local_clustering</code></td>
<td>
<p>Whether you want clustering to happen in a semi-local (entire dataset visible) or strictly local (only current level set visible) context. Defaults to semi-local.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function uses a value of 10 percent of the tallest branch across dendrograms as a threshold for <a href="#topic+cut_dendrogram">cut_dendrogram</a>.
</p>


<h3>Value</h3>

<p>A list of named vectors (one per dendrogram) whose names are data point names and whose values are cluster labels.
</p>

<hr>
<h2 id='run_link'>Perform agglomerative clustering on a single distance matrix.</h2><span id='topic+run_link'></span>

<h3>Description</h3>

<p>Perform agglomerative clustering on a single distance matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>run_link(dist, method)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="run_link_+3A_dist">dist</code></td>
<td>
<p>A distance matrix.</p>
</td></tr>
<tr><td><code id="run_link_+3A_method">method</code></td>
<td>
<p>A string to pass to <a href="stats.html#topic+hclust">hclust</a> to determine clustering method.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A dendrogram generated by <code>fastcluster</code>.
</p>

<hr>
<h2 id='subset_dists'>Subset a distance matrix</h2><span id='topic+subset_dists'></span>

<h3>Description</h3>

<p>Subset a distance matrix
</p>


<h3>Usage</h3>

<pre><code class='language-R'>subset_dists(bin, dists)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="subset_dists_+3A_bin">bin</code></td>
<td>
<p>A list of names of data points.</p>
</td></tr>
<tr><td><code id="subset_dists_+3A_dists">dists</code></td>
<td>
<p>A distance matrix for data points in the bin, possibly including extra points.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A distance matrix for only the data points in the input bin.
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
