<!DOCTYPE html><html><head><title>Help for package missoNet</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {missoNet}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#missoNet-package'><p>Multi-task regression and conditional network estimation with missing values in the tasks</p></a></li>
<li><a href='#cv.missoNet'><p>Cross-validation for missoNet</p></a></li>
<li><a href='#generateData'><p>Quickly generate synthetic data for simulation studies</p></a></li>
<li><a href='#missoNet'><p>Fit a series of missoNet models with user-supplied regularization parameters for the lasso penalties</p></a></li>
<li><a href='#plot.cv.missoNet'><p>Plot the cross-validation errors produced by cv.missoNet</p></a></li>
<li><a href='#predict.cv.missoNet'><p>Make predictions from a cv.missoNet object</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Missingness in Multi-Task Regression with Network Estimation</td>
</tr>
<tr>
<td>Version:</td>
<td>1.2.0</td>
</tr>
<tr>
<td>Date:</td>
<td>2023-07-18</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Yixiao Zeng &lt;yixiao.zeng@mail.mcgill.ca&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Efficient procedures for fitting conditional graphical lasso
    models that link a set of predictor variables to a set of response
    variables (or tasks), even when the response data may contain missing
    values. 'missoNet' simultaneously estimates the predictor
    coefficients for all tasks by leveraging information from one another,
    in order to provide more accurate predictions in comparison to
    modeling them individually. Additionally, 'missoNet' estimates the
    response network structure influenced by conditioning predictor
    variables using a L1-regularized conditional Gaussian graphical model.
    Unlike most penalized multi-task regression methods (e.g., MRCE),
    'missoNet' is capable of obtaining estimates even when the response
    data is corrupted by missing values. The method automatically enjoys
    the theoretical and computational benefits of convexity, and returns
    solutions that are comparable to the estimates obtained without
    missingness.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a></td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/yixiao-zeng/missoNet">https://github.com/yixiao-zeng/missoNet</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/yixiao-zeng/missoNet/issues">https://github.com/yixiao-zeng/missoNet/issues</a></td>
</tr>
<tr>
<td>Imports:</td>
<td>circlize (&ge; 0.4.14), ComplexHeatmap, glasso (&ge; 1.11),
mvtnorm (&ge; 1.1.3), pbapply (&ge; 1.5.0), Rcpp (&ge; 1.0.8.3),
scatterplot3d (&ge; 0.3.41)</td>
</tr>
<tr>
<td>Suggests:</td>
<td>knitr, rmarkdown</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>Rcpp, RcppArmadillo</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-07-18 19:06:47 UTC; yixiao</td>
</tr>
<tr>
<td>Author:</td>
<td>Yixiao Zeng [aut, cre, cph],
  Celia Greenwood [ths, aut],
  Archer Yang [ths, aut]</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-07-19 13:40:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='missoNet-package'>Multi-task regression and conditional network estimation with missing values in the tasks</h2><span id='topic+missoNet-package'></span>

<h3>Description</h3>


<table>
<tr>
 <td style="text-align: left;"> Package: </td><td style="text-align: left;"> missoNet</td>
</tr>
<tr>
 <td style="text-align: left;"> Type: </td><td style="text-align: left;"> Package</td>
</tr>
<tr>
 <td style="text-align: left;"> Version: </td><td style="text-align: left;">
1.0.0</td>
</tr>
<tr>
 <td style="text-align: left;"> Date: </td><td style="text-align: left;"> 2022-10-01</td>
</tr>
<tr>
 <td style="text-align: left;"> License: </td><td style="text-align: left;"> GPL-2</td>
</tr>
<tr>
 <td style="text-align: left;"> </td>
</tr>

</table>



<h3>missoNet functions</h3>


<dl>
<dt>missoNet</dt><dd><p>Fit a series of &lsquo;<code><a href="#topic+missoNet">missoNet</a></code>&rsquo; models with user-supplied regularization parameter pairs for the lasso penalties, {(<code class="reqn">\lambda_B</code>, <code class="reqn">\lambda_\Theta</code>)}.</p>
</dd>
<dt>cv.missoNet</dt><dd><p>Perform k-fold cross-validation for &lsquo;<code><a href="#topic+missoNet">missoNet</a></code>&rsquo; over a grid of (auto-computed) regularization parameter pairs.</p>
</dd>
<dt>plot</dt><dd><p>S3 method for plotting the cross-validation errors from a fitted <code>'cv.missoNet'</code> object.</p>
</dd>
<dt>predict</dt><dd><p>S3 method for making predictions of response values from a fitted <code>'cv.missoNet'</code> object.</p>
</dd>
<dt>generateData</dt><dd><p>Quickly generate synthetic data for simulation studies.</p>
</dd>
</dl>


<hr>
<h2 id='cv.missoNet'>Cross-validation for missoNet</h2><span id='topic+cv.missoNet'></span>

<h3>Description</h3>

<p>This function performs k-fold cross-validation for &lsquo;<code><a href="#topic+missoNet">missoNet</a></code>&rsquo;. The regularization path is computed 
for all possible combinations of values given in the two regularization parameter sequences, namely <code class="reqn">\lambda_B</code> and <code class="reqn">\lambda_\Theta</code>. 
&lsquo;<code>cv.missoNet</code>&rsquo; will select the most suitable model among all cross-validated fits along the path.
See the details of &lsquo;<code><a href="#topic+missoNet">missoNet</a></code>&rsquo; for the model definition. 
To help users, the &lsquo;<code>cv.missoNet</code>&rsquo; function is designed to automatically determine the likely ranges 
of the regularization parameters over which the cross-validation searches.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cv.missoNet(
  X,
  Y,
  kfold = 5,
  rho = NULL,
  lambda.Beta = NULL,
  lambda.Theta = NULL,
  lamBeta.min.ratio = NULL,
  lamTheta.min.ratio = NULL,
  n.lamBeta = NULL,
  n.lamTheta = NULL,
  lamBeta.scale.factor = 1,
  lamTheta.scale.factor = 1,
  Beta.maxit = 1000,
  Beta.thr = 1e-04,
  eta = 0.8,
  Theta.maxit = 1000,
  Theta.thr = 1e-04,
  eps = 1e-08,
  penalize.diagonal = TRUE,
  diag.penalty.factor = NULL,
  standardize = TRUE,
  standardize.response = TRUE,
  fit.1se = FALSE,
  fit.relax = FALSE,
  permute = TRUE,
  with.seed = NULL,
  parallel = FALSE,
  cl = NULL,
  verbose = 1
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cv.missoNet_+3A_x">X</code></td>
<td>
<p>Numeric predictor matrix (<code class="reqn">n\times p</code>): columns correspond to predictor variables and rows correspond to samples. Missing values are not allowed. There is no need for centering or scaling of the variables. <code>'X'</code> should not include a column of ones for an intercept.</p>
</td></tr>
<tr><td><code id="cv.missoNet_+3A_y">Y</code></td>
<td>
<p>Numeric response matrix (<code class="reqn">n\times q</code>): columns correspond to response variables and rows correspond to samples. Missing values should be coded as either <code>'NA'</code>s or <code>'NaN'</code>s. There is no need for centering or scaling of the variables.</p>
</td></tr>
<tr><td><code id="cv.missoNet_+3A_kfold">kfold</code></td>
<td>
<p>Number of folds for cross-validation &ndash; the default is <code>'5'</code>.</p>
</td></tr>
<tr><td><code id="cv.missoNet_+3A_rho">rho</code></td>
<td>
<p>(Optional) A scalar or a numeric vector of length <code class="reqn">q</code>: the elements are user-supplied probabilities of missingness for the response variables. The default is <code>'rho = NULL'</code> and the program will compute the empirical missing rates for each of the columns of <code>'Y'</code> and use them as the working missing probabilities. The default setting should suffice in most cases; misspecified missing probabilities would introduce biases into the model.</p>
</td></tr>
<tr><td><code id="cv.missoNet_+3A_lambda.beta">lambda.Beta</code></td>
<td>
<p>(Optional) Numeric vector: a user-supplied sequence of non-negative values for {<code class="reqn">\lambda_B</code>} penalizing the elements of the coefficient matrix <code class="reqn">\mathbf{B}</code> among which the cross-validation procedure searches. The default is <code>'lambda.Beta = NULL'</code>, in which case the program computes an appropriate range of <code class="reqn">\lambda_B</code> values using <code>'n.lamBeta'</code> and <code>'lamBeta.min.ratio'</code>. Supplying a vector overrides this default. Note that the supplied sequence will be automatically arranged, internally, in a descending order.</p>
</td></tr>
<tr><td><code id="cv.missoNet_+3A_lambda.theta">lambda.Theta</code></td>
<td>
<p>(Optional) Numeric vector: a user-supplied sequence of non-negative values for {<code class="reqn">\lambda_\Theta</code>} penalizing the (off-diagonal) elements of the precision matrix <code class="reqn">\mathbf{\Theta}</code> among which the cross-validation procedure searches. The default is <code>'lambda.Theta = NULL'</code>, in which case the program computes an appropriate range of <code class="reqn">\lambda_\Theta</code> values using <code>'n.lamTheta'</code> and <code>'lamTheta.min.ratio'</code>. Supplying a vector overrides this default. Note that the supplied sequence will be automatically arranged, internally, in a descending order.</p>
</td></tr>
<tr><td><code id="cv.missoNet_+3A_lambeta.min.ratio">lamBeta.min.ratio</code></td>
<td>
<p>The smallest value of <code class="reqn">\lambda_B</code> is calculated as the data-derived <code class="reqn">\mathrm{max}(\lambda_B)</code> multiplied by <code>'lamBeta.min.ratio'</code>. The default depends on the sample size, <code class="reqn">n</code>, relative to the number of predictors, <code class="reqn">p</code>. If <code class="reqn">n &gt; p</code>, the default is <code>'1.0E-4'</code>, otherwise it is <code>'1.0E-3'</code>. A very small value of <code>'lamBeta.min.ratio'</code> may significantly increase runtime and lead to a saturated fit in the <code class="reqn">n \leq p</code> case. This is only needed when <code>'lambda.Beta = NULL'</code>.</p>
</td></tr>
<tr><td><code id="cv.missoNet_+3A_lamtheta.min.ratio">lamTheta.min.ratio</code></td>
<td>
<p>The smallest value of <code class="reqn">\lambda_\Theta</code> is calculated as the data-derived <code class="reqn">\mathrm{max}(\lambda_\Theta)</code> multiplied by <code>'lamTheta.min.ratio'</code>. The default depends on the sample size, <code class="reqn">n</code>, relative to the number of responses, <code class="reqn">q</code>. If <code class="reqn">n &gt; q</code>, the default is <code>'1.0E-4'</code>, otherwise it is <code>'1.0E-3'</code>. A very small value of <code>'lamTheta.min.ratio'</code> may significantly increase runtime and lead to a saturated fit in the <code class="reqn">n \leq q</code> case. This is only needed when <code>'lambda.Theta = NULL'</code>.</p>
</td></tr>
<tr><td><code id="cv.missoNet_+3A_n.lambeta">n.lamBeta</code></td>
<td>
<p>The number of <code class="reqn">\lambda_B</code> values. If <code class="reqn">n &gt; p</code>, the default is <code>'40'</code>, otherwise it is <code>'30'</code>. Avoid supplying an excessively large number since the program will fit (<code>'n.lamBeta'</code> <code>*</code> <code>'n.lamTheta'</code>) models in total for each fold of the cross-validation. Typically we suggest <code>'n.lamBeta' = -log10('lamBeta.min.ratio') * c</code>, where <code>c</code> <code class="reqn">\in</code> [<code>10</code>, <code>20</code>]. This is only needed when <code>'lambda.Beta = NULL'</code>.</p>
</td></tr>
<tr><td><code id="cv.missoNet_+3A_n.lamtheta">n.lamTheta</code></td>
<td>
<p>The number of <code class="reqn">\lambda_\Theta</code> values. If <code class="reqn">n &gt; q</code>, the default is <code>'40'</code>, otherwise it is <code>'30'</code>. Avoid supplying an excessively large number since the program will fit (<code>'n.lamBeta'</code> <code>*</code> <code>'n.lamTheta'</code>) models in total for each fold of the cross-validation. Typically we suggest <code>'n.lamTheta' = -log10('lamTheta.min.ratio') * c</code>, where <code>c</code> <code class="reqn">\in</code> [<code>10</code>, <code>20</code>]. This is only needed when <code>'lambda.Theta = NULL'</code>.</p>
</td></tr>
<tr><td><code id="cv.missoNet_+3A_lambeta.scale.factor">lamBeta.scale.factor</code></td>
<td>
<p>A positive multiplication factor for scaling the entire <code class="reqn">\lambda_B</code> sequence; the default is <code>'1'</code>. A typical usage is when the magnitudes of the auto-computed <code class="reqn">\lambda_B</code> values are inappropriate. For example, this factor would be needed if the optimal value of <code class="reqn">\lambda_B</code> selected by the cross-validation (i.e. <code class="reqn">{\lambda_B}_\mathrm{min}</code> with the minimum cross-validated error) approaches either boundary of the search range. This is only needed when <code>'lambda.Beta = NULL'</code>.</p>
</td></tr>
<tr><td><code id="cv.missoNet_+3A_lamtheta.scale.factor">lamTheta.scale.factor</code></td>
<td>
<p>A positive multiplication factor for scaling the entire <code class="reqn">\lambda_\Theta</code> sequence; the default is <code>'1'</code>. A typical usage is when the magnitudes of the auto-computed <code class="reqn">\lambda_\Theta</code> values are inappropriate. For example, this factor would be needed if the optimal value of <code class="reqn">\lambda_\Theta</code> selected by the cross-validation (i.e. <code class="reqn">{\lambda_\Theta}_\mathrm{min}</code> with the minimum cross-validated error) approaches either boundary of the search range. This is only needed when <code>'lambda.Theta = NULL'</code>.</p>
</td></tr>
<tr><td><code id="cv.missoNet_+3A_beta.maxit">Beta.maxit</code></td>
<td>
<p>The maximum number of iterations of the fast iterative shrinkage-thresholding algorithm (FISTA) for updating <code class="reqn">\hat{\mathbf{B}}</code>. The default is <code>'Beta.maxit = 1000'</code>.</p>
</td></tr>
<tr><td><code id="cv.missoNet_+3A_beta.thr">Beta.thr</code></td>
<td>
<p>The convergence threshold of the FISTA algorithm for updating <code class="reqn">\hat{\mathbf{B}}</code>; the default is <code>'Beta.thr = 1.0E-4'</code>. Iterations stop when the absolute parameter change is less than (<code>'Beta.thr'</code> <code>*</code> <code>sum(abs(</code><code class="reqn">\hat{\mathbf{B}}</code><code>))</code>).</p>
</td></tr>
<tr><td><code id="cv.missoNet_+3A_eta">eta</code></td>
<td>
<p>The backtracking line search shrinkage factor; the default is <code>'eta = 0.8'</code>. Most users will be able to use the default value, some experienced users may want to tune <code>'eta'</code> according to the properties of a specific dataset for a faster convergence of the FISTA algorithm. Note that <code>'eta'</code> must be in (0, 1).</p>
</td></tr>
<tr><td><code id="cv.missoNet_+3A_theta.maxit">Theta.maxit</code></td>
<td>
<p>The maximum number of iterations of the &lsquo;<code><a href="glasso.html#topic+glasso">glasso</a></code>&rsquo; algorithm for updating <code class="reqn">\hat{\mathbf{\Theta}}</code>. The default is <code>'Theta.maxit = 1000'</code>.</p>
</td></tr>
<tr><td><code id="cv.missoNet_+3A_theta.thr">Theta.thr</code></td>
<td>
<p>The convergence threshold of the &lsquo;<code><a href="glasso.html#topic+glasso">glasso</a></code>&rsquo; algorithm for updating <code class="reqn">\hat{\mathbf{\Theta}}</code>; the default is <code>'Theta.thr = 1.0E-4'</code>. Iterations stop when the average absolute parameter change is less than (<code>'Theta.thr'</code> <code>*</code> <code>ave(abs(offdiag(</code><code class="reqn">\hat{\mathbf{\Sigma}}</code><code>)))</code>), where <code class="reqn">\hat{\mathbf{\Sigma}}</code> denotes the empirical working covariance matrix.</p>
</td></tr>
<tr><td><code id="cv.missoNet_+3A_eps">eps</code></td>
<td>
<p>A numeric tolerance level for the L1 projection of the empirical covariance matrix; the default is <code>'eps = 1.0E-8'</code>. The empirical covariance matrix will be projected onto a L1 ball to have <code>min(eigen(</code><code class="reqn">\hat{\mathbf{\Sigma}}</code><code>)$value)</code> == <code>'eps'</code>, if any of the eigenvalues is less than the specified tolerance. Most users will be able to use the default value.</p>
</td></tr>
<tr><td><code id="cv.missoNet_+3A_penalize.diagonal">penalize.diagonal</code></td>
<td>
<p>Logical: should the diagonal elements of <code class="reqn">\mathbf{\Theta}</code> be penalized? The default is <code>'TRUE'</code>.</p>
</td></tr>
<tr><td><code id="cv.missoNet_+3A_diag.penalty.factor">diag.penalty.factor</code></td>
<td>
<p>Numeric: a separate penalty multiplication factor for the diagonal elements of <code class="reqn">\mathbf{\Theta}</code> when <code>'penalize.diagonal = TRUE'</code>. <code class="reqn">\lambda_\Theta</code> is multiplied by this number to allow a differential shrinkage of the diagonal elements. The default is <code>'NULL'</code> and the program will guess a value based on an initial estimate of <code class="reqn">\mathbf{\Theta}</code>. This factor could be <code>'0'</code> for no shrinkage (equivalent to <code>'penalize.diagonal = FALSE'</code>) or <code>'1'</code> for an equal shrinkage.</p>
</td></tr>
<tr><td><code id="cv.missoNet_+3A_standardize">standardize</code></td>
<td>
<p>Logical: should the columns of <code>'X'</code> be standardized so each has unit variance? The default is <code>'TRUE'</code>. The estimated results will always be returned on the original scale. &lsquo;<code>cv.missoNet</code>&rsquo; computes appropriate <code class="reqn">\lambda</code> sequences relying on standardization, if <code>'X'</code> has been standardized prior to fitting the model, you might not wish to standardize it inside the algorithm.</p>
</td></tr>
<tr><td><code id="cv.missoNet_+3A_standardize.response">standardize.response</code></td>
<td>
<p>Logical: should the columns of <code>'Y'</code> be standardized so each has unit variance? The default is <code>'TRUE'</code>. The estimated results will always be returned on the original scale. &lsquo;<code>cv.missoNet</code>&rsquo; computes appropriate <code class="reqn">\lambda</code> sequences relying on standardization, if <code>'Y'</code> has been standardized prior to fitting the model, you might not wish to standardize it inside the algorithm.</p>
</td></tr>
<tr><td><code id="cv.missoNet_+3A_fit.1se">fit.1se</code></td>
<td>
<p>Logical: the default is <code>'FALSE'</code>. If <code>'TRUE'</code>, two additional models will be fitted with the largest values of <code class="reqn">\lambda_B</code> and <code class="reqn">\lambda_\Theta</code> respectively at which the cross-validated error is within one standard error of the minimum.</p>
</td></tr>
<tr><td><code id="cv.missoNet_+3A_fit.relax">fit.relax</code></td>
<td>
<p>Logical: the default is <code>'FALSE'</code>. If <code>'TRUE'</code>, the program will re-estimate the edges in the active set (i.e. nonzero off-diagonal elements) of the network structure <code class="reqn">\hat{\mathbf{\Theta}}</code> without penalization (<code class="reqn">\lambda_\Theta=0</code>). This debiased estimate of <code class="reqn">\mathbf{\Theta}</code> could be useful for some interdependency analyses. WARNING: there may be convergence issues if the empirical covariance matrix is not of full rank (e.g. <code class="reqn">n &lt; q)</code>).</p>
</td></tr>
<tr><td><code id="cv.missoNet_+3A_permute">permute</code></td>
<td>
<p>Logical: should the subject indices for the cross-validation be permuted? The default is <code>'TRUE'</code>.</p>
</td></tr>
<tr><td><code id="cv.missoNet_+3A_with.seed">with.seed</code></td>
<td>
<p>A random number seed for the permutation.</p>
</td></tr>
<tr><td><code id="cv.missoNet_+3A_parallel">parallel</code></td>
<td>
<p>Logical: the default is <code>'FALSE'</code>. If <code>'TRUE'</code>, the program uses clusters to compute the cross-validation folds in parallel. Must register parallel clusters beforehand, see examples below.</p>
</td></tr>
<tr><td><code id="cv.missoNet_+3A_cl">cl</code></td>
<td>
<p>A cluster object created by &lsquo;<code>parallel::makeCluster</code>&rsquo; for parallel evaluations. This is only needed when <code>'parallel = TRUE'</code>.</p>
</td></tr>
<tr><td><code id="cv.missoNet_+3A_verbose">verbose</code></td>
<td>
<p>Value of <code>'0'</code>, <code>'1'</code> or <code>'2'</code>. <code>'verbose = 0'</code> &ndash; silent; <code>'verbose = 1'</code> (the default) &ndash; limited tracing with progress bars; <code>'verbose = 2'</code> &ndash; detailed tracing. Note that displaying the progress bars slightly increases the computation overhead compared to the silent mode. The detailed tracing should be used for monitoring progress only when the program runs extremely slowly, and it is not supported under <code>'parallel = TRUE'</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The &lsquo;<code>cv.missoNet</code>&rsquo; function fits &lsquo;<code><a href="#topic+missoNet">missoNet</a></code>&rsquo; models (<code>'kfold'</code> <code>*</code> <code>'n.lamBeta'</code> <code>*</code> <code>'n.lamTheta'</code>) 
times in the whole cross-validation process. That is, for the <code class="reqn">k</code>th-fold (<code class="reqn">k=1,...,K</code>) computation, the models are fitted at each of 
the all (<code>'n.lamBeta'</code> <code>*</code> <code>'n.lamTheta'</code>) possible combinations of the regularization parameters (<code class="reqn">\lambda_B</code>, <code class="reqn">\lambda_\Theta</code>), with the <code class="reqn">k</code>th 
fold of the training data omitted. The errors are accumulated, and the averaged errors as well as the standard deviations are computed over all folds. 
Note that the results of &lsquo;<code>cv.missoNet</code>&rsquo; are random, since the samples are randomly split into k-folds. Users can eliminate this randomness 
by setting <code>'permute = FALSE'</code>, or by explicitly assigning a seed to the permutation of samples.
</p>
<p>A user-supplied sequence for {<code class="reqn">\lambda_B</code>} and/or {<code class="reqn">\lambda_\Theta</code>} is permitted, 
otherwise the program computes an appropriate range of values for the regularization parameters using other control arguments.
Note that &lsquo;<code>cv.missoNet</code>&rsquo; standardizes <code>'X'</code> and <code>'Y'</code> to have unit variances before computing its <code class="reqn">\lambda</code> 
sequences (and then unstandardizes the resulting coefficients); if you wish to reproduce/compare results with those of other softwares, 
it is best to supply pre-standardized <code>'X'</code> and <code>'Y'</code>. If the algorithm is running slowly, track its progress with <code>'verbose = 2'</code>. 
In most cases, choosing a sparser grid for the regularization parameters (e.g. smaller <code>'n.lamBeta'</code> and/or <code>'n.lamTheta'</code>) or setting <code>'Beta.thr = 1.0E-3'</code> (or even bigger) 
allows the algorithm to make faster progress.
</p>
<p>After cross-validation, the regression coefficient matrix <code class="reqn">\mathbf{B}</code> and the precision matrix <code class="reqn">\mathbf{\Theta}</code> can be 
estimated at three special <code class="reqn">\lambda</code> pairs, by reapplying &lsquo;<code>missoNet</code>&rsquo; to the entire training dataset:
</p>

<ol>
<li><p> &quot;<code>lambda.min</code>&quot; := (<code class="reqn">{\lambda_B}_\mathrm{min}, {\lambda_\Theta}_\mathrm{min}</code>), at which the minimum mean cross-validated error is achieved;
</p>
</li>
<li><p> &quot;<code>lambda.1se.Beta</code>&quot; := (<code class="reqn">{\lambda_B}_\mathrm{1se}, {\lambda_\Theta}_\mathrm{min}</code>), where <code class="reqn">{\lambda_B}_\mathrm{1se}</code> is the largest <code class="reqn">\lambda_B</code> at which the mean cross-validated error is within one standard error of the minimum;
</p>
</li>
<li><p> &quot;<code>lambda.1se.Theta</code>&quot; := (<code class="reqn">{\lambda_B}_\mathrm{min}, {\lambda_\Theta}_\mathrm{1se}</code>), where <code class="reqn">{\lambda_\Theta}_\mathrm{1se}</code> is the largest <code class="reqn">\lambda_\Theta</code> at which the mean cross-validated error is within one standard error of the minimum.
</p>
</li></ol>

<p>The corresponding estimates, along with the <code class="reqn">\lambda</code> values, are stored in three separate lists inside the returned object: 
<code>'est.min'</code>, <code>'est.1se.B'</code> and <code>'est.1se.Tht'</code> (<code>'est.1se.B'</code> and <code>'est.1se.Tht'</code> are <code>'NULL'</code> 
unless the argument <code>'fit.1se = TRUE'</code> when calling &lsquo;<code>cv.missoNet</code>&rsquo;).
</p>
<p>The &lsquo;<code>cv.missoNet</code>&rsquo; function returns an R object of S3 class <code>'cv.missoNet'</code> for which there are a set of accessory functions available.
The plotting function &lsquo;<code><a href="#topic+plot.cv.missoNet">plot.cv.missoNet</a></code>&rsquo; can be used to graphically identify the optimal pair of the regularization parameters, 
and the prediction function &lsquo;<code><a href="#topic+predict.cv.missoNet">predict.cv.missoNet</a></code>&rsquo; can be used to make predictions of response values given new input <code>'X'</code>. 
See the vignette for examples.
</p>


<h3>Value</h3>

<p>This function returns a <code>'cv.missoNet'</code> object containing a named <code>'list'</code> with all the ingredients of the cross-validated fit:
</p>
<table>
<tr><td><code>est.min</code></td>
<td>
<p>A <code>'list'</code> of results estimated at &quot;<code>lambda.min</code>&quot; := (<code class="reqn">{\lambda_B}_\mathrm{min}, {\lambda_\Theta}_\mathrm{min}</code>) that gives the minimum mean cross-validated error. It consists of the following components:
</p>

<ul>
<li> <p><code>Beta</code>: the penalized estimate of the regression coefficient matrix <code class="reqn">\hat{\mathbf{B}}</code> (<code class="reqn">p\times q</code>).
</p>
</li>
<li> <p><code>Theta</code>: the penalized estimate of the precision matrix <code class="reqn">\hat{\mathbf{\Theta}}</code> (<code class="reqn">q\times q</code>).
</p>
</li>
<li> <p><code>mu</code>: a vector of length <code class="reqn">q</code> storing the model intercept <code class="reqn">\hat{\mu}</code>.
</p>
</li>
<li> <p><code>lambda.Beta</code>: the value of <code class="reqn">\lambda_B</code> (i.e. <code class="reqn">{\lambda_B}_\mathrm{min}</code>) used to fit the model.
</p>
</li>
<li> <p><code>lambda.Theta</code>: the value of <code class="reqn">\lambda_\Theta</code> (i.e. <code class="reqn">{\lambda_\Theta}_\mathrm{min}</code>) used to fit the model.
</p>
</li>
<li> <p><code>relax.net</code>: the relaxed (debiased) estimate of the conditional network structure <code class="reqn">\hat{\mathbf{\Theta}}_\mathrm{rlx}</code> (<code class="reqn">q\times q</code>) if <code>'fit.relax = TRUE'</code> when calling &lsquo;<code>cv.missoNet</code>&rsquo;.
</p>
</li></ul>

</td></tr>
<tr><td><code>est.1se.B</code></td>
<td>
<p>A <code>'list'</code> of results estimated at &quot;<code>lambda.1se.Beta</code>&quot; := (<code class="reqn">{\lambda_B}_\mathrm{1se}, {\lambda_\Theta}_\mathrm{min}</code>) if <code>'fit.1se = TRUE'</code> when calling &lsquo;<code>cv.missoNet</code>&rsquo;. &quot;<code>lambda.1se.Beta</code>&quot; refers to the largest <code class="reqn">\lambda_B</code> at which the mean cross-validated error is within one standard error of the minimum, by fixing <code class="reqn">\lambda_\Theta</code> at <code class="reqn">{\lambda_\Theta}_\mathrm{min}</code>. This <code>'list'</code> consists of the same components as <code>'est.min'</code>.</p>
</td></tr>
<tr><td><code>est.1se.Tht</code></td>
<td>
<p>A <code>'list'</code> of results estimated at &quot;<code>lambda.1se.Theta</code>&quot; := (<code class="reqn">{\lambda_B}_\mathrm{min}, {\lambda_\Theta}_\mathrm{1se}</code>) if <code>'fit.1se = TRUE'</code> when calling &lsquo;<code>cv.missoNet</code>&rsquo;. &quot;<code>lambda.1se.Theta</code>&quot; refers to the largest <code class="reqn">\lambda_\Theta</code> at which the mean cross-validated error is within one standard error of the minimum, by fixing <code class="reqn">\lambda_B</code> at <code class="reqn">{\lambda_B}_\mathrm{min}</code>. This <code>'list'</code> consists of the same components as <code>'est.min'</code>.</p>
</td></tr>
<tr><td><code>rho</code></td>
<td>
<p>A vector of length <code class="reqn">q</code> storing the working missing probabilities for the <code class="reqn">q</code> response variables.</p>
</td></tr>
<tr><td><code>fold.index</code></td>
<td>
<p>The subject indices identifying which fold each observation is in.</p>
</td></tr>
<tr><td><code>lambda.Beta.vec</code></td>
<td>
<p>A flattened vector of length (<code>'n.lamBeta'</code> <code>*</code> <code>'n.lamTheta'</code>) storing the <code class="reqn">\lambda_B</code> values along the regularization path. More specifically, <code>'lambda.Beta.vec' = rep('lambda.Beta', each = 'n.lamTheta')</code>.</p>
</td></tr>
<tr><td><code>lambda.Theta.vec</code></td>
<td>
<p>A flattened vector of length (<code>'n.lamBeta'</code> <code>*</code> <code>'n.lamTheta'</code>) storing the <code class="reqn">\lambda_\Theta</code> values along the regularization path. More specifically, <code>'lambda.Theta.vec' = rep('lambda.Theta', times = 'n.lamBeta')</code>.</p>
</td></tr>
<tr><td><code>cvm</code></td>
<td>
<p>A flattened vector of length (<code>'n.lamBeta'</code> <code>*</code> <code>'n.lamTheta'</code>) storing the (standardized) mean cross-validated errors along the regularization path.</p>
</td></tr>
<tr><td><code>cvup</code></td>
<td>
<p>Upper cross-validated errors.</p>
</td></tr>
<tr><td><code>cvlo</code></td>
<td>
<p>Lower cross-validated errors.</p>
</td></tr>
<tr><td><code>penalize.diagonal</code></td>
<td>
<p>Logical: whether the diagonal elements of <code class="reqn">\mathbf{\Theta}</code> were penalized.</p>
</td></tr>
<tr><td><code>diag.penalty.factor</code></td>
<td>
<p>The additional penalty multiplication factor for the diagonal elements of <code class="reqn">\mathbf{\Theta}</code> when <code>'penalize.diagonal'</code> was returned as <code>'TRUE'</code>.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Yixiao Zeng <a href="mailto:yixiao.zeng@mail.mcgill.ca">yixiao.zeng@mail.mcgill.ca</a>, Celia M.T. Greenwood and Archer Yi Yang.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Simulate a dataset with response values missing completely at random (MCAR), 
## the overall missing rate is around 10%.
set.seed(123)  # reproducibility
sim.dat &lt;- generateData(n = 300, p = 50, q = 20, rho = 0.1, missing.type = "MCAR")
tr &lt;- 1:240  # training set indices
tst &lt;- 241:300  # test set indices
X.tr &lt;- sim.dat$X[tr, ]  # predictor matrix
Y.tr &lt;- sim.dat$Z[tr, ]  # corrupted response matrix


## Perform a five-fold cross-validation WITH specified 'lambda.Beta' and 'lambda.Theta'.
## 'standardize' and 'standardize.response' are 'TRUE' by default.
lamB.vec &lt;- 10^(seq(from = 0, to = -1, length.out = 5))
lamTht.vec &lt;- 10^(seq(from = 0, to = -1, length.out = 5))
cvfit &lt;- cv.missoNet(X = X.tr, Y = Y.tr, kfold = 5,
                     lambda.Beta = lamB.vec, lambda.Theta = lamTht.vec)


## Perform a five-fold cross-validation WITHOUT specified 'lambda.Beta' and 'lambda.Theta'.
## In this case, a grid of 'lambda.Beta' and 'lambda.Theta' values in a (hopefully) reasonable 
## range will be computed and used by the program.
## 
## &lt; This simplest command should be a good start for most analyses. &gt;
cvfit &lt;- cv.missoNet(X = X.tr, Y = Y.tr, kfold = 5)


## Alternatively, compute the cross-validation folds in parallel on a cluster with 2 cores.
## 
## 'fit.1se = TRUE' tells the program to make additional estimations of the parameters at the 
## largest value of 'lambda.Beta' / 'lambda.Theta' that gives the most regularized model such 
## that the cross-validated error is within one standard error of the minimum.
cl &lt;- parallel::makeCluster(min(parallel::detectCores()-1, 2))
cvfit &lt;- cv.missoNet(X = X.tr, Y = Y.tr, kfold = 5, fit.1se = TRUE,
                     parallel = TRUE, cl = cl,
                     permute = TRUE, with.seed = 486)  # permute with seed for reproducibility
parallel::stopCluster(cl)


## Use PRE-STANDARDIZED training data if you wish to compare the results with other softwares. 
X.tr.std &lt;- scale(X.tr, center = TRUE, scale = TRUE)
Y.tr.std &lt;- scale(Y.tr, center = TRUE, scale = TRUE)
cvfit.std &lt;- cv.missoNet(X = X.tr.std, Y = Y.tr.std, kfold = 5,
                         standardize = FALSE, standardize.response = FALSE)


## Plot the (standardized) mean cross-validated errors in a heatmap.
plot(cvfit, type = "cv.heatmap")

## Plot the (standardized) mean cross-validated errors in a 3D scatterplot.
plot(cvfit, type = "cv.scatter", plt.surf = TRUE)


## Extract the estimates at "lambda.min".
Beta.hat1 &lt;- cvfit$est.min$Beta
Theta.hat1 &lt;- cvfit$est.min$Theta

## Extract the estimates at "lambda.1se.Beta" (if 'fit.1se' = TRUE).
Beta.hat2 &lt;- cvfit$est.1se.B$Beta
Theta.hat2 &lt;- cvfit$est.1se.B$Theta

## Extract the estimates at "lambda.1se.Theta" (if 'fit.1se' = TRUE).
Beta.hat3 &lt;- cvfit$est.1se.Tht$Beta
Theta.hat3 &lt;- cvfit$est.1se.Tht$Theta


## Make predictions of response values on the test set.
newy1 &lt;- predict(cvfit, newx = sim.dat$X[tst, ], s = "lambda.min")
newy2 &lt;- predict(cvfit, newx = sim.dat$X[tst, ], s = "lambda.1se.Beta")  # 'fit.1se' = TRUE
newy3 &lt;- predict(cvfit, newx = sim.dat$X[tst, ], s = "lambda.1se.Theta")  # 'fit.1se' = TRUE

</code></pre>

<hr>
<h2 id='generateData'>Quickly generate synthetic data for simulation studies</h2><span id='topic+generateData'></span>

<h3>Description</h3>

<p>The &lsquo;<code>generateData</code>&rsquo; function is used to readily produce synthetic data with randomly/systematically-missing values from a conditional Gaussian graphical model. 
This function supports three types of missing mechanisms that can be specified by users &ndash; missing completely at random (MCAR), missing at random (MAR) and 
missing not at random (MNAR).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>generateData(
  X = NULL,
  Beta = NULL,
  E = NULL,
  Theta = NULL,
  Sigma.X = NULL,
  n,
  p,
  q,
  rho,
  missing.type = "MCAR",
  Beta.row.sparsity = 0.2,
  Beta.elm.sparsity = 0.2,
  with.seed = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="generateData_+3A_x">X</code></td>
<td>
<p>(Optional) a user-supplied predictor matrix (<code class="reqn">n\times p</code>). The default is <code>'NULL'</code> and the program simulates the rows of <code>'X'</code> independently from <code class="reqn">\mathcal{MVN}</code>(<code class="reqn">0_p</code>, <code class="reqn">\mathbf{\Sigma}_X</code>). A user-supplied matrix overrides this default, and the argument <code>'Sigma.X'</code> for <code class="reqn">\mathbf{\Sigma}_X</code> will be ignored.</p>
</td></tr>
<tr><td><code id="generateData_+3A_beta">Beta</code></td>
<td>
<p>(Optional) a user-supplied regression coefficient matrix <code class="reqn">\mathbf{B}</code> (<code class="reqn">p\times q</code>). The default is <code>'NULL'</code> and the program will generate a sparse <code class="reqn">\mathbf{B}</code> in which the nonzero elements are independently drawn from <code class="reqn">\mathcal{N}(0, 1)</code>; the row sparsity and element sparsity of <code class="reqn">\mathbf{B}</code> are controlled by the arguments <code>'Beta.row.sparsity'</code> and <code>'Beta.elm.sparsity'</code>, respectively. A user-supplied matrix overrides this default, and <code>'Beta.row.sparsity'</code> and <code>'Beta.elm.sparsity'</code> will be ignored.</p>
</td></tr>
<tr><td><code id="generateData_+3A_e">E</code></td>
<td>
<p>(Optional) a user-supplied error matrix (<code class="reqn">n\times q</code>). The default is <code>'NULL'</code> and the program simulates the rows of <code>'E'</code> independently from <code class="reqn">\mathcal{MVN}</code>(<code class="reqn">0_q</code>, <code class="reqn">\mathbf{\Theta}^{-1}</code>). A response matrix <code>'Y'</code> without missing values is given by <code>'Y = X %*% Beta + E'</code>. A user-supplied matrix overrides this default, and the argument <code>'Theta'</code> for <code class="reqn">\mathbf{\Theta}</code> will be ignored.</p>
</td></tr>
<tr><td><code id="generateData_+3A_theta">Theta</code></td>
<td>
<p>(Optional) a user-supplied positive definite precision (inverse covariance) matrix <code class="reqn">\mathbf{\Theta}</code> (<code class="reqn">q\times q</code>) for the response variables. The default is <code>'NULL'</code> and the program will generate a block-structured matrix having four blocks corresponding to four types of network structures: independent, weak graph, strong graph and chain. This is only needed when <code>'E = NULL'</code>.</p>
</td></tr>
<tr><td><code id="generateData_+3A_sigma.x">Sigma.X</code></td>
<td>
<p>(Optional) A user-supplied positive definite covariance matrix <code class="reqn">\mathbf{\Sigma}_X</code> (<code class="reqn">p\times p</code>) for the predictor variables. The samples of <code>'X'</code> are independently drawn from a multivariate Gaussian distribution <code class="reqn">\mathcal{MVN}</code>(<code class="reqn">0_p</code>, <code class="reqn">\mathbf{\Sigma}_X</code>). If <code>'Sigma.X = NULL'</code> (default), the program uses an AR(1) covariance with 0.7 autocorrelation (i.e., <code class="reqn">[\mathbf{\Sigma}_X]_{jk} = 0.7^{|j-k|}</code>). This is only needed when <code>'X = NULL'</code>.</p>
</td></tr>
<tr><td><code id="generateData_+3A_n">n</code></td>
<td>
<p>Sample size.</p>
</td></tr>
<tr><td><code id="generateData_+3A_p">p</code></td>
<td>
<p>The dimensionality of the predictors.</p>
</td></tr>
<tr><td><code id="generateData_+3A_q">q</code></td>
<td>
<p>The dimensionality of the responses.</p>
</td></tr>
<tr><td><code id="generateData_+3A_rho">rho</code></td>
<td>
<p>A scalar or a numeric vector of length <code class="reqn">q</code> specifying the approximate proportion of missing values in each column of the response matrix.</p>
</td></tr>
<tr><td><code id="generateData_+3A_missing.type">missing.type</code></td>
<td>
<p>Character string: can be &quot;<code>MCAR</code>&quot; (default), &quot;<code>MAR</code>&quot; or &quot;<code>MNAR</code>&quot;.</p>
</td></tr>
<tr><td><code id="generateData_+3A_beta.row.sparsity">Beta.row.sparsity</code></td>
<td>
<p>A Bernoulli parameter between 0 and 1 controlling the approximate proportion of rows where at least one element could be nonzero in <code class="reqn">\mathbf{B}</code>; the default is <code>'Beta.row.sparsity = 0.2'</code>. This is only needed when <code>'Beta = NULL'</code>.</p>
</td></tr>
<tr><td><code id="generateData_+3A_beta.elm.sparsity">Beta.elm.sparsity</code></td>
<td>
<p>A Bernoulli parameter between 0 and 1 controlling the approximate proportion of nonzero elements among the rows of <code class="reqn">\mathbf{B}</code> where not all elements are zeros; the default is <code>'Beta.elm.sparsity = 0.2'</code>. This is only needed when <code>'Beta = NULL'</code>.</p>
</td></tr>
<tr><td><code id="generateData_+3A_with.seed">with.seed</code></td>
<td>
<p>A random number seed for the generative process.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The dataset is simulated through the following steps:
</p>

<ol>
<li><p> If <code>'X = NULL'</code> (default), the function &lsquo;<code>MASS::mvrnorm(n, mean = rep(0, p), sigma = Sigma.X)</code>&rsquo; is used to simulate <code>'n'</code> samples from a <code>'p'</code>-variate Gaussian distribution for generating a predictor matrix <code>'X'</code>;
</p>
</li>
<li><p> If <code>'Beta = NULL'</code> (default), the function &lsquo;<code>stats::rnorm(p*q, 0, 1)</code>&rsquo; is used to fill an empty (<code class="reqn">p \times q</code>) dimensional matrix <code>'Beta'</code>, of which the row sparsity and element sparsity are later controlled by the auxiliary arguments <code>'Beta.row.sparsity'</code> and <code>'Beta.elm.sparsity'</code>, respectively;
</p>
</li>
<li><p> If <code>'E = NULL'</code> (default), the function &lsquo;<code>MASS::mvrnorm(n, mean = rep(0, q), sigma = solve(Theta))</code>&rsquo; is used to simulate <code>'n'</code> samples from a <code>'q'</code>-variate Gaussian distribution for generating an error matrix <code>'E'</code>;
</p>
</li>
<li><p> A complete response matrix <code>'Y'</code> without missing values is then generated by the command <code>'Y = X %*% Beta + E'</code>;
</p>
</li>
<li><p> To get a response matrix <code>'Z'</code> := <code class="reqn">f</code>(<code>'Y'</code>) corrupted by missing data, the values in <code>'Y'</code> are partially replaced with <code>'NA'</code>s following the strategy specified by the arguments <code>'missing.type'</code> and <code>'rho'</code>.
</p>
</li></ol>

<p>To better illustrate the step 5 above, suppose for all <code>i = 1,...,n</code> and <code>j = 1,...,q</code>: <code>'Y[i, j]'</code> is replaced with <code>'NA'</code> 
if <code>'M[i, j] == 1'</code>, where <code>'M'</code> is an indicator matrix of missingness having the same dimension as <code>'Y'</code>.
The value of <code>'M[i, j]'</code> is partially controlled by the arguments <code>'missing.type'</code> and <code>'rho'</code>. 
Below we sum up the three built-in missing mechanisms supported by the &lsquo;<code>generateData</code>&rsquo; function:
</p>

<ul>
<li> <p><code>'missing.type'</code> == &quot;<code>MCAR</code>&quot;: <code>'Y[i, j] &lt;- NA'</code> if <code>'M[i, j] == 1'</code>, where <code>'M[i, j] = rbinom(0, rho[j])'</code>;
</p>
</li>
<li> <p><code>'missing.type'</code> == &quot;<code>MAR</code>&quot;: <code>'Y[i, j] &lt;- NA'</code> if <code>'M[i, j] == 1'</code>, where <code>'M[i, j]  = rbinom(0, (rho[j] * c / (1 + exp(-(X %*% Beta)[i, j]))))'</code>, in which <code>c</code> is a constant correcting the missing rate of the <code>j</code>th column of <code>'Y'</code> to <code>'rho[j]'</code>;
</p>
</li>
<li> <p><code>'missing.type'</code> == &quot;<code>MNAR</code>&quot;: <code>'Y[i, j] &lt;- NA'</code> if <code>'M[i, j] == 1'</code>, where <code>'M[i, j] = 1 * (Y[i, j] &lt; Tj)'</code>, in which <code>'Tj = quantile(Y[ , j], rho[j])'</code>.
</p>
</li></ul>

<p>Of the aforementioned missing mechanisms, &quot;<code>MCAR</code>&quot; is random, and the other two are systematic. 
under &quot;<code>MCAR</code>&quot;, <code>'M[i, j]'</code> is not related to <code>'Y'</code> or to <code>'X'</code>; 
under &quot;<code>MAR</code>&quot;, <code>'M[i, j]'</code> is related to <code>'X'</code>, but not related to <code>'Y'</code> after <code>'X'</code> is controlled; 
under &quot;<code>MNAR</code>&quot;, <code>'M[i, j]'</code> is related to <code>'Y'</code> itself, even after <code>'X'</code> is controlled.
</p>


<h3>Value</h3>

<p>This function returns a <code>'list'</code> consisting of the following components:
</p>
<table>
<tr><td><code>X</code></td>
<td>
<p>A simulated (or the user-supplied) predictor matrix (<code class="reqn">n\times p</code>).</p>
</td></tr>
<tr><td><code>Y</code></td>
<td>
<p>A simulated response matrix without missing values (<code class="reqn">n\times q</code>).</p>
</td></tr>
<tr><td><code>Z</code></td>
<td>
<p>A simulated response matrix with missing values coded as <code>'NA'</code>s (<code class="reqn">n\times q</code>).</p>
</td></tr>
<tr><td><code>Beta</code></td>
<td>
<p>The regression coefficient matrix <code class="reqn">\mathbf{B}</code> for the generative model (<code class="reqn">p\times q</code>).</p>
</td></tr>
<tr><td><code>Theta</code></td>
<td>
<p>The precision matrix <code class="reqn">\mathbf{\Theta}</code> for the generative model (<code class="reqn">q\times q</code>).</p>
</td></tr>
<tr><td><code>rho</code></td>
<td>
<p>A vector of length <code class="reqn">q</code> storing the specified missing rate for each column of the response matrix.</p>
</td></tr>
<tr><td><code>missing.type</code></td>
<td>
<p>Character string: the type of missing mechanism used to generate missing values in the response matrix.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Yixiao Zeng <a href="mailto:yixiao.zeng@mail.mcgill.ca">yixiao.zeng@mail.mcgill.ca</a>, Celia M.T. Greenwood and Archer Yi Yang.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Simulate a dataset with response values missing completely at random (MCAR), 
## the overall missing rate is around 10%.
sim.dat &lt;- generateData(n = 300, p = 50, q = 20, rho = 0.1, missing.type = "MCAR")
## -------------------------------------------------------------------------------
## Fit a missoNet model using the simulated dataset.
X &lt;- sim.dat$X  # predictor matrix
Y &lt;- sim.dat$Z  # corrupted response matrix
fit &lt;- missoNet(X = X, Y = Y, lambda.Beta = 0.1, lambda.Theta = 0.1)


## Simulate a dataset with response values missing at random (MAR), the approximate 
## missing rate for each column of the response matrix is specified through a vector 'rho'.
## 
## The row sparsity and element sparsity of the auto-generated 'Beta' could be 
## adjusted correspondingly by using 'Beta.row.sparsity' and 'Beta.elm.sparsity'.
n &lt;- 300; p &lt;- 50; q &lt;- 20
rho &lt;- runif(q, min = 0, max = 0.2)
sim.dat &lt;- generateData(n = n, p = p, q = q, rho = rho, missing.type = "MAR",
                        Beta.row.sparsity = 0.3, Beta.elm.sparsity = 0.2)


## Simulate a dataset with response values missing not at random (MNAR), 
## using the user-supplied 'Beta' and 'Theta'.
n &lt;- 300; p &lt;- 50; q &lt;- 20
Beta &lt;- matrix(rnorm(p*q, 0, 1), p, q)  # a nonsparse 'Beta' (p x q)
Theta &lt;- diag(q)  # a diagonal 'Theta' (q x q)
sim.dat &lt;- generateData(Beta = Beta, Theta = Theta, n = n, p = p, q = q,
                        rho = 0.1, missing.type = "MNAR")
## ---------------------------------------------------------------------          
## Specifying just one of 'Beta' and 'Theta' is also allowed.
sim.dat &lt;- generateData(Theta = Theta, n = n, p = p, q = q,
                        rho = 0.1, missing.type = "MNAR")


## User-supplied 'X', 'Beta' and 'E', in which case 'Y' is deterministic.
n &lt;- 300; p &lt;- 50; q &lt;- 20
X &lt;- matrix(rnorm(n*p, 0, 1), n, p)
Beta &lt;- matrix(rnorm(p*q, 0, 1), p, q)
E &lt;- mvtnorm::rmvnorm(n, rep(0, q), sigma = diag(q))
sim.dat &lt;- generateData(X = X, Beta = Beta, E = E, n = n, p = p, q = q,
                        rho = 0.1, missing.type = "MCAR")
</code></pre>

<hr>
<h2 id='missoNet'>Fit a series of missoNet models with user-supplied regularization parameters for the lasso penalties</h2><span id='topic+missoNet'></span>

<h3>Description</h3>

<p>This function fits the conditional graphical lasso models to datasets with missing response values. 
&lsquo;<code>missoNet</code>&rsquo; computes the regularization path for the lasso penalties sequentially along the
bivariate regularization parameter sequence <code class="reqn">\{(\lambda_B, \lambda_\Theta)\}</code> provided by the user.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>missoNet(
  X,
  Y,
  lambda.Beta,
  lambda.Theta,
  rho = NULL,
  Beta.maxit = 10000,
  Beta.thr = 1e-08,
  eta = 0.8,
  Theta.maxit = 10000,
  Theta.thr = 1e-08,
  eps = 1e-08,
  penalize.diagonal = TRUE,
  diag.penalty.factor = NULL,
  standardize = TRUE,
  standardize.response = TRUE,
  fit.relax = FALSE,
  parallel = FALSE,
  cl = NULL,
  verbose = 1
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="missoNet_+3A_x">X</code></td>
<td>
<p>Numeric predictor matrix (<code class="reqn">n\times p</code>): columns correspond to predictor variables and rows correspond to samples. Missing values are not allowed. There is no need for centering or scaling of the variables. <code>'X'</code> should not include a column of ones for an intercept.</p>
</td></tr>
<tr><td><code id="missoNet_+3A_y">Y</code></td>
<td>
<p>Numeric response matrix (<code class="reqn">n\times q</code>): columns correspond to response variables and rows correspond to samples. Missing values should be coded as either <code>'NA'</code>s or <code>'NaN'</code>s. There is no need for centering or scaling of the variables.</p>
</td></tr>
<tr><td><code id="missoNet_+3A_lambda.beta">lambda.Beta</code></td>
<td>
<p>A scalar or a numeric vector: a user-supplied sequence of non-negative value(s) for {<code class="reqn">\lambda_B</code>} used to penalize the elements of the coefficient matrix <code class="reqn">\mathbf{B}</code>. Note that the values will be sequentially visited in the given orders as inputs to the regularization parameter sequence <code class="reqn">\{(\lambda_B, \lambda_\Theta)\}</code>; <code>'lambda.Beta'</code> must have the same length as <code>'lambda.Theta'</code>.</p>
</td></tr>
<tr><td><code id="missoNet_+3A_lambda.theta">lambda.Theta</code></td>
<td>
<p>A scalar or a numeric vector: a user-supplied sequence of non-negative value(s) for {<code class="reqn">\lambda_\Theta</code>} used to penalize the (off-diagonal) elements of the precision matrix <code class="reqn">\mathbf{\Theta}</code>. Note that the values will be sequentially visited in the given orders as inputs to the regularization parameter sequence <code class="reqn">\{(\lambda_B, \lambda_\Theta)\}</code>; <code>'lambda.Theta'</code> must have the same length as <code>'lambda.Beta'</code>.</p>
</td></tr>
<tr><td><code id="missoNet_+3A_rho">rho</code></td>
<td>
<p>(Optional) A scalar or a numeric vector of length <code class="reqn">q</code>: the elements are user-supplied probabilities of missingness for the response variables. The default is <code>'rho = NULL'</code> and the program will compute the empirical missing rates for each of the columns of <code>'Y'</code> and use them as the working missing probabilities. The default setting should suffice in most cases; misspecified missing probabilities would introduce biases into the model.</p>
</td></tr>
<tr><td><code id="missoNet_+3A_beta.maxit">Beta.maxit</code></td>
<td>
<p>The maximum number of iterations of the fast iterative shrinkage-thresholding algorithm (FISTA) for updating <code class="reqn">\hat{\mathbf{B}}</code>. The default is <code>'Beta.maxit = 10000'</code>.</p>
</td></tr>
<tr><td><code id="missoNet_+3A_beta.thr">Beta.thr</code></td>
<td>
<p>The convergence threshold of the FISTA algorithm for updating <code class="reqn">\hat{\mathbf{B}}</code>; the default is <code>'Beta.thr = 1.0E-8'</code>. Iterations stop when the absolute parameter change is less than (<code>'Beta.thr'</code> <code>*</code> <code>sum(abs(</code><code class="reqn">\hat{\mathbf{B}}</code><code>))</code>).</p>
</td></tr>
<tr><td><code id="missoNet_+3A_eta">eta</code></td>
<td>
<p>The backtracking line search shrinkage factor; the default is <code>'eta = 0.8'</code>. Most users will be able to use the default value, some experienced users may want to tune <code>'eta'</code> according to the properties of a specific dataset for a faster convergence of the FISTA algorithm. Note that <code>'eta'</code> must be in (0, 1).</p>
</td></tr>
<tr><td><code id="missoNet_+3A_theta.maxit">Theta.maxit</code></td>
<td>
<p>The maximum number of iterations of the &lsquo;<code><a href="glasso.html#topic+glasso">glasso</a></code>&rsquo; algorithm for updating <code class="reqn">\hat{\mathbf{\Theta}}</code>. The default is <code>'Theta.maxit = 10000'</code>.</p>
</td></tr>
<tr><td><code id="missoNet_+3A_theta.thr">Theta.thr</code></td>
<td>
<p>The convergence threshold of the &lsquo;<code><a href="glasso.html#topic+glasso">glasso</a></code>&rsquo; algorithm for updating <code class="reqn">\hat{\mathbf{\Theta}}</code>; the default is <code>'Theta.thr = 1.0E-8'</code>. Iterations stop when the average absolute parameter change is less than (<code>'Theta.thr'</code> <code>*</code> <code>ave(abs(offdiag(</code><code class="reqn">\hat{\mathbf{\Sigma}}</code><code>)))</code>), where <code class="reqn">\hat{\mathbf{\Sigma}}</code> denotes the empirical working covariance matrix.</p>
</td></tr>
<tr><td><code id="missoNet_+3A_eps">eps</code></td>
<td>
<p>A numeric tolerance level for the L1 projection of the empirical covariance matrix; the default is <code>'eps = 1.0E-8'</code>. The empirical covariance matrix will be projected onto a L1 ball to have <code>min(eigen(</code><code class="reqn">\hat{\mathbf{\Sigma}}</code><code>)$value)</code> == <code>'eps'</code>, if any of the eigenvalues is less than the specified tolerance. Most users will be able to use the default value.</p>
</td></tr>
<tr><td><code id="missoNet_+3A_penalize.diagonal">penalize.diagonal</code></td>
<td>
<p>Logical: should the diagonal elements of <code class="reqn">\mathbf{\Theta}</code> be penalized? The default is <code>'TRUE'</code>.</p>
</td></tr>
<tr><td><code id="missoNet_+3A_diag.penalty.factor">diag.penalty.factor</code></td>
<td>
<p>Numeric: a separate penalty multiplication factor for the diagonal elements of <code class="reqn">\mathbf{\Theta}</code> when <code>'penalize.diagonal = TRUE'</code>. <code class="reqn">\lambda_\Theta</code> is multiplied by this number to allow a differential shrinkage of the diagonal elements. The default is <code>'NULL'</code> and the program will guess a value based on an initial estimate of <code class="reqn">\mathbf{\Theta}</code>. This factor could be <code>'0'</code> for no shrinkage (equivalent to <code>'penalize.diagonal = FALSE'</code>) or <code>'1'</code> for an equal shrinkage.</p>
</td></tr>
<tr><td><code id="missoNet_+3A_standardize">standardize</code></td>
<td>
<p>Logical: should the columns of <code>'X'</code> be standardized so each has unit variance? The default is <code>'TRUE'</code>. The estimated results will always be returned on the original scale. If <code>'X'</code> has been standardized prior to fitting the model, you might not wish to standardize it inside the algorithm.</p>
</td></tr>
<tr><td><code id="missoNet_+3A_standardize.response">standardize.response</code></td>
<td>
<p>Logical: should the columns of <code>'Y'</code> be standardized so each has unit variance? The default is <code>'TRUE'</code>. The estimated results will always be returned on the original scale. If <code>'Y'</code> has been standardized prior to fitting the model, you might not wish to standardize it inside the algorithm.</p>
</td></tr>
<tr><td><code id="missoNet_+3A_fit.relax">fit.relax</code></td>
<td>
<p>Logical: the default is <code>'FALSE'</code>. If <code>'TRUE'</code>, the program will re-estimate the edges in the active set (i.e. nonzero off-diagonal elements) of the network structure <code class="reqn">\hat{\mathbf{\Theta}}</code> without penalization (<code class="reqn">\lambda_\Theta=0</code>). This debiased estimate of <code class="reqn">\mathbf{\Theta}</code> could be useful for some interdependency analyses. WARNING: there may be convergence issues if the empirical covariance matrix is not of full rank (e.g. <code class="reqn">n &lt; q)</code>).</p>
</td></tr>
<tr><td><code id="missoNet_+3A_parallel">parallel</code></td>
<td>
<p>Logical: the default is <code>'FALSE'</code>. If <code>'TRUE'</code>, the program uses clusters to fit models with each element of the <code class="reqn">\lambda</code> sequence <code class="reqn">\{(\lambda_B, \lambda_\Theta)\}</code> in parallel. Must register parallel clusters beforehand, see examples below.</p>
</td></tr>
<tr><td><code id="missoNet_+3A_cl">cl</code></td>
<td>
<p>A cluster object created by &lsquo;<code>parallel::makeCluster</code>&rsquo; for parallel evaluations. This is only needed when <code>'parallel = TRUE'</code>.</p>
</td></tr>
<tr><td><code id="missoNet_+3A_verbose">verbose</code></td>
<td>
<p>Value of <code>'0'</code>, <code>'1'</code> or <code>'2'</code>. <code>'verbose = 0'</code> &ndash; silent; <code>'verbose = 1'</code> (the default) &ndash; limited tracing with progress bars; <code>'verbose = 2'</code> &ndash; detailed tracing. Note that displaying the progress bars slightly increases the computation overhead compared to the silent mode. The detailed tracing should be used for monitoring progress only when the program runs extremely slowly, and it is not supported under <code>'parallel = TRUE'</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>&lsquo;<code>missoNet</code>&rsquo; is the main model-fitting function which is specifically proposed to fit the conditional 
graphical lasso models / penalized multi-task Gaussian regressions to (corrupted) datasets with response values missing at random (MAR).
To facilitate the interpretation of the model, let's temporarily assume that there are no missing values 
in the data used to fit the model. Suppose we have <code class="reqn">n</code> observations of both a <code class="reqn">p</code>-variate predictor <code class="reqn">X \in \mathcal{R}^p</code>
and a <code class="reqn">q</code>-variate response <code class="reqn">Y \in \mathcal{R}^q</code>, for the <code class="reqn">i</code>th sample (<code class="reqn">i = 1,...,n</code>), 
&lsquo;<code>missoNet</code>&rsquo; assumes the model
</p>
<p style="text-align: center;"><code class="reqn">Y_i = \mu + X_i\mathbf{B} + E_i,\ \ E_i \sim \mathcal{MVN}(0_q, (\mathbf{\Theta})^{-1}),</code>
</p>

<p>where <code class="reqn">Y_i \in \mathcal{R}^{1\times q}</code> and <code class="reqn">X_i \in \mathcal{R}^{1\times p}</code> are one 
realization of the <code class="reqn">q</code> responses and the <code class="reqn">p</code> predictors, respectively. 
<code class="reqn">E_i \in \mathcal{R}^{1\times q}</code> is an error vector drawn from a multivariate Gaussian distribution. 
</p>
<p>The regression coefficient matrix <code class="reqn">\mathbf{B} \in \mathcal{R}^{p\times q}</code> that mapping predictors to responses and 
the precision (inverse covariance) matrix <code class="reqn">\mathbf{\Theta} \in \mathcal{R}^{q\times q}</code> that revealing the 
responses' conditional dependencies are the parameters to be estimated by solving a penalized MLE problem
</p>
<p style="text-align: center;"><code class="reqn">(\hat{\mathbf{\Theta}},\hat{\mathbf{B}}) = {\mathrm{argmin}}_{\mathbf{\Theta} \succeq 0,\ \mathbf{B}}\ 
g(\mathbf{\Theta},\mathbf{B}) + \lambda_{\Theta}(\|\mathbf{\Theta}\|_{1,\mathrm{off}} + 1_{n\leq \mathrm{max}(p,q)} \|\mathbf{\Theta}\|_{1,\mathrm{diag}}) + \lambda_{B}\|\mathbf{B}\|_1,</code>
</p>

<p>where 
</p>
<p style="text-align: center;"><code class="reqn">g(\mathbf{\Theta},\mathbf{B}) = \mathrm{tr}\left[\frac{1}{n}(\mathbf{Y} - \mathbf{XB})^\top(\mathbf{Y} - \mathbf{XB}) \mathbf{\Theta}\right] 
- \mathrm{log}|\mathbf{\Theta}|.</code>
</p>

<p>The response matrix <code class="reqn">\mathbf{Y} \in \mathcal{R}^{n\times q}</code> has <code class="reqn">i</code>th row (<code class="reqn">Y_i - \frac{1}{n}\sum_{j=1}^n Y_j</code>), 
and the predictor matrix <code class="reqn">\mathbf{X} \in \mathcal{R}^{n\times p}</code> has <code class="reqn">i</code>th row (<code class="reqn">X_i - \frac{1}{n}\sum_{j=1}^n X_j</code>). 
The intercept <code class="reqn">\mu \in \mathcal{R}^{1\times q}</code> is canceled out because of centering of the data matrices <code class="reqn">\mathbf{Y}</code> and <code class="reqn">\mathbf{X}</code>. 
<code class="reqn">1_{n\leq \mathrm{max}(p,q)}</code> denotes the indicator function for whether penalizing the diagonal elements of <code class="reqn">\mathbf{\Theta}</code> or not. 
When <code class="reqn">n\leq \mathrm{max}(p,q)</code>, a global minimizer of the objective function defined above does not exist without the diagonal penalization.
</p>
<p>Missingness in real data is inevitable. In this instance, the estimates based only on complete cases are likely to be biased, 
and the objective function is likely to no longer be a biconvex optimization problem. In addition, many algorithms cannot be directly employed since they 
require complete datasets as inputs. &lsquo;<code>missoNet</code>&rsquo; aims to handle the specific situation where the response matrix <code class="reqn">\mathbf{Y}</code> contains values that 
are missing at random (MAR. Please refer to the vignette or other resources for more information about the differences between MAR, missing completely at 
random (MCAR) and missing not at random (MNAR)). As it should be, &lsquo;<code>missoNet</code>&rsquo; is also applicable to datasets with MCAR response values or without any missing values. 
The method provides a unified framework for automatically solving a convex modification of the multi-task learning problem defined above, 
using corrupted datasets. Moreover, &lsquo;<code>missoNet</code>&rsquo; enjoys the theoretical and computational benefits of convexity and returns 
solutions that are comparable/close to the clean conditional graphical lasso estimates. Please refer to the original manuscript (coming soon) for more details of our method.
</p>


<h3>Value</h3>

<p>This function returns a <code>'list'</code> consisting of the following components:
</p>
<table>
<tr><td><code>est.list</code></td>
<td>
<p>A named <code>'list'</code> storing the lists of results estimated at each of the <code class="reqn">\lambda</code> pairs, (<code class="reqn">\lambda_B</code>, <code class="reqn">\lambda_\Theta</code>). Each sub-<code>'list'</code> contains:
</p>

<ul>
<li> <p><code>Beta</code>: the penalized estimate of the regression coefficient matrix <code class="reqn">\hat{\mathbf{B}}</code> (<code class="reqn">p\times q</code>).
</p>
</li>
<li> <p><code>Theta</code>: the penalized estimate of the precision matrix <code class="reqn">\hat{\mathbf{\Theta}}</code> (<code class="reqn">q\times q</code>).
</p>
</li>
<li> <p><code>mu</code>: a vector of length <code class="reqn">q</code> storing the model intercept <code class="reqn">\hat{\mu}</code>.
</p>
</li>
<li> <p><code>lambda.Beta</code>: the value of <code class="reqn">\lambda_B</code> used to fit the model.
</p>
</li>
<li> <p><code>lambda.Theta</code>: the value of <code class="reqn">\lambda_\Theta</code> used to fit the model.
</p>
</li>
<li> <p><code>relax.net</code>: the relaxed (debiased) estimate of the conditional network structure <code class="reqn">\hat{\mathbf{\Theta}}_\mathrm{rlx}</code> (<code class="reqn">q\times q</code>) if <code>'fit.relax = TRUE'</code> when calling &lsquo;<code>missoNet</code>&rsquo;.
</p>
</li></ul>

</td></tr>
<tr><td><code>rho</code></td>
<td>
<p>A vector of length <code class="reqn">q</code> storing the working missing probabilities for the <code class="reqn">q</code> response variables.</p>
</td></tr>
<tr><td><code>penalize.diagonal</code></td>
<td>
<p>Logical: whether the diagonal elements of <code class="reqn">\mathbf{\Theta}</code> were penalized.</p>
</td></tr>
<tr><td><code>diag.penalty.factor</code></td>
<td>
<p>The additional penalty multiplication factor for the diagonal elements of <code class="reqn">\mathbf{\Theta}</code> when <code>'penalize.diagonal'</code> was returned as <code>'TRUE'</code>.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Yixiao Zeng <a href="mailto:yixiao.zeng@mail.mcgill.ca">yixiao.zeng@mail.mcgill.ca</a>, Celia M.T. Greenwood and Archer Yi Yang.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Simulate a dataset with response values missing completely at random (MCAR), 
## the overall missing rate is around 10%.
set.seed(123)  # reproducibility
sim.dat &lt;- generateData(n = 300, p = 50, q = 20, rho = 0.1, missing.type = "MCAR")
tr &lt;- 1:240  # training set indices
tst &lt;- 241:300  # test set indices
X.tr &lt;- sim.dat$X[tr, ]  # predictor matrix
Y.tr &lt;- sim.dat$Z[tr, ]  # corrupted response matrix


## Fit one missoNet model with two scalars for 'lambda.Beta' and 'lambda.Theta'.
fit1 &lt;- missoNet(X = X.tr, Y = Y.tr, lambda.Beta = 0.1, lambda.Theta = 0.2)


## Fit a series of missoNet models with the lambda pairs := (lambda.Beta, lambda.Theta)
## sequentially extracted from the 'lambda.Beta' and 'lambda.Theta' vectors, note that the 
## two vectors must have the same length.
lamB.vec &lt;- 10^(seq(from = 0, to = -1, length.out = 5))
lamTht.vec &lt;- rep(0.1, 5)
fit2 &lt;- missoNet(X = X.tr, Y = Y.tr, lambda.Beta = lamB.vec, lambda.Theta = lamTht.vec)


## Parallelization on a cluster with two cores.
cl &lt;- parallel::makeCluster(2)
fit2 &lt;- missoNet(X = X.tr, Y = Y.tr, lambda.Beta = lamB.vec, lambda.Theta = lamTht.vec, 
                 parallel = TRUE, cl = cl)
parallel::stopCluster(cl)


## Extract the estimates at ('lamB.vec[1]', 'lamTht.vec[1]').
## The estimates at the subsequent lambda pairs could be accessed in the same way.
Beta.hat &lt;- fit2$est.list[[1]]$Beta
Theta.hat &lt;- fit2$est.list[[1]]$Theta
lambda.Beta &lt;- fit2$est.list[[1]]$lambda.Beta  # equal to 'lamB.vec[1]'
lambda.Theta &lt;- fit2$est.list[[1]]$lambda.Theta  # equal to 'lamTht.vec[1]'


## Fit a series of missoNet models using PRE-STANDARDIZED training data
## if you wish to compare the results with other softwares. 
X.tr.std &lt;- scale(X.tr, center = TRUE, scale = TRUE)
Y.tr.std &lt;- scale(Y.tr, center = TRUE, scale = TRUE)
fit3 &lt;- missoNet(X = X.tr.std, Y = Y.tr.std, lambda.Beta = lamB.vec, lambda.Theta = lamTht.vec,
                 standardize = FALSE, standardize.response = FALSE)

</code></pre>

<hr>
<h2 id='plot.cv.missoNet'>Plot the cross-validation errors produced by cv.missoNet</h2><span id='topic+plot.cv.missoNet'></span>

<h3>Description</h3>

<p>S3 method for plotting the cross-validation error surface from a fitted <code>'cv.missoNet'</code> object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'cv.missoNet'
plot(
  x,
  type = c("cv.heatmap", "cv.scatter"),
  detailed.axes = TRUE,
  plt.surf = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.cv.missoNet_+3A_x">x</code></td>
<td>
<p>A fitted <code>'cv.missoNet'</code> object.</p>
</td></tr>
<tr><td><code id="plot.cv.missoNet_+3A_type">type</code></td>
<td>
<p>A character string for the type of plot, can be either &quot;<code>cv.heatmap</code>&quot; (default) or &quot;<code>cv.scatter</code>&quot;.</p>
</td></tr>
<tr><td><code id="plot.cv.missoNet_+3A_detailed.axes">detailed.axes</code></td>
<td>
<p>Logical: whether the detailed axes should be plotted. The default is <code>'TRUE'</code>.</p>
</td></tr>
<tr><td><code id="plot.cv.missoNet_+3A_plt.surf">plt.surf</code></td>
<td>
<p>Logical: whether to draw the error surface. The default is <code>'TRUE'</code>. This is only needed when <code>'type'</code> = &quot;<code>cv.scatter</code>&quot;.</p>
</td></tr>
<tr><td><code id="plot.cv.missoNet_+3A_...">...</code></td>
<td>
<p>Other graphical arguments used by &lsquo;ComplexHeatmap::Heatmap&rsquo; (<code>'type'</code> = &quot;<code>cv.heatmap</code>&quot;) or &lsquo;scatterplot3d::scatterplot3d&rsquo; (<code>'type'</code> = &quot;<code>cv.scatter</code>&quot;).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The plot object.
</p>


<h3>Author(s)</h3>

<p>Yixiao Zeng <a href="mailto:yixiao.zeng@mail.mcgill.ca">yixiao.zeng@mail.mcgill.ca</a>, Celia M.T. Greenwood and Archer Yi Yang.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Simulate a dataset.
set.seed(123)  # reproducibility
sim.dat &lt;- generateData(n = 200, p = 10, q = 10, rho = 0.1, missing.type = "MCAR")


## Perform a five-fold cross-validation on the simulated dataset.
cvfit &lt;- cv.missoNet(X = sim.dat$X, Y = sim.dat$Z, kfold = 5,
                     fit.1se = TRUE, permute = TRUE, with.seed = 486)


## Plot the (standardized) mean cross-validated errors in a heatmap.
plot(cvfit, type = "cv.heatmap")

## Plot the (standardized) mean cross-validated errors in a 3D scatterplot.
plot(cvfit, type = "cv.scatter", plt.surf = TRUE)

</code></pre>

<hr>
<h2 id='predict.cv.missoNet'>Make predictions from a cv.missoNet object</h2><span id='topic+predict.cv.missoNet'></span>

<h3>Description</h3>

<p>S3 method for making predictions of response values from a fitted <code>'cv.missoNet'</code> object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'cv.missoNet'
predict(object, newx = NULL, s = "lambda.min", ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="predict.cv.missoNet_+3A_object">object</code></td>
<td>
<p>A fitted <code>'cv.missoNet'</code> object.</p>
</td></tr>
<tr><td><code id="predict.cv.missoNet_+3A_newx">newx</code></td>
<td>
<p>A predictor matrix of new values at which predictions are to be made. The columns of <code>'newx'</code> should have the same standardization flags as the original input for training the model. Missing values are not allowed. <code>'newx'</code> should not include a column of ones for an intercept.</p>
</td></tr>
<tr><td><code id="predict.cv.missoNet_+3A_s">s</code></td>
<td>
<p>Character string, the regularization parameter pair <code class="reqn">\lambda</code> = (<code class="reqn">\lambda_B</code>, <code class="reqn">\lambda_\Theta</code>) at which the coefficients are extracted for making predictions. It supports three special strings, named &quot;<code>lambda.min</code>&quot; (default), &quot;<code>lambda.1se.Beta</code>&quot; and &quot;<code>lambda.1se.Theta</code>&quot;.</p>
</td></tr>
<tr><td><code id="predict.cv.missoNet_+3A_...">...</code></td>
<td>
<p>Not used. Other arguments for predicting.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The matrix of predicted values: <code>'newy = mu_hat + newx %*% Beta_hat'</code>.
</p>


<h3>Author(s)</h3>

<p>Yixiao Zeng <a href="mailto:yixiao.zeng@mail.mcgill.ca">yixiao.zeng@mail.mcgill.ca</a>, Celia M.T. Greenwood and Archer Yi Yang.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Simulate a dataset.
set.seed(123)  # reproducibility
sim.dat &lt;- generateData(n = 300, p = 10, q = 10, rho = 0.1, missing.type = "MCAR")
tr &lt;- 1:240  # training set indices
tst &lt;- 241:300  # test set indices


## Perform a five-fold cross-validation on the training set.
cvfit &lt;- cv.missoNet(X = sim.dat$X[tr, ], Y = sim.dat$Z[tr, ], kfold = 5,
                     fit.1se = TRUE, permute = TRUE, with.seed = 486)


## Make predictions of response values on the test set.
newy1 &lt;- predict(cvfit, newx = sim.dat$X[tst, ], s = "lambda.min")
newy2 &lt;- predict(cvfit, newx = sim.dat$X[tst, ], s = "lambda.1se.Beta")  # 'fit.1se' = TRUE
newy3 &lt;- predict(cvfit, newx = sim.dat$X[tst, ], s = "lambda.1se.Theta")  # 'fit.1se' = TRUE

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
