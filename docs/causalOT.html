<!DOCTYPE html><html><head><title>Help for package causalOT</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {causalOT}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#causalOT'><p>An R package to perform causal inference using optimal transport distances.</p></a></li>
<li><a href='#barycentric_projection'><p>Barycentric Projection outcome estimation</p></a></li>
<li><a href='#calc_weight'><p>Estimate causal weights</p></a></li>
<li><a href='#causalEffect-class'><p>causalEffect class</p></a></li>
<li><a href='#causalWeights-class'><p>causalWeights class</p></a></li>
<li><a href='#coef.causalEffect'><p>Extract treatment effect estimate</p></a></li>
<li><a href='#cot_solve+2CateClass-method'><p>cot_solve method for ateClass objects</p></a></li>
<li><a href='#cot_solve+2CgridSearch-method'><p>cot_solve for gridSearch</p></a></li>
<li><a href='#cot_solve+2ClikelihoodMethods-method'><p>cot_solve method for likelihoodMethods</p></a></li>
<li><a href='#cotOptions'><p>Options available for the COT method</p></a></li>
<li><a href='#CRASH3'><p>CRASH3 data example</p></a></li>
<li><a href='#data_separate.dataHolder'><p>Title</p></a></li>
<li><a href='#dataHolder'><p>dataHolder</p></a></li>
<li><a href='#dataHolder-class'><p>dataHolder-class</p></a></li>
<li><a href='#dataHolder+2CdataHolder-method'><p>dataHolder-methods</p></a></li>
<li><a href='#DataSim'><p>R6 Data Generating Parent Class</p></a></li>
<li><a href='#df2dataHolder'><p>df2dataHolder</p></a></li>
<li><a href='#df2dataHolder+2CANY+2CANY+2Cdata.frame-method'><p>df2dataHolder-methods</p></a></li>
<li><a href='#entBWOptions'><p>Options for the Entropy Balancing Weights</p></a></li>
<li><a href='#ESS'><p>Effective Sample Size</p></a></li>
<li><a href='#estimate_effect'><p>Estimate treatment effects</p></a></li>
<li><a href='#estimate_model'><p>Function to estimate outcome models</p></a></li>
<li><a href='#gridSearch-class'><p>gridSearch S4 class</p></a></li>
<li><a href='#Hainmueller'><p>Hainmueller data example</p></a></li>
<li><a href='#LaLonde'><p>LaLonde data example</p></a></li>
<li><a href='#mean_balance'><p>Standardized absolute mean difference calculations</p></a></li>
<li><a href='#Measure'><p>An R6 Class for setting up measures</p></a></li>
<li><a href='#Measure_'><p>An R6 object for measures</p></a></li>
<li><a href='#oop_loss_select'><p>Internal function to select appropriate loss function</p></a></li>
<li><a href='#ot_distance'><p>Optimal Transport Distance</p></a></li>
<li><a href='#OTProblem'><p>Object Oriented OT Problem</p></a></li>
<li><a href='#OTProblem_-class'><p>An R6 class to construct OTProblems</p></a></li>
<li><a href='#plot.causalWeights'><p>plot.causalWeights</p></a></li>
<li><a href='#pph'><p>An external control trial of treatments for post-partum hemorrhage</p></a></li>
<li><a href='#predict.bp'><p>Predict method for barycentric projection models</p></a></li>
<li><a href='#print.dataHolder'><p>print.dataHolder</p></a></li>
<li><a href='#PSIS'><p>Pareto-Smoothed Importance Sampling</p></a></li>
<li><a href='#PSIS.causalWeights'><p>PSIS casualWeights class</p></a></li>
<li><a href='#sbwOptions'><p>Options for the SBW method</p></a></li>
<li><a href='#scmOptions'><p>Options for the SCM Method</p></a></li>
<li><a href='#summary.causalWeights'><p>Summary diagnostics for causalWeights</p></a></li>
<li><a href='#supported_methods'><p>Supported Methods</p></a></li>
<li><a href='#vcov.causalEffect'><p>Get the variance of a causalEffect</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Optimal Transport Weights for Causal Inference</td>
</tr>
<tr>
<td>Version:</td>
<td>1.0.2</td>
</tr>
<tr>
<td>Date:</td>
<td>2024-02-17</td>
</tr>
<tr>
<td>Author:</td>
<td>Eric Dunipace <a href="https://orcid.org/0000-0001-8909-213X"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cre]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Eric Dunipace &lt;edunipace@mail.harvard.edu&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Uses optimal transport distances to find probabilistic 
    matching estimators for causal inference.
    These methods are described in Dunipace, Eric (2021) &lt;<a href="https://doi.org/10.48550/arXiv.2109.01991">doi:10.48550/arXiv.2109.01991</a>&gt;.
    The package will build the weights, estimate treatment effects, and
    calculate confidence intervals via the methods described in the paper.
    The package also supports several other methods as described in the help 
    files.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL (== 3.0)</a></td>
</tr>
<tr>
<td>Imports:</td>
<td>CBPS, ggplot2, lbfgsb3c, loo, Matrix (&ge; 1.5-0), matrixStats,
methods, osqp, R6 (&ge; 2.4.1), Rcpp (&ge; 1.0.3), rlang, sandwich,
torch, utils</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>BH (&ge; 1.66.0), Rcpp (&ge; 0.12.0), RcppEigen (&ge; 0.3.3.3.0),
torch</td>
</tr>
<tr>
<td>Suggests:</td>
<td>data.table (&ge; 1.12.8), testthat (&ge; 2.1.0), knitr,
reticulate, rkeops (&ge; 2.2.2), rmarkdown, V8, withr</td>
</tr>
<tr>
<td>Additional_repositories:</td>
<td><a href="https://ericdunipace.github.io/drat/">https://ericdunipace.github.io/drat/</a></td>
</tr>
<tr>
<td>Biarch:</td>
<td>true</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.5.0)</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.3.1</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>Collate:</td>
<td>'DataSimClass.R' 'dataHolder.R' 'weightsClass.R' 'ESS.R'
'OT.R' 'PSIS.R' 'RcppExports.R' 'balanceFunctions.R'
'barycentricProjection.R' 'calc_weight.R' 'causalOT-package.R'
'cost_functions.R' 'scmClass.R' 'gridSearch.R' 'cotClass.R'
'cotOOP.R' 'cot_opts.R' 'likelihoodClass.R' 'mean_balance.R'
'summary.R' 'supportedMethods.R' 'treatment_effect.R' 'utils.R'
'zzz.R'</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-02-18 21:20:35 UTC; eifer</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-02-18 22:50:08 UTC</td>
</tr>
</table>
<hr>
<h2 id='causalOT'>An R package to perform causal inference using optimal transport distances.</h2><span id='topic+causalOT-package'></span><span id='topic+causalOT'></span>

<h3>Description</h3>

<p>R code to perform causal inference weighting using a variety of methods and optimizers. The code can estimate weights, estimate treatment effects, and also give variance estimates. These methods are described in Dunipace, Eric (2021) <a href="https://arxiv.org/abs/2109.01991">https://arxiv.org/abs/2109.01991</a>.
</p>


<h3>Author(s)</h3>

<p>Eric Dunipace
</p>

<hr>
<h2 id='barycentric_projection'>Barycentric Projection outcome estimation</h2><span id='topic+barycentric_projection'></span>

<h3>Description</h3>

<p>Barycentric Projection outcome estimation
</p>


<h3>Usage</h3>

<pre><code class='language-R'>barycentric_projection(
  formula,
  data,
  weights,
  separate.samples.on = "z",
  penalty = NULL,
  cost_function = NULL,
  p = 2,
  debias = FALSE,
  cost.online = "auto",
  diameter = NULL,
  niter = 1000L,
  tol = 1e-07,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="barycentric_projection_+3A_formula">formula</code></td>
<td>
<p>A formula object specifying the outcome and covariates.</p>
</td></tr>
<tr><td><code id="barycentric_projection_+3A_data">data</code></td>
<td>
<p>A data.frame of the data to use in the model.</p>
</td></tr>
<tr><td><code id="barycentric_projection_+3A_weights">weights</code></td>
<td>
<p>Either a vector of weights, one for each observations, or an object of class <a href="#topic+causalWeights-class">causalWeights</a>.</p>
</td></tr>
<tr><td><code id="barycentric_projection_+3A_separate.samples.on">separate.samples.on</code></td>
<td>
<p>The variable in the data denoting the treatment indicator. How to separate samples for the optimal transport calculation</p>
</td></tr>
<tr><td><code id="barycentric_projection_+3A_penalty">penalty</code></td>
<td>
<p>The penalty parameter to use in the optimal transport calculation. By default it is <code class="reqn">1/\log(n)</code>.</p>
</td></tr>
<tr><td><code id="barycentric_projection_+3A_cost_function">cost_function</code></td>
<td>
<p>A user supplied cost function. If supplied, must take arguments <code>x1</code>, <code>x2</code>, and <code>p</code>.</p>
</td></tr>
<tr><td><code id="barycentric_projection_+3A_p">p</code></td>
<td>
<p>The power to raise the cost function. Default is 2.0. For user supplied cost functions, the cost will not be raised by this power unless the user so specifies.</p>
</td></tr>
<tr><td><code id="barycentric_projection_+3A_debias">debias</code></td>
<td>
<p>Should debiased barycentric projections be used? See details.</p>
</td></tr>
<tr><td><code id="barycentric_projection_+3A_cost.online">cost.online</code></td>
<td>
<p>Should an online cost algorithm be used? Default is &quot;auto&quot;, which selects an online cost algorithm when the sample size in each group specified by <code>separate.samples.on</code>, <code class="reqn">n_0</code> and <code class="reqn">n_1</code>, is such that <code class="reqn">n_0 \cdot n_1 \geq 5000^2</code> Must be one of &quot;auto&quot;, &quot;online&quot;, or &quot;tensorized&quot;. The last of these is the offline option.</p>
</td></tr>
<tr><td><code id="barycentric_projection_+3A_diameter">diameter</code></td>
<td>
<p>The diameter of the covariate space, if known.</p>
</td></tr>
<tr><td><code id="barycentric_projection_+3A_niter">niter</code></td>
<td>
<p>The maximum number of iterations to run the optimal transport problems</p>
</td></tr>
<tr><td><code id="barycentric_projection_+3A_tol">tol</code></td>
<td>
<p>The tolerance for convergence of the optimal transport problems</p>
</td></tr>
<tr><td><code id="barycentric_projection_+3A_...">...</code></td>
<td>
<p>Not used at this time.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The barycentric projection uses the dual potentials from the optimal transport distance between the two samples to calculate projections from one sample into another. For example, in the sample of controls, we may wish to know their outcome had they been treated. In general, we then seek to minimize
</p>
<p style="text-align: center;"><code class="reqn">\text{argmin}_{\eta} \sum_{ij} cost(\eta_i, y_j) \pi_{ij} </code>
</p>

<p>where <code class="reqn">\pi_{ij}</code> is the primal solution from the optimal transport problem.
</p>
<p>These values can also be de-biased using the solutions from running an optimal transport problem of one sample against itself. Details are listed in Pooladian et al. (2022) <a href="https://arxiv.org/abs/2202.08919">https://arxiv.org/abs/2202.08919</a>.
</p>


<h3>Value</h3>

<p>An object of class &quot;bp&quot; which is a list with slots:
</p>

<ul>
<li> <p><code>potentials</code> The dual potentials from calculating the optimal transport distance
</p>
</li>
<li> <p><code>penalty</code> The value of the penalty parameter used in calculating the optimal transport distance
</p>
</li>
<li> <p><code>cost_function</code> The cost function used to calculate the distances between units.
</p>
</li>
<li> <p><code>cost_alg</code> A character vector denoting if an <code class="reqn">L_1</code> distance, a squared euclidean distance, or other distance metric was used.
</p>
</li>
<li> <p><code>p</code> The power to which the cost matrix was raised if not using a user supplied cost function.
</p>
</li>
<li> <p><code>debias</code> Whether barycentric projections should be debiased.
</p>
</li>
<li> <p><code>tensorized</code> TRUE/FALSE denoting wether to use offline cost matrices.
</p>
</li>
<li> <p><code>data</code> An object of class <a href="#topic+dataHolder-class">dataHolder</a> with the data used to calculate the optimal transport distance.
</p>
</li>
<li> <p><code>y_a</code> The outcome vector in the first sample.
</p>
</li>
<li> <p><code>y_b</code> The outcome vector in the second sample.
</p>
</li>
<li> <p><code>x_a</code> The covariate matrix in the first sample.
</p>
</li>
<li> <p><code>x_b</code> The covariate matrix in the second sample.
</p>
</li>
<li> <p><code>a</code> The empirical measure in the first sample.
</p>
</li>
<li> <p><code>b</code> The empirical measure in the second sample.
</p>
</li>
<li> <p><code>terms</code> The terms object from the formula.
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>if(torch::torch_is_installed()) {
set.seed(23483)
n &lt;- 2^5
pp &lt;- 6
overlap &lt;- "low"
design &lt;- "A"
estimate &lt;- "ATT"
power &lt;- 2
data &lt;- causalOT::Hainmueller$new(n = n, p = pp,
design = design, overlap = overlap)

data$gen_data()

weights &lt;- causalOT::calc_weight(x = data,
  z = NULL, y = NULL,
  estimand = estimate,
  method = "NNM")
  
 df &lt;- data.frame(y = data$get_y(), z = data$get_z(), data$get_x())
  
 fit &lt;- causalOT::barycentric_projection(y ~ ., data = df, 
    weight = weights,
    separate.samples.on = "z",
    niter = 2)
 inherits(fit, "bp")
 }
</code></pre>

<hr>
<h2 id='calc_weight'>Estimate causal weights</h2><span id='topic+calc_weight'></span>

<h3>Description</h3>

<p>Estimate causal weights
</p>


<h3>Usage</h3>

<pre><code class='language-R'>calc_weight(
  x,
  z,
  estimand = c("ATC", "ATT", "ATE"),
  method = supported_methods(),
  options = NULL,
  weights = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="calc_weight_+3A_x">x</code></td>
<td>
<p>A numeric matrix of covariates. You can also pass an object of class <a href="#topic+dataHolder">dataHolder</a> or <a href="#topic+DataSim">DataSim</a>, which will make argument <code>z</code> not necessary,</p>
</td></tr>
<tr><td><code id="calc_weight_+3A_z">z</code></td>
<td>
<p>A binary treatment indicator.</p>
</td></tr>
<tr><td><code id="calc_weight_+3A_estimand">estimand</code></td>
<td>
<p>The estimand of interest. One of &quot;ATT&quot;,&quot;ATC&quot;, or &quot;ATE&quot;.</p>
</td></tr>
<tr><td><code id="calc_weight_+3A_method">method</code></td>
<td>
<p>The method to estimate the causal weights. Must be one of the methods returned by <code><a href="#topic+supported_methods">supported_methods()</a></code>.</p>
</td></tr>
<tr><td><code id="calc_weight_+3A_options">options</code></td>
<td>
<p>The options for the solver. Specific options depend on the solver you will be using and you can use the solver specific options functions as detailed below..</p>
</td></tr>
<tr><td><code id="calc_weight_+3A_weights">weights</code></td>
<td>
<p>The sample weights. Should be <code>NULL</code> or have a weight for each observation in the data. Normalized to sum to one.</p>
</td></tr>
<tr><td><code id="calc_weight_+3A_...">...</code></td>
<td>
<p>Not used at this time.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>We detail some of the particulars of the function arguments below.
</p>


<h4>Causal Optimal Transport (COT)</h4>

<p>This is the.main method of the package. This method relies on various solvers depending on the particular options chosen. Please see <a href="#topic+cotOptions">cotOptions()</a> for more details.
</p>



<h4>Energy Balancing Weights (EnergyBW)</h4>

<p>This is equivalent to COT with an infinite penalty parameter, <code>options(lambda = Inf)</code>. Uses the same solver and options as COT, <a href="#topic+cotOptions">cotOptions()</a>.
</p>



<h4>Nearest Neighbor Matching with replacement (NNM)</h4>

<p>This is equivalent to COT with a penalty parameter = 0, <code>options(lambda = 0)</code>. Uses the same solver and options as COT, <a href="#topic+cotOptions">cotOptions()</a>.
</p>



<h4>Synthetic Control Method (SCM)</h4>

<p>The SCM method is equivalent to an OT problem from a different angle. See <code><a href="#topic+scmOptions">scmOptions()</a></code>.
</p>



<h4>Entropy Balancing Weights (EntropyBW)</h4>

<p>This method balances chosen functions of the covariates specified in the data argument, <code>x</code>. See <code><a href="#topic+entBWOptions">entBWOptions()</a></code> for more details. Hainmueller (2012).
</p>



<h4>Stable Balancing Weights (SBW)</h4>

<p>Entropy Balancing Weights with a different penalty parameter, proposed by Zuizarreta (2012). See <code><a href="#topic+sbwOptions">sbwOptions()</a></code> for more details
</p>



<h4>Covariate Balancing Propensity Score (CBPS)</h4>

<p>The CBPS method of Imai and Ratkovic. Options argument is passed to the function <a href="CBPS.html#topic+CBPS">CBPS()</a>.
</p>



<h4>Logistic Regression or Probit Regression</h4>

<p>The main methods historically for implementing inverse probability weights. Options are passed directly to the <code>glm</code> function from <code>R</code>.
</p>



<h3>Value</h3>

<p>An object of class <a href="#topic+causalWeights-class">causalWeights</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+estimate_effect">estimate_effect()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(23483)
n &lt;- 2^5
p &lt;- 6
#### get data ####
data &lt;- Hainmueller$new(n = n, p = p)
data$gen_data()
x &lt;- data$get_x()
z &lt;- data$get_z()

if (torch::torch_is_installed()) {
# estimate weights
weights &lt;- calc_weight(x = x,
                                 z = z, 
                                 estimand = "ATE",
                                 method = "COT",
                                 options = list(lambda = 0))
#we can also use the dataSim object directly
weightsDS &lt;- calc_weight(x = data,
                                 z = NULL,
                                 estimand = "ATE",
                                 method = "COT",
                                 options = list(lambda = 0))
all.equal(weights@w0, weightsDS@w0)
all.equal(weights@w1, weightsDS@w1)
}
</code></pre>

<hr>
<h2 id='causalEffect-class'>causalEffect class</h2><span id='topic+causalEffect-class'></span><span id='topic+causalEffect'></span>

<h3>Description</h3>

<p>causalEffect class
</p>
<p>causalEffect constructor function
</p>


<h3>Usage</h3>

<pre><code class='language-R'>causalEffect(data, causalWeights, model.outputs, augment.estimate, call)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="causalEffect-class_+3A_data">data</code></td>
<td>
<p>an object of class <a href="#topic+dataHolder-class">dataHolder</a></p>
</td></tr>
<tr><td><code id="causalEffect-class_+3A_causalweights">causalWeights</code></td>
<td>
<p>an object of class <a href="#topic+causalWeights-class">causalWeights</a></p>
</td></tr>
<tr><td><code id="causalEffect-class_+3A_model.outputs">model.outputs</code></td>
<td>
<p>Outputs of the <a href="#topic+estimate_model">estimate_model()</a> function</p>
</td></tr>
<tr><td><code id="causalEffect-class_+3A_augment.estimate">augment.estimate</code></td>
<td>
<p>Is the estimate to be the augmented (doubly robust) estimator? TRUE/FALSE</p>
</td></tr>
<tr><td><code id="causalEffect-class_+3A_call">call</code></td>
<td>
<p>the call used to calculate the treatment effects</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The variables in slot <code>augmentedData</code> are
</p>

<ul>
<li> <p><code>weights</code>: The <a href="#topic+causalWeights-class">causalWeights</a> targeting the causal estimand.
</p>
</li>
<li> <p><code>y_obs</code>: The vector of the observed outcomes for each observation
</p>
</li>
<li> <p><code>y_0</code>: The outcome under the control condition. Missingness respects the design of the experiment. i.e., <code class="reqn">Y(0) | Z = 1</code> = <code>NA</code>.
</p>
</li>
<li> <p><code>y_hat_0</code>: The conditional mean outcome under the control condition. Estimated from a model.
</p>
</li>
<li> <p><code>y_hat_1</code>: The conditional mean outcome under the treatment condition. Estimated from a model.
</p>
</li>
<li> <p><code>x</code>: The columns denoting the covariates.
</p>
</li>
<li> <p><code>z</code>: The treatment indicator.
</p>
</li></ul>

<p>The slot <code>fit</code> is a list with slots <code>control</code>, <code>treated</code>, and <code>overall_sample</code>. Control and treated will be filled if <code>estimate.separately</code> is TRUE in estimate_effect. <code>overall_sample</code> will be filled if <code>estimate.separately</code> is FALSE.
</p>


<h3>Value</h3>

<p>an object of class <a href="#topic+causalEffect-class">causalEffect</a>
</p>


<h3>Slots</h3>


<dl>
<dt><code>estimate</code></dt><dd><p>The estimated treatment effect.</p>
</dd>
<dt><code>estimand</code></dt><dd><p>The estimand of interest</p>
</dd>
<dt><code>weights</code></dt><dd><p>The weights as an object of class <a href="#topic+causalWeights-class">causalWeights</a></p>
</dd>
<dt><code>augmentedData</code></dt><dd><p>The data as a <code>data.frame</code> with variables <code>weights</code>, <code>y_obs</code>, <code>y_0</code>, <code>y_1</code>, <code>y_hat_0</code>, <code>y_hat_1</code>, <code>x</code>, and <code>z</code>. See details for more info.</p>
</dd>
<dt><code>fit</code></dt><dd><p>The fitted model if present. See details.</p>
</dd>
<dt><code>call</code></dt><dd><p>The call from the <a href="#topic+estimate_effect">estimate_effect()</a> function.</p>
</dd>
</dl>

<hr>
<h2 id='causalWeights-class'>causalWeights class</h2><span id='topic+causalWeights-class'></span>

<h3>Description</h3>

<p>causalWeights class
</p>


<h3>Details</h3>

<p>This object is returned by the <code>calc_weight</code> function in this package. The slots can be accessed as any S4 object. There is no publicly accessible constructor function.
</p>


<h3>Slots</h3>


<dl>
<dt><code>w0</code></dt><dd><p>A slot with the weights for the control group with <code class="reqn">n_0</code> entries. Weights sum to 1.</p>
</dd>
<dt><code>w1</code></dt><dd><p>The weights for the treated group with <code class="reqn">n_1</code> entries. Weights sum to 1.</p>
</dd>
<dt><code>estimand</code></dt><dd><p>A character denoting the estimand targeted by the weights. One of &quot;ATT&quot;,&quot;ATC&quot;, or &quot;ATE&quot;.</p>
</dd>
<dt><code>info</code></dt><dd><p>A slot to store a variety of info for inference. Currently under development.</p>
</dd>
<dt><code>method</code></dt><dd><p>A character denoting the method used to estimate the weights.</p>
</dd>
<dt><code>penalty</code></dt><dd><p>A list or the selected penalty parameters, if relevant.</p>
</dd>
<dt><code>data</code></dt><dd><p>The dataHolder object containing the original data.</p>
</dd>
<dt><code>call</code></dt><dd><p>The call used to construct the weights.</p>
</dd>
</dl>

<hr>
<h2 id='coef.causalEffect'>Extract treatment effect estimate</h2><span id='topic+coef.causalEffect'></span>

<h3>Description</h3>

<p>Extract treatment effect estimate
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'causalEffect'
coef(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="coef.causalEffect_+3A_object">object</code></td>
<td>
<p>An object of class <a href="#topic+causalEffect-class">causalEffect</a></p>
</td></tr>
<tr><td><code id="coef.causalEffect_+3A_...">...</code></td>
<td>
<p>Not used</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A number corresponding to the estimated treatment effect
</p>


<h3>Examples</h3>

<pre><code class='language-R'># set-up data
set.seed(1234)
data &lt;- Hainmueller$new()
data$gen_data()

# calculate quantities
weight &lt;- calc_weight(data, method = "Logistic", estimand = "ATE")
tx_eff &lt;- estimate_effect(causalWeights = weight)

all.equal(coef(tx_eff), c(estimate = tx_eff@estimate))
</code></pre>

<hr>
<h2 id='cot_solve+2CateClass-method'>cot_solve method for ateClass objects</h2><span id='topic+cot_solve+2CateClass-method'></span>

<h3>Description</h3>

<p>cot_solve method for ateClass objects
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'ateClass'
cot_solve(object)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cot_solve+2B2CateClass-method_+3A_object">object</code></td>
<td>
<p>ateClass.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>object of class <a href="#topic+causalWeights-class">causalWeights</a>
</p>

<hr>
<h2 id='cot_solve+2CgridSearch-method'>cot_solve for gridSearch</h2><span id='topic+cot_solve+2CgridSearch-method'></span>

<h3>Description</h3>

<p>cot_solve for gridSearch
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'gridSearch'
cot_solve(object)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cot_solve+2B2CgridSearch-method_+3A_object">object</code></td>
<td>
<p>gridSearch.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>returns object of class <a href="#topic+causalWeights-class">causalWeights</a>
</p>

<hr>
<h2 id='cot_solve+2ClikelihoodMethods-method'>cot_solve method for likelihoodMethods</h2><span id='topic+cot_solve+2ClikelihoodMethods-method'></span>

<h3>Description</h3>

<p>cot_solve method for likelihoodMethods
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'likelihoodMethods'
cot_solve(object)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cot_solve+2B2ClikelihoodMethods-method_+3A_object">object</code></td>
<td>
<p>likelihoodMethods.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>object of class <a href="#topic+causalWeights-class">causalWeights</a>
</p>

<hr>
<h2 id='cotOptions'>Options available for the COT method</h2><span id='topic+cotOptions'></span>

<h3>Description</h3>

<p>Options available for the COT method
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cotOptions(
  lambda = NULL,
  delta = NULL,
  opt.direction = c("dual", "primal"),
  debias = TRUE,
  p = 2,
  cost.function = NULL,
  cost.online = "auto",
  diameter = NULL,
  balance.formula = NULL,
  quick.balance.function = TRUE,
  grid.length = 7L,
  torch.optimizer = torch::optim_rmsprop,
  torch.scheduler = torch::lr_multiplicative,
  niter = 2000,
  nboot = 100L,
  lambda.bootstrap = 0.05,
  tol = 1e-04,
  device = NULL,
  dtype = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cotOptions_+3A_lambda">lambda</code></td>
<td>
<p>The penalty parameter for the entropy penalized optimal transport. Default is NULL. Can be a single number or a set of numbers to try.</p>
</td></tr>
<tr><td><code id="cotOptions_+3A_delta">delta</code></td>
<td>
<p>The bound for balancing functions if they are being used. Only available for biased entropy penalized optimal transport. Can be a single number or a set of numbers to try.</p>
</td></tr>
<tr><td><code id="cotOptions_+3A_opt.direction">opt.direction</code></td>
<td>
<p>Should the optimizer solve the primal or dual problems. Should be one of &quot;dual&quot; or &quot;primal&quot; with a default of &quot;dual&quot; since it is typically faster.</p>
</td></tr>
<tr><td><code id="cotOptions_+3A_debias">debias</code></td>
<td>
<p>Should debiased optimal transport be used? TRUE or FALSE.</p>
</td></tr>
<tr><td><code id="cotOptions_+3A_p">p</code></td>
<td>
<p>The power of the cost function to use for the cost.</p>
</td></tr>
<tr><td><code id="cotOptions_+3A_cost.function">cost.function</code></td>
<td>
<p>A function to calculate the pairwise costs. Should take arguments <code>x1</code>, <code>x2</code>, and <code>p</code>. Default is NULL.</p>
</td></tr>
<tr><td><code id="cotOptions_+3A_cost.online">cost.online</code></td>
<td>
<p>Should an online cost algorithm be used? One of &quot;auto&quot;, &quot;online&quot;, or &quot;tensorized&quot;. &quot;tensorized&quot; is the offline option.</p>
</td></tr>
<tr><td><code id="cotOptions_+3A_diameter">diameter</code></td>
<td>
<p>The diameter of the covariate space, if known. Default is NULL.</p>
</td></tr>
<tr><td><code id="cotOptions_+3A_balance.formula">balance.formula</code></td>
<td>
<p>Formula for the balancing functions.</p>
</td></tr>
<tr><td><code id="cotOptions_+3A_quick.balance.function">quick.balance.function</code></td>
<td>
<p>TRUE or FALSE denoting whether balance function constraints should be selected via a linear program (TRUE) or just checked for feasibility (FALSE). Default is TRUE.</p>
</td></tr>
<tr><td><code id="cotOptions_+3A_grid.length">grid.length</code></td>
<td>
<p>The number of penalty parameters to explore in a grid search if none are provided in arguments <code>lambda</code> or <code>delta</code>.</p>
</td></tr>
<tr><td><code id="cotOptions_+3A_torch.optimizer">torch.optimizer</code></td>
<td>
<p>The torch optimizer to use for methods using debiased entropy penalized optimal transport. If <code>debiased</code> is FALSE or <code>opt.direction</code> is &quot;primal&quot;, will default to <code><a href="torch.html#topic+optim_lbfgs">torch::optim_lbfgs()</a></code>. Otherwise <code><a href="torch.html#topic+optim_rmsprop">torch::optim_rmsprop()</a></code> is used.</p>
</td></tr>
<tr><td><code id="cotOptions_+3A_torch.scheduler">torch.scheduler</code></td>
<td>
<p>The scheduler for the optimizer. Defaults to <code><a href="torch.html#topic+lr_multiplicative">torch::lr_multiplicative()</a></code>.</p>
</td></tr>
<tr><td><code id="cotOptions_+3A_niter">niter</code></td>
<td>
<p>The number of iterations to run the solver</p>
</td></tr>
<tr><td><code id="cotOptions_+3A_nboot">nboot</code></td>
<td>
<p>The number of iterations for the bootstrap to select the final penalty parameters.</p>
</td></tr>
<tr><td><code id="cotOptions_+3A_lambda.bootstrap">lambda.bootstrap</code></td>
<td>
<p>The penalty parameter to use for the bootstrap hyperparameter selection of lambda.</p>
</td></tr>
<tr><td><code id="cotOptions_+3A_tol">tol</code></td>
<td>
<p>The tolerance for convergence</p>
</td></tr>
<tr><td><code id="cotOptions_+3A_device">device</code></td>
<td>
<p>An object of class <code>torch_device</code> denoting which device the data will be located on. Default is NULL which will try to use a gpu if available.</p>
</td></tr>
<tr><td><code id="cotOptions_+3A_dtype">dtype</code></td>
<td>
<p>An object of class <code>torch_dtype</code> that determines data type of the data, i.e. double, float, integer. Default is NULL which will try to select for you.</p>
</td></tr>
<tr><td><code id="cotOptions_+3A_...">...</code></td>
<td>
<p>Arguments passed to the solvers. See details</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of class <code>cotOptions</code> with the following slots
</p>

<ul>
<li> <p><code>lambda</code>The penalty parameter for the optimal transport distance
</p>
</li>
<li> <p><code>delta</code>The constraint for the balancing functions
</p>
</li>
<li> <p><code>opt.direction</code> Whether to solve the primal or dual optimization problems
</p>
</li>
<li> <p><code>debias</code>TRUE or FALSE if debiased optimal transport distances are used
</p>
</li>
<li> <p><code>balance.formula</code> The formula giving how to generate the balancing functions.
</p>
</li>
<li> <p><code>quick.balance.function</code> TRUE or FALSE whether quick balance functions will be run.
</p>
</li>
<li> <p><code>grid.length</code> The number of parameters to check in a grid search of best parameters
</p>
</li>
<li> <p><code>p</code> The power of the cost function
</p>
</li>
<li> <p><code>cost.online</code> Whether online costs are used
</p>
</li>
<li> <p><code>cost.function</code> The user supplied cost function if supplied.
</p>
</li>
<li> <p><code>diameter</code> The diameter of the covariate space.
</p>
</li>
<li> <p><code>torch.optimizer</code> The <code>torch</code> optimizer used for Sinkhorn Divergences
</p>
</li>
<li> <p><code>torch.scheduler</code> The scheduler for the <code>torch</code> optimizer
</p>
</li>
<li> <p><code>solver.options</code> The arguments to be passeed to the <code>torch.optimizer</code>
</p>
</li>
<li> <p><code>scheduler.options</code> The arguments to be passeed to the <code>torch.scheduler</code>
</p>
</li>
<li> <p><code>osqp.options</code> Arguments passed to the <code>osqp</code> function if quick balance functions are used.
</p>
</li>
<li> <p><code>niter</code> The number of iterations to run the solver
</p>
</li>
<li> <p><code>nboot</code> The number of bootstrap samples
</p>
</li>
<li> <p><code>lambda.bootstrap</code> The penalty parameter to use for the bootstrap hyperparameter selection.
</p>
</li>
<li> <p><code>tol</code> The tolerance for convergence.
</p>
</li>
<li> <p><code>device</code> An object of class <code>torch_device</code>.
</p>
</li>
<li> <p><code>dtype</code> An object of class <code>torch_dtype</code>.
</p>
</li></ul>



<h3>Solvers and distances</h3>

<p>The function is setup to direct the COT optimizer to run two basic methods: debiased entropy penalized optimal transport (Sinkhorn Divergences) or entropy penalized optimal transport (Sinkhorn Distances).
</p>


<h4>Sinkhorn Distances</h4>

<p>The optimal transport problem solved is <code class="reqn">min_w OT_\lambda(w,b) </code> where </p>
<p style="text-align: center;"><code class="reqn">OT_\lambda(w,b) = \sum_{ij} C(x_i, x_j) P_{ij} + \lambda \sum_{ij} P_{ij}\log(P_{ij}),</code>
</p>
<p> such that the rows of the matrix <code class="reqn">P_{ij}</code> sum to <code class="reqn">w</code> and the columns sum to <code class="reqn">b</code>. In this case <code class="reqn">C(,)</code> is the cost between units i and j.
</p>



<h4>Sinkhorn Divergences</h4>

<p>The Sinkhorn Divergence solves </p>
<p style="text-align: center;"><code class="reqn">min_w OT_\lambda(w,b) - 0.5 OT_\lambda(w,w) - 0.5 * OT_\lambda(b,b).</code>
</p>
<p> The solver for this function uses the <code>torch</code> package in <code>R</code> and by default will use the <code>optim_rmsprop</code> solver. Your desired <code>torch</code> optimizer can be passed via <code>torch.optimizer</code> with a scheduler passed via <code>torch.scheduler</code>. GPU support is available as detailed in the <code>torch</code> package. Additional arguments in <code>...</code> are passed as extra arguments to the <code>torch</code> optimizer and schedulers as appropriate.
</p>



<h3>Function balancing</h3>

<p>There may be certain functions of the covariates that we wish to balance within some tolerance, <code class="reqn">\delta</code>. For these functions <code class="reqn">B</code>, we will desire
</p>
<p style="text-align: center;"><code class="reqn">\frac{\sum_{i: Z_i = 0} w_i B(x_i) - \sum_{j: Z_j = 1} B(x_j)/n_1}{\sigma} \leq \delta</code>
</p>
<p>, where in this case we are targeting balance with the treatment group for the ATT. <code class="reqn">\sigma</code> is the pooled standard deviation prior to balancing.
</p>


<h3>Cost functions</h3>

<p>The cost function specifies pairwise distances. If argument <code>cost.function</code> is NULL, the function will default to using <code class="reqn">L_p^p</code> distances with a default <code class="reqn">p = 2</code> supplied by the argument <code>p</code>. So for <code>p = 2</code>, the cost between units <code class="reqn">x_i</code> and <code class="reqn">x_j</code> will be </p>
<p style="text-align: center;"><code class="reqn">C(x_i, x_j) = \frac{1}{2} \| x_i - x_j \|_2^2.</code>
</p>

<p>If <code>cost.function</code> is provided, it should be a function that takes arguments <code>x1</code>, <code>x2</code>, and <code>p</code>: <code>function(x1, x2, p){...}</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if ( torch::torch_is_installed()) {
opts1 &lt;- cotOptions(lambda = 1e3, torch.optimizer = torch::optim_rmsprop)
opts2 &lt;- cotOptions(lambda = NULL)
opts3 &lt;- cotOptions(lambda = seq(0.1, 100, length.out = 7))
}
</code></pre>

<hr>
<h2 id='CRASH3'>CRASH3 data example</h2><span id='topic+CRASH3'></span>

<h3>Description</h3>

<p>CRASH3 data example
</p>
<p>CRASH3 data example
</p>


<h3>Details</h3>

<p>Returns the CRASH3 data. Note that <code>gen_data()</code> will initialize the fixed data for x and y, but z is generated from Binom(0.5).
</p>


<h3>Value</h3>

<p>An <a href="R6.html#topic+R6Class">R6</a> object of class <a href="#topic+DataSim">DataSim</a>
</p>


<h3>Super class</h3>

<p><code><a href="#topic+DataSim">causalOT::DataSim</a></code> -&gt; <code>CRASH3</code>
</p>


<h3>Public fields</h3>

<div class="r6-fields">

<dl>
<dt><code>site_id</code></dt><dd><p>The site of the observation in terms of the original RCT.</p>
</dd>
</dl>

</div>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-CRASH3-gen_data"><code>CRASH3$gen_data()</code></a>
</p>
</li>
<li> <p><a href="#method-CRASH3-gen_x"><code>CRASH3$gen_x()</code></a>
</p>
</li>
<li> <p><a href="#method-CRASH3-gen_y"><code>CRASH3$gen_y()</code></a>
</p>
</li>
<li> <p><a href="#method-CRASH3-gen_z"><code>CRASH3$gen_z()</code></a>
</p>
</li>
<li> <p><a href="#method-CRASH3-new"><code>CRASH3$new()</code></a>
</p>
</li>
<li> <p><a href="#method-CRASH3-clone"><code>CRASH3$clone()</code></a>
</p>
</li></ul>



<details><summary>Inherited methods</summary>
<ul>
<li><span class="pkg-link" data-pkg="causalOT" data-topic="DataSim" data-id="get_n"><a href='../../causalOT/html/DataSim.html#method-DataSim-get_n'><code>causalOT::DataSim$get_n()</code></a></span></li>
<li><span class="pkg-link" data-pkg="causalOT" data-topic="DataSim" data-id="get_p"><a href='../../causalOT/html/DataSim.html#method-DataSim-get_p'><code>causalOT::DataSim$get_p()</code></a></span></li>
<li><span class="pkg-link" data-pkg="causalOT" data-topic="DataSim" data-id="get_tau"><a href='../../causalOT/html/DataSim.html#method-DataSim-get_tau'><code>causalOT::DataSim$get_tau()</code></a></span></li>
<li><span class="pkg-link" data-pkg="causalOT" data-topic="DataSim" data-id="get_x"><a href='../../causalOT/html/DataSim.html#method-DataSim-get_x'><code>causalOT::DataSim$get_x()</code></a></span></li>
<li><span class="pkg-link" data-pkg="causalOT" data-topic="DataSim" data-id="get_x0"><a href='../../causalOT/html/DataSim.html#method-DataSim-get_x0'><code>causalOT::DataSim$get_x0()</code></a></span></li>
<li><span class="pkg-link" data-pkg="causalOT" data-topic="DataSim" data-id="get_x1"><a href='../../causalOT/html/DataSim.html#method-DataSim-get_x1'><code>causalOT::DataSim$get_x1()</code></a></span></li>
<li><span class="pkg-link" data-pkg="causalOT" data-topic="DataSim" data-id="get_y"><a href='../../causalOT/html/DataSim.html#method-DataSim-get_y'><code>causalOT::DataSim$get_y()</code></a></span></li>
<li><span class="pkg-link" data-pkg="causalOT" data-topic="DataSim" data-id="get_z"><a href='../../causalOT/html/DataSim.html#method-DataSim-get_z'><code>causalOT::DataSim$get_z()</code></a></span></li>
</ul>
</details>

<hr>
<a id="method-CRASH3-gen_data"></a>



<h4>Method <code>gen_data()</code></h4>

<p>The site ID for the observations
</p>
<p>Draws new treatment indicators. x and y data are fixed.
</p>


<h5>Usage</h5>

<div class="r"><pre>CRASH3$gen_data()</pre></div>


<hr>
<a id="method-CRASH3-gen_x"></a>



<h4>Method <code>gen_x()</code></h4>

<p>Sets up the covariate data. This data is fixed.
</p>


<h5>Usage</h5>

<div class="r"><pre>CRASH3$gen_x()</pre></div>


<hr>
<a id="method-CRASH3-gen_y"></a>



<h4>Method <code>gen_y()</code></h4>

<p>Sets up the outcome data. This data is fixed.
</p>


<h5>Usage</h5>

<div class="r"><pre>CRASH3$gen_y()</pre></div>


<hr>
<a id="method-CRASH3-gen_z"></a>



<h4>Method <code>gen_z()</code></h4>

<p>Sets up the treatment indicator. Drawn as Z ~ Binom(0.5)
</p>


<h5>Usage</h5>

<div class="r"><pre>CRASH3$gen_z()</pre></div>


<hr>
<a id="method-CRASH3-new"></a>



<h4>Method <code>new()</code></h4>

<p>Initializes the CRASH3 object.
</p>


<h5>Usage</h5>

<div class="r"><pre>CRASH3$new(n = NULL, p = NULL, param = list(), design = NA_character_, ...)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>n</code></dt><dd><p>Not used.
Maintained for symmetry with other
DataSim objects.</p>
</dd>
<dt><code>p</code></dt><dd><p>Not used.
Maintained for symmetry with other
DataSim objects.</p>
</dd>
<dt><code>param</code></dt><dd><p>Not used.
Maintained for symmetry with other
DataSim objects.</p>
</dd>
<dt><code>design</code></dt><dd><p>Not used</p>
</dd>
<dt><code>...</code></dt><dd><p>Not used.</p>
</dd>
</dl>

</div>



<h5>Examples</h5>

<div class="r example copy">
<pre>crash &lt;- CRASH3$new()
crash$gen_data()
crash$get_n()
crash$site_id
</pre>
</div>


<hr>
<a id="method-CRASH3-clone"></a>



<h4>Method <code>clone()</code></h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>CRASH3$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt><dd><p>Whether to make a deep clone.</p>
</dd>
</dl>

</div>




<h3>Examples</h3>

<pre><code class='language-R'>
## ------------------------------------------------
## Method `CRASH3$new`
## ------------------------------------------------

crash &lt;- CRASH3$new()
crash$gen_data()
crash$get_n()
crash$site_id
</code></pre>

<hr>
<h2 id='data_separate.dataHolder'>Title</h2><span id='topic+data_separate.dataHolder'></span>

<h3>Description</h3>

<p>Title
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'dataHolder'
data_separate(data, estimand)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="data_separate.dataHolder_+3A_data">data</code></td>
<td>
<p>dataHolder.</p>
</td></tr>
<tr><td><code id="data_separate.dataHolder_+3A_estimand">estimand</code></td>
<td>
<p>character.</p>
</td></tr>
</table>

<hr>
<h2 id='dataHolder'>dataHolder</h2><span id='topic+dataHolder'></span>

<h3>Description</h3>

<p>dataHolder
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dataHolder(x, z, y = NA_real_, weights = NA_real_)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dataHolder_+3A_x">x</code></td>
<td>
<p>the covariate data. Can be a matrix, an object of class <code>dataHolder</code> or a <a href="#topic+DataSim">DataSim</a> object. The latter two object types won't need arguments <code>z</code> or <code>y</code>.</p>
</td></tr>
<tr><td><code id="dataHolder_+3A_z">z</code></td>
<td>
<p>the treatment indicator</p>
</td></tr>
<tr><td><code id="dataHolder_+3A_y">y</code></td>
<td>
<p>the outcome data</p>
</td></tr>
<tr><td><code id="dataHolder_+3A_weights">weights</code></td>
<td>
<p>the empirical distribution of the sample</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Creates an object used internally by the <code>causalOT</code> package for data management.
</p>


<h3>Value</h3>

<p>Returns an object of class dataHolder with slots
</p>

<ul>
<li> <p><code>x</code> matrix. A matrix of confounders.
</p>
</li>
<li> <p><code>z</code> integer. The treatment indicator, <code class="reqn">z_i \in \{0,1\}</code>.
</p>
</li>
<li> <p><code>y</code> numeric. The outcome data.
</p>
</li>
<li> <p><code>n0</code> integer. The number of observations where z==0
</p>
</li>
<li> <p><code>n1</code> integer. The number of observations where z==1
</p>
</li>
<li> <p><code>weights</code> numeric. The empirical distribution of the full sample.
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- matrix(0, 100, 10)
z &lt;- stats::rbinom(100, 1, 0.5)

# don't need to provide outcome
# function will assume each observation gets equal mass
dataHolder(x = x, z = z) 
</code></pre>

<hr>
<h2 id='dataHolder-class'>dataHolder-class</h2><span id='topic+dataHolder-class'></span>

<h3>Description</h3>

<p>dataHolder-class
</p>


<h3>Slots</h3>


<dl>
<dt><code>x</code></dt><dd><p>matrix. A matrix of confounders.</p>
</dd>
<dt><code>z</code></dt><dd><p>integer. The treatment indicator, <code class="reqn">z_i \in \{0,1\}</code>.</p>
</dd>
<dt><code>y</code></dt><dd><p>numeric. The outcome data.</p>
</dd>
<dt><code>n0</code></dt><dd><p>integer. The number of observations where z==0</p>
</dd>
<dt><code>n1</code></dt><dd><p>integer. The number of observations where z==1</p>
</dd>
<dt><code>weights</code></dt><dd><p>numeric. The empirical distribution of the full sample.</p>
</dd>
</dl>

<hr>
<h2 id='dataHolder+2CdataHolder-method'>dataHolder-methods</h2><span id='topic+dataHolder+2CdataHolder-method'></span><span id='topic+dataHolder+2Cmatrix-method'></span><span id='topic+dataHolder.DataSim'></span><span id='topic+dataHolder+2CANY-method'></span><span id='topic+terms.dataHolder'></span>

<h3>Description</h3>

<p>dataHolder-methods
</p>
<p>dataHolder-methods
</p>
<p>dataHolder-methods
</p>
<p>dataHolder-methods
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'dataHolder'
dataHolder(x, z = NA_integer_, y = NA_real_)

## S4 method for signature 'matrix'
dataHolder(x, z, y = NA_real_, weights = NA_real_)

dataHolder.DataSim(x, z, y = NA_real_, weights = NA_real_)

## S4 method for signature 'ANY'
dataHolder(x, z = NA_integer_, y = NA_real_, weights = NA_real_)

## S3 method for class 'dataHolder'
terms(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dataHolder+2B2CdataHolder-method_+3A_x">x</code></td>
<td>
<p>dataHolder object constructed from a formula</p>
</td></tr>
<tr><td><code id="dataHolder+2B2CdataHolder-method_+3A_...">...</code></td>
<td>
<p>Not used at this time</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list with the formula terms for treatment and, if present, outcome formulae.
</p>

<hr>
<h2 id='DataSim'>R6 Data Generating Parent Class</h2><span id='topic+DataSim'></span>

<h3>Description</h3>

<p>R6 Data Generating Parent Class
</p>
<p>R6 Data Generating Parent Class
</p>


<h3>Details</h3>

<p>Can be used to make your own data simulation class.
Should have the same slots listed in this class at a minimum,
but you can add your own, of course. An easy way to do this is
to make your class inherit from this one. See the example.
</p>


<h3>Value</h3>

<p>An <a href="R6.html#topic+R6Class">R6</a> object
</p>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-DataSim-get_x"><code>DataSim$get_x()</code></a>
</p>
</li>
<li> <p><a href="#method-DataSim-get_y"><code>DataSim$get_y()</code></a>
</p>
</li>
<li> <p><a href="#method-DataSim-get_z"><code>DataSim$get_z()</code></a>
</p>
</li>
<li> <p><a href="#method-DataSim-get_n"><code>DataSim$get_n()</code></a>
</p>
</li>
<li> <p><a href="#method-DataSim-get_x1"><code>DataSim$get_x1()</code></a>
</p>
</li>
<li> <p><a href="#method-DataSim-get_x0"><code>DataSim$get_x0()</code></a>
</p>
</li>
<li> <p><a href="#method-DataSim-get_p"><code>DataSim$get_p()</code></a>
</p>
</li>
<li> <p><a href="#method-DataSim-get_tau"><code>DataSim$get_tau()</code></a>
</p>
</li>
<li> <p><a href="#method-DataSim-gen_data"><code>DataSim$gen_data()</code></a>
</p>
</li>
<li> <p><a href="#method-DataSim-clone"><code>DataSim$clone()</code></a>
</p>
</li></ul>


<hr>
<a id="method-DataSim-get_x"></a>



<h4>Method <code>get_x()</code></h4>

<p>Gets the covariate data
</p>


<h5>Usage</h5>

<div class="r"><pre>DataSim$get_x()</pre></div>


<hr>
<a id="method-DataSim-get_y"></a>



<h4>Method <code>get_y()</code></h4>

<p>Gets the outcome vector
</p>


<h5>Usage</h5>

<div class="r"><pre>DataSim$get_y()</pre></div>


<hr>
<a id="method-DataSim-get_z"></a>



<h4>Method <code>get_z()</code></h4>

<p>Gets the treatment indicator
</p>


<h5>Usage</h5>

<div class="r"><pre>DataSim$get_z()</pre></div>


<hr>
<a id="method-DataSim-get_n"></a>



<h4>Method <code>get_n()</code></h4>

<p>Gets the number of observations
</p>


<h5>Usage</h5>

<div class="r"><pre>DataSim$get_n()</pre></div>


<hr>
<a id="method-DataSim-get_x1"></a>



<h4>Method <code>get_x1()</code></h4>

<p>Gets the covariate data for the treated individuals
</p>


<h5>Usage</h5>

<div class="r"><pre>DataSim$get_x1()</pre></div>


<hr>
<a id="method-DataSim-get_x0"></a>



<h4>Method <code>get_x0()</code></h4>

<p>Gets the covaraiate data for the control individuals
</p>


<h5>Usage</h5>

<div class="r"><pre>DataSim$get_x0()</pre></div>


<hr>
<a id="method-DataSim-get_p"></a>



<h4>Method <code>get_p()</code></h4>

<p>Gets the dimensionality covariate data
</p>


<h5>Usage</h5>

<div class="r"><pre>DataSim$get_p()</pre></div>


<hr>
<a id="method-DataSim-get_tau"></a>



<h4>Method <code>get_tau()</code></h4>

<p>Gets the individual treatment effects
</p>


<h5>Usage</h5>

<div class="r"><pre>DataSim$get_tau()</pre></div>


<hr>
<a id="method-DataSim-gen_data"></a>



<h4>Method <code>gen_data()</code></h4>

<p>Generates the  data. Default is an empty function
</p>


<h5>Usage</h5>

<div class="r"><pre>DataSim$gen_data()</pre></div>


<hr>
<a id="method-DataSim-clone"></a>



<h4>Method <code>clone()</code></h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>DataSim$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt><dd><p>Whether to make a deep clone.</p>
</dd>
</dl>

</div>




<h3>Examples</h3>

<pre><code class='language-R'>MyClass &lt;- R6::R6Class("MyClass", 
inherit = DataSim,
public = list(),
private = list())
</code></pre>

<hr>
<h2 id='df2dataHolder'>df2dataHolder</h2><span id='topic+df2dataHolder'></span>

<h3>Description</h3>

<p>Function to turn a data.frame into a dataHolder object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>df2dataHolder(
  treatment.formula,
  outcome.formula = NA_character_,
  data,
  weights = NA_real_
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="df2dataHolder_+3A_treatment.formula">treatment.formula</code></td>
<td>
<p>a formula specifying the treatment indicator and covariates. Required.</p>
</td></tr>
<tr><td><code id="df2dataHolder_+3A_outcome.formula">outcome.formula</code></td>
<td>
<p>an optional formula specifying the outcome function.</p>
</td></tr>
<tr><td><code id="df2dataHolder_+3A_data">data</code></td>
<td>
<p>a data.frame with the data</p>
</td></tr>
<tr><td><code id="df2dataHolder_+3A_weights">weights</code></td>
<td>
<p>optional vector of sampling weights for the data</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This will take the formulas specified and transform that data.frame into a dataHolder object that is used internally by the causalOT package. Take care if you do not specify an outcome formula that you do not include the outcome in the data.frame. If you are not careful, the function may include the outcome as a covariate, which is not kosher in causal inference during the design phase.
</p>
<p>If both outcome.formula and treatment.formula are specified, it will assume you are in the design phase, and create a combined covariate matrix to balance on the assumed treatment and outcome models.
</p>
<p>If you are in the outcome phase of estimation, you can just provide a dummy formula for the treatment.formula like &quot;z ~ 0&quot; just so the function can identify the treatment indicator appropriately in the data creation phase.
</p>


<h3>Value</h3>

<p>Returns an object of class <code><a href="#topic+dataHolder">dataHolder()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
set.seed(20348)
n &lt;- 15
d &lt;- 3
x &lt;- matrix(stats::rnorm(n*d), n, d)
z &lt;- rbinom(n, 1, prob = 0.5)
y &lt;- rnorm(n)
weights &lt;- rep(1/n,n)
df &lt;- data.frame(x, z, y)
dh &lt;- df2dataHolder(
  treatment.formula = "z ~ .",
  outcome.formula = "y ~ ." ,
  data = df,
  weights = weights)
</code></pre>

<hr>
<h2 id='df2dataHolder+2CANY+2CANY+2Cdata.frame-method'>df2dataHolder-methods</h2><span id='topic+df2dataHolder+2CANY+2CANY+2Cdata.frame-method'></span>

<h3>Description</h3>

<p>df2dataHolder-methods
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'ANY,ANY,data.frame'
df2dataHolder(
  treatment.formula = NA_character_,
  outcome.formula = NA_character_,
  data,
  weights = NA_real_
)
</code></pre>

<hr>
<h2 id='entBWOptions'>Options for the Entropy Balancing Weights</h2><span id='topic+entBWOptions'></span>

<h3>Description</h3>

<p>Options for the Entropy Balancing Weights
</p>


<h3>Usage</h3>

<pre><code class='language-R'>entBWOptions(delta = NULL, grid.length = 20L, nboot = 1000L, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="entBWOptions_+3A_delta">delta</code></td>
<td>
<p>A number or vector of tolerances for the balancing functions. Default is NULL which will use a grid search</p>
</td></tr>
<tr><td><code id="entBWOptions_+3A_grid.length">grid.length</code></td>
<td>
<p>The number of values to try in the grid search</p>
</td></tr>
<tr><td><code id="entBWOptions_+3A_nboot">nboot</code></td>
<td>
<p>The number of bootstrap samples to run during the grid search.</p>
</td></tr>
<tr><td><code id="entBWOptions_+3A_...">...</code></td>
<td>
<p>Arguments passed on to <a href="lbfgsb3c.html#topic+lbfgsb3c">lbfgsb3c()</a></p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of class <code>entBWOptions</code> with slots
</p>

<ul>
<li> <p><code>delta</code> Delta values to try
</p>
</li>
<li> <p><code>grid.length</code> The number of parameters to try
</p>
</li>
<li> <p><code>nboot</code> Number of bootstrap samples
</p>
</li>
<li> <p><code>solver.options</code> A list of options passed to '<a href="lbfgsb3c.html#topic+lbfgsb3c">lbfgsb3c()</a>
</p>
</li></ul>



<h3>Function balancing</h3>

<p>This method will balance  functions of the covariates within some tolerance, <code class="reqn">\delta</code>. For these functions <code class="reqn">B</code>, we will desire
</p>
<p style="text-align: center;"><code class="reqn">\frac{\sum_{i: Z_i = 0} w_i B(x_i) - \sum_{j: Z_j = 1} B(x_j)/n_1}{\sigma} \leq \delta</code>
</p>
<p>, where in this case we are targeting balance with the treatment group for the ATT. <code class="reqn">\sigma</code> is the pooled standard deviation prior to balancing.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>opts &lt;- entBWOptions(delta = 0.1)
</code></pre>

<hr>
<h2 id='ESS'>Effective Sample Size</h2><span id='topic+ESS'></span><span id='topic+ESS+2Cnumeric-method'></span><span id='topic+ESS+2CcausalWeights-method'></span>

<h3>Description</h3>

<p>Effective Sample Size
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ESS(x)

## S4 method for signature 'numeric'
ESS(x)

## S4 method for signature 'causalWeights'
ESS(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ESS_+3A_x">x</code></td>
<td>
<p>Either a vector of weights summing to 1 or an object of class
<a href="#topic+causalWeights-class">causalWeights</a></p>
</td></tr>
</table>


<h3>Details</h3>

<p>Calculates the effective sample size as described by Kish (1965).
However, this calculation has some problems and the <code><a href="#topic+PSIS">PSIS()</a></code>
function should be used instead.
</p>


<h3>Value</h3>

<p>Either a number denoting the effective sample size or if <code>x</code> is of class
<a href="#topic+causalWeights-class">causalWeights</a>, then returns a list of both values in the treatment
and control groups.
</p>


<h3>Methods (by class)</h3>


<ul>
<li> <p><code>ESS(numeric)</code>: default ESS method for numeric vectors
</p>
</li>
<li> <p><code>ESS(causalWeights)</code>: ESS method for objects of class <a href="#topic+causalWeights-class">causalWeights</a>
</p>
</li></ul>


<h3>See Also</h3>

<p><a href="#topic+PSIS">PSIS()</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- rep(1/100,100)
ESS(x)
</code></pre>

<hr>
<h2 id='estimate_effect'>Estimate treatment effects</h2><span id='topic+estimate_effect'></span>

<h3>Description</h3>

<p>Estimate treatment effects
</p>


<h3>Usage</h3>

<pre><code class='language-R'>estimate_effect(
  causalWeights,
  x = NULL,
  y = NULL,
  model.function,
  estimate.separately = TRUE,
  augment.estimate = FALSE,
  normalize.weights = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="estimate_effect_+3A_causalweights">causalWeights</code></td>
<td>
<p>An object of class <a href="#topic+causalWeights-class">causalWeights</a></p>
</td></tr>
<tr><td><code id="estimate_effect_+3A_x">x</code></td>
<td>
<p>A dataHolder, matrix, data.frame, or object of class DataSim. See <a href="#topic+calc_weight">calc_weight</a> for more details how to input the data. If <code>NULL</code>, will use the info in the <code>causalWeights</code> argument.</p>
</td></tr>
<tr><td><code id="estimate_effect_+3A_y">y</code></td>
<td>
<p>The outcome vector.</p>
</td></tr>
<tr><td><code id="estimate_effect_+3A_model.function">model.function</code></td>
<td>
<p>The modeling function to use, if desired. Must take arguments &quot;formula&quot;, &quot;data&quot;, and &quot;weights&quot;. Other arguments passed via <code>...</code>, the dots.</p>
</td></tr>
<tr><td><code id="estimate_effect_+3A_estimate.separately">estimate.separately</code></td>
<td>
<p>Should the outcome model be estimated separately in each treatment group? TRUE or FALSE.</p>
</td></tr>
<tr><td><code id="estimate_effect_+3A_augment.estimate">augment.estimate</code></td>
<td>
<p>Should an augmented, doubly robust estimator be used?</p>
</td></tr>
<tr><td><code id="estimate_effect_+3A_normalize.weights">normalize.weights</code></td>
<td>
<p>Should the weights in the <code>causalWeights</code> argument be normalized to sum to one prior to effect estimation?</p>
</td></tr>
<tr><td><code id="estimate_effect_+3A_...">...</code></td>
<td>
<p>Pass additional arguments to the outcome modeling functions.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an object of class <a href="#topic+causalEffect-class">causalEffect</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if ( torch::torch_is_installed() ){
# set-up data
data &lt;- Hainmueller$new()
data$gen_data()

# calculate quantities
weight &lt;- calc_weight(data, method = "COT", 
                      estimand = "ATT",
                      options = list(lambda = 0))
tx_eff &lt;- estimate_effect(causalWeights = weight)

# get estimate
print(tx_eff@estimate)
all.equal(coef(tx_eff), c(estimate = tx_eff@estimate))
}
</code></pre>

<hr>
<h2 id='estimate_model'>Function to estimate outcome models</h2><span id='topic+estimate_model'></span>

<h3>Description</h3>

<p>Function to estimate outcome models
</p>


<h3>Usage</h3>

<pre><code class='language-R'>estimate_model(data, causalWeights, model.function, separate.estimation, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="estimate_model_+3A_data">data</code></td>
<td>
<p>A <code><a href="#topic+dataHolder">dataHolder()</a></code> object</p>
</td></tr>
<tr><td><code id="estimate_model_+3A_causalweights">causalWeights</code></td>
<td>
<p>A <a href="#topic+causalWeights-class">causalWeights</a> object</p>
</td></tr>
<tr><td><code id="estimate_model_+3A_model.function">model.function</code></td>
<td>
<p>The model function passed by the user</p>
</td></tr>
<tr><td><code id="estimate_model_+3A_separate.estimation">separate.estimation</code></td>
<td>
<p>TRUE or FALSE, should models be estimated separately in each group?</p>
</td></tr>
<tr><td><code id="estimate_model_+3A_...">...</code></td>
<td>
<p>Extra agruments passed to the predict functions</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list with slots <code>y_hat_0</code>, <code>y_hat_1</code>, and <code>fit</code>.
</p>

<hr>
<h2 id='gridSearch-class'>gridSearch S4 class</h2><span id='topic+gridSearch-class'></span>

<h3>Description</h3>

<p>gridSearch S4 class
</p>


<h3>Slots</h3>


<dl>
<dt><code>penalty_list</code></dt><dd><p>numeric.</p>
</dd>
<dt><code>nboot</code></dt><dd><p>integer.</p>
</dd>
<dt><code>solver</code></dt><dd><p>R6.</p>
</dd>
<dt><code>method</code></dt><dd><p>character.</p>
</dd>
<dt><code>estimand</code></dt><dd><p>character.</p>
</dd>
</dl>

<hr>
<h2 id='Hainmueller'>Hainmueller data example</h2><span id='topic+Hainmueller'></span>

<h3>Description</h3>

<p>Hainmueller data example
</p>
<p>Hainmueller data example
</p>


<h3>Details</h3>

<p>Generates the data as described in Hainmueller (2012).
</p>


<h3>Value</h3>

<p>An <a href="R6.html#topic+R6Class">R6</a> object of class <a href="#topic+DataSim">DataSim</a>
</p>


<h3>Super class</h3>

<p><code><a href="#topic+DataSim">causalOT::DataSim</a></code> -&gt; <code>Hainmueller</code>
</p>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-Hainmueller-gen_data"><code>Hainmueller$gen_data()</code></a>
</p>
</li>
<li> <p><a href="#method-Hainmueller-gen_x"><code>Hainmueller$gen_x()</code></a>
</p>
</li>
<li> <p><a href="#method-Hainmueller-gen_y"><code>Hainmueller$gen_y()</code></a>
</p>
</li>
<li> <p><a href="#method-Hainmueller-gen_z"><code>Hainmueller$gen_z()</code></a>
</p>
</li>
<li> <p><a href="#method-Hainmueller-new"><code>Hainmueller$new()</code></a>
</p>
</li>
<li> <p><a href="#method-Hainmueller-get_design"><code>Hainmueller$get_design()</code></a>
</p>
</li>
<li> <p><a href="#method-Hainmueller-get_pscore"><code>Hainmueller$get_pscore()</code></a>
</p>
</li>
<li> <p><a href="#method-Hainmueller-clone"><code>Hainmueller$clone()</code></a>
</p>
</li></ul>



<details><summary>Inherited methods</summary>
<ul>
<li><span class="pkg-link" data-pkg="causalOT" data-topic="DataSim" data-id="get_n"><a href='../../causalOT/html/DataSim.html#method-DataSim-get_n'><code>causalOT::DataSim$get_n()</code></a></span></li>
<li><span class="pkg-link" data-pkg="causalOT" data-topic="DataSim" data-id="get_p"><a href='../../causalOT/html/DataSim.html#method-DataSim-get_p'><code>causalOT::DataSim$get_p()</code></a></span></li>
<li><span class="pkg-link" data-pkg="causalOT" data-topic="DataSim" data-id="get_tau"><a href='../../causalOT/html/DataSim.html#method-DataSim-get_tau'><code>causalOT::DataSim$get_tau()</code></a></span></li>
<li><span class="pkg-link" data-pkg="causalOT" data-topic="DataSim" data-id="get_x"><a href='../../causalOT/html/DataSim.html#method-DataSim-get_x'><code>causalOT::DataSim$get_x()</code></a></span></li>
<li><span class="pkg-link" data-pkg="causalOT" data-topic="DataSim" data-id="get_x0"><a href='../../causalOT/html/DataSim.html#method-DataSim-get_x0'><code>causalOT::DataSim$get_x0()</code></a></span></li>
<li><span class="pkg-link" data-pkg="causalOT" data-topic="DataSim" data-id="get_x1"><a href='../../causalOT/html/DataSim.html#method-DataSim-get_x1'><code>causalOT::DataSim$get_x1()</code></a></span></li>
<li><span class="pkg-link" data-pkg="causalOT" data-topic="DataSim" data-id="get_y"><a href='../../causalOT/html/DataSim.html#method-DataSim-get_y'><code>causalOT::DataSim$get_y()</code></a></span></li>
<li><span class="pkg-link" data-pkg="causalOT" data-topic="DataSim" data-id="get_z"><a href='../../causalOT/html/DataSim.html#method-DataSim-get_z'><code>causalOT::DataSim$get_z()</code></a></span></li>
</ul>
</details>

<hr>
<a id="method-Hainmueller-gen_data"></a>



<h4>Method <code>gen_data()</code></h4>

<p>Generates the data
</p>


<h5>Usage</h5>

<div class="r"><pre>Hainmueller$gen_data()</pre></div>


<hr>
<a id="method-Hainmueller-gen_x"></a>



<h4>Method <code>gen_x()</code></h4>

<p>Generates the covaraiate data
</p>


<h5>Usage</h5>

<div class="r"><pre>Hainmueller$gen_x()</pre></div>


<hr>
<a id="method-Hainmueller-gen_y"></a>



<h4>Method <code>gen_y()</code></h4>

<p>Generates the outcome data
</p>


<h5>Usage</h5>

<div class="r"><pre>Hainmueller$gen_y()</pre></div>


<hr>
<a id="method-Hainmueller-gen_z"></a>



<h4>Method <code>gen_z()</code></h4>

<p>Generates the treatment indicator
</p>


<h5>Usage</h5>

<div class="r"><pre>Hainmueller$gen_z()</pre></div>


<hr>
<a id="method-Hainmueller-new"></a>



<h4>Method <code>new()</code></h4>

<p>Generates the the Hainmueller <code>R6</code> class
</p>


<h5>Usage</h5>

<div class="r"><pre>Hainmueller$new(
  n = 100,
  p = 6,
  param = list(),
  design = "A",
  overlap = "low",
  ...
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>n</code></dt><dd><p>The number of observations</p>
</dd>
<dt><code>p</code></dt><dd><p>The dimensions of the covariates.
Fixed to 6.</p>
</dd>
<dt><code>param</code></dt><dd><p>The data generating parameters
fed as a list.</p>
</dd>
<dt><code>design</code></dt><dd><p>One of &quot;A&quot; or &quot;B&quot;. See details.</p>
</dd>
<dt><code>overlap</code></dt><dd><p>One of &quot;high&quot;, &quot;low&quot;, or &quot;medium&quot;.
See details.</p>
</dd>
<dt><code>...</code></dt><dd><p>Extra arguments. Currently unused.</p>
</dd>
</dl>

</div>



<h5>Details</h5>



<h6>Design</h6>

<p>Design &quot;A&quot;
is the setting where the outcome is generated
from a linear model,
<code class="reqn">Y(0) = Y(1) = X_1 + X_2 + X_3 - X_4 + X_5 + X_6 + \eta</code>
and design &quot;B&quot; is where the outcome is
generated from the non-linear model
<code class="reqn">Y(0) = Y(1) = (X_1 + X_2 +X_5 )^2 + \eta</code>.
</p>



<h6>Overlap</h6>

<p>The treatment indicator is generated from
<code class="reqn">Z = 1(X_1 + 2 X_2 - 2 X_3 - X_4 - 0.5 X_5 + X_6 + \nu &gt; 0)</code>, where <code class="reqn">\nu</code>
depends on the overlap selected. If overlap is &quot;high&quot;,
then <code class="reqn">\nu \sim N(0, 100).</code> If overlap is
&quot;low&quot;, then <code class="reqn">\nu \sim N(0, 30).</code> Finally,
if overlap is &quot;medium&quot;, then <code class="reqn">\nu</code> is drawn
from a <code class="reqn">\chi^2</code> with 5 degrees of freedom
that is scaled and centered to have mean 0.5 and
variance 67.6.
</p>




<h5>Returns</h5>

<p>An object of class <a href="#topic+DataSim">DataSim</a>.
</p>



<h5>Examples</h5>

<div class="r example copy">
<pre>data &lt;- Hainmueller$new(n = 100, p = 6, design = "A", overlap = "low")
data$gen_data()
print(data$get_x()[1:2,])
</pre>
</div>


<hr>
<a id="method-Hainmueller-get_design"></a>



<h4>Method <code>get_design()</code></h4>

<p>Returns the chosen design parameters
</p>


<h5>Usage</h5>

<div class="r"><pre>Hainmueller$get_design()</pre></div>


<hr>
<a id="method-Hainmueller-get_pscore"></a>



<h4>Method <code>get_pscore()</code></h4>

<p>Returns the true propensity score
</p>


<h5>Usage</h5>

<div class="r"><pre>Hainmueller$get_pscore()</pre></div>


<hr>
<a id="method-Hainmueller-clone"></a>



<h4>Method <code>clone()</code></h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>Hainmueller$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt><dd><p>Whether to make a deep clone.</p>
</dd>
</dl>

</div>




<h3>Examples</h3>

<pre><code class='language-R'>
## ------------------------------------------------
## Method `Hainmueller$new`
## ------------------------------------------------

data &lt;- Hainmueller$new(n = 100, p = 6, design = "A", overlap = "low")
data$gen_data()
print(data$get_x()[1:2,])
</code></pre>

<hr>
<h2 id='LaLonde'>LaLonde data example</h2><span id='topic+LaLonde'></span>

<h3>Description</h3>

<p>LaLonde data example
</p>
<p>LaLonde data example
</p>


<h3>Details</h3>

<p>Returns the LaLonde data as used by Dehjia and Wahba. Note the data
is fixed and <code>gen_data()</code> will just initialize the fixed data.
</p>


<h3>Value</h3>

<p>An <a href="R6.html#topic+R6Class">R6</a> object of class <a href="#topic+DataSim">DataSim</a>
</p>


<h3>Super class</h3>

<p><code><a href="#topic+DataSim">causalOT::DataSim</a></code> -&gt; <code>LaLonde</code>
</p>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-LaLonde-gen_data"><code>LaLonde$gen_data()</code></a>
</p>
</li>
<li> <p><a href="#method-LaLonde-get_tau"><code>LaLonde$get_tau()</code></a>
</p>
</li>
<li> <p><a href="#method-LaLonde-gen_x"><code>LaLonde$gen_x()</code></a>
</p>
</li>
<li> <p><a href="#method-LaLonde-gen_y"><code>LaLonde$gen_y()</code></a>
</p>
</li>
<li> <p><a href="#method-LaLonde-gen_z"><code>LaLonde$gen_z()</code></a>
</p>
</li>
<li> <p><a href="#method-LaLonde-new"><code>LaLonde$new()</code></a>
</p>
</li>
<li> <p><a href="#method-LaLonde-get_design"><code>LaLonde$get_design()</code></a>
</p>
</li>
<li> <p><a href="#method-LaLonde-clone"><code>LaLonde$clone()</code></a>
</p>
</li></ul>



<details><summary>Inherited methods</summary>
<ul>
<li><span class="pkg-link" data-pkg="causalOT" data-topic="DataSim" data-id="get_n"><a href='../../causalOT/html/DataSim.html#method-DataSim-get_n'><code>causalOT::DataSim$get_n()</code></a></span></li>
<li><span class="pkg-link" data-pkg="causalOT" data-topic="DataSim" data-id="get_p"><a href='../../causalOT/html/DataSim.html#method-DataSim-get_p'><code>causalOT::DataSim$get_p()</code></a></span></li>
<li><span class="pkg-link" data-pkg="causalOT" data-topic="DataSim" data-id="get_x"><a href='../../causalOT/html/DataSim.html#method-DataSim-get_x'><code>causalOT::DataSim$get_x()</code></a></span></li>
<li><span class="pkg-link" data-pkg="causalOT" data-topic="DataSim" data-id="get_x0"><a href='../../causalOT/html/DataSim.html#method-DataSim-get_x0'><code>causalOT::DataSim$get_x0()</code></a></span></li>
<li><span class="pkg-link" data-pkg="causalOT" data-topic="DataSim" data-id="get_x1"><a href='../../causalOT/html/DataSim.html#method-DataSim-get_x1'><code>causalOT::DataSim$get_x1()</code></a></span></li>
<li><span class="pkg-link" data-pkg="causalOT" data-topic="DataSim" data-id="get_y"><a href='../../causalOT/html/DataSim.html#method-DataSim-get_y'><code>causalOT::DataSim$get_y()</code></a></span></li>
<li><span class="pkg-link" data-pkg="causalOT" data-topic="DataSim" data-id="get_z"><a href='../../causalOT/html/DataSim.html#method-DataSim-get_z'><code>causalOT::DataSim$get_z()</code></a></span></li>
</ul>
</details>

<hr>
<a id="method-LaLonde-gen_data"></a>



<h4>Method <code>gen_data()</code></h4>

<p>Sets up the data
</p>


<h5>Usage</h5>

<div class="r"><pre>LaLonde$gen_data()</pre></div>


<hr>
<a id="method-LaLonde-get_tau"></a>



<h4>Method <code>get_tau()</code></h4>

<p>Returns the experimental treatment effect, $1794
</p>


<h5>Usage</h5>

<div class="r"><pre>LaLonde$get_tau()</pre></div>


<hr>
<a id="method-LaLonde-gen_x"></a>



<h4>Method <code>gen_x()</code></h4>

<p>Sets up the covariate data
</p>


<h5>Usage</h5>

<div class="r"><pre>LaLonde$gen_x()</pre></div>


<hr>
<a id="method-LaLonde-gen_y"></a>



<h4>Method <code>gen_y()</code></h4>

<p>Sets up the outcome data
</p>


<h5>Usage</h5>

<div class="r"><pre>LaLonde$gen_y()</pre></div>


<hr>
<a id="method-LaLonde-gen_z"></a>



<h4>Method <code>gen_z()</code></h4>

<p>Sets up the treatment indicator
</p>


<h5>Usage</h5>

<div class="r"><pre>LaLonde$gen_z()</pre></div>


<hr>
<a id="method-LaLonde-new"></a>



<h4>Method <code>new()</code></h4>

<p>Initializes the LaLonde object.
</p>


<h5>Usage</h5>

<div class="r"><pre>LaLonde$new(n = NULL, p = NULL, param = list(), design = "NSW", ...)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>n</code></dt><dd><p>Not used.
Maintained for symmetry with other
DataSim objects.</p>
</dd>
<dt><code>p</code></dt><dd><p>Not used.
Maintained for symmetry with other
DataSim objects.</p>
</dd>
<dt><code>param</code></dt><dd><p>Not used.
Maintained for symmetry with other
DataSim objects.</p>
</dd>
<dt><code>design</code></dt><dd><p>One of &quot;NSW&quot; or &quot;Full&quot;.
&quot;NSW&quot; uses the original experimental data
from the job training program while option &quot;Full&quot;
uses the treated individuals from
LaLonde's study and compares them to
individuals from the
Current Population Survey as controls.</p>
</dd>
<dt><code>...</code></dt><dd><p>Not used.</p>
</dd>
</dl>

</div>



<h5>Examples</h5>

<div class="r example copy">
<pre>nsw &lt;- LaLonde$new(design = "NSW")
nsw$gen_data()
nsw$get_n()

obs.study &lt;-  LaLonde$new(design = "Full")
obs.study$gen_data()
obs.study$get_n()
</pre>
</div>


<hr>
<a id="method-LaLonde-get_design"></a>



<h4>Method <code>get_design()</code></h4>

<p>Returns the chosen design parameters
</p>


<h5>Usage</h5>

<div class="r"><pre>LaLonde$get_design()</pre></div>


<hr>
<a id="method-LaLonde-clone"></a>



<h4>Method <code>clone()</code></h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>LaLonde$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt><dd><p>Whether to make a deep clone.</p>
</dd>
</dl>

</div>




<h3>Examples</h3>

<pre><code class='language-R'>
## ------------------------------------------------
## Method `LaLonde$new`
## ------------------------------------------------

nsw &lt;- LaLonde$new(design = "NSW")
nsw$gen_data()
nsw$get_n()

obs.study &lt;-  LaLonde$new(design = "Full")
obs.study$gen_data()
obs.study$get_n()
</code></pre>

<hr>
<h2 id='mean_balance'>Standardized absolute mean difference calculations</h2><span id='topic+mean_balance'></span>

<h3>Description</h3>

<p>This function will calculate the difference in means between treatment groups standardized by the pooled standard-deviation of the respective covariates.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mean_balance(x = NULL, z = NULL, weights = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mean_balance_+3A_x">x</code></td>
<td>
<p>Either a matrix, an object of class <a href="#topic+dataHolder-class">dataHolder</a>, or an object of class DataSim</p>
</td></tr>
<tr><td><code id="mean_balance_+3A_z">z</code></td>
<td>
<p>A integer vector denoting the treatments of each observations. Can be null if <code>x</code> is a DataSim object or already of class <a href="#topic+dataHolder-class">dataHolder</a>.</p>
</td></tr>
<tr><td><code id="mean_balance_+3A_weights">weights</code></td>
<td>
<p>An object of class <a href="#topic+causalWeights-class">causalWeights</a>.</p>
</td></tr>
<tr><td><code id="mean_balance_+3A_...">...</code></td>
<td>
<p>Not used at this time.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector of mean balances
</p>


<h3>Examples</h3>

<pre><code class='language-R'>n &lt;- 100
p &lt;- 6
x &lt;- matrix(stats::rnorm(n * p), n, p)
z &lt;- stats::rbinom(n, 1, 0.5)
weights &lt;- calc_weight(x = x, z = z, estimand = "ATT", method = "Logistic")
mb &lt;- mean_balance(x = x, z = z, weights = weights)
print(mb)
</code></pre>

<hr>
<h2 id='Measure'>An R6 Class for setting up measures</h2><span id='topic+Measure'></span>

<h3>Description</h3>

<p>An R6 Class for setting up measures
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Measure(
  x,
  weights = NULL,
  probability.measure = TRUE,
  adapt = c("none", "weights", "x"),
  balance.functions = NA_real_,
  target.values = NA_real_,
  dtype = NULL,
  device = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Measure_+3A_x">x</code></td>
<td>
<p>The data points</p>
</td></tr>
<tr><td><code id="Measure_+3A_weights">weights</code></td>
<td>
<p>The empirical measure. If NULL, assigns equal weight to each observation</p>
</td></tr>
<tr><td><code id="Measure_+3A_probability.measure">probability.measure</code></td>
<td>
<p>Is the empirical measure a probability measure? Default is TRUE.</p>
</td></tr>
<tr><td><code id="Measure_+3A_adapt">adapt</code></td>
<td>
<p>Should we try to adapt the data (&quot;x&quot;), the weights (&quot;weights&quot;), or neither (&quot;none&quot;). Default is &quot;none&quot;.</p>
</td></tr>
<tr><td><code id="Measure_+3A_balance.functions">balance.functions</code></td>
<td>
<p>A matrix of functions of the covariates to target for mean balance. If NULL and <code>target.values</code> are provided, will use the data in <code>x</code>.</p>
</td></tr>
<tr><td><code id="Measure_+3A_target.values">target.values</code></td>
<td>
<p>The targets for the balance functions. Should be the same length as columns in <code>balance.functions.</code></p>
</td></tr>
<tr><td><code id="Measure_+3A_dtype">dtype</code></td>
<td>
<p>The torch_tensor dtype or NULL.</p>
</td></tr>
<tr><td><code id="Measure_+3A_device">device</code></td>
<td>
<p>The device to have the data on. Should be result of <code><a href="torch.html#topic+torch_device">torch::torch_device()</a></code> or NULL.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a Measure object
</p>


<h3>Public fields</h3>

<div class="r6-fields">

<dl>
<dt><code>balance_functions</code></dt><dd><p>the functions of the data that
we want to adjust towards the targets</p>
</dd>
<dt><code>balance_target</code></dt><dd><p>the values the balance_functions are targeting</p>
</dd>
<dt><code>adapt</code></dt><dd><p>What aspect of the data will be adapted. One of &quot;none&quot;,&quot;weights&quot;, or &quot;x&quot;.</p>
</dd>
<dt><code>device</code></dt><dd><p>the <code><a href="torch.html#topic+torch_device">torch::torch_device</a></code> of the data.</p>
</dd>
<dt><code>dtype</code></dt><dd><p>the <a href="torch.html#topic+torch_dtype">torch::torch_dtype</a> of the data.</p>
</dd>
<dt><code>n</code></dt><dd><p>the rows of the covariates, x.</p>
</dd>
<dt><code>d</code></dt><dd><p>the columns of the covariates, x.</p>
</dd>
<dt><code>probability_measure</code></dt><dd><p>is the measure a probability measure?</p>
</dd>
</dl>

</div>


<h3>Active bindings</h3>

<div class="r6-active-bindings">

<dl>
<dt><code>grad</code></dt><dd><p>gets or sets gradient</p>
</dd>
<dt><code>init_weights</code></dt><dd><p>returns the initial value of the weights</p>
</dd>
<dt><code>init_data</code></dt><dd><p>returns the initial value of the data</p>
</dd>
<dt><code>requires_grad</code></dt><dd><p>checks or turns on/off gradient</p>
</dd>
<dt><code>weights</code></dt><dd><p>gets or sets weights</p>
</dd>
<dt><code>x</code></dt><dd><p>Gets or sets the data</p>
</dd>
</dl>

</div>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-Measure-detach"><code>Measure$detach()</code></a>
</p>
</li>
<li> <p><a href="#method-Measure-get_weight_parameters"><code>Measure$get_weight_parameters()</code></a>
</p>
</li>
<li> <p><a href="#method-Measure-clone"><code>Measure$clone()</code></a>
</p>
</li></ul>


<hr>
<a id="method-Measure-detach"></a>



<h4>Method <code>detach()</code></h4>

<p>generates a deep clone of the object without gradients.
</p>


<h5>Usage</h5>

<div class="r"><pre>Measure$detach()</pre></div>


<hr>
<a id="method-Measure-get_weight_parameters"></a>



<h4>Method <code>get_weight_parameters()</code></h4>

<p>Makes a copy of the weights parameters.
</p>


<h5>Usage</h5>

<div class="r"><pre>Measure$get_weight_parameters()</pre></div>


<hr>
<a id="method-Measure-clone"></a>



<h4>Method <code>clone()</code></h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>Measure$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt><dd><p>Whether to make a deep clone.</p>
</dd>
</dl>

</div>




<h3>Examples</h3>

<pre><code class='language-R'>if(torch::torch_is_installed()) {
m &lt;- Measure(x = matrix(0, 10, 2), adapt = "none")
print(m)
m$x
m$x &lt;- matrix(1,10,2) # must have same dimensions
m$x
m$weights
m$weights &lt;- 1:10/sum(1:10)
m$weights

# with gradients
m &lt;- Measure(x = matrix(0, 10, 2), adapt = "weights")
m$requires_grad # TRUE
m$requires_grad &lt;- "none" # turns off
m$requires_grad # FALSE
m$requires_grad &lt;- "x"
m$requires_grad # TRUE
m &lt;- Measure(matrix(0, 10, 2), adapt = "none")
m$grad # NULL
m &lt;- Measure(matrix(0, 10, 2), adapt = "weights")
loss &lt;- sum(m$weights * 1:10)
loss$backward()
m$grad
# note the weights gradient is on the log softmax scale
#and the first parameter is fixed for identifiability
m$grad &lt;- rep(1,9)  
m$grad
}
</code></pre>

<hr>
<h2 id='Measure_'>An R6 object for measures</h2><span id='topic+Measure_'></span>

<h3>Description</h3>

<p>Internal R6 class object for Measure objects
</p>


<h3>Public fields</h3>

<div class="r6-fields">

<dl>
<dt><code>balance_functions</code></dt><dd><p>the functions of the data that
we want to adjust towards the targets</p>
</dd>
<dt><code>balance_target</code></dt><dd><p>the values the balance_functions are targeting</p>
</dd>
<dt><code>adapt</code></dt><dd><p>What aspect of the data will be adapted. One of &quot;none&quot;,&quot;weights&quot;, or &quot;x&quot;.</p>
</dd>
<dt><code>device</code></dt><dd><p>the <code><a href="torch.html#topic+torch_device">torch::torch_device()</a></code> of the data.</p>
</dd>
<dt><code>dtype</code></dt><dd><p>the <a href="torch.html#topic+torch_dtype">torch::torch_dtype</a> of the data.</p>
</dd>
<dt><code>n</code></dt><dd><p>the rows of the covariates, x.</p>
</dd>
<dt><code>d</code></dt><dd><p>the columns of the covariates, x.</p>
</dd>
<dt><code>probability_measure</code></dt><dd><p>is the measure a probability measure?</p>
</dd>
</dl>

</div>


<h3>Active bindings</h3>

<div class="r6-active-bindings">

<dl>
<dt><code>grad</code></dt><dd><p>gets or sets gradient</p>
</dd>
<dt><code>init_weights</code></dt><dd><p>returns the initial value of the weights</p>
</dd>
<dt><code>init_data</code></dt><dd><p>returns the initial value of the data</p>
</dd>
<dt><code>requires_grad</code></dt><dd><p>checks or turns on/off gradient</p>
</dd>
<dt><code>weights</code></dt><dd><p>gets or sets weights</p>
</dd>
<dt><code>x</code></dt><dd><p>Gets or sets the data.</p>
</dd>
</dl>

</div>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-Measure-detach"><code>Measure_$detach()</code></a>
</p>
</li>
<li> <p><a href="#method-Measure-get_weight_parameters"><code>Measure_$get_weight_parameters()</code></a>
</p>
</li>
<li> <p><a href="#method-Measure-print"><code>Measure_$print()</code></a>
</p>
</li>
<li> <p><a href="#method-Measure-new"><code>Measure_$new()</code></a>
</p>
</li>
<li> <p><a href="#method-Measure-clone"><code>Measure_$clone()</code></a>
</p>
</li></ul>


<hr>
<a id="method-Measure-detach"></a>



<h4>Method <code>detach()</code></h4>

<p>generates a deep clone of the object without gradients.
</p>


<h5>Usage</h5>

<div class="r"><pre>Measure_$detach()</pre></div>


<hr>
<a id="method-Measure-get_weight_parameters"></a>



<h4>Method <code>get_weight_parameters()</code></h4>

<p>Makes a copy of the weights parameters.
</p>


<h5>Usage</h5>

<div class="r"><pre>Measure_$get_weight_parameters()</pre></div>


<hr>
<a id="method-Measure-print"></a>



<h4>Method <code>print()</code></h4>

<p>prints the measure object
</p>


<h5>Usage</h5>

<div class="r"><pre>Measure_$print(...)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>...</code></dt><dd><p>Not used</p>
</dd>
</dl>

</div>


<hr>
<a id="method-Measure-new"></a>



<h4>Method <code>new()</code></h4>

<p>Constructor function
</p>


<h5>Usage</h5>

<div class="r"><pre>Measure_$new(
  x,
  weights = NULL,
  probability.measure = TRUE,
  adapt = c("none", "weights", "x"),
  balance.functions = NA_real_,
  target.values = NA_real_,
  dtype = NULL,
  device = NULL
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>x</code></dt><dd><p>The data points</p>
</dd>
<dt><code>weights</code></dt><dd><p>The empirical measure. If NULL, assigns equal weight to each observation</p>
</dd>
<dt><code>probability.measure</code></dt><dd><p>Is the empirical measure a probability measure? Default is TRUE.</p>
</dd>
<dt><code>adapt</code></dt><dd><p>Should we try to adapt the data (&quot;x&quot;), the weights (&quot;weights&quot;), or neither (&quot;none&quot;). Default is &quot;none&quot;.</p>
</dd>
<dt><code>balance.functions</code></dt><dd><p>A matrix of functions of the covariates to target for mean balance. If NULL and <code>target.values</code> are provided, will use the data in <code>x</code>.</p>
</dd>
<dt><code>target.values</code></dt><dd><p>The targets for the balance functions. Should be the same length as columns in <code>balance.functions.</code></p>
</dd>
<dt><code>dtype</code></dt><dd><p>The <a href="torch.html#topic+torch_dtype">torch::torch_dtype</a> or NULL.</p>
</dd>
<dt><code>device</code></dt><dd><p>The device to have the data on. Should be result of <code><a href="torch.html#topic+torch_device">torch::torch_device()</a></code> or NULL.</p>
</dd>
</dl>

</div>


<hr>
<a id="method-Measure-clone"></a>



<h4>Method <code>clone()</code></h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>Measure_$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt><dd><p>Whether to make a deep clone.</p>
</dd>
</dl>

</div>



<hr>
<h2 id='oop_loss_select'>Internal function to select appropriate loss function</h2><span id='topic+oop_loss_select'></span>

<h3>Description</h3>

<p>Selects sinkhorn or energy distance losses depending on value
of penalty parameter
</p>


<h3>Usage</h3>

<pre><code class='language-R'>oop_loss_select(ot)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="oop_loss_select_+3A_ot">ot</code></td>
<td>
<p>an OT object</p>
</td></tr>
</table>

<hr>
<h2 id='ot_distance'>Optimal Transport Distance</h2><span id='topic+ot_distance'></span><span id='topic+ot_distance.causalWeights'></span><span id='topic+ot_distance.matrix'></span><span id='topic+ot_distance.array'></span><span id='topic+ot_distance.torch_tensor'></span>

<h3>Description</h3>

<p>Optimal Transport Distance
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ot_distance(
  x1,
  x2 = NULL,
  a = NULL,
  b = NULL,
  penalty,
  p = 2,
  cost = NULL,
  debias = TRUE,
  online.cost = "auto",
  diameter = NULL,
  niter = 1000,
  tol = 1e-07
)

## S3 method for class 'causalWeights'
ot_distance(
  x1,
  x2 = NULL,
  a = NULL,
  b = NULL,
  penalty,
  p = 2,
  cost = NULL,
  debias = TRUE,
  online.cost = "auto",
  diameter = NULL,
  niter = 1000,
  tol = 1e-07
)

## S3 method for class 'matrix'
ot_distance(
  x1,
  x2,
  a = NULL,
  b = NULL,
  penalty,
  p = 2,
  cost = NULL,
  debias = TRUE,
  online.cost = "auto",
  diameter = NULL,
  niter = 1000,
  tol = 1e-07
)

## S3 method for class 'array'
ot_distance(
  x1,
  x2,
  a = NULL,
  b = NULL,
  penalty,
  p = 2,
  cost = NULL,
  debias = TRUE,
  online.cost = "auto",
  diameter = NULL,
  niter = 1000,
  tol = 1e-07
)

## S3 method for class 'torch_tensor'
ot_distance(
  x1,
  x2,
  a = NULL,
  b = NULL,
  penalty,
  p = 2,
  cost = NULL,
  debias = TRUE,
  online.cost = "auto",
  diameter = NULL,
  niter = 1000,
  tol = 1e-07
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ot_distance_+3A_x1">x1</code></td>
<td>
<p>Either an object of class <a href="#topic+causalWeights-class">causalWeights</a> or a matrix of the covariates in the first sample</p>
</td></tr>
<tr><td><code id="ot_distance_+3A_x2">x2</code></td>
<td>
<p><code>NULL</code> or a matrix of the covariates in the second sample.</p>
</td></tr>
<tr><td><code id="ot_distance_+3A_a">a</code></td>
<td>
<p>Empirical measure of the first sample. If NULL, assumes each observation gets equal mass. Ignored for objects of class causalWeights.</p>
</td></tr>
<tr><td><code id="ot_distance_+3A_b">b</code></td>
<td>
<p>Empirical measure of the second sample. If NULL, assumes each observation gets equal mass. Ignored for objects of class causalWeights.</p>
</td></tr>
<tr><td><code id="ot_distance_+3A_penalty">penalty</code></td>
<td>
<p>The penalty of the optimal transport distance to use. If missing or NULL, the function will try to guess a suitable value depending if debias is TRUE or FALSE.</p>
</td></tr>
<tr><td><code id="ot_distance_+3A_p">p</code></td>
<td>
<p><code class="reqn">L_p</code> distance metric power</p>
</td></tr>
<tr><td><code id="ot_distance_+3A_cost">cost</code></td>
<td>
<p>Supply your own cost function. Should take arguments <code>x1</code>, <code>x2</code>, and <code>p</code>.</p>
</td></tr>
<tr><td><code id="ot_distance_+3A_debias">debias</code></td>
<td>
<p>TRUE or FALSE. Should the debiased optimal transport distances be used.</p>
</td></tr>
<tr><td><code id="ot_distance_+3A_online.cost">online.cost</code></td>
<td>
<p>How to calculate the distance matrix. One of &quot;auto&quot;, &quot;tensorized&quot;, or &quot;online&quot;.</p>
</td></tr>
<tr><td><code id="ot_distance_+3A_diameter">diameter</code></td>
<td>
<p>The diameter of the metric space, if known. Default is NULL.</p>
</td></tr>
<tr><td><code id="ot_distance_+3A_niter">niter</code></td>
<td>
<p>The maximum number of iterations for the Sinkhorn updates</p>
</td></tr>
<tr><td><code id="ot_distance_+3A_tol">tol</code></td>
<td>
<p>The tolerance for convergence</p>
</td></tr>
</table>


<h3>Value</h3>

<p>For objects of class matrix, numeric value giving the optimal transport distance. For objects of class causalWeights, results are returned as a list for before ('pre') and after adjustment ('post').
</p>


<h3>Methods (by class)</h3>


<ul>
<li> <p><code>ot_distance(causalWeights)</code>: method for causalWeights class
</p>
</li>
<li> <p><code>ot_distance(matrix)</code>: method for matrices
</p>
</li>
<li> <p><code>ot_distance(array)</code>: method for arrays
</p>
</li>
<li> <p><code>ot_distance(torch_tensor)</code>: method for torch_tensors
</p>
</li></ul>


<h3>Examples</h3>

<pre><code class='language-R'>if ( torch::torch_is_installed()) {
x &lt;- matrix(stats::rnorm(10*5), 10, 5)
z &lt;- stats::rbinom(10, 1, 0.5)
weights &lt;- calc_weight(x = x, z = z, method = "Logistic", estimand = "ATT")
ot1 &lt;- ot_distance(x1 = weights, penalty = 100, 
p = 2, debias = TRUE, online.cost = "auto", 
diameter = NULL)
ot2&lt;- ot_distance(x1 = x[z==0, ], x2 = x[z == 1,], 
a= weights@w0/sum(weights@w0), b = weights@w1,
 penalty = 100, p = 2, debias = TRUE, online.cost = "auto", diameter = NULL)

 all.equal(ot1$post, ot2) 
}
</code></pre>

<hr>
<h2 id='OTProblem'>Object Oriented OT Problem</h2><span id='topic+OTProblem'></span>

<h3>Description</h3>

<p>Object Oriented OT Problem
</p>


<h3>Usage</h3>

<pre><code class='language-R'>OTProblem(measure_1, measure_2, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="OTProblem_+3A_measure_1">measure_1</code></td>
<td>
<p>An object of class <a href="#topic+Measure">Measure</a></p>
</td></tr>
<tr><td><code id="OTProblem_+3A_measure_2">measure_2</code></td>
<td>
<p>An object of class <a href="#topic+Measure">Measure</a></p>
</td></tr>
<tr><td><code id="OTProblem_+3A_...">...</code></td>
<td>
<p>Not used at this time</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An R6 object of class &quot;OTProblem&quot;
</p>


<h3>Public fields</h3>

<div class="r6-fields">

<dl>
<dt><code>device</code></dt><dd><p>the <code><a href="torch.html#topic+torch_device">torch::torch_device()</a></code> of the data.</p>
</dd>
<dt><code>dtype</code></dt><dd><p>the <a href="torch.html#topic+torch_dtype">torch::torch_dtype</a> of the data.</p>
</dd>
<dt><code>selected_delta</code></dt><dd><p>the delta value selected after <code>choose_hyperparameters</code></p>
</dd>
<dt><code>selected_lambda</code></dt><dd><p>the lambda value selected after <code>choose_hyperparameters</code></p>
</dd>
</dl>

</div>


<h3>Active bindings</h3>

<div class="r6-active-bindings">

<dl>
<dt><code>loss</code></dt><dd><p>prints the current value of the objective. Only availble after the <a href="#method-OTProblem-solve"><code>OTProblem$solve()</code></a> method has been run</p>
</dd>
<dt><code>penalty</code></dt><dd><p>Returns a list of the lambda and delta penalities that will be iterated through. To set these values, use the <a href="#method-OTProblem-setup_arguments"><code>OTProblem$setup_arguments()</code></a> function.</p>
</dd>
</dl>

</div>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-OTProblem-add"><code>OTProblem$add()</code></a>
</p>
</li>
<li> <p><a href="#method-OTProblem-subtract"><code>OTProblem$subtract()</code></a>
</p>
</li>
<li> <p><a href="#method-OTProblem-multiply"><code>OTProblem$multiply()</code></a>
</p>
</li>
<li> <p><a href="#method-OTProblem-divide"><code>OTProblem$divide()</code></a>
</p>
</li>
<li> <p><a href="#method-OTProblem-setup_arguments"><code>OTProblem$setup_arguments()</code></a>
</p>
</li>
<li> <p><a href="#method-OTProblem-solve"><code>OTProblem$solve()</code></a>
</p>
</li>
<li> <p><a href="#method-OTProblem-choose_hyperparameters"><code>OTProblem$choose_hyperparameters()</code></a>
</p>
</li>
<li> <p><a href="#method-OTProblem-info"><code>OTProblem$info()</code></a>
</p>
</li>
<li> <p><a href="#method-OTProblem-clone"><code>OTProblem$clone()</code></a>
</p>
</li></ul>


<hr>
<a id="method-OTProblem-add"></a>



<h4>Method <code>add()</code></h4>

<p>adds <code>o2</code> to the OTProblem
</p>


<h5>Usage</h5>

<div class="r"><pre>OTProblem$add(o2)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>o2</code></dt><dd><p>A number or object of class OTProblem</p>
</dd>
</dl>

</div>


<hr>
<a id="method-OTProblem-subtract"></a>



<h4>Method <code>subtract()</code></h4>

<p>subtracts <code>o2</code> from OTProblem
</p>


<h5>Usage</h5>

<div class="r"><pre>OTProblem$subtract(o2)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>o2</code></dt><dd><p>A number or object of class OTProblem</p>
</dd>
</dl>

</div>


<hr>
<a id="method-OTProblem-multiply"></a>



<h4>Method <code>multiply()</code></h4>

<p>multiplies OTProblem by <code>o2</code>
</p>


<h5>Usage</h5>

<div class="r"><pre>OTProblem$multiply(o2)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>o2</code></dt><dd><p>A number or an object of class OTProblem</p>
</dd>
</dl>

</div>


<hr>
<a id="method-OTProblem-divide"></a>



<h4>Method <code>divide()</code></h4>

<p>divides OTProblem by <code>o2</code>
</p>


<h5>Usage</h5>

<div class="r"><pre>OTProblem$divide(o2)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>o2</code></dt><dd><p>A number or object of class OTProblem</p>
</dd>
</dl>

</div>


<hr>
<a id="method-OTProblem-setup_arguments"></a>



<h4>Method <code>setup_arguments()</code></h4>



<h5>Usage</h5>

<div class="r"><pre>OTProblem$setup_arguments(
      lambda,
      delta,
      grid.length = 7L,
      cost.function = NULL,
      p = 2,
      cost.online = "auto",
      debias = TRUE,
      diameter = NULL,
      ot_niter = 1000L,
      ot_tol = 0.001
    )</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>lambda</code></dt><dd><p>The penalty parameters to try for the OT problems. If not provided, function will select some</p>
</dd>
<dt><code>delta</code></dt><dd><p>The constraint paramters to try for the balance function problems, if any</p>
</dd>
<dt><code>grid.length</code></dt><dd><p>The number of hyperparameters to try if not provided</p>
</dd>
<dt><code>cost.function</code></dt><dd><p>The cost function for the data. Can be any function that takes arguments <code>x1</code>, <code>x2</code>, <code>p</code>. Defaults to the Euclidean distance</p>
</dd>
<dt><code>p</code></dt><dd><p>The power to raise the cost matrix by. Default is 2</p>
</dd>
<dt><code>cost.online</code></dt><dd><p>Should online costs be used? Default is &quot;auto&quot; but &quot;tensorized&quot; stores the cost matrix in memory while &quot;online&quot; will calculate it on the fly.</p>
</dd>
<dt><code>debias</code></dt><dd><p>Should debiased OT problems be used? Defaults to TRUE</p>
</dd>
<dt><code>diameter</code></dt><dd><p>Diameter of the cost function.</p>
</dd>
<dt><code>ot_niter</code></dt><dd><p>Number of iterations to run the OT problems</p>
</dd>
<dt><code>ot_tol</code></dt><dd><p>The tolerance for convergence of the OT problems</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>NULL
</p>



<h5>Examples</h5>

<div class="r example copy">
<pre> ot$setup_arguments(lambda = c(1000,10))
    </pre>
</div>


<hr>
<a id="method-OTProblem-solve"></a>



<h4>Method <code>solve()</code></h4>

<p>Solve the OTProblem at each parameter value. Must run setup_arguments first.
</p>


<h5>Usage</h5>

<div class="r"><pre>OTProblem$solve(
      niter = 1000L,
      tol = 1e-05,
      optimizer = c("torch", "frank-wolfe"),
      torch_optim = torch::optim_lbfgs,
      torch_scheduler = torch::lr_reduce_on_plateau,
      torch_args = NULL,
      osqp_args = NULL,
      quick.balance.function = TRUE
    )</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>niter</code></dt><dd><p>The nubmer of iterations to run solver at each combination of hyperparameter values</p>
</dd>
<dt><code>tol</code></dt><dd><p>The tolerance for convergence</p>
</dd>
<dt><code>optimizer</code></dt><dd><p>The optimizer to use. One of &quot;torch&quot; or &quot;frank-wolfe&quot;</p>
</dd>
<dt><code>torch_optim</code></dt><dd><p>The <code>torch_optimizer</code> to use. Default is <a href="torch.html#topic+optim_lbfgs">torch::optim_lbfgs</a></p>
</dd>
<dt><code>torch_scheduler</code></dt><dd><p>The <a href="torch.html#topic+lr_scheduler">torch::lr_scheduler</a> to use. Default is <a href="torch.html#topic+lr_reduce_on_plateau">torch::lr_reduce_on_plateau</a></p>
</dd>
<dt><code>torch_args</code></dt><dd><p>Arguments passed to the torch optimizer and scheduler</p>
</dd>
<dt><code>osqp_args</code></dt><dd><p>Arguments passed to <code><a href="osqp.html#topic+osqpSettings">osqp::osqpSettings()</a></code> if appropriate</p>
</dd>
<dt><code>quick.balance.function</code></dt><dd><p>Should <code><a href="osqp.html#topic+osqp">osqp::osqp()</a></code> be used to select balance function constraints (delta) or not. Default true.</p>
</dd>
</dl>

</div>



<h5>Examples</h5>

<div class="r example copy">
<pre> ot$solve(niter = 1, torch_optim = torch::optim_rmsprop)
    </pre>
</div>


<hr>
<a id="method-OTProblem-choose_hyperparameters"></a>



<h4>Method <code>choose_hyperparameters()</code></h4>

<p>Selects the hyperparameter values through a bootstrap algorithm
</p>


<h5>Usage</h5>

<div class="r"><pre>OTProblem$choose_hyperparameters(
      n_boot_lambda = 100L,
      n_boot_delta = 1000L,
      lambda_bootstrap = Inf
    )</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>n_boot_lambda</code></dt><dd><p>The number of bootstrap iterations to run when selecting lambda</p>
</dd>
<dt><code>n_boot_delta</code></dt><dd><p>The number of bootstrap iterations to run when selecting delta</p>
</dd>
<dt><code>lambda_bootstrap</code></dt><dd><p>The penalty parameter to use when selecting lambda. Higher numbers run faster.</p>
</dd>
</dl>

</div>



<h5>Examples</h5>

<div class="r example copy">
<pre> ot$choose_hyperparameters(n_boot_lambda = 10, 
                                             n_boot_delta = 10, 
                                             lambda_bootstrap = Inf)
    </pre>
</div>


<hr>
<a id="method-OTProblem-info"></a>



<h4>Method <code>info()</code></h4>

<p>Provides diagnostics after solve and choose_hyperparameter methods have been run.
</p>


<h5>Usage</h5>

<div class="r"><pre>OTProblem$info()</pre></div>



<h5>Returns</h5>

<p>a list with slots
</p>

<ul>
<li> <p><code>loss</code> the final loss values
</p>
</li>
<li> <p><code>iterations</code> The number of iterations run for each combination of parameters
</p>
</li>
<li> <p><code>balance.function.differences</code> The final differences in the balance functions
</p>
</li>
<li> <p><code>hyperparam.metrics</code> A list of the bootstrap evalustion for delta and lambda values</p>
</li></ul>




<h5>Examples</h5>

<div class="r example copy">
<pre> ot$info()
    </pre>
</div>


<hr>
<a id="method-OTProblem-clone"></a>



<h4>Method <code>clone()</code></h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>OTProblem$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt><dd><p>Whether to make a deep clone.</p>
</dd>
</dl>

</div>




<h3>Examples</h3>

<pre><code class='language-R'>## ------------------------------------------------
## Method `OTProblem(measure_1, measure_2)`
## ------------------------------------------------

if (torch::torch_is_installed()) {
  # setup measures
  x &lt;- matrix(1, 100, 10)
  m1 &lt;- Measure(x = x)
  
  y &lt;- matrix(2, 100, 10)
  m2 &lt;- Measure(x = y, adapt = "weights")
  
  z &lt;- matrix(3,102, 10)
  m3 &lt;- Measure(x = z)
  
  # setup OT problems
  ot1 &lt;- OTProblem(m1, m2)
  ot2 &lt;- OTProblem(m3, m2)
  ot &lt;- 0.5 * ot1 + 0.5 * ot2
  print(ot)

## ------------------------------------------------
## Method `OTProblem$setup_arguments`
## ------------------------------------------------

  ot$setup_arguments(lambda = 1000)

## ------------------------------------------------
## Method `OTProblem$solve`
## ------------------------------------------------

  ot$solve(niter = 1, torch_optim = torch::optim_rmsprop)

## ------------------------------------------------
## Method `OTProblem$choose_hyperparameters`
## ------------------------------------------------

  ot$choose_hyperparameters(n_boot_lambda = 1,
                            n_boot_delta = 1, 
                            lambda_bootstrap = Inf)

## ------------------------------------------------
## Method `OTProblem$info`
## ------------------------------------------------

ot$info()
}
</code></pre>

<hr>
<h2 id='OTProblem_-class'>An R6 class to construct OTProblems</h2><span id='topic+OTProblem_-class'></span><span id='topic+OTProblem_'></span>

<h3>Description</h3>

<p>OTProblem R6 class
</p>


<h3>Public fields</h3>

<div class="r6-fields">

<dl>
<dt><code>device</code></dt><dd><p>the <code><a href="torch.html#topic+torch_device">torch::torch_device()</a></code> of the data.</p>
</dd>
<dt><code>dtype</code></dt><dd><p>the <a href="torch.html#topic+torch_dtype">torch::torch_dtype</a> of the data.</p>
</dd>
<dt><code>selected_delta</code></dt><dd><p>the delta value selected after <code>choose_hyperparameters</code></p>
</dd>
<dt><code>selected_lambda</code></dt><dd><p>the lambda value selected after <code>choose_hyperparameters</code></p>
</dd>
</dl>

</div>


<h3>Active bindings</h3>

<div class="r6-active-bindings">

<dl>
<dt><code>loss</code></dt><dd><p>prints the current value of the objective. Only availble after the solve method has been run</p>
</dd>
<dt><code>penalty</code></dt><dd><p>Returns a list of the lambda and delta penalities that will be iterated through. To set these values, use the <code>setup_arguments</code> function.</p>
</dd>
</dl>

</div>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-OTProblem-add"><code>OTProblem_$add()</code></a>
</p>
</li>
<li> <p><a href="#method-OTProblem-subtract"><code>OTProblem_$subtract()</code></a>
</p>
</li>
<li> <p><a href="#method-OTProblem-multiply"><code>OTProblem_$multiply()</code></a>
</p>
</li>
<li> <p><a href="#method-OTProblem-divide"><code>OTProblem_$divide()</code></a>
</p>
</li>
<li> <p><a href="#method-OTProblem-print"><code>OTProblem_$print()</code></a>
</p>
</li>
<li> <p><a href="#method-OTProblem-new"><code>OTProblem_$new()</code></a>
</p>
</li>
<li> <p><a href="#method-OTProblem-setup_arguments"><code>OTProblem_$setup_arguments()</code></a>
</p>
</li>
<li> <p><a href="#method-OTProblem-solve"><code>OTProblem_$solve()</code></a>
</p>
</li>
<li> <p><a href="#method-OTProblem-choose_hyperparameters"><code>OTProblem_$choose_hyperparameters()</code></a>
</p>
</li>
<li> <p><a href="#method-OTProblem-info"><code>OTProblem_$info()</code></a>
</p>
</li>
<li> <p><a href="#method-OTProblem-clone"><code>OTProblem_$clone()</code></a>
</p>
</li></ul>


<hr>
<a id="method-OTProblem-add"></a>



<h4>Method <code>add()</code></h4>

<p>adds <code>o2</code> to the OTProblem
</p>


<h5>Usage</h5>

<div class="r"><pre>OTProblem_$add(o2)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>o2</code></dt><dd><p>A number or object of class OTProblem</p>
</dd>
</dl>

</div>


<hr>
<a id="method-OTProblem-subtract"></a>



<h4>Method <code>subtract()</code></h4>

<p>subtracts <code>o2</code> from OTProblem
</p>


<h5>Usage</h5>

<div class="r"><pre>OTProblem_$subtract(o2)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>o2</code></dt><dd><p>A number or object of class OTProblem</p>
</dd>
</dl>

</div>


<hr>
<a id="method-OTProblem-multiply"></a>



<h4>Method <code>multiply()</code></h4>

<p>multiplies OTProblem by <code>o2</code>
</p>


<h5>Usage</h5>

<div class="r"><pre>OTProblem_$multiply(o2)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>o2</code></dt><dd><p>A number or object of class OTProblem</p>
</dd>
</dl>

</div>


<hr>
<a id="method-OTProblem-divide"></a>



<h4>Method <code>divide()</code></h4>

<p>divides OTProblem by <code>o2</code>
</p>


<h5>Usage</h5>

<div class="r"><pre>OTProblem_$divide(o2)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>o2</code></dt><dd><p>A number or object of class OTProblem</p>
</dd>
</dl>

</div>


<hr>
<a id="method-OTProblem-print"></a>



<h4>Method <code>print()</code></h4>

<p>prints the OT problem object
</p>


<h5>Usage</h5>

<div class="r"><pre>OTProblem_$print(...)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>...</code></dt><dd><p>Not used</p>
</dd>
</dl>

</div>


<hr>
<a id="method-OTProblem-new"></a>



<h4>Method <code>new()</code></h4>

<p>Constructor method
</p>


<h5>Usage</h5>

<div class="r"><pre>OTProblem_$new(measure_1, measure_2)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>measure_1</code></dt><dd><p>An object of class <a href="#topic+Measure">Measure</a></p>
</dd>
<dt><code>measure_2</code></dt><dd><p>An object of class <a href="#topic+Measure">Measure</a></p>
</dd>
<dt><code>...</code></dt><dd><p>Not used at this time</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>An R6 object of class &quot;OTProblem&quot;
</p>


<hr>
<a id="method-OTProblem-setup_arguments"></a>



<h4>Method <code>setup_arguments()</code></h4>



<h5>Usage</h5>

<div class="r"><pre>OTProblem_$setup_arguments(
  lambda,
  delta,
  grid.length = 7L,
  cost.function = NULL,
  p = 2,
  cost.online = "auto",
  debias = TRUE,
  diameter = NULL,
  ot_niter = 1000L,
  ot_tol = 0.001
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>lambda</code></dt><dd><p>The penalty parameters to try for the OT problems. If not provided, function will select some</p>
</dd>
<dt><code>delta</code></dt><dd><p>The constraint paramters to try for the balance function problems, if any</p>
</dd>
<dt><code>grid.length</code></dt><dd><p>The number of hyperparameters to try if not provided</p>
</dd>
<dt><code>cost.function</code></dt><dd><p>The cost function for the data. Can be any function that takes arguments <code>x1</code>, <code>x2</code>, <code>p</code>. Defaults to the Euclidean distance</p>
</dd>
<dt><code>p</code></dt><dd><p>The power to raise the cost matrix by. Default is 2</p>
</dd>
<dt><code>cost.online</code></dt><dd><p>Should online costs be used? Default is &quot;auto&quot; but &quot;tensorized&quot; stores the cost matrix in memory while &quot;online&quot; will calculate it on the fly.</p>
</dd>
<dt><code>debias</code></dt><dd><p>Should debiased OT problems be used? Defaults to TRUE</p>
</dd>
<dt><code>diameter</code></dt><dd><p>Diameter of the cost function.</p>
</dd>
<dt><code>ot_niter</code></dt><dd><p>Number of iterations to run the OT problems</p>
</dd>
<dt><code>ot_tol</code></dt><dd><p>The tolerance for convergence of the OT problems</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>NULL
</p>


<hr>
<a id="method-OTProblem-solve"></a>



<h4>Method <code>solve()</code></h4>

<p>Solve the OTProblem at each parameter value. Must run setup_arguments first.
</p>


<h5>Usage</h5>

<div class="r"><pre>OTProblem_$solve(
  niter = 1000L,
  tol = 1e-05,
  optimizer = c("torch", "frank-wolfe"),
  torch_optim = torch::optim_lbfgs,
  torch_scheduler = torch::lr_reduce_on_plateau,
  torch_args = NULL,
  osqp_args = NULL,
  quick.balance.function = TRUE
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>niter</code></dt><dd><p>The nubmer of iterations to run solver at each combination of hyperparameter values</p>
</dd>
<dt><code>tol</code></dt><dd><p>The tolerance for convergence</p>
</dd>
<dt><code>optimizer</code></dt><dd><p>The optimizer to use. One of &quot;torch&quot; or &quot;frank-wolfe&quot;</p>
</dd>
<dt><code>torch_optim</code></dt><dd><p>The <code>torch_optimizer</code> to use. Default is <a href="torch.html#topic+optim_lbfgs">torch::optim_lbfgs</a></p>
</dd>
<dt><code>torch_scheduler</code></dt><dd><p>The <a href="torch.html#topic+lr_scheduler">torch::lr_scheduler</a> to use. Default is <a href="torch.html#topic+lr_reduce_on_plateau">torch::lr_reduce_on_plateau</a></p>
</dd>
<dt><code>torch_args</code></dt><dd><p>Arguments passed to the torch optimizer and scheduler</p>
</dd>
<dt><code>osqp_args</code></dt><dd><p>Arguments passed to <code><a href="osqp.html#topic+osqpSettings">osqp::osqpSettings()</a></code> if appropriate</p>
</dd>
<dt><code>quick.balance.function</code></dt><dd><p>Should <code><a href="osqp.html#topic+osqp">osqp::osqp()</a></code> be used to select balance function constraints (delta) or not. Default true.</p>
</dd>
</dl>

</div>


<hr>
<a id="method-OTProblem-choose_hyperparameters"></a>



<h4>Method <code>choose_hyperparameters()</code></h4>

<p>Selects the hyperparameter values through a bootstrap algorithm
</p>


<h5>Usage</h5>

<div class="r"><pre>OTProblem_$choose_hyperparameters(
  n_boot_lambda = 100L,
  n_boot_delta = 1000L,
  lambda_bootstrap = Inf
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>n_boot_lambda</code></dt><dd><p>The number of bootstrap iterations to run when selecting lambda</p>
</dd>
<dt><code>n_boot_delta</code></dt><dd><p>The number of bootstrap iterations to run when selecting delta</p>
</dd>
<dt><code>lambda_bootstrap</code></dt><dd><p>The penalty parameter to use when selecting lambda. Higher numbers run faster.</p>
</dd>
</dl>

</div>


<hr>
<a id="method-OTProblem-info"></a>



<h4>Method <code>info()</code></h4>

<p>Provides diagnostics after solve and choose_hyperparameter methods have been run.
</p>


<h5>Usage</h5>

<div class="r"><pre>OTProblem_$info()</pre></div>



<h5>Returns</h5>

<p>a list with slots
</p>

<ul>
<li> <p><code>loss</code> the final loss values
</p>
</li>
<li> <p><code>iterations</code> The number of iterations run for each combination of parameters
</p>
</li>
<li> <p><code>balance.function.differences</code> The final differences in the balance functions
</p>
</li>
<li> <p><code>hyperparam.metrics</code> A list of the bootstrap evalustion for delta and lambda values</p>
</li></ul>



<hr>
<a id="method-OTProblem-clone"></a>



<h4>Method <code>clone()</code></h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>OTProblem_$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt><dd><p>Whether to make a deep clone.</p>
</dd>
</dl>

</div>



<hr>
<h2 id='plot.causalWeights'>plot.causalWeights</h2><span id='topic+plot.causalWeights'></span>

<h3>Description</h3>

<p>plot.causalWeights
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'causalWeights'
plot(
  x,
  r_eff = NULL,
  penalty,
  p = 2,
  cost = NULL,
  debias = TRUE,
  online.cost = "auto",
  diameter = NULL,
  niter = 1000,
  tol = 1e-07,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.causalWeights_+3A_x">x</code></td>
<td>
<p>A <a href="#topic+causalWeights-class">causalWeights</a> object</p>
</td></tr>
<tr><td><code id="plot.causalWeights_+3A_r_eff">r_eff</code></td>
<td>
<p>The <code class="reqn">r_\text{eff}</code> to use for the <code><a href="#topic+PSIS_diag">PSIS_diag()</a></code> function.</p>
</td></tr>
<tr><td><code id="plot.causalWeights_+3A_penalty">penalty</code></td>
<td>
<p>The penalty of the optimal transport distance to use. If missing or NULL, the function will try to guess a suitable value depending if debias is TRUE or FALSE.</p>
</td></tr>
<tr><td><code id="plot.causalWeights_+3A_p">p</code></td>
<td>
<p><code class="reqn">L_p</code> distance metric power</p>
</td></tr>
<tr><td><code id="plot.causalWeights_+3A_cost">cost</code></td>
<td>
<p>Supply your own cost function. Should take arguments <code>x1</code>, <code>x2</code>, and <code>p</code>.</p>
</td></tr>
<tr><td><code id="plot.causalWeights_+3A_debias">debias</code></td>
<td>
<p>TRUE or FALSE. Should the debiased optimal transport distances be used.</p>
</td></tr>
<tr><td><code id="plot.causalWeights_+3A_online.cost">online.cost</code></td>
<td>
<p>How to calculate the distance matrix. One of &quot;auto&quot;, &quot;tensorized&quot;, or &quot;online&quot;.</p>
</td></tr>
<tr><td><code id="plot.causalWeights_+3A_diameter">diameter</code></td>
<td>
<p>The diameter of the metric space, if known. Default is NULL.</p>
</td></tr>
<tr><td><code id="plot.causalWeights_+3A_niter">niter</code></td>
<td>
<p>The maximum number of iterations for the Sinkhorn updates</p>
</td></tr>
<tr><td><code id="plot.causalWeights_+3A_tol">tol</code></td>
<td>
<p>The tolerance for convergence</p>
</td></tr>
<tr><td><code id="plot.causalWeights_+3A_...">...</code></td>
<td>
<p>Not used at this time</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The plot method first calls summary.causalWeights on the causalWeights object. Then plots the diagnostics from that summary object.
</p>


<h3>Value</h3>

<p>The plot method returns an invisible object of class summary_causalWeights.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+summary.causalWeights">summary.causalWeights()</a></code>
</p>

<hr>
<h2 id='pph'>An external control trial of treatments for post-partum hemorrhage</h2><span id='topic+pph'></span>

<h3>Description</h3>

<p>A dataset evaluating treatments for post-partum hemorrhage. The data contain  treatment groups receiving misoprostol vs potential
controls from other locations that received only oxytocin. The data is
stored as a numeric matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(pph)
</code></pre>


<h3>Format</h3>

<p>A matrix with 802 rows and 17 variables
</p>


<h3>Details</h3>

<p>The variables are as follows:
</p>

<ul>
<li><p> cum_blood_20m. The outcome variable denoting cumulative blood loss in mL 20 minutes after the diagnosis of post-partum hemorrhage (650 &ndash; 2000).
</p>
</li>
<li><p> tx. The treatment indicator of whether an individual received misoprostol (1) or oxytocin (0).
</p>
</li>
<li><p> age. the mother's age in years (15 &ndash; 43).
</p>
</li>
<li><p> no_educ. whether a woman had no education (1) or some education (0).
</p>
</li>
<li><p> num_livebirth. the number of previous live births.
</p>
</li>
<li><p> cur_married. whether a mother is currently married (1 = yes, 0 = no).
</p>
</li>
<li><p> gest_age. the gestational age of the fetus in weeks (35 &ndash; 43).
</p>
</li>
<li><p> prev_pphyes. whether the woman has had a previous post-partum hemorrahge.
</p>
</li>
<li><p> hb_test. the woman's hemoglobin in mg/dL (7 &ndash; 15).
</p>
</li>
<li><p> induced_laboryes. whether labor was induced (1 = yes, 0 = no).
</p>
</li>
<li><p> augmented_laboryes. whether labor was augmented (1 = yes, 0 = no).
</p>
</li>
<li><p> early_cordclampyes. whether the umbilical cord was clamped early (1 = yes, 0 = no).
</p>
</li>
<li><p> control_cordtractionyes. whether cord traction was controlled (1 = yes, 0 = no).
</p>
</li>
<li><p> uterine_massageyes. whether a uterine massage was given (1 = yes, 0 = no).
</p>
</li>
<li><p> placenta. whether placenta was delivered before treatment given (1 = yes, 0 = no).
</p>
</li>
<li><p> bloodlossattx. amount of blood lost when treatment given (500 mL &ndash; 1800 mL)
</p>
</li>
<li><p> sitecode. Which site is the individual from? (1 = Cairo, Egypt,  2 = Turkey,        3 = Hocmon, Vietnam,  4 = Cuchi, Vietnam, and 5 Burkina Faso).
</p>
</li></ul>



<h3>Source</h3>

<p>Data from the following Harvard Dataverse:
</p>

<ul>
<li><p> Winikoff, Beverly, 2019, &quot;Two randomized controlled trials of misoprostol for the treatment of postpartum hemorrhage&quot;, https://doi.org/10.7910/DVN/ETHH4N, Harvard Dataverse, V1.
</p>
</li></ul>

<p>The data was originally analyzed in
</p>

<ul>
<li><p> Blum, J. et al. Treatment of post-partum haemorrhage with sublingual misoprostol versus oxytocin in women receiving prophylactic oxytocin: a double-blind, randomised, non-inferiority trial. The Lancet 375, 217&ndash;223 (2010).
</p>
</li></ul>


<hr>
<h2 id='predict.bp'>Predict method for barycentric projection models</h2><span id='topic+predict.bp'></span>

<h3>Description</h3>

<p>Predict method for barycentric projection models
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'bp'
predict(
  object,
  newdata = NULL,
  source.sample,
  cost_function = NULL,
  niter = 1000,
  tol = 1e-07,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="predict.bp_+3A_object">object</code></td>
<td>
<p>An object of class &quot;bp&quot;</p>
</td></tr>
<tr><td><code id="predict.bp_+3A_newdata">newdata</code></td>
<td>
<p>a data.frame containing new observations</p>
</td></tr>
<tr><td><code id="predict.bp_+3A_source.sample">source.sample</code></td>
<td>
<p>a vector giving the sample each observations arise from</p>
</td></tr>
<tr><td><code id="predict.bp_+3A_cost_function">cost_function</code></td>
<td>
<p>a cost metric between observations</p>
</td></tr>
<tr><td><code id="predict.bp_+3A_niter">niter</code></td>
<td>
<p>number of iterations to run the barycentric projection for powers &gt; 2.</p>
</td></tr>
<tr><td><code id="predict.bp_+3A_tol">tol</code></td>
<td>
<p>Tolerance on the optimization problem for projections with powers &gt; 2.</p>
</td></tr>
<tr><td><code id="predict.bp_+3A_...">...</code></td>
<td>
<p>Dots passed to the lbfgs method in the torch package.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>if(torch::torch_is_installed()) {
set.seed(23483)
n &lt;- 2^5
pp &lt;- 6
overlap &lt;- "low"
design &lt;- "A"
estimate &lt;- "ATT"
power &lt;- 2
data &lt;- causalOT::Hainmueller$new(n = n, p = pp,
design = design, overlap = overlap)

data$gen_data()

weights &lt;- causalOT::calc_weight(x = data,
  z = NULL, y = NULL,
  estimand = estimate,
  method = "NNM")
  
 df &lt;- data.frame(y = data$get_y(), z = data$get_z(), data$get_x())
  
 # undebiased
 fit &lt;- causalOT::barycentric_projection(y ~ ., data = df, 
    weight = weights,
    separate.samples.on = "z", niter = 2)
    
 #debiased
 fit_d &lt;- causalOT::barycentric_projection(y ~ ., data = df, 
    weight = weights,
    separate.samples.on = "z", debias = TRUE, niter = 2)
 
 # predictions, without new data
 undebiased_predictions &lt;- predict(fit,   source.sample = df$z)
 debiased_predictions   &lt;- predict(fit_d, source.sample = df$z)
 
 isTRUE(all.equal(unname(undebiased_predictions), df$y)) # FALSE
 isTRUE(all.equal(unname(debiased_predictions), df$y)) # TRUE
 }
</code></pre>

<hr>
<h2 id='print.dataHolder'>print.dataHolder</h2><span id='topic+print.dataHolder'></span>

<h3>Description</h3>

<p>print.dataHolder
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'dataHolder'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.dataHolder_+3A_x">x</code></td>
<td>
<p>dataHolder object</p>
</td></tr>
<tr><td><code id="print.dataHolder_+3A_...">...</code></td>
<td>
<p>Not used</p>
</td></tr>
</table>

<hr>
<h2 id='PSIS'>Pareto-Smoothed Importance Sampling</h2><span id='topic+PSIS'></span><span id='topic+PSIS+2Cnumeric-method'></span><span id='topic+PSIS+2CcausalWeights-method'></span><span id='topic+PSIS+2Clist-method'></span><span id='topic+PSIS_diag'></span><span id='topic+PSIS_diag+2Cnumeric-method'></span><span id='topic+PSIS_diag+2CcausalWeights-method'></span><span id='topic+PSIS_diag+2CcausalPSIS-method'></span><span id='topic+PSIS_diag+2Clist-method'></span><span id='topic+PSIS_diag+2Cpsis-method'></span>

<h3>Description</h3>

<p>Pareto-Smoothed Importance Sampling
</p>


<h3>Usage</h3>

<pre><code class='language-R'>PSIS(x, r_eff = NULL, ...)

## S4 method for signature 'numeric'
PSIS(x, r_eff = NULL, ...)

## S4 method for signature 'causalWeights'
PSIS(x, r_eff = NULL, ...)

## S4 method for signature 'list'
PSIS(x, r_eff = NULL, ...)

PSIS_diag(x, ...)

## S4 method for signature 'numeric'
PSIS_diag(x, r_eff = NULL)

## S4 method for signature 'causalWeights'
PSIS_diag(x, r_eff = NULL)

## S4 method for signature 'causalPSIS'
PSIS_diag(x, ...)

## S4 method for signature 'list'
PSIS_diag(x, r_eff = NULL)

## S4 method for signature 'psis'
PSIS_diag(x, r_eff = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="PSIS_+3A_x">x</code></td>
<td>
<p>For <code>PSIS()</code>, a vector of weights,
an object of class <a href="#topic+causalWeights-class">causalWeights</a>,
or a list with slots  &quot;w0&quot; and &quot;w1&quot;. For <code>PSIS_diag</code>,
the results of a run of <code>PSIS()</code>.</p>
</td></tr>
<tr><td><code id="PSIS_+3A_r_eff">r_eff</code></td>
<td>
<p>A vector of relative effective sample size with one estimate per observation. If providing
an object of class <a href="#topic+causalWeights-class">causalWeights</a>, should be a list of vectors with one vector for each
sample. See <a href="loo.html#topic+psis">psis()</a> from the <code>loo</code> package for more details. Updates to the <code>loo</code> package now make it so this
parameter should be ignored.</p>
</td></tr>
<tr><td><code id="PSIS_+3A_...">...</code></td>
<td>
<p>Arguments passed to the <a href="loo.html#topic+psis">psis()</a> function.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Acts as a wrapper to the <a href="loo.html#topic+psis">psis()</a> function from the <code>loo</code> package. It
is built to handle the data types found in this package. This method is preferred to the <code><a href="#topic+ESS">ESS()</a></code>
function in <code>causalOT</code> since the latter is prone to error (infinite variances) but will not give good any indication that the estimates
are problematic.
</p>


<h3>Value</h3>

<p>For <code>PSIS()</code>, returns a list. See <a href="loo.html#topic+psis">psis()</a> from <code>loo</code> for a description of the outputs. Will give the log of the
smoothed weights in slot <code>log_weights</code>, and in the slot <code>diagnostics</code>, it will give
the <code>pareto_k</code> parameter (see the <a href="loo.html#topic+pareto-k-diagnostic">pareto-k-diagnostic</a> page) and
the <code>n_eff</code> estimates. <code>PSIS_diag()</code> returns the diagnostic slot from an object of class &quot;psis&quot;.
</p>


<h3>Methods (by class)</h3>


<ul>
<li> <p><code>PSIS(numeric)</code>: numeric weights
</p>
</li>
<li> <p><code>PSIS(causalWeights)</code>: object of class causalWeights
</p>
</li>
<li> <p><code>PSIS(list)</code>: list of weights
</p>
</li>
<li> <p><code>PSIS_diag(numeric)</code>: numeric weights
</p>
</li>
<li> <p><code>PSIS_diag(causalWeights)</code>: object of class causalWeights diagnostics
</p>
</li>
<li> <p><code>PSIS_diag(causalPSIS)</code>: diagnostics from the output of a previous call to PSIS
</p>
</li>
<li> <p><code>PSIS_diag(list)</code>: a list of objects
</p>
</li>
<li> <p><code>PSIS_diag(psis)</code>: output of PSIS function
</p>
</li></ul>


<h3>See Also</h3>

<p><a href="#topic+ESS">ESS()</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- runif(100)
w &lt;- x/sum(x)

res &lt;- PSIS(x = w, r_eff = 1)
PSIS_diag(res)
</code></pre>

<hr>
<h2 id='PSIS.causalWeights'>PSIS casualWeights class</h2><span id='topic+PSIS.causalWeights'></span>

<h3>Description</h3>

<p>PSIS casualWeights class
</p>


<h3>Usage</h3>

<pre><code class='language-R'>PSIS.causalWeights(x, r_eff = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="PSIS.causalWeights_+3A_x">x</code></td>
<td>
<p>object of class causalWeights</p>
</td></tr>
<tr><td><code id="PSIS.causalWeights_+3A_r_eff">r_eff</code></td>
<td>
<p>pass to PSIS</p>
</td></tr>
<tr><td><code id="PSIS.causalWeights_+3A_...">...</code></td>
<td>
<p>pass to PSIS method</p>
</td></tr>
</table>


<h3>Value</h3>

<p>object of class causalPSIS
</p>

<hr>
<h2 id='sbwOptions'>Options for the SBW method</h2><span id='topic+sbwOptions'></span>

<h3>Description</h3>

<p>Options for the SBW method
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sbwOptions(delta = NULL, grid.length = 20L, nboot = 1000L, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sbwOptions_+3A_delta">delta</code></td>
<td>
<p>A number or vector of tolerances for the balancing functions. Default is NULL which will use a grid search</p>
</td></tr>
<tr><td><code id="sbwOptions_+3A_grid.length">grid.length</code></td>
<td>
<p>The number of values to try in the grid search</p>
</td></tr>
<tr><td><code id="sbwOptions_+3A_nboot">nboot</code></td>
<td>
<p>The number of bootstrap samples to run during the grid search.</p>
</td></tr>
<tr><td><code id="sbwOptions_+3A_...">...</code></td>
<td>
<p>Arguments passed on to <a href="osqp.html#topic+osqpSettings">osqpSettings()</a></p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of class <code>sbwOptions</code> with slots
</p>

<ul>
<li> <p><code>delta</code> Delta values to try
</p>
</li>
<li> <p><code>grid.length</code> The number of parameters to try
</p>
</li>
<li> <p><code>sumto1</code> Forced to be TRUE. Weights will always sum to 1.
</p>
</li>
<li> <p><code>nboot</code> Number of bootstrap samples
</p>
</li>
<li> <p><code>solver.options</code>A list with arguments passed to <a href="osqp.html#topic+osqpSettings">osqpSettings()</a>
</p>
</li></ul>



<h3>Function balancing</h3>

<p>This method will balance  functions of the covariates within some tolerance, <code class="reqn">\delta</code>. For these functions <code class="reqn">B</code>, we will desire
</p>
<p style="text-align: center;"><code class="reqn">\frac{\sum_{i: Z_i = 0} w_i B(x_i) - \sum_{j: Z_j = 1} B(x_j)/n_1}{\sigma} \leq \delta</code>
</p>
<p>, where in this case we are targeting balance with the treatment group for the ATT. <code class="reqn">\sigma</code> is the pooled standard deviation prior to balancing.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>opts &lt;- sbwOptions(delta = 0.1)
</code></pre>

<hr>
<h2 id='scmOptions'>Options for the SCM Method</h2><span id='topic+scmOptions'></span>

<h3>Description</h3>

<p>Options for the SCM Method
</p>


<h3>Usage</h3>

<pre><code class='language-R'>scmOptions(...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="scmOptions_+3A_...">...</code></td>
<td>
<p>Arguments passed to the <a href="osqp.html#topic+osqpSettings">osqpSettings()</a> function which solves the problem.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Options for the solver used in the optimization of the Synthetic Control Method of Abadie and Gardeazabal (2003).
</p>


<h3>Value</h3>

<p>A list with arguments to pass to <a href="osqp.html#topic+osqpSettings">osqpSettings()</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>opts &lt;- scmOptions()
</code></pre>

<hr>
<h2 id='summary.causalWeights'>Summary diagnostics for causalWeights</h2><span id='topic+summary.causalWeights'></span><span id='topic+print.summary_causalWeights'></span><span id='topic+plot.summary_causalWeights'></span>

<h3>Description</h3>

<p>Summary diagnostics for causalWeights
</p>
<p>print.summary_causalWeights
</p>
<p>plot.summary_causalWeights
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'causalWeights'
summary(
  object,
  r_eff = NULL,
  penalty,
  p = 2,
  cost = NULL,
  debias = TRUE,
  online.cost = "auto",
  diameter = NULL,
  niter = 1000,
  tol = 1e-07,
  ...
)

## S3 method for class 'summary_causalWeights'
print(x, ...)

## S3 method for class 'summary_causalWeights'
plot(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary.causalWeights_+3A_object">object</code></td>
<td>
<p>an object of class <a href="#topic+causalWeights-class">causalWeights</a></p>
</td></tr>
<tr><td><code id="summary.causalWeights_+3A_r_eff">r_eff</code></td>
<td>
<p>The r_eff used in the PSIS calculation. See <code><a href="#topic+PSIS_diag">PSIS_diag()</a></code></p>
</td></tr>
<tr><td><code id="summary.causalWeights_+3A_penalty">penalty</code></td>
<td>
<p>The penalty parameter to use</p>
</td></tr>
<tr><td><code id="summary.causalWeights_+3A_p">p</code></td>
<td>
<p>The power of the Lp distance to use. Overridden by argument <code>cost.</code></p>
</td></tr>
<tr><td><code id="summary.causalWeights_+3A_cost">cost</code></td>
<td>
<p>A user supplied cost function. Should take arguments <code>x1</code>, <code>x2</code>, <code>p</code>.</p>
</td></tr>
<tr><td><code id="summary.causalWeights_+3A_debias">debias</code></td>
<td>
<p>Should debiased optimal transport distances be used. TRUE or FALSE</p>
</td></tr>
<tr><td><code id="summary.causalWeights_+3A_online.cost">online.cost</code></td>
<td>
<p>Should the cost be calculated online? One of &quot;auto&quot;,&quot;tensorized&quot;, or &quot;online&quot;.</p>
</td></tr>
<tr><td><code id="summary.causalWeights_+3A_diameter">diameter</code></td>
<td>
<p>the diameter of the covariate space. Default is NULL.</p>
</td></tr>
<tr><td><code id="summary.causalWeights_+3A_niter">niter</code></td>
<td>
<p>the number of iterations to run the optimal transport distances</p>
</td></tr>
<tr><td><code id="summary.causalWeights_+3A_tol">tol</code></td>
<td>
<p>the tolerance for convergence for the optimal transport distances</p>
</td></tr>
<tr><td><code id="summary.causalWeights_+3A_...">...</code></td>
<td>
<p>Not used</p>
</td></tr>
<tr><td><code id="summary.causalWeights_+3A_x">x</code></td>
<td>
<p>an object of class &quot;summary_causalWeights&quot;</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The summary method returns an object of class &quot;summary_causalWeights&quot;.
</p>


<h3>Functions</h3>


<ul>
<li> <p><code>print(summary_causalWeights)</code>: print method
</p>
</li>
<li> <p><code>plot(summary_causalWeights)</code>: plot method
</p>
</li></ul>


<h3>Examples</h3>

<pre><code class='language-R'>if(torch::torch_is_installed()) {
n &lt;- 2^6
p &lt;- 6
overlap &lt;- "high"
design &lt;- "A"
estimand &lt;- "ATE"

#### get simulation functions ####
original &lt;- Hainmueller$new(n = n, p = p, 
                            design = design, overlap = overlap)
original$gen_data()
weights &lt;- calc_weight(x = original, estimand = estimand, method = "Logistic")
s &lt;- summary(weights)
plot(s)
}
</code></pre>

<hr>
<h2 id='supported_methods'>Supported Methods</h2><span id='topic+supported_methods'></span>

<h3>Description</h3>

<p>Supported Methods
</p>


<h3>Usage</h3>

<pre><code class='language-R'>supported_methods()
</code></pre>


<h3>Value</h3>

<p>A character list with supported methods. Note &quot;COT&quot; is the same as &quot;Wasserstein&quot;. We provide the second name for backwards compatibility.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>supported_methods()
</code></pre>

<hr>
<h2 id='vcov.causalEffect'>Get the variance of a causalEffect</h2><span id='topic+vcov.causalEffect'></span>

<h3>Description</h3>

<p>Get the variance of a causalEffect
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'causalEffect'
vcov(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="vcov.causalEffect_+3A_object">object</code></td>
<td>
<p>An object of class <a href="#topic+causalEffect-class">causalEffect</a></p>
</td></tr>
<tr><td><code id="vcov.causalEffect_+3A_...">...</code></td>
<td>
<p>Passed on to the sandwich estimator if there is a model fit that supports one</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The variance of the treatment effect as a matrix
</p>


<h3>Examples</h3>

<pre><code class='language-R'># set-up data
set.seed(1234)
data &lt;- Hainmueller$new()
data$gen_data()

# calculate quantities
weight &lt;- calc_weight(data, estimand = "ATT", method = "Logistic")
tx_eff &lt;- estimate_effect(causalWeights = weight)

vcov(tx_eff)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
