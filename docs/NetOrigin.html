<!DOCTYPE html><html lang="en"><head><title>Help for package NetOrigin</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {NetOrigin}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#NetOrigin'><p>Origin Estimation for Propagation Processes on Complex Networks</p></a></li>
<li><a href='#aggr_data'><p>convert individual event information to aggregated information per network node</p></a></li>
<li><a href='#analyze_ptn'><p>analyze public transportation network characteristics</p></a></li>
<li><a href='#compute_mu_lambda'><p>Compute Mu and Lambda for Source Detection Function</p></a></li>
<li><a href='#delay-data'><p>Delay propagation data examples simulated by LinTim software</p></a></li>
<li><a href='#eff_dist'><p>Computation of effective path distance</p></a></li>
<li><a href='#initial_condition_sib_model'><p>Provide Initial Condition for Function SIB_SS</p></a></li>
<li><a href='#origin'><p>Origin Estimation for Propagation Processes on Complex Networks</p></a></li>
<li><a href='#origin_multiple'><p>Multiple origin estimation using community partitioning</p></a></li>
<li><a href='#origin-methods'><p>methods for origin estimation objects of class <code>origin</code></p></a></li>
<li><a href='#performance'><p>generic method for performance evaluation</p></a></li>
<li><a href='#plot_performance'><p>A plot method combining a time series of performance results.</p></a></li>
<li><a href='#plot_ptn'><p>A plot method for public transportation networks (PTNs).</p></a></li>
<li><a href='#ptn-data'><p>Public transportation network datasets from LinTim software (Integrated Optimization in Public Transportation)</p></a></li>
<li><a href='#read_DB_data'><p>Reads a data file as provided by 'Deutsche Bahn' (for internal use).</p></a></li>
<li><a href='#robustness'><p>run robustness analysis for a source estimate by subsampling individual events.</p></a></li>
<li><a href='#robustness-methods'><p>methods for robustness estimation objects of class <code>robustness</code></p></a></li>
<li><a href='#stochastic_sib_model'><p>Stochastic SIB model for infected cases simulation</p></a></li>
<li><a href='#var_wtd_mean_cochran'><p>Computes the variance of a weighted mean following the definition by Cochran (1977; see Gatz and Smith, 1995)</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Title:</td>
<td>Origin Estimation for Propagation Processes on Complex Networks</td>
</tr>
<tr>
<td>Description:</td>
<td>Performs network-based source estimation. Different approaches are available: effective distance median, recursive backtracking, and centrality-based source estimation. Additionally, we provide public transportation network data as well as methods for data preparation, source estimation performance analysis and visualization.</td>
</tr>
<tr>
<td>Version:</td>
<td>1.1-6</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.2.2)</td>
</tr>
<tr>
<td>Imports:</td>
<td>igraph, Hmisc, colorspace, mvtnorm, corpcor, plyr, dplyr,
tibble</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>Collate:</td>
<td>'0_helper_net.r' 'NetOrigin.r' 'compute_mu_lambda.R'
'origin_helper.r' 'origin_methods.r' 'distance.r' 'data.r'
'data_handling.r' 'initial_condition_sib_model.R'
'robustness.r' 'stochastic_sib_model.R'</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-09-04 20:21:44 UTC; M254773</td>
</tr>
<tr>
<td>Author:</td>
<td>Juliane Manitz [aut, cre],
  Jonas Harbering [ctb],
  Jun Li [ctb]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Juliane Manitz &lt;r@manitz.org&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://netorigin.manitz.org/">https://netorigin.manitz.org/</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/jmanitz/NetOrigin/issues">https://github.com/jmanitz/NetOrigin/issues</a></td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-09-04 20:40:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='NetOrigin'>Origin Estimation for Propagation Processes on Complex Networks</h2><span id='topic+NetOrigin'></span><span id='topic+NetOrigin-package'></span>

<h3>Description</h3>

<p>Performs different approaches for network-based source estimation: effective distance median, recursive backtracking, and centrality-based source estimation. Additionally, we provide public transportation network data as well as methods for data preparation, source estimation performance analysis and visualization.
</p>


<h3>Details</h3>

<p>The main function for origin estimation of propagation processes on complex network is <code><a href="#topic+origin">origin</a></code>. Different methods are available: effective distance median (<code>'edm'</code>), recursive backtracking (<code>'backtracking'</code>), and centrality-based source estimation (<code>'centrality'</code>).
For more details on the methodological background, we refer to the corresponding publications.
</p>


<h3>Author(s)</h3>

<p>Juliane Manitz with contributions by Jonas Harbering
</p>


<h3>References</h3>


<ul>
<li><p> Manitz, J., J. Harbering, M. Schmidt, T. Kneib, and A. Schoebel (2017): Source Estimation for Propagation Processes on Complex Networks with an Application to Delays in Public Transportation Systems. Journal of Royal Statistical Society C (Applied Statistics), 66: 521-536.
</p>
</li>
<li><p> Manitz, J., Kneib, T., Schlather, M., Helbing, D. and Brockmann, D. (2014) Origin detection during food-borne disease outbreaks - a case study of the 2011 EHEC/HUS outbreak in Germany. PLoS Currents Outbreaks, 1. &lt;DOI: 10.1371/currents.outbreaks.f3fdeb08c5b9de7c09ed9cbcef5f01f2&gt;
</p>
</li>
<li><p> Comin, C. H. and da Fontoura Costa, L. (2011) Identifying the starting point of a spreading process in complex networks. Physical Review E, 84. &lt;DOI: 10.1103/PhysRevE.84.056105&gt;
</p>
</li></ul>


<hr>
<h2 id='aggr_data'>convert individual event information to aggregated information per network node</h2><span id='topic+aggr_data'></span>

<h3>Description</h3>

<p>convert individual event information to aggregated information per network node
</p>


<h3>Usage</h3>

<pre><code class='language-R'>aggr_data(dat, from = NULL, cumsum = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="aggr_data_+3A_dat">dat</code></td>
<td>
<p><code>data.frame</code> with variables <code>'node'</code>, <code>'time'</code>, <code>'delay'</code>, events data with single events with count magnitude</p>
</td></tr>
<tr><td><code id="aggr_data_+3A_from">from</code></td>
<td>
<p>character in <code><a href="base.html#topic+strftime">strftime</a></code> format, e.g. <code>"2014-06-12 16:15"</code>, data is subsetted accordingly before aggregation</p>
</td></tr>
<tr><td><code id="aggr_data_+3A_cumsum">cumsum</code></td>
<td>
<p>logical indicating whether data is aggregated by cumulative sum, default is <code>TRUE</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>data.frame</code> of dimension <code>(TxK)</code>, where <code>T</code> is the number of observation times and <code>K</code> the number of network nodes. Thus, each row represents a snapshot of the spreading process at a specific observation time with the event magnitude observed at the network nodes. Rownames are observation times, colnames are node names.
</p>


<h3>See Also</h3>

<p>Other data_handling: 
<code><a href="#topic+read_DB_data">read_DB_data</a>()</code>
</p>

<hr>
<h2 id='analyze_ptn'>analyze public transportation network characteristics</h2><span id='topic+analyze_ptn'></span>

<h3>Description</h3>

<p>analyze public transportation network characteristics
</p>


<h3>Usage</h3>

<pre><code class='language-R'>analyze_ptn(g)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="analyze_ptn_+3A_g">g</code></td>
<td>
<p><code><a href="igraph.html#topic+igraph">igraph</a></code> object, network graph representing the public transportation network, vertices represent stations, which are linked by an edge if there is a direct transfer between them</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>'data.frame':</code> 1 obs. of 7 variables: 
</p>

<ul>
<li> <p><code>vcount</code> number of nodes, 
</p>
</li>
<li> <p><code>ecount</code> number of edges, 
</p>
</li>
<li> <p><code>density</code> network graph density, 
</p>
</li>
<li> <p><code>av_deg</code> average degree, 
</p>
</li>
<li> <p><code>av_cent</code> average unit betweenness,
</p>
</li>
<li> <p><code>diam</code> diameter, and 
</p>
</li>
<li> <p><code>trans</code> transitivity.
</p>
</li></ul>



<h3>References</h3>

<p>Details to the computation and interpretation can be found in:</p>

<ul>
<li><p> Kolaczyk, E. D. (2009). Statistical analysis of network data: methods and models. Springer series in statistics. Springer. &lt;DOI: 10.1007/978-0-387-88146-1&gt;
</p>
</li>
<li><p> Manitz, J. (2014): Statistical Inference for Propagation Processes on Complex Networks. Ph.D. thesis, Georg-August-University Goettingen. Verlag Dr.~Hut, ISBN 978-3-8439-1668-4. Available online: <a href="https://ediss.uni-goettingen.de/handle/11858/00-1735-0000-0022-5F38-B">https://ediss.uni-goettingen.de/handle/11858/00-1735-0000-0022-5F38-B</a>.
</p>
</li></ul>



<h3>See Also</h3>

<p>Other network helper: 
<code><a href="#topic+plot_ptn">plot_ptn</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(ptnAth)
analyze_ptn(ptnAth)

data(ptnGoe)
analyze_ptn(ptnGoe)

</code></pre>

<hr>
<h2 id='compute_mu_lambda'>Compute Mu and Lambda for Source Detection Function</h2><span id='topic+compute_mu_lambda'></span>

<h3>Description</h3>

<p><code>compute_mu_lambda</code> computes 'mu' and 'lambda' from training data and 
selected observers, for Gaussian source estimation with prior information
</p>


<h3>Usage</h3>

<pre><code class='language-R'>compute_mu_lambda(train.data, obs.vec, candidate.thres)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="compute_mu_lambda_+3A_train.data">train.data</code></td>
<td>
<p>training data for 'mu' and 'lambda' list computation
format-list, length-number of cities/nodes
format of train.data[[i]]- number of simulated scenarios x number of cities/nodes, each entry is minimum arrival time</p>
</td></tr>
<tr><td><code id="compute_mu_lambda_+3A_obs.vec">obs.vec</code></td>
<td>
<p>list of cities ids used as observers</p>
</td></tr>
<tr><td><code id="compute_mu_lambda_+3A_candidate.thres">candidate.thres</code></td>
<td>
<p>threshold to determine if a node/city could be a candidate for source
e.g. if we set this number to be 0.2, if in [x] simulated scenarios, there are only 10 percent
scenarios a node [a] is infected, we do not think [a] is a potential source</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list, consisting of 3 variables: mu.mat, lambda.list, poss.candidate.vec
mu.mat: matrix- number of cities/nodes x number of observers, each row represents- 
if this node is the source, the mean of arrival time vector;
lambda.list: a length-number of cities/nodes list, each element is a number of observers x number of observers matrix-
if a node is the source, the covariance matrix for arrival time vector;
poss.candidate.vec: a boolean vector indicating if a node has the potential to be the source
</p>


<h3>Author(s)</h3>

<p>Jun Li
</p>


<h3>References</h3>

<p>Li, J., Manitz, J., Bertuzzo, E. and Kolaczyk, E.D. (2020). Sensor-based localization of epidemic sources on human mobility networks. arXiv preprint Available online: <a href="https://arxiv.org/abs/2011.00138">https://arxiv.org/abs/2011.00138</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# fake training data, indicating format
nnodes &lt;- 851
max.day &lt;- 1312
nsimu &lt;- 20
train.data.fake &lt;- list()
for (j in 1:nnodes) {
  train.data.fake[[j]] &lt;- matrix(sample.int(max.day, 
    size = nsimu*nnodes, replace = TRUE), nrow = nsimu, ncol = nnodes)
}
obs.vec &lt;- (1:9)
candidate.thres &lt;- 0.3
mu.lambda.list &lt;- compute_mu_lambda(train.data.fake, obs.vec, candidate.thres)


</code></pre>

<hr>
<h2 id='delay-data'>Delay propagation data examples simulated by LinTim software</h2><span id='topic+delay-data'></span><span id='topic+delayAth'></span><span id='topic+delayGoe'></span>

<h3>Description</h3>

<p>Delay propagation data examples simulated by LinTim software
</p>
<p><code>delayAth</code> Delay propagation data generated on the Athens metro network by LinTim software
</p>
<p><code>delayGoe</code> Delay propagation data generated on the Goettingen bus system by LinTim software
</p>


<h3>Details</h3>

<p><code>delayAth</code> Delay data on the Athens metro network. Propagation simulation under consideration of secruity distances and fixed-waiting time delay management. 'data.frame' with 510 observations (10 sequential time pictures for delay spreading pattern from 51 stations) of 53 variables (<code>k0</code> true source, <code>time</code>, delays at 51 stations).
</p>
<p><code>delayGoe</code> Delay data on the directed Goettingen bus system. Progation simulation under consideration of secruity distances and fixed-waiting time delay management. 'data.frame' with 2570 observations (10 sequential time pictures for delay spreading pattern from 257 stations) of 259 variables (<code>k0</code> true source, <code>time</code>, delays at 257 stations).
</p>


<h3>Author(s)</h3>

<p>Jonas Harbering
</p>


<h3>Source</h3>

<p>Public transportation network datasets are generated by LinTim software (Integrated Optimization in Public Transportation; <a href="https://lintim.net/">https://lintim.net/</a>).
</p>


<h3>References</h3>

<p>Manitz, J., J. Harbering, M. Schmidt, T. Kneib, and A. Schoebel (2017): Source Estimation for Propagation Processes on Complex Networks with an Application to Delays in Public Transportation Systems. Journal of Royal Statistical Society C (Applied Statistics), 66: 521-536.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+ptn-data">ptn-data</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run:  
# compute effective distance
data(ptnAth)
athnet &lt;- igraph::as_adjacency_matrix(ptnAth, sparse=FALSE)
p &lt;- athnet/rowSums(athnet)
eff &lt;- eff_dist(p)
# apply source estimation
data(delayAth)
res &lt;- plyr::alply(.data=delayAth[,-c(1:2)], .margins=1, .fun=origin_edm, distance=eff,
             silent=TRUE, .progress='text')
perfAth &lt;- plyr::ldply(Map(performance, x = res, start = as.list(delayAth$k0),  
                     list(graph = ptnAth)))

## End(Not run)
## Not run:  
# compute effective distance
data(ptnGoe)
goenet &lt;- igraph::as_adjacency_matrix(ptnGoe, sparse=FALSE)
p &lt;- goenet/rowSums(goenet)
eff &lt;- eff_dist(p)
# apply source estimation
data(delayGoe)
res &lt;- plyr::alply(.data=delayGoe[,-c(1:2)], .margins=1, .fun=origin_edm, distance=eff,
             silent=TRUE, .progress='text')
perfGoe &lt;- plyr::ldply(Map(performance, x = res, start = as.list(delayGoe$k0), 
                     list(graph = ptnGoe)))

## End(Not run)
</code></pre>

<hr>
<h2 id='eff_dist'>Computation of effective path distance</h2><span id='topic+eff_dist'></span><span id='topic+eff_dijkstra'></span><span id='topic+spd_dijkstra'></span>

<h3>Description</h3>

<p><code>eff_dist</code> computes the effective distance between all nodes in the network
</p>


<h3>Usage</h3>

<pre><code class='language-R'>eff_dist(p)

eff_dijkstra(p, start)

spd_dijkstra(p, start)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="eff_dist_+3A_p">p</code></td>
<td>
<p>numeric matrix, representing the transition probability matrix for the network graph</p>
</td></tr>
<tr><td><code id="eff_dist_+3A_start">start</code></td>
<td>
<p>start of path</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A numeric matrix, representing the effective distance between all nodes in the network graph.
</p>


<h3>References</h3>


<ul>
<li><p> Dijkstra, E. W. (1959): A note on two problems in connexion with graphs. Numerische Mathematik, 1, 269-271. &lt;DOI: 10.1007/BF01386390&gt;
</p>
</li>
<li><p> Brockmann, D. and Helbing, D. (2013): The hidden geometry of complex, network-driven contagion phenomena. Science, 342, 1337-1342. &lt;DOI: 10.1126/science.1245200&gt;
</p>
</li>
<li><p> Manitz, J. (2014): Statistical Inference for Propagation Processes on Complex Networks. Ph.D. thesis, Georg-August-University Goettingen. Verlag Dr. Hut, ISBN 978-3-8439-1668-4. Available online: <a href="https://ediss.uni-goettingen.de/handle/11858/00-1735-0000-0022-5F38-B">https://ediss.uni-goettingen.de/handle/11858/00-1735-0000-0022-5F38-B</a>.
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'># compute effective shortest path distance
data(ptnAth)
require(igraph)
net &lt;- igraph::as_adjacency_matrix(ptnAth, sparse=FALSE)
p &lt;- net/rowSums(net)
eff &lt;- eff_dist(p)

# compute shortest path distance
data(ptnAth)
athnet &lt;- as_adj(ptnAth, sparse=FALSE)
spd &lt;- spd_dijkstra(athnet, start=1)

# compare calculations with the one from igraph
spd_igraph &lt;- igraph::distances(ptnAth, v=1, algorithm='dijkstra')
all(spd[[1]] == spd_igraph)

</code></pre>

<hr>
<h2 id='initial_condition_sib_model'>Provide Initial Condition for Function SIB_SS</h2><span id='topic+initial_condition_sib_model'></span>

<h3>Description</h3>

<p><code>initial_condition_sib_model</code> Compute Initial Condition for Function SIB_SS
</p>


<h3>Usage</h3>

<pre><code class='language-R'>initial_condition_sib_model(
  POP_node,
  sigma,
  mu_B,
  theta,
  node_in,
  in_prevalence = 0.001
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="initial_condition_sib_model_+3A_pop_node">POP_node</code></td>
<td>
<p>vector, length represents number of cities/nodes; vector represents
population at each node</p>
</td></tr>
<tr><td><code id="initial_condition_sib_model_+3A_sigma">sigma</code></td>
<td>
<p>symptomatic ratio, i.e., fraction of infected people that develop symptoms and are infective. 
(The remaining fraction enters directly the recovered compartment.)</p>
</td></tr>
<tr><td><code id="initial_condition_sib_model_+3A_mu_b">mu_B</code></td>
<td>
<p>death rate of V.cholerae in the aquatic environment (day^-1)</p>
</td></tr>
<tr><td><code id="initial_condition_sib_model_+3A_theta">theta</code></td>
<td>
<p>contamination rate</p>
</td></tr>
<tr><td><code id="initial_condition_sib_model_+3A_node_in">node_in</code></td>
<td>
<p>index/indices for initial infected node(s)</p>
</td></tr>
<tr><td><code id="initial_condition_sib_model_+3A_in_prevalence">in_prevalence</code></td>
<td>
<p>initial prevalence of symptomatic infected in a node, default is 0.1%</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a 5 x number of nodes matrix, each row represents the following for all the nodes:
Row 1: number of suspectible people, i.e., population excpect infected and recovered for each node;
Row 2: number of infected people;
Row 3: number of recovered people;
Row 4: bacteria concentration in equilibrium with infected individuals;
Row 2: number of infected people, but representing cumulative cases
</p>


<h3>Author(s)</h3>

<p>Jun Li
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(2020)
popu &lt;- rep(20000, 10)
sigma &lt;- 0.05
mu_B &lt;- 0.2
theta_max &lt;- 16
theta &lt;- runif(10, 0.1, 0.9) * theta_max
y0 &lt;- initial_condition_sib_model(popu, sigma, mu_B, theta, c(3))
</code></pre>

<hr>
<h2 id='origin'>Origin Estimation for Propagation Processes on Complex Networks</h2><span id='topic+origin'></span><span id='topic+origin_edm'></span><span id='topic+origin_backtracking'></span><span id='topic+origin_centrality'></span><span id='topic+origin_bayesian'></span>

<h3>Description</h3>

<p>This is the main function for origin estimation for propagation processes on complex networks. Different methods are available: effective distance median (<code>'edm'</code>), recursive backtracking (<code>'backtracking'</code>), and centrality-based source estimation (<code>'centrality'</code>).
For details on the methodological background, we refer to the corresponding publications.
</p>
<p><code>origin_edm</code> for effective distance-median origin estimation (Manitz et al., 2016)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>origin(events, type = c("edm", "backtracking", "centrality", "bayesian"), ...)

origin_edm(events, distance, silent = TRUE)

origin_backtracking(events, graph, start_with_event_node = TRUE, silent = TRUE)

origin_centrality(events, graph, silent = TRUE)

origin_bayesian(
  events,
  thres.vec,
  obs.vec,
  mu.mat,
  lambda.list,
  poss.candidate.vec,
  prior,
  use.prior = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="origin_+3A_events">events</code></td>
<td>
<p>numeric vector of event counts at a specific time point; if type is 'bayesian', 'events' is a matrix, number of nodes x time points; entries represent number of cases</p>
</td></tr>
<tr><td><code id="origin_+3A_type">type</code></td>
<td>
<p>character specifying the method, <code>'edm'</code>, <code>'backtracking'</code>, <code>'centrality'</code> and <code>'bayesian'</code> are available.</p>
</td></tr>
<tr><td><code id="origin_+3A_...">...</code></td>
<td>
<p>parameters to be passed to origin methods <code><a href="#topic+origin_edm">origin_edm</a></code>, <code><a href="#topic+origin_backtracking">origin_backtracking</a></code>, <code><a href="#topic+origin_centrality">origin_centrality</a></code> or <code><a href="#topic+origin_centrality">origin_centrality</a></code></p>
</td></tr>
<tr><td><code id="origin_+3A_distance">distance</code></td>
<td>
<p>numeric matrix specifying the distance matrix (for <code>type='edm'</code>)</p>
</td></tr>
<tr><td><code id="origin_+3A_silent">silent</code></td>
<td>
<p>locigal, should the messages be suppressed?</p>
</td></tr>
<tr><td><code id="origin_+3A_graph">graph</code></td>
<td>
<p>igraph object specifying the underlying network graph (for <code>type='backtracking'</code> and <code>type='centrality'</code>)</p>
</td></tr>
<tr><td><code id="origin_+3A_start_with_event_node">start_with_event_node</code></td>
<td>
<p>logical specifying whether backtracking only starts from nodes that experienced events (for <code>type='backtracking'</code>)</p>
</td></tr>
<tr><td><code id="origin_+3A_thres.vec">thres.vec</code></td>
<td>
<p>vector, length represents number of cities/nodes, representing thresholds for cities/nodes that they are infected</p>
</td></tr>
<tr><td><code id="origin_+3A_obs.vec">obs.vec</code></td>
<td>
<p>list of cities ids used as observers</p>
</td></tr>
<tr><td><code id="origin_+3A_mu.mat">mu.mat</code></td>
<td>
<p>matrix- number of cities/nodes x number of observers, each row represents - if this node is the source, the mean of arrival time vector</p>
</td></tr>
<tr><td><code id="origin_+3A_lambda.list">lambda.list</code></td>
<td>
<p>a length-number of cities/nodes list, each element is a number of observers x number of observers matrix - if a node is the source, the covariance matrix for arrival time vector</p>
</td></tr>
<tr><td><code id="origin_+3A_poss.candidate.vec">poss.candidate.vec</code></td>
<td>
<p>a boolean vector indicating if a node has the potential to be the source</p>
</td></tr>
<tr><td><code id="origin_+3A_prior">prior</code></td>
<td>
<p>vector, length - number of cities/nodes, prior for cities</p>
</td></tr>
<tr><td><code id="origin_+3A_use.prior">use.prior</code></td>
<td>
<p>boolean, TRUE or FALSE, if use prior, default TRUE</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>origin_edm</code> returns an object of class <code>origin</code>, list with 
</p>

<ul>
<li> <p><code>est</code> origin estimate
</p>
</li>
<li> <p><code>aux</code> <code>data.frame</code> with auxiliary variables 
</p>

<ul>
<li> <p><code>id</code> as node identifier, 
</p>
</li>
<li> <p><code>events</code> for event magnitude, 
</p>
</li>
<li> <p><code>wmean</code> for weighted mean, 
</p>
</li>
<li> <p><code>wvar</code> for weighted variance, and 
</p>
</li>
<li> <p><code>mdist</code> mean distance from a node to all other nodes.
</p>
</li></ul>

</li>
<li> <p><code>type = 'edm'</code> effective distance median origin estimation
</p>
</li></ul>

<p><code>origin_backtracking</code> returns an object of class <code>origin</code>, list with 
</p>

<ul>
<li> <p><code>est</code> origin estimate
</p>
</li>
<li> <p><code>aux</code> <code>data.frame</code> with auxiliary variables 
</p>

<ul>
<li> <p><code>id</code> as node identifier, 
</p>
</li>
<li> <p><code>events</code> for event magnitude, and
</p>
</li>
<li> <p><code>bcount</code> for backtracking counts, how often backtracking identifies this source node.
</p>
</li></ul>

</li>
<li> <p><code>type = 'backtracking'</code> backtracking origin estimation
</p>
</li></ul>

<p><code>origin_centrality</code> returns an object of class <code>origin</code>, list with 
</p>

<ul>
<li> <p><code>est</code> origin estimate
</p>
</li>
<li> <p><code>aux</code> <code>data.frame</code> with auxiliary variables 
</p>

<ul>
<li> <p><code>id</code> as node identifier, 
</p>
</li>
<li> <p><code>events</code> for event magnitude, and
</p>
</li>
<li> <p><code>cent</code> for node centrality (betweenness divided degree).
</p>
</li></ul>

</li>
<li> <p><code>type = 'centrality'</code> centrality-based origin estimation
</p>
</li></ul>

<p>a dataframe with columns 'nodes' and 'probab', indicating nodes indices and their posteriors
</p>


<h3>Author(s)</h3>

<p>Juliane Manitz with contributions by Jonas Harbering
</p>
<p>Jun Li
</p>


<h3>References</h3>


<ul>
<li><p> Comin, C. H. and da Fontoura Costa, L. (2011). Identifying the starting point of a spreading process in complex networks. Physical Review E, 84. &lt;doi: 10.1103/PhysRevE.84.056105&gt;
</p>
</li>
<li><p> Manitz, J., J. Harbering, M. Schmidt, T. Kneib, and A. Schoebel (2017): Source Estimation for Propagation Processes on Complex Networks with an Application to Delays in Public Transportation Systems. Journal of Royal Statistical Society C (Applied Statistics), 66: 521-536. &lt;doi: 10.1111/rssc.12176&gt;
</p>
</li>
<li><p> Manitz, J. (2014). Statistical Inference for Propagation Processes on Complex Networks. Ph.D. thesis, Georg-August-University Goettingen. Verlag Dr.~Hut, ISBN 978-3-8439-1668-4. Available online: <a href="https://ediss.uni-goettingen.de/handle/11858/00-1735-0000-0022-5F38-B">https://ediss.uni-goettingen.de/handle/11858/00-1735-0000-0022-5F38-B</a>.
</p>
</li>
<li><p> Manitz, J., Kneib, T., Schlather, M., Helbing, D. and Brockmann, D. (2014). Origin detection during food-borne disease outbreaks - a case study of the 2011 EHEC/HUS outbreak in Germany. PLoS Currents Outbreaks, 1. &lt;doi: 10.1371/currents.outbreaks.f3fdeb08c5b9de7c09ed9cbcef5f01f2&gt;
</p>
</li>
<li><p> Li, J., Manitz, J., Bertuzzo, E. and Kolaczyk, E.D. (2020). Sensor-based localization of epidemic sources on human mobility networks. arXiv preprint Available online: <a href="https://arxiv.org/abs/2011.00138">https://arxiv.org/abs/2011.00138</a>.
</p>
</li></ul>



<h3>See Also</h3>

<p>Other origin-est: 
<code><a href="#topic+origin_multiple">origin_multiple</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(delayGoe)

# compute effective distance
data(ptnGoe)
goenet &lt;- igraph::as_adjacency_matrix(ptnGoe, sparse=FALSE)
p &lt;- goenet/rowSums(goenet)
eff &lt;- eff_dist(p)
# apply effective distance median source estimation
om &lt;- origin(events=delayGoe[10,-c(1:2)], type='edm', distance=eff)
summary(om)
plot(om, 'mdist',start=1)
plot(om, 'wvar',start=1)
performance(om, start=1, graph=ptnGoe)

# backtracking origin estimation (Manitz et al., 2016)
ob &lt;- origin(events=delayGoe[10,-c(1:2)], type='backtracking', graph=ptnGoe)
summary(ob)
plot(ob, start=1)
performance(ob, start=1, graph=ptnGoe)

# centrality-based origin estimation (Comin et al., 2011)
oc &lt;- origin(events=delayGoe[10,-c(1:2)], type='centrality', graph=ptnGoe)
summary(oc)
plot(oc, start=1)
performance(oc, start=1, graph=ptnGoe)

# fake training data, indicating format
nnodes &lt;- 851
max.day &lt;- 1312
nsimu &lt;- 20
max.case.per.day &lt;- 10
train.data.fake &lt;- list()
for (j in 1:nnodes) {
  train.data.fake[[j]] &lt;- matrix(sample.int(max.day, 
    size = nsimu*nnodes, replace = TRUE), nrow = nsimu, ncol = nnodes)
}
obs.vec &lt;- (1:9)
candidate.thres &lt;- 0.3
mu.lambda.list &lt;- compute_mu_lambda(train.data.fake, obs.vec, candidate.thres)
# matrix representing number of cases per node per day
cases.node.day &lt;- matrix(sample.int(max.case.per.day, 
  size = nnodes*max.day, replace = TRUE), nrow = nnodes, ncol = max.day)
nnodes &lt;- dim(cases.node.day)[1] # number of nodes
# fixed threshold for all nodes - 10 infected people
thres.vec &lt;- rep(10, nnodes)
# flat/non-informative prior
prior &lt;- rep(1, nnodes) 
result2.df &lt;- origin(events = cases.node.day, type = "bayesian",
                     thres.vec = thres.vec,
                     obs.vec = obs.vec,
                     mu.mat=mu.lambda.list$mu.mat, lambda.list = mu.lambda.list$lambda.list, 
                     poss.candidate.vec=mu.lambda.list$poss.candidate.vec,
                     prior=prior, use.prior=TRUE)

</code></pre>

<hr>
<h2 id='origin_multiple'>Multiple origin estimation using community partitioning</h2><span id='topic+origin_multiple'></span>

<h3>Description</h3>

<p>Multiple origin estimation using community partitioning
</p>


<h3>Usage</h3>

<pre><code class='language-R'>origin_multiple(
  events,
  type = c("edm", "backtracking", "centrality"),
  graph,
  no = 2,
  distance,
  fast = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="origin_multiple_+3A_events">events</code></td>
<td>
<p>numeric vector of event counts at specific time point</p>
</td></tr>
<tr><td><code id="origin_multiple_+3A_type">type</code></td>
<td>
<p>character specifying the method, <code>'edm'</code>, <code>'backtracking'</code> and <code>'centrality'</code> are available.</p>
</td></tr>
<tr><td><code id="origin_multiple_+3A_graph">graph</code></td>
<td>
<p>igraph object specifying the underlying network graph</p>
</td></tr>
<tr><td><code id="origin_multiple_+3A_no">no</code></td>
<td>
<p>numeric specifying the number of supposed origins</p>
</td></tr>
<tr><td><code id="origin_multiple_+3A_distance">distance</code></td>
<td>
<p>numeric matrix specifying the distance matrix</p>
</td></tr>
<tr><td><code id="origin_multiple_+3A_fast">fast</code></td>
<td>
<p>logical specifying community partitioning algorithm, default is <code>'TRUE'</code> that uses <code><a href="igraph.html#topic+fastgreedy.community">fastgreedy.community</a></code>, <code>'FALSE'</code> refers to <code><a href="igraph.html#topic+leading.eigenvector.community">leading.eigenvector.community</a></code></p>
</td></tr>
<tr><td><code id="origin_multiple_+3A_...">...</code></td>
<td>
<p>parameters to be passed to origin methods <code><a href="#topic+origin_edm">origin_edm</a></code>, <code><a href="#topic+origin_backtracking">origin_backtracking</a></code> or <code><a href="#topic+origin_centrality">origin_centrality</a></code></p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>origin_multiple</code> returns an list object with objects of class <code><a href="#topic+origin">origin</a></code> of length <code>no</code>
</p>


<h3>References</h3>

<p>Zang, W., Zhang, P., Zhou, C. and Guo, L. (2014) Discovering Multiple Diffusion Source Nodes in Social Networks. Procedia Computer Science, 29, 443-452. &lt;DOI: 10.1016/j.procs.2014.05.040&gt;
</p>


<h3>See Also</h3>

<p>Other origin-est: 
<code><a href="#topic+origin">origin</a>()</code>
</p>

<hr>
<h2 id='origin-methods'>methods for origin estimation objects of class <code>origin</code></h2><span id='topic+origin-methods'></span><span id='topic+print.origin'></span><span id='topic+summary.origin'></span><span id='topic+plot.origin'></span><span id='topic+performance.origin'></span>

<h3>Description</h3>

<p><code>print</code> produces an output for objects of class <code>origin</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'origin'
print(x, ...)

## S3 method for class 'origin'
summary(object, x = object, ...)

## S3 method for class 'origin'
plot(x, y = "id", start, ...)

## S3 method for class 'origin'
performance(x, start, graph = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="origin-methods_+3A_x">x</code></td>
<td>
<p>object of class <code><a href="#topic+origin">origin</a></code>, origin estimation object from function <code>origin_xxx</code></p>
</td></tr>
<tr><td><code id="origin-methods_+3A_...">...</code></td>
<td>
<p>further arguments to be passed to default <code>plot</code> function</p>
</td></tr>
<tr><td><code id="origin-methods_+3A_object">object</code></td>
<td>
<p>object of class <code><a href="#topic+origin">origin</a></code>, origin estimation object from function <code>origin_xxx</code>; passed to <code>x</code></p>
</td></tr>
<tr><td><code id="origin-methods_+3A_y">y</code></td>
<td>
<p>character specifying the variable being plotted at the y-axis; options are <code>'id'</code> for node identifier (default), <code>'mdist'</code> for mean distance (only available for <code><a href="#topic+origin_edm">origin_edm</a></code>) or <code>'wvar'</code> for weighted variance (only available for <code><a href="#topic+origin_edm">origin_edm</a></code>)</p>
</td></tr>
<tr><td><code id="origin-methods_+3A_start">start</code></td>
<td>
<p>numeric, giving the node of the true origin</p>
</td></tr>
<tr><td><code id="origin-methods_+3A_graph">graph</code></td>
<td>
<p><code><a href="igraph.html#topic+igraph">igraph</a></code> object specifying the underlying network graph with attribute 'length' on edges for calculation of distance to the correct origin</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>performance.origin</code> returns a <code>data.frame</code> with variables
</p>

<ul>
<li> <p><code>origin = start</code> representing the true origin, 
</p>
</li>
<li> <p><code>est</code> the estimated node of origin, 
</p>
</li>
<li> <p><code>hitt</code> logical indicating whether origin estimation is correct or not, 
</p>
</li>
<li> <p><code>rank</code> rank of correct detection, 
</p>
</li>
<li> <p><code>spj</code> number of segments from estimated origin to true origin (requires an <code><a href="igraph.html#topic+igraph">igraph</a></code> object), 
</p>
</li>
<li> <p><code>dist</code> distance along the shortest path from estimated origin to true origin (<code><a href="igraph.html#topic+igraph">igraph</a></code> edge attribute <code>length</code>)
</p>
</li></ul>



<h3>See Also</h3>

<p><code><a href="#topic+origin">origin</a></code> <code><a href="#topic+plot_performance">plot_performance</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(ptnGoe)
data(delayGoe)

res &lt;- origin(events=delayGoe[10,-c(1:2)], type='centrality', graph=ptnGoe)
res

summary(res)
plot(res, start=1)
performance(res, start=1, graph=ptnGoe)

</code></pre>

<hr>
<h2 id='performance'>generic method for performance evaluation</h2><span id='topic+performance'></span>

<h3>Description</h3>

<p>generic method for performance evaluation
</p>


<h3>Usage</h3>

<pre><code class='language-R'>performance(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="performance_+3A_x">x</code></td>
<td>
<p>object</p>
</td></tr>
<tr><td><code id="performance_+3A_...">...</code></td>
<td>
<p>further arguments</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+origin-methods">origin-methods</a></code> <code><a href="#topic+plot_performance">plot_performance</a></code>
</p>

<hr>
<h2 id='plot_performance'>A plot method combining a time series of performance results.</h2><span id='topic+plot_performance'></span>

<h3>Description</h3>

<p>A plot method combining a time series of performance results.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot_performance(
  x,
  var = "rank",
  add = FALSE,
  offset = NULL,
  log = FALSE,
  col = 1,
  ylim = NULL,
  text.padding = 0.9,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot_performance_+3A_x">x</code></td>
<td>
<p><code>data.frame</code> obtained by combined results from <code><a href="#topic+performance.origin">performance.origin</a></code> with variables <code>X1</code> for time point, <code>start</code> for true origin, <code>est</code> for estimated origin, and performance variables</p>
</td></tr>
<tr><td><code id="plot_performance_+3A_var">var</code></td>
<td>
<p>character, variable to be plotted, <code><a href="#topic+performance.origin">performance.origin</a></code> returns <code>rank</code>, <code>spj</code>, and <code>dist</code>, default is <code>'rank'</code></p>
</td></tr>
<tr><td><code id="plot_performance_+3A_add">add</code></td>
<td>
<p>logical, should be added to another performance plot</p>
</td></tr>
<tr><td><code id="plot_performance_+3A_offset">offset</code></td>
<td>
<p><code>POSIXct</code>, starting time of spreading</p>
</td></tr>
<tr><td><code id="plot_performance_+3A_log">log</code></td>
<td>
<p>logical, should y-axis be logarithmized?</p>
</td></tr>
<tr><td><code id="plot_performance_+3A_col">col</code></td>
<td>
<p>numeric or character, color of lines</p>
</td></tr>
<tr><td><code id="plot_performance_+3A_ylim">ylim</code></td>
<td>
<p>numeric vector, range of y axis</p>
</td></tr>
<tr><td><code id="plot_performance_+3A_text.padding">text.padding</code></td>
<td>
<p>a numeric value specifying the factor for the text position relative to the y values</p>
</td></tr>
<tr><td><code id="plot_performance_+3A_...">...</code></td>
<td>
<p>further graphical parameters passed to default <code>plot</code> function</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run:  
### delays on Goettingen bus network
# compute effective distance
data(ptnGoe)
goenet &lt;- igraph::as_adjacency_matrix(ptnGoe, sparse=FALSE)
p &lt;- goenet/rowSums(goenet)
eff &lt;- eff_dist(p)
# apply source estimation
data(delayGoe)
if (requireNamespace("aplyr", quietly = TRUE)) {
   res &lt;- alply(.data=delayGoe[11:20,-c(1:2)], .margins=1, .fun=origin_edm, 
                distance=eff, silent=TRUE, .progress='text')
   perfGoe &lt;- ldply(Map(performance, x = res, start = 2, list(graph = ptnGoe)))
   # performance plots
   plot_performance(perfGoe, var='rank', ylab='rank of correct detection', text.padding=0.5)
   plot_performance(perfGoe, var='dist', ylab='distance to correct detection')
}

### delays on Athens metro network
# compute effective distance
data(ptnAth)
athnet &lt;- igraph::as_adjacency_matrix(ptnAth, sparse=FALSE)
p &lt;- athnet/rowSums(athnet)
eff &lt;- eff_dist(p)
# apply source estimation
data(delayAth)
if (requireNamespace("aplyr", quietly = TRUE)) {
   res &lt;- alply(.data=delayAth[11:20,-c(1:2)], .margins=1, .fun=origin_edm, 
             distance=eff, silent=TRUE, .progress='text')
   perfAth &lt;- ldply(Map(performance, x = res, start = as.list(delayAth$k0),
                     list(graph = ptnAth)))
   # performance plots
   plot_performance(perfAth, var='rank', ylab='rank of correct detection',text.padding=0.5)
   plot_performance(perfAth, var='dist', ylab='distance to correct detection')
}

## End(Not run)
</code></pre>

<hr>
<h2 id='plot_ptn'>A plot method for public transportation networks (PTNs).</h2><span id='topic+plot_ptn'></span>

<h3>Description</h3>

<p>A plot method for public transportation networks (PTNs).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot_ptn(
  g,
  color.coding = NULL,
  color.scheme = rev(sequential_hcl(5)),
  legend = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot_ptn_+3A_g">g</code></td>
<td>
<p><code><a href="igraph.html#topic+igraph">igraph</a></code> object, network graph representing the public transportation network, vetrices represent stations, which are linked by an edge if there is a direct transfer between them</p>
</td></tr>
<tr><td><code id="plot_ptn_+3A_color.coding">color.coding</code></td>
<td>
<p>numeric vector with length equal to the number of network nodes</p>
</td></tr>
<tr><td><code id="plot_ptn_+3A_color.scheme">color.scheme</code></td>
<td>
<p>character vector of length 5 indicating the <code>vertex.color</code>, default is <code>rev(sequential_hcl(5))</code></p>
</td></tr>
<tr><td><code id="plot_ptn_+3A_legend">legend</code></td>
<td>
<p>logical indicating whether legend for color-coding should be added or not.</p>
</td></tr>
<tr><td><code id="plot_ptn_+3A_...">...</code></td>
<td>
<p>further arguments to be passed to <code><a href="igraph.html#topic+plot.igraph">plot.igraph</a></code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>No return value
</p>


<h3>See Also</h3>

<p>Other network helper: 
<code><a href="#topic+analyze_ptn">analyze_ptn</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(ptnAth)
plot_ptn(ptnAth)

data(ptnGoe)
plot_ptn(ptnGoe)

</code></pre>

<hr>
<h2 id='ptn-data'>Public transportation network datasets from LinTim software (Integrated Optimization in Public Transportation)</h2><span id='topic+ptn-data'></span><span id='topic+ptnAth'></span><span id='topic+ptnGoe'></span>

<h3>Description</h3>

<p>Public transportation network datasets from LinTim software (Integrated Optimization in Public Transportation)
</p>
<p><code>ptnAth</code> The data of the Athens Metro, consisting of 51 nodes and 52 edges. 
</p>

<ul>
<li><p> Vertex attributes: station name, additonal station info. 
</p>
</li>
<li><p> Edge attributes: track length (in meter), minimal and maximal time required to pass the track (in minutes).
</p>
</li></ul>

<p><code>ptnGoe</code> The data of the Goettingen bus network, consisting of 257 nodes and 548 edges. </p>

<ul>
<li><p> Vertex attributes: station name. 
</p>
</li>
<li><p> Edge attributes:  track length (in meter), minimal and maximal time required to pass the track (in minutes).
</p>
</li></ul>



<h3>Author(s)</h3>

<p>Juliane Manitz and Jonas Harbering
</p>


<h3>Source</h3>

<p>Public transportation network datasets are extracted from LinTim software (Integrated Optimization in Public Transportation; <a href="https://lintim.net/">https://lintim.net/</a>). Special thanks to Anita Schoebel for making the data available.
</p>
<p>The Athens Metro data was collected by Konstantinos Gkoumas.
</p>
<p>The Goettingen bus network data was collected by Barbara Michalski.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+delay-data">delay-data</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Athens metro system 
data(ptnAth)
plot_ptn(ptnAth)

# Goettingen bus system 
data(ptnGoe)
plot_ptn(ptnGoe)

</code></pre>

<hr>
<h2 id='read_DB_data'>Reads a data file as provided by 'Deutsche Bahn' (for internal use).</h2><span id='topic+read_DB_data'></span>

<h3>Description</h3>

<p>Reads a data file as provided by 'Deutsche Bahn' (for internal use).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>read_DB_data(file)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="read_DB_data_+3A_file">file</code></td>
<td>
<p>character with path and file name containing the variables for  'stationID', 'date', 'hour', 'minutes', and 'delay'</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>data.frame</code> with variables <code>'node'</code>, <code>'time'</code>, <code>'delay'</code>
</p>


<h3>See Also</h3>

<p>Other data_handling: 
<code><a href="#topic+aggr_data">aggr_data</a>()</code>
</p>

<hr>
<h2 id='robustness'>run robustness analysis for a source estimate by subsampling individual events.</h2><span id='topic+robustness'></span>

<h3>Description</h3>

<p>run robustness analysis for a source estimate by subsampling individual events.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>robustness(
  x,
  type = c("edm", "backtracking", "centrality"),
  prop,
  n = 100,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="robustness_+3A_x">x</code></td>
<td>
<p><code>data.frame</code>, dataset with individual events and their magnitude, to be passed to <code><a href="#topic+aggr_data">aggr_data</a></code></p>
</td></tr>
<tr><td><code id="robustness_+3A_type">type</code></td>
<td>
<p>character, specifying the method, <code>'edm'</code>, <code>'backtracking'</code> and <code>'centrality'</code> are available.</p>
</td></tr>
<tr><td><code id="robustness_+3A_prop">prop</code></td>
<td>
<p>numeric, value between zero and one, proportion of events to be sampled</p>
</td></tr>
<tr><td><code id="robustness_+3A_n">n</code></td>
<td>
<p>numeric, number of resamplings</p>
</td></tr>
<tr><td><code id="robustness_+3A_...">...</code></td>
<td>
<p>parameters to be passed to origin methods <code><a href="#topic+origin_edm">origin_edm</a></code>, <code><a href="#topic+origin_backtracking">origin_backtracking</a></code> or <code><a href="#topic+origin_centrality">origin_centrality</a></code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>We create subsamples of individual events and their magnitude using a sampling proportion p in [0, 1]. After aggregating the data, we apply the source estimation approach. Using this result, we deduce the relative frequency of how often the source estimate obtained with the complete data set can be recovered by source estimation based on the subsample. Thus, the estimate robustness is assessed by the proportion of estimate recovery.
</p>


<h3>Value</h3>

<p><code>data.frame</code> with columns
</p>

<ul>
<li> <p><code>est</code> origin estimated when all data is evaluated
</p>
</li>
<li> <p><code>rob</code> estimate uncertainty, computed as the proportion of resamplings when origin estimate was recovered
</p>
</li></ul>



<h3>See Also</h3>

<p><code><a href="#topic+robustness-methods">robustness-methods</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># generate random delay data
data(ptnAth)
require(igraph)
dat &lt;- data.frame(node  = sample(size = 500, make.names(V(ptnAth)$name), replace = TRUE),
                  time  = sample(size = 500, 1:10, replace = TRUE),
                  delay = rexp(500, rate=10))
# compute effective distance 
net &lt;- igraph::as_adjacency_matrix(ptnAth, sparse=FALSE)
p &lt;- net/rowSums(net)
eff &lt;- eff_dist(p)
colnames(eff) &lt;- paste('x.',colnames(eff),sep='')

# run robustness analysis
r5 &lt;- robustness(x=dat, type='edm', prop=0.5, n=10, distance=eff)
summary(r5)
plot(r5)

# compare results
r9 &lt;- robustness(x=dat, type='edm', prop=0.9, n=10, distance=eff)
plot(r9, add=TRUE, col='gray')

</code></pre>

<hr>
<h2 id='robustness-methods'>methods for robustness estimation objects of class <code>robustness</code></h2><span id='topic+robustness-methods'></span><span id='topic+print.robustness'></span><span id='topic+summary'></span><span id='topic+plot'></span><span id='topic+summary.robustness'></span><span id='topic+plot.robustness'></span>

<h3>Description</h3>

<p><code>print</code> produces an output for objects of class <code>robustness</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'robustness'
print(x, ...)

## S3 method for class 'robustness'
summary(object, x = object, ...)

## S3 method for class 'robustness'
plot(x, y = NULL, add = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="robustness-methods_+3A_x">x</code></td>
<td>
<p><code>data.frame</code> obtained by <code><a href="#topic+robustness">robustness</a></code>, robustness estimation object for source estimation from function <code><a href="#topic+robustness">robustness</a></code></p>
</td></tr>
<tr><td><code id="robustness-methods_+3A_...">...</code></td>
<td>
<p>further arguments passed to the default <code>print</code> method</p>
</td></tr>
<tr><td><code id="robustness-methods_+3A_object">object</code></td>
<td>
<p>object of class <code><a href="#topic+origin">origin</a></code>, origin estimation object from function <code>origin_xxx</code>; passed to <code>x</code></p>
</td></tr>
<tr><td><code id="robustness-methods_+3A_y">y</code></td>
<td>
<p>not used; default <code>NULL</code></p>
</td></tr>
<tr><td><code id="robustness-methods_+3A_add">add</code></td>
<td>
<p>logical specifying whether this should be added to another robustness plot</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+robustness">robustness</a></code>
</p>

<hr>
<h2 id='stochastic_sib_model'>Stochastic SIB model for infected cases simulation</h2><span id='topic+stochastic_sib_model'></span>

<h3>Description</h3>

<p><code>stochastic_sib_model</code> Stochastic SIB model for infected cases simulation
</p>


<h3>Usage</h3>

<pre><code class='language-R'>stochastic_sib_model(
  mu,
  beta,
  rho,
  sigma,
  gamma,
  alpha,
  mu_B,
  m = 0.3,
  theta,
  nnodes,
  POP_node,
  fluxes,
  time_sim,
  y0
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="stochastic_sib_model_+3A_mu">mu</code></td>
<td>
<p>population natality and mortality rate (day^-1)</p>
</td></tr>
<tr><td><code id="stochastic_sib_model_+3A_beta">beta</code></td>
<td>
<p>contact rate</p>
</td></tr>
<tr><td><code id="stochastic_sib_model_+3A_rho">rho</code></td>
<td>
<p>immunity loss rate (day^-1)</p>
</td></tr>
<tr><td><code id="stochastic_sib_model_+3A_sigma">sigma</code></td>
<td>
<p>symptomatic ratio, i.e., fraction of infected people that develop symptoms and are infective. 
(The remaining fraction enters directly the recovered compartment.)</p>
</td></tr>
<tr><td><code id="stochastic_sib_model_+3A_gamma">gamma</code></td>
<td>
<p>rate at which people recover from cholera (day^-1)</p>
</td></tr>
<tr><td><code id="stochastic_sib_model_+3A_alpha">alpha</code></td>
<td>
<p>cholera induced mortality rate (day^-1)</p>
</td></tr>
<tr><td><code id="stochastic_sib_model_+3A_mu_b">mu_B</code></td>
<td>
<p>death rate of V.cholerae in the aquatic environment (day^-1)</p>
</td></tr>
<tr><td><code id="stochastic_sib_model_+3A_m">m</code></td>
<td>
<p>parameter for infection force, default value is 0.3</p>
</td></tr>
<tr><td><code id="stochastic_sib_model_+3A_theta">theta</code></td>
<td>
<p>contamination rate</p>
</td></tr>
<tr><td><code id="stochastic_sib_model_+3A_nnodes">nnodes</code></td>
<td>
<p>number of nodes/cities</p>
</td></tr>
<tr><td><code id="stochastic_sib_model_+3A_pop_node">POP_node</code></td>
<td>
<p>vector, length represents number of cities/nodes; vector represents
population at each node</p>
</td></tr>
<tr><td><code id="stochastic_sib_model_+3A_fluxes">fluxes</code></td>
<td>
<p>matrix, number of nodes x number of nodes 
where each row contains the probabilities a person travels from the given city (by Row Index) to another city (by Column Index).</p>
</td></tr>
<tr><td><code id="stochastic_sib_model_+3A_time_sim">time_sim</code></td>
<td>
<p>time steps for simulation, e.g., seq(0, 100, 0.1)</p>
</td></tr>
<tr><td><code id="stochastic_sib_model_+3A_y0">y0</code></td>
<td>
<p>initial condition for stochastic_sib_model, output of 'initial_condition_sib_model'</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a matrix, nnodes x number of time steps, representing number of new cases at each node, each time step
</p>


<h3>Author(s)</h3>

<p>Jun Li
</p>


<h3>References</h3>

<p>Li, J., Manitz, J., Bertuzzo, E. and Kolaczyk, E.D. (2020). Sensor-based localization of epidemic sources on human mobility networks. arXiv preprint Available online: <a href="https://arxiv.org/abs/2011.00138">https://arxiv.org/abs/2011.00138</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(2020)
popu &lt;- rep(20000, 10)
sigma &lt;- 0.05
mu_B &lt;- 0.2
theta_max &lt;- 16
theta &lt;- runif(10, 0.1, 0.9) * theta_max
y0 &lt;- initial_condition_sib_model(popu, sigma, mu_B, theta, c(3))
time_sim &lt;- seq(0, 1, by=0.1)
mu &lt;- 4e-05
beta_max &lt;- 1 
rho &lt;- 0
beta &lt;- runif(10, 0.1, 0.9) * beta_max
gamma &lt;- 0.2
alpha &lt;- 0
humanmob.mass &lt;- matrix(runif(100, 0.1, 0.9), 10, 10)
diag(humanmob.mass) &lt;- 0
for (j in 1:10) {
  humanmob.mass[j, ] &lt;- humanmob.mass[j, ]/sum(humanmob.mass[j, ])
}
simu.list = stochastic_sib_model(mu = mu, beta = beta, rho = rho, sigma = sigma, gamma = gamma,
                   alpha = alpha, mu_B = mu_B, theta = theta, nnodes = 10, POP_node = popu,
                   fluxes = humanmob.mass, time_sim = time_sim, y0 = y0)
</code></pre>

<hr>
<h2 id='var_wtd_mean_cochran'>Computes the variance of a weighted mean following the definition by Cochran (1977; see Gatz and Smith, 1995)</h2><span id='topic+var_wtd_mean_cochran'></span>

<h3>Description</h3>

<p>This is a helper method for weighted variance computation in <code><a href="#topic+origin_edm">origin_edm</a></code>, which is the closest to the bootstrap.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>var_wtd_mean_cochran(x, w)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="var_wtd_mean_cochran_+3A_x">x</code></td>
<td>
<p>numeric vector of values</p>
</td></tr>
<tr><td><code id="var_wtd_mean_cochran_+3A_w">w</code></td>
<td>
<p>numeric vector of weights</p>
</td></tr>
</table>


<h3>Value</h3>

<p>numeric value of weighted variance
</p>


<h3>References</h3>


<ul>
<li><p> Gatz, D. F., and Smith, L. (1995). The standard error of a weighted mean concentration-I. Bootstrapping vs other methods. Atmospheric Environment, 29(11), 1185-1193. &lt;DOI: 10.1016/1352-2310(94)00210-C&gt;
</p>
</li>
<li><p> Gatz, D. F., and Smith, L. (1995). The standard error of a weighted mean concentration-II. Estimating confidence intervals. Atmospheric Environment, 29(11), 1195-1200. &lt;DOI: 10.1016/1352-2310(94)00209-4&gt;
</p>
</li></ul>


</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
