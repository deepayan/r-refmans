<!DOCTYPE html><html lang="en"><head><title>Help for package statforbiology</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {statforbiology}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#AMMI'>
<p>AMMI analysis for multienvironment genotype experiments</p></a></li>
<li><a href='#angularTransform'><p>Angular transformation for percentages</p></a></li>
<li><a href='#anova.aovlist'><p>Prints an ANOVA table for an 'aovList' object</p></a></li>
<li><a href='#asymReg'><p>Asymptotic functions</p></a></li>
<li><a href='#beetGrowth'><p>Growth of sugarbeet in weed-infested and weed-free conditions</p></a></li>
<li><a href='#biplot.AMMIobj'>
<p>Biplots for AMMI and GGE analyses of multi-environment genotype experiments</p></a></li>
<li><a href='#boxcox.nls'><p>Transform-both-sides (TBS) method for nonlinear regression</p></a></li>
<li><a href='#check.hom'>
<p>Check linear models for homoscedasticity</p></a></li>
<li><a href='#compCoefs'><p>Pairwise comparisons of model parameters for nls objects</p></a></li>
<li><a href='#compCurves'><p>Compare regression curves in a pairwise fashion</p></a></li>
<li><a href='#contr.Tukey'>
<p>Pairwise contrast matrix</p></a></li>
<li><a href='#CVA'><p> Canonical variate analysis for multienvironment and multitrait genotype experiments</p></a></li>
<li><a href='#degradation'><p>Soil degradation kinetic for a herbicide</p></a></li>
<li><a href='#deviance.drc'>
<p>Residual deviance for a non-linear regression fit.</p></a></li>
<li><a href='#expoDecay'><p>Exponential decay function</p></a></li>
<li><a href='#expoGrowth'><p>Exponential growth function</p></a></li>
<li><a href='#getAgroData'><p>Get one of the available datasets</p></a></li>
<li><a href='#getPlotData'><p>Get the data for plotting with ggplot()</p></a></li>
<li><a href='#GGE'>
<p>GGE analysis for multienvironment genotype experiments</p></a></li>
<li><a href='#gnlht'><p>Linear/nonlinear contrasts of model parameters</p></a></li>
<li><a href='#linear'><p>Simple linear regression functions</p></a></li>
<li><a href='#logCurve'><p>Logarithmic curve</p></a></li>
<li><a href='#ma'><p>Moving average for a vector</p></a></li>
<li><a href='#metamitron'><p>Degradation of metamitron in soil with co-applied herbicides</p></a></li>
<li><a href='#mixture'><p>Efficacy of the mixture of two herbicides</p></a></li>
<li><a href='#negExp'><p>Negative exponential functions</p></a></li>
<li><a href='#pairComp'><p>Pairwise comparisons between the numeric elements of a vector</p></a></li>
<li><a href='#plotnls'><p>Plotting diagnostics for an <code>nls</code> object</p></a></li>
<li><a href='#poly2'><p>Simple polynomial regression functions</p></a></li>
<li><a href='#R2nls'>
<p>Goodness of fit for nonlinear regression</p></a></li>
<li><a href='#SSbeta'><p>Beta equation</p></a></li>
<li><a href='#SSbragg'><p>Bragg's Equation</p></a></li>
<li><a href='#SScousens85'><p>Rectangular hyperbola for yield/weed density relationship</p></a></li>
<li><a href='#SSE'><p>Modified Gompertz equations</p></a></li>
<li><a href='#SSGompertz'><p>Gompertz equations</p></a></li>
<li><a href='#SSL'><p>Logistic equations</p></a></li>
<li><a href='#SSLL'><p>Log-logistic equation</p></a></li>
<li><a href='#SSlorentz'><p>Lorentz equation</p></a></li>
<li><a href='#SSpowerCurve'><p>Power curve equation</p></a></li>
<li><a href='#SSW1'><p>Weibull equation (Type I)</p></a></li>
<li><a href='#SSW2'><p>Weibull equation (Type II)</p></a></li>
<li><a href='#SSYL'><p>Yield loss equation (Rectangular hyperbola)</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Tools for Data Analyses in Biology</td>
</tr>
<tr>
<td>Version:</td>
<td>0.9.9</td>
</tr>
<tr>
<td>Description:</td>
<td>Contains several tools for nonlinear regression analyses and general data analysis in biology and agriculture. Contains also datasets for practicing and teaching purposes. Supports the blog: Onofri (2024) "Fixing the bridge between biologists and statisticians" <a href="https://www.statforbiology.com">https://www.statforbiology.com</a> and the book: Onofri (2024) "Experimental Methods in Agriculture" <a href="https://www.statforbiology.com/_statbookeng/">https://www.statforbiology.com/_statbookeng/</a>. The blog is a collection of short articles aimed at improving the efficiency of communication between biologists and statisticians, as pointed out in Kozak (2016) &lt;<a href="https://doi.org/10.1590%2F0103-9016-2015-0399">doi:10.1590/0103-9016-2015-0399</a>&gt;, spreading a better awareness of the potential usefulness, beauty and limitations of biostatistic.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/OnofriAndreaPG/statforbiology">https://github.com/OnofriAndreaPG/statforbiology</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/OnofriAndreaPG/statforbiology/issues">https://github.com/OnofriAndreaPG/statforbiology/issues</a></td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.5), drc</td>
</tr>
<tr>
<td>Imports:</td>
<td>ggplot2, tidyr, car, nlme, emmeans, methods, MASS, stats,
drcte, multcomp, utils, multcompView</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.3.1</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-10-18 15:30:43 UTC; andrea</td>
</tr>
<tr>
<td>Author:</td>
<td>Andrea Onofri [aut, cre]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Andrea Onofri &lt;andrea.onofri@unipg.it&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-10-21 12:00:08 UTC</td>
</tr>
</table>
<hr>
<h2 id='AMMI'>
AMMI analysis for multienvironment genotype experiments
</h2><span id='topic+AMMI'></span>

<h3>Description</h3>

<p>This function performs the AMMI (Addittive Main effects Multiplicative Interaction) analysis, according to Zobel et al (1988). The function has been described in Onofri and Ciriciofolo (2007).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>AMMI(yield, genotype, environment, block = NULL, PC = 2,
     MSE = NULL, dfr = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="AMMI_+3A_yield">yield</code></td>
<td>
<p>a vector containing yield levels</p>
</td></tr>
<tr><td><code id="AMMI_+3A_genotype">genotype</code></td>
<td>
<p>a vector containing genotype codings</p>
</td></tr>
<tr><td><code id="AMMI_+3A_environment">environment</code></td>
<td>
<p>a vector containing environment codings</p>
</td></tr>
<tr><td><code id="AMMI_+3A_block">block</code></td>
<td>
<p>a vector containing block codes for each environment</p>
</td></tr>
<tr><td><code id="AMMI_+3A_pc">PC</code></td>
<td>
<p>the number of PCs that one wants to extract</p>
</td></tr>
<tr><td><code id="AMMI_+3A_mse">MSE</code></td>
<td>
<p>Mean Squared Error</p>
</td></tr>
<tr><td><code id="AMMI_+3A_dfr">dfr</code></td>
<td>
<p>Residual Degrees of Freedom</p>
</td></tr>
</table>


<h3>Value</h3>

<p> Returns a list of class 'AMMIobject' with the following components
</p>
<table role = "presentation">
<tr><td><code>genotype_means</code></td>
<td>
<p>The overall least squares genotype means</p>
</td></tr>
<tr><td><code>environment_means</code></td>
<td>
<p>The overall least squares environment means</p>
</td></tr>
<tr><td><code>interaction_means</code></td>
<td>
<p>The least squares means for the genotype by environment combinations</p>
</td></tr>
<tr><td><code>interaction_effect</code></td>
<td>
<p>a two-way table of interaction effects</p>
</td></tr>
<tr><td><code>additive_ANOVA</code></td>
<td>
<p>an ANOVA table for the additive model</p>
</td></tr>
<tr><td><code>mult_Interaction</code></td>
<td>
<p>an ANOVA table for multiplicative model</p>
</td></tr>
<tr><td><code>MSE</code></td>
<td>
<p>Mean Square Error</p>
</td></tr>
<tr><td><code>dfr</code></td>
<td>
<p>Degrees of freedom for the MSE</p>
</td></tr>
<tr><td><code>environment_scores</code></td>
<td>
<p>a table of environment scores</p>
</td></tr>
<tr><td><code>genotype_scores</code></td>
<td>
<p>a table of genotype scores</p>
</td></tr>
<tr><td><code>stability</code></td>
<td>
<p>AMMI stability value (ASV; Mohammadi and Amri, 2008)</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Andrea Onofri
</p>


<h3>References</h3>

<p>Mohammadi, R., Amri, A., 2008. Comparison of parametric and non-parametric methods for selecting stable and adapted durum wheat genotypes in varibale environments. Euphytica 159, 419–432.
</p>
<p>Onofri, A., Ciriciofolo, E., 2007. Using R to perform the AMMI analysis on agriculture variety trials. R NEWS 7, 14–19.
</p>
<p>Zobel, R. W., Wright, M.J., and Gauch, H. G., 1988. Statistical analysis of a yield trial. Agronomy Journal, 388-393.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>WinterWheat &lt;- getAgroData("WinterWheat")
tab &lt;- with(WinterWheat, AMMI(Yield, Genotype, Year, Block, PC = 2))
tab
</code></pre>

<hr>
<h2 id='angularTransform'>Angular transformation for percentages</h2><span id='topic+angularTransform'></span>

<h3>Description</h3>

<p>Angular transformation for percentages
</p>


<h3>Usage</h3>

<pre><code class='language-R'>angularTransform(percentage)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="angularTransform_+3A_percentage">percentage</code></td>
<td>
<p>A number.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A number.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>angularTransform(25)
angularTransform(35.2)
</code></pre>

<hr>
<h2 id='anova.aovlist'>Prints an ANOVA table for an 'aovList' object</h2><span id='topic+anova.aovlist'></span>

<h3>Description</h3>

<p>A wrapper for the 'summary' method for objects of class 'aovlist'.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'aovlist'
anova(object, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="anova.aovlist_+3A_object">object</code></td>
<td>
<p>An object of class <code>"aovList"</code></p>
</td></tr>
<tr><td><code id="anova.aovlist_+3A_...">...</code></td>
<td>
<p>Other additional arguments</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <code>"summary.aovlist"</code>. It is a list (one object
per error stratum) of ANOVA tables (class <code>"anova"</code>) with a row for
each term in the model, plus one for <code>"Residuals"</code> if there
are any.
</p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+aov">aov</a></code>, <code><a href="base.html#topic+summary">summary</a></code>, <code><a href="stats.html#topic+model.tables">model.tables</a></code>,
<code><a href="stats.html#topic+TukeyHSD">TukeyHSD</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># A split-plot design
data(oats)
oats.aov &lt;- aov(Y ~ N*V + Error(B/V), data = oats)
anova(oats.aov)
emmeans::emmeans(oats.aov, ~N)
</code></pre>

<hr>
<h2 id='asymReg'>Asymptotic functions</h2><span id='topic+asymReg.fun'></span><span id='topic+NLS.asymReg'></span><span id='topic+DRC.asymReg'></span><span id='topic+DRC.SSasymp'></span>

<h3>Description</h3>

<p>These functions provide the asymptotic regression model (asymReg), the asymptotic regression function with self-starter for the <code><a href="stats.html#topic+nls">nls</a></code> function and the asymptotic regression function with self-starter for the <code><a href="drc.html#topic+drm">drm</a></code> function in the drc package. The 'DRC.SSasymp()' function provides the self-starter for drc, to fit the same function as in the 'SSasymp()' function in the 'nlme' package. The asymptotic regression model is also known as the Mitscherlich law in agriculture and as the von Bertalanffy law in fisheries research.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  asymReg.fun(predictor, init, m, plateau)
  NLS.asymReg(predictor, init, m, plateau)
  DRC.asymReg(fixed = c(NA, NA, NA), names = c("init", "m", "plateau"))
  DRC.SSasymp(fixed = c(NA, NA, NA), names = c("Asym", "R0", "lrc"))
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="asymReg_+3A_predictor">predictor</code></td>
<td>
<p>a numeric vector of values at which to evaluate the model</p>
</td></tr>
<tr><td><code id="asymReg_+3A_init">init</code></td>
<td>
<p>model parameter</p>
</td></tr>
<tr><td><code id="asymReg_+3A_m">m</code></td>
<td>
<p>model parameter</p>
</td></tr>
<tr><td><code id="asymReg_+3A_plateau">plateau</code></td>
<td>
<p>model parameter</p>
</td></tr>
<tr><td><code id="asymReg_+3A_fixed">fixed</code></td>
<td>
<p>numeric vector. Specifies which parameters are fixed and at what value they are fixed. NAs for parameter that are not fixed.</p>
</td></tr>
<tr><td><code id="asymReg_+3A_names">names</code></td>
<td>
<p>a vector of character strings giving the names of the parameters. The default is reasonable.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The asymptotic model is given by the following function:
</p>
<p style="text-align: center;"><code class="reqn"> f(x) = \textrm{plateau} - (\textrm{plateau} - \textrm{init}) \cdot \exp (- m x ) </code>
</p>

<p>A similar parameterisation where 'm' is replaced by exp(lrc) is provided in the 'nlme' package, with self-starter for the 'nls' function. Here, we provide the self-starter for the 'drm' function in the 'drc' package:
</p>
<p style="text-align: center;"><code class="reqn"> f(x) = \textrm{Asym} + (\textrm{R0} - \textrm{Asym}) \cdot \exp [- exp(lrc) x ] </code>
</p>



<h3>Value</h3>

<p>asymReg.fun and NLS. asymReg return a numeric value, while DRC.asymReg and DRC.SSasymp return a list containing the nonlinear function, the self starter function and the parameter names.
</p>


<h3>Note</h3>

<p>DRC.asymReg and DRC.SSasymp are for use with the function <code><a href="drc.html#topic+drm">drm</a></code>.</p>


<h3>Author(s)</h3>

<p>Andrea Onofri</p>


<h3>References</h3>

<p>Ratkowsky, DA (1990) Handbook of nonlinear regression models. New York (USA): Marcel Dekker Inc.
</p>
<p>Onofri, A. (2020). A collection of self-starters for nonlinear regression in R. See: <a href="https://www.statforbiology.com/2020/stat_nls_usefulfunctions/">https://www.statforbiology.com/2020/stat_nls_usefulfunctions/</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>X &lt;- c(1, 3, 5, 7, 9, 11, 13, 20)
Y &lt;- c(8.22, 14.0, 17.2, 16.9, 19.2, 19.6, 19.4, 19.6)

# nls fit
model &lt;- nls(Y ~ NLS.asymReg(X, init, m, plateau) )

# drm fit
model &lt;- drm(Y ~ X, fct = DRC.asymReg())
summary(model)

model2 &lt;- drm(Y ~ X, fct = DRC.SSasymp())
summary(model2)
</code></pre>

<hr>
<h2 id='beetGrowth'>Growth of sugarbeet in weed-infested and weed-free conditions</h2><span id='topic+beetGrowth'></span>

<h3>Description</h3>

<p>A data frame with 18 observations on the following 3 variables:
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data("beetGrowth")
</code></pre>


<h3>Format</h3>

<p>A data frame with 18 rows and 3 variables
</p>


<h3>Details</h3>


<ul>
<li><p> DAE. numeric: Days After Emergence
</p>
</li>
<li><p> weightInf. numeric: weight of crop biomass on the weed infested plots
</p>
</li>
<li><p> weightFree. numeric: weight of crop biomass on the weed free plots
</p>
</li></ul>



<h3>References</h3>

<p>Covarelli, G., Onofri, A., 1998. Effects of timing of weed removal and emergence in sugarbeet, in: Proceedings 6th EWRS Mediterranean Symposium, Montpellier, 13-15 May 1998. EWRS, pp. 65–72.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(beetGrowth)
mod3 &lt;- nls(weightInf ~ NLS.L3(DAE, b, c, d), data = beetGrowth)

</code></pre>

<hr>
<h2 id='biplot.AMMIobj'>
Biplots for AMMI and GGE analyses of multi-environment genotype experiments
</h2><span id='topic+biplot.AMMIobject'></span><span id='topic+biplot.GGEobject'></span>

<h3>Description</h3>

<p>This method is reserved for the classes 'AMMIobject' and 'GGEobject' as obtained from the 'AMMI()' and 'GGE()' functions in the 'aomisc' package. It draws swift biplots of two types: type 1 plots PC1 against the average yield of genotypes across environments, while type 2 plots PC2 against PC1. The former type of biplot is reserved for 'AMMI' objects, while the second one is for AMMI and GGE objects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'AMMIobject'
biplot(x, biplot = 1, xlim=NULL, ylim=NULL, elabels=NULL,
               glabels=NULL, quad=FALSE, cexG=0.9,
               cexE=0.9,
               xlab=NULL, ylab=NULL, font=1, ...)
## S3 method for class 'GGEobject'
biplot(x, biplot = 1, xlim=NULL, ylim=NULL, elabels=NULL,
               glabels=NULL, quad=FALSE, cexG=0.9,
               cexE=0.9,
               xlab=NULL, ylab=NULL, font=1, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="biplot.AMMIobj_+3A_x">x</code></td>
<td>
<p>a 'AMMIobject' or 'GGEobject' objects</p>
</td></tr>
<tr><td><code id="biplot.AMMIobj_+3A_biplot">biplot</code></td>
<td>
<p>Numeric: either 1 or 2, to request on of the two available types of biplots (see description).</p>
</td></tr>
<tr><td><code id="biplot.AMMIobj_+3A_xlim">xlim</code></td>
<td>
<p>graphical parameter as in the 'plot' method</p>
</td></tr>
<tr><td><code id="biplot.AMMIobj_+3A_ylim">ylim</code></td>
<td>
<p>graphical parameter as in the 'plot' method</p>
</td></tr>
<tr><td><code id="biplot.AMMIobj_+3A_elabels">elabels</code></td>
<td>
<p>labels for the environments</p>
</td></tr>
<tr><td><code id="biplot.AMMIobj_+3A_glabels">glabels</code></td>
<td>
<p>labels for the genotypes</p>
</td></tr>
<tr><td><code id="biplot.AMMIobj_+3A_quad">quad</code></td>
<td>
<p>logical. If TRUE, plots the axes</p>
</td></tr>
<tr><td><code id="biplot.AMMIobj_+3A_cexg">cexG</code></td>
<td>
<p>graphical parameter: the 'cex' for the genotype labels</p>
</td></tr>
<tr><td><code id="biplot.AMMIobj_+3A_cexe">cexE</code></td>
<td>
<p>graphical parameter: the 'cex' for the environment labels</p>
</td></tr>
<tr><td><code id="biplot.AMMIobj_+3A_xlab">xlab</code></td>
<td>
<p>graphical parameter as in the 'plot' method</p>
</td></tr>
<tr><td><code id="biplot.AMMIobj_+3A_ylab">ylab</code></td>
<td>
<p>graphical parameter as in the 'plot' method</p>
</td></tr>
<tr><td><code id="biplot.AMMIobj_+3A_font">font</code></td>
<td>
<p>graphical parameter as in the 'plot' method. Relating to the genotype labels</p>
</td></tr>
<tr><td><code id="biplot.AMMIobj_+3A_...">...</code></td>
<td>
<p>Other additional arguments</p>
</td></tr>
</table>


<h3>Value</h3>

<p>It only returns a graph</p>


<h3>Author(s)</h3>

<p>Andrea Onofri
</p>


<h3>Examples</h3>

<pre><code class='language-R'>WinterWheat &lt;- getAgroData("WinterWheat")
tab &lt;- with(WinterWheat, AMMI(Yield, Genotype, Year, Block, PC = 2))
biplot(tab)
</code></pre>

<hr>
<h2 id='boxcox.nls'>Transform-both-sides (TBS) method for nonlinear regression</h2><span id='topic+boxcox.nls'></span><span id='topic+summary.nlsbc'></span>

<h3>Description</h3>

<p>Finds the optimal Box-Cox transformation for non-linear regression models.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  ## S3 method for class 'nls'
boxcox(object, lambda = seq(-2, 2, 1/10), plotit = TRUE, 
             start, eps = 1/50, bcAdd = 0, level = 0.95, 
             xlab = expression(lambda), ylab = "log-likelihood", ...)
  ## S3 method for class 'nlsbc'
summary(object, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="boxcox.nls_+3A_object">object</code></td>
<td>
<p>object of class <code><a href="stats.html#topic+nls">nls</a></code>. For <code>bcSummary</code> the <code>nls</code> fit should have been obtained using <code>boxcox.nls</code></p>
</td></tr>
<tr><td><code id="boxcox.nls_+3A_lambda">lambda</code></td>
<td>
<p>numeric vector of lambda values; the default is (-2, 2) in steps of 0.1.</p>
</td></tr>
<tr><td><code id="boxcox.nls_+3A_plotit">plotit</code></td>
<td>
<p>logical which controls whether the result should be plotted.</p>
</td></tr>
<tr><td><code id="boxcox.nls_+3A_start">start</code></td>
<td>
<p>a list of starting values (optional).</p>
</td></tr>
<tr><td><code id="boxcox.nls_+3A_eps">eps</code></td>
<td>
<p>numeric value: the tolerance for lambda = 0; defaults to 0.02.</p>
</td></tr>
<tr><td><code id="boxcox.nls_+3A_bcadd">bcAdd</code></td>
<td>
<p>numeric value specifying the constant to be added on both sides prior to Box-Cox transformation. 
The default is 0.</p>
</td></tr>
<tr><td><code id="boxcox.nls_+3A_level">level</code></td>
<td>
<p>numeric value: the confidence level required.</p>
</td></tr>
<tr><td><code id="boxcox.nls_+3A_xlab">xlab</code></td>
<td>
<p>character string: the label on the x axis, defaults to &quot;lambda&quot;.</p>
</td></tr>
<tr><td><code id="boxcox.nls_+3A_ylab">ylab</code></td>
<td>
<p>character string: the label on the y axis, defaults to &quot;log-likelihood&quot;.</p>
</td></tr>
<tr><td><code id="boxcox.nls_+3A_...">...</code></td>
<td>
<p>additional graphical parameters.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>boxcox.nls</code> is very similar to the <code><a href="MASS.html#topic+boxcox">boxcox</a></code> in its
arguments.
The optimal lambda value is determined using a profile likelihood approach: 
For each lambda value the non-linear regression model is fitted and the lambda
value resulting in thre largest value of the log likelihood function is picked.
If a self starter model was used in the model fit, then gradient information
will be used in the profiling.
</p>


<h3>Value</h3>

<p>An object of class <code><a href="stats.html#topic+nls">nls</a></code> (returned invisibly). 
If plotit = TRUE a plot of loglik vs lambda is shown indicating a confidence interval (by default 95%) about 
the optimal lambda value.
</p>


<h3>Author(s)</h3>

<p>Christian Ritz, modified by Andrea Onofri</p>


<h3>References</h3>

<p>Carroll, R. J. and Ruppert, D. (1988) <em>Transformation and Weighting in Regression</em>, New York: Chapman and Hall (Chapter 4).
</p>


<h3>See Also</h3>

<p>For linear regression the analogue is <code><a href="MASS.html#topic+boxcox">boxcox</a></code>.</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Fitting log-logistic model without transformation
ryegrass.m1 &lt;- nls(rootl ~ NLS.L4(conc, b, c, d, e), 
                 data=ryegrass)
summary(ryegrass.m1)

## Fitting the same model with optimal Box-Cox transformation
ryegrass.m2 &lt;- boxcox(ryegrass.m1, plotit = TRUE)
summary(ryegrass.m2)
</code></pre>

<hr>
<h2 id='check.hom'>
Check linear models for homoscedasticity
</h2><span id='topic+check.hom'></span>

<h3>Description</h3>

<p>This function takes a linear model object as an argument and checks whether the residuals are homoscedastic, in relation to a stratification variable or covariate, that is given as an argument.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>check.hom(obj, var, alternative)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="check.hom_+3A_obj">obj</code></td>
<td>
<p>a linear model object fitted with lm()</p>
</td></tr>
<tr><td><code id="check.hom_+3A_var">var</code></td>
<td>
<p>a vector containing a stratification variable. If missing, the fitted values from obj are taken as a covariate</p>
</td></tr>
<tr><td><code id="check.hom_+3A_alternative">alternative</code></td>
<td>
<p>The null (homogeneous variances) is tested against the alternative, that is (i) different variances for each level of the stratification variable given as argument (&quot;varIdent&quot;), (ii) variance is a power function of a covariate, that is given as argument (&quot;varPower&quot;; the fitted values are taken as the covariate, in case the argument 'var' is missing and (iii) the variance is an exponential function of a covariate, that is given as argument (&quot;varExp&quot;; the fitted values are taken as the covariate, in case the argument 'var' is missing)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function fits a gls with same structure as the input model, together with a heteroscedastic gls, where residuals are allowed to be heteroscedastic, according to the 'alternative' argument. The two models are compared by a LRT</p>


<h3>Value</h3>

<table role = "presentation">
<tr><td><code>LRT</code></td>
<td>
<p>the value of LRT</p>
</td></tr>
<tr><td><code>LRT</code></td>
<td>
<p>the P-value of LRT</p>
</td></tr>
<tr><td><code>aovtable</code></td>
<td>
<p>a summary table for the LRT</p>
</td></tr>
<tr><td><code>modHet</code></td>
<td>
<p>the gls object containing the heteroscedastic fit</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Andrea Onofri
</p>


<h3>Examples</h3>

<pre><code class='language-R'>fileName &lt;- "https://www.casaonofri.it/_datasets/FGP_rape.csv"
library(statforbiology)
dataset &lt;- read.csv(fileName)
dataset[,1:5] &lt;- lapply(dataset[,1:5], factor)
mod &lt;- lm(FGP ~ Genotype * Run, data = dataset)
check &lt;- check.hom(mod, Run)
check$aovtable
</code></pre>

<hr>
<h2 id='compCoefs'>Pairwise comparisons of model parameters for nls objects</h2><span id='topic+compCoefs'></span>

<h3>Description</h3>

<p>With models containing covariates and factors, we may be interested in fitting nonlinear regression models in a groupwise fashion, according to the levels of the experimental factor(s). This function permits pairwise comparison procedures of model parameters; parameters can be compared by means of either ratios or differences. It works very much like the function 'compParm' in the package 'drc', but it is to be used with 'nls' objects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>compCoefs(object, parameterNames, operator = "-", display = "pairwise",
          adjust = "holm", reversed = FALSE, level = 0.05, Letters = c(letters, LETTERS))
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="compCoefs_+3A_object">object</code></td>
<td>
<p> an object of class 'nls' </p>
</td></tr>
<tr><td><code id="compCoefs_+3A_parameternames">parameterNames</code></td>
<td>
<p>The name of parameters to compare. It must corresponds to the names of parameters in coefs(object)</p>
</td></tr>
<tr><td><code id="compCoefs_+3A_operator">operator</code></td>
<td>
<p>a character. If equal to &quot;/&quot; parameter ratios are compared. If equal to &quot;-&quot; (default) parameter differences are compared.</p>
</td></tr>
<tr><td><code id="compCoefs_+3A_display">display</code></td>
<td>
<p>a character. If equal to &quot;pairwise&quot; (default), pairwise comparisons are displayed. Otherwise, a compact letter display is returned, according to the argument in 'level'.</p>
</td></tr>
<tr><td><code id="compCoefs_+3A_adjust">adjust</code></td>
<td>
<p>A multiplicity adjustment method as in p.adjust. Defaults to &quot;holm&quot;.</p>
</td></tr>
<tr><td><code id="compCoefs_+3A_reversed">reversed</code></td>
<td>
<p>logical. Should the order of means/letters be decreasing? Defaults to FALSE, which means that the means and letters are in increasing order.</p>
</td></tr>
<tr><td><code id="compCoefs_+3A_level">level</code></td>
<td>
<p>Protection level for compact letter display</p>
</td></tr>
<tr><td><code id="compCoefs_+3A_letters">Letters</code></td>
<td>
<p>Vector of distinct characters (or character strings) used to connect levels that are not significantly different. They should be recogizable when concatenated. The default behaviour is to use the small letters, followed by the capital letters. See help for 'multcompView::multcompLetters()' for futher detail)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>returns a dataframe, containing the results</p>


<h3>Author(s)</h3>

<p>Andrea Onofri
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(metamitron)
modNlin &lt;- nls(Conc ~ A[Herbicide] * exp(-k[Herbicide] * Time),
               start=list(A=rep(100, 4), k=rep(0.06, 4)),
               data=metamitron)
tab &lt;- summary(modNlin)
pn &lt;- c("k1", "k2", "k3", "k4")
compCoefs(modNlin, pn) # Holm multiplicity adjustment
compCoefs(modNlin, pn, adjust = "none")

# Displaying letters (P = 0.05 is default)
compCoefs(modNlin, pn, adjust = "none",
        display = "cld")

# Calculate ratios
compCoefs(modNlin, pn, adjust = "none",
        display = "pairwise", operator = "/")
</code></pre>

<hr>
<h2 id='compCurves'>Compare regression curves in a pairwise fashion</h2><span id='topic+compCurves'></span>

<h3>Description</h3>

<p>For regression models containing grouping factors and fitted with the 'drm'
function in the 'drc' package, this function compares the
different curves for each factor level in a pairwise fashion,
according to a series of F tests for the extra-sum-of-squares. Works only with
'drc' objects
</p>


<h3>Usage</h3>

<pre><code class='language-R'>compCurves(
  obj,
  adjusted = c("none", "holm", "hochberg", "hommel", "bonferroni", "BH", "BY", "fdr")
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="compCurves_+3A_obj">obj</code></td>
<td>
<p>a drc object</p>
</td></tr>
<tr><td><code id="compCurves_+3A_adjusted">adjusted</code></td>
<td>
<p>a character string, for selecting the method of multiplicity
correction. Must be one of: c(&quot;none&quot;, &quot;holm&quot;, &quot;hochberg&quot;, &quot;hommel&quot;,
&quot;bonferroni&quot;, &quot;BH&quot;, &quot;BY&quot;, &quot;fdr&quot;)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>returns a list with two slots: (i) Pairs: the list of peirwise comparisons,
with F values and P-values; (ii) Letters: letter display for the different
curves
</p>


<h3>Author(s)</h3>

<p>Andrea Onofri
</p>


<h3>Examples</h3>

<pre><code class='language-R'>metamitron &lt;- getAgroData("metamitron")
head(metamitron)
tail(metamitron)

mod1 &lt;- drm(Conc ~ Time, fct = DRC.expoDecay(),
               curveid = Herbicide,
               data = metamitron)
summary(mod1)
compCurves(mod1, adjusted = "bonferroni")


</code></pre>

<hr>
<h2 id='contr.Tukey'>
Pairwise contrast matrix
</h2><span id='topic+contr.Tukey'></span>

<h3>Description</h3>

<p>Returns a matrix of Tukey-type contrasts (all-pairwise)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>contr.Tukey(n, names = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="contr.Tukey_+3A_n">n</code></td>
<td>
<p>an integer: the number of levels, corresponding to the number of columns in the output matrix</p>
</td></tr>
<tr><td><code id="contr.Tukey_+3A_names">names</code></td>
<td>
<p>a vector of names with same length as n</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This functions is used for creating contrast matrices for use with glht or other methods for fitting linear contrasts. The rows of the resulting matrices contain the coefficients of contrasts relating to a factor with n levels. The names of the levels can be optionally given with the argument 'names', other wise they default to the numbers from 1 to n.
</p>


<h3>Value</h3>

<p>A matrix with n columns and n(n-1)/2 rows
</p>


<h3>Author(s)</h3>

<p>Andrea Onofri
</p>


<h3>Examples</h3>

<pre><code class='language-R'>contr.Tukey(8, LETTERS[1:8])
</code></pre>

<hr>
<h2 id='CVA'> Canonical variate analysis for multienvironment and multitrait genotype experiments</h2><span id='topic+CVA'></span>

<h3>Description</h3>

<p>This function performs canonical variate analysis as a descriptive visualisation tool. It is close to the 'lda()' function in the MASS package but it is not meant to be used for discriminant analyses.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>CVA(dataset, groups, scale = TRUE, constraint = 3)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="CVA_+3A_dataset">dataset</code></td>
<td>
<p> dataset is a multidimensional matrix of observations </p>
</td></tr>
<tr><td><code id="CVA_+3A_groups">groups</code></td>
<td>
<p> groups is a vector coding for groupings </p>
</td></tr>
<tr><td><code id="CVA_+3A_scale">scale</code></td>
<td>
<p> whether the data needs to be standardised prior to analysis. Defaults to TRUE </p>
</td></tr>
<tr><td><code id="CVA_+3A_constraint">constraint</code></td>
<td>
<p> It is the type of scaling for eigenvectors, so that canonical variates have: 1 = unit within-group standard deviations (most common); 2 = unit total standard deviations; 3 = unit within group norms; 4 = unit total norms. It defaults to 3</p>
</td></tr>
</table>


<h3>Details</h3>

<p>More detail can be found in a blog page, at 'https://www.statforbiology.com/2023/stat_multivar_cva/'. Please, note that preliminary data transformations (e.g.: standardisation) are left to the user and must be performed prior to analyses (see example below).
</p>


<h3>Value</h3>

<table role = "presentation">
<tr><td><code>TOT</code></td>
<td>
<p>matrix of total variances-covariances</p>
</td></tr>
<tr><td><code>B</code></td>
<td>
<p>matrix of 'between-groups' variances-covariances</p>
</td></tr>
<tr><td><code>W</code></td>
<td>
<p>matrix of 'within-group' variances-covariances</p>
</td></tr>
<tr><td><code>B/W</code></td>
<td>
<p>matrix of W^{-1} B</p>
</td></tr>
<tr><td><code>eigenvalues</code></td>
<td>
<p>vector of eigenvalues</p>
</td></tr>
<tr><td><code>eigenvectors</code></td>
<td>
<p>matrix of eigenvectors</p>
</td></tr>
<tr><td><code>proportion</code></td>
<td>
<p>a vector containing the proportion of total discriminating ability captured by each canonical variate</p>
</td></tr>
<tr><td><code>correlation</code></td>
<td>
<p>vector of canonical correlations</p>
</td></tr>
<tr><td><code>squared.canonical.correlation</code></td>
<td>
<p>vector of squared canonical correlations</p>
</td></tr>
<tr><td><code>coefficients</code></td>
<td>
<p>matrix of canonical coefficients</p>
</td></tr>
<tr><td><code>scores</code></td>
<td>
<p>matrix of canonical scores</p>
</td></tr>
<tr><td><code>centroids</code></td>
<td>
<p>matrix of scores for centroids</p>
</td></tr>
<tr><td><code>total.structure</code></td>
<td>
<p>matrix of total canonical structure</p>
</td></tr>
<tr><td><code>between.structure</code></td>
<td>
<p>matrix of between-groups canonical structure</p>
</td></tr>
<tr><td><code>within.structure</code></td>
<td>
<p>matrix of within-groups canonical structure</p>
</td></tr>
<tr><td><code>class.fun</code></td>
<td>
<p>matrix of classifications functions</p>
</td></tr>
<tr><td><code>class.val</code></td>
<td>
<p>matrix of classification values</p>
</td></tr>
<tr><td><code>within.structure</code></td>
<td>
<p>matrix of within-groups canonical structure</p>
</td></tr>
<tr><td><code>class</code></td>
<td>
<p>vector of predicted classes</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Andrea Onofri</p>


<h3>References</h3>

<p><a href="https://www.statforbiology.com/2023/stat_multivar_cva/">https://www.statforbiology.com/2023/stat_multivar_cva/</a></p>


<h3>Examples</h3>

<pre><code class='language-R'>dataset &lt;- getAgroData("WheatQuality4years")
dataset$Year &lt;- factor(dataset$Year)
head(dataset)

# Standardise the data
groups &lt;- dataset$Genotype
Z &lt;- apply(dataset[,3:6], 2, scale, center = TRUE, scale = TRUE)
head(Z)

# Performs CVA
cvaobj &lt;- CVA(Z, groups)
cvaobj
</code></pre>

<hr>
<h2 id='degradation'>Soil degradation kinetic for a herbicide</h2><span id='topic+degradation'></span>

<h3>Description</h3>

<p>A data frame with 24 observations on the following 2 variables:
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data("degradation")
</code></pre>


<h3>Format</h3>

<p>A data frame with 24 rows and 2 variables
</p>


<h3>Details</h3>


<ul>
<li><p> Time. numeric: Days from start of incubation
</p>
</li>
<li><p> Conc. numeric: residual concentration
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>data("degradation")
degradation

</code></pre>

<hr>
<h2 id='deviance.drc'>
Residual deviance for a non-linear regression fit.
</h2><span id='topic+deviance.drc'></span>

<h3>Description</h3>

<p>Calculate the sum of squared residuals from a non-linear regression fit with the 'drm()' function in the 'drc()' package.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'drc'
deviance(object, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="deviance.drc_+3A_object">object</code></td>
<td>
<p>a 'drc' object, for which the deviance is required</p>
</td></tr>
<tr><td><code id="deviance.drc_+3A_...">...</code></td>
<td>
<p>Other additional arguments, if necessary</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The value of the deviance extracted from the object object.
</p>


<h3>Author(s)</h3>

<p>Andrea Onofri
</p>


<h3>Examples</h3>

<pre><code class='language-R'>X &lt;- c(1, 3, 5, 7, 9, 11, 13, 20)
Y &lt;- c(8.22, 14.0, 17.2, 16.9, 19.2, 19.6, 19.4, 19.6)

# nls fit
model &lt;- nls(Y ~ NLS.asymReg(X, init, m, plateau) )
deviance(model)

# drm fit
model2 &lt;- drm(Y ~ X, fct = DRC.asymReg())
deviance(model2)
</code></pre>

<hr>
<h2 id='expoDecay'>Exponential decay function</h2><span id='topic+expoDecay.fun'></span><span id='topic+NLS.expoDecay'></span><span id='topic+DRC.expoDecay'></span>

<h3>Description</h3>

<p>These functions provide the exponential decay function (expoDecay), the exponential decay function with self-starter for the <code><a href="stats.html#topic+nls">nls</a></code> function and the exponential decay function with self-starter for the <code><a href="drc.html#topic+drm">drm</a></code> function in the drc package.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  expoDecay.fun(predictor, C0, k)
  NLS.expoDecay(predictor, C0, k)
  DRC.expoDecay(fixed = c(NA, NA), names = c("C0", "k"))
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="expoDecay_+3A_predictor">predictor</code></td>
<td>
<p>a numeric vector of values at which to evaluate the model.</p>
</td></tr>
<tr><td><code id="expoDecay_+3A_c0">C0</code></td>
<td>
<p>model parameter</p>
</td></tr>
<tr><td><code id="expoDecay_+3A_k">k</code></td>
<td>
<p>model parameter</p>
</td></tr>
<tr><td><code id="expoDecay_+3A_fixed">fixed</code></td>
<td>
<p>numeric vector. Specifies which parameters are fixed and at what value they are fixed. NAs for parameter that are not fixed.</p>
</td></tr>
<tr><td><code id="expoDecay_+3A_names">names</code></td>
<td>
<p>a vector of character strings giving the names of the parameters. The default is reasonable.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The exponential decay is given by the following function:
</p>
<p style="text-align: center;"><code class="reqn"> f(x) = \textrm{C0} \cdot \exp (- k x )\}</code>
</p>



<h3>Value</h3>

<p>expoDecay.fun and NLS.expoDecay return a numeric value, while DRC.expoDecay returns a list containing the nonlinear function, the self starter function and the parameter names.
</p>


<h3>Note</h3>

<p>DRC.expoDecay is for use with the function <code><a href="drc.html#topic+drm">drm</a></code>.</p>


<h3>Author(s)</h3>

<p>Andrea Onofri</p>


<h3>References</h3>

<p>Ratkowsky, DA (1990) Handbook of nonlinear regression models. New York (USA): Marcel Dekker Inc.
</p>
<p>Onofri, A. (2020). A collection of self-starters for nonlinear regression in R. See: <a href="https://www.statforbiology.com/2020/stat_nls_usefulfunctions/">https://www.statforbiology.com/2020/stat_nls_usefulfunctions/</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("degradation")
model &lt;- drm(Conc ~ Time, fct = DRC.expoDecay(),
             data = degradation)
summary(model)
model2 &lt;- nls(Conc ~ NLS.expoDecay(Time, a, b),
              data = degradation)
summary(model2)
</code></pre>

<hr>
<h2 id='expoGrowth'>Exponential growth function</h2><span id='topic+expoGrowth.fun'></span><span id='topic+NLS.expoGrowth'></span><span id='topic+DRC.expoGrowth'></span>

<h3>Description</h3>

<p>These functions provide the exponential growth equation (expoGrowth), the exponential growth equation with self-starter for the <code><a href="stats.html#topic+nls">nls</a></code> function and the exponential growth equation with self-starter for the <code><a href="drc.html#topic+drm">drm</a></code> function in the drc package.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  expoGrowth.fun(predictor, init, k)
  NLS.expoGrowth(predictor, init, k)
  DRC.expoGrowth(fixed = c(NA, NA), names = c("init", "k"))
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="expoGrowth_+3A_predictor">predictor</code></td>
<td>
<p>a numeric vector of values at which to evaluate the model.</p>
</td></tr>
<tr><td><code id="expoGrowth_+3A_init">init</code></td>
<td>
<p>model parameter: response at predictor = 0</p>
</td></tr>
<tr><td><code id="expoGrowth_+3A_k">k</code></td>
<td>
<p>model parameter: growth rate</p>
</td></tr>
<tr><td><code id="expoGrowth_+3A_fixed">fixed</code></td>
<td>
<p>numeric vector. Specifies which parameters are fixed and at what value they are fixed. NAs for parameter that are not fixed.</p>
</td></tr>
<tr><td><code id="expoGrowth_+3A_names">names</code></td>
<td>
<p>a vector of character strings giving the names of the parameters. The default is reasonable.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The exponential growth is given by the following function:
</p>
<p style="text-align: center;"><code class="reqn"> f(x) = \textrm{C0} \cdot \exp ( k x )\}</code>
</p>



<h3>Value</h3>

<p>expoGrowth.fun() and NLS.expoGrowth() return a numeric value, while DRC.expoGrowth() returns a list containing the nonlinear function, the self starter function and the parameter names.
</p>


<h3>Note</h3>

<p>DRC.expoGrowth() is for use with the function <code><a href="drc.html#topic+drm">drm</a></code>.</p>


<h3>Author(s)</h3>

<p>Andrea Onofri</p>


<h3>References</h3>

<p>Ratkowsky, DA (1990) Handbook of nonlinear regression models. New York (USA): Marcel Dekker Inc.
</p>
<p>Onofri, A. (2020). A collection of self-starters for nonlinear regression in R. See: <a href="https://www.statforbiology.com/2020/stat_nls_usefulfunctions/">https://www.statforbiology.com/2020/stat_nls_usefulfunctions/</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(statforbiology)
Time &lt;- 1:20
Resp &lt;- c(0.18, 0.64, 1.14, 0.67, 0.32, 0.86, 0.70, 0.73, 0.89, 0.48,
    2.20, 1.03, 1.14, 2.14, 1.31, 2.08, 1.85, 1.47, 1.98, 1.30)
model &lt;- drm(Resp ~ Time, fct = DRC.expoGrowth())
summary(model)
model2 &lt;- nls(Resp ~ NLS.expoGrowth(Time, a, b))
summary(model2)
</code></pre>

<hr>
<h2 id='getAgroData'>Get one of the available datasets</h2><span id='topic+getAgroData'></span>

<h3>Description</h3>

<p>This function loads and returns a dataset available in an external repository
and stored as '.csv' or other type of text files.
all the examples.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getAgroData(
  fileName,
  where = "https://www.casaonofri.it/_datasets/",
  type = "csv"
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="getAgroData_+3A_filename">fileName</code></td>
<td>
<p>character: the name of the file (with no extension)</p>
</td></tr>
<tr><td><code id="getAgroData_+3A_where">where</code></td>
<td>
<p>character: the name of the web repository</p>
</td></tr>
<tr><td><code id="getAgroData_+3A_type">type</code></td>
<td>
<p>character: the extension of the web file</p>
</td></tr>
</table>


<h3>Value</h3>

<p>returns a data.frame
</p>


<h3>Author(s)</h3>

<p>Andrea Onofri
</p>


<h3>Examples</h3>

<pre><code class='language-R'>getAgroData("rimsulfuron")

</code></pre>

<hr>
<h2 id='getPlotData'>Get the data for plotting with ggplot()</h2><span id='topic+getPlotData'></span><span id='topic+getPlotData.drc'></span><span id='topic+getPlotData.nls'></span><span id='topic+getPlotData.drcte'></span>

<h3>Description</h3>

<p>This method works on a model object and retrieves the data for plotting
the observed values (average or all data) and predictions from model fit.
It is mainly meant to be used with ggplot()
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getPlotData(obj, ...)

## S3 method for class 'drc'
getPlotData(obj, xlim = NULL, gridsize = 100, type = c("average", "all"), ...)

## S3 method for class 'nls'
getPlotData(obj, xlim = NULL, gridsize = 100, type = c("average", "all"), ...)

## S3 method for class 'drcte'
getPlotData(
  obj,
  xlim = NULL,
  gridsize = 100,
  npmle.type = c("interpolation", "midpoint", "right", "left", "none"),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="getPlotData_+3A_obj">obj</code></td>
<td>
<p>A fitted model object. Methods are provided for drc, drcte and nls objects</p>
</td></tr>
<tr><td><code id="getPlotData_+3A_...">...</code></td>
<td>
<p>Other additional arguments.</p>
</td></tr>
<tr><td><code id="getPlotData_+3A_xlim">xlim</code></td>
<td>
<p>a vector. The interval for the predictor in which predictions are to be obtained</p>
</td></tr>
<tr><td><code id="getPlotData_+3A_gridsize">gridsize</code></td>
<td>
<p>numeric. Number of points in the grid (within xlim) used for predictions.</p>
</td></tr>
<tr><td><code id="getPlotData_+3A_type">type</code></td>
<td>
<p>a character string specifying whether all the observed points should be plotted (type = &quot;all&quot;)
or whether the response should be averaged over the levels of the predictor
(type = &quot;all&quot;). It is disregarded for drcte objects</p>
</td></tr>
<tr><td><code id="getPlotData_+3A_npmle.type">npmle.type</code></td>
<td>
<p>a character string. For drcte objects, the NPMLE of the cumulative
density function is only specified at the end of each inspection interval, while
it is not unique within each interval. This argument specifies how the CDF
increases within each interval: possible values are &quot;interpolation&quot; (it is
assumed that the CDF increases progressively), &quot;left&quot; (the CDF increases at
the beginning of each interval), &quot;right&quot; (the CDF increases at the end of each
interval; it is very common in survival analysis) and &quot;midpoint&quot; (the CDF
increases in the middle of each interval; it is very common in survival
analysis). This argument is neglected with nls and drc objects.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>This function returns a list of two elements: 'plotPoints' is a dataframe containing
the observed data, 'plotFits' is a dataframe containing model predictions
</p>


<h3>Author(s)</h3>

<p>Andrea Onofri
</p>


<h3>Examples</h3>

<pre><code class='language-R'>fileName &lt;- "https://www.casaonofri.it/_datasets/metamitron.csv"
metamitron &lt;- read.csv(fileName)
mod &lt;- drm(Conc ~ Time, fct = EXD.2(),
           data = metamitron, curveid = Herbicide)
retVal &lt;- getPlotData(mod)
library(ggplot2)
ggplot() +
  geom_point(data = retVal$plotPoints, mapping = aes(x = Time, y = Conc)) +
  geom_line(data = retVal$plotFits, mapping = aes(x = Time, y = Conc)) +
  facet_wrap(~ Herbicide)

</code></pre>

<hr>
<h2 id='GGE'>
GGE analysis for multienvironment genotype experiments
</h2><span id='topic+GGE'></span>

<h3>Description</h3>

<p>This function performs the GGE (Genotype plus Genotype by Environment interaction) analysis, according to Yan et al., 2000.</p>


<h3>Usage</h3>

<pre><code class='language-R'>GGE(yield, genotype, environment, block, PC = 2)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="GGE_+3A_yield">yield</code></td>
<td>
<p>a vector containing yield levels</p>
</td></tr>
<tr><td><code id="GGE_+3A_genotype">genotype</code></td>
<td>
<p>a vector containing genotype codings</p>
</td></tr>
<tr><td><code id="GGE_+3A_environment">environment</code></td>
<td>
<p>a vector containing environment codings</p>
</td></tr>
<tr><td><code id="GGE_+3A_block">block</code></td>
<td>
<p>a vector containing block codes for each environment</p>
</td></tr>
<tr><td><code id="GGE_+3A_pc">PC</code></td>
<td>
<p>the number of PCs that one wants to extract</p>
</td></tr>
</table>


<h3>Value</h3>

<p> Returns a list of class 'GGEobject' with the following components
</p>
<table role = "presentation">
<tr><td><code>genotype_means</code></td>
<td>
<p>The overall least squares genotype means</p>
</td></tr>
<tr><td><code>environment_means</code></td>
<td>
<p>The overall least squares environment means</p>
</td></tr>
<tr><td><code>interaction_means</code></td>
<td>
<p>The least squares means for the genotype by environment combinations</p>
</td></tr>
<tr><td><code>ge_effect</code></td>
<td>
<p>a two-way table of 'interaction effects'gge' effects</p>
</td></tr>
<tr><td><code>additive_ANOVA</code></td>
<td>
<p>an ANOVA table for the additive model</p>
</td></tr>
<tr><td><code>GGE_summary</code></td>
<td>
<p>a summary table for GGE analysis</p>
</td></tr>
<tr><td><code>environment_scores</code></td>
<td>
<p>a table of environment scores</p>
</td></tr>
<tr><td><code>genotype_scores</code></td>
<td>
<p>a table of genotype scores</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Andrea Onofri
</p>


<h3>References</h3>

<p>Yan, W., Hunt, L.A., Sheng, Q., Szlavnics, Z., 2000. Cultivar Evaluation and Mega-Environment Investigation Based on the GGE Biplot. Crop Science 40, 597–605.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>WinterWheat &lt;- getAgroData("WinterWheat")
tab &lt;- with(WinterWheat, GGE(Yield, Genotype, Year, Block, PC = 2))
tab
</code></pre>

<hr>
<h2 id='gnlht'>Linear/nonlinear contrasts of model parameters</h2><span id='topic+gnlht'></span>

<h3>Description</h3>

<p>This function calculates linear/nonlinear contrasts of model parameters and returns their estimates with delta standard errors.</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'numeric'
gnlht(object, func, const, vcov.,
            parameterNames, dfr, ...)
## S3 method for class 'lm'
gnlht(object, func, const, vcov.,
            parameterNames, dfr, ...)
## S3 method for class 'nls'
gnlht(object, func, const, vcov.,
            parameterNames, dfr, ...)
## S3 method for class 'lme'
gnlht(object, func, const, vcov.,
            parameterNames, dfr, ...)
## S3 method for class 'nlme'
gnlht(object, func, const, vcov.,
            parameterNames, dfr, ...)
## S3 method for class 'drc'
gnlht(object, func, const, vcov.,
            parameterNames, dfr, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="gnlht_+3A_object">object</code></td>
<td>
<p>a named vector of parameter estimates, or a model object for which there are coef and vcov methods. The estimates are assumed as asymptotically normally distributed with covariance matrix returned by vcov. or passed as an argument</p>
</td></tr>
<tr><td><code id="gnlht_+3A_func">func</code></td>
<td>
<p>a list of functions or quoted strings that are the functions of the parameter estimates to be evaluated</p>
</td></tr>
<tr><td><code id="gnlht_+3A_const">const</code></td>
<td>
<p>If necessary, a dataframe whose columns are the constants to be used in the calculations above. For each row of this dataframe, the functions above are evaluated</p>
</td></tr>
<tr><td><code id="gnlht_+3A_vcov.">vcov.</code></td>
<td>
<p>a variance-covariance matrix, or a function to calculate it from the model object</p>
</td></tr>
<tr><td><code id="gnlht_+3A_parameternames">parameterNames</code></td>
<td>
<p>a character vector with namings for the parameters to be combined</p>
</td></tr>
<tr><td><code id="gnlht_+3A_dfr">dfr</code></td>
<td>
<p>number of degrees of freedom</p>
</td></tr>
<tr><td><code id="gnlht_+3A_...">...</code></td>
<td>
<p>Additional arguments</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Methods are given for several types of model fitting objects (lm, nls, lme, nlme, drc), from where model coefficients and a variance-covariance matrix are automatically retrieved. For other cases, a named vector of model parameters and a variance-covariance matrix can be provided as arguments to the 'gnlht()' function.
</p>


<h3>Value</h3>

<p>Returns a data.frame
</p>


<h3>Author(s)</h3>

<p>Andrea Onofri
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(metamitron)
#Fit nls grouped model
modNlin &lt;- nls(Conc ~ A[Herbicide] * exp(-k[Herbicide] * Time),
               start=list(A=rep(100, 4), k=rep(0.06, 4)),
               data=metamitron)
summary(modNlin)


# Compare parameters
funList &lt;- list(~k1 - k2, ~k1 - k3, ~k1 - k4)
gnlht(modNlin, funList)

# Combine parameters
funList &lt;- list(~ -log(0.5)/k1, ~ -log(0.5)/k2,
                ~ -log(0.5)/k3, ~ -log(0.5)/k4)
gnlht(modNlin, funList)

# Combine more flexibly
funList &lt;- list(~ -log(prop)/k1, ~ -log(prop)/k2,
                ~ -log(prop)/k3, ~ -log(prop)/k4)
gnlht(modNlin, funList, const = data.frame(prop = 0.5))

funList &lt;- list(~ -log(prop)/k1, ~ -log(prop)/k2,
                ~ -log(prop)/k3, ~ -log(prop)/k4)
gnlht(modNlin, funList, const = data.frame(prop = c(0.7, 0.5, 0.3)))

# Other possibilities
funList &lt;- list(~ (k2 - k1)/(k1 * k2) * log(prop),
                ~ (k3 - k1)/(k1 * k3) * log(prop),
                ~ (k4 - k1)/(k1 * k4) * log(prop))
gnlht(modNlin, funList, const = data.frame(prop = c(0.7, 0.5, 0.3)))

# Predictions
funList &lt;- list(~ A1 * exp (- k1 * Time), ~ A2 * exp (- k2 * Time),
                ~ A3 * exp (- k3 * Time), ~ A4 * exp (- k4 * Time))
propdF &lt;- data.frame(Time = seq(0, 67, 1))
func &lt;- funList
const &lt;- propdF
pred &lt;- gnlht(modNlin, funList, const = propdF)
head(pred)
tail(pred)
</code></pre>

<hr>
<h2 id='linear'>Simple linear regression functions</h2><span id='topic+linear.fun'></span><span id='topic+NLS.linear'></span><span id='topic+NLS.linearOrigin'></span><span id='topic+DRC.linear'></span>

<h3>Description</h3>

<p>These functions provide the simple linear regression model (linear), the linear regression model with self-starter for the <code><a href="stats.html#topic+nls">nls</a></code> function (NLS.linear) and the simple linear regression function with self-starter for the <code><a href="drc.html#topic+drm">drm</a></code> function in the drc package (DRC.linear). For the 'nls' function, we also provide function and self starter for the simple linear regression through origin (NLS.linearOrigin). Obviously, fitting linear functions with nonlinear least square regression is sub-optimal, but it might be useful for comparing alternative models.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  linear.fun(predictor, a, b)
  NLS.linear(predictor, a, b)
  NLS.linearOrigin(predictor, b)
  DRC.linear(fixed = c(NA, NA), names = c("a", "b"))
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="linear_+3A_predictor">predictor</code></td>
<td>
<p>a numeric vector of values at which to evaluate the model.</p>
</td></tr>
<tr><td><code id="linear_+3A_a">a</code></td>
<td>
<p>numeric. The response when the predict is equal to 0.</p>
</td></tr>
<tr><td><code id="linear_+3A_b">b</code></td>
<td>
<p>numeric. The slope.</p>
</td></tr>
<tr><td><code id="linear_+3A_fixed">fixed</code></td>
<td>
<p>numeric vector. Specifies which parameters are fixed and at what value they are fixed. NAs for parameter that are not fixed.</p>
</td></tr>
<tr><td><code id="linear_+3A_names">names</code></td>
<td>
<p>a vector of character strings giving the names of the parameters. The default is reasonable.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The simple linear regression model is given by the following equation:
</p>
<p style="text-align: center;"><code class="reqn"> f(x) = a +  b x </code>
</p>



<h3>Value</h3>

<p>linear.fun, NLS.linear and NLS.linearOrigin return a numeric value, while DRC.linear returns a list containing the nonlinear function, the self starter function and the parameter names.
</p>


<h3>Author(s)</h3>

<p>Andrea Onofri</p>


<h3>References</h3>

<p>Ratkowsky, DA (1990) Handbook of nonlinear regression models. New York (USA): Marcel Dekker Inc.
</p>
<p>Onofri, A. (2020). A collection of self-starters for nonlinear regression in R. See: <a href="https://www.statforbiology.com/2020/stat_nls_usefulfunctions/">https://www.statforbiology.com/2020/stat_nls_usefulfunctions/</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Simple linear regression
X &lt;- seq(5, 50, 5)
Y &lt;- 10 + 0.5*X + rnorm(10, 0, 0.5)

model1 &lt;- nls(Y ~ NLS.linear(X, a, b))
model2 &lt;- nls(Y ~ NLS.linearOrigin(X, b)) # force through origin
summary(model1); summary(model2)

model1 &lt;- drm(Y ~ X, fct = DRC.linear())
model2 &lt;- drm(Y ~ X, fct = DRC.linear(fixed = c(0, NA)))
summary(model1); summary(model2)
</code></pre>

<hr>
<h2 id='logCurve'>Logarithmic curve</h2><span id='topic+logCurve.fun'></span><span id='topic+logCurveNI.fun'></span><span id='topic+NLS.logCurve'></span><span id='topic+NLS.logCurveNI'></span><span id='topic+DRC.logCurve'></span>

<h3>Description</h3>

<p>These functions provide the logarithmic model (logCurve) with self-starter for the <code><a href="stats.html#topic+nls">nls</a></code> function and for the <code><a href="drc.html#topic+drm">drm</a></code> function in the drc package.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  logCurve.fun(predictor, a, b)
  NLS.logCurve(predictor, a, b)
  NLS.logCurveNI(predictor, b)
  DRC.logCurve(fixed = c(NA, NA), names = c("a", "b"))
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="logCurve_+3A_predictor">predictor</code></td>
<td>
<p>a numeric vector of values at which to evaluate the model.</p>
</td></tr>
<tr><td><code id="logCurve_+3A_a">a</code></td>
<td>
<p>model parameter</p>
</td></tr>
<tr><td><code id="logCurve_+3A_b">b</code></td>
<td>
<p>model parameter</p>
</td></tr>
<tr><td><code id="logCurve_+3A_fixed">fixed</code></td>
<td>
<p>numeric vector. Specifies which parameters are fixed and at what value they are fixed. NAs for parameter that are not fixed.</p>
</td></tr>
<tr><td><code id="logCurve_+3A_names">names</code></td>
<td>
<p>a vector of character strings giving the names of the parameters. The default is reasonable.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The logarithmic curve is given by the following function:
</p>
<p style="text-align: center;"><code class="reqn"> f(x) = a + b \log (X) </code>
</p>

<p>This curve crosses the X axis at X = a. We can force it through the origin by setting a = 0; this is possible by setting 'fixed = c(=, NA), while, in the 'nls()' function, we need to use the NLS.logCurveNI()' function.
</p>


<h3>Value</h3>

<p>logCurve.fun, NLS.logCurve and NLS.logCurveNI return a numeric value, while DRC.logCurve returns a list containing the nonlinear function, the self starter function and the parameter names.
</p>


<h3>Note</h3>

<p>DRC.logCurve() is for use with the function <code><a href="drc.html#topic+drm">drm</a></code>.</p>


<h3>Author(s)</h3>

<p>Andrea Onofri</p>


<h3>References</h3>

<p>Ratkowsky, DA (1990) Handbook of nonlinear regression models. New York (USA): Marcel Dekker Inc.
</p>
<p>Onofri, A. (2020). A collection of self-starters for nonlinear regression in R. See: <a href="https://www.statforbiology.com/2020/stat_nls_usefulfunctions/">https://www.statforbiology.com/2020/stat_nls_usefulfunctions/</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>X &lt;- c(1,2,4,5,7,12)
Y &lt;- c(1.97, 2.32, 2.67, 2.71, 2.86, 3.09)

# lm fit
model &lt;- lm(Y ~ log(X) )

# nls fit
model &lt;- nls(Y ~ NLS.logCurve(X, a, b) )

# drm fit
model &lt;- drm(Y ~ X, fct = DRC.logCurve() )
</code></pre>

<hr>
<h2 id='ma'>Moving average for a vector</h2><span id='topic+ma'></span>

<h3>Description</h3>

<p>This is a wrapper for the 'filter()' function that uses the convolution method
to calculate the moving averages of the terms in a vector, i.e. a series
of averages of different subsets of the full vector
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ma(x, n = 5, sides = 2)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ma_+3A_x">x</code></td>
<td>
<p>a numeric vector representing a time series</p>
</td></tr>
<tr><td><code id="ma_+3A_n">n</code></td>
<td>
<p>an integer, representing the number of values that compose each subset to be averaged</p>
</td></tr>
<tr><td><code id="ma_+3A_sides">sides</code></td>
<td>
<p>can be either 1 or 2. If sides = 1 the n values to be averaged are taken before
the preent values; If sides = 2 the n values are taken before and after the present value; If n
is odd, (n - 1)/2 values are taken before the present value and (n - 1)/2 are
taken after the present value, while, if n is even, more values are taken after
the present value</p>
</td></tr>
</table>


<h3>Value</h3>

<p>This function returns a vector of moving averages
</p>


<h3>Author(s)</h3>

<p>Andrea Onofri
</p>


<h3>Examples</h3>

<pre><code class='language-R'>series &lt;- c(319, 317, 332, 271, 301, 292, 351, 358, 259, 270)
ma(series, n = 4, sides = 2)

</code></pre>

<hr>
<h2 id='metamitron'>Degradation of metamitron in soil with co-applied herbicides</h2><span id='topic+metamitron'></span>

<h3>Description</h3>

<p>The dataset describes the degradation of metamitron in soil at 20°C
with several co-applied herbicides. It is a synthetic dataset,
that was generated by Monte Carlo methods, starting from the
observed data in Vischetti et al., 1996.
A data frame with 96 observations on the following 3 variables:
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data("metamitron")
</code></pre>


<h3>Format</h3>

<p>A data frame with 96 rows and 3 variables
</p>


<h3>Details</h3>


<ul>
<li><p> Time. numeric: Days from start of incubation
</p>
</li>
<li><p> Herbicide. factor: M is 'metamitron', MP is 'metamitron+phenmedipham', MC is 'metamitron+chloridazon' and MPC is 'metamitron+phenmedipham+chloridazon'
</p>
</li>
<li><p> Conc. numeric: residual concentration of metamitron
</p>
</li></ul>



<h3>References</h3>

<p>Vischetti, C., Marini, M., Businelli, M., Onofri, A., 1996. The effect of temperature and co-applied herbicides on the degradation rate of phenmedipham, chloridazon and metamitron in a clay loam soil in the laboratory, in: Re, A.D., Capri, E., Evans, S.P., Trevisan, M. (Eds.), “The Environmental Phate of Xenobiotics”, Proceedings X Symposium on Pesticide Chemistry, Piacenza. La Goliardica Pavese, Piacenza, pp. 287–294.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("metamitron")
metamitron

</code></pre>

<hr>
<h2 id='mixture'>Efficacy of the mixture of two herbicides</h2><span id='topic+mixture'></span>

<h3>Description</h3>

<p>Two herbicides are used alone and in mixture. It is a data frame
with 16 observations on the following 2 variables:
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data("mixture")
</code></pre>


<h3>Format</h3>

<p>A data frame with 24 rows and 2 variables
</p>


<h3>Details</h3>


<ul>
<li><p> Treat. Factor: the treatment levels
</p>
</li>
<li><p> Weight. numeric: the weight of weeds
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>data("degradation")
degradation

</code></pre>

<hr>
<h2 id='negExp'>Negative exponential functions</h2><span id='topic+negExp.fun'></span><span id='topic+negExpDist.fun'></span><span id='topic+NLS.negExp'></span><span id='topic+NLS.negExpDist'></span><span id='topic+DRC.negExp'></span><span id='topic+DRC.negExpDist'></span>

<h3>Description</h3>

<p>These functions provide the negative exponential model (negExp.fun) with the related self-starters for the <code><a href="stats.html#topic+nls">nls</a></code> function (NLS.negExp)  <code><a href="drc.html#topic+drm">drm</a></code> function in the 'drc' package (DRC.negExp) and the exponential cumulative distribution function (negExpDist.fun), with self-starters for both 'nls' (NLS.negExpDist) and 'drc' (DRC.negExpDist).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  negExp.fun(predictor, a, c)
  negExpDist.fun(predictor, c)
  NLS.negExp(predictor, a, c)
  DRC.negExp(fixed = c(NA, NA), names = c("a", "c"))
  NLS.negExpDist(predictor, c)
  DRC.negExpDist(fixed = NA, names = c("c"))
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="negExp_+3A_predictor">predictor</code></td>
<td>
<p>a numeric vector of values at which to evaluate the model.</p>
</td></tr>
<tr><td><code id="negExp_+3A_a">a</code></td>
<td>
<p>a numeric parameter representing the higher asymptote</p>
</td></tr>
<tr><td><code id="negExp_+3A_c">c</code></td>
<td>
<p>a numeric parameter that is proportional to the relative rate of increase of the fitted function</p>
</td></tr>
<tr><td><code id="negExp_+3A_fixed">fixed</code></td>
<td>
<p>numeric vector. Specifies which parameters are fixed and at what value they are fixed. NAs for parameter that are not fixed.</p>
</td></tr>
<tr><td><code id="negExp_+3A_names">names</code></td>
<td>
<p>a vector of character strings giving the names of the parameters. The default is reasonable.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The negative exponential model is given by the following function:
</p>
<p style="text-align: center;"><code class="reqn"> f(x) = \textrm{a} \{1 -  \exp [- \exp( c x )] \} </code>
</p>

<p>while the exponential CDF is obtained by setting a = 1:
</p>
<p style="text-align: center;"><code class="reqn"> f(x) = 1 -  \exp [- \exp( c x )] </code>
</p>

<p>The ‘drc’ package contains also the function AR.2(), where c is replaced
by e = 1/c. The ‘nlme’ package also contains an alternative
parameterisation named 'SSasympOrig()', where c
is replaced by phi3 = log(c).
</p>


<h3>Value</h3>

<p>negExp.fun and negExpDist.fun return a numeric value, while the self-starters return a list containing the nonlinear function, the self starter function and the parameter names.
</p>


<h3>Author(s)</h3>

<p>Andrea Onofri</p>


<h3>References</h3>

<p>Ratkowsky, DA (1990) Handbook of nonlinear regression models. New York (USA): Marcel Dekker Inc.
Onofri, A. (2020). A collection of self-starters for nonlinear regression in R. See: <a href="https://www.statforbiology.com/2020/stat_nls_usefulfunctions/">https://www.statforbiology.com/2020/stat_nls_usefulfunctions/</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>X &lt;- c(1, 3, 5, 7, 9, 11, 13, 20)
Y &lt;- c(4.5, 12.0, 16.1, 16.4, 18.9, 19.5, 19.3, 19.6)
model &lt;- drm(Y ~ X, fct = DRC.negExp())
summary(model)
</code></pre>

<hr>
<h2 id='pairComp'>Pairwise comparisons between the numeric elements of a vector</h2><span id='topic+pairComp'></span>

<h3>Description</h3>

<p>This function provides pairwise comparisons between the element of a vector, as long as a variance-covariance matrix is also provided
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pairComp(parm, vcovMat, nams = NULL, dfr = NULL, adjust = "none",
         level = 0.05, Letters = c(letters, LETTERS, "."),
         reversed = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="pairComp_+3A_parm">parm</code></td>
<td>
<p>A (possibly named) vector of estimates</p>
</td></tr>
<tr><td><code id="pairComp_+3A_vcovmat">vcovMat</code></td>
<td>
<p>Variance-covariance matrix for the estimates</p>
</td></tr>
<tr><td><code id="pairComp_+3A_nams">nams</code></td>
<td>
<p>A character vector of parameter names (optional). If it is not provided and if 'parm' is not a named vectors, numbers '1:length(parm)' are used.</p>
</td></tr>
<tr><td><code id="pairComp_+3A_dfr">dfr</code></td>
<td>
<p>An optional number of residual degrees of freedom (defaults to Inf)</p>
</td></tr>
<tr><td><code id="pairComp_+3A_adjust">adjust</code></td>
<td>
<p>A multiplicity adjustment method as in 'multcomp'. Defaults to &quot;none&quot;.</p>
</td></tr>
<tr><td><code id="pairComp_+3A_level">level</code></td>
<td>
<p>Protection level for compact letter display</p>
</td></tr>
<tr><td><code id="pairComp_+3A_letters">Letters</code></td>
<td>
<p>Vector of distinct characters (or character strings) used to connect levels that are not significantly different. They should be recogizable when concatenated. The default behaviour is to use the small letters, followed by the capital letters. See help for 'multcompView::multcompLetters()' for futher detail)</p>
</td></tr>
<tr><td><code id="pairComp_+3A_reversed">reversed</code></td>
<td>
<p>logical. Should the order of means/letters be decreasing? Defaults to FALSE, which means that the means and letters are in increasing order)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a list with the following elements
</p>
<table role = "presentation">
<tr><td><code>Pairs</code></td>
<td>
<p>A dataframe of pairwise comparisons</p>
</td></tr>
<tr><td><code>Letters</code></td>
<td>
<p>A dataframe with compact letter display</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Andrea Onofri
</p>


<h3>References</h3>

<p>Onofri A. (2020) The broken bridge between biologists and statisticians: a blog and R package, Statforbiology, IT, web: https://www.statforbiology.com
</p>


<h3>Examples</h3>

<pre><code class='language-R'># library(devtools)
# install_github("OnofriAndreaPG/aomisc")
library(statforbiology)
data(metamitron)

#Fit nls grouped model
modNlin &lt;- nls(Conc ~ A[Herbicide] * exp(-k[Herbicide] * Time),
               start=list(A=rep(100, 4), k=rep(0.06, 4)),
               data=metamitron)
tab &lt;- summary(modNlin)
tab

# Retreive infos and make comparisons
coefs &lt;- coef(modNlin)[5:8]
vcovMat &lt;- vcov(modNlin)[5:8, 5:8]
cp &lt;- pairComp(coefs, vcovMat, dfr = tab$df[2],
               adjust = "none", reversed = FALSE)
cp$Letters
cp$pairs
</code></pre>

<hr>
<h2 id='plotnls'>Plotting diagnostics for an <code>nls</code> object</h2><span id='topic+plotnls'></span>

<h3>Description</h3>

<p>This function is aimed at providing some types of plots to assess the goodness of fit for the selected model. Three plots (selectable by the argument 'which') are currently available: a plot of residuals against fitted values (which = 1), a Normal Q-Q plot (which = 2) and a plot of predicted against expected (line) and observed (symbols). By default, type = 3 is provided. As for the third graph, we can either plot all the data (type= &quot;all&quot;) or the group means (type = &quot;means&quot;; the default)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  plotnls(x, type = c("average", "all"),
                     xlim = NULL, gridsize = 100,
                     which = 3, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plotnls_+3A_x">x</code></td>
<td>
<p>an object of class 'nls'</p>
</td></tr>
<tr><td><code id="plotnls_+3A_type">type</code></td>
<td>
<p>it can be either &quot;means&quot; or &quot;all&quot;. In the first case, the group means are plotted for the third graph. It is only considered when which = 3</p>
</td></tr>
<tr><td><code id="plotnls_+3A_xlim">xlim</code></td>
<td>
<p>The limits for the x-axis (x1, x2)</p>
</td></tr>
<tr><td><code id="plotnls_+3A_gridsize">gridsize</code></td>
<td>
<p>For 'which = 3', it sets the resolution of the fitted line</p>
</td></tr>
<tr><td><code id="plotnls_+3A_which">which</code></td>
<td>
<p>The type of graph: can be 1, 2 or 3 (see description). It defaults to 3.</p>
</td></tr>
<tr><td><code id="plotnls_+3A_...">...</code></td>
<td>
<p>additional graphical arguments</p>
</td></tr>
</table>


<h3>Details</h3>

<p>It mimicks the behaviour of the function plot.lm()
</p>


<h3>Value</h3>

<p>No return value, it produces a plot</p>


<h3>Author(s)</h3>

<p>Andrea Onofri
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(statforbiology)
degradation &lt;- read.csv("https://www.casaonofri.it/_datasets/degradation.csv")
mod &lt;- nls(Conc ~ A*exp(-k*Time),
               start=list(A=100, k=0.05),
               data=degradation)
plotnls(mod, which = 3)
</code></pre>

<hr>
<h2 id='poly2'>Simple polynomial regression functions</h2><span id='topic+poly2.fun'></span><span id='topic+NLS.poly2'></span><span id='topic+DRC.poly2'></span>

<h3>Description</h3>

<p>These functions provide the simple polynomial (second order) regression model (poly2), the polynomial regression model with self-starter for the <code><a href="stats.html#topic+nls">nls</a></code> function (NLS.poly2) and the polynomial regression function with self-starter for the <code><a href="drc.html#topic+drm">drm</a></code> function in the drc package (DRC.poly2).  Fitting linear functions with nonlinear least square regression is sub-optimal, but it might be useful for comparing alternative models.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  poly2.fun(predictor, a, b, c)
  NLS.poly2(predictor, a, b, c)
  DRC.poly2(fixed = c(NA, NA, NA), names = c("a", "b", "c"))
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="poly2_+3A_predictor">predictor</code></td>
<td>
<p>a numeric vector of values at which to evaluate the model</p>
</td></tr>
<tr><td><code id="poly2_+3A_a">a</code></td>
<td>
<p>numeric. The response when the predictor is equal to 0.</p>
</td></tr>
<tr><td><code id="poly2_+3A_b">b</code></td>
<td>
<p>numeric. The slope at X = 0</p>
</td></tr>
<tr><td><code id="poly2_+3A_c">c</code></td>
<td>
<p>numeric. Regression parameter</p>
</td></tr>
<tr><td><code id="poly2_+3A_fixed">fixed</code></td>
<td>
<p>numeric vector. Specifies which parameters are fixed and at what value they are fixed. NAs for parameter that are not fixed.</p>
</td></tr>
<tr><td><code id="poly2_+3A_names">names</code></td>
<td>
<p>a vector of character strings giving the names of the parameters. The default is reasonable.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The simple polynomial (second order) regression model is given by the following equation:
</p>
<p style="text-align: center;"><code class="reqn"> f(x) = a +  b x + c x^2</code>
</p>



<h3>Value</h3>

<p>poly2.fun and NLS.poly2 return a numeric value, while DRC.poly2 returns a list containing the nonlinear function, the self starter function and the parameter names.
</p>


<h3>Author(s)</h3>

<p>Andrea Onofri</p>


<h3>References</h3>

<p>Ratkowsky, DA (1990) Handbook of nonlinear regression models. New York (USA): Marcel Dekker Inc.
</p>
<p>Onofri, A. (2020). A collection of self-starters for nonlinear regression in R. See: <a href="https://www.statforbiology.com/2020/stat_nls_usefulfunctions/">https://www.statforbiology.com/2020/stat_nls_usefulfunctions/</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Polynomial regression
X &lt;- seq(5, 50, 5)
Y &lt;- c(12.6, 74.1, 157.6, 225.5, 303.4, 462.8,
       669.9, 805.3, 964.2, 1169)

model &lt;- nls(Y ~ NLS.poly2(X, a, b, c))
summary(model)
model &lt;- drm(Y ~ X, fct = DRC.poly2())
summary(model)
</code></pre>

<hr>
<h2 id='R2nls'>
Goodness of fit for nonlinear regression
</h2><span id='topic+R2nls'></span>

<h3>Description</h3>

<p>This function calculates measures  of goodness of fit for nonlinear regression. It works with both 'nls' and 'drc' objects
</p>


<h3>Usage</h3>

<pre><code class='language-R'>R2nls(object)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="R2nls_+3A_object">object</code></td>
<td>
<p>A nonlinear regression fit object. It can be either a 'nls' fit or 'drm' fit.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with the following slots:
</p>
<table role = "presentation">
<tr><td><code>R2</code></td>
<td>
<p>Traditional coefficient of determination, calculated as the ratio of model SS to total SS. Formula as in Schabenberger and Pierce, 5.23, pag 211.</p>
</td></tr>
<tr><td><code>PseudoR2</code></td>
<td>
<p>Pseudo-R2, more useful for nonlinear regression with no-intercept-models. Formula Formula as in Schabenberger and Pierce, 5.24, pag 212.</p>
</td></tr>
<tr><td><code>R2adj</code></td>
<td>
<p>Adjusted R2, similar to R2 above, but penalised for higher number of parameters.</p>
</td></tr>
<tr><td><code>MSE</code></td>
<td>
<p>Mean Squared Error</p>
</td></tr>
<tr><td><code>RMSE</code></td>
<td>
<p> Root Means Squared Error</p>
</td></tr>
<tr><td><code>RRMSE</code></td>
<td>
<p>Relative Root Means Squared Error</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Andrea Onofri
</p>


<h3>References</h3>

<p>Schabenberger, O., Pierce, F.J., 2002. Contemporary statistical models for the plant and soil sciences. Taylor &amp; Francis, CRC Press, Books.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(beetGrowth)
mod3 &lt;- nls(weightInf ~ NLS.L3(DAE, b, c, d), data = beetGrowth)
R2nls(mod3)

mod4 &lt;- drm(weightInf ~ DAE, fct = L.3(), data = beetGrowth)
R2nls(mod4)
</code></pre>

<hr>
<h2 id='SSbeta'>Beta equation</h2><span id='topic+SSbeta'></span><span id='topic+beta.fun'></span><span id='topic+NLS.beta'></span><span id='topic+DRC.beta'></span>

<h3>Description</h3>

<p>These functions provide the beta equation, a threshold model that was derived
from the beta density function and it was adapted to describe phenomena taking place only
within a minimum and a maximum threshold value (threshold model), for example
to describe the germination rate (GR, i.e. the inverse of germination time)
as a function of temperature. These functions provide the beta
equation (beta.fun), the self-starters for the <code><a href="stats.html#topic+nls">nls</a></code>
function (NLS.beta) and the self-starters for
the <code><a href="drc.html#topic+drm">drm</a></code> function in the drc package (DRC.beta)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>beta.fun(X, b, d, Xb, Xo, Xc)
NLS.beta(X, b, d, Xb, Xo, Xc)
DRC.beta()
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="SSbeta_+3A_x">X</code></td>
<td>
<p>a numeric vector of values at which to evaluate the model</p>
</td></tr>
<tr><td><code id="SSbeta_+3A_b">b</code></td>
<td>
<p>model parameter</p>
</td></tr>
<tr><td><code id="SSbeta_+3A_d">d</code></td>
<td>
<p>model parameter</p>
</td></tr>
<tr><td><code id="SSbeta_+3A_xb">Xb</code></td>
<td>
<p>model parameter (base threshold level)</p>
</td></tr>
<tr><td><code id="SSbeta_+3A_xo">Xo</code></td>
<td>
<p>model parameter (optimal threshold level)</p>
</td></tr>
<tr><td><code id="SSbeta_+3A_xc">Xc</code></td>
<td>
<p>model parameter (ceiling threshold level)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This equation is parameterised as:
</p>
<p style="text-align: center;"><code class="reqn"> f(x) = max\left( d \left\{ \left( \frac{X - Xb}{Xo - Xb} \right) \left( \frac{Xc - X}{Xc - Xo} \right) ^{\frac{Xc - Xo}{Xo - Xb}} \right\}^b , 0 \right)</code>
</p>

<p>It depicts a curve that is equal to 0 for X &lt; Xb, grows up to a maximum,
that is attained at X = Xo and decreases down to 0, that is attained at
X = Xc and mantained for X &gt; Xc.
</p>


<h3>Value</h3>

<p>beta.fun, NLS.beta return a numeric value,
while DRC.beta returns a list containing the nonlinear function
and the self starter function
</p>


<h3>Author(s)</h3>

<p>Andrea Onofri
</p>


<h3>References</h3>

<p>Ratkowsky, DA (1990) Handbook of nonlinear regression models. New York (USA): Marcel Dekker Inc.
</p>
<p>Onofri, A. (2020). A collection of self-starters for nonlinear regression in R. See: <a href="https://www.statforbiology.com/2020/stat_nls_usefulfunctions/">https://www.statforbiology.com/2020/stat_nls_usefulfunctions/</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>X &lt;- c(1, 5, 10, 15, 20, 25, 30, 35, 40, 45, 50)
Y &lt;- c(0, 0, 0, 7.7, 12.3, 19.7, 22.4, 20.3, 6.6, 0, 0)

model &lt;- nls(Y ~ NLS.beta(X, b, d, Xb, Xo, Xc))
summary(model)
modelb &lt;- drm(Y ~ X, fct = DRC.beta())
summary(modelb)
plot(modelb, log = "")
</code></pre>

<hr>
<h2 id='SSbragg'>Bragg's Equation</h2><span id='topic+SSbragg'></span><span id='topic+bragg.3.fun'></span><span id='topic+bragg.4.fun'></span><span id='topic+NLS.bragg.4'></span><span id='topic+NLS.bragg.3'></span><span id='topic+DRC.bragg.4'></span><span id='topic+DRC.bragg.3'></span>

<h3>Description</h3>

<p>These functions provide the Bragg's equations, that is based on
the normal (Gaussian) distribution and it supports a maximum,
a minimum and inflection points. These functions provide the
equations with 4 (bragg.4.fun) and 3 (bragg.3.fun) parameters
with self-starters for the <code><a href="stats.html#topic+nls">nls</a></code>
function (NLS.bragg.4, NLS.bragg.3) and the self-starters for
the <code><a href="drc.html#topic+drm">drm</a></code> function in the drc package (DRC.bragg.4, DRC.bragg.3)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bragg.4.fun(X, b, c, d, e)
bragg.3.fun(X, b, d, e)
NLS.bragg.4(X, b, c, d, e)
NLS.bragg.3(X, b, d, e)
DRC.bragg.4()
DRC.bragg.3()
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="SSbragg_+3A_x">X</code></td>
<td>
<p>a numeric vector of values at which to evaluate the model</p>
</td></tr>
<tr><td><code id="SSbragg_+3A_b">b</code></td>
<td>
<p>model parameter (relates to slope at inflection point)</p>
</td></tr>
<tr><td><code id="SSbragg_+3A_d">d</code></td>
<td>
<p>model parameter (maximum value)</p>
</td></tr>
<tr><td><code id="SSbragg_+3A_e">e</code></td>
<td>
<p>model parameter (abscissa at maximum value)</p>
</td></tr>
<tr><td><code id="SSbragg_+3A_c">c</code></td>
<td>
<p>model parameter (lower asymptote)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The Bragg's equation is parameterised as:
</p>
<p style="text-align: center;"><code class="reqn"> f(x) = c + \left(d - c \right) \, \exp(- b \cdot (X - e)^2) </code>
</p>

<p>for the 4-parameter model. For the 3-parameter model, c is equal to 0.
It depicts a bell-shaped curve
</p>


<h3>Value</h3>

<p>bragg.4.fun, bragg.3.fun, NLS.bragg.4 and NLS.bragg.3
return a numeric value, while DRC.bragg.4 and DRC.bragg.3 return
a list containing the nonlinear function and the self starter function
</p>


<h3>Author(s)</h3>

<p>Andrea Onofri
</p>


<h3>References</h3>

<p>Ratkowsky, DA (1990) Handbook of nonlinear regression models. New York (USA): Marcel Dekker Inc.
</p>
<p>Onofri, A. (2020). A collection of self-starters for nonlinear regression in R. See: <a href="https://www.statforbiology.com/2020/stat_nls_usefulfunctions/">https://www.statforbiology.com/2020/stat_nls_usefulfunctions/</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(statforbiology)
X &lt;- c(5, 10, 15, 20, 25, 30, 35, 40, 45, 50)
Y1 &lt;- c(0.1, 2, 5.7, 9.3, 19.7, 28.4, 20.3, 6.6, 1.3, 0.1)
Y2 &lt;- Y1 + 2

# nls fit
mod.nls &lt;- nls(Y1 ~ NLS.bragg.3(X, b, d, e) )
mod.nls2 &lt;- nls(Y2 ~ NLS.bragg.4(X, b, c, d, e) )

# drm fit
mod.drc &lt;- drm(Y1 ~ X, fct = DRC.bragg.3() )
mod.drc2 &lt;- drm(Y2 ~ X, fct = DRC.bragg.4() )
plot(mod.drc, ylim = c(0, 30), log = "")
plot(mod.drc2, add = TRUE, col = "red")


</code></pre>

<hr>
<h2 id='SScousens85'>Rectangular hyperbola for yield/weed density relationship</h2><span id='topic+SScousens85'></span><span id='topic+cousens85.fun'></span><span id='topic+NLS.cousens85'></span><span id='topic+DRC.cousens85'></span>

<h3>Description</h3>

<p>These functions provide the rectangula hyperbola that was devided by Cousens (1985)
for modelling the relationship between crop yield and weed density. The function was
derived from the yield-loss function, and contains parameters that are revelant for
competition studies. These functions provide the
equation (cousens85.fun), the self-starters for the <code><a href="stats.html#topic+nls">nls</a></code>
function (NLS.cousens85) and the self-starters for
the <code><a href="drc.html#topic+drm">drm</a></code> function in the drc package (DRC.cousens85)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cousens85.fun(predictor, Ywf, i, A)
NLS.cousens85(predictor, Ywf, i, A)
DRC.cousens85(fixed = c(NA, NA, NA), names = c("Ywf", "i", "A"))
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="SScousens85_+3A_predictor">predictor</code></td>
<td>
<p>a numeric vector of values at which to evaluate the model</p>
</td></tr>
<tr><td><code id="SScousens85_+3A_ywf">Ywf</code></td>
<td>
<p>model parameter (Weed-free yield)</p>
</td></tr>
<tr><td><code id="SScousens85_+3A_i">i</code></td>
<td>
<p>model parameter (initial slope)</p>
</td></tr>
<tr><td><code id="SScousens85_+3A_a">A</code></td>
<td>
<p>model parameter (maximum percentage yield loss)</p>
</td></tr>
<tr><td><code id="SScousens85_+3A_fixed">fixed</code></td>
<td>
<p>numeric vector. Specifies which parameters are fixed and at what value they are fixed. NAs for parameter that are not fixed.</p>
</td></tr>
<tr><td><code id="SScousens85_+3A_names">names</code></td>
<td>
<p>a vector of character strings giving the names of the parameters. The default is usually reasonable.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This equation is parameterised as:
</p>
<p style="text-align: center;"><code class="reqn"> f(x) = Ywf \, \frac{(1 - (i predictor)} {(100 \, (1 + i \, predictor/A)))} </code>
</p>

<p>It depicts a decreasing curve with no inflection point. The curve is equal
to 'Ywf' when x = 0 and the lower asymptote is at 'A' multiplied by 'Ywf/100'
</p>


<h3>Value</h3>

<p>cousens85.fun, NLS.cousens85 return a numeric value,
while DRC.cousens85 return a list containing the nonlinear function
and the self starter function
</p>


<h3>Author(s)</h3>

<p>Andrea Onofri
</p>


<h3>References</h3>

<p>Ratkowsky, DA (1990) Handbook of nonlinear regression models. New York (USA): Marcel Dekker Inc.
</p>
<p>Onofri, A. (2020). A collection of self-starters for nonlinear regression in R. See: <a href="https://www.statforbiology.com/2020/stat_nls_usefulfunctions/">https://www.statforbiology.com/2020/stat_nls_usefulfunctions/</a>
</p>
<p>Cousens, R., 1985. A simple model relating yield loss to weed density. Annals of Applied Biology 107, 239–252. https://doi.org/10.1111/j.1744-7348.1985.tb01567.x
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(statforbiology)
dataset &lt;- getAgroData("Sinapis")

# nls fit
mod.nls &lt;- nls(yield ~ NLS.cousens85(density, Ywf, i, A),
               data = dataset )
summary(mod.nls)
mod.nls2 &lt;- drm(yield ~ density, fct = DRC.cousens85(), data = dataset )
summary(mod.nls2)
plot(mod.nls2)

</code></pre>

<hr>
<h2 id='SSE'>Modified Gompertz equations</h2><span id='topic+SSE'></span><span id='topic+E4.fun'></span><span id='topic+E3.fun'></span><span id='topic+E2.fun'></span><span id='topic+NLS.E4'></span><span id='topic+NLS.E3'></span><span id='topic+NLS.E2'></span><span id='topic+DRC.E4'></span><span id='topic+DRC.E3'></span><span id='topic+DRC.E2'></span>

<h3>Description</h3>

<p>These functions provide the modified Gompertz equations with 4 (E4.fun), 3 (E3.fun)
and 2 (E2.fun) parameters with self-starter for the <code><a href="stats.html#topic+nls">nls</a></code>
function (NLS.E4, NLS.E3 and NLS.E2) and for the <code><a href="drc.html#topic+drm">drm</a></code> function
in the 'drc' package (DRC.E4, DRC.E3 and DRC.E2).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>E4.fun(predictor, b, c, d, e)
E3.fun(predictor, b, d, e)
E2.fun(predictor, b, e)
NLS.E4(predictor, b, c, d, e)
NLS.E3(predictor, b, d, e)
NLS.E2(predictor, b, e)
DRC.E4(fixed = c(NA, NA, NA, NA), names = c("b", "c", "d", "e"))
DRC.E3(fixed = c(NA, NA, NA), names = c("b", "d", "e"))
DRC.E2(fixed = c(NA, NA), names = c("b", "e"))
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="SSE_+3A_predictor">predictor</code></td>
<td>
<p>a numeric vector of values at which to evaluate the model</p>
</td></tr>
<tr><td><code id="SSE_+3A_b">b</code></td>
<td>
<p>model parameter (slope at inflection point)</p>
</td></tr>
<tr><td><code id="SSE_+3A_c">c</code></td>
<td>
<p>model parameter (lower asymptote)</p>
</td></tr>
<tr><td><code id="SSE_+3A_d">d</code></td>
<td>
<p>model parameter (higher asymptote)</p>
</td></tr>
<tr><td><code id="SSE_+3A_e">e</code></td>
<td>
<p>model parameter (abscissa at inflection point)</p>
</td></tr>
<tr><td><code id="SSE_+3A_fixed">fixed</code></td>
<td>
<p>numeric vector. Specifies which parameters are fixed and at what value they are fixed. NAs for parameter that are not fixed.</p>
</td></tr>
<tr><td><code id="SSE_+3A_names">names</code></td>
<td>
<p>names. A vector of character strings giving the names of the parameters. The default is reasonable.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The modified Gompertz equation is parameterised as:
</p>
<p style="text-align: center;"><code class="reqn"> f(x) = c + (d - c) \, (1 - \exp \left[-exp( b (x - e))) \right] </code>
</p>

<p>It is a sygmoidally shaped curve and it is asymmetric about its inflection
point, but the type of asymmetry is different from the Gompertz equation.
For the 3- and 2-parameter model c is equal to 0, while for the
2-parameter model d is equal to 1.
</p>


<h3>Value</h3>

<p>E4.fun, E3.fun, E2.fun, NLS.E4, NLS.E3 and NLS.E2 return a numeric value,
while DRC.E4, DRC.E3 and DRC.E2 return a list containing the nonlinear function,
the self starter function and the parameter names.
</p>


<h3>Author(s)</h3>

<p>Andrea Onofri
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(beetGrowth)
mod3 &lt;- nls(weightInf ~ NLS.E3(DAE, b, c, d), data = beetGrowth)
summary(mod3)
plot(mod3)

</code></pre>

<hr>
<h2 id='SSGompertz'>Gompertz equations</h2><span id='topic+SSGompertz'></span><span id='topic+G4.fun'></span><span id='topic+G3.fun'></span><span id='topic+G2.fun'></span><span id='topic+NLS.G4'></span><span id='topic+NLS.G3'></span><span id='topic+NLS.G2'></span>

<h3>Description</h3>

<p>These functions provide the Gompertz equations with 4 (G4.fun), 3 (G3.fun)
and 2 (G2.fun) parameters with self-starter for the <code><a href="stats.html#topic+nls">nls</a></code>
function (NLS.G4, NLS.G3 and NLS.G2).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>G4.fun(predictor, b, c, d, e)
G3.fun(predictor, b, d, e)
G2.fun(predictor, b, e)
NLS.G4(predictor, b, c, d, e)
NLS.G3(predictor, b, d, e)
NLS.G2(predictor, b, e)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="SSGompertz_+3A_predictor">predictor</code></td>
<td>
<p>a numeric vector of values at which to evaluate the model</p>
</td></tr>
<tr><td><code id="SSGompertz_+3A_b">b</code></td>
<td>
<p>model parameter (slope at inflection point)</p>
</td></tr>
<tr><td><code id="SSGompertz_+3A_c">c</code></td>
<td>
<p>model parameter (lower asymptote)</p>
</td></tr>
<tr><td><code id="SSGompertz_+3A_d">d</code></td>
<td>
<p>model parameter (higher asymptote)</p>
</td></tr>
<tr><td><code id="SSGompertz_+3A_e">e</code></td>
<td>
<p>model parameter (abscissa at inflection point)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The Gompertz equation is parameterised as:
</p>
<p style="text-align: center;"><code class="reqn"> f(x) = c + (d - c) \, \exp \left[-exp(-b (x - e))\right] </code>
</p>

<p>It is a sygmoidally shaped curve and it is asymmetric about its inflection
point. For the 3- and 2-parameter model c is equal to 0, while for the
2-parameter model d is equal to 1.
</p>


<h3>Value</h3>

<p>All these functions return a numeric value.
</p>


<h3>Author(s)</h3>

<p>Andrea Onofri
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(beetGrowth)
mod3 &lt;- nls(weightInf ~ NLS.G3(DAE, b, c, d), data = beetGrowth)
summary(mod3)
plot(mod3)
</code></pre>

<hr>
<h2 id='SSL'>Logistic equations</h2><span id='topic+SSL'></span><span id='topic+L4.fun'></span><span id='topic+L3.fun'></span><span id='topic+L2.fun'></span><span id='topic+NLS.L4'></span><span id='topic+NLS.L3'></span><span id='topic+NLS.L2'></span><span id='topic+DRC.L2'></span>

<h3>Description</h3>

<p>These functions provide the logistic equations with 4 (L4.fun), 3 (L3.fun)
and 2 (L2.fun) parameters with self-starter for the <code><a href="stats.html#topic+nls">nls</a></code>
function (NLS.L4, NLS.L3 and NLS.L2) and the self-starter for logistic
function with two parameters for the <code><a href="drc.html#topic+drm">drm</a></code> function in the
drc package (DRC.L2).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>L4.fun(predictor, b, c, d, e)
L3.fun(predictor, b, d, e)
L2.fun(predictor, b, e)
NLS.L4(predictor, b, c, d, e)
NLS.L3(predictor, b, d, e)
NLS.L2(predictor, b, e)
DRC.L2(upper = 1, fixed = c(NA, NA), names = c("b", "e"))
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="SSL_+3A_predictor">predictor</code></td>
<td>
<p>a numeric vector of values at which to evaluate the model</p>
</td></tr>
<tr><td><code id="SSL_+3A_b">b</code></td>
<td>
<p>model parameter (slope at inflection point)</p>
</td></tr>
<tr><td><code id="SSL_+3A_c">c</code></td>
<td>
<p>model parameter (lower asymptote)</p>
</td></tr>
<tr><td><code id="SSL_+3A_d">d</code></td>
<td>
<p>model parameter (higher asymptote)</p>
</td></tr>
<tr><td><code id="SSL_+3A_e">e</code></td>
<td>
<p>model parameter (abscissa at inflection point)</p>
</td></tr>
<tr><td><code id="SSL_+3A_upper">upper</code></td>
<td>
<p>numeric. For L.2, a upper asymptote different from 1 can be specified.</p>
</td></tr>
<tr><td><code id="SSL_+3A_fixed">fixed</code></td>
<td>
<p>numeric vector. Specifies which parameters are fixed and at what value they are fixed. NAs for parameter that are not fixed.</p>
</td></tr>
<tr><td><code id="SSL_+3A_names">names</code></td>
<td>
<p>names. A vector of character strings giving the names of the parameters. The default is reasonable.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The logistic equation is parameterised as:
</p>
<p style="text-align: center;"><code class="reqn"> f(x) = c + \frac{d - c}{1+exp\left[-b(x - e)\right]} </code>
</p>

<p>for the 3- and 2-parameter model c is equal to 0, while for the 2-parameter model
d is equal to 1.
</p>


<h3>Value</h3>

<p>L4.fun, L3.fun, L2.fun, NLS.L4, NLS.L3 and NLS.L2 return a numeric value,
while DRC.L2 returns a list containing the nonlinear function, the self starter function
and the parameter names.
</p>


<h3>Author(s)</h3>

<p>Andrea Onofri
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(beetGrowth)
mod3 &lt;- nls(weightInf ~ NLS.L3(DAE, b, c, d), data = beetGrowth)
mod3b &lt;- drm(weightInf ~ DAE, fct=DRC.L2(upper = 25), data = beetGrowth)
</code></pre>

<hr>
<h2 id='SSLL'>Log-logistic equation</h2><span id='topic+SSLL'></span><span id='topic+LL4.fun'></span><span id='topic+LL3.fun'></span><span id='topic+LL2.fun'></span><span id='topic+NLS.LL4'></span><span id='topic+NLS.LL3'></span><span id='topic+NLS.LL2'></span>

<h3>Description</h3>

<p>These functions provide the loglogistic equation, that has a
symmetric sygmoidal shape over the logarithm of time and it has been used
for bioassay work. These functions provide the 4-, 3- and 2-parameter
equations (LL4.fun(), LL3.fun() and LL2.fun()) as well as the self-starters
for the <code><a href="stats.html#topic+nls">nls</a></code> function (NLS.LL4(), NLS.LL3() and NLS.LL2() )
</p>


<h3>Usage</h3>

<pre><code class='language-R'>LL4.fun(predictor, b, c, d, e)
LL3.fun(predictor, b, d, e)
LL2.fun(predictor, b, e)
NLS.LL4(predictor, b, c, d, e)
NLS.LL3(predictor, b, d, e)
NLS.LL2(predictor, b, e)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="SSLL_+3A_predictor">predictor</code></td>
<td>
<p>a numeric vector of values at which to evaluate the model</p>
</td></tr>
<tr><td><code id="SSLL_+3A_b">b</code></td>
<td>
<p>model parameter (slope at inflection point)</p>
</td></tr>
<tr><td><code id="SSLL_+3A_c">c</code></td>
<td>
<p>model parameter (lower asymptote)</p>
</td></tr>
<tr><td><code id="SSLL_+3A_d">d</code></td>
<td>
<p>model parameter (higher asymptote)</p>
</td></tr>
<tr><td><code id="SSLL_+3A_e">e</code></td>
<td>
<p>model parameter (abscissa at inflection point)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>These functions provide the log-logistic equation for bioassay work
This equation (4-parameters) is parameterised as:
</p>
<p style="text-align: center;"><code class="reqn"> f(x) = c + \frac{d - c}{\exp ( 1 + \exp ( - b\,(\log(x) - \log(e))))} </code>
</p>

<p>For the 3- and 2-parameters model, c is equal to 0, while for the 2-parameter
model d is equal to 1.
</p>


<h3>Value</h3>

<p>All these functions return a numeric value
</p>


<h3>Author(s)</h3>

<p>Andrea Onofri
</p>


<h3>References</h3>

<p>Ratkowsky, DA (1990) Handbook of nonlinear regression models. New York (USA): Marcel Dekker Inc.
</p>
<p>Onofri, A. (2020). A collection of self-starters for nonlinear regression in R. See: <a href="https://www.statforbiology.com/2020/stat_nls_usefulfunctions/">https://www.statforbiology.com/2020/stat_nls_usefulfunctions/</a>
</p>
<p>Ritz, C., Jensen, S.M., Gerhard, D., Streibig, J.C., 2019. Dose-response analysis using R, CRC Press. ed. USA.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>dataset &lt;- getAgroData("brassica")

model &lt;- nls(FW ~ NLS.LL4(Dose, b, c, d, e), data = dataset)
model &lt;- nls(FW ~ NLS.LL3(Dose, b, d, e), data = dataset)
model &lt;- nls(FW/max(FW) ~ NLS.LL2(Dose, b, e), data = dataset)
summary(model)

</code></pre>

<hr>
<h2 id='SSlorentz'>Lorentz equation</h2><span id='topic+SSlorentz'></span><span id='topic+lorentz.3.fun'></span><span id='topic+lorentz.4.fun'></span><span id='topic+NLS.lorentz.3'></span><span id='topic+NLS.lorentz.4'></span><span id='topic+DRC.lorentz.3'></span><span id='topic+DRC.lorentz.4'></span>

<h3>Description</h3>

<p>These functions provide the Lorentz equation with 3 and 4 parameters ('lorentz.3.fun()'
and 'lorentz.4.fun()' ), as well as the self-starters for the <code><a href="stats.html#topic+nls">nls</a></code>
function ( 'NLS.lorentz.3()' and 'NLS.lorentz.4()') and for the
<code><a href="drc.html#topic+drm">drm</a></code> function in the 'drc' package ('DRC.lorentz.3()' and 'DRC.lorentz.4()')
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lorentz.3.fun(X, b, d, e)
lorentz.4.fun(X, b, c, d, e)
NLS.lorentz.3(X, b, d, e)
NLS.lorentz.4(X, b, c, d, e)
DRC.lorentz.3()
DRC.lorentz.4()
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="SSlorentz_+3A_x">X</code></td>
<td>
<p>a numeric vector of values at which to evaluate the model</p>
</td></tr>
<tr><td><code id="SSlorentz_+3A_b">b</code></td>
<td>
<p>model parameter</p>
</td></tr>
<tr><td><code id="SSlorentz_+3A_d">d</code></td>
<td>
<p>model parameter</p>
</td></tr>
<tr><td><code id="SSlorentz_+3A_e">e</code></td>
<td>
<p>model parameter</p>
</td></tr>
<tr><td><code id="SSlorentz_+3A_c">c</code></td>
<td>
<p>model parameter</p>
</td></tr>
</table>


<h3>Details</h3>

<p>These functions provide the Lorentz equation, that is a bell-shaped
curve similar to a gaussian density function. It is parameterised as:
</p>
<p style="text-align: center;"><code class="reqn"> f(x) = c + \frac{d - c} {( 1 + b \, (X - e)^2) } </code>
</p>

<p>The parameter 'e' represents the abscissa of the maximum value,
while c is the minimum (asymptotic) response value and d is the maximum
response value. The parameter 'b' relates to the slope at inflection
point. For the 3-parameters curve, c is equal to 0.
</p>


<h3>Value</h3>

<p>lorentz.3.fun(), lorentz.4.fun(), NLS.lorentz.3() and NLS.lorentz.4() return a numeric value,
while DRC.lorentz.3() and DRC.lorentz.4()  returns a list containing
the nonlinear function, the self starter function and the parameter names.
</p>


<h3>Author(s)</h3>

<p>Andrea Onofri
</p>


<h3>References</h3>

<p>Ratkowsky, DA (1990) Handbook of nonlinear regression models. New York (USA): Marcel Dekker Inc.
</p>
<p>Onofri, A. (2020). A collection of self-starters for nonlinear regression in R. See: <a href="https://www.statforbiology.com/2020/stat_nls_usefulfunctions/">https://www.statforbiology.com/2020/stat_nls_usefulfunctions/</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
X &lt;- c(5, 10, 15, 20, 25, 30, 35, 40, 45, 50)
Y1 &lt;- c(0.1, 2, 5.7, 9.3, 19.7, 28.4, 20.3, 6.6, 1.3, 0.1)
Y2 &lt;- Y1 + 2

# nls fit
mod.nls &lt;- nls(Y1 ~ NLS.lorentz.3(X, b, d, e) )
mod.nls2 &lt;- nls(Y2 ~ NLS.lorentz.4(X, b, c, d, e) )

# drm fit
mod.drc &lt;- drm(Y1 ~ X, fct = DRC.lorentz.3() )
mod.drc2 &lt;- drm(Y2 ~ X, fct = DRC.lorentz.4() )
plot(mod.drc, ylim = c(0, 30), log = "")
plot(mod.drc2, add = TRUE, col = "red")


</code></pre>

<hr>
<h2 id='SSpowerCurve'>Power curve equation</h2><span id='topic+SSpowerCurve'></span><span id='topic+powerCurve.fun'></span><span id='topic+NLS.powerCurve'></span><span id='topic+DRC.powerCurve'></span>

<h3>Description</h3>

<p>These functions provide the Power curve equation, that is also known
as the Freundlich equation and it is very used in agricultural chemistry,
e.g. to model the sorption of xenobiotics in soil. It is also used to model
the number of plant species as a function of sampling area
(Muller-Dumbois method). These functions provide the equation
('powerCurve.fun()') as well as the self-starters
for the <code><a href="stats.html#topic+nls">nls</a></code> function ( 'NLS.powerCurve()' ) and for the
<code><a href="drc.html#topic+drm">drm</a></code> function in the 'drc' package ('DRC.powerCurve()')
</p>


<h3>Usage</h3>

<pre><code class='language-R'>powerCurve.fun(predictor, a, b)
NLS.powerCurve(predictor, a, b)
DRC.powerCurve(fixed = c(NA, NA), names = c("a", "b"))
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="SSpowerCurve_+3A_predictor">predictor</code></td>
<td>
<p>a numeric vector of values at which to evaluate the model</p>
</td></tr>
<tr><td><code id="SSpowerCurve_+3A_a">a</code></td>
<td>
<p>model parameter</p>
</td></tr>
<tr><td><code id="SSpowerCurve_+3A_b">b</code></td>
<td>
<p>model parameter</p>
</td></tr>
<tr><td><code id="SSpowerCurve_+3A_fixed">fixed</code></td>
<td>
<p>numeric vector. Specifies which parameters are fixed and at what value they are fixed. NAs for parameter that are not fixed.</p>
</td></tr>
<tr><td><code id="SSpowerCurve_+3A_names">names</code></td>
<td>
<p>names. A vector of character strings giving the names of the parameters. The default is reasonable.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>These functions provide the Power curve equation, that is parameterised as:
</p>
<p style="text-align: center;"><code class="reqn"> f(x) = a \, x^b </code>
</p>

<p>which is totally equivalent to an exponential curve on the logarithm
of X:
</p>
<p style="text-align: center;"><code class="reqn"> f(x) = a \, \exp \left[ b \, \log(x) \right] </code>
</p>

<p>We see that both parameters relate to the ‘slope’ of the curve and b
dictates its shape. If 0 &lt; b &lt; 1, the response Y increases as X
increases and the curve is convex up. If b &lt; 0 the curve is concave
up and Y decreases as X increases. Otherwise, if b &gt; 1, the curve is
concave up and Y increases as X increases.
</p>


<h3>Value</h3>

<p>powerCurve.fun() and NLS.powerCurve() return a numeric value,
while DRC.powerCurve() returns a list containing the nonlinear function, the self starter function
and the parameter names.
</p>


<h3>Author(s)</h3>

<p>Andrea Onofri
</p>


<h3>References</h3>

<p>Ratkowsky, DA (1990) Handbook of nonlinear regression models. New York (USA): Marcel Dekker Inc.
</p>
<p>Onofri, A. (2020). A collection of self-starters for nonlinear regression in R. See: <a href="https://www.statforbiology.com/2020/stat_nls_usefulfunctions/">https://www.statforbiology.com/2020/stat_nls_usefulfunctions/</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>dataset &lt;-getAgroData("speciesArea")

#nls fit
model &lt;- nls(numSpecies ~ NLS.powerCurve(Area, a, b),
             data = dataset)
summary(model)
# drm fit
model &lt;- drm(numSpecies ~ Area, fct = DRC.powerCurve(),
             data = dataset)
summary(model)

</code></pre>

<hr>
<h2 id='SSW1'>Weibull equation (Type I)</h2><span id='topic+SSW1'></span><span id='topic+W1.4.fun'></span><span id='topic+W1.3.fun'></span><span id='topic+W1.2.fun'></span><span id='topic+NLS.W1.4'></span><span id='topic+NLS.W1.3'></span><span id='topic+NLS.W1.2'></span>

<h3>Description</h3>

<p>These functions provide the Weibull equation (type I), that has an
asymmetric sygmoidal shape and it has been used for bioassay work.
These functions provide the 4-, 3- and 2-parameter equations
(W1.4.fun(), W1.3.fun() and W1.2.fun()) as well as the self-starters
for the <code><a href="stats.html#topic+nls">nls</a></code> function (NLS.W1.4(), NLS.W1.3() and NLS.W1.2()
</p>


<h3>Usage</h3>

<pre><code class='language-R'>W1.4.fun(predictor, b, c, d, e)
W1.3.fun(predictor, b, d, e)
W1.2.fun(predictor, b, e)
NLS.W1.4(predictor, b, c, d, e)
NLS.W1.3(predictor, b, d, e)
NLS.W1.2(predictor, b, e)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="SSW1_+3A_predictor">predictor</code></td>
<td>
<p>a numeric vector of values at which to evaluate the model</p>
</td></tr>
<tr><td><code id="SSW1_+3A_b">b</code></td>
<td>
<p>model parameter (slope at inflection point)</p>
</td></tr>
<tr><td><code id="SSW1_+3A_c">c</code></td>
<td>
<p>model parameter (lower asymptote)</p>
</td></tr>
<tr><td><code id="SSW1_+3A_d">d</code></td>
<td>
<p>model parameter (higher asymptote)</p>
</td></tr>
<tr><td><code id="SSW1_+3A_e">e</code></td>
<td>
<p>model parameter (abscissa at inlection point)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>These functions provide the Weibull (Type I) equation for bioassay work
This equation (4-parameters) is parameterised as:
</p>
<p style="text-align: center;"><code class="reqn"> f(x) = c + (d - c) \exp ( - \exp ( - b\,(\log(x) - \log(e)))) </code>
</p>

<p>For the 3- and 2-parameters model, c is equal to 0, while for the 2-parameter
model d is equal to 1.
</p>


<h3>Value</h3>

<p>All these functions return a numeric value
</p>


<h3>Author(s)</h3>

<p>Andrea Onofri
</p>


<h3>References</h3>

<p>Ratkowsky, DA (1990) Handbook of nonlinear regression models. New York (USA): Marcel Dekker Inc.
</p>
<p>Onofri, A. (2020). A collection of self-starters for nonlinear regression in R. See: <a href="https://www.statforbiology.com/2020/stat_nls_usefulfunctions/">https://www.statforbiology.com/2020/stat_nls_usefulfunctions/</a>
</p>
<p>Ritz, C., Jensen, S.M., Gerhard, D., Streibig, J.C., 2019. Dose-response analysis using R, CRC Press. ed. USA.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(statforbiology)
dataset &lt;- getAgroData("brassica")
model &lt;- nls(FW ~ NLS.W1.4(Dose, b, c, d, e), data = dataset)
model.2 &lt;- nls(FW ~ NLS.W1.3(Dose, b, d, e), data = dataset)
model.3 &lt;- nls(FW/max(FW) ~ NLS.W1.2(Dose, b, e), data = dataset)
summary(model)


</code></pre>

<hr>
<h2 id='SSW2'>Weibull equation (Type II)</h2><span id='topic+SSW2'></span><span id='topic+W2.4.fun'></span><span id='topic+W2.3.fun'></span><span id='topic+W2.2.fun'></span><span id='topic+NLS.W2.4'></span><span id='topic+NLS.W2.3'></span><span id='topic+NLS.W2.2'></span>

<h3>Description</h3>

<p>These functions provide the Weibull equation (type II), that has an
asymmetric sygmoidal shape and it has been used for bioassay work.
These functions provide the 4-, 3- and 2-parameter equations
(W2.4.fun(), W2.3.fun() and W2.2.fun()) as well as the self-starters
for the <code><a href="stats.html#topic+nls">nls</a></code> function (NLS.W2.4(), NLS.W2.3() and NLS.W2.2()
</p>


<h3>Usage</h3>

<pre><code class='language-R'>W2.4.fun(predictor, b, c, d, e)
W2.3.fun(predictor, b, d, e)
W2.2.fun(predictor, b, e)
NLS.W2.4(predictor, b, c, d, e)
NLS.W2.3(predictor, b, d, e)
NLS.W2.2(predictor, b, e)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="SSW2_+3A_predictor">predictor</code></td>
<td>
<p>a numeric vector of values at which to evaluate the model</p>
</td></tr>
<tr><td><code id="SSW2_+3A_b">b</code></td>
<td>
<p>model parameter (slope at inflection point)</p>
</td></tr>
<tr><td><code id="SSW2_+3A_c">c</code></td>
<td>
<p>model parameter (lower asymptote)</p>
</td></tr>
<tr><td><code id="SSW2_+3A_d">d</code></td>
<td>
<p>model parameter (higher asymptote)</p>
</td></tr>
<tr><td><code id="SSW2_+3A_e">e</code></td>
<td>
<p>model parameter (abscissa at inlection point)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>These functions provide the Weibull (Type I) equation for bioassay work
This equation (4-parameters) is parameterised as:
</p>
<p style="text-align: center;"><code class="reqn"> f(x) = c + (d - c) (1 - \exp( - \exp (b \, (\log(x) - \log(e))))) </code>
</p>

<p>For the 3- and 2-parameters model, c is equal to 0, while for the 2-parameter
model d is equal to 1.
</p>


<h3>Value</h3>

<p>All these functions return a numeric value
</p>


<h3>Author(s)</h3>

<p>Andrea Onofri
</p>


<h3>References</h3>

<p>Ratkowsky, DA (1990) Handbook of nonlinear regression models. New York (USA): Marcel Dekker Inc.
</p>
<p>Onofri, A. (2020). A collection of self-starters for nonlinear regression in R. See: <a href="https://www.statforbiology.com/2020/stat_nls_usefulfunctions/">https://www.statforbiology.com/2020/stat_nls_usefulfunctions/</a>
</p>
<p>Ritz, C., Jensen, S.M., Gerhard, D., Streibig, J.C., 2019. Dose-response analysis using R, CRC Press. ed. USA.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(statforbiology)
dataset &lt;- getAgroData("brassica")
model &lt;- nls(FW ~ NLS.W2.4(Dose, b, c, d, e), data = dataset)
model &lt;- nls(FW ~ NLS.W2.3(Dose, b, d, e), data = dataset)
model &lt;- nls(FW/max(FW) ~ NLS.W2.2(Dose, b, e), data = dataset)
summary(model)

</code></pre>

<hr>
<h2 id='SSYL'>Yield loss equation (Rectangular hyperbola)</h2><span id='topic+SSYL'></span><span id='topic+YL.fun'></span><span id='topic+NLS.YL'></span><span id='topic+DRC.YL'></span>

<h3>Description</h3>

<p>These functions provide the yield loss equation, based on
a rectangular hyperbola, supporting a higher asymptote and
no inflection points. These functions provide the
equation (YL.fun), the equation
with self-starters for the <code><a href="stats.html#topic+nls">nls</a></code>
function (NLS.YL) and equation with self-starters for
the <code><a href="drc.html#topic+drm">drm</a></code> function in the drc package (DRC.YL)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>YL.fun(predictor, i, A)
NLS.YL(predictor, i, A)
DRC.YL(fixed = c(NA, NA), names = c("i", "A"))
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="SSYL_+3A_predictor">predictor</code></td>
<td>
<p>a numeric vector of values at which to evaluate the model</p>
</td></tr>
<tr><td><code id="SSYL_+3A_i">i</code></td>
<td>
<p>model parameter (initial slope)</p>
</td></tr>
<tr><td><code id="SSYL_+3A_a">A</code></td>
<td>
<p>model parameter (maximum percentage yield loss)</p>
</td></tr>
<tr><td><code id="SSYL_+3A_fixed">fixed</code></td>
<td>
<p>numeric vector. Specifies which parameters are fixed and at what value they are fixed. NAs for parameter that are not fixed.</p>
</td></tr>
<tr><td><code id="SSYL_+3A_names">names</code></td>
<td>
<p>a vector of character strings giving the names of the parameters. The default is usually reasonable.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The Yield-loss equation is parameterised as:
</p>
<p style="text-align: center;"><code class="reqn"> f(x) = \frac{i \, x}{1 + (i \, x)/A}   </code>
</p>
<p>,
it is convex and asymptotically increasing, while the predictor increases.
The response is zero when the predictor is also zero and it was mainly used
to describe yield losses (in percentage) due to weed competition, expressed
as plant density (Cousens, 1985)
</p>


<h3>Value</h3>

<p>YL.fun and NLS.YL return a numeric value, while DRC.YL returns
a list containing the nonlinear function and the self starter function
</p>


<h3>Author(s)</h3>

<p>Andrea Onofri
</p>


<h3>References</h3>

<p>Ratkowsky, DA (1990) Handbook of nonlinear regression models. New York (USA): Marcel Dekker Inc.
</p>
<p>Onofri, A. (2020). A collection of self-starters for nonlinear regression in R. See: <a href="https://www.statforbiology.com/2020/stat_nls_usefulfunctions/">https://www.statforbiology.com/2020/stat_nls_usefulfunctions/</a>
</p>
<p>Cousens, R., 1985. A simple model relating yield loss to weed density. Annals of Applied Biology 107, 239–252. https://doi.org/10.1111/j.1744-7348.1985.tb01567.x
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(statforbiology)
WeedDens &lt;- c(0, 5, 10, 20, 25)
YieldLoss &lt;- c(0, 17.9, 21.5, 27.4, 29.5)

# nls fit
mod.nls &lt;- nls(YieldLoss ~ NLS.YL(WeedDens, i, A) )
summary(mod.nls)
# drm fit
mod.drc &lt;- drm(YieldLoss ~ WeedDens, fct = DRC.YL() )
summary(mod.drc)

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
