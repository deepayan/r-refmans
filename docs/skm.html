<!DOCTYPE html><html><head><title>Help for package skm</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {skm}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#col_max_idx'><p>col_max_idx</p></a></li>
<li><a href='#col_max_val'><p>col_max_val</p></a></li>
<li><a href='#col_min_idx'><p>col_min_idx</p></a></li>
<li><a href='#col_min_val'><p>col_min_val</p></a></li>
<li><a href='#col_rgn_val'><p>col_rgn_val</p></a></li>
<li><a href='#dist_wlatlng'><p>dist_wlatlng</p></a></li>
<li><a href='#dist_wlatlng_cpp'><p>dist_wlatlng_cpp</p></a></li>
<li><a href='#skm_gdp_cpp'><p>skm_gdp_cpp</p></a></li>
<li><a href='#skm_minmax_cpp'><p>skm_minmax_cpp</p></a></li>
<li><a href='#skm_mlp_cpp'><p>skm_mlp_cpp</p></a></li>
<li><a href='#skm_mls'><p>skm_mls</p></a></li>
<li><a href='#skm_mls_cpp'><p>skm_mls_cpp</p></a></li>
<li><a href='#skm_rgi_cpp'><p>skm_rgi_cpp</p></a></li>
<li><a href='#skm_rgs_cpp'><p>skm_rgs_cpp</p></a></li>
<li><a href='#skm_sgl_cpp'><p>skm_sgl_cpp</p></a></li>
<li><a href='#skmRpl_mlp_cpp'><p>skmRpl_mlp_cpp</p></a></li>
<li><a href='#skmSolution'><p>skmSolution</p></a></li>
<li><a href='#source_zip_list'><p>source_zip_list</p></a></li>
<li><a href='#stratified_sampling'><p>stratified_sampling</p></a></li>
<li><a href='#zip2012'><p>zip2012</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Selective k-Means</td>
</tr>
<tr>
<td>Version:</td>
<td>0.1.5.4</td>
</tr>
<tr>
<td>Author:</td>
<td>Guang Yang</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Guang Yang &lt;gyang274@gmail.com&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Algorithms for solving selective k-means problem,
    which is defined as finding k rows in an m x n matrix such that 
    the sum of each column minimal is minimized. 
    In the scenario when m == n and each cell value in matrix is a 
    valid distance metric, this is equivalent to a k-means problem. 
    The selective k-means extends the k-means problem in the sense 
    that it is possible to have m != n, often the case m &lt; n which 
    implies the search is limited within a small subset of rows. 
    Also, the selective k-means extends the k-means problem in the 
    sense that the instance in row set can be instance not seen in 
    the column set, e.g., select 2 from 3 internet service provider
    (row) for 5 houses (column) such that minimize the overall cost 
    (cell value) - overall cost is the sum of the column minimal of
    the selected 2 service provider.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://opensource.org/licenses/mit-license.php">MIT</a> + file LICENSE</td>
</tr>
<tr>
<td>LazyData:</td>
<td>TRUE</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="http://github.com/gyang274/skm">http://github.com/gyang274/skm</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="http://github.com/gyang274/skm/issues">http://github.com/gyang274/skm/issues</a></td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>5.0.1</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.0.0), magrittr, data.table</td>
</tr>
<tr>
<td>Imports:</td>
<td>methods, plyr, Rcpp (&ge; 0.12.5), RcppParallel</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>Rcpp, RcppArmadillo, RcppParallel</td>
</tr>
<tr>
<td>SystemRequirements:</td>
<td>GNU make</td>
</tr>
<tr>
<td>Suggests:</td>
<td>knitr, rmarkdown</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2017-01-23 06:02:24 UTC; gyang</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2017-01-23 08:22:33</td>
</tr>
</table>
<hr>
<h2 id='col_max_idx'>col_max_idx</h2><span id='topic+col_max_idx'></span>

<h3>Description</h3>

<p>calculate colvec max value index within limited range
</p>


<h3>Usage</h3>

<pre><code class='language-R'>col_max_idx(u, wlmt)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="col_max_idx_+3A_u">u</code></td>
<td>
<p>u: a numeric colvec</p>
</td></tr>
<tr><td><code id="col_max_idx_+3A_wlmt">wlmt</code></td>
<td>
<p>wlmt: limit search on colvec on indices within wlmt</p>
</td></tr>
</table>


<h3>Value</h3>

<p>id
an index of max value in u within wlmt w.r.t to original index
</p>


<h3>Note</h3>

<p>cpp use index start from 0 vs r use index start from 1
</p>
<p>in case of equal std:min/std:max take first index seen
</p>


<h3>See Also</h3>

<p>Other matrix_minmax: <code><a href="#topic+col_max_val">col_max_val</a></code>,
<code><a href="#topic+col_min_idx">col_min_idx</a></code>, <code><a href="#topic+col_min_val">col_min_val</a></code>,
<code><a href="#topic+col_rgn_val">col_rgn_val</a></code>
</p>

<hr>
<h2 id='col_max_val'>col_max_val</h2><span id='topic+col_max_val'></span>

<h3>Description</h3>

<p>calculate colvec max value within limited range
</p>


<h3>Usage</h3>

<pre><code class='language-R'>col_max_val(u, wlmt)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="col_max_val_+3A_u">u</code></td>
<td>
<p>u: a numeric colvec</p>
</td></tr>
<tr><td><code id="col_max_val_+3A_wlmt">wlmt</code></td>
<td>
<p>wlmt: limit search on colvec on indices within wlmt</p>
</td></tr>
</table>


<h3>Value</h3>

<p>vd
min value in u within wlmt w.r.t to original index
</p>


<h3>See Also</h3>

<p>Other matrix_minmax: <code><a href="#topic+col_max_idx">col_max_idx</a></code>,
<code><a href="#topic+col_min_idx">col_min_idx</a></code>, <code><a href="#topic+col_min_val">col_min_val</a></code>,
<code><a href="#topic+col_rgn_val">col_rgn_val</a></code>
</p>

<hr>
<h2 id='col_min_idx'>col_min_idx</h2><span id='topic+col_min_idx'></span>

<h3>Description</h3>

<p>calculate colvec min value index within limited range
</p>


<h3>Usage</h3>

<pre><code class='language-R'>col_min_idx(u, wlmt)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="col_min_idx_+3A_u">u</code></td>
<td>
<p>u: a numeric colvec</p>
</td></tr>
<tr><td><code id="col_min_idx_+3A_wlmt">wlmt</code></td>
<td>
<p>wlmt: limit search on colvec on indices within wlmt</p>
</td></tr>
</table>


<h3>Value</h3>

<p>id
an index of min value in u within wlmt w.r.t to original index
</p>


<h3>Note</h3>

<p>cpp use index start from 0 vs r use index start from 1
</p>
<p>in case of equal std:min/std:max take first index seen
</p>


<h3>See Also</h3>

<p>Other matrix_minmax: <code><a href="#topic+col_max_idx">col_max_idx</a></code>,
<code><a href="#topic+col_max_val">col_max_val</a></code>, <code><a href="#topic+col_min_val">col_min_val</a></code>,
<code><a href="#topic+col_rgn_val">col_rgn_val</a></code>
</p>

<hr>
<h2 id='col_min_val'>col_min_val</h2><span id='topic+col_min_val'></span>

<h3>Description</h3>

<p>calculate colvec min value within limited range
</p>


<h3>Usage</h3>

<pre><code class='language-R'>col_min_val(u, wlmt)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="col_min_val_+3A_u">u</code></td>
<td>
<p>u: a numeric colvec</p>
</td></tr>
<tr><td><code id="col_min_val_+3A_wlmt">wlmt</code></td>
<td>
<p>wlmt: limit search on colvec on indices within wlmt</p>
</td></tr>
</table>


<h3>Value</h3>

<p>vd
min value in u within wlmt w.r.t to original index
</p>


<h3>See Also</h3>

<p>Other matrix_minmax: <code><a href="#topic+col_max_idx">col_max_idx</a></code>,
<code><a href="#topic+col_max_val">col_max_val</a></code>, <code><a href="#topic+col_min_idx">col_min_idx</a></code>,
<code><a href="#topic+col_rgn_val">col_rgn_val</a></code>
</p>

<hr>
<h2 id='col_rgn_val'>col_rgn_val</h2><span id='topic+col_rgn_val'></span>

<h3>Description</h3>

<p>calculate colvec range = max - min value within limited range
</p>


<h3>Usage</h3>

<pre><code class='language-R'>col_rgn_val(u, wlmt)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="col_rgn_val_+3A_u">u</code></td>
<td>
<p>u: a numeric colvec</p>
</td></tr>
<tr><td><code id="col_rgn_val_+3A_wlmt">wlmt</code></td>
<td>
<p>wlmt: limit search on colvec on indices within wlmt</p>
</td></tr>
</table>


<h3>Value</h3>

<p>vd
max - min value in u within wlmt w.r.t to original index
</p>


<h3>See Also</h3>

<p>Other matrix_minmax: <code><a href="#topic+col_max_idx">col_max_idx</a></code>,
<code><a href="#topic+col_max_val">col_max_val</a></code>, <code><a href="#topic+col_min_idx">col_min_idx</a></code>,
<code><a href="#topic+col_min_val">col_min_val</a></code>
</p>

<hr>
<h2 id='dist_wlatlng'>dist_wlatlng</h2><span id='topic+dist_wlatlng'></span>

<h3>Description</h3>

<p>calculate distance btwn coordinate1&lt;lat1, lng1&gt; and coordinate2&lt;lat2, lng2&gt;
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dist_wlatlng(.lat1, .lng1, .lat2, .lng2, .measure = "mi")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dist_wlatlng_+3A_.lat1">.lat1</code></td>
<td>
<p>latitude of coordinate1</p>
</td></tr>
<tr><td><code id="dist_wlatlng_+3A_.lng1">.lng1</code></td>
<td>
<p>longitude of coordinate1</p>
</td></tr>
<tr><td><code id="dist_wlatlng_+3A_.lat2">.lat2</code></td>
<td>
<p>latitude of coordinate2</p>
</td></tr>
<tr><td><code id="dist_wlatlng_+3A_.lng2">.lng2</code></td>
<td>
<p>longitude of coordinate2</p>
</td></tr>
<tr><td><code id="dist_wlatlng_+3A_.measure">.measure</code></td>
<td>
<p>- mi or km</p>
</td></tr>
</table>


<h3>Details</h3>

<p>calculate the great circle distance between 2 points with Haversine formula,
which deliberately ignores elevation differences.
</p>
<p>Haversine formula (from R.W. Sinnott, &quot;Virtues of the Haversine&quot;,
Sky and Telescope, vol. 68, no. 2, 1984, p. 159):
</p>
<p>dlon = lon2 - lon1
</p>
<p>dlat = lat2 - lat1
</p>
<p>a = sin^2(dlat/2) + cos(lat1) * cos(lat2) * sin^2(dlon/2)
</p>
<p>c = 2 * arcsin(min(1,sqrt(a)))
</p>
<p>d = R * c
</p>

<hr>
<h2 id='dist_wlatlng_cpp'>dist_wlatlng_cpp</h2><span id='topic+distRpl_wlatlng_cpp'></span><span id='topic+distSgl_wlatlng_cpp'></span><span id='topic+dist_wlatlng_cpp'></span><span id='topic+dist_wlatlng_km_cpp'></span><span id='topic+dist_wlatlng_mi_cpp'></span>

<h3>Description</h3>

<p>calculate distance between coordinate1&lt;lat1, lng1&gt; and coordinate2&lt;lat2, lng2&gt;
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dist_wlatlng_mi_cpp(lat1, lng1, lat2, lng2)

dist_wlatlng_km_cpp(lat1, lng1, lat2, lng2)

distSgl_wlatlng_cpp(lat1, lng1, lat2, lng2, measure = "mi")

distRpl_wlatlng_cpp(lat1, lng1, lat2, lng2, measure = "mi",
  distRpl_GS = 100L)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dist_wlatlng_cpp_+3A_lat1">lat1</code></td>
<td>
<p>latitude of coordinate1</p>
</td></tr>
<tr><td><code id="dist_wlatlng_cpp_+3A_lng1">lng1</code></td>
<td>
<p>longitude of coordinate1</p>
</td></tr>
<tr><td><code id="dist_wlatlng_cpp_+3A_lat2">lat2</code></td>
<td>
<p>latitude of coordinate2</p>
</td></tr>
<tr><td><code id="dist_wlatlng_cpp_+3A_lng2">lng2</code></td>
<td>
<p>longitude of coordinate2</p>
</td></tr>
<tr><td><code id="dist_wlatlng_cpp_+3A_measure">measure</code></td>
<td>
<p>&quot;mi&quot; (mile) or &quot;km&quot; (kilometer)</p>
</td></tr>
<tr><td><code id="dist_wlatlng_cpp_+3A_distrpl_gs">distRpl_GS</code></td>
<td>
<p>The grain size of a parallel algorithm sets a minimum chunk size for parallelization.
In other words, at what point to stop processing input on separate threads (as sometimes creating more
threads can degrade the performance of an algorithm by introducing excessive synchronization overhead).
Default is 100.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>calculate the great circle distance between 2 points with Haversine formula,
which deliberately ignores elevation differences.
</p>
<p>Haversine formula (from R.W. Sinnott, &quot;Virtues of the Haversine&quot;,
Sky and Telescope, vol. 68, no. 2, 1984, p. 159):
</p>
<p>dlon = lon2 - lon1
</p>
<p>dlat = lat2 - lat1
</p>
<p>a = sin^2(dlat/2) + cos(lat1) * cos(lat2) * sin^2(dlon/2)
</p>
<p>c = 2 * arcsin(min(1,sqrt(a)))
</p>
<p>d = R * c
</p>
<p>dist_wlatlng_mi_cpp:
</p>
<p>calculate distance between coordinate1&lt;lat1, lng1&gt; and coordinate2&lt;lat2, lng2&gt; in mile
</p>
<p>dist_wlatlng_km_cpp:
</p>
<p>calculate distance between coordinate1&lt;lat1, lng1&gt; and coordinate2&lt;lat2, lng2&gt; in kilometer
</p>
<p>distSgl_wlatlng_cpp:
</p>
<p>calculate distance between coordinate1&lt;lat1, lng1&gt; and coordinate2&lt;lat2, lng2&gt; in
mile (measure = &quot;mi&quot;) or kilometer (measure = &quot;km&quot;), default is mile.
</p>
<p>implement as serial computing over vector of lat1, lng1, lat2, lng2
</p>
<p>distRpl_wlatlng_cpp:
</p>
<p>calculate distance between coordinate1&lt;lat1, lng1&gt; and coordinate2&lt;lat2, lng2&gt; in
mile (measure = &quot;mi&quot;) or kilometer (measure = &quot;km&quot;), default is mile.
</p>
<p>implement as parallel computing over vector of lat1, lng1, lat2, lng2 via RcppParallel
</p>

<hr>
<h2 id='skm_gdp_cpp'>skm_gdp_cpp</h2><span id='topic+skm_gdp_cpp'></span>

<h3>Description</h3>

<p>solve selective kmeans via a greedy propagation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>skm_gdp_cpp(x, k = 0L)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="skm_gdp_cpp_+3A_x">x</code></td>
<td>
<p>an m x n matrix of s - t - dist</p>
</td></tr>
<tr><td><code id="skm_gdp_cpp_+3A_k">k</code></td>
<td>
<p>number of index to be selected from x row index start from 0.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>skm_gdp_cpp init with an input m x n matrix x and want to select an index set s
of size k from x row index started from 0 such that
</p>
<p>minimize sum(min(x.subview(i in s, all j), min over all i), sum over all j)
</p>
<p>skm_gdp_cpp solve the problem with greedy propagation via selecting the current
best addon index from the index set left, addon index is defined as such index
when addon to the selected one can bring the most improvement.
</p>
<p>since skm_gbp_cpp would select index one by one, and no return, e.g., if select
index A for k = 1, then selection on k = 2 would build on k = 1, so index A is
always present in the solution, so all index can be ranked w.r.t when it would
be considered as the best addon.
as a result skm_gbp_cpp a parameter k is not always required, so default k = 0
will resturn a vector of size m, and user can select to top k as solution for k.
</p>


<h3>Value</h3>

<p>s
a ranked index 0 - m - 1 where the top k would
minimize sum(min(x.subview(i in s(0..k-1), all j), min over all i), sum over all j)
</p>

<hr>
<h2 id='skm_minmax_cpp'>skm_minmax_cpp</h2><span id='topic+skm_minmax_cpp'></span>

<h3>Description</h3>

<p>skm via min-max on in cpp - subroutine of skm_sgl_cpp calls
</p>


<h3>Usage</h3>

<pre><code class='language-R'>skm_minmax_cpp(x, s_must)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="skm_minmax_cpp_+3A_x">x</code></td>
<td>
<p>an m x n matrix often m &gt; n</p>
</td></tr>
<tr><td><code id="skm_minmax_cpp_+3A_s_must">s_must</code></td>
<td>
<p>matrix x row index start from 0 that must be selected with priority</p>
</td></tr>
</table>


<h3>Details</h3>

<p>skm_minmax_cpp init an input m x n matrix x, and a priority vector s_must
would select n indicies from m such that:
</p>
<p>minimize sum(min(x(i, j) where i &lt;1..n&gt; and j &lt;1..n&gt; each use &lt;1..n&gt; once))
</p>
<p>so in case m &lt;= n it simply select all m - should always be apply on matrix
with m &gt; n - it is designed as a expectation step in skm_cpp on updating s.
</p>
<p>it select i in &lt;1..m&gt; such that i has the colwise_min_idx on column j where
j has max difference of (colwise_max_val - colwise_min_val), it then remove
row i col j from matrix and repeat.
</p>
<p>s_must presents the indices with priority so that the selection must select
first indicies within s_must and then select other indicies outside s_must.
</p>
<p>an example skm_minmax_cpp is superior in bound worst case compare to greedy:
x = [1 100; 4 200; 2 400; 9 900]: greedy 1 then 200, min-max 100 then 2, and
greedy give [1 100; 4 200] with 201 and minmax give [1 100; 2 400] with 102.
</p>

<hr>
<h2 id='skm_mlp_cpp'>skm_mlp_cpp</h2><span id='topic+skm_mlp_cpp'></span>

<h3>Description</h3>

<p>solve skm with multiple runs in serial and return all w. optim
</p>


<h3>Usage</h3>

<pre><code class='language-R'>skm_mlp_cpp(x, k, s_must, max_it, max_at)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="skm_mlp_cpp_+3A_x">x</code></td>
<td>
<p>an m x n matrix often m &lt; n, as a convention index rows of x with s, and
cols of x with t so x(i, j) can be expressed as (s_i, t_j) equally.</p>
</td></tr>
<tr><td><code id="skm_mlp_cpp_+3A_k">k</code></td>
<td>
<p>number of index to be selected from x row index start from 0.</p>
</td></tr>
<tr><td><code id="skm_mlp_cpp_+3A_s_must">s_must</code></td>
<td>
<p>an index vector set should be selected before selecting other index.</p>
</td></tr>
<tr><td><code id="skm_mlp_cpp_+3A_max_it">max_it</code></td>
<td>
<p>max number of iterations can run for optimizing result.
max number of iterations within a single initial run on optimal path.</p>
</td></tr>
<tr><td><code id="skm_mlp_cpp_+3A_max_at">max_at</code></td>
<td>
<p>max number of attempts or repeats on running for optimial results,
max number of random initialization for finding optimial results.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>refer skm_sgl_cpp
</p>


<h3>Value</h3>

<p>skmSolution
skmSolution present in r list
</p>


<h3>See Also</h3>

<p>Other skm: <code><a href="#topic+skm_mls_cpp">skm_mls_cpp</a></code>,
<code><a href="#topic+skm_rgi_cpp">skm_rgi_cpp</a></code>, <code><a href="#topic+skm_rgs_cpp">skm_rgs_cpp</a></code>,
<code><a href="#topic+skm_sgl_cpp">skm_sgl_cpp</a></code>
</p>

<hr>
<h2 id='skm_mls'>skm_mls</h2><span id='topic+skm_mls'></span>

<h3>Description</h3>

<p>a selective k-means problem solver - wrapper over skm_mls_cpp
</p>


<h3>Usage</h3>

<pre><code class='language-R'>skm_mls(x, k = 1L, s_colname = "s", t_colname = "t", d_colname = "d",
  w_colname = NULL, s_ggrp = integer(0L), s_must = integer(0L),
  max_it = 100L, max_at = 100L, auto_create_ggrp = TRUE,
  extra_immaculatism = TRUE, extra_at = 10L)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="skm_mls_+3A_x">x</code></td>
<td>
<p>data.table with s - t - d(s, t): s&lt;source&gt; - t&lt;target&gt; - d&lt;distance&gt;
where s&lt;source&gt; and t&lt;target&gt; must characters and d&lt;distance&gt; must numeric.
aware d&lt;distance&gt; is not necessary as an euclidean or any distance and even
necessary as symmetric - d(s, t) can be unequal to d(t, s) - view d as such
a measure of the cost of assigning one to the other!</p>
</td></tr>
<tr><td><code id="skm_mls_+3A_k">k</code></td>
<td>
<p>number of centers</p>
</td></tr>
<tr><td><code id="skm_mls_+3A_s_colname">s_colname</code></td>
<td>
<p>s&lt;source&gt;</p>
</td></tr>
<tr><td><code id="skm_mls_+3A_t_colname">t_colname</code></td>
<td>
<p>t&lt;target&gt;</p>
</td></tr>
<tr><td><code id="skm_mls_+3A_d_colname">d_colname</code></td>
<td>
<p>d&lt;distance&gt; - view d as cost of assigning t into s.
also modify the input data or build in the algorithm can solve problem with
a different fixed cost on using each s as source - i prefer to moddify data
so that the algorithm is clean and clear - i will show a how to in vignette</p>
</td></tr>
<tr><td><code id="skm_mls_+3A_w_colname">w_colname</code></td>
<td>
<p>w&lt;weighting&gt; - optional: when not null will optimize toward
objective to minimize d = d * w such as weighted cost of assigning t into s</p>
</td></tr>
<tr><td><code id="skm_mls_+3A_s_ggrp">s_ggrp</code></td>
<td>
<p>s_init will be stratified sampling from s w.r.t s_ggrp.</p>
</td></tr>
<tr><td><code id="skm_mls_+3A_s_must">s_must</code></td>
<td>
<p>length &lt;= k-1 s must in result: conditional optimizing.</p>
</td></tr>
<tr><td><code id="skm_mls_+3A_max_it">max_it</code></td>
<td>
<p>max number of iterations can run for optimizing result.</p>
</td></tr>
<tr><td><code id="skm_mls_+3A_max_at">max_at</code></td>
<td>
<p>max number of attempts/repeats on running for optimial.</p>
</td></tr>
<tr><td><code id="skm_mls_+3A_auto_create_ggrp">auto_create_ggrp</code></td>
<td>
<p>boolean indicator of whether auto creating the group
structure using the first letter of s when s_ggrp is integer(0).</p>
</td></tr>
<tr><td><code id="skm_mls_+3A_extra_immaculatism">extra_immaculatism</code></td>
<td>
<p>boolean indicator of whether making extra runs for
improving result consistency when multiple successive k is specified, e.g.,
k = c(9L, 10L).</p>
</td></tr>
<tr><td><code id="skm_mls_+3A_extra_at">extra_at</code></td>
<td>
<p>an integer specifying the number of extra runs when argument
extra_immaculatism is TRUE.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>a selective k-means problem is defined as finding a subset of k rows from
a m x n matrix such that the sum of each column minimial is minimized.
</p>
<p>skm_mls would take data.table (data.frame) as inputs, rather than a matrix,
assume that a data.table of s - t - d(s, t) for all combination of s and t,
choose k of s that minimizes sum(min(d(s, t) over selected k of s) over t).
</p>


<h3>Value</h3>

<p>data.table
</p>
<p>o - objective - based on d_colname
</p>
<p>w - weighting - based on w_colname
</p>
<p>k - k&lt;k-list&gt; - based on k - input
</p>
<p>s - s&lt;source&gt; - based on s_colname
</p>
<p>d - weighed averge value of d_colname weighed by w_column when s are selected.
</p>

<hr>
<h2 id='skm_mls_cpp'>skm_mls_cpp</h2><span id='topic+skm_mls_cpp'></span>

<h3>Description</h3>

<p>solve skm with multiple runs in serial and return all w. optim
and s_init stratified sampled w.r.t g
</p>


<h3>Usage</h3>

<pre><code class='language-R'>skm_mls_cpp(x, k, g, s_must, max_it, max_at)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="skm_mls_cpp_+3A_x">x</code></td>
<td>
<p>an m x n matrix often m &lt; n, as a convention index rows of x with s, and
cols of x with t so x(i, j) can be expressed as (s_i, t_j) equally.</p>
</td></tr>
<tr><td><code id="skm_mls_cpp_+3A_k">k</code></td>
<td>
<p>number of index to be selected from x row index start from 0.</p>
</td></tr>
<tr><td><code id="skm_mls_cpp_+3A_g">g</code></td>
<td>
<p>stratify structure, often info on grouping of v so that algorithm should
make random initialization from stratified sample across groups.</p>
</td></tr>
<tr><td><code id="skm_mls_cpp_+3A_s_must">s_must</code></td>
<td>
<p>an index vector set should be selected before selecting other index.</p>
</td></tr>
<tr><td><code id="skm_mls_cpp_+3A_max_it">max_it</code></td>
<td>
<p>max number of iterations can run for optimizing result.
max number of iterations within a single initial run on optimal path.</p>
</td></tr>
<tr><td><code id="skm_mls_cpp_+3A_max_at">max_at</code></td>
<td>
<p>max number of attempts or repeats on running for optimial results,
max number of random initialization for finding optimial results.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>refer skm_sgl_cpp
</p>


<h3>Value</h3>

<p>skmSolution
skmSolution present in r list
</p>


<h3>See Also</h3>

<p>Other skm: <code><a href="#topic+skm_mlp_cpp">skm_mlp_cpp</a></code>,
<code><a href="#topic+skm_rgi_cpp">skm_rgi_cpp</a></code>, <code><a href="#topic+skm_rgs_cpp">skm_rgs_cpp</a></code>,
<code><a href="#topic+skm_sgl_cpp">skm_sgl_cpp</a></code>
</p>

<hr>
<h2 id='skm_rgi_cpp'>skm_rgi_cpp</h2><span id='topic+skm_rgi_cpp'></span>

<h3>Description</h3>

<p>solve skm with single and random size k s_init
</p>


<h3>Usage</h3>

<pre><code class='language-R'>skm_rgi_cpp(x, k, s_must, max_it)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="skm_rgi_cpp_+3A_x">x</code></td>
<td>
<p>an m x n matrix often m &lt; n, as a convention index rows of x with s, and
cols of x with t so x(i, j) can be expressed as (s_i, t_j) equally.</p>
</td></tr>
<tr><td><code id="skm_rgi_cpp_+3A_k">k</code></td>
<td>
<p>number of index to be selected from x row index start from 0.</p>
</td></tr>
<tr><td><code id="skm_rgi_cpp_+3A_s_must">s_must</code></td>
<td>
<p>an index vector set should be selected before selecting other index.</p>
</td></tr>
<tr><td><code id="skm_rgi_cpp_+3A_max_it">max_it</code></td>
<td>
<p>max number of iterations can run for optimizing result.
max number of iterations within a single initial run on optimal path.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>refer skm_sgl_cpp
</p>


<h3>Value</h3>

<p>skmSolution
</p>


<h3>See Also</h3>

<p>Other skm: <code><a href="#topic+skm_mlp_cpp">skm_mlp_cpp</a></code>,
<code><a href="#topic+skm_mls_cpp">skm_mls_cpp</a></code>, <code><a href="#topic+skm_rgs_cpp">skm_rgs_cpp</a></code>,
<code><a href="#topic+skm_sgl_cpp">skm_sgl_cpp</a></code>
</p>

<hr>
<h2 id='skm_rgs_cpp'>skm_rgs_cpp</h2><span id='topic+skm_rgs_cpp'></span>

<h3>Description</h3>

<p>solve skm with single and random size k s_init stratified sampled w.r.t g
</p>


<h3>Usage</h3>

<pre><code class='language-R'>skm_rgs_cpp(x, k, g, s_must, max_it)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="skm_rgs_cpp_+3A_x">x</code></td>
<td>
<p>an m x n matrix often m &lt; n, as a convention index rows of x with s, and
cols of x with t so x(i, j) can be expressed as (s_i, t_j) equally.</p>
</td></tr>
<tr><td><code id="skm_rgs_cpp_+3A_k">k</code></td>
<td>
<p>number of index to be selected from x row index start from 0.</p>
</td></tr>
<tr><td><code id="skm_rgs_cpp_+3A_g">g</code></td>
<td>
<p>stratify structure, often info on grouping of v so that algorithm should
make random initialization from stratified sample across groups.</p>
</td></tr>
<tr><td><code id="skm_rgs_cpp_+3A_s_must">s_must</code></td>
<td>
<p>an index vector set should be selected before selecting other index.</p>
</td></tr>
<tr><td><code id="skm_rgs_cpp_+3A_max_it">max_it</code></td>
<td>
<p>max number of iterations can run for optimizing result.
max number of iterations within a single initial run on optimal path.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>refer skm_sgl_cpp
</p>


<h3>Value</h3>

<p>skmSolution
</p>


<h3>See Also</h3>

<p>Other skm: <code><a href="#topic+skm_mlp_cpp">skm_mlp_cpp</a></code>,
<code><a href="#topic+skm_mls_cpp">skm_mls_cpp</a></code>, <code><a href="#topic+skm_rgi_cpp">skm_rgi_cpp</a></code>,
<code><a href="#topic+skm_sgl_cpp">skm_sgl_cpp</a></code>
</p>

<hr>
<h2 id='skm_sgl_cpp'>skm_sgl_cpp</h2><span id='topic+skm_sgl_cpp'></span>

<h3>Description</h3>

<p>solve skm with single and a fixed given s_init
</p>


<h3>Usage</h3>

<pre><code class='language-R'>skm_sgl_cpp(x, s_init, s_must, max_it)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="skm_sgl_cpp_+3A_x">x</code></td>
<td>
<p>an m x n matrix often m &lt; n, as a convention index rows of x with s, and
cols of x with t so x(i, j) can be expressed as (s_i, t_j) equally.</p>
</td></tr>
<tr><td><code id="skm_sgl_cpp_+3A_s_init">s_init</code></td>
<td>
<p>an init vector of k index to start the search of optimal index set of k,
length of s_init also defined the number of index want to be select.</p>
</td></tr>
<tr><td><code id="skm_sgl_cpp_+3A_s_must">s_must</code></td>
<td>
<p>an index vector set should be selected before selecting other index.</p>
</td></tr>
<tr><td><code id="skm_sgl_cpp_+3A_max_it">max_it</code></td>
<td>
<p>max number of iterations can run for optimizing result.
max number of iterations within a single initial run on optimal path.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>a numeric m x n matrix x often m &lt;&lt; n and want to select a subset of k from
m such that it minimize the sum(min(x(i, j) - minimum w.r.t each j over all
i within selected index set), over all i)
</p>
<p>if m == n and x(i, j) as euclidean distance then it is equivalent to kmeans
</p>
<p>skm can select a combined set for deploying resource, for example, where to
build 5 warehouses on united states, which often different than build these
warehouses via select the current best one by one.
</p>


<h3>Value</h3>

<p>skmSolution
</p>


<h3>See Also</h3>

<p>Other skm: <code><a href="#topic+skm_mlp_cpp">skm_mlp_cpp</a></code>,
<code><a href="#topic+skm_mls_cpp">skm_mls_cpp</a></code>, <code><a href="#topic+skm_rgi_cpp">skm_rgi_cpp</a></code>,
<code><a href="#topic+skm_rgs_cpp">skm_rgs_cpp</a></code>
</p>

<hr>
<h2 id='skmRpl_mlp_cpp'>skmRpl_mlp_cpp</h2><span id='topic+skmRpl_mlp_cpp'></span>

<h3>Description</h3>

<p>solve skm with multiple runs in parallel
</p>


<h3>Usage</h3>

<pre><code class='language-R'>skmRpl_mlp_cpp(x, k, s_must, max_it, max_at, skmRpl_GS = 100L)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="skmRpl_mlp_cpp_+3A_x">x</code></td>
<td>
<p>an m x n matrix often m &lt; n, as a convention index rows of x with s, and
cols of x with t so x(i, j) can be expressed as (s_i, t_j) equally.</p>
</td></tr>
<tr><td><code id="skmRpl_mlp_cpp_+3A_k">k</code></td>
<td>
<p>number of index to be selected from x row index start from 0.</p>
</td></tr>
<tr><td><code id="skmRpl_mlp_cpp_+3A_s_must">s_must</code></td>
<td>
<p>an index vector set should be selected before selecting other index.</p>
</td></tr>
<tr><td><code id="skmRpl_mlp_cpp_+3A_max_it">max_it</code></td>
<td>
<p>max number of iterations can run for optimizing result.
max number of iterations within a single initial run on optimal path.</p>
</td></tr>
<tr><td><code id="skmRpl_mlp_cpp_+3A_max_at">max_at</code></td>
<td>
<p>max number of attempts or repeats on running for optimial results,
max number of random initialization for finding optimial results.</p>
</td></tr>
<tr><td><code id="skmRpl_mlp_cpp_+3A_skmrpl_gs">skmRpl_GS</code></td>
<td>
<p>skmRpl_GS: RcppParallel grain size when run skmRpl_mlp_cpp</p>
</td></tr>
</table>


<h3>Details</h3>

<p>refer skm_sgl_cpp
</p>


<h3>Value</h3>

<p>skmSolution
skmSolution present in r list
</p>

<hr>
<h2 id='skmSolution'>skmSolution</h2><span id='topic+skmSolution'></span><span id='topic+Rcpp_skmSolution'></span><span id='topic+Rcpp_skmSolution-class'></span>

<h3>Description</h3>

<p>class skmSolution, which often returned via skm solver implemented in cpp
</p>


<h3>Usage</h3>

<pre><code class='language-R'>skmSolution
</code></pre>


<h3>Format</h3>

<p>An object of class <code>C++Class</code> of length 1.</p>


<h3>Details</h3>

<p>an skmSolution instance has two member variable:
</p>
<p>o: objective sum(min(x.subview(i in s, all j), min over all i), sum over all j)
</p>
<p>s: selected index set of row index start from 0
</p>

<hr>
<h2 id='source_zip_list'>source_zip_list</h2><span id='topic+source_zip_list'></span>

<h3>Description</h3>

<p>a list of zip code used in skm package demonstration.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>source_zip_list
</code></pre>


<h3>Format</h3>

<p>a character vector of length 51 includes one 5 digits zip code selected from
each state, where the most central zip code in each state selected.</p>

<hr>
<h2 id='stratified_sampling'>stratified_sampling</h2><span id='topic+stratified_sampling'></span>

<h3>Description</h3>

<p>select k elements from vector v w.r.t stratify structure group g.
TODO - implementing via template so v is flexible as vec or uvec.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>stratified_sampling(v, k, g)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="stratified_sampling_+3A_v">v</code></td>
<td>
<p>&lt;vector&gt;
v: a numeric candidate v from which draw sample.</p>
</td></tr>
<tr><td><code id="stratified_sampling_+3A_k">k</code></td>
<td>
<p>&lt;integer&gt;
k: selection sample size.</p>
</td></tr>
<tr><td><code id="stratified_sampling_+3A_g">g</code></td>
<td>
<p>&lt;vector&gt;
g: stratify structure g - info on grouping of v so that the selected sample is stratified across groups.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>s &lt;vector&gt;
s: a vector select from v length k stratified by g.
</p>


<h3>Note</h3>

<p>v is required as an integer vector for using in skm
</p>

<hr>
<h2 id='zip2012'>zip2012</h2><span id='topic+zip2012'></span>

<h3>Description</h3>

<p>a zip code database with latitude, longitude, population and income.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>zip2012
</code></pre>


<h3>Format</h3>

<p>A data table with 28844 rows and 9 variables:
</p>

<dl>
<dt>zip</dt><dd><p>zip code, 5 digits zip code in U.S.</p>
</dd>
<dt>lat</dt><dd><p>latitude</p>
</dd>
<dt>lng</dt><dd><p>longitude</p>
</dd>
<dt>pop</dt><dd><p>population</p>
</dd>
<dt>ink</dt><dd><p>income</p>
</dd>
<dt>city</dt><dd><p>city</p>
</dd>
<dt>state</dt><dd><p>state</p>
</dd>
<dt>p_pop</dt><dd><p>percentage of population w.r.t total population</p>
</dd>
<dt>p_ink</dt><dd><p>percentage of income w.r.t total income</p>
</dd>
</dl>


<h3>Source</h3>

<p><a href="http://federalgovernmentzipcodes.us/">http://federalgovernmentzipcodes.us/</a>
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
