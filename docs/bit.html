<!DOCTYPE html><html lang="en"><head><title>Help for package bit</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {bit}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#bit-package'><p>bit: Classes and methods for fast memory-efficient boolean selections</p></a></li>
<li><a href='#.BITS'><p>Initializing bit masks</p></a></li>
<li><a href='#as.bit.NULL'><p>Coercing to bit</p></a></li>
<li><a href='#as.bitwhich.NULL'><p>Coercing to bitwhich</p></a></li>
<li><a href='#as.booltype.default'><p>Coerce to booltype (generic)</p></a></li>
<li><a href='#as.character.bit'><p>Coerce bit to character</p></a></li>
<li><a href='#as.character.bitwhich'><p>Coerce bitwhich to character</p></a></li>
<li><a href='#as.ri.ri'><p>Coerce to ri</p></a></li>
<li><a href='#as.which.which'><p>Coercion to (positive) integer positions</p></a></li>
<li><a href='#bbatch'><p>Balanced Batch sizes</p></a></li>
<li><a href='#bit'><p>Create empty bit vector</p></a></li>
<li><a href='#bit_in'><p>bit %in%</p></a></li>
<li><a href='#bit_rangediff'><p>bit range difference</p></a></li>
<li><a href='#bit_setops'><p>bit set operations</p></a></li>
<li><a href='#bit_sort'><p>bit sort</p></a></li>
<li><a href='#bit_sort_unique'><p>bit sort unique</p></a></li>
<li><a href='#bit_unidup'><p>bit unique and duplicated</p></a></li>
<li><a href='#bitsort'><p>Low-level sorting: bit sort</p></a></li>
<li><a href='#bitwhich'><p>Create bitwhich vector (skewed boolean)</p></a></li>
<li><a href='#bitwhich_representation'><p>Diagnose representation of bitwhich</p></a></li>
<li><a href='#booltype'><p>Diagnosing boolean types</p></a></li>
<li><a href='#booltypes'><p>Boolean types</p></a></li>
<li><a href='#c.booltype'><p>Concatenating booltype vectors</p></a></li>
<li><a href='#chunk'><p>Methods for chunked range index</p></a></li>
<li><a href='#chunks'><p>Function for chunked range index</p></a></li>
<li><a href='#clone'><p>Cloning ff and ram objects</p></a></li>
<li><a href='#CoercionToStandard'><p>Coercion from bit, bitwhich, which and ri to logical, integer, double</p></a></li>
<li><a href='#copy_vector'><p>Copy atomic R vector</p></a></li>
<li><a href='#countsort'><p>Low-level sorting: counting sort</p></a></li>
<li><a href='#Extract'><p>Extract or replace part of an boolean vector</p></a></li>
<li><a href='#firstNA'><p>Position of first NA</p></a></li>
<li><a href='#get_length'><p>Get C length of a vector</p></a></li>
<li><a href='#getsetattr'><p>Attribute setting by reference</p></a></li>
<li><a href='#in.bitwhich'><p>Check existence of integers in table</p></a></li>
<li><a href='#intrle'><p>Hybrid Index, C-coded utilities</p></a></li>
<li><a href='#is.booltype'><p>Testing for boolean types</p></a></li>
<li><a href='#is.na.bit'><p>Test for NA in bit and bitwhich</p></a></li>
<li><a href='#length.bit'><p>Getting and setting length of bit, bitwhich and ri objects</p></a></li>
<li><a href='#maxindex.default'><p>Get maxindex (length of boolean vector) and poslength (number of 'selected' elements)</p></a></li>
<li><a href='#merge_rev'><p>Fast functions for sorted sets of integer</p></a></li>
<li><a href='#Metadata'><p>Generics related to cache access</p></a></li>
<li><a href='#physical.default'><p>Physical and virtual attributes</p></a></li>
<li><a href='#print.bit'><p>Print method for bit</p></a></li>
<li><a href='#print.bitwhich'><p>Print method for bitwhich</p></a></li>
<li><a href='#quicksort2'><p>Low-level sorting: binary quicksort</p></a></li>
<li><a href='#quicksort3'><p>Low-level sorting: threeway quicksort</p></a></li>
<li><a href='#range_na'><p>Get range and number of NAs</p></a></li>
<li><a href='#range_nanozero'><p>Remove zeros and get range and number of NAs</p></a></li>
<li><a href='#range_sortna'><p>Prepare for sorting and get range, number of NAs and unsortedness</p></a></li>
<li><a href='#rep.booltype'><p>Replicating bit and bitwhich vectors</p></a></li>
<li><a href='#repeat.time'><p>Adaptive timer</p></a></li>
<li><a href='#repfromto'><p>Virtual recycling</p></a></li>
<li><a href='#rev.booltype'><p>Reversing bit and bitwhich vectors</p></a></li>
<li><a href='#reverse_vector'><p>Reverse atomic vector</p></a></li>
<li><a href='#ri'><p>Range index</p></a></li>
<li><a href='#rlepack'><p>Hybrid Index, rle-pack utilities</p></a></li>
<li><a href='#Sorting'><p>Generics for in-RAM sorting and ordering</p></a></li>
<li><a href='#still.identical'><p>Test for C-level identity of two atomic vectors</p></a></li>
<li><a href='#str.bit'><p>Str method for bit</p></a></li>
<li><a href='#str.bitwhich'><p>Str method for bitwhich</p></a></li>
<li><a href='#Summaries'><p>Summaries of boolean vectors</p></a></li>
<li><a href='#symdiff'><p>Symmetric set complement</p></a></li>
<li><a href='#unattr'><p>Attribute removal</p></a></li>
<li><a href='#vecseq'><p>Vectorized Sequences</p></a></li>
<li><a href='#xor.default'><p>Boolean operators and functions</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Title:</td>
<td>Classes and Methods for Fast Memory-Efficient Boolean Selections</td>
</tr>
<tr>
<td>Version:</td>
<td>4.6.0</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.4.0)</td>
</tr>
<tr>
<td>Suggests:</td>
<td>testthat (&ge; 3.0.0), roxygen2, knitr, markdown, rmarkdown,
microbenchmark, bit64 (&ge; 4.0.0), ff (&ge; 4.0.0)</td>
</tr>
<tr>
<td>Description:</td>
<td>Provided are classes for boolean and skewed boolean vectors,
    fast boolean methods, fast unique and non-unique integer sorting,
    fast set operations on sorted and unsorted sets of integers, and
    foundations for ff (range index, compression, chunked processing).</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>LazyLoad:</td>
<td>yes</td>
</tr>
<tr>
<td>ByteCompile:</td>
<td>yes</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/r-lib/bit">https://github.com/r-lib/bit</a></td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr, rmarkdown</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.3.2</td>
</tr>
<tr>
<td>Config/testthat/edition:</td>
<td>3</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2025-03-05 07:18:45 UTC; michael</td>
</tr>
<tr>
<td>Author:</td>
<td>Michael Chirico [aut, cre],
  Jens Oehlschlägel [aut],
  Brian Ripley [ctb]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Michael Chirico &lt;MichaelChirico4@gmail.com&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2025-03-06 10:50:01 UTC</td>
</tr>
</table>
<hr>
<h2 id='bit-package'>bit: Classes and methods for fast memory-efficient boolean selections</h2><span id='topic+bit-package'></span>

<h3>Description</h3>

<p>Provided are classes for boolean and skewed boolean vectors, fast boolean
methods, fast unique and non-unique integer sorting, fast set operations on
sorted and unsorted sets of integers, and foundations for ff (range indices,
compression, chunked processing).
</p>


<h3>Details</h3>

<p>For details view the <code>vignette("bit-usage")</code> and <code>vignette("bit-performance")</code>.
</p>

<hr>
<h2 id='.BITS'>Initializing bit masks</h2><span id='topic+.BITS'></span><span id='topic+bit_init'></span><span id='topic+bit_done'></span>

<h3>Description</h3>

<p>Functions to allocate (and de-allocate) bit masks
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.BITS

bit_init()

bit_done()
</code></pre>


<h3>Format</h3>

<p>An object of class <code>integer</code> of length 1.
</p>


<h3>Details</h3>

<p>The C-code operates with bit masks.  The memory for these is allocated
dynamically.  <code>bit_init</code> is called by <code><a href="base.html#topic+.First.lib">.First.lib()</a></code> and
<code>bit_done</code> is called by <code><a href="base.html#topic+.Last.lib">.Last.lib()</a></code>.  You don't need to
care about these under normal circumstances.
</p>


<h3>Author(s)</h3>

<p>Jens Oehlschlägel
</p>


<h3>See Also</h3>

<p><code><a href="#topic+bit">bit()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
  bit_done()
  bit_init()

</code></pre>

<hr>
<h2 id='as.bit.NULL'>Coercing to bit</h2><span id='topic+as.bit.NULL'></span><span id='topic+as.bit.bit'></span><span id='topic+as.bit.logical'></span><span id='topic+as.bit.integer'></span><span id='topic+as.bit.double'></span><span id='topic+as.bit.bitwhich'></span><span id='topic+as.bit.which'></span><span id='topic+as.bit.ri'></span><span id='topic+as.bit'></span>

<h3>Description</h3>

<p>Coercing to bit vector
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class ''NULL''
as.bit(x, ...)

## S3 method for class 'bit'
as.bit(x, ...)

## S3 method for class 'logical'
as.bit(x, ...)

## S3 method for class 'integer'
as.bit(x, ...)

## S3 method for class 'double'
as.bit(x, ...)

## S3 method for class 'bitwhich'
as.bit(x, ...)

## S3 method for class 'which'
as.bit(x, length = attr(x, "maxindex"), ...)

## S3 method for class 'ri'
as.bit(x, ...)

as.bit(x = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="as.bit.NULL_+3A_x">x</code></td>
<td>
<p>an object of class <code><a href="#topic+bit">bit()</a></code>, <code><a href="base.html#topic+logical">logical()</a></code>,
<code><a href="base.html#topic+integer">integer()</a></code>, <code><a href="#topic+bitwhich">bitwhich()</a></code> or an integer from
<code><a href="#topic+as.which">as.which()</a></code> or a boolean <code><a href="ff.html#topic+vmode">ff</a></code></p>
</td></tr>
<tr><td><code id="as.bit.NULL_+3A_...">...</code></td>
<td>
<p>further arguments</p>
</td></tr>
<tr><td><code id="as.bit.NULL_+3A_length">length</code></td>
<td>
<p>the length of the new bit vector</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Coercing to bit is quite fast because we use a double loop that fixes each
word in a processor register
</p>


<h3>Value</h3>

<p><code>is.bit</code> returns FALSE or TRUE, <code>as.bit</code> returns a vector
of class 'bit'
</p>


<h3>Methods (by class)</h3>


<ul>
<li> <p><code>as.bit(`NULL`)</code>: method to coerce to <code><a href="#topic+bit">bit()</a></code> (zero length) from <code><a href="base.html#topic+NULL">NULL</a></code>
</p>
</li>
<li> <p><code>as.bit(bit)</code>: method to coerce to <code><a href="#topic+bit">bit()</a></code> from <code><a href="#topic+bit">bit()</a></code>
</p>
</li>
<li> <p><code>as.bit(logical)</code>: method to coerce to <code><a href="#topic+bit">bit()</a></code> from <code><a href="base.html#topic+logical">logical()</a></code>
</p>
</li>
<li> <p><code>as.bit(integer)</code>: method to coerce to <code><a href="#topic+bit">bit()</a></code> from
<code><a href="base.html#topic+integer">integer()</a></code> (<code>0L</code> and <code>NA</code> become <code>FALSE</code>,
everthing else becomes <code>TRUE</code>)
</p>
</li>
<li> <p><code>as.bit(double)</code>: method to coerce to <code><a href="#topic+bit">bit()</a></code> from
<code><a href="base.html#topic+double">double()</a></code> (<code>0</code> and <code>NA</code> become <code>FALSE</code>, everthing
else becomes <code>TRUE</code>)
</p>
</li>
<li> <p><code>as.bit(bitwhich)</code>: method to coerce to <code><a href="#topic+bit">bit()</a></code> from <code><a href="#topic+bitwhich">bitwhich()</a></code>
</p>
</li>
<li> <p><code>as.bit(which)</code>: method to coerce to <code><a href="#topic+bit">bit()</a></code> from <code><a href="#topic+as.which">which()</a></code>
</p>
</li>
<li> <p><code>as.bit(ri)</code>: method to coerce to <code><a href="#topic+bit">bit()</a></code> from <code><a href="#topic+ri">ri()</a></code>
</p>
</li></ul>


<h3>Note</h3>

<p>Zero is coerced to FALSE, all other numbers including NA are coerced
to TRUE.  This differs from the NA-to-FALSE coercion in package ff and may
change in the future.
</p>


<h3>Author(s)</h3>

<p>Jens Oehlschlägel
</p>


<h3>See Also</h3>

<p><code><a href="#topic+CoercionToStandard">CoercionToStandard</a></code>, <code><a href="#topic+as.booltype">as.booltype()</a></code>, <code><a href="#topic+as.bit">as.bit()</a></code>,
<code><a href="#topic+as.bitwhich">as.bitwhich()</a></code> , <code><a href="#topic+as.which">as.which()</a></code>, <code><a href="#topic+as.ri">as.ri()</a></code>, <code><a href="ff.html#topic+as.hi">ff::as.hi()</a></code>,  <code><a href="ff.html#topic+as.ff">ff::as.ff()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>as.bit(c(0L, 1L, 2L, -2L, NA))
as.bit(c(0, 1, 2, -2, NA))

as.bit(c(FALSE, NA, TRUE))

</code></pre>

<hr>
<h2 id='as.bitwhich.NULL'>Coercing to bitwhich</h2><span id='topic+as.bitwhich.NULL'></span><span id='topic+as.bitwhich.bitwhich'></span><span id='topic+as.bitwhich.which'></span><span id='topic+as.bitwhich.ri'></span><span id='topic+as.bitwhich.integer'></span><span id='topic+as.bitwhich.double'></span><span id='topic+as.bitwhich.logical'></span><span id='topic+as.bitwhich.bit'></span><span id='topic+as.bitwhich'></span>

<h3>Description</h3>

<p>Functions to coerce to bitwhich
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class ''NULL''
as.bitwhich(x, ...)

## S3 method for class 'bitwhich'
as.bitwhich(x, ...)

## S3 method for class 'which'
as.bitwhich(x, maxindex = attr(x, "maxindex"), ...)

## S3 method for class 'ri'
as.bitwhich(x, ...)

## S3 method for class 'integer'
as.bitwhich(x, poslength = NULL, ...)

## S3 method for class 'double'
as.bitwhich(x, poslength = NULL, ...)

## S3 method for class 'logical'
as.bitwhich(x, poslength = NULL, ...)

## S3 method for class 'bit'
as.bitwhich(x, range = NULL, poslength = NULL, ...)

as.bitwhich(x = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="as.bitwhich.NULL_+3A_x">x</code></td>
<td>
<p>An object of class 'bitwhich', 'integer', 'logical' or 'bit' or an
integer vector as resulting from 'which'</p>
</td></tr>
<tr><td><code id="as.bitwhich.NULL_+3A_...">...</code></td>
<td>
<p>further arguments</p>
</td></tr>
<tr><td><code id="as.bitwhich.NULL_+3A_maxindex">maxindex</code></td>
<td>
<p>the length of the new bitwhich vector</p>
</td></tr>
<tr><td><code id="as.bitwhich.NULL_+3A_poslength">poslength</code></td>
<td>
<p>the number of selected elements</p>
</td></tr>
<tr><td><code id="as.bitwhich.NULL_+3A_range">range</code></td>
<td>
<p>a <code><a href="#topic+ri">ri()</a></code> or an integer vector of length == 2 giving a
range restriction for chunked processing</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a value of class <code><a href="#topic+bitwhich">bitwhich()</a></code>
</p>


<h3>Methods (by class)</h3>


<ul>
<li> <p><code>as.bitwhich(`NULL`)</code>: method to coerce to <code><a href="#topic+bitwhich">bitwhich()</a></code> (zero length) from
<code><a href="base.html#topic+NULL">NULL</a></code>
</p>
</li>
<li> <p><code>as.bitwhich(bitwhich)</code>: method to coerce to <code><a href="#topic+bitwhich">bitwhich()</a></code> from <code><a href="#topic+bitwhich">bitwhich()</a></code>
</p>
</li>
<li> <p><code>as.bitwhich(which)</code>: method to coerce to <code><a href="#topic+bitwhich">bitwhich()</a></code> from <code><a href="#topic+as.which">which()</a></code>
</p>
</li>
<li> <p><code>as.bitwhich(ri)</code>: method to coerce to <code><a href="#topic+bitwhich">bitwhich()</a></code> from <code><a href="#topic+ri">ri()</a></code>
</p>
</li>
<li> <p><code>as.bitwhich(integer)</code>: method to coerce to <code><a href="#topic+bitwhich">bitwhich()</a></code> from
<code><a href="base.html#topic+integer">integer()</a></code> (<code>0</code> and <code>NA</code> become <code>FALSE</code>, everthing
else becomes <code>TRUE</code>)
</p>
</li>
<li> <p><code>as.bitwhich(double)</code>: method to coerce to <code><a href="#topic+bitwhich">bitwhich()</a></code> from
<code><a href="base.html#topic+double">double()</a></code> (<code>0</code> and <code>NA</code> become <code>FALSE</code>, everthing
else becomes <code>TRUE</code>)
</p>
</li>
<li> <p><code>as.bitwhich(logical)</code>: method to coerce to <code><a href="#topic+bitwhich">bitwhich()</a></code> from <code><a href="base.html#topic+logical">logical()</a></code>
</p>
</li>
<li> <p><code>as.bitwhich(bit)</code>: method to coerce to <code><a href="#topic+bitwhich">bitwhich()</a></code> from <code><a href="#topic+bit">bit()</a></code>
</p>
</li></ul>


<h3>Author(s)</h3>

<p>Jens Oehlschlägel
</p>


<h3>See Also</h3>

<p><code><a href="#topic+CoercionToStandard">CoercionToStandard</a></code>, <code><a href="#topic+as.booltype">as.booltype()</a></code>, <code><a href="#topic+as.bit">as.bit()</a></code>,
<code><a href="#topic+as.bitwhich">as.bitwhich()</a></code> , <code><a href="#topic+as.which">as.which()</a></code>, <code><a href="#topic+as.ri">as.ri()</a></code>, <code><a href="ff.html#topic+as.hi">ff::as.hi()</a></code>,  <code><a href="ff.html#topic+as.ff">ff::as.ff()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>as.bitwhich(c(0L, 1L, 2L, -2L, NA))
as.bitwhich(c(0, 1, 2, -2, NA))

 as.bitwhich(c(NA, NA, NA))
 as.bitwhich(c(FALSE, FALSE, FALSE))
 as.bitwhich(c(FALSE, FALSE, TRUE))
 as.bitwhich(c(FALSE, TRUE, TRUE))
 as.bitwhich(c(TRUE, TRUE, TRUE))

</code></pre>

<hr>
<h2 id='as.booltype.default'>Coerce to booltype (generic)</h2><span id='topic+as.booltype.default'></span><span id='topic+as.booltype'></span>

<h3>Description</h3>

<p>Coerce to booltype (generic)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## Default S3 method:
as.booltype(x, booltype = "logical", ...)

as.booltype(x, booltype, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="as.booltype.default_+3A_x">x</code></td>
<td>
<p>object to coerce</p>
</td></tr>
<tr><td><code id="as.booltype.default_+3A_booltype">booltype</code></td>
<td>
<p>target <code><a href="#topic+booltype">booltype()</a></code> given as integer or as character</p>
</td></tr>
<tr><td><code id="as.booltype.default_+3A_...">...</code></td>
<td>
<p>further arguments</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>x</code> coerced to <code>booltype</code>
</p>


<h3>Methods (by class)</h3>


<ul>
<li> <p><code>as.booltype(default)</code>: default method for as.booltype
</p>
</li></ul>


<h3>See Also</h3>

<p><code><a href="#topic+CoercionToStandard">CoercionToStandard</a></code>, <code><a href="#topic+booltypes">booltypes()</a></code>, <code><a href="#topic+booltype">booltype()</a></code>,
<code><a href="#topic+is.booltype">is.booltype()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>as.booltype(0:1)
as.booltype(0:1, "logical")
as.booltype(0:1, "bit")
as.booltype(0:1, "bitwhich")
as.booltype(0:1, "which", maxindex=2)
as.booltype(0:1, "ri")
</code></pre>

<hr>
<h2 id='as.character.bit'>Coerce bit to character</h2><span id='topic+as.character.bit'></span>

<h3>Description</h3>

<p>Coerce bit to character
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'bit'
as.character(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="as.character.bit_+3A_x">x</code></td>
<td>
<p>a <code><a href="#topic+bit">bit()</a></code> vector</p>
</td></tr>
<tr><td><code id="as.character.bit_+3A_...">...</code></td>
<td>
<p>ignored</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a character vector of zeroes and ones
</p>


<h3>Examples</h3>

<pre><code class='language-R'>as.character(bit(12))
</code></pre>

<hr>
<h2 id='as.character.bitwhich'>Coerce bitwhich to character</h2><span id='topic+as.character.bitwhich'></span>

<h3>Description</h3>

<p>Coerce bitwhich to character
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'bitwhich'
as.character(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="as.character.bitwhich_+3A_x">x</code></td>
<td>
<p>a <code><a href="#topic+bitwhich">bitwhich()</a></code> vector</p>
</td></tr>
<tr><td><code id="as.character.bitwhich_+3A_...">...</code></td>
<td>
<p>ignored</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a character vector of zeroes and ones
</p>


<h3>Examples</h3>

<pre><code class='language-R'>as.character(bitwhich(12))
</code></pre>

<hr>
<h2 id='as.ri.ri'>Coerce to ri</h2><span id='topic+as.ri.ri'></span><span id='topic+as.ri.default'></span><span id='topic+as.ri'></span>

<h3>Description</h3>

<p>Coerce to ri
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'ri'
as.ri(x, ...)

## Default S3 method:
as.ri(x, ...)

as.ri(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="as.ri.ri_+3A_x">x</code></td>
<td>
<p>object to coerce</p>
</td></tr>
<tr><td><code id="as.ri.ri_+3A_...">...</code></td>
<td>
<p>further arguments</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an <code><a href="#topic+ri">ri()</a></code> object
</p>


<h3>Methods (by class)</h3>


<ul>
<li> <p><code>as.ri(ri)</code>: method to coerce <code><a href="#topic+ri">ri()</a></code> to <code><a href="#topic+ri">ri()</a></code>
</p>
</li>
<li> <p><code>as.ri(default)</code>: default method to coerce to <code><a href="#topic+ri">ri()</a></code>
</p>
</li></ul>


<h3>Author(s)</h3>

<p>Jens Oehlschlägel
</p>


<h3>See Also</h3>

<p><code><a href="#topic+CoercionToStandard">CoercionToStandard</a></code>, <code><a href="#topic+as.booltype">as.booltype()</a></code>, <code><a href="#topic+as.bit">as.bit()</a></code>,
<code><a href="#topic+as.bitwhich">as.bitwhich()</a></code> , <code><a href="#topic+as.which">as.which()</a></code>, <code><a href="#topic+as.ri">as.ri()</a></code>, <code><a href="ff.html#topic+as.hi">ff::as.hi()</a></code>,  <code><a href="ff.html#topic+as.ff">ff::as.ff()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>as.ri(c(FALSE, TRUE, FALSE, TRUE))
</code></pre>

<hr>
<h2 id='as.which.which'>Coercion to (positive) integer positions</h2><span id='topic+as.which.which'></span><span id='topic+as.which.NULL'></span><span id='topic+as.which.numeric'></span><span id='topic+as.which.integer'></span><span id='topic+as.which.logical'></span><span id='topic+as.which.ri'></span><span id='topic+as.which.bit'></span><span id='topic+as.which.bitwhich'></span><span id='topic+as.which'></span>

<h3>Description</h3>

<p>Coercing to something like the result of which <code><a href="base.html#topic+which">which()</a></code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'which'
as.which(x, maxindex = NA_integer_, ...)

## S3 method for class ''NULL''
as.which(x, ...)

## S3 method for class 'numeric'
as.which(x, maxindex = NA_integer_, ...)

## S3 method for class 'integer'
as.which(x, maxindex = NA_integer_, is.unsorted = TRUE, has.dup = TRUE, ...)

## S3 method for class 'logical'
as.which(x, ...)

## S3 method for class 'ri'
as.which(x, ...)

## S3 method for class 'bit'
as.which(x, range = NULL, ...)

## S3 method for class 'bitwhich'
as.which(x, ...)

as.which(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="as.which.which_+3A_x">x</code></td>
<td>
<p>an object of classes <code><a href="#topic+bit">bit()</a></code>, <code><a href="#topic+bitwhich">bitwhich()</a></code>,
<code><a href="#topic+ri">ri()</a></code> or something on which <code><a href="base.html#topic+which">which()</a></code> works</p>
</td></tr>
<tr><td><code id="as.which.which_+3A_maxindex">maxindex</code></td>
<td>
<p>the length of the boolean vector which is represented</p>
</td></tr>
<tr><td><code id="as.which.which_+3A_...">...</code></td>
<td>
<p>further arguments (passed to <code><a href="base.html#topic+which">which()</a></code> for the
default method, ignored otherwise)</p>
</td></tr>
<tr><td><code id="as.which.which_+3A_is.unsorted">is.unsorted</code></td>
<td>
<p>a logical scalar indicating whether the data may be unsorted</p>
</td></tr>
<tr><td><code id="as.which.which_+3A_has.dup">has.dup</code></td>
<td>
<p>a logical scalar indicating whether the data may have duplicates</p>
</td></tr>
<tr><td><code id="as.which.which_+3A_range">range</code></td>
<td>
<p>a <code><a href="#topic+ri">ri()</a></code> or an integer vector of length == 2 giving a
range restriction for chunked processing</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>as.which.bit</code> returns a vector of subscripts with class 'which'
</p>


<h3>Value</h3>

<p>a vector of class 'logical' or 'integer'
</p>


<h3>Methods (by class)</h3>


<ul>
<li> <p><code>as.which(which)</code>: method to coerce to <code><a href="#topic+as.which">which()</a></code> from
<code><a href="#topic+as.which">which()</a></code>
</p>
</li>
<li> <p><code>as.which(`NULL`)</code>: method to coerce to zero length <code><a href="#topic+as.which">which()</a></code> from
<code><a href="base.html#topic+NULL">NULL</a></code>
</p>
</li>
<li> <p><code>as.which(numeric)</code>: method to coerce to <code><a href="#topic+as.which">which()</a></code> from <code><a href="base.html#topic+numeric">numeric()</a></code>
</p>
</li>
<li> <p><code>as.which(integer)</code>: method to coerce to <code><a href="#topic+as.which">which()</a></code> from <code><a href="base.html#topic+integer">integer()</a></code>
</p>
</li>
<li> <p><code>as.which(logical)</code>: method to coerce to <code><a href="#topic+as.which">which()</a></code> from <code><a href="base.html#topic+logical">logical()</a></code>
</p>
</li>
<li> <p><code>as.which(ri)</code>: method to coerce to <code><a href="#topic+as.which">which()</a></code> from <code><a href="#topic+ri">ri()</a></code>
</p>
</li>
<li> <p><code>as.which(bit)</code>: method to coerce to <code><a href="#topic+as.which">which()</a></code> from <code><a href="#topic+bit">bit()</a></code>
</p>
</li>
<li> <p><code>as.which(bitwhich)</code>: method to coerce to <code><a href="#topic+as.which">which()</a></code> from <code><a href="#topic+bitwhich">bitwhich()</a></code>
</p>
</li></ul>


<h3>Author(s)</h3>

<p>Jens Oehlschlägel
</p>


<h3>See Also</h3>

<p><code><a href="#topic+CoercionToStandard">CoercionToStandard</a></code>, <code><a href="#topic+as.booltype">as.booltype()</a></code>, <code><a href="#topic+as.bit">as.bit()</a></code>,
<code><a href="#topic+as.bitwhich">as.bitwhich()</a></code> , <code><a href="#topic+as.which">as.which()</a></code>, <code><a href="#topic+as.ri">as.ri()</a></code>, <code><a href="ff.html#topic+as.hi">ff::as.hi()</a></code>,  <code><a href="ff.html#topic+as.ff">ff::as.ff()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
  r &lt;- ri(5, 20, 100)
  x &lt;- as.which(r)
  x

  stopifnot(identical(x, as.which(as.logical(r))))
  stopifnot(identical(x, as.which(as.bitwhich(r))))
  stopifnot(identical(x, as.which(as.bit(r))))

</code></pre>

<hr>
<h2 id='bbatch'>Balanced Batch sizes</h2><span id='topic+bbatch'></span>

<h3>Description</h3>

<p><code>bbatch</code> calculates batch sizes in 1..N so that they have rather balanced
sizes than very different sizes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bbatch(N, B)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="bbatch_+3A_n">N</code></td>
<td>
<p>total size in 0..integer_max</p>
</td></tr>
<tr><td><code id="bbatch_+3A_b">B</code></td>
<td>
<p>desired batch size in 1..integer_max</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Tries to have <code>rb == 0</code> or <code>rb</code> as close to <code>b</code> as possible
while guaranteeing that <code>rb &lt; b &amp;&amp; (b - rb) &lt;= min(nb, b)</code>
</p>


<h3>Value</h3>

<p>a list with components:
</p>

<ul>
<li><p> b: the batch size
</p>
</li>
<li><p> nb: the number of batches
</p>
</li>
<li><p> rb: the size of the rest
</p>
</li></ul>



<h3>Author(s)</h3>

<p>Jens Oehlschlägel
</p>


<h3>See Also</h3>

<p><code><a href="#topic+repfromto">repfromto()</a></code>, <code><a href="ff.html#topic+ffapply">ff::ffvecapply()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
  bbatch(100, 24)

</code></pre>

<hr>
<h2 id='bit'>Create empty bit vector</h2><span id='topic+bit'></span>

<h3>Description</h3>

<p>Bit vectors are a boolean type wihout <code>NA</code> that requires by factor 32 less
RAM than <code><a href="base.html#topic+logical">logical()</a></code>.
For details on usage see <code>vignette("bit-usage")</code> and for details on
performance see <code>vignette("bit-performance")</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bit(length = 0L)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="bit_+3A_length">length</code></td>
<td>
<p>length in bits</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>bit</code> returns a vector of integer sufficiently long to store 'length' bits
</p>


<h3>See Also</h3>

<p><code><a href="#topic+booltype">booltype()</a></code>, <code><a href="#topic+bitwhich">bitwhich()</a></code>, <code><a href="base.html#topic+logical">logical()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>bit(12)
!bit(12)
str(bit(128))
</code></pre>

<hr>
<h2 id='bit_in'>bit %in%</h2><span id='topic+bit_in'></span>

<h3>Description</h3>

<p>fast <code><a href="base.html#topic+match">%in%</a></code> for integers
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bit_in(x, table, retFUN = as.bit)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="bit_in_+3A_x">x</code></td>
<td>
<p>an integer vector of values to be looked-up</p>
</td></tr>
<tr><td><code id="bit_in_+3A_table">table</code></td>
<td>
<p>an integer vector used as lookup-table</p>
</td></tr>
<tr><td><code id="bit_in_+3A_retfun">retFUN</code></td>
<td>
<p>a function that coerces <code><a href="#topic+bit">bit()</a></code> and <code><a href="base.html#topic+logical">logical()</a></code> vectors</p>
</td></tr>
</table>


<h3>Details</h3>

<p>determines the range of the integers and checks if the density justifies use
of a bit vector; if yes, maps <code>x</code> or <code>table</code> &ndash; whatever is smaller
&ndash; into a bit vector and searches the other of <code>table</code> or <code>x</code> in
the it vector; if no, falls back to <code><a href="base.html#topic+match">%in%</a></code>
</p>


<h3>Value</h3>

<p>a boolean vector coerced to <code>retFUN</code>
</p>


<h3>See Also</h3>

<p><code><a href="base.html#topic+match">%in%</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>bit_in(1:2, 2:3)
bit_in(1:2, 2:3, retFUN=as.logical)
</code></pre>

<hr>
<h2 id='bit_rangediff'>bit range difference</h2><span id='topic+bit_rangediff'></span>

<h3>Description</h3>

<p>Fast version of <code>setdiff(rx[1]:rx[2], y)</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bit_rangediff(rx, y, revx = FALSE, revy = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="bit_rangediff_+3A_rx">rx</code></td>
<td>
<p>range of integers given as <code><a href="#topic+ri">ri()</a></code> or as a two-element <code><a href="base.html#topic+integer">integer()</a></code></p>
</td></tr>
<tr><td><code id="bit_rangediff_+3A_y">y</code></td>
<td>
<p>an integer vector of elements to exclude</p>
</td></tr>
<tr><td><code id="bit_rangediff_+3A_revx">revx</code></td>
<td>
<p><code>FALSE</code> as is, <code>TRUE</code> to reverse the direction and sign of <code>rx</code></p>
</td></tr>
<tr><td><code id="bit_rangediff_+3A_revy">revy</code></td>
<td>
<p><code>FALSE</code> as is, <code>TRUE</code> to reverse the direction and sign of <code>y</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>determines the range of the integers <code>y</code> and checks if the density justifies use
of a bit vector; if yes, uses a bit vector for the set operation; if no,
falls back to a quicksort and <code><a href="#topic+merge_rangediff">merge_rangediff()</a></code>
</p>


<h3>Value</h3>

<p>an integer vector
</p>


<h3>See Also</h3>

<p><code><a href="#topic+bit_setdiff">bit_setdiff()</a></code>, <code><a href="#topic+merge_rangediff">merge_rangediff()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>bit_rangediff(c(1L, 6L), c(3L, 4L))
bit_rangediff(c(6L, 1L), c(3L, 4L))
bit_rangediff(c(6L, 1L), c(3L, 4L), revx=TRUE)
bit_rangediff(c(6L, 1L), c(3L, 4L), revx=TRUE, revy=TRUE)
</code></pre>

<hr>
<h2 id='bit_setops'>bit set operations</h2><span id='topic+bit_setops'></span><span id='topic+bit_union'></span><span id='topic+bit_intersect'></span><span id='topic+bit_setdiff'></span><span id='topic+bit_symdiff'></span><span id='topic+bit_setequal'></span>

<h3>Description</h3>

<p>Fast versions of <code><a href="base.html#topic+union">union()</a></code>, <code><a href="base.html#topic+intersect">intersect()</a></code>,
<code><a href="base.html#topic+setdiff">setdiff()</a></code>, symmetric difference and <code><a href="base.html#topic+setequal">setequal()</a></code>
for integers.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bit_union(x, y)

bit_intersect(x, y)

bit_setdiff(x, y)

bit_symdiff(x, y)

bit_setequal(x, y)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="bit_setops_+3A_x">x</code></td>
<td>
<p>an integer vector</p>
</td></tr>
<tr><td><code id="bit_setops_+3A_y">y</code></td>
<td>
<p>an integer vector</p>
</td></tr>
</table>


<h3>Details</h3>

<p>determines the range of the integers and checks if the density justifies use
of a bit vector; if yes, uses a bit vector for finding duplicates; if no,
falls back to <code><a href="base.html#topic+union">union()</a></code>, <code><a href="base.html#topic+intersect">intersect()</a></code>,
<code><a href="base.html#topic+setdiff">setdiff()</a></code>, <code>union(setdiff(x, y), setdiff(y, x))</code> and <code><a href="base.html#topic+setequal">setequal()</a></code>
</p>


<h3>Value</h3>

<p>an integer vector
</p>


<h3>Functions</h3>


<ul>
<li> <p><code>bit_union()</code>: union
</p>
</li>
<li> <p><code>bit_intersect()</code>: intersection
</p>
</li>
<li> <p><code>bit_setdiff()</code>: asymmetric difference
</p>
</li>
<li> <p><code>bit_symdiff()</code>: symmetricx difference
</p>
</li>
<li> <p><code>bit_setequal()</code>: equality
</p>
</li></ul>


<h3>See Also</h3>

<p><code><a href="#topic+bit_in">bit_in()</a></code>, <code><a href="#topic+bit_rangediff">bit_rangediff()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>bit_union(1:2, 2:3)
bit_intersect(1:2, 2:3)
bit_setdiff(1:2, 2:3)
bit_symdiff(1:2, 2:3)
bit_setequal(1:2, 2:3)
bit_setequal(1:2, 2:1)
</code></pre>

<hr>
<h2 id='bit_sort'>bit sort</h2><span id='topic+bit_sort'></span>

<h3>Description</h3>

<p>fast sorting of integers
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bit_sort(x, decreasing = FALSE, na.last = NA, has.dup = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="bit_sort_+3A_x">x</code></td>
<td>
<p>an integer vector</p>
</td></tr>
<tr><td><code id="bit_sort_+3A_decreasing">decreasing</code></td>
<td>
<p>(currently only <code>FALSE</code> is supported)</p>
</td></tr>
<tr><td><code id="bit_sort_+3A_na.last">na.last</code></td>
<td>
<p><code>NA</code> removes NAs, <code>FALSE</code> puts NAs at the beginning,
<code>TRUE</code> puts NAs at the end</p>
</td></tr>
<tr><td><code id="bit_sort_+3A_has.dup">has.dup</code></td>
<td>
<p>TRUE (the default) assumes that <code>x</code> might have
duplicates, set to <code>FALSE</code> if duplicates are impossible</p>
</td></tr>
</table>


<h3>Details</h3>

<p>determines the range of the integers and checks if the density justifies use
of a bit vector; if yes, sorts the first occurences of each integer in the
range using a bit vector, sorts the rest and merges; if no, falls back to quicksort.
</p>


<h3>Value</h3>

<p>a sorted vector
</p>


<h3>See Also</h3>

<p><code><a href="base.html#topic+sort">sort()</a></code>, <code><a href="#topic+ramsort">ramsort()</a></code>,
<code><a href="#topic+bit_sort_unique">bit_sort_unique()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>bit_sort(c(2L, 1L, NA, NA, 1L, 2L))
bit_sort(c(2L, 1L, NA, NA, 1L, 2L), na.last=FALSE)
bit_sort(c(2L, 1L, NA, NA, 1L, 2L), na.last=TRUE)

## Not run: 
x &lt;- sample(1e7, replace=TRUE)
system.time(bit_sort(x))
system.time(sort(x))

## End(Not run)
</code></pre>

<hr>
<h2 id='bit_sort_unique'>bit sort unique</h2><span id='topic+bit_sort_unique'></span>

<h3>Description</h3>

<p>fast combination of <code><a href="base.html#topic+sort">sort()</a></code> and <code><a href="base.html#topic+unique">unique()</a></code> for integers
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bit_sort_unique(
  x,
  decreasing = FALSE,
  na.last = NA,
  has.dup = TRUE,
  range_na = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="bit_sort_unique_+3A_x">x</code></td>
<td>
<p>an integer vector</p>
</td></tr>
<tr><td><code id="bit_sort_unique_+3A_decreasing">decreasing</code></td>
<td>
<p><code>FALSE</code> (ascending) or <code>TRUE</code> (descending)</p>
</td></tr>
<tr><td><code id="bit_sort_unique_+3A_na.last">na.last</code></td>
<td>
<p><code>NA</code> removes NAs, <code>FALSE</code> puts NAs at the beginning, <code>TRUE</code> puts NAs at
the end</p>
</td></tr>
<tr><td><code id="bit_sort_unique_+3A_has.dup">has.dup</code></td>
<td>
<p>TRUE (the default) assumes that <code>x</code> might have duplicates, set to
<code>FALSE</code> if duplicates are impossible</p>
</td></tr>
<tr><td><code id="bit_sort_unique_+3A_range_na">range_na</code></td>
<td>
<p><code>NULL</code> calls <code><a href="#topic+range_na">range_na()</a></code>, optionally the result of <code><a href="#topic+range_na">range_na()</a></code> can be
given here to avoid calling it again</p>
</td></tr>
</table>


<h3>Details</h3>

<p>determines the range of the integers and checks if the density justifies use
of a bit vector; if yes, creates the result using a bit vector; if no, falls back to
<code>sort(unique())</code>
</p>


<h3>Value</h3>

<p>a sorted unique integer vector
</p>


<h3>See Also</h3>

<p><code><a href="base.html#topic+sort">sort()</a></code>, <code><a href="base.html#topic+unique">unique()</a></code>,
<code><a href="#topic+bit_sort">bit_sort()</a></code>, <code><a href="#topic+bit_unique">bit_unique()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>bit_sort_unique(c(2L, 1L, NA, NA, 1L, 2L))
bit_sort_unique(c(2L, 1L, NA, NA, 1L, 2L), na.last=FALSE)
bit_sort_unique(c(2L, 1L, NA, NA, 1L, 2L), na.last=TRUE)
bit_sort_unique(c(2L, 1L, NA, NA, 1L, 2L), decreasing = TRUE)
bit_sort_unique(c(2L, 1L, NA, NA, 1L, 2L), decreasing = TRUE, na.last=FALSE)
bit_sort_unique(c(2L, 1L, NA, NA, 1L, 2L), decreasing = TRUE, na.last=TRUE)

## Not run: 
x &lt;- sample(1e7, replace=TRUE)
system.time(bit_sort_unique(x))
system.time(sort(unique(x)))
x &lt;- sample(1e7)
system.time(bit_sort_unique(x))
system.time(sort(x))

## End(Not run)
</code></pre>

<hr>
<h2 id='bit_unidup'>bit unique and duplicated</h2><span id='topic+bit_unidup'></span><span id='topic+bit_unique'></span><span id='topic+bit_duplicated'></span><span id='topic+bit_anyDuplicated'></span><span id='topic+bit_sumDuplicated'></span>

<h3>Description</h3>

<p>Fast versions of <code><a href="base.html#topic+unique">unique()</a></code>, <code><a href="base.html#topic+duplicated">duplicated()</a></code> ,
<code><a href="base.html#topic+anyDuplicated">anyDuplicated()</a></code> and <code>sum(duplicated(x))</code> for integers.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bit_unique(x, na.rm = NA, range_na = NULL)

bit_duplicated(x, na.rm = NA, range_na = NULL, retFUN = as.bit)

bit_anyDuplicated(x, na.rm = NA, range_na = NULL)

bit_sumDuplicated(x, na.rm = NA, range_na = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="bit_unidup_+3A_x">x</code></td>
<td>
<p>an integer vector</p>
</td></tr>
<tr><td><code id="bit_unidup_+3A_na.rm">na.rm</code></td>
<td>
<p><code>NA</code> treats NAs like other integers, <code>TRUE</code> treats
<em>all</em> NAs as duplicates, <code>FALSE</code> treats <em>no</em> NAs as
duplicates</p>
</td></tr>
<tr><td><code id="bit_unidup_+3A_range_na">range_na</code></td>
<td>
<p><code>NULL</code> calls <code><a href="#topic+range_na">range_na()</a></code>, optionally the result of <code><a href="#topic+range_na">range_na()</a></code> can be
given here to avoid calling it again</p>
</td></tr>
<tr><td><code id="bit_unidup_+3A_retfun">retFUN</code></td>
<td>
<p>a function that coerces <code><a href="#topic+bit">bit()</a></code> and <code><a href="base.html#topic+logical">logical()</a></code> vectors</p>
</td></tr>
</table>


<h3>Details</h3>

<p>determines the range of the integers and checks if the density justifies use
of a bit vector; if yes, uses a bit vector for finding duplicates; if no,
falls back to <code><a href="base.html#topic+unique">unique()</a></code>, <code><a href="base.html#topic+duplicated">duplicated()</a></code>, <code><a href="base.html#topic+anyDuplicated">anyDuplicated()</a></code> and <code>sum(duplicated(x))</code>
</p>


<h3>Value</h3>


<ul>
<li> <p><code>bit_unique</code> returns a vector of unique integers,
</p>
</li>
<li> <p><code>bit_duplicated</code> returns a boolean vector coerced to <code>retFUN</code>,
</p>
</li>
<li> <p><code>bit_anyDuplicated</code> returns the position of the first duplicate (or zero if no
duplicates)
</p>
</li>
<li> <p><code>bit_sumDuplicated</code> returns the number of duplicated values (as.integer)
</p>
</li></ul>



<h3>Functions</h3>


<ul>
<li> <p><code>bit_unique()</code>: extracts unique elements
</p>
</li>
<li> <p><code>bit_duplicated()</code>: determines duplicate elements
</p>
</li>
<li> <p><code>bit_anyDuplicated()</code>: checks for existence of duplicate elements
</p>
</li>
<li> <p><code>bit_sumDuplicated()</code>: counts duplicate elements
</p>
</li></ul>


<h3>See Also</h3>

<p><code><a href="#topic+bit_sort_unique">bit_sort_unique()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>bit_unique(c(2L, 1L, NA, NA, 1L, 2L))
bit_unique(c(2L, 1L, NA, NA, 1L, 2L), na.rm=FALSE)
bit_unique(c(2L, 1L, NA, NA, 1L, 2L), na.rm=TRUE)

bit_duplicated(c(2L, 1L, NA, NA, 1L, 2L))
bit_duplicated(c(2L, 1L, NA, NA, 1L, 2L), na.rm=FALSE)
bit_duplicated(c(2L, 1L, NA, NA, 1L, 2L), na.rm=TRUE)

bit_anyDuplicated(c(2L, 1L, NA, NA, 1L, 2L))
bit_anyDuplicated(c(2L, 1L, NA, NA, 1L, 2L), na.rm=FALSE)
bit_anyDuplicated(c(2L, 1L, NA, NA, 1L, 2L), na.rm=TRUE)

bit_sumDuplicated(c(2L, 1L, NA, NA, 1L, 2L))
bit_sumDuplicated(c(2L, 1L, NA, NA, 1L, 2L), na.rm=FALSE)
bit_sumDuplicated(c(2L, 1L, NA, NA, 1L, 2L), na.rm=TRUE)
</code></pre>

<hr>
<h2 id='bitsort'>Low-level sorting: bit sort</h2><span id='topic+bitsort'></span>

<h3>Description</h3>

<p>In one pass over the vector <code>NA</code>s are handled according to parameter
<code>na.last</code> by <code><a href="#topic+range_sortna">range_sortna()</a></code>, then, if the vector is unsorted,
bit sort is invoked.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bitsort(x, na.last = NA, depth = 1)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="bitsort_+3A_x">x</code></td>
<td>
<p>an integer vector</p>
</td></tr>
<tr><td><code id="bitsort_+3A_na.last">na.last</code></td>
<td>
<p><code>NA</code> removes NAs, <code>FALSE</code> puts NAs at the beginning,
<code>TRUE</code> puts NAs at the end</p>
</td></tr>
<tr><td><code id="bitsort_+3A_depth">depth</code></td>
<td>
<p>an integer scalar giving the number of bit-passed before switching to
quicksort</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a sorted vector
</p>


<h3>Examples</h3>

<pre><code class='language-R'>bitsort(c(2L, 0L, 1L, NA, 2L))
bitsort(c(2L, 0L, 1L, NA, 2L), na.last=TRUE)
bitsort(c(2L, 0L, 1L, NA, 2L), na.last=FALSE)
</code></pre>

<hr>
<h2 id='bitwhich'>Create bitwhich vector (skewed boolean)</h2><span id='topic+bitwhich'></span>

<h3>Description</h3>

<p>A bitwhich object represents a boolean filter like a <code><a href="#topic+bit">bit()</a></code> object (NAs are not
allowed) but uses a sparse representation suitable for very skewed (asymmetric)
selections. Three extreme cases are represented with logical values, no length via
<code>logical()</code>, all <code>TRUE</code> with <code>TRUE</code> and all <code>FALSE</code> with <code>FALSE</code>. All other
selections are represented with positive or negative integers, whatever is shorter.
This needs less RAM compared to <code><a href="base.html#topic+logical">logical()</a></code> (and often less than <code><a href="#topic+bit">bit()</a></code> or
<code><a href="#topic+as.which">which()</a></code>). Logical operations are fast if the selection is asymmetric
(only few or almost all selected).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bitwhich(
  maxindex = 0L,
  x = NULL,
  xempty = FALSE,
  poslength = NULL,
  is.unsorted = TRUE,
  has.dup = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="bitwhich_+3A_maxindex">maxindex</code></td>
<td>
<p>length of the vector</p>
</td></tr>
<tr><td><code id="bitwhich_+3A_x">x</code></td>
<td>
<p>Information about which positions are <code>FALSE</code> or <code>TRUE</code>: either <code>logical()</code> or
<code>TRUE</code> or <code>FALSE</code> or a integer vector of positive or of negative subscripts.</p>
</td></tr>
<tr><td><code id="bitwhich_+3A_xempty">xempty</code></td>
<td>
<p>what to assume about parameter <code>x</code> if <code>x=integer(0)</code>, typically <code>TRUE</code>
or <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="bitwhich_+3A_poslength">poslength</code></td>
<td>
<p>tuning: <code>poslength</code> is calculated automatically, you can give
<code>poslength</code> explicitly, in this case it must be correct and <code>x</code> must be sorted and
not have duplicates.</p>
</td></tr>
<tr><td><code id="bitwhich_+3A_is.unsorted">is.unsorted</code></td>
<td>
<p>tuning: FALSE implies that <code>x</code> is already sorted and sorting
is skipped</p>
</td></tr>
<tr><td><code id="bitwhich_+3A_has.dup">has.dup</code></td>
<td>
<p>tuning: FALSE implies that <code>x</code> has no duplicates</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an object of class 'bitwhich' carrying two attributes
</p>

<ul>
<li><p> maxindex: see above
</p>
</li>
<li><p> poslength: see above
</p>
</li></ul>



<h3>See Also</h3>

<p><code><a href="#topic+bitwhich_representation">bitwhich_representation()</a></code>,  <code><a href="#topic+as.bitwhich">as.bitwhich()</a></code>, <code><a href="#topic+bit">bit()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>bitwhich()
bitwhich(12)
bitwhich(12, x=TRUE)
bitwhich(12, x=3)
bitwhich(12, x=-3)
bitwhich(12, x=integer())
bitwhich(12, x=integer(), xempty=TRUE)
</code></pre>

<hr>
<h2 id='bitwhich_representation'>Diagnose representation of bitwhich</h2><span id='topic+bitwhich_representation'></span>

<h3>Description</h3>

<p>Diagnose representation of bitwhich
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bitwhich_representation(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="bitwhich_representation_+3A_x">x</code></td>
<td>
<p>a <code><a href="#topic+bitwhich">bitwhich()</a></code> object</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a scalar, one of <code>logical()</code>, <code>FALSE</code>, <code>TRUE</code>, <code>-1</code> or <code>1</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>bitwhich_representation(bitwhich())
bitwhich_representation(bitwhich(12, FALSE))
bitwhich_representation(bitwhich(12, TRUE))
bitwhich_representation(bitwhich(12, -3))
bitwhich_representation(bitwhich(12, 3))
</code></pre>

<hr>
<h2 id='booltype'>Diagnosing boolean types</h2><span id='topic+booltype'></span>

<h3>Description</h3>

<p>Specific methods for <code>booltype</code> are required, where non-unary methods can combine
multiple bollean types, particularly boolean binary operators.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>booltype(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="booltype_+3A_x">x</code></td>
<td>
<p>an R object</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Function <code>booltype</code> returns the boolean type of its argument.
There are currently six boolean types, <code>booltypes</code> is an <code><a href="base.html#topic+ordered">ordered()</a></code> vector with the
following ordinal <code><a href="base.html#topic+levels">levels()</a></code>:
</p>

<ul>
<li><p> nobool: non-boolean type
</p>
</li>
<li> <p><code><a href="base.html#topic+logical">logical()</a></code>: for representing any boolean data including <code>NA</code>
</p>
</li>
<li> <p><code><a href="#topic+bit">bit()</a></code>: for representing dense boolean data
</p>
</li>
<li> <p><code><a href="#topic+bitwhich">bitwhich()</a></code>: for representing sparse (skewed) boolean data
</p>
</li>
<li> <p><code><a href="base.html#topic+which">which()</a></code>: for representing sparse boolean data with few 'TRUE
</p>
</li>
<li> <p><code><a href="#topic+ri">ri()</a></code>: range-indexing, for representing sparse boolean data with a single range of
<code>TRUE</code>
</p>
</li></ul>



<h3>Value</h3>

<p>one scalar element of <code><a href="#topic+booltypes">booltypes()</a></code> in case of 'nobool' it carries a name
attribute with the data type.
</p>


<h3>Note</h3>

<p>do not rely on the internal integer codes of these levels, we might add-in
<code><a href="ff.html#topic+hi">hi</a></code> later
</p>


<h3>See Also</h3>

<p><code><a href="#topic+booltypes">booltypes()</a></code>, <code><a href="#topic+is.booltype">is.booltype()</a></code>, <code><a href="#topic+as.booltype">as.booltype()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>unname(booltypes)
str(booltypes)
sapply(
  list(double(), integer(), logical(), bit(), bitwhich(), as.which(), ri(1, 2, 3)),
  booltype
)
</code></pre>

<hr>
<h2 id='booltypes'>Boolean types</h2><span id='topic+booltypes'></span>

<h3>Description</h3>

<p>The <code><a href="base.html#topic+ordered">ordered()</a></code> factor <code>booltypes</code> ranks the boolean types.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>booltypes
</code></pre>


<h3>Format</h3>

<p>An object of class <code>ordered</code> (inherits from <code>factor</code>) of length 6.
</p>


<h3>Details</h3>

<p>There are currently six boolean types, <code>booltypes</code> is an <code><a href="base.html#topic+ordered">ordered()</a></code> vector with the
following ordinal <code><a href="base.html#topic+levels">levels()</a></code>:
</p>

<ul>
<li><p> nobool: non-boolean type
</p>
</li>
<li> <p><code><a href="base.html#topic+logical">logical()</a></code>: for representing any boolean data including <code>NA</code>
</p>
</li>
<li> <p><code><a href="#topic+bit">bit()</a></code>: for representing dense boolean data
</p>
</li>
<li> <p><code><a href="#topic+bitwhich">bitwhich()</a></code>: for representing sparse (skewed) boolean data
</p>
</li>
<li> <p><code><a href="base.html#topic+which">which()</a></code>: for representing sparse boolean data with few 'TRUE
</p>
</li>
<li> <p><code><a href="#topic+ri">ri()</a></code>: range-indexing, for representing sparse boolean data with a single range of
<code>TRUE</code>
</p>
</li></ul>

<p><code>booltypes</code> has a <code><a href="base.html#topic+names">names()</a></code> attribute such that elements can be selected by name.
</p>


<h3>Note</h3>

<p>do not rely on the internal integer codes of these levels, we might add-in
<code><a href="ff.html#topic+hi">hi</a></code> later
</p>


<h3>See Also</h3>

<p><code><a href="#topic+booltype">booltype()</a></code>, <code><a href="#topic+is.booltype">is.booltype()</a></code>, <code><a href="#topic+as.booltype">as.booltype()</a></code>
</p>

<hr>
<h2 id='c.booltype'>Concatenating booltype vectors</h2><span id='topic+c.booltype'></span><span id='topic+c.bit'></span><span id='topic+c.bitwhich'></span>

<h3>Description</h3>

<p>Creating new boolean vectors by concatenating boolean vectors
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'booltype'
c(...)

## S3 method for class 'bit'
c(...)

## S3 method for class 'bitwhich'
c(...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="c.booltype_+3A_...">...</code></td>
<td>
<p><code><a href="#topic+booltype">booltype()</a></code> vectors</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a vector with the lowest input <code><a href="#topic+booltype">booltype()</a></code> (but not lower than<code><a href="base.html#topic+logical">logical()</a></code>)
</p>


<h3>Author(s)</h3>

<p>Jens Oehlschlägel
</p>


<h3>See Also</h3>

<p><code><a href="base.html#topic+c">c()</a></code>, <code><a href="#topic+bit">bit()</a></code> , <code><a href="#topic+bitwhich">bitwhich()</a></code>,  , <code><a href="base.html#topic+which">which()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'> c(bit(4), !bit(4))
 c(bit(4), !bitwhich(4))
 c(bitwhich(4), !bit(4))
 c(ri(1, 2, 4), !bit(4))
 c(bit(4), !logical(4))
 message("logical in first argument does not dispatch: c(logical(4), bit(4))")
 c.booltype(logical(4), !bit(4))

</code></pre>

<hr>
<h2 id='chunk'>Methods for chunked range index</h2><span id='topic+chunk'></span><span id='topic+chunk.default'></span>

<h3>Description</h3>

<p>Calls <code><a href="#topic+chunks">chunks()</a></code> to create a sequence of range indexes along the object which causes
the method dispatch.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>chunk(x = NULL, ...)

## Default S3 method:
chunk(x = NULL, ..., RECORDBYTES = NULL, BATCHBYTES = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="chunk_+3A_x">x</code></td>
<td>
<p>the object along we want chunks</p>
</td></tr>
<tr><td><code id="chunk_+3A_...">...</code></td>
<td>
<p>further arguments passed to <code><a href="#topic+chunks">chunks()</a></code></p>
</td></tr>
<tr><td><code id="chunk_+3A_recordbytes">RECORDBYTES</code></td>
<td>
<p>integer scalar representing the bytes needed to process a single
element of the boolean vector (default 4 bytes for logical)</p>
</td></tr>
<tr><td><code id="chunk_+3A_batchbytes">BATCHBYTES</code></td>
<td>
<p>integer scalar limiting the number of bytes to be processed in one
chunk, default from <code>getOption("ffbatchbytes")</code> if not null, otherwise 16777216</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>chunk</code> is generic, the default method is described here, other methods
that automatically consider RAM needs are provided with package 'ff', see
for example <code><a href="ff.html#topic+chunk.ffdf">ff::chunk.ffdf()</a></code>
</p>


<h3>Value</h3>

<p>returns a named list of <code><a href="#topic+ri">ri()</a></code> objects
representing chunks of subscripts
</p>


<h3>Methods (by class)</h3>


<ul>
<li> <p><code>chunk(default)</code>: default vector method
</p>
</li></ul>


<h3>available methods</h3>

<p><code>chunk.default</code>, <code><a href="ff.html#topic+chunk.ffdf">ff::chunk.ff_vector()</a></code>,
<code><a href="ff.html#topic+chunk.ffdf">ff::chunk.ffdf()</a></code>
</p>


<h3>Author(s)</h3>

<p>Jens Oehlschlägel
</p>


<h3>See Also</h3>

<p><code><a href="#topic+chunks">chunks()</a></code>, <code><a href="#topic+ri">ri()</a></code>, <code><a href="base.html#topic+seq">seq()</a></code>, <code><a href="#topic+bbatch">bbatch()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  chunk(complex(1e7))
  chunk(raw(1e7))
  chunk(raw(1e7), length=3)

  chunks(1, 10, 3)
  # no longer do
  chunk(1, 100, 10)
  # but for bckward compatibility this works
  chunk(from=1, to=100, by=10)

</code></pre>

<hr>
<h2 id='chunks'>Function for chunked range index</h2><span id='topic+chunks'></span>

<h3>Description</h3>

<p>creates a sequence of range indexes using a syntax not completely unlike
'seq'
</p>


<h3>Usage</h3>

<pre><code class='language-R'>chunks(
  from = NULL,
  to = NULL,
  by = NULL,
  length.out = NULL,
  along.with = NULL,
  overlap = 0L,
  method = c("bbatch", "seq"),
  maxindex = NA
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="chunks_+3A_from">from</code></td>
<td>
<p>the starting value of the sequence.</p>
</td></tr>
<tr><td><code id="chunks_+3A_to">to</code></td>
<td>
<p>the (maximal) end value of the sequence.</p>
</td></tr>
<tr><td><code id="chunks_+3A_by">by</code></td>
<td>
<p>increment of the sequence</p>
</td></tr>
<tr><td><code id="chunks_+3A_length.out">length.out</code></td>
<td>
<p>desired length of the sequence.</p>
</td></tr>
<tr><td><code id="chunks_+3A_along.with">along.with</code></td>
<td>
<p>take the length from the length of this argument.</p>
</td></tr>
<tr><td><code id="chunks_+3A_overlap">overlap</code></td>
<td>
<p>number of values to overlap (will lower the starting value of
the sequence, the first range becomes smaller</p>
</td></tr>
<tr><td><code id="chunks_+3A_method">method</code></td>
<td>
<p>default 'bbatch' will try to balance the chunk size, see
<code><a href="#topic+bbatch">bbatch()</a></code>, 'seq' will create chunks like <code><a href="base.html#topic+seq">seq()</a></code></p>
</td></tr>
<tr><td><code id="chunks_+3A_maxindex">maxindex</code></td>
<td>
<p>passed to <code><a href="#topic+ri">ri()</a></code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>returns a named list of <code><a href="#topic+ri">ri()</a></code> objects
representing chunks of subscripts
</p>


<h3>Author(s)</h3>

<p>Jens Oehlschlägel
</p>


<h3>See Also</h3>

<p>generic <code><a href="#topic+chunk">chunk()</a></code>, <code><a href="#topic+ri">ri()</a></code>, <code><a href="base.html#topic+seq">seq()</a></code>, <code><a href="#topic+bbatch">bbatch()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
  chunks(1, 100, by=30)
  chunks(1, 100, by=30, method="seq")
   ## Not run: 
require(foreach)
m &lt;- 10000
k &lt;- 1000
n &lt;- m*k
message("Four ways to loop from 1 to n. Slowest foreach to fastest chunk is 1700:1
on a dual core notebook with 3GB RAM\n")
z &lt;- 0L;
print(k*system.time({it &lt;- icount(m); foreach (i = it) %do% { z &lt;- i; NULL }}))
z

z &lt;- 0L
print(system.time({i &lt;- 0L; while (i &lt; n) {i &lt;- i + 1L; z &lt;- i}}))
z

z &lt;- 0L
print(system.time(for (i in 1:n) z &lt;- i))
z

z &lt;- 0L; n &lt;- m*k;
print(system.time(for (ch in chunks(1, n, by=m)) {for (i in ch[1]:ch[2]) z &lt;- i}))
z

message("Seven ways to calculate sum(1:n).
 Slowest foreach to fastest chunk is 61000:1 on a dual core notebook with 3GB RAM\n")
print(k*system.time({it &lt;- icount(m); foreach (i = it, .combine="+") %do% { i }}))

z &lt;- 0;
print(k*system.time({it &lt;- icount(m); foreach (i = it) %do% { z &lt;- z + i; NULL }}))
z

z &lt;- 0; print(system.time({i &lt;- 0L;while (i &lt; n) {i &lt;- i + 1L; z &lt;- z + i}})); z

z &lt;- 0; print(system.time(for (i in 1:n) z &lt;- z + i)); z

print(system.time(sum(as.double(1:n))))

z &lt;- 0; n &lt;- m*k
print(system.time(for (ch in chunks(1, n, by=m)) {for (i in ch[1]:ch[2]) z &lt;- z + i}))
z

z &lt;- 0; n &lt;- m*k
print(system.time(for (ch in chunks(1, n, by=m)) {z &lt;- z + sum(as.double(ch[1]:ch[2]))}))
z
   
## End(Not run)

</code></pre>

<hr>
<h2 id='clone'>Cloning ff and ram objects</h2><span id='topic+clone'></span><span id='topic+clone.default'></span>

<h3>Description</h3>

<p><code>clone</code> physically duplicates objects and can additionally change
some features, e.g. length.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>clone(x, ...)

## Default S3 method:
clone(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="clone_+3A_x">x</code></td>
<td>
<p><code>x</code> an R object</p>
</td></tr>
<tr><td><code id="clone_+3A_...">...</code></td>
<td>
<p>further arguments to the generic</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>clone</code> is generic.  <code>clone.default</code> handles ram objects.
Further methods are provided in package 'ff'.
<code>still.identical</code> returns TRUE if the two atomic arguments still
point to the same memory.
</p>


<h3>Value</h3>

<p>an object that is a deep copy of x
</p>


<h3>Methods (by class)</h3>


<ul>
<li> <p><code>clone(default)</code>: default method uses R's C-API 'duplicate()'
</p>
</li></ul>


<h3>Author(s)</h3>

<p>Jens Oehlschlägel
</p>


<h3>See Also</h3>

<p><code>clone.ff</code>, <code><a href="#topic+copy_vector">copy_vector()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
  x &lt;- 1:12
  y &lt;- x
  still.identical(x, y)
  y[1] &lt;- y[1]
  still.identical(x, y)
  y &lt;- clone(x)
  still.identical(x, y)
  rm(x, y); gc()

</code></pre>

<hr>
<h2 id='CoercionToStandard'>Coercion from bit, bitwhich, which and ri to logical, integer, double</h2><span id='topic+CoercionToStandard'></span><span id='topic+as.logical.bit'></span><span id='topic+as.integer.bit'></span><span id='topic+as.double.bit'></span><span id='topic+as.integer.bitwhich'></span><span id='topic+as.double.bitwhich'></span><span id='topic+as.logical.bitwhich'></span><span id='topic+as.logical.ri'></span><span id='topic+as.integer.ri'></span><span id='topic+as.double.ri'></span><span id='topic+as.logical.which'></span>

<h3>Description</h3>

<p>Coercion from bit is quite fast because we use a double loop that fixes each
word in a processor register.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'bit'
as.logical(x, ...)

## S3 method for class 'bit'
as.integer(x, ...)

## S3 method for class 'bit'
as.double(x, ...)

## S3 method for class 'bitwhich'
as.integer(x, ...)

## S3 method for class 'bitwhich'
as.double(x, ...)

## S3 method for class 'bitwhich'
as.logical(x, ...)

## S3 method for class 'ri'
as.logical(x, ...)

## S3 method for class 'ri'
as.integer(x, ...)

## S3 method for class 'ri'
as.double(x, ...)

## S3 method for class 'which'
as.logical(x, length = attr(x, "maxindex"), ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="CoercionToStandard_+3A_x">x</code></td>
<td>
<p>an object of class <code><a href="#topic+bit">bit()</a></code>, <code><a href="#topic+bitwhich">bitwhich()</a></code> or
<code><a href="#topic+ri">ri()</a></code></p>
</td></tr>
<tr><td><code id="CoercionToStandard_+3A_...">...</code></td>
<td>
<p>ignored</p>
</td></tr>
<tr><td><code id="CoercionToStandard_+3A_length">length</code></td>
<td>
<p>length of the boolean vector (required for <code>as.logical.which</code>)</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code><a href="base.html#topic+as.logical">as.logical()</a></code> returns a vector of <code style="white-space: pre;">&#8288;FALSE, TRUE&#8288;</code>,
<code><a href="base.html#topic+as.integer">as.integer()</a></code> and <code><a href="base.html#topic+as.double">as.double()</a></code> return a vector of
<code style="white-space: pre;">&#8288;0,1&#8288;</code>.
</p>


<h3>Author(s)</h3>

<p>Jens Oehlschlägel
</p>


<h3>See Also</h3>

<p><code><a href="#topic+CoercionToStandard">CoercionToStandard</a></code>, <code><a href="#topic+as.booltype">as.booltype()</a></code>, <code><a href="#topic+as.bit">as.bit()</a></code>,
<code><a href="#topic+as.bitwhich">as.bitwhich()</a></code> , <code><a href="#topic+as.which">as.which()</a></code>, <code><a href="#topic+as.ri">as.ri()</a></code>, <code><a href="ff.html#topic+as.hi">ff::as.hi()</a></code>,  <code><a href="ff.html#topic+as.ff">ff::as.ff()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
  x &lt;- ri(2, 5, 10)
  y &lt;- as.logical(x)
  y
  stopifnot(identical(y, as.logical(as.bit(x))))
  stopifnot(identical(y, as.logical(as.bitwhich(x))))

  y &lt;- as.integer(x)
  y
  stopifnot(identical(y, as.integer(as.logical(x))))
  stopifnot(identical(y, as.integer(as.bit(x))))
  stopifnot(identical(y, as.integer(as.bitwhich(x))))

  y &lt;- as.double(x)
  y
  stopifnot(identical(y, as.double(as.logical(x))))
  stopifnot(identical(y, as.double(as.bit(x))))
  stopifnot(identical(y, as.double(as.bitwhich(x))))
</code></pre>

<hr>
<h2 id='copy_vector'>Copy atomic R vector</h2><span id='topic+copy_vector'></span>

<h3>Description</h3>

<p>Creates a true copy of the underlying C-vector &ndash; dropping all attributes &ndash; and
optionally reverses the direction of the elements.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>copy_vector(x, revx = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="copy_vector_+3A_x">x</code></td>
<td>
<p>an R vector</p>
</td></tr>
<tr><td><code id="copy_vector_+3A_revx">revx</code></td>
<td>
<p>default <code>FALSE</code>, set to <code>TRUE</code> to reverse the elements in 'x'</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This can be substantially faster than <code>duplicate(as.vector(unclass(x)))</code>
</p>


<h3>Value</h3>

<p>copied R vector
</p>


<h3>See Also</h3>

<p><code><a href="#topic+clone">clone()</a></code>, <code><a href="#topic+still.identical">still.identical()</a></code>,  <code><a href="#topic+reverse_vector">reverse_vector()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- factor(letters)
y &lt;- x
z &lt;- copy_vector(x)
still.identical(x, y)
still.identical(x, z)
str(x)
str(y)
str(z)
</code></pre>

<hr>
<h2 id='countsort'>Low-level sorting: counting sort</h2><span id='topic+countsort'></span>

<h3>Description</h3>

<p>In one pass over the vector <code>NA</code>s are handled according to parameter
<code>na.last</code> by <code><a href="#topic+range_sortna">range_sortna()</a></code>, then, if the vector is unsorted,
counting sort is invoked.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>countsort(x, na.last = NA)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="countsort_+3A_x">x</code></td>
<td>
<p>an integer vector</p>
</td></tr>
<tr><td><code id="countsort_+3A_na.last">na.last</code></td>
<td>
<p><code>NA</code> removes NAs, <code>FALSE</code> puts NAs at the beginning,
<code>TRUE</code> puts NAs at the end</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a sorted vector
</p>


<h3>Examples</h3>

<pre><code class='language-R'>countsort(c(2L, 0L, 1L, NA, 2L))
countsort(c(2L, 0L, 1L, NA, 2L), na.last=TRUE)
countsort(c(2L, 0L, 1L, NA, 2L), na.last=FALSE)
</code></pre>

<hr>
<h2 id='Extract'>Extract or replace part of an boolean vector</h2><span id='topic+Extract'></span><span id='topic++5B+5B.bit'></span><span id='topic++5B+5B+3C-.bit'></span><span id='topic++5B.bit'></span><span id='topic++5B+3C-.bit'></span><span id='topic++5B+5B.bitwhich'></span><span id='topic++5B+5B+3C-.bitwhich'></span><span id='topic++5B.bitwhich'></span><span id='topic++5B+3C-.bitwhich'></span>

<h3>Description</h3>

<p>Operators acting on <code><a href="#topic+bit">bit()</a></code> or <code><a href="#topic+bitwhich">bitwhich()</a></code> objects to extract or replace parts.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'bit'
x[[i]]

## S3 replacement method for class 'bit'
x[[i]] &lt;- value

## S3 method for class 'bit'
x[i]

## S3 replacement method for class 'bit'
x[i] &lt;- value

## S3 method for class 'bitwhich'
x[[i]]

## S3 replacement method for class 'bitwhich'
x[[i]] &lt;- value

## S3 method for class 'bitwhich'
x[i]

## S3 replacement method for class 'bitwhich'
x[i] &lt;- value
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="Extract_+3A_x">x</code></td>
<td>
<p>a <code><a href="#topic+bit">bit()</a></code> or <code><a href="#topic+bitwhich">bitwhich()</a></code> object</p>
</td></tr>
<tr><td><code id="Extract_+3A_i">i</code></td>
<td>
<p>preferrably a positive integer subscript or a <code><a href="#topic+ri">ri()</a></code>, see text</p>
</td></tr>
<tr><td><code id="Extract_+3A_value">value</code></td>
<td>
<p>new logical or integer values</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The typical usecase for '[' and '[&lt;-' is subscripting with positive integers,
negative integers are allowed but slower,
as logical subscripts only scalars are allowed.
The subscript can be given as a <code><a href="#topic+bitwhich">bitwhich()</a></code> object.
Also <code><a href="#topic+ri">ri()</a></code> can be used as subscript.
</p>
<p>Extracting from <code><a href="#topic+bit">bit()</a></code> and <code><a href="#topic+bitwhich">bitwhich()</a></code> is faster than from  <code><a href="base.html#topic+logical">logical()</a></code> if positive
subscripts are used. Unteger subscripts make sense.  Negative subscripts are
converted to positive ones, beware the RAM consumption.
</p>


<h3>Value</h3>

<p>The extractors <code>[[</code> and <code>[</code> return a logical scalar or
vector.  The replacment functions return an object of <code>class(x)</code>.
</p>


<h3>Author(s)</h3>

<p>Jens Oehlschlägel
</p>


<h3>See Also</h3>

<p><code><a href="#topic+bit">bit()</a></code>, <a href="base.html#topic+Extract">'Extract&ldquo;</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
  x &lt;- as.bit(c(FALSE, NA, TRUE))
  x[] &lt;- c(FALSE, NA, TRUE)
  x[1:2]
  x[-3]
  x[ri(1, 2)]
  x[as.bitwhich(c(TRUE, TRUE, FALSE))]
  x[[1]]
  x[] &lt;- TRUE
  x[1:2] &lt;- FALSE
  x[[1]] &lt;- TRUE

</code></pre>

<hr>
<h2 id='firstNA'>Position of first NA</h2><span id='topic+firstNA'></span>

<h3>Description</h3>

<p>This is substantially faster than <code>which.max(is.na(x))</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>firstNA(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="firstNA_+3A_x">x</code></td>
<td>
<p>an R vector</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a reversed vector
</p>


<h3>See Also</h3>

<p><code><a href="base.html#topic+which.max">which.max()</a></code>, <code><a href="base.html#topic+is.na">is.na()</a></code>, <code><a href="base.html#topic+anyNA">anyNA()</a></code>, <code><a href="base.html#topic+anyDuplicated">anyDuplicated()</a></code>, <code><a href="#topic+bit_anyDuplicated">bit_anyDuplicated()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- c(FALSE, NA, TRUE)
firstNA(x)
reverse_vector(x)
## Not run: 
x &lt;- 1:1e7
system.time(rev(x))
system.time(reverse_vector(x))

## End(Not run)
</code></pre>

<hr>
<h2 id='get_length'>Get C length of a vector</h2><span id='topic+get_length'></span>

<h3>Description</h3>

<p>Gets C length of a vector ignoring any length-methods dispatched by classes
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_length(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="get_length_+3A_x">x</code></td>
<td>
<p>a vector</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Queries the vector length using C-macro <code>LENGTH</code>, this can be substantially faster than
<code>length(unclass(x))</code>
</p>


<h3>Value</h3>

<p>integer scalar
</p>


<h3>Examples</h3>

<pre><code class='language-R'>length(bit(12))
get_length(bit(12))
</code></pre>

<hr>
<h2 id='getsetattr'>Attribute setting by reference</h2><span id='topic+getsetattr'></span><span id='topic+setattr'></span><span id='topic+setattributes'></span>

<h3>Description</h3>

<p>Function <code>setattr</code> sets a singe attribute and function
<code>setattributes</code> sets a list of attributes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getsetattr(x, which, value)

setattr(x, which, value)

setattributes(x, attributes)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="getsetattr_+3A_x">x</code></td>
<td>
<p>an R object</p>
</td></tr>
<tr><td><code id="getsetattr_+3A_which">which</code></td>
<td>
<p>name of the attribute</p>
</td></tr>
<tr><td><code id="getsetattr_+3A_value">value</code></td>
<td>
<p>value of the attribute, use NULL to remove this attribute</p>
</td></tr>
<tr><td><code id="getsetattr_+3A_attributes">attributes</code></td>
<td>
<p>a named list of attribute values</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The attributes of 'x' are changed in place without copying x. function
<code>setattributes</code> does only change the named attributes, it does not
delete the non-names attributes like <code><a href="base.html#topic+attributes">attributes()</a></code> does.
</p>


<h3>Value</h3>

<p>invisible(), we do not return the changed object to remind you of
the fact that this function is called for its side-effect of changing its
input object.
</p>


<h3>Author(s)</h3>

<p>Jens Oehlschlägel
</p>


<h3>References</h3>

<p>Writing R extensions &ndash; System and foreign language interfaces
&ndash; Handling R objects in C &ndash; Attributes (Version 2.11.1 (2010-06-03 ) R
Development)
</p>


<h3>See Also</h3>

<p><code><a href="base.html#topic+attr">attr()</a></code> <code><a href="#topic+unattr">unattr()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
  x &lt;- as.single(runif(10))
  attr(x, "Csingle")

  f &lt;- function(x) attr(x, "Csingle") &lt;- NULL
  g &lt;- function(x) setattr(x, "Csingle", NULL)

  f(x)
  x
  g(x)
  x

 ## Not run: 

  # restart R
  library(bit)

  mysingle &lt;- function(length = 0) {
    ret &lt;- double(length)
    setattr(ret, "Csingle", TRUE)
    ret
  }

  # show that mysinge gives exactly the same result as single
  identical(single(10), mysingle(10))

  # look at the speedup and memory-savings of mysingle compared to single
  system.time(mysingle(1e7))
  memory.size(max=TRUE)
  system.time(single(1e7))
  memory.size(max=TRUE)

  # look at the memory limits
  # on my win32 machine the first line fails
  #   because of not enough RAM, the second works
  x &lt;- single(1e8)
  x &lt;- mysingle(1e8)

  # .g. performance with factors
  x &lt;- rep(factor(letters), length.out=1e7)
  x[1:10]
  # look how fast one can do this
  system.time(setattr(x, "levels", rev(letters)))
  x[1:10]
  # look at the performance loss in time caused by the non-needed copying
  system.time(levels(x) &lt;- letters)
  x[1:10]


  # restart R
  library(bit)

  simplefactor &lt;- function(n) {
    factor(rep(1:2, length.out=n))
  }

  mysimplefactor &lt;- function(n) {
    ret &lt;- rep(1:2, length.out=n)
    setattr(ret, "levels", as.character(1:2))
    setattr(ret, "class", "factor")
    ret
  }

  identical(simplefactor(10), mysimplefactor(10))

  system.time(x &lt;- mysimplefactor(1e7))
  memory.size(max=TRUE)
  system.time(setattr(x, "levels", c("a", "b")))
  memory.size(max=TRUE)
  x[1:4]
  memory.size(max=TRUE)
  rm(x)
  gc()

  system.time(x &lt;- simplefactor(1e7))
  memory.size(max=TRUE)
  system.time(levels(x) &lt;- c("x", "y"))
  memory.size(max=TRUE)
  x[1:4]
  memory.size(max=TRUE)
  rm(x)
  gc()


## End(Not run)


</code></pre>

<hr>
<h2 id='in.bitwhich'>Check existence of integers in table</h2><span id='topic+in.bitwhich'></span>

<h3>Description</h3>

<p>If the table is sorted, this can be much faster than <code><a href="base.html#topic+match">%in%</a></code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>in.bitwhich(x, table, is.unsorted = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="in.bitwhich_+3A_x">x</code></td>
<td>
<p>a vector of integer</p>
</td></tr>
<tr><td><code id="in.bitwhich_+3A_table">table</code></td>
<td>
<p>a <code><a href="#topic+bitwhich">bitwhich()</a></code> object or a vector of integer</p>
</td></tr>
<tr><td><code id="in.bitwhich_+3A_is.unsorted">is.unsorted</code></td>
<td>
<p>logical telling the function whether the table is (un)sorted. With
the default <code>NULL</code> <code>FALSE</code> is assumed for <code><a href="#topic+bitwhich">bitwhich()</a></code> tables, otherwise <code>TRUE</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>logical vector
</p>


<h3>See Also</h3>

<p><code><a href="base.html#topic+match">%in%</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- bitwhich(100)
x[3] &lt;- TRUE
in.bitwhich(c(NA, 2, 3), x)
</code></pre>

<hr>
<h2 id='intrle'>Hybrid Index, C-coded utilities</h2><span id='topic+intrle'></span><span id='topic+intisasc'></span><span id='topic+intisdesc'></span>

<h3>Description</h3>

<p>These C-coded utilitites speed up index preprocessing considerably.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>intrle(x)

intisasc(x, na.method = c("none", "break", "skip")[2])

intisdesc(x, na.method = c("none", "break", "skip")[1])
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="intrle_+3A_x">x</code></td>
<td>
<p>an integer vector</p>
</td></tr>
<tr><td><code id="intrle_+3A_na.method">na.method</code></td>
<td>
<p>one of &quot;none&quot;, &quot;break&quot;, &quot;skip&quot;, see details. The strange defaults stem
from the initial usage.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>intrle</code> is by factor 50 faster and needs less RAM (2x its input
vector) compared to <code><a href="base.html#topic+rle">rle()</a></code> which needs 9x the RAM of its input
vector.  This is achieved because we allow the C-code of <code>intrle</code> to
break when it turns out, that rle-packing will not achieve a compression
factor of 3 or better.
</p>
<p><code>intisasc</code> is a faster version of <code><a href="base.html#topic+is.unsorted">is.unsorted()</a></code>: it checks whether <code>x</code> is sorted.
</p>
<p><code>intisdesc</code> checks for being sorted descending and by default default assumes that the
input <code>x</code> contains no NAs.
</p>
<p><code>na.method="none"</code> treats <code>NAs</code> (the smallest integer) like every other integer and
hence returns either <code>TRUE</code> or <code>FALSE</code> <code>na.method="break"</code> checks for <code>NAs</code> and
returns either <code>NA</code> as soon as  <code>NA</code> is encountered. <code>na.method="skip"</code> checks for
<code>NAs</code> and skips over them, hence decides the return value only on the basis of
non-NA values.
</p>


<h3>Value</h3>


<ul>
<li> <p><code>intrle</code> returns an object of class <code><a href="base.html#topic+rle">rle()</a></code> or NULL, if rle-compression is not
efficient (compression factor &lt;3 or <code>length(x) &lt; 3</code>).
</p>
</li>
<li> <p><code>intisasc</code> returns one of <code style="white-space: pre;">&#8288;FALSE, NA, TRUE&#8288;</code>
</p>
</li>
<li> <p><code>intisdesc</code> returns one of <code style="white-space: pre;">&#8288;FALSE, TRUE&#8288;</code> (if the input contains NAs, the output is
undefined)
</p>
</li></ul>



<h3>Functions</h3>


<ul>
<li> <p><code>intisasc()</code>: check whether integer vector is ascending
</p>
</li>
<li> <p><code>intisdesc()</code>: check whether integer vector is descending
</p>
</li></ul>


<h3>Author(s)</h3>

<p>Jens Oehlschlägel
</p>


<h3>See Also</h3>

<p><code><a href="ff.html#topic+hi">ff::hi()</a></code>, <code><a href="base.html#topic+rle">rle()</a></code>, <code><a href="base.html#topic+is.unsorted">is.unsorted()</a></code>,
<code><a href="ff.html#topic+is.sorted">ff::is.sorted.default()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
  intrle(sample(1:10))
  intrle(diff(1:10))
  intisasc(1:10)
  intisasc(10:1)
  intisasc(c(NA, 1:10))
  intisdesc(1:10)
  intisdesc(c(10:1, NA))
  intisdesc(c(10:6, NA, 5:1))
  intisdesc(c(10:6, NA, 5:1), na.method="skip")
  intisdesc(c(10:6, NA, 5:1), na.method="break")

</code></pre>

<hr>
<h2 id='is.booltype'>Testing for boolean types</h2><span id='topic+is.booltype'></span><span id='topic+is.bit'></span><span id='topic+is.bitwhich'></span><span id='topic+is.which'></span><span id='topic+is.hi'></span><span id='topic+is.ri'></span>

<h3>Description</h3>

<p>All <code><a href="#topic+booltypes">booltypes()</a></code> including  <code><a href="base.html#topic+logical">logical()</a></code> except 'nobool' types are considered
'is.booltype'.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is.booltype(x)

is.bit(x)

is.bitwhich(x)

is.which(x)

is.hi(x)

is.ri(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="is.booltype_+3A_x">x</code></td>
<td>
<p>an R object</p>
</td></tr>
</table>


<h3>Value</h3>

<p>logical scalar
</p>


<h3>Functions</h3>


<ul>
<li> <p><code>is.bit()</code>: tests for <code><a href="#topic+bit">bit()</a></code>
</p>
</li>
<li> <p><code>is.bitwhich()</code>: tests for <code><a href="#topic+bitwhich">bitwhich()</a></code>
</p>
</li>
<li> <p><code>is.which()</code>: tests for <code><a href="#topic+as.which">which()</a></code>
</p>
</li>
<li> <p><code>is.hi()</code>: tests for <code><a href="ff.html#topic+hi">hi</a></code>
</p>
</li>
<li> <p><code>is.ri()</code>: tests for <code><a href="#topic+ri">ri()</a></code>
</p>
</li></ul>


<h3>See Also</h3>

<p><code><a href="#topic+booltypes">booltypes()</a></code>, <code><a href="#topic+booltype">booltype()</a></code>, <code><a href="#topic+as.booltype">as.booltype()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>sapply(
  list(double(), integer(), logical(), bit(), bitwhich(), as.which(), ri(1, 2, 3)),
  is.booltype
)
</code></pre>

<hr>
<h2 id='is.na.bit'>Test for NA in bit and bitwhich</h2><span id='topic+is.na.bit'></span><span id='topic+is.na.bitwhich'></span>

<h3>Description</h3>

<p>Test for NA in bit and bitwhich
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'bit'
is.na(x)

## S3 method for class 'bitwhich'
is.na(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="is.na.bit_+3A_x">x</code></td>
<td>
<p>a <code><a href="#topic+bit">bit()</a></code> or  <code><a href="#topic+bitwhich">bitwhich()</a></code> vector</p>
</td></tr>
</table>


<h3>Value</h3>

<p>vector of same type with all elements <code>FALSE</code>
</p>


<h3>Functions</h3>


<ul>
<li> <p><code>is.na(bitwhich)</code>: method for <code><a href="base.html#topic+is.na">is.na()</a></code> from <code><a href="#topic+bitwhich">bitwhich()</a></code>
</p>
</li></ul>


<h3>See Also</h3>

<p><code><a href="base.html#topic+is.na">is.na()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>is.na(bit(6))
is.na(bitwhich(6))
</code></pre>

<hr>
<h2 id='length.bit'>Getting and setting length of bit, bitwhich and ri objects</h2><span id='topic+length.bit'></span><span id='topic+length+3C-.bit'></span><span id='topic+length.bitwhich'></span><span id='topic+length+3C-.bitwhich'></span><span id='topic+length.ri'></span>

<h3>Description</h3>

<p>Query the number of bits in a <code><a href="#topic+bit">bit()</a></code> vector or change the number
of bits in a bit vector.
Query the number of bits in a bitwhich()] vector or change the number of bits in a bit
vector.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'bit'
length(x)

## S3 replacement method for class 'bit'
length(x) &lt;- value

## S3 method for class 'bitwhich'
length(x)

## S3 replacement method for class 'bitwhich'
length(x) &lt;- value

## S3 method for class 'ri'
length(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="length.bit_+3A_x">x</code></td>
<td>
<p>a <code><a href="#topic+bit">bit()</a></code>, <code><a href="#topic+bitwhich">bitwhich()</a></code> or <code><a href="#topic+ri">ri()</a></code>
object</p>
</td></tr>
<tr><td><code id="length.bit_+3A_value">value</code></td>
<td>
<p>the new number of bits</p>
</td></tr>
</table>


<h3>Details</h3>

<p>NOTE that the length does NOT reflect the number of selected (<code>TRUE</code>)
bits, it reflects the sum of both, <code>TRUE</code> and <code>FALSE</code> bits.
Increasing the length of a <code><a href="#topic+bit">bit()</a></code> object will set new bits to
<code>FALSE</code>.  The behaviour of increasing the length of a
<code><a href="#topic+bitwhich">bitwhich()</a></code> object is different and depends on the content of the
object:
</p>

<ul>
<li><p> TRUE &ndash; all included, new bits are set to <code>TRUE</code>
</p>
</li>
<li><p> positive integers &ndash; some included, new bits are set to <code>FALSE</code>
</p>
</li>
<li><p> negative integers &ndash; some excluded, new bits are set to <code>TRUE</code>
</p>
</li>
<li><p> FALSE &ndash; all excluded:, new bits are set to <code>FALSE</code>
</p>
</li></ul>

<p>Decreasing the length of bit or bitwhich removes any previous information
about the status bits above the new length.
</p>


<h3>Value</h3>

<p>the length A bit vector with the new length
</p>


<h3>Author(s)</h3>

<p>Jens Oehlschlägel
</p>


<h3>See Also</h3>

<p><code><a href="base.html#topic+length">length()</a></code>, <code><a href="#topic+sum.bit">sum()</a></code>,
<code><a href="#topic+poslength">poslength()</a></code>, <code><a href="#topic+maxindex">maxindex()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
  stopifnot(length(ri(1, 1, 32)) == 32)

  x &lt;- as.bit(ri(32, 32, 32))
  stopifnot(length(x) == 32)
  stopifnot(sum(x) == 1)
  length(x) &lt;- 16
  stopifnot(length(x) == 16)
  stopifnot(sum(x) == 0)
  length(x) &lt;- 32
  stopifnot(length(x) == 32)
  stopifnot(sum(x) == 0)

  x &lt;- as.bit(ri(1, 1, 32))
  stopifnot(length(x) == 32)
  stopifnot(sum(x) == 1)
  length(x) &lt;- 16
  stopifnot(length(x) == 16)
  stopifnot(sum(x) == 1)
  length(x) &lt;- 32
  stopifnot(length(x) == 32)
  stopifnot(sum(x) == 1)

  x &lt;- as.bitwhich(bit(32))
  stopifnot(length(x) == 32)
  stopifnot(sum(x) == 0)
  length(x) &lt;- 16
  stopifnot(length(x) == 16)
  stopifnot(sum(x) == 0)
  length(x) &lt;- 32
  stopifnot(length(x) == 32)
  stopifnot(sum(x) == 0)

  x &lt;- as.bitwhich(!bit(32))
  stopifnot(length(x) == 32)
  stopifnot(sum(x) == 32)
  length(x) &lt;- 16
  stopifnot(length(x) == 16)
  stopifnot(sum(x) == 16)
  length(x) &lt;- 32
  stopifnot(length(x) == 32)
  stopifnot(sum(x) == 32)

  x &lt;- as.bitwhich(ri(32, 32, 32))
  stopifnot(length(x) == 32)
  stopifnot(sum(x) == 1)
  length(x) &lt;- 16
  stopifnot(length(x) == 16)
  stopifnot(sum(x) == 0)
  length(x) &lt;- 32
  stopifnot(length(x) == 32)
  stopifnot(sum(x) == 0)

  x &lt;- as.bitwhich(ri(2, 32, 32))
  stopifnot(length(x) == 32)
  stopifnot(sum(x) == 31)
  length(x) &lt;- 16
  stopifnot(length(x) == 16)
  stopifnot(sum(x) == 15)
  length(x) &lt;- 32
  stopifnot(length(x) == 32)
  stopifnot(sum(x) == 31)

  x &lt;- as.bitwhich(ri(1, 1, 32))
  stopifnot(length(x) == 32)
  stopifnot(sum(x) == 1)
  length(x) &lt;- 16
  stopifnot(length(x) == 16)
  stopifnot(sum(x) == 1)
  length(x) &lt;- 32
  stopifnot(length(x) == 32)
  stopifnot(sum(x) == 1)

  x &lt;- as.bitwhich(ri(1, 31, 32))
  stopifnot(length(x) == 32)
  stopifnot(sum(x) == 31)
  message("NOTE the change from 'some excluded' to 'all excluded' here")
  length(x) &lt;- 16
  stopifnot(length(x) == 16)
  stopifnot(sum(x) == 16)
  length(x) &lt;- 32
  stopifnot(length(x) == 32)
  stopifnot(sum(x) == 32)

</code></pre>

<hr>
<h2 id='maxindex.default'>Get maxindex (length of boolean vector) and poslength (number of 'selected' elements)</h2><span id='topic+maxindex.default'></span><span id='topic+poslength.default'></span><span id='topic+maxindex.logical'></span><span id='topic+poslength.logical'></span><span id='topic+maxindex.bit'></span><span id='topic+poslength.bit'></span><span id='topic+maxindex.bitwhich'></span><span id='topic+poslength.bitwhich'></span><span id='topic+maxindex.which'></span><span id='topic+poslength.which'></span><span id='topic+maxindex.ri'></span><span id='topic+poslength.ri'></span><span id='topic+maxindex'></span><span id='topic+poslength'></span>

<h3>Description</h3>

<p>For <code><a href="#topic+is.booltype">is.booltype()</a></code> objects the term <code><a href="base.html#topic+length">length()</a></code> is ambiguous.
For example the length of <code><a href="base.html#topic+which">which()</a></code> corresponds to the sum of <code><a href="base.html#topic+logical">logical()</a></code>.
The generic <code>maxindex</code> gives <code>length(logical)</code> for all <code><a href="#topic+booltype">booltype()</a></code>s.
The generic <code>poslength</code> gives the number of positively selected elements, i.e.
<code>sum(logical)</code> for all <code><a href="#topic+booltype">booltype()</a></code>s (and gives <code>NA</code> if <code>NAs</code> are present).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## Default S3 method:
maxindex(x, ...)

## Default S3 method:
poslength(x, ...)

## S3 method for class 'logical'
maxindex(x, ...)

## S3 method for class 'logical'
poslength(x, ...)

## S3 method for class 'bit'
maxindex(x, ...)

## S3 method for class 'bit'
poslength(x, ...)

## S3 method for class 'bitwhich'
maxindex(x, ...)

## S3 method for class 'bitwhich'
poslength(x, ...)

## S3 method for class 'which'
maxindex(x, ...)

## S3 method for class 'which'
poslength(x, ...)

## S3 method for class 'ri'
maxindex(x, ...)

## S3 method for class 'ri'
poslength(x, ...)

maxindex(x, ...)

poslength(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="maxindex.default_+3A_x">x</code></td>
<td>
<p>an R object, typically a <code><a href="#topic+is.booltype">is.booltype()</a></code> object.</p>
</td></tr>
<tr><td><code id="maxindex.default_+3A_...">...</code></td>
<td>
<p>further arguments (ignored)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an integer scalar
</p>


<h3>Methods (by class)</h3>


<ul>
<li> <p><code>maxindex(default)</code>: default method for <code>maxindex</code>
</p>
</li>
<li> <p><code>maxindex(logical)</code>: <code>maxindex</code> method for class <code><a href="base.html#topic+logical">logical()</a></code>
</p>
</li>
<li> <p><code>maxindex(bit)</code>: <code>maxindex</code> method for class <code><a href="#topic+bit">bit()</a></code>
</p>
</li>
<li> <p><code>maxindex(bitwhich)</code>: <code>maxindex</code> method for class <code><a href="#topic+bitwhich">bitwhich()</a></code>
</p>
</li>
<li> <p><code>maxindex(which)</code>: <code>maxindex</code> method for class <code><a href="#topic+as.which">which()</a></code>
</p>
</li>
<li> <p><code>maxindex(ri)</code>: <code>maxindex</code> method for class <code><a href="#topic+ri">ri()</a></code>
</p>
</li></ul>


<h3>Functions</h3>


<ul>
<li> <p><code>poslength(default)</code>: default method for <code>poslength</code>
</p>
</li>
<li> <p><code>poslength(logical)</code>: <code>poslength</code> method for class <code><a href="base.html#topic+logical">logical()</a></code>
</p>
</li>
<li> <p><code>poslength(bit)</code>: <code>poslength</code> method for class <code><a href="#topic+bit">bit()</a></code>
</p>
</li>
<li> <p><code>poslength(bitwhich)</code>: <code>poslength</code> method for class <code><a href="#topic+bitwhich">bitwhich()</a></code>
</p>
</li>
<li> <p><code>poslength(which)</code>: <code>poslength</code> method for class <code><a href="#topic+as.which">which()</a></code>
</p>
</li>
<li> <p><code>poslength(ri)</code>: <code>poslength</code> method for class <code><a href="#topic+ri">ri()</a></code>
</p>
</li></ul>


<h3>Examples</h3>

<pre><code class='language-R'>r &lt;- ri(1, 2, 12)
i &lt;- as.which(r)
w &lt;- as.bitwhich(r)
b &lt;- as.bit(r)
l &lt;- as.logical(r)
u &lt;- which(l)      # unclassed which

sapply(list(r=r, u=u, i=i, w=w, b=b, l=l), function(x) {
  c(length=length(x), sum=sum(x), maxindex=maxindex(x), poslength=poslength(x))
})
</code></pre>

<hr>
<h2 id='merge_rev'>Fast functions for sorted sets of integer</h2><span id='topic+merge_rev'></span><span id='topic+merge_match'></span><span id='topic+merge_in'></span><span id='topic+merge_notin'></span><span id='topic+merge_duplicated'></span><span id='topic+merge_anyDuplicated'></span><span id='topic+merge_sumDuplicated'></span><span id='topic+merge_unique'></span><span id='topic+merge_union'></span><span id='topic+merge_setdiff'></span><span id='topic+merge_symdiff'></span><span id='topic+merge_intersect'></span><span id='topic+merge_setequal'></span><span id='topic+merge_rangein'></span><span id='topic+merge_rangenotin'></span><span id='topic+merge_rangesect'></span><span id='topic+merge_rangediff'></span><span id='topic+merge_first'></span><span id='topic+merge_last'></span><span id='topic+merge_firstin'></span><span id='topic+merge_lastin'></span><span id='topic+merge_firstnotin'></span><span id='topic+merge_lastnotin'></span>

<h3>Description</h3>

<p>The <code>merge_</code> functions allow unary and binary operations on (ascending) sorted vectors
of <code><a href="base.html#topic+integer">integer()</a></code>.
<code>merge_rev(x)</code> will do in one scan what costs two scans in <code><a href="base.html#topic+rev">-rev(x)</a></code>, see also
<code><a href="#topic+reverse_vector">reverse_vector()</a></code>.
Many of these <code>merge_</code> can optionally scan their input in reverse order (and switch the
sign), which again saves extra scans for calling <code>merge_rev(x)</code> first.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>merge_rev(x)

merge_match(x, y, revx = FALSE, revy = FALSE, nomatch = NA_integer_)

merge_in(x, y, revx = FALSE, revy = FALSE)

merge_notin(x, y, revx = FALSE, revy = FALSE)

merge_duplicated(x, revx = FALSE)

merge_anyDuplicated(x, revx = FALSE)

merge_sumDuplicated(x, revx = FALSE)

merge_unique(x, revx = FALSE)

merge_union(
  x,
  y,
  revx = FALSE,
  revy = FALSE,
  method = c("unique", "exact", "all")
)

merge_setdiff(x, y, revx = FALSE, revy = FALSE, method = c("unique", "exact"))

merge_symdiff(x, y, revx = FALSE, revy = FALSE, method = c("unique", "exact"))

merge_intersect(
  x,
  y,
  revx = FALSE,
  revy = FALSE,
  method = c("unique", "exact")
)

merge_setequal(x, y, revx = FALSE, revy = FALSE, method = c("unique", "exact"))

merge_rangein(rx, y, revx = FALSE, revy = FALSE)

merge_rangenotin(rx, y, revx = FALSE, revy = FALSE)

merge_rangesect(rx, y, revx = FALSE, revy = FALSE)

merge_rangediff(rx, y, revx = FALSE, revy = FALSE)

merge_first(x, revx = FALSE)

merge_last(x, revx = FALSE)

merge_firstin(rx, y, revx = FALSE, revy = FALSE)

merge_lastin(rx, y, revx = FALSE, revy = FALSE)

merge_firstnotin(rx, y, revx = FALSE, revy = FALSE)

merge_lastnotin(rx, y, revx = FALSE, revy = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="merge_rev_+3A_x">x</code></td>
<td>
<p>a sorted set</p>
</td></tr>
<tr><td><code id="merge_rev_+3A_y">y</code></td>
<td>
<p>a sorted set</p>
</td></tr>
<tr><td><code id="merge_rev_+3A_revx">revx</code></td>
<td>
<p>default <code>FALSE</code>, set to <code>TRUE</code> to reverse scan parameter 'x'</p>
</td></tr>
<tr><td><code id="merge_rev_+3A_revy">revy</code></td>
<td>
<p>default <code>FALSE</code>, set to <code>TRUE</code> to reverse scan parameter 'y'</p>
</td></tr>
<tr><td><code id="merge_rev_+3A_nomatch">nomatch</code></td>
<td>
<p>integer value returned for non-matched elements, see <code><a href="base.html#topic+match">match()</a></code></p>
</td></tr>
<tr><td><code id="merge_rev_+3A_method">method</code></td>
<td>
<p>one of &quot;unique&quot;, &quot;exact&quot; (or &quot;all&quot;) which governs how to treat ties, see
the function descriptions</p>
</td></tr>
<tr><td><code id="merge_rev_+3A_rx">rx</code></td>
<td>
<p>range of integers given as <code><a href="#topic+ri">ri()</a></code> or as a two-element <code><a href="base.html#topic+integer">integer()</a></code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>These are low-level functions and hence do not check whether the set is
actually sorted.
Note that the <code style="white-space: pre;">&#8288;merge_*&#8288;</code> and <code style="white-space: pre;">&#8288;merge_range*&#8288;</code> functions have no special treatment for
<code>NA</code>.
If vectors with <code>NA</code> are sorted ith <code>NA</code> in the first positions (<code>na.last=FALSE</code>) and
arguments <code style="white-space: pre;">&#8288;revx=&#8288;</code> or <code style="white-space: pre;">&#8288;revy=&#8288;</code> have not been used, then <code>NAs</code> are treated like ordinary
integers. <code>NA</code> sorted elsewhere or using <code style="white-space: pre;">&#8288;revx=&#8288;</code> or <code style="white-space: pre;">&#8288;revy=&#8288;</code> can cause unexpected
results (note for example that <code style="white-space: pre;">&#8288;revx=&#8288;</code> switches the sign on all integers but <code>NAs</code>).
</p>
<p>The <em>binary</em> <code style="white-space: pre;">&#8288;merge_*&#8288;</code> functions have a <code>method="exact"</code>
which in both sets treats consecutive occurrences of the same value as if they were
different values, more precisely they are handled as if the identity of ties were
tuples of <code style="white-space: pre;">&#8288;ties, rank(ties)&#8288;</code>. <code>method="exact"</code> delivers unique output if the input is
unique, and in this case works faster than <code>method="unique"</code>.
</p>


<h3>Value</h3>

<p><code>merge_rev(x)</code> returns <code><a href="base.html#topic+rev">-rev(x)</a></code> for <code><a href="base.html#topic+integer">integer()</a></code> and <code><a href="base.html#topic+double">double()</a></code> and
<code><a href="base.html#topic+rev">!rev(x)</a></code> for <code><a href="base.html#topic+logical">logical()</a></code>
</p>


<h3>Functions</h3>


<ul>
<li> <p><code>merge_match()</code>: returns integer positions of sorted set x in sorted set y, see
<code><a href="base.html#topic+match">match(x, y, ...)</a></code>
</p>
</li>
<li> <p><code>merge_in()</code>: returns logical existence of sorted set x in sorted set y, see
<code><a href="base.html#topic+match">x %in% y</a></code>
</p>
</li>
<li> <p><code>merge_notin()</code>: returns logical in-existence of sorted set x in sorted set y, see
<code><a href="base.html#topic+match">!(x %in% y)</a></code>
</p>
</li>
<li> <p><code>merge_duplicated()</code>: returns the duplicated status of a sorted set x, see
<code><a href="base.html#topic+duplicated">duplicated()</a></code>
</p>
</li>
<li> <p><code>merge_anyDuplicated()</code>: returns the anyDuplicated status of a sorted set x, see
<code><a href="base.html#topic+anyDuplicated">anyDuplicated()</a></code>
</p>
</li>
<li> <p><code>merge_sumDuplicated()</code>: returns the sumDuplicated status of a sorted set x, see
<code><a href="#topic+bit_sumDuplicated">bit_sumDuplicated()</a></code>
</p>
</li>
<li> <p><code>merge_unique()</code>: returns unique elements of sorted set x, see <code><a href="base.html#topic+unique">unique()</a></code>
</p>
</li>
<li> <p><code>merge_union()</code>: returns union of two sorted sets.
Default <code>method='unique'</code> returns a unique sorted set, see <code><a href="base.html#topic+union">union()</a></code>;
<code>method='exact'</code> returns a sorted set with the maximum number of ties in either
input set; <code>method='all'</code> returns a sorted set with the sum of ties in both input
sets.
</p>
</li>
<li> <p><code>merge_setdiff()</code>: returns sorted set x minus sorted set y
Default <code>method='unique'</code> returns a unique sorted set, see <code><a href="base.html#topic+setdiff">setdiff()</a></code>;
<code>ethod='exact'</code> returns a sorted set with sum(x ties) minus sum(y ties);
</p>
</li>
<li> <p><code>merge_symdiff()</code>: returns those elements that are in sorted set <code>y</code> <code><a href="#topic+xor">xor()</a></code> in
sorted set <code>y</code>
Default <code>method='unique'</code> returns the sorted unique set complement, see <code><a href="#topic+symdiff">symdiff()</a></code>;
<code>method='exact'</code> returns a sorted set set complement with
<code style="white-space: pre;">&#8288;abs(sum(x ties) - sum(y ties))&#8288;</code>.
</p>
</li>
<li> <p><code>merge_intersect()</code>: returns the intersection of two sorted sets x and y
Default <code>method='unique'</code> returns the sorted unique intersect, see <code><a href="base.html#topic+intersect">intersect()</a></code>;
<code>method='exact'</code> returns the intersect with the minium number of ties in either set;
</p>
</li>
<li> <p><code>merge_setequal()</code>: returns <code>TRUE</code> for equal sorted sets and <code>FALSE</code> otherwise
Default <code>method='unique'</code> compares the sets after removing ties, see <code><a href="base.html#topic+setequal">setequal()</a></code>;
<code>method='exact'</code> compares the sets without removing ties;
</p>
</li>
<li> <p><code>merge_rangein()</code>: returns logical existence of range rx in sorted set y, see
<code><a href="#topic+merge_in">merge_in()</a></code>
</p>
</li>
<li> <p><code>merge_rangenotin()</code>: returns logical in-existence of range rx in sorted set y, see
<code><a href="#topic+merge_notin">merge_notin()</a></code>
</p>
</li>
<li> <p><code>merge_rangesect()</code>: returns the intersection of range rx and sorted set y, see
<code><a href="#topic+merge_intersect">merge_intersect()</a></code>
</p>
</li>
<li> <p><code>merge_rangediff()</code>: returns range rx minus sorted set y, see <code><a href="#topic+merge_setdiff">merge_setdiff()</a></code>
</p>
</li>
<li> <p><code>merge_first()</code>: quickly returns the first element of a sorted set x (or <code>NA</code> if
x is empty), hence <code>x[1]</code> or <code>merge_rev(x)[1]</code>
</p>
</li>
<li> <p><code>merge_last()</code>: quickly returns the last element of a sorted set x, (or <code>NA</code> if
x is empty), hence <code>x[n]</code> or <code>merge_rev(x)[n]</code>
</p>
</li>
<li> <p><code>merge_firstin()</code>: quickly returns the first common element of a range rx and a
sorted set y, (or <code>NA</code> if the intersection is empty), hence
<code>merge_first(merge_rangesect(rx, y))</code>
</p>
</li>
<li> <p><code>merge_lastin()</code>: quickly returns the last common element of a range rx and a
sorted set y, (or <code>NA</code> if the intersection is empty), hence
<code>merge_last(merge_rangesect(rx, y))</code>
</p>
</li>
<li> <p><code>merge_firstnotin()</code>: quickly returns the first element of a range rx which is not in a
sorted set y (or <code>NA</code> if all rx are in y), hence <code>merge_first(merge_rangediff(rx, y))</code>
</p>
</li>
<li> <p><code>merge_lastnotin()</code>: quickly returns the last element of a range rx which is not in a
sorted set y (or <code>NA</code> if all rx are in y), hence <code>merge_last(merge_rangediff(rx, y))</code>
</p>
</li></ul>


<h3>Note</h3>

<p>xx OPTIMIZATION OPPORTUNITY These are low-level functions could be optimized with
initial binary search (not findInterval, which coerces to double).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>merge_rev(1:9)

merge_match(1:7, 3:9)
#' merge_match(merge_rev(1:7), 3:9)
merge_match(merge_rev(1:7), 3:9, revx=TRUE)
merge_match(merge_rev(1:7), 3:9, revy=TRUE)
merge_match(merge_rev(1:7), merge_rev(3:9))

merge_in(1:7, 3:9)
merge_notin(1:7, 3:9)

merge_anyDuplicated(c(1L, 1L, 2L, 3L))
merge_duplicated(c(1L, 1L, 2L, 3L))
merge_unique(c(1L, 1L, 2L, 3L))

merge_union(c(1L, 2L, 2L, 2L), c(2L, 2L, 3L))
merge_union(c(1L, 2L, 2L, 2L), c(2L, 2L, 3L), method="exact")
merge_union(c(1L, 2L, 2L, 2L), c(2L, 2L, 3L), method="all")

merge_setdiff(c(1L, 2L, 2L, 2L), c(2L, 2L, 3L))
merge_setdiff(c(1L, 2L, 2L, 2L), c(2L, 2L, 3L), method="exact")
merge_setdiff(c(1L, 2L, 2L), c(2L, 2L, 2L, 3L), method="exact")

merge_symdiff(c(1L, 2L, 2L, 2L), c(2L, 2L, 3L))
merge_symdiff(c(1L, 2L, 2L, 2L), c(2L, 2L, 3L), method="exact")
merge_symdiff(c(1L, 2L, 2L), c(2L, 2L, 2L, 3L), method="exact")

merge_intersect(c(1L, 2L, 2L, 2L), c(2L, 2L, 3L))
merge_intersect(c(1L, 2L, 2L, 2L), c(2L, 2L, 3L), method="exact")

merge_setequal(c(1L, 2L, 2L), c(1L, 2L))
merge_setequal(c(1L, 2L, 2L), c(1L, 2L, 2L))
merge_setequal(c(1L, 2L, 2L), c(1L, 2L), method="exact")
merge_setequal(c(1L, 2L, 2L), c(1L, 2L, 2L), method="exact")

</code></pre>

<hr>
<h2 id='Metadata'>Generics related to cache access</h2><span id='topic+Metadata'></span><span id='topic+is.sorted'></span><span id='topic+is.sorted+3C-'></span><span id='topic+na.count'></span><span id='topic+na.count+3C-'></span><span id='topic+nvalid'></span><span id='topic+nunique'></span><span id='topic+nunique+3C-'></span><span id='topic+nties'></span><span id='topic+nties+3C-'></span>

<h3>Description</h3>

<p>These generics are packaged here for methods in packages <code>bit64</code> and
<code>ff</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is.sorted(x, ...)

is.sorted(x, ...) &lt;- value

na.count(x, ...)

na.count(x, ...) &lt;- value

nvalid(x, ...)

nunique(x, ...)

nunique(x, ...) &lt;- value

nties(x, ...)

nties(x, ...) &lt;- value
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="Metadata_+3A_x">x</code></td>
<td>
<p>some object</p>
</td></tr>
<tr><td><code id="Metadata_+3A_...">...</code></td>
<td>
<p>ignored</p>
</td></tr>
<tr><td><code id="Metadata_+3A_value">value</code></td>
<td>
<p>value assigned on responsibility of the user</p>
</td></tr>
</table>


<h3>Details</h3>

<p>see help of the available methods
</p>


<h3>Value</h3>

<p>see help of the available methods
</p>


<h3>Author(s)</h3>

<p>Jens Oehlschlägel <a href="mailto:Jens.Oehlschlaegel@truecluster.com">Jens.Oehlschlaegel@truecluster.com</a>
</p>


<h3>See Also</h3>

<p><code><a href="bit64.html#topic+is.sorted.integer64">bit64::is.sorted.integer64()</a></code>, <code><a href="bit64.html#topic+is.sorted.integer64">bit64::na.count.integer64()</a></code>,
<code><a href="bit64.html#topic+is.sorted.integer64">bit64::nvalid.integer64()</a></code>, <code><a href="bit64.html#topic+is.sorted.integer64">bit64::nunique.integer64()</a></code>, <code><a href="bit64.html#topic+is.sorted.integer64">bit64::nties.integer64()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  methods("na.count")
</code></pre>

<hr>
<h2 id='physical.default'>Physical and virtual attributes</h2><span id='topic+physical.default'></span><span id='topic+physical+3C-.default'></span><span id='topic+virtual.default'></span><span id='topic+virtual+3C-.default'></span><span id='topic+print.physical'></span><span id='topic+print.virtual'></span><span id='topic+PhysVirt'></span><span id='topic+physical'></span><span id='topic+physical+3C-'></span><span id='topic+virtual'></span><span id='topic+virtual+3C-'></span>

<h3>Description</h3>

<p>Compatibility functions (to package ff) for getting and setting physical and
virtual attributes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## Default S3 method:
physical(x)

## Default S3 replacement method:
physical(x) &lt;- value

## Default S3 method:
virtual(x)

## Default S3 replacement method:
virtual(x) &lt;- value

## S3 method for class 'physical'
print(x, ...)

## S3 method for class 'virtual'
print(x, ...)

physical(x)

physical(x) &lt;- value

virtual(x)

virtual(x) &lt;- value
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="physical.default_+3A_x">x</code></td>
<td>
<p>a ff or ram object</p>
</td></tr>
<tr><td><code id="physical.default_+3A_value">value</code></td>
<td>
<p>a list with named elements</p>
</td></tr>
<tr><td><code id="physical.default_+3A_...">...</code></td>
<td>
<p>further arguments</p>
</td></tr>
</table>


<h3>Details</h3>

<p>ff objects have physical and virtual attributes, which have different
copying semantics: physical attributes are shared between copies of ff
objects while virtual attributes might differ between copies.
<code><a href="ff.html#topic+as.ff">ff::as.ram()</a></code> will retain some physical and virtual atrributes in
the ram clone, such that <code><a href="ff.html#topic+as.ff">ff::as.ff()</a></code> can restore an ff object
with the same attributes.
</p>


<h3>Value</h3>

<p><code>physical</code> and <code>virtual</code> returns a list with named elements
</p>


<h3>Author(s)</h3>

<p>Jens Oehlschlägel
</p>


<h3>See Also</h3>

<p><code><a href="ff.html#topic+physical.ff">ff::physical.ff()</a></code>, <code><a href="ff.html#topic+physical.ffdf">ff::physical.ffdf()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
  physical(bit(12))
  virtual(bit(12))
</code></pre>

<hr>
<h2 id='print.bit'>Print method for bit</h2><span id='topic+print.bit'></span>

<h3>Description</h3>

<p>Print method for bit
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'bit'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="print.bit_+3A_x">x</code></td>
<td>
<p>a bit vector</p>
</td></tr>
<tr><td><code id="print.bit_+3A_...">...</code></td>
<td>
<p>passed to print</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a character vector showing first and last elements of the bit vector
</p>


<h3>Examples</h3>

<pre><code class='language-R'>print(bit(120))
</code></pre>

<hr>
<h2 id='print.bitwhich'>Print method for bitwhich</h2><span id='topic+print.bitwhich'></span>

<h3>Description</h3>

<p>Print method for bitwhich
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'bitwhich'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="print.bitwhich_+3A_x">x</code></td>
<td>
<p>a <code><a href="#topic+bitwhich">bitwhich()</a></code> object</p>
</td></tr>
<tr><td><code id="print.bitwhich_+3A_...">...</code></td>
<td>
<p>ignored</p>
</td></tr>
</table>

<hr>
<h2 id='quicksort2'>Low-level sorting: binary quicksort</h2><span id='topic+quicksort2'></span>

<h3>Description</h3>

<p>In one pass over the vector <code>NA</code>s are handled according to parameter
<code>na.last</code> by <code><a href="#topic+range_sortna">range_sortna()</a></code>, then, if the vector is unsorted,
binary quicksort is invoked.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>quicksort2(x, na.last = NA)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="quicksort2_+3A_x">x</code></td>
<td>
<p>an integer vector</p>
</td></tr>
<tr><td><code id="quicksort2_+3A_na.last">na.last</code></td>
<td>
<p><code>NA</code> removes NAs, <code>FALSE</code> puts NAs at the beginning,
<code>TRUE</code> puts NAs at the end</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a sorted vector
</p>


<h3>Examples</h3>

<pre><code class='language-R'>quicksort2(c(2L, 0L, 1L, NA, 2L))
quicksort2(c(2L, 0L, 1L, NA, 2L), na.last=TRUE)
quicksort2(c(2L, 0L, 1L, NA, 2L), na.last=FALSE)
</code></pre>

<hr>
<h2 id='quicksort3'>Low-level sorting: threeway quicksort</h2><span id='topic+quicksort3'></span>

<h3>Description</h3>

<p>In one pass over the vector <code>NA</code>s are handled according to parameter
<code>na.last</code> by <code><a href="#topic+range_sortna">range_sortna()</a></code>, then, if the vector is unsorted,
threeway quicksort is invoked.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>quicksort3(x, na.last = NA)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="quicksort3_+3A_x">x</code></td>
<td>
<p>an integer vector</p>
</td></tr>
<tr><td><code id="quicksort3_+3A_na.last">na.last</code></td>
<td>
<p><code>NA</code> removes NAs, <code>FALSE</code> puts NAs at the beginning,
<code>TRUE</code> puts NAs at the end</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a sorted vector
</p>


<h3>Examples</h3>

<pre><code class='language-R'>countsort(c(2L, 0L, 1L, NA, 2L))
countsort(c(2L, 0L, 1L, NA, 2L), na.last=TRUE)
countsort(c(2L, 0L, 1L, NA, 2L), na.last=FALSE)
</code></pre>

<hr>
<h2 id='range_na'>Get range and number of NAs</h2><span id='topic+range_na'></span>

<h3>Description</h3>

<p>Get range and number of NAs
</p>


<h3>Usage</h3>

<pre><code class='language-R'>range_na(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="range_na_+3A_x">x</code></td>
<td>
<p>an integer vector</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an integer vector with three elements:
</p>

<ol>
<li><p> min integer
</p>
</li>
<li><p> max integer
</p>
</li>
<li><p> number of NAs
</p>
</li></ol>



<h3>See Also</h3>

<p><code><a href="#topic+range_nanozero">range_nanozero()</a></code> and <code><a href="#topic+range_sortna">range_sortna()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>range_na(c(0L, 1L, 2L, NA))
</code></pre>

<hr>
<h2 id='range_nanozero'>Remove zeros and get range and number of NAs</h2><span id='topic+range_nanozero'></span>

<h3>Description</h3>

<p>Remove zeros and get range and number of NAs
</p>


<h3>Usage</h3>

<pre><code class='language-R'>range_nanozero(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="range_nanozero_+3A_x">x</code></td>
<td>
<p>an integer vector</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an integer vector without zeros and with an attribute <code><a href="#topic+range_na">range_na()</a></code>  with three
elements:
</p>

<ol>
<li><p> min integer
</p>
</li>
<li><p> max integer
</p>
</li>
<li><p> number of NAs
</p>
</li></ol>



<h3>See Also</h3>

<p><code><a href="#topic+range_na">range_na()</a></code> and <code><a href="#topic+range_sortna">range_sortna()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>range_nanozero(c(0L, 1L, 2L, NA))
</code></pre>

<hr>
<h2 id='range_sortna'>Prepare for sorting and get range, number of NAs and unsortedness</h2><span id='topic+range_sortna'></span>

<h3>Description</h3>

<p>In one pass over the vector <code>NA</code>s are treated according to parameter
<code>na.last</code> exactly like <code><a href="base.html#topic+sort">sort()</a></code> does, the <code><a href="base.html#topic+range">range()</a></code>,
number of <code>NA</code>s and unsortedness is determined.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>range_sortna(x, decreasing = FALSE, na.last = NA)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="range_sortna_+3A_x">x</code></td>
<td>
<p>an integer vector</p>
</td></tr>
<tr><td><code id="range_sortna_+3A_decreasing">decreasing</code></td>
<td>
<p>(currently only <code>FALSE</code> is supported)</p>
</td></tr>
<tr><td><code id="range_sortna_+3A_na.last">na.last</code></td>
<td>
<p><code>NA</code> removes NAs, <code>FALSE</code> puts NAs at the beginning,
<code>TRUE</code> puts NAs at the end</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an integer vector with <code>NA</code>s are treated and an <code>attribute</code> <code><a href="#topic+range_na">range_na()</a></code>  with
four elements:
</p>

<ol>
<li><p> min integer
</p>
</li>
<li><p> max integer
</p>
</li>
<li><p> number of NAs
</p>
</li>
<li><p> 0 for sorted vector and 1 for <code><a href="base.html#topic+is.unsorted">is.unsorted()</a></code>
</p>
</li></ol>



<h3>See Also</h3>

<p><code><a href="#topic+range_na">range_na()</a></code> and <code><a href="#topic+range_nanozero">range_nanozero()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>range_sortna(c(0L, 1L, NA, 2L))
range_sortna(c(2L, NA, 1L, 0L))
range_sortna(c(0L, 1L, NA, 2L), na.last=TRUE)
range_sortna(c(2L, NA, 1L, 0L), na.last=TRUE)
range_sortna(c(0L, 1L, NA, 2L), na.last=FALSE)
range_sortna(c(2L, NA, 1L, 0L), na.last=FALSE)
</code></pre>

<hr>
<h2 id='rep.booltype'>Replicating bit and bitwhich vectors</h2><span id='topic+rep.booltype'></span><span id='topic+rep.bit'></span><span id='topic+rep.bitwhich'></span>

<h3>Description</h3>

<p>Creating new bit or bitwhich by recycling such vectors
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'bit'
rep(x, times = 1L, length.out = NA, ...)

## S3 method for class 'bitwhich'
rep(x, times = 1L, length.out = NA, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="rep.booltype_+3A_x">x</code></td>
<td>
<p>bit or bitwhich object</p>
</td></tr>
<tr><td><code id="rep.booltype_+3A_times">times</code></td>
<td>
<p>number of replications</p>
</td></tr>
<tr><td><code id="rep.booltype_+3A_length.out">length.out</code></td>
<td>
<p>final length of replicated vector (dominates times)</p>
</td></tr>
<tr><td><code id="rep.booltype_+3A_...">...</code></td>
<td>
<p>not used</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class 'bit' or 'bitwhich'
</p>


<h3>Author(s)</h3>

<p>Jens Oehlschlägel
</p>


<h3>See Also</h3>

<p><code><a href="base.html#topic+rep">rep()</a></code>, <code><a href="#topic+bit">bit()</a></code> , <code><a href="#topic+bitwhich">bitwhich()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
 rep(as.bit(c(FALSE, TRUE)), 2)
 rep(as.bit(c(FALSE, TRUE)), length.out=7)
 rep(as.bitwhich(c(FALSE, TRUE)), 2)
 rep(as.bitwhich(c(FALSE, TRUE)), length.out=1)
</code></pre>

<hr>
<h2 id='repeat.time'>Adaptive timer</h2><span id='topic+repeat.time'></span>

<h3>Description</h3>

<p>Repeats timing expr until minSec is reached
</p>


<h3>Usage</h3>

<pre><code class='language-R'>repeat.time(expr, gcFirst = TRUE, minSec = 0.5, envir = parent.frame())
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="repeat.time_+3A_expr">expr</code></td>
<td>
<p>Valid expression to be timed.</p>
</td></tr>
<tr><td><code id="repeat.time_+3A_gcfirst">gcFirst</code></td>
<td>
<p>Logical - should a garbage collection be performed
immediately before the timing?  Default is <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="repeat.time_+3A_minsec">minSec</code></td>
<td>
<p>number of seconds to repeat at least</p>
</td></tr>
<tr><td><code id="repeat.time_+3A_envir">envir</code></td>
<td>
<p>the environment in which to evaluate <code>expr</code> (by default
the calling frame)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A object of class <code>"proc_time"</code>: see <code><a href="base.html#topic+proc.time">proc.time()</a></code>
for details.
</p>


<h3>Author(s)</h3>

<p>Jens Oehlschlägel <a href="mailto:Jens.Oehlschlaegel@truecluster.com">Jens.Oehlschlaegel@truecluster.com</a>
</p>


<h3>See Also</h3>

<p><code><a href="base.html#topic+system.time">system.time()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
  system.time(1 + 1)
  repeat.time(1 + 1)
  system.time(sort(runif(1e6)))
  repeat.time(sort(runif(1e6)))

</code></pre>

<hr>
<h2 id='repfromto'>Virtual recycling</h2><span id='topic+repfromto'></span><span id='topic+repfromto+3C-'></span>

<h3>Description</h3>

<p><code>repfromto</code> virtually recylcles object <code>x</code> and cuts out
positions <code style="white-space: pre;">&#8288;from .. to&#8288;</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>repfromto(x, from, to)

repfromto(x, from, to) &lt;- value
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="repfromto_+3A_x">x</code></td>
<td>
<p>an object from which to recycle</p>
</td></tr>
<tr><td><code id="repfromto_+3A_from">from</code></td>
<td>
<p>first position to return</p>
</td></tr>
<tr><td><code id="repfromto_+3A_to">to</code></td>
<td>
<p>last position to return</p>
</td></tr>
<tr><td><code id="repfromto_+3A_value">value</code></td>
<td>
<p>value to assign</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>repfromto</code> is a generalization of <code><a href="base.html#topic+rep">rep()</a></code>, where
<code>rep(x, n) == repfromto(x, 1, n)</code>.  You can see this as an R-side
(vector) solution of the <code>mod_iterate</code> macro in arithmetic.c
</p>


<h3>Value</h3>

<p>a vector of length <code>from - to + 1</code>
</p>


<h3>Author(s)</h3>

<p>Jens Oehlschlägel
</p>


<h3>See Also</h3>

<p><code><a href="base.html#topic+rep">rep()</a></code>, <code><a href="ff.html#topic+ffapply">ff::ffvecapply()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
  message("a simple example")
  repfromto(0:9, 11, 20)

</code></pre>

<hr>
<h2 id='rev.booltype'>Reversing bit and bitwhich vectors</h2><span id='topic+rev.booltype'></span><span id='topic+rev.bit'></span><span id='topic+rev.bitwhich'></span>

<h3>Description</h3>

<p>Creating new bit or bitwhich by reversing such vectors
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'bit'
rev(x)

## S3 method for class 'bitwhich'
rev(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="rev.booltype_+3A_x">x</code></td>
<td>
<p>bit or bitwhich object</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class 'bit' or 'bitwhich'
</p>


<h3>Author(s)</h3>

<p>Jens Oehlschlägel
</p>


<h3>See Also</h3>

<p><code><a href="base.html#topic+rev">rev()</a></code>, <code><a href="#topic+bit">bit()</a></code> , <code><a href="#topic+bitwhich">bitwhich()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
 rev(as.bit(c(FALSE, TRUE)))
 rev(as.bitwhich(c(FALSE, TRUE)))
</code></pre>

<hr>
<h2 id='reverse_vector'>Reverse atomic vector</h2><span id='topic+reverse_vector'></span>

<h3>Description</h3>

<p>Returns a reversed copy &ndash; with attributes retained.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>reverse_vector(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="reverse_vector_+3A_x">x</code></td>
<td>
<p>an R vector</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This is substantially faster than <code><a href="base.html#topic+rev">rev()</a></code>
</p>


<h3>Value</h3>

<p>a reversed vector
</p>


<h3>See Also</h3>

<p><code><a href="base.html#topic+rev">rev()</a></code>, <code><a href="#topic+copy_vector">copy_vector()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- factor(letters)
rev(x)
reverse_vector(x)
## Not run: 
x &lt;- 1:1e7
system.time(rev(x))
system.time(reverse_vector(x))

## End(Not run)
</code></pre>

<hr>
<h2 id='ri'>Range index</h2><span id='topic+ri'></span><span id='topic+print.ri'></span>

<h3>Description</h3>

<p>A range index can be used to extract or replace a continuous ascending part
of the data
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ri(from, to = NULL, maxindex = NA)

## S3 method for class 'ri'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ri_+3A_from">from</code></td>
<td>
<p>first position</p>
</td></tr>
<tr><td><code id="ri_+3A_to">to</code></td>
<td>
<p>last posistion</p>
</td></tr>
<tr><td><code id="ri_+3A_maxindex">maxindex</code></td>
<td>
<p>the maximal length of the object-to-be-subscripted (if
known)</p>
</td></tr>
<tr><td><code id="ri_+3A_x">x</code></td>
<td>
<p>an object of class 'ri'</p>
</td></tr>
<tr><td><code id="ri_+3A_...">...</code></td>
<td>
<p>further arguments</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A two element integer vector with class 'ri'
</p>


<h3>Author(s)</h3>

<p>Jens Oehlschlägel
</p>


<h3>See Also</h3>

<p><code><a href="ff.html#topic+as.hi">ff::as.hi()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
 bit(12)[ri(1, 6)]

</code></pre>

<hr>
<h2 id='rlepack'>Hybrid Index, rle-pack utilities</h2><span id='topic+rlepack'></span><span id='topic+rlepack.integer'></span><span id='topic+rleunpack'></span><span id='topic+rleunpack.rlepack'></span><span id='topic+rev.rlepack'></span><span id='topic+unique.rlepack'></span><span id='topic+anyDuplicated.rlepack'></span>

<h3>Description</h3>

<p>Basic utilities for rle packing and unpacking and apropriate methods for
<code><a href="base.html#topic+rev">rev()</a></code> and <code><a href="base.html#topic+unique">unique()</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rlepack(x, ...)

## S3 method for class 'integer'
rlepack(x, pack = TRUE, ...)

rleunpack(x)

## S3 method for class 'rlepack'
rleunpack(x)

## S3 method for class 'rlepack'
rev(x)

## S3 method for class 'rlepack'
unique(x, incomparables = FALSE, ...)

## S3 method for class 'rlepack'
anyDuplicated(x, incomparables = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="rlepack_+3A_x">x</code></td>
<td>
<p>in 'rlepack' an integer vector, in the other functions an object of
class 'rlepack'</p>
</td></tr>
<tr><td><code id="rlepack_+3A_...">...</code></td>
<td>
<p>just to keep R CMD CHECK quiet (not used)</p>
</td></tr>
<tr><td><code id="rlepack_+3A_pack">pack</code></td>
<td>
<p>FALSE to suppress packing</p>
</td></tr>
<tr><td><code id="rlepack_+3A_incomparables">incomparables</code></td>
<td>
<p>just to keep R CMD CHECK quiet (not used)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with components:
</p>

<ul>
<li><p> first: the first element of the packed sequence
</p>
</li>
<li><p> dat: either an object of class <code><a href="base.html#topic+rle">rle()</a></code> or the complete input vector <code>x</code> if
rle-packing is not efficient
</p>
</li>
<li><p> last: the last element of the packed sequence
</p>
</li></ul>



<h3>Author(s)</h3>

<p>Jens Oehlschlägel
</p>


<h3>See Also</h3>

<p><code><a href="ff.html#topic+hi">ff::hi()</a></code>, <code><a href="#topic+intrle">intrle()</a></code>, <code><a href="base.html#topic+rle">rle()</a></code>, <code><a href="base.html#topic+rev">rev()</a></code>, <code><a href="base.html#topic+unique">unique()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
  x &lt;- rlepack(rep(0L, 10))

</code></pre>

<hr>
<h2 id='Sorting'>Generics for in-RAM sorting and ordering</h2><span id='topic+Sorting'></span><span id='topic+ramsort'></span><span id='topic+ramorder'></span><span id='topic+ramsortorder'></span><span id='topic+mergesort'></span><span id='topic+mergeorder'></span><span id='topic+mergesortorder'></span><span id='topic+quicksort'></span><span id='topic+quickorder'></span><span id='topic+quicksortorder'></span><span id='topic+shellsort'></span><span id='topic+shellorder'></span><span id='topic+shellsortorder'></span><span id='topic+radixsort'></span><span id='topic+radixorder'></span><span id='topic+radixsortorder'></span><span id='topic+keysort'></span><span id='topic+keyorder'></span><span id='topic+keysortorder'></span>

<h3>Description</h3>

<p>These are generic stubs for low-level sorting and ordering methods
implemented in packages 'bit64' and 'ff'.  The <code>..sortorder</code> methods do
sorting and ordering at once, which requires more RAM than ordering but is
(almost) as fast as as sorting.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ramsort(x, ...)

ramorder(x, i, ...)

ramsortorder(x, i, ...)

mergesort(x, ...)

mergeorder(x, i, ...)

mergesortorder(x, i, ...)

quicksort(x, ...)

quickorder(x, i, ...)

quicksortorder(x, i, ...)

shellsort(x, ...)

shellorder(x, i, ...)

shellsortorder(x, i, ...)

radixsort(x, ...)

radixorder(x, i, ...)

radixsortorder(x, i, ...)

keysort(x, ...)

keyorder(x, i, ...)

keysortorder(x, i, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="Sorting_+3A_x">x</code></td>
<td>
<p>a vector to be sorted by <code><a href="#topic+ramsort">ramsort()</a></code> and
<code><a href="#topic+ramsortorder">ramsortorder()</a></code>, i.e. the output of <code><a href="base.html#topic+sort">sort()</a></code></p>
</td></tr>
<tr><td><code id="Sorting_+3A_...">...</code></td>
<td>
<p>further arguments to the sorting methods</p>
</td></tr>
<tr><td><code id="Sorting_+3A_i">i</code></td>
<td>
<p>integer positions to be modified by <code><a href="#topic+ramorder">ramorder()</a></code> and
<code><a href="#topic+ramsortorder">ramsortorder()</a></code>, default is 1:n, in this case the output is
similar to <code><a href="base.html#topic+order">order()</a></code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>sort</code> generics do sort their argument 'x', some methods need
temporary RAM of the same size as 'x'.  The <code>order</code> generics do order
their argument 'i' leaving 'x' as it was, some methods need temporary RAM of
the same size as 'i'.  The <code>sortorder</code> generics do sort their argument
'x' and order their argument 'i', this way of ordering is much faster at the
price of requiring temporary RAM for both, 'x' and 'i', if the method
requires temporary RAM.  The <code>ram</code> generics are high-level functions
containing an optimizer that chooses the 'best' algorithms given some
context.
</p>


<h3>Value</h3>

<p>These functions return the number of <code>NAs</code> found or assumed
during sorting
</p>


<h3>Index of implemented methods</h3>


<table>
<tr>
 <td style="text-align: right;">
   <strong>generic</strong> </td><td style="text-align: right;"> <strong>ff</strong> </td><td style="text-align: left;"> <strong>bit64</strong> </td>
</tr>
<tr>
 <td style="text-align: right;">
   <code>ramsort</code> </td><td style="text-align: right;"> <code><a href="ff.html#topic+ramsort.default">ff::ramsort.default()</a></code> </td><td style="text-align: left;"> <code><a href="bit64.html#topic+ramsort.integer64">bit64::ramsort.integer64()</a></code> </td>
</tr>
<tr>
 <td style="text-align: right;">
   <code>shellsort</code> </td><td style="text-align: right;"> <code><a href="ff.html#topic+ramsort.default">ff::shellsort.default()</a></code> </td><td style="text-align: left;"> <code><a href="bit64.html#topic+ramsort.integer64">bit64::shellsort.integer64()</a></code> </td>
</tr>
<tr>
 <td style="text-align: right;">
   <code>quicksort</code> </td><td style="text-align: right;">  </td><td style="text-align: left;"> <code><a href="bit64.html#topic+ramsort.integer64">bit64::quicksort.integer64()</a></code> </td>
</tr>
<tr>
 <td style="text-align: right;">
   <code>mergesort</code> </td><td style="text-align: right;"> <code><a href="ff.html#topic+ramsort.default">ff::mergesort.default()</a></code> </td><td style="text-align: left;"> <code><a href="bit64.html#topic+ramsort.integer64">bit64::mergesort.integer64()</a></code> </td>
</tr>
<tr>
 <td style="text-align: right;">
   <code>radixsort</code> </td><td style="text-align: right;"> <code><a href="ff.html#topic+ramsort.default">ff::radixsort.default()</a></code> </td><td style="text-align: left;"> <code><a href="bit64.html#topic+ramsort.integer64">bit64::radixsort.integer64()</a></code> </td>
</tr>
<tr>
 <td style="text-align: right;">
   <code>keysort</code> </td><td style="text-align: right;"> <code><a href="ff.html#topic+ramsort.default">ff::keysort.default()</a></code> </td><td style="text-align: left;">  </td>
</tr>
<tr>
 <td style="text-align: right;">
   <code>ramorder</code> </td><td style="text-align: right;"> <code><a href="ff.html#topic+ramorder.default">ff::ramorder.default()</a></code> </td><td style="text-align: left;"> <code><a href="bit64.html#topic+ramsort.integer64">bit64::ramorder.integer64()</a></code> </td>
</tr>
<tr>
 <td style="text-align: right;">
   <code>shellorder</code> </td><td style="text-align: right;"> <code><a href="ff.html#topic+ramorder.default">ff::shellorder.default()</a></code> </td><td style="text-align: left;"> <code><a href="bit64.html#topic+ramsort.integer64">bit64::shellorder.integer64()</a></code> </td>
</tr>
<tr>
 <td style="text-align: right;">
   <code>quickorder</code> </td><td style="text-align: right;">  </td><td style="text-align: left;"> <code><a href="bit64.html#topic+ramsort.integer64">bit64::quickorder.integer64()</a></code> </td>
</tr>
<tr>
 <td style="text-align: right;">
   <code>mergeorder</code> </td><td style="text-align: right;"> <code><a href="ff.html#topic+ramorder.default">ff::mergeorder.default()</a></code> </td><td style="text-align: left;"> <code><a href="bit64.html#topic+ramsort.integer64">bit64::mergeorder.integer64()</a></code> </td>
</tr>
<tr>
 <td style="text-align: right;">
   <code>radixorder</code> </td><td style="text-align: right;"> <code><a href="ff.html#topic+ramorder.default">ff::radixorder.default()</a></code> </td><td style="text-align: left;"> <code><a href="bit64.html#topic+ramsort.integer64">bit64::radixorder.integer64()</a></code> </td>
</tr>
<tr>
 <td style="text-align: right;">
   <code>keyorder</code> </td><td style="text-align: right;"> <code><a href="ff.html#topic+ramorder.default">ff::keyorder.default()</a></code> </td><td style="text-align: left;">  </td>
</tr>
<tr>
 <td style="text-align: right;">
   <code>ramsortorder</code> </td><td style="text-align: right;">  </td><td style="text-align: left;"> <code><a href="bit64.html#topic+ramsort.integer64">bit64::ramsortorder.integer64()</a></code> </td>
</tr>
<tr>
 <td style="text-align: right;">
   <code>shellsortorder</code> </td><td style="text-align: right;">  </td><td style="text-align: left;"> <code><a href="bit64.html#topic+ramsort.integer64">bit64::shellsortorder.integer64()</a></code> </td>
</tr>
<tr>
 <td style="text-align: right;">
   <code>quicksortorder</code> </td><td style="text-align: right;">  </td><td style="text-align: left;"> <code><a href="bit64.html#topic+ramsort.integer64">bit64::quicksortorder.integer64()</a></code> </td>
</tr>
<tr>
 <td style="text-align: right;">
   <code>mergesortorder</code> </td><td style="text-align: right;">  </td><td style="text-align: left;"> <code><a href="bit64.html#topic+ramsort.integer64">bit64::mergesortorder.integer64()</a></code> </td>
</tr>
<tr>
 <td style="text-align: right;">
   <code>radixsortorder</code> </td><td style="text-align: right;">  </td><td style="text-align: left;"> <code><a href="bit64.html#topic+ramsort.integer64">bit64::radixsortorder.integer64()</a></code> </td>
</tr>
<tr>
 <td style="text-align: right;">
   <code>keysortorder</code> </td><td style="text-align: right;">  </td><td style="text-align: left;">  </td>
</tr>
<tr>
 <td style="text-align: right;">
</td>
</tr>

</table>



<h3>Note</h3>

<p>Note that these methods purposely violate the functional programming
paradigm: they are called for the side-effect of changing some of their
arguments.  The rationale behind this is that sorting is very RAM-intensive
and in certain situations we might not want to allocate additional memory if
not necessary to do so.  The <code>sort</code>-methods change <code>x</code>, the
<code>order</code>-methods change <code>i</code>, and the <code>sortoder</code>-methods change
both <code>x</code> and <code>i</code> You as the user are responsible to create copies
of the input data 'x' and 'i' if you need non-modified versions.
</p>


<h3>Author(s)</h3>

<p>Jens Oehlschlägel <a href="mailto:Jens.Oehlschlaegel@truecluster.com">Jens.Oehlschlaegel@truecluster.com</a>
</p>


<h3>See Also</h3>

<p><code><a href="base.html#topic+sort">sort()</a></code> and <code><a href="base.html#topic+order">order()</a></code> in base R, <code><a href="#topic+bitsort">bitsort()</a></code> for faster inteer sorting
</p>

<hr>
<h2 id='still.identical'>Test for C-level identity of two atomic vectors</h2><span id='topic+still.identical'></span>

<h3>Description</h3>

<p>Test for C-level identity of two atomic vectors
</p>


<h3>Usage</h3>

<pre><code class='language-R'>still.identical(x, y)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="still.identical_+3A_x">x</code></td>
<td>
<p>an atomic vector</p>
</td></tr>
<tr><td><code id="still.identical_+3A_y">y</code></td>
<td>
<p>an atomic vector</p>
</td></tr>
</table>


<h3>Value</h3>

<p>logical scalar
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- 1:2
y &lt;- x
z &lt;- copy_vector(x)
still.identical(y, x)
still.identical(z, x)
</code></pre>

<hr>
<h2 id='str.bit'>Str method for bit</h2><span id='topic+str.bit'></span>

<h3>Description</h3>

<p>To actually view the internal structure use <code>str(unclass(bit))</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'bit'
str(
  object,
  vec.len = strO$vec.len,
  give.head = TRUE,
  give.length = give.head,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="str.bit_+3A_object">object</code></td>
<td>
<p>any <span class="rlang"><b>R</b></span> object about which you want to have some
information.</p>
</td></tr>
<tr><td><code id="str.bit_+3A_vec.len">vec.len</code></td>
<td>
<p>numeric (&gt;= 0) indicating how many &lsquo;first few&rsquo; elements
are displayed of each vector.  The number is multiplied by different
factors (from .5 to 3) depending on the kind of vector.  Defaults to
the <code>vec.len</code> component of option <code>"str"</code> (see
<code><a href="base.html#topic+options">options</a></code>) which defaults to 4.</p>
</td></tr>
<tr><td><code id="str.bit_+3A_give.head">give.head</code></td>
<td>
<p>logical; if <code>TRUE</code> (default), give (possibly
abbreviated) mode/class and length (as <code><var>type</var>[1:...]</code>).</p>
</td></tr>
<tr><td><code id="str.bit_+3A_give.length">give.length</code></td>
<td>
<p>logical; if <code>TRUE</code> (default), indicate
length (as <code>[1:...]</code>).</p>
</td></tr>
<tr><td><code id="str.bit_+3A_...">...</code></td>
<td>
<p>potential further arguments (required for Method/Generic
reasons).</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code><a href="base.html#topic+invisible">invisible()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>str(bit(120))
</code></pre>

<hr>
<h2 id='str.bitwhich'>Str method for bitwhich</h2><span id='topic+str.bitwhich'></span>

<h3>Description</h3>

<p>To actually view the internal structure use <code>str(unclass(bitwhich))</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'bitwhich'
str(
  object,
  vec.len = strO$vec.len,
  give.head = TRUE,
  give.length = give.head,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="str.bitwhich_+3A_object">object</code></td>
<td>
<p>any <span class="rlang"><b>R</b></span> object about which you want to have some
information.</p>
</td></tr>
<tr><td><code id="str.bitwhich_+3A_vec.len">vec.len</code></td>
<td>
<p>numeric (&gt;= 0) indicating how many &lsquo;first few&rsquo; elements
are displayed of each vector.  The number is multiplied by different
factors (from .5 to 3) depending on the kind of vector.  Defaults to
the <code>vec.len</code> component of option <code>"str"</code> (see
<code><a href="base.html#topic+options">options</a></code>) which defaults to 4.</p>
</td></tr>
<tr><td><code id="str.bitwhich_+3A_give.head">give.head</code></td>
<td>
<p>logical; if <code>TRUE</code> (default), give (possibly
abbreviated) mode/class and length (as <code><var>type</var>[1:...]</code>).</p>
</td></tr>
<tr><td><code id="str.bitwhich_+3A_give.length">give.length</code></td>
<td>
<p>logical; if <code>TRUE</code> (default), indicate
length (as <code>[1:...]</code>).</p>
</td></tr>
<tr><td><code id="str.bitwhich_+3A_...">...</code></td>
<td>
<p>potential further arguments (required for Method/Generic
reasons).</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code><a href="base.html#topic+invisible">invisible()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>str(bitwhich(120))
</code></pre>

<hr>
<h2 id='Summaries'>Summaries of boolean vectors</h2><span id='topic+Summaries'></span><span id='topic+all.bit'></span><span id='topic+any.bit'></span><span id='topic+anyNA.bit'></span><span id='topic+sum.bit'></span><span id='topic+min.bit'></span><span id='topic+max.bit'></span><span id='topic+range.bit'></span><span id='topic+summary.bit'></span><span id='topic+all.bitwhich'></span><span id='topic+any.bitwhich'></span><span id='topic+anyNA.bitwhich'></span><span id='topic+sum.bitwhich'></span><span id='topic+min.bitwhich'></span><span id='topic+max.bitwhich'></span><span id='topic+range.bitwhich'></span><span id='topic+summary.bitwhich'></span><span id='topic+all.which'></span><span id='topic+any.which'></span><span id='topic+anyNA.which'></span><span id='topic+sum.which'></span><span id='topic+min.which'></span><span id='topic+max.which'></span><span id='topic+range.which'></span><span id='topic+summary.which'></span><span id='topic+all.booltype'></span><span id='topic+any.booltype'></span><span id='topic+anyNA.booltype'></span><span id='topic+sum.booltype'></span><span id='topic+min.booltype'></span><span id='topic+max.booltype'></span><span id='topic+range.booltype'></span><span id='topic+summary.booltype'></span><span id='topic+all.ri'></span><span id='topic+any.ri'></span><span id='topic+anyNA.ri'></span><span id='topic+sum.ri'></span><span id='topic+min.ri'></span><span id='topic+max.ri'></span><span id='topic+range.ri'></span><span id='topic+summary.ri'></span>

<h3>Description</h3>

<p>Fast aggregation functions for <code><a href="#topic+booltype">booltype()</a></code> vectors. namely <code><a href="#topic+bit">bit()</a></code>, <code><a href="base.html#topic+all">all()</a></code>, <code><a href="base.html#topic+any">any()</a></code>,
<code><a href="base.html#topic+anyNA">anyNA()</a></code>, <code><a href="base.html#topic+min">min()</a></code>, <code><a href="base.html#topic+max">max()</a></code>, <code><a href="base.html#topic+range">range()</a></code>, <code><a href="base.html#topic+sum">sum()</a></code> and <code><a href="base.html#topic+summary">summary()</a></code>.
Now all boolean summaries (except for <code>anyNA</code> because the generic does not allow it)
have an optional <code>range</code> argument to restrict the range of evalution.
Note that the boolean summaries have meaning and return values differing from logical
aggregation functions: they treat <code>NA</code> as <code>FALSE</code>, <code>min</code>, <code>max</code> and <code>range</code> give the
minimum and maximum positions of <code>TRUE</code>, <code>summary</code> returns counts of <code>FALSE</code>,  <code>TRUE</code>
and the <code>range</code>.
Note that you can force the boolean interpretation by calling the booltype method
explicitly on any <code><a href="#topic+booltypes">booltypes</a></code> input, e.g. <code>min.booltype()</code>, see the
examples.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'bit'
all(x, range = NULL, ...)

## S3 method for class 'bit'
any(x, range = NULL, ...)

## S3 method for class 'bit'
anyNA(x, recursive = FALSE)

## S3 method for class 'bit'
sum(x, range = NULL, ...)

## S3 method for class 'bit'
min(x, range = NULL, ...)

## S3 method for class 'bit'
max(x, range = NULL, ...)

## S3 method for class 'bit'
range(x, range = NULL, ...)

## S3 method for class 'bit'
summary(object, range = NULL, ...)

## S3 method for class 'bitwhich'
all(x, range = NULL, ...)

## S3 method for class 'bitwhich'
any(x, range = NULL, ...)

## S3 method for class 'bitwhich'
anyNA(x, recursive = FALSE)

## S3 method for class 'bitwhich'
sum(x, range = NULL, ...)

## S3 method for class 'bitwhich'
min(x, range = NULL, ...)

## S3 method for class 'bitwhich'
max(x, range = NULL, ...)

## S3 method for class 'bitwhich'
range(x, range = NULL, ...)

## S3 method for class 'bitwhich'
summary(object, range = NULL, ...)

## S3 method for class 'which'
all(x, range = NULL, ...)

## S3 method for class 'which'
any(x, range = NULL, ...)

## S3 method for class 'which'
anyNA(x, recursive = FALSE)

## S3 method for class 'which'
sum(x, range = NULL, ...)

## S3 method for class 'which'
min(x, range = NULL, ...)

## S3 method for class 'which'
max(x, range = NULL, ...)

## S3 method for class 'which'
range(x, range = NULL, ...)

## S3 method for class 'which'
summary(object, range = NULL, ...)

## S3 method for class 'booltype'
all(x, range = NULL, ...)

## S3 method for class 'booltype'
any(x, range = NULL, ...)

## S3 method for class 'booltype'
anyNA(x, ...)

## S3 method for class 'booltype'
sum(x, range = NULL, ...)

## S3 method for class 'booltype'
min(x, range = NULL, ...)

## S3 method for class 'booltype'
max(x, range = NULL, ...)

## S3 method for class 'booltype'
range(x, range = NULL, ...)

## S3 method for class 'booltype'
summary(object, range = NULL, ...)

## S3 method for class 'ri'
all(x, range = NULL, ...)

## S3 method for class 'ri'
any(x, range = NULL, ...)

## S3 method for class 'ri'
anyNA(x, recursive = FALSE)

## S3 method for class 'ri'
sum(x, ...)

## S3 method for class 'ri'
min(x, ...)

## S3 method for class 'ri'
max(x, ...)

## S3 method for class 'ri'
range(x, ...)

## S3 method for class 'ri'
summary(object, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="Summaries_+3A_x">x</code></td>
<td>
<p>an object of class bit or bitwhich</p>
</td></tr>
<tr><td><code id="Summaries_+3A_range">range</code></td>
<td>
<p>a <code><a href="#topic+ri">ri()</a></code> or an integer vector of length == 2 giving a
range restriction for chunked processing</p>
</td></tr>
<tr><td><code id="Summaries_+3A_...">...</code></td>
<td>
<p>formally required but not used</p>
</td></tr>
<tr><td><code id="Summaries_+3A_recursive">recursive</code></td>
<td>
<p>formally required but not used</p>
</td></tr>
<tr><td><code id="Summaries_+3A_object">object</code></td>
<td>
<p>an object of class bit</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Summaries of <code><a href="#topic+bit">bit()</a></code> vectors are quite fast because we use a double loop that fixes
each word in a processor register.  Furthermore we break out of looping as soon
as possible. Summaries of <code><a href="#topic+bitwhich">bitwhich()</a></code> vectors are even faster, if the selection is
very skewed.
</p>


<h3>Value</h3>

<p>as expected
</p>


<h3>Author(s)</h3>

<p>Jens Oehlschlägel
</p>


<h3>See Also</h3>

<p><code><a href="base.html#topic+length">length()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
  l &lt;- c(NA, FALSE, TRUE)
  b &lt;- as.bit(l)

  all(l)
  all(b)
  all(b, range=c(3, 3))
  all.booltype(l, range=c(3, 3))

  min(l)
  min(b)

  sum(l)
  sum(b)

  summary(l)
  summary(b)
  summary.booltype(l)
</code></pre>

<hr>
<h2 id='symdiff'>Symmetric set complement</h2><span id='topic+symdiff'></span>

<h3>Description</h3>

<p>Symmetric set complement
</p>


<h3>Usage</h3>

<pre><code class='language-R'>symdiff(x, y)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="symdiff_+3A_x">x</code></td>
<td>
<p>a vector</p>
</td></tr>
<tr><td><code id="symdiff_+3A_y">y</code></td>
<td>
<p>a vector</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>union(setdiff(x, y), setdiff(y, x))</code>
</p>


<h3>Note</h3>

<p>that <code>symdiff(x, y)</code> is not <code><a href="base.html#topic+identical">identical()</a></code>
as <code>symdiff(y, x)</code> without applying <code><a href="base.html#topic+sort">sort()</a></code> to the result
</p>


<h3>See Also</h3>

<p><code><a href="#topic+merge_symdiff">merge_symdiff()</a></code> and <code><a href="#topic+xor">xor()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>symdiff(c(1L, 2L, 2L), c(2L, 3L))
symdiff(c(2L, 3L), c(1L, 2L, 2L))
</code></pre>

<hr>
<h2 id='unattr'>Attribute removal</h2><span id='topic+unattr'></span>

<h3>Description</h3>

<p>Returns object with attributes removed
</p>


<h3>Usage</h3>

<pre><code class='language-R'>unattr(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="unattr_+3A_x">x</code></td>
<td>
<p>any R object</p>
</td></tr>
</table>


<h3>Details</h3>

<p>attribute removal copies the object as usual
</p>


<h3>Value</h3>

<p>a similar object with attributes removed
</p>


<h3>Author(s)</h3>

<p>Jens Oehlschlägel
</p>


<h3>See Also</h3>

<p><code><a href="base.html#topic+attributes">attributes()</a></code>, <code><a href="#topic+setattributes">setattributes()</a></code>,
<code><a href="base.html#topic+unclass">unclass()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
  bit(2)[]
  unattr(bit(2)[])

</code></pre>

<hr>
<h2 id='vecseq'>Vectorized Sequences</h2><span id='topic+vecseq'></span>

<h3>Description</h3>

<p><code>vecseq</code> returns concatenated multiple sequences
</p>


<h3>Usage</h3>

<pre><code class='language-R'>vecseq(x, y = NULL, concat = TRUE, eval = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="vecseq_+3A_x">x</code></td>
<td>
<p>vector of sequence start points</p>
</td></tr>
<tr><td><code id="vecseq_+3A_y">y</code></td>
<td>
<p>vector of sequence end points (if <code>is.null(y)</code> then <code>x</code>
are taken as endpoints, all starting at 1)</p>
</td></tr>
<tr><td><code id="vecseq_+3A_concat">concat</code></td>
<td>
<p>vector of sequence end points (if <code>is.null(y)</code> then
<code>x</code> are taken as endpoints, all starting at 1)</p>
</td></tr>
<tr><td><code id="vecseq_+3A_eval">eval</code></td>
<td>
<p>vector of sequence end points (if <code>is.null(y)</code> then
<code>x</code> are taken as endpoints, all starting at 1)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This is a generalization of <code><a href="base.html#topic+sequence">sequence()</a></code> in that you can choose
sequence starts other than 1 and also have options to no concat and/or
return a call instead of the evaluated sequence.
</p>


<h3>Value</h3>


<ul>
<li><p> if <code>concat == FALSE</code> and <code>eval == FALSE</code> a list with n calls that generate sequences
</p>
</li>
<li><p> if <code>concat == FALSE</code> and <code>eval == TRUE </code> a list with n sequences
</p>
</li>
<li><p> if <code>concat == TRUE </code> and <code>eval == FALSE</code> a single call generating the concatenated
sequences
</p>
</li>
<li><p> if <code>concat == TRUE</code> and <code>eval == TRUE </code> an integer vector of concatentated sequences
</p>
</li></ul>



<h3>Author(s)</h3>

<p>Angelo Canty, Jens Oehlschlägel
</p>


<h3>See Also</h3>

<p><code><a href="base.html#topic++3A">:</a></code>, <code><a href="base.html#topic+seq">seq()</a></code>, <code><a href="base.html#topic+sequence">sequence()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
  sequence(c(3, 4))
  vecseq(c(3, 4))
  vecseq(c(1, 11), c(5, 15))
  vecseq(c(1, 11), c(5, 15), concat=FALSE, eval=FALSE)
  vecseq(c(1, 11), c(5, 15), concat=FALSE, eval=TRUE)
  vecseq(c(1, 11), c(5, 15), concat=TRUE, eval=FALSE)
  vecseq(c(1, 11), c(5, 15), concat=TRUE, eval=TRUE)

</code></pre>

<hr>
<h2 id='xor.default'>Boolean operators and functions</h2><span id='topic+xor.default'></span><span id='topic+xor.logical'></span><span id='topic++21.bit'></span><span id='topic++26.bit'></span><span id='topic++7C.bit'></span><span id='topic++3D+3D.bit'></span><span id='topic++21+3D.bit'></span><span id='topic+xor.bit'></span><span id='topic++21.bitwhich'></span><span id='topic++26.bitwhich'></span><span id='topic++7C.bitwhich'></span><span id='topic++3D+3D.bitwhich'></span><span id='topic++21+3D.bitwhich'></span><span id='topic+xor.bitwhich'></span><span id='topic++26.booltype'></span><span id='topic++7C.booltype'></span><span id='topic++3D+3D.booltype'></span><span id='topic++21+3D.booltype'></span><span id='topic+xor.booltype'></span><span id='topic+xor'></span>

<h3>Description</h3>

<p>Boolean NEGATION '!', AND '&amp;', OR '|' and EXCLUSIVE OR xor', see
<code><a href="base.html#topic+Logic">Logic</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## Default S3 method:
xor(x, y)

## S3 method for class 'logical'
xor(x, y)

## S3 method for class 'bit'
!x

## S3 method for class 'bit'
e1 &amp; e2

## S3 method for class 'bit'
e1 | e2

## S3 method for class 'bit'
e1 == e2

## S3 method for class 'bit'
e1 != e2

## S3 method for class 'bit'
xor(x, y)

## S3 method for class 'bitwhich'
!x

## S3 method for class 'bitwhich'
e1 &amp; e2

## S3 method for class 'bitwhich'
e1 | e2

## S3 method for class 'bitwhich'
e1 == e2

## S3 method for class 'bitwhich'
e1 != e2

## S3 method for class 'bitwhich'
xor(x, y)

## S3 method for class 'booltype'
e1 &amp; e2

## S3 method for class 'booltype'
e1 | e2

## S3 method for class 'booltype'
e1 == e2

## S3 method for class 'booltype'
e1 != e2

## S3 method for class 'booltype'
xor(x, y)

xor(x, y)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="xor.default_+3A_x">x</code></td>
<td>
<p>a <code><a href="#topic+is.booltype">is.booltype()</a></code> vector</p>
</td></tr>
<tr><td><code id="xor.default_+3A_y">y</code></td>
<td>
<p>a <code><a href="#topic+is.booltype">is.booltype()</a></code> vector</p>
</td></tr>
<tr><td><code id="xor.default_+3A_e1">e1</code></td>
<td>
<p>a <code><a href="#topic+is.booltype">is.booltype()</a></code> vector</p>
</td></tr>
<tr><td><code id="xor.default_+3A_e2">e2</code></td>
<td>
<p>a <code><a href="#topic+is.booltype">is.booltype()</a></code> vector</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The binary operators and function <code>xor</code> can now combine any <code><a href="#topic+is.booltype">is.booltype()</a></code> vectors.
They now recycle if vectors have different length. If the two arguments have different
<code><a href="#topic+booltypes">booltypes()</a></code> the return value corresponds to the lower <code><a href="#topic+booltype">booltype()</a></code> of the two.
</p>
<p>Boolean operations on <code><a href="#topic+bit">bit()</a></code> vectors are extremely fast because they are
implemented using C's bitwise operators. Boolean operations on or <code><a href="#topic+bitwhich">bitwhich()</a></code>
vectors are even faster, if they represent very skewed selections.
</p>
<p>The <code>xor</code> function has been made generic and <code>xor.default</code> has
been implemented much faster than R's standard <code><a href="#topic+xor">xor()</a></code>.
This was possible because actually boolean function <code>xor</code> and
comparison operator <code>!=</code> do the same (even with NAs), and <code>!=</code> is
much faster than the multiple calls in <code>(x | y) &amp; !(x &amp; y)</code>
</p>


<h3>Value</h3>

<p>An object of class <code><a href="#topic+booltype">booltype()</a></code> or <code><a href="base.html#topic+logical">logical()</a></code>
</p>


<h3>Methods (by class)</h3>


<ul>
<li> <p><code>xor(default)</code>: default method for <code><a href="#topic+xor">xor()</a></code>
</p>
</li>
<li> <p><code>xor(logical)</code>: <code><a href="base.html#topic+logical">logical()</a></code> method for <code><a href="#topic+xor">xor()</a></code>
</p>
</li>
<li> <p><code>xor(bit)</code>: <code><a href="#topic+bit">bit()</a></code> method for <code><a href="#topic+xor">xor()</a></code>
</p>
</li>
<li> <p><code>xor(bitwhich)</code>: <code><a href="#topic+bitwhich">bitwhich()</a></code> method for <code><a href="#topic+xor">xor()</a></code>
</p>
</li>
<li> <p><code>xor(booltype)</code>: <code><a href="#topic+booltype">booltype()</a></code> method for <code><a href="#topic+xor">xor()</a></code>
</p>
</li></ul>


<h3>Functions</h3>


<ul>
<li> <p><code>`!`(bit)</code>: <code><a href="#topic+bit">bit()</a></code> method for <code><a href="base.html#topic+Logic">!</a></code>
</p>
</li>
<li> <p><code> &amp; </code>: <code><a href="#topic+bit">bit()</a></code> method for <code><a href="base.html#topic+Logic">&amp;</a></code>
</p>
</li>
<li> <p><code> | </code>: <code><a href="#topic+bit">bit()</a></code> method for <code><a href="base.html#topic+Logic">|</a></code>
</p>
</li>
<li> <p><code> == </code>: <code><a href="#topic+bit">bit()</a></code> method for <code><a href="base.html#topic+Comparison">==</a></code>
</p>
</li>
<li> <p><code> != </code>: <code><a href="#topic+bit">bit()</a></code> method for <code><a href="base.html#topic+Comparison">!=</a></code>
</p>
</li>
<li> <p><code>`!`(bitwhich)</code>: <code><a href="#topic+bitwhich">bitwhich()</a></code> method for <code><a href="base.html#topic+Logic">!</a></code>
</p>
</li>
<li> <p><code> &amp; </code>: <code><a href="#topic+bitwhich">bitwhich()</a></code> method for <code><a href="base.html#topic+Logic">&amp;</a></code>
</p>
</li>
<li> <p><code> | </code>: <code><a href="#topic+bitwhich">bitwhich()</a></code> method for <code><a href="base.html#topic+Logic">|</a></code>
</p>
</li>
<li> <p><code> == </code>: <code><a href="#topic+bitwhich">bitwhich()</a></code> method for <code><a href="base.html#topic+Comparison">==</a></code>
</p>
</li>
<li> <p><code> != </code>: <code><a href="#topic+bitwhich">bitwhich()</a></code> method for <code><a href="base.html#topic+Comparison">!=</a></code>
</p>
</li>
<li> <p><code> &amp; </code>: <code><a href="#topic+booltype">booltype()</a></code> method for <code><a href="base.html#topic+Logic">&amp;</a></code>
</p>
</li>
<li> <p><code> | </code>: <code><a href="#topic+booltype">booltype()</a></code> method for <code><a href="base.html#topic+Logic">|</a></code>
</p>
</li>
<li> <p><code> == </code>: <code><a href="#topic+booltype">booltype()</a></code> method for <code><a href="base.html#topic+Comparison">==</a></code>
</p>
</li>
<li> <p><code> != </code>: <code><a href="#topic+booltype">booltype()</a></code> method for <code><a href="base.html#topic+Comparison">!=</a></code>
</p>
</li></ul>


<h3>Author(s)</h3>

<p>Jens Oehlschlägel
</p>


<h3>See Also</h3>

<p><code><a href="#topic+booltypes">booltypes()</a></code>, <code><a href="base.html#topic+Logic">Logic</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
  x &lt;- c(FALSE, FALSE, FALSE, NA, NA, NA, TRUE, TRUE, TRUE)
  y &lt;- c(FALSE, NA, TRUE, FALSE, NA, TRUE, FALSE, NA, TRUE)

  x | y
  x | as.bit(y)
  x | as.bitwhich(y)
  x | as.which(y)
  x | ri(1, 1, 9)


</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
