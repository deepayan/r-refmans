<!DOCTYPE html><html><head><title>Help for package Rsolnp</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {Rsolnp}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#Rsolnp-package'><p>The Rsolnp package</p></a></li>
<li><a href='#benchmark'>
<p>The Rsolnp Benchmark Problems Suite.</p></a></li>
<li><a href='#benchmarkids'>
<p>The Rsolnp Benchmark Problems Suite problem id's.</p></a></li>
<li><a href='#gosolnp'>
<p>Random Initialization and Multiple Restarts of the solnp solver.</p></a></li>
<li><a href='#solnp'>
<p>Nonlinear optimization using augmented Lagrange method.</p></a></li>
<li><a href='#startpars'>
<p>Generates and returns a set of starting parameters by sampling the parameter</p>
space based on the evaluation of the function and constraints.</a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>General Non-Linear Optimization</td>
</tr>
<tr>
<td>Version:</td>
<td>1.16</td>
</tr>
<tr>
<td>Date:</td>
<td>2015-07-02</td>
</tr>
<tr>
<td>Author:</td>
<td>Alexios Ghalanos and Stefan Theussl</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Alexios Ghalanos &lt;alexios@4dscape.com&gt;</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 2.10.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>truncnorm, parallel, stats</td>
</tr>
<tr>
<td>Description:</td>
<td>General Non-linear Optimization Using Augmented Lagrange Multiplier Method.</td>
</tr>
<tr>
<td>LazyLoad:</td>
<td>yes</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL]</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Repository/R-Forge/Project:</td>
<td>rino</td>
</tr>
<tr>
<td>Repository/R-Forge/Revision:</td>
<td>102</td>
</tr>
<tr>
<td>Repository/R-Forge/DateTimeStamp:</td>
<td>2015-07-04 02:08:32</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2015-12-28 09:01:11</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2015-07-08 12:20:39 UTC; rforge</td>
</tr>
</table>
<hr>
<h2 id='Rsolnp-package'>The Rsolnp package</h2><span id='topic+Rsolnp-package'></span><span id='topic+Rsolnp'></span>

<h3>Description</h3>

<p>The Rsolnp package implements Y.Ye's general nonlinear augmented Lagrange 
multiplier method solver (SQP based solver).</p>


<h3>Details</h3>


<table>
<tr>
 <td style="text-align: left;">
Package: </td><td style="text-align: left;"> Rsolnp</td>
</tr>
<tr>
 <td style="text-align: left;">
Type: </td><td style="text-align: left;"> Package</td>
</tr>
<tr>
 <td style="text-align: left;">
Version: </td><td style="text-align: left;"> 1.15</td>
</tr>
<tr>
 <td style="text-align: left;">
Date: </td><td style="text-align: left;"> 2013-04-10</td>
</tr>
<tr>
 <td style="text-align: left;">
License: </td><td style="text-align: left;"> GPL</td>
</tr>
<tr>
 <td style="text-align: left;">
LazyLoad: </td><td style="text-align: left;"> yes</td>
</tr>
<tr>
 <td style="text-align: left;">
Depends: </td><td style="text-align: left;"> stats, truncnorm, parallel</td>
</tr>

</table>



<h3>Author(s)</h3>

<p>Alexios Ghalanos and Stefan Theussl
</p>


<h3>References</h3>

<p>Y.Ye, <em>Interior algorithms for linear, quadratic, and linearly constrained 
non linear programming</em>, PhD Thesis, Department of EES Stanford University, 
Stanford CA.
</p>

<hr>
<h2 id='benchmark'>
The Rsolnp Benchmark Problems Suite.
</h2><span id='topic+benchmark'></span>

<h3>Description</h3>

<p>The function implements a set of benchmark problems against the MINOS solver of 
Murtagh and Saunders.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>benchmark(id = "Powell")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="benchmark_+3A_id">id</code></td>
<td>

<p>The name of the benchmark problem. A call to the function <code><a href="#topic+benchmarkids">benchmarkids</a></code>
will return the available benchmark problems.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The benchmarks were run on dual xeon server with 24GB of memory and windows 7 
operating system. The MINOS solver was used via the tomlab interface.
</p>


<h3>Value</h3>

<p>A data.frame containing the benchmark data. The description of the benchmark 
problem can be accessed throught the <code>description</code> attribute of 
the data.frame.
</p>


<h3>Author(s)</h3>

<p>Alexios Ghalanos and Stefan Theussl<br />
Y.Ye (original matlab version of solnp)
</p>


<h3>References</h3>

<p>W.Hock and K.Schittkowski, <em>Test Examples for Nonlinear Programming Codes</em>, 
Lecture Notes in Economics and Mathematical Systems. Springer Verlag, 1981.<br /> 
Y.Ye, <em>Interior algorithms for linear, quadratic, and linearly constrained 
non linear programming</em>, PhD Thesis, Department of EES Stanford University, 
Stanford CA.<br />
B.A.Murtagh and M.A.Saunders, <em>MINOS 5.5 User's Guide, Report SOL 83-20R</em>, 
Systems Optimization Laboratory, Stanford University (revised July 1998).<br />
P. E. Gill, W. Murray, and M. A. Saunders, <em>SNOPT An SQP algorithm for 
large-scale constrained optimization</em>, SIAM J. Optim., 12 (2002), pp.979-1006.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
benchmarkids()
benchmark(id = "Powell")
benchmark(id = "Alkylation")
benchmark(id = "Box")
benchmark(id = "RosenSuzuki")
benchmark(id = "Wright4")
benchmark(id = "Wright9")
benchmark(id = "Electron")
benchmark(id = "Permutation")
# accessing the description
test = benchmark(id = "Entropy")
attr(test, "description")

## End(Not run)
</code></pre>

<hr>
<h2 id='benchmarkids'>
The Rsolnp Benchmark Problems Suite problem id's.
</h2><span id='topic+benchmarkids'></span>

<h3>Description</h3>

<p>Returns the id's of available benchmark in the Rsolnp Benchmark Problems Suite.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>benchmarkids()
</code></pre>


<h3>Value</h3>

<p>A character vector of problem id's.
</p>


<h3>Author(s)</h3>

<p>Alexios Ghalanos and Stefan Theussl<br />
Y.Ye (original matlab version of solnp)
</p>


<h3>References</h3>

<p>W.Hock and K.Schittkowski, <em>Test Examples for Nonlinear Programming Codes</em>, 
Lecture Notes in Economics and Mathematical Systems. Springer Verlag, 1981.<br /> 
Y.Ye, <em>Interior algorithms for linear, quadratic, and linearly constrained 
non linear programming</em>, PhD Thesis, Department of EES Stanford University, 
Stanford CA.<br />
</p>


<h3>Examples</h3>

<pre><code class='language-R'>benchmarkids()
</code></pre>

<hr>
<h2 id='gosolnp'>
Random Initialization and Multiple Restarts of the solnp solver.
</h2><span id='topic+gosolnp'></span>

<h3>Description</h3>

<p>When the objective function is non-smooth or has many local minima, it is hard
to judge the optimality of the solution, and this usually depends critically on
the starting parameters. This function enables the generation of a set of
randomly chosen parameters from which to initialize multiple restarts of the
solver (see note for details).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gosolnp(pars = NULL, fixed = NULL, fun, eqfun = NULL, eqB = NULL, ineqfun = NULL,
ineqLB = NULL, ineqUB = NULL, LB = NULL, UB = NULL, control = list(),
distr = rep(1, length(LB)), distr.opt = list(), n.restarts = 1, n.sim = 20000,
cluster = NULL, rseed = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gosolnp_+3A_pars">pars</code></td>
<td>

<p>The starting parameter vector. This is not required unless the fixed option is
also used.
</p>
</td></tr>
<tr><td><code id="gosolnp_+3A_fixed">fixed</code></td>
<td>

<p>The numeric index which indicates those parameters which should stay fixed
instead of being randomly generated.
</p>
</td></tr>
<tr><td><code id="gosolnp_+3A_fun">fun</code></td>
<td>

<p>The main function which takes as first argument the parameter vector and returns
a single value.
</p>
</td></tr>
<tr><td><code id="gosolnp_+3A_eqfun">eqfun</code></td>
<td>

<p>(Optional) The equality constraint function returning the vector of evaluated
equality constraints.
</p>
</td></tr>
<tr><td><code id="gosolnp_+3A_eqb">eqB</code></td>
<td>

<p>(Optional) The equality constraints.
</p>
</td></tr>
<tr><td><code id="gosolnp_+3A_ineqfun">ineqfun</code></td>
<td>

<p>(Optional) The inequality constraint function returning the vector of evaluated
inequality constraints.
</p>
</td></tr>
<tr><td><code id="gosolnp_+3A_ineqlb">ineqLB</code></td>
<td>

<p>(Optional) The lower bound of the inequality constraints.
</p>
</td></tr>
<tr><td><code id="gosolnp_+3A_inequb">ineqUB</code></td>
<td>

<p>(Optional) The upper bound of the inequality constraints.
</p>
</td></tr>
<tr><td><code id="gosolnp_+3A_lb">LB</code></td>
<td>

<p>The lower bound on the parameters. This is not optional in this function.
</p>
</td></tr>
<tr><td><code id="gosolnp_+3A_ub">UB</code></td>
<td>

<p>The upper bound on the parameters. This is not optional in this function.
</p>
</td></tr>
<tr><td><code id="gosolnp_+3A_control">control</code></td>
<td>

<p>(Optional) The control list of optimization parameters. The <code>eval.type</code>
option in this control list denotes whether to evaluate the function as is and
exclude inequality violations in the final ranking (default, value = 1),
else whether to evaluate a penalty barrier function comprised of the objective
and all constraints (value = 2). See <code>solnp</code> function documentation for
details of the remaining control options.
</p>
</td></tr>
<tr><td><code id="gosolnp_+3A_distr">distr</code></td>
<td>

<p>A numeric vector of length equal to the number of parameters, indicating the
choice of distribution to use for the random parameter  generation. Choices are
uniform (1), truncated normal (2), and normal (3).
</p>
</td></tr>
<tr><td><code id="gosolnp_+3A_distr.opt">distr.opt</code></td>
<td>

<p>If any choice in <code>distr</code> was anything other than uniform (1), this is a
list equal to the length of the parameters with sub-components for the mean and
sd, which are required in the truncated normal and normal distributions.
</p>
</td></tr>
<tr><td><code id="gosolnp_+3A_n.restarts">n.restarts</code></td>
<td>

<p>The number of solver restarts required.
</p>
</td></tr>
<tr><td><code id="gosolnp_+3A_n.sim">n.sim</code></td>
<td>

<p>The number of random parameters to generate for every restart of the solver.
Note that there will always be significant rejections if inequality bounds are
present. Also, this choice should also be motivated by the width of the upper
and lower bounds.
</p>
</td></tr>
<tr><td><code id="gosolnp_+3A_cluster">cluster</code></td>
<td>

<p>If you want to make use of parallel functionality, initialize and pass a cluster
object from the parallel package (see details), and remember to terminate it!
</p>
</td></tr>
<tr><td><code id="gosolnp_+3A_rseed">rseed</code></td>
<td>

<p>(Optional) A seed to initiate the random number generator, else system time will
be used.
</p>
</td></tr>
<tr><td><code id="gosolnp_+3A_...">...</code></td>
<td>

<p>(Optional) Additional parameters passed to the main, equality or inequality
functions
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Given a set of lower and upper bounds, the function generates, for those
parameters not set as fixed, random values from one of the 3 chosen
distributions. Depending on the <code>eval.type</code> option of the <code>control</code>
argument, the function is either directly evaluated for those points not
violating any inequality constraints, or indirectly via a penalty barrier
function jointly comprising the objective and constraints. The resulting values
are then sorted, and the best N (N = random.restart) parameter vectors
(corresponding to the best N objective function values) chosen in order to
initialize the solver. Since version 1.14, it is up to the user to prepare and
pass a cluster object from the parallel package for use with gosolnp, after
which the parLapply function is used. If your function makes use of additional
packages, or functions, then make sure to export them via the <code>clusterExport</code>
function of the parallel package. Additional arguments passed to the solver via the
... option are evaluated and exported by gosolnp to the cluster.
</p>


<h3>Value</h3>

<p>A list containing the following values:
</p>
<table>
<tr><td><code>pars</code></td>
<td>
<p>Optimal Parameters.</p>
</td></tr>
<tr><td><code>convergence</code></td>
<td>
<p>Indicates whether the solver has converged (0) or not (1).</p>
</td></tr>
<tr><td><code>values</code></td>
<td>
<p>Vector of function values during optimization with last one the
value at the optimal.</p>
</td></tr>
<tr><td><code>lagrange</code></td>
<td>
<p>The vector of Lagrange multipliers.</p>
</td></tr>
<tr><td><code>hessian</code></td>
<td>
<p>The Hessian at the optimal solution.</p>
</td></tr>
<tr><td><code>ineqx0</code></td>
<td>
<p>The estimated optimal inequality vector of slack variables used
for transforming the inequality into an equality constraint.</p>
</td></tr>
<tr><td><code>nfuneval</code></td>
<td>
<p>The number of function evaluations.</p>
</td></tr>
<tr><td><code>elapsed</code></td>
<td>
<p>Time taken to compute solution.</p>
</td></tr>
<tr><td><code>start.pars</code></td>
<td>
<p>The parameter vector used to start the solver</p>
</td></tr>
</table>


<h3>Note</h3>

<p>The choice of which distribution to use for randomly sampling the parameter
space should be driven by the user's knowledge of the problem and confidence or
lack thereof of the parameter distribution. The uniform distribution indicates
a lack of confidence in the location or dispersion of the parameter, while the
truncated normal indicates a more confident choice in both the location and
dispersion. On the other hand, the normal indicates perhaps a lack of knowledge
in the upper or lower bounds, but some confidence in the location and dispersion
of the parameter. In using choices (2) and (3) for <code>distr</code>,
the <code>distr.opt</code> list must be supplied with <code>mean</code> and <code>sd</code> as
subcomponents for those parameters not using the uniform (the examples section
hopefully clarifies the usage).
</p>


<h3>Author(s)</h3>

<p>Alexios Ghalanos and Stefan Theussl<br />
Y.Ye (original matlab version of solnp)
</p>


<h3>References</h3>

<p>Y.Ye, <em>Interior algorithms for linear, quadratic, and linearly constrained
non linear programming</em>, PhD Thesis, Department of EES Stanford University,
Stanford CA.<br />
Hu, X. and Shonkwiler, R. and Spruill, M.C. <em>Random Restarts in Global
Optimization</em>, 1994, Georgia Institute of technology, Atlanta.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# [Example 1]
# Distributions of Electrons on a Sphere Problem:
# Given n electrons, find the equilibrium state distribution (of minimal Coulomb
# potential) of the electrons positioned on a conducting sphere. This model is
# from the COPS benchmarking suite. See http://www-unix.mcs.anl.gov/~more/cops/.
gofn = function(dat, n)
{

	x = dat[1:n]
	y = dat[(n+1):(2*n)]
	z = dat[(2*n+1):(3*n)]
	ii = matrix(1:n, ncol = n, nrow = n, byrow = TRUE)
	jj = matrix(1:n, ncol = n, nrow = n)
	ij = which(ii&lt;jj, arr.ind = TRUE)
	i = ij[,1]
	j = ij[,2]
	#  Coulomb potential
	potential = sum(1.0/sqrt((x[i]-x[j])^2 + (y[i]-y[j])^2 + (z[i]-z[j])^2))
	potential
}

goeqfn = function(dat, n)
{
	x = dat[1:n]
	y = dat[(n+1):(2*n)]
	z = dat[(2*n+1):(3*n)]
	apply(cbind(x^2, y^2, z^2), 1, "sum")
}

n = 25
LB = rep(-1, 3*n)
UB = rep(1,  3*n)
eqB = rep(1, n)
ans = gosolnp(pars  = NULL, fixed = NULL, fun = gofn, eqfun = goeqfn, eqB = eqB,
LB = LB, UB = UB, control = list(outer.iter = 100, trace = 1),
distr = rep(1, length(LB)), distr.opt = list(), n.restarts = 2, n.sim = 20000,
rseed = 443, n = 25)
# should get a function value around 243.813

# [Example 2]
# Parallel functionality for solving the Upper to Lower CVaR problem (not properly
# formulated...for illustration purposes only).

mu =c(1.607464e-04, 1.686867e-04, 3.057877e-04, 1.149289e-04, 7.956294e-05)
sigma = c(0.02307198,0.02307127,0.01953382,0.02414608,0.02736053)
R = matrix(c(1, 0.408, 0.356, 0.347, 0.378,  0.408, 1, 0.385, 0.565, 0.578, 0.356,
0.385, 1, 0.315, 0.332, 0.347, 0.565, 0.315, 1, 0.662, 0.378, 0.578,
0.332, 0.662, 1), 5,5, byrow=TRUE)
# Generate Random deviates from the multivariate Student distribution
set.seed(1101)
v = sqrt(rchisq(10000, 5)/5)
S = chol(R)
S = matrix(rnorm(10000 * 5), 10000) %*% S
ret = S/v
RT = as.matrix(t(apply(ret, 1, FUN = function(x) x*sigma+mu)))
# setup the functions
.VaR = function(x, alpha = 0.05)
{
	VaR = quantile(x, probs = alpha, type = 1)
	VaR
}

.CVaR = function(x, alpha = 0.05)
{
	VaR = .VaR(x, alpha)
	X = as.vector(x[, 1])
	CVaR = VaR - 0.5 * mean(((VaR-X) + abs(VaR-X))) / alpha
	CVaR
}
.fn1 = function(x,ret)
{
	port=ret%*%x
	obj=-.CVaR(-port)/.CVaR(port)
	return(obj)
}

# abs(sum) of weights ==1
.eqn1  = function(x,ret)
{
	sum(abs(x))
}

LB=rep(0,5)
UB=rep(1,5)
pars=rep(1/5,5)
ctrl = list(delta = 1e-10, tol = 1e-8, trace = 0)
cl = makePSOCKcluster(2)
# export the auxilliary functions which are used and cannot be seen by gosolnp
clusterExport(cl, c(".CVaR", ".VaR"))
ans = gosolnp(pars, fun = .fn1, eqfun = .eqn1, eqB = 1, LB = LB, UB = UB,
n.restarts = 2, n.sim=500, cluster = cl, ret = RT)
ans
# don't forget to stop the cluster!
stopCluster(cl)

## End(Not run)
</code></pre>

<hr>
<h2 id='solnp'>
Nonlinear optimization using augmented Lagrange method.
</h2><span id='topic+solnp'></span>

<h3>Description</h3>

<p>The solnp function is based on the solver by Yinyu Ye which solves the general 
nonlinear programming problem:<br />
</p>
<p style="text-align: center;"><code class="reqn">\min  f(x)</code>
</p>

<p style="text-align: center;"><code class="reqn">\mathrm{s.t.}</code>
</p>

<p style="text-align: center;"><code class="reqn">g(x) = 0</code>
</p>

<p style="text-align: center;"><code class="reqn">l_h \leq h(x) \leq u_h</code>
</p>

<p style="text-align: center;"><code class="reqn">l_x \leq x \leq u_x</code>
</p>

<p>where, <code class="reqn">f(x)</code>, <code class="reqn">g(x)</code> and <code class="reqn">h(x)</code> are smooth functions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>solnp(pars, fun, eqfun = NULL, eqB = NULL, ineqfun = NULL, ineqLB = NULL, 
ineqUB = NULL, LB = NULL, UB = NULL, control = list(), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="solnp_+3A_pars">pars</code></td>
<td>

<p>The starting parameter vector.
</p>
</td></tr>
<tr><td><code id="solnp_+3A_fun">fun</code></td>
<td>

<p>The main function which takes as first argument the parameter vector and returns
a single value.
</p>
</td></tr>
<tr><td><code id="solnp_+3A_eqfun">eqfun</code></td>
<td>

<p>(Optional) The equality constraint function returning the vector of evaluated 
equality constraints.
</p>
</td></tr>
<tr><td><code id="solnp_+3A_eqb">eqB</code></td>
<td>

<p>(Optional) The equality constraints.
</p>
</td></tr>
<tr><td><code id="solnp_+3A_ineqfun">ineqfun</code></td>
<td>

<p>(Optional) The inequality constraint function returning the vector of evaluated 
inequality constraints.
</p>
</td></tr>
<tr><td><code id="solnp_+3A_ineqlb">ineqLB</code></td>
<td>

<p>(Optional) The lower bound of the inequality constraints.
</p>
</td></tr>
<tr><td><code id="solnp_+3A_inequb">ineqUB</code></td>
<td>

<p>(Optional) The upper bound of the inequality constraints.
</p>
</td></tr>
<tr><td><code id="solnp_+3A_lb">LB</code></td>
<td>

<p>(Optional) The lower bound on the parameters.
</p>
</td></tr>
<tr><td><code id="solnp_+3A_ub">UB</code></td>
<td>

<p>(Optional) The upper bound on the parameters.
</p>
</td></tr>
<tr><td><code id="solnp_+3A_control">control</code></td>
<td>

<p>(Optional) The control list of optimization parameters. See below for details.
</p>
</td></tr>
<tr><td><code id="solnp_+3A_...">...</code></td>
<td>

<p>(Optional) Additional parameters passed to the main, equality or inequality 
functions. Note that the main and constraint functions must take the exact same 
arguments, irrespective of whether they are used by all of them.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The solver belongs to the class of indirect solvers and implements the augmented 
Lagrange multiplier method with an SQP interior algorithm.
</p>


<h3>Value</h3>

<p>A list containing the following values:
</p>
<table>
<tr><td><code>pars</code></td>
<td>
<p>Optimal Parameters.</p>
</td></tr>
<tr><td><code>convergence</code></td>
<td>
<p>Indicates whether the solver has converged (0) or not 
(1 or 2).</p>
</td></tr>
<tr><td><code>values</code></td>
<td>
<p>Vector of function values during optimization with last one the
value at the optimal.</p>
</td></tr>
<tr><td><code>lagrange</code></td>
<td>
<p>The vector of Lagrange multipliers.</p>
</td></tr>
<tr><td><code>hessian</code></td>
<td>
<p>The Hessian of the augmented problem at the optimal solution.</p>
</td></tr>
<tr><td><code>ineqx0</code></td>
<td>
<p>The estimated optimal inequality vector of slack variables used 
for transforming the inequality into an equality constraint.</p>
</td></tr>
<tr><td><code>nfuneval</code></td>
<td>
<p>The number of function evaluations.</p>
</td></tr>
<tr><td><code>elapsed</code></td>
<td>
<p>Time taken to compute solution.</p>
</td></tr>
</table>


<h3>Control</h3>


<dl>
<dt>rho</dt><dd><p>This is used as a penalty weighting scaler for infeasibility in the 
augmented objective function. The higher its value the more the weighting to 
bring the solution into the feasible region (default 1). However, very high 
values might lead to numerical ill conditioning or significantly slow down 
convergence.</p>
</dd>
<dt>outer.iter</dt><dd><p>Maximum number of major (outer) iterations (default 400).</p>
</dd>
<dt>inner.iter</dt><dd><p>Maximum number of minor (inner) iterations (default 800).</p>
</dd>
<dt>delta</dt><dd><p>Relative step size in forward difference evaluation 
(default 1.0e-7).</p>
</dd>
<dt>tol</dt><dd><p> Relative tolerance on feasibility and optimality (default 1e-8).</p>
</dd>
<dt>trace</dt><dd><p>The value of the objective function and the parameters is printed 
at every major iteration (default 1).</p>
</dd>
</dl>


<h3>Note</h3>

<p>The control parameters <code>tol</code> and <code>delta</code> are key in getting any 
possibility of successful convergence, therefore it is suggested that the user 
change these appropriately to reflect their problem specification.<br />
The solver is a local solver, therefore for problems with rough surfaces and 
many local minima there is absolutely no reason to expect anything other than a 
local solution.
</p>


<h3>Author(s)</h3>

<p>Alexios Ghalanos and Stefan Theussl<br />
Y.Ye (original matlab version of solnp)
</p>


<h3>References</h3>

<p>Y.Ye, <em>Interior algorithms for linear, quadratic, and linearly constrained 
non linear programming</em>, PhD Thesis, Department of EES Stanford University, 
Stanford CA.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># From the original paper by Y.Ye
# see the unit tests for more....
#---------------------------------------------------------------------------------
# POWELL Problem
fn1=function(x)
{
	exp(x[1]*x[2]*x[3]*x[4]*x[5])
}

eqn1=function(x){
	z1=x[1]*x[1]+x[2]*x[2]+x[3]*x[3]+x[4]*x[4]+x[5]*x[5]
	z2=x[2]*x[3]-5*x[4]*x[5]
	z3=x[1]*x[1]*x[1]+x[2]*x[2]*x[2]
	return(c(z1,z2,z3))
}


x0 = c(-2, 2, 2, -1, -1)
powell=solnp(x0, fun = fn1, eqfun = eqn1, eqB = c(10, 0, -1))
</code></pre>

<hr>
<h2 id='startpars'>
Generates and returns a set of starting parameters by sampling the parameter 
space based on the evaluation of the function and constraints.
</h2><span id='topic+startpars'></span>

<h3>Description</h3>

<p>A simple penalty barrier function is formed which is then evaluated at randomly 
sampled points based on the upper and lower parameter bounds 
(when <code>eval.type</code> = 2), else the objective function directly for values not 
violating any inequality constraints (when <code>eval.type</code> = 1). The sampled 
points can be generated from the uniform, normal or truncated normal 
distributions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>startpars(pars = NULL, fixed = NULL, fun, eqfun = NULL, eqB = NULL, 
ineqfun = NULL, ineqLB = NULL, ineqUB = NULL, LB = NULL, UB = NULL, 
distr = rep(1, length(LB)), distr.opt = list(), n.sim = 20000, cluster = NULL, 
rseed = NULL, bestN = 15, eval.type = 1, trace = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="startpars_+3A_pars">pars</code></td>
<td>

<p>The starting parameter vector. This is not required unless the fixed option is 
also used.
</p>
</td></tr>
<tr><td><code id="startpars_+3A_fixed">fixed</code></td>
<td>

<p>The numeric index which indicates those parameters which should stay fixed 
instead of being randomly generated.
</p>
</td></tr>
<tr><td><code id="startpars_+3A_fun">fun</code></td>
<td>

<p>The main function which takes as first argument the parameter vector and returns 
a single value.
</p>
</td></tr>
<tr><td><code id="startpars_+3A_eqfun">eqfun</code></td>
<td>

<p>(Optional) The equality constraint function returning the vector of evaluated 
equality constraints.
</p>
</td></tr>
<tr><td><code id="startpars_+3A_eqb">eqB</code></td>
<td>

<p>(Optional) The equality constraints.
</p>
</td></tr>
<tr><td><code id="startpars_+3A_ineqfun">ineqfun</code></td>
<td>

<p>(Optional) The inequality constraint function returning the vector of evaluated 
inequality constraints.
</p>
</td></tr>
<tr><td><code id="startpars_+3A_ineqlb">ineqLB</code></td>
<td>

<p>(Optional) The lower bound of the inequality constraints.
</p>
</td></tr>
<tr><td><code id="startpars_+3A_inequb">ineqUB</code></td>
<td>

<p>(Optional) The upper bound of the inequality constraints.
</p>
</td></tr>
<tr><td><code id="startpars_+3A_lb">LB</code></td>
<td>

<p>The lower bound on the parameters. This is not optional in this function.
</p>
</td></tr>
<tr><td><code id="startpars_+3A_ub">UB</code></td>
<td>

<p>The upper bound on the parameters. This is not optional in this function.
</p>
</td></tr>
<tr><td><code id="startpars_+3A_distr">distr</code></td>
<td>

<p>A numeric vector of length equal to the number of parameters, indicating the 
choice of distribution to use for the random parameter generation. Choices are 
uniform (1), truncated normal (2), and normal (3).
</p>
</td></tr>
<tr><td><code id="startpars_+3A_distr.opt">distr.opt</code></td>
<td>

<p>If any choice in <code>distr</code> was anything other than uniform (1), this is a 
list equal to the length of the parameters with sub-components for the mean and 
sd, which are required in the truncated normal and normal distributions.
</p>
</td></tr>
<tr><td><code id="startpars_+3A_bestn">bestN</code></td>
<td>

<p>The best N (less than or equal to n.sim) set of parameters to return.
</p>
</td></tr>
<tr><td><code id="startpars_+3A_n.sim">n.sim</code></td>
<td>

<p>The number of random parameter sets to generate.
</p>
</td></tr>
<tr><td><code id="startpars_+3A_cluster">cluster</code></td>
<td>
 
<p>If you want to make use of parallel functionality, initialize and pass a cluster 
object from the parallel package (see details), and remember to terminate it!
</p>
</td></tr>
<tr><td><code id="startpars_+3A_rseed">rseed</code></td>
<td>

<p>(Optional) A seed to initiate the random number generator, else system time will 
be used.
</p>
</td></tr>
<tr><td><code id="startpars_+3A_eval.type">eval.type</code></td>
<td>

<p>Either 1 (default) for the direction evaluation of the function (excluding 
inequality constraint violations) or 2 for the penalty barrier method.
</p>
</td></tr>
<tr><td><code id="startpars_+3A_trace">trace</code></td>
<td>

<p>(logical) Whether to display the progress of the function evaluation.
</p>
</td></tr>
<tr><td><code id="startpars_+3A_...">...</code></td>
<td>

<p>(Optional) Additional parameters passed to the main, equality or inequality 
functions
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Given a set of lower and upper bounds, the function generates, for those 
parameters not set as fixed, random values from one of the 3 chosen 
distributions. For simple functions with only inequality constraints, the direct 
method (<code>eval.type</code> = 1) might work better. For more complex setups with 
both equality and inequality constraints the penalty barrier method 
(<code>eval.type</code> = 2)might be a better choice.
</p>


<h3>Value</h3>

<p>A matrix of dimension bestN x (no.parameters + 1). The last column is the 
evaluated function value.
</p>


<h3>Note</h3>

<p>The choice of which distribution to use for randomly sampling the parameter 
space should be driven by the user's knowledge of the problem and confidence or 
lack thereof of the parameter distribution. The uniform distribution indicates a 
lack of confidence in the location or dispersion of the parameter, while the 
truncated normal indicates a more confident choice in both the location and 
dispersion. On the other hand, the normal indicates perhaps a lack
of knowledge in the upper or lower bounds, but some confidence in the location 
and dispersion of the parameter. In using choices (2) and (3) for <code>distr</code>, 
the <code>distr.opt</code> list must be supplied with <code>mean</code> and <code>sd</code> as 
subcomponents for those parameters not using the uniform.
</p>


<h3>Author(s)</h3>

<p>Alexios Ghalanos and Stefan Theussl<br />
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
library(Rsolnp)
library(parallel)
# Windows
cl = makePSOCKcluster(2)
# Linux:
# makeForkCluster(nnodes = getOption("mc.cores", 2L), ...)

gofn = function(dat, n)
{
	
	x = dat[1:n]
	y = dat[(n+1):(2*n)]
	z = dat[(2*n+1):(3*n)]
	ii = matrix(1:n, ncol = n, nrow = n, byrow = TRUE)
	jj = matrix(1:n, ncol = n, nrow = n)
	ij = which(ii&lt;jj, arr.ind = TRUE)
	i = ij[,1]
	j = ij[,2]
	#  Coulomb potential
	potential = sum(1.0/sqrt((x[i]-x[j])^2 + (y[i]-y[j])^2 + (z[i]-z[j])^2))
	potential
}

goeqfn = function(dat, n)
{
	x = dat[1:n]
	y = dat[(n+1):(2*n)]
	z = dat[(2*n+1):(3*n)]
	apply(cbind(x^2, y^2, z^2), 1, "sum")
}
n = 25
LB  = rep(-1, 3*n)
UB  = rep( 1, 3*n)
eqB = rep( 1,   n)

sp = startpars(pars = NULL, fixed = NULL, fun = gofn , eqfun = goeqfn, 
eqB = eqB, ineqfun = NULL, ineqLB = NULL, ineqUB = NULL, LB = LB, UB = UB, 
distr = rep(1, length(LB)), distr.opt = list(), n.sim = 2000, 
cluster = cl, rseed = 100, bestN = 15, eval.type = 2, n = 25)
#stop cluster
stopCluster(cl)
# the last column is the value of the evaluated function (here it is the barrier 
# function since eval.type = 2) 
print(round(apply(sp, 2, "mean"), 3))
# remember to remove the last column
ans = solnp(pars=sp[1,-76],fun = gofn , eqfun = goeqfn , eqB = eqB, ineqfun = NULL, 
ineqLB = NULL, ineqUB = NULL, LB = LB, UB = UB, n = 25)
# should get a value of around 243.8162

## End(Not run)</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
