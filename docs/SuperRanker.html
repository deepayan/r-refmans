<!DOCTYPE html><html><head><title>Help for package SuperRanker</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {SuperRanker}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#average_overlap'><p>Compute the average overlap</p></a></li>
<li><a href='#overlap'><p>Compute the overlap between k ranked lists</p></a></li>
<li><a href='#plot.sra'><p>Plot sequential rank agreement</p></a></li>
<li><a href='#random_list_sra'><p>Simulate sequential rank agreement for randomized unrelated lists</p></a></li>
<li><a href='#smooth_sra'><p>Smooth quantiles of a matrix of sequential ranked agreements.</p></a></li>
<li><a href='#sra'><p>Compute the sequential rank agreement</p></a></li>
<li><a href='#sracpp'><p>Compute the sequential rank agreement between k ranked lists</p></a></li>
<li><a href='#sracppfull'><p>Compute the sequential rank agreement between k ranked lists</p></a></li>
<li><a href='#SuperRanker'><p>Functions related to comparison of ranked lists</p></a></li>
<li><a href='#test_sra'><p>Compute a Kolmogorov-Smirnoff-like test for Smooth quantiles of a matrix of sequential rank agreements</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Sequential Rank Agreement</td>
</tr>
<tr>
<td>Version:</td>
<td>1.2.1</td>
</tr>
<tr>
<td>Date:</td>
<td>2023-08-27</td>
</tr>
<tr>
<td>Description:</td>
<td>Tools for analysing the agreement of two or more rankings of the same items. Examples are importance rankings of predictor variables and risk predictions of subjects. Benchmarks for agreement are computed based on random permutation and bootstrap. See Ekstrøm CT, Gerds TA, Jensen, AK (2018). "Sequential rank agreement methods for comparison of ranked lists." _Biostatistics_, *20*(4), 582-598 &lt;<a href="https://doi.org/10.1093%2Fbiostatistics%2Fkxy017">doi:10.1093/biostatistics/kxy017</a>&gt; for more information.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>Imports:</td>
<td>stats, graphics, Rcpp (&ge; 0.11.5), prodlim (&ge; 1.5.7)</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>Rcpp</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>ByteCompile:</td>
<td>true</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>Suggests:</td>
<td>testthat (&ge; 3.0.0)</td>
</tr>
<tr>
<td>Config/testthat/edition:</td>
<td>3</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-08-27 14:36:06 UTC; ekstrom</td>
</tr>
<tr>
<td>Author:</td>
<td>Claus Thorn Ekstrøm [aut, cre],
  Thomas Alexander Gerds [aut]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Claus Thorn Ekstrøm &lt;ekstrom@sund.ku.dk&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-08-27 22:40:09 UTC</td>
</tr>
</table>
<hr>
<h2 id='average_overlap'>Compute the average overlap</h2><span id='topic+average_overlap'></span>

<h3>Description</h3>

<p>Compute the average overlap
</p>


<h3>Usage</h3>

<pre><code class='language-R'>average_overlap(obj)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="average_overlap_+3A_obj">obj</code></td>
<td>
<p>Either a vector or matrix</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector of the average overlap
</p>


<h3>Examples</h3>

<pre><code class='language-R'># setting with 3 lists
mlist &lt;- matrix(cbind(1:8,c(1,2,3,5,6,7,4,8),c(1,5,3,4,2,8,7,6)),ncol=3)
average_overlap(mlist)
</code></pre>

<hr>
<h2 id='overlap'>Compute the overlap between k ranked lists</h2><span id='topic+overlap'></span>

<h3>Description</h3>

<p>Computes the overlap (number of items present in all k lists divided by the current rank) for each rank in the k lists
</p>


<h3>Usage</h3>

<pre><code class='language-R'>overlap(rankMat)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="overlap_+3A_rankmat">rankMat</code></td>
<td>
<p>A matrix with k columns corresponding to the k ranked lists. Elements of each column are integers between 1 and the length of the lists</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector of the same length as the rows in rankMat containing the overlap between the lists for each rank
</p>


<h3>Author(s)</h3>

<p>Claus Ekstrøm &lt;ekstrom@sund.ku.dk&gt;
</p>

<hr>
<h2 id='plot.sra'>Plot sequential rank agreement</h2><span id='topic+plot.sra'></span>

<h3>Description</h3>

<p>Plot the agreement between lists as a function of the list depth
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'sra'
plot(
  x,
  xlim,
  ylim,
  xlab = "List depth",
  ylab = "Sequential rank agreement",
  add = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.sra_+3A_x">x</code></td>
<td>
<p>Agreement object</p>
</td></tr>
<tr><td><code id="plot.sra_+3A_xlim">xlim</code></td>
<td>
<p>x-axis limits</p>
</td></tr>
<tr><td><code id="plot.sra_+3A_ylim">ylim</code></td>
<td>
<p>y-axis limits</p>
</td></tr>
<tr><td><code id="plot.sra_+3A_xlab">xlab</code></td>
<td>
<p>x-axis lab</p>
</td></tr>
<tr><td><code id="plot.sra_+3A_ylab">ylab</code></td>
<td>
<p>y-axis lab</p>
</td></tr>
<tr><td><code id="plot.sra_+3A_add">add</code></td>
<td>
<p>Logical. If <code>TRUE</code> add graph to existing plot.</p>
</td></tr>
<tr><td><code id="plot.sra_+3A_...">...</code></td>
<td>
<p>Processed by function <code>prodlim::SmartControl</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Graph
</p>


<h3>Author(s)</h3>

<p>Thomas A. Gerds &lt;tag@biostat.ku.dk&gt;
</p>


<h3>Examples</h3>

<pre><code class='language-R'>R1=c(1,2,3,4,5,7,6,8,9,10,11,12,13)
R2=c(5,11,4,7,8,3,12,13,6,10,9,2,1)
a &lt;- sra(list(R1,R2))
plot(a)
arand = colMeans(do.call("rbind",lapply(1:20,function(b){
    sra(list(sample(R1),sample(R1)))
})))
lines(1:length(R1),arand,col=2,lwd=3)

l &lt;- c(1,2,3,4,5,7,6,8,9,10,11,12,13)
l &lt;- 1:100
aa &lt;- sapply(1:20,function(i){
    sra(list(sample(l),sample(l),sample(l)))[i]
})
c(mean(aa),sd(aa))

</code></pre>

<hr>
<h2 id='random_list_sra'>Simulate sequential rank agreement for randomized unrelated lists</h2><span id='topic+random_list_sra'></span>

<h3>Description</h3>

<p>Simulate sequential rank agreement from completely uninformative lists (ie., raw permutations of items) and compute the corresponding sequential rank agreement curves.
The following attributes are copied from the input object: number of lists, number of items and amount of censoring.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>random_list_sra(
  object,
  B = 1,
  n = 1,
  na.strings = NULL,
  nitems = NULL,
  type = c("sd", "mad"),
  epsilon = 0
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="random_list_sra_+3A_object">object</code></td>
<td>
<p>A matrix of numbers or list of vectors representing ranked lists.</p>
</td></tr>
<tr><td><code id="random_list_sra_+3A_b">B</code></td>
<td>
<p>An integer giving the number of randomizations to sample
over in the case of censored observations</p>
</td></tr>
<tr><td><code id="random_list_sra_+3A_n">n</code></td>
<td>
<p>Integer: the number of permutation runs. For each permutation run we permute each of the lists in object
and compute corresponding the sequential rank agreement curves</p>
</td></tr>
<tr><td><code id="random_list_sra_+3A_na.strings">na.strings</code></td>
<td>
<p>A vector of character values that represent
censored observations</p>
</td></tr>
<tr><td><code id="random_list_sra_+3A_nitems">nitems</code></td>
<td>
<p>The total number of items in the original lists if we only have partial lists available. Will be derived from the unique elements of the object if set to <code>NULL</code> (the default)</p>
</td></tr>
<tr><td><code id="random_list_sra_+3A_type">type</code></td>
<td>
<p>The type of measure to use. Either sd (standard
deviation - the default) or mad (median absolute deviance)</p>
</td></tr>
<tr><td><code id="random_list_sra_+3A_epsilon">epsilon</code></td>
<td>
<p>A non-negative numeric vector that contains the minimum limit in proportion of lists that must show the item. Defaults to 0. If a single number is provided then the value will be recycles to the number of items. Should usually be low.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix with n columns and the same number of rows as for the input object. Each column contains one
simulated sequential rank agreement curve from one permutation run.
</p>


<h3>Author(s)</h3>

<p>Claus Ekstrøm &lt;ekstrom@sund.ku.dk&gt;
</p>


<h3>Examples</h3>

<pre><code class='language-R'># setting with 3 lists
mlist &lt;- matrix(cbind(1:8,c(1,2,3,5,6,7,4,8),c(1,5,3,4,2,8,7,6)),ncol=3)
# compute sequential rank agreement of lists
sra(mlist)
# compute sequential rank agreement of 5 random permutations
random_list_sra(mlist, n=5)

</code></pre>

<hr>
<h2 id='smooth_sra'>Smooth quantiles of a matrix of sequential ranked agreements.</h2><span id='topic+smooth_sra'></span>

<h3>Description</h3>

<p>Smooth quantiles of a matrix of sequential ranked agreements.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>smooth_sra(object, confidence = 0.95)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="smooth_sra_+3A_object">object</code></td>
<td>
<p>A matrix</p>
</td></tr>
<tr><td><code id="smooth_sra_+3A_confidence">confidence</code></td>
<td>
<p>the limits to compute</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list containing two vectors for the smoothed lower and upper limits
</p>


<h3>Author(s)</h3>

<p>Claus Ekstrøm &lt;ekstrom@sund.ku.dk&gt;
</p>


<h3>Examples</h3>

<pre><code class='language-R'># setting with 3 lists
mlist &lt;- matrix(cbind(1:8,c(1,2,3,5,6,7,4,8),c(1,5,3,4,2,8,7,6)),ncol=3)
# compute rank agreement of 5 random permutations
null=random_list_sra(mlist,n=15)
# now extract point-wise quantiles according to confidence level
smooth_sra(null)
</code></pre>

<hr>
<h2 id='sra'>Compute the sequential rank agreement</h2><span id='topic+sra'></span><span id='topic+sra.default'></span><span id='topic+sra.matrix'></span><span id='topic+sra.list'></span>

<h3>Description</h3>

<p>Compute the sequential rank agreement
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sra(object, B, na.strings, nitems, type, epsilon = 0, ...)

## Default S3 method:
sra(object, B, na.strings, nitems, type, epsilon = 0, ...)

## S3 method for class 'matrix'
sra(
  object,
  B = 1,
  na.strings = NULL,
  nitems = nrow(object),
  type = c("sd", "mad"),
  epsilon = 0,
  ...
)

## S3 method for class 'list'
sra(
  object,
  B = 1,
  na.strings = NULL,
  nitems = max(sapply(object, length)),
  type = c("sd", "mad"),
  epsilon = 0,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sra_+3A_object">object</code></td>
<td>
<p>Either matrix where each column is a ranked list of
items or a list of ranked lists of items. Elements are integers
between 1 and the length of the lists. The lists should have
the same length but censoring can be used by setting the list
to zero from a point onwards. See details for more information.</p>
</td></tr>
<tr><td><code id="sra_+3A_b">B</code></td>
<td>
<p>An integer giving the number of randomization to sample
over in the case of censored observations</p>
</td></tr>
<tr><td><code id="sra_+3A_na.strings">na.strings</code></td>
<td>
<p>A vector of strings/values that represent missing
values in addition to NA. Defaults to NULL which means only NA
are censored values.</p>
</td></tr>
<tr><td><code id="sra_+3A_nitems">nitems</code></td>
<td>
<p>The total number of items in the original lists if we only have partial lists available.</p>
</td></tr>
<tr><td><code id="sra_+3A_type">type</code></td>
<td>
<p>The type of measure to use. Either sd (standard
deviation - the default) or mad (median absolute deviance around the median)</p>
</td></tr>
<tr><td><code id="sra_+3A_epsilon">epsilon</code></td>
<td>
<p>A non-negative numeric vector that contains the minimum limit in proportion of lists that must show the item. Defaults to 0. If a single number is provided then the value will be recycles to the number of items.</p>
</td></tr>
<tr><td><code id="sra_+3A_...">...</code></td>
<td>
<p>Arguments passed to methods.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector of the sequential rank agreement
</p>


<h3>Author(s)</h3>

<p>Claus Ekstrøm &lt;ekstrom@sund.ku.dk&gt; and Thomas A Gerds &lt;tag@biostat.ku.dk&gt;
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
mlist &lt;- matrix(cbind(1:8,c(1,2,3,5,6,7,4,8),c(1,5,3,4,2,8,7,6)),ncol=3)
sra(mlist)

mlist &lt;- matrix(cbind(1:8,c(1,2,3,5,6,7,4,8),c(1,5,3,4,2,8,7,6)),ncol=3)
sra(mlist, nitems=20, B=10)

alist &lt;- list(a=1:8,b=sample(1:8),c=sample(1:8))
sra(alist)

blist &lt;- list(x1=letters,x2=sample(letters),x3=sample(letters))
sra(blist)

## censored lists are either too short
clist &lt;- list(x1=c("a","b","c","d","e","f","g","h"),
              x2=c("h","c","f","g","b"),
              x3=c("d","e","a"))
set.seed(17)
sra(clist,na.strings="z",B=10)

## or use a special code for missing elements
Clist &lt;- list(x1=c("a","b","c","d","e","f","g","h"),
              x2=c("h","c","f","g","b","z","z","z"),
              x3=c("d","e","a","z","z","z","z","z"))
set.seed(17)
sra(Clist,na.strings="z",B=10)

</code></pre>

<hr>
<h2 id='sracpp'>Compute the sequential rank agreement between k ranked lists</h2><span id='topic+sracpp'></span>

<h3>Description</h3>

<p>Computes the sequential rank agreement (number of items present in all k lists divided by the current rank) for each rank in the k lists
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sracpp(rankMat, maxlength, B, cens, type = 0L, epsilon = as.numeric(c(0)))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sracpp_+3A_rankmat">rankMat</code></td>
<td>
<p>A matrix with k columns corresponding to the k ranked lists. Elements of each column are integers between 1 and the length of the lists</p>
</td></tr>
<tr><td><code id="sracpp_+3A_maxlength">maxlength</code></td>
<td>
<p>The maximum depth that are needed XXX</p>
</td></tr>
<tr><td><code id="sracpp_+3A_b">B</code></td>
<td>
<p>The number of resamples to use in the presence of censored lists</p>
</td></tr>
<tr><td><code id="sracpp_+3A_cens">cens</code></td>
<td>
<p>A vector of integer values that</p>
</td></tr>
<tr><td><code id="sracpp_+3A_type">type</code></td>
<td>
<p>The type of distance measure to use: 0 (the default) is the variance while 1 is MAD (median absolute deviation)</p>
</td></tr>
<tr><td><code id="sracpp_+3A_epsilon">epsilon</code></td>
<td>
<p>A non-negative numeric vector that contains the minimum limit in proportion of lists that must show the item. Defaults to 0. If a single number is provided then the value will be recycles to the number of items.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector of the same length as the rows in rankMat containing the squared (!) sequential rank agreement between the lists for each depth. If the MAD type was chosen then the sequential MAD values are returned
</p>


<h3>Author(s)</h3>

<p>Claus Ekstrøm &lt;ekstrom@sund.ku.dk&gt;
</p>

<hr>
<h2 id='sracppfull'>Compute the sequential rank agreement between k ranked lists</h2><span id='topic+sracppfull'></span>

<h3>Description</h3>

<p>Computes the sequential rank agreement (number of items present in all k lists divided by the current rank) for each rank in the k lists
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sracppfull(rankMat, type = 0L, epsilon = as.numeric(c(0)))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sracppfull_+3A_rankmat">rankMat</code></td>
<td>
<p>A matrix with k columns corresponding to the k ranked lists. Elements of each column are integers between 1 and the length of the lists</p>
</td></tr>
<tr><td><code id="sracppfull_+3A_type">type</code></td>
<td>
<p>The type of distance measure to use: 0 (the default) is the variance while 1 is MAD (mean absolute deviation)</p>
</td></tr>
<tr><td><code id="sracppfull_+3A_epsilon">epsilon</code></td>
<td>
<p>A non-negative numeric vector that contains the minimum limit in proportion of lists that must show the item. Defaults to 0. If a single number is provided then the value will be recycles to the number of items.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector of the same length as the rows in rankMat containing the sequential rank agreement between the lists for each depth (squared for type=0)
</p>


<h3>Author(s)</h3>

<p>Claus Ekstrøm &lt;ekstrom@sund.ku.dk&gt;
</p>

<hr>
<h2 id='SuperRanker'>Functions related to comparison of ranked lists</h2><span id='topic+SuperRanker'></span><span id='topic+SuperRanker-package'></span>

<h3>Description</h3>

<p>SuperRanker allows you to estimate the agreement between two or more rankings of the same items.
</p>

<hr>
<h2 id='test_sra'>Compute a Kolmogorov-Smirnoff-like test for Smooth quantiles of a matrix of sequential rank agreements</h2><span id='topic+test_sra'></span>

<h3>Description</h3>

<p>Compute a Kolmogorov-Smirnoff-like test for Smooth quantiles of a matrix of sequential rank agreements
</p>


<h3>Usage</h3>

<pre><code class='language-R'>test_sra(object, nullobject, weights = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="test_sra_+3A_object">object</code></td>
<td>
<p>An object created with <code>sra</code>.</p>
</td></tr>
<tr><td><code id="test_sra_+3A_nullobject">nullobject</code></td>
<td>
<p>An object created with <code>random_list_sra</code>.</p>
</td></tr>
<tr><td><code id="test_sra_+3A_weights">weights</code></td>
<td>
<p>Either a single value or a vector of the same length as the number of item with the weight that should be given to specific depths.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A single value corresponding to the p-value
</p>


<h3>Author(s)</h3>

<p>Claus Ekstrøm &lt;ekstrom@sund.ku.dk&gt;
</p>


<h3>Examples</h3>

<pre><code class='language-R'># setting with 3 lists
mlist &lt;- matrix(cbind(1:8,c(1,2,3,5,6,7,4,8),c(1,5,3,4,2,8,7,6)),ncol=3)
# compute sequential rank agreements
x=sra(mlist)
# compute rank agreement of 5 random permutations
null=random_list_sra(mlist,n=15)
# now extract point-wise quantiles according to confidence level
test_sra(x,null)
# compare to when we use the result of the first permutation run
test_sra(null[,1],null[,-1])

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
