<!DOCTYPE html><html><head><title>Help for package wNNSel</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {wNNSel}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#artifNA'><p>Introduce MCAR Missing Values in a matrix</p></a></li>
<li><a href='#artifNA.cv'><p>Introduce MCAR Missing Values in a matrix for cross validation</p></a></li>
<li><a href='#computeMAIE'><p>Mean Absolute Imputation Error</p></a></li>
<li><a href='#computeMSIE'><p>Mean Squared Imputation Error</p></a></li>
<li><a href='#computeNRMSE'><p>Normalized Root Mean Squared Imputatoin Error</p></a></li>
<li><a href='#cv.wNNSel'><p>Cross Validation for wNNSel Imputation</p></a></li>
<li><a href='#wNNSel'><p>Imputatin using wNNSel method.</p></a></li>
<li><a href='#wNNSel-package'><p>Weighted Nearest Neighbor Imputation of Missing Values using Selected Variables</p></a></li>
<li><a href='#wNNSel.impute'><p>Weighted Nearest Neighbor Imputation of Missing Values using Selected Variables</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Weighted Nearest Neighbor Imputation of Missing Values using
Selected Variables</td>
</tr>
<tr>
<td>Version:</td>
<td>0.1</td>
</tr>
<tr>
<td>Author:</td>
<td>Shahla Faisal</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Shahla Faisal &lt;shahla_ramzan@yahoo.com&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>New tools for the imputation of missing values in high-dimensional
    data are introduced using the non-parametric nearest neighbor methods. It
    includes weighted nearest neighbor imputation methods that use specific
    distances for selected variables. It includes an automatic procedure of cross
    validation and does not require prespecified values of the tuning parameters.
    It can be used to impute missing values in high-dimensional data when the sample
    size is smaller than the number of predictors. For more information see Faisal
    and Tutz (2017) &lt;<a href="https://doi.org/10.1515%2Fsagmb-2015-0098">doi:10.1515/sagmb-2015-0098</a>&gt;.</td>
</tr>
<tr>
<td>Imports:</td>
<td>stats</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>5.0.1</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2017-11-09 08:23:48 UTC; ramzan</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2017-11-09 11:32:18 UTC</td>
</tr>
</table>
<hr>
<h2 id='artifNA'>Introduce MCAR Missing Values in a matrix</h2><span id='topic+artifNA'></span>

<h3>Description</h3>

<p>This function artificially introduces missing values in a data matrix under missing completely at random (MCAR) mechanism.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>artifNA(x, miss.prop = 0.1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="artifNA_+3A_x">x</code></td>
<td>
<p>a matrix, in which missing values are to be created.</p>
</td></tr>
<tr><td><code id="artifNA_+3A_miss.prop">miss.prop</code></td>
<td>
<p>proportion of missing values</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a matrix with missing values
</p>


<h3>Examples</h3>

<pre><code class='language-R'> set.seed(3)
 x = matrix(rnorm(100),10,10)
 ## create 10% missing values in x
 artifNA(x, 0.10)
</code></pre>

<hr>
<h2 id='artifNA.cv'>Introduce MCAR Missing Values in a matrix for cross validation</h2><span id='topic+artifNA.cv'></span>

<h3>Description</h3>

<p>This function introduces additional missing values in a missing data matrix artificially.
The missing values are introduced under missing completely at random (MCAR) mechanism.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>artifNA.cv(x, testNA.prop = 0.1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="artifNA.cv_+3A_x">x</code></td>
<td>
<p>a matrix, in which missing values are to be created.</p>
</td></tr>
<tr><td><code id="artifNA.cv_+3A_testna.prop">testNA.prop</code></td>
<td>
<p>proportion of missing values</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list contatining a matrix with artifical missing values, removed indices and the provided x matrix
</p>


<h3>See Also</h3>

<p><code><a href="#topic+cv.wNNSel">cv.wNNSel</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'> set.seed(3)
 x = matrix(rnorm(100),10,10)
 ## create 10% missing values in x
 x.miss&lt;- artifNA(x, 0.10)
 ## create another 10% missing values in x
 x.miss.cv&lt;- artifNA.cv(x, 0.10)
 summary(x.miss)
 summary(x.miss.cv)
</code></pre>

<hr>
<h2 id='computeMAIE'>Mean Absolute Imputation Error</h2><span id='topic+computeMAIE'></span>

<h3>Description</h3>

<p>This function computes the mean absolute imputation error for a given complete/true data matrix,
imputed data matrix and the data matrix with missing values.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>computeMAIE(x.miss, x.impute, x.true)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="computeMAIE_+3A_x.miss">x.miss</code></td>
<td>
<p>a <code>matrix</code>,  having missing values</p>
</td></tr>
<tr><td><code id="computeMAIE_+3A_x.impute">x.impute</code></td>
<td>
<p>an imputed data <code>matrix</code>. Note that it should not contain any missing values.</p>
</td></tr>
<tr><td><code id="computeMAIE_+3A_x.true">x.true</code></td>
<td>
<p>complete/true data <code>matrix</code>. Note that it should not contain any missing values.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>value of MSIE
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  set.seed(3)
  x.true = matrix(rnorm(100),10,10)
  ## create 10% missing values in x
  x.miss = artifNA(x.true, 0.10)
  ## impute using wNNSel method
  x.impute = wNNSel.impute(x.miss)
  computeMAIE(x.miss, x.impute, x.true)
</code></pre>

<hr>
<h2 id='computeMSIE'>Mean Squared Imputation Error</h2><span id='topic+computeMSIE'></span>

<h3>Description</h3>

<p>This function computes the mean squared imputation error for a given complete/true data matrix,
imputed data matrix and the data matrix with missing values.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>computeMSIE(x.miss, x.impute, x.true)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="computeMSIE_+3A_x.miss">x.miss</code></td>
<td>
<p>a <code>matrix</code>,  having missing values</p>
</td></tr>
<tr><td><code id="computeMSIE_+3A_x.impute">x.impute</code></td>
<td>
<p>an imputed data <code>matrix</code>. Note that it should not contain any missing values.</p>
</td></tr>
<tr><td><code id="computeMSIE_+3A_x.true">x.true</code></td>
<td>
<p>complete/true data <code>matrix</code>. Note that it should not contain any missing values.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>value of MSIE
</p>


<h3>Examples</h3>

<pre><code class='language-R'> set.seed(3)
 x.true = matrix(rnorm(100),10,10)
 ## create 10% missing values in x
 x.miss = artifNA(x.true, 0.10)
 ## impute using wNNSel method
 x.impute = wNNSel.impute(x.miss)
 computeMSIE(x.miss, x.impute, x.true)
</code></pre>

<hr>
<h2 id='computeNRMSE'>Normalized Root Mean Squared Imputatoin Error</h2><span id='topic+computeNRMSE'></span>

<h3>Description</h3>

<p>This function computes the nrmalized root mean squared imputation error for a given complete/true data matrix,
imputed data matrix and the data matrix with missing values.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>computeNRMSE(x.miss, x.impute, x.true)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="computeNRMSE_+3A_x.miss">x.miss</code></td>
<td>
<p>a <code>matrix</code>,  having missing values</p>
</td></tr>
<tr><td><code id="computeNRMSE_+3A_x.impute">x.impute</code></td>
<td>
<p>an imputed data <code>matrix</code>. Note that it should not contain any missing values.</p>
</td></tr>
<tr><td><code id="computeNRMSE_+3A_x.true">x.true</code></td>
<td>
<p>complete/true data <code>matrix</code>. Note that it should not contain any missing values.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>value of MSIE
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  set.seed(3)
  x.true = matrix(rnorm(100),10,10)
  ## create 10% missing values in x
  x.miss = artifNA(x.true, 0.10)
  ## impute using wNNSel method
  x.impute = wNNSel.impute(x.miss)
  computeNRMSE(x.miss, x.impute, x.true)
</code></pre>

<hr>
<h2 id='cv.wNNSel'>Cross Validation for wNNSel Imputation</h2><span id='topic+cv.wNNSel'></span>

<h3>Description</h3>

<p>This function aims to search for optimal values of the tuning parameters for the wNNSel imputation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cv.wNNSel(x, kernel = "gaussian", x.dist = "euclidean", method = "2",
  m.values = seq(2, 8, by = 2), c.values = seq(0.1, 0.5, by = 0.1),
  lambda.values = seq(0, 0.6, by = 0.01)[-1], times.max = 5,
  testNA.prop = 0.05)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cv.wNNSel_+3A_x">x</code></td>
<td>
<p>a <code>matrix</code> containing missing values</p>
</td></tr>
<tr><td><code id="cv.wNNSel_+3A_kernel">kernel</code></td>
<td>
<p>kernel function to be used in nearest neighbors imputation. Default kernel function is &quot;gaussian&quot;.</p>
</td></tr>
<tr><td><code id="cv.wNNSel_+3A_x.dist">x.dist</code></td>
<td>
<p>distance to compute, The default is <code>x.dist="euclidean"</code>
to compute Euclidean distance. Set <code>x.dist</code> to <code>NULL</code> to use Manhattan distance.</p>
</td></tr>
<tr><td><code id="cv.wNNSel_+3A_method">method</code></td>
<td>
<p>convex function,  performs selection of variables. If <code>method="1"</code>,
linear function is used and when if <code>method="c"</code>, power function is used.</p>
</td></tr>
<tr><td><code id="cv.wNNSel_+3A_m.values">m.values</code></td>
<td>
<p>a <code>vector</code> of integer values, required when mehtod=&quot;2&quot;.</p>
</td></tr>
<tr><td><code id="cv.wNNSel_+3A_c.values">c.values</code></td>
<td>
<p>a <code>vector</code> between 0 and less than 1. It is required when mehtod=&quot;1&quot;.</p>
</td></tr>
<tr><td><code id="cv.wNNSel_+3A_lambda.values">lambda.values</code></td>
<td>
<p>a <code>vector</code>, for the tuning parameter <code class="reqn">\lambda</code></p>
</td></tr>
<tr><td><code id="cv.wNNSel_+3A_times.max">times.max</code></td>
<td>
<p>maximum number of repititions for the cross validation procedure.</p>
</td></tr>
<tr><td><code id="cv.wNNSel_+3A_testna.prop">testNA.prop</code></td>
<td>
<p>proportion of values to be deleted artificially for
cross validation in the missing matrix <code>x</code>. Default method uses 5 percent.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Some values are artificially deleted and wNNSel is run multiple times, varying  <code class="reqn">\lambda</code> and  <code class="reqn">m</code>.
For each pair of <code class="reqn">\lambda</code> and <code class="reqn">m</code>, compute MSIE on the subset of the data matrix x for which the
the values were deleted artificially. (See References for more detail).
</p>


<h3>Value</h3>

<p>a list containing 
</p>
<table>
<tr><td><code>lambda.opt</code></td>
<td>
<p>optimal parameter selected by cross validation</p>
</td></tr>
<tr><td><code>m.opt</code></td>
<td>
<p>optimal parameter selected by cross validation</p>
</td></tr>
<tr><td><code>MSIE.cv</code></td>
<td>
<p>cross validation error</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Shahla Faisal &lt;shahla_ramzan@yahoo.com&gt;
</p>


<h3>References</h3>

<p>Tutz, G. and Ramzan,S. (2015). Improved methods for the imputation of missing data
by nearest neighbor methods.  <em>Computational Statistics and Data Analysis</em>, Vol. 90, pp. 84-99.
</p>
<p>Faisal, S. and Tutz, G. (2017). Missing value imputation for gene expression data by tailored nearest neighbors.
<em>Statistical Application in Genetics and  Molecular Biology</em>.  Vol. 16(2), pp. 95-106.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+artifNA.cv">artifNA.cv</a></code>, <code><a href="#topic+wNNSel">wNNSel</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'> set.seed(3)
 x.true = matrix(rnorm(100),10,10)
 ## create 10% missing values in x
 x.miss = artifNA(x.true, 0.10)
 ## use cross validation to find optimal values
 result = cv.wNNSel(x.miss)
 ## optimal values are
 result$lambda.opt
 result$m.opt
 ## Now use these values to get final imputation
 x.impute = wNNSel.impute(x.miss, lambda=result$lambda.opt, m=result$m.opt)
 ## and final MSIE
 computeMSIE(x.miss, x.impute, x.true)
</code></pre>

<hr>
<h2 id='wNNSel'>Imputatin using wNNSel method.</h2><span id='topic+wNNSel'></span>

<h3>Description</h3>

<p><code>'wNNSel'</code> is used to impute the missing values particularly in high dimensional data.
It uses a cross validation procedure for selecting the best values of the tuning parameters.
It also works when the samples are smaller than the covariates.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>wNNSel(x, x.initial = NULL, x.true = NULL, k, useAll = TRUE,
  x.dist = "euclidean", kernel = "gaussian", method = "2", impute.fn,
  convex = TRUE, m.values = seq(2, 8, by = 2), c.values = seq(0.1, 0.5, by
  = 0.1), lambda.values = seq(0, 0.6, by = 0.01)[-1], times.max = 5,
  testNA.prop = 0.05, withinFolds = FALSE, folds, verbose = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="wNNSel_+3A_x">x</code></td>
<td>
<p>a numeric data <code>matrix</code> containing missing values</p>
</td></tr>
<tr><td><code id="wNNSel_+3A_x.initial">x.initial</code></td>
<td>
<p>an optional. A complete data matrix e.g. using mean imputation of <code>x</code>. If provided, it will be used for the computation of correlations.</p>
</td></tr>
<tr><td><code id="wNNSel_+3A_x.true">x.true</code></td>
<td>
<p>a matrix of true or complete data. If provided, <code>MSIE</code> will be returned in the results list.</p>
</td></tr>
<tr><td><code id="wNNSel_+3A_k">k</code></td>
<td>
<p>an optional, the number of nearest neighbors to use for imputation.</p>
</td></tr>
<tr><td><code id="wNNSel_+3A_useall">useAll</code></td>
<td>
<p><code>logical</code>. If <code>TRUE</code>, all <em>available</em> neighbors are used for the imputation.</p>
</td></tr>
<tr><td><code id="wNNSel_+3A_x.dist">x.dist</code></td>
<td>
<p>distance to compute. The default is <code>x.dist="euclidean"</code>, that uses the Euclidean distance. Set <code>x.dist</code> to <code>NULL</code> for Manhattan distance.</p>
</td></tr>
<tr><td><code id="wNNSel_+3A_kernel">kernel</code></td>
<td>
<p>kernel function to be used in nearest neighbors imputation. Default kernel function is &quot;gaussian&quot;.</p>
</td></tr>
<tr><td><code id="wNNSel_+3A_method">method</code></td>
<td>
<p>convex function,  performs selection of variables. If <code>method="1"</code>, linear function is used and the power function is used when <code>method="2"</code>.</p>
</td></tr>
<tr><td><code id="wNNSel_+3A_impute.fn">impute.fn</code></td>
<td>
<p>the imputation function to run on the length k vector of values for a missing feature. Defaults to a weighted mean of the neighboring values, weighted by the specified <code>kernel</code>. If not specified then wNN imputation will be used by default.</p>
</td></tr>
<tr><td><code id="wNNSel_+3A_convex">convex</code></td>
<td>
<p>logical. If <code>TRUE</code>, selected variables are used for the computation of distance.  The default is <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="wNNSel_+3A_m.values">m.values</code></td>
<td>
<p>a <code>vector</code> of integer values, required when mehtod=&quot;2&quot;.</p>
</td></tr>
<tr><td><code id="wNNSel_+3A_c.values">c.values</code></td>
<td>
<p>a <code>vector</code> between 0 and less than 1. It is required when mehtod=&quot;1&quot;.</p>
</td></tr>
<tr><td><code id="wNNSel_+3A_lambda.values">lambda.values</code></td>
<td>
<p>a <code>vector</code>, for the tuning parameter <code class="reqn">\lambda</code></p>
</td></tr>
<tr><td><code id="wNNSel_+3A_times.max">times.max</code></td>
<td>
<p>maximum number of repititions for the cross validation procedure.</p>
</td></tr>
<tr><td><code id="wNNSel_+3A_testna.prop">testNA.prop</code></td>
<td>
<p>proportion of values to be deleted artificially for
cross validation in the missing matrix <code>x</code>. Default method uses 5 percent.</p>
</td></tr>
<tr><td><code id="wNNSel_+3A_withinfolds">withinFolds</code></td>
<td>
<p><code>logical</code>. Use only if the neighbors/rows belong to particular folds/groups. Default is set to <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="wNNSel_+3A_folds">folds</code></td>
<td>
<p>a <code>list</code> of vectors specifying folds/groups for neighbors. lenght of list is equal to the number of folds/groups. Each element/vector of the list indicates row indices belonging to that particular group/fold.</p>
</td></tr>
<tr><td><code id="wNNSel_+3A_verbose">verbose</code></td>
<td>
<p>logical. If <code>TRUE</code>, prints status updates</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For each sample, identify missinng features.  For each missing feature
find the nearest neighbors which have that feature.  Impute the missing
value using the imputation function on the <em>selected</em> vector of values
found from the neighbors.
By default the <code>wNNSel</code> method automatically searches for optimal values for a given data matrix.
</p>
<p>The default method uses <code>x.dist="euclidean"</code> including selected covariates.
The specific distancs are computed using important covariates only.
If <code>mehtod="1"</code>, the linear function in absolute value of <code class="reqn">r</code> is used, defined by
</p>
<p style="text-align: center;"><code class="reqn">\frac{|r|}{1-c} - \frac{c}{1-c},</code>
</p>

<p>for <code class="reqn">|r|&gt;c</code>, and, 0 , otherwise. 
By default, the power function <code class="reqn">|r|^m </code> is used when <code>mehtod="2"</code>. For more detailed discussion, see references.
</p>


<h3>Value</h3>

<p>a list containing imputed data matrix, and cross validation results
</p>
<table>
<tr><td><code>x.impute</code></td>
<td>
<p>imputed data matrix</p>
</td></tr>
<tr><td><code>MSIE</code></td>
<td>
<p>True error. Note it is only available when x.true is provided.</p>
</td></tr>
<tr><td><code>lambda.opt</code></td>
<td>
<p>optimal parameter selected by cross validation</p>
</td></tr>
<tr><td><code>m.opt</code></td>
<td>
<p>optimal parameter selected by cross validation</p>
</td></tr>
<tr><td><code>MSIE.cv</code></td>
<td>
<p>cross validation error</p>
</td></tr>
</table>


<h3>References</h3>

<p>Tutz, G. and Ramzan,S. (2015). Improved methods for the imputation of missing data
by nearest neighbor methods.  <em>Computational Statistics and Data Analysis</em>, Vol. 90, pp. 84-99.
</p>
<p>Faisal, S. and Tutz, G. (2017). Missing value imputation for gene expression data by tailored nearest neighbors.
<em>Statistical Application in Genetics and  Molecular Biology</em>.  Vol. 16(2), pp. 95-106.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+cv.wNNSel">cv.wNNSel</a></code>, <code><a href="#topic+wNNSel.impute">wNNSel.impute</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'> set.seed(3)
 x.true = matrix(rnorm(100),10,10)
 ## create 10% missing values in x
 x.miss = artifNA(x.true, 0.10)
 ## imputed matrix
 result &lt;- wNNSel(x.miss)
 result$x.impute
 ## cross validation result can be accessed using
 result$cross.val
</code></pre>

<hr>
<h2 id='wNNSel-package'>Weighted Nearest Neighbor Imputation of Missing Values using Selected Variables</h2><span id='topic+wNNSel-package'></span>

<h3>Description</h3>

<p>This package introduces new non-parametric tools for the imputation of missing values in high-dimensional data.   
It includes weighted nearest neighbor
imputation methods that use distances for selected covariates. The careful
selection of distances that carry information about the missing values yields an imputation
tool. It does not require pre-specified <code class="reqn">k</code>, unlike other kNN methods. 
It can be used to impute missing values in high-dimensional data when <code class="reqn">n&lt;p</code>.
</p>


<h3>Details</h3>


<table>
<tr>
 <td style="text-align: left;"> Package: </td><td style="text-align: left;"> wNNSel</td>
</tr>
<tr>
 <td style="text-align: left;"> Version: </td><td style="text-align: left;"> 0.1 </td>
</tr>
<tr>
 <td style="text-align: left;"> Date: </td><td style="text-align: left;">
2017-11-08</td>
</tr>
<tr>
 <td style="text-align: left;"> Depends: </td><td style="text-align: left;"> R (&gt;= 2.10) </td>
</tr>
<tr>
 <td style="text-align: left;"> License: </td><td style="text-align: left;"> GPL (&gt;=
2) </td>
</tr>

</table>

<p>The main function of the package is <code><a href="#topic+wNNSel">wNNSel</a></code> for implementing the nonparameteric procedure of nearest neighbors imputaiton.
See  <code><a href="#topic+wNNSel">wNNSel</a></code> for more details.
</p>


<h3>Note</h3>

<p>*Author's Last name changed to <em>Faisal</em> from <em>Ramzan</em> in 2016.
</p>


<h3>Author(s)</h3>

<p>Shahla Faisal  &lt;shahla_ramzan@yahoo.com&gt;
</p>


<h3>References</h3>

<p>Tutz, G. and Ramzan,S*. (2015). Improved methods for the imputation of missing data
by nearest neighbor methods.  <em>Computational Statistics and Data Analysis</em>, Vol. 90, pp. 84-99.
</p>
<p>Faisal, S.* and Tutz, G. (2017). Missing value imputation for gene expression data by tailored nearest neighbors.
<em>Statistical Application in Genetics and  Molecular Biology</em>.  Vol. 16(2), pp. 95-106.
</p>

<hr>
<h2 id='wNNSel.impute'>Weighted Nearest Neighbor Imputation of Missing Values using Selected Variables</h2><span id='topic+wNNSel.impute'></span>

<h3>Description</h3>

<p>This function imputes the missing values using user-spefied values of the tuning parameters. 
It also works when the samples are smaller than the covariates.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>wNNSel.impute(x, k, useAll = TRUE, x.initial = NULL, x.dist = "euclidean",
  kernel = "gaussian", lambda = 0.3, impute.fn, convex = TRUE,
  method = "2", m = 2, c = 0.3, withinFolds = FALSE, folds,
  verbose = TRUE, verbose2 = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="wNNSel.impute_+3A_x">x</code></td>
<td>
<p>a <code>matrix</code> containing missing values</p>
</td></tr>
<tr><td><code id="wNNSel.impute_+3A_k">k</code></td>
<td>
<p>an optional, the number of nearest neighbors to use for imputation.</p>
</td></tr>
<tr><td><code id="wNNSel.impute_+3A_useall">useAll</code></td>
<td>
<p><code>logical</code>. The default is <code>useALL=TRUE</code>, that is, all <em>available</em> neighbors are used for the imputation.</p>
</td></tr>
<tr><td><code id="wNNSel.impute_+3A_x.initial">x.initial</code></td>
<td>
<p>an optional. A complete data matrix e.g. using mean imputation of <code>x</code>. If provided, it will be used for the computation of correlations.</p>
</td></tr>
<tr><td><code id="wNNSel.impute_+3A_x.dist">x.dist</code></td>
<td>
<p>distance to compute. The default is <code>x.dist="euclidean"</code>, that uses the Euclidean distance. Set <code>x.dist</code> to <code>NULL</code> for Manhattan distance.</p>
</td></tr>
<tr><td><code id="wNNSel.impute_+3A_kernel">kernel</code></td>
<td>
<p>kernel function to be used in nearest neighbors imputation. Default kernel function is &quot;gaussian&quot;.</p>
</td></tr>
<tr><td><code id="wNNSel.impute_+3A_lambda">lambda</code></td>
<td>
<p><code>scaler</code>, a tuning parameter</p>
</td></tr>
<tr><td><code id="wNNSel.impute_+3A_impute.fn">impute.fn</code></td>
<td>
<p>the imputation function to run on the length k vector of values for a missing feature. 
Defaults to a weighted mean of the neighboring values, weighted by the specified <code>kernel</code>. If not specified then wNN imputation will be used by default.</p>
</td></tr>
<tr><td><code id="wNNSel.impute_+3A_convex">convex</code></td>
<td>
<p>logical. If <code>TRUE</code>, selected variables are used for the computation of distance.  The default is <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="wNNSel.impute_+3A_method">method</code></td>
<td>
<p>convex function,  performs selection of variables. If <code>method="1"</code>, linear function is used and the power function is used when <code>method="2"</code>.</p>
</td></tr>
<tr><td><code id="wNNSel.impute_+3A_m">m</code></td>
<td>
<p><code>scaler</code>, a tuning parameter required by the power function.</p>
</td></tr>
<tr><td><code id="wNNSel.impute_+3A_c">c</code></td>
<td>
<p><code>scaler</code>, a tuning parameter required by the linear function.</p>
</td></tr>
<tr><td><code id="wNNSel.impute_+3A_withinfolds">withinFolds</code></td>
<td>
<p><code>logical</code>. Use only if the neighbors/rows belong to particular folds/groups. Default is set to <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="wNNSel.impute_+3A_folds">folds</code></td>
<td>
<p>a <code>list</code> of vectors specifying folds/groups for neighbors. lenght of list is equal to the number of folds/groups. 
Each element/vector of the list indicates row indices belonging to that particular group/fold.</p>
</td></tr>
<tr><td><code id="wNNSel.impute_+3A_verbose">verbose</code></td>
<td>
<p>logical. If <code>TRUE</code>, prints status updates</p>
</td></tr>
<tr><td><code id="wNNSel.impute_+3A_verbose2">verbose2</code></td>
<td>
<p>logical. If <code>TRUE</code>, prints status updates with more detail</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For each sample, identify missinng features.  For each missing feature
find the nearest neighbors which have that feature.  Impute the missing
value using the imputation function on the <em>selected</em> vector of values
found from the neighbors.
</p>


<h3>Value</h3>

<p>imputed data matrix
</p>


<h3>See Also</h3>

<p><code><a href="#topic+cv.wNNSel">cv.wNNSel</a></code>,  <code><a href="#topic+wNNSel">wNNSel</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  set.seed(3)
  x = matrix(rnorm(100),10,10)
  x.miss = x &gt; 1
  x[x.miss] = NA
  wNNSel.impute(x)
  wNNSel.impute(x, lambda=0.5, m=2)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
