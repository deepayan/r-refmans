<!DOCTYPE html><html><head><title>Help for package recurse</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {recurse}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#.calculateCrossingPercentageCmplx'><p>Calculates percentage of trajectory segment within circle</p></a></li>
<li><a href='#calculateIntervalResidenceTime'><p>Calculates residence time within user-specified breaks</p></a></li>
<li><a href='#drawCircle'><p>Draws a circle</p></a></li>
<li><a href='#getRecursions'><p>Calculates recursion information from the trajectory</p></a></li>
<li><a href='#getRecursions3D'><p>Calculates recursion information from the 3D trajectory</p></a></li>
<li><a href='#getRecursions3DAtLocations'><p>Calculates recursion information from the 3D trajectory for specific locations</p></a></li>
<li><a href='#getRecursionsAtLocations'><p>Calculates recursion information from the trajectory for specific locations</p></a></li>
<li><a href='#getRecursionsInPolygon.Move'><p>Calculates recursion information from the trajectory inside a polygon</p></a></li>
<li><a href='#martin'><p>Sample trajectory (martin).</p></a></li>
<li><a href='#plot.recurse'><p>Calculates recursion information from the trajectory</p></a></li>
<li><a href='#recurse'><p>Computes revisitation metrics for trajectory data</p></a></li>
<li><a href='#track'><p>Sample trajectory (track).</p></a></li>
<li><a href='#wren'><p>Sample trajectory (wren).</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Computes Revisitation Metrics for Trajectory Data</td>
</tr>
<tr>
<td>Version:</td>
<td>1.3.0</td>
</tr>
<tr>
<td>Date:</td>
<td>2024-02-18</td>
</tr>
<tr>
<td>Author:</td>
<td>Chloe Bracis [aut, cre]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Chloe Bracis &lt;cbracis@uw.edu&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Computes revisitation metrics for trajectory data, such as the number of revisitations for each location as well as the time spent for that visit and the time since the previous visit. Also includes functions to plot data.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://opensource.org/licenses/mit-license.php">MIT</a> + file LICENSE</td>
</tr>
<tr>
<td>Imports:</td>
<td>Rcpp (&ge; 0.12.7)</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>Rcpp</td>
</tr>
<tr>
<td>Suggests:</td>
<td>testthat, circular, prevR, scales, fields, methods, move,
knitr, rmarkdown, sf</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.2</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-02-18 19:34:05 UTC; bracisc</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-02-18 20:00:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='.calculateCrossingPercentageCmplx'>Calculates percentage of trajectory segment within circle</h2><span id='topic+.calculateCrossingPercentageCmplx'></span>

<h3>Description</h3>

<p>Calculates the percentage of a segment that lies within a circle for a point
A inside the circle and point B outside the circle for a circle with center C and radius R.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.calculateCrossingPercentageCmplx(Cz, Az, Bz, R)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id=".calculateCrossingPercentageCmplx_+3A_cz">Cz</code></td>
<td>
<p>circle center</p>
</td></tr>
<tr><td><code id=".calculateCrossingPercentageCmplx_+3A_az">Az</code></td>
<td>
<p>point 1</p>
</td></tr>
<tr><td><code id=".calculateCrossingPercentageCmplx_+3A_bz">Bz</code></td>
<td>
<p>point 2</p>
</td></tr>
<tr><td><code id=".calculateCrossingPercentageCmplx_+3A_r">R</code></td>
<td>
<p>radius</p>
</td></tr>
</table>

<hr>
<h2 id='calculateIntervalResidenceTime'>Calculates residence time within user-specified breaks</h2><span id='topic+calculateIntervalResidenceTime'></span>

<h3>Description</h3>

<p>Using the results from <code><a href="#topic+getRecursions">getRecursions</a></code> or <code><a href="#topic+getRecursionsAtLocations">getRecursionsAtLocations</a></code>,
calculates the residence time during user-specified intervals (rather than the entire trajectory period) in
the radius around each location.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>calculateIntervalResidenceTime(x, breaks, labels = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="calculateIntervalResidenceTime_+3A_x">x</code></td>
<td>
<p><code>recurse</code> object returned from call to <code><a href="#topic+getRecursions">getRecursions</a></code> or 
<code><a href="#topic+getRecursionsAtLocations">getRecursionsAtLocations</a></code> with <code>verbose = TRUE</code></p>
</td></tr>
<tr><td><code id="calculateIntervalResidenceTime_+3A_breaks">breaks</code></td>
<td>
<p>vector of POSIX datetimes describing the interval boundaries</p>
</td></tr>
<tr><td><code id="calculateIntervalResidenceTime_+3A_labels">labels</code></td>
<td>
<p>(optional) vector or names for the intervals</p>
</td></tr>
</table>


<h3>Details</h3>

<p>When recursions are calculated, the residence time in the radius around each location is also 
calculated. This method allows the user to post-process the results from calculating recursions to calculate
residence time over user-specified intervals, rather than the entire trajectory. This allows the calculation
of residence time on biologically relevant scales, such as seasons, and in cases where large gaps between 
visits (e.g., a seasonal migrant) may make splitting up the residence time preferable.
</p>
<p>Note that care should be taken to use the same time zone when specifying the break points as used in the
datetime for the movement trajectory.
</p>


<h3>Value</h3>

<p>A matrix of residence times where the columns are the coordinate indices of the locations (either 
movement trajectory locations or user-specified locations) and the rows are the time intervals.
</p>


<h3>Author(s)</h3>

<p>Chloe Bracis &lt;cbracis@uw.edu&gt;
</p>


<h3>See Also</h3>

<p><code><a href="#topic+getRecursions">getRecursions</a></code>, <code><a href="#topic+getRecursionsAtLocations">getRecursionsAtLocations</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(martin)
revisits = getRecursions(martin, radius = 1)
breaks = strptime(c("2000-01-01 00:00:00", "2000-01-15 00:00:00", "2000-02-01 00:00:00"), 
format = "")
intervalResTime = calculateIntervalResidenceTime(revisits, breaks)

</code></pre>

<hr>
<h2 id='drawCircle'>Draws a circle</h2><span id='topic+drawCircle'></span>

<h3>Description</h3>

<p>Draws a circle in data coordinates, so it will be a circle if the aspect
ratio of the plot is 1, or else it will be appear as an ellipse.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>drawCircle(x, y, radius, nv = 100, border = NULL, col = NA, lty = 1, lwd = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="drawCircle_+3A_x">x</code></td>
<td>
<p>x-coordinate of circle center</p>
</td></tr>
<tr><td><code id="drawCircle_+3A_y">y</code></td>
<td>
<p>y-coordinate of circle center</p>
</td></tr>
<tr><td><code id="drawCircle_+3A_radius">radius</code></td>
<td>
<p>radius of circle</p>
</td></tr>
<tr><td><code id="drawCircle_+3A_nv">nv</code></td>
<td>
<p>how many plotted segments</p>
</td></tr>
<tr><td><code id="drawCircle_+3A_border">border</code></td>
<td>
<p>polygon border</p>
</td></tr>
<tr><td><code id="drawCircle_+3A_col">col</code></td>
<td>
<p>line color</p>
</td></tr>
<tr><td><code id="drawCircle_+3A_lty">lty</code></td>
<td>
<p>line type</p>
</td></tr>
<tr><td><code id="drawCircle_+3A_lwd">lwd</code></td>
<td>
<p>line width</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is useful to display a representative circle with the specified radius
on a plot of revisits.
</p>


<h3>Value</h3>

<p>invisibly, the x and y points of the drawn circle
</p>


<h3>Author(s)</h3>

<p>Chloe Bracis &lt;cbracis@uw.edu&gt;
</p>


<h3>See Also</h3>

<p><code><a href="#topic+plot.recurse">plot.recurse</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(martin)
revisits = getRecursions(martin, radius = 1)
plot(revisits, martin, legendPos = c(10, -15))
drawCircle(10, -10, 1)

</code></pre>

<hr>
<h2 id='getRecursions'>Calculates recursion information from the trajectory</h2><span id='topic+getRecursions'></span><span id='topic+getRecursions.data.frame'></span><span id='topic+getRecursions.Move'></span><span id='topic+getRecursions.MoveStack'></span>

<h3>Description</h3>

<p>A circle of radius R is drawn around each point in the trajectory. The number of
revisits is calculated as the number of segments of the trajectory passing through that circle.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getRecursions(
  x,
  radius,
  threshold = 0,
  timeunits = c("hours", "secs", "mins", "days"),
  verbose = TRUE
)

## S3 method for class 'data.frame'
getRecursions(
  x,
  radius,
  threshold = 0,
  timeunits = c("hours", "secs", "mins", "days"),
  verbose = TRUE
)

## S3 method for class 'Move'
getRecursions(
  x,
  radius,
  threshold = 0,
  timeunits = c("hours", "secs", "mins", "days"),
  verbose = TRUE
)

## S3 method for class 'MoveStack'
getRecursions(
  x,
  radius,
  threshold = 0,
  timeunits = c("hours", "secs", "mins", "days"),
  verbose = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getRecursions_+3A_x">x</code></td>
<td>
<p>Either a data frame, <a href="move.html#topic+Move-class">Move-class</a>, or <a href="move.html#topic+MoveStack">MoveStack</a> object. For a data frame, 
the trajectory data with four columns (the x-coordinate, the y-coordinate, the datetime, and the animal id).</p>
</td></tr>
<tr><td><code id="getRecursions_+3A_radius">radius</code></td>
<td>
<p>numeric radius to use in units of the (x,y) location data to detect recursions.</p>
</td></tr>
<tr><td><code id="getRecursions_+3A_threshold">threshold</code></td>
<td>
<p>a time difference (in units <code>timeunits</code>) to ignore excursions outside the radius. Defaults to 0.</p>
</td></tr>
<tr><td><code id="getRecursions_+3A_timeunits">timeunits</code></td>
<td>
<p>character string specifying units to calculate time differences in for the time spans inside the radius and since the 
visit in <code>revisitStats</code>. Defaults to hours.</p>
</td></tr>
<tr><td><code id="getRecursions_+3A_verbose">verbose</code></td>
<td>
<p><code>TRUE</code> to output complete information (can be large for large input data frames) or 
<code>FALSE</code> to output basic information.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For each point in the trajectory, a circle of radius R is drawn around that point.
Then the number of segments of the trajectory passing through that circle is counted. This is
the number of revisits, so each point will have at least one revisit (the initial visit). For each 
revisit, the time spent inside the circle is calculated, as well as the time since the last 
visit (NA for the first visit). In order to calculate the time values, the crossing time of the
radius is calculated by assuming linear movement at a constant speed between the points inside
and outside the circle.
</p>
<p><strong>Projection.</strong> Consider the projection used. Since segments are counted passing through circles
drawn around points, an equal area projection would ensure similar size comparisons (e.g., <code><a href="move.html#topic+spTransform">spTransform</a></code>). 
</p>
<p>Either single or multiple individuals are supported, but be aware that this function will be slow with
large amounts of data (e.g. millions of points), so consider pre-specifying the locations 
(<code><a href="#topic+getRecursionsAtLocations">getRecursionsAtLocations</a></code>) or use clustering. Multiple individuals are handled via the <code>id</code> column of the 
data.frame or using a <a href="move.html#topic+MoveStack">MoveStack</a> object.
</p>


<h3>Value</h3>

<p>A list with several components, <code>revisits</code> and <code>residenceTime</code>
are vectors of the same length as the <code>x</code> dataframe. <code>revisits</code> is the number of revisits for each 
location, where 1 means that there were 
no revisits, only the initial visit. <code>residenceTime</code> is the total time spent withing the radius. <code>radius</code>
is the specified radius used for all the calculations. <code>timeunits</code> is the specified time units used to specify
timespans.
</p>
<p>When <code>verbose = TRUE</code>, additional information 
is also returned, <code>dists</code> and <code>revisitStats</code>. Next, <code>dists</code> gives the distance matrix between
all locations. Finally, <code>revisitStats</code> gives further statistics on each visit. These are calculated 
per location (i.e., no aggregation of nearby points is performed), and give the index and location
of the point of the track at the center of the radius, the radius entrance and exit time of the track for that 
visit, how much time was spent inside the radius, and how long since the last visit (<code>NA</code> for the first visit).
</p>


<h3>Methods (by class)</h3>


<ul>
<li> <p><code>getRecursions(data.frame)</code>: Get recursions for a data.frame object consisting of columns x, y, datetime, and id
</p>
</li>
<li> <p><code>getRecursions(Move)</code>: Get recursions for a <a href="move.html#topic+Move-class">Move-class</a> object
</p>
</li>
<li> <p><code>getRecursions(MoveStack)</code>: Get recursions for a <a href="move.html#topic+MoveStack">MoveStack</a> object
</p>
</li></ul>


<h3>Author(s)</h3>

<p>Chloe Bracis &lt;cbracis@uw.edu&gt;
</p>


<h3>See Also</h3>

<p><code><a href="#topic+getRecursionsAtLocations">getRecursionsAtLocations</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(martin)
revisits = getRecursions(martin, radius = 1)
plot(revisits, martin, legendPos = c(10, -15))
drawCircle(10, -10, 1)

</code></pre>

<hr>
<h2 id='getRecursions3D'>Calculates recursion information from the 3D trajectory</h2><span id='topic+getRecursions3D'></span><span id='topic+getRecursions3D.data.frame'></span>

<h3>Description</h3>

<p>A sphere of radius R is drawn around each point in the trajectory. The number of
revisits is calculated as the number of segments of the trajectory passing through that sphere.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getRecursions3D(
  x,
  radius,
  threshold = 0,
  timeunits = c("hours", "secs", "mins", "days"),
  verbose = TRUE
)

## S3 method for class 'data.frame'
getRecursions3D(
  x,
  radius,
  threshold = 0,
  timeunits = c("hours", "secs", "mins", "days"),
  verbose = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getRecursions3D_+3A_x">x</code></td>
<td>
<p>A data frame with 
the trajectory data in five columns (the x-coordinate, the y-coordinate, the z-coordinate, the datetime, and the animal id).</p>
</td></tr>
<tr><td><code id="getRecursions3D_+3A_radius">radius</code></td>
<td>
<p>numeric radius to use in units of the (x,y,z) location data to detect recursions.</p>
</td></tr>
<tr><td><code id="getRecursions3D_+3A_threshold">threshold</code></td>
<td>
<p>a time difference (in units <code>timeunits</code>) to ignore excursions outside the radius. Defaults to 0.</p>
</td></tr>
<tr><td><code id="getRecursions3D_+3A_timeunits">timeunits</code></td>
<td>
<p>character string specifying units to calculate time differences in for the time spans inside the radius and since the 
visit in <code>revisitStats</code>. Defaults to hours.</p>
</td></tr>
<tr><td><code id="getRecursions3D_+3A_verbose">verbose</code></td>
<td>
<p><code>TRUE</code> to output complete information (can be large for large input data frames) or 
<code>FALSE</code> to output basic information.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For each point in the trajectory, a sphere of radius R is drawn around that point.
Then the number of segments of the trajectory passing through that sphere is counted. This is
the number of revisits, so each point will have at least one revisit (the initial visit). For each 
revisit, the time spent inside the sphere is calculated, as well as the time since the last 
visit (NA for the first visit). In order to calculate the time values, the crossing time of the
radius is calculated by assuming linear movement at a constant speed between the points inside
and outside the sphere.
</p>
<p><strong>Projection.</strong> Consider the projection used. Since segments are counted passing through spheres
drawn around points, an equal area projection would ensure similar size comparisons (e.g., <code><a href="move.html#topic+spTransform">spTransform</a></code>). 
</p>
<p>Either single or multiple individuals are supported, but be aware that this function will be slow with
large amounts of data (e.g. millions of points), so consider pre-specifying the locations 
(<code><a href="#topic+getRecursionsAtLocations">getRecursionsAtLocations</a></code>) or use clustering. Multiple individuals are handled via the <code>id</code> column of the 
data.frame.
</p>


<h3>Value</h3>

<p>A list with several components, <code>revisits</code> and <code>residenceTime</code>
are vectors of the same length as the <code>x</code> dataframe. <code>revisits</code> is the number of revisits for each 
location, where 1 means that there were 
no revisits, only the initial visit. <code>residenceTime</code> is the total time spent withing the radius. <code>radius</code>
is the specified radius used for all the calculations. <code>timeunits</code> is the specified time units used to specify
timespans.
</p>
<p>When <code>verbose = TRUE</code>, additional information 
is also returned, <code>dists</code> and <code>revisitStats</code>. Next, <code>dists</code> gives the distance matrix between
all locations. Finally, <code>revisitStats</code> gives further statistics on each visit. These are calculated 
per location (i.e., no aggregation of nearby points is performed), and give the index and location
of the point of the track at the center of the radius, the radius entrance and exit time of the track for that 
visit, how much time was spent inside the radius, and how long since the last visit (<code>NA</code> for the first visit).
</p>


<h3>Methods (by class)</h3>


<ul>
<li> <p><code>getRecursions3D(data.frame)</code>: Get recursions for a data.frame object consisting of columns x, y, z, datetime, and id
</p>
</li></ul>


<h3>Author(s)</h3>

<p>Chloe Bracis &lt;cbracis@uw.edu&gt;
</p>


<h3>See Also</h3>

<p><code><a href="#topic+getRecursions3DAtLocations">getRecursions3DAtLocations</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(martin)
revisits = getRecursions(martin, radius = 1)
plot(revisits, martin, legendPos = c(10, -15))
drawCircle(10, -10, 1)

</code></pre>

<hr>
<h2 id='getRecursions3DAtLocations'>Calculates recursion information from the 3D trajectory for specific locations</h2><span id='topic+getRecursions3DAtLocations'></span><span id='topic+getRecursions3DAtLocations.data.frame'></span>

<h3>Description</h3>

<p>A sphere of radius R is drawn around each specified location. The number of
revisits is calculated as the number of segments of the trajectory passing through that sphere.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getRecursions3DAtLocations(
  x,
  locations,
  radius,
  threshold = 0,
  timeunits = c("hours", "secs", "mins", "days"),
  verbose = TRUE
)

## S3 method for class 'data.frame'
getRecursions3DAtLocations(
  x,
  locations,
  radius,
  threshold = 0,
  timeunits = c("hours", "secs", "mins", "days"),
  verbose = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getRecursions3DAtLocations_+3A_x">x</code></td>
<td>
<p>A data frame with 
the trajectory data with five columns (the x-coordinate, the y-coordinate, the z-coordinate, the datetime, and the animal id).</p>
</td></tr>
<tr><td><code id="getRecursions3DAtLocations_+3A_locations">locations</code></td>
<td>
<p>A data frame with x and y locations at which to calculate the recursions.</p>
</td></tr>
<tr><td><code id="getRecursions3DAtLocations_+3A_radius">radius</code></td>
<td>
<p>numeric radius to use in units of the (x,y,z) location data to detect recursions.</p>
</td></tr>
<tr><td><code id="getRecursions3DAtLocations_+3A_threshold">threshold</code></td>
<td>
<p>a time difference (in units <code>timeunits</code>) to ignore excursions outside the radius. Defaults to 0.</p>
</td></tr>
<tr><td><code id="getRecursions3DAtLocations_+3A_timeunits">timeunits</code></td>
<td>
<p>character string specifying units to calculate time differences in for the time spans inside the radius and since the 
visit in <code>revisitStats</code>. Defaults to hours.</p>
</td></tr>
<tr><td><code id="getRecursions3DAtLocations_+3A_verbose">verbose</code></td>
<td>
<p><code>TRUE</code> to output complete information (can be large for large input data frames) or 
<code>FALSE</code> to output basic information.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For specified location, a sphere of radius R is drawn around that point. This method differs 
from <code><a href="#topic+getRecursions">getRecursions</a></code> in that only specified locations are used, rather than all points in the
trajectory.
Then the number of segments of the trajectory passing through that sphere is counted. This is
the number of revisits to that location. For each 
revisit, the time spent inside the sphere is calculated, as well as the time since the last 
visit (NA for the first visit). In order to calculate the time values, the crossing time of the
radius is calculated by assuming linear movement at a constant speed between the points inside
and outside the sphere.
</p>
<p><strong>Projection.</strong> Consider the projection used. Since segments are counted passing through spheres
drawn around points, an equal area projection would ensure similar size comparisons (e.g., <a href="move.html#topic+spTransform">spTransform</a>). 
</p>
<p>Either single or multiple individuals are supported, but be aware that this function will be slow with
large amounts of data (e.g. millions of points), so consider pre-specifying the locations 
(<code><a href="#topic+getRecursionsAtLocations">getRecursionsAtLocations</a></code>) or use clustering. Multiple individuals are handled via the <code>id</code> column of the 
data.frame.
</p>


<h3>Value</h3>

<p>A list with several components, <code>revisits</code> and <code>residenceTime</code>
are vectors of the same length as the <code>x</code> dataframe. <code>revisits</code> is the number of revisits for each 
location, where 1 means that there were 
no revisits, only the initial visit. <code>residenceTime</code> is the total time spent withing the radius. <code>radius</code>
is the specified radius used for all the calculations. <code>timeunits</code> is the specified time units used to specify
timespans.
</p>
<p>When <code>verbose = TRUE</code>, additional information 
is also returned, <code>dists</code> and <code>revisitStats</code>. Next, <code>dists</code> gives the distance matrix between
all locations. Finally, <code>revisitStats</code> gives further statistics on each visit. These are calculated 
per location (i.e., no aggregation of nearby points is performed), and give the index and location
of the point of the track at the center of the radius, the radius entrance and exit time of the track for that 
visit, how much time was spent inside the radius, and how long since the last visit (<code>NA</code> for the first visit).
</p>


<h3>Methods (by class)</h3>


<ul>
<li> <p><code>getRecursions3DAtLocations(data.frame)</code>: Get recursions at specified locations for a data.frame object
</p>
</li></ul>


<h3>Author(s)</h3>

<p>Chloe Bracis &lt;cbracis@uw.edu&gt;
</p>


<h3>See Also</h3>

<p><code><a href="#topic+getRecursions">getRecursions</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(martin)
locations = data.frame(x = c(-10, 0, 20), y = c(5, 0, 0))
revisits = getRecursionsAtLocations(martin, locations, radius = 1)
plot(revisits, locations, legendPos = c(10, -15), 
     alpha = 1, pch = 17, xlim = range(martin$x), ylim = range(martin$y))
points(martin$x, martin$y, pch = ".", col = "gray50")
drawCircle(10, -10, 1)

</code></pre>

<hr>
<h2 id='getRecursionsAtLocations'>Calculates recursion information from the trajectory for specific locations</h2><span id='topic+getRecursionsAtLocations'></span><span id='topic+getRecursionsAtLocations.data.frame'></span><span id='topic+getRecursionsAtLocations.Move'></span><span id='topic+getRecursionsAtLocations.MoveStack'></span>

<h3>Description</h3>

<p>A circle of radius R is drawn around each specified location. The number of
revisits is calculated as the number of segments of the trajectory passing through that circle.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getRecursionsAtLocations(
  x,
  locations,
  radius,
  threshold = 0,
  timeunits = c("hours", "secs", "mins", "days"),
  verbose = TRUE
)

## S3 method for class 'data.frame'
getRecursionsAtLocations(
  x,
  locations,
  radius,
  threshold = 0,
  timeunits = c("hours", "secs", "mins", "days"),
  verbose = TRUE
)

## S3 method for class 'Move'
getRecursionsAtLocations(
  x,
  locations,
  radius,
  threshold = 0,
  timeunits = c("hours", "secs", "mins", "days"),
  verbose = TRUE
)

## S3 method for class 'MoveStack'
getRecursionsAtLocations(
  x,
  locations,
  radius,
  threshold = 0,
  timeunits = c("hours", "secs", "mins", "days"),
  verbose = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getRecursionsAtLocations_+3A_x">x</code></td>
<td>
<p>Either a data frame, <a href="move.html#topic+Move-class">Move-class</a>, or <a href="move.html#topic+MoveStack">MoveStack</a> object. For a data frame, 
the trajectory data with four columns (the x-coordinate, the y-coordinate, the datetime, and the animal id).</p>
</td></tr>
<tr><td><code id="getRecursionsAtLocations_+3A_locations">locations</code></td>
<td>
<p>A data frame with x and y locations at which to calculate the recursions.</p>
</td></tr>
<tr><td><code id="getRecursionsAtLocations_+3A_radius">radius</code></td>
<td>
<p>numeric radius to use in units of the (x,y) location data to detect recursions.</p>
</td></tr>
<tr><td><code id="getRecursionsAtLocations_+3A_threshold">threshold</code></td>
<td>
<p>a time difference (in units <code>timeunits</code>) to ignore excursions outside the radius. Defaults to 0.</p>
</td></tr>
<tr><td><code id="getRecursionsAtLocations_+3A_timeunits">timeunits</code></td>
<td>
<p>character string specifying units to calculate time differences in for the time spans inside the radius and since the 
visit in <code>revisitStats</code>. Defaults to hours.</p>
</td></tr>
<tr><td><code id="getRecursionsAtLocations_+3A_verbose">verbose</code></td>
<td>
<p><code>TRUE</code> to output complete information (can be large for large input data frames) or 
<code>FALSE</code> to output basic information.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For specified location, a circle of radius R is drawn around that point. This method differs 
from <code><a href="#topic+getRecursions">getRecursions</a></code> in that only specified locations are used, rather than all points in the
trajectory.
Then the number of segments of the trajectory passing through that circle is counted. This is
the number of revisits to that location. For each 
revisit, the time spent inside the circle is calculated, as well as the time since the last 
visit (NA for the first visit). In order to calculate the time values, the crossing time of the
radius is calculated by assuming linear movement at a constant speed between the points inside
and outside the circle.
</p>
<p><strong>Projection.</strong> Consider the projection used. Since segments are counted passing through circles
drawn around points, an equal area projection would ensure similar size comparisons (e.g., <a href="move.html#topic+spTransform">spTransform</a>). 
</p>
<p>Either single or multiple individuals are supported, but be aware that this function will be slow with
large amounts of data (e.g. millions of points), so consider pre-specifying the locations 
(<code><a href="#topic+getRecursionsAtLocations">getRecursionsAtLocations</a></code>) or use clustering. Multiple individuals are handled via the <code>id</code> column of the 
data.frame or using a <a href="move.html#topic+MoveStack">MoveStack</a> object.
</p>


<h3>Value</h3>

<p>A list with several components, <code>revisits</code> and <code>residenceTime</code>
are vectors of the same length as the <code>x</code> dataframe. <code>revisits</code> is the number of revisits for each 
location, where 1 means that there were 
no revisits, only the initial visit. <code>residenceTime</code> is the total time spent withing the radius. <code>radius</code>
is the specified radius used for all the calculations. <code>timeunits</code> is the specified time units used to specify
timespans.
</p>
<p>When <code>verbose = TRUE</code>, additional information 
is also returned, <code>dists</code> and <code>revisitStats</code>. Next, <code>dists</code> gives the distance matrix between
all locations. Finally, <code>revisitStats</code> gives further statistics on each visit. These are calculated 
per location (i.e., no aggregation of nearby points is performed), and give the index and location
of the point of the track at the center of the radius, the radius entrance and exit time of the track for that 
visit, how much time was spent inside the radius, and how long since the last visit (<code>NA</code> for the first visit).
</p>


<h3>Methods (by class)</h3>


<ul>
<li> <p><code>getRecursionsAtLocations(data.frame)</code>: Get recursions at specified locations for a data.frame object
</p>
</li>
<li> <p><code>getRecursionsAtLocations(Move)</code>: Get recursions at specified locations for a <a href="move.html#topic+Move-class">Move-class</a> object
</p>
</li>
<li> <p><code>getRecursionsAtLocations(MoveStack)</code>: Get recursions at specified locations for a <a href="move.html#topic+MoveStack">MoveStack</a> object
</p>
</li></ul>


<h3>Author(s)</h3>

<p>Chloe Bracis &lt;cbracis@uw.edu&gt;
</p>


<h3>See Also</h3>

<p><code><a href="#topic+getRecursions">getRecursions</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(martin)
locations = data.frame(x = c(-10, 0, 20), y = c(5, 0, 0))
revisits = getRecursionsAtLocations(martin, locations, radius = 1)
plot(revisits, locations, legendPos = c(10, -15), 
     alpha = 1, pch = 17, xlim = range(martin$x), ylim = range(martin$y))
points(martin$x, martin$y, pch = ".", col = "gray50")
drawCircle(10, -10, 1)

</code></pre>

<hr>
<h2 id='getRecursionsInPolygon.Move'>Calculates recursion information from the trajectory inside a polygon</h2><span id='topic+getRecursionsInPolygon.Move'></span><span id='topic+getRecursionsInPolygon'></span><span id='topic+getRecursionsInPolygon.data.frame'></span><span id='topic+getRecursionsInPolygon.MoveStack'></span>

<h3>Description</h3>

<p>The number of  revisits to a polygon is calculated as the number of segments of the trajectory 
passing through the polygon.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'Move'
getRecursionsInPolygon(
  trajectory,
  polygon,
  threshold = 0,
  timeunits = c("hours", "secs", "mins", "days"),
  verbose = TRUE
)

getRecursionsInPolygon(
  trajectory,
  polygon,
  threshold = 0,
  timeunits = c("hours", "secs", "mins", "days"),
  verbose = TRUE
)

## S3 method for class 'data.frame'
getRecursionsInPolygon(
  trajectory,
  polygon,
  threshold = 0,
  timeunits = c("hours", "secs", "mins", "days"),
  verbose = TRUE
)

## S3 method for class 'MoveStack'
getRecursionsInPolygon(
  trajectory,
  polygon,
  threshold = 0,
  timeunits = c("hours", "secs", "mins", "days"),
  verbose = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getRecursionsInPolygon.Move_+3A_trajectory">trajectory</code></td>
<td>
<p>A data frame with four columns (the x-coordinate, the y-coordinate, the datetime, and the animal id).</p>
</td></tr>
<tr><td><code id="getRecursionsInPolygon.Move_+3A_polygon">polygon</code></td>
<td>
<p>A <a href="sf.html#topic+st_polygon">st_polygon</a> object with a single convex polygon.</p>
</td></tr>
<tr><td><code id="getRecursionsInPolygon.Move_+3A_threshold">threshold</code></td>
<td>
<p>A time difference (in units <code>timeunits</code>) to ignore excursions outside the radius. Defaults to 0.</p>
</td></tr>
<tr><td><code id="getRecursionsInPolygon.Move_+3A_timeunits">timeunits</code></td>
<td>
<p>Character string specifying units to calculate time differences in for the time spans inside the radius and since the 
visit in <code>revisitStats</code>. Defaults to hours.</p>
</td></tr>
<tr><td><code id="getRecursionsInPolygon.Move_+3A_verbose">verbose</code></td>
<td>
<p><code>TRUE</code> to output complete information (can be large for large input data frames) or 
<code>FALSE</code> to output basic information.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The number of segments of the trajectory passing through the polygon is counted as 
the number of revisits. For each  revisit, the time spent inside the polygon is calculated, as 
well as the time since the last visit (NA for the first visit). In order to calculate the time values, 
the crossing time of the polygon is calculated by assuming linear movement at a constant speed between 
the points inside and outside the polygon. Note the polygon must be convex as described in further detail below.
</p>
<p><strong>Projection.</strong> Consider the projection used. Since segments are counted passing through the
polygon, an equal area projection would ensure similar size comparisons (e.g., <a href="move.html#topic+spTransform">spTransform</a>). 
A geographic projection is not appropriate. The projection for the 
polygon and the trajectory must be the same.
</p>
<p><strong>Polygon.</strong> The polygon must be specified as a <a href="sf.html#topic+st_polygon">st_polygon</a> object. It should consist
of a single polygon (i.e. <a href="sf.html#topic+st_geometry_type">st_geometry_type</a> = POLYGON). It should further be convex, though this
requirement is not enforced, calculations for non-convex polygons will not necessarily be accurate. It may
be advantageous to simplify complex geometry in order to shorten the time to run. If it is necessary to use a
non-convex polygon, one approach would be to split it into convex pieces that can be run one-by-one. However,
some visits would then be double-counted and would need to be combined back together based on the
entrance/exit times and sequence of trajectory locations. Multiple polygons would need to be handled with multiple
calls with the output then concatenated together.
</p>
<p>Either single or multiple individuals are supported, but be aware that this function will be slow with
large amounts of data (e.g. millions of points). Multiple individuals are handled via the <code>id</code> column of the 
data.frame.
</p>


<h3>Value</h3>

<p>A list with several components. <code>revisits</code> is the number of revisits to the polygon. <code>residenceTime</code> is the total time 
spent withing the polygon. <code>radius</code> is NA in the case of polygons. <code>timeunits</code> is the specified time units used to specify timespans.
</p>
<p>When <code>verbose = TRUE</code>, additional information 
is also returned in <code>revisitStats</code>. Next, <code>dists</code> gives the distance matrix between
all locations. Finally, <code>revisitStats</code> gives further statistics on each visit. These are calculated 
per location (i.e., no aggregation of nearby points is performed), and give the index and location
of the point of the track at the center of the radius (NA and 1 in the case of polygons), the radius entrance and exit time of the track for that 
visit, how much time was spent inside the radius, and how long since the last visit (<code>NA</code> for the first visit).
</p>


<h3>Methods (by class)</h3>


<ul>
<li> <p><code>getRecursionsInPolygon(Move)</code>: Get recursions in polygon for a <a href="move.html#topic+Move-class">Move-class</a> trajectory
</p>
</li>
<li> <p><code>getRecursionsInPolygon(data.frame)</code>: Get recursions inside a polygon for a trajectory data.frame object consisting of columns x, y, datetime, and id
</p>
</li>
<li> <p><code>getRecursionsInPolygon(MoveStack)</code>: Get recursions in polygon for a <a href="move.html#topic+MoveStack">MoveStack</a> trajectory
</p>
</li></ul>


<h3>Author(s)</h3>

<p>Chloe Bracis &lt;cbracis@uw.edu&gt;
</p>


<h3>See Also</h3>

<p><code><a href="#topic+getRecursions">getRecursions</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(track)
poly = sf::st_polygon(list(cbind(c(4,6,6,3,4), c(1,2,4,3,1))))
poly = sf::st_sfc(poly, crs = "EPSG:3410")
revisits = getRecursionsInPolygon(track, poly)
</code></pre>

<hr>
<h2 id='martin'>Sample trajectory (martin).</h2><span id='topic+martin'></span>

<h3>Description</h3>

<p>A dataset containing a sample trajectory with revisits.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(martin)
</code></pre>


<h3>Format</h3>

<p>A data frame with 600 rows and 4 columns
</p>


<h3>Details</h3>


<ul>
<li><p> x. x-coordinate
</p>
</li>
<li><p> y. y-coordinate
</p>
</li>
<li><p> t. time
</p>
</li>
<li><p> id. identifier
</p>
</li></ul>


<hr>
<h2 id='plot.recurse'>Calculates recursion information from the trajectory</h2><span id='topic+plot.recurse'></span>

<h3>Description</h3>

<p>Plots a trajectory color coded by number of revisits to each point.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'recurse'
plot(x, xyt, ..., col, alpha = 1, legendPos = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.recurse_+3A_x">x</code></td>
<td>
<p><code>recurse</code> object returned from call to <code><a href="#topic+getRecursions">getRecursions</a></code></p>
</td></tr>
<tr><td><code id="plot.recurse_+3A_xyt">xyt</code></td>
<td>
<p>data.frame of x, y, t, and id representing the xy-coordinates and the time (same as call to <code><a href="#topic+getRecursions">getRecursions</a></code>)</p>
</td></tr>
<tr><td><code id="plot.recurse_+3A_...">...</code></td>
<td>
<p>additional arguments to <code><a href="graphics.html#topic+plot">plot</a></code></p>
</td></tr>
<tr><td><code id="plot.recurse_+3A_col">col</code></td>
<td>
<p>optional vector of colors as long as the maximum number of revisits to color code trajectory points</p>
</td></tr>
<tr><td><code id="plot.recurse_+3A_alpha">alpha</code></td>
<td>
<p>optional alpha value for color transparency between 0 and 1</p>
</td></tr>
<tr><td><code id="plot.recurse_+3A_legendpos">legendPos</code></td>
<td>
<p>a vector of length 2 with the x and y coordinate of the center of the legend in user coordinates</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This method allows the user to visually represent the number of revisitations by location. The size
of the circle of radius R can be added to the plot with <code><a href="#topic+drawCircle">drawCircle</a></code>.
</p>


<h3>Value</h3>

<p>the plot
</p>


<h3>Author(s)</h3>

<p>Chloe Bracis &lt;cbracis@uw.edu&gt;
</p>


<h3>See Also</h3>

<p><code><a href="#topic+getRecursions">getRecursions</a></code>, <code><a href="#topic+getRecursionsAtLocations">getRecursionsAtLocations</a></code>, <code><a href="#topic+drawCircle">drawCircle</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(martin)
revisits = getRecursions(martin, radius = 1)
plot(revisits, martin, legendPos = c(10, -15))
drawCircle(10, -10, 1)

</code></pre>

<hr>
<h2 id='recurse'>Computes revisitation metrics for trajectory data</h2><span id='topic+recurse'></span>

<h3>Description</h3>

<p>Computes revisitation metrics for trajectory data, such as the number of revisitations for each location 
as well as the time spent for that visit and the time since the previous visit. Also includes functions to 
plot data.
</p>


<h3>Details</h3>

<p>The function <code><a href="#topic+getRecursions">getRecursions</a></code> computes the revisit metrics, which can be plotted with 
<code><a href="#topic+plot.recurse">plot.recurse</a></code>. Alternatively, <code><a href="#topic+getRecursionsAtLocations">getRecursionsAtLocations</a></code> computes revisit metrics
for specified locations, rather than all locations in the movement trajectory.
</p>


<h3>Author(s)</h3>

<p>Chloe Bracis &lt;cbracis@uw.edu&gt;
</p>

<hr>
<h2 id='track'>Sample trajectory (track).</h2><span id='topic+track'></span>

<h3>Description</h3>

<p>A dataset containing a sample trajectory with revisits.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(track)
</code></pre>


<h3>Format</h3>

<p>A data frame with 100 rows and 4 columns
</p>


<h3>Details</h3>


<ul>
<li><p> x. x-coordinate
</p>
</li>
<li><p> y. y-coordinate
</p>
</li>
<li><p> t. time
</p>
</li>
<li><p> id. identifier
</p>
</li></ul>


<hr>
<h2 id='wren'>Sample trajectory (wren).</h2><span id='topic+wren'></span>

<h3>Description</h3>

<p>A dataset containing a sample trajectory with revisits.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(wren)
</code></pre>


<h3>Format</h3>

<p>A data frame with 600 rows and 4 columns
</p>


<h3>Details</h3>


<ul>
<li><p> x. x-coordinate
</p>
</li>
<li><p> y. y-coordinate
</p>
</li>
<li><p> t. time
</p>
</li>
<li><p> id. identifier
</p>
</li></ul>


</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
