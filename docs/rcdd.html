<!DOCTYPE html><html lang="en"><head><title>Help for package rcdd</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {rcdd}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#allfaces'><p>All Faces of a Convex Polyhedron</p></a></li>
<li><a href='#ArithmeticGMP'><p>GMP Rational Arithmetic</p></a></li>
<li><a href='#ConvertGMP'><p>Convert Between Real, Integer, and GMP Rational</p></a></li>
<li><a href='#linearity'><p>Find implicit linearities in H-representation and V-representation</p>
of convex polyhedron</a></li>
<li><a href='#lpcdd'><p>linear programming with exact arithmetic</p></a></li>
<li><a href='#makeH'><p>make H-representation of convex polyhedron</p></a></li>
<li><a href='#makeV'><p>make V-representation of convex polyhedron</p></a></li>
<li><a href='#qgram'><p>GMP Rational Gram-Schmidt</p></a></li>
<li><a href='#redundant'><p>Eliminate redundant rows of H-representation and V-representation</p></a></li>
<li><a href='#scdd'><p>Go between H-representation and V-representation of convex polyhedron</p></a></li>
<li><a href='#Subset'><p>subsets and maximal sets</p></a></li>
<li><a href='#validcdd'><p>validate an H-representation or V-representation of convex polyhedron</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Version:</td>
<td>1.6</td>
</tr>
<tr>
<td>Date:</td>
<td>2023-12-14</td>
</tr>
<tr>
<td>Title:</td>
<td>Computational Geometry</td>
</tr>
<tr>
<td>Author:</td>
<td>Charles J. Geyer &lt;geyer@umn.edu&gt; and
    Glen D. Meeden &lt;gmeeden@umn.edu&gt;, incorporates code from
    cddlib (ver 0.94f) written by Komei Fukuda &lt;fukuda@ifor.math.ethz.ch&gt;</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Charles J. Geyer &lt;geyer@umn.edu&gt;</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.0.2)</td>
</tr>
<tr>
<td>Imports:</td>
<td>methods</td>
</tr>
<tr>
<td>SystemRequirements:</td>
<td>GMP (GNU MP bignum library from
&lt;https://gmplib.org/&gt;)</td>
</tr>
<tr>
<td>Description:</td>
<td>R interface to (some of) cddlib
    (<a href="https://github.com/cddlib/cddlib">https://github.com/cddlib/cddlib</a>).
    Converts back and forth between two representations of a convex polytope:
    as solution of a set of linear equalities and inequalities and as
    convex hull of set of points and rays.
    Also does linear programming and redundant generator elimination
    (for example, convex hull in n dimensions).  All functions can use exact
    infinite-precision rational arithmetic.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a></td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://www.stat.umn.edu/geyer/rcdd/">https://www.stat.umn.edu/geyer/rcdd/</a>,
<a href="https://github.com/cjgeyer/rcdd">https://github.com/cjgeyer/rcdd</a></td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-12-14 16:53:06 UTC; geyer</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-12-15 09:40:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='allfaces'>All Faces of a Convex Polyhedron</h2><span id='topic+allfaces'></span>

<h3>Description</h3>

<p>List all the nonempty faces of a convex polyhedron, giving for each
the dimension, the active set of constraints, and a relative interior point.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>allfaces(hrep)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="allfaces_+3A_hrep">hrep</code></td>
<td>
<p>H-representation of convex polyhedron (see details).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>See <code>cddlibman.pdf</code> in the <code>doc</code> directory of this package,
especially Sections 1 and 2.
</p>
<p>This function lists all nonempty faces of a convex polyhedron
given by the H-representation given by the matrix <code>hrep</code>.
Let
</p>
<pre>
      l &lt;- hrep[ , 1]
      b &lt;- hrep[ , 2]
      v &lt;- hrep[ , - c(1, 2)]
      a &lt;- (- v)
  </pre>
<p>Then the convex polyhedron in question is the set of
points <code>x</code> satisfying
</p>
<pre>
      axb &lt;- a %*% x - b
      all(axb &lt;= 0)
      all(l * axb == 0)
  </pre>
<p>A nonempty <em>face</em> of a convex polyhedron <code class="reqn">P</code> is the subset
of <code class="reqn">P</code> that is the set of points over which some linear function
achieves its
maximum over <code class="reqn">P</code>.  Note that <code class="reqn">P</code> is a face of <code class="reqn">P</code> and appears
in the list of faces.  By definition the empty set is also a face, but
is not listed.   These two faces are said to be <em>improper</em>, the
other faces are <em>proper</em>.
</p>
<p>A face in the listing is characterized by the set of constraints that
are <em>active</em>, i. e., satisfied with equality, on the face.
</p>
<p>The <em>relative interior</em> of a convex set its its interior considered
as a subset of its affine hull.  The relative interior of
a one-point set is that point.  The relative interior of a multi-point
convex set is the union of open line segments <code class="reqn">(x, y)</code> with endpoints
<code class="reqn">x</code> and <code class="reqn">y</code> in the set.
</p>


<h3>Value</h3>

<p>a list containing the following components:
</p>
<table role = "presentation">
<tr><td><code>dimension</code></td>
<td>
<p>list of integers giving the dimensions of the faces.</p>
</td></tr>
<tr><td><code>active.set</code></td>
<td>
<p>list of integer vectors giving for each face the
set of constraints that are active (satisfied with equality) on
the face, the integers referring to row numbers of <code>hrep</code>.</p>
</td></tr>
<tr><td><code>relative.interior.point</code></td>
<td>
<p>list of double or character vectors
(same type as <code>hrep</code>)
giving a point in the relative interior of each face.</p>
</td></tr>
</table>


<h3>Rational Arithmetic</h3>

<p>The argument <code>hrep</code> may
have type <code>"character"</code> in which case its elements are interpreted
as unlimited precision rational numbers.  They consist of an optional
minus sign, a string of digits of any length (the numerator),
a slash, and another string of digits of any length (the denominator).
The denominator must be positive.  If the denominator is one, the
slash and the denominator may be omitted.  This package
provides several functions (see <a href="#topic+ConvertGMP">ConvertGMP</a> and <a href="#topic+ArithmeticGMP">ArithmeticGMP</a>)
for conversion back and forth between R floating point numbers and rationals
and for arithmetic on GMP rationals.
</p>


<h3>Warning</h3>

<p>If you want correct answers, use rational arithmetic.  If you do not,
this function may (1) produce approximately correct answers, (2) fail with
an error, (3) give answers that are nowhere near correct with no error or
warning, or (4) crash R losing all work done to that point.  In large
simulations (1) is most frequent, (2) occurs roughly one time in a thousand,
(3) occurs roughly one time in ten thousand, and (4) has only occurred once
and only with the <code><a href="#topic+redundant">redundant</a></code> function.  So the R floating point
arithmetic version does mostly work, but you cannot trust its results unless
you can check them independently.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+scdd">scdd</a></code>, <code><a href="#topic+ArithmeticGMP">ArithmeticGMP</a></code>,
<code><a href="#topic+ConvertGMP">ConvertGMP</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>hrep &lt;- rbind(c(0, 1,  1,  1, -1),
              c(0, 1,  1, -1, -1),
              c(0, 1, -1, -1, -1),
              c(0, 1, -1,  1, -1),
              c(0, 0,  0,  0,  1))

allfaces(d2q(hrep))
</code></pre>

<hr>
<h2 id='ArithmeticGMP'>GMP Rational Arithmetic</h2><span id='topic+ArithmeticGMP'></span><span id='topic+qpq'></span><span id='topic+qmq'></span><span id='topic+qxq'></span><span id='topic+qdq'></span><span id='topic+qneg'></span><span id='topic+qabs'></span><span id='topic+qinv'></span><span id='topic+qsum'></span><span id='topic+qprod'></span><span id='topic+qmax'></span><span id='topic+qmin'></span><span id='topic+qsign'></span><span id='topic+qmatmult'></span>

<h3>Description</h3>

<p>Add, subtract, multiply, or divide one object to/from/by another using
GMP (GNU multiple precision) rational arithmetic.
Any size integers in the numerator and denominator are allowed.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>qpq(x, y)
qmq(x, y)
qxq(x, y)
qdq(x, y)
qmatmult(x, y)
qsum(x)
qprod(x)
qmax(x)
qmin(x)
qsign(x)
qneg(x)
qabs(x)
qinv(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ArithmeticGMP_+3A_x">x</code>, <code id="ArithmeticGMP_+3A_y">y</code></td>
<td>
<p>objects of type <code>"numeric"</code>
or <code>"character"</code>.  If <code>"numeric"</code> are converted to rational
using <code><a href="#topic+d2q">d2q</a></code>.  Objects must have the same length.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>qpq</code> is &ldquo;plus&rdquo;,
<code>qmq</code> is &ldquo;minus&rdquo;,
<code>qxq</code> is &ldquo;times&rdquo;,
<code>qdq</code> is &ldquo;divide&rdquo;.
Divide by zero is an error.  There are no rational NA, NaN, Inf.
<code>qsum</code> is vectorizing summation like <code>sum</code> for ordinary numeric.
<code>qprod</code> is vectorizing product like <code>prod</code> for ordinary numeric.
<code>qmax</code> is like <code>max</code> for ordinary numeric.
<code>qmin</code> is like <code>min</code> for ordinary numeric.
<code>qsign</code> is vectorizing sign like <code>sign</code> for ordinary numeric.
<code>qmatmult</code> is matrix multiplication like <code>%*%</code> for ordinary
numeric; both arguments must be matrices.
<code>qneg</code> is vectorizing negation like unary minus for ordinary numeric.
<code>qabs</code> is vectorizing absolute value like <code>abs</code> for ordinary numeric.
<code>qinv</code> is vectorizing inversion like <code>1 / x</code> for ordinary numeric.
</p>


<h3>Value</h3>

<p>an object of the same form as <code>x</code> that is the sum, difference,
product, quotient, or sign or (for <code>qsum</code> and <code>qprod</code>)
a scalar that is the sum or product.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+ConvertGMP">ConvertGMP</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>qmq("1/3", "1/2")
# note inexactness of floating point representations
qmq("1/5", 1/5)
qdq("1/5", 1/5)
qsum(c("1", "1/2", "1/4", "1/8"))
qprod(c("1", "1/2", "1/4", "1/8"))
qmax(c("-1", "1/2", "1/-4", "1/8"))
qmin(c("-1", "1/2", "1/-4", "1/8"))
qsign(c("-1", "1/2", "1/-4", "1/8"))
qmatmult(matrix(c("1", "2", "3", "4"), 2, 2),
    matrix(c("1/1", "1/2", "1/3", "1/4"), 2, 2))
qneg(seq(-3, 3))
</code></pre>

<hr>
<h2 id='ConvertGMP'>Convert Between Real, Integer, and GMP Rational</h2><span id='topic+ConvertGMP'></span><span id='topic+d2q'></span><span id='topic+q2d'></span><span id='topic+q2q'></span><span id='topic+z2q'></span>

<h3>Description</h3>

<p>Converts to and from GMP (GNU multiple precision) rational numbers.
Any size integers in the numerator and denominator are allowed.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>d2q(x)
q2d(x)
q2q(x)
z2q(numer, denom, canonicalize = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ConvertGMP_+3A_x">x</code>, <code id="ConvertGMP_+3A_numer">numer</code>, <code id="ConvertGMP_+3A_denom">denom</code></td>
<td>
<p>objects of type <code>"numeric"</code>
or <code>"character"</code>.</p>
</td></tr>
<tr><td><code id="ConvertGMP_+3A_canonicalize">canonicalize</code></td>
<td>
<p>if <code>TRUE</code> (the default) canonicalize (see below).</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>d2q</code> converts from real to rational,
<code>q2d</code> converts from rational to real,
<code>q2q</code> canonicalizes (no common factors in numerator and denominator)
rationals,
<code>z2q</code> converts integer numerator and denominator to rational
canonicalizing if <code>canonicalize = TRUE</code> (the default).
</p>


<h3>See Also</h3>

<p><code><a href="#topic+ArithmeticGMP">ArithmeticGMP</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>d2q(runif(1))
q2d("-123456789123456789987654321/33")
z2q(44, 11)
</code></pre>

<hr>
<h2 id='linearity'>Find implicit linearities in H-representation and V-representation
of convex polyhedron</h2><span id='topic+linearity'></span>

<h3>Description</h3>

<p>Given V-representation (convex hull of points and directions)
or H-representation (intersection of half spaces) of convex polyhedron
find non-linearity generators that can be made linearity without
changing polyhedron
</p>


<h3>Usage</h3>

<pre><code class='language-R'>linearity(input, representation = c("H", "V"))
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="linearity_+3A_input">input</code></td>
<td>
<p>either H-representation or V-representation of
convex polyhedron (see details).</p>
</td></tr>
<tr><td><code id="linearity_+3A_representation">representation</code></td>
<td>
<p>if <code>"H"</code>, then <code>input</code> is
an H-representation, otherwise a V-representation.  May also be
obtained from a <code>"representation"</code> attribute of <code>input</code>,
if present.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Interface to the function <code>dd_ImpliedLinearityRows</code> of the
<code>cddlib</code> library,
see <code>cddlibman.pdf</code> in the <code>doc</code> directory of this package,
especially Sections 1 and 2 and page 9.
See also <code><a href="#topic+scdd">scdd</a></code> for a description of the way this package
codes H-representations and V-representations as R matrices.
</p>
<p>A row of a matrix that is an H-representation or V-representation is
a linearity row if the first element of that row is 1.  The row is
an implied linearity row if the first element of that row is 0 but
if it were 1 the convex polyhedron described would be unchanged.
</p>
<p>The interpretation is as follows.  For an H-representation, the
linearity (given plus implied) determines the affine hull of the
polyhedron (the smallest translate of a subspace containing it).
For a V-representation, the linearity (given plus implied) determines
the smallest affine set (translate of a subspace) contained in the
polyhedron.
</p>


<h3>Value</h3>

<p>a numeric vector, the indices of the implied linearity rows.
(Note: rows that are linearity rows in the input matrix are not
contained in this vector.)
</p>


<h3>Rational Arithmetic</h3>

<p>The input representation may
have type <code>"character"</code> in which case its elements are interpreted
as unlimited precision rational numbers.  They consist of an optional
minus sign, a string of digits of any length (the numerator),
a slash, and another string of digits of any length (the denominator).
The denominator must be positive.  If the denominator is one, the
slash and the denominator may be omitted.  This package
provides several functions (see <a href="#topic+ConvertGMP">ConvertGMP</a> and <a href="#topic+ArithmeticGMP">ArithmeticGMP</a>)
for conversion back and forth between R floating point numbers and rationals
and for arithmetic on GMP rationals.
</p>


<h3>Warning</h3>

<p>If you want correct answers, use rational arithmetic.  If you do not,
this function may (1) produce approximately correct answers, (2) fail with
an error, (3) give answers that are nowhere near correct with no error or
warning, or (4) crash R losing all work done to that point.  In large
simulations (1) is most frequent, (2) occurs roughly one time in a thousand,
(3) occurs roughly one time in ten thousand, and (4) has only occurred once
and only with the <code><a href="#topic+redundant">redundant</a></code> function.  So the R floating point
arithmetic version does mostly work, but you cannot trust its results unless
you can check them independently.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+ArithmeticGMP">ArithmeticGMP</a></code>, <code><a href="#topic+ConvertGMP">ConvertGMP</a></code>,
<code><a href="#topic+validcdd">validcdd</a></code>, <code><a href="#topic+makeH">makeH</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>### calculate affine hull
### determined by given + implied linearity rows
qux &lt;- rbind(c(0, 2, 0, 0, 1),
             c(0, 3, 1, 0, 0),
             c(0, 4, 0, 1, 0),
             c(0, -7, -1, -1, 0))
out &lt;- linearity(qux, representation = "H")
print(out)
qux[out, 1] &lt;- 1
redundant(qux, representation = "H")$output

### calculate minimal nonempty face of polyhedral convex cone
### determined by given + implied linearity rows
qux &lt;- rbind(c(0, 0, 0, 0, 1),
             c(0, 0, 1, 0, 0),
             c(0, 0, 0, 1, 0),
             c(0, 0, -1, -1, 0))
out &lt;- linearity(qux, representation = "V")
print(out)
redundant(qux, representation = "V")$output
</code></pre>

<hr>
<h2 id='lpcdd'>linear programming with exact arithmetic</h2><span id='topic+lpcdd'></span>

<h3>Description</h3>

<p>Solve linear program or explain why it has no solution.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lpcdd(hrep, objgrd, objcon, minimize = TRUE,
    solver = c("DualSimplex", "CrissCross"))
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="lpcdd_+3A_hrep">hrep</code></td>
<td>
<p>H-representation of convex polyhedron (see details) over
which an affine function is maximized or minimized.</p>
</td></tr>
<tr><td><code id="lpcdd_+3A_objgrd">objgrd</code></td>
<td>
<p>gradient vector of affine function.</p>
</td></tr>
<tr><td><code id="lpcdd_+3A_objcon">objcon</code></td>
<td>
<p>constant term of affine function. May be missing, in
which case, taken to be zero.</p>
</td></tr>
<tr><td><code id="lpcdd_+3A_minimize">minimize</code></td>
<td>
<p>minimize if <code>TRUE</code>, otherwise maximize.</p>
</td></tr>
<tr><td><code id="lpcdd_+3A_solver">solver</code></td>
<td>
<p>type of solver.  Use the default unless you know better.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>See <code>cddlibman.pdf</code> in the <code>doc</code> directory of this package,
especially Sections 1 and 2 and the documentation of the function
<code>dd_LPSolve</code> in Section 4.2.
</p>
<p>This function minimizes or maximizes an affine function <code>x</code>
maps to <code>sum(objgrd * x) + objcon</code> over a convex polyhedron
given by the H-representation given by the matrix <code>hrep</code>.
Let
</p>
<pre>
      l &lt;- hrep[ , 1]
      b &lt;- hrep[ , 2]
      v &lt;- hrep[ , - c(1, 2)]
      a &lt;- (- v)
  </pre>
<p>Then the convex polyhedron in question is the set of
points <code>x</code> satisfying
</p>
<pre>
      axb &lt;- a %*% x - b
      all(axb &lt;= 0)
      all(l * axb == 0)
  </pre>


<h3>Value</h3>

<p>a list containing some of the following components:
</p>
<table role = "presentation">
<tr><td><code>solution.type</code></td>
<td>
<p>character string describing the solution type.
<code>"Optimal"</code> indicates the optimum is achieved.
<code>"Inconsistent"</code> indicates the feasible region is empty
(no points satisfy the constraints, the polyhedron specified
by <code>hrep</code> is empty).
<code>"DualInconsistent"</code> or <code>"StrucDualInconsistent"</code> indicates
the feasible region is unbounded
and the objective function is unbounded below when <code>minimize = TRUE</code>
or above when <code>minimize = FALSE</code>.</p>
</td></tr>
<tr><td><code>primal.solution</code></td>
<td>
<p>Returned only when <code>solution.type = "Optimal"</code>,
the solution to the stated (primal) problem.</p>
</td></tr>
<tr><td><code>dual.solution</code></td>
<td>
<p>Returned only when <code>solution.type = "Optimal"</code>,
the solution to the dual problem, Lagrange multipliers for the primal
problem.</p>
</td></tr>
<tr><td><code>dual.direction</code></td>
<td>
<p>Returned only when
<code>solution.type = "Inconsistent"</code>,
coefficients of a linear combination of original inequalities
and equalities that proves the inconsistency.  Coefficients for original
inequalities are nonnegative.</p>
</td></tr>
<tr><td><code>primal.direction</code></td>
<td>
<p>Returned only when
<code>solution.type = "DualInconsistent"</code>
or <code>solution.type = "StrucDualInconsistent"</code>,
coefficients of the linear combination of columns
that proves the dual inconsistency, also an unbounded direction
for the primal LP.</p>
</td></tr>
</table>


<h3>Rational Arithmetic</h3>

<p>The arguments <code>hrep</code>, <code>objgrd</code>, and <code>objcon</code> may
have type <code>"character"</code> in which case their elements are interpreted
as unlimited precision rational numbers.  They consist of an optional
minus sign, a string of digits of any length (the numerator),
a slash, and another string of digits of any length (the denominator).
The denominator must be positive.  If the denominator is one, the
slash and the denominator may be omitted.  This package
provides several functions (see <a href="#topic+ConvertGMP">ConvertGMP</a> and <a href="#topic+ArithmeticGMP">ArithmeticGMP</a>)
for conversion back and forth between R floating point numbers and rationals
and for arithmetic on GMP rationals.
</p>


<h3>Warning</h3>

<p>If you want correct answers, use rational arithmetic.  If you do not,
this function may (1) produce approximately correct answers, (2) fail with
an error, (3) give answers that are nowhere near correct with no error or
warning, or (4) crash R losing all work done to that point.  In large
simulations (1) is most frequent, (2) occurs roughly one time in a thousand,
(3) occurs roughly one time in ten thousand, and (4) has only occurred once
and only with the <code><a href="#topic+redundant">redundant</a></code> function.  So the R floating point
arithmetic version does mostly work, but you cannot trust its results unless
you can check them independently.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+scdd">scdd</a></code>, <code><a href="#topic+ArithmeticGMP">ArithmeticGMP</a></code>,
<code><a href="#topic+ConvertGMP">ConvertGMP</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'># first two rows are inequalities, second two equalities
hrep &lt;- rbind(c("0", "0", "1", "1", "0", "0"),
              c("0", "0", "0", "2", "0", "0"),
              c("1", "3", "0", "-1", "0", "0"),
              c("1", "9/2", "0", "0", "-1", "-1"))
a &lt;- c("2", "3/5", "0", "0")
lpcdd(hrep, a)

# primal inconsistent problem
hrep &lt;- rbind(c("0", "0", "1", "0"),
              c("0", "0", "0", "1"),
              c("0", "-2", "-1", "-1"))
a &lt;- c("1", "1")
lpcdd(hrep, a)

# dual inconsistent problem
hrep &lt;- rbind(c("0", "0", "1", "0"),
              c("0", "0", "0", "1"))
a &lt;- c("1", "1")
lpcdd(hrep, a, minimize = FALSE)
</code></pre>

<hr>
<h2 id='makeH'>make H-representation of convex polyhedron</h2><span id='topic+makeH'></span><span id='topic+addHeq'></span><span id='topic+addHin'></span>

<h3>Description</h3>

<p>Construct H-representation of convex polyhedron,
set of points <code>x</code> satisfying
</p>
<pre>
    a1 %*% x &lt;= b1
    a2 %*% x == b2
</pre>
<p>see <code><a href="#topic+scdd">scdd</a></code> for description of valid representations.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>makeH(a1, b1, a2, b2, x = NULL)
addHeq(a, b, x)
addHin(a, b, x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="makeH_+3A_a1">a1</code></td>
<td>
<p>numerical or character matrix for inequality constraints.
If vector, treated as matrix with one row.</p>
</td></tr>
<tr><td><code id="makeH_+3A_b1">b1</code></td>
<td>
<p>numerical or character right hand side vector for inequality
constraints.</p>
</td></tr>
<tr><td><code id="makeH_+3A_a2">a2</code></td>
<td>
<p>numerical or character matrix for equality constraints.  If
vector, treated as matrix with one row.</p>
</td></tr>
<tr><td><code id="makeH_+3A_b2">b2</code></td>
<td>
<p>numerical or character right hand side vector for equality
constraints.</p>
</td></tr>
<tr><td><code id="makeH_+3A_x">x</code></td>
<td>
<p>if not <code>NULL</code>, a valid H-representation.</p>
</td></tr>
<tr><td><code id="makeH_+3A_a">a</code></td>
<td>
<p>numerical or character matrix for constraints.  If vector,
treated as matrix with one row.  Constraints are equality
in <code>addHeq</code> and inequality in <code>addHin</code>.</p>
</td></tr>
<tr><td><code id="makeH_+3A_b">b</code></td>
<td>
<p>numerical or character right hand side vector for constraints.</p>
</td></tr>
</table>
<p>Arguments <code>a1</code>, <code>b1</code>, <code>a2</code>, and <code>b2</code> may be missing,
but must be missing in pairs.
Rows in <code>x</code>, if any, are added to new rows corresponding to
the constraints given by the other arguments.
</p>


<h3>Value</h3>

<p>a valid H-representation that can be handed to <code><a href="#topic+scdd">scdd</a></code>.
</p>


<h3>Rational Arithmetic</h3>

<p>The input representation may
have type <code>"character"</code> in which case its elements are interpreted
as unlimited precision rational numbers.  They consist of an optional
minus sign, a string of digits of any length (the numerator),
a slash, and another string of digits of any length (the denominator).
The denominator must be positive.  If the denominator is one, the
slash and the denominator may be omitted.  This package
provides several functions (see <a href="#topic+ConvertGMP">ConvertGMP</a> and <a href="#topic+ArithmeticGMP">ArithmeticGMP</a>)
for conversion back and forth between R floating point numbers and rationals
and for arithmetic on GMP rationals.
</p>
<p>Arguments may be a mix of numeric and character in which case all are
converted to GMP rationals (character) and the output is GMP rational.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+scdd">scdd</a></code>, <code><a href="#topic+validcdd">validcdd</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>d &lt;- 4
# unit simplex in H-representation
qux &lt;- makeH(- diag(d), rep(0, d), rep(1, d), 1)
print(qux)
# add an inequality constraint
qux &lt;- addHin(c(1, -1, 0, 0), 0, qux)
print(qux)
# drop a constraint
qux &lt;- qux[- 3, ]
print(qux)
</code></pre>

<hr>
<h2 id='makeV'>make V-representation of convex polyhedron</h2><span id='topic+makeV'></span><span id='topic+addVpoints'></span><span id='topic+addVrays'></span><span id='topic+addVlines'></span>

<h3>Description</h3>

<p>Construct V-representation of convex polyhedron.
See <code><a href="#topic+scdd">scdd</a></code> for description of valid representations.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>makeV(points, rays, lines, x = NULL)
addVpoints(points, x)
addVrays(rays, x)
addVlines(lines, x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="makeV_+3A_points">points</code></td>
<td>
<p>numerical or character matrix for points.
If vector, treated as matrix with one row.  Each row is one point.</p>
</td></tr>
<tr><td><code id="makeV_+3A_rays">rays</code></td>
<td>
<p>numerical or character matrix for points.
If vector, treated as matrix with one row.  Each row represents one ray
consisting of all nonnegative multiples of the vector which is the row.</p>
</td></tr>
<tr><td><code id="makeV_+3A_lines">lines</code></td>
<td>
<p>numerical or character matrix for points.
If vector, treated as matrix with one row.  Each row represents one line
consisting of all scalar multiples of the vector which is the row.</p>
</td></tr>
<tr><td><code id="makeV_+3A_x">x</code></td>
<td>
<p>if not <code>NULL</code>, a valid V-representation.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>In <code>makeV</code> the arguments <code>points</code> and <code>rays</code> and <code>lines</code>
may be missing.
</p>


<h3>Value</h3>

<p>a valid V-representation that can be handed to <code><a href="#topic+scdd">scdd</a></code>.
</p>


<h3>Rational Arithmetic</h3>

<p>The input representation may
have type <code>"character"</code> in which case its elements are interpreted
as unlimited precision rational numbers.  They consist of an optional
minus sign, a string of digits of any length (the numerator),
a slash, and another string of digits of any length (the denominator).
The denominator must be positive.  If the denominator is one, the
slash and the denominator may be omitted.  This package
provides several functions (see <a href="#topic+ConvertGMP">ConvertGMP</a> and <a href="#topic+ArithmeticGMP">ArithmeticGMP</a>)
for conversion back and forth between R floating point numbers and rationals
and for arithmetic on GMP rationals.
</p>
<p>Arguments may be a mix of numeric and character in which case all are
converted to GMP rationals (character) and the output is GMP rational.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+scdd">scdd</a></code>, <code><a href="#topic+validcdd">validcdd</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>d &lt;- 4
n &lt;- 7
qux &lt;- makeV(points = matrix(rnorm(n * d), ncol = d))
out &lt;- scdd(qux)
out$output
</code></pre>

<hr>
<h2 id='qgram'>GMP Rational Gram-Schmidt</h2><span id='topic+qgram'></span>

<h3>Description</h3>

<p>Find Orthogonal Basis
</p>


<h3>Usage</h3>

<pre><code class='language-R'>qgram(x, remove.zero.vectors = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="qgram_+3A_x">x</code></td>
<td>
<p>matrix of type <code>"numeric"</code>
or <code>"character"</code>.  If <code>"numeric"</code> are converted to rational
using <code><a href="#topic+d2q">d2q</a></code>.  Columns are considered vectors in space
of dimension <code>nrow(x)</code>.</p>
</td></tr>
<tr><td><code id="qgram_+3A_remove.zero.vectors">remove.zero.vectors</code></td>
<td>
<p>logical.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>If <code>remove.zero.vectors == FALSE</code>,
a matrix of the same dimensions as <code>x</code> whose columns are orthogonal
and span the same vector subspace as the columns of <code>x</code>.
Since making the columns unit vectors in the L2 sense could require
irrational numbers, the columns are made unit vectors in the L1 sense
unless they are zero vectors (which, of course, cannot be normalized).
</p>
<p>If <code>remove.zero.vectors == TRUE</code>, then the result is the same
except zero vectors are removed,
so the columns of the result form a basis of the subspace.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+ConvertGMP">ConvertGMP</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>foo &lt;- cbind(c("1", "1", "0", "0", "0"),
             c("2", "1", "0", "0", "0"),
             c("3", "1", "0", "0", "0"),
             c("1", "2", "3", "4", "5"))
qgram(foo)
qgram(foo, remo = FALSE)
</code></pre>

<hr>
<h2 id='redundant'>Eliminate redundant rows of H-representation and V-representation</h2><span id='topic+redundant'></span>

<h3>Description</h3>

<p>Eliminate redundant rows from H-representation (intersection of half spaces)
or V-representation (convex hull of points and directions) of convex polytope.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>redundant(input, representation = c("H", "V"))
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="redundant_+3A_input">input</code></td>
<td>
<p>either H-representation or V-representation of
convex polyhedron (see details).</p>
</td></tr>
<tr><td><code id="redundant_+3A_representation">representation</code></td>
<td>
<p>if <code>"H"</code>, then <code>input</code> is
an H-representation, otherwise a V-representation.  May also be
obtained from a <code>"representation"</code> attribute of <code>input</code>,
if present.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>See <code>cddlibman.pdf</code> in the <code>doc</code> directory of this package,
especially Sections 1 and 2.
</p>
<p>Both representations are (in R) matrices, the first two columns are
special.  Let <code>foo</code> be either an H-representation or
a V-representation and
</p>
<pre>
      l &lt;- foo[ , 1]
      b &lt;- foo[ , 2]
      v &lt;- foo[ , - c(1, 2)]
      a &lt;- (- v)
  </pre>
<p>In the H-representation the convex polyhedron in question is the set of
points <code>x</code> satisfying
</p>
<pre>
      axb &lt;- a %*% x - b
      all(axb &lt;= 0)
      all(l * axb == 0)
  </pre>
<p>In the V-representation the convex polyhedron in question is the set of
points <code>x</code> for which there exists a <code>lambda</code> such that
</p>
<pre>
      x &lt;- t(lambda) %*% v
  </pre>
<p>where <code>lambda</code> satisfies the constraints
</p>
<pre>
      all(lambda * (1 - l) &gt;= 0)
      sum(b * lambda) == max(b)
  </pre>
<p>An H-representation or V-representation object can be checked for validity
using the function <code><a href="#topic+validcdd">validcdd</a></code>.
</p>


<h3>Value</h3>

<p>a list containing some of the following components:
</p>
<table role = "presentation">
<tr><td><code>output</code></td>
<td>
<p>The input matrix with redundant rows removed.</p>
</td></tr>
<tr><td><code>implied.linearity</code></td>
<td>
<p>For an H-representation, row numbers of inequality
constraint rows that together imply equality constraints.  For a
V-representation, row numbers of rays that together imply lines.</p>
</td></tr>
<tr><td><code>redundant</code></td>
<td>
<p>Row numbers of redundant rows.  Note: this is set
<code>redset</code> output by the <code>dd_MatrixCanonicalize</code> function
in <code>cddlib</code>.  It apparently does not consider all rows it deletes
&ldquo;redundant&rdquo;.  Redundancy can also be determined from the
following component.</p>
</td></tr>
<tr><td><code>new.position</code></td>
<td>
<p>Integer vector of length <code>nrow(input)</code>.  Says
for each input row which output row it becomes or zero to indicate
redundant.</p>
</td></tr>
</table>


<h3>Rational Arithmetic</h3>

<p>The input representation may
have type <code>"character"</code> in which case its elements are interpreted
as unlimited precision rational numbers.  They consist of an optional
minus sign, a string of digits of any length (the numerator),
a slash, and another string of digits of any length (the denominator).
The denominator must be positive.  If the denominator is one, the
slash and the denominator may be omitted.  This package
provides several functions (see <a href="#topic+ConvertGMP">ConvertGMP</a> and <a href="#topic+ArithmeticGMP">ArithmeticGMP</a>)
for conversion back and forth between R floating point numbers and rationals
and for arithmetic on GMP rationals.
</p>


<h3>Warning</h3>

<p>If you want correct answers, use rational arithmetic.  If you do not,
this function may (1) produce approximately correct answers, (2) fail with
an error, (3) give answers that are nowhere near correct with no error or
warning, or (4) crash R losing all work done to that point.  In large
simulations (1) is most frequent, (2) occurs roughly one time in a thousand,
(3) occurs roughly one time in ten thousand, and (4) has only occurred once.
So the R floating point
arithmetic version does mostly work, but you cannot trust its results unless
you can check them independently.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+ArithmeticGMP">ArithmeticGMP</a></code>, <code><a href="#topic+ConvertGMP">ConvertGMP</a></code>,
<code><a href="#topic+validcdd">validcdd</a></code>, <code><a href="#topic+makeH">makeH</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>hrep &lt;- rbind(c(0, 0,  1,  1,  0),
              c(0, 0, -1,  0,  0),
              c(0, 0,  0, -1,  0),
              c(0, 0,  0,  0, -1),
              c(0, 0, -1, -1, -1))

redundant(d2q(hrep), representation = "H")

foo &lt;- c(1, 0, -1)
hrep &lt;- cbind(0, 1, rep(foo, each = 9), rep(foo, each = 3), foo)
print(hrep)
redundant(d2q(hrep), representation = "V")
</code></pre>

<hr>
<h2 id='scdd'>Go between H-representation and V-representation of convex polyhedron</h2><span id='topic+scdd'></span>

<h3>Description</h3>

<p>Calculate V-representation (convex hull of points and directions)
of convex polytope given H-representation (intersection of half spaces)
or vice versa.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>scdd(input, adjacency = FALSE, inputadjacency = FALSE,
    incidence = FALSE, inputincidence = FALSE, roworder = c("lexmin",
    "maxindex", "minindex", "mincutoff", "maxcutoff", "mixcutoff", "lexmax",
    "randomrow"), keepinput = c("maybe", "TRUE", "FALSE"),
    representation = c("H", "V"))
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="scdd_+3A_input">input</code></td>
<td>
<p>either H-representation or V-representation of
convex polyhedron (see details).</p>
</td></tr>
<tr><td><code id="scdd_+3A_adjacency">adjacency</code></td>
<td>
<p>if <code>TRUE</code> produce adjacency list of output
generators.</p>
</td></tr>
<tr><td><code id="scdd_+3A_inputadjacency">inputadjacency</code></td>
<td>
<p>if <code>TRUE</code> produce adjacency list of input
generators.</p>
</td></tr>
<tr><td><code id="scdd_+3A_incidence">incidence</code></td>
<td>
<p>if <code>TRUE</code> produce incidence list of output
generators with respect to input generators.</p>
</td></tr>
<tr><td><code id="scdd_+3A_inputincidence">inputincidence</code></td>
<td>
<p>if <code>TRUE</code> produce incidence list of input
generators with respect to output generators.</p>
</td></tr>
<tr><td><code id="scdd_+3A_roworder">roworder</code></td>
<td>
<p>during the computation, take input rows in the specified
order.  The default <code>"lexmin"</code> is usually o. k.  The option
<code>"maxcutoff"</code> might be efficient if the input contains many
redundant inequalities or generators.</p>
</td></tr>
<tr><td><code id="scdd_+3A_keepinput">keepinput</code></td>
<td>
<p>if <code>"TRUE"</code> or <code>"maybe"</code> and an adjacency
or incidence list involving the input is requested, save the input.</p>
</td></tr>
<tr><td><code id="scdd_+3A_representation">representation</code></td>
<td>
<p>if <code>"H"</code>, then <code>input</code> is
an H-representation, otherwise a V-representation.  May also be
obtained from a <code>"representation"</code> attribute of <code>input</code>,
if present.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>See <code>cddlibman.pdf</code> in the <code>doc</code> directory of this package,
especially Sections 1 and 2.
</p>
<p>Both representations are (in R) matrices, the first two columns are
special.  Let <code>foo</code> be either an H-representation or
a V-representation and
</p>
<pre>
      l &lt;- foo[ , 1]
      b &lt;- foo[ , 2]
      v &lt;- foo[ , - c(1, 2)]
      a &lt;- (- v)
  </pre>
<p>In the H-representation the convex polyhedron in question is the set of
points <code>x</code> satisfying
</p>
<pre>
      axb &lt;- a %*% x - b
      all(axb &lt;= 0)
      all(l * axb == 0)
  </pre>
<p>In the V-representation the convex polyhedron in question is the set of
points <code>x</code> for which there exists a <code>lambda</code> such that
</p>
<pre>
      x &lt;- t(lambda) %*% v
  </pre>
<p>where <code>lambda</code> satisfies the constraints
</p>
<pre>
      all(lambda * (1 - l) &gt;= 0)
      sum(b * lambda) == max(b)
  </pre>
<p>An H-representation or V-representation object can be checked for validity
using the function <code><a href="#topic+validcdd">validcdd</a></code>.
</p>


<h3>Value</h3>

<p>a list containing some of the following components:
</p>
<table role = "presentation">
<tr><td><code>output</code></td>
<td>
<p>An H-representation if input was V-representation
and vice versa.</p>
</td></tr>
<tr><td><code>input</code></td>
<td>
<p>The argument <code>input</code>, if requested.</p>
</td></tr>
<tr><td><code>adjacency</code></td>
<td>
<p>The adjacency list, if requested.</p>
</td></tr>
<tr><td><code>inputadjacency</code></td>
<td>
<p>The input adjacency list, if requested.</p>
</td></tr>
<tr><td><code>incidence</code></td>
<td>
<p>The incidence list, if requested.</p>
</td></tr>
<tr><td><code>inputincidence</code></td>
<td>
<p>The input incidence list, if requested.</p>
</td></tr>
</table>


<h3>Rational Arithmetic</h3>

<p>The input representation may
have type <code>"character"</code> in which case its elements are interpreted
as unlimited precision rational numbers.  They consist of an optional
minus sign, a string of digits of any length (the numerator),
a slash, and another string of digits of any length (the denominator).
The denominator must be positive.  If the denominator is one, the
slash and the denominator may be omitted.  This package
provides several functions (see <a href="#topic+ConvertGMP">ConvertGMP</a> and <a href="#topic+ArithmeticGMP">ArithmeticGMP</a>)
for conversion back and forth between R floating point numbers and rationals
and for arithmetic on GMP rationals.
</p>


<h3>Warning</h3>

<p>If you want correct answers, use rational arithmetic.  If you do not,
this function may (1) produce approximately correct answers, (2) fail with
an error, (3) give answers that are nowhere near correct with no error or
warning, or (4) crash R losing all work done to that point.  In large
simulations (1) is most frequent, (2) occurs roughly one time in a thousand,
(3) occurs roughly one time in ten thousand, and (4) has only occurred once
and only with the <code><a href="#topic+redundant">redundant</a></code> function.  So the R floating point
arithmetic version does mostly work, but you cannot trust its results unless
you can check them independently.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+ArithmeticGMP">ArithmeticGMP</a></code>, <code><a href="#topic+ConvertGMP">ConvertGMP</a></code>,
<code><a href="#topic+validcdd">validcdd</a></code>, <code><a href="#topic+makeH">makeH</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>d &lt;- 4
# unit simplex in H-representation
qux &lt;- makeH(- diag(d), rep(0, d), rep(1, d), 1)
print(qux)
# unit simplex in V-representation
out &lt;- scdd(qux)
print(out)
# unit simplex in H-representation
# note: different from original, but equivalent
out &lt;- scdd(out$output)
print(out)

# add equality constraint
quux &lt;- addHeq(1:d, (d + 1) / 2, qux)
print(quux)
out &lt;- scdd(quux)
print(out)

# use some options
out &lt;- scdd(quux, roworder = "maxcutoff", adjacency = TRUE)
print(out)

# convex hull
# not the efficient way to do convex hull
# see ?redundant and sections 5.4 and 6.2 of the package vignette
np &lt;- 50
x &lt;- matrix(rnorm(d * np), ncol = d)
foo &lt;- cbind(0, cbind(1, x))
out &lt;- scdd(d2q(foo), inputincidence = TRUE, representation = "V")
boundies &lt;- sapply(out$inputincidence, length) &gt; 0
sum(boundies) ## number of points on boundary of convex hull
</code></pre>

<hr>
<h2 id='Subset'>subsets and maximal sets</h2><span id='topic+all.intersect'></span><span id='topic+all.union'></span><span id='topic+allIntersect'></span><span id='topic+allUnion'></span><span id='topic+maximal'></span>

<h3>Description</h3>

<p>Given a list of positive integer vectors representing sets,
return a vector of all pairwise intersections (<code>allIntersect</code>),
return a vector of all pairwise unions (<code>allUnion</code>),
or a vector indicating the sets that are maximal
in the sense of not being a subset of any other set in the list
(<code>maximal</code>).  If the list contains duplicate sets,
at most one of each class of duplicates is declared maximal.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>allIntersect(sets, pow2)
allUnion(sets, pow2)
maximal(sets, pow2)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="Subset_+3A_sets">sets</code></td>
<td>
<p>a list of vectors of <code>storage.mode</code> <code>"integer"</code>.
(Unlike most R functions we do not coerce real to integer.)</p>
</td></tr>
<tr><td><code id="Subset_+3A_pow2">pow2</code></td>
<td>
<p>use hash table of size <code>2^pow2</code>.  May be missing.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>For <code>allIntersect</code> or <code>allUnion</code> a
list of length <code>choose(length(sets), 2)</code>
giving all pairwise intersections (resp. unions) of elements of <code>sets</code>.
For <code>maximal</code> a logical vector of the same length as <code>sets</code>
indicating the maximal elements.
</p>
<p>Note: <code>allIntersect</code> and <code>allUnion</code> run over the pairs
in the same order so they can be matched up.
</p>


<h3>Note</h3>

<p>The functions <code>allIntersect</code> and <code>allUnion</code>
were called <code>all.intersect</code> and <code>all.union</code> in previous
versions of this package.  The names were changed because the
<code><a href="base.html#topic+all">all</a></code> function was made generic and these function are
not methods of that one.  These functions were originally intended to
be used to find the faces of a convex set using the output of
<code><a href="#topic+scdd">scdd</a></code> but now the <code><a href="#topic+allfaces">allfaces</a></code> function does a better
job and does it much more efficiently.  Hence these functions have no known
use, but have not been deleted for reasons of backwards compatibility.
</p>

<hr>
<h2 id='validcdd'>validate an H-representation or V-representation of convex polyhedron</h2><span id='topic+validcdd'></span>

<h3>Description</h3>

<p>Validate an H-representation or V-representation of convex polyhedron,
see <code><a href="#topic+scdd">scdd</a></code> for description of valid representations.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>validcdd(x, representation = c("H", "V"))
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="validcdd_+3A_x">x</code></td>
<td>
<p>an H-representation or V-representation to be validated.</p>
</td></tr>
<tr><td><code id="validcdd_+3A_representation">representation</code></td>
<td>
<p>if <code>"H"</code>,
validate <code>x</code> as an H-representation,
otherwise as a V-representation.  May also be obtained from
a <code>"representation"</code> attribute of <code>x</code>, if present.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>always <code>TRUE</code>.  Fails with error message if not a valid object.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+scdd">scdd</a></code></p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
