<!DOCTYPE html><html lang="en"><head><title>Help for package permute</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {permute}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#allPerms'><p>Complete enumeration of all possible permutations</p></a></li>
<li><a href='#allUtils'><p>Utility functions for complete enumeration of all possible</p>
permutations</a></li>
<li><a href='#check'><p>Utility functions for permutation schemes</p></a></li>
<li><a href='#get-methods'><p>Extractor functions to access components of a permutation design</p></a></li>
<li><a href='#how'><p>How to define a permutation design?</p></a></li>
<li><a href='#jackal'>
<p>Mandible lengths of male and female golden jackals</p></a></li>
<li><a href='#nobs-methods'><p>Number of observations in a given object</p></a></li>
<li><a href='#numPerms'><p>Number of possible permutations for a given object</p></a></li>
<li><a href='#set-methods'><p>Replacement functions to set components of a permutation design</p></a></li>
<li><a href='#shuffle'><p>Unrestricted and restricted permutations</p></a></li>
<li><a href='#shuffle-utils'><p>Utility functions for unrestricted and restricted permutations</p></a></li>
<li><a href='#shuffleSet'>
<p>Generate a set of permutations from the specified design.</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Title:</td>
<td>Functions for Generating Restricted Permutations of Data</td>
</tr>
<tr>
<td>Version:</td>
<td>0.9-7</td>
</tr>
<tr>
<td>Date:</td>
<td>2022-01-27</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 2.14.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>stats</td>
</tr>
<tr>
<td>Suggests:</td>
<td>vegan (&ge; 2.0-0), testthat (&ge; 0.5), parallel, knitr,
rmarkdown, bookdown, sessioninfo</td>
</tr>
<tr>
<td>Description:</td>
<td>A set of restricted permutation designs for freely exchangeable, line transects (time series), and spatial grid designs plus permutation of blocks (groups of samples) is provided. 'permute' also allows split-plot designs, in which the whole-plots or split-plots or both can be freely-exchangeable or one of the restricted designs. The 'permute' package is modelled after the permutation schemes of 'Canoco 3.1' (and later) by Cajo ter Braak.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a></td>
</tr>
<tr>
<td>ByteCompile:</td>
<td>true</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/gavinsimpson/permute">https://github.com/gavinsimpson/permute</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/gavinsimpson/permute/issues">https://github.com/gavinsimpson/permute/issues</a></td>
</tr>
<tr>
<td>Copyright:</td>
<td>see file COPYRIGHTS</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2022-01-27 11:11:56 UTC; au690221</td>
</tr>
<tr>
<td>Author:</td>
<td>Gavin L. Simpson <a href="https://orcid.org/0000-0002-9084-8413"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cph, cre],
  R Core Team [cph],
  Douglas M. Bates [ctb],
  Jari Oksanen [ctb]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Gavin L. Simpson &lt;ucfagls@gmail.com&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2022-01-27 11:50:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='allPerms'>Complete enumeration of all possible permutations</h2><span id='topic+allPerms'></span><span id='topic+print.allPerms'></span><span id='topic+summary.allPerms'></span><span id='topic+print.summary.allPerms'></span><span id='topic+as.matrix.allPerms'></span><span id='topic+as.allPerms'></span>

<h3>Description</h3>

<p><code>allPerms</code> is a utility function to return the set of
permutations for a given R object and a specified permutation design.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>allPerms(n, control = how(), check = TRUE)

## S3 method for class 'allPerms'
summary(object, ...)

## S3 method for class 'allPerms'
as.matrix(x, ...)

as.allPerms(object, control)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="allPerms_+3A_n">n</code></td>
<td>
<p>the number of observations or an 'object' from which the
number of observations can be determined via <code>getNumObs</code>.</p>
</td></tr>
<tr><td><code id="allPerms_+3A_control">control</code></td>
<td>
<p>a list of control values describing properties of the
permutation design, as returned by a call to
<code><a href="#topic+how">how</a></code>.</p>
</td></tr>
<tr><td><code id="allPerms_+3A_check">check</code></td>
<td>
<p>logical; should <code>allPerms</code> check the design? The
default is to check, but this can be skipped, for example if a
function checked the design earlier.</p>
</td></tr>
<tr><td><code id="allPerms_+3A_object">object</code></td>
<td>
<p>for <code>summary.allPerms</code>, an object of class
<code>"allPerms"</code>. For <code>as.allPerms</code> a matrix or something that
can be coerced to a matrix by <code><a href="base.html#topic+as.matrix">as.matrix</a></code>.</p>
</td></tr>
<tr><td><code id="allPerms_+3A_...">...</code></td>
<td>
<p>arguments to other methods.</p>
</td></tr>
<tr><td><code id="allPerms_+3A_x">x</code></td>
<td>

<p>an object of class <code>"allPerms"</code>, as returned by <code>allPerms</code>.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Function <code>allPerms</code> enumerates all possible permutations for the 
number of observations and the selected permutation scheme. It has
<code><a href="base.html#topic+print">print</a></code> and <code><a href="base.html#topic+summary">summary</a></code> methods. <code>allPerms</code>
returns a matrix containing all possible permutations, possibly
containing the observed ordering (if argument <code>observed</code> is
<code>TRUE</code>). The rows of this matrix are the various permutations and
the columns reflect the number of samples.
</p>
<p>With free permutation designs, and restricted permutation schemes with
large numbers of observations, there are a potentially huge number of
possible permutations of the samples. It would be inefficient, not to
mention incredibly time consuming, to enumerate them all. Storing all
possible permutations would also become problematic in such cases. To
control this and guard against trying to evaluate too large a number
of permutations, if the number of possible permutations is larger than
<code>getMaxperm(control)</code>, <code>allPerms</code> exits with an error.
</p>
<p>The <code>as.matrix</code> method sets the <code>control</code> and <code>seed</code>
attributes to <code>NULL</code> and removes the <code>"permutationMatrix"</code>
class, resulting in a standard matrix object.
</p>


<h3>Value</h3>

<p>For <code>allPerms</code>, and object of class <code>"allPerms"</code>, a matrix
whose rows are the set of all possible permutations for the supplies
number of observations and permutation scheme selected. The matrix has
two additional attributes <code>control</code> and
<code>observed</code>. Attribute <code>control</code> contains the argument
<code>control</code> (possibly updated via <code>check</code>). Attribute 
<code>observed</code> contains argument <code>observed</code>.
</p>


<h3>Warning</h3>

<p>If permuting the strata themselves, a balanced design is required (the
same number of observations in each level of <code>strata</code>. This is
common to all functions in the package.
</p>


<h3>Author(s)</h3>

<p>Gavin Simpson</p>


<h3>Examples</h3>

<pre><code class='language-R'>## allPerms can work with a vector
vec &lt;- c(3,4,5)
allPerms(vec) ## free permutation

## enumerate all possible permutations for a more complicated
## design
fac &lt;- gl(2,6)
ctrl &lt;- how(within = Within(type = "grid", mirror = FALSE,
                            constant = TRUE, nrow = 3, ncol = 2),
            plots = Plots(strata = fac))
Nobs &lt;- length(fac)
numPerms(seq_len(Nobs), control = ctrl) ## 6
(tmp &lt;- allPerms(Nobs, control = update(ctrl, observed = TRUE)))
(tmp2 &lt;- allPerms(Nobs, control = ctrl))

## turn on mirroring
##ctrl$within$mirror &lt;- TRUE
ctrl &lt;- update(ctrl, within = update(getWithin(ctrl), mirror = TRUE))
numPerms(seq_len(Nobs), control = ctrl)
(tmp3 &lt;- allPerms(Nobs, control = update(ctrl, observed = TRUE)))
(tmp4 &lt;- allPerms(Nobs, control = ctrl))

## prints out details of the permutation scheme as
## well as the matrix of permutations
summary(tmp3)
summary(tmp4)
</code></pre>

<hr>
<h2 id='allUtils'>Utility functions for complete enumeration of all possible
permutations</h2><span id='topic+allFree'></span><span id='topic+allSeries'></span><span id='topic+allGrid'></span><span id='topic+allStrata'></span>

<h3>Description</h3>

<p>Utility functions to return the set of all permutations under
different designs. For most practical applications, i.e. to combine
designs permuting blocks and/or within blocks function
<code><a href="#topic+allPerms">allPerms</a></code> will be required.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>allFree(n, v = seq_len(n))

allSeries(n, nperms, mirror = FALSE)

allGrid(n, nperms, nr, nc, mirror, constant)

allStrata(n, control)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="allUtils_+3A_n">n</code></td>
<td>
<p>the number of observations.</p>
</td></tr>
<tr><td><code id="allUtils_+3A_v">v</code></td>
<td>
<p>numeric; vector of indices. Default is <code>1:n</code>.</p>
</td></tr>
<tr><td><code id="allUtils_+3A_nperms">nperms</code></td>
<td>
<p>numeric; number of possible permutations.</p>
</td></tr>
<tr><td><code id="allUtils_+3A_mirror">mirror</code></td>
<td>
<p>logical; mirroring of permutations allowed?</p>
</td></tr>
<tr><td><code id="allUtils_+3A_nr">nr</code>, <code id="allUtils_+3A_nc">nc</code></td>
<td>
<p>integer; number of rows and columns of grid designs.</p>
</td></tr>
<tr><td><code id="allUtils_+3A_constant">constant</code></td>
<td>
<p>logical; same permutation within each block?</p>
</td></tr>
<tr><td><code id="allUtils_+3A_control">control</code></td>
<td>
<p>a list of control values describing properties of the
permutation design, as returned by a call to <code><a href="#topic+how">how</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>These are utility functions and aren't designed for casual
use. <code><a href="#topic+allPerms">allPerms</a></code> should be used instead.
</p>
<p>Details on usage of these functions can be found in
<code><a href="#topic+allPerms">allPerms</a></code>.
</p>


<h3>Value</h3>

<p>A matrix of all possible permutations of <code>n</code> observations or of
<code>v</code>, given the provided options.
</p>


<h3>Author(s)</h3>

<p>Gavin Simpson</p>

<hr>
<h2 id='check'>Utility functions for permutation schemes</h2><span id='topic+check'></span><span id='topic+print.check'></span><span id='topic+print.summary.check'></span><span id='topic+summary.check'></span>

<h3>Description</h3>

<p><code>check</code> provides checking of permutation schemes for
validity. <code>permuplot</code> produces a graphical representation of the
selected permutation design.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>check(object, control = how(), quietly = FALSE)

## S3 method for class 'check'
summary(object, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="check_+3A_object">object</code></td>
<td>
<p>an R object. See Details for a complete description,
especially for <code><a href="#topic+numPerms">numPerms</a></code>. For
<code><a href="#topic+summary.check">summary.check</a></code> an object of class <code>"check"</code>.</p>
</td></tr>
<tr><td><code id="check_+3A_control">control</code></td>
<td>
<p>a list of control values describing properties of the
permutation design, as returned by a call to <code><a href="#topic+how">how</a></code>.</p>
</td></tr>
<tr><td><code id="check_+3A_quietly">quietly</code></td>
<td>
<p>logical; should messages by suppressed?</p>
</td></tr>
<tr><td><code id="check_+3A_...">...</code></td>
<td>
<p>arguments to other methods.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>check</code> is a utility functions for working with the new
permutation schemes available in <code><a href="#topic+shuffle">shuffle</a></code>.
</p>
<p><code>check</code> is used to check the current permutation schemes
against the object to which it will be applied. It calculates the
maximum number of possible permutations for the number of observations
in <code>object</code> and the permutation scheme described by
<code>control</code>. The returned object contains component <code>control</code>,
an object of class <code>"how"</code> suitably modified if
<code>check</code> identifies a problem.
</p>
<p>The main problem is requesting more permutations than is possible with
the number of observations and the permutation design. In such cases,
<code>nperm</code> is reduced to equal the number of possible permutations,
and complete enumeration of all permutations is turned on
(<code>control$complete</code> is set to <code>TRUE</code>). 
</p>
<p>Alternatively, if the number of possible permutations is low, and
less than <code>control$minperm</code>, it is better to enumerate all
possible permutations, and as such complete enumeration of all
permutations is turned on (<code>control$complete</code> is set to
<code>TRUE</code>). This guarantees that permutations are all unique and
there are no duplicates.
</p>


<h3>Value</h3>

<p>For <code>check</code> a list containing the maximum number of
permutations possible and an object of class <code>"<a href="#topic+how">how</a>"</code>.
</p>


<h3>Author(s)</h3>

<p>Gavin L. Simpson</p>


<h3>See Also</h3>

<p><code><a href="#topic+shuffle">shuffle</a></code> and <code><a href="#topic+how">how</a></code>.</p>


<h3>Examples</h3>

<pre><code class='language-R'>## only run this example if vegan is available
if (suppressPackageStartupMessages(require("vegan"))) {
    ## use example data from ?pyrifos in package vegan
    example(pyrifos)

    ## Demonstrate the maximum number of permutations for the pyrifos data
    ## under a series of permutation schemes

    ## no restrictions - lots of perms
    CONTROL &lt;- how(within = Within(type = "free"))
    (check1 &lt;- check(pyrifos, CONTROL))
    ## summary(check1)
    
    ## no strata but data are series with no mirroring, so 132 permutations
    CONTROL &lt;- how(within = Within(type = "series", mirror = FALSE))
    check(pyrifos, CONTROL)
    
    ## no strata but data are series with mirroring, so 264 permutations
    CONTROL &lt;- how(within = Within(type = "series", mirror = TRUE))
    check(pyrifos, control = CONTROL)
    
    ## unrestricted within strata
    check(pyrifos, control = how(plots = Plots(strata = ditch),
                   within = Within(type = "free")))
    
    ## time series within strata, no mirroring
    check(pyrifos,
          control = how(plots = Plots(strata = ditch),
          within = Within(type = "series", mirror = FALSE)))
    
    ## time series within strata, with mirroring
    check(pyrifos,
          control = how(plots = Plots(strata = ditch),
          within = Within(type = "series", mirror = TRUE)))
    
    ## time series within strata, no mirroring, same permutation
    ## within strata
    check(pyrifos,
          control = how(plots = Plots(strata = ditch),
          within = Within(type = "series", constant = TRUE)))
    
    ## time series within strata, with mirroring, same permutation
    ## within strata
    check(pyrifos,
          control = how(plots = Plots(strata = ditch),
          within = Within(type = "series", mirror = TRUE,
          constant = TRUE)))
    ## permute strata
    check(pyrifos, how(plots = Plots(strata = ditch, type = "free"),
                       within = Within(type = "none")))
}
    
## this should also also for arbitrary vectors
vec1 &lt;- check(1:100)
vec2 &lt;- check(1:100, how())
all.equal(vec1, vec2)
vec3 &lt;- check(1:100, how(within = Within(type = "series")))
all.equal(100, vec3$n)
vec4 &lt;- check(1:100, how(within = Within(type= "series", mirror = TRUE)))
all.equal(vec4$n, 200)

## enumerate all possible permutations
fac &lt;- gl(2,6)
ctrl &lt;- how(plots = Plots(strata = fac),
            within = Within(type = "grid", mirror = FALSE,
                            constant = TRUE, nrow = 3, ncol = 2))
check(1:12, ctrl)

numPerms(1:12, control = ctrl)
(tmp &lt;- allPerms(12, control = update(ctrl, observed = TRUE)))
(tmp2 &lt;- allPerms(12, control = ctrl))

## turn on mirroring
ctrl &lt;- update(ctrl, within = update(getWithin(ctrl), mirror = TRUE))
numPerms(1:12, control = ctrl)
(tmp3 &lt;- allPerms(12, control = update(ctrl, observed = TRUE)))
(tmp4 &lt;- allPerms(12, control = ctrl))
## prints out details of the permutation scheme as
## well as the matrix of permutations
summary(tmp)
summary(tmp2)

## different numbers of observations per level of strata
fac &lt;- factor(rep(1:3, times = c(3,2,2)))
## free permutations in levels of strata
numPerms(7, how(within = Within(type = "free"),
                plots = Plots(strata = fac, type = "none")))
allPerms(7, how(within = Within(type = "free"),
                plots = Plots(strata = fac)))
## series permutations in levels of strata
ctrl &lt;- how(within = Within(type = "series"), plots = Plots(strata = fac))
numPerms(7, control = ctrl)
allPerms(7, control = ctrl)
</code></pre>

<hr>
<h2 id='get-methods'>Extractor functions to access components of a permutation design</h2><span id='topic+get-methods'></span><span id='topic+getBlocks'></span><span id='topic+getBlocks.default'></span><span id='topic+getBlocks.how'></span><span id='topic+getBlocks.permControl'></span><span id='topic+getWithin'></span><span id='topic+getWithin.default'></span><span id='topic+getWithin.how'></span><span id='topic+getWithin.permControl'></span><span id='topic+getStrata'></span><span id='topic+getStrata.default'></span><span id='topic+getStrata.how'></span><span id='topic+getStrata.permControl'></span><span id='topic+getStrata.Plots'></span><span id='topic+getType'></span><span id='topic+getType.default'></span><span id='topic+getType.how'></span><span id='topic+getType.permControl'></span><span id='topic+getType.Plots'></span><span id='topic+getType.Within'></span><span id='topic+getMirror'></span><span id='topic+getMirror.default'></span><span id='topic+getMirror.how'></span><span id='topic+getMirror.permControl'></span><span id='topic+getMirror.Plots'></span><span id='topic+getMirror.Within'></span><span id='topic+getConstant'></span><span id='topic+getConstant.default'></span><span id='topic+getConstant.how'></span><span id='topic+getConstant.permControl'></span><span id='topic+getConstant.Within'></span><span id='topic+getPlots'></span><span id='topic+getPlots.default'></span><span id='topic+getPlots.how'></span><span id='topic+getPlots.permControl'></span><span id='topic+getRow'></span><span id='topic+getRow.default'></span><span id='topic+getRow.how'></span><span id='topic+getRow.permControl'></span><span id='topic+getRow.Plots'></span><span id='topic+getRow.Within'></span><span id='topic+getCol'></span><span id='topic+getCol.default'></span><span id='topic+getCol.how'></span><span id='topic+getCol.permControl'></span><span id='topic+getCol.Plots'></span><span id='topic+getCol.Within'></span><span id='topic+getDim'></span><span id='topic+getDim.default'></span><span id='topic+getDim.how'></span><span id='topic+getDim.permControl'></span><span id='topic+getDim.Plots'></span><span id='topic+getDim.Within'></span><span id='topic+getNperm'></span><span id='topic+getNperm.default'></span><span id='topic+getNperm.how'></span><span id='topic+getNperm.permControl'></span><span id='topic+getMaxperm'></span><span id='topic+getMaxperm.default'></span><span id='topic+getMaxperm.how'></span><span id='topic+getMaxperm.permControl'></span><span id='topic+getMinperm'></span><span id='topic+getMinperm.default'></span><span id='topic+getMinperm.how'></span><span id='topic+getMinperm.permControl'></span><span id='topic+getComplete'></span><span id='topic+getComplete.default'></span><span id='topic+getComplete.how'></span><span id='topic+getComplete.permControl'></span><span id='topic+getMake'></span><span id='topic+getMake.default'></span><span id='topic+getMake.how'></span><span id='topic+getObserved'></span><span id='topic+getObserved.default'></span><span id='topic+getObserved.how'></span><span id='topic+getAllperms'></span><span id='topic+getAllperms.default'></span><span id='topic+getAllperms.how'></span><span id='topic+getControl'></span><span id='topic+getHow'></span><span id='topic+getControl.default'></span><span id='topic+getControl.allPerms'></span>

<h3>Description</h3>

<p>Simple functions to allow abstracted access to components of a
permutation design, for example as returned by
<code><a href="#topic+how">how</a></code>. Whilst many of these are very simple index
opertations on a list, using these rather than directly accessing that
list allows the internal representation of the permutation design to
change without breaking code.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>
getAllperms(object, ...)
getBlocks(object, ...)
getComplete(object, ...)
getConstant(object, ...)
getCol(object, ...)
getDim(object, ...)
getMake(object, ...)
getMaxperm(object, ...)
getMinperm(object, ...)
getMirror(object, ...)
getNperm(object, ...)
getObserved(object, ...)
getPlots(object, ...)
getRow(object, ...)
getStrata(object, ...)
getType(object, ...)
getWithin(object, ...)
getControl(object, ...)
getHow(object, ...)

## S3 method for class 'how'
getAllperms(object, ...)

## S3 method for class 'how'
getBlocks(object, ...)

## S3 method for class 'how'
getCol(object, which = c("plots", "within"), ...)
## S3 method for class 'Plots'
getCol(object, ...)
## S3 method for class 'Within'
getCol(object, ...)

## S3 method for class 'how'
getComplete(object, ...)

## S3 method for class 'how'
getConstant(object, ...)
## S3 method for class 'Within'
getConstant(object, ...)

## S3 method for class 'how'
getDim(object, which = c("plots", "within"), ...)
## S3 method for class 'Plots'
getDim(object, ...)
## S3 method for class 'Within'
getDim(object, ...)

## S3 method for class 'how'
getMake(object, ...)

## S3 method for class 'how'
getMaxperm(object, ...)

## S3 method for class 'how'
getMinperm(object, ...)

## S3 method for class 'how'
getMirror(object, which = c("plots", "within"), ...)
## S3 method for class 'Plots'
getMirror(object, ...)
## S3 method for class 'Within'
getMirror(object, ...)

## S3 method for class 'how'
getNperm(object, ...)

## S3 method for class 'how'
getObserved(object, ...)

## S3 method for class 'how'
getPlots(object, ...)

## S3 method for class 'how'
getRow(object, which = c("plots", "within"), ...)
## S3 method for class 'Plots'
getRow(object, ...)
## S3 method for class 'Within'
getRow(object, ...)

## S3 method for class 'how'
getStrata(object, which = c("plots", "blocks"),
          drop = TRUE, ...)
## S3 method for class 'Plots'
getStrata(object, drop = TRUE, ...)

## S3 method for class 'how'
getType(object, which = c("plots", "within"), ...)
## S3 method for class 'Plots'
getType(object, ...)
## S3 method for class 'Within'
getType(object, ...)

## S3 method for class 'how'
getWithin(object, ...)

## S3 method for class 'allPerms'
getControl(object, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="get-methods_+3A_object">object</code></td>
<td>
<p>An R object to dispatch on.</p>
</td></tr>
<tr><td><code id="get-methods_+3A_which">which</code></td>
<td>
<p>character; which level of restriction to extract
information for.</p>
</td></tr>
<tr><td><code id="get-methods_+3A_drop">drop</code></td>
<td>
<p>logical; should un-used factor levels be dropped?</p>
</td></tr>
<tr><td><code id="get-methods_+3A_...">...</code></td>
<td>
<p>Arguments passed on to other methods.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>These are extractor functions for working with permutation design
objects created by <code><a href="#topic+how">how</a></code>. They should be used in
preference to directly subsetting the permutation design in case the
internal structure of object changes as <span class="pkg">permute</span> is developed.
</p>
<p><code>getHow</code> is an alias for <code>getControl</code>; specific methods are
implemented for <code>getControl</code> if you are debugging.
</p>


<h3>Value</h3>

<p>These are simple extractor functions and return the contents of the
corresponding components of <code>object</code>.
</p>


<h3>Author(s)</h3>

<p>Gavin Simpson</p>


<h3>See Also</h3>

<p><code><a href="#topic+check">check</a></code>, a utility function for checking
permutation scheme described by <code><a href="#topic+how">how</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## extract components from a "how" object
hh &lt;- how()
getWithin(hh)
getNperm(hh)
</code></pre>

<hr>
<h2 id='how'>How to define a permutation design?</h2><span id='topic+how'></span><span id='topic+print.how'></span><span id='topic+Blocks'></span><span id='topic+Within'></span><span id='topic+Plots'></span>

<h3>Description</h3>

<p>Utility functions to describe unrestricted and restricted permutation
designs for time series, line transects, spatial grids and blocking
factors.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>how(within = Within(), plots = Plots(), blocks = NULL,
    nperm = 199, complete = FALSE, maxperm = 9999,
    minperm = 5040, all.perms = NULL, make = TRUE,
    observed = FALSE)

Within(type = c("free","series","grid","none"),
       constant = FALSE, mirror = FALSE,
       ncol = NULL, nrow = NULL)

Plots(strata = NULL, type = c("none","free","series","grid"),
      mirror = FALSE, ncol = NULL, nrow = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="how_+3A_within">within</code>, <code id="how_+3A_plots">plots</code>, <code id="how_+3A_blocks">blocks</code></td>
<td>
<p>Permutation designs for samples within the
levels of <code>plots</code> (<code>within</code>), permutation of <code>plots</code>
themselves, or for the definition of blocking structures which
further restrict permutations (<code>blocks</code>). <code>within</code> and
<code>plots</code> each require a named list as produced by <code>Within</code>
and <code>Plots</code> respectively. <code>blocks</code> takes a factor (or an
object coercible to a factor via <code>as.factor</code>), the levels of
which define the blocking structure.</p>
</td></tr>
<tr><td><code id="how_+3A_nperm">nperm</code></td>
<td>
<p>numeric; the number of permutations.</p>
</td></tr>
<tr><td><code id="how_+3A_complete">complete</code></td>
<td>
<p>logical; should complete enumeration of all
permutations be performed?</p>
</td></tr>
<tr><td><code id="how_+3A_type">type</code></td>
<td>
<p>character; the type of permutations required. One of
<code>"free"</code>, <code>"series"</code>, <code>"grid"</code> or <code>"none"</code>. See
Details.</p>
</td></tr> 
<tr><td><code id="how_+3A_maxperm">maxperm</code></td>
<td>
<p>numeric; the maximum number of permutations to
perform. Currently unused.</p>
</td></tr>
<tr><td><code id="how_+3A_minperm">minperm</code></td>
<td>
<p>numeric; the lower limit to the number of possible
permutations at which complete enumeration is performed. When
<code>nperm</code> is lower than <code>minperm</code>, sampling is performed
from the set of complete permutations to avoid duplicate
permutations. See argument <code>complete</code> and Details, below.</p>
</td></tr>
<tr><td><code id="how_+3A_all.perms">all.perms</code></td>
<td>
<p>an object of class <code>allPerms</code>, the result of a
call to <code><a href="#topic+allPerms">allPerms</a></code>.</p>
</td></tr>
<tr><td><code id="how_+3A_make">make</code></td>
<td>
<p>logical; should <code>check</code> generate all possible
permutations? Useful if want to check permutation design but not
produce the matrix of all permutations, or to circumvent the
heuristics governing when complete enumeration is activated.</p>
</td></tr>
<tr><td><code id="how_+3A_observed">observed</code></td>
<td>
<p>logical; should the observed permutation be returned
as part of the set of all permutations? Default is <code>FALSE</code> to
facilitate usage in higher level functions.</p>
</td></tr>
<tr><td><code id="how_+3A_constant">constant</code></td>
<td>
<p>logical; should the same permutation be used within
each level of strata? If <code>FALSE</code> a separate, possibly restricted,
permutation is produced for each level of <code>strata</code>.</p>
</td></tr>
<tr><td><code id="how_+3A_mirror">mirror</code></td>
<td>
<p>logical; should mirroring of sequences be allowed?</p>
</td></tr>
<tr><td><code id="how_+3A_ncol">ncol</code>, <code id="how_+3A_nrow">nrow</code></td>
<td>
<p>numeric; the number of columns and rows of samples
in the spatial grid respectively.</p>
</td></tr>
<tr><td><code id="how_+3A_strata">strata</code></td>
<td>
<p>A factor, or an object that can be coerced to a factor
via <code>as.factor</code>, specifying the strata for permutation.</p>
</td></tr> 
</table>


<h3>Details</h3>

<p><code>shuffle</code> can generate permutations for a wide range of
restricted permutation schemes. A small selection of the available
combinations of options is provided in the Examples section below.
</p>
<p>Argument type controls how samples are actually permuted;
<code>"free"</code> indicates randomization, <code>"series"</code> indicates
permutation via cyclic shifts (suitable for evenly-spaced line
transect or time series data), <code>"grid"</code> indicates permutation via
toroidal shifts (suitable for samples on a regular grid), and
<code>"none"</code> indicates no permutation of samples. See the package
vignette (<code>browseVignettes("permute")</code>) for additional
information on each of these types of permutation.
</p>
<p>Argument <code>mirror</code> determines whether grid or series permutations
can be mirrored. Consider the sequence 1,2,3,4. The relationship
between consecutive observations is preserved if we reverse the
sequence to 4,3,2,1. If there is no inherent direction in your
experimental design, mirrored permutations can be considered
part of the Null model, and as such increase the number of possible
permutations. The default is to not use mirroring so you must
explicitly turn this on using <code>mirror = TRUE</code> in <code>how</code>.
</p>
<p>To permute plots rather than the observations within plots (the
levels of <code>strata</code>), use <code>Within(type = "none")</code> and
<code>Plots(type = foo)</code>, where <code>foo</code> is how you want the plots
to be permuted. However, note that the number of observations within
each plot <strong>must</strong> be equal! 
</p>
<p>For some experiments, such as BACI designs, one might wish to use the
same permutation within each plot. This is controlled by
argument <code>constant</code>. If <code>constant = TRUE</code> then the same
permutation will be generated for each level of <code>strata</code>. The
default is <code>constant = FALSE</code>.
</p>


<h3>Value</h3>

  
<p>For <code>how</code> a list with components for each of the possible arguments.
</p>


<h3>Author(s)</h3>

<p>Gavin Simpson</p>


<h3>References</h3>

<p><code>shuffle()</code> is modelled after the permutation schemes of Canoco
3.1 (ter Braak, 1990); see also Besag &amp; Clifford (1989).
</p>
<p>Besag, J. and Clifford, P. (1989) Generalized Monte Carlo significance
tests. <em>Biometrika</em> <strong>76</strong>; 633&ndash;642.
</p>
<p>ter Braak, C. J. F. (1990). <em>Update notes: CANOCO version
3.1</em>. Wageningen: Agricultural Mathematics Group. (UR).
</p>


<h3>See Also</h3>

<p><code><a href="#topic+shuffle">shuffle</a></code> and <code><a href="#topic+shuffleSet">shuffleSet</a></code> for
permuting from a design, and <code><a href="#topic+check">check</a></code>, a utility function
for checking permutation design described by <code>how</code>.</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Set up factors for the Plots and Blocks
plts &lt;- gl(4, 10) ## 4 Plots of 10 samples each
blks &lt;- gl(2, 20) ## 2 Blocks of 20 samples each

## permutation design
h1 &lt;- how(within = Within(type = "series", mirror = TRUE),
          plots = Plots(strata = plts, type = "series"),
          blocks = blks)

## The design can be updated...
## ... remove the blocking:
update(h1, blocks = NULL)

## ... or switch the type of shuffling at a level:
#update(h1, plots = update(getPlots(h1), type = "none"))
plots2 &lt;- update(getPlots(h1), type = "none")
update(h1, plots = plots2)
</code></pre>

<hr>
<h2 id='jackal'>
Mandible lengths of male and female golden jackals
</h2><span id='topic+jackal'></span>

<h3>Description</h3>

<p>Mandible lengths (in mm) for male and female golden jackals
(<em>Canis aureus</em>) from a collection of specimens in the British
Museum of Natural History, London, UK.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(jackal)</code></pre>


<h3>Format</h3>

<p>A data frame with 20 observations on the following 2 variables.
</p>

<dl>
<dt><code>Length</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>Sex</code></dt><dd><p>a factor with levels <code>Male</code> <code>Female</code></p>
</dd>
</dl>



<h3>Source</h3>

<p>The data were manually transcribed from Manly (2007).
</p>


<h3>References</h3>

<p>Higham, C.F.W., Kijngam, A., and Manly, B.F.J. (1980) An analysis of
prehistoric canid remains from Thailand. <em>Journal of
Archaeological Science</em> <strong>7</strong>:149-165.
</p>
<p>Manly, B.F.J. (2007) <em>Randomization, bootstrap and Monte Carlo
methods in biology. Third Edition</em>. Chapman \&amp; Hall/CRC, Boca
Raton.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(jackal)
str(jackal)

## boxplot of mandible length vs sex
plot(Length ~ Sex, data = jackal)
</code></pre>

<hr>
<h2 id='nobs-methods'>Number of observations in a given object</h2><span id='topic+nobs-methods'></span><span id='topic+nobs.numeric'></span><span id='topic+nobs.integer'></span><span id='topic+nobs.matrix'></span><span id='topic+nobs.data.frame'></span><span id='topic+nobs.factor'></span><span id='topic+nobs.character'></span>

<h3>Description</h3>

<p><code><a href="stats.html#topic+nobs">nobs</a></code> is a generic function to return the number of
observations from a model. <code>shuffle</code> provides a few methods for
other types of data object in R.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>
## S3 method for class 'numeric'
nobs(object, ...)

## S3 method for class 'integer'
nobs(object, ...)

## S3 method for class 'matrix'
nobs(object, ...)

## S3 method for class 'data.frame'
nobs(object, ...)

## S3 method for class 'character'
nobs(object, ...)

## S3 method for class 'factor'
nobs(object, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="nobs-methods_+3A_object">object</code></td>
<td>
<p>a data frame or matrix, or a numeric, integer,
character, or factor vector.</p>
</td></tr>
<tr><td><code id="nobs-methods_+3A_...">...</code></td>
<td>
<p>arguments to other methods.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Function <code>nobs</code> is a simple generic function to return the
number of observations in a range of R model objects. Methods are
provided to work with a variety of R objects.
</p>


<h3>Value</h3>

<p>The (numeric) number of observations in <code>object</code>.
</p>


<h3>Author(s)</h3>

<p>Gavin Simpson</p>


<h3>Examples</h3>

<pre><code class='language-R'>
set.seed(1)
## numeric vector
len &lt;- sample(1:10, 1)
v &lt;- as.numeric(sample(1:100, len))
len
obs &lt;- nobs(v)
isTRUE(all.equal(len, obs))

## integer
len &lt;- sample(1L:10L, 1)
obs &lt;- nobs(len)
isTRUE(all.equal(len, obs))

</code></pre>

<hr>
<h2 id='numPerms'>Number of possible permutations for a given object</h2><span id='topic+numPerms'></span>

<h3>Description</h3>

<p><code>numPerms</code> calculates the maximum number of permutations possible
under the current permutation scheme.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>numPerms(object, control = how())
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="numPerms_+3A_object">object</code></td>
<td>
<p>any object handled by <code><a href="stats.html#topic+nobs">nobs</a></code>.</p>
</td></tr>
<tr><td><code id="numPerms_+3A_control">control</code></td>
<td>
<p>a list of control values describing properties of the
permutation design, as returned by a call to
<code><a href="#topic+how">how</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Function <code>numPerms</code> returns the number of permutations for the
passed <code>object</code> and the selected permutation
scheme. <code>object</code> can be one of a data frame, matrix, an object
for which a scores method exists, or a numeric or integer vector. In
the case of a numeric or integer vector, a vector of length 1 can be
used and it will be expanded to a vector of length <code>object</code>
(i.e., <code>1:object</code>) before computing the number of
permutations. As such, <code>object</code> can be the number of observations
not just the object containing the observations. 
</p>


<h3>Value</h3>

<p>The (numeric) number of possible permutations of observations in
<code>object</code>.
</p>


<h3>Note</h3>

<p>In general, mirroring <code>"series"</code> or <code>"grid"</code> designs doubles
or quadruples, respectively, the number of permutations without
mirroring (within levels of strata if present). This is <strong>not</strong>
true in two special cases:
</p>

<ol>
<li><p> In <code>"grid"</code> designs where the number of columns is equal
to 2, and
</p>
</li>
<li><p> In <code>"series"</code> designs where the number of observations in
a series is equal to 2.
</p>
</li></ol>

<p>For example, with 2 observations there are 2 permutations for
<code>"series"</code> designs:
</p>

<ol>
<li><p> 1-2, and
</p>
</li>
<li><p> 2-1.
</p>
</li></ol>

<p>If these two permutations were mirrored, we would have:
</p>

<ol>
<li><p> 2-1, and
</p>
</li>
<li><p> 1-2.
</p>
</li></ol>

<p>It is immediately clear that this is the same set of permutations
without mirroring (if one reorders the rows). A similar situation
arises in <code>"grid"</code> designs where the number of <strong>columns</strong>
per <em>grid</em> is equal to 2. Note that the number of rows per
<em>grid</em> is not an issue here.
</p>


<h3>Author(s)</h3>

<p>Gavin Simpson</p>


<h3>See Also</h3>

<p><code><a href="#topic+shuffle">shuffle</a></code> and
<code><a href="#topic+how">how</a></code>. Additional <code><a href="stats.html#topic+nobs">nobs</a></code> methods are
provide, see <code><a href="#topic+nobs-methods">nobs-methods</a></code>.</p>


<h3>Examples</h3>

<pre><code class='language-R'>## permutation design --- see ?how
ctrl &lt;- how() ## defaults to freely exchangeable

## vector input
v &lt;- 1:10
(obs &lt;- nobs(v))
numPerms(v, control = ctrl)

## integer input
len &lt;- length(v)
(obs &lt;- nobs(len))
numPerms(len, control = ctrl)

## new design, objects are a time series
ctrl &lt;- how(within = Within(type = "series"))
numPerms(v, control = ctrl)
## number of permutations possible drastically reduced...
## ...turn on mirroring
ctrl &lt;- how(within = Within(type = "series", mirror = TRUE))
numPerms(v, control = ctrl)

## Try blocking --- 2 groups of 5
bl &lt;- numPerms(v, control = how(blocks = gl(2,5)))
bl

## should be same as
pl &lt;- numPerms(v, control = how(plots = Plots(strata = gl(2,5))))
pl
stopifnot(all.equal(bl, pl))
</code></pre>

<hr>
<h2 id='set-methods'>Replacement functions to set components of a permutation design</h2><span id='topic+set-methods'></span><span id='topic+setBlocks+3C-'></span><span id='topic+setBlocks+3C-.default'></span><span id='topic+setBlocks+3C-.how'></span><span id='topic+setBlocks+3C-.permControl'></span><span id='topic+setWithin+3C-'></span><span id='topic+setWithin+3C-.default'></span><span id='topic+setWithin+3C-.how'></span><span id='topic+setStrata+3C-'></span><span id='topic+setStrata+3C-.default'></span><span id='topic+setStrata+3C-.how'></span><span id='topic+setStrata+3C-.Plots'></span><span id='topic+setType+3C-'></span><span id='topic+setType+3C-.default'></span><span id='topic+setType+3C-.how'></span><span id='topic+setType+3C-.Plots'></span><span id='topic+setType+3C-.Within'></span><span id='topic+setMirror+3C-'></span><span id='topic+setMirror+3C-.default'></span><span id='topic+setMirror+3C-.how'></span><span id='topic+setMirror+3C-.Plots'></span><span id='topic+setMirror+3C-.Within'></span><span id='topic+setConstant+3C-'></span><span id='topic+setConstant+3C-.default'></span><span id='topic+setConstant+3C-.how'></span><span id='topic+setConstant+3C-.Plots'></span><span id='topic+setConstant+3C-.Within'></span><span id='topic+setPlots+3C-'></span><span id='topic+setPlots+3C-.default'></span><span id='topic+setPlots+3C-.how'></span><span id='topic+setRow+3C-'></span><span id='topic+setRow+3C-.default'></span><span id='topic+setRow+3C-.how'></span><span id='topic+setRow+3C-.Plots'></span><span id='topic+setRow+3C-.Within'></span><span id='topic+setCol+3C-'></span><span id='topic+setCol+3C-.default'></span><span id='topic+setCol+3C-.how'></span><span id='topic+setCol+3C-.Plots'></span><span id='topic+setCol+3C-.Within'></span><span id='topic+setDim+3C-'></span><span id='topic+setDim+3C-.default'></span><span id='topic+setDim+3C-.how'></span><span id='topic+setDim+3C-.Plots'></span><span id='topic+setDim+3C-.Within'></span><span id='topic+setNperm+3C-'></span><span id='topic+setNperm+3C-.default'></span><span id='topic+setNperm+3C-.how'></span><span id='topic+setNperm+3C-.permControl'></span><span id='topic+setAllperms+3C-'></span><span id='topic+setAllperms+3C-.default'></span><span id='topic+setAllperms+3C-.how'></span><span id='topic+setAllperms+3C-.permControl'></span><span id='topic+setMaxperm+3C-'></span><span id='topic+setMaxperm+3C-.default'></span><span id='topic+setMaxperm+3C-.how'></span><span id='topic+setMaxperm+3C-.permControl'></span><span id='topic+setMinperm+3C-'></span><span id='topic+setMinperm+3C-.default'></span><span id='topic+setMinperm+3C-.how'></span><span id='topic+setMinperm+3C-.permControl'></span><span id='topic+setComplete+3C-'></span><span id='topic+setComplete+3C-.default'></span><span id='topic+setComplete+3C-.how'></span><span id='topic+setComplete+3C-.permControl'></span><span id='topic+setMake+3C-'></span><span id='topic+setMake+3C-.default'></span><span id='topic+setMake+3C-.how'></span><span id='topic+setObserved+3C-'></span><span id='topic+setObserved+3C-.default'></span><span id='topic+setObserved+3C-.how'></span>

<h3>Description</h3>

<p>Simple functions to allow abstracted replacement of components of a
permutation design, for example as returned by <code><a href="#topic+how">how</a></code>. In
addition to performing replacement of components of the list returned
by <code><a href="#topic+how">how</a></code>, these replacement function also update the
matched calls stored within the list to facilitate the use of
<code><a href="stats.html#topic+update">update</a></code> by users.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>
setBlocks(object) &lt;- value
setPlots(object) &lt;- value
setWithin(object) &lt;- value
setStrata(object) &lt;- value
setNperm(object) &lt;- value
setAllperms(object) &lt;- value
setMaxperm(object) &lt;- value
setMinperm(object) &lt;- value
setComplete(object) &lt;- value
setMake(object) &lt;- value
setObserved(object) &lt;- value
setRow(object) &lt;- value
setCol(object) &lt;- value
setDim(object) &lt;- value
setType(object) &lt;- value
setMirror(object) &lt;- value
setConstant(object) &lt;- value
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="set-methods_+3A_object">object</code></td>
<td>
<p>An R object to dispatch on.</p>
</td></tr>
<tr><td><code id="set-methods_+3A_value">value</code></td>
<td>
<p>The replacement value/object.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>These are replacement functions for working with permutation design
objects created by <code><a href="#topic+how">how</a></code>. They should be used in
preference to directly updating the permutation design in case the
internal structure of object changes as <span class="pkg">permute</span> is developed and
because the matched call also needs to be updated to facilitate use of
<code><a href="stats.html#topic+update">update</a></code> on the <code><a href="#topic+how">how</a></code> object.
</p>


<h3>Value</h3>

<p>These replacement functions return <code>object</code> suitably modified.
</p>


<h3>Note</h3>

<p><code>setStrata&lt;-</code> has methods for objects of class <code>"how"</code> and
<code>"Plots"</code>. The former sets the <code>blocks</code> component of the
<code><a href="#topic+how">how</a></code> object, whilst the latter sets the <code>strata</code>
component of the <code><a href="#topic+Plots">Plots</a></code> object.
</p>
<p><code>setDim&lt;-</code>, <code>setRow&lt;-</code>, and <code>setCol&lt;-</code> cannot be used
on an object of class <code>"how"</code>. Instead, extract the <code>Plots</code>
or <code>Within</code> components with <code><a href="#topic+getPlots">getPlots</a></code> or
<code><a href="#topic+getWithin">getWithin</a></code> and alter those components, then use the
resulting object to replace the <code>plots</code> or <code>within</code>
components using <code>setPlots</code> or <code>setWithin</code>.
</p>


<h3>Author(s)</h3>

<p>Gavin Simpson</p>


<h3>See Also</h3>

<p><code><a href="#topic+check">check</a></code>, a utility function for checking
permutation scheme described by <code><a href="#topic+how">how</a></code>. Comparable
extractor functions are also available; see
<code><a href="#topic+get-methods">get-methods</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## extract components from a "how" object
hh &lt;- how()
getNperm(hh)
setNperm(hh) &lt;- 999
getNperm(hh)
</code></pre>

<hr>
<h2 id='shuffle'>Unrestricted and restricted permutations</h2><span id='topic+shuffle'></span><span id='topic+permute'></span>

<h3>Description</h3>

<p>Unrestricted and restricted permutation designs for time series,
line transects, spatial grids and blocking factors.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>shuffle(n, control = how())

permute(i, n, control)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="shuffle_+3A_n">n</code></td>
<td>
<p>numeric; the length of the returned vector of permuted
values. Usually the number of observations under consideration. May
also be any object that <code>nobs</code> knows about; see
<code><a href="#topic+nobs-methods">nobs-methods</a></code>.</p>
</td></tr>
<tr><td><code id="shuffle_+3A_control">control</code></td>
<td>
<p>a list of control values describing properties of the
permutation design, as returned by a call to <code>how</code>.</p>
</td></tr>
<tr><td><code id="shuffle_+3A_i">i</code></td>
<td>
<p>integer; row of <code>control$all.perms</code> to return.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>shuffle</code> can generate permutations for a wide range of
restricted permutation schemes. A small selection of the available
combinations of options is provided in the Examples section below.
</p>
<p><code>permute</code> is a higher level utility function for use in a loop
within a function implementing a permutation test. The main purpose of
<code>permute</code> is to return the correct permutation in each iteration
of the loop, either a random permutation from the current design or
the next permutation from <code>control$all.perms</code> if it is not
<code>NULL</code> and <code>control$complete</code> is <code>TRUE</code>.
</p>


<h3>Value</h3>

<p>For <code>shuffle</code> a vector of length <code>n</code> containing a
permutation of the observations 1, ..., n using the permutation
scheme described by argument <code>control</code>.
</p>
<p>For <code>permute</code> the <code>i</code>th permutation from the set of all
permutations, or a random permutation from the design.
</p>


<h3>Author(s)</h3>

<p>Gavin Simpson</p>


<h3>References</h3>

<p><code>shuffle()</code> is modelled after the permutation schemes of Canoco
3.1 (ter Braak, 1990); see also Besag &amp; Clifford (1989).
</p>
<p>Besag, J. and Clifford, P. (1989) Generalized Monte Carlo significance
tests. <em>Biometrika</em> <strong>76</strong>; 633&ndash;642.
</p>
<p>ter Braak, C. J. F. (1990). <em>Update notes: CANOCO version
3.1</em>. Wageningen: Agricultural Mathematics Group. (UR).
</p>


<h3>See Also</h3>

<p><code><a href="#topic+check">check</a></code>, a utility function for checking
permutation scheme described by <code><a href="#topic+how">how</a></code>.</p>


<h3>Examples</h3>

<pre><code class='language-R'>
set.seed(1234)

## unrestricted permutations
shuffle(20)

## observations represent a time series of line transect
CTRL &lt;- how(within = Within(type = "series"))
shuffle(20, control = CTRL)

## observations represent a time series of line transect
## but with mirroring allowed
CTRL &lt;- how(within = Within(type = "series", mirror = TRUE))
shuffle(20, control = CTRL)

## observations represent a spatial grid, 5rx4c
nr &lt;- 5
nc &lt;- 4
CTRL &lt;- how(within = Within(type = "grid", ncol = nc, nrow = nr))
perms &lt;- shuffle(20, control = CTRL)
## view the permutation as a grid
matrix(matrix(1:20, nrow = nr, ncol = nc)[perms],
       ncol = nc, nrow = nr)

## random permutations in presence of strata
plots &lt;- Plots(strata = gl(4, 5))
CTRL &lt;- how(plots = plots, within = Within(type = "free"))
shuffle(20, CTRL)
## as above but same random permutation within strata
CTRL &lt;- how(plots = plots, within = Within(type = "free",
            constant = TRUE))
shuffle(20, CTRL)

## time series within each level of block
CTRL &lt;- how(plots = plots, within = Within(type = "series"))
shuffle(20, CTRL)
## as above, but  with same permutation for each level
CTRL &lt;- how(plots = plots, within = Within(type = "series",
            constant = TRUE))
shuffle(20, CTRL)

## spatial grids within each level of block, 4 x (5r x 5c)
nr &lt;- 5
nc &lt;- 5
nb &lt;- 4 ## number of blocks
plots &lt;- Plots(gl(nb, 25))
CTRL &lt;- how(plots = plots,
            within = Within(type = "grid", ncol = nc, nrow = nr))
shuffle(100, CTRL)
## as above, but with same permutation for each level
CTRL &lt;- how(plots = plots,
            within = Within(type = "grid", ncol = nc, nrow = nr,
                            constant = TRUE))
shuffle(100, CTRL)

## permuting levels of plots instead of observations
CTRL &lt;- how(plots = Plots(gl(4, 5), type = "free"),
            within = Within(type = "none"))
shuffle(20, CTRL)
## permuting levels of plots instead of observations
## but plots represent a time series
CTRL &lt;- how(plots = Plots(gl(4, 5), type = "series"),
            within = Within(type = "none"))
shuffle(20, CTRL)

## permuting levels of plots but plots represent a time series
## free permutation within plots
CTRL &lt;- how(plots = Plots(gl(4, 5), type = "series"),
            within = Within(type = "free"))
shuffle(20, CTRL)

## permuting within blocks
grp &lt;- gl(2, 10) # 2 groups of 10 samples each
CTRL &lt;- how(blocks = grp)
shuffle(length(grp), control = CTRL)

## Simple function using permute() to assess significance
## of a t.test  
pt.test &lt;- function(x, group, control) {
    ## function to calculate t
    t.statistic &lt;- function(x, y) {
        m &lt;- length(x)
        n &lt;- length(y)
        ## means and variances, but for speed
        xbar &lt;- mean(x)
        ybar &lt;- mean(y)
        xvar &lt;- var(x)
        yvar &lt;- var(y)
        pooled &lt;- sqrt(((m-1)*xvar + (n-1)*yvar) / (m+n-2))
        (xbar - ybar) / (pooled * sqrt(1/m + 1/n))
    }
    ## check the control object
    #control &lt;- check(x, control)$control ## FIXME
    ## number of observations
    Nobs &lt;- nobs(x)
    ## group names
    lev &lt;- names(table(group))
    ## vector to hold results, +1 because of observed t
    t.permu &lt;- numeric(length = control$nperm) + 1
    ## calculate observed t
    t.permu[1] &lt;- t.statistic(x[group == lev[1]], x[group == lev[2]])
    ## generate randomisation distribution of t
    for(i in seq_along(t.permu)) {
        ## return a permutation
        want &lt;- permute(i, Nobs, control)
        ## calculate permuted t
        t.permu[i+1] &lt;- t.statistic(x[want][group == lev[1]],
                                    x[want][group == lev[2]])
    }
    ## pval from permutation test
    pval &lt;- sum(abs(t.permu) &gt;= abs(t.permu[1])) / (control$nperm + 1)
    ## return value
    return(list(t.stat = t.permu[1], pval = pval))
}

## generate some data with slightly different means
set.seed(1234)
gr1 &lt;- rnorm(20, mean = 9)
gr2 &lt;- rnorm(20, mean = 10)
dat &lt;- c(gr1, gr2)
## grouping variable
grp &lt;- gl(2, 20, labels = paste("Group", 1:2))
## create the permutation design
control &lt;- how(nperm = 999, within = Within(type = "free"))
## perform permutation t test
perm.val &lt;- pt.test(dat, grp, control)
perm.val

## compare perm.val with the p-value from t.test()
t.test(dat ~ grp, var.equal = TRUE)
</code></pre>

<hr>
<h2 id='shuffle-utils'>Utility functions for unrestricted and restricted permutations</h2><span id='topic+shuffle-utils'></span><span id='topic+shuffleFree'></span><span id='topic+shuffleGrid'></span><span id='topic+shuffleSeries'></span><span id='topic+shuffleStrata'></span>

<h3>Description</h3>

<p>Unrestricted and restricted permutations for time series,
line transects, spatial grids and blocking factors.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>shuffleFree(x, size)

shuffleSeries(x, mirror = FALSE, start = NULL, flip = NULL)

shuffleGrid(nrow, ncol, mirror = FALSE, start.row = NULL,
            start.col = NULL, flip = NULL)

shuffleStrata(strata, type, mirror = FALSE, start = NULL, flip = NULL,
              nrow, ncol, start.row = NULL, start.col = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="shuffle-utils_+3A_x">x</code></td>
<td>
<p>vector of indices to permute.</p>
</td></tr>
<tr><td><code id="shuffle-utils_+3A_size">size</code></td>
<td>
<p>number of random permutations required</p>
</td></tr>
<tr><td><code id="shuffle-utils_+3A_mirror">mirror</code></td>
<td>
<p>logical; should mirroring of sequences be allowed?</p>
</td></tr>
<tr><td><code id="shuffle-utils_+3A_start">start</code></td>
<td>
<p>integer; the starting point for time series
permutations. If missing, a random starting point is determined.</p>
</td></tr>
<tr><td><code id="shuffle-utils_+3A_flip">flip</code></td>
<td>
<p>logical, length 1 (<code>shuffleSeries</code>) or length 2
(<code>shuffleGrid</code>); force mirroring of permutation. This will
always return the reverse of the computed permutation. For
<code>shuffleGrid</code>, the first element pertains to flipping rows, the
second to flipping columns of the grid.</p>
</td></tr>
<tr><td><code id="shuffle-utils_+3A_nrow">nrow</code>, <code id="shuffle-utils_+3A_ncol">ncol</code></td>
<td>
<p>numeric; the number of rows and columns in the grid.</p>
</td></tr>
<tr><td><code id="shuffle-utils_+3A_start.row">start.row</code>, <code id="shuffle-utils_+3A_start.col">start.col</code></td>
<td>
<p>numeric; the starting row and column for
the shifted grid permutation. If non supplied, a random starting row
and column will be selected.</p>
</td></tr>
<tr><td><code id="shuffle-utils_+3A_strata">strata</code></td>
<td>
<p>factor; the blocks to permute.</p>
</td></tr>
<tr><td><code id="shuffle-utils_+3A_type">type</code></td>
<td>
<p>character; the type of permutation used to shuffle the
<code>strata</code>. One of <code>"free"</code>, <code>"grid"</code> or
<code>"series"</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>These are developer-level functions for generating permuted indexes
from one of several restricted and unrestricted designs.
</p>
<p><code>shuffleFree</code> is a wrapper to code underlying
<code><a href="base.html#topic+sample">sample</a></code>, but without the extra over head of sanity
checks. It is defined as <code>sample.int(x, size, replace = FALSE)</code>.
You must arrange for the correct values to be supplied, where
<code>x</code> is a vector of indices to sample from, and <code>size</code> is the
number of indices to sample. Sampling is done without replacement and
without regard to prior probabilities. Argument <code>size</code> is allowed
so that one can draw a single observation at random from the indices
<code>x</code>. In general use, <code>size</code> would be set equal to
<code>length{x}</code>.
</p>


<h3>Value</h3>

<p>A integer vector of permuted indices.
</p>


<h3>Author(s)</h3>

<p>Gavin Simpson</p>


<h3>See Also</h3>

<p><code><a href="#topic+check">check</a></code>, a utility function for checking
permutation scheme described by
<code><a href="#topic+how">how</a></code>. <code><a href="#topic+shuffle">shuffle</a></code> as a user-oriented
wrapper to these functions.</p>


<h3>Examples</h3>

<pre><code class='language-R'>
set.seed(3)

## draw 1 value at random from the set 1:10
shuffleFree(1:10, 1)

## permute the series 1:10
x &lt;- 1:10
shuffleSeries(x)                ## with random starting point
shuffleSeries(x, start = 5L)    ## known starting point
shuffleSeries(x, flip = TRUE)   ## random start, forced mirror
shuffleSeries(x, mirror = TRUE) ## random start, possibly mirror

## permute a grid of size 3x3
shuffleGrid(3, 3)                      ## random starting row/col
shuffleGrid(3, 3, start.row = 2,
            start.col = 3)             ## with known row/col
shuffleGrid(3, 3, flip = rep(TRUE, 2)) ## random start, forced mirror
</code></pre>

<hr>
<h2 id='shuffleSet'>
Generate a set of permutations from the specified design.
</h2><span id='topic+shuffleSet'></span><span id='topic+as.matrix.permutationMatrix'></span>

<h3>Description</h3>

<p><code>shuffleSet</code> returns a set of <code>nset</code> permutations from the
specified design. The main purpose of the function is to circumvent
the overhead of repeatedly calling <code><a href="#topic+shuffle">shuffle</a></code> to generate a
set of permutations.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>shuffleSet(n, nset, control = how(), check = TRUE, quietly = FALSE)

## S3 method for class 'permutationMatrix'
as.matrix(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="shuffleSet_+3A_n">n</code></td>
<td>

<p>numeric; the number of observations in the sample set. May also be
any object that <code>nobs</code> knows about; see
<code><a href="#topic+nobs-methods">nobs-methods</a></code>.
</p>
</td></tr>
<tr><td><code id="shuffleSet_+3A_nset">nset</code></td>
<td>

<p>numeric; the number of permutations to generate for the set. Can be
missing, the default, in which case <code>nset</code> is determined from
<code>control</code>.
</p>
</td></tr>
<tr><td><code id="shuffleSet_+3A_control">control</code></td>
<td>

<p>an object of class <code>"how"</code> describing a valid permutation
design.
</p>
</td></tr>
<tr><td><code id="shuffleSet_+3A_check">check</code></td>
<td>

<p>logical; should the design be checked for various problems via
function <code><a href="#topic+check">check</a></code>? The default is to check the design for
the stated number of observations and update <code>control</code>
accordingly. See Details.
</p>
</td></tr>
<tr><td><code id="shuffleSet_+3A_quietly">quietly</code></td>
<td>

<p>logical; should messages by suppressed?
</p>
</td></tr>
<tr><td><code id="shuffleSet_+3A_x">x</code></td>
<td>

<p>an object of class <code>"permutationMatrix"</code>, as returned by
<code>shuffleSet</code>.
</p>
</td></tr>
<tr><td><code id="shuffleSet_+3A_...">...</code></td>
<td>

<p>arguments passed to other methods. For the <code>as.matrix</code> method
only.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>shuffleSet</code> is designed to generate a set of <code>nset</code>
permutation indices over which a function can iterate as part of a
permutation test. It is only slightly more efficient than calling
<code><a href="#topic+shuffle">shuffle</a></code> <code>nset</code> times, but it is far more practical
than the simpler function because a set of permutations can be worked
on by applying a function to the rows of the returned object. This
simplifies the function applied, and facilitates the use of parallel
processing functions, thus enabling a larger number of permutations to
be evaluated in reasonable time.
</p>
<p>By default, <code>shuffleSet</code> will check the permutations design
following a few simple heuristics. See <code><a href="#topic+check">check</a></code> for details
of these. Whether some of the heuristics are activiated or not can be
controlled via <code><a href="#topic+how">how</a></code>, essentialy via its argument
<code>minperm</code>. In particular, if there are fewer than <code>minperm</code>
permutations, <code>shuffleSet</code> will generate and return <strong>all
possible permutations</strong>, which may differ from the number requested via
argument <code>nset</code>.
</p>
<p>The <code>check</code> argument to <code>shuffleSet</code> controls whether
checking is performed in the permutation design. If you set
<code>check = FALSE</code> then exactly <code>nset</code> permutations will be
returned. However, do be aware that there is no guarantee that the set
of permutations returned will be unique, especially so for designs and
data sets where there are few possible permutations relative to the
number requested.
</p>
<p>The <code>as.matrix</code> method sets the <code>control</code> and <code>seed</code>
attributes to <code>NULL</code> and removes the <code>"permutationMatrix"</code>
class, resulting in a standard matrix object.
</p>


<h3>Value</h3>

<p>Returns a matrix of permutations, where each row is a separate
permutation. As such, the returned matrix has <code>nset</code> rows and
<code>n</code> columns.
</p>


<h3>Author(s)</h3>

<p>Gavin L. Simpson
</p>


<h3>References</h3>

<p><code>shuffleSet()</code> is modelled after the permutation schemes of Canoco
3.1 (ter Braak, 1990); see also Besag &amp; Clifford (1989).
</p>
<p>Besag, J. and Clifford, P. (1989) Generalized Monte Carlo significance
tests. <em>Biometrika</em> <strong>76</strong>; 633&ndash;642.
</p>
<p>ter Braak, C. J. F. (1990). <em>Update notes: CANOCO version
3.1</em>. Wageningen: Agricultural Mathematics Group. (UR).
</p>


<h3>See Also</h3>

<p>See <code><a href="#topic+shuffle">shuffle</a></code> for generating a single permutation, and
<code><a href="#topic+how">how</a></code> for setting up permutation designs.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
set.seed(1)
## simple random permutations, 5 permutations in set
shuffleSet(n = 10, nset = 5)

## series random permutations, 5 permutations in set
shuffleSet(10, 5, how(within = Within(type = "series")))

## series random permutations, 10 permutations in set,
## with possible mirroring
CTRL &lt;- how(within = Within(type = "series", mirror = TRUE))
shuffleSet(10, 10, CTRL)

## Permuting strata
## 4 groups of 5 observations
CTRL &lt;- how(within = Within(type = "none"),
            plots = Plots(strata = gl(4,5), type = "free"))
shuffleSet(20, 10, control = CTRL)

## 10 random permutations in presence of Plot-level strata
plotStrata &lt;- Plots(strata = gl(4,5))
CTRL &lt;- how(plots = plotStrata,
            within = Within(type = "free"))
numPerms(20, control = CTRL)
shuffleSet(20, 10, control = CTRL)
## as above but same random permutation within Plot-level strata
CTRL &lt;- how(plots = plotStrata,
            within = Within(type = "free", constant = TRUE))
numPerms(20, control = CTRL)
shuffleSet(20, 10, CTRL) ## check this.

## time series within each level of Plot strata
CTRL &lt;- how(plots = plotStrata,
            within = Within(type = "series"))
shuffleSet(20, 10, CTRL)
## as above, but  with same permutation for each Plot-level stratum
CTRL &lt;- how(plots = plotStrata,
            within = Within(type = "series", constant = TRUE))
shuffleSet(20, 10, CTRL)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
