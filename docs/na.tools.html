<!DOCTYPE html><html lang="en"><head><title>Help for package na.tools</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {na.tools}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#all_na'><p>Tests for missing values</p></a></li>
<li><a href='#coerce_safe'><p>coerce_safe</p></a></li>
<li><a href='#impute-commutative'><p>Imputation by Cummutative Functions</p>
</p>
<p>Impute using replacement values calculated from a univariate, cummuative</p>
function.</a></li>
<li><a href='#impute-constant'><p>Impute by Constant Value</p>
</p>
<p>Replaces <code>NA</code>s by a constant</p></a></li>
<li><a href='#impute-noncommutative'><p>non-commutative imputation</p>
</p>
<p>Impute missing values using non-commutative functions, i.e. where the order</p>
<strong>matters</strong>.</a></li>
<li><a href='#n_na'><p>Counts how many values are NA</p></a></li>
<li><a href='#NA_explicit_'><p>NA_explicit_</p></a></li>
<li><a href='#NA_logical'><p>NA_logical</p></a></li>
<li><a href='#na.bootstrap'><p>na.bootstrap</p></a></li>
<li><a href='#na.replace'><p>Replace Missing Values</p></a></li>
<li><a href='#na.rm'><p>na.rm</p></a></li>
<li><a href='#na.unreplace'><p>na.unreplace</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Title:</td>
<td>Comprehensive Library for Working with Missing (NA) Values in
Vectors</td>
</tr>
<tr>
<td>Version:</td>
<td>0.3.1</td>
</tr>
<tr>
<td>Date:</td>
<td>2018-06-25</td>
</tr>
<tr>
<td>Description:</td>
<td>
    This comprehensive toolkit provide a consistent and 
    extensible framework for working with missing values in vectors. The 
    companion package 'tidyimpute' provides similar functionality for list-like 
    and table-like structures).
    Functions exist for detection, removal, replacement, imputation, 
    recollection, etc. of 'NAs'.</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/decisionpatterns/na.tools">https://github.com/decisionpatterns/na.tools</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/decisionpatterns/na.tools/issues">https://github.com/decisionpatterns/na.tools/issues</a></td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.1.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>stats, methods</td>
</tr>
<tr>
<td>Suggests:</td>
<td>testthat (&ge; 1.0.2)</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> | file LICENSE</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>6.0.1.9000</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2018-06-25 19:35:31 UTC; cbrown</td>
</tr>
<tr>
<td>Author:</td>
<td>Christopher Brown [aut, cre],
  Decision Patterns [cph]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Christopher Brown &lt;chris.brown@decisionpatterns.com&gt;</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2018-06-25 20:02:57 UTC</td>
</tr>
</table>
<hr>
<h2 id='all_na'>Tests for missing values</h2><span id='topic+all_na'></span><span id='topic+all_na.default'></span><span id='topic+any_na'></span><span id='topic+is_na'></span><span id='topic+which_na'></span>

<h3>Description</h3>

<p>Test if all values are missing
</p>


<h3>Usage</h3>

<pre><code class='language-R'>all_na(x)

## Default S3 method:
all_na(x)

any_na(x)

is_na()

which_na(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="all_na_+3A_x">x</code></td>
<td>
<p>object to test.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>These are S3 Generics that provide default methods.
</p>
<p><code>all_na</code> reports if <strong>all</strong> values are missing.
</p>
<p><code>any_na</code> reports if <strong>any</strong> values are missing. If always returns a logical
scalar.
</p>
<p><code>is_na</code> is a wrapper around <code><a href="base.html#topic+is.na">base::is.na()</a></code> created to keep stylistic
consistenct with the other functions.
</p>
<p><code>which_na</code> is implemented as <code>which( is.na(x) )</code>.
It is a S3 generic function.
</p>


<h3>Value</h3>

<p>logical scalar indicating if values are missing.
</p>
<p>logical scalar; either TRUE or FALSE.
</p>
<p><code>integer</code> of indexes of <code>x</code> that corerspond to elements
of x that are missing (<code>NA</code>).  Names of the result
are set to the names of <code>x</code>.
</p>


<h3>See Also</h3>


<ul>
<li> <p><code><a href="base.html#topic+anyNA">base::anyNA()</a></code>
</p>
</li></ul>


<ul>
<li> <p><code><a href="base.html#topic+is.na">base::is.na()</a></code> - for the variant returning logical
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>
  all_na( c( NA, NA, 1 ) )    # FALSE
  all_na( c( NA, NA, NA ) )   # TRUE
  
  df &lt;- data.frame( char = rep(NA_character_, 3), nums=1:3)
  all_na(df)  # FALSE
  
  df &lt;- data.frame( char = rep(NA_character_, 3), nums=rep(NA_real_,3))
  all_na(df)  # TRUE
  
  any_na( 1:10 )           # FALSE
  any_na( c( 1, NA, 3 ) )  # TRUE


  x &lt;- c( 1, NA, NA, 4:6 )
  which_na(x)
  
  names(x) &lt;- letters[1:6]
  which_na(x)
 
</code></pre>

<hr>
<h2 id='coerce_safe'>coerce_safe</h2><span id='topic+coerce_safe'></span>

<h3>Description</h3>

<p>Coerce values in a safe, non-destructive and consistent way.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>coerce_safe(object, class, alert = stop, ..., alert_irreversible = alert,
  alert_na = alert)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="coerce_safe_+3A_object">object</code></td>
<td>
<p>to be coerced</p>
</td></tr>
<tr><td><code id="coerce_safe_+3A_class">class</code></td>
<td>
<p>character; class to which <code>object</code> should be coerced.</p>
</td></tr>
<tr><td><code id="coerce_safe_+3A_alert">alert</code></td>
<td>
<p>function to use to raise exceptions: (Default: <code><a href="base.html#topic+stop">base::stop()</a></code>)</p>
</td></tr>
<tr><td><code id="coerce_safe_+3A_...">...</code></td>
<td>
<p>unused</p>
</td></tr>
<tr><td><code id="coerce_safe_+3A_alert_irreversible">alert_irreversible</code></td>
<td>
<p>function to raise alert when coercion is not
reversible. See Details.</p>
</td></tr>
<tr><td><code id="coerce_safe_+3A_alert_na">alert_na</code></td>
<td>
<p>function to raise when <code>NAs</code> are produced.
</p>
<p><code>coerce_safe</code> transform the <code>object</code> to <code>class</code> in a safe, consistent,
non-destructive way.
</p>
<p>Safe means that coercison:
</p>

<ol>
<li><p> is non-destructive (i.e information is not lost in the transformation )
</p>
</li>
<li><p> is reversible: </p>
<p style="text-align: center;"><code class="reqn"> f^{-1}( f(x) ) == x </code>
</p>

</li>
<li><p> does not introduce (additional) missing values (<code>NA</code>)
</p>
</li></ol>

<p>By default, <code>corece_safe</code> raises an alert (message|warning|error)
when the attempted coercion violates these constraints.  The <code>alert</code>
argument (and <code>alert_irreversible</code> or <code>alert_na</code>) can be used
to fleixble change the response.  Valid values for these are
<code><a href="base.html#topic+message">base::message()</a></code>, <code><a href="base.html#topic+warning">base::warning()</a></code> and <a href="base.html#topic+stop">base::stop</a> among others.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>object</code> coerced to <code>class</code> but ensured that there has been no loss in data
and no additional Missonve values introduced.
</p>


<h3>Note</h3>

<p>There must be a <code>as</code> method to the reverse coercion for this function to work.
</p>


<h3>See Also</h3>

<p><a href="methods.html#topic+as">methods::as</a>
'coercion::try_as()&ldquo;
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Not run: 
  # Error
  coerce_safe(1.01, "integer")  # 1.01 != 1
  coerce_safe( c("1","2","a"), "integer" )

## End(Not run)

</code></pre>

<hr>
<h2 id='impute-commutative'>Imputation by Cummutative Functions
Impute using replacement values calculated from a univariate, cummuative
function.</h2><span id='topic+impute-commutative'></span><span id='topic+na.max'></span><span id='topic+na.min'></span><span id='topic+na.mean'></span><span id='topic+na.median'></span><span id='topic+na.quantile'></span><span id='topic+na.mode'></span><span id='topic+na.most_freq'></span>

<h3>Description</h3>

<p>Imputation by Cummutative Functions
</p>
<p>Impute using replacement values calculated from a univariate, cummuative
function.
</p>
<p><code>na.median</code> imputes with the median value of <code>x</code>. The median is only valid
for numeric or logical values.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>na.max(.x, ...)

na.min(.x, ...)

na.mean(.x, ...)

na.median(.x, ...)

na.quantile(.x, ...)

na.mode(.x, ...)

na.most_freq(.x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="impute-commutative_+3A_.x">.x</code></td>
<td>
<p>vector in which <code>NA</code> values are to be replaced. The ordering of <code>x</code>
does not matter.</p>
</td></tr>
<tr><td><code id="impute-commutative_+3A_...">...</code></td>
<td>
<p>additional arguments passed to lower-level summary functions.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This collection of functions calculates a replacement value using an
unvariate function where the order of values in <code>x</code> do not matter,
i.e. commutative.
</p>
<p><code>na.max</code> and <code>na.min</code> replace missing values (<code>NA</code>) with the maximum or
minimum <em>of non-missing values <code>x</code>.</em>
( Internally: <code>base::max(..., na.rm=TRUE)</code> and <code>base::min(..., na.rm=TRUE)</code>.
<code>...</code> has no affect.
</p>
<p><code>na.mean</code> replaces <code>NA</code> values with the mean of <code>x</code>. Internally,
<code>mean(x, na.rm=TRUE, ... )</code> is used. If mean cannot be calculated (e.g. x
isn't numeric) then <code>x</code> is returned with a warning.
</p>
<p><code>na.quantile</code> imputes with a quantile. The quantile is specified by a
<code>probs</code> argument that is passed to <code><a href="stats.html#topic+quantile">stats::quantile()</a></code>. If <code>probs</code> can be
a scalar value in which all values are replaced by that quantile or a vector
of <code>length(.x)</code> values which replaces the missing values of x with the
<code>probs</code>. The ability to provide a vector may be deprecated in the future.
</p>
<p><code>na.mode</code> replaces all <code>NA</code> with the most frequently occuring value. In
the event of ties, the value encounter first in <code>.x</code> is used.
</p>
<p><code>na.most_freq</code> is an alias for <code>na.mode</code>.
</p>


<h3>Value</h3>

<p>A vector of <code>class(x)</code> and <code>length(x)</code> in which missing values (NA) have
been replaced the result of a function call: </p>
<p style="text-align: center;"><code class="reqn"> fun(x, ...) </code>
</p>



<h3>See Also</h3>


<ul>
<li> <p><code><a href="#topic+na.replace">na.replace()</a></code> - used internally by these functions
</p>
</li>
<li> <p><code><a href="#topic+na.constant">na.constant()</a></code>
</p>
</li></ul>


<ul>
<li> <p><code><a href="base.html#topic+max">base::max()</a></code> and <code><a href="base.html#topic+min">base::min()</a></code>
</p>
</li></ul>

<p><code><a href="stats.html#topic+median">median()</a></code>
</p>

<ul>
<li> <p><code><a href="stats.html#topic+quantile">quantile()</a></code>
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>  na.median( c(1,2,NA_real_,3) )
      
  na.quantile( c(1,2,NA_real_,3), prob=0.4 )

  na.mode( c(1,1,NA,4) )
  na.mode( c(1,1,4,4,NA) ) 

</code></pre>

<hr>
<h2 id='impute-constant'>Impute by Constant Value
Replaces <code>NA</code>s by a constant</h2><span id='topic+impute-constant'></span><span id='topic+na.constant'></span><span id='topic+na.inf'></span><span id='topic+na.neginf'></span><span id='topic+na.true'></span><span id='topic+na.false'></span><span id='topic+na.zero'></span>

<h3>Description</h3>

<p>Impute by Constant Value
</p>
<p>Replaces <code>NA</code>s by a constant
</p>


<h3>Usage</h3>

<pre><code class='language-R'>na.constant(.x, .na)

na.inf(.x)

na.neginf(.x)

na.true(.x)

na.false(.x)

na.zero(.x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="impute-constant_+3A_.x">.x</code></td>
<td>
<p>vector; of values to have the <code>NA</code></p>
</td></tr>
<tr><td><code id="impute-constant_+3A_.na">.na</code></td>
<td>
<p>scalar to use as replacement.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>These functions replace <strong>ALL</strong> <code>NA</code> values in <code>x</code> with an scalar
value specified by<code>.na</code>.
</p>
<p><code>na.constant</code> replaces missing values with a scalar constant. It is a wrapper
around <code><a href="#topic+na.replace">na.replace()</a></code> but permits <code>.na</code> to only be a scalar.
</p>
<p><code>na.inf</code> and <code>na.neginf</code> replace all missing values with <code>Inf</code> and <code>-Inf</code>
repectively.  '.
</p>
<p><code>na.true</code> and <code>na.false</code> replace missing values with <code>TRUE</code> and <code>FALSE</code>
respectively.
</p>
<p><code>na.zero</code> replaces missing values with <code>0</code> which gets coerced to the
<code>class(x)</code> as needed.
</p>


<h3>Value</h3>

<p>A vector with the type and length of <code>x</code> with all missing values replaces
by <code>.na</code>.
</p>


<h3>See Also</h3>


<ul>
<li> <p><code><a href="#topic+na.replace">na.replace()</a></code> the underlying function that performs the replacement.
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>  na.constant( c(1,NA,2), -1 )
 
  na.inf( c( 1, 2, NA, 4) )
  na.neginf( c( 1, 2, NA, 4) ) 
  
  na.true( c(TRUE, NA_logical, FALSE) )   # T T F
  na.false( c(TRUE, NA_logical, FALSE) )  # T F F

 
           
  na.zero( c(1,NA,3) )  # 1 0 3 

 
           
</code></pre>

<hr>
<h2 id='impute-noncommutative'>non-commutative imputation
Impute missing values using non-commutative functions, i.e. where the order
<strong>matters</strong>.</h2><span id='topic+impute-noncommutative'></span><span id='topic+na.cummax'></span><span id='topic+na.cummin'></span><span id='topic+na.cumsum'></span><span id='topic+na.cumprod'></span>

<h3>Description</h3>

<p>non-commutative imputation
</p>
<p>Impute missing values using non-commutative functions, i.e. where the order
<strong>matters</strong>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>na.cummax(.x, ...)

na.cummin(.x, ...)

na.cumsum(.x, ...)

na.cumprod(.x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="impute-noncommutative_+3A_.x">.x</code></td>
<td>
<p>atomic-vector with 0 or more missing values</p>
</td></tr>
<tr><td><code id="impute-noncommutative_+3A_...">...</code></td>
<td>
<p>additional arguments</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Non-commutative imputations functions assume that <code>.x</code> is in the proper order
since the values depend on order. Usually, this is relevant then <code>.x</code> is part
of a table.
</p>
<p>These functions replaces <code>NA</code> values with the cummulative max of <code>.x</code>. Internally,
<code>fun(.x, na.rm=TRUE, ... )</code> is used. If the function cannot be calculated
(e.g. <code>.x</code>  isn't numeric) then <code>x</code> is returned unchanged with a warning.
</p>
<p>Use of <code>na.cumsum</code> and <code>na.cumprod</code> are dangerous since they omit missing
values that may contribute to
</p>


<h3>See Also</h3>


<ul>
<li> <p><code><a href="base.html#topic+cummax">base::cummax()</a></code>
</p>
</li>
<li> <p><a href="#topic+impute-commutative">impute-commutative</a>
</p>
</li></ul>


<hr>
<h2 id='n_na'>Counts how many values are NA</h2><span id='topic+n_na'></span><span id='topic+na.howmany'></span><span id='topic+na.n'></span><span id='topic+pct_na'></span><span id='topic+na.pct'></span>

<h3>Description</h3>

<p>Returns the number of values that are NA
</p>


<h3>Usage</h3>

<pre><code class='language-R'>n_na(x)

na.howmany(x)

na.n(x)

pct_na(x)

na.pct(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="n_na_+3A_x">x</code></td>
<td>
<p>object to count how many values are <code>NA</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>n_na</code> counts the number of missing values. <code>na.n</code> is an alias in the dplyr
style.
</p>
<p><code>pct_na</code> gives the percentage of values that are <code>NA</code>
</p>


<h3>Value</h3>

<p><code>n_na</code> returns an integer. <code>pct_na</code> returns a numeric value 0-1.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  x &lt;- c( 1, NA, NA, 4:5 )
  n_na(x)
  pct_na(x)

</code></pre>

<hr>
<h2 id='NA_explicit_'>NA_explicit_</h2><span id='topic+NA_explicit_'></span>

<h3>Description</h3>

<p>Default replacement for missing values in categorical vectors.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>NA_explicit_
</code></pre>


<h3>Format</h3>

<p>An object of class <code>character</code> of length 1.</p>


<h3>Details</h3>

<p><code>NA_explicit_</code> is used as a default replacement for categorical vectors.
</p>
<p>It is an active binding to <code>getOptions('NA_explicit_')</code> and is exported
to the callers namespace.
</p>
<p>To change the value of <code>NA_explicit</code> use:</p>
<pre>options( NA_explicit = new_value )
</pre>
<p><code>NA_explicit_</code> cannot be directly set.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+na.replace">na.replace()</a></code>
</p>

<hr>
<h2 id='NA_logical'>NA_logical</h2><span id='topic+NA_logical'></span>

<h3>Description</h3>

<p>NA_logical
</p>


<h3>Usage</h3>

<pre><code class='language-R'>NA_logical
</code></pre>


<h3>Format</h3>

<p>An object of class <code>logical</code> of length 1.</p>


<h3>Details</h3>

<p>This simply creates a NA_logical variable. This is the same as NA
</p>

<hr>
<h2 id='na.bootstrap'>na.bootstrap</h2><span id='topic+na.bootstrap'></span><span id='topic+na.resample'></span>

<h3>Description</h3>

<p>Replace missing values with value randomly drawn from x
</p>


<h3>Usage</h3>

<pre><code class='language-R'>na.bootstrap(.x, ...)

na.resample(.x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="na.bootstrap_+3A_.x">.x</code></td>
<td>
<p>vector with</p>
</td></tr>
<tr><td><code id="na.bootstrap_+3A_...">...</code></td>
<td>
<p>additional arguments passed to <code><a href="base.html#topic+sample">base::sample()</a></code></p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>na.random</code> replaces missing values by sampling the non-missing values. By
default aampling occurs <strong>with replacement</strong> since more valuables may be needed than
are available. This function is based on <code><a href="base.html#topic+sample">base::sample()</a></code>.
</p>
<p>The default is to replace bv sampling a population defined by the
non-missing values of <code>.x</code> <strong>with replacement</strong>
</p>
<p><code>na.random</code> is an alias for <code>na.bootstrap</code>.
'
</p>


<h3>Note</h3>

<p><code>na.bootstrap</code> is <strong>non-deterministic</strong>. Use
<code><a href="base.html#topic+set.seed">base::set.seed()</a></code> to make it deterministic
</p>


<h3>See Also</h3>


<ul>
<li> <p><code><a href="base.html#topic+sample">base::sample()</a></code>
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>  x &lt;- c(1,NA,3)
  na.bootstrap(x)
  
</code></pre>

<hr>
<h2 id='na.replace'>Replace Missing Values</h2><span id='topic+na.replace'></span><span id='topic+na.explicit'></span>

<h3>Description</h3>

<p>Replaces <code>NA</code> values with explicit values.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>na.replace(x, .na, ...)

na.explicit(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="na.replace_+3A_x">x</code></td>
<td>
<p>vector in which <code>NA</code> values are to be replaced.</p>
</td></tr>
<tr><td><code id="na.replace_+3A_.na">.na</code></td>
<td>
<p>scalar, length(x)-vector or function used to replace <code>NA</code>. See #Details.</p>
</td></tr>
<tr><td><code id="na.replace_+3A_...">...</code></td>
<td>
<p>additional arguments passed to <code>.na</code> when it is a function.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>na.replace</code> replaces missing values in <code>x</code> by <code>.na</code> if possible.
</p>
<p>In R, replacement of values can cause a change in the class/type of an object.
This is not often desired. <code>na.replace</code> is class/type-safe and length-safe.
It replaces missing values without changing the <code>x</code>'s class or length
regardless of the value provided by <code>.na</code>.
</p>
<p><strong>Param: <code>x</code></strong>
</p>
<p>If <code>x</code> is <strong>categorical</strong> (e.g. character or factor), <code>.na</code> is optional.
The default is &quot;(NA)&quot; and can be set with
<code>options( NA_explicit_ = new_value )</code>. It can also be
referenced directly with <a href="#topic+NA_explicit_">NA_explicit_</a>.
</p>
<p>If <code>x</code> is a <strong>factor</strong>, unique values of <code>.na</code> not in already present in
<code>levels(x)</code> will be added. They are appended silently unless
<code>getOption('verbose')==TRUE</code> in which a message reports the added levels.
</p>
<p><strong>Param: <code>.na</code></strong>
</p>
<p><code>.na</code> can be either a scalar, vector or function.
</p>
<p>If a <strong>scalar</strong>, each missing value of <code>x</code> is replaced by <code>na</code>.
</p>
<p>If a <strong>vector</strong>, <code>.na</code> must have length(x)<code>. Missing values of</code>x<code>are replaced by corresponding elements of</code>.na<code>. Recycling values of</code>.na<code>is not allowed. An error will be thrown in the event that</code>length(.na)<code>is not</code>1<code>or</code>length(x)<code>.</code>
</p>
<p>If a <strong>function</strong>, <code>x</code> is transformed by .na' with:</p>
<pre>     .na(x, ...)
</pre>
<p>then preceding with normal operations.
</p>
<p><code>na.explicit</code> is an alias for na.replace that uses <a href="#topic+NA_explicit_">NA_explicit_</a> for '.na&ldquo;;
it returns x unchanged if it cannot change the value.
</p>


<h3>Value</h3>

<p>A vector with the class and length of <code>x</code>.
<code>NA</code>s in <code>x</code> will be replaced by <code>.na</code>. <code>.na</code> is coerced as necessary.
</p>


<h3>See Also</h3>


<ul>
<li> <p><code><a href="base.html#topic+ifelse">base::ifelse()</a></code>, <code><a href="base.html#topic+replace">base::replace()</a></code>
</p>
</li>
<li> <p><code>forcats::fct_explicit_na</code> - which only handles factors
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>
  # Integers and numerics
  na.replace( c(1,NA,3,NA), 2 )    # 1 2 3 2   
  na.replace( c(1,NA,3,NA), 1:4 )  # 1 2 3 4

  # This produces an error because it would change the type
  ## Not run: 
  na.replace( c(1,NA,3,NA), letters[1:4] )  # "1" "b" "3" "d"
  
## End(Not run)
  
  # Characters 
  lets &lt;- letters[1:5]
  lets[ c(2,4) ] &lt;- NA
  na.replace(lets)  # replace with NA_explicit_

  # Factors 
  fct &lt;- as.factor( c( NA, letters[2:4], NA) )
  fct
  na.replace(fct, "z")  # z b c d z  -- level z added
  na.replace(fct, letters[1:5] )
  na.replace(fct)
     
 ## Not run: 
   na.replace( rep(NA,3), rep(NA,3) )
 
## End(Not run)
     
</code></pre>

<hr>
<h2 id='na.rm'>na.rm</h2><span id='topic+na.rm'></span>

<h3>Description</h3>

<p>Removes <code>NA</code> values from objects
</p>


<h3>Usage</h3>

<pre><code class='language-R'>na.rm(object, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="na.rm_+3A_object">object</code></td>
<td>
<p>to remove <code>NA</code>s from</p>
</td></tr>
<tr><td><code id="na.rm_+3A_...">...</code></td>
<td>
<p>further arguments special methods could require.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For <strong>vectors</strong> this is the same as <code><a href="stats.html#topic+na.omit">stats::na.omit()</a></code> or
<code><a href="stats.html#topic+na.exclude">stats::na.exclude()</a></code>. It will also work on recursive objects.
</p>
<p>This is predominantly maintained for syntactic convenience since a number of
functions have na.omir
</p>


<h3>Value</h3>

<p>An object of the same class with all <code>NA</code> values removed. For
data.frame and data.table objects entire columns are removed if they
contain solely <code>NA</code> values.
</p>


<h3>See Also</h3>


<ul>
<li> <p><code><a href="stats.html#topic+na.omit">stats::na.omit()</a></code>, <code><a href="stats.html#topic+na.exclude">stats::na.exclude()</a></code>
</p>
</li>
<li> <p><code><a href="#topic+all_na">all_na()</a></code>
</p>
</li></ul>


<hr>
<h2 id='na.unreplace'>na.unreplace</h2><span id='topic+na.unreplace'></span><span id='topic+na.unreplace.default'></span><span id='topic+na.unreplace.character'></span><span id='topic+na.unreplace.factor'></span><span id='topic+na.implicit'></span>

<h3>Description</h3>

<p>Change values to NAs, ie make explicit <code>NAs</code> back to <code>NA</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>na.unreplace(x, values)

## Default S3 method:
na.unreplace(x, values = NULL)

## S3 method for class 'character'
na.unreplace(x, values = c("NA", NA_explicit_))

## S3 method for class 'factor'
na.unreplace(x, values = c("NA", NA_explicit_))

na.implicit(x, values)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="na.unreplace_+3A_x">x</code></td>
<td>
<p>object</p>
</td></tr>
<tr><td><code id="na.unreplace_+3A_values">values</code></td>
<td>
<p>values that are (or can be coerced to) <code>class(x)</code> that are to
be set to <code>NA</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>na.unreplace</code> replaces <code>values</code> by <code>NA</code>. It is meant to be nearly inverse
operation to <code>na_replace</code> (and <code>na_explicit</code>). It can be used on both atomic
and recursive objects. Unlike  <code>na.replace</code> however, <code>values</code> express the
values that if matched are set to <code>NA</code>.  It is basically:</p>
<pre>x[ x 
</pre>
<p><code>na.unreplace</code> is a S3 method that can be used to defince additional
methods for other objects.
</p>


<h3>See Also</h3>


<ul>
<li> <p><code><a href="#topic+na.replace">na.replace()</a></code>
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>
 na.unreplace( c(1,2,3,4), 3 )
 na.unreplace( c("A", "(NA)", "B", "C") )
 na.unreplace( c("A", NA_explicit_, "B", "C") )
 
 df &lt;- data.frame( char=c('A', 'NA', 'C', NA_explicit_), num=1:4 ) 
 na.unreplace(df)
 
 
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
