<!DOCTYPE html><html lang="en"><head><title>Help for package gek</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {gek}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#banana'><p>Rosenbrock's Banana Function</p></a></li>
<li><a href='#blockChol'><p>Block Cholesky Decomposition</p></a></li>
<li><a href='#blockCor'>
<p>Correlation Matrix without or with Derivatives</p></a></li>
<li><a href='#borehole'><p>Borehole Function</p></a></li>
<li><a href='#branin'><p>Branin-Hoo Function</p></a></li>
<li><a href='#camel3'><p>Three-Hump Camel Function</p></a></li>
<li><a href='#camel6'><p>Six-Hump Camel Function</p></a></li>
<li><a href='#cigar'><p>Bent Cigar Function</p></a></li>
<li><a href='#derivModelMatrix'>
<p>Derivatives of Model Matrix</p></a></li>
<li><a href='#gekm'>
<p>Fitting (Gradient-Enhanced) Kriging Models</p></a></li>
<li><a href='#griewank'><p>Griewank Function</p></a></li>
<li><a href='#himmelblau'><p>Himmelblau's Function</p></a></li>
<li><a href='#predict.gekm'>
<p>Predict Method for (Gradient-Enhanced) Kriging Model Fits</p></a></li>
<li><a href='#qing'><p>Qing Function</p></a></li>
<li><a href='#rastrigin'><p>Rastrigin Function</p></a></li>
<li><a href='#schwefel'><p>Schwefel Function</p></a></li>
<li><a href='#short'><p>Short Column Function</p></a></li>
<li><a href='#simulate.gekm'>
<p>Simulates Conditional Process Paths</p></a></li>
<li><a href='#sphere'><p>Sphere Function</p></a></li>
<li><a href='#steel'><p>Steel Column Function</p></a></li>
<li><a href='#styblinski'><p>Styblinski-Tang Function</p></a></li>
<li><a href='#sulfur'><p>Sulfur Model Function</p></a></li>
<li><a href='#tangents'><p>Add Tangent Lines to a Plot</p></a></li>
<li><a href='#testfunctions'><p>Testfunctions in <span class="pkg">gek</span></p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Title:</td>
<td>Gradient-Enhanced Kriging</td>
</tr>
<tr>
<td>Version:</td>
<td>1.1.0</td>
</tr>
<tr>
<td>Date:</td>
<td>2025-03-13</td>
</tr>
<tr>
<td>Description:</td>
<td>Gradient-Enhanced Kriging as an emulator for computer experiments based on Maximum-Likelihood estimation.</td>
</tr>
<tr>
<td>Imports:</td>
<td>stats, graphics, dfoptim</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.5.0)</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2025-03-13 15:45:01 UTC; vanmeegen</td>
</tr>
<tr>
<td>Author:</td>
<td>Carmen van Meegen <a href="https://orcid.org/0000-0003-4125-5088"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cre]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Carmen van Meegen &lt;vanmeegen@statistik.tu-dortmund.de&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2025-03-14 12:30:01 UTC</td>
</tr>
</table>
<hr>
<h2 id='banana'>Rosenbrock's Banana Function</h2><span id='topic+banana'></span><span id='topic+bananaGrad'></span>

<h3>Description</h3>

<p>Rosenbrock's banana function is defined by
</p>
<p style="text-align: center;"><code class="reqn">f_{\rm banana}(x_1, ..., x_d) = \sum_{k = 1}^{d - 1} (100 (x_{k+1} - x_k^2)^2 + (x_k - 1)^2)</code>
</p>

<p>with <code class="reqn">x_k \in [-5, 10]</code> for <code class="reqn">k = 1, ..., d</code> and <code class="reqn">d \geq 2</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>banana(x)
bananaGrad(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="banana_+3A_x">x</code></td>
<td>

<p>a numeric <code><a href="base.html#topic+vector">vector</a></code> of length <code>d</code> or a numeric <code><a href="base.html#topic+matrix">matrix</a></code> with <code>n</code> rows and <code>d</code> columns, where <code>d</code> must be greater than <code>1</code>.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The gradient of Rosenbrock's banana function is
</p>
<p style="text-align: center;"><code class="reqn">\nabla f_{\rm banana}(x_1, ..., x_d) = \begin{pmatrix} -400 (x_2 - x_1)^2 x_1 + 2 (x_1 - 1) \\ 200 (x_2 - x_1)^2 - 400 x_2 (x_3 - x_2^2) + 2 (x_2 - 1) \\ \vdots \\ 200 (x_{d-1} - x_{d-2})^2 - 400 x_{d-1} (x_d - x_{d-1}^2) + 2 (x_{d-1} - 1) \\ 200 (x_d - x_{d -1}^2)\end{pmatrix}.</code>
</p>

<p>Rosenbrock's banana function has one global minimum <code class="reqn">f_{\rm banana}(x^{\star}) = 0</code> at <code class="reqn">x^{\star} = (1,\dots, 1)</code>.
</p>


<h3>Value</h3>

<p><code>banana</code> returns the function value of Rosenbrock's banana function at <code>x</code>.
</p>
<p><code>bananaGrad</code> returns the gradient of Rosenbrock's banana function at <code>x</code>.
</p>


<h3>Author(s)</h3>

<p>Carmen van Meegen
</p>


<h3>References</h3>

<p>Jamil, M. and Yang, X.-S. (2013). A Literature Survey of Benchmark Functions for Global Optimization Problems. <em>International Journal of Mathematical Modelling and Numerical Optimisation</em>, <b>4</b>(2):150-â€“194. <a href="https://doi.org/10.1504/IJMMNO.2013.055204">doi:10.1504/IJMMNO.2013.055204</a>.
</p>
<p>Rosenbrock, H. H. (1960). An Automatic Method for Finding the Greatest or least Value of a Function. <em>The Computer Journal</em>, <b>3</b>(3):175&ndash;184. <a href="https://doi.org/10.1093/comjnl/3.3.175">doi:10.1093/comjnl/3.3.175</a>.
</p>
<p>Surjanovic, S. and Bingham, D. (2013). Virtual Library of Simulation Experiments: Test Functions and Datasets. <a href="https://www.sfu.ca/~ssurjano/">https://www.sfu.ca/~ssurjano/</a> (retrieved January 19, 2024). 
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Contour plot of Rosenbrock's banana function 
n.grid &lt;- 50
x1 &lt;- seq(-2, 2, length.out = n.grid)
x2 &lt;- seq(-1, 3, length.out = n.grid)
y &lt;- outer(x1, x2, function(x1, x2) banana(cbind(x1, x2)))
contour(x1, x2, y, xaxs = "i", yaxs = "i", nlevels = 25, xlab = "x1", ylab = "x2")

# Perspective plot of Rosenbrock's banana function
col.pal &lt;- colorRampPalette(c("#00007F", "blue", "#007FFF", "cyan", "#7FFF7F", "yellow",
	"#FF7F00", "red", "#7F0000"))
colors &lt;- col.pal(100)
y.facet.center &lt;- (y[-1, -1] + y[-1, -n.grid] + y[-n.grid, -1] + y[-n.grid, -n.grid])/4
y.facet.range &lt;- cut(y.facet.center, 100)
persp(x1, x2, y, phi = 30, theta = -315, expand = 0.75, ticktype = "detailed", 
	col = colors[y.facet.range])
</code></pre>

<hr>
<h2 id='blockChol'>Block Cholesky Decomposition</h2><span id='topic+blockChol'></span>

<h3>Description</h3>

<p><code>blockChol</code> calculates the block Cholesky decomposition of a partitioned matrix of the form
</p>
<p style="text-align: center;"><code class="reqn">A = \begin{pmatrix} K &amp; R^{\rm T} \\ R &amp; S \end{pmatrix}.</code>
</p>



<h3>Usage</h3>

<pre><code class='language-R'>blockChol(K, R = NULL, S = NULL, tol = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="blockChol_+3A_k">K</code></td>
<td>

<p>a real symmetric positive-definite square submatrix.
</p>
</td></tr>
<tr><td><code id="blockChol_+3A_r">R</code></td>
<td>

<p>an (optinal) rectangular submatrix.
</p>
</td></tr>
<tr><td><code id="blockChol_+3A_s">S</code></td>
<td>

<p>an (optional) real symmetric positive-definite square submatrix.
</p>
</td></tr>
<tr><td><code id="blockChol_+3A_tol">tol</code></td>
<td>

<p>an (optional) numeric tolerance, see &lsquo;Details&rsquo;.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>To obtain the block Cholesky decomposition
</p>
<p style="text-align: center;"><code class="reqn">\begin{pmatrix} K &amp; R^{\rm T} \\ R &amp; S \end{pmatrix} = \begin{pmatrix} L^{\rm T} &amp; 0 \\ Q^{\rm T} &amp; M^{\rm T} \end{pmatrix} \begin{pmatrix} L &amp; Q \\ 0 &amp; M \end{pmatrix}</code>
</p>

<p>the following steps are performed:
</p>

<ol>
<li><p>Calculate <code class="reqn">K = L^{\rm T}L</code> with upper triangular matrix <code class="reqn">L</code>.
</p>
</li>
<li><p>Solve <code class="reqn">L^{\rm T}Q = R^{\rm T}</code> via forward substitution.
</p>
</li>
<li><p>Compute <code class="reqn">N = S - Q^{\rm T}Q</code> the Schur complement of the block <code class="reqn">K</code> of the matrix <code class="reqn">A</code>.
</p>
</li>
<li><p>Determine <code class="reqn">N = M^{\rm T}M</code> with upper triangular matrix <code class="reqn">M</code>.
</p>
</li></ol>

<p>The upper triangular matrices <code class="reqn">L</code> and <code class="reqn">M</code> in step 1 and 4 are obtained by <code><a href="base.html#topic+chol">chol</a></code>.
Forward substitution in step 2 is carried out with <code><a href="base.html#topic+backsolve">backsolve</a></code> and the option <code>transpose = TRUE</code>.
</p>
<p>If <code>tol</code> is specified a regularization of the form <code class="reqn">A_{\epsilon} = A + \epsilon I</code> is conducted.
Here, <code>tol</code> is the upper bound for the logarithmic condition number of <code class="reqn">A_{\epsilon}</code>.
Then
</p>
<p style="text-align: center;"><code class="reqn">\epsilon = \max\left\{ \frac{\lambda_{\max}(\kappa(A) - e^{\code{tol}})}{\kappa(A)(e^{\code{tol}} - 1)}, 0 \right\}</code>
</p>

<p>is chosen as the minimal &quot;nugget&quot; that is added to the diagonal of <code class="reqn">A</code> to ensure <code class="reqn">\log(\kappa(A_{\epsilon})) \leq</code> <code>tol</code>.
</p>
<p>Within <span class="pkg">gek</span> this function is used to calculate the block Cholesky decomposition of the correlation matrix with derivatives.
Here <code>K</code> is the Kriging correlation matrix. 
<code>R</code> is the matrix containing the first partial derivatives and <code>S</code> consists of the second partial derivatives of the correlation matrix <code>K</code>.</p>


<h3>Value</h3>

<p><code>blockChol</code> returns a list with the following components:
</p>
<table role = "presentation">
<tr><td><code>L</code></td>
<td>
<p>the upper triangular factor of the Cholesky decomposition of <code>K</code>.</p>
</td></tr>
<tr><td><code>Q</code></td>
<td>
<p>the solution of the triangular system <code>t(L) %*% Q == t(R)</code>.</p>
</td></tr>
<tr><td><code>M</code></td>
<td>
<p>the upper triangular factor of the Cholesky decomposition of the Schur complement <code>N</code>.</p>
</td></tr>
</table>
<p>If <code>R</code> or <code>S</code> are not specified, <code>Q</code> and <code>M</code> are set to <code>NULL</code>,
i.e. only the Cholesky decomposition of <code>K</code> is calculated. 
</p>
<p>The attribute <code>"eps"</code> gives the minimum &ldquo;nugget&rdquo; that is added to the diagonal. 
</p>


<h3>Warning</h3>

<p>As in <code><a href="base.html#topic+chol">chol</a></code> there is no check for symmetry.
</p>


<h3>Author(s)</h3>

<p>Carmen van Meegen
</p>


<h3>References</h3>

<p>Chen, J., Jin, Z., Shi, Q., Qiu, J., and Liu, W. (2013). Block Algorithm and Its Implementation for Cholesky Factorization.
</p>
<p>Gustavson, F. G. and Jonsson, I. (2000). Minimal-storage high-performance Cholesky factorization via blocking and recursion. <em>IBM Journal of Research and Development</em>, <b>44</b>(6):823&ndash;850. <a href="https://doi.org/10.1147/rd.446.0823">doi:10.1147/rd.446.0823</a>.
</p>
<p>Ranjan, P., Haynes, R. and Karsten, R. (2011). A Computationally Stable Approach to Gaussian Process Interpolation of Deterministic Computer Simulation Data. <em>Technometrics</em>, <b>53</b>:366&ndash;378. <a href="https://doi.org/10.1198/TECH.2011.09141">doi:10.1198/TECH.2011.09141</a>.
</p>


<h3>See Also</h3>

<p><code><a href="base.html#topic+chol">chol</a></code> for the Cholesky decomposition.
</p>
<p><code><a href="base.html#topic+backsolve">backsolve</a></code> for backward substitution.
</p>
<p><code><a href="#topic+blockCor">blockCor</a></code> for computing a correlation matrix with derivatives.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Construct correlation matrix
x &lt;- matrix(seq(0, 1, length = 5), ncol = 1)
res &lt;- blockCor(x, theta = 1, covtype = "gaussian", derivatives = TRUE)
A &lt;- cbind(rbind(res$K, res$R), rbind(t(res$R), res$S))

# Cholesky decomposition of correlation matix without derivatives
cholK &lt;- blockChol(res$K)
cholK
cholK$L == chol(res$K)

# Cholesky decomposition of correlation matix with derivatives
cholA &lt;- blockChol(res$K, res$R, res$S) 
cholA &lt;- cbind(rbind(cholA$L, matrix(0, ncol(cholA$Q), nrow(cholA$Q))), 
	rbind(cholA$Q, cholA$M))
cholA
cholA == chol(A)

# Cholesky decomposition of correlation matix with derivatives with regularization
res &lt;- blockCor(x, theta = 2, covtype = "gaussian", derivatives = TRUE)
A &lt;- cbind(rbind(res$K, res$R), rbind(t(res$R), res$S))
try(blockChol(res$K, res$R, res$S))
blockChol(res$K, res$R, res$S, tol = 35)
</code></pre>

<hr>
<h2 id='blockCor'>
Correlation Matrix without or with Derivatives
</h2><span id='topic+blockCor'></span><span id='topic+blockCor.default'></span><span id='topic+blockCor.gekm'></span>

<h3>Description</h3>

<p>Calculation of a correlation matrix with or without derivatives according to the specification of a correlation structure. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>blockCor(x, ...)

## Default S3 method:
blockCor(x, theta, covtype = c("matern5_2", "matern3_2", "gaussian"), 
	derivatives = FALSE, ...)
## S3 method for class 'gekm'
blockCor(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="blockCor_+3A_x">x</code></td>
<td>

<p>a numeric <code><a href="base.html#topic+matrix">matrix</a></code> or an object of class <code><a href="#topic+gekm">gekm</a></code>.
</p>
</td></tr>
<tr><td><code id="blockCor_+3A_theta">theta</code></td>
<td>

<p><code><a href="base.html#topic+numeric">numeric</a></code> vector of length <code>d</code> for the hyperparameters.
</p>
</td></tr>
<tr><td><code id="blockCor_+3A_covtype">covtype</code></td>
<td>

<p><code><a href="base.html#topic+character">character</a></code> specifying the correlation function to be used. Must be one of <code>"matern5_2"</code>, <code>"matern3_2"</code> or <code>"gaussian"</code>.
See &lsquo;Details&rsquo;.</p>
</td></tr>
<tr><td><code id="blockCor_+3A_derivatives">derivatives</code></td>
<td>

<p><code><a href="base.html#topic+logical">logical</a></code>, if <code>TRUE</code> the first and second partial derivatives of the correlation matrix are calculated, otherwise not.
</p>
</td></tr>
<tr><td><code id="blockCor_+3A_...">...</code></td>
<td>

<p>further arguments passed to or from other methods.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The correlation matrix with derivatives is defined as a block matrix of the form
</p>
<p style="text-align: center;"><code class="reqn">\begin{pmatrix} K &amp; R^{\rm T} \\ R &amp; S \end{pmatrix}.</code>
</p>

<p>Three correlation functions are currently implemented in <code>blockCor</code>:
</p>

<ul>
<li><p>MatÃ©rn 5/2 kernel with <code>covtype = "matern5_2"</code>: </p>
<p style="text-align: center;"><code class="reqn">\phi(x, x'; \theta) = \prod_{k = 1}^d \left(1 + \frac{\sqrt{5}|x_k - x_k'|}{\theta_k} + \frac{5 |x_k - x_k'|^2}{3 \theta_k^2}\right) \exp\left( -\frac{\sqrt{5}|x_k - x_k'|}{\theta_k}\right)</code>
</p>

</li>
<li><p>MatÃ©rn 3/2 kernel with <code>covtype = "matern3_2"</code>: </p>
<p style="text-align: center;"><code class="reqn">\phi(x, x'; \theta) = \prod_{k = 1}^d \left(1 + \frac{\sqrt{3} |x_k - x_k'|}{\theta_k} \right) \exp\left( -\frac{\sqrt{3} |x_k - x_k'|}{\theta_k}\right)</code>
</p>

</li>
<li><p>Gaussian kernel with <code>covtype = "gaussian"</code>: </p>
<p style="text-align: center;"><code class="reqn">\phi(x, x'; \theta) = \prod_{k = 1}^d \exp\left( -\frac{(x_k - x_k')^2}{2\theta_k^2}\right)</code>
</p>

</li></ul>



<h3>Value</h3>

<p><code>blockCor</code> returns a list with the following components:
</p>
<table role = "presentation">
<tr><td><code>K</code></td>
<td>
<p>The correlation matrix without derivatives.</p>
</td></tr>
<tr><td><code>R</code></td>
<td>
<p>If <code>derivatives = TRUE</code>, the correlation matrix with first partial derivatives, otherwise <code>NULL</code>.</p>
</td></tr>
<tr><td><code>S</code></td>
<td>
<p>If <code>derivatives = TRUE</code>, the correlation matrix with second partial derivatives, otherwise <code>NULL</code>.</p>
</td></tr>
</table>
<p>The components of the list can be combined in the following form to constructed the complete correlation matrix with derivatives:
<code>cbind(rbind(K, R), rbind(t(R), S))</code>.
</p>


<h3>Author(s)</h3>

<p>Carmen van Meegen
</p>


<h3>References</h3>

<p>Koehler, J. and Owen, A. (1996). Computer Experiments. In Ghosh, S. and Rao, C. (eds.), <em>Design and Analysis of Experiments</em>, volume 13 of <em>Handbook of Statistics</em>, pp. 261â€“308. Elsevier Science. <a href="https://doi.org/10.1016/S0169-7161%2896%2913011-X">doi:10.1016/S0169-7161(96)13011-X</a>.
</p>
<p>Rasmussen, C. E. and Williams, C. K. I. (2006). <em>Gaussian Processes for Machine Learning</em>. The MIT Press. <a href="https://gaussianprocess.org/gpml/">https://gaussianprocess.org/gpml/</a>.
</p>
<p>Stein, M. L. (1999). <em>Interpolation of Spatial Data: Some Theory for Kriging</em>. Springer Series in Statistics. Springer-Verlag. <a href="https://doi.org/10.1007/978-1-4612-1494-6">doi:10.1007/978-1-4612-1494-6</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+blockChol">blockChol</a></code> for block Cholesky decomposition.
</p>
<p><code><a href="#topic+tangents">tangents</a></code> for drawing tangent lines.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Some examples of correlation matrices:

x &lt;- matrix(1:4, ncol = 1)
blockCor(x, theta = 1)
blockCor(x, theta = 1, covtype = "gaussian")
blockCor(x, theta = 1, covtype = "gaussian", derivatives = TRUE)
blockCor(x, theta = 1, covtype = "matern3_2", derivatives = TRUE)

res &lt;- blockCor(x, theta = 2, covtype = "gaussian", derivatives = TRUE)
cbind(rbind(res$K, res$R), rbind(t(res$R), res$S))


# Illustration of correlation functions and their derivatives:

x &lt;- seq(0, 1, length = 100)
X &lt;- matrix(x, ncol = 1)
gaussian &lt;- blockCor(X, theta = 0.25, covtype = "gaussian", derivatives = TRUE)
matern5_2 &lt;- blockCor(X, theta = 0.25, covtype = "matern5_2", derivatives = TRUE)
matern3_2 &lt;- blockCor(X, theta = 0.25, covtype = "matern3_2", derivatives = TRUE)

# Correlation functions and first partial derivatives:
index &lt;- c(10, 20, 40, 80)
par(mar = c(5.1, 5.1, 4.1, 2.1))

# Matern 3/2
plot(x, matern3_2$K[1, ], type = "l", xlab = expression(group("|", x - x*minute, "|")),
	ylab = expression(phi(x, x*minute, theta == 0.25)), lwd = 2)
tangents(x[index], matern3_2$K[index, 1], matern3_2$R[index, 1], 
	length = 0.15, lwd = 2, col = 2)
points(x[index], matern3_2$K[index, 1], pch = 16)

# Matern 5/2
lines(x, matern5_2$K[1, ], lwd = 2, col = 3)
tangents(x[index], matern5_2$K[index, 1], matern5_2$R[index, 1], 
	length = 0.15, lwd = 2, col = 2)
points(x[index], matern5_2$K[index, 1], pch = 16)

# Gaussian
lines(x, gaussian$K[1, ], lwd = 2, col = 4)
tangents(x[index], gaussian$K[index, 1], gaussian$R[index, 1], 
	length = 0.15, lwd = 2, col = 2)
points(x[index], gaussian$K[index, 1], pch = 16)

legend("topright", lty = 1, lwd = 2, col = c(1, 3, 4), bty = "n",
	legend = c("Matern 3/2", "Matern 5/2", "Gaussian"))


# First and second partial derivatives of correlation functions:
index &lt;- c(5, 10, 20, 40, 80)
par(mar = c(5.1, 6.1, 4.1, 2.1))

# Gaussian
plot(x, matern3_2$R[1, ], type = "l", xlab = expression(group("|", x - x*minute, "|")),
	ylab = expression(frac(partialdiff * phi(x, x*minute, theta == 0.25), 
		partialdiff * x * minute)), lwd = 2)
tangents(x[index], matern3_2$R[1, index], matern3_2$S[index, 1], 
	length = 0.15, lwd = 2, col = 2)
points(x[index], matern3_2$R[1, index], pch = 16)

# Matern 5/2
lines(x, matern5_2$R[1, ], lwd = 2, col = 3)
tangents(x[index], matern5_2$R[1, index], matern5_2$S[index, 1], 
	length = 0.15, lwd = 2, col = 2)
points(x[index], matern5_2$R[1, index], pch = 16)

# Matern 3/2
lines(x, gaussian$R[1, ], lwd = 2, col = 4)
tangents(x[index], gaussian$R[1, index], gaussian$S[index, 1], 
	length = 0.15, lwd = 2, col = 2)
points(x[index], gaussian$R[1, index], pch = 16)

legend("topright", lty = 1, lwd = 2, col = c(1, 3, 4), bty = "n",
	legend = c("Matern 3/2", "Matern 5/2", "Gaussian"))
</code></pre>

<hr>
<h2 id='borehole'>Borehole Function</h2><span id='topic+borehole'></span><span id='topic+boreholeGrad'></span>

<h3>Description</h3>

<p>The borehole function is defined by
</p>
<p style="text-align: center;"><code class="reqn">f_{\rm borehole}(x) = \frac{2 \pi T_u (H_u - H_l)}{\log(r/r_w)\left(1 + \frac{2 L T_u}{\log(r / r_w) r_w^2 K_w} + \frac{T_u}{T_l}\right)}</code>
</p>

<p>with <code class="reqn">x = (r_w, r, T_u, H_u, T_l, H_l, L, K_w)</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>borehole(x)
boreholeGrad(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="borehole_+3A_x">x</code></td>
<td>

<p>a numeric <code><a href="base.html#topic+vector">vector</a></code> of length <code>8</code> or a numeric <code><a href="base.html#topic+matrix">matrix</a></code> with <code>n</code> rows and <code>8</code> columns.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The borehole function calculates the water flow rate <code class="reqn">\rm [m^3/yr]</code> through a borehole.
</p>

<table>
<tr>
 <td style="text-align: left;">
	Input </td><td style="text-align: right;"> Domain </td><td style="text-align: right;"> Distribution </td><td style="text-align: left;"> Description </td>
</tr>
<tr>
 <td style="text-align: left;">
	<code class="reqn">r_w</code> </td><td style="text-align: right;"> <code class="reqn">[0.05, 0.15]</code> </td><td style="text-align: right;"> <code class="reqn">\mathcal{N}(0.1, 0.0161812)</code> </td><td style="text-align: left;"> radius of borehole in <code class="reqn">\rm m</code> </td>
</tr>
<tr>
 <td style="text-align: left;">
	<code class="reqn">r</code> </td><td style="text-align: right;"> <code class="reqn">[100, 50\,000]</code> </td><td style="text-align: right;"> <code class="reqn">\mathcal{LN}(7.71, 1.0056)</code> </td><td style="text-align: left;"> radius of influence in <code class="reqn">\rm m</code> </td>
</tr>
<tr>
 <td style="text-align: left;">
	<code class="reqn">T_u</code> </td><td style="text-align: right;"> <code class="reqn">[63070, 115600]</code> </td><td style="text-align: right;"> <code class="reqn">\mathcal{U}(63070, 115600)</code> </td><td style="text-align: left;"> transmissivity of upper aquifer in <code class="reqn">\rm m^2/yr</code> </td>
</tr>
<tr>
 <td style="text-align: left;">
	<code class="reqn">H_u</code> </td><td style="text-align: right;"> <code class="reqn">[990, 1100]</code> </td><td style="text-align: right;"> <code class="reqn">\mathcal{U}(990, 1110)</code> </td><td style="text-align: left;"> potentiometric head of upper aquifer in <code class="reqn">\rm m</code> </td>
</tr>
<tr>
 <td style="text-align: left;">
	<code class="reqn">T_l</code> </td><td style="text-align: right;"> <code class="reqn">[63.1, 116]</code> </td><td style="text-align: right;"> <code class="reqn">\mathcal{U}(63.1, 116)</code> </td><td style="text-align: left;"> transmissivity of lower aquifer in <code class="reqn">\rm m^2/yr</code> </td>
</tr>
<tr>
 <td style="text-align: left;">
	<code class="reqn">H_l</code> </td><td style="text-align: right;"> <code class="reqn">[700, 820]</code> </td><td style="text-align: right;"> <code class="reqn">\mathcal{U}(700, 820)</code> </td><td style="text-align: left;"> potentiometric head of lower aquifer in <code class="reqn">\rm m</code> </td>
</tr>
<tr>
 <td style="text-align: left;">
	<code class="reqn">L</code> </td><td style="text-align: right;"> <code class="reqn">[1120, 1680]</code> </td><td style="text-align: right;"> <code class="reqn">\mathcal{U}(1120, 1680)</code> </td><td style="text-align: left;"> length of borehole in <code class="reqn">\rm m</code> </td>
</tr>
<tr>
 <td style="text-align: left;">
	<code class="reqn">K_w</code> </td><td style="text-align: right;"> <code class="reqn">[9855, 12045]</code> </td><td style="text-align: right;"> <code class="reqn">\mathcal{U}(9855, 12045)</code> </td><td style="text-align: left;"> hydraulic conductivity of borehole in <code class="reqn">\rm m/yr</code> </td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>

<p>Note, <code class="reqn">\mathcal{N}(\mu, \sigma)</code> represents the normal distribution with expected value <code class="reqn">\mu</code> and standard deviation <code class="reqn">\sigma</code>
and <code class="reqn">\mathcal{LN}(\mu, \sigma)</code> is the log-normal distribution with mean <code class="reqn">\mu</code> and standard deviation <code class="reqn">\sigma</code> of the logarithm.
Further, <code class="reqn">\mathcal{U}(a,b)</code> denotes the continuous uniform distribution over the interval <code class="reqn">[a,b]</code>.
</p>


<h3>Value</h3>

<p><code>borehole</code> returns the function value of borehole function at <code>x</code>.
</p>
<p><code>boreholeGrad</code> returns the gradient of borehole function at <code>x</code>.
</p>


<h3>Author(s)</h3>

<p>Carmen van Meegen
</p>


<h3>References</h3>

<p>Harper, W. V. and Gupta, S. K. (1983). Sensitivity/Uncertainty Analysis of a Borehole Scenario Comparing Latin Hypercube Sampling and Deterministic Sensitivity Approaches.
BMI/ONWI-516, Office of Nuclear Waste Isolation, Battelle Memorial Institute, Columbus, OH.
</p>
<p>Morris, M., Mitchell, T., and Ylvisaker, D. (1993). Bayesian Design and Analysis of Computer Experiments: Use of Derivatives in Surface Prediction. <em>Technometrics</em>, <b>35</b>(3):243&ndash;255. <a href="https://doi.org/10.1080/00401706.1993.10485320">doi:10.1080/00401706.1993.10485320</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+gekm">gekm</a></code> for another example.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># List of inputs with their distributions and their respective ranges
inputs &lt;- list("r_w" = list(dist = "norm", mean =  0.1, sd = 0.0161812, min = 0.05, max = 0.15),
	"r" = list(dist = "lnorm", meanlog = 7.71, sdlog = 1.0056, min = 100, max = 50000),
	"T_u" = list(dist = "unif", min = 63070, max = 115600),
	"H_u" = list(dist = "unif", min = 990, max = 1110),
	"T_l" = list(dist = "unif", min = 63.1, max = 116),
	"H_l" = list(dist = "unif", min = 700, max = 820),
	"L" = list(dist = "unif", min = 1120, max = 1680),
	# for a more nonlinear, nonadditive function, see Morris et al. (1993)
	"K_w" = list(dist = "unif", min = 1500, max = 15000))

# Function for Monte Carlo simulation
samples &lt;- function(x, N = 10^5){
	switch(x$dist,
		"norm" = rnorm(N, x$mean, x$sd),
		"lnorm" = rlnorm(N, x$meanlog, x$sdlog),
		"unif" = runif(N, x$min, x$max))
}

# Uncertainty distribution of the water flow rate
set.seed(1)
X &lt;- sapply(inputs, samples)
y &lt;- borehole(X)
hist(y, breaks = 50, xlab = expression(paste("Water flow rate ", group("[", m^3/yr, "]"))), 
	main = "", freq = FALSE)
</code></pre>

<hr>
<h2 id='branin'>Branin-Hoo Function</h2><span id='topic+branin'></span><span id='topic+braninGrad'></span>

<h3>Description</h3>

<p>The Branin-Hoo function is defined by
</p>
<p style="text-align: center;"><code class="reqn">f_{\rm branin}(x_1, x_2) = \left(x_2 - \frac{5.1}{4 \pi^2}x_1^2 + \frac{5}{\pi}x_1 - 6\right)^2 + 10 \left(1-\frac{1}{8\pi}\right)\cos(x_1) + 10</code>
</p>

<p>with <code class="reqn">x_1 \in [-5, 10]</code> and <code class="reqn">x_2 \in [0, 15]</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>branin(x)
braninGrad(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="branin_+3A_x">x</code></td>
<td>

<p>a numeric <code><a href="base.html#topic+vector">vector</a></code> of length <code>2</code> or a numeric <code><a href="base.html#topic+matrix">matrix</a></code> with <code>n</code> rows and <code>2</code> columns.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The gradient of the Branin-Hoo function is
</p>
<p style="text-align: center;"><code class="reqn">\nabla f_{\rm branin}(x_1, x_2) = \begin{pmatrix} 2 \left(x_2 - \frac{5.1 x_1^2}{4 \pi^2} + \frac{5 x_1}{\pi} - 6\right) \left(-10.2 \frac{x_1}{4\pi^2} + \frac{5}{\pi}\right) - 10 \left(1 - \frac{1}{8\pi}\right) \sin(x_1) \\ 2 \left( x_2 - \frac{5.1 x_1^2}{4 \pi^2} + \frac{5 x_1}{\pi} - 6\right)\end{pmatrix}.</code>
</p>

<p>The Branin-Hoo function has three global minima <code class="reqn">f_{\rm branin}(x^{\star}) = 0.397887</code> at <code class="reqn">x^{\star} = (-\pi, 12.275)</code>, <code class="reqn">x^{\star} = (\pi, 2.275)</code> and <code class="reqn">x^{\star} = (9.42478, 2.475)</code>. 
</p>


<h3>Value</h3>

<p><code>branin</code> returns the function value of the Branin-Hoo function at <code>x</code>.
</p>
<p><code>braninGrad</code> returns the gradient of the Branin-Hoo function at <code>x</code>.
</p>


<h3>Author(s)</h3>

<p>Carmen van Meegen
</p>


<h3>References</h3>

<p>Branin, Jr., F. H. (1972). Widely Convergent Method of Finding Multiple Solutions of Simultaneous Nonlinear Equations. <em>IBM Journal of Research and Development</em>, <b>16</b>(5):504&ndash;522.
</p>
<p>Surjanovic, S. and Bingham, D. (2013). Virtual Library of Simulation Experiments: Test Functions and Datasets. <a href="https://www.sfu.ca/~ssurjano/">https://www.sfu.ca/~ssurjano/</a> (retrieved January 19, 2024). 
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Contour plot of Branin-Hoo function 
n.grid &lt;- 50
x1 &lt;- seq(-5, 10, length.out = n.grid)
x2 &lt;- seq(0, 15, length.out = n.grid)
y &lt;- outer(x1, x2, function(x1, x2) branin(cbind(x1, x2)))
contour(x1, x2, y, xaxs = "i", yaxs = "i", nlevels = 25, xlab = "x1", ylab = "x2")

# Perspective plot of Branin-Hoo function
col.pal &lt;- colorRampPalette(c("#00007F", "blue", "#007FFF", "cyan", "#7FFF7F", "yellow",
	"#FF7F00", "red", "#7F0000"))
colors &lt;- col.pal(100)
y.facet.center &lt;- (y[-1, -1] + y[-1, -n.grid] + y[-n.grid, -1] + y[-n.grid, -n.grid])/4
y.facet.range &lt;- cut(y.facet.center, 100)
persp(x1, x2, y, phi = 30, theta = -315, expand = 0.75, ticktype = "detailed", 
	col = colors[y.facet.range])
</code></pre>

<hr>
<h2 id='camel3'>Three-Hump Camel Function</h2><span id='topic+camel3'></span><span id='topic+camel3Grad'></span>

<h3>Description</h3>

<p>The three-hump camel function is defined by
</p>
<p style="text-align: center;"><code class="reqn">f_{\rm camel3}(x_1, x_2) = 2 x_1^2 - 1.05 x_1^4 + \frac{x_1^6}{6} + x_1 x_2 + x_2^2</code>
</p>

<p>with <code class="reqn">x_1, x_2 \in [-5, 5]</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>camel3(x)
camel3Grad(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="camel3_+3A_x">x</code></td>
<td>

<p>a numeric <code><a href="base.html#topic+vector">vector</a></code> of length <code>2</code> or a numeric <code><a href="base.html#topic+matrix">matrix</a></code> with <code>n</code> rows and <code>2</code> columns.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The gradient of the three-hump camel function is
</p>
<p style="text-align: center;"><code class="reqn">\nabla f_{\rm camel3}(x_1, x_2) = \begin{pmatrix} 4 x_1 - 4.2 x_1^3 + x_1^5 + x_2 \\ x_1 + 2 x_2 \end{pmatrix}.</code>
</p>

<p>The three-hump camel function has one global minimum <code class="reqn">f_{\rm camel3}(x^{\star}) = 0</code> at <code class="reqn">x^{\star} = (0, 0)</code>.
</p>


<h3>Value</h3>

<p><code>camel3</code> returns the function value of the three-hump camel function at <code>x</code>.
</p>
<p><code>camel3Grad</code> returns the gradient of the three-hump camel function at <code>x</code>.
</p>


<h3>Author(s)</h3>

<p>Carmen van Meegen
</p>


<h3>References</h3>

<p>Jamil, M. and Yang, X.-S. (2013). A Literature Survey of Benchmark Functions for Global Optimization Problems. <em>International Journal of Mathematical Modelling and Numerical Optimisation</em>, <b>4</b>(2):150-â€“194. <a href="https://doi.org/10.1504/IJMMNO.2013.055204">doi:10.1504/IJMMNO.2013.055204</a>.
</p>
<p>Surjanovic, S. and Bingham, D. (2013). Virtual Library of Simulation Experiments: Test Functions and Datasets. <a href="https://www.sfu.ca/~ssurjano/">https://www.sfu.ca/~ssurjano/</a> (retrieved January 19, 2024). 
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Contour plot of three-hump camel function 
n.grid &lt;- 50
x1 &lt;- x2 &lt;- seq(-2, 2, length.out = n.grid)
y &lt;- outer(x1, x2, function(x1, x2) camel3(cbind(x1, x2)))
contour(x1, x2, y, xaxs = "i", yaxs = "i", nlevels = 25, xlab = "x1", ylab = "x2")

# Perspective plot of three-hump camel function
col.pal &lt;- colorRampPalette(c("#00007F", "blue", "#007FFF", "cyan", "#7FFF7F", "yellow",
	"#FF7F00", "red", "#7F0000"))
colors &lt;- col.pal(100)
y.facet.center &lt;- (y[-1, -1] + y[-1, -n.grid] + y[-n.grid, -1] + y[-n.grid, -n.grid])/4
y.facet.range &lt;- cut(y.facet.center, 100)
persp(x1, x2, y, phi = 30, theta = -315, expand = 0.75, ticktype = "detailed", 
	col = colors[y.facet.range])
</code></pre>

<hr>
<h2 id='camel6'>Six-Hump Camel Function</h2><span id='topic+camel6'></span><span id='topic+camel6Grad'></span>

<h3>Description</h3>

<p>The six-hump camel function is defined by
</p>
<p style="text-align: center;"><code class="reqn">f_{\rm camel6}(x_1, x_2) = \left(4 - 2.1 x_1^2 + \frac{x_1^4}{3}\right) x_1^2 + x_1 x_2 + (-4 + 4 x_2^2) x_2^2</code>
</p>

<p>with <code class="reqn">x_1 \in [-3, 3]</code> and <code class="reqn">x_2 \in [-2, 2]</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>camel6(x)
camel6Grad(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="camel6_+3A_x">x</code></td>
<td>

<p>a numeric <code><a href="base.html#topic+vector">vector</a></code> of length <code>2</code> or a numeric <code><a href="base.html#topic+matrix">matrix</a></code> with <code>n</code> rows and <code>2</code> columns.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The gradient of the six-hump camel function is
</p>
<p style="text-align: center;"><code class="reqn">\nabla f_{\rm camel6}(x_1, x_2) = \begin{pmatrix} 8 x_1 - 8.4 x_1^3 + 2 x_1^5 + x_2 \\ x_1 - 8 x_2 + 16 x_2^3 \end{pmatrix}.</code>
</p>

<p>The six-hump camel function has two global minima <code class="reqn">f_{\rm camel6}(x^{\star}) = -1.031628</code> at <code class="reqn">x^{\star} = (0.0898, -0.7126)</code> and <code class="reqn">x^{\star} = (-0.0898, 0.7126)</code>.
</p>


<h3>Value</h3>

<p><code>camel6</code> returns the function value of the six-hump camel function function at <code>x</code>.
</p>
<p><code>camel6Grad</code> returns the gradient of the six-hump camel function function at <code>x</code>. 
</p>


<h3>Author(s)</h3>

<p>Carmen van Meegen
</p>


<h3>References</h3>

<p>Jamil, M. and Yang, X.-S. (2013). A Literature Survey of Benchmark Functions for Global Optimization Problems. <em>International Journal of Mathematical Modelling and Numerical Optimisation</em>, <b>4</b>(2):150-â€“194. <a href="https://doi.org/10.1504/IJMMNO.2013.055204">doi:10.1504/IJMMNO.2013.055204</a>.
</p>
<p>Surjanovic, S. and Bingham, D. (2013). Virtual Library of Simulation Experiments: Test Functions and Datasets. <a href="https://www.sfu.ca/~ssurjano/">https://www.sfu.ca/~ssurjano/</a> (retrieved January 19, 2024). 
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Contour plot of six-hump camel function 
n.grid &lt;- 50
x1 &lt;- seq(-2, 2, length.out = n.grid)
x2 &lt;- seq(-1, 1, length.out = n.grid)
y &lt;- outer(x1, x2, function(x1, x2) camel6(cbind(x1, x2)))
contour(x1, x2, y, xaxs = "i", yaxs = "i", nlevels = 25, xlab = "x1", ylab = "x2")

# Perspective plot of six-hump camel function
col.pal &lt;- colorRampPalette(c("#00007F", "blue", "#007FFF", "cyan", "#7FFF7F", "yellow",
	"#FF7F00", "red", "#7F0000"))
colors &lt;- col.pal(100)
y.facet.center &lt;- (y[-1, -1] + y[-1, -n.grid] + y[-n.grid, -1] + y[-n.grid, -n.grid])/4
y.facet.range &lt;- cut(y.facet.center, 100)
persp(x1, x2, y, phi = 30, theta = -315, expand = 0.75, ticktype = "detailed", 
	col = colors[y.facet.range])
</code></pre>

<hr>
<h2 id='cigar'>Bent Cigar Function</h2><span id='topic+cigar'></span><span id='topic+cigarGrad'></span>

<h3>Description</h3>

<p>The Bent cigar function is defined by
</p>
<p style="text-align: center;"><code class="reqn">f_{\rm cigar}(x_1, ..., x_d) = x_1^2 + 10^6 \sum_{k = 2}^{d} x_k^2</code>
</p>

<p>with <code class="reqn">x_k \in [-100, 100]</code> for <code class="reqn">k = 1, ..., d</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cigar(x)
cigarGrad(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="cigar_+3A_x">x</code></td>
<td>

<p>a numeric vector of length <code>2</code> or a numeric matrix with <code>n</code> rows and <code>2</code> columns.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The gradient of the bent cigar function is
</p>
<p style="text-align: center;"><code class="reqn">\nabla f_{\rm cigar}(x_1, ..., x_d) = \begin{pmatrix} 2x_1 \\ 20^6x_2\\ \vdots \\  20^6x_d\end{pmatrix}.</code>
</p>

<p>The bent cigar function has one global minimum <code class="reqn">f_{\rm cigar}(x^{\star}) = 0</code> at <code class="reqn">x^{\star} = (1,\dots, 1)</code>.
</p>


<h3>Value</h3>

<p><code>cigar</code> returns the function value of the bent cigar function at <code>x</code>.
</p>
<p><code>cigarGrad</code> returns the gradient of the bent cigar function at <code>x</code>.
</p>


<h3>Author(s)</h3>

<p>Carmen van Meegen
</p>


<h3>References</h3>

<p>Plevris, V. and Solorzano, G. (2022). A Collection of 30 Multidimensional Functions for Global Optimization Benchmarking. <em>Data</em>, <b>7</b>(4):46. <a href="https://doi.org/10.3390/data7040046">doi:10.3390/data7040046</a>. 
</p>


<h3>See Also</h3>

<p><code><a href="#topic+tangents">tangents</a></code> for drawing tangent lines.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># 1-dimensional Cigar function with tangents
curve(cigar(x), from = -5, to = 5, n = 200)
x &lt;- seq(-4.5, 4.5, length = 5)
y &lt;- cigar(x)
dy &lt;- cigarGrad(x)
tangents(x, y, dy, length = 2, lwd = 2, col = "red")
points(x, y, pch = 16)

# Contour plot of Cigar function 
n.grid &lt;- 50
x1 &lt;- x2 &lt;- seq(-100, 100, length.out = n.grid)
y &lt;- outer(x1, x2, function(x1, x2) cigar(cbind(x1, x2)))
contour(x1, x2, y, xaxs = "i", yaxs = "i", nlevels = 25, xlab = "x1", ylab = "x2")

# Perspective plot of Cigar function
col.pal &lt;- colorRampPalette(c("#00007F", "blue", "#007FFF", "cyan", "#7FFF7F", "yellow",
	"#FF7F00", "red", "#7F0000"))
colors &lt;- col.pal(100)
y.facet.center &lt;- (y[-1, -1] + y[-1, -n.grid] + y[-n.grid, -1] + y[-n.grid, -n.grid])/4
y.facet.range &lt;- cut(y.facet.center, 100)
persp(x1, x2, y, phi = 30, theta = -315, expand = 0.75, ticktype = "detailed", 
	col = colors[y.facet.range])
</code></pre>

<hr>
<h2 id='derivModelMatrix'>
Derivatives of Model Matrix
</h2><span id='topic+derivModelMatrix'></span><span id='topic+derivModelMatrix.default'></span><span id='topic+derivModelMatrix.gekm'></span><span id='topic+model.matrix.gekm'></span>

<h3>Description</h3>

<p>Determine the derivatives of a model matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>derivModelMatrix(object, ...)

## Default S3 method:
derivModelMatrix(object, data, ...)
## S3 method for class 'gekm'
derivModelMatrix(object, ...)
## S3 method for class 'gekm'
model.matrix(object, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="derivModelMatrix_+3A_object">object</code></td>
<td>

<p>an object of an appropriate <code><a href="base.html#topic+class">class</a></code>. For the default method, a <code><a href="stats.html#topic+formula">formula</a></code> defining the regression functions.
</p>
</td></tr>
<tr><td><code id="derivModelMatrix_+3A_data">data</code></td>
<td>

<p>a <code><a href="base.html#topic+data.frame">data.frame</a></code> with named columns.
</p>
</td></tr>
<tr><td><code id="derivModelMatrix_+3A_...">...</code></td>
<td>

<p>further arguments, yet not used.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>derivModelMatrix</code> makes use of the function <code><a href="stats.html#topic+deriv">deriv</a></code>. 
Accordingly, the calculation of derivatives is only possible for functions that are contained in the derivatives table of <code><a href="stats.html#topic+deriv">deriv</a></code>.
</p>
<p>Note, in contrast to <code><a href="stats.html#topic+model.matrix">model.matrix</a></code>, <code><a href="base.html#topic+factor">factor</a>s</code> are not supported. 
</p>


<h3>Value</h3>

<p>The derivatives of the model (or design) matrix.
</p>
<p>As in <code><a href="stats.html#topic+model.matrix">model.matrix</a></code> there is an attribute <code>"assign"</code>.
</p>


<h3>Author(s)</h3>

<p>Carmen van Meegen
</p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+deriv">deriv</a></code> for more details on supported arithmetic operators and functions.
</p>
<p><code><a href="stats.html#topic+model.matrix">model.matrix</a></code> for construction of a design (or model) matrix.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Several examples for the derivatives of a model matrix

dat &lt;- data.frame(x1 = seq(-2, 2, length.out = 5))

model.matrix(~ 1, dat)
derivModelMatrix(~ 1, dat)

model.matrix(~ ., dat)
derivModelMatrix(~ ., dat)

model.matrix(~ . - 1, dat)
derivModelMatrix(~ . - 1, dat)

model.matrix(~ sin(x1) + I(x1^2), dat)
derivModelMatrix(~ sin(x1) + I(x1^2), dat)

dat &lt;- cbind(dat, x2 = seq(1, 5, length.out = 5))

model.matrix(~ 1, dat)
derivModelMatrix(~ 1, dat)

model.matrix(~ .^2, dat)
derivModelMatrix(~ .^2, dat)

model.matrix(~ log(x2), dat)
derivModelMatrix(~ log(x2), dat)

model.matrix(~ x1:x2, dat)
derivModelMatrix(~ x1:x2, dat)

model.matrix(~ I(x1^2) * I(x2^3), dat)
derivModelMatrix(~ I(x1^2) * I(x2^3), dat)

model.matrix(~ sin(x1) + cos(x2) + atan(x1 * x2), dat)
derivModelMatrix(~ sin(x1) + cos(x2) + atan(x1 * x2), dat)
</code></pre>

<hr>
<h2 id='gekm'>
Fitting (Gradient-Enhanced) Kriging Models
</h2><span id='topic+gekm'></span><span id='topic+print.gekm'></span>

<h3>Description</h3>

<p>Estimation of a Kriging model with or without derivatives.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gekm(formula, data, deriv, covtype = c("matern5_2", "matern3_2", "gaussian"),
	theta = NULL, tol = NULL, optimizer = c("NMKB", "L-BFGS-B"), 
	lower = NULL, upper = NULL, start = NULL, ncalls = 20, control = NULL,
	model = TRUE, x = FALSE, y = FALSE, dx = FALSE, dy = FALSE, ...)
	
## S3 method for class 'gekm'
print(x, digits = 4L, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="gekm_+3A_formula">formula</code></td>
<td>

<p>a <code>formula</code> that defines the regression functions.
Note that only formula expressions for which the derivations are contained in the derivatives table of <code><a href="stats.html#topic+deriv">deriv</a></code> are supported in the gradient-enhanced Kriging model.
In addition, formulas containing <code><a href="base.html#topic+I">I</a></code> also work for the gradient-enhanced Kriging model, although this function is not included in the derivatives table of <code><a href="stats.html#topic+deriv">deriv</a></code>.
See <code><a href="#topic+derivModelMatrix">derivModelMatrix</a></code> for some examples of the trend specification.
</p>
</td></tr>
<tr><td><code id="gekm_+3A_data">data</code></td>
<td>

<p>a <code><a href="base.html#topic+data.frame">data.frame</a></code> with named columns of <code>n</code> training points of dimension <code>d</code>. Note, all variables contained in <code>data</code> are used for the construction of the correlation matrix without and with derivatives.
</p>
</td></tr>
<tr><td><code id="gekm_+3A_deriv">deriv</code></td>
<td>

<p>an optional <code><a href="base.html#topic+data.frame">data.frame</a></code> with the derivatives, whose columns should be named like those of <code>data</code>. If not specified, a Kriging model without derivatives is estimated.
</p>
</td></tr>
<tr><td><code id="gekm_+3A_covtype">covtype</code></td>
<td>

<p>a <code><a href="base.html#topic+character">character</a></code> to specify the covariance structure to be used. One of <code>matern5_2</code>, <code>matern3_2</code> or <code>gaussian</code>. Default is <code>matern5_2</code>.
</p>
</td></tr>
<tr><td><code id="gekm_+3A_theta">theta</code></td>
<td>

<p>a <code><a href="base.html#topic+numeric">numeric</a></code> vector of length <code>d</code> for the hyperparameters (optional). If not given, hyperparameters will be estimated via maximum likelihood.
</p>
</td></tr>
<tr><td><code id="gekm_+3A_tol">tol</code></td>
<td>

<p>a tolerance for the conditional number of the correlation matrix, see <code><a href="#topic+blockChol">blockChol</a></code> for details. Default is <code>NULL</code>, i.e. no regularization is applied.
</p>
</td></tr>
<tr><td><code id="gekm_+3A_optimizer">optimizer</code></td>
<td>

<p>an optional <code><a href="base.html#topic+character">character</a></code> that characterizes the optimization algorithms to be used for maximum likelihood estimation. See &lsquo;Details&rsquo;.
</p>
</td></tr>
<tr><td><code id="gekm_+3A_lower">lower</code></td>
<td>

<p>an optional lower bound for the optimization of the correlation parameters.
</p>
</td></tr>
<tr><td><code id="gekm_+3A_upper">upper</code></td>
<td>

<p>an optional upper bound for the optimization of the correlation parameters.
</p>
</td></tr>
<tr><td><code id="gekm_+3A_start">start</code></td>
<td>

<p>an optional <code><a href="base.html#topic+vector">vector</a></code> of inital values for the optimization of the correlation parameters.
</p>
</td></tr>
<tr><td><code id="gekm_+3A_ncalls">ncalls</code></td>
<td>

<p>an optional <code><a href="base.html#topic+integer">integer</a></code> that defines the number of randomly selected initial values for the optimization.
</p>
</td></tr>
<tr><td><code id="gekm_+3A_control">control</code></td>
<td>

<p>a <code><a href="base.html#topic+list">list</a></code> of control parameters for the optimization routine. See <code><a href="stats.html#topic+optim">optim</a></code> or <code><a href="dfoptim.html#topic+nmkb">nmkb</a></code>.
</p>
</td></tr>
<tr><td><code id="gekm_+3A_model">model</code></td>
<td>

<p><code><a href="base.html#topic+logical">logical</a></code>. Should the model frame be returned? Default is <code>TRUE</code>.
</p>
</td></tr>
<tr><td><code id="gekm_+3A_x">x</code></td>
<td>

<p><code><a href="base.html#topic+logical">logical</a></code>. Should the model matrix be returned? Default is <code>FALSE</code>.
</p>
</td></tr>
<tr><td><code id="gekm_+3A_y">y</code></td>
<td>

<p><code><a href="base.html#topic+logical">logical</a></code>. Should the response vector be returned? Default is <code>FALSE</code>.
</p>
</td></tr>
<tr><td><code id="gekm_+3A_dx">dx</code></td>
<td>

<p><code><a href="base.html#topic+logical">logical</a></code>. Should the derivative of the model matrix be returned? Default is <code>FALSE</code>.
</p>
</td></tr>
<tr><td><code id="gekm_+3A_dy">dy</code></td>
<td>

<p><code><a href="base.html#topic+logical">logical</a></code>. Should the derivatives of the response be returned? Default is <code>FALSE</code>.
</p>
</td></tr>
<tr><td><code id="gekm_+3A_digits">digits</code></td>
<td>

<p>number of digits to be used for the <code>print</code> method.
</p>
</td></tr>
<tr><td><code id="gekm_+3A_...">...</code></td>
<td>

<p>further arguments, currently not used.
</p>
</td></tr></table>


<h3>Details</h3>

<p>Parameter estimation is performed via maximum likelihood.
The <code>optimizer</code> argument can be used to select one of the optimization algorithms <code>"NMBK"</code> or <code>"L-BFGS-B"</code>.
In the case of the <code>"L-BFGS-B"</code>, analytical gradients of the &ldquo;concentrated&rdquo; log likelihood are used.
For one-dimensional problems, <code><a href="stats.html#topic+optimize">optimize</a></code> is called and the algorithm selected via <code>optimizer</code> is ignored.
</p>


<h3>Value</h3>

<p><code>gekm</code> returns an object of <code><a href="base.html#topic+class">class</a></code> <code>"gekm"</code> whose underlying structure is a list containing at least the following components:
</p>
<table role = "presentation">
<tr><td><code>coefficients</code></td>
<td>

<p>the estimated regression coefficients.
</p>
</td></tr>
<tr><td><code>sigma</code></td>
<td>

<p>the estimated process standard deviation.
</p>
</td></tr>
<tr><td><code>theta</code></td>
<td>

<p>the (estimated) correlation parameters.
</p>
</td></tr>
<tr><td><code>covtype</code></td>
<td>

<p>the name of the correlation function.
</p>
</td></tr>
<tr><td><code>chol</code></td>
<td>

<p>(the components of) the upper triangular matrix of the Cholesky decomposition of the correlation matrix.
</p>
</td></tr>
<tr><td><code>optimizer</code></td>
<td>

<p>the optimization algorithm.
</p>
</td></tr>
<tr><td><code>convergence</code></td>
<td>

<p>the convergence code.
</p>
</td></tr>
<tr><td><code>message</code></td>
<td>

<p>information from the optimizer.
</p>
</td></tr>
<tr><td><code>logLik</code></td>
<td>

<p>the value of the negative &ldquo;concentrated&rdquo; log likelihood at the estimated parameters.
</p>
</td></tr>
<tr><td><code>derivatives</code></td>
<td>

<p><code>TRUE</code> if a gradient-enhanced Kriging model was adapted, otherwise <code>FALSE</code>.
</p>
</td></tr>
<tr><td><code>data</code></td>
<td>

<p>the <code><a href="base.html#topic+data.frame">data.frame</a></code> that was specified via the <code>data</code> argument.
</p>
</td></tr>
<tr><td><code>deriv</code></td>
<td>

<p>if <code>derivatives = TRUE</code>, the <code><a href="base.html#topic+data.frame">data.frame</a></code> with the derivatives that was specified via the <code>deriv</code> argument.
</p>
</td></tr>
<tr><td><code>call</code></td>
<td>

<p>the matched call.
</p>
</td></tr>
<tr><td><code>terms</code></td>
<td>

<p>the <code><a href="stats.html#topic+terms">terms</a></code> object used.
</p>
</td></tr>
<tr><td><code>model</code></td>
<td>

<p>if requested (the default), the model frame used.
</p>
</td></tr>
<tr><td><code>x</code></td>
<td>

<p>if requested, the model matrix.
</p>
</td></tr>
<tr><td><code>y</code></td>
<td>

<p>if requested, the response vector.
</p>
</td></tr>
<tr><td><code>dx</code></td>
<td>

<p>if requested, the derivatives of the model matrix.
</p>
</td></tr>
<tr><td><code>dx</code></td>
<td>

<p>if requested, the vector of derivatives of the response.
</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Carmen van Meegen
</p>


<h3>References</h3>

<p>Cressie, N. A. C. (1993). <em>Statistics for Spartial Data</em>. John Wiley &amp; Sons. <a href="https://doi.org/10.1002/9781119115151">doi:10.1002/9781119115151</a>.
</p>
<p>Koehler, J. and Owen, A. (1996). Computer Experiments. In Ghosh, S. and Rao, C. (eds.), <em>Design and Analysis of Experiments</em>, volume 13 of <em>Handbook of Statistics</em>, pp. 261â€“308. Elsevier Science. <a href="https://doi.org/10.1016/S0169-7161%2896%2913011-X">doi:10.1016/S0169-7161(96)13011-X</a>.
</p>
<p>Krige, D. G. (1951). A Statistical Approach to Some Basic Mine Valuation Problems on the Witwatersrand. <em>Journal of the Southern African Institute of Mining and Metallurgy</em>, <b>52</b>(6):199&ndash;139. 
</p>
<p>Laurent, L., Le Riche, R., Soulier, B., and Boucard, PA. (2019). An Overview of Gradient-Enhanced Metamodels with Applications. <em>Archives of Computational Methods in Engineering</em>, <b>26</b>(1):61&ndash;106. <a href="https://doi.org/10.1007/s11831-017-9226-3">doi:10.1007/s11831-017-9226-3</a>.
</p>
<p>Martin, J. D. and Simpson, T. W. (2005). Use of Kriging Models to Approximate Deterministic Computer Models. <em>AIAA Journal</em>, <b>43</b>(4):853&ndash;863. <a href="https://doi.org/10.2514/1.8650">doi:10.2514/1.8650</a>.
</p>
<p>Morris, M., Mitchell, T., and Ylvisaker, D. (1993). Bayesian Design and Analysis of Computer Experiments: Use of Derivatives in Surface Prediction. <em>Technometrics</em>, <b>35</b>(3):243&ndash;255. <a href="https://doi.org/10.1080/00401706.1993.10485320">doi:10.1080/00401706.1993.10485320</a>.
</p>
<p>Oakley, J. and O'Hagan, A. (2002). Bayesian Inference for the Uncertainty Distribution of Computer Model Outputs. <em>Biometrika</em>, <b>89</b>(4):769&ndash;784. <a href="https://doi.org/10.1093/biomet/89.4.769">doi:10.1093/biomet/89.4.769</a>.
</p>
<p>O'Hagan, A., Kennedy, M. C., and Oakley, J. E. (1999). Uncertainty Analysis and Other Inference Tools for Complex Computer Codes. In <em>Bayesian Statistics 6</em>, Ed. J. M. Bernardo, J. O. Berger, A. P. Dawid and A .F. M. Smith, 503&ndash;524. Oxford University Press. 
</p>
<p>O'Hagan, A. (2006). Bayesian Analysis of Computer Code Outputs: A Tutorial. <em>Reliability Engineering &amp; System Safet</em>, <b>91</b>(10):1290&ndash;1300. <a href="https://doi.org/10.1016/j.ress.2005.11.025">doi:10.1016/j.ress.2005.11.025</a>.
</p>
<p>Park, J.-S. and Beak, J. (2001). Efficient Computation of Maximum Likelihood Estimators in a Spatial Linear Model with Power Exponential Covariogram. <em>Computers &amp; Geosciences</em>, <b>27</b>(1):1&ndash;7. <a href="https://doi.org/10.1016/S0098-3004%2800%2900016-9">doi:10.1016/S0098-3004(00)00016-9</a>.
</p>
<p>Ranjan, P., Haynes, R. and Karsten, R. (2011). A Computationally Stable Approach to Gaussian Process Interpolation of Deterministic Computer Simulation Data. <em>Technometrics</em>, <b>53</b>:366&ndash;378. <a href="https://doi.org/10.1198/TECH.2011.09141">doi:10.1198/TECH.2011.09141</a>.
</p>
<p>Rasmussen, C. E. and Williams, C. K. I. (2006). <em>Gaussian Processes for Machine Learning</em>. The MIT Press. <a href="https://gaussianprocess.org/gpml/">https://gaussianprocess.org/gpml/</a>.
</p>
<p>Ripley, B. D. (1981). <em>Spatial Statistics</em>. John Wiley &amp; Sons. <a href="https://doi.org/10.1002/0471725218">doi:10.1002/0471725218</a>. 
</p>
<p>Sacks, J., Welch, W. J., Mitchell, T. J., and Wynn, H. P. (1989). Design and Analysis of Computer Experiments. <em>Statistical Science</em>, <b>4</b>(4):409&ndash;423. <a href="https://doi.org/10.1214/ss/1177012413">doi:10.1214/ss/1177012413</a>.
</p>
<p>Santner, T. J., Williams, B. J., and Notz, W. I. (2018). <em>The Design and Analysis of Computer Experiments</em>. 2nd edition. Springer-Verlag.
</p>
<p>Stein, M. L. (1999). <em>Interpolation of Spatial Data: Some Theory for Kriging</em>. Springer Series in Statistics. Springer-Verlag. <a href="https://doi.org/10.1007/978-1-4612-1494-6">doi:10.1007/978-1-4612-1494-6</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+predict.gekm">predict.gekm</a></code> for prediction at new data points based on a model of class <code>"gekm"</code>.
</p>
<p><code><a href="#topic+simulate.gekm">simulate.gekm</a></code> for simulation of process paths conditional on a model of class <code>"gekm"</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## 1-dimensional example: Oakley and Oâ€™Hagan (2002)

# Define test function and its gradient
f &lt;- function(x) 5 + x + cos(x)
fGrad &lt;- function(x) 1 - sin(x)

# Generate coordinates and calculate slopes
x &lt;- seq(-5, 5, length = 5)
y &lt;- f(x)
dy &lt;- fGrad(x)
dat &lt;- data.frame(x, y)
deri &lt;- data.frame(x = dy)

# Fit Kriging model
km.1d &lt;- gekm(y ~ x, data = dat, covtype = "gaussian", theta = 1)
km.1d

# Fit Gradient-Enhanced Kriging model
gekm.1d &lt;- gekm(y ~ x, data = dat, deriv = deri, covtype = "gaussian", theta = 1)
gekm.1d


## 2-dimensional example: Morris et al. (1993)

# List of inputs with their distributions and their respective ranges
inputs &lt;- list("r_w" = list(dist = "norm", mean =  0.1, sd = 0.0161812, min = 0.05, max = 0.15),
	"r" = list(dist = "lnorm", meanlog = 7.71, sdlog = 1.0056, min = 100, max = 50000),
	"T_u" = list(dist = "unif", min = 63070, max = 115600),
	"H_u" = list(dist = "unif", min = 990, max = 1110),
	"T_l" = list(dist = "unif", min = 63.1, max = 116),
	"H_l" = list(dist = "unif", min = 700, max = 820),
	"L" = list(dist = "unif", min = 1120, max = 1680),
	# for a more nonlinear, nonadditive function, see Morris et al. (1993)
	"K_w" = list(dist = "unif", min = 1500, max = 15000))

# Generate design
design &lt;- data.frame("r_w" = c(0, 0.268, 1),
	"r" = rep(0, 3),
	"T_u" = rep(0, 3),
	"H_u" = rep(0, 3),
	"T_l" = rep(0, 3),
	"H_l" = rep(0, 3),
	"L" = rep(0, 3),
	"K_w" = c(0, 1, 0.268))

# Function to transform design onto input range
transform &lt;- function(x, data){
	for(p in names(data)){
		data[ , p] &lt;- (x[[p]]$max - x[[p]]$min) * data[ , p] + x[[p]]$min
	}
	data
}

# Function to transform derivatives
deriv.transform &lt;- function(x, data){
	for(p in colnames(data)){
		data[ , p] &lt;- data[ , p] * (x[[p]]$max - x[[p]]$min)  
	}
	data
}

# Generate outcome and derivatives
design.trans &lt;- transform(inputs, design)
design$y &lt;- borehole(design.trans)
deri.trans &lt;- boreholeGrad(design.trans)
deri &lt;- data.frame(deriv.transform(inputs, deri.trans))

# Design and data
cbind(design[ , c("r_w", "K_w", "y")], deri[ , c("r_w", "K_w")])

# Fit gradient-enhanced Kriging model with Gaussian correlation function
mod &lt;- gekm(y ~ 1, data = design[ , c("r_w", "K_w", "y")], 
	deriv = deri[ , c("r_w", "K_w")], covtype = "gaussian")
mod

## Compare results with Morris et al. (1993):

# Estimated hyperparameters
# in Morris et al. (1993): 0.429 and 0.467
1 / (2 * mod$theta^2)
# Estimated intercept
# in Morris et al. (1993): 69.15
coef(mod)
# Estimated standard deviation
# in Morris et al. (1993): 135.47
mod$sigma
# Posterior mean and standard deviation at (0.5, 0.5)
# in Morris et al. (1993): 69.4 and 2.7
predict(mod, data.frame("r_w" = 0.5, "K_w" = 0.5))
# Posterior mean and standard deviation at (1, 1)
# in Morris et al. (1993): 230.0 and 19.2
predict(mod, data.frame("r_w" = 1, "K_w" = 1))

## Graphical comparison: 

# Generate a 21 x 21 grid for prediction
n_grid &lt;- 21
x &lt;- seq(0, 1, length.out = n_grid)
grid &lt;- expand.grid("r_w" = x, "K_w" = x)
pred &lt;- predict(mod, grid)

# Compute ground truth on (transformed) grid
newdata &lt;- data.frame("r_w" = grid[ , "r_w"], 
	"r" = 0, "T_u" = 0, "H_u" = 0, 
	"T_l" = 0, "H_l" = 0, "L" = 0,
	"K_w" = grid[ , "K_w"])
newdata &lt;- transform(inputs, newdata)
truth &lt;- borehole(newdata)

# Contour plots of predicted and actual output
par(mfrow = c(1, 2), oma = c(3.5, 3.5, 0, 0.2), mar = c(0, 0, 1.5, 0))
contour(x, x, matrix(pred$fit, nrow = n_grid, ncol = n_grid, byrow = TRUE),
	levels = c(seq(10, 50, 10), seq(100, 250, 50)),
	main = "Predicted output")
points(design[ , c("K_w", "r_w")], pch = 16)
contour(x, x, matrix(truth, nrow = n_grid, ncol = n_grid, byrow = TRUE), 
	levels = c(seq(10, 50, 10), seq(100, 250, 50)),
	yaxt = "n", main = "Ground truth")
points(design[ , c("K_w", "r_w")], pch = 16)
mtext(side = 1, outer = TRUE, line = 2.5, "Normalized hydraulic conductivity of borehole")
mtext(side = 2, outer = TRUE, line = 2.5, "Normalized radius of borehole")
</code></pre>

<hr>
<h2 id='griewank'>Griewank Function</h2><span id='topic+griewank'></span><span id='topic+griewankGrad'></span>

<h3>Description</h3>

<p>Griewank function is defined by
</p>
<p style="text-align: center;"><code class="reqn">f_{\rm griewank}(x_1, ..., x_d) = \sum_{k = 1}^{d} \frac{x_k^2}{4000} - \prod_{k = 1}^d \cos\left(\frac{x_k}{\sqrt{k}}\right) + 1</code>
</p>

<p>with <code class="reqn">x_k \in [-600, 600]</code> for <code class="reqn">k = 1, ..., d</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>griewank(x)
griewankGrad(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="griewank_+3A_x">x</code></td>
<td>

<p>a numeric <code><a href="base.html#topic+vector">vector</a></code> or a numeric <code><a href="base.html#topic+matrix">matrix</a></code> with <code>n</code> rows and <code>d</code> columns.
If a <code><a href="base.html#topic+vector">vector</a></code> is passed, the 1-dimensional version of the Griewank function is calculated.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The gradient of Griewank function is
</p>
<p style="text-align: center;"><code class="reqn">\nabla f_{\rm griewank}(x_1, ..., x_d) = \begin{pmatrix} \frac{x_1}{2000} + \frac{1}{\sqrt{1}} \sin\left( \frac{x_1}{\sqrt{1}}\right) \prod_{k = 2}^d \cos\left(\frac{x_k}{\sqrt{k}}\right) \\ \vdots \\ \frac{x_d}{2000} + \frac{1}{\sqrt{d}} \sin\left( \frac{x_d}{\sqrt{d}}\right) \prod_{k = 1}^{d-1} \cos\left(\frac{x_k}{\sqrt{k}}\right) \end{pmatrix}.</code>
</p>

<p>Griewank function has one global minimum <code class="reqn">f_{\rm griewank}(x^{\star}) = 0</code> at <code class="reqn">x^{\star} = (0,\dots, 0)</code>.
</p>


<h3>Value</h3>

<p><code>griewank</code> returns the function value of Griewank function at <code>x</code>.
</p>
<p><code>griewankGrad</code> returns the gradient of Griewank function at <code>x</code>.
</p>


<h3>Author(s)</h3>

<p>Carmen van Meegen
</p>


<h3>References</h3>

<p>Plevris, V. and Solorzano, G. (2022). A Collection of 30 Multidimensional Functions for Global Optimization Benchmarking. <em>Data</em>, <b>7</b>(4):46. <a href="https://doi.org/10.3390/data7040046">doi:10.3390/data7040046</a>. 
</p>
<p>Surjanovic, S. and Bingham, D. (2013). Virtual Library of Simulation Experiments: Test Functions and Datasets. <a href="https://www.sfu.ca/~ssurjano/">https://www.sfu.ca/~ssurjano/</a> (retrieved January 19, 2024). 
</p>


<h3>See Also</h3>

<p><code><a href="#topic+tangents">tangents</a></code> for drawing tangent lines.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># 1-dimensional Griewank function with tangents
curve(griewank(x), from = -5, to = 5, n = 200)
x &lt;- seq(-5, 5, length = 5)
y &lt;- griewank(x)
dy &lt;- griewankGrad(x)
tangents(x, y, dy, length = 2, lwd = 2, col = "red")
points(x, y, pch = 16)

# Contour plot of Griewank function 
n.grid &lt;- 50
x1 &lt;- x2 &lt;- seq(-5, 5, length.out = n.grid)
y &lt;- outer(x1, x2, function(x1, x2) griewank(cbind(x1, x2)))
contour(x1, x2, y, xaxs = "i", yaxs = "i", nlevels = 25, xlab = "x1", ylab = "x2")

# Perspective plot of Griewank function
col.pal &lt;- colorRampPalette(c("#00007F", "blue", "#007FFF", "cyan", "#7FFF7F", "yellow",
	"#FF7F00", "red", "#7F0000"))
colors &lt;- col.pal(100)
y.facet.center &lt;- (y[-1, -1] + y[-1, -n.grid] + y[-n.grid, -1] + y[-n.grid, -n.grid])/4
y.facet.range &lt;- cut(y.facet.center, 100)
persp(x1, x2, y, phi = 30, theta = -315, expand = 0.75, ticktype = "detailed", 
	col = colors[y.facet.range])
</code></pre>

<hr>
<h2 id='himmelblau'>Himmelblau's Function</h2><span id='topic+himmelblau'></span><span id='topic+himmelblauGrad'></span>

<h3>Description</h3>

<p>Himmelblau's function is defined by
</p>
<p style="text-align: center;"><code class="reqn">f_{\rm himmelblau}(x_1, x_2) = (x_1^2 + x_2 - 11)^2 + (x_1 + x_2^2 -7)^2</code>
</p>

<p>with <code class="reqn">x_1, x_2 \in [-5, 5]</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>himmelblau(x)
himmelblauGrad(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="himmelblau_+3A_x">x</code></td>
<td>

<p>a numeric <code><a href="base.html#topic+vector">vector</a></code> of length <code>2</code> or a numeric <code><a href="base.html#topic+matrix">matrix</a></code> with <code>n</code> rows and <code>2</code> columns.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The gradient of Himmelblau's function is
</p>
<p style="text-align: center;"><code class="reqn">\nabla f_{\rm himmelblau}(x_1, x_2) = \begin{pmatrix} 4 x_1 (x_1^2 + x_2 - 11) + 2 (x_1 + x_2^2 - 7) \\ 2 (x_1^2 + x_2 - 11) + 4 x_2 (x_1 + x_2^2 - 7) \end{pmatrix}.</code>
</p>

<p>Himmelblau's function has four global minima <code class="reqn">f_{\rm himmelblau}(x^{\star}) = 0</code> at <code class="reqn">x^{\star} = (3, 2)</code>, 
<code class="reqn">x^{\star} = (-2.805118, 3.131312)</code>, <code class="reqn">x^{\star} = (-3.779310, -3.283186)</code> and <code class="reqn">x^{\star} = (3.584428, -1.848126)</code>.
</p>


<h3>Value</h3>

<p><code>himmelblau</code> returns the function value of Himmelblau's function at <code>x</code>.
</p>
<p><code>himmelblauGrad</code> returns the gradient of Himmelblau's function at <code>x</code>.
</p>


<h3>Author(s)</h3>

<p>Carmen van Meegen
</p>


<h3>References</h3>

<p>Himmelblau, D. (1972). Applied Nonlinear Programming. McGraw-Hill. ISBN 0-07-028921-2.
</p>
<p>Jamil, M. and Yang, X.-S. (2013). A Literature Survey of Benchmark Functions for Global Optimization Problems. <em>International Journal of Mathematical Modelling and Numerical Optimisation</em>, <b>4</b>(2):150-â€“194. <a href="https://doi.org/10.1504/IJMMNO.2013.055204">doi:10.1504/IJMMNO.2013.055204</a>.
</p>
<p>Surjanovic, S. and Bingham, D. (2013). Virtual Library of Simulation Experiments: Test Functions and Datasets. <a href="https://www.sfu.ca/~ssurjano/">https://www.sfu.ca/~ssurjano/</a> (retrieved January 19, 2024). 
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Contour plot of Himmelblau's function 
n.grid &lt;- 50
x1 &lt;- x2 &lt;- seq(-5, 5, length.out = n.grid)
y &lt;- outer(x1, x2, function(x1, x2) himmelblau(cbind(x1, x2)))
contour(x1, x2, y, xaxs = "i", yaxs = "i", nlevels = 25, xlab = "x1", ylab = "x2")

# Perspective plot of Himmelblau's function
col.pal &lt;- colorRampPalette(c("#00007F", "blue", "#007FFF", "cyan", "#7FFF7F", "yellow",
	"#FF7F00", "red", "#7F0000"))
colors &lt;- col.pal(100)
y.facet.center &lt;- (y[-1, -1] + y[-1, -n.grid] + y[-n.grid, -1] + y[-n.grid, -n.grid])/4
y.facet.range &lt;- cut(y.facet.center, 100)
persp(x1, x2, y, phi = 30, theta = -315, expand = 0.75, ticktype = "detailed", 
	col = colors[y.facet.range])
</code></pre>

<hr>
<h2 id='predict.gekm'>
Predict Method for (Gradient-Enhanced) Kriging Model Fits
</h2><span id='topic+predict.gekm'></span>

<h3>Description</h3>

<p>Predicted values and standard deviations based on a <code>gekm</code> model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'gekm'
predict(object, newdata, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="predict.gekm_+3A_object">object</code></td>
<td>

<p>an object of class <code>"gekm"</code>.
</p>
</td></tr>
<tr><td><code id="predict.gekm_+3A_newdata">newdata</code></td>
<td>

<p>a <code><a href="base.html#topic+data.frame">data.frame</a></code> containing the points where to perform predictions. 
</p>
</td></tr>
<tr><td><code id="predict.gekm_+3A_...">...</code></td>
<td>

<p>further arguments, currently not used.
</p>
</td></tr>
</table>


<h3>Value</h3>

<table role = "presentation">
<tr><td><code>fit</code></td>
<td>
<p>predicted mean computed at newdata.</p>
</td></tr>
<tr><td><code>sd.fit</code></td>
<td>
<p>predicted standard deviation of predicted mean.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Carmen van Meegen
</p>


<h3>References</h3>

<p>Cressie, N. A. C. (1993). <em>Statistics for Spartial Data</em>. John Wiley &amp; Sons. <a href="https://doi.org/10.1002/9781119115151">doi:10.1002/9781119115151</a>.
</p>
<p>Koehler, J. and Owen, A. (1996). Computer Experiments. In Ghosh, S. and Rao, C. (eds.), <em>Design and Analysis of Experiments</em>, volume 13 of <em>Handbook of Statistics</em>, pp. 261â€“308. Elsevier Science. <a href="https://doi.org/10.1016/S0169-7161%2896%2913011-X">doi:10.1016/S0169-7161(96)13011-X</a>.
</p>
<p>Krige, D. G. (1951). A Statistical Approach to Some Basic Mine Valuation Problems on the Witwatersrand. <em>Journal of the Southern African Institute of Mining and Metallurgy</em>, <b>52</b>(6):199&ndash;139. 
</p>
<p>Laurent, L., Le Riche, R., Soulier, B., and Boucard, PA. (2019). An Overview of Gradient-Enhanced Metamodels with Applications. <em>Archives of Computational Methods in Engineering</em>, <b>26</b>(1):61&ndash;106. <a href="https://doi.org/10.1007/s11831-017-9226-3">doi:10.1007/s11831-017-9226-3</a>.
</p>
<p>Martin, J. D. and Simpson, T. W. (2005). Use of Kriging Models to Approximate Deterministic Computer Models. <em>AIAA Journal</em>, <b>43</b>(4):853&ndash;863. <a href="https://doi.org/10.2514/1.8650">doi:10.2514/1.8650</a>.
</p>
<p>Morris, M., Mitchell, T., and Ylvisaker, D. (1993). Bayesian Design and Analysis of Computer Experiments: Use of Derivatives in Surface Prediction. <em>Technometrics</em>, <b>35</b>(3):243&ndash;255. <a href="https://doi.org/10.1080/00401706.1993.10485320">doi:10.1080/00401706.1993.10485320</a>.
</p>
<p>Oakley, J. and O'Hagan, A. (2002). Bayesian Inference for the Uncertainty Distribution of Computer Model Outputs. <em>Biometrika</em>, <b>89</b>(4):769&ndash;784. <a href="https://doi.org/10.1093/biomet/89.4.769">doi:10.1093/biomet/89.4.769</a>.
</p>
<p>O'Hagan, A., Kennedy, M. C., and Oakley, J. E. (1999). Uncertainty Analysis and Other Inference Tools for Complex Computer Codes. In <em>Bayesian Statistics 6</em>, Ed. J. M. Bernardo, J. O. Berger, A. P. Dawid and A .F. M. Smith, 503&ndash;524. Oxford University Press. 
</p>
<p>O'Hagan, A. (2006). Bayesian Analysis of Computer Code Outputs: A Tutorial. <em>Reliability Engineering &amp; System Safet</em>, <b>91</b>(10):1290&ndash;1300. <a href="https://doi.org/10.1016/j.ress.2005.11.025">doi:10.1016/j.ress.2005.11.025</a>.
</p>
<p>Park, J.-S. and Beak, J. (2001). Efficient Computation of Maximum Likelihood Estimators in a Spatial Linear Model with Power Exponential Covariogram. <em>Computers &amp; Geosciences</em>, <b>27</b>(1):1&ndash;7. <a href="https://doi.org/10.1016/S0098-3004%2800%2900016-9">doi:10.1016/S0098-3004(00)00016-9</a>.
</p>
<p>Ranjan, P., Haynes, R. and Karsten, R. (2011). A Computationally Stable Approach to Gaussian Process Interpolation of Deterministic Computer Simulation Data. <em>Technometrics</em>, <b>53</b>:366&ndash;378. <a href="https://doi.org/10.1198/TECH.2011.09141">doi:10.1198/TECH.2011.09141</a>.
</p>
<p>Rasmussen, C. E. and Williams, C. K. I. (2006). <em>Gaussian Processes for Machine Learning</em>. The MIT Press. <a href="https://gaussianprocess.org/gpml/">https://gaussianprocess.org/gpml/</a>.
</p>
<p>Ripley, B. D. (1981). <em>Spatial Statistics</em>. John Wiley &amp; Sons. <a href="https://doi.org/10.1002/0471725218">doi:10.1002/0471725218</a>. 
</p>
<p>Sacks, J., Welch, W. J., Mitchell, T. J., and Wynn, H. P. (1989). Design and Analysis of Computer Experiments. <em>Statistical Science</em>, <b>4</b>(4):409&ndash;423. <a href="https://doi.org/10.1214/ss/1177012413">doi:10.1214/ss/1177012413</a>.
</p>
<p>Santner, T. J., Williams, B. J., and Notz, W. I. (2018). <em>The Design and Analysis of Computer Experiments</em>. 2nd edition. Springer-Verlag.
</p>
<p>Stein, M. L. (1999). <em>Interpolation of Spatial Data: Some Theory for Kriging</em>. Springer Series in Statistics. Springer-Verlag. <a href="https://doi.org/10.1007/978-1-4612-1494-6">doi:10.1007/978-1-4612-1494-6</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+gekm">gekm</a></code> for fitting a (gradient-enhanced) Kriging model.
</p>
<p><code><a href="#topic+tangents">tangents</a></code> for drawing tangent lines.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## 1-dimensional example: Oakley and Oâ€™Hagan (2002)

# Define test function and its gradient 
f &lt;- function(x) 5 + x + cos(x)
fGrad &lt;- function(x) 1 - sin(x)

# Generate coordinates and calculate slopes
x &lt;- seq(-5, 5, length = 5)
y &lt;- f(x)
dy &lt;- fGrad(x)
dat &lt;- data.frame(x, y)
deri &lt;- data.frame(x = dy)

# Fit Kriging model
km.1d &lt;- gekm(y ~ x, data = dat, covtype = "gaussian", theta = 1)

# Fit gradient-enhanced Kriging model
gekm.1d &lt;- gekm(y ~ x, data = dat, deriv = deri, covtype = "gaussian", theta = 1)

# Generate new data for prediction
newdat &lt;- data.frame(x = seq(-6, 6, length = 100))

# Prediction for both models
pred.km.1d &lt;- predict(km.1d, newdat)
pred.gekm.1d  &lt;- predict(gekm.1d, newdat)

# Draw curves
curve(f(x), from = -6, to = 6, lwd = 2)
lines(newdat$x, pred.km.1d$fit, type = "l", col = rgb(0.5, 0.5, 0.5), lwd = 2, lty = 2)
lines(newdat$x, pred.gekm.1d$fit, type = "l", col = rgb(0, 0.5, 1), lwd = 2, lty = 2)

# Add pointswise confidence intervals
lower.km.1d &lt;- pred.km.1d$fit - qnorm(0.975) * pred.km.1d$sd
upper.km.1d &lt;- pred.km.1d$fit + qnorm(0.975) * pred.km.1d$sd
lower.gekm.1d &lt;- pred.gekm.1d$fit - qnorm(0.975) * pred.gekm.1d$sd
upper.gekm.1d &lt;- pred.gekm.1d$fit + qnorm(0.975) * pred.gekm.1d$sd
 
polygon(c(newdat$x, rev(newdat$x)),	c(lower.km.1d, rev(upper.km.1d)),
	col = rgb(0.5, 0.5, 0.5, alpha = 0.1), border = NA)
polygon(c(newdat$x, rev(newdat$x)),	c(lower.gekm.1d, rev(upper.gekm.1d)),
	col = rgb(0, 0.5, 1, alpha = 0.1), border = NA)

# Add tangent lines and observations
tangents(x, y, dy, lwd = 2, col = "red")
points(x, y, pch = 16)

# Add legend
legend("topleft", lty = c(1, 2, 2), col = c("black", rgb(0.5, 0.5, 0.5), rgb(0, 0.5, 1)),
	legend = c("Test function", "Kriging", "GEK"), lwd = 2, bty = "n")


## 2-dimensional example: Branin-Hoo function

# Generate a grid for training
n &lt;- 5
x1 &lt;- seq(-5, 10, length = n)
x2 &lt;- seq(0, 15, length = n)
x &lt;- expand.grid(x1 = x1, x2 = x2)
y &lt;- branin(x)
dy &lt;- braninGrad(x)
dat &lt;- data.frame(x, y)
deri &lt;- data.frame(dy)

# Fit Kriging model
km.2d &lt;- gekm(y ~ ., data = dat)
km.2d

# Fit gradient-enhanced Kriging model
gekm.2d &lt;- gekm(y ~ ., data = dat, deriv = deri)
gekm.2d

# Generate new data for prediction
n.grid &lt;- 50
x1.grid &lt;- seq(-5, 10, length = n.grid)
x2.grid &lt;- seq(0, 15, length = n.grid)
newdat &lt;- expand.grid(x1 = x1.grid, x2 = x2.grid)

# Prediction for both models and actual outcome
pred.km.2d &lt;- predict(km.2d, newdat)
pred.gekm.2d  &lt;- predict(gekm.2d, newdat)
truth &lt;- outer(x1.grid, x2.grid, function(x1, x2) branin(cbind(x1, x2)))

# Contour plots of predicted and actual output
par(mfrow = c(1, 3), oma = c(3.5, 3.5, 0, 0.2), mar = c(0, 0, 1.5, 0))
contour(x1.grid, x2.grid, truth, nlevels = 30, 
	levels = seq(0, 300, 10), main = "Branin-Hoo")
points(x, pch = 16)
contour(x1.grid, x2.grid, matrix(pred.km.2d$fit, nrow = n.grid, ncol = n.grid),
	levels = seq(0, 300, 10), main = "Kriging", yaxt = "n")
points(x, pch = 16)
contour(x1.grid, x2.grid, matrix(pred.gekm.2d$fit, nrow = n.grid, ncol = n.grid),
	levels = seq(0, 300, 10), main = "GEK", yaxt = "n")
points(x, pch = 16)
mtext(side = 1, outer = TRUE, line = 2.5, expression(x[1]))
mtext(side = 2, outer = TRUE, line = 2, expression(x[2]))

# Contour plots of predicted variance
par(mfrow = c(1, 2), oma = c(3.5, 3.5, 0, 0.2), mar = c(0, 0, 1.5, 0))
contour(x1.grid, x2.grid, matrix(pred.km.2d$sd.fit^2, nrow = n.grid, ncol = n.grid),
	main = "Kriging variance")
points(x, pch = 16)
contour(x1.grid, x2.grid, matrix(pred.gekm.2d$sd.fit^2, nrow = n.grid, ncol = n.grid),
	main = "GEK variance", yaxt = "n")
points(x, pch = 16)
mtext(side = 1, outer = TRUE, line = 2.5, expression(x[1]))
mtext(side = 2, outer = TRUE, line = 2, expression(x[2]))
</code></pre>

<hr>
<h2 id='qing'>Qing Function</h2><span id='topic+qing'></span><span id='topic+qingGrad'></span>

<h3>Description</h3>

<p>Qing function is defined by
</p>
<p style="text-align: center;"><code class="reqn">f_{\rm qing}(x_1, ..., x_d) = \sum_{k = 1}^{d} (x_i^2 - i)^2</code>
</p>

<p>with <code class="reqn">x_k \in [-500, 500]</code> for <code class="reqn">k = 1, ..., d</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>qing(x)
qingGrad(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="qing_+3A_x">x</code></td>
<td>

<p>a numeric <code><a href="base.html#topic+vector">vector</a></code> or a numeric <code><a href="base.html#topic+matrix">matrix</a></code> with <code>n</code> rows and <code>d</code> columns.
If a <code><a href="base.html#topic+vector">vector</a></code> is passed, the 1-dimensional version of the Rastrigin function is calculated.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The gradient of Qing function is
</p>
<p style="text-align: center;"><code class="reqn">\nabla f_{\rm qing}(x_1, ..., x_d) = \begin{pmatrix} 4 x_1 (x_1^2 - 1)  \\  \vdots \\ 4 x_d (x_d^2 - d) \end{pmatrix}.</code>
</p>

<p>Qing function has <code class="reqn">2^d</code> global minimum <code class="reqn">f_{\rm qing}(x^{\star}) = 0</code> at <code class="reqn">x^{\star} = (\pm \sqrt{1},\dots, \pm \sqrt{d})</code>.
</p>


<h3>Value</h3>

<p><code>qing</code> returns the function value of Qing function at <code>x</code>.
</p>
<p><code>qingGrad</code> returns the gradient of Qing function at <code>x</code>.
</p>


<h3>Author(s)</h3>

<p>Carmen van Meegen
</p>


<h3>References</h3>

<p>Qing, A. (2006). Dynamic Differential Evolution Strategy and Applications in Electromagnetic Inverse Scattering Problems. <em>IEEE Transactions on Geoscience and Remote Sensing</em>, <b>44</b>(1):116-â€“125. <a href="https://doi.org/10.1109/TGRS.2005.859347">doi:10.1109/TGRS.2005.859347</a>.
</p>
<p>Jamil, M. and Yang, X.-S. (2013). A Literature Survey of Benchmark Functions for Global Optimization Problems. <em>International Journal of Mathematical Modelling and Numerical Optimisation</em>, <b>4</b>(2):150-â€“194. <a href="https://doi.org/10.1504/IJMMNO.2013.055204">doi:10.1504/IJMMNO.2013.055204</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># 1-dimensional Qing function with tangents
curve(qing(x), from = -1.7, to = 1.7)
x &lt;- seq(-1.5, 1.5, length = 5)
y &lt;- qing(x)
dy &lt;- qingGrad(x)
tangents(x, y, dy, length = 1, lwd = 2, col = "red")
points(x, y, pch = 16)

# Contour plot of Qing function 
n.grid &lt;- 50
x1 &lt;- seq(-2, 2, length.out = n.grid)
x2 &lt;- seq(-2, 2, length.out = n.grid)
y &lt;- outer(x1, x2, function(x1, x2) qing(cbind(x1, x2)))
contour(x1, x2, y, xaxs = "i", yaxs = "i", nlevels = 25, xlab = "x1", ylab = "x2")

# Perspective plot of Qing function
col.pal &lt;- colorRampPalette(c("#00007F", "blue", "#007FFF", "cyan", "#7FFF7F", "yellow",
	"#FF7F00", "red", "#7F0000"))
colors &lt;- col.pal(100)
y.facet.center &lt;- (y[-1, -1] + y[-1, -n.grid] + y[-n.grid, -1] + y[-n.grid, -n.grid])/4
y.facet.range &lt;- cut(y.facet.center, 100)
persp(x1, x2, y, phi = 30, theta = -315, expand = 0.75, ticktype = "detailed", 
	col = colors[y.facet.range])

</code></pre>

<hr>
<h2 id='rastrigin'>Rastrigin Function</h2><span id='topic+rastrigin'></span><span id='topic+rastriginGrad'></span>

<h3>Description</h3>

<p>Rastrigin function is defined by
</p>
<p style="text-align: center;"><code class="reqn">f_{\rm rastrigin}(x_1, ..., x_d) = 10 d + \sum_{k = 1}^{d} (x_k^2 - 10\cos(2\pi x_k))</code>
</p>

<p>with <code class="reqn">x_k \in [-5.12, 5.12]</code> for <code class="reqn">k = 1, ..., d</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rastrigin(x)
rastriginGrad(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="rastrigin_+3A_x">x</code></td>
<td>

<p>a numeric <code><a href="base.html#topic+vector">vector</a></code> or a numeric <code><a href="base.html#topic+matrix">matrix</a></code> with <code>n</code> rows and <code>d</code> columns.
If a <code><a href="base.html#topic+vector">vector</a></code> is passed, the 1-dimensional version of the Rastrigin function is calculated.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The gradient of Rastrigin function is
</p>
<p style="text-align: center;"><code class="reqn">\nabla f_{\rm rastrigin}(x_1, ..., x_d) = \begin{pmatrix} 2x_1 + 20 \sin(2\pi x_1) \\ \vdots \\ 2x_d + 20 \sin(2\pi x_d))\end{pmatrix}.</code>
</p>

<p>Rastrigin function has one global minimum <code class="reqn">f_{\rm rastrigin}(x^{\star}) = 0</code> at <code class="reqn">x^{\star} = (0,\dots, 0)</code>.
</p>


<h3>Value</h3>

<p><code>rastrigin</code> returns the function value of Rastrigin function at <code>x</code>.
</p>
<p><code>rastriginGrad</code> returns the gradient of Rastrigin function at <code>x</code>.
</p>


<h3>Author(s)</h3>

<p>Carmen van Meegen
</p>


<h3>References</h3>

<p>Plevris, V. and Solorzano, G. (2022). A Collection of 30 Multidimensional Functions for Global Optimization Benchmarking. <em>Data</em>, <b>7</b>(4):46. <a href="https://doi.org/10.3390/data7040046">doi:10.3390/data7040046</a>. 
</p>
<p>Surjanovic, S. and Bingham, D. (2013). Virtual Library of Simulation Experiments: Test Functions and Datasets. <a href="https://www.sfu.ca/~ssurjano/">https://www.sfu.ca/~ssurjano/</a> (retrieved January 19, 2024). 
</p>


<h3>See Also</h3>

<p><code><a href="#topic+tangents">tangents</a></code> for drawing tangent lines.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># 1-dimensional Rastrigin function with tangents
curve(rastrigin(x), from = -5, to = 5, n = 200)
x &lt;- seq(-4.5, 4.5, length = 5)
y &lt;- rastrigin(x)
dy &lt;- rastriginGrad(x)
tangents(x, y, dy, length = 2, lwd = 2, col = "red")
points(x, y, pch = 16)

# Contour plot of Rastrigin function 
n.grid &lt;- 100
x1 &lt;- x2 &lt;- seq(-5.12, 5.12, length.out = n.grid)
y &lt;- outer(x1, x2, function(x1, x2) rastrigin(cbind(x1, x2)))
contour(x1, x2, y, xaxs = "i", yaxs = "i", nlevels = 25, xlab = "x1", ylab = "x2")

# Perspective plot of Rastrigin function
col.pal &lt;- colorRampPalette(c("#00007F", "blue", "#007FFF", "cyan", "#7FFF7F", "yellow",
	"#FF7F00", "red", "#7F0000"))
colors &lt;- col.pal(100)
y.facet.center &lt;- (y[-1, -1] + y[-1, -n.grid] + y[-n.grid, -1] + y[-n.grid, -n.grid])/4
y.facet.range &lt;- cut(y.facet.center, 100)
persp(x1, x2, y, phi = 30, theta = -315, expand = 0.75, ticktype = "detailed", 
	col = colors[y.facet.range])
</code></pre>

<hr>
<h2 id='schwefel'>Schwefel Function</h2><span id='topic+schwefel'></span><span id='topic+schwefelGrad'></span>

<h3>Description</h3>

<p>The Schwefel function is defined by
</p>
<p style="text-align: center;"><code class="reqn">f_{\rm schwefel}(x_1, ..., x_d) = 418.9829 d - \sum_{k = 1}^{d} x_k \sin\left(\sqrt{|x_k|}\right)</code>
</p>

<p>with <code class="reqn">x_k \in [-500, 500]</code> for <code class="reqn">k = 1, ..., d</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>schwefel(x)
schwefelGrad(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="schwefel_+3A_x">x</code></td>
<td>

<p>a numeric vector of length <code>d</code> or a numeric matrix with <code>n</code> rows and <code>d</code> columns.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The gradient of the Schwefel function is
</p>
<p style="text-align: center;"><code class="reqn">\nabla f_{\rm schwefel}(x_1, \dots, x_d) = \begin{pmatrix} -\sin\left( \sqrt{|x_1|} \right) - \frac{x_1^2 \cos\left(\sqrt{|x_1|}\right)}{2 |x_1|^{\frac{3}{2}}} \\ \vdots \\ -\sin\left( \sqrt{|x_d|} \right) - \frac{x_d^2 \cos\left(\sqrt{|x_d|}\right)}{2  |x_d|^{\frac{3}{2}}} \end{pmatrix}.</code>
</p>

<p>The Schwefel function has one global minimum <code class="reqn">f_{\rm schwefel}(x^{\star}) = 0</code> at <code class="reqn">x^{\star} = (420.968746, \dots, 420.968746)</code>.
</p>


<h3>Value</h3>

<p><code>schwefel</code> returns the function value of the Schwefel function at <code>x</code>.
</p>
<p><code>schwefelGrad</code> returns the gradient of the Schwefel function at <code>x</code>.
</p>


<h3>Author(s)</h3>

<p>Carmen van Meegen
</p>


<h3>References</h3>

<p>Plevris, V. and Solorzano, G. (2022). A Collection of 30 Multidimensional Functions for Global Optimization Benchmarking. <em>Data</em>, <b>7</b>(4):46. <a href="https://doi.org/10.3390/data7040046">doi:10.3390/data7040046</a>. 
</p>
<p>Surjanovic, S. and Bingham, D. (2013). Virtual Library of Simulation Experiments: Test Functions and Datasets. <a href="https://www.sfu.ca/~ssurjano/">https://www.sfu.ca/~ssurjano/</a> (retrieved January 19, 2024). 
</p>


<h3>See Also</h3>

<p><code><a href="#topic+tangents">tangents</a></code> for drawing tangent lines.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># 1-dimensional Schwefel function with tangents
curve(schwefel(x), from = -500, to = 500, n = 500)
x &lt;- seq(-450, 450, length = 5)
y &lt;- schwefel(x)
dy &lt;- schwefelGrad(x)
tangents(x, y, dy, length = 200, lwd = 2, col = "red")
points(x, y, pch = 16)

# Contour plot of Schwefel function 
n.grid &lt;- 75
x1 &lt;- x2 &lt;- seq(-500, 500, length.out = n.grid)
y &lt;- outer(x1, x2, function(x1, x2) schwefel(cbind(x1, x2)))
contour(x1, x2, y, xaxs = "i", yaxs = "i", nlevels = 25, xlab = "x1", ylab = "x2")

# Perspective plot of Schwefel function
col.pal &lt;- colorRampPalette(c("#00007F", "blue", "#007FFF", "cyan", "#7FFF7F", "yellow",
	"#FF7F00", "red", "#7F0000"))
colors &lt;- col.pal(100)
y.facet.center &lt;- (y[-1, -1] + y[-1, -n.grid] + y[-n.grid, -1] + y[-n.grid, -n.grid])/4
y.facet.range &lt;- cut(y.facet.center, 100)
persp(x1, x2, y, phi = 30, theta = -315, expand = 0.75, ticktype = "detailed", 
	col = colors[y.facet.range])
</code></pre>

<hr>
<h2 id='short'>Short Column Function</h2><span id='topic+short'></span><span id='topic+shortGrad'></span>

<h3>Description</h3>

<p>The short column function is defined by
</p>
<p style="text-align: center;"><code class="reqn">f_{\rm short}(x) = 1 - \frac{4M}{b h^2 Y} - \frac{P^2}{b^2 h^2 Y^2}</code>
</p>

<p>with <code class="reqn">x = (Y, M, P)</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>short(x, b = 5, h = 15)
shortGrad(x, b = 5, h = 15)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="short_+3A_x">x</code></td>
<td>

<p>a numeric <code><a href="base.html#topic+vector">vector</a></code> of length <code>3</code> or a numeric <code><a href="base.html#topic+matrix">matrix</a></code> with <code>n</code> rows and <code>3</code> columns.
</p>
</td></tr>
<tr><td><code id="short_+3A_b">b</code></td>
<td>

<p>width of the cross-section in <code class="reqn">\rm mm</code> of the short column. Default is <code>5</code>.
</p>
</td></tr>
<tr><td><code id="short_+3A_h">h</code></td>
<td>

<p>depth of the cross-section in <code class="reqn">\rm mm</code> of the short column. Default is <code>15</code>.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The short column function describes the limite state function of a short column with uncertain material properties and loads.
</p>

<table>
<tr>
 <td style="text-align: left;">
	Input </td><td style="text-align: right;"> Distribution </td><td style="text-align: right;"> Mean </td><td style="text-align: right;"> Standard deviation </td><td style="text-align: right;"> Description </td>
</tr>
<tr>
 <td style="text-align: left;">
	<code class="reqn">Y</code> </td><td style="text-align: right;"> <code class="reqn">\mathcal{LN}</code> </td><td style="text-align: right;"> <code class="reqn">5</code> </td><td style="text-align: right;"> <code class="reqn">0.5</code> </td><td style="text-align: right;"> yield stress in <code class="reqn">\rm MPa</code> </td>
</tr>
<tr>
 <td style="text-align: left;">
	<code class="reqn">M</code> </td><td style="text-align: right;"> <code class="reqn">\mathcal{N}</code> </td><td style="text-align: right;"> <code class="reqn">2000</code> </td><td style="text-align: right;"> <code class="reqn">400</code> </td><td style="text-align: right;"> bending moment in <code class="reqn">\rm MNm</code> </td>
</tr>
<tr>
 <td style="text-align: left;">
	<code class="reqn">P</code> </td><td style="text-align: right;"> <code class="reqn">\mathcal{N}</code> </td><td style="text-align: right;"> <code class="reqn">500</code> </td><td style="text-align: right;"> <code class="reqn">100</code> </td><td style="text-align: right;"> axial force in <code class="reqn">\rm MPa</code> </td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>

<p>The bending moment and the axial force are correlated with <code class="reqn">\rm{Cor}</code><code class="reqn">(M, P) = 0.5</code>.
Note, <code class="reqn">\mathcal{N}</code> represents the normal distribution and <code class="reqn">\mathcal{LN}</code> is the log-normal distribution.
</p>


<h3>Value</h3>

<p><code>short</code> returns the function value of short column function at <code>x</code>.
</p>
<p><code>shortGrad</code> returns the gradient of short column function at <code>x</code>.
</p>


<h3>Author(s)</h3>

<p>Carmen van Meegen
</p>


<h3>References</h3>

<p>Kuschel, N. and Rackwitz, R. (1997). Two Basic Problems in Reliability-Based Structural Optimization. <em>Mathematical Methods of Operations Research</em>, <b>46</b>(3):309&ndash;333.
</p>
<p>Surjanovic, S. and Bingham, D. (2013). Virtual Library of Simulation Experiments: Test Functions and Datasets. <a href="https://www.sfu.ca/~ssurjano/">https://www.sfu.ca/~ssurjano/</a> (retrieved January 19, 2024). 
</p>

<hr>
<h2 id='simulate.gekm'>
Simulates Conditional Process Paths
</h2><span id='topic+simulate.gekm'></span>

<h3>Description</h3>

<p>Simulates process paths conditional on a fitted <code><a href="#topic+gekm">gekm</a></code> model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'gekm'
simulate(object, nsim = 1, seed = NULL, newdata = NULL, tol = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="simulate.gekm_+3A_object">object</code></td>
<td>

<p>an object of class <code>"gekm"</code>.
</p>
</td></tr>
<tr><td><code id="simulate.gekm_+3A_nsim">nsim</code></td>
<td>

<p>number of simulated process paths. Default is <code>1</code>.
</p>
</td></tr>
<tr><td><code id="simulate.gekm_+3A_seed">seed</code></td>
<td>

<p>argument is not supported.
</p>
</td></tr>  
<tr><td><code id="simulate.gekm_+3A_newdata">newdata</code></td>
<td>

<p>a <code><a href="base.html#topic+data.frame">data.frame</a></code> containing the points where the process in <code>object</code> should be evaluated.
</p>
</td></tr>
<tr><td><code id="simulate.gekm_+3A_tol">tol</code></td>
<td>

<p>a tolerance for the conditional number of the conditional correlation matrix of <code>newdata</code>, see <code><a href="#topic+blockChol">blockChol</a></code> for details. Default is <code>NULL</code>, i.e. no regularization is applied.
</p>
</td></tr>
<tr><td><code id="simulate.gekm_+3A_...">...</code></td>
<td>

<p>further arguments, not used.
</p>
</td></tr>
</table>


<h3>Value</h3>

<table role = "presentation">
<tr><td><code>val</code></td>
<td>
<p>a <code><a href="base.html#topic+matrix">matrix</a></code> with <code>nrow(newdata)</code> rows and <code>nsim</code> columns of simulated response values at the points of <code>newdata</code>.
Each column represents one conditional simulated process path.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Carmen van Meegen
</p>


<h3>References</h3>

<p>Cressie, N. A. C. (1993). <em>Statistics for Spartial Data</em>. John Wiley &amp; Sons. <a href="https://doi.org/10.1002/9781119115151">doi:10.1002/9781119115151</a>.
</p>
<p>Ripley, B. D. (1981). <em>Spatial Statistics</em>. John Wiley &amp; Sons. <a href="https://doi.org/10.1002/0471725218">doi:10.1002/0471725218</a>. 
</p>


<h3>See Also</h3>

<p><code><a href="#topic+gekm">gekm</a></code> for fitting a (gradient-enhanced) Kriging model.
</p>
<p><code><a href="#topic+predict.gekm">predict.gekm</a></code> for prediction at new data points based on a model of class <code>"gekm"</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## 1-dimensional example

# Define test function and its gradient from Oakley and Oâ€™Hagan (2002)
f &lt;- function(x) 5 + x + cos(x)
fGrad &lt;- function(x) 1 - sin(x)

# Generate coordinates and calculate slopes
x &lt;- seq(-5, 5, length = 5)
y &lt;- f(x)
dy &lt;- fGrad(x)
dat &lt;- data.frame(x, y)
deri &lt;- data.frame(x = dy)

# Fit Kriging model
km.1d &lt;- gekm(y ~ x, data = dat, covtype = "gaussian", theta = 1)

# Fit Gradient-Enhanced Kriging model
gekm.1d &lt;- gekm(y ~ x, data = dat, deriv = deri, covtype = "gaussian", theta = 1)

# Generate new data for prediction and simulation
newdat &lt;- data.frame(x = seq(-6, 6, length = 600))

# Prediction for both models
pred.km.1d &lt;- predict(km.1d, newdat)
pred.gekm.1d  &lt;- predict(gekm.1d, newdat)

# Simulate process path conditional on fitted models
set.seed(1)
n &lt;- 50
sim.km.1d &lt;- simulate(km.1d, nsim = n, newdata = newdat, tol = 35)
sim.gekm.1d &lt;- simulate(gekm.1d, nsim = n, newdata = newdat, tol = 35)

par(mfrow = c(1, 2), oma = c(3.5, 3.5, 0, 0.2), mar = c(0, 0, 1.5, 0))
matplot(newdat$x, sim.km.1d, type = "l", lty = 1, col = 2:8, lwd = 1, 
	ylim = c(-1, 12), main = "Kriging")
lines(newdat$x, pred.km.1d$fit + qnorm(0.975) * pred.km.1d$sd, lwd = 1.5)
lines(newdat$x, pred.km.1d$fit - qnorm(0.975) * pred.km.1d$sd, lwd = 1.5)
points(x, y, pch = 16, cex = 1)

matplot(newdat$x, sim.gekm.1d, type = "l", lty = 1, col = 2:8, 
	lwd = 1, ylim = c(-1, 12), main = "GEK", yaxt = "n")
lines(newdat$x, pred.gekm.1d$fit + qnorm(0.975) * pred.gekm.1d$sd, lwd = 1.5)
lines(newdat$x, pred.gekm.1d$fit - qnorm(0.975) * pred.gekm.1d$sd, lwd = 1.5)
points(x, y, pch = 16, cex = 1)

mtext(side = 1, outer = TRUE, line = 2.5, "x")
mtext(side = 2, outer = TRUE, line = 2.5, "f(x)")
</code></pre>

<hr>
<h2 id='sphere'>Sphere Function</h2><span id='topic+sphere'></span><span id='topic+sphereGrad'></span>

<h3>Description</h3>

<p>The sphere function is defined by
</p>
<p style="text-align: center;"><code class="reqn">f_{\rm sphere}(x_1, ..., x_d) = \sum_{k = 1}^{d} x_k^2</code>
</p>

<p>with <code class="reqn">x_k \in [-5.12, 5.12]</code> for <code class="reqn">k = 1, ..., d</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sphere(x)
sphereGrad(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="sphere_+3A_x">x</code></td>
<td>

<p>a numeric <code><a href="base.html#topic+vector">vector</a></code> or a numeric <code><a href="base.html#topic+matrix">matrix</a></code> with <code>n</code> rows and <code>d</code> columns.
If a <code><a href="base.html#topic+vector">vector</a></code> is passed, the 1-dimensional version of the sphere function is calculated.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The gradient of the sphere function is
</p>
<p style="text-align: center;"><code class="reqn">\nabla f_{\rm sphere}(x_1, \dots, x_d) = \begin{pmatrix} 2 x_1 \\ \vdots \\ 2 x_d \end{pmatrix}.</code>
</p>

<p>The sphere function has one global minimum <code class="reqn">f_{\rm sphere}(x^{\star}) = 0</code> at <code class="reqn">x^{\star} = (0, \dots, 0)</code>. 
</p>


<h3>Value</h3>

<p><code>sphere</code> returns the function value of the sphere function at <code>x</code>.
</p>
<p><code>sphereGrad</code> returns the gradient of the sphere function at <code>x</code>.
</p>


<h3>Author(s)</h3>

<p>Carmen van Meegen
</p>


<h3>References</h3>

<p>Plevris, V. and Solorzano, G. (2022). A Collection of 30 Multidimensional Functions for Global Optimization Benchmarking. <em>Data</em>, <b>7</b>(4):46. <a href="https://doi.org/10.3390/data7040046">doi:10.3390/data7040046</a>. 
</p>
<p>Surjanovic, S. and Bingham, D. (2013). Virtual Library of Simulation Experiments: Test Functions and Datasets. <a href="https://www.sfu.ca/~ssurjano/">https://www.sfu.ca/~ssurjano/</a> (retrieved January 19, 2024). 
</p>


<h3>See Also</h3>

<p><code><a href="#topic+tangents">tangents</a></code> for drawing tangent lines.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># 1-dimensional sphere function with tangents
curve(sphere(x), from = -5, to = 5)
x &lt;- seq(-4.5, 4.5, length = 5)
y &lt;- sphere(x)
dy &lt;- sphereGrad(x)
tangents(x, y, dy, length = 2, lwd = 2, col = "red")
points(x, y, pch = 16)

# Contour plot of sphere function 
n.grid &lt;- 50
x1 &lt;- x2 &lt;- seq(-5.12, 5.12, length.out = n.grid)
y &lt;- outer(x1, x2, function(x1, x2) sphere(cbind(x1, x2)))
contour(x1, x2, y, xaxs = "i", yaxs = "i", nlevels = 25, xlab = "x1", ylab = "x2")

# Perspective plot of sphere function
col.pal &lt;- colorRampPalette(c("#00007F", "blue", "#007FFF", "cyan", "#7FFF7F", "yellow",
	"#FF7F00", "red", "#7F0000"))
colors &lt;- col.pal(100)
y.facet.center &lt;- (y[-1, -1] + y[-1, -n.grid] + y[-n.grid, -1] + y[-n.grid, -n.grid])/4
y.facet.range &lt;- cut(y.facet.center, 100)
persp(x1, x2, y, phi = 30, theta = -315, expand = 0.75, ticktype = "detailed", 
	col = colors[y.facet.range])
</code></pre>

<hr>
<h2 id='steel'>Steel Column Function</h2><span id='topic+steel'></span><span id='topic+steelGrad'></span>

<h3>Description</h3>

<p>The steel column function is defined by
</p>
<p style="text-align: center;"><code class="reqn">f_{\rm steel}(x) = F_S - P \left(\frac{1}{2BD} + \frac{F_0 E_b}{BDH(E_b - P)} \right),</code>
</p>

<p>with <code class="reqn">P = P_1 + P_2 + P_3</code>, <code class="reqn">E_b = \frac{\pi^2 EBDH^2}{2L^2}</code> and <code class="reqn">x = (F_S, P_1, P_2, P_3, B, D, H, F_0, E)</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>steel(x, L = 7500)
steelGrad(x, L = 7500)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="steel_+3A_x">x</code></td>
<td>

<p>a numeric <code><a href="base.html#topic+vector">vector</a></code> of length <code>9</code> or a numeric <code><a href="base.html#topic+matrix">matrix</a></code> with <code>n</code> rows and <code>9</code> columns.
</p>
</td></tr>
<tr><td><code id="steel_+3A_l">L</code></td>
<td>

<p>length in <code class="reqn">\rm mm</code> of the steel column. Default is <code>7500</code>.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The steel column function describes the limite state function of a steel column with uncertain parameters.
</p>

<table>
<tr>
 <td style="text-align: left;">
	Input </td><td style="text-align: right;"> Distribution </td><td style="text-align: right;"> Mean </td><td style="text-align: right;"> Standard Deviation </td><td style="text-align: right;"> Description </td>
</tr>
<tr>
 <td style="text-align: left;">
	<code class="reqn">F_S</code> </td><td style="text-align: right;"> <code class="reqn">\mathcal{LN}</code> </td><td style="text-align: right;"> <code class="reqn">400</code> </td><td style="text-align: right;"> <code class="reqn">35</code> </td><td style="text-align: right;"> yield stress in <code class="reqn">\rm MPa</code> </td>
</tr>
<tr>
 <td style="text-align: left;">
	<code class="reqn">P_1</code> </td><td style="text-align: right;"> <code class="reqn">\mathcal{N}</code> </td><td style="text-align: right;"> <code class="reqn">500000</code> </td><td style="text-align: right;"> <code class="reqn">50000</code> </td><td style="text-align: right;"> dead weight load in <code class="reqn">\rm N</code> </td>
</tr>
<tr>
 <td style="text-align: left;">
	<code class="reqn">P_2</code> </td><td style="text-align: right;"> <code class="reqn">\mathcal{G}</code> </td><td style="text-align: right;"> <code class="reqn">600000</code> </td><td style="text-align: right;"> <code class="reqn">90000</code> </td><td style="text-align: right;"> variable load in <code class="reqn">\rm N</code> </td>
</tr>
<tr>
 <td style="text-align: left;">
	<code class="reqn">P_3</code> </td><td style="text-align: right;"> <code class="reqn">\mathcal{G}</code> </td><td style="text-align: right;"> <code class="reqn">600000</code> </td><td style="text-align: right;"> <code class="reqn">90000</code> </td><td style="text-align: right;"> variable load in <code class="reqn">\rm N</code> </td>
</tr>
<tr>
 <td style="text-align: left;">
	<code class="reqn">B</code> </td><td style="text-align: right;"> <code class="reqn">\mathcal{LN}</code> </td><td style="text-align: right;"> <code class="reqn">b</code> </td><td style="text-align: right;"> <code class="reqn">3</code> </td><td style="text-align: right;"> flange breadth in <code class="reqn">\rm mm</code> </td>
</tr>
<tr>
 <td style="text-align: left;">
	<code class="reqn">D</code> </td><td style="text-align: right;"> <code class="reqn">\mathcal{LN}</code> </td><td style="text-align: right;"> <code class="reqn">t</code> </td><td style="text-align: right;"> <code class="reqn">2</code> </td><td style="text-align: right;"> flange thickness in <code class="reqn">\rm mm</code> </td>
</tr>
<tr>
 <td style="text-align: left;">
	<code class="reqn">H</code> </td><td style="text-align: right;"> <code class="reqn">\mathcal{LN}</code> </td><td style="text-align: right;"> <code class="reqn">h</code> </td><td style="text-align: right;"> <code class="reqn">5</code> </td><td style="text-align: right;"> profile height in <code class="reqn">\rm mm</code> </td>
</tr>
<tr>
 <td style="text-align: left;">
	<code class="reqn">F_0</code> </td><td style="text-align: right;"> <code class="reqn">\mathcal{N}</code> </td><td style="text-align: right;"> <code class="reqn">30</code> </td><td style="text-align: right;"> <code class="reqn">10</code> </td><td style="text-align: right;"> initial deflection in <code class="reqn">\rm mm</code> </td>
</tr>
<tr>
 <td style="text-align: left;">
	<code class="reqn">E</code> </td><td style="text-align: right;"> <code class="reqn">\mathcal{W}</code> </td><td style="text-align: right;"> <code class="reqn">210000</code> </td><td style="text-align: right;"> <code class="reqn">4200</code> </td><td style="text-align: right;"> Young's modulus in <code class="reqn">\rm MPa</code> </td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>

<p>Here, <code class="reqn">\mathcal{N}</code> is the normal distribution and <code class="reqn">\mathcal{LN}</code> is the log-normal distribution.
Further, <code class="reqn">\mathcal{G}</code> represents the Gumbel distribution and <code class="reqn">\mathcal{W}</code> denotes the Weibull distribution.
</p>


<h3>Value</h3>

<p><code>steel</code> returns the function value of steel column function at <code>x</code>.
</p>
<p><code>steelGrad</code> returns the gradient of steel column function at <code>x</code>.
</p>


<h3>Author(s)</h3>

<p>Carmen van Meegen
</p>


<h3>References</h3>

<p>Kuschel, N. and Rackwitz, R. (1997). Two Basic Problems in Reliability-Based Structural Optimization. <em>Mathematical Methods of Operations Research</em>, <b>46</b>(3):309&ndash;333.
</p>
<p>Surjanovic, S. and Bingham, D. (2013). Virtual Library of Simulation Experiments: Test Functions and Datasets. <a href="https://www.sfu.ca/~ssurjano/">https://www.sfu.ca/~ssurjano/</a> (retrieved January 19, 2024). 
</p>

<hr>
<h2 id='styblinski'>Styblinski-Tang Function</h2><span id='topic+styblinski'></span><span id='topic+styblinskiGrad'></span>

<h3>Description</h3>

<p>Styblinski-Tang function is defined by
</p>
<p style="text-align: center;"><code class="reqn">f_{\rm styblinski}(x_1, ..., x_d) = \frac{1}{2} \sum_{k = 1}^{d} (x_k^4 - 16x_k^2 + 5x_k)</code>
</p>

<p>with <code class="reqn">x_k \in [-5, 5]</code> for <code class="reqn">k = 1, ..., d</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>styblinski(x)
styblinskiGrad(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="styblinski_+3A_x">x</code></td>
<td>

<p>a numeric <code><a href="base.html#topic+vector">vector</a></code> or a numeric <code><a href="base.html#topic+matrix">matrix</a></code> with <code>n</code> rows and <code>d</code> columns.
If a <code><a href="base.html#topic+vector">vector</a></code> is passed, the 1-dimensional version of the Rastrigin function is calculated.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The gradient of Styblinski-Tang function is
</p>
<p style="text-align: center;"><code class="reqn">\nabla f_{\rm styblinski}(x_1, ..., x_d) = \begin{pmatrix} 2x_1^3 - 16 x_1 + 2.5\\ \vdots \\ 2 x_d^3 - 16 x_d + 2.5 \end{pmatrix}.</code>
</p>

<p>Styblinski-Tang function has one global minimum <code class="reqn">f_{\rm styblinski}(x^{\star}) = -39.16599d</code> at
<code class="reqn">x^{\star} = (-2.903534,\dots, -2.903534)</code>.
</p>


<h3>Value</h3>

<p><code>styblinski</code> returns the function value of Styblinski-Tang function at <code>x</code>.
</p>
<p><code>styblinskiGrad</code> returns the gradient of Styblinski-Tang function at <code>x</code>.
</p>


<h3>Author(s)</h3>

<p>Carmen van Meegen
</p>


<h3>References</h3>

<p>Jamil, M. and Yang, X.-S. (2013). A Literature Survey of Benchmark Functions for Global Optimization Problems. <em>International Journal of Mathematical Modelling and Numerical Optimisation</em>, <b>4</b>(2):150-â€“194. <a href="https://doi.org/10.1504/IJMMNO.2013.055204">doi:10.1504/IJMMNO.2013.055204</a>.
</p>
<p>Surjanovic, S. and Bingham, D. (2013). Virtual Library of Simulation Experiments: Test Functions and Datasets. <a href="https://www.sfu.ca/~ssurjano/">https://www.sfu.ca/~ssurjano/</a> (retrieved January 19, 2024). 
</p>


<h3>See Also</h3>

<p><code><a href="#topic+tangents">tangents</a></code> for drawing tangent lines.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># 1-dimensional Styblinski-Tang function with tangents
curve(styblinski(x), from = -5, to = 5)
x &lt;- seq(-4.5, 4.5, length = 5)
y &lt;- styblinski(x)
dy &lt;- styblinskiGrad(x)
tangents(x, y, dy, length = 2, lwd = 2, col = "red")
points(x, y, pch = 16)

# Contour plot of Styblinski-Tang function 
n.grid &lt;- 50
x1 &lt;- seq(-5, 5, length.out = n.grid)
x2 &lt;- seq(-5, 5, length.out = n.grid)
y &lt;- outer(x1, x2, function(x1, x2) styblinski(cbind(x1, x2)))
contour(x1, x2, y, xaxs = "i", yaxs = "i", nlevels = 25, xlab = "x1", ylab = "x2")

# Perspective plot of Styblinski-Tang function
col.pal &lt;- colorRampPalette(c("#00007F", "blue", "#007FFF", "cyan", "#7FFF7F", "yellow",
	"#FF7F00", "red", "#7F0000"))
colors &lt;- col.pal(100)
y.facet.center &lt;- (y[-1, -1] + y[-1, -n.grid] + y[-n.grid, -1] + y[-n.grid, -n.grid])/4
y.facet.range &lt;- cut(y.facet.center, 100)
persp(x1, x2, y, phi = 30, theta = -315, expand = 0.75, ticktype = "detailed", 
	col = colors[y.facet.range])
</code></pre>

<hr>
<h2 id='sulfur'>Sulfur Model Function</h2><span id='topic+sulfur'></span><span id='topic+sulfurGrad'></span>

<h3>Description</h3>

<p>The sulfur function is defined by
</p>
<p style="text-align: center;"><code class="reqn">f_{\rm sulfur}(x) = -\frac{1}{2} S_0^2 (1 - A_c) T^2 (1 - R_s)^2 \bar{\beta} \Psi_e f_{\Psi_e} \frac{3 Q Y L}{A}</code>
</p>

<p>with <code class="reqn">x = (Q, Y, L, \Psi_e, \bar{\beta}, f_{\Psi_e}, T, 1-A_c, 1-R_s)</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sulfur(x, S_0 = 1366, A = 5.1e+14)
sulfurGrad(x, S_0 = 1366, A = 5.1e+14)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="sulfur_+3A_x">x</code></td>
<td>

<p>a numeric <code><a href="base.html#topic+vector">vector</a></code> of length <code>9</code> or a numeric <code><a href="base.html#topic+matrix">matrix</a></code> with <code>n</code> rows and <code>9</code> columns.
</p>
</td></tr>
<tr><td><code id="sulfur_+3A_s_0">S_0</code></td>
<td>

<p>solar constant in <code class="reqn">\rm W/m^2</code>. Default is <code>1366</code>.
</p>
</td></tr>
<tr><td><code id="sulfur_+3A_a">A</code></td>
<td>

<p>surface area of the earth in <code class="reqn">\rm m^2</code>. Default is <code>5.1e+14</code>.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The sulfur model function calculates the direct radiative forcing by sulfate aerosols <code class="reqn">\rm [W/m^2]</code>.
</p>

<table>
<tr>
 <td style="text-align: left;">
	Input </td><td style="text-align: right;"> Central value </td><td style="text-align: right;"> Uncertainty factor </td><td style="text-align: left;"> Description </td>
</tr>
<tr>
 <td style="text-align: left;">
	<code class="reqn">Q</code> </td><td style="text-align: right;"> <code class="reqn">71</code> </td><td style="text-align: right;"> <code class="reqn">1.15</code> </td><td style="text-align: left;"> source strength of anthropogenic sulfur in <code class="reqn">\rm Tg/yr</code> </td>
</tr>
<tr>
 <td style="text-align: left;">
	<code class="reqn">Y</code> </td><td style="text-align: right;"> <code class="reqn">0.5</code> </td><td style="text-align: right;"> <code class="reqn">1.5</code>  </td><td style="text-align: left;"> fraction of <code class="reqn">\rm SO_2</code> oxidized to <code class="reqn">\rm SO_4^=</code> </td>
</tr>
<tr>
 <td style="text-align: left;">
	<code class="reqn">L</code> </td><td style="text-align: right;"> <code class="reqn">5.5</code> </td><td style="text-align: right;"> <code class="reqn">1.5</code>  </td><td style="text-align: left;"> average lifetime of atmospheric <code class="reqn">\rm SO_4^=</code> in <code class="reqn">\rm days</code> </td>
</tr>
<tr>
 <td style="text-align: left;">
	<code class="reqn">\Psi_e</code> </td><td style="text-align: right;"> <code class="reqn">5</code> </td><td style="text-align: right;"> <code class="reqn">1.4</code>  </td><td style="text-align: left;"> aerosol mass scattering efficiency in <code class="reqn">\rm m^2/g</code> </td>
</tr>
<tr>
 <td style="text-align: left;">
	<code class="reqn">\bar{\beta}</code> </td><td style="text-align: right;"> <code class="reqn">0.3</code> </td><td style="text-align: right;"> <code class="reqn">1.3</code>  </td><td style="text-align: left;"> fraction of light scattering into upward hemisphere </td>
</tr>
<tr>
 <td style="text-align: left;">
	<code class="reqn">f_{\Psi_e}</code> </td><td style="text-align: right;"> <code class="reqn">1.7</code> </td><td style="text-align: right;"> <code class="reqn">1.2</code>  </td><td style="text-align: left;"> fractional increase in aerosol scattering efficiency due to hygroscopic growth </td>
</tr>
<tr>
 <td style="text-align: left;">
	<code class="reqn">T</code> </td><td style="text-align: right;"> <code class="reqn">0.76</code> </td><td style="text-align: right;"> <code class="reqn">1.2</code>  </td><td style="text-align: left;"> atmospheric transmittance above aerosol layer </td>
</tr>
<tr>
 <td style="text-align: left;">
	<code class="reqn">1-A_c</code> </td><td style="text-align: right;"> <code class="reqn">0.39</code> </td><td style="text-align: right;"> <code class="reqn">1.1</code>  </td><td style="text-align: left;"> fraction of earth not covered by cloud </td>
</tr>
<tr>
 <td style="text-align: left;">
	<code class="reqn">1-R_s</code> </td><td style="text-align: right;"> <code class="reqn">0.85</code> </td><td style="text-align: right;"> <code class="reqn">1.1</code>  </td><td style="text-align: left;"> surface coalbedo </td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>

<p>The inputs are all log-normally distributed.
</p>


<h3>Value</h3>

<p><code>sulfur</code> returns the function value of sulfur function at <code>x</code>.
</p>
<p><code>sulfurGrad</code> returns the gradient of sulfur function at <code>x</code>.
</p>


<h3>Author(s)</h3>

<p>Carmen van Meegen
</p>


<h3>References</h3>

<p>Charlson, R. J., Schwartz, S. E., Hales, J. M., Cess, R. D., Coakley, Jr., J. A., Hansen, J. E., and Hoffman, D. J. (1992). Climate Forcing by Anthropogenic Aerosols. <em>Science</em>, <b>255</b>:423&ndash;430. <a href="https://doi.org/10.1126/science.255.5043.423">doi:10.1126/science.255.5043.423</a>.
</p>
<p>Penner, J. E., Charlson, R. J., Hales, J. M., Laulainen, N. S., Leifer, R., Novakov, T., Ogren, J., Radke, L. F., Schwartz, S. E., and Travis, L. (1994). Quantifying and Minimizing Uncertainty of Climate Forcing by Anthropogenic Aerosols. <em>Bulletin of the American Meteorological Society</em>, <b>75</b>(3):375&ndash;400. <a href="https://doi.org/10.1175/1520-0477%281994%29075%3C0375%3AQAMUOC%3E2.0.CO%3B2">doi:10.1175/1520-0477(1994)075&lt;0375:QAMUOC&gt;2.0.CO;2</a>.
</p>
<p>Tatang, M. A., Pan, W., Prinn, R. G., and McRae, G. J. (1997). An Efficient Method for Parametric Uncertainty Analysis of Numerical Geophysical Model. <em>Journal of Geophysical Research Atmospheres</em>, <b>102</b>(18):21925&ndash;21932. <a href="https://doi.org/10.1029/97JD01654">doi:10.1029/97JD01654</a>.
</p>

<hr>
<h2 id='tangents'>Add Tangent Lines to a Plot</h2><span id='topic+tangents'></span>

<h3>Description</h3>

<p>Draw tangent lines to an existing plot.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tangents(x, y, slope, length = 1, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="tangents_+3A_x">x</code>, <code id="tangents_+3A_y">y</code></td>
<td>

<p>coordinate vectors of points <code>x</code> and function values <code>y</code>.
</p>
</td></tr>
<tr><td><code id="tangents_+3A_slope">slope</code></td>
<td>

<p>vector of slopes at the points <code>x</code>.
</p>
</td></tr>
<tr><td><code id="tangents_+3A_length">length</code></td>
<td>

<p>desired length of tangent lines, see &lsquo;Details&rsquo;.
</p>
</td></tr>
<tr><td><code id="tangents_+3A_...">...</code></td>
<td>

<p>further <a href="graphics.html#topic+par">graphical parameters</a> to be passed to <code><a href="graphics.html#topic+segments">segments</a></code>.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The length of the tangent lines is scaled according to the current aspect ratio of the existing plot.
</p>


<h3>Author(s)</h3>

<p>Carmen van Meegen
</p>


<h3>See Also</h3>

<p><code><a href="graphics.html#topic+segments">segments</a></code> for drawing line segments between pairs of points.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Define test function and its gradient from Oakley and O'Hagan (2002)
f &lt;- function(x) 5 + x + cos(x)
fGrad &lt;- function(x) 1 - sin(x)

# Generate coordinates and calculate slopes
x &lt;- seq(-5, 5, length = 5)
y &lt;- f(x)
dy &lt;- fGrad(x)

# Draw curve and tangent lines
curve(f(x), from = -6, to = 6)
tangents(x, y, dy, length = 2, lwd = 2, col = 2:6)
points(x, y, pch = 16)
</code></pre>

<hr>
<h2 id='testfunctions'>Testfunctions in <span class="pkg">gek</span></h2><span id='topic+testfunctions'></span>

<h3>Description</h3>

<p>Overview of testfunctions available in <span class="pkg">gek</span>.
</p>


<h3>2-dimensional testfunctions for optimization</h3>


<ul>
<li><p><code><a href="#topic+branin">branin</a></code>: Branin-Hoo function
</p>
</li>
<li><p><code><a href="#topic+camel3">camel3</a></code>: Three-hump camel function
</p>
</li>
<li><p><code><a href="#topic+camel6">camel6</a></code>: Six-hump camel function
</p>
</li>
<li><p><code><a href="#topic+himmelblau">himmelblau</a></code>: Himmelblaus's function
</p>
</li></ul>



<h3>Multi-dimensional testfunctions for optimization</h3>


<ul>
<li><p><code><a href="#topic+banana">banana</a></code>: Rosenbrock's Banana function
</p>
</li>
<li><p><code><a href="#topic+cigar">cigar</a></code>: Bent Cigar function
</p>
</li>
<li><p><code><a href="#topic+griewank">griewank</a></code>: Griewank function
</p>
</li>
<li><p><code><a href="#topic+qing">qing</a></code>: Qing function
</p>
</li>
<li><p><code><a href="#topic+rastrigin">rastrigin</a></code>: Rastrigin function
</p>
</li>
<li><p><code><a href="#topic+schwefel">schwefel</a></code>: Schwefel function
</p>
</li>
<li><p><code><a href="#topic+sphere">sphere</a></code>: Sphere function
</p>
</li>
<li><p><code><a href="#topic+styblinski">styblinski</a></code>: Styblinski-Tang function	
</p>
</li></ul>
	


<h3>Testfunctions for uncertainty quantification</h3>


<ul>
<li><p><code><a href="#topic+borehole">borehole</a></code>: Borehole function
</p>
</li>
<li><p><code><a href="#topic+steel">steel</a></code>: Steel column function
</p>
</li>
<li><p><code><a href="#topic+short">short</a></code>: Short column function
</p>
</li>
<li><p><code><a href="#topic+sulfur">sulfur</a></code>: Sulfur model function
</p>
</li></ul>



<h3>Author(s)</h3>

<p>Carmen van Meegen
</p>


<h3>References</h3>

<p>Branin, Jr., F. H. (1972). Widely Convergent Method of Finding Multiple Solutions of Simultaneous Nonlinear Equations. <em>IBM Journal of Research and Development</em>, <b>16</b>(5):504&ndash;522.
</p>
<p>Jamil, M. and Yang, X.-S. (2013). A Literature Survey of Benchmark Functions for Global Optimization Problems. <em>International Journal of Mathematical Modelling and Numerical Optimisation</em>, <b>4</b>(2):150-â€“194. <a href="https://doi.org/10.1504/IJMMNO.2013.055204">doi:10.1504/IJMMNO.2013.055204</a>.
</p>
<p>Harper, W. V. and Gupta, S. K. (1983). Sensitivity/Uncertainty Analysis of a Borehole Scenario Comparing Latin Hypercube Sampling and Deterministic Sensitivity Approaches.
BMI/ONWI-516, Office of Nuclear Waste Isolation, Battelle Memorial Institute, Columbus, OH.
</p>
<p>Himmelblau, D. (1972). Applied Nonlinear Programming. McGraw-Hill. ISBN 0-07-028921-2.
</p>
<p>Kuschel, N. and Rackwitz, R. (1997). Two Basic Problems in Reliability-Based Structural Optimization. <em>Mathematical Methods of Operations Research</em>, <b>46</b>(3):309&ndash;333.
</p>
<p>Morris, M., Mitchell, T., and Ylvisaker, D. (1993). Bayesian Design and Analysis of Computer Experiments: Use of Derivatives in Surface Prediction. <em>Technometrics</em>, <b>35</b>(3):243&ndash;255. <a href="https://doi.org/10.1080/00401706.1993.10485320">doi:10.1080/00401706.1993.10485320</a>.
</p>
<p>Plevris, V. and Solorzano, G. (2022). A Collection of 30 Multidimensional Functions for Global Optimization Benchmarking. <em>Data</em>, <b>7</b>(4):46. <a href="https://doi.org/10.3390/data7040046">doi:10.3390/data7040046</a>. 
</p>
<p>Rosenbrock, H. H. (1960). An Automatic Method for Finding the Greatest or least Value of a Function. <em>The Computer Journal</em>, <b>3</b>(3):175&ndash;184. <a href="https://doi.org/10.1093/comjnl/3.3.175">doi:10.1093/comjnl/3.3.175</a>.
</p>
<p>Surjanovic, S. and Bingham, D. (2013). Virtual Library of Simulation Experiments: Test Functions and Datasets. <a href="https://www.sfu.ca/~ssurjano/">https://www.sfu.ca/~ssurjano/</a> (retrieved January 19, 2024). 
</p>


<h3>See Also</h3>

<p><code><a href="#topic+banana">banana</a></code>, <code><a href="#topic+bananaGrad">bananaGrad</a></code>,
<code><a href="#topic+borehole">borehole</a></code>, <code><a href="#topic+boreholeGrad">boreholeGrad</a></code>,
<code><a href="#topic+branin">branin</a></code>, <code><a href="#topic+braninGrad">braninGrad</a></code>,
<code><a href="#topic+camel3">camel3</a></code>, <code><a href="#topic+camel3Grad">camel3Grad</a></code>,
<code><a href="#topic+camel6">camel6</a></code>, <code><a href="#topic+camel6Grad">camel6Grad</a></code>,
<code><a href="#topic+cigar">cigar</a></code>, <code><a href="#topic+cigarGrad">cigarGrad</a></code>,
<code><a href="#topic+griewank">griewank</a></code>, <code><a href="#topic+griewankGrad">griewankGrad</a></code>,
<code><a href="#topic+himmelblau">himmelblau</a></code>, <code><a href="#topic+himmelblauGrad">himmelblauGrad</a></code>,
<code><a href="#topic+qing">qing</a></code>, <code><a href="#topic+qingGrad">qingGrad</a></code>,
<code><a href="#topic+rastrigin">rastrigin</a></code>, <code><a href="#topic+rastriginGrad">rastriginGrad</a></code>,
<code><a href="#topic+schwefel">schwefel</a></code>, <code><a href="#topic+schwefelGrad">schwefelGrad</a></code>,
<code><a href="#topic+short">short</a></code>, <code><a href="#topic+shortGrad">shortGrad</a></code>,
<code><a href="#topic+sphere">sphere</a></code>, <code><a href="#topic+sphereGrad">sphereGrad</a></code>,
<code><a href="#topic+steel">steel</a></code>, <code><a href="#topic+steelGrad">steelGrad</a></code>,
<code><a href="#topic+styblinski">styblinski</a></code>, <code><a href="#topic+styblinskiGrad">styblinskiGrad</a></code>,
<code><a href="#topic+sulfur">sulfur</a></code>, <code><a href="#topic+sulfurGrad">sulfurGrad</a></code>
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
