<!DOCTYPE html><html lang="en-GB"><head><title>Help for package FossilSim</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {FossilSim}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#FossilSim'><p>FossilSim: A package for simulating and plotting fossil and taxonomy data</p></a></li>
<li><a href='#beast.fbd.format'><p>Transforms a tree and fossils into a sampled tree in beast-usable format and writes it in Newick format.</p>
Designed to work with FBD.</a></li>
<li><a href='#count.fossils'><p>Count the total number of fossils</p></a></li>
<li><a href='#count.fossils.binned'><p>Count the total number of fossils per interval</p></a></li>
<li><a href='#fbdrange'><p>Creates an fbdrange object from provided tree and data</p></a></li>
<li><a href='#fossils'><p>Fossils object</p></a></li>
<li><a href='#fossils.to.BEAST.constraints'><p>Create a set of BEAST2 constraints to construct a DPPDIV style fixed extant</p>
topology FBD analysis</a></li>
<li><a href='#fossils.to.BEAST.start.tree'><p>Create a suitable starting tree for a DPPDIV style FBD analysis in BEAST2</p></a></li>
<li><a href='#fossils.to.paleotree.record'><p>Transforms a fossils dataframe and either taxonomy or tree into a fossilRecordSimulation object from package paleotree.</p></a></li>
<li><a href='#fossils.to.pyrate'><p>Generate output in the format used by the program PyRate</p></a></li>
<li><a href='#get_fbdrange_from_file'><p>Import fbdrange object from file</p></a></li>
<li><a href='#get.tip.descs'><p>Obtain the tips that define each node in a tree</p></a></li>
<li><a href='#paleotree.record.to.fossils'><p>Transforms a fossilRecordSimulation object from package paleotree to a tree and taxonomy and fossils objects.</p></a></li>
<li><a href='#place.fossils'><p>Place fossil samples from one tree in another tree, or find the ancestral</p>
node for each fossil sample in one tree.</a></li>
<li><a href='#plot.fbdrange'><p>Plot oriented tree with stratigraphic ranges</p></a></li>
<li><a href='#plot.fossils'><p>Plot simulated fossils</p></a></li>
<li><a href='#plot.taxonomy'><p>Plot simulated taxonomy</p></a></li>
<li><a href='#prune.fossil.tips'><p>Remove fossil lineages from a tree</p></a></li>
<li><a href='#prune.fossils'><p>Removes all intermediate fossils from a combined tree and labels the first and last fossils of each lineage.</p>
Can be used with sampled or complete trees. If only one fossil is present for a particular species it is labelled as first.</a></li>
<li><a href='#rangeplot.asymmetric'><p>Make an asymmetric stratigraphic range plot from a tree object of class phylo</p></a></li>
<li><a href='#reconcile.fossils.taxonomy'><p>Reconcile existing fossil and taxonomy objects</p></a></li>
<li><a href='#reconstructed.tree.fossils.objects'><p>Returns tree and fossil objects that you can use to plot the reconstructed tree.</p></a></li>
<li><a href='#remove.stem.fossils'><p>Remove fossil samples that occur in the stem</p></a></li>
<li><a href='#remove.stem.lineages'><p>Remove stem lineages from a tree.</p></a></li>
<li><a href='#sampled.tree.from.combined'><p>Removes all unsampled lineages from a combined tree.</p>
Extinct tips are only sampled if they are fossils. With default settings all extant tips are sampled.</a></li>
<li><a href='#SAtree'><p>Tree with sampled ancestors represented as zero-length edges</p></a></li>
<li><a href='#SAtree.from.fossils'><p>Transforms a tree and fossils dataframe to a combined SA tree.</p>
Sampled ancestors are represented as tips on zero-length edges to maintain compatibility with the ape format.
Tip labels are set to &quot;species id&quot;_&quot;index&quot;, where the most recent tip of a given species receives index 1 and indices increase towards the past.</a></li>
<li><a href='#sim.anagenetic.species'><p>Simulate anagenetic species on a taxonomy object</p></a></li>
<li><a href='#sim.cryptic.species'><p>Simulate cryptic species on a taxonomy object</p></a></li>
<li><a href='#sim.extant.samples'><p>Include extant samples in the fossil object, with optional rho sampling.</p></a></li>
<li><a href='#sim.fbd.age'><p>sim.fbd.age: Simulating fossilized birth-death trees of a fixed age.</p></a></li>
<li><a href='#sim.fbd.rateshift.taxa'><p>sim.fbd.rateshift.taxa: Simulating fossilized birth death trees incorporating rate shifts.</p></a></li>
<li><a href='#sim.fbd.taxa'><p>sim.fbd.taxa: Simulating fossilized birth-death trees on a fixed number of extant taxa.</p></a></li>
<li><a href='#sim.fossils.environment'><p>Simulate fossils under an environment-dependent model of preservation (Holland, 1995)</p></a></li>
<li><a href='#sim.fossils.intervals'><p>Simulate fossils under a non-uniform model of preservation for a given set of consecutive time intervals</p></a></li>
<li><a href='#sim.fossils.poisson'><p>Simulate fossils under a Poisson sampling model</p></a></li>
<li><a href='#sim.gradient'><p>Simulate an environmental gradient</p></a></li>
<li><a href='#sim.interval.ages'><p>Reassign fossil ages to user-specified stratigraphic intervals</p></a></li>
<li><a href='#sim.taxonomy'><p>Simulate taxonomy</p></a></li>
<li><a href='#sim.tip.samples'><p>Include extant and extinct tip samples in the fossil object, with optional rho sampling.</p></a></li>
<li><a href='#sim.trait.values'><p>Simulate trait values with variation across lineages</p></a></li>
<li><a href='#species.end'><p>Find a species' end (i.e extinction) time from a taxonomy object</p></a></li>
<li><a href='#species.start'><p>Find a species' start (i.e speciation) time from a taxonomy object</p></a></li>
<li><a href='#subsample.fossils.oldest'><p>Obtain a subsample of fossil occurrences containing the oldest fossil sample</p>
in each node of the tree.</a></li>
<li><a href='#subsample.fossils.oldest.and.youngest'><p>Obtain a subsample of fossil occurrences containing the oldest and youngest</p>
fossil sample found at each node of the tree.</a></li>
<li><a href='#subsample.fossils.uniform'><p>Obtain a uniform random sample of fossil occurrences.</p></a></li>
<li><a href='#subsample.fossils.youngest'><p>Obtain a subsample of fossil occurrences containing the youngest fossil</p>
sample in each node of the tree.</a></li>
<li><a href='#summary.taxonomy'><p>Display taxonomy object</p></a></li>
<li><a href='#taxonomy'><p>Taxonomy object</p></a></li>
<li><a href='#tree.max'><p>Find the maximum age in a phylo object (root age or origin time)</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Simulation and Plots for Fossil and Taxonomy Data</td>
</tr>
<tr>
<td>Version:</td>
<td>2.4.1</td>
</tr>
<tr>
<td>Description:</td>
<td>Simulating and plotting taxonomy and fossil data on phylogenetic trees under mechanistic
    models of speciation, preservation and sampling.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.3.2</td>
</tr>
<tr>
<td>Imports:</td>
<td>ape, ggtree, ggfun, ggplot2, tidytree, methods, rlang,</td>
</tr>
<tr>
<td>Suggests:</td>
<td>paleotree, knitr, rmarkdown, devtools, TreeSim, treeio,
ggrepel</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>Language:</td>
<td>en-GB</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 2.10)</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-10-02 11:58:39 UTC; barido</td>
</tr>
<tr>
<td>Author:</td>
<td>Rachel Warnock [aut, cph],
  Joelle Barido-Sottani [aut, cre, cph],
  Walker Pett [aut, cph],
  O'Reilly Joseph [aut, cph],
  UgnÄ— Stolz [aut, cph]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Joelle Barido-Sottani &lt;joelle.barido-sottani@m4x.org&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-10-02 20:30:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='FossilSim'>FossilSim: A package for simulating and plotting fossil and taxonomy data</h2><span id='topic+FossilSim-package'></span><span id='topic+FossilSim'></span>

<h3>Description</h3>

<p>This package provides functions for simulating both taxonomy and fossil data from an existing phylogeny.
</p>


<h3>Simulating taxonomy</h3>

<p>Taxonomy can be simulated in FossilSim under a mixed model of speciation that can incorporate three modes of speciation &ndash;
budding (or asymmetric), bifurcating (or symmetric) and anagenetic &ndash; in addition to cryptic speciation.
A description of the resulting taxonomy objects and simulation functions can be found in the &quot;Simulating taxonomy&quot; vignette.
</p>


<h3>Simulating fossil data</h3>

<p>Fossils can be simulated from a phylogeny or a taxonomy under a model of constant fossil recovery or
time-dependent, environment-dependent or species-dependent fossil recovery.
A description of the resulting fossil objects and simulation functions can be found in the &quot;Simulating fossils&quot; vignette.
</p>


<h3>Plotting functions</h3>

<p>Both taxonomy and fossil objects are provided with custom plotting functions that highlight important features of the simulated objects
along the original phylogeny. More details about these functions can be found in the vignettes or by calling
<code>?plot.taxonomy</code> and <code>?plot.fossils</code>.
</p>


<h3>Compatibility with other packages</h3>

<p>FossilSim is designed to use phylogenies in the ape format. It provides functions to convert to and from the fossilRecordSimulation
format used by the package paleotree (see the vignette &quot;Converting from and to paleotree format&quot;), as well as functions to convert to the
zero-edge format used by BEAST2 and RevBayes (see the vignette &quot;Exporting sampled ancestor trees&quot;).
</p>


<h3>Author(s)</h3>

<p><strong>Maintainer</strong>: Joelle Barido-Sottani <a href="mailto:joelle.barido-sottani@m4x.org">joelle.barido-sottani@m4x.org</a> [copyright holder]
</p>
<p>Authors:
</p>

<ul>
<li><p> Rachel Warnock <a href="mailto:rachel.warnock@bsse.ethz.ch">rachel.warnock@bsse.ethz.ch</a> [copyright holder]
</p>
</li>
<li><p> Walker Pett [copyright holder]
</p>
</li>
<li><p> O'Reilly Joseph [copyright holder]
</p>
</li>
<li><p> UgnÄ— Stolz [copyright holder]
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'># simulate a tree using TreeSim conditioned on tip number
t = TreeSim::sim.bd.taxa(n = 10, numbsim = 1, lambda = 1, mu = 0.2)[[1]]

# simulate taxonomy under mixed speciation
s = sim.taxonomy(tree = t, beta = 0.5, lambda.a = 1, kappa = 0.1)
# plot the result
plot(s, tree = t, legend.position = "topleft")

# simulate fossils using the phylogeny and a constant fossil recovery rate
f = sim.fossils.poisson(rate = 3, tree = t)
# plot the result
plot(f, tree = t)

# simulate fossils using the taxonomy and a constant fossil recovery rate
f = sim.fossils.poisson(rate = 3, taxonomy = s)
# plot the result
plot(f, tree = t, taxonomy = s, show.taxonomy = TRUE)

# simulate fossils using time-dependent fossil recovery rates
f = sim.fossils.intervals(tree = t, rates = c(1, 0.1, 1, 0.1), max.age = tree.max(t), strata = 4)
# plot the result, with the time intervals
plot(f, tree = t, show.strata = TRUE, max.age = tree.max(t), strata = 4)

</code></pre>

<hr>
<h2 id='beast.fbd.format'>Transforms a tree and fossils into a sampled tree in beast-usable format and writes it in Newick format.
Designed to work with FBD.</h2><span id='topic+beast.fbd.format'></span>

<h3>Description</h3>

<p>Transforms a tree and fossils into a sampled tree in beast-usable format and writes it in Newick format.
Designed to work with FBD.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>beast.fbd.format(tree, fossils, rho = 1, sampled_tips = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="beast.fbd.format_+3A_tree">tree</code></td>
<td>
<p>Complete tree.</p>
</td></tr>
<tr><td><code id="beast.fbd.format_+3A_fossils">fossils</code></td>
<td>
<p>fossils dataframe.</p>
</td></tr>
<tr><td><code id="beast.fbd.format_+3A_rho">rho</code></td>
<td>
<p>Sampling probability of extant tips. Default 1, will be disregarded if sampled_tips is not null.</p>
</td></tr>
<tr><td><code id="beast.fbd.format_+3A_sampled_tips">sampled_tips</code></td>
<td>
<p>List of tip labels corresponding to sampled extant tips.</p>
</td></tr>
<tr><td><code id="beast.fbd.format_+3A_...">...</code></td>
<td>
<p>Additional parameters will be passed to ape::write.tree</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Output of write.tree.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># simulate tree
t = ape::rtree(6)

# simulate fossils
f = sim.fossils.poisson(rate = 2, tree = t)

# output for BEAST
beast.fbd.format(t, f) # output on the console
## Not run: 
beast.fbd.format(t, f, file="example.tre") # output in file

## End(Not run)
</code></pre>

<hr>
<h2 id='count.fossils'>Count the total number of fossils</h2><span id='topic+count.fossils'></span>

<h3>Description</h3>

<p>Count the total number of fossils
</p>


<h3>Usage</h3>

<pre><code class='language-R'>count.fossils(fossils)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="count.fossils_+3A_fossils">fossils</code></td>
<td>
<p>Fossils object.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Number of extinct samples.
</p>

<hr>
<h2 id='count.fossils.binned'>Count the total number of fossils per interval</h2><span id='topic+count.fossils.binned'></span>

<h3>Description</h3>

<p>Count the total number of fossils per interval
</p>


<h3>Usage</h3>

<pre><code class='language-R'>count.fossils.binned(fossils, interval.ages)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="count.fossils.binned_+3A_fossils">fossils</code></td>
<td>
<p>Fossils object.</p>
</td></tr>
<tr><td><code id="count.fossils.binned_+3A_interval.ages">interval.ages</code></td>
<td>
<p>Vector of stratigraphic interval ages, starting with the minimum age of the youngest interval and ending with the maximum age of the oldest interval.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Vector of extinct samples corresponding to each interval. Note the last value corresponds to the number of samples &gt; the maximum age of the oldest interval.
</p>

<hr>
<h2 id='fbdrange'>Creates an fbdrange object from provided tree and data</h2><span id='topic+fbdrange'></span>

<h3>Description</h3>

<p>Creates an fbdrange object from provided tree and data
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fbdrange(tree, data)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="fbdrange_+3A_tree">tree</code></td>
<td>
<p><code>phylo</code> object to be included in the fbdrange object</p>
</td></tr>
<tr><td><code id="fbdrange_+3A_data">data</code></td>
<td>
<p>associated data to be included in the fbdrange object. Needs to contain <code>range</code> and <code>orientation</code> fields.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the new fbdrange object
</p>

<hr>
<h2 id='fossils'>Fossils object</h2><span id='topic+fossils'></span><span id='topic+as.fossils'></span><span id='topic+is.fossils'></span>

<h3>Description</h3>

<p>Create a fossil record object. The input is taken to be a dataframe or list.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fossils(data = NULL, from.taxonomy = FALSE)

as.fossils(data, from.taxonomy = FALSE)

is.fossils(data)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="fossils_+3A_data">data</code></td>
<td>
<p>Dataframe or list of sampled fossils. See Details for the list of required fields. If NULL, the function creates an empty fossils object.</p>
</td></tr>
<tr><td><code id="fossils_+3A_from.taxonomy">from.taxonomy</code></td>
<td>
<p>Boolean indicating whether the fossils were sampled using a taxonomy object, as opposed to a tree object. Default = FALSE.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The fossil record object contains 4 fields for each fossil with the following information:
</p>

<ul>
<li> <p><code>sp</code> the label of the corresponding species. This label matches the edge labels in the corresponding phylo object or the species labels in the corresponding taxonomy object if additional taxonomic
information was provided
</p>
</li>
<li> <p><code>edge</code> the label of the sampled node or tip in the phylogeny, i.e the node at the end of the edge along which the fossil was sampled
</p>
</li>
<li> <p><code>hmin</code> the age of the fossil or the youngest bound of the time interval in which the fossil was sampled
</p>
</li>
<li> <p><code>hmax</code> the oldest bound of the time interval in which the fossil was sampled.
This is equal to <code>hmin</code> if exact sampling times are known
</p>
</li></ul>


<hr>
<h2 id='fossils.to.BEAST.constraints'>Create a set of BEAST2 constraints to construct a DPPDIV style fixed extant
topology FBD analysis</h2><span id='topic+fossils.to.BEAST.constraints'></span>

<h3>Description</h3>

<p>If complete = FALSE, only the extant taxa are used to construct the taxon
constraints, resulting in a DPPDIV style analysis in which the extant
topology is fixed and fossils can float in the tree. The resulting output uses the stronglyMonophyletic
taxon constraint on the root, this means that all fossil taxa will be sampled in the crown group, and never
in a position below the root.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fossils.to.BEAST.constraints(
  fossils,
  tree,
  file = "BEASTconstraints.xml",
  complete = FALSE,
  tree.name = "beastTree"
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="fossils.to.BEAST.constraints_+3A_fossils">fossils</code></td>
<td>
<p>an object of class &quot;fossils&quot; that corresponds to fossil
occurrences for the &quot;tree&quot; argument.</p>
</td></tr>
<tr><td><code id="fossils.to.BEAST.constraints_+3A_tree">tree</code></td>
<td>
<p>an object of class &quot;phylo&quot;, representing the tree upon which the
fossil occurrences were simulated.</p>
</td></tr>
<tr><td><code id="fossils.to.BEAST.constraints_+3A_file">file</code></td>
<td>
<p>the name of the file to which the constraints will be written,
defaults to &quot;BEASTconstraints.xml&quot;.</p>
</td></tr>
<tr><td><code id="fossils.to.BEAST.constraints_+3A_complete">complete</code></td>
<td>
<p>logical, if TRUE then taxon constraints are built for the
complete tree, if FALSE then constraints are built for the crown clades
only. Default value is FALSE.</p>
</td></tr>
<tr><td><code id="fossils.to.BEAST.constraints_+3A_tree.name">tree.name</code></td>
<td>
<p>the name of the tree as used in the BEAST2 xml format.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>NULL.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>t = TreeSim::sim.bd.taxa(10, 1, 0.1, 0.05)[[1]]
f = sim.fossils.poisson(0.1, t, root.edge = FALSE)
fossils.to.BEAST.constraints(f, t, file = tempfile(), complete = TRUE)
</code></pre>

<hr>
<h2 id='fossils.to.BEAST.start.tree'>Create a suitable starting tree for a DPPDIV style FBD analysis in BEAST2</h2><span id='topic+fossils.to.BEAST.start.tree'></span>

<h3>Description</h3>

<p>If complete = FALSE, only the extant taxa are used to construct the tree,
resulting in a DPPDIV style analysis in which the extant topology is fixed
and fossils can float in the tree.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fossils.to.BEAST.start.tree(tree, fossils, complete = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="fossils.to.BEAST.start.tree_+3A_tree">tree</code></td>
<td>
<p>an object of class &quot;phylo&quot;, representing the tree upon which the
fossil occurrences were simulated.</p>
</td></tr>
<tr><td><code id="fossils.to.BEAST.start.tree_+3A_fossils">fossils</code></td>
<td>
<p>an object of class &quot;fossils&quot; that corresponds to fossil
occurrences for the &quot;tree&quot; argument.</p>
</td></tr>
<tr><td><code id="fossils.to.BEAST.start.tree_+3A_complete">complete</code></td>
<td>
<p>logical, if TRUE then the tree are built for the complete
tree, if FALSE then the tree is built for the crown clades only.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a string representing the starting tree in newick format.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>t = TreeSim::sim.bd.taxa(10, 1, 0.1, 0.05)[[1]]
f = sim.fossils.poisson(0.1, t, root.edge = FALSE)
fossils.to.BEAST.start.tree(t,f, complete = FALSE)
</code></pre>

<hr>
<h2 id='fossils.to.paleotree.record'>Transforms a fossils dataframe and either taxonomy or tree into a fossilRecordSimulation object from package paleotree.</h2><span id='topic+fossils.to.paleotree.record'></span>

<h3>Description</h3>

<p>Transforms a fossils dataframe and either taxonomy or tree into a fossilRecordSimulation object from package paleotree.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fossils.to.paleotree.record(fossils, tree = NULL, taxonomy = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="fossils.to.paleotree.record_+3A_fossils">fossils</code></td>
<td>
<p>fossils object</p>
</td></tr>
<tr><td><code id="fossils.to.paleotree.record_+3A_tree">tree</code></td>
<td>
<p>phylo object containing the tree. If provided and taxonomy = NULL, all speciation is assumed symmetric</p>
</td></tr>
<tr><td><code id="fossils.to.paleotree.record_+3A_taxonomy">taxonomy</code></td>
<td>
<p>taxonomy object. If both tree and taxonomy are provided, only taxonomy will be used.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The converted paleotree record
</p>


<h3>See Also</h3>

<p><code><a href="#topic+taxonomy">taxonomy</a></code>, <code><a href="#topic+fossils">fossils</a></code>, <code><a href="#topic+paleotree.record.to.fossils">paleotree.record.to.fossils</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># simulate tree
t = ape::rtree(6)
# simulate fossils using taxonomy
s = sim.taxonomy(t, 0.5, 1, 0.5)
f = sim.fossils.poisson(2, taxonomy = s)
# transform format
record = fossils.to.paleotree.record(f, taxonomy = s)
</code></pre>

<hr>
<h2 id='fossils.to.pyrate'>Generate output in the format used by the program PyRate</h2><span id='topic+fossils.to.pyrate'></span>

<h3>Description</h3>

<p>Generate output in the format used by the program PyRate
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fossils.to.pyrate(
  fossils,
  python = TRUE,
  traits = NULL,
  cutoff = NULL,
  random = FALSE,
  min = NULL,
  exclude.extant.singletons = TRUE,
  file = "",
  use.sp.names = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="fossils.to.pyrate_+3A_fossils">fossils</code></td>
<td>
<p>Fossils object.</p>
</td></tr>
<tr><td><code id="fossils.to.pyrate_+3A_python">python</code></td>
<td>
<p>If TRUE the function outputs the data in the python format used by PyRate (default).
If FALSE the function outputs a tab-delimited table used by tools associated with PyRate.</p>
</td></tr>
<tr><td><code id="fossils.to.pyrate_+3A_traits">traits</code></td>
<td>
<p>Vector of trait values equal to the number of unique species in the fossils dataframe.
The order should correspond to the order in which they appear in <code>unique(fossils$sp)</code>.</p>
</td></tr>
<tr><td><code id="fossils.to.pyrate_+3A_cutoff">cutoff</code></td>
<td>
<p>Exclude occurrences with age uncertainty greater than this value i.e. <code>hmax - hmin &gt; cutoff</code>.</p>
</td></tr>
<tr><td><code id="fossils.to.pyrate_+3A_random">random</code></td>
<td>
<p>If TRUE use a random number from within the interval U(hmin, hmax) for specimen ages,
otherwise use the midpoint of this interval (default). Applicable only when <code>python = TRUE</code> and for specimens with <code>hmin != hmax</code>.</p>
</td></tr>
<tr><td><code id="fossils.to.pyrate_+3A_min">min</code></td>
<td>
<p>Value used to represent the minimum possible interval age of extinct specimens with <code>hmin = 0</code>. By default <code>min = NULL</code> and the function will use the sampling times in the fossils dataframe.</p>
</td></tr>
<tr><td><code id="fossils.to.pyrate_+3A_exclude.extant.singletons">exclude.extant.singletons</code></td>
<td>
<p>If TRUE exclude species that have extant samples only (default = TRUE).</p>
</td></tr>
<tr><td><code id="fossils.to.pyrate_+3A_file">file</code></td>
<td>
<p>Output file name.</p>
</td></tr>
<tr><td><code id="fossils.to.pyrate_+3A_use.sp.names">use.sp.names</code></td>
<td>
<p>If TRUE use the value in fossils$sp as the complete taxon name, otherwise the function adds the prefix &quot;taxa&quot; (default = FALSE).</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>
set.seed(123)

# simulate tree
t = ape::rtree(6)

# assign a max age based on tree height
max.age = tree.max(t)

# define a set of non-uniform length intervals
times = c(0, sort(runif(3, min = 0, max = max.age)), max.age)
rates = c(1,2,3,4)

# simulate fossils reflect age uncertainty
f = sim.fossils.intervals(tree = t, interval.ages = times, rates = rates,
    use.exact.times = FALSE)

# simulate extant samples
rho = 1
f = sim.extant.samples(f, t, rho = 1)

plot(f, t)

# generate input files for pyrate
fossils.to.pyrate(f)
fossils.to.pyrate(f, python = FALSE)

# add trait values
traits = runif(length(unique(f$sp)))
fossils.to.pyrate(f, traits = traits)

</code></pre>

<hr>
<h2 id='get_fbdrange_from_file'>Import fbdrange object from file</h2><span id='topic+get_fbdrange_from_file'></span>

<h3>Description</h3>

<p>Import fbdrange object from file
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_fbdrange_from_file(input_file)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="get_fbdrange_from_file_+3A_input_file">input_file</code></td>
<td>
<p>path to a tree file in Nexus format containing range and orientation metadata for the trees (for instance, a file generated by the BEAST2 package sRanges)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an fbdrange object
</p>


<h3>Examples</h3>

<pre><code class='language-R'>tree_file &lt;- system.file("extdata", "fbdrange.trees", package = "FossilSim")
fbdr &lt;- get_fbdrange_from_file(tree_file)
</code></pre>

<hr>
<h2 id='get.tip.descs'>Obtain the tips that define each node in a tree</h2><span id='topic+get.tip.descs'></span>

<h3>Description</h3>

<p>Obtain the tips that define each node in a tree
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get.tip.descs(tree)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="get.tip.descs_+3A_tree">tree</code></td>
<td>
<p>an object of class &quot;Phylo&quot;.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of vectors, with one entry for each node consisting of the tip labels
that define that node.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>t = TreeSim::sim.bd.taxa(10, 1, 0.1, 0.05)[[1]]
get.tip.descs(t)
</code></pre>

<hr>
<h2 id='paleotree.record.to.fossils'>Transforms a fossilRecordSimulation object from package paleotree to a tree and taxonomy and fossils objects.</h2><span id='topic+paleotree.record.to.fossils'></span>

<h3>Description</h3>

<p>The returned tree is in paleotree format, with zero-length edges leading to tips at bifurcation and anagenetic events.
Fossils and taxonomy are only specified on non-zero-length edges.
The label assigned to the parent of the origin or root will be zero.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>paleotree.record.to.fossils(record)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="paleotree.record.to.fossils_+3A_record">record</code></td>
<td>
<p>fossilRecordSimulation object.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list containing the converted tree, taxonomy and fossils
</p>


<h3>See Also</h3>

<p><code><a href="#topic+taxonomy">taxonomy</a></code>, <code><a href="#topic+fossils">fossils</a></code>, <code><a href="#topic+fossils.to.paleotree.record">fossils.to.paleotree.record</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if (requireNamespace("paleotree", quietly = TRUE)) {
# simulate record
record = paleotree::simFossilRecord(p=0.1, q=0.1,r=0.1, nruns=1, nTotalTaxa=c(30,40),
    nExtant=0, nSamp = c(5,25))

# transform format
l_tf = paleotree.record.to.fossils(record)
l_tf$tree
l_tf$taxonomy
l_tf$fossils
}

</code></pre>

<hr>
<h2 id='place.fossils'>Place fossil samples from one tree in another tree, or find the ancestral
node for each fossil sample in one tree.</h2><span id='topic+place.fossils'></span>

<h3>Description</h3>

<p>If &quot;ext.tree&quot; is not supplied, this function will find the direct ancestral
node for each of the supplied fossil samples. If &quot;ext.tree&quot; is supplied, this
function will find the direct ancestral node for each fossil in &quot;ext.tree&quot;.
This second behaviour is used for placing fossils simulated on a complete
Birth-Death tree in the extant-only counterpart tree. This results in fossil
samples being placed in the crown clades of the tree upon which they were
simulated. When &quot;ext.tree&quot; is supplied, any fossil samples appearing before
the MRCA of the crown group are discarded.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>place.fossils(tree, fossils, ext.tree)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="place.fossils_+3A_tree">tree</code></td>
<td>
<p>an object of class &quot;Phylo&quot;.</p>
</td></tr>
<tr><td><code id="place.fossils_+3A_fossils">fossils</code></td>
<td>
<p>an object of class &quot;fossils&quot; that corresponds to fossil
occurrences for the &quot;tree&quot; argument.</p>
</td></tr>
<tr><td><code id="place.fossils_+3A_ext.tree">ext.tree</code></td>
<td>
<p>an object of class &quot;Phylo&quot; representing the extant
counterpart to &quot;tree&quot;, this can be obtained with prune.fossil.tips(tree).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a vector of node numbers corresponding to the direct ancestor of each
fossil sample in &quot;fossils&quot;.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>t = TreeSim::sim.bd.taxa(10, 1, 0.1, 0.05)[[1]]
f = sim.fossils.poisson(0.1, t, root.edge = FALSE)
place.fossils(t,f)
</code></pre>

<hr>
<h2 id='plot.fbdrange'>Plot oriented tree with stratigraphic ranges</h2><span id='topic+plot.fbdrange'></span>

<h3>Description</h3>

<p>Plot oriented tree with stratigraphic ranges
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'fbdrange'
plot(x, smart.labels = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot.fbdrange_+3A_x">x</code></td>
<td>
<p>object of type <code>fbdrange</code> containing orientation and range data</p>
</td></tr>
<tr><td><code id="plot.fbdrange_+3A_smart.labels">smart.labels</code></td>
<td>
<p>whether to label the ranges (default <code>FALSE</code>, requires package [ggrepel] to place labels)</p>
</td></tr>
<tr><td><code id="plot.fbdrange_+3A_...">...</code></td>
<td>
<p>other arguments to be passed to the plot labels (does nothing if <code>smart.labels = FALSE</code>)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a ggtree plot which can be combined with any other commands from [ggplot2] or [ggtree]
</p>


<h3>Examples</h3>

<pre><code class='language-R'>tree_file &lt;- system.file("extdata", "fbdrange.trees", package = "FossilSim")
fbdr &lt;- get_fbdrange_from_file(tree_file)
p &lt;- plot(fbdr, smart.labels = TRUE)

</code></pre>

<hr>
<h2 id='plot.fossils'>Plot simulated fossils</h2><span id='topic+plot.fossils'></span>

<h3>Description</h3>

<p>This function is adapted from the <em>ape</em> function <code>plot.phylo</code> used to plot phylogenetic trees.
The function can be used to plot simulated fossils (<code>show.fossils = TRUE</code>), with or without the corresponding tree (<code>show.tree = TRUE</code>),
stratigraphic intervals (<code>show.strata = TRUE</code>), stratigraphic ranges (<code>show.ranges = TRUE</code>) and sampling proxy data (<code>show.proxy = TRUE</code>).
Interval ages can be specified as a vector (<code>interval.ages</code>) or a uniform set of interval ages can be specified using the
number of intervals (<code>strata</code>) and maximum interval age (<code>max</code>), where interval length <code class="reqn">= max.age/strata</code>.
If no maximum age is specified, the function calculates a maximum interval age slightly older than the root edge (or root age if <code>root.edge = FALSE</code>),
using the function <code>tree.max()</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'fossils'
plot(
  x,
  tree,
  show.fossils = TRUE,
  show.tree = TRUE,
  show.ranges = FALSE,
  show.strata = FALSE,
  strata = 1,
  max.age = NULL,
  interval.ages = NULL,
  binned = FALSE,
  show.axis = TRUE,
  show.proxy = FALSE,
  proxy.data = NULL,
  show.preferred.environ = FALSE,
  preferred.environ = NULL,
  show.taxonomy = FALSE,
  taxonomy = NULL,
  show.unknown = FALSE,
  rho = 1,
  root.edge = TRUE,
  hide.edge = FALSE,
  edge.width = 1,
  show.tip.label = FALSE,
  align.tip.label = FALSE,
  reconstructed = FALSE,
  fossil.col = 1,
  range.col = rgb(0, 0, 1),
  extant.col = 1,
  taxa.palette = "viridis",
  col.axis = "gray35",
  cex = 1.2,
  pch = 18,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot.fossils_+3A_x">x</code></td>
<td>
<p>Fossils object.</p>
</td></tr>
<tr><td><code id="plot.fossils_+3A_tree">tree</code></td>
<td>
<p>Phylo object.</p>
</td></tr>
<tr><td><code id="plot.fossils_+3A_show.fossils">show.fossils</code></td>
<td>
<p>If TRUE plot fossils (default = TRUE).</p>
</td></tr>
<tr><td><code id="plot.fossils_+3A_show.tree">show.tree</code></td>
<td>
<p>If TRUE plot the tree  (default = TRUE).</p>
</td></tr>
<tr><td><code id="plot.fossils_+3A_show.ranges">show.ranges</code></td>
<td>
<p>If TRUE plot stratigraphic ranges (default = FALSE). If <code>show.taxonomy = FALSE</code> all occurrences along a single edge are grouped together (i.e. function assumes all speciation is symmetric).</p>
</td></tr>
<tr><td><code id="plot.fossils_+3A_show.strata">show.strata</code></td>
<td>
<p>If TRUE plot strata  (default = FALSE).</p>
</td></tr>
<tr><td><code id="plot.fossils_+3A_strata">strata</code></td>
<td>
<p>Number of stratigraphic intervals (default = 1).</p>
</td></tr>
<tr><td><code id="plot.fossils_+3A_max.age">max.age</code></td>
<td>
<p>Maximum age of a set of equal length intervals. If no value is specified (<code>max = NULL</code>), the function uses a maximum age based on tree height.</p>
</td></tr>
<tr><td><code id="plot.fossils_+3A_interval.ages">interval.ages</code></td>
<td>
<p>Vector of stratigraphic interval ages, starting with the minimum age of the youngest interval and ending with the maximum age of the oldest interval.</p>
</td></tr>
<tr><td><code id="plot.fossils_+3A_binned">binned</code></td>
<td>
<p>If TRUE fossils are plotted at the mid point of each interval.</p>
</td></tr>
<tr><td><code id="plot.fossils_+3A_show.axis">show.axis</code></td>
<td>
<p>If TRUE plot x-axis (default = TRUE).</p>
</td></tr>
<tr><td><code id="plot.fossils_+3A_show.proxy">show.proxy</code></td>
<td>
<p>If TRUE add profile of sampling data to plot (e.g. rates in time-dependent rates model) (default = FALSE).</p>
</td></tr>
<tr><td><code id="plot.fossils_+3A_proxy.data">proxy.data</code></td>
<td>
<p>Vector of sampling proxy data (default = NULL). Should be as long as the number of stratigraphic intervals.</p>
</td></tr>
<tr><td><code id="plot.fossils_+3A_show.preferred.environ">show.preferred.environ</code></td>
<td>
<p>If TRUE add species preferred environmental value (e.g. water depth) (default = FALSE). Only works if combined with <code>show.proxy = TRUE</code>.</p>
</td></tr>
<tr><td><code id="plot.fossils_+3A_preferred.environ">preferred.environ</code></td>
<td>
<p>Preferred environmental value (e.g. water depth). Currently only one value can be shown.</p>
</td></tr>
<tr><td><code id="plot.fossils_+3A_show.taxonomy">show.taxonomy</code></td>
<td>
<p>If TRUE highlight species taxonomy.</p>
</td></tr>
<tr><td><code id="plot.fossils_+3A_taxonomy">taxonomy</code></td>
<td>
<p>Taxonomy object.</p>
</td></tr>
<tr><td><code id="plot.fossils_+3A_show.unknown">show.unknown</code></td>
<td>
<p>If TRUE plot fossils with unknown taxonomic affiliation (i.e. sp = NA) (default = FALSE).</p>
</td></tr>
<tr><td><code id="plot.fossils_+3A_rho">rho</code></td>
<td>
<p>Extant species sampling probability (default = 1). Will be disregarded if fossils object already contains extant samples.</p>
</td></tr>
<tr><td><code id="plot.fossils_+3A_root.edge">root.edge</code></td>
<td>
<p>If TRUE include the root edge (default = TRUE).</p>
</td></tr>
<tr><td><code id="plot.fossils_+3A_hide.edge">hide.edge</code></td>
<td>
<p>If TRUE hide the root edge but still incorporate it into the automatic timescale (default = FALSE).</p>
</td></tr>
<tr><td><code id="plot.fossils_+3A_edge.width">edge.width</code></td>
<td>
<p>A numeric vector giving the width of the branches of the plotted phylogeny. These are taken to be in the same order as the component edge of <code>tree</code>. If fewer widths are given than the number of edges, then the values are recycled.</p>
</td></tr>
<tr><td><code id="plot.fossils_+3A_show.tip.label">show.tip.label</code></td>
<td>
<p>Whether to show the tip labels on the phylogeny (defaults to FALSE).</p>
</td></tr>
<tr><td><code id="plot.fossils_+3A_align.tip.label">align.tip.label</code></td>
<td>
<p>A logical value or an integer. If TRUE, the tips are aligned and dotted lines are drawn between the tips of the tree and the labels. If an integer, the tips are aligned and this gives the type of the lines (following <code>lty</code>).</p>
</td></tr>
<tr><td><code id="plot.fossils_+3A_reconstructed">reconstructed</code></td>
<td>
<p>If TRUE plot the reconstructed tree. If fossils object contains no extant samples, the function assumes rho = 1 and includes all species at the present.</p>
</td></tr>
<tr><td><code id="plot.fossils_+3A_fossil.col">fossil.col</code></td>
<td>
<p>Colour of fossil occurrences. A vector equal to the length of the fossils object can be used to assign different colours.</p>
</td></tr>
<tr><td><code id="plot.fossils_+3A_range.col">range.col</code></td>
<td>
<p>Colour of stratigraphic ranges.</p>
</td></tr>
<tr><td><code id="plot.fossils_+3A_extant.col">extant.col</code></td>
<td>
<p>Colour of extant samples. If <code>show.taxonomy = TRUE</code>, <code>extant.col</code> will be ignored.</p>
</td></tr>
<tr><td><code id="plot.fossils_+3A_taxa.palette">taxa.palette</code></td>
<td>
<p>Colour palette used if <code>show.fossils = TRUE</code>. Colours are assigned to taxa using the function <code>grDevices::hcl.colors()</code> and the default palette is &quot;viridis&quot;. Other colour blind friendly palettes include <code>"Blue-Red 3"</code> and <code>"Green-Brown"</code>.</p>
</td></tr>
<tr><td><code id="plot.fossils_+3A_col.axis">col.axis</code></td>
<td>
<p>Colour of the time scale axis (default = &quot;gray35&quot;).</p>
</td></tr>
<tr><td><code id="plot.fossils_+3A_cex">cex</code></td>
<td>
<p>Numeric value giving the factor used to scale the points representing the fossils when <code>show.fossils = TRUE</code>.</p>
</td></tr>
<tr><td><code id="plot.fossils_+3A_pch">pch</code></td>
<td>
<p>Numeric value giving the symbol used for the points representing the fossils when <code>show.fossils = TRUE</code>.</p>
</td></tr>
<tr><td><code id="plot.fossils_+3A_...">...</code></td>
<td>
<p>Additional parameters to be passed to <code>plot.default</code>.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(123)

## simulate tree
t = TreeSim::sim.bd.taxa(8, 1, 1, 0.3)[[1]]

## simulate fossils under a Poisson sampling process
f = sim.fossils.poisson(rate = 3, tree = t)
plot(f, t)
# add a set of equal length strata
plot(f, t, show.strata = TRUE, strata = 4)
# show stratigraphic ranges
plot(f, t, show.strata = TRUE, strata = 4, show.ranges = TRUE)

## simulate fossils and highlight taxonomy
s = sim.taxonomy(t, 0.5, 1)
f = sim.fossils.poisson(rate = 3, taxonomy = s)
plot(f, t, taxonomy = s, show.taxonomy = TRUE, show.ranges = TRUE)


## simulate fossils under a non-uniform model of preservation
# assign a max interval based on tree height
max.age = tree.max(t)
times = c(0, 0.3, 1, max.age)
rates = c(4, 1, 0.1)
f = sim.fossils.intervals(t, interval.ages = times, rates = rates)
plot(f, t, show.strata = TRUE, interval.ages = times)
# add proxy data
plot(f, t, show.strata = TRUE, interval.ages = times, show.proxy = TRUE, proxy.data = rates)

</code></pre>

<hr>
<h2 id='plot.taxonomy'>Plot simulated taxonomy</h2><span id='topic+plot.taxonomy'></span>

<h3>Description</h3>

<p>This function is adapted from the <em>ape</em> function <code>plot.phylo</code> used to plot phylogenetic trees.
The function can be used to plot simulated taxonomy along with the corresponding tree.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'taxonomy'
plot(
  x,
  tree,
  show.mode = TRUE,
  show.legend = TRUE,
  legend.position = "bottomleft",
  root.edge = TRUE,
  hide.edge = FALSE,
  edge.width = 1,
  show.tip.label = FALSE,
  align.tip.label = FALSE,
  taxa.palette = "viridis",
  cex = 1.2,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot.taxonomy_+3A_x">x</code></td>
<td>
<p>Taxonomy object.</p>
</td></tr>
<tr><td><code id="plot.taxonomy_+3A_tree">tree</code></td>
<td>
<p>Phylo object.</p>
</td></tr>
<tr><td><code id="plot.taxonomy_+3A_show.mode">show.mode</code></td>
<td>
<p>Indicate speciation mode.</p>
</td></tr>
<tr><td><code id="plot.taxonomy_+3A_show.legend">show.legend</code></td>
<td>
<p>Add a legend for the symbols indicating different speciation modes.</p>
</td></tr>
<tr><td><code id="plot.taxonomy_+3A_legend.position">legend.position</code></td>
<td>
<p>Position of the legend. Options include <code>"bottomleft"</code> (default), <code>"topleft"</code>, <code>"bottomright"</code>, <code>"topright"</code> or a vector of length 2 with x, y coordinates.</p>
</td></tr>
<tr><td><code id="plot.taxonomy_+3A_root.edge">root.edge</code></td>
<td>
<p>If TRUE include the root edge (default = TRUE).</p>
</td></tr>
<tr><td><code id="plot.taxonomy_+3A_hide.edge">hide.edge</code></td>
<td>
<p>If TRUE hide the root edge but still incorporate it into the automatic timescale (default = FALSE).</p>
</td></tr>
<tr><td><code id="plot.taxonomy_+3A_edge.width">edge.width</code></td>
<td>
<p>A numeric vector giving the width of the branches of the plotted phylogeny. These are taken to be in the same order as the component edge of <code>tree</code>. If fewer widths are given than the number of edges, then the values are recycled.</p>
</td></tr>
<tr><td><code id="plot.taxonomy_+3A_show.tip.label">show.tip.label</code></td>
<td>
<p>Whether to show the tip labels on the phylogeny (defaults to FALSE).</p>
</td></tr>
<tr><td><code id="plot.taxonomy_+3A_align.tip.label">align.tip.label</code></td>
<td>
<p>A logical value or an integer. If TRUE, the tips are aligned and dotted lines are drawn between the tips of the tree and the labels. If an integer, the tips are aligned and this gives the type of the lines (lty).</p>
</td></tr>
<tr><td><code id="plot.taxonomy_+3A_taxa.palette">taxa.palette</code></td>
<td>
<p>Colour palette used for taxa. Colours are assigned to taxa using the function <code>grDevices::hcl.colors()</code> and the default palette is &quot;viridis&quot;. Other colour blind friendly palettes include <code>"Blue-Red 3"</code> and <code>"Green-Brown"</code>.</p>
</td></tr>
<tr><td><code id="plot.taxonomy_+3A_cex">cex</code></td>
<td>
<p>Numeric value giving the factor used to scale the points representing the fossils when <code>show.fossils = TRUE</code>.</p>
</td></tr>
<tr><td><code id="plot.taxonomy_+3A_...">...</code></td>
<td>
<p>Additional parameters to be passed to <code>plot.default</code>.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(123)

## simulate tree
t = TreeSim::sim.bd.taxa(8, 1, 1, 0.3)[[1]]

## simulate taxonomy
s = sim.taxonomy(t, 0.5, 1)

## plot the output
plot(s, t)

</code></pre>

<hr>
<h2 id='prune.fossil.tips'>Remove fossil lineages from a tree</h2><span id='topic+prune.fossil.tips'></span>

<h3>Description</h3>

<p>Remove fossil lineages from a tree
</p>


<h3>Usage</h3>

<pre><code class='language-R'>prune.fossil.tips(tree)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="prune.fossil.tips_+3A_tree">tree</code></td>
<td>
<p>an object of class &quot;Phylo&quot;.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an object of class &quot;Phylo&quot;. If fossil lineages were found in the tree
these will be pruned, if not then the original tree is returned.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>t = TreeSim::sim.bd.taxa(10, 1, 0.1, 0.05)[[1]]
prune.fossil.tips(t)
</code></pre>

<hr>
<h2 id='prune.fossils'>Removes all intermediate fossils from a combined tree and labels the first and last fossils of each lineage.
Can be used with sampled or complete trees. If only one fossil is present for a particular species it is labelled as first.</h2><span id='topic+prune.fossils'></span>

<h3>Description</h3>

<p>Removes all intermediate fossils from a combined tree and labels the first and last fossils of each lineage.
Can be used with sampled or complete trees. If only one fossil is present for a particular species it is labelled as first.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>prune.fossils(tree)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="prune.fossils_+3A_tree">tree</code></td>
<td>
<p>Combined tree with fossils.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Tree with pruned fossils.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># simulate tree
t = ape::rtree(6)

# simulate fossils
f = sim.fossils.poisson(rate = 2, tree = t)

# transform format
t2 = SAtree.from.fossils(t,f)$tree

# prune fossils
t4 = prune.fossils(t2)

# or transform to sampled tree first
t3 = sampled.tree.from.combined(t2)
t4 = prune.fossils(t3)
plot(t4)
</code></pre>

<hr>
<h2 id='rangeplot.asymmetric'>Make an asymmetric stratigraphic range plot from a tree object of class phylo</h2><span id='topic+rangeplot.asymmetric'></span>

<h3>Description</h3>

<p>Make an asymmetric stratigraphic range plot from a tree object of class phylo
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rangeplot.asymmetric(x, complete = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="rangeplot.asymmetric_+3A_x">x</code></td>
<td>
<p>phylo object to plot.</p>
</td></tr>
<tr><td><code id="rangeplot.asymmetric_+3A_complete">complete</code></td>
<td>
<p>Plot unsampled species.</p>
</td></tr>
<tr><td><code id="rangeplot.asymmetric_+3A_...">...</code></td>
<td>
<p>Additional parameters to be passed to <code>plot.default</code>.</p>
</td></tr>
</table>


<h3>Note</h3>

<p>This function assumes all speciation events are asymmetric.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>tree = sim.fbd.taxa(n = 10, numbsim = 1, lambda = 3, mu = 2, psi = 1, complete = TRUE)[[1]]
rangeplot.asymmetric(tree, complete=TRUE)

</code></pre>

<hr>
<h2 id='reconcile.fossils.taxonomy'>Reconcile existing fossil and taxonomy objects</h2><span id='topic+reconcile.fossils.taxonomy'></span>

<h3>Description</h3>

<p>This function uses edge identifiers (<code>edge</code>) and fossil sampling times (<code>hmin</code>) to reassign fossil species identifiers (<code>sp, origin</code>) using an existing taxonomy object.
It can only be used if exact fossil sampling times are known (i.e. <code>hmin = hmax</code>), otherwise edges containing multiple species may be indistinguishable.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>reconcile.fossils.taxonomy(fossils, taxonomy)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="reconcile.fossils.taxonomy_+3A_fossils">fossils</code></td>
<td>
<p>Fossils object.</p>
</td></tr>
<tr><td><code id="reconcile.fossils.taxonomy_+3A_taxonomy">taxonomy</code></td>
<td>
<p>Taxonomy object.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class fossils.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># simulate tree
t = ape::rtree(6)

# simulate fossils using the tree
rate = 2
f = sim.fossils.poisson(rate, tree = t)
plot(f, t)

# simulate fossils using taxonomy
s = sim.taxonomy(t, 0.5, 1, 0.5)
f = reconcile.fossils.taxonomy(f, s)
plot(f, t)

</code></pre>

<hr>
<h2 id='reconstructed.tree.fossils.objects'>Returns tree and fossil objects that you can use to plot the reconstructed tree.</h2><span id='topic+reconstructed.tree.fossils.objects'></span>

<h3>Description</h3>

<p>Note that for datasets containing extinct only samples (&amp; rho = 0) the ages output are scaled so that the youngest sample = 0.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>reconstructed.tree.fossils.objects(fossils, tree, rho = 1)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="reconstructed.tree.fossils.objects_+3A_fossils">fossils</code></td>
<td>
<p>Fossils object.</p>
</td></tr>
<tr><td><code id="reconstructed.tree.fossils.objects_+3A_tree">tree</code></td>
<td>
<p>Tree object.</p>
</td></tr>
<tr><td><code id="reconstructed.tree.fossils.objects_+3A_rho">rho</code></td>
<td>
<p>Extant species sampling probability. Default = 1, will be disregarded if fossils object already contains extant samples.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list containing the tree and fossil objects.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># simulate tree
birth = 0.1
death = 0.05
tips = 10
t = TreeSim::sim.bd.taxa(tips, 1, birth, death)[[1]]

# simulate fossils
f = sim.fossils.poisson(rate = 0.3, tree = t)

# simulate extant samples
f = sim.extant.samples(f, tree = t, rho = 0.5)

# plot the complete tree
plot(f,t)

# generate tree &amp; fossil objects corresponding to the reconstructed tree
out = reconstructed.tree.fossils.objects(f, t)
f.reconst = out$fossils
t.reconst = out$tree

# plot the reconstructed tree
plot(f.reconst, t.reconst)

</code></pre>

<hr>
<h2 id='remove.stem.fossils'>Remove fossil samples that occur in the stem</h2><span id='topic+remove.stem.fossils'></span>

<h3>Description</h3>

<p>Remove fossil samples that occur in the stem
</p>


<h3>Usage</h3>

<pre><code class='language-R'>remove.stem.fossils(fossils, tree)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="remove.stem.fossils_+3A_fossils">fossils</code></td>
<td>
<p>an object of class &quot;fossils&quot; that corresponds to fossil
occurrences for &quot;tree&quot;.</p>
</td></tr>
<tr><td><code id="remove.stem.fossils_+3A_tree">tree</code></td>
<td>
<p>an object of class &quot;Phylo&quot;.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an object of class &quot;fossils&quot;, containing only the fossil samples that
occur in the crown.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>t = TreeSim::sim.bd.taxa(10, 1, 0.1, 0.05)[[1]]
f = sim.fossils.poisson(0.1, t)
remove.stem.fossils(f, t)
</code></pre>

<hr>
<h2 id='remove.stem.lineages'>Remove stem lineages from a tree.</h2><span id='topic+remove.stem.lineages'></span>

<h3>Description</h3>

<p>Remove stem lineages from a tree.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>remove.stem.lineages(tree)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="remove.stem.lineages_+3A_tree">tree</code></td>
<td>
<p>an object of class &quot;Phylo&quot;.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an object of class &quot;Phylo&quot;, if stem lineages were found in the tree
these will be pruned; if not then the original tree is returned.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>t = TreeSim::sim.bd.taxa(10, 1, 0.1, 0.05)[[1]]
remove.stem.lineages(t)
</code></pre>

<hr>
<h2 id='sampled.tree.from.combined'>Removes all unsampled lineages from a combined tree.
Extinct tips are only sampled if they are fossils. With default settings all extant tips are sampled.</h2><span id='topic+sampled.tree.from.combined'></span>

<h3>Description</h3>

<p>Removes all unsampled lineages from a combined tree.
Extinct tips are only sampled if they are fossils. With default settings all extant tips are sampled.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sampled.tree.from.combined(tree, rho = 1, sampled_tips = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="sampled.tree.from.combined_+3A_tree">tree</code></td>
<td>
<p>Combined tree with fossils.</p>
</td></tr>
<tr><td><code id="sampled.tree.from.combined_+3A_rho">rho</code></td>
<td>
<p>Sampling probability of extant tips. Default 1, will be disregarded if sampled_tips is not null.</p>
</td></tr>
<tr><td><code id="sampled.tree.from.combined_+3A_sampled_tips">sampled_tips</code></td>
<td>
<p>List of tip labels corresponding to sampled extant tips.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Sampled tree with fossils.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># simulate tree
t = ape::rtree(6)

# simulate fossils
f = sim.fossils.poisson(rate = 2, tree = t)

# transform format
t2 = SAtree.from.fossils(t,f)$tree

# transform to sampled tree
t3 = sampled.tree.from.combined(t2)
plot(t3)
</code></pre>

<hr>
<h2 id='SAtree'>Tree with sampled ancestors represented as zero-length edges</h2><span id='topic+SAtree'></span>

<h3>Description</h3>

<p>Converts a phylo object to SAtree, without modification of tip labels.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>SAtree(tree, complete = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="SAtree_+3A_tree">tree</code></td>
<td>
<p>Phylo object.</p>
</td></tr>
<tr><td><code id="SAtree_+3A_complete">complete</code></td>
<td>
<p>Whether the tree is complete. Default TRUE. If the tree is not complete, then all fossil tips correspond to fossil samples, otherwise only sampled ancestors are considered samples.</p>
</td></tr>
</table>

<hr>
<h2 id='SAtree.from.fossils'>Transforms a tree and fossils dataframe to a combined SA tree.
Sampled ancestors are represented as tips on zero-length edges to maintain compatibility with the ape format.
Tip labels are set to &quot;species id&quot;_&quot;index&quot;, where the most recent tip of a given species receives index 1 and indices increase towards the past.</h2><span id='topic+SAtree.from.fossils'></span>

<h3>Description</h3>

<p>Transforms a tree and fossils dataframe to a combined SA tree.
Sampled ancestors are represented as tips on zero-length edges to maintain compatibility with the ape format.
Tip labels are set to &quot;species id&quot;_&quot;index&quot;, where the most recent tip of a given species receives index 1 and indices increase towards the past.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>SAtree.from.fossils(tree, fossils)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="SAtree.from.fossils_+3A_tree">tree</code></td>
<td>
<p>Phylo object.</p>
</td></tr>
<tr><td><code id="SAtree.from.fossils_+3A_fossils">fossils</code></td>
<td>
<p>Fossils object.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of 'tree', the SA tree integrating the fossils, and 'fossils', the fossils object updated with the tip label of each sample.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># simulate tree
t = ape::rtree(6)

# simulate fossils
f = sim.fossils.poisson(rate = 2, tree = t)

# transform format
t2 = SAtree.from.fossils(t,f)
plot(t2$tree)
</code></pre>

<hr>
<h2 id='sim.anagenetic.species'>Simulate anagenetic species on a taxonomy object</h2><span id='topic+sim.anagenetic.species'></span>

<h3>Description</h3>

<p>Simulate anagenetic species on a taxonomy object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sim.anagenetic.species(tree, species, lambda.a)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="sim.anagenetic.species_+3A_tree">tree</code></td>
<td>
<p>Phylo object.</p>
</td></tr>
<tr><td><code id="sim.anagenetic.species_+3A_species">species</code></td>
<td>
<p>Taxonomy object.</p>
</td></tr>
<tr><td><code id="sim.anagenetic.species_+3A_lambda.a">lambda.a</code></td>
<td>
<p>Rate of anagenetic speciation. Default = 0.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Object of class taxonomy.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+taxonomy">taxonomy</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>t = ape::rtree(10)
sp = sim.taxonomy(t, 1)
sim.anagenetic.species(t, sp, 0.1)

</code></pre>

<hr>
<h2 id='sim.cryptic.species'>Simulate cryptic species on a taxonomy object</h2><span id='topic+sim.cryptic.species'></span>

<h3>Description</h3>

<p>Simulate cryptic species on a taxonomy object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sim.cryptic.species(species, kappa)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="sim.cryptic.species_+3A_species">species</code></td>
<td>
<p>Taxonomy object.</p>
</td></tr>
<tr><td><code id="sim.cryptic.species_+3A_kappa">kappa</code></td>
<td>
<p>Probability that speciation event is cryptic.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class taxonomy. Note the origin or root can not be cryptic.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+taxonomy">taxonomy</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>t = ape::rtree(10)
sp = sim.taxonomy(t, 1)
sim.cryptic.species(sp, 0.5)

</code></pre>

<hr>
<h2 id='sim.extant.samples'>Include extant samples in the fossil object, with optional rho sampling.</h2><span id='topic+sim.extant.samples'></span>

<h3>Description</h3>

<p>Include extant samples in the fossil object, with optional rho sampling.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sim.extant.samples(fossils, tree = NULL, taxonomy = NULL, rho = 1, tol = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="sim.extant.samples_+3A_fossils">fossils</code></td>
<td>
<p>Fossils object.</p>
</td></tr>
<tr><td><code id="sim.extant.samples_+3A_tree">tree</code></td>
<td>
<p>Phylo object.</p>
</td></tr>
<tr><td><code id="sim.extant.samples_+3A_taxonomy">taxonomy</code></td>
<td>
<p>Taxonomy object.</p>
</td></tr>
<tr><td><code id="sim.extant.samples_+3A_rho">rho</code></td>
<td>
<p>Extant species sampling probability. Can be a single value or a vector. Vector entries will be applied to extant tips in the order in which they appear in the taxonomy object.</p>
</td></tr>
<tr><td><code id="sim.extant.samples_+3A_tol">tol</code></td>
<td>
<p>Rounding error tolerance for tip ages.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class fossils containing extant tip samples equal to the age of the tips (i.e. 0.0).
</p>


<h3>Examples</h3>

<pre><code class='language-R'># simulate tree
lambda = 0.1
mu = 0.05
tips = 8
t = TreeSim::sim.bd.taxa(tips, 1, lambda, mu)[[1]]

# simulate fossils
f = sim.fossils.poisson(0.5, t)

# simulate extant samples
f = sim.extant.samples(f, t, rho = 0.5)
plot(f, t)

</code></pre>

<hr>
<h2 id='sim.fbd.age'>sim.fbd.age: Simulating fossilized birth-death trees of a fixed age.</h2><span id='topic+sim.fbd.age'></span>

<h3>Description</h3>

<p>sim.fbd.age: Simulating fossilized birth-death trees of a fixed age.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sim.fbd.age(
  age,
  numbsim,
  lambda,
  mu,
  psi,
  frac = 1,
  mrca = FALSE,
  complete = FALSE,
  K = 0
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="sim.fbd.age_+3A_age">age</code></td>
<td>
<p>Time since origin / most recent common ancestor.</p>
</td></tr>
<tr><td><code id="sim.fbd.age_+3A_numbsim">numbsim</code></td>
<td>
<p>Number of trees to simulate.</p>
</td></tr>
<tr><td><code id="sim.fbd.age_+3A_lambda">lambda</code></td>
<td>
<p>Speciation rate.</p>
</td></tr>
<tr><td><code id="sim.fbd.age_+3A_mu">mu</code></td>
<td>
<p>Extinction rate.</p>
</td></tr>
<tr><td><code id="sim.fbd.age_+3A_psi">psi</code></td>
<td>
<p>Fossil sampling rate.</p>
</td></tr>
<tr><td><code id="sim.fbd.age_+3A_frac">frac</code></td>
<td>
<p>Extant sampling fraction: The actual (simulated) number of tips is n, but only n*frac tips are included in the sampled tree (incomplete sampling).</p>
</td></tr>
<tr><td><code id="sim.fbd.age_+3A_mrca">mrca</code></td>
<td>
<p>If mrca=FALSE: age is the time since origin. If mrca=TRUE: age is the time since the most recent common ancestor of all sampled tips.</p>
</td></tr>
<tr><td><code id="sim.fbd.age_+3A_complete">complete</code></td>
<td>
<p>whether to return the complete tree (with non-sampled lineages) or the reconstructed tree (with unsampled lineages removed).</p>
</td></tr>
<tr><td><code id="sim.fbd.age_+3A_k">K</code></td>
<td>
<p>If K = 0 (default), then lambda is constant. If K&gt;0, density-dependent speciation is assumed, with speciation rate = lambda(1-m/K) when there are m living species.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Array of 'numbsim' SAtrees with the time since origin / most recent common ancestor being 'age'. If the tree goes extinct or
no tips are sampled (only possible when mrca = FALSE), return value is '0'. If only one extant and no extinct tips are sampled, return value is '1'.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>age = 1
lambda = 2.0
mu = 0.5
psi = 0.6
numbsim = 2
if (requireNamespace("TreeSim", quietly = TRUE)) {
sim.fbd.age(age, numbsim, lambda, mu, psi)
}
</code></pre>

<hr>
<h2 id='sim.fbd.rateshift.taxa'>sim.fbd.rateshift.taxa: Simulating fossilized birth death trees incorporating rate shifts.</h2><span id='topic+sim.fbd.rateshift.taxa'></span>

<h3>Description</h3>

<p>sim.fbd.rateshift.taxa: Simulating fossilized birth death trees incorporating rate shifts.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sim.fbd.rateshift.taxa(n, numbsim, lambda, mu, psi, times, complete = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="sim.fbd.rateshift.taxa_+3A_n">n</code></td>
<td>
<p>Number of extant sampled tips.</p>
</td></tr>
<tr><td><code id="sim.fbd.rateshift.taxa_+3A_numbsim">numbsim</code></td>
<td>
<p>Number of trees to simulate.</p>
</td></tr>
<tr><td><code id="sim.fbd.rateshift.taxa_+3A_lambda">lambda</code></td>
<td>
<p>Vector of speciation rates, the rate in entry i is the speciation rate prior (ancestral) to time times[i].</p>
</td></tr>
<tr><td><code id="sim.fbd.rateshift.taxa_+3A_mu">mu</code></td>
<td>
<p>Vector of extinction rates, the rate in entry i is the extinction rate prior (ancestral) to time times[i].</p>
</td></tr>
<tr><td><code id="sim.fbd.rateshift.taxa_+3A_psi">psi</code></td>
<td>
<p>Vector of fossil sampling rates, the rate in entry i is the fossil sampling rate prior (ancestral) to time times[i].</p>
</td></tr>
<tr><td><code id="sim.fbd.rateshift.taxa_+3A_times">times</code></td>
<td>
<p>Vector of mass extinction and rate shift times. Time is 0 today and increasing going backwards in time. Specify the
vector as times[i]&lt;times[i+1]. times[1]=0 (today).</p>
</td></tr>
<tr><td><code id="sim.fbd.rateshift.taxa_+3A_complete">complete</code></td>
<td>
<p>whether to return the complete tree (with non-sampled lineages) or the reconstructed tree (with unsampled lineages removed).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>List of numbsim simulated SAtrees with n extant sampled tips.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>n = 10
numbsim = 1
if (requireNamespace("TreeSim", quietly = TRUE)) {
sim.fbd.rateshift.taxa(n, numbsim, lambda = c(2,1), mu = c(0,0.3), psi = c(1,0.1), times = c(0,0.3))
}
</code></pre>

<hr>
<h2 id='sim.fbd.taxa'>sim.fbd.taxa: Simulating fossilized birth-death trees on a fixed number of extant taxa.</h2><span id='topic+sim.fbd.taxa'></span>

<h3>Description</h3>

<p>sim.fbd.taxa: Simulating fossilized birth-death trees on a fixed number of extant taxa.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sim.fbd.taxa(n, numbsim, lambda, mu, psi, frac = 1, complete = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="sim.fbd.taxa_+3A_n">n</code></td>
<td>
<p>Number of extant sampled tips.</p>
</td></tr>
<tr><td><code id="sim.fbd.taxa_+3A_numbsim">numbsim</code></td>
<td>
<p>Number of trees to simulate.</p>
</td></tr>
<tr><td><code id="sim.fbd.taxa_+3A_lambda">lambda</code></td>
<td>
<p>Speciation rate.</p>
</td></tr>
<tr><td><code id="sim.fbd.taxa_+3A_mu">mu</code></td>
<td>
<p>Extinction rate.</p>
</td></tr>
<tr><td><code id="sim.fbd.taxa_+3A_psi">psi</code></td>
<td>
<p>Fossil sampling rate.</p>
</td></tr>
<tr><td><code id="sim.fbd.taxa_+3A_frac">frac</code></td>
<td>
<p>Extant sampling fraction. When complete = FALSE, the actual (simulated) number of extant tips is n/frac, but only n tips are included
in the result (incomplete sampling). When complete = TRUE: all unsampled lineages are included, i.e. the final tree has n/frac extant tips.</p>
</td></tr>
<tr><td><code id="sim.fbd.taxa_+3A_complete">complete</code></td>
<td>
<p>whether to return the complete tree (with non-sampled lineages) or the reconstructed tree (with unsampled lineages removed).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>List of numbsim simulated SAtrees with n extant sampled tips.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>n = 10
lambda = 2.0
mu = 0.5
psi = 0.6
numbsim = 2
if (requireNamespace("TreeSim", quietly = TRUE)) {
sim.fbd.taxa(n, numbsim, lambda, mu, psi)
}
</code></pre>

<hr>
<h2 id='sim.fossils.environment'>Simulate fossils under an environment-dependent model of preservation (Holland, 1995)</h2><span id='topic+sim.fossils.environment'></span>

<h3>Description</h3>

<p>This function uses a three parameter Gaussian model to simulate non-uniform fossil recovery along a specified phylogeny.
Preservation varies with respect to water depth, which is a useful for proxy for changes in the depositional environment.
The per interval probability of sampling is </p>
<p style="text-align: center;"><code class="reqn">P(collection) = PA e ^ (-(d - PD)^2 / 2*DT^2 ) </code>
</p>

<p>where <em>PA</em> is species peak abundance, <em>PD</em> is preferred depth, <em>DT</em> is depth tolerance and <em>d</em> is current water depth.
<em>PD</em> is the depth at which the species is most likely to be found and is equivalent to the mean of the distribution.
<em>PA</em> is the probability of sampling an occurrence at this depth.
<em>DT</em> is the potential of a species to be found at a range of depths and is equivalent to the standard deviation.
Although here fossil recovery is described with respect to water depth, the model could be applied in the context of any environmental gradient. <br /> <br />
The model uses a probability of collecting a fossil within a given interval, rather than a rate.
</p>
<p>To simulate discrete fossil sampling events and times within each interval we need to convert the probability into a rate
(<code>use.rates = TRUE</code>). This is done using the formula </p>
<p style="text-align: center;"><code class="reqn">rate = -ln(1 - P(collection)/t) </code>
</p>
<p> where <em>t</em> is the interval length.
One caveat of this approach is that the model cannot use a probability of 1, as it would correspond to rate = infinity.
In this instance we use an approximation for probabilities = 1 (e.g. <code>pr.1.approx = 0.999</code>). <br /> <br />
</p>
<p>Non-uniform interval ages can be specified as a vector (<code>interval.ages</code>) or a uniform set of interval ages can be specified using
maximum interval age (<code>max.age</code>) and the number of intervals (<code>strata</code>), where interval length <code class="reqn">= max.age/strata</code>. <br /> <br />
A vector of values can be specified for the model parameters <em>PA</em>, <em>PD</em> and <em>DT</em> to allow for variation across lineages.
If a vector is provided, each entry will apply to each unique species in the order in which they appear in the taxonomy object (if taxonomy is provided),
or to each unique edge in the order in which they appear in the tree object.
If the tree object has a root edge (<code>root.edge</code>), the first entry in the vector will apply to this edge. <br /> <br />
Fossils can be simulated for a phylo (<code>tree</code>) or taxonomy (<code>taxonomy</code>) object.
If both are specified, the function uses taxonomy.
If no taxonomic information is provided, the function assumes all speciation is symmetric (i.e. bifurcating, <code>beta = 1</code>).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sim.fossils.environment(
  tree = NULL,
  taxonomy = NULL,
  interval.ages = NULL,
  max.age = NULL,
  strata = NULL,
  proxy.data = NULL,
  PD = 0.5,
  DT = 0.5,
  PA = 0.5,
  root.edge = TRUE,
  use.rates = FALSE,
  pr.1.approx = 0.999,
  use.exact.times = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="sim.fossils.environment_+3A_tree">tree</code></td>
<td>
<p>Phylo object.</p>
</td></tr>
<tr><td><code id="sim.fossils.environment_+3A_taxonomy">taxonomy</code></td>
<td>
<p>Taxonomy object.</p>
</td></tr>
<tr><td><code id="sim.fossils.environment_+3A_interval.ages">interval.ages</code></td>
<td>
<p>Vector of stratigraphic interval ages, starting with the minimum age of the youngest interval and ending with the maximum age of the oldest interval.</p>
</td></tr>
<tr><td><code id="sim.fossils.environment_+3A_max.age">max.age</code></td>
<td>
<p>Maximum age of the oldest stratigraphic interval or age at the base of the basin.</p>
</td></tr>
<tr><td><code id="sim.fossils.environment_+3A_strata">strata</code></td>
<td>
<p>Number of stratigraphic intervals.</p>
</td></tr>
<tr><td><code id="sim.fossils.environment_+3A_proxy.data">proxy.data</code></td>
<td>
<p>Vector of relative water depth or other proxy data. The first number corresponds to the youngest interval. The length of the vector should be 1 less than the length of interval.ages.</p>
</td></tr>
<tr><td><code id="sim.fossils.environment_+3A_pd">PD</code></td>
<td>
<p>Preferred depth parameter value or a vector of values.</p>
</td></tr>
<tr><td><code id="sim.fossils.environment_+3A_dt">DT</code></td>
<td>
<p>Depth tolerance parameter value or a vector of values.</p>
</td></tr>
<tr><td><code id="sim.fossils.environment_+3A_pa">PA</code></td>
<td>
<p>Peak abundance parameter value or a vector of values.</p>
</td></tr>
<tr><td><code id="sim.fossils.environment_+3A_root.edge">root.edge</code></td>
<td>
<p>If TRUE include the root edge. Default = TRUE.</p>
</td></tr>
<tr><td><code id="sim.fossils.environment_+3A_use.rates">use.rates</code></td>
<td>
<p>If TRUE convert per interval sampling probability into a per interval Poisson rate. Default = FALSE.</p>
</td></tr>
<tr><td><code id="sim.fossils.environment_+3A_pr.1.approx">pr.1.approx</code></td>
<td>
<p>Value used to approximate sampling probabilities = 1 when use.rates = TRUE.</p>
</td></tr>
<tr><td><code id="sim.fossils.environment_+3A_use.exact.times">use.exact.times</code></td>
<td>
<p>If TRUE use exact sampling times. If FALSE <code>hmin</code> and <code>hmax</code> will equal the start and end times of the corresponding interval. Default = TRUE.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class fossils.
</p>


<h3>References</h3>

<p>Holland, S.M. 1995. The stratigraphic distribution of fossils. Paleobiology 21: 92-109.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+sim.fossils.poisson">sim.fossils.poisson</a></code>, <code><a href="#topic+sim.fossils.intervals">sim.fossils.intervals</a></code>, <code><a href="#topic+sim.trait.values">sim.trait.values</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># simulate tree
t = ape::rtree(6)

# assign a max age based on tree height
max.age = tree.max(t)

# generate water depth profile
strata = 7
wd = sim.gradient(strata)

# simulate fossils using tree &amp; max.age and strata
f = sim.fossils.environment(t, max.age = max.age, strata = strata,
proxy.data = wd, PD = 0.5, DT = 1, PA = 1)
plot(f, t, show.proxy = TRUE, proxy.data = wd, strata = strata, show.strata = TRUE)

# simulate fossils using taxonomy &amp; interval.ages
s = sim.taxonomy(t, 0.1, 0.1, 1)
times = seq(0, max.age, length.out = strata + 1)
f = sim.fossils.environment(taxonomy = s, interval.ages = times,
     proxy.data = wd, PD = 0.5, DT = 1, PA = 1)
plot(f, t, strata = strata, binned = TRUE)

# simulate fossils with variable preservation across lineages
dist = function() {runif(1)}
PD = sim.trait.values(1, taxonomy = s, model = "independent", dist = dist,
                     change.pr = 0.1)
f = sim.fossils.environment(taxonomy = s, interval.ages = times,
     proxy.data = wd, PD = PD, DT = 1, PA = 1)
plot(f, t, strata = strata, binned = TRUE)

</code></pre>

<hr>
<h2 id='sim.fossils.intervals'>Simulate fossils under a non-uniform model of preservation for a given set of consecutive time intervals</h2><span id='topic+sim.fossils.intervals'></span>

<h3>Description</h3>

<p>Intervals can be specified by specifying the interval boundaries using <code>interval.ages</code> or specifying both <code>max.age</code> and <code>strata</code>.
In the second scenario all intervals will be of equal length.
Preservation can be specified using <code>rates</code>, which represent the rates of a Poisson process in each interval,
or <code>probabilities</code>, which represent the probabilities of sampling per interval.
When using <code>probabilities</code>, at most one fossil per species will be sampled per interval. <br /> <br />
Fossils can be simulated for a phylo (<code>tree</code>) or taxonomy (<code>taxonomy</code>) object.
If both are specified, the function uses taxonomy.
If no taxonomic information is provided, the function assumes all speciation is symmetric (i.e. bifurcating, <code>beta = 1</code>).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sim.fossils.intervals(
  tree = NULL,
  taxonomy = NULL,
  fossils = NULL,
  interval.ages = NULL,
  max.age = NULL,
  strata = NULL,
  probabilities = NULL,
  rates = NULL,
  ignore.taxonomy = FALSE,
  root.edge = TRUE,
  use.exact.times = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="sim.fossils.intervals_+3A_tree">tree</code></td>
<td>
<p>Phylo object.</p>
</td></tr>
<tr><td><code id="sim.fossils.intervals_+3A_taxonomy">taxonomy</code></td>
<td>
<p>Taxonomy object.</p>
</td></tr>
<tr><td><code id="sim.fossils.intervals_+3A_fossils">fossils</code></td>
<td>
<p>Append fossils to to an existing fossils object.</p>
</td></tr>
<tr><td><code id="sim.fossils.intervals_+3A_interval.ages">interval.ages</code></td>
<td>
<p>Vector of stratigraphic interval ages, starting with the minimum age of the youngest interval and ending with the maximum age of the oldest interval.</p>
</td></tr>
<tr><td><code id="sim.fossils.intervals_+3A_max.age">max.age</code></td>
<td>
<p>Maximum age of the oldest stratigraphic interval.</p>
</td></tr>
<tr><td><code id="sim.fossils.intervals_+3A_strata">strata</code></td>
<td>
<p>Number of stratigraphic intervals.</p>
</td></tr>
<tr><td><code id="sim.fossils.intervals_+3A_probabilities">probabilities</code></td>
<td>
<p>Probability of sampling/preservation in each interval. The number of probabilities should match the number of intervals and the first entry should correspond to youngest interval.</p>
</td></tr>
<tr><td><code id="sim.fossils.intervals_+3A_rates">rates</code></td>
<td>
<p>Poisson sampling rate for each interval. The number of rates should match the number of intervals and the first entry should correspond to youngest interval.</p>
</td></tr>
<tr><td><code id="sim.fossils.intervals_+3A_ignore.taxonomy">ignore.taxonomy</code></td>
<td>
<p>Ignore species taxonomy (returns sp = NA). Default = FALSE.</p>
</td></tr>
<tr><td><code id="sim.fossils.intervals_+3A_root.edge">root.edge</code></td>
<td>
<p>If TRUE include the root edge. Default = TRUE.</p>
</td></tr>
<tr><td><code id="sim.fossils.intervals_+3A_use.exact.times">use.exact.times</code></td>
<td>
<p>If TRUE use exact sampling times. If FALSE <code>hmin</code> and <code>hmax</code> will equal the start and end times of the corresponding interval. Default = TRUE.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class fossils.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+sim.fossils.poisson">sim.fossils.poisson</a></code>, <code><a href="#topic+sim.fossils.environment">sim.fossils.environment</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># simulate tree
t = ape::rtree(6)

# assign a max age based on tree height
max.age = tree.max(t)

# simulate fossils using max.age and strata &amp; probabilities
strata = 4
probability = rep(0.7, 4)
f = sim.fossils.intervals(t, max.age = max.age, strata = strata, probabilities = probability)
plot(f, t, strata = strata, show.strata = TRUE)

# simulate fossils using interval.ages &amp; rates
times = c(0, sort(runif(3, min = 0, max = max.age)), max.age)
rates = c(5, 0, 5, 0)
f = sim.fossils.intervals(t, interval.ages = times, rates = rates)
plot(f, t, interval.ages = times, show.strata = TRUE)

# simulate fossils using taxonomy
s = sim.taxonomy(t, 0.1, 0.1, 1)
f = sim.fossils.intervals(taxonomy = s, interval.ages = times, rates = rates)
plot(f, t, interval.ages = times, show.strata = TRUE)

# append fossils to an existing fossils object
new.rates = rates * 2
f2 = sim.fossils.intervals(taxonomy = s, fossils = f, interval.ages = times, rates = new.rates)

</code></pre>

<hr>
<h2 id='sim.fossils.poisson'>Simulate fossils under a Poisson sampling model</h2><span id='topic+sim.fossils.poisson'></span>

<h3>Description</h3>

<p>Fossils can be simulated for a phylo (<code>tree</code>) or taxonomy (<code>taxonomy</code>) object.
If both are specified, the function uses taxonomy.
If no taxonomic information is provided, the function assumes all speciation is symmetric (i.e. bifurcating, <code>beta = 1</code>).
A vector of rates can be specified to allow for rate variation across lineages.
If a vector is provided, each entry will apply to each unique species in the order in which they appear in the taxonomy object (if taxonomy is provided),
or to each unique edge in the order in which they appear in the tree object.
If the tree object has a root edge (<code>root.edge</code>), the first entry in the rates vector should correspond to this edge.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sim.fossils.poisson(
  rate,
  tree = NULL,
  taxonomy = NULL,
  fossils = NULL,
  ignore.taxonomy = FALSE,
  root.edge = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="sim.fossils.poisson_+3A_rate">rate</code></td>
<td>
<p>A single Poisson sampling rate or a vector of rates.</p>
</td></tr>
<tr><td><code id="sim.fossils.poisson_+3A_tree">tree</code></td>
<td>
<p>Phylo object.</p>
</td></tr>
<tr><td><code id="sim.fossils.poisson_+3A_taxonomy">taxonomy</code></td>
<td>
<p>Taxonomy object.</p>
</td></tr>
<tr><td><code id="sim.fossils.poisson_+3A_fossils">fossils</code></td>
<td>
<p>Append fossils to to an existing fossils object.</p>
</td></tr>
<tr><td><code id="sim.fossils.poisson_+3A_ignore.taxonomy">ignore.taxonomy</code></td>
<td>
<p>Ignore species taxonomy (returns sp = NA). Default = FALSE.</p>
</td></tr>
<tr><td><code id="sim.fossils.poisson_+3A_root.edge">root.edge</code></td>
<td>
<p>If TRUE include the root edge. Default = TRUE.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class fossils.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+sim.fossils.intervals">sim.fossils.intervals</a></code>, <code><a href="#topic+sim.fossils.environment">sim.fossils.environment</a></code>, <code><a href="#topic+sim.trait.values">sim.trait.values</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># simulate tree
t = ape::rtree(6)

# simulate fossils using the tree
rate = 2
f = sim.fossils.poisson(rate, tree = t)
plot(f, t)

# simulate fossils using taxonomy
s = sim.taxonomy(t, 0.5, 1, 0.5)
f = sim.fossils.poisson(rate, taxonomy = s)
plot(f, t)

# simulate fossils with autocorrelated rate variation across lineages
rates = sim.trait.values(init = rate, taxonomy = s, v = 1)
f = sim.fossils.poisson(rates, taxonomy = s)
plot(f, t)

# append fossils to an existing fossils object
rate = 1
f1 = sim.fossils.poisson(rate, tree = t)
plot(f1, t)
rate = 2
f2 = sim.fossils.poisson(rate, tree = t, fossils = f1)
plot(f2, t)
f3 = sim.fossils.poisson(rate, tree = t, fossils = f2, ignore.taxonomy = TRUE)
plot(f3, t, show.unknown = TRUE)

</code></pre>

<hr>
<h2 id='sim.gradient'>Simulate an environmental gradient</h2><span id='topic+sim.gradient'></span>

<h3>Description</h3>

<p>Function returns a vector using the sine wave function <code class="reqn">y = depth*sin(cycles*pi*(x-1/4))</code>
for a given set of intervals.
This vector can be used as a gradient to simulate fossils under an environment-dependent model of fossil recovery using the
function <code>sim.fossils.environment</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sim.gradient(strata, depth = 2, cycles = 2)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="sim.gradient_+3A_strata">strata</code></td>
<td>
<p>Number of stratigraphic intervals.</p>
</td></tr>
<tr><td><code id="sim.gradient_+3A_depth">depth</code></td>
<td>
<p>Maximum water depth.</p>
</td></tr>
<tr><td><code id="sim.gradient_+3A_cycles">cycles</code></td>
<td>
<p>Number of cycles (e.g. transgressions and regressions).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>vector of sampled water depths.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+sim.fossils.environment">sim.fossils.environment</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>strata = 100
wd = sim.gradient(strata)
plot(wd, type="l")
</code></pre>

<hr>
<h2 id='sim.interval.ages'>Reassign fossil ages to user-specified stratigraphic intervals</h2><span id='topic+sim.interval.ages'></span>

<h3>Description</h3>

<p>Reassign exact fossil ages using the minimum and maximum ages of a set of stratigraphic intervals.
If <code>use.species.ages = TRUE</code> the function will respect species durations and will not
return minimum and maximum bounds that may be younger or older than the species durations.
This requires supplying a phylo or taxonomy object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sim.interval.ages(
  fossils,
  tree = NULL,
  taxonomy = NULL,
  interval.ages = NULL,
  max.age = NULL,
  strata = NULL,
  use.species.ages = FALSE,
  root.edge = TRUE,
  sim.extant = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="sim.interval.ages_+3A_fossils">fossils</code></td>
<td>
<p>Fossil object.</p>
</td></tr>
<tr><td><code id="sim.interval.ages_+3A_tree">tree</code></td>
<td>
<p>Phylo object.</p>
</td></tr>
<tr><td><code id="sim.interval.ages_+3A_taxonomy">taxonomy</code></td>
<td>
<p>Taxonomy object.</p>
</td></tr>
<tr><td><code id="sim.interval.ages_+3A_interval.ages">interval.ages</code></td>
<td>
<p>Vector of stratigraphic interval ages, starting with the minimum age of the youngest interval and ending with the maximum age of the oldest interval.</p>
</td></tr>
<tr><td><code id="sim.interval.ages_+3A_max.age">max.age</code></td>
<td>
<p>Maximum age of the oldest stratigraphic interval.</p>
</td></tr>
<tr><td><code id="sim.interval.ages_+3A_strata">strata</code></td>
<td>
<p>Number of stratigraphic intervals.</p>
</td></tr>
<tr><td><code id="sim.interval.ages_+3A_use.species.ages">use.species.ages</code></td>
<td>
<p>If TRUE reassigned fossil ages will respect the speciation times. Default = FALSE.</p>
</td></tr>
<tr><td><code id="sim.interval.ages_+3A_root.edge">root.edge</code></td>
<td>
<p>If TRUE include root edge.</p>
</td></tr>
<tr><td><code id="sim.interval.ages_+3A_sim.extant">sim.extant</code></td>
<td>
<p>If TRUE simulate age uncertainty for extant samples as well, default FALSE.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class fossils.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># simulate tree
t = ape::rtree(8)

# simulate fossils
rate = 2
f = sim.fossils.poisson(rate, t)
plot(f, t)

# assign a max age based on tree height
max.age = tree.max(t)

# define intervals
times = seq(0, max.age, length.out = 5)

# reassign ages
f = sim.interval.ages(f, t, interval.ages = times)

# plot output
plot(f, t, interval.ages = times)

</code></pre>

<hr>
<h2 id='sim.taxonomy'>Simulate taxonomy</h2><span id='topic+sim.taxonomy'></span>

<h3>Description</h3>

<p>Simulate a taxonomy object relating species identity to a phylo object under a mixed model of speciation.
Anagenetic and cryptic species can also be added later using the <code>sim.anagenetic.species</code> and <code>sim.cryptic.species</code> functions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sim.taxonomy(tree, beta = 0, lambda.a = 0, kappa = 0, root.edge = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="sim.taxonomy_+3A_tree">tree</code></td>
<td>
<p>Phylo object.</p>
</td></tr>
<tr><td><code id="sim.taxonomy_+3A_beta">beta</code></td>
<td>
<p>Probability of bifurcating speciation. Default = 0.</p>
</td></tr>
<tr><td><code id="sim.taxonomy_+3A_lambda.a">lambda.a</code></td>
<td>
<p>Rate of anagenetic speciation. Default = 0.</p>
</td></tr>
<tr><td><code id="sim.taxonomy_+3A_kappa">kappa</code></td>
<td>
<p>Probability that speciation event is cryptic. Default = 0.</p>
</td></tr>
<tr><td><code id="sim.taxonomy_+3A_root.edge">root.edge</code></td>
<td>
<p>If TRUE include root edge. Default = TRUE.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class taxonomy.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+taxonomy">taxonomy</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>t = ape::rtree(10)
sim.taxonomy(t, 0.5, 0.1, 0.5)

</code></pre>

<hr>
<h2 id='sim.tip.samples'>Include extant and extinct tip samples in the fossil object, with optional rho sampling.</h2><span id='topic+sim.tip.samples'></span>

<h3>Description</h3>

<p>Include extant and extinct tip samples in the fossil object, with optional rho sampling.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sim.tip.samples(fossils, tree, taxonomy = NULL, rho = 1)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="sim.tip.samples_+3A_fossils">fossils</code></td>
<td>
<p>Fossils object.</p>
</td></tr>
<tr><td><code id="sim.tip.samples_+3A_tree">tree</code></td>
<td>
<p>Phylo object.</p>
</td></tr>
<tr><td><code id="sim.tip.samples_+3A_taxonomy">taxonomy</code></td>
<td>
<p>Taxonomy object.</p>
</td></tr>
<tr><td><code id="sim.tip.samples_+3A_rho">rho</code></td>
<td>
<p>Tip sampling probability. Can be a single value or a vector. Vector entries will be applied to extant tips in the order in which they appear in the taxonomy object.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class fossils containing extant or extinct tip samples equal to the age of the tips.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># simulate tree
t = ape::rtree(6)

# simulate fossils
f = sim.fossils.poisson(2, t)

# simulate tip samples
f = sim.tip.samples(f, t, rho = 0.5)
plot(f, t)

</code></pre>

<hr>
<h2 id='sim.trait.values'>Simulate trait values with variation across lineages</h2><span id='topic+sim.trait.values'></span>

<h3>Description</h3>

<p>Fossil recovery rates or other parameter values can be simulated for a phylo (<code>tree</code>) or taxonomy (<code>taxonomy</code>) object.
Under the <code>autocorrelated</code> model, trait values evolve along lineages according to a Brownian motion process, where the strength of the relationship between ancestor and descendant values is determined by the parameter <code class="reqn">\nu</code> (<code>v</code>).
If <code class="reqn">\nu</code> is small values will be more similar between ancestor and descendants, and if <code class="reqn">\nu</code> is zero all trait values will be equal.
For a given species <code class="reqn">i</code> with ancestor <code class="reqn">j</code>, a new trait value <code class="reqn">\kappa_i</code> is drawn from a lognormal distribution with
</p>
<p style="text-align: center;"><code class="reqn">\kappa_i ~ LN( ln([\kappa_j] - (\sigma^2/2), \sigma)</code>
</p>

<p>where <code class="reqn">\sigma = \nu * t_i</code> and <code class="reqn">t_i</code> is the lineage duration of the species.
This fossil recovery model is described in Heath et al. (2014) and is equivalent to the autocorrelated relaxed clock model described in Kishino et al. (2001).
Under the <code>BM</code> and <code>OU</code> models traits are simulated under a standard Brownian motion or Ornstein-Uhlenbeck process with rate parameter <code class="reqn">\nu</code> (<code>v</code>).
The OU model has the additional parameter <code>alpha</code>, which determines the strength with which trait values are attracted to the mean. Note the <code>init</code> argument will specify both the value at the root and the mean of the process under the OU model.
Under the <code>independent</code> model a new trait value is drawn for each species from any valid user-specified distribution (<code>dist</code>).
<code>change.pr</code> is the probability that a trait value will change at each speciation event.
If <code>change.pr = 1</code> trait values will be updated at every speciation events.
Finally, traits can be simulated under the standard Lewis Mk model (<code>Mk</code>), with symmetric rates of change. The rate is specified using <code>v</code> and number of states using <code>k</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sim.trait.values(
  init = 1,
  tree = NULL,
  taxonomy = NULL,
  root.edge = TRUE,
  model = "autocorrelated",
  v = 0.01,
  alpha = 0.1,
  min.value = -Inf,
  max.value = Inf,
  dist = function() {
     runif(1, 0, 2)
 },
  change.pr = 1,
  k = 2
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="sim.trait.values_+3A_init">init</code></td>
<td>
<p>Initial value at the origin or root of the phylo or taxonomy object. Default = 1.</p>
</td></tr>
<tr><td><code id="sim.trait.values_+3A_tree">tree</code></td>
<td>
<p>Phylo object.</p>
</td></tr>
<tr><td><code id="sim.trait.values_+3A_taxonomy">taxonomy</code></td>
<td>
<p>Taxonomy object.</p>
</td></tr>
<tr><td><code id="sim.trait.values_+3A_root.edge">root.edge</code></td>
<td>
<p>If TRUE include the root edge. Default = TRUE.</p>
</td></tr>
<tr><td><code id="sim.trait.values_+3A_model">model</code></td>
<td>
<p>Model used to simulate rate variation across lineages. Options include &quot;autocorrelated&quot; (default), &quot;BM&quot; (Brownian motion), &quot;OU&quot; (Ornstein-Uhlenbeck), &quot;independent&quot; or the Lewis &quot;Mk&quot; model.</p>
</td></tr>
<tr><td><code id="sim.trait.values_+3A_v">v</code></td>
<td>
<p>Brownian motion parameter <code class="reqn">v</code> used in the autocorrelated, BM and OU models. Or rate change under the Mk model. Default = 0.01.</p>
</td></tr>
<tr><td><code id="sim.trait.values_+3A_alpha">alpha</code></td>
<td>
<p>Ornstein-Uhlenbeck parameter <code class="reqn">alpha</code>. Determines the strength with which trait values are pulled back towards the mean.</p>
</td></tr>
<tr><td><code id="sim.trait.values_+3A_min.value">min.value</code></td>
<td>
<p>Min trait value allowed under the BM and OU models. Default = -Inf.</p>
</td></tr>
<tr><td><code id="sim.trait.values_+3A_max.value">max.value</code></td>
<td>
<p>Max trait value allowed under the BM and OU models. Default = Inf.</p>
</td></tr>
<tr><td><code id="sim.trait.values_+3A_dist">dist</code></td>
<td>
<p>Distribution of trait values used to draw new values under the &quot;independent&quot; model. This parameter is ignored if <code>model = "autocorrealted"</code>. The default is a uniform distribution with <em>U(0, 2)</em>. The distribution function must return a single value.</p>
</td></tr>
<tr><td><code id="sim.trait.values_+3A_change.pr">change.pr</code></td>
<td>
<p>Probability that trait values change at speciation events. Default = 1.</p>
</td></tr>
<tr><td><code id="sim.trait.values_+3A_k">k</code></td>
<td>
<p>Number of states used for the Mk model. Default = 2.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector of parameter values.
Values are output for each species in the order in which they appear in the taxonomy object (if taxonomy was provided) or for each edge in the order in which they appear in the tree object.
If the tree object has a root edge (<code>root.edge</code>), the first entry in the vector will correspond to this edge.
</p>


<h3>References</h3>

<p>Heath et al. 2014. The fossilized birth-death process for coherent calibration of divergence-time estimates. PNAS 111:E2957-E2966.<br />
Kishino et al. 2001. Performance of a divergence time estimation method under a probabilistic model of rate evolution MBE 18:352-361.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># simulate tree
t = ape::rtree(6)

# simulate taxonomy
s = sim.taxonomy(t, 0.5, 1, 0.5)

# simulate rates under the autocorrelated trait values model
rate = 2
rates = sim.trait.values(rate, taxonomy = s, v = 1)
f = sim.fossils.poisson(rates, taxonomy = s)
plot(f, t)

# simulate rates under the independent trait values model
dist = function() { rlnorm(1, log(rate), 1) }
rates = sim.trait.values(rate, taxonomy = s, model = "independent", dist = dist)
f = sim.fossils.poisson(rates, taxonomy = s)
plot(f, t)

# simulate rates under the independent trait values model with infrequent changes
rates = sim.trait.values(rate, taxonomy = s, model = "independent",
                        dist = dist, change.pr = 0.1)
f = sim.fossils.poisson(rates, taxonomy = s)
plot(f, t)

# simulate traits under Brownian motion and convert into rates
traits = sim.trait.values(0, taxonomy = s, model = "BM", v = 2)
# function for translating states into rates
translate.states = function(traits, low, high) sapply(traits, function(t) if(t &lt; 0) low else high)
# sampling rates
low = 0.1
high = 2
rates = translate.states(traits, low, high)
f = sim.fossils.poisson(rates, taxonomy = s)
plot(f, tree = t)

</code></pre>

<hr>
<h2 id='species.end'>Find a species' end (i.e extinction) time from a taxonomy object</h2><span id='topic+species.end'></span>

<h3>Description</h3>

<p>Find a species' end (i.e extinction) time from a taxonomy object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>species.end(species, taxonomy)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="species.end_+3A_species">species</code></td>
<td>
<p>Species id (as written in <code>taxonomy$sp</code>).</p>
</td></tr>
<tr><td><code id="species.end_+3A_taxonomy">taxonomy</code></td>
<td>
<p>Taxonomy object.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>End time.
</p>

<hr>
<h2 id='species.start'>Find a species' start (i.e speciation) time from a taxonomy object</h2><span id='topic+species.start'></span>

<h3>Description</h3>

<p>Find a species' start (i.e speciation) time from a taxonomy object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>species.start(species, taxonomy)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="species.start_+3A_species">species</code></td>
<td>
<p>Species id (as written in <code>taxonomy$sp</code>).</p>
</td></tr>
<tr><td><code id="species.start_+3A_taxonomy">taxonomy</code></td>
<td>
<p>Taxonomy object.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Start time.
</p>

<hr>
<h2 id='subsample.fossils.oldest'>Obtain a subsample of fossil occurrences containing the oldest fossil sample
in each node of the tree.</h2><span id='topic+subsample.fossils.oldest'></span>

<h3>Description</h3>

<p>Obtain a subsample of fossil occurrences containing the oldest fossil sample
in each node of the tree.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>subsample.fossils.oldest(fossils, tree, complete = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="subsample.fossils.oldest_+3A_fossils">fossils</code></td>
<td>
<p>an object of class &quot;fossils&quot; that corresponds to fossil
occurrences.</p>
</td></tr>
<tr><td><code id="subsample.fossils.oldest_+3A_tree">tree</code></td>
<td>
<p>an object of class &quot;Phylo&quot;, representing the tree upon which the
fossil occurrences were simulated.</p>
</td></tr>
<tr><td><code id="subsample.fossils.oldest_+3A_complete">complete</code></td>
<td>
<p>logical, if TRUE the oldest sample from each clade in the
complete tree is returned, if FALSE the oldest sample from each clade in
the extant only counterpart tree is returned.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an object of class &quot;fossils&quot; containing the subsampled fossil
occurrences.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>t = TreeSim::sim.bd.taxa(10, 1, 0.1, 0.05)[[1]]
f = sim.fossils.poisson(0.1, t, root.edge = FALSE)
subsample.fossils.oldest(f, t, complete = FALSE)
</code></pre>

<hr>
<h2 id='subsample.fossils.oldest.and.youngest'>Obtain a subsample of fossil occurrences containing the oldest and youngest
fossil sample found at each node of the tree.</h2><span id='topic+subsample.fossils.oldest.and.youngest'></span>

<h3>Description</h3>

<p>Obtain a subsample of fossil occurrences containing the oldest and youngest
fossil sample found at each node of the tree.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>subsample.fossils.oldest.and.youngest(fossils, tree, complete = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="subsample.fossils.oldest.and.youngest_+3A_fossils">fossils</code></td>
<td>
<p>an object of class &quot;fossils&quot; that corresponds to fossil
occurrences.</p>
</td></tr>
<tr><td><code id="subsample.fossils.oldest.and.youngest_+3A_tree">tree</code></td>
<td>
<p>an object of class &quot;Phylo&quot;, representing the tree upon which the
fossil occurrences were simulated.</p>
</td></tr>
<tr><td><code id="subsample.fossils.oldest.and.youngest_+3A_complete">complete</code></td>
<td>
<p>logical, if TRUE the oldest and youngest sample from each
clade in the complete tree is returned, if FALSE the oldest and youngest
sample from each clade in the extant only counterpart tree is returned.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an object of class &quot;fossils&quot; containing the subsampled fossil
occurrences.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>t = TreeSim::sim.bd.taxa(10, 1, 0.1, 0.05)[[1]]
f = sim.fossils.poisson(0.1, t, root.edge = FALSE)
subsample.fossils.oldest.and.youngest(f, t, complete = FALSE)
</code></pre>

<hr>
<h2 id='subsample.fossils.uniform'>Obtain a uniform random sample of fossil occurrences.</h2><span id='topic+subsample.fossils.uniform'></span>

<h3>Description</h3>

<p>Obtain a uniform random sample of fossil occurrences.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>subsample.fossils.uniform(fossils, proportion)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="subsample.fossils.uniform_+3A_fossils">fossils</code></td>
<td>
<p>an object of class &quot;fossils&quot; that corresponds to fossil
occurrences.</p>
</td></tr>
<tr><td><code id="subsample.fossils.uniform_+3A_proportion">proportion</code></td>
<td>
<p>the proportion of all fossil samples to return in the
subsample.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an object of class &quot;fossils&quot; containing the subsampled fossil
occurrences.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>t = TreeSim::sim.bd.taxa(10, 1, 0.1, 0.05)[[1]]
f = sim.fossils.poisson(0.1, t, root.edge = FALSE)
subsample.fossils.uniform(f, 0.5)
</code></pre>

<hr>
<h2 id='subsample.fossils.youngest'>Obtain a subsample of fossil occurrences containing the youngest fossil
sample in each node of the tree.</h2><span id='topic+subsample.fossils.youngest'></span>

<h3>Description</h3>

<p>Obtain a subsample of fossil occurrences containing the youngest fossil
sample in each node of the tree.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>subsample.fossils.youngest(fossils, tree, complete = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="subsample.fossils.youngest_+3A_fossils">fossils</code></td>
<td>
<p>an object of class &quot;fossils&quot; that corresponds to fossil
occurrences.</p>
</td></tr>
<tr><td><code id="subsample.fossils.youngest_+3A_tree">tree</code></td>
<td>
<p>an object of class &quot;Phylo&quot;, representing the tree upon which the
fossil occurrences were simulated.</p>
</td></tr>
<tr><td><code id="subsample.fossils.youngest_+3A_complete">complete</code></td>
<td>
<p>logical, if TRUE the youngest sample from each clade in the
complete tree is returned, if FALSE the youngest sample from each clade in
the extant only counterpart tree is returned.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an object of class &quot;fossils&quot; containing the subsampled fossil
occurrences.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>t = TreeSim::sim.bd.taxa(10, 1, 0.1, 0.05)[[1]]
f = sim.fossils.poisson(0.1, t, root.edge = FALSE)
subsample.fossils.youngest(f, t, complete = FALSE)
</code></pre>

<hr>
<h2 id='summary.taxonomy'>Display taxonomy object</h2><span id='topic+summary.taxonomy'></span>

<h3>Description</h3>

<p>Display taxonomy object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'taxonomy'
summary(object, max.length = 50, round.x = 12, details = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="summary.taxonomy_+3A_object">object</code></td>
<td>
<p>Taxonomy object.</p>
</td></tr>
<tr><td><code id="summary.taxonomy_+3A_max.length">max.length</code></td>
<td>
<p>Max number of rows to print out.</p>
</td></tr>
<tr><td><code id="summary.taxonomy_+3A_round.x">round.x</code></td>
<td>
<p>Number of decimal places to be used for species and edge ages.</p>
</td></tr>
<tr><td><code id="summary.taxonomy_+3A_details">details</code></td>
<td>
<p>If TRUE include summary statistics.</p>
</td></tr>
<tr><td><code id="summary.taxonomy_+3A_...">...</code></td>
<td>
<p>Additional parameters to be passed to <code>summary.default</code>.</p>
</td></tr>
</table>

<hr>
<h2 id='taxonomy'>Taxonomy object</h2><span id='topic+taxonomy'></span><span id='topic+as.taxonomy'></span><span id='topic+is.taxonomy'></span>

<h3>Description</h3>

<p>Create a taxonomy object relating species identity to a phylo object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>taxonomy(data)

as.taxonomy(data)

is.taxonomy(data)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="taxonomy_+3A_data">data</code></td>
<td>
<p>Dataframe of species taxonomy. See Details for the list of required fields.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The taxonomy object includes the following 6 fields for each edge in the corresponding phylo object:
</p>

<ul>
<li><p><code>sp</code> true species identity label.
If all species originated via budding or bifurcation this will always correspond to the terminal-most edge label (i.e. the youngest node) associated with each species.
This is not the case if the data set also contains anagenetic species, when multiple species may be associated with a single edge
</p>
</li>
<li><p><code>edge</code> edge label of the branch in the corresponding phylo object.
Note some species may be associated with multiple edges
</p>
</li>
<li><p><code>parent</code> = ancestor of species <code>sp</code>. Parent labels follow the same convention as species.
The label assigned to the parent of the origin or root will be zero
</p>
</li>
<li><p><code>start</code> = start time of the corresponding <code>edge</code> and/or origin time of the species.
If the corresponding edge is also the oldest edge associated with the species this value will equal the species origination time.
If speciation mode is asymmetric or symmetric the speciation time will match the start time of the corresponding edge.
If speciation mode is anagenetic the speciation time will be younger than the start time of the corresponding edge
</p>
</li>
<li><p><code>end</code> = end time of the corresponding <code>edge</code> and/or end time of the species.
If the corresponding edge is also the youngest edge associated with the species this value will equal the species end time.
Unless the species end time coincides with an anagenetic speciation event, the species end time will match the end time of the corresponding edge.
If the species end time coincides with an anagenetic speciation event, the speciation time will be older than the end time of the corresponding edge
</p>
</li>
<li><p><code>mode</code> = speciation mode. &quot;o&quot; = origin or &quot;r&quot; = root (the edge/species that began the process).
&quot;b&quot; = asymmetric or budding speciation. &quot;s&quot; = symmetric or bifurcating speciation. &quot;a&quot; = anagenetic speciation
</p>
</li></ul>

<p>Optional fields:
</p>

<ul>
<li><p><code>cryptic</code> TRUE if the speciation event was cryptic. If missing the function assumes <code>cryptic = FALSE</code>
</p>
</li>
<li><p><code>cryptic.id</code> = cryptic species identity. If <code>cryptic = TRUE</code> <code>cryptic.id</code> will differ from the true species identity <code>sp</code>
</p>
</li></ul>


<hr>
<h2 id='tree.max'>Find the maximum age in a phylo object (root age or origin time)</h2><span id='topic+tree.max'></span>

<h3>Description</h3>

<p>Function returns the the root age or the origin time (if <code>root.edge = TRUE</code>).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tree.max(tree, root.edge = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="tree.max_+3A_tree">tree</code></td>
<td>
<p>Phylo object.</p>
</td></tr>
<tr><td><code id="tree.max_+3A_root.edge">root.edge</code></td>
<td>
<p>If TRUE include the root edge (default = TRUE).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>max age
</p>


<h3>Examples</h3>

<pre><code class='language-R'>t = ape::rtree(6)
tree.max(t, root.edge = FALSE)

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
