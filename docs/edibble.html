<!DOCTYPE html><html lang="en"><head><title>Help for package edibble</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {edibble}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#edibble-package'><p>edibble: Encapsulating Elements of Experimental Design</p></a></li>
<li><a href='#+25+26gt+3B+25'><p>Pipe operator</p></a></li>
<li><a href='#activate_provenance'><p>Activate the provenance in the edibble design object</p></a></li>
<li><a href='#allot_table'><p>Allot treatments to units and serve table</p></a></li>
<li><a href='#allot_trts'><p>Define allotment of treatments to units</p></a></li>
<li><a href='#allot_units'><p>Define allotment of units to nested units</p></a></li>
<li><a href='#as_tibble.edbl_table'><p>Convert an edibble data frame to normal data frame</p></a></li>
<li><a href='#as.data.frame.edbl_table'><p>Convert edibble table to normal data frame</p></a></li>
<li><a href='#assign_fcts'><p>Assign treatments or units to units</p></a></li>
<li><a href='#autofill_rcrds'><p>Autofill the records</p></a></li>
<li><a href='#column'><p>Select a column.</p></a></li>
<li><a href='#crossed_by'><p>Specify the units to cross to index a new unit</p></a></li>
<li><a href='#design'><p>Start the edibble design</p></a></li>
<li><a href='#design_anatomy'><p>Anatomy of the design</p></a></li>
<li><a href='#design_data'><p>Get the node or edge data from an edibble design</p></a></li>
<li><a href='#design_model'><p>A baseline model for given experimental design</p></a></li>
<li><a href='#design-helpers'><p>Test and get edibble objects</p></a></li>
<li><a href='#examine_process'><p>Examine the simulation process</p></a></li>
<li><a href='#examine_recipe'><p>Check the recipe code</p></a></li>
<li><a href='#expect_rcrds'><p>Set the expected values for recording variables</p></a></li>
<li><a href='#expect-vars'><p>Expected type of data entry</p></a></li>
<li><a href='#export_design'><p>Export the design to xlsx</p></a></li>
<li><a href='#fct'><p>Setting the traits of factors</p></a></li>
<li><a href='#fct_generator'><p>Factor name generator</p></a></li>
<li><a href='#fct_graph'><p>Factor graph</p></a></li>
<li><a href='#formatting'><p>Print intermediate experimental design to terminal</p></a></li>
<li><a href='#graph_input'><p>A function to process input as input for graph manipulation</p></a></li>
<li><a href='#is_provenance'><p>Check if an object is an instance of the &quot;Provenance&quot; class.</p></a></li>
<li><a href='#is_takeout'><p>A function to check if the output is a takeout design</p></a></li>
<li><a href='#label_nested'><p>Label with nested or distinct labels</p></a></li>
<li><a href='#label_seq'><p>Generate a sequence of labels with custom formatting options</p></a></li>
<li><a href='#lady_tasting_tea'><p>Lady tasting tea</p></a></li>
<li><a href='#latin'><p>Latin square designs and its generalisations as an array</p></a></li>
<li><a href='#lvls'><p>Setting the traits of the levels</p></a></li>
<li><a href='#menu_bibd'><p>Balance incomplete block design</p></a></li>
<li><a href='#menu_crd'><p>Completely randomised design</p></a></li>
<li><a href='#menu_factorial'><p>Prepare a factorial design</p></a></li>
<li><a href='#menu_graeco'><p>Graeco-Latin Square Design</p></a></li>
<li><a href='#menu_hyper_graeco'><p>Hyper-Graeco-Latin Square Design</p></a></li>
<li><a href='#menu_lsd'><p>Prepare classical Latin square design</p></a></li>
<li><a href='#menu_rcbd'><p>Prepare a randomised complete block design</p></a></li>
<li><a href='#menu_split'><p>Split-unit design</p></a></li>
<li><a href='#menu_strip'><p>Strip-unit design</p></a></li>
<li><a href='#menu_youden'><p>Youden square design</p></a></li>
<li><a href='#nested_in'><p>Specify the nesting or conditional structure for units or treatments</p></a></li>
<li><a href='#nesting_structure'><p>Get the nesting structure for the units</p></a></li>
<li><a href='#new_edibble'><p>An edibble table constructor</p></a></li>
<li><a href='#order_trts'><p>A custom ordering algorithm</p></a></li>
<li><a href='#pivot_trts_widelist'><p>Pivot treatments to a wider list or table format</p></a></li>
<li><a href='#pivot_wider_by'><p>Pivot factor to a wider list</p></a></li>
<li><a href='#plot.edbl_design'><p>Interactive plot of the edibble design</p></a></li>
<li><a href='#Provenance'><p>An object to query, record and modify an edibble graph</p></a></li>
<li><a href='#rescale_values'><p>Rescale a numerical vector</p></a></li>
<li><a href='#scan_menu'><p>Find the short names of the named designs</p></a></li>
<li><a href='#serve_table'><p>Serve edibble table</p></a></li>
<li><a href='#set_attrs'><p>Set the experimental context as metadata</p></a></li>
<li><a href='#set_rcrds'><p>Set records for given unit</p></a></li>
<li><a href='#set_trts'><p>Set the treatment variables</p></a></li>
<li><a href='#set_units'><p>Set units used in experiment</p></a></li>
<li><a href='#simulate_process'><p>Simulation process</p></a></li>
<li><a href='#simulate_rcrds'><p>Simulate records</p></a></li>
<li><a href='#skittles'><p>Skittles experiment</p></a></li>
<li><a href='#split_by'><p>Split or count the data according to certain factors</p></a></li>
<li><a href='#takeout'><p>Create a named experimental design</p></a></li>
<li><a href='#trts_table'><p>Treatments table</p></a></li>
<li><a href='#utility-edibble-var'><p>Utility functions for edibble variable</p></a></li>
<li><a href='#with_params'><p>This is a helper function to set the parameter values</p></a></li>
<li><a href='#with_value'><p>Validation values</p></a></li>
<li><a href='#with_variables'><p>A helper function to set variables that the record is dependent on.</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Title:</td>
<td>Encapsulating Elements of Experimental Design</td>
</tr>
<tr>
<td>Version:</td>
<td>1.1.1</td>
</tr>
<tr>
<td>Description:</td>
<td>A system to facilitate designing comparative (and non-comparative) experiments using the 
  grammar of experimental designs <a href="https://emitanaka.org/edibble-book/">https://emitanaka.org/edibble-book/</a>. 
  An experimental design is treated as an intermediate, mutable object that is 
  built progressively by fundamental experimental components like units, treatments, and their relation.
  The system aids in experimental planning, management and workflow.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://opensource.org/licenses/mit-license.php">MIT</a> + file LICENSE</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.3.1</td>
</tr>
<tr>
<td>Config/testthat/edition:</td>
<td>3</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://edibble.emitanaka.org/">https://edibble.emitanaka.org/</a>,
<a href="https://github.com/emitanaka/edibble">https://github.com/emitanaka/edibble</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/emitanaka/edibble/issues">https://github.com/emitanaka/edibble/issues</a></td>
</tr>
<tr>
<td>Imports:</td>
<td>magrittr, rlang, vctrs, tibble, cli, pillar, tidyselect (&ge;
1.0.0), nestr, stats, AlgDesign, dae, R6, lifecycle, dplyr</td>
</tr>
<tr>
<td>Suggests:</td>
<td>testthat (&ge; 3.0.0), rmarkdown, openxlsx2 (&ge; 1.0.0),
visNetwork, blocksdesign, knitr, scales, tidyr</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 2.10)</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-05-06 01:33:29 UTC; emitanaka</td>
</tr>
<tr>
<td>Author:</td>
<td>Emi Tanaka <a href="https://orcid.org/0000-0002-1455-259X"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [aut,
    cre, cph]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Emi Tanaka &lt;dr.emi.tanaka@gmail.com&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-05-06 02:30:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='edibble-package'>edibble: Encapsulating Elements of Experimental Design</h2><span id='topic+edibble'></span><span id='topic+edibble-package'></span>

<h3>Description</h3>

<p><img src="../help/figures/logo.png" style='float: right' alt='logo' width='120' />
</p>
<p>A system to facilitate designing comparative (and non-comparative) experiments using the grammar of experimental designs <a href="https://emitanaka.org/edibble-book/">https://emitanaka.org/edibble-book/</a>. An experimental design is treated as an intermediate, mutable object that is built progressively by fundamental experimental components like units, treatments, and their relation. The system aids in experimental planning, management and workflow.
</p>


<h3>Details</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#experimental"><img src="../help/figures/lifecycle-experimental.svg" alt='[Experimental]' /></a>
</p>
<p><strong>(WIP)</strong>
</p>


<h3>Website</h3>


<ul>
<li><p> The website for the package is at <a href="https://edibble.emitanaka.org">https://edibble.emitanaka.org</a>
</p>
</li></ul>


<ul>
<li><p> Discussion is at <a href="https://github.com/emitanaka/edibble/discussions">https://github.com/emitanaka/edibble/discussions</a>
</p>
</li></ul>



<h3>Package options</h3>

<p>The following options are used for changing the default view for the print
out of edibble design or edibble graph.
</p>

<ul>
<li> <p><code>edibble.tree.decorate.trts</code>
</p>
</li>
<li> <p><code>edibble.tree.decorate.units</code>
</p>
</li>
<li> <p><code>edibble.tree.decorate.rcrd</code>
</p>
</li>
<li> <p><code>edibble.tree.decorate.levels</code>
</p>
</li>
<li> <p><code>edibble.tree.decorate.main</code>
</p>
</li></ul>

<p>TODO
</p>


<h3>Author(s)</h3>

<p><strong>Maintainer</strong>: Emi Tanaka <a href="mailto:dr.emi.tanaka@gmail.com">dr.emi.tanaka@gmail.com</a> (<a href="https://orcid.org/0000-0002-1455-259X">ORCID</a>) [copyright holder]
</p>


<h3>See Also</h3>

<p>Useful links:
</p>

<ul>
<li> <p><a href="https://edibble.emitanaka.org/">https://edibble.emitanaka.org/</a>
</p>
</li>
<li> <p><a href="https://github.com/emitanaka/edibble">https://github.com/emitanaka/edibble</a>
</p>
</li>
<li><p> Report bugs at <a href="https://github.com/emitanaka/edibble/issues">https://github.com/emitanaka/edibble/issues</a>
</p>
</li></ul>


<hr>
<h2 id='+25+26gt+3B+25'>Pipe operator</h2><span id='topic++25+3E+25'></span>

<h3>Description</h3>

<p>See <code>magrittr::<a href="magrittr.html#topic+pipe">%&gt;%</a></code> for details.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lhs %&gt;% rhs
</code></pre>

<hr>
<h2 id='activate_provenance'>Activate the provenance in the edibble design object</h2><span id='topic+activate_provenance'></span>

<h3>Description</h3>

<p>This is a developer function to create a new Kitchen class with
the existing design.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>activate_provenance(
  .edibble,
  overwrite = c("graph", "anatomy", "recipe", "validation", "simulate",
    "simulate_result")
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="activate_provenance_+3A_.edibble">.edibble</code></td>
<td>
<p>An edibble object.</p>
</td></tr>
<tr><td><code id="activate_provenance_+3A_overwrite">overwrite</code></td>
<td>
<p>What object to overwrite in the provenance object.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A Provenance object.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>activate_provenance(takeout())
</code></pre>

<hr>
<h2 id='allot_table'>Allot treatments to units and serve table</h2><span id='topic+allot_table'></span>

<h3>Description</h3>

<p>This function is a short hand that combines <code>allot_trts()</code>, <code>assign_trts()</code>
and <code>serve_table()</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>allot_table(
  .edibble = NULL,
  ...,
  order = "random",
  seed = NULL,
  constrain = nesting_structure(.edibble),
  label_nested = NULL,
  fail = "error",
  .record = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="allot_table_+3A_.edibble">.edibble</code></td>
<td>
<p>An edibble design which should have units, treatments and allotment defined.</p>
</td></tr>
<tr><td><code id="allot_table_+3A_...">...</code></td>
<td>
<p>One-sided or two-sided formula. If the input is a one-sided formula
then the whole treatment is applied to the specified unit.</p>
</td></tr>
<tr><td><code id="allot_table_+3A_order">order</code></td>
<td>
<p>A character vector signifying the apportion of treatments to units.
The value should be either &quot;random&quot;, &quot;systematic-fastest&quot;, &quot;systematic-slowest&quot;,
&quot;systematic-random-fastest&quot;, &quot;systematic-random-slowest&quot; or a class name corresponding to the algorithm for order_trts().
&quot;random&quot; allocates the treatment randomly to units based on specified allotment with restrictions
implied by unit structure.
&quot;systematic-slowest&quot; allocates the treatment in a systematic order to units such that the treatment level is slow in varying.
In contrast, &quot;systematic-fastest&quot; is fast in varying for treatment levels.
&quot;systematic-random-fastest&quot; and &quot;systematic-random-slowest&quot; allocates the treatment in a systematic order to units but
where it is not possible to divide treatments equally (as the number of units are not divisible
by the number of levels of the treatment factor), then the extras are chosen randomly.</p>
</td></tr>
<tr><td><code id="allot_table_+3A_seed">seed</code></td>
<td>
<p>A scalar value used to set the seed so that the result is reproducible.</p>
</td></tr>
<tr><td><code id="allot_table_+3A_constrain">constrain</code></td>
<td>
<p>The nesting structure for units.</p>
</td></tr>
<tr><td><code id="allot_table_+3A_label_nested">label_nested</code></td>
<td>
<p>The columns to show nested labels (if available). Tidyselect compatible.</p>
</td></tr>
<tr><td><code id="allot_table_+3A_fail">fail</code></td>
<td>
<p>What to do when failing to convert graph to table.</p>
</td></tr>
<tr><td><code id="allot_table_+3A_.record">.record</code></td>
<td>
<p>Whether to record the step.</p>
</td></tr>
</table>

<hr>
<h2 id='allot_trts'>Define allotment of treatments to units</h2><span id='topic+allot_trts'></span>

<h3>Description</h3>

<p>This function adds the edges between factor nodes to describe the
high-level relationship between factors.
This function does not actually assign edges between level nodes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>allot_trts(.edibble = NULL, ..., .record = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="allot_trts_+3A_.edibble">.edibble</code></td>
<td>
<p>An edibble design which should have units, treatments and allotment defined.</p>
</td></tr>
<tr><td><code id="allot_trts_+3A_...">...</code></td>
<td>
<p>One-sided or two-sided formula. If the input is a one-sided formula
then the whole treatment is applied to the specified unit.</p>
</td></tr>
<tr><td><code id="allot_trts_+3A_.record">.record</code></td>
<td>
<p>Whether to record the step.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Return an edibble design.
</p>


<h3>See Also</h3>

<p>assign_fcts
</p>
<p>Other user-facing functions: 
<code><a href="#topic+allot_units">allot_units</a>()</code>,
<code><a href="#topic+design">design</a>()</code>,
<code><a href="#topic+expect_rcrds">expect_rcrds</a>()</code>,
<code><a href="#topic+export_design">export_design</a>()</code>,
<code><a href="#topic+serve_table">serve_table</a>()</code>,
<code><a href="#topic+set_rcrds">set_rcrds</a>()</code>,
<code><a href="#topic+set_trts">set_trts</a>()</code>,
<code><a href="#topic+set_units">set_units</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>design() %&gt;%
  set_units(block = 10,
            plot = nested_in(block, 3)) %&gt;%
  set_trts(treat = c("A", "B", "C"),
           pest = c("a", "b")) %&gt;%
  allot_trts(treat ~ plot,
              pest ~ block)

</code></pre>

<hr>
<h2 id='allot_units'>Define allotment of units to nested units</h2><span id='topic+allot_units'></span>

<h3>Description</h3>

<p>This function adds the edges between factor nodes to describe the
high-level relationship between factors.
This function does not actually assign edges between level nodes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>allot_units(.edibble, ..., .record = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="allot_units_+3A_.edibble">.edibble</code></td>
<td>
<p>An edibble design which should have units, treatments and allotment defined.</p>
</td></tr>
<tr><td><code id="allot_units_+3A_...">...</code></td>
<td>
<p>A two-sided formula.</p>
</td></tr>
<tr><td><code id="allot_units_+3A_.record">.record</code></td>
<td>
<p>Whether to record the step.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Return an edibble design.
</p>


<h3>See Also</h3>

<p>assign_fcts
</p>
<p>Other user-facing functions: 
<code><a href="#topic+allot_trts">allot_trts</a>()</code>,
<code><a href="#topic+design">design</a>()</code>,
<code><a href="#topic+expect_rcrds">expect_rcrds</a>()</code>,
<code><a href="#topic+export_design">export_design</a>()</code>,
<code><a href="#topic+serve_table">serve_table</a>()</code>,
<code><a href="#topic+set_rcrds">set_rcrds</a>()</code>,
<code><a href="#topic+set_trts">set_trts</a>()</code>,
<code><a href="#topic+set_units">set_units</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>design() %&gt;%
  set_units(block = 10,
            plot = 20) %&gt;%
  allot_units(block ~ plot)

</code></pre>

<hr>
<h2 id='as_tibble.edbl_table'>Convert an edibble data frame to normal data frame</h2><span id='topic+as_tibble.edbl_table'></span>

<h3>Description</h3>

<p>A patch function where there is an issue with edbl factors
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'edbl_table'
as_tibble(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="as_tibble.edbl_table_+3A_x">x</code></td>
<td>
<p>can be a list or data frame</p>
</td></tr>
<tr><td><code id="as_tibble.edbl_table_+3A_...">...</code></td>
<td>
<p>Not currently used.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data.frame.
</p>

<hr>
<h2 id='as.data.frame.edbl_table'>Convert edibble table to normal data frame</h2><span id='topic+as.data.frame.edbl_table'></span>

<h3>Description</h3>

<p>Convert edibble table to normal data frame
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'edbl_table'
as.data.frame(x, ..., levels_as = "factor", ignore_numeric = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="as.data.frame.edbl_table_+3A_x">x</code></td>
<td>
<p>An edibble table</p>
</td></tr>
<tr><td><code id="as.data.frame.edbl_table_+3A_...">...</code></td>
<td>
<p>Unused.
i.e. don't coerce numeric factors.</p>
</td></tr>
<tr><td><code id="as.data.frame.edbl_table_+3A_levels_as">levels_as</code></td>
<td>
<p>Coerce the edibble factors to either &quot;factor&quot; or &quot;character&quot;.</p>
</td></tr>
<tr><td><code id="as.data.frame.edbl_table_+3A_ignore_numeric">ignore_numeric</code></td>
<td>
<p>Whether to coerce numeric factors or not. Default is TRUE,</p>
</td></tr>
</table>

<hr>
<h2 id='assign_fcts'>Assign treatments or units to units</h2><span id='topic+assign_fcts'></span><span id='topic+assign_trts'></span><span id='topic+assign_units'></span>

<h3>Description</h3>

<p>This function assigns specific treatment or unit levels to actual units.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>assign_trts(
  .edibble = NULL,
  order = "random",
  seed = NULL,
  constrain = nesting_structure(.edibble),
  ...,
  .record = TRUE
)

assign_units(
  .edibble = NULL,
  order = "random",
  seed = NULL,
  constrain = nesting_structure(.edibble),
  ...,
  .record = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="assign_fcts_+3A_.edibble">.edibble</code></td>
<td>
<p>An edibble design which should have units, treatments and allotment defined.</p>
</td></tr>
<tr><td><code id="assign_fcts_+3A_order">order</code></td>
<td>
<p>A character vector signifying the apportion of treatments to units.
The value should be either &quot;random&quot;, &quot;systematic-fastest&quot;, &quot;systematic-slowest&quot;,
&quot;systematic-random-fastest&quot;, &quot;systematic-random-slowest&quot; or a class name corresponding to the algorithm for order_trts().
&quot;random&quot; allocates the treatment randomly to units based on specified allotment with restrictions
implied by unit structure.
&quot;systematic-slowest&quot; allocates the treatment in a systematic order to units such that the treatment level is slow in varying.
In contrast, &quot;systematic-fastest&quot; is fast in varying for treatment levels.
&quot;systematic-random-fastest&quot; and &quot;systematic-random-slowest&quot; allocates the treatment in a systematic order to units but
where it is not possible to divide treatments equally (as the number of units are not divisible
by the number of levels of the treatment factor), then the extras are chosen randomly.</p>
</td></tr>
<tr><td><code id="assign_fcts_+3A_seed">seed</code></td>
<td>
<p>A scalar value used to set the seed so that the result is reproducible.</p>
</td></tr>
<tr><td><code id="assign_fcts_+3A_constrain">constrain</code></td>
<td>
<p>The nesting structure for units.</p>
</td></tr>
<tr><td><code id="assign_fcts_+3A_...">...</code></td>
<td>
<p>Arguments parsed into <code>order_trts</code> functions.</p>
</td></tr>
<tr><td><code id="assign_fcts_+3A_.record">.record</code></td>
<td>
<p>Whether to record the step.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An edibble design.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># 10 subject, 2 vaccine treatments
design() %&gt;%
  set_units(subject = 10) %&gt;%
  set_trts(vaccine = 2) %&gt;%
  allot_trts(vaccine ~ subject) %&gt;%
  assign_trts() %&gt;%
  serve_table()

# 20 subjects, 2 blocks, assign subjects to blocks
design() %&gt;%
  set_units(subject = 20,
            block = 2) %&gt;%
  allot_units(block ~ subject) %&gt;%
  assign_units() %&gt;%
  serve_table()
</code></pre>

<hr>
<h2 id='autofill_rcrds'>Autofill the records</h2><span id='topic+autofill_rcrds'></span>

<h3>Description</h3>

<p>This function fills the values of the record factors by automatically
choosing a simulation process. It tries to be smart by ensuring to use
values that is within expectation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>autofill_rcrds(.data, ..., .seed = NULL, .nsim = 1L)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="autofill_rcrds_+3A_.data">.data</code></td>
<td>
<p>An edibble data.</p>
</td></tr>
<tr><td><code id="autofill_rcrds_+3A_...">...</code></td>
<td>
<p>If supplied, it is a name-value pair where the name should
correspond to the record factor name and value is the f</p>
</td></tr>
<tr><td><code id="autofill_rcrds_+3A_.seed">.seed</code></td>
<td>
<p>The seed number.</p>
</td></tr>
<tr><td><code id="autofill_rcrds_+3A_.nsim">.nsim</code></td>
<td>
<p>The number of simulations to run.</p>
</td></tr>
</table>

<hr>
<h2 id='column'>Select a column.</h2><span id='topic+column'></span>

<h3>Description</h3>

<p>This is a helper function to select a column when data is supplied
for <code>lvls</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>column(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="column_+3A_x">x</code></td>
<td>
<p>The column to select. Can be unquoted name or the column index.</p>
</td></tr>
</table>

<hr>
<h2 id='crossed_by'>Specify the units to cross to index a new unit</h2><span id='topic+crossed_by'></span>

<h3>Description</h3>

<p><code>crossed_by(A, B)</code> is the same as <code>~A:B</code> but <code>crossed_by</code> offers more control over the names of the new units
as well as adding new attributes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>crossed_by(..., attrs = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="crossed_by_+3A_...">...</code></td>
<td>
<p>a sequence of units</p>
</td></tr>
<tr><td><code id="crossed_by_+3A_attrs">attrs</code></td>
<td>
<p>Currently not implemented.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class &quot;cross_lvls&quot;.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>design("Strip-Plot Design | Strip-Unit Design") %&gt;%
  set_units(block = 3,
            row = nested_in(block, 7),
            col = nested_in(block, 6),
            unit = nested_in(block, crossed_by(row, col)))
</code></pre>

<hr>
<h2 id='design'>Start the edibble design</h2><span id='topic+design'></span><span id='topic+redesign'></span>

<h3>Description</h3>

<p>This function doesn't really do much besides create a new edibble design object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>design(
  .title = NULL,
  ...,
  .name = "edibble",
  .record = TRUE,
  .seed = NULL,
  .provenance = Provenance$new()
)

redesign(
  .data,
  .title,
  ...,
  .name = NULL,
  .record = TRUE,
  .seed = NULL,
  .provenance = Provenance$new()
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="design_+3A_.title">.title</code></td>
<td>
<p>Optional title of the experiment.</p>
</td></tr>
<tr><td><code id="design_+3A_...">...</code></td>
<td>
<p>A series of name-value pairs where the name corresponds to the
name of the metadata nad the value corresponds to the actual metadata value.
If the name is omitted, then no name to the metadata is assigned for the
corresponding value.</p>
</td></tr>
<tr><td><code id="design_+3A_.name">.name</code></td>
<td>
<p>Optional name of the experiment.</p>
</td></tr>
<tr><td><code id="design_+3A_.record">.record</code></td>
<td>
<p>A logical value. This indicates whether to record this
code step. The default is TRUE. It should remain TRUE unless this
function is used as a wrapper in other code.</p>
</td></tr>
<tr><td><code id="design_+3A_.seed">.seed</code></td>
<td>
<p>A seed number for reproducibility.</p>
</td></tr>
<tr><td><code id="design_+3A_.provenance">.provenance</code></td>
<td>
<p>An environment setup in a manner to store methods and
information to trace the origin of the design</p>
</td></tr>
<tr><td><code id="design_+3A_.data">.data</code></td>
<td>
<p>An edibble table.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An empty <code>edbl_design</code> object.
</p>


<h3>See Also</h3>

<p>Add variables to this design with <code><a href="#topic+set_units">set_units()</a></code>, <code><a href="#topic+set_trts">set_trts()</a></code>, and
<code><a href="#topic+set_rcrds">set_rcrds()</a></code>.
</p>
<p>Other user-facing functions: 
<code><a href="#topic+allot_trts">allot_trts</a>()</code>,
<code><a href="#topic+allot_units">allot_units</a>()</code>,
<code><a href="#topic+expect_rcrds">expect_rcrds</a>()</code>,
<code><a href="#topic+export_design">export_design</a>()</code>,
<code><a href="#topic+serve_table">serve_table</a>()</code>,
<code><a href="#topic+set_rcrds">set_rcrds</a>()</code>,
<code><a href="#topic+set_trts">set_trts</a>()</code>,
<code><a href="#topic+set_units">set_units</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>design("My design")
</code></pre>

<hr>
<h2 id='design_anatomy'>Anatomy of the design</h2><span id='topic+design_anatomy'></span>

<h3>Description</h3>

<p>This is a convenient wrapper for <code>dae::designAnatomy</code> where the <code>formulae</code> structure is
automatically determined by the unit and treatment structure specified in <code>edibble</code> system.
Note: the computation may be long if the design is quite complicated or there are many units.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>design_anatomy(.edibble, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="design_anatomy_+3A_.edibble">.edibble</code></td>
<td>
<p>A complete edibble design object or edibble table.</p>
</td></tr>
<tr><td><code id="design_anatomy_+3A_...">...</code></td>
<td>
<p>Any other arguments parsed to <code>dae::designAnatomy</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class &quot;des_anatomy&quot;.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>split &lt;- takeout(menu_split(t1 = 3, t2 = 2, r = 2))
design_anatomy(split)
</code></pre>

<hr>
<h2 id='design_data'>Get the node or edge data from an edibble design</h2><span id='topic+design_data'></span><span id='topic+fct_nodes'></span><span id='topic+fct_edges'></span><span id='topic+lvl_nodes'></span><span id='topic+lvl_edges'></span>

<h3>Description</h3>

<p>Get the node or edge data from an edibble design
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fct_nodes(x)

fct_edges(x)

lvl_nodes(x)

lvl_edges(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="design_data_+3A_x">x</code></td>
<td>
<p>An edibble object.</p>
</td></tr>
</table>

<hr>
<h2 id='design_model'>A baseline model for given experimental design</h2><span id='topic+design_model'></span>

<h3>Description</h3>

<p>This
</p>


<h3>Usage</h3>

<pre><code class='language-R'>design_model(data, type = c("anova", "lmer"))
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="design_model_+3A_data">data</code></td>
<td>
<p>An edibble data.</p>
</td></tr>
<tr><td><code id="design_model_+3A_type">type</code></td>
<td>
<p>The type of model expression to return.</p>
</td></tr>
</table>

<hr>
<h2 id='design-helpers'>Test and get edibble objects</h2><span id='topic+design-helpers'></span><span id='topic+is_edibble_design'></span><span id='topic+is_named_design'></span><span id='topic+is_edibble_table'></span><span id='topic+is_edibble_graph'></span><span id='topic+is_edibble'></span><span id='topic+is_edibble_levels'></span><span id='topic+is_nest_levels'></span><span id='topic+is_cross_levels'></span><span id='topic+edbl_design'></span><span id='topic+edbl_table'></span>

<h3>Description</h3>

<p>The <code>is</code> functions tests if an object (or an object in its attribute)
inherits particular class and returns <code>TRUE</code> if it does, otherwise <code>FALSE</code>.
</p>

<ul>
<li> <p><code>is_edibble_design</code> checks if it inherits <code>edbl_design</code>.
</p>
</li>
<li> <p><code>is_edibble_graph</code> checks if it inherits <code>edbl_graph</code>.
</p>
</li>
<li> <p><code>is_edibble_table</code> checks if it inherits <code>edbl_table</code>
</p>
</li>
<li> <p><code>is_edibble</code> checks if the object inherits <code>edbl</code>.
The search is quite simple, it checks if
the object is <code>edbl_design</code>, failing that it looks to see if the
attribute &quot;design&quot; of the object is <code>edbl_design</code>.
</p>
</li>
<li> <p><code>is_named_design</code> check if it inherits <code>NamedDesign</code>.
</p>
</li></ul>

<p>The <code>get</code> functions extracts the requested edibble component (table, graph,
or design) from the object if possible.
</p>

<ul>
<li> <p><code>edbl_design</code> tries to get <code>edbl_design</code>.
</p>
</li>
<li> <p><code>edbl_table</code> tries to get <code>edbl_table</code> with no design attribute.
</p>
</li>
<li> <p><code>edbl_graph</code> tries to get <code>edbl_graph</code>.
</p>
</li></ul>



<h3>Usage</h3>

<pre><code class='language-R'>is_edibble_design(x)

is_named_design(x)

is_edibble_table(x)

is_edibble_graph(x)

is_edibble(x)

is_edibble_levels(x)

is_nest_levels(x)

is_cross_levels(x)

edbl_design(x)

edbl_table(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="design-helpers_+3A_x">x</code></td>
<td>
<p>An object.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A logical value.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>is_edibble_design(takeout())
</code></pre>

<hr>
<h2 id='examine_process'>Examine the simulation process</h2><span id='topic+examine_process'></span><span id='topic+examine_process_values'></span>

<h3>Description</h3>

<p>Examine the simulation process
</p>


<h3>Usage</h3>

<pre><code class='language-R'>examine_process(data, process = NULL)

examine_process_values(data, process = NULL, sim = 1L)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="examine_process_+3A_data">data</code></td>
<td>
<p>An edibble data frame.</p>
</td></tr>
<tr><td><code id="examine_process_+3A_process">process</code></td>
<td>
<p>The process name. Typically the name of the process. If unknown,
leave this empty.</p>
</td></tr>
<tr><td><code id="examine_process_+3A_sim">sim</code></td>
<td>
<p>The simulation number. Default is 1.</p>
</td></tr>
</table>

<hr>
<h2 id='examine_recipe'>Check the recipe code</h2><span id='topic+examine_recipe'></span>

<h3>Description</h3>

<p>Check the recipe code
</p>


<h3>Usage</h3>

<pre><code class='language-R'>examine_recipe(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="examine_recipe_+3A_x">x</code></td>
<td>
<p>An edibble design, edibble, or takeout object.</p>
</td></tr>
<tr><td><code id="examine_recipe_+3A_...">...</code></td>
<td>
<p>Not used.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The recipe code.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>examine_recipe(takeout())
</code></pre>

<hr>
<h2 id='expect_rcrds'>Set the expected values for recording variables</h2><span id='topic+expect_rcrds'></span>

<h3>Description</h3>

<p>Set the expected values for recording variables
</p>


<h3>Usage</h3>

<pre><code class='language-R'>expect_rcrds(.edibble = NULL, ..., .record = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="expect_rcrds_+3A_.edibble">.edibble</code></td>
<td>
<p>An edibble design (<code>edbl_design</code>), an edibble data frame (<code>edbl_table</code>) or an
object that contains the edibble data frame in the attribute
<code>design</code>.</p>
</td></tr>
<tr><td><code id="expect_rcrds_+3A_...">...</code></td>
<td>
<p>Name-value pairs with the name belonging to the variable
that are plan to be recorded from <code>set_rcrds()</code> and the values are
the expected types and values set by helper functions, see <code>?expect-rcrds</code>.</p>
</td></tr>
<tr><td><code id="expect_rcrds_+3A_.record">.record</code></td>
<td>
<p>A logical value. This indicates whether to record this
code step. The default is TRUE. It should remain TRUE unless this
function is used as a wrapper in other code.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An edibble design.
</p>


<h3>See Also</h3>

<p>Other user-facing functions: 
<code><a href="#topic+allot_trts">allot_trts</a>()</code>,
<code><a href="#topic+allot_units">allot_units</a>()</code>,
<code><a href="#topic+design">design</a>()</code>,
<code><a href="#topic+export_design">export_design</a>()</code>,
<code><a href="#topic+serve_table">serve_table</a>()</code>,
<code><a href="#topic+set_rcrds">set_rcrds</a>()</code>,
<code><a href="#topic+set_trts">set_trts</a>()</code>,
<code><a href="#topic+set_units">set_units</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>takeout(menu_crd(t = 4, n = 10)) %&gt;%
  set_rcrds(y = unit) %&gt;%
  expect_rcrds(y &gt; 0)
</code></pre>

<hr>
<h2 id='expect-vars'>Expected type of data entry</h2><span id='topic+expect-vars'></span><span id='topic+to_be_numeric'></span><span id='topic+to_be_integer'></span><span id='topic+to_be_date'></span><span id='topic+to_be_time'></span><span id='topic+to_be_character'></span><span id='topic+to_be_factor'></span>

<h3>Description</h3>

<p>These functions should be used within <code>expect_vars</code> where variables that
are to be recorded are constraint to the expected values when exported
as an xlsx file by <code style="white-space: pre;">&#8288;export_design().&#8288;</code> The functions to set a particular
value type (numeric, integer, date, time and character) are preceded by
&quot;to_be_&quot; where the corresponding restriction set by <code>with_value()</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>to_be_numeric(range)

to_be_integer(range)

to_be_date(range)

to_be_time(range)

to_be_character(length)

to_be_factor(levels)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="expect-vars_+3A_range">range</code>, <code id="expect-vars_+3A_length">length</code></td>
<td>
<p>A named list with two elements: &quot;operator&quot; and &quot;value&quot; as
provided by helper <code>with_value()</code> that gives the possible range of values
that the expected type can take.</p>
</td></tr>
<tr><td><code id="expect-vars_+3A_levels">levels</code></td>
<td>
<p>A character vector with the factor levels.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A record type.
</p>

<hr>
<h2 id='export_design'>Export the design to xlsx</h2><span id='topic+export_design'></span>

<h3>Description</h3>

<p>This function is designed to export the design made using edibble to an
external xlsx file.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>export_design(
  .data,
  file,
  author = NULL,
  date = Sys.Date(),
  overwrite = FALSE,
  hide_treatments = FALSE,
  theme = NULL,
  subject = NULL,
  category = NULL,
  table_style = "TableStyleMedium9"
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="export_design_+3A_.data">.data</code></td>
<td>
<p>An edibble table to export.</p>
</td></tr>
<tr><td><code id="export_design_+3A_file">file</code></td>
<td>
<p>File, including the path, to export the data to.</p>
</td></tr>
<tr><td><code id="export_design_+3A_author">author</code></td>
<td>
<p>(Optional) name of the author in character. A vector of character is supported
for where there are multiple authors.</p>
</td></tr>
<tr><td><code id="export_design_+3A_date">date</code></td>
<td>
<p>The date to be inserted in header (defaults to today).</p>
</td></tr>
<tr><td><code id="export_design_+3A_overwrite">overwrite</code></td>
<td>
<p>A logical value indicating whether to overwrite existing file or not.</p>
</td></tr>
<tr><td><code id="export_design_+3A_hide_treatments">hide_treatments</code></td>
<td>
<p>A logical value indicating whether treatments should be included in the data entry sheet.
Default is true.</p>
</td></tr>
<tr><td><code id="export_design_+3A_theme">theme</code></td>
<td>
<p>The Excel theme to use (optional). One of &quot;Atlas&quot;, &quot;Badge&quot;, &quot;Berlin&quot;, &quot;Celestial&quot;, &quot;Crop&quot;, &quot;Depth&quot;, &quot;Droplet&quot;, &quot;Facet&quot;, &quot;Feathered&quot;, &quot;Gallery&quot;, &quot;Headlines&quot;, &quot;Integral&quot;, &quot;Ion&quot;, &quot;Ion Boardroom&quot;, &quot;Madison&quot;, &quot;Main Event&quot;, &quot;Mesh&quot;, &quot;Office Theme&quot;, &quot;Old Office Theme&quot;, &quot;Organic&quot;, &quot;Parallax&quot;, &quot;Parcel&quot;, &quot;Retrospect&quot;, &quot;Savon&quot;, &quot;Slice&quot;, &quot;Vapor Trail&quot;, &quot;View&quot;, &quot;Wisp&quot;, &quot;Wood Type&quot;.</p>
</td></tr>
<tr><td><code id="export_design_+3A_subject">subject</code></td>
<td>
<p>The subject of the workbook (optional).</p>
</td></tr>
<tr><td><code id="export_design_+3A_category">category</code></td>
<td>
<p>The category of the workbook (optional).</p>
</td></tr>
<tr><td><code id="export_design_+3A_table_style">table_style</code></td>
<td>
<p>The table style to apply to the exported data (default: &quot;TableStyleMedium9&quot;).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The input data object.
</p>


<h3>See Also</h3>

<p>Other user-facing functions: 
<code><a href="#topic+allot_trts">allot_trts</a>()</code>,
<code><a href="#topic+allot_units">allot_units</a>()</code>,
<code><a href="#topic+design">design</a>()</code>,
<code><a href="#topic+expect_rcrds">expect_rcrds</a>()</code>,
<code><a href="#topic+serve_table">serve_table</a>()</code>,
<code><a href="#topic+set_rcrds">set_rcrds</a>()</code>,
<code><a href="#topic+set_trts">set_trts</a>()</code>,
<code><a href="#topic+set_units">set_units</a>()</code>
</p>

<hr>
<h2 id='fct'>Setting the traits of factors</h2><span id='topic+fct'></span><span id='topic+fct_attrs'></span>

<h3>Description</h3>

<p>This function is used to set characteristics of the factors.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fct(.levels = character(), ...)

fct_attrs(.levels = character(), ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="fct_+3A_.levels">.levels</code></td>
<td>
<p>Either a short hand given as either as a single integer (number of levels),
a vector or levels created from <code>lvls()</code>.</p>
</td></tr>
<tr><td><code id="fct_+3A_...">...</code></td>
<td>
<p>A name-value pair of attributes. The value must be a scalar and
attributed to the whole factor (not individual levels).
The values are added as attributes to the output object.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p>lvls
</p>


<h3>Examples</h3>

<pre><code class='language-R'>fct(c("A", "B"))
</code></pre>

<hr>
<h2 id='fct_generator'>Factor name generator</h2><span id='topic+fct_generator'></span>

<h3>Description</h3>

<p>Generate a factor with custom levels and repetitions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fct_generator(labels, nlevels)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="fct_generator_+3A_labels">labels</code></td>
<td>
<p>A character vector specifying the custom labels for the factor levels.</p>
</td></tr>
<tr><td><code id="fct_generator_+3A_nlevels">nlevels</code></td>
<td>
<p>An integer or a vector of integers indicating the number of repetitions for each label.
If a single integer is provided, it is recycled to match the length of <code>labels</code>.
If a vector is provided, it should have the same length as <code>labels</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function creates a factor with custom labels and specified repetitions for each label.
</p>


<h3>Value</h3>

<p>A factor with custom levels and repetitions.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Example usage of the function
fct_generator(labels = c("A", "B", "C"), nlevels = 3)

</code></pre>

<hr>
<h2 id='fct_graph'>Factor graph</h2><span id='topic+fct_graph'></span>

<h3>Description</h3>

<p>Get the factor graph.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fct_graph(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="fct_graph_+3A_x">x</code></td>
<td>
<p>An edibble object.</p>
</td></tr>
</table>

<hr>
<h2 id='formatting'>Print intermediate experimental design to terminal</h2><span id='topic+formatting'></span><span id='topic+print.edbl_design'></span>

<h3>Description</h3>

<p>This function prints an <code>edbl_graph</code> object as a tree to terminal.
The variables are color coded (or decorated) with the given options.
Any ANSI coloring or styling are only visible in the console or terminal
outputs that support it. The print output is best used interactively since
any text styling are lost in text or R Markdown output. More details can
be found in <code>vignette("edbl-output", package = "edibble")</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'edbl_design'
print(
  x,
  decorate_units = edibble_decorate("units"),
  decorate_trts = edibble_decorate("trts"),
  decorate_rcrds = edibble_decorate("rcrds"),
  decorate_levels = edibble_decorate("levels"),
  decorate_title = edibble_decorate("title"),
  title = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="formatting_+3A_x">x</code></td>
<td>
<p>An edibble graph.</p>
</td></tr>
<tr><td><code id="formatting_+3A_decorate_trts">decorate_trts</code>, <code id="formatting_+3A_decorate_units">decorate_units</code>, <code id="formatting_+3A_decorate_rcrds">decorate_rcrds</code>, <code id="formatting_+3A_decorate_levels">decorate_levels</code>, <code id="formatting_+3A_decorate_title">decorate_title</code></td>
<td>
<p>A function applied to the name of treatment, unit, response factors or
design title. The function should return a string. Most often this wraps the name with
ANSI colored text.</p>
</td></tr>
<tr><td><code id="formatting_+3A_title">title</code></td>
<td>
<p>The title of the design.</p>
</td></tr>
<tr><td><code id="formatting_+3A_...">...</code></td>
<td>
<p>Unused.</p>
</td></tr>
</table>

<hr>
<h2 id='graph_input'>A function to process input as input for graph manipulation</h2><span id='topic+graph_input'></span>

<h3>Description</h3>

<p>A function to process input as input for graph manipulation
</p>


<h3>Usage</h3>

<pre><code class='language-R'>graph_input(input, prov, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="graph_input_+3A_input">input</code></td>
<td>
<p>An input.</p>
</td></tr>
<tr><td><code id="graph_input_+3A_prov">prov</code></td>
<td>
<p>A provenance object.</p>
</td></tr>
<tr><td><code id="graph_input_+3A_...">...</code></td>
<td>
<p>Unused.</p>
</td></tr>
</table>

<hr>
<h2 id='is_provenance'>Check if an object is an instance of the &quot;Provenance&quot; class.</h2><span id='topic+is_provenance'></span>

<h3>Description</h3>

<p>This function determines whether the given object is an instance of the
&quot;Provenance&quot; class.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is_provenance(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="is_provenance_+3A_x">x</code></td>
<td>
<p>An object to be checked for its class membership.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>TRUE</code> if the object is an instance of the &quot;Provenance&quot; class,
<code>FALSE</code> otherwise.
</p>

<hr>
<h2 id='is_takeout'>A function to check if the output is a takeout design</h2><span id='topic+is_takeout'></span>

<h3>Description</h3>

<p>The function returns <code>TRUE</code> if the input is a takeout design.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is_takeout(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="is_takeout_+3A_x">x</code></td>
<td>
<p>An object.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A logical value.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>is_takeout(takeout())
</code></pre>

<hr>
<h2 id='label_nested'>Label with nested or distinct labels</h2><span id='topic+label_nested'></span><span id='topic+label_distinct'></span><span id='topic+index_levels'></span>

<h3>Description</h3>

<p>Label with nested or distinct labels
</p>


<h3>Usage</h3>

<pre><code class='language-R'>label_nested(x)

label_distinct(x)

index_levels(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="label_nested_+3A_x">x</code></td>
<td>
<p>A unit vector.</p>
</td></tr>
</table>

<hr>
<h2 id='label_seq'>Generate a sequence of labels with custom formatting options</h2><span id='topic+label_seq'></span><span id='topic+label_seq_from_to'></span><span id='topic+label_seq_from_length'></span><span id='topic+label_seq_to_length'></span><span id='topic+label_seq_length'></span>

<h3>Description</h3>

<p>These can be handy for generating pseudo labels for the levels or
factor names using <code>fct_generator</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>label_seq_from_to(
  from = 1L,
  to = 1L,
  by = 1L,
  prefix = "",
  suffix = "",
  sep_prefix = "",
  sep_suffix = "",
  leading_zero = edibble_labels_opt("leading_zero")
)

label_seq_from_length(
  from = 1L,
  length = 1L,
  by = 1L,
  prefix = "",
  suffix = "",
  sep_prefix = "",
  sep_suffix = "",
  leading_zero = edibble_labels_opt("leading_zero")
)

label_seq_to_length(
  to = 1L,
  length = 1L,
  by = 1L,
  prefix = "",
  suffix = "",
  sep_prefix = "",
  sep_suffix = "",
  leading_zero = edibble_labels_opt("leading_zero")
)

label_seq_length(
  length = 1L,
  prefix = "",
  suffix = "",
  sep_prefix = "",
  sep_suffix = "",
  leading_zero = edibble_labels_opt("leading_zero")
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="label_seq_+3A_from">from</code></td>
<td>
<p>An integer specifying the starting value (inclusive) of the sequence.</p>
</td></tr>
<tr><td><code id="label_seq_+3A_to">to</code></td>
<td>
<p>An integer specifying the ending value (inclusive) of the sequence.</p>
</td></tr>
<tr><td><code id="label_seq_+3A_by">by</code></td>
<td>
<p>An integer specifying the increment between values in the sequence.</p>
</td></tr>
<tr><td><code id="label_seq_+3A_prefix">prefix</code></td>
<td>
<p>A character string to be prepended to the labels.</p>
</td></tr>
<tr><td><code id="label_seq_+3A_suffix">suffix</code></td>
<td>
<p>A character string to be appended to the labels.</p>
</td></tr>
<tr><td><code id="label_seq_+3A_sep_prefix">sep_prefix</code></td>
<td>
<p>A character string used to separate the prefix from the labels.</p>
</td></tr>
<tr><td><code id="label_seq_+3A_sep_suffix">sep_suffix</code></td>
<td>
<p>A character string used to separate the suffix from the labels.</p>
</td></tr>
<tr><td><code id="label_seq_+3A_leading_zero">leading_zero</code></td>
<td>
<p>A logical value indicating whether to add leading zeros to the labels.
If integer, then pad based on the number supplied.</p>
</td></tr>
<tr><td><code id="label_seq_+3A_length">length</code></td>
<td>
<p>An integer specifying the desired length of the sequence.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A character vector containing the labels generated from the sequence.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>label_seq_to_length(to = 10, length = 5, by = 2)
label_seq_from_to(from = 8, to = 10, leading_zero = 3)
label_seq_length(10, leading_zero = FALSE)
</code></pre>

<hr>
<h2 id='lady_tasting_tea'>Lady tasting tea</h2><span id='topic+lady_tasting_tea'></span>

<h3>Description</h3>

<p>Lady tasting tea experiment was described in Fisher (1935) to test
the ability of a lady who said she tell whether the tea or milk was added
first to a cup of tea.
</p>
<p>The experiment consisted of preparing eight cups of tea, four with milk poured
first and the other four with tea poured first. The lady has been told in
advance that there are four of each kind of preparation.
</p>
<p>This data consists of the same experimental structure and result but
the order presented in practice is unknown.
</p>

<dl>
<dt>cup</dt><dd><p>The cup number.</p>
</dd>
<dt>first</dt><dd><p>The cup of tea prepared with milk or tea first.</p>
</dd>
<dt>guess</dt><dd><p>The guess by lady which one was poured first.</p>
</dd>
<dt>correct</dt><dd><p>Whether the lady's guess was correct.</p>
</dd>
</dl>



<h3>Usage</h3>

<pre><code class='language-R'>lady_tasting_tea
</code></pre>


<h3>Format</h3>

<p>An object of class <code>tbl_df</code> (inherits from <code>tbl</code>, <code>data.frame</code>) with 8 rows and 4 columns.
</p>


<h3>Source</h3>

<p>Fisher, Ronald (1935) The Design of Experiments.
</p>


<h3>See Also</h3>

<p>Other experimental data: 
<code><a href="#topic+skittles">skittles</a></code>
</p>

<hr>
<h2 id='latin'>Latin square designs and its generalisations as an array</h2><span id='topic+latin'></span><span id='topic+latin_square'></span><span id='topic+latin_rectangle'></span><span id='topic+latin_array'></span>

<h3>Description</h3>

<p>Latin square designs and its generalisations as an array
</p>


<h3>Usage</h3>

<pre><code class='language-R'>latin_square(n, randomise = TRUE)

latin_rectangle(nr, nc, nt, randomise = TRUE)

latin_array(dim, nt, randomise = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="latin_+3A_n">n</code>, <code id="latin_+3A_nt">nt</code></td>
<td>
<p>The number of treatments</p>
</td></tr>
<tr><td><code id="latin_+3A_randomise">randomise</code></td>
<td>
<p>A logical value to indicate whether the treatment allocation should be randomised. The default value is <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="latin_+3A_nr">nr</code></td>
<td>
<p>The number of rows</p>
</td></tr>
<tr><td><code id="latin_+3A_nc">nc</code></td>
<td>
<p>The number of columns</p>
</td></tr>
<tr><td><code id="latin_+3A_dim">dim</code></td>
<td>
<p>A vector of integers to indicate the number of elements in each dimension.</p>
</td></tr>
</table>


<h3>Functions</h3>


<ul>
<li> <p><code>latin_square()</code>: Latin square design
</p>
</li>
<li> <p><code>latin_rectangle()</code>: Like a Latin square design but allow different number of rows and columns
</p>
</li>
<li> <p><code>latin_array()</code>: Returns an array where it stitches up multiple Latin square/rectangle design
</p>
</li></ul>


<h3>Examples</h3>

<pre><code class='language-R'>latin_square(n = 3)
latin_rectangle(3, 3, 3)
latin_array(c(3, 3, 3), 3)
</code></pre>

<hr>
<h2 id='lvls'>Setting the traits of the levels</h2><span id='topic+lvls'></span>

<h3>Description</h3>

<p>Setting the traits of the levels
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lvls(value = NULL, n = NA_integer_, data = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="lvls_+3A_value">value</code></td>
<td>
<p>A vector of the level values.</p>
</td></tr>
<tr><td><code id="lvls_+3A_n">n</code></td>
<td>
<p>The number of replicate (if applicable).</p>
</td></tr>
<tr><td><code id="lvls_+3A_data">data</code></td>
<td>
<p>A list or data frame of the same size as the <code>levels</code>.</p>
</td></tr>
<tr><td><code id="lvls_+3A_...">...</code></td>
<td>
<p>Name-value pair denoting other level attributes. The value should be the same
length as <code>levels</code> or a single value.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An edbl_lvls object.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>lvls(c("A", "B"))
</code></pre>

<hr>
<h2 id='menu_bibd'>Balance incomplete block design</h2><span id='topic+menu_bibd'></span>

<h3>Description</h3>

<p>Some combinations of parameter values cannot create a balanced incomplete
block design.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>menu_bibd(
  t = random_integer_small(min = 3),
  k = random_integer_small(max = t - 1),
  r = random_integer_small(),
  seed = random_seed_number()
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="menu_bibd_+3A_t">t</code></td>
<td>
<p>The number of treatments.</p>
</td></tr>
<tr><td><code id="menu_bibd_+3A_k">k</code></td>
<td>
<p>The size of the block. This should be less than the number of
treatments.</p>
</td></tr>
<tr><td><code id="menu_bibd_+3A_r">r</code></td>
<td>
<p>The number of replications for each treatment level.</p>
</td></tr>
<tr><td><code id="menu_bibd_+3A_seed">seed</code></td>
<td>
<p>A scalar value for computational reproducibility.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A recipe for balance incomplete block design.
</p>


<h3>See Also</h3>

<p>Other recipe-designs: 
<code><a href="#topic+menu_crd">menu_crd</a>()</code>,
<code><a href="#topic+menu_factorial">menu_factorial</a>()</code>,
<code><a href="#topic+menu_graeco">menu_graeco</a>()</code>,
<code><a href="#topic+menu_hyper_graeco">menu_hyper_graeco</a>()</code>,
<code><a href="#topic+menu_lsd">menu_lsd</a>()</code>,
<code><a href="#topic+menu_rcbd">menu_rcbd</a>()</code>,
<code><a href="#topic+menu_split">menu_split</a>()</code>,
<code><a href="#topic+menu_strip">menu_strip</a>()</code>,
<code><a href="#topic+menu_youden">menu_youden</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>menu_bibd(t = 3, k = 2, r = 4)
</code></pre>

<hr>
<h2 id='menu_crd'>Completely randomised design</h2><span id='topic+menu_crd'></span>

<h3>Description</h3>

<p>Completely randomised design
</p>


<h3>Usage</h3>

<pre><code class='language-R'>menu_crd(
  t = random_integer_small(),
  n = random_integer_medium(min = t),
  r = NULL,
  seed = random_seed_number()
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="menu_crd_+3A_t">t</code></td>
<td>
<p>The number of treatment levels</p>
</td></tr>
<tr><td><code id="menu_crd_+3A_n">n</code></td>
<td>
<p>The number of experimental units</p>
</td></tr>
<tr><td><code id="menu_crd_+3A_r">r</code></td>
<td>
<p>(Optional) The number of replicates.</p>
</td></tr>
<tr><td><code id="menu_crd_+3A_seed">seed</code></td>
<td>
<p>A scalar value for computational reproducibility.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A recipe for completely randomised design.
</p>


<h3>See Also</h3>

<p>Other recipe-designs: 
<code><a href="#topic+menu_bibd">menu_bibd</a>()</code>,
<code><a href="#topic+menu_factorial">menu_factorial</a>()</code>,
<code><a href="#topic+menu_graeco">menu_graeco</a>()</code>,
<code><a href="#topic+menu_hyper_graeco">menu_hyper_graeco</a>()</code>,
<code><a href="#topic+menu_lsd">menu_lsd</a>()</code>,
<code><a href="#topic+menu_rcbd">menu_rcbd</a>()</code>,
<code><a href="#topic+menu_split">menu_split</a>()</code>,
<code><a href="#topic+menu_strip">menu_strip</a>()</code>,
<code><a href="#topic+menu_youden">menu_youden</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>menu_crd(t = 3, n = 10)
</code></pre>

<hr>
<h2 id='menu_factorial'>Prepare a factorial design</h2><span id='topic+menu_factorial'></span>

<h3>Description</h3>

<p>Prepare a factorial design
</p>


<h3>Usage</h3>

<pre><code class='language-R'>menu_factorial(
  trt = c(random_integer_small(), random_integer_small()),
  r = random_integer_small(),
  design = c("crd", "rcbd"),
  seed = random_seed_number()
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="menu_factorial_+3A_trt">trt</code></td>
<td>
<p>A vector of the number of levels for each treatment factor.</p>
</td></tr>
<tr><td><code id="menu_factorial_+3A_r">r</code></td>
<td>
<p>The number of replications for each treatment level.</p>
</td></tr>
<tr><td><code id="menu_factorial_+3A_design">design</code></td>
<td>
<p>The unit structure: &quot;crd&quot; or &quot;rcbd&quot;. The default is &quot;crd&quot;.</p>
</td></tr>
<tr><td><code id="menu_factorial_+3A_seed">seed</code></td>
<td>
<p>A scalar value for computational reproducibility.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A recipe for factorial design.
</p>


<h3>See Also</h3>

<p>Other recipe-designs: 
<code><a href="#topic+menu_bibd">menu_bibd</a>()</code>,
<code><a href="#topic+menu_crd">menu_crd</a>()</code>,
<code><a href="#topic+menu_graeco">menu_graeco</a>()</code>,
<code><a href="#topic+menu_hyper_graeco">menu_hyper_graeco</a>()</code>,
<code><a href="#topic+menu_lsd">menu_lsd</a>()</code>,
<code><a href="#topic+menu_rcbd">menu_rcbd</a>()</code>,
<code><a href="#topic+menu_split">menu_split</a>()</code>,
<code><a href="#topic+menu_strip">menu_strip</a>()</code>,
<code><a href="#topic+menu_youden">menu_youden</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>menu_factorial(trt = c(3, 2), r = 2, design = "crd")
</code></pre>

<hr>
<h2 id='menu_graeco'>Graeco-Latin Square Design</h2><span id='topic+menu_graeco'></span>

<h3>Description</h3>

<p>Graeco-Latin Square Design
</p>


<h3>Usage</h3>

<pre><code class='language-R'>menu_graeco(t = random_integer_small(), seed = random_seed_number())
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="menu_graeco_+3A_t">t</code></td>
<td>
<p>The number of treatments.</p>
</td></tr>
<tr><td><code id="menu_graeco_+3A_seed">seed</code></td>
<td>
<p>A scalar value for computational reproducibility.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A recipe for Graeco-Latin square design.
</p>


<h3>See Also</h3>

<p>Other recipe-designs: 
<code><a href="#topic+menu_bibd">menu_bibd</a>()</code>,
<code><a href="#topic+menu_crd">menu_crd</a>()</code>,
<code><a href="#topic+menu_factorial">menu_factorial</a>()</code>,
<code><a href="#topic+menu_hyper_graeco">menu_hyper_graeco</a>()</code>,
<code><a href="#topic+menu_lsd">menu_lsd</a>()</code>,
<code><a href="#topic+menu_rcbd">menu_rcbd</a>()</code>,
<code><a href="#topic+menu_split">menu_split</a>()</code>,
<code><a href="#topic+menu_strip">menu_strip</a>()</code>,
<code><a href="#topic+menu_youden">menu_youden</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>menu_graeco(t = 3)
</code></pre>

<hr>
<h2 id='menu_hyper_graeco'>Hyper-Graeco-Latin Square Design</h2><span id='topic+menu_hyper_graeco'></span>

<h3>Description</h3>

<p>Hyper-Graeco-Latin Square Design
</p>


<h3>Usage</h3>

<pre><code class='language-R'>menu_hyper_graeco(t = random_integer_small(), seed = random_seed_number())
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="menu_hyper_graeco_+3A_t">t</code></td>
<td>
<p>The number of treatments</p>
</td></tr>
<tr><td><code id="menu_hyper_graeco_+3A_seed">seed</code></td>
<td>
<p>A scalar value for computational reproducibility.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A recipe Hyper-Graeco-Latin square design.
</p>


<h3>See Also</h3>

<p>Other recipe-designs: 
<code><a href="#topic+menu_bibd">menu_bibd</a>()</code>,
<code><a href="#topic+menu_crd">menu_crd</a>()</code>,
<code><a href="#topic+menu_factorial">menu_factorial</a>()</code>,
<code><a href="#topic+menu_graeco">menu_graeco</a>()</code>,
<code><a href="#topic+menu_lsd">menu_lsd</a>()</code>,
<code><a href="#topic+menu_rcbd">menu_rcbd</a>()</code>,
<code><a href="#topic+menu_split">menu_split</a>()</code>,
<code><a href="#topic+menu_strip">menu_strip</a>()</code>,
<code><a href="#topic+menu_youden">menu_youden</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>menu_hyper_graeco(t = 3)
</code></pre>

<hr>
<h2 id='menu_lsd'>Prepare classical Latin square design</h2><span id='topic+menu_lsd'></span>

<h3>Description</h3>

<p>Prepare classical Latin square design
</p>


<h3>Usage</h3>

<pre><code class='language-R'>menu_lsd(t = random_integer_small(), seed = random_seed_number())
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="menu_lsd_+3A_t">t</code></td>
<td>
<p>The number of treatments</p>
</td></tr>
<tr><td><code id="menu_lsd_+3A_seed">seed</code></td>
<td>
<p>A scalar value for computational reproducibility.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A recipe Latin square design.
</p>


<h3>See Also</h3>

<p>Other recipe-designs: 
<code><a href="#topic+menu_bibd">menu_bibd</a>()</code>,
<code><a href="#topic+menu_crd">menu_crd</a>()</code>,
<code><a href="#topic+menu_factorial">menu_factorial</a>()</code>,
<code><a href="#topic+menu_graeco">menu_graeco</a>()</code>,
<code><a href="#topic+menu_hyper_graeco">menu_hyper_graeco</a>()</code>,
<code><a href="#topic+menu_rcbd">menu_rcbd</a>()</code>,
<code><a href="#topic+menu_split">menu_split</a>()</code>,
<code><a href="#topic+menu_strip">menu_strip</a>()</code>,
<code><a href="#topic+menu_youden">menu_youden</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>menu_lsd(t = 3)
</code></pre>

<hr>
<h2 id='menu_rcbd'>Prepare a randomised complete block design</h2><span id='topic+menu_rcbd'></span>

<h3>Description</h3>

<p>Prepare a randomised complete block design
</p>


<h3>Usage</h3>

<pre><code class='language-R'>menu_rcbd(
  t = random_integer_small(),
  r = random_integer_small(),
  seed = random_seed_number()
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="menu_rcbd_+3A_t">t</code></td>
<td>
<p>The number of treatments.</p>
</td></tr>
<tr><td><code id="menu_rcbd_+3A_r">r</code></td>
<td>
<p>The number of replications for each treatment level.</p>
</td></tr>
<tr><td><code id="menu_rcbd_+3A_seed">seed</code></td>
<td>
<p>A scalar value for computational reproducibility.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A recipe for randomised complete block design.
</p>


<h3>See Also</h3>

<p>Other recipe-designs: 
<code><a href="#topic+menu_bibd">menu_bibd</a>()</code>,
<code><a href="#topic+menu_crd">menu_crd</a>()</code>,
<code><a href="#topic+menu_factorial">menu_factorial</a>()</code>,
<code><a href="#topic+menu_graeco">menu_graeco</a>()</code>,
<code><a href="#topic+menu_hyper_graeco">menu_hyper_graeco</a>()</code>,
<code><a href="#topic+menu_lsd">menu_lsd</a>()</code>,
<code><a href="#topic+menu_split">menu_split</a>()</code>,
<code><a href="#topic+menu_strip">menu_strip</a>()</code>,
<code><a href="#topic+menu_youden">menu_youden</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>menu_rcbd(t = 3, r = 2)
</code></pre>

<hr>
<h2 id='menu_split'>Split-unit design</h2><span id='topic+menu_split'></span>

<h3>Description</h3>

<p>Originally referred to as split-plot design when it was first used.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>menu_split(
  t1 = random_integer_small(),
  t2 = random_integer_small(),
  r = random_integer_small(),
  seed = random_seed_number()
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="menu_split_+3A_t1">t1</code></td>
<td>
<p>The number of treatment levels for the main plots.</p>
</td></tr>
<tr><td><code id="menu_split_+3A_t2">t2</code></td>
<td>
<p>The number of treatment levels for the subplots.</p>
</td></tr>
<tr><td><code id="menu_split_+3A_r">r</code></td>
<td>
<p>The number of replications for each treatment level.</p>
</td></tr>
<tr><td><code id="menu_split_+3A_seed">seed</code></td>
<td>
<p>A scalar value for computational reproducibility.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A recipe split-plot design.
</p>


<h3>See Also</h3>

<p>Other recipe-designs: 
<code><a href="#topic+menu_bibd">menu_bibd</a>()</code>,
<code><a href="#topic+menu_crd">menu_crd</a>()</code>,
<code><a href="#topic+menu_factorial">menu_factorial</a>()</code>,
<code><a href="#topic+menu_graeco">menu_graeco</a>()</code>,
<code><a href="#topic+menu_hyper_graeco">menu_hyper_graeco</a>()</code>,
<code><a href="#topic+menu_lsd">menu_lsd</a>()</code>,
<code><a href="#topic+menu_rcbd">menu_rcbd</a>()</code>,
<code><a href="#topic+menu_strip">menu_strip</a>()</code>,
<code><a href="#topic+menu_youden">menu_youden</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>menu_split(t1 = 3, t2 = 2, r = 4)
</code></pre>

<hr>
<h2 id='menu_strip'>Strip-unit design</h2><span id='topic+menu_strip'></span>

<h3>Description</h3>

<p>Strip-unit design
</p>


<h3>Usage</h3>

<pre><code class='language-R'>menu_strip(
  t1 = random_integer_small(),
  t2 = random_integer_small(),
  r = random_integer_small(),
  seed = random_seed_number()
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="menu_strip_+3A_t1">t1</code></td>
<td>
<p>The number of treatment levels for the main plots.</p>
</td></tr>
<tr><td><code id="menu_strip_+3A_t2">t2</code></td>
<td>
<p>The number of treatment levels for the subplots.</p>
</td></tr>
<tr><td><code id="menu_strip_+3A_r">r</code></td>
<td>
<p>The number of replications for each treatment level.</p>
</td></tr>
<tr><td><code id="menu_strip_+3A_seed">seed</code></td>
<td>
<p>A scalar value for computational reproducibility.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A recipe strip-unit design.
</p>


<h3>See Also</h3>

<p>Other recipe-designs: 
<code><a href="#topic+menu_bibd">menu_bibd</a>()</code>,
<code><a href="#topic+menu_crd">menu_crd</a>()</code>,
<code><a href="#topic+menu_factorial">menu_factorial</a>()</code>,
<code><a href="#topic+menu_graeco">menu_graeco</a>()</code>,
<code><a href="#topic+menu_hyper_graeco">menu_hyper_graeco</a>()</code>,
<code><a href="#topic+menu_lsd">menu_lsd</a>()</code>,
<code><a href="#topic+menu_rcbd">menu_rcbd</a>()</code>,
<code><a href="#topic+menu_split">menu_split</a>()</code>,
<code><a href="#topic+menu_youden">menu_youden</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>menu_strip(t1 = 3, t2 = 3, r = 2)
</code></pre>

<hr>
<h2 id='menu_youden'>Youden square design</h2><span id='topic+menu_youden'></span>

<h3>Description</h3>

<p>Youden square design
</p>


<h3>Usage</h3>

<pre><code class='language-R'>menu_youden(
  nc = random_integer_small(),
  t = random_integer_small(min = nc + 1),
  seed = random_seed_number()
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="menu_youden_+3A_nc">nc</code></td>
<td>
<p>The number of columns.</p>
</td></tr>
<tr><td><code id="menu_youden_+3A_t">t</code></td>
<td>
<p>The number of treatments.</p>
</td></tr>
<tr><td><code id="menu_youden_+3A_seed">seed</code></td>
<td>
<p>A scalar value for computational reproducibility.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A recipe Youden square design.
</p>


<h3>See Also</h3>

<p>Other recipe-designs: 
<code><a href="#topic+menu_bibd">menu_bibd</a>()</code>,
<code><a href="#topic+menu_crd">menu_crd</a>()</code>,
<code><a href="#topic+menu_factorial">menu_factorial</a>()</code>,
<code><a href="#topic+menu_graeco">menu_graeco</a>()</code>,
<code><a href="#topic+menu_hyper_graeco">menu_hyper_graeco</a>()</code>,
<code><a href="#topic+menu_lsd">menu_lsd</a>()</code>,
<code><a href="#topic+menu_rcbd">menu_rcbd</a>()</code>,
<code><a href="#topic+menu_split">menu_split</a>()</code>,
<code><a href="#topic+menu_strip">menu_strip</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>menu_youden(nc = 4, t = 5)
</code></pre>

<hr>
<h2 id='nested_in'>Specify the nesting or conditional structure for units or treatments</h2><span id='topic+nested_in'></span><span id='topic+conditioned_on'></span>

<h3>Description</h3>

<p>Conditional treatment is different to nested units as the levels are assumed to be
distinct for the latter but not for the former.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>nested_in(x, ...)

conditioned_on(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="nested_in_+3A_x">x</code></td>
<td>
<p>The name of the parent unit to nest under.</p>
</td></tr>
<tr><td><code id="nested_in_+3A_...">...</code></td>
<td>
<p>a single number OR a sequence of two-sided formula where the
left-hand side corresponds to the name of the level (or the level number) of <code>x</code>
and the right-hand side is an integer specifying the number of levels nested under the
corresponding levels.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Currently when specifying conditional treatment, only character vectors
are accepted on the RHS.
</p>


<h3>Value</h3>

<p>A nested level.
</p>


<h3>See Also</h3>

<p>See <code><a href="#topic+set_units">set_units()</a></code> for examples of how to use this.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>design("Split-Plot Design | Split-Unit Design") %&gt;%
  set_units(mainplot = 60,
            subplot = nested_in(mainplot, 10))
</code></pre>

<hr>
<h2 id='nesting_structure'>Get the nesting structure for the units</h2><span id='topic+nesting_structure'></span>

<h3>Description</h3>

<p>Get the nesting structure for the units
</p>


<h3>Usage</h3>

<pre><code class='language-R'>nesting_structure(design)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="nesting_structure_+3A_design">design</code></td>
<td>
<p>An edibble design</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Return a named list. Only shows the direct parent.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>nesting_structure(takeout(menu_split()))
</code></pre>

<hr>
<h2 id='new_edibble'>An edibble table constructor</h2><span id='topic+new_edibble'></span><span id='topic+as_edibble'></span>

<h3>Description</h3>

<p>This helps to construct a new edibble table which is a special type
of tibble.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>new_edibble(.data, ..., .design = NULL, .class = NULL)

as_edibble(.data, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="new_edibble_+3A_.data">.data</code></td>
<td>
<p>data frame or list of the same size.</p>
</td></tr>
<tr><td><code id="new_edibble_+3A_...">...</code></td>
<td>
<p>Passed to <code>new_tibble</code>.</p>
</td></tr>
<tr><td><code id="new_edibble_+3A_.design">.design</code></td>
<td>
<p>An edibble graph object.</p>
</td></tr>
<tr><td><code id="new_edibble_+3A_.class">.class</code></td>
<td>
<p>Subclasses for edibble table. The default is NULL.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An edibble table.
</p>

<hr>
<h2 id='order_trts'>A custom ordering algorithm</h2><span id='topic+order_trts'></span>

<h3>Description</h3>

<p>A custom ordering algorithm
</p>


<h3>Usage</h3>

<pre><code class='language-R'>order_trts(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="order_trts_+3A_x">x</code></td>
<td>
<p>A string specifying the class</p>
</td></tr>
<tr><td><code id="order_trts_+3A_...">...</code></td>
<td>
<p>Other arguments.</p>
</td></tr>
</table>

<hr>
<h2 id='pivot_trts_widelist'>Pivot treatments to a wider list or table format</h2><span id='topic+pivot_trts_widelist'></span><span id='topic+pivot_trts_widetable'></span>

<h3>Description</h3>

<p>Pivot treatments to a wider list or table format
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pivot_trts_widelist(.data, trts = NULL, fcts = NULL, drop = FALSE)

pivot_trts_widetable(.data, trts = NULL, fcts = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="pivot_trts_widelist_+3A_.data">.data</code></td>
<td>
<p>An edibble table.</p>
</td></tr>
<tr><td><code id="pivot_trts_widelist_+3A_trts">trts</code></td>
<td>
<p>A vector of treatment (tidyselect compatible). By default it is
NULL and includes all the treatments.</p>
</td></tr>
<tr><td><code id="pivot_trts_widelist_+3A_fcts">fcts</code></td>
<td>
<p>A vector of factors in the edibble table.</p>
</td></tr>
<tr><td><code id="pivot_trts_widelist_+3A_drop">drop</code></td>
<td>
<p>Whether the resulting list should drop to a vector within each list
element if there is only one column. Default is FALSE.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A named list where elements are the data and the names are treatments.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>pivot_trts_widelist(takeout(menu_crd(t = 5, n = 20)))
</code></pre>

<hr>
<h2 id='pivot_wider_by'>Pivot factor to a wider list</h2><span id='topic+pivot_wider_by'></span>

<h3>Description</h3>

<p>This function makes it easier to see which units or records are associated
with a particular level of factor.
The arguments closely follow <code><a href="tidyr.html#topic+pivot_wider">tidyr::pivot_wider()</a></code>, but the major difference
is that it is aware of the relationships between columns and makes use of
this to present to you information without unnecessary duplication.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pivot_wider_by(
  data,
  id_cols = NULL,
  id_expand = FALSE,
  names_from = where(is_trt),
  names_prefix = "",
  names_sep = ":",
  names_glue = NULL,
  names_sort = FALSE,
  names_vary = "fastest",
  names_expand = FALSE,
  names_repair = "check_unique",
  values_from = NULL,
  values_fill = NULL,
  values_fn = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="pivot_wider_by_+3A_data">data</code></td>
<td>
<p>An edibble table</p>
</td></tr>
<tr><td><code id="pivot_wider_by_+3A_id_cols">id_cols</code></td>
<td>
<p>Columns in the data where the levels correspond to a unique
level on the row.</p>
</td></tr>
<tr><td><code id="pivot_wider_by_+3A_id_expand">id_expand</code></td>
<td>
<p>If multiple columns are selected, whether all combinations of
the levels should be taken into account.</p>
</td></tr>
<tr><td><code id="pivot_wider_by_+3A_names_from">names_from</code></td>
<td>
<p>An expression specifying which columns to pivot from.</p>
</td></tr>
<tr><td><code id="pivot_wider_by_+3A_names_prefix">names_prefix</code></td>
<td>
<p>A prefix to add to the resulting column names.</p>
</td></tr>
<tr><td><code id="pivot_wider_by_+3A_names_sep">names_sep</code></td>
<td>
<p>A separator to use between column names in the resulting wide format.</p>
</td></tr>
<tr><td><code id="pivot_wider_by_+3A_names_glue">names_glue</code></td>
<td>
<p>A glue specification to control column names.</p>
</td></tr>
<tr><td><code id="pivot_wider_by_+3A_names_sort">names_sort</code></td>
<td>
<p>A logical indicating whether to sort the resulting column names.</p>
</td></tr>
<tr><td><code id="pivot_wider_by_+3A_names_vary">names_vary</code></td>
<td>
<p>A character vector of options to specify how to handle varying identifiers.</p>
</td></tr>
<tr><td><code id="pivot_wider_by_+3A_names_expand">names_expand</code></td>
<td>
<p>A logical indicating whether to expand identifiers in the column names.</p>
</td></tr>
<tr><td><code id="pivot_wider_by_+3A_names_repair">names_repair</code></td>
<td>
<p>A method to handle non-unique resulting column names.</p>
</td></tr>
<tr><td><code id="pivot_wider_by_+3A_values_from">values_from</code></td>
<td>
<p>A character vector specifying columns to use as values in the wide format.</p>
</td></tr>
<tr><td><code id="pivot_wider_by_+3A_values_fill">values_fill</code></td>
<td>
<p>A value or function to fill missing values.</p>
</td></tr>
<tr><td><code id="pivot_wider_by_+3A_values_fn">values_fn</code></td>
<td>
<p>A function to aggregate values.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+split_by">split_by()</a></code> and <code><a href="#topic+count_by">count_by()</a></code>
</p>

<hr>
<h2 id='plot.edbl_design'>Interactive plot of the edibble design</h2><span id='topic+plot.edbl_design'></span><span id='topic+plot.edbl_table'></span><span id='topic+plot_fct_graph'></span><span id='topic+plot_lvl_graph'></span>

<h3>Description</h3>

<p>Interactive plot of the edibble design
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'edbl_design'
plot(
  x,
  which = c("factors", "levels"),
  width = "100%",
  height = NULL,
  seed = 1,
  title = NULL,
  subtitle = NULL,
  footer = NULL,
  background = "transparent",
  view = c("show-buttons", "hide-buttons", "static"),
  ...
)

## S3 method for class 'edbl_table'
plot(x, ...)

plot_fct_graph(
  x,
  width = "100%",
  height = NULL,
  seed = 1,
  title = NULL,
  subtitle = NULL,
  footer = NULL,
  background = "transparent",
  view = c("show-buttons", "hide-buttons", "static"),
  ...
)

plot_lvl_graph(
  x,
  width = "100%",
  height = NULL,
  seed = 1,
  title = NULL,
  subtitle = NULL,
  footer = NULL,
  background = "transparent",
  view = c("show-buttons", "hide-buttons", "static"),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot.edbl_design_+3A_x">x</code></td>
<td>
<p>An edibble design.</p>
</td></tr>
<tr><td><code id="plot.edbl_design_+3A_which">which</code></td>
<td>
<p>A string of either &quot;factors&quot; or &quot;levels&quot;.</p>
</td></tr>
<tr><td><code id="plot.edbl_design_+3A_width">width</code>, <code id="plot.edbl_design_+3A_height">height</code></td>
<td>
<p>The width and height of the plot.</p>
</td></tr>
<tr><td><code id="plot.edbl_design_+3A_seed">seed</code></td>
<td>
<p>A seed number so same plot is always generated.</p>
</td></tr>
<tr><td><code id="plot.edbl_design_+3A_title">title</code>, <code id="plot.edbl_design_+3A_subtitle">subtitle</code>, <code id="plot.edbl_design_+3A_footer">footer</code></td>
<td>
<p>The title, subtitle or footer of the plot.
By default it uses the name from the <code>x</code> object as the title while rest is empty.
To modify the look of the text, you can pass a character string consisting of valid
for input style value in an HTML object, e.g. &quot;font-size: 18px;font-family:serif;&quot; as a
named vector where the name corresponds to the text to display, e.g. <code>c("Title" = "font-size:20px;")</code>.</p>
</td></tr>
<tr><td><code id="plot.edbl_design_+3A_background">background</code></td>
<td>
<p>The background color of the plot. Default is transparent. The input
can be a color name (e.g. &quot;white&quot;), a HEX value (&quot;#FFFFFF&quot;), or rgb/rgba in the format like rgba(0, 0, 0, 0).</p>
</td></tr>
<tr><td><code id="plot.edbl_design_+3A_view">view</code></td>
<td>
<p>A string of either &quot;show-buttons&quot; (default), &quot;hide-buttons&quot;, &quot;static&quot;</p>
</td></tr>
<tr><td><code id="plot.edbl_design_+3A_...">...</code></td>
<td>
<p>Currently unused.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A plot.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>plot(takeout(menu_crd(t = 4, n = 20)))
</code></pre>

<hr>
<h2 id='Provenance'>An object to query, record and modify an edibble graph</h2><span id='topic+Provenance'></span>

<h3>Description</h3>

<p>An object to query, record and modify an edibble graph
</p>
<p>An object to query, record and modify an edibble graph
</p>


<h3>Details</h3>

<p>The Provenance contains a set of operations to manipulate the nodes and edges of
the edibble graph object.
</p>


<h3>Active bindings</h3>

<div class="r6-active-bindings">

<dl>
<dt><code>fct_nodes</code></dt><dd><p>Get the factor nodes</p>
</dd>
<dt><code>lvl_nodes</code></dt><dd><p>Get the level nodes</p>
</dd>
<dt><code>fct_edges</code></dt><dd><p>Get the factor edges</p>
</dd>
<dt><code>lvl_edges</code></dt><dd><p>Get the level edges</p>
</dd>
<dt><code>fct_n</code></dt><dd><p>Get the number of nodes in factor graph</p>
</dd>
<dt><code>lvl_n</code></dt><dd><p>Get the number of nodes in level graph</p>
</dd>
<dt><code>rcrd_ids</code></dt><dd><p>Get the ids for all edbl_rcrd factors.</p>
</dd>
<dt><code>unit_ids</code></dt><dd><p>Get the ids for all edbl_unit factors.</p>
</dd>
<dt><code>trt_ids</code></dt><dd><p>Get the ids for all edbl_trt factors.</p>
</dd>
<dt><code>is_connected</code></dt><dd><p>Check if nodes are connected.
Get a new factor id.
Get a new level id.
Given a particular DAG, return a topological order
Remember that there could be more than one order.</p>
</dd>
</dl>

</div>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-Provenance-new"><code>Provenance$new()</code></a>
</p>
</li>
<li> <p><a href="#method-Provenance-set_title"><code>Provenance$set_title()</code></a>
</p>
</li>
<li> <p><a href="#method-Provenance-set_name"><code>Provenance$set_name()</code></a>
</p>
</li>
<li> <p><a href="#method-Provenance-set_validation"><code>Provenance$set_validation()</code></a>
</p>
</li>
<li> <p><a href="#method-Provenance-set_simulate"><code>Provenance$set_simulate()</code></a>
</p>
</li>
<li> <p><a href="#method-Provenance-reactivate"><code>Provenance$reactivate()</code></a>
</p>
</li>
<li> <p><a href="#method-Provenance-deactivate"><code>Provenance$deactivate()</code></a>
</p>
</li>
<li> <p><a href="#method-Provenance-fct_id"><code>Provenance$fct_id()</code></a>
</p>
</li>
<li> <p><a href="#method-Provenance-fct_id_parent"><code>Provenance$fct_id_parent()</code></a>
</p>
</li>
<li> <p><a href="#method-Provenance-fct_id_child"><code>Provenance$fct_id_child()</code></a>
</p>
</li>
<li> <p><a href="#method-Provenance-fct_id_ancestor"><code>Provenance$fct_id_ancestor()</code></a>
</p>
</li>
<li> <p><a href="#method-Provenance-fct_id_descendant"><code>Provenance$fct_id_descendant()</code></a>
</p>
</li>
<li> <p><a href="#method-Provenance-fct_id_leaves"><code>Provenance$fct_id_leaves()</code></a>
</p>
</li>
<li> <p><a href="#method-Provenance-lvl_id"><code>Provenance$lvl_id()</code></a>
</p>
</li>
<li> <p><a href="#method-Provenance-lvl_id_parent"><code>Provenance$lvl_id_parent()</code></a>
</p>
</li>
<li> <p><a href="#method-Provenance-lvl_id_child"><code>Provenance$lvl_id_child()</code></a>
</p>
</li>
<li> <p><a href="#method-Provenance-lvl_id_ancestor"><code>Provenance$lvl_id_ancestor()</code></a>
</p>
</li>
<li> <p><a href="#method-Provenance-fct_id_from_lvl_id"><code>Provenance$fct_id_from_lvl_id()</code></a>
</p>
</li>
<li> <p><a href="#method-Provenance-fct_id_from_lvl_values"><code>Provenance$fct_id_from_lvl_values()</code></a>
</p>
</li>
<li> <p><a href="#method-Provenance-lvl_id_from_fct_id"><code>Provenance$lvl_id_from_fct_id()</code></a>
</p>
</li>
<li> <p><a href="#method-Provenance-fct_names"><code>Provenance$fct_names()</code></a>
</p>
</li>
<li> <p><a href="#method-Provenance-unit_names"><code>Provenance$unit_names()</code></a>
</p>
</li>
<li> <p><a href="#method-Provenance-trt_names"><code>Provenance$trt_names()</code></a>
</p>
</li>
<li> <p><a href="#method-Provenance-rcrd_names"><code>Provenance$rcrd_names()</code></a>
</p>
</li>
<li> <p><a href="#method-Provenance-rcrd_class"><code>Provenance$rcrd_class()</code></a>
</p>
</li>
<li> <p><a href="#method-Provenance-lvl_values"><code>Provenance$lvl_values()</code></a>
</p>
</li>
<li> <p><a href="#method-Provenance-unit_values"><code>Provenance$unit_values()</code></a>
</p>
</li>
<li> <p><a href="#method-Provenance-trt_values"><code>Provenance$trt_values()</code></a>
</p>
</li>
<li> <p><a href="#method-Provenance-rcrd_values"><code>Provenance$rcrd_values()</code></a>
</p>
</li>
<li> <p><a href="#method-Provenance-fct_role"><code>Provenance$fct_role()</code></a>
</p>
</li>
<li> <p><a href="#method-Provenance-fct_levels"><code>Provenance$fct_levels()</code></a>
</p>
</li>
<li> <p><a href="#method-Provenance-fct_levels_id_to_edbl_fct"><code>Provenance$fct_levels_id_to_edbl_fct()</code></a>
</p>
</li>
<li> <p><a href="#method-Provenance-fct_levels_id_to_value"><code>Provenance$fct_levels_id_to_value()</code></a>
</p>
</li>
<li> <p><a href="#method-Provenance-fct_levels_value_to_id"><code>Provenance$fct_levels_value_to_id()</code></a>
</p>
</li>
<li> <p><a href="#method-Provenance-fct_exists"><code>Provenance$fct_exists()</code></a>
</p>
</li>
<li> <p><a href="#method-Provenance-trt_exists"><code>Provenance$trt_exists()</code></a>
</p>
</li>
<li> <p><a href="#method-Provenance-unit_exists"><code>Provenance$unit_exists()</code></a>
</p>
</li>
<li> <p><a href="#method-Provenance-rcrd_exists"><code>Provenance$rcrd_exists()</code></a>
</p>
</li>
<li> <p><a href="#method-Provenance-append_fct_nodes"><code>Provenance$append_fct_nodes()</code></a>
</p>
</li>
<li> <p><a href="#method-Provenance-append_lvl_nodes"><code>Provenance$append_lvl_nodes()</code></a>
</p>
</li>
<li> <p><a href="#method-Provenance-append_fct_edges"><code>Provenance$append_fct_edges()</code></a>
</p>
</li>
<li> <p><a href="#method-Provenance-append_lvl_edges"><code>Provenance$append_lvl_edges()</code></a>
</p>
</li>
<li> <p><a href="#method-Provenance-serve_units"><code>Provenance$serve_units()</code></a>
</p>
</li>
<li> <p><a href="#method-Provenance-serve_trts"><code>Provenance$serve_trts()</code></a>
</p>
</li>
<li> <p><a href="#method-Provenance-serve_rcrds"><code>Provenance$serve_rcrds()</code></a>
</p>
</li>
<li> <p><a href="#method-Provenance-make_trts_table"><code>Provenance$make_trts_table()</code></a>
</p>
</li>
<li> <p><a href="#method-Provenance-graph_subset"><code>Provenance$graph_subset()</code></a>
</p>
</li>
<li> <p><a href="#method-Provenance-save_seed"><code>Provenance$save_seed()</code></a>
</p>
</li>
<li> <p><a href="#method-Provenance-get_title"><code>Provenance$get_title()</code></a>
</p>
</li>
<li> <p><a href="#method-Provenance-get_validation"><code>Provenance$get_validation()</code></a>
</p>
</li>
<li> <p><a href="#method-Provenance-get_trail"><code>Provenance$get_trail()</code></a>
</p>
</li>
<li> <p><a href="#method-Provenance-get_graph"><code>Provenance$get_graph()</code></a>
</p>
</li>
<li> <p><a href="#method-Provenance-get_seed"><code>Provenance$get_seed()</code></a>
</p>
</li>
<li> <p><a href="#method-Provenance-get_session_info"><code>Provenance$get_session_info()</code></a>
</p>
</li>
<li> <p><a href="#method-Provenance-get_edibble_version"><code>Provenance$get_edibble_version()</code></a>
</p>
</li>
<li> <p><a href="#method-Provenance-get_simulate"><code>Provenance$get_simulate()</code></a>
</p>
</li>
<li> <p><a href="#method-Provenance-get_simulate_result_env"><code>Provenance$get_simulate_result_env()</code></a>
</p>
</li>
<li> <p><a href="#method-Provenance-mapping"><code>Provenance$mapping()</code></a>
</p>
</li>
<li> <p><a href="#method-Provenance-mapping_to_unit"><code>Provenance$mapping_to_unit()</code></a>
</p>
</li>
<li> <p><a href="#method-Provenance-record_step"><code>Provenance$record_step()</code></a>
</p>
</li>
<li> <p><a href="#method-Provenance-lvl_mapping"><code>Provenance$lvl_mapping()</code></a>
</p>
</li>
<li> <p><a href="#method-Provenance-record_track_external"><code>Provenance$record_track_external()</code></a>
</p>
</li>
<li> <p><a href="#method-Provenance-fct_id_links"><code>Provenance$fct_id_links()</code></a>
</p>
</li>
<li> <p><a href="#method-Provenance-fct_graph_components"><code>Provenance$fct_graph_components()</code></a>
</p>
</li>
<li> <p><a href="#method-Provenance-lvl_graph_components"><code>Provenance$lvl_graph_components()</code></a>
</p>
</li>
<li> <p><a href="#method-Provenance-clone"><code>Provenance$clone()</code></a>
</p>
</li></ul>


<hr>
<a id="method-Provenance-new"></a>



<h4>Method <code>new()</code></h4>

<p>Initialise function
</p>


<h5>Usage</h5>

<div class="r"><pre>Provenance$new(graph = NULL)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>graph</code></dt><dd><p>An edibble graph.</p>
</dd>
</dl>

</div>


<hr>
<a id="method-Provenance-set_title"></a>



<h4>Method <code>set_title()</code></h4>

<p>Set the title.
</p>


<h5>Usage</h5>

<div class="r"><pre>Provenance$set_title(title)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>title</code></dt><dd><p>The title of the experiment</p>
</dd>
</dl>

</div>


<hr>
<a id="method-Provenance-set_name"></a>



<h4>Method <code>set_name()</code></h4>

<p>Set the name.
</p>


<h5>Usage</h5>

<div class="r"><pre>Provenance$set_name(name)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>name</code></dt><dd><p>The name of the edibble graph object.</p>
</dd>
</dl>

</div>


<hr>
<a id="method-Provenance-set_validation"></a>



<h4>Method <code>set_validation()</code></h4>

<p>Set the validation.
</p>


<h5>Usage</h5>

<div class="r"><pre>Provenance$set_validation(validation, type = "rcrds")</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>validation</code></dt><dd><p>The validation statement.</p>
</dd>
<dt><code>type</code></dt><dd><p>The type of validation.</p>
</dd>
</dl>

</div>


<hr>
<a id="method-Provenance-set_simulate"></a>



<h4>Method <code>set_simulate()</code></h4>

<p>Set the simulation process
</p>


<h5>Usage</h5>

<div class="r"><pre>Provenance$set_simulate(name, process, rcrds)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>name</code></dt><dd><p>The name of the process</p>
</dd>
<dt><code>process</code></dt><dd><p>A function to simulate the record</p>
</dd>
<dt><code>rcrds</code></dt><dd><p>The record factor name simulating for.</p>
</dd>
</dl>

</div>


<hr>
<a id="method-Provenance-reactivate"></a>



<h4>Method <code>reactivate()</code></h4>

<p>Reactivate the graph in the provenance object.
</p>


<h5>Usage</h5>

<div class="r"><pre>Provenance$reactivate(
  design,
  overwrite = c("graph", "anatomy", "recipe", "validation", "simulate",
    "simualte_result")
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>design</code></dt><dd><p>An edibble design</p>
</dd>
<dt><code>overwrite</code></dt><dd><p>A vector of character to overwrite from the
supplied design object.</p>
</dd>
</dl>

</div>


<hr>
<a id="method-Provenance-deactivate"></a>



<h4>Method <code>deactivate()</code></h4>

<p>Deactivate the provenance object.
</p>


<h5>Usage</h5>

<div class="r"><pre>Provenance$deactivate(delete = c("graph", "anatomy", "recipe", "validation"))</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>delete</code></dt><dd><p>A vector of character to delete.</p>
</dd>
</dl>

</div>


<hr>
<a id="method-Provenance-fct_id"></a>



<h4>Method <code>fct_id()</code></h4>

<p>Get the id based on either the name of the factor node.
If none supplied then it will give all.
</p>


<h5>Usage</h5>

<div class="r"><pre>Provenance$fct_id(name = NULL, role = NULL)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>name</code></dt><dd><p>The name of the node.</p>
</dd>
<dt><code>role</code></dt><dd><p>The role for the node.</p>
</dd>
</dl>

</div>


<hr>
<a id="method-Provenance-fct_id_parent"></a>



<h4>Method <code>fct_id_parent()</code></h4>

<p>Get the factor parent ids
</p>


<h5>Usage</h5>

<div class="r"><pre>Provenance$fct_id_parent(id = NULL, role = NULL, type = NULL)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>id</code></dt><dd><p>The id of the corresponding node.</p>
</dd>
<dt><code>role</code></dt><dd><p>The role for the node.</p>
</dd>
<dt><code>type</code></dt><dd><p>The type of edge link.</p>
</dd>
</dl>

</div>


<hr>
<a id="method-Provenance-fct_id_child"></a>



<h4>Method <code>fct_id_child()</code></h4>

<p>Get the factor child ids. If <code>role</code> is
supplied then the child has to fit <code>role</code>
</p>


<h5>Usage</h5>

<div class="r"><pre>Provenance$fct_id_child(id = NULL, role = NULL)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>id</code></dt><dd><p>The id of the corresponding node.</p>
</dd>
<dt><code>role</code></dt><dd><p>The role for the node.</p>
</dd>
</dl>

</div>


<hr>
<a id="method-Provenance-fct_id_ancestor"></a>



<h4>Method <code>fct_id_ancestor()</code></h4>

<p>Get the factor ancestor ids
</p>


<h5>Usage</h5>

<div class="r"><pre>Provenance$fct_id_ancestor(id = NULL, role = NULL)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>id</code></dt><dd><p>The id of the corresponding node.</p>
</dd>
<dt><code>role</code></dt><dd><p>The role for the node.</p>
</dd>
</dl>

</div>


<hr>
<a id="method-Provenance-fct_id_descendant"></a>



<h4>Method <code>fct_id_descendant()</code></h4>

<p>Get the factor descendant ids
</p>


<h5>Usage</h5>

<div class="r"><pre>Provenance$fct_id_descendant(id = NULL, role = NULL)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>id</code></dt><dd><p>The id of the corresponding node.</p>
</dd>
<dt><code>role</code></dt><dd><p>The role for the node.</p>
</dd>
</dl>

</div>


<hr>
<a id="method-Provenance-fct_id_leaves"></a>



<h4>Method <code>fct_id_leaves()</code></h4>

<p>Get the leave factor ids.
</p>


<h5>Usage</h5>

<div class="r"><pre>Provenance$fct_id_leaves(role = NULL)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>role</code></dt><dd><p>The role for the node.</p>
</dd>
</dl>

</div>


<hr>
<a id="method-Provenance-lvl_id"></a>



<h4>Method <code>lvl_id()</code></h4>

<p>Get the id based on name of level node.
Assumes that level ids obtained are all from the same fid
</p>


<h5>Usage</h5>

<div class="r"><pre>Provenance$lvl_id(value = NULL, role = NULL, fid = NULL)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>value</code></dt><dd><p>The value of the node.</p>
</dd>
<dt><code>role</code></dt><dd><p>The role for the node.</p>
</dd>
<dt><code>fid</code></dt><dd><p>The factor id.</p>
</dd>
</dl>

</div>


<hr>
<a id="method-Provenance-lvl_id_parent"></a>



<h4>Method <code>lvl_id_parent()</code></h4>

<p>Get the level parent ids
</p>


<h5>Usage</h5>

<div class="r"><pre>Provenance$lvl_id_parent(id = NULL, role = NULL)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>id</code></dt><dd><p>The id of the corresponding node.</p>
</dd>
<dt><code>role</code></dt><dd><p>The role for the node.</p>
</dd>
</dl>

</div>


<hr>
<a id="method-Provenance-lvl_id_child"></a>



<h4>Method <code>lvl_id_child()</code></h4>

<p>Get the level child ids
</p>


<h5>Usage</h5>

<div class="r"><pre>Provenance$lvl_id_child(id = NULL, role = NULL)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>id</code></dt><dd><p>The id of the corresponding node.</p>
</dd>
<dt><code>role</code></dt><dd><p>The role for the node.</p>
</dd>
</dl>

</div>


<hr>
<a id="method-Provenance-lvl_id_ancestor"></a>



<h4>Method <code>lvl_id_ancestor()</code></h4>

<p>Get the level ancestor ids
</p>


<h5>Usage</h5>

<div class="r"><pre>Provenance$lvl_id_ancestor(id = NULL, role = NULL)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>id</code></dt><dd><p>The id of the corresponding node.</p>
</dd>
<dt><code>role</code></dt><dd><p>The role for the node.</p>
</dd>
</dl>

</div>


<hr>
<a id="method-Provenance-fct_id_from_lvl_id"></a>



<h4>Method <code>fct_id_from_lvl_id()</code></h4>

<p>Find the factor id from level ids.
</p>


<h5>Usage</h5>

<div class="r"><pre>Provenance$fct_id_from_lvl_id(id = NULL, fid_search = NULL)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>id</code></dt><dd><p>The id of the corresponding node.</p>
</dd>
<dt><code>fid_search</code></dt><dd><p>A vector of fids to search from.</p>
</dd>
</dl>

</div>


<hr>
<a id="method-Provenance-fct_id_from_lvl_values"></a>



<h4>Method <code>fct_id_from_lvl_values()</code></h4>

<p>Find the factor id from level values.
</p>


<h5>Usage</h5>

<div class="r"><pre>Provenance$fct_id_from_lvl_values(value = NULL, fid_search = NULL)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>value</code></dt><dd><p>The value of the node.</p>
</dd>
<dt><code>fid_search</code></dt><dd><p>A vector of fids to search from.</p>
</dd>
</dl>

</div>


<hr>
<a id="method-Provenance-lvl_id_from_fct_id"></a>



<h4>Method <code>lvl_id_from_fct_id()</code></h4>

<p>Find the level id from the given fid
</p>


<h5>Usage</h5>

<div class="r"><pre>Provenance$lvl_id_from_fct_id(fid = NULL)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>fid</code></dt><dd><p>The factor id.</p>
</dd>
</dl>

</div>


<hr>
<a id="method-Provenance-fct_names"></a>



<h4>Method <code>fct_names()</code></h4>

<p>Get the factor names based on id or role
</p>


<h5>Usage</h5>

<div class="r"><pre>Provenance$fct_names(id = NULL, role = NULL)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>id</code></dt><dd><p>The id of the corresponding node.</p>
</dd>
<dt><code>role</code></dt><dd><p>The role for the node.</p>
</dd>
</dl>

</div>


<hr>
<a id="method-Provenance-unit_names"></a>



<h4>Method <code>unit_names()</code></h4>

<p>Get the unit names
</p>


<h5>Usage</h5>

<div class="r"><pre>Provenance$unit_names(id = NULL)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>id</code></dt><dd><p>The id of the corresponding node.</p>
</dd>
</dl>

</div>


<hr>
<a id="method-Provenance-trt_names"></a>



<h4>Method <code>trt_names()</code></h4>

<p>Get the treatment names
</p>


<h5>Usage</h5>

<div class="r"><pre>Provenance$trt_names(id = NULL)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>id</code></dt><dd><p>The id of the corresponding node.</p>
</dd>
</dl>

</div>


<hr>
<a id="method-Provenance-rcrd_names"></a>



<h4>Method <code>rcrd_names()</code></h4>

<p>Get the record names.
</p>


<h5>Usage</h5>

<div class="r"><pre>Provenance$rcrd_names(id = NULL)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>id</code></dt><dd><p>The id of the corresponding node.</p>
</dd>
</dl>

</div>


<hr>
<a id="method-Provenance-rcrd_class"></a>



<h4>Method <code>rcrd_class()</code></h4>

<p>Get the class for record with validation.
</p>


<h5>Usage</h5>

<div class="r"><pre>Provenance$rcrd_class(name = NULL)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>name</code></dt><dd><p>The name of the node.</p>
</dd>
</dl>

</div>


<hr>
<a id="method-Provenance-lvl_values"></a>



<h4>Method <code>lvl_values()</code></h4>

<p>Get the level values based on id or role
cannot have just role only defined.
id must be from the same fid
</p>


<h5>Usage</h5>

<div class="r"><pre>Provenance$lvl_values(id = NULL, role = NULL, fid = NULL)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>id</code></dt><dd><p>The id of the corresponding node.</p>
</dd>
<dt><code>role</code></dt><dd><p>The role for the node.</p>
</dd>
<dt><code>fid</code></dt><dd><p>The factor id.</p>
</dd>
</dl>

</div>


<hr>
<a id="method-Provenance-unit_values"></a>



<h4>Method <code>unit_values()</code></h4>

<p>Get the unit values.
</p>


<h5>Usage</h5>

<div class="r"><pre>Provenance$unit_values(id = NULL, fid = NULL)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>id</code></dt><dd><p>The id of the corresponding node.</p>
</dd>
<dt><code>fid</code></dt><dd><p>The factor id.</p>
</dd>
</dl>

</div>


<hr>
<a id="method-Provenance-trt_values"></a>



<h4>Method <code>trt_values()</code></h4>

<p>Get the treatment values.
</p>


<h5>Usage</h5>

<div class="r"><pre>Provenance$trt_values(id = NULL, fid = NULL)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>id</code></dt><dd><p>The id of the corresponding node.</p>
</dd>
<dt><code>fid</code></dt><dd><p>The factor id.</p>
</dd>
</dl>

</div>


<hr>
<a id="method-Provenance-rcrd_values"></a>



<h4>Method <code>rcrd_values()</code></h4>

<p>Get the record values.
</p>


<h5>Usage</h5>

<div class="r"><pre>Provenance$rcrd_values(uid = NULL, fid = NULL)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>uid</code></dt><dd><p>The unit level id</p>
</dd>
<dt><code>fid</code></dt><dd><p>The factor id.</p>
</dd>
</dl>

</div>


<hr>
<a id="method-Provenance-fct_role"></a>



<h4>Method <code>fct_role()</code></h4>

<p>Get the role of the vertex given the factor id
</p>


<h5>Usage</h5>

<div class="r"><pre>Provenance$fct_role(id = NULL)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>id</code></dt><dd><p>The id of the corresponding node.</p>
</dd>
</dl>

</div>


<hr>
<a id="method-Provenance-fct_levels"></a>



<h4>Method <code>fct_levels()</code></h4>

<p>Get the levels for each factor
</p>


<h5>Usage</h5>

<div class="r"><pre>Provenance$fct_levels(id = NULL, name = NULL, return = c("id", "value"))</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>id</code></dt><dd><p>The id of the corresponding node.</p>
</dd>
<dt><code>name</code></dt><dd><p>The name of the node.</p>
</dd>
<dt><code>return</code></dt><dd><p>To return in &quot;id&quot; or &quot;value&quot; format.</p>
</dd>
</dl>

</div>


<hr>
<a id="method-Provenance-fct_levels_id_to_edbl_fct"></a>



<h4>Method <code>fct_levels_id_to_edbl_fct()</code></h4>

<p>Factor levels to edble factor
</p>


<h5>Usage</h5>

<div class="r"><pre>Provenance$fct_levels_id_to_edbl_fct(fct_levels, role)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>fct_levels</code></dt><dd><p>The factor levels in id.</p>
</dd>
<dt><code>role</code></dt><dd><p>The role for the node.</p>
</dd>
</dl>

</div>


<hr>
<a id="method-Provenance-fct_levels_id_to_value"></a>



<h4>Method <code>fct_levels_id_to_value()</code></h4>

<p>Get the factor levels in value given id format
</p>


<h5>Usage</h5>

<div class="r"><pre>Provenance$fct_levels_id_to_value(fct_levels)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>fct_levels</code></dt><dd><p>A list of factor levels in id format.</p>
</dd>
</dl>

</div>


<hr>
<a id="method-Provenance-fct_levels_value_to_id"></a>



<h4>Method <code>fct_levels_value_to_id()</code></h4>

<p>Get the factor levels in id given value format.
</p>


<h5>Usage</h5>

<div class="r"><pre>Provenance$fct_levels_value_to_id(fct_levels)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>fct_levels</code></dt><dd><p>A list of factor levels in id format.</p>
</dd>
</dl>

</div>


<hr>
<a id="method-Provenance-fct_exists"></a>



<h4>Method <code>fct_exists()</code></h4>

<p>One of <code>name</code>, <code>id</code> or <code>role</code> is defined to check if it exists.
If more than one of the arguments <code>name</code>, <code>id</code> and <code>role</code> are supplied, then
the intersection of it will be checked.
</p>


<h5>Usage</h5>

<div class="r"><pre>Provenance$fct_exists(id = NULL, name = NULL, role = NULL, abort = TRUE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>id</code></dt><dd><p>The id of the corresponding node.</p>
</dd>
<dt><code>name</code></dt><dd><p>The name of the node.</p>
</dd>
<dt><code>role</code></dt><dd><p>The role for the node.</p>
</dd>
<dt><code>abort</code></dt><dd><p>Whether to abort.</p>
</dd>
</dl>

</div>


<hr>
<a id="method-Provenance-trt_exists"></a>



<h4>Method <code>trt_exists()</code></h4>

<p>Check if treatment exists.
</p>


<h5>Usage</h5>

<div class="r"><pre>Provenance$trt_exists(id = NULL, name = NULL, abort = TRUE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>id</code></dt><dd><p>The id of the corresponding node.</p>
</dd>
<dt><code>name</code></dt><dd><p>The name of the node.</p>
</dd>
<dt><code>abort</code></dt><dd><p>Whether to abort.</p>
</dd>
</dl>

</div>


<hr>
<a id="method-Provenance-unit_exists"></a>



<h4>Method <code>unit_exists()</code></h4>

<p>Check if unit exists.
</p>


<h5>Usage</h5>

<div class="r"><pre>Provenance$unit_exists(id = NULL, name = NULL, abort = TRUE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>id</code></dt><dd><p>The id of the corresponding node.</p>
</dd>
<dt><code>name</code></dt><dd><p>The name of the node.</p>
</dd>
<dt><code>abort</code></dt><dd><p>Whether to abort.</p>
</dd>
</dl>

</div>


<hr>
<a id="method-Provenance-rcrd_exists"></a>



<h4>Method <code>rcrd_exists()</code></h4>

<p>Check if record exists.
</p>


<h5>Usage</h5>

<div class="r"><pre>Provenance$rcrd_exists(id = NULL, name = NULL, abort = TRUE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>id</code></dt><dd><p>The id of the corresponding node.</p>
</dd>
<dt><code>name</code></dt><dd><p>The name of the node.</p>
</dd>
<dt><code>abort</code></dt><dd><p>Whether to abort.</p>
</dd>
</dl>

</div>


<hr>
<a id="method-Provenance-append_fct_nodes"></a>



<h4>Method <code>append_fct_nodes()</code></h4>

<p>Given node data, append the factor nodes
</p>


<h5>Usage</h5>

<div class="r"><pre>Provenance$append_fct_nodes(name, role, attrs = NULL)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>name</code></dt><dd><p>The name of the node.</p>
</dd>
<dt><code>role</code></dt><dd><p>The role for the node.</p>
</dd>
<dt><code>attrs</code></dt><dd><p>The attributes.</p>
</dd>
</dl>

</div>


<hr>
<a id="method-Provenance-append_lvl_nodes"></a>



<h4>Method <code>append_lvl_nodes()</code></h4>

<p>Given node data, append the level nodes
</p>


<h5>Usage</h5>

<div class="r"><pre>Provenance$append_lvl_nodes(
  value,
  n = NULL,
  label = NULL,
  attrs = NULL,
  fid = NULL
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>value</code></dt><dd><p>The value of the node.</p>
</dd>
<dt><code>n</code></dt><dd><p>The number of replications.</p>
</dd>
<dt><code>label</code></dt><dd><p>The labels for the levels.</p>
</dd>
<dt><code>attrs</code></dt><dd><p>The attributes.</p>
</dd>
<dt><code>fid</code></dt><dd><p>The factor id.</p>
</dd>
</dl>

</div>


<hr>
<a id="method-Provenance-append_fct_edges"></a>



<h4>Method <code>append_fct_edges()</code></h4>

<p>Given edge data, append the factor edges
</p>


<h5>Usage</h5>

<div class="r"><pre>Provenance$append_fct_edges(from, to, type = NULL, group = FALSE, attrs = NULL)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>from</code></dt><dd><p>The node id from.</p>
</dd>
<dt><code>to</code></dt><dd><p>The node id to.</p>
</dd>
<dt><code>type</code></dt><dd><p>The type of edges.</p>
</dd>
<dt><code>group</code></dt><dd><p>A logical value to indicate whether to create new group id or not.</p>
</dd>
<dt><code>attrs</code></dt><dd><p>The attributes.</p>
</dd>
</dl>

</div>


<hr>
<a id="method-Provenance-append_lvl_edges"></a>



<h4>Method <code>append_lvl_edges()</code></h4>

<p>Given edge data, append the level edges
</p>


<h5>Usage</h5>

<div class="r"><pre>Provenance$append_lvl_edges(from, to, attrs = NULL)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>from</code></dt><dd><p>The node id from.</p>
</dd>
<dt><code>to</code></dt><dd><p>The node id to.</p>
</dd>
<dt><code>attrs</code></dt><dd><p>The attributes.</p>
</dd>
</dl>

</div>


<hr>
<a id="method-Provenance-serve_units"></a>



<h4>Method <code>serve_units()</code></h4>

<p>Serve the units.
</p>


<h5>Usage</h5>

<div class="r"><pre>Provenance$serve_units(id = NULL, return = c("id", "value"))</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>id</code></dt><dd><p>The id of the corresponding node.</p>
</dd>
<dt><code>return</code></dt><dd><p>To return in &quot;id&quot; or &quot;value&quot; format.</p>
</dd>
</dl>

</div>


<hr>
<a id="method-Provenance-serve_trts"></a>



<h4>Method <code>serve_trts()</code></h4>

<p>Serve treatments
</p>


<h5>Usage</h5>

<div class="r"><pre>Provenance$serve_trts(id = NULL, return = c("id", "value"))</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>id</code></dt><dd><p>The id of the corresponding node.</p>
</dd>
<dt><code>return</code></dt><dd><p>To return in &quot;id&quot; or &quot;value&quot; format.</p>
</dd>
</dl>

</div>


<hr>
<a id="method-Provenance-serve_rcrds"></a>



<h4>Method <code>serve_rcrds()</code></h4>

<p>Serve records
</p>


<h5>Usage</h5>

<div class="r"><pre>Provenance$serve_rcrds(id = NULL, return = c("id", "value"))</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>id</code></dt><dd><p>The id of the corresponding node.</p>
</dd>
<dt><code>return</code></dt><dd><p>To return in &quot;id&quot; or &quot;value&quot; format.</p>
</dd>
</dl>

</div>


<hr>
<a id="method-Provenance-make_trts_table"></a>



<h4>Method <code>make_trts_table()</code></h4>

<p>Make the treatments table
</p>


<h5>Usage</h5>

<div class="r"><pre>Provenance$make_trts_table(id = NULL, return = c("id", "value"))</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>id</code></dt><dd><p>The id of the corresponding node.</p>
</dd>
<dt><code>return</code></dt><dd><p>To return in &quot;id&quot; or &quot;value&quot; format.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>A treatment table
</p>


<hr>
<a id="method-Provenance-graph_subset"></a>



<h4>Method <code>graph_subset()</code></h4>

<p>Subset graph
</p>


<h5>Usage</h5>

<div class="r"><pre>Provenance$graph_subset(
  id = NULL,
  include = c("self", "child", "parent", "ancestors")
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>id</code></dt><dd><p>The id of the corresponding node.</p>
</dd>
<dt><code>include</code></dt><dd><p>&quot;self&quot; for only input id, &quot;child&quot; for child also,
&quot;parent&quot; for parent also,
nodes immediately related, and &quot;ancestors&quot; for all ancestors</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>subsetted graph
</p>


<hr>
<a id="method-Provenance-save_seed"></a>



<h4>Method <code>save_seed()</code></h4>

<p>Save the seed
</p>


<h5>Usage</h5>

<div class="r"><pre>Provenance$save_seed(seed, type)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>seed</code></dt><dd><p>A seed.</p>
</dd>
<dt><code>type</code></dt><dd><p>Type.</p>
</dd>
</dl>

</div>


<hr>
<a id="method-Provenance-get_title"></a>



<h4>Method <code>get_title()</code></h4>

<p>Get the title
</p>


<h5>Usage</h5>

<div class="r"><pre>Provenance$get_title()</pre></div>


<hr>
<a id="method-Provenance-get_validation"></a>



<h4>Method <code>get_validation()</code></h4>

<p>Get the validation
</p>


<h5>Usage</h5>

<div class="r"><pre>Provenance$get_validation(type = NULL)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>type</code></dt><dd><p>A type.</p>
</dd>
</dl>

</div>


<hr>
<a id="method-Provenance-get_trail"></a>



<h4>Method <code>get_trail()</code></h4>

<p>Get the trail.
</p>


<h5>Usage</h5>

<div class="r"><pre>Provenance$get_trail()</pre></div>


<hr>
<a id="method-Provenance-get_graph"></a>



<h4>Method <code>get_graph()</code></h4>

<p>Get the graph
</p>


<h5>Usage</h5>

<div class="r"><pre>Provenance$get_graph()</pre></div>


<hr>
<a id="method-Provenance-get_seed"></a>



<h4>Method <code>get_seed()</code></h4>

<p>Get the seed
</p>


<h5>Usage</h5>

<div class="r"><pre>Provenance$get_seed()</pre></div>


<hr>
<a id="method-Provenance-get_session_info"></a>



<h4>Method <code>get_session_info()</code></h4>

<p>Get the session information
</p>


<h5>Usage</h5>

<div class="r"><pre>Provenance$get_session_info()</pre></div>


<hr>
<a id="method-Provenance-get_edibble_version"></a>



<h4>Method <code>get_edibble_version()</code></h4>

<p>Get the edibble version.
</p>


<h5>Usage</h5>

<div class="r"><pre>Provenance$get_edibble_version()</pre></div>


<hr>
<a id="method-Provenance-get_simulate"></a>



<h4>Method <code>get_simulate()</code></h4>

<p>Get the simulation information
</p>


<h5>Usage</h5>

<div class="r"><pre>Provenance$get_simulate(name = NULL)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>name</code></dt><dd><p>The process name. Only one name allowed.</p>
</dd>
</dl>

</div>


<hr>
<a id="method-Provenance-get_simulate_result_env"></a>



<h4>Method <code>get_simulate_result_env()</code></h4>

<p>Get the simulation results
</p>


<h5>Usage</h5>

<div class="r"><pre>Provenance$get_simulate_result_env(name = NULL)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>name</code></dt><dd><p>The process name. Only one name allowed.</p>
</dd>
</dl>

</div>


<hr>
<a id="method-Provenance-mapping"></a>



<h4>Method <code>mapping()</code></h4>

<p>Mapping of a role to role
</p>


<h5>Usage</h5>

<div class="r"><pre>Provenance$mapping(role_from, role_to)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>role_from</code></dt><dd><p>The role from.</p>
</dd>
<dt><code>role_to</code></dt><dd><p>The role to.</p>
</dd>
</dl>

</div>


<hr>
<a id="method-Provenance-mapping_to_unit"></a>



<h4>Method <code>mapping_to_unit()</code></h4>

<p>Mapping of an id to a unit
</p>


<h5>Usage</h5>

<div class="r"><pre>Provenance$mapping_to_unit(id = NULL)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>id</code></dt><dd><p>The id of the corresponding node.</p>
</dd>
</dl>

</div>


<hr>
<a id="method-Provenance-record_step"></a>



<h4>Method <code>record_step()</code></h4>

<p>Record step.
</p>


<h5>Usage</h5>

<div class="r"><pre>Provenance$record_step()</pre></div>


<hr>
<a id="method-Provenance-lvl_mapping"></a>



<h4>Method <code>lvl_mapping()</code></h4>

<p>Get the level edges by factor
</p>


<h5>Usage</h5>

<div class="r"><pre>Provenance$lvl_mapping(from, to, return = c("vector", "table"))</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>from, to</code></dt><dd><p>The factor id.</p>
</dd>
<dt><code>return</code></dt><dd><p>To return in &quot;id&quot; or &quot;value&quot; format.</p>
</dd>
</dl>

</div>


<hr>
<a id="method-Provenance-record_track_external"></a>



<h4>Method <code>record_track_external()</code></h4>

<p>Record track external.
</p>


<h5>Usage</h5>

<div class="r"><pre>Provenance$record_track_external(code)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>code</code></dt><dd><p>The code to record.</p>
</dd>
</dl>

</div>


<hr>
<a id="method-Provenance-fct_id_links"></a>



<h4>Method <code>fct_id_links()</code></h4>

<p>Find all id that is linked.
</p>


<h5>Usage</h5>

<div class="r"><pre>Provenance$fct_id_links(id = NULL, role = NULL, link = c("direct", "indirect"))</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>id</code></dt><dd><p>The id of the corresponding node.</p>
</dd>
<dt><code>role</code></dt><dd><p>The role for the node.</p>
</dd>
<dt><code>link</code></dt><dd><p>Whether the link should be direct or indirect</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>id of linked factors, excluding itself.
</p>


<hr>
<a id="method-Provenance-fct_graph_components"></a>



<h4>Method <code>fct_graph_components()</code></h4>

<p>Get the nodes with components (subgraph number)
</p>


<h5>Usage</h5>

<div class="r"><pre>Provenance$fct_graph_components(id = NULL)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>id</code></dt><dd><p>The id of the corresponding node.</p>
</dd>
</dl>

</div>


<hr>
<a id="method-Provenance-lvl_graph_components"></a>



<h4>Method <code>lvl_graph_components()</code></h4>

<p>Get the nodes with components (subgraph number)
</p>


<h5>Usage</h5>

<div class="r"><pre>Provenance$lvl_graph_components()</pre></div>


<hr>
<a id="method-Provenance-clone"></a>



<h4>Method <code>clone()</code></h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>Provenance$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt><dd><p>Whether to make a deep clone.</p>
</dd>
</dl>

</div>



<hr>
<h2 id='rescale_values'>Rescale a numerical vector</h2><span id='topic+rescale_values'></span>

<h3>Description</h3>

<p>Similar to <code><a href="scales.html#topic+rescale">scales::rescale()</a></code> but it has a different
behaviour when only upper or lower bound is given.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rescale_values(x, lower = NA, upper = NA)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="rescale_values_+3A_x">x</code></td>
<td>
<p>A numerical vector.</p>
</td></tr>
<tr><td><code id="rescale_values_+3A_lower">lower</code></td>
<td>
<p>The lower bound.</p>
</td></tr>
<tr><td><code id="rescale_values_+3A_upper">upper</code></td>
<td>
<p>The upper bound.</p>
</td></tr>
</table>

<hr>
<h2 id='scan_menu'>Find the short names of the named designs</h2><span id='topic+scan_menu'></span>

<h3>Description</h3>

<p>Find the short names of the named designs
</p>


<h3>Usage</h3>

<pre><code class='language-R'>scan_menu(packages = NULL, exclude = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="scan_menu_+3A_packages">packages</code></td>
<td>
<p>A character vector containing the package names to search
named designs from. By default it will search edibble and other packages loaded.</p>
</td></tr>
<tr><td><code id="scan_menu_+3A_exclude">exclude</code></td>
<td>
<p>A character vector denoting the packages to exclude search from.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data.frame with package, name, arguments, and full name.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>scan_menu()
</code></pre>

<hr>
<h2 id='serve_table'>Serve edibble table</h2><span id='topic+serve_table'></span>

<h3>Description</h3>

<p>This converts an edibble graph object to a data frame called edibble.
This function should be used when the design is in the final form
(or close to the final form). The table can only be formed when the
variables can be reconciled, otherwise it will be a data frame with
zero rows.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>serve_table(
  .edibble = NULL,
  label_nested = NULL,
  fail = c("error", "warn", "ignore"),
  .record = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="serve_table_+3A_.edibble">.edibble</code></td>
<td>
<p>An edibble design (<code>edbl_design</code>), an edibble data frame (<code>edbl_table</code>) or an
object that contains the edibble data frame in the attribute
<code>design</code>.</p>
</td></tr>
<tr><td><code id="serve_table_+3A_label_nested">label_nested</code></td>
<td>
<p>The columns to show nested labels (if available). Tidyselect compatible.</p>
</td></tr>
<tr><td><code id="serve_table_+3A_fail">fail</code></td>
<td>
<p>What to do when failing to convert graph to table.</p>
</td></tr>
<tr><td><code id="serve_table_+3A_.record">.record</code></td>
<td>
<p>A logical value. This indicates whether to record this
code step. The default is TRUE. It should remain TRUE unless this
function is used as a wrapper in other code.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An <code>edbl</code> data frame with columns defined by vertices and
rows displayed only if the vertices are connected and reconcile for output.
</p>


<h3>See Also</h3>

<p>Other user-facing functions: 
<code><a href="#topic+allot_trts">allot_trts</a>()</code>,
<code><a href="#topic+allot_units">allot_units</a>()</code>,
<code><a href="#topic+design">design</a>()</code>,
<code><a href="#topic+expect_rcrds">expect_rcrds</a>()</code>,
<code><a href="#topic+export_design">export_design</a>()</code>,
<code><a href="#topic+set_rcrds">set_rcrds</a>()</code>,
<code><a href="#topic+set_trts">set_trts</a>()</code>,
<code><a href="#topic+set_units">set_units</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>design("Completely Randomised Design") %&gt;%
  set_units(unit = 28) %&gt;%
  set_trts(trt = 6) %&gt;%
  allot_trts(trt ~ unit) %&gt;%
  assign_trts("random", seed = 521) %&gt;%
  serve_table()
</code></pre>

<hr>
<h2 id='set_attrs'>Set the experimental context as metadata</h2><span id='topic+set_attrs'></span>

<h3>Description</h3>

<p>These are structured information that can be encoded in into the design
object. By encoding this information, you can make it interoperable.
If you use <code><a href="#topic+export_design">export_design()</a></code>, the information is exported to the title sheet
of the excel output.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>set_attrs(.edibble = design(), ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="set_attrs_+3A_.edibble">.edibble</code></td>
<td>
<p>An edibble table or design.</p>
</td></tr>
<tr><td><code id="set_attrs_+3A_...">...</code></td>
<td>
<p>A series of name-value pairs where the name corresponds to the
name of the metadata nad the value corresponds to the actual metadata value.
If the name is omitted, then no name to the metadata is assigned for the
corresponding value.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>des &lt;- set_attrs(design(aim = "Testing for new flu vaccine.",
                        contact = "emi.tanaka (at) anu.edu",
                       "Funded by Better Experiments Institute.") )

des$context

</code></pre>

<hr>
<h2 id='set_rcrds'>Set records for given unit</h2><span id='topic+set_rcrds'></span><span id='topic+set_rcrds_of'></span>

<h3>Description</h3>

<p>This function creates new nodes to edibble graph with the name
corresponding to either the intended response that will be measured or
a variable to be recorded. Avoid record names staring with a &quot;.&quot; as these
are reserved for other purposes downstream.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>set_rcrds(
  .edibble = NULL,
  ...,
  .name_repair = c("check_unique", "unique", "universal", "minimal"),
  .record = TRUE
)

set_rcrds_of(.edibble = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="set_rcrds_+3A_.edibble">.edibble</code></td>
<td>
<p>An edibble design (<code>edbl_design</code>), an edibble data frame (<code>edbl_table</code>) or an
object that contains the edibble data frame in the attribute
<code>design</code>.</p>
</td></tr>
<tr><td><code id="set_rcrds_+3A_...">...</code></td>
<td>
<p>Name-value pair. The value should correspond to a single name of the
unit defined in <code>set_units</code>. The name should be the name of the record variable.</p>
</td></tr>
<tr><td><code id="set_rcrds_+3A_.name_repair">.name_repair</code></td>
<td>
<p>Same as the argument in <code>tibble::tibble()</code>.</p>
</td></tr>
<tr><td><code id="set_rcrds_+3A_.record">.record</code></td>
<td>
<p>A logical value. This indicates whether to record this
code step. The default is TRUE. It should remain TRUE unless this
function is used as a wrapper in other code.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An edibble design.
</p>


<h3>See Also</h3>

<p>Other user-facing functions: 
<code><a href="#topic+allot_trts">allot_trts</a>()</code>,
<code><a href="#topic+allot_units">allot_units</a>()</code>,
<code><a href="#topic+design">design</a>()</code>,
<code><a href="#topic+expect_rcrds">expect_rcrds</a>()</code>,
<code><a href="#topic+export_design">export_design</a>()</code>,
<code><a href="#topic+serve_table">serve_table</a>()</code>,
<code><a href="#topic+set_trts">set_trts</a>()</code>,
<code><a href="#topic+set_units">set_units</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>takeout(menu_crd(t = 4, n = 10)) %&gt;%
  set_rcrds(y = unit)

takeout(menu_crd(t = 4, n = 10)) %&gt;%
  set_rcrds_of(unit = "y")
</code></pre>

<hr>
<h2 id='set_trts'>Set the treatment variables</h2><span id='topic+set_trts'></span>

<h3>Description</h3>

<p>This function add a special class, called <code>edbl_trt</code>, of edibble variables.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>set_trts(
  .edibble = design(),
  ...,
  .name_repair = c("check_unique", "unique", "universal", "minimal"),
  .record = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="set_trts_+3A_.edibble">.edibble</code></td>
<td>
<p>An edibble design (<code>edbl_design</code>), an edibble data frame (<code>edbl_table</code>) or an
object that contains the edibble data frame in the attribute
<code>design</code>.</p>
</td></tr>
<tr><td><code id="set_trts_+3A_...">...</code></td>
<td>
<p>Either a name-value pair or a series of the names.</p>
</td></tr>
<tr><td><code id="set_trts_+3A_.name_repair">.name_repair</code></td>
<td>
<p>Same as the argument in <code>tibble::tibble()</code>.</p>
</td></tr>
<tr><td><code id="set_trts_+3A_.record">.record</code></td>
<td>
<p>A logical value. This indicates whether to record this
code step. The default is TRUE. It should remain TRUE unless this
function is used as a wrapper in other code.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An edibble design.
</p>


<h3>Definition of <em>treatment</em></h3>

<p>The word <em>treatment</em> is sometimes used to refer to one of these variables.
When there are more than one treatment variables then this unfortunately
confuses whether treatment refers to the variable or the combination of
all treatment variables.
</p>
<p>Treatment is the whole description of what is applied in an experiment.
</p>


<h3>See Also</h3>

<p>Other user-facing functions: 
<code><a href="#topic+allot_trts">allot_trts</a>()</code>,
<code><a href="#topic+allot_units">allot_units</a>()</code>,
<code><a href="#topic+design">design</a>()</code>,
<code><a href="#topic+expect_rcrds">expect_rcrds</a>()</code>,
<code><a href="#topic+export_design">export_design</a>()</code>,
<code><a href="#topic+serve_table">serve_table</a>()</code>,
<code><a href="#topic+set_rcrds">set_rcrds</a>()</code>,
<code><a href="#topic+set_units">set_units</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
design() %&gt;%
  set_trts(pesticide = c("A", "B", "C"),
           dosage = c(0, 10, 20, 30, 40))

</code></pre>

<hr>
<h2 id='set_units'>Set units used in experiment</h2><span id='topic+set_units'></span>

<h3>Description</h3>

<p>This function sets new edibble variables of class <code>edbl_unit</code>. More
specifically, this means that new nodes are added to the <code>edbl_graph</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>set_units(
  .edibble = design(),
  ...,
  .name_repair = c("check_unique", "unique", "universal", "minimal"),
  .record = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="set_units_+3A_.edibble">.edibble</code></td>
<td>
<p>An edibble design (<code>edbl_design</code>), an edibble data frame (<code>edbl_table</code>) or an
object that contains the edibble data frame in the attribute
<code>design</code>.</p>
</td></tr>
<tr><td><code id="set_units_+3A_...">...</code></td>
<td>
<p>Either a name-value pair or a series of the names.</p>
</td></tr>
<tr><td><code id="set_units_+3A_.name_repair">.name_repair</code></td>
<td>
<p>Same as the argument in <code>tibble::tibble()</code>.</p>
</td></tr>
<tr><td><code id="set_units_+3A_.record">.record</code></td>
<td>
<p>A logical value. This indicates whether to record this
code step. The default is TRUE. It should remain TRUE unless this
function is used as a wrapper in other code.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An edibble design.
</p>


<h3>Definition of <em>unit</em></h3>

<p>A <em>unit</em>, much like <em>factor</em>, is an over-used word but due to lack of a
better word, edibble uses the word &quot;unit&quot; to refer to any entity, physical
or otherwise, that pertain to the experiment. This function doen't
explicitly distinguish between experimental or observational units,
nor is a unit limited to these type of units.
A unit in edibble can be a blocking factor or even a discrete time unit.
</p>


<h3>Limitations</h3>

<p>Currently a unit should only have a discrete set of levels and
you need to know the number of levels prior to setting the units.
</p>


<h3>See Also</h3>

<p>Other user-facing functions: 
<code><a href="#topic+allot_trts">allot_trts</a>()</code>,
<code><a href="#topic+allot_units">allot_units</a>()</code>,
<code><a href="#topic+design">design</a>()</code>,
<code><a href="#topic+expect_rcrds">expect_rcrds</a>()</code>,
<code><a href="#topic+export_design">export_design</a>()</code>,
<code><a href="#topic+serve_table">serve_table</a>()</code>,
<code><a href="#topic+set_rcrds">set_rcrds</a>()</code>,
<code><a href="#topic+set_trts">set_trts</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># 30 rats
design() %&gt;%
  set_units(rat = 30) %&gt;%
  serve_table()

# 4 girls named "Anna", "Betty", "Carol", "Diana"
design() %&gt;%
  set_units(girl = c("Anna", "Betty", "Carol", "Diana")) %&gt;%
  serve_table()

# 3 companies, with 10 boxes each
design() %&gt;%
  set_units(company = c("A", "B", "C"),
                box = nested_in(company, 10))

# 2 classes, one with 10 students, the other with 20 students
design() %&gt;%
  set_units(class = 2,
            student = nested_in(class,
                                1 ~ 10,
                                2 ~ 20))

# 4 countries with 10 people from Australia &amp; New Zealand and 20 from the rest
design() %&gt;%
  set_units(country = c("AU", "NZ", "USA", "JPN"),
            person = nested_in(country,
                               c("AU", "NZ") ~ 10,
                                           . ~ 20)) %&gt;%
  serve_table()


</code></pre>

<hr>
<h2 id='simulate_process'>Simulation process</h2><span id='topic+simulate_process'></span>

<h3>Description</h3>

<p>This function to create and store functions to simulate the records.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>simulate_process(.data, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="simulate_process_+3A_.data">.data</code></td>
<td>
<p>An edibble table.</p>
</td></tr>
<tr><td><code id="simulate_process_+3A_...">...</code></td>
<td>
<p>A name-value pair where the name should correspond to either the record name
that you are simulating or a process name if the return object is a data frame with
columns corresponding to the name of the records. The value must be a function with
set default arguments. The return object of this function should be either a
vector or a data frame with the column names corresponding to the record names.
The size should correspond to the number of columns.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>When creating a function, internally you can refer to any of the factors without referring
to the actual data. The data referred to is expected to be from the full data.
Like in tidyverse, syntax <code>.data</code> is reserved for the full data and <code>.env</code> can be
used to refer to environment variables.
</p>
<p>You can use the syntax <code>n()</code> to refer to <code>nrow(.data)</code> or <code>n(fct)</code> where <code>fct</code> corresponds to
unquoted factor name. The return value will be the number of the observed number of levels of factor <code>fct</code>
in the data. For <code>n(fct1, fct2)</code> it will return the observed number of distinct interaction levels for <code>fct1</code>
and <code>fct2</code>.
</p>
<p>Note that you can actually put as many process as you like if you use a process name (starting with a dot),
even if this is for the same record factor.
</p>

<hr>
<h2 id='simulate_rcrds'>Simulate records</h2><span id='topic+simulate_rcrds'></span>

<h3>Description</h3>

<p>Simulate records
</p>


<h3>Usage</h3>

<pre><code class='language-R'>simulate_rcrds(.data, ..., .seed = NULL, .nsim = 1L)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="simulate_rcrds_+3A_.data">.data</code></td>
<td>
<p>An edibble data</p>
</td></tr>
<tr><td><code id="simulate_rcrds_+3A_...">...</code></td>
<td>
<p>A name-value pair where the name should correspond to the names
used in the <code><a href="#topic+simulate_process">simulate_process()</a></code>. The value should be returned from calling
<code><a href="#topic+with_params">with_params()</a></code>.</p>
</td></tr>
<tr><td><code id="simulate_rcrds_+3A_.seed">.seed</code></td>
<td>
<p>An optional seed value.</p>
</td></tr>
<tr><td><code id="simulate_rcrds_+3A_.nsim">.nsim</code></td>
<td>
<p>The number of times to simulate data.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>design() %&gt;%
 set_units(unit = 4) %&gt;%
 set_trts(trt = 2) %&gt;%
 allot_table(trt ~ unit) %&gt;%
 set_rcrds(y = unit) %&gt;%
 simulate_process(y = function() {
            res &lt;- rnorm(n())
            res
 }) %&gt;%
 simulate_rcrds(y = with_params(), .nsim = 3)


</code></pre>

<hr>
<h2 id='skittles'>Skittles experiment</h2><span id='topic+skittles'></span>

<h3>Description</h3>

<p>This contains the data from the skittle experiment conducted by
Nick Tierney. The goal of the experiment was to assess if people
can discern the flavour of the skittle (indicated by color of the skittle)
based on taste alone. The participants are blindfolded.
</p>
<p>The experiment had 3 participants with each participant
tasting 10 skittles, 2 of each 5 color, in a random order.
</p>

<dl>
<dt>skittle_type</dt><dd><p>The type of skittle. Coincides with <code>real_skittle</code>.</p>
</dd>
<dt>person</dt><dd><p>The participant.</p>
</dd>
<dt>order</dt><dd><p>The order the skittle was tasted.</p>
</dd>
<dt>choice</dt><dd><p>The participant's choice.</p>
</dd>
<dt>real_skittle</dt><dd><p>The actual skittle color.</p>
</dd>
</dl>



<h3>Usage</h3>

<pre><code class='language-R'>skittles
</code></pre>


<h3>Format</h3>

<p>An object of class <code>spec_tbl_df</code> (inherits from <code>tbl_df</code>, <code>tbl</code>, <code>data.frame</code>) with 30 rows and 6 columns.
</p>


<h3>Source</h3>

<p>https://github.com/njtierney/skittles
</p>


<h3>See Also</h3>

<p>Other experimental data: 
<code><a href="#topic+lady_tasting_tea">lady_tasting_tea</a></code>
</p>

<hr>
<h2 id='split_by'>Split or count the data according to certain factors</h2><span id='topic+split_by'></span><span id='topic+count_by'></span>

<h3>Description</h3>

<p>This function has a similar result with <code>split()</code> where
it returns a named list with names corresponding to the
levels of the separating factor (or concatenated strings
if multiple separating factors). The key differences to <code>split()</code>,
are that the splitting factor does not appear in the elements of the
list and only linked factors and their ancestors appear in the output, e.g.
if treatment is applied to wholeplot and subplots are nested within
subplots, then the subplot will not be shown in the output if split by
treatment.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>split_by(.data, ..., .sep = ":", .remove_empty = TRUE)

count_by(.data, ..., .remove_empty = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="split_by_+3A_.data">.data</code></td>
<td>
<p>An edibble table.</p>
</td></tr>
<tr><td><code id="split_by_+3A_...">...</code></td>
<td>
<p>The factors to split or count by. You cannot split by a record
factor or a factor that uniquely indexes the smallest unit in the
design. You cannot also combine treatment and unit factors together.</p>
</td></tr>
<tr><td><code id="split_by_+3A_.sep">.sep</code></td>
<td>
<p>The separator to use if more than one factor to split by.</p>
</td></tr>
<tr><td><code id="split_by_+3A_.remove_empty">.remove_empty</code></td>
<td>
<p>Remove empty combinations. Default is TRUE.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A named list.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+pivot_wider_by">pivot_wider_by()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>spd &lt;- takeout(menu_split())
split(spd, spd$trt1)
spd %&gt;% split_by(trt1)
spd %&gt;% split_by(trt2)
spd %&gt;% split_by(mainplot)
spd %&gt;% count_by(trt1)

fac &lt;- takeout(menu_factorial(trt = c(2, 2, 2)))
fac %&gt;% count_by(where(~is_trt(.x)))

</code></pre>

<hr>
<h2 id='takeout'>Create a named experimental design</h2><span id='topic+takeout'></span>

<h3>Description</h3>

<p>This function generates a named experimental
design by supplying the selected menu named design and prints out by default
</p>
<p>You can find the available recipes with <code>scan_menu()</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>takeout(recipe = NULL, show = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="takeout_+3A_recipe">recipe</code></td>
<td>
<p>A named design object. This should be typically generated from a
function with prefix <code>menu_</code>. If nothing is supplied, it will randomly select one.</p>
</td></tr>
<tr><td><code id="takeout_+3A_show">show</code></td>
<td>
<p>A logical value to indicate whether the code should be shown or not.
Default is TRUE.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A recipe design.
</p>


<h3>See Also</h3>

<p>See <code><a href="#topic+scan_menu">scan_menu()</a></code> for finding the short names of the
named experimental designs.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>takeout(menu_crd(n = 50, t = 5))
# if you omit the design parameters then it will use the default
# (which may be random)
takeout(menu_crd())
# if you don't give any short names then it will generate a random one
takeout()
</code></pre>

<hr>
<h2 id='trts_table'>Treatments table</h2><span id='topic+trts_table'></span>

<h3>Description</h3>

<p>Treatments table
</p>


<h3>Usage</h3>

<pre><code class='language-R'>trts_table(.edibble)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="trts_table_+3A_.edibble">.edibble</code></td>
<td>
<p>An edibble table</p>
</td></tr>
</table>

<hr>
<h2 id='utility-edibble-var'>Utility functions for edibble variable</h2><span id='topic+utility-edibble-var'></span><span id='topic+as.character.edbl_fct'></span><span id='topic+as.integer.edbl_fct'></span><span id='topic+is_fct'></span><span id='topic+is_unit'></span><span id='topic+is_trt'></span><span id='topic+is_rcrd'></span>

<h3>Description</h3>

<p>The S3 methods for <code>edbl_fct</code> objects have
the same expected output that of a factor.
</p>
<p>Other functions are utility functions related to <code>edbl_fct</code> object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'edbl_fct'
as.character(x, ...)

## S3 method for class 'edbl_fct'
as.integer(x, ...)

is_fct(x)

is_unit(x)

is_trt(x)

is_rcrd(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="utility-edibble-var_+3A_x">x</code></td>
<td>
<p>An <code>edbl_fct</code> object.</p>
</td></tr>
<tr><td><code id="utility-edibble-var_+3A_...">...</code></td>
<td>
<p>Ignored.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A character vector.
</p>

<hr>
<h2 id='with_params'>This is a helper function to set the parameter values</h2><span id='topic+with_params'></span>

<h3>Description</h3>

<p>This is a helper function to set the parameter values
</p>


<h3>Usage</h3>

<pre><code class='language-R'>with_params(..., .censor = NA, .aggregate = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="with_params_+3A_...">...</code></td>
<td>
<p>A series of name-value pair that are inputs used for the
simulation process.</p>
</td></tr>
<tr><td><code id="with_params_+3A_.censor">.censor</code></td>
<td>
<p>The value to censor if it outside the valid values. If the
value has a lower and upper bound then it should be a vector of size 2. Use
-Inf or Inf if you don't want to censor either value. You can use a list if
you want a different censoring for different records where the name corresponds to
the name of the record. If you want to apply a default value/function for censoring
then use the name &quot;.default&quot;. You can use a function instead of a value. The function
may be specified by as a lambda function. The object <code>.lower</code> and <code>.upper</code> are
special reserved values, corresponding to the limits given from valid values,
that can be used within this function.</p>
</td></tr>
<tr><td><code id="with_params_+3A_.aggregate">.aggregate</code></td>
<td>
<p>The function for aggregation if the response values differ
within the same unit level for the record. Use <code>NA</code> if you don't want to aggregate.
By default, it will get the mean or mode depending on the encoding
(numeric is mean, mode for character or factor), or if absent,
based on returned encoding. It can be a named list where the names correspond to
the record name and the values corresponding to a function.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+simulate_rcrds">simulate_rcrds()</a></code>
</p>

<hr>
<h2 id='with_value'>Validation values</h2><span id='topic+with_value'></span>

<h3>Description</h3>

<p>This creates a list that is used later for creating data validation rules
when the data is exported.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>with_value(
  operator = c("=", "==", "&gt;=", "&lt;=", "&lt;", "&gt;", "!="),
  value = NULL,
  between = NULL,
  not_between = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="with_value_+3A_operator">operator</code></td>
<td>
<p>Operator to apply.</p>
</td></tr>
<tr><td><code id="with_value_+3A_value">value</code></td>
<td>
<p>An optional value related to operator</p>
</td></tr>
<tr><td><code id="with_value_+3A_between">between</code>, <code id="with_value_+3A_not_between">not_between</code></td>
<td>
<p>An optional numerical vector of size two where the
first entry is the minimum value and the second entry is the maximum value.
For <code>between</code>, the value is valid if within the range of minimum and maximum
value inclusive. For <code>not_between</code>, the value must lie outside of these values.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with two elements <code>operator</code> and <code>value</code>.
</p>

<hr>
<h2 id='with_variables'>A helper function to set variables that the record is dependent on.</h2><span id='topic+with_variables'></span>

<h3>Description</h3>

<p>The other options give are characteristics of the record (not the independent variables).
Warning: none of the other options work at the moment!
</p>


<h3>Usage</h3>

<pre><code class='language-R'>with_variables(
  ...,
  .missing = FALSE,
  .interaction = random_true_false(),
  .discrete = FALSE,
  .linear = random_true_false(),
  .error_dist = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="with_variables_+3A_...">...</code></td>
<td>
<p>A series of factors in which the record is explicitly dependent upon (tidyselect campatible).</p>
</td></tr>
<tr><td><code id="with_variables_+3A_.missing">.missing</code></td>
<td>
<p>A logical value indicating whether there should be some
missing values. Default is FALSE. The missing values are introduced at random.
It can also be numeric of between 0 and 1 giving the proportion of missing values.</p>
</td></tr>
<tr><td><code id="with_variables_+3A_.interaction">.interaction</code></td>
<td>
<p>Whether there should be treatment interaction effects.</p>
</td></tr>
<tr><td><code id="with_variables_+3A_.discrete">.discrete</code></td>
<td>
<p>Whether to make the response value discrete or not.</p>
</td></tr>
<tr><td><code id="with_variables_+3A_.linear">.linear</code></td>
<td>
<p>Whether to include non-linear term or not. The value is always additive.</p>
</td></tr>
<tr><td><code id="with_variables_+3A_.error_dist">.error_dist</code></td>
<td>
<p>The random distribution to use for numerical values
(either &quot;normal&quot;, &quot;uniform&quot;, &quot;exponential&quot;, &quot;gamma&quot;, &quot;beta&quot;, &quot;cauchy&quot;, &quot;chisq&quot;, &quot;f&quot;, &quot;t&quot;, &quot;poisson&quot;, &quot;weibull&quot;).
The default choice is random out of these with higher chances of &quot;normal&quot;.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+autofill_rcrds">autofill_rcrds()</a></code>
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
