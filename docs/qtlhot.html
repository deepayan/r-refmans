<!DOCTYPE html><html><head><title>Help for package qtlhot</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {qtlhot}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#add.phenos'>
<p>Add phenotypes to cross object.</p></a></li>
<li><a href='#CMSTtests'><p>Perform CMST Tests on cross object</p></a></li>
<li><a href='#filter.threshold'><p>Summary of threshold results</p></a></li>
<li><a href='#GetCandReg'>
<p>Get genetic information on candidate regulators and co-mapping traits.</p></a></li>
<li><a href='#GetCommonQtls'><p>Get common QTLs for phenotypes</p></a></li>
<li><a href='#highlod'>
<p>Pull high LOD values with chr and pos.</p></a></li>
<li><a href='#hotperm'><p>Conduct NL and N permutation tests</p></a></li>
<li><a href='#hotsize'>
<p>Hotspot size routines.</p></a></li>
<li><a href='#parallel.qtlhot'>
<p>Code for parallelizing R/qtlhot.</p></a></li>
<li><a href='#PrecTpFpMatrix'>
<p>Determine false positive and true positive rates for known targets.</p></a></li>
<li><a href='#sim.hotspot'><p>Wrapper routine for simulations.</p></a></li>
<li><a href='#SimCrossCausal'><p>Simulate Cross for Causal Tests</p></a></li>
<li><a href='#ww.perm'><p>Conduct West-Wu (Q) permutation tests</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Version:</td>
<td>1.0.4</td>
</tr>
<tr>
<td>Date:</td>
<td>2018-04-05</td>
</tr>
<tr>
<td>Author:</td>
<td>Elias Chaibub Neto &lt;echaibub@hotmail.com&gt; and Brian S Yandell &lt;brian.yandell@wisc.edu&gt;</td>
</tr>
<tr>
<td>Title:</td>
<td>Inference for QTL Hotspots</td>
</tr>
<tr>
<td>Description:</td>
<td>Functions to infer co-mapping trait hotspots and causal models.
  Chaibub Neto E, Keller MP, Broman AF, Attie AD, Jansen RC, Broman KW, Yandell BS (2012) 
  Quantile-based permutation thresholds for QTL hotspots. Genetics 191 : 1355-1365. 
  &lt;<a href="https://doi.org/10.1534%2Fgenetics.112.139451">doi:10.1534/genetics.112.139451</a>&gt;.
  Chaibub Neto E, Broman AT, Keller MP, Attie AD, Zhang B, Zhu J, Yandell BS (2013)
  Modeling causality for pairs of phenotypes in system genetics. Genetics 193 : 1003-1013.
  &lt;<a href="https://doi.org/10.1534%2Fgenetics.112.147124">doi:10.1534/genetics.112.147124</a>&gt;.</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Brian S. Yandell &lt;brian.yandell@wisc.edu&gt;</td>
</tr>
<tr>
<td>Depends:</td>
<td>stats,qtl,mnormt,utils,corpcor, R (&ge; 2.10)</td>
</tr>
<tr>
<td>LazyLoad:</td>
<td>yes</td>
</tr>
<tr>
<td>LazyData:</td>
<td>yes</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="http://www.stat.wisc.edu/~yandell/statgen">http://www.stat.wisc.edu/~yandell/statgen</a></td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>6.0.1</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2018-04-05 19:01:54 UTC; brianyandell</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2018-04-05 21:50:55 UTC</td>
</tr>
</table>
<hr>
<h2 id='add.phenos'>
Add phenotypes to cross object.
</h2><span id='topic+add.phenos'></span>

<h3>Description</h3>

<p>Add phenotypes to cross object by checking index.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>add.phenos(cross, newdata = NULL, index = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="add.phenos_+3A_cross">cross</code></td>
<td>
<p>object of class <code>cross</code>; see <code><a href="qtl.html#topic+read.cross">read.cross</a></code></p>
</td></tr>
<tr><td><code id="add.phenos_+3A_newdata">newdata</code></td>
<td>
<p>data frame with row names matching values of phenotype
identified by <code>index</code> for object <code>cross</code></p>
</td></tr>
<tr><td><code id="add.phenos_+3A_index">index</code></td>
<td>
<p>character string name of phenotype in object
<code>cross</code>; if <code>NULL</code>, then <code>newdata</code> must be of same
size as <code>cross</code> with phenotypes in order</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The name <code>index</code> must be a phenotype in the <code>cross</code>
object. The row names of <code>newdata</code> are matched with values of <code>index</code>.
</p>


<h3>Value</h3>

<p>object of class <code>cross</code> with added phenotypes
</p>


<h3>Author(s)</h3>

<p>Brian S. Yandell, <a href="mailto:byandell@wisc.edu">byandell@wisc.edu</a>
</p>


<h3>See Also</h3>

<p><code><a href="qtl.html#topic+read.cross">read.cross</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
data(hyper)
x &lt;- data.frame(x = rnorm(nind(hyper)))
hyperx &lt;- add.phenos(hyper, x)

## End(Not run)
</code></pre>

<hr>
<h2 id='CMSTtests'>Perform CMST Tests on cross object</h2><span id='topic+CMSTtests'></span><span id='topic+CMSTtestsList'></span>

<h3>Description</h3>

<p>Performs 6 separate CMST tests (3 versions, 2 penalties).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>CMSTtests(cross, pheno1, pheno2, Q.chr, Q.pos,
  addcov1 = NULL, addcov2 = NULL, intcov1 = NULL, intcov2 = NULL, 
  method = c("par", "non.par", "joint", "all"),
  penalty = c("bic", "aic", "both"), verbose = FALSE)
CMSTtestsList(cross, pheno1, pheno2, Q.chr, Q.pos,
  addcov1 = NULL, addcov2 = NULL, intcov1 = NULL, intcov2 = NULL, 
  method = c("par", "non.par", "joint", "all"),
  penalty = c("bic", "aic", "both"), verbose = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="CMSTtests_+3A_cross">cross</code></td>
<td>
<p>object of class <code>cross</code></p>
</td></tr>
<tr><td><code id="CMSTtests_+3A_pheno1">pheno1</code></td>
<td>
<p>first phenotype column number or character string name</p>
</td></tr>
<tr><td><code id="CMSTtests_+3A_pheno2">pheno2</code></td>
<td>
<p>second phenotype column number or character string name;
if more than one, then all phenotypes will be tested against <code>pheno1</code></p>
</td></tr>
<tr><td><code id="CMSTtests_+3A_q.chr">Q.chr</code></td>
<td>
<p>QTL chromosome (number or label)</p>
</td></tr>
<tr><td><code id="CMSTtests_+3A_q.pos">Q.pos</code></td>
<td>
<p>QTL position in cM</p>
</td></tr>
<tr><td><code id="CMSTtests_+3A_addcov1">addcov1</code>, <code id="CMSTtests_+3A_addcov2">addcov2</code></td>
<td>
<p>additive covariates for first and second
phenotype, respectively</p>
</td></tr>
<tr><td><code id="CMSTtests_+3A_intcov1">intcov1</code>, <code id="CMSTtests_+3A_intcov2">intcov2</code></td>
<td>
<p>interactive covariates for first and second
phenotype, respectively</p>
</td></tr>
<tr><td><code id="CMSTtests_+3A_method">method</code></td>
<td>
<p>test method; see details</p>
</td></tr>
<tr><td><code id="CMSTtests_+3A_penalty">penalty</code></td>
<td>
<p>type of penalty; see details</p>
</td></tr>
<tr><td><code id="CMSTtests_+3A_verbose">verbose</code></td>
<td>
<p>verbose printout if <code>TRUE</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>Explain method and penalty here.
</p>


<h3>References</h3>

<p>Chaibub Neto E, Broman AT, Keller MP, Attie AD, Zhang B, Zhu J, Yandell BS,
Causal model selection hypothesis tests in systems genetics.
Genetics (in review).
</p>


<h3>See Also</h3>

<p><code><a href="#topic+CMSTCross">CMSTCross</a></code>, <code><a href="#topic+PrecTpFpMatrix">PrecTpFpMatrix</a></code>,
<code><a href="#topic+FitAllTests">FitAllTests</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>data(CMSTCross)
nms &lt;- names(CMSTCross$pheno)
out1 &lt;- CMSTtests(CMSTCross, 
                  pheno1 = nms[1], 
                  pheno2 = nms[2],
                  Q.chr = 1,
                  Q.pos = 55,
                  addcov1 = NULL, 
                  addcov2 = NULL, 
                  intcov1 = NULL, 
                  intcov2 = NULL, 
                  method = "all",
                  penalty = "both")
out1[1:6]
out1[7]
out1[8:12]
out1[13:17]
## list of phenotypes
out2 &lt;- CMSTtests(CMSTCross, 
                  pheno1 = nms[1], 
                  pheno2 = nms[-1],
                  Q.chr = 1,
                  Q.pos = 55,
                  addcov1 = NULL, 
                  addcov2 = NULL, 
                  intcov1 = NULL, 
                  intcov2 = NULL, 
                  method = "par",
                  penalty = "bic")
out2
</code></pre>

<hr>
<h2 id='filter.threshold'>Summary of threshold results</h2><span id='topic+filter.threshold'></span>

<h3>Description</h3>

<p>Summary of threshold results.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>filter.threshold(cross, pheno.col, latent.eff, res.var, lod.thrs, drop.lod = 1.5,
  s.quant, n.perm, alpha.levels, qh.thrs, ww.thrs, addcovar = NULL,
  intcovar = NULL, verbose = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="filter.threshold_+3A_cross">cross</code></td>
<td>
<p>object of class <code>cross</code>; see <code><a href="qtl.html#topic+read.cross">read.cross</a></code></p>
</td></tr>
<tr><td><code id="filter.threshold_+3A_pheno.col">pheno.col</code></td>
<td>
<p>phenotype columns used for filtering thresholds</p>
</td></tr>
<tr><td><code id="filter.threshold_+3A_latent.eff">latent.eff</code></td>
<td>
<p>ratio of latent effect SD to residual SD</p>
</td></tr>
<tr><td><code id="filter.threshold_+3A_res.var">res.var</code></td>
<td>
<p>residual variance (=SD^2)</p>
</td></tr>
<tr><td><code id="filter.threshold_+3A_lod.thrs">lod.thrs</code></td>
<td>
<p>LOD threshold values for range of significance (alpha) levels</p>
</td></tr>
<tr><td><code id="filter.threshold_+3A_drop.lod">drop.lod</code></td>
<td>
<p>LOD drop from max LOD to keep in analysis</p>
</td></tr>
<tr><td><code id="filter.threshold_+3A_s.quant">s.quant</code></td>
<td>
<p>vector of <code>1:Nmax</code> with <code>Nmax</code> the maximum hotspot
size to be considered</p>
</td></tr>
<tr><td><code id="filter.threshold_+3A_n.perm">n.perm</code></td>
<td>
<p>number of permutations</p>
</td></tr>
<tr><td><code id="filter.threshold_+3A_alpha.levels">alpha.levels</code></td>
<td>
<p>range of significance levels; same length as <code>lod.thrs</code></p>
</td></tr>
<tr><td><code id="filter.threshold_+3A_qh.thrs">qh.thrs</code></td>
<td>
<p>Results of call to <code><a href="#topic+hotperm">hotperm</a></code></p>
</td></tr>
<tr><td><code id="filter.threshold_+3A_ww.thrs">ww.thrs</code></td>
<td>
<p>Results of call to <code><a href="#topic+ww.perm">ww.perm</a></code></p>
</td></tr>
<tr><td><code id="filter.threshold_+3A_addcovar">addcovar</code></td>
<td>
<p>additive covariates as vector or matrix; see <code><a href="qtl.html#topic+scanone">scanone</a></code></p>
</td></tr>
<tr><td><code id="filter.threshold_+3A_intcovar">intcovar</code></td>
<td>
<p>interactive covariates as vector or matrix; see <code><a href="qtl.html#topic+scanone">scanone</a></code></p>
</td></tr>
<tr><td><code id="filter.threshold_+3A_verbose">verbose</code></td>
<td>
<p>verbose output if <code>TRUE</code></p>
</td></tr>
<tr><td><code id="filter.threshold_+3A_...">...</code></td>
<td>
<p>arguments passed along to <code>scanone</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>List with items
</p>
<table>
<tr><td><code>NL.thrs</code></td>
<td>
</td></tr>
<tr><td><code>N.thrs</code></td>
<td>
</td></tr>
<tr><td><code>WW.thrs</code></td>
<td>
</td></tr>
<tr><td><code>NL</code></td>
<td>
</td></tr>
<tr><td><code>N.counts</code></td>
<td>
</td></tr>
<tr><td><code>WW.counts</code></td>
<td>
</td></tr>
</table>


<h3>References</h3>

<p>Manichaikul A, Dupuis J, Sen S, Broman KW (2006) Poor performance of
bootstrap confidence intervals for the location of a quantitative trait
locus. Genetics 174: 481-489.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+hotperm">hotperm</a></code>, <code><a href="#topic+ww.perm">ww.perm</a></code>, <code><a href="qtl.html#topic+scanone">scanone</a></code></p>

<hr>
<h2 id='GetCandReg'>
Get genetic information on candidate regulators and co-mapping traits.
</h2><span id='topic+GetCandReg'></span><span id='topic+GetCisCandReg'></span><span id='topic+GetCoMappingTraits'></span>

<h3>Description</h3>

<p>Get chromosome (phys.chr) and physical position in cM (phys.pos), along
with the LOD score (peak.lod) at the peak position (peak.pos), and the
chromosome where the peak is located (peak.chr). Some candidates may map to the
same chromosome where they are physically located.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>GetCandReg(highobj, annot, traits)
GetCisCandReg(highobj, cand.reg, lod.thr = NULL)
GetCoMappingTraits(highobj, cand.reg)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="GetCandReg_+3A_highobj">highobj</code></td>
<td>

<p>data frame from <code><a href="#topic+highlod">highlod</a></code>, which is sparse summary of
high LODs in large <code><a href="qtl.html#topic+scanone">scanone</a></code> object
</p>
</td></tr>
<tr><td><code id="GetCandReg_+3A_annot">annot</code></td>
<td>

<p>data frame with annotation information; must have first column as unique
identifier, third column as chromosome, and fifth column as position in
cM; typically column 2 has gene name, and column 4 has position in Mb
</p>
</td></tr>
<tr><td><code id="GetCandReg_+3A_traits">traits</code></td>
<td>

<p>names of traits to examine as candidate regulators; names must
correspond to phenotypes in <code>cross</code> object
</p>
</td></tr>
<tr><td><code id="GetCandReg_+3A_cand.reg">cand.reg</code></td>
<td>

<p>data frame with candidate regulator; see value section below
</p>
</td></tr>
<tr><td><code id="GetCandReg_+3A_lod.thr">lod.thr</code></td>
<td>
<p>LOD threshold; restrict to intervals above this value if
not <code>NULL</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>Traits that map to positions close to their physical locations are said
to map in cis (local linkages). 
Traits that map to positions away from their physical locations are said to map in
trans (distal linkages). There is no unambiguous way to determine how close a trait needs to
map to its physical location in order to be classified as cis. Our choice is to classify a trait as
cis if the 1.5-LOD support interval (Manichaikul et al. 2006) around the LOD peak contains
the trait's physical location, and if the LOD score at its physical location is higher the the LOD
threshold. The function <code>GetCisCandReg</code> determines which of the candidate regulators map in
cis. The function <code>GetCoMappingTraits</code> returns a list with the putative
targets of each trait. A trait is included in the putative target list of
a trait when its LOD peak is greater than <code>lod.thr</code> and the
<code>drop</code> LOD support interval around the peak contains the location
of the trait's QTL.
The function <code>JoinTestOutputs</code> currently relies on external files
that contain results of <code><a href="#topic+FitAllTests">FitAllTests</a></code>. It needs to be
rewritten to save space.
</p>


<h3>Value</h3>

<p><code>GetCoMappingTraits</code> returns a list with each element being the
names of co-mapping traits for a particular name in <code>traits</code>.
<code>GetCandReg</code> returns a data frame while <code>GetCisCandReg</code>
returns a list with a similar candidate regulator data frame as the
element <code>cis.reg</code>, and the index of trait names as the element
<code>cis.index</code>. The elements of the candidate regulator data frame
are as follows (<code>peak.pos.lower</code> and <code>peak.pos.upper</code> only
for <code>GetCisCandReg</code>):
</p>
<table>
<tr><td><code>gene</code></td>
<td>
<p>name of trait, which might be a gene name</p>
</td></tr>
<tr><td><code>phys.chr</code></td>
<td>
<p>chromosome on which gene physically resides</p>
</td></tr>
<tr><td><code>phys.pos</code></td>
<td>
<p>physical position (in cM)</p>
</td></tr>
<tr><td><code>peak.chr</code></td>
<td>
<p>chromosome where peak LOD is located</p>
</td></tr>
<tr><td><code>peak.pos</code></td>
<td>
<p>position of peak (in cM)</p>
</td></tr>
<tr><td><code>peak.lod</code></td>
<td>
<p>LOD value at peak</p>
</td></tr>
<tr><td><code>peak.pos.lower</code>, <code>peak.pos.upper</code></td>
<td>
<p>lower and upper bounds
of the 1.5-LOD support interval around <code>peak.pos</code></p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Elias Chaibub Neto
</p>


<h3>References</h3>

<p>Manichaikul et al. (2006) Genetics
</p>


<h3>See Also</h3>

<p><code><a href="#topic+highlod">highlod</a></code>,
<code><a href="#topic+FitAllTests">FitAllTests</a></code>,
<code><a href="qtl.html#topic+scanone">scanone</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## data(CMSTCross) is loaded lazily.
CMSTscan &lt;- scanone(CMSTCross, pheno.col = 1:3, method = "hk")
CMSThigh &lt;- highlod(CMSTscan)
traits &lt;- names(CMSTCross$pheno)
annot &lt;- data.frame(name = traits, traits = traits, chr = rep(1, 3),
 Mb.pos = c(55,10,100))
annot$cM.pos &lt;- annot$Mb.pos
cand.reg &lt;- GetCandReg(CMSThigh, annot, traits)
cis.cand.reg &lt;- GetCisCandReg(CMSThigh, cand.reg)
comap.targets &lt;- GetCoMappingTraits(CMSThigh, cand.reg)
</code></pre>

<hr>
<h2 id='GetCommonQtls'>Get common QTLs for phenotypes</h2><span id='topic+GetCommonQtls'></span>

<h3>Description</h3>

<p>Perform joint QTL mapping for phenotypes
with marginal LOD peak positions higher than LOD threshold and within
set distance of each other
</p>


<h3>Usage</h3>

<pre><code class='language-R'>GetCommonQtls(cross, pheno1, pheno2, thr = 3, peak.dist = 5,
  addcov1 = NULL, addcov2 = NULL, intcov1 = NULL, intcov2 = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="GetCommonQtls_+3A_cross">cross</code></td>
<td>
<p>object of class <code>cross</code></p>
</td></tr>
<tr><td><code id="GetCommonQtls_+3A_pheno1">pheno1</code></td>
<td>
<p>first phenotype column number or character string name</p>
</td></tr>
<tr><td><code id="GetCommonQtls_+3A_pheno2">pheno2</code></td>
<td>
<p>second phenotype column number or character string name;
if more than one, then all phenotypes will be tested against <code>pheno1</code></p>
</td></tr>
<tr><td><code id="GetCommonQtls_+3A_thr">thr</code></td>
<td>
<p>LOD threshold</p>
</td></tr>
<tr><td><code id="GetCommonQtls_+3A_peak.dist">peak.dist</code></td>
<td>
<p>maximal peak distance to be considered the same peak
(in cM)</p>
</td></tr>
<tr><td><code id="GetCommonQtls_+3A_addcov1">addcov1</code>, <code id="GetCommonQtls_+3A_addcov2">addcov2</code></td>
<td>
<p>additive covariates for first and second
phenotype, respectively</p>
</td></tr>
<tr><td><code id="GetCommonQtls_+3A_intcov1">intcov1</code>, <code id="GetCommonQtls_+3A_intcov2">intcov2</code></td>
<td>
<p>interactive covariates for first and second
phenotype, respectively</p>
</td></tr>
</table>


<h3>References</h3>

<p>Chaibub Neto E, Broman AT, Keller MP, Attie AD, Zhang B, Zhu J, Yandell BS,
Causal model selection hypothesis tests in systems genetics.
Genetics (in review).
</p>


<h3>See Also</h3>

<p><code><a href="#topic+CMSTCross">CMSTCross</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>data(CMSTCross)
commqtls &lt;- GetCommonQtls(CMSTCross, 
                          pheno1 = "y1", 
                          pheno2 = "y3",
                          thr = 3,
                          peak.dist = 5,
                          addcov1 = NULL, 
                          addcov2 = NULL, 
                          intcov1 = NULL, 
                          intcov2 = NULL)
commqtls
</code></pre>

<hr>
<h2 id='highlod'>
Pull high LOD values with chr and pos.
</h2><span id='topic+highlod'></span><span id='topic+print.highlod'></span><span id='topic+summary.highlod'></span><span id='topic+plot.highlod'></span><span id='topic+max.highlod'></span><span id='topic+quantile.highlod'></span><span id='topic+pull.highlod'></span>

<h3>Description</h3>

<p>Pull high LOD values with chr and pos.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>highlod(scans, lod.thr = 0, drop.lod = 1.5,
  extend = TRUE, restrict.lod = FALSE, ...)
pull.highlod(object, chr, pos, ...)
## S3 method for class 'highlod'
print(x, ...)
## S3 method for class 'highlod'
summary(object, ...)
## S3 method for class 'highlod'
plot(x, ..., quant.level = NULL, sliding = FALSE)
## S3 method for class 'highlod'
max(x, lod.thr = NULL, window = NULL, quant.level = NULL, ...)
## S3 method for class 'highlod'
quantile(x, probs = NULL, lod.thr = NULL, n.quant,
  n.pheno, max.quantile = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="highlod_+3A_scans">scans</code></td>
<td>
<p>object of class <code><a href="qtl.html#topic+scanone">scanone</a></code></p>
</td></tr>
<tr><td><code id="highlod_+3A_lod.thr">lod.thr</code></td>
<td>
<p>LOD threshold</p>
</td></tr>
<tr><td><code id="highlod_+3A_drop.lod">drop.lod</code></td>
<td>
<p>LOD drop from max to keep for support intervals</p>
</td></tr>
<tr><td><code id="highlod_+3A_extend">extend</code></td>
<td>
<p>extend support interval just past <code>drop.lod</code>;
matches behavior of <code><a href="qtl.html#topic+lodint">lodint</a></code> when <code>TRUE</code></p>
</td></tr>
<tr><td><code id="highlod_+3A_restrict.lod">restrict.lod</code></td>
<td>
<p>restrict to loci above LOD threshold if
<code>TRUE</code>; matches behavior of <code><a href="qtl.html#topic+lodint">lodint</a></code> when
<code>FALSE</code> (default)</p>
</td></tr>
<tr><td><code id="highlod_+3A_chr">chr</code></td>
<td>
<p>chromosome identifier</p>
</td></tr>
<tr><td><code id="highlod_+3A_pos">pos</code></td>
<td>
<p>position, or range of positions, in cM</p>
</td></tr>
<tr><td><code id="highlod_+3A_x">x</code>, <code id="highlod_+3A_object">object</code></td>
<td>
<p>object of class <code>highlod</code></p>
</td></tr>
<tr><td><code id="highlod_+3A_probs">probs</code></td>
<td>
<p>probability levels for quantiles (should be &gt; 0.5)</p>
</td></tr>
<tr><td><code id="highlod_+3A_n.quant">n.quant</code></td>
<td>
<p>maximum of <code>s.quant</code></p>
</td></tr>
<tr><td><code id="highlod_+3A_n.pheno">n.pheno</code></td>
<td>
<p>number of phenotypes considered</p>
</td></tr>
<tr><td><code id="highlod_+3A_max.quantile">max.quantile</code></td>
<td>
<p>return only quantiles of max LOD across genome if
<code>TRUE</code></p>
</td></tr>
<tr><td><code id="highlod_+3A_window">window</code></td>
<td>
<p>size of window for smoothing hotspot size</p>
</td></tr>
<tr><td><code id="highlod_+3A_quant.level">quant.level</code></td>
<td>
<p>vector of LOD levels for 1 up to
<code>length(quant.level)</code> size hotspots</p>
</td></tr>
<tr><td><code id="highlod_+3A_sliding">sliding</code></td>
<td>
<p>plot as sliding hotspot if <code>TRUE</code></p>
</td></tr>
<tr><td><code id="highlod_+3A_...">...</code></td>
<td>
<p>arguments passed along</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>highlod</code> condenses a <code>scanone</code> object to the peaks
above a <code>lod.thr</code> and/or within <code>drop.lod</code> of such
peaks. The <code>pull.highlod</code> pulls out the entries at a particular
genomic location or interval of locations. Summary, print, plot, max
and quantile methods provide ways to examine a <code>highlod</code> object.
</p>


<h3>Value</h3>

<p>Data frame with
</p>
<table>
<tr><td><code>row</code></td>
<td>
<p>row number in <code><a href="qtl.html#topic+scanone">scanone</a></code> object</p>
</td></tr>
<tr><td><code>phenos</code></td>
<td>
<p>phenotype column number</p>
</td></tr>
<tr><td><code>lod</code></td>
<td>
<p>LOD score for phenotype at locus indicated by <code>row</code></p>
</td></tr> 
</table>


<h3>Author(s)</h3>

<p>Brian S Yandell and Elias Chaibub Neto
</p>


<h3>See Also</h3>

<p><code><a href="#topic+highlod">highlod</a></code>, <code><a href="#topic+hotperm">hotperm</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>example(include.hotspots)
scan1 &lt;- scanone(cross1, pheno.col = 1:1000, method = "hk")
high1 &lt;- highlod(scan1, lod.thr = 2.11, drop.lod = 1.5)
pull.highlod(high1, chr = 2, pos = 24)
summary(high1, lod.thr = 2.44)
max(high1, lod.thr = seq(2.11, 3.11, by = .1))
</code></pre>

<hr>
<h2 id='hotperm'>Conduct NL and N permutation tests</h2><span id='topic+hotperm'></span><span id='topic+print.hotperm'></span><span id='topic+summary.hotperm'></span><span id='topic+quantile.hotperm'></span><span id='topic+print.summary.hotperm'></span><span id='topic+hotperm1'></span>

<h3>Description</h3>

<p>Conduct NL and N permutation tests.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>hotperm(cross, n.quant, n.perm, lod.thrs, alpha.levels, drop.lod = 1.5,
  window = NULL, verbose = FALSE, init.seed = 0,
  addcovar = NULL, intcovar = NULL, ...)
data(hotperm1)
## S3 method for class 'hotperm'
print(x, ...)
## S3 method for class 'hotperm'
summary(object, quant.levels, ...)
## S3 method for class 'hotperm'
quantile(x, probs, ..., lod.thr = NULL)
## S3 method for class 'summary.hotperm'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="hotperm_+3A_cross">cross</code></td>
<td>
<p>object of class <code>cross</code></p>
</td></tr>
<tr><td><code id="hotperm_+3A_n.quant">n.quant</code></td>
<td>
<p>maximum of <code>s.quant</code></p>
</td></tr>
<tr><td><code id="hotperm_+3A_n.perm">n.perm</code></td>
<td>
<p>number of permutations</p>
</td></tr>
<tr><td><code id="hotperm_+3A_lod.thrs">lod.thrs</code></td>
<td>
<p>vector of LOD thresholds</p>
</td></tr>
<tr><td><code id="hotperm_+3A_alpha.levels">alpha.levels</code></td>
<td>
<p>vector of significance levels</p>
</td></tr>
<tr><td><code id="hotperm_+3A_quant.levels">quant.levels</code></td>
<td>
<p>quantile levels, as number of traits, to show in
summary; default is 1, 2, 5, 10, ... up to maximum recorded</p>
</td></tr>
<tr><td><code id="hotperm_+3A_drop.lod">drop.lod</code></td>
<td>
<p>LOD drop amount for support intervals</p>
</td></tr>
<tr><td><code id="hotperm_+3A_window">window</code></td>
<td>
<p>window size for smoothed hotspot size</p>
</td></tr>
<tr><td><code id="hotperm_+3A_verbose">verbose</code></td>
<td>
<p>verbose output if <code>TRUE</code></p>
</td></tr>
<tr><td><code id="hotperm_+3A_init.seed">init.seed</code></td>
<td>
<p>initial seed for pseudo-random number generation</p>
</td></tr>
<tr><td><code id="hotperm_+3A_x">x</code>, <code id="hotperm_+3A_object">object</code></td>
<td>
<p>object of class <code>hotperm</code> or <code>summary.hotperm</code></p>
</td></tr>
<tr><td><code id="hotperm_+3A_probs">probs</code></td>
<td>
<p>probability levels for quantiles (<code>1-probs</code> if all &gt; 0.5);
default is <code>alpha.levels</code></p>
</td></tr>
<tr><td><code id="hotperm_+3A_lod.thr">lod.thr</code></td>
<td>
<p>restrict to values above this if not <code>NULL</code></p>
</td></tr>
<tr><td><code id="hotperm_+3A_addcovar">addcovar</code></td>
<td>
<p>additive covariates as vector or matrix; see <code><a href="qtl.html#topic+scanone">scanone</a></code></p>
</td></tr>
<tr><td><code id="hotperm_+3A_intcovar">intcovar</code></td>
<td>
<p>interactive covariates as vector or matrix; see <code><a href="qtl.html#topic+scanone">scanone</a></code></p>
</td></tr>
<tr><td><code id="hotperm_+3A_...">...</code></td>
<td>
<p>arguments passed along to <code>scanone</code></p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Elias Chaibub Neto and Brian S Yandell
</p>


<h3>Examples</h3>

<pre><code class='language-R'>example(include.hotspots)
set.seed(123)
pt &lt;- scanone(ncross1, method = "hk", n.perm = 1000)
alphas &lt;- seq(0.01, 0.10, by=0.01)
lod.thrs &lt;- summary(pt, alphas)
## Not run: 
## This takes awhile, so we save the object.
set.seed(12345)
hotperm1 &lt;- hotperm(cross = cross1,
                    n.quant = 300,
                    n.perm = 100,
                    lod.thrs = lod.thrs,
                    alpha.levels = alphas,
                    drop.lod = 1.5,
                    verbose = FALSE)
save(hotperm1, file = "hotperm1.RData", compress = TRUE)

## End(Not run)
summary(hotperm1)
</code></pre>

<hr>
<h2 id='hotsize'>
Hotspot size routines.
</h2><span id='topic+hotsize'></span><span id='topic+hotsize.scanone'></span><span id='topic+hotsize.highlod'></span><span id='topic+print.hotsize'></span><span id='topic+summary.hotsize'></span><span id='topic+plot.hotsize'></span>

<h3>Description</h3>

<p>Determine hotspot sizes and display. Use individual threshold and
quantile thresholds as provided.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>hotsize(hotobject, ...)
## S3 method for class 'scanone'
hotsize(hotobject, lod.thr = NULL, drop.lod = 1.5, ...)
## S3 method for class 'highlod'
hotsize(hotobject, lod.thr = NULL, window = NULL,
  quant.level = NULL, ...)
## S3 method for class 'hotsize'
print(x, ...)
## S3 method for class 'hotsize'
summary(object, ...)
## S3 method for class 'hotsize'
plot(x, ylab = "counts", quant.axis = pretty(x$max.N),
  col = c("black", "red", "blue"), by.chr = FALSE, maps = NULL,
  title = "",...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="hotsize_+3A_hotobject">hotobject</code></td>
<td>
<p>object of class <code><a href="qtl.html#topic+scanone">scanone</a></code> or <code><a href="#topic+highlod">highlod</a></code></p>
</td></tr>
<tr><td><code id="hotsize_+3A_lod.thr">lod.thr</code></td>
<td>
<p>LOD threshold</p>
</td></tr>
<tr><td><code id="hotsize_+3A_drop.lod">drop.lod</code></td>
<td>
<p>LOD drop from max to keep for support intervals</p>
</td></tr>
<tr><td><code id="hotsize_+3A_window">window</code></td>
<td>
<p>window width in cM for smoothing hotspot size; not used
if <code>0</code> or <code>NULL</code></p>
</td></tr>
<tr><td><code id="hotsize_+3A_quant.level">quant.level</code></td>
<td>
<p>vector of LOD levels for 1 up to
<code>length(quant.level)</code> size hotspots</p>
</td></tr>
<tr><td><code id="hotsize_+3A_x">x</code>, <code id="hotsize_+3A_object">object</code></td>
<td>
<p>object of class <code>hotsize</code></p>
</td></tr>
<tr><td><code id="hotsize_+3A_ylab">ylab</code></td>
<td>
<p>label for vertical plot axis</p>
</td></tr>
<tr><td><code id="hotsize_+3A_quant.axis">quant.axis</code></td>
<td>
<p>hotspot sizes for quantile axis (vertical on right
side of plot)</p>
</td></tr>
<tr><td><code id="hotsize_+3A_col">col</code></td>
<td>
<p>col of hotspot size, smoothed hotspot size, and sliding
hotspot size</p>
</td></tr>
<tr><td><code id="hotsize_+3A_by.chr">by.chr</code></td>
<td>
<p>separate plot by chromosome if <code>TRUE</code></p>
</td></tr>
<tr><td><code id="hotsize_+3A_maps">maps</code></td>
<td>
<p>if not <code>NULL</code>, list of objects of class <code>map</code>
to use for rugs on top and bottom of plot</p>
</td></tr>
<tr><td><code id="hotsize_+3A_title">title</code></td>
<td>
<p>title for plot</p>
</td></tr>
<tr><td><code id="hotsize_+3A_...">...</code></td>
<td>
<p>arguments passed along to scanone methods</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>hotsize</code> methods return an object of class <code>hotsize</code>, which
is essentially an object of class <code><a href="qtl.html#topic+summary.scanone">summary.scanone</a></code>
with additional attributes for <code>lod.thr</code>, <code>window</code>, and
<code>quant.level</code>. 
</p>


<h3>Author(s)</h3>

<p>Brian S Yandell and Elias Chaibub Neto
</p>


<h3>See Also</h3>

<p><code><a href="#topic+highlod">highlod</a></code>, <code><a href="#topic+hotperm">hotperm</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>example(highlod)
hots1 &lt;- hotsize(high1)
summary(hots1)
plot(hots1)
</code></pre>

<hr>
<h2 id='parallel.qtlhot'>
Code for parallelizing R/qtlhot.
</h2><span id='topic+parallel.qtlhot'></span><span id='topic+qtlhot.phase0'></span><span id='topic+big.phase0'></span>

<h3>Description</h3>

<p>Code for parallelizing R/qtlhot. See installed parallel directory for
proper use. There is apparently an S3 parallel method, so doc has to be
as shown below, even though it is called as parallel.qtlhot.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'qtlhot'
parallel(x, data = 1, ..., dirpath = ".")
qtlhot.phase0(dirpath, init.seed = 92387475, len = rep(400,16), n.mar = 185, n.ind = 112,
   n.phe = 100, latent.eff = 0, res.var = 1, lod.thrs, ...)
big.phase0(dirpath, cross, trait.file, trait.matrix, droptrait.names = NULL,
   keeptrait.names = NULL, lod.thrs, sex = "Sex", trait.index,
   batch.effect = NULL, size.set = 250, offset = 0, subset.sex = NULL, verbose = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="parallel.qtlhot_+3A_x">x</code></td>
<td>
<p>phase of parallel processing (1,2,3)</p>
</td></tr>
<tr><td><code id="parallel.qtlhot_+3A_data">data</code></td>
<td>
<p>index for parallel processing (1,2,...)</p>
</td></tr>
<tr><td><code id="parallel.qtlhot_+3A_...">...</code></td>
<td>
<p>additional arguments passed along</p>
</td></tr>
<tr><td><code id="parallel.qtlhot_+3A_dirpath">dirpath</code></td>
<td>
<p>directory path as character string</p>
</td></tr>
<tr><td><code id="parallel.qtlhot_+3A_init.seed">init.seed</code></td>
<td>
<p>initial seed for pseudorandom number generation</p>
</td></tr>
<tr><td><code id="parallel.qtlhot_+3A_len">len</code></td>
<td>
<p>vector of chromosome lengths for simulated map</p>
</td></tr>
<tr><td><code id="parallel.qtlhot_+3A_n.mar">n.mar</code></td>
<td>
<p>number of markers for simulated map</p>
</td></tr>
<tr><td><code id="parallel.qtlhot_+3A_n.ind">n.ind</code></td>
<td>
<p>number of individuals for simulated cross</p>
</td></tr>
<tr><td><code id="parallel.qtlhot_+3A_n.phe">n.phe</code></td>
<td>
<p>number of phenotypes for simulated phenotypes</p>
</td></tr>
<tr><td><code id="parallel.qtlhot_+3A_latent.eff">latent.eff</code></td>
<td>
<p>size of latent effect</p>
</td></tr>
<tr><td><code id="parallel.qtlhot_+3A_res.var">res.var</code></td>
<td>
<p>magnitude of residual variance</p>
</td></tr>
<tr><td><code id="parallel.qtlhot_+3A_lod.thrs">lod.thrs</code></td>
<td>
<p>vector of LOD thresholds to examine</p>
</td></tr>
<tr><td><code id="parallel.qtlhot_+3A_cross">cross</code></td>
<td>
<p>object of class <code>cross</code></p>
</td></tr>
<tr><td><code id="parallel.qtlhot_+3A_trait.file">trait.file</code></td>
<td>
<p>character string name of trait file</p>
</td></tr>
<tr><td><code id="parallel.qtlhot_+3A_trait.matrix">trait.matrix</code></td>
<td>
<p>character string name of trait matrix</p>
</td></tr>
<tr><td><code id="parallel.qtlhot_+3A_droptrait.names">droptrait.names</code></td>
<td>
<p>vector of character strings for traits to drop
(none if <code>NULL</code>)</p>
</td></tr>
<tr><td><code id="parallel.qtlhot_+3A_keeptrait.names">keeptrait.names</code></td>
<td>
<p>vector of character strings for traits to keep
(keep all if <code>NULL</code>)</p>
</td></tr>
<tr><td><code id="parallel.qtlhot_+3A_sex">sex</code></td>
<td>
<p>character string name of phenotype for sex</p>
</td></tr>
<tr><td><code id="parallel.qtlhot_+3A_trait.index">trait.index</code></td>
<td>
<p>vector of character strings for trait names</p>
</td></tr>
<tr><td><code id="parallel.qtlhot_+3A_batch.effect">batch.effect</code></td>
<td>
<p>character string for batch effect (none if <code>NULL</code>)</p>
</td></tr>
<tr><td><code id="parallel.qtlhot_+3A_size.set">size.set</code></td>
<td>
<p>maximum size of set of traits to scan at one time</p>
</td></tr>
<tr><td><code id="parallel.qtlhot_+3A_offset">offset</code></td>
<td>
<p>offset for name of trait RData files</p>
</td></tr>
<tr><td><code id="parallel.qtlhot_+3A_subset.sex">subset.sex</code></td>
<td>
<p>string of sex to subset on (both sexes if <code>NULL</code>)</p>
</td></tr>
<tr><td><code id="parallel.qtlhot_+3A_verbose">verbose</code></td>
<td>
<p>verbose output if <code>TRUE</code></p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Brian S Yandell and Elias Chaibub Neto
</p>


<h3>See Also</h3>

<p><code><a href="qtl.html#topic+read.cross">read.cross</a></code></p>

<hr>
<h2 id='PrecTpFpMatrix'>
Determine false positive and true positive rates for known targets.
</h2><span id='topic+FitAllTests'></span><span id='topic+JoinTestOutputs'></span><span id='topic+PrecTpFpMatrix'></span><span id='topic+CitTests'></span><span id='topic+p.adjust.np'></span>

<h3>Description</h3>

<p>Determine how well different tests do to predict candidates of regulation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>FitAllTests(cross, pheno1, pheno2, Q.chr, Q.pos, verbose = TRUE)
JoinTestOutputs(comap, tests, file)
PrecTpFpMatrix(alpha, val.targets, all.orfs, tests, cand.reg, cis.cand.reg)
p.adjust.np(tests, method = "BH")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="PrecTpFpMatrix_+3A_cross">cross</code></td>
<td>
<p>object of class <code>cross</code></p>
</td></tr>
<tr><td><code id="PrecTpFpMatrix_+3A_pheno1">pheno1</code></td>
<td>
<p>first phenotype column number or character string name</p>
</td></tr>
<tr><td><code id="PrecTpFpMatrix_+3A_pheno2">pheno2</code></td>
<td>
<p>second phenotype column number or character string name;
if more than one, then all phenotypes will be tested against <code>pheno1</code></p>
</td></tr>
<tr><td><code id="PrecTpFpMatrix_+3A_q.chr">Q.chr</code></td>
<td>
<p>QTL chromosome (number or label)</p>
</td></tr>
<tr><td><code id="PrecTpFpMatrix_+3A_q.pos">Q.pos</code></td>
<td>
<p>QTL position in cM</p>
</td></tr>
<tr><td><code id="PrecTpFpMatrix_+3A_verbose">verbose</code></td>
<td>
<p>verbose printout if <code>TRUE</code></p>
</td></tr>
<tr><td><code id="PrecTpFpMatrix_+3A_comap">comap</code></td>
<td>
<p>list result of <code>GetComappingTraits</code></p>
</td></tr>
<tr><td><code id="PrecTpFpMatrix_+3A_alpha">alpha</code></td>
<td>

<p>significance levels at which summaries are computed
</p>
</td></tr>
<tr><td><code id="PrecTpFpMatrix_+3A_val.targets">val.targets</code></td>
<td>

<p>validated targets of candidate regulators
</p>
</td></tr>
<tr><td><code id="PrecTpFpMatrix_+3A_all.orfs">all.orfs</code></td>
<td>

<p>all trait names
</p>
</td></tr>
<tr><td><code id="PrecTpFpMatrix_+3A_tests">tests</code></td>
<td>

<p>list object as list of <code>FitAllTests</code> results, or of joined
output created by <code>JoinTestsOutputs</code> 
</p>
</td></tr>
<tr><td><code id="PrecTpFpMatrix_+3A_file">file</code></td>
<td>
<p>prefix for file names when running <code>FitAllTests</code> in
parallel and saving test results in separate files</p>
</td></tr>
<tr><td><code id="PrecTpFpMatrix_+3A_cand.reg">cand.reg</code></td>
<td>

<p>object from <code><a href="#topic+GetCandReg">GetCandReg</a></code></p>
</td></tr>
<tr><td><code id="PrecTpFpMatrix_+3A_cis.cand.reg">cis.cand.reg</code></td>
<td>

<p>object from <code><a href="#topic+GetCisCandReg">GetCisCandReg</a></code></p>
</td></tr>
<tr><td><code id="PrecTpFpMatrix_+3A_method">method</code></td>
<td>
<p>method for p-value adjustment; see <code><a href="stats.html#topic+p.adjust">p.adjust</a></code></p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>FitAllTests</code> invokes 7 tests. The hidden routine <code>CitTests</code>
is invoked by call to <code>FitAllTests</code>; this is hidden because we do
not recommend its use.
</p>
<p><code>JoinTestOutputs</code> joins results of
<code><a href="#topic+FitAllTests">FitAllTests</a></code>, either from a list <code>tests</code> or from a
collection of files prefixed by <code>file</code>. The joined <code>tests</code>
from <code>JoinTestOutputs</code> are summarized with <code>PrecTpFpMatrix</code>
using the biologically validated true positives, false positives and
precision, for the inferred causal relations. We define a true
positive as a statistically significant causal relation between a gene
and a putative target gene when the putative target gene belongs to
the known signature of the gene. Similarly, we define a false positive
as a statistically significant causal relation between a gene and a
putative target gene when the target gene does not belong to the
signature. (For the AIC and BIC methods that do not provide a p-value
measuring the significance of the causal call, we simply use the
detected causal relations in the computation of true and false
positives). The validated precision is computed as the ratio of true
positives by the sum of true and false positives. The
<code>PrecTpFpMatrix</code> computes these measures to both all genes, and
to cis genes only. Simulations suggest only non-parametric tests need
to be adjusted using Benjamini-Hochberg via <code>p.adjust.np</code>.
</p>


<h3>Value</h3>

<p>List containing
</p>
<table>
<tr><td><code>Prec1</code>, <code>Prec2</code></td>
<td>
<p>matrix of precision with rows for significance level and
columns for test; first is for all, second is for cis candidates only</p>
</td></tr>
<tr><td><code>Tp1</code>, <code>Tp2</code></td>
<td>
<p>matrix of true positive rate with rows for significance level and
columns for test; first is for all, second is for cis candidates only</p>
</td></tr>
<tr><td><code>Fp1</code>, <code>Fp2</code></td>
<td>
<p>matrix of false positive rate with rows for significance level and
columns for test; first is for all, second is for cis candidates only</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Elias Chaibub Neto
</p>


<h3>See Also</h3>

<p><code><a href="#topic+GetCandReg">GetCandReg</a></code>, <code><a href="#topic+CMSTtests">CMSTtests</a></code>, <code><a href="stats.html#topic+p.adjust">p.adjust</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>example(GetCandReg)
## Suppose y1 is causal with targets y2 and y3.
targets &lt;- list(y1 = c("y2","y3"))

tests &lt;- list()
for(k in seq(names(comap.targets))) {
  tests[[k]] &lt;- FitAllTests(CMSTCross, pheno1 = names(comap.targets)[k],
                      pheno2 = comap.targets[[k]],
                      Q.chr = cand.reg[k, 4],
                      Q.pos = cand.reg[k, 5])
}
names(tests) &lt;- names(comap.targets)
tests &lt;- JoinTestOutputs(comap.targets, tests)

PrecTpFpMatrix(alpha = seq(0.01, 0.10, by = 0.01),
  val.targets = targets, all.orfs = CMSThigh$names, tests = tests,
  cand.reg = cand.reg, cis.cand.reg = cis.cand.reg)
</code></pre>

<hr>
<h2 id='sim.hotspot'>Wrapper routine for simulations.</h2><span id='topic+sim.hotspot'></span><span id='topic+mySimulations'></span><span id='topic+sim.null.cross'></span><span id='topic+sim.null.pheno.data'></span><span id='topic+include.hotspots'></span>

<h3>Description</h3>

<p>Wrapper routine for simulations
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sim.hotspot(nSim, cross, n.pheno, latent.eff, res.var = 1, n.quant, n.perm,
  alpha.levels, lod.thrs, drop.lod = 1.5, verbose = FALSE)
mySimulations(...)
sim.null.cross(chr.len = rep(400, 16), n.mar = 185, n.ind = 112,
  type = "bc", n.pheno = 6000, latent.eff = 1.5, res.var = 1,
  init.seed = 92387475)
sim.null.pheno.data(cross, n.pheno, latent.eff, res.var)
include.hotspots(cross, hchr, hpos, hsize, Q.eff, latent.eff,
  lod.range.1, lod.range.2, lod.range.3, res.var=1, n.pheno, init.seed)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sim.hotspot_+3A_nsim">nSim</code></td>
<td>
<p>Number of simulated sets of phenotypes to create. See details.</p>
</td></tr>
<tr><td><code id="sim.hotspot_+3A_cross">cross</code></td>
<td>
<p>Object of class <code>cross</code>. See <code><a href="qtl.html#topic+read.cross">read.cross</a></code>.</p>
</td></tr>
<tr><td><code id="sim.hotspot_+3A_n.pheno">n.pheno</code></td>
<td>
<p>Number of traits, or phenotypes, to simulate for cross object.</p>
</td></tr>
<tr><td><code id="sim.hotspot_+3A_latent.eff">latent.eff</code></td>
<td>
<p>Strength of latent effect, which is included in all traits. See <code><a href="#topic+sim.null.cross">sim.null.cross</a></code>.</p>
</td></tr>
<tr><td><code id="sim.hotspot_+3A_res.var">res.var</code></td>
<td>
<p>Residual variance for traits. Should not affect results.</p>
</td></tr>
<tr><td><code id="sim.hotspot_+3A_n.quant">n.quant</code></td>
<td>
<p>maximum size of hotspots examined; ideally large enough to exceed the largest Breitling alpha critical value.</p>
</td></tr>
<tr><td><code id="sim.hotspot_+3A_n.perm">n.perm</code></td>
<td>
<p>Number of permutations to perform per realization. Good idea to do 1000,
but this takes time.</p>
</td></tr>
<tr><td><code id="sim.hotspot_+3A_alpha.levels">alpha.levels</code></td>
<td>
<p>Vector of significance levels.</p>
</td></tr>
<tr><td><code id="sim.hotspot_+3A_lod.thrs">lod.thrs</code></td>
<td>
<p>Vector of LOD thresholds, typically single-trait
permutation thresholds for various significance levels.</p>
</td></tr>
<tr><td><code id="sim.hotspot_+3A_drop.lod">drop.lod</code></td>
<td>
<p>Drop in LOD score examined. LODs below this drop from the maximum for a
chromosome will not be scored.</p>
</td></tr>
<tr><td><code id="sim.hotspot_+3A_init.seed">init.seed</code></td>
<td>
<p>initial seed for pseudo-random number generation</p>
</td></tr>
<tr><td><code id="sim.hotspot_+3A_chr.len">chr.len</code></td>
<td>
<p>vector of chromosome lengths</p>
</td></tr>
<tr><td><code id="sim.hotspot_+3A_n.mar">n.mar</code></td>
<td>
<p>number of markers</p>
</td></tr>
<tr><td><code id="sim.hotspot_+3A_n.ind">n.ind</code></td>
<td>
<p>number of individuals</p>
</td></tr>
<tr><td><code id="sim.hotspot_+3A_type">type</code></td>
<td>
<p>type of cross</p>
</td></tr>
<tr><td><code id="sim.hotspot_+3A_hchr">hchr</code>, <code id="sim.hotspot_+3A_hpos">hpos</code>, <code id="sim.hotspot_+3A_hsize">hsize</code></td>
<td>
<p>vectors for hotspot chromosomes, positions, and
sizes</p>
</td></tr>
<tr><td><code id="sim.hotspot_+3A_q.eff">Q.eff</code></td>
<td>
<p>QTL effect</p>
</td></tr>
<tr><td><code id="sim.hotspot_+3A_lod.range.1">lod.range.1</code>, <code id="sim.hotspot_+3A_lod.range.2">lod.range.2</code>, <code id="sim.hotspot_+3A_lod.range.3">lod.range.3</code></td>
<td>
<p>2-vectors of LOD ranges for
multiple purposes</p>
</td></tr>
<tr><td><code id="sim.hotspot_+3A_verbose">verbose</code></td>
<td>
<p>Verbose output if <code>TRUE</code>. More detailed output if <code>2</code>.</p>
</td></tr>
<tr><td><code id="sim.hotspot_+3A_...">...</code></td>
<td>
<p>Arguments passed directly to <code>sim.hotspot</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Simulate <code>nSim</code> realizations of cross object with <code>n.pheno</code> phenotypes with correlation
<code>latent.eff</code>. All simulations use the same genotypes in the
<code>cross</code> object.
</p>


<h3>Value</h3>

<p><code>sim.null.cross</code> simulates an object of class <code>cross</code>.
<code>sim.null.pheno.data</code> simulates a data frame of phenotypes.
<code>sim.hotspot</code> uses these other routines to simulate a hotspot,
returning an list object.
</p>


<h3>Author(s)</h3>

<p>Elias Chaibub Neto and Brian S. Yandell
</p>


<h3>See Also</h3>

<p><code><a href="#topic+sim.null.cross">sim.null.cross</a></code>, <code><a href="qtl.html#topic+read.cross">read.cross</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>ncross1 &lt;- sim.null.cross(chr.len = rep(100, 4),
                          n.mar = 51,
                          n.ind = 100,
                          type = "bc",
                          n.phe = 1000,
                          latent.eff = 3,
                          res.var = 1,
                          init.seed = 123457)
cross1 &lt;- include.hotspots(cross = ncross1,
                           hchr = c(2, 3, 4),
                           hpos = c(25, 75, 50),
                           hsize = c(100, 50, 20),
                           Q.eff = 2,
                           latent.eff = 3,
                           lod.range.1 = c(2.5, 2.5),
                           lod.range.2 = c(5, 8),
                           lod.range.3 = c(10, 15),
                           res.var = 1,
                           n.phe = 1000,
                           init.seed = 12345)
</code></pre>

<hr>
<h2 id='SimCrossCausal'>Simulate Cross for Causal Tests</h2><span id='topic+SimCrossCausal'></span><span id='topic+SimCrossIndep'></span><span id='topic+CMSTCross'></span>

<h3>Description</h3>

<p>Creates cross with certain pattern of dependence across phenotypes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>SimCrossCausal(n.ind, len, n.mar, beta, add.eff, dom.eff, 
  sig2.1 = 1, sig2.2 = 1, eq.spacing = FALSE, 
  cross.type = c("bc", "f2"), normalize = FALSE)
SimCrossIndep(n.ind, len, n.mar, beta, add.eff.1, dom.eff.1,
  add.eff.h, dom.eff.h, sig2.1 = 1, sig2.2 = 1, sig2.h = 1, 
  eq.spacing = FALSE, cross.type = "f2", normalize = FALSE)
data(CMSTCross)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="SimCrossCausal_+3A_n.ind">n.ind</code></td>
<td>
<p>number of individuals to simulate</p>
</td></tr>
<tr><td><code id="SimCrossCausal_+3A_len">len</code></td>
<td>
<p>vector specifying the chromosome lengths (in cM)</p>
</td></tr>
<tr><td><code id="SimCrossCausal_+3A_n.mar">n.mar</code></td>
<td>
<p>vector specifying the number of markers per chromosome</p>
</td></tr>
<tr><td><code id="SimCrossCausal_+3A_beta">beta</code></td>
<td>
<p>causal effect (slope) of first phenotype on others</p>
</td></tr>
<tr><td><code id="SimCrossCausal_+3A_add.eff">add.eff</code>, <code id="SimCrossCausal_+3A_add.eff.1">add.eff.1</code>, <code id="SimCrossCausal_+3A_add.eff.h">add.eff.h</code></td>
<td>
<p>additive genetic effect</p>
</td></tr>
<tr><td><code id="SimCrossCausal_+3A_dom.eff">dom.eff</code>, <code id="SimCrossCausal_+3A_dom.eff.1">dom.eff.1</code>, <code id="SimCrossCausal_+3A_dom.eff.h">dom.eff.h</code></td>
<td>
<p>dominance genetic effect</p>
</td></tr>
<tr><td><code id="SimCrossCausal_+3A_sig2.1">sig2.1</code></td>
<td>
<p>residual variance for first phenotype</p>
</td></tr>
<tr><td><code id="SimCrossCausal_+3A_sig2.2">sig2.2</code>, <code id="SimCrossCausal_+3A_sig2.h">sig2.h</code></td>
<td>
<p>residual variance for all other phenotypes</p>
</td></tr>
<tr><td><code id="SimCrossCausal_+3A_eq.spacing">eq.spacing</code></td>
<td>
<p>if <code>TRUE</code>, markers will be equally spaced</p>
</td></tr>
<tr><td><code id="SimCrossCausal_+3A_cross.type">cross.type</code></td>
<td>
<p>type of cross (<code>bc</code> and <code>f2</code> for now)</p>
</td></tr>
<tr><td><code id="SimCrossCausal_+3A_normalize">normalize</code></td>
<td>
<p>normalize values if <code>TRUE</code></p>
</td></tr>
</table>


<h3>References</h3>

<p>Chaibub Neto E, Broman AT, Keller MP, Attie AD, Zhang B, Zhu J, Yandell BS,
Causal model selection hypothesis tests in systems genetics.
Genetics (in review).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(987654321)
CMSTCross &lt;- SimCrossCausal(n.ind = 100, 
  len = rep(100, 3), n.mar = 101,
  beta = rep(0.5, 2), add.eff = 1, dom.eff = 0, 
  sig2.1 = 0.4, sig2.2 = 0.1, eq.spacing = FALSE, 
  cross.type = "bc", normalize = TRUE)
CMSTCross &lt;- calc.genoprob(CMSTCross, step = 1)
## Not run: 
save(CMSTCross, file = "CMSTCross.RData", compress = TRUE)

## End(Not run)
</code></pre>

<hr>
<h2 id='ww.perm'>Conduct West-Wu (Q) permutation tests</h2><span id='topic+ww.perm'></span><span id='topic+summary.ww.perm'></span><span id='topic+print.ww.perm'></span>

<h3>Description</h3>

<p>Conduct West-Wu (Q) permutation tests.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ww.perm(highobj, n.perm, lod.thrs, alpha.levels, verbose = FALSE)
## S3 method for class 'ww.perm'
print(x, ...)
## S3 method for class 'ww.perm'
summary(object, alpha.levels, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ww.perm_+3A_highobj">highobj</code></td>
<td>
<p>object of class <code><a href="#topic+highlod">highlod</a></code></p>
</td></tr>
<tr><td><code id="ww.perm_+3A_n.perm">n.perm</code></td>
<td>
<p>number of permutations</p>
</td></tr>
<tr><td><code id="ww.perm_+3A_lod.thrs">lod.thrs</code></td>
<td>
<p>vector of LOD thresholds</p>
</td></tr>
<tr><td><code id="ww.perm_+3A_alpha.levels">alpha.levels</code></td>
<td>
<p>vector of significance levels</p>
</td></tr>
<tr><td><code id="ww.perm_+3A_x">x</code>, <code id="ww.perm_+3A_object">object</code></td>
<td>
<p>object of class <code>ww.perm</code></p>
</td></tr>
<tr><td><code id="ww.perm_+3A_...">...</code></td>
<td>
<p>ignored</p>
</td></tr>
<tr><td><code id="ww.perm_+3A_verbose">verbose</code></td>
<td>
<p>verbose output if <code>TRUE</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>Perform permutation tests to assess the statistical significance of the
hotspots detected using the West-Wu <code>Q</code>-method permutations. The
<code>ww.perm</code> function implements the <code>Q</code>-method's permutation
scheme (see the Method's section of Chaibub Neto et a. 2012, for
details). The <code>n.perm</code> parameter specifies the number of
simulations. Here we set it to 100 in order to save time. In practice,
we recommend at least 1,000 permutations. The function's output is a
matrix with 100 rows representing the permutations, and 10 columns
representing the QTL mapping thresholds. Each entry <code>ij</code>, represents the
maximum number of significant linkages across the entire genome detected
at permutation <code>i</code>, using the LOD threshold <code>j</code>. The
<code>ww.summary</code> function computes the Q-method's hotspot size
permutation thresholds, that is, the <code>1-alpha</code> quantiles for each
one of the QTL mapping LOD thrsholds in <code>lod.thrs</code>. For instance,
the entry at row 10 and column 1 of the <code>Q.1.thr</code> matrix tells us
that the 99% percentile of the permutation distribution of genome wide
maximum hotspot size based on a QTL mapping threshold of 2.11 is
27.00. In other words, any hotspot greater than 27 is considered
statistically significant at a 0.01 significance level when QTL mapping
is done using a 2.11 LOD threshold. 
In general, we are often interested in using the same error rates for
the QTL mapping and hotspot analysis. That is, if we adopt a QTL mapping
threshold that controls GWER at a 1% level (in our case, 3.11) we will
also want to consider <code>alpha = 0.01</code> for the hotspot analysis,
leading to a hotspot threshold of 12.00. Therefore, we are usually more
interested in the diagonal of <code>Q.1.thr</code>. We adopted a GWER of 5%,
and the corresponding <code>Q</code>-method's permutation threshold is
18. According to this threshold, all hotspots are significant. 
</p>


<h3>Author(s)</h3>

<p>Elias Chaibub Neto and Brian S Yandell
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
## All unspecified objects come from vignette qtlhot.
set.seed(12345)
Q.1 &lt;- ww.perm(high1, n.perm = 100, lod.thrs, alphas)
Q.1.thr &lt;- summary(Q.1, alphas)
Q.1.thr
diag(Q.1.thr)

set.seed(12345)
Q.2 &lt;- ww.perm(high2, 100, lod.thrs, alphas)
Q.2.thr &lt;- summary(Q.2, alphas)

## End(Not run)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
