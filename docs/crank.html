<!DOCTYPE html><html><head><title>Help for package crank</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {crank}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#cats2ranks'><p>Ordered option selections to ranks</p></a></li>
<li><a href='#elrepos'><p>Move the position of an element in a vector.</p></a></li>
<li><a href='#fillArow'><p>Impute a row of ranks using the existing values of rankings</p></a></li>
<li><a href='#fillArows'><p>Impute ranks using the existing values of rankings</p></a></li>
<li><a href='#getLWargs'><p>Get the information about a matrix of ranks.</p></a></li>
<li><a href='#listBuilder'><p>Build a possibly nested list.</p></a></li>
<li><a href='#listCrawler'><p>Descend a list, applying a function to each element.</p></a></li>
<li><a href='#lw.FriedmanTest'><p>Wrapper for the Friedman test function.</p></a></li>
<li><a href='#lwscreen'><p>Impute ranks using the existing values of rankings</p></a></li>
<li><a href='#meanranks'><p>Calculate mean ranks with possible missing values</p></a></li>
<li><a href='#muranks'><p>Complete a matrix of rankings</p></a></li>
<li><a href='#page.trend.test'><p>Page test for ordered alternatives</p></a></li>
<li><a href='#permute'><p>Permute a vector.</p></a></li>
<li><a href='#print.cats2ranks'><p>Print the result of cats2ranks</p></a></li>
<li><a href='#print.lwstat'><p>Print the result of lwscreen</p></a></li>
<li><a href='#print.meanranks'><p>Print the result of meanranks</p></a></li>
<li><a href='#print.page.trend.test'><p>prints the L statistic for Page's trend test</p></a></li>
<li><a href='#spsort'><p>Simple partial sorting of a vector of elements.</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Version:</td>
<td>1.1-2</td>
</tr>
<tr>
<td>Title:</td>
<td>Completing Ranks</td>
</tr>
<tr>
<td>Date:</td>
<td>2019-04-08</td>
</tr>
<tr>
<td>Author:</td>
<td>Jim Lemon &lt;drjimlemon@gmail.com&gt;,</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Jim Lemon &lt;drjimlemon@gmail.com&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Functions for completing and recalculating rankings and sorting.</td>
</tr>
<tr>
<td>Imports:</td>
<td>stats</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2019-04-08 00:43:44 UTC; root</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2019-04-09 04:23:01 UTC</td>
</tr>
</table>
<hr>
<h2 id='cats2ranks'>Ordered option selections to ranks</h2><span id='topic+cats2ranks'></span>

<h3>Description</h3>

<p>Convert ordered option selections to ranks, assigning the mean of unused
ranks to unselected options.
</p>


<h3>Usage</h3>

<pre><code class='language-R'> cats2ranks(x,cats=NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cats2ranks_+3A_x">x</code></td>
<td>
<p>A matrix or data frame of numeric or characters labels for options.
Rows are interpreted as cases or respondents and columns are interpreted as
the order of option selections, beginning with the highest ranking
(usually something like &quot;Most important&quot;) and descending.</p>
</td></tr>
<tr><td><code id="cats2ranks_+3A_cats">cats</code></td>
<td>
<p>The range of numbers that represent options. The default is the
vector of unique entries in &lsquo;<span class="samp">&#8288;x&#8288;</span>&rsquo;.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>&lsquo;<span class="samp">&#8288;cats2ranks&#8288;</span>&rsquo; converts ordered option selections to mean ranks. It is
useful in the situation where a respondent is asked to select one of a number
of options as the most important, another as the second most important, and
so on. It counts the number of times each option code appears in each column
and calculates the mean ranking of options. It is expected that there will be
fewer selections available than there are options, thus creating the opportunity
for biased rankings. This can occur when one or more options are not commonly
chosen, but are given extreme (usually high) ranks when they are. The function
calculates the mean of unallocated ranks and assigns this to all options not
chosen by each respondent, correcting for this bias. The correction assumes
that the respondent does not differentiate between unranked options, but these
are all ranked lower than the options selected.
</p>
<p>&lsquo;<span class="samp">&#8288;cats2ranks&#8288;</span>&rsquo; is especially useful when respondents do not select the same
number of options. The mean of unallocated ranks is calculated for each
respondent so that all options are entered into the calculation of mean ranks.
</p>
<p>Note that &lsquo;<span class="samp">&#8288;cats2ranks&#8288;</span>&rsquo; interprets each value in &lsquo;<span class="samp">&#8288;x&#8288;</span>&rsquo; as a nominal
level variable and its column index as the rank, while &lsquo;<span class="samp">&#8288;meanranks&#8288;</span>&rsquo;
interprets values as ordinal level (ranks). Thus if a matrix or data frame
of ranks is passed to &lsquo;<span class="samp">&#8288;cats2ranks&#8288;</span>&rsquo;, it will not give the correct mean
ranks or relative positions.
</p>


<h3>Value</h3>

<p>A list with four components:
</p>
<table>
<tr><td><code>ranks</code></td>
<td>
<p>The matrix of completed ranks.</p>
</td></tr>
<tr><td><code>cats</code></td>
<td>
<p>The vector of options as passed or calculated.</p>
</td></tr>
<tr><td><code>ranksum</code></td>
<td>
<p>The sum of ranks for each option.</p>
</td></tr>
<tr><td><code>rankcount</code></td>
<td>
<p>The number of times each option was selected.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Jim Lemon</p>


<h3>See Also</h3>

<p><a href="#topic+muranks">muranks</a>,<a href="#topic+meanranks">meanranks</a></p>


<h3>Examples</h3>

<pre><code class='language-R'> # first a standard 1:m numerically coded selection
 opchoice&lt;-matrix(NA,nrow=40,ncol=5)
 for(i in 1:40) opchoice[i,]&lt;-sample(1:10,5)
 opchoice
 cats2ranks(opchoice)
 # now a messy character choice with missing values
 opchoice&lt;-matrix(NA,nrow=40,ncol=5)
 tencolors&lt;-c("red","green","blue","yellow","magenta","cyan",
  "purple","orange","brown","pink")
 for(i in 1:40) {
  nchoices&lt;-sample(3:5,1)
  opchoice[i,1:nchoices]&lt;-sample(tencolors,nchoices)
 }
 opchoice
 cats2ranks(opchoice)
</code></pre>

<hr>
<h2 id='elrepos'>Move the position of an element in a vector.</h2><span id='topic+elrepos'></span>

<h3>Description</h3>

<p>Move the position of an element in a vector.</p>


<h3>Usage</h3>

<pre><code class='language-R'>elrepos(x,i1,i2)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="elrepos_+3A_x">x</code></td>
<td>
<p>A vector of unique values.</p>
</td></tr>
<tr><td><code id="elrepos_+3A_i1">i1</code>, <code id="elrepos_+3A_i2">i2</code></td>
<td>
<p>The position (i1) in the vector of an element that should be ahead of 
the element in position i2.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>&lsquo;<span class="samp">&#8288;elrepos&#8288;</span>&rsquo; saves the element in position i1 of the vector x and removes
that element from x. It then inserts the element that was in position i1 just 
before the element in position i2.
</p>


<h3>Value</h3>

<p>The vector &lsquo;<span class="samp">&#8288;x&#8288;</span>&rsquo; with the position of one element changed as above.</p>


<h3>Note</h3>

<p>Currently this function is only useful to perform the position changing
for the function &lsquo;<span class="samp">&#8288;spsort&#8288;</span>&rsquo;.</p>


<h3>Author(s)</h3>

<p>Jim Lemon</p>


<h3>See Also</h3>

<p>spsort</p>


<h3>Examples</h3>

<pre><code class='language-R'> x&lt;-unlist(strsplit("lemon",""))
 y&lt;-elrepos(x,3,1)
 z&lt;-elrepos(y,2,1)
 paste0(z,collapse="")
</code></pre>

<hr>
<h2 id='fillArow'>Impute a row of ranks using the existing values of rankings</h2><span id='topic+fillArow'></span>

<h3>Description</h3>

<p>Imputes a row of missing ranks using the Lim-Wolfe procedure</p>


<h3>Usage</h3>

<pre><code class='language-R'> fillArow(x,ranksums=NA,Arow,maxcon=TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fillArow_+3A_x">x</code></td>
<td>
<p>A matrix of ranks that may contain ties and NAs. Columns
represent objects ranked and rows represent ranking methods.</p>
</td></tr>
<tr><td><code id="fillArow_+3A_ranksums">ranksums</code></td>
<td>
<p>The sums of ranks of all complete rows in &lsquo;<span class="samp">&#8288;x&#8288;</span>&rsquo;.</p>
</td></tr>
<tr><td><code id="fillArow_+3A_arow">Arow</code></td>
<td>
<p>The row of &lsquo;<span class="samp">&#8288;x&#8288;</span>&rsquo; that is to be completed.</p>
</td></tr>
<tr><td><code id="fillArow_+3A_maxcon">maxcon</code></td>
<td>
<p>Whether to impute rankings maximally consistent with
the existing ones (TRUE) or minimally consistent (FALSE).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>&lsquo;<span class="samp">&#8288;fillArow&#8288;</span>&rsquo; imputes missing ranks in the row designated by &lsquo;<span class="samp">&#8288;Arow&#8288;</span>&rsquo;
using the information in &lsquo;<span class="samp">&#8288;ranksums&#8288;</span>&rsquo;. If the ranks already completed
provide information on the order of imputation, that is used directly for
imputed ranks of maximal consistency or inversely for imputed ranks of
minimal consistency. If the existing ranks do not provide such information,
the missing ranks are permuted, and a list of matrices with all the
permutations is substituted. This may involve a recursive call to 
&lsquo;<span class="samp">&#8288;fillArow&#8288;</span>&rsquo; and produce a nested list of matrices. See Lim and Wolfe 
(2002) for details of this process.
</p>


<h3>Value</h3>

<p>The matrix &lsquo;<span class="samp">&#8288;x&#8288;</span>&rsquo; with row &lsquo;<span class="samp">&#8288;Arow&#8288;</span>&rsquo; completed or a list of such
matrices, possibly nested.
</p>


<h3>Author(s)</h3>

<p>Jim Lemon</p>


<h3>References</h3>

<p>Lim, D.H. &amp; Wolfe, D.A. (2002) An efficient alternative to average
ranks for testing with incomplete ranking data. Biometrical Journal,
43(2): 187-206.
</p>


<h3>See Also</h3>

<p><a href="#topic+lwscreen">lwscreen</a>, <a href="#topic+listBuilder">listBuilder</a>, <a href="#topic+fillArows">fillArows</a></p>


<h3>Examples</h3>

<pre><code class='language-R'> # The first example matrix from Lim and Wolfe (2002)
 lwmat&lt;-matrix(c(3,1,2,4,NA,2,1,NA,2,NA,1,NA),nrow=3,byrow=TRUE)
 # complete the second row with maximal consistency
 fillArow(lwmat,lwmat[1,],2)
 # now with minimal consistency
 fillArow(lwmat,lwmat[1,],2,maxcon=FALSE)
</code></pre>

<hr>
<h2 id='fillArows'>Impute ranks using the existing values of rankings</h2><span id='topic+fillArows'></span>

<h3>Description</h3>

<p>Imputes missing ranks using the Lim-Wolfe procedure</p>


<h3>Usage</h3>

<pre><code class='language-R'> fillArows(x,maxcon=TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fillArows_+3A_x">x</code></td>
<td>
<p>A matrix of ranks that may contain ties and NAs. Columns
represent objects ranked and rows represent ranking methods.</p>
</td></tr>
<tr><td><code id="fillArows_+3A_maxcon">maxcon</code></td>
<td>
<p>Whether to impute rankings maximally consistent with
the existing ones (TRUE) or minimally consistent (FALSE).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>&lsquo;<span class="samp">&#8288;fillArows&#8288;</span>&rsquo; imputes missing ranks by examining the completed ranks for
each set of rows that have the same number of missing ranks. If more than one
row has the minimum number of missing values, the order of these rows is
permuted and the matrix &lsquo;<span class="samp">&#8288;x&#8288;</span>&rsquo; becomes a list of matrices in which the
values in the rows will be imputed in different orders. Another level of
permutation and multiplication of matrices may occur in &lsquo;<span class="samp">&#8288;fillArow&#8288;</span>&rsquo; to
which the matrices are passed for the actual imputation. The function
&lsquo;<span class="samp">&#8288;getLWargs&#8288;</span>&rsquo; is called to get the arguments for &lsquo;<span class="samp">&#8288;fillArow&#8288;</span>&rsquo;. 
See Lim and Wolfe (2002) for details of this process.
</p>


<h3>Value</h3>

<p>A list of one or more completed matrices of ranks, possibly nested.
</p>


<h3>Author(s)</h3>

<p>Jim Lemon</p>


<h3>References</h3>

<p>Lim, D.H. &amp; Wolfe, D.A. (2002) An efficient alternative to average
ranks for testing with incomplete ranking data. Biometrical Journal,
43(2): 187-206.
</p>


<h3>See Also</h3>

<p><a href="#topic+lwscreen">lwscreen</a>, <a href="#topic+getLWargs">getLWargs</a>, <a href="#topic+fillArow">fillArow</a></p>


<h3>Examples</h3>

<pre><code class='language-R'> # The first example matrix from Lim and Wolfe (2002)
 lwmat&lt;-matrix(c(3,1,2,4,NA,2,1,NA,2,NA,1,NA),nrow=3,byrow=TRUE)
 # complete with maximal consistency, permuting row order
 fillArows(lwmat)
 # now with minimal consistency as above
 fillArows(lwmat,maxcon=FALSE)
</code></pre>

<hr>
<h2 id='getLWargs'>Get the information about a matrix of ranks.</h2><span id='topic+getLWargs'></span>

<h3>Description</h3>

<p>Get the information required for imputing missing ranks.</p>


<h3>Usage</h3>

<pre><code class='language-R'> getLWargs(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getLWargs_+3A_x">x</code></td>
<td>
<p>A matrix of ranks, usually containing missing values.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>&lsquo;<span class="samp">&#8288;getLWargs&#8288;</span>&rsquo; calculates the information required for &lsquo;<span class="samp">&#8288;fillArows&#8288;</span>&rsquo;
and &lsquo;<span class="samp">&#8288;fillArow&#8288;</span>&rsquo; to impute the missing ranks in a matrix.
</p>


<h3>Value</h3>

<p>A list containing the following:
</p>
<table>
<tr><td><code>ranksums</code></td>
<td>
<p>The column sums of the complete rows of the matrix.</p>
</td></tr>
<tr><td><code>Arows</code></td>
<td>
<p>The indices of the row(s) with the minimal number of missing
values.</p>
</td></tr>
<tr><td><code>nArows</code></td>
<td>
<p>The number of Arows.</p>
</td></tr>
<tr><td><code>Brows</code></td>
<td>
<p>The indices of the complete rows.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Jim Lemon</p>


<h3>See Also</h3>

<p><a href="#topic+listBuilder">listBuilder</a></p>


<h3>Examples</h3>

<pre><code class='language-R'> # The first example matrix from Lim and Wolfe (2002)
 lwmat&lt;-matrix(c(3,1,2,4,NA,2,1,NA,2,NA,1,NA),nrow=3,byrow=TRUE) 
 getLWargs(lwmat)
</code></pre>

<hr>
<h2 id='listBuilder'>Build a possibly nested list.</h2><span id='topic+listBuilder'></span>

<h3>Description</h3>

<p>Build a possibly nested list using the result of a function.</p>


<h3>Usage</h3>

<pre><code class='language-R'> listBuilder(x,FUN=NULL,fargs=NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="listBuilder_+3A_x">x</code></td>
<td>
<p>The object that will be the first argument of &lsquo;<span class="samp">&#8288;FUN&#8288;</span>&rsquo;, or a
possibly nested list of such objects.</p>
</td></tr>
<tr><td><code id="listBuilder_+3A_fun">FUN</code></td>
<td>
<p>A function that can accept &lsquo;<span class="samp">&#8288;x&#8288;</span>&rsquo; as its first argument.</p>
</td></tr>
<tr><td><code id="listBuilder_+3A_fargs">fargs</code></td>
<td>
<p>A list of the remaining arguments to &lsquo;<span class="samp">&#8288;FUN&#8288;</span>&rsquo;.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>&lsquo;<span class="samp">&#8288;listBuilder&#8288;</span>&rsquo; descends the list structure of &lsquo;<span class="samp">&#8288;x&#8288;</span>&rsquo; if it is a
list until it encounters a non-list element. It then passes that element
as the first argument to &lsquo;<span class="samp">&#8288;FUN&#8288;</span>&rsquo; and returns the value of &lsquo;<span class="samp">&#8288;FUN&#8288;</span>&rsquo;.
This may be a list of elements, replacing the original element, hence the
name.
</p>


<h3>Value</h3>

<p>If &lsquo;<span class="samp">&#8288;x&#8288;</span>&rsquo; is not a list and &lsquo;<span class="samp">&#8288;FUN&#8288;</span>&rsquo; is NULL, &lsquo;<span class="samp">&#8288;x&#8288;</span>&rsquo; is returned.
If &lsquo;<span class="samp">&#8288;FUN&#8288;</span>&rsquo; creates a list from one or more elements of &lsquo;<span class="samp">&#8288;x&#8288;</span>&rsquo;, a
list or nested list will be returned. Successive calls to &lsquo;<span class="samp">&#8288;listBuilder&#8288;</span>&rsquo;
can rapidly create very large, deeply nested list structures.
</p>


<h3>Author(s)</h3>

<p>Jim Lemon</p>


<h3>See Also</h3>

<p><a href="base.html#topic+list">list</a></p>


<h3>Examples</h3>

<pre><code class='language-R'> # define a function that splits a vector into a list
 splitvec&lt;-function(x) {
  xlen&lt;-length(x)
  if(xlen &gt; 1) {
   newx&lt;-vector("list",xlen)
   for(newlist in 1:xlen) newx[[newlist]]&lt;-x[newlist]
   return(newx)
  }
  return(x)
 }
 testlist&lt;-list(c(9,16),list(25,c(36,49)))
 listBuilder(testlist,splitvec)
</code></pre>

<hr>
<h2 id='listCrawler'>Descend a list, applying a function to each element.</h2><span id='topic+listCrawler'></span>

<h3>Description</h3>

<p>Descend a possibly nested list, seeking the element that has the
extreme value of a function.</p>


<h3>Usage</h3>

<pre><code class='language-R'> listCrawler(x,FUN=NULL,maxval=TRUE,
  retval=list(indx=vector("numeric",0),element=NULL,value=NA))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="listCrawler_+3A_x">x</code></td>
<td>
<p>The object that will be the first argument of &lsquo;<span class="samp">&#8288;FUN&#8288;</span>&rsquo;, or a
possibly nested list of such objects.</p>
</td></tr>
<tr><td><code id="listCrawler_+3A_fun">FUN</code></td>
<td>
<p>A function that can accept &lsquo;<span class="samp">&#8288;x&#8288;</span>&rsquo; as its first argument.</p>
</td></tr>
<tr><td><code id="listCrawler_+3A_maxval">maxval</code></td>
<td>
<p>Whether to look for maximal (TRUE) or minimal (FALSE) values of
the function &lsquo;<span class="samp">&#8288;FUN&#8288;</span>&rsquo;.</p>
</td></tr>
<tr><td><code id="listCrawler_+3A_retval">retval</code></td>
<td>
<p>The list that is eventually returned.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>&lsquo;<span class="samp">&#8288;listCrawler&#8288;</span>&rsquo; descends the list structure of &lsquo;<span class="samp">&#8288;x&#8288;</span>&rsquo; applying &lsquo;<span class="samp">&#8288;FUN&#8288;</span>&rsquo;
to any non-list elements it encounters. If the value of &lsquo;<span class="samp">&#8288;FUN&#8288;</span>&rsquo; is larger or
smaller than the current extremum (depending upon the value of &lsquo;<span class="samp">&#8288;maxval&#8288;</span>&rsquo;),
the new value becomes the current extremum. The default value of &lsquo;<span class="samp">&#8288;FUN&#8288;</span>&rsquo; just
takes the value of the elements.
</p>


<h3>Value</h3>

<p>A list containing:
</p>
<table>
<tr><td><code>indx</code></td>
<td>
<p>the indices of the element producing the extreme value of
&lsquo;<span class="samp">&#8288;FUN&#8288;</span>&rsquo;.</p>
</td></tr>
<tr><td><code>element</code></td>
<td>
<p>The element that produced the extremum.</p>
</td></tr>
<tr><td><code>value</code></td>
<td>
<p>The extreme value of &lsquo;<span class="samp">&#8288;FUN&#8288;</span>&rsquo;.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Jim Lemon</p>


<h3>See Also</h3>

<p><a href="base.html#topic+list">list</a>, <a href="#topic+listBuilder">listBuilder</a></p>


<h3>Examples</h3>

<pre><code class='language-R'> # a simple example using the square root function
 testlist&lt;-list(list(9,16),list(25,list(36,49)))
 # first get the default maximum
 listCrawler(testlist,sqrt)
 # then the minimum
 listCrawler(testlist,sqrt,maxval=FALSE)
</code></pre>

<hr>
<h2 id='lw.FriedmanTest'>Wrapper for the Friedman test function.</h2><span id='topic+lw.FriedmanTest'></span>

<h3>Description</h3>

<p>Wrapper for the Friedman test function.</p>


<h3>Usage</h3>

<pre><code class='language-R'> lw.FriedmanTest(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="lw.FriedmanTest_+3A_x">x</code></td>
<td>
<p>A matrix of ranks.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Calls &lsquo;<span class="samp">&#8288;friedman.test&#8288;</span>&rsquo; and returns a vector containing the statistic
and p value.
</p>


<h3>Value</h3>

<p>The statistic and p value returned by &lsquo;<span class="samp">&#8288;friedman.test&#8288;</span>&rsquo;.</p>


<h3>Author(s)</h3>

<p>Jim Lemon</p>


<h3>See Also</h3>

<p><a href="stats.html#topic+friedman.test">friedman.test</a></p>

<hr>
<h2 id='lwscreen'>Impute ranks using the existing values of rankings</h2><span id='topic+lwscreen'></span>

<h3>Description</h3>

<p>Completes a matrix with missing ranks for the values maximally
and minimally consistent with existing values using the Lim-Wolfe procedure</p>


<h3>Usage</h3>

<pre><code class='language-R'> lwscreen(x,scrtest="lw.FriedmanTest")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="lwscreen_+3A_x">x</code></td>
<td>
<p>A matrix of ranks that may contain ties and NAs. Columns
represent objects ranked and rows represent ranking methods.</p>
</td></tr>
<tr><td><code id="lwscreen_+3A_scrtest">scrtest</code></td>
<td>
<p>What test to use to determine the maximally and
minimally consistent imputed values.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>&lsquo;<span class="samp">&#8288;lwscreen&#8288;</span>&rsquo; calls &lsquo;<span class="samp">&#8288;fillArows&#8288;</span>&rsquo; to impute the missing ranks in the
matrix &lsquo;<span class="samp">&#8288;x&#8288;</span>&rsquo;. It then applies &lsquo;<span class="samp">&#8288;scrtest&#8288;</span>&rsquo; to all the matrices returned
and finds the minimum and maximum values. See Lim and Wolfe (2002) for
details of the algorithm.
</p>
<p>The algorithm for finding the maximally consistent and inconsistent rank
imputations is extremely computer intensive, creating large numbers of
permuted matrices when tied ranksums or multiple rows with the same number
of missing values are encountered. The APA election example in Lim and Wolfe
(2002) is beyond the capability of the average PC in the present
implementation.
</p>


<h3>Value</h3>

<p>The maximal and minimal statistics and p values for the list of completed
rank matrices obtained.
</p>


<h3>Author(s)</h3>

<p>Jim Lemon</p>


<h3>References</h3>

<p>Lim, D.H. &amp; Wolfe, D.A. (2002) An efficient alternative to average
ranks for testing with incomplete ranking data. Biometrical Journal,
43(2): 187-206.
</p>


<h3>See Also</h3>

<p><a href="#topic+lw.FriedmanTest">lw.FriedmanTest</a>, <a href="#topic+listBuilder">listBuilder</a>, <a href="#topic+fillArows">fillArows</a></p>


<h3>Examples</h3>

<pre><code class='language-R'> # The first example matrix from Lim and Wolfe (2002)
 lwmat&lt;-matrix(c(3,1,2,4,NA,2,1,NA,2,NA,1,NA),nrow=3,byrow=TRUE)
 lwscreen(lwmat)
</code></pre>

<hr>
<h2 id='meanranks'>Calculate mean ranks with possible missing values</h2><span id='topic+meanranks'></span>

<h3>Description</h3>

<p>Calculates mean ranks where some ranks may be missing</p>


<h3>Usage</h3>

<pre><code class='language-R'> meanranks(x,allranks=NULL,labels=NULL,rankx=FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="meanranks_+3A_x">x</code></td>
<td>
<p>A matrix of ranks that may contain ties and NAs. Objects
ranked are assumed to be columns and ranking methods rows.</p>
</td></tr>
<tr><td><code id="meanranks_+3A_allranks">allranks</code></td>
<td>
<p>An optional list of all ranks that might have been
made.</p>
</td></tr>
<tr><td><code id="meanranks_+3A_labels">labels</code></td>
<td>
<p>Optional labels for the ranks.</p>
</td></tr>
<tr><td><code id="meanranks_+3A_rankx">rankx</code></td>
<td>
<p>Whether to convert competition ranks, or any other set of
numeric values, into the usual mean rankings for ties.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>&lsquo;<span class="samp">&#8288;meanranks&#8288;</span>&rsquo; calls &lsquo;<span class="samp">&#8288;muranks&#8288;</span>&rsquo; to complete the rank matrix
before calculating the mean ranks for each column if there are any
NAs in &lsquo;<span class="samp">&#8288;x&#8288;</span>&rsquo;.
</p>
<p>Note that &lsquo;<span class="samp">&#8288;cats2ranks&#8288;</span>&rsquo; interprets each value in &lsquo;<span class="samp">&#8288;x&#8288;</span>&rsquo; as a nominal
level variable and its index as the rank, while &lsquo;<span class="samp">&#8288;meanranks&#8288;</span>&rsquo; interprets
values as ordinal level (ranks). Thus if a matrix or data frame of category
labels is passed to &lsquo;<span class="samp">&#8288;meanranks&#8288;</span>&rsquo;, it will not give the correct mean
ranks.
</p>


<h3>Value</h3>

<p>A list with the following components:
</p>
<table>
<tr><td><code>ranks</code></td>
<td>
<p>&lsquo;<span class="samp">&#8288;x&#8288;</span>&rsquo; with any NAs replaced by the mean of unallocated ranks
for each row.</p>
</td></tr>
<tr><td><code>labels</code></td>
<td>
<p>The vector of labels, defaulting to the integers 1:allranks.</p>
</td></tr>
<tr><td><code>mean.ranks</code></td>
<td>
<p>A vector of mean ranks for each value of allranks.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Jim Lemon</p>


<h3>See Also</h3>

<p><a href="#topic+muranks">muranks</a>, <a href="base.html#topic+rank">rank</a>, <a href="#topic+cats2ranks">cats2ranks</a></p>


<h3>Examples</h3>

<pre><code class='language-R'> # simulate "best/worst" ranking
 x&lt;-matrix(NA,nrow=10,ncol=10)
 for(i in 1:10) {
  nbest&lt;-sample(2:5,1)
  best&lt;-1:nbest
  nworst&lt;-sample(1:5,1)
  worst&lt;-(11-nworst):10
  rankpos&lt;-sample(1:10,nbest+nworst)
  x[i,rankpos]&lt;-c(best,worst)
 }
 x
 meanranks(x)
</code></pre>

<hr>
<h2 id='muranks'>Complete a matrix of rankings</h2><span id='topic+muranks'></span>

<h3>Description</h3>

<p>Fills an incomplete matrix of rankings with means of
unallocated ranks</p>


<h3>Usage</h3>

<pre><code class='language-R'> muranks(x,allranks=NULL,rankx=FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="muranks_+3A_x">x</code></td>
<td>
<p>A vector or matrix of rankings that may contain ties and NAs.
Objects ranked are assumed to be columns and ranking methods rows.</p>
</td></tr>
<tr><td><code id="muranks_+3A_allranks">allranks</code></td>
<td>
<p>An optional list of all ranks that might have been
allocated. Defaults to the unique values in &lsquo;<span class="samp">&#8288;x&#8288;</span>&rsquo;.</p>
</td></tr>
<tr><td><code id="muranks_+3A_rankx">rankx</code></td>
<td>
<p>Whether to apply the &lsquo;<span class="samp">&#8288;rank&#8288;</span>&rsquo; function (see Details).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>&lsquo;<span class="samp">&#8288;muranks&#8288;</span>&rsquo; assumes that the values in &lsquo;<span class="samp">&#8288;x&#8288;</span>&rsquo; are rankings with
values in the set &lsquo;<span class="samp">&#8288;allranks&#8288;</span>&rsquo; or if that is NULL, between 1 and the
number of columns or values in &lsquo;<span class="samp">&#8288;x&#8288;</span>&rsquo;. If any values in &lsquo;<span class="samp">&#8288;x&#8288;</span>&rsquo; are
outside this range, or if the missing ranks are not sequential, the
function will drop that row with a warning.
</p>
<p>For each row, the function finds the mean of those ranks in &lsquo;<span class="samp">&#8288;allranks&#8288;</span>&rsquo;
that were not allocated and substitutes that value for any missing values
in the row.
</p>
<p>If &lsquo;<span class="samp">&#8288;rankx&#8288;</span>&rsquo; is TRUE, each row is passed to &lsquo;<span class="samp">&#8288;rank&#8288;</span>&rsquo;. This will
convert competition ranks or any set of numbers to the usual mean rankings.
This will also override the rejection of rows in which the missing ranks
are not sequential, and may produce counterintuitive imputed ranks.
</p>


<h3>Value</h3>

<p>A matrix similar to &lsquo;<span class="samp">&#8288;x&#8288;</span>&rsquo; in which any NAs are replaced by the mean of
unallocated ranks for each row.
</p>


<h3>Note</h3>

<p>&lsquo;<span class="samp">&#8288;muranks&#8288;</span>&rsquo; will impute ranks for &quot;best/worst&quot; ranking, where the 
method (rater) allocates the highest ranks to the most preferred data 
objects and the lowest ranks to the least preferred. The mean of all 
unallocated ranks is imputed for unranked data objects. It is assumed that 
unranked data objects are considered less preferred than those allocated 
high ranks, more preferred than those allocated low ranks, and not 
differentiated from each other. If this assumption is not satisfied, 
&lsquo;<span class="samp">&#8288;muranks&#8288;</span>&rsquo; will warn the operator that one or more rows have been 
dropped. To explain this behavior, consider the case in which a method 
allocates the ranks 1,2,3,5,7,8 to eight data objects. Two ranks have not 
been allocated, 4 and 6. It would be possible to impute the mean, 5, to 
both, but this ignores the implicit information that the two data objects 
were differentiated by the rank 5, which is &quot;between&quot; them. Only in the 
unlikely case that both were considered equivalent to the object ranked 5 
would this be correct, as there is no way to establish which was more or 
less preferred. The operator should be aware that if &lsquo;<span class="samp">&#8288;rankx&#8288;</span>&rsquo; is TRUE, 
the unranked objects will be allocated the lowest ranks, which is unlikely 
to be correct.
</p>


<h3>Author(s)</h3>

<p>Jim Lemon</p>


<h3>See Also</h3>

<p><a href="#topic+meanranks">meanranks</a>,<a href="base.html#topic+rank">rank</a></p>


<h3>Examples</h3>

<pre><code class='language-R'> # simulate ranking from the top with variable completion
 x&lt;-matrix(NA,nrow=10,ncol=10)
 for(i in 1:10) {
  nx&lt;-sample(2:10,1)
  xx&lt;-sample(1:10,nx)
  x[i,xx]&lt;-1:nx
 }
 x
 muranks(x)
</code></pre>

<hr>
<h2 id='page.trend.test'>Page test for ordered alternatives</h2><span id='topic+page.trend.test'></span>

<h3>Description</h3>

<p>calculates the Page test for ordered alternatives.
</p>


<h3>Usage</h3>

<pre><code class='language-R'> page.trend.test(x,ranks=TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="page.trend.test_+3A_x">x</code></td>
<td>
<p>a 2D matrix of ranks or observations.</p>
</td></tr>
<tr><td><code id="page.trend.test_+3A_ranks">ranks</code></td>
<td>
<p>Whether the values in x are ranks or observations.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>&lsquo;<span class="samp">&#8288;page.trend.test&#8288;</span>&rsquo; will accept a matrix of ranks where the rows 
represent methods (usually raters) and the columns represent related
data objects. It apparently handles ties, but not missing values.
For small values of k (methods) or N (data objects), &lsquo;<span class="samp">&#8288;page.trend.test&#8288;</span>&rsquo; 
will try to look up the tabled values (as in Siegel &amp; Castellan (1988) for 
significance. For &lsquo;<span class="samp">&#8288;k,N &gt; 3,20&#8288;</span>&rsquo; or &lsquo;<span class="samp">&#8288;k,N &gt; 4-10,12&#8288;</span>&rsquo;, a normal 
approximation is returned. Only one of these values will be returned.
</p>
<p>If &lsquo;<span class="samp">&#8288;ranks&#8288;</span>&rsquo; is FALSE, the function ranks the values in &lsquo;<span class="samp">&#8288;x&#8288;</span>&rsquo; and then
calculates the test. If the values are already ranks, it usually makes
no difference.
</p>


<h3>Value</h3>

<table>
<tr><td><code>ranks</code></td>
<td>
<p>matrix of ranks</p>
</td></tr>
<tr><td><code>mean.ranks</code></td>
<td>
<p>mean ranks of data objects</p>
</td></tr>
<tr><td><code>L</code></td>
<td>
<p>value of the L statistic</p>
</td></tr>
<tr><td><code>p.table</code></td>
<td>
<p>whether the obtained L exceeded the table value for small k,N</p>
</td></tr>
<tr><td><code>Z</code></td>
<td>
<p>The normal approximation for larger k,N</p>
</td></tr>
<tr><td><code>pZ</code></td>
<td>
<p>the probability of the obtained normal value for larger k,N</p>
</td></tr>
</table>


<h3>Note</h3>

<p>The Page test for ordered alternatives is slightly more powerful than
the Friedman analysis of variance by ranks.</p>


<h3>Author(s)</h3>

<p>Jim Lemon - thanks to Mikhail Trofimov and Michael Kirchhof
for discovering major errors in the function and supplying the 
corrections</p>


<h3>References</h3>

<p>Siegel, S. &amp; Castellan, N.J.Jr. (1988) Nonparametric
statistics for the behavioral sciences. Boston, MA: McGraw-Hill.</p>


<h3>Examples</h3>

<pre><code class='language-R'> # Craig's data from Siegel &amp; Castellan, p 186
 soa.mat&lt;-matrix(c(.797,.873,.888,.923,.942,.956,
  .794,.772,.908,.982,.946,.913,
  .838,.801,.853,.951,.883,.837,
  .815,.801,.747,.859,.887,.902),nrow=4,byrow=TRUE)
 page.trend.test(soa.mat)
</code></pre>

<hr>
<h2 id='permute'>Permute a vector.</h2><span id='topic+permute'></span>

<h3>Description</h3>

<p>Permute the values contained in a vector.</p>


<h3>Usage</h3>

<pre><code class='language-R'> permute(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="permute_+3A_x">x</code></td>
<td>
<p>The vector of values that are to be permuted.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>&lsquo;<span class="samp">&#8288;permute&#8288;</span>&rsquo; calculates the number of permutations and creates a matrix
with that number of rows. It fills the first column with the elements of
&lsquo;<span class="samp">&#8288;x&#8288;</span>&rsquo; in groups large enough to cover the permutations of a vector with
one less value. It then fills the remaining columns by calling itself with
all values except the one in the first row of the current block. If
&lsquo;<span class="samp">&#8288;x&#8288;</span>&rsquo; has only two values, it returns the trivial permutation of &lsquo;<span class="samp">&#8288;x&#8288;</span>&rsquo;
and its reverse.
</p>


<h3>Value</h3>

<p>A matrix in which each row is a permutation of the values in &lsquo;<span class="samp">&#8288;x&#8288;</span>&rsquo;.
</p>


<h3>Author(s)</h3>

<p>Jim Lemon</p>


<h3>See Also</h3>

<p><a href="#topic+fillArows">fillArows</a>, <a href="#topic+fillArow">fillArow</a></p>


<h3>Examples</h3>

<pre><code class='language-R'> permute(c(5,8,3,9))
</code></pre>

<hr>
<h2 id='print.cats2ranks'>Print the result of cats2ranks</h2><span id='topic+print.cats2ranks'></span>

<h3>Description</h3>

<p>Print the result of cats2ranks.</p>


<h3>Usage</h3>

<pre><code class='language-R'> ## S3 method for class 'cats2ranks'
print(x,...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.cats2ranks_+3A_x">x</code></td>
<td>
<p>The result of cats2ranks.</p>
</td></tr>
<tr><td><code id="print.cats2ranks_+3A_...">...</code></td>
<td>
<p>a dummy argument to keep S3 methods happy</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Displays the names and mean ranks of the output of &lsquo;<span class="samp">&#8288;cats2ranks&#8288;</span>&rsquo; in
order of numerically ascending ranks.
</p>


<h3>Value</h3>

<p>nil</p>


<h3>Author(s)</h3>

<p>Jim Lemon</p>


<h3>See Also</h3>

<p><a href="#topic+cats2ranks">cats2ranks</a></p>

<hr>
<h2 id='print.lwstat'>Print the result of lwscreen</h2><span id='topic+print.lwstat'></span>

<h3>Description</h3>

<p>Print the result of lwscreen.</p>


<h3>Usage</h3>

<pre><code class='language-R'> ## S3 method for class 'lwstat'
print(x,...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.lwstat_+3A_x">x</code></td>
<td>
<p>The result of lwscreen.</p>
</td></tr>
<tr><td><code id="print.lwstat_+3A_...">...</code></td>
<td>
<p>a dummy argument to keep S3 methods happy</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Displays the output of &lsquo;<span class="samp">&#8288;lwscreen&#8288;</span>&rsquo;.
</p>


<h3>Value</h3>

<p>nil</p>


<h3>Author(s)</h3>

<p>Jim Lemon</p>


<h3>See Also</h3>

<p><a href="#topic+lwscreen">lwscreen</a></p>

<hr>
<h2 id='print.meanranks'>Print the result of meanranks</h2><span id='topic+print.meanranks'></span>

<h3>Description</h3>

<p>Print the result of meanranks.</p>


<h3>Usage</h3>

<pre><code class='language-R'> ## S3 method for class 'meanranks'
print(x,...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.meanranks_+3A_x">x</code></td>
<td>
<p>The result of meanranks.</p>
</td></tr>
<tr><td><code id="print.meanranks_+3A_...">...</code></td>
<td>
<p>a dummy argument to keep S3 methods happy</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Displays the names and mean ranks of the output of &lsquo;<span class="samp">&#8288;meanranks&#8288;</span>&rsquo; in
order of numerically ascending ranks.
</p>


<h3>Value</h3>

<p>nil</p>


<h3>Author(s)</h3>

<p>Jim Lemon</p>


<h3>See Also</h3>

<p><a href="#topic+meanranks">meanranks</a></p>

<hr>
<h2 id='print.page.trend.test'>prints the L statistic for Page's trend test</h2><span id='topic+print.page.trend.test'></span>

<h3>Description</h3>

<p>prints the obtained L statistic and the associated probability for the normal
approximation if the sample size is sufficiently large
</p>


<h3>Usage</h3>

<pre><code class='language-R'> ## S3 method for class 'page.trend.test'
print(x,...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.page.trend.test_+3A_x">x</code></td>
<td>
<p>an object returned from &lsquo;<span class="samp">&#8288;page.trend.test&#8288;</span>&rsquo;</p>
</td></tr>
<tr><td><code id="print.page.trend.test_+3A_...">...</code></td>
<td>
<p>arguments to be passed to &lsquo;<span class="samp">&#8288;print&#8288;</span>&rsquo;</p>
</td></tr>
</table>


<h3>Value</h3>

<p>nil
</p>


<h3>Author(s)</h3>

<p>Jim Lemon</p>

<hr>
<h2 id='spsort'>Simple partial sorting of a vector of elements.</h2><span id='topic+spsort'></span>

<h3>Description</h3>

<p>Sort the elements in a vector according to a set of precedence
rules.</p>


<h3>Usage</h3>

<pre><code class='language-R'>spsort(x,L=NULL)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="spsort_+3A_x">x</code></td>
<td>
<p>A matrix or data frame with at least two columns. The first two 
columns are interpreted as precedence pairs, meaning that the element in
column 1 should appear before the one in column 2.</p>
</td></tr>
<tr><td><code id="spsort_+3A_l">L</code></td>
<td>
<p>The vector of elements to be sorted. If NULL, it becomes all of the
unique elements in &lsquo;<span class="samp">&#8288;x[1:2,]&#8288;</span>&rsquo;.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>&lsquo;<span class="samp">&#8288;spsort&#8288;</span>&rsquo; steps through rows of &lsquo;<span class="samp">&#8288;x&#8288;</span>&rsquo; identifying the positions of the 
leading and trailing elements in each rule. If the leading element in the rule
does not precede the trailing element in L, its position in L is moved to just
ahead of the trailing element. If all of the possible precedence rules for the
vector L are specified, the sorting will be unique. In most cases, the order
of the result will depend upon the initial order of L and the order of the
precendence rules.
</p>


<h3>Value</h3>

<p>The vector &lsquo;<span class="samp">&#8288;L&#8288;</span>&rsquo; sorted by the rules in &lsquo;<span class="samp">&#8288;x&#8288;</span>&rsquo;.</p>


<h3>Author(s)</h3>

<p> Jim Lemon </p>


<h3>Examples</h3>

<pre><code class='language-R'> # Pedro's example
 Smaller&lt;-c("ASD", "DFE", "ASD", "SDR", "EDF", "ASD")
 Larger&lt;-c("SDR", "EDF", "KLM", "KLM", "SDR", "EDF")
 matComp&lt;-cbind(Smaller,Larger)
 spsort(matComp)
 # scramble the order of rules
 nmatrows&lt;-nrow(matComp)
 spsort(matComp[sample(1:nmatrows,nmatrows),])
 # David Urbina's example
 priors&lt;-c("A","B","C","C","D","E","E","F","G")
 posts&lt;-c("E","H","A","D","E","B","F","G","H")
 dinnerMat&lt;-cbind(priors,posts)
 spsort(dinnerMat)
 # add the condition that the taquitos must precede the guacamole
 dinnerMat&lt;-rbind(dinnerMat,c("G","B"))
 spsort(dinnerMat)
 # scramble the rows
 nmatrows&lt;-nrow(dinnerMat)
 spsort(dinnerMat[sample(1:nmatrows,nmatrows),])
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
