<!DOCTYPE html><html><head><title>Help for package rsi</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {rsi}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#calculate_indices'><p>Calculate indices from the bands of a raster</p></a></li>
<li><a href='#default_query_function'><p>Query a STAC API using a specific spatiotemporal area of interest</p></a></li>
<li><a href='#dem_band_mapping'><p>Landsat band mapping</p></a></li>
<li><a href='#filter_platforms'><p>Filter indices based on (relatively) complicated fields</p></a></li>
<li><a href='#get_stac_data'><p>Retrieve raster data from STAC endpoints</p></a></li>
<li><a href='#landsat_band_mapping'><p>Landsat band mapping</p></a></li>
<li><a href='#landsat_mask_function'><p>Create a Landsat mask raster from the QA band</p></a></li>
<li><a href='#landsat_platform_filter'><p>Filter Landsat features to only specific platforms</p></a></li>
<li><a href='#rsi-package'><p>rsi: Efficiently Retrieve and Process Satellite Imagery</p></a></li>
<li><a href='#sentinel1_band_mapping'><p>Sentinel-1 band mapping</p></a></li>
<li><a href='#sentinel2_band_mapping'><p>Sentinel-2 band mapping</p></a></li>
<li><a href='#sentinel2_mask_function'><p>Create a Sentinel-2 mask raster from the SCL band</p></a></li>
<li><a href='#sign_planetary_computer'><p>Sign STAC items retrieved from the Planetary Computer</p></a></li>
<li><a href='#spectral_indices'><p>Get a data frame of spectral indices</p></a></li>
<li><a href='#spectral_indices_url'><p>Get the URL to download spectral indices from</p></a></li>
<li><a href='#stack_rasters'><p>Create and save a multi-band output raster by combining input rasters</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Title:</td>
<td>Efficiently Retrieve and Process Satellite Imagery</td>
</tr>
<tr>
<td>Version:</td>
<td>0.1.2</td>
</tr>
<tr>
<td>Description:</td>
<td>Downloads spatial data from spatiotemporal asset catalogs 
    ('STAC'), computes standard spectral indices from the Awesome Spectral 
    Indices project (Montero et al. (2023) &lt;<a href="https://doi.org/10.1038%2Fs41597-023-02096-0">doi:10.1038/s41597-023-02096-0</a>&gt;) 
    against raster data, and glues the outputs together into predictor bricks. 
    Methods focus on interoperability with the broader spatial ecosystem; 
    function arguments and outputs use classes from 'sf' and 'terra', and data 
    downloading functions support complex 'CQL2' queries using 'rstac'.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.apache.org/licenses/LICENSE-2.0">Apache License (&ge; 2)</a></td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 4.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>future.apply, glue, jsonlite, proceduralnames, rlang, rstac,
sf, terra, tibble</td>
</tr>
<tr>
<td>Suggests:</td>
<td>curl, knitr, progressr, rmarkdown, testthat (&ge; 3.0.0), withr</td>
</tr>
<tr>
<td>Config/testthat/edition:</td>
<td>3</td>
</tr>
<tr>
<td>Config/testthat/parallel:</td>
<td>true</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.3.0</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/Permian-Global-Research/rsi">https://github.com/Permian-Global-Research/rsi</a>,
<a href="https://permian-global-research.github.io/rsi/">https://permian-global-research.github.io/rsi/</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/Permian-Global-Research/rsi/issues">https://github.com/Permian-Global-Research/rsi/issues</a></td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-02-12 19:42:31 UTC; mikemahoney218</td>
</tr>
<tr>
<td>Author:</td>
<td>Michael Mahoney <a href="https://orcid.org/0000-0003-2402-304X"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cre],
  Permian Global [cph, fnd]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Michael Mahoney &lt;mike.mahoney.218@gmail.com&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-02-13 17:00:23 UTC</td>
</tr>
</table>
<hr>
<h2 id='calculate_indices'>Calculate indices from the bands of a raster</h2><span id='topic+calculate_indices'></span>

<h3>Description</h3>

<p>This function computes any number of indices from an input raster via
<code><a href="terra.html#topic+predict">terra::predict()</a></code>. By default, this function is designed to work with
subsets of <code><a href="#topic+spectral_indices">spectral_indices()</a></code>, but it will work with any data frame with a
<code>formula</code>, <code>bands</code>, and <code>short_name</code> column.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>calculate_indices(raster, indices, output_filename, ..., names_suffix = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="calculate_indices_+3A_raster">raster</code></td>
<td>
<p>The raster (either as a SpatRaster or object readable by
<code><a href="terra.html#topic+rast">terra::rast()</a></code>) to compute indices from.</p>
</td></tr>
<tr><td><code id="calculate_indices_+3A_indices">indices</code></td>
<td>
<p>A data frame of indices to compute. The intent is for this
function to work with subsets of <a href="#topic+spectral_indices">spectral_indices</a>, but any data frame with
columns <code>formula</code> (containing a string representation of the equation used
to calculate the index), <code>bands</code> (a list column containing character vectors
of the necessary bands) and <code>short_name</code> (which will be used as the band
name) will work.</p>
</td></tr>
<tr><td><code id="calculate_indices_+3A_output_filename">output_filename</code></td>
<td>
<p>The filename to write the computed metrics to.</p>
</td></tr>
<tr><td><code id="calculate_indices_+3A_...">...</code></td>
<td>
<p>These dots are for future extensions and must be empty.</p>
</td></tr>
<tr><td><code id="calculate_indices_+3A_names_suffix">names_suffix</code></td>
<td>
<p>If not <code>NULL</code>, will be used (with <code><a href="base.html#topic+paste">paste()</a></code>) to add a
suffix to each of the band names returned.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>output_filename</code>, unchanged.
</p>


<h3>Security</h3>

<p>Note that this function is running code from the <code>formula</code> column of the
spectral indices data frame, which is derived from a JSON file downloaded off
the internet. It's not impossible that an attacker could take advantage of
this to run arbitrary code on your computer. To mitigate this, indices are
calculated in a minimal environment that contains very few functions or
symbols (preventing an attacker from accessing, for example, <code>system()</code>).
</p>
<p>Still, it's good practice to inspect your <code>formula</code> column to make sure
there's nothing nasty hiding in any of the formulas you're going to run.
Additionally, consider using pre-saved indices tables or
<code>spectral_indices(download_indices = FALSE)</code> if using this in an unsupervised
workload.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>calculate_indices(
  system.file("rasters/example_sentinel1.tif", package = "rsi"),
  filter_platforms(platforms = "Sentinel-1 (Dual Polarisation VV-VH)"),
  tempfile(fileext = ".tif"),
  names_suffix = "sentinel1"
)

# Formulas aren't able to access most R functions or operators:
example_indices &lt;- filter_platforms(platforms = "Sentinel-1 (Dual Polarisation VV-VH)")[1, ]
example_indices$formula &lt;- 'system("echo something bad")'
try(
  calculate_indices(
    system.file("rasters/example_sentinel1.tif", package = "rsi"),
    example_indices,
    tempfile(fileext = ".tif")
  )
)

</code></pre>

<hr>
<h2 id='default_query_function'>Query a STAC API using a specific spatiotemporal area of interest</h2><span id='topic+default_query_function'></span>

<h3>Description</h3>

<p>This function is the default method used to retrieve lists of items to
download for all the collections and endpoints supported by rsi. It will
likely work for any other STAC APIs of interest.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>default_query_function(
  bbox,
  stac_source,
  collection,
  start_date,
  end_date,
  limit,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="default_query_function_+3A_bbox">bbox</code></td>
<td>
<p>An sfc object representing the spatial bounding box of your area
of interest. This must be in EPSG:4326 coordinates (and, if this function is
called from within <code>get_stac_data()</code>, it will be)</p>
</td></tr>
<tr><td><code id="default_query_function_+3A_stac_source">stac_source</code></td>
<td>
<p>Character of length 1: the STAC URL to download
imagery from.</p>
</td></tr>
<tr><td><code id="default_query_function_+3A_collection">collection</code></td>
<td>
<p>Character of length 1: the STAC collection to download
images from.</p>
</td></tr>
<tr><td><code id="default_query_function_+3A_start_date">start_date</code>, <code id="default_query_function_+3A_end_date">end_date</code></td>
<td>
<p>Character strings of length 1 representing the
boundaries of your temporal range of interest, in RFC-3339 format. Set either
argument to <code>..</code> to use an open interval; set <code>start_date</code> to <code>NULL</code> to not
pass a temporal range of interest (which may cause errors with some APIs). If
this function is called from within <code>get_stac_data()</code>, the inputs to
<code>start_date</code> and <code>end_date</code> will have already been processed to try and force
RFC-3339 compliance.</p>
</td></tr>
<tr><td><code id="default_query_function_+3A_limit">limit</code></td>
<td>
<p>an <code>integer</code> defining the maximum number of results
to return. If not informed, it defaults to the service implementation.</p>
</td></tr>
<tr><td><code id="default_query_function_+3A_...">...</code></td>
<td>
<p>Ignored by this function. Arguments passed to <code>get_stac_data()</code>
via <code>...</code> will be available (unchanged) in this function</p>
</td></tr>
</table>


<h3>Details</h3>

<p>You can pass your own query functions to <code>get_stac_data()</code> and its variants.
This is the best way to perform more complex queries, for instance if you
need to provide authentication to get the list of items (not just the assets)
available for your AOI, or to perform cloud filtering prior to downloading
assets.
</p>


<h3>Value</h3>

<p>A StacItemCollection object.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
aoi &lt;- sf::st_point(c(-74.912131, 44.080410))
aoi &lt;- sf::st_set_crs(sf::st_sfc(aoi), 4326)
aoi &lt;- sf::st_buffer(sf::st_transform(aoi, 5070), 100)

landsat_image &lt;- get_landsat_imagery(
  aoi,
  start_date = "2022-06-01",
  end_date = "2022-08-30",
  query_function = default_query_function
)

</code></pre>

<hr>
<h2 id='dem_band_mapping'>Landsat band mapping</h2><span id='topic+dem_band_mapping'></span>

<h3>Description</h3>

<p>This object is structured slightly differently from other band mapping
objects; it is a list of named lists, whose names correspond to DEM
collections available within a given STAC catalog. Those named lists are
then more standard band mapping objects, containing character vectors with
names corresponding to asset names and values equal to <code>elevation</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dem_band_mapping
</code></pre>


<h3>Format</h3>

<p>An object of class <code>list</code> of length 1.
</p>


<h3>Details</h3>

<p>Band mapping objects:
</p>
<p>These objects are semi-standardized sets of metadata which provide all the
necessary information for downloading data from a given STAC server.
The object itself is list of character vectors, whose names represent asset
names on a given STAC server and whose values represent the corresponding
standardized band name from the Awesome Spectral Indices project. In addition
to this data, these vectors usually have some of (but not necessarily all of)
the following attributes:
</p>

<ul>
<li> <p><code>stac_source</code>: The URL for the STAC server this metadata corresponds to.
</p>
</li>
<li> <p><code>collection_name</code>: The default STAC collection for this data source.
</p>
</li>
<li> <p><code>download_function</code>: The function to be used to download assets from the
STAC server.
</p>
</li>
<li> <p><code>mask_band</code>: The name of the asset on this server to be used for masking
images.
</p>
</li>
<li> <p><code>mask_function</code>: The function to be used to mask images downloaded from
this server.
</p>
</li></ul>


<hr>
<h2 id='filter_platforms'>Filter indices based on (relatively) complicated fields</h2><span id='topic+filter_platforms'></span><span id='topic+filter_bands'></span>

<h3>Description</h3>

<p>Filter indices based on (relatively) complicated fields
</p>


<h3>Usage</h3>

<pre><code class='language-R'>filter_platforms(
  indices = spectral_indices(),
  platforms = unique(unlist(spectral_indices(download_indices = FALSE, update_cache =
    FALSE)$platforms)),
  operand = c("all", "any")
)

filter_bands(
  indices = spectral_indices(),
  bands = unique(unlist(spectral_indices(download_indices = FALSE, update_cache =
    FALSE)$bands)),
  operand = c("all", "any"),
  type = c("filter", "search")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="filter_platforms_+3A_indices">indices</code></td>
<td>
<p>The data frame to filter. Must contain the relevant column.</p>
</td></tr>
<tr><td><code id="filter_platforms_+3A_platforms">platforms</code>, <code id="filter_platforms_+3A_bands">bands</code></td>
<td>
<p>Names of the instruments (for <code>platforms</code>) or spectra
(for <code>bands</code>) indices must contain.</p>
</td></tr>
<tr><td><code id="filter_platforms_+3A_operand">operand</code></td>
<td>
<p>A function defining how to apply this filter.
For instance, <code>operand = all</code> means that the index must contain all the
<code>platforms</code> or <code>bands</code> provided, while <code>operand = any</code> means that the index
must contain at least one of the <code>platforms</code> or <code>bands</code> provided.</p>
</td></tr>
<tr><td><code id="filter_platforms_+3A_type">type</code></td>
<td>
<p>What type of query is this? If <code>filter</code>, then indices are
returned if all/any the bands they use (depending on <code>operand</code>) are in
<code>bands</code>. If <code>search</code>, then indices are returned if all/any of <code>bands</code> are in
the bands they use.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A filtered version of <code>indices</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>filter_platforms(platforms = "Sentinel-2")
filter_platforms(platforms = c("Landsat-OLI", "Sentinel-2"))
filter_bands(bands = c("R", "N"), operand = any)

</code></pre>

<hr>
<h2 id='get_stac_data'>Retrieve raster data from STAC endpoints</h2><span id='topic+get_stac_data'></span><span id='topic+get_sentinel1_imagery'></span><span id='topic+get_sentinel2_imagery'></span><span id='topic+get_landsat_imagery'></span><span id='topic+get_dem'></span>

<h3>Description</h3>

<p>These functions retrieve raster data from STAC endpoints and optionally
create composite data sets from multiple files.
<code>get_stac_data()</code> is a generic function which should be able to download
raster data from a variety of data sources, while the other helper functions
have useful defaults for downloading common data sets from standard
STAC sources.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_stac_data(
  aoi,
  start_date,
  end_date,
  pixel_x_size = NULL,
  pixel_y_size = NULL,
  asset_names,
  stac_source,
  collection,
  ...,
  query_function = default_query_function,
  sign_function = NULL,
  rescale_bands = TRUE,
  item_filter_function = NULL,
  mask_band = NULL,
  mask_function = NULL,
  output_filename = paste0(proceduralnames::make_english_names(1), ".tif"),
  composite_function = c("merge", "median", "mean", "sum", "min", "max"),
  limit = 999,
  gdalwarp_options = c("-r", "bilinear", "-multi", "-overwrite", "-co",
    "COMPRESS=DEFLATE", "-co", "PREDICTOR=2", "-co", "NUM_THREADS=ALL_CPUS"),
  gdal_config_options = c(VSI_CACHE = "TRUE", GDAL_CACHEMAX = "30%", VSI_CACHE_SIZE =
    "10000000", GDAL_HTTP_MULTIPLEX = "YES", GDAL_INGESTED_BYTES_AT_OPEN = "32000",
    GDAL_DISABLE_READDIR_ON_OPEN = "EMPTY_DIR", GDAL_HTTP_VERSION = "2",
    GDAL_HTTP_MERGE_CONSECUTIVE_RANGES = "YES", GDAL_NUM_THREADS = "ALL_CPUS")
)

get_sentinel1_imagery(
  aoi,
  start_date,
  end_date,
  ...,
  pixel_x_size = 10,
  pixel_y_size = 10,
  asset_names = rsi::sentinel1_band_mapping$planetary_computer_v1,
  stac_source = attr(asset_names, "stac_source"),
  collection = attr(asset_names, "collection_name"),
  query_function = attr(asset_names, "query_function"),
  sign_function = attr(asset_names, "sign_function"),
  rescale_bands = FALSE,
  item_filter_function = NULL,
  mask_band = NULL,
  mask_function = NULL,
  output_filename = paste0(proceduralnames::make_english_names(1), ".tif"),
  composite_function = "median",
  limit = 999,
  gdalwarp_options = c("-r", "bilinear", "-multi", "-overwrite", "-co",
    "COMPRESS=DEFLATE", "-co", "PREDICTOR=2", "-co", "NUM_THREADS=ALL_CPUS"),
  gdal_config_options = c(VSI_CACHE = "TRUE", GDAL_CACHEMAX = "30%", VSI_CACHE_SIZE =
    "10000000", GDAL_HTTP_MULTIPLEX = "YES", GDAL_INGESTED_BYTES_AT_OPEN = "32000",
    GDAL_DISABLE_READDIR_ON_OPEN = "EMPTY_DIR", GDAL_HTTP_VERSION = "2",
    GDAL_HTTP_MERGE_CONSECUTIVE_RANGES = "YES", GDAL_NUM_THREADS = "ALL_CPUS")
)

get_sentinel2_imagery(
  aoi,
  start_date,
  end_date,
  ...,
  pixel_x_size = 10,
  pixel_y_size = 10,
  asset_names = rsi::sentinel2_band_mapping$planetary_computer_v1,
  stac_source = attr(asset_names, "stac_source"),
  collection = attr(asset_names, "collection_name"),
  query_function = attr(asset_names, "query_function"),
  sign_function = attr(asset_names, "sign_function"),
  rescale_bands = FALSE,
  item_filter_function = NULL,
  mask_band = attr(asset_names, "mask_band"),
  mask_function = attr(asset_names, "mask_function"),
  output_filename = paste0(proceduralnames::make_english_names(1), ".tif"),
  composite_function = "median",
  limit = 999,
  gdalwarp_options = c("-r", "bilinear", "-multi", "-overwrite", "-co",
    "COMPRESS=DEFLATE", "-co", "PREDICTOR=2", "-co", "NUM_THREADS=ALL_CPUS"),
  gdal_config_options = c(VSI_CACHE = "TRUE", GDAL_CACHEMAX = "30%", VSI_CACHE_SIZE =
    "10000000", GDAL_HTTP_MULTIPLEX = "YES", GDAL_INGESTED_BYTES_AT_OPEN = "32000",
    GDAL_DISABLE_READDIR_ON_OPEN = "EMPTY_DIR", GDAL_HTTP_VERSION = "2",
    GDAL_HTTP_MERGE_CONSECUTIVE_RANGES = "YES", GDAL_NUM_THREADS = "ALL_CPUS")
)

get_landsat_imagery(
  aoi,
  start_date,
  end_date,
  ...,
  platforms = c("landsat-9", "landsat-8"),
  pixel_x_size = 30,
  pixel_y_size = 30,
  asset_names = rsi::landsat_band_mapping$planetary_computer_v1,
  stac_source = attr(asset_names, "stac_source"),
  collection = attr(asset_names, "collection_name"),
  query_function = attr(asset_names, "query_function"),
  sign_function = attr(asset_names, "sign_function"),
  rescale_bands = TRUE,
  item_filter_function = landsat_platform_filter,
  mask_band = attr(asset_names, "mask_band"),
  mask_function = attr(asset_names, "mask_function"),
  output_filename = paste0(proceduralnames::make_english_names(1), ".tif"),
  composite_function = "median",
  limit = 999,
  gdalwarp_options = c("-r", "bilinear", "-multi", "-overwrite", "-co",
    "COMPRESS=DEFLATE", "-co", "PREDICTOR=2", "-co", "NUM_THREADS=ALL_CPUS"),
  gdal_config_options = c(VSI_CACHE = "TRUE", GDAL_CACHEMAX = "30%", VSI_CACHE_SIZE =
    "10000000", GDAL_HTTP_MULTIPLEX = "YES", GDAL_INGESTED_BYTES_AT_OPEN = "32000",
    GDAL_DISABLE_READDIR_ON_OPEN = "EMPTY_DIR", GDAL_HTTP_VERSION = "2",
    GDAL_HTTP_MERGE_CONSECUTIVE_RANGES = "YES", GDAL_NUM_THREADS = "ALL_CPUS")
)

get_dem(
  aoi,
  ...,
  start_date = NULL,
  end_date = NULL,
  pixel_x_size = 30,
  pixel_y_size = 30,
  asset_names = rsi::dem_band_mapping$planetary_computer_v1$`cop-dem-glo-30`,
  stac_source = attr(asset_names, "stac_source"),
  collection = attr(asset_names, "collection_name"),
  query_function = attr(asset_names, "query_function"),
  sign_function = attr(asset_names, "sign_function"),
  rescale_bands = FALSE,
  item_filter_function = NULL,
  mask_band = NULL,
  mask_function = NULL,
  output_filename = paste0(proceduralnames::make_english_names(1), ".tif"),
  composite_function = "max",
  limit = 999,
  gdalwarp_options = c("-r", "bilinear", "-multi", "-overwrite", "-co",
    "COMPRESS=DEFLATE", "-co", "PREDICTOR=2", "-co", "NUM_THREADS=ALL_CPUS"),
  gdal_config_options = c(VSI_CACHE = "TRUE", GDAL_CACHEMAX = "30%", VSI_CACHE_SIZE =
    "10000000", GDAL_HTTP_MULTIPLEX = "YES", GDAL_INGESTED_BYTES_AT_OPEN = "32000",
    GDAL_DISABLE_READDIR_ON_OPEN = "EMPTY_DIR", GDAL_HTTP_VERSION = "2",
    GDAL_HTTP_MERGE_CONSECUTIVE_RANGES = "YES", GDAL_NUM_THREADS = "ALL_CPUS")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_stac_data_+3A_aoi">aoi</code></td>
<td>
<p>An sf(c) object outlining the area of interest to get imagery for.
Will be used to get the bounding box used for calculating metrics and the
output data's CRS.</p>
</td></tr>
<tr><td><code id="get_stac_data_+3A_start_date">start_date</code>, <code id="get_stac_data_+3A_end_date">end_date</code></td>
<td>
<p>Character of length 1: The first and last date,
respectively, of imagery to include in metrics calculations. Should be in
YYYY-MM-DD format.</p>
</td></tr>
<tr><td><code id="get_stac_data_+3A_pixel_x_size">pixel_x_size</code>, <code id="get_stac_data_+3A_pixel_y_size">pixel_y_size</code></td>
<td>
<p>Numeric of length 1: size of pixels in
x-direction (longitude / easting) and y-direction (latitude / northing).</p>
</td></tr>
<tr><td><code id="get_stac_data_+3A_asset_names">asset_names</code></td>
<td>
<p>The names of the assets to download. If this vector has
names, then the names of the vector are assumed to be the names of assets on
the STAC server, which will be renamed to the elements of the vector in the
final output.</p>
</td></tr>
<tr><td><code id="get_stac_data_+3A_stac_source">stac_source</code></td>
<td>
<p>Character of length 1: the STAC URL to download
imagery from.</p>
</td></tr>
<tr><td><code id="get_stac_data_+3A_collection">collection</code></td>
<td>
<p>Character of length 1: the STAC collection to download
images from.</p>
</td></tr>
<tr><td><code id="get_stac_data_+3A_...">...</code></td>
<td>
<p>Passed to <code>item_filter_function</code>.</p>
</td></tr>
<tr><td><code id="get_stac_data_+3A_query_function">query_function</code></td>
<td>
<p>A function that takes the output from
<code><a href="rstac.html#topic+stac_search">rstac::stac_search()</a></code> and executes the request. See
<code><a href="#topic+default_query_function">default_query_function()</a></code> and the <code>query_function</code> slots of
<a href="#topic+sentinel1_band_mapping">sentinel1_band_mapping</a>, <a href="#topic+sentinel2_band_mapping">sentinel2_band_mapping</a>, and
<a href="#topic+landsat_band_mapping">landsat_band_mapping</a>.</p>
</td></tr>
<tr><td><code id="get_stac_data_+3A_sign_function">sign_function</code></td>
<td>
<p>A function that takes the output from <code>query_function</code>
and signs the item URLs, if necessary.</p>
</td></tr>
<tr><td><code id="get_stac_data_+3A_rescale_bands">rescale_bands</code></td>
<td>
<p>Logical of length 1: If the STAC collection implements
the <code>raster</code> STAC extension, and that extension includes <code>scale</code> and <code>offset</code>
values, should this function attempt to automatically rescale the downloaded
data?</p>
</td></tr>
<tr><td><code id="get_stac_data_+3A_item_filter_function">item_filter_function</code></td>
<td>
<p>A function that takes the outputs of
<code>query_function</code> (usually a <code>STACItemCollection</code>) and <code>...</code> and returns a
filtered <code>STACItemCollection</code>. This is used, for example, to only download
images from specific Landsat platforms.</p>
</td></tr>
<tr><td><code id="get_stac_data_+3A_mask_band">mask_band</code></td>
<td>
<p>Character of length 1: The name of the asset in your
STAC source to use to mask the data. Set to <code>NULL</code> to not mask. See the
<code>mask_band</code> slots of <a href="#topic+sentinel1_band_mapping">sentinel1_band_mapping</a>, <a href="#topic+sentinel2_band_mapping">sentinel2_band_mapping</a>, and
<a href="#topic+landsat_band_mapping">landsat_band_mapping</a>.</p>
</td></tr>
<tr><td><code id="get_stac_data_+3A_mask_function">mask_function</code></td>
<td>
<p>A function that takes a raster and returns a boolean
raster, where <code>TRUE</code> pixels will be preserved and <code>FALSE</code> or <code>NA</code> pixels will
be masked out. See <code><a href="#topic+sentinel2_mask_function">sentinel2_mask_function()</a></code>.</p>
</td></tr>
<tr><td><code id="get_stac_data_+3A_output_filename">output_filename</code></td>
<td>
<p>The filename to write the output raster to. If
<code>composite_function</code> is <code>NULL</code>, item datetimes will be appended to this
in order to create unique filenames. If items do not have datetimes, a
sequential ID will be appended instead.</p>
</td></tr>
<tr><td><code id="get_stac_data_+3A_composite_function">composite_function</code></td>
<td>
<p>Character of length 1: The name of a
function used to combine downloaded images into a single composite
(i.e., to aggregate pixel values from multiple images into a single value).
Must be one of of &quot;sum&quot;, &quot;mean&quot;, &quot;median&quot;, &quot;min&quot;, &quot;max&quot;.
Set to <code>NULL</code> to not composite
(i.e., to rescale and save each individual file independently).</p>
</td></tr>
<tr><td><code id="get_stac_data_+3A_limit">limit</code></td>
<td>
<p>an <code>integer</code> defining the maximum number of results
to return. If not informed, it defaults to the service implementation.</p>
</td></tr>
<tr><td><code id="get_stac_data_+3A_gdalwarp_options">gdalwarp_options</code></td>
<td>
<p>Options passed to <code>gdalwarp</code> through the <code>options</code>
argument of <code><a href="sf.html#topic+gdal_utils">sf::gdal_utils()</a></code>. The same set of options are used for all
downloaded data and the final output images; this means that some common
options (for instance, <code>PREDICTOR=3</code>) may cause errors if bands are of
varying data types.</p>
</td></tr>
<tr><td><code id="get_stac_data_+3A_gdal_config_options">gdal_config_options</code></td>
<td>
<p>Options passed to <code>gdalwarp</code> through the
<code>config_options</code> argument of <code><a href="sf.html#topic+gdal_utils">sf::gdal_utils()</a></code>.</p>
</td></tr>
<tr><td><code id="get_stac_data_+3A_platforms">platforms</code></td>
<td>
<p>The names of Landsat satellites to download imagery from.
These do not correspond to the <code>platforms</code> column in <code><a href="#topic+spectral_indices">spectral_indices()</a></code>;
the default argument of <code>c("landsat-9", "landsat-8")</code> corresponds to
the <code>Landsat-OLI</code> value in that column.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>output_filename</code>, unchanged.
</p>


<h3>Usage Tips</h3>

<p>It's often useful to buffer your <code>aoi</code> object slightly, on the order of 1-2
cell widths, in order to ensure that data is downloaded for your entire AOI
even after accounting for any reprojection needed to compare your AOI to
the data on the STAC server.
</p>
<p>These functions allow for parallelizing downloads via <code><a href="future.html#topic+plan">future::plan()</a></code>, and
for user-controlled progress updates via <code><a href="progressr.html#topic+handlers">progressr::handlers()</a></code>. If
there are fewer images to download than <code>asset_names</code>, then this function
uses <code><a href="base.html#topic+lapply">lapply()</a></code> to iterate through images and <code><a href="future.apply.html#topic+future_mapply">future.apply::future_mapply()</a></code>
to iterate through downloading each asset. If there are more images than
assets, this function uses <code><a href="future.apply.html#topic+future_lapply">future.apply::future_lapply()</a></code> to iterate through
images.
</p>


<h3>Downloading from Planetary Computer</h3>

<p>Certain data sets in Planetary Computer require
<a href="https://planetarycomputer.microsoft.com/docs/concepts/sas/">providing a subscription key</a>.
Even for non-protected data sets, providing a subscription key grants you
higher rate limits and faster downloads. As such, it's a good idea to
<a href="https://planetarycomputer.microsoft.com/account/request">request a Planetary Computer account</a>,
then <a href="https://planetarycomputer.developer.azure-api.net/">generate a subscription key</a>.
If you set the <code>rsi_pc_key</code> environment variable to your key (either primary
or secondary; there is no difference), rsi will automatically use
this key to sign all requests against Planetary Computer.
</p>
<p>There are currently some challenges with certain Landsat images in Planetary
Computer; please see
https://github.com/microsoft/PlanetaryComputer/discussions/101
for more information on these images and their current status. These files
may cause data downloads to fail.
</p>


<h3>Compositing</h3>

<p>This function can either download all data that intersects with your
spatiotemporal AOI as multiple files (if <code>composite_function = NULL</code>),
or can be used to rescale band values, apply a mask function, and create a
composite from the resulting files in a single function call. Each of these
steps can be skipped by passing <code>NULL</code> to the corresponding argument.
</p>
<p>Masks are applied to each downloaded asset separately. Rescaling is applied
to the final composite after images are combined.
</p>
<p>A number of the steps involved in creating composites &ndash; rescaling band
values, running the mask function, masking images, and compositing images &ndash;
currently rely on the <code>terra</code> package for raster calculations. This means
creating larger composites, either in geographic or temporal dimension, may
cause errors. It can be a good idea to tile your <code>aoi</code> using
<code>sf::st_make_grid()</code> and iterate through the tiles to avoid these errors
(and to make it easier to interrupt and restart a download job).
</p>


<h3>Rescaling</h3>

<p>If <code>rescale_bands</code> is <code>TRUE</code>, then this function is able to use the <code>scale</code>
and <code>offset</code> values in the <code>bands</code> field of the <code>raster</code> STAC extension.
This was implemented originally to work with the Landsat collections in the
Planetary Computer STAC catalogue, but hopefully will work automatically with
other data sources as well. Note that Sentinel-2 data typically doesn't use
this STAC extension, and so the returned data is typically not re-scaled;
divide the downloaded band values by 10000 to get reflectance values in the
expected values.
</p>


<h3>Sentinel-1 Data</h3>

<p>The <code>get_sentinel1_data()</code> function is designed to download Sentinel-1 data
from the Microsoft Planetary Computer STAC API. Both the GRD and RTC
Sentinel-1 collections are supported. To download RTC data,
set <code>collection</code> to <code>sentinel-1-rtc</code>, and supply your subscription key
as an environment variable named <code>rsi_pc_key</code> (through, e.g., <code>Sys.setenv()</code>
or your <code>.Renviron</code> file).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
aoi &lt;- sf::st_point(c(-74.912131, 44.080410))
aoi &lt;- sf::st_set_crs(sf::st_sfc(aoi), 4326)
aoi &lt;- sf::st_buffer(sf::st_transform(aoi, 5070), 100)

get_stac_data(aoi,
  start_date = "2022-06-01",
  end_date = "2022-06-30",
  pixel_x_size = 30,
  pixel_y_size = 30,
  asset_names = c(
    "red", "blue", "green"
  ),
  stac_source = "https://planetarycomputer.microsoft.com/api/stac/v1/",
  collection = "landsat-c2-l2",
  query_function = default_query_function,
  sign_function = sign_planetary_computer,
  mask_band = "qa_pixel",
  mask_function = landsat_mask_function,
  item_filter_function = landsat_platform_filter,
  platforms = c("landsat-9", "landsat-8")
)

# or, mostly equivalently (will download more bands):
landsat_image &lt;- get_landsat_imagery(
  aoi,
  start_date = "2022-06-01",
  end_date = "2022-08-30"
)

</code></pre>

<hr>
<h2 id='landsat_band_mapping'>Landsat band mapping</h2><span id='topic+landsat_band_mapping'></span>

<h3>Description</h3>

<p>This object is a named list of character vectors, with names corresponding to
Landsat band names and values corresponding to band names in
<code>spectral_indices</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>landsat_band_mapping
</code></pre>


<h3>Format</h3>

<p>An object of class <code>list</code> of length 1.
</p>


<h3>Details</h3>

<p>Band mapping objects:
</p>
<p>These objects are semi-standardized sets of metadata which provide all the
necessary information for downloading data from a given STAC server.
The object itself is list of character vectors, whose names represent asset
names on a given STAC server and whose values represent the corresponding
standardized band name from the Awesome Spectral Indices project. In addition
to this data, these vectors usually have some of (but not necessarily all of)
the following attributes:
</p>

<ul>
<li> <p><code>stac_source</code>: The URL for the STAC server this metadata corresponds to.
</p>
</li>
<li> <p><code>collection_name</code>: The default STAC collection for this data source.
</p>
</li>
<li> <p><code>download_function</code>: The function to be used to download assets from the
STAC server.
</p>
</li>
<li> <p><code>mask_band</code>: The name of the asset on this server to be used for masking
images.
</p>
</li>
<li> <p><code>mask_function</code>: The function to be used to mask images downloaded from
this server.
</p>
</li></ul>


<hr>
<h2 id='landsat_mask_function'>Create a Landsat mask raster from the QA band</h2><span id='topic+landsat_mask_function'></span>

<h3>Description</h3>

<p>Create a Landsat mask raster from the QA band
</p>


<h3>Usage</h3>

<pre><code class='language-R'>landsat_mask_function(raster)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="landsat_mask_function_+3A_raster">raster</code></td>
<td>
<p>The QA band of a Landsat image</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A boolean raster to be used to mask a Landsat image
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
aoi &lt;- sf::st_point(c(-74.912131, 44.080410))
aoi &lt;- sf::st_set_crs(sf::st_sfc(aoi), 4326)
aoi &lt;- sf::st_buffer(sf::st_transform(aoi, 5070), 100)

landsat_image &lt;- get_landsat_imagery(
  aoi,
  start_date = "2022-06-01",
  end_date = "2022-08-30",
  mask_function = landsat_mask_function
)

</code></pre>

<hr>
<h2 id='landsat_platform_filter'>Filter Landsat features to only specific platforms</h2><span id='topic+landsat_platform_filter'></span>

<h3>Description</h3>

<p>Filter Landsat features to only specific platforms
</p>


<h3>Usage</h3>

<pre><code class='language-R'>landsat_platform_filter(items, platforms)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="landsat_platform_filter_+3A_items">items</code></td>
<td>
<p>A <code>STACItemCatalog</code> containing some number of features</p>
</td></tr>
<tr><td><code id="landsat_platform_filter_+3A_platforms">platforms</code></td>
<td>
<p>A vector of acceptable platforms, for instance <code>landsat-9</code>.
Note that this refers to satellite names, and <em>not</em> to platforms in
<code>spectral_indices()</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>STACItemCollection</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
aoi &lt;- sf::st_point(c(-74.912131, 44.080410))
aoi &lt;- sf::st_set_crs(sf::st_sfc(aoi), 4326)
aoi &lt;- sf::st_buffer(sf::st_transform(aoi, 5070), 100)

landsat_image &lt;- get_landsat_imagery(
  aoi,
  start_date = "2022-06-01",
  end_date = "2022-08-30",
  item_filter_function = landsat_platform_filter
)

</code></pre>

<hr>
<h2 id='rsi-package'>rsi: Efficiently Retrieve and Process Satellite Imagery</h2><span id='topic+rsi'></span><span id='topic+rsi-package'></span>

<h3>Description</h3>

<p><img src="../help/figures/logo.png" style='float: right' alt='logo' width='120' />
</p>
<p>Downloads spatial data from spatiotemporal asset catalogs ('STAC'), computes standard spectral indices from the Awesome Spectral Indices project (Montero et al. (2023) <a href="https://doi.org/10.1038/s41597-023-02096-0">doi:10.1038/s41597-023-02096-0</a>) against raster data, and glues the outputs together into predictor bricks. Methods focus on interoperability with the broader spatial ecosystem; function arguments and outputs use classes from 'sf' and 'terra', and data downloading functions support complex 'CQL2' queries using 'rstac'.
</p>


<h3>Author(s)</h3>

<p><strong>Maintainer</strong>: Michael Mahoney <a href="mailto:mike.mahoney.218@gmail.com">mike.mahoney.218@gmail.com</a> (<a href="https://orcid.org/0000-0003-2402-304X">ORCID</a>)
</p>
<p>Other contributors:
</p>

<ul>
<li><p> Permian Global [copyright holder, funder]
</p>
</li></ul>



<h3>See Also</h3>

<p>Useful links:
</p>

<ul>
<li> <p><a href="https://github.com/Permian-Global-Research/rsi">https://github.com/Permian-Global-Research/rsi</a>
</p>
</li>
<li> <p><a href="https://permian-global-research.github.io/rsi/">https://permian-global-research.github.io/rsi/</a>
</p>
</li>
<li><p> Report bugs at <a href="https://github.com/Permian-Global-Research/rsi/issues">https://github.com/Permian-Global-Research/rsi/issues</a>
</p>
</li></ul>


<hr>
<h2 id='sentinel1_band_mapping'>Sentinel-1 band mapping</h2><span id='topic+sentinel1_band_mapping'></span>

<h3>Description</h3>

<p>This object is a named list of character vectors, with names corresponding to
Sentinel-1 band names and values corresponding to band names in
<code>spectral_indices</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sentinel1_band_mapping
</code></pre>


<h3>Format</h3>

<p>An object of class <code>list</code> of length 1.
</p>


<h3>Details</h3>

<p>Band mapping objects:
</p>
<p>These objects are semi-standardized sets of metadata which provide all the
necessary information for downloading data from a given STAC server.
The object itself is list of character vectors, whose names represent asset
names on a given STAC server and whose values represent the corresponding
standardized band name from the Awesome Spectral Indices project. In addition
to this data, these vectors usually have some of (but not necessarily all of)
the following attributes:
</p>

<ul>
<li> <p><code>stac_source</code>: The URL for the STAC server this metadata corresponds to.
</p>
</li>
<li> <p><code>collection_name</code>: The default STAC collection for this data source.
</p>
</li>
<li> <p><code>download_function</code>: The function to be used to download assets from the
STAC server.
</p>
</li>
<li> <p><code>mask_band</code>: The name of the asset on this server to be used for masking
images.
</p>
</li>
<li> <p><code>mask_function</code>: The function to be used to mask images downloaded from
this server.
</p>
</li></ul>


<hr>
<h2 id='sentinel2_band_mapping'>Sentinel-2 band mapping</h2><span id='topic+sentinel2_band_mapping'></span>

<h3>Description</h3>

<p>This object is a named list of character vectors, with names corresponding to
Sentinel-2 band names and values corresponding to band names in
<code>spectral_indices</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sentinel2_band_mapping
</code></pre>


<h3>Format</h3>

<p>An object of class <code>list</code> of length 3.
</p>


<h3>Details</h3>

<p>Band mapping objects:
</p>
<p>These objects are semi-standardized sets of metadata which provide all the
necessary information for downloading data from a given STAC server.
The object itself is list of character vectors, whose names represent asset
names on a given STAC server and whose values represent the corresponding
standardized band name from the Awesome Spectral Indices project. In addition
to this data, these vectors usually have some of (but not necessarily all of)
the following attributes:
</p>

<ul>
<li> <p><code>stac_source</code>: The URL for the STAC server this metadata corresponds to.
</p>
</li>
<li> <p><code>collection_name</code>: The default STAC collection for this data source.
</p>
</li>
<li> <p><code>download_function</code>: The function to be used to download assets from the
STAC server.
</p>
</li>
<li> <p><code>mask_band</code>: The name of the asset on this server to be used for masking
images.
</p>
</li>
<li> <p><code>mask_function</code>: The function to be used to mask images downloaded from
this server.
</p>
</li></ul>


<hr>
<h2 id='sentinel2_mask_function'>Create a Sentinel-2 mask raster from the SCL band</h2><span id='topic+sentinel2_mask_function'></span>

<h3>Description</h3>

<p>Create a Sentinel-2 mask raster from the SCL band
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sentinel2_mask_function(raster)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sentinel2_mask_function_+3A_raster">raster</code></td>
<td>
<p>The SCL band of a Sentinel-2 image</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A boolean raster to be used to mask a Sentinel-2 image
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
aoi &lt;- sf::st_point(c(-74.912131, 44.080410))
aoi &lt;- sf::st_set_crs(sf::st_sfc(aoi), 4326)
aoi &lt;- sf::st_buffer(sf::st_transform(aoi, 5070), 100)

sentinel2_image &lt;- get_sentinel2_imagery(
  aoi,
  start_date = "2022-06-01",
  end_date = "2022-08-30",
  mask_function = sentinel2_mask_function
)

</code></pre>

<hr>
<h2 id='sign_planetary_computer'>Sign STAC items retrieved from the Planetary Computer</h2><span id='topic+sign_planetary_computer'></span>

<h3>Description</h3>

<p>Sign STAC items retrieved from the Planetary Computer
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sign_planetary_computer(items, subscription_key = Sys.getenv("rsi_pc_key"))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sign_planetary_computer_+3A_items">items</code></td>
<td>
<p>A STACItemCollection, as returned by <code>default_query_function</code>.</p>
</td></tr>
<tr><td><code id="sign_planetary_computer_+3A_subscription_key">subscription_key</code></td>
<td>
<p>Optionally, a subscription key associated with your
Planetary Computer account. At the time of writing, this is required for
downloading Sentinel 1 RTC products, as well as NAIP imagery. This key will
be automatically used if the environment variable <code>rsi_pc_key</code> is set.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A STACItemCollection object with signed assets url.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
aoi &lt;- sf::st_point(c(-74.912131, 44.080410))
aoi &lt;- sf::st_set_crs(sf::st_sfc(aoi), 4326)
aoi &lt;- sf::st_buffer(sf::st_transform(aoi, 5070), 100)

landsat_image &lt;- get_landsat_imagery(
  aoi,
  start_date = "2022-06-01",
  end_date = "2022-08-30",
  sign_function = sign_planetary_computer
)

</code></pre>

<hr>
<h2 id='spectral_indices'>Get a data frame of spectral indices</h2><span id='topic+spectral_indices'></span>

<h3>Description</h3>

<p>This function returns a data frame of spectral indices, from the
<code>awesome-spectral-indices</code> repository.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>spectral_indices(
  ...,
  url = spectral_indices_url(),
  download_indices = NULL,
  update_cache = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="spectral_indices_+3A_...">...</code></td>
<td>
<p>These dots are for future extensions and must be empty.</p>
</td></tr>
<tr><td><code id="spectral_indices_+3A_url">url</code></td>
<td>
<p>The URL to download spectral indices from. If the option <code>rsi_url</code>
is set, that value will be used; otherwise, if the environment variable
<code>rsi_url</code> is set, that value will be used; otherwise, the list at
https://github.com/awesome-spectral-indices/awesome-spectral-indices will
be used.</p>
</td></tr>
<tr><td><code id="spectral_indices_+3A_download_indices">download_indices</code></td>
<td>
<p>Logical: should this function download indices? If
<code>NULL</code>, this function will only download indices if the cache will be
updated. If <code>TRUE</code>, this function will attempt to download indices no matter
what. If <code>FALSE</code>, either cached or package indices will be used.</p>
</td></tr>
<tr><td><code id="spectral_indices_+3A_update_cache">update_cache</code></td>
<td>
<p>Logical: should cached indices be updated? If <code>NULL</code>,
cached values will be updated if the cache is older than a day. If <code>TRUE</code>,
the cache will be updated, if <code>FALSE</code> it will not.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <a href="tibble.html#topic+tibble">tibble::tibble</a> with nine columns, containing information about spectral indices.
</p>


<h3>Source</h3>

<p><a href="https://github.com/awesome-spectral-indices/awesome-spectral-indices">https://github.com/awesome-spectral-indices/awesome-spectral-indices</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>spectral_indices()

</code></pre>

<hr>
<h2 id='spectral_indices_url'>Get the URL to download spectral indices from</h2><span id='topic+spectral_indices_url'></span>

<h3>Description</h3>

<p>Get the URL to download spectral indices from
</p>


<h3>Usage</h3>

<pre><code class='language-R'>spectral_indices_url()
</code></pre>


<h3>Value</h3>

<p>A URL to download indices from.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>spectral_indices_url()

</code></pre>

<hr>
<h2 id='stack_rasters'>Create and save a multi-band output raster by combining input rasters</h2><span id='topic+stack_rasters'></span>

<h3>Description</h3>

<p>This function creates an output raster that &quot;stacks&quot; all the bands of its
input rasters, as though they were loaded one after another into a GIS. It
does this by first constructing a GDAL virtual raster, or &quot;VRT&quot;, and then
optionally uses GDAL's warper to convert this VRT into a standalone file.
The VRT is fast to create and does not require much space, but does require
the input rasters not be moved or altered. Creating a standalone raster from
this file may take a long time and a large amount of disk space.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>stack_rasters(
  rasters,
  output_filename,
  ...,
  resolution,
  extent,
  reference_raster = 1,
  resampling_method = "bilinear",
  band_names,
  gdalwarp_options = c("-multi", "-overwrite", "-co", "COMPRESS=DEFLATE", "-co",
    "PREDICTOR=2", "-co", "NUM_THREADS=ALL_CPUS"),
  gdal_config_options = c(VSI_CACHE = "TRUE", GDAL_CACHEMAX = "30%", VSI_CACHE_SIZE =
    "10000000", GDAL_HTTP_MULTIPLEX = "YES", GDAL_INGESTED_BYTES_AT_OPEN = "32000",
    GDAL_DISABLE_READDIR_ON_OPEN = "EMPTY_DIR", GDAL_HTTP_VERSION = "2",
    GDAL_HTTP_MERGE_CONSECUTIVE_RANGES = "YES", GDAL_NUM_THREADS = "ALL_CPUS")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="stack_rasters_+3A_rasters">rasters</code></td>
<td>
<p>A list of rasters to combine into a single multi-band raster,
either as SpatRaster objects from <code><a href="terra.html#topic+rast">terra::rast()</a></code> or character file paths
to files that can be read by <code><a href="terra.html#topic+rast">terra::rast()</a></code>. Rasters will be &quot;stacked&quot; upon
one another, preserving values. They must share CRS.</p>
</td></tr>
<tr><td><code id="stack_rasters_+3A_output_filename">output_filename</code></td>
<td>
<p>The location to save the final &quot;stacked&quot; raster. If
this filename has a &quot;vrt&quot; extension as determined by <code>tools::file_ext()</code>,
then this function exits after creating a VRT; otherwise, this function will
create a VRT and then use <code>sf::gdal_utils("warp")</code> to convert the VRT into
another format.</p>
</td></tr>
<tr><td><code id="stack_rasters_+3A_...">...</code></td>
<td>
<p>These dots are for future extensions and must be empty.</p>
</td></tr>
<tr><td><code id="stack_rasters_+3A_resolution">resolution</code></td>
<td>
<p>Numeric of length 2, representing the target X and Y
resolution of the output raster. If only a single value is provided, it will
be used for both X and Y resolution; if more than 2 values are provided, an
error is thrown.</p>
</td></tr>
<tr><td><code id="stack_rasters_+3A_extent">extent</code></td>
<td>
<p>Numeric of length 4, representing the target xmin, ymin, xmax,
and ymax values of the output raster (its bounding box), in that order.</p>
</td></tr>
<tr><td><code id="stack_rasters_+3A_reference_raster">reference_raster</code></td>
<td>
<p>The position (index) of the raster in <code>rasters</code> to
take extent, resolution, and CRS information from. No reprojection is done.
If <code>resolution</code> or <code>extent</code> are provided, they override the values from the
reference raster.</p>
</td></tr>
<tr><td><code id="stack_rasters_+3A_resampling_method">resampling_method</code></td>
<td>
<p>The method to use when resampling to different
resolutions in the VRT.</p>
</td></tr>
<tr><td><code id="stack_rasters_+3A_band_names">band_names</code></td>
<td>
<p>Either a character vector of band names, or a function that
when given a character vector of band names, returns a character vector of
the same length containing new band names.</p>
</td></tr>
<tr><td><code id="stack_rasters_+3A_gdalwarp_options">gdalwarp_options</code></td>
<td>
<p>Options passed to <code>gdalwarp</code> through the <code>options</code>
argument of <code><a href="sf.html#topic+gdal_utils">sf::gdal_utils()</a></code>. This argument is ignored (with a warning)
if <code>output_filename</code> is a VRT.</p>
</td></tr>
<tr><td><code id="stack_rasters_+3A_gdal_config_options">gdal_config_options</code></td>
<td>
<p>Options passed to <code>gdalwarp</code> through the
<code>config_options</code> argument of <code><a href="sf.html#topic+gdal_utils">sf::gdal_utils()</a></code>.  This argument is ignored
(with a warning) if <code>output_filename</code> is a VRT.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>output_filename</code>, unchanged.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>stack_rasters(
  list(
    system.file("rasters/dpdd.tif", package = "rsi"),
    system.file("rasters/example_sentinel1.tif", package = "rsi")
  ),
  tempfile(fileext = ".vrt")
)

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
