<!DOCTYPE html><html><head><title>Help for package pool</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {pool}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#DBI-custom'><p>Unsupported DBI methods</p></a></li>
<li><a href='#DBI-wrap'><p>DBI methods (simple wrappers)</p></a></li>
<li><a href='#dbPool'><p>Create a pool of database connections</p></a></li>
<li><a href='#hooks'><p>Pooled object methods.</p></a></li>
<li><a href='#Pool-class'><p>Create a pool of reusable objects</p></a></li>
<li><a href='#pool-package'><p>pool: Object Pooling</p></a></li>
<li><a href='#poolCheckout'><p>Check out and return object from the pool</p></a></li>
<li><a href='#poolWithTransaction'><p>Self-contained database transactions using pool</p></a></li>
<li><a href='#reexports'><p>Objects exported from other packages</p></a></li>
<li><a href='#tbl.Pool'><p>Use pool with dbplyr</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Object Pooling</td>
</tr>
<tr>
<td>Version:</td>
<td>1.0.3</td>
</tr>
<tr>
<td>Description:</td>
<td>Enables the creation of object pools, which make it less
    computationally expensive to fetch a new object. Currently the only
    supported pooled objects are 'DBI' connections.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://opensource.org/licenses/mit-license.php">MIT</a> + file LICENSE</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/rstudio/pool">https://github.com/rstudio/pool</a>, <a href="http://rstudio.github.io/pool/">http://rstudio.github.io/pool/</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/rstudio/pool/issues">https://github.com/rstudio/pool/issues</a></td>
</tr>
<tr>
<td>Depends:</td>
<td>methods, R (&ge; 3.6.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>DBI (&ge; 1.2.1), later (&ge; 1.0.0), R6, rlang (&ge; 1.0.0)</td>
</tr>
<tr>
<td>Suggests:</td>
<td>covr, dbplyr (&ge; 2.4.0), dplyr, knitr, rmarkdown, RMySQL,
RSQLite, shiny, testthat (&ge; 3.0.0), tibble</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>Config/Needs/website:</td>
<td>tidyverse/tidytemplate</td>
</tr>
<tr>
<td>Config/testthat/edition:</td>
<td>3</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.3.1</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-02-14 13:56:35 UTC; hadleywickham</td>
</tr>
<tr>
<td>Author:</td>
<td>Joe Cheng [aut],
  Barbara Borges [aut],
  Hadley Wickham [aut, cre],
  Posit Software, PBC [cph, fnd]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Hadley Wickham &lt;hadley@posit.co&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-02-14 17:30:08 UTC</td>
</tr>
</table>
<hr>
<h2 id='DBI-custom'>Unsupported DBI methods</h2><span id='topic+DBI-custom'></span><span id='topic+dbSendQuery+2CPool-method'></span><span id='topic+dbSendStatement+2CPool+2CANY-method'></span><span id='topic+dbDisconnect+2CPool-method'></span><span id='topic+dbGetInfo+2CPool-method'></span><span id='topic+dbIsValid+2CPool-method'></span><span id='topic+dbBegin+2CPool-method'></span><span id='topic+dbCommit+2CPool-method'></span><span id='topic+dbRollback+2CPool-method'></span><span id='topic+dbWithTransaction+2CPool-method'></span>

<h3>Description</h3>

<p>Most pool methods for DBI generics check out a connection, perform the
operation, and the return the connection to the pool, as described in
<a href="#topic+DBI-wrap">DBI-wrap</a>.
</p>
<p>This page describes the exceptions:
</p>

<ul>
<li> <p><code><a href="DBI.html#topic+dbSendQuery">DBI::dbSendQuery()</a></code> and <code><a href="DBI.html#topic+dbSendStatement">DBI::dbSendStatement()</a></code> can't work with pool
because they return result sets that are bound to a specific connection.
Instead use <code><a href="DBI.html#topic+dbGetQuery">DBI::dbGetQuery()</a></code>, <code><a href="DBI.html#topic+dbExecute">DBI::dbExecute()</a></code>, or
<code><a href="#topic+localCheckout">localCheckout()</a></code>.
</p>
</li>
<li> <p><code><a href="DBI.html#topic+transactions">DBI::dbBegin()</a></code>, <code><a href="DBI.html#topic+transactions">DBI::dbRollback()</a></code>, <code><a href="DBI.html#topic+transactions">DBI::dbCommit()</a></code>, and
<code><a href="DBI.html#topic+dbWithTransaction">DBI::dbWithTransaction()</a></code> can't work with pool because transactions are
bound to a connection. Instead use <code><a href="#topic+poolWithTransaction">poolWithTransaction()</a></code>.
</p>
</li>
<li> <p><code><a href="DBI.html#topic+dbDisconnect">DBI::dbDisconnect()</a></code> can't work because pool handles disconnection.
</p>
</li>
<li> <p><code><a href="DBI.html#topic+dbGetInfo">DBI::dbGetInfo()</a></code> returns information about the pool, not the database
connection.
</p>
</li>
<li> <p><code><a href="DBI.html#topic+dbIsValid">DBI::dbIsValid()</a></code> returns whether or not the entire pool is valid (i.e.
not closed).
</p>
</li></ul>



<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'Pool'
dbSendQuery(conn, statement, ...)

## S4 method for signature 'Pool,ANY'
dbSendStatement(conn, statement, ...)

## S4 method for signature 'Pool'
dbDisconnect(conn, ...)

## S4 method for signature 'Pool'
dbGetInfo(dbObj, ...)

## S4 method for signature 'Pool'
dbIsValid(dbObj, ...)

## S4 method for signature 'Pool'
dbBegin(conn, ...)

## S4 method for signature 'Pool'
dbCommit(conn, ...)

## S4 method for signature 'Pool'
dbRollback(conn, ...)

## S4 method for signature 'Pool'
dbWithTransaction(conn, code)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="DBI-custom_+3A_conn">conn</code>, <code id="DBI-custom_+3A_dbobj">dbObj</code></td>
<td>
<p>A Pool object, as returned from <code><a href="#topic+dbPool">dbPool()</a></code>.</p>
</td></tr>
<tr><td><code id="DBI-custom_+3A_statement">statement</code>, <code id="DBI-custom_+3A_code">code</code>, <code id="DBI-custom_+3A_...">...</code></td>
<td>
<p>See DBI documentation.</p>
</td></tr>
</table>

<hr>
<h2 id='DBI-wrap'>DBI methods (simple wrappers)</h2><span id='topic+DBI-wrap'></span><span id='topic+dbDataType+2CPool-method'></span><span id='topic+dbGetQuery+2CPool+2CANY-method'></span><span id='topic+dbExecute+2CPool+2CANY-method'></span><span id='topic+dbListFields+2CPool+2CANY-method'></span><span id='topic+dbListTables+2CPool-method'></span><span id='topic+dbListObjects+2CPool-method'></span><span id='topic+dbReadTable+2CPool+2CANY-method'></span><span id='topic+dbWriteTable+2CPool+2CANY-method'></span><span id='topic+dbCreateTable+2CPool-method'></span><span id='topic+dbAppendTable+2CPool-method'></span><span id='topic+dbExistsTable+2CPool+2CANY-method'></span><span id='topic+dbRemoveTable+2CPool+2CANY-method'></span><span id='topic+dbIsReadOnly+2CPool-method'></span><span id='topic+sqlData+2CPool-method'></span><span id='topic+sqlCreateTable+2CPool-method'></span><span id='topic+sqlAppendTable+2CPool-method'></span><span id='topic+sqlInterpolate+2CPool-method'></span><span id='topic+sqlParseVariables+2CPool-method'></span><span id='topic+dbQuoteIdentifier+2CPool+2CANY-method'></span><span id='topic+dbUnquoteIdentifier+2CPool-method'></span><span id='topic+dbQuoteLiteral+2CPool-method'></span><span id='topic+dbQuoteString+2CPool+2CANY-method'></span><span id='topic+dbAppendTableArrow+2CPool-method'></span><span id='topic+dbCreateTableArrow+2CPool-method'></span><span id='topic+dbGetQueryArrow+2CPool-method'></span><span id='topic+dbReadTableArrow+2CPool-method'></span><span id='topic+dbSendQueryArrow+2CPool-method'></span><span id='topic+dbWriteTableArrow+2CPool-method'></span>

<h3>Description</h3>

<p>These pool method for DBI generics methods check out a connection
(with <code><a href="#topic+poolCheckout">poolCheckout()</a></code>), re-call the generic, then return the connection
to the pool (with <code><a href="#topic+poolReturn">poolReturn()</a></code>).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'Pool'
dbDataType(dbObj, obj, ...)

## S4 method for signature 'Pool,ANY'
dbGetQuery(conn, statement, ...)

## S4 method for signature 'Pool,ANY'
dbExecute(conn, statement, ...)

## S4 method for signature 'Pool,ANY'
dbListFields(conn, name, ...)

## S4 method for signature 'Pool'
dbListTables(conn, ...)

## S4 method for signature 'Pool'
dbListObjects(conn, prefix = NULL, ...)

## S4 method for signature 'Pool,ANY'
dbReadTable(conn, name, ...)

## S4 method for signature 'Pool,ANY'
dbWriteTable(conn, name, value, ...)

## S4 method for signature 'Pool'
dbCreateTable(conn, name, fields, ..., row.names = NULL, temporary = FALSE)

## S4 method for signature 'Pool'
dbAppendTable(conn, name, value, ..., row.names = NULL)

## S4 method for signature 'Pool,ANY'
dbExistsTable(conn, name, ...)

## S4 method for signature 'Pool,ANY'
dbRemoveTable(conn, name, ...)

## S4 method for signature 'Pool'
dbIsReadOnly(dbObj, ...)

## S4 method for signature 'Pool'
sqlData(con, value, row.names = NA, ...)

## S4 method for signature 'Pool'
sqlCreateTable(con, table, fields, row.names = NA, temporary = FALSE, ...)

## S4 method for signature 'Pool'
sqlAppendTable(con, table, values, row.names = NA, ...)

## S4 method for signature 'Pool'
sqlInterpolate(conn, sql, ..., .dots = list())

## S4 method for signature 'Pool'
sqlParseVariables(conn, sql, ...)

## S4 method for signature 'Pool,ANY'
dbQuoteIdentifier(conn, x, ...)

## S4 method for signature 'Pool'
dbUnquoteIdentifier(conn, x, ...)

## S4 method for signature 'Pool'
dbQuoteLiteral(conn, x, ...)

## S4 method for signature 'Pool,ANY'
dbQuoteString(conn, x, ...)

## S4 method for signature 'Pool'
dbAppendTableArrow(conn, name, value, ...)

## S4 method for signature 'Pool'
dbCreateTableArrow(conn, name, value, ..., temporary = FALSE)

## S4 method for signature 'Pool'
dbGetQueryArrow(conn, statement, ...)

## S4 method for signature 'Pool'
dbReadTableArrow(conn, name, ...)

## S4 method for signature 'Pool'
dbSendQueryArrow(conn, statement, ...)

## S4 method for signature 'Pool'
dbWriteTableArrow(conn, name, value, ...)
</code></pre>


<h3>Examples</h3>

<pre><code class='language-R'>mtcars1 &lt;- mtcars[ c(1:16), ] # first half of the mtcars dataset
mtcars2 &lt;- mtcars[-c(1:16), ] # second half of the mtcars dataset

pool &lt;- dbPool(RSQLite::SQLite())

# write the mtcars1 table into the database
dbWriteTable(pool, "mtcars", mtcars1, row.names = TRUE)

# list the current tables in the database
dbListTables(pool)

# read the "mtcars" table from the database (only 16 rows)
dbReadTable(pool, "mtcars")

# append mtcars2 to the "mtcars" table already in the database
dbWriteTable(pool, "mtcars", mtcars2, row.names = TRUE, append = TRUE)

# read the "mtcars" table from the database (all 32 rows)
dbReadTable(pool, "mtcars")

# get the names of the columns in the databases's table
dbListFields(pool, "mtcars")

# use dbExecute to change the "mpg" and "cyl" values of the 1st row
dbExecute(pool,
  paste(
    "UPDATE mtcars",
    "SET mpg = '22.0', cyl = '10'",
    "WHERE row_names = 'Mazda RX4'"
  )
)

# read the 1st row of "mtcars" table to confirm the previous change
dbGetQuery(pool, "SELECT * FROM mtcars WHERE row_names = 'Mazda RX4'")

# drop the "mtcars" table from the database
dbRemoveTable(pool, "mtcars")

# list the current tables in the database
dbListTables(pool)

poolClose(pool)
</code></pre>

<hr>
<h2 id='dbPool'>Create a pool of database connections</h2><span id='topic+dbPool'></span>

<h3>Description</h3>

<p><code>dbPool()</code> is a drop-in replacement for <code><a href="DBI.html#topic+dbConnect">DBI::dbConnect()</a></code> that
provides a shared pool of connections that can automatically reconnect
to the database if needed.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dbPool(
  drv,
  ...,
  minSize = 1,
  maxSize = Inf,
  onCreate = NULL,
  idleTimeout = 60,
  validationInterval = 60,
  validateQuery = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dbPool_+3A_drv">drv</code></td>
<td>
<p>A <a href="DBI.html#topic+DBIDriver-class">DBI Driver</a>, e.g. <code>RSQLite::SQLite()</code>,
<code>RPostgres::Postgres()</code>, <code>odbc::odbc()</code> etc.</p>
</td></tr>
<tr><td><code id="dbPool_+3A_...">...</code></td>
<td>
<p>Arguments passed on to <code><a href="DBI.html#topic+dbConnect">DBI::dbConnect()</a></code>. These are used to
identify the database and provide needed authentication.</p>
</td></tr>
<tr><td><code id="dbPool_+3A_minsize">minSize</code>, <code id="dbPool_+3A_maxsize">maxSize</code></td>
<td>
<p>The minimum and maximum number of objects in the pool.</p>
</td></tr>
<tr><td><code id="dbPool_+3A_oncreate">onCreate</code></td>
<td>
<p>A function that takes a single argument, a connection,
and is called when the connection is created. Use this with
<code><a href="DBI.html#topic+dbExecute">DBI::dbExecute()</a></code> to set default options on every connection created
by the pool.</p>
</td></tr>
<tr><td><code id="dbPool_+3A_idletimeout">idleTimeout</code></td>
<td>
<p>Number of seconds to wait before destroying idle objects
(i.e. objects available for checkout over and above <code>minSize</code>).</p>
</td></tr>
<tr><td><code id="dbPool_+3A_validationinterval">validationInterval</code></td>
<td>
<p>Number of seconds to wait between validating
objects that are available for checkout. These objects are validated
in the background to keep them alive.
</p>
<p>To force objects to be validated on every checkout, set
<code>validationInterval = 0</code>.</p>
</td></tr>
<tr><td><code id="dbPool_+3A_validatequery">validateQuery</code></td>
<td>
<p>A simple query that can be used to verify that the
connetction is valid. If not provided, <code>dbPool()</code> will try a few common
options, but these don't work for all databases.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'># You use a dbPool in the same way as a standard DBI connection
pool &lt;- dbPool(RSQLite::SQLite())
pool

DBI::dbWriteTable(pool, "mtcars", mtcars)
dbGetQuery(pool, "SELECT * FROM mtcars LIMIT 4")

# Always close a pool when you're done using it
poolClose(pool)

# Using the RMySQL package
if (requireNamespace("RMySQL", quietly = TRUE)) {
  pool &lt;- dbPool(
    drv = RMySQL::MySQL(),
    dbname = "shinydemo",
    host = "shiny-demo.csa7qlmguqrf.us-east-1.rds.amazonaws.com",
    username = "guest",
    password = "guest"
  )

  dbGetQuery(pool, "SELECT * from City LIMIT 5;")

  poolClose(pool)
}
</code></pre>

<hr>
<h2 id='hooks'>Pooled object methods.</h2><span id='topic+hooks'></span><span id='topic+onActivate'></span><span id='topic+onPassivate'></span><span id='topic+onDestroy'></span><span id='topic+onValidate'></span><span id='topic+onActivate+2CANY-method'></span><span id='topic+onPassivate+2CANY-method'></span><span id='topic+onDestroy+2CANY-method'></span><span id='topic+onValidate+2CANY-method'></span><span id='topic+onPassivate+2CDBIConnection-method'></span><span id='topic+onDestroy+2CDBIConnection-method'></span><span id='topic+onValidate+2CDBIConnection-method'></span>

<h3>Description</h3>

<p>For backend authors only. Authors should implement all of these,
which are then called by the Pool class methods. These should
not be called directly either by backend authors or by the end
users.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>onActivate(object)

onPassivate(object)

onDestroy(object)

onValidate(object, query)

## S4 method for signature 'ANY'
onActivate(object)

## S4 method for signature 'ANY'
onPassivate(object)

## S4 method for signature 'ANY'
onDestroy(object)

## S4 method for signature 'ANY'
onValidate(object, query)

## S4 method for signature 'DBIConnection'
onPassivate(object)

## S4 method for signature 'DBIConnection'
onDestroy(object)

## S4 method for signature 'DBIConnection'
onValidate(object)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="hooks_+3A_object">object</code></td>
<td>
<p>A pooled object.</p>
</td></tr>
<tr><td><code id="hooks_+3A_query">query</code></td>
<td>
<p>A simple query that can be used to verify that
the <code>object</code> functions as expected.</p>
</td></tr>
</table>

<hr>
<h2 id='Pool-class'>Create a pool of reusable objects</h2><span id='topic+Pool-class'></span><span id='topic+Pool'></span><span id='topic+poolCreate'></span><span id='topic+poolClose'></span><span id='topic+poolClose+2CPool-method'></span>

<h3>Description</h3>

<p>A generic pool class that holds objects. These can be fetched
from the pool and released back to it at will, with very
little computational cost. The pool should be created only once
and closed when it is no longer needed, to prevent leaks.
</p>
<p>Every usage of <code>poolCreate()</code> should always be paired with a call to
<code>poolClose()</code> to avoid &quot;leaking&quot; resources. In shiny app, you should
create the pool outside of the server function and close it on stop,
i.e. <code>onStop(function() pool::poolClose(pool))</code>.
</p>
<p>See <code><a href="#topic+dbPool">dbPool()</a></code> for an example of object pooling applied to DBI database
connections.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>poolCreate(
  factory,
  minSize = 1,
  maxSize = Inf,
  idleTimeout = 60,
  validationInterval = 60,
  state = NULL
)

poolClose(pool)

## S4 method for signature 'Pool'
poolClose(pool)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Pool-class_+3A_factory">factory</code></td>
<td>
<p>A zero-argument function called to create the objects that
the pool will hold (e.g. for DBI database connections, <code><a href="#topic+dbPool">dbPool()</a></code> uses
a wrapper around <code>DBI::dbConnect()</code>).</p>
</td></tr>
<tr><td><code id="Pool-class_+3A_minsize">minSize</code>, <code id="Pool-class_+3A_maxsize">maxSize</code></td>
<td>
<p>The minimum and maximum number of objects in the pool.</p>
</td></tr>
<tr><td><code id="Pool-class_+3A_idletimeout">idleTimeout</code></td>
<td>
<p>Number of seconds to wait before destroying idle objects
(i.e. objects available for checkout over and above <code>minSize</code>).</p>
</td></tr>
<tr><td><code id="Pool-class_+3A_validationinterval">validationInterval</code></td>
<td>
<p>Number of seconds to wait between validating
objects that are available for checkout. These objects are validated
in the background to keep them alive.
</p>
<p>To force objects to be validated on every checkout, set
<code>validationInterval = 0</code>.</p>
</td></tr>
<tr><td><code id="Pool-class_+3A_state">state</code></td>
<td>
<p>A <code>pool</code> public variable to be used by backend authors.</p>
</td></tr>
<tr><td><code id="Pool-class_+3A_pool">pool</code></td>
<td>
<p>A Pool object previously created with <code>poolCreate</code></p>
</td></tr>
</table>

<hr>
<h2 id='pool-package'>pool: Object Pooling</h2><span id='topic+pool'></span><span id='topic+pool-package'></span>

<h3>Description</h3>

<p>Enables the creation of object pools, which make it less computationally expensive to fetch a new object. Currently the only supported pooled objects are 'DBI' connections.
</p>


<h3>Author(s)</h3>

<p><strong>Maintainer</strong>: Hadley Wickham <a href="mailto:hadley@posit.co">hadley@posit.co</a>
</p>
<p>Authors:
</p>

<ul>
<li><p> Joe Cheng <a href="mailto:joe@posit.co">joe@posit.co</a>
</p>
</li>
<li><p> Barbara Borges
</p>
</li></ul>

<p>Other contributors:
</p>

<ul>
<li><p> Posit Software, PBC [copyright holder, funder]
</p>
</li></ul>



<h3>See Also</h3>

<p>Useful links:
</p>

<ul>
<li> <p><a href="https://github.com/rstudio/pool">https://github.com/rstudio/pool</a>
</p>
</li>
<li> <p><a href="http://rstudio.github.io/pool/">http://rstudio.github.io/pool/</a>
</p>
</li>
<li><p> Report bugs at <a href="https://github.com/rstudio/pool/issues">https://github.com/rstudio/pool/issues</a>
</p>
</li></ul>


<hr>
<h2 id='poolCheckout'>Check out and return object from the pool</h2><span id='topic+poolCheckout'></span><span id='topic+poolCheckout+2CPool-method'></span><span id='topic+poolReturn'></span><span id='topic+poolReturn+2CANY-method'></span><span id='topic+localCheckout'></span>

<h3>Description</h3>

<p>Use <code>poolCheckout()</code> to check out an object from the pool and
<code>poolReturn()</code> to return it. You will receive a warning if all objects
aren't returned before the pool is closed.
</p>
<p><code>localCheckout()</code> is a convenience function that can be used inside
functions (and other function-scoped operations like <code>shiny::reactive()</code>
and <code>local()</code>). It checks out an object and automatically returns it when
the function exits
</p>
<p>Note that validation is only performed when the object is checked out,
so you generally want to keep the checked out around for as little time as
possible.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>poolCheckout(pool)

## S4 method for signature 'Pool'
poolCheckout(pool)

poolReturn(object)

## S4 method for signature 'ANY'
poolReturn(object)

localCheckout(pool, env = parent.frame())
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="poolCheckout_+3A_pool">pool</code></td>
<td>
<p>The pool to get the object from.</p>
</td></tr>
<tr><td><code id="poolCheckout_+3A_object">object</code></td>
<td>
<p>Object to return</p>
</td></tr>
<tr><td><code id="poolCheckout_+3A_env">env</code></td>
<td>
<p>Environment corresponding to the execution frame. For expert
use only.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>pool &lt;- dbPool(RSQLite::SQLite())
con &lt;- poolCheckout(pool)
con
poolReturn(con)

f &lt;- function() {
  con &lt;- localCheckout(pool)
  # do something ...
}
f()

poolClose(pool)
</code></pre>

<hr>
<h2 id='poolWithTransaction'>Self-contained database transactions using pool</h2><span id='topic+poolWithTransaction'></span>

<h3>Description</h3>

<p>This function allows you to use a pool object directly to execute a
transaction on a database connection, without ever having to actually
check out a connection from the pool and then return it. Using this
function instead of the direct transaction methods will guarantee that
you don't leak connections or forget to commit/rollback a transaction.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>poolWithTransaction(pool, func)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="poolWithTransaction_+3A_pool">pool</code></td>
<td>
<p>The pool object to fetch the connection from.</p>
</td></tr>
<tr><td><code id="poolWithTransaction_+3A_func">func</code></td>
<td>
<p>A function that has one argument, <code>conn</code> (a database
connection checked out from <code>pool</code>).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is similar to <code><a href="DBI.html#topic+dbWithTransaction">DBI::dbWithTransaction()</a></code>, but
its arguments work a little differently. First, it takes in a pool
object, instead of a connection. Second, instead of taking an arbitrary
chunk of code to execute as a transaction (i.e. either run all the
commands successfully or not run any of them), it takes in a function.
This function (the <code>func</code> argument) gives you an argument to use
in its body, a database connection. So, you can use connection methods
without ever having to check out a connection. But you can also use
arbitrary R code inside the <code>func</code>'s body. This function will be
called once we fetch a connection from the pool. Once the function
returns, we release the connection back to the pool.
</p>
<p>Like its DBI sister <code><a href="DBI.html#topic+dbWithTransaction">DBI::dbWithTransaction()</a></code>, this function
calls <code>dbBegin()</code> before executing the code, and <code>dbCommit()</code>
after successful completion, or <code>dbRollback()</code> in case of an error.
This means that calling <code>poolWithTransaction</code> always has side
effects, namely to commit or roll back the code executed when <code>func</code>
is called. In addition, if you modify the local R environment from within
<code>func</code> (e.g. setting global variables, writing to disk), these
changes will persist after the function has returned.
</p>
<p>Also, like <code><a href="DBI.html#topic+dbWithTransaction">DBI::dbWithTransaction()</a></code>, there is also a special
function called <code>dbBreak()</code> that allows for an early, silent exit
with rollback. It can be called only from inside <code>poolWithTransaction</code>.
</p>


<h3>Value</h3>

<p><code>func</code>'s return value.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if (requireNamespace("RSQLite", quietly = TRUE)) {
  pool &lt;- dbPool(RSQLite::SQLite(), dbname = ":memory:")

  dbWriteTable(pool, "cars", head(cars, 3))
  dbReadTable(pool, "cars")   # there are 3 rows

  ## successful transaction
  poolWithTransaction(pool, function(conn) {
    dbExecute(conn, "INSERT INTO cars (speed, dist) VALUES (1, 1);")
    dbExecute(conn, "INSERT INTO cars (speed, dist) VALUES (2, 2);")
    dbExecute(conn, "INSERT INTO cars (speed, dist) VALUES (3, 3);")
  })
  dbReadTable(pool, "cars")   # there are now 6 rows

  ## failed transaction -- note the missing comma
  tryCatch(
    poolWithTransaction(pool, function(conn) {
      dbExecute(conn, "INSERT INTO cars (speed, dist) VALUES (1, 1);")
      dbExecute(conn, "INSERT INTO cars (speed dist) VALUES (2, 2);")
      dbExecute(conn, "INSERT INTO cars (speed, dist) VALUES (3, 3);")
    }),
    error = identity
  )
  dbReadTable(pool, "cars")   # still 6 rows

  ## early exit, silently
  poolWithTransaction(pool, function(conn) {
    dbExecute(conn, "INSERT INTO cars (speed, dist) VALUES (1, 1);")
    dbExecute(conn, "INSERT INTO cars (speed, dist) VALUES (2, 2);")
    if (nrow(dbReadTable(conn, "cars")) &gt; 7) dbBreak()
    dbExecute(conn, "INSERT INTO cars (speed, dist) VALUES (3, 3);")
  })
  dbReadTable(pool, "cars")   # still 6 rows

  poolClose(pool)

} else {
  message("Please install the 'RSQLite' package to run this example")
}
</code></pre>

<hr>
<h2 id='reexports'>Objects exported from other packages</h2><span id='topic+reexports'></span><span id='topic+dbBreak'></span>

<h3>Description</h3>

<p>These objects are imported from other packages. Follow the links
below to see their documentation.
</p>

<dl>
<dt>DBI</dt><dd><p><code><a href="DBI.html#topic+dbWithTransaction">dbBreak</a></code></p>
</dd>
</dl>

<hr>
<h2 id='tbl.Pool'>Use pool with dbplyr</h2><span id='topic+tbl.Pool'></span><span id='topic+copy_to.Pool'></span>

<h3>Description</h3>

<p>Wrappers for key dplyr (and dbplyr) methods so that pool works seemlessly
with <a href="https://dbplyr.tidyverse.org/">dbplyr</a>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tbl.Pool(src, from, ..., vars = NULL)

copy_to.Pool(dest, df, name = NULL, overwrite = FALSE, temporary = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tbl.Pool_+3A_src">src</code>, <code id="tbl.Pool_+3A_dest">dest</code></td>
<td>
<p>A <a href="#topic+dbPool">dbPool</a>.</p>
</td></tr>
<tr><td><code id="tbl.Pool_+3A_from">from</code></td>
<td>
<p>Name table or <code><a href="dbplyr.html#topic+sql">dbplyr::sql()</a></code> string.</p>
</td></tr>
<tr><td><code id="tbl.Pool_+3A_...">...</code></td>
<td>
<p>Other arguments passed on to the individual methods</p>
</td></tr>
<tr><td><code id="tbl.Pool_+3A_vars">vars</code></td>
<td>
<p>A character vector of variable names in <code>src</code>.
For expert use only.</p>
</td></tr>
<tr><td><code id="tbl.Pool_+3A_df">df</code></td>
<td>
<p>A local data frame, a <code>tbl_sql</code> from same source, or a <code>tbl_sql</code>
from another source. If from another source, all data must transition
through R in one pass, so it is only suitable for transferring small
amounts of data.</p>
</td></tr>
<tr><td><code id="tbl.Pool_+3A_name">name</code></td>
<td>
<p>Name for remote table. Defaults to the name of <code>df</code>, if it's
an identifier, otherwise uses a random name.</p>
</td></tr>
<tr><td><code id="tbl.Pool_+3A_overwrite">overwrite</code></td>
<td>
<p>If <code>TRUE</code>, will overwrite an existing table with
name <code>name</code>. If <code>FALSE</code>, will throw an error if <code>name</code> already
exists.</p>
</td></tr>
<tr><td><code id="tbl.Pool_+3A_temporary">temporary</code></td>
<td>
<p>if <code>TRUE</code>, will create a temporary table that is
local to this connection and will be automatically deleted when the
connection expires</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>library(dplyr)

pool &lt;- dbPool(RSQLite::SQLite())
# copy a table into the database
copy_to(pool, mtcars, "mtcars", temporary = FALSE)

# retrieve a table
mtcars_db &lt;- tbl(pool, "mtcars")
mtcars_db
mtcars_db %&gt;% select(mpg, cyl, disp)
mtcars_db %&gt;% filter(cyl == 6) %&gt;% collect()

poolClose(pool)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
