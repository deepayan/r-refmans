<!DOCTYPE html><html><head><title>Help for package SpatialPosition</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {SpatialPosition}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#CreateDistMatrix'><p>Create a Distance Matrix Between Two Spatial Objects</p></a></li>
<li><a href='#CreateGrid'><p>Create a Regularly Spaced Points Grid</p></a></li>
<li><a href='#hospital'><p>Public Hospitals</p></a></li>
<li><a href='#huff'><p>Huff Catchment Areas</p></a></li>
<li><a href='#isopoly'><p>Create Spatial Polygons Contours from a Raster</p></a></li>
<li><a href='#mcStewart'><p>Stewart Potentials Parallel</p></a></li>
<li><a href='#paris'><p>Paris Polygon</p></a></li>
<li><a href='#plotHuff'><p>Plot a Huff Raster</p></a></li>
<li><a href='#plotReilly'><p>Plot a Reilly Raster</p></a></li>
<li><a href='#plotStewart'><p>Plot a Stewart Raster</p></a></li>
<li><a href='#quickStewart'><p>Create Polygons of Potentials Contours</p></a></li>
<li><a href='#rasterHuff'><p>Create a Raster from a Huff SpatialPointsDataFrame</p></a></li>
<li><a href='#rasterReilly'><p>Create a Raster from a Reilly Regular Grid</p></a></li>
<li><a href='#rasterStewart'><p>Create a Raster from a Stewart Regular Grid</p></a></li>
<li><a href='#reilly'><p>Reilly Catchment Areas</p></a></li>
<li><a href='#smoothy'><p>Stewart Smooth</p></a></li>
<li><a href='#SpatialPosition'><p>Spatial Position Package</p></a></li>
<li><a href='#stewart'><p>Stewart Potentials</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Title:</td>
<td>Spatial Position Models</td>
</tr>
<tr>
<td>Version:</td>
<td>2.1.2</td>
</tr>
<tr>
<td>Description:</td>
<td>Computes spatial position models: the potential model as defined
    by Stewart (1941) &lt;<a href="https://doi.org/10.1126%2Fscience.93.2404.89">doi:10.1126/science.93.2404.89</a>&gt; and catchment areas as
    defined by Reilly (1931) or Huff (1964) &lt;<a href="https://doi.org/10.2307%2F1249154">doi:10.2307/1249154</a>&gt;.</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.5.0)</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>Imports:</td>
<td>sf, sp, grDevices, graphics, methods, isoband, raster</td>
</tr>
<tr>
<td>Suggests:</td>
<td>lwgeom, parallel, doParallel, foreach, cartography, knitr,
rmarkdown</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/riatelab/SpatialPosition">https://github.com/riatelab/SpatialPosition</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/riatelab/SpatialPosition/issues">https://github.com/riatelab/SpatialPosition/issues</a></td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-09-14 09:10:18 UTC; tim</td>
</tr>
<tr>
<td>Author:</td>
<td>Timothée Giraud <a href="https://orcid.org/0000-0002-1932-3323"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [cre, aut],
  Hadrien Commenges [aut],
  Joël Boulier [ctb]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Timothée Giraud &lt;timothee.giraud@cnrs.fr&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-09-14 09:40:04 UTC</td>
</tr>
</table>
<hr>
<h2 id='CreateDistMatrix'>Create a Distance Matrix Between Two Spatial Objects</h2><span id='topic+CreateDistMatrix'></span>

<h3>Description</h3>

<p>This function creates a distance matrix between two 
spatial objects (sp or sf objects).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>CreateDistMatrix(knownpts, unknownpts, bypassctrl = FALSE, longlat = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="CreateDistMatrix_+3A_knownpts">knownpts</code></td>
<td>
<p>sp or sf object; rows of the distance matrix.</p>
</td></tr>
<tr><td><code id="CreateDistMatrix_+3A_unknownpts">unknownpts</code></td>
<td>
<p>sp or sf object; columns of the distance matrix.</p>
</td></tr>
<tr><td><code id="CreateDistMatrix_+3A_bypassctrl">bypassctrl</code></td>
<td>
<p>logical; bypass the distance matrix size control (see Details).</p>
</td></tr>
<tr><td><code id="CreateDistMatrix_+3A_longlat">longlat</code></td>
<td>
<p>logical; if FALSE, Euclidean distance, if TRUE Great Circle 
(WGS84 ellipsoid) distance.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function returns a full matrix of distances in meters. 
If the matrix to compute is too large (more than 100,000,000 cells, more than 
10,000,000 origins or more than 10,000,000 destinations) 
the function sends a confirmation message to warn users about the amount of 
RAM mobilized. 
Use <code>bypassctrl</code> = TRUE to skip this control.
</p>


<h3>Value</h3>

<p>A distance matrix, row names are <code>knownpts</code> row names, column 
names are <code>unknownpts</code> row names.
</p>


<h3>See Also</h3>

<p><a href="#topic+CreateGrid">CreateGrid</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Create a grid of paris extent and 200 meters
# resolution
data(hospital)
mygrid &lt;- CreateGrid(w = paris, resolution = 200, returnclass = "sf")
# Create a distance matrix between known hospital and mygrid
mymat &lt;- CreateDistMatrix(knownpts = hospital, unknownpts = mygrid, 
                          longlat = FALSE)
mymat[1:5,1:5]
nrow(paris)
nrow(mygrid)
dim(mymat)
</code></pre>

<hr>
<h2 id='CreateGrid'>Create a Regularly Spaced Points Grid</h2><span id='topic+CreateGrid'></span>

<h3>Description</h3>

<p>This function creates a regular grid of points 
from the extent of a given spatial object and a given resolution.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>CreateGrid(w, resolution, returnclass = "sp")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="CreateGrid_+3A_w">w</code></td>
<td>
<p>sp or sf object; the spatial extent of this object is used to 
create the regular grid.</p>
</td></tr>
<tr><td><code id="CreateGrid_+3A_resolution">resolution</code></td>
<td>
<p>numeric; resolution of the grid (in map units). If 
resolution is not set, the grid will contain around 7500 points. (optional)</p>
</td></tr>
<tr><td><code id="CreateGrid_+3A_returnclass">returnclass</code></td>
<td>
<p>&quot;sp&quot; or &quot;sf&quot;; class of the returned object.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The output of the function is a regularly spaced points grid
with the extent of <code>w</code>.
</p>


<h3>See Also</h3>

<p><a href="#topic+CreateDistMatrix">CreateDistMatrix</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Create a grid of paris extent and 200 meters
# resolution
library(SpatialPosition)
library(sf)
data(hospital)
mygrid &lt;- CreateGrid(w = paris, resolution = 200, returnclass = "sf")
plot(st_geometry(mygrid), cex = 0.1, pch = ".")
plot(st_geometry(paris), border="red", lwd = 2, add = TRUE)
</code></pre>

<hr>
<h2 id='hospital'>Public Hospitals</h2><span id='topic+hospital'></span>

<h3>Description</h3>

<p>An sf POINT data frame of 18 public hospitals with their capacity 
(&quot;capacity&quot; = number of beds).
</p>

<hr>
<h2 id='huff'>Huff Catchment Areas</h2><span id='topic+huff'></span>

<h3>Description</h3>

<p>This function computes the catchment areas as defined by D. Huff (1964).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>huff(
  knownpts,
  unknownpts,
  matdist,
  varname,
  typefct = "exponential",
  span,
  beta,
  resolution,
  mask,
  bypassctrl = FALSE,
  longlat = TRUE,
  returnclass = "sp"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="huff_+3A_knownpts">knownpts</code></td>
<td>
<p>sp or sf object; 
this is the set of known observations to estimate the catchment areas from.</p>
</td></tr>
<tr><td><code id="huff_+3A_unknownpts">unknownpts</code></td>
<td>
<p>sp or sf object; 
this is the set of unknown units for which the function computes the estimates. 
Not used when <code>resolution</code> is set up. (optional)</p>
</td></tr>
<tr><td><code id="huff_+3A_matdist">matdist</code></td>
<td>
<p>matrix; distance matrix between known observations and unknown 
units for which the function computes the estimates. Row names match the row 
names of <code>knownpts</code> and column names match the row names of 
<code>unknownpts</code>. <code>matdist</code> can contain any distance metric (time 
distance or euclidean distance for example). If <code>matdist</code> is not set, the distance 
matrix is automaticly built with <code><a href="#topic+CreateDistMatrix">CreateDistMatrix</a></code>. (optional)</p>
</td></tr>
<tr><td><code id="huff_+3A_varname">varname</code></td>
<td>
<p>character; name of the variable in the <code>knownpts</code> dataframe 
from which values are computed. Quantitative variable with no negative values.</p>
</td></tr>
<tr><td><code id="huff_+3A_typefct">typefct</code></td>
<td>
<p>character; spatial interaction function. Options are &quot;pareto&quot; 
(means power law) or &quot;exponential&quot;.
If &quot;pareto&quot; the interaction is defined as: (1 + alpha * mDistance) ^ (-beta).
If &quot;exponential&quot; the interaction is defined as: 
exp(- alpha * mDistance ^ beta).
The alpha parameter is computed from parameters given by the user 
(<code>beta</code> and <code>span</code>).</p>
</td></tr>
<tr><td><code id="huff_+3A_span">span</code></td>
<td>
<p>numeric; distance where the density of probability of the spatial 
interaction function equals 0.5.</p>
</td></tr>
<tr><td><code id="huff_+3A_beta">beta</code></td>
<td>
<p>numeric; impedance factor for the spatial interaction function.</p>
</td></tr>
<tr><td><code id="huff_+3A_resolution">resolution</code></td>
<td>
<p>numeric; resolution of the output grid (in map units). 
If resolution is not set, the grid will contain around 7000 points. (optional)</p>
</td></tr>
<tr><td><code id="huff_+3A_mask">mask</code></td>
<td>
<p>sp or sf object; the spatial extent of this object is used to 
create the regularly spaced points output. (optional)</p>
</td></tr>
<tr><td><code id="huff_+3A_bypassctrl">bypassctrl</code></td>
<td>
<p>logical; bypass the distance matrix size control (see 
<code><a href="#topic+CreateDistMatrix">CreateDistMatrix</a></code> Details).</p>
</td></tr>
<tr><td><code id="huff_+3A_longlat">longlat</code></td>
<td>
<p>logical; if FALSE, Euclidean distance, if TRUE Great Circle 
(WGS84 ellipsoid) distance.</p>
</td></tr>
<tr><td><code id="huff_+3A_returnclass">returnclass</code></td>
<td>
<p>&quot;sp&quot; or &quot;sf&quot;; class of the returned object.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Point object with the computed catchment areas in a new 
field named <code>OUTPUT</code>.
</p>


<h3>References</h3>

<p>HUFF D. (1964) Defining and Estimating a Trading Area. Journal of Marketing, 28: 34-38.
</p>


<h3>See Also</h3>

<p><a href="#topic+huff">huff</a>, <a href="#topic+rasterHuff">rasterHuff</a>, <a href="#topic+plotHuff">plotHuff</a>, <a href="#topic+CreateGrid">CreateGrid</a>, 
<a href="#topic+CreateDistMatrix">CreateDistMatrix</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Create a grid of paris extent and 200 meters
# resolution
data(hospital)
mygrid &lt;- CreateGrid(w = paris, resolution = 200, returnclass = "sf")
# Create a distance matrix between known points (hospital) and mygrid
mymat &lt;- CreateDistMatrix(knownpts = hospital, unknownpts = mygrid, 
                          longlat = FALSE)
# Compute Huff catchment areas from known points (hospital) on a given
# grid (mygrid) using a given distance matrix (mymat)
myhuff &lt;- huff(knownpts = hospital, unknownpts = mygrid,
               matdist = mymat, varname = "capacity",
               typefct = "exponential", span = 1250,
               beta = 3, mask = paris, returnclass = "sf")
# Compute Huff catchment areas from known points (hospital) on a
# grid defined by its resolution
myhuff2 &lt;- huff(knownpts = hospital, varname = "capacity",
                typefct = "exponential", span = 1250, beta = 3,
                resolution = 200, mask = paris, returnclass= "sf")
# The two methods have the same result
identical(myhuff, myhuff2)
# the function output an sf object
class(myhuff)
</code></pre>

<hr>
<h2 id='isopoly'>Create Spatial Polygons Contours from a Raster</h2><span id='topic+isopoly'></span>

<h3>Description</h3>

<p>This function creates spatial polygons of contours from a raster.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>isopoly(
  x,
  nclass = 8,
  breaks,
  mask,
  xcoords = "COORDX",
  ycoords = "COORDY",
  var = "OUTPUT",
  returnclass = "sp"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="isopoly_+3A_x">x</code></td>
<td>
<p>sf POINT data.frame; must contain X, Y and OUTPUT fields.</p>
</td></tr>
<tr><td><code id="isopoly_+3A_nclass">nclass</code></td>
<td>
<p>numeric; a number of class.</p>
</td></tr>
<tr><td><code id="isopoly_+3A_breaks">breaks</code></td>
<td>
<p>numeric; a vector of break values.</p>
</td></tr>
<tr><td><code id="isopoly_+3A_mask">mask</code></td>
<td>
<p>sf POLYGON data.frame; mask used to 
clip contour shapes.</p>
</td></tr>
<tr><td><code id="isopoly_+3A_xcoords">xcoords</code></td>
<td>
<p>character; name of the X coordinates field in x.</p>
</td></tr>
<tr><td><code id="isopoly_+3A_ycoords">ycoords</code></td>
<td>
<p>character; name of the Y coordinates field in x.</p>
</td></tr>
<tr><td><code id="isopoly_+3A_var">var</code></td>
<td>
<p>character; name of the OUTPUT field in x.</p>
</td></tr>
<tr><td><code id="isopoly_+3A_returnclass">returnclass</code></td>
<td>
<p>&quot;sp&quot; or &quot;sf&quot;; class of the returned object.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The output is an sf POLYGON data.frame.
The data frame contains four fields: 
id (id of each polygon), min and max (minimum and maximum breaks of the polygon), 
center (central values of classes).
</p>


<h3>See Also</h3>

<p><a href="#topic+stewart">stewart</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(hospital)
# Compute Stewart potentials
mystewart &lt;- stewart(knownpts = hospital, varname = "capacity",
                     typefct = "exponential", span = 1000, beta = 3,
                     mask = paris, returnclass = "sf")
# Create contour
contourpoly &lt;- isopoly(x = mystewart,
                       nclass = 6,
                       mask = paris, returnclass = "sf")
library(sf)
plot(st_geometry(contourpoly))
if(require(cartography)){
  # Created breaks
  bks &lt;- sort(unique(c(contourpoly$min, contourpoly$max)))
  opar &lt;- par(mar = c(0,0,1.2,0))
  # Display the map
  choroLayer(x = contourpoly,
             var = "center", legend.pos = "topleft",
             breaks = bks, border = "grey90",
             lwd = 0.2,
             legend.title.txt = "Potential number\nof beds in the\nneighbourhood",
             legend.values.rnd = 0)
  plot(st_geometry(paris), add = TRUE)
  propSymbolsLayer(x = hospital, var = "capacity",
                   legend.pos = "right",
                   legend.title.txt = "Number of beds",
                   col = "#ff000020")
  layoutLayer(title = "Global Accessibility to Public Hospitals",
              sources = "", author = "")
  par(opar)
}
</code></pre>

<hr>
<h2 id='mcStewart'>Stewart Potentials Parallel</h2><span id='topic+mcStewart'></span>

<h3>Description</h3>

<p>This function computes Stewart potentials using parallel 
computation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mcStewart(
  knownpts,
  unknownpts,
  varname,
  typefct = "exponential",
  span,
  beta,
  resolution,
  mask,
  cl,
  size = 1000,
  longlat = TRUE,
  returnclass = "sp"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mcStewart_+3A_knownpts">knownpts</code></td>
<td>
<p>sp or sf object; this is the set of known observations to 
estimate the potentials from.</p>
</td></tr>
<tr><td><code id="mcStewart_+3A_unknownpts">unknownpts</code></td>
<td>
<p>sp or sf object; this is the set of unknown units for which 
the function computes the estimates. Not used when <code>resolution</code> is set 
up. (optional)</p>
</td></tr>
<tr><td><code id="mcStewart_+3A_varname">varname</code></td>
<td>
<p>character; name of the variable in the <code>knownpts</code> dataframe 
from which potentials are computed. Quantitative variable with no negative values.</p>
</td></tr>
<tr><td><code id="mcStewart_+3A_typefct">typefct</code></td>
<td>
<p>character; spatial interaction function. Options are &quot;pareto&quot; 
(means power law) or &quot;exponential&quot;.
If &quot;pareto&quot; the interaction is defined as: (1 + alpha * mDistance) ^ (-beta).
If &quot;exponential&quot; the interaction is defined as: 
exp(- alpha * mDistance ^ beta).
The alpha parameter is computed from parameters given by the user 
(<code>beta</code> and <code>span</code>).</p>
</td></tr>
<tr><td><code id="mcStewart_+3A_span">span</code></td>
<td>
<p>numeric; distance where the density of probability of the spatial 
interaction function equals 0.5.</p>
</td></tr>
<tr><td><code id="mcStewart_+3A_beta">beta</code></td>
<td>
<p>numeric; impedance factor for the spatial interaction function.</p>
</td></tr>
<tr><td><code id="mcStewart_+3A_resolution">resolution</code></td>
<td>
<p>numeric; resolution of the output SpatialPointsDataFrame
(in map units). If resolution is not set, the grid will contain around 7250 
points. (optional)</p>
</td></tr>
<tr><td><code id="mcStewart_+3A_mask">mask</code></td>
<td>
<p>sp or sf object; the spatial extent of this object is used to 
create the regularly spaced points output. (optional)</p>
</td></tr>
<tr><td><code id="mcStewart_+3A_cl">cl</code></td>
<td>
<p>numeric; number of clusters. By default cl is determined using 
<code>parallel::detectCores()</code>.</p>
</td></tr>
<tr><td><code id="mcStewart_+3A_size">size</code></td>
<td>
<p>numeric; mcStewart splits unknownpts in chunks, size indicates 
the size of each chunks.</p>
</td></tr>
<tr><td><code id="mcStewart_+3A_longlat">longlat</code></td>
<td>
<p>logical; if FALSE, Euclidean distance, if TRUE Great Circle 
(WGS84 ellipsoid) distance.</p>
</td></tr>
<tr><td><code id="mcStewart_+3A_returnclass">returnclass</code></td>
<td>
<p>&quot;sp&quot; or &quot;sf&quot;; class of the returned object.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The parallel implementation splits potentials computations along 
chunks of unknownpts (or chunks of the grid defined using resolution).
</p>


<h3>Value</h3>

<p>Point object with the computed potentials in a new field 
named <code>OUTPUT</code>.
</p>


<h3>See Also</h3>

<p><a href="#topic+stewart">stewart</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
if(require(cartography)){
  nuts3.spdf@data &lt;- nuts3.df
  t1 &lt;- system.time(
    s1 &lt;- stewart(knownpts = nuts3.spdf,resolution = 40000,
                  varname = "pop2008",
                  typefct = "exponential", span = 100000,
                  beta = 3, mask = nuts3.spdf, returnclass = "sf")
  )
  t2 &lt;- system.time(
    s2 &lt;- mcStewart(knownpts = nuts3.spdf, resolution = 40000,
                    varname = "pop2008",
                    typefct = "exponential", span = 100000,
                    beta = 3, mask = nuts3.spdf, cl = 3, size = 500, 
                    returnclass = "sf")
  )
  identical(s1, s2)
  cat("Elapsed time\n", "stewart:", t1[3], "\n mcStewart:",t2[3])
  
  iso &lt;- isopoly(x = s2, 
                 breaks = c(0,1000000,2000000, 5000000, 10000000, 20000000, 
                            200004342),
                 mask = nuts3.spdf, returnclass = "sf")
  # cartography
  opar &lt;- par(mar = c(0,0,1.2,0))
  bks &lt;- sort(unique(c(iso$min, iso$max)))
  choroLayer(x = iso, var = "center", breaks = bks, border = NA,
             legend.title.txt = "pop")
  layoutLayer("potential population", "","", scale = NULL)
  par(opar)
}

## End(Not run)
</code></pre>

<hr>
<h2 id='paris'>Paris Polygon</h2><span id='topic+paris'></span>

<h3>Description</h3>

<p>An sf POLYGON data frame of the Paris perimeter.
</p>

<hr>
<h2 id='plotHuff'>Plot a Huff Raster</h2><span id='topic+plotHuff'></span>

<h3>Description</h3>

<p>This function plots the raster produced by the 
<code><a href="#topic+rasterHuff">rasterHuff</a></code> function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plotHuff(x, add = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plotHuff_+3A_x">x</code></td>
<td>
<p>raster; output of the <code><a href="#topic+rasterHuff">rasterHuff</a></code> function.</p>
</td></tr>
<tr><td><code id="plotHuff_+3A_add">add</code></td>
<td>
<p>logical; if TRUE the raster is added to the current plot, if FALSE 
the raster is displayed in a new plot.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Display the raster nicely.
</p>


<h3>See Also</h3>

<p><a href="#topic+huff">huff</a>, <a href="#topic+rasterHuff">rasterHuff</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(hospital)
# Compute Huff catchment areas from known points (hospital) on a
# grid defined by its resolution
myhuff &lt;- huff(knownpts = hospital, varname = "capacity",
               typefct = "exponential", span = 750, beta = 2,
               resolution = 100, mask = paris, returnclass = "sf")
# Create a raster of huff values
myhuffraster &lt;- rasterHuff(x = myhuff, mask = paris)
plotHuff(myhuffraster)
</code></pre>

<hr>
<h2 id='plotReilly'>Plot a Reilly Raster</h2><span id='topic+plotReilly'></span>

<h3>Description</h3>

<p>This function plots the raster produced by the 
<code><a href="#topic+rasterReilly">rasterReilly</a></code> function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plotReilly(x, add = FALSE, col = rainbow)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plotReilly_+3A_x">x</code></td>
<td>
<p>raster; output of the <code><a href="#topic+rasterReilly">rasterReilly</a></code> function.</p>
</td></tr>
<tr><td><code id="plotReilly_+3A_add">add</code></td>
<td>
<p>logical; if TRUE the raster is added to the current plot, if FALSE 
the raster is displayed in a new plot.</p>
</td></tr>
<tr><td><code id="plotReilly_+3A_col">col</code></td>
<td>
<p>function; color ramp function, such as <code><a href="grDevices.html#topic+colorRampPalette">colorRampPalette</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Display the raster nicely.
</p>


<h3>See Also</h3>

<p><a href="#topic+reilly">reilly</a>, <a href="#topic+rasterReilly">rasterReilly</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(hospital)
# Compute Reilly catchment areas from known points (hospital) on a
# grid defined by its resolution
myreilly &lt;- reilly(knownpts = hospital, varname = "capacity",
                   typefct = "exponential", span = 1250, beta = 3,
                   resolution = 200, mask = paris, returnclass = 'sf')
# Create a raster of reilly values
myreillyraster &lt;- rasterReilly(x = myreilly, mask = paris)
# Plot the raster nicely
plotReilly(x = myreillyraster)
</code></pre>

<hr>
<h2 id='plotStewart'>Plot a Stewart Raster</h2><span id='topic+plotStewart'></span>

<h3>Description</h3>

<p>This function plots the raster produced by the 
<code><a href="#topic+rasterStewart">rasterStewart</a></code> function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plotStewart(
  x,
  add = FALSE,
  breaks = NULL,
  typec = "equal",
  nclass = 5,
  legend.rnd = 0,
  col = colorRampPalette(c("#FEA3A3", "#980000"))
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plotStewart_+3A_x">x</code></td>
<td>
<p>raster; output of the <code><a href="#topic+rasterStewart">rasterStewart</a></code> function.</p>
</td></tr>
<tr><td><code id="plotStewart_+3A_add">add</code></td>
<td>
<p>logical; if TRUE the raster is added to the current plot, if FALSE 
the raster is displayed in a new plot.</p>
</td></tr>
<tr><td><code id="plotStewart_+3A_breaks">breaks</code></td>
<td>
<p>numeric; vector of break values to map. If used, 
this parameter overrides <code>typec</code> and <code>nclass</code> parameters</p>
</td></tr>
<tr><td><code id="plotStewart_+3A_typec">typec</code></td>
<td>
<p>character; either &quot;equal&quot; or &quot;quantile&quot;, how to discretize the values.</p>
</td></tr>
<tr><td><code id="plotStewart_+3A_nclass">nclass</code></td>
<td>
<p>numeric (integer), number of classes.</p>
</td></tr>
<tr><td><code id="plotStewart_+3A_legend.rnd">legend.rnd</code></td>
<td>
<p>numeric (integer); number of digits used to round the values 
displayed in the legend.</p>
</td></tr>
<tr><td><code id="plotStewart_+3A_col">col</code></td>
<td>
<p>function; color ramp function, such as <code><a href="grDevices.html#topic+colorRampPalette">colorRampPalette</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Display the raster nicely and return the list of break values (invisible).
</p>


<h3>See Also</h3>

<p><a href="#topic+stewart">stewart</a>, <a href="#topic+rasterStewart">rasterStewart</a>, <a href="#topic+quickStewart">quickStewart</a>, 
<a href="#topic+CreateGrid">CreateGrid</a>, <a href="#topic+CreateDistMatrix">CreateDistMatrix</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(hospital)
# Compute Stewart potentials from known points (hospital) on a
# grid defined by its resolution
mystewart &lt;- stewart(knownpts = hospital, varname = "capacity",
                     typefct = "exponential", span = 1000, beta = 3,
                     resolution = 100, mask = paris)
# Create a raster of potentials values
mystewartraster &lt;- rasterStewart(x = mystewart, mask = paris)
# Plot stewart potentials nicely
plotStewart(x = mystewartraster, add = FALSE, nclass = 5)
# Can be used to obtain break values
break.values &lt;- plotStewart(x = mystewartraster, add = FALSE, nclass = 5)
break.values
</code></pre>

<hr>
<h2 id='quickStewart'>Create Polygons of Potentials Contours</h2><span id='topic+quickStewart'></span>

<h3>Description</h3>

<p>This function is a wrapper around <a href="#topic+stewart">stewart</a>, and <a href="#topic+isopoly">isopoly</a> functions. 
Providing only the main parameters of these functions, it simplifies a lot the computation of potentials. 
This function creates polygons of potential values. 
It also allows to compute directly the ratio between the potentials of two variables.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>quickStewart(
  x,
  spdf,
  df,
  spdfid = NULL,
  dfid = NULL,
  var,
  var2,
  typefct = "exponential",
  span,
  beta,
  resolution,
  mask,
  nclass = 8,
  breaks,
  bypassctrl = FALSE,
  returnclass = "sp"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="quickStewart_+3A_x">x</code></td>
<td>
<p>sp or sf object; this is the set of known observations to 
estimate the potentials from.</p>
</td></tr>
<tr><td><code id="quickStewart_+3A_spdf">spdf</code></td>
<td>
<p>a SpatialPolygonsDataFrame.</p>
</td></tr>
<tr><td><code id="quickStewart_+3A_df">df</code></td>
<td>
<p>a data frame that contains the values to compute</p>
</td></tr>
<tr><td><code id="quickStewart_+3A_spdfid">spdfid</code></td>
<td>
<p>name of the identifier field in spdf, default to the first column 
of the spdf data frame. (optional)</p>
</td></tr>
<tr><td><code id="quickStewart_+3A_dfid">dfid</code></td>
<td>
<p>name of the identifier field in df, default to the first column 
of df. (optional)</p>
</td></tr>
<tr><td><code id="quickStewart_+3A_var">var</code></td>
<td>
<p>name of the numeric field in df used to compute potentials.</p>
</td></tr>
<tr><td><code id="quickStewart_+3A_var2">var2</code></td>
<td>
<p>name of the numeric field in df used to compute potentials. 
This field is used for ratio computation (see Details).</p>
</td></tr>
<tr><td><code id="quickStewart_+3A_typefct">typefct</code></td>
<td>
<p>character; spatial interaction function. Options are &quot;pareto&quot; 
(means power law) or &quot;exponential&quot;.
If &quot;pareto&quot; the interaction is defined as: (1 + alpha * mDistance) ^ (-beta).
If &quot;exponential&quot; the interaction is defined as: 
exp(- alpha * mDistance ^ beta).
The alpha parameter is computed from parameters given by the user 
(<code>beta</code> and <code>span</code>).</p>
</td></tr>
<tr><td><code id="quickStewart_+3A_span">span</code></td>
<td>
<p>numeric; distance where the density of probability of the spatial 
interaction function equals 0.5.</p>
</td></tr>
<tr><td><code id="quickStewart_+3A_beta">beta</code></td>
<td>
<p>numeric; impedance factor for the spatial interaction function.</p>
</td></tr>
<tr><td><code id="quickStewart_+3A_resolution">resolution</code></td>
<td>
<p>numeric; resolution of the output SpatialPointsDataFrame
(in map units). If resolution is not set, the grid will contain around 7250 
points. (optional)</p>
</td></tr>
<tr><td><code id="quickStewart_+3A_mask">mask</code></td>
<td>
<p>sp or sf object; the spatial extent of this object is used to 
create the regularly spaced points output. (optional)</p>
</td></tr>
<tr><td><code id="quickStewart_+3A_nclass">nclass</code></td>
<td>
<p>numeric; a targeted number of classes (default to 8). Not used 
if breaks is set.</p>
</td></tr>
<tr><td><code id="quickStewart_+3A_breaks">breaks</code></td>
<td>
<p>numeric; a vector of values used to discretize the potentials.</p>
</td></tr>
<tr><td><code id="quickStewart_+3A_bypassctrl">bypassctrl</code></td>
<td>
<p>logical; bypass the distance matrix size control (see 
<code><a href="#topic+CreateDistMatrix">CreateDistMatrix</a></code> Details).</p>
</td></tr>
<tr><td><code id="quickStewart_+3A_returnclass">returnclass</code></td>
<td>
<p>&quot;sp&quot; or &quot;sf&quot;; class of the returned object.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If var2 is provided, the ratio between the potentials of var (numerator) 
and var2 (denominator) is computed.
</p>


<h3>Value</h3>

<p>A polyfon object is returned (&quot;sp&quot; or &quot;sf&quot;, see <a href="#topic+isopoly">isopoly</a> Value).
</p>


<h3>See Also</h3>

<p><a href="#topic+stewart">stewart</a>, <a href="#topic+isopoly">isopoly</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># load data
data("hospital")
# Compute potentials
pot &lt;- quickStewart(x = hospital,
                    var = "capacity",
                    span = 1000,
                    beta = 2, mask = paris, 
                    returnclass = "sf")
# cartography
if(require("cartography")){
  breaks &lt;- sort(c(unique(pot$min), max(pot$max)), decreasing = FALSE)
  choroLayer(x = pot,
             var = "center", breaks = breaks,
             legend.pos = "topleft",
             legend.title.txt = "Nb. of Beds")
}

# Compute a ratio of potentials
hospital$dummy &lt;- hospital$capacity + c(rep(50, 18))
pot2 &lt;- quickStewart(x = hospital,
                     var = "capacity",
                     var2 = "dummy",
                     span = 1000,
                     beta = 2, 
                     mask = paris, 
                     returnclass = "sf")
# cartography
if(require("cartography")){
  breaks &lt;- sort(c(unique(pot2$min), max(pot2$max)), decreasing = FALSE)
  choroLayer(x = pot2,
             var = "center", breaks = breaks,
             legend.pos = "topleft",legend.values.rnd = 3,
             legend.title.txt = "Nb. of DummyBeds")
}
</code></pre>

<hr>
<h2 id='rasterHuff'>Create a Raster from a Huff SpatialPointsDataFrame</h2><span id='topic+rasterHuff'></span>

<h3>Description</h3>

<p>This function creates a raster from a regularly spaced 
Huff grid (output of the <code><a href="#topic+huff">huff</a></code> function).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rasterHuff(x, mask = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rasterHuff_+3A_x">x</code></td>
<td>
<p>sp or sf object; output of the <code>huff</code> function.</p>
</td></tr>
<tr><td><code id="rasterHuff_+3A_mask">mask</code></td>
<td>
<p>sp or sf object; this object is used to clip 
the raster. (optional)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Raster of catchment areas values.
</p>


<h3>See Also</h3>

<p><a href="#topic+huff">huff</a>, <a href="#topic+plotHuff">plotHuff</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(raster)
data(hospital)
# Compute Huff catchment areas from known points (hospital) on a
# grid defined by its resolution
myhuff &lt;- huff(knownpts = hospital, varname = "capacity",
               typefct = "exponential", span = 750, beta = 2,
               resolution = 100, mask = paris, returnclass = "sf")
# Create a raster of huff values
myhuffraster &lt;- rasterHuff(x = myhuff, mask = paris)
plot(myhuffraster)
</code></pre>

<hr>
<h2 id='rasterReilly'>Create a Raster from a Reilly Regular Grid</h2><span id='topic+rasterReilly'></span>

<h3>Description</h3>

<p>This function creates a raster from a regularly spaced 
Reilly grid (output of the <code><a href="#topic+reilly">reilly</a></code> function).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rasterReilly(x, mask = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rasterReilly_+3A_x">x</code></td>
<td>
<p>sp or sf object; output of the <code>reilly</code> function.</p>
</td></tr>
<tr><td><code id="rasterReilly_+3A_mask">mask</code></td>
<td>
<p>sp or sf object; this object is used to clip 
the raster. (optional)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Raster of catchment areas values.
The raster uses a RAT (<code>ratify</code>) that contains the 
correspondance between raster values and catchement areas values. Use <code>
unique(levels(rasterName)[[1]])</code> to see the correpondance table.
</p>


<h3>See Also</h3>

<p><a href="#topic+reilly">reilly</a>, <a href="#topic+plotReilly">plotReilly</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(raster)
data(hospital)
# Compute Reilly catchment areas from known points (hospital) on a
# grid defined by its resolution
myreilly &lt;- reilly(knownpts = hospital, varname = "capacity",
                   typefct = "exponential", span = 1250, beta = 3,
                   resolution = 200, mask = paris, returnclass = "sf")
# Create a raster of reilly values
myreillyraster &lt;- rasterReilly(x = myreilly, mask = paris)
plot(myreillyraster, col = rainbow(18))
# Correspondance between raster values and reilly areas
head(unique(levels(myreillyraster)[[1]]))
</code></pre>

<hr>
<h2 id='rasterStewart'>Create a Raster from a Stewart Regular Grid</h2><span id='topic+rasterStewart'></span>

<h3>Description</h3>

<p>This function creates a raster from a regularly spaced 
Stewart points grid (output of the <code><a href="#topic+stewart">stewart</a></code> function).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rasterStewart(x, mask = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rasterStewart_+3A_x">x</code></td>
<td>
<p>sp or sf object; output of the <code>stewart</code> 
function.</p>
</td></tr>
<tr><td><code id="rasterStewart_+3A_mask">mask</code></td>
<td>
<p>sp or sf object; this object is used to clip 
the raster. (optional)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Raster of potential values.
</p>


<h3>See Also</h3>

<p><a href="#topic+stewart">stewart</a>, <a href="#topic+quickStewart">quickStewart</a>, <a href="#topic+plotStewart">plotStewart</a>, 
<a href="#topic+CreateGrid">CreateGrid</a>, <a href="#topic+CreateDistMatrix">CreateDistMatrix</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(raster)
data(hospital)
# Compute Stewart potentials from known points (hospital) on a
# grid defined by its resolution
mystewart &lt;- stewart(knownpts = hospital, varname = "capacity",
                     typefct = "exponential", span = 1000, beta = 3,
                     resolution = 100, mask = paris)
# Create a raster of potentials values
mystewartraster &lt;- rasterStewart(x = mystewart, mask = paris)
plot(mystewartraster)
</code></pre>

<hr>
<h2 id='reilly'>Reilly Catchment Areas</h2><span id='topic+reilly'></span>

<h3>Description</h3>

<p>This function computes the catchment areas as defined by W.J. Reilly (1931).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>reilly(
  knownpts,
  unknownpts,
  matdist,
  varname,
  typefct = "exponential",
  span,
  beta,
  resolution,
  mask,
  bypassctrl = FALSE,
  longlat = TRUE,
  returnclass = "sp"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="reilly_+3A_knownpts">knownpts</code></td>
<td>
<p>sp or sf object; 
this is the set of known observations to estimate the catchment areas from.</p>
</td></tr>
<tr><td><code id="reilly_+3A_unknownpts">unknownpts</code></td>
<td>
<p>sp or sf object; 
this is the set of unknown units for which the function computes the estimates. 
Not used when <code>resolution</code> is set up. (optional)</p>
</td></tr>
<tr><td><code id="reilly_+3A_matdist">matdist</code></td>
<td>
<p>matrix; distance matrix between known observations and unknown 
units for which the function computes the estimates. Row names match the row 
names of <code>knownpts</code> and column names match the row names of 
<code>unknownpts</code>. <code>matdist</code> can contain any distance metric (time 
distance or euclidean distance for example). If <code>matdist</code> is not set, 
the distance matrix is built with <code><a href="#topic+CreateDistMatrix">CreateDistMatrix</a></code>. (optional)</p>
</td></tr>
<tr><td><code id="reilly_+3A_varname">varname</code></td>
<td>
<p>character; name of the variable in the <code>knownpts</code> dataframe 
from which values are computed. Quantitative variable with no negative values.</p>
</td></tr>
<tr><td><code id="reilly_+3A_typefct">typefct</code></td>
<td>
<p>character; spatial interaction function. Options are &quot;pareto&quot; 
(means power law) or &quot;exponential&quot;.
If &quot;pareto&quot; the interaction is defined as: (1 + alpha * mDistance) ^ (-beta).
If &quot;exponential&quot; the interaction is defined as: 
exp(- alpha * mDistance ^ beta).
The alpha parameter is computed from parameters given by the user 
(<code>beta</code> and <code>span</code>).</p>
</td></tr>
<tr><td><code id="reilly_+3A_span">span</code></td>
<td>
<p>numeric; distance where the density of probability of the spatial 
interaction function equals 0.5.</p>
</td></tr>
<tr><td><code id="reilly_+3A_beta">beta</code></td>
<td>
<p>numeric; impedance factor for the spatial interaction function.</p>
</td></tr>
<tr><td><code id="reilly_+3A_resolution">resolution</code></td>
<td>
<p>numeric; resolution of the output grid (in map units). 
If resolution is not set, the grid will contain around 7250 points. (optional)</p>
</td></tr>
<tr><td><code id="reilly_+3A_mask">mask</code></td>
<td>
<p>sp or sf object; the spatial extent of this object is used to 
create the regularly spaced points output. (optional)</p>
</td></tr>
<tr><td><code id="reilly_+3A_bypassctrl">bypassctrl</code></td>
<td>
<p>logical; bypass the distance matrix size control (see 
<code><a href="#topic+CreateDistMatrix">CreateDistMatrix</a></code> Details).</p>
</td></tr>
<tr><td><code id="reilly_+3A_longlat">longlat</code></td>
<td>
<p>logical; if FALSE, Euclidean distance, if TRUE Great Circle 
(WGS84 ellipsoid) distance.</p>
</td></tr>
<tr><td><code id="reilly_+3A_returnclass">returnclass</code></td>
<td>
<p>&quot;sp&quot; or &quot;sf&quot;; class of the returned object.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Point object with the computed catchment areas in a new 
field named <code>OUTPUT</code>. Values match the row names of <code>knownpts</code>.
</p>


<h3>References</h3>

<p>REILLY, W. J. (1931) The law of retail gravitation, W. J. Reilly, New York.
</p>


<h3>See Also</h3>

<p><a href="#topic+reilly">reilly</a>, <a href="#topic+rasterReilly">rasterReilly</a>, <a href="#topic+plotReilly">plotReilly</a>, <a href="#topic+CreateGrid">CreateGrid</a>, 
<a href="#topic+CreateDistMatrix">CreateDistMatrix</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Create a grid of paris extent and 200 meters
# resolution
data(hospital)
mygrid &lt;- CreateGrid(w = hospital, resolution = 200, returnclass = "sf")
# Create a distance matrix between known points (hospital) and mygrid
mymat &lt;- CreateDistMatrix(knownpts = hospital, unknownpts = mygrid)
# Compute Reilly catchment areas from known points (hospital) on a given
# grid (mygrid) using a given distance matrix (mymat)
myreilly2 &lt;- reilly(knownpts = hospital, unknownpts = mygrid,
                    matdist = mymat, varname = "capacity",
                    typefct = "exponential", span = 1250,
                    beta = 3, mask = paris, returnclass = "sf")
# Compute Reilly catchment areas from known points (hospital) on a
# grid defined by its resolution
myreilly &lt;- reilly(knownpts = hospital, varname = "capacity",
                   typefct = "exponential", span = 1250, beta = 3,
                   resolution = 200, mask = paris, returnclass = "sf")
# The function output an sf object
class(myreilly)
# The OUTPUT field values match knownpts row names
head(unique(myreilly$OUTPUT))
</code></pre>

<hr>
<h2 id='smoothy'>Stewart Smooth</h2><span id='topic+smoothy'></span>

<h3>Description</h3>

<p>This function computes a distance weighted mean. It offers the 
same parameters as <code><a href="#topic+stewart">stewart</a></code>: user defined distance matrix, user 
defined impedance function (power or exponential), user defined exponent.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>smoothy(
  knownpts,
  unknownpts,
  matdist,
  varname,
  typefct = "exponential",
  span,
  beta,
  resolution,
  mask,
  bypassctrl = FALSE,
  longlat = TRUE,
  returnclass = "sp"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="smoothy_+3A_knownpts">knownpts</code></td>
<td>
<p>sp or sf object; this is the set of known observations to 
estimate the potentials from.</p>
</td></tr>
<tr><td><code id="smoothy_+3A_unknownpts">unknownpts</code></td>
<td>
<p>sp or sf object;
this is the set of unknown units for which the function computes the estimates. 
Not used when <code>resolution</code> is set up. (optional)</p>
</td></tr>
<tr><td><code id="smoothy_+3A_matdist">matdist</code></td>
<td>
<p>matrix; distance matrix between known observations and unknown 
units for which the function computes the estimates. Row names match the row 
names of <code>knownpts</code> and column names match the row names of 
<code>unknownpts</code>. <code>matdist</code> can contain any distance metric (time 
distance or euclidean distance for example). If <code>matdist</code> is NULL, the distance 
matrix is built with <code><a href="#topic+CreateDistMatrix">CreateDistMatrix</a></code>. (optional)</p>
</td></tr>
<tr><td><code id="smoothy_+3A_varname">varname</code></td>
<td>
<p>character; name of the variable in the <code>knownpts</code> dataframe 
from which potentials are computed. Quantitative variable with no negative values.</p>
</td></tr>
<tr><td><code id="smoothy_+3A_typefct">typefct</code></td>
<td>
<p>character; spatial interaction function. Options are &quot;pareto&quot; 
(means power law) or &quot;exponential&quot;.
If &quot;pareto&quot; the interaction is defined as: (1 + alpha * mDistance) ^ (-beta).
If &quot;exponential&quot; the interaction is defined as: 
exp(- alpha * mDistance ^ beta).
The alpha parameter is computed from parameters given by the user 
(<code>beta</code> and <code>span</code>).</p>
</td></tr>
<tr><td><code id="smoothy_+3A_span">span</code></td>
<td>
<p>numeric; distance where the density of probability of the spatial 
interaction function equals 0.5.</p>
</td></tr>
<tr><td><code id="smoothy_+3A_beta">beta</code></td>
<td>
<p>numeric; impedance factor for the spatial interaction function.</p>
</td></tr>
<tr><td><code id="smoothy_+3A_resolution">resolution</code></td>
<td>
<p>numeric; resolution of the output grid
(in map units). If resolution is not set, the grid will contain around 7250 
points. (optional)</p>
</td></tr>
<tr><td><code id="smoothy_+3A_mask">mask</code></td>
<td>
<p>sp or sf object; the spatial extent of this object is used to 
create the regularly spaced points output. (optional)</p>
</td></tr>
<tr><td><code id="smoothy_+3A_bypassctrl">bypassctrl</code></td>
<td>
<p>logical; bypass the distance matrix size control (see 
<code><a href="#topic+CreateDistMatrix">CreateDistMatrix</a></code> Details).</p>
</td></tr>
<tr><td><code id="smoothy_+3A_longlat">longlat</code></td>
<td>
<p>logical; if FALSE, Euclidean distance, if TRUE Great Circle 
(WGS84 ellipsoid) distance.</p>
</td></tr>
<tr><td><code id="smoothy_+3A_returnclass">returnclass</code></td>
<td>
<p>&quot;sp&quot; or &quot;sf&quot;; class of the returned object.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Point object with the computed distance weighted mean in a new field 
named <code>OUTPUT</code>.
</p>


<h3>See Also</h3>

<p><a href="#topic+stewart">stewart</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Create a grid of paris extent and 200 meters
# resolution
data(hospital)
mygrid &lt;- CreateGrid(w = paris, resolution = 200, returnclass = "sf")
# Create a distance matrix between known points (hospital) and mygrid
mymat &lt;- CreateDistMatrix(knownpts = hospital, unknownpts = mygrid)
# Compute  distance weighted mean from known points (hospital) on a given
# grid (mygrid) using a given distance matrix (mymat)
mysmoothy &lt;- smoothy(knownpts = hospital, unknownpts = mygrid,
                     matdist = mymat, varname = "capacity",
                     typefct = "exponential", span = 1250,
                     beta = 3, mask = paris, returnclass = "sf")
# Compute  distance weighted mean from known points (hospital) on a
# grid defined by its resolution
mysmoothy2 &lt;- smoothy(knownpts = hospital, varname = "capacity",
                      typefct = "exponential", span = 1250, beta = 3,
                      resolution = 200, mask = paris, returnclass = "sf")
# The two methods have the same result
identical(mysmoothy, mysmoothy2)
# Computed values
summary(mysmoothy$OUTPUT)
</code></pre>

<hr>
<h2 id='SpatialPosition'>Spatial Position Package</h2><span id='topic+SpatialPosition'></span><span id='topic+SpatialPosition-package'></span>

<h3>Description</h3>

<p>Computes spatial position models: </p>

<ul>
<li><p>Stewart potentials,
</p>
</li>
<li><p>Reilly catchment areas, 
</p>
</li>
<li><p>Huff catchment areas.
</p>
</li></ul>

<p>An introduction to the package conceptual background and usage: <br />
- <code>vignette(topic = "SpatialPosition")</code><br />
A Stewart potentials use case:<br />
- <code>vignette(topic = "StewartExample")</code>.
</p>


<h3>Author(s)</h3>

<p><strong>Maintainer</strong>: Timothée Giraud <a href="mailto:timothee.giraud@cnrs.fr">timothee.giraud@cnrs.fr</a> (<a href="https://orcid.org/0000-0002-1932-3323">ORCID</a>)
</p>
<p>Authors:
</p>

<ul>
<li><p> Hadrien Commenges
</p>
</li></ul>

<p>Other contributors:
</p>

<ul>
<li><p> Joël Boulier [contributor]
</p>
</li></ul>



<h3>References</h3>

<p>COMMENGES H., GIRAUD, T., LAMBERT, N. (2016) &quot;ESPON FIT: Functional Indicators for Spatial-Aware Policy-Making&quot;, 
Cartographica: The International Journal for Geographic Information and Geovisualization, 51(3): 127-136.
</p>


<h3>See Also</h3>

<p>Useful links:
</p>

<ul>
<li> <p><a href="https://github.com/riatelab/SpatialPosition">https://github.com/riatelab/SpatialPosition</a>
</p>
</li>
<li><p> Report bugs at <a href="https://github.com/riatelab/SpatialPosition/issues">https://github.com/riatelab/SpatialPosition/issues</a>
</p>
</li></ul>


<hr>
<h2 id='stewart'>Stewart Potentials</h2><span id='topic+stewart'></span>

<h3>Description</h3>

<p>This function computes the potentials as defined by J.Q. Stewart (1942).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>stewart(
  knownpts,
  unknownpts,
  matdist,
  varname,
  typefct = "exponential",
  span,
  beta,
  resolution,
  mask,
  bypassctrl = FALSE,
  longlat = TRUE,
  returnclass = "sp"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="stewart_+3A_knownpts">knownpts</code></td>
<td>
<p>sp or sf object; this is the set of known observations to 
estimate the potentials from.</p>
</td></tr>
<tr><td><code id="stewart_+3A_unknownpts">unknownpts</code></td>
<td>
<p>sp or sf object; this is the set of unknown units for which 
the function computes the estimates. Not used when <code>resolution</code> is set 
up. (optional)</p>
</td></tr>
<tr><td><code id="stewart_+3A_matdist">matdist</code></td>
<td>
<p>matrix; distance matrix between known observations and unknown 
units for which the function computes the estimates. Row names match the row 
names of <code>knownpts</code> and column names match the row names of 
<code>unknownpts</code>. <code>matdist</code> can contain any distance metric (time 
distance or euclidean distance for example). If <code>matdist</code> is missing, the distance 
matrix is built with <code><a href="#topic+CreateDistMatrix">CreateDistMatrix</a></code>. (optional)</p>
</td></tr>
<tr><td><code id="stewart_+3A_varname">varname</code></td>
<td>
<p>character; name of the variable in the <code>knownpts</code> dataframe 
from which potentials are computed. Quantitative variable with no negative values.</p>
</td></tr>
<tr><td><code id="stewart_+3A_typefct">typefct</code></td>
<td>
<p>character; spatial interaction function. Options are &quot;pareto&quot; 
(means power law) or &quot;exponential&quot;.
If &quot;pareto&quot; the interaction is defined as: (1 + alpha * mDistance) ^ (-beta).
If &quot;exponential&quot; the interaction is defined as: 
exp(- alpha * mDistance ^ beta).
The alpha parameter is computed from parameters given by the user 
(<code>beta</code> and <code>span</code>).</p>
</td></tr>
<tr><td><code id="stewart_+3A_span">span</code></td>
<td>
<p>numeric; distance where the density of probability of the spatial 
interaction function equals 0.5.</p>
</td></tr>
<tr><td><code id="stewart_+3A_beta">beta</code></td>
<td>
<p>numeric; impedance factor for the spatial interaction function.</p>
</td></tr>
<tr><td><code id="stewart_+3A_resolution">resolution</code></td>
<td>
<p>numeric; resolution of the output grid (in map units). 
If resolution is not set, the grid will contain around 7250 points. (optional)</p>
</td></tr>
<tr><td><code id="stewart_+3A_mask">mask</code></td>
<td>
<p>sp or sf object; the spatial extent of this object is used to 
create the regularly spaced points output. (optional)</p>
</td></tr>
<tr><td><code id="stewart_+3A_bypassctrl">bypassctrl</code></td>
<td>
<p>logical; bypass the distance matrix size control (see 
<code><a href="#topic+CreateDistMatrix">CreateDistMatrix</a></code> Details).</p>
</td></tr>
<tr><td><code id="stewart_+3A_longlat">longlat</code></td>
<td>
<p>logical; if FALSE, Euclidean distance, if TRUE Great Circle 
(WGS84 ellipsoid) distance.</p>
</td></tr>
<tr><td><code id="stewart_+3A_returnclass">returnclass</code></td>
<td>
<p>&quot;sp&quot; or &quot;sf&quot;; class of the returned object.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Point object with the computed potentials in a new field 
named <code>OUTPUT</code>.
</p>


<h3>References</h3>

<p>STEWART J.Q. (1942) &quot;Measure of the influence of a population at a distance&quot;, Sociometry, 5(1): 63-71.
</p>


<h3>See Also</h3>

<p><a href="#topic+rasterStewart">rasterStewart</a>, <a href="#topic+plotStewart">plotStewart</a>, <a href="#topic+quickStewart">quickStewart</a>,
<a href="#topic+isopoly">isopoly</a>, <a href="#topic+CreateGrid">CreateGrid</a>, <a href="#topic+CreateDistMatrix">CreateDistMatrix</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Create a grid of paris extent and 200 meters
# resolution
data(hospital)
mygrid &lt;- CreateGrid(w = paris, resolution = 200, returnclass = "sf")
# Create a distance matrix between known points (spatPts) and mygrid
mymat &lt;- CreateDistMatrix(knownpts = hospital, unknownpts = mygrid)
# Compute Stewart potentials from known points (spatPts) on a given
# grid (mygrid) using a given distance matrix (mymat)
mystewart &lt;- stewart(knownpts = hospital, unknownpts = mygrid,
                     matdist = mymat, varname = "capacity",
                     typefct = "exponential", span = 1250,
                     beta = 3, mask = paris, returnclass = "sf")
# Compute Stewart potentials from known points (spatPts) on a
# grid defined by its resolution
mystewart2 &lt;- stewart(knownpts = hospital, varname = "capacity",
                      typefct = "exponential", span = 1250, beta = 3,
                      resolution = 200, mask = paris, returnclass = "sf")
# The two methods have the same result
identical(mystewart, mystewart2)
# the function output a sf data.frame
class(mystewart)
# Computed values
summary(mystewart$OUTPUT)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
