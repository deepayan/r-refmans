<!DOCTYPE html><html lang="en"><head><title>Help for package nlsr</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {nlsr}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#coef.nlsr'><p>coef.nlsr</p></a></li>
<li><a href='#dex'><p>dex</p></a></li>
<li><a href='#findSubexprs'><p>findSubexprs</p></a></li>
<li><a href='#fitted.nlsr'><p>fitted.nlsr</p></a></li>
<li><a href='#isCALL'><p>isCALL</p>
</p>
<p>Test if argument is a particular call</p></a></li>
<li><a href='#isZERO'><p>Test for constants</p></a></li>
<li><a href='#jaback'><p>jaback</p></a></li>
<li><a href='#jacentral'><p>jacentral</p></a></li>
<li><a href='#jafwd'><p>jafwd</p></a></li>
<li><a href='#jand'><p>jand</p></a></li>
<li><a href='#model2rjfun'><p>model2rjfun</p></a></li>
<li><a href='#newDeriv'><p>newDeriv</p></a></li>
<li><a href='#newSimplification'><p>newSimplification</p></a></li>
<li><a href='#nlfb'><p>nlfb: nonlinear least squares modeling by functions</p></a></li>
<li><a href='#nlsDeriv'><p>nlsDeriv</p>
Functions to take symbolic derivatives.</a></li>
<li><a href='#nlsr'><p>nlsr function</p></a></li>
<li><a href='#nlsr.control'><p>nlsr.control</p></a></li>
<li><a href='#nlsr.package'><p>nlsr-package</p>
</p>
<p>Tools for solving nonlinear least squares problems</p>
</p>
<p>The package provides some tools related to using the Nash variant</p>
of Marquardt's algorithm for nonlinear least squares. Jacobians can
usually be developed by automatic or symbolic derivatives.</a></li>
<li><a href='#nlsrSS'><p>nlsrSS - solve selfStart nonlinear least squares with nlsr package</p></a></li>
<li><a href='#nlsSimplify'><p>nlsSimplify</p></a></li>
<li><a href='#nlxb'><p>nlxb: nonlinear least squares modeling by formula</p></a></li>
<li><a href='#numericDerivR'><p>numericDerivR: numerically evaluates the gradient of an expression. All in R</p></a></li>
<li><a href='#nvec'><p>nvec</p></a></li>
<li><a href='#pctrl'><p>pctrl</p></a></li>
<li><a href='#pnls'><p>pnls</p></a></li>
<li><a href='#pnlslm'><p>pnlslm</p></a></li>
<li><a href='#predict.nlsr'><p>predict.nlsr</p></a></li>
<li><a href='#print.nlsr'><p>print.nlsr</p></a></li>
<li><a href='#prt'><p>prt</p></a></li>
<li><a href='#pshort'><p>pshort</p></a></li>
<li><a href='#rawres'><p>rawres</p></a></li>
<li><a href='#resgr'><p>resgr</p></a></li>
<li><a href='#resid.nlsr'><p>resid.nlsr</p></a></li>
<li><a href='#residuals.nlsr'><p>residuals.nlsr</p></a></li>
<li><a href='#resss'><p>resss</p></a></li>
<li><a href='#SSlogisJN'><p>Alternative self start for three-parameter logistic function SSlogis</p></a></li>
<li><a href='#summary.nlsr'><p>summary.nlsr</p></a></li>
<li><a href='#sysDerivs'><p>Internal Environments</p></a></li>
<li><a href='#wrapnlsr'><p>wrapnlsr</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Functions for Nonlinear Least Squares Solutions - Updated 2022</td>
</tr>
<tr>
<td>Version:</td>
<td>2023.8.31</td>
</tr>
<tr>
<td>Date:</td>
<td>2023-08-31</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>John C Nash &lt;nashjc@uottawa.ca&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Provides tools for working with nonlinear least squares problems.
      For the estimation of models reliable and robust tools than nls(), where the
      the Gauss-Newton method frequently stops with 'singular gradient' messages. 
      This is accomplished by using, where possible, analytic derivatives to compute
      the matrix of derivatives and a stabilization of the solution of the estimation
      equations. Tools for approximate or externally supplied derivative matrices
      are included. Bounds and masks on parameters are handled properly.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.5)</td>
</tr>
<tr>
<td>Imports:</td>
<td>digest</td>
</tr>
<tr>
<td>Suggests:</td>
<td>minpack.lm, optimx, numDeriv, knitr, rmarkdown, markdown,
Ryacas, Deriv, microbenchmark, MASS, ggplot2, nlraa</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.1</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-09-02 18:59:12 UTC; john</td>
</tr>
<tr>
<td>Author:</td>
<td>John C Nash [aut, cre],
  Duncan Murdoch [aut],
  Fernando Miguez [ctb],
  Arkajyoti Bhattacharjee [ctb]</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-09-05 08:10:09 UTC</td>
</tr>
</table>
<hr>
<h2 id='coef.nlsr'>coef.nlsr</h2><span id='topic+coef.nlsr'></span>

<h3>Description</h3>

<p>prepare and display result of <code>nlsr</code> computations
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'nlsr'
coef(object, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="coef.nlsr_+3A_object">object</code></td>
<td>
<p>an object of class <code>nlsr</code></p>
</td></tr>
<tr><td><code id="coef.nlsr_+3A_...">...</code></td>
<td>
<p>additional data needed to evaluate the modeling functions
Default FALSE</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The set of possible controls to set is as follows
</p>


<h3>Author(s)</h3>

<p>J C Nash 2014-7-16   nashjc _at_ uottawa.ca
</p>

<hr>
<h2 id='dex'>dex</h2><span id='topic+dex'></span>

<h3>Description</h3>

<p>Calculate expression for derivative calculations.
Mainly for internal use, <code>dex()</code> converts 
its input to an expression suitable for use
in <code><a href="#topic+nlsDeriv">nlsDeriv</a></code> and related functions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dex(x, do_substitute = NA, verbose = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="dex_+3A_x">x</code></td>
<td>
<p>An expression represented in a variety of ways.
See Details.</p>
</td></tr>
<tr><td><code id="dex_+3A_do_substitute">do_substitute</code></td>
<td>
<p>Whether to use the expression passed as <code>x</code>, or
to evaluate it and use its value.</p>
</td></tr>
<tr><td><code id="dex_+3A_verbose">verbose</code></td>
<td>
<p>Print messages describing the process.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If <code>do_substitute</code> is <code>NA</code>, the following 
rules are used:
</p>

<ul>
<li><p> An attempt is made to evaluate <code>x</code>.  If that fails,
the expression is used.
</p>
</li>
<li><p> If the evaluation succeeds and the value is a character
vector, it is parsed.
</p>
</li>
<li><p> If the value is not a character vector and the
expression is a single name, the value is used.
</p>
</li></ul>

<p>Otherwise, the expression is used.
</p>
<p>Once the expression is determined it may be simplified,
by extracting the language object from a length-one
expression vector, or the right-hand-side from a 
formula.
</p>
<p>Normally a warning will be issued if <code>x</code> is a formula
containing a left-hand side.  To suppress this, 
wrap the formula in <code>expression()</code>, or pass it 
as a character string to be parsed.
</p>


<h3>value</h3>

<p>An expression or language object suitable as input
to <code><a href="#topic+nlsDeriv">nlsDeriv</a></code> and related functions.
</p>


<h3>Author(s)</h3>

<p>Duncan Murdoch
</p>


<h3>Examples</h3>

<pre><code class='language-R'>   aa &lt;- dex(~ x^2)
   aa
   str(aa)
   bb &lt;- dex(expression(x^2))
   bb
   str(bb)
   cc &lt;- dex("x^2")
   cc
   str(cc)
   
</code></pre>

<hr>
<h2 id='findSubexprs'>findSubexprs</h2><span id='topic+findSubexprs'></span>

<h3>Description</h3>

<p>Find common sub-expressions in <code>expr</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>findSubexprs(expr, simplify = FALSE, tag = ".expr", verbose = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="findSubexprs_+3A_expr">expr</code></td>
<td>
<p>An expression represented in a variety of ways. See Details.</p>
</td></tr>
<tr><td><code id="findSubexprs_+3A_simplify">simplify</code></td>
<td>
<p>Whether to simplify.</p>
</td></tr>
<tr><td><code id="findSubexprs_+3A_tag">tag</code></td>
<td>
<p>to be attached to the returned object(s)</p>
</td></tr>
<tr><td><code id="findSubexprs_+3A_verbose">verbose</code></td>
<td>
<p>If <code>TRUE</code>, then diagnostic output will be printed as derivatives
and simplifications are recognized.</p>
</td></tr>
<tr><td><code id="findSubexprs_+3A_...">...</code></td>
<td>
<p>Additional arguments, passed to <code><a href="#topic+nlsSimplify">nlsSimplify</a></code></p>
</td></tr></table>
<p>.
</p>


<h3>Details</h3>

<p>If <code>expr</code> contains repeated subexpressions, this function
returns an expression to evaluate them just once and store them
in temporary variables with names starting with the <code>tag</code>.
</p>
<p>This function is used internally by <code><a href="#topic+codeDeriv">codeDeriv</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>findSubexprs(expression(x^2 + x^2), tag = ".example")
</code></pre>

<hr>
<h2 id='fitted.nlsr'>fitted.nlsr</h2><span id='topic+fitted.nlsr'></span>

<h3>Description</h3>

<p>prepare and display fits of <code>nlsr</code> computations
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'nlsr'
fitted(object = NULL, data = parent.frame(), ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="fitted.nlsr_+3A_object">object</code></td>
<td>
<p>an object of class <code>nlsr</code></p>
</td></tr>
<tr><td><code id="fitted.nlsr_+3A_data">data</code></td>
<td>
<p>a data frame with the data for which fits are wanted.</p>
</td></tr>
<tr><td><code id="fitted.nlsr_+3A_...">...</code></td>
<td>
<p>additional data needed to evaluate the modeling functions
Default FALSE</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>J C Nash 2014-7-16 revised 2022-11-22  nashjc _at_ uottawa.ca
</p>

<hr>
<h2 id='isCALL'>isCALL
Test if argument is a particular call</h2><span id='topic+isCALL'></span>

<h3>Description</h3>

<p>Test if <code>x</code> is a call to the function given by <code>name</code>.
</p>
<p>Used in <code><a href="#topic+newSimplification">newSimplification</a></code> definitions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>isCALL(x, name)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="isCALL_+3A_x">x</code></td>
<td>
<p>object to be tested</p>
</td></tr>
<tr><td><code id="isCALL_+3A_name">name</code></td>
<td>
<p>The function to test for.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- quote(mean(1:10))
isCALL(x, "mean")
isCALL(x, "sd")
</code></pre>

<hr>
<h2 id='isZERO'>Test for constants</h2><span id='topic+isZERO'></span><span id='topic+isONE'></span><span id='topic+isMINUSONE'></span>

<h3>Description</h3>

<p>Test for the values <code>0</code>, <code>1</code> or <code>-1</code>.
</p>
<p>Used in <code><a href="#topic+newSimplification">newSimplification</a></code> definitions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>isZERO(x)
isONE(x)
isMINUSONE(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="isZERO_+3A_x">x</code></td>
<td>
<p>object to be tested</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns <code>TRUE</code> if the argument is the appropriate scalar value.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>isZERO(0)
x &lt;- quote(0*1)
isZERO(x) # This is `*`(0, 1), not a value
isZERO(eval(x))
x &lt;- quote(-1)
isMINUSONE(x) # This is `-`(1), not a value
isMINUSONE(eval(x))
</code></pre>

<hr>
<h2 id='jaback'>jaback</h2><span id='topic+jaback'></span>

<h3>Description</h3>

<p>approximate Jacobian via forward differences
</p>


<h3>Usage</h3>

<pre><code class='language-R'>jaback(pars, resfn = NULL, bdmsk = NULL, resbest = NULL, ndstep = 1e-07, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="jaback_+3A_pars">pars</code></td>
<td>
<p>a named numeric vector of parameters to the model</p>
</td></tr>
<tr><td><code id="jaback_+3A_resfn">resfn</code></td>
<td>
<p>a function to compute a vector of residuals</p>
</td></tr>
<tr><td><code id="jaback_+3A_bdmsk">bdmsk</code></td>
<td>
<p>Vector defining bounds and masks. Default is <code>NULL</code></p>
</td></tr>
<tr><td><code id="jaback_+3A_resbest">resbest</code></td>
<td>
<p>If supplied, a vector of the residuals at the parameters
<code>pars</code> to save re-evaluation.</p>
</td></tr>
<tr><td><code id="jaback_+3A_ndstep">ndstep</code></td>
<td>
<p>A tolerance used to alter parameters to compute numerical
approximations to derivatives. Default <code>1e-7</code>.</p>
</td></tr>
<tr><td><code id="jaback_+3A_...">...</code></td>
<td>
<p>Extra information needed to compute the residuals</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>J C Nash 2014-7-16   nashjc _at_ uottawa.ca
</p>

<hr>
<h2 id='jacentral'>jacentral</h2><span id='topic+jacentral'></span>

<h3>Description</h3>

<p>Approximate Jacobian via central differences. Note this needs two
evaluations per parameter, but generally gives much better approximation
of the derivatives.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>jacentral(
  pars,
  resfn = NULL,
  bdmsk = NULL,
  resbest = NULL,
  ndstep = 1e-07,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="jacentral_+3A_pars">pars</code></td>
<td>
<p>a named numeric vector of parameters to the model</p>
</td></tr>
<tr><td><code id="jacentral_+3A_resfn">resfn</code></td>
<td>
<p>a function to compute a vector of residuals</p>
</td></tr>
<tr><td><code id="jacentral_+3A_bdmsk">bdmsk</code></td>
<td>
<p>Vector defining bounds and masks. Default is <code>NULL</code></p>
</td></tr>
<tr><td><code id="jacentral_+3A_resbest">resbest</code></td>
<td>
<p>If supplied, a vector of the residuals at the parameters
<code>pars</code> to save re-evaluation.</p>
</td></tr>
<tr><td><code id="jacentral_+3A_ndstep">ndstep</code></td>
<td>
<p>A tolerance used to alter parameters to compute numerical
approximations to derivatives. Default <code>1e-7</code>.</p>
</td></tr>
<tr><td><code id="jacentral_+3A_...">...</code></td>
<td>
<p>Extra information needed to compute the residuals</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>J C Nash 2014-7-16 revised 2022-11-22   nashjc _at_ uottawa.ca
</p>

<hr>
<h2 id='jafwd'>jafwd</h2><span id='topic+jafwd'></span>

<h3>Description</h3>

<p>approximate Jacobian via forward differences
</p>


<h3>Usage</h3>

<pre><code class='language-R'>jafwd(pars, resfn = NULL, bdmsk = NULL, resbest = NULL, ndstep = 1e-07, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="jafwd_+3A_pars">pars</code></td>
<td>
<p>a named numeric vector of parameters to the model</p>
</td></tr>
<tr><td><code id="jafwd_+3A_resfn">resfn</code></td>
<td>
<p>a function to compute a vector of residuals</p>
</td></tr>
<tr><td><code id="jafwd_+3A_bdmsk">bdmsk</code></td>
<td>
<p>Vector defining bounds and masks. Default is <code>NULL</code></p>
</td></tr>
<tr><td><code id="jafwd_+3A_resbest">resbest</code></td>
<td>
<p>If supplied, a vector of the residuals at the parameters
<code>pars</code> to save re-evaluation.</p>
</td></tr>
<tr><td><code id="jafwd_+3A_ndstep">ndstep</code></td>
<td>
<p>A tolerance used to alter parameters to compute numerical
approximations to derivatives. Default <code>1e-7</code>.</p>
</td></tr>
<tr><td><code id="jafwd_+3A_...">...</code></td>
<td>
<p>Extra information needed to compute the residuals</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>J C Nash 2014-7-16   nashjc _at_ uottawa.ca
</p>

<hr>
<h2 id='jand'>jand</h2><span id='topic+jand'></span>

<h3>Description</h3>

<p>approximate Jacobian via numDeriv::jacobian
</p>


<h3>Usage</h3>

<pre><code class='language-R'>jand(pars, resfn = NULL, bdmsk = NULL, resbest = NULL, ndstep = 1e-07, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="jand_+3A_pars">pars</code></td>
<td>
<p>a named numeric vector of parameters to the model</p>
</td></tr>
<tr><td><code id="jand_+3A_resfn">resfn</code></td>
<td>
<p>a function to compute a vector of residuals</p>
</td></tr>
<tr><td><code id="jand_+3A_bdmsk">bdmsk</code></td>
<td>
<p>Vector defining bounds and masks. Default is <code>NULL</code></p>
</td></tr>
<tr><td><code id="jand_+3A_resbest">resbest</code></td>
<td>
<p>If supplied, a vector of the residuals at the parameters
<code>pars</code> to save re-evaluation.</p>
</td></tr>
<tr><td><code id="jand_+3A_ndstep">ndstep</code></td>
<td>
<p>A tolerance used to alter parameters to compute numerical
approximations to derivatives. Default <code>1e-7</code>.</p>
</td></tr>
<tr><td><code id="jand_+3A_...">...</code></td>
<td>
<p>Extra information needed to compute the residuals</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>J C Nash 2014-7-16   nashjc _at_ uottawa.ca
</p>

<hr>
<h2 id='model2rjfun'>model2rjfun</h2><span id='topic+model2rjfun'></span><span id='topic+model2ssgrfun'></span><span id='topic+modelexpr'></span><span id='topic+SSmod2rjfun'></span>

<h3>Description</h3>

<p>These functions create functions to evaluate residuals or sums of squares at 
particular parameter locations.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>model2rjfun(modelformula, pvec, data = NULL, jacobian = TRUE, testresult = TRUE, ...)
SSmod2rjfun(modelformula, pvec, data = NULL, jacobian = TRUE, testresult = TRUE, ...)
model2ssgrfun(modelformula, pvec, data = NULL, gradient = TRUE, 
              testresult = TRUE, ...)
modelexpr(fun)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="model2rjfun_+3A_modelformula">modelformula</code></td>
<td>
<p>A formula describing a nonlinear regression model.</p>
</td></tr>
<tr><td><code id="model2rjfun_+3A_pvec">pvec</code></td>
<td>
<p>A vector of parameters.</p>
</td></tr>
<tr><td><code id="model2rjfun_+3A_data">data</code></td>
<td>
<p>A dataframe, list or environment holding data used in the calculation.</p>
</td></tr>
<tr><td><code id="model2rjfun_+3A_jacobian">jacobian</code></td>
<td>
<p>Whether to compute the Jacobian matrix.</p>
</td></tr>
<tr><td><code id="model2rjfun_+3A_testresult">testresult</code></td>
<td>
<p>Whether to test the function by evaluating it at <code>pvec</code>.</p>
</td></tr>
<tr><td><code id="model2rjfun_+3A_gradient">gradient</code></td>
<td>
<p>Whether to compute the gradient vector.</p>
</td></tr>
<tr><td><code id="model2rjfun_+3A_fun">fun</code></td>
<td>
<p>A function produced by one of <code>model2rjfun</code> or <code>model2ssgrfun</code>.</p>
</td></tr>
<tr><td><code id="model2rjfun_+3A_...">...</code></td>
<td>
<p>Dot arguments, that is, arguments that may be supplied by <code>name = value</code>
to supply information needed to compute specific quantities in the model.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If <code>pvec</code> does not have names, the parameters will have names
generated in the form &lsquo;<span class="samp">&#8288;p_&lt;n&gt;&#8288;</span>&rsquo;, e.g. <code>p_1, p_2</code>.  Names that appear in
<code>pvec</code> will be taken to be parameters of the model.  
</p>
<p>The <code>data</code> argument may be a dataframe, list or environment, or <code>NULL</code>.
If it is not an environment, one will be constructed using the components
of <code>data</code> with parent environment set to be
the environment of <code>modelformula</code>.  
</p>
<p><code>SSmod2rjfun</code> returns a function with header <code>function(prm)</code>, which
evaluates the residuals (and if <code>jacobian</code> is <code>TRUE</code> the
Jacobian matrix) of the selfStart model (the rhs is used) at <code>prm</code>.  
The residuals are defined to be the right hand side of <code>modelformula</code> 
minus the left hand side. Note that the selfStart model used in the model
formula must be available (i.e., loaded). If this function is called from 
<code>nlxb()</code> then the <code>control</code> element <code>japprox</code> must be 
set to value <code>SSJac</code>. 
</p>


<h3>Value</h3>

<p><code>model2rjfun</code> returns a function with header <code>function(prm)</code>, which
evaluates the residuals (and if <code>jacobian</code> is <code>TRUE</code> the
Jacobian matrix) of the model at <code>prm</code>.  The residuals are defined to be
the right hand side of <code>modelformula</code> minus the left hand side.
</p>
<p><code>model2ssgrfun</code> returns a function with header <code>function(prm)</code>, which
evaluates the sum of squared residuals (and if <code>gradient</code> is <code>TRUE</code> the
gradient vector) of the model at <code>prm</code>. 
</p>
<p><code>modelexpr</code> returns the expression used to calculate the vector of 
residuals (and possibly the Jacobian) used in the previous functions.
</p>


<h3>Author(s)</h3>

<p>John Nash and Duncan Murdoch
</p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+nls">nls</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># We do not appear to have an example for modelexpr. See nlsr-devdoc.Rmd for one.

y &lt;- c(5.308, 7.24, 9.638, 12.866, 17.069, 23.192, 31.443, 38.558,
       50.156, 62.948, 75.995, 91.972)

tt &lt;- seq_along(y)  # for testing

mydata &lt;- data.frame(y = y, tt = tt)
f &lt;- y ~ b1/(1 + b2 * exp(-1 * b3 * tt))
p &lt;- c(b1 = 1, b2 = 1, b3 = 1)
rjfn &lt;- model2rjfun(f, p, data = mydata)
rjfn(p)
rjfnnoj &lt;- model2rjfun(f, p, data = mydata, jacobian=FALSE)
rjfnnoj(p)

myexp &lt;- modelexpr(rjfn)
cat("myexp:"); print(myexp)

ssgrfn &lt;- model2ssgrfun(f, p, data = mydata)
ssgrfn(p)

ssgrfnnoj &lt;- model2ssgrfun(f, p, data = mydata, gradient=FALSE)
ssgrfnnoj(p)
</code></pre>

<hr>
<h2 id='newDeriv'>newDeriv</h2><span id='topic+newDeriv'></span>

<h3>Description</h3>

<p>Define a new derivative expression.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>newDeriv (expr, deriv, derivEnv = sysDerivs)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="newDeriv_+3A_expr">expr</code></td>
<td>
<p>An expression represented as a quoted expression.</p>
</td></tr>
<tr><td><code id="newDeriv_+3A_deriv">deriv</code></td>
<td>
<p>The derivative.  See Details below. </p>
</td></tr>
<tr><td><code id="newDeriv_+3A_derivenv">derivEnv</code></td>
<td>
<p>The environment in which to store the setting.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Both <code>expr</code> and <code>deriv</code> are treated
as unevaluated expressions.
</p>
<p><code>deriv</code> should include the sum of derivatives with respect to
all variables similar to a &ldquo;total derivative&rdquo; using
<code><a href="stats.html#topic+D">D</a></code> for the differential.  See the examples
below.
</p>
<p>This is mainly intended for internal use.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>newDeriv(sin(x), cos(x)*D(x))
newDeriv(x*y, x*D(y) + D(x)*y)

nlsDeriv(quote(sin(x)*sin(y)), "x")
</code></pre>

<hr>
<h2 id='newSimplification'>newSimplification</h2><span id='topic+newSimplification'></span>

<h3>Description</h3>

<p>Define a new simplification expression
</p>


<h3>Usage</h3>

<pre><code class='language-R'>newSimplification(expr, test, simplification, do_eval = FALSE, 
                       simpEnv = sysSimplifications)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="newSimplification_+3A_expr">expr</code></td>
<td>
<p>An expression to simplify.</p>
</td></tr>
<tr><td><code id="newSimplification_+3A_test">test</code></td>
<td>
<p>An expression to evaluate whether the simplification
should be applied to <code>expr</code>.</p>
</td></tr>
<tr><td><code id="newSimplification_+3A_simplification">simplification</code></td>
<td>
<p>An equivalent but simpler version of the expression.</p>
</td></tr>
<tr><td><code id="newSimplification_+3A_do_eval">do_eval</code></td>
<td>
<p>Whether the simplification should be evaluated
or stored as-is.</p>
</td></tr>
<tr><td><code id="newSimplification_+3A_simpenv">simpEnv</code></td>
<td>
<p>The environment in which the simplification is stored.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>If <code>expr</code> is missing, list all the functions with known 
simplifications.
</p>
<p>If <code>test</code> is missing, list all the known simplifications for
<code>expr</code>.
</p>
<p>Otherwise, add the new simplification to the list of possible simplifications.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># The unary + operation can always be safely removed:
newSimplification(+a, TRUE, a)

# The unary - operation can be absorbed into numeric values:
newSimplification(-a, is.numeric(a), -a, do_eval = TRUE)

# Adding zero to anything can be skipped:
newSimplification(a + b, isZERO(b), a)
</code></pre>

<hr>
<h2 id='nlfb'>nlfb: nonlinear least squares modeling by functions</h2><span id='topic+nlfb'></span>

<h3>Description</h3>

<p>A simplified and hopefully robust alternative to finding
the nonlinear least squares minimizer that causes
'formula' to give a minimal residual sum of squares.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>nlfb(
  start,
  resfn,
  jacfn = NULL,
  trace = FALSE,
  lower = -Inf,
  upper = Inf,
  weights = NULL,
  data = NULL,
  ctrlcopy = FALSE,
  control = list(),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="nlfb_+3A_start">start</code></td>
<td>
<p>a numeric vector with all elements present
e.g., start=c(b1=200, b2=50, b3=0.3) 
The start vector for this <code>nlfb</code>, unlike <code>nlxb</code>, does
not need to be named.</p>
</td></tr>
<tr><td><code id="nlfb_+3A_resfn">resfn</code></td>
<td>
<p>A function that evaluates the residual vector for 
computing the elements of the sum of squares function at the set of 
parameters <code>start</code>. Where this function is created by actions on 
a formula or expression in <code>nlxb</code>, this residual vector will be 
created by evaluation of the 'model - data', rather than 
the conventional 'data - model' approach. The sum of squares is the same.</p>
</td></tr>
<tr><td><code id="nlfb_+3A_jacfn">jacfn</code></td>
<td>
<p>A function that evaluates the Jacobian of the sum of squares 
function, that is, the matrix of partial derivatives of the residuals 
with respect to each of the parameters. If NULL (default), uses an 
approximation.
</p>
<p>The Jacobian MUST be returned as the attribute &quot;gradient&quot; of this function,
allowing <code>jacfn</code> to have the same name and be the same code block
as <code>resfn</code>, which may permit some efficiencies of computation.
</p>
</td></tr>
<tr><td><code id="nlfb_+3A_trace">trace</code></td>
<td>
<p>TRUE for console output during execution</p>
</td></tr>
<tr><td><code id="nlfb_+3A_lower">lower</code></td>
<td>
<p>a vector of lower bounds on the parameters. 
If a single number, this will be applied to all. Default <code>-Inf</code>.</p>
</td></tr>
<tr><td><code id="nlfb_+3A_upper">upper</code></td>
<td>
<p>a vector of upper bounds on the parameters. If a single number, 
this will be applied to all parameters. Default <code>Inf</code>.</p>
</td></tr>
<tr><td><code id="nlfb_+3A_weights">weights</code></td>
<td>
<p>A vector of fixed weights or a function producing one.
See the Details below.</p>
</td></tr>
<tr><td><code id="nlfb_+3A_data">data</code></td>
<td>
<p>a data frame of variables used by resfn and jacfn to compute the
required residuals and Jacobian.</p>
</td></tr>
<tr><td><code id="nlfb_+3A_ctrlcopy">ctrlcopy</code></td>
<td>
<p>If TRUE use control supplied as is.
This avoids reprocessing controls.</p>
</td></tr>
<tr><td><code id="nlfb_+3A_control">control</code></td>
<td>
<p>a list of control parameters. See nlsr.control().</p>
</td></tr>
<tr><td><code id="nlfb_+3A_...">...</code></td>
<td>
<p>additional data needed to evaluate the modeling functions</p>
</td></tr>
</table>


<h3>Details</h3>

<p>nlfb is particularly intended to allow for the
resolution of very ill-conditioned or else near
zero-residual problems for which the regular nls()
function is ill-suited. 
</p>
<p>This variant uses a qr solution without forming the sum
of squares and cross products t(J)
</p>
<p>Neither this function nor <code>nlxb</code> have provision for parameter
scaling (as in the <code>parscale</code> control of <code>optim</code> and
package <code>optimx</code>). This would be more tedious than difficult to
introduce, but does not seem to be a priority feature to add.
</p>
<p>The <code>weights</code> argument can be a vector of fixed weights, in which
case the objective function that will be 
minimized is the sum of squares where each residual is multiplied by the 
square root of the corresponding weight. Default <code>NULL</code> implies 
unit weights.  <code>weights</code> may alternatively be a function with header <code>function(parms, resids)</code> to compute such a vector.
</p>


<h3>Value</h3>


<p>A list of the following items: </p>

<dl>
<dt>coefficients</dt><dd><p>A named vector giving the parameter values at
the supposed solution.</p>
</dd>
<dt>ssquares</dt><dd><p>The sum of squared residuals at this set of parameters.</p>
</dd>
<dt>resid</dt><dd><p>The weighted residual vector at the returned parameters.</p>
</dd>
<dt>jacobian</dt><dd><p>The jacobian matrix (partial derivatives of residuals w.r.t.
the parameters) at the returned parameters.</p>
</dd>
<dt>feval</dt><dd><p>The number of residual evaluations (sum of squares
computations) used.</p>
</dd>
<dt>jeval</dt><dd><p>The number of Jacobian evaluations used.</p>
</dd>
<dt>weights0</dt><dd><p>The weights argument as specified.</p>
</dd>
<dt>weights</dt><dd><p>The weights vector at the final fit.</p>
</dd>
</dl>
            



<h3>Author(s)</h3>

<p>J C Nash 2014-7-16   nashjc _at_ uottawa.ca
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(nlsr)
# Scaled Hobbs problem
shobbs.res  &lt;-  function(x){ # scaled Hobbs weeds problem -- residual
  # This variant uses looping
  if(length(x) != 3) stop("shobbs.res -- parameter vector n!=3")
  y  &lt;-  c(5.308, 7.24, 9.638, 12.866, 17.069, 23.192, 31.443,
           38.558, 50.156, 62.948, 75.995, 91.972)
  tt  &lt;-  1:12
  res  &lt;-  100.0*x[1]/(1+x[2]*10.*exp(-0.1*x[3]*tt)) - y
}
shobbs.jac  &lt;-  function(x) { # scaled Hobbs weeds problem -- Jacobian
  jj  &lt;-  matrix(0.0, 12, 3)
  tt  &lt;-  1:12
  yy  &lt;-  exp(-0.1*x[3]*tt)
  zz  &lt;-  100.0/(1+10.*x[2]*yy)
  jj[tt,1]   &lt;-   zz
  jj[tt,2]   &lt;-   -0.1*x[1]*zz*zz*yy
  jj[tt,3]   &lt;-   0.01*x[1]*zz*zz*yy*x[2]*tt
  attr(jj, "gradient") &lt;- jj
  jj
}
st &lt;- c(b1=2, b2=1, b3=1) # a default starting vector (named!)
# Default controls, standard Nash-Marquardt algorithm
anlf0 &lt;- nlfb(start=st, resfn=shobbs.res, jacfn=shobbs.jac,
               trace=TRUE, control=list(prtlvl=1))
anlf0

# Hartley with step reduction factor of .2
anlf0h &lt;- nlfb(start=st, resfn=shobbs.res, jacfn=shobbs.jac,
              trace=TRUE, control=list(prtlvl=1, lamda=0, laminc=1.0,
              lamdec=1.0, phi=0, stepredn=0.2))
anlf0h

anlf1bm &lt;- nlfb(start=st, resfn=shobbs.res, jacfn=shobbs.jac, lower=c(2,0,0),
                upper=c(2,6,3), trace=TRUE, control=list(prtlvl=1))
anlf1bm
cat("backtrack using stepredn=0.2\n")
anlf1bmbt &lt;- nlfb(start=st, resfn=shobbs.res, jacfn=shobbs.jac, lower=c(2,0,0),
                upper=c(2,6,3), trace=TRUE, control=list(stepredn=0.2, prtlvl=1))
anlf1bmbt
## Short output
pshort(anlf1bm)
anlf2bm &lt;- nlfb(start=st, resfn=shobbs.res, jacfn=shobbs.jac, lower=c(2,0,0),
                upper=c(2,6,9), trace=TRUE, control=list(prtlvl=1))
anlf2bm
cat("backtrack using stepredn=0.2\n")

anlf2bmbt &lt;- nlfb(start=st, resfn=shobbs.res, jacfn=shobbs.jac, lower=c(2,0,0),
                upper=c(2,6,9), trace=TRUE, control=list(stepredn=0.2, prtlvl=1))
anlf2bmbt
## Short output
pshort(anlf2bm)
</code></pre>

<hr>
<h2 id='nlsDeriv'>nlsDeriv
Functions to take symbolic derivatives.</h2><span id='topic+nlsDeriv'></span><span id='topic+codeDeriv'></span><span id='topic+fnDeriv'></span>

<h3>Description</h3>

<p>Compute derivatives of simple expressions symbolically, allowing user-specified derivatives.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>nlsDeriv(expr, name, derivEnv = sysDerivs, do_substitute = FALSE, verbose = FALSE, ...)

codeDeriv(expr, namevec, hessian = FALSE, derivEnv = sysDerivs, 
          do_substitute = FALSE, verbose = FALSE, ...)

fnDeriv(expr, namevec, args = all.vars(expr), env = environment(expr), 
          do_substitute = FALSE, verbose = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="nlsDeriv_+3A_expr">expr</code></td>
<td>
<p>An expression represented in a variety of ways. See Details.</p>
</td></tr>
<tr><td><code id="nlsDeriv_+3A_name">name</code></td>
<td>
<p>The name of the variable with respect to which the derivative will be computed.</p>
</td></tr>
<tr><td><code id="nlsDeriv_+3A_derivenv">derivEnv</code></td>
<td>
<p>The environment in which derivatives are stored.</p>
</td></tr>
<tr><td><code id="nlsDeriv_+3A_do_substitute">do_substitute</code></td>
<td>
<p>If <code>TRUE</code>, use <code><a href="base.html#topic+substitute">substitute</a></code> to get the expression passed as
<code>expr</code>, otherwise evaluate it.</p>
</td></tr>
<tr><td><code id="nlsDeriv_+3A_verbose">verbose</code></td>
<td>
<p>If <code>TRUE</code>, then diagnostic output will be printed as derivatives
and simplifications are recognized.</p>
</td></tr>
<tr><td><code id="nlsDeriv_+3A_...">...</code></td>
<td>
<p>Additional parameters which will be passed to <code>codeDeriv</code>
from <code>fnDeriv</code>, and to <code>nlsSimplify</code> from 
<code>nlsDeriv</code> and <code>codeDeriv</code>.</p>
</td></tr>
<tr><td><code id="nlsDeriv_+3A_namevec">namevec</code></td>
<td>
<p>Character vector giving the variable names with respect to 
which the derivatives will be taken.</p>
</td></tr>
<tr><td><code id="nlsDeriv_+3A_hessian">hessian</code></td>
<td>
<p>Logical indicator of whether the 2nd derivatives should also be computed.</p>
</td></tr>
<tr><td><code id="nlsDeriv_+3A_args">args</code></td>
<td>
<p>Desired arguments for the function.  See Details below.</p>
</td></tr>
<tr><td><code id="nlsDeriv_+3A_env">env</code></td>
<td>
<p>The environment to be attached to the created function.
If <code>NULL</code>, the caller's frame is used.</p>
</td></tr>
</table>


<h3>Details</h3>

   
<p>Functions <code>nlsDeriv</code> and <code>codeDeriv</code> are designed as replacements 
for the <span class="pkg">stats</span> package functions <code><a href="stats.html#topic+D">D</a></code> and <code><a href="stats.html#topic+deriv">deriv</a></code>
respectively, though the argument lists do not match exactly.
</p>
<p>The <code>nlsDeriv</code> function computes a symbolic derivative of an expression
or language object.  Known derivatives are stored in
<code>derivEnv</code>; the default <code>sysDerivs</code> contains expressions for
all of the derivatives recognized by <code><a href="stats.html#topic+deriv">deriv</a></code>, but in
addition allows differentiation with respect to any parameter
where it makes sense.  It also allows the derivative of <code>abs</code>
and <code>sign</code>, using an arbitrary choice of 0 at the discontinuities.
</p>
<p>The <code>codeDeriv</code> function computes
an expression for efficient calculation of the expression value together
with its gradient and optionally the Hessian matrix.
</p>
<p>The <code>fnDeriv</code> function wraps the <code>codeDeriv</code> result
in a function.  If the <code>args</code> are given as a character
vector (the default), the arguments will have those names,
with no default values.  Alternatively, a custom argument list with default values can
be created using <code><a href="base.html#topic+alist">alist</a></code>; see the example below.
</p>
<p>The <code>expr</code> argument will be converted to a
language object using <code><a href="#topic+dex">dex</a></code> (but note
the different default for <code>do_substitute</code>).  
Normally it should be a formula with no left
hand side, e.g. <code> ~ x^2 </code>, or an expression vector
e.g. <code> expression(x, x^2, x^3) </code>, or a language
object e.g. <code>quote(x^2)</code>.  In <code>codeDeriv</code> and
<code>fnDeriv</code> the expression vector must be of length 1.
</p>
<p>The <code>newDeriv</code> function is used to define a new derivative.
The <code>expr</code> argument should match the header of the function as a
call to it (e.g. as in the help pages), and the <code>deriv</code> argument
should be an expression giving the derivative, including calls to
<code>D(arg)</code>, which will not be evaluated, but will be substituted
with partial derivatives of that argument with respect to <code>name</code>.
See the examples below.  
</p>
<p>If <code>expr</code> or <code>deriv</code> is missing in a call to
<code>newDeriv()</code>, it will return the currently saved derivative
record from <code>derivEnv</code>.  If <code>name</code> is missing in a call to
<code>nlsDeriv</code> with a function call, it will print a message describing
the derivative formula and return <code>NULL</code>.
</p>
<p>To handle functions which act differently if a parameter is
missing, code the default value of that parameter to <code>.MissingVal</code>,
and give a derivative that is conditional on <code>missing()</code>
applied to that parameter.  See the derivatives of <code>"-"</code> and <code>"+"</code> 
in the file <code>derivs.R</code> for an example.
</p>


<h3>Value</h3>

<p>If <code>expr</code> is an expression vector, <code>nlsDeriv</code> and <code>nlsSimplify</code>
return expression vectors containing the response.  
For formulas or language objects, a language object is returned.
</p>
<p><code>codeDeriv</code> always returns a language object.
</p>
<p><code>fnDeriv</code> returns a closure (i.e. a function).
</p>
<p><code>nlsDeriv</code> returns the symbolic derivative of the expression.
</p>
<p><code>newDeriv</code> with <code>expr</code> and <code>deriv</code> specified is
called for the side effect of recording the derivative in <code>derivEnv</code>.
If <code>expr</code> is missing, it will return the list of names of functions
for which derivatives are recorded.  If <code>deriv</code> is missing, it
will return its record for the specified function.
</p>


<h3>Note</h3>

<p><code>newDeriv(expr, deriv, ...)</code> will issue a warning
if a different definition for the derivative exists
in the derivative table.
</p>


<h3>Author(s)</h3>

<p>Duncan Murdoch
</p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+deriv">deriv</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'> nlsDeriv(~ sin(x+y), "x")

 f &lt;- function(x) x^2
 newDeriv(f(x), 2*x*D(x))
 nlsDeriv(~ f(abs(x)), "x")
 
 nlsDeriv(~ pnorm(x, sd=2, log = TRUE), "x")
 fnDeriv(~ pnorm(x, sd = sd, log = TRUE), "x")
 f &lt;- fnDeriv(~ pnorm(x, sd = sd, log = TRUE), "x", args = alist(x =, sd = 2))
 f
 f(1)
 100*(f(1.01) - f(1))  # Should be close to the gradient
 
       # The attached gradient attribute (from f(1.01)) is
       # meaningless after the subtraction.
       
 # Multiple point example
 xvals &lt;- c(1, 3, 4.123)
 print(f(xvals))
 # Getting a hessian matrix
 f2 &lt;- ~ (x-2)^3*y - y^2
 mydf2 &lt;- fnDeriv(f2, c("x","y"), hessian=TRUE)
 # display the resulting function
 print(mydf2)
 x &lt;- c(1, 2)
 y &lt;- c(0.5, 0.1)
 evalmydf2 &lt;- mydf2(x, y)
 print(evalmydf2)
 # the first index of the hessian attribute is the point at which we want the hessian
 hmat1 &lt;- as.matrix(attr(evalmydf2,"hessian")[1,,])
 print(hmat1)
 hmat2 &lt;- as.matrix(attr(evalmydf2,"hessian")[2,,])
 print(hmat2)
</code></pre>

<hr>
<h2 id='nlsr'>nlsr function</h2><span id='topic+nlsr'></span>

<h3>Description</h3>

<p>Provides class nls solution to a nonlinear least squares solution
using the Nash Marquardt tools.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  nlsr(formula = NULL,  data = NULL,  start = NULL,  control = NULL,
    trace = FALSE, subset = NULL, lower = -Inf, upper = Inf,  weights = NULL,
    ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="nlsr_+3A_formula">formula</code></td>
<td>
<p>The modeling formula. Looks like 'y~b1/(1+b2*exp(-b3*T))'</p>
</td></tr>
<tr><td><code id="nlsr_+3A_data">data</code></td>
<td>
<p>a data frame containing data for variables
used in the formula that are NOT the parameters. This
data may also be defined in the parent frame i.e.,
'global' to this function</p>
</td></tr>
<tr><td><code id="nlsr_+3A_start">start</code></td>
<td>
<p>MUST be a named vector with all elements present
e.g., start=c(b1=200, b2=50, b3=0.3)</p>
</td></tr>
<tr><td><code id="nlsr_+3A_control">control</code></td>
<td>
<p>a list of control parameters. See nlsr.control().</p>
</td></tr>
<tr><td><code id="nlsr_+3A_trace">trace</code></td>
<td>
<p>TRUE for console output during execution (default FALSE)</p>
</td></tr>
<tr><td><code id="nlsr_+3A_subset">subset</code></td>
<td>
<p>an optional vector specifying a subset of observations
to be used in the fitting process. NOT used currently by nlxb()
or nlfb() and will throw an error if present and not NULL.</p>
</td></tr>
<tr><td><code id="nlsr_+3A_lower">lower</code></td>
<td>
<p>a vector of lower bounds on the parameters.
If a single number, this will be applied to all parameters
Default <code>-Inf</code>.</p>
</td></tr>
<tr><td><code id="nlsr_+3A_upper">upper</code></td>
<td>
<p>a vector of upper bounds on the parameters. If a single number,
this will be applied to all parameters. Default <code>Inf</code>.</p>
</td></tr>
<tr><td><code id="nlsr_+3A_weights">weights</code></td>
<td>
<p>A vector of fixed weights. The objective function that will be
minimized is the sum of squares where each residual is multiplied by the
square root of the corresponding weight. Default <code>NULL</code> implies
unit weights.</p>
</td></tr>
<tr><td><code id="nlsr_+3A_...">...</code></td>
<td>
<p>additional data needed to evaluate the modeling functions</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A solution object of type <code>nls</code>
</p>

<hr>
<h2 id='nlsr.control'>nlsr.control</h2><span id='topic+nlsr.control'></span>

<h3>Description</h3>

<p>Set and provide defaults of controls for package <code>nlsr</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>nlsr.control(control)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="nlsr.control_+3A_control">control</code></td>
<td>
<p>A list of controls. 
If missing, the defaults are provided. See below.
If a named control is provided,  e.g., via a call
ctrllist&lt;- nlsr.control(japprox=&quot;jand&quot;), then
that value is substituted for the default of the control
in the FULL list of controls that is returned.
</p>
<p>NOTE: at 2022-6-17 there is NO CHECK FOR VALIDITY
</p>
<p>The set of possible controls to set is as follows, and is returned.</p>
</td></tr>
</table>


<h3>Value</h3>

<table role = "presentation">
<tr><td><code>femax</code></td>
<td>
<p>INTEGER limit on the number of evaluations of residual function
Default  10000.</p>
</td></tr>
<tr><td><code>japprox</code></td>
<td>
<p>CHARACTER name of the Jacobian approximation to use
Default NULL, since we try to use analytic gradient</p>
</td></tr>
<tr><td><code>jemax</code></td>
<td>
<p>INTEGER limit on the number of evaluations of the Jacobian
Default 5000</p>
</td></tr>
<tr><td><code>lamda</code></td>
<td>
<p>REAL initial value of the Marquardt parameter
Default 0.0001 
Note: mis-spelling as in JNMWS, kept as historical serendipity.</p>
</td></tr>
<tr><td><code>lamdec</code></td>
<td>
<p> REAL multiplier used to REDUCE <code>lambda</code> (0 &lt; <code>lamdec</code> &lt; <code>laminc</code>)
Default 4, so <code>lamda &lt;- lamda * (lamdec/laminc)</code> </p>
</td></tr>
<tr><td><code>laminc</code></td>
<td>
<p> REAL multiplier to INCREASE <code>lambda</code> (1 &lt; <code>laminc</code>
Default 10</p>
</td></tr>
<tr><td><code>nbtlim</code></td>
<td>
<p> if stepredn &gt; 0, then maximum number of backtrack loops
(in addition to default evaluation); Default 6</p>
</td></tr>
<tr><td><code>ndstep</code></td>
<td>
<p> REAL  stepsize for numerical Jacobian approximation
Default 1e-7</p>
</td></tr>
<tr><td><code>offset</code></td>
<td>
<p> REAL A value used to test for numerical equality, i.e. <code>a</code> and
<code>b</code> are taken equal if <code>(a + offset) == (b + offset)</code>
Default 100.</p>
</td></tr>
<tr><td><code>phi</code></td>
<td>
<p>REAL Factor used to add unit Marquardt stabilization matrix in Nash
modification of LM method.  Default 1</p>
</td></tr>
<tr><td><code>prtlvl</code></td>
<td>
<p> INTEGER The higher the value, the more intermediate output is provided.
Default 0</p>
</td></tr>
<tr><td><code>psi</code></td>
<td>
<p>REAL Factor used to add scaled Marquardt stabilization matrix in Nash
modification of LM method.  Default 0</p>
</td></tr> 
<tr><td><code>rofftest</code></td>
<td>
<p> LOGICAL If TRUE, perform (safeguarded) relative offset convergence test
Default TRUE</p>
</td></tr>
<tr><td><code>scaleOffset</code></td>
<td>
<p> a positive constant to be added to the denominator sum-of-squares in
the relative offset convergence criteria. Default 0</p>
</td></tr>
<tr><td><code>smallsstest</code></td>
<td>
<p> LOGICAL. If TRUE tests sum of squares and terminates if very small.
Default TRUE</p>
</td></tr>
<tr><td><code>stepredn</code></td>
<td>
<p>REAL Factor used to reduce the stepsize in a Gauss-Newton algorithm (Hartley's
method). 0 means NO backtrack. Default 0</p>
</td></tr>
<tr><td><code>watch</code></td>
<td>
<p>LOGICAL to provide a pause at the end of each iteration for user to monitor
progress.   Default FALSE</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>J C Nash 2014-7-16 revised 2022-11-22   nashjc _at_ uottawa.ca
</p>

<hr>
<h2 id='nlsr.package'>nlsr-package
Tools for solving nonlinear least squares problems
The package provides some tools related to using the Nash variant
of Marquardt's algorithm for nonlinear least squares. Jacobians can
usually be developed by automatic or symbolic derivatives.</h2><span id='topic+nlsr.package'></span>

<h3>Description</h3>

<p>nlsr-package
</p>
<p>Tools for solving nonlinear least squares problems
</p>
<p>The package provides some tools related to using the Nash variant
of Marquardt's algorithm for nonlinear least squares. Jacobians can
usually be developed by automatic or symbolic derivatives.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>nlsr.package()
</code></pre>


<h3>Details</h3>

<p>This package includes methods for solving nonlinear least squares problems
specified by a modeling expression and given a starting vector of named 
paramters. Note: You must provide an expression of the form
lhs ~ rhsexpression
so that the residual expression 
rhsexpression - lhs
can be computed. The expression can be enclosed in quotes, and this seems to give
fewer difficulties with R. Data variables must already be defined, either within 
the parent environment or else in the dot-arguments. Other symbolic elements in
the modeling expression must be standard functions or else parameters that are 
named in the start vector.
</p>
<p>The main functions in <code>nlsr</code> are:
</p>
<p>nlfb   Nash variant of the Marquardt procedure for nonlinear least squares,
with bounds constraints, using a residual and optionally Jacobian
described as <code>R</code> functions.
</p>
<p>nlxb  Nash variant of the Marquardt procedure for nonlinear least squares,
with bounds constraints, using an expression to describe the residual via
an <code>R</code> modeling expression. The Jacobian is computed via symbolic
differentiation.
</p>
<p>wrapnlsr  Uses <code>nlxb</code> to solve nonlinear least squares then calls 
<code>nls()</code> to create an object of type nls. <code>nlsr</code> is an alias
for <code>wrapnlsr</code>
</p>
<p>model2rjfun  returns a function with header <code>function(prm)</code>, which
evaluates the residuals (and if jacobian is TRUE the Jacobian matrix) 
of the model at <code>prm</code>.  The residuals are defined to be the 
right hand side of <code>modelformula</code> minus the left hand side.
</p>
<p>model2ssgrfun  returns a function with header <code>function(prm)</code>, which
evaluates the sum of squared residuals (and if gradient is <code>TRUE</code> the
gradient vector) of the model at <code>prm</code>.
</p>
<p>modelexpr  returns the expression used to calculate the vector of 
residuals (and possibly the Jacobian) used in the previous functions.
</p>


<h3>Author(s)</h3>

<p>John C Nash and Duncan Murdoch
</p>


<h3>References</h3>

<p>Nash, J. C. (1979, 1990) _Compact Numerical Methods for Computers.
Linear Algebra and Function Minimisation._ Adam Hilger./Institute
of Physics Publications
</p>
<p>Nash, J. C. (2014) _Nonlinear Parameter Optimization Using R Tools._
Wiley
</p>

<hr>
<h2 id='nlsrSS'>nlsrSS - solve selfStart nonlinear least squares with nlsr package</h2><span id='topic+nlsrSS'></span>

<h3>Description</h3>

<p>This function uses the <code>getInitial()</code> function to estimate starting parameters for
a Gauss-Newton iteration, then calls <code>nlsr::nlxb()</code> appropriately to find a solution
to the required nonlinear least squares problem. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>nlsrSS(formula, data)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="nlsrSS_+3A_formula">formula</code></td>
<td>
<p>a model formula incorporating a selfStart function in the right hand side</p>
</td></tr>
<tr><td><code id="nlsrSS_+3A_data">data</code></td>
<td>
<p>a data frame with named columns that allow evaluation of the <code>formula</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>A solution object of class <code>nlsr</code>.
</p>
<p>List of solution elements
</p>
<table role = "presentation">
<tr><td><code>resid</code></td>
<td>
<p>weighted residuals at the proposed solution</p>
</td></tr>
<tr><td><code>jacobian</code></td>
<td>
<p>Jacobian matrix at the proposed solution</p>
</td></tr>
<tr><td><code>feval</code></td>
<td>
<p>residual function evaluations used to reach solution from starting parameters</p>
</td></tr>
<tr><td><code>jeval</code></td>
<td>
<p>Jacobian function (or approximation) evaluations used</p>
</td></tr>
<tr><td><code>coefficients</code></td>
<td>
<p>a named vector of proposed solution parameters</p>
</td></tr>
<tr><td><code>ssquares</code></td>
<td>
<p>weighted sum of squared residuals (often the deviance)</p>
</td></tr>
<tr><td><code>lower</code></td>
<td>
<p>lower bounds on parameters</p>
</td></tr>
<tr><td><code>upper</code></td>
<td>
<p>upper bounds on parameters</p>
</td></tr>
<tr><td><code>maskidx</code></td>
<td>
<p>vector if indices of fixed (masked) parameters</p>
</td></tr>
<tr><td><code>weights</code></td>
<td>
<p>specified weights on observations</p>
</td></tr>
<tr><td><code>formula</code></td>
<td>
<p>the modeling formula</p>
</td></tr>
<tr><td><code>resfn</code></td>
<td>
<p>the residual function (unweighted) based on the formula</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>J C Nash 2022-9-14   nashjc _at_ uottawa.ca</p>

<hr>
<h2 id='nlsSimplify'>nlsSimplify</h2><span id='topic+nlsSimplify'></span>

<h3>Description</h3>

<p>Try to simplify an expression.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>nlsSimplify(expr, simpEnv = sysSimplifications, verbose = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="nlsSimplify_+3A_expr">expr</code></td>
<td>
<p>An expression represented in a variety of ways. See Details.</p>
</td></tr>
<tr><td><code id="nlsSimplify_+3A_simpenv">simpEnv</code></td>
<td>
<p>The environment in which simplifications are stored.</p>
</td></tr>
<tr><td><code id="nlsSimplify_+3A_verbose">verbose</code></td>
<td>
<p>If <code>TRUE</code>, then diagnostic output will be printed as simplifications are recognized.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>expr</code> can be an expression vector or other language object.
If it
is a complex expression (e.g. <code>(a + b) + c</code>), then simplifications
will be applied recursively.  Simplifications are applied 
from the database created by <code><a href="#topic+newSimplification">newSimplification</a></code>,
and the new expression (or call...) is returned.
</p>
<p>This function is mainly for internal use by <code><a href="#topic+nlsDeriv">nlsDeriv</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>nlsSimplify(quote(x + 0 + y*1), verbose = TRUE)
</code></pre>

<hr>
<h2 id='nlxb'>nlxb: nonlinear least squares modeling by formula</h2><span id='topic+nlxb'></span>

<h3>Description</h3>

<p>A simplified and hopefully robust alternative to finding
the nonlinear least squares minimizer that causes
'formula' to give a minimal residual sum of squares.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>nlxb(
  formula,
  data = parent.frame(),
  start,
  trace = FALSE,
  lower = NULL,
  upper = NULL,
  weights = NULL,
  control = list(),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="nlxb_+3A_formula">formula</code></td>
<td>
<p>The modeling formula. Looks like 'y~b1/(1+b2*exp(-b3*T))'</p>
</td></tr>
<tr><td><code id="nlxb_+3A_data">data</code></td>
<td>
<p>a data frame containing data for variables
used in the formula that are NOT the parameters. This
data may also be defined in the parent frame i.e.,
'global' to this function</p>
</td></tr>
<tr><td><code id="nlxb_+3A_start">start</code></td>
<td>
<p>MUST be a named vector with all elements present
e.g., start=c(b1=200, b2=50, b3=0.3)</p>
</td></tr>
<tr><td><code id="nlxb_+3A_trace">trace</code></td>
<td>
<p>TRUE for console output during execution</p>
</td></tr>
<tr><td><code id="nlxb_+3A_lower">lower</code></td>
<td>
<p>a vector of lower bounds on the parameters. 
If a single number, this will be applied to all parameters
Default <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="nlxb_+3A_upper">upper</code></td>
<td>
<p>a vector of upper bounds on the parameters. If a single number, 
this will be applied to all parameters. Default <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="nlxb_+3A_weights">weights</code></td>
<td>
<p>A vector of fixed weights or a function or formula
producing one.  See the Details below.</p>
</td></tr>
<tr><td><code id="nlxb_+3A_control">control</code></td>
<td>
<p>a list of control parameters. See nlsr.control().</p>
</td></tr>
<tr><td><code id="nlxb_+3A_...">...</code></td>
<td>
<p>additional data needed to evaluate the modeling functions</p>
</td></tr>
</table>


<h3>Details</h3>

<p>nlxb is particularly intended to allow for the
resolution of very ill-conditioned or else near
zero-residual problems for which the regular nls()
function is ill-suited. 
</p>
<p>This variant uses a qr solution without forming the sum
of squares and cross products t(J)
</p>
<p>Neither this function nor <code>nlfb</code> have provision for parameter
scaling (as in the <code>parscale</code> control of <code>optim</code> and
package <code>optimx</code>). This would be more tedious than difficult to
introduce, but does not seem to be a priority feature to add.
</p>
<p>There are many controls, and some of them are important for <code>nlxb</code>.
In particular, if the derivatives needed for developing the Jacobian are
NOT in the derivatives table, then we must supply code elsewhere as 
specified by the control <code>japprox</code>. This was originally just for
numerical approximations, with the character strings &quot;jafwd&quot;, &quot;jaback&quot;,
&quot;jacentral&quot; and &quot;jand&quot; leading to the use of a forward, backward, central
or package <code>numDeriv</code> approximation. However, it is also possible to
use code embedded in the residual function created using the <code>formula</code>.
This is particularly useful for <code>selfStart</code> models, and we use the
character string &quot;SSJac&quot; to point to such Jacobian code. Note how the
starting parameter vector is found using the <code>getInitial</code> function
from the <code>stats</code> package as in an example below.
</p>
<p>The <code>weights</code> argument can be a vector of fixed weights, in which
case the objective function that will be 
minimized is the sum of squares where each residual is multiplied by the 
square root of the corresponding weight. Default <code>NULL</code> implies 
unit weights.  
</p>
<p><code>weights</code> may alternatively be a function with header <code>function(parms, resids)</code> to compute such a vector, or a formula
whose right hand side gives an expression for the weights.  Variables
in the expression may include the following:
</p>

<dl>
<dt>A variable named <code>resid</code></dt><dd><p>The current residuals.</p>
</dd>
<dt>A variable named <code>fitted</code></dt><dd><p>The right hand side of the model formula.</p>
</dd>
<dt>Parameters</dt><dd><p>The parameters of the model.</p>
</dd>
<dt>Data</dt><dd><p>Values from <code>data</code>.</p>
</dd>
<dt>Vars</dt><dd><p>Variables in the environment of the formula.</p>
</dd>
</dl>



<h3>Value</h3>

<p>list of solution elements
</p>
<table role = "presentation">
<tr><td><code>resid</code></td>
<td>
<p>weighted residuals at the proposed solution</p>
</td></tr>
<tr><td><code>jacobian</code></td>
<td>
<p>Jacobian matrix at the proposed solution</p>
</td></tr>
<tr><td><code>feval</code></td>
<td>
<p>residual function evaluations used to reach solution from starting parameters</p>
</td></tr>
<tr><td><code>jeval</code></td>
<td>
<p>Jacobian function (or approximation) evaluations used</p>
</td></tr>
<tr><td><code>coefficients</code></td>
<td>
<p>a named vector of proposed solution parameters</p>
</td></tr>
<tr><td><code>ssquares</code></td>
<td>
<p>weighted sum of squared residuals (often the deviance)</p>
</td></tr>
<tr><td><code>lower</code></td>
<td>
<p>lower bounds on parameters</p>
</td></tr>
<tr><td><code>upper</code></td>
<td>
<p>upper bounds on parameters</p>
</td></tr>
<tr><td><code>maskidx</code></td>
<td>
<p>vector if indices of fixed (masked) parameters</p>
</td></tr>
<tr><td><code>weights0</code></td>
<td>
<p>weights specified in function call</p>
</td></tr>
<tr><td><code>weights</code></td>
<td>
<p>weights at the final solution</p>
</td></tr>
<tr><td><code>formula</code></td>
<td>
<p>the modeling formula</p>
</td></tr>
<tr><td><code>resfn</code></td>
<td>
<p>the residual function (unweighted) based on the formula</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>J C Nash 2014-7-16   nashjc _at_ uottawa.ca
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(nlsr)
weed &lt;- c(5.308, 7.24, 9.638, 12.866, 17.069, 23.192, 31.443,
        38.558, 50.156, 62.948, 75.995, 91.972)
tt &lt;- 1:12
weeddf &lt;- data.frame(tt, weed)
frm &lt;- 
wmodu &lt;- weed ~ b1/(1+b2*exp(-b3*tt)) # Unscaled
## nls from unit start FAILS
start1&lt;-c(b1=1, b2=1, b3=1)
hunls1 &lt;- try(nls(wmodu, data=weeddf, start=start1, trace=FALSE))
if (! inherits(hunls1, "try-error")) print(hunls1) ## else cat("Failure -- try-error\n")
## nlxb from unit start
hunlx1 &lt;- try(nlxb(wmodu, data=weeddf, start=c(b1=1, b2=1, b3=1), trace=FALSE))
if (! inherits(hunlx1, "try-error")) print(hunlx1)

st2h&lt;-c(b1=185, b2=10, b3=.3)
#' hunls2 &lt;- try(nls(wmodu, data=weeddf, start=st2h, trace=FALSE))
if (! inherits(hunls1, "try-error")) print(hunls1) ## else cat("Failure -- try-error\n")
## nlxb from unit start
hunlx1 &lt;- try(nlxb(wmodu, data=weeddf, start=st2h, trace=FALSE))
if (! inherits(hunlx1, "try-error")) print(hunlx1)

# Functional models need to use a Jacobian approximation or external calculation.
# For example, the SSlogis() selfStart model from \code{stats} package.

# nls() needs NO starting value
hSSnls&lt;-try(nls(weed~SSlogis(tt, Asym, xmid, scal), data=weeddf))
summary(hSSnls)
# We need to get the start for nlxb explicitly
stSS &lt;- getInitial(weed ~ SSlogis(tt, Asym, xmid, scal), data=weeddf)
hSSnlx&lt;-try(nlxb(weed~SSlogis(tt, Asym, xmid, scal), data=weeddf, start=stSS))
hSSnlx

# nls() can only bound parameters with algorithm="port"
#   and minpack.lm is unreliable in imposing bounds, but nlsr copes fine.
lo&lt;-c(0, 0, 0)
up&lt;-c(190, 10, 2) # Note: start must be admissible.
bnls0&lt;-try(nls(wmodu, data=weeddf, start=st2h,
         lower=lo, upper=up)) # should complain and fail
 
bnls&lt;-try(nls(wmodu, data=weeddf, start=st2h,
         lower=lo, upper=up, algorith="port"))
summary(bnls)
bnlx&lt;-try(nlxb(wmodu, data=weeddf, start=st2h, lower=lo, upper=up))
bnlx

# nlxb() can also MASK (fix) parameters. The mechanism of maskidx from nls
# is NO LONGER USED. Instead we set upper and lower parameters equal for
# the masked parameters. The start value MUST be equal to this fixed value.
lo&lt;-c(190, 0, 0) # mask first parameter
up&lt;-c(190, 10, 2)
strt &lt;- c(b1=190, b2=1, b3=1)
mnlx&lt;-try(nlxb(wmodu, start=strt, data=weeddf, 
         lower=lo, upper=up))
mnlx
mnls&lt;-try(nls(wmodu, data=weeddf, start=strt,
         lower=lo, upper=up, algorith="port"))
summary(mnls)

# Try first parameter masked and see if we get SEs 
lo&lt;-c(200, 0, 0) # mask first parameter
up&lt;-c(100, 10, 5)
strt &lt;- c(b1=200, b2=1, b3=1)
mnlx&lt;-try(nlxb(wmodu, start=strt, data=weeddf, 
         lower=lo, upper=up))
mnlx
mnls&lt;-try(nls(wmodu, data=weeddf, start=strt,
         lower=lo, upper=up, algorith="port"))
summary(mnls) 

# Try with weights on the observations
mnlx&lt;-try(nlxb(wmodu, start=strt, data=weeddf, 
               weights = ~ 1/weed))
mnlx

</code></pre>

<hr>
<h2 id='numericDerivR'>numericDerivR: numerically evaluates the gradient of an expression. All in R</h2><span id='topic+numericDerivR'></span>

<h3>Description</h3>

<p>This version is all in R to replace the C version in package stats
</p>


<h3>Usage</h3>

<pre><code class='language-R'>numericDerivR(
  expr,
  theta,
  rho = parent.frame(),
  dir = 1,
  eps = .Machine$double.eps^(1/if (central) 3 else 2),
  central = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="numericDerivR_+3A_expr">expr</code></td>
<td>
<p>expression or call to be differentiated. Should evaluate to a numeric vector.</p>
</td></tr>
<tr><td><code id="numericDerivR_+3A_theta">theta</code></td>
<td>
<p>character vector of names of numeric variables used in expr.</p>
</td></tr>
<tr><td><code id="numericDerivR_+3A_rho">rho</code></td>
<td>
<p>environment containing all the variables needed to evaluate expr.</p>
</td></tr>
<tr><td><code id="numericDerivR_+3A_dir">dir</code></td>
<td>
<p>numeric vector of directions, typically with values in -1, 1 to use for the finite 
differences; will be recycled to the length of theta.</p>
</td></tr>
<tr><td><code id="numericDerivR_+3A_eps">eps</code></td>
<td>
<p>a positive number, to be used as unit step size hh for the approximate 
numerical derivative (f(x+h)-f(x))/h (f(x+h)-f(x))/h or the central version, see central.</p>
</td></tr>
<tr><td><code id="numericDerivR_+3A_central">central</code></td>
<td>
<p>logical indicating if central divided differences should be computed, 
i.e., (f(x+h) - f(x-h)) / 2h (f(x+h)-f(x-h))/2h. These are typically more accurate but 
need more evaluations of f()f().</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The value of eval(expr, envir = rho) plus a matrix attribute &quot;gradient&quot;. The columns of 
this matrix are the derivatives of the value with respect to the variables listed in theta.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>ex &lt;- expression(a/(1+b*exp(-tt*c)) - weed)
weed &lt;- c(5.308, 7.24, 9.638, 12.866, 17.069, 23.192, 31.443,
              38.558, 50.156, 62.948, 75.995, 91.972)
tt &lt;- 1:12
a &lt;- 200; b &lt;- 50; c &lt;- 0.3
dhobb &lt;- numericDerivR(ex, theta=c("a", "b", "c"))
print(dhobb)
# exf &lt;- ~ a/(1+b*exp(-tt*c)) - weed
# Note that a formula doesn't work
# dh1 &lt;-  try(numericDerivR(exf, theta=c("a", "b", "c")))
</code></pre>

<hr>
<h2 id='nvec'>nvec</h2><span id='topic+nvec'></span>

<h3>Description</h3>

<p>Compact display of a specified named vector
</p>


<h3>Usage</h3>

<pre><code class='language-R'>nvec(vec)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="nvec_+3A_vec">vec</code></td>
<td>
<p>a named vector of parameters</p>
</td></tr>
</table>


<h3>Value</h3>

<p>none (Note that we may want to change this.)
</p>


<h3>Author(s)</h3>

<p>J C Nash 2014-7-16   nashjc _at_ uottawa.ca
</p>

<hr>
<h2 id='pctrl'>pctrl</h2><span id='topic+pctrl'></span>

<h3>Description</h3>

<p>Compact display of specified <code>control</code> vector for
package <code>nlsr</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pctrl(control)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="pctrl_+3A_control">control</code></td>
<td>
<p>a control list</p>
</td></tr>
</table>


<h3>Value</h3>

<p>none
</p>


<h3>Author(s)</h3>

<p>J C Nash 2014-7-16   nashjc _at_ uottawa.ca
</p>

<hr>
<h2 id='pnls'>pnls</h2><span id='topic+pnls'></span>

<h3>Description</h3>

<p>Compact display of specified <code>nls</code> object <code>x</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pnls(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="pnls_+3A_x">x</code></td>
<td>
<p>an nls() result object from nls() or nlsLM()</p>
</td></tr>
</table>


<h3>Value</h3>

<p>none
</p>


<h3>Author(s)</h3>

<p>J C Nash 2014-7-16, 2023-5-8 nashjc _at_ uottawa.ca
</p>

<hr>
<h2 id='pnlslm'>pnlslm</h2><span id='topic+pnlslm'></span>

<h3>Description</h3>

<p>Compact display of specified <code>nls.lm</code> object <code>x</code>.
This code returns the iteration count in a different variable
from that of <code>nls</code> objects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pnlslm(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="pnlslm_+3A_x">x</code></td>
<td>
<p>an nls() result object from minpack.lm::nls.lm()</p>
</td></tr>
</table>


<h3>Value</h3>

<p>none
</p>


<h3>Author(s)</h3>

<p>J C Nash 2014-7-16, 2023-5-8 nashjc _at_ uottawa.ca
</p>

<hr>
<h2 id='predict.nlsr'>predict.nlsr</h2><span id='topic+predict.nlsr'></span>

<h3>Description</h3>

<p>prepare and display predictions from an <code>nlsr</code> model
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'nlsr'
predict(object = NULL, newdata = list(), ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="predict.nlsr_+3A_object">object</code></td>
<td>
<p>an object of class <code>nlsr</code></p>
</td></tr>
<tr><td><code id="predict.nlsr_+3A_newdata">newdata</code></td>
<td>
<p>a dataframe containing columns that match the original dataframe
used to estimate the nonlinear model in the <code>nlsr</code> object</p>
</td></tr>
<tr><td><code id="predict.nlsr_+3A_...">...</code></td>
<td>
<p>additional data needed to evaluate the modeling functions
Default FALSE</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>J C Nash 2014-7-16   nashjc _at_ uottawa.ca
</p>

<hr>
<h2 id='print.nlsr'>print.nlsr</h2><span id='topic+print.nlsr'></span>

<h3>Description</h3>

<p>prepare and display result of <code>nlsr</code> computations
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'nlsr'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="print.nlsr_+3A_x">x</code></td>
<td>
<p>an object of class <code>nlsr</code></p>
</td></tr>
<tr><td><code id="print.nlsr_+3A_...">...</code></td>
<td>
<p>additional data needed to evaluate the modeling functions
Default FALSE</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The set of possible controls to set is as follows
</p>


<h3>Author(s)</h3>

<p>J C Nash 2014-7-16   nashjc _at_ uottawa.ca
</p>

<hr>
<h2 id='prt'>prt</h2><span id='topic+prt'></span>

<h3>Description</h3>

<p>To display the calling name of <code>x</code> and print
the object with the print.nlsr() function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>prt(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="prt_+3A_x">x</code></td>
<td>
<p>an object of class <code>nlsr</code></p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>J C Nash 2022-11-22   nashjc _at_ uottawa.ca
</p>

<hr>
<h2 id='pshort'>pshort</h2><span id='topic+pshort'></span>

<h3>Description</h3>

<p>To provide a 1-line summary of an object of class <code>nlsr</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pshort(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="pshort_+3A_x">x</code></td>
<td>
<p>an object of class <code>nlsr</code></p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>J C Nash 2022-11-22   nashjc _at_ uottawa.ca
</p>

<hr>
<h2 id='rawres'>rawres</h2><span id='topic+rawres'></span>

<h3>Description</h3>

<p>Prepare and display raw residuals of <code>nlsr</code> computations
NOTE: we use model - data form i.e., rhs - lhs
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rawres(object = NULL, data = parent.frame(), ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="rawres_+3A_object">object</code></td>
<td>
<p>an object of class <code>nlsr</code></p>
</td></tr>
<tr><td><code id="rawres_+3A_data">data</code></td>
<td>
<p>a data frame with the data for which fits are wanted</p>
</td></tr>
<tr><td><code id="rawres_+3A_...">...</code></td>
<td>
<p>additional data needed to evaluate the modeling functions</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector of the raw residuals
</p>


<h3>Author(s)</h3>

<p>J C Nash 2014-7-16 revised 2022-11-22   nashjc _at_ uottawa.ca
</p>

<hr>
<h2 id='resgr'>resgr</h2><span id='topic+resgr'></span>

<h3>Description</h3>

<p>Computes the gradient of the sum of squares function for nonlinear least
squares where <code>resfn</code> and <code>jacfn</code> supply the residuals and Jacobian
</p>


<h3>Usage</h3>

<pre><code class='language-R'>resgr(prm, resfn, jacfn, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="resgr_+3A_prm">prm</code></td>
<td>
<p>a numeric vector of parameters to the model</p>
</td></tr>
<tr><td><code id="resgr_+3A_resfn">resfn</code></td>
<td>
<p>a function to compute a vector of residuals</p>
</td></tr>
<tr><td><code id="resgr_+3A_jacfn">jacfn</code></td>
<td>
<p>a function to compute the Jacobian of the sum of squares. If
the value is quoted, then the function is assumed to be a numerical
approximation. Currently one of <code>"jafwd"</code>, <code>"jaback"</code>, 
<code>"jacentral"</code>, or  <code>"jand"</code>.</p>
</td></tr>
<tr><td><code id="resgr_+3A_...">...</code></td>
<td>
<p>Extra information needed to compute the residuals</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Does NOT (yet) handle calling of code built into selfStart models. That
is, codes that in <code>nlxb</code> employ control <code>japprox="SSJac"</code>.
</p>


<h3>Value</h3>

<p>The main object returned is the numeric vector of residuals computed at <code>prm</code>
by means of the function <code>resfn</code>. 
There are <code>Jacobian</code> and <code>gradient</code> attributes giving the Jacobian
(matrix of 1st partial derivatives whose row i contains the partial derivative
of the i'th residual w.r.t. each of the parameters) and the gradient of the
sum of squared residuals w.r.t. each of the parameters. Moreover, the Jacobian
is repeated within the <code>gradient</code> attribute of the Jacobian. This somewhat
bizarre structure is present for compatibility with <code>nls()</code> and some other
legacy functions, as well as to simplify the call to <code>nlfb()</code>.
</p>


<h3>Author(s)</h3>

<p>J C Nash 2014-7-16 revised 2022-11-22   nashjc _at_ uottawa.ca
</p>

<hr>
<h2 id='resid.nlsr'>resid.nlsr</h2><span id='topic+resid.nlsr'></span>

<h3>Description</h3>

<p>prepare and display result of <code>nlsr</code> computations
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'nlsr'
resid(object, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="resid.nlsr_+3A_object">object</code></td>
<td>
<p>an object of class <code>nlsr</code></p>
</td></tr>
<tr><td><code id="resid.nlsr_+3A_...">...</code></td>
<td>
<p>additional data needed to evaluate the modeling functions</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>J C Nash nashjc _at_ uottawa.ca
</p>
<p>### remove _at_export to try to overcome NAMESPACE issue
</p>

<hr>
<h2 id='residuals.nlsr'>residuals.nlsr</h2><span id='topic+residuals.nlsr'></span>

<h3>Description</h3>

<p>prepare and display result of <code>nlsr</code> computations
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'nlsr'
residuals(object, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="residuals.nlsr_+3A_object">object</code></td>
<td>
<p>an object of class <code>nlsr</code></p>
</td></tr>
<tr><td><code id="residuals.nlsr_+3A_...">...</code></td>
<td>
<p>additional data needed to evaluate the modeling functions</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>J C Nash nashjc _at_ uottawa.ca
</p>

<hr>
<h2 id='resss'>resss</h2><span id='topic+resss'></span>

<h3>Description</h3>

<p>compute the sum of squares from <code>resfn</code> at parameters <code>prm</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>resss(prm, resfn, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="resss_+3A_prm">prm</code></td>
<td>
<p>a named numeric vector of parameters to the model</p>
</td></tr>
<tr><td><code id="resss_+3A_resfn">resfn</code></td>
<td>
<p>a function to compute a vector of residuals</p>
</td></tr>
<tr><td><code id="resss_+3A_...">...</code></td>
<td>
<p>Extra information needed to compute the residuals</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>J C Nash 2014-7-16   nashjc _at_ uottawa.ca
</p>

<hr>
<h2 id='SSlogisJN'>Alternative self start for three-parameter logistic function SSlogis</h2><span id='topic+SSlogisJN'></span>

<h3>Description</h3>

<p>Self starter for a 3-parameter logistic function.
</p>
<p>The equation for this function is:
</p>
<p style="text-align: center;"><code class="reqn">f(input) = Asym/(1 + exp((xmid - input)/scal))</code>
</p>

<p>The approach of the function SSlogis() in base R uses a different
algorithm and returns the actual solution rather than starting
parameters, so runs a complete set of iterations, only to try to
repeat from the solution with the standard algorithm.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>SSlogisJN(input, Asym, xmid, scal)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="SSlogisJN_+3A_input">input</code></td>
<td>
<p>input vector (input)</p>
</td></tr>
<tr><td><code id="SSlogisJN_+3A_asym">Asym</code></td>
<td>
<p>asymptotic value for large values of x</p>
</td></tr>
<tr><td><code id="SSlogisJN_+3A_xmid">xmid</code></td>
<td>
<p>a numeric parameter representing the x value at the inflection point of 
the curve. The value of SSlogisJN will be Asym/2 at xmid.</p>
</td></tr>
<tr><td><code id="SSlogisJN_+3A_scal">scal</code></td>
<td>
<p>numeric scale parameter on the input axis</p>
</td></tr>
</table>


<h3>References</h3>

<p>Ratkowsky, David A. (1983) Nonlinear Regression Modeling, A Unified
Practical Approach, Dekker: New York, section 8.3.2
</p>


<h3>Examples</h3>

<pre><code class='language-R'>{
## require(ggplot2)
require(nlsr)
set.seed(1234)
x &lt;- seq(0, 20, .2)
y &lt;- SSlogisJN(x, 5, 10, .5) + rnorm(length(x), 0, 0.15)
frm&lt;-y ~ SSlogisJN(x, Asym, xmid, scal)
dat &lt;- data.frame(x = x, y = y)
strt&lt;-getInitial(frm, dat)
cat("Proposed start:\n"); print(strt)
fit &lt;- nlxb(frm, strt, data = dat, control=list(japprox="SSJac"))
print(fit)
## plot
## ggplot(data = dat, aes(x = x, y = y)) + 
##   geom_point() + 
##  geom_line(aes(y = fitted(fit)))
}
</code></pre>

<hr>
<h2 id='summary.nlsr'>summary.nlsr</h2><span id='topic+summary.nlsr'></span>

<h3>Description</h3>

<p>prepare display result of <code>nlsr</code> computations - NOT compact output
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'nlsr'
summary(object, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="summary.nlsr_+3A_object">object</code></td>
<td>
<p>an object of class <code>nlsr</code></p>
</td></tr>
<tr><td><code id="summary.nlsr_+3A_...">...</code></td>
<td>
<p>additional data needed to evaluate the modeling functions</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The set of possible controls to set is as follows
</p>


<h3>Author(s)</h3>

<p>J C Nash 2014-7-16   nashjc _at_ uottawa.ca
</p>

<hr>
<h2 id='sysDerivs'>Internal Environments</h2><span id='topic+sysDerivs'></span><span id='topic+sysSimplifications'></span>

<h3>Description</h3>

<p>These are the default collection of derivatives and 
simplifications used internally by
<code><a href="#topic+nlsDeriv">nlsDeriv</a></code> and <code><a href="#topic+nlsSimplify">nlsSimplify</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sysDerivs
sysSimplifications
</code></pre>


<h3>Format</h3>

<p><code>environment</code>s holding derivatives and simplification rules.
</p>

<hr>
<h2 id='wrapnlsr'>wrapnlsr</h2><span id='topic+wrapnlsr'></span>

<h3>Description</h3>

<p>Provides class nls solution to a nonlinear least squares solution 
using the Nash Marquardt tools.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>wrapnlsr(formula = NULL,  data = NULL,  start = NULL,  control = NULL,
    trace = FALSE, subset = NULL, lower = -Inf, upper = Inf,  weights = NULL,
    ...)                           
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="wrapnlsr_+3A_formula">formula</code></td>
<td>
<p>The modeling formula. Looks like 'y~b1/(1+b2*exp(-b3*T))'</p>
</td></tr>
<tr><td><code id="wrapnlsr_+3A_data">data</code></td>
<td>
<p>a data frame containing data for variables
used in the formula that are NOT the parameters. This
data may also be defined in the parent frame i.e.,
'global' to this function</p>
</td></tr>
<tr><td><code id="wrapnlsr_+3A_start">start</code></td>
<td>
<p>MUST be a named vector with all elements present
e.g., start=c(b1=200, b2=50, b3=0.3)</p>
</td></tr>
<tr><td><code id="wrapnlsr_+3A_control">control</code></td>
<td>
<p>a list of control parameters. See nlsr.control().</p>
</td></tr>
<tr><td><code id="wrapnlsr_+3A_trace">trace</code></td>
<td>
<p>TRUE for console output during execution (default FALSE)</p>
</td></tr>
<tr><td><code id="wrapnlsr_+3A_subset">subset</code></td>
<td>
<p>an optional vector specifying a subset of observations 
to be used in the fitting process. NOT used currently by nlxb()
or nlfb() and will throw an error if present and not NULL.</p>
</td></tr>
<tr><td><code id="wrapnlsr_+3A_lower">lower</code></td>
<td>
<p>a vector of lower bounds on the parameters. 
If a single number, this will be applied to all parameters
Default <code>-Inf</code>.</p>
</td></tr>
<tr><td><code id="wrapnlsr_+3A_upper">upper</code></td>
<td>
<p>a vector of upper bounds on the parameters. If a single number, 
this will be applied to all parameters. Default <code>Inf</code>.</p>
</td></tr>
<tr><td><code id="wrapnlsr_+3A_weights">weights</code></td>
<td>
<p>A vector of (usually fixed) weights. The objective function that will be 
minimized is the sum of squares where each residual is multiplied by the 
square root of the corresponding weight. Default <code>NULL</code> implies 
unit weights.</p>
</td></tr>
<tr><td><code id="wrapnlsr_+3A_...">...</code></td>
<td>
<p>additional data needed to evaluate the modeling functions</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A solution object of type <code>nls</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(nlsr)
cat("kvanderpoel.R test of wrapnlsr\n")
x&lt;-c(1,3,5,7)
y&lt;-c(37.98,11.68,3.65,3.93)
pks28&lt;-data.frame(x=x,y=y)
fit0&lt;-try(nls(y~(a+b*exp(1)^(-c*x)), data=pks28, start=c(a=0,b=1,c=1), 
              trace=TRUE))
print(fit0)
fit1&lt;-nlxb(y~(a+b*exp(-c*x)), data=pks28, start=c(a=0,b=1,c=1), trace = TRUE)
print(fit1) 
cat("\n\n or better\n")
fit2&lt;-wrapnlsr(y~(a+b*exp(-c*x)), data=pks28, start=c(a=0,b=1,c=1), 
               lower=-Inf, upper=Inf, trace = TRUE)
fit2

weed &lt;- c(5.308, 7.24, 9.638, 12.866, 17.069, 23.192, 31.443,
          38.558, 50.156, 62.948, 75.995, 91.972)
tt &lt;- 1:12
weeddf &lt;- data.frame(tt, weed)
hobbsu &lt;- weed ~ b1/(1+b2*exp(-b3*tt))
st2 &lt;- c(b1=200, b2=50, b3=0.3)
wts &lt;- 0.5^tt # a straight scaling comes via wts &lt;- rep(0.01, 12)
lo &lt;- c(200, 0, 0)
up &lt;- c(1000, 1000, 1000)
whuw2 &lt;-  try(wrapnlsr(start=st2, formula=hobbsu, data=weeddf, subset=2:11,
                  weights=wts, trace=TRUE, lower=lo, upper=up))
summary(whuw2)
deviance(whuw2)
whuw2a &lt;-  try(nlsr(start=st2, formula=hobbsu, data=weeddf, subset=2:11,
                  weights=wts, trace=TRUE, lower=lo, upper=up))
summary(whuw2a)
deviance(whuw2a)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
