<!DOCTYPE html><html><head><title>Help for package cna</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {cna}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#cna-package'>
<p>cna: A Package for Causal Modeling with Coincidence Analysis</p></a></li>
<li><a href='#allCombs'>
<p>Generate all logically possible value configurations of a given set of factors</p></a></li>
<li><a href='#cna'><p>Perform Coincidence Analysis</p></a></li>
<li><a href='#cna-deprecated'><p>Deprecated functions in the cna package</p></a></li>
<li><a href='#cna-internals'><p>Internal functions in the cna package</p></a></li>
<li><a href='#coherence'>
<p>Calculate the coherence of complex solution formulas</p></a></li>
<li><a href='#condition'>
<p>Uncover relevant properties of msc, asf, and csf in a data frame or <code>configTable</code></p></a></li>
<li><a href='#condList-methods'>
<p>Methods for class &ldquo;condList&rdquo;</p></a></li>
<li><a href='#condTbl'>
<p>Extract conditions and solutions from an object of class &ldquo;cna&rdquo;</p></a></li>
<li><a href='#configTable'><p>Assemble cases with identical configurations in a configuration table</p></a></li>
<li><a href='#ct2df'>
<p>Transform a configuration table into a data frame</p></a></li>
<li><a href='#cyclic'>
<p>Detect cyclic substructures in complex solution formulas (csf)</p></a></li>
<li><a href='#d.autonomy'><p>Emergence and endurance of autonomy of biodiversity institutions in Costa Rica</p></a></li>
<li><a href='#d.educate'><p>Artificial data on education levels and left-party strength</p></a></li>
<li><a href='#d.highdim'><p>Artificial data with 50 factors and 1191 cases</p></a></li>
<li><a href='#d.irrigate'><p>Data on the impact of development interventions on water adequacy in Nepal</p></a></li>
<li><a href='#d.jobsecurity'><p>Job security regulations in western democracies</p></a></li>
<li><a href='#d.minaret'><p>Data on the voting outcome of the 2009 Swiss Minaret Initiative</p></a></li>
<li><a href='#d.pacts'><p>Data on the emergence of labor agreements in new democracies between 1994 and 2004</p></a></li>
<li><a href='#d.pban'><p>Party ban provisions in sub-Saharan Africa</p></a></li>
<li><a href='#d.performance'><p>Data on combinations of industry, corporate, and business-unit effects</p></a></li>
<li><a href='#d.volatile'><p>Data on the volatility of grassroots associations in Norway between 1980 and 2000</p></a></li>
<li><a href='#d.women'><p>Data on high percentage of women's representation in parliaments of western countries</p></a></li>
<li><a href='#full.ct'>
<p>Generate the logically possible value configurations of a given set of factors</p></a></li>
<li><a href='#is.inus'>
<p>Check whether expressions in the syntax of CNA solutions have INUS form</p></a></li>
<li><a href='#is.submodel'>
<p>Identify correctness-preserving submodel relations</p></a></li>
<li><a href='#makeFuzzy'>
<p>Fuzzifying crisp-set data</p></a></li>
<li><a href='#minimalize'>
<p>Eliminate logical redundancies from Boolean expressions</p></a></li>
<li><a href='#minimalizeCsf'>
<p>Eliminate structural redundancies from csf</p></a></li>
<li><a href='#randomConds'><p>Generate random solution formulas</p></a></li>
<li><a href='#redundant'>
<p>Identify structurally redundant asf in a csf</p></a></li>
<li><a href='#rreduce'><p>Eliminate redundancies from a disjunctive normal form (DNF)</p></a></li>
<li><a href='#selectCases'>
<p>Select the cases/configurations compatible with a data generating causal structure</p></a></li>
<li><a href='#shortcuts'><p>Shortcut functions with fixed <code>type</code> argument.</p></a></li>
<li><a href='#some'>
<p>Randomly select configurations from a data frame or <code>configTable</code></p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Causal Modeling with Coincidence Analysis</td>
</tr>
<tr>
<td>Version:</td>
<td>3.6.2</td>
</tr>
<tr>
<td>Date:</td>
<td>2024-07-05</td>
</tr>
<tr>
<td>Description:</td>
<td>Provides comprehensive functionalities for causal modeling with Coincidence Analysis (CNA), which is a configurational comparative method of causal data analysis that was first introduced in Baumgartner (2009) &lt;<a href="https://doi.org/10.1177%2F0049124109339369">doi:10.1177/0049124109339369</a>&gt;, and generalized in Baumgartner &amp; Ambuehl (2018) &lt;<a href="https://doi.org/10.1017%2Fpsrm.2018.45">doi:10.1017/psrm.2018.45</a>&gt;. CNA is designed to recover INUS-causation from data, which is particularly relevant for analyzing processes featuring conjunctural causation (component causation) and equifinality (alternative causation). CNA is currently the only method for INUS-discovery that allows for multiple effects (outcomes/endogenous factors), meaning it can analyze common-cause and causal chain structures.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://CRAN.R-project.org/package=cna">https://CRAN.R-project.org/package=cna</a></td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 4.1.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>Rcpp, utils, stats, Matrix, matrixStats, car</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>Rcpp</td>
</tr>
<tr>
<td>Suggests:</td>
<td>dplyr, frscore, causalHyperGraph</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>LazyData:</td>
<td>yes</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Mathias Ambuehl &lt;mathias.ambuehl@consultag.ch&gt;</td>
</tr>
<tr>
<td>Author:</td>
<td>Mathias Ambuehl [aut, cre, cph],
  Michael Baumgartner [aut, cph],
  Ruedi Epple [ctb],
  Veli-Pekka Parkkinen [ctb],
  Alrik Thiem [ctb]</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-07-05 04:50:09 UTC; MAM</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-07-05 09:30:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='cna-package'>
cna: A Package for Causal Modeling with Coincidence Analysis
</h2><span id='topic+cna-package'></span>

<h3>Description</h3>

<p><dfn>Coincidence Analysis</dfn> (CNA) is a configurational comparative method of causal data analysis that was first introduced for crisp-set (i.e. binary) data in Baumgartner (2009a, 2009b, 2013) and generalized for multi-value and fuzzy-set data in Baumgartner and Ambuehl (2020). The <span class="pkg">cna</span> package implements the method's latest stage of development. 
</p>
<p>CNA infers causal structures as defined by modern variants of the so-called <em>INUS-theory</em> (Mackie 1974; Grasshoff and May 2001; Baumgartner and Falk 2023) from empirical data. The INUS-theory is a type-level difference-making theory that spells out causation in terms of redundancy-free Boolean dependency structures. It is optimally suited for the anaylsis of causal structures with the following features: <em>conjunctivity</em>&mdash;causes are arranged in complex bundles 
that only become operative when all of their components are properly co-instantiated, each of which in isolation is ineffective or leads to different outcomes&mdash;and <em>disjunctivity</em>&mdash;effects can be brought about along alternative causal routes such that, when suppressing one route, the effect may still be produced via another one. 
</p>
<p>Causal structures featuring conjunctivity and disjunctivity pose challenges for 
methods of causal data analysis. As many theories of causation (other than the INUS-theory) entail that it is necessary (though not sufficient) for X to be a cause of Y that there be some kind of dependence (e.g. probabilistic or counterfactual) between X and Y, standard methods (e.g. Spirtes et al. 2000) infer that X is <em>not</em> a cause of Y if X and Y are <em>not</em> pairwise dependent. 
Howeover, there often are no dependencies between an individual component X of a conjunctive cause and the corresponding effect Y (for concrete examples see  the package vignette (accessed from R by typing <code>vignette("cna")</code>). In the absence of pairwise dependencies, X can only be identified as a cause of Y if it is embedded in a complex Boolean structure over many factors and that structure is fitted to the data as a whole. But the space of Boolean functions over even a handful of factors is vast. So, a method for INUS-discovery must find ways to efficiently navigate in that vast space of possibilities. That is the purpose of CNA. 
</p>
<p>CNA is not the only method for the discovery of INUS structures. Other methods that can be used for that purpose are Logic Regression (Ruczinski et al. 2003, Kooperberg and Ruczinski 2005), which is implemented in the R package <a href="https://cran.r-project.org/package=LogicReg"><span class="pkg">LogicReg</span></a>, and Qualitative Comparative Analysis (Ragin 1987; 2008; Cronqvist and Berg-Schlosser 2009), whose most powerful implementations are provided by the R packages <a href="https://cran.r-project.org/package=QCApro"><span class="pkg">QCApro</span></a> and <a href="https://cran.r-project.org/package=QCA"><span class="pkg">QCA</span></a>. But CNA is the only method of its kind that can process data generated by causal structures with more than one outcome and, hence, can analyze common-cause and causal chain structures as well as causal cycles and feedbacks. Moreover, unlike the models produced by Logic Regression or Qualitative Comparative Analysis, CNA's models are guaranteed to be redundancy-free, which makes them directly causally interpretable in terms of the INUS-theory; and CNA is more successful than any other method at exhaustively uncovering all INUS models that fit the data equally well. For comparisons of CNA with Qualitative Comparative Analysis and Logic Regression see (Baumgartner and Ambuehl 2020; Swiatczak 2022) and (Baumgartner and Falk 2023), respectively.
</p>
<p>There exist three additional R packages for data analysis with CNA: <a href="https://CRAN.R-project.org/package=causalHyperGraph"><span class="pkg">causalHyperGraph</span></a>, which visualizes CNA models as causal graphs, <a href="https://CRAN.R-project.org/package=cnaOpt"><span class="pkg">cnaOpt</span></a>, which systematizes the search for optimally fitting CNA models, and <a href="https://CRAN.R-project.org/package=frscore"><span class="pkg">frscore</span></a>, which automatizes robustness scoring of CNA models.
</p>


<h3>Details</h3>


<table>
<tr>
 <td style="text-align: left;">
Package: </td><td style="text-align: left;"> cna</td>
</tr>
<tr>
 <td style="text-align: left;">
Type:    </td><td style="text-align: left;"> Package</td>
</tr>
<tr>
 <td style="text-align: left;">
Version: </td><td style="text-align: left;"> 3.6.2</td>
</tr>
<tr>
 <td style="text-align: left;">
Date:    </td><td style="text-align: left;"> 2024-07-05</td>
</tr>
<tr>
 <td style="text-align: left;">
License: </td><td style="text-align: left;"> GPL (&gt;= 2)</td>
</tr>
<tr>
 <td style="text-align: left;">
    </td>
</tr>

</table>



<h3>Author(s)</h3>

<p><b>Authors</b>:<br />
Mathias Ambuehl<br />
<a href="mailto:mathias.ambuehl@consultag.ch">mathias.ambuehl@consultag.ch</a>
</p>
<p>Michael Baumgartner<br />
Department of Philosophy<br />
University of Bergen<br />
<a href="mailto:michael.baumgartner@uib.no">michael.baumgartner@uib.no</a>
</p>
<p><b>Maintainer</b>:<br />
Mathias Ambuehl
</p>


<h3>References</h3>

<p>Baumgartner, Michael. 2009a. &ldquo;Inferring Causal Complexity.&rdquo;
<em>Sociological Methods &amp; Research</em> 38(1):71-101.
</p>
<p>Baumgartner, Michael. 2009b. &ldquo;Uncovering Deterministic Causal Structures:
A Boolean Approach.&rdquo; <em>Synthese</em> 170(1):71-96.
</p>
<p>Baumgartner, Michael. 2013. &ldquo;Detecting Causal Chains in Small-n Data.&rdquo;
<em>Field Methods</em> 25 (1):3-24.
</p>
<p>Baumgartner, Michael and Mathias Ambuehl. 2020. &ldquo;Causal Modeling with Multi-Value and Fuzzy-Set Coincidence Analysis.&rdquo; <em>Political Science Research and Methods</em>. 8:526-542.
</p>
<p>Baumgartner, Michael and Christoph Falk. 2023. &ldquo;Boolean Difference-Making: A Modern Regularity Theory of Causation&rdquo;. <em>The British Journal for the Philosophy of Science</em>, 74(1), 171-197. 
</p>
<p>Baumgartner Michael and Christoph Falk. 2023. &ldquo;Configurational Causal Modeling and Logic Regression.&rdquo; <em>Multivariate Behavioral Research</em>, 58:2, 292-310.
</p>
<p>Cronqvist, Lasse, Dirk Berg-Schlosser. 2009. &ldquo;Multi-Value QCA (mvQCA).&rdquo; In B Rihoux, CC Ragin (eds.), <em>Configurational Comparative Methods: Qualitative Comparative Analysis (QCA) and Related Techniques</em>, pp. 69-86. Sage Publications, London.
</p>
<p>Grasshoff, Gerd and Michael May. 2001. &ldquo;Causal Regularities&rdquo;. In W. Spohn, M. Ledwig, and
M. Esfeld (Eds.). <em>Current Issues in Causation</em>, pp. 85-114. Paderborn: Mentis.
</p>
<p>Mackie, John L. 1974. <em>The Cement of the Universe: A Study of Causation</em>. Oxford: Oxford University Press.
</p>
<p>Kooperberg, Charles and Ingo Ruczinski. 2005. &ldquo;Identifying Interacting SNPs Using Monte Carlo Logic Regression.&rdquo; Genetic Epidemiology, 28(2):157-170. 
</p>
<p>Ragin, Charles C. 1987. <em>The Comparative Method</em>. Berkeley: University of California Press.
</p>
<p>Ragin, Charles C. 2008. <em>Redesigning Social Inquiry: Fuzzy Sets and Beyond</em>. Chicago:
University of Chicago Press.
</p>
<p>Ruczinski, Ingo, Charles Kooperberg, and Michael LeBlanc. 2003. &ldquo;Logic Regression&rdquo;. <em>Journal of Computational and Graphical Statistics</em> 12:475-511.
</p>
<p>Spirtes, Peter, Clark Glymour, and Richard Scheines. 2000. &ldquo;Causation, Prediction, and Search.&rdquo; 2 edition. MIT Press, Cambridge.
</p>
<p>Swiatczak, Martyna. 2022. &ldquo;Different Algorithms, Different Models&rdquo;. <em>Quality &amp; Quantity</em> 56:1913-1937.
</p>

<hr>
<h2 id='allCombs'>
Generate all logically possible value configurations of a given set of factors
</h2><span id='topic+allCombs'></span>

<h3>Description</h3>

<p>The function <code>allCombs</code> generates a data frame of all possible value configurations of <code>length(x)</code> factors, the first factor having <code>x[1]</code> values, the second <code>x[2]</code> values etc. The factors are labeled using capital letters. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>allCombs(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="allCombs_+3A_x">x</code></td>
<td>
<p>Integer vector with values &gt;0</p>
</td></tr>
</table>


<h3>Details</h3>

<p>In combination with <code>selectCases</code>. <code>makeFuzzy</code>, and <code>is.submodel</code>, <code>allCombs</code> is useful for simulating data, which are needed for inverse search trials benchmarking the output of <code>cna</code>. In a nutshell, <code>allCombs</code> generates the space of all logically possible configurations of the factors in an analyzed factor set, <code>selectCases</code> selects those configurations from this space that are compatible with a given data generating causal structure (i.e. the ground truth, which can be randomly generated using <code>randomConds</code>), <code>makeFuzzy</code> fuzzifies those data, and <code>is.submodel</code> checks whether the models returned by <code>cna</code> are true of the ground truth.
</p>
<p>The <span class="pkg">cna</span> package provides another function to the same effect, <code><a href="#topic+full.ct">full.ct</a></code>, which is more flexible than <code>allCombs</code>.
</p>


<h3>Value</h3>

<p>A data frame.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+selectCases">selectCases</a></code>, <code><a href="#topic+makeFuzzy">makeFuzzy</a></code>, <code><a href="#topic+is.submodel">is.submodel</a></code>, <code><a href="#topic+randomConds">randomConds</a></code>, <code><a href="#topic+full.ct">full.ct</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'># Generate all logically possible configurations of 5 dichotomous factors named "A", "B",
# "C", "D", and "E". 
allCombs(c(2, 2, 2, 2, 2)) - 1
# allCombs(c(2, 2, 2, 2, 2)) generates the value space for values 1 and 2, but as it is
# conventional to use values 0 and 1 for Boolean factors, 1 must be subtracted from
# every value output by allCombs(c(2, 2, 2, 2, 2)) to yield a Boolean data frame.

# Generate all logically possible configurations of 5 multi-value factors named "A", "B",
# "C", "D", and "E", such that A can take on 3 values {1,2,3}, B 4 values {1,2,3,4},
# C 3 values etc.
dat0 &lt;- allCombs(c(3, 4, 3, 5, 3))
head(dat0)
nrow(dat0) # = 3*4*3*5*3

# Generate all configurations of 5 dichotomous factors that are compatible with the causal
# chain (A*b + a*B &lt;-&gt; C)*(C*d + c*D &lt;-&gt; E).
dat1 &lt;- allCombs(c(2, 2, 2, 2, 2)) - 1
(dat2 &lt;- selectCases("(A*b + a*B &lt;-&gt; C)*(C*d + c*D &lt;-&gt; E)", dat1))

# Generate all configurations of 5 multi-value factors that are compatible with the causal
# chain (A=2*B=1 + A=3*B=3 &lt;-&gt; C=1)*(C=1*D=2 + C=4*D=4 &lt;-&gt; E=3).
dat1 &lt;- allCombs(c(3, 3, 4, 4, 3))
dat2 &lt;- selectCases("(A=2*B=1 + A=3*B=3 &lt;-&gt; C=1)*(C=1*D=2 + C=4*D=4 &lt;-&gt; E=3)", dat1)
nrow(dat1)
nrow(dat2)                    

# Generate all configurations of 5 fuzzy-set factors that are compatible with the causal
# structure A*b + C*D &lt;-&gt; E, such that con = .8 and cov = .8.
dat1 &lt;- allCombs(c(2, 2, 2, 2, 2)) - 1
dat2 &lt;- makeFuzzy(dat1, fuzzvalues = seq(0, 0.45, 0.01))
(dat3 &lt;- selectCases1("A*b + C*D &lt;-&gt; E", con = .8, cov = .8, dat2))

# Inverse search for the data generating causal structure A*b + a*B + C*D &lt;-&gt; E from
# fuzzy-set data with non-perfect consistency and coverage scores.
set.seed(3)
groundTruth &lt;- "A*b + a*B + C*D &lt;-&gt; E"
dat1 &lt;- allCombs(c(2, 2, 2, 2, 2)) - 1
dat2 &lt;- makeFuzzy(dat1, fuzzvalues = 0:4/10)
dat3 &lt;- selectCases1(groundTruth, con = .8, cov = .8, dat2)
ana1 &lt;- cna(dat3, outcome = "E", con = .8, cov = .8)
any(is.submodel(asf(ana1)$condition, groundTruth))
</code></pre>

<hr>
<h2 id='cna'>Perform Coincidence Analysis</h2><span id='topic+cna'></span><span id='topic+print.cna'></span>

<h3>Description</h3>

<p>The <code>cna</code> function performs Coincidence Analysis to identify atomic solution formulas (asf) consisting of minimally necessary
disjunctions of minimally sufficient conditions of all outcomes in the data
and combines the recovered asf to complex solution formulas (csf) representing multi-outcome structures, e.g. common-cause and/or
causal chain structures. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cna(x, type, ordering = NULL, strict = FALSE, outcome = TRUE, exclude = character(0),
    con = 1, cov = 1, con.msc = con,
    notcols = NULL, rm.const.factors = FALSE, rm.dup.factors = FALSE,  
    maxstep = c(3, 4, 10), inus.only = only.minimal.msc &amp;&amp; only.minimal.asf, 
    only.minimal.msc = TRUE,  only.minimal.asf = TRUE, 
    maxSol = 1e6, suff.only = FALSE, 
    what = if (suff.only) "m" else "ac", cutoff = 0.5, 
    border = c("up", "down", "drop"), details = FALSE, 
    acyclic.only = FALSE, cycle.type = c("factor", "value"), 
    asf.selection = c("cs", "fs", "none"), verbose = FALSE)

## S3 method for class 'cna'
print(x, what = x$what, digits = 3, nsolutions = 5, 
      details = x$details, show.cases = NULL, inus.only = x$inus.only, 
      acyclic.only = x$acyclic.only, cycle.type = x$cycle.type, 
      verbose = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cna_+3A_x">x</code></td>
<td>
<p>Data frame or <code>configTable</code> (as output by <code><a href="#topic+configTable">configTable</a></code>).</p>
</td></tr>
<tr><td><code id="cna_+3A_type">type</code></td>
<td>
<p>Character vector specifying the type of <code>x</code>: <code>"auto"</code> (automatic detection; default), <code>"cs"</code> (crisp-set), <code>"mv"</code> (multi-value),  or <code>"fs"</code> (fuzzy-set).</p>
</td></tr>
<tr><td><code id="cna_+3A_ordering">ordering</code></td>
<td>
<p>Character string or list of character vectors specifying the causal ordering of
the factors in <code>x</code>.</p>
</td></tr>
<tr><td><code id="cna_+3A_strict">strict</code></td>
<td>
<p>Logical; if <code>TRUE</code>, factors on the same level of the causal
ordering are <em>not</em> potential causes of each other; if <code>FALSE</code> (default), factors on the same level <em>are</em> potential causes of each other.</p>
</td></tr>
<tr><td><code id="cna_+3A_outcome">outcome</code></td>
<td>
<p>Character vector specifying one or several factor values that are to be considered as potential outcome(s). For crisp- and fuzzy-set data, factor values are expressed by upper and lower cases, for multi-value data, they are expressed by the &quot;factor=value&quot; notation.  
Defaults to <code>outcome = TRUE</code>, which means that all factor values in <code>x</code> are considered as potential outcomes.</p>
</td></tr>
<tr><td><code id="cna_+3A_exclude">exclude</code></td>
<td>
<p>Character vector specifying factor values to be excluded as possible causes of certain outcomes. For instance, <code>exclude = "A,c-&gt;B"</code> determines that A and c are not considered as potential causes of B.</p>
</td></tr>
<tr><td><code id="cna_+3A_con">con</code></td>
<td>
<p>Numeric scalar between 0 and 1 to set the minimum consistency threshold every minimally sufficient condition (msc), atomic solution formula (asf), and complex solution formula (csf) must satisfy. (See also the argument <code>con.msc</code> below).</p>
</td></tr>
<tr><td><code id="cna_+3A_cov">cov</code></td>
<td>
<p>Numeric scalar between 0 and 1 to set the minimum coverage threshold every asf and csf must satisfy.</p>
</td></tr>
<tr><td><code id="cna_+3A_con.msc">con.msc</code></td>
<td>
<p>Numeric scalar between 0 and 1 to set the minimum consistency threshold every msc must satisfy. Overrides <code>con</code> for msc and, thereby, allows for imposing a consistency threshold on msc that differs from the threshold <code>con</code> imposes on asf and csf. Defaults to <code>con</code>.</p>
</td></tr>
<tr><td><code id="cna_+3A_maxstep">maxstep</code></td>
<td>
<p>Vector of three integers; the first specifies the maximum number of conjuncts in each disjunct of an asf, the second specifies the maximum number of disjuncts in an asf, the third specifies the maximum <em>complexity</em> of an asf. The complexity of an asf is 
the total number of exogenous factor values in the asf. Default: <code>c(3,4,10)</code>.</p>
</td></tr>
<tr><td><code id="cna_+3A_inus.only">inus.only</code></td>
<td>
<p>Either <code>TRUE</code>/<code>FALSE</code> or a character string with possible values &quot;implication&quot; or &quot;equivalence&quot;. The strings can be abbreviated. If <code>TRUE</code>, only disjunctive normal forms that are free of redundancies are retained as asf (see also <code><a href="#topic+is.inus">is.inus</a></code>). <br /> Defaults to <code>only.minimal.msc &amp;&amp; only.minimal.asf</code>.</p>
</td></tr>
<tr><td><code id="cna_+3A_only.minimal.msc">only.minimal.msc</code></td>
<td>
<p>Logical; if <code>TRUE</code> (default), only minimal conjunctions are retained as msc. If <code>FALSE</code>, sufficient conjunctions are not required to be minimal.</p>
</td></tr>
<tr><td><code id="cna_+3A_only.minimal.asf">only.minimal.asf</code></td>
<td>
<p>Logical; if <code>TRUE</code> (default), only minimal disjunctions are retained as asf. If <code>FALSE</code>, necessary disjunctions are not required to be minimal. </p>
</td></tr>
<tr><td><code id="cna_+3A_maxsol">maxSol</code></td>
<td>
<p>Maximum number of asf calculated.</p>
</td></tr>
<tr><td><code id="cna_+3A_suff.only">suff.only</code></td>
<td>
<p>Logical; if <code>TRUE</code>, the function only searches for msc and not for asf and csf.</p>
</td></tr>
<tr><td><code id="cna_+3A_notcols">notcols</code></td>
<td>
<p>Character vector of factors to be negated in <code>x</code>. If <code>notcols = "all"</code>, all factors in <code>x</code> are negated.</p>
</td></tr>
<tr><td><code id="cna_+3A_rm.const.factors">rm.const.factors</code>, <code id="cna_+3A_rm.dup.factors">rm.dup.factors</code></td>
<td>
<p>Logical; if <code>TRUE</code>, factors with constant values are removed and all but the first of a set of duplicated factors are removed. These parameters are passed to <code><a href="#topic+configTable">configTable</a></code>. <b>Note:</b> The default value has changed from <code>TRUE</code> to <code>FALSE</code> in the package's version 3.5.4.</p>
</td></tr>
<tr><td><code id="cna_+3A_what">what</code></td>
<td>
<p>Character string specifying what to print; <code>"t"</code> for the configuration table, <code>"m"</code> for msc, <code>"a"</code> for asf, <code>"c"</code> for csf, and <code>"all"</code> for all. Defaults to <code>"ac"</code> if <code>suff.only = FALSE</code>, and to <code>"m"</code> otherwise.</p>
</td></tr>
<tr><td><code id="cna_+3A_cutoff">cutoff</code></td>
<td>
<p>Minimum membership score required for a factor to count as instantiated in the data and to be integrated in the analysis. Value in the unit interval [0,1]. The default cutoff is 0.5. Only meaningful if <code>type = "fs"</code>.</p>
</td></tr>
<tr><td><code id="cna_+3A_border">border</code></td>
<td>
<p>Character string specifying whether factors with membership scores equal to <code>cutoff</code> are rounded up (<code>"up"</code>), rounded down (<code>"down"</code>) or dropped from the analysis (<code>"drop"</code>). Only meaningful if <code>type = "fs"</code>. </p>
</td></tr>
<tr><td><code id="cna_+3A_details">details</code></td>
<td>
<p>Either <code>TRUE</code>/<code>FALSE</code> or a character vector with possible elements <code>"exhaustiveness"</code>, <code>"faithfulness"</code>, <code>"coherence"</code>, <code>"redundant"</code>, <code>"cyclic"</code>. The strings can be abbreviated, e.g.  <code>"e"</code> or <code>"exh"</code> for <code>"exhaustiveness"</code>, etc.</p>
</td></tr>
<tr><td><code id="cna_+3A_acyclic.only">acyclic.only</code></td>
<td>
<p>Logical; if <code>TRUE</code>, csf featuring a cyclic substructure are not returned. <code>FALSE</code> by default.</p>
</td></tr>
<tr><td><code id="cna_+3A_cycle.type">cycle.type</code></td>
<td>
<p>Character string specifying what type of cycles to be detected: <code>"factor"</code> (the default) or <code>"value"</code> (cf. <code><a href="#topic+cyclic">cyclic</a></code>).</p>
</td></tr>
<tr><td><code id="cna_+3A_asf.selection">asf.selection</code></td>
<td>
<p>Character string specifying how to select asfs based on outcome variation in configurations incompatible with a model. <code>asf.selection = "cs"</code> (default): selection based on variation at the 0.5 anchor; <code>asf.selection = "fs"</code>: selection based on variation in the fuzzy-set value; <code>asf.selection = "none"</code>: no selection based on outcome variation in incompatible configurations.</p>
</td></tr>
<tr><td><code id="cna_+3A_verbose">verbose</code></td>
<td>
<p>Logical; if <code>TRUE</code>, some details on the csf building process are printed during the execution of the <code>cna</code> function. <code>FALSE</code> by default.</p>
</td></tr>
<tr><td><code id="cna_+3A_digits">digits</code></td>
<td>
<p>Number of digits to print in consistency, coverage, exhaustiveness, faithfulness, and coherence scores.</p>
</td></tr>
<tr><td><code id="cna_+3A_nsolutions">nsolutions</code></td>
<td>
<p>Maximum number of msc, asf, and csf to print. Alternatively, <code>nsolutions = "all"</code> will print all solutions.</p>
</td></tr>
<tr><td><code id="cna_+3A_show.cases">show.cases</code></td>
<td>
<p>Logical; if <code>TRUE</code>, the <code>configTable</code>'s attribute &ldquo;cases&rdquo;
is printed. <br /> See <code><a href="#topic+print.configTable">print.configTable</a></code></p>
</td></tr>
<tr><td><code id="cna_+3A_...">...</code></td>
<td>

<p>In <code>print.cna</code>: arguments passed to other <code>print</code>-methods.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <strong>first input <code>x</code></strong> of the <code>cna</code> function is a data frame or a configuration table. To ensure that no misinterpretations of returned asf and csf can occur, users are advised to use only upper case letters as factor (column) names. Column names may contain numbers, but the first sign in a column name must be a letter. Only ASCII signs should be used for column and row names.
</p>
<p>The argument <code>type</code> allows for specifying the <b>type of data</b> <code>x</code> contains. As of package version 3.2, that argument has the default value <code>"auto"</code> inducing automatic detection of the data type. But the user can still manually set the data type. Data that feature factors taking values 1 or 0 only are called <em>crisp-set</em>, which can be indicated by <code>type = "cs"</code>. If the data contain at least one factor that takes more than two values, e.g. {1,2,3}, the data count as <em>multi-value</em>: <code>type = "mv"</code>. Data featuring at least one factor taking real values from the interval [0,1] count as <em>fuzzy-set</em>: <code>type = "fs"</code>. (Note that mixing multi-value and fuzzy-set factors in one analysis is not supported). 
</p>
<p>A data frame or configuration table <code>x</code> is the only mandatory input of the <code>cna</code> function. In particular, <code>cna</code> does not need an input specifying which factor(s) in <code>x</code> are endogenous, it tries to infer that from the data. But if it is known prior to the analysis what factors have values that can figure as outcomes, an <strong>outcome specification</strong> can be given to <code>cna</code> via the argument <code>outcome</code>, which takes as input a character vector identifying one or several factor values  as potential outcome(s). For <code>"cs"</code> and <code>"fs"</code> data, outcomes are expressed by upper and lower cases (e.g. <code>outcome = c("A", "b")</code>). If factor names have multiple letters, any upper case letter is interpreted as 1, and the absence of upper case letters as 0 (i.e. <code>outcome = c("coLd", "shiver")</code> is interpreted as <code>COLD=1</code> and <code>SHIVER=0</code>).  For <code>"mv"</code> data, factor values are assigned by the &ldquo;factor=value&rdquo; notation (e.g. <code>outcome = c("A=1","B=3")</code>). Defaults to <code>outcome = TRUE</code>, which means that all factor values in <code>x</code> are potential outcomes.
</p>
<p>When the data <code>x</code> contain multiple potential outcomes, it may moreover be known, prior to the analysis, that these outcomes have a certain <strong>causal ordering</strong>, meaning that some of them are causally upstream of the others. Such information can be given to <code>cna</code> by means of the argument <code>ordering</code>, which takes either a character string or a list of character vectors as value.
For example,  <code>ordering = "A, B &lt; C"</code> or, equivalently, <code>ordering = list(c("A",</code> <code> "B"), "C")</code> determines that factor C is causally located <em>downstream</em> of factors A and B, meaning that <em>no values</em> of C are potential causes of values of A and B. In consequence, <code>cna</code> only checks whether values of A and B can be modeled as causes of values of C; the test for a causal dependency in the other direction is skipped.
An <code>ordering</code> does not need to explicitly mention all factors in <code>x</code>. If only a subset of the factors are included in the <code>ordering</code>, the non-included factors are entailed to be upstream of the included ones. Hence, <code>ordering = "C"</code> means that C is located downstream of all other factors in <code>x</code>.
</p>
<p>The argument <code>strict</code> determines whether the elements of one level in an ordering can be causally related or not. For example, if <code>ordering = "A, B &lt; C"</code> and <code>strict = TRUE</code>, then the values of A and B&mdash;which are on the same level of the ordering&mdash;are excluded to be causally related and <code>cna</code> skips corresponding tests. By contrast, if <code>ordering = "A, B &lt; C"</code> and <code>strict = FALSE</code>, then <code>cna</code> also searches for dependencies among the values of A and B. The default is <code>strict</code> <code> = FALSE</code>. 
</p>
<p>An <code>ordering</code> excludes <em>all</em> values of a factor as potential causes of an outcome. But a user may only be in a position to exclude <em>some</em> (not all) values as potential causes. Such information can be given to <code>cna</code> through the argument <strong><code>exclude</code></strong>, which can be assigned a vector of character strings featuring the factor values to be excluded as causes to the left of the &quot;<code>-&gt;</code>&quot; sign and the corresponding outcomes on the right. For example, <code>exclude = "A=1,C=3 -&gt; B=1"</code> determines that the value 1 of factor A and the value 3 of factor C are excluded as  causes of the value 1 of factor B. Factor values can be excluded as potential causes of multiple outcomes as follows: <code>exclude = c("A,c -&gt; B", "b,H -&gt; D")</code>. For <code>"cs"</code> and <code>"fs"</code> data, upper case letters are interpreted as 1, lower case letters as 0. If factor names have multiple letters, any upper case letter is interpreted as 1, and the absence of upper case letters as 0. For <code>"mv"</code> data, the &quot;factor=value&quot; notation is required. 
To exclude <em>all</em> values of a factor as potential causes of an outcome or to exclude a factor value as potential cause of <em>all</em> values of some endogenous factor, a &quot;<code>*</code>&quot; can be appended to the corresponding factor name; for example: <code>exclude = "A* -&gt; B"</code> or <code>exclude = "A=1,C=3 -&gt; B*"</code>.
The <code>exclude</code> argument can be used both independently of and in conjunction with <code>outcome</code> and  <code>ordering</code>, but if assignments to <code>outcome</code> and <code>ordering</code> contradict assignments to <code>exclude</code>, the latter are ignored. If <code>exclude</code> is assigned values of factors that do not appear in the data <code>x</code>, an error is returned.
</p>
<p>If no outcomes are specified and no causal ordering is provided, all factor values in <code>x</code> are treated as potential outcomes; more specifically, in case of <code>"cs"</code> and <code>"fs"</code> data, <code>cna</code> tests for all factors whether their presence (i.e. them taking the value 1) can be modeled as an outcome, and in case of  <code>"mv"</code> data, <code>cna</code> tests for all factors whether any of their possible values can be modeled as an outcome. That is done by searching for redundancy-free Boolean functions (in disjunctive normal form) that account for the behavior of an outcome in accordance with <code>exclude</code> and <code>cna</code>'s core model fit parameters of <b>consistency and coverage</b> (for details see the <span class="pkg">cna</span> package vignette or Ragin 2006). First, <code>cna</code> identifies all minimally sufficient conditions (msc) that meet the threshold given by the consistency threshold <code>con.msc</code> (resp. <code>con</code>, if <code>con.msc = con</code>) for each potential outcome in <code>x</code>. Then, these msc are disjunctively combined to minimally
necessary conditions that meet the coverage threshold given by <code>cov</code> such that the whole disjunction meets the solution consistency threshold given by <code>con</code>. The resulting expressions are the atomic solution formulas (asf) for every factor value that can be modeled as outcome. The default value for <code>con.msc</code>, <code>con</code>, and <code>cov</code> is 1. 
</p>
<p>The <code>cna</code> function builds its models in four stages using a <strong><em>bottom-up search algorithm</em></strong> (see Baumgartner and Ambuehl 2020). 
</p>

<dl>
<dt>First stage</dt><dd><p>On the basis of <code>outcome</code> and <code>ordering</code>, the algorithm builds a set of potential outcomes <strong>O</strong> from the factors in <code>x</code>; and on the basis of <code>ordering</code> and <code>exclude</code>, it assigns a set of potential causes to each potential outcome. At the default values of <code>outcome</code>, <code>ordering</code>, and <code>exclude</code>, all factor values in <code>x</code> are treated as potential outcomes and  as potential causes.</p>
</dd>
<dt>Second stage</dt><dd><p>The algorithm checks whether single factor values, e.g. A, b, C, (where &quot;A&quot; stands for &quot;A=1&quot; and &quot;b&quot; for &quot;B=0&quot;) or D=3, E=2, etc., (whose membership scores, in case of <code>"fs"</code> data, meet <code>cutoff</code> in at least one case) are sufficient for a potential outcome in <strong>O</strong> (where a factor value counts as sufficient iff it meets the threshold given by <code>con.msc</code>). Next, conjuncts of two factor values, e.g. A*b, A*C, D=3*E=2 etc., (whose membership scores, in case of <code>"fs"</code> data, meet <code>cutoff</code> in at least one case) are tested for sufficiency. Then, conjuncts of three factors, and so on. Whenever a conjunction (or a single factor value) is found to be sufficient, all supersets of that conjunction contain redundancies and are, thus, not considered for the further analysis. The result is a set of msc for every potential outcome in <strong>O</strong>. To recover certain target structures from noisy data, it may be useful to allow <code>cna</code> to also consider sufficient conditions for further analysis that are not minimal. This can be accomplished by setting <code>only.minimal.msc</code> to <code>FALSE</code>. A concrete example illustrating the utility of <code>only.minimal.msc</code> is provided in the &ldquo;Examples&rdquo; section below. (The ordinary user is advised not to change the default value of this argument.)</p>
</dd> 
<dt>Third stage</dt><dd><p>Minimally necessary disjunctions are built for each potential outcome in <strong>O</strong> by first testing whether single msc are necessary, then disjunctions of two msc, then of three, etc. (where a disjunction of msc counts as necessary iff it meets the threshold given by <code>cov</code>). Whenever a disjunction of msc (or a single msc) is found to be necessary, all supersets of that disjunction contain redundancies and are, thus, excluded from the further analysis. Finally, all and only those disjunctions of msc that meet both <code>cov</code> and <code>con</code> are issued as redundancy-free <strong>atomic solution formulas</strong> (asf). To recover certain target structures from noisy data, it may be useful to allow <code>cna</code> to also consider necessary conditions for further analysis that are not minimal. This can be accomplished by setting <code>only.minimal.asf</code> to <code>FALSE</code>, in which case <em>all</em> disjunctions of msc reaching the con and cov thresholds will be returned. (The ordinary user is advised not to change the default value of this argument.)  
</p>
<p>As the combinatorial search space for asf is potentially too large to be exhaustively scanned in reasonable time, the argument <b><code>maxstep</code></b> allows for setting an upper bound for the complexity of the generated asf. <code>maxstep</code> takes a vector of three integers <code>c(i, j, k)</code> as input, entailing that the generated asf have maximally <code>j</code> disjuncts with maximally <code>i</code> conjuncts each and a total of maximally <code>k</code> factor values (<code>k</code> is the maximal complexity). The default is <code>maxstep = c(3, 4, 10)</code>.
</p>
<p>Note that when the data feature noise due to uncontrolled background influences the default <code>con</code> and <code>cov</code> thresholds of 1 will often not yield any asf. In such cases, <code>con</code> and <code>cov</code> may be set to values different from 1. <code>con</code> and <code>cov</code> should neither be set too high, in order to avoid overfitting, nor too low, in order to avoid underfitting. The <strong>overfitting danger</strong> is severe in causal modeling with CNA (and configurational causal modeling more generally). For a discussion of this problem see Parkkinen and Baumgartner (2023), who also introduce a procedure for robustness assessment that explores all threshold settings in a given interval&mdash;in an attempt to reduce both over- and underfitting. See also the R package <a href="https://CRAN.R-project.org/package=frscore"><span class="pkg">frscore</span></a>. </p>
</dd>
<dt>Fourth stage</dt><dd><p>If <code>cna</code> finds asf, it builds <strong>complex solution formulas</strong> (csf) from those asf. This is done in a stepwise manner as follows. First, all logically possible conjunctions featuring one asf of every outcome are built. Second, if <code>inus.only = TRUE</code>, the solutions resulting from step 1 are freed of structural redundancies (cf. Baumgartner and Falk 2023), and  tautologous and contradictory solutions as well as solutions with partial structural redundancies and constant factors are eliminated (cf. <code><a href="#topic+is.inus">is.inus</a></code>). [Note: as of package version 3.6.0, the &quot;implication&quot; definition of partial structural redundancy is used, see <code><a href="#topic+is.inus">is.inus</a></code> for details.] Third, if <code>acyclic.only = TRUE</code>, solutions with cyclic substructures are eliminated. Fourth, for those solutions that were modified in the previous steps, consistency and coverage are re-calculated and solutions that no longer reach <code>con</code> or <code>cov</code> are eliminated. The remaining solutions are returned as csf. (See also <code><a href="#topic+csf">csf</a></code>.)</p>
</dd> 
</dl>
 
<p>If <code>verbose</code> is set to its non-default value <code>TRUE</code>, some information about the progression of the algorithm is returned to the console during the execution of the <code>cna</code> function. The execution can easily be interrupted by ESC at all stages.
</p>
<p>The <b>default output</b> of <code>cna</code> lists asf and csf, ordered by complexity and the product of consistency and coverage. It provides the consistency and coverage scores of each solution, a complexity score, which corresponds to the number of exogenous factor values in a solution, and a column &ldquo;<code>inus</code>&rdquo; indicating whether a solution has INUS form, meaning whether it is redundancy-free as required by the <em>INUS-theory</em> of causation (Mackie 1974, ch. 3; Baumgartner and Falk 2023). If <code>inus.only = TRUE</code>, all solutions automatically have INUS form, but if <code>only.minimal.msc</code> or 
<code>only.minimal.asf</code> are set to <code>FALSE</code>, non-INUS solutions may also be returned. 
</p>
<p>Apart from the standard solution attributes, <code>cna</code> can calculate a number of  <b>further solution attributes</b>: <code>exhaustiveness</code>, <code>faithfulness</code>, <code>coherence</code>, <code>redundant</code>, and <code>cyclic</code> all of which are recovered by setting <code>details</code> to its non-default value <code>TRUE</code> or to a character vector specifying the attributes to be calculated. 
These attributes require explication (see also <code>vignette("cna")</code>):
</p>

<ul>
<li> <p><code>exhaustiveness</code> and <code>faithfulness</code> are two measures of model fit that quantify the degree of correspondence between the configurations that are, in principle, compatible with a solution and the configurations contained in the data from which that solution is derived. 
</p>
  
<ul>
<li> <p><code>exhaustiveness</code> amounts to the ratio of the number of configurations in the data that are compatible with a solution to the number of configurations in total that are compatible with a solution.
</p>
</li>
<li> <p><code>faithfulness</code> amounts to the ratio of the number of configurations in the data that are compatible with a solution to the total number of configurations in the data.
</p>
</li></ul>
 
</li>
<li>  <p><code>coherence</code> measures the degree to which the asf combined in a csf cohere, i.e. are instantiated together in the data rather than independently of one another. For more details see <code><a href="#topic+coherence">coherence</a></code>. 
</p>
</li>
<li> <p><code>redundant</code> determines whether a csf contains structurally redundant proper parts. A csf with <code>redundant = TRUE</code> should not be causally interpreted. If <code>inus.only = TRUE</code>, all csf are free of structural redundancies.  For more details see <code><a href="#topic+redundant">redundant</a></code>. 
</p>
</li>
<li> <p><code>cyclic</code> determines whether a csf contains a cyclic substructure. For more details see <code><a href="#topic+cyclic">cyclic</a></code>.
</p>
</li></ul>

<p>The argument <code>notcols</code> is used to calculate asf and csf
for <b>negative outcomes</b> in data of <code>type</code> <code>"cs"</code> and <code>"fs"</code> (in <code>"mv"</code> data <code>notcols</code> has no meaningful interpretation and, correspondingly, issues an error message). If <code>notcols = "all"</code>, all factors in <code>x</code> are negated,
i.e. their membership scores i are replaced by 1-i. If <code>notcols</code> is given a character vector 
of factors in <code>x</code>, only the factors in that vector are negated. For example, <code>notcols = c("A", "B")</code>
determines that only factors A and B are negated. The default is no negations, i.e. <code>notcols = NULL</code>.
</p>
<p><code>suff.only</code> is applicable whenever a complete <code>cna</code> analysis cannot be performed for reasons of computational complexity. In such a case, <code>suff.only = TRUE</code> forces <code>cna</code> to stop the analysis after the identification of msc, which will normally yield results even in cases when a complete analysis does not terminate. In that manner, it is possible to shed at least some light on the dependencies among the factors in <code>x</code>, in spite of an incomputable solution space.
</p>
<p><code>rm.const.factors</code> and <code>rm.dup.factors</code> are used to determine the handling of <b>constant factors</b>, i.e. factors with constant values in all cases (rows) in <code>x</code>, and of <b>duplicated factors</b>, i.e. factors that take identical value distributions in all cases in <code>x</code>. As of package version 3.5.4, the default is <code>FALSE</code> for both <code>rm.const.factors</code> and <code>rm.dup.factors</code>. See <code><a href="#topic+configTable">configTable</a></code> for more details.
</p>
<p>If the data <code>x</code> feature noise, it can happen that all variation of an outcome occurs in noisy configurations in <code>x</code>. In such cases, there may be asfs that meet chosen consistency and coverage thresholds (lower than 1) such that the corresponding outcome only varies in configurations that are incompatible with the strict crisp-set or fuzzy-set necessity and sufficiency relations expressed by those very asfs. In the default setting <code>"cs"</code> of the argument <code>asf.selection</code> (introduced in version 3.5.0 of the <span class="pkg">cna</span> package), an asf is only returned if the outcome takes a value above and below the 0.5 anchor in the configurations compatible with the strict crisp-set necessity and sufficiency relations expressed by that asf. At <code>asf.selection = "fs"</code>, an asf is only returned if the outcome takes different values in the configurations compatible with the strict fuzzy-set necessity and sufficiency relations expressed by that asf. At <code>asf.selection = "none"</code>, asfs are returned even if outcome variation only occurs in noisy configurations, which was the default behavior of <code>cna</code> prior to version 3.5.0. (For more details, see examples below.)
</p>
<p>The argument <code>what</code> can be specified both for the <code>cna</code> and the <code>print()</code>
function. It regulates what items of the output of <code>cna</code> are printed. If
<code>what</code> is given the value &ldquo;<code>t</code>&rdquo;, the configuration table is printed; if
it is given an &ldquo;<code>m</code>&rdquo;, the msc are printed; if it is given an &ldquo;<code>a</code>&rdquo;, the asf are printed; if it is given a &ldquo;<code>c</code>&rdquo;, the csf are printed.
<code>what = "all"</code> or <code>what = "tmac"</code> determine that all output items are
printed. Note that <code>what</code> has no effect on the computations that are performed when executing <code>cna</code>; it only determines how the result is printed.
The default output of <code>cna</code> is <code>what = "ac"</code>. It first returns an implemented ordering or outcome specification. Second, the top 5 asf and, third, the top 5 csf are reported, along with an indication of how many solutions in total exist. To print all msc, asf, and csf, the corresponding functions in <code><a href="#topic+condTbl">condTbl</a></code> should be used. 
In case of <code>suff.only = TRUE</code>, <code>what</code> defaults to <code>"m"</code>. msc are printed with an attribute <code>minimal</code> specifying whether a sufficient condition is minimal as required by the INUS-theory of causation. If <code>inus.only = TRUE</code>, all msc are minimal by default. 
</p>
<p><code>cna</code> only includes factor configurations in the analysis that are actually instantiated in the data. The argument <code>cutoff</code> determines the minimum membership score required for a factor or a combination of factors to count as instantiated. It takes values in the unit interval [0,1] with a default of 0.5. <code>border</code> specifies whether configurations with membership scores equal to <code>cutoff</code> are rounded up (<code>border = "up"</code>), which is the default, rounded down (<code>border = "down"</code>), or dropped from the analysis (<code>border = "drop"</code>).
</p>
<p>The arguments <code>digits</code>, <code>nsolutions</code>, and <code>show.cases</code> apply to the <strong><code>print()</code> method</strong>, which takes an object of class &ldquo;cna&rdquo; as first input. <code>digits</code> determines how many digits of consistency, coverage, coherence, exhaustiveness, and faithfulness scores
are printed, while <code>nsolutions</code> fixes the number of conditions and solutions
to print. <code>nsolutions</code> applies separately to minimally sufficient conditions,
atomic solution formulas, and complex solution formulas. <code>nsolutions = "all"</code> recovers all minimally sufficient conditions, atomic and complex solution formulas. <code>show.cases</code> is applicable if the <code>what</code> argument is given the value &ldquo;<code>t</code>&rdquo;. In that case, <code>show.cases = TRUE</code> yields a configuration table featuring a &ldquo;cases&rdquo; column, which assigns cases to configurations.
</p>
<p>The option &ldquo;spaces&rdquo; controls how the conditions are rendered. The current setting is queried by typing <code>getOption("spaces")</code>. The option specifies characters that will be printed with a space before and after them. The default is <code>c("&lt;-&gt;","-&gt;","+")</code>. A more compact output is obtained with <code>option(spaces = NULL)</code>. 
</p>


<h3>Value</h3>

<p><code>cna</code> returns an object of class &ldquo;cna&rdquo;, which amounts to a list with the following elements:
</p>

<table>
<tr>
 <td style="text-align: right;">
<code>call</code>: </td><td style="text-align: left;"> the executed function call</td>
</tr>
<tr>
 <td style="text-align: right;">
<code>x</code>:</td><td style="text-align: left;"> the processed data frame or configuration table, as input to <code>cna</code></td>
</tr>
<tr>
 <td style="text-align: right;">
<code>ordering</code> </td><td style="text-align: left;"> the ordering imposed on the factors in the configuration table (if not <code>NULL</code>)</td>
</tr>
<tr>
 <td style="text-align: right;"> 
<code>notcols</code> </td><td style="text-align: left;"> the names of negated outcome factors (if not <code>NULL</code>)</td>
</tr>
<tr>
 <td style="text-align: right;"> 
<code>configTable</code>: </td><td style="text-align: left;"> the object of class &ldquo;configTable&rdquo;</td>
</tr>
<tr>
 <td style="text-align: right;">
<code>solution</code>: </td><td style="text-align: left;"> the solution object, which itself is composed of lists exhibiting msc, asf,</td>
</tr>
<tr>
 <td style="text-align: right;"></td><td style="text-align: left;"> and csf for all factors in <code>x</code></td>
</tr>
<tr>
 <td style="text-align: right;">
<code>what</code>:</td><td style="text-align: left;"> the values given to the <code>what</code> argument</td>
</tr>
<tr>
 <td style="text-align: right;">
<code>details</code>:</td><td style="text-align: left;"> the calculated solution attributes</td>
</tr>
<tr>
 <td style="text-align: right;">
<code>...</code>:</td><td style="text-align: left;"> plus additional list elements reporting the values given to the parameters <code>con</code>,</td>
</tr>
<tr>
 <td style="text-align: right;">
</td><td style="text-align: left;"> <code>cov</code>, <code>con.msc</code>, <code>inus.only</code>, <code>acyclic.only</code>, and <code>cycle.type</code>. 
  </td>
</tr>

</table>



<h3>Note</h3>

<p>In the first example described below (in <em>Examples</em>), the two resulting complex solution formulas represent a common cause structure and a causal chain, respectively. The common cause structure is graphically depicted in figure (a) below, the causal chain in figure (b).
</p>
<p><img src="../help/figures/structures.png" alt="Causal Structures" />

</p>


<h3>References</h3>

<p>Aleman, Jose. 2009. &ldquo;The Politics of Tripartite Cooperation in New Democracies: A Multi-level Analysis.&rdquo; <em>International Political Science Review</em> 30 (2):141-162.
</p>
<p>Basurto, Xavier. 2013. &ldquo;Linking Multi-Level Governance to Local Common-Pool 
Resource Theory using Fuzzy-Set Qualitative Comparative Analysis: Insights from 
Twenty Years of Biodiversity Conservation in Costa Rica.&rdquo; <em>Global Environmental Change</em> 23(3):573-87.
</p>
<p>Baumgartner, Michael. 2009a. &ldquo;Inferring Causal Complexity.&rdquo;
<em>Sociological Methods &amp; Research</em> 38(1):71-101.
</p>
<p>Baumgartner, Michael and Mathias Ambuehl. 2020. &ldquo;Causal Modeling with Multi-Value and Fuzzy-Set Coincidence Analysis.&rdquo; <em>Political Science Research and Methods</em>. 8:526&ndash;542.
</p>
<p>Baumgartner, Michael and Christoph Falk. 2023. &ldquo;Boolean Difference-Making: A Modern Regularity Theory of Causation&rdquo;. <em>The British Journal for the Philosophy of Science</em>, 74(1), 171-197. 
</p>
<p>Hartmann, Christof, and Joerg Kemmerzell. 2010. &ldquo;Understanding Variations 
in Party Bans in Africa.&rdquo; <em>Democratization</em> 17(4):642-65.
</p>
<p>Krook, Mona Lena. 2010.
&ldquo;Women's Representation in Parliament: A Qualitative Comparative Analysis.&rdquo;
<em>Political Studies</em> 58(5):886-908.
</p>
<p>Mackie, John L. 1974. <em>The Cement of the Universe: A Study of Causation.</em> Oxford: Oxford University Press.
</p>
<p>Parkkinen, Veli-Pekka and Michael Baumgartner. 2023. &ldquo;Robustness and Model Selection in Configurational Causal Modeling&rdquo;, <em>Sociological Methods &amp; Research</em>,  52(1), 176-208.
</p>
<p>Ragin, Charles C. 2006. &ldquo;Set Relations in Social Research: Evaluating Their Consistency and Coverage&rdquo;. <em>Political Analysis</em> 14(3):291-310.
</p>
<p>Wollebaek, Dag. 2010.
&ldquo;Volatility and Growth in Populations of Rural Associations.&rdquo;
<em>Rural Sociology</em> 75:144-166.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+configTable">configTable</a></code>, <code><a href="#topic+condition">condition</a></code>, <code><a href="#topic+cyclic">cyclic</a></code>, <code><a href="#topic+condTbl">condTbl</a></code>, <code><a href="#topic+selectCases">selectCases</a></code>, <code><a href="#topic+makeFuzzy">makeFuzzy</a></code>, <code><a href="#topic+some">some</a></code>,  <code><a href="#topic+coherence">coherence</a></code>,<br />
<code><a href="#topic+minimalizeCsf">minimalizeCsf</a></code>, <code><a href="#topic+randomConds">randomConds</a></code>, <code><a href="#topic+is.submodel">is.submodel</a></code>,  <code><a href="#topic+is.inus">is.inus</a></code>,  <code><a href="#topic+redundant">redundant</a></code>, <code><a href="#topic+full.ct">full.ct</a></code>, <code><a href="#topic+shortcuts">shortcuts</a></code>, <code><a href="#topic+d.educate">d.educate</a></code>,<br />
<code><a href="#topic+d.women">d.women</a></code>, <code><a href="#topic+d.pban">d.pban</a></code>, <code><a href="#topic+d.autonomy">d.autonomy</a></code>, <code><a href="#topic+d.highdim">d.highdim</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'># Ideal crisp-set data from Baumgartner (2009a) on education levels in western democracies
# ----------------------------------------------------------------------------------------
# Exhaustive CNA without constraints on the search space; print atomic and complex 
# solution formulas (default output).
cna.educate &lt;- cna(d.educate)
cna.educate
# The two resulting complex solution formulas represent a common cause structure 
# and a causal chain, respectively. The common cause structure is graphically depicted 
# in (Note, figure (a)), the causal chain in (Note, figure (b)).

# Print only complex solution formulas.
print(cna.educate, what = "c")

# Print only atomic solution formulas.
print(cna.educate, what = "a")

# Print only minimally sufficient conditions.
print(cna.educate, what = "m")

# Print only the configuration table.
print(cna.educate, what = "t")

# CNA with negations of the factors E and L.
cna(d.educate, notcols = c("E","L"))
# The same by use of the outcome argument.
cna(d.educate, outcome = c("e","l"))

# CNA with negations of all factors.
cna(d.educate, notcols = "all")

# Print msc, asf, and csf with all solution attributes.
cna(d.educate, what = "mac", details = TRUE)

# Add only the non-standard solution attributes "exhaustiveness" and  "faithfulness".
cna(d.educate, details = c("e", "f"))

# Print solutions without spaces before and after "+".
options(spaces = c("&lt;-&gt;", "-&gt;" ))
cna(d.educate, details = c("e", "f"))

# Print solutions with spaces before and after "*".
options(spaces = c("&lt;-&gt;", "-&gt;", "*" ))
cna(d.educate, details = c("e", "f"))

# Restore the default of the option "spaces".
options(spaces = c("&lt;-&gt;", "-&gt;", "+"))



# Crisp-set data from Krook (2010) on representation of women in western-democratic parliaments
# ------------------------------------------------------------------------------------------
# This example shows that CNA can distinguish exogenous and endogenous factors in the data.
# Without being told which factor is the outcome, CNA reproduces the original QCA 
# of Krook (2010).
ana1 &lt;- cna(d.women, details = c("e", "f"))
ana1

# The two resulting asf only reach an exhaustiveness score of 0.438, meaning that
# not all configurations that are compatible with the asf are contained in the data
# "d.women". Here is how to extract the configurations that are compatible with 
# the first asf but are not contained in "d.women".
library(dplyr)
setdiff(ct2df(selectCases(asf(ana1)$condition[1], full.ct(d.women))),
        d.women)


# Highly ambiguous crisp-set data from Wollebaek (2010) on very high volatility of 
# grassroots associations in Norway
# --------------------------------------------------------------------------------
# csCNA with ordering from Wollebaek (2010) [Beware: due to massive ambiguities, this analysis
# will take about 20 seconds to compute.]
cna(d.volatile, ordering = "VO2", maxstep = c(6, 6, 16))
              
# Using suff.only, CNA can be forced to abandon the analysis after minimization of sufficient 
# conditions. [This analysis terminates quickly.]
cna(d.volatile, ordering = "VO2", maxstep = c(6, 6, 16), suff.only = TRUE)

# Similarly, by using the default maxstep, CNA can be forced to only search for asf and csf
# with reduced complexity.
cna(d.volatile, ordering = "VO2")

# ordering = "VO2" only excludes that the values of VO2 are causes of the values
# of the other factors in d.volatile, but cna() still tries to model other factor 
# values as outcomes. The following call determines that only VO2 is a possible 
# outcome. (This call terminates quickly.)
cna(d.volatile, outcome = "VO2")

# We can even increase maxstep.
cna(d.volatile, outcome = "VO2", maxstep=c(4,4,16))

# If it is known that, say, el and od cannot be causes of VO2, we can exclude this.
cna(d.volatile, outcome = "VO2", maxstep=c(4,4,16), exclude = "el, od -&gt; VO2")

# The verbose argument returns information during the execution of cna().
cna(d.volatile, ordering = "VO2", verbose = TRUE)


# Multi-value data from Hartmann &amp; Kemmerzell (2010) on party bans in Africa
# ---------------------------------------------------------------------------
# mvCNA with an outcome specification taken from Hartmann &amp; Kemmerzell 
# (2010); coverage cutoff at 0.95 (consistency cutoff at 1), maxstep at c(6, 6, 10).
cna.pban &lt;- cna(d.pban, outcome = "PB=1", cov = .95, maxstep = c(6, 6, 10), 
                  what = "all")
cna.pban

# The previous function call yields a total of 14 asf and csf, only 5 of which are 
# printed in the default output. Here is how to extract all 14 asf and csf.
asf(cna.pban)
csf(cna.pban)

# [Note that all of these 14 causal models reach better consistency and 
# coverage scores than the one model Hartmann &amp; Kemmerzell (2010) present in their paper, 
# which they generated using the TOSMANA software, version 1.3. 
# T=0 + T=1 + C=2 + T=1*V=0 + T=2*V=0 &lt;-&gt; PB=1]
condTbl("T=0 + T=1 + C=2 + T=1*V=0 + T=2*V=0 &lt;-&gt; PB = 1", d.pban)

# Extract all minimally sufficient conditions.
msc(cna.pban)

# Alternatively, all msc, asf, and csf can be recovered by means of the nsolutions
# argument of the print function.
print(cna.pban, nsolutions = "all")

# Print the configuration table with the "cases" column.
print(cna.pban, what = "t", show.cases = TRUE)

# Build solution formulas with maximally 4 disjuncts.
cna(d.pban, outcome = "PB=1", cov = .95, maxstep = c(4, 4, 10))

# Only print 2 digits of consistency and coverage scores.
print(cna.pban, digits = 2)

# Build all but print only two msc for each factor and two asf and csf.
print(cna(d.pban, outcome = "PB=1", cov = .95,
      maxstep = c(6, 6, 10), what = "all"), nsolutions = 2)

# Lowering the consistency instead of the coverage threshold yields further models with
# excellent fit scores; print only asf.
cna(d.pban, outcome = "PB=1", con = .93, what = "a", maxstep = c(6, 6, 10))

# Lowering both consistency and coverage. 
cna(d.pban, outcome = "PB=1", con = .9, cov =.9, maxstep = c(6, 6, 10))

# Lowering both consistency and coverage and excluding F=0 as potential cause of PB=1.
cna(d.pban, outcome = "PB=1", con = .9, cov =.9, maxstep = c(6, 6, 10), 
    exclude = "F=0 -&gt; PB=1")
      
# Specifying an outcome is unnecessary for d.pban. PB=1 is the only 
# factor value in those data that could possibly be an outcome.
cna(d.pban, con=.9, cov = .9, maxstep = c(6, 6, 10))


# Fuzzy-set data from Basurto (2013) on autonomy of biodiversity institutions in Costa Rica
# ---------------------------------------------------------------------------------------
# Basurto investigates two outcomes: emergence of local autonomy and endurance thereof. The 
# data for the first outcome are contained in rows 1-14 of d.autonomy, the data for the second
# outcome in rows 15-30. For each outcome, the author distinguishes between local ("EM",  
# "SP", "CO"), national ("CI", "PO") and international ("RE", "CN", "DE") conditions. Here,   
# we first apply fsCNA to replicate the analysis for the local conditions of the endurance of 
# local autonomy.
dat1 &lt;- d.autonomy[15:30, c("AU","EM","SP","CO")]
cna(dat1, ordering = "AU", strict = TRUE, con = .9, cov = .9)

# The fsCNA model has significantly better consistency (and equal coverage) scores than the 
# model presented by Basurto (p. 580): SP*EM + CO &lt;-&gt; AU, which he generated using the 
# fs/QCA software.
condition("SP*EM + CO &lt;-&gt; AU", dat1) # both EM and CO are redundant to account for AU

# If we allow for dependencies among the conditions by setting strict = FALSE, CNA reveals 
# that SP is a common cause of both AU and EM.
cna(dat1, ordering = "AU", strict = FALSE, con = .9, cov = .9)

# Here is the analysis for the international conditions of autonomy endurance, which
# yields the same model as the one presented by Basurto (plus one model Basurto does not mention).
dat2 &lt;- d.autonomy[15:30, c("AU","RE", "CN", "DE")]
cna(dat2, ordering = "AU", con = .9, con.msc = .85, cov = .85)

# But there are other models (here printed with all solution attributes)
# that fare equally well.
cna(dat2, ordering = "AU", con = .85, cov = .9, details = TRUE)

# Finally, here is an analysis of the whole dataset, showing that across the whole period 
# 1986-2006, the best causal model of local autonomy (AU) renders that outcome dependent
# only on local direct spending (SP).
cna(d.autonomy, outcome = "AU", con = .85, cov = .9, 
      maxstep = c(5, 5, 11), details = TRUE)

# Also build non-INUS solutions.
asf(cna(d.autonomy, outcome = "AU", con = .85, cov = .9, 
      maxstep = c(5, 5, 11), details = TRUE, inus.only = FALSE))
      
      
# High-dimensional data
# ---------------------
# As of package version 3.1, cna's handling of data with more than 20 factors
# has been improved. Here's an analysis of the data d.highdim with 50 factors, massive 
# fragmentation, and 20% noise. (Takes about 15 seconds to compute.)
head(d.highdim)
cna(d.highdim,  outcome = c("V13", "V11"), con = .8, cov = .8)

# By lowering maxstep, computation time can be reduced to less than 1 second
# (at the cost of an incomplete solution).
cna(d.highdim,  outcome = c("V13", "V11"), con = .8, cov = .8,
  maxstep = c(2,3,10))      


# Highly ambiguous artificial data to illustrate exhaustiveness and acyclic.only
# ------------------------------------------------------------------------------
mycond &lt;- "(D + C*f &lt;-&gt; A)*(C*d + c*D &lt;-&gt; B)*(B*d + D*f &lt;-&gt; C)*(c*B + B*f &lt;-&gt; E)"
dat1 &lt;- selectCases(mycond)
ana1 &lt;- cna(dat1, details = c("e","cy"))
# There exist almost 2M csf. This is how to build the first 1076 of them, with 
# additional messages about the csf building process.
first.csf &lt;- csf(ana1, verbose = TRUE)
first.csf
# Most of these csf are compatible with more configurations than are contained in 
# dat1. Only 193 csf in first.csf are perfectly exhaustive (i.e. all compatible 
# configurations are contained in dat1).
subset(first.csf, exhaustiveness == 1)

# 1020 of the csf in first.csf contain cyclic substructures.
subset(first.csf, cyclic == TRUE)

# Here's how to only build acyclic csf.
ana2 &lt;- cna(dat1, details = c("e","cy"), acyclic.only = TRUE)
csf(ana2, verbose = TRUE)


# Illustration of only.minimal.msc = FALSE
# ----------------------------------------
# Simulate noisy data on the causal structure "a*B*d + A*c*D &lt;-&gt; E"
set.seed(1324557857)
mydata &lt;- allCombs(rep(2, 5)) - 1
dat1 &lt;- makeFuzzy(mydata, fuzzvalues = seq(0, 0.5, 0.01))
dat1 &lt;- ct2df(selectCases1("a*B*d + A*c*D &lt;-&gt; E", con = .8, cov = .8, dat1))

# In dat1, "a*B*d + A*c*D &lt;-&gt; E" has the following con and cov scores.
as.condTbl(condition("a*B*d + A*c*D &lt;-&gt; E", dat1))

# The standard algorithm of CNA will, however, not find this structure with
# con = cov = 0.8 because one of the disjuncts (a*B*d) does not meet the con
# threshold.
as.condTbl(condition(c("a*B*d &lt;-&gt; E", "A*c*D &lt;-&gt; E"), dat1))
cna(dat1, outcome = "E", con = .8, cov = .8)

# With the argument con.msc we can lower the con threshold for msc, but this does not
# recover "a*B*d + A*c*D &lt;-&gt; E" either.
cna2 &lt;- cna(dat1, outcome = "E", con = .8, cov = .8, con.msc = .78)
cna2
msc(cna2)

# The reason is that "A*c -&gt; E" and "c*D -&gt; E" now also meet the con.msc threshold and,
# therefore,  "A*c*D -&gt; E" is not contained in the msc---because of violated minimality.
# In a situation like this, lifting the minimality requirement via 
# only.minimal.msc = FALSE allows CNA to find the intended target.
cna(dat1, outcome = "E", con = .8, cov = .8, con.msc = .78,
      only.minimal.msc = FALSE)


# Overriding automatic detection of the data type
# ------------------------------------------------
# The type argument allows for manually setting the data type.
# If "cs" data are treated as "mv" data, cna() automatically builds models for all values
# of outcome factors, i.e. both positive and negated outcomes.
cna(d.educate, type = "mv")
# Treating "cs" data as "fs".
cna(d.women, type = "fs")

# Not all manual settings are admissible. 
try(cna(d.autonomy, outcome = "AU", con = .8, cov = .8, type = "mv" ))

# Shortcut functions from previous versions of the package continue to work 
# (see ?shortcuts).
fscna(d.autonomy, outcome = "AU", con = .8, cov = .8)
mvcna(d.pban, outcome = "PB=1", con = .8)


# Illustration of asf.selection
# -----------------------------
# Consider the following data set:
d1 &lt;- data.frame(X1 = c(1, 0, 1),
                 X2 = c(0, 1, 0), 
                 Y = c(1, 1, 0))
ct1 &lt;- configTable(d1, frequency = c(10, 10, 1))

# Both of the following are asfs reaching con=0.95 and cov=1.
condition(c("X1+X2&lt;-&gt;Y", "x1+x2&lt;-&gt;Y"), ct1)

# Up to version 3.4.0 of the cna package, these two asfs were inferred from 
# ct1 by cna(). But the outcome Y is constant in ct1, except for a variation in 
# the third row, which is incompatible with X1+X2&lt;-&gt;Y and x1+x2&lt;-&gt;Y. Subject to  
# both of these models, the third row of ct1 is a noisy configuration. Inferring
# difference-making models that are incapable of accounting for the only difference
# in the outcome in the data is inadequate. (Thanks to Luna De Souter for 
# pointing out this problem.) Hence, as of version 3.5.0, asfs whose outcome only
# varies in configurations incompatible with the strict crisp-set necessity 
# or sufficiency relations expressed by those asfs are not returned anymore.

cna(ct1, outcome = "Y", con = 0.9)

# The old behavior of cna() can be obtained by setting the argument asf.selection
# to its non-default value "none".

cna(ct1, outcome = "Y", con = 0.9, asf.selection = "none")

# Analysis of fuzzy-set data from Aleman (2009).
cna(d.pacts, con = .9, cov = .85)
cna(d.pacts, con = .9, cov = .85, asf.selection = "none")
# In the default setting, cna() does not return any model for d.pacts because
# the outcome takes a value &gt;0.5 in every single case, meaning it does not change
# between presence and absence. No difference-making model should be inferred from
# such data. 
# The implications of asf.selection can also be traced by
# the verbose argument:

cna(d.pacts, con = .9, cov = .85, verbose = TRUE)

</code></pre>

<hr>
<h2 id='cna-deprecated'>Deprecated functions in the cna package</h2><span id='topic+cna-deprecated'></span><span id='topic+truthTab'></span><span id='topic+cstt'></span><span id='topic+fstt'></span><span id='topic+mvtt'></span><span id='topic+full.tt'></span><span id='topic+tt2df'></span>

<h3>Description</h3>

<p>These functions are provided for compatibility with older versions of the <span class="pkg">cna</span> package only, and may be removed eventually. Commands that worked in versions of the <span class="pkg">cna</span> package prior to version 3.0.0 will not necessarily work in version 3.0.0 and beyond, or may not work in the same manner.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>truthTab(...)
cstt(...)
fstt(...)
mvtt(...)

full.tt(...)
tt2df(...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cna-deprecated_+3A_...">...</code></td>
<td>
<p>Arguments passed to renamed functions. See the corresponding help pages for help.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>truthTab</code> has been replaced by <code><a href="#topic+configTable">configTable</a></code>.
<code>cstt</code> has been replaced by <code><a href="#topic+csct">csct</a></code>.
<code>fstt</code> has been replaced by <code><a href="#topic+fsct">fsct</a></code>.
<code>mvtt</code> has been replaced by <code><a href="#topic+mvct">mvct</a></code>.
</p>
<p><code>full.tt</code> has been replaced by <code><a href="#topic+full.ct">full.ct</a></code>.
<code>tt2df</code> has been replaced by <code><a href="#topic+ct2df">ct2df</a></code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+configTable">configTable</a></code>, <code><a href="#topic+full.ct">full.ct</a></code>, <code><a href="#topic+ct2df">ct2df</a></code></p>

<hr>
<h2 id='cna-internals'>Internal functions in the cna package</h2><span id='topic+cna-internals'></span><span id='topic+getCond'></span><span id='topic+noblanks'></span><span id='topic+rhs'></span><span id='topic+lhs'></span><span id='topic+extract_asf'></span><span id='topic+ctInfo'></span><span id='topic+qcond_csf'></span><span id='topic+qcond_asf'></span><span id='topic+qcond_bool'></span><span id='topic+stdCond'></span><span id='topic+matchCond'></span><span id='topic+fs2cs'></span><span id='topic+C_recCharList2char'></span><span id='topic+C_relist_Int'></span><span id='topic+relist1'></span><span id='topic+C_mconcat'></span><span id='topic+hstrsplit'></span><span id='topic+C_redund'></span><span id='topic+getComplexity'></span><span id='topic+getCondType'></span><span id='topic+C_is_submodel'></span>

<h3>Description</h3>

<p>These functions are mainly for internal purposes and will not normally be called directly by the user.
</p>


<h3>Overview of Functions</h3>


<dl>
<dt><code>noblanks</code>, <code>lhs</code>, <code>rhs</code>, <code>extract_asf</code>:</dt><dd>
<p>Manipulation of character vectors containing conditions.
</p>
</dd>
<dt><code>ctInfo</code>:</dt><dd>
<p>Alternative internal represenation of a <code><a href="#topic+configTable">configTable</a></code>.
</p>
</dd>
<dt><code>qcond_bool</code>, <code>qcond_asf</code>, <code>qcond_csf</code>:</dt><dd>
<p>Fast evaluation of certain aspects of the well-formedness of conditions.
</p>
</dd>
<dt><code>getCondType</code>, <code>getComplexity</code>:</dt><dd>
<p>Extract condition type and complexity values from a character vector containing conditions.
</p>
</dd>
<dt><code>fs2cs</code>:</dt><dd>
<p>Convert an &ldquo;fs&rdquo; configTable to &ldquo;cs&rdquo;.
</p>
</dd>
<dt><code>stdCond</code>, <code>matchCond</code>:</dt><dd>
<p>Standardize and match conditions.
</p>
</dd>
<dt><code>relist1</code>, <code>hstrsplit</code>, <code>C_mconcat</code>, <code>C_recCharList2char</code>, <code>C_relist_Int</code>:</dt><dd>
<p>Utility functions for conversion between different represenations of conditions.
</p>
</dd>
<dt><code>C_redund</code>:</dt><dd>
<p>Internal version of the test for structural redundancy (used in <code><a href="#topic+redundant">redundant</a>)</code>.
</p>
</dd>
<dt><code>getCond</code>:</dt><dd>
<p>Derive a condition from a data set. 
</p>
</dd>
<dt><code>C_is_submodel</code>:</dt><dd>
<p>Internal core of the function <code><a href="#topic+is.submodel">is.submodel</a></code>. 
</p>
</dd>
</dl>


<hr>
<h2 id='coherence'>
Calculate the coherence of complex solution formulas
</h2><span id='topic+coherence'></span><span id='topic+coherence.default'></span><span id='topic+coherence.cti'></span>

<h3>Description</h3>

<p>Calculates the coherence measure of complex solution formulas (csf).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>coherence(x, ...)
## Default S3 method:
coherence(x, ct, type, ..., tt)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="coherence_+3A_x">x</code></td>
<td>
<p>Character vector specifying an asf or csf.</p>
</td></tr>
<tr><td><code id="coherence_+3A_ct">ct</code></td>
<td>
<p>Data frame or <code>configTable</code>.</p>
</td></tr>
<tr><td><code id="coherence_+3A_type">type</code></td>
<td>
<p>Character vector specifying the type of <code>x</code>: <code>"auto"</code> (automatic detection; default), <code>"cs"</code> (crisp-set), <code>"mv"</code> (multi-value),  or <code>"fs"</code> (fuzzy-set).</p>
</td></tr>
<tr><td><code id="coherence_+3A_...">...</code></td>
<td>
<p>Arguments passed to methods.</p>
</td></tr>
<tr><td><code id="coherence_+3A_tt">tt</code></td>
<td>
<p>Argument <code>tt</code> is deprecated in <code>coherence()</code>; use <code>x</code> instead.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Coherence is a measure for model fit that is custom-built for complex solution formulas (csf). It measures the degree to which the atomic solution formulas (asf) combined in a csf cohere, i.e. are instantiated together in <code>x</code> rather than independently of one another. More concretely, coherence is the ratio of the number of cases satisfying all asf contained in a csf to the number of cases satisfying at least one asf in the csf. For example, if the csf contains the three asf asf1, asf2, asf3, coherence amounts to | asf1 * asf2 * asf3 | / | asf1 + asf2 + asf3 |, where |...| expresses the cardinality of the set of cases in <code>x</code> instantiating the corresponding expression. For asf, <code>coherence</code> returns 1. For boolean conditions (see <code><a href="#topic+condition">condition</a></code>), the coherence measure is not defined and <code>coherence</code> hence returns <code>NA</code>. For multiple csf that do not have a factor in common, <code>coherence</code> returns the minimum of the separate coherence scores. 
</p>


<h3>Value</h3>

<p>Numeric vector of coherence values to which <code>cond</code> is appended as a &quot;names&quot; attribute. If <code>cond</code> is a <em>csf</em> &quot;asf1*asf2*asf3&quot; composed of asf that do not have a factor in common, the <em>csf</em> is rendered with commas in the &quot;names&quot; attribute: &quot;asf1, asf2, asf3&quot;.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+cna">cna</a></code>, <code><a href="#topic+condition">condition</a></code>, <code><a href="#topic+selectCases">selectCases</a></code>, <code><a href="#topic+allCombs">allCombs</a></code>, <code><a href="#topic+full.ct">full.ct</a></code>, <code><a href="#topic+condTbl">condTbl</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'># Perfect coherence.
dat1 &lt;- selectCases("(A*b &lt;-&gt; C)*(C + D &lt;-&gt; E)")
coherence("(A*b &lt;-&gt; C)*(C + D &lt;-&gt; E)", dat1)
csf(cna(dat1, details = "coherence"))

# Non-perfect coherence.
dat2 &lt;- selectCases("(a*B &lt;-&gt; C)*(C + D &lt;-&gt; E)*(F*g &lt;-&gt; H)")
dat3 &lt;- rbind(ct2df(dat2), c(0,1,0,1,1,1,0,1))
coherence("(a*B &lt;-&gt; C)*(C + D &lt;-&gt; E)*(F*g &lt;-&gt; H)", dat3)
csf(cna(dat3, con = .88, details = "coherence")) 
</code></pre>

<hr>
<h2 id='condition'>
Uncover relevant properties of msc, asf, and csf in a data frame or <code>configTable</code>
</h2><span id='topic+condition'></span><span id='topic+condition.default'></span><span id='topic+condition.condTbl'></span><span id='topic+print.condList'></span><span id='topic+print.cond'></span>

<h3>Description</h3>

<p>The <code>condition</code> function provides assistance to inspect the properties of msc, asf, and csf (as returned by <code><a href="#topic+cna">cna</a></code>) in a data frame or <code>configTable</code>, but also of any other Boolean function. <code>condition</code> reveals which configurations and cases instantiate a given msc, asf, or csf and lists consistency and coverage scores. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>condition(x, ...)

## Default S3 method:
condition(x, ct, type, add.data = FALSE,
          force.bool = FALSE, rm.parentheses = FALSE, ..., tt)
## S3 method for class 'condTbl'
condition(x, ct, ...)

## S3 method for class 'condList'
print(x, ...)
## S3 method for class 'cond'
print(x, digits = 3, print.table = TRUE, 
      show.cases = NULL, add.data = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="condition_+3A_x">x</code></td>
<td>
<p>Character vector specifying a Boolean expression as <code>"A + B*C -&gt; D"</code>, where <code>"A"</code>, <code>"B"</code>, <code>"C"</code>, <code>"D"</code> are factor values appearing in <code>ct</code>.</p>
</td></tr>
<tr><td><code id="condition_+3A_ct">ct</code></td>
<td>
<p>Data frame or <code>configTable</code> (see <code><a href="#topic+configTable">configTable</a></code>).</p>
</td></tr>
<tr><td><code id="condition_+3A_type">type</code></td>
<td>
<p>Character vector specifying the type of <code>x</code>: <code>"auto"</code> (automatic detection; default), <code>"cs"</code> (crisp-set), <code>"mv"</code> (multi-value),  or <code>"fs"</code> (fuzzy-set).</p>
</td></tr>
<tr><td><code id="condition_+3A_add.data">add.data</code></td>
<td>
<p>Logical; if <code>TRUE</code>, <code>ct</code> is attached to the output. Alternatively, <code>ct</code> can be requested by the <code>add.data</code> argument in <code>print.cond</code>.</p>
</td></tr>
<tr><td><code id="condition_+3A_force.bool">force.bool</code></td>
<td>
<p>Logical; if <code>TRUE</code>, <code>x</code> is interpreted as a mere Boolean function, not as a causal model.</p>
</td></tr> 
<tr><td><code id="condition_+3A_rm.parentheses">rm.parentheses</code></td>
<td>
<p>Logical; if <code>TRUE</code>, parentheses around <code>x</code> are removed prior to evaluation.</p>
</td></tr>
<tr><td><code id="condition_+3A_digits">digits</code></td>
<td>
<p>Number of digits to print in consistency and coverage scores.</p>
</td></tr>
<tr><td><code id="condition_+3A_print.table">print.table</code></td>
<td>
<p>Logical; if <code>TRUE</code>, the table assigning configurations and cases to conditions is printed.</p>
</td></tr>
<tr><td><code id="condition_+3A_show.cases">show.cases</code></td>
<td>
<p>Logical; if <code>TRUE</code>, the attribute &ldquo;cases&rdquo; of the <code>configTable</code> is printed; same default behavior as in <code><a href="#topic+print.configTable">print.configTable</a></code>.</p>
</td></tr>
<tr><td><code id="condition_+3A_...">...</code></td>
<td>
<p>Arguments passed to methods.</p>
</td></tr>
<tr><td><code id="condition_+3A_tt">tt</code></td>
<td>
<p>Argument <code>tt</code> is deprecated in <code>condition()</code>; use <code>ct</code> instead.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Depending on the processed data frame or <code>configTable</code>, the solutions output by <code><a href="#topic+cna">cna</a></code> are often ambiguous; that is, it can happen that many solution formulas fit the data equally well. If that happens, the data alone are insufficient to single out one solution. While <code><a href="#topic+cna">cna</a></code> simply lists the possible solutions, the <code>condition</code> function is intended to provide assistance in comparing different minimally sufficient conditions (msc), atomic solution formulas (asf), and complex solution formulas (csf) in order to have a better basis for selecting among them. 
</p>
<p>Most importantly, the output of the <code>condition</code> function highlights in which configurations and cases in the data an msc, asf, and csf is instantiated. Thus, if the user has independent causal knowledge about particular configurations or cases, the information received from <code>condition</code> may be helpful in selecting the solutions that are consistent with that knowledge. Moreover, the <code>condition</code> function allows for directly contrasting consistency and coverage scores or frequencies of different conditions contained in returned asf. 
</p>
<p>The <code>condition</code> function is independent of <code><a href="#topic+cna">cna</a></code>. That is, any msc, asf, or csf&mdash;irrespective of whether they are output by <code><a href="#topic+cna">cna</a></code>&mdash;can be given as input to <code>condition</code>. Even Boolean expressions that do not have the syntax of CNA solution formulas can be passed to <code>condition</code>. 
</p>
<p>The first required input <code>x</code> of <code>condition</code> is a character vector consisting of Boolean formulas composed of factor values that appear in <code>ct</code>, which is the second required input. <code>ct</code> can be a <code>configTable</code> or a data frame. If <code>ct</code> is a data frame and the <code>type</code> argument has its default value <code>"auto"</code>, <code>condition</code> first determines the data type and then converts the data frame to a <code>configTable</code>. The data type can also be manually specified by giving the <code>type</code> argument one of the values <code>"cs"</code>, <code>"mv"</code>, or <code>"fs"</code>.
</p>
<p>Conjunction can be expressed by &ldquo;<code>*</code>&rdquo; or &ldquo;<code>&amp;</code>&rdquo;, disjunction by &ldquo;<code>+</code>&rdquo; or &ldquo;<code>|</code>&rdquo;, negation can be expressed by &ldquo;<code>-</code>&rdquo; or &ldquo;<code>!</code>&rdquo; or, in case of crisp-set or fuzzy-set data, by changing upper case into lower case letters and vice versa, implication by &ldquo;<code>-&gt;</code>&rdquo;, and equivalence by &ldquo;<code>&lt;-&gt;</code>&rdquo;. Examples are </p>

<ul>
<li> <p><code>A*b -&gt; C, A+b*c+!(C+D),  A*B*C + -(E*!B), C -&gt; A*B + a*b</code>
</p>
</li>
<li> <p><code>(A=2*B=4 + A=3*B=1 &lt;-&gt; C=2)*(C=2*D=3 + C=1*D=4 &lt;-&gt; E=3)</code>
</p>
</li>
<li> <p><code>(A=2*B=4*!(A=3*B=1)) | !(C=2|D=4)*(C=2*D=3 + C=1*D=4 &lt;-&gt; E=3)</code>
</p>
</li></ul>

<p>Three types of conditions are distinguished:
</p>

<ul>
<li><p> The type <em>boolean</em> comprises Boolean expressions that do not have the syntactic form of causal models, meaning the corresponding character strings in the argument <code>x</code> do not have an &ldquo;<code>-&gt;</code>&rdquo; or &ldquo;<code>&lt;-&gt;</code>&rdquo; as main operator. Examples: <code>"A*B + C"</code> or <code>"-(A*B + -(C+d))"</code>. The expression is evaluated and written into a data frame with one column. Frequency is attached to this data frame as an attribute. 
</p>
</li>
<li><p> The type <em>atomic</em> comprises expressions that have the syntactic form of atomic causal models, i.e. asf, meaning the corresponding character strings in the argument <code>x</code> have an &ldquo;<code>-&gt;</code>&rdquo; or &ldquo;<code>&lt;-&gt;</code>&rdquo; as main operator. Examples: <code>"A*B + C -&gt; D"</code> or <code>"A*B + C &lt;-&gt; D"</code>. The expressions on both sides of &ldquo;<code>-&gt;</code>&rdquo; and &ldquo;<code>&lt;-&gt;</code>&rdquo; are evaluated and written into a data frame with two columns. Consistency and coverage are attached to these data frames as attributes.
</p>
</li>
<li><p> The type <em>complex</em> represents complex causal models, i.e. csf. Example:<br /> <code>"(A*B + a*b &lt;-&gt; C)*(C*d + c*D &lt;-&gt; E)"</code>. Each component must be a causal model of type <em>atomic</em>. These components are evaluated separately and the results stored in a list. Consistency and coverage of the complex expression are then attached to this list.
</p>
</li></ul>

<p>The types of the character strings in the input <code>x</code> are automatically discerned and thus do not need to be specified by the user.
</p>
<p>If <code>force.bool = TRUE</code>, expressions with &ldquo;<code>-&gt;</code>&rdquo; or &ldquo;<code>&lt;-&gt;</code>&rdquo; are treated as type <em>boolean</em>, i.e. only their frequencies are calculated. Enclosing a character string representing a causal model in parentheses has the same effect as specifying <code>force.bool = TRUE</code>. <code>rm.parentheses = TRUE</code> removes parentheses around the expression prior to evaluation, and thus has the reverse effect of setting <code>force.bool = TRUE</code>.
</p>
<p>If <code>add.data = TRUE</code>, <code>ct</code> is appended to the output such as to facilitate the analysis and evaluation of a model on the case level.
</p>
<p>The <code>digits</code> argument of the <code>print</code> method determines how many digits of consistency and coverage scores are printed. If <code>print.table = FALSE</code>, the table assigning conditions to configurations and cases is omitted, i.e. only frequencies or consistency and coverage scores are returned. <code>row.names = TRUE</code> also lists the row names in <code>ct</code>. If rows in a <code>ct</code> are instantiated by many cases, those cases are not printed by default. They can be recovered by <code>show.cases = TRUE</code>.
</p>


<h3>Value</h3>

<p><code>condition</code> returns a nested list of objects, each of them corresponding to one element of the input vector <code>x</code>. The list has a class attribute &ldquo;condList&rdquo;, the list elements (i.e., the individual conditions) are of class &ldquo;cond&rdquo; and have a more specific class label &ldquo;booleanCond&rdquo;, &ldquo;atomicCond&rdquo; or &ldquo;complexCond&rdquo;, relfecting the type of condition. The components of class &ldquo;booleanCond&rdquo; or &ldquo;atomicCond&rdquo; are amended data frames, those of class &ldquo;complexCond&rdquo; are lists of amended data frames.
</p>


<h3><code>print</code> method</h3>

<p><code>print.condList</code> essentially executes <code>print.cond</code> (the method printing a single condition)
successively for each list element/condition. All arguments in <code>print.condList</code> are thereby passed to <code>print.cond</code>, i.e. <code>digits</code>, <code>print.table</code>, <code>show.cases</code>, <code>add.data</code> can also be specified when printing the complete list of conditions.
</p>
<p>The option &ldquo;spaces&rdquo; controls how the conditions are rendered in certain contexts. The current setting is queried by typing <code>getOption("spaces")</code>. The option specifies characters that will be printed with a space before and after them. The default is <code>c("&lt;-&gt;","-&gt;","+")</code>. A more compact output is obtained with <code>option(spaces = NULL)</code>. 
</p>


<h3>References</h3>

<p>Emmenegger, Patrick. 2011. &ldquo;Job Security Regulations in Western Democracies: 
A Fuzzy Set Analysis.&rdquo; <em>European Journal of Political Research</em> 50(3):336-64.
</p>
<p>Lam, Wai Fung, and Elinor Ostrom. 2010.
&ldquo;Analyzing the Dynamic Complexity of Development Interventions: Lessons
from an Irrigation Experiment in Nepal.&rdquo;
<em>Policy Sciences</em> 43 (2):1-25.
</p>
<p>Ragin, Charles. 2008.
<em>Redesigning Social Inquiry: Fuzzy Sets and Beyond</em>. Chicago, IL:
University of Chicago Press.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+condList-methods">condList-methods</a></code> describes methods and functions processing the output of <code>condition</code>; see, in particular, the related <code>summary</code> and <code>as.data.frame</code> methods.
</p>
<p><code><a href="#topic+cna">cna</a></code>, <code><a href="#topic+configTable">configTable</a></code>, <code><a href="#topic+condTbl">condTbl</a></code>, <code><a href="#topic+as.data.frame.condList">as.data.frame.condList</a></code>, <code><a href="#topic+d.irrigate">d.irrigate</a></code>, <code><a href="#topic+shortcuts">shortcuts</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'># Crisp-set data from Lam and Ostrom (2010) on the impact of development interventions 
# ------------------------------------------------------------------------------------
# Build the configuration table for d.irrigate.
irrigate.ct &lt;- configTable(d.irrigate)

# Any Boolean functions involving values of the factors "A", "R", "F", "L", "C", "W" in 
# d.irrigate can be tested by condition().
condition("A*r + L*C", irrigate.ct)
condition(c("A*r + !(L*C)", "A*-(L | -F)", "C -&gt; A*R + C*l"), irrigate.ct)
condition(c("A*r + L*C -&gt; W", "!(A*L*R -&gt; W)", "(A*R + C*l &lt;-&gt; F)*(W*a -&gt; F)"),
          irrigate.ct)

# Group expressions with "-&gt;" by outcome.
irrigate.con &lt;- condition(c("A*r + L*C -&gt; W", "A*L*R -&gt; W", "A*R + C*l -&gt; F", "W*a -&gt; F"),
                          irrigate.ct)
group.by.outcome(irrigate.con)

# Pass minimally sufficient conditions inferred by cna() to condition().
irrigate.cna1 &lt;- cna(d.irrigate, ordering = "A, R, L &lt; F, C &lt; W", con = .9)
condition(msc(irrigate.cna1)$condition, irrigate.ct)

# Pass atomic solution formulas inferred by cna() to condition().
irrigate.cna1 &lt;- cna(d.irrigate, ordering = "A, R, L &lt; F, C &lt; W", con = .9)
condition(asf(irrigate.cna1)$condition, irrigate.ct)

# Group by outcome.
irrigate.cna1.msc &lt;- condition(msc(irrigate.cna1)$condition, irrigate.ct)
group.by.outcome(irrigate.cna1.msc)

irrigate.cna2 &lt;- cna(d.irrigate, con = .9)
irrigate.cna2a.asf &lt;- condition(asf(irrigate.cna2)$condition, irrigate.ct)
group.by.outcome(irrigate.cna2a.asf)

# Return as regular data frame.
as.data.frame(irrigate.cna2a.asf)

# Add data.
(irrigate.cna2b.asf &lt;- condition(asf(irrigate.cna2)$condition, irrigate.ct, 
                                     add.data = TRUE))

# No spaces before and after "+".
options(spaces = c("&lt;-&gt;", "-&gt;" ))
irrigate.cna2b.asf

# No spaces at all.
options(spaces = NULL)
irrigate.cna2b.asf

# Restore the default spacing.
options(spaces = c("&lt;-&gt;", "-&gt;", "+"))

# Print only consistency and coverage scores.
print(irrigate.cna2a.asf, print.table = FALSE)
summary(irrigate.cna2a.asf)

# Print only 2 digits of consistency and coverage scores.
print(irrigate.cna2b.asf, digits = 2)

# Instead of a configuration table as output by configTable(), it is also possible to provide 
# a data frame as second input. 
condition("A*r + L*C", d.irrigate)
condition(c("A*r + L*C", "A*L -&gt; F", "C -&gt; A*R + C*l"), d.irrigate)
condition(c("A*r + L*C -&gt; W", "A*L*R -&gt; W", "A*R + C*l -&gt; F", "W*a -&gt; F"), d.irrigate)
          
          
# Fuzzy-set data from Emmenegger (2011) on the causes of high job security regulations
# ------------------------------------------------------------------------------------
# Compare the CNA solution for outcome JSR to the solution presented by Emmenegger
# S*R*v + S*L*R*P + S*C*R*P + C*L*P*v -&gt; JSR (p. 349), which he generated by fsQCA as
# implemented in the fs/QCA software, version 2.5.
jobsecurity.cna &lt;- cna(d.jobsecurity, outcome = "JSR", con = .97, cov= .77,
                         maxstep = c(4, 4, 15))
compare.sol &lt;- condition(c(asf(jobsecurity.cna)$condition, "S*R*v + S*L*R*P + S*C*R*P + 
                         C*L*P*v -&gt; JSR"), d.jobsecurity)
summary(compare.sol)
print(compare.sol, add.data = d.jobsecurity)
group.by.outcome(compare.sol)

# There exist even more high quality solutions for JSR.
jobsecurity.cna2 &lt;- cna(d.jobsecurity, outcome = "JSR", con = .95, cov= .8,
                          maxstep = c(4, 4, 15))
compare.sol2 &lt;- condition(c(asf(jobsecurity.cna2)$condition, "S*R*v + S*L*R*P + S*C*R*P + 
                         C*L*P*v -&gt; JSR"), d.jobsecurity)
summary(compare.sol2)
group.by.outcome(compare.sol2)


# Simulate multi-value data
# -------------------------
library(dplyr)
# Define the data generating structure.
groundTruth &lt;- "(A=2*B=1 + A=3*B=3 &lt;-&gt; C=1)*(C=1*D=2 + C=2*D=3 &lt;-&gt; E=3)"
# Generate ideal data on groundTruth.
fullData &lt;- allCombs(c(3, 3, 2, 3, 3))
idealData &lt;- ct2df(selectCases(groundTruth, fullData))
# Randomly add 15% inconsistent cases.
inconsistentCases &lt;- setdiff(fullData, idealData)
realData &lt;- rbind(idealData, inconsistentCases[sample(1:nrow(inconsistentCases), 
                                               nrow(idealData)*0.15), ])
# Determine model fit of groundTruth and its submodels. 
condition(groundTruth, realData)
condition("A=2*B=1 + A=3*B=3 &lt;-&gt; C=1", realData)
condition("A=2*B=1 + A=3*B=3 &lt;-&gt; C=1", realData, force.bool = TRUE)
condition("(C=1*D=2 + C=2*D=3 &lt;-&gt; E=3)", realData)
condition("(C=1*D=2 + C=2*D=3 &lt;-&gt; E=3)", realData, rm.parentheses = TRUE)
condition("(C=1*D=2 +!(C=2*D=3 + A=1*B=1) &lt;-&gt; E=3)", realData)
# Manually calculate unique coverages, i.e. the ratio of an outcome's instances
# covered by individual msc alone (for details on unique coverage cf.
# Ragin 2008:63-68).
summary(condition("A=2*B=1 * -(A=3*B=3) &lt;-&gt; C=1", realData)) # unique coverage of A=2*B=1
summary(condition("-(A=2*B=1) * A=3*B=3 &lt;-&gt; C=1", realData)) # unique coverage of A=3*B=3

# Note that expressions must feature factor VALUES contained in the data, they may not 
# contain factor NAMES. The following calls produce errors.
condition("C*D &lt;-&gt; E", realData)
condition("A=2*B=1 + C=23", realData)
# In case of mv expressions, negations of factor values must be written with brackets.
condition("!(A=2)", realData)
# The following produces an error.
condition("!A=2", realData)
</code></pre>

<hr>
<h2 id='condList-methods'>
Methods for class &ldquo;condList&rdquo;
</h2><span id='topic+condList-methods'></span><span id='topic+summary.condList'></span><span id='topic+as.data.frame.condList'></span><span id='topic+group.by.outcome'></span>

<h3>Description</h3>

<p>The output of the <code><a href="#topic+condition">condition</a></code> function is a nested list of class &ldquo;condList&rdquo; that contains one or several data frames. The utilities in <code>condList-methods</code> are suited for rendering or reshaping these objects in different ways.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'condList'
summary(object, ...)

## S3 method for class 'condList'
as.data.frame(x, row.names = attr(x, "cases"), optional = TRUE, nobs = TRUE, ...)

group.by.outcome(object, cases = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="condList-methods_+3A_object">object</code>, <code id="condList-methods_+3A_x">x</code></td>
<td>
<p>An object of class &ldquo;condList&rdquo;, the output of the <code><a href="#topic+condition">condition</a></code> function.</p>
</td></tr>
<tr><td><code id="condList-methods_+3A_...">...</code></td>
<td>
<p>Not used.</p>
</td></tr>
<tr><td><code id="condList-methods_+3A_row.names">row.names</code>, <code id="condList-methods_+3A_optional">optional</code></td>
<td>
<p>As in <code><a href="base.html#topic+as.data.frame">as.data.frame</a></code>.</p>
</td></tr>
<tr><td><code id="condList-methods_+3A_nobs">nobs</code></td>
<td>
<p>Logical; if <code>TRUE</code>, the returned data frame has a 
column named &ldquo;n.obs&rdquo; indicating how many cases instantiate a given configuration in the data.</p>
</td></tr>
<tr><td><code id="condList-methods_+3A_cases">cases</code></td>
<td>
<p>Logical; if <code>TRUE</code>, the returned data frame has a
column named &ldquo;cases&rdquo;.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>summary</code> method for class &ldquo;condList&rdquo; prints the output of <code>condition</code> in a condensed manner. It is identical to <code>print</code>ing with <code>print.table = FALSE</code>, see <code><a href="#topic+print.condList">print.condList</a></code>.
</p>
<p>The output of <code><a href="#topic+condition">condition</a></code> is a nested list of class &ldquo;condList&rdquo; that contains one or several data frames. The method <code>as.data.frame</code> is a variant of the base method <code><a href="base.html#topic+as.data.frame">as.data.frame</a></code>. It offers a convenient way of combining the columns of the data frames in a <code>condList</code> into one regular data frame.
Columns appearing in several tables (typically the modeled outcomes) are included only once in the resulting data frame. The output of <code>as.data.frame</code> has syntactically invalid column names by default, including operators such as <code>"-&gt;"</code> or <code>"+"</code>.
Setting <code>optional = FALSE</code> converts the column names into syntactically valid names (using <code><a href="base.html#topic+make.names">make.names</a></code>). 
</p>
<p><code>group.by.outcome</code> takes a <code>condlist</code> as input and combines the entries in that nested list into a data frame with a larger number of columns, combining all columns concerning the same outcome into the same data frame. The additional attributes (consistency etc.) are thereby removed.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+condition">condition</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>ana1 &lt;- cna(d.educate)
(csfList &lt;- condition(csf(ana1)$condition, d.educate))
as.data.frame(csfList)
as.data.frame(csfList[1]) # Include the first condition only
as.data.frame(csfList, row.names = NULL)
as.data.frame(csfList, optional = FALSE)
as.data.frame(csfList, nobs = FALSE)

(asfList &lt;- condition(asf(ana1)$condition, d.educate))
as.data.frame(asfList)  
group.by.outcome(asfList)
summary(asfList)

(mscList &lt;- condition(msc(ana1)$condition, d.educate))
as.data.frame(mscList) 
group.by.outcome(mscList)
summary(mscList)
  
</code></pre>

<hr>
<h2 id='condTbl'>
Extract conditions and solutions from an object of class &ldquo;cna&rdquo;
</h2><span id='topic+condTbl'></span><span id='topic+print.condTbl'></span><span id='topic+as.data.frame.condTbl'></span><span id='topic+as.condTbl'></span><span id='topic+condTbl'></span><span id='topic+msc'></span><span id='topic+asf'></span><span id='topic+csf'></span>

<h3>Description</h3>

<p>Given a solution object <code>x</code> produced by <code><a href="#topic+cna">cna</a></code>, <code>msc(x)</code> extracts all minimally sufficient conditions, <code>asf(x)</code> all atomic solution formulas, and <code>csf(x, n.init)</code> builds approximately <code>n.init</code> complex solution formulas. All solution attributes (<code>details</code>) that are saved in <code>x</code> are recovered as well. The three functions return a data frame with the additional class attribute <code>condTbl</code>.
</p>
<p><code>as.condTbl</code> reshapes the output produced by <code><a href="#topic+condition">condition</a></code> in such a way as to make it identical to the output returned by <code>msc</code>, <code>asf</code>, and <code>csf</code>.
</p>
<p><code>condTbl</code> executes <code><a href="#topic+condition">condition</a></code> and returns a concise summary table featuring consistencies and coverages.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>msc(x, details = x$details, cases = FALSE)
asf(x, details = x$details, warn_details = TRUE)
csf(x, n.init = 1000, details = x$details,
    asfx = asf(x, details, warn_details = FALSE),
    inus.only = x$inus.only, minimalizeCsf = inus.only,
    acyclic.only = x$acyclic.only, cycle.type = x$cycle.type,
    verbose = FALSE)
## S3 method for class 'condTbl'
print(x, n = 20, digits = 3, quote = FALSE, row.names = TRUE, ...)
## S3 method for class 'condTbl'
as.data.frame(x, ...)

condTbl(...)
as.condTbl(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="condTbl_+3A_x">x</code></td>
<td>
<p>Object of class &ldquo;cna&rdquo;. In <code>as.condTbl</code>, <code>x</code> is a list of evaluated conditions as returned by <code>condition</code>. In <code>print</code>, <code>x</code> is an object returned by <code>msc</code>, <code>asf</code>, or <code>csf</code>.</p>
</td></tr>
<tr><td><code id="condTbl_+3A_details">details</code></td>
<td>
<p>Either <code>TRUE/FALSE</code> or a character vector specifying which solution attributes to print (see <code><a href="#topic+cna">cna</a></code>). Note that <code>msc</code> and <code>asf</code> can only display attributes that are saved in <code>x</code>, i.e. those that have been requested in the <code>details</code> argument within the call of <code><a href="#topic+cna">cna</a></code>.</p>
</td></tr>
<tr><td><code id="condTbl_+3A_cases">cases</code></td>
<td>
<p>Logical; if <code>TRUE</code>, an additional column listing the cases where the msc is instantiated in combination with the outcome is added to the output.</p>
</td></tr>
<tr><td><code id="condTbl_+3A_warn_details">warn_details</code></td>
<td>
<p>Logical; if <code>TRUE</code>, a warning is issued when some attribute requested in <code>details</code> is not available in <code>x</code> (parameter for internal use).</p>
</td></tr>
<tr><td><code id="condTbl_+3A_n.init">n.init</code></td>
<td>
<p>Integer capping the amount of initial asf combinations. Default at 1000. Serves to control the computational complexity of the csf building process. 
</p>
</td></tr>
<tr><td><code id="condTbl_+3A_asfx">asfx</code></td>
<td>
<p>Object of class &ldquo;condTbl&rdquo; produced by the <code>asf</code> function.</p>
</td></tr>
<tr><td><code id="condTbl_+3A_inus.only">inus.only</code></td>
<td>
<p>Either <code>TRUE</code>/<code>FALSE</code> or a character string with possible values &quot;implication&quot; or &quot;equivalence&quot;. The strings can be abbreviated. If <code>TRUE</code>, csf are freed of structural redundancies and only csf not featuring partial structural redundancies are retained  (see the fourth stage of <code><a href="#topic+cna">cna</a></code>'s search algorithm; see also <code><a href="#topic+is.inus">is.inus</a></code>). Defaults to <code>x$inus.only</code>.</p>
</td></tr>
<tr><td><code id="condTbl_+3A_minimalizecsf">minimalizeCsf</code></td>
<td>
<p>Logical; if <code>TRUE</code>, csf are freed of structural redundancies.</p>
</td></tr>
<tr><td><code id="condTbl_+3A_acyclic.only">acyclic.only</code></td>
<td>
<p>Logical; if <code>TRUE</code>, csf featuring a cyclic substructure are not returned. <code>FALSE</code> by default.</p>
</td></tr>
<tr><td><code id="condTbl_+3A_cycle.type">cycle.type</code></td>
<td>
<p>Character string specifying what type of cycles to be detected: <code>"factor"</code> (the default) or <code>"value"</code> (cf. <code><a href="#topic+cyclic">cyclic</a></code>).</p>
</td></tr>
<tr><td><code id="condTbl_+3A_verbose">verbose</code></td>
<td>
<p>Logical; if <code>TRUE</code>, some details on the csf building process are printed. <code>FALSE</code> by default.</p>
</td></tr>
<tr><td><code id="condTbl_+3A_n">n</code></td>
<td>
<p>Maximal number of msc, asf, or csf to be printed.</p>
</td></tr>
<tr><td><code id="condTbl_+3A_digits">digits</code></td>
<td>
<p>Number of digits to print in consistency, coverage, exhaustiveness, faithfulness, and coherence scores.</p>
</td></tr>
<tr><td><code id="condTbl_+3A_quote">quote</code>, <code id="condTbl_+3A_row.names">row.names</code></td>
<td>
<p>As in <code><a href="base.html#topic+print.data.frame">print.data.frame</a></code>.</p>
</td></tr>
<tr><td><code id="condTbl_+3A_...">...</code></td>
<td>
<p>All arguments in <code>condTbl</code> are passed on to <code><a href="#topic+condition">condition</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Depending on the processed data, the solutions (models) output by <code><a href="#topic+cna">cna</a></code> are often ambiguous, to the effect that many atomic and complex solutions fit the data equally well. To facilitate the inspection of the <code><a href="#topic+cna">cna</a></code> output, however, the latter standardly returns only 5 minimally sufficient conditions (msc), 5 atomic solution formulas (asf), and 5 complex solution formulas (csf) for each outcome. <code>msc</code> can be used to extract <em>all</em> msc from an object <code>x</code> of class &ldquo;cna&rdquo;, <code>asf</code> to extract <em>all</em> asf, and <code>csf</code> to build approximately <code>n.init</code> csf from the asf stored in <code>x</code>. All solution attributes (<code>details</code>) that are saved in <code>x</code> are recovered as well.
The outputs of <code>msc</code>, <code>asf</code>, and <code>csf</code> can be further processed by the <code><a href="#topic+condition">condition</a></code> function.
</p>
<p>While <code>msc</code> and <code>asf</code> merely extract information stored in <code>x</code>, <code>csf</code> builds csf from the inventory of asf recovered at the end of the third stage of the <code><a href="#topic+cna">cna</a></code> algorithm. That is, the <code>csf</code> function implements the fourth stage of that algorithm. It proceeds in a stepwise manner as follows.
</p>
<ol>
<li> <p><code>n.init</code> possible conjunctions featuring one asf of every outcome are built. </p>
</li>
<li><p>  If <code>inus.only = TRUE</code> or <code>minimalizeCsf = TRUE</code>, the solutions resulting from step 1 are freed of structural redundancies (cf. Baumgartner and Falk 2023). 
</p>
</li>
<li><p> If <code>inus.only = TRUE</code>, tautologous and contradictory solutions as well as solutions with partial structural redundancies and constant factors are eliminated. 
[If <code>inus.only = FALSE</code> and <code>minimalizeCsf = TRUE</code>, only structural redundancies are eliminated, meaning only step 2, but not step 3, is executed.]
</p>
</li>
<li><p> If <code>acyclic.only = TRUE</code>, solutions with cyclic substructures are eliminated. </p>
</li>
<li><p> For those solutions that were modified in the previous steps, consistency and coverage are re-calculated and solutions that no longer reach <code>con</code> or <code>cov</code> are eliminated. 
</p>
</li>
<li><p> The remaining solutions are returned as csf, ordered by complexity and the product of consistency and coverage.</p>
</li></ol>

<p>The argument <code>digits</code> applies to the <code>print</code> method. It determines how many digits of consistency, coverage, exhaustiveness, faithfulness, and coherence scores are printed. The default value is 3.
</p>
<p>The function <code>as.condTbl</code> takes a list of objects of class &ldquo;cond&rdquo; that are returned by the <code><a href="#topic+condition">condition</a></code> function as input, and reshapes these objects in such a way as to make them identical to the output returned by <code>msc</code>, <code>asf</code>, and <code>csf</code>.
</p>
<p><code>condTbl(...)</code> is identical with <code>as.condTbl(condition(...))</code>.
</p>


<h3>Value</h3>

<p><code>msc</code>, <code>asf</code>, <code>csf</code>, and <code>as.condTbl</code> return objects of class &ldquo;condTbl&rdquo;, a <code>data.frame</code> which features the following components:
</p>

<table>
<tr>
 <td style="text-align: right;">
<code>outcome</code>: </td><td style="text-align: left;"> the outcomes</td>
</tr>
<tr>
 <td style="text-align: right;">
<code>condition</code>:</td><td style="text-align: left;"> the relevant conditions or solutions</td>
</tr>
<tr>
 <td style="text-align: right;">
<code>consistency</code>:</td><td style="text-align: left;"> the consistency scores </td>
</tr>
<tr>
 <td style="text-align: right;">
<code>coverage</code>: </td><td style="text-align: left;"> the coverage scores  </td>
</tr>
<tr>
 <td style="text-align: right;">
<code>complexity</code>: </td><td style="text-align: left;"> the complexity scores</td>
</tr>
<tr>
 <td style="text-align: right;">
<code>inus</code>: </td><td style="text-align: left;"> whether the solutions have INUS form</td>
</tr>
<tr>
 <td style="text-align: right;">
<code>exhaustiveness</code>: </td><td style="text-align: left;"> the exhaustiveness scores</td>
</tr>
<tr>
 <td style="text-align: right;">
<code>faithfulness</code>: </td><td style="text-align: left;"> the faithfulness scores</td>
</tr>
<tr>
 <td style="text-align: right;">
<code>coherence</code>: </td><td style="text-align: left;"> the coherence scores</td>
</tr>
<tr>
 <td style="text-align: right;">
<code>redundant</code>: </td><td style="text-align: left;"> whether the csf contain redundant proper parts</td>
</tr>
<tr>
 <td style="text-align: right;">
<code>cyclic</code>: </td><td style="text-align: left;"> whether the csf contain cyclic substructures
</td>
</tr>

</table>

<p>The latter five measures are optional and will be appended to the table according to the setting of the argument <code>details</code>.
</p>


<h3>Contributors</h3>

<p>Falk, Christoph: development, testing
</p>


<h3>References</h3>

<p>Baumgartner, Michael and Christoph Falk. 2023. &ldquo;Boolean Difference-Making: A Modern Regularity Theory of Causation&rdquo;. <em>The British Journal for the Philosophy of Science</em>, 74(1), 171-197. 
</p>
<p>Lam, Wai Fung, and Elinor Ostrom. 2010.
&ldquo;Analyzing the Dynamic Complexity of Development Interventions: Lessons
from an Irrigation Experiment in Nepal.&rdquo;
<em>Policy Sciences</em> 43 (2):1-25.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+cna">cna</a></code>, <code><a href="#topic+configTable">configTable</a></code>, <code><a href="#topic+condition">condition</a></code>, <code><a href="#topic+minimalizeCsf">minimalizeCsf</a></code>, <code><a href="#topic+d.irrigate">d.irrigate</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'># Crisp-set data from Lam and Ostrom (2010) on the impact of development interventions
# ------------------------------------------------------------------------------------
# CNA with causal ordering that corresponds to the ordering in Lam &amp; Ostrom (2010); coverage 
# cut-off at 0.9 (consistency cut-off at 1).
cna.irrigate &lt;- cna(d.irrigate, ordering = "A, R, F, L, C &lt; W", cov = .9,
                    maxstep = c(4, 4, 12), details = TRUE)
cna.irrigate

# The previous function call yields a total of 12 complex solution formulas, only
# 5 of which are returned in the default output. 
# Here is how to extract all 12 complex solution formulas along with all 
# solution attributes.
csf(cna.irrigate)
# With only the standard attributes plus exhaustiveness and faithfulness.
csf(cna.irrigate, details = c("e", "f"))

# Extract all atomic solution formulas.
asf(cna.irrigate)

# Extract all minimally sufficient conditions.
msc(cna.irrigate) # capped at 20 rows
print(msc(cna.irrigate), n = Inf) # prints all rows
# Add cases featuring the minimally sufficient conditions combined 
# with the outcome.
(msc.table &lt;- msc(cna.irrigate, cases = TRUE))
# Render as data frame.
as.data.frame(msc.table)

# Extract only the conditions (solutions).
csf(cna.irrigate)$condition
asf(cna.irrigate)$condition
msc(cna.irrigate)$condition

# A CNA of d.irrigate without outcome specification and ordering is even more
# ambiguous.
cna2.irrigate &lt;- cna(d.irrigate, cov = .9, maxstep = c(4,4,12), details = TRUE)

# To speed up the construction of complex solution formulas, first extract asf
# and then pass these asf to csf.
cna2.irrigate.asf &lt;- asf(cna2.irrigate)
csf(cna2.irrigate, asfx = cna2.irrigate.asf, details = FALSE)
# Reduce the initial asf combinations.
csf(cna2.irrigate, asfx = cna2.irrigate.asf, n.init = 50)
# Print the first 20 csf.
csf(cna2.irrigate, asfx = cna2.irrigate.asf, n.init = 50)[1:20, ]
# Also extract exhaustiveness scores.
csf(cna2.irrigate, asfx = cna2.irrigate.asf, n.init = 50,
    details = "e")[1:20, ]

# Print details about the csf building process.
csf(cna.irrigate, verbose = TRUE)

# Return solution attributes with 5 digits.
print(cna2.irrigate.asf, digits = 5)
 

# Further examples
# ----------------
# An example generating structural redundancies.
target &lt;- "(A*B + C &lt;-&gt; D)*(c + a &lt;-&gt; E)"
dat1 &lt;- selectCases(target)
ana1 &lt;- cna(dat1, maxstep = c(3, 4, 10))
# Run csf with elimination of structural redundancies.
csf(ana1, verbose = TRUE)
# Run csf without elimination of structural redundancies. 
csf(ana1, verbose = TRUE, inus.only = FALSE)

# An example generating partial structural redundancies.
dat2 &lt;- data.frame(A=c(0,0,0,0,1,1,1,1,0,0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,0,
        1),B=c(0,0,1,1,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1),C=c(1,
        1,0,0,0,1,0,0,1,1,0,1,1,0,1,1,0,1,1,1,0,1,0,1,0,1,0),D=c(0,1,1,1,
        0,1,1,1,0,0,0,1,0,1,0,0,0,1,0,0,0,1,1,0,0,1,0),E=c(1,0,0,0,0,1,1,
        1,1,1,1,0,0,1,0,0,0,1,1,1,1,0,0,0,0,1,1),F=c(1,1,1,1,1,0,0,0,0,0,
        0,0,0,1,1,1,1,0,0,0,0,0,0,0,0,0,0),G=c(1,1,1,1,1,1,1,1,1,1,1,1,1,
        0,0,0,0,0,0,0,0,0,0,0,0,1,1))
ana2 &lt;- cna(dat2, con = .8, cov = .8, maxstep = c(3, 3, 10))
# Run csf without elimination of partial structural redundancies.
csf(ana2, inus.only = FALSE, verbose = TRUE)
# Run csf with elimination of partial structural redundancies.
csf(ana2, verbose = TRUE)
# Prior to version 3.6.0, the "equivalence" definition of partial structural
# redandancy was used by default (see ?is.inus() for details). Now, the 
# "implication" definition is used. To replicate old behavior
# set inus.only to "equivalence".
csf(ana2, verbose = TRUE, inus.only = "equivalence")
# The two definitions only come apart in case of cyclic structures.
# Build only acyclic models.
csf(ana2, verbose = TRUE, acyclic.only = TRUE)

# Feed the outputs of msc, asf, and csf into the condition function to further inspect the 
# properties of minimally sufficient conditions and atomic and complex solution formulas.
head(condition(msc(ana2)$condition, dat2), 3) # (showing output for first 3 only)
head(condition(asf(ana2)$condition, dat2), 3)
head(condition(csf(ana2)$condition, dat2), 3)

# Reshape the output of the condition function in such a way as to make it identical to the
# output returned by msc, asf, and csf.
head(condition(msc(ana2)$condition, dat2), 3)
head(condition(asf(ana2)$condition, dat2), 3)
head(condition(csf(ana2)$condition, dat2), 3)

head(condTbl(csf(ana2)$condition, dat2), 3) # Same as preceding line
</code></pre>

<hr>
<h2 id='configTable'>Assemble cases with identical configurations in a configuration table</h2><span id='topic+configTable'></span><span id='topic+print.configTable'></span>

<h3>Description</h3>

<p>The <code>configTable</code> function assembles cases with identical configurations from a crisp-set, multi-value, or fuzzy-set data frame in a table called a <em>configuration table</em>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>configTable(x, type = c("auto", "cs", "mv", "fs"), frequency = NULL,
            case.cutoff = 0, rm.dup.factors = FALSE, rm.const.factors = FALSE,
           .cases = NULL, verbose = TRUE)

## S3 method for class 'configTable'
print(x, show.cases = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="configTable_+3A_x">x</code></td>
<td>
<p>Data frame or matrix.</p>
</td></tr>
<tr><td><code id="configTable_+3A_type">type</code></td>
<td>
<p>Character vector specifying the type of <code>x</code>: <code>"auto"</code> (automatic detection; default), <code>"cs"</code> (crisp-set), <code>"mv"</code> (multi-value),  or <code>"fs"</code> (fuzzy-set).</p>
</td></tr>
<tr><td><code id="configTable_+3A_frequency">frequency</code></td>
<td>
<p>Numeric vector of length <code>nrow(x)</code>. All elements must be
non-negative.</p>
</td></tr>
<tr><td><code id="configTable_+3A_case.cutoff">case.cutoff</code></td>
<td>
<p>Minimum number of occurrences (cases) of a configuration
in <code>x</code>. Configurations with fewer than <code>case.cutoff</code> occurrences (cases)
are not included in the configuration table.</p>
</td></tr>
<tr><td><code id="configTable_+3A_rm.dup.factors">rm.dup.factors</code></td>
<td>
<p>Logical; if <code>TRUE</code>, all but the first of a set of factors with identical values in <code>x</code> are removed. <b>Note:</b> The default value has changed from <code>TRUE</code> to <code>FALSE</code> in the package's version 3.5.4.</p>
</td></tr>
<tr><td><code id="configTable_+3A_rm.const.factors">rm.const.factors</code></td>
<td>
<p>Logical; if <code>TRUE</code>, factors with constant values in <code>x</code> are removed. <b>Note:</b> The default value has changed from <code>TRUE</code> to <code>FALSE</code> in the package's version 3.5.4.</p>
</td></tr>
<tr><td><code id="configTable_+3A_.cases">.cases</code></td>
<td>
<p>Optional character vector of length <code>nrow(x)</code> to set case labels (row names).</p>
</td></tr>
<tr><td><code id="configTable_+3A_verbose">verbose</code></td>
<td>
<p>Logical; if <code>TRUE</code>, some messages on the configuration table are printed.</p>
</td></tr>
<tr><td><code id="configTable_+3A_show.cases">show.cases</code></td>
<td>
<p>Logical; if <code>TRUE</code>, the attribute &ldquo;cases&rdquo;
is printed.</p>
</td></tr>
<tr><td><code id="configTable_+3A_...">...</code></td>
<td>

<p>In <br /><code>print.configTable</code>: arguments passed to <code><a href="base.html#topic+print.data.frame">print.data.frame</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The first input <code>x</code> of the <code>configTable</code> function is a data frame. To ensure that no misinterpretations of issued asf and csf can occur, users are advised to use only upper case letters as factor (column) names. Column names may contain numbers, but the first sign in a column name must be a letter. Only ASCII signs should be used for column and row names.
</p>
<p>The <code>configTable</code> function merges multiple rows of <code>x</code> featuring the same configuration into one row, such that each row of the resulting table, which is called a <em>configuration table</em>, corresponds to one determinate configuration of the factors in <code>x</code>.
The number of occurrences (cases) and an enumeration of the cases are saved as attributes
&ldquo;n&rdquo; and &ldquo;cases&rdquo;, respectively. The attribute &ldquo;n&rdquo; is always printed in the output of <code>configTable</code>, the attribute &ldquo;cases&rdquo; is printed if the argument <code>show.cases</code> is <code>TRUE</code> in the <code>print</code> method. 
</p>
<p>The argument <code>type</code> allows for manually specifying the type of data; it defaults to <code>"auto"</code>, which induces automatic detection of the data type. <code>"cs"</code> stands for crisp-set data featuring factors that only take values 1 and 0; <code>"mv"</code> stands for multi-value data with factors that can take any non-negative integers as values; <code>"fs"</code> stands for fuzzy-set data comprising factors taking real values from the interval [0,1], which are interpreted as membership scores in fuzzy sets. 
</p>
<p>Instead of multiply listing identical configurations in <code>x</code>, the <code>frequency</code> argument can
be used to indicate the frequency of each configuration in the data frame. <code>frequency</code> takes a numeric vector of length <code>nrow(x)</code> as value. For instance, <code>configTable(x, frequency = c(3,4,2,3))</code> determines that the first configuration in <code>x</code> is featured in 3 cases, the second in 4, the third in 2, and the fourth in 3 cases.
</p>
<p>The <code>case.cutoff</code> argument is used to determine that configurations are only included in the configuration table if they are instantiated at least as many times in <code>x</code> as the number assigned to <code>case.cutoff</code>. Or differently, configurations that are instantiated less than  <code>case.cutoff</code> are excluded from the configuration table. For instance, <code>configTable(x, case.cutoff = 3)</code> entails that configurations with less than 3 cases are excluded.
</p>
<p><code>rm.dup.factors</code> and <code>rm.const.factors</code> allow for determining whether all but the first of a set of duplicated factors (i.e. factors with identical value distributions in <code>x</code>) are eliminated and whether constant factors (i.e. factors with constant values in all cases (rows) in <code>x</code>) are eliminated. From the perspective of configurational causal modeling, factors with constant values in all cases can neither be modeled as causes nor as outcomes; therefore, they can be removed prior to the analysis. Factors with identical value distributions cannot be distinguished configurationally, meaning they are one and the same factor as far as configurational causal modeling is concerned. When duplicate or constant factors are contained in <code>x</code>, a warning message is issued by default. By setting <code>rm.dup.factors</code> and <code>rm.const.factors</code> to the non-default value <code>TRUE</code>, <code>configTable</code> is given permission to automatically eliminate duplicate or constant factors.
</p>
<p><code>.cases</code> can be used to set case labels (row names). It is a character vector of length <code>nrow(x)</code>. 
</p>
<p>The <code>row.names</code> argument of the <code>print</code> function determines whether the case labels of <code>x</code> are printed or not. By default, <code>row.names</code> is <code>TRUE</code> unless the (comma-separated) list of the <code>cases</code> exceeds 20 characters in at least one row.
</p>


<h3>Value</h3>

<p>An object of type &ldquo;configTable&rdquo;, i.e. a data.frame with additional attributes &ldquo;type&rdquo;, &ldquo;n&rdquo; and &ldquo;cases&rdquo;.
</p>


<h3>Note</h3>

<p>For those users of <span class="pkg">cna</span> that are familiar with Qualitative Comparative Analysis (QCA), it must be emphasized that a <em>configuration table</em> is a different type of object than a QCA <em>truth table</em>. While a truth table indicates whether a minterm (i.e. a configuration of all exogenous factors) is sufficient for the outcome or not, a configuration table is simply an integrated representation of the input data that lists all configurations in the data exactly once. A configuration table does not express relations of sufficiency.
</p>


<h3>References</h3>

<p>Greckhamer, Thomas, Vilmos F. Misangyi, Heather Elms, and Rodney Lacey. 2008.
&ldquo;Using Qualitative Comparative Analysis in Strategic Management Research: An Examination of Combinations of Industry, Corporate, and Business-Unit Effects.&rdquo;
<em>Organizational Research Methods</em> 11 (4):695-726.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+cna">cna</a></code>, <code><a href="#topic+condition">condition</a></code>, <code><a href="#topic+allCombs">allCombs</a></code>, <code><a href="#topic+d.performance">d.performance</a></code>, <code><a href="#topic+d.pacts">d.pacts</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'># Manual input of cs data
# -----------------------
dat1 &lt;- data.frame(
  A = c(1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0),
  B = c(1,1,1,1,1,1,1,1,0,0,0,0,0,0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0,0,0,0),
  C = c(1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0,0,0,0),
  D = c(1,1,1,1,0,0,0,0,1,1,1,0,0,0,0,0,1,1,1,1,1,1,1,1,1,1,1,0,0,0,1,1,1,0,0,0),
  E = c(1,1,1,1,1,1,1,0,1,1,1,1,1,1,1,0,1,1,1,1,1,1,1,1,1,1,0,1,1,1,1,1,1,0,0,0)
)

# Default return of the configTable function.
configTable(dat1)

# Recovering the cases featuring each configuration by means of the print function.
print(configTable(dat1), show.cases = TRUE)

# The same configuration table as before can be generated by using the frequency argument 
# while listing each configuration only once.
dat1 &lt;- data.frame(
  A = c(1,1,1,1,1,1,0,0,0,0,0),
  B = c(1,1,1,0,0,0,1,1,1,0,0),
  C = c(1,1,1,1,1,1,1,1,1,0,0),
  D = c(1,0,0,1,0,0,1,1,0,1,0),
  E = c(1,1,0,1,1,0,1,0,1,1,0)
)
configTable(dat1, frequency = c(4,3,1,3,4,1,10,1,3,3,3))

# Set (random) case labels.
print(configTable(dat1, .cases = sample(letters, nrow(dat1), replace = FALSE)),
      show.cases = TRUE)

# Configuration tables generated by configTable() can be input into the cna() function.
dat1.ct &lt;- configTable(dat1, frequency = c(4,3,1,3,4,1,4,1,3,3,3))
cna(dat1.ct, con = .85, details = TRUE)

# By means of the case.cutoff argument configurations with less than 2 cases can
# be excluded (which yields perfect consistency and coverage scores for dat1).
dat1.ct &lt;- configTable(dat1, frequency = c(4,3,1,3,4,1,4,1,3,3,3), case.cutoff = 2)
cna(dat1.ct, details = TRUE)



# Simulating multi-value data with biased samples (exponential distribution)
# --------------------------------------------------------------------------
dat1 &lt;- allCombs(c(3,3,3,3,3))
set.seed(32)
m &lt;- nrow(dat1)
wei &lt;- rexp(m)
dat2 &lt;- dat1[sample(nrow(dat1), 100, replace = TRUE, prob = wei),]
configTable(dat2) # 100 cases with 51 configurations instantiated only once.
configTable(dat2, case.cutoff = 2) # removing the single instances.

# Duplicated factors are not eliminated by default.
dat3 &lt;- selectCases("(A=1+A=2+A=3 &lt;-&gt; C=2)*(B=3&lt;-&gt;D=3)*(B=2&lt;-&gt;D=2)*(A=2 + B=1 &lt;-&gt; E=2)",
                    dat1)
configTable(dat3)

# By setting rm.dup.factors and rm.const.factors to their non-default values,
# duplicates and constant factors can be eliminated automatically.
configTable(dat3, rm.dup.factors = TRUE, rm.const.factors = TRUE)

# The same without messages about constant and duplicated factors.
configTable(dat3, rm.dup.factors = TRUE, rm.const.factors = TRUE, verbose = FALSE)



# Large-N data with crisp sets from Greckhamer et al. (2008)
# ----------------------------------------------------------
configTable(d.performance[1:8], frequency = d.performance$frequency)

# Eliminate configurations with less than 5 cases.
configTable(d.performance[1:8], frequency = d.performance$frequency, case.cutoff = 5)

# Various large-N CNAs of d.performance with varying case cut-offs.
cna(configTable(d.performance[1:8], frequency = d.performance$frequency, case.cutoff = 4),
    ordering = "SP", con = .75, cov = .6)
cna(configTable(d.performance[1:8], frequency = d.performance$frequency, case.cutoff = 5),
    ordering = "SP", con = .75, cov = .6)
cna(configTable(d.performance[1:8], frequency = d.performance$frequency, case.cutoff = 10),
    ordering = "SP", con = .75, cov = .6)
print(cna(configTable(d.performance[1:8], frequency = d.performance$frequency, 
    case.cutoff = 15), ordering = "SP", con = .75, cov = .6, what = "a"), 
    nsolutions = "all")

</code></pre>

<hr>
<h2 id='ct2df'>
Transform a configuration table into a data frame
</h2><span id='topic+ct2df'></span>

<h3>Description</h3>

<p>Transform a configuration table into a data frame. This is the converse function of <code><a href="#topic+configTable">configTable</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ct2df(ct, tt)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ct2df_+3A_ct">ct</code></td>
<td>
<p>A <code>configTable</code>.</p>
</td></tr>
<tr><td><code id="ct2df_+3A_tt">tt</code></td>
<td>
<p>Argument <code>tt</code> is deprecated in <code>ct2df()</code>; use <code>ct</code> instead.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Rows in the <code>configTable</code> corresponding to several cases are rendered as multiple rows in the resulting data frame.
</p>


<h3>Value</h3>

<p>A data frame.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+configTable">configTable</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>ct.educate &lt;- configTable(d.educate[1:2])
ct.educate
ct2df(ct.educate)

dat1 &lt;- some(configTable(allCombs(c(2, 2, 2, 2, 2)) - 1), n = 200, replace = TRUE)
dat2 &lt;- selectCases("(A*b + a*B &lt;-&gt; C)*(C*d + c*D &lt;-&gt; E)", dat1)
dat2 
ct2df(dat2)

dat3 &lt;- data.frame(
  A = c(1,1,1,1,1,1,0,0,0,0,0),
  B = c(1,1,1,0,0,0,1,1,1,0,0),
  C = c(1,1,1,1,1,1,1,1,1,0,0),
  D = c(1,0,0,1,0,0,1,1,0,1,0),
  E = c(1,1,0,1,1,0,1,0,1,1,0)
  )
ct.dat3 &lt;- configTable(dat3, frequency = c(4,3,5,7,4,6,10,2,4,3,12))
ct2df(ct.dat3)
</code></pre>

<hr>
<h2 id='cyclic'>
Detect cyclic substructures in complex solution formulas (csf)
</h2><span id='topic+cyclic'></span>

<h3>Description</h3>

<p>Given a character vector <code>x</code> specifying complex solution formula(s) (csf), <code>cyclic(x)</code> checks whether <code>x</code> contains cyclic substructures. The function can be used, for instance, to filter cyclic causal models out of <code><a href="#topic+cna">cna</a></code> solution objects (e.g. in order to reduce ambiguities).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cyclic(x, cycle.type = c("factor", "value"), use.names = TRUE, verbose = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cyclic_+3A_x">x</code></td>
<td>
<p>Character vector specifying one or several csf.</p>
</td></tr>
<tr><td><code id="cyclic_+3A_cycle.type">cycle.type</code></td>
<td>
<p>Character string specifying what type of cycles to be detected: <code>"factor"</code> (the default) or <code>"value"</code>.</p>
</td></tr>
<tr><td><code id="cyclic_+3A_use.names">use.names</code></td>
<td>
<p>Logical; if <code>TRUE</code>, names are added to the result (see examples).</p>
</td></tr>
<tr><td><code id="cyclic_+3A_verbose">verbose</code></td>
<td>
<p>Logical; if <code>TRUE</code>, the checked causal paths are printed to the console.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Detecting causal cycles is one of the most challenging tasks in causal data analysis&mdash;in all methodological traditions. In a nutshell, the reason is that factors in a cyclic structure are so highly interdependent that, even under optimal discovery conditions, the diversity of (observational) data tends to be too limited to draw informative conclusions about the data generating structure. In consequence, various methods (most notably, Bayes nets methods, cf. Spirtes et al. 2000) assume that analyzed data generating structures are acyclic.
</p>
<p><code><a href="#topic+cna">cna</a></code> outputs cyclic complex solution formulas (csf) if they fit the data. Typically, however, the causal modeling of configurational data that can be modeled in terms of cycles is massively ambiguous. Therefore, if there are independent reasons to assume that the data are not generated by a cyclic structure, the function <code>cyclic</code> can be used to reduce the ambiguities in a <code><a href="#topic+cna">cna</a></code> output by filtering out all csf with cyclic substructures.
</p>
<p>A causal structure has a cyclic substructure if, and only if, it contains a directed causal path from at least one cause back to itself. The INUS-theory of causation spells this criterion out as follows: a csf <code>x</code> has a cyclic substructure if, and only if, <code>x</code> contains a sequence &lt;Z1, Z2,..., Zn&gt; every element of which is an INUS condition of its successor and Z1=Zn. Accordingly, the function <code>cyclic</code> searches for sequences &lt;Z1, Z2,..., Zn&gt; of factors or factor values in a csf <code>x</code> such that (i) every Zi is contained in the antecedent (i.e. the left-hand side of &quot;<code>&lt;-&gt;</code>&quot;) of and atomic solution formula (asf) of Zi+1 in <code>x</code>, and (ii) Zn is identical to Z1. The function returns <code>TRUE</code> if, and only if, at least one such sequence (i.e. directed causal path) is contained in <code>x</code>. 
</p>
<p>The <code>cycle.type</code> argument controls whether the sequence &lt;Z1, Z2,..., Zn&gt; is composed of factors (<code>cycle.type = "factor"</code>) or factor values (<code>cycle.type = "value"</code>). To illustrate, if <code>cycle.type = "factor"</code>, the following csf is considered cyclic: (A + B &lt;-&gt; C)*(c + D &lt;-&gt; A). The factor A (with value 1) appears in the antecedent of an asf of C (with value 1), and the factor C (with value 0) appears in the antecedent of an asf of A (with value 1). But if <code>cycle.type = "value"</code>, that same csf does not pass as cyclic. Although the factor value 1 of A appears in the antecedent of an asf of the factor value 1 of C, that same value of C does not appear in the antecedent of an asf of A; rather, the value 0 of C appears in the antecedent of A.
</p>
<p>If <code>verbose = TRUE</code>, the sequences (paths) tested for cyclicity are output to the console. Note that the search for cycles is stopped as soon as one cyclic sequence (path) has been detected. Accordingly, not all sequences (paths) contained in <code>x</code> may be output to the console.
</p>


<h3>Value</h3>

<p>A logical vector: <code>TRUE</code> for a csf with at least one cyclic substructure, <code>FALSE</code> for a csf without any cyclic substructures.</p>


<h3>References</h3>

<p>Spirtes, Peter, Clark Glymour, and Richard Scheines. 2000. <em>Causation, Prediction, and Search</em> (second ed.). Cambridge MA: MIT Press.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># cna() infers two csf from the d.educate data, neither of which has a cyclic
# substructure.
cnaedu &lt;- cna(d.educate)
cyclic(csf(cnaedu)$condition)

# At con = .82 and cov = .82, cna() infers 47 csf for the d.pacts data, some
# of which are cyclic, others are acyclic. If there are independent
# reasons to assume acyclicity, here is how to extract all acyclic csf.
cnapacts &lt;- cna(d.pacts, con = .82, cov = .82)
cyclic(csf(cnapacts)$condition)
subset(csf(cnapacts, n.init = Inf, details = "cyclic"), !cyclic)

# With verbose = TRUE, the tested sequences (causal paths) are printed.
cyclic("(L=1 + G=1 &lt;-&gt; E=2)*(U=5 + D=3 &lt;-&gt; L=1)*(E=2*G=4 &lt;-&gt; D=3)", verbose = TRUE) 
cyclic("(e*G + F*D + E*c*g*f &lt;-&gt; A)*(d + f*e + c*a &lt;-&gt; B)*(A*e + G*a*f &lt;-&gt; C)",
       verbose = TRUE)

# Argument cycle.type = "factor" or "value".
cyclic("(A*b + C -&gt; D)*(d + E &lt;-&gt; A)")
cyclic("(A*b + C -&gt; D)*(d + E &lt;-&gt; A)", cycle.type = "value")

cyclic("(L=1 + G=1 &lt;-&gt; E=2)*(U=5 + D=3 &lt;-&gt; L=2)*(E=2 + G=3 &lt;-&gt; D=3)") 
cyclic("(L=1 + G=1 &lt;-&gt; E=2)*(U=5 + D=3 &lt;-&gt; L=2)*(E=2 + G=3 &lt;-&gt; D=3)", cycle.type = "v") 

cyclic("a &lt;-&gt; A")
cyclic("a &lt;-&gt; A", cycle.type = "v")

sol1 &lt;- "(A*X1 + Y1 &lt;-&gt; B)*(b*X2 + Y2 &lt;-&gt; C)*(C*X3 + Y3 &lt;-&gt; A)"
cyclic(sol1)
cyclic(sol1, cycle.type = "value") 

sol2 &lt;- "(A*X1 + Y1 &lt;-&gt; B)*(B*X2 + Y2 &lt;-&gt; C)*(C*X3 + Y3 &lt;-&gt; A)"
cyclic(sol2)
cyclic(sol2, cycle.type = "value")

# Argument use.names.
cyclic("a*b + C -&gt; A", use.names = FALSE)

# More examples.
cyclic("(L + G &lt;-&gt; E)*(U + D &lt;-&gt; L)*(A &lt;-&gt; U)")
cyclic("(L + G &lt;-&gt; E)*(U + D &lt;-&gt; L)*(A &lt;-&gt; U)*(B &lt;-&gt; G)")
cyclic("(L + G &lt;-&gt; E)*(U + D &lt;-&gt; L)*(A &lt;-&gt; U)*(B &lt;-&gt; G)*(L &lt;-&gt; G)")
cyclic("(L + G &lt;-&gt; E)*(U + D &lt;-&gt; L)*(A &lt;-&gt; U)*(B &lt;-&gt; G)*(L &lt;-&gt; C)")
cyclic("(D -&gt; A)*(A -&gt; B)*(A -&gt; C)*(B -&gt; C)")
cyclic("(B=3*C=2 + C=1*E=3 &lt;-&gt; A=2)*(B=2*C=1 &lt;-&gt; D=2)*(A=2*B=2 + A=3*C=3 &lt;-&gt; E=3)")
cyclic("(B=3*C=2 + D=2*E=3 &lt;-&gt; A=2)*(A=2*E=3 + B=2*C=1 &lt;-&gt; D=2)*(A=3*C=3 + A=2*D=2 &lt;-&gt; E=3)")

cyclic("(B + d*f &lt;-&gt; A)*(E + F*g &lt;-&gt; B)*(G*e + D*A &lt;-&gt; C)")
cyclic("(B*E + d*f &lt;-&gt; A)*(A + E*g + f &lt;-&gt; B)*(G*e + D*A &lt;-&gt; C)")
cyclic("(B + d*f &lt;-&gt; A)*(C + F*g &lt;-&gt; B)*(G*e + D*A &lt;-&gt; C)")
cyclic("(e*G + F*D + E*c*g*f &lt;-&gt; A)*(d + f*e + c*a &lt;-&gt; B)*(A*e + G*a*f &lt;-&gt; C)")
cyclic("(e*G + F*D + E*c*g*f &lt;-&gt; A)*(d + f*e + c*a &lt;-&gt; B)*(A*e + G*a*f &lt;-&gt; C)", 
       verbose = TRUE)
</code></pre>

<hr>
<h2 id='d.autonomy'>Emergence and endurance of autonomy of biodiversity institutions in Costa Rica</h2><span id='topic+d.autonomy'></span>

<h3>Description</h3>

<p>This dataset is from Basurto (2013), who analyzes the causes of the emergence and endurance of autonomy among local institutions for biodiversity conservation in Costa Rica between 1986 and 2006. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>d.autonomy</code></pre>


<h3>Format</h3>

<p>The data frame contains 30 rows (cases), which are divided in two halves: rows 1 to 14 comprise data on the emergence of local autonomy between 1986 and 1998, rows 15 to 30 comprise data on the endurance of local autonomy between 1998 and 2006. The data has the following 9 columns featuring fuzzy-set factors:
</p>

<table>
<tr>
 <td style="text-align: right;">
[ , 1] </td><td style="text-align: left;"> <b>AU</b>  </td><td style="text-align: left;"> local autonomy  (ultimate outcome)                                        </td>
</tr>
<tr>
 <td style="text-align: right;">
[ , 2] </td><td style="text-align: left;"> <b>EM</b>  </td><td style="text-align: left;"> local communal involvement through direct employment                       </td>
</tr>
<tr>
 <td style="text-align: right;">
[ , 3] </td><td style="text-align: left;"> <b>SP</b>  </td><td style="text-align: left;">  local direct spending                                          </td>
</tr>
<tr>
 <td style="text-align: right;">                          
[ , 4] </td><td style="text-align: left;"> <b>CO</b>  </td><td style="text-align: left;"> co-management with local or regional stakeholders                          </td>
</tr>
<tr>
 <td style="text-align: right;">
[ , 5] </td><td style="text-align: left;"> <b>CI</b>  </td><td style="text-align: left;"> degree of influence of national civil service policies         </td>
</tr>
<tr>
 <td style="text-align: right;">
[ , 6] </td><td style="text-align: left;"> <b>PO</b>  </td><td style="text-align: left;">  national participation in policy-making                        </td>
</tr>
<tr>
 <td style="text-align: right;">
[ , 7] </td><td style="text-align: left;"> <b>RE</b>  </td><td style="text-align: left;">  research-oriented partnerships                                 </td>
</tr>
<tr>
 <td style="text-align: right;">   
[ , 8] </td><td style="text-align: left;"> <b>CN</b>  </td><td style="text-align: left;"> conservation-oriented partnerships                             </td>
</tr>
<tr>
 <td style="text-align: right;">
[ , 9] </td><td style="text-align: left;"> <b>DE</b>  </td><td style="text-align: left;">  direct support by development organizations              
</td>
</tr>

</table>



<h3>Contributors</h3>

<p>Thiem, Alrik: collection, documentation
</p>


<h3>Source</h3>

<p>Basurto, Xavier. 2013. &ldquo;Linking Multi-Level Governance to Local Common-Pool 
Resource Theory using Fuzzy-Set Qualitative Comparative Analysis: Insights from 
Twenty Years of Biodiversity Conservation in Costa Rica.&rdquo; <em>Global Environmental Change</em> <strong>23</strong> (3):573-87. 
</p>

<hr>
<h2 id='d.educate'>Artificial data on education levels and left-party strength</h2><span id='topic+d.educate'></span>

<h3>Description</h3>

<p>This artificial dataset of macro-sociological factors on high levels of education is from Baumgartner (2009).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>d.educate</code></pre>


<h3>Format</h3>

<p>The data frame contains 8 rows (cases) and the following 5 columns featuring Boolean factors taking values 1 and 0 only:
</p>

<table>
<tr>
 <td style="text-align: right;">
[ , 1] </td><td style="text-align: left;"> <b>U</b> </td><td style="text-align: left;"> existence of strong unions      </td>
</tr>
<tr>
 <td style="text-align: right;">
[ , 2] </td><td style="text-align: left;"> <b>D</b> </td><td style="text-align: left;"> high level of disparity         </td>
</tr>
<tr>
 <td style="text-align: right;">
[ , 3] </td><td style="text-align: left;"> <b>L</b> </td><td style="text-align: left;"> existence of strong left parties</td>
</tr>
<tr>
 <td style="text-align: right;">
[ , 4] </td><td style="text-align: left;"> <b>G</b> </td><td style="text-align: left;"> high gross national product     </td>
</tr>
<tr>
 <td style="text-align: right;">
[ , 5] </td><td style="text-align: left;"> <b>E</b> </td><td style="text-align: left;"> high level of education
</td>
</tr>

</table>



<h3>Source</h3>

<p>Baumgartner, Michael. 2009. &ldquo;Inferring Causal Complexity.&rdquo;
<em>Sociological Methods &amp; Research</em> 38(1):71-101.
</p>

<hr>
<h2 id='d.highdim'>Artificial data with 50 factors and 1191 cases</h2><span id='topic+d.highdim'></span>

<h3>Description</h3>

<p>These crisp-set data are simulated from a presupposed data generating structure (i.e. a causal chain). They feature 20% noise and massive fragmentation (limited diversity). <code>d.highdim</code> is used to illustrate CNA's capacity to analyze high-dimensional data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>d.highdim</code></pre>


<h3>Format</h3>

<p>The data frame contains 50 factors (columns), V1 to V50, and 1191 rows (cases). It was simulated from the following data generating structure:
</p>
<p style="text-align: center;"><code class="reqn">(v2*V10 + V18*V16*v15 &lt;-&gt; V13)*(V2*v14 + V3*v12 + V13*V19 &lt;-&gt; V11)</code>
</p>

<p>20% of the cases in <code>d.highdim</code> are incompatible with that structure, meaning they are affected by noise or measurement error. The fragmentation is massive, as there is a total of 281 trillion (<code class="reqn">2^{48}</code>) configurations over the set {V1,...,V50} that are compatible with that structure. 
</p>


<h3>Source</h3>

<p><code>d.highdim</code> has been generated with the following code:<br /><br />
<code>RNGversion("4.0.0")</code><br />
<code>set.seed(39)</code><br />
<code>m0 &lt;- matrix(0, 5000, 50)</code><br />
<code>dat1 &lt;- as.data.frame(apply(m0, c(1,2), function(x) sample(c(0,1), 1)))</code> <br />
<code>target &lt;- "(v2*V10 + V18*V16*v15 &lt;-&gt; V13)*(V2*v14 + V3*v12 + V13*V19 &lt;-&gt; V11)"</code><br />
<code>dat2 &lt;- ct2df(selectCases(target, dat1))</code><br />
<code>incomp.data &lt;- dplyr::setdiff(dat1, dat2)</code> <br /><br />
</p>
<p><code>no.replace &lt;- round(nrow(dat2)*0.2)</code><br />
<code>a &lt;- dat2[sample(nrow(dat2), nrow(dat2)-no.replace, replace = FALSE),]</code><br />
<code>b &lt;- some(incomp.data, no.replace)</code><br />
<code>d.highdim &lt;- rbind(a, b)</code><br />
<code>head(d.highdim)</code>
</p>

<hr>
<h2 id='d.irrigate'>Data on the impact of development interventions on water adequacy in Nepal</h2><span id='topic+d.irrigate'></span>

<h3>Description</h3>

<p>This dataset is from Lam and Ostrom (2010), who analyze the effects of an irrigation
experiment in Nepal.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>d.irrigate</code></pre>


<h3>Format</h3>

<p>The dataset contains 15 rows (cases) and the following 6 columns featuring Boolean factors taking values 1 and 0 only:
</p>

<table>
<tr>
 <td style="text-align: right;">
[ , 1] </td><td style="text-align: left;"> <b>A</b> </td><td style="text-align: left;"> continual assistance on infrastructure improvement                         </td>
</tr>
<tr>
 <td style="text-align: right;">
[ , 2] </td><td style="text-align: left;"> <b>R</b> </td><td style="text-align: left;"> existence of a set of formal rules for irrigation operation and maintenance</td>
</tr>
<tr>
 <td style="text-align: right;">
[ , 3] </td><td style="text-align: left;"> <b>F</b> </td><td style="text-align: left;"> existence of provisions of fines                                           </td>
</tr>
<tr>
 <td style="text-align: right;">
[ , 4] </td><td style="text-align: left;"> <b>L</b> </td><td style="text-align: left;"> existence of consistent leadership                                         </td>
</tr>
<tr>
 <td style="text-align: right;">
[ , 5] </td><td style="text-align: left;"> <b>C</b> </td><td style="text-align: left;"> existence of collective action among farmers for system maintenance        </td>
</tr>
<tr>
 <td style="text-align: right;">
[ , 6] </td><td style="text-align: left;"> <b>W</b> </td><td style="text-align: left;"> persistent improvement in water adequacy at the tail end in winter
</td>
</tr>

</table>



<h3>Source</h3>

<p>Lam, Wai Fung, and Elinor Ostrom. 2010.
&ldquo;Analyzing the Dynamic Complexity of Development Interventions: Lessons
from an Irrigation Experiment in Nepal.&rdquo;
<em>Policy Sciences</em> 43 (2):1-25.
</p>

<hr>
<h2 id='d.jobsecurity'>Job security regulations in western democracies</h2><span id='topic+d.jobsecurity'></span>

<h3>Description</h3>

<p>This dataset is from Emmenegger (2011), who analyzes the determinants of 
high job security regulations in Western democracies using fsQCA. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>d.jobsecurity</code></pre>


<h3>Format</h3>

<p>The data frame contains 19 rows (cases) and the following 7 columns featuring fuzzy-set factors:
</p>

<table>
<tr>
 <td style="text-align: right;">
[ , 1] </td><td style="text-align: left;"> <b>S</b>   </td><td style="text-align: left;"> statism                  </td><td style="text-align: right;"> ("1" high, "0" not high)</td>
</tr>
<tr>
 <td style="text-align: right;">
[ , 2] </td><td style="text-align: left;"> <b>C</b>   </td><td style="text-align: left;"> non-market coordination  </td><td style="text-align: right;"> ("1" high, "0" not high)</td>
</tr>
<tr>
 <td style="text-align: right;">
[ , 3] </td><td style="text-align: left;"> <b>L</b>   </td><td style="text-align: left;"> labour movement strength </td><td style="text-align: right;"> ("1" high, "0" not high)</td>
</tr>
<tr>
 <td style="text-align: right;">
[ , 4] </td><td style="text-align: left;"> <b>R</b>   </td><td style="text-align: left;"> Catholicism              </td><td style="text-align: right;"> ("1" high, "0" not high)</td>
</tr>
<tr>
 <td style="text-align: right;">
[ , 5] </td><td style="text-align: left;"> <b>P</b>   </td><td style="text-align: left;"> religious party strength </td><td style="text-align: right;"> ("1" high, "0" not high)</td>
</tr>
<tr>
 <td style="text-align: right;">
[ , 6] </td><td style="text-align: left;"> <b>V</b>   </td><td style="text-align: left;"> institutional veto points </td><td style="text-align: right;">   ("1" many, "0" not many)</td>
</tr>
<tr>
 <td style="text-align: right;">
[ , 7] </td><td style="text-align: left;"> <b>JSR</b> </td><td style="text-align: left;"> job security regulations </td><td style="text-align: right;">  ("1" high, "0" not high)
</td>
</tr>

</table>



<h3>Contributors</h3>

<p>Thiem, Alrik: collection, documentation
</p>


<h3>Note</h3>

<p>The row names are the official International Organization for Standardization 
(ISO) country code elements as specified in ISO 3166-1-alpha-2.
</p>


<h3>Source</h3>

<p>Emmenegger, Patrick. 2011. &ldquo;Job Security Regulations in Western Democracies: 
A Fuzzy Set Analysis.&rdquo; <em>European Journal of Political Research</em> 50(3):336-64.
</p>

<hr>
<h2 id='d.minaret'>Data on the voting outcome of the 2009 Swiss Minaret Initiative</h2><span id='topic+d.minaret'></span>

<h3>Description</h3>

<p>This dataset is from Baumgartner and Epple (2014), who analyze the determinants
of the outcome of the vote on the 2009 Swiss Minaret Initative.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>d.minaret</code></pre>


<h3>Format</h3>

<p>The data frame contains 26 rows (cases) and the following 6 columns featuring raw data:
</p>

<table>
<tr>
 <td style="text-align: right;">
[ , 1] </td><td style="text-align: left;"> <b>A</b> </td><td style="text-align: left;"> rate of old xenophobia                                    </td>
</tr>
<tr>
 <td style="text-align: right;">
[ , 2] </td><td style="text-align: left;"> <b>L</b> </td><td style="text-align: left;"> left party strength                                       </td>
</tr>
<tr>
 <td style="text-align: right;">
[ , 3] </td><td style="text-align: left;"> <b>S</b> </td><td style="text-align: left;"> share of native speakers of Serbian, Croatian, or Albanian</td>
</tr>
<tr>
 <td style="text-align: right;">
[ , 4] </td><td style="text-align: left;"> <b>T</b> </td><td style="text-align: left;"> strength of traditional economic sector                   </td>
</tr>
<tr>
 <td style="text-align: right;">
[ , 5] </td><td style="text-align: left;"> <b>X</b> </td><td style="text-align: left;"> rate of new xenophobia                                    </td>
</tr>
<tr>
 <td style="text-align: right;">
[ , 6] </td><td style="text-align: left;"> <b>M</b> </td><td style="text-align: left;"> acceptance of Minaret Initiative
</td>
</tr>

</table>



<h3>Contributors</h3>

<p>Ruedi Epple: collection, documentation
</p>


<h3>Source</h3>

<p>Baumgartner, Michael, and Ruedi Epple. 2014. &ldquo;A Coincidence Analysis of a
Causal Chain: The Swiss Minaret Vote.&rdquo;
<em>Sociological Methods &amp; Research</em> 43 (2):280-312.
</p>

<hr>
<h2 id='d.pacts'>Data on the emergence of labor agreements in new democracies between 1994 and 2004</h2><span id='topic+d.pacts'></span>

<h3>Description</h3>

<p>This dataset is from Aleman (2009), who analyzes the causes of the emergence of tripartite labor agreements among unions, employers, and government representatives in new democracies in Europe, Latin America, Africa, and Asia between 1994 and 2004.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>d.pacts</code></pre>


<h3>Format</h3>

<p>The data frame contains 78 rows (cases) and the following 5 columns listing membership scores in 5 fuzzy sets:
</p>

<table>
<tr>
 <td style="text-align: right;">
[ , 1] </td><td style="text-align: left;"> <b>PACT</b> </td><td style="text-align: left;"> development of tripartite cooperation (ultimate outcome)</td>
</tr>
<tr>
 <td style="text-align: right;">
[ , 2] </td><td style="text-align: left;"> <b>W</b> </td><td style="text-align: left;"> regulation of the wage setting process</td>
</tr>
<tr>
 <td style="text-align: right;">
[ , 3] </td><td style="text-align: left;"> <b>E</b> </td><td style="text-align: left;"> regulation of the employment process                                          </td>
</tr>
<tr>
 <td style="text-align: right;">
[ , 4] </td><td style="text-align: left;"> <b>L</b> </td><td style="text-align: left;"> presence of a left government                                         </td>
</tr>
<tr>
 <td style="text-align: right;">
[ , 5] </td><td style="text-align: left;"> <b>P</b> </td><td style="text-align: left;"> presence of an encompassing labor organization (labor power)        
</td>
</tr>

</table>



<h3>Contributors</h3>

<p>Thiem, Alrik: collection, documentation
</p>


<h3>Source</h3>

<p>Aleman, Jose. 2009.
&ldquo;The Politics of Tripartite Cooperation in New Democracies: A Multi-level Analysis.&rdquo;
<em>International Political Science Review</em> 30 (2):141-162.
</p>

<hr>
<h2 id='d.pban'>Party ban provisions in sub-Saharan Africa</h2><span id='topic+d.pban'></span>

<h3>Description</h3>

<p>This dataset is from Hartmann and Kemmerzell (2010), who, among other things, analyze the causes of
the emergence of party ban provisions in sub-Saharan Africa.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>d.pban</code></pre>


<h3>Format</h3>

<p>The data frame contains 48 rows (cases) and the following 5 columns, some of which feature multi-value factors:
</p>

<table>
<tr>
 <td style="text-align: right;">
[ , 1] </td><td style="text-align: left;"> <b>C</b>    </td><td style="text-align: left;"> colonial background ("2" British, "1" French, "0" other)</td>
</tr>
<tr>
 <td style="text-align: right;">
[ , 2] </td><td style="text-align: left;"> <b>F</b>   </td><td style="text-align: left;"> former regime type competition ("2" no, "1" limited, "0" multi-party)   </td>
</tr>
<tr>
 <td style="text-align: right;">
[ , 3] </td><td style="text-align: left;"> <b>T</b>   </td><td style="text-align: left;"> transition mode ("2" managed, "1" pacted, "0" democracy before 1990) </td>
</tr>
<tr>
 <td style="text-align: right;">
[ , 4] </td><td style="text-align: left;"> <b>V</b>   </td><td style="text-align: left;"> ethnic violence ("1" yes, "0" no)      </td>
</tr>
<tr>
 <td style="text-align: right;">
[ , 5] </td><td style="text-align: left;"> <b>PB</b>  </td><td style="text-align: left;"> introduction of party ban provisions ("1" yes, "0" no)   </td>
</tr>
<tr>
 <td style="text-align: right;">  
</td>
</tr>

</table>



<h3>Source</h3>

<p>Hartmann, Christof, and Joerg Kemmerzell. 2010. &ldquo;Understanding Variations 
in Party Bans in Africa.&rdquo; <em>Democratization</em> 17(4):642-65.
doi:10.1080/13510347.2010.491189.
</p>

<hr>
<h2 id='d.performance'>Data on combinations of industry, corporate, and business-unit effects</h2><span id='topic+d.performance'></span>

<h3>Description</h3>

<p>This dataset is from Greckhammer et al. (2008), who analyze the causal conditions for superior (above average) business-unit performance of corporations in the manufacturing sector during the years 1995 to 1998.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>d.performance</code></pre>


<h3>Format</h3>

<p>The data frame contains 214 rows featuring configurations, one column reporting the frequencies of each configuration, and 8 columns listing the following Boolean factors:
</p>

<table>
<tr>
 <td style="text-align: right;">
[ , 1] </td><td style="text-align: left;"> <b>MU</b> </td><td style="text-align: left;"> above average industry munificence     </td>
</tr>
<tr>
 <td style="text-align: right;">
[ , 2] </td><td style="text-align: left;"> <b>DY</b> </td><td style="text-align: left;"> high industry dynamism </td>
</tr>
<tr>
 <td style="text-align: right;">
[ , 3] </td><td style="text-align: left;"> <b>CO</b> </td><td style="text-align: left;"> high industry competitiveness   </td>
</tr>
<tr>
 <td style="text-align: right;">
[ , 4] </td><td style="text-align: left;"> <b>DIV</b> </td><td style="text-align: left;"> high corporate diversification      </td>
</tr>
<tr>
 <td style="text-align: right;">
[ , 5] </td><td style="text-align: left;"> <b>CRA</b> </td><td style="text-align: left;"> above median corporate resource availability        </td>
</tr>
<tr>
 <td style="text-align: right;">
[ , 6] </td><td style="text-align: left;"> <b>CI</b> </td><td style="text-align: left;">  above median corporate capital intensity </td>
</tr>
<tr>
 <td style="text-align: right;"> 
[ , 7] </td><td style="text-align: left;"> <b>BUS</b> </td><td style="text-align: left;">  large business-unit size </td>
</tr>
<tr>
 <td style="text-align: right;">
[ , 8] </td><td style="text-align: left;"> <b>SP</b> </td><td style="text-align: left;">  above average business-unit performance (in the manufacturing sector)</td>
</tr>
<tr>
 <td style="text-align: right;">
</td>
</tr>

</table>



<h3>Source</h3>

<p>Greckhamer, Thomas, Vilmos F. Misangyi, Heather Elms, and Rodney Lacey. 2008.
&ldquo;Using Qualitative Comparative Analysis in Strategic Management Research: An Examination of Combinations of Industry, Corporate, and Business-Unit Effects.&rdquo;
<em>Organizational Research Methods</em> 11 (4):695-726.
</p>

<hr>
<h2 id='d.volatile'>Data on the volatility of grassroots associations in Norway between 1980 and 2000</h2><span id='topic+d.volatile'></span>

<h3>Description</h3>

<p>This dataset is from Wollebaek (2010), who analyzes the causes of disbandings of grassroots associations in Norway.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>d.volatile</code></pre>


<h3>Format</h3>

<p>The data frame contains 22 rows (cases) and the following 9 columns featuring Boolean factors taking values 1 and 0 only:
</p>

<table>
<tr>
 <td style="text-align: right;">
[ , 1] </td><td style="text-align: left;"> <b>PG</b> </td><td style="text-align: left;"> high population growth                         </td>
</tr>
<tr>
 <td style="text-align: right;">
[ , 2] </td><td style="text-align: left;"> <b>RB</b> </td><td style="text-align: left;"> high rurbanization (i.e. people moving to previously sparsely populated areas that are</td>
</tr>
<tr>
 <td style="text-align: right;"></td><td style="text-align: left;"></td><td style="text-align: left;"> not adjacent to a larger city)</td>
</tr>
<tr>
 <td style="text-align: right;">
[ , 3] </td><td style="text-align: left;"> <b>EL</b> </td><td style="text-align: left;"> high increase in education levels                                           </td>
</tr>
<tr>
 <td style="text-align: right;">
[ , 4] </td><td style="text-align: left;"> <b>SE</b> </td><td style="text-align: left;"> high degree of secularization                                    </td>
</tr>
<tr>
 <td style="text-align: right;">
[ , 5] </td><td style="text-align: left;"> <b>CS</b> </td><td style="text-align: left;"> existence of Christian strongholds        </td>
</tr>
<tr>
 <td style="text-align: right;">
[ , 6] </td><td style="text-align: left;"> <b>OD</b> </td><td style="text-align: left;"> high organizational density </td>
</tr>
<tr>
 <td style="text-align: right;">
[ , 7] </td><td style="text-align: left;"> <b>PC</b> </td><td style="text-align: left;"> existence of polycephality (i.e. municipalities with multiple centers)</td>
</tr>
<tr>
 <td style="text-align: right;">
[ , 8] </td><td style="text-align: left;"> <b>UP</b> </td><td style="text-align: left;"> urban proximity        </td>
</tr>
<tr>
 <td style="text-align: right;">
[ , 9] </td><td style="text-align: left;"> <b>VO2</b> </td><td style="text-align: left;"> very high volatility of grassroots associations        
</td>
</tr>

</table>



<h3>Source</h3>

<p>Wollebaek, Dag. 2010.
&ldquo;Volatility and Growth in Populations of Rural Associations.&rdquo;
<em>Rural Sociology</em> 75:144-166.
</p>

<hr>
<h2 id='d.women'>Data on high percentage of women's representation in parliaments of western countries</h2><span id='topic+d.women'></span>

<h3>Description</h3>

<p>This dataset is from Krook (2010), who analyzes the causal conditions for high women's representation in western-democratic parliaments.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>d.women</code></pre>


<h3>Format</h3>

<p>The data frame contains 22 rows (cases) and the following 6 columns featuring Boolean factors taking values 1 and 0 only:
</p>

<table>
<tr>
 <td style="text-align: right;">
[ , 1] </td><td style="text-align: left;"> <b>ES</b> </td><td style="text-align: left;"> existence of a PR electoral system     </td>
</tr>
<tr>
 <td style="text-align: right;">
[ , 2] </td><td style="text-align: left;"> <b>QU</b> </td><td style="text-align: left;"> existence of quotas for women </td>
</tr>
<tr>
 <td style="text-align: right;">
[ , 3] </td><td style="text-align: left;"> <b>WS</b> </td><td style="text-align: left;"> existence of social-democratic welfare system   </td>
</tr>
<tr>
 <td style="text-align: right;">
[ , 4] </td><td style="text-align: left;"> <b>WM</b> </td><td style="text-align: left;"> existence of autonomous women's movement      </td>
</tr>
<tr>
 <td style="text-align: right;">
[ , 5] </td><td style="text-align: left;"> <b>LP</b> </td><td style="text-align: left;"> strong left parties        </td>
</tr>
<tr>
 <td style="text-align: right;">
[ , 6] </td><td style="text-align: left;"> <b>WNP</b> </td><td style="text-align: left;"> high women's representation in parliament 
</td>
</tr>

</table>



<h3>Source</h3>

<p>Krook, Mona Lena. 2010.
&ldquo;Women's Representation in Parliament: A Qualitative Comparative Analysis.&rdquo;
<em>Political Studies</em> 58 (5):886-908.
</p>

<hr>
<h2 id='full.ct'>
Generate the logically possible value configurations of a given set of factors
</h2><span id='topic+full.ct'></span><span id='topic+full.ct.default'></span><span id='topic+full.ct.configTable'></span><span id='topic+full.ct.cti'></span>

<h3>Description</h3>

<p>The function <code>full.ct</code> generates a <code>configTable</code> with all (or a specified number of) logically possible value configurations of the factors defined in the input <code>x</code>. It is more flexible than <code><a href="#topic+allCombs">allCombs</a></code>. 
<code>x</code> can be a <code>configTable</code>, a data frame, an integer, a list specifying the factors' value ranges, or a character string expressing a condition featuring all admissible factor values.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>full.ct(x, ...)

## Default S3 method:
full.ct(x, type = "auto", cond = NULL, nmax = NULL, ...)
## S3 method for class 'configTable'
full.ct(x, cond = NULL, nmax = NULL, ...)
## S3 method for class 'cti'
full.ct(x, cond = NULL, nmax = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="full.ct_+3A_x">x</code></td>
<td>
<p>A <code>configTable</code>, a data frame, a matrix, an integer, a list specifying the factors' value ranges,  or a character vector featuring all admissible factor values (see the details and examples below).</p>
</td></tr>
<tr><td><code id="full.ct_+3A_type">type</code></td>
<td>
<p>Character vector specifying the type of <code>x</code>: <code>"auto"</code> (automatic detection; default), <code>"cs"</code> (crisp-set), <code>"mv"</code> (multi-value),  or <code>"fs"</code> (fuzzy-set). (Manual specification of the <code>type</code> only has an effect if <code>x</code> is a data frame or matrix.)</p>
</td></tr>
<tr><td><code id="full.ct_+3A_cond">cond</code></td>
<td>
<p>Optional character vector containing conditions in the syntax of msc, asf or csf. If it is not <code>NULL</code>, only factors appearing in <code>cond</code> are used.</p>
</td></tr>
<tr><td><code id="full.ct_+3A_nmax">nmax</code></td>
<td>
<p>Maximal number of rows in the output <code>configTable</code>. If <code>nmax</code> is smaller than the total number of logically possible configurations, a random sample of configurations is drawn. The default <code>nmax = NULL</code> selects all logically possible configurations.</p>
</td></tr>
<tr><td><code id="full.ct_+3A_...">...</code></td>
<td>

<p>Further arguments passed to methods.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>full.ct</code> generates all or <code>nmax</code> logically possible value configurations of the factors defined in <code>x</code>, which can either be a character vector or an integer or a list or a data frame or a matrix. </p>

<ul>
<li><p>If <code>x</code> is a character vector, it can be a condition of any of the three types of conditions, <em>boolean</em>, <em>atomic</em> or <em>complex</em> (see <code><a href="#topic+condition">condition</a></code>). <code>x</code> must contain at least one factor. Factor names and admissible values are guessed from the Boolean formulas. If <code>x</code> contains multi-value factors, only those values are considered admissible that are explicitly contained in <code>x</code>. Accordingly, in case of multi-value factors, <code>full.ct</code> should be given the relevant factor definitions by means of a list (see below).

</p>
</li>
<li><p>If <code>x</code> is an integer, the output is a configuration table of type <code>"cs"</code> with <code>x</code> factors. If <code>x &lt;= 26</code>, the first <code>x</code> capital letters of the alphabet are used as the names of the factors. If <code>x &gt; 26</code>, factors are named &quot;X1&quot; to &quot;Xx&quot;. 

</p>
</li>
<li><p>If <code>x</code> is a list, <code>x</code> is expected to have named elements each of which provides the factor names with corresponding vectors enumerating their admissible values (i.e. their value ranges). These values must be non-negative integers.

</p>
</li>
<li><p>If <code>x</code> is a <code>configTable</code>, data frame, or matrix, <code>colnames(x)</code> are interpreted as factor names and the rows as enumerating the admissible values (i.e. as value ranges). If <code>x</code> is a data frame or a matrix, <code>x</code> is first converted to a <code><a href="#topic+configTable">configTable</a></code> (the function <code>configTable</code> is called with <code>type</code> as specified in <code>full.ct</code>), and the <code>configTable</code> method of <code>full.ct</code> is then applied to the result. The <code>configTable</code> method uses all factors and factor values occurring in the <code>configTable</code>. If <code>x</code> is of type <code>"fs"</code>, 0 and 1 are taken as the admissible values.

</p>
</li></ul>

<p>The computational demand of generating all logically possible configurations increases exponentially with the number of factors in <code>x</code>. In order to get an output in reasonable time, even when <code>x</code> features more than about 15 factors, the argument <code>nmax</code> allows for specifying a maximal number of configurations to be returned (by random sampling).
</p>
<p>If not all factors specified in <code>x</code> are of interest but only those in a given msc, asf, or csf, <code>full.ct</code> can be correspondingly restricted via the argument <code>cond</code>. For instance, <code>full.ct(d.educate, cond = "D + L &lt;-&gt; E")</code> generates the logically possible value configurations of the factors in the set {D, L, E}, even though <code>d.educate</code> contains further factors. The argument <code>cond</code> is primarily used internally to speed up the execution of various functions in case of high-dimensional data. 
</p>
<p>The main area of application of <code>full.ct</code> is data simulation in the context of inverse search trials benchmarking the output of <code>cna</code> (see examples below). While <code>full.ct</code> generates the relevant space of logically possible configurations of the factors in an analyzed factor set, <code><a href="#topic+selectCases">selectCases</a></code> selects those configurations from this space that are compatible with a given data generating causal structure (i.e. the ground truth), that is, it selects the empirically possible configurations.
</p>
<p>The method for class &quot;cti&quot; is for internal use only.
</p>


<h3>Value</h3>

<p>A <code><a href="#topic+configTable">configTable</a></code> of type <code>"cs"</code> or <code>"mv"</code> with the full enumeration of combinations of the factor values.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+configTable">configTable</a></code>, <code><a href="#topic+selectCases">selectCases</a></code>, <code><a href="#topic+allCombs">allCombs</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># x is a character vector.
full.ct("A + B*c")
full.ct("A=1*C=3 + B=2*C=1 + A=3*B=1") 
full.ct(c("A + b*C", "a*D"))
full.ct("!A*-(B + c) + F")
full.ct(c("A=1", "A=2", "B=1", "B=0", "C=13","C=45"))

# x is a data frame.
full.ct(d.educate)
full.ct(d.jobsecurity)
full.ct(d.pban)

# x is a configTable.
full.ct(configTable(d.jobsecurity))
full.ct(configTable(d.pban), cond = "C=1 + F=0 &lt;-&gt; V=1") 

# x is an integer.
full.ct(6)
# Constrain the number of configurations to 1000.
full.ct(30, nmax = 1000) 

# x is a list.
full.ct(list(A = 0:1, B = 0:1, C = 0:1))  # cs
full.ct(list(A = 1:2, B = 0:1, C = 23:25))  # mv

# Simulating crisp-set data.
groundTruth.1 &lt;- "(A*b + C*d &lt;-&gt; E)*(E*H + I*k &lt;-&gt; F)"
fullData &lt;- ct2df(full.ct(groundTruth.1))
idealData &lt;- ct2df(selectCases(groundTruth.1, fullData))
# Introduce 20% data fragmentation.
fragData &lt;- idealData[-sample(1:nrow(idealData), nrow(idealData)*0.2), ] 
# Add 10% random noise.
incompData &lt;- dplyr::setdiff(fullData, idealData)
(realData &lt;- rbind(incompData[sample(1:nrow(incompData), nrow(fragData)*0.1), ], 
  fragData))

# Simulating multi-value data.
groundTruth.2 &lt;- "(JO=3 + TS=1*PE=3 &lt;-&gt; ES=1)*(ES=1*HI=4 + IQ=2*KT=5 &lt;-&gt; FA=1)"
fullData &lt;- ct2df(full.ct(list(JO=1:3, TS=1:2, PE=1:3, ES=1:2, HI=1:4, IQ=1:5, KT=1:5, FA=1:2)))
idealData &lt;- ct2df(selectCases(groundTruth.2, fullData))
# Introduce 20% data fragmentation.
fragData &lt;- idealData[-sample(1:nrow(idealData), nrow(idealData)*0.2), ] 
# Add 10% random noise.
incompData &lt;- dplyr::setdiff(fullData, idealData)
(realData &lt;- rbind(incompData[sample(1:nrow(incompData), nrow(fragData)*0.1), ], 
  fragData))

</code></pre>

<hr>
<h2 id='is.inus'>
Check whether expressions in the syntax of CNA solutions have INUS form
</h2><span id='topic+is.inus'></span>

<h3>Description</h3>

<p><code>is.inus</code> checks for each element of a character vector of disjunctive normal forms (DNFs) or expressions in the syntax of CNA solution formulas whether it has INUS form, meaning whether it is free of redundancies in necessary or sufficient conditions, free of structural redundancies and partial structural redundancies, whether it has constant factors or identical outcomes, and whether it is tautologous or contradictory.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is.inus(cond, x = NULL, csf.info = FALSE, def = c("implication", "equivalence"))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="is.inus_+3A_cond">cond</code></td>
<td>

<p>Character vector of DNFs or expressions in the syntax of CNA solutions (i.e. asf or csf). </p>
</td></tr>
<tr><td><code id="is.inus_+3A_x">x</code></td>
<td>
<p>An optional argument providing a <code>configTable</code>, a data frame, or a list specifying the factors' value ranges if <code>cond</code> contains multi-value factors; if <code>x</code> is not <code>NULL</code>, <code>is.inus</code> tests whether <code>cond</code> has INUS form relative to <code>full.ct(x)</code>, otherwise relative to <code>full.ct(cond)</code>.
</p>
</td></tr>
<tr><td><code id="is.inus_+3A_csf.info">csf.info</code></td>
<td>
<p>Logical; if <code>TRUE</code> and <code>cond</code> has the syntax of a csf, details about the performed INUS checks are printed. If <code>cond</code> does not have the syntax of a csf, <code>csf.info</code> has no effect.
</p>
</td></tr>
<tr><td><code id="is.inus_+3A_def">def</code></td>
<td>
<p>Character string specifying the definition of partial structural redundancy (PSR) to be applied. If <code>def = "implication"</code> (default), <code>cond</code> is treated as containing a PSR iff <code>cond</code> logically implies a proper submodel of itself. If <code>def = "equivalence"</code>, a PSR obtains iff  <code>cond</code> is logically equivalent with a proper submodel of itself. The character string can be abbreviated. <b>Note:</b> To reproduce results produced by versions of the package prior to 3.6.0, def may have to be set to <code>"equivalence"</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A Boolean dependency structure is not interpretable in terms of a deterministic causal structure if it contains at least one of the following (cf. the &ldquo;Examples&rdquo; section for examples): </p>
 <ol>
<li><p> redundancies in necessary or sufficient conditions, </p>
</li>
<li><p> structural redundancies,</p>
</li>
<li><p> partial structural redundancies, </p>
</li>
<li><p> constant factors, </p>
</li>
<li><p>  tautologous or contradictory substructures, </p>
</li>
<li><p> multiple instances of the same outcome. </p>
</li></ol>

<p>The function <code>is.inus</code> takes a character vector <code>cond</code> specifying Boolean disjunctive normal forms (DNFs) or expressions in the syntax of CNA solution formulas as input and runs a series of checks on <code>cond</code>; one for each of the conditions (1) to (6). For instance, whenever <code>cond</code> logically implies a syntactic proper part of itself, the surplus in <code>cond</code> is redundant, meaning that it violates condition (1) and is not causally interpretable. To illustrate, &ldquo;A + a*B &lt;-&gt; C&rdquo; implies and is even logically equivalent to &ldquo;A + B &lt;-&gt; C&rdquo;. Hence, &quot;a&quot; is redundant in the first expression, which is not causally interpretable due to a violation of condition (1).
Or the first asf in &ldquo;(a + C &lt;-&gt; D)*(D + G &lt;-&gt; A)&rdquo; implies that whenever &quot;a&quot; is given, so is &quot;D&quot;, while the second asf implies that whenever &quot;D&quot; is given, so is &quot;A&quot;. It follows that &quot;a&quot; cannot ever be given, meaning that the factor A takes the constant value 1 and, hence, violates condition (4). As constant factors can neither be causes nor effects, &ldquo;(a + C &lt;-&gt; D)*(D + G &lt;-&gt; A)&rdquo; is not a well-formed causal structure.
</p>
<p>If an expression passes the <code>is.inus</code>-check it can be interpreted as a causal structure according to Mackie's (1974) INUS-theory of causation or modern variants thereof (e.g. Grasshoff and May 2001; Baumgartner and Falk 2023). In other words, such an expression has the form of an INUS structure, i.e. it has <em>INUS form</em>, for short.
</p>
<p>In the function's default call with <code>x = NULL</code>, the INUS checks are performed relative to <code>full.ct(cond)</code>; if <code>x</code> is not <code>NULL</code>, the checks are performed relative to <code>full.ct(x)</code>. As <code>full.ct(cond)</code> and <code>full.ct(x)</code> coincide in case of binary factors, the argument <code>x</code> has no effect in the crisp-set and fuzzy-set cases. In case of multi-value factors, however, the argument <code>x</code> should be specified in order to define the factors' value ranges (see examples below).
</p>
<p>If the argument <code>csf.info</code> is set to its non-default value <code>TRUE</code> and <code>cond</code> has the syntax of a csf, the results of the individual checks of conditions (1) to (6) are printed (in that order) to the console.
</p>
<p>In its default setting, the <code>cna</code> function does not output solutions that do not have INUS form. But when <code>cna</code> is called with <code>inus.only = FALSE</code>, non-INUS solutions may be returned. The function <code>is.inus</code> is standardly called from within the <code>cna</code> function to determine whether its output has INUS form. 
<code>is.inus</code> also serves an important purpose in the context of benchmark tests. Not any Boolean expression can be interpreted to represent a causal structure; only expressions in INUS form can. That means when simulating data on randomly drawn target structures, it must be ensured that the latter have INUS form. An expression as &ldquo;A + a*B &lt;-&gt; C&rdquo;, which has a logically equivalent proper part and, hence, does not have INUS form, is not a well-formed causal structure that could be used as a search target in a benchmark test.
</p>


<h3>Value</h3>

<p>Logical vector of the same length as <code>cond</code>; if <code>cond</code> is a csf and <code>is.inus</code> is called with <code>csf.info = TRUE</code>, an attribute &ldquo;csf.info&rdquo; is added.
</p>


<h3>References</h3>

<p>Baumgartner, Michael and Christoph Falk. 2023. &ldquo;Boolean Difference-Making: A Modern Regularity Theory of Causation&rdquo;. <em>The British Journal for the Philosophy of Science</em>, 74(1), 171-197. doi:10.1093/bjps/axz047.
</p>
<p>Grasshoff, Gerd and Michael May. 2001. &ldquo;Causal Regularities.&rdquo; In W Spohn, M Ledwig, M Esfeld (eds.), <em>Current Issues in Causation</em>, pp. 85-114. Mentis, Paderborn.
</p>
<p>Mackie, John L. 1974. <em>The Cement of the Universe: A Study of Causation</em>. Oxford: Oxford University Press.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+condition">condition</a></code>, <code><a href="#topic+full.ct">full.ct</a></code>, <code><a href="#topic+redundant">redundant</a></code>, <code><a href="#topic+minimalize">minimalize</a></code>, <code><a href="#topic+cna">cna</a></code>, <code><a href="#topic+minimalizeCsf">minimalizeCsf</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Crisp-set case
# --------------
# Testing disjunctive normal forms. 
is.inus(c("A", "A + B", "A + a*B", "A + a", "A*a", "A*a + B"))
  
# Testing expressions in the syntax of atomic solution formulas.
is.inus(c("A + B &lt;-&gt; C", "A + B &lt;-&gt; c", "A + a*B &lt;-&gt; C", "A*a + B &lt;-&gt; C", "A + a &lt;-&gt; C", 
          "F*G + f*g + H &lt;-&gt; E", "F*G + f*g + H*F + H*G &lt;-&gt; E")) 

# Testing expressions in the syntax of complex solution formulas.
is.inus(c("(A + B &lt;-&gt; C)*(c + E &lt;-&gt; D)", "(A &lt;-&gt; B)*(B &lt;-&gt; C)", "(A &lt;-&gt; B)*(B &lt;-&gt; C)*(C &lt;-&gt; D)", 
          "(A &lt;-&gt; B)*(B &lt;-&gt; a)", "(A*B + c &lt;-&gt; D)*(E + f &lt;-&gt; D)",
          "(A + B &lt;-&gt; C)*(B*c + E &lt;-&gt; D)"))

# A redundancy in necessary or sufficient conditions, i.e. 
# a non-INUS asf in a csf.
is.inus("(A + A*B &lt;-&gt; C)*(B + D &lt;-&gt; E)", csf.info = TRUE)

# A structural redundancy in a csf.
cond1 &lt;- "(e + a*D &lt;-&gt; C)*(C + A*B &lt;-&gt; D)*(a + c &lt;-&gt; E)"
is.inus("(e + a*D &lt;-&gt; C)*(C + A*B &lt;-&gt; D)*(a + c &lt;-&gt; E)", csf.info = TRUE)
# The first asf in cond1 is redundant.
minimalizeCsf(cond1, selectCases(cond1))

# A partial structural redundancy in a csf.
cond2 &lt;- "(A + B*c + c*E &lt;-&gt; D)*(B + C &lt;-&gt; E)"
is.inus(cond2, csf.info = TRUE)
# The second or third disjunct in the first asf of cond2 is redundant.
cna(selectCases(cond2))
# The notion of a partial structural redundancy (PSR) can be defined in two 
# different ways. To illustrate, consider the following two csfs.
cond2b &lt;- "(B + F*C &lt;-&gt; A)*(A*e*f &lt;-&gt; B)"
cond2c &lt;- "(B + F*C &lt;-&gt; A)*(A*f &lt;-&gt; B)"
# cond2c is a proper submodel of cond2b, and cond2b logically implies cond2c,
# but the two csfs are not logically equivalent (i.e. cond2c does not 
# imply cond2b). If a PSR is said to obtain when one csf logically implies 
# a proper submodel of itself, then cond2b contains a PSR. If a csf has to be
# logically equivalent to a proper submodel of itself in order for a PSR to 
# obtain, then cond2b does not contain a PSR. This difference is implemented
# in the argument def of is.inus(). The default is def = "implication".
is.inus(cond2b, csf.info = TRUE, def = "implication")
is.inus(cond2b, csf.info = TRUE, def = "equivalence")
# The two definitions of PSR only come apart in case of cyclic structures.
# In versions of cna prior to 3.6.0, is.inus() implemented the "equivalence" 
# definition of PSR. That is, to reproduce results of earlier versions, def may
# have to be set to "equivalence". 

# A csf entailing that one factor is constant.
is.inus("(a + C &lt;-&gt; D)*(D + G &lt;-&gt; A)", csf.info = TRUE)

# A contradictory (i.e. logically constant) csf.
is.inus("(A &lt;-&gt; B)*(B &lt;-&gt; a)", csf.info = TRUE)

# A csf with multiple identical outcomes.
is.inus("(A + C &lt;-&gt; B)*(C + E &lt;-&gt; B)", csf.info = TRUE)


# Multi-value case
# ----------------
# In case of multi-value data, is.inus() needs to be given a dataset x determining
# the value ranges of the factors in cond.
mvdata &lt;- configTable(setNames(allCombs(c(2, 3, 2, 3)) -1, c("C", "F", "V", "O")))
is.inus("C=1 + F=2*V=0 &lt;-&gt; O=2", mvdata)
# x can also be given to is.inus() as a list.
is.inus("C=1 + F=2*V=0 &lt;-&gt; O=2", list(C=0:1, F=0:2, V=0:1, O=0:2))
# When x is NULL, is.inus() is applied to full.ct("C=1 + F=2*V=0"), which has only
# one single row. That row is then interpreted to be the only possible configuration, 
# in which case C=1 + F=2*V=0 is tautologous and, hence, non-INUS.
is.inus("C=1 + F=2*V=0 &lt;-&gt; O=2") 
        
is.inus("C=1 + C=0*C=2", configTable(d.pban))    # contradictory
is.inus("C=0 + C=1 + C=2", configTable(d.pban))  # tautologous

# A redundancy in necessary or sufficient conditions, i.e. a 
# non-INUS asf in a csf.
fullDat &lt;- full.ct(list(A=1:3, B=1:3, C=1:3, D=1:3, E=1:3))
is.inus("(A=1 + A=1*B=2 &lt;-&gt; C=3)*(B=2 + D=3 &lt;-&gt; E=1)", fullDat, csf.info = TRUE)

# A structural redundancy in a csf.
cond3 &lt;- "(E=2 + C=1*D=3 &lt;-&gt; A=1)*(A=3*E=1 + C=2*D=2 &lt;-&gt; B=3)*(A=1*E=3 + D=2*E=3 &lt;-&gt; C=1)*
          (A=1*C=2 + A=1*C=3 &lt;-&gt; E=2)"
is.inus(cond3, fullDat, csf.info = TRUE)
# The last asf in cond3 is redundant.
minimalizeCsf(cond3, selectCases(cond3, fullDat))

# A partial structural redundancy in a csf.
cond4 &lt;- "(B=2*C=3 + C=2*D=1 + B=2*C=1*D=2*E=1 &lt;-&gt; A=2)*(D=2*E=1 + D=3*E=1 &lt;-&gt; B=1)"
is.inus(cond4, fullDat, csf.info = TRUE)
# The third disjunct in the first asf of cond4 is redundant.
cna(selectCases(cond4, fullDat))

# A csf entailing that one factor is constant. (I.e. D is constantly ~(D=1).)
cond5 &lt;- "(A=1 + B=2 + E=3 &lt;-&gt;C=3)*(A=1*C=1 + B=2*C=1 &lt;-&gt; D=1)"
is.inus(cond5, fullDat, csf.info = TRUE)

# A contradictory csf.
is.inus("(A=1 &lt;-&gt; C=1)*(A=1 &lt;-&gt; C=2)*(A=1 &lt;-&gt; C=3)", fullDat, csf.info = TRUE)

# A csf with multiple identical outcomes.
is.inus("(A=1 + B=2 + D=3 &lt;-&gt; C=1)*(A=2 + B=3 + D=2 &lt;-&gt; C=1)", fullDat, csf.info = TRUE)


# Fuzzy-set case 
# --------------
fsdata &lt;- configTable(d.jobsecurity)
conds &lt;- csf(cna(fsdata, con = 0.85, cov = 0.85, inus.only = FALSE))$condition
# Various examples of different types.
is.inus(conds[1:10], fsdata, csf.info = TRUE)
is.inus(c("S + s", "S + s*R", "S*s"), fsdata)

# A redundancy in necessary or sufficient conditions, i.e. a 
# non-INUS asf in a csf.
is.inus("(S + s*L &lt;-&gt; JSR)*(R + P &lt;-&gt; V)", fsdata, csf.info = TRUE)

# A structural redundancy in a csf.
is.inus("(s + l*R &lt;-&gt; C)*(C + L*V &lt;-&gt; R)*(l + c &lt;-&gt; S)", fsdata, csf.info = TRUE)

# A partial structural redundancy in a csf.
is.inus("(S + L*c + c*R &lt;-&gt; P)*(L + C &lt;-&gt; R)", fsdata, csf.info = TRUE)

# A csf entailing that one factor is constant.
is.inus("(S + L &lt;-&gt; P)*(L*p &lt;-&gt; JSR)", csf.info = TRUE)

# A contradictory csf.
is.inus("(S &lt;-&gt; JSR)*(JSR &lt;-&gt; s)", fsdata, csf.info = TRUE)

# A csf with multiple identical outcomes.
is.inus("(S*C + V &lt;-&gt; JSR)*(R + P &lt;-&gt; JSR)", fsdata, csf.info = TRUE)
</code></pre>

<hr>
<h2 id='is.submodel'>
Identify correctness-preserving submodel relations
</h2><span id='topic+is.submodel'></span><span id='topic+identical.model'></span>

<h3>Description</h3>

<p>The function <code>is.submodel</code> checks for each element of a vector of <code><a href="#topic+cna">cna</a></code> solution formulas whether it is a submodel of a specified target model <code>y</code>. If <code>y</code> is the true model in an inverse search (i.e. the ground truth), <code>is.submodel</code> identifies correct models in the <code><a href="#topic+cna">cna</a></code> output (see Baumgartner and Thiem 2020, Baumgartner and Ambuehl 2020).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is.submodel(x, y, strict = FALSE)
identical.model(x, y)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="is.submodel_+3A_x">x</code></td>
<td>
<p>Character vector of atomic and/or complex solution formulas (asf/csf). Must be of length 1 in <code>identical.model</code>.</p>
</td></tr>
<tr><td><code id="is.submodel_+3A_y">y</code></td>
<td>
<p>Character string of length 1 specifying the target asf or csf.</p>
</td></tr>
<tr><td><code id="is.submodel_+3A_strict">strict</code></td>
<td>
<p>Logical; if <code>TRUE</code>, the elements of <code>x</code> only count as submodels of <code>y</code> if they are proper parts of <code>y</code> (i.e. not identical to <code>y</code>).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>To benchmark the reliability of a method of causal inference it must be tested to what degree the method recovers the true data generating structure <code class="reqn">\Delta</code> or proper substructures of <code class="reqn">\Delta</code> from data of varying quality. Reliability benchmarking is done in so-called <em>inverse searches</em>, which reverse the order of causal discovery as normally conducted in scientific practice. An inverse search comprises three steps: (1) a causal structure <code class="reqn">\Delta</code> is drawn/presupposed (as ground truth), (2) artificial data <code class="reqn">\delta</code> is simulated from <code class="reqn">\Delta</code>, possibly featuring various deficiencies (e.g. noise, fragmentation, measurement error etc.), and (3) <code class="reqn">\delta</code> is processed by the benchmarked method in order to check whether its output meets the tested reliability benchmark (e.g. whether the output is true of or identical to <code class="reqn">\Delta</code>). 
</p>
<p>The main purpose of <code>is.submodel</code> is to execute step (3) of an inverse search that is tailor-made to test the reliability of <code><a href="#topic+cna">cna</a></code> [with <code><a href="#topic+randomConds">randomConds</a></code> and <code><a href="#topic+selectCases">selectCases</a></code> designed for steps (1) and (2), respectively]. A solution formula <code>x</code> being a submodel of a target formula <code>y</code> means that all the causal claims entailed by <code>x</code> are true of <code>y</code>, which is the case if a causal interpretation of <code>x</code> entails conjunctive and disjunctive causal relevance relations that are all likewise entailed by a causal interpretation of <code>y</code>. More specifically, <code>x</code> is a submodel of <code>y</code> if, and only if, the following conditions are satisfied: (i) all factor values causally relevant according to <code>x</code> are also causally relevant according to <code>y</code>, (ii) all factor values contained in two different disjuncts in <code>x</code> are also contained in two different disjuncts in <code>y</code>, (iii) all factor values contained in the same conjunct in <code>x</code> are also contained in the same conjunct in <code>y</code>, and (iv) if <code>x</code> is a csf with more than one asf, (i) to (iii) are satisfied for all asfs in <code>x</code>. For more details see Baumgartner and Thiem (2020) or Baumgartner and Ambuehl (2020, online appendix).
</p>
<p><code>is.submodel</code> requires two inputs <code>x</code> and <code>y</code>, where <code>x</code> is a character vector of <code><a href="#topic+cna">cna</a></code> solution formulas (asf or csf) and <code>y</code> is one asf or csf (i.e. a character string of length 1), viz. the target structure or ground truth. The function returns <code>TRUE</code> for elements of <code>x</code> that are a submodel of <code>y</code> according to the definition of submodel-hood given in the previous paragraph. If <code>strict = TRUE</code>, <code>x</code> counts as a submodel of <code>y</code> only if <code>x</code> is a proper part of <code>y</code> (i.e. <code>x</code> is not identical to <code>y</code>).
</p>
<p>The function <code>identical.model</code> returns <code>TRUE</code> only if <code>x</code> (which must be of length 1) and <code>y</code> are identical. It can be used to test whether <code>y</code> is completely recovered in an inverse search.
</p>


<h3>Value</h3>

<p>Logical vector of the same length as <code>x</code>.</p>


<h3>References</h3>

<p>Baumgartner, Michael and Mathias Ambuehl. 2020. &ldquo;Causal Modeling with Multi-Value and Fuzzy-Set Coincidence Analysis.&rdquo; <em>Political Science Research and Methods</em>. 8:526&ndash;542.
</p>
<p>Baumgartner, Michael and Alrik Thiem. 2020. &ldquo;Often Trusted But Never (Properly) Tested: Evaluating Qualitative Comparative Analysis&rdquo;. <em>Sociological Methods &amp; Research</em> 49:279-311.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+randomConds">randomConds</a></code>, <code><a href="#topic+selectCases">selectCases</a></code>, <code><a href="#topic+cna">cna</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Binary expressions
# ------------------
trueModel.1 &lt;- "(A*b + a*B &lt;-&gt; C)*(C*d + c*D &lt;-&gt; E)"
candidates.1 &lt;- c("(A + B &lt;-&gt; C)*(C + c*D &lt;-&gt; E)", "A + B &lt;-&gt; C", 
                 "(A &lt;-&gt;  C)*(C &lt;-&gt; E)", "C &lt;-&gt; E")
candidates.2 &lt;- c("(A*B + a*b &lt;-&gt; C)*(C*d + c*D &lt;-&gt; E)", "A*b*D + a*B &lt;-&gt; C", 
                 "(A*b + a*B &lt;-&gt; C)*(C*A*D &lt;-&gt; E)", "D &lt;-&gt; C", 
                 "(A*b + a*B + E &lt;-&gt; C)*(C*d + c*D &lt;-&gt; E)")

is.submodel(candidates.1, trueModel.1)
is.submodel(candidates.2, trueModel.1)
is.submodel(c(candidates.1, candidates.2), trueModel.1)

is.submodel("C + b*A &lt;-&gt; D", "A*b + C &lt;-&gt; D")
is.submodel("C + b*A &lt;-&gt; D", "A*b + C &lt;-&gt; D", strict = TRUE)
identical.model("C + b*A &lt;-&gt; D", "A*b + C &lt;-&gt; D")

target.1 &lt;- "(A*b + a*B &lt;-&gt; C)*(C*d + c*D &lt;-&gt; E)"
testformula.1 &lt;- "(A*b + a*B &lt;-&gt; C)*(C*d + c*D &lt;-&gt; E)*(A + B &lt;-&gt; C)"
is.submodel(testformula.1, target.1)

# Multi-value expressions
# -----------------------
trueModel.2 &lt;- "(A=1*B=2 + B=3*A=2 &lt;-&gt; C=3)*(C=1 + D=3 &lt;-&gt; E=2)"
is.submodel("(A=1*B=2 + B=3 &lt;-&gt; C=3)*(D=3 &lt;-&gt; E=2)", trueModel.2)
is.submodel("(A=1*B=1 + B=3 &lt;-&gt; C=3)*(D=3 &lt;-&gt; E=2)", trueModel.2)
is.submodel(trueModel.2, trueModel.2)
is.submodel(trueModel.2, trueModel.2, strict = TRUE)

target.2 &lt;- "C=2*D=1*B=3 + A=1 &lt;-&gt; E=5"
testformula.2 &lt;- c("C=2 + D=1 &lt;-&gt; E=5","C=2 + D=1*B=3 &lt;-&gt; E=5","A=1+B=3*D=1*C=2 &lt;-&gt; E=5",
                "C=2 + D=1*B=3 + A=1 &lt;-&gt; E=5","C=2*B=3 + D=1 + B=3 + A=1 &lt;-&gt; E=5")
is.submodel(testformula.2, target.2)
identical.model(testformula.2[3], target.2)
identical.model(testformula.2[1], target.2)
</code></pre>

<hr>
<h2 id='makeFuzzy'>
Fuzzifying crisp-set data
</h2><span id='topic+makeFuzzy'></span>

<h3>Description</h3>

<p>The <code>makeFuzzy</code> function fuzzifies crisp-set data to a customizable degree. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>makeFuzzy(x, fuzzvalues = c(0, 0.05, 0.1), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="makeFuzzy_+3A_x">x</code></td>
<td>
<p>Data frame, matrix, or <code>configTable</code> featuring crisp-set (binary) factors with values 1 and 0 only.</p>
</td></tr>
<tr><td><code id="makeFuzzy_+3A_fuzzvalues">fuzzvalues</code></td>
<td>
<p>Numeric vector of values from the interval [0,1].</p>
</td></tr>
<tr><td><code id="makeFuzzy_+3A_...">...</code></td>
<td>
<p>Additional arguments are passed to <code><a href="#topic+configTable">configTable</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>In combination with <code>allCombs</code>, <code>full.ct</code> and <code>selectCases</code>, <code>makeFuzzy</code> is useful for simulating fuzzy-set data, which are needed for inverse search trials benchmarking the output of <code>cna</code>. <code>makeFuzzy</code> transforms a data frame or <code>configTable</code> <code>x</code> consisting of crisp-set (binary) factors into a fuzzy-set <code>configTable</code> by adding values selected at random from the argument <code>fuzzvalues</code> to the 0's and subtracting them from the 1's in <code>x</code>. <code>fuzzvalues</code> is a numeric vector of values from the interval [0,1].
</p>
<p><code>selectCases</code> can be used before and <code>selectCases1</code> after the fuzzification to select those configurations that are compatible with a given data generating causal structure (see examples below).
</p>


<h3>Value</h3>

<p>A <code>configTable</code> of type &quot;fs&quot;.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+selectCases">selectCases</a></code>, <code><a href="#topic+allCombs">allCombs</a></code>, <code><a href="#topic+full.ct">full.ct</a></code>, <code><a href="#topic+configTable">configTable</a></code>, <code><a href="#topic+cna">cna</a></code>, <code><a href="#topic+ct2df">ct2df</a></code>, <code><a href="#topic+condition">condition</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Fuzzify a crisp-set (binary) 6x3 matrix with default fuzzvalues.
X &lt;- matrix(sample(0:1, 18, replace = TRUE), 6)
makeFuzzy(X)

# ... and with customized fuzzvalues.
makeFuzzy(X, fuzzvalues = 0:5/10)
makeFuzzy(X, fuzzvalues = seq(0, 0.45, 0.01))

# First, generate crisp-set data comprising all configurations of 5 binary factors that 
# are compatible with the causal chain (A*b + a*B &lt;-&gt; C)*(C*d + c*D &lt;-&gt; E) and, 
# second, fuzzify those crisp-set data. 
dat1 &lt;- full.ct(5)
dat2 &lt;- selectCases("(A*b + a*B &lt;-&gt; C)*(C*d + c*D &lt;-&gt; E)", dat1)
(dat3 &lt;- makeFuzzy(dat2, fuzzvalues = seq(0, 0.45, 0.01)))
condition("(A*b + a*B &lt;-&gt; C)*(C*d + c*D &lt;-&gt; E)", dat3)

# Inverse search for the data generating causal structure A*b + a*B + C*D &lt;-&gt; E from
# fuzzy-set data with non-perfect consistency and coverage scores.
dat1 &lt;- full.ct(5)
set.seed(55)
dat2 &lt;- makeFuzzy(dat1, fuzzvalues = 0:4/10)
dat3 &lt;- selectCases1("A*b + a*B + C*D &lt;-&gt; E", con = .8, cov = .8, dat2)
cna(dat3, outcome = "E", con = .8, cov = .8)
</code></pre>

<hr>
<h2 id='minimalize'>
Eliminate logical redundancies from Boolean expressions
</h2><span id='topic+minimalize'></span>

<h3>Description</h3>

<p><code>minimalize</code> eliminates logical redundancies from a Boolean expression <code>cond</code> based on all configurations of the factors in <code>cond</code> that are possible according to classical Boolean logic. That is, <code>minimalize</code> performs logical (i.e. not data-driven) redundancy elimination. The output is a set of redundancy-free DNFs that are logically equivalent to <code>cond</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>minimalize(cond, x = NULL, maxstep = c(4, 4, 12))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="minimalize_+3A_cond">cond</code></td>
<td>

<p>Character vector specifying Boolean expressions; the acceptable syntax is the same as that of <code><a href="#topic+condition">condition</a></code>.
</p>
</td></tr>
<tr><td><code id="minimalize_+3A_x">x</code></td>
<td>
<p>A data frame, a <code>configTable</code>, or a list determining the possible values for each factor in <code>cond</code>; <code>x</code> has no effect for a <code>cond</code> with only binary factors but is mandatory for a <code>cond</code> with multi-value factors (see details).
</p>
</td></tr>
<tr><td><code id="minimalize_+3A_maxstep">maxstep</code></td>
<td>

<p>Maximal complexity of the returned redundancy-free DNFs (see <code><a href="#topic+cna">cna</a></code>).
</p>
</td></tr>
</table>


<h3>Details</h3>

 
<p>The regularity theory of causation underlying CNA conceives of causes as parts of redundancy-free Boolean dependency structures. Boolean dependency structures tend to contain a host of redundancies. 
Redundancies may obtain relative to an analyzed set of empirical data, which, typically, are fragmented and do not feature all logically possible configurations, or they may obtain for principled logical reasons, that is, relative to all configurations that are possible according to Boolean logic.
Whether a Boolean expression (in disjunctive normal form) contains the latter type of logical redundancies can be checked with the function <code><a href="#topic+is.inus">is.inus</a></code>. 
</p>
<p><code>minimalize</code> eliminates logical redundancies from <code>cond</code> and outputs all redundancy-free disjunctive normal forms (DNF) (within some complexity range given by <code>maxstep</code>) that are logically equivalent with <code>cond</code>.
If <code>cond</code> is redundancy-free, no reduction is possible and <code>minimalize</code> returns <code>cond</code> itself (possibly as an element of multiple logically equivalent redundancy-free DNFs). If <code>cond</code> is not redundancy-free, a <code><a href="#topic+cna">cna</a></code> with <code>con = 1</code> and <code>cov = 1</code> is performed relative to <code><a href="#topic+full.ct">full.ct</a>(x)</code> (relative to <code>full.ct(cond)</code> if <code>x</code> is <code>NULL</code>). The output is the set of all redundancy-free DNFs in the complexity range given by <code>maxstep</code> that are logically equivalent to <code>cond</code>.
</p>
<p>The purpose of the optional argument <code>x</code> is to determine the space of possible values of the factors in <code>cond</code>. If all factors in <code>cond</code> are binary, <code>x</code> is optional and without influence on the output of <code>minimalize</code>. If some factors in <code>cond</code> are multi-value, <code>minimalize</code> needs to be given the range of these values. <code>x</code> can be a data frame or <code>configTable</code> listing all possible value configurations or simply a list of the possible values for each factor in <code>cond</code> (see examples).
</p>
<p>The argument <code>maxstep</code>, which is identical to the corresponding argument in <code><a href="#topic+cna">cna</a></code>, specifies the maximal complexity of the returned DNF. <code>maxstep</code> expects a vector of three integers <code>c(i, j, k)</code>  determining that the generated DNFs have maximally <code>j</code> disjuncts with maximally <code>i</code> conjuncts each and a total of maximally <code>k</code> factor values. The default is <code>maxstep = c(4, 4, 12)</code>.
If the complexity range of the search space given by <code>maxstep</code> is too low, it may happen that nothing is returned (accompanied by a corresponding warning message). In that case, the <code>maxstep</code> values need to be increased. 
</p>


<h3>Value</h3>

<p>A list of character vectors of the same length as <code>cond</code>. Each list element contains one or several redundancy-free disjunctive normal forms (DNFs) that are logically equivalent to <code>cond</code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+condition">condition</a></code>, <code><a href="#topic+is.inus">is.inus</a></code>, <code><a href="#topic+cna">cna</a></code>, <code><a href="#topic+full.ct">full.ct</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Binary expressions
# ------------------
# DNFs as input.
minimalize(c("A", "A+B", "A + a*B", "A + a", "A*a"))
minimalize(c("F + f*G", "F*G + f*H + G*H", "F*G + f*g + H*F + H*G"))

# Any Boolean expressions (with variable syntax) are admissible inputs.
minimalize(c("!(A*B*C + a*b*c)", "A*!(B*d+E)-&gt;F", "-(A+-(E*F))&lt;-&gt;H"))

# Proper redundancy elimination may require increasing the maxstep values.
minimalize("!(A*B*C*D*E+a*b*c*d*e)")  
minimalize("!(A*B*C*D*E+a*b*c*d*e)", maxstep = c(3, 5, 15))


# Multi-value expressions
# -----------------------
# In case of expressions with multi-value factors, the relevant range of factor 
# values must be specified by means of x. x can be a list or a configTable:
values &lt;- list(C = 0:3, F = 0:2, V = 0:4)
minimalize(c("C=1 + F=2*V=0", "C=1 + C=0*V=1"), values)
minimalize("C=1 + F=2 &lt;-&gt; V=1", values, maxstep=c(3,10,20))
minimalize(c("C=1 + C=0 * C=2", "C=0 + C=1 + C=2"), configTable(d.pban))


# Eliminating logical redundancies from non-INUS asf inferred from real data
# --------------------------------------------------------------------------
fsdata &lt;- configTable(d.jobsecurity)
conds &lt;- asf(cna(fsdata, con = 0.8, cov = 0.8, inus.only = FALSE))$condition
conds &lt;- lhs(conds)
noninus.conds &lt;- conds[-which(is.inus(conds, fsdata))]
minimalize(noninus.conds)
</code></pre>

<hr>
<h2 id='minimalizeCsf'>
Eliminate structural redundancies from csf
</h2><span id='topic+minimalizeCsf'></span><span id='topic+minimalizeCsf.default'></span><span id='topic+minimalizeCsf.cna'></span>

<h3>Description</h3>

<p><code>minimalizeCsf</code> eliminates structural redundancies from complex solution formulas (csf) by recursively testing their component atomic solution formulas (asf) for redundancy and eliminating the redundant ones.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>minimalizeCsf(x, ...)

## Default S3 method:
minimalizeCsf(x, ct = NULL, verbose = FALSE, ..., data)
## S3 method for class 'cna'
minimalizeCsf(x, n = 20, verbose = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="minimalizeCsf_+3A_x">x</code></td>
<td>
<p>In the default method, <code>x</code> is a character vector of csf. The <code>cna</code> method uses the strings representing the csf contained in an output object of <code>cna</code> (see details).</p>
</td></tr>
<tr><td><code id="minimalizeCsf_+3A_ct">ct</code></td>
<td>
<p>Data frame, matrix or <code><a href="#topic+configTable">configTable</a></code> with the data; optional, if all factors in <code>x</code> are binary, but required, if some factors are multi-value. In the default case, <code>ct</code> is <code>NULL</code> and a dataset containing all possible configurations of the variables in the condition <code>x</code> is used.</p>
</td></tr>
<tr><td><code id="minimalizeCsf_+3A_verbose">verbose</code></td>
<td>
<p>Logical; if <code>TRUE</code> additional messages on the number of csf that are found to be reducible are printed.</p>
</td></tr>
<tr><td><code id="minimalizeCsf_+3A_n">n</code></td>
<td>
<p>Minimal number of csf to use.</p>
</td></tr>
<tr><td><code id="minimalizeCsf_+3A_...">...</code></td>
<td>
<p>Further arguments passed to the methods.</p>
</td></tr>
<tr><td><code id="minimalizeCsf_+3A_data">data</code></td>
<td>
<p>Argument <code>data</code> is deprecated in <code>minimalizeCsf()</code>; use <code>ct</code> instead.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>As of version 3.0 of the <span class="pkg">cna</span> package, the function <code>minimalizeCsf</code> is automatically executed, where needed, by the default calls of the <code><a href="#topic+cna">cna</a></code> and <code><a href="#topic+csf">csf</a></code> functions. In consequence, applying the stand-alone <code>minimalizeCsf</code> function to an output object of <code>cna</code> is no longer required. The stand-alone function is kept in the package for reasons of backwards compatibility and for developing purposes. Its automatic execution can be suppressed by calling <code>csf</code> with <code>minimalizeCsf = FALSE</code>, which emulates outputs of older versions of the package.
</p>
<p>The core criterion that Boolean dependency structures must satisfy in order to be causally interpretable is <em>redundancy-freeness</em>. In atomic solution formulas (asf), both sufficient and necessary conditions are completely free of redundant elements. However, when asf are conjunctively combined to complex solution formulas (csf), new redundancies may arise. A csf may contain redundant parts. To illustrate, assume that a csf is composed of three asf: asf1 * asf2 * asf3. It can happen that the conjunction asf1 * asf2 * asf3 is logically equivalent to a proper part of itself, say, to asf1 * asf2. In that case, asf3 is a so-called <em>structural redundancy</em> in asf1 * asf2 * asf3 and must not be causally interpreted. See the package vignette (<code>vignette("cna")</code>) or Baumgartner and Falk (2023) for more details. 
</p>
<p><code>minimalizeCsf</code> recursively tests the <code>asf</code> contained in a <code>csf</code> for structural redundancies and eliminates the redundant ones. It takes a character vector <code>x</code> specifying csf as input and builds all redundancy-free csf that can be inferred from <code>x</code>. There are two possibilities to use <code>minimalizeCsf</code>. Either the csf to be tested for structural redundancies is passed to <code>minimalizeCsf</code> as a character vector (this is the default method), or <code>minimalizeCsf</code> is applied directly to the output of <code><a href="#topic+cna">cna</a></code>&mdash;which however, as indicated above, is superfluous as of version 3.0 of the <span class="pkg">cna</span> package. 
</p>
<p>As a test for structural redundancies amounts to a test of logical equivalencies, it must be conducted relative to all logically possible configurations of the factors in <code>x</code>. That space of logical possibilities is generated by <code>full.ct(x)</code> if the <code>ct</code> argument takes its default value. If all factors in <code>x</code> are binary, providing a non-default <code>ct</code> value is optional and without influence on the output of <code>minimalizeCsf</code>. If some factors in <code>x</code> are multi-value, <code>minimalizeCsf</code> needs to be given the range of these values by means of the <code>ct</code> argument. <code>ct</code> can be a data frame or <code>configTable</code> listing all possible value configurations.
</p>


<h3>Value</h3>

<p><code>minimalizeCsf</code> returns an object of class &quot;minimalizeCsf&quot;, essentially a data frame.
</p>


<h3>Contributors</h3>

<p>Falk, Christoph: identification and solution of the problem of structural redundancies
</p>


<h3>References</h3>

<p>Baumgartner, Michael and Christoph Falk. 2023. &ldquo;Boolean Difference-Making: A Modern Regularity Theory of Causation&rdquo;. <em>The British Journal for the Philosophy of Science</em>, 74(1), 171-197. 
</p>


<h3>See Also</h3>

<p><code><a href="#topic+csf">csf</a></code>, <code><a href="#topic+cna">cna</a></code>, <code><a href="#topic+redundant">redundant</a></code>, <code><a href="#topic+full.ct">full.ct</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># The default method.
minimalizeCsf("(f + a*D &lt;-&gt; C)*(C + A*B &lt;-&gt; D)*(c + a*E &lt;-&gt; F)")
minimalizeCsf("(f + a*D &lt;-&gt; C)*(C + A*B &lt;-&gt; D)*(c + a*E &lt;-&gt; F)", 
              verbose = TRUE) # Same result, but with some messages.
              
# The cna method.
dat1 &lt;- selectCases("(C + A*B &lt;-&gt; D)*(c + a*E &lt;-&gt; F)")
(ana1 &lt;- cna(dat1, details = c("r"), inus.only = FALSE))
csf(ana1, minimalizeCsf = FALSE)
# The attribute "redundant" taking the value TRUE in ana1 shows that this csf contains 
# at least one redundant element. Applying minimalizeCsf() identifies and removes
# the redundant element.
minimalizeCsf(ana1)

</code></pre>

<hr>
<h2 id='randomConds'>Generate random solution formulas</h2><span id='topic+randomConds'></span><span id='topic+randomAsf'></span><span id='topic+randomCsf'></span>

<h3>Description</h3>

<p>Based on a set of factors&mdash;given as a data frame or <code>configTable</code>&mdash;, <code>randomAsf</code> generates a random atomic solution formula (asf) and <code>randomCsf</code> a random (acyclic) complex solution formula (csf).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>randomAsf(x, outcome = NULL, positive = TRUE, 
          maxVarNum = if (type == "mv") 8 else 16, compl = NULL, 
          how = c("inus", "minimal"))
randomCsf(x, outcome = NULL, positive = TRUE, 
          n.asf = NULL, compl = NULL, maxVarNum = if (type == "mv") 8 else 16)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="randomConds_+3A_x">x</code></td>
<td>
<p>Data frame or <code>configTable</code>; determines the number of factors, their names and their possible values. In <code>randomAsf</code>, <code>x</code> must have &gt;=3 columns, in <code>randomCsf</code>, <code>x</code> must have &gt;=4 columns. As a shorthand, <code>x</code> can also be an integer, in which case <code><a href="#topic+full.ct">full.ct</a>(x)</code> is executed first.</p>
</td></tr>
<tr><td><code id="randomConds_+3A_outcome">outcome</code></td>
<td>
<p>Optional character vector (of length 1 in <code>randomAsf</code>) specifying the outcome factor value(s) in the solution formula. Must be factor values, e.g. <code>"A"</code> or <code>"b"</code> in case of binary data or <code>"A=1"</code> in case of multi-value data. With multi-value data, factor <em>names</em> are also allowed; a value of that factor will then be chosen at random. <code>outcome</code> overrides <code>positive</code> and <code>n.asf</code>.
</p>
</td></tr>
<tr><td><code id="randomConds_+3A_positive">positive</code></td>
<td>
<p>Logical; if TRUE (default), the outcomes all have positive values. If <code>FALSE</code>, a value (positive or negative in case of binary data) will be picked at random. <code>positive</code> has no effect if the <code>outcome</code> argument is not <code>NULL</code> or if <code>x</code> contains multi-value data.</p>
</td></tr>
<tr><td><code id="randomConds_+3A_maxvarnum">maxVarNum</code></td>
<td>
<p>Maximal number of factors in <code>x</code> that can appear in the generated asf or csf. The default depends on the type of the data contained in <code>x</code>.
</p>
</td></tr>
<tr><td><code id="randomConds_+3A_compl">compl</code></td>
<td>
<p>Integer vector specifying the maximal complexity of the formula (i.e. number of factors in msc; number of msc in asf). Alternatively, <code>compl</code> can be a list of two integer vectors; then the first vector is used for the initial complexity of the msc and the second for that of the asf.</p>
</td></tr>
<tr><td><code id="randomConds_+3A_how">how</code></td>
<td>
<p>Character string, either <code>"inus"</code> or <code>"minimal"</code>, specifying whether the generated solution formula is redundancy-free relative to <code>full.ct(x)</code> or relative to <code>x</code> (see details below).</p>
</td></tr>
<tr><td><code id="randomConds_+3A_n.asf">n.asf</code></td>
<td>
<p>Integer scalar specifying the number of asf in the csf. Is overridden by<br /> <code>length(outcome)</code> if <code>outcome</code> is not <code>NULL</code>. Note that <code>n.asf</code> is limited to <br /> <code>ncol(x)-2</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>randomAsf</code> and <code>randomCsf</code> can be used to randomly draw data generating structures (ground truths) in inverse search trials benchmarking the output of <code><a href="#topic+cna">cna</a></code>. In the regularity theoretic context in which the CNA method is embedded, a causal structure is a redundancy-free Boolean dependency structure. Hence, <code>randomAsf</code> and <code>randomCsf</code> both produce redundancy-free Boolean dependency structures. <code>randomAsf</code> generates structures with one outcome, i.e. atomic solution formulas (asf), <code>randomCsf</code> generates structures with multiple outcomes, i.e. complex solution formulas (csf), that are free of cyclic substructures. In a nutshell, <code>randomAsf</code> proceeds by, first, randomly drawing disjunctive normal forms (DNFs) and by, second, eliminating redundancies from these DNFs. <code>randomCsf</code> essentially consists in repeated executions of <code>randomAsf</code>.
</p>
<p>The only mandatory argument of <code>randomAsf</code> and <code>randomCsf</code> is a data frame or a <code>configTable</code> <code>x</code> defining the factors (with their possible values) from which the generated asf and csf shall be drawn. 
</p>
<p>The optional argument <code>outcome</code> determines which values of which factors in <code>x</code> shall be treated as outcomes. If <code>outcome = NULL</code> (default), <code>randomAsf</code> and <code>randomCsf</code> randomly draw factor values from <code>x</code> to be treated as outcome(s). If <code>positive = TRUE</code> (default), only positive outcome values are chosen in case of crisp-set data; if <code>positive = FALSE</code>, outcome values are drawn from the set {1,0} at random. <code>positive</code> only has an effect if <code>x</code> contains crisp-set data and <code>outcome = NULL</code>.
</p>
<p>The maximal number of factors included in the generated asf and csf can be controlled via the argument <code>maxVarNum</code>. This is relevant when <code>x</code> is of high dimension, as generating solution formulas with more than 20 factors is computationally demanding and, accordingly, may take a long time (or even exhaust computer memory).
</p>
<p>The argument <code>compl</code> controls the complexity of the generated asf and csf. More specifically, the <em>initial</em> complexity of asf and csf (i.e. the number of factors included in msc and the number of msc included in asf prior to redundancy elimination) is drawn from the vector or list of vectors <code>compl</code>. As this complexity might be reduced in the subsequent process of redundancy elimination, issued asf or csf will often have lower complexity than specified in <code>compl</code>. The default value of <code>compl</code> is determined by the number of columns in <code>x</code>. 
</p>
<p><code>randomAsf</code> has the additional argument <code>how</code> with the two possible values <code>"inus"</code> and <code>"minimal"</code>. <code>how = "inus"</code> determines that the generated asf is redundancy-free relative to all logically possible configurations of the factors in <code>x</code>, i.e. relative to <code>full.ct(x)</code>, whereas in case of <code>how = "minimal"</code> redundancy-freeness is imposed only relative to all configurations actually contained in <code>x</code>, i.e. relative to <code>x</code> itself. Typically <code>"inus"</code> should be used; the value <code>"minimal"</code> is relevant mainly in repeated <code>randomAsf</code> calls from within <code>randomCsf</code>. Moreover, setting <code>how = "minimal"</code> will return an error if <code>x</code> is a <code><a href="#topic+configTable">configTable</a></code> of type <code>"fs"</code>.
</p>
<p>The argument <code>n.asf</code> controls the number of asf in the generated csf. Its value is limited to <code>ncol(x)-2</code> and overridden by <code>length(outcome)</code>, if <code>outcome</code> is not <code>NULL</code>. Analogously to <code>compl</code>, <code>n.asf</code> specifies the number of asf prior to redundancy elimination, which, in turn, may further reduce these numbers. That is, <code>n.asf</code> provides an upper bound for the number of asf in the resulting csf.
</p>


<h3>Value</h3>

<p>The randomly generated formula, a character string.</p>


<h3>See Also</h3>

<p><code><a href="#topic+is.submodel">is.submodel</a></code>, <code><a href="#topic+selectCases">selectCases</a></code>, <code><a href="#topic+full.ct">full.ct</a></code>, <code><a href="#topic+configTable">configTable</a></code>, <code><a href="#topic+cna">cna</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># randomAsf
# ---------
# Asf generated from explicitly specified binary factors.
randomAsf(full.ct("H*I*T*R*K"))
randomAsf(full.ct("Johnny*Debby*Aurora*Mars*James*Sonja"))

# Asf generated from a specified number of binary factors.
randomAsf(full.ct(7))
# In shorthand form.
randomAsf(7)

# Randomly choose positive or negative outcome values.
replicate(10, randomAsf(7, positive = FALSE))

# Asf generated from an existing data frame.
randomAsf(d.educate)

# Specify the outcome.
randomAsf(d.educate, outcome = "G")

# Specify the complexity.
# Initial complexity of 2 conjunctions and 2 disjunctions.
randomAsf(full.ct(7), compl = 2)
# Initial complexity of 3:4 conjunctions and 3:4 disjunctions.
randomAsf(full.ct(7), compl = 3:4)
# Initial complexity of 2 conjunctions and 3:4 disjunctions.
randomAsf(full.ct(7), compl = list(2,3:4))

# Redundancy-freeness relative to x instead of full.ct(x).
randomAsf(d.educate, outcome = "G", how = "minimal")

# Asf with multi-value factors.
randomAsf(allCombs(c(3,4,3,5,3,4)))
# Set the outcome value.
randomAsf(allCombs(c(3,4,3,5,3,4)), outcome = "B=4")
# Choose a random value of factor B.
randomAsf(allCombs(c(3,4,3,5,3,4)), outcome = "B")

# Asf from fuzzy-set data.
randomAsf(d.jobsecurity)
randomAsf(d.jobsecurity, outcome = "JSR")

# Generate 20 asf for outcome "e".
replicate(20, randomAsf(7, compl = list(2:3, 3:4), outcome = "e"))


# randomCsf
# ---------
# Csf generated from explicitly specified binary factors.
randomCsf(full.ct("H*I*T*R*K*Q*P"))

# Csf generated from a specified number of binary factors.
randomCsf(full.ct(7))
# In shorthand form.
randomCsf(7)

# Randomly choose positive or negative outcome values.
replicate(5, randomCsf(7, positive = FALSE))

# Specify the outcomes.
randomCsf(d.volatile, outcome = c("RB","se"))

# Specify the complexity.
randomCsf(d.volatile, outcome = c("RB","se"), compl = 2)
randomCsf(full.ct(7), compl = 3:4)
randomCsf(full.ct(7), compl = list(2,4))

# Specify the maximal number of factors.
randomCsf(d.highdim, maxVarNum = 10)
randomCsf(d.highdim, maxVarNum = 15) # takes a while to complete

# Specify the number of asf.
randomCsf(full.ct(7), n.asf = 3)

# Csf with multi-value factors.
randomCsf(allCombs(c(3,4,3,5,3,4)))
# Set the outcome values.
randomCsf(allCombs(c(3,4,3,5,3,4)), outcome = c("A=1","B=4"))

# Generate 20 csf.
replicate(20, randomCsf(full.ct(7), n.asf = 2, compl = 2:3))


# Inverse searches
# ----------------
# === Ideal Data ===
# Draw the data generating structure. (Every run yields different 
# targets and data.)
target &lt;- randomCsf(full.ct(5), n.asf = 2)
target
# Select the cases compatible with the target.
x &lt;- selectCases(target)
# Run CNA without an ordering.
mycna &lt;- cna(x)
# Extract the csf. 
csfs &lt;- csf(mycna)
# Check whether the target is completely returned.
any(unlist(lapply(csfs$condition, identical.model, target)))

# === Data fragmentation (20% missing observations) ===
# Draw the data generating structure. (Every run yields different 
# targets and data.)
target &lt;- randomCsf(full.ct(7), n.asf = 2)
target
# Generate the ideal data.
x &lt;- ct2df(selectCases(target))
# Introduce fragmentation.
x &lt;- x[-sample(1:nrow(x), nrow(x)*0.2), ] 
# Run CNA without an ordering.
mycna &lt;- cna(x)
# Extract the csf. 
csfs &lt;- csf(mycna)
# Check whether (a causal submodel of) the target is returned.
any(unlist(lapply(csfs$condition, function(x)
      frscore::causal_submodel(x, target)))) 


# === Data fragmentation and noise (20% missing observations, noise ratio of 0.05) ===
# Multi-value data.
# Draw the data generating structure. (Every run yields different 
# targets and data.)
fullData &lt;- allCombs(c(4,4,4,4,4))
target &lt;- randomCsf(fullData, n.asf=2, compl = 2:3)
target
# Generate the ideal data.
idealData &lt;- ct2df(selectCases(target, fullData))
# Introduce fragmentation.
x &lt;- idealData[-sample(1:nrow(idealData), nrow(idealData)*0.2), ] 
# Add random noise.
incompData &lt;- dplyr::setdiff(ct2df(fullData), idealData)
x &lt;- rbind(ct2df(incompData[sample(1:nrow(incompData), nrow(x)*0.05), ]), x)  
# Run CNA without an ordering.
mycna &lt;- cna(x, con = .7, cov = .65, maxstep = c(3, 3, 12))
mycna
# Extract the csf. 
csfs &lt;- csf(mycna)
# Check whether no error (no false positive) is returned.
if(nrow(csfs)==0) {
  TRUE } else {any(unlist(lapply(csfs$condition, function(x)
    frscore::causal_submodel(x, target, idealData))))}
    
</code></pre>

<hr>
<h2 id='redundant'>
Identify structurally redundant asf in a csf
</h2><span id='topic+redundant'></span>

<h3>Description</h3>

<p><code>redundant</code> takes a character vector <code>cond</code> containing complex solution formulas (csf) as input and tests for each element of <code>cond</code> whether the atomic solution formulas (asf) it consists of are structurally redundant. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>redundant(cond, x = NULL, simplify = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="redundant_+3A_cond">cond</code></td>
<td>

<p>Character vector specifying complex solution formulas (csf); only strings of type csf are allowed, meaning conjunctions of one or more asf. 
</p>
</td></tr>
<tr><td><code id="redundant_+3A_x">x</code></td>
<td>

<p>An optional argument providing a <code>configTable</code>, a data frame, or a list specifying the factors' value ranges if <code>cond</code> contains multi-value factors; if <code>x</code> is not <code>NULL</code>, <code>cond</code> is tested for redundancy-freeness relative to <code>full.ct(x)</code>, otherwise relative to <code>full.ct(cond)</code>.
</p>
</td></tr>
<tr><td><code id="redundant_+3A_simplify">simplify</code></td>
<td>

<p>Logical; if <code>TRUE</code>, the result for csfs with the same number of component asfs is presented as a matrix, otherwise all results are presented as a list of logical vectors.  
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>According to the regularity theory of causation underlying CNA, a Boolean dependency structure is causally interpretable only if it does not contain any redundant elements. Boolean dependency structures may feature various types of redundancies, one of which are so-called <em>structural redundancies</em>. A csf <code class="reqn">\Phi</code> has a structural redundancy if, and only if, reducing <code class="reqn">\Phi</code> by one or more of the asf it is composed of results in a csf <code class="reqn">\Phi'</code> that is logically equivalent to <code class="reqn">\Phi</code>. To illustrate, suppose that <code class="reqn">\Phi</code> is composed of three asf: asf1 * asf2 * asf3; and suppose that <code class="reqn">\Phi</code> is logically equivalent to <code class="reqn">\Phi'</code>: asf1 * asf2. In that case, asf3 makes no difference to the behavior of the factors in <code class="reqn">\Phi</code> and <code class="reqn">\Phi'</code>; it is structurally redundant and, accordingly, must not be causally interpreted. For more details see the package vignette (<code>vignette("cna")</code>) or Baumgartner and Falk (2023).
</p>
<p>The function <code>redundant</code> takes a character vector <code>cond</code> composed of csf as input an tests for each element of <code>cond</code> whether it is structurally redundant or not. As a test for structural redundancies amounts to a test of logical equivalencies, it must be conducted relative to all logically possible configurations of the factors in <code>cond</code>. That space of logical possibilities is generated by <code>full.ct(cond)</code> in case of <code>x =  NULL</code>, and by <code>full.ct(x)</code> otherwise. If all factors in <code>cond</code> are binary, <code>x</code> is optional and without influence on the output of <code>redundant</code>. If some factors in <code>cond</code> are multi-value, <code>redundant</code> needs to be given the range of these values. <code>x</code> can be a data frame or <code>configTable</code> listing all possible value configurations or a list of the possible values for each factor in <code>cond</code>.
</p>
<p>If <code>redundant</code> returns <code>TRUE</code> for a csf, that csf must not be causally interpreted but further processed by <code><a href="#topic+minimalizeCsf">minimalizeCsf</a></code>. As of version 3.0 of the <span class="pkg">cna</span> package, standard calls of the <code>cna</code> and <code>csf</code> functions automatically eliminate all structurally redundant asf.
</p>


<h3>Value</h3>

<p>A list of logical vectors or a logical matrix.
</p>
<p>If all <code>csf</code> in <code>cond</code> have the same number of <code>asf</code> and <code>simplify = TRUE</code>,  the result is a logical matrix with <code>length(cond)</code> rows and the number of columns corresponds to the number of <code>asf</code> in each <code>csf</code>. In all other cases, a list of logical vectors of the same length as <code>cond</code> is returned.
</p>


<h3>Contributors</h3>

<p>Falk, Christoph: identification and solution of the problem of structural redundancies
</p>


<h3>References</h3>

<p>Baumgartner, Michael and Christoph Falk. 2023. &ldquo;Boolean Difference-Making: A Modern Regularity Theory of Causation&rdquo;. <em>The British Journal for the Philosophy of Science</em>, 74(1), 171-197. 
</p>


<h3>See Also</h3>

<p><code><a href="#topic+condition">condition</a></code>, <code><a href="#topic+full.ct">full.ct</a></code>, <code><a href="#topic+is.inus">is.inus</a></code>, <code><a href="#topic+csf">csf</a></code>, <code><a href="#topic+minimalizeCsf">minimalizeCsf</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Binary factors.
cond1 &lt;- c("(f + a*D &lt;-&gt; C)*(C + A*B &lt;-&gt; D)*(c + a*E &lt;-&gt; F)", "f + a*D &lt;-&gt; C")
redundant(cond1)

edu.sol &lt;- csf(cna(d.educate), inus.only = FALSE)$condition
redundant(edu.sol, d.educate)

redundant(edu.sol, d.educate, simplify = FALSE)


# Default application of csf() with automatic elimination of structural redundancies.
ct.pban &lt;- configTable(d.pban)
cna.pban &lt;- cna(ct.pban, con = .75, cov = .75)
csf.pban &lt;- csf(cna.pban)
# check for structural redundancies in the csf:
redund.pban &lt;- redundant(csf.pban$condition, ct.pban) 
# show result for the first few:
head(redund.pban)  
# verify that no solutions with structural redundancies are returned
any(unlist(redund.pban))  # FALSE - no redundancies

# Non-default application of csf() without automatic elimination of structural redundancies.
csf.pban &lt;- csf(cna.pban, inus.only = FALSE)
redund.pban &lt;- redundant(csf.pban$condition, ct.pban)
head(redund.pban)
# various solutions with structural redundancies are returned:
table(apply(redund.pban, 1, any)) # each TRUE corresponds to a csf with struct. redundancies


# If no x is specified defining the factors' value ranges, the space of
# logically possible configurations is limited to the factor values contained in
# cond, resulting in structural redundancies that disappear as soon as x is specified.
cond2 &lt;- "(C=0*F=0 + G=1&lt;-&gt; T=2)*(T=2 + G=2 &lt;-&gt; P=1)"
redundant(cond2)
redundant(cond2, list(C=0:2, F=0:2, G=0:3, T=0:2, P=0:2))

</code></pre>

<hr>
<h2 id='rreduce'>Eliminate redundancies from a disjunctive normal form (DNF)</h2><span id='topic+rreduce'></span>

<h3>Description</h3>

<p><code>rreduce</code> eliminates redundancies from disjunctive normal forms (DNF), i.e. disjunctions of conjunctions of literals. If there are several minimal DNF, <code>rreduce</code> selects one at random.</p>


<h3>Usage</h3>

<pre><code class='language-R'>rreduce(cond, x = full.ct(cond), niter = 1, full = !missing(x), verbose = FALSE, 
        maxiter = 1000, simplify2constant = TRUE) 
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rreduce_+3A_cond">cond</code></td>
<td>

<p>A character string specifying a disjunctive normal form; can be either crisp-set or multi-value.
</p>
</td></tr>
<tr><td><code id="rreduce_+3A_x">x</code></td>
<td>
<p>A 
<code>configTable</code> or <code>data.frame</code>; can be either crisp-set or multi-value.
</p>
</td></tr>
<tr><td><code id="rreduce_+3A_niter">niter</code></td>
<td>

<p>An integer value <code>&gt;=1</code> specifying the number of iterated minimization attempts. The minimal DNFs produced in each iteration are collected and returned.
</p>
</td></tr>
<tr><td><code id="rreduce_+3A_full">full</code></td>
<td>

<p>Logical; if <code>TRUE</code> (the default), redundancies are eliminated relative to <code>full.ct(x)</code>, otherwise relative to <code>x</code>.
</p>
</td></tr>
<tr><td><code id="rreduce_+3A_simplify2constant">simplify2constant</code></td>
<td>

<p>Logical; if <code>TRUE</code> (the default), a tautologous or contradictory <code>cond</code> is reduced to a constant <code>"1"</code> or <code>"0"</code>, respectively. If <code>FALSE</code>, a minimal tautology or contradiction, i.e. <code>"A+a"</code> or <code>"A*a"</code>, will result.
</p>
</td></tr>
<tr><td><code id="rreduce_+3A_verbose">verbose</code></td>
<td>

<p>Logical; if TRUE, the reduction process will be traced in the console. 
</p>
</td></tr>
<tr><td><code id="rreduce_+3A_maxiter">maxiter</code></td>
<td>

<p>Maximal number of iterations. This is a parameter of internal nature, usually not set by the user.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>rreduce</code> successively eliminates conjuncts and disjuncts from a DNF <code>cond</code> as long as the result of <code>condition(cond, x)</code> remains the same. The only required argument is <code>cond</code>. If <code>x</code> is not provided, redundancies are eliminated relative to <code>full.ct(cond)</code>. If <code>x</code> is provided and <code>full = TRUE</code>, redundancies are eliminated relative to <code>full.ct(x)</code>. If <code>x</code> is provided and <code>full = FALSE</code>, redundancies are eliminated relative to <code>x</code>.
</p>
<p>If <code>cond</code> has more than one redundancy-free form, <code>rreduce</code> only returns a randomly chosen one in the default setting of <code>niter = 1</code>. By increasing <code>niter</code> to a value <code>&gt;1</code>, <code>cond</code> is (randomly) minimized <code>niter</code> times. All resulting redundancy-free forms are collected and returned. This provides some insight about the amount of redundancy-free forms that <code>cond</code> has.
</p>


<h3>Value</h3>

<p>Redundancy-free disjunctive normal form (DNF).
</p>


<h3>See Also</h3>

<p><code><a href="#topic+full.ct">full.ct</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Logical redundancies.
cond1 &lt;- "A*b + a*B + A*C + B*C"
rreduce(cond1)
rreduce(cond1, niter = 10)
cond2 &lt;- "A*b + a*B + A*B + a*b"
rreduce(cond2, simplify2constant = FALSE)

# Any Boolean expressions.
cond &lt;- "!(A*B*C)*!(a*b*c)" # or "A + B*!(D + e) &lt;-&gt; C" 
x &lt;- selectCases(cond) 
cond &lt;- getCond(x) # Returns a DNF equivalent to cond, but with many redundancies.
rreduce(cond)      # Repeated execution results in different outputs.
rreduce(cond, verbose = TRUE)      
rreduce(cond, niter = 20) # 20 iterations yield 5 minimal forms.
</code></pre>

<hr>
<h2 id='selectCases'>
Select the cases/configurations compatible with a data generating causal structure
</h2><span id='topic+selectCases'></span><span id='topic+selectCases1'></span>

<h3>Description</h3>

<p><code>selectCases</code> selects the cases/configurations that are compatible with a Boolean function, in particular (but not exclusively), a data generating causal structure, from a data frame or <code>configTable</code>.
</p>
<p><code>selectCases1</code> allows for setting consistency (<code>con</code>) and coverage (<code>cov</code>) thresholds. It then selects cases/configurations that are compatible with the data generating structure to degrees <code>con</code> and <code>cov</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>selectCases(cond, x = full.ct(cond), type = "auto", cutoff = 0.5, 
            rm.dup.factors = FALSE, rm.const.factors = FALSE)
selectCases1(cond, x = full.ct(cond), type = "auto", con = 1, cov = 1, 
             rm.dup.factors = FALSE, rm.const.factors = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="selectCases_+3A_cond">cond</code></td>
<td>
<p>Character string specifying the Boolean function for which compatible cases are to be selected.</p>
</td></tr>
<tr><td><code id="selectCases_+3A_x">x</code></td>
<td>
<p>Data frame or <code>configTable</code>; if not specified, <code><a href="#topic+full.ct">full.ct</a>(cond)</code> is used.</p>
</td></tr>
<tr><td><code id="selectCases_+3A_type">type</code></td>
<td>
<p>Character vector specifying the type of <code>x</code>: <code>"auto"</code> (automatic detection; default), <code>"cs"</code> (crisp-set), <code>"mv"</code> (multi-value),  or <code>"fs"</code> (fuzzy-set).</p>
</td></tr>
<tr><td><code id="selectCases_+3A_cutoff">cutoff</code></td>
<td>
<p>Cutoff value in case of <code>"fs"</code> data.</p>
</td></tr>
<tr><td><code id="selectCases_+3A_rm.dup.factors">rm.dup.factors</code></td>
<td>
<p>Logical; if <code>TRUE</code>, all but the first of a set of factors with identical value distributions are eliminated.</p>
</td></tr>
<tr><td><code id="selectCases_+3A_rm.const.factors">rm.const.factors</code></td>
<td>
<p>Logical; if <code>TRUE</code>, constant factors are eliminated.</p>
</td></tr>
<tr><td><code id="selectCases_+3A_con">con</code>, <code id="selectCases_+3A_cov">cov</code></td>
<td>
<p>Numeric scalars between 0 and 1 to set the minimum consistency and coverage thresholds.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>In combination with <code>allCombs</code>, <code>full.ct</code>, <code>randomConds</code> and <code>makeFuzzy</code>, <code>selectCases</code> is useful for simulating data, which are needed for inverse search trials benchmarking the output of the <code>cna</code> function. 
</p>
<p><code>selectCases</code> draws those cases/configurations from a data frame or <code>configTable</code> <code>x</code> that are compatible with a data generating causal structure (or any other Boolean or set-theoretic function), which is given to <code>selectCases</code> as a character string <code>cond</code>. If the argument <code>x</code> is not specified, configurations are drawn from <code>full.ct(cond)</code>. <code>cond</code> can be a condition of any of the three types of conditions, <em>boolean</em>, <em>atomic</em> or <em>complex</em> (see <code><a href="#topic+condition">condition</a></code>). To illustrate, if the data generating structure is &quot;A + B &lt;-&gt; C&quot;, then a case featuring A=1, B=0, and C=1 is selected by <code>selectCases</code>, whereas a case featuring A=1, B=0, and C=0 is not (because according to the data generating structure, A=1 must be associated with C=1, which is violated in the latter case). The type of the data frame is automatically detected by default, but can be manually specified by giving the argument <code>type</code> one of its non-default values: <code>"cs"</code> (crisp-set), <code>"mv"</code> (multi-value), and <code>"fs"</code> (fuzzy-set).
</p>
<p><code>selectCases1</code> allows for providing consistency (<code>con</code>) and coverage (<code>cov</code>) thresholds, such that some cases that are incompatible with <code>cond</code> are also drawn, as long as <code>con</code> and <code>cov</code> remain satisfied. The solution is identified by an algorithm aiming to find a subset of maximal size meeting the <code>con</code> and <code>cov</code> requirements. In contrast to  <code>selectCases</code>, <code>selectCases1</code> only accepts a condition of type <em>atomic</em> as its <code>cond</code> argument, i.e. an atomic solution formula. Data drawn by <code>selectCases1</code> can only be modeled with consistency = <code>con</code> and coverage = <code>cov</code>. 
</p>


<h3>Value</h3>

<p>A <code>configTable</code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+allCombs">allCombs</a></code>, <code><a href="#topic+full.ct">full.ct</a></code>, <code><a href="#topic+randomConds">randomConds</a></code>, <code><a href="#topic+makeFuzzy">makeFuzzy</a></code>, <code><a href="#topic+configTable">configTable</a></code>, <code><a href="#topic+condition">condition</a></code>, <code><a href="#topic+cna">cna</a></code>, <code><a href="#topic+d.jobsecurity">d.jobsecurity</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'># Generate all configurations of 5 dichotomous factors that are compatible with the causal
# chain (A*b + a*B &lt;-&gt; C) * (C*d + c*D &lt;-&gt; E).
groundTruth.1 &lt;- "(A*b + a*B &lt;-&gt; C) * (C*d + c*D &lt;-&gt; E)"
(dat1 &lt;- selectCases(groundTruth.1))
condition(groundTruth.1, dat1)

# Randomly draw a multi-value ground truth and generate all configurations compatible with it.
dat1 &lt;- allCombs(c(3, 3, 4, 4, 3))
groundTruth.2 &lt;- randomCsf(dat1, n.asf=2)
(dat2 &lt;- selectCases(groundTruth.2, dat1))
condition(groundTruth.2, dat2)

# Generate all configurations of 5 fuzzy-set factors compatible with the causal structure
# A*b + C*D &lt;-&gt; E, such that con = .8 and cov = .8.
dat1 &lt;- allCombs(c(2, 2, 2, 2, 2)) - 1
dat2 &lt;- makeFuzzy(dat1, fuzzvalues = seq(0, 0.45, 0.01))
(dat3 &lt;- selectCases1("A*b + C*D &lt;-&gt; E", con = .8, cov = .8, dat2))
condition("A*b + C*D &lt;-&gt; E", dat3)

# Inverse search for the data generating causal structure A*b + a*B + C*D &lt;-&gt; E from
# fuzzy-set data with non-perfect consistency and coverage scores.
dat1 &lt;- allCombs(c(2, 2, 2, 2, 2)) - 1
set.seed(7)
dat2 &lt;- makeFuzzy(dat1, fuzzvalues = 0:4/10)
dat3 &lt;- selectCases1("A*b + a*B + C*D &lt;-&gt; E", con = .8, cov = .8, dat2)
cna(dat3, outcome = "E", con = .8, cov = .8)

# Draw cases satisfying specific conditions from real-life fuzzy-set data.
ct.js &lt;- configTable(d.jobsecurity)
selectCases("S -&gt; C", ct.js)  # Cases with higher membership scores in C than in S.
selectCases("S -&gt; C", d.jobsecurity)  # Same.
selectCases("S &lt;-&gt; C", ct.js) # Cases with identical membership scores in C and in S.
selectCases1("S -&gt; C", con = .8, cov = .8, ct.js)  # selectCases1() makes no distinction 
              #  between "-&gt;" and "&lt;-&gt;".
condition("S -&gt; C", selectCases1("S -&gt; C", con = .8, cov = .8, ct.js))

# selectCases() not only draws cases compatible with Boolean causal models. Any Boolean 
# function of factor values appearing in the data can be given as cond.
selectCases("C=1*B=3", allCombs(2:4))
selectCases("A=1 * !(C=2 + B=3)", allCombs(2:4), type = "mv")
selectCases("A=1 + (C=3 &lt;-&gt; B=1)*D=3", allCombs(c(3,3,3,3)), type = "mv")
</code></pre>

<hr>
<h2 id='shortcuts'>Shortcut functions with fixed <code>type</code> argument.</h2><span id='topic+shortcuts'></span><span id='topic+csct'></span><span id='topic+mvct'></span><span id='topic+fsct'></span><span id='topic+cscna'></span><span id='topic+mvcna'></span><span id='topic+fscna'></span><span id='topic+cscond'></span><span id='topic+mvcond'></span><span id='topic+fscond'></span>

<h3>Description</h3>

<p>In previous versions of the <span class="pkg">cna</span> package (&lt;3.2), these functions were designed to abbreviate the specification of the data type using the type argument in calls to
<code><a href="#topic+configTable">configTable</a></code>, <code><a href="#topic+cna">cna</a></code> and <code><a href="#topic+condition">condition</a></code>, respectively.
</p>
<p>They have become obsolete since the introduction of the default setting <code>type = "auto"</code> in package version 3.2.0.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>csct(...)
mvct(...)
fsct(...)

cscna(...)
mvcna(...)
fscna(...)

cscond(...)
mvcond(...)
fscond(...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="shortcuts_+3A_...">...</code></td>
<td>

<p>In <code>cscna</code>, <code>mvcna</code>, <code>fscna</code>: any formal argument of <code>cna</code> except <code>type</code>. In <code>csct</code>, <code>mvct</code>, <code>fsct</code>: any formal argument of <code>configTable</code> except <code>type</code>. In <code>cscond</code>, <code>mvcond</code>, <code>fscond</code>: any formal argument of <code>condition</code> except <code>type</code>.   
</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>csct(x, ...)</code>, <code>mvct(x, ...)</code>, and <code>fsct(x, ...)</code> are shorthands for <code>configTable(x, type = "cs", ...)</code>, <br /><code>configTable(x, type = "mv", ...)</code> and <code>configTable(x, type = "fs", ...)</code>, respectively.
</p>
<p><code>cscna(x, ...)</code>, <code>mvcna(x, ...)</code>, and <code>fscna(x, ...)</code> are shorthands for <code>cna(x, type = "cs", ...)</code>, <code>cna(x, type = "mv", ...)</code> and <code>cna(x, type = "fs", ...)</code>, respectively.
</p>
<p><code>cscond(x, ct, ...)</code>, <code>mvcond(x, ct, ...)</code>, and <code>fscond(x, ct, ...)</code> are shorthands for <code>condition(x, ct, type = "cs", ...)</code>, <br /><code>condition(x, ct, type = "mv", ...)</code> and <code>condition(x, ct, type = "fs", ...)</code>, respectively.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+configTable">configTable</a></code>, <code><a href="#topic+cna">cna</a></code>, <code><a href="#topic+condition">condition</a></code></p>

<hr>
<h2 id='some'>
Randomly select configurations from a data frame or <code>configTable</code>
</h2><span id='topic+some'></span><span id='topic+some.data.frame'></span><span id='topic+some.configTable'></span>

<h3>Description</h3>

<p>The function <code>some</code> randomly selects configurations from a data frame or <code>configTable</code> with or without replacement.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>some(x, ...)

## S3 method for class 'data.frame'
some(x, n = 10, replace = TRUE, ...)
## S3 method for class 'configTable'
some(x, n = 10, replace = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="some_+3A_x">x</code></td>
<td>
<p>Data frame or <code>configTable</code>.</p>
</td></tr>
<tr><td><code id="some_+3A_n">n</code></td>
<td>
<p>Sample size.</p>
</td></tr>
<tr><td><code id="some_+3A_replace">replace</code></td>
<td>
<p>Logical; if <code>TRUE</code>, configurations are sampled with replacement.</p>
</td></tr>
<tr><td><code id="some_+3A_...">...</code></td>
<td>
<p>Not used.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function <code>some</code> randomly samples configurations from <code>x</code>, which is a data frame or <code>configTable</code>. Such samples can, for instance, be used to simulate data fragmentation (limited diversity), i.e. the failure to observe/measure all configurations that are compatible with a data generating causal structure. They can also be used to simulate large-N data featuring multiple cases instantiating each configuration.
</p>


<h3>Value</h3>

<p>A data frame or configTable.
</p>


<h3>Note</h3>

<p>The generic function <code>some</code> is read from the package <a href="https://CRAN.R-project.org/package=car"><span class="pkg">car</span></a>.
The method for <code>data.frame</code>s in the <span class="pkg">cna</span> package has an additional parameter <code>replace</code>, which is <code>TRUE</code> by default. It will thus not apply the same sampling scheme as the method in <span class="pkg">car</span> by default.
</p>


<h3>References</h3>

<p>Krook, Mona Lena. 2010.
&ldquo;Women's Representation in Parliament: A Qualitative Comparative Analysis.&rdquo;
<em>Political Studies</em> 58(5):886-908.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+configTable">configTable</a></code>, <code><a href="#topic+selectCases">selectCases</a></code>, <code><a href="#topic+allCombs">allCombs</a></code>, <code><a href="#topic+makeFuzzy">makeFuzzy</a></code>, <code><a href="#topic+cna">cna</a></code>, <code><a href="#topic+d.women">d.women</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Randomly sample configurations from the dataset analyzed by Krook (2010).
ct.women &lt;- configTable(d.women)
some(ct.women, 20)
some(ct.women, 5, replace = FALSE)
some(ct.women, 5, replace = TRUE)

# Simulate limited diversity in data generated by the causal structure 
# A=2*B=1 + C=3*D=4 &lt;-&gt; E=3.
dat1 &lt;- allCombs(c(3, 3, 4, 4, 3))
dat2 &lt;- selectCases("A=2*B=1 + C=3*D=4 &lt;-&gt; E=3", dat1)
(dat3 &lt;- some(dat2, 150, replace = TRUE))
cna(dat3)

# Simulate large-N fuzzy-set data generated by the common-cause structure
# (A*b*C + B*c &lt;-&gt; D) * (A*B + a*C &lt;-&gt; E).
dat1 &lt;- selectCases("(A*b*C + B*c &lt;-&gt; D) * (A*B + a*C &lt;-&gt; E)")
dat2 &lt;- some(dat1, 250, replace = TRUE)
dat3 &lt;- makeFuzzy(ct2df(dat2), fuzzvalues = seq(0, 0.45, 0.01))
cna(dat3, ordering = "D, E", strict = TRUE, con = .8, cov = .8)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
