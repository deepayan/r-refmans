<!DOCTYPE html><html><head><title>Help for package pergola</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {pergola}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#add_offset'><p>Add offset</p></a></li>
<li><a href='#allTrees'><p>Creates all trees for distance</p></a></li>
<li><a href='#bases2genotypes'><p>Transform bases into genotypes</p></a></li>
<li><a href='#calcRec'><p>Recombination frequencies computation</p></a></li>
<li><a href='#calcSarf'><p>Calculates the SARF value of given input.</p></a></li>
<li><a href='#calcSarfDist'><p>Calculates SARF</p></a></li>
<li><a href='#findChr'><p>Find most equal chromosome in other map</p></a></li>
<li><a href='#getLeaves'><p>Leaves from subtree</p></a></li>
<li><a href='#getNode'><p>Get Node for leave</p></a></li>
<li><a href='#getSubtree'><p>Subtrees from tree</p></a></li>
<li><a href='#makealtord'><p>Creates vectors with highly distant neighbors</p></a></li>
<li><a href='#maketangle'><p>Create a gray scale tanglegram</p></a></li>
<li><a href='#map2dend'><p>Transforming a map into a dendrogram</p></a></li>
<li><a href='#pairwRF'><p>Pairwise recombination frequency calculation</p></a></li>
<li><a href='#pergola'><p>Toolbox for polyploid genetic data</p></a></li>
<li><a href='#plotChr'><p>Plotting one or two linkage maps</p></a></li>
<li><a href='#plotRf'><p>Plot recombination frequencies</p></a></li>
<li><a href='#pullMap'><p>Creates map object</p></a></li>
<li><a href='#sarfExt'><p>Extends SARF criterion to neighborhood</p></a></li>
<li><a href='#shuffleInput'><p>Randomize marker order and alleles within samples</p>
</p>
<p>In simulated datasets, the order or markers and alleles within samples is often given.</p>
To remove any prior knowledge, that would not be available, the data should be randomized.
Thus, the performance of our tool can be validated unbiased.</a></li>
<li><a href='#simHexa'><p>Hexaploid F2 population</p></a></li>
<li><a href='#simTetra'><p>Tetraploid F2 population</p></a></li>
<li><a href='#sortLeafs'><p>Chromosome wise leaf ordering</p></a></li>
<li><a href='#splitChr'><p>Split markers into chromosomes</p></a></li>
<li><a href='#swapChrs'><p>Swap chromosomes</p></a></li>
<li><a href='#switchChr'><p>Switch Chromosomes</p></a></li>
<li><a href='#switchChrs'><p>Switch Chromosomes</p></a></li>
<li><a href='#switchEntries'><p>Switches entries in hclust object</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Toolbox for Polyploid Genetic Data</td>
</tr>
<tr>
<td>Version:</td>
<td>1.0</td>
</tr>
<tr>
<td>Date:</td>
<td>2016-03-31</td>
</tr>
<tr>
<td>Description:</td>
<td>Provides tools for linkage mapping in polyploids.
    It implements the method PERGOLA, which is a fast, deterministic method to
    calculate the order of markers in a linkage group.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>Imports:</td>
<td>seriation, utils, stats</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>Suggests:</td>
<td>knitr, gclus, dendextend, dendextendRcpp, Matrix, rmarkdown,
grDevices</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>5.0.1</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="http://github.com/grafab/pergola">http://github.com/grafab/pergola</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="http://github.com/grafab/pergola/issues">http://github.com/grafab/pergola/issues</a></td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2016-04-01 19:31:02 UTC; fabian</td>
</tr>
<tr>
<td>Author:</td>
<td>Fabian Grandke [aut, cre],
  Dirk Metzler [ths]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Fabian Grandke &lt;grafabian@gmail.com&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2016-04-03 16:29:32</td>
</tr>
</table>
<hr>
<h2 id='add_offset'>Add offset</h2><span id='topic+add_offset'></span>

<h3>Description</h3>

<p>Add offset to zero distance markers to allow computation of correlation between maps.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>add_offset(map, offset = 0.1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="add_offset_+3A_map">map</code></td>
<td>
<p>One map. Required.</p>
</td></tr>
<tr><td><code id="add_offset_+3A_offset">offset</code></td>
<td>
<p>Numeric value for offset.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Map object.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(simTetra)
simTetrageno &lt;- bases2genotypes(simTetra, 4)
rfMat &lt;- calcRec(simTetrageno, 4)
split &lt;- splitChr(rfMat, nchr = 7)
split &lt;- sortLeafs(rfMat, split)
map &lt;- pullMap(rfMat, split = split)   
map &lt;- add_offset(map)
</code></pre>

<hr>
<h2 id='allTrees'>Creates all trees for distance</h2><span id='topic+allTrees'></span>

<h3>Description</h3>

<p>Takes order and tree and creates all possible trees
</p>


<h3>Usage</h3>

<pre><code class='language-R'>allTrees(hc, dis, start = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="allTrees_+3A_hc">hc</code></td>
<td>
<p>Hierarchical clustering object.</p>
</td></tr>
<tr><td><code id="allTrees_+3A_dist">dist</code></td>
<td>
<p>Distance object.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Vector with markers with unclear relation (equal distances).
</p>

<hr>
<h2 id='bases2genotypes'>Transform bases into genotypes</h2><span id='topic+bases2genotypes'></span>

<h3>Description</h3>

<p>Preprocess the input data in case bases are provided instead of genotypes
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bases2genotypes(input, ploidy)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bases2genotypes_+3A_input">input</code></td>
<td>
<p>Matrix of genotype bases. Rows represent the individual markers. 
Columns represent samples, dependenden on the ploidy.</p>
</td></tr>
<tr><td><code id="bases2genotypes_+3A_ploidy">ploidy</code></td>
<td>
<p>Ploidy level of the organism. 
Influences how many columns are collapsed into one.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Matrix of genotypes. 
The number of columns is 1/<code>ploidy</code> of the <code>input</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(simTetra)
bases2genotypes(simTetra, 4)
</code></pre>

<hr>
<h2 id='calcRec'>Recombination frequencies computation</h2><span id='topic+calcRec'></span>

<h3>Description</h3>

<p>Calculate recombination frequencies for a whole matrix
</p>


<h3>Usage</h3>

<pre><code class='language-R'>calcRec(input, ploidy, sparse = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="calcRec_+3A_input">input</code></td>
<td>
<p>Matrix of genotypes. Rows represent markers. 
Columns represent samples.</p>
</td></tr>
<tr><td><code id="calcRec_+3A_ploidy">ploidy</code></td>
<td>
<p>Ploidy level of the organism.</p>
</td></tr>
<tr><td><code id="calcRec_+3A_sparse">sparse</code></td>
<td>
<p>Logical, if the matrix is a sparse matrix or not.</p>
</td></tr>
<tr><td><code id="calcRec_+3A_...">...</code></td>
<td>
<p>arguments are forwarded to <code>pairwRF</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Matrix of pairwise recombination frequencies.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(simTetra)
simTetraGen &lt;- bases2genotypes(simTetra, ploidy = 4)
calcRec(simTetraGen, 4)
</code></pre>

<hr>
<h2 id='calcSarf'>Calculates the SARF value of given input.</h2><span id='topic+calcSarf'></span>

<h3>Description</h3>

<p>The sum of adjecent recombination frequency (SARF) is a measure of how well the marker order is.
This function calculates it for a given matrix of pairwise recombination frequencies and marker order.
The SARF criterion can be extended to a neighborhood &gt; 1.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>calcSarf(rf, ord = 1:(ncol(rf)), n = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="calcSarf_+3A_rf">rf</code></td>
<td>
<p>Matrix of pairwise recombination frequencies.</p>
</td></tr>
<tr><td><code id="calcSarf_+3A_ord">ord</code></td>
<td>
<p>Vector with marker order.</p>
</td></tr>
<tr><td><code id="calcSarf_+3A_n">n</code></td>
<td>
<p>Number of neighbors, which are included in the calculation.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Single numeric value, which is the result of the SARF calculation.
</p>


<h3>References</h3>

<p>Liu, B.H. 1998, <em>Statistical genomics: linkage, mapping, and QTL analysis.</em>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(simTetra)
simTetrageno &lt;- bases2genotypes(simTetra, 4)
rfMat &lt;- calcRec(simTetrageno, 4)
split &lt;- splitChr(rfMat, nchr = 7)
split &lt;- sortLeafs(rfMat, split)
calcSarf(rfMat, split$order, n = 1)
calcSarf(rfMat, split$order, n = 2)
calcSarf(rfMat, split$order, n = 3)
</code></pre>

<hr>
<h2 id='calcSarfDist'>Calculates SARF</h2><span id='topic+calcSarfDist'></span>

<h3>Description</h3>

<p>Internal method to calculate the SARF score for a given order and distance object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>calcSarfDist(ord, dis, n = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="calcSarfDist_+3A_ord">ord</code></td>
<td>
<p>Order of markers.</p>
</td></tr>
<tr><td><code id="calcSarfDist_+3A_dis">dis</code></td>
<td>
<p>Distance object.</p>
</td></tr>
<tr><td><code id="calcSarfDist_+3A_n">n</code></td>
<td>
<p>Number of neighbors to include.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>SARF score.
</p>

<hr>
<h2 id='findChr'>Find most equal chromosome in other map</h2><span id='topic+findChr'></span>

<h3>Description</h3>

<p>Find most equal chromosome in other map
</p>


<h3>Usage</h3>

<pre><code class='language-R'>findChr(map, comp)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="findChr_+3A_map">map</code></td>
<td>
<p>Map to switch.</p>
</td></tr>
<tr><td><code id="findChr_+3A_comp">comp</code></td>
<td>
<p>Other map for comparison.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>map
</p>

<hr>
<h2 id='getLeaves'>Leaves from subtree</h2><span id='topic+getLeaves'></span>

<h3>Description</h3>

<p>Provides all leaves for a given tree and node.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getLeaves(merge, i)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getLeaves_+3A_merge">merge</code></td>
<td>
<p>Tree from hierarchical clustering.</p>
</td></tr>
<tr><td><code id="getLeaves_+3A_i">i</code></td>
<td>
<p>Node number.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Leave indices.
</p>

<hr>
<h2 id='getNode'>Get Node for leave</h2><span id='topic+getNode'></span>

<h3>Description</h3>

<p>Finds the highest node of a leaf in hclust object below a threshold
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getNode(merge, leave, max)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getNode_+3A_hc">hc</code></td>
<td>
<p>Hierarchical clustering object.</p>
</td></tr>
<tr><td><code id="getNode_+3A_pair">pair</code></td>
<td>
<p>Vector of length 2.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Updated hclust object.
</p>

<hr>
<h2 id='getSubtree'>Subtrees from tree</h2><span id='topic+getSubtree'></span>

<h3>Description</h3>

<p>Provides the subtree from a given tree and node.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getSubtree(merge, i = NULL, leaves = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getSubtree_+3A_merge">merge</code></td>
<td>
<p>Tree from hierarchical clustering.</p>
</td></tr>
<tr><td><code id="getSubtree_+3A_i">i</code></td>
<td>
<p>Node number.</p>
</td></tr>
<tr><td><code id="getSubtree_+3A_leaves">leaves</code></td>
<td>
<p>Logical. If TRUE the leaves will be provided.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Vector containing indices.
</p>

<hr>
<h2 id='makealtord'>Creates vectors with highly distant neighbors</h2><span id='topic+makealtord'></span>

<h3>Description</h3>

<p>Creates a vector of numbers 1 to n, where the neighbors are as distant as possible.
For the grey scale plot, that guarantees, that the shades of grey are easy to distinguish.
For instance, 1, 4, 2, 5, 3; all numbers have a distance of at least 2 and where possible 3.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>makealtord(n = 3)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="makealtord_+3A_n">n</code></td>
<td>
<p>Length of vector.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Vector of length n.
</p>

<hr>
<h2 id='maketangle'>Create a gray scale tanglegram</h2><span id='topic+maketangle'></span>

<h3>Description</h3>

<p>Create tanglegram. Removes markers, that are not in both trees.
Calculates alternating light and dark shades of grey.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>maketangle(dend1, dend2, cutheight, k = NULL, ncol = k, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="maketangle_+3A_dend1">dend1</code></td>
<td>
<p>First dendrogram. Required.</p>
</td></tr>
<tr><td><code id="maketangle_+3A_dend2">dend2</code></td>
<td>
<p>Second dendrogram. Required.</p>
</td></tr>
<tr><td><code id="maketangle_+3A_cutheight">cutheight</code></td>
<td>
<p>The height, at which dend1 is cut. Influences number of colors.</p>
</td></tr>
<tr><td><code id="maketangle_+3A_k">k</code></td>
<td>
<p>Number of desired linkage groups.</p>
</td></tr>
<tr><td><code id="maketangle_+3A_ncol">ncol</code></td>
<td>
<p>Number of desired colors.</p>
</td></tr>
<tr><td><code id="maketangle_+3A_...">...</code></td>
<td>
<p>Other parameters are forwarded to the tanglegram command.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>None. Plotting only.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(simTetra)
simTetraGen &lt;- bases2genotypes(simTetra, 4)
rfMat &lt;- calcRec(simTetraGen, 4)
split &lt;- splitChr(rfMat, nchr = 7)
split &lt;- sortLeafs(rfMat, split)
map &lt;- pullMap(rfMat, split = split)  
dend &lt;- map2dend(map)  
maketangle(dend, dend, cutheight = 500, k = 7, ncol = 7)
</code></pre>

<hr>
<h2 id='map2dend'>Transforming a map into a dendrogram</h2><span id='topic+map2dend'></span>

<h3>Description</h3>

<p>Create dendrogram object. The map specific distance are ignored and only the grouping and ordering is maintained.
Allows for comparison of whole map with package 'dendextend'
</p>


<h3>Usage</h3>

<pre><code class='language-R'>map2dend(map, mergeoff = 0L)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="map2dend_+3A_map">map</code></td>
<td>
<p>One map. Required.</p>
</td></tr>
<tr><td><code id="map2dend_+3A_mergeoff">mergeoff</code></td>
<td>
<p>Numeric, offset between chromosomes, to avoid equal heights in dendrogram.
Equal heights lead to problems in cor_bakers_gamma().</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Dendogram object.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(simTetra)
simTetrageno &lt;- bases2genotypes(simTetra, 4)
rfMat &lt;- calcRec(simTetrageno, 4)
split &lt;- splitChr(rfMat, nchr = 7)
split &lt;- sortLeafs(rfMat, split)
map &lt;- pullMap(rfMat, split = split)   
dend &lt;- map2dend(map)  
plot(dend)
</code></pre>

<hr>
<h2 id='pairwRF'>Pairwise recombination frequency calculation</h2><span id='topic+pairwRF'></span>

<h3>Description</h3>

<p>Calculates the pairwise recombination frequencies for two given markers.
Heuristic approach, assuming minimal recombination between markers.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pairwRF(input, ploidy = 4, na.penalty = 0)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pairwRF_+3A_input">input</code></td>
<td>
<p>Matrix with two rows of genotypes. Each row is one marker.</p>
</td></tr>
<tr><td><code id="pairwRF_+3A_ploidy">ploidy</code></td>
<td>
<p>Ploidy level of the organism.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Numeric value of recomination between the two markers.
</p>

<hr>
<h2 id='pergola'>Toolbox for polyploid genetic data</h2><span id='topic+pergola'></span><span id='topic+pergola-package'></span>

<h3>Description</h3>

<p>This package provides multiple tools to work with polyploid data.
</p>


<h3>Details</h3>

<p>Load the dataset <code>simTetra</code> and analyse it according to the vignette.
</p>

<hr>
<h2 id='plotChr'>Plotting one or two linkage maps</h2><span id='topic+plotChr'></span>

<h3>Description</h3>

<p>Visualization of one or two linkage maps.
Used as comparison between two different maps (e.g. different parameters or linkage mapping tools).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plotChr(map1, map2 = NULL, cex = 1, labels = c("Map 1", "Map 2"), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plotChr_+3A_map1">map1</code></td>
<td>
<p>Numeric vector with marker positions.</p>
</td></tr>
<tr><td><code id="plotChr_+3A_map2">map2</code></td>
<td>
<p>Optional second map for comparison.</p>
</td></tr>
<tr><td><code id="plotChr_+3A_cex">cex</code></td>
<td>
<p>Font size in the figure.</p>
</td></tr>
<tr><td><code id="plotChr_+3A_labels">labels</code></td>
<td>
<p>Labels for the two blocks</p>
</td></tr>
<tr><td><code id="plotChr_+3A_...">...</code></td>
<td>
<p>arguments are forwarded to <code>plot</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>None. Plotting only.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(simTetra)
simTetraGen &lt;- bases2genotypes(simTetra, 4)
rfMat &lt;- calcRec(simTetraGen, 4)
split &lt;- splitChr(rfMat, nchr = 7)
split &lt;- sortLeafs(rfMat, split)
map &lt;- pullMap(rfMat, split = split) 
plotChr(map[[1]])  
</code></pre>

<hr>
<h2 id='plotRf'>Plot recombination frequencies</h2><span id='topic+plotRf'></span>

<h3>Description</h3>

<p>Graphical representation of recombination frequencies to support supervised estimation
of the numbers of clusters
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plotRf(rf, plottype = "dendrogram", method = "single", cex.axis = 1, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plotRf_+3A_rf">rf</code></td>
<td>
<p>Matrix of pairwise recombination frequencies.</p>
</td></tr>
<tr><td><code id="plotRf_+3A_plottype">plottype</code></td>
<td>
<p>Default is &quot;dendrogram&quot;. Any other value will plot the recombination frequencies.</p>
</td></tr>
<tr><td><code id="plotRf_+3A_method">method</code></td>
<td>
<p>Default is &quot;single&quot;, which is used for the hierarchical clustering.</p>
</td></tr>
<tr><td><code id="plotRf_+3A_cex.axis">cex.axis</code></td>
<td>
<p>Size of axis labels in image plot.</p>
</td></tr>
<tr><td><code id="plotRf_+3A_...">...</code></td>
<td>
<p>arguments are forwarded to <code>image</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>None.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(simTetra)
simTetraGen &lt;- bases2genotypes(simTetra, 4)
rfMat &lt;- calcRec(simTetraGen, 4)
plotRf(rfMat)
</code></pre>

<hr>
<h2 id='pullMap'>Creates map object</h2><span id='topic+pullMap'></span>

<h3>Description</h3>

<p>Creates map object from matrix of pairwise recombination frequencies.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pullMap(rf, split, fun = "haldane", corr = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pullMap_+3A_rf">rf</code></td>
<td>
<p>Matrix of pairwise recombination frequencies.</p>
</td></tr>
<tr><td><code id="pullMap_+3A_split">split</code></td>
<td>
<p>Split object.</p>
</td></tr>
<tr><td><code id="pullMap_+3A_fun">fun</code></td>
<td>
<p>Function to space the markers on the map. 
Default is &quot;haldane&quot;. Alternatives are &quot;kosambi&quot;, &quot;carter&quot; and &quot;none.</p>
</td></tr>
<tr><td><code id="pullMap_+3A_corr">corr</code></td>
<td>
<p>Corrector, if recombinations are overestimated.
Allows to multiply all spaces by a fixed factor.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Ordered vector of marker locations. Each marker has a name attribute.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(simTetra)
simTetrageno &lt;- bases2genotypes(simTetra, 4)
rfMat &lt;- calcRec(simTetrageno, 4)
split &lt;- splitChr(rfMat, nchr = 7)
split &lt;- sortLeafs(rfMat, split)
pullMap(rfMat, split = split)   
</code></pre>

<hr>
<h2 id='sarfExt'>Extends SARF criterion to neighborhood</h2><span id='topic+sarfExt'></span>

<h3>Description</h3>

<p>The neighborhood is increased stepwise until only one order remains.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sarfExt(uniOrd, dis, maxSarf = length(uniOrd[1, ]) - 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sarfExt_+3A_uniord">uniOrd</code></td>
<td>
<p>Order of markers.</p>
</td></tr>
<tr><td><code id="sarfExt_+3A_dis">dis</code></td>
<td>
<p>Distance object.</p>
</td></tr>
<tr><td><code id="sarfExt_+3A_maxsarf">maxSarf</code></td>
<td>
<p>Maximal number of neighbors to include. Should not exceed number of markers -1.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Order with minimal SARF.
</p>

<hr>
<h2 id='shuffleInput'>Randomize marker order and alleles within samples
In simulated datasets, the order or markers and alleles within samples is often given.
To remove any prior knowledge, that would not be available, the data should be randomized.
Thus, the performance of our tool can be validated unbiased.</h2><span id='topic+shuffleInput'></span>

<h3>Description</h3>

<p>Randomize marker order and alleles within samples
</p>
<p>In simulated datasets, the order or markers and alleles within samples is often given.
To remove any prior knowledge, that would not be available, the data should be randomized.
Thus, the performance of our tool can be validated unbiased.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>shuffleInput(input, ploidy = 4, ignore = 0)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="shuffleInput_+3A_input">input</code></td>
<td>
<p>Matrix of genotypes. Rows represent markers. 
Columns represent samples.</p>
</td></tr>
<tr><td><code id="shuffleInput_+3A_ploidy">ploidy</code></td>
<td>
<p>Ploidy level of the organism. Default is 4.</p>
</td></tr>
<tr><td><code id="shuffleInput_+3A_ignore">ignore</code></td>
<td>
<p>In case of unnecessary fronstanding columns (e.g. parental genotypes or rownames), these can be excluded from the randomization.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Matrix of the same size as the input matrix.
The markers are in a random order and the alleles within the samples are in a random order.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(simTetra)
shuffleInput(simTetra, 4)
</code></pre>

<hr>
<h2 id='simHexa'>Hexaploid F2 population</h2><span id='topic+simHexa'></span>

<h3>Description</h3>

<p>100 offspring genotypes from an F2 crossing population.
Generated with PedigreeSim (Voorips et al, 2012).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>simHexa
</code></pre>


<h3>Format</h3>

<p>A data frame with 131 rows and 600 variables:</p>


<h3>Source</h3>

<p><a href="https://github.com/PBR/pedigreeSim">https://github.com/PBR/pedigreeSim</a>
</p>

<hr>
<h2 id='simTetra'>Tetraploid F2 population</h2><span id='topic+simTetra'></span>

<h3>Description</h3>

<p>100 offspring genotypes from an F2 crossing population.
Generated with PedigreeSim (Voorips et al, 2012).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>simTetra
</code></pre>


<h3>Format</h3>

<p>A data frame with 131 rows and 400 variables:</p>


<h3>Source</h3>

<p><a href="https://github.com/PBR/pedigreeSim">https://github.com/PBR/pedigreeSim</a>
</p>

<hr>
<h2 id='sortLeafs'>Chromosome wise leaf ordering</h2><span id='topic+sortLeafs'></span>

<h3>Description</h3>

<p>Calculates the optimal leaf ordering pairwise for all linkage groups.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sortLeafs(rf, df, method = "seriation", maxSarf = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sortLeafs_+3A_rf">rf</code></td>
<td>
<p>Matrix of pairwise recombination frequencies.</p>
</td></tr>
<tr><td><code id="sortLeafs_+3A_df">df</code></td>
<td>
<p>Vector of cluster numbers, created by splitChr(). Zeros indicated filtered markers and will be ignored.</p>
</td></tr>
<tr><td><code id="sortLeafs_+3A_method">method</code></td>
<td>
<p>Name of method. Default: seriation (uses the optimal leaf ordering algorithm from the seriation package). 
Alternatives endlink (order.endlink from gclus) and endlink-global (ignores linkage groups).</p>
</td></tr>
<tr><td><code id="sortLeafs_+3A_maxsarf">maxSarf</code></td>
<td>
<p>Maximum number of neighbor to include into SARF extension.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Vector of global marker order.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(simTetra)
simTetrageno &lt;- bases2genotypes(simTetra, 4)
rfMat &lt;- calcRec(simTetrageno, 4)
split &lt;- splitChr(rfMat, nchr = 7)
sortLeafs(rfMat, split)
</code></pre>

<hr>
<h2 id='splitChr'>Split markers into chromosomes</h2><span id='topic+splitChr'></span>

<h3>Description</h3>

<p>This function splits markers into linkage groups (LG), which ideally represent chromosomes.
The split is based on hierarchical clustering with a single linkage distance.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>splitChr(rf, height = 0.4, nchr = NULL, method = "single",
  filter = FALSE, thresh = 0.05, rm.dup = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="splitChr_+3A_rf">rf</code></td>
<td>
<p>Matrix of pairwise recombination frequencies.</p>
</td></tr>
<tr><td><code id="splitChr_+3A_height">height</code></td>
<td>
<p>Threshold value for grouping the markers.</p>
</td></tr>
<tr><td><code id="splitChr_+3A_nchr">nchr</code></td>
<td>
<p>Expected number of chromosomes.</p>
</td></tr>
<tr><td><code id="splitChr_+3A_method">method</code></td>
<td>
<p>Default is &quot;single&quot;, which is used for the hierarchical clustering.</p>
</td></tr>
<tr><td><code id="splitChr_+3A_filter">filter</code></td>
<td>
<p>Logical, if the result should be filtered or not. Default is FALSE. Creates zeros for the markers below the threshold.</p>
</td></tr>
<tr><td><code id="splitChr_+3A_thresh">thresh</code></td>
<td>
<p>Threshold for filtering. Default is 0.05, i.e. linkage groups with less than 5% of markers, are filtered out.</p>
</td></tr>
<tr><td><code id="splitChr_+3A_rm.dup">rm.dup</code></td>
<td>
<p>Logical, if the duplicated markers should be filtered out.
TRUE is highly recommended because the markers have no added value for the linkage map.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Vector of cluster relationship. Same length and order as the matrix of recombination frequencies.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(simTetra)
simTetrageno&lt;-bases2genotypes(simTetra, 4)
rfMat&lt;-calcRec(simTetrageno, 4)
splitChr(rfMat, nchr = 7)
</code></pre>

<hr>
<h2 id='swapChrs'>Swap chromosomes</h2><span id='topic+swapChrs'></span>

<h3>Description</h3>

<p>Finds best matching chromosome for each chromosome and brings them into the same order.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>swapChrs(map, comp)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="swapChrs_+3A_map">map</code></td>
<td>
<p>Map to switch.</p>
</td></tr>
<tr><td><code id="swapChrs_+3A_comp">comp</code></td>
<td>
<p>Other map for comparison.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>map
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(simTetra)
simTetrageno &lt;- bases2genotypes(simTetra, 4)
rfMat &lt;- calcRec(simTetrageno, 4)
split &lt;- splitChr(rfMat, nchr = 7)
split &lt;- sortLeafs(rfMat, split)
map &lt;- pullMap(rfMat, split = split)   
split &lt;- sortLeafs(rfMat, split, method = "endlink")
map2 &lt;- pullMap(rfMat, split = split)   
map &lt;- swapChrs(map, map2)
</code></pre>

<hr>
<h2 id='switchChr'>Switch Chromosomes</h2><span id='topic+switchChr'></span>

<h3>Description</h3>

<p>Switches chromosomes if comparison map fits better.
This does improve the comparability without changing the order, 
as chromosomes are independent.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>switchChr(map, comp)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="switchChr_+3A_map">map</code></td>
<td>
<p>Map to switch.</p>
</td></tr>
<tr><td><code id="switchChr_+3A_comp">comp</code></td>
<td>
<p>Other map for comparison.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>map
</p>

<hr>
<h2 id='switchChrs'>Switch Chromosomes</h2><span id='topic+switchChrs'></span>

<h3>Description</h3>

<p>Wrapper function to switch chromosomes for the whole map
</p>


<h3>Usage</h3>

<pre><code class='language-R'>switchChrs(map, comp)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="switchChrs_+3A_map">map</code></td>
<td>
<p>Map to switch.</p>
</td></tr>
<tr><td><code id="switchChrs_+3A_comp">comp</code></td>
<td>
<p>Other map for comparison.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>map
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(simTetra)
simTetrageno &lt;- bases2genotypes(simTetra, 4)
rfMat &lt;- calcRec(simTetrageno, 4)
split &lt;- splitChr(rfMat, nchr = 7)
split &lt;- sortLeafs(rfMat, split)
map &lt;- pullMap(rfMat, split = split)   
split &lt;- sortLeafs(rfMat, split, method = "endlink")
map2 &lt;- pullMap(rfMat, split = split)   
map &lt;- switchChrs(map, map2)

</code></pre>

<hr>
<h2 id='switchEntries'>Switches entries in hclust object</h2><span id='topic+switchEntries'></span>

<h3>Description</h3>

<p>Switches entries in hclust object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>switchEntries(hc, e1, e2)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="switchEntries_+3A_hc">hc</code></td>
<td>
<p>Hierarchical clustering object.</p>
</td></tr>
<tr><td><code id="switchEntries_+3A_pair">pair</code></td>
<td>
<p>Vector of length 2.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Updated hclust object.
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
