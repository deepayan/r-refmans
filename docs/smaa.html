<!DOCTYPE html><html lang="en"><head><title>Help for package smaa</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {smaa}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#smaa-package'><p>SMAA: Stochastic Multi-criteria Acceptability Analysis</p></a></li>
<li><a href='#smaa'><p>One-stage SMAA analysis</p></a></li>
<li><a href='#smaa.cf'>
<p>SMAA confidence factors</p></a></li>
<li><a href='#smaa.cw'>
<p>SMAA central weights</p></a></li>
<li><a href='#smaa.entropy'>
<p>Decision entropy</p></a></li>
<li><a href='#smaa.pvf'>
<p>Compute piece-wise linear partial value functions</p></a></li>
<li><a href='#smaa.pwi'>
<p>SMAA pair-wise winning indices</p></a></li>
<li><a href='#smaa.ra'>
<p>SMAA rank acceptabilities</p></a></li>
<li><a href='#smaa.ranks'>
<p>SMAA ranking</p></a></li>
<li><a href='#smaa.values'>
<p>SMAA alternative values</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Version:</td>
<td>0.3-3</td>
</tr>
<tr>
<td>Date:</td>
<td>2024-09-05</td>
</tr>
<tr>
<td>Title:</td>
<td>Stochastic Multi-Criteria Acceptability Analysis</td>
</tr>
<tr>
<td>Suggests:</td>
<td>hitandrun</td>
</tr>
<tr>
<td>Imports:</td>
<td>graphics</td>
</tr>
<tr>
<td>Description:</td>
<td>Implementation of the Stochastic Multi-Criteria Acceptability Analysis (SMAA) family of Multiple Criteria Decision Analysis (MCDA) methods. Tervonen, T. and Figueira,  J. R. (2008) &lt;<a href="https://doi.org/10.1002%2Fmcda.407">doi:10.1002/mcda.407</a>&gt;.</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/gertvv/rsmaa">https://github.com/gertvv/rsmaa</a></td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-09-05 18:11:06 UTC; gert</td>
</tr>
<tr>
<td>Author:</td>
<td>Gert van Valkenhoef [aut, cre, cph]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Gert van Valkenhoef &lt;gert@gertvv.nl&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-09-06 14:40:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='smaa-package'>SMAA: Stochastic Multi-criteria Acceptability Analysis</h2><span id='topic+smaa-package'></span>

<h3>Description</h3>

<p>This R package implements the Stochastic Multi-criteria Acceptability Analysis (SMAA) family of
methods for stochastic Multiple Criteria Decision Analysis (MCDA). In SMAA methods, uncertainty in
criteria measurements and incomplete information on the weights are accounted for by Monte Carlo
integration of probability distributions.
</p>


<h3>Details</h3>

<p>The <code><a href="#topic+smaa">smaa</a></code> function implements the core Monte Carlo integration method. It calculates
the SMAA decision metrics (rank acceptabilities and central weights) in one go.
</p>
<p>Alternatively, the <code><a href="#topic+smaa.values">smaa.values</a></code>, <code><a href="#topic+smaa.ranks">smaa.ranks</a></code>, <code><a href="#topic+smaa.ra">smaa.ra</a></code>, and
<code><a href="#topic+smaa.cw">smaa.cw</a></code> perform the individual steps. Note that <code><a href="#topic+smaa">smaa</a></code> is slightly more
efficient because it does not store the alternatives' values or rankings.
</p>
<p>The <a href="hitandrun.html#topic+hitandrun-package">hitandrun-package</a> is complementary to this package in that it provides methods
for sampling weights when incomplete preference information is available in the form of linear
constraints on the weight vector.
</p>


<h3>Author(s)</h3>

<p>Gert van Valkenhoef</p>


<h3>References</h3>

<p>T. Tervonen and J.R. Figueira (2008),
<em>A survey on stochastic multicriteria acceptability analysis methods</em>,
Journal of Multi-Criteria Decision Analysis 15(1-2):1-14.
[<a href="https://doi.org/10.1002/mcda.407">doi:10.1002/mcda.407</a>]
</p>
<p>T. Tervonen, G. van Valkenhoef, N. Basturk, and D. Postmus (2012),
<em>Hit-And-Run enables efficient weight generation for simulation-based multiple criteria decision analysis</em>,
European Journal of Operational Research 224(3):552-559.
[<a href="https://doi.org/10.1016/j.ejor.2012.08.026">doi:10.1016/j.ejor.2012.08.026</a>]
</p>


<h3>Examples</h3>

<pre><code class='language-R'>N &lt;- 1E4; m &lt;- 2; n &lt;- 3
meas &lt;- dget(system.file("extdata/thrombo-meas.txt.gz", package="smaa"))
pref &lt;- dget(system.file("extdata/thrombo-weights-nopref.txt.gz", package="smaa"))

# Calculate SMAA metrics (one-stage)
result &lt;- smaa(meas, pref)
print(result)

# Calculate SMAA metrics (multi-stage)
values &lt;- smaa.values(meas, pref)
summary(values)
ranks &lt;- smaa.ranks(values)
smaa.ra(ranks)
smaa.entropy.ranking(ranks)
smaa.cw(ranks, pref)

# Calculate confidence factors
smaa.cf(meas, result$cw)
</code></pre>

<hr>
<h2 id='smaa'>One-stage SMAA analysis</h2><span id='topic+smaa'></span>

<h3>Description</h3>

<p>Calculate SMAA decision indices based on a set of samples from the criteria values distribution and a set of samples from the feasible weight space.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>    smaa(meas, pref)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="smaa_+3A_meas">meas</code></td>
<td>
<p>Criteria measurements. An <code class="reqn">N \times m \times n</code>
array, where <code>meas[i,,]</code> is a matrix where the m alternatives are the
rows and the n criteria the columns. The values must be standardized
measurements (i.e.  after application of the partial value function).
<code><a href="#topic+smaa.pvf">smaa.pvf</a></code> provides a convenience method to standardize partial values.</p>
</td></tr>
<tr><td><code id="smaa_+3A_pref">pref</code></td>
<td>
<p>Weights. An <code class="reqn">N \times n</code> array, where <code>pref[i,]</code>
is a normalized weight vector.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The one-stage method does not store the alternatives' values or the raw
rankings. Instead, only standard summary metrics are provided.
</p>


<h3>Value</h3>

<table role = "presentation">
<tr><td><code>ra</code></td>
<td>
<p>Rank acceptabilities (see <code><a href="#topic+smaa.ra">smaa.ra</a></code>).</p>
</td></tr>
<tr><td><code>cw</code></td>
<td>
<p>Central weights (see <code><a href="#topic+smaa.cw">smaa.cw</a></code>).</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Gert van Valkenhoef
</p>


<h3>See Also</h3>

<p><code><a href="#topic+smaa.pvf">smaa.pvf</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>N &lt;- 1E4; m &lt;- 2; n &lt;- 3
meas &lt;- dget(system.file("extdata/thrombo-meas.txt.gz", package="smaa"))

# Read weights from file
pref &lt;- dget(system.file("extdata/thrombo-weights-nopref.txt.gz", package="smaa"))
# Alternatively, sample weights using hitandrun:
# library(hitandrun)
# pref &lt;- simplex.sample(n, N)$samples

# Calculate SMAA metrics
result &lt;- smaa(meas, pref)
print(result)
plot(result)

result &lt;- smaa(meas, c(0.5, 0.2, 0.3))
print(result)
</code></pre>

<hr>
<h2 id='smaa.cf'>
SMAA confidence factors
</h2><span id='topic+smaa.cf'></span>

<h3>Description</h3>

<p>Calculate SMAA confidence factors of the central weights.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>smaa.cf(meas, cw)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="smaa.cf_+3A_meas">meas</code></td>
<td>
<p>Criteria measurements. An <code class="reqn">N \times m \times n</code>
array, where <code>meas[i,,]</code> is a matrix where the m alternatives are the
rows and the n criteria the columns. The values must be standardized
measurements (i.e.  after application of the partial value function).</p>
</td></tr>
<tr><td><code id="smaa.cf_+3A_cw">cw</code></td>
<td>
<p>An <code class="reqn">m \times n</code> matrix of central weights, where
each row corresponds to an alternative and each column to a criterion.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The confidence factor for an alternative is its first-rank acceptability
under its central weight.
</p>


<h3>Value</h3>

<p>An object of class <code>smaa.cf</code>, with the following elements:
</p>
<table role = "presentation">
<tr><td><code>cf</code></td>
<td>
<p>A vector of confidence factors, one for each alternative.</p>
</td></tr>
<tr><td><code>cw</code></td>
<td>
<p>The central weights (see <code><a href="#topic+smaa.cw">smaa.cw</a></code>).</p>
</td></tr>
</table>
<p>The number of SMAA iterations is stored in <code>attr(x, "smaa.N")</code>.
</p>


<h3>Author(s)</h3>

<p>Gert van Valkenhoef
</p>


<h3>See Also</h3>

<p><code><a href="#topic+smaa.cw">smaa.cw</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>N &lt;- 1E4; m &lt;- 2; n &lt;- 3
meas &lt;- dget(system.file("extdata/thrombo-meas.txt.gz", package="smaa"))
pref &lt;- dget(system.file("extdata/thrombo-weights-nopref.txt.gz", package="smaa"))

# Calculate central weights
values &lt;- smaa.values(meas, pref)
ranks &lt;- smaa.ranks(values)
cw &lt;- smaa.cw(ranks, pref)
print(cw)
cf &lt;- smaa.cf(meas, cw)
print(cf)
plot(cf)
</code></pre>

<hr>
<h2 id='smaa.cw'>
SMAA central weights
</h2><span id='topic+smaa.cw'></span>

<h3>Description</h3>

<p>Calculate SMAA central weights from sampled rankings and the corresponding weights.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>smaa.cw(ranks, pref)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="smaa.cw_+3A_ranks">ranks</code></td>
<td>
<p>An <code class="reqn">N \times m</code> array of sampled rankings, where <code class="reqn">N</code> is the number
of SMAA iterations and <code class="reqn">m</code> is the number of alternatives.</p>
</td></tr>
<tr><td><code id="smaa.cw_+3A_pref">pref</code></td>
<td>
<p>An <code class="reqn">N \times n</code> array of sampled rankings, where <code class="reqn">N</code> is the number
of SMAA iterations and <code class="reqn">n</code> is the number of alternatives.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An <code class="reqn">m \times n</code> matrix of central weights, where each row corresponds to an
alternative and each column to a criterion.
The number of SMAA iterations is stored in <code>attr(x, "smaa.N")</code>.
</p>


<h3>Note</h3>

<p>The value is given class <code>smaa.cw</code>, use <code>unclass(x)</code> to treat it as a regular matrix.
</p>


<h3>Author(s)</h3>

<p>Gert van Valkenhoef
</p>


<h3>See Also</h3>

<p><code><a href="#topic+smaa.ranks">smaa.ranks</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>N &lt;- 1E4; m &lt;- 2; n &lt;- 3
meas &lt;- dget(system.file("extdata/thrombo-meas.txt.gz", package="smaa"))
pref &lt;- dget(system.file("extdata/thrombo-weights-nopref.txt.gz", package="smaa"))

# Calculate central weights
values &lt;- smaa.values(meas, pref)
ranks &lt;- smaa.ranks(values)
cw &lt;- smaa.cw(ranks, pref)
print(cw)
plot(cw)
</code></pre>

<hr>
<h2 id='smaa.entropy'>
Decision entropy
</h2><span id='topic+smaa.entropy'></span><span id='topic+smaa.entropy.ranking'></span><span id='topic+smaa.entropy.choice'></span>

<h3>Description</h3>

<p>Calculate decision entropy from the sampled SMAA rankings. For both ranking and choice problematics.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>smaa.entropy.ranking(ranks, p0 = 1)
smaa.entropy.choice(ra, p0 = 1)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="smaa.entropy_+3A_ranks">ranks</code></td>
<td>
<p>Object of class <code>smaa.ranks</code> containing sampled SMAA rankings.</p>
</td></tr>
<tr><td><code id="smaa.entropy_+3A_ra">ra</code></td>
<td>
<p>Object of class <code>smaa.ra</code> containing SMAA rank acceptabilities.
Alternatively, an object of class <code>smaa.ranks</code> from which the rank acceptabilities will be
calculated.</p>
</td></tr>
<tr><td><code id="smaa.entropy_+3A_p0">p0</code></td>
<td>
<p>Baseline probability for the entropy calculation.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Calculates the entropy for the given problematic, quantifying either the uncertainty in the ranking
of the alternatives (where the outcome space <code class="reqn">Y</code> consists of the <code class="reqn">m!</code> possible
rankings) or in the choice of the best alternative (where the outcome space <code class="reqn">Y</code> consists of
the <code class="reqn">m</code> alternatives). The entropy is given by:
</p>
<p style="text-align: center;"><code class="reqn">H(Y|W) = -\sum_{y \in Y} p_0 p(y|W) \log p_0 p(y|W)</code>
</p>

<p>where <code class="reqn">W</code> is the space of feasible weights.
Since the SMAA analysis samples from the outcome space, the <code class="reqn">p(y|W)</code> can be estimated
directly from the given sample.
</p>


<h3>Value</h3>

<p>The entropy (a single numeric value).
</p>


<h3>Note</h3>

<p>The number of samples needed to accurately estimate <code class="reqn">H(Y|W)</code> for the ranking problematic
is currently unknown.
</p>


<h3>Author(s)</h3>

<p>Gert van Valkenhoef
</p>


<h3>References</h3>

<p>G. van Valkenhoef and T. Tervonen, <em>Optimal weight constraint elicitation for additive
multi-attribute utility models</em>, presentation at EURO 2013, July 2013, Rome, Italy.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+smaa.ranks">smaa.ranks</a></code>
<code><a href="#topic+smaa.ra">smaa.ra</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>N &lt;- 1E4; m &lt;- 2; n &lt;- 3
meas &lt;- dget(system.file("extdata/thrombo-meas.txt.gz", package="smaa"))
pref &lt;- dget(system.file("extdata/thrombo-weights-nopref.txt.gz", package="smaa"))

# Calculate ranks
values &lt;- smaa.values(meas, pref)
ranks &lt;- smaa.ranks(values)

# Calculate ranking entropy
smaa.entropy.ranking(ranks)

# Calculate choice entropy
# (equal to ranking entropy because there are only two alternatives)
smaa.entropy.choice(ranks)
smaa.entropy.choice(smaa.ra(ranks))
</code></pre>

<hr>
<h2 id='smaa.pvf'>
Compute piece-wise linear partial value functions
</h2><span id='topic+smaa.pvf'></span>

<h3>Description</h3>

<p>Given a set of reference levels and their values, compute a linearly
interpolated (piece-wise linear) partial value function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>smaa.pvf(x, cutoffs, values, outOfBounds="error")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="smaa.pvf_+3A_x">x</code></td>
<td>
<p>Values to compute the PVF for, a numeric vector</p>
</td></tr>
<tr><td><code id="smaa.pvf_+3A_cutoffs">cutoffs</code></td>
<td>
<p>Reference levels (ascending order)</p>
</td></tr>
<tr><td><code id="smaa.pvf_+3A_values">values</code></td>
<td>
<p>Values of the reference levels</p>
</td></tr>
<tr><td><code id="smaa.pvf_+3A_outofbounds">outOfBounds</code></td>
<td>
<p>What to do when some of the <code>x</code> are outside
the range of the given <code>cutoffs</code>. When <code>"error"</code>, throws an
error. When <code>"clip"</code>, clips to the value of the first or last
cutoff. When <code>"interpolate"</code>, interpolates according to the closest
interval.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A numeric vector the same length as <code>x</code>.
</p>
<p>The values are computed by linear interpolation between the values of
the two closest reference levels. This has been implemented in C for a
dramatic performance improvement.
</p>


<h3>Author(s)</h3>

<p>Gert van Valkenhoef
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- c(50, 90, 100, 10, 40, 101, 120)
values &lt;- smaa.pvf(x,
  cutoffs=c(50, 75, 90, 100),
  values=c(1, 0.8, 0.5, 0),
  outOfBounds="clip")
stopifnot(all.equal(values, c(1.0, 0.5, 0.0, 1.0, 1.0, 0.0, 0.0)))
</code></pre>

<hr>
<h2 id='smaa.pwi'>
SMAA pair-wise winning indices
</h2><span id='topic+smaa.pwi'></span>

<h3>Description</h3>

<p>Calculate SMAA pair-wise winning indices from sampled rankings.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>smaa.pwi(ranks)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="smaa.pwi_+3A_ranks">ranks</code></td>
<td>
<p>An <code class="reqn">N \times m</code> array of sampled rankings, where <code class="reqn">N</code> is the number
of SMAA iterations and <code class="reqn">m</code> is the number of alternatives.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An <code class="reqn">m \times m</code> matrix of pair-wise winning indices. The
index at (i, j) describes the share of samples for which alternative i
has a better (lower) rank than alternative j.
</p>


<h3>Author(s)</h3>

<p>Tommi Tervonen
</p>


<h3>See Also</h3>

<p><code><a href="#topic+smaa.ranks">smaa.ranks</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>N &lt;- 1E4; m &lt;- 2; n &lt;- 3
meas &lt;- dget(system.file("extdata/thrombo-meas.txt.gz", package="smaa"))
pref &lt;- dget(system.file("extdata/thrombo-weights-nopref.txt.gz", package="smaa"))

# Calculate pair-wise winning indices
values &lt;- smaa.values(meas, pref)
ranks &lt;- smaa.ranks(values)
pwi &lt;- smaa.pwi(ranks)
print(pwi)
</code></pre>

<hr>
<h2 id='smaa.ra'>
SMAA rank acceptabilities
</h2><span id='topic+smaa.ra'></span>

<h3>Description</h3>

<p>Calculate SMAA rank acceptabilities from sampled rankings.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>smaa.ra(ranks)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="smaa.ra_+3A_ranks">ranks</code></td>
<td>
<p>An <code class="reqn">N \times m</code> array of sampled rankings, where <code class="reqn">N</code> is the number
of SMAA iterations and <code class="reqn">m</code> is the number of alternatives.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An <code class="reqn">m \times m</code> matrix of rank probabilities, where each row corresponds to an
alternative.
The number of SMAA iterations is stored in <code>attr(x, "smaa.N")</code>.
</p>


<h3>Note</h3>

<p>The value is given class <code>smaa.ra</code>, use <code>unclass(x)</code> to treat it as a regular matrix.
</p>


<h3>Author(s)</h3>

<p>Gert van Valkenhoef
</p>


<h3>See Also</h3>

<p><code><a href="#topic+smaa.ranks">smaa.ranks</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>N &lt;- 1E4; m &lt;- 2; n &lt;- 3
meas &lt;- dget(system.file("extdata/thrombo-meas.txt.gz", package="smaa"))
pref &lt;- dget(system.file("extdata/thrombo-weights-nopref.txt.gz", package="smaa"))

# Calculate rank acceptabilities
values &lt;- smaa.values(meas, pref)
ranks &lt;- smaa.ranks(values)
ra &lt;- smaa.ra(ranks)
print(ra)
plot(ra)
</code></pre>

<hr>
<h2 id='smaa.ranks'>
SMAA ranking
</h2><span id='topic+smaa.ranks'></span>

<h3>Description</h3>

<p>Calculate SMAA ranks based on the sampled alternatives' values.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>smaa.ranks(values)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="smaa.ranks_+3A_values">values</code></td>
<td>
<p>An <code class="reqn">N \times m</code> array of sampled alternative values, where <code class="reqn">N</code> is
the number of SMAA iterations and <code class="reqn">m</code> is the number of alternatives.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An <code class="reqn">N \times m</code> array of ranks obtained by each alternative in each iteration.
</p>


<h3>Note</h3>

<p>The value is given class <code>smaa.ranks</code>, use <code>unclass(x)</code> to treat it as a regular matrix.
</p>


<h3>Author(s)</h3>

<p>Gert van Valkenhoef
</p>


<h3>See Also</h3>

<p><code><a href="#topic+smaa.values">smaa.values</a></code>
<code><a href="#topic+smaa.ra">smaa.ra</a></code>
<code><a href="#topic+smaa.cw">smaa.cw</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>N &lt;- 1E4; m &lt;- 2; n &lt;- 3
meas &lt;- dget(system.file("extdata/thrombo-meas.txt.gz", package="smaa"))
pref &lt;- dget(system.file("extdata/thrombo-weights-nopref.txt.gz", package="smaa"))

# Calculate alternative ranks
values &lt;- smaa.values(meas, pref)
ranks &lt;- smaa.ranks(values)
summary(ranks)

ranks.expected &lt;- dget(system.file("extdata/thrombo-ranks-nopref.txt.gz", package="smaa"))
stopifnot(all.equal(ranks, ranks.expected))
</code></pre>

<hr>
<h2 id='smaa.values'>
SMAA alternative values
</h2><span id='topic+smaa.values'></span>

<h3>Description</h3>

<p>Calculate the alternative values based on a set of samples from the criteria values distribution and a set of samples from the feasible weight space.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>smaa.values(meas, pref)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="smaa.values_+3A_meas">meas</code></td>
<td>
<p>Criteria measurements. An <code class="reqn">N \times m \times n</code>
array, where <code>meas[i,,]</code> is a matrix where the m alternatives are the
rows and the n criteria the columns. The values must be standardized
measurements (i.e.  after application of the partial value function).
<code><a href="#topic+smaa.pvf">smaa.pvf</a></code> provides a convenience method to standardize partial values.</p>
</td></tr>
<tr><td><code id="smaa.values_+3A_pref">pref</code></td>
<td>
<p>Weights. An <code class="reqn">N \times n</code> array, where <code>pref[i,]</code>
is a normalized weight vector.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An <code class="reqn">N \times m</code> array of alternative values.
</p>


<h3>Author(s)</h3>

<p>Gert van Valkenhoef
</p>


<h3>See Also</h3>

<p><code><a href="#topic+smaa.pvf">smaa.pvf</a></code>
<code><a href="#topic+smaa.ranks">smaa.ranks</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>N &lt;- 1E4; m &lt;- 2; n &lt;- 3
meas &lt;- dget(system.file("extdata/thrombo-meas.txt.gz", package="smaa"))

# Read weights from file
pref &lt;- dget(system.file("extdata/thrombo-weights-nopref.txt.gz", package="smaa"))
# Alternatively, sample weights using hitandrun:
# library(hitandrun)
# pref &lt;- simplex.sample(n, N)$samples

# Calculate alternative values
values &lt;- smaa.values(meas, pref)
summary(values)
plot(values)

values.expected &lt;- dget(system.file("extdata/thrombo-values-nopref.txt.gz", package="smaa"))
stopifnot(all.equal(values, values.expected))
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
