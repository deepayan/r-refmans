<!DOCTYPE html><html><head><title>Help for package iCAMP</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {iCAMP}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#bmntd'>
<p>beta mean nearest taxon distance (betaMNTD)</p></a></li>
<li><a href='#bmntd.big'>
<p>beta mean nearest taxon distance (betaMNTD) from big data</p></a></li>
<li><a href='#bmpd'>
<p>Beta mean pairwise distance (betaMPD)</p></a></li>
<li><a href='#bNRI.bin.big'>
<p>Calculate beta net relatedness index (betaNRI) for each phylogenetic bin</p></a></li>
<li><a href='#bNRI.bin.cm'>
<p>Calculate beta net relatedness index (betaNRI) for each phylogenetic bin under multiple metacommunities</p></a></li>
<li><a href='#bNRI.cm'>
<p>Calculate beta net relatedness index with parallel computing under multiple metacommunities</p></a></li>
<li><a href='#bNRIn.p'>
<p>Calculate beta net relatedness index with parallel computing</p></a></li>
<li><a href='#bNTI.big'>
<p>Beta nearest taxon index (betaNTI) from big data</p></a></li>
<li><a href='#bNTI.big.cm'>
<p>Beta nearest taxon index (betaNTI) from big data and under multiple metacommunities</p></a></li>
<li><a href='#bNTI.bin.big'>
<p>Calculate beta nearest taxon index (betaNTI) for each phylogenetic bin</p></a></li>
<li><a href='#bNTI.bin.cm'>
<p>Calculate beta nearest taxon index (betaNTI) for each phylogenetic bin under multiple metacommunities</p></a></li>
<li><a href='#bNTI.cm'>
<p>Calculate beta nearest taxon index (betaNTI) with parallel computing under multiple metacommunities</p></a></li>
<li><a href='#bNTIn.p'>
<p>Calculate beta nearest taxon index (betaNTI) with parallel computing</p></a></li>
<li><a href='#change.sigindex'>
<p>Change significance index option in iCAMP analysis</p></a></li>
<li><a href='#cohend'>
<p>Cohen's d effect size</p></a></li>
<li><a href='#dist.3col'>
<p>Transform distance matrix to 3-column matrix</p></a></li>
<li><a href='#dist.bin.3col'>
<p>Convert a list of dist (or matrixes) to a matrix</p></a></li>
<li><a href='#dniche'>
<p>Calculate niche difference between species</p></a></li>
<li><a href='#example.data'>
<p>A simple example dataset for test</p></a></li>
<li><a href='#iCAMP-package'>
<p>Infer Community Assembly Mechanisms by Phylogenetic-bin-based null model analysis</p></a></li>
<li><a href='#icamp.big'>
<p>Infer community assembly mechanism by phylogenetic-bin-based null model analysis</p></a></li>
<li><a href='#icamp.bins'>
<p>Summarize iCAMP result in each bin</p></a></li>
<li><a href='#icamp.boot'>
<p>Bootstrapping analysis of icamp results</p></a></li>
<li><a href='#icamp.cate'>
<p>Summarize iCAMP result for different categories of taxa</p></a></li>
<li><a href='#icamp.cm'>
<p>Infer community assembly mechanism by phylogenetic-bin-based null model analysis under multiple metacommunities</p></a></li>
<li><a href='#icamp.cm2'>
<p>Phylogenetic-bin-based null model analysis under different metacommunity settings for phylogenetic and taxonomic null models</p></a></li>
<li><a href='#icamp.out'>
<p>Example output of function icamp.big</p></a></li>
<li><a href='#match.2col'>
<p>Check the consistency of the first two columns of different matrixes</p></a></li>
<li><a href='#match.name'>
<p>Check and ensure the consistency of IDs in different objects.</p></a></li>
<li><a href='#maxbigm'>
<p>Find maximum value in a big matrix</p></a></li>
<li><a href='#midpoint.root.big'>
<p>Midpoint root a large phylogeny</p></a></li>
<li><a href='#mntdn'>
<p>Mean nearest taxon distance (MNTD)</p></a></li>
<li><a href='#mpdn'>
<p>Mean pairwise distance (MPD)</p></a></li>
<li><a href='#NRI.cm'>
<p>Calculate net relatedness index (NRI) under multiple metacommunities</p></a></li>
<li><a href='#NRI.p'>
<p>Calculate net relatedness index (NRI) by parallel computing.</p></a></li>
<li><a href='#NTI.cm'>
<p>Calculate nearest taxon index (NTI) under multiple metacommunities</p></a></li>
<li><a href='#NTI.p'>
<p>Calculate nearest taxon index (NTI) with parallel computing</p></a></li>
<li><a href='#null.norm'>
<p>Normality test for null values</p></a></li>
<li><a href='#pdist.big'>
<p>Pairwise phylogenetic distance matrix from big tree</p></a></li>
<li><a href='#pdist.p'>
<p>Pairwise phylogenetic distance matrix from small tree</p></a></li>
<li><a href='#ps.bin'>
<p>Test within-bin phylogenetic signal</p></a></li>
<li><a href='#qp.bin.js'>
<p>Calculate relative importance of community assembly processes</p></a></li>
<li><a href='#qpen'>
<p>Quantifying assembly processes based on entire-community null model analysis</p></a></li>
<li><a href='#qpen.cm'>
<p>Quantifying assembly processes based on entire-community null model analysis under multiple metacommunities</p></a></li>
<li><a href='#qpen.test'>
<p>Summary and comparison of QPEN results based on bootstrapping</p></a></li>
<li><a href='#RC.bin.bigc'>
<p>Calculate modified Roup-Crick index based on Bray-Curtis similarity for each phylogenetic bin</p></a></li>
<li><a href='#RC.bin.cm'>
<p>Calculate modified Roup-Crick index based on Bray-Curtis similarity for each phylogenetic bin under multiple metacommunities</p></a></li>
<li><a href='#RC.cm'>
<p>Modified Raup-Crick index based on Bray-Curtis similarity under multiple metacommunities</p></a></li>
<li><a href='#RC.pc'>
<p>Modified Raup-Crick index based on Bray-Curtis similarity</p></a></li>
<li><a href='#snm'>
<p>Estimation of neutral taxa percentae and dispersal rate</p></a></li>
<li><a href='#taxa.binphy.big'>
<p>Phylogenetic binning based on phylogenetic tree</p></a></li>
<li><a href='#tree.droot'>
<p>Distance from root to tip(s) and node(s) on phylogenetic tree</p></a></li>
<li><a href='#tree.path'>
<p>List nodes and edge lengthes from root to each tip and/or node</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Infer Community Assembly Mechanisms by Phylogenetic-Bin-Based
Null Model Analysis</td>
</tr>
<tr>
<td>Version:</td>
<td>1.5.12</td>
</tr>
<tr>
<td>Date:</td>
<td>2022-5-29</td>
</tr>
<tr>
<td>Author:</td>
<td>Daliang Ning</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Daliang Ning &lt;ningdaliang@ou.edu&gt;</td>
</tr>
<tr>
<td>Imports:</td>
<td>vegan,parallel,permute,ape,bigmemory,nortest,minpack.lm,Hmisc,stats4,DirichletReg,data.table</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.5)</td>
</tr>
<tr>
<td>Description:</td>
<td>To implement a general framework to quantitatively infer Community Assembly Mechanisms by Phylogenetic-bin-based null model analysis, abbreviated as 'iCAMP' (Ning et al 2020) &lt;<a href="https://doi.org/10.1038%2Fs41467-020-18560-z">doi:10.1038/s41467-020-18560-z</a>&gt;. It can quantitatively assess the relative importance of different community assembly processes, such as selection, dispersal, and drift, for both communities and each phylogenetic group ('bin'). Each bin usually consists of different taxa from a family or an order. The package also provides functions to implement some other published methods, including neutral taxa percentage (Burns et al 2016) &lt;<a href="https://doi.org/10.1038%2Fismej.2015.142">doi:10.1038/ismej.2015.142</a>&gt; based on neutral theory model and quantifying assembly processes based on entire-community null models ('QPEN', Stegen et al 2013) &lt;<a href="https://doi.org/10.1038%2Fismej.2013.93">doi:10.1038/ismej.2013.93</a>&gt;. It also includes some handy functions, particularly for big datasets, such as phylogenetic and taxonomic null model analysis at both community and bin levels, between-taxa niche difference and phylogenetic distance calculation, phylogenetic signal test within phylogenetic groups, midpoint root of big trees, etc. Version 1.3.x mainly improved the function for 'QPEN' and added function 'icamp.cate()' to summarize 'iCAMP' results for different categories of taxa (e.g. core versus rare taxa).</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a></td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/DaliangNing/iCAMP1">https://github.com/DaliangNing/iCAMP1</a></td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2022-05-29 17:16:02 UTC; ndl81</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2022-06-01 08:00:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='bmntd'>
beta mean nearest taxon distance (betaMNTD)
</h2><span id='topic+bmntd'></span>

<h3>Description</h3>

<p>Calculates beta MNTD (beta mean nearest taxon distance, Webb et al 2008) for taxa in each pair of communities in a givern community matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bmntd(comm, pd, abundance.weighted = TRUE,
      exclude.conspecifics = FALSE,time.output=FALSE,
      unit.sum=NULL, spname.check = TRUE, silent = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bmntd_+3A_comm">comm</code></td>
<td>
<p>matrix or data.frame, community data matrix, rownames are sample names, colnames are OTU ids.</p>
</td></tr>
<tr><td><code id="bmntd_+3A_pd">pd</code></td>
<td>
<p>matrix, pairwise phylogenetic distance matrix.</p>
</td></tr>
<tr><td><code id="bmntd_+3A_abundance.weighted">abundance.weighted</code></td>
<td>
<p>logic, whether weighted by species abundance, default is TRUE, means weighted.</p>
</td></tr>
<tr><td><code id="bmntd_+3A_exclude.conspecifics">exclude.conspecifics</code></td>
<td>
<p>logic, whether conspecific taxa in different communities be exclude from beta MNTD calculations, default is FALSE.</p>
</td></tr>
<tr><td><code id="bmntd_+3A_time.output">time.output</code></td>
<td>
<p>logic, whether to count calculation time, default is FALSE.</p>
</td></tr>
<tr><td><code id="bmntd_+3A_unit.sum">unit.sum</code></td>
<td>
<p>NULL or a number or a nemeric vector. When unit.sum is not NULL and a beta diversity index is calculated for a bin, the taxa abundances will be divided by unit.sum to calculate the relative abundances. usually, unit.sum can be set as the sequencing depth in each sample. Default setting is NULL, means not to do this special transformation.</p>
</td></tr> 
<tr><td><code id="bmntd_+3A_spname.check">spname.check</code></td>
<td>
<p>logic, whether to check the species names in comm and pd.</p>
</td></tr> 
<tr><td><code id="bmntd_+3A_silent">silent</code></td>
<td>
<p>logic, if FALSE, some messages will be showed if any mismatch in spcies names.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>beta mean nearest taxon distance for taxa in each pair of communities. Modified from 'comdistnt' in package 'picante'(Kembel et al 2010), this function includes matrix multiplication to be efficient for medium size dataset. 
</p>


<h3>Value</h3>

<p>result is a distance object of pairwise beta MNTD between samples. 
</p>


<h3>Note</h3>

<p>Version 3: 2020.8.16, add examples.
Version 2: 2018.10.15, add unit.sum option. if unit.sum!=NULL, will calculate relative abundance according to unit.sum.
Version 1: 2015.9.23  
</p>


<h3>Author(s)</h3>

<p>Daliang Ning
</p>


<h3>References</h3>

<p>Webb, C.O., Ackerly, D.D. &amp; Kembel, S.W. (2008). Phylocom: software for the analysis of phylogenetic community structure and trait evolution. Bioinformatics, 24, 2098-2100.
</p>
<p>Kembel, S.W., Cowan, P.D., Helmus, M.R., Cornwell, W.K., Morlon, H., Ackerly, D.D. et al. (2010). Picante: R tools for integrating phylogenies and ecology. Bioinformatics, 26, 1463-1464.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+bNTIn.p">bNTIn.p</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("example.data")
comm=example.data$comm
pd=example.data$pd
bmntd.wt=bmntd(comm, pd, abundance.weighted = TRUE,
               exclude.conspecifics = FALSE)
</code></pre>

<hr>
<h2 id='bmntd.big'>
beta mean nearest taxon distance (betaMNTD) from big data
</h2><span id='topic+bmntd.big'></span>

<h3>Description</h3>

<p>Calculates beta MNTD (beta mean nearest taxon distance, Webb et al 2008) for taxa in each pair of communities in a givern community matrix, using bigmemory (Kane et al 2013) to deal with too large dataset.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bmntd.big(comm, pd.desc = "pd.desc", pd.spname, pd.wd,
          spname.check = FALSE, abundance.weighted = TRUE,
          exclude.conspecifics = FALSE, time.output = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bmntd.big_+3A_comm">comm</code></td>
<td>
<p>matrix or data.frame, community data matrix, rownames are sample names, colnames are taxa ids.</p>
</td></tr>
<tr><td><code id="bmntd.big_+3A_pd.desc">pd.desc</code></td>
<td>
<p>character, the name to describe bigmemory file of phylogenetic distance matrix, default is &quot;pd.desc&quot;.</p>
</td></tr>
<tr><td><code id="bmntd.big_+3A_pd.spname">pd.spname</code></td>
<td>
<p>vector, the OTU ids (species names) in exactly the same order as the phylogenetic matrix rows or columns</p>
</td></tr>
<tr><td><code id="bmntd.big_+3A_pd.wd">pd.wd</code></td>
<td>
<p>the path of the folder saving the phylogenetic distance matrix.</p>
</td></tr>
<tr><td><code id="bmntd.big_+3A_spname.check">spname.check</code></td>
<td>
<p>logic, whether to check the OTU ids (species names) in community matrix and phylogenetic distance matrix are the same.</p>
</td></tr>
<tr><td><code id="bmntd.big_+3A_abundance.weighted">abundance.weighted</code></td>
<td>
<p>logic, whether weighted by species abundance, default is TRUE, means weighted.</p>
</td></tr>
<tr><td><code id="bmntd.big_+3A_exclude.conspecifics">exclude.conspecifics</code></td>
<td>
<p>logic, whether conspecific taxa in different communities be exclude from beta MNTD calculations, default is FALSE.</p>
</td></tr>
<tr><td><code id="bmntd.big_+3A_time.output">time.output</code></td>
<td>
<p>logic, whether to count calculation time, default is FALSE.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>beta mean nearest taxon distance for taxa in each pair of communities. Improved from 'comdistnt' in package 'picante'(Kembel et al 2010). This function adds bigmemory part (Kane et al 2013) to deal with large dataset.
</p>


<h3>Value</h3>

<p>result is a distance object.
</p>


<h3>Note</h3>

<p>Version 4: 2020.12.5, copy from package NST to iCAMP to improve the function qpen.
Version 3: 2020.9.9, remove setwd; change dontrun to donttest and revise save.wd in help doc.
Version 2: 2020.8.22, add to NST package, update help document.
Version 1: 2017.3.13
</p>


<h3>Author(s)</h3>

<p>Daliang Ning (ningdaliang@ou.edu)
</p>


<h3>References</h3>

<p>Webb, C.O., Ackerly, D.D. &amp; Kembel, S.W. (2008). Phylocom: software for the analysis of phylogenetic community structure and trait evolution. Bioinformatics, 24, 2098-2100.
</p>
<p>Kembel, S.W., Cowan, P.D., Helmus, M.R., Cornwell, W.K., Morlon, H., Ackerly, D.D. et al. (2010). Picante: R tools for integrating phylogenies and ecology. Bioinformatics, 26, 1463-1464.
</p>
<p>Kane, M.J., Emerson, J., Weston, S. (2013). Scalable Strategies for Computing with Massive Data. Journal of Statistical Software, 55(14), 1-19. URL http://www.jstatsoft.org/v55/i14/.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("example.data")
comm=example.data$comm
tree=example.data$tree

# since it needs to save some file to a certain folder,
# the following code is set as 'not test'.
# but you may test the code on your computer
# after change the folder path for 'save.wd'.

wd0=getwd()
save.wd=paste0(tempdir(),"/pdbig.bmntd.big")
# you may change save.wd to the folder you want to save the pd.big output.
nworker=2 # parallel computing thread number
pd.big=pdist.big(tree = tree, wd=save.wd, nworker = nworker)
bmntd.wt=bmntd.big(comm=comm, pd.desc = pd.big$pd.file,
                   pd.spname = pd.big$tip.label, pd.wd = pd.big$pd.wd,
                   abundance.weighted = TRUE)
setwd(wd0)

</code></pre>

<hr>
<h2 id='bmpd'>
Beta mean pairwise distance (betaMPD)
</h2><span id='topic+bmpd'></span>

<h3>Description</h3>

<p>Calculates mean pairwise distance separating taxa in each pair of communities in a given community matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bmpd(comm, pd, abundance.weighted = TRUE, na.zero = TRUE,
     time.output = FALSE, unit.sum = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bmpd_+3A_comm">comm</code></td>
<td>
<p>matrix or data.frame, community data matrix, rownames are sample names, colnames are OTU ids.</p>
</td></tr>
<tr><td><code id="bmpd_+3A_pd">pd</code></td>
<td>
<p>matrix, pairwise phylogenetic distance matrix.</p>
</td></tr>
<tr><td><code id="bmpd_+3A_abundance.weighted">abundance.weighted</code></td>
<td>
<p>logic, whether weighted by species abundance, default is TRUE, means weighted.</p>
</td></tr>
<tr><td><code id="bmpd_+3A_na.zero">na.zero</code></td>
<td>
<p>logic. when the sum of a row (a sample) is zero in community data matrix, the relative abundance will be NAN. Sometimes, to avoid some problem in following calculation, this kind of NAN value need be set as zero. Defalt is TRUE.</p>
</td></tr>
<tr><td><code id="bmpd_+3A_time.output">time.output</code></td>
<td>
<p>logic, whether to count calculation time, default is FALSE.</p>
</td></tr>
<tr><td><code id="bmpd_+3A_unit.sum">unit.sum</code></td>
<td>
<p>When a beta diversity index is calculated for a bin, the taxa abundances will be divided by unit.sum to calculate the relative abundances. usually, unit.sum can be set as the sequencing depth in each sample. Default setting is NULL, means not to do this special transformation.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>beta mean pairwise distance.
</p>


<h3>Value</h3>

<p>Output is a distance object of pairwise betaMPD between samples.
</p>


<h3>Note</h3>

<p>Version 3: 2020.8.16, add examples.
Version 2: 2018.10.3, add unit.sum option. if unit.sum!=NULL, will calculate relative abundance according to unit.sum
Version 1: 2015.8.21.
</p>


<h3>Author(s)</h3>

<p>Daliang Ning
</p>


<h3>References</h3>

<p>Webb CO, Ackerly DD, and Kembel SW. 2008. Phylocom: software for the analysis of phylogenetic community structure and trait evolution. Bioinformatics 18:2098-2100
</p>


<h3>See Also</h3>

<p><code><a href="#topic+bNRIn.p">bNRIn.p</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("example.data")
comm=example.data$comm
pd=example.data$pd
bmpd.wt=bmpd(comm, pd, abundance.weighted = TRUE)
</code></pre>

<hr>
<h2 id='bNRI.bin.big'>
Calculate beta net relatedness index (betaNRI) for each phylogenetic bin
</h2><span id='topic+bNRI.bin.big'></span>

<h3>Description</h3>

<p>Perform null model test based on a phylogenetic beta diversity index, beta mean pairwise distance (betaMPD), in each bin; calculate beta net relatedness index (betaNRI. Webb et al 2008), or modified Raup-Crick metric, or confidence level based on the comparison between observed and null betaMPD in each bin. The package bigmemory (Kane et al 2013) is used to handle very large phylogenetic distance matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bNRI.bin.big(comm, pd.desc, pd.spname, pd.wd, pdid.bin, sp.bin,
             spname.check = FALSE, nworker = 4, memo.size.GB = 50,
             weighted = c(TRUE, FALSE), rand = 1000, output.bMPD = FALSE,
             sig.index=c("SES","Confidence","RC","bNRI"),
             unit.sum = NULL, correct.special = FALSE,
             detail.null=FALSE, special.method=c("MPD","MNTD","both"),
             ses.cut=1.96,rc.cut=0.95, conf.cut=0.975,
             dirichlet = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bNRI.bin.big_+3A_comm">comm</code></td>
<td>
<p>matrix or data.frame, community data, each row is a sample or site, each colname is a species or OTU or gene, thus rownames should be sample IDs, colnames should be taxa IDs.</p>
</td></tr>
<tr><td><code id="bNRI.bin.big_+3A_pd.desc">pd.desc</code></td>
<td>
<p>the name of the file to hold the backingfile description of the phylogenetic distance matrix, it is usually &quot;pd.desc&quot; if using default setting in pdist.big function.</p>
</td></tr>
<tr><td><code id="bNRI.bin.big_+3A_pd.spname">pd.spname</code></td>
<td>
<p>character vector, taxa id in the same rank as the big matrix of phylogenetic distances.</p>
</td></tr>
<tr><td><code id="bNRI.bin.big_+3A_pd.wd">pd.wd</code></td>
<td>
<p>folder path, where the bigmemmory file of the phylogenetic distance matrix are saved.</p>
</td></tr>
<tr><td><code id="bNRI.bin.big_+3A_pdid.bin">pdid.bin</code></td>
<td>
<p>list, each element is a vector of integer, indicating which rows/columns in the big phylogenetic matrix represent the taxa in a bin.</p>
</td></tr>
<tr><td><code id="bNRI.bin.big_+3A_sp.bin">sp.bin</code></td>
<td>
<p>one-column matrix, rownames are taxa IDs (i.e. OTU IDs), the only column shows the bin ID of each taxon. Bin IDs are integers in the same order as the elements in the list of pdid.bin.</p>
</td></tr>
<tr><td><code id="bNRI.bin.big_+3A_spname.check">spname.check</code></td>
<td>
<p>logic, whether to check the OTU ids (species names) in community matrix and phylogenetic distance matrix are the same.</p>
</td></tr>
<tr><td><code id="bNRI.bin.big_+3A_nworker">nworker</code></td>
<td>
<p>for parallel computing. Either a character vector of host names on which to run the worker copies of R, or a positive integer (in which case that number of copies is run on localhost). default is 4, means 4 threads will be run.</p>
</td></tr>
<tr><td><code id="bNRI.bin.big_+3A_memo.size.gb">memo.size.GB</code></td>
<td>
<p>numeric, to set the memory size as you need, so that calculation of large tree will not be limited by physical memory. unit is Gb. default is 50Gb.</p>
</td></tr>
<tr><td><code id="bNRI.bin.big_+3A_weighted">weighted</code></td>
<td>
<p>Logic, consider abundances or not (just presence/absence). default is TRUE.</p>
</td></tr>
<tr><td><code id="bNRI.bin.big_+3A_rand">rand</code></td>
<td>
<p>integer, randomization times. default is 1000.</p>
</td></tr>
<tr><td><code id="bNRI.bin.big_+3A_output.bmpd">output.bMPD</code></td>
<td>
<p>logic, if TRUE, the output will include beta mean pairwise distance (betaMPD).</p>
</td></tr>
<tr><td><code id="bNRI.bin.big_+3A_sig.index">sig.index</code></td>
<td>
<p>character, the index for null model significance test. SES or bNRI, standard effect size, i.e. beta net relatedness index (betaNRI); Confidence, percentage of null values less extreme than the observed value, i.e. non-parametric one-side confidence level; RC, modified Raup-Crick index (RC) based on betaMPD, i.e. count the number of null betaMPD lower than observed betaMPD plus a half of the number of null betaMPD equal to observed betaMPD, to get alpha, then calculate betaMPD-based RC as (2 x alpha - 1). default is SES. If input a vector, only the first element will be used.</p>
</td></tr>
<tr><td><code id="bNRI.bin.big_+3A_unit.sum">unit.sum</code></td>
<td>
<p>NULL or a number or a nemeric vector. When a beta diversity index is calculated for a bin, the taxa abundances will be divided by unit.sum to calculate the relative abundances. Usually, unit.sum can be set as the sequencing depth in each sample. Default setting is NULL, means not to do this transformation.</p>
</td></tr>
<tr><td><code id="bNRI.bin.big_+3A_correct.special">correct.special</code></td>
<td>
<p>logic, whether to correct the special cases. Default is FALSE.</p>
</td></tr>
<tr><td><code id="bNRI.bin.big_+3A_detail.null">detail.null</code></td>
<td>
<p>logic, if TRUE, the output will include all the null values. Default is FALSE.</p>
</td></tr>
<tr><td><code id="bNRI.bin.big_+3A_special.method">special.method</code></td>
<td>
<p>When correct.special is TRUE, which method will be used to check underestimation of deterministic pattern(s) in special cases. MPD, use null model test based on mean pairwise distance; MNTD, use null model test of mean nearest taxon distance; both, use null model test of both MPD and MNTD. Default is MPD.</p>
</td></tr>
<tr><td><code id="bNRI.bin.big_+3A_ses.cut">ses.cut</code></td>
<td>
<p>numeric, the cutoff of significant standard effect size, default is 1.96.</p>
</td></tr>
<tr><td><code id="bNRI.bin.big_+3A_rc.cut">rc.cut</code></td>
<td>
<p>numeric, the cutoff of significant modified Raup-Crick metric, default is 0.95.</p>
</td></tr>
<tr><td><code id="bNRI.bin.big_+3A_conf.cut">conf.cut</code></td>
<td>
<p>numeric, the cutoff of significant one-side confidence level, default is 0.975.</p>
</td></tr>
<tr><td><code id="bNRI.bin.big_+3A_dirichlet">dirichlet</code></td>
<td>
<p>Logic. If TRUE, the taxonomic null model for correcting special cases will use Dirichlet distribution to generate relative abundances in randomized community matrix. default is FALSE.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The beta net relatedness index (betaNRI; Webb et al. 2008, Stegen et al 2012) is calculated for each phylogenetic bin. betaNRI is a standardized measure of the mean pairwise distance between samples/communities (betaMPD). Parallel computing is used to improve the speed.
</p>
<p>The null model algorithm is &quot;taxa shuffle&quot; (Kembel 2009), i.e. shuffling taxa labels across the
tips of the phylogenetic tree to randomize phylogenetic relationships among species. In this function, taxa will be randomized across all bins.
</p>
<p>In the betaNRI of each bin, the diagonal are set as zero. If the randomized results are all the same, the standard deviation will be zero and betaNRI will be NAN. In this case, betaNRI will be set as zero, since the observed result is not differentiable from randomized results.
</p>
<p>Modified RC (Chase et al 2011) and Confidence (Ning et al 2020) are alternative significance test indexes to evaluate how the observed beta diversity index deviates from null expectation, which could be a better metric than standardized effect size (betaNRI) in some cases, e.g. null values do not follow normal distribution.
</p>


<h3>Value</h3>

<p>Output is a list with following elements:
</p>
<table>
<tr><td><code>index</code></td>
<td>
<p>list, each element is a square matrix of betaNRI (or RC or Confidence based on betaMPD) values of a bin. The elements (bins) are in the same order as in the input pdid.bin.</p>
</td></tr>
<tr><td><code>sig.index</code></td>
<td>
<p>character, indicates the index for null model significance test, SES (i.e. betaNRI), RC, or Confidence.</p>
</td></tr>
<tr><td><code>betaMPD.obs</code></td>
<td>
<p>Output only if output.bMPD is TRUE. A list, each element is a square matrix of observed beta MPD values of a bin. The elements (bins) are in the same order as in the input pdid.bin.</p>
</td></tr>
<tr><td><code>rand</code></td>
<td>
<p>Output only if detail.null is TRUE. A list, each element is a matrix with null values of beta MPD for each turnover of a bin. The elements (bins) are in the same order as in the input pdid.bin.</p>
</td></tr>
<tr><td><code>special.crct</code></td>
<td>
<p>Output only if detail.null is TRUE. NULL if correct.special is FALSE. A list with three elements, corresponding to three different null model significance testing indexes, i.e. SES, RC, and Confidence. Each element is a matrix, where the value is zero if the result for a turnover of a bin does not need to correct, otherwise there will be a corrected value.</p>
</td></tr>
</table>


<h3>Note</h3>

<p>Version 8: 2021.12.9, previous 'paste' led to error; corrected to 'paste0'.
Version 7: 2021.4.18, fix the bug when detail.null=TRUE and comm has only two samples.
Version 6: 2020.9.1, remove setwd. change dontrun to donttest and revise save.wd in help doc.
Version 5: 2020.8.18, update help document, add example.
Version 4: 2020.8.1, change RC opiton to sig.index, add detail.null and conf.cut.
Version 3: 2018.10.15, add unit.sum, correct.special.
Version 2: 2016.3.26, add RC option.
Version 1: 2015.12.16
</p>


<h3>Author(s)</h3>

<p>Daliang Ning
</p>


<h3>References</h3>

<p>Webb, C.O., Ackerly, D.D. &amp; Kembel, S.W. (2008). Phylocom: software for the analysis of phylogenetic community structure and trait evolution. Bioinformatics, 24, 2098-2100.
</p>
<p>Kembel, S.W. (2009). Disentangling niche and neutral influences on community assembly: assessing the performance of community phylogenetic structure tests. Ecol Lett, 12, 949-960.
</p>
<p>Stegen, J.C., Lin, X., Konopka, A.E. &amp; Fredrickson, J.K. (2012). Stochastic and deterministic assembly processes in subsurface microbial communities. Isme Journal, 6, 1653-1664.
</p>
<p>Chase, J.M., Kraft, N.J.B., Smith, K.G., Vellend, M. &amp; Inouye, B.D. (2011). Using null models to disentangle variation in community dissimilarity from variation in alpha-diversity. Ecosphere, 2, 1-11.
</p>
<p>Ning, D., Yuan, M., Wu, L., Zhang, Y., Guo, X., Zhou, X. et al. (2020). A quantitative framework reveals ecological drivers of grassland microbial community assembly in response to warming. Nature Communications, 11, 4717.
</p>
<p>Kane, M.J., Emerson, J., Weston, S. (2013). Scalable Strategies for Computing with Massive Data. Journal of Statistical Software, 55(14), 1-19. URL http://www.jstatsoft.org/v55/i14/.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+bNRIn.p">bNRIn.p</a></code>,<code><a href="#topic+bmpd">bmpd</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># this function is usually used in icamp.big when setting phylo.rand.scale="across",
# means randomization across all bins in phylogenetic null model.
data("example.data")
comm=example.data$comm
tree=example.data$tree
pdid.bin=example.data$pdid.bin
sp.bin=example.data$sp.bin

# since pdist.big need to save output to a certain folder,
# the following code is set as 'not test'.
# but you may test the example on your computer after change the path for 'save.wd'.


wd0=getwd()
save.wd=paste0(tempdir(),"/pdbig.bNRI.bin.big")
# you may change save.wd to the folder you want to save the pd.big output.
nworker=2 # parallel computing thread number
pd.big=pdist.big(tree = tree, wd=save.wd, nworker = nworker)
rand.time=20 # usually use 1000 for real data.

bNRIbins=bNRI.bin.big(comm=comm, pd.desc=pd.big$pd.file, pd.spname=pd.big$tip.label,
                      pd.wd=pd.big$pd.wd, pdid.bin=pdid.bin, sp.bin=sp.bin,
                      spname.check = FALSE, nworker = nworker, memo.size.GB = 50,
                      weighted = TRUE, rand = rand.time, output.bMPD = FALSE,
                      sig.index="SES",unit.sum = NULL, correct.special = TRUE,
                      detail.null=FALSE, special.method="MPD")
setwd(wd0)

</code></pre>

<hr>
<h2 id='bNRI.bin.cm'>
Calculate beta net relatedness index (betaNRI) for each phylogenetic bin under multiple metacommunities
</h2><span id='topic+bNRI.bin.cm'></span>

<h3>Description</h3>

<p>Perform null model test based on a phylogenetic beta diversity index, beta mean pairwise distance (betaMPD), in each bin; calculate beta net relatedness index (betaNRI. Webb et al 2008), or modified Raup-Crick metric, or confidence level based on the comparison between observed and null betaMPD in each bin. The package bigmemory (Kane et al 2013) is used to handle very large phylogenetic distance matrix. This function can deal with local communities under different metacommunities (regional pools).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bNRI.bin.cm(comm, meta.group = NULL, meta.spool = NULL,
            meta.frequency = NULL, meta.ab = NULL,
            pd.desc, pd.spname, pd.wd, pdid.bin, sp.bin,
            spname.check = FALSE, nworker = 4,
            memo.size.GB = 50, weighted = c(TRUE, FALSE),
            rand = 1000, output.bMPD = FALSE,
            sig.index = c("SES", "Confidence", "RC", "bNRI"),
            unit.sum = NULL, correct.special = FALSE,
            detail.null = FALSE, special.method = c("MPD", "MNTD", "both"),
            ses.cut = 1.96, rc.cut = 0.95,
            conf.cut = 0.975, dirichlet = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bNRI.bin.cm_+3A_comm">comm</code></td>
<td>
<p>matrix or data.frame, community data, each row is a sample or site, each colname is a species or OTU or gene, thus rownames should be sample IDs, colnames should be taxa IDs.</p>
</td></tr>
<tr><td><code id="bNRI.bin.cm_+3A_meta.group">meta.group</code></td>
<td>
<p>matrix or data.frame, a one-column (n x 1) matrix indicating which metacommunity each sample belongs to. rownames are sample IDs. first column is metacommunity names. Such that different samples can belong to different metacommunities. If input a n x m matrix, only the first column is used. NULL means all samples belong to the same metacommunity. Default is NULL, means all samples from the same metacommunity.</p>
</td></tr>
<tr><td><code id="bNRI.bin.cm_+3A_meta.spool">meta.spool</code></td>
<td>
<p>a list object, each element is a character vector listing all taxa IDs in a metacommunity. The names of the elements indicate metacommunity names, which should be the same as the metacommunity names in meta.group. Default is NULL, means to use the observed taxa in comm across samples within the same metacommunity that is defined by meta.group.</p>
</td></tr>
<tr><td><code id="bNRI.bin.cm_+3A_meta.frequency">meta.frequency</code></td>
<td>
<p>matrix or data.frame, each column represents a taxon, each row represents a metacommunity (regional pool), to define the occurrence frequency of each taxon in each metacommunity. The rownames indicate metacommunity names, which should be the same as the metacommunity names in meta.group. Default setting is NULL, means to calculate meta.frequency as occurrence frequency of each taxon in comm across the samples within each metacommunity defined by meta.group.</p>
</td></tr>
<tr><td><code id="bNRI.bin.cm_+3A_meta.ab">meta.ab</code></td>
<td>
<p>matrix or data.frame, each column represents a taxon, each row represents a metacommunity (regional pool), to define the aubndance (or relative abundance) of each taxon in each metacommunity. The rownames indicate metacommunity names, which should be the same as the metacommunity names in meta.group. Default setting is NULL, means to calculate meta.ab as average relative abundance of each taxon in comm across the samples within each metacommunity defined by meta.group.</p>
</td></tr>
<tr><td><code id="bNRI.bin.cm_+3A_pd.desc">pd.desc</code></td>
<td>
<p>the name of the file to hold the backingfile description of the phylogenetic distance matrix, it is usually &quot;pd.desc&quot; if using default setting in pdist.big function.</p>
</td></tr>
<tr><td><code id="bNRI.bin.cm_+3A_pd.spname">pd.spname</code></td>
<td>
<p>character vector, taxa id in the same rank as the big matrix of phylogenetic distances.</p>
</td></tr>
<tr><td><code id="bNRI.bin.cm_+3A_pd.wd">pd.wd</code></td>
<td>
<p>folder path, where the bigmemmory file of the phylogenetic distance matrix are saved.</p>
</td></tr>
<tr><td><code id="bNRI.bin.cm_+3A_pdid.bin">pdid.bin</code></td>
<td>
<p>list, each element is a vector of integer, indicating which rows/columns in the big phylogenetic matrix represent the taxa in a bin.</p>
</td></tr>
<tr><td><code id="bNRI.bin.cm_+3A_sp.bin">sp.bin</code></td>
<td>
<p>one-column matrix, rownames are taxa IDs (i.e. OTU IDs), the only column shows the bin ID of each taxon. Bin IDs are integers in the same order as the elements in the list of pdid.bin.</p>
</td></tr>
<tr><td><code id="bNRI.bin.cm_+3A_spname.check">spname.check</code></td>
<td>
<p>logic, whether to check the OTU ids (species names) in community matrix and phylogenetic distance matrix are the same.</p>
</td></tr>
<tr><td><code id="bNRI.bin.cm_+3A_nworker">nworker</code></td>
<td>
<p>for parallel computing. Either a character vector of host names on which to run the worker copies of R, or a positive integer (in which case that number of copies is run on localhost). default is 4, means 4 threads will be run.</p>
</td></tr>
<tr><td><code id="bNRI.bin.cm_+3A_memo.size.gb">memo.size.GB</code></td>
<td>
<p>numeric, to set the memory size as you need, so that calculation of large tree will not be limited by physical memory. unit is Gb. default is 50Gb.</p>
</td></tr>
<tr><td><code id="bNRI.bin.cm_+3A_weighted">weighted</code></td>
<td>
<p>Logic, consider abundances or not (just presence/absence). default is TRUE.</p>
</td></tr>
<tr><td><code id="bNRI.bin.cm_+3A_rand">rand</code></td>
<td>
<p>integer, randomization times. default is 1000.</p>
</td></tr>
<tr><td><code id="bNRI.bin.cm_+3A_output.bmpd">output.bMPD</code></td>
<td>
<p>logic, if TRUE, the output will include beta mean pairwise distance (betaMPD).</p>
</td></tr>
<tr><td><code id="bNRI.bin.cm_+3A_sig.index">sig.index</code></td>
<td>
<p>character, the index for null model significance test. SES or bNRI, standard effect size, i.e. beta net relatedness index (betaNRI); Confidence, percentage of null values less extreme than the observed value, i.e. non-parametric one-side confidence level; RC, modified Raup-Crick index (RC) based on betaMPD, i.e. count the number of null betaMPD lower than observed betaMPD plus a half of the number of null betaMPD equal to observed betaMPD, to get alpha, then calculate betaMPD-based RC as (2 x alpha - 1). default is SES. If input a vector, only the first element will be used.</p>
</td></tr>
<tr><td><code id="bNRI.bin.cm_+3A_unit.sum">unit.sum</code></td>
<td>
<p>NULL or a number or a nemeric vector. When a beta diversity index is calculated for a bin, the taxa abundances will be divided by unit.sum to calculate the relative abundances. Usually, unit.sum can be set as the sequencing depth in each sample. Default setting is NULL, means not to do this transformation.</p>
</td></tr>
<tr><td><code id="bNRI.bin.cm_+3A_correct.special">correct.special</code></td>
<td>
<p>logic, whether to correct the special cases. Default is FALSE.</p>
</td></tr>
<tr><td><code id="bNRI.bin.cm_+3A_detail.null">detail.null</code></td>
<td>
<p>logic, if TRUE, the output will include all the null values. Default is FALSE.</p>
</td></tr>
<tr><td><code id="bNRI.bin.cm_+3A_special.method">special.method</code></td>
<td>
<p>When correct.special is TRUE, which method will be used to check underestimation of deterministic pattern(s) in special cases. MPD, use null model test based on mean pairwise distance; MNTD, use null model test of mean nearest taxon distance; both, use null model test of both MPD and MNTD. Default is MPD.</p>
</td></tr>
<tr><td><code id="bNRI.bin.cm_+3A_ses.cut">ses.cut</code></td>
<td>
<p>numeric, the cutoff of significant standard effect size, default is 1.96.</p>
</td></tr>
<tr><td><code id="bNRI.bin.cm_+3A_rc.cut">rc.cut</code></td>
<td>
<p>numeric, the cutoff of significant modified Raup-Crick metric, default is 0.95.</p>
</td></tr>
<tr><td><code id="bNRI.bin.cm_+3A_conf.cut">conf.cut</code></td>
<td>
<p>numeric, the cutoff of significant one-side confidence level, default is 0.975.</p>
</td></tr>
<tr><td><code id="bNRI.bin.cm_+3A_dirichlet">dirichlet</code></td>
<td>
<p>Logic. If TRUE, the taxonomic null model for correcting special cases will use Dirichlet distribution to generate relative abundances in randomized community matrix. default is FALSE.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is particularly designed for samples from different metacommunities. The null model &quot;taxa shuffle&quot; will be done under different metacommunities, separately (and independently). All other details are the same as the function bNRI.bin.big. 
</p>


<h3>Value</h3>

<p>Output is a list with following elements:
</p>
<table>
<tr><td><code>index</code></td>
<td>
<p>list, each element is a square matrix of betaNRI (or RC or Confidence based on betaMPD) values of a bin. The elements (bins) are in the same order as in the input pdid.bin.</p>
</td></tr>
<tr><td><code>sig.index</code></td>
<td>
<p>character, indicates the index for null model significance test, SES (i.e. betaNRI), RC, or Confidence.</p>
</td></tr>
<tr><td><code>betaMPD.obs</code></td>
<td>
<p>Output only if output.bMPD is TRUE. A list, each element is a square matrix of observed beta MPD values of a bin. The elements (bins) are in the same order as in the input pdid.bin.</p>
</td></tr>
<tr><td><code>rand</code></td>
<td>
<p>Output only if detail.null is TRUE. A list, each element is a matrix with null values of beta MPD for each turnover of a bin. The elements (bins) are in the same order as in the input pdid.bin.</p>
</td></tr>
<tr><td><code>special.crct</code></td>
<td>
<p>Output only if detail.null is TRUE. NULL if correct.special is FALSE. A list with three elements, corresponding to three different null model significance testing indexes, i.e. SES, RC, and Confidence. Each element is a matrix, where the value is zero if the result for a turnover of a bin does not need to correct, otherwise there will be a corrected value.</p>
</td></tr>
</table>


<h3>Note</h3>

<p>Version 2: 2021.12.9, previous 'paste' led to error; corrected to 'paste0'.
Version 1: 2021.8.4
</p>


<h3>Author(s)</h3>

<p>Daliang Ning
</p>


<h3>References</h3>

<p>Webb, C.O., Ackerly, D.D. &amp; Kembel, S.W. (2008). Phylocom: software for the analysis of phylogenetic community structure and trait evolution. Bioinformatics, 24, 2098-2100.
</p>
<p>Kembel, S.W. (2009). Disentangling niche and neutral influences on community assembly: assessing the performance of community phylogenetic structure tests. Ecol Lett, 12, 949-960.
</p>
<p>Stegen, J.C., Lin, X., Konopka, A.E. &amp; Fredrickson, J.K. (2012). Stochastic and deterministic assembly processes in subsurface microbial communities. Isme Journal, 6, 1653-1664.
</p>
<p>Chase, J.M., Kraft, N.J.B., Smith, K.G., Vellend, M. &amp; Inouye, B.D. (2011). Using null models to disentangle variation in community dissimilarity from variation in alpha-diversity. Ecosphere, 2, 1-11.
</p>
<p>Ning, D., Yuan, M., Wu, L., Zhang, Y., Guo, X., Zhou, X. et al. (2020). A quantitative framework reveals ecological drivers of grassland microbial community assembly in response to warming. Nature Communications, 11, 4717.
</p>
<p>Kane, M.J., Emerson, J., Weston, S. (2013). Scalable Strategies for Computing with Massive Data. Journal of Statistical Software, 55(14), 1-19. URL http://www.jstatsoft.org/v55/i14/.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+bNRI.bin.big">bNRI.bin.big</a></code>, <code><a href="#topic+icamp.cm">icamp.cm</a></code>, <code><a href="#topic+bNRI.cm">bNRI.cm</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># this function is usually used in icamp.cm when setting phylo.rand.scale="across",
# means randomization across all bins in phylogenetic null model.
data("example.data")
comm=example.data$comm
tree=example.data$tree
pdid.bin=example.data$pdid.bin
sp.bin=example.data$sp.bin

# the other 10 samples from another metacommunity.
meta.group=data.frame(meta.com=c(rep("meta1",10),rep("meta2",10)))
rownames(meta.group)=rownames(comm)

# since pdist.big need to save output to a certain folder,
# the following code is set as 'not test'.
# but you may test the example on your computer after change the path for 'save.wd'.

wd0=getwd()
save.wd=paste0(tempdir(),"/pdbig.bNRI.bin.cm")
# you may change save.wd to the folder you want to save the pd.big output.
nworker=2 # parallel computing thread number
pd.big=pdist.big(tree = tree, wd=save.wd, nworker = nworker)
rand.time=20 # usually use 1000 for real data.

bNRIbins=bNRI.bin.cm(comm=comm, meta.group=meta.group,
                     pd.desc=pd.big$pd.file, pd.spname=pd.big$tip.label,
                     pd.wd=pd.big$pd.wd, pdid.bin=pdid.bin, sp.bin=sp.bin,
                     spname.check = FALSE, nworker = nworker, memo.size.GB = 50,
                     weighted = TRUE, rand = rand.time, output.bMPD = FALSE,
                     sig.index="SES",unit.sum = NULL, correct.special = TRUE,
                     detail.null=FALSE, special.method="MPD")

setwd(wd0)

</code></pre>

<hr>
<h2 id='bNRI.cm'>
Calculate beta net relatedness index with parallel computing under multiple metacommunities
</h2><span id='topic+bNRI.cm'></span>

<h3>Description</h3>

<p>Perform null model test based on a phylogenetic beta diversity index, beta mean pairwise distance (betaMPD); calculate beta net relatedness index (betaNRI), or modified Raup-Crick metric, or confidence level based on the comparison between observed and null betaMPD. Run by parallel computing. This function can deal with local communities under different metacommunities (regional pools).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bNRI.cm(comm, dis, nworker = 4, memo.size.GB = 50,
        meta.group = NULL, meta.spool = NULL,
        meta.frequency = NULL, meta.ab = NULL,
        weighted = c(TRUE, FALSE), rand = 1000,
        output.bMPD = c(FALSE, TRUE),
        sig.index = c("SES", "Confidence", "RC", "bNRI"),
        unit.sum = NULL, correct.special = FALSE,
        detail.null = FALSE, special.method = c("MPD", "MNTD", "both"),
        ses.cut = 1.96, rc.cut = 0.95, conf.cut = 0.975,
        dirichlet = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bNRI.cm_+3A_comm">comm</code></td>
<td>
<p>matrix or data.frame, community data, each row is a sample or site, each colname is a species or OTU or gene, thus rownames should be sample IDs, colnames should be taxa IDs.</p>
</td></tr>
<tr><td><code id="bNRI.cm_+3A_dis">dis</code></td>
<td>
<p>matrix, pairwise phylogenetic distance matrix.</p>
</td></tr>
<tr><td><code id="bNRI.cm_+3A_nworker">nworker</code></td>
<td>
<p>integer, for parallel computing. Either a character vector of host names on which to run the worker copies of R, or a positive integer (in which case that number of copies is run on localhost). default is 4, means 4 threads will be run.</p>
</td></tr>
<tr><td><code id="bNRI.cm_+3A_memo.size.gb">memo.size.GB</code></td>
<td>
<p>numeric, to set the memory size as you need, so that calculation of large tree will not be limited by physical memory. unit is Gb. default is 50Gb.</p>
</td></tr>
<tr><td><code id="bNRI.cm_+3A_meta.group">meta.group</code></td>
<td>
<p>matrix or data.frame, a one-column (n x 1) matrix indicating which metacommunity each sample belongs to. rownames are sample IDs. first column is metacommunity names. Such that different samples can belong to different metacommunities. If input a n x m matrix, only the first column is used. NULL means all samples belong to the same metacommunity. Default is NULL, means all samples from the same metacommunity.</p>
</td></tr>
<tr><td><code id="bNRI.cm_+3A_meta.spool">meta.spool</code></td>
<td>
<p>a list object, each element is a character vector listing all taxa IDs in a metacommunity. The names of the elements indicate metacommunity names, which should be the same as the metacommunity names in meta.group. Default is NULL, means to use the observed taxa in comm across samples within the same metacommunity that is defined by meta.group.</p>
</td></tr>
<tr><td><code id="bNRI.cm_+3A_meta.frequency">meta.frequency</code></td>
<td>
<p>matrix or data.frame, each column represents a taxon, each row represents a metacommunity (regional pool), to define the occurrence frequency of each taxon in each metacommunity. The rownames indicate metacommunity names, which should be the same as the metacommunity names in meta.group. Default setting is NULL, means to calculate meta.frequency as occurrence frequency of each taxon in comm across the samples within each metacommunity defined by meta.group.</p>
</td></tr>
<tr><td><code id="bNRI.cm_+3A_meta.ab">meta.ab</code></td>
<td>
<p>matrix or data.frame, each column represents a taxon, each row represents a metacommunity (regional pool), to define the aubndance (or relative abundance) of each taxon in each metacommunity. The rownames indicate metacommunity names, which should be the same as the metacommunity names in meta.group. Default setting is NULL, means to calculate meta.ab as average relative abundance of each taxon in comm across the samples within each metacommunity defined by meta.group.</p>
</td></tr>
<tr><td><code id="bNRI.cm_+3A_weighted">weighted</code></td>
<td>
<p>logic, whether to use abundance-weighted or unweighted metrics. Default is TRUE.</p>
</td></tr>
<tr><td><code id="bNRI.cm_+3A_rand">rand</code></td>
<td>
<p>integer, randomization times. default is 1000.</p>
</td></tr>
<tr><td><code id="bNRI.cm_+3A_output.bmpd">output.bMPD</code></td>
<td>
<p>logic, if TRUE, the output will include beta mean pairwise distance (betaMPD).</p>
</td></tr>
<tr><td><code id="bNRI.cm_+3A_sig.index">sig.index</code></td>
<td>
<p>character, the index for null model significance test. SES or bNRI, standard effect size, i.e. beta net relatedness index (betaNRI); Confidence, percentage of null values less extreme than the observed value, i.e. non-parametric one-side confidence level; RC, modified Raup-Crick index (RC) based on betaMPD, i.e. count the number of null betaMPD lower than observed betaMPD plus a half of the number of null betaMPD equal to observed betaMPD, to get alpha, then calculate betaMPD-based RC as (2 x alpha - 1). default is SES. If input a vector, only the first element will be used.</p>
</td></tr>
<tr><td><code id="bNRI.cm_+3A_unit.sum">unit.sum</code></td>
<td>
<p>NULL or a number or a nemeric vector. When a beta diversity index is calculated for a bin, the taxa abundances will be divided by unit.sum to calculate the relative abundances. Usually, unit.sum can be set as the sequencing depth in each sample. Default setting is NULL, means not to do this transformation.</p>
</td></tr>
<tr><td><code id="bNRI.cm_+3A_correct.special">correct.special</code></td>
<td>
<p>logic, whether to correct the special cases. Default is FALSE.</p>
</td></tr>
<tr><td><code id="bNRI.cm_+3A_detail.null">detail.null</code></td>
<td>
<p>logic, if TRUE, the output will include all the null values. Default is FALSE.</p>
</td></tr>
<tr><td><code id="bNRI.cm_+3A_special.method">special.method</code></td>
<td>
<p>When correct.special is TRUE, which method will be used to check underestimation of deterministic pattern(s) in special cases. MPD, use null model test based on mean pairwise distance; MNTD, use null model test of mean nearest taxon distance; both, use null model test of both MPD and MNTD. Default is MPD.</p>
</td></tr>
<tr><td><code id="bNRI.cm_+3A_ses.cut">ses.cut</code></td>
<td>
<p>numeric, the cutoff of significant standard effect size, default is 1.96.</p>
</td></tr>
<tr><td><code id="bNRI.cm_+3A_rc.cut">rc.cut</code></td>
<td>
<p>numeric, the cutoff of significant modified Raup-Crick metric, default is 0.95.</p>
</td></tr>
<tr><td><code id="bNRI.cm_+3A_conf.cut">conf.cut</code></td>
<td>
<p>numeric, the cutoff of significant one-side confidence level, default is 0.975.</p>
</td></tr>
<tr><td><code id="bNRI.cm_+3A_dirichlet">dirichlet</code></td>
<td>
<p>Logic. If TRUE, the taxonomic null model for correcting special cases will use Dirichlet distribution to generate relative abundances in randomized community matrix. default is FALSE.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is particularly designed for samples from different metacommunities. The null model &quot;taxa shuffle&quot; will be done under different metacommunities, separately (and independently). All other details are the same as the function bNRIn.p. 
</p>


<h3>Value</h3>

<p>Output is a list with following elements:
</p>
<table>
<tr><td><code>index</code></td>
<td>
<p>a square matrix of betaNRI (or RC or Confidence based on betaMPD) values.</p>
</td></tr>
<tr><td><code>sig.index</code></td>
<td>
<p>character, indicates the index for null model significance test, SES (i.e. betaNRI), RC, or Confidence.</p>
</td></tr>
<tr><td><code>betaMPD.obs</code></td>
<td>
<p>Output only if output.bMPD is TRUE. A square matrix of observed beta MPD values.</p>
</td></tr>
<tr><td><code>rand</code></td>
<td>
<p>Output only if detail.null is TRUE. A matrix with null values of beta MPD for each turnover.</p>
</td></tr>
<tr><td><code>special.crct</code></td>
<td>
<p>Output only if detail.null is TRUE. it will be NULL if correct.special is FALSE. Otherwise, it will be a list with three elements, corresponding to three different null model significance testing indexes, i.e. SES, RC, and Confidence. Each element is a square matrix, where the value is zero if the result for a turnover does not need to correct, otherwise there will be a corrected value.</p>
</td></tr>
</table>


<h3>Note</h3>

<p>Version 1: 2021.8.4
</p>


<h3>Author(s)</h3>

<p>Daliang Ning
</p>


<h3>References</h3>

<p>Webb, C.O., Ackerly, D.D. &amp; Kembel, S.W. (2008). Phylocom: software for the analysis of phylogenetic community structure and trait evolution. Bioinformatics, 24, 2098-2100.
</p>
<p>Kembel, S.W. (2009). Disentangling niche and neutral influences on community assembly: assessing the performance of community phylogenetic structure tests. Ecol Lett, 12, 949-960.
</p>
<p>Stegen, J.C., Lin, X., Konopka, A.E. &amp; Fredrickson, J.K. (2012). Stochastic and deterministic assembly processes in subsurface microbial communities. Isme Journal, 6, 1653-1664.
</p>
<p>Chase, J.M., Kraft, N.J.B., Smith, K.G., Vellend, M. &amp; Inouye, B.D. (2011). Using null models to disentangle variation in community dissimilarity from variation in alpha-diversity. Ecosphere, 2, 1-11.
</p>
<p>Ning, D., Yuan, M., Wu, L., Zhang, Y., Guo, X., Zhou, X. et al. (2020). A quantitative framework reveals ecological drivers of grassland microbial community assembly in response to warming. Nature Communications, 11, 4717.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+bNRIn.p">bNRIn.p</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("example.data")
comm=example.data$comm
pd=example.data$pd

# in this example, 10 samples from one metacommunity,
# the other 10 samples from another metacommunity.
meta.group=data.frame(meta.com=c(rep("meta1",10),rep("meta2",10)))
rownames(meta.group)=rownames(comm)

nworker=2 # parallel computing thread number
rand.time=4 # usually use 1000 for real data.
bNRI=bNRI.cm(comm=comm, meta.group=meta.group,
             dis=pd, nworker = nworker, memo.size.GB = 50,
             weighted = TRUE, rand = rand.time, output.bMPD = FALSE, 
             sig.index = "SES", unit.sum = NULL, correct.special = TRUE,
             detail.null = FALSE, special.method = "MPD")
</code></pre>

<hr>
<h2 id='bNRIn.p'>
Calculate beta net relatedness index with parallel computing
</h2><span id='topic+bNRIn.p'></span>

<h3>Description</h3>

<p>Perform null model test based on a phylogenetic beta diversity index, beta mean pairwise distance (betaMPD); calculate beta net relatedness index (betaNRI), or modified Raup-Crick metric, or confidence level based on the comparison between observed and null betaMPD. Run by parallel computing.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bNRIn.p(comm, dis, nworker = 4, memo.size.GB = 50,
        weighted = c(TRUE, FALSE), rand = 1000, output.bMPD = c(FALSE, TRUE), 
        sig.index = c("SES", "Confidence", "RC", "bNRI"),
        unit.sum = NULL, correct.special = FALSE, detail.null = FALSE,
        special.method = c("MPD", "MNTD", "both"),
        ses.cut = 1.96, rc.cut = 0.95, conf.cut = 0.975,
        dirichlet = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bNRIn.p_+3A_comm">comm</code></td>
<td>
<p>matrix or data.frame, community data, each row is a sample or site, each colname is a species or OTU or gene, thus rownames should be sample IDs, colnames should be taxa IDs.</p>
</td></tr>
<tr><td><code id="bNRIn.p_+3A_dis">dis</code></td>
<td>
<p>matrix, pairwise phylogenetic distance matrix.</p>
</td></tr>
<tr><td><code id="bNRIn.p_+3A_nworker">nworker</code></td>
<td>
<p>integer, for parallel computing. Either a character vector of host names on which to run the worker copies of R, or a positive integer (in which case that number of copies is run on localhost). default is 4, means 4 threads will be run.</p>
</td></tr>
<tr><td><code id="bNRIn.p_+3A_memo.size.gb">memo.size.GB</code></td>
<td>
<p>numeric, to set the memory size as you need, so that calculation of large tree will not be limited by physical memory. unit is Gb. default is 50Gb.</p>
</td></tr>
<tr><td><code id="bNRIn.p_+3A_weighted">weighted</code></td>
<td>
<p>logic, whether to use abundance-weighted or unweighted metrics. Default is TRUE.</p>
</td></tr>
<tr><td><code id="bNRIn.p_+3A_rand">rand</code></td>
<td>
<p>integer, randomization times. default is 1000.</p>
</td></tr>
<tr><td><code id="bNRIn.p_+3A_output.bmpd">output.bMPD</code></td>
<td>
<p>logic, if TRUE, the output will include beta mean pairwise distance (betaMPD).</p>
</td></tr>
<tr><td><code id="bNRIn.p_+3A_sig.index">sig.index</code></td>
<td>
<p>character, the index for null model significance test. SES or bNRI, standard effect size, i.e. beta net relatedness index (betaNRI); Confidence, percentage of null values less extreme than the observed value, i.e. non-parametric one-side confidence level; RC, modified Raup-Crick index (RC) based on betaMPD, i.e. count the number of null betaMPD lower than observed betaMPD plus a half of the number of null betaMPD equal to observed betaMPD, to get alpha, then calculate betaMPD-based RC as (2 x alpha - 1). default is SES. If input a vector, only the first element will be used.</p>
</td></tr>
<tr><td><code id="bNRIn.p_+3A_unit.sum">unit.sum</code></td>
<td>
<p>NULL or a number or a nemeric vector. When a beta diversity index is calculated for a bin, the taxa abundances will be divided by unit.sum to calculate the relative abundances. Usually, unit.sum can be set as the sequencing depth in each sample. Default setting is NULL, means not to do this transformation.</p>
</td></tr>
<tr><td><code id="bNRIn.p_+3A_correct.special">correct.special</code></td>
<td>
<p>logic, whether to correct the special cases. Default is FALSE.</p>
</td></tr>
<tr><td><code id="bNRIn.p_+3A_detail.null">detail.null</code></td>
<td>
<p>logic, if TRUE, the output will include all the null values. Default is FALSE.</p>
</td></tr>
<tr><td><code id="bNRIn.p_+3A_special.method">special.method</code></td>
<td>
<p>When correct.special is TRUE, which method will be used to check underestimation of deterministic pattern(s) in special cases. MPD, use null model test based on mean pairwise distance; MNTD, use null model test of mean nearest taxon distance; both, use null model test of both MPD and MNTD. Default is MPD.</p>
</td></tr>
<tr><td><code id="bNRIn.p_+3A_ses.cut">ses.cut</code></td>
<td>
<p>numeric, the cutoff of significant standard effect size, default is 1.96.</p>
</td></tr>
<tr><td><code id="bNRIn.p_+3A_rc.cut">rc.cut</code></td>
<td>
<p>numeric, the cutoff of significant modified Raup-Crick metric, default is 0.95.</p>
</td></tr>
<tr><td><code id="bNRIn.p_+3A_conf.cut">conf.cut</code></td>
<td>
<p>numeric, the cutoff of significant one-side confidence level, default is 0.975.</p>
</td></tr>
<tr><td><code id="bNRIn.p_+3A_dirichlet">dirichlet</code></td>
<td>
<p>Logic. If TRUE, the taxonomic null model for correcting special cases will use Dirichlet distribution to generate relative abundances in randomized community matrix. default is FALSE.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The beta net relatedness index (betaNRI; Webb et al. 2008, Stegen et al. 2012) is a standardized measure of the mean pairwise distance between samples/communities (betaMPD). Parallel computing is used to improve the speed.
</p>
<p>The null model algorithm is &quot;taxa shuffle&quot; (Kembel 2009), i.e. shuffling taxa labels across the
tips of the phylogenetic tree to randomize phylogenetic relationships among species.
</p>
<p>In the output of beta NRI, the diagonal are set as zero. If the randomized results are all the same, the standard deviation will be zero and betaNRI will be NAN. In this case, beta NRI will be set as zero, since the observed result is not differentiable from randomized results.
</p>
<p>Modified RC (Chase et al 2011) and Confidence (Ning et al 2020) are alternative significance test indexes to evaluate how the observed beta diversity index deviates from null expectation, which could be a better metric than standardized effect size (betaNRI) in some cases, e.g. null values do not follow normal distribution.
</p>


<h3>Value</h3>

<p>Output is a list with following elements:
</p>
<table>
<tr><td><code>index</code></td>
<td>
<p>a square matrix of betaNRI (or RC or Confidence based on betaMPD) values.</p>
</td></tr>
<tr><td><code>sig.index</code></td>
<td>
<p>character, indicates the index for null model significance test, SES (i.e. betaNRI), RC, or Confidence.</p>
</td></tr>
<tr><td><code>betaMPD.obs</code></td>
<td>
<p>Output only if output.bMPD is TRUE. A square matrix of observed beta MPD values.</p>
</td></tr>
<tr><td><code>rand</code></td>
<td>
<p>Output only if detail.null is TRUE. A matrix with null values of beta MPD for each turnover.</p>
</td></tr>
<tr><td><code>special.crct</code></td>
<td>
<p>Output only if detail.null is TRUE. it will be NULL if correct.special is FALSE. Otherwise, it will be a list with three elements, corresponding to three different null model significance testing indexes, i.e. SES, RC, and Confidence. Each element is a square matrix, where the value is zero if the result for a turnover does not need to correct, otherwise there will be a corrected value.</p>
</td></tr>
</table>


<h3>Note</h3>

<p>Version 5: 2021.4.18, fix the bug when detail.null=TRUE and comm has only two samples.
Version 4: 2020.8.18, update help document, add example.
Version 3: 2020.8.1, change RC opiton to sig.index, add detail.null and conf.cut. 
Version 2: 2018.10.3, correct special cases
Version 1: 2016.3.26.
</p>


<h3>Author(s)</h3>

<p>Daliang Ning
</p>


<h3>References</h3>

<p>Webb, C.O., Ackerly, D.D. &amp; Kembel, S.W. (2008). Phylocom: software for the analysis of phylogenetic community structure and trait evolution. Bioinformatics, 24, 2098-2100.
</p>
<p>Kembel, S.W. (2009). Disentangling niche and neutral influences on community assembly: assessing the performance of community phylogenetic structure tests. Ecol Lett, 12, 949-960.
</p>
<p>Stegen, J.C., Lin, X., Konopka, A.E. &amp; Fredrickson, J.K. (2012). Stochastic and deterministic assembly processes in subsurface microbial communities. Isme Journal, 6, 1653-1664.
</p>
<p>Chase, J.M., Kraft, N.J.B., Smith, K.G., Vellend, M. &amp; Inouye, B.D. (2011). Using null models to disentangle variation in community dissimilarity from variation in alpha-diversity. Ecosphere, 2, 1-11.
</p>
<p>Ning, D., Yuan, M., Wu, L., Zhang, Y., Guo, X., Zhou, X. et al. (2020). A quantitative framework reveals ecological drivers of grassland microbial community assembly in response to warming. Nature Communications, 11, 4717.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+bmpd">bmpd</a></code>, <code><a href="#topic+bNRI.cm">bNRI.cm</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("example.data")
comm=example.data$comm
pd=example.data$pd
nworker=2 # parallel computing thread number
rand.time=4 # usually use 1000 for real data.
bNRI=bNRIn.p(comm=comm, dis=pd, nworker = nworker, memo.size.GB = 50,
             weighted = TRUE, rand = rand.time, output.bMPD = FALSE, 
             sig.index = "SES", unit.sum = NULL, correct.special = TRUE,
             detail.null = FALSE, special.method = "MPD")
</code></pre>

<hr>
<h2 id='bNTI.big'>
Beta nearest taxon index (betaNTI) from big data
</h2><span id='topic+bNTI.big'></span>

<h3>Description</h3>

<p>To calculate pairwise beta nearest taxon index (betaNTI) by randomizing in the whole species pool or within each group. Package bigmemory (Kane et al 2013) is used to deal with large datasets.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bNTI.big(comm, meta.group=NULL, pd.desc="pd.desc",
         pd.spname,pd.wd, spname.check=TRUE,
         nworker=4, memo.size.GB=50, weighted=TRUE,
         exclude.consp=FALSE,rand=1000,output.dtail=FALSE,
         RC=FALSE, trace=TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bNTI.big_+3A_comm">comm</code></td>
<td>
<p>matrix or data.frame, community data, each row is a sample or site, each colname is a species or OTU or gene, thus rownames should be sample IDs, colnames should be taxa IDs.</p>
</td></tr>
<tr><td><code id="bNTI.big_+3A_meta.group">meta.group</code></td>
<td>
<p>matrix or data.frame, a one-column (n x 1) matrix indicating which metacommunity each sample belongs to. rownames are sample IDs. first column is metacommunity IDs. Such that different samples can belong to different metacommunities. If input a n x m matrix, only the first column is used. NULL means all samples belong to the same metacommunity. Default is NULL, means all samples are under the same metacommunity (the same regional species pool).</p>
</td></tr>
<tr><td><code id="bNTI.big_+3A_pd.desc">pd.desc</code></td>
<td>
<p>the name of the file to hold the backingfile description of the phylogenetic distance matrix, it is usually &quot;pd.desc&quot; if using default setting in pdist.big function.</p>
</td></tr>
<tr><td><code id="bNTI.big_+3A_pd.spname">pd.spname</code></td>
<td>
<p>character vector, taxa id in the same rank as the big matrix of phylogenetic distances.</p>
</td></tr>
<tr><td><code id="bNTI.big_+3A_pd.wd">pd.wd</code></td>
<td>
<p>folder path, where the bigmemmory file of the phylogenetic distance matrix are saved.</p>
</td></tr>
<tr><td><code id="bNTI.big_+3A_spname.check">spname.check</code></td>
<td>
<p>logic, whether to check the OTU ids (species names) in community matrix and phylogenetic distance matrix are the same.</p>
</td></tr>
<tr><td><code id="bNTI.big_+3A_nworker">nworker</code></td>
<td>
<p>for parallel computing. Either a character vector of host names on which to run the worker copies of R, or a positive integer (in which case that number of copies is run on localhost). default is 4, means 4 threads will be run.</p>
</td></tr>
<tr><td><code id="bNTI.big_+3A_memo.size.gb">memo.size.GB</code></td>
<td>
<p>numeric, to set the memory size as you need, so that calculation of large tree will not be limited by physical memory. unit is Gb. default is 50Gb.</p>
</td></tr>
<tr><td><code id="bNTI.big_+3A_weighted">weighted</code></td>
<td>
<p>Logic, consider abundances or not (just presence/absence). default is TRUE.</p>
</td></tr>
<tr><td><code id="bNTI.big_+3A_exclude.consp">exclude.consp</code></td>
<td>
<p>Logic, should conspecific taxa in different communities be exclude from MNTD calculations? default is FALSE. The same as in the function bmntd.</p>
</td></tr>
<tr><td><code id="bNTI.big_+3A_rand">rand</code></td>
<td>
<p>integer, randomization times. default is 1000.</p>
</td></tr>
<tr><td><code id="bNTI.big_+3A_output.dtail">output.dtail</code></td>
<td>
<p>logic, if TRUE, the betaNTI, RC value, observed betaMNTD, all null betaMNTD values will all be output, if FALSE, only output betaNTI or RC.</p>
</td></tr>
<tr><td><code id="bNTI.big_+3A_rc">RC</code></td>
<td>
<p>logic, whether to use modified RC merics to evaluate significance of betaMNTD insteal of betaNTI (standardized effect size).</p>
</td></tr>
<tr><td><code id="bNTI.big_+3A_trace">trace</code></td>
<td>
<p>logic, whether to show the progress when the code is running.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The beta nearest taxon index (betaNTI) is a standardized measure of the mean phylogenetic distance to the nearest taxon between samples/communities (betaMNTD) and quantifies the extent of terminal clustering, independent of deep level clustering. There are a lot of null models for randomization, but this function only use phylogeny shuffle (the same as taxa.labels in ses.mntd).
</p>
<p>In the output of betaNTI, the diagonal are set as zero. If the randomized results are all the same, the standard deviation will be zero and betaNTI will be NAN. In this case, beta NTI will be set as zero, since the observed result is not differentiable from randomized results. If the observed betaMNTD has NA values, the corresponding betaNTI will remain NA. Modified RC (Chase 2010) is another metric to evaluate how the observed betaMNTD deviates from null expectation, which could be a better metric than standardized effect size (classic betaNTI) in some cases.
</p>


<h3>Value</h3>

<p>If output.detail=FALSE (default), a matrix of betaNTI values (if RC=FALSE) or RC values (if RC=TRUE) is returned. If output.detail=TRUE, a list is returned.
</p>
<table>
<tr><td><code>bNTI</code></td>
<td>
<p>a matrix of pairwise betaNTI values.</p>
</td></tr>
<tr><td><code>RC.bMNTD</code></td>
<td>
<p>a matrix of RC values based on null model test of betaMNTD. Ouput when RC=TRUE.</p>
</td></tr>
<tr><td><code>bMNTD</code></td>
<td>
<p>observed betaMNTD values.</p>
</td></tr>
<tr><td><code>bMNTD.rand</code></td>
<td>
<p>a matrix of all null results.</p>
</td></tr>
</table>


<h3>Note</h3>

<p>Version 2: 2020.12.5, included into iCAMP package to improve the function qpen.
Version 1: 2017.7.12
</p>


<h3>Author(s)</h3>

<p>Daliang Ning</p>


<h3>References</h3>

<p>Webb, C.O., Ackerly, D.D. &amp; Kembel, S.W. (2008). Phylocom: software for the analysis of phylogenetic community structure and trait evolution. Bioinformatics, 24, 2098-2100.
</p>
<p>Kembel, S.W. (2009). Disentangling niche and neutral influences on community assembly: assessing the performance of community phylogenetic structure tests. Ecol Lett, 12, 949-960.
</p>
<p>Stegen, J.C., Lin, X., Konopka, A.E. &amp; Fredrickson, J.K. (2012). Stochastic and deterministic assembly processes in subsurface microbial communities. Isme Journal, 6, 1653-1664.
</p>
<p>Chase, J.M., Kraft, N.J.B., Smith, K.G., Vellend, M. &amp; Inouye, B.D. (2011). Using null models to disentangle variation in community dissimilarity from variation in alpha-diversity. Ecosphere, 2, 1-11.
</p>
<p>Kane, M.J., Emerson, J., Weston, S. (2013). Scalable Strategies for Computing with Massive Data. Journal of Statistical Software, 55(14), 1-19. URL http://www.jstatsoft.org/v55/i14/.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+bmntd.big">bmntd.big</a></code>,<a href="#topic+qpen">qpen</a></p>


<h3>Examples</h3>

<pre><code class='language-R'>data("example.data")
comm=example.data$comm
tree=example.data$tree

# since pdist.big need to save output to a certain folder,
# the following code is set as 'not test'.
# but you may test the code on your computer after change the path for 'save.wd'.

wd0=getwd()
save.wd=paste0(tempdir(),"/pdbig.bNTI.big")
# you may change save.wd to the folder you want to save the pd.big output.
nworker=2 # parallel computing thread number
pd.big=pdist.big(tree = tree, wd=save.wd, nworker = nworker)

rand.time=20 # usually use 1000 for real data.
bNTI=bNTI.big(comm=comm, pd.desc=pd.big$pd.file,
              pd.spname=pd.big$tip.label,pd.wd=pd.big$pd.wd,
              spname.check=TRUE, nworker=nworker, memo.size.GB=50,
              weighted=TRUE, exclude.consp=FALSE,rand=rand.time,
              output.dtail=FALSE, RC=FALSE, trace=TRUE)
setwd(wd0)

</code></pre>

<hr>
<h2 id='bNTI.big.cm'>
Beta nearest taxon index (betaNTI) from big data and under multiple metacommunities
</h2><span id='topic+bNTI.big.cm'></span>

<h3>Description</h3>

<p>To calculate pairwise beta nearest taxon index (betaNTI) by randomizing in the whole species pool or within each group. Package bigmemory (Kane et al 2013) is used to deal with large datasets. Besides, this function can deal with local communities under different metacommunities (regional pools).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bNTI.big.cm(comm, meta.group = NULL, meta.spool = NULL,
            pd.desc = "pd.desc", pd.spname, pd.wd,
            spname.check = TRUE, nworker = 4,
            memo.size.GB = 50, weighted = TRUE,
            exclude.consp = FALSE, rand = 1000,
            output.dtail = FALSE, RC = FALSE, trace = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bNTI.big.cm_+3A_comm">comm</code></td>
<td>
<p>matrix or data.frame, community data, each row is a sample or site, each colname is a species or OTU or gene, thus rownames should be sample IDs, colnames should be taxa IDs.</p>
</td></tr>
<tr><td><code id="bNTI.big.cm_+3A_meta.group">meta.group</code></td>
<td>
<p>matrix or data.frame, a one-column (n x 1) matrix indicating which metacommunity each sample belongs to. rownames are sample IDs. first column is metacommunity IDs. Such that different samples can belong to different metacommunities. If input a n x m matrix, only the first column is used. NULL means all samples belong to the same metacommunity. Default is NULL, means all samples are under the same metacommunity (the same regional species pool).</p>
</td></tr>
<tr><td><code id="bNTI.big.cm_+3A_meta.spool">meta.spool</code></td>
<td>
<p>a list object, each element is a character vector listing all taxa IDs in a metacommunity. The names of the elements indicate metacommunity names, which should be the same as the metacommunity names in meta.group. Default is NULL, means to use the observed taxa in comm across samples within the same metacommunity that is defined by meta.group.</p>
</td></tr>
<tr><td><code id="bNTI.big.cm_+3A_pd.desc">pd.desc</code></td>
<td>
<p>the name of the file to hold the backingfile description of the phylogenetic distance matrix, it is usually &quot;pd.desc&quot; if using default setting in pdist.big function.</p>
</td></tr>
<tr><td><code id="bNTI.big.cm_+3A_pd.spname">pd.spname</code></td>
<td>
<p>character vector, taxa id in the same rank as the big matrix of phylogenetic distances.</p>
</td></tr>
<tr><td><code id="bNTI.big.cm_+3A_pd.wd">pd.wd</code></td>
<td>
<p>folder path, where the bigmemmory file of the phylogenetic distance matrix are saved.</p>
</td></tr>
<tr><td><code id="bNTI.big.cm_+3A_spname.check">spname.check</code></td>
<td>
<p>logic, whether to check the OTU ids (species names) in community matrix and phylogenetic distance matrix are the same.</p>
</td></tr>
<tr><td><code id="bNTI.big.cm_+3A_nworker">nworker</code></td>
<td>
<p>for parallel computing. Either a character vector of host names on which to run the worker copies of R, or a positive integer (in which case that number of copies is run on localhost). default is 4, means 4 threads will be run.</p>
</td></tr>
<tr><td><code id="bNTI.big.cm_+3A_memo.size.gb">memo.size.GB</code></td>
<td>
<p>numeric, to set the memory size as you need, so that calculation of large tree will not be limited by physical memory. unit is Gb. default is 50Gb.</p>
</td></tr>
<tr><td><code id="bNTI.big.cm_+3A_weighted">weighted</code></td>
<td>
<p>Logic, consider abundances or not (just presence/absence). default is TRUE.</p>
</td></tr>
<tr><td><code id="bNTI.big.cm_+3A_exclude.consp">exclude.consp</code></td>
<td>
<p>Logic, should conspecific taxa in different communities be exclude from MNTD calculations? default is FALSE. The same as in the function bmntd.</p>
</td></tr>
<tr><td><code id="bNTI.big.cm_+3A_rand">rand</code></td>
<td>
<p>integer, randomization times. default is 1000.</p>
</td></tr>
<tr><td><code id="bNTI.big.cm_+3A_output.dtail">output.dtail</code></td>
<td>
<p>logic, if TRUE, the betaNTI, RC value, observed betaMNTD, all null betaMNTD values will all be output, if FALSE, only output betaNTI or RC.</p>
</td></tr>
<tr><td><code id="bNTI.big.cm_+3A_rc">RC</code></td>
<td>
<p>logic, whether to use modified RC merics to evaluate significance of betaMNTD insteal of betaNTI (standardized effect size).</p>
</td></tr>
<tr><td><code id="bNTI.big.cm_+3A_trace">trace</code></td>
<td>
<p>logic, whether to show the progress when the code is running.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is particularly designed for samples from different metacommunities. The null model &quot;taxa shuffle&quot; will be done under different metacommunities, separately (and independently). All other details are the same as the function bNTI.big.
</p>


<h3>Value</h3>

<p>If output.detail=FALSE (default), a matrix of betaNTI values (if RC=FALSE) or RC values (if RC=TRUE) is returned. If output.detail=TRUE, a list is returned.
</p>
<table>
<tr><td><code>bNTI</code></td>
<td>
<p>a matrix of pairwise betaNTI values.</p>
</td></tr>
<tr><td><code>RC.bMNTD</code></td>
<td>
<p>a matrix of RC values based on null model test of betaMNTD. Ouput when RC=TRUE.</p>
</td></tr>
<tr><td><code>bMNTD</code></td>
<td>
<p>observed betaMNTD values.</p>
</td></tr>
<tr><td><code>bMNTD.rand</code></td>
<td>
<p>a matrix of all null results.</p>
</td></tr>
</table>


<h3>Note</h3>

<p>Version 1: 2021.8.2
</p>


<h3>Author(s)</h3>

<p>Daliang Ning
</p>


<h3>References</h3>

<p>Webb, C.O., Ackerly, D.D. &amp; Kembel, S.W. (2008). Phylocom: software for the analysis of phylogenetic community structure and trait evolution. Bioinformatics, 24, 2098-2100.
</p>
<p>Kembel, S.W. (2009). Disentangling niche and neutral influences on community assembly: assessing the performance of community phylogenetic structure tests. Ecol Lett, 12, 949-960.
</p>
<p>Stegen, J.C., Lin, X., Konopka, A.E. &amp; Fredrickson, J.K. (2012). Stochastic and deterministic assembly processes in subsurface microbial communities. Isme Journal, 6, 1653-1664.
</p>
<p>Chase, J.M., Kraft, N.J.B., Smith, K.G., Vellend, M. &amp; Inouye, B.D. (2011). Using null models to disentangle variation in community dissimilarity from variation in alpha-diversity. Ecosphere, 2, 1-11.
</p>
<p>Kane, M.J., Emerson, J., Weston, S. (2013). Scalable Strategies for Computing with Massive Data. Journal of Statistical Software, 55(14), 1-19. URL http://www.jstatsoft.org/v55/i14/.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+bNTI.big">bNTI.big</a></code>, <code><a href="#topic+qpen.cm">qpen.cm</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("example.data")
comm=example.data$comm
tree=example.data$tree

# In this example, 10 samples from one metacommunity,
# the other 10 samples from another metacommunity.
meta.group=data.frame(meta.com=c(rep("meta1",10),rep("meta2",10)))
rownames(meta.group)=rownames(comm)

# since pdist.big need to save output to a certain folder,
# the following code is set as 'not test'.
# but you may test the code on your computer after change the path for 'save.wd'.

wd0=getwd()
save.wd=paste0(tempdir(),"/pdbig.bNTI.big.cm")
# you may change save.wd to the folder you want to save the pd.big output.
nworker=2 # parallel computing thread number
pd.big=pdist.big(tree = tree, wd=save.wd, nworker = nworker)
rand.time=20 # usually use 1000 for real data.
bNTI=bNTI.big.cm(comm=comm, meta.group=meta.group,pd.desc=pd.big$pd.file,
                pd.spname=pd.big$tip.label,pd.wd=pd.big$pd.wd,
                spname.check=TRUE, nworker=nworker, memo.size.GB=50,
                weighted=TRUE, exclude.consp=FALSE,rand=rand.time,
                output.dtail=FALSE, RC=FALSE, trace=TRUE)
setwd(wd0)

</code></pre>

<hr>
<h2 id='bNTI.bin.big'>
Calculate beta nearest taxon index (betaNTI) for each phylogenetic bin
</h2><span id='topic+bNTI.bin.big'></span>

<h3>Description</h3>

<p>Perform null model test based on a phylogenetic beta diversity index, beta mean phylogenetic distance to the nearest taxon (betaMNTD), in each bin; calculate beta nearest taxon index (betaNTI), or modified Raup-Crick metric, or confidence level based on the comparison between observed and null betaMNTD in each bin. The package bigmemory (Kane et al 2013) is used to handle very large phylogenetic distance matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bNTI.bin.big(comm, pd.desc, pd.spname, pd.wd, pdid.bin,
             sp.bin, spname.check = FALSE, nworker = 4,
             memo.size.GB = 50, weighted = c(TRUE, FALSE),
             rand = 1000, output.bMNTD = c(FALSE, TRUE),
             sig.index=c("SES","Confidence","RC","bNTI"),
             unit.sum = NULL, correct.special = FALSE, detail.null = FALSE,
             special.method = c("MNTD","MPD","both"),
             ses.cut = 1.96, rc.cut = 0.95, conf.cut = 0.975,
             exclude.conspecifics = FALSE, dirichlet = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bNTI.bin.big_+3A_comm">comm</code></td>
<td>
<p>matrix or data.frame, community data, each row is a sample or site, each colname is a species or OTU or gene, thus rownames should be sample IDs, colnames should be taxa IDs.</p>
</td></tr>
<tr><td><code id="bNTI.bin.big_+3A_pd.desc">pd.desc</code></td>
<td>
<p>the name of the file to hold the backingfile description of the phylogenetic distance matrix, it is usually &quot;pd.desc&quot; if using default setting in pdist.big function.</p>
</td></tr>
<tr><td><code id="bNTI.bin.big_+3A_pd.spname">pd.spname</code></td>
<td>
<p>character vector, taxa id in the same rank as the big matrix of phylogenetic distances.</p>
</td></tr>
<tr><td><code id="bNTI.bin.big_+3A_pd.wd">pd.wd</code></td>
<td>
<p>folder path, where the bigmemmory file of the phylogenetic distance matrix are saved.</p>
</td></tr>
<tr><td><code id="bNTI.bin.big_+3A_pdid.bin">pdid.bin</code></td>
<td>
<p>list, each element is a vector of integer, indicating which rows/columns in the big phylogenetic matrix represent the taxa in a bin.</p>
</td></tr>
<tr><td><code id="bNTI.bin.big_+3A_sp.bin">sp.bin</code></td>
<td>
<p>one-column matrix, rownames are taxa IDs (i.e. OTU IDs), the only column shows the bin ID of each taxon. Bin IDs are integers in the same order as the elements in the list of pdid.bin.</p>
</td></tr>
<tr><td><code id="bNTI.bin.big_+3A_spname.check">spname.check</code></td>
<td>
<p>logic, whether to check the OTU ids (species names) in community matrix and phylogenetic distance matrix are the same.</p>
</td></tr>
<tr><td><code id="bNTI.bin.big_+3A_nworker">nworker</code></td>
<td>
<p>for parallel computing. Either a character vector of host names on which to run the worker copies of R, or a positive integer (in which case that number of copies is run on localhost). default is 4, means 4 threads will be run.</p>
</td></tr>
<tr><td><code id="bNTI.bin.big_+3A_memo.size.gb">memo.size.GB</code></td>
<td>
<p>numeric, to set the memory size as you need, so that calculation of large tree will not be limited by physical memory. unit is Gb. default is 50Gb.</p>
</td></tr>
<tr><td><code id="bNTI.bin.big_+3A_weighted">weighted</code></td>
<td>
<p>Logic, consider abundances or not (just presence/absence). default is TRUE.</p>
</td></tr>
<tr><td><code id="bNTI.bin.big_+3A_rand">rand</code></td>
<td>
<p>integer, randomization times. default is 1000.</p>
</td></tr>
<tr><td><code id="bNTI.bin.big_+3A_output.bmntd">output.bMNTD</code></td>
<td>
<p>logic, if TRUE, the output will include betaMNTD.</p>
</td></tr>
<tr><td><code id="bNTI.bin.big_+3A_sig.index">sig.index</code></td>
<td>
<p>character, the index for null model significance test. SES or bNTI, standard effect size, i.e. beta nearest taxon index (betaNTI); Confidence, percentage of null values less extreme than the observed value, i.e. non-parametric one-side confidence level; RC, modified Raup-Crick index (RC) based on betaMNTD, i.e. count the number of null betaMNTD lower than observed betaMNTD plus a half of the number of null betaMNTD equal to observed betaMNTD, to get alpha, then calculate betaMNTD-based RC as (2 x alpha - 1). default is SES. If input a vector, only the first element will be used.</p>
</td></tr>
<tr><td><code id="bNTI.bin.big_+3A_unit.sum">unit.sum</code></td>
<td>
<p>NULL or a number or a nemeric vector. When a beta diversity index is calculated for a bin, the taxa abundances will be divided by unit.sum to calculate the relative abundances. Usually, unit.sum can be set as the sequencing depth in each sample. Default setting is NULL, means not to do this transformation.</p>
</td></tr>
<tr><td><code id="bNTI.bin.big_+3A_correct.special">correct.special</code></td>
<td>
<p>logic, whether to correct the special cases. Default is FALSE.</p>
</td></tr>
<tr><td><code id="bNTI.bin.big_+3A_detail.null">detail.null</code></td>
<td>
<p>logic, if TRUE, the output will include all the null values. Default is FALSE.</p>
</td></tr>
<tr><td><code id="bNTI.bin.big_+3A_special.method">special.method</code></td>
<td>
<p>When correct.special is TRUE, which method will be used to check underestimation of deterministic pattern(s) in special cases. MNTD, use null model test of mean distance to the nearest taxon; MPD, use null model test based on mean pairwise distance; both, use null model test of both MPD and MNTD. Default is MNTD.</p>
</td></tr>
<tr><td><code id="bNTI.bin.big_+3A_ses.cut">ses.cut</code></td>
<td>
<p>numeric, the cutoff of significant standard effect size, default is 1.96.</p>
</td></tr>
<tr><td><code id="bNTI.bin.big_+3A_rc.cut">rc.cut</code></td>
<td>
<p>numeric, the cutoff of significant modified Raup-Crick metric, default is 0.95.</p>
</td></tr>
<tr><td><code id="bNTI.bin.big_+3A_conf.cut">conf.cut</code></td>
<td>
<p>numeric, the cutoff of significant one-side confidence level, default is 0.975.</p>
</td></tr>
<tr><td><code id="bNTI.bin.big_+3A_exclude.conspecifics">exclude.conspecifics</code></td>
<td>
<p>Logic, should conspecific taxa in different communities be exclude from MNTD calculations? default is FALSE. The same as in the function bmntd.</p>
</td></tr>
<tr><td><code id="bNTI.bin.big_+3A_dirichlet">dirichlet</code></td>
<td>
<p>Logic. If TRUE, the taxonomic null model for correcting special cases will use Dirichlet distribution to generate relative abundances in randomized community matrix. default is FALSE.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The beta nearest taxon index (betaNTI; Webb et al. 2008, Stegen et al. 2012) is calculated for each phylogenetic bin. betaNTI is a standardized measure of the mean phylogenetic distance to the nearest taxon between samples/communities (beta MNTD) and quantifies the extent of terminal clustering, independent of deep level clustering. Parallel computing is used to improve the speed.
</p>
<p>The null model algorithm is &quot;taxa shuffle&quot; (Kembel 2009), i.e. shuffling taxa labels across the
tips of the phylogenetic tree to randomize phylogenetic relationships among species. In this function, taxa will be randomized across all bins.
</p>
<p>In the betaNTI of each bin, the diagonal are set as zero. If the randomized results are all the same, the standard deviation will be zero and betaNTI will be NAN. In this case, betaNTI will be set as zero, since the observed result is not differentiable from randomized results.
</p>
<p>Modified RC (Chase et al 2011) and Confidence (Ning et al 2020) are alternative significance test indexes to evaluate how the observed beta diversity index deviates from null expectation, which could be a better metric than standardized effect size (betaNTI) in some cases, e.g. null values do not follow normal distribution.
</p>


<h3>Value</h3>

<p>Output is a list with following elements:
</p>
<table>
<tr><td><code>index</code></td>
<td>
<p>list, each element is a square matrix of betaNTI values of a bin. The elements (bins) are in the same order as in the input pdid.bin.</p>
</td></tr>
<tr><td><code>sig.index</code></td>
<td>
<p>character, indicates the index for null model significance test, SES (i.e. betaNTI), RC, or Confidence.</p>
</td></tr>
<tr><td><code>betaMNTD.obs</code></td>
<td>
<p>Output only if output.bMNTD is TRUE. A list, each element is a square matrix of observed beta MNTD values of a bin. The elements (bins) are in the same order as in the input pdid.bin.</p>
</td></tr>
<tr><td><code>rand</code></td>
<td>
<p>Output only if detail.null is TRUE. A list, each element is a matrix with null values of beta MNTD for each turnover of a bin. The elements (bins) are in the same order as in the input pdid.bin.</p>
</td></tr>
<tr><td><code>special.crct</code></td>
<td>
<p>Output only if detail.null is TRUE. NULL if correct.special is FALSE. A list with three elements, corresponding to three different null model significance testing indexes, i.e. SES, RC, and Confidence. Each element is a matrix, where the value is zero if the result for a turnover of a bin does not need to correct, otherwise there will be a corrected value.</p>
</td></tr>
</table>


<h3>Note</h3>

<p>Version 8: 2021.4.18, fix the bug when detail.null=TRUE and comm has only two samples.
Version 7: 2020.9.1, remove setwd. change dontrun to donttest and revise save.wd in help doc.
Version 6: 2020.8.18, update help document, add example.
Version 5: 2020.8.1, change RC opiton to sig.index, add detail.null, rc.cut and conf.cut. 
Version 4: 2019.11.6, add exclude.conspecifics.
Version 3: 2018.10.15, add unit.sum, correct.special.
Version 2: 2016.3.26, add RC option.
Version 1: 2015.12.16
</p>


<h3>Author(s)</h3>

<p>Daliang Ning
</p>


<h3>References</h3>

<p>Webb, C.O., Ackerly, D.D. &amp; Kembel, S.W. (2008). Phylocom: software for the analysis of phylogenetic community structure and trait evolution. Bioinformatics, 24, 2098-2100.
</p>
<p>Kembel, S.W. (2009). Disentangling niche and neutral influences on community assembly: assessing the performance of community phylogenetic structure tests. Ecol Lett, 12, 949-960.
</p>
<p>Stegen, J.C., Lin, X., Konopka, A.E. &amp; Fredrickson, J.K. (2012). Stochastic and deterministic assembly processes in subsurface microbial communities. Isme Journal, 6, 1653-1664.
</p>
<p>Chase, J.M., Kraft, N.J.B., Smith, K.G., Vellend, M. &amp; Inouye, B.D. (2011). Using null models to disentangle variation in community dissimilarity from variation in alpha-diversity. Ecosphere, 2, 1-11.
</p>
<p>Ning, D., Yuan, M., Wu, L., Zhang, Y., Guo, X., Zhou, X. et al. (2020). A quantitative framework reveals ecological drivers of grassland microbial community assembly in response to warming. Nature Communications, 11, 4717.
</p>
<p>Kane, M.J., Emerson, J., Weston, S. (2013). Scalable Strategies for Computing with Massive Data. Journal of Statistical Software, 55(14), 1-19. URL http://www.jstatsoft.org/v55/i14/.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+bNTIn.p">bNTIn.p</a></code>,<code><a href="#topic+bmntd">bmntd</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># function 'bNTI.bin.big' is usually used in the main function, 'icamp.big',
# when setting phylo.rand.scale="across",
# means randomization across all bins in phylogenetic null model.

data("example.data")
comm=example.data$comm
tree=example.data$tree
pdid.bin=example.data$pdid.bin
sp.bin=example.data$sp.bin

# since pdist.big need to save output to a certain folder,
# the following code is set as 'not test'.
# but you may test the code on your computer after change the path for 'save.wd'.

wd0=getwd()
save.wd=paste0(tempdir(),"/pdbig.bNTI.bin.big")
# you may change save.wd to the folder you want to save the pd.big output.
nworker=2 # parallel computing thread number
pd.big=pdist.big(tree = tree, wd=save.wd, nworker = nworker)
rand.time=20 # usually use 1000 for real data.

bNTIbins=bNTI.bin.big(comm=comm, pd.desc=pd.big$pd.file, pd.spname=pd.big$tip.label,
                      pd.wd=pd.big$pd.wd, pdid.bin=pdid.bin, sp.bin=sp.bin,
                      spname.check = TRUE, nworker = nworker, memo.size.GB = 50,
                      weighted = TRUE, rand = rand.time, output.bMNTD = FALSE,
                      sig.index="SES", unit.sum = NULL, correct.special = TRUE,
                      detail.null = FALSE, special.method = "MNTD",
                      exclude.conspecifics = FALSE)
setwd(wd0)

</code></pre>

<hr>
<h2 id='bNTI.bin.cm'>
Calculate beta nearest taxon index (betaNTI) for each phylogenetic bin under multiple metacommunities
</h2><span id='topic+bNTI.bin.cm'></span>

<h3>Description</h3>

<p>Perform null model test based on a phylogenetic beta diversity index, beta mean phylogenetic distance to the nearest taxon (betaMNTD), in each bin; calculate beta nearest taxon index (betaNTI), or modified Raup-Crick metric, or confidence level based on the comparison between observed and null betaMNTD in each bin. The package bigmemory (Kane et al 2013) is used to handle very large phylogenetic distance matrix. This function can deal with local communities under different metacommunities (regional pools).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bNTI.bin.cm(comm, meta.group = NULL, meta.spool = NULL,
            meta.frequency = NULL, meta.ab = NULL,
            pd.desc, pd.spname, pd.wd, pdid.bin, sp.bin,
            spname.check = FALSE, nworker = 4,
            memo.size.GB = 50, weighted = c(TRUE, FALSE),
            rand = 1000, output.bMNTD = c(FALSE, TRUE),
            sig.index = c("SES", "Confidence", "RC", "bNTI"),
            unit.sum = NULL, correct.special = FALSE,
            detail.null = FALSE, special.method = c("MNTD", "MPD", "both"),
            ses.cut = 1.96, rc.cut = 0.95, conf.cut = 0.975,
            exclude.conspecifics = FALSE, dirichlet = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bNTI.bin.cm_+3A_comm">comm</code></td>
<td>
<p>matrix or data.frame, community data, each row is a sample or site, each colname is a species or OTU or gene, thus rownames should be sample IDs, colnames should be taxa IDs.</p>
</td></tr>
<tr><td><code id="bNTI.bin.cm_+3A_meta.group">meta.group</code></td>
<td>
<p>matrix or data.frame, a one-column (n x 1) matrix indicating which metacommunity each sample belongs to. rownames are sample IDs. first column is metacommunity names. Such that different samples can belong to different metacommunities. If input a n x m matrix, only the first column is used. NULL means all samples belong to the same metacommunity. Default is NULL, means all samples from the same metacommunity.</p>
</td></tr>
<tr><td><code id="bNTI.bin.cm_+3A_meta.spool">meta.spool</code></td>
<td>
<p>a list object, each element is a character vector listing all taxa IDs in a metacommunity. The names of the elements indicate metacommunity names, which should be the same as the metacommunity names in meta.group. Default is NULL, means to use the observed taxa in comm across samples within the same metacommunity that is defined by meta.group.</p>
</td></tr>
<tr><td><code id="bNTI.bin.cm_+3A_meta.frequency">meta.frequency</code></td>
<td>
<p>matrix or data.frame, each column represents a taxon, each row represents a metacommunity (regional pool), to define the occurrence frequency of each taxon in each metacommunity. The rownames indicate metacommunity names, which should be the same as the metacommunity names in meta.group. Default setting is NULL, means to calculate meta.frequency as occurrence frequency of each taxon in comm across the samples within each metacommunity defined by meta.group.</p>
</td></tr>
<tr><td><code id="bNTI.bin.cm_+3A_meta.ab">meta.ab</code></td>
<td>
<p>matrix or data.frame, each column represents a taxon, each row represents a metacommunity (regional pool), to define the aubndance (or relative abundance) of each taxon in each metacommunity. The rownames indicate metacommunity names, which should be the same as the metacommunity names in meta.group. Default setting is NULL, means to calculate meta.ab as average relative abundance of each taxon in comm across the samples within each metacommunity defined by meta.group.</p>
</td></tr>
<tr><td><code id="bNTI.bin.cm_+3A_pd.desc">pd.desc</code></td>
<td>
<p>the name of the file to hold the backingfile description of the phylogenetic distance matrix, it is usually &quot;pd.desc&quot; if using default setting in pdist.big function.</p>
</td></tr>
<tr><td><code id="bNTI.bin.cm_+3A_pd.spname">pd.spname</code></td>
<td>
<p>character vector, taxa id in the same rank as the big matrix of phylogenetic distances.</p>
</td></tr>
<tr><td><code id="bNTI.bin.cm_+3A_pd.wd">pd.wd</code></td>
<td>
<p>folder path, where the bigmemmory file of the phylogenetic distance matrix are saved.</p>
</td></tr>
<tr><td><code id="bNTI.bin.cm_+3A_pdid.bin">pdid.bin</code></td>
<td>
<p>list, each element is a vector of integer, indicating which rows/columns in the big phylogenetic matrix represent the taxa in a bin.</p>
</td></tr>
<tr><td><code id="bNTI.bin.cm_+3A_sp.bin">sp.bin</code></td>
<td>
<p>one-column matrix, rownames are taxa IDs (i.e. OTU IDs), the only column shows the bin ID of each taxon. Bin IDs are integers in the same order as the elements in the list of pdid.bin.</p>
</td></tr>
<tr><td><code id="bNTI.bin.cm_+3A_spname.check">spname.check</code></td>
<td>
<p>logic, whether to check the OTU ids (species names) in community matrix and phylogenetic distance matrix are the same.</p>
</td></tr>
<tr><td><code id="bNTI.bin.cm_+3A_nworker">nworker</code></td>
<td>
<p>for parallel computing. Either a character vector of host names on which to run the worker copies of R, or a positive integer (in which case that number of copies is run on localhost). default is 4, means 4 threads will be run.</p>
</td></tr>
<tr><td><code id="bNTI.bin.cm_+3A_memo.size.gb">memo.size.GB</code></td>
<td>
<p>numeric, to set the memory size as you need, so that calculation of large tree will not be limited by physical memory. unit is Gb. default is 50Gb.</p>
</td></tr>
<tr><td><code id="bNTI.bin.cm_+3A_weighted">weighted</code></td>
<td>
<p>Logic, consider abundances or not (just presence/absence). default is TRUE.</p>
</td></tr>
<tr><td><code id="bNTI.bin.cm_+3A_rand">rand</code></td>
<td>
<p>integer, randomization times. default is 1000.</p>
</td></tr>
<tr><td><code id="bNTI.bin.cm_+3A_output.bmntd">output.bMNTD</code></td>
<td>
<p>logic, if TRUE, the output will include betaMNTD.</p>
</td></tr>
<tr><td><code id="bNTI.bin.cm_+3A_sig.index">sig.index</code></td>
<td>
<p>character, the index for null model significance test. SES or bNTI, standard effect size, i.e. beta nearest taxon index (betaNTI); Confidence, percentage of null values less extreme than the observed value, i.e. non-parametric one-side confidence level; RC, modified Raup-Crick index (RC) based on betaMNTD, i.e. count the number of null betaMNTD lower than observed betaMNTD plus a half of the number of null betaMNTD equal to observed betaMNTD, to get alpha, then calculate betaMNTD-based RC as (2 x alpha - 1). default is SES. If input a vector, only the first element will be used.</p>
</td></tr>
<tr><td><code id="bNTI.bin.cm_+3A_unit.sum">unit.sum</code></td>
<td>
<p>NULL or a number or a nemeric vector. When a beta diversity index is calculated for a bin, the taxa abundances will be divided by unit.sum to calculate the relative abundances. Usually, unit.sum can be set as the sequencing depth in each sample. Default setting is NULL, means not to do this transformation.</p>
</td></tr>
<tr><td><code id="bNTI.bin.cm_+3A_correct.special">correct.special</code></td>
<td>
<p>logic, whether to correct the special cases. Default is FALSE.</p>
</td></tr>
<tr><td><code id="bNTI.bin.cm_+3A_detail.null">detail.null</code></td>
<td>
<p>logic, if TRUE, the output will include all the null values. Default is FALSE.</p>
</td></tr>
<tr><td><code id="bNTI.bin.cm_+3A_special.method">special.method</code></td>
<td>
<p>When correct.special is TRUE, which method will be used to check underestimation of deterministic pattern(s) in special cases. MNTD, use null model test of mean distance to the nearest taxon; MPD, use null model test based on mean pairwise distance; both, use null model test of both MPD and MNTD. Default is MNTD.</p>
</td></tr>
<tr><td><code id="bNTI.bin.cm_+3A_ses.cut">ses.cut</code></td>
<td>
<p>numeric, the cutoff of significant standard effect size, default is 1.96.</p>
</td></tr>
<tr><td><code id="bNTI.bin.cm_+3A_rc.cut">rc.cut</code></td>
<td>
<p>numeric, the cutoff of significant modified Raup-Crick metric, default is 0.95.</p>
</td></tr>
<tr><td><code id="bNTI.bin.cm_+3A_conf.cut">conf.cut</code></td>
<td>
<p>numeric, the cutoff of significant one-side confidence level, default is 0.975.</p>
</td></tr>
<tr><td><code id="bNTI.bin.cm_+3A_exclude.conspecifics">exclude.conspecifics</code></td>
<td>
<p>Logic, should conspecific taxa in different communities be exclude from MNTD calculations? default is FALSE. The same as in the function bmntd.</p>
</td></tr>
<tr><td><code id="bNTI.bin.cm_+3A_dirichlet">dirichlet</code></td>
<td>
<p>Logic. If TRUE, the taxonomic null model for correcting special cases will use Dirichlet distribution to generate relative abundances in randomized community matrix. default is FALSE.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is particularly designed for samples from different metacommunities. The null model &quot;taxa shuffle&quot; will be done under different metacommunities, separately (and independently). All other details are the same as the function bNTI.bin.big. 
</p>


<h3>Value</h3>

<p>Output is a list with following elements:
</p>
<table>
<tr><td><code>index</code></td>
<td>
<p>list, each element is a square matrix of betaNTI values of a bin. The elements (bins) are in the same order as in the input pdid.bin.</p>
</td></tr>
<tr><td><code>sig.index</code></td>
<td>
<p>character, indicates the index for null model significance test, SES (i.e. betaNTI), RC, or Confidence.</p>
</td></tr>
<tr><td><code>betaMNTD.obs</code></td>
<td>
<p>Output only if output.bMNTD is TRUE. A list, each element is a square matrix of observed beta MNTD values of a bin. The elements (bins) are in the same order as in the input pdid.bin.</p>
</td></tr>
<tr><td><code>rand</code></td>
<td>
<p>Output only if detail.null is TRUE. A list, each element is a matrix with null values of beta MNTD for each turnover of a bin. The elements (bins) are in the same order as in the input pdid.bin.</p>
</td></tr>
<tr><td><code>special.crct</code></td>
<td>
<p>Output only if detail.null is TRUE. NULL if correct.special is FALSE. A list with three elements, corresponding to three different null model significance testing indexes, i.e. SES, RC, and Confidence. Each element is a matrix, where the value is zero if the result for a turnover of a bin does not need to correct, otherwise there will be a corrected value.</p>
</td></tr>
</table>


<h3>Note</h3>

<p>Version 2: 2022.4.26, fixed error when correcting special case.
Version 1: 2021.8.4
</p>


<h3>Author(s)</h3>

<p>Daliang Ning
</p>


<h3>References</h3>

<p>Webb, C.O., Ackerly, D.D. &amp; Kembel, S.W. (2008). Phylocom: software for the analysis of phylogenetic community structure and trait evolution. Bioinformatics, 24, 2098-2100.
</p>
<p>Kembel, S.W. (2009). Disentangling niche and neutral influences on community assembly: assessing the performance of community phylogenetic structure tests. Ecol Lett, 12, 949-960.
</p>
<p>Stegen, J.C., Lin, X., Konopka, A.E. &amp; Fredrickson, J.K. (2012). Stochastic and deterministic assembly processes in subsurface microbial communities. Isme Journal, 6, 1653-1664.
</p>
<p>Chase, J.M., Kraft, N.J.B., Smith, K.G., Vellend, M. &amp; Inouye, B.D. (2011). Using null models to disentangle variation in community dissimilarity from variation in alpha-diversity. Ecosphere, 2, 1-11.
</p>
<p>Ning, D., Yuan, M., Wu, L., Zhang, Y., Guo, X., Zhou, X. et al. (2020). A quantitative framework reveals ecological drivers of grassland microbial community assembly in response to warming. Nature Communications, 11, 4717.
</p>
<p>Kane, M.J., Emerson, J., Weston, S. (2013). Scalable Strategies for Computing with Massive Data. Journal of Statistical Software, 55(14), 1-19. URL http://www.jstatsoft.org/v55/i14/.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+bNTI.bin.big">bNTI.bin.big</a></code>, <code><a href="#topic+icamp.cm">icamp.cm</a></code>, <code><a href="#topic+bNTI.cm">bNTI.cm</a></code>, <code><a href="#topic+bNTI.big.cm">bNTI.big.cm</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># function 'bNTI.bin.cm' is usually used in the main function, 'icamp.cm',
# when setting phylo.rand.scale="across",
# means randomization across all bins in phylogenetic null model.

data("example.data")
comm=example.data$comm
tree=example.data$tree
pdid.bin=example.data$pdid.bin
sp.bin=example.data$sp.bin

# in this example, 10 samples from one metacommunity,
# the other 10 samples from another metacommunity.
meta.group=data.frame(meta.com=c(rep("meta1",10),rep("meta2",10)))
rownames(meta.group)=rownames(comm)

# since pdist.big need to save output to a certain folder,
# the following code is set as 'not test'.
# but you may test the code on your computer after change the path for 'save.wd'.

wd0=getwd()
save.wd=paste0(tempdir(),"/pdbig.bNTI.bin.cm")
# you may change save.wd to the folder you want to save the pd.big output.
nworker=2 # parallel computing thread number
pd.big=pdist.big(tree = tree, wd=save.wd, nworker = nworker)
rand.time=20 # usually use 1000 for real data.

bNTIbins=bNTI.bin.cm(comm=comm,meta.group=meta.group,
                     pd.desc=pd.big$pd.file, pd.spname=pd.big$tip.label,
                     pd.wd=pd.big$pd.wd, pdid.bin=pdid.bin, sp.bin=sp.bin,
                     spname.check = TRUE, nworker = nworker, memo.size.GB = 50,
                     weighted = TRUE, rand = rand.time, output.bMNTD = FALSE,
                     sig.index="SES", unit.sum = NULL, correct.special = TRUE,
                     detail.null = FALSE, special.method = "MNTD",
                     exclude.conspecifics = FALSE)
setwd(wd0)

</code></pre>

<hr>
<h2 id='bNTI.cm'>
Calculate beta nearest taxon index (betaNTI) with parallel computing under multiple metacommunities
</h2><span id='topic+bNTI.cm'></span>

<h3>Description</h3>

<p>Perform null model test based on a phylogenetic beta diversity index, beta mean phylogenetic distance to the nearest taxon (betaMNTD); calculate beta nearest taxon index (betaNTI), or modified Raup-Crick metric, or confidence level, based on the comparison between observed and null betaMNTD. Run by parallel computing. This function can deal with local communities under different metacommunities (regional pools).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bNTI.cm(comm, dis, nworker = 4, memo.size.GB = 50,
        meta.group = NULL, meta.spool = NULL,
        meta.frequency = NULL, meta.ab = NULL,
        weighted = c(TRUE, FALSE), exclude.consp = FALSE,
        rand = 1000, output.bMNTD = c(FALSE, TRUE),
        sig.index = c("SES", "Confidence", "RC", "bNTI"),
        unit.sum = NULL, correct.special = FALSE,
        detail.null = FALSE, special.method = c("MNTD", "MPD", "both"),
        ses.cut = 1.96, rc.cut = 0.95, conf.cut = 0.975,
        dirichlet = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bNTI.cm_+3A_comm">comm</code></td>
<td>
<p>community data matrix. rownames are sample names. colnames are species names</p>
</td></tr>
<tr><td><code id="bNTI.cm_+3A_dis">dis</code></td>
<td>
<p>Phylogenetic distance matrix.</p>
</td></tr>
<tr><td><code id="bNTI.cm_+3A_nworker">nworker</code></td>
<td>
<p>for parallel computing. Either a character vector of host names on which to run the worker copies of R, or a positive integer (in which case that number of copies is run on localhost). default is 4, means 4 threads will be run.</p>
</td></tr>
<tr><td><code id="bNTI.cm_+3A_memo.size.gb">memo.size.GB</code></td>
<td>
<p>numeric, to set the memory size as you need, so that calculation of large tree will not be limited by physical memory. unit is Gb. default is 50Gb.</p>
</td></tr>
<tr><td><code id="bNTI.cm_+3A_meta.group">meta.group</code></td>
<td>
<p>matrix or data.frame, a one-column (n x 1) matrix indicating which metacommunity each sample belongs to. rownames are sample IDs. first column is metacommunity names. Such that different samples can belong to different metacommunities. If input a n x m matrix, only the first column is used. NULL means all samples belong to the same metacommunity. Default is NULL, means all samples from the same metacommunity.</p>
</td></tr>
<tr><td><code id="bNTI.cm_+3A_meta.spool">meta.spool</code></td>
<td>
<p>a list object, each element is a character vector listing all taxa IDs in a metacommunity. The names of the elements indicate metacommunity names, which should be the same as the metacommunity names in meta.group. Default is NULL, means to use the observed taxa in comm across samples within the same metacommunity that is defined by meta.group.</p>
</td></tr>
<tr><td><code id="bNTI.cm_+3A_meta.frequency">meta.frequency</code></td>
<td>
<p>matrix or data.frame, each column represents a taxon, each row represents a metacommunity (regional pool), to define the occurrence frequency of each taxon in each metacommunity. The rownames indicate metacommunity names, which should be the same as the metacommunity names in meta.group. Default setting is NULL, means to calculate meta.frequency as occurrence frequency of each taxon in comm across the samples within each metacommunity defined by meta.group.</p>
</td></tr>
<tr><td><code id="bNTI.cm_+3A_meta.ab">meta.ab</code></td>
<td>
<p>matrix or data.frame, each column represents a taxon, each row represents a metacommunity (regional pool), to define the aubndance (or relative abundance) of each taxon in each metacommunity. The rownames indicate metacommunity names, which should be the same as the metacommunity names in meta.group. Default setting is NULL, means to calculate meta.ab as average relative abundance of each taxon in comm across the samples within each metacommunity defined by meta.group.</p>
</td></tr>
<tr><td><code id="bNTI.cm_+3A_weighted">weighted</code></td>
<td>
<p>Logic, consider abundances or not (just presence/absence). default is TRUE.</p>
</td></tr>
<tr><td><code id="bNTI.cm_+3A_exclude.consp">exclude.consp</code></td>
<td>
<p>Logic, should conspecific taxa in different communities be exclude from MNTD calculations? default is FALSE. The same as in the function bmntd.</p>
</td></tr>
<tr><td><code id="bNTI.cm_+3A_rand">rand</code></td>
<td>
<p>integer, randomization times. default is 1000.</p>
</td></tr>
<tr><td><code id="bNTI.cm_+3A_output.bmntd">output.bMNTD</code></td>
<td>
<p>logic, if TRUE, the output will include the observed betaMNTD.</p>
</td></tr>
<tr><td><code id="bNTI.cm_+3A_sig.index">sig.index</code></td>
<td>
<p>character, the index for null model significance test. SES or bNTI, standard effect size, i.e. beta nearest taxon index (betaNTI); Confidence, percentage of null values less extreme than the observed value, i.e. non-parametric one-side confidence level; RC, modified Raup-Crick index (RC) based on betaMNTD, i.e. count the number of null betaMNTD lower than observed betaMNTD plus a half of the number of null betaMNTD equal to observed betaMNTD, to get alpha, then calculate betaMNTD-based RC as (2 x alpha - 1). default is SES. If input a vector, only the first element will be used.</p>
</td></tr>
<tr><td><code id="bNTI.cm_+3A_unit.sum">unit.sum</code></td>
<td>
<p>NULL or a number or a nemeric vector. When a beta diversity index is calculated for a bin, the taxa abundances will be divided by unit.sum to calculate the relative abundances. Usually, unit.sum can be set as the sequencing depth in each sample. Default setting is NULL, means not to do this transformation.</p>
</td></tr>  
<tr><td><code id="bNTI.cm_+3A_correct.special">correct.special</code></td>
<td>
<p>logic, whether to correct the special cases when calculating bNTI. Default is FALSE.</p>
</td></tr>
<tr><td><code id="bNTI.cm_+3A_detail.null">detail.null</code></td>
<td>
<p>logic, if TRUE, the output will include all the null values. Default is FALSE.</p>
</td></tr>
<tr><td><code id="bNTI.cm_+3A_special.method">special.method</code></td>
<td>
<p>When correct.special is TRUE, which method will be used to check underestimation of deterministic pattern(s) in special cases. MNTD, use null model test of mean distance to the nearest taxon; MPD, use null model test based on mean pairwise distance; both, use null model test of both MPD and MNTD. Default is MNTD.</p>
</td></tr>
<tr><td><code id="bNTI.cm_+3A_ses.cut">ses.cut</code></td>
<td>
<p>numeric, the cutoff of significant standard effect size, default is 1.96.</p>
</td></tr>
<tr><td><code id="bNTI.cm_+3A_rc.cut">rc.cut</code></td>
<td>
<p>numeric, the cutoff of significant modified Raup-Crick metric, default is 0.95.</p>
</td></tr>
<tr><td><code id="bNTI.cm_+3A_conf.cut">conf.cut</code></td>
<td>
<p>numeric, the cutoff of significant one-side confidence level, default is 0.975.</p>
</td></tr>
<tr><td><code id="bNTI.cm_+3A_dirichlet">dirichlet</code></td>
<td>
<p>Logic. If TRUE, the taxonomic null model for correcting special cases will use Dirichlet distribution to generate relative abundances in randomized community matrix. default is FALSE.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is particularly designed for samples from different metacommunities. The null model &quot;taxa shuffle&quot; will be done under different metacommunities, separately (and independently). All other details are the same as the function bNTIn.p. 
</p>


<h3>Value</h3>

<p>Output is a list with following elements:
</p>
<table>
<tr><td><code>index</code></td>
<td>
<p>a square matrix of betaNTI (or RC or Confidence based on betaMNTD) values.</p>
</td></tr>
<tr><td><code>sig.index</code></td>
<td>
<p>character, indicates the index for null model significance test, SES (i.e. betaNTI), RC, or Confidence.</p>
</td></tr>
<tr><td><code>betaMNTD.obs</code></td>
<td>
<p>Output only if output.bMNTD is TRUE. A square matrix of observed beta MNTD values.</p>
</td></tr>
<tr><td><code>rand</code></td>
<td>
<p>Output only if detail.null is TRUE. A matrix with null values of beta MNTD for each turnover.</p>
</td></tr>
<tr><td><code>special.crct</code></td>
<td>
<p>Output only if detail.null is TRUE. it will be NULL if correct.special is FALSE. Otherwise, it will be a list with three elements, corresponding to three different null model significance testing indexes, i.e. SES, RC, and Confidence. Each element is a square matrix, where the value is zero if the result for a turnover does not need to correct, otherwise there will be a corrected value.</p>
</td></tr>
</table>


<h3>Note</h3>

<p>Version 1: 2021.8.4
</p>


<h3>Author(s)</h3>

<p>Daliang Ning
</p>


<h3>References</h3>

<p>Webb, C.O., Ackerly, D.D. &amp; Kembel, S.W. (2008). Phylocom: software for the analysis of phylogenetic community structure and trait evolution. Bioinformatics, 24, 2098-2100.
</p>
<p>Kembel, S.W. (2009). Disentangling niche and neutral influences on community assembly: assessing the performance of community phylogenetic structure tests. Ecol Lett, 12, 949-960.
</p>
<p>Stegen, J.C., Lin, X., Konopka, A.E. &amp; Fredrickson, J.K. (2012). Stochastic and deterministic assembly processes in subsurface microbial communities. Isme Journal, 6, 1653-1664.
</p>
<p>Chase, J.M., Kraft, N.J.B., Smith, K.G., Vellend, M. &amp; Inouye, B.D. (2011). Using null models to disentangle variation in community dissimilarity from variation in alpha-diversity. Ecosphere, 2, 1-11.
</p>
<p>Ning, D., Yuan, M., Wu, L., Zhang, Y., Guo, X., Zhou, X. et al. (2020). A quantitative framework reveals ecological drivers of grassland microbial community assembly in response to warming. Nature Communications, 11, 4717.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+bNTIn.p">bNTIn.p</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("example.data")
comm=example.data$comm
pd=example.data$pd

# in this example, 10 samples from one metacommunity,
# the other 10 samples from another metacommunity.
meta.group=data.frame(meta.com=c(rep("meta1",10),rep("meta2",10)))
rownames(meta.group)=rownames(comm)

nworker=2 # parallel computing thread number
rand.time=4 # usually use 1000 for real data.
bNTI=bNTI.cm(comm=comm, meta.group=meta.group,
             dis=pd, nworker = nworker, memo.size.GB = 50,
             weighted = TRUE, exclude.consp = FALSE, rand = rand.time,
             output.bMNTD = FALSE, sig.index = "SES", unit.sum = NULL,
             correct.special = TRUE, detail.null = FALSE,
             special.method = "MNTD")
</code></pre>

<hr>
<h2 id='bNTIn.p'>
Calculate beta nearest taxon index (betaNTI) with parallel computing
</h2><span id='topic+bNTIn.p'></span>

<h3>Description</h3>

<p>Perform null model test based on a phylogenetic beta diversity index, beta mean phylogenetic distance to the nearest taxon (betaMNTD); calculate beta nearest taxon index (betaNTI), or modified Raup-Crick metric, or confidence level, based on the comparison between observed and null betaMNTD. Run by parallel computing.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bNTIn.p(comm, dis, nworker = 4, memo.size.GB = 50,
        weighted = c(TRUE, FALSE), exclude.consp = FALSE,
        rand = 1000, output.bMNTD = c(FALSE, TRUE), 
        sig.index=c("SES","Confidence","RC","bNTI"),
        unit.sum = NULL, correct.special = FALSE,
        detail.null=FALSE,
        special.method=c("MNTD", "MPD", "both"),
        ses.cut=1.96,rc.cut=0.95,conf.cut=0.975,
        dirichlet = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bNTIn.p_+3A_comm">comm</code></td>
<td>
<p>community data matrix. rownames are sample names. colnames are species names</p>
</td></tr>
<tr><td><code id="bNTIn.p_+3A_dis">dis</code></td>
<td>
<p>Phylogenetic distance matrix.</p>
</td></tr>
<tr><td><code id="bNTIn.p_+3A_nworker">nworker</code></td>
<td>
<p>for parallel computing. Either a character vector of host names on which to run the worker copies of R, or a positive integer (in which case that number of copies is run on localhost). default is 4, means 4 threads will be run.</p>
</td></tr>
<tr><td><code id="bNTIn.p_+3A_memo.size.gb">memo.size.GB</code></td>
<td>
<p>numeric, to set the memory size as you need, so that calculation of large tree will not be limited by physical memory. unit is Gb. default is 50Gb.</p>
</td></tr>
<tr><td><code id="bNTIn.p_+3A_weighted">weighted</code></td>
<td>
<p>Logic, consider abundances or not (just presence/absence). default is TRUE.</p>
</td></tr>
<tr><td><code id="bNTIn.p_+3A_exclude.consp">exclude.consp</code></td>
<td>
<p>Logic, should conspecific taxa in different communities be exclude from MNTD calculations? default is FALSE. The same as in the function bmntd.</p>
</td></tr>
<tr><td><code id="bNTIn.p_+3A_rand">rand</code></td>
<td>
<p>integer, randomization times. default is 1000.</p>
</td></tr>
<tr><td><code id="bNTIn.p_+3A_output.bmntd">output.bMNTD</code></td>
<td>
<p>logic, if TRUE, the output will include the observed betaMNTD.</p>
</td></tr>
<tr><td><code id="bNTIn.p_+3A_sig.index">sig.index</code></td>
<td>
<p>character, the index for null model significance test. SES or bNTI, standard effect size, i.e. beta nearest taxon index (betaNTI); Confidence, percentage of null values less extreme than the observed value, i.e. non-parametric one-side confidence level; RC, modified Raup-Crick index (RC) based on betaMNTD, i.e. count the number of null betaMNTD lower than observed betaMNTD plus a half of the number of null betaMNTD equal to observed betaMNTD, to get alpha, then calculate betaMNTD-based RC as (2 x alpha - 1). default is SES. If input a vector, only the first element will be used.</p>
</td></tr>
<tr><td><code id="bNTIn.p_+3A_unit.sum">unit.sum</code></td>
<td>
<p>NULL or a number or a nemeric vector. When a beta diversity index is calculated for a bin, the taxa abundances will be divided by unit.sum to calculate the relative abundances. Usually, unit.sum can be set as the sequencing depth in each sample. Default setting is NULL, means not to do this transformation.</p>
</td></tr>  
<tr><td><code id="bNTIn.p_+3A_correct.special">correct.special</code></td>
<td>
<p>logic, whether to correct the special cases when calculating bNTI. Default is FALSE.</p>
</td></tr>
<tr><td><code id="bNTIn.p_+3A_detail.null">detail.null</code></td>
<td>
<p>logic, if TRUE, the output will include all the null values. Default is FALSE.</p>
</td></tr>
<tr><td><code id="bNTIn.p_+3A_special.method">special.method</code></td>
<td>
<p>When correct.special is TRUE, which method will be used to check underestimation of deterministic pattern(s) in special cases. MNTD, use null model test of mean distance to the nearest taxon; MPD, use null model test based on mean pairwise distance; both, use null model test of both MPD and MNTD. Default is MNTD.</p>
</td></tr>
<tr><td><code id="bNTIn.p_+3A_ses.cut">ses.cut</code></td>
<td>
<p>numeric, the cutoff of significant standard effect size, default is 1.96.</p>
</td></tr>
<tr><td><code id="bNTIn.p_+3A_rc.cut">rc.cut</code></td>
<td>
<p>numeric, the cutoff of significant modified Raup-Crick metric, default is 0.95.</p>
</td></tr>
<tr><td><code id="bNTIn.p_+3A_conf.cut">conf.cut</code></td>
<td>
<p>numeric, the cutoff of significant one-side confidence level, default is 0.975.</p>
</td></tr>
<tr><td><code id="bNTIn.p_+3A_dirichlet">dirichlet</code></td>
<td>
<p>Logic. If TRUE, the taxonomic null model for correcting special cases will use Dirichlet distribution to generate relative abundances in randomized community matrix. default is FALSE.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The beta nearest taxon index (beta NTI; Webb et al. 2008, Stegen et al. 2012) is a standardized measure of the mean phylogenetic distance to the nearest taxon between samples/communities (beta MNTD) and quantifies the extent of terminal clustering, independent of deep level clustering. Parallel computing is used to improve the speed.
</p>
<p>The null model algorithm is &quot;taxa shuffle&quot; (Kembel 2009), i.e. shuffling taxa labels across the
tips of the phylogenetic tree to randomize phylogenetic relationships among species.
</p>
<p>In the output of betaNTI, the diagonal are set as zero. If the randomized results are all the same, the standard deviation will be zero and betaNTI will be NAN. In this case, beta NTI will be set as zero, since the observed result is not differentiable from randomized results.
</p>
<p>Modified RC (Chase et al 2011) and Confidence (Ning et al 2020) are alternative significance test indexes to evaluate how the observed beta diversity index deviates from null expectation, which could be a better metric than standardized effect size (betaNTI) in some cases, e.g. null values do not follow normal distribution.
</p>


<h3>Value</h3>

<p>Output is a list with following elements:
</p>
<table>
<tr><td><code>index</code></td>
<td>
<p>a square matrix of betaNTI (or RC or Confidence based on betaMNTD) values.</p>
</td></tr>
<tr><td><code>sig.index</code></td>
<td>
<p>character, indicates the index for null model significance test, SES (i.e. betaNTI), RC, or Confidence.</p>
</td></tr>
<tr><td><code>betaMNTD.obs</code></td>
<td>
<p>Output only if output.bMNTD is TRUE. A square matrix of observed beta MNTD values.</p>
</td></tr>
<tr><td><code>rand</code></td>
<td>
<p>Output only if detail.null is TRUE. A matrix with null values of beta MNTD for each turnover.</p>
</td></tr>
<tr><td><code>special.crct</code></td>
<td>
<p>Output only if detail.null is TRUE. it will be NULL if correct.special is FALSE. Otherwise, it will be a list with three elements, corresponding to three different null model significance testing indexes, i.e. SES, RC, and Confidence. Each element is a square matrix, where the value is zero if the result for a turnover does not need to correct, otherwise there will be a corrected value.</p>
</td></tr>
</table>


<h3>Note</h3>

<p>Version 7: 2021.4.18, fix the bug when detail.null=TRUE and comm has only two samples.
Version 6: 2020.8.18, update help document, add example.
Version 5: 2020.8.1, change RC opiton to sig.index, add detail.null, rc.cut and conf.cut. 
Version 4: 2018.10.15, consider special cases.
Version 3: 2016.3.26, add RC option.
Version 2: 2015.9.23, set diag of bNTI = 0 and set 0/0 = 0 for bNTI.
Version 1: 2015.4.1
</p>


<h3>Author(s)</h3>

<p>Daliang Ning
</p>


<h3>References</h3>

<p>Webb, C.O., Ackerly, D.D. &amp; Kembel, S.W. (2008). Phylocom: software for the analysis of phylogenetic community structure and trait evolution. Bioinformatics, 24, 2098-2100.
</p>
<p>Kembel, S.W. (2009). Disentangling niche and neutral influences on community assembly: assessing the performance of community phylogenetic structure tests. Ecol Lett, 12, 949-960.
</p>
<p>Stegen, J.C., Lin, X., Konopka, A.E. &amp; Fredrickson, J.K. (2012). Stochastic and deterministic assembly processes in subsurface microbial communities. Isme Journal, 6, 1653-1664.
</p>
<p>Chase, J.M., Kraft, N.J.B., Smith, K.G., Vellend, M. &amp; Inouye, B.D. (2011). Using null models to disentangle variation in community dissimilarity from variation in alpha-diversity. Ecosphere, 2, 1-11.
</p>
<p>Ning, D., Yuan, M., Wu, L., Zhang, Y., Guo, X., Zhou, X. et al. (2020). A quantitative framework reveals ecological drivers of grassland microbial community assembly in response to warming. Nature Communications, 11, 4717.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+bmntd">bmntd</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("example.data")
comm=example.data$comm
pd=example.data$pd
nworker=2 # parallel computing thread number
rand.time=4 # usually use 1000 for real data.
bNTI=bNTIn.p(comm=comm, dis=pd, nworker = nworker, memo.size.GB = 50,
             weighted = TRUE, exclude.consp = FALSE, rand = rand.time,
             output.bMNTD = FALSE, sig.index = "SES", unit.sum = NULL,
             correct.special = TRUE, detail.null = FALSE,
             special.method = "MNTD")
</code></pre>

<hr>
<h2 id='change.sigindex'>
Change significance index option in iCAMP analysis
</h2><span id='topic+change.sigindex'></span>

<h3>Description</h3>

<p>This function is to change the method to calculate significance between null and observed dissimilarity and/or change the significance threshold values.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>change.sigindex(icamp.output, sig.index = c("Confidence", "SES.RC", "SES", "RC"),
                detail.save = TRUE, detail.null = FALSE,
                ses.cut = 1.96, rc.cut = 0.95, conf.cut = 0.975)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="change.sigindex_+3A_icamp.output">icamp.output</code></td>
<td>
<p>list, the exact output of the function icamp.big in which detail.null must be TRUE, to save all null values.</p>
</td></tr>
<tr><td><code id="change.sigindex_+3A_sig.index">sig.index</code></td>
<td>
<p>character, Confidence means to directly count the percentage of null values higher/lower than observed value; SES.RC means to use Standard Effect Size (e.g. betaNRI, betaNTI) for phylogenetic beta diversity and use modified Raup-Crick for taxonomic beta diversity, which is typical practice in the previous method; SES means to use Standard Effect Size for both phylogenetic and taxonomic beta diversity; RC means to use modified Raup-Crick for both phylogenetic and taxonomic beta diversity.</p>
</td></tr>
<tr><td><code id="change.sigindex_+3A_detail.save">detail.save</code></td>
<td>
<p>logic, whether to output the details, including binning information, significance indexes, bin abundances, and some key parameter settings for iCAMP analysis. Default is TRUE</p>
</td></tr>
<tr><td><code id="change.sigindex_+3A_detail.null">detail.null</code></td>
<td>
<p>logic, whether to output all observed and null values of beta diversity indexes. Default is FALSE.</p>
</td></tr>
<tr><td><code id="change.sigindex_+3A_ses.cut">ses.cut</code></td>
<td>
<p>numeric, the cutoff of significant standard effect size, default is 1.96.</p>
</td></tr>
<tr><td><code id="change.sigindex_+3A_rc.cut">rc.cut</code></td>
<td>
<p>numeric, the cutoff of significant modified Raup-Crick index value, default is 0.95.</p>
</td></tr>
<tr><td><code id="change.sigindex_+3A_conf.cut">conf.cut</code></td>
<td>
<p>numeric, the cutoff of significant confidence level (one-tail), default is 0.975.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is to re-calculate significance using another index or a different threshold value using previously saved null model values. Since the null values are directly extracted from previous icamp.big results, it can skip the most time-consuming step (randomization) and quickly complete calculation.
</p>
<p>The default threshold values of Confidence (0.975), SES (1.96), and RC (0.95) mean to capture the 0.95 two-tail confidence level (P=0.05). But, SES need to assume the null values follow normal distribution. RC counts in a half of the special cases that null values are equal to observed values, which is good for obtaining a symmetric metric but theoretically has risk to misestimate significance level (but very slight). Thus, Confidence is preferred as long as the 1000-time randomization is representative.
</p>


<h3>Value</h3>

<p>The output will be the same as icamp.big.
</p>


<h3>Note</h3>

<p>Version 2: 2020.8.18, update help document, add example.
Version 1: 2020.8.1
</p>


<h3>Author(s)</h3>

<p>Daliang Ning
</p>


<h3>References</h3>

<p>Ning, D., Yuan, M., Wu, L., Zhang, Y., Guo, X., Zhou, X. et al. (2020). A quantitative framework reveals ecological drivers of grassland microbial community assembly in response to warming. Nature Communications, 11, 4717.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+icamp.big">icamp.big</a></code>, <code><a href="#topic+null.norm">null.norm</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("icamp.out")
icamp.out.new=change.sigindex(icamp.output=icamp.out, sig.index = "Confidence")
</code></pre>

<hr>
<h2 id='cohend'>
Cohen's d effect size
</h2><span id='topic+cohend'></span>

<h3>Description</h3>

<p>This function is to calculate the popular effect size index Cohen's d.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cohend(treat, control, paired = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cohend_+3A_treat">treat</code></td>
<td>
<p>a numeric vector. treatment group.</p>
</td></tr>
<tr><td><code id="cohend_+3A_control">control</code></td>
<td>
<p>a numberic vector. control group.</p>
</td></tr>
<tr><td><code id="cohend_+3A_paired">paired</code></td>
<td>
<p>logic. Whether the samples in treatment and control groups are paired. default is FALSE.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function computes the value of Cohen's d statistics (Cohen 1988).
The effect size magnitude is performed using the thresholds proposed by Cohen (1992), i.e. |d|&lt;0.2 &quot;negligible&quot;, 0.2&lt;=|d|&lt;0.5 &quot;small&quot;, 0.5&lt;=|d|&lt;0.8 &quot;medium&quot;, |d|&gt;=0.8 &quot;large&quot;.
The variance of the d is calculate using the conversion formula reportead at page 238 of Cooper et al. (2009):
((n1+n2)/(n1*n2) + .5*d^2/df) * ((n1+n2)/df)
Its square root is output as standard deviation of d.
</p>


<h3>Value</h3>

<p>A list of values will be returned
</p>
<table>
<tr><td><code>d</code></td>
<td>
<p>Cohen's d value, (mean(treat)-mean(control))/sd</p>
</td></tr>
<tr><td><code>sd</code></td>
<td>
<p>standard deviation of d</p>
</td></tr>
<tr><td><code>magnitude</code></td>
<td>
<p>a qualitative assessment of the magnitude of effect size</p>
</td></tr>
<tr><td><code>paired</code></td>
<td>
<p>whether the samples are paired</p>
</td></tr>
</table>


<h3>Note</h3>

<p>version 1: 2016.2.12
</p>


<h3>Author(s)</h3>

<p>Daliang Ning
</p>


<h3>References</h3>

<p>Cohen, J. (1988). Statistical power analysis for the behavioral sciences (2nd ed.). New York:Academic Press
</p>
<p>Cohen, J. (1992). A power primer. Psychological Bulletin, 112, 155-159.
</p>
<p>The Handbook of Research Synthesis and Meta-Analysis (Cooper, Hedges, &amp; Valentine, 2009)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x=c(1,5,8)
y=c(2,6,10)
cohend(x,y)
cohend(x,y,paired=TRUE)
</code></pre>

<hr>
<h2 id='dist.3col'>
Transform distance matrix to 3-column matrix
</h2><span id='topic+dist.3col'></span>

<h3>Description</h3>

<p>Transform a distance matrix to a 3-column matrix in which the first 2 columns indicate the pairwised samples/species names.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dist.3col(dist)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dist.3col_+3A_dist">dist</code></td>
<td>
<p>a square matrix or distance object with column names and row names.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>In many cases, a 3-column matrix is easier to use than a distance matrix.
</p>


<h3>Value</h3>

<table>
<tr><td><code>name1</code></td>
<td>
<p>1st column, the first item of pairwised two items</p>
</td></tr>
<tr><td><code>name2</code></td>
<td>
<p>2nd column, the second item of pairwised two items</p>
</td></tr>
<tr><td><code>dis</code></td>
<td>
<p>3rd column, distance value of the pairwised two itmes</p>
</td></tr>
</table>


<h3>Note</h3>

<p>Version 1: 2015.5.17
</p>


<h3>Author(s)</h3>

<p>Daliang Ning
</p>


<h3>Examples</h3>

<pre><code class='language-R'># In this example, dist.3col transforms the distance object
# of Bray-Curtis dissimilarity to 3-column matrix.

data("example.data")
comm=example.data$comm
BC=vegan::vegdist(comm)
BC3c=dist.3col(BC)
</code></pre>

<hr>
<h2 id='dist.bin.3col'>
Convert a list of dist (or matrixes) to a matrix
</h2><span id='topic+dist.bin.3col'></span>

<h3>Description</h3>

<p>Convert a list of distance matrixes (or square matrixes) with the same sample IDs into a matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dist.bin.3col(dist.bin, obj.name = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dist.bin.3col_+3A_dist.bin">dist.bin</code></td>
<td>
<p>a list, each element is a distance matrix or square matrix. all elements have exactly the same sample IDs (rownames and colnames) which are in the same order.</p>
</td></tr>
<tr><td><code id="dist.bin.3col_+3A_obj.name">obj.name</code></td>
<td>
<p>a character, as a prefix of the bin names.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A tool to facilitate format transformation in iCAMP analysis.
</p>


<h3>Value</h3>

<p>output is a matrix. The first two columns are sample IDs, and each of the following columns represent an element in the original list which usually is a bin in iCAMP analysis.
</p>


<h3>Note</h3>

<p>Version 2: 2020.8.18, add example
Version 1: 2015.8.30
</p>


<h3>Author(s)</h3>

<p>Daliang Ning
</p>


<h3>Examples</h3>

<pre><code class='language-R'># let's see a very simple example
bin.dist=as.matrix(dist(1:10))
rownames(bin.dist)&lt;-colnames(bin.dist)&lt;-paste0("Sample",1:10)
dist.bins=list(bin1=bin.dist,bin2=bin.dist+1,bin3=bin.dist*2)
dis.3c=dist.bin.3col(dist.bins,obj.name="test")
</code></pre>

<hr>
<h2 id='dniche'>
Calculate niche difference between species
</h2><span id='topic+dniche'></span>

<h3>Description</h3>

<p>Calculate niche difference between species based on each environmental variable, directly output the matrix or save the result matrix as big.matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dniche(env, comm,
       method = c("ab.overlap", "niche.value", "prefer.overlap"),
       nworker = 4, memory.G = 50, out.dist = FALSE,
       bigmemo = TRUE, nd.wd = getwd(), nd.spname.file="nd.names.csv",
       detail.file="ND.res.rda")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dniche_+3A_env">env</code></td>
<td>
<p>matrix or data.frame, each row is a sample, each column is an environmental factor which may be important to represent the niche, thus rownames are sample IDs, and colnames are environmental factor names.</p>
</td></tr>
<tr><td><code id="dniche_+3A_comm">comm</code></td>
<td>
<p>matrix or data.frame, each row is a sample, each column is a spcies (OTU or ASV), thus rownames are sample IDs, colnames are species/OTU/ASV IDs.</p>
</td></tr>
<tr><td><code id="dniche_+3A_method">method</code></td>
<td>
<p>methods to calculate niche difference. ab.overlap means to calculate from overlapp based on observed abundances along an environment gradient. niche.value means to calculate the difference from abundance weighted mean of each environment factor for each species. prefer.overlap is similar to ab.overlap, but the observed abundances of each species are divided by total abundance sum of the species before calculating overlapping.  If list multiple methods as a vector, only the first element will be used.</p>
</td></tr>
<tr><td><code id="dniche_+3A_nworker">nworker</code></td>
<td>
<p>integer, for parallel computing. Either a character vector of host names on which to run the worker copies of R, or a positive integer (in which case that number of copies is run on localhost). default is 4, means 4 threads will be run.</p>
</td></tr>
<tr><td><code id="dniche_+3A_memory.g">memory.G</code></td>
<td>
<p>numeric, to set the memory size as you need, so that calculation of large tree will not be limited by physical memory. unit is Gb. default is 50Gb.</p>
</td></tr>
<tr><td><code id="dniche_+3A_out.dist">out.dist</code></td>
<td>
<p>logic, if TRUE, the output niche difference matrix of each environment factor will be a distance object, otherwise will be a matrix in the output list.</p>
</td></tr>
<tr><td><code id="dniche_+3A_bigmemo">bigmemo</code></td>
<td>
<p>logic, if TRUE, big.matrix in R package bigmemory will be used to save each niche differnece matrix as a big matrix on hard disk.</p>
</td></tr>
<tr><td><code id="dniche_+3A_nd.wd">nd.wd</code></td>
<td>
<p>folder path, when bigmemo is TRUE, where the big matrixes are saved.</p>
</td></tr>
<tr><td><code id="dniche_+3A_nd.spname.file">nd.spname.file</code></td>
<td>
<p>character, name of the file saving taxa IDs, which should be in exactly the same order as in the row names (and column names) of the big niche difference matrix, if bigmemo is TRUE. it should be a .csv file.</p>
</td></tr>
<tr><td><code id="dniche_+3A_detail.file">detail.file</code></td>
<td>
<p>character, name of the file saving all output information in R data format. it should be a .rda file.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The method niche.value is to calculate niche difference as the absolute difference of niche values between each pair of species. The niche value of a species is calculated as abundance-weighted mean of each environmental factor as previously reported (Stegen et al 2012 ISME J). In the method ab.overlap, the abundance of each species along the gradient of an environment factor is estimated using the density function using Gaussian kernel with 512 points. Then, the niche difference between two species is calculated as the sum of absolute abundance difference at each point divided by the sum of the higher abundance at each point, like Ruzicka dissimilarity (weighted Jaccard). It is like 1 - niche overlap based on abundance profile overlap, thus called ab.overlap. The method prefer.overlap is very similar to ab.overlap, just one modification, i.e. the observed abundance of each species in each sample is divied by the total abundance of the species across all sample, to normalize the profile, before calcuating niche difference.
</p>
<p>Bigmemory (Kane et al 2013) is used to deal with large datasets.
</p>


<h3>Value</h3>

<p>The output is a list object, with several elements.
</p>
<table>
<tr><td><code>bigmemo</code></td>
<td>
<p>logic, to show whether big.matrix is used.</p>
</td></tr>
<tr><td><code>nd</code></td>
<td>
<p>if bigmemo is FALSE, this is a list of matrixes or distance objects showing the niche difference matrix based on each environment factor. if bigmemo is TRUE, this is a list of big matrix file names.</p>
</td></tr>
<tr><td><code>nd.wd</code></td>
<td>
<p>only appear when bigmemo is TRUE, shows the folder path where the big matrixes are saved.</p>
</td></tr>
<tr><td><code>names</code></td>
<td>
<p>only appear when bigmemo is TRUE, shows species (OTU or ASV) IDs, in the same order as rownames and colnames in the niche difference matrixes.</p>
</td></tr>
<tr><td><code>method</code></td>
<td>
<p>The method used.</p>
</td></tr>
</table>


<h3>Note</h3>

<p>Version 4: 2022.5.29, if nd.wd does not exist, creat a folder as nd.wd.
Version 3: 2020.9.1, add nd.spname.file and detail.file; remove setwd; change dontrun to donttest and revise save.wd in help doc.
Version 2: 2020.8.18, add example.
Version 1: 2020.5.15
</p>


<h3>Author(s)</h3>

<p>Daliang Ning
</p>


<h3>References</h3>

<p>Stegen, J.C., Lin, X., Konopka, A.E. &amp; Fredrickson, J.K. (2012). Stochastic and deterministic assembly processes in subsurface microbial communities. ISME J, 6, 1653-1664.
</p>
<p>Ning, D., Yuan, M., Wu, L., Zhang, Y., Guo, X., Zhou, X. et al. (2020). A quantitative framework reveals ecological drivers of grassland microbial community assembly in response to warming. Nature Communications, 11, 4717.
</p>
<p>Kane, M.J., Emerson, J., Weston, S. (2013). Scalable Strategies for Computing with Massive Data. Journal of Statistical Software, 55(14), 1-19. URL http://www.jstatsoft.org/v55/i14/.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+ps.bin">ps.bin</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("example.data")
comm=example.data$comm
env=example.data$env

# if data is small, you do not need to use big.memory
niche.dif=dniche(env = env, comm = comm, method = "niche.value",
                 nworker = 1,out.dist=FALSE,bigmemo=FALSE,nd.wd = NULL)

# if data is large, you need to use big.memory
# since big.memory need to specify a certain folder,
# it is set as 'not test'.
# but you may test the code on your computer after change the path for 'save.wd'.

  wd0=getwd()
  save.wd=paste0(tempdir(),"/dnichewd")
  # please change to the folder you want to save the big niche difference matrix.
  
  nworker=2 # parallel computing thread number
  niche.dif=dniche(env = env, comm = comm,
                   method = "niche.value", nworker = nworker,
                   out.dist=FALSE,bigmemo=TRUE,nd.wd = save.wd)
  setwd(wd0)

</code></pre>

<hr>
<h2 id='example.data'>
A simple example dataset for test
</h2><span id='topic+example.data'></span>

<h3>Description</h3>

<p>A small dataset including community matrix, phylogenetic tree, treatment information, environmental factors. just for test.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data("example.data")</code></pre>


<h3>Format</h3>

<p>The format is:
List of 4
$ comm : int [1:20, 1:30] 1 3 0 0 2 2 2 0 0 4 ...
..- attr(*, &quot;dimnames&quot;)=List of 2
.. ..$ : chr [1:20] &quot;s1&quot; &quot;s2&quot; &quot;s3&quot; &quot;s4&quot; ...
.. ..$ : chr [1:30] &quot;OTU1&quot; &quot;OTU2&quot; &quot;OTU3&quot; &quot;OTU4&quot; ...
$ tree :List of 4
..$ edge       : int [1:58, 1:2] 31 32 33 34 35 36 36 35 34 37 ...
..$ edge.length: num [1:58] 0.314 0.422 0.315 0.881 0.774 ...
..$ Nnode      : int 29
..$ tip.label  : chr [1:30] &quot;OTU1&quot; &quot;OTU2&quot; &quot;OTU3&quot; &quot;OTU4&quot; ...
..- attr(*, &quot;class&quot;)= chr &quot;phylo&quot;
..- attr(*, &quot;order&quot;)= chr &quot;cladewise&quot;
$ treat:'data.frame':	20 obs. of  2 variables:
..$ Management: chr [1:20] &quot;SF&quot; &quot;BF&quot; &quot;SF&quot; &quot;SF&quot; ...
..$ Location  : chr [1:20] &quot;south&quot; &quot;south&quot; &quot;south&quot; &quot;south&quot; ...
$ env  :'data.frame':	20 obs. of  2 variables:
..$ pH         : num [1:20] 3.4 3.6 3.8 4 4.2 4.4 4.6 4.8 5 5.2 ...
..$ temperature: num [1:20] 12.9 4 13.7 6 8 2.7 10.4 3.2 7.6 5.8 ...
$ pd   :'data.frame':	30 obs. of  30 variables:
..$ OTU1 : num [1:30] 0 0.606 1.348 3.015 3.331 ...
..$ OTU2 : num [1:30] 0.606 0 1.19 2.856 3.173 ...
..$ OTU3 : num [1:30] 1.35 1.19 0 2.05 2.37 ...
..$ OTU4 : num [1:30] 3.015 2.856 2.051 0 0.479 ...
..$ OTU5 : num [1:30] 3.331 3.173 2.367 0.479 0 ...
..$ OTU6 : num [1:30] 2.96 2.8 2 1.9 2.22 ...
..$ OTU7 : num [1:30] 3.62 3.46 2.65 2.56 2.87 ...
..$ OTU8 : num [1:30] 4.97 4.82 4.01 3.92 4.23 ...
..$ OTU9 : num [1:30] 4.77 4.61 3.81 3.71 4.03 ...
..$ OTU10: num [1:30] 3.96 3.81 3 2.9 3.22 ...
..$ OTU11: num [1:30] 3.4 3.24 2.43 2.34 2.65 ...
..$ OTU12: num [1:30] 3.69 3.53 2.73 2.63 2.95 ...
..$ OTU13: num [1:30] 5.64 5.48 4.68 4.58 4.9 ...
..$ OTU14: num [1:30] 6.1 5.94 5.14 5.04 5.36 ...
..$ OTU15: num [1:30] 4.73 4.57 3.77 3.67 3.99 ...
..$ OTU16: num [1:30] 5.77 5.61 4.8 4.71 5.03 ...
..$ OTU17: num [1:30] 5.97 5.81 5 4.91 5.22 ...
..$ OTU18: num [1:30] 5.27 5.11 4.3 4.21 4.52 ...
..$ OTU19: num [1:30] 7.56 7.4 6.6 6.5 6.82 ...
..$ OTU20: num [1:30] 7.55 7.39 6.58 6.49 6.8 ...
..$ OTU21: num [1:30] 6.49 6.33 5.53 5.43 5.75 ...
..$ OTU22: num [1:30] 6.52 6.37 5.56 5.46 5.78 ...
..$ OTU23: num [1:30] 6.68 6.52 5.72 5.62 5.94 ...
..$ OTU24: num [1:30] 6.35 6.19 5.38 5.29 5.61 ...
..$ OTU25: num [1:30] 6.37 6.21 5.41 5.31 5.63 ...
..$ OTU26: num [1:30] 5.73 5.57 4.77 4.67 4.99 ...
..$ OTU27: num [1:30] 6.23 6.07 5.27 5.17 5.49 ...
..$ OTU28: num [1:30] 5.99 5.83 5.02 4.93 5.24 ...
..$ OTU29: num [1:30] 5.7 5.54 4.74 4.64 4.96 ...
..$ OTU30: num [1:30] 3.94 3.78 2.97 2.88 3.19 ...
$ pdid.bin:List of 3
..$ : int [1:5] 1 2 3 4 5
..$ : int [1:7] 6 7 8 9 10 11 12
..$ : int [1:18] 13 14 15 16 17 18 19 20 21 22 ...
$ sp.bin  :'data.frame':	30 obs. of  1 variable:
..$ bin.id.new: num [1:30] 1 1 1 1 1 2 2 2 2 2 ...
$ classification: chr [1:30, 1:6] &quot;Archaea&quot; &quot;Archaea&quot; &quot;Archaea&quot; &quot;Archaea&quot; ...
..- attr(*, &quot;dimnames&quot;)=List of 2
.. ..$ : chr [1:30] &quot;OTU1&quot; &quot;OTU2&quot; &quot;OTU3&quot; &quot;OTU4&quot; ...
.. ..$ : chr [1:6] &quot;Domain&quot; &quot;Phylum&quot; &quot;Class&quot; &quot;Order&quot; ...
</p>


<h3>Details</h3>

<p>comm is a matrix, each row as a sample, each column as a species.
</p>
<p>tree means phylogenetic tree.
</p>
<p>treat is a treatment information matrix, each row as a sample, each column indicates a type of treatment.
</p>
<p>env is a matrix of environmental factors, i.e. pH and temperature in this case.
</p>
<p>pd is a matrix of the pairwise phylogenetic distance between species.
</p>
<p>pdid.bin is a list, each element is a vector of integer, indicating which rows/columns in the big phylogenetic matrix represent the taxa in a bin.
</p>
<p>sp.bin is a one-column matrix, rownames are taxa IDs (i.e. OTU IDs), the only column shows the bin ID of each taxon. Bin IDs are integers in the same order as the elements in the list of pdid.bin.
</p>
<p>classification is a matrix to define the lineage of each taxon.
</p>
<p>This dataset is randomly generated, just for test.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(example.data)
comm=example.data$comm
tree=example.data$tree
treat=example.data$treat
env=example.data$env
pd=example.data$pd
pdid.bin=example.data$pdid.bin
sp.bin=example.data$sp.bin
</code></pre>

<hr>
<h2 id='iCAMP-package'>
Infer Community Assembly Mechanisms by Phylogenetic-bin-based null model analysis
</h2><span id='topic+iCAMP-package'></span><span id='topic+iCAMP'></span>

<h3>Description</h3>

<p>This package is to implement a general framework to quantitatively infer Community Assembly Mechanisms by Phylogenetic-bin-based null model analysis, abbreviated as iCAMP (Ning et al 2020). It can quantitatively assess the relative importance of different community assembly processes, such as selection, dispersal, and drift, for both communities and each phylogenetic group ('bin'). Each bin usually consists of different taxa from a family or an order. The package also provides functions to implement some other published methods, including neutral taxa percentage (Burns et al 2016) based on neutral theory model (Sloan et al 2006) and quantifying assembly processes based on entire-community null models (Stegen et al 2013). It also includes quite a few handy functions, particularly for big datasets, such as phylogenetic and taxonomic null model analysis at both community and bin levels, between-taxa niche difference and phylogenetic distance calculation, phylogenetic signal test within phylogenetic groups, midpoint root of big trees, etc. URL: https://github.com/DaliangNing/iCAMP1
</p>
<p>Version 1.2.4: the first formal version of iCAMP for CRAN.
Version 1.2.5: correct typo in description and fix the error of memory.limit issue.
Version 1.2.6: revise the help document of qpen to include an example for big datasets.
Version 1.2.7: remove setwd in functions; add options to specify file names; change dontrun to donttest and revise save.wd in some help documents.
Version 1.2.8: revise dniche to avoid unnecessary file.
Version 1.2.9: update iCAMP paper newly published on Nature Communications and the GitHub link.
Version 1.2.10: fix minor bug when output.wd is NULL in icamp.big.
Version 1.2.11: fix minor bug in icamp.big when comm is data.frame.
Version 1.3.1: add bNTI.big and bMNTD.big, and revise qpen to handle big datasets better.
Version 1.3.2: revise icamp.bins to fix error when an input taxonomy name has unrecognizable character; revise icamp.boot to fix error when there is no outlier.
Version 1.3.3: add icamp.cate to summary for each category of taxa, e.g. core versus rare taxa.
Version 1.3.4: typo and format.
Version 1.3.5: revise icamp.big to correct error when using strict bin IDs when omit small bins.
Version 1.4.1: add function 'qpen.test' for bootstrapping test on 'qpen' results.
Version 1.4.2: add options in icamp.big, RC.pc, and RC.bin.bigc to allow relative abundances (value &lt; 1) in community matrix, community data transformation, and use of other taxonomic dissimilarity indexes.
Version 1.4.3: debug to allow input community matrix only has two samples. Also provide a temporary solution for the failure of makeCluster in some OS.
Version 1.4.4: debug ps.bin and icamp.cate to avoid error in special cases.
Version 1.4.5: add option to taxa.binphy.big and icamp.big to handle trees with single edge from root.
Version 1.4.6: debug icamp.big, fix 'differing number of rows' issue in version 1.4.2 to 1.4.5.
Version 1.4.7: speed up qpen.test when there are numerous between-group comparisons.
Version 1.4.8: fix a bug in function taxa.binphy.big.
Version 1.4.9: internal version.
Version 1.4.10: fix a potential bug in function maxbigm.
Version 1.4.11: debug for function icamp.boot.
Version 1.5.1: add functions qpen.cm, RC.cm, bNTI.cm, and bNTI.big.cm, to deal with samples from multiple metacommunities.
Version 1.5.2: add functions icamp.cm, NTI.cm, NRI.cm, bNRI.cm, bNTI.bin.cm, bNRI.bin.cm, and RC.bin.cm, to deal with samples from multiple metacommunities.
Version 1.5.3(20210924): add function pdist.p to calculate phylogenetic distance for relatively small datasets.
Version 1.5.4(20211209): correct 'paste' error in functions bNRI.bin.big and bNRI.bin.cm.
Version 1.5.5(20220210): add icamp.cm2 function to allow different metacommunity settings for taxonomic and phylogenetic null models.
Version 1.5.6(20220410): fix error and warnings from package check.
Version 1.5.7(20220410): fix notes from package check.
Version 1.5.8(20220421): fix error when nworker=1 in several functions.
Version 1.5.9(20220421): fix error in function bNTI.bin.cm.
Version 1.5.10(20220425): correct parallel thread number in examples.
Version 1.5.11(20220426): fix error in special cases in fucntion bNTI.bin.cm.
Version 1.5.12(20220529): fix warnings due to working directory issues of some examples in help documents.
</p>


<h3>Details</h3>


<table>
<tr>
 <td style="text-align: left;">
Package: </td><td style="text-align: left;"> iCAMP</td>
</tr>
<tr>
 <td style="text-align: left;">
Type: </td><td style="text-align: left;"> Package</td>
</tr>
<tr>
 <td style="text-align: left;">
Version: </td><td style="text-align: left;"> 1.5.12</td>
</tr>
<tr>
 <td style="text-align: left;">
Date: </td><td style="text-align: left;"> 2022-5-29</td>
</tr>
<tr>
 <td style="text-align: left;">
License: </td><td style="text-align: left;"> GPL-2</td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>



<h3>Author(s)</h3>

<p>Daliang Ning &lt;ningdaliang@ou.edu&gt;
</p>


<h3>References</h3>

<p>Ning, D., Yuan, M., Wu, L., Zhang, Y., Guo, X., Zhou, X. et al. (2020). A quantitative framework reveals ecological drivers of grassland microbial community assembly in response to warming. Nature Communications, 11, 4717.
</p>
<p>Burns, A.R., Stephens, W.Z., Stagaman, K., Wong, S., Rawls, J.F., Guillemin, K. et al. (2016). Contribution of neutral processes to the assembly of gut microbial communities in the zebrafish over host development. Isme Journal, 10, 655-664.
</p>
<p>Sloan, W.T., Lunn, M., Woodcock, S., Head, I.M., Nee, S. &amp; Curtis, T.P. (2006). Quantifying the roles of immigration and chance in shaping prokaryote community structure. Environmental Microbiology, 8, 732-740.
</p>
<p>Stegen, J.C., Lin, X., Fredrickson, J.K., Chen, X., Kennedy, D.W., Murray, C.J. et al. (2013). Quantifying community assembly processes and identifying features that impose them. Isme Journal, 7, 2069-2079.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("example.data")
comm=example.data$comm
tree=example.data$tree
# since need to save some outputs to a certain folder,
# the following code is set as 'not test'.
# but you may test the code on your computer
# after change the path for 'save.wd'.

  wd0=getwd() # please change to the folder you want to save the pd.big output.
  save.wd=paste0(tempdir(),"/pdbig")
  nworker=2 # parallel computing thread number
  rand.time=20 # usually use 1000 for real data.
  
  bin.size.limit=5 # for real data, usually use a proper number
  # according to phylogenetic signal test or try some settings
  # then choose the reasonable stochasticity level.
  # our experience is 12, or 24, or 48.
  # but for this example dataset which is too small, have to use 5.
  
  icamp.out=icamp.big(comm=comm,tree=tree,pd.wd=save.wd,
                      rand=rand.time, nworker=nworker,
                      bin.size.limit=bin.size.limit)
  setwd(wd0)

</code></pre>

<hr>
<h2 id='icamp.big'>
Infer community assembly mechanism by phylogenetic-bin-based null model analysis
</h2><span id='topic+icamp.big'></span>

<h3>Description</h3>

<p>main function of iCAMP, to perform phylogenetic-bin-based null model analysis and quantify the relative importance of different processes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>icamp.big(comm, tree, pd.desc = NULL, pd.spname = NULL, pd.wd = getwd(),
          rand = 1000, prefix = "iCAMP", ds = 0.2, pd.cut = NA, sp.check = TRUE,
          phylo.rand.scale = c("within.bin", "across.all", "both"),
          taxa.rand.scale = c("across.all", "within.bin", "both"),
          phylo.metric = c("bMPD", "bMNTD", "both", "bNRI", "bNTI"), 
          sig.index=c("Confidence","SES.RC","SES","RC"), bin.size.limit = 24,
          nworker = 4, memory.G = 50, rtree.save = FALSE, detail.save = TRUE,
          qp.save = TRUE, detail.null=FALSE, ignore.zero = TRUE,
          output.wd = getwd(), correct.special = TRUE, unit.sum = rowSums(comm),
          special.method = c("depend","MPD","MNTD","both"),
          ses.cut = 1.96, rc.cut = 0.95, conf.cut=0.975,
          omit.option = c("no", "test", "omit"), meta.ab = NULL,
          treepath.file="path.rda", pd.spname.file="pd.taxon.name.csv",
          pd.backingfile="pd.bin", pd.desc.file="pd.desc",
          taxo.metric="bray", transform.method=NULL,
          logbase=2, dirichlet=FALSE, d.cut.method=c("maxpd","maxdroot"))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="icamp.big_+3A_comm">comm</code></td>
<td>
<p>matrix or data.frame, community data, each row is a sample or site, each colname is a taxon (a species or OTU or ASV), thus rownames should be sample IDs, colnames should be taxa IDs.</p>
</td></tr>
<tr><td><code id="icamp.big_+3A_tree">tree</code></td>
<td>
<p>phylogenetic tree, an object of class &quot;phylo&quot;.</p>
</td></tr>
<tr><td><code id="icamp.big_+3A_pd.desc">pd.desc</code></td>
<td>
<p>the name of the file to hold the backingfile description of the phylogenetic distance matrix, it is usually &quot;pd.desc&quot; if using default setting in pdist.big function. If it is NULL, the fucntion pd.big will be used to calculate the phylogenetic distance matrix from tree, and save it in pd.wd as a big.memory file.</p>
</td></tr>
<tr><td><code id="icamp.big_+3A_pd.spname">pd.spname</code></td>
<td>
<p>character vector, taxa id in the same rank as the big matrix of phylogenetic distances.</p>
</td></tr>
<tr><td><code id="icamp.big_+3A_pd.wd">pd.wd</code></td>
<td>
<p>folder path, where the bigmemmory file of the phylogenetic distance matrix are saved.</p>
</td></tr>
<tr><td><code id="icamp.big_+3A_rand">rand</code></td>
<td>
<p>integer, randomization times. default is 1000.</p>
</td></tr>
<tr><td><code id="icamp.big_+3A_prefix">prefix</code></td>
<td>
<p>character string, the prefix of those output files.</p>
</td></tr>
<tr><td><code id="icamp.big_+3A_ds">ds</code></td>
<td>
<p>numeric, the general threshold of phylogenetic distance within which the phylogenetic signal is still significant. default is 0.2.</p>
</td></tr>
<tr><td><code id="icamp.big_+3A_pd.cut">pd.cut</code></td>
<td>
<p>numeric, the distance to the tree root where the phylogenetic tree is trancated to get strict phylogenetic bins. if pd.cut is set, the distance threshold (ds) is disabled. default is NA.</p>
</td></tr>
<tr><td><code id="icamp.big_+3A_sp.check">sp.check</code></td>
<td>
<p>logic, whether to match the taxa ids in community data, phylogenetic distance matrix, and tree. default is TRUE.</p>
</td></tr>
<tr><td><code id="icamp.big_+3A_phylo.rand.scale">phylo.rand.scale</code></td>
<td>
<p>character, the scale to randomize the taxa for phylogenetic null model. &quot;within.bin&quot; means randomization within each bin; &quot;across.all&quot; means randomization across all bins; &quot;both&quot; means to test both methods. Default setting is within.bin.</p>
</td></tr>
<tr><td><code id="icamp.big_+3A_taxa.rand.scale">taxa.rand.scale</code></td>
<td>
<p>character, the scale to randomize the taxa for taxonomic null model. &quot;within.bin&quot; means randomization within each bin; &quot;across.all&quot; means randomization across all bins; &quot;both&quot; means to test both methods. Default setting is across.all.</p>
</td></tr>
<tr><td><code id="icamp.big_+3A_phylo.metric">phylo.metric</code></td>
<td>
<p>character, the metric for phylogenetic null model analysis. bMPD (or bNRI), null model analysis based on beta mean pairwise distance (betaMPD); if sig.index is SES, it is beta net relatedness index (betaNRI). bMNTD (or bNTI), null model analysis based on beta mean nearest taxon distance (betaMNTD); if sig.index is SES, it is beta nearest taxon index (betaNTI). both, use null model test based on both bMPD and bMNTD. Default setting is based on bMPD.</p>
</td></tr>
<tr><td><code id="icamp.big_+3A_sig.index">sig.index</code></td>
<td>
<p>character, the index for null model significance test. Confidence, percentage of null values less extreme than the observed value, i.e. non-parametric one-side confidence level; if set sig.index as Confidence, it will be applied to both phylogenetic and taxonomic metrics. If set as SES.RC, use standard effect size (SES) for phylogenetic metrics (i.e. betaNTI or betaNRI), and use modified Raup-Crick (RC) for taxonomic metrics (RCbray). If set as SES, use SES for both phylogenetic and taxonomic metrics. If set as RC, use RC for both phylogenetic and taxonomic metrics. default is Confidence. If input a vector, only the first one will be used.</p>
</td></tr>
<tr><td><code id="icamp.big_+3A_bin.size.limit">bin.size.limit</code></td>
<td>
<p>integer, the minimal requirement of bin size (taxa numer in a bin). Default setting is 24.</p>
</td></tr>
<tr><td><code id="icamp.big_+3A_nworker">nworker</code></td>
<td>
<p>integer, for parallel computing. Either a character vector of host names on which to run the worker copies of R, or a positive integer (in which case that number of copies is run on localhost). default is 4, means 4 threads will be run.</p>
</td></tr>
<tr><td><code id="icamp.big_+3A_memory.g">memory.G</code></td>
<td>
<p>numeric, to set the memory size as you need, so that calculation of large tree will not be limited by physical memory. unit is Gb. default is 50Gb.</p>
</td></tr>
<tr><td><code id="icamp.big_+3A_rtree.save">rtree.save</code></td>
<td>
<p>logic, whether to save the rooted tree as nwk file, if the input tree is not rooted. Default is FALSE.</p>
</td></tr>
<tr><td><code id="icamp.big_+3A_detail.save">detail.save</code></td>
<td>
<p>logic, whether to save the details, i.e. some key objects for iCAMP analysis, as rda file. Default is TRUE.</p>
</td></tr>
<tr><td><code id="icamp.big_+3A_qp.save">qp.save</code></td>
<td>
<p>logic, whether to save the relative importance of processes as csv file. Default is TRUE.</p>
</td></tr>
<tr><td><code id="icamp.big_+3A_detail.null">detail.null</code></td>
<td>
<p>logic, if TRUE, the output will include all the null values. Default is FALSE. But this need to be TRUE if you want to change significance testing index later using 'change.sigindex'.</p>
</td></tr>
<tr><td><code id="icamp.big_+3A_ignore.zero">ignore.zero</code></td>
<td>
<p>logic, in the community data matrix (comm), whether to remove the row(s)/column(s) of which the sum is zero. Default is TRUE.</p>
</td></tr>
<tr><td><code id="icamp.big_+3A_output.wd">output.wd</code></td>
<td>
<p>a folder path, where the files will be saved when rtree.save, detail.save, or qp.save is true.</p>
</td></tr>
<tr><td><code id="icamp.big_+3A_correct.special">correct.special</code></td>
<td>
<p>logic, whether to correct the special cases when calculating bNRI or bNTI. Default is TRUE.</p>
</td></tr>
<tr><td><code id="icamp.big_+3A_unit.sum">unit.sum</code></td>
<td>
<p>NULL or a number or a nemeric vector. When a beta diversity index is calculated for a bin, the taxa abundances will be divided by unit.sum to calculate the relative abundances, and the Bray-Cuits index in each bin will become manhattan index divided by 2. Default setting are the row sums of community matrix, which are usually sequencing depth in each sample. If set as NULL, means not to do this special transformation.</p>
</td></tr>
<tr><td><code id="icamp.big_+3A_special.method">special.method</code></td>
<td>
<p>When correct.special is TRUE, which method will be used to check underestimation of deterministic pattern(s) in special cases. MPD, use null model test based on mean pairwise distance; MNTD, use null model test based on mean nearest taxon distance; depend, use MPD when phylo.metric is bMPD or bNRI, and use MNTD when phylo.metric is bMNTD or bNTI; both, use both MPD and MNTD. Default is depend</p>
</td></tr>
<tr><td><code id="icamp.big_+3A_ses.cut">ses.cut</code></td>
<td>
<p>numeric, the cutoff of significant standard effect size, default is 1.96.</p>
</td></tr>
<tr><td><code id="icamp.big_+3A_rc.cut">rc.cut</code></td>
<td>
<p>numeric, the cutoff of significant modified Raup-Crick index value, default is 0.95.</p>
</td></tr>
<tr><td><code id="icamp.big_+3A_conf.cut">conf.cut</code></td>
<td>
<p>numeric, the cutoff of significant one-side confidence level, default is 0.975.</p>
</td></tr>
<tr><td><code id="icamp.big_+3A_omit.option">omit.option</code></td>
<td>
<p>three options about omitting small bins. &quot;no&quot; means to merge small bins to their nearest relatives to meet the bin size requirement, rather than omitting them; &quot;test&quot; means to output the information of small strict bins with a size lower than requirement, iCAMP will not be performed; &quot;omit&quot;  means to do iCAMP analysis with strict bins which have enough species (larger than bin size requirement).</p>
</td></tr>
<tr><td><code id="icamp.big_+3A_meta.ab">meta.ab</code></td>
<td>
<p>a numeric vector, to define the relative aubndance of each species in the regional pool. Default setting is NULL, means to calculate meta.ab as average relative abundance of each species across the samples.</p>
</td></tr>
<tr><td><code id="icamp.big_+3A_treepath.file">treepath.file</code></td>
<td>
<p>character, name of the file saving the tree.path, which is a list of all the nodes and edge lengthes from root to every tip and/or node. it should be a .rda filename.</p>
</td></tr>
<tr><td><code id="icamp.big_+3A_pd.spname.file">pd.spname.file</code></td>
<td>
<p>character, name of the file saving the taxa IDs, which has exactly the same order as the row names (and column names) of the big phylogenetic distance matrix. it should be a .csv filename.</p>
</td></tr>
<tr><td><code id="icamp.big_+3A_pd.backingfile">pd.backingfile</code></td>
<td>
<p>character, the root name for the file for the cache of the big phylogenetic distance matrix. it should be a .bin filename.</p>
</td></tr>
<tr><td><code id="icamp.big_+3A_pd.desc.file">pd.desc.file</code></td>
<td>
<p>character, name of the file to hold the backingfile description for the big phylogenetic distance matrix. it should be a .desc filename.</p>
</td></tr>
<tr><td><code id="icamp.big_+3A_taxo.metric">taxo.metric</code></td>
<td>
<p>taxonomic beta diversity index, the same as 'method' in the function 'vegdist' in package 'vegan', including &quot;manhattan&quot;, &quot;euclidean&quot;, &quot;canberra&quot;, &quot;clark&quot;, &quot;bray&quot;, &quot;kulczynski&quot;, &quot;jaccard&quot;, &quot;gower&quot;, &quot;altGower&quot;, &quot;morisita&quot;, &quot;horn&quot;, &quot;mountford&quot;, &quot;raup&quot;, &quot;binomial&quot;, &quot;chao&quot;, &quot;cao&quot; or &quot;mahalanobis&quot;. If taxo.metric='bray' and transform.method=NULL, RC will be calculated based on Bray-Curtis dissimilarity as recommended in original iCAMP; otherwise, unit.sum setting will be ignored.</p>
</td></tr>
<tr><td><code id="icamp.big_+3A_transform.method">transform.method</code></td>
<td>
<p>character or a defined function, to specify how to transform community matrix before calculating dissimilarity. if it is a characher, it should be a method name as in the function 'decostand' in package 'vegan', including 'total','max','freq','normalize','range','standardize','pa','chi.square','cmdscale','hellinger','log'.</p>
</td></tr>
<tr><td><code id="icamp.big_+3A_logbase">logbase</code></td>
<td>
<p>numeric, the logarithm base used when transform.method='log'.</p>
</td></tr> 
<tr><td><code id="icamp.big_+3A_dirichlet">dirichlet</code></td>
<td>
<p>Logic. If TRUE, the taxonomic null model will use Dirichlet distribution to generate relative abundances in randomized community matrix. If the input community matrix has all row sums no more than 1, the function will automatically set dirichlet=TRUE. default is FALSE.</p>
</td></tr>
<tr><td><code id="icamp.big_+3A_d.cut.method">d.cut.method</code></td>
<td>
<p>character, to specify the method to calculate pd.cut from ds. 'maxpd' means based on maximum phylogenetic distance, pd.cut = (maxpd - ds)/2. 'maxdroot' means based on maximum distance to root, pd.cut = maxdroot - (ds/2), which is preferred if the tree only has one edge from the root.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This is the main function of iCAMP (Ning et al 2020). Most parameters can use the default settings. 
</p>
<p>To quantify various ecological processes, the observed taxa are first divided into different groups ('bins') based on their phylogenetic relationships. Then, the process governing each bin is identified based on null model analysis of the phylogenetic diversity using beta Net Relatedness Index (betaNRI), and taxonomic beta-diversities using modified Raup-Crick metric (RC; a typical setting of sig.index as SES.RC). For each bin, the fraction of pairwise comparisons with betaNRI &lt; -1.96 is considered as the percentages of homogeneous selection, whereas those with betaNRI &gt; +1.96 as the percentages of heterogeneous selection based on the threshold applied previously (Stegen et al 2015; Zhou and Ning 2017). Next, taxonomic diversity metric RC is used to partition the remaining pairwise comparisons with abs(NRI) &lt;= 1.96. The fraction of pairwise comparisons with RC &lt; -0.95 is treated as the percentages of homogenizing dispersal, while those with RC &gt; 0.95 as dispersal limitation (Stegen et al 2013). The remains with abs(NRI) &lt;= 1.96 and abs(RC) &lt;= 0.95 represent the percentages of drift, diversification, weak selection and/or weak dispersal(Zhou and Ning 2017), simply designated as 'drift'(Stegen et al 2013) for convenience. The above analysis is repeated for every bin. Subsequently, the fractions of individual processes across all bins are weighted by the relative abundance of each bin, and summarized to estimate the relative importance of individual processes at the whole community level. Besides betaNRI and RC, null model significance can also be inferred by direct test based on null model distribution, which should be a preferred choice when the null model simulated values do not follow normal distribution (Veech 2012). See the references for details.
</p>
<p>Bigmemory (Kane et al 2013) is used to deal with large datasets.
</p>


<h3>Value</h3>

<p>If omit.option is test, the output will be a table summarizing the information of small bins.
</p>
<p>Otherwise, the output is a list object, including one or more elements as below:
</p>
<p>The first one or selveral (if set 'both' for metrics and/or randomization scale) elements are matrixes of process importances at community level. In each matrix, the first two columns will be sample ID of each turnover, and the third to last column will show estimated relative importance of each process in shaping each turnover between communities (samples). The name(s) of the element(s) shows the metrics and its randomization scale, e.g. bNRIiRCa means phylogenetic null model analysis using betaNRI (i.e. SES based on betaMPD) with randomizaiton within each bin and taxonomic null model analysis using RC based on Bray-Curtis with randomization across bins. Other possible phylogenetic null-model-based metrics: bNTI, betaNTI (i.e. SES based on betaMNTD); RCbMPD, RC based on betaMPD; RCbMNTD, RC based on betaMNTD; CbMPD, confidence level based on betaMPD; CbMNTD, confidence level based on betaMNTD. Other possible taxonomic null-model-based metrics: SESbray, SES based on Bray-Curtis; CBray, confidence level based on Bray-Curtis. i, within-bin randomization; a, across-bin randomization.
</p>
<table>
<tr><td><code>detail</code></td>
<td>
<p>an element in output only if detail.save is TRUE. A list with elements as below.</p>
</td></tr>
<tr><td><code>taxabin</code></td>
<td>
<p>an element in 'detail'. A list, show phylogenetic binning results.
</p>
<p>The first element is a matrix named sp.bin, where each row is a taxon (OTU or ASV), the first column is the original strict bin ID, the second column is the original bin ID after small bins are merged into nearest relative(s), the third column is the final renewed bin ID.
</p>
<p>The second element named bin.united.sp is a list, where each element shows taxa IDs within each bin and the bins are in the order of the final renewed bin IDs.
</p>
<p>The third element named bin.strict.sp is a list, where each element shows taxa IDs within each strict bin and the bins are in the order of the original strict bin IDs.
</p>
<p>The fourth element named state.strict is a matrix, where the 1st column is orginal strict bin IDs, the 2nd column is the taxa number in each strict bin, the 3rd to 5th columns show the maximum, mean, and standard deviation of phylogenetic distances within each strict bin.
</p>
<p>The fifth element named state.united is a matrix, where the row numbering is the final bin ID, the 1st column is orginal bin IDs, the 2nd column is the taxa number in each final bin, the 3rd to 5th columns show the maximum, mean, and standard deviation of phylogenetic distances within each final bin.
</p>
</td></tr>
<tr><td><code>SigbMPDi</code>, <code>SigbMPDa</code>, <code>SigbMNTDi</code>, <code>SigbMNTDa</code>, <code>SigBCi</code>, <code>SigBCa</code></td>
<td>
<p>elements in 'detail', matrixes showing null model significance testing index for each turnover of each bin. In the name of the element(s), SigbMPD, SigMNTD, or SigBC mean the significance testing is based on betaMPD, betaMNTD, or taxonomic dissimilarity (default is Bray-Curtis); i, within-bin randomization; a, across-bin randomization. In each matrix, the first two columns are sample IDs for each turnover; the 3rd to the last column represent different bins with column names containing the significance testing index name, which can be bNRI, bNTI, RCbMPD, RCbMNTD, CbMPD, CbMNTD, SESbray, RCbray, or CBray as mentioned above.</p>
</td></tr>
<tr><td><code>bin.weight</code></td>
<td>
<p>an element in 'detail', a matrix showing relative abundance of each bin in each pair of samples.</p>
</td></tr>
<tr><td><code>processes</code></td>
<td>
<p>an element in 'detail', a list of process importance results at community level.</p>
</td></tr>
<tr><td><code>setting</code></td>
<td>
<p>an element in 'detail', a data.frame showing all basic settings of this function.</p>
</td></tr>
<tr><td><code>comm</code></td>
<td>
<p>an element in 'detail', the input community matrix.</p>
</td></tr>
<tr><td><code>rand</code></td>
<td>
<p>an element in output only if detail.null is TRUE. It is a list with each element showing the observed or null values of a beta diversity index (e.g. betaMPD, betaMNTD, Bray-Curtis). Each index is showed as a list where each element represents a bin.</p>
</td></tr>
<tr><td><code>special.crct</code></td>
<td>
<p>an element in output only if detail.null is TRUE. It shows the corrected values for special cases, where zero means no correction is needed.</p>
</td></tr>
</table>


<h3>Note</h3>

<p>Version 12: 2021.6.4, debug, fix 'arguments imply differing number of rows' issue.
Version 11: 2021.6.4, add option d.cut.method to handle trees with only one edge from root.
Version 10: 2021.4.17, add taxo.metric, transform.method, logbase, and dirichlet, to allow community data transform, dissimilar index other than Bray-Curtis, and relative abundances (values &lt; 1) in the input community matrix.
Version 9: 2021.4.1, revise 'sp.bin==i' to 'sp.bin==bin.lev[i]' to correct error when omit.option='omit' and strict bin IDs are used. Thank adityabandla for finding this bug. see https://github.com/DaliangNing/iCAMP1/issues/9 for details.
Version 8: 2020.10.15, input comm as data.frame may return error, now include as.matrix to solve it.
Version 7: 2020.9.21, fix minor bug when output.wd is NULL.
Version 6: 2020.9.1, remove setwd; add options to specify some file names; change dontrun to donttest and revise folder path in help doc.
Version 5: 2020.8.19, update help document, add example.
Version 4: 2020.5.31.
Version 3: 2019.9.30.
</p>


<h3>Author(s)</h3>

<p>Daliang Ning
</p>


<h3>References</h3>

<p>Ning, D., Yuan, M., Wu, L., Zhang, Y., Guo, X., Zhou, X. et al. (2020). A quantitative framework reveals ecological drivers of grassland microbial community assembly in response to warming. Nature Communications, 11, 4717.
</p>
<p>Stegen, J.C., Lin, X., Fredrickson, J.K. &amp; Konopka, A.E. (2015). Estimating and mapping ecological processes influencing microbial community assembly. Front Microbiol, 6, 370.
</p>
<p>Stegen, J.C., Lin, X., Fredrickson, J.K., Chen, X., Kennedy, D.W., Murray, C.J. et al. (2013). Quantifying community assembly processes and identifying features that impose them. ISME J, 7, 2069.
</p>
<p>Zhou, J. &amp; Ning, D. (2017). Stochastic community assembly: Does it matter in microbial ecology? Microbiology and Molecular Biology Reviews, 81.
</p>
<p>Veech, J.A. (2012). Significance testing in ecological null models. Theor Ecol, 5, 611-616.
</p>
<p>Kane, M.J., Emerson, J., Weston, S. (2013). Scalable Strategies for Computing with Massive Data. Journal of Statistical Software, 55(14), 1-19. URL http://www.jstatsoft.org/v55/i14/.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+qp.bin.js">qp.bin.js</a></code>,<code><a href="#topic+icamp.cm">icamp.cm</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("example.data")
comm=example.data$comm
tree=example.data$tree
# since need to save some output to a certain folder,
# the following code is set as 'not test'.
# but you may test the code on your computer
# after change the folder path for 'pd.wd'.

  wd0=getwd() # please change to the folder you want to save the pd.big output.
  pd.wd=paste0(tempdir(),"/pdbig.icampbig")
  nworker=2 # parallel computing thread number
  rand.time=20 # usually use 1000 for real data.
  
  bin.size.limit=5 # for real data, usually use a proper number
  # according to phylogenetic signal test or try some settings
  # then choose the reasonable stochasticity level.
  # our experience is 12, or 24, or 48.
  # but for this example dataset which is too small, have to use 5.
  
  icamp.out=icamp.big(comm=comm,tree=tree,pd.wd=pd.wd,
                      rand=rand.time, nworker=nworker,
                      bin.size.limit=bin.size.limit)
  setwd(wd0)

</code></pre>

<hr>
<h2 id='icamp.bins'>
Summarize iCAMP result in each bin
</h2><span id='topic+icamp.bins'></span>

<h3>Description</h3>

<p>This function is to calculate various statistic index to assess relative importance of each process in each bin and each turnover, and bin's contribution to each process.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>icamp.bins(icamp.detail, treat = NULL, clas = NULL, silent = FALSE,
          boot = FALSE, rand.time = 1000, between.group = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="icamp.bins_+3A_icamp.detail">icamp.detail</code></td>
<td>
<p>list object, the output or the &quot;detail&quot; element of the output from <code><a href="#topic+icamp.big">icamp.big</a></code></p>
</td></tr>
<tr><td><code id="icamp.bins_+3A_treat">treat</code></td>
<td>
<p>matrix or data.frame, indicating the group or treatment of each sample, rownames are sample IDs. Allow to input multi-column matrix, different columns represent different ways to group the samples.</p>
</td></tr>
<tr><td><code id="icamp.bins_+3A_clas">clas</code></td>
<td>
<p>matrix or data.frame, the classification information of species (OTUs).</p>
</td></tr>
<tr><td><code id="icamp.bins_+3A_silent">silent</code></td>
<td>
<p>Logic, whether to show messages. Default is FALSE, thus all messages will be showed.</p>
</td></tr>
<tr><td><code id="icamp.bins_+3A_boot">boot</code></td>
<td>
<p>Logic, whether to do bootstrapping test to get significance of dominating process in each bin.</p>
</td></tr>
<tr><td><code id="icamp.bins_+3A_rand.time">rand.time</code></td>
<td>
<p>integer, bootstrapping times.</p>
</td></tr>
<tr><td><code id="icamp.bins_+3A_between.group">between.group</code></td>
<td>
<p>Logic, whether to analyze between-treatment turnovers.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Bin level analysis can provide insights into community assembly mechanisms. This function provides more detailed statistics with the output of the main function <code><a href="#topic+icamp.big">icamp.big</a></code>.
</p>


<h3>Value</h3>

<p>Output is a list object.
</p>
<table>
<tr><td><code>Wtuvk</code></td>
<td>
<p>The dominant process in each turnover of each bin.</p>
</td></tr>
<tr><td><code>Ptuv</code></td>
<td>
<p>Relative importance of each process in governing the turnovers between each pair of communities (samples).</p>
</td></tr>
<tr><td><code>Ptk</code></td>
<td>
<p>Relative importance of each process in governing the turnovers of each bin among a group of samples.</p>
</td></tr>
<tr><td><code>Pt</code></td>
<td>
<p>Relative importance of each process in governing the turnovers in a group of samples.</p>
</td></tr>
<tr><td><code>BPtk</code></td>
<td>
<p>Bin contribution to each process, measuring the contribution of each bin to the relative importance of each process in the assembly of a group of communities.</p>
</td></tr>
<tr><td><code>BRPtk</code></td>
<td>
<p>Bin relative contribution to each process, measuring the relative contribution of each bin to a certain process.</p>
</td></tr>
<tr><td><code>Binwt</code></td>
<td>
<p>Output if treat is given. Bin relative abundance in each group (treatment) of samples.</p>
</td></tr>
<tr><td><code>Bin.TopClass</code></td>
<td>
<p>Output if clas is given. A matrix showing the bin relative abundance; the top taxon ID, percentage in bin, and classification; the most abundant name at each phylogeny level in the bin.</p>
</td></tr>
<tr><td><code>Class.Bin</code></td>
<td>
<p>Output if clas is given. A matrix showing the bin ID and classification information for each taxon.</p>
</td></tr>
</table>


<h3>Note</h3>

<p>Version 3: 2021.1.5, fix the error when a tanoxomy name has unrecognizable character.
Version 2: 2020.8.19, update help document, add example.
Version 1: 2019.12.11
</p>


<h3>Author(s)</h3>

<p>Daliang Ning
</p>


<h3>References</h3>

<p>Ning, D., Yuan, M., Wu, L., Zhang, Y., Guo, X., Zhou, X. et al. (2020). A quantitative framework reveals ecological drivers of grassland microbial community assembly in response to warming. Nature Communications, 11, 4717.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+icamp.big">icamp.big</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("icamp.out")
data("example.data")
treatment=example.data$treat
classification=example.data$classification
rand.time=20 # usually use 1000 for real data.
icampbin=icamp.bins(icamp.detail = icamp.out, treat = treatment,
                    clas = classification, boot = TRUE,
                    rand.time = rand.time, between.group = TRUE)
</code></pre>

<hr>
<h2 id='icamp.boot'>
Bootstrapping analysis of icamp results
</h2><span id='topic+icamp.boot'></span>

<h3>Description</h3>

<p>Use bootstrapping to estimate the variation of relative importance of each process in each group, and compare the difference between groups.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>icamp.boot(icamp.result, treat, rand.time = 1000, compare = TRUE,
           silent = FALSE, between.group = FALSE, ST.estimation = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="icamp.boot_+3A_icamp.result">icamp.result</code></td>
<td>
<p>data.frame object, from the output of <code><a href="#topic+icamp.big">icamp.big</a></code>. the first two columns are sample IDs, the third to seventh columns are the relative importance of the five ecological processes.</p>
</td></tr>
<tr><td><code id="icamp.boot_+3A_treat">treat</code></td>
<td>
<p>matrix or data.frame, a one-column (n x 1) matrix indicating the group or treatment of each sample, rownames are sample IDs. if input a n x m matrix, only the first column is used.</p>
</td></tr>
<tr><td><code id="icamp.boot_+3A_rand.time">rand.time</code></td>
<td>
<p>integer, bootstrapping times. default is 1000.</p>
</td></tr>
<tr><td><code id="icamp.boot_+3A_compare">compare</code></td>
<td>
<p>logic, whether to compare icamp reults between different groups.</p>
</td></tr>
<tr><td><code id="icamp.boot_+3A_silent">silent</code></td>
<td>
<p>logic, if FALSE, some messages will show during calculation.</p>
</td></tr>
<tr><td><code id="icamp.boot_+3A_between.group">between.group</code></td>
<td>
<p>logic, whether to analyze between-treatment turnovers.</p>
</td></tr>
<tr><td><code id="icamp.boot_+3A_st.estimation">ST.estimation</code></td>
<td>
<p>logic, whether to estimate stochasticity as the total relative importance of dispersal and drift.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Bootstrapping is implemented by random draw samples with replacement, to estimate the variation of relative importance of each process in each group, and calculate the relative difference, effect size, and significance of the difference between each two groups.</p>


<h3>Value</h3>

<p>Output is a list with three elements.
</p>
<table>
<tr><td><code>summary</code></td>
<td>
<p>data.frame, summary of each group.
</p>
<p>Group: group name from the input &quot;treat&quot;.
</p>
<p>Process: process name from the icamp.result.
</p>
<p>Observed: the mean relative importance of each process in each group.
</p>
<p>Mean, Stdev, Min, Quartile25, Median, Quartile75, and Max: mean, standard deviation, minimum, 25 percent-quantile, median, 75 percent-quantile, and maximum of bootstrapping results, respectively.
</p>
<p>Lower.whisker, Lower.hinge, Mediean.1, Higher.hinge, Higher.whisker, Outerlier1...: boxplot elements.</p>
</td></tr>
<tr><td><code>compare</code></td>
<td>
<p>data.frame, summary of comaprison between each two groups. First two columns are group names. From the third column, different indexes for comparison are showed, including Cohen's d (Cohen.d), effect size magnitude according to Cohen's d (Effect.Size), and P value from bootstrapping test (P.value).</p>
</td></tr>
<tr><td><code>boot.detail</code></td>
<td>
<p>a list of matrixes, each matrix corresponds to a group, showing detailed bootstrapping results in each random draw.</p>
</td></tr>
</table>


<h3>Note</h3>

<p>Version 4: 2021.7.1, fix a bug leading to zero cohen's d.
Version 3: 2021.1.5, fix error when there is no outlier.
Version 2: 2020.8.19, update help document, add example.
Version 1: 2019.11.14
</p>


<h3>Author(s)</h3>

<p>Daliang Ning
</p>


<h3>References</h3>

<p>Ning, D., Yuan, M., Wu, L., Zhang, Y., Guo, X., Zhou, X. et al. (2020). A quantitative framework reveals ecological drivers of grassland microbial community assembly in response to warming. Nature Communications, 11, 4717.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+icamp.big">icamp.big</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("icamp.out")
data("example.data")
treatment=example.data$treat
rand.time=20 # usually use 1000 for real data.
icampbt=icamp.boot(icamp.result = icamp.out$bNRIiRCa, treat = treatment,
                   rand.time = rand.time, compare = TRUE,
                   between.group = TRUE, ST.estimation = TRUE)
</code></pre>

<hr>
<h2 id='icamp.cate'>
Summarize iCAMP result for different categories of taxa
</h2><span id='topic+icamp.cate'></span>

<h3>Description</h3>

<p>This function is to calculate various statistic index to assess relative importance of each process on different categories of taxa. The categories can be defined in various ways. For example, core, consistently and occasionally rare taxa; or different phyla; or various particular functional groups.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>icamp.cate(icamp.bins.result, comm, cate, treat = NULL,
           silent = FALSE, between.group = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="icamp.cate_+3A_icamp.bins.result">icamp.bins.result</code></td>
<td>
<p>list object, the output from <code><a href="#topic+icamp.bins">icamp.bins</a></code></p>
</td></tr>
<tr><td><code id="icamp.cate_+3A_comm">comm</code></td>
<td>
<p>matrix or data.frame, community data, each row is a sample or site, each colname is a taxon (a species or OTU or ASV), thus rownames should be sample IDs, colnames should be taxa IDs.</p>
</td></tr>
<tr><td><code id="icamp.cate_+3A_cate">cate</code></td>
<td>
<p>matrix or data.frame, indicating the category of each taxon, rownames are taxa IDs. If the matrix has multiple columns, only the first column will be used.</p>
</td></tr>
<tr><td><code id="icamp.cate_+3A_treat">treat</code></td>
<td>
<p>matrix or data.frame, indicating the group or treatment of each sample, rownames are sample IDs. Allow to input multi-column matrix, different columns represent different ways to group the samples.</p>
</td></tr>
<tr><td><code id="icamp.cate_+3A_silent">silent</code></td>
<td>
<p>logic, if FALSE, some messages will show during calculation.</p>
</td></tr>
<tr><td><code id="icamp.cate_+3A_between.group">between.group</code></td>
<td>
<p>logic, whether to analyze between-treatment turnovers.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function simply sums up the relative abundance of taxa of a category in different bins governed by a process to summarize the relative importance of the process on the category.
</p>


<h3>Value</h3>

<p>Output is a list object.
</p>
<table>
<tr><td><code>Ptuvx</code></td>
<td>
<p>Relative importance of each process in governing each category's turnover between each pair of communities (samples).</p>
</td></tr>
<tr><td><code>Ptx</code></td>
<td>
<p>Relative importance of each process in governing each category's turnovers among a group of samples.</p>
</td></tr>
</table>


<h3>Note</h3>

<p>Version 3: 2021.5.24, set NA if a cate has no taxon in a turnover; solve the problem that group means of different processes do not add up to 1.
Version 2: 2021.1.7, add help document; fixed NAN error.
Version 1: 2020.12.9.
</p>


<h3>Author(s)</h3>

<p>Daliang Ning
</p>


<h3>References</h3>

<p>Ning, D., Yuan, M., Wu, L., Zhang, Y., Guo, X., Zhou, X. et al. (2020). A quantitative framework reveals ecological drivers of grassland microbial community assembly in response to warming. Nature Communications, 11, 4717.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+icamp.bins">icamp.bins</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("icamp.out")
data("example.data")
comm=example.data$comm
treatment=example.data$treat
classification=example.data$classification
rand.time=20 # usually use 1000 for real data.
# 1 # summarize each bin
icampbin=icamp.bins(icamp.detail = icamp.out, treat = treatment,
                    clas = classification, boot = TRUE,
                    rand.time = rand.time, between.group = TRUE)

# 2 # define category
cate=data.frame(type=rep("others",ncol(comm)),stringsAsFactors = FALSE)
rownames(cate)=colnames(comm)
tax.frequency=colSums(comm&gt;0)/nrow(comm)
tax.relative.ab=colMeans(comm/rowSums(comm))
cate[which(tax.frequency&gt;0.75 &amp; tax.relative.ab&gt;0.05),1]="core"
cate[which(tax.relative.ab&lt;0.02),1]="rare"

# 3 # summarize each category
icampcate=icamp.cate(icamp.bins.result = icampbin, comm = comm, cate = cate,
                     treat = treatment, silent = FALSE, between.group = TRUE)
</code></pre>

<hr>
<h2 id='icamp.cm'>
Infer community assembly mechanism by phylogenetic-bin-based null model analysis under multiple metacommunities
</h2><span id='topic+icamp.cm'></span>

<h3>Description</h3>

<p>Perform phylogenetic-bin-based null model analysis and quantify the relative importance of different processes. This function can deal with local communities under different metacommunities (regional pools).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>icamp.cm(comm, tree, meta.group = NULL, meta.com = NULL,
         meta.frequency = NULL, meta.ab = NULL,
         pd.desc = NULL, pd.spname = NULL, pd.wd = getwd(),
         rand = 1000, prefix = "iCAMP", ds = 0.2,
         pd.cut = NA, phylo.rand.scale = c("within.bin", "across.all", "both"),
         taxa.rand.scale = c("across.all", "within.bin", "both"),
         phylo.metric = c("bMPD", "bMNTD", "both", "bNRI", "bNTI"),
         sig.index = c("Confidence", "SES.RC", "SES", "RC"),
         bin.size.limit = 24, nworker = 4, memory.G = 50,
         rtree.save = FALSE, detail.save = TRUE, qp.save = TRUE,
         detail.null = FALSE, ignore.zero = TRUE, output.wd = getwd(),
         correct.special = TRUE, unit.sum = rowSums(comm),
         special.method = c("depend", "MPD", "MNTD", "both"),
         ses.cut = 1.96, rc.cut = 0.95, conf.cut = 0.975,
         omit.option = c("no", "test", "omit"), treepath.file = "path.rda",
         pd.spname.file = "pd.taxon.name.csv", pd.backingfile = "pd.bin",
         pd.desc.file = "pd.desc", taxo.metric = "bray",
         transform.method = NULL, logbase = 2, dirichlet = FALSE,
         d.cut.method = c("maxpd", "maxdroot"))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="icamp.cm_+3A_comm">comm</code></td>
<td>
<p>matrix or data.frame, community data, each row is a sample or site, each colname is a taxon (a species or OTU or ASV), thus rownames should be sample IDs, colnames should be taxa IDs.</p>
</td></tr>
<tr><td><code id="icamp.cm_+3A_tree">tree</code></td>
<td>
<p>phylogenetic tree, an object of class &quot;phylo&quot;.</p>
</td></tr>
<tr><td><code id="icamp.cm_+3A_meta.group">meta.group</code></td>
<td>
<p>matrix or data.frame, a one-column (n x 1) matrix indicating which metacommunity each sample belongs to. Rownames are sample IDs. The first column is metacommunity names. Such that different samples can belong to different metacommunities. If input a n x m matrix, only the first column is used. NULL means all samples belong to the same metacommunity. Default is NULL, means all samples from the same metacommunity.</p>
</td></tr>
<tr><td><code id="icamp.cm_+3A_meta.com">meta.com</code></td>
<td>
<p>a list object, each element is a matrix or data.frame to define abundance (or relative abundance) of taxa in a metacommunity (regional pool). The element names indicate metacommunity names, which should be consistent with the metacommunity names defined in meta.group. If there is only one metacommunity, meta.com can be a matrix or data.frame to define taxa abundance (or relative abundance) in the metacommunity. Default is NULL, means to calculate metacommunity structure from comm according to metacommunities defined in meta.group.
</p>
</td></tr>
<tr><td><code id="icamp.cm_+3A_meta.frequency">meta.frequency</code></td>
<td>
<p>matrix or data.frame, each column represents a taxon, each row represents a metacommunity (regional pool), to define the occurrence frequency of each taxon in each metacommunity. The rownames indicate metacommunity names, which should be the same as the metacommunity names in meta.group. Default setting is NULL, means to calculate meta.frequency as occurrence frequency of each taxon in comm across the samples within each metacommunity defined by meta.group.</p>
</td></tr>
<tr><td><code id="icamp.cm_+3A_meta.ab">meta.ab</code></td>
<td>
<p>matrix or data.frame, each column represents a taxon, each row represents a metacommunity (regional pool), to define the aubndance (or relative abundance) of each taxon in each metacommunity. The rownames indicate metacommunity names, which should be the same as the metacommunity names in meta.group. Default setting is NULL, means to calculate meta.ab as average relative abundance of each taxon in comm across the samples within each metacommunity defined by meta.group.</p>
</td></tr>
<tr><td><code id="icamp.cm_+3A_pd.desc">pd.desc</code></td>
<td>
<p>the name of the file to hold the backingfile description of the phylogenetic distance matrix, it is usually &quot;pd.desc&quot; if using default setting in pdist.big function. If it is NULL, the fucntion pd.big will be used to calculate the phylogenetic distance matrix from tree, and save it in pd.wd as a big.memory file.</p>
</td></tr>
<tr><td><code id="icamp.cm_+3A_pd.spname">pd.spname</code></td>
<td>
<p>character vector, taxa id in the same rank as the big matrix of phylogenetic distances.</p>
</td></tr>
<tr><td><code id="icamp.cm_+3A_pd.wd">pd.wd</code></td>
<td>
<p>folder path, where the bigmemmory file of the phylogenetic distance matrix are saved.</p>
</td></tr>
<tr><td><code id="icamp.cm_+3A_rand">rand</code></td>
<td>
<p>integer, randomization times. default is 1000.</p>
</td></tr>
<tr><td><code id="icamp.cm_+3A_prefix">prefix</code></td>
<td>
<p>character string, the prefix of those output files.</p>
</td></tr>
<tr><td><code id="icamp.cm_+3A_ds">ds</code></td>
<td>
<p>numeric, the general threshold of phylogenetic distance within which the phylogenetic signal is still significant. default is 0.2.</p>
</td></tr>
<tr><td><code id="icamp.cm_+3A_pd.cut">pd.cut</code></td>
<td>
<p>numeric, the distance to the tree root where the phylogenetic tree is trancated to get strict phylogenetic bins. if pd.cut is set, the distance threshold (ds) is disabled. default is NA.</p>
</td></tr>
<tr><td><code id="icamp.cm_+3A_phylo.rand.scale">phylo.rand.scale</code></td>
<td>
<p>character, the scale to randomize the taxa for phylogenetic null model. &quot;within.bin&quot; means randomization within each bin; &quot;across.all&quot; means randomization across all bins; &quot;both&quot; means to test both methods. Default setting is within.bin.</p>
</td></tr>
<tr><td><code id="icamp.cm_+3A_taxa.rand.scale">taxa.rand.scale</code></td>
<td>
<p>character, the scale to randomize the taxa for taxonomic null model. &quot;within.bin&quot; means randomization within each bin; &quot;across.all&quot; means randomization across all bins; &quot;both&quot; means to test both methods. Default setting is across.all.</p>
</td></tr>
<tr><td><code id="icamp.cm_+3A_phylo.metric">phylo.metric</code></td>
<td>
<p>character, the metric for phylogenetic null model analysis. bMPD (or bNRI), null model analysis based on beta mean pairwise distance (betaMPD); if sig.index is SES, it is beta net relatedness index (betaNRI). bMNTD (or bNTI), null model analysis based on beta mean nearest taxon distance (betaMNTD); if sig.index is SES, it is beta nearest taxon index (betaNTI). both, use null model test based on both bMPD and bMNTD. Default setting is based on bMPD.</p>
</td></tr>
<tr><td><code id="icamp.cm_+3A_sig.index">sig.index</code></td>
<td>
<p>character, the index for null model significance test. Confidence, percentage of null values less extreme than the observed value, i.e. non-parametric one-side confidence level; if set sig.index as Confidence, it will be applied to both phylogenetic and taxonomic metrics. If set as SES.RC, use standard effect size (SES) for phylogenetic metrics (i.e. betaNTI or betaNRI), and use modified Raup-Crick (RC) for taxonomic metrics (RCbray). If set as SES, use SES for both phylogenetic and taxonomic metrics. If set as RC, use RC for both phylogenetic and taxonomic metrics. default is Confidence. If input a vector, only the first one will be used.</p>
</td></tr>
<tr><td><code id="icamp.cm_+3A_bin.size.limit">bin.size.limit</code></td>
<td>
<p>integer, the minimal requirement of bin size (taxa numer in a bin). Default setting is 24.</p>
</td></tr>
<tr><td><code id="icamp.cm_+3A_nworker">nworker</code></td>
<td>
<p>integer, for parallel computing. Either a character vector of host names on which to run the worker copies of R, or a positive integer (in which case that number of copies is run on localhost). default is 4, means 4 threads will be run.</p>
</td></tr>
<tr><td><code id="icamp.cm_+3A_memory.g">memory.G</code></td>
<td>
<p>numeric, to set the memory size as you need, so that calculation of large tree will not be limited by physical memory. unit is Gb. default is 50Gb.</p>
</td></tr>
<tr><td><code id="icamp.cm_+3A_rtree.save">rtree.save</code></td>
<td>
<p>logic, whether to save the rooted tree as nwk file, if the input tree is not rooted. Default is FALSE.</p>
</td></tr>
<tr><td><code id="icamp.cm_+3A_detail.save">detail.save</code></td>
<td>
<p>logic, whether to save the details, i.e. some key objects for iCAMP analysis, as rda file. Default is TRUE.</p>
</td></tr>
<tr><td><code id="icamp.cm_+3A_qp.save">qp.save</code></td>
<td>
<p>logic, whether to save the relative importance of processes as csv file. Default is TRUE.</p>
</td></tr>
<tr><td><code id="icamp.cm_+3A_detail.null">detail.null</code></td>
<td>
<p>logic, if TRUE, the output will include all the null values. Default is FALSE. But this need to be TRUE if you want to change significance testing index later using 'change.sigindex'.</p>
</td></tr>
<tr><td><code id="icamp.cm_+3A_ignore.zero">ignore.zero</code></td>
<td>
<p>logic, in the community data matrix (comm), whether to remove the row(s)/column(s) of which the sum is zero. Default is TRUE.</p>
</td></tr>
<tr><td><code id="icamp.cm_+3A_output.wd">output.wd</code></td>
<td>
<p>a folder path, where the files will be saved when rtree.save, detail.save, or qp.save is true.</p>
</td></tr>
<tr><td><code id="icamp.cm_+3A_correct.special">correct.special</code></td>
<td>
<p>logic, whether to correct the special cases when calculating bNRI or bNTI. Default is TRUE.</p>
</td></tr>
<tr><td><code id="icamp.cm_+3A_unit.sum">unit.sum</code></td>
<td>
<p>NULL or a number or a nemeric vector. When a beta diversity index is calculated for a bin, the taxa abundances will be divided by unit.sum to calculate the relative abundances, and the Bray-Cuits index in each bin will become manhattan index divided by 2. Default setting are the row sums of community matrix, which are usually sequencing depth in each sample. If set as NULL, means not to do this special transformation.</p>
</td></tr>
<tr><td><code id="icamp.cm_+3A_special.method">special.method</code></td>
<td>
<p>When correct.special is TRUE, which method will be used to check underestimation of deterministic pattern(s) in special cases. MPD, use null model test based on mean pairwise distance; MNTD, use null model test based on mean nearest taxon distance; depend, use MPD when phylo.metric is bMPD or bNRI, and use MNTD when phylo.metric is bMNTD or bNTI; both, use both MPD and MNTD. Default is depend</p>
</td></tr>
<tr><td><code id="icamp.cm_+3A_ses.cut">ses.cut</code></td>
<td>
<p>numeric, the cutoff of significant standard effect size, default is 1.96.</p>
</td></tr>
<tr><td><code id="icamp.cm_+3A_rc.cut">rc.cut</code></td>
<td>
<p>numeric, the cutoff of significant modified Raup-Crick index value, default is 0.95.</p>
</td></tr>
<tr><td><code id="icamp.cm_+3A_conf.cut">conf.cut</code></td>
<td>
<p>numeric, the cutoff of significant one-side confidence level, default is 0.975.</p>
</td></tr>
<tr><td><code id="icamp.cm_+3A_omit.option">omit.option</code></td>
<td>
<p>three options about omitting small bins. &quot;no&quot; means to merge small bins to their nearest relatives to meet the bin size requirement, rather than omitting them; &quot;test&quot; means to output the information of small strict bins with a size lower than requirement, iCAMP will not be performed; &quot;omit&quot;  means to do iCAMP analysis with strict bins which have enough species (larger than bin size requirement).</p>
</td></tr>
<tr><td><code id="icamp.cm_+3A_treepath.file">treepath.file</code></td>
<td>
<p>character, name of the file saving the tree.path, which is a list of all the nodes and edge lengthes from root to every tip and/or node. it should be a .rda filename.</p>
</td></tr>
<tr><td><code id="icamp.cm_+3A_pd.spname.file">pd.spname.file</code></td>
<td>
<p>character, name of the file saving the taxa IDs, which has exactly the same order as the row names (and column names) of the big phylogenetic distance matrix. it should be a .csv filename.</p>
</td></tr>
<tr><td><code id="icamp.cm_+3A_pd.backingfile">pd.backingfile</code></td>
<td>
<p>character, the root name for the file for the cache of the big phylogenetic distance matrix. it should be a .bin filename.</p>
</td></tr>
<tr><td><code id="icamp.cm_+3A_pd.desc.file">pd.desc.file</code></td>
<td>
<p>character, name of the file to hold the backingfile description for the big phylogenetic distance matrix. it should be a .desc filename.</p>
</td></tr>
<tr><td><code id="icamp.cm_+3A_taxo.metric">taxo.metric</code></td>
<td>
<p>taxonomic beta diversity index, the same as 'method' in the function 'vegdist' in package 'vegan', including &quot;manhattan&quot;, &quot;euclidean&quot;, &quot;canberra&quot;, &quot;clark&quot;, &quot;bray&quot;, &quot;kulczynski&quot;, &quot;jaccard&quot;, &quot;gower&quot;, &quot;altGower&quot;, &quot;morisita&quot;, &quot;horn&quot;, &quot;mountford&quot;, &quot;raup&quot;, &quot;binomial&quot;, &quot;chao&quot;, &quot;cao&quot; or &quot;mahalanobis&quot;. If taxo.metric='bray' and transform.method=NULL, RC will be calculated based on Bray-Curtis dissimilarity as recommended in original iCAMP; otherwise, unit.sum setting will be ignored.</p>
</td></tr>
<tr><td><code id="icamp.cm_+3A_transform.method">transform.method</code></td>
<td>
<p>character or a defined function, to specify how to transform community matrix before calculating dissimilarity. if it is a characher, it should be a method name as in the function 'decostand' in package 'vegan', including 'total','max','freq','normalize','range','standardize','pa','chi.square','cmdscale','hellinger','log'.</p>
</td></tr>
<tr><td><code id="icamp.cm_+3A_logbase">logbase</code></td>
<td>
<p>numeric, the logarithm base used when transform.method='log'.</p>
</td></tr> 
<tr><td><code id="icamp.cm_+3A_dirichlet">dirichlet</code></td>
<td>
<p>Logic. If TRUE, the taxonomic null model will use Dirichlet distribution to generate relative abundances in randomized community matrix. If the input community matrix has all row sums no more than 1, the function will automatically set dirichlet=TRUE. default is FALSE.</p>
</td></tr>
<tr><td><code id="icamp.cm_+3A_d.cut.method">d.cut.method</code></td>
<td>
<p>character, to specify the method to calculate pd.cut from ds. 'maxpd' means based on maximum phylogenetic distance, pd.cut = (maxpd - ds)/2. 'maxdroot' means based on maximum distance to root, pd.cut = maxdroot - (ds/2), which is preferred if the tree only has one edge from the root.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is particularly designed for samples from different metacommunities. The null model will randomize the commuity matrix under different metacommunities, separately (and independently). All other details are the same as the function icamp.big. 
</p>


<h3>Value</h3>

<p>If omit.option is test, the output will be a table summarizing the information of small bins.
</p>
<p>Otherwise, the output is a list object, including one or more elements as below:
</p>
<p>The first one or selveral (if set 'both' for metrics and/or randomization scale) elements are matrixes of process importances at community level. In each matrix, the first two columns will be sample ID of each turnover, and the third to last column will show estimated relative importance of each process in shaping each turnover between communities (samples). The name(s) of the element(s) shows the metrics and its randomization scale, e.g. bNRIiRCa means phylogenetic null model analysis using betaNRI (i.e. SES based on betaMPD) with randomizaiton within each bin and taxonomic null model analysis using RC based on Bray-Curtis with randomization across bins. Other possible phylogenetic null-model-based metrics: bNTI, betaNTI (i.e. SES based on betaMNTD); RCbMPD, RC based on betaMPD; RCbMNTD, RC based on betaMNTD; CbMPD, confidence level based on betaMPD; CbMNTD, confidence level based on betaMNTD. Other possible taxonomic null-model-based metrics: SESbray, SES based on Bray-Curtis; CBray, confidence level based on Bray-Curtis. i, within-bin randomization; a, across-bin randomization.
</p>
<table>
<tr><td><code>detail</code></td>
<td>
<p>an element in output only if detail.save is TRUE. A list with elements as below.</p>
</td></tr>
<tr><td><code>taxabin</code></td>
<td>
<p>an element in 'detail'. A list, show phylogenetic binning results.
</p>
<p>The first element is a matrix named sp.bin, where each row is a taxon (OTU or ASV), the first column is the original strict bin ID, the second column is the original bin ID after small bins are merged into nearest relative(s), the third column is the final renewed bin ID.
</p>
<p>The second element named bin.united.sp is a list, where each element shows taxa IDs within each bin and the bins are in the order of the final renewed bin IDs.
</p>
<p>The third element named bin.strict.sp is a list, where each element shows taxa IDs within each strict bin and the bins are in the order of the original strict bin IDs.
</p>
<p>The fourth element named state.strict is a matrix, where the 1st column is orginal strict bin IDs, the 2nd column is the taxa number in each strict bin, the 3rd to 5th columns show the maximum, mean, and standard deviation of phylogenetic distances within each strict bin.
</p>
<p>The fifth element named state.united is a matrix, where the row numbering is the final bin ID, the 1st column is orginal bin IDs, the 2nd column is the taxa number in each final bin, the 3rd to 5th columns show the maximum, mean, and standard deviation of phylogenetic distances within each final bin.
</p>
</td></tr>
<tr><td><code>SigbMPDi</code>, <code>SigbMPDa</code>, <code>SigbMNTDi</code>, <code>SigbMNTDa</code>, <code>SigBCi</code>, <code>SigBCa</code></td>
<td>
<p>elements in 'detail', matrixes showing null model significance testing index for each turnover of each bin. In the name of the element(s), SigbMPD, SigMNTD, or SigBC mean the significance testing is based on betaMPD, betaMNTD, or taxonomic dissimilarity (default is Bray-Curtis); i, within-bin randomization; a, across-bin randomization. In each matrix, the first two columns are sample IDs for each turnover; the 3rd to the last column represent different bins with column names containing the significance testing index name, which can be bNRI, bNTI, RCbMPD, RCbMNTD, CbMPD, CbMNTD, SESbray, RCbray, or CBray as mentioned above.</p>
</td></tr>
<tr><td><code>bin.weight</code></td>
<td>
<p>an element in 'detail', a matrix showing relative abundance of each bin in each pair of samples.</p>
</td></tr>
<tr><td><code>processes</code></td>
<td>
<p>an element in 'detail', a list of process importance results at community level.</p>
</td></tr>
<tr><td><code>setting</code></td>
<td>
<p>an element in 'detail', a data.frame showing all basic settings of this function.</p>
</td></tr>
<tr><td><code>comm</code></td>
<td>
<p>an element in 'detail', the input community matrix.</p>
</td></tr>
<tr><td><code>rand</code></td>
<td>
<p>an element in output only if detail.null is TRUE. It is a list with each element showing the observed or null values of a beta diversity index (e.g. betaMPD, betaMNTD, Bray-Curtis). Each index is showed as a list where each element represents a bin.</p>
</td></tr>
<tr><td><code>special.crct</code></td>
<td>
<p>an element in output only if detail.null is TRUE. It shows the corrected values for special cases, where zero means no correction is needed.</p>
</td></tr>
</table>


<h3>Note</h3>

<p>Version 1: 2021.8.4
</p>


<h3>Author(s)</h3>

<p>Daliang Ning
</p>


<h3>References</h3>

<p>Ning, D., Yuan, M., Wu, L., Zhang, Y., Guo, X., Zhou, X. et al. (2020). A quantitative framework reveals ecological drivers of grassland microbial community assembly in response to warming. Nature Communications, 11, 4717.
</p>
<p>Stegen, J.C., Lin, X., Fredrickson, J.K. &amp; Konopka, A.E. (2015). Estimating and mapping ecological processes influencing microbial community assembly. Front Microbiol, 6, 370.
</p>
<p>Stegen, J.C., Lin, X., Fredrickson, J.K., Chen, X., Kennedy, D.W., Murray, C.J. et al. (2013). Quantifying community assembly processes and identifying features that impose them. ISME J, 7, 2069.
</p>
<p>Zhou, J. &amp; Ning, D. (2017). Stochastic community assembly: Does it matter in microbial ecology? Microbiology and Molecular Biology Reviews, 81.
</p>
<p>Veech, J.A. (2012). Significance testing in ecological null models. Theor Ecol, 5, 611-616.
</p>
<p>Kane, M.J., Emerson, J., Weston, S. (2013). Scalable Strategies for Computing with Massive Data. Journal of Statistical Software, 55(14), 1-19. URL http://www.jstatsoft.org/v55/i14/.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+icamp.big">icamp.big</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("example.data")
comm=example.data$comm
tree=example.data$tree

# in this example, 10 samples from one metacommunity,
# the other 10 samples from another metacommunity.
meta.group=data.frame(meta.com=c(rep("meta1",10),rep("meta2",10)))
rownames(meta.group)=rownames(comm)

# since need to save some output to a certain folder,
# the following code is set as 'not test'.
# but you may test the code on your computer
# after change the folder path for 'save.wd'.

  wd0=getwd() # please change to the folder you want to save the pd.big output.
  save.wd=paste0(tempdir(),"/pdbig.icampcm")
  nworker=2 # parallel computing thread number
  rand.time=20 # usually use 1000 for real data.
  
  bin.size.limit=5 # for real data, usually use a proper number
  # according to phylogenetic signal test or try some settings
  # then choose the reasonable stochasticity level.
  # our experience is 12, or 24, or 48.
  # but for this example dataset which is too small, have to use 5.
  
  icamp.out=icamp.cm(comm=comm, tree=tree, meta.group=meta.group,
                     pd.wd=save.wd, rand=rand.time, nworker=nworker,
                     bin.size.limit=bin.size.limit)
  setwd(wd0)

</code></pre>

<hr>
<h2 id='icamp.cm2'>
Phylogenetic-bin-based null model analysis under different metacommunity settings for phylogenetic and taxonomic null models
</h2><span id='topic+icamp.cm2'></span>

<h3>Description</h3>

<p>Perform phylogenetic-bin-based null model analysis and quantify the relative importance of different processes. This function can deal with local communities under different metacommunities (regional pools), and different metacommunity settings for phylogenetic and taxonomic models
</p>


<h3>Usage</h3>

<pre><code class='language-R'>icamp.cm2(comm, tree, meta.group.phy = NULL, meta.com.phy = NULL,
          meta.frequency.phy = NULL, meta.ab.phy = NULL,
          meta.group.tax = NULL, meta.com.tax = NULL,
          meta.frequency.tax = NULL, meta.ab.tax = NULL,
          pd.desc = NULL, pd.spname = NULL, pd.wd = getwd(),
          rand = 1000, prefix = "iCAMP", ds = 0.2, pd.cut = NA,
          phylo.rand.scale = c("within.bin", "across.all", "both"),
          taxa.rand.scale = c("across.all", "within.bin", "both"),
          phylo.metric = c("bMPD", "bMNTD", "both", "bNRI", "bNTI"),
          sig.index = c("Confidence", "SES.RC", "SES", "RC"),
          bin.size.limit = 24, nworker = 4, memory.G = 50,
          rtree.save = FALSE, detail.save = TRUE, qp.save = TRUE,
          detail.null = FALSE, ignore.zero = TRUE, output.wd = getwd(),
          correct.special = TRUE, unit.sum = rowSums(comm),
          special.method = c("depend", "MPD", "MNTD", "both"),
          ses.cut = 1.96, rc.cut = 0.95, conf.cut = 0.975,
          omit.option = c("no", "test", "omit"),
          treepath.file = "path.rda", pd.spname.file = "pd.taxon.name.csv",
          pd.backingfile = "pd.bin", pd.desc.file = "pd.desc",
          taxo.metric = "bray", transform.method = NULL, logbase = 2,
          dirichlet = FALSE, d.cut.method = c("maxpd", "maxdroot"))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="icamp.cm2_+3A_comm">comm</code></td>
<td>
<p>matrix or data.frame, community data, each row is a sample or site, each colname is a taxon (a species or OTU or ASV), thus rownames should be sample IDs, colnames should be taxa IDs.</p>
</td></tr>
<tr><td><code id="icamp.cm2_+3A_tree">tree</code></td>
<td>
<p>phylogenetic tree, an object of class &quot;phylo&quot;.</p>
</td></tr>
<tr><td><code id="icamp.cm2_+3A_meta.group.phy">meta.group.phy</code></td>
<td>
<p>matrix or data.frame, a one-column (n x 1) matrix indicating which metacommunity each sample belongs to in the null model for phylogenetic beta diversity. Rownames are sample IDs. The first column is metacommunity names. Such that different samples can belong to different metacommunities. If input a n x m matrix, only the first column is used. NULL means all samples belong to the same metacommunity. Default is NULL, means all samples from the same metacommunity.</p>
</td></tr>
<tr><td><code id="icamp.cm2_+3A_meta.com.phy">meta.com.phy</code></td>
<td>
<p>a list object, each element is a matrix or data.frame to define abundance (or relative abundance) of taxa in a metacommunity (regional pool) in the null model for phylogenetic beta diversity. The element names indicate metacommunity names, which should be consistent with the metacommunity names defined in meta.group. If there is only one metacommunity, meta.com can be a matrix or data.frame to define taxa abundance (or relative abundance) in the metacommunity. Default is NULL, means to calculate metacommunity structure from comm according to metacommunities defined in meta.group.
</p>
</td></tr>
<tr><td><code id="icamp.cm2_+3A_meta.frequency.phy">meta.frequency.phy</code></td>
<td>
<p>matrix or data.frame, each column represents a taxon, each row represents a metacommunity (regional pool), to define the occurrence frequency of each taxon in each metacommunity in the null model for phylogenetic beta diversity. The rownames indicate metacommunity names, which should be the same as the metacommunity names in meta.group. Default setting is NULL, means to calculate meta.frequency as occurrence frequency of each taxon in comm across the samples within each metacommunity defined by meta.group.</p>
</td></tr>
<tr><td><code id="icamp.cm2_+3A_meta.ab.phy">meta.ab.phy</code></td>
<td>
<p>matrix or data.frame, each column represents a taxon, each row represents a metacommunity (regional pool), to define the aubndance (or relative abundance) of each taxon in each metacommunity in the null model for phylogenetic beta diversity. The rownames indicate metacommunity names, which should be the same as the metacommunity names in meta.group. Default setting is NULL, means to calculate meta.ab as average relative abundance of each taxon in comm across the samples within each metacommunity defined by meta.group.</p>
</td></tr>
<tr><td><code id="icamp.cm2_+3A_meta.group.tax">meta.group.tax</code></td>
<td>
<p>the same format as meta.group.phy, but for taxonomic null model.</p>
</td></tr>
<tr><td><code id="icamp.cm2_+3A_meta.com.tax">meta.com.tax</code></td>
<td>
<p>the same format as meta.com.phy, but for taxonomic null model.</p>
</td></tr>
<tr><td><code id="icamp.cm2_+3A_meta.frequency.tax">meta.frequency.tax</code></td>
<td>
<p>the same format as meta.frequency.phy, but for taxonomic null model.</p>
</td></tr>
<tr><td><code id="icamp.cm2_+3A_meta.ab.tax">meta.ab.tax</code></td>
<td>
<p>the same format as meta.ab.phy, but for taxonomic null model.</p>
</td></tr>
<tr><td><code id="icamp.cm2_+3A_pd.desc">pd.desc</code></td>
<td>
<p>the name of the file to hold the backingfile description of the phylogenetic distance matrix, it is usually &quot;pd.desc&quot; if using default setting in pdist.big function. If it is NULL, the fucntion pd.big will be used to calculate the phylogenetic distance matrix from tree, and save it in pd.wd as a big.memory file.</p>
</td></tr>
<tr><td><code id="icamp.cm2_+3A_pd.spname">pd.spname</code></td>
<td>
<p>character vector, taxa id in the same rank as the big matrix of phylogenetic distances.</p>
</td></tr>
<tr><td><code id="icamp.cm2_+3A_pd.wd">pd.wd</code></td>
<td>
<p>folder path, where the bigmemmory file of the phylogenetic distance matrix are saved.</p>
</td></tr>
<tr><td><code id="icamp.cm2_+3A_rand">rand</code></td>
<td>
<p>integer, randomization times. default is 1000.</p>
</td></tr>
<tr><td><code id="icamp.cm2_+3A_prefix">prefix</code></td>
<td>
<p>character string, the prefix of those output files.</p>
</td></tr>
<tr><td><code id="icamp.cm2_+3A_ds">ds</code></td>
<td>
<p>numeric, the general threshold of phylogenetic distance within which the phylogenetic signal is still significant. default is 0.2.</p>
</td></tr>
<tr><td><code id="icamp.cm2_+3A_pd.cut">pd.cut</code></td>
<td>
<p>numeric, the distance to the tree root where the phylogenetic tree is trancated to get strict phylogenetic bins. if pd.cut is set, the distance threshold (ds) is disabled. default is NA.</p>
</td></tr>
<tr><td><code id="icamp.cm2_+3A_phylo.rand.scale">phylo.rand.scale</code></td>
<td>
<p>character, the scale to randomize the taxa for phylogenetic null model. &quot;within.bin&quot; means randomization within each bin; &quot;across.all&quot; means randomization across all bins; &quot;both&quot; means to test both methods. Default setting is within.bin.</p>
</td></tr>
<tr><td><code id="icamp.cm2_+3A_taxa.rand.scale">taxa.rand.scale</code></td>
<td>
<p>character, the scale to randomize the taxa for taxonomic null model. &quot;within.bin&quot; means randomization within each bin; &quot;across.all&quot; means randomization across all bins; &quot;both&quot; means to test both methods. Default setting is across.all.</p>
</td></tr>
<tr><td><code id="icamp.cm2_+3A_phylo.metric">phylo.metric</code></td>
<td>
<p>character, the metric for phylogenetic null model analysis. bMPD (or bNRI), null model analysis based on beta mean pairwise distance (betaMPD); if sig.index is SES, it is beta net relatedness index (betaNRI). bMNTD (or bNTI), null model analysis based on beta mean nearest taxon distance (betaMNTD); if sig.index is SES, it is beta nearest taxon index (betaNTI). both, use null model test based on both bMPD and bMNTD. Default setting is based on bMPD.</p>
</td></tr>
<tr><td><code id="icamp.cm2_+3A_sig.index">sig.index</code></td>
<td>
<p>character, the index for null model significance test. Confidence, percentage of null values less extreme than the observed value, i.e. non-parametric one-side confidence level; if set sig.index as Confidence, it will be applied to both phylogenetic and taxonomic metrics. If set as SES.RC, use standard effect size (SES) for phylogenetic metrics (i.e. betaNTI or betaNRI), and use modified Raup-Crick (RC) for taxonomic metrics (RCbray). If set as SES, use SES for both phylogenetic and taxonomic metrics. If set as RC, use RC for both phylogenetic and taxonomic metrics. default is Confidence. If input a vector, only the first one will be used.</p>
</td></tr>
<tr><td><code id="icamp.cm2_+3A_bin.size.limit">bin.size.limit</code></td>
<td>
<p>integer, the minimal requirement of bin size (taxa numer in a bin). Default setting is 24.</p>
</td></tr>
<tr><td><code id="icamp.cm2_+3A_nworker">nworker</code></td>
<td>
<p>integer, for parallel computing. Either a character vector of host names on which to run the worker copies of R, or a positive integer (in which case that number of copies is run on localhost). default is 4, means 4 threads will be run.</p>
</td></tr>
<tr><td><code id="icamp.cm2_+3A_memory.g">memory.G</code></td>
<td>
<p>numeric, to set the memory size as you need, so that calculation of large tree will not be limited by physical memory. unit is Gb. default is 50Gb.</p>
</td></tr>
<tr><td><code id="icamp.cm2_+3A_rtree.save">rtree.save</code></td>
<td>
<p>logic, whether to save the rooted tree as nwk file, if the input tree is not rooted. Default is FALSE.</p>
</td></tr>
<tr><td><code id="icamp.cm2_+3A_detail.save">detail.save</code></td>
<td>
<p>logic, whether to save the details, i.e. some key objects for iCAMP analysis, as rda file. Default is TRUE.</p>
</td></tr>
<tr><td><code id="icamp.cm2_+3A_qp.save">qp.save</code></td>
<td>
<p>logic, whether to save the relative importance of processes as csv file. Default is TRUE.</p>
</td></tr>
<tr><td><code id="icamp.cm2_+3A_detail.null">detail.null</code></td>
<td>
<p>logic, if TRUE, the output will include all the null values. Default is FALSE. But this need to be TRUE if you want to change significance testing index later using 'change.sigindex'.</p>
</td></tr>
<tr><td><code id="icamp.cm2_+3A_ignore.zero">ignore.zero</code></td>
<td>
<p>logic, in the community data matrix (comm), whether to remove the row(s)/column(s) of which the sum is zero. Default is TRUE.</p>
</td></tr>
<tr><td><code id="icamp.cm2_+3A_output.wd">output.wd</code></td>
<td>
<p>a folder path, where the files will be saved when rtree.save, detail.save, or qp.save is true.</p>
</td></tr>
<tr><td><code id="icamp.cm2_+3A_correct.special">correct.special</code></td>
<td>
<p>logic, whether to correct the special cases when calculating bNRI or bNTI. Default is TRUE.</p>
</td></tr>
<tr><td><code id="icamp.cm2_+3A_unit.sum">unit.sum</code></td>
<td>
<p>NULL or a number or a nemeric vector. When a beta diversity index is calculated for a bin, the taxa abundances will be divided by unit.sum to calculate the relative abundances, and the Bray-Cuits index in each bin will become manhattan index divided by 2. Default setting are the row sums of community matrix, which are usually sequencing depth in each sample. If set as NULL, means not to do this special transformation.</p>
</td></tr>
<tr><td><code id="icamp.cm2_+3A_special.method">special.method</code></td>
<td>
<p>When correct.special is TRUE, which method will be used to check underestimation of deterministic pattern(s) in special cases. MPD, use null model test based on mean pairwise distance; MNTD, use null model test based on mean nearest taxon distance; depend, use MPD when phylo.metric is bMPD or bNRI, and use MNTD when phylo.metric is bMNTD or bNTI; both, use both MPD and MNTD. Default is depend</p>
</td></tr>
<tr><td><code id="icamp.cm2_+3A_ses.cut">ses.cut</code></td>
<td>
<p>numeric, the cutoff of significant standard effect size, default is 1.96.</p>
</td></tr>
<tr><td><code id="icamp.cm2_+3A_rc.cut">rc.cut</code></td>
<td>
<p>numeric, the cutoff of significant modified Raup-Crick index value, default is 0.95.</p>
</td></tr>
<tr><td><code id="icamp.cm2_+3A_conf.cut">conf.cut</code></td>
<td>
<p>numeric, the cutoff of significant one-side confidence level, default is 0.975.</p>
</td></tr>
<tr><td><code id="icamp.cm2_+3A_omit.option">omit.option</code></td>
<td>
<p>three options about omitting small bins. &quot;no&quot; means to merge small bins to their nearest relatives to meet the bin size requirement, rather than omitting them; &quot;test&quot; means to output the information of small strict bins with a size lower than requirement, iCAMP will not be performed; &quot;omit&quot;  means to do iCAMP analysis with strict bins which have enough species (larger than bin size requirement).</p>
</td></tr>
<tr><td><code id="icamp.cm2_+3A_treepath.file">treepath.file</code></td>
<td>
<p>character, name of the file saving the tree.path, which is a list of all the nodes and edge lengthes from root to every tip and/or node. it should be a .rda filename.</p>
</td></tr>
<tr><td><code id="icamp.cm2_+3A_pd.spname.file">pd.spname.file</code></td>
<td>
<p>character, name of the file saving the taxa IDs, which has exactly the same order as the row names (and column names) of the big phylogenetic distance matrix. it should be a .csv filename.</p>
</td></tr>
<tr><td><code id="icamp.cm2_+3A_pd.backingfile">pd.backingfile</code></td>
<td>
<p>character, the root name for the file for the cache of the big phylogenetic distance matrix. it should be a .bin filename.</p>
</td></tr>
<tr><td><code id="icamp.cm2_+3A_pd.desc.file">pd.desc.file</code></td>
<td>
<p>character, name of the file to hold the backingfile description for the big phylogenetic distance matrix. it should be a .desc filename.</p>
</td></tr>
<tr><td><code id="icamp.cm2_+3A_taxo.metric">taxo.metric</code></td>
<td>
<p>taxonomic beta diversity index, the same as 'method' in the function 'vegdist' in package 'vegan', including &quot;manhattan&quot;, &quot;euclidean&quot;, &quot;canberra&quot;, &quot;clark&quot;, &quot;bray&quot;, &quot;kulczynski&quot;, &quot;jaccard&quot;, &quot;gower&quot;, &quot;altGower&quot;, &quot;morisita&quot;, &quot;horn&quot;, &quot;mountford&quot;, &quot;raup&quot;, &quot;binomial&quot;, &quot;chao&quot;, &quot;cao&quot; or &quot;mahalanobis&quot;. If taxo.metric='bray' and transform.method=NULL, RC will be calculated based on Bray-Curtis dissimilarity as recommended in original iCAMP; otherwise, unit.sum setting will be ignored.</p>
</td></tr>
<tr><td><code id="icamp.cm2_+3A_transform.method">transform.method</code></td>
<td>
<p>character or a defined function, to specify how to transform community matrix before calculating dissimilarity. if it is a characher, it should be a method name as in the function 'decostand' in package 'vegan', including 'total','max','freq','normalize','range','standardize','pa','chi.square','cmdscale','hellinger','log'.</p>
</td></tr>
<tr><td><code id="icamp.cm2_+3A_logbase">logbase</code></td>
<td>
<p>numeric, the logarithm base used when transform.method='log'.</p>
</td></tr> 
<tr><td><code id="icamp.cm2_+3A_dirichlet">dirichlet</code></td>
<td>
<p>Logic. If TRUE, the taxonomic null model will use Dirichlet distribution to generate relative abundances in randomized community matrix. If the input community matrix has all row sums no more than 1, the function will automatically set dirichlet=TRUE. default is FALSE.</p>
</td></tr>
<tr><td><code id="icamp.cm2_+3A_d.cut.method">d.cut.method</code></td>
<td>
<p>character, to specify the method to calculate pd.cut from ds. 'maxpd' means based on maximum phylogenetic distance, pd.cut = (maxpd - ds)/2. 'maxdroot' means based on maximum distance to root, pd.cut = maxdroot - (ds/2), which is preferred if the tree only has one edge from the root.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is particularly designed for samples from different metacommunities, and allows phylogenetic and taxonomic null models have different settings of metacommunities. The null model will randomize the commuity matrix under different metacommunities, separately (and independently). All other details are the same as the function icamp.big. 
</p>


<h3>Value</h3>

<p>If omit.option is test, the output will be a table summarizing the information of small bins.
</p>
<p>Otherwise, the output is a list object, including one or more elements as below:
</p>
<p>The first one or selveral (if set 'both' for metrics and/or randomization scale) elements are matrixes of process importances at community level. In each matrix, the first two columns will be sample ID of each turnover, and the third to last column will show estimated relative importance of each process in shaping each turnover between communities (samples). The name(s) of the element(s) shows the metrics and its randomization scale, e.g. bNRIiRCa means phylogenetic null model analysis using betaNRI (i.e. SES based on betaMPD) with randomizaiton within each bin and taxonomic null model analysis using RC based on Bray-Curtis with randomization across bins. Other possible phylogenetic null-model-based metrics: bNTI, betaNTI (i.e. SES based on betaMNTD); RCbMPD, RC based on betaMPD; RCbMNTD, RC based on betaMNTD; CbMPD, confidence level based on betaMPD; CbMNTD, confidence level based on betaMNTD. Other possible taxonomic null-model-based metrics: SESbray, SES based on Bray-Curtis; CBray, confidence level based on Bray-Curtis. i, within-bin randomization; a, across-bin randomization.
</p>
<table>
<tr><td><code>detail</code></td>
<td>
<p>an element in output only if detail.save is TRUE. A list with elements as below.</p>
</td></tr>
<tr><td><code>taxabin</code></td>
<td>
<p>an element in 'detail'. A list, show phylogenetic binning results.
</p>
<p>The first element is a matrix named sp.bin, where each row is a taxon (OTU or ASV), the first column is the original strict bin ID, the second column is the original bin ID after small bins are merged into nearest relative(s), the third column is the final renewed bin ID.
</p>
<p>The second element named bin.united.sp is a list, where each element shows taxa IDs within each bin and the bins are in the order of the final renewed bin IDs.
</p>
<p>The third element named bin.strict.sp is a list, where each element shows taxa IDs within each strict bin and the bins are in the order of the original strict bin IDs.
</p>
<p>The fourth element named state.strict is a matrix, where the 1st column is orginal strict bin IDs, the 2nd column is the taxa number in each strict bin, the 3rd to 5th columns show the maximum, mean, and standard deviation of phylogenetic distances within each strict bin.
</p>
<p>The fifth element named state.united is a matrix, where the row numbering is the final bin ID, the 1st column is orginal bin IDs, the 2nd column is the taxa number in each final bin, the 3rd to 5th columns show the maximum, mean, and standard deviation of phylogenetic distances within each final bin.
</p>
</td></tr>
<tr><td><code>SigbMPDi</code>, <code>SigbMPDa</code>, <code>SigbMNTDi</code>, <code>SigbMNTDa</code>, <code>SigBCi</code>, <code>SigBCa</code></td>
<td>
<p>elements in 'detail', matrixes showing null model significance testing index for each turnover of each bin. In the name of the element(s), SigbMPD, SigMNTD, or SigBC mean the significance testing is based on betaMPD, betaMNTD, or taxonomic dissimilarity (default is Bray-Curtis); i, within-bin randomization; a, across-bin randomization. In each matrix, the first two columns are sample IDs for each turnover; the 3rd to the last column represent different bins with column names containing the significance testing index name, which can be bNRI, bNTI, RCbMPD, RCbMNTD, CbMPD, CbMNTD, SESbray, RCbray, or CBray as mentioned above.</p>
</td></tr>
<tr><td><code>bin.weight</code></td>
<td>
<p>an element in 'detail', a matrix showing relative abundance of each bin in each pair of samples.</p>
</td></tr>
<tr><td><code>processes</code></td>
<td>
<p>an element in 'detail', a list of process importance results at community level.</p>
</td></tr>
<tr><td><code>setting</code></td>
<td>
<p>an element in 'detail', a data.frame showing all basic settings of this function.</p>
</td></tr>
<tr><td><code>comm</code></td>
<td>
<p>an element in 'detail', the input community matrix.</p>
</td></tr>
<tr><td><code>rand</code></td>
<td>
<p>an element in output only if detail.null is TRUE. It is a list with each element showing the observed or null values of a beta diversity index (e.g. betaMPD, betaMNTD, Bray-Curtis). Each index is showed as a list where each element represents a bin.</p>
</td></tr>
<tr><td><code>special.crct</code></td>
<td>
<p>an element in output only if detail.null is TRUE. It shows the corrected values for special cases, where zero means no correction is needed.</p>
</td></tr>
</table>


<h3>Note</h3>

<p>Version 1: 2022.2.10
</p>


<h3>Author(s)</h3>

<p>Daliang Ning
</p>


<h3>References</h3>

<p>Ning, D., Yuan, M., Wu, L., Zhang, Y., Guo, X., Zhou, X. et al. (2020). A quantitative framework reveals ecological drivers of grassland microbial community assembly in response to warming. Nature Communications, 11, 4717.
</p>
<p>Stegen, J.C., Lin, X., Fredrickson, J.K. &amp; Konopka, A.E. (2015). Estimating and mapping ecological processes influencing microbial community assembly. Front Microbiol, 6, 370.
</p>
<p>Stegen, J.C., Lin, X., Fredrickson, J.K., Chen, X., Kennedy, D.W., Murray, C.J. et al. (2013). Quantifying community assembly processes and identifying features that impose them. ISME J, 7, 2069.
</p>
<p>Zhou, J. &amp; Ning, D. (2017). Stochastic community assembly: Does it matter in microbial ecology? Microbiology and Molecular Biology Reviews, 81.
</p>
<p>Veech, J.A. (2012). Significance testing in ecological null models. Theor Ecol, 5, 611-616.
</p>
<p>Kane, M.J., Emerson, J., Weston, S. (2013). Scalable Strategies for Computing with Massive Data. Journal of Statistical Software, 55(14), 1-19. URL http://www.jstatsoft.org/v55/i14/.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+icamp.big">icamp.big</a></code>,<code><a href="#topic+icamp.cm">icamp.cm</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("example.data")
comm=example.data$comm
tree=example.data$tree

# in this example, 10 samples from one metacommunity,
# the other 10 samples from another metacommunity.
meta.group=data.frame(meta.com=c(rep("meta1",10),rep("meta2",10)))
rownames(meta.group)=rownames(comm)

# since need to save some output to a certain folder,
# the following code is set as 'not test'.
# but you may test the code on your computer
# after change the folder path for 'save.wd'.

  wd0=getwd() # please change to the folder you want to save the pd.big output.
  save.wd=paste0(tempdir(),"/pdbig.icampcm2")
  nworker=2 # parallel computing thread number
  rand.time=20 # usually use 1000 for real data.
  
  bin.size.limit=5 # for real data, usually use a proper number
  # according to phylogenetic signal test or try some settings
  # then choose the reasonable stochasticity level.
  # our experience is 12, or 24, or 48.
  # but for this example dataset which is too small, have to use 5.
  
  icamp.out=icamp.cm2(comm=comm, tree=tree, meta.group.phy=meta.group,
                     meta.group.tax=NULL, pd.wd=save.wd, rand=rand.time,
                     nworker=nworker, bin.size.limit=bin.size.limit)
  setwd(wd0)

</code></pre>

<hr>
<h2 id='icamp.out'>
Example output of function icamp.big
</h2><span id='topic+icamp.out'></span>

<h3>Description</h3>

<p>a typical output of icamp.big.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data("icamp.out")</code></pre>


<h3>Format</h3>

<p>The format is:
List of 4
$ bNRIiRCa    :'data.frame':	190 obs. of  7 variables:
..$ sample1                : Factor w/ 19 levels &quot;s10&quot;,&quot;s11&quot;,&quot;s12&quot;,..: 11 13 14 15 16 17 18 19 1 2 ...
..$ sample2                : Factor w/ 19 levels &quot;s1&quot;,&quot;s10&quot;,&quot;s11&quot;,..: 1 1 1 1 1 1 1 1 1 1 ...
..$ Heterogeneous.Selection: num [1:190] 0 0 0 0 0 0 0 0 0 0 ...
..$ Homogeneous.Selection  : num [1:190] 0 0 0 0 0 ...
..$ Dispersal.Limitation   : num [1:190] 0 0 0 0 0 0 0 0 0 0 ...
..$ Homogenizing.Dispersal : num [1:190] 0 0.649 0.628 0 0 ...
..$ Drift.and.Others       : num [1:190] 1 0.351 0.372 1 1 ...
$ detail      :List of 7
..$ taxabin   :List of 5
.. ..$ sp.bin       :'data.frame':	30 obs. of  3 variables:
.. .. ..$ bin.id.strict: int [1:30] 1 2 3 4 5 6 7 8 9 10 ...
.. .. ..$ bin.id.united: chr [1:30] &quot;34&quot; &quot;34&quot; &quot;34&quot; &quot;34&quot; ...
.. .. ..$ bin.id.new   : num [1:30] 1 1 1 1 1 2 2 2 2 2 ...
.. ..$ bin.united.sp:List of 3
.. .. ..$ : chr [1:5] &quot;OTU1&quot; &quot;OTU2&quot; &quot;OTU3&quot; &quot;OTU4&quot; ...
.. .. ..$ : chr [1:7] &quot;OTU6&quot; &quot;OTU7&quot; &quot;OTU8&quot; &quot;OTU9&quot; ...
.. .. ..$ : chr [1:18] &quot;OTU13&quot; &quot;OTU14&quot; &quot;OTU15&quot; &quot;OTU16&quot; ...
.. ..$ bin.strict.sp:List of 30
.. .. ..$ 1 : chr &quot;OTU1&quot;
.. .. ..$ 2 : chr &quot;OTU2&quot;
.. .. ..$ 3 : chr &quot;OTU3&quot;
.. .. ..$ 4 : chr &quot;OTU4&quot;
.. .. ..$ 5 : chr &quot;OTU5&quot;
.. .. ..$ 6 : chr &quot;OTU6&quot;
.. .. ..$ 7 : chr &quot;OTU7&quot;
.. .. ..$ 8 : chr &quot;OTU8&quot;
.. .. ..$ 9 : chr &quot;OTU9&quot;
.. .. ..$ 10: chr &quot;OTU10&quot;
.. .. ..$ 11: chr &quot;OTU11&quot;
.. .. ..$ 12: chr &quot;OTU12&quot;
.. .. ..$ 13: chr &quot;OTU13&quot;
.. .. ..$ 14: chr &quot;OTU14&quot;
.. .. ..$ 15: chr &quot;OTU15&quot;
.. .. ..$ 16: chr &quot;OTU16&quot;
.. .. ..$ 17: chr &quot;OTU17&quot;
.. .. ..$ 18: chr &quot;OTU18&quot;
.. .. ..$ 19: chr &quot;OTU19&quot;
.. .. ..$ 20: chr &quot;OTU20&quot;
.. .. ..$ 21: chr &quot;OTU21&quot;
.. .. ..$ 22: chr &quot;OTU22&quot;
.. .. ..$ 23: chr &quot;OTU23&quot;
.. .. ..$ 24: chr &quot;OTU24&quot;
.. .. ..$ 25: chr &quot;OTU25&quot;
.. .. ..$ 26: chr &quot;OTU26&quot;
.. .. ..$ 27: chr &quot;OTU27&quot;
.. .. ..$ 28: chr &quot;OTU28&quot;
.. .. ..$ 29: chr &quot;OTU29&quot;
.. .. ..$ 30: chr &quot;OTU30&quot;
.. ..$ state.strict :'data.frame':	30 obs. of  5 variables:
.. .. ..$ bin.strict.id      : chr [1:30] &quot;1&quot; &quot;2&quot; &quot;3&quot; &quot;4&quot; ...
.. .. ..$ bin.strict.taxa.num: int [1:30, 1] 1 1 1 1 1 1 1 1 1 1 ...
.. .. .. ..- attr(*, &quot;dimnames&quot;)=List of 2
.. .. .. .. ..$ : chr [1:30] &quot;1&quot; &quot;2&quot; &quot;3&quot; &quot;4&quot; ...
.. .. .. .. ..$ : NULL
.. .. ..$ bin.pd.max         : num [1:30] 0 0 0 0 0 0 0 0 0 0 ...
.. .. ..$ bin.pd.mean        : num [1:30] 0 0 0 0 0 0 0 0 0 0 ...
.. .. ..$ bin.pd.sd          : num [1:30] NA NA NA NA NA NA NA NA NA NA ...
.. ..$ state.united :'data.frame':	3 obs. of  5 variables:
.. .. ..$ bin.united.id.old : chr [1:3] &quot;34&quot; &quot;38&quot; &quot;51&quot;
.. .. ..$ bin.united.tax.num: int [1:3] 5 7 18
.. .. ..$ bin.pd.max        : num [1:3] 3.33 3.96 6.36
.. .. ..$ bin.pd.mean       : num [1:3] 2.04 2.6 3.5
.. .. ..$ bin.pd.sd         : num [1:3] 1.073 0.816 1.235
..$ SigbMPDi  :'data.frame':	190 obs. of  5 variables:
.. ..$ name1     : Factor w/ 19 levels &quot;s10&quot;,&quot;s11&quot;,&quot;s12&quot;,..: 11 13 14 15 16 17 18 19 1 2 ...
.. ..$ name2     : Factor w/ 19 levels &quot;s1&quot;,&quot;s10&quot;,&quot;s11&quot;,..: 1 1 1 1 1 1 1 1 1 1 ...
.. ..$ bNRIi.bin1: num [1:190] 0.919 0.132 -1.207 1.274 1.274 ...
.. ..$ bNRIi.bin2: num [1:190] -0.572 -0.935 0.311 -0.681 0 ...
.. ..$ bNRIi.bin3: num [1:190] 0.919 0.865 1.034 0.345 0.701 ...
..$ SigBCa    :'data.frame':	190 obs. of  5 variables:
.. ..$ name1       : Factor w/ 19 levels &quot;s10&quot;,&quot;s11&quot;,&quot;s12&quot;,..: 11 13 14 15 16 17 18 19 1 2 ...
.. ..$ name2       : Factor w/ 19 levels &quot;s1&quot;,&quot;s10&quot;,&quot;s11&quot;,..: 1 1 1 1 1 1 1 1 1 1 ...
.. ..$ RCbraya.bin1: num [1:190] -0.81 0.41 0.14 -0.83 -0.8 -0.96 0.3 -0.12 -0.66 -0.75 ...
.. ..$ RCbraya.bin2: num [1:190] 0.79 0.3 0.83 0.45 0.62 0.64 0.83 -0.49 0.84 0.42 ...
.. ..$ RCbraya.bin3: num [1:190] -0.94 -0.98 -1 -0.42 -0.04 -0.82 -0.87 -0.55 -0.92 -0.12 ...
..$ bin.weight:'data.frame':	190 obs. of  5 variables:
.. ..$ samp1: Factor w/ 19 levels &quot;s10&quot;,&quot;s11&quot;,&quot;s12&quot;,..: 11 13 14 15 16 17 18 19 1 2 ...
.. ..$ samp2: Factor w/ 19 levels &quot;s1&quot;,&quot;s10&quot;,&quot;s11&quot;,..: 1 1 1 1 1 1 1 1 1 1 ...
.. ..$ bin1 : num [1:190] 0.0873 0.1653 0.1389 0.0975 0.0799 ...
.. ..$ bin2 : num [1:190] 0.242 0.186 0.233 0.204 0.111 ...
.. ..$ bin3 : num [1:190] 0.671 0.649 0.628 0.698 0.809 ...
..$ processes :List of 1
.. ..$ bNRIiRCa:'data.frame':	190 obs. of  7 variables:
.. .. ..$ sample1                : Factor w/ 19 levels &quot;s10&quot;,&quot;s11&quot;,&quot;s12&quot;,..: 11 13 14 15 16 17 18 19 1 2 ...
.. .. ..$ sample2                : Factor w/ 19 levels &quot;s1&quot;,&quot;s10&quot;,&quot;s11&quot;,..: 1 1 1 1 1 1 1 1 1 1 ...
.. .. ..$ Heterogeneous.Selection: num [1:190] 0 0 0 0 0 0 0 0 0 0 ...
.. .. ..$ Homogeneous.Selection  : num [1:190] 0 0 0 0 0 ...
.. .. ..$ Dispersal.Limitation   : num [1:190] 0 0 0 0 0 0 0 0 0 0 ...
.. .. ..$ Homogenizing.Dispersal : num [1:190] 0 0.649 0.628 0 0 ...
.. .. ..$ Drift.and.Others       : num [1:190] 1 0.351 0.372 1 1 ...
..$ setting   :'data.frame':	1 obs. of  24 variables:
.. ..$ ds              : num 0.2
.. ..$ pd.cut          : logi NA
.. ..$ max.pd          : num 7.83
.. ..$ sp.check        : logi TRUE
.. ..$ phylo.rand.scale: Factor w/ 1 level &quot;within.bin&quot;: 1
.. ..$ taxa.rand.scale : Factor w/ 1 level &quot;across.all&quot;: 1
.. ..$ phylo.metric    : Factor w/ 1 level &quot;bMPD&quot;: 1
.. ..$ sig.index       : Factor w/ 1 level &quot;SES.RC&quot;: 1
.. ..$ bin.size.limit  : num 5
.. ..$ nworker         : num 4
.. ..$ memory.G        : num 50
.. ..$ rtree.save      : logi FALSE
.. ..$ detail.save     : logi TRUE
.. ..$ qp.save         : logi FALSE
.. ..$ detail.null     : logi TRUE
.. ..$ ignore.zero     : logi TRUE
.. ..$ output.wd       : Factor w/ 1 level &quot;E:/Dropbox/ToolDevelop/package/iCAMP/LatestVersion/Example/TestOutputs14&quot;: 1
.. ..$ correct.special : logi TRUE
.. ..$ unit.sum.mean   : num 34.2
.. ..$ special.method  : Factor w/ 1 level &quot;depend&quot;: 1
.. ..$ ses.cut         : num 1.96
.. ..$ rc.cut          : num 0.95
.. ..$ conf.cut        : num 0.975
.. ..$ omit.option     : Factor w/ 1 level &quot;no&quot;: 1
..$ comm      : int [1:20, 1:30] 1 3 0 0 2 2 2 0 0 4 ...
.. ..- attr(*, &quot;dimnames&quot;)=List of 2
.. .. ..$ : chr [1:20] &quot;s1&quot; &quot;s2&quot; &quot;s3&quot; &quot;s4&quot; ...
.. .. ..$ : chr [1:30] &quot;OTU1&quot; &quot;OTU2&quot; &quot;OTU3&quot; &quot;OTU4&quot; ...
$ rand        :List of 4
..$ bMPD.obs  :List of 3
.. ..$ : num [1:20, 1:20] 0 0.00798 0.03268 0.01343 0.01722 ...
.. .. ..- attr(*, &quot;dimnames&quot;)=List of 2
.. .. .. ..$ : chr [1:20] &quot;s1&quot; &quot;s2&quot; &quot;s3&quot; &quot;s4&quot; ...
.. .. .. ..$ : chr [1:20] &quot;s1&quot; &quot;s2&quot; &quot;s3&quot; &quot;s4&quot; ...
.. ..$ : num [1:20, 1:20] 0 0.086 0.0216 0.0949 0.047 ...
.. .. ..- attr(*, &quot;dimnames&quot;)=List of 2
.. .. .. ..$ : chr [1:20] &quot;s1&quot; &quot;s2&quot; &quot;s3&quot; &quot;s4&quot; ...
.. .. .. ..$ : chr [1:20] &quot;s1&quot; &quot;s2&quot; &quot;s3&quot; &quot;s4&quot; ...
.. ..$ : num [1:20, 1:20] 0 1.48 1.29 1.27 1.64 ...
.. .. ..- attr(*, &quot;dimnames&quot;)=List of 2
.. .. .. ..$ : chr [1:20] &quot;s1&quot; &quot;s2&quot; &quot;s3&quot; &quot;s4&quot; ...
.. .. .. ..$ : chr [1:20] &quot;s1&quot; &quot;s2&quot; &quot;s3&quot; &quot;s4&quot; ...
..$ bMPDi.rand:List of 3
.. ..$ :'data.frame':	190 obs. of  102 variables:
.. .. ..$ name1  : Factor w/ 19 levels &quot;s10&quot;,&quot;s11&quot;,&quot;s12&quot;,..: 11 13 14 15 16 17 18 19 1 2 ...
.. .. ..$ name2  : Factor w/ 19 levels &quot;s1&quot;,&quot;s10&quot;,&quot;s11&quot;,..: 1 1 1 1 1 1 1 1 1 1 ...
.. .. ..$ rand1  : num [1:190] 0.00798 0.03197 0.01217 0.01476 0.00992 ...
.. .. ..$ rand2  : num [1:190] 0.00543 0.02743 0.01838 0.01224 0.00822 ...
.. .. ..$ rand3  : num [1:190] 0.00357 0.0245 0.02358 0.01224 0.00822 ...
.. .. ..$ rand4  : num [1:190] 0.00839 0.04672 0.03604 0.00615 0.00413 ...
.. .. ..$ rand5  : num [1:190] 0.0016 0.0226 0.0313 0.0172 0.0116 ...
.. .. ..$ rand6  : num [1:190] 0.00626 0.03441 0.0261 0.00615 0.00413 ...
.. .. ..$ rand7  : num [1:190] 0.00839 0.03746 0.01959 0.01476 0.00992 ...
.. .. ..$ rand8  : num [1:190] 0.00839 0.03351 0.01257 0.01722 0.01157 ...
.. .. ..$ rand9  : num [1:190] 0.00798 0.03268 0.01343 0.00697 0.00468 ...
.. .. ..$ rand10 : num [1:190] 0.00357 0.02626 0.02671 0.00615 0.00413 ...
.. .. ..$ rand11 : num [1:190] 0.00357 0.03161 0.03623 0.00313 0.0021 ...
.. .. ..$ rand12 : num [1:190] 0.0016 0.0125 0.01325 0.01476 0.00992 ...
.. .. ..$ rand13 : num [1:190] 0.00881 0.05001 0.03956 0.00248 0.00166 ...
.. .. ..$ rand14 : num [1:190] 0.00127 0.02228 0.03252 0.01722 0.01157 ...
.. .. ..$ rand15 : num [1:190] 0.00881 0.04554 0.03161 0.00248 0.00166 ...
.. .. ..$ rand16 : num [1:190] 0.0016 0.02264 0.03127 0.00697 0.00468 ...
.. .. ..$ rand17 : num [1:190] 0.00881 0.03988 0.02154 0.00313 0.0021 ...
.. .. ..$ rand18 : num [1:190] 0.0016 0.02176 0.02971 0.00615 0.00413 ...
.. .. ..$ rand19 : num [1:190] 0.0016 0.0134 0.0148 0.0172 0.0116 ...
.. .. ..$ rand20 : num [1:190] 0.00127 0.02053 0.02939 0.01558 0.01047 ...
.. .. ..$ rand21 : num [1:190] 0.00543 0.03581 0.03327 0.00248 0.00166 ...
.. .. ..$ rand22 : num [1:190] 0.00798 0.04518 0.03565 0.0106 0.00712 ...
.. .. ..$ rand23 : num [1:190] 0.00798 0.03197 0.01217 0.0106 0.00712 ...
.. .. ..$ rand24 : num [1:190] 0.00881 0.05001 0.03956 0.01224 0.00822 ...
.. .. ..$ rand25 : num [1:190] 0.00543 0.03309 0.02845 0.00697 0.00468 ...
.. .. ..$ rand26 : num [1:190] 0.00839 0.03421 0.01382 0.00615 0.00413 ...
.. .. ..$ rand27 : num [1:190] 0.00357 0.02626 0.02671 0.0106 0.00712 ...
.. .. ..$ rand28 : num [1:190] 0.00881 0.03575 0.01421 0.00697 0.00468 ...
.. .. ..$ rand29 : num [1:190] 0.00626 0.03441 0.0261 0.00697 0.00468 ...
.. .. ..$ rand30 : num [1:190] 0.00798 0.04782 0.04035 0.00697 0.00468 ...
.. .. ..$ rand31 : num [1:190] 0.00626 0.04064 0.03718 0.00248 0.00166 ...
.. .. ..$ rand32 : num [1:190] 0.00127 0.02316 0.03408 0.01224 0.00822 ...
.. .. ..$ rand33 : num [1:190] 0.00626 0.04152 0.03875 0.00248 0.00166 ...
.. .. ..$ rand34 : num [1:190] 0.00881 0.03575 0.01421 0.01558 0.01047 ...
.. .. ..$ rand35 : num [1:190] 0.0016 0.0244 0.0344 0.0156 0.0105 ...
.. .. ..$ rand36 : num [1:190] 0.00543 0.02655 0.01681 0.01224 0.00822 ...
.. .. ..$ rand37 : num [1:190] 0.00127 0.01781 0.02457 0.0164 0.01102 ...
.. .. ..$ rand38 : num [1:190] 0.00756 0.03916 0.02731 0.00248 0.00166 ...
.. .. ..$ rand39 : num [1:190] 0.00756 0.03438 0.0188 0.00313 0.0021 ...
.. .. ..$ rand40 : num [1:190] 0.00357 0.01647 0.00931 0.01722 0.01157 ...
.. .. ..$ rand41 : num [1:190] 0.00127 0.02053 0.02939 0.0106 0.00712 ...
.. .. ..$ rand42 : num [1:190] 0.0016 0.0125 0.0132 0.0164 0.011 ...
.. .. ..$ rand43 : num [1:190] 0.0016 0.0218 0.0297 0.0164 0.011 ...
.. .. ..$ rand44 : num [1:190] 0.00756 0.0454 0.03839 0.00313 0.0021 ...
.. .. ..$ rand45 : num [1:190] 0.0016 0.02352 0.03283 0.00615 0.00413 ...
.. .. ..$ rand46 : num [1:190] 0.00626 0.02963 0.0176 0.00697 0.00468 ...
.. .. ..$ rand47 : num [1:190] 0.00315 0.02472 0.02632 0.0106 0.00712 ...
.. .. ..$ rand48 : num [1:190] 0.00798 0.04782 0.04035 0.00313 0.0021 ...
.. .. ..$ rand49 : num [1:190] 0.00315 0.02744 0.03115 0.0164 0.01102 ...
.. .. ..$ rand50 : num [1:190] 0.00839 0.03746 0.01959 0.00313 0.0021 ...
.. .. ..$ rand51 : num [1:190] 0.00127 0.02141 0.03096 0.0106 0.00712 ...
.. .. ..$ rand52 : num [1:190] 0.00839 0.03421 0.01382 0.01476 0.00992 ...
.. .. ..$ rand53 : num [1:190] 0.00839 0.04935 0.04074 0.01224 0.00822 ...
.. .. ..$ rand54 : num [1:190] 0.00315 0.02919 0.03427 0.00313 0.0021 ...
.. .. ..$ rand55 : num [1:190] 0.00357 0.02986 0.0331 0.00313 0.0021 ...
.. .. ..$ rand56 : num [1:190] 0.00357 0.01647 0.00931 0.01558 0.01047 ...
.. .. ..$ rand57 : num [1:190] 0.00315 0.02296 0.02319 0.00697 0.00468 ...
.. .. ..$ rand58 : num [1:190] 0.00756 0.0454 0.03839 0.00615 0.00413 ...
.. .. ..$ rand59 : num [1:190] 0.00315 0.01493 0.00892 0.0164 0.01102 ...
.. .. ..$ rand60 : num [1:190] 0.00315 0.02744 0.03115 0.00313 0.0021 ...
.. .. ..$ rand61 : num [1:190] 0.00756 0.03438 0.0188 0.0164 0.01102 ...
.. .. ..$ rand62 : num [1:190] 0.00839 0.044 0.03122 0.00248 0.00166 ...
.. .. ..$ rand63 : num [1:190] 0.00798 0.0368 0.02076 0.00313 0.0021 ...
.. .. ..$ rand64 : num [1:190] 0.00315 0.01493 0.00892 0.01476 0.00992 ...
.. .. ..$ rand65 : num [1:190] 0.00798 0.04518 0.03565 0.00248 0.00166 ...
.. .. ..$ rand66 : num [1:190] 0.00626 0.02963 0.0176 0.0106 0.00712 ...
.. .. ..$ rand67 : num [1:190] 0.00881 0.03505 0.01296 0.0164 0.01102 ...
.. .. ..$ rand68 : num [1:190] 0.00626 0.04152 0.03875 0.0164 0.01102 ...
.. .. ..$ rand69 : num [1:190] 0.00626 0.02568 0.01058 0.0164 0.01102 ...
.. .. ..$ rand70 : num [1:190] 0.00127 0.02141 0.03096 0.01476 0.00992 ...
.. .. ..$ rand71 : num [1:190] 0.00798 0.0407 0.0277 0.01476 0.00992 ...
.. .. ..$ rand72 : num [1:190] 0.00839 0.04935 0.04074 0.00248 0.00166 ...
.. .. ..$ rand73 : num [1:190] 0.00543 0.02743 0.01838 0.00615 0.00413 ...
.. .. ..$ rand74 : num [1:190] 0.00881 0.03505 0.01296 0.01224 0.00822 ...
.. .. ..$ rand75 : num [1:190] 0.00626 0.04064 0.03718 0.01722 0.01157 ...
.. .. ..$ rand76 : num [1:190] 0.00881 0.03988 0.02154 0.01558 0.01047 ...
.. .. ..$ rand77 : num [1:190] 0.00315 0.01906 0.01625 0.01224 0.00822 ...
.. .. ..$ rand78 : num [1:190] 0.00756 0.03114 0.01304 0.00615 0.00413 ...
.. .. ..$ rand79 : num [1:190] 0.0016 0.02352 0.03283 0.01476 0.00992 ...
.. .. ..$ rand80 : num [1:190] 0.00127 0.01605 0.02144 0.01476 0.00992 ...
.. .. ..$ rand81 : num [1:190] 0.00127 0.01605 0.02144 0.01558 0.01047 ...
.. .. ..$ rand82 : num [1:190] 0.00543 0.03669 0.03484 0.01476 0.00992 ...
.. .. ..$ rand83 : num [1:190] 0.00626 0.03051 0.01916 0.0106 0.00712 ...
.. .. ..$ rand84 : num [1:190] 0.00798 0.0368 0.02076 0.01722 0.01157 ...
.. .. ..$ rand85 : num [1:190] 0.00881 0.04914 0.038 0.00313 0.0021 ...
.. .. ..$ rand86 : num [1:190] 0.00357 0.02986 0.0331 0.01722 0.01157 ...
.. .. ..$ rand87 : num [1:190] 0.00756 0.03043 0.01178 0.0106 0.00712 ...
.. .. ..$ rand88 : num [1:190] 0.00756 0.03114 0.01304 0.0164 0.01102 ...
.. .. ..$ rand89 : num [1:190] 0.00543 0.0226 0.00979 0.01558 0.01047 ...
.. .. ..$ rand90 : num [1:190] 0.00626 0.02568 0.01058 0.01722 0.01157 ...
.. .. ..$ rand91 : num [1:190] 0.00127 0.02316 0.03408 0.0164 0.01102 ...
.. .. ..$ rand92 : num [1:190] 0.00756 0.03916 0.02731 0.01558 0.01047 ...
.. .. ..$ rand93 : num [1:190] 0.00881 0.04914 0.038 0.00697 0.00468 ...
.. .. ..$ rand94 : num [1:190] 0.00756 0.04452 0.03683 0.00248 0.00166 ...
.. .. ..$ rand95 : num [1:190] 0.0016 0.0134 0.0148 0.0156 0.0105 ...
.. .. ..$ rand96 : num [1:190] 0.00357 0.01972 0.01508 0.0106 0.00712 ...
.. .. ..$ rand97 : num [1:190] 0.00543 0.03309 0.02845 0.00615 0.00413 ...
.. .. .. [list output truncated]
.. ..$ :'data.frame':	190 obs. of  102 variables:
.. .. ..$ name1  : Factor w/ 19 levels &quot;s10&quot;,&quot;s11&quot;,&quot;s12&quot;,..: 11 13 14 15 16 17 18 19 1 2 ...
.. .. ..$ name2  : Factor w/ 19 levels &quot;s1&quot;,&quot;s10&quot;,&quot;s11&quot;,..: 1 1 1 1 1 1 1 1 1 1 ...
.. .. ..$ rand1  : num [1:190] 0.1008 0.0194 0.1046 0.0538 0 ...
.. .. ..$ rand2  : num [1:190] 0.1009 0.0418 0.0792 0.059 0 ...
.. .. ..$ rand3  : num [1:190] 0.093 0.0289 0.0847 0.0521 0 ...
.. .. ..$ rand4  : num [1:190] 0.0695 0.0198 0.0566 0.0386 0 ...
.. .. ..$ rand5  : num [1:190] 0.1207 0.0288 0.1134 0.0656 0 ...
.. .. ..$ rand6  : num [1:190] 0.0985 0.0328 0.0897 0.0557 0 ...
.. .. ..$ rand7  : num [1:190] 0.0769 0.0274 0.0749 0.0439 0 ...
.. .. ..$ rand8  : num [1:190] 0.0659 0.0216 0.0713 0.0372 0 ...
.. .. ..$ rand9  : num [1:190] 0.1118 0.0418 0.1078 0.0643 0 ...
.. .. ..$ rand10 : num [1:190] 0.1054 0.0256 0.0966 0.0574 0 ...
.. .. ..$ rand11 : num [1:190] 0.0823 0.0288 0.0721 0.0469 0 ...
.. .. ..$ rand12 : num [1:190] 0.1124 0.0274 0.0929 0.0613 0 ...
.. .. ..$ rand13 : num [1:190] 0.1193 0.044 0.1063 0.0685 0 ...
.. .. ..$ rand14 : num [1:190] 0.1036 0.0384 0.094 0.0595 0 ...
.. .. ..$ rand15 : num [1:190] 0.0938 0.0271 0.0728 0.0521 0 ...
.. .. ..$ rand16 : num [1:190] 0.1036 0.0384 0.0924 0.0595 0 ...
.. .. ..$ rand17 : num [1:190] 0.1112 0.0385 0.0964 0.0633 0 ...
.. .. ..$ rand18 : num [1:190] 0.0881 0.0328 0.0837 0.0506 0 ...
.. .. ..$ rand19 : num [1:190] 0.0876 0.0271 0.0684 0.0491 0 ...
.. .. ..$ rand20 : num [1:190] 0.0846 0.0198 0.0862 0.0459 0 ...
.. .. ..$ rand21 : num [1:190] 0.1051 0.0148 0.101 0.0548 0 ...
.. .. ..$ rand22 : num [1:190] 0.1387 0.0384 0.1101 0.0766 0 ...
.. .. ..$ rand23 : num [1:190] 0.08 0.0295 0.0768 0.0459 0 ...
.. .. ..$ rand24 : num [1:190] 0.1174 0.0311 0.1051 0.0646 0 ...
.. .. ..$ rand25 : num [1:190] 0.0883 0.0256 0.0691 0.0491 0 ...
.. .. ..$ rand26 : num [1:190] 0.1071 0.0385 0.088 0.0613 0 ...
.. .. ..$ rand27 : num [1:190] 0.1282 0.0311 0.1127 0.0699 0 ...
.. .. ..$ rand28 : num [1:190] 0.1254 0.044 0.12 0.0715 0 ...
.. .. ..$ rand29 : num [1:190] 0.1009 0.0418 0.0917 0.059 0 ...
.. .. ..$ rand30 : num [1:190] 0.1054 0.0194 0.0979 0.056 0 ...
.. .. ..$ rand31 : num [1:190] 0.099 0.0328 0.0919 0.056 0 ...
.. .. ..$ rand32 : num [1:190] 0.0938 0.0271 0.0728 0.0521 0 ...
.. .. ..$ rand33 : num [1:190] 0.1008 0.0311 0.1012 0.0565 0 ...
.. .. ..$ rand34 : num [1:190] 0.1147 0.0418 0.0949 0.0657 0 ...
.. .. ..$ rand35 : num [1:190] 0.0825 0.0289 0.0677 0.047 0 ...
.. .. ..$ rand36 : num [1:190] 0.1031 0.0328 0.0926 0.058 0 ...
.. .. ..$ rand37 : num [1:190] 0.0899 0.0385 0.0949 0.0529 0 ...
.. .. ..$ rand38 : num [1:190] 0.1104 0.0216 0.1006 0.059 0 ...
.. .. ..$ rand39 : num [1:190] 0.0869 0.0194 0.0928 0.047 0 ...
.. .. ..$ rand40 : num [1:190] 0.0501 0.0198 0.0605 0.0291 0 ...
.. .. ..$ rand41 : num [1:190] 0.094 0.0296 0.0917 0.0528 0 ...
.. .. ..$ rand42 : num [1:190] 0.0865 0.0407 0.0823 0.0517 0 ...
.. .. ..$ rand43 : num [1:190] 0.1221 0.044 0.1069 0.0699 0 ...
.. .. ..$ rand44 : num [1:190] 0.0541 0.0114 0.0642 0.0291 0 ...
.. .. ..$ rand45 : num [1:190] 0.0805 0.0198 0.0782 0.0439 0 ...
.. .. ..$ rand46 : num [1:190] 0.0934 0.0216 0.1001 0.0506 0 ...
.. .. ..$ rand47 : num [1:190] 0.094 0.0274 0.0969 0.0522 0 ...
.. .. ..$ rand48 : num [1:190] 0.1015 0.0296 0.085 0.0565 0 ...
.. .. ..$ rand49 : num [1:190] 0.1015 0.0296 0.1019 0.0565 0 ...
.. .. ..$ rand50 : num [1:190] 0.0908 0.0198 0.0857 0.049 0 ...
.. .. ..$ rand51 : num [1:190] 0.0879 0.0418 0.0761 0.0527 0 ...
.. .. ..$ rand52 : num [1:190] 0.1118 0.0271 0.0854 0.0609 0 ...
.. .. ..$ rand53 : num [1:190] 0.1032 0.0361 0.0784 0.0588 0 ...
.. .. ..$ rand54 : num [1:190] 0.0794 0.0296 0.0885 0.0456 0 ...
.. .. ..$ rand55 : num [1:190] 0.1112 0.0384 0.0909 0.0632 0 ...
.. .. ..$ rand56 : num [1:190] 0.133 0.0418 0.114 0.0746 0 ...
.. .. ..$ rand57 : num [1:190] 0.0988 0.0148 0.0938 0.0517 0 ...
.. .. ..$ rand58 : num [1:190] 0.1199 0.0296 0.1148 0.0655 0 ...
.. .. ..$ rand59 : num [1:190] 0.1435 0.0418 0.1215 0.0798 0 ...
.. .. ..$ rand60 : num [1:190] 0.1249 0.0361 0.1007 0.0694 0 ...
.. .. ..$ rand61 : num [1:190] 0.0917 0.0256 0.0855 0.0508 0 ...
.. .. ..$ rand62 : num [1:190] 0.1032 0.0361 0.094 0.0588 0 ...
.. .. ..$ rand63 : num [1:190] 0.1252 0.0289 0.1136 0.0679 0 ...
.. .. ..$ rand64 : num [1:190] 0.0965 0.0194 0.1025 0.0517 0 ...
.. .. ..$ rand65 : num [1:190] 0.0766 0.0271 0.0768 0.0437 0 ...
.. .. ..$ rand66 : num [1:190] 0.0995 0.0184 0.1038 0.0529 0 ...
.. .. ..$ rand67 : num [1:190] 0.1209 0.0289 0.1205 0.0657 0 ...
.. .. ..$ rand68 : num [1:190] 0.1118 0.0418 0.1078 0.0643 0 ...
.. .. ..$ rand69 : num [1:190] 0.068 0.0114 0.0691 0.0358 0 ...
.. .. ..$ rand70 : num [1:190] 0.0674 0.0184 0.0708 0.0372 0 ...
.. .. ..$ rand71 : num [1:190] 0.1124 0.0274 0.1128 0.0613 0 ...
.. .. ..$ rand72 : num [1:190] 0.0944 0.0296 0.092 0.053 0 ...
.. .. ..$ rand73 : num [1:190] 0.1237 0.0385 0.1194 0.0694 0 ...
.. .. ..$ rand74 : num [1:190] 0.0801 0.0296 0.0771 0.046 0 ...
.. .. ..$ rand75 : num [1:190] 0.0944 0.0296 0.0805 0.053 0 ...
.. .. ..$ rand76 : num [1:190] 0.1032 0.0361 0.1024 0.0588 0 ...
.. .. ..$ rand77 : num [1:190] 0.1009 0.0418 0.0917 0.059 0 ...
.. .. ..$ rand78 : num [1:190] 0.0733 0.0361 0.0701 0.0442 0 ...
.. .. ..$ rand79 : num [1:190] 0.1051 0.0148 0.0911 0.0548 0 ...
.. .. ..$ rand80 : num [1:190] 0.0822 0.0311 0.0797 0.0474 0 ...
.. .. ..$ rand81 : num [1:190] 0.0986 0.0295 0.0834 0.055 0 ...
.. .. ..$ rand82 : num [1:190] 0.0865 0.0407 0.0823 0.0517 0 ...
.. .. ..$ rand83 : num [1:190] 0.0659 0.0216 0.0713 0.0372 0 ...
.. .. ..$ rand84 : num [1:190] 0.1038 0.0385 0.0946 0.0596 0 ...
.. .. ..$ rand85 : num [1:190] 0.0999 0.044 0.0991 0.059 0 ...
.. .. ..$ rand86 : num [1:190] 0.1174 0.0407 0.0949 0.0668 0 ...
.. .. ..$ rand87 : num [1:190] 0.1326 0.0385 0.1113 0.0737 0 ...
.. .. ..$ rand88 : num [1:190] 0.0846 0.0198 0.0811 0.0459 0 ...
.. .. ..$ rand89 : num [1:190] 0.0769 0.0274 0.0749 0.0439 0 ...
.. .. ..$ rand90 : num [1:190] 0.0755 0.0114 0.0772 0.0395 0 ...
.. .. ..$ rand91 : num [1:190] 0.136 0.044 0.1166 0.0766 0 ...
.. .. ..$ rand92 : num [1:190] 0.1036 0.0384 0.0924 0.0595 0 ...
.. .. ..$ rand93 : num [1:190] 0.0501 0.0198 0.0491 0.0291 0 ...
.. .. ..$ rand94 : num [1:190] 0.0562 0.0148 0.0739 0.0309 0 ...
.. .. ..$ rand95 : num [1:190] 0.0902 0.0289 0.084 0.0508 0 ...
.. .. ..$ rand96 : num [1:190] 0.086 0.0216 0.0869 0.047 0 ...
.. .. ..$ rand97 : num [1:190] 0.093 0.0289 0.0847 0.0521 0 ...
.. .. .. [list output truncated]
.. ..$ :'data.frame':	190 obs. of  102 variables:
.. .. ..$ name1  : Factor w/ 19 levels &quot;s10&quot;,&quot;s11&quot;,&quot;s12&quot;,..: 11 13 14 15 16 17 18 19 1 2 ...
.. .. ..$ name2  : Factor w/ 19 levels &quot;s1&quot;,&quot;s10&quot;,&quot;s11&quot;,..: 1 1 1 1 1 1 1 1 1 1 ...
.. .. ..$ rand1  : num [1:190] 1.36 1.25 1.23 1.66 2.19 ...
.. .. ..$ rand2  : num [1:190] 1.46 1.25 1.27 1.79 2.31 ...
.. .. ..$ rand3  : num [1:190] 1.34 1.15 1.06 1.52 1.96 ...
.. .. ..$ rand4  : num [1:190] 1.26 1.13 1.03 1.43 1.94 ...
.. .. ..$ rand5  : num [1:190] 1.349 1.137 0.997 1.545 1.841 ...
.. .. ..$ rand6  : num [1:190] 1.43 1.27 1.23 1.67 2.1 ...
.. .. ..$ rand7  : num [1:190] 1.12 1.02 1.04 1.48 2.07 ...
.. .. ..$ rand8  : num [1:190] 1.38 1.17 1.17 1.8 2.34 ...
.. .. ..$ rand9  : num [1:190] 1.15 0.934 0.867 1.5 1.997 ...
.. .. ..$ rand10 : num [1:190] 1.48 1.26 1.22 1.75 2.26 ...
.. .. ..$ rand11 : num [1:190] 1.39 1.25 1.22 1.48 1.98 ...
.. .. ..$ rand12 : num [1:190] 1.28 1.11 1.17 1.87 2.41 ...
.. .. ..$ rand13 : num [1:190] 1.328 1.109 0.973 1.653 2.036 ...
.. .. ..$ rand14 : num [1:190] 1.5 1.3 1.28 1.62 2.06 ...
.. .. ..$ rand15 : num [1:190] 1.35 1.24 1.27 1.74 2.27 ...
.. .. ..$ rand16 : num [1:190] 0.99 0.865 0.923 1.242 1.662 ...
.. .. ..$ rand17 : num [1:190] 1.26 1.15 1.08 1.52 1.98 ...
.. .. ..$ rand18 : num [1:190] 1.259 1.08 0.976 1.326 1.75 ...
.. .. ..$ rand19 : num [1:190] 1.72 1.53 1.44 2.03 2.62 ...
.. .. ..$ rand20 : num [1:190] 1.085 0.868 0.893 1.23 1.578 ...
.. .. ..$ rand21 : num [1:190] 0.969 0.938 0.883 1.278 1.695 ...
.. .. ..$ rand22 : num [1:190] 1.17 1.03 1 1.4 1.81 ...
.. .. ..$ rand23 : num [1:190] 1.26 1.04 1.06 1.36 1.72 ...
.. .. ..$ rand24 : num [1:190] 1.144 0.993 0.991 1.479 1.978 ...
.. .. ..$ rand25 : num [1:190] 0.973 0.818 0.878 1.294 1.771 ...
.. .. ..$ rand26 : num [1:190] 1.44 1.29 1.25 1.82 2.33 ...
.. .. ..$ rand27 : num [1:190] 1.34 1.23 1.22 1.55 1.9 ...
.. .. ..$ rand28 : num [1:190] 1.21 1.12 1.11 1.6 2.06 ...
.. .. ..$ rand29 : num [1:190] 0.996 0.869 0.977 1.239 1.724 ...
.. .. ..$ rand30 : num [1:190] 1.29 1.04 1.03 1.59 2 ...
.. .. ..$ rand31 : num [1:190] 0.991 0.807 0.907 1.473 1.771 ...
.. .. ..$ rand32 : num [1:190] 1.59 1.3 1.27 1.7 2.23 ...
.. .. ..$ rand33 : num [1:190] 1.52 1.44 1.3 1.92 2.46 ...
.. .. ..$ rand34 : num [1:190] 1.12 1.01 1 1.41 1.77 ...
.. .. ..$ rand35 : num [1:190] 1.76 1.55 1.51 1.88 2.43 ...
.. .. ..$ rand36 : num [1:190] 1.13 1.02 1.08 1.43 1.92 ...
.. .. ..$ rand37 : num [1:190] 1.57 1.25 1.39 1.91 2.4 ...
.. .. ..$ rand38 : num [1:190] 1.4 1.24 1.24 1.66 2.08 ...
.. .. ..$ rand39 : num [1:190] 1.43 1.18 1.13 1.66 2.15 ...
.. .. ..$ rand40 : num [1:190] 1.78 1.5 1.38 1.84 2.31 ...
.. .. ..$ rand41 : num [1:190] 1.33 1.09 1.06 1.55 1.94 ...
.. .. ..$ rand42 : num [1:190] 1.45 1.33 1.22 1.76 2.31 ...
.. .. ..$ rand43 : num [1:190] 1.119 1.014 0.993 1.496 1.879 ...
.. .. ..$ rand44 : num [1:190] 1.4 1.29 1.18 1.63 2.17 ...
.. .. ..$ rand45 : num [1:190] 1.59 1.45 1.29 1.68 2.2 ...
.. .. ..$ rand46 : num [1:190] 1.45 1.28 1.27 1.77 2.22 ...
.. .. ..$ rand47 : num [1:190] 1.24 1.05 1.09 1.5 2.03 ...
.. .. ..$ rand48 : num [1:190] 1.14 1.16 1.17 1.54 2.1 ...
.. .. ..$ rand49 : num [1:190] 0.951 0.928 0.924 1.384 1.856 ...
.. .. ..$ rand50 : num [1:190] 1.39 1.24 1.23 1.65 2.05 ...
.. .. ..$ rand51 : num [1:190] 1.233 1.037 0.956 1.522 1.937 ...
.. .. ..$ rand52 : num [1:190] 0.962 0.815 0.929 1.202 1.568 ...
.. .. ..$ rand53 : num [1:190] 1.42 1.3 1.28 1.95 2.46 ...
.. .. ..$ rand54 : num [1:190] 0.936 0.733 0.769 1.24 1.453 ...
.. .. ..$ rand55 : num [1:190] 1.197 0.968 0.983 1.272 1.743 ...
.. .. ..$ rand56 : num [1:190] 1.48 1.37 1.29 1.7 2.33 ...
.. .. ..$ rand57 : num [1:190] 1.038 0.976 1.023 1.476 1.916 ...
.. .. ..$ rand58 : num [1:190] 1.42 1.3 1.2 1.69 2.18 ...
.. .. ..$ rand59 : num [1:190] 0.979 0.93 0.833 1.418 1.849 ...
.. .. ..$ rand60 : num [1:190] 1.33 1.11 1.15 1.63 2.09 ...
.. .. ..$ rand61 : num [1:190] 1.54 1.23 1.13 1.59 2.07 ...
.. .. ..$ rand62 : num [1:190] 1.117 0.805 0.844 1.329 1.576 ...
.. .. ..$ rand63 : num [1:190] 1.25 1.12 1.21 1.44 1.82 ...
.. .. ..$ rand64 : num [1:190] 1.36 1.18 1.13 1.6 2.09 ...
.. .. ..$ rand65 : num [1:190] 1.15 1.029 0.947 1.348 1.851 ...
.. .. ..$ rand66 : num [1:190] 1.143 0.963 0.956 1.278 1.784 ...
.. .. ..$ rand67 : num [1:190] 1.128 0.834 0.855 1.401 1.661 ...
.. .. ..$ rand68 : num [1:190] 1.02 0.93 0.87 1.57 1.97 ...
.. .. ..$ rand69 : num [1:190] 0.984 0.931 0.919 1.472 1.913 ...
.. .. ..$ rand70 : num [1:190] 1.092 0.835 0.889 1.337 1.635 ...
.. .. ..$ rand71 : num [1:190] 1.2 1.104 0.992 1.777 2.262 ...
.. .. ..$ rand72 : num [1:190] 1.21 1.06 1.14 1.27 1.64 ...
.. .. ..$ rand73 : num [1:190] 1.32 1.07 0.93 1.55 2.07 ...
.. .. ..$ rand74 : num [1:190] 1.5 1.3 1.26 1.74 2.27 ...
.. .. ..$ rand75 : num [1:190] 1.62 1.46 1.42 1.86 2.45 ...
.. .. ..$ rand76 : num [1:190] 1.28 1.09 1.13 1.7 2.2 ...
.. .. ..$ rand77 : num [1:190] 1.156 0.874 0.936 1.548 2.069 ...
.. .. ..$ rand78 : num [1:190] 1.201 0.989 0.922 1.352 1.769 ...
.. .. ..$ rand79 : num [1:190] 1.34 1.12 1.14 1.37 1.8 ...
.. .. ..$ rand80 : num [1:190] 1.31 1.12 1.02 1.59 2.06 ...
.. .. ..$ rand81 : num [1:190] 1.43 1.13 1.03 1.49 1.94 ...
.. .. ..$ rand82 : num [1:190] 1.216 0.798 0.897 1.465 1.809 ...
.. .. ..$ rand83 : num [1:190] 1.139 1.048 0.957 1.462 1.843 ...
.. .. ..$ rand84 : num [1:190] 1.5 1.23 1.18 1.76 2.26 ...
.. .. ..$ rand85 : num [1:190] 1.58 1.46 1.45 1.87 2.53 ...
.. .. ..$ rand86 : num [1:190] 1.39 1.22 1.18 1.65 2.14 ...
.. .. ..$ rand87 : num [1:190] 0.994 0.731 0.766 1.279 1.735 ...
.. .. ..$ rand88 : num [1:190] 1.15 1.04 1.06 1.54 2.01 ...
.. .. ..$ rand89 : num [1:190] 1.19 1.02 1.05 1.46 1.84 ...
.. .. ..$ rand90 : num [1:190] 1.65 1.39 1.35 1.93 2.29 ...
.. .. ..$ rand91 : num [1:190] 1.26 1.01 1.04 1.39 1.81 ...
.. .. ..$ rand92 : num [1:190] 1.57 1.35 1.3 1.76 2.16 ...
.. .. ..$ rand93 : num [1:190] 1.22 1.09 1.11 1.31 1.74 ...
.. .. ..$ rand94 : num [1:190] 1.4 1.31 1.24 1.78 2.35 ...
.. .. ..$ rand95 : num [1:190] 1.71 1.48 1.36 1.92 2.48 ...
.. .. ..$ rand96 : num [1:190] 1.4 1.23 1.04 1.61 2.02 ...
.. .. ..$ rand97 : num [1:190] 1.47 1.23 1.18 1.5 1.96 ...
.. .. .. [list output truncated]
..$ BC.obs    :List of 3
.. ..$ : num [1:20, 1:20] 0 0.0317 0.1653 0.1389 0.051 ...
.. .. ..- attr(*, &quot;dimnames&quot;)=List of 2
.. .. .. ..$ : chr [1:20] &quot;s1&quot; &quot;s2&quot; &quot;s3&quot; &quot;s4&quot; ...
.. .. .. ..$ : chr [1:20] &quot;s1&quot; &quot;s2&quot; &quot;s3&quot; &quot;s4&quot; ...
.. ..$ : num [1:20, 1:20] 0 0.1468 0.0861 0.1444 0.1111 ...
.. .. ..- attr(*, &quot;dimnames&quot;)=List of 2
.. .. .. ..$ : chr [1:20] &quot;s1&quot; &quot;s2&quot; &quot;s3&quot; &quot;s4&quot; ...
.. .. .. ..$ : chr [1:20] &quot;s1&quot; &quot;s2&quot; &quot;s3&quot; &quot;s4&quot; ...
.. ..$ : num [1:20, 1:20] 0 0.345 0.263 0.317 0.494 ...
.. .. ..- attr(*, &quot;dimnames&quot;)=List of 2
.. .. .. ..$ : chr [1:20] &quot;s1&quot; &quot;s2&quot; &quot;s3&quot; &quot;s4&quot; ...
.. .. .. ..$ : chr [1:20] &quot;s1&quot; &quot;s2&quot; &quot;s3&quot; &quot;s4&quot; ...
..$ BCa.rand  :List of 3
.. ..$ :'data.frame':	190 obs. of  102 variables:
.. .. ..$ name1  : Factor w/ 19 levels &quot;s10&quot;,&quot;s11&quot;,&quot;s12&quot;,..: 11 13 14 15 16 17 18 19 1 2 ...
.. .. ..$ name2  : Factor w/ 19 levels &quot;s1&quot;,&quot;s10&quot;,&quot;s11&quot;,..: 1 1 1 1 1 1 1 1 1 1 ...
.. .. ..$ rand1  : num [1:190] 0.127 0.1931 0.0333 0.137 0.0451 ...
.. .. ..$ rand2  : num [1:190] 0.1429 0.0875 0.0778 0.0465 0.0208 ...
.. .. ..$ rand3  : num [1:190] 0.1071 0.125 0.0667 0.0698 0.0521 ...
.. .. ..$ rand4  : num [1:190] 0.19 0.225 0.206 0.262 0.281 ...
.. .. ..$ rand5  : num [1:190] 0.107 0.296 0.117 0.095 0.104 ...
.. .. ..$ rand6  : num [1:190] 0.123 0.169 0.194 0.148 0.163 ...
.. .. ..$ rand7  : num [1:190] 0 0.1125 0.0889 0.0698 0.0104 ...
.. .. ..$ rand8  : num [1:190] 0.107 0.167 0.178 0.143 0.104 ...
.. .. ..$ rand9  : num [1:190] 0.127 0.1431 0.0778 0.1253 0.0972 ...
.. .. ..$ rand10 : num [1:190] 0.1587 0.1403 0.0278 0.1208 0.0903 ...
.. .. ..$ rand11 : num [1:190] 0.1548 0.1958 0.0944 0.1415 0.0938 ...
.. .. ..$ rand12 : num [1:190] 0.0833 0.0375 0.1111 0.093 0.1562 ...
.. .. ..$ rand13 : num [1:190] 0.111 0.211 0.189 0.123 0.142 ...
.. .. ..$ rand14 : num [1:190] 0.0992 0.1361 0.1556 0.1693 0.2049 ...
.. .. ..$ rand15 : num [1:190] 0.127 0.156 0.1 0.16 0.16 ...
.. .. ..$ rand16 : num [1:190] 0.07937 0.07778 0.00556 0.13243 0.07986 ...
.. .. ..$ rand17 : num [1:190] 0.234 0.16 0.244 0.222 0.253 ...
.. .. ..$ rand18 : num [1:190] 0.0754 0.1653 0.15 0.1441 0.0278 ...
.. .. ..$ rand19 : num [1:190] 0.1905 0.1125 0.1556 0.093 0.0104 ...
.. .. ..$ rand20 : num [1:190] 0.337 0.29 0.3 0.243 0.236 ...
.. .. ..$ rand21 : num [1:190] 0.1706 0.1736 0.1889 0.0995 0.1944 ...
.. .. ..$ rand22 : num [1:190] 0.0952 0.0375 0.1889 0.1395 0.0833 ...
.. .. ..$ rand23 : num [1:190] 0.0595 0.1333 0.1722 0.1531 0.059 ...
.. .. ..$ rand24 : num [1:190] 0.19 0.204 0.178 0.167 0.115 ...
.. .. ..$ rand25 : num [1:190] 0.0952 0.05 0.1889 0.093 0.0417 ...
.. .. ..$ rand26 : num [1:190] 0.246 0.21 0.267 0.257 0.264 ...
.. .. ..$ rand27 : num [1:190] 0.1786 0.2125 0.0222 0.0698 0.125 ...
.. .. ..$ rand28 : num [1:190] 0.2262 0.1292 0.0556 0.1085 0.1875 ...
.. .. ..$ rand29 : num [1:190] 0.119 0.075 0.0778 0.0465 0.1042 ...
.. .. ..$ rand30 : num [1:190] 0.0595 0.075 0.1 0.1163 0.125 ...
.. .. ..$ rand31 : num [1:190] 0.119 0.1 0.167 0.128 0 ...
.. .. ..$ rand32 : num [1:190] 0.131 0.0625 0.1667 0.0814 0.0833 ...
.. .. ..$ rand33 : num [1:190] 0.0119 0.0958 0.1389 0.1996 0.1667 ...
.. .. ..$ rand34 : num [1:190] 0.119 0 0.1444 0.0465 0.125 ...
.. .. ..$ rand35 : num [1:190] 0.23 0.249 0.144 0.111 0.132 ...
.. .. ..$ rand36 : num [1:190] 0.0357 0.15 0.0333 0.0233 0.1146 ...
.. .. ..$ rand37 : num [1:190] 0.0675 0.0681 0.0889 0.1486 0.1389 ...
.. .. ..$ rand38 : num [1:190] 0.0119 0.1 0.1444 0.1279 0.125 ...
.. .. ..$ rand39 : num [1:190] 0.0873 0.1653 0.1278 0.051 0.1528 ...
.. .. ..$ rand40 : num [1:190] 0.246 0.222 0.233 0.257 0.243 ...
.. .. ..$ rand41 : num [1:190] 0.119 0.125 0.0778 0.0814 0.0521 ...
.. .. ..$ rand42 : num [1:190] 0.0714 0.125 0.1333 0.0698 0.1562 ...
.. .. ..$ rand43 : num [1:190] 0.0595 0.1 0.0778 0.0698 0.0729 ...
.. .. ..$ rand44 : num [1:190] 0.1429 0.15 0.0333 0.0814 0.1042 ...
.. .. ..$ rand45 : num [1:190] 0.0476 0.1 0.1444 0.0814 0.0938 ...
.. .. ..$ rand46 : num [1:190] 0.1667 0.075 0.0111 0.093 0.0521 ...
.. .. ..$ rand47 : num [1:190] 0.0317 0.1306 0.1667 0.0904 0.0556 ...
.. .. ..$ rand48 : num [1:190] 0.119 0.1125 0.0667 0.0349 0.1562 ...
.. .. ..$ rand49 : num [1:190] 0.0476 0 0.0444 0.0465 0.1354 ...
.. .. ..$ rand50 : num [1:190] 0.163 0.133 0.161 0.095 0.125 ...
.. .. ..$ rand51 : num [1:190] 0.0595 0.125 0.1 0.0698 0.1042 ...
.. .. ..$ rand52 : num [1:190] 0.1667 0.15 0.0889 0.1628 0 ...
.. .. ..$ rand53 : num [1:190] 0.1667 0 0.0889 0.093 0 ...
.. .. ..$ rand54 : num [1:190] 0.0357 0.125 0.1111 0.1163 0.1354 ...
.. .. ..$ rand55 : num [1:190] 0.0873 0.1167 0.1667 0.1667 0.1562 ...
.. .. ..$ rand56 : num [1:190] 0.1587 0.2736 0.1 0.0762 0.1632 ...
.. .. ..$ rand57 : num [1:190] 0.0556 0.1181 0.0667 0.084 0.0278 ...
.. .. ..$ rand58 : num [1:190] 0.0833 0.1875 0.1 0.1279 0.0938 ...
.. .. ..$ rand59 : num [1:190] 0.1111 0.0736 0.1778 0.0879 0.1632 ...
.. .. ..$ rand60 : num [1:190] 0.1746 0.1639 0.1833 0.0691 0.1424 ...
.. .. ..$ rand61 : num [1:190] 0 0.1375 0.1222 0.093 0.0833 ...
.. .. ..$ rand62 : num [1:190] 0.1151 0.1403 0.0833 0.0536 0.0799 ...
.. .. ..$ rand63 : num [1:190] 0.135 0.178 0.106 0.121 0.17 ...
.. .. ..$ rand64 : num [1:190] 0.0476 0.1 0.1556 0.1047 0.125 ...
.. .. ..$ rand65 : num [1:190] 0.131 0.0375 0.0778 0.0698 0.0208 ...
.. .. ..$ rand66 : num [1:190] 0.25 0.25 0.139 0.18 0.271 ...
.. .. ..$ rand67 : num [1:190] 0.0357 0.1375 0.0667 0.0698 0 ...
.. .. ..$ rand68 : num [1:190] 0.1071 0.0833 0.1056 0.1298 0.1875 ...
.. .. ..$ rand69 : num [1:190] 0.234 0.164 0.172 0.185 0.181 ...
.. .. ..$ rand70 : num [1:190] 0.226 0.204 0.233 0.19 0.198 ...
.. .. ..$ rand71 : num [1:190] 0.0714 0.1125 0.0444 0.093 0.1146 ...
.. .. ..$ rand72 : num [1:190] 0.1508 0.0889 0.1611 0.1156 0.1181 ...
.. .. ..$ rand73 : num [1:190] 0.175 0.226 0.106 0.127 0.191 ...
.. .. ..$ rand74 : num [1:190] 0.0357 0.125 0.1556 0.0233 0.0729 ...
.. .. ..$ rand75 : num [1:190] 0.159 0.14 0.139 0.206 0.309 ...
.. .. ..$ rand76 : num [1:190] 0 0.158 0.106 0.165 0.146 ...
.. .. ..$ rand77 : num [1:190] 0.123 0.161 0.122 0.169 0.163 ...
.. .. ..$ rand78 : num [1:190] 0.0635 0.1611 0.1444 0.2506 0.2153 ...
.. .. ..$ rand79 : num [1:190] 0.0238 0.075 0.0556 0.093 0.1042 ...
.. .. ..$ rand80 : num [1:190] 0.155 0.246 0.106 0.095 0.198 ...
.. .. ..$ rand81 : num [1:190] 0.1706 0.0861 0.1889 0.1227 0.1944 ...
.. .. ..$ rand82 : num [1:190] 0.262 0.154 0.289 0.202 0.135 ...
.. .. ..$ rand83 : num [1:190] 0.127 0.0403 0.1278 0.1208 0.0972 ...
.. .. ..$ rand84 : num [1:190] 0.00397 0.05556 0.11111 0.07881 0.07639 ...
.. .. ..$ rand85 : num [1:190] 0.313 0.278 0.211 0.15 0.267 ...
.. .. ..$ rand86 : num [1:190] 0.23 0.136 0.133 0.204 0.111 ...
.. .. ..$ rand87 : num [1:190] 0 0.1875 0.1444 0.1047 0.0833 ...
.. .. ..$ rand88 : num [1:190] 0.2143 0.125 0.0333 0.1047 0.1771 ...
.. .. ..$ rand89 : num [1:190] 0.333 0.358 0.267 0.403 0.312 ...
.. .. ..$ rand90 : num [1:190] 0.23 0.194 0.261 0.218 0.174 ...
.. .. ..$ rand91 : num [1:190] 0.179 0.167 0.256 0.202 0.167 ...
.. .. ..$ rand92 : num [1:190] 0.0357 0.0375 0.0556 0.1512 0.0729 ...
.. .. ..$ rand93 : num [1:190] 0.0238 0.1625 0.1667 0.1628 0.0833 ...
.. .. ..$ rand94 : num [1:190] 0.131 0.1875 0.0444 0.093 0.0625 ...
.. .. ..$ rand95 : num [1:190] 0.1032 0.1181 0.1222 0.0556 0.1076 ...
.. .. ..$ rand96 : num [1:190] 0.0556 0.0931 0.0778 0.1602 0.1701 ...
.. .. ..$ rand97 : num [1:190] 0.1825 0.1111 0.0778 0.0762 0.059 ...
.. .. .. [list output truncated]
.. ..$ :'data.frame':	190 obs. of  102 variables:
.. .. ..$ name1  : Factor w/ 19 levels &quot;s10&quot;,&quot;s11&quot;,&quot;s12&quot;,..: 11 13 14 15 16 17 18 19 1 2 ...
.. .. ..$ name2  : Factor w/ 19 levels &quot;s1&quot;,&quot;s10&quot;,&quot;s11&quot;,..: 1 1 1 1 1 1 1 1 1 1 ...
.. .. ..$ rand1  : num [1:190] 0.1151 0.0306 0.0778 0.137 0.1076 ...
.. .. ..$ rand2  : num [1:190] 0.0397 0.0903 0.0611 0.1324 0.0903 ...
.. .. ..$ rand3  : num [1:190] 0.1032 0.1181 0.0778 0.1137 0.0868 ...
.. .. ..$ rand4  : num [1:190] 0.0635 0.0403 0.0389 0.0627 0.0694 ...
.. .. ..$ rand5  : num [1:190] 0.0833 0 0.0778 0.1047 0.0417 ...
.. .. ..$ rand6  : num [1:190] 0.0238 0.05 0.1222 0.0465 0.0417 ...
.. .. ..$ rand7  : num [1:190] 0.167 0.146 0.106 0.153 0.104 ...
.. .. ..$ rand8  : num [1:190] 0.0476 0.0375 0.0556 0.0116 0.0312 ...
.. .. ..$ rand9  : num [1:190] 0.0516 0.0556 0.1 0.0672 0.0868 ...
.. .. ..$ rand10 : num [1:190] 0.0794 0.0556 0.0444 0.0672 0.066 ...
.. .. ..$ rand11 : num [1:190] 0.0278 0.0278 0.1278 0.1092 0.059 ...
.. .. ..$ rand12 : num [1:190] 0.0595 0.1958 0.1167 0.1415 0.0729 ...
.. .. ..$ rand13 : num [1:190] 0.262 0.167 0.156 0.248 0.281 ...
.. .. ..$ rand14 : num [1:190] 0.0992 0.0861 0.0889 0.0762 0.0694 ...
.. .. ..$ rand15 : num [1:190] 0.1706 0.1361 0.0778 0.146 0.1111 ...
.. .. ..$ rand16 : num [1:190] 0.1349 0.1153 0.05 0.0743 0.0486 ...
.. .. ..$ rand17 : num [1:190] 0.0952 0.0833 0.0722 0.095 0.1042 ...
.. .. ..$ rand18 : num [1:190] 0.0833 0.025 0 0.0698 0.0729 ...
.. .. ..$ rand19 : num [1:190] 0.0119 0.075 0.0333 0.1279 0.0625 ...
.. .. ..$ rand20 : num [1:190] 0.0595 0.0125 0.0889 0.0814 0.0312 ...
.. .. ..$ rand21 : num [1:190] 0.0675 0.0806 0.1222 0.1486 0.0347 ...
.. .. ..$ rand22 : num [1:190] 0.0278 0.0403 0.0278 0.1092 0.1111 ...
.. .. ..$ rand23 : num [1:190] 0.0714 0.0625 0.0333 0.0581 0.0417 ...
.. .. ..$ rand24 : num [1:190] 0.0357 0.05 0.0222 0.0233 0.0625 ...
.. .. ..$ rand25 : num [1:190] 0.0119 0.0375 0.0333 0.0698 0.0729 ...
.. .. ..$ rand26 : num [1:190] 0.127 0.1181 0.1 0.0323 0.0972 ...
.. .. ..$ rand27 : num [1:190] 0.1429 0.0958 0.1056 0.0975 0.1042 ...
.. .. ..$ rand28 : num [1:190] 0.1071 0.0375 0.0444 0.0233 0.0417 ...
.. .. ..$ rand29 : num [1:190] 0.23 0.219 0.139 0.206 0.122 ...
.. .. ..$ rand30 : num [1:190] 0.183 0.186 0.189 0.146 0.111 ...
.. .. ..$ rand31 : num [1:190] 0.0476 0.2333 0.0722 0.1415 0.1563 ...
.. .. ..$ rand32 : num [1:190] 0.187 0.247 0.256 0.234 0.253 ...
.. .. ..$ rand33 : num [1:190] 0.0595 0.0125 0.1 0.0233 0.0312 ...
.. .. ..$ rand34 : num [1:190] 0.0238 0.05 0.0222 0.0465 0 ...
.. .. ..$ rand35 : num [1:190] 0.0952 0.05 0.0667 0.0349 0.1042 ...
.. .. ..$ rand36 : num [1:190] 0.0476 0.075 0.0667 0.1047 0.1146 ...
.. .. ..$ rand37 : num [1:190] 0.0476 0.1 0.1222 0.0698 0.0938 ...
.. .. ..$ rand38 : num [1:190] 0.19 0.179 0.144 0.134 0.188 ...
.. .. ..$ rand39 : num [1:190] 0 0 0.0889 0.0233 0.0104 ...
.. .. ..$ rand40 : num [1:190] 0.04365 0.06806 0.05556 0.09044 0.00347 ...
.. .. ..$ rand41 : num [1:190] 0.0119 0.0375 0.0111 0.1047 0.0729 ...
.. .. ..$ rand42 : num [1:190] 0.214 0.275 0.183 0.192 0.25 ...
.. .. ..$ rand43 : num [1:190] 0.0913 0.0931 0.0556 0.137 0.1181 ...
.. .. ..$ rand44 : num [1:190] 0.1587 0.0861 0.1111 0.0762 0.0694 ...
.. .. ..$ rand45 : num [1:190] 0.143 0.167 0.189 0.178 0.26 ...
.. .. ..$ rand46 : num [1:190] 0.0278 0.0403 0.0389 0.0627 0.0382 ...
.. .. ..$ rand47 : num [1:190] 0.0357 0.0625 0.0222 0.1137 0.0208 ...
.. .. ..$ rand48 : num [1:190] 0.131 0.0708 0.1611 0.095 0.1042 ...
.. .. ..$ rand49 : num [1:190] 0 0.075 0.0111 0.0465 0 ...
.. .. ..$ rand50 : num [1:190] 0.119 0 0.0222 0.093 0.0625 ...
.. .. ..$ rand51 : num [1:190] 0.1071 0.0625 0.0222 0.0349 0 ...
.. .. ..$ rand52 : num [1:190] 0.00794 0.10278 0.08333 0.06266 0.10069 ...
.. .. ..$ rand53 : num [1:190] 0.123 0.0861 0.1222 0.1227 0.2569 ...
.. .. ..$ rand54 : num [1:190] 0.1071 0.0681 0.0778 0.0439 0.1042 ...
.. .. ..$ rand55 : num [1:190] 0.0357 0.0875 0.0889 0.0116 0.0208 ...
.. .. ..$ rand56 : num [1:190] 0.0833 0.0458 0.0833 0.1298 0.0833 ...
.. .. ..$ rand57 : num [1:190] 0.0595 0.0625 0.0667 0.0698 0.0521 ...
.. .. ..$ rand58 : num [1:190] 0.135 0.136 0.1 0.123 0.101 ...
.. .. ..$ rand59 : num [1:190] 0.1071 0.0833 0.0944 0.095 0.0938 ...
.. .. ..$ rand60 : num [1:190] 0.0119 0 0.0333 0.0581 0.0104 ...
.. .. ..$ rand61 : num [1:190] 0.1984 0.1514 0.0944 0.1389 0.1285 ...
.. .. ..$ rand62 : num [1:190] 0.0833 0.0528 0.0944 0.1182 0.184 ...
.. .. ..$ rand63 : num [1:190] 0.119 0.1083 0.1944 0.0368 0.0729 ...
.. .. ..$ rand64 : num [1:190] 0.0556 0.0931 0.0556 0.0788 0.0868 ...
.. .. ..$ rand65 : num [1:190] 0.0357 0.0875 0.0333 0.0465 0.0312 ...
.. .. ..$ rand66 : num [1:190] 0.123 0.1528 0.1278 0.051 0.0278 ...
.. .. ..$ rand67 : num [1:190] 0.0992 0.0528 0.1056 0.0743 0.1111 ...
.. .. ..$ rand68 : num [1:190] 0.0119 0.025 0.0556 0.0349 0.0729 ...
.. .. ..$ rand69 : num [1:190] 0.0754 0.1111 0.1556 0.1344 0.1007 ...
.. .. ..$ rand70 : num [1:190] 0.0595 0.0375 0.1 0.0698 0.0417 ...
.. .. ..$ rand71 : num [1:190] 0.0238 0.025 0.1 0.0233 0.0833 ...
.. .. ..$ rand72 : num [1:190] 0.1468 0.1111 0.0778 0.0995 0.0799 ...
.. .. ..$ rand73 : num [1:190] 0.0119 0.05 0 0.0116 0.125 ...
.. .. ..$ rand74 : num [1:190] 0.0873 0.0528 0.05 0.1001 0.0139 ...
.. .. ..$ rand75 : num [1:190] 0.0952 0.0833 0.0611 0.1066 0.0521 ...
.. .. ..$ rand76 : num [1:190] 0.0714 0 0.1333 0.0581 0.0521 ...
.. .. ..$ rand77 : num [1:190] 0 0.0125 0 0.0581 0 ...
.. .. ..$ rand78 : num [1:190] 0.0119 0.0125 0.0556 0 0.0208 ...
.. .. ..$ rand79 : num [1:190] 0.119 0.075 0.0778 0.0698 0.0208 ...
.. .. ..$ rand80 : num [1:190] 0.0992 0.0278 0.0389 0.0627 0.0174 ...
.. .. ..$ rand81 : num [1:190] 0 0.0625 0.0556 0.1163 0.0521 ...
.. .. ..$ rand82 : num [1:190] 0.0873 0.1486 0.1333 0.1111 0.1528 ...
.. .. ..$ rand83 : num [1:190] 0.0476 0.05 0.0556 0.0581 0.0417 ...
.. .. ..$ rand84 : num [1:190] 0.0833 0.0625 0 0.0116 0 ...
.. .. ..$ rand85 : num [1:190] 0.0992 0.0403 0.1056 0.051 0.059 ...
.. .. ..$ rand86 : num [1:190] 0.0952 0.1208 0.1167 0.0601 0.125 ...
.. .. ..$ rand87 : num [1:190] 0.0357 0.0375 0.0667 0 0.0417 ...
.. .. ..$ rand88 : num [1:190] 0.0952 0.075 0.1111 0.0116 0.0312 ...
.. .. ..$ rand89 : num [1:190] 0.0833 0.1125 0.0667 0.0581 0.0312 ...
.. .. ..$ rand90 : num [1:190] 0.1071 0.1125 0.0667 0.0814 0 ...
.. .. ..$ rand91 : num [1:190] 0.0556 0.1181 0.1333 0.0672 0.0972 ...
.. .. ..$ rand92 : num [1:190] 0 0.025 0.0778 0.0233 0.0625 ...
.. .. ..$ rand93 : num [1:190] 0 0.0625 0.0222 0.0581 0.1354 ...
.. .. ..$ rand94 : num [1:190] 0 0.025 0.0111 0.0581 0 ...
.. .. ..$ rand95 : num [1:190] 0.1429 0.1083 0.0611 0.1647 0.1146 ...
.. .. ..$ rand96 : num [1:190] 0.119 0.075 0.0667 0.0233 0.0938 ...
.. .. ..$ rand97 : num [1:190] 0.0833 0 0.0333 0.0349 0 ...
.. .. .. [list output truncated]
.. ..$ :'data.frame':	190 obs. of  102 variables:
.. .. ..$ name1  : Factor w/ 19 levels &quot;s10&quot;,&quot;s11&quot;,&quot;s12&quot;,..: 11 13 14 15 16 17 18 19 1 2 ...
.. .. ..$ name2  : Factor w/ 19 levels &quot;s1&quot;,&quot;s10&quot;,&quot;s11&quot;,..: 1 1 1 1 1 1 1 1 1 1 ...
.. .. ..$ rand1  : num [1:190] 0.639 0.526 0.511 0.563 0.535 ...
.. .. ..$ rand2  : num [1:190] 0.603 0.572 0.683 0.561 0.618 ...
.. .. ..$ rand3  : num [1:190] 0.742 0.557 0.833 0.607 0.542 ...
.. .. ..$ rand4  : num [1:190] 0.627 0.41 0.444 0.397 0.649 ...
.. .. ..$ rand5  : num [1:190] 0.714 0.704 0.561 0.614 0.583 ...
.. .. ..$ rand6  : num [1:190] 0.409 0.319 0.394 0.457 0.538 ...
.. .. ..$ rand7  : num [1:190] 0.405 0.517 0.517 0.545 0.427 ...
.. .. ..$ rand8  : num [1:190] 0.456 0.696 0.489 0.58 0.58 ...
.. .. ..$ rand9  : num [1:190] 0.591 0.426 0.411 0.389 0.649 ...
.. .. ..$ rand10 : num [1:190] 0.667 0.629 0.461 0.533 0.427 ...
.. .. ..$ rand11 : num [1:190] 0.365 0.626 0.367 0.307 0.368 ...
.. .. ..$ rand12 : num [1:190] 0.762 0.642 0.683 0.626 0.708 ...
.. .. ..$ rand13 : num [1:190] 0.413 0.497 0.478 0.513 0.556 ...
.. .. ..$ rand14 : num [1:190] 0.635 0.553 0.533 0.452 0.58 ...
.. .. ..$ rand15 : num [1:190] 0.488 0.458 0.622 0.554 0.604 ...
.. .. ..$ rand16 : num [1:190] 0.587 0.632 0.644 0.561 0.726 ...
.. .. ..$ rand17 : num [1:190] 0.337 0.532 0.483 0.45 0.455 ...
.. .. ..$ rand18 : num [1:190] 0.484 0.585 0.583 0.647 0.649 ...
.. .. ..$ rand19 : num [1:190] 0.631 0.662 0.5 0.453 0.802 ...
.. .. ..$ rand20 : num [1:190] 0.603 0.406 0.389 0.513 0.649 ...
.. .. ..$ rand21 : num [1:190] 0.762 0.596 0.6 0.612 0.729 ...
.. .. ..$ rand22 : num [1:190] 0.544 0.45 0.628 0.495 0.597 ...
.. .. ..$ rand23 : num [1:190] 0.393 0.479 0.394 0.417 0.406 ...
.. .. ..$ rand24 : num [1:190] 0.679 0.696 0.644 0.554 0.49 ...
.. .. ..$ rand25 : num [1:190] 0.79 0.487 0.6 0.558 0.677 ...
.. .. ..$ rand26 : num [1:190] 0.484 0.547 0.411 0.594 0.389 ...
.. .. ..$ rand27 : num [1:190] 0.44 0.417 0.583 0.48 0.521 ...
.. .. ..$ rand28 : num [1:190] 0.27 0.522 0.322 0.455 0.333 ...
.. .. ..$ rand29 : num [1:190] 0.389 0.606 0.472 0.492 0.42 ...
.. .. ..$ rand30 : num [1:190] 0.702 0.683 0.567 0.627 0.479 ...
.. .. ..$ rand31 : num [1:190] 0.476 0.442 0.361 0.364 0.594 ...
.. .. ..$ rand32 : num [1:190] 0.516 0.59 0.489 0.499 0.497 ...
.. .. ..$ rand33 : num [1:190] 0.643 0.586 0.339 0.591 0.427 ...
.. .. ..$ rand34 : num [1:190] 0.5 0.492 0.433 0.563 0.639 ...
.. .. ..$ rand35 : num [1:190] 0.317 0.551 0.678 0.528 0.326 ...
.. .. ..$ rand36 : num [1:190] 0.694 0.669 0.344 0.5 0.604 ...
.. .. ..$ rand37 : num [1:190] 0.623 0.632 0.567 0.596 0.663 ...
.. .. ..$ rand38 : num [1:190] 0.393 0.621 0.489 0.45 0.583 ...
.. .. ..$ rand39 : num [1:190] 0.389 0.413 0.494 0.657 0.58 ...
.. .. ..$ rand40 : num [1:190] 0.425 0.535 0.467 0.513 0.462 ...
.. .. ..$ rand41 : num [1:190] 0.623 0.713 0.478 0.558 0.625 ...
.. .. ..$ rand42 : num [1:190] 0.452 0.575 0.417 0.576 0.427 ...
.. .. ..$ rand43 : num [1:190] 0.452 0.482 0.6 0.514 0.434 ...
.. .. ..$ rand44 : num [1:190] 0.389 0.289 0.656 0.54 0.701 ...
.. .. ..$ rand45 : num [1:190] 0.738 0.458 0.622 0.671 0.542 ...
.. .. ..$ rand46 : num [1:190] 0.528 0.474 0.628 0.663 0.569 ...
.. .. ..$ rand47 : num [1:190] 0.52 0.576 0.544 0.494 0.681 ...
.. .. ..$ rand48 : num [1:190] 0.464 0.642 0.539 0.521 0.406 ...
.. .. ..$ rand49 : num [1:190] 0.579 0.925 0.611 0.767 0.615 ...
.. .. ..$ rand50 : num [1:190] 0.552 0.511 0.394 0.431 0.215 ...
.. .. ..$ rand51 : num [1:190] 0.69 0.812 0.811 0.826 0.812 ...
.. .. ..$ rand52 : num [1:190] 0.413 0.747 0.561 0.542 0.378 ...
.. .. ..$ rand53 : num [1:190] 0.567 0.714 0.544 0.366 0.514 ...
.. .. ..$ rand54 : num [1:190] 0.635 0.446 0.656 0.654 0.469 ...
.. .. ..$ rand55 : num [1:190] 0.655 0.546 0.656 0.473 0.469 ...
.. .. ..$ rand56 : num [1:190] 0.615 0.506 0.572 0.631 0.628 ...
.. .. ..$ rand57 : num [1:190] 0.48 0.708 0.444 0.572 0.601 ...
.. .. ..$ rand58 : num [1:190] 0.472 0.601 0.544 0.61 0.618 ...
.. .. ..$ rand59 : num [1:190] 0.496 0.501 0.483 0.399 0.264 ...
.. .. ..$ rand60 : num [1:190] 0.552 0.611 0.406 0.617 0.674 ...
.. .. ..$ rand61 : num [1:190] 0.516 0.536 0.406 0.605 0.538 ...
.. .. ..$ rand62 : num [1:190] 0.603 0.626 0.533 0.563 0.556 ...
.. .. ..$ rand63 : num [1:190] 0.484 0.514 0.567 0.726 0.41 ...
.. .. ..$ rand64 : num [1:190] 0.468 0.357 0.433 0.514 0.559 ...
.. .. ..$ rand65 : num [1:190] 0.548 0.625 0.511 0.628 0.573 ...
.. .. ..$ rand66 : num [1:190] 0.46 0.272 0.511 0.443 0.535 ...
.. .. ..$ rand67 : num [1:190] 0.627 0.685 0.606 0.582 0.611 ...
.. .. ..$ rand68 : num [1:190] 0.476 0.617 0.439 0.486 0.531 ...
.. .. ..$ rand69 : num [1:190] 0.429 0.375 0.428 0.494 0.51 ...
.. .. ..$ rand70 : num [1:190] 0.476 0.458 0.5 0.554 0.531 ...
.. .. ..$ rand71 : num [1:190] 0.683 0.751 0.367 0.628 0.483 ...
.. .. ..$ rand72 : num [1:190] 0.44 0.25 0.517 0.483 0.531 ...
.. .. ..$ rand73 : num [1:190] 0.552 0.557 0.361 0.443 0.392 ...
.. .. ..$ rand74 : num [1:190] 0.496 0.767 0.506 0.635 0.524 ...
.. .. ..$ rand75 : num [1:190] 0.46 0.46 0.6 0.571 0.368 ...
.. .. ..$ rand76 : num [1:190] 0.643 0.567 0.639 0.498 0.594 ...
.. .. ..$ rand77 : num [1:190] 0.56 0.596 0.578 0.531 0.385 ...
.. .. ..$ rand78 : num [1:190] 0.615 0.601 0.522 0.578 0.542 ...
.. .. ..$ rand79 : num [1:190] 0.595 0.583 0.511 0.651 0.667 ...
.. .. ..$ rand80 : num [1:190] 0.675 0.551 0.511 0.633 0.472 ...
.. .. ..$ rand81 : num [1:190] 0.425 0.576 0.556 0.459 0.399 ...
.. .. ..$ rand82 : num [1:190] 0.579 0.597 0.511 0.548 0.545 ...
.. .. ..$ rand83 : num [1:190] 0.437 0.585 0.572 0.635 0.618 ...
.. .. ..$ rand84 : num [1:190] 0.611 0.432 0.733 0.63 0.569 ...
.. .. ..$ rand85 : num [1:190] 0.587 0.507 0.461 0.52 0.382 ...
.. .. ..$ rand86 : num [1:190] 0.413 0.393 0.55 0.48 0.535 ...
.. .. ..$ rand87 : num [1:190] 0.472 0.45 0.522 0.616 0.493 ...
.. .. ..$ rand88 : num [1:190] 0.595 0.675 0.489 0.442 0.604 ...
.. .. ..$ rand89 : num [1:190] 0.583 0.454 0.489 0.516 0.552 ...
.. .. ..$ rand90 : num [1:190] 0.433 0.593 0.606 0.488 0.535 ...
.. .. ..$ rand91 : num [1:190] 0.353 0.615 0.567 0.429 0.66 ...
.. .. ..$ rand92 : num [1:190] 0.702 0.562 0.511 0.547 0.552 ...
.. .. ..$ rand93 : num [1:190] 0.548 0.65 0.5 0.523 0.559 ...
.. .. ..$ rand94 : num [1:190] 0.536 0.487 0.878 0.57 0.812 ...
.. .. ..$ rand95 : num [1:190] 0.635 0.674 0.617 0.64 0.715 ...
.. .. ..$ rand96 : num [1:190] 0.444 0.54 0.344 0.584 0.528 ...
.. .. ..$ rand97 : num [1:190] 0.409 0.428 0.378 0.517 0.33 ...
.. .. .. [list output truncated]
$ special.crct:List of 1
..$ SigbMPDi:List of 3
.. ..$ special.ses :'data.frame':	190 obs. of  5 variables:
.. .. ..$ name1: Factor w/ 19 levels &quot;s10&quot;,&quot;s11&quot;,&quot;s12&quot;,..: 11 13 14 15 16 17 18 19 1 2 ...
.. .. ..$ name2: Factor w/ 19 levels &quot;s1&quot;,&quot;s10&quot;,&quot;s11&quot;,..: 1 1 1 1 1 1 1 1 1 1 ...
.. .. ..$ bin1 : num [1:190] 0 0 0 0 0 0 0 0 0 0 ...
.. .. ..$ bin2 : num [1:190] 0 0 0 0 0 0 0 -99 0 0 ...
.. .. ..$ bin3 : num [1:190] 0 0 0 0 0 0 0 0 0 0 ...
.. ..$ special.rc  :'data.frame':	190 obs. of  5 variables:
.. .. ..$ name1: Factor w/ 19 levels &quot;s10&quot;,&quot;s11&quot;,&quot;s12&quot;,..: 11 13 14 15 16 17 18 19 1 2 ...
.. .. ..$ name2: Factor w/ 19 levels &quot;s1&quot;,&quot;s10&quot;,&quot;s11&quot;,..: 1 1 1 1 1 1 1 1 1 1 ...
.. .. ..$ bin1 : num [1:190] 0 0 0 0 0 0 0 0 0 0 ...
.. .. ..$ bin2 : num [1:190] 0 0 0 0 0 0 0 -1.1 0 0 ...
.. .. ..$ bin3 : num [1:190] 0 0 0 0 0 0 0 0 0 0 ...
.. ..$ special.conf:'data.frame':	190 obs. of  5 variables:
.. .. ..$ name1: Factor w/ 19 levels &quot;s10&quot;,&quot;s11&quot;,&quot;s12&quot;,..: 11 13 14 15 16 17 18 19 1 2 ...
.. .. ..$ name2: Factor w/ 19 levels &quot;s1&quot;,&quot;s10&quot;,&quot;s11&quot;,..: 1 1 1 1 1 1 1 1 1 1 ...
.. .. ..$ bin1 : num [1:190] 0 0 0 0 0 0 0 0 0 0 ...
.. .. ..$ bin2 : num [1:190] 0 0 0 0 0 0 0 -1.1 0 0 ...
.. .. ..$ bin3 : num [1:190] 0 0 0 0 0 0 0 0 0 0 ...
</p>


<h3>Details</h3>

<p>See help of icamp.big for detail.
</p>


<h3>Source</h3>

<p>icamp.big result from the example.data.
</p>


<h3>References</h3>

<p>Ning, D., Yuan, M., Wu, L., Zhang, Y., Guo, X., Zhou, X. et al. (2020). A quantitative framework reveals ecological drivers of grassland microbial community assembly in response to warming. Nature Communications, 11, 4717.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(icamp.out)
</code></pre>

<hr>
<h2 id='match.2col'>
Check the consistency of the first two columns of different matrixes 
</h2><span id='topic+match.2col'></span>

<h3>Description</h3>

<p>This function is usually used to check the consistency of samples names in different pairwise comparison matrixes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>match.2col(check.list, name.check = NULL, rerank = TRUE, silent = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="match.2col_+3A_check.list">check.list</code></td>
<td>
<p>List, each element is a matrix. It must be set in a format like &quot;check.list=list(A=A,B=B)&quot;.
The first two columns of the matrixes will be compared and matched with each other. </p>
</td></tr>
<tr><td><code id="match.2col_+3A_name.check">name.check</code></td>
<td>
<p>matrix, the first two columns will be used as a standard. The pairs not appear in this matrix will be removed from all matrixes.</p>
</td></tr>
<tr><td><code id="match.2col_+3A_rerank">rerank</code></td>
<td>
<p>Logic, make the first two columns in all matrixes in the same rank or not. Default is TRUE.</p>
</td></tr>
<tr><td><code id="match.2col_+3A_silent">silent</code></td>
<td>
<p>Logic, whether to show messages. Default is FALSE, thus all messages will be showed.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A tool to match IDs.
</p>


<h3>Value</h3>

<p>Return a list object, new matrixes with the same first two columns. Some messages will return if some names are removed or all names matches very well.
</p>


<h3>Note</h3>

<p>Version 2: 2020.8.19, add example.
Version 1: 2018.10.20
</p>


<h3>Author(s)</h3>

<p>Daliang Ning
</p>


<h3>Examples</h3>

<pre><code class='language-R'># here two simple matrixes are generated and the pairwise comparison IDs not matched are removed.
A=1:5
names(A)=paste0("S",1:5)
B=1:6
names(B)=paste0("S",1:6)
DA3c=dist.3col(dist(A))
DB3c=dist.3col(dist(B))

checkid=match.2col(check.list = list(DA3c=DA3c,DB3c=DB3c))
DA3cnew=checkid$DA3c
DB3cnew=checkid$DB3c
</code></pre>

<hr>
<h2 id='match.name'>
Check and ensure the consistency of IDs in different objects.
</h2><span id='topic+match.name'></span>

<h3>Description</h3>

<p>This function is usually used to check the consistency of species or samples names in different data table (e.g. OTU table and phylogenetic distance matrix). it can be used to check row names and/or column names of different matrixes, names in vector(s) or list(s), and tip.lable in tree(s)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>match.name(name.check=integer(0), rn.list=list(integer(0)),
           cn.list=list(integer(0)), both.list=list(integer(0)),
           v.list=list(integer(0)), lf.list=list(integer(0)),
           tree.list=list(integer(0)), group=integer(0),
           rerank=TRUE, silent=FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="match.name_+3A_name.check">name.check</code></td>
<td>
<p>A character vector, indicating reference name list or the names you would like to keep. If not available, a union of all names is set as reference name list.</p>
</td></tr>
<tr><td><code id="match.name_+3A_rn.list">rn.list</code></td>
<td>
<p>A list object, including the matrix(es) of which the row names will be check. rn.list must be set in a format like &quot;rn.list=list(A=A,B=B)&quot;. default is nothing.</p>
</td></tr>
<tr><td><code id="match.name_+3A_cn.list">cn.list</code></td>
<td>
<p>A list object, including the matrix(es) of which the column names will be check. cn.list must be set in a format like &quot;cn.list=list(A=A,B=B)&quot;. default is nothing.</p>
</td></tr>
<tr><td><code id="match.name_+3A_both.list">both.list</code></td>
<td>
<p>A list object, including the matrix(es) of which both column and row names will be check. both.list must be set in a format like &quot;both.list=list(A=A,B=B)&quot;. default is nothing.</p>
</td></tr>
<tr><td><code id="match.name_+3A_v.list">v.list</code></td>
<td>
<p>A list object, including the vector(s) of which the names will be check. v.list must be set in a format like &quot;v.list=list(A=A,B=B)&quot;.default is nothing.</p>
</td></tr>
<tr><td><code id="match.name_+3A_lf.list">lf.list</code></td>
<td>
<p>A list object, including the list(s) of which the names will be check. lf.list must be set in a format like &quot;lf.list=list(A=A,B=B)&quot;.default is nothing.</p>
</td></tr>
<tr><td><code id="match.name_+3A_tree.list">tree.list</code></td>
<td>
<p>A list object, including the tree(s) of which the tip.label names will be check. tree.list must be set in a format like &quot;tree.list=list(A=A,B=B)&quot;.default is nothing.</p>
</td></tr>
<tr><td><code id="match.name_+3A_group">group</code></td>
<td>
<p>a vector or one-column matrix/data.frame indicating the grouping information of samples or species, of which the sample/species names will be check.</p>
</td></tr>
<tr><td><code id="match.name_+3A_rerank">rerank</code></td>
<td>
<p>Logic, make all names in the same rank or not. Default is TRUE</p>
</td></tr>
<tr><td><code id="match.name_+3A_silent">silent</code></td>
<td>
<p>Logic, whether to show messages. Default is FALSE, thus all messages will be showed.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>In many cases and functions, species names and samples names must be checked and set in the same rank. Sometimes, we also need to select some samples or species as necessary. This function can help.
</p>


<h3>Value</h3>

<p>Return a list object, new matrixes with the same row/column names in the same rank. 
Some messages will return if some names are removed or all names match very well.
</p>


<h3>Note</h3>

<p>Version 3: 2017.3.13
Version 2: 2015.9.25
</p>


<h3>Author(s)</h3>

<p>Daliang Ning
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("example.data")
comm=example.data$comm
treat=example.data$treat
tree=example.data$tree
pd=example.data$pd
clas=example.data$classification

env=example.data$env
# remove one sample in purpose to see how match.name works
env=env[-13,]

sampid.check=match.name(rn.list = list(comm=comm, treat=treat, env=env))
comm.ck=sampid.check$comm
comm.ck=comm.ck[,colSums(comm.ck)&gt;0,drop=FALSE]
treat.ck=sampid.check$treat
env.ck=sampid.check$env

taxid.check=match.name(cn.list = list(comm.ck=comm.ck),
                       rn.list = list(clas=clas),
                       tree.list = list(tree=tree))
comm.ck=taxid.check$comm.ck
clas.ck=taxid.check$clas
tree.ck=taxid.check$tree
</code></pre>

<hr>
<h2 id='maxbigm'>
Find maximum value in a big matrix
</h2><span id='topic+maxbigm'></span>

<h3>Description</h3>

<p>Return the maxium value and its (their) location(s) in a big matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>maxbigm(m.desc, m.wd, nworker = 1, rm.na = TRUE, size.limit = 10000 * 10000)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="maxbigm_+3A_m.desc">m.desc</code></td>
<td>
<p>the name of the file to hold the backingfile description of the big matrix.</p>
</td></tr>
<tr><td><code id="maxbigm_+3A_m.wd">m.wd</code></td>
<td>
<p>the path of the folder holding the big matrix file.</p>
</td></tr>
<tr><td><code id="maxbigm_+3A_nworker">nworker</code></td>
<td>
<p>integer, for parallel computing. Either a character vector of host names on which to run the worker copies of R, or a positive integer (in which case that number of copies is run on localhost). default is 4, means 4 threads will be run.</p>
</td></tr>
<tr><td><code id="maxbigm_+3A_rm.na">rm.na</code></td>
<td>
<p>logic, whether to remove NA. Default is TRUE.</p>
</td></tr>
<tr><td><code id="maxbigm_+3A_size.limit">size.limit</code></td>
<td>
<p>the matrix size which your current computer memory can easily handle at each time.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A tool to figure out the maximum value in the big phylogenetic distance matrix.
</p>


<h3>Value</h3>

<p>Output is a list of two elements.
</p>
<table>
<tr><td><code>max.value</code></td>
<td>
<p>Numeric, the maximum value.</p>
</td></tr>
<tr><td><code>row.col</code></td>
<td>
<p>Matrix, the row(s) and column(s), i.e. the location(s), of the maximum value in the big matrix.</p>
</td></tr>
</table>


<h3>Note</h3>

<p>Version 3: 2020.9.1, remove setwd; change dontrun to donttest and revise save.wd in help doc.
Version 2: 2020.8.19, add example.
Version 1: 2015.12.16
</p>


<h3>Author(s)</h3>

<p>Daliang Ning
</p>


<h3>References</h3>

<p>Michael J. Kane, John Emerson, Stephen Weston (2013). Scalable Strategies for Computing with Massive Data. Journal of Statistical Software, 55(14), 1-19. URL http://www.jstatsoft.org/v55/i14/.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+midpoint.root.big">midpoint.root.big</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># this example shows how to find maximum value
# in a big phylogenetic distance matrix.
data("example.data")
tree=example.data$tree
# since pdist.big need to save output to a certain folder,
# the following code is set as 'not test'.
# but you may test the code on your computer
# after change the folder path for 'save.wd'.

  wd0=getwd()
  save.wd=paste0(tempdir(),"/pdbig.maxbigm")
  # please change to the folder you want to save the pd.big output.
  
  nworker=2 # parallel computing thread number
  pd.big=pdist.big(tree = tree, wd=save.wd, nworker = nworker)
  
  maxb=maxbigm(m.desc = pd.big$pd.file, m.wd = pd.big$pd.wd,
               nworker = nworker, rm.na = TRUE)
  setwd(wd0)

</code></pre>

<hr>
<h2 id='midpoint.root.big'>
Midpoint root a large phylogeny
</h2><span id='topic+midpoint.root.big'></span>

<h3>Description</h3>

<p>This is modified from the function &quot;modpoint.root&quot; in package &quot;phytools&quot;. To deal with a large tree, phylogenetic distance is calculated and saved by using bigmemory in advance.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>midpoint.root.big(tree, pd.desc, pd.spname, pd.wd, nworker = 4)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="midpoint.root.big_+3A_tree">tree</code></td>
<td>
<p>phylogenetic tree, an object of class &quot;phylo&quot;.</p>
</td></tr>
<tr><td><code id="midpoint.root.big_+3A_pd.desc">pd.desc</code></td>
<td>
<p>the name of the file to hold the backingfile description of the phylogenetic distance matrix, it is usually &quot;pd.desc&quot; if using default setting in pdist.big function.</p>
</td></tr>
<tr><td><code id="midpoint.root.big_+3A_pd.spname">pd.spname</code></td>
<td>
<p>character vector, taxa id in the same rank as the big matrix of phylogenetic distances.</p>
</td></tr>
<tr><td><code id="midpoint.root.big_+3A_pd.wd">pd.wd</code></td>
<td>
<p>folder path, where the bigmemmory file of the phylogenetic distance matrix are saved.</p>
</td></tr>
<tr><td><code id="midpoint.root.big_+3A_nworker">nworker</code></td>
<td>
<p>integer, for parallel computing. Either a character vector of host names on which to run the worker copies of R, or a positive integer (in which case that number of copies is run on localhost). default is 4, means 4 threads will be run.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>iCAMP analysis need a rooted tree. If it is difficult to figure out the root, midpoint root is recommended for iCAMP analysis. Modified from the function 'midpoint.root' in package 'phytool'(Revell 2012), this function uses bigmemory (Kane et al 2013) to deal with large datasets.
</p>


<h3>Value</h3>

<p>Output is a list with two elements.
</p>
<table>
<tr><td><code>tree</code></td>
<td>
<p>The rooted tree.</p>
</td></tr>
<tr><td><code>max.pd</code></td>
<td>
<p>The maximum pairwise phylogenetic distance.</p>
</td></tr>
</table>


<h3>Note</h3>

<p>Version 3: 2020.9.1, remove setwd; change dontrun to donttest and revise save.wd in help doc.
Version 2: 2020.8.19, update help document, add example.
Version 1: 2015.12.16
</p>


<h3>Author(s)</h3>

<p>Daliang Ning
</p>


<h3>References</h3>

<p>Farris, J. (1972) Estimating phylogenetic trees from distance matrices. American Naturalist, 106, 645-667.
</p>
<p>Paradis, E., J. Claude, and K. Strimmer (2004) APE: Analyses of phylogenetics and evolution in R language. Bioinformatics, 20, 289-290.
</p>
<p>Revell, L. J. (2012) phytools: An R package for phylogenetic comparative biology (and other things). Methods Ecol. Evol., 3, 217-223. 
</p>
<p>Michael J. Kane, John Emerson, Stephen Weston (2013). Scalable Strategies for Computing with Massive Data. Journal of Statistical Software, 55(14), 1-19. URL http://www.jstatsoft.org/v55/i14/.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+maxbigm">maxbigm</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("example.data")
tree=example.data$tree
# since pdist.big need to save output to a certain folder,
# the following code is set as 'not test'.
# but you may test the code on your computer
# after change the folder path for 'save.wd'.

  wd0=getwd()
  save.wd=paste0(tempdir(),"/pdbig.midpointroot")
  # please change to the folder you want to save the pd.big output.
  
  nworker=2 # parallel computing thread number
  pd.big=pdist.big(tree = tree, wd=save.wd, nworker = nworker)
  
  mroot=midpoint.root.big(tree = tree, pd.desc = pd.big$pd.file,
                          pd.spname = pd.big$tip.label,
                          pd.wd = pd.big$pd.wd, nworker = nworker)
  setwd(wd0)

</code></pre>

<hr>
<h2 id='mntdn'>
Mean nearest taxon distance (MNTD)
</h2><span id='topic+mntdn'></span>

<h3>Description</h3>

<p>Calculate mean nearest taxon distance (MNTD) in each community in a given community matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mntdn(comm, pd, abundance.weighted = TRUE,
      check.name = TRUE, memory.G = 50, time.count = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mntdn_+3A_comm">comm</code></td>
<td>
<p>matrix or data.frame, community data matrix, rownames are sample names, colnames are OTU ids.</p>
</td></tr>
<tr><td><code id="mntdn_+3A_pd">pd</code></td>
<td>
<p>matrix, pairwise phylogenetic distance matrix.</p>
</td></tr>
<tr><td><code id="mntdn_+3A_abundance.weighted">abundance.weighted</code></td>
<td>
<p>logic, whether weighted by species abundance, default is TRUE, means weighted.</p>
</td></tr>
<tr><td><code id="mntdn_+3A_check.name">check.name</code></td>
<td>
<p>logic, whether to check the OTU ids (species names) in community matrix and phylogenetic distance matrix are the same.</p>
</td></tr>
<tr><td><code id="mntdn_+3A_memory.g">memory.G</code></td>
<td>
<p>numeric, to set the memory size as you need, so that calculation of large tree will not be limited by physical memory. unit is Gb. default is 50Gb</p>
</td></tr>
<tr><td><code id="mntdn_+3A_time.count">time.count</code></td>
<td>
<p>logic, whether to count calculation time, default is FALSE.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>mean nearest taxon distance (MNTD) in each community, using the same algrithm as the function 'mntd' in package 'picante'.
</p>


<h3>Value</h3>

<p>result is a numeric vector with sample names
</p>


<h3>Note</h3>

<p>Version 2: 2020.8.19, update help document, add example.
Version 1: 2017.3.13
</p>


<h3>Author(s)</h3>

<p>Daliang Ning
</p>


<h3>References</h3>

<p>Webb CO, Ackerly DD, and Kembel SW. (2008). Phylocom: software for the analysis of phylogenetic community structure and trait evolution. Bioinformatics 18:2098-2100
</p>
<p>Kembel, S.W., Cowan, P.D., Helmus, M.R., Cornwell, W.K., Morlon, H., Ackerly, D.D. et al. (2010). Picante: R tools for integrating phylogenies and ecology. Bioinformatics, 26, 1463-1464.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+NTI.p">NTI.p</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("example.data")
comm=example.data$comm
pd=example.data$pd
mntd=mntdn(comm=comm,pd=pd,abundance.weighted = TRUE)
</code></pre>

<hr>
<h2 id='mpdn'>
Mean pairwise distance (MPD)
</h2><span id='topic+mpdn'></span>

<h3>Description</h3>

<p>Calculate mean pairwise distance (MPD) in each community in a given community matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mpdn(comm, pd, abundance.weighted = TRUE, time.output = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mpdn_+3A_comm">comm</code></td>
<td>
<p>matrix or data.frame, community data matrix, rownames are sample names, colnames are OTU ids.</p>
</td></tr>
<tr><td><code id="mpdn_+3A_pd">pd</code></td>
<td>
<p>matrix, pairwise phylogenetic distance matrix.</p>
</td></tr>
<tr><td><code id="mpdn_+3A_abundance.weighted">abundance.weighted</code></td>
<td>
<p>logic, whether weighted by species abundance, default is TRUE, means weighted.</p>
</td></tr>
<tr><td><code id="mpdn_+3A_time.output">time.output</code></td>
<td>
<p>logic, whether to count calculation time, default is FALSE.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>mean pairwise distance (MPD) in each community, which is the same index as 'mpd' in package 'picante', but calculated by matrix multiplication. 
</p>


<h3>Value</h3>

<p>result is a numeric vector with sample names
</p>


<h3>Note</h3>

<p>Version 2: 2020.8.19, update help document, add example.
Version 1: 2017.3.13
</p>


<h3>Author(s)</h3>

<p>Daliang Ning
</p>


<h3>References</h3>

<p>Webb C, Ackerly D, McPeek M, and Donoghue M. (2002). Phylogenies and community ecology. Annual Review of Ecology and Systematics 33:475-505.
</p>
<p>Kembel, S.W., Cowan, P.D., Helmus, M.R., Cornwell, W.K., Morlon, H., Ackerly, D.D. et al. (2010). Picante: R tools for integrating phylogenies and ecology. Bioinformatics, 26, 1463-1464.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+NRI.p">NRI.p</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("example.data")
comm=example.data$comm
pd=example.data$pd
mpd=mpdn(comm = comm, pd = pd, abundance.weighted = TRUE)
</code></pre>

<hr>
<h2 id='NRI.cm'>
Calculate net relatedness index (NRI) under multiple metacommunities
</h2><span id='topic+NRI.cm'></span>

<h3>Description</h3>

<p>Calculate net relatedness index (NRI) or other index of null model significance test based on mean pairwise distance (MPD) by parallel computing, for small and medium size dataset. This function can deal with local communities under different metacommunities (regional pools).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>NRI.cm(comm, dis, meta.group = NULL, meta.spool = NULL,
       nworker = 4, memo.size.GB = 50, weighted = c(TRUE, FALSE),
       check.name = TRUE, rand = 1000,
       output.MPD = c(FALSE, TRUE), silent = FALSE,
       sig.index = c("SES", "NRI", "Confidence", "RC", "all"))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="NRI.cm_+3A_comm">comm</code></td>
<td>
<p>community data matrix. rownames are sample names. colnames are species names.</p>
</td></tr>
<tr><td><code id="NRI.cm_+3A_dis">dis</code></td>
<td>
<p>Phylogenetic distance matrix</p>
</td></tr>
<tr><td><code id="NRI.cm_+3A_meta.group">meta.group</code></td>
<td>
<p>matrix or data.frame, a one-column (n x 1) matrix indicating which metacommunity each sample belongs to. rownames are sample IDs. first column is metacommunity names. Such that different samples can belong to different metacommunities. If input a n x m matrix, only the first column is used. NULL means all samples belong to the same metacommunity. Default is NULL, means all samples from the same metacommunity.</p>
</td></tr>
<tr><td><code id="NRI.cm_+3A_meta.spool">meta.spool</code></td>
<td>
<p>a list object, each element is a character vector listing all taxa IDs in a metacommunity. The names of the elements indicate metacommunity names, which should be the same as the metacommunity names in meta.group. Default is NULL, means to use the observed taxa in comm across samples within the same metacommunity that is defined by meta.group.</p>
</td></tr>
<tr><td><code id="NRI.cm_+3A_nworker">nworker</code></td>
<td>
<p>for parallel computing. Either a character vector of host names on which to run the worker copies of R, or a positive integer (in which case that number of copies is run on localhost). default is 4, means 4 threads will be run.</p>
</td></tr>
<tr><td><code id="NRI.cm_+3A_memo.size.gb">memo.size.GB</code></td>
<td>
<p>numeric, to set the memory size as you need, so that calculation of large tree will not be limited by physical memory. unit is Gb. default is 50Gb.</p>
</td></tr>
<tr><td><code id="NRI.cm_+3A_weighted">weighted</code></td>
<td>
<p>Logic, consider abundances or not (just presence/absence). default is TRUE.</p>
</td></tr>
<tr><td><code id="NRI.cm_+3A_check.name">check.name</code></td>
<td>
<p>Logic, whether to check the species names in comm and dis. default is TRUE.</p>
</td></tr>
<tr><td><code id="NRI.cm_+3A_rand">rand</code></td>
<td>
<p>integer, randomization times. default is 1000.</p>
</td></tr>
<tr><td><code id="NRI.cm_+3A_output.mpd">output.MPD</code></td>
<td>
<p>Logic, whether to output observed MNTD, so that you do not need to calculate observed MNTD alone. default is FALSE.</p>
</td></tr>
<tr><td><code id="NRI.cm_+3A_silent">silent</code></td>
<td>
<p>Logic, if FALSE, some messages will be showed during calculation. Default is FALSE.</p>
</td></tr>
<tr><td><code id="NRI.cm_+3A_sig.index">sig.index</code></td>
<td>
<p>character, the index for null model significance test. SES or NRI, standard effect size, i.e. net relatedness index (NRI); Confidence, percentage of null values less extreme than the observed value, i.e. non-parametric one-side confidence level; RC, modified Raup-Crick index (RC) based on MPD, i.e. count the number of null MPD lower than observed MPD plus a half of the number of null MPD equal to observed MPD, to get alpha, then calculate MPD-based RC as (2 x alpha - 1); all, output all the three indexes. default is SES. If input a vector, only the first element will be used.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is particularly designed for samples from different metacommunities. The null model &quot;taxa shuffle&quot; will be done under different metacommunities, separately (and independently). All other details are the same as the function NRI.p. 
</p>


<h3>Value</h3>

<p>Output can be a data.frame with each row representing a sample and only one column of index values, or a list of several data.frame objects.
</p>
<table>
<tr><td><code>SES</code></td>
<td>
<p>output if sig.index is Confidence or all, a data.frame with NRI value for each sample.</p>
</td></tr>
<tr><td><code>Confidence</code></td>
<td>
<p>output if sig.index is SES or all, a data.frame showing confidence level based on MPD for each sample.</p>
</td></tr>
<tr><td><code>RC</code></td>
<td>
<p>output if sig.index is RC or all, a data.frame showing RC based on MPD for each sample.</p>
</td></tr>
<tr><td><code>MPD.obs</code></td>
<td>
<p>output if output.MPD is TRUE, a data.frame showing observed MPD for each sample.</p>
</td></tr>
<tr><td><code>MPD.rand</code></td>
<td>
<p>output if output.MPD is TRUE, a matrix showing all null MPD values.</p>
</td></tr>
</table>


<h3>Note</h3>

<p>Version 1: 2021.8.4
</p>


<h3>Author(s)</h3>

<p>Daliang Ning
</p>


<h3>References</h3>

<p>Webb CO, Ackerly DD, and Kembel SW. 2008. Phylocom: software for the analysis of phylogenetic community structure and trait evolution. Bioinformatics 18:2098-2100
</p>
<p>Kembel, S.W. (2009). Disentangling niche and neutral influences on community assembly: assessing the performance of community phylogenetic structure tests. Ecol Lett, 12, 949-960.
</p>
<p>Chase, J.M., Kraft, N.J.B., Smith, K.G., Vellend, M. &amp; Inouye, B.D. (2011). Using null models to disentangle variation in community dissimilarity from variation in alpha-diversity. Ecosphere, 2, 1-11.
</p>
<p>Ning, D., Yuan, M., Wu, L., Zhang, Y., Guo, X., Zhou, X. et al. (2020). A quantitative framework reveals ecological drivers of grassland microbial community assembly in response to warming. Nature Communications, 11, 4717.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+NRI.p">NRI.p</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("example.data")
comm=example.data$comm
pd=example.data$pd

# in this example, 10 samples from one metacommunity,
# the other 10 samples from another metacommunity.
meta.group=data.frame(meta.com=c(rep("meta1",10),rep("meta2",10)))
rownames(meta.group)=rownames(comm)

nworker=2 # parallel computing thread number.
rand.time=20 # usually use 1000 for real data.
sigmpd=NRI.cm(comm=comm, meta.group=meta.group,
              dis=pd, nworker=nworker,
              weighted=TRUE, rand=rand.time,
              sig.index="all")
NRI=sigmpd$SES
CMPD=sigmpd$Confidence
RCMPD=sigmpd$RC
</code></pre>

<hr>
<h2 id='NRI.p'>
Calculate net relatedness index (NRI) by parallel computing.
</h2><span id='topic+NRI.p'></span>

<h3>Description</h3>

<p>Calculate net relatedness index (NRI) or other index of null model significance test based on mean pairwise distance (MPD) by parallel computing, for small and medium size dataset.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>NRI.p(comm, dis, nworker = 4, memo.size.GB = 50,
      weighted = c(TRUE, FALSE), check.name = TRUE,
      rand = 1000, output.MPD = c(FALSE, TRUE), silent = FALSE,
      sig.index=c("SES","NRI","Confidence","RC","all"))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="NRI.p_+3A_comm">comm</code></td>
<td>
<p>community data matrix. rownames are sample names. colnames are species names.</p>
</td></tr>
<tr><td><code id="NRI.p_+3A_dis">dis</code></td>
<td>
<p>Phylogenetic distance matrix</p>
</td></tr>
<tr><td><code id="NRI.p_+3A_nworker">nworker</code></td>
<td>
<p>for parallel computing. Either a character vector of host names on which to run the worker copies of R, or a positive integer (in which case that number of copies is run on localhost). default is 4, means 4 threads will be run.</p>
</td></tr>
<tr><td><code id="NRI.p_+3A_memo.size.gb">memo.size.GB</code></td>
<td>
<p>numeric, to set the memory size as you need, so that calculation of large tree will not be limited by physical memory. unit is Gb. default is 50Gb.</p>
</td></tr>
<tr><td><code id="NRI.p_+3A_weighted">weighted</code></td>
<td>
<p>Logic, consider abundances or not (just presence/absence). default is TRUE.</p>
</td></tr>
<tr><td><code id="NRI.p_+3A_check.name">check.name</code></td>
<td>
<p>Logic, whether to check the species names in comm and dis. default is TRUE.</p>
</td></tr>
<tr><td><code id="NRI.p_+3A_rand">rand</code></td>
<td>
<p>integer, randomization times. default is 1000.</p>
</td></tr>
<tr><td><code id="NRI.p_+3A_output.mpd">output.MPD</code></td>
<td>
<p>Logic, whether to output observed MNTD, so that you do not need to calculate observed MNTD alone. default is FALSE.</p>
</td></tr>
<tr><td><code id="NRI.p_+3A_silent">silent</code></td>
<td>
<p>Logic, if FALSE, some messages will be showed during calculation. Default is FALSE.</p>
</td></tr>
<tr><td><code id="NRI.p_+3A_sig.index">sig.index</code></td>
<td>
<p>character, the index for null model significance test. SES or NRI, standard effect size, i.e. net relatedness index (NRI); Confidence, percentage of null values less extreme than the observed value, i.e. non-parametric one-side confidence level; RC, modified Raup-Crick index (RC) based on MPD, i.e. count the number of null MPD lower than observed MPD plus a half of the number of null MPD equal to observed MPD, to get alpha, then calculate MPD-based RC as (2 x alpha - 1); all, output all the three indexes. default is SES. If input a vector, only the first element will be used.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The net relatedness index (NRI) is a standardized measure of the mean pairwise phylogenetic distance in each sample/community (MPD). Currently this function only performs one null model algorithm, &quot;taxa.labels&quot; (&quot;taxa shuffle&quot;, Kembel 2009), which is to shuffle distance matrix labels (across all taxa included in distance matrix). If the randomized results are all the same, the standard deviation will be zero and NRI will be NAN. In this case, NRI will be set as zero, since the observed result is not differentiable from randomized results.
</p>
<p>RC (Chase et al 2011) and Confidence (Ning et al 2020) are alternative significance test indexes to evaluate how the observed diversity index deviates from null expectation, which could be a better metric than standardized effect size (NRI) in some cases, e.g. null values do not follow normal distribution.
</p>


<h3>Value</h3>

<p>Output can be a data.frame with each row representing a sample and only one column of index values, or a list of several data.frame objects.
</p>
<table>
<tr><td><code>SES</code></td>
<td>
<p>output if sig.index is Confidence or all, a data.frame with NRI value for each sample.</p>
</td></tr>
<tr><td><code>Confidence</code></td>
<td>
<p>output if sig.index is SES or all, a data.frame showing confidence level based on MPD for each sample.</p>
</td></tr>
<tr><td><code>RC</code></td>
<td>
<p>output if sig.index is RC or all, a data.frame showing RC based on MPD for each sample.</p>
</td></tr>
<tr><td><code>MPD.obs</code></td>
<td>
<p>output if output.MPD is TRUE, a data.frame showing observed MPD for each sample.</p>
</td></tr>
<tr><td><code>MPD.rand</code></td>
<td>
<p>output if output.MPD is TRUE, a matrix showing all null MPD values.</p>
</td></tr>
</table>


<h3>Note</h3>

<p>Version 2: 2020.8.19, update help document, add example
Version 1: 2017.5.10
</p>


<h3>Author(s)</h3>

<p>Daliang Ning
</p>


<h3>References</h3>

<p>Webb CO, Ackerly DD, and Kembel SW. 2008. Phylocom: software for the analysis of phylogenetic community structure and trait evolution. Bioinformatics 18:2098-2100
</p>
<p>Kembel, S.W. (2009). Disentangling niche and neutral influences on community assembly: assessing the performance of community phylogenetic structure tests. Ecol Lett, 12, 949-960.
</p>
<p>Chase, J.M., Kraft, N.J.B., Smith, K.G., Vellend, M. &amp; Inouye, B.D. (2011). Using null models to disentangle variation in community dissimilarity from variation in alpha-diversity. Ecosphere, 2, 1-11.
</p>
<p>Ning, D., Yuan, M., Wu, L., Zhang, Y., Guo, X., Zhou, X. et al. (2020). A quantitative framework reveals ecological drivers of grassland microbial community assembly in response to warming. Nature Communications, 11, 4717.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+mpdn">mpdn</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("example.data")
comm=example.data$comm
pd=example.data$pd
nworker=2 # parallel computing thread number.
rand.time=20 # usually use 1000 for real data.
sigmpd=NRI.p(comm=comm, dis=pd, nworker=nworker,
             weighted=TRUE, rand=rand.time,
             sig.index="all")
NRI=sigmpd$SES
CMPD=sigmpd$Confidence
RCMPD=sigmpd$RC
</code></pre>

<hr>
<h2 id='NTI.cm'>
Calculate nearest taxon index (NTI) under multiple metacommunities
</h2><span id='topic+NTI.cm'></span>

<h3>Description</h3>

<p>Calculate nearest taxon index (NTI) of each sample with parallel computing. his function can deal with local communities under different metacommunities (regional pools).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>NTI.cm(comm, dis, meta.group = NULL,
       meta.spool = NULL, nworker = 4, memo.size.GB = 50,
       weighted = c(TRUE, FALSE), rand = 1000,
       check.name = TRUE, output.MNTD = c(FALSE, TRUE),
       sig.index = c("SES", "NTI", "Confidence", "RC", "all"),
       silent = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="NTI.cm_+3A_comm">comm</code></td>
<td>
<p>community data matrix. rownames are sample names. colnames are species names.</p>
</td></tr>
<tr><td><code id="NTI.cm_+3A_dis">dis</code></td>
<td>
<p>Phylogenetic distance matrix.</p>
</td></tr>
<tr><td><code id="NTI.cm_+3A_meta.group">meta.group</code></td>
<td>
<p>matrix or data.frame, a one-column (n x 1) matrix indicating which metacommunity each sample belongs to. rownames are sample IDs. first column is metacommunity names. Such that different samples can belong to different metacommunities. If input a n x m matrix, only the first column is used. NULL means all samples belong to the same metacommunity. Default is NULL, means all samples from the same metacommunity.</p>
</td></tr>
<tr><td><code id="NTI.cm_+3A_meta.spool">meta.spool</code></td>
<td>
<p>a list object, each element is a character vector listing all taxa IDs in a metacommunity. The names of the elements indicate metacommunity names, which should be the same as the metacommunity names in meta.group. Default is NULL, means to use the observed taxa in comm across samples within the same metacommunity that is defined by meta.group.</p>
</td></tr>
<tr><td><code id="NTI.cm_+3A_nworker">nworker</code></td>
<td>
<p>for parallel computing. Either a character vector of host names on which to run the worker copies of R, or a positive integer (in which case that number of copies is run on localhost). default is 4, means 4 threads will be run.</p>
</td></tr>
<tr><td><code id="NTI.cm_+3A_memo.size.gb">memo.size.GB</code></td>
<td>
<p>numeric, to set the memory size as you need, so that calculation of large tree will not be limited by physical memory. unit is Gb. default is 50Gb.</p>
</td></tr>
<tr><td><code id="NTI.cm_+3A_weighted">weighted</code></td>
<td>
<p>Logic, consider abundances or not (just presence/absence). default is TRUE.</p>
</td></tr>
<tr><td><code id="NTI.cm_+3A_rand">rand</code></td>
<td>
<p>integer, randomization times. default is 1000.</p>
</td></tr>
<tr><td><code id="NTI.cm_+3A_check.name">check.name</code></td>
<td>
<p>logic, whether to check the taxa names in comm and dis, which must be the same and in the same order; if not match, remove mismatched names and change to the same order. default is TRUE.</p>
</td></tr>
<tr><td><code id="NTI.cm_+3A_output.mntd">output.MNTD</code></td>
<td>
<p>logic, if TRUE, the NTI and MNTD  will be output, if FALSE, only output NTI.</p>
</td></tr>
<tr><td><code id="NTI.cm_+3A_sig.index">sig.index</code></td>
<td>
<p>character, the index for null model significance test. SES or NTI, standard effect size, i.e. nearest taxon index (NTI); Confidence, percentage of null values less extreme than the observed value, i.e. non-parametric one-side confidence level; RC, modified Raup-Crick index (RC) based on MNTD, i.e. count the number of null MNTD lower than observed MNTD plus a half of the number of null MNTD equal to observed MNTD, to get alpha, then calculate MNTD-based RC as (2 x alpha - 1); all, output all the three indexes. default is SES. If input a vector, only the first element will be used.</p>
</td></tr>
<tr><td><code id="NTI.cm_+3A_silent">silent</code></td>
<td>
<p>logic, if FALSE, some messages will show during calculation.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is particularly designed for samples from different metacommunities. The null model &quot;taxa shuffle&quot; will be done under different metacommunities, separately (and independently). All other details are the same as the function NTI.p. 
</p>


<h3>Value</h3>

<p>If output.MNTD is FALSE, output is a one-column matrix where rownames are sample IDs and the only column shows NTI values. If output.MNTD is TRUE, output is a list of three elements.
</p>
<table>
<tr><td><code>NTI</code></td>
<td>
<p>matrix, NTI values.</p>
</td></tr>
<tr><td><code>MNTD</code></td>
<td>
<p>matrix, observed MNTD.</p>
</td></tr>
<tr><td><code>MNTD.rand</code></td>
<td>
<p>array, null MNTD values, the third dimension represent randomization times.</p>
</td></tr>
</table>


<h3>Note</h3>

<p>Version 1: 2021.8.4
</p>


<h3>Author(s)</h3>

<p>Daliang Ning
</p>


<h3>References</h3>

<p>Webb CO, Ackerly DD, and Kembel SW. 2008. Phylocom: software for the analysis of phylogenetic community structure and trait evolution. Bioinformatics 18:2098-2100
</p>
<p>Kembel, S.W. (2009). Disentangling niche and neutral influences on community assembly: assessing the performance of community phylogenetic structure tests. Ecol Lett, 12, 949-960.
</p>
<p>Chase, J.M., Kraft, N.J.B., Smith, K.G., Vellend, M. &amp; Inouye, B.D. (2011). Using null models to disentangle variation in community dissimilarity from variation in alpha-diversity. Ecosphere, 2, 1-11.
</p>
<p>Ning, D., Yuan, M., Wu, L., Zhang, Y., Guo, X., Zhou, X. et al. (2020). A quantitative framework reveals ecological drivers of grassland microbial community assembly in response to warming. Nature Communications, 11, 4717.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+NTI.p">NTI.p</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("example.data")
comm=example.data$comm
pd=example.data$pd

# in this example, 10 samples from one metacommunity,
# the other 10 samples from another metacommunity.
meta.group=data.frame(meta.com=c(rep("meta1",10),rep("meta2",10)))
rownames(meta.group)=rownames(comm)

nworker=2 # parallel computing thread number.
rand.time=4 # usually use 1000 for real data.
sigmntd=NTI.cm(comm=comm, meta.group=meta.group,
               dis=pd, nworker = nworker,
               weighted = TRUE, rand = rand.time,
               sig.index="all")
NTI=sigmntd$SES
CMNTD=sigmntd$Confidence
RCMNTD=sigmntd$RC
</code></pre>

<hr>
<h2 id='NTI.p'>
Calculate nearest taxon index (NTI) with parallel computing
</h2><span id='topic+NTI.p'></span>

<h3>Description</h3>

<p>Calculate nearest taxon index (NTI) of each sample with parallel computing.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>NTI.p(comm, dis, nworker = 4, memo.size.GB = 50,
      weighted = c(TRUE, FALSE), rand = 1000,
      check.name = TRUE, output.MNTD = c(FALSE, TRUE),
      sig.index=c("SES","NTI","Confidence","RC","all"),
      silent=FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="NTI.p_+3A_comm">comm</code></td>
<td>
<p>community data matrix. rownames are sample names. colnames are species names.</p>
</td></tr>
<tr><td><code id="NTI.p_+3A_dis">dis</code></td>
<td>
<p>Phylogenetic distance matrix.</p>
</td></tr>
<tr><td><code id="NTI.p_+3A_nworker">nworker</code></td>
<td>
<p>for parallel computing. Either a character vector of host names on which to run the worker copies of R, or a positive integer (in which case that number of copies is run on localhost). default is 4, means 4 threads will be run.</p>
</td></tr>
<tr><td><code id="NTI.p_+3A_memo.size.gb">memo.size.GB</code></td>
<td>
<p>numeric, to set the memory size as you need, so that calculation of large tree will not be limited by physical memory. unit is Gb. default is 50Gb.</p>
</td></tr>
<tr><td><code id="NTI.p_+3A_weighted">weighted</code></td>
<td>
<p>Logic, consider abundances or not (just presence/absence). default is TRUE.</p>
</td></tr>
<tr><td><code id="NTI.p_+3A_rand">rand</code></td>
<td>
<p>integer, randomization times. default is 1000.</p>
</td></tr>
<tr><td><code id="NTI.p_+3A_check.name">check.name</code></td>
<td>
<p>logic, whether to check the taxa names in comm and dis, which must be the same and in the same order; if not match, remove mismatched names and change to the same order. default is TRUE.</p>
</td></tr>
<tr><td><code id="NTI.p_+3A_output.mntd">output.MNTD</code></td>
<td>
<p>logic, if TRUE, the NTI and MNTD  will be output, if FALSE, only output NTI.</p>
</td></tr>
<tr><td><code id="NTI.p_+3A_sig.index">sig.index</code></td>
<td>
<p>character, the index for null model significance test. SES or NTI, standard effect size, i.e. nearest taxon index (NTI); Confidence, percentage of null values less extreme than the observed value, i.e. non-parametric one-side confidence level; RC, modified Raup-Crick index (RC) based on MNTD, i.e. count the number of null MNTD lower than observed MNTD plus a half of the number of null MNTD equal to observed MNTD, to get alpha, then calculate MNTD-based RC as (2 x alpha - 1); all, output all the three indexes. default is SES. If input a vector, only the first element will be used.</p>
</td></tr>
<tr><td><code id="NTI.p_+3A_silent">silent</code></td>
<td>
<p>logic, if FALSE, some messages will show during calculation.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The nearest taxon index (NTI) is a standardized measure of the mean phylogenetic distance to the nearest taxon in each sample/community (MNTD). Currently this function only performs one null model algorithm, &quot;taxa.labels&quot; (&quot;taxa shuffle&quot;, Kembel 2009), which is to shuffle distance matrix labels (across all taxa included in distance matrix). If the randomized results are all the same, the standard deviation will be zero and NTI will be NAN. In this case, NTI will be set as zero, since the observed result is not differentiable from randomized results.
</p>
<p>RC (Chase et al 2011) and Confidence (Ning et al 2020) are alternative significance test indexes to evaluate how the observed diversity index deviates from null expectation, which could be a better metric than standardized effect size (NTI) in some cases, e.g. null values do not follow normal distribution.
</p>


<h3>Value</h3>

<p>If output.MNTD is FALSE, output is a one-column matrix where rownames are sample IDs and the only column shows NTI values. If output.MNTD is TRUE, output is a list of three elements.
</p>
<table>
<tr><td><code>NTI</code></td>
<td>
<p>matrix, NTI values.</p>
</td></tr>
<tr><td><code>MNTD</code></td>
<td>
<p>matrix, observed MNTD.</p>
</td></tr>
<tr><td><code>MNTD.rand</code></td>
<td>
<p>array, null MNTD values, the third dimension represent randomization times.</p>
</td></tr>
</table>


<h3>Note</h3>

<p>Version 2: 2020.8.19, update help document, add example.
Version 1: 2018.10.19
</p>


<h3>Author(s)</h3>

<p>Daliang Ning
</p>


<h3>References</h3>

<p>Webb CO, Ackerly DD, and Kembel SW. 2008. Phylocom: software for the analysis of phylogenetic community structure and trait evolution. Bioinformatics 18:2098-2100
</p>
<p>Kembel, S.W. (2009). Disentangling niche and neutral influences on community assembly: assessing the performance of community phylogenetic structure tests. Ecol Lett, 12, 949-960.
</p>
<p>Chase, J.M., Kraft, N.J.B., Smith, K.G., Vellend, M. &amp; Inouye, B.D. (2011). Using null models to disentangle variation in community dissimilarity from variation in alpha-diversity. Ecosphere, 2, 1-11.
</p>
<p>Ning, D., Yuan, M., Wu, L., Zhang, Y., Guo, X., Zhou, X. et al. (2020). A quantitative framework reveals ecological drivers of grassland microbial community assembly in response to warming. Nature Communications, 11, 4717.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+mntdn">mntdn</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("example.data")
comm=example.data$comm
pd=example.data$pd
nworker=2 # parallel computing thread number.
rand.time=4 # usually use 1000 for real data.
sigmntd=NTI.p(comm=comm, dis=pd, nworker = nworker,
              weighted = TRUE, rand = rand.time,
              sig.index="all")
NTI=sigmntd$SES
CMNTD=sigmntd$Confidence
RCMNTD=sigmntd$RC
</code></pre>

<hr>
<h2 id='null.norm'>
Normality test for null values
</h2><span id='topic+null.norm'></span>

<h3>Description</h3>

<p>To test whether the null values of each turnover of each bin follow normal distribution.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>null.norm(icamp.output = NULL, rand.list = NULL, index.name = "Test.Index",
          p.norm.cut = 0.05, detail.out = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="null.norm_+3A_icamp.output">icamp.output</code></td>
<td>
<p>list, the exact output of the function icamp.big in which detail.null must be TRUE, to save all null values.</p>
</td></tr>
<tr><td><code id="null.norm_+3A_rand.list">rand.list</code></td>
<td>
<p>list, the null values of a certain dissimilarity index. Each eletment is a matrix that represents a bin. In each eletment matrix, the first two columns indicate sample IDs of the pairwise comparison (turnover), and each of the other columns shows the null values from one time of randomization.</p>
</td></tr>
<tr><td><code id="null.norm_+3A_index.name">index.name</code></td>
<td>
<p>character, when rand.list is given, to specify the name of the dissimilarity index.</p>
</td></tr>
<tr><td><code id="null.norm_+3A_p.norm.cut">p.norm.cut</code></td>
<td>
<p>numeric, the threshold of significant P value. A p value lower than this indicates significant difference from normal distribution.</p>
</td></tr>
<tr><td><code id="null.norm_+3A_detail.out">detail.out</code></td>
<td>
<p>logic, if TRUE, the detailed statistics and P values for each turnover of each bin will be output; otherwise, only output a summary on non-normal percentage for each bin.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Normal distribution of null values is basic assumption when using Standard Effect Size (SES, e.g. betaNRI, betaNTI) to identify significant difference between null and observed values. This function uses five different methods to perform normality test, including Anderson-Darling test (Anderson), Cramer-von Mises test (Cramer), Kolmogorov-Smirnov test (Kolmogorov, also known as Lilliefors test), Shapiro-Francia test (ShapiroF), and Shapiro-Wilk test (Shapiro). The function 'shapiro.test' in package 'stats', and various functions in package 'nortest' are used.
</p>


<h3>Value</h3>

<p>Output is a list object. 
</p>
<table>
<tr><td><code>summary</code></td>
<td>
<p>data.frame, each row represents a bin and a dissimilarity index. Seven columns. The first column indicates the dissimilarity index; the second column indicate Bin ID; each of the other columns indicate non-normal ratio based on a method. The non-normal raio is calculated as percentage of turnovers where null value distribution is significantly different from normal distribution.</p>
</td></tr>
<tr><td><code>P.value.cut</code></td>
<td>
<p>the value of p.norm.cut</p>
</td></tr>
<tr><td><code>detail</code></td>
<td>
<p>list, each first-level element represents a dissimilarity index; each second-level element is a matrix represents a bin; and the matrix has 14 columns, including the dissimilarity index (Index), bin ID (BinID), sample IDs (name1 and name2), and the statistics and P value based on different methods.</p>
</td></tr>
</table>


<h3>Note</h3>

<p>Version 2: 2020.8.19, update help document, add example
Version 1: 2020.8.1
</p>


<h3>Author(s)</h3>

<p>Daliang Ning
</p>


<h3>References</h3>

<p>Stephens, M.A. (1986): Tests based on EDF statistics. In: D'Agostino, R.B. and Stephens, M.A., eds.: Goodness-of-Fit Techniques. Marcel Dekker, New York.
</p>
<p>Dallal, G.E. and Wilkinson, L. (1986): An analytic approximation to the distribution of Lilliefors' test for normality. The American Statistician, 40, 294-296.
</p>
<p>Stephens, M.A. (1974): EDF statistics for goodness of fit and some comparisons. Journal of the American Statistical Association, 69, 730-737.
</p>
<p>Royston, P. (1993): A pocket-calculator algorithm for the Shapiro-Francia test for non-normality: an application to medicine. Statistics in Medicine, 12, 181-184.
</p>
<p>Thode Jr., H.C. (2002): Testing for Normality. Marcel Dekker, New York
</p>
<p>Patrick Royston (1982). An extension of Shapiro and Wilk's W test for normality to large samples. Applied Statistics, 31, 115-124. doi: 10.2307/2347973.
</p>
<p>Patrick Royston (1982). Algorithm AS 181: The W test for Normality. Applied Statistics, 31, 176-180. doi: 10.2307/2347986.
</p>
<p>Patrick Royston (1995). Remark AS R94: A remark on Algorithm AS 181: The W test for normality. Applied Statistics, 44, 547-551. doi: 10.2307/2986146.
</p>
<p>Juergen Gross and Uwe Ligges (2015). nortest: Tests for Normality. R package version 1.0-4. https://CRAN.R-project.org/package=nortest
</p>


<h3>See Also</h3>

<p><code><a href="#topic+icamp.big">icamp.big</a></code>, <code><a href="#topic+change.sigindex">change.sigindex</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("icamp.out")
nntest=null.norm(icamp.output = icamp.out, detail.out = TRUE)
</code></pre>

<hr>
<h2 id='pdist.big'>
Pairwise phylogenetic distance matrix from big tree
</h2><span id='topic+pdist.big'></span>

<h3>Description</h3>

<p>Calculates between-species phylogenetic distance matrix from a tree, using bigmemory to deal with too large dataset.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pdist.big(tree, wd = getwd(), tree.asbig = FALSE,
          output = FALSE, nworker = 4, nworker.pd = nworker,
          memory.G = 50, time.count = FALSE,
          treepath.file="path.rda", pd.spname.file="pd.taxon.name.csv",
          pd.backingfile="pd.bin", pd.desc.file="pd.desc",
          tree.backingfile="treeinfo.bin", tree.desc.file="treeinfo.desc")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pdist.big_+3A_tree">tree</code></td>
<td>
<p>phylogenetic tree, an object of class &quot;phylo&quot;.</p>
</td></tr>
<tr><td><code id="pdist.big_+3A_wd">wd</code></td>
<td>
<p>path of a folder to save the big phylogenetic distance matrix, default is current work directory.</p>
</td></tr>
<tr><td><code id="pdist.big_+3A_tree.asbig">tree.asbig</code></td>
<td>
<p>logic, whether to treat tree attributes also as big data, default is FALSE, generally no need to set as TRUE.</p>
</td></tr>
<tr><td><code id="pdist.big_+3A_output">output</code></td>
<td>
<p>logic, whether to output the big phylogenetic distance matrix, default is FALSE, generally do not output it, could be too large.</p>
</td></tr>
<tr><td><code id="pdist.big_+3A_nworker">nworker</code></td>
<td>
<p>for parallel computing the tree paths. a positive integer (in which case that number of copies is run on localhost). default is 4, means 4 threads will be run.</p>
</td></tr>
<tr><td><code id="pdist.big_+3A_nworker.pd">nworker.pd</code></td>
<td>
<p>for parallel computing the phylogenetic distance matrix. default is set the same as nworker. may need to set lower than nworker if the matrix is too large.</p>
</td></tr>
<tr><td><code id="pdist.big_+3A_memory.g">memory.G</code></td>
<td>
<p>numeric, to set the memory size as you need, so that calculation of large tree will not be limited by physical memory. unit is Gb. default is 50Gb</p>
</td></tr>
<tr><td><code id="pdist.big_+3A_time.count">time.count</code></td>
<td>
<p>logic, whether to count calculation time, default is FALSE.</p>
</td></tr>
<tr><td><code id="pdist.big_+3A_treepath.file">treepath.file</code></td>
<td>
<p>character, name of the file saving the tree.path, which is a list of all the nodes and edge lengthes from root to every tip and/or node. it should be a .rda filename.</p>
</td></tr>
<tr><td><code id="pdist.big_+3A_pd.spname.file">pd.spname.file</code></td>
<td>
<p>character, name of the file saving the taxa IDs, which has exactly the same order as the row names (and column names) of the big phylogenetic distance matrix. it should be a .csv filename.</p>
</td></tr>
<tr><td><code id="pdist.big_+3A_pd.backingfile">pd.backingfile</code></td>
<td>
<p>character, the root name for the file for the cache of the big phylogenetic distance matrix. it should be a .bin filename.</p>
</td></tr>
<tr><td><code id="pdist.big_+3A_pd.desc.file">pd.desc.file</code></td>
<td>
<p>character, name of the file to hold the backingfile description for the big phylogenetic distance matrix. it should be a .desc filename.</p>
</td></tr>
<tr><td><code id="pdist.big_+3A_tree.backingfile">tree.backingfile</code></td>
<td>
<p>character, the root name for the file for the cache of the 3-column matrix of the tree information, including edge and edge length. it should be a .bin filename.</p>
</td></tr>
<tr><td><code id="pdist.big_+3A_tree.desc.file">tree.desc.file</code></td>
<td>
<p>character, name of the file to hold the backingfile description for the tree information matrix. it should be a .desc filename.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The cophenetic distance between each pair of taxa is calculated (Sokal and Rohlf 1962). Modified from the function &quot;cophenetic&quot; in package &quot;ape&quot; (Paradis &amp; Schliep 2018), this function can calculate pairwise distance from large phylogenetic tree quickly by parallel computing. This function uses bigmemory (Kane et al 2013) to deal with large phylogenetic distance matrix, which will not occupy memory but directly be saved at the hard disk.
</p>


<h3>Value</h3>

<p>Output is a list
</p>
<table>
<tr><td><code>tip.label</code></td>
<td>
<p>OTU ids or species names, which is tip.label in tree file.</p>
</td></tr>
<tr><td><code>pd.wd</code></td>
<td>
<p>the folder saving the big phylogenetic distance matrix.</p>
</td></tr>
<tr><td><code>pd.file</code></td>
<td>
<p>the folder saving the big phylogenetic distance matrix.</p>
</td></tr>
<tr><td><code>pd.name.file</code></td>
<td>
<p>the file saving the tip.label information.</p>
</td></tr>
</table>


<h3>Note</h3>

<p>Version 4: 2020.9.1, remove setwd; add options to specify the file names; change dontrun to donttest and revise save.wd in help doc.
Version 3: 2020.8.19, add example.
Version 2: 2017.3.13
Version 1: 2015.7.24
</p>


<h3>Author(s)</h3>

<p>Daliang Ning
</p>


<h3>References</h3>

<p>Sokal, R. R. &amp; Rohlf, F. J.. (1962). The comparison of dendrograms by objective methods. Taxon, 11:33-40
</p>
<p>Paradis, E. &amp; Schliep, K. (2018). ape 5.0: an environment for modern phylogenetics and evolutionary analyses in R. Bioinformatics 35: 526-528.
</p>
<p>Kane, M.J., Emerson, J., &amp; Weston, S. (2013). Scalable Strategies for Computing with Massive Data. Journal of Statistical Software, 55(14), 1-19. URL http://www.jstatsoft.org/v55/i14/.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("example.data")
tree=example.data$tree
# since pdist.big need to save output to a certain folder,
# the following code is set as 'not test'.
# but you may test the code on your computer
# after change the folder path for 'save.wd'.

  wd0=getwd()
  save.wd=paste0(tempdir(),"/pdbig.pdist.big")
  # please change to the folder you want to save the pd.big output.
  
  nworker=2 # parallel computing thread number
  pd.big=pdist.big(tree = tree, wd=save.wd, nworker = nworker)
  setwd(wd0)

</code></pre>

<hr>
<h2 id='pdist.p'>
Pairwise phylogenetic distance matrix from small tree
</h2><span id='topic+pdist.p'></span>

<h3>Description</h3>

<p>Calculates between-species phylogenetic distance matrix from a tree. only deal with relatively small dataset.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pdist.p(tree, nworker = 4, memory.G = 50, silent = FALSE, time.count = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pdist.p_+3A_tree">tree</code></td>
<td>
<p>phylogenetic tree, an object of class &quot;phylo&quot;.</p>
</td></tr>
<tr><td><code id="pdist.p_+3A_nworker">nworker</code></td>
<td>
<p>for parallel computing the tree paths. a positive integer (in which case that number of copies is run on localhost). default is 4, means 4 threads will be run.</p>
</td></tr>
<tr><td><code id="pdist.p_+3A_memory.g">memory.G</code></td>
<td>
<p>numeric, to set the memory size as you need, so that calculation of large tree will not be limited by physical memory. unit is Gb. default is 50Gb</p>
</td></tr>
<tr><td><code id="pdist.p_+3A_silent">silent</code></td>
<td>
<p>logic, whether to show messages. Default is FALSE, thus all messages will be showed.</p>
</td></tr>
<tr><td><code id="pdist.p_+3A_time.count">time.count</code></td>
<td>
<p>logic, whether to count calculation time, default is FALSE.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The cophenetic distance between each pair of taxa is calculated (Sokal and Rohlf 1962). Modified from the function &quot;cophenetic&quot; in package &quot;ape&quot; (Paradis &amp; Schliep 2018), this function can calculate pairwise distance from phylogenetic tree quickly by parallel computing. If the tree has too many tips (taxa), please use another function pdist.big designed for large datasets.
</p>


<h3>Value</h3>

<p>Output is a data.frame object, a square matrix of pairwise phylogenetic distances. Row names are the same as column names, indicating taxa IDs. 
</p>


<h3>Note</h3>

<p>Version 1: 2021.9.24
</p>


<h3>Author(s)</h3>

<p>Daliang Ning
</p>


<h3>References</h3>

<p>Sokal, R. R. &amp; Rohlf, F. J.. (1962). The comparison of dendrograms by objective methods. Taxon, 11:33-40
</p>
<p>Paradis, E. &amp; Schliep, K. (2018). ape 5.0: an environment for modern phylogenetics and evolutionary analyses in R. Bioinformatics 35: 526-528.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+pdist.big">pdist.big</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("example.data")
tree=example.data$tree
nworker=2 # parallel computing thread number
pd=pdist.p(tree = tree, nworker = nworker)
</code></pre>

<hr>
<h2 id='ps.bin'>
Test within-bin phylogenetic signal
</h2><span id='topic+ps.bin'></span>

<h3>Description</h3>

<p>Use Mantel test to evaluate phylogenetic signal within each bin, i.e. correlation between phylogenetic distance and niche difference.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ps.bin(sp.bin, sp.ra, spname.use = NULL,
       pd.desc = "pd.desc", pd.spname, pd.wd,
       nd.list, nd.spname = NULL, ndbig.wd = NULL,
       cor.method = c("pearson", "spearman"),
       r.cut = 0.01, p.cut = 0.2, min.spn = 6)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ps.bin_+3A_sp.bin">sp.bin</code></td>
<td>
<p>one-column matrix or data.frame, indicating the bin ID for each species (OTU or ASV), rownames are species IDs. usually use the third column of &quot;sp.bin&quot; in the output of <code><a href="#topic+taxa.binphy.big">taxa.binphy.big</a></code>. if input matrix with multiple columns, only the first column will be used.</p>
</td></tr>
<tr><td><code id="ps.bin_+3A_sp.ra">sp.ra</code></td>
<td>
<p>one-column matrix or data.frame, or a vector with name for each element, indicating mean relative abundance of each species.</p>
</td></tr>
<tr><td><code id="ps.bin_+3A_spname.use">spname.use</code></td>
<td>
<p>character vector, to specify which species will be used for phylogenetic signal test. Default is NULL, means to use all species.</p>
</td></tr>
<tr><td><code id="ps.bin_+3A_pd.desc">pd.desc</code></td>
<td>
<p>the name of the file to hold the backingfile description of the phylogenetic distance matrix, it is usually &quot;pd.desc&quot; if using default setting in pdist.big function.</p>
</td></tr>
<tr><td><code id="ps.bin_+3A_pd.spname">pd.spname</code></td>
<td>
<p>character vector, species id in the same order as the big matrix of phylogenetic distances.</p>
</td></tr>
<tr><td><code id="ps.bin_+3A_pd.wd">pd.wd</code></td>
<td>
<p>folder path, where the bigmemmory file of the phylogenetic distance matrix are saved.</p>
</td></tr>
<tr><td><code id="ps.bin_+3A_nd.list">nd.list</code></td>
<td>
<p>list object. if the niche difference matrixes are big.matrix, each element of this list is the big.matrix backingfile description, e.g. &quot;pH.ND.desc&quot;; otherwise, each element is a niche difference matrix based on an environment factor. usually this is the &quot;nd&quot; in the output of <code><a href="#topic+dniche">dniche</a></code>.</p>
</td></tr>
<tr><td><code id="ps.bin_+3A_nd.spname">nd.spname</code></td>
<td>
<p>character vector or NULL. If the niche difference matrixes are big.matrix, this is the species IDs in the same order as in each big matrix; otherwise, this should be set as NULL, the species IDs will be extracted from nd.list.</p>
</td></tr>
<tr><td><code id="ps.bin_+3A_ndbig.wd">ndbig.wd</code></td>
<td>
<p>folder path or NULL. If the niche difference matrixes are big.matrix, this is where the big matrixes of niche differences are saved; otherwise, this is NULL.</p>
</td></tr>
<tr><td><code id="ps.bin_+3A_cor.method">cor.method</code></td>
<td>
<p>Correlation method, as accepted by cor: &quot;pearson&quot;, &quot;spearman&quot; or &quot;kendall&quot;. Multiple methods at a time are allowed.</p>
</td></tr>
<tr><td><code id="ps.bin_+3A_r.cut">r.cut</code></td>
<td>
<p>the cutoff of correlaiton coefficient to identify significant correlation.</p>
</td></tr>
<tr><td><code id="ps.bin_+3A_p.cut">p.cut</code></td>
<td>
<p>the cutoff of p value to identify significant correlation.</p>
</td></tr>
<tr><td><code id="ps.bin_+3A_min.spn">min.spn</code></td>
<td>
<p>the minimal spcies (or OUT or ASV) number required for phylogenetic signal test.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This is simply Mantel test between phylogenetic distance and niche difference (i.e. phylogenetic signal) within each bin. Then, it returns the overall relative abundance of bins with significant phylogenetic signal, average correlation coefficient, as well as detailed results in each bin, to evaluate within-bin phylogenetic signal of the binning (inputed as sp.bin). Bigmemory (Kane et al 2013) is used to deal with large datasets.
</p>


<h3>Value</h3>

<p>Output is a list object with two elements.
</p>
<table>
<tr><td><code>Index</code></td>
<td>
<p>Summary of phylogenetic signal test. The indexes include relative abundance of bins with significant phylogenetic signal in all bins (RAsig) or in bins with species number larger than min.spn (RAsig.adj), average correlation coefficient in significant bins (MeanR.sig) or in all bins (MeanR).</p>
</td></tr>
<tr><td><code>detail</code></td>
<td>
<p>correlation coefficient (r) and p value in each bin.</p>
</td></tr>
</table>


<h3>Note</h3>

<p>Version 4: 2021.5.24, debug to avoid the dimnames issue.
Version 3: 2020.9.1, remove setwd; change dontrun to donttest and revise save.wd in help doc.
Version 2: 2020.8.18, update help document, add example.
Version 1: 2020.5.15
</p>


<h3>Author(s)</h3>

<p>Daliang Ning
</p>


<h3>References</h3>

<p>Ning, D., Yuan, M., Wu, L., Zhang, Y., Guo, X., Zhou, X. et al. (2020). A quantitative framework reveals ecological drivers of grassland microbial community assembly in response to warming. Nature Communications, 11, 4717.
</p>
<p>Kane, M.J., Emerson, J., &amp; Weston, S. (2013). Scalable Strategies for Computing with Massive Data. Journal of Statistical Software, 55(14), 1-19. URL http://www.jstatsoft.org/v55/i14/.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+taxa.binphy.big">taxa.binphy.big</a></code>, <code><a href="#topic+dniche">dniche</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("example.data")
comm=example.data$comm
env=example.data$env
tree=example.data$tree

# since big.memory need to specify a certain folder,
# the following code is set as 'not test'.
# but you may test the code on your computer
# after change the folder path for 'save.wd'.

  wd0=getwd()
  save.wd=paste0(tempdir(),"/pdbig.ps.bin")
  # please change to the folder you want to save the big niche difference matrix.
  
  nworker=2 # parallel computing thread number
  pd.big=pdist.big(tree = tree, wd=save.wd, nworker = nworker)
    
  niche.dif=dniche(env = env, comm = comm,
                   method = "niche.value", nworker = nworker,
                   out.dist=FALSE,bigmemo=TRUE,nd.wd = save.wd,
                   nd.spname.file="nd.names.csv")
  
  ds = 0.2 # setting can be changed to explore the best choice
  bin.size.limit = 5 # setting can be changed to explore the best choice.
  # here, bin.size.limit is set as 5 just for the small example dataset.
  # For real data, usually try 12 to 48.
  
  phylobin=taxa.binphy.big(tree = tree, pd.desc = pd.big$pd.file,
                           pd.spname = pd.big$tip.label, pd.wd = pd.big$pd.wd,
                           ds = ds, bin.size.limit = bin.size.limit,
                           nworker = nworker)
  sp.bin=phylobin$sp.bin[,3,drop=FALSE]
  
  sp.ra=colMeans(comm/rowSums(comm))
  abcut=3
  # by abcut, you may remove some species,
  # if they are too rare to perform reliable correlation test.
  
  
  commc=comm[,colSums(comm)&gt;=abcut,drop=FALSE]
  dim(commc)
  spname.use=colnames(commc)
  
  binps=ps.bin(sp.bin = sp.bin,sp.ra = sp.ra,spname.use = spname.use,
               pd.desc = pd.big$pd.file, pd.spname = pd.big$tip.label,
               pd.wd = pd.big$pd.wd, nd.list = niche.dif$nd,
               nd.spname = niche.dif$names, ndbig.wd = niche.dif$nd.wd,
               cor.method = "pearson",r.cut = 0.1, p.cut = 0.05, min.spn = 5)
  setwd(wd0)

</code></pre>

<hr>
<h2 id='qp.bin.js'>
Calculate relative importance of community assembly processes
</h2><span id='topic+qp.bin.js'></span>

<h3>Description</h3>

<p>Identify the community assembly process governing each bin in each turnover (i.e. pairwise comparison between two samples/communities), then calculate the relative importance of community assembly processes in each turnover.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>qp.bin.js(sig.phy.bin=NULL, sig.phy2.bin=NULL, sig.tax.bin=NULL,
          bin.weight, sig.phy.cut=1.96, sig.phy2.cut=1.96,
          sig.tax.cut=0.95, check.name=FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="qp.bin.js_+3A_sig.phy.bin">sig.phy.bin</code></td>
<td>
<p>matrix, the first two columns are sample IDs, thus each row represent a turnover between two samples. From the third column, each column shows the significance testing index of phylogenetic null model analysis (e.g. betaNTI) of a bin. NULL means the data is not available.</p>
</td></tr>
<tr><td><code id="qp.bin.js_+3A_sig.phy2.bin">sig.phy2.bin</code></td>
<td>
<p>matrix, the same as sig.phy.bin, serves as the second phylogenetic metrics when phylogenetic null model test is based on two different beta diversity indexes, e.g. both betaMPD and betaMNTD. NULL means the data is not available.</p>
</td></tr>
<tr><td><code id="qp.bin.js_+3A_sig.tax.bin">sig.tax.bin</code></td>
<td>
<p>matrix, the first two columns are sample IDs, thus each row represent a turnover between two samples. From the third column, each column shows the significance testing index of taxonomic null model analysis (e.g. RC.Bray) of a bin. NULL means the data is not available.</p>
</td></tr>
<tr><td><code id="qp.bin.js_+3A_bin.weight">bin.weight</code></td>
<td>
<p>matrix, the first two columns are sample IDs, thus each row represent a turnover between two samples. From the third column, each column shows the abundance sum of a bin in each pair of samples.</p>
</td></tr>
<tr><td><code id="qp.bin.js_+3A_sig.phy.cut">sig.phy.cut</code></td>
<td>
<p>numeric, a cutoff for the null model significance testing index based on a phylogenetic beta diversity index, e.g. betaNRI based on betaMPD, default is 1.96.</p>
</td></tr>
<tr><td><code id="qp.bin.js_+3A_sig.phy2.cut">sig.phy2.cut</code></td>
<td>
<p>numeric, a cutoff for the null model significance testing index based on the second phylogenetic beta diversity index, e.g. betaNTI based on betaMNTD, default is 1.96.</p>
</td></tr>
<tr><td><code id="qp.bin.js_+3A_sig.tax.cut">sig.tax.cut</code></td>
<td>
<p>numeric, a cutoff for the null model significance testing index based on a taxonomic beta diversity index, e.g. RC based on Bray-Curtis, default is 0.95.</p>
</td></tr>
<tr><td><code id="qp.bin.js_+3A_check.name">check.name</code></td>
<td>
<p>logic, whether to check the sample IDs in different input matrixess are in the same order.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The framework is proposed by James Stegen (2013 and 2015), to identify governing ecologcial process based on phylogenetic (betaNTI) and taonomic (RC.Bray) null model analysis. In all pairwised comparisons between samples/communities, the non-random phylogenetic turnovers recognized by phylogeny shuffle were counted as influence of environment selection, and the non-random taxonomic turnovers in the rest pairwised comparisons were counted as influence of dispersal limitation or homogenizing dispersal. The rest part is called undominated.
</p>
<p>This function applied this framework to each phylogenetic bin and allowed to use betaNRI and/or betaNTI. When both betaNTI and betaNRI are provided, a turnover is idientified as controlled by selection when either betaNRI or betaNTI is significant. Alternatively, RC or confidence level based on betaMPD and/or betaMNTD can also be used (Ning et al. 2020).
</p>


<h3>Value</h3>

<p>Output is a matrix. The first two columns are sample IDs, and each row represent a turnover between two samples. From the third column, each column shows the relative importance of a community assembly process in each turnover (pairwise comparison between each pair of samples). 
</p>


<h3>Note</h3>

<p>Version 5: 2020.8.19, update help document, add example.
Version 4: 2020.7.28, change bNTI.bin=NULL,bNRI.bin=NULL,RC.bin=NULL to sig.phy.bin and sig.tax.bin.
Version 3: 2018.10.20, add bNRI.bin as option; add check.name.
Version 2: 2016.3.26, add RC.all option
Version 1: 2015.12.16
</p>


<h3>Author(s)</h3>

<p>Daliang Ning
</p>


<h3>References</h3>

<p>Ning, D., Yuan, M., Wu, L., Zhang, Y., Guo, X., Zhou, X. et al. (2020). A quantitative framework reveals ecological drivers of grassland microbial community assembly in response to warming. Nature Communications, 11, 4717.
</p>
<p>Stegen JC, Lin X, Fredrickson JK, Chen X, Kennedy DW, Murray CJ et al. 2013. Quantifying community assembly processes and identifying features that impose them. Isme Journal 7: 2069-2079.
</p>
<p>Stegen JC, Lin X, Fredrickson JK, Konopka AE. 2015. Estimating and mapping ecological processes influencing microbial community assembly. Frontiers in Microbiology 6.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+icamp.big">icamp.big</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("icamp.out")
bNRIbins=icamp.out$detail$SigbMPDi
RCbins=icamp.out$detail$SigBCa
binwt=icamp.out$detail$bin.weight
qpbin=qp.bin.js(sig.phy.bin = bNRIbins,sig.tax.bin = RCbins,
                bin.weight = binwt, sig.phy.cut = 1.96,
                sig.tax.cut = 0.95, check.name = TRUE)
</code></pre>

<hr>
<h2 id='qpen'>
Quantifying assembly processes based on entire-community null model analysis
</h2><span id='topic+qpen'></span>

<h3>Description</h3>

<p>The previous framework quantifying assembly processes based on entire-community null model analysis (Stegen et al 2013, 2015). add bigmemory function to handle large datasets.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>qpen(comm = NULL, pd = NULL, pd.big.wd = NULL,
     pd.big.spname = NULL, tree = NULL,
     bNTI = NULL, RC = NULL, ab.weight = TRUE,
     meta.ab = NULL, exclude.conspecifics = FALSE,
     rand.time = 1000, sig.bNTI = 1.96, sig.rc = 0.95,
     nworker = 4, memory.G = 50, project = NA,
     wd = getwd(), output.detail = FALSE, save.bNTIRC = FALSE,
     taxo.metric = "bray", transform.method = NULL,
     logbase = 2, dirichlet = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="qpen_+3A_comm">comm</code></td>
<td>
<p>matrix or data.frame, community data, each row is a sample or site, each colname is a taxon (species or OTU or ASV), thus rownames should be sample IDs, colnames should be taxa IDs.</p>
</td></tr>
<tr><td><code id="qpen_+3A_pd">pd</code></td>
<td>
<p>a character or a matrix or NULL. If it is a character, it specifies the name of the file to hold the backingfile description of the big phylogenetic distance matrix, it is usually &quot;pd.desc&quot; if using default setting in pdist.big function. If it is matrix, it is the phylogenetic distance matrix with taxa IDs as colnames and rownames. The function will check the consistency of species names between phylogenetic matrix and comm. if pd is NULL, the function will calculate phylogenetic distance matrix from tree.</p>
</td></tr>
<tr><td><code id="qpen_+3A_pd.big.wd">pd.big.wd</code></td>
<td>
<p>a folder path, where the bigmemmory file of the phylogenetic distance matrix are saved. If pd has given the phylogenetic matrix, pd.big.wd should be NULL. If pd is NULL and pd.big.wd is NULL either, a folder will be created to save the big phylgoenetic distance matrix.</p>
</td></tr>
<tr><td><code id="qpen_+3A_pd.big.spname">pd.big.spname</code></td>
<td>
<p>character vector, taxa id in the same rank as the big matrix of phylogenetic distances. not necessary if pd has given the phylogenetic matrix.</p>
</td></tr>
<tr><td><code id="qpen_+3A_tree">tree</code></td>
<td>
<p>phylogenetic tree, an object of class &quot;phylo&quot;.</p>
</td></tr>
<tr><td><code id="qpen_+3A_bnti">bNTI</code></td>
<td>
<p>a matrix, if beta nearest taxon index (betaNTI) values are available, just directly input them as a squre matrix here.</p>
</td></tr>
<tr><td><code id="qpen_+3A_rc">RC</code></td>
<td>
<p>a matrix, if modified Raup-Crick metric based Bray-Curtis (RCbray) values are available, just directly input them as a squre matrix here.</p>
</td></tr>
<tr><td><code id="qpen_+3A_ab.weight">ab.weight</code></td>
<td>
<p>logic, abundance-weighted or binary. default is TRUE, means abundance-weighted.</p>
</td></tr>
<tr><td><code id="qpen_+3A_meta.ab">meta.ab</code></td>
<td>
<p>a numeric vector, to define the relative aubndance of each species in the regional pool. Default setting is NULL, means to calculate meta.ab as average relative abundance of each species across the samples.</p>
</td></tr>
<tr><td><code id="qpen_+3A_exclude.conspecifics">exclude.conspecifics</code></td>
<td>
<p>Logic, should conspecific taxa in different communities be exclude from MNTD calculations? default is FALSE. The same as in the function bmntd.</p>
</td></tr>
<tr><td><code id="qpen_+3A_rand.time">rand.time</code></td>
<td>
<p>integer, randomization times. default is 1000.</p>
</td></tr>
<tr><td><code id="qpen_+3A_sig.bnti">sig.bNTI</code></td>
<td>
<p>numeric, the cutoff of significant betaNTI, default is 1.96.</p>
</td></tr>
<tr><td><code id="qpen_+3A_sig.rc">sig.rc</code></td>
<td>
<p>numeric, the cutoff of significant modified Raup-Crick metric, default is 0.95.</p>
</td></tr>
<tr><td><code id="qpen_+3A_nworker">nworker</code></td>
<td>
<p>for parallel computing. Either a character vector of host names on which to run the worker copies of R, or a positive integer (in which case that number of copies is run on localhost). default is 4, means 4 threads will be run.</p>
</td></tr>
<tr><td><code id="qpen_+3A_memory.g">memory.G</code></td>
<td>
<p>numeric, to set the memory size as you need, so that calculation of large tree will not be limited by physical memory. unit is Gb. default is 50Gb.</p>
</td></tr>
<tr><td><code id="qpen_+3A_project">project</code></td>
<td>
<p>character string, the prefix of saved output files.</p>
</td></tr>
<tr><td><code id="qpen_+3A_wd">wd</code></td>
<td>
<p>a folder path, where the files will be saved.</p>
</td></tr>
<tr><td><code id="qpen_+3A_output.detail">output.detail</code></td>
<td>
<p>logic, if TRUE, some detailed results including all null values will be output.</p>
</td></tr>
<tr><td><code id="qpen_+3A_save.bntirc">save.bNTIRC</code></td>
<td>
<p>logic, if TRUE, a file will be saved in the folder specified by wd.</p>
</td></tr>
<tr><td><code id="qpen_+3A_taxo.metric">taxo.metric</code></td>
<td>
<p>taxonomic beta diversity index, the same as 'method' in the function 'vegdist' in package 'vegan', including &quot;manhattan&quot;, &quot;euclidean&quot;, &quot;canberra&quot;, &quot;clark&quot;, &quot;bray&quot;, &quot;kulczynski&quot;, &quot;jaccard&quot;, &quot;gower&quot;, &quot;altGower&quot;, &quot;morisita&quot;, &quot;horn&quot;, &quot;mountford&quot;, &quot;raup&quot;, &quot;binomial&quot;, &quot;chao&quot;, &quot;cao&quot; or &quot;mahalanobis&quot;. If taxo.metric='bray' and transform.method=NULL, RC will be calculated based on Bray-Curtis dissimilarity as recommended in original iCAMP; otherwise, unit.sum setting will be ignored.</p>
</td></tr>
<tr><td><code id="qpen_+3A_transform.method">transform.method</code></td>
<td>
<p>character or a defined function, to specify how to transform community matrix before calculating taxonomic dissimilarity. Due to the definition of the phylogenetic dissimilarity (bMNTD), it is not affected by data transformation. If transform.method is a characher, it should be a method name as in the function 'decostand' in package 'vegan', including 'total','max','freq','normalize','range','standardize','pa','chi.square','cmdscale','hellinger','log'.</p>
</td></tr>
<tr><td><code id="qpen_+3A_logbase">logbase</code></td>
<td>
<p>numeric, the logarithm base used when transform.method='log'.</p>
</td></tr> 
<tr><td><code id="qpen_+3A_dirichlet">dirichlet</code></td>
<td>
<p>Logic. If TRUE, the taxonomic null model will use Dirichlet distribution to generate relative abundances in randomized community matrix. If the input community matrix has all row sums no more than 1, the function will automatically set dirichlet=TRUE. default is FALSE.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This method is developed by Dr. James Stegen (2013 and 2015), from which we developed iCAMP. In all pairwised comparisons between samples/communities, the non-random phylogenetic turnovers recognized by phylogeny shuffle were counted as influence of environment selection (betaNTI&gt;1.96 or &lt;-1.96), and the non-random taxonomic turnovers in the rest pairwised comparisons were counted as influence of dispersal limitation (RCbray&gt;0.95) or homogenizing dispersal (RCbray&lt;-0.95). The rest part is called undominated. Please read the references for details.
</p>
<p>betaNTI is the standardized effect size between the observed and null values of beta mean nearest taxon distance (betaMNTD). RCbray is the modified Roup-Crick metric based on taxonomic Bray-Curtis dissimilarity index.
</p>
<p>Bigmemory (Kane et al 2013) is used to deal with large datasets.
</p>


<h3>Value</h3>

<p>output is a list with following elements.
</p>
<table>
<tr><td><code>ratio</code></td>
<td>
<p>The overall percentage of turnovers governed by each process</p>
</td></tr>
<tr><td><code>result</code></td>
<td>
<p>a matrix, showing betaMNTD, Bray-Curtis dissimilarity, betaNTI, RC, and the identified process governing each turnover. Each row represents a turnover between two samples.</p>
</td></tr>
<tr><td><code>pd</code></td>
<td>
<p>phylogenetic distance matrix or the backingfile name if phylogenetic distance is saved by bigmemeory function.</p>
</td></tr>
<tr><td><code>bMNTD</code></td>
<td>
<p>a square matrix of observed betaMNTD.</p>
</td></tr>
<tr><td><code>BC</code></td>
<td>
<p>a square matrix of observed Bary-Curtis index.</p>
</td></tr>
<tr><td><code>bMNTD.rand</code></td>
<td>
<p>a matrix showing all null values of betaMNTD.</p>
</td></tr>
<tr><td><code>BC.rand</code></td>
<td>
<p>a matrix showing all null values of Bray-Curtis index.</p>
</td></tr>
<tr><td><code>setting</code></td>
<td>
<p>a data.frame showing all settings for this function.</p>
</td></tr>
</table>


<h3>Note</h3>

<p>Version 7: 2021.4.18, add taxo.metric, transform.method, logbase, and dirichlet, to allow community data transform, dissimilar index other than Bray-Curtis, and relative abundances (values &lt; 1) in the input community matrix.
Version 6: 2020.12.5, use function bNTI.big to calculate betaNTI, which use bigmemory better.
Version 5: 2020.9.1, remove setwd; change dontrun to donttest and revise save.wd in help doc.
Version 4: 2020.8.21, update help document, add example.
Version 3: 2016.2.15, add options to use bigmemory to handle large phylogenetic distance matrixes.
Version 2: 2015.11.22
</p>


<h3>Author(s)</h3>

<p>Daliang Ning
</p>


<h3>References</h3>

<p>Stegen, J.C., Lin, X., Fredrickson, J.K., Chen, X., Kennedy, D.W., Murray, C.J. et al. (2013). Quantifying community assembly processes and identifying features that impose them. ISME J, 7, 2069.
</p>
<p>Stegen, J.C., Lin, X., Fredrickson, J.K. &amp; Konopka, A.E. (2015). Estimating and mapping ecological processes influencing microbial community assembly. Front Microbiol, 6, 370.
</p>
<p>Kane, M.J., Emerson, J., &amp; Weston, S. (2013). Scalable Strategies for Computing with Massive Data. Journal of Statistical Software, 55(14), 1-19. URL http://www.jstatsoft.org/v55/i14/.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+bNTIn.p">bNTIn.p</a></code>, <code><a href="#topic+bNTI.big">bNTI.big</a></code>, <code><a href="#topic+RC.pc">RC.pc</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("example.data")
comm=example.data$comm
tree=example.data$tree
# since pdist.big need to save output to a certain folder,
# the following code is set as 'not test'.
# but you may test the code on your computer
# after change the folder path for 'save.wd'.

  wd0=getwd()
  nworker=2 # parallel computing thread number
  rand.time=5 # usually use 1000 for real data.
  
  # for a small dataset, phylogenetic distance matrix can be directly used.
  pd=example.data$pd
  qp=qpen(comm=comm, pd=pd,
          rand.time=rand.time,nworker=nworker)
  
  # for a big dataset, pdist.big may be used
  save.wd=paste0(tempdir(),"/pdbig.qpen")
  # please change to the folder you want to save the pd.big output.
  
  pd.big=pdist.big(tree = tree, wd=save.wd, nworker = nworker)
  qp2=qpen(comm=comm, pd=pd.big$pd.file, pd.big.wd=pd.big$pd.wd,
           pd.big.spname=pd.big$tip.label, tree=tree,
           rand.time=rand.time, nworker=nworker)
  setwd(wd0)

</code></pre>

<hr>
<h2 id='qpen.cm'>
Quantifying assembly processes based on entire-community null model analysis under multiple metacommunities
</h2><span id='topic+qpen.cm'></span>

<h3>Description</h3>

<p>The framework quantifying assembly processes based on entire-community null model analysis (Stegen et al 2013, 2015). add bigmemory function to handle large datasets. This function can deal with local communities under different metacommunities (regional pools).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>qpen.cm(comm, pd = NULL, pd.big.wd = NULL,
        pd.big.spname = NULL, tree = NULL,
        meta.group = NULL, meta.com = NULL,
        meta.frequency = NULL, meta.ab = NULL,
        ab.weight = TRUE, exclude.conspecifics = FALSE,
        rand.time = 1000, sig.bNTI = 1.96, sig.rc = 0.95,
        nworker = 4, memory.G = 50, project = NA, wd = getwd(),
        output.detail = FALSE, save.bNTIRC = FALSE,
        taxo.metric = "bray", transform.method = NULL,
        logbase = 2, dirichlet = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="qpen.cm_+3A_comm">comm</code></td>
<td>
<p>matrix or data.frame, community data, each row is a sample or site, each colname is a taxon (species or OTU or ASV), thus rownames should be sample IDs, colnames should be taxa IDs.</p>
</td></tr>
<tr><td><code id="qpen.cm_+3A_pd">pd</code></td>
<td>
<p>a character or a matrix or NULL. If it is a character, it specifies the name of the file to hold the backingfile description of the big phylogenetic distance matrix, it is usually &quot;pd.desc&quot; if using default setting in pdist.big function. If it is matrix, it is the phylogenetic distance matrix with taxa IDs as colnames and rownames. The function will check the consistency of species names between phylogenetic matrix and comm. if pd is NULL, the function will calculate phylogenetic distance matrix from tree.</p>
</td></tr>
<tr><td><code id="qpen.cm_+3A_pd.big.wd">pd.big.wd</code></td>
<td>
<p>a folder path, where the bigmemmory file of the phylogenetic distance matrix are saved. If pd has given the phylogenetic matrix, pd.big.wd should be NULL. If pd is NULL and pd.big.wd is NULL either, a folder will be created to save the big phylgoenetic distance matrix.</p>
</td></tr>
<tr><td><code id="qpen.cm_+3A_pd.big.spname">pd.big.spname</code></td>
<td>
<p>character vector, taxa id in the same rank as the big matrix of phylogenetic distances. not necessary if pd has given the phylogenetic matrix.</p>
</td></tr>
<tr><td><code id="qpen.cm_+3A_tree">tree</code></td>
<td>
<p>phylogenetic tree, an object of class &quot;phylo&quot;.</p>
</td></tr>
<tr><td><code id="qpen.cm_+3A_meta.group">meta.group</code></td>
<td>
<p>matrix or data.frame, a one-column (n x 1) matrix indicating which metacommunity each sample belongs to. Rownames are sample IDs. The first column is metacommunity names. Such that different samples can belong to different metacommunities. If input a n x m matrix, only the first column is used. NULL means all samples belong to the same metacommunity. Default is NULL, means all samples from the same metacommunity.</p>
</td></tr>
<tr><td><code id="qpen.cm_+3A_meta.com">meta.com</code></td>
<td>
<p>a list object, each element is a matrix or data.frame to define abundance (or relative abundance) of taxa in a metacommunity (regional pool). The element names indicate metacommunity names, which should be consistent with the metacommunity names defined in meta.group. If there is only one metacommunity, meta.com can be a matrix or data.frame to define taxa abundance (or relative abundance) in the metacommunity. Default is NULL, means to calculate metacommunity structure from comm according to metacommunities defined in meta.group.
</p>
</td></tr>
<tr><td><code id="qpen.cm_+3A_meta.frequency">meta.frequency</code></td>
<td>
<p>matrix or data.frame, each column represents a taxon, each row represents a metacommunity (regional pool), to define the occurrence frequency of each taxon in each metacommunity. The rownames indicate metacommunity names, which should be the same as the metacommunity names in meta.group. Default setting is NULL, means to calculate meta.frequency as occurrence frequency of each taxon in comm across the samples within each metacommunity defined by meta.group.</p>
</td></tr>
<tr><td><code id="qpen.cm_+3A_meta.ab">meta.ab</code></td>
<td>
<p>matrix or data.frame, each column represents a taxon, each row represents a metacommunity (regional pool), to define the aubndance (or relative abundance) of each taxon in each metacommunity. The rownames indicate metacommunity names, which should be the same as the metacommunity names in meta.group. Default setting is NULL, means to calculate meta.ab as average relative abundance of each taxon in comm across the samples within each metacommunity defined by meta.group.</p>
</td></tr>
<tr><td><code id="qpen.cm_+3A_ab.weight">ab.weight</code></td>
<td>
<p>logic, abundance-weighted or binary. default is TRUE, means abundance-weighted.</p>
</td></tr>
<tr><td><code id="qpen.cm_+3A_exclude.conspecifics">exclude.conspecifics</code></td>
<td>
<p>Logic, should conspecific taxa in different communities be exclude from MNTD calculations? default is FALSE. The same as in the function bmntd.</p>
</td></tr>
<tr><td><code id="qpen.cm_+3A_rand.time">rand.time</code></td>
<td>
<p>integer, randomization times. default is 1000.</p>
</td></tr>
<tr><td><code id="qpen.cm_+3A_sig.bnti">sig.bNTI</code></td>
<td>
<p>numeric, the cutoff of significant betaNTI, default is 1.96.</p>
</td></tr>
<tr><td><code id="qpen.cm_+3A_sig.rc">sig.rc</code></td>
<td>
<p>numeric, the cutoff of significant modified Raup-Crick metric, default is 0.95.</p>
</td></tr>
<tr><td><code id="qpen.cm_+3A_nworker">nworker</code></td>
<td>
<p>for parallel computing. Either a character vector of host names on which to run the worker copies of R, or a positive integer (in which case that number of copies is run on localhost). default is 4, means 4 threads will be run.</p>
</td></tr>
<tr><td><code id="qpen.cm_+3A_memory.g">memory.G</code></td>
<td>
<p>numeric, to set the memory size as you need, so that calculation of large tree will not be limited by physical memory. unit is Gb. default is 50Gb.</p>
</td></tr>
<tr><td><code id="qpen.cm_+3A_project">project</code></td>
<td>
<p>character string, the prefix of saved output files.</p>
</td></tr>
<tr><td><code id="qpen.cm_+3A_wd">wd</code></td>
<td>
<p>a folder path, where the files will be saved.</p>
</td></tr>
<tr><td><code id="qpen.cm_+3A_output.detail">output.detail</code></td>
<td>
<p>logic, if TRUE, some detailed results including all null values will be output.</p>
</td></tr>
<tr><td><code id="qpen.cm_+3A_save.bntirc">save.bNTIRC</code></td>
<td>
<p>logic, if TRUE, a file will be saved in the folder specified by wd.</p>
</td></tr>
<tr><td><code id="qpen.cm_+3A_taxo.metric">taxo.metric</code></td>
<td>
<p>taxonomic beta diversity index, the same as 'method' in the function 'vegdist' in package 'vegan', including &quot;manhattan&quot;, &quot;euclidean&quot;, &quot;canberra&quot;, &quot;clark&quot;, &quot;bray&quot;, &quot;kulczynski&quot;, &quot;jaccard&quot;, &quot;gower&quot;, &quot;altGower&quot;, &quot;morisita&quot;, &quot;horn&quot;, &quot;mountford&quot;, &quot;raup&quot;, &quot;binomial&quot;, &quot;chao&quot;, &quot;cao&quot; or &quot;mahalanobis&quot;. If taxo.metric='bray' and transform.method=NULL, RC will be calculated based on Bray-Curtis dissimilarity as recommended in original iCAMP; otherwise, unit.sum setting will be ignored.</p>
</td></tr>
<tr><td><code id="qpen.cm_+3A_transform.method">transform.method</code></td>
<td>
<p>character or a defined function, to specify how to transform community matrix before calculating taxonomic dissimilarity. Due to the definition of the phylogenetic dissimilarity (bMNTD), it is not affected by data transformation. If transform.method is a characher, it should be a method name as in the function 'decostand' in package 'vegan', including 'total','max','freq','normalize','range','standardize','pa','chi.square','cmdscale','hellinger','log'.</p>
</td></tr>
<tr><td><code id="qpen.cm_+3A_logbase">logbase</code></td>
<td>
<p>numeric, the logarithm base used when transform.method='log'.</p>
</td></tr> 
<tr><td><code id="qpen.cm_+3A_dirichlet">dirichlet</code></td>
<td>
<p>Logic. If TRUE, the taxonomic null model will use Dirichlet distribution to generate relative abundances in randomized community matrix. If the input community matrix has all row sums no more than 1, the function will automatically set dirichlet=TRUE. default is FALSE.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is particularly designed for samples from different metacommunities. The null model will randomize the commuity matrix under different metacommunities, separately (and independently). All other details are the same as the function qpen. 
</p>


<h3>Value</h3>

<p>output is a list with following elements.
</p>
<table>
<tr><td><code>ratio</code></td>
<td>
<p>The overall percentage of turnovers governed by each process</p>
</td></tr>
<tr><td><code>result</code></td>
<td>
<p>a matrix, showing betaMNTD, Bray-Curtis dissimilarity, betaNTI, RC, and the identified process governing each turnover. Each row represents a turnover between two samples.</p>
</td></tr>
<tr><td><code>pd</code></td>
<td>
<p>phylogenetic distance matrix or the backingfile name if phylogenetic distance is saved by bigmemeory function.</p>
</td></tr>
<tr><td><code>bMNTD</code></td>
<td>
<p>a square matrix of observed betaMNTD.</p>
</td></tr>
<tr><td><code>BC</code></td>
<td>
<p>a square matrix of observed Bary-Curtis index.</p>
</td></tr>
<tr><td><code>bMNTD.rand</code></td>
<td>
<p>a matrix showing all null values of betaMNTD.</p>
</td></tr>
<tr><td><code>BC.rand</code></td>
<td>
<p>a matrix showing all null values of Bray-Curtis index.</p>
</td></tr>
<tr><td><code>setting</code></td>
<td>
<p>a data.frame showing all settings for this function.</p>
</td></tr>
</table>


<h3>Note</h3>

<p>Version 1: 2021.8.3
</p>


<h3>Author(s)</h3>

<p>Daliang Ning
</p>


<h3>References</h3>

<p>Stegen, J.C., Lin, X., Fredrickson, J.K., Chen, X., Kennedy, D.W., Murray, C.J. et al. (2013). Quantifying community assembly processes and identifying features that impose them. ISME J, 7, 2069.
</p>
<p>Stegen, J.C., Lin, X., Fredrickson, J.K. &amp; Konopka, A.E. (2015). Estimating and mapping ecological processes influencing microbial community assembly. Front Microbiol, 6, 370.
</p>
<p>Kane, M.J., Emerson, J., &amp; Weston, S. (2013). Scalable Strategies for Computing with Massive Data. Journal of Statistical Software, 55(14), 1-19. URL http://www.jstatsoft.org/v55/i14/.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+qpen">qpen</a></code>, <code><a href="#topic+RC.cm">RC.cm</a></code>, <code><a href="#topic+bNTI.cm">bNTI.cm</a></code>, <code><a href="#topic+bNTI.big.cm">bNTI.big.cm</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("example.data")
comm=example.data$comm
tree=example.data$tree

# in this example, 10 samples from one metacommunity,
# the other 10 samples from another metacommunity.
meta.group=data.frame(meta.com=c(rep("meta1",10),rep("meta2",10)))
rownames(meta.group)=rownames(comm)

# since pdist.big need to save output to a certain folder,
# the following code is set as 'not test'.
# but you may test the code on your computer
# after change the folder path for 'save.wd'.

  wd0=getwd()
  nworker=2 # parallel computing thread number
  rand.time=5 # usually use 1000 for real data.
  
  # for a small dataset, phylogenetic distance matrix can be directly used.
  pd=example.data$pd
  qp=qpen.cm(comm=comm, meta.group=meta.group, pd=pd,
          rand.time=rand.time,nworker=nworker)
  
  # for a big dataset, pdist.big may be used
  save.wd=paste0(tempdir(),"/pdbig.qpen.cm")
  # please change to the folder you want to save the pd.big output.
  
  pd.big=pdist.big(tree = tree, wd=save.wd, nworker = nworker)
  qp2=qpen.cm(comm=comm, meta.group=meta.group,
           pd=pd.big$pd.file, pd.big.wd=pd.big$pd.wd,
           pd.big.spname=pd.big$tip.label, tree=tree,
           rand.time=rand.time, nworker=nworker)
  setwd(wd0)

</code></pre>

<hr>
<h2 id='qpen.test'>
Summary and comparison of QPEN results based on bootstrapping
</h2><span id='topic+qpen.test'></span>

<h3>Description</h3>

<p>Bootstrapping analysis of the results from QPEN (quantifying assembly processes based on entire-community null model analysis, Stegen et al 2013, 2015), to estimate the mean and variation of each index and each process influence in each group, and calculate the significance of the difference between groups.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>qpen.test(qpen.result, treat, rand.time = 1000,
          between.group = FALSE, out.detail = TRUE,
          silent = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="qpen.test_+3A_qpen.result">qpen.result</code></td>
<td>
<p>the output of the function 'qpen', or the element 'result' (data.frame) in qpen output.</p>
</td></tr>
<tr><td><code id="qpen.test_+3A_treat">treat</code></td>
<td>
<p>matrix or data.frame, each column indicates the group or treatment of each sample, rownames are sample IDs.</p>
</td></tr>
<tr><td><code id="qpen.test_+3A_rand.time">rand.time</code></td>
<td>
<p>integer, bootstrapping times. default is 1000.</p>
</td></tr>
<tr><td><code id="qpen.test_+3A_between.group">between.group</code></td>
<td>
<p>logic. if True, the turnovers between each pair of treatments will also be calculated as a group.</p>
</td></tr>
<tr><td><code id="qpen.test_+3A_out.detail">out.detail</code></td>
<td>
<p>logic. if True, the 'qpen' results and the bootstrapping results in each group will also be output.</p>
</td></tr>
<tr><td><code id="qpen.test_+3A_silent">silent</code></td>
<td>
<p>logic. if FALSE, some messages will show during calculation.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Basically use bootstrapping of samples to estimate the variation of each index's mean and relative importance of each process in each group, as well as the effect size and signficance of the difference between different groups.
</p>


<h3>Value</h3>

<p>Output is a list.
</p>
<table>
<tr><td><code>obs.summary</code></td>
<td>
<p>the mean, standarded deviation, quartile, and boxplot elements for each observed index (e.g. bMNTD, bNTI, etc.) in each group.</p>
</td></tr>
<tr><td><code>boot.summary</code></td>
<td>
<p>the mean, standarded deviation, quartile, and boxplot elements of the average level of each index and the estimated relative importance of each process in each group.</p>
</td></tr>
<tr><td><code>compare</code></td>
<td>
<p>The relative difference, Cohen's d, and P value of the difference of each index or each process importance between different groups.</p>
</td></tr>
<tr><td><code>group.results.detail</code></td>
<td>
<p>the qpen results in each group.</p>
</td></tr>
<tr><td><code>boot.detail</code></td>
<td>
<p>the average value of each index or estimated relative importanc of each process in each group in each time of bootstrapping.</p>
</td></tr>
</table>


<h3>Note</h3>

<p>Version 2: 2021.6.9 speed up transformation for a huge number of comparisons by using package data.table.
Version 1: 2021.4.15 include the function into package iCAMP.
</p>


<h3>Author(s)</h3>

<p>Daliang Ning
</p>


<h3>References</h3>

<p>Ning, D., Yuan, M., Wu, L., Zhang, Y., Guo, X., Zhou, X. et al. (2020). A quantitative framework reveals ecological drivers of grassland microbial community assembly in response to warming. Nature Communications, 11, 4717.
</p>
<p>Stegen, J.C., Lin, X., Fredrickson, J.K., Chen, X., Kennedy, D.W., Murray, C.J. et al. (2013). Quantifying community assembly processes and identifying features that impose them. ISME J, 7, 2069.
</p>
<p>Stegen, J.C., Lin, X., Fredrickson, J.K. &amp; Konopka, A.E. (2015). Estimating and mapping ecological processes influencing microbial community assembly. Front Microbiol, 6, 370.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+qpen">qpen</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("example.data")
comm=example.data$comm
tree=example.data$tree
treat=example.data$treat
# since pdist.big need to save output to a certain folder,
# the following code is set as 'not test'.
# but you may test the code on your computer
# after change the folder path for 'save.wd'.

  wd0=getwd()
  nworker=2 # parallel computing thread number
  rand.time=5 # usually use 1000 for real data.
  
  # for a big dataset, pdist.big may be used
  save.wd=paste0(tempdir(),"/pdbig.qpen.test")
  # please change to the folder you want to save the pd.big output.
  
  pd.big=pdist.big(tree = tree, wd=save.wd, nworker = nworker)
  qp2=qpen(comm=comm, pd=pd.big$pd.file, pd.big.wd=pd.big$pd.wd,
           pd.big.spname=pd.big$tip.label, tree=tree,
           rand.time=rand.time, nworker=nworker)

  qptest=qpen.test(qpen.result=qp2, treat=treat)
  setwd(wd0)

</code></pre>

<hr>
<h2 id='RC.bin.bigc'>
Calculate modified Roup-Crick index based on Bray-Curtis similarity for each phylogenetic bin
</h2><span id='topic+RC.bin.bigc'></span>

<h3>Description</h3>

<p>Calculate modified Roup-Crick index based on Bray-Curtis similarity (RC.Bray) for each phylogenetic bin. The null model algorithm will randomize the whole community data matrix of all bins. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>RC.bin.bigc(com, sp.bin, rand = 1000, na.zero = TRUE,
            nworker = 4, memory.G = 50, big.method = c("loop", "no"),
            weighted = TRUE, unit.sum = NULL, meta.ab = NULL,
            sig.index=c("RC","Confidence","SES"),
            detail.null=FALSE,output.bray=FALSE,
            taxo.metric= "bray", transform.method=NULL,
            logbase=2, dirichlet=FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="RC.bin.bigc_+3A_com">com</code></td>
<td>
<p>community data matrix. rownames are sample names. colnames are species names.</p>
</td></tr>
<tr><td><code id="RC.bin.bigc_+3A_sp.bin">sp.bin</code></td>
<td>
<p>one-column matrix, rownames are taxa IDs (i.e. OTU IDs), the only column shows the bin ID of each taxon. Bin IDs are integers.</p>
</td></tr>
<tr><td><code id="RC.bin.bigc_+3A_rand">rand</code></td>
<td>
<p>integer, randomization times. default is 1000.</p>
</td></tr>
<tr><td><code id="RC.bin.bigc_+3A_na.zero">na.zero</code></td>
<td>
<p>logic. If community data marix has any zero-sum row (sample), Bray-Curtis index will be NA. Somtimes, this kind of NA need be set as zero to avoid some format problem in following calculation. Default is TRUE.</p>
</td></tr>
<tr><td><code id="RC.bin.bigc_+3A_nworker">nworker</code></td>
<td>
<p>for parallel computing. Either a character vector of host names on which to run the worker copies of R, or a positive integer (in which case that number of copies is run on localhost). default is 4, means 4 threads will be run.</p>
</td></tr>
<tr><td><code id="RC.bin.bigc_+3A_memory.g">memory.G</code></td>
<td>
<p>numeric, to set the memory size as you need, so that calculation of big data will not be limited by physical memory. unit is Gb. default is 50Gb.</p>
</td></tr>
<tr><td><code id="RC.bin.bigc_+3A_big.method">big.method</code></td>
<td>
<p>character, the method to handle big data. loop, randomization once after another; no, use parallel computing.</p>
</td></tr>
<tr><td><code id="RC.bin.bigc_+3A_weighted">weighted</code></td>
<td>
<p>Logic, consider abundances or not (just presence/absence). default is TRUE.</p>
</td></tr>
<tr><td><code id="RC.bin.bigc_+3A_unit.sum">unit.sum</code></td>
<td>
<p>If unit.sum is set as a number or a numeric vector, the taxa abundances will be divided by unit.sum to calculate the relative abundances, and the Bray-Cuits index in each bin will become manhattan index divided by 2. usually, unit.sum can be set as the sequencing depth in each sample. Default setting is NULL, means not to do this special transformation.</p>
</td></tr>
<tr><td><code id="RC.bin.bigc_+3A_meta.ab">meta.ab</code></td>
<td>
<p>a numeric vector, to define the relative aubndance of each species in the regional pool. Default setting is NULL, means to calculate meta.ab as average relative abundance of each species across the samples.</p>
</td></tr>
<tr><td><code id="RC.bin.bigc_+3A_sig.index">sig.index</code></td>
<td>
<p>character, the index for null model significance test. RC, modified Raup-Crick index (RC) based on taxonomic dissimilarity (default is Bray-Curtis, BC), i.e. count the number of null BC lower than observed BC plus a half of the number of null BC equal to observed BC, to get alpha, then calculate RCbray as (2 x alpha - 1). SES, standard effect size; Confidence, percentage of null values less extreme than the observed value, i.e. non-parametric one-side confidence level. default is RC. If input a vector, only the first element will be used.</p>
</td></tr>
<tr><td><code id="RC.bin.bigc_+3A_detail.null">detail.null</code></td>
<td>
<p>logic, if TRUE, the output will include all the null values. Default is FALSE.</p>
</td></tr>
<tr><td><code id="RC.bin.bigc_+3A_output.bray">output.bray</code></td>
<td>
<p>logic, if TRUE, the output will include observed taxonomic dissimilarity (default is Bray-Curtis).</p>
</td></tr>
<tr><td><code id="RC.bin.bigc_+3A_taxo.metric">taxo.metric</code></td>
<td>
<p>taxonomic beta diversity index, the same as 'method' in the function 'vegdist' in package 'vegan', including &quot;manhattan&quot;, &quot;euclidean&quot;, &quot;canberra&quot;, &quot;clark&quot;, &quot;bray&quot;, &quot;kulczynski&quot;, &quot;jaccard&quot;, &quot;gower&quot;, &quot;altGower&quot;, &quot;morisita&quot;, &quot;horn&quot;, &quot;mountford&quot;, &quot;raup&quot;, &quot;binomial&quot;, &quot;chao&quot;, &quot;cao&quot; or &quot;mahalanobis&quot;. If taxo.metric='bray' and transform.method=NULL, RC will be calculated based on Bray-Curtis dissimilarity as recommended in original iCAMP; otherwise, unit.sum setting will be ignored.</p>
</td></tr>
<tr><td><code id="RC.bin.bigc_+3A_transform.method">transform.method</code></td>
<td>
<p>character or a defined function, to specify how to transform community matrix before calculating dissimilarity. if it is a characher, it should be a method name as in the function 'decostand' in package 'vegan', including 'total','max','freq','normalize','range','standardize','pa','chi.square','cmdscale','hellinger','log'.</p>
</td></tr>
<tr><td><code id="RC.bin.bigc_+3A_logbase">logbase</code></td>
<td>
<p>numeric, the logarithm base used when transform.method='log'.</p>
</td></tr> 
<tr><td><code id="RC.bin.bigc_+3A_dirichlet">dirichlet</code></td>
<td>
<p>Logic. If TRUE, the taxonomic null model will use Dirichlet distribution to generate relative abundances in randomized community matrix. If the input community matrix has all row sums no more than 1, the function will automatically set dirichlet=TRUE. default is FALSE.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function calculates RC.Bray in each phylogenetic bin while randomizing across all bins (Ning et al 2020). The Raup-Crick based on taxonomic dissimilarity index was proposed by Chase in 2011, and then modified to include consider species relative abundances by Stegen in 2013. The non-random part recognized by RC can reflect the influence niche seletion and extreme dispersal. The original codes used a relatively time-consuming looping. This function improved the efficiency and added some parameters to fit iCAMP analysis.
</p>
<p>SES (Kraft et al 2011) and Confidence (Ning et al 2020) are alternative significance testing indexes to evaluate how the observed beta diversity index deviates from null expectation.
</p>


<h3>Value</h3>

<p>Output is a list. 
</p>
<table>
<tr><td><code>index</code></td>
<td>
<p>list, each element is a square matrix of RC (or SES or Confidence based on Bray-Curtis) values of a bin. The elements (bins) are in the same order as in the input pdid.bin.</p>
</td></tr>
<tr><td><code>sig.index</code></td>
<td>
<p>character, indicates the index for null model significance test, RC, Confidence, or SES.</p>
</td></tr>
<tr><td><code>BC.obs</code></td>
<td>
<p>Output only if output.bray is TRUE. A list, each element is a square matrix of observed taxonomic dissimilarity (default is Bray-Curtis) index values of a bin. The elements (bins) are in the same order as in the input pdid.bin.</p>
</td></tr>
<tr><td><code>rand</code></td>
<td>
<p>Output only if detail.null is TRUE. A list, each element is a matrix with null values of Bray-Curtis index for each turnover of a bin. The elements (bins) are in the same order as in the input pdid.bin.</p>
</td></tr>
</table>


<h3>Note</h3>

<p>Version 7: 2021.4.18, fix the bug when detail.null=TRUE and comm has only two samples.
Version 6: 2021.4.17, add taxo.metric, transform.method, logbase, and dirichlet, to allow community data transform, dissimilar index other than Bray-Curtis, and relative abundances (values &lt; 1) in the input community matrix.
Version 5: 2020.8.19, update help document, add example.
Version 4: 2020.8.2, add sig.index, detail.null, and output.bray.
Version 3: 2020.6.14, add meta.ab
Version 2: 2018.10.3, add unit.sum
Version 1: 2015.3.17
</p>


<h3>Author(s)</h3>

<p>Daliang Ning
</p>


<h3>References</h3>

<p>Ning, D., Yuan, M., Wu, L., Zhang, Y., Guo, X., Zhou, X. et al. (2020). A quantitative framework reveals ecological drivers of grassland microbial community assembly in response to warming. Nature Communications, 11, 4717.
</p>
<p>Chase, J.M., Kraft, N.J.B., Smith, K.G., Vellend, M. &amp; Inouye, B.D. (2011). Using null models to disentangle variation in community dissimilarity from variation in alpha-diversity. Ecosphere, 2, 1-11.
</p>
<p>Stegen, J.C., Lin, X., Fredrickson, J.K., Chen, X., Kennedy, D.W., Murray, C.J. et al. (2013). Quantifying community assembly processes and identifying features that impose them. ISME J, 7, 2069.
</p>
<p>Kraft, N.J.B., Comita, L.S., Chase, J.M., Sanders, N.J., Swenson, N.G., Crist, T.O. et al. (2011). Disentangling the drivers of beta diversity along latitudinal and elevational gradients. Science, 333, 1755-1758.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+RC.pc">RC.pc</a></code>,<code><a href="#topic+RC.bin.cm">RC.bin.cm</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("example.data")
comm=example.data$comm
sp.bin=example.data$sp.bin
rand.time=20 # usually use 1000 for real data.
nworker=2 # parallel computing thread number
RCbin=RC.bin.bigc(com=comm, sp.bin=sp.bin,
                  rand=rand.time, nworker=nworker,
                  weighted=TRUE, sig.index="RC")
</code></pre>

<hr>
<h2 id='RC.bin.cm'>
Calculate modified Roup-Crick index based on Bray-Curtis similarity for each phylogenetic bin under multiple metacommunities
</h2><span id='topic+RC.bin.cm'></span>

<h3>Description</h3>

<p>Calculate modified Roup-Crick index based on Bray-Curtis similarity (RC.Bray) for each phylogenetic bin. The null model algorithm will randomize the whole community data matrix of all bins. This function can deal with local communities under different metacommunities (regional pools).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>RC.bin.cm(com, sp.bin, rand = 1000, na.zero = TRUE,
          meta.group = NULL, meta.frequency = NULL,
          meta.ab = NULL, nworker = 4, memory.G = 50,
          big.method = c("loop", "no"), weighted = TRUE,
          unit.sum = NULL, sig.index = c("RC", "Confidence", "SES"),
          detail.null = FALSE, output.bray = FALSE,
          taxo.metric = "bray", transform.method = NULL,
          logbase = 2, dirichlet = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="RC.bin.cm_+3A_com">com</code></td>
<td>
<p>community data matrix. rownames are sample names. colnames are species names.</p>
</td></tr>
<tr><td><code id="RC.bin.cm_+3A_sp.bin">sp.bin</code></td>
<td>
<p>one-column matrix, rownames are taxa IDs (i.e. OTU IDs), the only column shows the bin ID of each taxon. Bin IDs are integers.</p>
</td></tr>
<tr><td><code id="RC.bin.cm_+3A_rand">rand</code></td>
<td>
<p>integer, randomization times. default is 1000.</p>
</td></tr>
<tr><td><code id="RC.bin.cm_+3A_na.zero">na.zero</code></td>
<td>
<p>logic. If community data marix has any zero-sum row (sample), Bray-Curtis index will be NA. Somtimes, this kind of NA need be set as zero to avoid some format problem in following calculation. Default is TRUE.</p>
</td></tr>
<tr><td><code id="RC.bin.cm_+3A_meta.group">meta.group</code></td>
<td>
<p>matrix or data.frame, a one-column (n x 1) matrix indicating which metacommunity each sample belongs to. Rownames are sample IDs. The first column is metacommunity names. Such that different samples can belong to different metacommunities. If input a n x m matrix, only the first column is used. NULL means all samples belong to the same metacommunity. Default is NULL, means all samples from the same metacommunity.</p>
</td></tr>
<tr><td><code id="RC.bin.cm_+3A_meta.frequency">meta.frequency</code></td>
<td>
<p>matrix or data.frame, each column represents a taxon, each row represents a metacommunity (regional pool), to define the occurrence frequency of each taxon in each metacommunity. The rownames indicate metacommunity names, which should be the same as the metacommunity names in meta.group. Default setting is NULL, means to calculate meta.frequency as occurrence frequency of each taxon in comm across the samples within each metacommunity defined by meta.group.</p>
</td></tr>
<tr><td><code id="RC.bin.cm_+3A_meta.ab">meta.ab</code></td>
<td>
<p>matrix or data.frame, each column represents a taxon, each row represents a metacommunity (regional pool), to define the aubndance (or relative abundance) of each taxon in each metacommunity. The rownames indicate metacommunity names, which should be the same as the metacommunity names in meta.group. Default setting is NULL, means to calculate meta.ab as average relative abundance of each taxon in comm across the samples within each metacommunity defined by meta.group.</p>
</td></tr>
<tr><td><code id="RC.bin.cm_+3A_nworker">nworker</code></td>
<td>
<p>for parallel computing. Either a character vector of host names on which to run the worker copies of R, or a positive integer (in which case that number of copies is run on localhost). default is 4, means 4 threads will be run.</p>
</td></tr>
<tr><td><code id="RC.bin.cm_+3A_memory.g">memory.G</code></td>
<td>
<p>numeric, to set the memory size as you need, so that calculation of big data will not be limited by physical memory. unit is Gb. default is 50Gb.</p>
</td></tr>
<tr><td><code id="RC.bin.cm_+3A_big.method">big.method</code></td>
<td>
<p>character, the method to handle big data. loop, randomization once after another; no, use parallel computing.</p>
</td></tr>
<tr><td><code id="RC.bin.cm_+3A_weighted">weighted</code></td>
<td>
<p>Logic, consider abundances or not (just presence/absence). default is TRUE.</p>
</td></tr>
<tr><td><code id="RC.bin.cm_+3A_unit.sum">unit.sum</code></td>
<td>
<p>If unit.sum is set as a number or a numeric vector, the taxa abundances will be divided by unit.sum to calculate the relative abundances, and the Bray-Cuits index in each bin will become manhattan index divided by 2. usually, unit.sum can be set as the sequencing depth in each sample. Default setting is NULL, means not to do this special transformation.</p>
</td></tr>
<tr><td><code id="RC.bin.cm_+3A_sig.index">sig.index</code></td>
<td>
<p>character, the index for null model significance test. RC, modified Raup-Crick index (RC) based on taxonomic dissimilarity (default is Bray-Curtis, BC), i.e. count the number of null BC lower than observed BC plus a half of the number of null BC equal to observed BC, to get alpha, then calculate RCbray as (2 x alpha - 1). SES, standard effect size; Confidence, percentage of null values less extreme than the observed value, i.e. non-parametric one-side confidence level. default is RC. If input a vector, only the first element will be used.</p>
</td></tr>
<tr><td><code id="RC.bin.cm_+3A_detail.null">detail.null</code></td>
<td>
<p>logic, if TRUE, the output will include all the null values. Default is FALSE.</p>
</td></tr>
<tr><td><code id="RC.bin.cm_+3A_output.bray">output.bray</code></td>
<td>
<p>logic, if TRUE, the output will include observed taxonomic dissimilarity (default is Bray-Curtis).</p>
</td></tr>
<tr><td><code id="RC.bin.cm_+3A_taxo.metric">taxo.metric</code></td>
<td>
<p>taxonomic beta diversity index, the same as 'method' in the function 'vegdist' in package 'vegan', including &quot;manhattan&quot;, &quot;euclidean&quot;, &quot;canberra&quot;, &quot;clark&quot;, &quot;bray&quot;, &quot;kulczynski&quot;, &quot;jaccard&quot;, &quot;gower&quot;, &quot;altGower&quot;, &quot;morisita&quot;, &quot;horn&quot;, &quot;mountford&quot;, &quot;raup&quot;, &quot;binomial&quot;, &quot;chao&quot;, &quot;cao&quot; or &quot;mahalanobis&quot;. If taxo.metric='bray' and transform.method=NULL, RC will be calculated based on Bray-Curtis dissimilarity as recommended in original iCAMP; otherwise, unit.sum setting will be ignored.</p>
</td></tr>
<tr><td><code id="RC.bin.cm_+3A_transform.method">transform.method</code></td>
<td>
<p>character or a defined function, to specify how to transform community matrix before calculating dissimilarity. if it is a characher, it should be a method name as in the function 'decostand' in package 'vegan', including 'total','max','freq','normalize','range','standardize','pa','chi.square','cmdscale','hellinger','log'.</p>
</td></tr>
<tr><td><code id="RC.bin.cm_+3A_logbase">logbase</code></td>
<td>
<p>numeric, the logarithm base used when transform.method='log'.</p>
</td></tr> 
<tr><td><code id="RC.bin.cm_+3A_dirichlet">dirichlet</code></td>
<td>
<p>Logic. If TRUE, the taxonomic null model will use Dirichlet distribution to generate relative abundances in randomized community matrix. If the input community matrix has all row sums no more than 1, the function will automatically set dirichlet=TRUE. default is FALSE.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is particularly designed for samples from different metacommunities. The null model will randomize the commuity matrix under different metacommunities, separately (and independently). All other details are the same as the function RC.bin.bigc.
</p>


<h3>Value</h3>

<p>Output is a list. 
</p>
<table>
<tr><td><code>index</code></td>
<td>
<p>list, each element is a square matrix of RC (or SES or Confidence based on Bray-Curtis) values of a bin. The elements (bins) are in the same order as in the input pdid.bin.</p>
</td></tr>
<tr><td><code>sig.index</code></td>
<td>
<p>character, indicates the index for null model significance test, RC, Confidence, or SES.</p>
</td></tr>
<tr><td><code>BC.obs</code></td>
<td>
<p>Output only if output.bray is TRUE. A list, each element is a square matrix of observed taxonomic dissimilarity (default is Bray-Curtis) index values of a bin. The elements (bins) are in the same order as in the input pdid.bin.</p>
</td></tr>
<tr><td><code>rand</code></td>
<td>
<p>Output only if detail.null is TRUE. A list, each element is a matrix with null values of Bray-Curtis index for each turnover of a bin. The elements (bins) are in the same order as in the input pdid.bin.</p>
</td></tr>
</table>


<h3>Note</h3>

<p>Version 1: 2021.8.4
</p>


<h3>Author(s)</h3>

<p>Daliang Ning
</p>


<h3>References</h3>

<p>Ning, D., Yuan, M., Wu, L., Zhang, Y., Guo, X., Zhou, X. et al. (2020). A quantitative framework reveals ecological drivers of grassland microbial community assembly in response to warming. Nature Communications, 11, 4717.
</p>
<p>Chase, J.M., Kraft, N.J.B., Smith, K.G., Vellend, M. &amp; Inouye, B.D. (2011). Using null models to disentangle variation in community dissimilarity from variation in alpha-diversity. Ecosphere, 2, 1-11.
</p>
<p>Stegen, J.C., Lin, X., Fredrickson, J.K., Chen, X., Kennedy, D.W., Murray, C.J. et al. (2013). Quantifying community assembly processes and identifying features that impose them. ISME J, 7, 2069.
</p>
<p>Kraft, N.J.B., Comita, L.S., Chase, J.M., Sanders, N.J., Swenson, N.G., Crist, T.O. et al. (2011). Disentangling the drivers of beta diversity along latitudinal and elevational gradients. Science, 333, 1755-1758.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+RC.bin.bigc">RC.bin.bigc</a></code>,<code><a href="#topic+RC.cm">RC.cm</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("example.data")
comm=example.data$comm
sp.bin=example.data$sp.bin

# in this example, 10 samples from one metacommunity,
# the other 10 samples from another metacommunity.
meta.group=data.frame(meta.com=c(rep("meta1",10),rep("meta2",10)))
rownames(meta.group)=rownames(comm)

rand.time=20 # usually use 1000 for real data.
nworker=2 # parallel computing thread number
RCbin=RC.bin.cm(com=comm, meta.group=meta.group,
                sp.bin=sp.bin, rand=rand.time,
                nworker=nworker, weighted=TRUE,
                sig.index="RC")
</code></pre>

<hr>
<h2 id='RC.cm'>
Modified Raup-Crick index based on Bray-Curtis similarity under multiple metacommunities
</h2><span id='topic+RC.cm'></span>

<h3>Description</h3>

<p>The Raup-Crick based on taxonomic dissimilarity index (i.e. Bray-Curtis) is to use null models to disentangle variation in community dissimilarity from variation in alpha-diversity. This function can deal with local communities under different metacommunities (regional pools).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>RC.cm(comm, rand = 1000, na.zero = TRUE, nworker = 4,
      meta.group = NULL, meta.frequency = NULL, meta.ab = NULL,
      memory.G = 50, weighted = TRUE, unit.sum = NULL,
      sig.index = c("RC", "Confidence", "SES"), detail.null = FALSE,
      output.bray = FALSE, silent = FALSE, taxo.metric = "bray",
      transform.method = NULL, logbase = 2, dirichlet = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="RC.cm_+3A_comm">comm</code></td>
<td>
<p>Community data matrix. rownames are sample names. colnames are species names.</p>
</td></tr>
<tr><td><code id="RC.cm_+3A_rand">rand</code></td>
<td>
<p>integer, randomization times, default is 1000.</p>
</td></tr>
<tr><td><code id="RC.cm_+3A_na.zero">na.zero</code></td>
<td>
<p>logic. If community data marix has any zero-sum row (sample), Bray-Curtis index will be NA. Somtimes, this kind of NA need be set as zero to avoid some format problem in following calculation. Default is TRUE.</p>
</td></tr>
<tr><td><code id="RC.cm_+3A_nworker">nworker</code></td>
<td>
<p>for parallel computing. Either a character vector of host names on which to run the worker copies of R, or a positive integer (in which case that number of copies is run on localhost). default is 4, means 4 threads will be run.</p>
</td></tr>
<tr><td><code id="RC.cm_+3A_meta.group">meta.group</code></td>
<td>
<p>matrix or data.frame, a one-column (n x 1) matrix indicating which metacommunity each sample belongs to. rownames are sample IDs. first column is metacommunity names. Such that different samples can belong to different metacommunities. If input a n x m matrix, only the first column is used. NULL means all samples belong to the same metacommunity. Default is NULL, means all samples from the same metacommunity.</p>
</td></tr>
<tr><td><code id="RC.cm_+3A_meta.frequency">meta.frequency</code></td>
<td>
<p>matrix or data.frame, each column represents a taxon, each row represents a metacommunity (regional pool), to define the occurrence frequency of each taxon in each metacommunity. The rownames indicate metacommunity names, which should be the same as the metacommunity names in meta.group. Default setting is NULL, means to calculate meta.frequency as occurrence frequency of each taxon in comm across the samples within each metacommunity defined by meta.group.</p>
</td></tr>
<tr><td><code id="RC.cm_+3A_meta.ab">meta.ab</code></td>
<td>
<p>matrix or data.frame, each column represents a taxon, each row represents a metacommunity (regional pool), to define the aubndance (or relative abundance) of each taxon in each metacommunity. The rownames indicate metacommunity names, which should be the same as the metacommunity names in meta.group. Default setting is NULL, means to calculate meta.ab as average relative abundance of each taxon in comm across the samples within each metacommunity defined by meta.group.</p>
</td></tr>
<tr><td><code id="RC.cm_+3A_memory.g">memory.G</code></td>
<td>
<p>numeric, to set the memory size as you need, so that calculation of big data will not be limited by physical memory. unit is Gb. default is 50Gb.</p>
</td></tr>
<tr><td><code id="RC.cm_+3A_weighted">weighted</code></td>
<td>
<p>lOgic, whether to use abundance-weighted metrics. default is TRUE</p>
</td></tr>
<tr><td><code id="RC.cm_+3A_unit.sum">unit.sum</code></td>
<td>
<p>If unit.sum is set as a number or a numeric vector, the taxa abundances will be divided by unit.sum to calculate the relative abundances, and the Bray-Cuits index in each bin will become manhattan index divided by 2. usually, unit.sum can be set as the sequencing depth in each sample. Default setting is NULL, means not to do this special transformation.</p>
</td></tr>
<tr><td><code id="RC.cm_+3A_sig.index">sig.index</code></td>
<td>
<p>character, the index for null model significance test. RC, modified Raup-Crick index (RC) based on Bray-Curtis (BC), i.e. count the number of null BC lower than observed BC plus a half of the number of null BC equal to observed BC, to get alpha, then calculate RCbray as (2 x alpha - 1). SES, standard effect size; Confidence, percentage of null values less extreme than the observed value, i.e. non-parametric one-side confidence level. default is RC. If input a vector, only the first element will be used.</p>
</td></tr>
<tr><td><code id="RC.cm_+3A_detail.null">detail.null</code></td>
<td>
<p>logic, if TRUE, the output will include all the null values. Default is FALSE.</p>
</td></tr>
<tr><td><code id="RC.cm_+3A_output.bray">output.bray</code></td>
<td>
<p>logic, if TRUE, the output will include observed taxonomic dissimilarity (default is Bray-Curtis).</p>
</td></tr>
<tr><td><code id="RC.cm_+3A_silent">silent</code></td>
<td>
<p>logic, if FALSE, some messages will show during calculation.</p>
</td></tr>
<tr><td><code id="RC.cm_+3A_taxo.metric">taxo.metric</code></td>
<td>
<p>taxonomic beta diversity index, the same as 'method' in the function 'vegdist' in package 'vegan', including &quot;manhattan&quot;, &quot;euclidean&quot;, &quot;canberra&quot;, &quot;clark&quot;, &quot;bray&quot;, &quot;kulczynski&quot;, &quot;jaccard&quot;, &quot;gower&quot;, &quot;altGower&quot;, &quot;morisita&quot;, &quot;horn&quot;, &quot;mountford&quot;, &quot;raup&quot;, &quot;binomial&quot;, &quot;chao&quot;, &quot;cao&quot; or &quot;mahalanobis&quot;. If taxo.metric='bray' and transform.method=NULL, RC will be calculated based on Bray-Curtis dissimilarity as recommended in original iCAMP; otherwise, unit.sum setting will be ignored.</p>
</td></tr>
<tr><td><code id="RC.cm_+3A_transform.method">transform.method</code></td>
<td>
<p>character or a defined function, to specify how to transform community matrix before calculating dissimilarity. if it is a characher, it should be a method name as in the function 'decostand' in package 'vegan', including 'total','max','freq','normalize','range','standardize','pa','chi.square','cmdscale','hellinger','log'.</p>
</td></tr>
<tr><td><code id="RC.cm_+3A_logbase">logbase</code></td>
<td>
<p>numeric, the logarithm base used when transform.method='log'.</p>
</td></tr> 
<tr><td><code id="RC.cm_+3A_dirichlet">dirichlet</code></td>
<td>
<p>Logic. If TRUE, the taxonomic null model will use Dirichlet distribution to generate relative abundances in randomized community matrix. If the input community matrix has all row sums no more than 1, the function will automatically set dirichlet=TRUE. default is FALSE.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>While all other details are the same as the function RC.pc, this function is particularly designed for samples from different metacommunities. The null model will randomize the commuity matrix under different metacommunities, separately (and independently).
</p>


<h3>Value</h3>

<p>Output is a list. 
</p>
<table>
<tr><td><code>index</code></td>
<td>
<p>a square matrix of RC (or SES or Confidence based on Bray-Curtis) values.</p>
</td></tr>
<tr><td><code>sig.index</code></td>
<td>
<p>character, indicates the index for null model significance test, RC, Confidence, or SES.</p>
</td></tr>
<tr><td><code>BC.obs</code></td>
<td>
<p>Output only if output.bray is TRUE. A square matrix of observed taxonomic dissimilarity index (default is Bray-Curtis dissimilarity) values.</p>
</td></tr>
<tr><td><code>rand</code></td>
<td>
<p>Output only if detail.null is TRUE. A matrix with all null values of Bray-Curtis index for each turnover.</p>
</td></tr>
</table>


<h3>Note</h3>

<p>Version 1: 2021.8.2
</p>


<h3>Author(s)</h3>

<p>Daliang Ning
</p>


<h3>References</h3>

<p>Ning, D., Yuan, M., Wu, L., Zhang, Y., Guo, X., Zhou, X. et al. (2020). A quantitative framework reveals ecological drivers of grassland microbial community assembly in response to warming. Nature Communications, 11, 4717.
</p>
<p>Chase, J.M., Kraft, N.J.B., Smith, K.G., Vellend, M. &amp; Inouye, B.D. (2011). Using null models to disentangle variation in community dissimilarity from variation in alpha-diversity. Ecosphere, 2, 1-11.
</p>
<p>Stegen, J.C., Lin, X., Fredrickson, J.K., Chen, X., Kennedy, D.W., Murray, C.J. et al. (2013). Quantifying community assembly processes and identifying features that impose them. ISME J, 7, 2069.
</p>
<p>Kraft, N.J.B., Comita, L.S., Chase, J.M., Sanders, N.J., Swenson, N.G., Crist, T.O. et al. (2011). Disentangling the drivers of beta diversity along latitudinal and elevational gradients. Science, 333, 1755-1758.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+RC.pc">RC.pc</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("example.data")
comm=example.data$comm
rand.time=20 # usually use 1000 for real data.

# in this example, 10 samples from one metacommunity,
# the other 10 samples from another metacommunity.
meta.group=data.frame(meta.com=c(rep("meta1",10),rep("meta2",10)))
rownames(meta.group)=rownames(comm)

nworker=2 # parallel computing thread number
RC=RC.cm(comm=comm, rand = rand.time,
         nworker = nworker, meta.group=meta.group,
         weighted = TRUE, sig.index="RC")
</code></pre>

<hr>
<h2 id='RC.pc'>
Modified Raup-Crick index based on Bray-Curtis similarity
</h2><span id='topic+RC.pc'></span>

<h3>Description</h3>

<p>The Raup-Crick based on taxonomic dissimilarity index (i.e. Bray-Curtis) is to use null models to disentangle variation in community dissimilarity from variation in alpha-diversity.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>RC.pc(comm, rand = 1000, na.zero = TRUE, nworker = 4,
      memory.G = 50, weighted = TRUE, unit.sum = NULL,
      meta.ab = NULL,sig.index=c("RC","Confidence","SES"),
      detail.null=FALSE,output.bray=FALSE,silent=FALSE,
      taxo.metric="bray", transform.method=NULL, logbase=2,
      dirichlet=FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="RC.pc_+3A_comm">comm</code></td>
<td>
<p>Community data matrix. rownames are sample names. colnames are species names.</p>
</td></tr>
<tr><td><code id="RC.pc_+3A_rand">rand</code></td>
<td>
<p>integer, randomization times, default is 1000.</p>
</td></tr>
<tr><td><code id="RC.pc_+3A_na.zero">na.zero</code></td>
<td>
<p>logic. If community data marix has any zero-sum row (sample), Bray-Curtis index will be NA. Somtimes, this kind of NA need be set as zero to avoid some format problem in following calculation. Default is TRUE.</p>
</td></tr>
<tr><td><code id="RC.pc_+3A_nworker">nworker</code></td>
<td>
<p>for parallel computing. Either a character vector of host names on which to run the worker copies of R, or a positive integer (in which case that number of copies is run on localhost). default is 4, means 4 threads will be run.</p>
</td></tr>
<tr><td><code id="RC.pc_+3A_memory.g">memory.G</code></td>
<td>
<p>numeric, to set the memory size as you need, so that calculation of big data will not be limited by physical memory. unit is Gb. default is 50Gb.</p>
</td></tr>
<tr><td><code id="RC.pc_+3A_weighted">weighted</code></td>
<td>
<p>lOgic, whether to use abundance-weighted metrics. default is TRUE</p>
</td></tr>
<tr><td><code id="RC.pc_+3A_unit.sum">unit.sum</code></td>
<td>
<p>If unit.sum is set as a number or a numeric vector, the taxa abundances will be divided by unit.sum to calculate the relative abundances, and the Bray-Cuits index in each bin will become manhattan index divided by 2. usually, unit.sum can be set as the sequencing depth in each sample. Default setting is NULL, means not to do this special transformation.</p>
</td></tr>
<tr><td><code id="RC.pc_+3A_meta.ab">meta.ab</code></td>
<td>
<p>a numeric vector, to define the relative aubndance of each species in the regional pool. Default setting is NULL, means to calculate meta.ab as average relative abundance of each species across the samples.</p>
</td></tr>
<tr><td><code id="RC.pc_+3A_sig.index">sig.index</code></td>
<td>
<p>character, the index for null model significance test. RC, modified Raup-Crick index (RC) based on Bray-Curtis (BC), i.e. count the number of null BC lower than observed BC plus a half of the number of null BC equal to observed BC, to get alpha, then calculate RCbray as (2 x alpha - 1). SES, standard effect size; Confidence, percentage of null values less extreme than the observed value, i.e. non-parametric one-side confidence level. default is RC. If input a vector, only the first element will be used.</p>
</td></tr>
<tr><td><code id="RC.pc_+3A_detail.null">detail.null</code></td>
<td>
<p>logic, if TRUE, the output will include all the null values. Default is FALSE.</p>
</td></tr>
<tr><td><code id="RC.pc_+3A_output.bray">output.bray</code></td>
<td>
<p>logic, if TRUE, the output will include observed taxonomic dissimilarity (default is Bray-Curtis).</p>
</td></tr>
<tr><td><code id="RC.pc_+3A_silent">silent</code></td>
<td>
<p>logic, if FALSE, some messages will show during calculation.</p>
</td></tr>
<tr><td><code id="RC.pc_+3A_taxo.metric">taxo.metric</code></td>
<td>
<p>taxonomic beta diversity index, the same as 'method' in the function 'vegdist' in package 'vegan', including &quot;manhattan&quot;, &quot;euclidean&quot;, &quot;canberra&quot;, &quot;clark&quot;, &quot;bray&quot;, &quot;kulczynski&quot;, &quot;jaccard&quot;, &quot;gower&quot;, &quot;altGower&quot;, &quot;morisita&quot;, &quot;horn&quot;, &quot;mountford&quot;, &quot;raup&quot;, &quot;binomial&quot;, &quot;chao&quot;, &quot;cao&quot; or &quot;mahalanobis&quot;. If taxo.metric='bray' and transform.method=NULL, RC will be calculated based on Bray-Curtis dissimilarity as recommended in original iCAMP; otherwise, unit.sum setting will be ignored.</p>
</td></tr>
<tr><td><code id="RC.pc_+3A_transform.method">transform.method</code></td>
<td>
<p>character or a defined function, to specify how to transform community matrix before calculating dissimilarity. if it is a characher, it should be a method name as in the function 'decostand' in package 'vegan', including 'total','max','freq','normalize','range','standardize','pa','chi.square','cmdscale','hellinger','log'.</p>
</td></tr>
<tr><td><code id="RC.pc_+3A_logbase">logbase</code></td>
<td>
<p>numeric, the logarithm base used when transform.method='log'.</p>
</td></tr> 
<tr><td><code id="RC.pc_+3A_dirichlet">dirichlet</code></td>
<td>
<p>Logic. If TRUE, the taxonomic null model will use Dirichlet distribution to generate relative abundances in randomized community matrix. If the input community matrix has all row sums no more than 1, the function will automatically set dirichlet=TRUE. default is FALSE.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The Raup-Crick based on taxonomic dissimilarity index was proposed by Chase in 2011, and then modified to include consider species relative abundances by Stegen in 2013. The non-random part recognized by RC can reflect the influence niche seletion and extreme dispersal. The original codes used a relatively time-consuming looping. This function improved the efficiency and added some parameters to fit iCAMP analysis.
</p>
<p>SES (Kraft et al 2011) and Confidence (Ning et al 2020) are alternative significance testing indexes to evaluate how the observed beta diversity index deviates from null expectation.
</p>


<h3>Value</h3>

<p>Output is a list. 
</p>
<table>
<tr><td><code>index</code></td>
<td>
<p>a square matrix of RC (or SES or Confidence based on Bray-Curtis) values.</p>
</td></tr>
<tr><td><code>sig.index</code></td>
<td>
<p>character, indicates the index for null model significance test, RC, Confidence, or SES.</p>
</td></tr>
<tr><td><code>BC.obs</code></td>
<td>
<p>Output only if output.bray is TRUE. A square matrix of observed taxonomic dissimilarity index (default is Bray-Curtis dissimilarity) values.</p>
</td></tr>
<tr><td><code>rand</code></td>
<td>
<p>Output only if detail.null is TRUE. A matrix with all null values of Bray-Curtis index for each turnover.</p>
</td></tr>
</table>


<h3>Note</h3>

<p>Version 8: 2021.4.18, fix the bug when detail.null=TRUE and comm has only two samples.
Version 7: 2021.4.17, add taxo.metric, transform.method, logbase, and dirichlet, to allow community data transform, dissimilar index other than Bray-Curtis, and relative abundances (values &lt; 1) in the input community matrix.
Version 6: 2020.8.19, update help document, add example.
Version 5: 2020.8.2, add sig.index, detail.null, and output.bray.
Version 4: 2020.6.14, add meta.ab
Version 3: 2018.10.3, add unit.sum.
Version 2: 2015.8.5, revise the randomization algorithm according to Stegen et al 2013.
Version 1: 2015.2.12
</p>


<h3>Author(s)</h3>

<p>Daliang Ning
</p>


<h3>References</h3>

<p>Ning, D., Yuan, M., Wu, L., Zhang, Y., Guo, X., Zhou, X. et al. (2020). A quantitative framework reveals ecological drivers of grassland microbial community assembly in response to warming. Nature Communications, 11, 4717.
</p>
<p>Chase, J.M., Kraft, N.J.B., Smith, K.G., Vellend, M. &amp; Inouye, B.D. (2011). Using null models to disentangle variation in community dissimilarity from variation in alpha-diversity. Ecosphere, 2, 1-11.
</p>
<p>Stegen, J.C., Lin, X., Fredrickson, J.K., Chen, X., Kennedy, D.W., Murray, C.J. et al. (2013). Quantifying community assembly processes and identifying features that impose them. ISME J, 7, 2069.
</p>
<p>Kraft, N.J.B., Comita, L.S., Chase, J.M., Sanders, N.J., Swenson, N.G., Crist, T.O. et al. (2011). Disentangling the drivers of beta diversity along latitudinal and elevational gradients. Science, 333, 1755-1758.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+RC.bin.bigc">RC.bin.bigc</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("example.data")
comm=example.data$comm
rand.time=20 # usually use 1000 for real data.
nworker=2 # parallel computing thread number
RC=RC.pc(comm=comm, rand = rand.time,
         nworker = nworker, weighted = TRUE,
         sig.index="RC")
</code></pre>

<hr>
<h2 id='snm'>
Estimation of neutral taxa percentae and dispersal rate
</h2><span id='topic+snm'></span><span id='topic+snm.boot'></span><span id='topic+snm.comm'></span>

<h3>Description</h3>

<p>To calculate the abundance-weighted or unweighted percentage of taxa following Sloan's neutral theory model. The original R code is from Burns et al (2016). Bootstrapping test and different metacommunity settings are added. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>snm(comm, meta.com = NULL, taxon = NULL,
    alpha = 0.05, simplify = FALSE)
snm.boot(comm, rand=1000, meta.com=NULL,
         taxon=NULL, alpha=0.05, detail=TRUE)
snm.comm(comm, treat=NULL, meta.coms=NULL,
         meta.com=NULL, meta.group=NULL,
         rand=1000,taxon=NULL,alpha=0.05,
         two.tail=TRUE,output.detail=TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="snm_+3A_comm">comm</code></td>
<td>
<p>matrix or data.frame, community data, each row is a sample or site, each colname is a taxon (a species or OTU or ASV), thus rownames should be sample IDs, colnames should be taxa IDs.</p>
</td></tr>
<tr><td><code id="snm_+3A_meta.com">meta.com</code></td>
<td>
<p>matrix or data.frame, metacommunity data, each column represents a taxon, can be one or multiple rows. If NULL, the comm will be used to estimate relative abundance of each taxon in the metacommunity. In function snm.comm, if this is given, meta.group will be ignored.</p>
</td></tr>
<tr><td><code id="snm_+3A_taxon">taxon</code></td>
<td>
<p>matrix or data.frame, classification information of each taxon. Each row represents a taxon. Rownames are taxa IDs.</p>
</td></tr>
<tr><td><code id="snm_+3A_alpha">alpha</code></td>
<td>
<p>numeric, the significance level threshold counted as alpha value, usually 0.05.</p>
</td></tr>
<tr><td><code id="snm_+3A_simplify">simplify</code></td>
<td>
<p>logic, if FALSE, the function snm will performan more model fitting test and return detailed statistical information.</p>
</td></tr>
<tr><td><code id="snm_+3A_rand">rand</code></td>
<td>
<p>integer, randomization times. default is 1000.</p>
</td></tr>
<tr><td><code id="snm_+3A_detail">detail</code></td>
<td>
<p>logic, if TRUE, the detailed output from the function snm will be included into the output of snm.boot.</p>
</td></tr>
<tr><td><code id="snm_+3A_treat">treat</code></td>
<td>
<p>matrix or data.frame, indicating the group or treatment of each sample, rownames are sample IDs. if input multiple columns, they will be analyzed one column after another.</p>
</td></tr>
<tr><td><code id="snm_+3A_meta.coms">meta.coms</code></td>
<td>
<p>a list, to specify the metacommunity data for each level of treatments in each of the columns of 'treat'. A basic element is a matrix, each column represents a taxon, can be one or multiple rows. If this is given, 'meta.group' and 'meta.com' will be ignored.</p>
</td></tr>
<tr><td><code id="snm_+3A_meta.group">meta.group</code></td>
<td>
<p>a matrix, to specify the metacommunity ID that each sample belongs to. It should have the some column number as 'treat' if 'treat' is given. If meta.coms, meta.com, and meta.group are all NULL, the samples are deemed from the same metacommunity.</p>
</td></tr>
<tr><td><code id="snm_+3A_two.tail">two.tail</code></td>
<td>
<p>logic, to specify the p value is calculated as two-tail (TRUE) or one-tail (FALSE).</p>
</td></tr>
<tr><td><code id="snm_+3A_output.detail">output.detail</code></td>
<td>
<p>logic, if TRUE, the output of the function snm.comm will include all bootstrapping values.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The method is developed by Burns et al (2016) based on the Sloan's model (Sloan et al 2006, 2007) which is derived from Hubbell's unified neutral theory (Hubbell 2001). According to neutral theory, the regional relative abundance and occurrence frequency of each taxon should follow a certain model (Sloan et al 2006). Thus, a taxon can be counted as 'neutral taxon' if inside a certain confidence interval of the neutral expectation, and their percentage in a sample may be used to reflect the importance of neutral processes (Burns et al 2016).
</p>


<h3>Value</h3>

<p>Output of snm is a list.
</p>
<table>
<tr><td><code>stats</code></td>
<td>
<p>output only if simplify is FALSE, showing statistics about model fitting and coefficients.
</p>
<p>m, dispersal rate estimated by Non-linear least squares (NLS).
</p>
<p>m.ci.2.5 and m.ci.97.5, the confidence interval of m.
</p>
<p>m.mle, dispersal rate calculated by Maximum likelihood estimation.
</p>
<p>maxLL, binoLL, and poisLL, maximum likelihood function value (L) for neutral theory model, binomial model, and Poisson model, respectively.
</p>
<p>Rsqr, Rsqr.bino, and Rsqr.pois, R squared (coefficient of determination) of neutral theory model, binomial model, and Poisson model, respectively.
</p>
<p>RMSE, RMSE.bino, and RMSE.pois, root-mean-square error.
</p>
<p>AIC, BIC, AIC.bino, BIC.bino, AIC.pois, and BIC.pois, AIC and BIC of different models.
</p>
<p>N, mean individual number in each local community.
</p>
<p>Samples, sample number.
</p>
<p>Richness, total number of taxa.
</p>
<p>Detect, detected limitation of relative abundance in each local community, i.e. 1/N.</p>
</td></tr>
<tr><td><code>detail</code></td>
<td>
<p>output only if simplify is FALSE. a matrix, showing detailed information of each taxon. Each row represent a taxon. Columns as blow.
</p>
<p>p, observed regional relative abundance of each taxon.
</p>
<p>freq, observed occurrence frequency of each taxon.
</p>
<p>freq.pred, occurrence frequency predicted by neutral theory model.
</p>
<p>pred.lwr and pred.upr, the confidence interval of occurrence frequency estimated by neutral theory model.
</p>
<p>bino.pred, bino.lwr, bino.upr, pois.pred, pois.lwr, and bino.upr, the expectation and confidence interval of occurrence frequency estimated by bionomial and Poisson model, respectively.
</p>
<p>type, the taxon is identified as 'Neutral', or 'Below' or 'Above' the confidence interval of neutral expectation.
</p>
</td></tr>
<tr><td><code>type.uw</code></td>
<td>
<p>the percentage (unweighted) of taxa within (Neutral), below, or above the confidence interval of the neutral theory expected frequency (given the regional relative abudance). </p>
</td></tr>
<tr><td><code>type.wt</code></td>
<td>
<p>the abundance weighted percentage (relative abundance sum) of taxa within (Neutral), below, or above the confidence interval of the neutral theory expectation.</p>
</td></tr>
<tr><td><code>sp.names</code></td>
<td>
<p>the taxa IDs for each type.</p>
</td></tr>
</table>
<p>Output of snm.boot is a list.
</p>
<table>
<tr><td><code>stats</code>, <code>detail</code>, <code>type.uw</code>, <code>type.wt</code></td>
<td>
<p>output only if detail is TRUE. the same as output of snm.</p>
</td></tr>
<tr><td><code>summary</code></td>
<td>
<p>a matrix, showing observed values, mean, standard deviation, quartiles, boxplot key points and outliers, for the unweighted and weighted precentage of taxa within (Neutral), below, and above the confidence interval of neutral theory expectation.</p>
</td></tr>
<tr><td><code>rand</code></td>
<td>
<p>a matrix, showing the bootstrapping values of the unweighted and weighted precentage of different types of taxa. Each row represents one time of bootstrapping.</p>
</td></tr>
</table>
<p>Output of snm.comm is a list.
</p>
<table>
<tr><td><code>stats</code></td>
<td>
<p>treat.type, the treatment type, a column name of the input 'treat'. treatment.id, the treatment name. Others are the same as the output 'stats' of snm. The most commonly used information is the dispersal rate values under different treatments, to investigate the effect of treatment on species dispersal.</p>
</td></tr>
<tr><td><code>plot.detail</code></td>
<td>
<p>a matrix, showing the output 'detail' of snm for each treatment. it is ofen used to show the type of each taxon and draw the figure of neutral confidence interval and each taxon.</p>
</td></tr>
<tr><td><code>ratio.summary</code></td>
<td>
<p>a matrix, showing the output 'summary' of snm.boot for each treatment. it is ofen used to draw box plots.</p>
</td></tr>
<tr><td><code>pvalues</code></td>
<td>
<p>a matrix, showing significance of difference between different treatments.</p>
</td></tr>
<tr><td><code>boot.detail</code></td>
<td>
<p>output only if output.detail is TRUE. A matrix, showing the output 'rand' of snm.boot for each treatment.</p>
</td></tr>
</table>


<h3>Note</h3>

<p>Version 3: 2020.8.21, update help document, add example.
</p>
<p>Version 2: 2018.4.16, add meta.group, meta.com, meta.coms, to consider if the samples are from different metacommunities. 
</p>
<p>Version 1: 2017.7.21
</p>


<h3>Author(s)</h3>

<p>Daliang Ning
</p>


<h3>References</h3>

<p>Burns, A.R., Stephens, W.Z., Stagaman, K., Wong, S., Rawls, J.F., Guillemin, K. et al. (2016). Contribution of neutral processes to the assembly of gut microbial communities in the zebrafish over host development. ISME J, 10, 655-664.
</p>
<p>Sloan, W.T., Lunn, M., Woodcock, S., Head, I.M., Nee, S. &amp; Curtis, T.P. (2006). Quantifying the roles of immigration and chance in shaping prokaryote community structure. Environ Microbiol, 8, 732-740.
</p>
<p>Sloan, W.T., Woodcock, S., Lunn, M., Head, I.M. &amp; Curtis, T.P. (2007). Modeling taxa-abundance distributions in microbial communities using environmental sequence data. Microbial Ecology, 53, 443-455.
</p>
<p>Hubbell, S.P. (2001). The unified neutral theory of biodiversity and biogeography. Princeton University Press, Princeton, New Jersey.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("example.data")
comm=example.data$comm
treat=example.data$treat
rand.time=10 # usually use 1000 for real data.
snmtest=snm.comm(comm = comm, treat = treat,
                 rand = rand.time)
</code></pre>

<hr>
<h2 id='taxa.binphy.big'>
Phylogenetic binning based on phylogenetic tree
</h2><span id='topic+taxa.binphy.big'></span>

<h3>Description</h3>

<p>Phylogenetic binning for iCAMP analysis. To handle large phylogenetic tree, phylogenetic distance matrix should be calculated and saved using the package 'bigmemory' in advance. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>taxa.binphy.big(tree, pd.desc, pd.spname, pd.wd,
                outgroup.tip = NA, outgroup.rm = TRUE,
                d.cut=NULL, ds=0.2, bin.size.limit = 24,
                nworker = 4, d.cut.method=c("maxpd","maxdroot"))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="taxa.binphy.big_+3A_tree">tree</code></td>
<td>
<p>phylogenetic tree, an object of class &quot;phylo&quot;.</p>
</td></tr>
<tr><td><code id="taxa.binphy.big_+3A_pd.desc">pd.desc</code></td>
<td>
<p>the name of the file to hold the backingfile description of the phylogenetic distance matrix, it is usually &quot;pd.desc&quot; if using default setting in pdist.big function.</p>
</td></tr>
<tr><td><code id="taxa.binphy.big_+3A_pd.spname">pd.spname</code></td>
<td>
<p>character vector, taxa id in the same rank as the big matrix of phylogenetic distances.</p>
</td></tr>
<tr><td><code id="taxa.binphy.big_+3A_pd.wd">pd.wd</code></td>
<td>
<p>folder path, where the bigmemmory file of the phylogenetic distance matrix are saved.</p>
</td></tr>
<tr><td><code id="taxa.binphy.big_+3A_outgroup.tip">outgroup.tip</code></td>
<td>
<p>a vector of tip names (i.e. OTU IDs) which is in totally different lineage from all other tips, thus can be used as outgroup to root the tree. For example, Archaeal OTUs may be set as outgroup tips when analyzing Bacterial OTUs. Default is NA, means no need to set outgroup tip.</p>
</td></tr>
<tr><td><code id="taxa.binphy.big_+3A_outgroup.rm">outgroup.rm</code></td>
<td>
<p>logic, whether to remove the outgroup.tip after the tree is rooted. Default is TRUE.</p>
</td></tr>
<tr><td><code id="taxa.binphy.big_+3A_d.cut">d.cut</code></td>
<td>
<p>numeric, the distance from root to the truncating point of the tree.</p>
</td></tr>
<tr><td><code id="taxa.binphy.big_+3A_ds">ds</code></td>
<td>
<p>numeric, the general threshold of phylogenetic distance within which the phylogenetic signal is significant. default is 0.2.</p>
</td></tr>
<tr><td><code id="taxa.binphy.big_+3A_bin.size.limit">bin.size.limit</code></td>
<td>
<p>integer, the minimal requirement of bin size (taxa numer in a bin). Default setting is 24.</p>
</td></tr>
<tr><td><code id="taxa.binphy.big_+3A_nworker">nworker</code></td>
<td>
<p>integer, for parallel computing. Either a character vector of host names on which to run the worker copies of R, or a positive integer (in which case that number of copies is run on localhost). default is 4, means 4 threads will be run.</p>
</td></tr>
<tr><td><code id="taxa.binphy.big_+3A_d.cut.method">d.cut.method</code></td>
<td>
<p>character, to specify the method to calculate d.cut from ds. 'maxpd' means based on maximum phylogenetic distance, d.cut = (maxpd - ds)/2. 'maxdroot' means based on maximum distance to root, d.cut = maxdroot - (ds/2), which is preferred if the tree only has one edge from the root.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The phylogenetic tree is truncated at a certain phylogenetic distance (as short as necessary) to the root (d.cut), by which all the rest connections between tips (taxa) are lower than a threshold. Within the threshold, phylogenetic signal is generally significant. The taxa derived from the same ancestor after the truncating point are grouped to the same strict bin. Then, each small bin is merged into the bin with the nearest relatives. This procedure is repeated until all merged bins have enough taxa (&gt;= bin.size.limit). Bigmemory (Kane et al 2013) is used to deal with large datasets.
</p>


<h3>Value</h3>

<p>Output is a list.
</p>
<table>
<tr><td><code>sp.bin</code></td>
<td>
<p>matrix, rownames are taxa IDs; the first column is strict bin IDs; the second column indicates which strict bin the taxon is merged into; the third column is the final bin IDs.</p>
</td></tr>
<tr><td><code>bin.united.sp</code></td>
<td>
<p>list, each element is a vector of taxa IDs, indicating the taxa in a final bin (after small bins are merged into nearest large bins).</p>
</td></tr>
<tr><td><code>bin.strict.sp</code></td>
<td>
<p>list, each element is a vector of taxa ID(s), indicating the taxa in a strict bin (before small bins are merged into large bins).</p>
</td></tr>
<tr><td><code>state.strict</code></td>
<td>
<p>matrix, status of each strict bin. bin.strict.id, the strict bin ID; bin.strict.taxa.num, taxa number in each strict bin; bin.pd.max, bin.pd.mean, and bin.pd.sd, the maximum, mean, and standard deviation of the pairwise phylogenetic distances in each strict bin.</p>
</td></tr>
<tr><td><code>state.united</code></td>
<td>
<p>matrix, status of each final bin. bin.united.id.old, the ID of the largest strict bin in each final bin; bin.united.tax.num, taxa number in each final bin; bin.pd.max, bin.pd.mean, and bin.pd.sd, the maximum, mean, and standard deviation of the pairwise phylogenetic distances in each strict bin.</p>
</td></tr>
</table>


<h3>Note</h3>

<p>Version 4: 2021.6.26, fix a bug which may mess up some large taxa ids.
Version 4: 2021.6.4, add option d.cut.method to handle trees with only one edge from root.
Version 3: 2020.9.1, remove setwd. change dontrun to donttest and revise save.wd in help doc.
Version 2: 2020.8.19, update help document, add example.
Version 1: 2015.12.16
</p>


<h3>Author(s)</h3>

<p>Daliang Ning
</p>


<h3>References</h3>

<p>Ning, D., Yuan, M., Wu, L., Zhang, Y., Guo, X., Zhou, X. et al. (2020). A quantitative framework reveals ecological drivers of grassland microbial community assembly in response to warming. Nature Communications, 11, 4717.
</p>
<p>Kane, M.J., Emerson, J., &amp; Weston, S. (2013). Scalable Strategies for Computing with Massive Data. Journal of Statistical Software, 55(14), 1-19. URL http://www.jstatsoft.org/v55/i14/.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+icamp.big">icamp.big</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("example.data")
comm=example.data$comm
tree=example.data$tree

# since pd.big need to specify a certain folder,
# the following code is set as 'not test'.
# but you may test the code on your computer
# after change the folder path for 'save.wd'.

  wd0=getwd()
  save.wd=paste0(tempdir(),"/pdbig.taxa.binphy")
  # please change to the folder you want to save the big niche difference matrix.
  
  nworker=2 # parallel computing thread number
  pd.big=pdist.big(tree = tree, wd=save.wd, nworker = nworker)
  
  ds = 0.2 # setting can be changed to explore the best choice
  
  bin.size.limit = 5 # setting can be changed to explore the best choice.
  # here set as 5 just for the small example dataset.
  # For real data, usually try 12 to 48.
  
  phylobin=taxa.binphy.big(tree = tree, pd.desc = pd.big$pd.file,
                           pd.spname = pd.big$tip.label, pd.wd = pd.big$pd.wd,
                           ds = ds, bin.size.limit = bin.size.limit,
                           nworker = nworker)
  setwd(wd0)

</code></pre>

<hr>
<h2 id='tree.droot'>
Distance from root to tip(s) and node(s) on phylogenetic tree
</h2><span id='topic+tree.droot'></span>

<h3>Description</h3>

<p>To calculate the distance from root to tip(s) and node(s) on phylogenetic tree
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tree.droot(tree, range = NA, nworker = 4, output.path = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tree.droot_+3A_tree">tree</code></td>
<td>
<p>Phylogenetic tree, an object of class &quot;phylo&quot;.</p>
</td></tr>
<tr><td><code id="tree.droot_+3A_range">range</code></td>
<td>
<p>NA or a vector of integer, to specify the numbering of the tips/nodes of which the distances to root will be calculated. The numbering corresponds to those in the element &quot;edge&quot; of the tree. Default is NA, means to calculate all tips and nodes.</p>
</td></tr>
<tr><td><code id="tree.droot_+3A_nworker">nworker</code></td>
<td>
<p>integer, for parallel computing. Either a character vector of host names on which to run the worker copies of R, or a positive integer (in which case that number of copies is run on localhost). default is 4, means 4 threads will be run.</p>
</td></tr>
<tr><td><code id="tree.droot_+3A_output.path">output.path</code></td>
<td>
<p>logic, this function will call the function tree.path, if output.path is TRUE, the result of tree.path will be included in the output. Default is FALSE.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A tool to get distances to root, used in phylogenetic binning.
</p>


<h3>Value</h3>

<p>If output.path is FALSE, output is a matrix where the first column indicates the numbering of nodes/tips and the second column has the distance to root.
If output.path is TRUE, output is a list with two elements.
</p>
<table>
<tr><td><code>droot</code></td>
<td>
<p>matrix, the first column indicates the numbering of nodes/tips and the second column has the distance to root.</p>
</td></tr>
<tr><td><code>path</code></td>
<td>
<p>result of tree.path, list of nodes and edge lengthes from root to each tip and/or node.</p>
</td></tr>
</table>


<h3>Note</h3>

<p>Version 2: 2020.8.19, add example.
Version 1: 2015.8.19
</p>


<h3>Author(s)</h3>

<p>Daliang Ning
</p>


<h3>See Also</h3>

<p><code><a href="#topic+tree.path">tree.path</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>tree=ape::rtree(4)
nworker=2 # parallel computing thread number
droot=tree.droot(tree = tree, nworker = nworker)
</code></pre>

<hr>
<h2 id='tree.path'>
List nodes and edge lengthes from root to each tip and/or node
</h2><span id='topic+tree.path'></span>

<h3>Description</h3>

<p>To list all the nodes and edge lengthes from root to every tip and/or node.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tree.path(tree, nworker = 4, range = NA, cum = c("no", "from.root", "from.tip", "both"))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tree.path_+3A_tree">tree</code></td>
<td>
<p>Phylogenetic tree, an object of class &quot;phylo&quot;.</p>
</td></tr>
<tr><td><code id="tree.path_+3A_nworker">nworker</code></td>
<td>
<p>for parallel computing. Either a character vector of host names on which to run the worker copies of R, or a positive integer (in which case that number of copies is run on localhost). default is 4.</p>
</td></tr>
<tr><td><code id="tree.path_+3A_range">range</code></td>
<td>
<p>a numeric vector, to specify nodes and/or tips to which the path from root will be calculated. default is NA, means all tips.</p>
</td></tr>
<tr><td><code id="tree.path_+3A_cum">cum</code></td>
<td>
<p>method to calculate cumulative banch length. &quot;no&quot; means not to calculate cumulative lenght; &quot;from.root&quot; means to cumulate from root to tip; &quot;from.tip&quot; means to cumulate from tip to root; &quot;both&quot; means to calculate in both ways and return both results.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function can be useful in phylogenetic diversity analysis, for example, phylogenetic distance, phylogenetic Hill number, phylogenetic binning, etc.
</p>


<h3>Value</h3>

<p>A list result will be returned.
1st layer (the names of the list) is the end of the path, usually the names of tips and/or nodes
In 2nd layer, [[1]] is the orders of nodes between root and the tip/node specified in 1st layer;
[[2]] is the edge lengthes. if cum=&quot;both&quot;, [[3]] is cumulative length from root, and [[4]] is cumulative length from tip, otherwise, [[3]] is the cumulative length specified by cum.
</p>


<h3>Note</h3>

<p>Version 1: 2016.2.14
</p>


<h3>Author(s)</h3>

<p>Daliang Ning
</p>


<h3>See Also</h3>

<p><code><a href="#topic+taxa.binphy.big">taxa.binphy.big</a></code>,<code><a href="#topic+tree.droot">tree.droot</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("example.data")
tree=example.data$tree
nworker=2 # parallel computing thread number
treepath=tree.path(tree=tree, nworker=nworker)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
