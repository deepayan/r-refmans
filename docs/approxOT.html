<!DOCTYPE html><html><head><title>Help for package approxOT</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {approxOT}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#approxOT'><p>An R package to perform exact and approximate optimal transport.</p></a></li>
<li><a href='#as.matrix.transport.plan'><p>Transform transportation plan to transportation matrix</p></a></li>
<li><a href='#as.transport.plan'><p>Transform transportation matrix to transportation plan</p></a></li>
<li><a href='#cost_calc'><p>Calculate cost matrix</p></a></li>
<li><a href='#dist_2d_to_1d'><p>Covert the 2-dimensional index to 1-dimensional index</p></a></li>
<li><a href='#general_1d_transport'><p>One-dimensional optimal transport for measures with more general mass</p></a></li>
<li><a href='#hilbert_proj_'><p>Returns orders along the Hilbert space-filling Curve</p></a></li>
<li><a href='#hilbert.projection'><p>Get order along the Hilbert curve</p></a></li>
<li><a href='#is.transport.plan'><p>Check if function is a transport.plan</p></a></li>
<li><a href='#round_transport_matrix'><p>Round transportation matrix to feasible set</p></a></li>
<li><a href='#sinkhorn_pot'><p>Return the dual potentials for the Sinkhorn distance</p></a></li>
<li><a href='#transport_options'><p>Function returning supported optimal transportation methods.</p></a></li>
<li><a href='#transport_plan'><p>Optimal transport plans</p></a></li>
<li><a href='#transport_plan_given_C'><p>Optimal transport plans given a pre-specified cost</p></a></li>
<li><a href='#transport_plan_multimarg'><p>Multimarginal optimal transport plans</p></a></li>
<li><a href='#wasserstein'><p>Calculate the Wasserstein distance</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Approximate and Exact Optimal Transport Methods</td>
</tr>
<tr>
<td>Version:</td>
<td>1.1.1</td>
</tr>
<tr>
<td>Date:</td>
<td>2024-01-30</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Eric Dunipace &lt;edunipace@mail.harvard.edu&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>R and C++ functions to perform exact and 
  approximate optimal transport. All C++ methods can be linked 
  to other R packages via their header files. </td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL (== 3.0)</a></td>
</tr>
<tr>
<td>Imports:</td>
<td>Rcpp (&ge; 1.0.3), stats</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>Rcpp, RcppEigen, RcppCGAL, BH</td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/ericdunipace/approxOT/issues">https://github.com/ericdunipace/approxOT/issues</a></td>
</tr>
<tr>
<td>Suggests:</td>
<td>testthat (&ge; 2.1.0), transport</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/ericdunipace/approxOT">https://github.com/ericdunipace/approxOT</a></td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-01-30 23:49:03 UTC; eifer</td>
</tr>
<tr>
<td>Author:</td>
<td>Eric Dunipace <a href="https://orcid.org/0000-0001-8909-213X"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cre],
  Andrew Johnson <a href="https://orcid.org/0000-0001-7000-8065"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [ctb],
  Espen Bernton [ctb] ('Hilbert Sort' adapted from their code),
  Mathieu Gerber [ctb] ('Hilbert Sort' adapted from their code),
  Pierre Jacob [ctb] ('Hilbert Sort' adapted from their code),
  Dominic Schuhmacher [ctb] ('Shortsimplex' optimal transport method
    adapted from their code),
  Nicolas Bonneel [ctb] ('network simplex' algorithm adapted from their
    code)</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-01-31 00:00:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='approxOT'>An R package to perform exact and approximate optimal transport.</h2><span id='topic+approxOT'></span><span id='topic+approxOT-package'></span>

<h3>Description</h3>

<p>R and C++ functions to perform exact and approximate optimal transport. All C++ methods are linkable to other R packages via their header files.
</p>


<h3>Author(s)</h3>

<p>Eric Dunipace
</p>


<h3>See Also</h3>

<p>Useful links:
</p>

<ul>
<li> <p><a href="https://github.com/ericdunipace/approxOT">https://github.com/ericdunipace/approxOT</a>
</p>
</li>
<li><p> Report bugs at <a href="https://github.com/ericdunipace/approxOT/issues">https://github.com/ericdunipace/approxOT/issues</a>
</p>
</li></ul>


<hr>
<h2 id='as.matrix.transport.plan'>Transform transportation plan to transportation matrix</h2><span id='topic+as.matrix.transport.plan'></span>

<h3>Description</h3>

<p>Transform transportation plan to transportation matrix
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'transport.plan'
as.matrix(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="as.matrix.transport.plan_+3A_x">x</code></td>
<td>
<p>An object of class 'transport.plan'. See output of (transport_plan)[transport_plan()]</p>
</td></tr>
<tr><td><code id="as.matrix.transport.plan_+3A_...">...</code></td>
<td>
<p>Unused arguments</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix specifying the minimal joint distribution between samples. Margins will be equal to the marginal distributions of the samples
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(203987)
n &lt;- 5
d &lt;- 2
x &lt;- matrix(rnorm(d*n), nrow=d, ncol=n)
y &lt;- matrix(rnorm(d*n), nrow=d, ncol=n)
#get hilbert sort orders for x in backwards way
trans_plan &lt;- transport_plan(X=x, Y=x, ground_p = 2, p = 2, 
                         observation.orientation =  "colwise", 
                         method = "hilbert")
trans_matrix &lt;- as.matrix(trans_plan)
print(trans_matrix)
</code></pre>

<hr>
<h2 id='as.transport.plan'>Transform transportation matrix to transportation plan</h2><span id='topic+as.transport.plan'></span>

<h3>Description</h3>

<p>Transform transportation matrix to transportation plan
</p>


<h3>Usage</h3>

<pre><code class='language-R'>as.transport.plan(transport_matrix, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="as.transport.plan_+3A_transport_matrix">transport_matrix</code></td>
<td>
<p>A matrix that is a transportation matrix, i.e. the minimal joint distribution for two samples.</p>
</td></tr>
<tr><td><code id="as.transport.plan_+3A_...">...</code></td>
<td>
<p>Unused arguments</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class 'transport.plan'. See output of (transport_plan)[transport_plan]
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(203987)
n &lt;- 5
d &lt;- 2
x &lt;- matrix(stats::rnorm(d*n), nrow=d, ncol=n)
y &lt;- matrix(stats::rnorm(d*n), nrow=d, ncol=n)
#get hilbert sort orders for x in backwards way
trans_plan &lt;- transport_plan(X=x, Y=x, ground_p = 2, p = 2, 
                         observation.orientation =  "colwise", 
                         method = "hilbert")
trans_matrix &lt;- as.matrix(trans_plan$tplan)
tplan2 &lt;- as.transport.plan(trans_matrix)
all.equal(tplan2, trans_plan$tplan)
</code></pre>

<hr>
<h2 id='cost_calc'>Calculate cost matrix</h2><span id='topic+cost_calc'></span>

<h3>Description</h3>

<p>Calculate cost matrix
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cost_calc(X, Y, ground_p)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cost_calc_+3A_x">X</code></td>
<td>
<p>matrix of values in first sample. Observations should be by column, not rows.</p>
</td></tr>
<tr><td><code id="cost_calc_+3A_y">Y</code></td>
<td>
<p>matrix of Values in second sample. Observations should be by column, not rows.</p>
</td></tr>
<tr><td><code id="cost_calc_+3A_ground_p">ground_p</code></td>
<td>
<p>power of the Lp norm to use in cost calculation.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>matrix of costs
</p>


<h3>Examples</h3>

<pre><code class='language-R'>X &lt;- matrix(rnorm(10*100), 10, 100)
Y &lt;- matrix(rnorm(10*100), 10, 100)
# the Euclidean distance
cost &lt;- cost_calc(X, Y, ground_p = 2)
</code></pre>

<hr>
<h2 id='dist_2d_to_1d'>Covert the 2-dimensional index to 1-dimensional index</h2><span id='topic+dist_2d_to_1d'></span>

<h3>Description</h3>

<p>Covert the 2-dimensional index to 1-dimensional index
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dist_2d_to_1d(i, j, n, m)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dist_2d_to_1d_+3A_i">i</code></td>
<td>
<p>Index of row</p>
</td></tr>
<tr><td><code id="dist_2d_to_1d_+3A_j">j</code></td>
<td>
<p>Index of column</p>
</td></tr>
<tr><td><code id="dist_2d_to_1d_+3A_n">n</code></td>
<td>
<p>Total number of rows</p>
</td></tr>
<tr><td><code id="dist_2d_to_1d_+3A_m">m</code></td>
<td>
<p>Total number of columns</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a 1d index for easy matrix entry
</p>

<hr>
<h2 id='general_1d_transport'>One-dimensional optimal transport for measures with more general mass</h2><span id='topic+general_1d_transport'></span>

<h3>Description</h3>

<p>One-dimensional optimal transport for measures with more general mass
</p>


<h3>Usage</h3>

<pre><code class='language-R'>general_1d_transport(
  X,
  Y,
  a = NULL,
  b = NULL,
  method = c("hilbert", "univariate")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="general_1d_transport_+3A_x">X</code></td>
<td>
<p>Data for sample one. Should be a vector if method is &quot;univariate&quot; or a matrix if method is &quot;hilbert&quot;</p>
</td></tr>
<tr><td><code id="general_1d_transport_+3A_y">Y</code></td>
<td>
<p>Data for sample two Should be a vector if method is &quot;univariate&quot; or a matrix if method is &quot;hilbert&quot;</p>
</td></tr>
<tr><td><code id="general_1d_transport_+3A_a">a</code></td>
<td>
<p>Empirical measure for sample one.</p>
</td></tr>
<tr><td><code id="general_1d_transport_+3A_b">b</code></td>
<td>
<p>Empirical measure for sample two.</p>
</td></tr>
<tr><td><code id="general_1d_transport_+3A_method">method</code></td>
<td>
<p>One of &quot;hilbert&quot; or &quot;univariate&quot;</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An optimal transportation plan as a list with slots &quot;from&quot;, &quot;to&quot;, and &quot;mass&quot;
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(23423)
n &lt;- 100
d &lt;- 10
x &lt;- matrix(stats::rnorm((n + 11)*d), n + 11 , d)
y &lt;- matrix(stats::rnorm(n*d), n, d)

trans &lt;- general_1d_transport(t(x), t(y))
</code></pre>

<hr>
<h2 id='hilbert_proj_'>Returns orders along the Hilbert space-filling Curve</h2><span id='topic+hilbert_proj_'></span>

<h3>Description</h3>

<p>Returns orders along the Hilbert space-filling Curve
</p>


<h3>Usage</h3>

<pre><code class='language-R'>hilbert_proj_(A)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="hilbert_proj__+3A_a">A</code></td>
<td>
<p>a matrix of data-values of class Eigen::MatrixXd</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An integer vector of orders
</p>

<hr>
<h2 id='hilbert.projection'>Get order along the Hilbert curve</h2><span id='topic+hilbert.projection'></span>

<h3>Description</h3>

<p>Get order along the Hilbert curve
</p>


<h3>Usage</h3>

<pre><code class='language-R'>hilbert.projection(X, Sigma = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="hilbert.projection_+3A_x">X</code></td>
<td>
<p>matrix of values. Observations are unique by rows.</p>
</td></tr>
<tr><td><code id="hilbert.projection_+3A_sigma">Sigma</code></td>
<td>
<p>Covariance of the data. If provided, uses a Mahalanobis distance.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Index of orders
</p>


<h3>Examples</h3>

<pre><code class='language-R'>X &lt;- matrix(rnorm(10*3), 3, 10)
idx &lt;- hilbert.projection(X)
print(idx)
</code></pre>

<hr>
<h2 id='is.transport.plan'>Check if function is a transport.plan</h2><span id='topic+is.transport.plan'></span>

<h3>Description</h3>

<p>Check if function is a transport.plan
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is.transport.plan(tplan)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="is.transport.plan_+3A_tplan">tplan</code></td>
<td>
<p>An object of class 'transport.plan'. See output of (transport_plan)[transport_plan]</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Logical
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(203987)
n &lt;- 5
d &lt;- 2
x &lt;- matrix(rnorm(d*n), nrow=d, ncol=n)
y &lt;- matrix(rnorm(d*n), nrow=d, ncol=n)
#get hilbert sort orders for x in backwards way
trans_plan &lt;- transport_plan(X=x, Y=x, ground_p = 2, p = 2, 
                         observation.orientation =  "colwise", 
                         method = "hilbert")
print(is.transport.plan(trans_plan))
</code></pre>

<hr>
<h2 id='round_transport_matrix'>Round transportation matrix to feasible set</h2><span id='topic+round_transport_matrix'></span>

<h3>Description</h3>

<p>Round transportation matrix to feasible set
</p>


<h3>Usage</h3>

<pre><code class='language-R'>round_transport_matrix(transport_matrix, mass_x, mass_y)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="round_transport_matrix_+3A_transport_matrix">transport_matrix</code></td>
<td>
<p>A transportation matrix returned by an approximate method</p>
</td></tr>
<tr><td><code id="round_transport_matrix_+3A_mass_x">mass_x</code></td>
<td>
<p>The distribution of the first margin</p>
</td></tr>
<tr><td><code id="round_transport_matrix_+3A_mass_y">mass_y</code></td>
<td>
<p>The distribution of the second margin</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a transportation matrix projected to the feasible set.
</p>

<hr>
<h2 id='sinkhorn_pot'>Return the dual potentials for the Sinkhorn distance</h2><span id='topic+sinkhorn_pot'></span>

<h3>Description</h3>

<p>Return the dual potentials for the Sinkhorn distance
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sinkhorn_pot(
  mass_x,
  mass_y,
  p = 2,
  cost = NULL,
  cost_a = NULL,
  cost_b = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sinkhorn_pot_+3A_mass_x">mass_x</code></td>
<td>
<p>The empirical distribution of the first sample</p>
</td></tr>
<tr><td><code id="sinkhorn_pot_+3A_mass_y">mass_y</code></td>
<td>
<p>The empirical distribution of the second sample</p>
</td></tr>
<tr><td><code id="sinkhorn_pot_+3A_p">p</code></td>
<td>
<p>The power to raise the cost by</p>
</td></tr>
<tr><td><code id="sinkhorn_pot_+3A_cost">cost</code></td>
<td>
<p>The cost matrix between first and second samples</p>
</td></tr>
<tr><td><code id="sinkhorn_pot_+3A_cost_a">cost_a</code></td>
<td>
<p>The cost matrix for the first sample</p>
</td></tr>
<tr><td><code id="sinkhorn_pot_+3A_cost_b">cost_b</code></td>
<td>
<p>The cost matrix for the second sample</p>
</td></tr>
<tr><td><code id="sinkhorn_pot_+3A_...">...</code></td>
<td>
<p>Additional arguments including
</p>

<ul>
<li><p> epsilon: The fraction of the median cost to use as a penalty
</p>
</li>
<li><p> niter: Number of iterations to run the Sinkhorn algorithm
</p>
</li>
<li><p> unbiased: Should the potentials be de-biased TRUE/FALSE
</p>
</li></ul>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with slots &quot;f&quot; and &quot;g&quot;, the potentials of the rows and margins, respectively.
</p>

<hr>
<h2 id='transport_options'>Function returning supported optimal transportation methods.</h2><span id='topic+transport_options'></span>

<h3>Description</h3>

<p>Function returning supported optimal transportation methods.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>transport_options()
</code></pre>


<h3>Details</h3>

<p>The currently supported methods are
</p>

<ul>
<li><p> exact, networkflow: Utilize the networkflow algorithm to solve the exact optimal transport problem
</p>
</li>
<li><p> shortsimplex: Use the shortsimplex algorithm to solve the exact optimal transport problem
</p>
</li>
<li><p> sinkhorn: Use Sinkhorn's algorithm to solve the approximate optimal transport problem
</p>
</li>
<li><p> sinkhorn_log: Use Sinkhorn's algorithm on a log-scale for added stability to solve the approximate optimal transport problem
</p>
</li>
<li><p> greenkhorn: Use the Greenkhorn algorithm to solve the approximate optimal transport problem
</p>
</li>
<li><p> hilbert: Use hilbert sorting to perform approximate optimal transport
</p>
</li>
<li><p> rank: use the average covariate ranks to perform approximate optimal transport
</p>
</li>
<li><p> univariate: Use appropriate optimal transport methods for univariate data
</p>
</li>
<li><p> swapping: Utilize the swapping algorithm to perform approximate optimal transport
</p>
</li>
<li><p> sliced: Use the sliced optimal transport distance
</p>
</li></ul>



<h3>Value</h3>

<p>Returns a vector of supported transport methods
</p>

<hr>
<h2 id='transport_plan'>Optimal transport plans</h2><span id='topic+transport_plan'></span>

<h3>Description</h3>

<p>Optimal transport plans
</p>


<h3>Usage</h3>

<pre><code class='language-R'>transport_plan(
  X,
  Y,
  a = NULL,
  b = NULL,
  p = 2,
  ground_p = 2,
  observation.orientation = c("rowwise", "colwise"),
  method = transport_options(),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="transport_plan_+3A_x">X</code></td>
<td>
<p>The covariate data of the first sample.</p>
</td></tr>
<tr><td><code id="transport_plan_+3A_y">Y</code></td>
<td>
<p>The covariate data of the second sample.</p>
</td></tr>
<tr><td><code id="transport_plan_+3A_a">a</code></td>
<td>
<p>Optional. Empirical measure of the first sample</p>
</td></tr>
<tr><td><code id="transport_plan_+3A_b">b</code></td>
<td>
<p>Optional. Empirical measure of the second sample</p>
</td></tr>
<tr><td><code id="transport_plan_+3A_p">p</code></td>
<td>
<p>The power of the Wasserstein distance</p>
</td></tr>
<tr><td><code id="transport_plan_+3A_ground_p">ground_p</code></td>
<td>
<p>The power of the Lp norm</p>
</td></tr>
<tr><td><code id="transport_plan_+3A_observation.orientation">observation.orientation</code></td>
<td>
<p>Are observations by row (&quot;rowwise&quot;) or column (&quot;colwise&quot;).</p>
</td></tr>
<tr><td><code id="transport_plan_+3A_method">method</code></td>
<td>
<p>Which transportation method to use. See [transport_options][transport_options]</p>
</td></tr>
<tr><td><code id="transport_plan_+3A_...">...</code></td>
<td>
<p>Additional arguments for various methods
</p>

<ul>
<li><p>&quot;niter&quot;: The number of iterations to use for the entropically penalized optimal transport distances
</p>
</li>
<li><p>&quot;epsilon&quot;: The multiple of the median cost to use as a penalty in the entropically penalized optimal transport distances
</p>
</li>
<li><p>&quot;unbiased&quot;: If using Sinkhorn distances, should the distance be de-biased? (TRUE/FALSE)
</p>
</li>
<li><p>&quot;nboot&quot;: If using sliced Wasserstein distances, specify the number of Monte Carlo samples
</p>
</li></ul>
</td></tr>
</table>


<h3>Value</h3>

<p>a list with slots &quot;tplan&quot; and &quot;cost&quot;. &quot;tplan&quot; is the optimal transport plan and &quot;cost&quot; is the optimal transport distance.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(203987)
n &lt;- 100
d &lt;- 10
x &lt;- matrix(stats::rnorm(d*n), nrow=d, ncol=n)
y &lt;- matrix(stats::rnorm(d*n), nrow=d, ncol=n)
#get hilbert sort orders for x in backwards way
transx &lt;- transport_plan(X=x, Y=x, ground_p = 2, p = 2, 
                         observation.orientation =  "colwise", 
                         method = "hilbert")
</code></pre>

<hr>
<h2 id='transport_plan_given_C'>Optimal transport plans given a pre-specified cost</h2><span id='topic+transport_plan_given_C'></span>

<h3>Description</h3>

<p>Optimal transport plans given a pre-specified cost
</p>


<h3>Usage</h3>

<pre><code class='language-R'>transport_plan_given_C(
  mass_x,
  mass_y,
  p = 2,
  cost = NULL,
  method = "exact",
  cost_a = NULL,
  cost_b = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="transport_plan_given_C_+3A_mass_x">mass_x</code></td>
<td>
<p>The empirical measure of the first sample</p>
</td></tr>
<tr><td><code id="transport_plan_given_C_+3A_mass_y">mass_y</code></td>
<td>
<p>The empirical measure of the second sample.</p>
</td></tr>
<tr><td><code id="transport_plan_given_C_+3A_p">p</code></td>
<td>
<p>The power of the Wasserstein distance</p>
</td></tr>
<tr><td><code id="transport_plan_given_C_+3A_cost">cost</code></td>
<td>
<p>Specify the cost matrix in advance.</p>
</td></tr>
<tr><td><code id="transport_plan_given_C_+3A_method">method</code></td>
<td>
<p>The transportation method to use, one of &quot;exact&quot;, &quot;networkflow&quot;,&quot;shortsimplex&quot;, &quot;sinkhorn&quot;, &quot;greenkhorn&quot;</p>
</td></tr>
<tr><td><code id="transport_plan_given_C_+3A_cost_a">cost_a</code></td>
<td>
<p>The cost matrix for the first sample with itself. Only used for unbiased Sinkhorn</p>
</td></tr>
<tr><td><code id="transport_plan_given_C_+3A_cost_b">cost_b</code></td>
<td>
<p>The cost matrix for the second sample with itself. Only used for unbiased Sinkhorn</p>
</td></tr>
<tr><td><code id="transport_plan_given_C_+3A_...">...</code></td>
<td>
<p>Additional arguments for various methods
</p>

<ul>
<li><p> &quot;niter&quot;: The number of iterations to use for the entropically penalized optimal transport distances
</p>
</li>
<li><p> &quot;epsilon&quot;: The multiple of the median cost to use as a penalty in the entropically penalized optimal transport distances
</p>
</li>
<li><p>&quot;unbiased&quot;: If using Sinkhorn distances, should the distance be de-biased? (TRUE/FALSE)
</p>
</li></ul>
</td></tr>
</table>


<h3>Value</h3>

<p>A transportation plan as an object of class &quot;transport.plan&quot;, which is a list with slots &quot;from&quot;,&quot;to&quot;, and &quot;mass&quot;.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>n &lt;- 32
d &lt;- 5
set.seed(293897)
A &lt;- matrix(stats::rnorm(n*d),nrow=d,ncol=n)
B &lt;- matrix(stats::rnorm(n*d),nrow=d,ncol=n)
transp.meth &lt;- "sinkhorn"
niter &lt;- 1e2
test &lt;- transport_plan_given_C(rep(1/n,n), 
rep(1/n,n),  2, cost = cost_calc(A,B,2), 
"sinkhorn", niter = niter)
</code></pre>

<hr>
<h2 id='transport_plan_multimarg'>Multimarginal optimal transport plans</h2><span id='topic+transport_plan_multimarg'></span>

<h3>Description</h3>

<p>Multimarginal optimal transport plans
</p>


<h3>Usage</h3>

<pre><code class='language-R'>transport_plan_multimarg(
  ...,
  p = 2,
  ground_p = 2,
  observation.orientation = c("rowwise", "colwise"),
  method = c("hilbert", "univariate", "sliced"),
  nsim = 1000
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="transport_plan_multimarg_+3A_...">...</code></td>
<td>
<p>Either data matrices as separate arguments or a list of data matrices. Arguments after the data must be specified by name.</p>
</td></tr>
<tr><td><code id="transport_plan_multimarg_+3A_p">p</code></td>
<td>
<p>The power of the Wasserstein distance to use</p>
</td></tr>
<tr><td><code id="transport_plan_multimarg_+3A_ground_p">ground_p</code></td>
<td>
<p>The power of the Euclidean distance to use</p>
</td></tr>
<tr><td><code id="transport_plan_multimarg_+3A_observation.orientation">observation.orientation</code></td>
<td>
<p>Are observations by rows or columns</p>
</td></tr>
<tr><td><code id="transport_plan_multimarg_+3A_method">method</code></td>
<td>
<p>One of &quot;hilbert&quot;, &quot;univariate&quot;, or &quot;sliced&quot;</p>
</td></tr>
<tr><td><code id="transport_plan_multimarg_+3A_nsim">nsim</code></td>
<td>
<p>Number of simulations to use for the sliced method</p>
</td></tr>
</table>


<h3>Value</h3>

<p>transport plan
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(23423)
n &lt;- 100
d &lt;- 10
p &lt;- ground_p &lt;- 2 #euclidean cost, p = 2
x &lt;- matrix(stats::rnorm((n + 11)*d), n + 11 , d)
y &lt;- matrix(stats::rnorm(n*d), n, d)
z &lt;- matrix(stats::rnorm((n +455)*d), n +455, d)

# make data a list
data &lt;- list(x,y,z)

tplan &lt;- transport_plan_multimarg(data, p = p, ground_p = ground_p,
observation.orientation = "rowwise", method = "hilbert")

#' #transpose data works too
datat &lt;- lapply(data, t)

tplan2 &lt;- transport_plan_multimarg(datat, p = p, ground_p = ground_p,
observation.orientation = "colwise",method = "hilbert")
</code></pre>

<hr>
<h2 id='wasserstein'>Calculate the Wasserstein distance</h2><span id='topic+wasserstein'></span>

<h3>Description</h3>

<p>Calculate the Wasserstein distance
</p>


<h3>Usage</h3>

<pre><code class='language-R'>wasserstein(
  X = NULL,
  Y = NULL,
  a = NULL,
  b = NULL,
  cost = NULL,
  tplan = NULL,
  p = 2,
  ground_p = 2,
  method = transport_options(),
  cost_a = NULL,
  cost_b = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="wasserstein_+3A_x">X</code></td>
<td>
<p>The covariate data of the first sample.</p>
</td></tr>
<tr><td><code id="wasserstein_+3A_y">Y</code></td>
<td>
<p>The covariate data of the second sample.</p>
</td></tr>
<tr><td><code id="wasserstein_+3A_a">a</code></td>
<td>
<p>Optional. Empirical measure of the first sample</p>
</td></tr>
<tr><td><code id="wasserstein_+3A_b">b</code></td>
<td>
<p>Optional. Empirical measure of the second sample</p>
</td></tr>
<tr><td><code id="wasserstein_+3A_cost">cost</code></td>
<td>
<p>Specify the cost matrix in advance.</p>
</td></tr>
<tr><td><code id="wasserstein_+3A_tplan">tplan</code></td>
<td>
<p>Give a transportation plan with slots &quot;from&quot;, &quot;to&quot;, and &quot;mass&quot;, like that returned by the [tranportation_plan()] function.</p>
</td></tr>
<tr><td><code id="wasserstein_+3A_p">p</code></td>
<td>
<p>The power of the Wasserstein distance</p>
</td></tr>
<tr><td><code id="wasserstein_+3A_ground_p">ground_p</code></td>
<td>
<p>The power of the Lp norm</p>
</td></tr>
<tr><td><code id="wasserstein_+3A_method">method</code></td>
<td>
<p>Which transportation method to use. See [transport_options()]</p>
</td></tr>
<tr><td><code id="wasserstein_+3A_cost_a">cost_a</code></td>
<td>
<p>The cost matrix for the first sample with itself. Only used for unbiased Sinkhorn</p>
</td></tr>
<tr><td><code id="wasserstein_+3A_cost_b">cost_b</code></td>
<td>
<p>The cost matrix for the second sample with itself. Only used for unbiased Sinkhorn</p>
</td></tr>
<tr><td><code id="wasserstein_+3A_...">...</code></td>
<td>
<p>Additional arguments for various methods:
</p>

<ul>
<li><p>&quot;niter&quot;: The number of iterations to use for the entropically penalized optimal transport distances
</p>
</li>
<li><p>&quot;epsilon&quot;: The multiple of the median cost to use as a penalty in the entropically penalized optimal transport distances
</p>
</li>
<li><p>&quot;unbiased&quot;: If using Sinkhorn distances, should the distance be de-biased? (TRUE/FALSE)
</p>
</li>
<li><p>&quot;nboot&quot;: If using sliced Wasserstein distances, specify the number of Monte Carlo samples
</p>
</li></ul>
</td></tr>
</table>


<h3>Value</h3>

<p>The p-Wasserstein distance, a numeric value
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(11289374)
n &lt;- 100
z &lt;- stats::rnorm(n)
w &lt;- stats::rnorm(n)
uni &lt;- approxOT::wasserstein(X = z, Y = w, 
p = 2, ground_p = 2, 
observation.orientation = "colwise", 
method = "univariate")
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
