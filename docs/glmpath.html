<!DOCTYPE html><html lang="en"><head><title>Help for package glmpath</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {glmpath}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#bootstrap.path'>
<p>Generates a set of bootstrap coefficients for glmpath or coxpath</p></a></li>
<li><a href='#coxpath'>
<p>Fits the entire L1 regularization path for Cox proportional hazards</p>
model</a></li>
<li><a href='#cv.coxpath'>
<p>Computes cross-validated (minus) log-partial-likelihoods for coxpath</p></a></li>
<li><a href='#cv.glmpath'>
<p>Computes cross-validated (minus) log-likelihoods or prediction errors</p>
for glmpath</a></li>
<li><a href='#glmpath'>
<p>Fits the entire L1 regularization path for generalized linear models</p></a></li>
<li><a href='#glmpath-internal'>
<p>Internal glmpath functions</p></a></li>
<li><a href='#heart.data'><p>Dataset for glmpath</p></a></li>
<li><a href='#lung.data'><p>Dataset for coxpath</p></a></li>
<li><a href='#plot.bootpath'>
<p>Generates the histograms or the pairwise scatter plots of the</p>
bootstrap coefficients computed from bootstrap.path</a></li>
<li><a href='#plot.coxpath'>
<p>Plots the regularization path computed from coxpath</p></a></li>
<li><a href='#plot.glmpath'>
<p>Plots the regularization path computed from glmpath</p></a></li>
<li><a href='#predict.coxpath'>
<p>Makes predictions at particular points along the fitted coxpath</p></a></li>
<li><a href='#predict.glmpath'>
<p>Makes predictions at particular points along the fitted glmpath</p></a></li>
<li><a href='#summary.coxpath'>
<p>Produces an anova-type summary for a coxpath object</p></a></li>
<li><a href='#summary.glmpath'>
<p>Produces an anova-type summary for a glmpath object</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Version:</td>
<td>0.98</td>
</tr>
<tr>
<td>Date:</td>
<td>2018-01-27</td>
</tr>
<tr>
<td>Title:</td>
<td>L1 Regularization Path for Generalized Linear Models and Cox
Proportional Hazards Model</td>
</tr>
<tr>
<td>Author:</td>
<td>Mee Young Park, Trevor Hastie</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Mee Young Park &lt;meeyoung@google.com&gt;</td>
</tr>
<tr>
<td>Depends:</td>
<td>survival, R (&ge; 2.0)</td>
</tr>
<tr>
<td>Description:</td>
<td>A path-following algorithm for L1 regularized generalized linear models and Cox proportional hazards model.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2018-01-28 00:56:02 UTC; meeyoung</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2018-01-28 16:09:29 UTC</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
</table>
<hr>
<h2 id='bootstrap.path'>
Generates a set of bootstrap coefficients for glmpath or coxpath
</h2><span id='topic+bootstrap.path'></span>

<h3>Description</h3>

<p>This function generates a set of bootstrap coefficients for
<code>glmpath</code> or <code>coxpath.</code> For each bootstrap run, the
regularization parameter may be determined based on either <code>aic</code>
or <code>bic.</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  bootstrap.path(x, y, data, B, index = NULL,
                 path = c("glmpath", "coxpath"),
                 method = c("aic", "bic"), trace = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="bootstrap.path_+3A_x">x</code></td>
<td>

<p>matrix of features
</p>
</td></tr>
<tr><td><code id="bootstrap.path_+3A_y">y</code></td>
<td>

<p>response
</p>
</td></tr>
<tr><td><code id="bootstrap.path_+3A_data">data</code></td>
<td>

<p>a list of data components. If <code>path=glmpath,</code> <code>data</code>
consists of <code>x:</code> a matrix of features and <code>y:</code>
response. <code>data</code> is not needed if <code>x</code> and <code>y</code> are
input separately. If <code>path=coxpath,</code> <code>data</code> must be
provided, including <code>x:</code> a matrix of features, <code>time:</code> the
survival time, and <code>status:</code> censor status with 1 if died and 0
if censored.
</p>
</td></tr>
<tr><td><code id="bootstrap.path_+3A_b">B</code></td>
<td>

<p>number of bootstrap runs
</p>
</td></tr>
<tr><td><code id="bootstrap.path_+3A_index">index</code></td>
<td>

<p>matrix (<code>B</code> rows, <code>ncol(x)</code> columns) of bootstrap sample
indices. Each row is a vector of indices for a bootstrap run. If
<code>index=NULL,</code> the indices are randomly chosen.
</p>
</td></tr>
<tr><td><code id="bootstrap.path_+3A_path">path</code></td>
<td>

<p>Bootstrap coefficients for either <code>glmpath</code> or <code>coxpath</code>
are computed. Default is <code>path=glmpath.</code>
</p>
</td></tr>
<tr><td><code id="bootstrap.path_+3A_method">method</code></td>
<td>

<p>For each bootstrap run, the regularization parameter is determined
based on either <code>aic</code> or <code>bic.</code> Default is <code>aic.</code>
</p>
</td></tr>
<tr><td><code id="bootstrap.path_+3A_trace">trace</code></td>
<td>

<p>If <code>TRUE,</code> the number of bootstrap runs is printed out.
</p>
</td></tr>
<tr><td><code id="bootstrap.path_+3A_...">...</code></td>
<td>

<p>other options for <code>glmpath</code> or <code>coxpath</code>
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Fitting <code>glmpath</code> or <code>coxpath</code> gives a series of solution
sets with a varying size of the active set. Once we select an
appropriate value of the regularization parameter, and thus a set of
coefficients, we may then validate the chosen coefficients through
bootstrap analysis. <code>plot.bootstrap</code> summarizes the bootstrap
results by generating the histograms or the pair scatter plots of the
bootstrap coefficients.
</p>


<h3>Value</h3>

<p><code>bootstrap.path</code> returns a <code>bootpath</code> object, which is a
matrix (<code>B</code> by <code>ncol(x)</code>) of bootstrap
coefficients. Coefficients computed from the whole data are stored as
an attribute <code>coefficients.</code>
</p>


<h3>Author(s)</h3>

<p>Mee Young Park and Trevor Hastie</p>


<h3>References</h3>

<p>Bradley Efron and Robert Tibshirani (1993) <em>An Introduction to
the Bootstrap</em> CHAPMAN &amp; HALL/CRC, Boca Raton.
</p>
<p>Mee Young Park and Trevor Hastie (2007) L1 regularization path
algorithm for generalized linear models. <em>J. R. Statist. Soc.</em> B,
69, 659-677.
</p>


<h3>See Also</h3>

<p>coxpath, glmpath, plot.bootstrap
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(heart.data)
attach(heart.data)
bootstrap.a &lt;- bootstrap.path(x, y, B=5, method="bic")
detach(heart.data)
data(lung.data)
attach(lung.data)
bootstrap.b &lt;- bootstrap.path(data=lung.data, B=5, path="coxpath")
detach(lung.data)
</code></pre>

<hr>
<h2 id='coxpath'>
Fits the entire L1 regularization path for Cox proportional hazards
model
</h2><span id='topic+coxpath'></span>

<h3>Description</h3>

<p>This algorithm uses predictor-corrector method to compute the
entire regularization path for Cox proportional hazards model with L1
penalty.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  coxpath(data, nopenalty.subset = NULL, method = c("breslow", "efron"),
          lambda2 = 1e-5, max.steps = 10 * min(n, m), max.norm = 100 * m,
          min.lambda = (if (m &gt;= n) 1e-3 else 0), max.vars = Inf,
          max.arclength = Inf, frac.arclength = 1, add.newvars = 1,
          bshoot.threshold = 0.1, relax.lambda = 1e-7,
          approx.Gram = FALSE, standardize = TRUE,
          eps = .Machine$double.eps, trace = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="coxpath_+3A_data">data</code></td>
<td>

<p>a list consisting of <code>x:</code> a matrix of features, <code>time:</code>
the survival time, and <code>status:</code> censor status with 1 if died
and 0 if censored. 
</p>
</td></tr>
<tr><td><code id="coxpath_+3A_nopenalty.subset">nopenalty.subset</code></td>
<td>

<p>a set of indices for the predictors that are not subject to the L1
penalty
</p>
</td></tr>
<tr><td><code id="coxpath_+3A_method">method</code></td>
<td>

<p>approximation method for tied survival times. Approximations derived
by Breslow (1974) and Efron (1977) are available. Default is
<code>breslow.</code>
</p>
</td></tr>
<tr><td><code id="coxpath_+3A_lambda2">lambda2</code></td>
<td>

<p>regularization parameter for the L2 norm of the
coefficients. Default is <code>1e-5.</code>
</p>
</td></tr>
<tr><td><code id="coxpath_+3A_max.steps">max.steps</code></td>
<td>

<p>an optional bound for the number of steps to be taken. Default is
<code>10 * min{nrow(x), ncol(x)}.</code>
</p>
</td></tr>
<tr><td><code id="coxpath_+3A_max.norm">max.norm</code></td>
<td>

<p>an optional bound for the L1 norm of the coefficients. Default is
<code>100 * ncol(x).</code>
</p>
</td></tr>
<tr><td><code id="coxpath_+3A_min.lambda">min.lambda</code></td>
<td>

<p>an optional (lower) bound for the size of <code class="reqn">\lambda</code>. When
<code>ncol(x)</code> is relatively large, the coefficient estimates are
prone to numerical precision errors at extremely small
<code class="reqn">\lambda</code>. In such cases, early stopping is recommended. Default
is <code>0</code> for <code>ncol(x) &lt; nrow(x)</code> cases and <code>1e-3</code>
otherwise.
</p>
</td></tr>
<tr><td><code id="coxpath_+3A_max.vars">max.vars</code></td>
<td>

<p>an optional bound for the number of active variables. Default is
<code>Inf.</code>
</p>
</td></tr>
<tr><td><code id="coxpath_+3A_max.arclength">max.arclength</code></td>
<td>

<p>an optional bound for arc length (L1 norm) of a step. If
<code>max.arclength</code> is extremely small, an exact nonlinear path is
produced. Default is <code>Inf.</code>
</p>
</td></tr>
<tr><td><code id="coxpath_+3A_frac.arclength">frac.arclength</code></td>
<td>

<p>Under the default setting, the next step size is computed so that
the active set changes right at the next value of lambda. When
<code>frac.arclength</code> is assigned some fraction between 0 and 1, the
step size is decreased by the factor of <code>frac.arclength</code> in arc
length. If <code>frac.arclength=0.2,</code> the step length is adjusted so
that the active set would change after five smaller steps. Either
<code>max.arclength</code> or <code>frac.arclength</code> can be used to force
the path to be more accurate. Default is <code>1.</code>
</p>
</td></tr>
<tr><td><code id="coxpath_+3A_add.newvars">add.newvars</code></td>
<td>

<p><code>add.newvars</code> candidate variables (that are currently not in
the active set) are used in the corrector step as potential active
variables. Default is <code>1.</code>
</p>
</td></tr>
<tr><td><code id="coxpath_+3A_bshoot.threshold">bshoot.threshold</code></td>
<td>

<p>If the absolute value of a coefficient is larger than
<code>bshoot.threshold</code> at the first corrector step it becomes
nonzero (therefore when <code class="reqn">\lambda</code> is considered to have been
decreased too far), <code class="reqn">\lambda</code> is increased again. i.e. A
backward distance in <code class="reqn">\lambda</code> that makes the coefficient zero
is computed. Default is <code>0.1.</code>
</p>
</td></tr>
<tr><td><code id="coxpath_+3A_relax.lambda">relax.lambda</code></td>
<td>

<p>A variable joins the active set if <code class="reqn">|l'(\beta)| &gt;
      \lambda</code>*(1-<code>relax.lambda</code>). Default is <code>1e-7.</code> If no
variable joins the active set even after many (&gt;20) steps, the user
should increase <code>relax.lambda</code> to <code>1e-6</code> or <code>1e-5,</code>
but not more than that. This adjustment is sometimes needed because
of the numerical precision/error propagation problems. In general,
the paths are less accurate with relaxed lambda.     
</p>
</td></tr>
<tr><td><code id="coxpath_+3A_approx.gram">approx.Gram</code></td>
<td>

<p>If <code>TRUE,</code> an approximated Gram matrix is used in predictor
steps; each step takes less number of computations, but the total
number of steps usually increases. This might be useful when the
number of features is large.    
</p>
</td></tr>
<tr><td><code id="coxpath_+3A_standardize">standardize</code></td>
<td>

<p>If <code>TRUE,</code> predictors are standardized to have a unit variance.
</p>
</td></tr>
<tr><td><code id="coxpath_+3A_eps">eps</code></td>
<td>

<p>an effective zero
</p>
</td></tr>
<tr><td><code id="coxpath_+3A_trace">trace</code></td>
<td>

<p>If <code>TRUE,</code> the algorithm prints out its progress.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This algorithm implements the predictor-corrector method to determine
the entire path of the coefficient estimates as the amount of
regularization varies; it computes a series of solution sets,
each time estimating the coefficients with less regularization, based
on the previous estimate. The coefficients are estimated with
no error at the knots, and the values are connected, thereby making
the paths piecewise linear.
</p>


<h3>Value</h3>

<p>A <code>coxpath</code> object is returned.
</p>
<table role = "presentation">
<tr><td><code>lambda</code></td>
<td>

<p>vector of <code class="reqn">\lambda</code> values for which the exact coefficients are
computed
</p>
</td></tr>
<tr><td><code>lambda2</code></td>
<td>

<p><code class="reqn">\lambda_2</code> used
</p>
</td></tr>
<tr><td><code>step.length</code></td>
<td>

<p>vector of step lengths in <code class="reqn">\lambda</code>
</p>
</td></tr>
<tr><td><code>corr</code></td>
<td>

<p>matrix of <code class="reqn">l'(\beta)</code> values (derivatives of the
log-partial-likelihood)
</p>
</td></tr>
<tr><td><code>new.df</code></td>
<td>

<p>vector of degrees of freedom (to be used in the plot function)
</p>
</td></tr>
<tr><td><code>df</code></td>
<td>

<p>vector of degrees of freedom at each step
</p>
</td></tr>
<tr><td><code>loglik</code></td>
<td>

<p>vector of log-partial-likelihood computed at each step
</p>
</td></tr>
<tr><td><code>aic</code></td>
<td>

<p>vector of AIC values 
</p>
</td></tr>
<tr><td><code>bic</code></td>
<td>

<p>vector of BIC values 
</p>
</td></tr>
<tr><td><code>b.predictor</code></td>
<td>

<p>matrix of coefficient estimates from the predictor steps
</p>
</td></tr>
<tr><td><code>b.corrector</code></td>
<td>

<p>matrix of coefficient estimates from the corrector steps
</p>
</td></tr>
<tr><td><code>new.A</code></td>
<td>

<p>vector of boolean values indicating the steps at which the active
set changed (to be used in the plot/predict functions)
</p>
</td></tr>
<tr><td><code>actions</code></td>
<td>

<p>actions taken at each step
</p>
</td></tr>
<tr><td><code>meanx</code></td>
<td>

<p>means of the columns of x
</p>
</td></tr>
<tr><td><code>sdx</code></td>
<td>

<p>standard deviations of the columns of x
</p>
</td></tr>
<tr><td><code>xnames</code></td>
<td>

<p>column names of x
</p>
</td></tr>
<tr><td><code>method</code></td>
<td>

<p>method used
</p>
</td></tr>
<tr><td><code>nopenalty.subset</code></td>
<td>

<p>nopenalty.subset used
</p>
</td></tr>
<tr><td><code>standardize</code></td>
<td>

<p><code>TRUE</code> if the predictors were standardized before fitting
</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Mee Young Park and Trevor Hastie</p>


<h3>References</h3>

<p>Mee Young Park and Trevor Hastie (2007) L1 regularization path
algorithm for generalized linear models. <em>J. R. Statist. Soc.</em> B,
69, 659-677.
</p>


<h3>See Also</h3>

<p>cv.coxpath, plot.coxpath, predict.coxpath, summary.coxpath
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(lung.data)
attach(lung.data)
fit.a &lt;- coxpath(lung.data)
fit.b &lt;- coxpath(lung.data, method="efron")
detach(lung.data)
</code></pre>

<hr>
<h2 id='cv.coxpath'>
Computes cross-validated (minus) log-partial-likelihoods for coxpath
</h2><span id='topic+cv.coxpath'></span>

<h3>Description</h3>

  
<p>This function computes cross-validated (minus) log-partial-likelihoods
for <code>coxpath.</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  cv.coxpath(data, method = c("breslow", "efron"), nfold = 5,
             fraction = seq(0, 1, length = 100),
             mode = c("norm", "lambda"), plot.it = TRUE, se = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="cv.coxpath_+3A_data">data</code></td>
<td>

<p>a list consisting of <code>x:</code> a matrix of features, <code>time:</code>
the survival time, and <code>status:</code> censor status with 1 if died
and 0 if censored. 
</p>
</td></tr>
<tr><td><code id="cv.coxpath_+3A_method">method</code></td>
<td>

<p>approximation method for tied survival times. Approximations derived
by Breslow (1974) and Efron (1977) are available. Default is
<code>breslow.</code>
</p>
</td></tr>
<tr><td><code id="cv.coxpath_+3A_nfold">nfold</code></td>
<td>

<p>number of folds to be used in cross-validation. Default is
<code>nfold=5.</code>
</p>
</td></tr>
<tr><td><code id="cv.coxpath_+3A_fraction">fraction</code></td>
<td>

<p>the fraction of L1 norm or log(<code class="reqn">\lambda</code>) with respect to their
maximum values at which the CV errors are computed. Default is
<code>seq(0,1,length=100).</code>
</p>
</td></tr>
<tr><td><code id="cv.coxpath_+3A_mode">mode</code></td>
<td>

<p>If <code>mode=norm,</code> cross-validation is run at certain values of
L1 norm. If <code>mode=lambda,</code> cross-validation is run at certain
values of log(<code class="reqn">\lambda</code>). Default is <code>norm.</code>
</p>
</td></tr>
<tr><td><code id="cv.coxpath_+3A_plot.it">plot.it</code></td>
<td>

<p>If <code>TRUE,</code> CV curve is plotted.
</p>
</td></tr>
<tr><td><code id="cv.coxpath_+3A_se">se</code></td>
<td>

<p>If <code>TRUE,</code> standard errors are plotted.
</p>
</td></tr>
<tr><td><code id="cv.coxpath_+3A_...">...</code></td>
<td>

<p>other options for coxpath
</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Mee Young Park and Trevor Hastie</p>


<h3>References</h3>

<p>Mee Young Park and Trevor Hastie (2007) L1 regularization path
algorithm for generalized linear models. <em>J. R. Statist. Soc.</em> B,
69, 659-677.
</p>


<h3>See Also</h3>

<p>coxpath, plot.coxpath, predict.coxpath
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(lung.data)
attach(lung.data)
cv &lt;- cv.coxpath(lung.data)
detach(lung.data)
</code></pre>

<hr>
<h2 id='cv.glmpath'>
Computes cross-validated (minus) log-likelihoods or prediction errors
for glmpath
</h2><span id='topic+cv.glmpath'></span>

<h3>Description</h3>

  
<p>This function computes cross-validated (minus) log-likelihoods or
prediction errors for <code>glmpath.</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  cv.glmpath(x, y, data, family = binomial, weight = rep(1, n),
             offset = rep(0, n), nfold = 10,
             fraction = seq(0, 1, length = 100),
             type = c("loglik", "response"), mode = c("norm", "lambda"),
             plot.it = TRUE, se = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="cv.glmpath_+3A_x">x</code></td>
<td>

<p>matrix of features
</p>
</td></tr>
<tr><td><code id="cv.glmpath_+3A_y">y</code></td>
<td>

<p>response
</p>
</td></tr>
<tr><td><code id="cv.glmpath_+3A_data">data</code></td>
<td>

<p>a list consisting of <code>x:</code> a matrix of features and <code>y:</code>
response. <code>data</code> is not needed if above <code>x</code> and <code>y</code>
are input separately.
</p>
</td></tr>
<tr><td><code id="cv.glmpath_+3A_family">family</code></td>
<td>

<p>name of a family function that represents the distribution of y to
be used in the model. It must be <code>binomial</code>, <code>gaussian</code>,
or <code>poisson</code>. For each one, the canonical link function is
used; <code>logit</code> for binomial, <code>identity</code> for gaussian, and
<code>log</code> for poisson distribution. Default is <code>binomial.</code>
</p>
</td></tr>
<tr><td><code id="cv.glmpath_+3A_weight">weight</code></td>
<td>

<p>an optional vector of weights for observations
</p>
</td></tr>
<tr><td><code id="cv.glmpath_+3A_offset">offset</code></td>
<td>

<p>an optional vector of offset. If a column of <code>x</code> is used as
offset, the corresponding column must be excluded from <code>x.</code>
</p>
</td></tr>
<tr><td><code id="cv.glmpath_+3A_nfold">nfold</code></td>
<td>

<p>number of folds to be used in cross-validation. Default is
<code>nfold=10.</code>
</p>
</td></tr>
<tr><td><code id="cv.glmpath_+3A_fraction">fraction</code></td>
<td>

<p>the fraction of L1 norm or log(<code class="reqn">\lambda</code>) with respect to their
maximum values at which the CV errors are computed. Default is
<code>seq(0,1,length=100).</code>
</p>
</td></tr>
<tr><td><code id="cv.glmpath_+3A_type">type</code></td>
<td>

<p>If <code>type=loglik,</code> cross-validated minus log-likelihoods are
computed. If <code>type=response,</code> cross-validated prediction errors
are computed. Default is <code>loglik.</code>
</p>
</td></tr>
<tr><td><code id="cv.glmpath_+3A_mode">mode</code></td>
<td>

<p>If <code>mode=norm,</code> cross-validation is run at certain values of
L1 norm. If <code>mode=lambda,</code> cross-validation is run at certain
values of log(<code class="reqn">\lambda</code>). Default is <code>norm.</code>
</p>
</td></tr>
<tr><td><code id="cv.glmpath_+3A_plot.it">plot.it</code></td>
<td>

<p>If <code>TRUE,</code> CV curve is plotted.
</p>
</td></tr>
<tr><td><code id="cv.glmpath_+3A_se">se</code></td>
<td>

<p>If <code>TRUE,</code> standard errors are plotted.
</p>
</td></tr>
<tr><td><code id="cv.glmpath_+3A_...">...</code></td>
<td>

<p>other options for glmpath
</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Mee Young Park and Trevor Hastie</p>


<h3>References</h3>

<p>Mee Young Park and Trevor Hastie (2007) L1 regularization path
algorithm for generalized linear models. <em>J. R. Statist. Soc.</em> B,
69, 659-677.
</p>


<h3>See Also</h3>

<p>glmpath, plot.glmpath, predict.glmpath
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(heart.data)
attach(heart.data)
cv.a &lt;- cv.glmpath(x, y, family=binomial)
cv.b &lt;- cv.glmpath(x, y, family=binomial, type="response")
detach(heart.data)
</code></pre>

<hr>
<h2 id='glmpath'>
Fits the entire L1 regularization path for generalized linear models
</h2><span id='topic+glmpath'></span>

<h3>Description</h3>

<p>This algorithm uses predictor-corrector method to compute the
entire regularization path for generalized linear models with L1
penalty.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  glmpath(x, y, data, nopenalty.subset = NULL, family = binomial,
          weight = rep(1, n), offset = rep(0, n), lambda2 = 1e-5,
          max.steps = 10 * min(n, m), max.norm = 100 * m,
          min.lambda = (if (m &gt;= n) 1e-6 else 0), max.vars = Inf,
          max.arclength = Inf, frac.arclength = 1, add.newvars = 1,
          bshoot.threshold = 0.1, relax.lambda = 1e-8,
          standardize = TRUE, eps = .Machine$double.eps,
          trace = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="glmpath_+3A_x">x</code></td>
<td>

<p>matrix of features
</p>
</td></tr>
<tr><td><code id="glmpath_+3A_y">y</code></td>
<td>

<p>response 
</p>
</td></tr>
<tr><td><code id="glmpath_+3A_data">data</code></td>
<td>

<p>a list consisting of <code>x:</code> a matrix of features and <code>y:</code>
response. <code>data</code> is not needed if <code>x</code> and <code>y</code> are
input separately.
</p>
</td></tr>
<tr><td><code id="glmpath_+3A_nopenalty.subset">nopenalty.subset</code></td>
<td>

<p>a set of indices for the predictors that are not subject to the L1
penalty
</p>
</td></tr>
<tr><td><code id="glmpath_+3A_family">family</code></td>
<td>

<p>name of a family function that represents the distribution of y to
be used in the model. It must be <code>binomial</code>, <code>gaussian</code>,
or <code>poisson</code>. For each one, the canonical link function is
used; <code>logit</code> for binomial, <code>identity</code> for gaussian, and
<code>log</code> for poisson distribution. Default is <code>binomial.</code>
</p>
</td></tr>
<tr><td><code id="glmpath_+3A_weight">weight</code></td>
<td>

<p>an optional vector of weights for observations
</p>
</td></tr>
<tr><td><code id="glmpath_+3A_offset">offset</code></td>
<td>

<p>an optional vector of offset. If a column of <code>x</code> is used as
offset, the corresponding column must be removed from <code>x.</code>
</p>
</td></tr>
<tr><td><code id="glmpath_+3A_lambda2">lambda2</code></td>
<td>

<p>regularization parameter for the L2 norm of the
coefficients. Default is <code>1e-5.</code>
</p>
</td></tr>
<tr><td><code id="glmpath_+3A_max.steps">max.steps</code></td>
<td>

<p>an optional bound for the number of steps to be taken. Default is
<code>10 * min{nrow(x), ncol(x)}.</code>
</p>
</td></tr>
<tr><td><code id="glmpath_+3A_max.norm">max.norm</code></td>
<td>

<p>an optional bound for the L1 norm of the coefficients. Default is
<code>100 * ncol(x).</code>
</p>
</td></tr>
<tr><td><code id="glmpath_+3A_min.lambda">min.lambda</code></td>
<td>

<p>an optional (lower) bound for the size of <code class="reqn">\lambda</code>. Default is
<code>0</code> for <code>ncol(x) &lt; nrow(x)</code> cases and <code>1e-6</code>
otherwise.    
</p>
</td></tr>
<tr><td><code id="glmpath_+3A_max.vars">max.vars</code></td>
<td>

<p>an optional bound for the number of active variables. Default is
<code>Inf.</code>
</p>
</td></tr>
<tr><td><code id="glmpath_+3A_max.arclength">max.arclength</code></td>
<td>

<p>an optional bound for arc length (L1 norm) of a step. If
<code>max.arclength</code> is extremely small, an exact nonlinear path is
produced. Default is <code>Inf.</code>
</p>
</td></tr>
<tr><td><code id="glmpath_+3A_frac.arclength">frac.arclength</code></td>
<td>

<p>Under the default setting, the next step size is computed so that
the active set changes right at the next value of lambda. When
<code>frac.arclength</code> is assigned some fraction between 0 and 1, the
step size is decreased by the factor of <code>frac.arclength</code> in arc
length. If <code>frac.arclength=0.2,</code> the step length is adjusted so
that the active set would change after five smaller steps. Either
<code>max.arclength</code> or <code>frac.arclength</code> can be used to force
the path to be more accurate. Default is <code>1.</code>
</p>
</td></tr>
<tr><td><code id="glmpath_+3A_add.newvars">add.newvars</code></td>
<td>

<p><code>add.newvars</code> candidate variables (that are currently not in
the active set) are used in the corrector step as potential active
variables. Default is <code>1.</code>
</p>
</td></tr>
<tr><td><code id="glmpath_+3A_bshoot.threshold">bshoot.threshold</code></td>
<td>

<p>If the absolute value of a coefficient is larger than
<code>bshoot.threshold</code> at the first corrector step it becomes
nonzero (therefore when <code class="reqn">\lambda</code> is considered to have been
decreased too far), <code class="reqn">\lambda</code> is increased again. i.e. A
backward distance in <code class="reqn">\lambda</code> that makes the coefficient zero
is computed. Default is <code>0.1.</code>
</p>
</td></tr>
<tr><td><code id="glmpath_+3A_relax.lambda">relax.lambda</code></td>
<td>

<p>A variable joins the active set if <code class="reqn">|l'(\beta)| &gt;
      \lambda</code>*(1-<code>relax.lambda</code>). Default is <code>1e-8.</code> If no
variable joins the active set even after many (&gt;20) steps, the user
should increase <code>relax.lambda</code> to <code>1e-7</code> or <code>1e-6,</code>
but not more than that. This adjustment is sometimes needed because
of the numerical precision/error propagation problems. In general,
the paths are less accurate with relaxed lambda.     
</p>
</td></tr>
<tr><td><code id="glmpath_+3A_standardize">standardize</code></td>
<td>

<p>If <code>TRUE,</code> predictors are standardized to have a unit variance.
</p>
</td></tr>
<tr><td><code id="glmpath_+3A_eps">eps</code></td>
<td>

<p>an effective zero
</p>
</td></tr>
<tr><td><code id="glmpath_+3A_trace">trace</code></td>
<td>

<p>If <code>TRUE,</code> the algorithm prints out its progress.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This algorithm implements the predictor-corrector method to determine
the entire path of the coefficient estimates as the amount of
regularization varies; it computes a series of solution sets,
each time estimating the coefficients with less regularization, based
on the previous estimate. The coefficients are estimated with
no error at the knots, and the values are connected, thereby making
the paths piecewise linear.
</p>


<h3>Value</h3>

<p>A <code>glmpath</code> object is returned.
</p>
<table role = "presentation">
<tr><td><code>lambda</code></td>
<td>

<p>vector of <code class="reqn">\lambda</code> values for which the exact coefficients are
computed
</p>
</td></tr>
<tr><td><code>lambda2</code></td>
<td>

<p><code class="reqn">\lambda_2</code> used
</p>
</td></tr>
<tr><td><code>step.length</code></td>
<td>

<p>vector of step lengths in <code class="reqn">\lambda</code>
</p>
</td></tr>
<tr><td><code>corr</code></td>
<td>

<p>matrix of <code class="reqn">l'(\beta)</code> values (derivatives of the log-likelihood)
</p>
</td></tr>
<tr><td><code>new.df</code></td>
<td>

<p>vector of degrees of freedom (to be used in the plot function)
</p>
</td></tr>
<tr><td><code>df</code></td>
<td>

<p>vector of degrees of freedom at each step
</p>
</td></tr>
<tr><td><code>deviance</code></td>
<td>

<p>vector of deviance computed at each step
</p>
</td></tr>
<tr><td><code>aic</code></td>
<td>

<p>vector of AIC values 
</p>
</td></tr>
<tr><td><code>bic</code></td>
<td>

<p>vector of BIC values 
</p>
</td></tr>
<tr><td><code>b.predictor</code></td>
<td>

<p>matrix of coefficient estimates from the predictor steps
</p>
</td></tr>
<tr><td><code>b.corrector</code></td>
<td>

<p>matrix of coefficient estimates from the corrector steps
</p>
</td></tr>
<tr><td><code>new.A</code></td>
<td>

<p>vector of boolean values indicating the steps at which the active
set changed (to be used in the plot/predict functions)
</p>
</td></tr>
<tr><td><code>actions</code></td>
<td>

<p>actions taken at each step
</p>
</td></tr>
<tr><td><code>meanx</code></td>
<td>

<p>means of the columns of x
</p>
</td></tr>
<tr><td><code>sdx</code></td>
<td>

<p>standard deviations of the columns of x
</p>
</td></tr>
<tr><td><code>xnames</code></td>
<td>

<p>column names of x
</p>
</td></tr>
<tr><td><code>family</code></td>
<td>

<p>family used
</p>
</td></tr>
<tr><td><code>weight</code></td>
<td>

<p>weights used
</p>
</td></tr>
<tr><td><code>offset</code></td>
<td>

<p>offset used
</p>
</td></tr>
<tr><td><code>nopenalty.subset</code></td>
<td>

<p>nopenalty.subset used
</p>
</td></tr>
<tr><td><code>standardize</code></td>
<td>

<p><code>TRUE</code> if the predictors were standardized before fitting
</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Mee Young Park and Trevor Hastie</p>


<h3>References</h3>

<p>Mee Young Park and Trevor Hastie (2007) L1 regularization path
algorithm for generalized linear models. <em>J. R. Statist. Soc.</em> B,
69, 659-677.
</p>


<h3>See Also</h3>

<p>cv.glmpath, plot.glmpath, predict.glmpath, summary.glmpath
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(heart.data)
attach(heart.data)
fit.a &lt;- glmpath(x, y, family=binomial)
fit.b &lt;- glmpath(x, y, family=gaussian)
detach(heart.data)
</code></pre>

<hr>
<h2 id='glmpath-internal'>
Internal glmpath functions
</h2><span id='topic+corrector1'></span><span id='topic+corrector.cox'></span><span id='topic+logplik'></span><span id='topic+predictor1'></span><span id='topic+predictor.cox'></span><span id='topic+print.coxpath'></span><span id='topic+print.glmpath'></span><span id='topic+step.length'></span><span id='topic+step.length.cox'></span>

<h3>Description</h3>

<p>Internal glmpath functions
</p>


<h3>Usage</h3>

<pre><code class='language-R'>corrector1(x, y, family, weight, offset, active, tmpa, force.active,
  lambda, lambda2, b0, bshoot.threshold, relax.lambda, trace,
  no.iter = FALSE, eps = .Machine$double.eps)
corrector.cox(x, d, rslist, wlist, rept, method, active, tmpa,
  force.active, lambda, lambda2, b0, bshoot.threshold, relax.lambda,
  trace, eps = .Machine$double.eps)
logplik(x, time, status, b, method = c("breslow", "efron"),
  return.all = FALSE)
predictor1(b, step)
predictor.cox(b, step)
## S3 method for class 'coxpath'
print(x, ...)
## S3 method for class 'glmpath'
print(x, ...)
step.length(corrector, lambda2, min.lambda, max.arclength,
  frac.arclength, add.newvars, backshoot, h0 = NULL,
  eps = .Machine$double.eps)
step.length.cox(corrector, lambda2, x, d, rslist, wlist, min.lambda,
  max.arclength, frac.arclength, add.newvars, backshoot, approx.Gram,
  h0 = NULL, eps = .Machine$double.eps)
</code></pre>


<h3>Author(s)</h3>

<p>Mee Young Park and Trevor Hastie</p>


<h3>References</h3>

<p>Mee Young Park and Trevor Hastie (2007) L1 regularization path
algorithm for generalized linear models. <em>J. R. Statist. Soc.</em> B,
69, 659-677.
</p>

<hr>
<h2 id='heart.data'>Dataset for glmpath</h2><span id='topic+heart.data'></span>

<h3>Description</h3>

<p><em>South African Heart Disease dataset</em> used to test <code>glmpath</code>
algorithm
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(heart.data)
</code></pre>


<h3>Format</h3>

<p>A dataset with 462 observations on 9 variables and a binary
response.
</p>

<dl>
<dt>x</dt><dd><p>x contains 9 columns of the following variables:
sbp (systolic blood pressure); tobacco (cumulative tobacco); ldl
(low density lipoprotein cholesterol); adiposity; famhist (family
history of heart disease); typea (type-A behavior); obesity;
alcohol (current alcohol consumption); age (age at onset)</p>
</dd>
<dt>y</dt><dd><p>response, coronary heart disease</p>
</dd>
</dl>



<h3>References</h3>

<p>Hastie, T., Tibshirani, R., and Friedman, J. (2001)
<em>Elements of Statistical Learning; Data Mining, Inference, and
Prediction</em> Springer-Verlag, New York.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(heart.data)
attach(heart.data)
fit &lt;- glmpath(x, y, family=binomial)
detach(heart.data)
</code></pre>

<hr>
<h2 id='lung.data'>Dataset for coxpath</h2><span id='topic+lung.data'></span>

<h3>Description</h3>

<p><em>Lung cancer dataset</em> used to test <code>coxpath</code> algorithm
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(lung.data)
</code></pre>


<h3>Format</h3>

<p>A dataset consisting of 137 observations with their survival time,
censor status as well as 6 features. 
</p>

<dl>
<dt>x</dt><dd><p>x contains 6 columns of the following variables: trt
(1=standard treatment, and 2=test); celltype (1=squamous,
2=smallcell, 3=adeno, and 4=large); karno (Karnofsky performance
score); diagtime (months from diagnosis to randomization); age (in
years); prior (prior therapy 0=no, and 1=yes)</p>
</dd>
<dt>time</dt><dd><p>survival time</p>
</dd>
<dt>status</dt><dd><p>censor status</p>
</dd>
</dl>



<h3>References</h3>

<p>Kalbfleisch, J. and Prentice, R. (2002) <em>The Statistical Analysis
of Failure Time Data</em> J. Wiley, Hoboken, N.J.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(lung.data)
attach(lung.data)
fit &lt;- coxpath(lung.data)
detach(lung.data)
</code></pre>

<hr>
<h2 id='plot.bootpath'>
Generates the histograms or the pairwise scatter plots of the
bootstrap coefficients computed from bootstrap.path
</h2><span id='topic+plot.bootpath'></span>

<h3>Description</h3>

<p>This function takes a <code>bootpath</code> object from
<code>bootstrap.path</code> and generates the histograms or the pairwise
scatter plots of the bootstrap coefficients.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  ## S3 method for class 'bootpath'
plot(x, type = c("histogram", "pairplot"),
     mfrow = NULL, mar = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot.bootpath_+3A_x">x</code></td>
<td>

<p>a <code>bootpath</code> object from <code>bootstrap.path.</code>
</p>
</td></tr>
<tr><td><code id="plot.bootpath_+3A_type">type</code></td>
<td>

<p>If <code>type=histogram,</code> the histograms of bootstrap coefficients
for individual features are generated. The red vertical bar
indicates the coefficient computed using the whole data. The thick
bar at zero indicates the frequency of the zero coefficients. If
<code>type=pairplot,</code> the pairwise scatter plots of the bootstrap
coefficients are generated. The red solid dot indicates the pair of
coefficients computed using the whole data. Default is
<code>histogram.</code>
</p>
</td></tr>
<tr><td><code id="plot.bootpath_+3A_mfrow">mfrow</code></td>
<td>

<p>determines the numbers of rows and columns of the histograms on a
page. 2 rows are generated as a default.
</p>
</td></tr>
<tr><td><code id="plot.bootpath_+3A_mar">mar</code></td>
<td>

<p>margin relative to the current font size
</p>
</td></tr>
<tr><td><code id="plot.bootpath_+3A_...">...</code></td>
<td>

<p>other options for the plot
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Fitting <code>glmpath</code> or <code>coxpath</code> gives a series of solution
sets with a varying size of the active set. Once we select an
appropriate value of the regularization parameter, and, thus a set of
coefficients, we may then validate the chosen coefficients through a
bootstrap analysis. <code>plot.bootstrap</code> summarizes the bootstrap
results by generating the histograms or the pairwise scatter plots of
the bootstrap coefficients.
</p>


<h3>Author(s)</h3>

<p>Mee Young Park and Trevor Hastie</p>


<h3>References</h3>

<p>Bradley Efron and Robert Tibshirani (1993) <em>An Introduction to
the Bootstrap</em> CHAPMAN &amp; HALL/CRC, Boca Raton.
</p>
<p>Mee Young Park and Trevor Hastie (2007) L1 regularization path
algorithm for generalized linear models. <em>J. R. Statist. Soc.</em> B,
69, 659-677.
</p>


<h3>See Also</h3>

<p>bootstrap.path, coxpath, glmpath
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(heart.data)
attach(heart.data)
bootstrap.a &lt;- bootstrap.path(x, y, B=5)
plot(bootstrap.a)
plot(bootstrap.a, type="pairplot")
detach(heart.data)
</code></pre>

<hr>
<h2 id='plot.coxpath'>
Plots the regularization path computed from coxpath
</h2><span id='topic+plot.coxpath'></span>

<h3>Description</h3>

<p>This function takes a <code>coxpath</code> object and visualizes the
regularization path. The horizontal axis can be <code>norm,</code>
<code>lambda</code> or <code>step.</code> The vertical axis can be
<code>coefficients,</code> <code>aic</code> or <code>bic.</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  ## S3 method for class 'coxpath'
plot(x, xvar = c("norm", "lambda", "step"),
     type = c("coefficients", "aic", "bic"),
     plot.all.steps = FALSE, xlimit = NULL, predictor = FALSE,
     omit.zero = TRUE, breaks = TRUE, mar = NULL, main = NULL,
     eps = .Machine$double.eps, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot.coxpath_+3A_x">x</code></td>
<td>

<p>a <code>coxpath</code> object
</p>
</td></tr>
<tr><td><code id="plot.coxpath_+3A_xvar">xvar</code></td>
<td>

<p>horizontal axis. <code>xvar=norm</code> plots against the L1 norm of the
coefficients (to which L1 norm penalty was applied);
<code>xvar=lambda</code> plots against <code class="reqn">\lambda</code>; and <code>xvar=step</code>
plots against the number of steps taken. Default is <code>norm.</code>
</p>
</td></tr>
<tr><td><code id="plot.coxpath_+3A_type">type</code></td>
<td>

<p>type of the plot, or the vertical axis. Default is
<code>coefficients.</code>
</p>
</td></tr>
<tr><td><code id="plot.coxpath_+3A_plot.all.steps">plot.all.steps</code></td>
<td>

<p>If <code>TRUE,</code> all the steps taken along the path are marked on the
plot. If <code>FALSE,</code> which is the default, only the steps at which
the active set changed are shown on the plot.
</p>
</td></tr>
<tr><td><code id="plot.coxpath_+3A_xlimit">xlimit</code></td>
<td>

<p>When the user wants to visualize a (beginning) sub-part of the plot,
<code>xlimit</code> sets an upper limit to the L1 norm or the number of
steps, or a lower limit to <code class="reqn">\lambda</code>.
</p>
</td></tr>
<tr><td><code id="plot.coxpath_+3A_predictor">predictor</code></td>
<td>

<p>If <code>TRUE</code> and <code>type=coefficients,</code> the predictor step
estimates are connected with dotted lines. If <code>FALSE,</code> only the
corrector step estimates are connected with solid lines.
</p>
</td></tr>
<tr><td><code id="plot.coxpath_+3A_omit.zero">omit.zero</code></td>
<td>

<p>If <code>TRUE,</code> the predictors that were never in the active set are
omitted.
</p>
</td></tr>
<tr><td><code id="plot.coxpath_+3A_breaks">breaks</code></td>
<td>

<p>If <code>TRUE,</code> vertical lines are drawn at the points where the
active set changes and numbered with the degrees of freedom.
</p>
</td></tr>
<tr><td><code id="plot.coxpath_+3A_mar">mar</code></td>
<td>

<p>margin relative to the current font size
</p>
</td></tr>
<tr><td><code id="plot.coxpath_+3A_main">main</code></td>
<td>

<p>title of the plot
</p>
</td></tr>
<tr><td><code id="plot.coxpath_+3A_eps">eps</code></td>
<td>

<p>an effective zero
</p>
</td></tr>
<tr><td><code id="plot.coxpath_+3A_...">...</code></td>
<td>

<p>other options for the plot
</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Mee Young Park and Trevor Hastie</p>


<h3>References</h3>

<p>Mee Young Park and Trevor Hastie (2007) L1 regularization path
algorithm for generalized linear models. <em>J. R. Statist. Soc.</em> B,
69, 659-677.
</p>


<h3>See Also</h3>

<p>cv.coxpath, coxpath, predict.coxpath
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(lung.data)
attach(lung.data)
fit &lt;- coxpath(lung.data)
par(mfrow=c(3, 2))
plot(fit)
plot(fit, xvar="lambda")
plot(fit, xvar="step")
plot(fit, xvar="step", xlimit=8)
plot(fit, type="aic")
plot(fit, type="bic")
detach(lung.data)
</code></pre>

<hr>
<h2 id='plot.glmpath'>
Plots the regularization path computed from glmpath
</h2><span id='topic+plot.glmpath'></span>

<h3>Description</h3>

<p>This function takes a <code>glmpath</code> object and visualizes the
regularization path. The horizontal axis can be <code>norm,</code>
<code>lambda</code> or <code>step.</code> The vertical axis can be
<code>coefficients,</code> <code>aic</code> or <code>bic.</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  ## S3 method for class 'glmpath'
plot(x, xvar = c("norm", "lambda", "step"),
     type = c("coefficients", "aic", "bic"),
     plot.all.steps = FALSE, xlimit = NULL, predictor = FALSE,
     omit.zero = TRUE, breaks = TRUE, mar = NULL,
     eps = .Machine$double.eps, main = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot.glmpath_+3A_x">x</code></td>
<td>

<p>a <code>glmpath</code> object
</p>
</td></tr>
<tr><td><code id="plot.glmpath_+3A_xvar">xvar</code></td>
<td>

<p>horizontal axis. <code>xvar=norm</code> plots against the L1 norm of the
coefficients (to which L1 norm penalty was applied);
<code>xvar=lambda</code> plots against <code class="reqn">\lambda</code>; and <code>xvar=step</code>
plots against the number of steps taken. Default is <code>norm.</code>
</p>
</td></tr>
<tr><td><code id="plot.glmpath_+3A_type">type</code></td>
<td>

<p>type of the plot, or the vertical axis. Default is
<code>coefficients.</code>
</p>
</td></tr>
<tr><td><code id="plot.glmpath_+3A_plot.all.steps">plot.all.steps</code></td>
<td>

<p>If <code>TRUE,</code> all the steps taken along the path are marked on the
plot. If <code>FALSE,</code> which is the default, only the steps at which
the active set changed are shown on the plot.
</p>
</td></tr>
<tr><td><code id="plot.glmpath_+3A_xlimit">xlimit</code></td>
<td>

<p>When the user wants to visualize a (beginning) sub-part of the plot,
<code>xlimit</code> sets an upper limit to the L1 norm or the number of
steps, or a lower limit to <code class="reqn">\lambda</code>.
</p>
</td></tr>
<tr><td><code id="plot.glmpath_+3A_predictor">predictor</code></td>
<td>

<p>If <code>TRUE</code> and <code>type=coefficients,</code> the predictor step
estimates are connected with dotted lines. If <code>FALSE,</code> only the
corrector step estimates are connected with solid lines.
</p>
</td></tr>
<tr><td><code id="plot.glmpath_+3A_omit.zero">omit.zero</code></td>
<td>

<p>If <code>TRUE</code> and <code>type=coefficients,</code> the predictors that
were never in the active set are omitted.
</p>
</td></tr>
<tr><td><code id="plot.glmpath_+3A_breaks">breaks</code></td>
<td>

<p>If <code>TRUE,</code> vertical lines are drawn at the points where the
active set changes and numbered with the degrees of freedom.
</p>
</td></tr>
<tr><td><code id="plot.glmpath_+3A_mar">mar</code></td>
<td>

<p>margin relative to the current font size
</p>
</td></tr>
<tr><td><code id="plot.glmpath_+3A_eps">eps</code></td>
<td>

<p>an effective zero
</p>
</td></tr>
<tr><td><code id="plot.glmpath_+3A_main">main</code></td>
<td>

<p>title of the plot
</p>
</td></tr>
<tr><td><code id="plot.glmpath_+3A_...">...</code></td>
<td>

<p>other options for the plot
</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Mee Young Park and Trevor Hastie</p>


<h3>References</h3>

<p>Mee Young Park and Trevor Hastie (2007) L1 regularization path
algorithm for generalized linear models. <em>J. R. Statist. Soc.</em> B,
69, 659-677.
</p>


<h3>See Also</h3>

<p>cv.glmpath, glmpath, predict.glmpath
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(heart.data)
attach(heart.data)
fit &lt;- glmpath(x, y, family=binomial)
par(mfrow=c(3, 2))
plot(fit)
plot(fit, xvar="lambda")
plot(fit, xvar="step")
plot(fit, xvar="step", xlimit=8)
plot(fit, type="aic")
plot(fit, type="bic")
detach(heart.data)
</code></pre>

<hr>
<h2 id='predict.coxpath'>
Makes predictions at particular points along the fitted coxpath
</h2><span id='topic+predict.coxpath'></span>

<h3>Description</h3>

<p>This function makes predictions at particular points along the fitted
<code>coxpath.</code> The coefficients, log-partial-likelihood, linear
predictor or the risk can be computed. A <code>coxph</code> object can be
returned at one particular value of <code class="reqn">\lambda.</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  ## S3 method for class 'coxpath'
predict(object, data, s, type = c("coefficients", "loglik",
        "lp", "risk", "coxph"), mode = c("step",
        "norm.fraction", "norm", "lambda.fraction", "lambda"),
        eps = .Machine$double.eps, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="predict.coxpath_+3A_object">object</code></td>
<td>

<p>a <code>coxpath</code> object
</p>
</td></tr>
<tr><td><code id="predict.coxpath_+3A_data">data</code></td>
<td>

<p>a list containing <code>x,</code> <code>time,</code> and <code>status,</code> with
which the predictions are made. If <code>type=lp</code> or
<code>type=risk,</code> then <code>x</code> is required. If <code>type=loglik</code>
or <code>type=coxph,</code> then <code>x,</code> <code>time,</code> and <code>status</code>
are required.
</p>
</td></tr>
<tr><td><code id="predict.coxpath_+3A_s">s</code></td>
<td>

<p>the values of <code>mode</code> at which the predictions are made. If
<code>type=coxph,</code> only the first element of <code>s</code> is used. If
<code>s</code> is missing, then the steps at which the active set changed
are used, and thus, <code>mode</code> is automatically switched to
<code>step.</code>
</p>
</td></tr>
<tr><td><code id="predict.coxpath_+3A_type">type</code></td>
<td>

<p>If <code>type=coefficients,</code> the coefficients are returned; if
<code>type=loglik,</code> log-partial-likelihoods are returned; if
<code>type=lp,</code> linear predictors (<code class="reqn">x'\beta</code>) are returned; if
<code>type=risk,</code> risks (<code class="reqn">e^{x'\beta}</code>) are returned; and if
<code>type=coxph,</code> a <code>coxph</code> object (as in <span class="pkg">survival</span>
package) at the first element of <code>s</code> is returned. (i.e. the
components of a <code>coxph</code> object such as coefficients, variance,
and the test statistics are adjusted to the shrinkage corresponding
to <code>s.</code> A <code>coxph</code> object can be further used as an
argument to the functions in <span class="pkg">survival</span> package.) Default is
<code>coefficients.</code> The coefficients for the initial input
variables are returned (rather than the standardized coefficients).
</p>
</td></tr>
<tr><td><code id="predict.coxpath_+3A_mode">mode</code></td>
<td>

<p>what <code>mode=s</code> refers to. If <code>mode=step,</code> <code>s</code> is the
number of steps taken; if <code>mode=norm.fraction,</code> <code>s</code> is the
fraction of the L1 norm of the standardized coefficients (with
respect to the largest norm); if <code>mode=norm,</code> <code>s</code> is the
L1 norm of the standardized coefficients; if
<code>mode=lambda.fraction,</code> <code>s</code> is the fraction of
log(<code class="reqn">\lambda</code>); and if <code>mode=lambda,</code> <code>s</code> is
<code class="reqn">\lambda</code>. Default is <code>step.</code>
</p>
</td></tr>
<tr><td><code id="predict.coxpath_+3A_eps">eps</code></td>
<td>

<p>an effective zero
</p>
</td></tr>
<tr><td><code id="predict.coxpath_+3A_...">...</code></td>
<td>

<p>other options for the prediction
</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Mee Young Park and Trevor Hastie</p>


<h3>References</h3>

<p>Mee Young Park and Trevor Hastie (2007) L1 regularization path
algorithm for generalized linear models. <em>J. R. Statist. Soc.</em> B,
69, 659-677.
</p>


<h3>See Also</h3>

<p>cv.coxpath, coxpath, plot.coxpath
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(lung.data)
attach(lung.data)
fit &lt;- coxpath(lung.data)
pred.a &lt;- predict(fit, x, s = seq(0, 1, length=10),
                  mode = "norm.fraction")
library(survival)
pred.b &lt;- predict(fit, lung.data, s = 0.5, type = "coxph",
                  mode = "lambda.fraction")
pred.s &lt;- survfit(pred.b)
plot(pred.s)
detach(lung.data)
</code></pre>

<hr>
<h2 id='predict.glmpath'>
Makes predictions at particular points along the fitted glmpath
</h2><span id='topic+predict.glmpath'></span>

<h3>Description</h3>

<p>This function makes predictions at particular points along the fitted
<code>glmpath.</code> The linear predictor, estimated response,
log-likelihood, or the coefficients can be computed.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  ## S3 method for class 'glmpath'
predict(object, newx, newy, s, type = c("link", "response",
        "loglik", "coefficients"), mode = c("step",
        "norm.fraction", "norm", "lambda.fraction", "lambda"),
        weight = NULL, offset = NULL,
        eps = .Machine$double.eps, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="predict.glmpath_+3A_object">object</code></td>
<td>

<p>a <code>glmpath</code> object
</p>
</td></tr>
<tr><td><code id="predict.glmpath_+3A_newx">newx</code></td>
<td>

<p>a matrix of features at which the predictions are made. If
<code>type=link,</code> <code>type=response,</code> or <code>type=loglik,</code>
<code>newx</code> is required.
</p>
</td></tr>
<tr><td><code id="predict.glmpath_+3A_newy">newy</code></td>
<td>

<p>a vector of responses corresponding to <code>newx.</code> If
<code>type=loglik,</code> <code>newy</code> is required.
</p>
</td></tr>
<tr><td><code id="predict.glmpath_+3A_s">s</code></td>
<td>

<p>the values of <code>mode</code> at which the predictions are made. If
<code>s</code> is missing, then the steps at which the active set changed
are used, and thus, <code>mode</code> is automatically switched to
<code>step.</code>
</p>
</td></tr>
<tr><td><code id="predict.glmpath_+3A_type">type</code></td>
<td>

<p>If <code>type=link,</code> the linear predictors are returned; if
<code>type=response,</code> the estimated responses are returned; if
<code>type=loglik,</code> the log-likelihoods are returned, and if
<code>type=coefficients,</code> the coefficients are returned. The
coefficients for the initial input variables are returned (rather
than the standardized coefficients). Default is <code>link.</code>
</p>
</td></tr>
<tr><td><code id="predict.glmpath_+3A_mode">mode</code></td>
<td>

<p>what <code>mode=s</code> refers to. If <code>mode=step,</code> <code>s</code> is the
number of steps taken; if <code>mode=norm.fraction,</code> <code>s</code> is the
fraction of the L1 norm of the standardized coefficients (with
respect to the largest norm); if <code>mode=norm,</code> <code>s</code> is the
L1 norm of the standardized coefficients; if
<code>mode=lambda.fraction,</code> <code>s</code> is the fraction of
log(<code class="reqn">\lambda</code>); and if <code>mode=lambda,</code> <code>s</code> is
<code class="reqn">\lambda</code>. Default is <code>step.</code>
</p>
</td></tr>
<tr><td><code id="predict.glmpath_+3A_weight">weight</code></td>
<td>

<p>an optional vector of weights for observations. <code>weight</code> is
effective only if <code>type=loglik.</code>
</p>
</td></tr>
<tr><td><code id="predict.glmpath_+3A_offset">offset</code></td>
<td>

<p>If <code>offset</code> was used in <code>object,</code> <code>offset</code> must be
provided for prediction, unless <code>type=coefficients.</code>
</p>
</td></tr>
<tr><td><code id="predict.glmpath_+3A_eps">eps</code></td>
<td>

<p>an effective zero
</p>
</td></tr>
<tr><td><code id="predict.glmpath_+3A_...">...</code></td>
<td>

<p>other options for the prediction
</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Mee Young Park and Trevor Hastie</p>


<h3>References</h3>

<p>Mee Young Park and Trevor Hastie (2007) L1 regularization path
algorithm for generalized linear models. <em>J. R. Statist. Soc.</em> B,
69, 659-677.
</p>


<h3>See Also</h3>

<p>cv.glmpath, glmpath, plot.glmpath
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(heart.data)
attach(heart.data)
fit &lt;- glmpath(x, y, family=binomial)
pred &lt;- predict(fit, x, s = seq(0, 1, length=10), mode="norm.fraction")
detach(heart.data)
</code></pre>

<hr>
<h2 id='summary.coxpath'>
Produces an anova-type summary for a coxpath object
</h2><span id='topic+summary.coxpath'></span>

<h3>Description</h3>

<p>This function produces an anova-type summary for a coxpath object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  ## S3 method for class 'coxpath'
summary(object, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="summary.coxpath_+3A_object">object</code></td>
<td>

<p>a <code>coxpath</code> object
</p>
</td></tr>
<tr><td><code id="summary.coxpath_+3A_...">...</code></td>
<td>

<p>additional arguments
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>An anova type of summary is returned, including Df,
Log-partial-likelihood, AIC, and BIC values for the steps where the
active set changed.
</p>


<h3>Value</h3>

<p>A data.frame is returned, with the following components at transition points:
</p>
<table role = "presentation">
<tr><td><code>Df</code></td>
<td>

<p>degrees of freedom at each step
</p>
</td></tr>
<tr><td><code>Log.p.lik</code></td>
<td>

<p>log-partial-likelihood at each step
</p>
</td></tr>
<tr><td><code>AIC</code></td>
<td>

<p>AIC value at each step
</p>
</td></tr>
<tr><td><code>BIC</code></td>
<td>

<p>BIC value at each step
</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Mee Young Park and Trevor Hastie</p>


<h3>References</h3>

<p>Mee Young Park and Trevor Hastie (2007) L1 regularization path
algorithm for generalized linear models. <em>J. R. Statist. Soc.</em> B,
69, 659-677.
</p>


<h3>See Also</h3>

<p>coxpath, plot.coxpath, print.coxpath
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(lung.data)
attach(lung.data)
fit &lt;- coxpath(lung.data)
summary(fit)
detach(lung.data)
</code></pre>

<hr>
<h2 id='summary.glmpath'>
Produces an anova-type summary for a glmpath object
</h2><span id='topic+summary.glmpath'></span>

<h3>Description</h3>

<p>This function produces an anova-type summary for a glmpath object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  ## S3 method for class 'glmpath'
summary(object, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="summary.glmpath_+3A_object">object</code></td>
<td>

<p>a <code>glmpath</code> object
</p>
</td></tr>
<tr><td><code id="summary.glmpath_+3A_...">...</code></td>
<td>

<p>additional arguments
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>An anova type of summary is returned, including Df, Deviance, AIC, and
BIC values for the steps where the active set changed.
</p>


<h3>Value</h3>

<p>A data.frame is returned, with the following components at transition points:
</p>
<table role = "presentation">
<tr><td><code>Df</code></td>
<td>

<p>degrees of freedom at each step
</p>
</td></tr>
<tr><td><code>Deviance</code></td>
<td>

<p>deviance computed at each step
</p>
</td></tr>
<tr><td><code>AIC</code></td>
<td>

<p>AIC value at each step
</p>
</td></tr>
<tr><td><code>BIC</code></td>
<td>

<p>BIC value at each step
</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Mee Young Park and Trevor Hastie</p>


<h3>References</h3>

<p>Mee Young Park and Trevor Hastie (2007) L1 regularization path
algorithm for generalized linear models. <em>J. R. Statist. Soc.</em> B,
69, 659-677.
</p>


<h3>See Also</h3>

<p>glmpath, plot.glmpath, print.glmpath
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(heart.data)
attach(heart.data)
fit &lt;- glmpath(x, y)
summary(fit)
detach(heart.data)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
