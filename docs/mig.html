<!DOCTYPE html><html lang="en"><head><title>Help for package mig</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {mig}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#.lsum'><p>Log of sum of terms</p></a></li>
<li><a href='#.mig_mle'><p>Maximum likelihood estimation of multivariate inverse Gaussian vectors</p></a></li>
<li><a href='#.mig_mom'><p>Method of moments estimators for multivariate inverse Gaussian vectors</p></a></li>
<li><a href='#dmig'><p>Multivariate inverse Gaussian distribution</p></a></li>
<li><a href='#dmig_laplacian'><p>Laplacian of the MIG density with respect to the data</p></a></li>
<li><a href='#dtellipt'><p>Density of elliptical vectors subject to a linear constraint</p></a></li>
<li><a href='#fit_mig'><p>Fit multivariate inverse Gaussian distribution</p></a></li>
<li><a href='#geomagnetic'><p>Magnetic storms</p></a></li>
<li><a href='#mig_kdens'><p>Multivariate inverse Gaussian kernel density estimator</p></a></li>
<li><a href='#mig_kdens_arma'><p>MIG kernel density estimator</p></a></li>
<li><a href='#mig_kdens_bandwidth'><p>Optimal scale matrix for MIG kernel density estimation</p></a></li>
<li><a href='#mig_lcv'><p>Likelihood cross-validation for kernel density estimation with MIG</p></a></li>
<li><a href='#mig_loglik_grad'><p>Gradient of the MIG log likelihood with respect to data</p></a></li>
<li><a href='#mig_loglik_hessian'><p>Hessian of the MIG log likelihood with respect to data</p></a></li>
<li><a href='#mig_loglik_laplacian'><p>Laplacian of the MIG log likelihood with respect to the data</p></a></li>
<li><a href='#mig_rlcv'><p>Robust likelihood cross-validation for kernel density estimation</p></a></li>
<li><a href='#normalrule_bandwidth'><p>Normal bandwidth rule</p></a></li>
<li><a href='#rtellipt'><p>Simulate elliptical vector subject to a linear constraint</p></a></li>
<li><a href='#tellipt_kdens'><p>Truncated Gaussian kernel density estimator</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Multivariate Inverse Gaussian Distribution</td>
</tr>
<tr>
<td>Version:</td>
<td>1.0</td>
</tr>
<tr>
<td>Description:</td>
<td>Provides utilities for estimation for the multivariate inverse Gaussian distribution of Minami (2003) &lt;<a href="https://doi.org/10.1081%2FSTA-120025379">doi:10.1081/STA-120025379</a>&gt;, including random vector generation and explicit estimators of the location vector and scale matrix. The package implements kernel density estimators discussed in Belzile, Desgagnes, Genest and Ouimet (2024) &lt;<a href="https://doi.org/10.48550%2FarXiv.2209.04757">doi:10.48550/arXiv.2209.04757</a>&gt; for smoothing multivariate data on half-spaces.</td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/lbelzile/mig/issues">https://github.com/lbelzile/mig/issues</a></td>
</tr>
<tr>
<td>Imports:</td>
<td>statmod, TruncatedNormal (&ge; 2.3), Rcpp (&ge; 1.0.12)</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 2.10)</td>
</tr>
<tr>
<td>Suggests:</td>
<td>numDeriv, tinytest, knitr, rmarkdown, minqa</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>Rcpp, RcppArmadillo</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://opensource.org/licenses/mit-license.php">MIT</a> + file LICENSE</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.3.2</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-07-12 13:32:47 UTC; lbelzile</td>
</tr>
<tr>
<td>Author:</td>
<td>Frederic Ouimet <a href="https://orcid.org/0000-0001-7933-5265"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut],
  Leo Belzile <a href="https://orcid.org/0000-0002-9135-014X"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [aut,
    cre]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Leo Belzile &lt;belzilel@gmail.com&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-07-14 12:30:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='.lsum'>Log of sum of terms</h2><span id='topic+.lsum'></span>

<h3>Description</h3>

<p>Computes the log of a sum of positive components, given on the log scale (<code>lx</code>), avoiding numerical overflow.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.lsum(lx, loff)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id=".lsum_+3A_lx">lx</code></td>
<td>
<p>vector or matrix of log of terms to add</p>
</td></tr>
<tr><td><code id=".lsum_+3A_loff">loff</code></td>
<td>
<p>log of offset</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a vector of log sums
</p>


<h3>Author(s)</h3>

<p>Marius Hofert, Martin Maechler (package <code>copula</code>)
</p>

<hr>
<h2 id='.mig_mle'>Maximum likelihood estimation of multivariate inverse Gaussian vectors</h2><span id='topic+.mig_mle'></span>

<h3>Description</h3>

<p>The maximum likelihood estimators are obtained for fixed shift vector <code class="reqn">\boldsymbol{a}</code>
and half-space vector <code class="reqn">\boldsymbol{\beta}</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.mig_mle(x, beta, shift)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id=".mig_mle_+3A_x">x</code></td>
<td>
<p><code>n</code> by <code>d</code> matrix of quantiles</p>
</td></tr>
<tr><td><code id=".mig_mle_+3A_beta">beta</code></td>
<td>
<p><code>d</code> vector <code class="reqn">\boldsymbol{\beta}</code> defining the half-space through <code class="reqn">\boldsymbol{\beta}^{\top}\boldsymbol{\xi}&gt;0</code></p>
</td></tr>
<tr><td><code id=".mig_mle_+3A_shift">shift</code></td>
<td>
<p><code>d</code> translation for the half-space <code class="reqn">\boldsymbol{a}</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list with components:
</p>

<ul>
<li> <p><code>xi</code>: MLE of the expectation or location vector
</p>
</li>
<li> <p><code>Omega</code>: MLE of the scale matrix
</p>
</li></ul>


<hr>
<h2 id='.mig_mom'>Method of moments estimators for multivariate inverse Gaussian vectors</h2><span id='topic+.mig_mom'></span>

<h3>Description</h3>

<p>These estimators are based on the sample mean and covariance.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.mig_mom(x, beta, shift)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id=".mig_mom_+3A_x">x</code></td>
<td>
<p><code>n</code> by <code>d</code> matrix of quantiles</p>
</td></tr>
<tr><td><code id=".mig_mom_+3A_beta">beta</code></td>
<td>
<p><code>d</code> vector <code class="reqn">\boldsymbol{\beta}</code> defining the half-space through <code class="reqn">\boldsymbol{\beta}^{\top}\boldsymbol{\xi}&gt;0</code></p>
</td></tr>
<tr><td><code id=".mig_mom_+3A_shift">shift</code></td>
<td>
<p><code>d</code> translation for the half-space <code class="reqn">\boldsymbol{a}</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list with components:
</p>

<ul>
<li> <p><code>xi</code>: MOM estimate of the expectation or location vector
</p>
</li>
<li> <p><code>Omega</code>: MOM estimate of the scale matrix
</p>
</li></ul>


<hr>
<h2 id='dmig'>Multivariate inverse Gaussian distribution</h2><span id='topic+dmig'></span><span id='topic+rmig'></span><span id='topic+pmig'></span>

<h3>Description</h3>

<p>The density of the MIG model is
</p>
<p style="text-align: center;"><code class="reqn">f(\boldsymbol{x}+\boldsymbol{a}) =(2\pi)^{-d/2}\boldsymbol{\beta}^{\top}\boldsymbol{\xi}|\boldsymbol{\Omega}|^{-1/2}(\boldsymbol{\beta}^{\top}\boldsymbol{x})^{-(1+d/2)}\exp\left\{-\frac{(\boldsymbol{x}-\boldsymbol{\xi})^{\top}\boldsymbol{\Omega}^{-1}(\boldsymbol{x}-\boldsymbol{\xi})}{2\boldsymbol{\beta}^{\top}\boldsymbol{x}}\right\}</code>
</p>

<p>for points in the <code>d</code>-dimensional half-space <code class="reqn">\{\boldsymbol{x} \in \mathbb{R}^d: \boldsymbol{\beta}^{\top}(\boldsymbol{x}-\boldsymbol{a}) \geq 0\}</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dmig(x, xi, Omega, beta, shift, log = FALSE)

rmig(n, xi, Omega, beta, shift, method = c("invsim", "bm"), timeinc = 0.001)

pmig(q, xi, Omega, beta, log = FALSE, method = c("sov", "mc"), B = 10000L)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="dmig_+3A_x">x</code></td>
<td>
<p><code>n</code> by <code>d</code> matrix of quantiles</p>
</td></tr>
<tr><td><code id="dmig_+3A_xi">xi</code></td>
<td>
<p><code>d</code> vector of location parameters <code class="reqn">\boldsymbol{\xi}</code>, giving the expected value</p>
</td></tr>
<tr><td><code id="dmig_+3A_omega">Omega</code></td>
<td>
<p><code>d</code> by <code>d</code> positive definite scale matrix <code class="reqn">\boldsymbol{\Omega}</code></p>
</td></tr>
<tr><td><code id="dmig_+3A_beta">beta</code></td>
<td>
<p><code>d</code> vector <code class="reqn">\boldsymbol{\beta}</code> defining the half-space through <code class="reqn">\boldsymbol{\beta}^{\top}\boldsymbol{\xi}&gt;0</code></p>
</td></tr>
<tr><td><code id="dmig_+3A_shift">shift</code></td>
<td>
<p><code>d</code> translation for the half-space <code class="reqn">\boldsymbol{a}</code></p>
</td></tr>
<tr><td><code id="dmig_+3A_log">log</code></td>
<td>
<p>logical; if <code>TRUE</code>, returns log probabilities</p>
</td></tr>
<tr><td><code id="dmig_+3A_n">n</code></td>
<td>
<p>number of observations</p>
</td></tr>
<tr><td><code id="dmig_+3A_method">method</code></td>
<td>
<p>string; one of inverse system (<code>invsim</code>, default), Brownian motion (<code>bm</code>)</p>
</td></tr>
<tr><td><code id="dmig_+3A_timeinc">timeinc</code></td>
<td>
<p>time increment for multivariate simulation algorithm based on the hitting time of Brownian motion, default to <code>1e-3</code>.</p>
</td></tr>
<tr><td><code id="dmig_+3A_q">q</code></td>
<td>
<p><code>n</code> by <code>d</code> matrix of quantiles</p>
</td></tr>
<tr><td><code id="dmig_+3A_b">B</code></td>
<td>
<p>number of Monte Carlo replications for the SOV estimator</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Observations are generated using the representation as the first hitting time of a hyperplane of a correlated Brownian motion.
</p>


<h3>Value</h3>

<p>for <code>dmig</code>, the (log)-density
</p>
<p>for <code>rmig</code>, an <code>n</code> vector if <code>d=1</code> (univariate) or an <code>n</code> by <code>d</code> matrix if <code>d &gt; 1</code>
</p>
<p>an <code>n</code> vector of (log) probabilities
</p>


<h3>Author(s)</h3>

<p>Frederic Ouimet (<code>bm</code>), Leo Belzile (<code>invsim</code>)
</p>
<p>Leo Belzile
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Density evaluation
x &lt;- rbind(c(1, 2), c(2,3), c(0,-1))
beta &lt;- c(1, 0)
xi &lt;- c(1, 1)
Omega &lt;- matrix(c(2, -1, -1, 2), nrow = 2, ncol = 2)
dmig(x, xi = xi, Omega = Omega, beta = beta)
# Random number generation
d &lt;- 5L
beta &lt;- runif(d)
xi &lt;- rexp(d)
Omega &lt;- matrix(0.5, d, d) + diag(d)
samp &lt;- rmig(n = 1000, beta = beta, xi = xi, Omega = Omega)
mle &lt;- fit_mig(samp, beta = beta, method = "mle")
set.seed(1234)
d &lt;- 2L
beta &lt;- runif(d)
Omega &lt;- rWishart(n = 1, df = 2*d, Sigma = matrix(0.5, d, d) + diag(d))[,,1]
xi &lt;- rexp(d)
q &lt;- mig::rmig(n = 10, beta = beta, Omega = Omega, xi = xi)
pmig(q, xi = xi, beta = beta, Omega = Omega)
</code></pre>

<hr>
<h2 id='dmig_laplacian'>Laplacian of the MIG density with respect to the data</h2><span id='topic+dmig_laplacian'></span>

<h3>Description</h3>

<p>Computes the sum of second derivatives of the multivariate
inverse Gaussian density with respect to the data argument
<code>x</code>. The function is vectorized for more efficiency.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dmig_laplacian(x, xi, Omega, beta, scale = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="dmig_laplacian_+3A_x">x</code></td>
<td>
<p><code>n</code> by <code>d</code> matrix of quantiles</p>
</td></tr>
<tr><td><code id="dmig_laplacian_+3A_xi">xi</code></td>
<td>
<p><code>d</code> vector of location parameters <code class="reqn">\boldsymbol{\xi}</code>, giving the expected value</p>
</td></tr>
<tr><td><code id="dmig_laplacian_+3A_omega">Omega</code></td>
<td>
<p><code>d</code> by <code>d</code> positive definite scale matrix <code class="reqn">\boldsymbol{\Omega}</code></p>
</td></tr>
<tr><td><code id="dmig_laplacian_+3A_beta">beta</code></td>
<td>
<p><code>d</code> vector <code class="reqn">\boldsymbol{\beta}</code> defining the half-space through <code class="reqn">\boldsymbol{\beta}^{\top}\boldsymbol{\xi}&gt;0</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>an <code>n</code> vector
</p>

<hr>
<h2 id='dtellipt'>Density of elliptical vectors subject to a linear constraint</h2><span id='topic+dtellipt'></span>

<h3>Description</h3>

<p>Compute the density of  multivariate Student-t or Gaussian <code class="reqn">\boldsymbol{x}</code>
with location vector <code>mu</code>, scale matrix <code>sigma</code> and  <code>df</code> (integer) degrees of freedom
subject to the linear constraint <code class="reqn">\boldsymbol{\beta}^\top\boldsymbol{x} &gt; \delta</code>.
Negative degrees of freedom or values larger than 1000 imply Gaussian vectors are generated instead.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dtellipt(x, beta, mu, sigma, df, delta = 0, log = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="dtellipt_+3A_beta">beta</code></td>
<td>
<p><code>d</code> vector of linear constraints</p>
</td></tr>
<tr><td><code id="dtellipt_+3A_mu">mu</code></td>
<td>
<p>location vector</p>
</td></tr>
<tr><td><code id="dtellipt_+3A_sigma">sigma</code></td>
<td>
<p>scale matrix</p>
</td></tr>
<tr><td><code id="dtellipt_+3A_df">df</code></td>
<td>
<p>degrees of freedom argument</p>
</td></tr>
<tr><td><code id="dtellipt_+3A_delta">delta</code></td>
<td>
<p>buffer; default to zero</p>
</td></tr>
<tr><td><code id="dtellipt_+3A_log">log</code></td>
<td>
<p>logical; if <code>TRUE</code>, return the log density</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an <code>n</code> by <code>d</code> matrix of random vectors
</p>

<hr>
<h2 id='fit_mig'>Fit multivariate inverse Gaussian distribution</h2><span id='topic+fit_mig'></span>

<h3>Description</h3>

<p>Fit multivariate inverse Gaussian distribution
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fit_mig(x, beta, method = c("mle", "mom"), shift)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="fit_mig_+3A_x">x</code></td>
<td>
<p><code>n</code> by <code>d</code> matrix of quantiles</p>
</td></tr>
<tr><td><code id="fit_mig_+3A_beta">beta</code></td>
<td>
<p><code>d</code> vector <code class="reqn">\boldsymbol{\beta}</code> defining the half-space through <code class="reqn">\boldsymbol{\beta}^{\top}\boldsymbol{\xi}&gt;0</code></p>
</td></tr>
<tr><td><code id="fit_mig_+3A_method">method</code></td>
<td>
<p>string, one of <code>mle</code> for maximum likelihood estimation, or <code>mom</code> for method of moments.</p>
</td></tr>
<tr><td><code id="fit_mig_+3A_shift">shift</code></td>
<td>
<p><code>d</code> translation for the half-space <code class="reqn">\boldsymbol{a}</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list with components:
</p>

<ul>
<li> <p><code>xi</code>: estimate of the expectation or location vector
</p>
</li>
<li> <p><code>Omega</code>: estimate of the scale matrix
</p>
</li></ul>


<hr>
<h2 id='geomagnetic'>Magnetic storms</h2><span id='topic+geomagnetic'></span>

<h3>Description</h3>

<p>Absolute magnitude of 373 geomagnetic storms lasting more than 48h with absolute magnitude (dst) larger than 100 in 1957-2014.
</p>


<h3>Format</h3>

<p>a vector of size 373
</p>


<h3>Note</h3>

<p>For a detailed article presenting the derivation of the Dst index, see <code>http://wdc.kugi.kyoto-u.ac.jp/dstdir/dst2/onDstindex.html</code>
</p>


<h3>Source</h3>

<p>Aki Vehtari
</p>


<h3>References</h3>

<p>World Data Center for Geomagnetism, Kyoto, M. Nose, T. Iyemori, M. Sugiura, T. Kamei (2015), <em>Geomagnetic Dst index</em>, doi:10.17593/14515-74000.
</p>

<hr>
<h2 id='mig_kdens'>Multivariate inverse Gaussian kernel density estimator</h2><span id='topic+mig_kdens'></span>

<h3>Description</h3>

<p>Given a matrix of new observations, compute the density of the multivariate
inverse Gaussian mixture defined by assigning equal weight to each component where
<code class="reqn">\boldsymbol{\xi}</code> is the location parameter.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mig_kdens(x, newdata, Omega, beta, log = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="mig_kdens_+3A_x">x</code></td>
<td>
<p><code>n</code> by <code>d</code> matrix of quantiles</p>
</td></tr>
<tr><td><code id="mig_kdens_+3A_newdata">newdata</code></td>
<td>
<p>matrix of new observations at which to evaluated the kernel density</p>
</td></tr>
<tr><td><code id="mig_kdens_+3A_omega">Omega</code></td>
<td>
<p><code>d</code> by <code>d</code> positive definite scale matrix <code class="reqn">\boldsymbol{\Omega}</code></p>
</td></tr>
<tr><td><code id="mig_kdens_+3A_beta">beta</code></td>
<td>
<p><code>d</code> vector <code class="reqn">\boldsymbol{\beta}</code> defining the half-space through <code class="reqn">\boldsymbol{\beta}^{\top}\boldsymbol{\xi}&gt;0</code></p>
</td></tr>
<tr><td><code id="mig_kdens_+3A_log">log</code></td>
<td>
<p>logical; if <code>TRUE</code>, returns log probabilities</p>
</td></tr>
</table>


<h3>Value</h3>

<p>value of the (log)-density at <code>newdata</code>
</p>

<hr>
<h2 id='mig_kdens_arma'>MIG kernel density estimator</h2><span id='topic+mig_kdens_arma'></span>

<h3>Description</h3>

<p>Given a data matrix over a half-space defined by <code>beta</code>,
compute the log density taking in turn an observation in  <code>newdata</code>
as location vector and computing the kernel density estimate.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mig_kdens_arma(x, newdata, Omega, beta, logd)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="mig_kdens_arma_+3A_x">x</code></td>
<td>
<p><code>n</code> by <code>d</code> matrix of quantiles</p>
</td></tr>
<tr><td><code id="mig_kdens_arma_+3A_newdata">newdata</code></td>
<td>
<p>matrix of new observations at which to evaluated the kernel density</p>
</td></tr>
<tr><td><code id="mig_kdens_arma_+3A_omega">Omega</code></td>
<td>
<p><code>d</code> by <code>d</code> positive definite scale matrix <code class="reqn">\boldsymbol{\Omega}</code></p>
</td></tr>
<tr><td><code id="mig_kdens_arma_+3A_beta">beta</code></td>
<td>
<p><code>d</code> vector <code class="reqn">\boldsymbol{\beta}</code> defining the half-space through <code class="reqn">\boldsymbol{\beta}^{\top}\boldsymbol{\xi}&gt;0</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>the value of the likelihood cross-validation criterion
</p>

<hr>
<h2 id='mig_kdens_bandwidth'>Optimal scale matrix for MIG kernel density estimation</h2><span id='topic+mig_kdens_bandwidth'></span>

<h3>Description</h3>

<p>Given an <code>n</code> sample from a multivariate
inverse Gaussian distribution on the half-space defined by
<code class="reqn">\{\boldsymbol{x} \in \mathbb{R}^d: \boldsymbol{\beta}^\top\boldsymbol{x}&gt;0\}</code>,
the function computes the bandwidth (<code>type="isotropic"</code>) or scale
matrix that minimizes the asymptotic mean integrated squared error away from the boundary.
The latter depend on the true unknown density, which is replaced using as plug-in
a MIG distribution evaluated at the maximum likelihood estimator. The integral or the integrated
squared error are obtained by Monte Carlo integration with <code>N</code> simulations
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mig_kdens_bandwidth(
  x,
  beta,
  shift,
  method = c("amise", "lcv", "lscv", "rlcv"),
  type = c("isotropic", "full"),
  approx = c("mig", "tnorm"),
  transformation = c("none", "scaling", "spherical"),
  N = 10000L,
  buffer = 0.25,
  pointwise = NULL,
  maxiter = 2000L,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="mig_kdens_bandwidth_+3A_x">x</code></td>
<td>
<p>an <code>n</code> by <code>d</code> matrix of observations</p>
</td></tr>
<tr><td><code id="mig_kdens_bandwidth_+3A_beta">beta</code></td>
<td>
<p><code>d</code> vector defining the half-space</p>
</td></tr>
<tr><td><code id="mig_kdens_bandwidth_+3A_shift">shift</code></td>
<td>
<p>location vector for translating the half-space. If missing, defaults to zero</p>
</td></tr>
<tr><td><code id="mig_kdens_bandwidth_+3A_method">method</code></td>
<td>
<p>estimation criterion, either <code>amise</code> for the expression that minimizes the asymptotic integrated squared error, <code>lcv</code> for likelihood (leave-one-out) cross-validation, <code>lscv</code> for least-square cross-validation or <code>rlcv</code> for robust cross validation of Wu (2019)</p>
</td></tr>
<tr><td><code id="mig_kdens_bandwidth_+3A_type">type</code></td>
<td>
<p>string indicating whether to compute an isotropic model or estimate the optimal scale matrix via optimization</p>
</td></tr>
<tr><td><code id="mig_kdens_bandwidth_+3A_approx">approx</code></td>
<td>
<p>string; distribution to approximate the true density function <code class="reqn">f(x)</code>; either <code>mig</code> for multivariate inverse Gaussian, or <code>tnorm</code> for truncated Gaussian.</p>
</td></tr>
<tr><td><code id="mig_kdens_bandwidth_+3A_transformation">transformation</code></td>
<td>
<p>string for optional scaling of the data before computing the bandwidth. Either standardization to unit variance <code>scaling</code>, spherical transformation to unit variance and zero correlation (<code>spherical</code>), or <code>none</code> (default).</p>
</td></tr>
<tr><td><code id="mig_kdens_bandwidth_+3A_n">N</code></td>
<td>
<p>integer number of simulations to evaluate the integrals of the MISE by Monte Carlo</p>
</td></tr>
<tr><td><code id="mig_kdens_bandwidth_+3A_buffer">buffer</code></td>
<td>
<p>double indicating the buffer from the halfspace</p>
</td></tr>
<tr><td><code id="mig_kdens_bandwidth_+3A_pointwise">pointwise</code></td>
<td>
<p>if <code>NULL</code>, evaluates the mean integrated squared error, otherwise a <code>d</code> vector to evaluate the bandwidth or scale pointwise</p>
</td></tr>
<tr><td><code id="mig_kdens_bandwidth_+3A_maxiter">maxiter</code></td>
<td>
<p>integer; max number of iterations in the call to <code>optim</code>.</p>
</td></tr>
<tr><td><code id="mig_kdens_bandwidth_+3A_...">...</code></td>
<td>
<p>additional parameters, currently ignored</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a <code>d</code> by <code>d</code> scale matrix
</p>


<h3>References</h3>

<p>Wu, X. (2019). Robust likelihood cross-validation for kernel density estimation. <em>Journal of Business &amp; Economic Statistics</em>, 37(<b>4</b>), 761–770. <a href="https://doi.org/10.1080/07350015.2018.1424633">doi:10.1080/07350015.2018.1424633</a>
Bowman, A.W. (1984). An alternative method of cross-validation for the smoothing of density estimates, <em>Biometrika</em>, 71(<b>2</b>), 353–360. <a href="https://doi.org/10.1093/biomet/71.2.353">doi:10.1093/biomet/71.2.353</a>
Rudemo, M. (1982). Empirical choice of histograms and kernel density estimators. <em>Scandinavian Journal of Statistics</em>, 9(<b>2</b>), 65–78. http://www.jstor.org/stable/4615859
</p>

<hr>
<h2 id='mig_lcv'>Likelihood cross-validation for kernel density estimation with MIG</h2><span id='topic+mig_lcv'></span>

<h3>Description</h3>

<p>Given a data matrix over a half-space defined by <code>beta</code>,
compute the log density using leave-one-out cross validation,
taking in turn an observation as location vector and computing the
density of the resulting mixture.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mig_lcv(x, beta, Omega)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="mig_lcv_+3A_x">x</code></td>
<td>
<p><code>n</code> by <code>d</code> matrix of quantiles</p>
</td></tr>
<tr><td><code id="mig_lcv_+3A_beta">beta</code></td>
<td>
<p><code>d</code> vector <code class="reqn">\boldsymbol{\beta}</code> defining the half-space through <code class="reqn">\boldsymbol{\beta}^{\top}\boldsymbol{\xi}&gt;0</code></p>
</td></tr>
<tr><td><code id="mig_lcv_+3A_omega">Omega</code></td>
<td>
<p><code>d</code> by <code>d</code> positive definite scale matrix <code class="reqn">\boldsymbol{\Omega}</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>the value of the likelihood cross-validation criterion
</p>

<hr>
<h2 id='mig_loglik_grad'>Gradient of the MIG log likelihood with respect to data</h2><span id='topic+mig_loglik_grad'></span>

<h3>Description</h3>

<p>This function returns the gradient vector of the log likelihood with respect to the
argument <code>x</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mig_loglik_grad(x, xi, Omega, beta)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="mig_loglik_grad_+3A_x">x</code></td>
<td>
<p><code>n</code> by <code>d</code> matrix of quantiles</p>
</td></tr>
<tr><td><code id="mig_loglik_grad_+3A_xi">xi</code></td>
<td>
<p><code>d</code> vector of location parameters <code class="reqn">\boldsymbol{\xi}</code>, giving the expected value</p>
</td></tr>
<tr><td><code id="mig_loglik_grad_+3A_omega">Omega</code></td>
<td>
<p><code>d</code> by <code>d</code> positive definite scale matrix <code class="reqn">\boldsymbol{\Omega}</code></p>
</td></tr>
<tr><td><code id="mig_loglik_grad_+3A_beta">beta</code></td>
<td>
<p><code>d</code> vector <code class="reqn">\boldsymbol{\beta}</code> defining the half-space through <code class="reqn">\boldsymbol{\beta}^{\top}\boldsymbol{\xi}&gt;0</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>an <code>n</code> by <code>d</code> matrix of first derivatives for the gradient, observation by observation, or a <code>d</code> vector if <code>x</code> is a vector.
</p>

<hr>
<h2 id='mig_loglik_hessian'>Hessian of the MIG log likelihood with respect to data</h2><span id='topic+mig_loglik_hessian'></span>

<h3>Description</h3>

<p>This function returns the hessian, i.e., the matrix of
second derivatives of the log likelihood with respect to the
argument <code>x</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mig_loglik_hessian(x, beta, xi, Omega)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="mig_loglik_hessian_+3A_x">x</code></td>
<td>
<p><code>n</code> by <code>d</code> matrix of quantiles</p>
</td></tr>
<tr><td><code id="mig_loglik_hessian_+3A_beta">beta</code></td>
<td>
<p><code>d</code> vector <code class="reqn">\boldsymbol{\beta}</code> defining the half-space through <code class="reqn">\boldsymbol{\beta}^{\top}\boldsymbol{\xi}&gt;0</code></p>
</td></tr>
<tr><td><code id="mig_loglik_hessian_+3A_xi">xi</code></td>
<td>
<p><code>d</code> vector of location parameters <code class="reqn">\boldsymbol{\xi}</code>, giving the expected value</p>
</td></tr>
<tr><td><code id="mig_loglik_hessian_+3A_omega">Omega</code></td>
<td>
<p><code>d</code> by <code>d</code> positive definite scale matrix <code class="reqn">\boldsymbol{\Omega}</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>a <code>d</code> by <code>d</code> matrix of second derivatives if <code>x</code> has length <code>d</code>,
else an <code>n</code> by <code>d</code> by <code>d</code> array if <code>x</code> is an <code>n</code> by <code>d</code> matrix
</p>

<hr>
<h2 id='mig_loglik_laplacian'>Laplacian of the MIG log likelihood with respect to the data</h2><span id='topic+mig_loglik_laplacian'></span>

<h3>Description</h3>

<p>Computes the sum of second derivatives of the multivariate
inverse Gaussian likelihood with respect to the data argument
<code>x</code>. The function is vectorized for more efficiency.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mig_loglik_laplacian(x, beta, xi, Omega)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="mig_loglik_laplacian_+3A_x">x</code></td>
<td>
<p><code>n</code> by <code>d</code> matrix of quantiles</p>
</td></tr>
<tr><td><code id="mig_loglik_laplacian_+3A_beta">beta</code></td>
<td>
<p><code>d</code> vector <code class="reqn">\boldsymbol{\beta}</code> defining the half-space through <code class="reqn">\boldsymbol{\beta}^{\top}\boldsymbol{\xi}&gt;0</code></p>
</td></tr>
<tr><td><code id="mig_loglik_laplacian_+3A_xi">xi</code></td>
<td>
<p><code>d</code> vector of location parameters <code class="reqn">\boldsymbol{\xi}</code>, giving the expected value</p>
</td></tr>
<tr><td><code id="mig_loglik_laplacian_+3A_omega">Omega</code></td>
<td>
<p><code>d</code> by <code>d</code> positive definite scale matrix <code class="reqn">\boldsymbol{\Omega}</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>an <code>n</code> vector
</p>

<hr>
<h2 id='mig_rlcv'>Robust likelihood cross-validation for kernel density estimation</h2><span id='topic+mig_rlcv'></span>

<h3>Description</h3>

<p>Given a data matrix over a half-space defined by <code>beta</code>,
compute the log density using leave-one-out cross validation,
taking in turn an observation as location vector and computing the
density of the resulting mixture.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mig_rlcv(x, beta, Omega, xsamp, dxsamp)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="mig_rlcv_+3A_x">x</code></td>
<td>
<p><code>n</code> by <code>d</code> matrix of quantiles</p>
</td></tr>
<tr><td><code id="mig_rlcv_+3A_beta">beta</code></td>
<td>
<p><code>d</code> vector <code class="reqn">\boldsymbol{\beta}</code> defining the half-space through <code class="reqn">\boldsymbol{\beta}^{\top}\boldsymbol{\xi}&gt;0</code></p>
</td></tr>
<tr><td><code id="mig_rlcv_+3A_omega">Omega</code></td>
<td>
<p><code>d</code> by <code>d</code> positive definite scale matrix <code class="reqn">\boldsymbol{\Omega}</code></p>
</td></tr>
<tr><td><code id="mig_rlcv_+3A_xsamp">xsamp</code></td>
<td>
<p>matrix of points at which to evaluate the integral</p>
</td></tr>
<tr><td><code id="mig_rlcv_+3A_dxsamp">dxsamp</code></td>
<td>
<p>density of points</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the value of the likelihood cross-validation criterion
</p>

<hr>
<h2 id='normalrule_bandwidth'>Normal bandwidth rule</h2><span id='topic+normalrule_bandwidth'></span>

<h3>Description</h3>

<p>Given an <code>n</code> by <code>d</code> matrix of observations, compute the
bandwidth according to Scott's rule.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>normalrule_bandwidth(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="normalrule_bandwidth_+3A_x">x</code></td>
<td>
<p><code>n</code> by <code>d</code> matrix of observations</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a <code>d</code> by <code>d</code> diagonal bandwidth matrix
</p>

<hr>
<h2 id='rtellipt'>Simulate elliptical vector subject to a linear constraint</h2><span id='topic+rtellipt'></span>

<h3>Description</h3>

<p>Simulate multivariate Student-t <code class="reqn">\boldsymbol{x}</code>
with location vector <code>mu</code>, scale matrix <code>sigma</code> and  <code>df</code> (integer) degrees of freedom
subject to the linear constraint <code class="reqn">\boldsymbol{\beta}^\top\boldsymbol{x} &gt; 0</code>.
Negative degrees of freedom or values larger than 1000 imply Gaussian vectors are generated instead.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rtellipt(n, beta, mu, sigma, df, delta = 0)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="rtellipt_+3A_n">n</code></td>
<td>
<p>number of simulations</p>
</td></tr>
<tr><td><code id="rtellipt_+3A_beta">beta</code></td>
<td>
<p><code>d</code> vector of linear constraints</p>
</td></tr>
<tr><td><code id="rtellipt_+3A_mu">mu</code></td>
<td>
<p>location vector</p>
</td></tr>
<tr><td><code id="rtellipt_+3A_sigma">sigma</code></td>
<td>
<p>scale matrix</p>
</td></tr>
<tr><td><code id="rtellipt_+3A_df">df</code></td>
<td>
<p>degrees of freedom argument</p>
</td></tr>
<tr><td><code id="rtellipt_+3A_delta">delta</code></td>
<td>
<p>buffer; default to zero</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an <code>n</code> by <code>d</code> matrix of random vectors
</p>

<hr>
<h2 id='tellipt_kdens'>Truncated Gaussian kernel density estimator</h2><span id='topic+tellipt_kdens'></span>

<h3>Description</h3>

<p>Given a data matrix over a half-space defined by <code>beta</code>,
compute the log density of the asymmetric truncated Gaussian kernel density estimator,
taking in turn an observation as location vector.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tellipt_kdens(x, newdata, Sigma, beta, log = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="tellipt_kdens_+3A_x">x</code></td>
<td>
<p><code>n</code> by <code>d</code> matrix of quantiles</p>
</td></tr>
<tr><td><code id="tellipt_kdens_+3A_newdata">newdata</code></td>
<td>
<p>matrix of new observations at which to evaluated the kernel density</p>
</td></tr>
<tr><td><code id="tellipt_kdens_+3A_sigma">Sigma</code></td>
<td>
<p>scale matrix</p>
</td></tr>
<tr><td><code id="tellipt_kdens_+3A_beta">beta</code></td>
<td>
<p><code>d</code> vector <code class="reqn">\boldsymbol{\beta}</code> defining the half-space through <code class="reqn">\boldsymbol{\beta}^{\top}\boldsymbol{\xi}&gt;0</code></p>
</td></tr>
<tr><td><code id="tellipt_kdens_+3A_log">log</code></td>
<td>
<p>logical; if <code>TRUE</code>, returns log probabilities</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a vector containing the value of the kernel density at each of the <code>newdata</code> points
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
