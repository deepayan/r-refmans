<!DOCTYPE html><html><head><title>Help for package lphom</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {lphom}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#adjust2integers'><p>Integer-adjusting of outputs of the lphom-family functions</p></a></li>
<li><a href='#confidence_intervals_pjk'><p>Confidence Intervals for lphom estimates</p></a></li>
<li><a href='#error_lphom'><p>Global error of a lphom estimated table</p></a></li>
<li><a href='#France2017D'>
<p>2017 French Presidential Election. Department official results.</p></a></li>
<li><a href='#France2017P'>
<p>2017 French Presidential Election. Regional provisional results.</p></a></li>
<li><a href='#lclphom'><p>Implements lclphom algorithm</p></a></li>
<li><a href='#lp_apriori'><p>Implements lp_apriori models</p></a></li>
<li><a href='#lphom'><p>Implements lphom algorithm</p></a></li>
<li><a href='#lphom_dual'><p>Implements lphom_dual algorithm</p></a></li>
<li><a href='#lphom_joint'><p>Implements the lphom_joint algorithm</p></a></li>
<li><a href='#nslphom'><p>Implements nslphom algorithm</p></a></li>
<li><a href='#nslphom_dual'><p>Implements the nslphom_dual algorithm</p></a></li>
<li><a href='#nslphom_joint'><p>Implements the nslphom_joint algorithm</p></a></li>
<li><a href='#plot.lphom'><p>Graphical representation of a RxC ecological inference (vote transfer) matrix</p></a></li>
<li><a href='#print.lphom'><p>Print a summary of a lphom-family object</p></a></li>
<li><a href='#print.summary.lphom'><p>Print a summary of a lphom-family object</p></a></li>
<li><a href='#rslphom'><p>Implements rslphom algorithm</p></a></li>
<li><a href='#summary.lphom'><p>Summarize a lphom-family object</p></a></li>
<li><a href='#tslphom'><p>Implements tslphom algorithm</p></a></li>
<li><a href='#tslphom_dual'><p>Implements the tslphom_dual algorithm</p></a></li>
<li><a href='#tslphom_joint'><p>Implements the tslphom_joint algorithm</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Ecological Inference by Linear Programming under Homogeneity</td>
</tr>
<tr>
<td>Version:</td>
<td>0.3.5-5</td>
</tr>
<tr>
<td>Description:</td>
<td>Provides a bunch of algorithms based on linear programming for estimating, under 
    the homogeneity hypothesis, RxC ecological contingency tables (or vote transition matrices) 
    using mainly aggregate data (from voting units). 
    References: 
    Pavía and Romero (2022) &lt;<a href="https://doi.org/10.1177%2F00491241221092725">doi:10.1177/00491241221092725</a>&gt;.
    Pavía (2023) &lt;<a href="https://doi.org/10.1007%2Fs43545-023-00658-y">doi:10.1007/s43545-023-00658-y</a>&gt;.
    Pavía and Romero (2024) &lt;<a href="https://doi.org/10.1093%2Fjrsssa%2Fqnae013">doi:10.1093/jrsssa/qnae013</a>&gt;.
    Pavía (2024) A local convergent ecological inference algorithm for RxC tables.
    Pavía and Penadés (2024). A bottom-up approach for ecological inference.
    Romero, Pavía, Martín and Romero (2020) &lt;<a href="https://doi.org/10.1080%2F02664763.2020.1804842">doi:10.1080/02664763.2020.1804842</a>&gt;.
    Acknowledgements:
    The authors wish to thank Consellería de Educación, Universidades y Empleo, Generalitat Valenciana (grant AICO/2021/257) and Ministerio de Economía e Innovación (grant PID2021-128228NB-I00) for supporting this research.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.eclipse.org/legal/epl-v10.html">EPL</a> | file LICENSE</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>Imports:</td>
<td>stats, lpSolve (&ge; 5.6.18)</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.5.0)</td>
</tr>
<tr>
<td>Suggests:</td>
<td>ggplot2, scales, Rsymphony (&ge; 0.1-30)</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-03-03 10:12:27 UTC; mariaamparo</td>
</tr>
<tr>
<td>Author:</td>
<td>Jose M. Pavía <a href="https://orcid.org/0000-0002-0129-726X"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cre],
  Rafael Romero [aut]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Jose M. Pavía &lt;jose.m.pavia@uv.es&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-03-03 10:30:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='adjust2integers'>Integer-adjusting of outputs of the lphom-family functions</h2><span id='topic+adjust2integers'></span>

<h3>Description</h3>

<p>Takes as input an object generated with an algorithm of the lphom-family
(lphom, tslphom, nslphom, tslphom_dual, nslphom_joint, ....) and returns
as output an object of the same class as the input object with all their relevant estimated (local and global) transfer matrices
of counts updated to their closest integer matrices. The rest of main components of the object are also accordingly updated.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>adjust2integers(x, solver = "symphony", ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="adjust2integers_+3A_x">x</code></td>
<td>
<p>An object output of a lphom family algorithm</p>
</td></tr>
<tr><td><code id="adjust2integers_+3A_solver">solver</code></td>
<td>
<p>A character string indicating the linear programming solver to be used to approximate
to the closest integer solution, only <code>symphony</code> and <code>lp_solve</code> are allowed.
By default, <code>symphony</code>. The package <code>Rsymphony</code> needs to be installed for the option <code>symphony</code>
to be used.</p>
</td></tr>
<tr><td><code id="adjust2integers_+3A_...">...</code></td>
<td>
<p>Other arguments passed on the method. Not currently used.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The updating of the matrices is performed using integer linear programming after imposing all the row- and column-constraints.
</p>


<h3>Value</h3>

<p>An object of the same class and components as <code>x</code> with its components properly updated after adjusting the estimated count matrices in <code>x</code> using integer linear programming
</p>


<h3>Author(s)</h3>

<p>Jose M. Pavia, <a href="mailto:pavia@uv.es">pavia@uv.es</a>
</p>


<h3>References</h3>

<p>...
</p>


<h3>Examples</h3>

<pre><code class='language-R'>mt.ts &lt;- tslphom(France2017P[, 1:8] , France2017P[, 9:12], new_and_exit_voters= "raw")
mt.ts &lt;- adjust2integers(mt.ts, solver = "lp_solve")
</code></pre>

<hr>
<h2 id='confidence_intervals_pjk'>Confidence Intervals for lphom estimates</h2><span id='topic+confidence_intervals_pjk'></span>

<h3>Description</h3>

<p>Estimates confidence intervals for the (vote) transfer probabilities obtained with <strong>lphom()</strong>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>confidence_intervals_pjk(lphom.object, level = 0.9, num.d = 11, B = 30)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="confidence_intervals_pjk_+3A_lphom.object">lphom.object</code></td>
<td>
<p>An object output of the <strong>lphom()</strong> function.</p>
</td></tr>
<tr><td><code id="confidence_intervals_pjk_+3A_level">level</code></td>
<td>
<p>A number between 0 and 1 to be used as level of confidence for the intervals. By default 0.90</p>
</td></tr>
<tr><td><code id="confidence_intervals_pjk_+3A_num.d">num.d</code></td>
<td>
<p>Number maximum of different disturbances, <code>d</code>, to be initially considered. Positive integer greater than or equal to 5. By default, 11.</p>
</td></tr>
<tr><td><code id="confidence_intervals_pjk_+3A_b">B</code></td>
<td>
<p>Integer that determines the number of simulations to be performed for each disturbance value. By default, 30.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with the following components
</p>
<table>
<tr><td><code>TM.estimation</code></td>
<td>
<p> Transfer matrix of probability point estimates.</p>
</td></tr>
<tr><td><code>TM.lower</code></td>
<td>
<p> Transfer matrix of lower values for the probability estimates.</p>
</td></tr>
<tr><td><code>TM.upper</code></td>
<td>
<p> Transfer matrix of upper values for the probability estimates.</p>
</td></tr>
<tr><td><code>level</code></td>
<td>
<p> Confidence level used when computing the confidence intervals.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Jose M. Pavia, <a href="mailto:pavia@uv.es">pavia@uv.es</a>
</p>
<p>Rafael Romero <a href="mailto:rromero@eio.upv.es">rromero@eio.upv.es</a>
</p>


<h3>References</h3>

<p>Romero, R, Pavia, JM, Martin, J and Romero G (2020). Assessing uncertainty of voter transitions estimated from aggregated data. Application to the 2017 French presidential election. <em>Journal of Applied Statistics</em>, 47(13-15), 2711-2736. <a href="https://doi.org/10.1080/02664763.2020.1804842">doi:10.1080/02664763.2020.1804842</a>
</p>
<p>Martin, J (2020). Analisis de la incertidumbre en la estimacion de la movilidad electoral mediante el procedimiento plhom. PhD Dissertation.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Do not run
# mt.lphom &lt;- lphom(France2017P[, 1:8], France2017P[, 9:12], "raw", NULL, FALSE)
# set.seed(533423)
# confidence_intervals_pjk(mt.lphom, level = 0.90, num.d = 5, B = 8)
</code></pre>

<hr>
<h2 id='error_lphom'>Global error of a lphom estimated table</h2><span id='topic+error_lphom'></span>

<h3>Description</h3>

<p>Estimation of the error index (EI) of a RxC vote transfer matrix obtained with <strong>lphom()</strong>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>error_lphom(
  lphom.object,
  upper.alfa = 0.1,
  show.plot = TRUE,
  num.d = 11,
  B = 30
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="error_lphom_+3A_lphom.object">lphom.object</code></td>
<td>
<p>An object output of the <strong>lphom()</strong> function.</p>
</td></tr>
<tr><td><code id="error_lphom_+3A_upper.alfa">upper.alfa</code></td>
<td>
<p>Upper bound that will not be exceed by the EI estimate with a confidence 1 - alpha. By default, 0.10.</p>
</td></tr>
<tr><td><code id="error_lphom_+3A_show.plot">show.plot</code></td>
<td>
<p>TRUE/FALSE. Indicates whether the plot showing the relationship between EI and HETe estimated by simulation for the election under study should be displayed as a side-effect. By default, TRUE.</p>
</td></tr>
<tr><td><code id="error_lphom_+3A_num.d">num.d</code></td>
<td>
<p>Number maximum of different disturbances, <code>d</code>, to be initially considered. Positive integer greater than or equal to 5. By default, 11.</p>
</td></tr>
<tr><td><code id="error_lphom_+3A_b">B</code></td>
<td>
<p>Integer that determines the number of simulations to be performed for each disturbance value. By default, 30.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with the following components
</p>
<table>
<tr><td><code>EI.estimate</code></td>
<td>
<p> Point estimate for EI.</p>
</td></tr>
<tr><td><code>EI.upper</code></td>
<td>
<p> Upper bound with confidence 1 - alpha of the EI estimate </p>
</td></tr>
<tr><td><code>figure</code></td>
<td>
<p> ggplot2 object describing the graphical representation of the relationship between EI and HETe.</p>
</td></tr>
<tr><td><code>equation</code></td>
<td>
<p> lm object of the adjustment between EI and HETe.</p>
</td></tr>
<tr><td><code>statistics</code></td>
<td>
<p> A four column matrix with the values of HET, HETe, EI and d associated with each simulated scenario.</p>
</td></tr>
<tr><td><code>TMs.real</code></td>
<td>
<p> Array with the simulated real transfer matrices associated with each scenario.</p>
</td></tr>
<tr><td><code>TMs.estimate</code></td>
<td>
<p> Array with the estimated transfer matrices associated with each scenario.</p>
</td></tr>
</table>


<h3>Note</h3>

<p>ggplot2 is needed to be installed for this function to work.
</p>
<p>See equation (12) in Romero et al. (2020) for a definition of the EI index.
</p>


<h3>Author(s)</h3>

<p>Jose M. Pavia, <a href="mailto:pavia@uv.es">pavia@uv.es</a>
</p>
<p>Rafael Romero <a href="mailto:rromero@eio.upv.es">rromero@eio.upv.es</a>
</p>


<h3>References</h3>

<p>Romero, R, Pavia, JM, Martin, J and Romero G (2020). Assessing uncertainty of voter transitions estimated from aggregated data. Application to the 2017 French presidential election. <em>Journal of Applied Statistics</em>, 47(13-15), 2711-2736. <a href="https://doi.org/10.1080/02664763.2020.1804842">doi:10.1080/02664763.2020.1804842</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+lphom">lphom</a></code> <code><a href="#topic+confidence_intervals_pjk">confidence_intervals_pjk</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>mt.lphom &lt;- lphom(France2017P[, 1:8], France2017P[, 9:12], 
                  new_and_exit_voters = "raw", verbose = FALSE)
set.seed(253443)
example &lt;- error_lphom(mt.lphom, upper.alfa = 0.10, show.plot = FALSE, num.d = 5, B = 8)
example$EI.estimate
</code></pre>

<hr>
<h2 id='France2017D'>
2017 French Presidential Election. Department official results.
</h2><span id='topic+France2017D'></span>

<h3>Description</h3>

<p>Data frame containing the official results recorded in the first and second rounds of the 2017 French presidential election in the 107 territorial French departments and in an artificial department that groups the French electors living abroad.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(France2017D)</code></pre>


<h3>Format</h3>

<p>A table containing 108 observations and 13 variables:
</p>

<dl>
<dt>ABSTENTION</dt><dd><p>Number of people abstaining (NonVoters) in the first-round of 2017 Presidential Election.</p>
</dd>
<dt>BLANK_NULL</dt><dd><p>Number of people voting either blank or null in the first-round of 2017 Presidential Election.</p>
</dd>
<dt>MACRON</dt><dd><p>Number of votes gained at a national level by Emmanuel Macron in the
first-round of 2017 Presidential Election.</p>
</dd>
<dt>LE_PEN</dt><dd><p>Number of votes gained at a national level by Marine Le Pen in the
first-round of 2017 Presidential Election.</p>
</dd>
<dt>FILLON</dt><dd><p>Number of votes gained at a national level by Francois Fillon in the
first-round of 2017 Presidential Election.</p>
</dd>
<dt>MELENCHON</dt><dd><p>Number of votes gained at a national level by Jean-Luc Melenchon in the
first-round of 2017 Presidential Election.</p>
</dd>
<dt>HAMON</dt><dd><p>Number of votes gained at a national level by Benoit Hamon in the
first-round of 2017 Presidential Election.</p>
</dd>
<dt>DUPONT.AIGNAN</dt><dd><p>Number of votes gained at a national level by Nicolas Dupont-Aignan in the
first-round of 2017 Presidential Election.</p>
</dd>
<dt>OTHERS</dt><dd><p>Number of votes gained at a national level by the rest of candidates in the
first-round of 2017 Presidential Election.</p>
</dd>
<dt>ABSTENTION2</dt><dd><p>Number of people abstaining (NonVoters) in the second-round of 2017 Presidential Election.</p>
</dd>
<dt>BLANK_NULL2</dt><dd><p>Number of people voting either blank or null in the second-round of 2017 Presidential Election.</p>
</dd>
<dt>MACRON2</dt><dd><p>Number of votes gained at a national level by Emmanuel Macron in the
second-round of 2017 Presidential Election</p>
</dd>
<dt>LE_PEN2</dt><dd><p>Number of votes gained at a national level by Marine Le Pen in the
second-round of 2017 Presidential Election</p>
</dd>
</dl>


<h3>Source</h3>

<p>Own elaboration from data available in <a href="https://www.conseil-constitutionnel.fr/">https://www.conseil-constitutionnel.fr/</a>, retrieved 3 March 2020.
</p>

<hr>
<h2 id='France2017P'>
2017 French Presidential Election. Regional provisional results.
</h2><span id='topic+France2017P'></span>

<h3>Description</h3>

<p>Data frame containing the provisional results of the first and second rounds of the 2017 French presidential election in the 12 French continental regions (Auvergne-Rhone-Alpes, Bourgogne-Franche-Comte, Brittany, Centre-Val de Loire, Grand Est, Hauts-de-France, Ile-de-France, Normandy, Nouvelle-Aquitaine, Occitanie, Pays de la Loire, Provence-Alpes-Cote d'Azur) plus an additional region that covers Corsica and the rest of French overseas regions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(France2017P)</code></pre>


<h3>Format</h3>

<p>A table containing 13 observations and 12 variables:
</p>

<dl>
<dt>ABSTENTION</dt><dd><p>Number of people abstaining (NonVoters) and voting either blank
or null in the first-round of 2017 Presidential Election.</p>
</dd>
<dt>MACRON</dt><dd><p>Number of votes gained at a national level by Emmanuel Macron in the
first-round of 2017 Presidential Election.</p>
</dd>
<dt>LE_PEN</dt><dd><p>Number of votes gained at a national level by Marine Le Pen in the
first-round of 2017 Presidential Election.</p>
</dd>
<dt>FILLON</dt><dd><p>Number of votes gained at a national level by Francois Fillon in the
first-round of 2017 Presidential Election.</p>
</dd>
<dt>MELENCHON</dt><dd><p>Number of votes gained at a national level bu Jean-Luc Melenchon in the
first-round of 2017 Presidential Election.</p>
</dd>
<dt>HAMON</dt><dd><p>Number of votes gained at a national level by Benoit Hamon in the
first-round of 2017 Presidential Election.</p>
</dd>
<dt>DUPONT</dt><dd><p>Number of votes gained at a national level by Nicolas Dupont-Aignan in the
first-round of 2017 Presidential Election.</p>
</dd>
<dt>OTHERS</dt><dd><p>Number of votes gained at a national level by the rest of candidates in the
first-round of 2017 Presidential Election.</p>
</dd>
<dt>ABSTENTION2</dt><dd><p>Number of people abstaining (NonVoters) in the second-round of 2017 Presidential Election.</p>
</dd>
<dt>BLANK_NULL</dt><dd><p>Number of people voting either blank or null in the second-round of 2017 Presidential Election.</p>
</dd>
<dt>MACRON2</dt><dd><p>Number of votes gained at a national level by Emmanuel Macron in the
second-round of 2017 Presidential Election</p>
</dd>
<dt>LE_PEN2</dt><dd><p>Number of votes gained at a national level by Marine Le Pen in the
second-round of 2017 Presidential Election</p>
</dd>
</dl>


<h3>Source</h3>

<p>Own elaboration from data available in <a href="https://www.francetvinfo.fr/elections/resultats/">https://www.francetvinfo.fr/elections/resultats/</a>, retrieved 7 May 2017.
</p>

<hr>
<h2 id='lclphom'>Implements lclphom algorithm</h2><span id='topic+lclphom'></span>

<h3>Description</h3>

<p>Estimates RxC (JxK) vote transfer matrices (ecological contingency tables) with lclphom
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lclphom(
  votes_election1,
  votes_election2,
  new_and_exit_voters = c("raw", "regular", "ordinary", "enriched", "adjust1", "adjust2",
    "simultaneous", "semifull", "full", "fullreverse", "gold"),
  apriori = NULL,
  lambda = 0.5,
  uniform = TRUE,
  structural_zeros = NULL,
  integers = FALSE,
  iter.max = 1000,
  type.errors = "posterior",
  distance.local = c("abs", "max", "none"),
  verbose = TRUE,
  solver = "lp_solve",
  integers.solver = "symphony",
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="lclphom_+3A_votes_election1">votes_election1</code></td>
<td>
<p>data.frame (or matrix) of order IxJ1 with the votes gained by
(or the counts corresponding to) the J1 political options competing
(available) on election 1 (or origin) in the I units considered.
In general, the row marginals of the I tables corresponding
to the units.</p>
</td></tr>
<tr><td><code id="lclphom_+3A_votes_election2">votes_election2</code></td>
<td>
<p>data.frame (or matrix) of order IxK2
with the votes gained by (or the counts corresponding to) the K2
political options competing (available) on election 2 (or destination)
in the I (territorial) units considered. In general, the column marginals
of the I tables corresponding to the units.</p>
</td></tr>
<tr><td><code id="lclphom_+3A_new_and_exit_voters">new_and_exit_voters</code></td>
<td>
<p>A character string indicating the level of information available
in <code>votes_election1</code> and <code>votes_election2</code> regarding new entries
and exits of the election censuses between the two elections.
This argument allows, in addition to the options discussed in Pavia
(2023), three more options. This argument admits eleven different values:
<code>raw</code>, <code>regular</code>, <code>ordinary</code>, <code>enriched</code>, <code>adjust1</code>, <code>adjust2</code>,
<code>simultaneous</code>, <code>semifull</code>, <code>full</code>, <code>fullreverse</code> and <code>gold</code>.
Default, <code>raw</code>.</p>
</td></tr>
<tr><td><code id="lclphom_+3A_apriori">apriori</code></td>
<td>
<p>data.frame (or matrix) of order J0xK0 with an initial estimate of the
(row-standarized) global voter transition proportions/fractions, pjk0, between
the first J0 (election) options of election 1 and the first K0 (election) options
of election 2. This matrix can contain some missing values. When no a priori
information is available <code>apriori</code> is a null object. Default, <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="lclphom_+3A_lambda">lambda</code></td>
<td>
<p>A number between 0 and 1, informing the relative weight the user assigns to the
<code>apriori</code> information. Setting <code>lambda = 0</code> is equivalent to not having a priori
information (i.e., <code>apriori = NULL</code>). Default, <code>0.5</code>.</p>
</td></tr>
<tr><td><code id="lclphom_+3A_uniform">uniform</code></td>
<td>
<p>A <code>TRUE/FALSE</code> value that informs whether census exits impact all the electoral options
in a (relatively) similar fashion in all iterations, including iteration 0 and
when deriving units tables. If <code>uniform = TRUE</code> typically at least one of the equations
among equations (6) to (11) of Pavia (2023) is included in the underlying model.
This parameter has no effect in <code>simultaneous</code> scenarios. It also has not impact
in <code>raw</code> and <code>regular</code> scenarios when no net exits are estimated by the function
from the provided information. Default, <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="lclphom_+3A_structural_zeros">structural_zeros</code></td>
<td>
<p>Default <code>NULL</code>. A list of vectors of length two, indicating the election options
for which no transfer of votes are allowed between election 1 and election 2.
For instance, when new_and_exit_voters is set to <code>"semifull"</code>,
lphom implicitly states <code>structural_zeros = list(c(J1, K2))</code>.</p>
</td></tr>
<tr><td><code id="lclphom_+3A_integers">integers</code></td>
<td>
<p>A <code>TRUE/FALSE</code> value that indicates whether the problem is solved in integer values
in both iterations, including iteration zero (lphom) and the rest of iterations,
when deriving unit tables solutions. If <code>integers = TRUE</code>, the LP matrices are
approximated to the closest integer solution solving
the corresponding Integer Linear Program. Default, <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="lclphom_+3A_iter.max">iter.max</code></td>
<td>
<p>Maximum number of iterations to be performed. The process ends when either the
number of iterations reaches <code>iter.max</code> or when there is no error reduction in any
local unit between two consecutive iterations. By default, <code>1000</code>.</p>
</td></tr>
<tr><td><code id="lclphom_+3A_type.errors">type.errors</code></td>
<td>
<p>A string argument that indicates whether the errors (distance to homogeneity) to be
computed for the temporary local solutions are calculated taking as reference the
previous global matrix (the one that is used to derive the temporary local solution)
or taking as reference the posterior global matrix (the one in which the temporary
local solution is integrated). This argument admits two values: <code>previous</code> and <code>posterior</code>.
Default, <code>posterior</code>.</p>
</td></tr>
<tr><td><code id="lclphom_+3A_distance.local">distance.local</code></td>
<td>
<p>A string argument that indicates whether the second step of the lphom_local algorithm
should be performed to solve potential indeterminacies of local solutions.
Default, <code>"abs"</code>.
If <code>distance.local = "abs"</code> lphom_local selects in its second step the matrix
closer to the temporary global solution under L_1 norm, among the first step compatible matrices.
If <code>distance.local = "max"</code> lphom_local selects in its second step the matrix
closer to the temporary global solution under L_Inf norm, among the first step compatible matrices.
If <code>distance.local = "none"</code>, the second step of lphom_local is not performed.</p>
</td></tr>
<tr><td><code id="lclphom_+3A_verbose">verbose</code></td>
<td>
<p>A <code>TRUE/FALSE</code> value that indicates if a summary of the results of the computations performed
to estimate net entries and exits should be printed on the screen. Default, <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="lclphom_+3A_solver">solver</code></td>
<td>
<p>A character string indicating the linear programming solver to be used, only
<code>lp_solve</code> and <code>symphony</code> are allowed. By default, <code>lp_solve</code>. The package <code>Rsymphony</code>
needs to be installed for the option <code>symphony</code> to be used.</p>
</td></tr>
<tr><td><code id="lclphom_+3A_integers.solver">integers.solver</code></td>
<td>
<p>A character string indicating the linear programming solver to be used for
approximating the LP solution to the closest integer solution.
Only <code>symphony</code> and <code>lp_solve</code> are allowed. By default, <code>symphony</code>.
The package <code>Rsymphony</code> needs to be installed for the
option <code>symphony</code> to be used. Only used when <code>integers = TRUE</code>.</p>
</td></tr>
<tr><td><code id="lclphom_+3A_...">...</code></td>
<td>
<p>Other arguments to be passed to the function. Not currently used.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Description of the <code>new_and_exit_voters</code> argument in more detail.
</p>

<ul>
<li> <p><code>raw</code>: The default value. This argument accounts for the most plausible scenario when
estimating vote transfer matrices. A scenario with two elections elapsed at least
some months where only the raw election data recorded in the I (territorial) units,
in which the electoral space under study is divided, are available.
In this scenario, net exits and net entries are estimated according to
equation (7) of Romero et al. (2020). When both net entries and exits are no
null, constraint (15) of Pavia (2023) applies. If there are net exits and <code>uniform = TRUE</code>
either constraints (6) or (8) and (15) of Pavia (2023) are imposed. In this scenario,
J could be equal to J1 or J1 + 1 and K equal to K2 or K2 + 1.
</p>
</li>
<li> <p><code>regular</code>: This value accounts for a scenario with
two elections elapsed at least some months where (i) the column J1
of <code>votes_election1</code> corresponds to new young electors who have the right
to vote for the first time, (ii) net exits and maybe other additional
net entries are computed according to equation (7) of Romero et al. (2020), and
(iii) we can (or not) assume that net exits impact equally all the first J1 - 1
options of election 1. When both net entries and exits are no null, constraints
(13) and (15) of Pavia (2023) apply. If <code>uniform = TRUE</code> and there are net exits either
constraints (8) or (11) of Pavia (2023), depending on whether there are or not net
entries, are also imposed. In this scenario, J could be equal to J1 or J1 + 1 and
K equal to K2 or K2 + 1. Note that this scenario could be also used if
column J1 of <code>votes_election1</code> would correspond to immigrants instead of
new young electors.
</p>
</li>
<li> <p><code>ordinary</code>: This value accounts for a scenario
with two elections elapsed at least some months where (i) the column K1
of <code>votes_election2</code> corresponds to electors who died in the period between
elections, (ii) net entries and maybe other additional net exits are
computed according to equation (7) of Romero et al. (2020), and (iii) we can
assume (or not) that exits impact equally all the J1 options of election 1.
When both net entries and exits are no null, constraints (14) and
(15) of Pavia (2023) apply and if <code>uniform = TRUE</code> either constraints
(8) and (9) or, without net entries, (6) and (7) of Pavia (2023) are also imposed.
In this scenario, J could be equal to J1 or J1 + 1 and K equal to K2 or K2 + 1.
Note that this scenario could be also used if column K1 of
<code>votes_election2</code> would correspond to emigrants instead of deaths.
</p>
</li>
<li> <p><code>enriched</code>: This value accounts for a scenario that somehow combine <code>regular</code> and
<code>ordinary</code> scenarios. We consider two elections elapsed at least some months where
(i) the column J1 of <code>votes_election1</code> corresponds to new young electors
who have the right to vote for the first time, (ii) the column K2 of
<code>votes_election2</code> corresponds to electors who died in the interperiod
election, (iii) other (net) entries and (net) exits are computed according
to equation (7) of Romero et al. (2020), and (iv) we can assume
(or not) that exits impact equally all the J1 - 1 options of election 1.
When both net entries and exits are no null, constraints (12) to
(15) of Pavia (2023) apply and if <code>uniform = TRUE</code> constraints
(10) and (11) of Pavia (2023) are also imposed. In this scenario, J could be equal
to J1 or J1 + 1 and K equal to K2 or K2 + 1. Note that this scenario could be also used if
the column J1 of <code>votes_election1</code> would correspond to immigrants instead of
new young electors and/or if column K1 of <code>votes_election2</code> would correspond
to emigrants instead of deaths.
</p>
</li>
<li> <p><code>adjust1</code>: This value accounts for a scenario
with two elections elapsed at least some months where the census in
each of the I polling units of the first election (the row-sums of <code>votes_election1</code>) are
proportionally adjusted to match the corresponding census of the polling units in the
second election (the row-sums of <code>votes_election2</code>).
If <code>integers = TRUE</code>, each row in <code>votes_election1</code> is proportionally adjusted to the closest integer
vector whose sum is equal to the sum of the corresponding row in <code>votes_election2</code>.
</p>
</li>
<li> <p><code>adjust2</code>: This value accounts for a scenario
with two elections elapsed at least some months where the census in
each of the I polling units of the second election (the row-sums of <code>votes_election2</code>)
are proportionally adjusted to match the corresponding census of the polling units
in the first election (the row-sums of <code>votes_election1</code>).
If <code>integers = TRUE</code>, each row in <code>votes_election2</code> is adjusted to the closest integer
vector whose sum is equal to the sum of the corresponding row in <code>votes_election1</code>.
</p>
</li>
<li> <p><code>simultaneous</code>: This is the value to be used in classical ecological inference problems,
such as in ecological studies of racial voting, and in scenarios with two simultaneous elections.
In this scenario, the sum by rows of <code>votes_election1</code> and <code>votes_election2</code> must coincide.
Constraints defined by equations (8) and (9) of Romero et al. (2020) are not included in
the model. In this case, the lphom function just implements the basic model defined,
for instance, by equations (1) to (5) of Pavia (2024).
</p>
</li>
<li> <p><code>semifull</code>: This value accounts for a scenario with two elections elapsed at least some
months, where: (i) the column J1 = J of <code>votes_election1</code> totals new
electors (young and immigrants) that have the right to vote for the first time and
(ii) the column K2 = K of <code>votes_election2</code> corresponds to total exits of the census
lists (due to death or emigration). In this scenario, the sum by rows of
<code>votes_election1</code> and <code>votes_election2</code> must agree and constraint (15)
of Pavia (2023) apply. Additionally, if <code>uniform = TRUE</code> constraints
(8) of Pavia (2023) are also imposed.
</p>
</li>
<li> <p><code>full</code>: This value accounts for a scenario with two elections elapsed at least some
months, where (i) the column J - 1 of <code>votes_election1</code> totals new young
electors that have the right to vote for the first time, (ii) the column J (=J1)
of <code>votes_election1</code> measures new immigrants that have the right to vote and
(iii) the column K (=K2) of <code>votes_election2</code> corresponds to total exits of the census
lists (due to death or emigration). In this scenario, the sum by rows of
<code>votes_election1</code> and <code>votes_election2</code> must agree and constraints (13)
and (15) of Pavia (2023) apply.  Additionally, if <code>uniform = TRUE</code> constraints
(11) of Pavia (2023) are also imposed.
</p>
</li>
<li> <p><code>fullreverse</code>: This value is somehow the mirror version of <code>full</code>.
It accounts for a scenario with two elections elapsed at least some
months, where (i) the column J1 = J of <code>votes_election1</code> totals new
electors (young and immigrants) that have the right to vote for the first time and
(ii) where total exits are separated out between exits due to emigration
(column K - 1 of <code>votes_election2</code>) and death (column K of <code>votes_election2</code>).
In this scenario, the sum by rows of <code>votes_election1</code> and <code>votes_election2</code> must
agree and constraints (14) and (15) of Pavia (2023) apply.
Additionally, if <code>uniform = TRUE</code> constraints (8) and (9) of Pavia (2023) are also imposed.
</p>
</li>
<li> <p><code>gold</code>: This value accounts for a scenario similar to <code>full</code>, where total exits are
separated out between exits due to emigration (column K - 1 of <code>votes_election2</code>)
and death (column K of <code>votes_election2</code>). In this scenario, the sum by rows
of <code>votes_election1</code> and <code>votes_election2</code> must agree. Constraints (12) to
(15) of Pavia (2023) apply and if <code>uniform = TRUE</code> constraints (10) and (11)
of Pavia (2023) are also imposed.
</p>
</li></ul>



<h3>Value</h3>

<p>A list with the following components
</p>
<table>
<tr><td><code>VTM</code></td>
<td>
<p> A matrix of order J'xK' (where J'=J-1 or J and K'=K-1 or K) with the estimated percentages of row-standardized vote transitions from election 1 to election 2.
In <code>raw</code>, <code>regular</code>, <code>ordinary</code> and <code>enriched</code> scenarios when the percentage of net entries is small, less than 1% of the census in all units,
net entries are omitted (i.e., the number of rows of <code>VTM</code> is equal to J1) even when estimates for net entries different from zero are obtained. Likewise, in the same scenarios when the percentage of net exits is small, less than 1%
of the census in all units, net exits are omitted (i.e., the number of rows of <code>VTM</code> is equal to K2) even when estimates for net exits different from zero are obtained.</p>
</td></tr>
<tr><td><code>VTM.votes</code></td>
<td>
<p> A matrix of order J'xK' (where J'=J-1 or J and K'=K-1 or K) with the estimated vote transitions from election 1 to election 2.
In <code>raw</code>, <code>regular</code>, <code>ordinary</code> and <code>enriched</code> scenarios when the percentage of net entries is small, less than 1% of the census,
net entries are omitted (i.e., J = J1) even when estimates for net entries different from zero are obtained. Likewise, in the same scenarios when the percentage of net exits is small, less than 1%
of the census, net exits are omitted (i.e., K = K2) even when estimates for net exits different from zero are obtained.</p>
</td></tr>
<tr><td><code>OTM</code></td>
<td>
<p> A matrix of order KxJ with the estimated percentages of the origin of the votes obtained for the different options of election 2.</p>
</td></tr>
<tr><td><code>HETe</code></td>
<td>
<p> The estimated heterogeneity index as defined in equation (15) of Pavia and Romero (2022).</p>
</td></tr>
<tr><td><code>VTM.complete</code></td>
<td>
<p> A matrix of order JxK with the estimated proportions of row-standardized vote transitions from election 1 to election 2, including in <code>raw</code>, <code>regular</code>, <code>ordinary</code> and <code>enriched</code> scenarios the row and the column corresponding to net_entries and net_exits even when they are really small, less than 1% in all units.</p>
</td></tr>
<tr><td><code>VTM.complete.votes</code></td>
<td>
<p> A matrix of order JxK with the estimated vote transitions from election 1 to election 2, including in <code>raw</code>, <code>regular</code>, <code>ordinary</code> and <code>enriched</code> scenarios the row and the column corresponding to net_entries and net_exits even when they are really small, less than 1% in all units.</p>
</td></tr>
<tr><td><code>VTM.prop.units</code></td>
<td>
<p> An array of order JxKxI with the estimated proportions of vote transitions from election 1 to election 2 attained for each unit in the solution.</p>
</td></tr>
<tr><td><code>VTM.votes.units</code></td>
<td>
<p> An array of order JxKxI with the estimated matrix of vote transitions from election 1 to election 2 attained for for each unit in the solution.</p>
</td></tr>
<tr><td><code>VTM.complete.last.iter</code></td>
<td>
<p> A matrix of order JxK with the estimated proportions of vote transitions from election 1 to election 2, including in <code>raw</code>, <code>regular</code>, <code>ordinary</code> and <code>enriched</code> scenarios the row and the column corresponding to net_entries and net_exits even when they are really small, less than 1% in all units, corresponding to the final iteration.</p>
</td></tr>
<tr><td><code>VTM.sequence</code></td>
<td>
<p> Array of order JxKx(iter+1) (where <code>iter</code> is the efective number of iterations performed) of the intermediate estimated matrices corresponding to each iteration.</p>
</td></tr>
<tr><td><code>HETe.sequence</code></td>
<td>
<p> Numeric vector of length <code>iter+1</code> with the <code>HETe</code> coefficients corresponding to the matrices in <code>VTM.sequence</code>.</p>
</td></tr>
<tr><td><code>VTM.prop.units.last.iter</code></td>
<td>
<p> An array of order JxKxI with the estimated proportions of vote transitions from election 1 to election 2 attained for each unit in the final iteration.</p>
</td></tr>
<tr><td><code>VTM.votes.units.last.iter</code></td>
<td>
<p> An array of order JxKxI with the estimated matrix of vote transitions from election 1 to election 2 attained for each unit in the final iteration.</p>
</td></tr>
<tr><td><code>zeros</code></td>
<td>
<p> A list of vectors of length two, indicating the election options for which no transfer of votes are allowed between election 1 and election 2.</p>
</td></tr>
<tr><td><code>iter</code></td>
<td>
<p> The real final number of iterations performed before ending the process.</p>
</td></tr>
<tr><td><code>iter.units</code></td>
<td>
<p> A matrix of order Ix(iter+1) with the number of iteration corresponding to the solution selected for each unit
in each iteration.</p>
</td></tr>
<tr><td><code>errors</code></td>
<td>
<p> A vector of length I with the minimal error observed in the sequence for each unit. It corresponds to
the unit-error associated with the solution linked with either <code>VTM.prop.units</code> or <code>VTM.votes.units</code>.</p>
</td></tr>
<tr><td><code>deterministic.bounds</code></td>
<td>
<p> A list of two matrices of order JxK and two arrays of order JxKxI containing for each vote transition the lower and upper allowed proportions given the observed aggregates.</p>
</td></tr>
<tr><td><code>inputs</code></td>
<td>
<p> A list containing all the objects with the values used as arguments by the function.</p>
</td></tr>
<tr><td><code>origin</code></td>
<td>
<p> A matrix with the final data used as votes of the origin election after taking into account the level of information available regarding to new entries and exits of the election censuses between the two elections.</p>
</td></tr>
<tr><td><code>destination</code></td>
<td>
<p> A matrix with the final data used as votes of the origin election after taking into account the level of information available regarding to new entries and exits of the election censuses between the two elections.</p>
</td></tr>
<tr><td><code>EHet</code></td>
<td>
<p> A matrix of order IxK measuring in each spatial unit a distance to the homogeneity hypothesis, that is, the differences under the homogeneity hypothesis between the actual recorded results and the expected results with the solution in each territorial unit for each option of election 2.</p>
</td></tr>
<tr><td><code>solution_init</code></td>
<td>
<p> A list with the main outputs produced by <strong>lphom()</strong>.</p>
</td></tr>
</table>

<ul>
<li> <p><code>VTM_init</code>: A matrix of order J'xK' with the estimated percentages of vote transitions from election 1 to election 2 initially obtained by <strong>lphom()</strong>.
</p>
</li>
<li> <p><code>VTM.votes_init</code>: A matrix of order J'xK' with the estimated vote transitions from election 1 to election 2 initially obtained by <strong>lphom()</strong>.
</p>
</li>
<li> <p><code>OTM_init</code>: A matrix of order KxJ with the estimated percentages of the origin of the votes obtained for the different options of election 2 initially obtained by <strong>lphom()</strong>.
</p>
</li>
<li> <p><code>HETe_init</code>: The estimated heterogeneity index defined in equation (10) of Romero et al. (2020).
</p>
</li>
<li> <p><code>EHet_init</code>: A matrix of order IxK measuring in each spatial unit the distance to the homogeneity hypothesis, that is, the differences under the homogeneity hypothesis between the actual recorded results and the expected results, using the <strong>lphom()</strong> solution, in each territorial unit for each option of election 2.
</p>
</li>
<li> <p><code>VTM.complete_init</code>: A matrix of order JxK with the estimated proportions of vote transitions from election 1 to election 2 initially obtained by <strong>lphom()</strong>, including in <code>raw</code>, <code>regular</code>, <code>ordinary</code> and <code>enriched</code> scenarios the row and the column corresponding to net_entries and net_exits even when they are really small, less than 1% in all units.
</p>
</li>
<li> <p><code>VTM.complete.votes_init</code>: A matrix of order JxK with the estimated vote transitions from election 1 to election 2 initially obtained by <strong>lphom()</strong>, including in <code>raw</code>, <code>regular</code>, <code>ordinary</code> and <code>enriched</code> scenarios the row and the column corresponding to net_entries and net_exits even when they are really small, less than 1% in all units.
</p>
</li></ul>



<h3>Author(s)</h3>

<p>Jose M. Pavia, <a href="mailto:pavia@uv.es">pavia@uv.es</a>
</p>


<h3>References</h3>

<p>Pavia, JM, and Romero, R (2022). Improving estimates accuracy of voter transitions. Two new algorithms for ecological inference based on linear programming, <em>Sociological Methods &amp; Research</em>. <a href="https://doi.org/10.1177/00491241221092725">doi:10.1177/00491241221092725</a>.
</p>
<p>Pavia, JM. (2024). A local convergent ecological inference algorithm for RxC tables.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+lphom">lphom</a></code> <code><a href="#topic+tslphom">tslphom</a></code> <code><a href="#topic+nslphom">nslphom</a></code> <code><a href="#topic+rslphom">rslphom</a></code>
</p>
<p>Other linear programing ecological inference functions: 
<code><a href="#topic+lp_apriori">lp_apriori</a>()</code>,
<code><a href="#topic+lphom_dual">lphom_dual</a>()</code>,
<code><a href="#topic+lphom_joint">lphom_joint</a>()</code>,
<code><a href="#topic+lphom">lphom</a>()</code>,
<code><a href="#topic+nslphom_dual">nslphom_dual</a>()</code>,
<code><a href="#topic+nslphom_joint">nslphom_joint</a>()</code>,
<code><a href="#topic+nslphom">nslphom</a>()</code>,
<code><a href="#topic+rslphom">rslphom</a>()</code>,
<code><a href="#topic+tslphom_dual">tslphom_dual</a>()</code>,
<code><a href="#topic+tslphom_joint">tslphom_joint</a>()</code>,
<code><a href="#topic+tslphom">tslphom</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>mt.lc &lt;- lclphom(France2017P[, 1:8] , France2017P[, 9:12], new_and_exit_voters= "raw")
mt.lc$VTM
mt.lc$HETe
mt.lc$solution_init$HETe_init

</code></pre>

<hr>
<h2 id='lp_apriori'>Implements lp_apriori models</h2><span id='topic+lp_apriori'></span>

<h3>Description</h3>

<p>Adjusts an initial J0xK0 vote transfer matrix (ecological contingency table) to guarantee (i) congruency with aggregate results and (ii) completeness.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lp_apriori(
  votes_election1,
  votes_election2,
  apriori,
  weights = "constant",
  new_and_exit_voters = "raw",
  uniform = TRUE,
  solver = "lp_solve",
  integers = TRUE,
  integers.solver = "symphony",
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="lp_apriori_+3A_votes_election1">votes_election1</code></td>
<td>
<p>data.frame (or matrix) of order IxJ1 (or vector of length J1)
with the votes gained by (or the numbers corresponding to) the J1
political options competing on election 1 (or origin) in the I
territorial units considered.</p>
</td></tr>
<tr><td><code id="lp_apriori_+3A_votes_election2">votes_election2</code></td>
<td>
<p>data.frame (or matrix) of order IxK2 (or vector of length K2)
with the votes gained by (or the numbers corresponding to) the K2
political options competing on election 2 (or destination) in the I
territorial units considered.</p>
</td></tr>
<tr><td><code id="lp_apriori_+3A_apriori">apriori</code></td>
<td>
<p>data.frame (or matrix) of order J0xK0 with an initial estimate of the
(row-standarized) voter transition proportions/fractions, pjk0, between
the first J0 election options of election 1 and the first K0 election options
of election 2. It could be also a data.frame (matrix) of counts.
This matrix can contain some missing values.</p>
</td></tr>
<tr><td><code id="lp_apriori_+3A_weights">weights</code></td>
<td>
<p>Either a numeric matrix (or data.frame) of order J0xK0 of weights, wjk, or
a character string indicating the structure of weights to be used. As character
string this argument admits seven different values: <code>constant</code>, <code>x</code>, <code>xy</code>, <code>expected</code>, <code>counts</code>,
<code>sqrt</code>, or <code>sd</code>. Default, <code>constant</code> (i.e., wjk = 1). The wjk coefficients measure the
(relative) degree of confidence we have in the a priori values pjk0.
Everything else constant, the greater a weight wjk the closer the estimated pjk and
the pjk0 proportions will be.
As numeric matrix, this matrix can contain some missing values, usually located in the same cells than
the missing values of <code>apriori</code>.</p>
</td></tr>
<tr><td><code id="lp_apriori_+3A_new_and_exit_voters">new_and_exit_voters</code></td>
<td>
<p>A character string indicating the level of information available
in <code>votes_election1</code> and <code>votes_election2</code> regarding new entries
and exits of the election censuses between the two elections.
This argument allows, in addition to the options discussed in Pavia
(2023), three more options. This argument admits eleven different values:
<code>raw</code>, <code>regular</code>, <code>ordinary</code>, <code>enriched</code>, <code>adjust1</code>, <code>adjust2</code>,
<code>simultaneous</code>, <code>semifull</code>, <code>full</code>, <code>fullreverse</code> and <code>gold</code>.
Default, <code>raw</code>.</p>
</td></tr>
<tr><td><code id="lp_apriori_+3A_uniform">uniform</code></td>
<td>
<p>A TRUE/FALSE value that indicates if census exits affect all the electoral options in
a (relatively) similar fashion; depending on the scenario any equation(s) among equations (6) to (11) of
Pavia (2023) could be used in the underlying model. Default, <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="lp_apriori_+3A_solver">solver</code></td>
<td>
<p>A character string indicating the linear programming solver to be used, only
<code>lp_solve</code> and <code>symphony</code> are allowed. By default, <code>lp_solve</code>. The package <code>Rsymphony</code>
needs to be installed for the option <code>symphony</code> to be used.</p>
</td></tr>
<tr><td><code id="lp_apriori_+3A_integers">integers</code></td>
<td>
<p>A TRUE/FALSE value that indicates whether the LP solution of counts (votes) must be
approximate to the closest integer solution using ILP to generate the final solution.
Default, TRUE.</p>
</td></tr>
<tr><td><code id="lp_apriori_+3A_integers.solver">integers.solver</code></td>
<td>
<p>A character string indicating the linear programming solver to be used for
approximating to the closest integer solution. Only <code>symphony</code> and <code>lp_solve</code> are allowed.
By default, <code>symphony</code>. The package <code>Rsymphony</code> needs to be installed for the
option <code>symphony</code> to be used. Only used when <code>integers = TRUE</code>.</p>
</td></tr>
<tr><td><code id="lp_apriori_+3A_...">...</code></td>
<td>
<p>Other arguments to be passed to the function. Not currently used.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Description of the <code>new_and_exit_voters</code> argument in more detail.
</p>

<ul>
<li> <p><code>raw</code>: The default value. This argument accounts for the most plausible scenario when
estimating vote transfer matrices. A scenario with two elections elapsed at least
some months where only the raw election data recorded in the I (territorial) units,
in which the electoral space under study is divided, are available.
In this scenario, net exits and net entries are estimated according to
equation (7) of Romero et al. (2020). When both net entries and exits are no
null, constraint (15) of Pavia (2023) applies. If there are net exits and <code>uniform = TRUE</code>
either constraints (6) or (8) and (15) of Pavia (2023) are imposed. In this scenario,
J could be equal to J1 or J1 + 1 and K equal to K2 or K2 + 1.
</p>
</li>
<li> <p><code>regular</code>: This value accounts for a scenario with
two elections elapsed at least some months where (i) the column J1
of <code>votes_election1</code> corresponds to new young electors who have the right
to vote for the first time, (ii) net exits and maybe other additional
net entries are computed according to equation (7) of Romero et al. (2020), and
(iii) we can (or not) assume that net exits impact equally all the first J1 - 1
options of election 1. When both net entries and exits are no null, constraints
(13) and (15) of Pavia (2023) apply. If <code>uniform = TRUE</code> and there are net exits either
constraints (8) or (11) of Pavia (2023), depending on whether there are or not net
entries, are also imposed. In this scenario, J could be equal to J1 or J1 + 1 and
K equal to K2 or K2 + 1. Note that this scenario could be also used if
column J1 of <code>votes_election1</code> would correspond to immigrants instead of
new young electors.
</p>
</li>
<li> <p><code>ordinary</code>: This value accounts for a scenario
with two elections elapsed at least some months where (i) the column K1
of <code>votes_election2</code> corresponds to electors who died in the period between
elections, (ii) net entries and maybe other additional net exits are
computed according to equation (7) of Romero et al. (2020), and (iii) we can
assume (or not) that exits impact equally all the J1 options of election 1.
When both net entries and exits are no null, constraints (14) and
(15) of Pavia (2023) apply and if <code>uniform = TRUE</code> either constraints
(8) and (9) or, without net entries, (6) and (7) of Pavia (2023) are also imposed.
In this scenario, J could be equal to J1 or J1 + 1 and K equal to K2 or K2 + 1.
Note that this scenario could be also used if column K1 of
<code>votes_election2</code> would correspond to emigrants instead of deaths.
</p>
</li>
<li> <p><code>enriched</code>: This value accounts for a scenario that somehow combine <code>regular</code> and
<code>ordinary</code> scenarios. We consider two elections elapsed at least some months where
(i) the column J1 of <code>votes_election1</code> corresponds to new young electors
who have the right to vote for the first time, (ii) the column K2 of
<code>votes_election2</code> corresponds to electors who died in the interperiod
election, (iii) other (net) entries and (net) exits are computed according
to equation (7) of Romero et al. (2020), and (iv) we can assume
(or not) that exits impact equally all the J1 - 1 options of election 1.
When both net entries and exits are no null, constraints (12) to
(15) of Pavia (2023) apply and if <code>uniform = TRUE</code> constraints
(10) and (11) of Pavia (2023) are also imposed. In this scenario, J could be equal
to J1 or J1 + 1 and K equal to K2 or K2 + 1. Note that this scenario could be also used if
the column J1 of <code>votes_election1</code> would correspond to immigrants instead of
new young electors and/or if column K1 of <code>votes_election2</code> would correspond
to emigrants instead of deaths.
</p>
</li>
<li> <p><code>adjust1</code>: This value accounts for a scenario
with two elections elapsed at least some months where the census in
each of the I polling units of the first election (the row-sums of <code>votes_election1</code>) are
proportionally adjusted to match the corresponding census of the polling units in the
second election (the row-sums of <code>votes_election2</code>).
If <code>integers = TRUE</code>, each row in <code>votes_election1</code> is proportionally adjusted to the closest integer
vector whose sum is equal to the sum of the corresponding row in <code>votes_election2</code>.
</p>
</li>
<li> <p><code>adjust2</code>: This value accounts for a scenario
with two elections elapsed at least some months where the census in
each of the I polling units of the second election (the row-sums of <code>votes_election2</code>)
are proportionally adjusted to match the corresponding census of the polling units
in the first election (the row-sums of <code>votes_election1</code>).
If <code>integers = TRUE</code>, each row in <code>votes_election2</code> is adjusted to the closest integer
vector whose sum is equal to the sum of the corresponding row in <code>votes_election1</code>.
</p>
</li>
<li> <p><code>simultaneous</code>: This is the value to be used in classical ecological inference problems,
such as in ecological studies of racial voting, and in scenarios with two simultaneous elections.
In this scenario, the sum by rows of <code>votes_election1</code> and <code>votes_election2</code> must coincide.
Constraints defined by equations (8) and (9) of Romero et al. (2020) are not included in
the model. In this case, the lphom function just implements the basic model defined,
for instance, by equations (1) to (5) of Pavia (2024).
</p>
</li>
<li> <p><code>semifull</code>: This value accounts for a scenario with two elections elapsed at least some
months, where: (i) the column J1 = J of <code>votes_election1</code> totals new
electors (young and immigrants) that have the right to vote for the first time and
(ii) the column K2 = K of <code>votes_election2</code> corresponds to total exits of the census
lists (due to death or emigration). In this scenario, the sum by rows of
<code>votes_election1</code> and <code>votes_election2</code> must agree and constraint (15)
of Pavia (2023) apply. Additionally, if <code>uniform = TRUE</code> constraints
(8) of Pavia (2023) are also imposed.
</p>
</li>
<li> <p><code>full</code>: This value accounts for a scenario with two elections elapsed at least some
months, where (i) the column J - 1 of <code>votes_election1</code> totals new young
electors that have the right to vote for the first time, (ii) the column J (=J1)
of <code>votes_election1</code> measures new immigrants that have the right to vote and
(iii) the column K (=K2) of <code>votes_election2</code> corresponds to total exits of the census
lists (due to death or emigration). In this scenario, the sum by rows of
<code>votes_election1</code> and <code>votes_election2</code> must agree and constraints (13)
and (15) of Pavia (2023) apply.  Additionally, if <code>uniform = TRUE</code> constraints
(11) of Pavia (2023) are also imposed.
</p>
</li>
<li> <p><code>fullreverse</code>: This value is somehow the mirror version of <code>full</code>.
It accounts for a scenario with two elections elapsed at least some
months, where (i) the column J1 = J of <code>votes_election1</code> totals new
electors (young and immigrants) that have the right to vote for the first time and
(ii) where total exits are separated out between exits due to emigration
(column K - 1 of <code>votes_election2</code>) and death (column K of <code>votes_election2</code>).
In this scenario, the sum by rows of <code>votes_election1</code> and <code>votes_election2</code> must
agree and constraints (14) and (15) of Pavia (2023) apply.
Additionally, if <code>uniform = TRUE</code> constraints (8) and (9) of Pavia (2023) are also imposed.
</p>
</li>
<li> <p><code>gold</code>: This value accounts for a scenario similar to <code>full</code>, where total exits are
separated out between exits due to emigration (column K - 1 of <code>votes_election2</code>)
and death (column K of <code>votes_election2</code>). In this scenario, the sum by rows
of <code>votes_election1</code> and <code>votes_election2</code> must agree. Constraints (12) to
(15) of Pavia (2023) apply and if <code>uniform = TRUE</code> constraints (10) and (11)
of Pavia (2023) are also imposed.
</p>
</li></ul>



<h3>Value</h3>

<p>A list with the following components
</p>
<table>
<tr><td><code>VTM</code></td>
<td>
<p> A matrix of order JxK with the estimated percentages of row-standardized vote transitions from election 1 to election 2.
In <code>raw</code>, <code>regular</code>, <code>ordinary</code> and <code>enriched</code> scenarios when the percentage of net entries is small, less than 1% of the census,
net entries are omitted (i.e., J = J1) even when estimates for net entries different from zero are obtained. Likewise, in the same scenarios when the percentage of net exits is small, less than 1%
of the census, net exits are omitted (i.e., K = K2) even when estimates for net exits different from zero are obtained.</p>
</td></tr>
<tr><td><code>VTM.votes</code></td>
<td>
<p> A matrix of order JxK with the estimated vote transitions from election 1 to election 2.
In <code>raw</code>, <code>regular</code>, <code>ordinary</code> and <code>enriched</code> scenarios when the percentage of net entries is small, less than 1% of the census,
net entries are omitted (i.e., J = J1) even when estimates for net entries different from zero are obtained. Likewise, in the same scenarios when the percentage of net exits is small, less than 1%
of the census, net exits are omitted (i.e., K = K2) even when estimates for net exits different from zero are obtained.</p>
</td></tr>
<tr><td><code>weights</code></td>
<td>
<p> A matrix of order JxK with the weights used to adjust the a priori vote transitions from  election 1 to election 2.</p>
</td></tr>
<tr><td><code>OTM</code></td>
<td>
<p> A matrix of order KxJ with the estimated percentages of the origin of the votes obtained for the different options of election 2.</p>
</td></tr>
<tr><td><code>VTM.complete</code></td>
<td>
<p> A matrix of order JxK with the estimated proportions of row-standardized vote transitions from election 1 to election 2.
In <code>raw</code>, <code>regular</code>, <code>ordinary</code> and <code>enriched</code> scenarios, this matrix includes the row and the column corresponding to net entries
and net exits (when they are present) even when they are really small.</p>
</td></tr>
<tr><td><code>VTM.complete.votes</code></td>
<td>
<p> A matrix of order JxK with the estimated vote transitions from election 1 to election 2.
In <code>raw</code>, <code>regular</code>, <code>ordinary</code> and <code>enriched</code> scenarios, this matrix includes the row and the column corresponding to net entries
and net exits (when they are present) even when they are really small.</p>
</td></tr>
<tr><td><code>inputs</code></td>
<td>
<p> A list containing all the objects with the values used as arguments by the function.</p>
</td></tr>
<tr><td><code>origin</code></td>
<td>
<p> A vector with the final data used as votes of the origin election after taking into account the level of information available regarding to new entries and exits of the election censuses between the two elections.</p>
</td></tr>
<tr><td><code>destination</code></td>
<td>
<p> A vector with the final data used as votes of the origin election after taking into account the level of information available regarding to new entries and exits of the election censuses between the two elections.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Jose M. Pavia, <a href="mailto:pavia@uv.es">pavia@uv.es</a>
</p>


<h3>References</h3>

<p>Pavia, JM (2023). Adjustment of initial estimates of voter transition probabilities to guarantee consistency and completeness, <em>SN Social Sciences</em>, 3, 75. <a href="https://doi.org/10.1007/s43545-023-00658-y">doi:10.1007/s43545-023-00658-y</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+lphom">lphom</a></code> <code><a href="#topic+tslphom">tslphom</a></code> <code><a href="#topic+nslphom">nslphom</a></code> <code><a href="#topic+lclphom">lclphom</a></code>
</p>
<p>Other linear programing ecological inference functions: 
<code><a href="#topic+lclphom">lclphom</a>()</code>,
<code><a href="#topic+lphom_dual">lphom_dual</a>()</code>,
<code><a href="#topic+lphom_joint">lphom_joint</a>()</code>,
<code><a href="#topic+lphom">lphom</a>()</code>,
<code><a href="#topic+nslphom_dual">nslphom_dual</a>()</code>,
<code><a href="#topic+nslphom_joint">nslphom_joint</a>()</code>,
<code><a href="#topic+nslphom">nslphom</a>()</code>,
<code><a href="#topic+rslphom">rslphom</a>()</code>,
<code><a href="#topic+tslphom_dual">tslphom_dual</a>()</code>,
<code><a href="#topic+tslphom_joint">tslphom_joint</a>()</code>,
<code><a href="#topic+tslphom">tslphom</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>P0 &lt;- matrix(c(.75, .02, .15, .08, .01, .01, .97, .01,
               .01, .01, .01, .97, .01, .10, .80, .09,
               .20, .30, .30, .20, .10, .10, .50, .30,
               .10, .30, NA, NA, .25, .20, NA, NA), 
             byrow = TRUE, 8, 4)
mt &lt;- lp_apriori(France2017P[, 1:8], France2017P[, 9:12], P0, integers = FALSE)
</code></pre>

<hr>
<h2 id='lphom'>Implements lphom algorithm</h2><span id='topic+lphom'></span>

<h3>Description</h3>

<p>Estimates RxC (JxK) vote transfer matrices (ecological contingency tables) with lphom
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lphom(
  votes_election1,
  votes_election2,
  new_and_exit_voters = c("raw", "regular", "ordinary", "enriched", "adjust1", "adjust2",
    "simultaneous", "semifull", "full", "fullreverse", "gold"),
  apriori = NULL,
  lambda = 0.5,
  uniform = TRUE,
  structural_zeros = NULL,
  integers = FALSE,
  verbose = TRUE,
  solver = "lp_solve",
  integers.solver = "symphony",
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="lphom_+3A_votes_election1">votes_election1</code></td>
<td>
<p>data.frame (or matrix) of order IxJ1 with the votes gained by
(or the counts corresponding to) the J1 political options competing
(available) on election 1 (or origin) in the I units considered.
In general, the row marginals of the I tables corresponding
to the units.</p>
</td></tr>
<tr><td><code id="lphom_+3A_votes_election2">votes_election2</code></td>
<td>
<p>data.frame (or matrix) of order IxK2
with the votes gained by (or the counts corresponding to) the K2
political options competing (available) on election 2 (or destination)
in the I (territorial) units considered. In general, the column marginals
of the I tables corresponding to the units.</p>
</td></tr>
<tr><td><code id="lphom_+3A_new_and_exit_voters">new_and_exit_voters</code></td>
<td>
<p>A character string indicating the level of information available
in <code>votes_election1</code> and <code>votes_election2</code> regarding new entries
and exits of the election censuses between the two elections.
This argument allows, in addition to the options discussed in Pavia
(2023), three more options. This argument admits eleven different values:
<code>raw</code>, <code>regular</code>, <code>ordinary</code>, <code>enriched</code>, <code>adjust1</code>, <code>adjust2</code>,
<code>simultaneous</code>, <code>semifull</code>, <code>full</code>, <code>fullreverse</code> and <code>gold</code>.
Default, <code>raw</code>.</p>
</td></tr>
<tr><td><code id="lphom_+3A_apriori">apriori</code></td>
<td>
<p>data.frame (or matrix) of order J0xK0 with an initial estimate of the
(row-standarized) global voter transition proportions/fractions, pjk0, between
the first J0 (election) options of election 1 and the first K0 (election) options
of election 2. This matrix can contain some missing values. When no a priori
information is available <code>apriori</code> is a null object. Default, <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="lphom_+3A_lambda">lambda</code></td>
<td>
<p>A number between 0 and 1, informing the relative weight the user assigns to the
<code>apriori</code> information. Setting <code>lambda = 0</code> is equivalent to not having a priori
information (i.e., <code>apriori = NULL</code>). Default, <code>0.5</code>.</p>
</td></tr>
<tr><td><code id="lphom_+3A_uniform">uniform</code></td>
<td>
<p>A <code>TRUE/FALSE</code> value that informs whether census exits affect all the electoral options
in a (relatively) similar fashion. If <code>uniform = TRUE</code> typically at least one of the equations
among equations (6) to (11) of Pavia (2022) is included in the underlying model.
This parameter has never effect in <code>simultaneous</code> scenarios. It also has not impact
in <code>raw</code> and <code>regular</code> scenarios when no net exits are estimated by the function
from the provided information. Default, <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="lphom_+3A_structural_zeros">structural_zeros</code></td>
<td>
<p>Default <code>NULL</code>. A list of vectors of length two, indicating the election options
for which no transfer of votes are allowed between election 1 and election 2.
For instance, when new_and_exit_voters is set to <code>"semifull"</code>,
lphom implicitly states <code>structural_zeros = list(c(J1, K2))</code>.</p>
</td></tr>
<tr><td><code id="lphom_+3A_integers">integers</code></td>
<td>
<p>A <code>TRUE/FALSE</code> value that indicates whether the LP solution of counts (votes) must be
approximate to the closest integer solution using ILP to generate the final solution.
Default, <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="lphom_+3A_verbose">verbose</code></td>
<td>
<p>A <code>TRUE/FALSE</code> value that indicates if a summary of the results of the computations performed
to estimate net entries and exits should be printed on the screen. Default, <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="lphom_+3A_solver">solver</code></td>
<td>
<p>A character string indicating the linear programming solver to be used, only
<code>lp_solve</code> and <code>symphony</code> are allowed. By default, <code>lp_solve</code>. The package <code>Rsymphony</code>
needs to be installed for the option <code>symphony</code> to be used.</p>
</td></tr>
<tr><td><code id="lphom_+3A_integers.solver">integers.solver</code></td>
<td>
<p>A character string indicating the linear programming solver to be used for
approximating the LP solution to the closest integer solution.
Only <code>symphony</code> and <code>lp_solve</code> are allowed. By default, <code>symphony</code>.
The package <code>Rsymphony</code> needs to be installed for the
option <code>symphony</code> to be used. Only used when <code>integers = TRUE</code>.</p>
</td></tr>
<tr><td><code id="lphom_+3A_...">...</code></td>
<td>
<p>Other arguments to be passed to the function. Not currently used.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Description of the <code>new_and_exit_voters</code> argument in more detail.
</p>

<ul>
<li> <p><code>raw</code>: The default value. This argument accounts for the most plausible scenario when
estimating vote transfer matrices. A scenario with two elections elapsed at least
some months where only the raw election data recorded in the I (territorial) units,
in which the electoral space under study is divided, are available.
In this scenario, net exits and net entries are estimated according to
equation (7) of Romero et al. (2020). When both net entries and exits are no
null, constraint (15) of Pavia (2023) applies. If there are net exits and <code>uniform = TRUE</code>
either constraints (6) or (8) and (15) of Pavia (2023) are imposed. In this scenario,
J could be equal to J1 or J1 + 1 and K equal to K2 or K2 + 1.
</p>
</li>
<li> <p><code>regular</code>: This value accounts for a scenario with
two elections elapsed at least some months where (i) the column J1
of <code>votes_election1</code> corresponds to new young electors who have the right
to vote for the first time, (ii) net exits and maybe other additional
net entries are computed according to equation (7) of Romero et al. (2020), and
(iii) we can (or not) assume that net exits impact equally all the first J1 - 1
options of election 1. When both net entries and exits are no null, constraints
(13) and (15) of Pavia (2023) apply. If <code>uniform = TRUE</code> and there are net exits either
constraints (8) or (11) of Pavia (2023), depending on whether there are or not net
entries, are also imposed. In this scenario, J could be equal to J1 or J1 + 1 and
K equal to K2 or K2 + 1. Note that this scenario could be also used if
column J1 of <code>votes_election1</code> would correspond to immigrants instead of
new young electors.
</p>
</li>
<li> <p><code>ordinary</code>: This value accounts for a scenario
with two elections elapsed at least some months where (i) the column K1
of <code>votes_election2</code> corresponds to electors who died in the period between
elections, (ii) net entries and maybe other additional net exits are
computed according to equation (7) of Romero et al. (2020), and (iii) we can
assume (or not) that exits impact equally all the J1 options of election 1.
When both net entries and exits are no null, constraints (14) and
(15) of Pavia (2023) apply and if <code>uniform = TRUE</code> either constraints
(8) and (9) or, without net entries, (6) and (7) of Pavia (2023) are also imposed.
In this scenario, J could be equal to J1 or J1 + 1 and K equal to K2 or K2 + 1.
Note that this scenario could be also used if column K1 of
<code>votes_election2</code> would correspond to emigrants instead of deaths.
</p>
</li>
<li> <p><code>enriched</code>: This value accounts for a scenario that somehow combine <code>regular</code> and
<code>ordinary</code> scenarios. We consider two elections elapsed at least some months where
(i) the column J1 of <code>votes_election1</code> corresponds to new young electors
who have the right to vote for the first time, (ii) the column K2 of
<code>votes_election2</code> corresponds to electors who died in the interperiod
election, (iii) other (net) entries and (net) exits are computed according
to equation (7) of Romero et al. (2020), and (iv) we can assume
(or not) that exits impact equally all the J1 - 1 options of election 1.
When both net entries and exits are no null, constraints (12) to
(15) of Pavia (2023) apply and if <code>uniform = TRUE</code> constraints
(10) and (11) of Pavia (2023) are also imposed. In this scenario, J could be equal
to J1 or J1 + 1 and K equal to K2 or K2 + 1. Note that this scenario could be also used if
the column J1 of <code>votes_election1</code> would correspond to immigrants instead of
new young electors and/or if column K1 of <code>votes_election2</code> would correspond
to emigrants instead of deaths.
</p>
</li>
<li> <p><code>adjust1</code>: This value accounts for a scenario
with two elections elapsed at least some months where the census in
each of the I polling units of the first election (the row-sums of <code>votes_election1</code>) are
proportionally adjusted to match the corresponding census of the polling units in the
second election (the row-sums of <code>votes_election2</code>).
If <code>integers = TRUE</code>, each row in <code>votes_election1</code> is proportionally adjusted to the closest integer
vector whose sum is equal to the sum of the corresponding row in <code>votes_election2</code>.
</p>
</li>
<li> <p><code>adjust2</code>: This value accounts for a scenario
with two elections elapsed at least some months where the census in
each of the I polling units of the second election (the row-sums of <code>votes_election2</code>)
are proportionally adjusted to match the corresponding census of the polling units
in the first election (the row-sums of <code>votes_election1</code>).
If <code>integers = TRUE</code>, each row in <code>votes_election2</code> is adjusted to the closest integer
vector whose sum is equal to the sum of the corresponding row in <code>votes_election1</code>.
</p>
</li>
<li> <p><code>simultaneous</code>: This is the value to be used in classical ecological inference problems,
such as in ecological studies of racial voting, and in scenarios with two simultaneous elections.
In this scenario, the sum by rows of <code>votes_election1</code> and <code>votes_election2</code> must coincide.
Constraints defined by equations (8) and (9) of Romero et al. (2020) are not included in
the model. In this case, the lphom function just implements the basic model defined,
for instance, by equations (1) to (5) of Pavia (2024).
</p>
</li>
<li> <p><code>semifull</code>: This value accounts for a scenario with two elections elapsed at least some
months, where: (i) the column J1 = J of <code>votes_election1</code> totals new
electors (young and immigrants) that have the right to vote for the first time and
(ii) the column K2 = K of <code>votes_election2</code> corresponds to total exits of the census
lists (due to death or emigration). In this scenario, the sum by rows of
<code>votes_election1</code> and <code>votes_election2</code> must agree and constraint (15)
of Pavia (2023) apply. Additionally, if <code>uniform = TRUE</code> constraints
(8) of Pavia (2023) are also imposed.
</p>
</li>
<li> <p><code>full</code>: This value accounts for a scenario with two elections elapsed at least some
months, where (i) the column J - 1 of <code>votes_election1</code> totals new young
electors that have the right to vote for the first time, (ii) the column J (=J1)
of <code>votes_election1</code> measures new immigrants that have the right to vote and
(iii) the column K (=K2) of <code>votes_election2</code> corresponds to total exits of the census
lists (due to death or emigration). In this scenario, the sum by rows of
<code>votes_election1</code> and <code>votes_election2</code> must agree and constraints (13)
and (15) of Pavia (2023) apply.  Additionally, if <code>uniform = TRUE</code> constraints
(11) of Pavia (2023) are also imposed.
</p>
</li>
<li> <p><code>fullreverse</code>: This value is somehow the mirror version of <code>full</code>.
It accounts for a scenario with two elections elapsed at least some
months, where (i) the column J1 = J of <code>votes_election1</code> totals new
electors (young and immigrants) that have the right to vote for the first time and
(ii) where total exits are separated out between exits due to emigration
(column K - 1 of <code>votes_election2</code>) and death (column K of <code>votes_election2</code>).
In this scenario, the sum by rows of <code>votes_election1</code> and <code>votes_election2</code> must
agree and constraints (14) and (15) of Pavia (2023) apply.
Additionally, if <code>uniform = TRUE</code> constraints (8) and (9) of Pavia (2023) are also imposed.
</p>
</li>
<li> <p><code>gold</code>: This value accounts for a scenario similar to <code>full</code>, where total exits are
separated out between exits due to emigration (column K - 1 of <code>votes_election2</code>)
and death (column K of <code>votes_election2</code>). In this scenario, the sum by rows
of <code>votes_election1</code> and <code>votes_election2</code> must agree. Constraints (12) to
(15) of Pavia (2023) apply and if <code>uniform = TRUE</code> constraints (10) and (11)
of Pavia (2023) are also imposed.
</p>
</li></ul>



<h3>Value</h3>

<p>A list with the following components
</p>
<table>
<tr><td><code>VTM</code></td>
<td>
<p> A matrix of order J'xK' (where J'=J-1 or J and K'=K-1 or K) with the estimated percentages of row-standardized vote transitions from election 1 to election 2.
In <code>raw</code>, <code>regular</code>, <code>ordinary</code> and <code>enriched</code> scenarios when the percentage of net entries is small, less than 1% of the census in all units,
net entries are omitted (i.e., the number of rows of <code>VTM</code> is equal to J1) even when estimates for net entries different from zero are obtained. Likewise, in the same scenarios when the percentage of net exits is small, less than 1%
of the census in all units, net exits are omitted (i.e., the number of rows of <code>VTM</code> is equal to K2) even when estimates for net exits different from zero are obtained.</p>
</td></tr>
<tr><td><code>VTM.votes</code></td>
<td>
<p> A matrix of order J'xK' (where J'=J-1 or J and K'=K-1 or K) with the estimated vote transitions from election 1 to election 2.
In <code>raw</code>, <code>regular</code>, <code>ordinary</code> and <code>enriched</code> scenarios when the percentage of net entries is small, less than 1% of the census,
net entries are omitted (i.e., J = J1) even when estimates for net entries different from zero are obtained. Likewise, in the same scenarios when the percentage of net exits is small, less than 1%
of the census, net exits are omitted (i.e., K = K2) even when estimates for net exits different from zero are obtained.</p>
</td></tr>
<tr><td><code>OTM</code></td>
<td>
<p> A matrix of order KxJ with the estimated percentages of the origin of the votes obtained for the different options of election 2.</p>
</td></tr>
<tr><td><code>HETe</code></td>
<td>
<p> The estimated heterogeneity index defined in equation (11) of Romero et al. (2020).</p>
</td></tr>
<tr><td><code>VTM.complete</code></td>
<td>
<p> A matrix of order JxK with the estimated proportions of row-standardized vote transitions from election 1 to election 2.
In <code>raw</code>, <code>regular</code>, <code>ordinary</code> and <code>enriched</code> scenarios, this matrix includes the row and the column corresponding to net entries
and net exits (when they are present) even when they are really small, less than 1%.</p>
</td></tr>
<tr><td><code>VTM.complete.votes</code></td>
<td>
<p> A matrix of order JxK with the estimated vote transitions from election 1 to election 2.
In <code>raw</code>, <code>regular</code>, <code>ordinary</code> and <code>enriched</code> scenarios, this matrix includes the row and the column corresponding to net entries
and net exits (when they are present) even when they are really small, less than 1%.</p>
</td></tr>
<tr><td><code>deterministic.bounds</code></td>
<td>
<p> A list of two matrices of order JxK containing for each vote transition the lower and upper proportions allowed given the observed aggregates.</p>
</td></tr>
<tr><td><code>inputs</code></td>
<td>
<p> A list containing all the objects with the values used as arguments by the function.</p>
</td></tr>
<tr><td><code>origin</code></td>
<td>
<p> A matrix with the final data used as votes of the origin election after taking into account the level of information available regarding to new entries and exits of the election censuses between the two elections.</p>
</td></tr>
<tr><td><code>destination</code></td>
<td>
<p> A matrix with the final data used as votes of the origin election after taking into account the level of information available regarding to new entries and exits of the election censuses between the two elections.</p>
</td></tr>
<tr><td><code>EHet</code></td>
<td>
<p> A matrix of order IxK measuring in each spatial unit a distance to the homogeneity hypothesis. That is, the differences under the homogeneity hypothesis between the actual recorded results and the expected results in each territorial unit for each option of election 2.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Jose M. Pavia, <a href="mailto:pavia@uv.es">pavia@uv.es</a>
</p>
<p>Rafael Romero <a href="mailto:rromero@eio.upv.es">rromero@eio.upv.es</a>
</p>


<h3>References</h3>

<p>Romero, R, Pavia, JM, Martin, J and Romero G (2020). Assessing uncertainty of voter transitions estimated from aggregated data. Application to the 2017 French presidential election. <em>Journal of Applied Statistics</em>, 47(13-15), 2711-2736. <a href="https://doi.org/10.1080/02664763.2020.1804842">doi:10.1080/02664763.2020.1804842</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+tslphom">tslphom</a></code> <code><a href="#topic+nslphom">nslphom</a></code> <code><a href="#topic+lclphom">lclphom</a></code> <code><a href="#topic+rslphom">rslphom</a></code>
</p>
<p>Other linear programing ecological inference functions: 
<code><a href="#topic+lclphom">lclphom</a>()</code>,
<code><a href="#topic+lp_apriori">lp_apriori</a>()</code>,
<code><a href="#topic+lphom_dual">lphom_dual</a>()</code>,
<code><a href="#topic+lphom_joint">lphom_joint</a>()</code>,
<code><a href="#topic+nslphom_dual">nslphom_dual</a>()</code>,
<code><a href="#topic+nslphom_joint">nslphom_joint</a>()</code>,
<code><a href="#topic+nslphom">nslphom</a>()</code>,
<code><a href="#topic+rslphom">rslphom</a>()</code>,
<code><a href="#topic+tslphom_dual">tslphom_dual</a>()</code>,
<code><a href="#topic+tslphom_joint">tslphom_joint</a>()</code>,
<code><a href="#topic+tslphom">tslphom</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>lphom(France2017P[, 1:8] , France2017P[, 9:12], new_and_exit_voters= "raw")
</code></pre>

<hr>
<h2 id='lphom_dual'>Implements lphom_dual algorithm</h2><span id='topic+lphom_dual'></span>

<h3>Description</h3>

<p>Estimates RxC vote transfer matrices (ecological contingency tables) with lphom_dual
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lphom_dual(
  votes_election1,
  votes_election2,
  integers = FALSE,
  solver = "lp_solve",
  integers.solver = "symphony",
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="lphom_dual_+3A_votes_election1">votes_election1</code></td>
<td>
<p>data.frame (or matrix) of order IxJ with the counts to be initially
mapped to rows. When estimating vote transfer matrices, the votes gained by
the <em>J</em> political options competing on election 1 (or origin) in the <em>I</em>
territorial units considered.  The sum by rows of <code>votes_election1</code> and
<code>votes_election2</code> must coincide.</p>
</td></tr>
<tr><td><code id="lphom_dual_+3A_votes_election2">votes_election2</code></td>
<td>
<p>data.frame (or matrix) of order IxK with the counts to be initially mapped
to columns. When estimating vote transfer matrices, the votes gained by
the <em>K</em> political options competing on election 2 (or destination) in the <em>I</em>
territorial units considered. The sum by rows of <code>votes_election1</code> and
<code>votes_election2</code> must coincide.</p>
</td></tr>
<tr><td><code id="lphom_dual_+3A_integers">integers</code></td>
<td>
<p>A TRUE/FALSE value that indicates whether the LP solution of counts (votes) must be approximate
to the closest integer solution using ILP. Default, FALSE.</p>
</td></tr>
<tr><td><code id="lphom_dual_+3A_solver">solver</code></td>
<td>
<p>A character string indicating the linear programming solver to be used, only
<code>lp_solve</code> and <code>symphony</code> are allowed. By default, <code>lp_solve</code>. The package <code>Rsymphony</code>
needs to be installed for the option <code>symphony</code> to be used.</p>
</td></tr>
<tr><td><code id="lphom_dual_+3A_integers.solver">integers.solver</code></td>
<td>
<p>A character string indicating the linear programming solver to be used to approximate
to the closest integer solution, only <code>symphony</code> and <code>lp_solve</code> are allowed.
By default, <code>symphony</code>. The package <code>Rsymphony</code> needs to be installed for the option <code>symphony</code>
to be used. Only used when <code>integers = TRUE</code>.</p>
</td></tr>
<tr><td><code id="lphom_dual_+3A_...">...</code></td>
<td>
<p>Other arguments to be passed to the function. Not currently used.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with the following components
</p>
<table>
<tr><td><code>VTM.votes.w</code></td>
<td>
<p> The matrix of order JxK with the estimated cross-distribution of votes of elections 1 and 2, attained weighting the two dual solutions using as weights the corresponding HTEe estimates.</p>
</td></tr>
<tr><td><code>VTM.votes.a</code></td>
<td>
<p> The matrix of order JxK with the estimated cross-distribution of votes of elections 1 and 2, attained simple averaging the two dual solutions.</p>
</td></tr>
<tr><td><code>HETe.w</code></td>
<td>
<p> Estimated heterogeneity index associated to the <code>VTM.votes.w</code> solution.</p>
</td></tr>
<tr><td><code>HETe.a</code></td>
<td>
<p> Estimated heterogeneity index associated to the <code>VTM.votes.a</code> solution.</p>
</td></tr>
<tr><td><code>VTM12.w</code></td>
<td>
<p> The matrix of order JxK with the estimated row-standardized proportions of vote transitions from election 1 to election 2 associated to the <code>VTM.votes.w</code> solution.</p>
</td></tr>
<tr><td><code>VTM21.w</code></td>
<td>
<p> The matrix of order KxJ with the estimated row-standardized proportions of vote transitions from election 2 to election 1 associated to the <code>VTM.votes.w</code> solution.</p>
</td></tr>
<tr><td><code>VTM12.a</code></td>
<td>
<p> The matrix of order JxK with the estimated row-standardized proportions of vote transitions from election 1 to election 2 associated to the <code>VTM.votes.a</code> solution.</p>
</td></tr>
<tr><td><code>VTM21.a</code></td>
<td>
<p> The matrix of order KxJ with the estimated row-standardized proportions of vote transitions from election 2 to election 1 associated to the <code>VTM.votes.a</code> solution.</p>
</td></tr>
<tr><td><code>lphom.object.12</code></td>
<td>
<p> The output of the <code><a href="#topic+lphom">lphom</a></code> function attained solving the problem X &ndash;&gt; Y. That is, mapping <code>votes_election1</code> to rows and <code>votes_election2</code> to columns.</p>
</td></tr>
<tr><td><code>lphom.object.21</code></td>
<td>
<p> The output of the <code><a href="#topic+lphom">lphom</a></code> function attained solving the problem Y &ndash;&gt; X. That is, mapping <code>votes_election2</code> to rows and <code>votes_election1</code> to columns.</p>
</td></tr>
<tr><td><code>inputs</code></td>
<td>
<p> A list containing all the objects with the values used as arguments by the function.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Jose M. Pavia, <a href="mailto:pavia@uv.es">pavia@uv.es</a>
</p>
<p>Rafael Romero <a href="mailto:rromero@eio.upv.es">rromero@eio.upv.es</a>
</p>


<h3>References</h3>

<p>Pavia, JM and Romero, R (2024). Symmetry estimating RxC vote transfer matrices from aggregate data. <em>Journal of the Royal Statistical Society, Series A – Statistics in Society</em>, forthcoming.  <a href="https://doi.org/10.1093/jrsssa/qnae013">doi:10.1093/jrsssa/qnae013</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+lphom">lphom</a></code> <code><a href="#topic+tslphom_dual">tslphom_dual</a></code> <code><a href="#topic+nslphom_dual">nslphom_dual</a></code> <code><a href="#topic+lphom_joint">lphom_joint</a></code> <code><a href="#topic+tslphom_joint">tslphom_joint</a></code> <code><a href="#topic+nslphom_joint">nslphom_joint</a></code>
</p>
<p>Other linear programing ecological inference functions: 
<code><a href="#topic+lclphom">lclphom</a>()</code>,
<code><a href="#topic+lp_apriori">lp_apriori</a>()</code>,
<code><a href="#topic+lphom_joint">lphom_joint</a>()</code>,
<code><a href="#topic+lphom">lphom</a>()</code>,
<code><a href="#topic+nslphom_dual">nslphom_dual</a>()</code>,
<code><a href="#topic+nslphom_joint">nslphom_joint</a>()</code>,
<code><a href="#topic+nslphom">nslphom</a>()</code>,
<code><a href="#topic+rslphom">rslphom</a>()</code>,
<code><a href="#topic+tslphom_dual">tslphom_dual</a>()</code>,
<code><a href="#topic+tslphom_joint">tslphom_joint</a>()</code>,
<code><a href="#topic+tslphom">tslphom</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- France2017P[, 1:8]
y &lt;- France2017P[, 9:12]
y[,1] &lt;- y[,1]  - (rowSums(y) - rowSums(x))
mt &lt;- lphom_dual(x, y)
mt$VTM.votes.w
mt$HETe.w
</code></pre>

<hr>
<h2 id='lphom_joint'>Implements the lphom_joint algorithm</h2><span id='topic+lphom_joint'></span>

<h3>Description</h3>

<p>Estimates RxC vote transfer matrices (ecological contingency tables) with lphom_joint
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lphom_joint(
  votes_election1,
  votes_election2,
  integers = FALSE,
  solver = "lp_solve",
  integers.solver = "symphony",
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="lphom_joint_+3A_votes_election1">votes_election1</code></td>
<td>
<p>data.frame (or matrix) of order IxJ with the counts to be initially
mapped to rows. When estimating vote transfer matrices, the votes gained by
the <em>J</em> political options competing on election 1 (or origin) in the <em>I</em>
territorial units considered.  The sum by rows of <code>votes_election1</code> and
<code>votes_election2</code> must coincide.</p>
</td></tr>
<tr><td><code id="lphom_joint_+3A_votes_election2">votes_election2</code></td>
<td>
<p>data.frame (or matrix) of order IxK with the counts to be initially mapped
to columns. When estimating vote transfer matrices, the votes gained by
the <em>K</em> political options competing on election 2 (or destination) in the <em>I</em>
territorial units considered. The sum by rows of <code>votes_election1</code> and
<code>votes_election2</code> must coincide.</p>
</td></tr>
<tr><td><code id="lphom_joint_+3A_integers">integers</code></td>
<td>
<p>A TRUE/FALSE value that indicates whether the LP solution of counts (votes) must be approximate
to the closest integer solution using ILP. Default, FALSE.</p>
</td></tr>
<tr><td><code id="lphom_joint_+3A_solver">solver</code></td>
<td>
<p>A character string indicating the linear programming solver to be used, only
<code>lp_solve</code> and <code>symphony</code> are allowed. By default, <code>lp_solve</code>. The package <code>Rsymphony</code>
needs to be installed for the option <code>symphony</code> to be used.</p>
</td></tr>
<tr><td><code id="lphom_joint_+3A_integers.solver">integers.solver</code></td>
<td>
<p>A character string indicating the linear programming solver to be used to approximate
to the closest integer solution, only <code>symphony</code> and <code>lp_solve</code> are allowed.
By default, <code>symphony</code>. The package <code>Rsymphony</code> needs to be installed for the option <code>symphony</code>
to be used. Only used when <code>integers = TRUE</code>.</p>
</td></tr>
<tr><td><code id="lphom_joint_+3A_...">...</code></td>
<td>
<p>Other arguments to be passed to the function. Not currently used.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with the following components
</p>
<table>
<tr><td><code>VTM.votes</code></td>
<td>
<p> A matrix of order JxK with the estimated cross-distribution of votes of elections 1 and 2.</p>
</td></tr>
<tr><td><code>HETe</code></td>
<td>
<p> The estimated heterogeneity index associated to the <code>VTM.votes</code> solution.</p>
</td></tr>
<tr><td><code>VTM12</code></td>
<td>
<p> The matrix of order JxK with the estimated row-standardized proportions of vote transitions from election 1 to election 2 associated to the <code>VTM.votes</code> solution.</p>
</td></tr>
<tr><td><code>VTM21</code></td>
<td>
<p> The matrix of order KxJ with the estimated row-standardized proportions of vote transitions from election 2 to election 1 associated to the <code>VTM.votes</code> solution.</p>
</td></tr>
<tr><td><code>EHet12</code></td>
<td>
<p> A matrix of order IxK measuring in each unit a distance to the homogeneity hypothesis. That is, the differences under the homogeneity hypothesis between the actual recorded results and the expected results in each territorial unit for each option of election two. The matrix Eik.</p>
</td></tr>
<tr><td><code>EHet21</code></td>
<td>
<p> A matrix of order IxJ measuring in each unit a distance to the homogeneity hypothesis. That is, the differences under the homogeneity hypothesis between the actual recorded results and the expected results in each territorial unit for each option of election one. The matrix Eij.</p>
</td></tr>
<tr><td><code>deterministic.bounds</code></td>
<td>
<p> A list of two matrices of order JxK containing for each vote transition the lower and upper proportions allowed given the observed aggregates.</p>
</td></tr>
<tr><td><code>inputs</code></td>
<td>
<p> A list containing all the objects with the values used as arguments by the function.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Jose M. Pavia, <a href="mailto:pavia@uv.es">pavia@uv.es</a>
</p>
<p>Rafael Romero <a href="mailto:rromero@eio.upv.es">rromero@eio.upv.es</a>
</p>


<h3>References</h3>

<p>Pavia, JM and Romero, R (2024). Symmetry estimating RxC vote transfer matrices from aggregate data. <em>Journal of the Royal Statistical Society, Series A – Statistics in Society</em>, forthcoming.  <a href="https://doi.org/10.1093/jrsssa/qnae013">doi:10.1093/jrsssa/qnae013</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+lphom">lphom</a></code> <code><a href="#topic+lphom_dual">lphom_dual</a></code> <code><a href="#topic+tslphom_dual">tslphom_dual</a></code> <code><a href="#topic+nslphom_dual">nslphom_dual</a></code> <code><a href="#topic+tslphom_joint">tslphom_joint</a></code> <code><a href="#topic+nslphom_joint">nslphom_joint</a></code>
</p>
<p>Other linear programing ecological inference functions: 
<code><a href="#topic+lclphom">lclphom</a>()</code>,
<code><a href="#topic+lp_apriori">lp_apriori</a>()</code>,
<code><a href="#topic+lphom_dual">lphom_dual</a>()</code>,
<code><a href="#topic+lphom">lphom</a>()</code>,
<code><a href="#topic+nslphom_dual">nslphom_dual</a>()</code>,
<code><a href="#topic+nslphom_joint">nslphom_joint</a>()</code>,
<code><a href="#topic+nslphom">nslphom</a>()</code>,
<code><a href="#topic+rslphom">rslphom</a>()</code>,
<code><a href="#topic+tslphom_dual">tslphom_dual</a>()</code>,
<code><a href="#topic+tslphom_joint">tslphom_joint</a>()</code>,
<code><a href="#topic+tslphom">tslphom</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- France2017P[, 1:8]
y &lt;- France2017P[, 9:12]
y[,1] &lt;- y[,1]  - (rowSums(y) - rowSums(x))
mt &lt;- lphom_joint(x, y)
mt$VTM.votes
mt$HETe
</code></pre>

<hr>
<h2 id='nslphom'>Implements nslphom algorithm</h2><span id='topic+nslphom'></span>

<h3>Description</h3>

<p>Estimates RxC (JxK) vote transfer matrices (ecological contingency tables) with nslphom
</p>


<h3>Usage</h3>

<pre><code class='language-R'>nslphom(
  votes_election1,
  votes_election2,
  new_and_exit_voters = c("raw", "regular", "ordinary", "enriched", "adjust1", "adjust2",
    "simultaneous", "semifull", "full", "fullreverse", "gold"),
  apriori = NULL,
  lambda = 0.5,
  uniform = TRUE,
  iter.max = 10,
  min.first = FALSE,
  structural_zeros = NULL,
  integers = FALSE,
  distance.local = c("abs", "max", "none"),
  verbose = TRUE,
  solver = "lp_solve",
  integers.solver = "symphony",
  burnin = 0,
  tol = 10^-5,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="nslphom_+3A_votes_election1">votes_election1</code></td>
<td>
<p>data.frame (or matrix) of order IxJ1 with the votes gained by
(or the counts corresponding to) the J1 political options competing
(available) on election 1 (or origin) in the I units considered.
In general, the row marginals of the I tables corresponding
to the units.</p>
</td></tr>
<tr><td><code id="nslphom_+3A_votes_election2">votes_election2</code></td>
<td>
<p>data.frame (or matrix) of order IxK2
with the votes gained by (or the counts corresponding to) the K2
political options competing (available) on election 2 (or destination)
in the I (territorial) units considered. In general, the column marginals
of the I tables corresponding to the units.</p>
</td></tr>
<tr><td><code id="nslphom_+3A_new_and_exit_voters">new_and_exit_voters</code></td>
<td>
<p>A character string indicating the level of information available
in <code>votes_election1</code> and <code>votes_election2</code> regarding new entries
and exits of the election censuses between the two elections.
This argument allows, in addition to the options discussed in Pavia
(2023), three more options. This argument admits eleven different values:
<code>raw</code>, <code>regular</code>, <code>ordinary</code>, <code>enriched</code>, <code>adjust1</code>, <code>adjust2</code>,
<code>simultaneous</code>, <code>semifull</code>, <code>full</code>, <code>fullreverse</code> and <code>gold</code>.
Default, <code>raw</code>.</p>
</td></tr>
<tr><td><code id="nslphom_+3A_apriori">apriori</code></td>
<td>
<p>data.frame (or matrix) of order J0xK0 with an initial estimate of the
(row-standarized) global voter transition proportions/fractions, pjk0, between
the first J0 (election) options of election 1 and the first K0 (election) options
of election 2. This matrix can contain some missing values. When no a priori
information is available <code>apriori</code> is a null object. Default, <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="nslphom_+3A_lambda">lambda</code></td>
<td>
<p>A number between 0 and 1, informing the relative weight the user assigns to the
<code>apriori</code> information. Setting <code>lambda = 0</code> is equivalent to not having a priori
information (i.e., <code>apriori = NULL</code>). Default, <code>0.5</code>.</p>
</td></tr>
<tr><td><code id="nslphom_+3A_uniform">uniform</code></td>
<td>
<p>A <code>TRUE/FALSE</code> value that informs whether census exits impact all the electoral options
in a (relatively) similar fashion in all iterations, including iteration 0 and
when deriving units tables. If <code>uniform = TRUE</code> typically at least one of the equations
among equations (6) to (11) of Pavia (2023) is included in the underlying model.
This parameter has no effect in <code>simultaneous</code> scenarios. It also has not impact
in <code>raw</code> and <code>regular</code> scenarios when no net exits are estimated by the function
from the provided information. Default, <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="nslphom_+3A_iter.max">iter.max</code></td>
<td>
<p>Maximum number of iterations to be performed. The process ends when either the
number of iterations reaches iter.max or when the maximum variation between two consecutive
estimates of the probability transfer matrix is less than <code>tol</code>. By default, <code>10</code>.</p>
</td></tr>
<tr><td><code id="nslphom_+3A_min.first">min.first</code></td>
<td>
<p>A <code>TRUE/FALSE</code> value. If <code>min.first = FALSE</code>, the matrix associated with the
minimum <code>HETe</code> after performing <code>iter.max</code> iterations is taken as solution.
If <code>min.first = TRUE</code>, the associated matrix to the instant in which the first decrease
of <code>HETe</code> occurs is taken as solution. The process stops at that moment.
In this last scenario (when <code>min.first = TRUE</code>), <code>burnin = 0</code> is forced and <code>iter.max</code>
is at least <code>100</code>. Default, <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="nslphom_+3A_structural_zeros">structural_zeros</code></td>
<td>
<p>Default <code>NULL</code>. A list of vectors of length two, indicating the election options
for which no transfer of votes are allowed between election 1 and election 2.
For instance, when new_and_exit_voters is set to <code>"semifull"</code>,
lphom implicitly states <code>structural_zeros = list(c(J1, K2))</code>.</p>
</td></tr>
<tr><td><code id="nslphom_+3A_integers">integers</code></td>
<td>
<p>A <code>TRUE/FALSE</code> value that indicates whether the problem is solved in integer values
in both iterations, including iteration zero (lphom) and the rest of iterations,
when deriving unit tables solutions. If <code>integers = TRUE</code>, the LP matrices are
approximated to the closest integer solution solving
the corresponding Integer Linear Program. Default, <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="nslphom_+3A_distance.local">distance.local</code></td>
<td>
<p>A string argument that indicates whether the second step of the lphom_local algorithm
should be performed to solve potential indeterminacies of local solutions.
Default, <code>"abs"</code>.
If <code>distance.local = "abs"</code> lphom_local selects in its second step the matrix
closer to the temporary global solution under L_1 norm, among the first step compatible matrices.
If <code>distance.local = "max"</code> lphom_local selects in its second step the matrix
closer to the temporary global solution under L_Inf norm, among the first step compatible matrices.
If <code>distance.local = "none"</code>, the second step of lphom_local is not performed.</p>
</td></tr>
<tr><td><code id="nslphom_+3A_verbose">verbose</code></td>
<td>
<p>A <code>TRUE/FALSE</code> value that indicates if a summary of the results of the computations performed
to estimate net entries and exits should be printed on the screen. Default, <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="nslphom_+3A_solver">solver</code></td>
<td>
<p>A character string indicating the linear programming solver to be used, only
<code>lp_solve</code> and <code>symphony</code> are allowed. By default, <code>lp_solve</code>. The package <code>Rsymphony</code>
needs to be installed for the option <code>symphony</code> to be used.</p>
</td></tr>
<tr><td><code id="nslphom_+3A_integers.solver">integers.solver</code></td>
<td>
<p>A character string indicating the linear programming solver to be used to approximate
to the closest integer solution, only <code>symphony</code> and <code>lp_solve</code> are allowed.
By default, <code>symphony</code>. The package <code>Rsymphony</code> needs to be installed for the option <code>symphony</code>
to be used. Only used when <code>integers = TRUE</code>.</p>
</td></tr>
<tr><td><code id="nslphom_+3A_burnin">burnin</code></td>
<td>
<p>Number of initial solutions to be discarded before determining the final solution. By default, 0.</p>
</td></tr>
<tr><td><code id="nslphom_+3A_tol">tol</code></td>
<td>
<p>Maximum deviation allowed between two consecutive iterations. The process ends when the maximum
variation between two proportions for the estimation of the transfer matrix between two consecutive
iterations is less than <code>tol</code> or the maximum number of iterations, <code>iter.max</code>, has been reached. By default, 0.00001.</p>
</td></tr>
<tr><td><code id="nslphom_+3A_...">...</code></td>
<td>
<p>Other arguments to be passed to the function. Not currently used.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Description of the <code>new_and_exit_voters</code> argument in more detail.
</p>

<ul>
<li> <p><code>raw</code>: The default value. This argument accounts for the most plausible scenario when
estimating vote transfer matrices. A scenario with two elections elapsed at least
some months where only the raw election data recorded in the I (territorial) units,
in which the electoral space under study is divided, are available.
In this scenario, net exits and net entries are estimated according to
equation (7) of Romero et al. (2020). When both net entries and exits are no
null, constraint (15) of Pavia (2023) applies. If there are net exits and <code>uniform = TRUE</code>
either constraints (6) or (8) and (15) of Pavia (2023) are imposed. In this scenario,
J could be equal to J1 or J1 + 1 and K equal to K2 or K2 + 1.
</p>
</li>
<li> <p><code>regular</code>: This value accounts for a scenario with
two elections elapsed at least some months where (i) the column J1
of <code>votes_election1</code> corresponds to new young electors who have the right
to vote for the first time, (ii) net exits and maybe other additional
net entries are computed according to equation (7) of Romero et al. (2020), and
(iii) we can (or not) assume that net exits impact equally all the first J1 - 1
options of election 1. When both net entries and exits are no null, constraints
(13) and (15) of Pavia (2023) apply. If <code>uniform = TRUE</code> and there are net exits either
constraints (8) or (11) of Pavia (2023), depending on whether there are or not net
entries, are also imposed. In this scenario, J could be equal to J1 or J1 + 1 and
K equal to K2 or K2 + 1. Note that this scenario could be also used if
column J1 of <code>votes_election1</code> would correspond to immigrants instead of
new young electors.
</p>
</li>
<li> <p><code>ordinary</code>: This value accounts for a scenario
with two elections elapsed at least some months where (i) the column K1
of <code>votes_election2</code> corresponds to electors who died in the period between
elections, (ii) net entries and maybe other additional net exits are
computed according to equation (7) of Romero et al. (2020), and (iii) we can
assume (or not) that exits impact equally all the J1 options of election 1.
When both net entries and exits are no null, constraints (14) and
(15) of Pavia (2023) apply and if <code>uniform = TRUE</code> either constraints
(8) and (9) or, without net entries, (6) and (7) of Pavia (2023) are also imposed.
In this scenario, J could be equal to J1 or J1 + 1 and K equal to K2 or K2 + 1.
Note that this scenario could be also used if column K1 of
<code>votes_election2</code> would correspond to emigrants instead of deaths.
</p>
</li>
<li> <p><code>enriched</code>: This value accounts for a scenario that somehow combine <code>regular</code> and
<code>ordinary</code> scenarios. We consider two elections elapsed at least some months where
(i) the column J1 of <code>votes_election1</code> corresponds to new young electors
who have the right to vote for the first time, (ii) the column K2 of
<code>votes_election2</code> corresponds to electors who died in the interperiod
election, (iii) other (net) entries and (net) exits are computed according
to equation (7) of Romero et al. (2020), and (iv) we can assume
(or not) that exits impact equally all the J1 - 1 options of election 1.
When both net entries and exits are no null, constraints (12) to
(15) of Pavia (2023) apply and if <code>uniform = TRUE</code> constraints
(10) and (11) of Pavia (2023) are also imposed. In this scenario, J could be equal
to J1 or J1 + 1 and K equal to K2 or K2 + 1. Note that this scenario could be also used if
the column J1 of <code>votes_election1</code> would correspond to immigrants instead of
new young electors and/or if column K1 of <code>votes_election2</code> would correspond
to emigrants instead of deaths.
</p>
</li>
<li> <p><code>adjust1</code>: This value accounts for a scenario
with two elections elapsed at least some months where the census in
each of the I polling units of the first election (the row-sums of <code>votes_election1</code>) are
proportionally adjusted to match the corresponding census of the polling units in the
second election (the row-sums of <code>votes_election2</code>).
If <code>integers = TRUE</code>, each row in <code>votes_election1</code> is proportionally adjusted to the closest integer
vector whose sum is equal to the sum of the corresponding row in <code>votes_election2</code>.
</p>
</li>
<li> <p><code>adjust2</code>: This value accounts for a scenario
with two elections elapsed at least some months where the census in
each of the I polling units of the second election (the row-sums of <code>votes_election2</code>)
are proportionally adjusted to match the corresponding census of the polling units
in the first election (the row-sums of <code>votes_election1</code>).
If <code>integers = TRUE</code>, each row in <code>votes_election2</code> is adjusted to the closest integer
vector whose sum is equal to the sum of the corresponding row in <code>votes_election1</code>.
</p>
</li>
<li> <p><code>simultaneous</code>: This is the value to be used in classical ecological inference problems,
such as in ecological studies of racial voting, and in scenarios with two simultaneous elections.
In this scenario, the sum by rows of <code>votes_election1</code> and <code>votes_election2</code> must coincide.
Constraints defined by equations (8) and (9) of Romero et al. (2020) are not included in
the model. In this case, the lphom function just implements the basic model defined,
for instance, by equations (1) to (5) of Pavia (2024).
</p>
</li>
<li> <p><code>semifull</code>: This value accounts for a scenario with two elections elapsed at least some
months, where: (i) the column J1 = J of <code>votes_election1</code> totals new
electors (young and immigrants) that have the right to vote for the first time and
(ii) the column K2 = K of <code>votes_election2</code> corresponds to total exits of the census
lists (due to death or emigration). In this scenario, the sum by rows of
<code>votes_election1</code> and <code>votes_election2</code> must agree and constraint (15)
of Pavia (2023) apply. Additionally, if <code>uniform = TRUE</code> constraints
(8) of Pavia (2023) are also imposed.
</p>
</li>
<li> <p><code>full</code>: This value accounts for a scenario with two elections elapsed at least some
months, where (i) the column J - 1 of <code>votes_election1</code> totals new young
electors that have the right to vote for the first time, (ii) the column J (=J1)
of <code>votes_election1</code> measures new immigrants that have the right to vote and
(iii) the column K (=K2) of <code>votes_election2</code> corresponds to total exits of the census
lists (due to death or emigration). In this scenario, the sum by rows of
<code>votes_election1</code> and <code>votes_election2</code> must agree and constraints (13)
and (15) of Pavia (2023) apply.  Additionally, if <code>uniform = TRUE</code> constraints
(11) of Pavia (2023) are also imposed.
</p>
</li>
<li> <p><code>fullreverse</code>: This value is somehow the mirror version of <code>full</code>.
It accounts for a scenario with two elections elapsed at least some
months, where (i) the column J1 = J of <code>votes_election1</code> totals new
electors (young and immigrants) that have the right to vote for the first time and
(ii) where total exits are separated out between exits due to emigration
(column K - 1 of <code>votes_election2</code>) and death (column K of <code>votes_election2</code>).
In this scenario, the sum by rows of <code>votes_election1</code> and <code>votes_election2</code> must
agree and constraints (14) and (15) of Pavia (2023) apply.
Additionally, if <code>uniform = TRUE</code> constraints (8) and (9) of Pavia (2023) are also imposed.
</p>
</li>
<li> <p><code>gold</code>: This value accounts for a scenario similar to <code>full</code>, where total exits are
separated out between exits due to emigration (column K - 1 of <code>votes_election2</code>)
and death (column K of <code>votes_election2</code>). In this scenario, the sum by rows
of <code>votes_election1</code> and <code>votes_election2</code> must agree. Constraints (12) to
(15) of Pavia (2023) apply and if <code>uniform = TRUE</code> constraints (10) and (11)
of Pavia (2023) are also imposed.
</p>
</li></ul>



<h3>Value</h3>

<p>A list with the following components
</p>
<table>
<tr><td><code>VTM</code></td>
<td>
<p> A matrix of order J'xK' (where J'=J-1 or J and K'=K-1 or K) with the estimated percentages of row-standardized vote transitions from election 1 to election 2.
In <code>raw</code>, <code>regular</code>, <code>ordinary</code> and <code>enriched</code> scenarios when the percentage of net entries is small, less than 1% of the census in all units,
net entries are omitted (i.e., the number of rows of <code>VTM</code> is equal to J1) even when estimates for net entries different from zero are obtained. Likewise, in the same scenarios when the percentage of net exits is small, less than 1%
of the census in all units, net exits are omitted (i.e., the number of rows of <code>VTM</code> is equal to K2) even when estimates for net exits different from zero are obtained.</p>
</td></tr>
<tr><td><code>VTM.votes</code></td>
<td>
<p> A matrix of order J'xK' (where J'=J-1 or J and K'=K-1 or K) with the estimated vote transitions from election 1 to election 2.
In <code>raw</code>, <code>regular</code>, <code>ordinary</code> and <code>enriched</code> scenarios when the percentage of net entries is small, less than 1% of the census,
net entries are omitted (i.e., J = J1) even when estimates for net entries different from zero are obtained. Likewise, in the same scenarios when the percentage of net exits is small, less than 1%
of the census, net exits are omitted (i.e., K = K2) even when estimates for net exits different from zero are obtained.</p>
</td></tr>
<tr><td><code>OTM</code></td>
<td>
<p> A matrix of order KxJ with the estimated percentages of the origin of the votes obtained for the different options of election 2.</p>
</td></tr>
<tr><td><code>HETe</code></td>
<td>
<p> The estimated heterogeneity index as defined in equation (15) of Pavia and Romero (2022).</p>
</td></tr>
<tr><td><code>VTM.complete</code></td>
<td>
<p> A matrix of order JxK with the estimated proportions of row-standardized vote transitions from election 1 to election 2, including in <code>regular</code> and <code>raw</code> scenarios the row and the column corresponding to net_entries and net_exits even when they are really small, less than 1% in all units.</p>
</td></tr>
<tr><td><code>VTM.complete.votes</code></td>
<td>
<p> A matrix of order JxK with the estimated vote transitions from election 1 to election 2, including in <code>regular</code> and <code>raw</code> scenarios the row and the column corresponding to net_entries and net_exits even when they are really small, less than 1% in all units.</p>
</td></tr>
<tr><td><code>VTM.sequence</code></td>
<td>
<p> Array of order JxKx(iter+1) (where <code>iter</code> is the efective number of iterations performed) of the estimated matrices corresponding to each iteration.</p>
</td></tr>
<tr><td><code>HETe.sequence</code></td>
<td>
<p> Numeric vector of length <code>iter+1</code> with the <code>HETe</code> coefficients corresponding to the matrices in <code>VTM.sequence</code>.</p>
</td></tr>
<tr><td><code>VTM.prop.units</code></td>
<td>
<p> An array of order JxKxI with the estimated proportions of vote transitions from election 1 to election 2 attained for each unit in the selected iteration.</p>
</td></tr>
<tr><td><code>VTM.votes.units</code></td>
<td>
<p> An array of order JxKxI with the estimated matrix of vote transitions from election 1 to election 2 attained for for each unit in the selected iteration.</p>
</td></tr>
<tr><td><code>zeros</code></td>
<td>
<p> A list of vectors of length two, indicating the election options for which no transfer of votes are allowed between election 1 and election 2.</p>
</td></tr>
<tr><td><code>iter</code></td>
<td>
<p> The real final number of iterations performed before ending the process.</p>
</td></tr>
<tr><td><code>iter.min</code></td>
<td>
<p> Number of the iteration associated to the selected <code>VTM</code> solution.</p>
</td></tr>
<tr><td><code>deterministic.bounds</code></td>
<td>
<p> A list of two matrices of order JxK and two arrays of order JxKxI containing for each vote transition the lower and upper allowed proportions given the observed aggregates.</p>
</td></tr>
<tr><td><code>inputs</code></td>
<td>
<p> A list containing all the objects with the values used as arguments by the function.</p>
</td></tr>
<tr><td><code>origin</code></td>
<td>
<p> A matrix with the final data used as votes of the origin election after taking into account the level of information available regarding to new entries and exits of the election censuses between the two elections.</p>
</td></tr>
<tr><td><code>destination</code></td>
<td>
<p> A matrix with the final data used as votes of the origin election after taking into account the level of information available regarding to new entries and exits of the election censuses between the two elections.</p>
</td></tr>
<tr><td><code>EHet</code></td>
<td>
<p> A matrix of order IxK measuring in each spatial unit a distance to the homogeneity hypothesis, that is, the differences under the homogeneity hypothesis between the actual recorded results and the expected results with the solution in each territorial unit for each option of election 2.</p>
</td></tr>
<tr><td><code>solution_init</code></td>
<td>
<p> A list with the main outputs produced by <strong>lphom()</strong>.</p>
</td></tr>
</table>

<ul>
<li> <p><code>VTM_init</code>: A matrix of order JxK with the estimated percentages of vote transitions from election 1 to election 2 initially obtained by <strong>lphom()</strong>.
</p>
</li>
<li> <p><code>VTM.votes_init</code>: A matrix of order JxK with the estimated vote transitions from election 1 to election 2 initially obtained by <strong>lphom()</strong>.
</p>
</li>
<li> <p><code>OTM_init</code>: A matrix of order KxJ with the estimated percentages of the origin of the votes obtained for the different options of election 2 initially obtained by <strong>lphom()</strong>.
</p>
</li>
<li> <p><code>HETe_init</code>: The estimated heterogeneity index defined in equation (10) of Romero et al. (2020).
</p>
</li>
<li> <p><code>EHet_init</code>: A matrix of order IxK measuring in each spatial unit the distance to the homogeneity hypothesis, that is, the differences under the homogeneity hypothesis between the actual recorded results and the expected results, using the <strong>lphom()</strong> solution, in each territorial unit for each option of election 2.
</p>
</li>
<li> <p><code>VTM.complete_init</code>: A matrix of order J'xK' with the estimated proportions of vote transitions from election 1 to election 2 initially obtained by <strong>lphom()</strong>, including in <code>regular</code> and <code>raw</code> scenarios the row and the column corresponding to net_entries and net_exits even when they are really small, less than 1% in all units.
</p>
</li>
<li> <p><code>VTM.complete.votes_init</code>: A matrix of order J'xK' with the estimated vote transitions from election 1 to election 2 initially obtained by <strong>lphom()</strong>, including in <code>regular</code> and <code>raw</code> scenarios the row and the column corresponding to net_entries and net_exits even when they are really small, less than 1% in all units.
</p>
</li></ul>



<h3>Author(s)</h3>

<p>Jose M. Pavia, <a href="mailto:pavia@uv.es">pavia@uv.es</a>
</p>
<p>Rafael Romero <a href="mailto:rromero@eio.upv.es">rromero@eio.upv.es</a>
</p>


<h3>References</h3>

<p>Pavia, JM, and Romero, R (2022). Improving estimates accuracy of voter transitions. Two new algorithms for ecological inference based on linear programming, <em>Sociological Methods &amp; Research</em>. <a href="https://doi.org/10.1177/00491241221092725">doi:10.1177/00491241221092725</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+lphom">lphom</a></code> <code><a href="#topic+tslphom">tslphom</a></code> <code><a href="#topic+lclphom">lclphom</a></code> <code><a href="#topic+rslphom">rslphom</a></code>
</p>
<p>Other linear programing ecological inference functions: 
<code><a href="#topic+lclphom">lclphom</a>()</code>,
<code><a href="#topic+lp_apriori">lp_apriori</a>()</code>,
<code><a href="#topic+lphom_dual">lphom_dual</a>()</code>,
<code><a href="#topic+lphom_joint">lphom_joint</a>()</code>,
<code><a href="#topic+lphom">lphom</a>()</code>,
<code><a href="#topic+nslphom_dual">nslphom_dual</a>()</code>,
<code><a href="#topic+nslphom_joint">nslphom_joint</a>()</code>,
<code><a href="#topic+rslphom">rslphom</a>()</code>,
<code><a href="#topic+tslphom_dual">tslphom_dual</a>()</code>,
<code><a href="#topic+tslphom_joint">tslphom_joint</a>()</code>,
<code><a href="#topic+tslphom">tslphom</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>mt.ns &lt;- nslphom(France2017P[, 1:8] , France2017P[, 9:12], new_and_exit_voters= "raw")
mt.ns$VTM
mt.ns$HETe
mt.ns$solution_init$HETe_init

</code></pre>

<hr>
<h2 id='nslphom_dual'>Implements the nslphom_dual algorithm</h2><span id='topic+nslphom_dual'></span>

<h3>Description</h3>

<p>Estimates RxC vote transfer matrices (ecological contingency tables) with nslphom_dual
</p>


<h3>Usage</h3>

<pre><code class='language-R'>nslphom_dual(
  votes_election1,
  votes_election2,
  iter.max = 10,
  min.first = FALSE,
  integers = FALSE,
  solver = "lp_solve",
  integers.solver = "symphony",
  tol = 10^-5,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="nslphom_dual_+3A_votes_election1">votes_election1</code></td>
<td>
<p>data.frame (or matrix) of order IxJ with the counts to be initially
mapped to rows. When estimating vote transfer matrices, the votes gained by
the <em>J</em> political options competing on election 1 (or origin) in the <em>I</em>
territorial units considered.  The sum by rows of <code>votes_election1</code> and
<code>votes_election2</code> must coincide.</p>
</td></tr>
<tr><td><code id="nslphom_dual_+3A_votes_election2">votes_election2</code></td>
<td>
<p>data.frame (or matrix) of order IxK with the counts to be initially mapped
to columns. When estimating vote transfer matrices, the votes gained by
the <em>K</em> political options competing on election 2 (or destination) in the <em>I</em>
territorial units considered. The sum by rows of <code>votes_election1</code> and
<code>votes_election2</code> must coincide.</p>
</td></tr>
<tr><td><code id="nslphom_dual_+3A_iter.max">iter.max</code></td>
<td>
<p>Maximum number of iterations to be performed in each dual linear program.
The process ends independently in each system when either the number of iterations reaches
iter.max or when the maximum variation between two consecutive estimates of the
probability transfer matrix is less than <code>tol</code>. By default, 10.</p>
</td></tr>
<tr><td><code id="nslphom_dual_+3A_min.first">min.first</code></td>
<td>
<p>A <code>TRUE/FALSE</code> value. If <code>FALSE</code>, the matrix associated with the minimum <code>HETe</code> after
performing <code>iter.max</code> iterations is taken as solution.
If <code>TRUE</code>, the associated matrix to the instant in which the first decrease of <code>HETe</code> occurs
is taken as solution. The process stops at that moment. In this last scenario
(when <code>min.first = TRUE</code>), <code>iter.max</code> is is forced to be at least 100. Default, <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="nslphom_dual_+3A_integers">integers</code></td>
<td>
<p>A <code>TRUE/FALSE</code> value that indicates whether the problem is solved in integer values in
each iteration: zero (lphom) and intermediate and final (including unit) solutions.
If <code>TRUE</code>, the initial LP matrices are approximated in each iteration to the closest integer solution
solving the corresponding Integer Linear Program. Default, <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="nslphom_dual_+3A_solver">solver</code></td>
<td>
<p>A character string indicating the linear programming solver to be used, only
<code>lp_solve</code> and <code>symphony</code> are allowed. By default, <code>lp_solve</code>. The package <code>Rsymphony</code>
needs to be installed for the option <code>symphony</code> to be used.</p>
</td></tr>
<tr><td><code id="nslphom_dual_+3A_integers.solver">integers.solver</code></td>
<td>
<p>A character string indicating the linear programming solver to be used to approximate
to the closest integer solution, only <code>symphony</code> and <code>lp_solve</code> are allowed.
By default, <code>symphony</code>. The package <code>Rsymphony</code> needs to be installed for the option <code>symphony</code>
to be used. Only used when <code>integers = TRUE</code>.</p>
</td></tr>
<tr><td><code id="nslphom_dual_+3A_tol">tol</code></td>
<td>
<p>Maximum deviation allowed between two consecutive iterations. The process ends when the maximum
variation between two proportions for the estimation of the transfer matrix between two consecutive
iterations is less than <code>tol</code> or the maximum number of iterations, <code>iter.max</code>, has been reached. By default, 0.00001.</p>
</td></tr>
<tr><td><code id="nslphom_dual_+3A_...">...</code></td>
<td>
<p>Other arguments to be passed to the function. Not currently used.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with the following components
</p>
<table>
<tr><td><code>VTM.votes.w</code></td>
<td>
<p> The matrix of order JxK with the estimated cross-distribution of votes of elections 1 and 2,
attained weighting the two dual solutions using as weights the corresponding HTEe estimates.</p>
</td></tr>
<tr><td><code>VTM.votes.units.w</code></td>
<td>
<p> The array of order JxKxI with the local estimated cross-distributions of votes of elections 1 and 2 by unit,
attained weighting the two dual solutions using as weights the corresponding HTEe estimates.</p>
</td></tr>
<tr><td><code>VTM.votes.a</code></td>
<td>
<p> The matrix of order JxK with the estimated cross-distribution of votes of elections 1 and 2,
attained simple averaging the two dual solutions.</p>
</td></tr>
<tr><td><code>VTM.votes.units.a</code></td>
<td>
<p> The matrix of order JxKxI with the estimated cross-distributions of votes of elections 1 and 2 by unit,
attained weighting the two dual solutions using as weights the corresponding HTEe estimates.</p>
</td></tr>
<tr><td><code>HETe.w</code></td>
<td>
<p> Estimated heterogeneity index associated to the <code>VTM.votes.w</code> solution.</p>
</td></tr>
<tr><td><code>HETe.a</code></td>
<td>
<p> Estimated heterogeneity index associated to the <code>VTM.votes.a</code> solution.</p>
</td></tr>
<tr><td><code>VTM12.w</code></td>
<td>
<p> The matrix of order JxK with the estimated row-standardized proportions of vote transitions from election 1
to election 2 associated to the <code>VTM.votes.w</code> solution.</p>
</td></tr>
<tr><td><code>VTM21.w</code></td>
<td>
<p> The matrix of order KxJ with the estimated row-standardized proportions of vote transitions from election 2
to election 1 associated to the <code>VTM.votes.w</code> solution.</p>
</td></tr>
<tr><td><code>VTM12.a</code></td>
<td>
<p> The matrix of order JxK with the estimated row-standardized proportions of vote transitions from election 1
to election 2 associated to the <code>VTM.votes.a</code> solution.</p>
</td></tr>
<tr><td><code>VTM21.a</code></td>
<td>
<p> The matrix of order KxJ with the estimated row-standardized proportions of vote transitions from election 2
to election 1 associated to the <code>VTM.votes.a</code> solution.</p>
</td></tr>
<tr><td><code>nslphom.object.12</code></td>
<td>
<p> The output of the <code><a href="#topic+nslphom">nslphom</a></code> function attained solving the problem X &ndash;&gt; Y,
that is, mapping <code>votes_election1</code> to rows and <code>votes_election2</code> to columns.</p>
</td></tr>
<tr><td><code>nslphom.object.21</code></td>
<td>
<p> The output of the <code><a href="#topic+nslphom">nslphom</a></code> function attained solving the problem Y &ndash;&gt; X,
that is, mapping <code>votes_election2</code> to rows and <code>votes_election1</code> to columns.</p>
</td></tr>
<tr><td><code>inputs</code></td>
<td>
<p> A list containing all the objects with the values used as arguments by the function.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Jose M. Pavia, <a href="mailto:pavia@uv.es">pavia@uv.es</a>
</p>
<p>Rafael Romero <a href="mailto:rromero@eio.upv.es">rromero@eio.upv.es</a>
</p>


<h3>References</h3>

<p>Pavia, JM and Romero, R (2024). Symmetry estimating RxC vote transfer matrices from aggregate data. <em>Journal of the Royal Statistical Society, Series A – Statistics in Society</em>, forthcoming.  <a href="https://doi.org/10.1093/jrsssa/qnae013">doi:10.1093/jrsssa/qnae013</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+nslphom">nslphom</a></code> <code><a href="#topic+lphom_dual">lphom_dual</a></code> <code><a href="#topic+tslphom_dual">tslphom_dual</a></code> <code><a href="#topic+lphom_joint">lphom_joint</a></code> <code><a href="#topic+tslphom_joint">tslphom_joint</a></code> <code><a href="#topic+nslphom_joint">nslphom_joint</a></code>
</p>
<p>Other linear programing ecological inference functions: 
<code><a href="#topic+lclphom">lclphom</a>()</code>,
<code><a href="#topic+lp_apriori">lp_apriori</a>()</code>,
<code><a href="#topic+lphom_dual">lphom_dual</a>()</code>,
<code><a href="#topic+lphom_joint">lphom_joint</a>()</code>,
<code><a href="#topic+lphom">lphom</a>()</code>,
<code><a href="#topic+nslphom_joint">nslphom_joint</a>()</code>,
<code><a href="#topic+nslphom">nslphom</a>()</code>,
<code><a href="#topic+rslphom">rslphom</a>()</code>,
<code><a href="#topic+tslphom_dual">tslphom_dual</a>()</code>,
<code><a href="#topic+tslphom_joint">tslphom_joint</a>()</code>,
<code><a href="#topic+tslphom">tslphom</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- France2017P[, 1:8]
y &lt;- France2017P[, 9:12]
y[,1] &lt;- y[,1]  - (rowSums(y) - rowSums(x))
mt &lt;- nslphom_dual(x, y)
mt$VTM.votes.w
mt$HETe.w

</code></pre>

<hr>
<h2 id='nslphom_joint'>Implements the nslphom_joint algorithm</h2><span id='topic+nslphom_joint'></span>

<h3>Description</h3>

<p>Estimates RxC vote transfer matrices (ecological contingency tables) with nslphom_joint
</p>


<h3>Usage</h3>

<pre><code class='language-R'>nslphom_joint(
  votes_election1,
  votes_election2,
  iter.max = 10,
  min.first = FALSE,
  integers = FALSE,
  solver = "lp_solve",
  integers.solver = "symphony",
  tol = 0.001,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="nslphom_joint_+3A_votes_election1">votes_election1</code></td>
<td>
<p>data.frame (or matrix) of order IxJ with the counts to be initially
mapped to rows. When estimating vote transfer matrices, the votes gained by
the <em>J</em> political options competing on election 1 (or origin) in the <em>I</em>
territorial units considered.  The sum by rows of <code>votes_election1</code> and
<code>votes_election2</code> must coincide.</p>
</td></tr>
<tr><td><code id="nslphom_joint_+3A_votes_election2">votes_election2</code></td>
<td>
<p>data.frame (or matrix) of order IxK with the counts to be initially mapped
to columns. When estimating vote transfer matrices, the votes gained by
the <em>K</em> political options competing on election 2 (or destination) in the <em>I</em>
territorial units considered. The sum by rows of <code>votes_election1</code> and
<code>votes_election2</code> must coincide.</p>
</td></tr>
<tr><td><code id="nslphom_joint_+3A_iter.max">iter.max</code></td>
<td>
<p>Maximum number of iterations to be performed. The process ends independently when either
the number of iterations reaches iter.max or when the maximum variation between two
consecutive estimates of both ways probability transfer matrices are less than <code>tol</code>.
By default, 10.</p>
</td></tr>
<tr><td><code id="nslphom_joint_+3A_min.first">min.first</code></td>
<td>
<p>A <code>TRUE/FALSE</code> value. If <code>FALSE</code>, the matrix associated with the minimum <code>HETe</code> after
performing <code>iter.max</code> iterations is taken as solution.
If <code>TRUE</code>, the associated matrix to the instant in which the first decrease of <code>HETe</code> occurs
is taken as solution. The process stops at that moment. In this last scenario
(when <code>min.first = TRUE</code>), <code>iter.max</code> is is forced to be at least 100. Default, <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="nslphom_joint_+3A_integers">integers</code></td>
<td>
<p>A <code>TRUE/FALSE</code> value that indicates whether the problem is solved in integer values in
each iteration: zero (lphom) and intermediate and final (including unit) solutions.
If <code>TRUE</code>, the initial LP matrices are approximated in each iteration to the closest integer solution
solving the corresponding Integer Linear Program. Default, <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="nslphom_joint_+3A_solver">solver</code></td>
<td>
<p>A character string indicating the linear programming solver to be used, only
<code>lp_solve</code> and <code>symphony</code> are allowed. By default, <code>lp_solve</code>. The package <code>Rsymphony</code>
needs to be installed for the option <code>symphony</code> to be used.</p>
</td></tr>
<tr><td><code id="nslphom_joint_+3A_integers.solver">integers.solver</code></td>
<td>
<p>A character string indicating the linear programming solver to be used to approximate
to the closest integer solution, only <code>symphony</code> and <code>lp_solve</code> are allowed.
By default, <code>symphony</code>. The package <code>Rsymphony</code> needs to be installed for the option <code>symphony</code>
to be used. Only used when <code>integers = TRUE</code>.</p>
</td></tr>
<tr><td><code id="nslphom_joint_+3A_tol">tol</code></td>
<td>
<p>Maximum deviation allowed between two consecutive iterations. The process ends when the maximum
variation between the estimated cross-distributions of votes between two consecutive
iterations is less than <code>tol</code> or the maximum number of iterations, <code>iter.max</code>, has been reached. By default, 0.001.</p>
</td></tr>
<tr><td><code id="nslphom_joint_+3A_...">...</code></td>
<td>
<p>Other arguments to be passed to the function. Not currently used.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with the following components
</p>
<table>
<tr><td><code>VTM.votes</code></td>
<td>
<p> A matrix of order JxK with the estimated cross-distribution of votes of elections 1 and 2.</p>
</td></tr>
<tr><td><code>HETe</code></td>
<td>
<p> The estimated heterogeneity index associated to the <code>VTM.votes</code> solution.</p>
</td></tr>
<tr><td><code>VTM12</code></td>
<td>
<p> The matrix of order JxK with the estimated row-standardized proportions of vote transitions from election 1 to election 2 associated to the <code>VTM.votes</code> solution.</p>
</td></tr>
<tr><td><code>VTM21</code></td>
<td>
<p> The matrix of order KxJ with the estimated row-standardized proportions of vote transitions from election 2 to election 1 associated to the <code>VTM.votes</code> solution.</p>
</td></tr>
<tr><td><code>VTM.votes.units</code></td>
<td>
<p> An array of order JxKxI with the estimated matrix of cross-distributions of votes of elections 1 and 2 attained for each unit in iteration of the solution.</p>
</td></tr>
<tr><td><code>iter</code></td>
<td>
<p> The real final number of iterations performed before ending the process.</p>
</td></tr>
<tr><td><code>iter.min</code></td>
<td>
<p> Number of the iteration associated to the selected <code>VTM.votes</code> solution.</p>
</td></tr>
<tr><td><code>EHet12</code></td>
<td>
<p> A matrix of order IxK measuring in each unit a distance to the homogeneity hypothesis. That is, the differences under the homogeneity hypothesis between the actual recorded results and the expected results in each territorial unit for each option of election two. The matrix Eik.</p>
</td></tr>
<tr><td><code>EHet21</code></td>
<td>
<p> A matrix of order IxJ measuring in each unit a distance to the homogeneity hypothesis. That is, the differences under the homogeneity hypothesis between the actual recorded results and the expected results in each territorial unit for each option of election one. The matrix Eij.</p>
</td></tr>
<tr><td><code>deterministic.bounds</code></td>
<td>
<p> A list of two matrices of order JxK and two arrays of order JxKxI containing for each vote transition the lower and upper allowed proportions given the observed aggregates.</p>
</td></tr>
<tr><td><code>inputs</code></td>
<td>
<p> A list containing all the objects with the values used as arguments by the function.</p>
</td></tr>
<tr><td><code>solution_init</code></td>
<td>
<p> A list with the main outputs produced by <strong>lphom_joint()</strong>.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Jose M. Pavia, <a href="mailto:pavia@uv.es">pavia@uv.es</a>
</p>
<p>Rafael Romero <a href="mailto:rromero@eio.upv.es">rromero@eio.upv.es</a>
</p>


<h3>References</h3>

<p>Pavia, JM and Romero, R (2024). Symmetry estimating RxC vote transfer matrices from aggregate data. <em>Journal of the Royal Statistical Society, Series A – Statistics in Society</em>, forthcoming.  <a href="https://doi.org/10.1093/jrsssa/qnae013">doi:10.1093/jrsssa/qnae013</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+nslphom">nslphom</a></code> <code><a href="#topic+lphom_dual">lphom_dual</a></code> <code><a href="#topic+tslphom_dual">tslphom_dual</a></code> <code><a href="#topic+nslphom_dual">nslphom_dual</a></code> <code><a href="#topic+lphom_joint">lphom_joint</a></code> <code><a href="#topic+tslphom_joint">tslphom_joint</a></code>
</p>
<p>Other linear programing ecological inference functions: 
<code><a href="#topic+lclphom">lclphom</a>()</code>,
<code><a href="#topic+lp_apriori">lp_apriori</a>()</code>,
<code><a href="#topic+lphom_dual">lphom_dual</a>()</code>,
<code><a href="#topic+lphom_joint">lphom_joint</a>()</code>,
<code><a href="#topic+lphom">lphom</a>()</code>,
<code><a href="#topic+nslphom_dual">nslphom_dual</a>()</code>,
<code><a href="#topic+nslphom">nslphom</a>()</code>,
<code><a href="#topic+rslphom">rslphom</a>()</code>,
<code><a href="#topic+tslphom_dual">tslphom_dual</a>()</code>,
<code><a href="#topic+tslphom_joint">tslphom_joint</a>()</code>,
<code><a href="#topic+tslphom">tslphom</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- France2017P[, 1:8]
y &lt;- France2017P[, 9:12]
y[,1] &lt;- y[,1]  - (rowSums(y) - rowSums(x))
mt &lt;- nslphom_joint(x, y, iter.max = 3)
mt$VTM.votes
mt$HETe
</code></pre>

<hr>
<h2 id='plot.lphom'>Graphical representation of a RxC ecological inference (vote transfer) matrix</h2><span id='topic+plot.lphom'></span>

<h3>Description</h3>

<p>Plot method for objects obtained with an algorithm of the lphom-family (lphom, tslphom, nslphom, tslphom_dual, nslphom_joint, ....).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'lphom'
plot(
  x,
  complete = FALSE,
  margins = TRUE,
  digits = 2,
  row.names = NULL,
  col.names = NULL,
  size.numbers = 6,
  size.labels = 4,
  size.margins = 4,
  colour.cells = "deeppink3",
  colour.grid = "blanchedalmond",
  alpha = 0.5,
  which = NULL,
  ...,
  type = "w",
  show.plot = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.lphom_+3A_x">x</code></td>
<td>
<p>An object output of a <code>lphom</code>  family algorithm.</p>
</td></tr>
<tr><td><code id="plot.lphom_+3A_complete">complete</code></td>
<td>
<p>A <code>TRUE/FALSE</code> argument informing if the complete matrix should be displayed. In <code>raw</code>, <code>regular</code>, <code>ordinary</code> and <code>enriched</code> scenarios the plot includes the row and the column corresponding to net_entries and net_exits even when they are really small, less than 1% in all units. Default, <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="plot.lphom_+3A_margins">margins</code></td>
<td>
<p>A <code style="white-space: pre;">&#8288;TRUE/FALSE`` argument informing if the margins of the matrix should be displayed. Default &#8288;</code>TRUE'.</p>
</td></tr>
<tr><td><code id="plot.lphom_+3A_digits">digits</code></td>
<td>
<p>Integer indicating the number of decimal places to be shown. Default, 2.</p>
</td></tr>
<tr><td><code id="plot.lphom_+3A_row.names">row.names</code></td>
<td>
<p>Names to be used for the rows of the matrix.</p>
</td></tr>
<tr><td><code id="plot.lphom_+3A_col.names">col.names</code></td>
<td>
<p>Names to be used for the columns of the matrix.</p>
</td></tr>
<tr><td><code id="plot.lphom_+3A_size.numbers">size.numbers</code></td>
<td>
<p>A reference number indicating the average font size to be used for the transfer numbers. Default, 6.</p>
</td></tr>
<tr><td><code id="plot.lphom_+3A_size.labels">size.labels</code></td>
<td>
<p>A number indicating the font size to be used for labels. Default, 4.</p>
</td></tr>
<tr><td><code id="plot.lphom_+3A_size.margins">size.margins</code></td>
<td>
<p>A number indicating the font size to be used for margin numbers. Default, 4.</p>
</td></tr>
<tr><td><code id="plot.lphom_+3A_colour.cells">colour.cells</code></td>
<td>
<p>Background base colour for cells.</p>
</td></tr>
<tr><td><code id="plot.lphom_+3A_colour.grid">colour.grid</code></td>
<td>
<p>Colour to be used for grid lines.</p>
</td></tr>
<tr><td><code id="plot.lphom_+3A_alpha">alpha</code></td>
<td>
<p>A [0,1] number of colour transparency.</p>
</td></tr>
<tr><td><code id="plot.lphom_+3A_which">which</code></td>
<td>
<p>A vector of integers informing the units for which the aggregate transfer matrix should be plotted. Default, <code>NULL</code>, the global matrix is shown.</p>
</td></tr>
<tr><td><code id="plot.lphom_+3A_...">...</code></td>
<td>
<p>Other arguments passed on to methods. Not currently used.</p>
</td></tr>
<tr><td><code id="plot.lphom_+3A_type">type</code></td>
<td>
<p>A character string indicating the solution (transfer matrix) to be plotted. Only valid for <strong>_dual</strong> algorithms. <code>type = "w"</code> stands for the weighted solution and <code>type = "a"</code> for the simple average solution. Default <code>w</code>.</p>
</td></tr>
<tr><td><code id="plot.lphom_+3A_show.plot">show.plot</code></td>
<td>
<p>A <code>TRUE/FALSE</code> argument indicating if the plot should be displayed as a side-effect. By default, <code>TRUE</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Invisibly returns the (ggplot) description of the plot, which is a list with components that contain the plot itself, the data, information about the scales, panels etc.
</p>


<h3>Note</h3>

<p>ggplot2 is needed to be installed for this function to work.
</p>


<h3>Author(s)</h3>

<p>Jose M. Pavia, <a href="mailto:pavia@uv.es">pavia@uv.es</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>mt.ns &lt;- nslphom(France2017P[, 1:8] , France2017P[, 9:12], new_and_exit_voters= "raw")
p &lt;- plot(mt.ns, show.plot = FALSE)
p

</code></pre>

<hr>
<h2 id='print.lphom'>Print a summary of a lphom-family object</h2><span id='topic+print.lphom'></span>

<h3>Description</h3>

<p>Print method for objects obtained with an algorithm of the lphom-family (lphom, tslphom, nslphom, tslphom_dual, nslphom_joint, ....).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'lphom'
print(x, ..., margins = TRUE, digits = 2)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.lphom_+3A_x">x</code></td>
<td>
<p>An object output of a <code>lphom</code> family algorithm.</p>
</td></tr>
<tr><td><code id="print.lphom_+3A_...">...</code></td>
<td>
<p>Other arguments passed on to methods. Not currently used.</p>
</td></tr>
<tr><td><code id="print.lphom_+3A_margins">margins</code></td>
<td>
<p>A <code>TRUE/FALSE</code> argument informing if the margins of the matrix should be displayed. Default <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="print.lphom_+3A_digits">digits</code></td>
<td>
<p>Integer indicating the number of decimal places to be shown. Default, 2.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Jose M. Pavia, <a href="mailto:pavia@uv.es">pavia@uv.es</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>mt.ns &lt;- nslphom(France2017P[, 1:8] , France2017P[, 9:12], new_and_exit_voters= "raw")
print(mt.ns, digits = 2, margins = TRUE)

</code></pre>

<hr>
<h2 id='print.summary.lphom'>Print a summary of a lphom-family object</h2><span id='topic+print.summary.lphom'></span>

<h3>Description</h3>

<p>Print method for <code>summary.lphom</code> objects
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'summary.lphom'
print(x, ..., margins = TRUE, digits = 2)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.summary.lphom_+3A_x">x</code></td>
<td>
<p>An <code>summary.lphom</code> class object.</p>
</td></tr>
<tr><td><code id="print.summary.lphom_+3A_...">...</code></td>
<td>
<p>Other arguments passed on to methods. Not currently used.</p>
</td></tr>
<tr><td><code id="print.summary.lphom_+3A_margins">margins</code></td>
<td>
<p>A <code>TRUE/FALSE</code> argument informing if the margins of the matrix should be displayed. Default <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="print.summary.lphom_+3A_digits">digits</code></td>
<td>
<p>Integer indicating the number of decimal places to be shown. Default, 2.</p>
</td></tr>
</table>

<hr>
<h2 id='rslphom'>Implements rslphom algorithm</h2><span id='topic+rslphom'></span>

<h3>Description</h3>

<p>Estimates RxC (JxK) vote transfer matrices (ecological contingency tables) with rslphom
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rslphom(
  votes_election1,
  votes_election2,
  emphasis = 0.995,
  new_and_exit_voters = c("raw", "regular", "ordinary", "enriched", "adjust1", "adjust2",
    "simultaneous", "semifull", "full", "fullreverse", "gold"),
  apriori = NULL,
  lambda = 0.5,
  uniform = TRUE,
  structural_zeros = NULL,
  integers = FALSE,
  distance.local = c("abs", "max", "none"),
  save.local.by.emphasis = FALSE,
  verbose = TRUE,
  solver = "lp_solve",
  integers.solver = "symphony",
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rslphom_+3A_votes_election1">votes_election1</code></td>
<td>
<p>data.frame (or matrix) of order IxJ1 with the votes gained by
(or the counts corresponding to) the J1 political options competing
(available) on election 1 (or origin) in the I units considered.
In general, the row marginals of the I tables corresponding
to the units.</p>
</td></tr>
<tr><td><code id="rslphom_+3A_votes_election2">votes_election2</code></td>
<td>
<p>data.frame (or matrix) of order IxK2
with the votes gained by (or the counts corresponding to) the K2
political options competing (available) on election 2 (or destination)
in the I (territorial) units considered. In general, the column marginals
of the I tables corresponding to the units.</p>
</td></tr>
<tr><td><code id="rslphom_+3A_emphasis">emphasis</code></td>
<td>
<p>A numerical vector of values between 0 and 1 informing of the weights/emphasis to be used
to promote each unit when estimating its transfer matrix. Default, 0.995. When the length
of <code>emphasis</code> is one, only a weight (a level of emphasis) is analyzed. When the length of
<code>emphasis</code> is higher than one, as many as different weights/emphasis as the length of
emphasis are tried in the estimation of the transfer matrix of each unit. In each unit,
the local solution selected corresponds to the transfer matrix with lower expected error.</p>
</td></tr>
<tr><td><code id="rslphom_+3A_new_and_exit_voters">new_and_exit_voters</code></td>
<td>
<p>A character string indicating the level of information available
in <code>votes_election1</code> and <code>votes_election2</code> regarding new entries
and exits of the election censuses between the two elections.
This argument allows, in addition to the options discussed in Pavia
(2023), three more options. This argument admits eleven different values:
<code>raw</code>, <code>regular</code>, <code>ordinary</code>, <code>enriched</code>, <code>adjust1</code>, <code>adjust2</code>,
<code>simultaneous</code>, <code>semifull</code>, <code>full</code>, <code>fullreverse</code> and <code>gold</code>.
Default, <code>raw</code>.</p>
</td></tr>
<tr><td><code id="rslphom_+3A_apriori">apriori</code></td>
<td>
<p>data.frame (or matrix) of order J0xK0 with an initial estimate of the
(row-standarized) global voter transition proportions/fractions, pjk0, between
the first J0 (election) options of election 1 and the first K0 (election) options
of election 2. This matrix can contain some missing values. When no a priori
information is available <code>apriori</code> is a null object. Default, <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="rslphom_+3A_lambda">lambda</code></td>
<td>
<p>A number between 0 and 1 informing the relative weight the user assigns to the
<code>apriori</code> information. Setting <code>lambda = 0</code> is equivalent to not having a priori
information (i.e., <code>apriori = NULL</code>). Default, <code>0.5</code>.</p>
</td></tr>
<tr><td><code id="rslphom_+3A_uniform">uniform</code></td>
<td>
<p>A <code>TRUE/FALSE</code> value that informs whether census exits impact all the electoral options
in a (relatively) similar fashion in all iterations, including iteration 0 and
when deriving units tables. If <code>uniform = TRUE</code> typically at least one of the equations
among equations (6) to (11) of Pavia (2023) is included in the underlying model.
This parameter has no effect in <code>simultaneous</code> scenarios. It also has not impact
in <code>raw</code> and <code>regular</code> scenarios when no net exits are estimated by the function
from the provided information. Default, <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="rslphom_+3A_structural_zeros">structural_zeros</code></td>
<td>
<p>Default <code>NULL</code>. A list of vectors of length two, indicating the election options
for which no transfer of votes are allowed between election 1 and election 2.
For instance, when new_and_exit_voters is set to <code>"semifull"</code>,
lphom implicitly states <code>structural_zeros = list(c(J1, K2))</code>.</p>
</td></tr>
<tr><td><code id="rslphom_+3A_integers">integers</code></td>
<td>
<p>A <code>TRUE/FALSE</code> value that indicates whether the problem is solved in integer values
in all the steps, including lphom intermediate solutions and unit solutions.
If <code>integers = TRUE</code>, the LP matrices are approximated to the closest integer solution solving
the corresponding Integer Linear Program. Default, <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="rslphom_+3A_distance.local">distance.local</code></td>
<td>
<p>A string argument that indicates whether the second step of the lphom_local algorithm
should be performed to solve potential indeterminacies of local solutions.
Default, <code>"abs"</code>.
If <code>distance.local = "abs"</code> lphom_local selects in its second step the matrix
closer to the temporary global solution under L_1 norm, among the first step compatible matrices.
If <code>distance.local = "max"</code> lphom_local selects in its second step the matrix
closer to the temporary global solution under L_Inf norm, among the first step compatible matrices.
If <code>distance.local = "none"</code>, the second step of lphom_local is not performed.</p>
</td></tr>
<tr><td><code id="rslphom_+3A_save.local.by.emphasis">save.local.by.emphasis</code></td>
<td>
<p>A <code>TRUE/FALSE</code> value that indicates if the estimated matrices obtained in each unit
for each value of emphasis should be saved. Default, <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="rslphom_+3A_verbose">verbose</code></td>
<td>
<p>A <code>TRUE/FALSE</code> value that indicates if a summary of the results of the computations performed
to estimate net entries and exits should be printed on the screen. Default, <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="rslphom_+3A_solver">solver</code></td>
<td>
<p>A character string indicating the linear programming solver to be used, only
<code>lp_solve</code> and <code>symphony</code> are allowed. By default, <code>lp_solve</code>. The package <code>Rsymphony</code>
needs to be installed for the option <code>symphony</code> to be used.</p>
</td></tr>
<tr><td><code id="rslphom_+3A_integers.solver">integers.solver</code></td>
<td>
<p>A character string indicating the linear programming solver to be used for
approximating the LP solution to the closest integer solution.
Only <code>symphony</code> and <code>lp_solve</code> are allowed. By default, <code>symphony</code>.
The package <code>Rsymphony</code> needs to be installed for the
option <code>symphony</code> to be used. Only used when <code>integers = TRUE</code>.</p>
</td></tr>
<tr><td><code id="rslphom_+3A_...">...</code></td>
<td>
<p>Other arguments to be passed to the function. Not currently used.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Description of the <code>new_and_exit_voters</code> argument in more detail.
</p>

<ul>
<li> <p><code>raw</code>: The default value. This argument accounts for the most plausible scenario when
estimating vote transfer matrices. A scenario with two elections elapsed at least
some months where only the raw election data recorded in the I (territorial) units,
in which the electoral space under study is divided, are available.
In this scenario, net exits and net entries are estimated according to
equation (7) of Romero et al. (2020). When both net entries and exits are no
null, constraint (15) of Pavia (2023) applies. If there are net exits and <code>uniform = TRUE</code>
either constraints (6) or (8) and (15) of Pavia (2023) are imposed. In this scenario,
J could be equal to J1 or J1 + 1 and K equal to K2 or K2 + 1.
</p>
</li>
<li> <p><code>regular</code>: This value accounts for a scenario with
two elections elapsed at least some months where (i) the column J1
of <code>votes_election1</code> corresponds to new young electors who have the right
to vote for the first time, (ii) net exits and maybe other additional
net entries are computed according to equation (7) of Romero et al. (2020), and
(iii) we can (or not) assume that net exits impact equally all the first J1 - 1
options of election 1. When both net entries and exits are no null, constraints
(13) and (15) of Pavia (2023) apply. If <code>uniform = TRUE</code> and there are net exits either
constraints (8) or (11) of Pavia (2023), depending on whether there are or not net
entries, are also imposed. In this scenario, J could be equal to J1 or J1 + 1 and
K equal to K2 or K2 + 1. Note that this scenario could be also used if
column J1 of <code>votes_election1</code> would correspond to immigrants instead of
new young electors.
</p>
</li>
<li> <p><code>ordinary</code>: This value accounts for a scenario
with two elections elapsed at least some months where (i) the column K1
of <code>votes_election2</code> corresponds to electors who died in the period between
elections, (ii) net entries and maybe other additional net exits are
computed according to equation (7) of Romero et al. (2020), and (iii) we can
assume (or not) that exits impact equally all the J1 options of election 1.
When both net entries and exits are no null, constraints (14) and
(15) of Pavia (2023) apply and if <code>uniform = TRUE</code> either constraints
(8) and (9) or, without net entries, (6) and (7) of Pavia (2023) are also imposed.
In this scenario, J could be equal to J1 or J1 + 1 and K equal to K2 or K2 + 1.
Note that this scenario could be also used if column K1 of
<code>votes_election2</code> would correspond to emigrants instead of deaths.
</p>
</li>
<li> <p><code>enriched</code>: This value accounts for a scenario that somehow combine <code>regular</code> and
<code>ordinary</code> scenarios. We consider two elections elapsed at least some months where
(i) the column J1 of <code>votes_election1</code> corresponds to new young electors
who have the right to vote for the first time, (ii) the column K2 of
<code>votes_election2</code> corresponds to electors who died in the interperiod
election, (iii) other (net) entries and (net) exits are computed according
to equation (7) of Romero et al. (2020), and (iv) we can assume
(or not) that exits impact equally all the J1 - 1 options of election 1.
When both net entries and exits are no null, constraints (12) to
(15) of Pavia (2023) apply and if <code>uniform = TRUE</code> constraints
(10) and (11) of Pavia (2023) are also imposed. In this scenario, J could be equal
to J1 or J1 + 1 and K equal to K2 or K2 + 1. Note that this scenario could be also used if
the column J1 of <code>votes_election1</code> would correspond to immigrants instead of
new young electors and/or if column K1 of <code>votes_election2</code> would correspond
to emigrants instead of deaths.
</p>
</li>
<li> <p><code>adjust1</code>: This value accounts for a scenario
with two elections elapsed at least some months where the census in
each of the I polling units of the first election (the row-sums of <code>votes_election1</code>) are
proportionally adjusted to match the corresponding census of the polling units in the
second election (the row-sums of <code>votes_election2</code>).
If <code>integers = TRUE</code>, each row in <code>votes_election1</code> is proportionally adjusted to the closest integer
vector whose sum is equal to the sum of the corresponding row in <code>votes_election2</code>.
</p>
</li>
<li> <p><code>adjust2</code>: This value accounts for a scenario
with two elections elapsed at least some months where the census in
each of the I polling units of the second election (the row-sums of <code>votes_election2</code>)
are proportionally adjusted to match the corresponding census of the polling units
in the first election (the row-sums of <code>votes_election1</code>).
If <code>integers = TRUE</code>, each row in <code>votes_election2</code> is adjusted to the closest integer
vector whose sum is equal to the sum of the corresponding row in <code>votes_election1</code>.
</p>
</li>
<li> <p><code>simultaneous</code>: This is the value to be used in classical ecological inference problems,
such as in ecological studies of racial voting, and in scenarios with two simultaneous elections.
In this scenario, the sum by rows of <code>votes_election1</code> and <code>votes_election2</code> must coincide.
Constraints defined by equations (8) and (9) of Romero et al. (2020) are not included in
the model. In this case, the lphom function just implements the basic model defined,
for instance, by equations (1) to (5) of Pavia (2024).
</p>
</li>
<li> <p><code>semifull</code>: This value accounts for a scenario with two elections elapsed at least some
months, where: (i) the column J1 = J of <code>votes_election1</code> totals new
electors (young and immigrants) that have the right to vote for the first time and
(ii) the column K2 = K of <code>votes_election2</code> corresponds to total exits of the census
lists (due to death or emigration). In this scenario, the sum by rows of
<code>votes_election1</code> and <code>votes_election2</code> must agree and constraint (15)
of Pavia (2023) apply. Additionally, if <code>uniform = TRUE</code> constraints
(8) of Pavia (2023) are also imposed.
</p>
</li>
<li> <p><code>full</code>: This value accounts for a scenario with two elections elapsed at least some
months, where (i) the column J - 1 of <code>votes_election1</code> totals new young
electors that have the right to vote for the first time, (ii) the column J (=J1)
of <code>votes_election1</code> measures new immigrants that have the right to vote and
(iii) the column K (=K2) of <code>votes_election2</code> corresponds to total exits of the census
lists (due to death or emigration). In this scenario, the sum by rows of
<code>votes_election1</code> and <code>votes_election2</code> must agree and constraints (13)
and (15) of Pavia (2023) apply.  Additionally, if <code>uniform = TRUE</code> constraints
(11) of Pavia (2023) are also imposed.
</p>
</li>
<li> <p><code>fullreverse</code>: This value is somehow the mirror version of <code>full</code>.
It accounts for a scenario with two elections elapsed at least some
months, where (i) the column J1 = J of <code>votes_election1</code> totals new
electors (young and immigrants) that have the right to vote for the first time and
(ii) where total exits are separated out between exits due to emigration
(column K - 1 of <code>votes_election2</code>) and death (column K of <code>votes_election2</code>).
In this scenario, the sum by rows of <code>votes_election1</code> and <code>votes_election2</code> must
agree and constraints (14) and (15) of Pavia (2023) apply.
Additionally, if <code>uniform = TRUE</code> constraints (8) and (9) of Pavia (2023) are also imposed.
</p>
</li>
<li> <p><code>gold</code>: This value accounts for a scenario similar to <code>full</code>, where total exits are
separated out between exits due to emigration (column K - 1 of <code>votes_election2</code>)
and death (column K of <code>votes_election2</code>). In this scenario, the sum by rows
of <code>votes_election1</code> and <code>votes_election2</code> must agree. Constraints (12) to
(15) of Pavia (2023) apply and if <code>uniform = TRUE</code> constraints (10) and (11)
of Pavia (2023) are also imposed.
</p>
</li></ul>



<h3>Value</h3>

<p>A list with the following components
</p>
<table>
<tr><td><code>VTM</code></td>
<td>
<p> A matrix of order J'xK' (where J'=J-1 or J and K'= K-1 or K) with the estimated percentages of row-standardized vote transitions from election 1 to election 2.
In <code>raw</code>, <code>regular</code>, <code>ordinary</code> and <code>enriched</code> scenarios when the percentage of net entries is small, less than 1% of the census in all units,
net entries are omitted (i.e., the number of rows of <code>VTM</code> is equal to J1) even when estimates for net entries different from zero are obtained. Likewise, in the same scenarios when the percentage of net exits is small, less than 1%
of the census in all units, net exits are omitted (i.e., the number of rows of <code>VTM</code> is equal to K2) even when estimates for net exits different from zero are obtained.</p>
</td></tr>
<tr><td><code>VTM.votes</code></td>
<td>
<p> A matrix of order J'xK' (where J'=J-1 or J and K'= K-1 or K) with the estimated vote transitions from election 1 to election 2.
In <code>raw</code>, <code>regular</code>, <code>ordinary</code> and <code>enriched</code> scenarios when the percentage of net entries is small, less than 1% of the census,
net entries are omitted (i.e., J = J1) even when estimates for net entries different from zero are obtained. Likewise, in the same scenarios when the percentage of net exits is small, less than 1%
of the census, net exits are omitted (i.e., K = K2) even when estimates for net exits different from zero are obtained.</p>
</td></tr>
<tr><td><code>OTM</code></td>
<td>
<p> A matrix of order KxJ with the estimated percentages of the origin of the votes obtained for the different options of election 2.</p>
</td></tr>
<tr><td><code>HETe</code></td>
<td>
<p> The estimated heterogeneity index as defined in equation (15) of Pavia and Romero (2022).</p>
</td></tr>
<tr><td><code>VTM.complete</code></td>
<td>
<p> A matrix of order JxK with the estimated proportions of row-standardized vote transitions from election 1 to election 2, including in <code>raw</code>, <code>regular</code>, <code>ordinary</code> and <code>enriched</code> scenarios the row and the column corresponding to net_entries and net_exits even when they are really small, less than 1% in all units.</p>
</td></tr>
<tr><td><code>VTM.complete.votes</code></td>
<td>
<p> A matrix of order JxK with the estimated vote transitions from election 1 to election 2, including in <code>raw</code>, <code>regular</code>, <code>ordinary</code> and <code>enriched</code> scenarios the row and the column corresponding to net_entries and net_exits even when they are really small, less than 1% in all units.</p>
</td></tr>
<tr><td><code>VTM.prop.units</code></td>
<td>
<p> An array of order JxKxI with the estimated proportions of vote transitions from election 1 to election 2 attained for each unit after adjusting the <strong>lphom()</strong> initial estimate.</p>
</td></tr>
<tr><td><code>VTM.votes.units</code></td>
<td>
<p> An array of order JxKxI with the estimated matrix of vote transitions from election 1 to election 2 attained for each unit after adjusting the <strong>lphom()</strong> initial estimate.</p>
</td></tr>
<tr><td><code>VTM.sequence</code></td>
<td>
<p> Array of order JxKxlength(emphasis) with the global estimated matrices corresponding to each weight.</p>
</td></tr>
<tr><td><code>zeros</code></td>
<td>
<p> A list of vectors of length two, indicating the election options for which no transfer of votes are allowed between election 1 and election 2.</p>
</td></tr>
<tr><td><code>errors</code></td>
<td>
<p> A matrix of order Ixlength(emphasis) with the expected errors for each unit and weight. The
solution determined by <code>VTM.prop.units</code> or <code>VTM.votes.units</code> is the one obtained combining the unit solutions
corresponding to the minimum observed errors.</p>
</td></tr>
<tr><td><code>VTM.prop.units.by.emphasis</code></td>
<td>
<p> An array of order JxKxIxlength(emphasis) with the estimated proportions of vote transitions from election 1 to election 2 attained in each unit for each weight.
This is a <code>NULL</code> array if <code>save.local.by.emphasis = FALSE</code>.</p>
</td></tr>
<tr><td><code>deterministic.bounds</code></td>
<td>
<p> A list of two matrices of order JxK and two arrays of order JxKxI containing for each vote transition the lower and upper allowed proportions given the observed aggregates.</p>
</td></tr>
<tr><td><code>inputs</code></td>
<td>
<p> A list containing all the objects with the values used as arguments by the function.</p>
</td></tr>
<tr><td><code>origin</code></td>
<td>
<p> A matrix with the final data used as votes of the origin election after taking into account the level of information available regarding to new entries and exits of the election censuses between the two elections.</p>
</td></tr>
<tr><td><code>destination</code></td>
<td>
<p> A matrix with the final data used as votes of the origin election after taking into account the level of information available regarding to new entries and exits of the election censuses between the two elections.</p>
</td></tr>
<tr><td><code>EHet</code></td>
<td>
<p> A matrix of order IxK measuring in each spatial unit a distance to the homogeneity hypothesis, that is, the differences under the homogeneity hypothesis between the actual recorded results and the expected results with the solution in each territorial unit for each option of election 2.</p>
</td></tr>
<tr><td><code>solution_init</code></td>
<td>
<p> A list with the main outputs produced by <strong>lphom()</strong>.</p>
</td></tr>
</table>

<ul>
<li> <p><code>VTM_init</code>: A matrix of order J'xK' with the estimated percentages of vote transitions from election 1 to election 2 initially obtained by <strong>lphom()</strong> with the raw data, without promoting any unit.
</p>
</li>
<li> <p><code>VTM.votes_init</code>: A matrix of order J'xK' with the estimated vote transitions from election 1 to election 2 initially obtained by <strong>lphom()</strong>  with the raw data, without promoting any unit.
</p>
</li>
<li> <p><code>OTM_init</code>: A matrix of order KxJ with the estimated percentages of the origin of the votes obtained for the different options of election 2 initially obtained by <strong>lphom()</strong>  with the raw data, without promoting any unit.
</p>
</li>
<li> <p><code>HETe_init</code>: The estimated heterogeneity index defined in equation (10) of Romero et al. (2020).
</p>
</li>
<li> <p><code>EHet_init</code>: A matrix of order IxK measuring in each spatial unit the distance to the homogeneity hypothesis, that is, the differences under the homogeneity hypothesis between the actual recorded results and the expected results, using the <strong>lphom()</strong> solution  with the raw data, without promoting any unit, in each territorial unit for each option of election 2.
</p>
</li>
<li> <p><code>VTM.complete_init</code>: A matrix of order JxK with the estimated proportions of vote transitions from election 1 to election 2 initially obtained by <strong>lphom()</strong>, including in <code>raw</code>, <code>regular</code>, <code>ordinary</code> and <code>enriched</code> scenarios the row and the column corresponding to net_entries and net_exits even when they are really small, less than 1% in all units.
</p>
</li>
<li> <p><code>VTM.complete.votes_init</code>: A matrix of order JxK with the estimated vote transitions from election 1 to election 2 initially obtained by <strong>lphom()</strong>, including in <code>raw</code>, <code>regular</code>, <code>ordinary</code> and <code>enriched</code> scenarios the row and the column corresponding to net_entries and net_exits even when they are really small, less than 1% in all units.
</p>
</li></ul>



<h3>Author(s)</h3>

<p>Jose M. Pavia, <a href="mailto:pavia@uv.es">pavia@uv.es</a>
</p>


<h3>References</h3>

<p>Pavia, JM, and Romero, R (2022). Improving estimates accuracy of voter transitions. Two new algorithms for ecological inference based on linear programming, <em>Sociological Methods &amp; Research</em>. <a href="https://doi.org/10.1177/00491241221092725">doi:10.1177/00491241221092725</a>.
</p>
<p>Pavia, JM, and Penades, A (2024). A bottom-up approach for ecological inference.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+lphom">lphom</a></code> <code><a href="#topic+tslphom">tslphom</a></code> <code><a href="#topic+nslphom">nslphom</a></code> <code><a href="#topic+lclphom">lclphom</a></code>
</p>
<p>Other linear programing ecological inference functions: 
<code><a href="#topic+lclphom">lclphom</a>()</code>,
<code><a href="#topic+lp_apriori">lp_apriori</a>()</code>,
<code><a href="#topic+lphom_dual">lphom_dual</a>()</code>,
<code><a href="#topic+lphom_joint">lphom_joint</a>()</code>,
<code><a href="#topic+lphom">lphom</a>()</code>,
<code><a href="#topic+nslphom_dual">nslphom_dual</a>()</code>,
<code><a href="#topic+nslphom_joint">nslphom_joint</a>()</code>,
<code><a href="#topic+nslphom">nslphom</a>()</code>,
<code><a href="#topic+tslphom_dual">tslphom_dual</a>()</code>,
<code><a href="#topic+tslphom_joint">tslphom_joint</a>()</code>,
<code><a href="#topic+tslphom">tslphom</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>mt.rs &lt;- rslphom(France2017P[, 1:8] , France2017P[, 9:12], emphasis = 0.5)
mt.rs$VTM

</code></pre>

<hr>
<h2 id='summary.lphom'>Summarize a lphom-family object</h2><span id='topic+summary.lphom'></span>

<h3>Description</h3>

<p>Summary method for objects obtained with an algorithm of the lphom-family (lphom, tslphom, nslphom, tslphom_dual, nslphom_joint, ....).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'lphom'
summary(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary.lphom_+3A_object">object</code></td>
<td>
<p>An object output of a <code>lphom</code> family algorithm.</p>
</td></tr>
<tr><td><code id="summary.lphom_+3A_...">...</code></td>
<td>
<p>Other arguments passed on to methods. Not currently used.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <code>"summary.lphom"</code>.
</p>


<h3>Author(s)</h3>

<p>Jose M. Pavia, <a href="mailto:pavia@uv.es">pavia@uv.es</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>mt.ns &lt;- nslphom(France2017P[, 1:8] , France2017P[, 9:12], new_and_exit_voters= "raw")
summary(mt.ns)

</code></pre>

<hr>
<h2 id='tslphom'>Implements tslphom algorithm</h2><span id='topic+tslphom'></span>

<h3>Description</h3>

<p>Estimates RxC (JxK) vote transfer matrices (ecological contingency tables) with tslphom
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tslphom(
  votes_election1,
  votes_election2,
  new_and_exit_voters = c("raw", "regular", "ordinary", "enriched", "adjust1", "adjust2",
    "simultaneous", "semifull", "full", "fullreverse", "gold"),
  apriori = NULL,
  lambda = 0.5,
  uniform = TRUE,
  structural_zeros = NULL,
  integers = FALSE,
  distance.local = c("abs", "max", "none"),
  verbose = TRUE,
  solver = "lp_solve",
  integers.solver = "symphony",
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tslphom_+3A_votes_election1">votes_election1</code></td>
<td>
<p>data.frame (or matrix) of order IxJ1 with the votes gained by
(or the counts corresponding to) the J1 political options competing
(available) on election 1 (or origin) in the I units considered.
In general, the row marginals of the I tables corresponding
to the units.</p>
</td></tr>
<tr><td><code id="tslphom_+3A_votes_election2">votes_election2</code></td>
<td>
<p>data.frame (or matrix) of order IxK2
with the votes gained by (or the counts corresponding to) the K2
political options competing (available) on election 2 (or destination)
in the I (territorial) units considered. In general, the column marginals
of the I tables corresponding to the units.</p>
</td></tr>
<tr><td><code id="tslphom_+3A_new_and_exit_voters">new_and_exit_voters</code></td>
<td>
<p>A character string indicating the level of information available
in <code>votes_election1</code> and <code>votes_election2</code> regarding new entries
and exits of the election censuses between the two elections.
This argument allows, in addition to the options discussed in Pavia
(2023), three more options. This argument admits eleven different values:
<code>raw</code>, <code>regular</code>, <code>ordinary</code>, <code>enriched</code>, <code>adjust1</code>, <code>adjust2</code>,
<code>simultaneous</code>, <code>semifull</code>, <code>full</code>, <code>fullreverse</code> and <code>gold</code>.
Default, <code>raw</code>.</p>
</td></tr>
<tr><td><code id="tslphom_+3A_apriori">apriori</code></td>
<td>
<p>data.frame (or matrix) of order J0xK0 with an initial estimate of the
(row-standarized) global voter transition proportions/fractions, pjk0, between
the first J0 (election) options of election 1 and the first K0 (election) options
of election 2. This matrix can contain some missing values. When no a priori
information is available <code>apriori</code> is a null object. Default, <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="tslphom_+3A_lambda">lambda</code></td>
<td>
<p>A number between 0 and 1, informing the relative weight the user assigns to the
<code>apriori</code> information. Setting <code>lambda = 0</code> is equivalent to not having a priori
information (i.e., <code>apriori = NULL</code>). Default, <code>0.5</code>.</p>
</td></tr>
<tr><td><code id="tslphom_+3A_uniform">uniform</code></td>
<td>
<p>A <code>TRUE/FALSE</code> value that informs whether census exits impact all the electoral options
in a (relatively) similar fashion in all iterations, including iteration 0 and
when deriving units tables. If <code>uniform = TRUE</code> typically at least one of the equations
among equations (6) to (11) of Pavia (2023) is included in the underlying model.
This parameter has no effect in <code>simultaneous</code> scenarios. It also has not impact
in <code>raw</code> and <code>regular</code> scenarios when no net exits are estimated by the function
from the provided information. Default, <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="tslphom_+3A_structural_zeros">structural_zeros</code></td>
<td>
<p>Default <code>NULL</code>. A list of vectors of length two, indicating the election options
for which no transfer of votes are allowed between election 1 and election 2.
For instance, when new_and_exit_voters is set to <code>"semifull"</code>,
lphom implicitly states <code>structural_zeros = list(c(J1, K2))</code>.</p>
</td></tr>
<tr><td><code id="tslphom_+3A_integers">integers</code></td>
<td>
<p>A <code style="white-space: pre;">&#8288;TRUE/FALSE`` value that indicates whether the problem is solved in integer values in both iterations, including iteration zero (lphom) and final (including unit) solutions.  If &#8288;</code>integers = TRUE<code style="white-space: pre;">&#8288;, the LP matrices are approximated to the closest integer solution solving  the corresponding Integer Linear Program. Default, &#8288;</code>FALSE'.</p>
</td></tr>
<tr><td><code id="tslphom_+3A_distance.local">distance.local</code></td>
<td>
<p>A string argument that indicates whether the second step of the lphom_local algorithm
should be performed to solve potential indeterminacies of local solutions.
Default, <code>"abs"</code>.
If <code>distance.local = "abs"</code> lphom_local selects in its second step the matrix
closer to the temporary global solution under L_1 norm, among the first step compatible matrices.
If <code>distance.local = "max"</code> lphom_local selects in its second step the matrix
closer to the temporary global solution under L_Inf norm, among the first step compatible matrices.
If <code>distance.local = "none"</code>, the second step of lphom_local is not performed.</p>
</td></tr>
<tr><td><code id="tslphom_+3A_verbose">verbose</code></td>
<td>
<p>A <code>TRUE/FALSE</code> value that indicates if a summary of the results of the computations performed
to estimate net entries and exits should be printed on the screen. Default, <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="tslphom_+3A_solver">solver</code></td>
<td>
<p>A character string indicating the linear programming solver to be used, only
<code>lp_solve</code> and <code>symphony</code> are allowed. By default, <code>lp_solve</code>. The package <code>Rsymphony</code>
needs to be installed for the option <code>symphony</code> to be used.</p>
</td></tr>
<tr><td><code id="tslphom_+3A_integers.solver">integers.solver</code></td>
<td>
<p>A character string indicating the linear programming solver to be used for
approximating the LP solution to the closest integer solution.
Only <code>symphony</code> and <code>lp_solve</code> are allowed. By default, <code>symphony</code>.
The package <code>Rsymphony</code> needs to be installed for the
option <code>symphony</code> to be used. Only used when <code>integers = TRUE</code>.</p>
</td></tr>
<tr><td><code id="tslphom_+3A_...">...</code></td>
<td>
<p>Other arguments to be passed to the function. Not currently used.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Description of the <code>new_and_exit_voters</code> argument in more detail.
</p>

<ul>
<li> <p><code>raw</code>: The default value. This argument accounts for the most plausible scenario when
estimating vote transfer matrices. A scenario with two elections elapsed at least
some months where only the raw election data recorded in the I (territorial) units,
in which the electoral space under study is divided, are available.
In this scenario, net exits and net entries are estimated according to
equation (7) of Romero et al. (2020). When both net entries and exits are no
null, constraint (15) of Pavia (2023) applies. If there are net exits and <code>uniform = TRUE</code>
either constraints (6) or (8) and (15) of Pavia (2023) are imposed. In this scenario,
J could be equal to J1 or J1 + 1 and K equal to K2 or K2 + 1.
</p>
</li>
<li> <p><code>regular</code>: This value accounts for a scenario with
two elections elapsed at least some months where (i) the column J1
of <code>votes_election1</code> corresponds to new young electors who have the right
to vote for the first time, (ii) net exits and maybe other additional
net entries are computed according to equation (7) of Romero et al. (2020), and
(iii) we can (or not) assume that net exits impact equally all the first J1 - 1
options of election 1. When both net entries and exits are no null, constraints
(13) and (15) of Pavia (2023) apply. If <code>uniform = TRUE</code> and there are net exits either
constraints (8) or (11) of Pavia (2023), depending on whether there are or not net
entries, are also imposed. In this scenario, J could be equal to J1 or J1 + 1 and
K equal to K2 or K2 + 1. Note that this scenario could be also used if
column J1 of <code>votes_election1</code> would correspond to immigrants instead of
new young electors.
</p>
</li>
<li> <p><code>ordinary</code>: This value accounts for a scenario
with two elections elapsed at least some months where (i) the column K1
of <code>votes_election2</code> corresponds to electors who died in the period between
elections, (ii) net entries and maybe other additional net exits are
computed according to equation (7) of Romero et al. (2020), and (iii) we can
assume (or not) that exits impact equally all the J1 options of election 1.
When both net entries and exits are no null, constraints (14) and
(15) of Pavia (2023) apply and if <code>uniform = TRUE</code> either constraints
(8) and (9) or, without net entries, (6) and (7) of Pavia (2023) are also imposed.
In this scenario, J could be equal to J1 or J1 + 1 and K equal to K2 or K2 + 1.
Note that this scenario could be also used if column K1 of
<code>votes_election2</code> would correspond to emigrants instead of deaths.
</p>
</li>
<li> <p><code>enriched</code>: This value accounts for a scenario that somehow combine <code>regular</code> and
<code>ordinary</code> scenarios. We consider two elections elapsed at least some months where
(i) the column J1 of <code>votes_election1</code> corresponds to new young electors
who have the right to vote for the first time, (ii) the column K2 of
<code>votes_election2</code> corresponds to electors who died in the interperiod
election, (iii) other (net) entries and (net) exits are computed according
to equation (7) of Romero et al. (2020), and (iv) we can assume
(or not) that exits impact equally all the J1 - 1 options of election 1.
When both net entries and exits are no null, constraints (12) to
(15) of Pavia (2023) apply and if <code>uniform = TRUE</code> constraints
(10) and (11) of Pavia (2023) are also imposed. In this scenario, J could be equal
to J1 or J1 + 1 and K equal to K2 or K2 + 1. Note that this scenario could be also used if
the column J1 of <code>votes_election1</code> would correspond to immigrants instead of
new young electors and/or if column K1 of <code>votes_election2</code> would correspond
to emigrants instead of deaths.
</p>
</li>
<li> <p><code>adjust1</code>: This value accounts for a scenario
with two elections elapsed at least some months where the census in
each of the I polling units of the first election (the row-sums of <code>votes_election1</code>) are
proportionally adjusted to match the corresponding census of the polling units in the
second election (the row-sums of <code>votes_election2</code>).
If <code>integers = TRUE</code>, each row in <code>votes_election1</code> is proportionally adjusted to the closest integer
vector whose sum is equal to the sum of the corresponding row in <code>votes_election2</code>.
</p>
</li>
<li> <p><code>adjust2</code>: This value accounts for a scenario
with two elections elapsed at least some months where the census in
each of the I polling units of the second election (the row-sums of <code>votes_election2</code>)
are proportionally adjusted to match the corresponding census of the polling units
in the first election (the row-sums of <code>votes_election1</code>).
If <code>integers = TRUE</code>, each row in <code>votes_election2</code> is adjusted to the closest integer
vector whose sum is equal to the sum of the corresponding row in <code>votes_election1</code>.
</p>
</li>
<li> <p><code>simultaneous</code>: This is the value to be used in classical ecological inference problems,
such as in ecological studies of racial voting, and in scenarios with two simultaneous elections.
In this scenario, the sum by rows of <code>votes_election1</code> and <code>votes_election2</code> must coincide.
Constraints defined by equations (8) and (9) of Romero et al. (2020) are not included in
the model. In this case, the lphom function just implements the basic model defined,
for instance, by equations (1) to (5) of Pavia (2024).
</p>
</li>
<li> <p><code>semifull</code>: This value accounts for a scenario with two elections elapsed at least some
months, where: (i) the column J1 = J of <code>votes_election1</code> totals new
electors (young and immigrants) that have the right to vote for the first time and
(ii) the column K2 = K of <code>votes_election2</code> corresponds to total exits of the census
lists (due to death or emigration). In this scenario, the sum by rows of
<code>votes_election1</code> and <code>votes_election2</code> must agree and constraint (15)
of Pavia (2023) apply. Additionally, if <code>uniform = TRUE</code> constraints
(8) of Pavia (2023) are also imposed.
</p>
</li>
<li> <p><code>full</code>: This value accounts for a scenario with two elections elapsed at least some
months, where (i) the column J - 1 of <code>votes_election1</code> totals new young
electors that have the right to vote for the first time, (ii) the column J (=J1)
of <code>votes_election1</code> measures new immigrants that have the right to vote and
(iii) the column K (=K2) of <code>votes_election2</code> corresponds to total exits of the census
lists (due to death or emigration). In this scenario, the sum by rows of
<code>votes_election1</code> and <code>votes_election2</code> must agree and constraints (13)
and (15) of Pavia (2023) apply.  Additionally, if <code>uniform = TRUE</code> constraints
(11) of Pavia (2023) are also imposed.
</p>
</li>
<li> <p><code>fullreverse</code>: This value is somehow the mirror version of <code>full</code>.
It accounts for a scenario with two elections elapsed at least some
months, where (i) the column J1 = J of <code>votes_election1</code> totals new
electors (young and immigrants) that have the right to vote for the first time and
(ii) where total exits are separated out between exits due to emigration
(column K - 1 of <code>votes_election2</code>) and death (column K of <code>votes_election2</code>).
In this scenario, the sum by rows of <code>votes_election1</code> and <code>votes_election2</code> must
agree and constraints (14) and (15) of Pavia (2023) apply.
Additionally, if <code>uniform = TRUE</code> constraints (8) and (9) of Pavia (2023) are also imposed.
</p>
</li>
<li> <p><code>gold</code>: This value accounts for a scenario similar to <code>full</code>, where total exits are
separated out between exits due to emigration (column K - 1 of <code>votes_election2</code>)
and death (column K of <code>votes_election2</code>). In this scenario, the sum by rows
of <code>votes_election1</code> and <code>votes_election2</code> must agree. Constraints (12) to
(15) of Pavia (2023) apply and if <code>uniform = TRUE</code> constraints (10) and (11)
of Pavia (2023) are also imposed.
</p>
</li></ul>



<h3>Value</h3>

<p>A list with the following components
</p>
<table>
<tr><td><code>VTM</code></td>
<td>
<p> A matrix of order J'xK' (where J'=J-1 or J and K'=K-1 or K) with the estimated percentages of row-standardized vote transitions from election 1 to election 2.
In <code>raw</code>, <code>regular</code>, <code>ordinary</code> and <code>enriched</code> scenarios when the percentage of net entries is small, less than 1% of the census in all units,
net entries are omitted (i.e., the number of rows of <code>VTM</code> is equal to J1) even when estimates for net entries different from zero are obtained. Likewise, in the same scenarios when the percentage of net exits is small, less than 1%
of the census in all units, net exits are omitted (i.e., the number of rows of <code>VTM</code> is equal to K2) even when estimates for net exits different from zero are obtained.</p>
</td></tr>
<tr><td><code>VTM.votes</code></td>
<td>
<p> A matrix of order J'xK' (where J'=J-1 or J and K'=K-1 or K) with the estimated vote transitions from election 1 to election 2.
In <code>raw</code>, <code>regular</code>, <code>ordinary</code> and <code>enriched</code> scenarios when the percentage of net entries is small, less than 1% of the census,
net entries are omitted (i.e., J = J1) even when estimates for net entries different from zero are obtained. Likewise, in the same scenarios when the percentage of net exits is small, less than 1%
of the census, net exits are omitted (i.e., K = K2) even when estimates for net exits different from zero are obtained.</p>
</td></tr>
<tr><td><code>OTM</code></td>
<td>
<p> A matrix of order KxJ with the estimated percentages of the origin of the votes obtained for the different options of election 2.</p>
</td></tr>
<tr><td><code>HETe</code></td>
<td>
<p> The estimated heterogeneity index as defined in equation (15) of Pavia and Romero (2022).</p>
</td></tr>
<tr><td><code>VTM.complete</code></td>
<td>
<p> A matrix of order JxK with the estimated proportions of row-standardized vote transitions from election 1 to election 2, including in <code>raw</code>, <code>regular</code>, <code>ordinary</code> and <code>enriched</code> scenarios the row and the column corresponding to net_entries and net_exits even when they are really small, less than 1% in all units.</p>
</td></tr>
<tr><td><code>VTM.complete.votes</code></td>
<td>
<p> A matrix of order JxK with the estimated vote transitions from election 1 to election 2, including in <code>raw</code>, <code>regular</code>, <code>ordinary</code> and <code>enriched</code> scenarios the row and the column corresponding to net_entries and net_exits even when they are really small, less than 1% in all units.</p>
</td></tr>
<tr><td><code>VTM.prop.units</code></td>
<td>
<p> An array of order JxKxI with the estimated proportions of vote transitions from election 1 to election 2 attained for each unit after adjusting the <strong>lphom()</strong> initial estimate.</p>
</td></tr>
<tr><td><code>VTM.votes.units</code></td>
<td>
<p> An array of order JxKxI with the estimated matrix of vote transitions from election 1 to election 2 attained for each unit after adjusting the <strong>lphom()</strong> initial estimate.</p>
</td></tr>
<tr><td><code>zeros</code></td>
<td>
<p> A list of vectors of length two, indicating the election options for which no transfer of votes are allowed between election 1 and election 2.</p>
</td></tr>
<tr><td><code>deterministic.bounds</code></td>
<td>
<p> A list of two matrices of order JxK and two arrays of order JxKxI containing for each vote transition the lower and upper allowed proportions given the observed aggregates.</p>
</td></tr>
<tr><td><code>inputs</code></td>
<td>
<p> A list containing all the objects with the values used as arguments by the function.</p>
</td></tr>
<tr><td><code>origin</code></td>
<td>
<p> A matrix with the final data used as votes of the origin election after taking into account the level of information available regarding to new entries and exits of the election censuses between the two elections.</p>
</td></tr>
<tr><td><code>destination</code></td>
<td>
<p> A matrix with the final data used as votes of the origin election after taking into account the level of information available regarding to new entries and exits of the election censuses between the two elections.</p>
</td></tr>
<tr><td><code>EHet</code></td>
<td>
<p> A matrix of order IxK measuring in each spatial unit a distance to the homogeneity hypothesis, that is, the differences under the homogeneity hypothesis between the actual recorded results and the expected results with the solution in each territorial unit for each option of election 2.</p>
</td></tr>
<tr><td><code>solution_init</code></td>
<td>
<p> A list with the main outputs produced by <strong>lphom()</strong>.</p>
</td></tr>
</table>

<ul>
<li> <p><code>VTM_init</code>: A matrix of order J'xK' with the estimated percentages of vote transitions from election 1 to election 2 initially obtained by <strong>lphom()</strong>.
</p>
</li>
<li> <p><code>VTM.votes_init</code>: A matrix of order J'xK' with the estimated vote transitions from election 1 to election 2 initially obtained by <strong>lphom()</strong>.
</p>
</li>
<li> <p><code>OTM_init</code>: A matrix of order KxJ with the estimated percentages of the origin of the votes obtained for the different options of election 2 initially obtained by <strong>lphom()</strong>.
</p>
</li>
<li> <p><code>HETe_init</code>: The estimated heterogeneity index defined in equation (10) of Romero et al. (2020).
</p>
</li>
<li> <p><code>EHet_init</code>: A matrix of order IxK measuring in each spatial unit the distance to the homogeneity hypothesis, that is, the differences under the homogeneity hypothesis between the actual recorded results and the expected results, using the <strong>lphom()</strong> solution, in each territorial unit for each option of election 2.
</p>
</li>
<li> <p><code>VTM.complete_init</code>:  matrix of order JxK with the estimated proportions of vote transitions from election 1 to election 2 initially obtained by <strong>lphom()</strong>, including in <code>raw</code>, <code>regular</code>, <code>ordinary</code> and <code>enriched</code> scenarios the row and the column corresponding to net_entries and net_exits even when they are really small, less than 1% in all units.
</p>
</li>
<li> <p><code>VTM.complete.votes_init</code>: A matrix of order JxK with the estimated vote transitions from election 1 to election 2 initially obtained by <strong>lphom()</strong>, including in <code>raw</code>, <code>regular</code>, <code>ordinary</code> and <code>enriched</code> scenarios the row and the column corresponding to net_entries and net_exits even when they are really small, less than 1% in all units.
</p>
</li></ul>



<h3>Author(s)</h3>

<p>Jose M. Pavia, <a href="mailto:pavia@uv.es">pavia@uv.es</a>
</p>
<p>Rafael Romero <a href="mailto:rromero@eio.upv.es">rromero@eio.upv.es</a>
</p>


<h3>References</h3>

<p>Pavia, JM, and Romero, R (2022). Improving estimates accuracy of voter transitions. Two new algorithms for ecological inference based on linear programming, <em>Sociological Methods &amp; Research</em>. <a href="https://doi.org/10.1177/00491241221092725">doi:10.1177/00491241221092725</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+lphom">lphom</a></code> <code><a href="#topic+nslphom">nslphom</a></code> <code><a href="#topic+lclphom">lclphom</a></code> <code><a href="#topic+rslphom">rslphom</a></code>
</p>
<p>Other linear programing ecological inference functions: 
<code><a href="#topic+lclphom">lclphom</a>()</code>,
<code><a href="#topic+lp_apriori">lp_apriori</a>()</code>,
<code><a href="#topic+lphom_dual">lphom_dual</a>()</code>,
<code><a href="#topic+lphom_joint">lphom_joint</a>()</code>,
<code><a href="#topic+lphom">lphom</a>()</code>,
<code><a href="#topic+nslphom_dual">nslphom_dual</a>()</code>,
<code><a href="#topic+nslphom_joint">nslphom_joint</a>()</code>,
<code><a href="#topic+nslphom">nslphom</a>()</code>,
<code><a href="#topic+rslphom">rslphom</a>()</code>,
<code><a href="#topic+tslphom_dual">tslphom_dual</a>()</code>,
<code><a href="#topic+tslphom_joint">tslphom_joint</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>mt.ts &lt;- tslphom(France2017P[, 1:8] , France2017P[, 9:12], new_and_exit_voters= "raw")
mt.ts$VTM
mt.ts$HETe
mt.ts$solution_init$HETe_init

</code></pre>

<hr>
<h2 id='tslphom_dual'>Implements the tslphom_dual algorithm</h2><span id='topic+tslphom_dual'></span>

<h3>Description</h3>

<p>Estimates RxC vote transfer matrices (ecological contingency tables) with tslphom_dual
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tslphom_dual(
  votes_election1,
  votes_election2,
  integers = FALSE,
  solver = "lp_solve",
  integers.solver = "symphony",
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tslphom_dual_+3A_votes_election1">votes_election1</code></td>
<td>
<p>data.frame (or matrix) of order IxJ with the counts to be initially
mapped to rows. When estimating vote transfer matrices, the votes gained by
the <em>J</em> political options competing on election 1 (or origin) in the <em>I</em>
territorial units considered.  The sum by rows of <code>votes_election1</code> and
<code>votes_election2</code> must coincide.</p>
</td></tr>
<tr><td><code id="tslphom_dual_+3A_votes_election2">votes_election2</code></td>
<td>
<p>data.frame (or matrix) of order IxK with the counts to be initially mapped
to columns. When estimating vote transfer matrices, the votes gained by
the <em>K</em> political options competing on election 2 (or destination) in the <em>I</em>
territorial units considered. The sum by rows of <code>votes_election1</code> and
<code>votes_election2</code> must coincide.</p>
</td></tr>
<tr><td><code id="tslphom_dual_+3A_integers">integers</code></td>
<td>
<p>A <code>TRUE/FALSE</code> value that indicates whether the problem is solved in integer values
in both iterations: zero (lphom) and final (including unit) solutions. If <code>TRUE</code>, the LP matrices
are approximated to the closest integer solution solving the corresponding Integer Linear Program.
Default, <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="tslphom_dual_+3A_solver">solver</code></td>
<td>
<p>A character string indicating the linear programming solver to be used, only
<code>lp_solve</code> and <code>symphony</code> are allowed. By default, <code>lp_solve</code>. The package <code>Rsymphony</code>
needs to be installed for the option <code>symphony</code> to be used.</p>
</td></tr>
<tr><td><code id="tslphom_dual_+3A_integers.solver">integers.solver</code></td>
<td>
<p>A character string indicating the linear programming solver to be used to approximate
to the closest integer solution, only <code>symphony</code> and <code>lp_solve</code> are allowed.
By default, <code>symphony</code>. The package <code>Rsymphony</code> needs to be installed for the option <code>symphony</code>
to be used. Only used when <code>integers = TRUE</code>.</p>
</td></tr>
<tr><td><code id="tslphom_dual_+3A_...">...</code></td>
<td>
<p>Other arguments to be passed to the function. Not currently used.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with the following components
</p>
<table>
<tr><td><code>VTM.votes.w</code></td>
<td>
<p> The matrix of order JxK with the estimated cross-distribution of votes of elections 1 and 2,
attained weighting the two dual solutions using as weights the corresponding HTEe estimates.</p>
</td></tr>
<tr><td><code>VTM.votes.units.w</code></td>
<td>
<p> The array of order JxKxI with the local estimated cross-distributions of votes of elections 1 and 2 by unit,
attained weighting the two dual solutions using as weights the corresponding HTEe estimates.</p>
</td></tr>
<tr><td><code>VTM.votes.a</code></td>
<td>
<p> The matrix of order JxK with the estimated cross-distribution of votes of elections 1 and 2,
attained simple averaging the two dual solutions.</p>
</td></tr>
<tr><td><code>VTM.votes.units.a</code></td>
<td>
<p> The matrix of order JxKxI with the estimated cross-distributions of votes of elections 1 and 2 by unit,
attained weighting the two dual solutions using as weights the corresponding HTEe estimates.</p>
</td></tr>
<tr><td><code>HETe.w</code></td>
<td>
<p> Estimated heterogeneity index associated to the <code>VTM.votes.w</code> solution.</p>
</td></tr>
<tr><td><code>HETe.a</code></td>
<td>
<p> Estimated heterogeneity index associated to the <code>VTM.votes.a</code> solution.</p>
</td></tr>
<tr><td><code>VTM12.w</code></td>
<td>
<p> The matrix of order JxK with the estimated row-standardized proportions of vote transitions from election 1
to election 2 associated to the <code>VTM.votes.w</code> solution.</p>
</td></tr>
<tr><td><code>VTM21.w</code></td>
<td>
<p> The matrix of order KxJ with the estimated row-standardized proportions of vote transitions from election 2
to election 1 associated to the <code>VTM.votes.w</code> solution.</p>
</td></tr>
<tr><td><code>VTM12.a</code></td>
<td>
<p> The matrix of order JxK with the estimated row-standardized proportions of vote transitions from election 1
to election 2 associated to the <code>VTM.votes.a</code> solution.</p>
</td></tr>
<tr><td><code>VTM21.a</code></td>
<td>
<p> The matrix of order KxJ with the estimated row-standardized proportions of vote transitions from election 2
to election 1 associated to the <code>VTM.votes.a</code> solution.</p>
</td></tr>
<tr><td><code>tslphom.object.12</code></td>
<td>
<p> The output of the <code><a href="#topic+tslphom">tslphom</a></code> function attained solving the problem X &ndash;&gt; Y,
that is, mapping <code>votes_election1</code> to rows and <code>votes_election2</code> to columns.</p>
</td></tr>
<tr><td><code>tslphom.object.21</code></td>
<td>
<p> The output of the <code><a href="#topic+tslphom">tslphom</a></code> function attained solving the problem Y &ndash;&gt; X,
that is, mapping <code>votes_election2</code> to rows and <code>votes_election1</code> to columns.</p>
</td></tr>
<tr><td><code>inputs</code></td>
<td>
<p> A list containing all the objects with the values used as arguments by the function.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Jose M. Pavia, <a href="mailto:pavia@uv.es">pavia@uv.es</a>
</p>
<p>Rafael Romero <a href="mailto:rromero@eio.upv.es">rromero@eio.upv.es</a>
</p>


<h3>References</h3>

<p>Pavia, JM and Romero, R (2024). Symmetry estimating RxC vote transfer matrices from aggregate data. <em>Journal of the Royal Statistical Society, Series A – Statistics in Society</em>, forthcoming.  <a href="https://doi.org/10.1093/jrsssa/qnae013">doi:10.1093/jrsssa/qnae013</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+tslphom">tslphom</a></code> <code><a href="#topic+lphom_dual">lphom_dual</a></code> <code><a href="#topic+nslphom_dual">nslphom_dual</a></code> <code><a href="#topic+lphom_joint">lphom_joint</a></code> <code><a href="#topic+tslphom_joint">tslphom_joint</a></code> <code><a href="#topic+nslphom_joint">nslphom_joint</a></code>
</p>
<p>Other linear programing ecological inference functions: 
<code><a href="#topic+lclphom">lclphom</a>()</code>,
<code><a href="#topic+lp_apriori">lp_apriori</a>()</code>,
<code><a href="#topic+lphom_dual">lphom_dual</a>()</code>,
<code><a href="#topic+lphom_joint">lphom_joint</a>()</code>,
<code><a href="#topic+lphom">lphom</a>()</code>,
<code><a href="#topic+nslphom_dual">nslphom_dual</a>()</code>,
<code><a href="#topic+nslphom_joint">nslphom_joint</a>()</code>,
<code><a href="#topic+nslphom">nslphom</a>()</code>,
<code><a href="#topic+rslphom">rslphom</a>()</code>,
<code><a href="#topic+tslphom_joint">tslphom_joint</a>()</code>,
<code><a href="#topic+tslphom">tslphom</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- France2017P[, 1:8]
y &lt;- France2017P[, 9:12]
y[,1] &lt;- y[,1]  - (rowSums(y) - rowSums(x))
mt &lt;- tslphom_dual(x, y)
mt$VTM.votes.w
mt$HETe.w

</code></pre>

<hr>
<h2 id='tslphom_joint'>Implements the tslphom_joint algorithm</h2><span id='topic+tslphom_joint'></span>

<h3>Description</h3>

<p>Estimates RxC vote transfer matrices (ecological contingency tables) with tslphom_joint
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tslphom_joint(
  votes_election1,
  votes_election2,
  integers = FALSE,
  solver = "lp_solve",
  integers.solver = "symphony",
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tslphom_joint_+3A_votes_election1">votes_election1</code></td>
<td>
<p>data.frame (or matrix) of order IxJ with the counts to be initially
mapped to rows. When estimating vote transfer matrices, the votes gained by
the <em>J</em> political options competing on election 1 (or origin) in the <em>I</em>
territorial units considered.  The sum by rows of <code>votes_election1</code> and
<code>votes_election2</code> must coincide.</p>
</td></tr>
<tr><td><code id="tslphom_joint_+3A_votes_election2">votes_election2</code></td>
<td>
<p>data.frame (or matrix) of order IxK with the counts to be initially mapped
to columns. When estimating vote transfer matrices, the votes gained by
the <em>K</em> political options competing on election 2 (or destination) in the <em>I</em>
territorial units considered. The sum by rows of <code>votes_election1</code> and
<code>votes_election2</code> must coincide.</p>
</td></tr>
<tr><td><code id="tslphom_joint_+3A_integers">integers</code></td>
<td>
<p>A <code>TRUE/FALSE</code> value that indicates whether the problem is solved in integer values
in both iterations: zero (lphom) and final (including unit) solutions. If <code>TRUE</code>, the LP matrices
are approximated to the closest integer solution solving the corresponding Integer Linear Program.
Default, <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="tslphom_joint_+3A_solver">solver</code></td>
<td>
<p>A character string indicating the linear programming solver to be used, only
<code>lp_solve</code> and <code>symphony</code> are allowed. By default, <code>lp_solve</code>. The package <code>Rsymphony</code>
needs to be installed for the option <code>symphony</code> to be used.</p>
</td></tr>
<tr><td><code id="tslphom_joint_+3A_integers.solver">integers.solver</code></td>
<td>
<p>A character string indicating the linear programming solver to be used to approximate
to the closest integer solution, only <code>symphony</code> and <code>lp_solve</code> are allowed.
By default, <code>symphony</code>. The package <code>Rsymphony</code> needs to be installed for the option <code>symphony</code>
to be used. Only used when <code>integers = TRUE</code>.</p>
</td></tr>
<tr><td><code id="tslphom_joint_+3A_...">...</code></td>
<td>
<p>Other arguments to be passed to the function. Not currently used.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with the following components
</p>
<table>
<tr><td><code>VTM.votes</code></td>
<td>
<p> A matrix of order JxK with the estimated cross-distribution of votes of elections 1 and 2.</p>
</td></tr>
<tr><td><code>HETe</code></td>
<td>
<p> The estimated heterogeneity index associated to the <code>VTM.votes</code> solution.</p>
</td></tr>
<tr><td><code>VTM12</code></td>
<td>
<p> The matrix of order JxK with the estimated row-standardized proportions of vote transitions from election 1 to election 2 associated to the <code>VTM.votes</code> solution.</p>
</td></tr>
<tr><td><code>VTM21</code></td>
<td>
<p> The matrix of order KxJ with the estimated row-standardized proportions of vote transitions from election 2 to election 1 associated to the <code>VTM.votes</code> solution.</p>
</td></tr>
<tr><td><code>VTM.votes.units</code></td>
<td>
<p> An array of order JxKxI with the estimated matrix of cross-distributions of votes of elections 1 and 2 attained for each unit after congruently adjusting the <strong>lphom_joint()</strong> initial estimate.</p>
</td></tr>
<tr><td><code>EHet12</code></td>
<td>
<p> A matrix of order IxK measuring in each unit a distance to the homogeneity hypothesis. That is, the differences under the homogeneity hypothesis between the actual recorded results and the expected results in each territorial unit for each option of election two. The matrix Eik.</p>
</td></tr>
<tr><td><code>EHet21</code></td>
<td>
<p> A matrix of order IxJ measuring in each unit a distance to the homogeneity hypothesis. That is, the differences under the homogeneity hypothesis between the actual recorded results and the expected results in each territorial unit for each option of election one. The matrix Eij.</p>
</td></tr>
<tr><td><code>deterministic.bounds</code></td>
<td>
<p> A list of two matrices of order JxK and two arrays of order JxKxI containing for each vote transition the lower and upper allowed proportions given the observed aggregates.</p>
</td></tr>
<tr><td><code>inputs</code></td>
<td>
<p> A list containing all the objects with the values used as arguments by the function.</p>
</td></tr>
<tr><td><code>solution_init</code></td>
<td>
<p> A list with the main outputs produced by <strong>lphom_joint()</strong>.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Jose M. Pavia, <a href="mailto:pavia@uv.es">pavia@uv.es</a>
</p>
<p>Rafael Romero <a href="mailto:rromero@eio.upv.es">rromero@eio.upv.es</a>
</p>


<h3>References</h3>

<p>Pavia, JM and Romero, R (2024). Symmetry estimating RxC vote transfer matrices from aggregate data. <em>Journal of the Royal Statistical Society, Series A – Statistics in Society</em>, forthcoming.  <a href="https://doi.org/10.1093/jrsssa/qnae013">doi:10.1093/jrsssa/qnae013</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+tslphom">tslphom</a></code> <code><a href="#topic+lphom_dual">lphom_dual</a></code> <code><a href="#topic+tslphom_dual">tslphom_dual</a></code> <code><a href="#topic+nslphom_dual">nslphom_dual</a></code> <code><a href="#topic+lphom_joint">lphom_joint</a></code> <code><a href="#topic+nslphom_joint">nslphom_joint</a></code>
</p>
<p>Other linear programing ecological inference functions: 
<code><a href="#topic+lclphom">lclphom</a>()</code>,
<code><a href="#topic+lp_apriori">lp_apriori</a>()</code>,
<code><a href="#topic+lphom_dual">lphom_dual</a>()</code>,
<code><a href="#topic+lphom_joint">lphom_joint</a>()</code>,
<code><a href="#topic+lphom">lphom</a>()</code>,
<code><a href="#topic+nslphom_dual">nslphom_dual</a>()</code>,
<code><a href="#topic+nslphom_joint">nslphom_joint</a>()</code>,
<code><a href="#topic+nslphom">nslphom</a>()</code>,
<code><a href="#topic+rslphom">rslphom</a>()</code>,
<code><a href="#topic+tslphom_dual">tslphom_dual</a>()</code>,
<code><a href="#topic+tslphom">tslphom</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- France2017P[, 1:8]
y &lt;- France2017P[, 9:12]
y[,1] &lt;- y[,1]  - (rowSums(y) - rowSums(x))
mt &lt;- tslphom_joint(x, y)
mt$VTM.votes
mt$HETe
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
