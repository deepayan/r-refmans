<!DOCTYPE html><html><head><title>Help for package spsurvey</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {spsurvey}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#adjwgt'><p>Adjust survey design weights by categories</p></a></li>
<li><a href='#adjwgtNR'><p>Adjust survey design weights for non-response by categories</p></a></li>
<li><a href='#ash1_wgt'><p>Compute the average shifted histogram (ASH) for one-dimensional weighted data</p></a></li>
<li><a href='#attrisk_analysis'><p>Attributable risk analysis</p></a></li>
<li><a href='#cat_analysis'><p>Categorical variable analysis</p></a></li>
<li><a href='#cdf_plot'><p>Plot a cumulative distribution function (CDF)</p></a></li>
<li><a href='#change_analysis'><p>Change analysis</p></a></li>
<li><a href='#cont_analysis'><p>Continuous variable analysis</p></a></li>
<li><a href='#cont_cdfplot'><p>Create a PDF file containing cumulative distribution functions (CDF) plots</p></a></li>
<li><a href='#cont_cdftest'><p>Cumulative distribution function (CDF) inference for a probability survey</p></a></li>
<li><a href='#cov_panel_dsgn'><p>Create a covariance matrix for a panel design</p></a></li>
<li><a href='#diffrisk_analysis'><p>Risk difference analysis</p></a></li>
<li><a href='#errorprnt'><p>Print errors from analysis functions</p></a></li>
<li><a href='#grts'><p>Select a generalized random tessellation stratified (GRTS) sample</p></a></li>
<li><a href='#Illinois_River'><p>Illinois River data</p></a></li>
<li><a href='#Illinois_River_Legacy'><p>Illinois River legacy data</p></a></li>
<li><a href='#irs'><p>Select an independent random sample (IRS)</p></a></li>
<li><a href='#Lake_Ontario'><p>Lake Ontario data</p></a></li>
<li><a href='#localmean_cov'><p>Internal Function: Variance-Covariance Matrix Based on Local Mean Estimator</p></a></li>
<li><a href='#localmean_var'><p>Internal Function: Local Mean Variance Estimator</p></a></li>
<li><a href='#localmean_weight'><p>Internal Function: Local Mean Variance Neighbors and Weights</p></a></li>
<li><a href='#NE_Lakes'><p>New England Lakes data</p></a></li>
<li><a href='#NE_Lakes_df'><p>New England Lakes data (as a data frame)</p></a></li>
<li><a href='#NE_Lakes_Legacy'><p>New England Lakes legacy data</p></a></li>
<li><a href='#NLA_PNW'><p>NLA PNW data</p></a></li>
<li><a href='#NRSA_EPA7'><p>NRSA EPA7 data</p></a></li>
<li><a href='#pd_summary'><p>Summary characteristics of a panel revisit design</p></a></li>
<li><a href='#plot'><p>Plot sampling frames, design sites, and analysis data.</p></a></li>
<li><a href='#plot.sp_CDF'><p>Plot a cumulative distribution function (CDF)</p></a></li>
<li><a href='#power_dsgn'><p>Power calculation for multiple panel designs</p></a></li>
<li><a href='#ppd_plot'><p>Plot power curves for panel designs</p></a></li>
<li><a href='#relrisk_analysis'><p>Relative risk analysis</p></a></li>
<li><a href='#revisit_bibd'><p>Create a balanced incomplete block panel revisit design</p></a></li>
<li><a href='#revisit_dsgn'><p>Create a panel revisit design</p></a></li>
<li><a href='#revisit_rand'><p>Create a revisit design with random assignment to panels and time periods</p></a></li>
<li><a href='#sp_balance'><p>Calculate spatial balance metrics</p></a></li>
<li><a href='#sp_frame'><p><code>sp_frame</code> objects</p></a></li>
<li><a href='#sp_plot'><p>Plot sampling frames, design sites, and analysis data.</p></a></li>
<li><a href='#sp_rbind'><p>Combine rows from GRTS or IRS samples.</p></a></li>
<li><a href='#sp_summary'><p>Summarize sampling frames, design sites, and analysis data.</p></a></li>
<li><a href='#spsurvey-package'><p>spsurvey: Spatial Sampling Design and Analysis</p></a></li>
<li><a href='#stopprnt'><p>Print grts() and irs() errors.</p></a></li>
<li><a href='#summary'><p>Summarize sampling frames, design sites, and analysis data.</p></a></li>
<li><a href='#trend_analysis'><p>Trend analysis</p></a></li>
<li><a href='#warnprnt'><p>Print grts(), irs()), and analysis function warnings</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Title:</td>
<td>Spatial Sampling Design and Analysis</td>
</tr>
<tr>
<td>Version:</td>
<td>5.5.1</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Michael Dumelle &lt;Dumelle.Michael@epa.gov&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>A design-based approach to statistical inference, with a focus on spatial data. Spatially balanced samples are selected using the Generalized Random Tessellation Stratified (GRTS) algorithm. The GRTS algorithm can be applied to finite resources (point geometries) and infinite resources (linear / linestring and areal / polygon geometries) and flexibly accommodates a diverse set of sampling design features, including stratification, unequal inclusion probabilities, proportional (to size) inclusion probabilities, legacy (historical) sites, a minimum distance between sites, and two options for replacement sites (reverse hierarchical order and nearest neighbor). Data are analyzed using a wide range of analysis functions that perform categorical variable analysis, continuous variable analysis, attributable risk analysis, risk difference analysis, relative risk analysis, change analysis, and trend analysis. spsurvey can also be used to summarize objects, visualize objects, select samples that are not spatially balanced, select panel samples, measure the amount of spatial balance in a sample, adjust design weights, and more. For additional details, see Dumelle et al. (2023) &lt;<a href="https://doi.org/10.18637%2Fjss.v105.i03">doi:10.18637/jss.v105.i03</a>&gt;.</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.5.0), sf, survey (&ge; 4.1-1)</td>
</tr>
<tr>
<td>Imports:</td>
<td>boot, crossdes, deldir, graphics, grDevices, lme4, MASS,
sampling, stats, units</td>
</tr>
<tr>
<td>Suggests:</td>
<td>knitr, testthat, rmarkdown</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL (&ge; 3)</a></td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://usepa.github.io/spsurvey/">https://usepa.github.io/spsurvey/</a>,
<a href="https://github.com/USEPA/spsurvey">https://github.com/USEPA/spsurvey</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/USEPA/spsurvey/issues">https://github.com/USEPA/spsurvey/issues</a></td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-01-08 20:47:59 UTC; MDUMELLE</td>
</tr>
<tr>
<td>Author:</td>
<td>Michael Dumelle <a href="https://orcid.org/0000-0002-3393-5529"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cre],
  Tom Kincaid [aut],
  Tony Olsen [aut],
  Marc Weber [aut],
  Don Stevens [ctb],
  Denis White [ctb]</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-01-09 08:20:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='adjwgt'>Adjust survey design weights by categories</h2><span id='topic+adjwgt'></span>

<h3>Description</h3>

<p>Adjust initial survey design weights so that the
final weights sum to a desired frame size. Adjusted weights
proportionally scale the initial weights to sum to the desired frame size.
Separate adjustments are applied to each category specified in <code>wgtcat</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>adjwgt(wgt, wgtcat = NULL, framesize, sites = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="adjwgt_+3A_wgt">wgt</code></td>
<td>
<p>Vector of initial weights for each site. These equal
the reciprocal of the site's inclusion probability.</p>
</td></tr>
<tr><td><code id="adjwgt_+3A_wgtcat">wgtcat</code></td>
<td>
<p>Vector containing each site's weight adjustment
category name. The default is <code>NULL</code>, which assumes every
site is in the same category.</p>
</td></tr>
<tr><td><code id="adjwgt_+3A_framesize">framesize</code></td>
<td>
<p>Vector containing the known size of the frame
for each category name in <code>wgtcat</code>. If <code>wgtcat</code> is provided,
the names in <code>framesize</code> must match the names in <code>wgtcat</code>.
If <code>wgtcat</code> is not provided, an unnamed scalar is given to
<code>framesize</code>.</p>
</td></tr>
<tr><td><code id="adjwgt_+3A_sites">sites</code></td>
<td>
<p>Vector indicating site use; <code>TRUE</code> indicates the site
should be included in the weight adjustment and <code>FALSE</code> indicates
the site should not be included in the weight adjustment. The default is
<code>NULL</code>, which assumes every site should be included.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Vector of adjusted weights, where the adjusted weight is set
to <code>0</code> for sites whose value in the sites argument was set to
<code>FALSE</code>.
</p>


<h3>Author(s)</h3>

<p>Tony Olsen <a href="mailto:olsen.tony@epa.gov">olsen.tony@epa.gov</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>wgt &lt;- runif(50)
wgtcat &lt;- rep(c("A", "B"), c(30, 20))
framesize &lt;- c(A = 15, B = 10)
sites &lt;- rep(rep(c(TRUE, FALSE), c(9, 1)), 5)
adjwgt(wgt, wgtcat, framesize, sites)
</code></pre>

<hr>
<h2 id='adjwgtNR'>Adjust survey design weights for non-response by categories</h2><span id='topic+adjwgtNR'></span>

<h3>Description</h3>

<p>Adjust weights for target sample units that do not respond 
and are missing at random within categories. The missing at random
assumption implies that their sample weight may be assigned to
specific categories of units that have responded (i.e., have been
sampled). This is a class-based method for non-response adjustment.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>adjwgtNR(wgt, MARClass, EvalStatus, TNRClass, TRClass)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="adjwgtNR_+3A_wgt">wgt</code></td>
<td>
<p>vector of weights for each sample unit that will be adjusted
for non-response. Weights must be weights for the design as implemented.
All weights must be greater than zero.</p>
</td></tr>
<tr><td><code id="adjwgtNR_+3A_marclass">MARClass</code></td>
<td>
<p>vector that identifies for each sample unit the category
that will be used in non-response weight adjustment for sample units 
that are known to be target. Within each missing at random (MAR) 
category, the missing sample units that are not sampled are assumed to
be missing at random.</p>
</td></tr>
<tr><td><code id="adjwgtNR_+3A_evalstatus">EvalStatus</code></td>
<td>
<p>vector of the evaluation status for each sample unit.
Values must include the values given in TNRclass and TRClass. May 
include other values not required for the non-response adjustment.</p>
</td></tr>
<tr><td><code id="adjwgtNR_+3A_tnrclass">TNRClass</code></td>
<td>
<p>subset of values in EvalStatus that identify sample units
whose target status is known and that do not respond (i.e., are not 
sampled).</p>
</td></tr>
<tr><td><code id="adjwgtNR_+3A_trclass">TRClass</code></td>
<td>
<p>Subset of values in EvalStatus that identify sample units 
whose target status is known and that respond (i.e., are target and
sampled).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Vector of sample unit weights that are adjusted for non-response
and that is the same length of input weights. Weights for sample 
units that did not response but were known to be eligible are set
to zero. Weights for all other sample units are also set to zero.
</p>


<h3>Author(s)</h3>

<p>Tony Olsen <a href="mailto:olsen.tony@epa.gov">olsen.tony@epa.gov</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(5)
wgt &lt;- runif(40)
MARClass &lt;- rep(c("A", "B"), rep(20, 2))
EvalStatus &lt;- sample(c("Not_Target", "Target_Sampled", "Target_Not_Sampled"), 40, replace = TRUE)
TNRClass &lt;- "Target_Not_Sampled"
TRClass &lt;- "Target_Sampled"
adjwgtNR(wgt, MARClass, EvalStatus, TNRClass, TRClass)
# function that has an error check
</code></pre>

<hr>
<h2 id='ash1_wgt'>Compute the average shifted histogram (ASH) for one-dimensional weighted data</h2><span id='topic+ash1_wgt'></span>

<h3>Description</h3>

<p>Calculate the average shifted histogram estimate of a density based on one-dimensional data
from a survey design with weights.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ash1_wgt(
  x,
  wgt = rep(1, length(x)),
  m = 5,
  nbin = 50,
  ab = NULL,
  support = "Continuous"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ash1_wgt_+3A_x">x</code></td>
<td>
<p>Vector used to estimate the density. <code>NA</code> values are allowed.</p>
</td></tr>
<tr><td><code id="ash1_wgt_+3A_wgt">wgt</code></td>
<td>
<p>Vector of weights for each observation from a
probability sample. The default assigns equal weights (equal probability).</p>
</td></tr>
<tr><td><code id="ash1_wgt_+3A_m">m</code></td>
<td>
<p>Number of empty bins to add to the ends when the range is not
completely specified.  The default is <code>5</code>.</p>
</td></tr>
<tr><td><code id="ash1_wgt_+3A_nbin">nbin</code></td>
<td>
<p>Number of bins for density estimation.  The default is <code>50</code>.</p>
</td></tr>
<tr><td><code id="ash1_wgt_+3A_ab">ab</code></td>
<td>
<p>Optional range for support associated with the density. Both
values may be equal to <code>NA</code>.  If equal to <code>NA</code>, then corresponding limit will
be based on <code>nicerange()</code>. The default is <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="ash1_wgt_+3A_support">support</code></td>
<td>
<p>Type of support.  If equal to <code>"Continuous"</code>, then data are
from a continuous distribution.  If equal to <code>"Ordinal"</code>, then data are from
a discrete distribution defined for integers only.  The default is
<code>"Continuous"</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>List containing the ASH density estimate.  List consists of
</p>

<dl>
<dt><code>tcen</code></dt><dd><p> x-coordinate for center of bin</p>
</dd>
<dt><code>f</code></dt><dd><p> y-coordinate for density estimate height</p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>Tony Olsen <a href="mailto:Olsen.tony@epa.gov">Olsen.tony@epa.gov</a>
</p>


<h3>References</h3>

<p>Scott, D. W. (1985). &quot;Averaged shifted histograms: effective nonparametric
density estimators in several dimensions.&quot; <em>The Annals of Statistics</em> 13(3):
1024-1040.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- rnorm(100, 10, sqrt(10))
wgt &lt;- runif(100, 10, 100)
rslt &lt;- ash1_wgt(x, wgt)
plot(rslt)
</code></pre>

<hr>
<h2 id='attrisk_analysis'>Attributable risk analysis</h2><span id='topic+attrisk_analysis'></span>

<h3>Description</h3>

<p>This function organizes input and output for the analysis of attributable risk (for
categorical variables).  The analysis data,
<code>dframe</code>, can be either a data frame or a simple features (<code>sf</code>) object.  If an
<code>sf</code> object is used, coordinates are extracted from the geometry column in the
object, arguments <code>xcoord</code> and <code>ycoord</code> are assigned values
<code>"xcoord"</code> and <code>"ycoord"</code>, respectively, and the geometry column is
dropped from the object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>attrisk_analysis(
  dframe,
  vars_response,
  vars_stressor,
  response_levels = NULL,
  stressor_levels = NULL,
  subpops = NULL,
  siteID = NULL,
  weight = "weight",
  xcoord = NULL,
  ycoord = NULL,
  stratumID = NULL,
  clusterID = NULL,
  weight1 = NULL,
  xcoord1 = NULL,
  ycoord1 = NULL,
  sizeweight = FALSE,
  sweight = NULL,
  sweight1 = NULL,
  fpc = NULL,
  popsize = NULL,
  vartype = "Local",
  conf = 95,
  All_Sites = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="attrisk_analysis_+3A_dframe">dframe</code></td>
<td>
<p>Data to be analyzed (analysis data). A data frame or
<code>sf</code> object containing survey design
variables, response variables, stressor variables, and subpopulation
(domain) variables.</p>
</td></tr>
<tr><td><code id="attrisk_analysis_+3A_vars_response">vars_response</code></td>
<td>
<p>Vector composed of character values that identify the
names of response variables in <code>dframe</code>. Each response
variable must have two category values (levels), where one level is
associated with poor condition and the other level is associated with good
condition.</p>
</td></tr>
<tr><td><code id="attrisk_analysis_+3A_vars_stressor">vars_stressor</code></td>
<td>
<p>Vector composed of character values that identify the
names of stressor variables in <code>dframe</code>. Each stressor
variable must have two category values (levels), where one level is
associated with poor condition and the other level is associated with good
condition.</p>
</td></tr>
<tr><td><code id="attrisk_analysis_+3A_response_levels">response_levels</code></td>
<td>
<p>List providing the category values (levels) for each
element in the <code>vars_response</code> argument.  Each element in the list
must contain two values, where the first value identifies poor condition,
and the second value identifies good condition.  This argument must be
named and must be the same length as argument <code>vars_response</code>.  Names
for this argument must match the values in the <code>vars_response</code>
argument. If this argument equals NULL, then a named list is created that
contains the values <code>"Poor"</code> and <code>"Good"</code> for the first and
second levels, respectively, of each element in the <code>vars_response</code>
argument and that uses values in the <code>vars_response</code> argument as names
for the list.  If <code>response_levels</code> is provided without names,
then the names of <code>response_levels</code> are set to <code>vars_response</code>.
The default value is NULL.</p>
</td></tr>
<tr><td><code id="attrisk_analysis_+3A_stressor_levels">stressor_levels</code></td>
<td>
<p>List providing the category values (levels) for each
element in the <code>vars_stressor</code> argument.  Each element in the list
must contain two values, where the first value identifies poor condition,
and the second value identifies good condition.  This argument must be
named and must be the same length as argument <code>vars_stressor</code>.  Names
for this argument must match the values in the <code>vars_stressor</code>
argument. If this argument equals NULL, then a named list is created that
contains the values <code>"Poor"</code> and <code>"Good"</code> for the first and
second levels, respectively, of each element in the <code>vars_stressor</code>
argument and that uses values in the <code>vars_stressor</code> argument as names
for the list.  If <code>stressor_levels</code> is provided without names,
then the names of <code>stressor_levels</code> are set to <code>vars_stressor</code>. 
The default value is NULL.</p>
</td></tr>
<tr><td><code id="attrisk_analysis_+3A_subpops">subpops</code></td>
<td>
<p>Vector composed of character values that identify the
names of subpopulation (domain) variables in <code>dframe</code>.
If a value is not provided, the value <code>"All_Sites"</code> is assigned to the
subpops argument and a factor variable named <code>"All_Sites"</code> that takes
the value <code>"All Sites"</code> is added to <code>dframe</code>.  The
default value is <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="attrisk_analysis_+3A_siteid">siteID</code></td>
<td>
<p>Character value providing the name of the site ID variable in
<code>dframe</code>.  For a two-stage sample, the site ID variable
identifies stage two site IDs.  The default value is <code>NULL</code>, which
assumes that each row in <code>dframe</code> represents a unique site.</p>
</td></tr>
<tr><td><code id="attrisk_analysis_+3A_weight">weight</code></td>
<td>
<p>Character value providing the name of the design weight
variable in <code>dframe</code>.  For a two-stage sample, the
weight variable identifies stage two weights.  The default value is
<code>"weight"</code>.</p>
</td></tr>
<tr><td><code id="attrisk_analysis_+3A_xcoord">xcoord</code></td>
<td>
<p>Character value providing name of the x-coordinate variable in
<code>dframe</code>.  For a two-stage sample, the x-coordinate
variable identifies stage two x-coordinates.  Note that x-coordinates are
required for calculation of the local mean variance estimator.  If <code>dframe</code>
is an <code>sf</code> object, this argument is not required (as the geometry column
in <code>dframe</code> is used to find the x-coordinate). The default
value is <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="attrisk_analysis_+3A_ycoord">ycoord</code></td>
<td>
<p>Character value providing name of the y-coordinate variable in
<code>dframe</code>.  For a two-stage sample, the y-coordinate
variable identifies stage two y-coordinates.  Note that y-coordinates are
required for calculation of the local mean variance estimator.  If <code>dframe</code>
is an <code>sf</code> object, this argument is not required (as the geometry column
in <code>dframe</code> is used to find the t-coordinate). The default
value is <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="attrisk_analysis_+3A_stratumid">stratumID</code></td>
<td>
<p>Character value providing the name of the stratum ID
variable in <code>dframe</code>.  The default value is
<code>NULL</code>.</p>
</td></tr>
<tr><td><code id="attrisk_analysis_+3A_clusterid">clusterID</code></td>
<td>
<p>Character value providing the name of the cluster
(stage one) ID variable in <code>dframe</code>.  Note that cluster
IDs are required for a two-stage sample.  The default value is <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="attrisk_analysis_+3A_weight1">weight1</code></td>
<td>
<p>Character value providing the name of the stage one weight
variable in <code>dframe</code>.  The default value is
<code>NULL</code>.</p>
</td></tr>
<tr><td><code id="attrisk_analysis_+3A_xcoord1">xcoord1</code></td>
<td>
<p>Character value providing the name of the stage one
x-coordinate variable in <code>dframe</code>.  Note that x
coordinates are required for calculation of the local mean variance
estimator.  The default value is <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="attrisk_analysis_+3A_ycoord1">ycoord1</code></td>
<td>
<p>Character value providing the name of the stage one
y-coordinate variable in <code>dframe</code>.  Note that
y-coordinates are required for calculation of the local mean variance
estimator.  The default value is <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="attrisk_analysis_+3A_sizeweight">sizeweight</code></td>
<td>
<p>Logical value that indicates whether size weights should be
used during estimation, where <code>TRUE</code> uses size weights and
<code>FALSE</code> does not use size weights. To employ size weights for a
single-stage sample, a value must be supplied for argument weight.  To
employ size weights for a two-stage sample, values must be supplied for
arguments <code>weight</code> and <code>weight1</code>. The default value is
<code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="attrisk_analysis_+3A_sweight">sweight</code></td>
<td>
<p>Character value providing the name of the size weight variable
in <code>dframe</code>.  For a two-stage sample, the size weight
variable identifies stage two size weights.  The default value is
<code>NULL</code>.</p>
</td></tr>
<tr><td><code id="attrisk_analysis_+3A_sweight1">sweight1</code></td>
<td>
<p>Character value providing the name of the stage one size
weight variable in <code>dframe</code>.  The default value is
<code>NULL</code>.</p>
</td></tr>
<tr><td><code id="attrisk_analysis_+3A_fpc">fpc</code></td>
<td>
<p>Object that specifies values required for calculation of the
finite population correction factor used during variance estimation. The
object must match the survey design in terms of stratification and whether
the design is single-stage or two-stage.  For an unstratified design, the
object is a vector.  The vector is composed of a single numeric value for a
single-stage design.  For a two-stage unstratified design, the object is a
named vector containing one more than the number of clusters in the sample,
where the first item in the vector specifies the number of clusters in the
population and each subsequent item specifies the number of stage two units
for the cluster.  The name for the first item in the vector is arbitrary.
Subsequent names in the vector identify clusters and must match the cluster
IDs.  For a stratified design, the object is a named list of vectors, where
names must match the strata IDs.  For each stratum, the format of the
vector is identical to the format described for unstratified single-stage
and two-stage designs.  Note that the finite population correction factor
is not used with the local mean variance estimator.
</p>
<p>Example fpc for a single-stage unstratified survey design:
</p>
<p><code style="white-space: pre;">&#8288;fpc &lt;- 15000&#8288;</code>
</p>
<p>Example fpc for a single-stage stratified survey design:
</p>
<p><code style="white-space: pre;">&#8288;fpc &lt;- list(
    Stratum_1 = 9000,
    Stratum_2 = 6000)
   &#8288;</code>
</p>
<p>Example fpc for a two-stage unstratified survey design:
</p>
<p><code style="white-space: pre;">&#8288;fpc &lt;- c(
    Ncluster = 150,
    Cluster_1 = 150,
    Cluster_2 = 75,
    Cluster_3 = 75,
    Cluster_4 = 125,
    Cluster_5 = 75)
  &#8288;</code>
</p>
<p>Example fpc for a two-stage stratified survey design:
</p>
<p><code style="white-space: pre;">&#8288;fpc &lt;- list(
    Stratum_1 = c(
      Ncluster_1 = 100,
      Cluster_1 = 125,
      Cluster_2 = 100,
      Cluster_3 = 100,
      Cluster_4 = 125,
      Cluster_5 = 50),
    Stratum_2 = c(
      Ncluster_2 = 50,
      Cluster_1 = 75,
      Cluster_2 = 150,
      Cluster_3 = 75,
      Cluster_4 = 75,
      Cluster_5 = 125))
  &#8288;</code></p>
</td></tr>
<tr><td><code id="attrisk_analysis_+3A_popsize">popsize</code></td>
<td>
<p>Object that provides values for the population argument of the
<code>calibrate</code> or <code>postStratify</code> functions in the survey package. If
a value is provided for popsize, then either the <code>calibrate</code> or
<code>postStratify</code> function is used to modify the survey design object
that is required by functions in the survey package.  Whether to use the
<code>calibrate</code> or <code>postStratify</code> function is dictated by the format
of popsize, which is discussed below.  Post-stratification adjusts the
sampling and replicate weights so that the joint distribution of a set of
post-stratifying variables matches the known population joint distribution.
Calibration, generalized raking, or GREG estimators generalize
post-stratification and raking by calibrating a sample to the marginal
totals of variables in a linear regression model. For the <code>calibrate</code>
function, the object is a named list, where the names identify factor
variables in <code>dframe</code>.  Each element of the list is a
named vector containing the population total for each level of the
associated factor variable.  For the <code>postStratify</code> function, the
object is either a data frame, table, or xtabs object that provides the
population total for all combinations of selected factor variables in the
<code>dframe</code> data frame.  If a data frame is used for <code>popsize</code>, the
variable containing population totals must be the last variable in the data
frame.  If a table is used for <code>popsize</code>, the table must have named
<code>dimnames</code> where the names identify factor variables in the
<code>dframe</code> data frame.  If the popsize argument is equal to <code>NULL</code>,
then neither calibration nor post-stratification is performed.  The default
value is <code>NULL</code>.
</p>
<p>Example popsize for calibration:
</p>
<p><code style="white-space: pre;">&#8288;popsize &lt;- list(
    Ecoregion = c(
      East = 750,
      Central = 500,
      West = 250),
    Type = c(
      Streams = 1150,
      Rivers = 350))
  &#8288;</code>
</p>
<p>Example popsize for post-stratification using a data frame:
</p>
<p><code style="white-space: pre;">&#8288;popsize &lt;- data.frame(
    Ecoregion = rep(c("East", "Central", "West"),
      rep(2, 3)),
    Type = rep(c("Streams", "Rivers"), 3),
    Total = c(575, 175, 400, 100, 175, 75))
  &#8288;</code>
</p>
<p>Example popsize for post-stratification using a table:
</p>
<p><code style="white-space: pre;">&#8288;popsize &lt;- with(MySurveyFrame,
    table(Ecoregion, Type))&#8288;</code>
</p>
<p>Example popsize for post-stratification using an xtabs object:
</p>
<p><code style="white-space: pre;">&#8288;popsize &lt;- xtabs(~Ecoregion + Type,
    data = MySurveyFrame)&#8288;</code></p>
</td></tr>
<tr><td><code id="attrisk_analysis_+3A_vartype">vartype</code></td>
<td>
<p>Character value providing the choice of the variance
estimator, where <code>"Local"</code> indicates the local mean estimator and <code>"SRS"</code> indicates the
simple random sampling estimator.  The default value is <code>"Local"</code>.</p>
</td></tr>
<tr><td><code id="attrisk_analysis_+3A_conf">conf</code></td>
<td>
<p>Numeric value providing the Gaussian-based confidence level.  The default value
is <code>95</code>.</p>
</td></tr>
<tr><td><code id="attrisk_analysis_+3A_all_sites">All_Sites</code></td>
<td>
<p>A logical variable used when <code>subpops</code> is not
<code>NULL</code>. If <code>All_Sites</code> is <code>TRUE</code>, then alongside the
subpopulation output, output for all sites (ignoring subpopulations) is
returned for each variable in <code>vars</code>. If <code>All_Sites</code> is
<code>FALSE</code>, then alongside the subpopulation output, output for all sites
(ignoring subpopulations) is not returned for each variable in <code>vars</code>.
The default is <code>FALSE</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The analysis results. A data frame of population estimates for all combinations of
subpopulations, categories within each subpopulation, response variables,
and categories within each response variable.  Estimates are provided for
proportion and size of the population plus standard error, margin of
error, and confidence interval estimates. The data frame contains the following
variables:
</p>

<dl>
<dt>Type</dt><dd><p>subpopulation (domain) name</p>
</dd>
<dt>Subpopulation</dt><dd><p>subpopulation name within a domain</p>
</dd>
<dt>Response</dt><dd><p>response variable</p>
</dd>
<dt>Stressor</dt><dd><p>stressor variable</p>
</dd>
<dt>nResp</dt><dd><p>sample size</p>
</dd>
<dt>Estimate</dt><dd><p>attributable risk estimate</p>
</dd>
<dt>StdError_log</dt><dd><p>attributable risk standard error (on the log scale)</p>
</dd>
<dt>MarginofError_log</dt><dd><p>attributable risk margin of error (on the log scale)</p>
</dd>
<dt>LCBxxPct</dt><dd><p>xx% (default 95%) lower confidence bound</p>
</dd>
<dt>UCBxxPct</dt><dd><p>xx% (default 95%) upper confidence bound</p>
</dd>
<dt>WeightTotal</dt><dd><p>sum of design weights</p>
</dd>
<dt>Count_RespPoor_StressPoor</dt><dd><p>number of observations in the poor response and poor stressor group</p>
</dd>
<dt>Count_RespPoor_StressGood</dt><dd><p>number of observations in the poor response and good stressor group</p>
</dd>
<dt>Count_RespGood_StressPoor</dt><dd><p>number of observations in the good response and poor stressor group</p>
</dd>
<dt>Count_RespGood_StressGood</dt><dd><p>number of observations in the good response and good stressor group</p>
</dd>
<dt>Prop_RespPoor_StressPoor</dt><dd><p>weighted proportion of observations in the poor response and poor stressor group</p>
</dd>
<dt>Prop_RespPoor_StressGood</dt><dd><p>weighted proportion of observations in the poor response and good stressor group</p>
</dd>
<dt>Prop_RespGood_StressPoor</dt><dd><p>weighted proportion of observations in the good response and poor stressor group</p>
</dd>
<dt>Prop_RespGood_StressGood</dt><dd><p>weighted proportion of observations in the good response and good stressor group</p>
</dd>
</dl>



<h3>Details</h3>

<p>Attributable risk measures the proportional reduction in the extent of poor
condition of a response variable that presumably would result from
eliminating a stressor variable, where the response and stressor variables
are classified as either good (i.e., reference condition) or poor (i.e.,
different from reference condition).  Attributable risk is defined as one
minus the ratio of two probabilities.  The numerator of the ratio is the
conditional probability that the response variable is in poor condition given
that the stressor variable is in good condition.   The denominator of the
ratio is the probability that the response variable is in poor condition.
Attributable risk values close to zero indicate that removing the stressor
variable will have little or no impact on the probability that the response
variable is in poor condition.  Attributable risk values close to one
indicate that removing the stressor variable will result in extensive
reduction of the probability that the response variable is in poor condition.
</p>


<h3>Author(s)</h3>

<p>Tom Kincaid <a href="mailto:Kincaid.Tom@epa.gov">Kincaid.Tom@epa.gov</a>
</p>


<h3>References</h3>

<p>Sickle, J. V., &amp; Paulsen, S. G. (2008). Assessing the attributable risks,
relative risks, and regional extents of aquatic stressors.
<em>Journal of the North American Benthological Society</em>, 27(4), 920-931.
</p>


<h3>See Also</h3>


<dl>
<dt><code><a href="#topic+relrisk_analysis">relrisk_analysis</a></code></dt><dd><p> for relative risk analysis</p>
</dd>
<dt><code><a href="#topic+diffrisk_analysis">diffrisk_analysis</a></code></dt><dd><p> for risk difference analysis</p>
</dd>
</dl>



<h3>Examples</h3>

<pre><code class='language-R'>dframe &lt;- data.frame(
  siteID = paste0("Site", 1:100),
  wgt = runif(100, 10, 100),
  xcoord = runif(100),
  ycoord = runif(100),
  stratum = rep(c("Stratum1", "Stratum2"), 50),
  RespVar1 = sample(c("Poor", "Good"), 100, replace = TRUE),
  RespVar2 = sample(c("Poor", "Good"), 100, replace = TRUE),
  StressVar = sample(c("Poor", "Good"), 100, replace = TRUE),
  All_Sites = rep("All Sites", 100),
  Resource_Class = rep(c("Agr", "Forest"), c(55, 45))
)
myresponse &lt;- c("RespVar1", "RespVar2")
mystressor &lt;- c("StressVar")
mysubpops &lt;- c("All_Sites", "Resource_Class")
attrisk_analysis(dframe,
  vars_response = myresponse,
  vars_stressor = mystressor, subpops = mysubpops, siteID = "siteID",
  weight = "wgt", xcoord = "xcoord", ycoord = "ycoord",
  stratumID = "stratum"
)
</code></pre>

<hr>
<h2 id='cat_analysis'>Categorical variable analysis</h2><span id='topic+cat_analysis'></span>

<h3>Description</h3>

<p>This function organizes input and output for the analysis of categorical variables.  The analysis data,
<code>dframe</code>, can be either a data frame or a simple features (<code>sf</code>) object.  If an
<code>sf</code> object is used, coordinates are extracted from the geometry column in the
object, arguments <code>xcoord</code> and <code>ycoord</code> are assigned values
<code>"xcoord"</code> and <code>"ycoord"</code>, respectively, and the geometry column is
dropped from the object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cat_analysis(
  dframe,
  vars,
  subpops = NULL,
  siteID = NULL,
  weight = "weight",
  xcoord = NULL,
  ycoord = NULL,
  stratumID = NULL,
  clusterID = NULL,
  weight1 = NULL,
  xcoord1 = NULL,
  ycoord1 = NULL,
  sizeweight = FALSE,
  sweight = NULL,
  sweight1 = NULL,
  fpc = NULL,
  popsize = NULL,
  vartype = "Local",
  jointprob = "overton",
  conf = 95,
  All_Sites = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cat_analysis_+3A_dframe">dframe</code></td>
<td>
<p>Data to be analyzed (analysis data). A data frame or
<code>sf</code> object containing survey design
variables, response variables, and subpopulation (domain) variables.</p>
</td></tr>
<tr><td><code id="cat_analysis_+3A_vars">vars</code></td>
<td>
<p>Vector composed of character values that identify the
names of response variables in <code>dframe</code>.</p>
</td></tr>
<tr><td><code id="cat_analysis_+3A_subpops">subpops</code></td>
<td>
<p>Vector composed of character values that identify the
names of subpopulation (domain) variables in <code>dframe</code>.
If a value is not provided, the value <code>"All_Sites"</code> is assigned to the
subpops argument and a factor variable named <code>"All_Sites"</code> that takes
the value <code>"All Sites"</code> is added to the <code>dframe</code> data frame.  The
default value is <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="cat_analysis_+3A_siteid">siteID</code></td>
<td>
<p>Character value providing name of the site ID variable in
the <code>dframe</code> data frame.  For a two-stage sample, the site ID variable
identifies stage two site IDs.  The default value is <code>NULL</code>, which
assumes that each row in <code>dframe</code> represents a unique site.</p>
</td></tr>
<tr><td><code id="cat_analysis_+3A_weight">weight</code></td>
<td>
<p>Character value providing name of the design weight
variable in <code>dframe</code>.  For a two-stage sample, the
weight variable identifies stage two weights.  The default value is
<code>"weight"</code>.</p>
</td></tr>
<tr><td><code id="cat_analysis_+3A_xcoord">xcoord</code></td>
<td>
<p>Character value providing name of the x-coordinate variable in
the <code>dframe</code> data frame.  For a two-stage sample, the x-coordinate
variable identifies stage two x-coordinates.  Note that x-coordinates are
required for calculation of the local mean variance estimator.  If <code>dframe</code>
is an <code>sf</code> object, this argument is not required (as the geometry column
in <code>dframe</code> is used to find the x-coordinate). The default
value is <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="cat_analysis_+3A_ycoord">ycoord</code></td>
<td>
<p>Character value providing name of the y-coordinate variable in
the <code>dframe</code> data frame.  For a two-stage sample, the y-coordinate
variable identifies stage two y-coordinates.  Note that y-coordinates are
required for calculation of the local mean variance estimator.  If <code>dframe</code>
is an <code>sf</code> object, this argument is not required (as the geometry column
in <code>dframe</code> is used to find the y-coordinate). The default
value is <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="cat_analysis_+3A_stratumid">stratumID</code></td>
<td>
<p>Character value providing name of the stratum ID variable in
the <code>dframe</code> data frame.  The default value is <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="cat_analysis_+3A_clusterid">clusterID</code></td>
<td>
<p>Character value providing the name of the cluster
(stage one) ID variable in <code>dframe</code>.  Note that cluster
IDs are required for a two-stage sample.  The default value is <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="cat_analysis_+3A_weight1">weight1</code></td>
<td>
<p>Character value providing name of the stage one weight
variable in <code>dframe</code>.  The default value is <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="cat_analysis_+3A_xcoord1">xcoord1</code></td>
<td>
<p>Character value providing the name of the stage one
x-coordinate variable in <code>dframe</code>.  Note that x
coordinates are required for calculation of the local mean variance
estimator.  The default value is <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="cat_analysis_+3A_ycoord1">ycoord1</code></td>
<td>
<p>Character value providing the name of the stage one
y-coordinate variable in <code>dframe</code>.  Note that
y-coordinates are required for calculation of the local mean variance
estimator.  The default value is <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="cat_analysis_+3A_sizeweight">sizeweight</code></td>
<td>
<p>Logical value that indicates whether size weights should be
used during estimation, where <code>TRUE</code> uses size weights and
<code>FALSE</code> does not use size weights. To employ size weights for a
single-stage sample, a value must be supplied for argument weight.  To
employ size weights for a two-stage sample, values must be supplied for
arguments <code>weight</code> and <code>weight1</code>. The default value is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="cat_analysis_+3A_sweight">sweight</code></td>
<td>
<p>Character value providing the name of the size weight variable
in <code>dframe</code>.  For a two-stage sample, the size weight
variable identifies stage two size weights.  The default value is
<code>NULL</code>.</p>
</td></tr>
<tr><td><code id="cat_analysis_+3A_sweight1">sweight1</code></td>
<td>
<p>Character value providing name of the stage one size weight
variable in <code>dframe</code>.  The default value is <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="cat_analysis_+3A_fpc">fpc</code></td>
<td>
<p>Object that specifies values required for calculation of the
finite population correction factor used during variance estimation. The
object must match the survey design in terms of stratification and whether
the design is single-stage or two-stage.  For an unstratified design, the
object is a vector.  The vector is composed of a single numeric value for a
single-stage design.  For a two-stage unstratified design, the object is a
named vector containing one more than the number of clusters in the sample,
where the first item in the vector specifies the number of clusters in the
population and each subsequent item specifies the number of stage two units
for the cluster.  The name for the first item in the vector is arbitrary.
Subsequent names in the vector identify clusters and must match the cluster
IDs.  For a stratified design, the object is a named list of vectors, where
names must match the strata IDs.  For each stratum, the format of the
vector is identical to the format described for unstratified single-stage
and two-stage designs.  Note that the finite population correction factor
is not used with the local mean variance estimator.
</p>
<p>Example fpc for a single-stage unstratified survey design:
</p>
<p><code style="white-space: pre;">&#8288;fpc &lt;- 15000&#8288;</code>
</p>
<p>Example fpc for a single-stage stratified survey design:
</p>
<p><code style="white-space: pre;">&#8288;fpc &lt;- list(
    Stratum_1 = 9000,
    Stratum_2 = 6000)
   &#8288;</code>
</p>
<p>Example fpc for a two-stage unstratified survey design:
</p>
<p><code style="white-space: pre;">&#8288;fpc &lt;- c(
    Ncluster = 150,
    Cluster_1 = 150,
    Cluster_2 = 75,
    Cluster_3 = 75,
    Cluster_4 = 125,
    Cluster_5 = 75)
  &#8288;</code>
</p>
<p>Example fpc for a two-stage stratified survey design:
</p>
<p><code style="white-space: pre;">&#8288;fpc &lt;- list(
    Stratum_1 = c(
      Ncluster_1 = 100,
      Cluster_1 = 125,
      Cluster_2 = 100,
      Cluster_3 = 100,
      Cluster_4 = 125,
      Cluster_5 = 50),
    Stratum_2 = c(
      Ncluster_2 = 50,
      Cluster_1 = 75,
      Cluster_2 = 150,
      Cluster_3 = 75,
      Cluster_4 = 75,
      Cluster_5 = 125))
  &#8288;</code></p>
</td></tr>
<tr><td><code id="cat_analysis_+3A_popsize">popsize</code></td>
<td>
<p>Object that provides values for the population argument of the
<code>calibrate</code> or <code>postStratify</code> functions in the survey package. If
a value is provided for popsize, then either the <code>calibrate</code> or
<code>postStratify</code> function is used to modify the survey design object
that is required by functions in the survey package.  Whether to use the
<code>calibrate</code> or <code>postStratify</code> function is dictated by the format
of popsize, which is discussed below.  Post-stratification adjusts the
sampling and replicate weights so that the joint distribution of a set of
post-stratifying variables matches the known population joint distribution.
Calibration, generalized raking, or GREG estimators generalize
post-stratification and raking by calibrating a sample to the marginal
totals of variables in a linear regression model. For the <code>calibrate</code>
function, the object is a named list, where the names identify factor
variables in <code>dframe</code>.  Each element of the list is a
named vector containing the population total for each level of the
associated factor variable.  For the <code>postStratify</code> function, the
object is either a data frame, table, or xtabs object that provides the
population total for all combinations of selected factor variables in the
<code>dframe</code> data frame.  If a data frame is used for <code>popsize</code>, the
variable containing population totals must be the last variable in the data
frame.  If a table is used for <code>popsize</code>, the table must have named
<code>dimnames</code> where the names identify factor variables in the
<code>dframe</code> data frame.  If the popsize argument is equal to <code>NULL</code>,
then neither calibration nor post-stratification is performed.  The default
value is <code>NULL</code>.
</p>
<p>Example popsize for calibration:
</p>
<p><code style="white-space: pre;">&#8288;popsize &lt;- list(
    Ecoregion = c(
      East = 750,
      Central = 500,
      West = 250),
    Type = c(
      Streams = 1150,
      Rivers = 350))
  &#8288;</code>
</p>
<p>Example popsize for post-stratification using a data frame:
</p>
<p><code style="white-space: pre;">&#8288;popsize &lt;- data.frame(
    Ecoregion = rep(c("East", "Central", "West"),
      rep(2, 3)),
    Type = rep(c("Streams", "Rivers"), 3),
    Total = c(575, 175, 400, 100, 175, 75))
  &#8288;</code>
</p>
<p>Example popsize for post-stratification using a table:
</p>
<p><code style="white-space: pre;">&#8288;popsize &lt;- with(MySurveyFrame,
    table(Ecoregion, Type))&#8288;</code>
</p>
<p>Example popsize for post-stratification using an xtabs object:
</p>
<p><code style="white-space: pre;">&#8288;popsize &lt;- xtabs(~Ecoregion + Type,
    data = MySurveyFrame)&#8288;</code></p>
</td></tr>
<tr><td><code id="cat_analysis_+3A_vartype">vartype</code></td>
<td>
<p>Character value providing the choice of the variance
estimator, where <code>"Local"</code> indicates the local mean estimator,
<code>"SRS"</code> indicates the simple random sampling estimator, <code>"HT"</code>
indicates the Horvitz-Thompson estimator, and <code>"YG"</code> indicates the
Yates-Grundy estimator.  The default value is <code>"Local"</code>.</p>
</td></tr>
<tr><td><code id="cat_analysis_+3A_jointprob">jointprob</code></td>
<td>
<p>Character value providing the choice of joint inclusion
probability approximation for use with Horvitz-Thompson and Yates-Grundy
variance estimators, where <code>"overton"</code> indicates the Overton
approximation, <code>"hr"</code> indicates the Hartley-Rao approximation, and
<code>"brewer"</code> equals the Brewer approximation.  The default value is
<code>"overton"</code>.</p>
</td></tr>
<tr><td><code id="cat_analysis_+3A_conf">conf</code></td>
<td>
<p>Numeric value providing the Gaussian-based confidence level.  The default value
is <code>95</code>.</p>
</td></tr>
<tr><td><code id="cat_analysis_+3A_all_sites">All_Sites</code></td>
<td>
<p>A logical variable used when <code>subpops</code> is not
<code>NULL</code>. If <code>All_Sites</code> is <code>TRUE</code>, then alongside the
subpopulation output, output for all sites (ignoring subpopulations) is
returned for each variable in <code>vars</code>. If <code>All_Sites</code> is
<code>FALSE</code>, then alongside the subpopulation output, output for all sites
(ignoring subpopulations) is not returned for each variable in <code>vars</code>.
The default is <code>FALSE</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The analysis results. A data frame of population estimates for all combinations of
subpopulations, categories within each subpopulation, response variables,
and categories within each response variable.  Estimates are provided for
proportion and total of the population plus standard error, margin of
error, and confidence interval estimates. The data frame contains the following
variables:
</p>

<dl>
<dt>Type</dt><dd><p>subpopulation (domain) name</p>
</dd>
<dt>Subpopulation</dt><dd><p>subpopulation name within a domain</p>
</dd>
<dt>Indicator</dt><dd><p>response variable</p>
</dd>
<dt>Category</dt><dd><p>category of response variable</p>
</dd>
<dt>nResp</dt><dd><p>sample size</p>
</dd>
<dt>Estimate.P</dt><dd><p>proportion estimate (in %)</p>
</dd>
<dt>StdError.P</dt><dd><p>standard error of proportion estimate</p>
</dd>
<dt>MarginofError.P</dt><dd><p>margin of error of proportion estimate</p>
</dd>
<dt>LCBxxPct.P</dt><dd><p>xx% (default 95%) lower confidence bound of proportion estimate</p>
</dd>
<dt>UCBxxPct.P</dt><dd><p>xx% (default 95%) upper confidence bound of proportion estimate</p>
</dd>
<dt>Estimate.U</dt><dd><p>total estimate</p>
</dd>
<dt>StdError.U</dt><dd><p>standard error of total estimate</p>
</dd>
<dt>MarginofError.U</dt><dd><p>margin of error of total estimate</p>
</dd>
<dt>LCBxxPct.U</dt><dd><p>xx% (default 95%) lower confidence bound of total estimate</p>
</dd>
<dt>UCBxxPct.U</dt><dd><p>xx% (default 95%) upper confidence bound of total estimate</p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>Tom Kincaid <a href="mailto:Kincaid.Tom@epa.gov">Kincaid.Tom@epa.gov</a>
</p>


<h3>See Also</h3>


<dl>
<dt><code><a href="#topic+cont_analysis">cont_analysis</a></code></dt><dd><p> for continuous variable analysis</p>
</dd>
</dl>



<h3>Examples</h3>

<pre><code class='language-R'>dframe &lt;- data.frame(
  siteID = paste0("Site", 1:100),
  wgt = runif(100, 10, 100),
  xcoord = runif(100),
  ycoord = runif(100),
  stratum = rep(c("Stratum1", "Stratum2"), 50),
  CatVar = rep(c("north", "south", "east", "west"), 25),
  All_Sites = rep("All Sites", 100),
  Resource_Class = rep(c("Good", "Poor"), c(55, 45))
)
myvars &lt;- c("CatVar")
mysubpops &lt;- c("All_Sites", "Resource_Class")
mypopsize &lt;- data.frame(
  Resource_Class = c("Good", "Poor"),
  Total = c(4000, 1500)
)
cat_analysis(dframe,
  vars = myvars, subpops = mysubpops, siteID = "siteID",
  weight = "wgt", xcoord = "xcoord", ycoord = "ycoord",
  stratumID = "stratum", popsize = mypopsize
)
</code></pre>

<hr>
<h2 id='cdf_plot'>Plot a cumulative distribution function (CDF)</h2><span id='topic+cdf_plot'></span>

<h3>Description</h3>

<p>This function creates a CDF plot.  Input data for the plots is provided by a
data frame with the same structure as the &quot;CDF&quot; output from  <code>cont_analysis</code>.
Confidence limits for the CDF also are plotted.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cdf_plot(
  cdfest,
  var = NULL,
  subpop = NULL,
  subpop_level = NULL,
  units_cdf = "Percent",
  type_cdf = "Continuous",
  log = "",
  xlab = NULL,
  ylab = NULL,
  ylab_r = NULL,
  main = NULL,
  legloc = NULL,
  confcut = 0,
  conflev = 95,
  cex.main = 1.2,
  cex.legend = 1,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cdf_plot_+3A_cdfest">cdfest</code></td>
<td>
<p>Data frame with the same structure as the &quot;CDF&quot; output from
<code>cont_analysis</code>.</p>
</td></tr>
<tr><td><code id="cdf_plot_+3A_var">var</code></td>
<td>
<p>If <code>cdfest</code> has multiple variables in the &quot;Indicator&quot; column,
then <code>var</code> is the single variable to be plotted. The default is
<code>NULL</code>, which assumes that only one variable is in the &quot;Indicator&quot;
column of <code>cdfest</code>.</p>
</td></tr>
<tr><td><code id="cdf_plot_+3A_subpop">subpop</code></td>
<td>
<p>If <code>cdfest</code> has multiple variables in the &quot;Type&quot; column,
then <code>subpop</code> is the single variable to be plotted. The default is
<code>NULL</code>, which assumes that only one variable is in the &quot;Type&quot;
column of <code>cdfest</code>.</p>
</td></tr>
<tr><td><code id="cdf_plot_+3A_subpop_level">subpop_level</code></td>
<td>
<p>If <code>cdfest</code> has multiple levels of <code>subpop</code>
in the &quot;Subpopulation&quot; column,
then <code>subpop_level</code> is the single level to be plotted. The default is
<code>NULL</code>, which assumes that only one level is in the &quot;Subpopulation&quot;
column of <code>cdfest</code>.</p>
</td></tr>
<tr><td><code id="cdf_plot_+3A_units_cdf">units_cdf</code></td>
<td>
<p>Indicator for the label utilized for the left side y-axis
and the values used for the left side y-axis tick marks, where &quot;Percent&quot;
means the label and values are in terms of percent of the population, and
&quot;Units&quot; means the label and values are in terms of units (count, length,
or area) of the population.  The default is &quot;Percent&quot;.</p>
</td></tr>
<tr><td><code id="cdf_plot_+3A_type_cdf">type_cdf</code></td>
<td>
<p>Character string consisting of the value &quot;Continuous&quot; or
&quot;Ordinal&quot; that controls the type of CDF plot.  The default is &quot;Continuous&quot;.</p>
</td></tr>
<tr><td><code id="cdf_plot_+3A_log">log</code></td>
<td>
<p>Character string consisting of the value &quot;&quot; or &quot;x&quot; that
controls whether the x axis uses the original scale (&quot;&quot;) or the base 10
logarithmic scale (&quot;x&quot;).  The default is &quot;&quot;.</p>
</td></tr>
<tr><td><code id="cdf_plot_+3A_xlab">xlab</code></td>
<td>
<p>Character string providing the x-axis label.  If this argument
equals NULL, then the indicator name is used as the label.  The default is
NULL.</p>
</td></tr>
<tr><td><code id="cdf_plot_+3A_ylab">ylab</code></td>
<td>
<p>Character string providing the left side y-axis label.  If
argument units_cdf equals &quot;Units&quot;, a value should be provided for this
argument.  Otherwise, the label will be &quot;Percent&quot;.  The default is
&quot;Percent&quot;.</p>
</td></tr>
<tr><td><code id="cdf_plot_+3A_ylab_r">ylab_r</code></td>
<td>
<p>Character string providing the label for the right side y-axis
(and, hence, determining the values used for the right side y-axis tick
marks), where NULL means a right side y-axis is not created.  If this
argument equals &quot;Same&quot;, the right side y-axis will have the same label and
tick mark values as the left side y-axis.  If this argument equals a
character string other than &quot;Same&quot;, the right side y-axis label will be the
value provided for argument ylab_r, and the right side y-axis tick mark
values will be determined by the choice not utilized for argument
units_cdf, which means that the default value of argument units_cdf (i.e.,
&quot;Percent&quot;) will result in the right side y-axis tick mark values being
expressed  in terms of units of the population (i.e., count, length, or
area).  The default is NULL.</p>
</td></tr>
<tr><td><code id="cdf_plot_+3A_main">main</code></td>
<td>
<p>Character string providing the plot title.  The default is
NULL.</p>
</td></tr>
<tr><td><code id="cdf_plot_+3A_legloc">legloc</code></td>
<td>
<p>Indicator for location of the plot legend, where &quot;BR&quot; means
bottom right, &quot;BL&quot; means bottom left, &quot;TR&quot; means top right, &quot;TL&quot; means
top left, and NULL means no legend.  The default is NULL.</p>
</td></tr>
<tr><td><code id="cdf_plot_+3A_confcut">confcut</code></td>
<td>
<p>Numeric value that controls plotting confidence limits at
the CDF extremes.  Confidence limits for CDF values (percent scale) less
than confcut or greater than 100 minus confcut are not plotted.  A value of
zero means confidence limits are plotted for the complete range of the CDF.
The default is 0.</p>
</td></tr>
<tr><td><code id="cdf_plot_+3A_conflev">conflev</code></td>
<td>
<p>Numeric value of the confidence level used for confidence
limits. The default is 95.</p>
</td></tr>
<tr><td><code id="cdf_plot_+3A_cex.main">cex.main</code></td>
<td>
<p>Expansion factor for the plot title.  The default is 1.2.</p>
</td></tr>
<tr><td><code id="cdf_plot_+3A_cex.legend">cex.legend</code></td>
<td>
<p>Expansion factor for the legend title. The default is 1.</p>
</td></tr>
<tr><td><code id="cdf_plot_+3A_...">...</code></td>
<td>
<p>Additional arguments passed to the <code>plot.default</code> function
(aside from those already used and <code>ylim</code>).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A plot of a variable's CDF estimates associated confidence limits.
</p>


<h3>Author(s)</h3>

<p>Tom Kincaid <a href="mailto:Kincaid.Tom@epa.gov">Kincaid.Tom@epa.gov</a>
</p>


<h3>See Also</h3>


<dl>
<dt><code><a href="#topic+cont_cdfplot">cont_cdfplot</a></code></dt><dd><p>for creating a PDF file containing CDF
plots</p>
</dd>
<dt><code><a href="#topic+cont_cdftest">cont_cdftest</a></code></dt><dd><p>for CDF hypothesis testing</p>
</dd>
</dl>



<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
dframe &lt;- data.frame(
  siteID = paste0("Site", 1:100),
  wgt = runif(100, 10, 100),
  xcoord = runif(100),
  ycoord = runif(100),
  stratum = rep(c("Stratum1", "Stratum2"), 50),
  ContVar = rnorm(100, 10, 1),
  All_Sites = rep("All Sites", 100),
  Resource_Class = rep(c("Good", "Poor"), c(55, 45))
)
myvars &lt;- c("ContVar")
mysubpops &lt;- c("All_Sites", "Resource_Class")
mypopsize &lt;- data.frame(
  Resource_Class = c("Good", "Poor"),
  Total = c(4000, 1500)
)
myanalysis &lt;- cont_analysis(dframe,
  vars = myvars, subpops = mysubpops,
  siteID = "siteID", weight = "wgt", xcoord = "xcoord", ycoord = "ycoord",
  stratumID = "stratum", popsize = mypopsize
)
keep &lt;- with(myanalysis$CDF, Type == "Resource_Class" &amp;
  Subpopulation == "Good")
par(mfrow = c(2, 1))
cdf_plot(myanalysis$CDF[keep, ],
  xlab = "ContVar",
  ylab = "Percent of Stream Length", ylab_r = "Stream Length (km)",
  main = "Estimates for Resource Class: Good"
)
cdf_plot(myanalysis$CDF[keep, ],
  xlab = "ContVar",
  ylab = "Percent of Stream Length", ylab_r = "Same",
  main = "Estimates for Resource Class: Good"
)

## End(Not run)
</code></pre>

<hr>
<h2 id='change_analysis'>Change analysis</h2><span id='topic+change_analysis'></span>

<h3>Description</h3>

<p>This function organizes input and output for the estimation of change between two
samples (for categorical and continuous variables).  The analysis data,
<code>dframe</code>, can be either a data frame or a simple features (<code>sf</code>) object.  If an
<code>sf</code> object is used, coordinates are extracted from the geometry column in the
object, arguments <code>xcoord</code> and <code>ycoord</code> are assigned values
<code>"xcoord"</code> and <code>"ycoord"</code>, respectively, and the geometry column is
dropped from the object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>change_analysis(
  dframe,
  vars_cat = NULL,
  vars_cont = NULL,
  test = "mean",
  subpops = NULL,
  surveyID = "surveyID",
  survey_names = NULL,
  siteID = "siteID",
  weight = "weight",
  revisitwgt = FALSE,
  xcoord = NULL,
  ycoord = NULL,
  stratumID = NULL,
  clusterID = NULL,
  weight1 = NULL,
  xcoord1 = NULL,
  ycoord1 = NULL,
  sizeweight = FALSE,
  sweight = NULL,
  sweight1 = NULL,
  fpc = NULL,
  popsize = NULL,
  vartype = "Local",
  jointprob = "overton",
  conf = 95,
  All_Sites = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="change_analysis_+3A_dframe">dframe</code></td>
<td>
<p>Data to be analyzed (analysis data). A data frame or
<code>sf</code> object containing survey design variables, response
variables, and subpopulation (domain) variables.</p>
</td></tr>
<tr><td><code id="change_analysis_+3A_vars_cat">vars_cat</code></td>
<td>
<p>Vector composed of character values that identify the
names of categorical response variables in <code>dframe</code>.  The
default is <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="change_analysis_+3A_vars_cont">vars_cont</code></td>
<td>
<p>Vector composed of character values that identify the
names of continuous response variables in <code>dframe</code>.  The
default is <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="change_analysis_+3A_test">test</code></td>
<td>
<p>Character string or character vector providing the location
measure(s) to use for change estimation for continuous variables.  The
choices are <code>"mean"</code>, <code>"total"</code>, <code>"median"</code>, or some
combination of the three options (e.g., <code>c("mean", "total")</code>).
The default is <code>"mean"</code>.</p>
</td></tr>
<tr><td><code id="change_analysis_+3A_subpops">subpops</code></td>
<td>
<p>Vector composed of character values that identify the
names of subpopulation (domain) variables in <code>dframe</code>.
If a value is not provided, the value <code>"All_Sites"</code> is assigned to the
subpops argument and a factor variable named <code>"All_Sites"</code> that takes
the value <code>"All Sites"</code> is added to <code>dframe</code>.  The
default value is <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="change_analysis_+3A_surveyid">surveyID</code></td>
<td>
<p>Character value providing name of the survey ID variable in
<code>dframe</code>.  The default value is <code>"surveyID"</code>.</p>
</td></tr>
<tr><td><code id="change_analysis_+3A_survey_names">survey_names</code></td>
<td>
<p>Character vector of length two that provides the survey
names contained in the <code>surveyID</code> variable in the <code>dframe</code> data
frame.  The two values in the vector identify the first survey and second
survey, respectively.  If a value is not provided, unique values of the
<code>surveyID</code> variable are assigned to the <code>survey_names</code> argument.
The default is <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="change_analysis_+3A_siteid">siteID</code></td>
<td>
<p>Character value providing name of the site ID variable in
<code>dframe</code>.  For a two-stage sample, the site ID variable
identifies stage two site IDs.  The default value is <code>"siteID"</code>. If a
unique site is visited in both surveys, the corresponding <code>siteID</code>
should be the same for both entries.</p>
</td></tr>
<tr><td><code id="change_analysis_+3A_weight">weight</code></td>
<td>
<p>Character value providing name of the design weight
variable in <code>dframe</code>.  For a two-stage sample, the
weight variable identifies stage two weights.  The default value is
<code>"weight"</code>.</p>
</td></tr>
<tr><td><code id="change_analysis_+3A_revisitwgt">revisitwgt</code></td>
<td>
<p>Logical value that indicates whether each repeat visit
site has the same design weight in the two surveys, where
<code>TRUE</code> = the weight for each repeat visit site is the same and
<code>FALSE</code> = the weight for each repeat visit site is not the same.  When
this argument is <code>FALSE</code>, all of the repeat visit sites are assigned
equal weights when calculating the covariance component of the change
estimate standard error.  The default is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="change_analysis_+3A_xcoord">xcoord</code></td>
<td>
<p>Character value providing name of the x-coordinate variable in
<code>dframe</code>.  For a two-stage sample, the x-coordinate
variable identifies stage two x-coordinates.  Note that x-coordinates are
required for calculation of the local mean variance estimator.  If <code>dframe</code>
is an <code>sf</code> object, this argument is not required (as the geometry column
in <code>dframe</code> is used to find the x-coordinate). The default
value is <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="change_analysis_+3A_ycoord">ycoord</code></td>
<td>
<p>Character value providing name of the y-coordinate variable in
<code>dframe</code>.  For a two-stage sample, the y-coordinate
variable identifies stage two y-coordinates.  Note that y-coordinates are
required for calculation of the local mean variance estimator.  If <code>dframe</code>
is an <code>sf</code> object, this argument is not required (as the geometry column
in <code>dframe</code> is used to find the y-coordinate). The default
value is <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="change_analysis_+3A_stratumid">stratumID</code></td>
<td>
<p>Character value providing name of the stratum ID variable in
<code>dframe</code>.  The default value is <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="change_analysis_+3A_clusterid">clusterID</code></td>
<td>
<p>Character value providing the name of the cluster
(stage one) ID variable in <code>dframe</code>.  Note that cluster
IDs are required for a two-stage sample.  The default value is <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="change_analysis_+3A_weight1">weight1</code></td>
<td>
<p>Character value providing name of the stage one weight
variable in <code>dframe</code>.  The default value is <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="change_analysis_+3A_xcoord1">xcoord1</code></td>
<td>
<p>Character value providing the name of the stage one
x-coordinate variable in <code>dframe</code>.  Note that x
coordinates are required for calculation of the local mean variance
estimator.  The default value is <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="change_analysis_+3A_ycoord1">ycoord1</code></td>
<td>
<p>Character value providing the name of the stage one
y-coordinate variable in <code>dframe</code>.  Note that
y-coordinates are required for calculation of the local mean variance
estimator.  The default value is <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="change_analysis_+3A_sizeweight">sizeweight</code></td>
<td>
<p>Logical value that indicates whether size weights should be
used during estimation, where <code>TRUE</code> uses size weights and
<code>FALSE</code> does not use size weights. To employ size weights for a
single-stage sample, a value must be supplied for argument weight.  To
employ size weights for a two-stage sample, values must be supplied for
arguments <code>weight</code> and <code>weight1</code>. The default value is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="change_analysis_+3A_sweight">sweight</code></td>
<td>
<p>Character value providing the name of the size weight variable
in <code>dframe</code>.  For a two-stage sample, the size weight
variable identifies stage two size weights.  The default value is
<code>NULL</code>.</p>
</td></tr>
<tr><td><code id="change_analysis_+3A_sweight1">sweight1</code></td>
<td>
<p>Character value providing name of the stage one size weight
variable in <code>dframe</code>.  The default value is <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="change_analysis_+3A_fpc">fpc</code></td>
<td>
<p>Object that specifies values required for calculation of the
finite population correction factor used during variance estimation. The
object must match the survey design in terms of stratification and whether
the design is single-stage or two-stage.  For an unstratified design, the
object is a vector.  The vector is composed of a single numeric value for a
single-stage design.  For a two-stage unstratified design, the object is a
named vector containing one more than the number of clusters in the sample,
where the first item in the vector specifies the number of clusters in the
population and each subsequent item specifies the number of stage two units
for the cluster.  The name for the first item in the vector is arbitrary.
Subsequent names in the vector identify clusters and must match the cluster
IDs.  For a stratified design, the object is a named list of vectors, where
names must match the strata IDs.  For each stratum, the format of the
vector is identical to the format described for unstratified single-stage
and two-stage designs.  Note that the finite population correction factor
is not used with the local mean variance estimator.
</p>
<p>Example fpc for a single-stage unstratified survey design:
</p>
<p><code style="white-space: pre;">&#8288;fpc &lt;- 15000&#8288;</code>
</p>
<p>Example fpc for a single-stage stratified survey design:
</p>
<p><code style="white-space: pre;">&#8288;fpc &lt;- list(
    Stratum_1 = 9000,
    Stratum_2 = 6000)
   &#8288;</code>
</p>
<p>Example fpc for a two-stage unstratified survey design:
</p>
<p><code style="white-space: pre;">&#8288;fpc &lt;- c(
    Ncluster = 150,
    Cluster_1 = 150,
    Cluster_2 = 75,
    Cluster_3 = 75,
    Cluster_4 = 125,
    Cluster_5 = 75)
  &#8288;</code>
</p>
<p>Example fpc for a two-stage stratified survey design:
</p>
<p><code style="white-space: pre;">&#8288;fpc &lt;- list(
    Stratum_1 = c(
      Ncluster_1 = 100,
      Cluster_1 = 125,
      Cluster_2 = 100,
      Cluster_3 = 100,
      Cluster_4 = 125,
      Cluster_5 = 50),
    Stratum_2 = c(
      Ncluster_2 = 50,
      Cluster_1 = 75,
      Cluster_2 = 150,
      Cluster_3 = 75,
      Cluster_4 = 75,
      Cluster_5 = 125))
  &#8288;</code></p>
</td></tr>
<tr><td><code id="change_analysis_+3A_popsize">popsize</code></td>
<td>
<p>Object that provides values for the population argument of the
<code>calibrate</code> or <code>postStratify</code> functions in the survey package. If
a value is provided for popsize, then either the <code>calibrate</code> or
<code>postStratify</code> function is used to modify the survey design object
that is required by functions in the survey package.  Whether to use the
<code>calibrate</code> or <code>postStratify</code> function is dictated by the format
of popsize, which is discussed below.  Post-stratification adjusts the
sampling and replicate weights so that the joint distribution of a set of
post-stratifying variables matches the known population joint distribution.
Calibration, generalized raking, or GREG estimators generalize
post-stratification and raking by calibrating a sample to the marginal
totals of variables in a linear regression model. For the <code>calibrate</code>
function, the object is a named list, where the names identify factor
variables in <code>dframe</code>.  Each element of the list is a
named vector containing the population total for each level of the
associated factor variable.  For the <code>postStratify</code> function, the
object is either a data frame, table, or xtabs object that provides the
population total for all combinations of selected factor variables in the
<code>dframe</code> data frame.  If a data frame is used for <code>popsize</code>, the
variable containing population totals must be the last variable in the data
frame.  If a table is used for <code>popsize</code>, the table must have named
<code>dimnames</code> where the names identify factor variables in the
<code>dframe</code> data frame.  If the popsize argument is equal to <code>NULL</code>,
then neither calibration nor post-stratification is performed.  The default
value is <code>NULL</code>.
</p>
<p>Example popsize for calibration:
</p>
<p><code style="white-space: pre;">&#8288;popsize &lt;- list(
    Ecoregion = c(
      East = 750,
      Central = 500,
      West = 250),
    Type = c(
      Streams = 1150,
      Rivers = 350))
  &#8288;</code>
</p>
<p>Example popsize for post-stratification using a data frame:
</p>
<p><code style="white-space: pre;">&#8288;popsize &lt;- data.frame(
    Ecoregion = rep(c("East", "Central", "West"),
      rep(2, 3)),
    Type = rep(c("Streams", "Rivers"), 3),
    Total = c(575, 175, 400, 100, 175, 75))
  &#8288;</code>
</p>
<p>Example popsize for post-stratification using a table:
</p>
<p><code style="white-space: pre;">&#8288;popsize &lt;- with(MySurveyFrame,
    table(Ecoregion, Type))&#8288;</code>
</p>
<p>Example popsize for post-stratification using an xtabs object:
</p>
<p><code style="white-space: pre;">&#8288;popsize &lt;- xtabs(~Ecoregion + Type,
    data = MySurveyFrame)&#8288;</code></p>
</td></tr>
<tr><td><code id="change_analysis_+3A_vartype">vartype</code></td>
<td>
<p>Character value providing the choice of the variance
estimator, where <code>"Local"</code> indicates the local mean estimator and
<code>"SRS"</code> indicates the simple random sampling estimator.  The default
value is <code>"Local"</code>.</p>
</td></tr>
<tr><td><code id="change_analysis_+3A_jointprob">jointprob</code></td>
<td>
<p>Character value providing the choice of joint inclusion
probability approximation for use with Horvitz-Thompson and Yates-Grundy
variance estimators, where <code>"overton"</code> indicates the Overton
approximation, <code>"hr"</code> indicates the Hartley-Rao approximation, and
<code>"brewer"</code> equals the Brewer approximation.  The default value is
<code>"overton"</code>.</p>
</td></tr>
<tr><td><code id="change_analysis_+3A_conf">conf</code></td>
<td>
<p>Numeric value providing the Gaussian-based confidence level.  The default value
is <code>95</code>.</p>
</td></tr>
<tr><td><code id="change_analysis_+3A_all_sites">All_Sites</code></td>
<td>
<p>A logical variable used when <code>subpops</code> is not
<code>NULL</code>. If <code>All_Sites</code> is <code>TRUE</code>, then alongside the
subpopulation output, output for all sites (ignoring subpopulations) is
returned for each variable in <code>vars</code>. If <code>All_Sites</code> is
<code>FALSE</code>, then alongside the subpopulation output, output for all sites
(ignoring subpopulations) is not returned for each variable in <code>vars</code>.
The default is <code>FALSE</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>List of change estimates composed of four items:
(1) <code>catsum</code> contains change estimates for categorical variables,
(2) <code>contsum_mean</code> contains estimates for continuous variables using
the mean, (3) <code>contsum_total</code> contains estimates for continuous
variables using the total, and (4) <code>contsum_median</code> contains estimates for continuous
variables using the median.  The items in the list will contain <code>NULL</code>
for estimates that were not calculated.  Each data frame includes estimates
for all combinations of population Types, subpopulations within types,
response variables, and categories within each response variable (for
categorical variables and continuous variables using the median).  Change
estimates are provided plus standard error estimates and confidence
interval estimates.
</p>
<p>The <code>catsum</code> data frame contains the following variables:
</p>

<dl>
<dt>Survey_1</dt><dd><p>first survey name</p>
</dd>
<dt>Survey_2</dt><dd><p>second survey name</p>
</dd>
<dt>Type</dt><dd><p>subpopulation (domain) name</p>
</dd>
<dt>Subpopulation</dt><dd><p>subpopulation name within a domain</p>
</dd>
<dt>Indicator</dt><dd><p>response variable</p>
</dd>
<dt>Category</dt><dd><p>category of response variable</p>
</dd>
<dt>DiffEst.P</dt><dd><p>proportion difference estimate (in %; second survey - first survey)</p>
</dd>
<dt>StdError.P</dt><dd><p>standard error of proportion difference estimate</p>
</dd>
<dt>MarginofError.P</dt><dd><p>margin of error of proportion difference estimate</p>
</dd>
<dt>LCBxxPct.P</dt><dd><p>xx% (default 95%) lower confidence bound of proportion difference estimate</p>
</dd>
<dt>UCBxxPct.P</dt><dd><p>xx% (default 95%) upper confidence bound of proportion difference estimate</p>
</dd>
<dt>Estimate.U</dt><dd><p>total difference estimate (second survey - first survey)</p>
</dd>
<dt>StdError.U</dt><dd><p>standard error of total difference estimate</p>
</dd>
<dt>MarginofError.U</dt><dd><p>margin of error of total difference estimate</p>
</dd>
<dt>LCBxxPct.U</dt><dd><p>xx% (default 95%) lower confidence bound of total difference estimate</p>
</dd>
<dt>UCBxxPct.U</dt><dd><p>xx% (default 95%) upper confidence bound of total difference estimate</p>
</dd>
<dt>nResp_1</dt><dd><p>sample size in the first survey</p>
</dd>
<dt>Estimate.P_1</dt><dd><p>proportion estimate (in %) from the first survey</p>
</dd>
<dt>StdError.P_1</dt><dd><p>standard error of proportion estimate from the first survey</p>
</dd>
<dt>MarginofError.P_1</dt><dd><p>margin of error of proportion estimate from the first survey</p>
</dd>
<dt>LCBxxPct.P_1</dt><dd><p>xx% (default 95%) lower confidence bound of proportion estimate from the first survey</p>
</dd>
<dt>UCBxxPct.P_1</dt><dd><p>xx% (default 95%) upper confidence bound of proportion estimate from the first survey</p>
</dd>
<dt>nResp_2</dt><dd><p>sample size in the second survey</p>
</dd>
<dt>Estimate.U_1</dt><dd><p>total estimate from the first survey</p>
</dd>
<dt>StdError.U_1</dt><dd><p>standard error of total estimate from the first survey</p>
</dd>
<dt>MarginofError.U_1</dt><dd><p>margin of error of total estimate from the first survey</p>
</dd>
<dt>LCBxxPct.U_1</dt><dd><p>xx% (default 95%) lower confidence bound of total estimate from the first survey</p>
</dd>
<dt>UCBxxPct.U_1</dt><dd><p>xx% (default 95%) upper confidence bound of total estimate from the first survey</p>
</dd>
<dt>Estimate.P_2</dt><dd><p>proportion estimate (in %) from the second survey</p>
</dd>
<dt>StdError.P_2</dt><dd><p>standard error of proportion estimate from the second survey</p>
</dd>
<dt>MarginofError.P_2</dt><dd><p>margin of error of proportion estimate from the second survey</p>
</dd>
<dt>LCBxxPct.P_2</dt><dd><p>xx% (default 95%) lower confidence bound of proportion estimate from the second survey</p>
</dd>
<dt>UCBxxPct.P_2</dt><dd><p>xx% (default 95%) upper confidence bound of proportion estimate from the second survey</p>
</dd>
<dt>Estimate.U_2</dt><dd><p>total estimate from the second survey</p>
</dd>
<dt>StdError.U_2</dt><dd><p>standard error of total estimate from the second survey</p>
</dd>
<dt>MarginofError.U_2</dt><dd><p>margin of error of total estimate from the second survey</p>
</dd>
<dt>LCBxxPct.U_2</dt><dd><p>xx% (default 95%) lower confidence bound of total estimate from the second survey</p>
</dd>
<dt>UCBxxPct.U_2</dt><dd><p>xx% (default 95%) upper confidence bound of total estimate from the second survey</p>
</dd>
</dl>

<p>The <code>contsum_mean</code> data frame contains the following variables:
</p>

<dl>
<dt>Survey_1</dt><dd><p>first survey name</p>
</dd>
<dt>Survey_2</dt><dd><p>second survey name</p>
</dd>
<dt>Type</dt><dd><p>subpopulation (domain) name</p>
</dd>
<dt>Subpopulation</dt><dd><p>subpopulation name within a domain</p>
</dd>
<dt>Indicator</dt><dd><p>response variable</p>
</dd>
<dt>Statistic</dt><dd><p>value of percentile</p>
</dd>
<dt>nResp</dt><dd><p>sample size at or below <code>Value</code></p>
</dd>
<dt>DiffEst</dt><dd><p>mean difference estimate</p>
</dd>
<dt>StdError</dt><dd><p>standard error of mean difference estimate</p>
</dd>
<dt>MarginofError</dt><dd><p>margin of error of mean difference estimate</p>
</dd>
<dt>LCBxxPct</dt><dd><p>xx% (default 95%) lower confidence bound of mean difference estimate</p>
</dd>
<dt>UCBxxPct</dt><dd><p>xx% (default 95%) upper confidence bound of mean difference estimate</p>
</dd>
<dt>nResp_1</dt><dd><p>sample size in the first survey</p>
</dd>
<dt>Estimate_1</dt><dd><p>mean estimate from the first survey</p>
</dd>
<dt>StdError_1</dt><dd><p>standard error of mean estimate from the first survey</p>
</dd>
<dt>MarginofError_1</dt><dd><p>margin of error of mean estimate from the first survey</p>
</dd>
<dt>LCBxxPct_1</dt><dd><p>xx% (default 95%) lower confidence bound of mean estimate from the first survey</p>
</dd>
<dt>UCBxxPct_1</dt><dd><p>xx% (default 95%) upper confidence bound of mean estimate from the first survey</p>
</dd>
<dt>nResp_2</dt><dd><p>sample size in the second survey</p>
</dd>
<dt>Estimate_2</dt><dd><p>mean estimate from the second survey</p>
</dd>
<dt>StdError_2</dt><dd><p>standard error of mean estimate from the second survey</p>
</dd>
<dt>MarginofError_2</dt><dd><p>margin of error of mean estimate from the second survey</p>
</dd>
<dt>LCBxxPct_2</dt><dd><p>xx% (default 95%) lower confidence bound of mean estimate from the second survey</p>
</dd>
<dt>UCBxxPct_2</dt><dd><p>xx% (default 95%) upper confidence bound of mean estimate from the second survey</p>
</dd>
</dl>

<p>The <code>contsum_total</code> data frame contains the following variables:
</p>

<dl>
<dt>Survey_1</dt><dd><p>first survey name</p>
</dd>
<dt>Survey_2</dt><dd><p>second survey name</p>
</dd>
<dt>Type</dt><dd><p>subpopulation (domain) name</p>
</dd>
<dt>Subpopulation</dt><dd><p>subpopulation name within a domain</p>
</dd>
<dt>Indicator</dt><dd><p>response variable</p>
</dd>
<dt>Statistic</dt><dd><p>value of percentile</p>
</dd>
<dt>nResp</dt><dd><p>sample size at or below <code>Value</code></p>
</dd>
<dt>DiffEst</dt><dd><p>total difference estimate</p>
</dd>
<dt>StdError</dt><dd><p>standard error of total difference estimate</p>
</dd>
<dt>MarginofError</dt><dd><p>margin of error of total difference estimate</p>
</dd>
<dt>LCBxxPct</dt><dd><p>xx% (default 95%) lower confidence bound of total difference estimate</p>
</dd>
<dt>UCBxxPct</dt><dd><p>xx% (default 95%) upper confidence bound of total difference estimate</p>
</dd>
<dt>nResp_1</dt><dd><p>sample size in the first survey</p>
</dd>
<dt>Estimate_1</dt><dd><p>total estimate from the first survey</p>
</dd>
<dt>StdError_1</dt><dd><p>standard error of total estimate from the first survey</p>
</dd>
<dt>MarginofError_1</dt><dd><p>margin of error of total estimate from the first survey</p>
</dd>
<dt>LCBxxPct_1</dt><dd><p>xx% (default 95%) lower confidence bound of total estimate from the first survey</p>
</dd>
<dt>UCBxxPct_1</dt><dd><p>xx% (default 95%) upper confidence bound of total estimate from the first survey</p>
</dd>
<dt>nResp_2</dt><dd><p>sample size in the second survey</p>
</dd>
<dt>Estimate_2</dt><dd><p>total estimate from the second survey</p>
</dd>
<dt>StdError_2</dt><dd><p>standard error of total estimate from the second survey</p>
</dd>
<dt>MarginofError_2</dt><dd><p>margin of error of total estimate from the second survey</p>
</dd>
<dt>LCBxxPct_2</dt><dd><p>xx% (default 95%) lower confidence bound of total estimate from the second survey</p>
</dd>
<dt>UCBxxPct_2</dt><dd><p>xx% (default 95%) upper confidence bound of total estimate from the second survey</p>
</dd>
</dl>

<p>The <code>contsum_median</code> data frame contains the following variables:
</p>

<dl>
<dt>Survey_1</dt><dd><p>first survey name</p>
</dd>
<dt>Survey_2</dt><dd><p>second survey name</p>
</dd>
<dt>Type</dt><dd><p>subpopulation (domain) name</p>
</dd>
<dt>Subpopulation</dt><dd><p>subpopulation name within a domain</p>
</dd>
<dt>Indicator</dt><dd><p>response variable</p>
</dd>
<dt>Category</dt><dd><p>category of response variable</p>
</dd>
<dt>DiffEst.P</dt><dd><p>proportion above or below median difference estimate (in %; second survey - first survey)</p>
</dd>
<dt>StdError.P</dt><dd><p>standard error of proportion above or below median difference estimate</p>
</dd>
<dt>MarginofError.P</dt><dd><p>margin of error of proportion above or below median difference estimate</p>
</dd>
<dt>LCBxxPct.P</dt><dd><p>xx% (default 95%) lower confidence bound of proportion above or below median difference estimate</p>
</dd>
<dt>UCBxxPct.P</dt><dd><p>xx% (default 95%) upper confidence bound of proportion above or below median difference estimate</p>
</dd>
<dt>Estimate.U</dt><dd><p>total above or below median difference estimate (second survey - first survey)</p>
</dd>
<dt>StdError.U</dt><dd><p>standard error of total above or below median difference estimate</p>
</dd>
<dt>MarginofError.U</dt><dd><p>margin of error of total above or below median difference estimate</p>
</dd>
<dt>LCBxxPct.U</dt><dd><p>xx% (default 95%) lower confidence bound of total above or below median difference estimate</p>
</dd>
<dt>UCBxxPct.U</dt><dd><p>xx% (default 95%) upper confidence bound of total above or below median difference estimate</p>
</dd>
<dt>nResp_1</dt><dd><p>sample size in the first survey</p>
</dd>
<dt>Estimate.P_1</dt><dd><p>proportion above or below median estimate (in %) from the first survey</p>
</dd>
<dt>StdError.P_1</dt><dd><p>standard error of proportion above or below median estimate from the first survey</p>
</dd>
<dt>MarginofError.P_1</dt><dd><p>margin of error of proportion above or below median estimate from the first survey</p>
</dd>
<dt>LCBxxPct.P_1</dt><dd><p>xx% (default 95%) lower confidence bound of proportion above or below median estimate from the first survey</p>
</dd>
<dt>UCBxxPct.P_1</dt><dd><p>xx% (default 95%) upper confidence bound of proportion above or below median estimate from the first survey</p>
</dd>
<dt>nResp_2</dt><dd><p>sample size in the second survey</p>
</dd>
<dt>Estimate.U_1</dt><dd><p>total above or below median estimate from the first survey</p>
</dd>
<dt>StdError.U_1</dt><dd><p>standard error of total above or below median estimate from the first survey</p>
</dd>
<dt>MarginofError.U_1</dt><dd><p>margin of error of total above or below median estimate from the first survey</p>
</dd>
<dt>LCBxxPct.U_1</dt><dd><p>xx% (default 95%) lower confidence bound of total above or below median estimate from the first survey</p>
</dd>
<dt>UCBxxPct.U_1</dt><dd><p>xx% (default 95%) upper confidence bound of total above or below median estimate from the first survey</p>
</dd>
<dt>Estimate.P_2</dt><dd><p>proportion above or below median estimate (in %) from the second survey</p>
</dd>
<dt>StdError.P_2</dt><dd><p>standard error of proportion above or below median estimate from the second survey</p>
</dd>
<dt>MarginofError.P_2</dt><dd><p>margin of error of proportion above or below median estimate from the second survey</p>
</dd>
<dt>LCBxxPct.P_2</dt><dd><p>xx% (default 95%) lower confidence bound of proportion above or below median estimate from the second survey</p>
</dd>
<dt>UCBxxPct.P_2</dt><dd><p>xx% (default 95%) upper confidence bound of proportion above or below median estimate from the second survey</p>
</dd>
<dt>Estimate.U_2</dt><dd><p>total above or below median estimate from the second survey</p>
</dd>
<dt>StdError.U_2</dt><dd><p>standard error of total above or below median estimate from the second survey</p>
</dd>
<dt>MarginofError.U_2</dt><dd><p>margin of error of total above or below median estimate from the second survey</p>
</dd>
<dt>LCBxxPct.U_2</dt><dd><p>xx% (default 95%) lower confidence bound of total above or below median estimate from the second survey</p>
</dd>
<dt>UCBxxPct.U_2</dt><dd><p>xx% (default 95%) upper confidence bound of total above or below median estimate from the second survey</p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>Tom Kincaid <a href="mailto:Kincaid.Tom@epa.gov">Kincaid.Tom@epa.gov</a>
</p>


<h3>See Also</h3>


<dl>
<dt><code><a href="#topic+trend_analysis">trend_analysis</a></code></dt><dd><p> for trend analysis</p>
</dd>
</dl>



<h3>Examples</h3>

<pre><code class='language-R'># Categorical variable example for three resource classes
dframe &lt;- data.frame(
  surveyID = rep(c("Survey 1", "Survey 2"), c(100, 100)),
  siteID = paste0("Site", 1:200),
  wgt = runif(200, 10, 100),
  xcoord = runif(200),
  ycoord = runif(200),
  stratum = rep(rep(c("Stratum 1", "Stratum 2"), c(2, 2)), 50),
  CatVar = rep(c("North", "South"), 100),
  All_Sites = rep("All Sites", 200),
  Resource_Class = sample(c("Good", "Fair", "Poor"), 200, replace = TRUE)
)
myvars &lt;- c("CatVar")
mysubpops &lt;- c("All_Sites", "Resource_Class")
change_analysis(dframe,
  vars_cat = myvars, subpops = mysubpops,
  surveyID = "surveyID", siteID = "siteID", weight = "wgt",
  xcoord = "xcoord", ycoord = "ycoord", stratumID = "stratum"
)
</code></pre>

<hr>
<h2 id='cont_analysis'>Continuous variable analysis</h2><span id='topic+cont_analysis'></span>

<h3>Description</h3>

<p>This function organizes input and output for the analysis of continuous
variables. The analysis data, <code>dframe</code>, can be either a data frame or a
simple features (<code>sf</code>) object.  If an <code>sf</code> object is used,
coordinates are extracted from the geometry column in the object, arguments
<code>xcoord</code> and <code>ycoord</code> are assigned values <code>"xcoord"</code> and
<code>"ycoord"</code>, respectively, and the geometry column is dropped from the
object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cont_analysis(
  dframe,
  vars,
  subpops = NULL,
  siteID = NULL,
  weight = "weight",
  xcoord = NULL,
  ycoord = NULL,
  stratumID = NULL,
  clusterID = NULL,
  weight1 = NULL,
  xcoord1 = NULL,
  ycoord1 = NULL,
  sizeweight = FALSE,
  sweight = NULL,
  sweight1 = NULL,
  fpc = NULL,
  popsize = NULL,
  vartype = "Local",
  jointprob = "overton",
  conf = 95,
  pctval = c(5, 10, 25, 50, 75, 90, 95),
  statistics = c("CDF", "Pct", "Mean", "Total"),
  All_Sites = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cont_analysis_+3A_dframe">dframe</code></td>
<td>
<p>Data to be analyzed (analysis data). A data frame or
<code>sf</code> object containing survey design
variables, response variables, and subpopulation (domain) variables.</p>
</td></tr>
<tr><td><code id="cont_analysis_+3A_vars">vars</code></td>
<td>
<p>Vector composed of character values that identify the
names of response variables in <code>dframe</code>.</p>
</td></tr>
<tr><td><code id="cont_analysis_+3A_subpops">subpops</code></td>
<td>
<p>Vector composed of character values that identify the
names of subpopulation (domain) variables in <code>dframe</code>.
If a value is not provided, the value <code>"All_Sites"</code> is assigned to the
subpops argument and a factor variable named <code>"All_Sites"</code> that takes
the value <code>"All Sites"</code> is added to the <code>dframe</code> data frame.  The
default value is <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="cont_analysis_+3A_siteid">siteID</code></td>
<td>
<p>Character value providing name of the site ID variable in
the <code>dframe</code> data frame.  For a two-stage sample, the site ID variable
identifies stage two site IDs.  The default value is <code>NULL</code>, which
assumes that each row in <code>dframe</code> represents a unique site.</p>
</td></tr>
<tr><td><code id="cont_analysis_+3A_weight">weight</code></td>
<td>
<p>Character value providing name of the design weight
variable in <code>dframe</code>.  For a two-stage sample, the
weight variable identifies stage two weights.  The default value is
<code>"weight"</code>.</p>
</td></tr>
<tr><td><code id="cont_analysis_+3A_xcoord">xcoord</code></td>
<td>
<p>Character value providing name of the x-coordinate variable in
the <code>dframe</code> data frame.  For a two-stage sample, the x-coordinate
variable identifies stage two x-coordinates.  Note that x-coordinates are
required for calculation of the local mean variance estimator.  If <code>dframe</code>
is an <code>sf</code> object, this argument is not required (as the geometry column
in <code>dframe</code> is used to find the x-coordinate). The default
value is <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="cont_analysis_+3A_ycoord">ycoord</code></td>
<td>
<p>Character value providing name of the y-coordinate variable in
the <code>dframe</code> data frame.  For a two-stage sample, the y-coordinate
variable identifies stage two y-coordinates.  Note that y-coordinates are
required for calculation of the local mean variance estimator.  If <code>dframe</code>
is an <code>sf</code> object, this argument is not required (as the geometry column
in <code>dframe</code> is used to find the y-coordinate). The default
value is <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="cont_analysis_+3A_stratumid">stratumID</code></td>
<td>
<p>Character value providing name of the stratum ID variable in
the <code>dframe</code> data frame.  The default value is <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="cont_analysis_+3A_clusterid">clusterID</code></td>
<td>
<p>Character value providing the name of the cluster
(stage one) ID variable in <code>dframe</code>.  Note that cluster
IDs are required for a two-stage sample.  The default value is <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="cont_analysis_+3A_weight1">weight1</code></td>
<td>
<p>Character value providing name of the stage one weight
variable in <code>dframe</code>.  The default value is <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="cont_analysis_+3A_xcoord1">xcoord1</code></td>
<td>
<p>Character value providing the name of the stage one
x-coordinate variable in <code>dframe</code>.  Note that x
coordinates are required for calculation of the local mean variance
estimator.  The default value is <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="cont_analysis_+3A_ycoord1">ycoord1</code></td>
<td>
<p>Character value providing the name of the stage one
y-coordinate variable in <code>dframe</code>.  Note that
y-coordinates are required for calculation of the local mean variance
estimator.  The default value is <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="cont_analysis_+3A_sizeweight">sizeweight</code></td>
<td>
<p>Logical value that indicates whether size weights should be
used during estimation, where <code>TRUE</code> uses size weights and
<code>FALSE</code> does not use size weights. To employ size weights for a
single-stage sample, a value must be supplied for argument weight.  To
employ size weights for a two-stage sample, values must be supplied for
arguments <code>weight</code> and <code>weight1</code>. The default value is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="cont_analysis_+3A_sweight">sweight</code></td>
<td>
<p>Character value providing the name of the size weight variable
in <code>dframe</code>.  For a two-stage sample, the size weight
variable identifies stage two size weights.  The default value is
<code>NULL</code>.</p>
</td></tr>
<tr><td><code id="cont_analysis_+3A_sweight1">sweight1</code></td>
<td>
<p>Character value providing name of the stage one size weight
variable in <code>dframe</code>.  The default value is <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="cont_analysis_+3A_fpc">fpc</code></td>
<td>
<p>Object that specifies values required for calculation of the
finite population correction factor used during variance estimation. The
object must match the survey design in terms of stratification and whether
the design is single-stage or two-stage.  For an unstratified design, the
object is a vector.  The vector is composed of a single numeric value for a
single-stage design.  For a two-stage unstratified design, the object is a
named vector containing one more than the number of clusters in the sample,
where the first item in the vector specifies the number of clusters in the
population and each subsequent item specifies the number of stage two units
for the cluster.  The name for the first item in the vector is arbitrary.
Subsequent names in the vector identify clusters and must match the cluster
IDs.  For a stratified design, the object is a named list of vectors, where
names must match the strata IDs.  For each stratum, the format of the
vector is identical to the format described for unstratified single-stage
and two-stage designs.  Note that the finite population correction factor
is not used with the local mean variance estimator.
</p>
<p>Example fpc for a single-stage unstratified survey design:
</p>
<p><code style="white-space: pre;">&#8288;fpc &lt;- 15000&#8288;</code>
</p>
<p>Example fpc for a single-stage stratified survey design:
</p>
<p><code style="white-space: pre;">&#8288;fpc &lt;- list(
    Stratum_1 = 9000,
    Stratum_2 = 6000)
   &#8288;</code>
</p>
<p>Example fpc for a two-stage unstratified survey design:
</p>
<p><code style="white-space: pre;">&#8288;fpc &lt;- c(
    Ncluster = 150,
    Cluster_1 = 150,
    Cluster_2 = 75,
    Cluster_3 = 75,
    Cluster_4 = 125,
    Cluster_5 = 75)
  &#8288;</code>
</p>
<p>Example fpc for a two-stage stratified survey design:
</p>
<p><code style="white-space: pre;">&#8288;fpc &lt;- list(
    Stratum_1 = c(
      Ncluster_1 = 100,
      Cluster_1 = 125,
      Cluster_2 = 100,
      Cluster_3 = 100,
      Cluster_4 = 125,
      Cluster_5 = 50),
    Stratum_2 = c(
      Ncluster_2 = 50,
      Cluster_1 = 75,
      Cluster_2 = 150,
      Cluster_3 = 75,
      Cluster_4 = 75,
      Cluster_5 = 125))
  &#8288;</code></p>
</td></tr>
<tr><td><code id="cont_analysis_+3A_popsize">popsize</code></td>
<td>
<p>Object that provides values for the population argument of the
<code>calibrate</code> or <code>postStratify</code> functions in the survey package. If
a value is provided for popsize, then either the <code>calibrate</code> or
<code>postStratify</code> function is used to modify the survey design object
that is required by functions in the survey package.  Whether to use the
<code>calibrate</code> or <code>postStratify</code> function is dictated by the format
of popsize, which is discussed below.  Post-stratification adjusts the
sampling and replicate weights so that the joint distribution of a set of
post-stratifying variables matches the known population joint distribution.
Calibration, generalized raking, or GREG estimators generalize
post-stratification and raking by calibrating a sample to the marginal
totals of variables in a linear regression model. For the <code>calibrate</code>
function, the object is a named list, where the names identify factor
variables in <code>dframe</code>.  Each element of the list is a
named vector containing the population total for each level of the
associated factor variable.  For the <code>postStratify</code> function, the
object is either a data frame, table, or xtabs object that provides the
population total for all combinations of selected factor variables in the
<code>dframe</code> data frame.  If a data frame is used for <code>popsize</code>, the
variable containing population totals must be the last variable in the data
frame.  If a table is used for <code>popsize</code>, the table must have named
<code>dimnames</code> where the names identify factor variables in the
<code>dframe</code> data frame.  If the popsize argument is equal to <code>NULL</code>,
then neither calibration nor post-stratification is performed.  The default
value is <code>NULL</code>.
</p>
<p>Example popsize for calibration:
</p>
<p><code style="white-space: pre;">&#8288;popsize &lt;- list(
    Ecoregion = c(
      East = 750,
      Central = 500,
      West = 250),
    Type = c(
      Streams = 1150,
      Rivers = 350))
  &#8288;</code>
</p>
<p>Example popsize for post-stratification using a data frame:
</p>
<p><code style="white-space: pre;">&#8288;popsize &lt;- data.frame(
    Ecoregion = rep(c("East", "Central", "West"),
      rep(2, 3)),
    Type = rep(c("Streams", "Rivers"), 3),
    Total = c(575, 175, 400, 100, 175, 75))
  &#8288;</code>
</p>
<p>Example popsize for post-stratification using a table:
</p>
<p><code style="white-space: pre;">&#8288;popsize &lt;- with(MySurveyFrame,
    table(Ecoregion, Type))&#8288;</code>
</p>
<p>Example popsize for post-stratification using an xtabs object:
</p>
<p><code style="white-space: pre;">&#8288;popsize &lt;- xtabs(~Ecoregion + Type,
    data = MySurveyFrame)&#8288;</code></p>
</td></tr>
<tr><td><code id="cont_analysis_+3A_vartype">vartype</code></td>
<td>
<p>Character value providing the choice of the variance
estimator, where <code>"Local"</code> indicates the local mean estimator,
<code>"SRS"</code> indicates the simple random sampling estimator, <code>"HT"</code>
indicates the Horvitz-Thompson estimator, and <code>"YG"</code> indicates the
Yates-Grundy estimator.  The default value is <code>"Local"</code>.</p>
</td></tr>
<tr><td><code id="cont_analysis_+3A_jointprob">jointprob</code></td>
<td>
<p>Character value providing the choice of joint inclusion
probability approximation for use with Horvitz-Thompson and Yates-Grundy
variance estimators, where <code>"overton"</code> indicates the Overton
approximation, <code>"hr"</code> indicates the Hartley-Rao approximation, and
<code>"brewer"</code> equals the Brewer approximation.  The default value is
<code>"overton"</code>.</p>
</td></tr>
<tr><td><code id="cont_analysis_+3A_conf">conf</code></td>
<td>
<p>Numeric value providing the Gaussian-based confidence level.  The default value
is <code>95</code>.</p>
</td></tr>
<tr><td><code id="cont_analysis_+3A_pctval">pctval</code></td>
<td>
<p>Vector of the set of values at which percentiles are
estimated.  The default set is: <code>c(5, 10, 25, 50, 75, 90, 95)</code>.</p>
</td></tr>
<tr><td><code id="cont_analysis_+3A_statistics">statistics</code></td>
<td>
<p>Character vector specifying desired estimates, where
<code>"CDF"</code> specifies CDF estimates, <code>"Pct"</code> specifies percentile
estimates, <code>"Mean"</code> specifies mean estimates, and &quot;Total&quot; specifies
total estimates.  Any combination of the four choices may be provided by
the user.  The default value is <code>c("CDF", "Pct", "Mean", "Total")</code>.</p>
</td></tr>
<tr><td><code id="cont_analysis_+3A_all_sites">All_Sites</code></td>
<td>
<p>A logical variable used when <code>subpops</code> is not
<code>NULL</code>. If <code>All_Sites</code> is <code>TRUE</code>, then alongside the
subpopulation output, output for all sites (ignoring subpopulations) is
returned for each variable in <code>vars</code>. If <code>All_Sites</code> is
<code>FALSE</code>, then alongside the subpopulation output, output for all sites
(ignoring subpopulations) is not returned for each variable in <code>vars</code>.
The default is <code>FALSE</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The analysis results. A list composed of one, two, three, or four
data frames that contain population estimates for all combinations of
subpopulations, categories within each subpopulation, and response
variables, where the number of data frames is determined by argument
<code>statistics</code>.  The possible data frames in the output list are:
</p>

<dl>
<dt><code>CDF</code></dt><dd><p>: a data frame containing CDF estimates</p>
</dd>
<dt><code>Pct</code></dt><dd><p>: data frame containing percentile estimates</p>
</dd>
<dt><code>Mean</code></dt><dd><p>: a data frame containing mean estimates</p>
</dd>
<dt><code>Total</code></dt><dd><p>: a data frame containing total estimates</p>
</dd>
</dl>

<p>The <code>CDF</code> data frame contains the following variables:
</p>

<dl>
<dt>Type</dt><dd><p>subpopulation (domain) name</p>
</dd>
<dt>Subpopulation</dt><dd><p>subpopulation name within a domain</p>
</dd>
<dt>Indicator</dt><dd><p>response variable</p>
</dd>
<dt>Value</dt><dd><p>value of response variable</p>
</dd>
<dt>nResp</dt><dd><p>sample size at or below <code>Value</code></p>
</dd>
<dt>Estimate.P</dt><dd><p>CDF proportion estimate (in %)</p>
</dd>
<dt>StdError.P</dt><dd><p>standard error of CDF proportion estimate</p>
</dd>
<dt>MarginofError.P</dt><dd><p>margin of error of CDF proportion estimate</p>
</dd>
<dt>LCBxxPct.P</dt><dd><p>xx% (default 95%) lower confidence bound of CDF proportion estimate</p>
</dd>
<dt>UCBxxPct.P</dt><dd><p>xx% (default 95%) upper confidence bound of CDF proportion estimate</p>
</dd>
<dt>Estimate.U</dt><dd><p>CDF total estimate</p>
</dd>
<dt>StdError.U</dt><dd><p>standard error of CDF total estimate</p>
</dd>
<dt>MarginofError.U</dt><dd><p>margin of error of CDF total estimate</p>
</dd>
<dt>LCBxxPct.U</dt><dd><p>xx% (default 95%) lower confidence bound of CDF total estimate</p>
</dd>
<dt>UCBxxPct.U</dt><dd><p>xx% (default 95%) upper confidence bound of CDF total estimate</p>
</dd>
</dl>

<p>The <code>Pct</code> data frame contains the following variables:
</p>

<dl>
<dt>Type</dt><dd><p>subpopulation (domain) name</p>
</dd>
<dt>Subpopulation</dt><dd><p>subpopulation name within a domain</p>
</dd>
<dt>Indicator</dt><dd><p>response variable</p>
</dd>
<dt>Statistic</dt><dd><p>value of percentile</p>
</dd>
<dt>nResp</dt><dd><p>sample size at or below <code>Value</code></p>
</dd>
<dt>Estimate</dt><dd><p>percentile estimate</p>
</dd>
<dt>StdError</dt><dd><p>standard error of percentile estimate</p>
</dd>
<dt>MarginofError</dt><dd><p>margin of error of percentile estimate</p>
</dd>
<dt>LCBxxPct</dt><dd><p>xx% (default 95%) lower confidence bound of percentile estimate</p>
</dd>
<dt>UCBxxPct</dt><dd><p>xx% (default 95%) upper confidence bound of percentile estimate</p>
</dd>
</dl>

<p>The <code>Mean</code> data frame contains the following variables:
</p>

<dl>
<dt>Type</dt><dd><p>subpopulation (domain) name</p>
</dd>
<dt>Subpopulation</dt><dd><p>subpopulation name within a domain</p>
</dd>
<dt>Indicator</dt><dd><p>response variable</p>
</dd>
<dt>nResp</dt><dd><p>sample size at or below <code>Value</code></p>
</dd>
<dt>Estimate</dt><dd><p>mean estimate</p>
</dd>
<dt>StdError</dt><dd><p>standard error of mean estimate</p>
</dd>
<dt>MarginofError</dt><dd><p>margin of error of mean estimate</p>
</dd>
<dt>LCBxxPct</dt><dd><p>xx% (default 95%) lower confidence bound of mean estimate</p>
</dd>
<dt>UCBxxPct</dt><dd><p>xx% (default 95%) upper confidence bound of mean estimate</p>
</dd>
</dl>

<p>The <code>Total</code> data frame contains the following variables:
</p>

<dl>
<dt>Type</dt><dd><p>subpopulation (domain) name</p>
</dd>
<dt>Subpopulation</dt><dd><p>subpopulation name within a domain</p>
</dd>
<dt>Indicator</dt><dd><p>response variable</p>
</dd>
<dt>nResp</dt><dd><p>sample size at or below <code>Value</code></p>
</dd>
<dt>Estimate</dt><dd><p>total estimate</p>
</dd>
<dt>StdError</dt><dd><p>standard error of total estimate</p>
</dd>
<dt>MarginofError</dt><dd><p>margin of error of total estimate</p>
</dd>
<dt>LCBxxPct</dt><dd><p>xx% (default 95%) lower confidence bound of total estimate</p>
</dd>
<dt>UCBxxPct</dt><dd><p>xx% (default 95%) upper confidence bound of total estimate</p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>Tom Kincaid <a href="mailto:Kincaid.Tom@epa.gov">Kincaid.Tom@epa.gov</a>
</p>


<h3>See Also</h3>


<dl>
<dt><code><a href="#topic+cat_analysis">cat_analysis</a></code></dt><dd><p> for categorical variable analysis</p>
</dd>
</dl>



<h3>Examples</h3>

<pre><code class='language-R'>dframe &lt;- data.frame(
  siteID = paste0("Site", 1:100),
  wgt = runif(100, 10, 100),
  xcoord = runif(100),
  ycoord = runif(100),
  stratum = rep(c("Stratum1", "Stratum2"), 50),
  ContVar = rnorm(100, 10, 1),
  All_Sites = rep("All Sites", 100),
  Resource_Class = rep(c("Good", "Poor"), c(55, 45))
)
myvars &lt;- c("ContVar")
mysubpops &lt;- c("All_Sites", "Resource_Class")
mypopsize &lt;- data.frame(
  Resource_Class = c("Good", "Poor"),
  Total = c(4000, 1500)
)
cont_analysis(dframe,
  vars = myvars, subpops = mysubpops, siteID = "siteID",
  weight = "wgt", xcoord = "xcoord", ycoord = "ycoord",
  stratumID = "stratum", popsize = mypopsize, statistics = "Mean"
)
</code></pre>

<hr>
<h2 id='cont_cdfplot'>Create a PDF file containing cumulative distribution functions (CDF) plots</h2><span id='topic+cont_cdfplot'></span>

<h3>Description</h3>

<p>This function creates a PDF file containing CDF plots.  Input data for the
plots is provided by a data frame with the same structure as the &quot;CDF&quot;
output from  <code>cont_analysis</code>.  Plots are produced for every combination of <code>Type</code> of
population, <code>Subpopulation</code> within <code>Type</code>, and <code>Indicator</code> (every combination
of subpopulations, subpopulation levels, and variables).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cont_cdfplot(
  pdffile = "cdf2x2.pdf",
  cdfest,
  units_cdf = "Percent",
  ind_type = rep("Continuous", nind),
  log = rep("", nind),
  xlab = NULL,
  ylab = NULL,
  ylab_r = NULL,
  legloc = NULL,
  cdf_page = 4,
  width = 10,
  height = 8,
  confcut = 0,
  cex.main = 1.2,
  cex.legend = 1,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cont_cdfplot_+3A_pdffile">pdffile</code></td>
<td>
<p>Name of the PDF file.  The default is &quot;cdf2x2.pdf&quot;.</p>
</td></tr>
<tr><td><code id="cont_cdfplot_+3A_cdfest">cdfest</code></td>
<td>
<p>Data frame with the same structure as the &quot;CDF&quot;
output from  <code>cont_analysis</code>.</p>
</td></tr>
<tr><td><code id="cont_cdfplot_+3A_units_cdf">units_cdf</code></td>
<td>
<p>Indicator for the label utilized for the left side y-axis
and the values used for the left side y-axis tick marks, where &quot;Percent&quot;
means the label and values are in terms of percent of the population, and
&quot;Units&quot; means the label and values are in terms of units (count, length,
or area) of the population.  The default is &quot;Percent&quot;.</p>
</td></tr>
<tr><td><code id="cont_cdfplot_+3A_ind_type">ind_type</code></td>
<td>
<p>Character vector consisting of the values &quot;Continuous&quot; or
&quot;Ordinal&quot; that controls the type of CDF plot for each indicator.  The
default is &quot;Continuous&quot; for every indicator.</p>
</td></tr>
<tr><td><code id="cont_cdfplot_+3A_log">log</code></td>
<td>
<p>Character vector consisting of the values &quot;&quot; or &quot;x&quot; that
controls whether the x axis uses the original scale (&quot;&quot;) or the base 10
logarithmic scale (&quot;x&quot;) for each indicator.  The default is &quot;&quot; for every
indicator.</p>
</td></tr>
<tr><td><code id="cont_cdfplot_+3A_xlab">xlab</code></td>
<td>
<p>Character vector consisting of the x-axis label for each
indicator. If this argument equals NULL, then indicator names are used as
the labels. The default is NULL.</p>
</td></tr>
<tr><td><code id="cont_cdfplot_+3A_ylab">ylab</code></td>
<td>
<p>Character string providing the left side y-axis label.  If
argument units_cdf equals &quot;Units&quot;, a value should be provided for this
argument.  Otherwise, the label will be &quot;Percent&quot;.  The default is
&quot;Percent&quot;.</p>
</td></tr>
<tr><td><code id="cont_cdfplot_+3A_ylab_r">ylab_r</code></td>
<td>
<p>Character string providing the label for the right side y-axis
(and, hence, determining the values used for the right side y-axis tick
marks), where NULL means a right side y-axis is not created.  If this
argument equals &quot;Same&quot;, the right side y-axis will have the same label and
tick mark values as the left side y-axis.  If this argument equals a
character string other than &quot;Same&quot;, the right side y-axis label will be the
value provided for argument ylab_r, and the right side y-axis tick mark
values will be determined by the choice not utilized for argument
units_cdf, which means that the default value of argument units_cdf (i.e.,
&quot;Percent&quot;) will result in the right side y-axis tick mark values being
expressed  in terms of units of the population (i.e., count, length, or
area).  The default is NULL.</p>
</td></tr>
<tr><td><code id="cont_cdfplot_+3A_legloc">legloc</code></td>
<td>
<p>Indicator for location of the plot legend, where &quot;BR&quot; means
bottom right, &quot;BL&quot; means bottom left, &quot;TR&quot; means top right, &quot;TL&quot; means
top left, and NULL means no legend.  The default is NULL.</p>
</td></tr>
<tr><td><code id="cont_cdfplot_+3A_cdf_page">cdf_page</code></td>
<td>
<p>Number of CDF plots on each page, which must be chosen from
the values: 1, 2, 4, or 6.  The default is 4.</p>
</td></tr>
<tr><td><code id="cont_cdfplot_+3A_width">width</code></td>
<td>
<p>Width of the graphic region in inches.  The default is 10.</p>
</td></tr>
<tr><td><code id="cont_cdfplot_+3A_height">height</code></td>
<td>
<p>Height of the graphic region in inches.  The default is 8.</p>
</td></tr>
<tr><td><code id="cont_cdfplot_+3A_confcut">confcut</code></td>
<td>
<p>Numeric value that controls plotting confidence limits at
the CDF extremes.  Confidence limits for CDF values (percent scale) less
than confcut or greater than 100 minus confcut are not plotted.  A value of
zero means confidence limits are plotted for the complete range of the CDF.
The default is 0.</p>
</td></tr>
<tr><td><code id="cont_cdfplot_+3A_cex.main">cex.main</code></td>
<td>
<p>Expansion factor for the plot title.  The default is 1.2.</p>
</td></tr>
<tr><td><code id="cont_cdfplot_+3A_cex.legend">cex.legend</code></td>
<td>
<p>Expansion factor for the legend title. The default is 1.</p>
</td></tr>
<tr><td><code id="cont_cdfplot_+3A_...">...</code></td>
<td>
<p>Additional arguments passed to the <code>cdf_plot</code> function.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A PDF file containing the CDF plots.
</p>


<h3>Author(s)</h3>

<p>Tom Kincaid <a href="mailto:Kincaid.Tom@epa.gov">Kincaid.Tom@epa.gov</a>
</p>


<h3>See Also</h3>


<dl>
<dt><code><a href="#topic+cdf_plot">cdf_plot</a></code></dt><dd><p>for plotting a cumulative distribution
function (CDF)</p>
</dd>
<dt><code><a href="#topic+cont_cdftest">cont_cdftest</a></code></dt><dd><p>for CDF hypothesis testing</p>
</dd>
</dl>



<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
dframe &lt;- data.frame(
  siteID = paste0("Site", 1:100),
  wgt = runif(100, 10, 100),
  xcoord = runif(100),
  ycoord = runif(100),
  stratum = rep(c("Stratum1", "Stratum2"), 50),
  ContVar = rnorm(100, 10, 1),
  All_Sites = rep("All Sites", 100),
  Resource_Class = rep(c("Good", "Poor"), c(55, 45))
)
myvars &lt;- c("ContVar")
mysubpops &lt;- c("All_Sites", "Resource_Class")
mypopsize &lt;- data.frame(
  Resource_Class = c("Good", "Poor"),
  Total = c(4000, 1500)
)
myanalysis &lt;- cont_analysis(dframe,
  vars = myvars, subpops = mysubpops,
  siteID = "siteID", weight = "wgt", xcoord = "xcoord", ycoord = "ycoord",
  stratumID = "stratum", popsize = mypopsize
)
cont_cdfplot("myanalysis.pdf", myanalysis$CDF, ylab_r = "Stream Length (km)")

## End(Not run)

</code></pre>

<hr>
<h2 id='cont_cdftest'>Cumulative distribution function (CDF) inference for a probability survey</h2><span id='topic+cont_cdftest'></span>

<h3>Description</h3>

<p>This function organizes input and output for conducting inference regarding
cumulative distribution functions (CDFs) generated by a probability survey.
For every response variable and every subpopulation (domain) variable,
differences between CDFs are tested for every pair of subpopulations within
the domain.  Data input to the function can be either a single survey or
multiple surveys (two or more).  If the data contain multiple surveys, then
the domain variables will reference those surveys and (potentially)
subpopulations within those surveys.  The inferential procedures divide the
CDFs into a discrete set of intervals (classes) and then utilize procedures
that have been developed for analysis of categorical data from probability
surveys.  Choices for inference are the Wald, adjusted Wald, Rao-Scott first
order corrected (mean eigenvalue corrected), and Rao-Scott second order
corrected (Satterthwaite corrected) test statistics. The default test
statistic is the adjusted Wald statistic.  The input data argument can be
either a data frame or a simple features (sf) object.  If an sf object is
used, coordinates are extracted from the geometry column in the object,
arguments xcoord and ycoord are assigned values &quot;xcoord&quot; and &quot;ycoord&quot;,
respectively, and the geometry column is dropped from the object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cont_cdftest(
  dframe,
  vars,
  subpops = NULL,
  surveyID = NULL,
  siteID = "siteID",
  weight = "weight",
  xcoord = NULL,
  ycoord = NULL,
  stratumID = NULL,
  clusterID = NULL,
  weight1 = NULL,
  xcoord1 = NULL,
  ycoord1 = NULL,
  sizeweight = FALSE,
  sweight = NULL,
  sweight1 = NULL,
  fpc = NULL,
  popsize = NULL,
  vartype = "Local",
  jointprob = "overton",
  testname = "adjWald",
  nclass = 3
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cont_cdftest_+3A_dframe">dframe</code></td>
<td>
<p>Data frame containing survey design variables, response
variables, and subpopulation (domain) variables.</p>
</td></tr>
<tr><td><code id="cont_cdftest_+3A_vars">vars</code></td>
<td>
<p>Vector composed of character values that identify the
names of response variables in the <code>dframe</code> data frame.</p>
</td></tr>
<tr><td><code id="cont_cdftest_+3A_subpops">subpops</code></td>
<td>
<p>Vector composed of character values that identify the
names of subpopulation (domain) variables in the <code>dframe</code> data frame.
If a value is not provided, the value <code>"All_Sites"</code> is assigned to the
subpops argument and a factor variable named <code>"All_Sites"</code> that takes
the value <code>"All Sites"</code> is added to the <code>dframe</code> data frame.  The
default value is <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="cont_cdftest_+3A_surveyid">surveyID</code></td>
<td>
<p>Character value providing name of the survey ID variable in
the <code>dframe</code> data frame.  If this argument equals <code>NULL</code>, then
the dframe data frame contains data for a single survey.  The default value
is <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="cont_cdftest_+3A_siteid">siteID</code></td>
<td>
<p>Character value providing name of the site ID variable in
the <code>dframe</code> data frame.  For a two-stage sample, the site ID variable
identifies stage two site IDs.  The default value is <code>"siteID"</code>.</p>
</td></tr>
<tr><td><code id="cont_cdftest_+3A_weight">weight</code></td>
<td>
<p>Character value providing name of the survey design weight
variable in the <code>dframe</code> data frame.  For a two-stage sample, the
weight variable identifies stage two weights.  The default value is
<code>"weight"</code>.</p>
</td></tr>
<tr><td><code id="cont_cdftest_+3A_xcoord">xcoord</code></td>
<td>
<p>Character value providing name of the x-coordinate variable in
the <code>dframe</code> data frame.  For a two-stage sample, the x-coordinate
variable identifies stage two x-coordinates.  Note that x-coordinates are
required for calculation of the local mean variance estimator.  The default
value is <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="cont_cdftest_+3A_ycoord">ycoord</code></td>
<td>
<p>Character value providing name of the y-coordinate variable in
the <code>dframe</code> data frame.  For a two-stage sample, the y-coordinate
variable identifies stage two y-coordinates.  Note that y-coordinates are
required for calculation of the local mean variance estimator.  The default
value is <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="cont_cdftest_+3A_stratumid">stratumID</code></td>
<td>
<p>Character value providing name of the stratum ID variable in
the <code>dframe</code> data frame.  The default value is <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="cont_cdftest_+3A_clusterid">clusterID</code></td>
<td>
<p>Character value providing the name of the cluster
(stage one) ID variable in the <code>dframe</code> data frame.  Note that cluster
IDs are required for a two-stage sample.  The default value is <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="cont_cdftest_+3A_weight1">weight1</code></td>
<td>
<p>Character value providing name of the stage one weight
variable in the <code>dframe</code> data frame.  The default value is <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="cont_cdftest_+3A_xcoord1">xcoord1</code></td>
<td>
<p>Character value providing the name of the stage one
x-coordinate variable in the <code>dframe</code> data frame.  Note that x
coordinates are required for calculation of the local mean variance
estimator.  The default value is <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="cont_cdftest_+3A_ycoord1">ycoord1</code></td>
<td>
<p>Character value providing the name of the stage one
y-coordinate variable in the <code>dframe</code> data frame.  Note that
y-coordinates are required for calculation of the local mean variance
estimator.  The default value is <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="cont_cdftest_+3A_sizeweight">sizeweight</code></td>
<td>
<p>Logical value that indicates whether size weights should be
used during estimation, where <code>TRUE</code> uses size weights and
<code>FALSE</code> does not use size weights. To employ size weights for a
single-stage sample, a value must be supplied for argument weight.  To
employ size weights for a two-stage sample, values must be supplied for
arguments <code>weight</code> and <code>weight1</code>. The default value is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="cont_cdftest_+3A_sweight">sweight</code></td>
<td>
<p>Character value providing the name of the size weight variable
in the <code>dframe</code> data frame.  For a two-stage sample, the size weight
variable identifies stage two size weights.  The default value is
<code>NULL</code>.</p>
</td></tr>
<tr><td><code id="cont_cdftest_+3A_sweight1">sweight1</code></td>
<td>
<p>Character value providing name of the stage one size weight
variable in the <code>dframe</code> data frame.  The default value is <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="cont_cdftest_+3A_fpc">fpc</code></td>
<td>
<p>Object that specifies values required for calculation of the
finite population correction factor used during variance estimation. The
object must match the survey design in terms of stratification and whether
the design is single-stage or two-stage.  For an unstratified design, the
object is a vector.  The vector is composed of a single numeric value for a
single-stage design.  For a two-stage unstratified design, the object is a
named vector containing one more than the number of clusters in the sample,
where the first item in the vector specifies the number of clusters in the
population and each subsequent item specifies the number of stage two units
for the cluster.  The name for the first item in the vector is arbitrary.
Subsequent names in the vector identify clusters and must match the cluster
IDs.  For a stratified design, the object is a named list of vectors, where
names must match the strata IDs.  For each stratum, the format of the
vector is identical to the format described for unstratified single-stage
and two-stage designs.  Note that the finite population correction factor
is not used with the local mean variance estimator.
</p>
<p>Example fpc for a single-stage unstratified survey design:
</p>
<p><code style="white-space: pre;">&#8288;fpc &lt;- 15000&#8288;</code>
</p>
<p>Example fpc for a single-stage stratified survey design:
</p>
<p><code style="white-space: pre;">&#8288;fpc &lt;- list(
    Stratum_1 = 9000,
    Stratum_2 = 6000)
   &#8288;</code>
</p>
<p>Example fpc for a two-stage unstratified survey design:
</p>
<p><code style="white-space: pre;">&#8288;fpc &lt;- c(
    Ncluster = 150,
    Cluster_1 = 150,
    Cluster_2 = 75,
    Cluster_3 = 75,
    Cluster_4 = 125,
    Cluster_5 = 75)
  &#8288;</code>
</p>
<p>Example fpc for a two-stage stratified survey design:
</p>
<p><code style="white-space: pre;">&#8288;fpc &lt;- list(
    Stratum_1 = c(
      Ncluster_1 = 100,
      Cluster_1 = 125,
      Cluster_2 = 100,
      Cluster_3 = 100,
      Cluster_4 = 125,
      Cluster_5 = 50),
    Stratum_2 = c(
      Ncluster_2 = 50,
      Cluster_1 = 75,
      Cluster_2 = 150,
      Cluster_3 = 75,
      Cluster_4 = 75,
      Cluster_5 = 125))
  &#8288;</code></p>
</td></tr>
<tr><td><code id="cont_cdftest_+3A_popsize">popsize</code></td>
<td>
<p>Object that provides values for the population argument of the
<code>calibrate</code> or <code>postStratify</code> functions in the survey package. If
a value is provided for popsize, then either the <code>calibrate</code> or
<code>postStratify</code> function is used to modify the survey design object
that is required by functions in the survey package.  Whether to use the
<code>calibrate</code> or <code>postStratify</code> function is dictated by the format
of popsize, which is discussed below.  Post-stratification adjusts the
sampling and replicate weights so that the joint distribution of a set of
post-stratifying variables matches the known population joint distribution.
Calibration, generalized raking, or GREG estimators generalize
post-stratification and raking by calibrating a sample to the marginal
totals of variables in a linear regression model. For the <code>calibrate</code>
function, the object is a named list, where the names identify factor
variables in the <code>dframe</code> data frame.  Each element of the list is a
named vector containing the population total for each level of the
associated factor variable.  For the <code>postStratify</code> function, the
object is either a data frame, table, or xtabs object that provides the
population total for all combinations of selected factor variables in the
<code>dframe</code> data frame.  If a data frame is used for <code>popsize</code>, the
variable containing population totals must be the last variable in the data
frame.  If a table is used for <code>popsize</code>, the table must have named
<code>dimnames</code> where the names identify factor variables in the
<code>dframe</code> data frame.  If the popsize argument is equal to <code>NULL</code>,
then neither calibration nor post-stratification is performed.  The default
value is <code>NULL</code>.
</p>
<p>Example popsize for calibration:
</p>
<p><code style="white-space: pre;">&#8288;popsize &lt;- list(
    Ecoregion = c(
      East = 750,
      Central = 500,
      West = 250),
    Type = c(
      Streams = 1150,
      Rivers = 350))
  &#8288;</code>
</p>
<p>Example popsize for post-stratification using a data frame:
</p>
<p><code style="white-space: pre;">&#8288;popsize &lt;- data.frame(
    Ecoregion = rep(c("East", "Central", "West"),
      rep(2, 3)),
    Type = rep(c("Streams", "Rivers"), 3),
    Total = c(575, 175, 400, 100, 175, 75))
  &#8288;</code>
</p>
<p>Example popsize for post-stratification using a table:
</p>
<p><code style="white-space: pre;">&#8288;popsize &lt;- with(MySurveyFrame,
    table(Ecoregion, Type))&#8288;</code>
</p>
<p>Example popsize for post-stratification using an xtabs object:
</p>
<p><code style="white-space: pre;">&#8288;popsize &lt;- xtabs(~Ecoregion + Type,
    data = MySurveyFrame)&#8288;</code></p>
</td></tr>
<tr><td><code id="cont_cdftest_+3A_vartype">vartype</code></td>
<td>
<p>Character value providing the choice of the variance
estimator, where <code>"Local"</code> indicates the local mean estimator,
<code>"SRS"</code> indicates the simple random sampling estimator, <code>"HT"</code>
indicates the Horvitz-Thompson estimator, and <code>"YG"</code> indicates the
Yates-Grundy estimator.  The default value is <code>"Local"</code>.</p>
</td></tr>
<tr><td><code id="cont_cdftest_+3A_jointprob">jointprob</code></td>
<td>
<p>Character value providing the choice of joint inclusion
probability approximation for use with Horvitz-Thompson and Yates-Grundy
variance estimators, where <code>"overton"</code> indicates the Overton
approximation, <code>"hr"</code> indicates the Hartley-Rao approximation, and
<code>"brewer"</code> equals the Brewer approximation.  The default value is
<code>"overton"</code>.</p>
</td></tr>
<tr><td><code id="cont_cdftest_+3A_testname">testname</code></td>
<td>
<p>Name of the test statistic to be reported in the output
data frame.  Choices for the name are: <code>"Wald"</code>, <code>"adjWald"</code>,
<code>"RaoScott_First"</code>, and <code>"RaoScott_Second"</code>, which correspond to
the Wald statistic, adjusted Wald statistic, Rao-Scott first-order
corrected statistic, and Rao-Scott second-order corrected statistic,
respectively.  The default is <code>"adjWald"</code>.</p>
</td></tr>
<tr><td><code id="cont_cdftest_+3A_nclass">nclass</code></td>
<td>
<p>Number of classes into which the CDFs will be divided
(binned), which must equal at least <code>2</code>.  The default is <code>3</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Data frame of CDF test results for all pairs of subpopulations
within each population type for every response variable.  The data frame
includes the test statistic specified by argument <code>testname</code> plus its
degrees of freedom and p-value.
</p>


<h3>Author(s)</h3>

<p>Tom Kincaid <a href="mailto:Kincaid.Tom@epa.gov">Kincaid.Tom@epa.gov</a>
</p>


<h3>See Also</h3>


<dl>
<dt><code><a href="#topic+cdf_plot">cdf_plot</a></code></dt><dd><p> for visualizing CDF plots</p>
</dd>
<dt><code><a href="#topic+cont_cdfplot">cont_cdfplot</a></code></dt><dd><p> for making CDF plots output to pdfs</p>
</dd>
</dl>



<h3>Examples</h3>

<pre><code class='language-R'>n &lt;- 200
mysiteID &lt;- paste("Site", 1:n, sep = "")
dframe &lt;- data.frame(
  siteID = mysiteID,
  wgt = runif(n, 10, 100),
  xcoord = runif(n),
  ycoord = runif(n),
  stratum = rep(c("Stratum1", "Stratum2"), n / 2),
  Resource_Class = sample(c("Agr", "Forest", "Urban"), n, replace = TRUE)
)
ContVar &lt;- numeric(n)
tst &lt;- dframe$Resource_Class == "Agr"
ContVar[tst] &lt;- rnorm(sum(tst), 10, 1)
tst &lt;- dframe$Resource_Class == "Forest"
ContVar[tst] &lt;- rnorm(sum(tst), 10.1, 1)
tst &lt;- dframe$Resource_Class == "Urban"
ContVar[tst] &lt;- rnorm(sum(tst), 10.5, 1)
dframe$ContVar &lt;- ContVar
myvars &lt;- c("ContVar")
mysubpops &lt;- c("Resource_Class")
mypopsize &lt;- data.frame(
  Resource_Class = rep(c("Agr", "Forest", "Urban"), rep(2, 3)),
  stratum = rep(c("Stratum1", "Stratum2"), 3),
  Total = c(2500, 1500, 1000, 500, 600, 450)
)
cont_cdftest(dframe,
  vars = myvars, subpops = mysubpops, siteID = "siteID",
  weight = "wgt", xcoord = "xcoord", ycoord = "ycoord",
  stratumID = "stratum", popsize = mypopsize, testname = "RaoScott_First"
)
</code></pre>

<hr>
<h2 id='cov_panel_dsgn'>Create a covariance matrix for a panel design</h2><span id='topic+cov_panel_dsgn'></span>

<h3>Description</h3>

<p>Covariance structure accounts for the panel design and the four variance
components: unit variation, period variation, unit by period interaction
variation and index (or residual) variation. The model incorporates unit,
period, unit by period, and index variance components. It also includes a
provision for unit correlation and period autocorrelation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cov_panel_dsgn(
  paneldsgn = matrix(50, 1, 10),
  nrepeats = 1,
  unit_var = NULL,
  period_var = NULL,
  unitperiod_var = NULL,
  index_var = NULL,
  unit_rho = 1,
  period_rho = 0
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cov_panel_dsgn_+3A_paneldsgn">paneldsgn</code></td>
<td>
<p>A matrix (dimensions: number of panels (rows) by number of
periods (columns)) containing the number of units visited for each
combination of panel and period. Default is matrix(50, 1, 10) which is a
single panel of 50 units visited 10 times, typical time is a period.</p>
</td></tr>
<tr><td><code id="cov_panel_dsgn_+3A_nrepeats">nrepeats</code></td>
<td>
<p>Either <code>NULL</code> or a list of matrices the same length as
paneldsgn specifying the number of revisits made to units in a panel in the
same period for each design.  Specifying <code>NULL</code> indicates that number of
revisits to units is the same for all panels and for all periods and for
all panel designs. The default is <code>NULL</code>, a single visit. Names must match
list names in <code>paneldsgn</code>.</p>
</td></tr>
<tr><td><code id="cov_panel_dsgn_+3A_unit_var">unit_var</code></td>
<td>
<p>The variance component estimate for unit. The default is
<code>NULL</code>.</p>
</td></tr>
<tr><td><code id="cov_panel_dsgn_+3A_period_var">period_var</code></td>
<td>
<p>The variance component estimate for period The default is
<code>NULL</code>.</p>
</td></tr>
<tr><td><code id="cov_panel_dsgn_+3A_unitperiod_var">unitperiod_var</code></td>
<td>
<p>The variance component estimate for unit by period
interaction. The default is <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="cov_panel_dsgn_+3A_index_var">index_var</code></td>
<td>
<p>The variance component estimate for index error. The
default is <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="cov_panel_dsgn_+3A_unit_rho">unit_rho</code></td>
<td>
<p>Unit correlation across periods. The default is <code>1</code>.</p>
</td></tr>
<tr><td><code id="cov_panel_dsgn_+3A_period_rho">period_rho</code></td>
<td>
<p>Period autocorrelation. The default is <code>0</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Covariance structure accounts for the panel design and the four
variance components: unit variation, period variation, unit by period
interaction variation and index (or residual) variation. Uses the model
structure defined by Urquhart 2012.
</p>
<p>If <code>nrepeats</code> is <code>NULL</code>, then no units sampled more than once in a specific
panel, period combination) and then unit by period and index variances are
added together or user may have only estimated unit, period and unit by
period variance components so that index component is zero. It calculates
the covariance matrix for the simple linear regression. The standard error
for a linear trend coefficient is the square root of the variance.
</p>


<h3>Value</h3>

<p>A list containing the covariance matrix (<code>cov</code>) for the panel design,
the input panel design (<code>paneldsgn</code>), the input <code>nrepeats</code> design
(<code>nrepeats.dsgn</code>) and the function call.
</p>


<h3>Author(s)</h3>

<p>Tony Olsen <a href="mailto:Olsen.Tony@epa.gov">Olsen.Tony@epa.gov</a>
</p>


<h3>References</h3>

<p>Urquhart, N. S., W. S. Overton, et al. (1993) Comparing sampling designs
for monitoring ecological status and trends: impact of temporal patterns.
In: <em>Statistics for the Environment.</em> V. Barnett and K. F. Turkman.
John Wiley &amp; Sons, New York, pp. 71-86.
</p>
<p>Urquhart, N. S. and T. M. Kincaid (1999). Designs for detecting trends
from repeated surveys of ecological resources. <em>Journal of
Agricultural, Biological, and Environmental Statistics</em>, <b>4(4)</b>,
404-414.
</p>
<p>Urquhart, N. S. (2012). The role of monitoring design in detecting trend in
long-term ecological monitoring studies. In: <em>Design and Analysis of
Long-term Ecological Monitoring Studies.</em> R. A. Gitzen, J. J. Millspaugh,
A. B. Cooper, and D. S. Licht (eds.). Cambridge University Press, New York,
pp. 151-173.
</p>


<h3>See Also</h3>


<dl>
<dt><code><a href="#topic+power_dsgn">power_dsgn</a></code></dt><dd><p> for power calculations of multiple panel
designs</p>
</dd>
</dl>


<hr>
<h2 id='diffrisk_analysis'>Risk difference analysis</h2><span id='topic+diffrisk_analysis'></span>

<h3>Description</h3>

<p>This function organizes input and output for risk difference analysis (of
categorical variables).  The analysis data,
<code>dframe</code>, can be either a data frame or a simple features (<code>sf</code>) object.  If an
<code>sf</code> object is used, coordinates are extracted from the geometry column in the
object, arguments <code>xcoord</code> and <code>ycoord</code> are assigned values
<code>"xcoord"</code> and <code>"ycoord"</code>, respectively, and the geometry column is
dropped from the object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>diffrisk_analysis(
  dframe,
  vars_response,
  vars_stressor,
  response_levels = NULL,
  stressor_levels = NULL,
  subpops = NULL,
  siteID = NULL,
  weight = "weight",
  xcoord = NULL,
  ycoord = NULL,
  stratumID = NULL,
  clusterID = NULL,
  weight1 = NULL,
  xcoord1 = NULL,
  ycoord1 = NULL,
  sizeweight = FALSE,
  sweight = NULL,
  sweight1 = NULL,
  fpc = NULL,
  popsize = NULL,
  vartype = "Local",
  conf = 95,
  All_Sites = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="diffrisk_analysis_+3A_dframe">dframe</code></td>
<td>
<p>Data to be analyzed (analysis data). A data frame or
<code>sf</code> object containing survey design
variables, response variables, stressor variables, and subpopulation
(domain) variables.</p>
</td></tr>
<tr><td><code id="diffrisk_analysis_+3A_vars_response">vars_response</code></td>
<td>
<p>Vector composed of character values that identify the
names of response variables in <code>dframe</code>. Each response
variable must have two category values (levels), where one level is
associated with poor condition and the other level is associated with good
condition.</p>
</td></tr>
<tr><td><code id="diffrisk_analysis_+3A_vars_stressor">vars_stressor</code></td>
<td>
<p>Vector composed of character values that identify the
names of stressor variables in <code>dframe</code>. Each stressor
variable must have two category values (levels), where one level is
associated with poor condition and the other level is associated with good
condition.</p>
</td></tr>
<tr><td><code id="diffrisk_analysis_+3A_response_levels">response_levels</code></td>
<td>
<p>List providing the category values (levels) for each
element in the <code>vars_response</code> argument.  Each element in the list
must contain two values, where the first value identifies poor condition,
and the second value identifies good condition.  This argument must be
named and must be the same length as argument <code>vars_response</code>.  Names
for this argument must match the values in the <code>vars_response</code>
argument. If this argument equals NULL, then a named list is created that
contains the values <code>"Poor"</code> and <code>"Good"</code> for the first and
second levels, respectively, of each element in the <code>vars_response</code>
argument and that uses values in the <code>vars_response</code> argument as names
for the list.  If <code>response_levels</code> is provided without names,
then the names of <code>response_levels</code> are set to <code>vars_response</code>.
The default value is NULL.</p>
</td></tr>
<tr><td><code id="diffrisk_analysis_+3A_stressor_levels">stressor_levels</code></td>
<td>
<p>List providing the category values (levels) for each
element in the <code>vars_stressor</code> argument.  Each element in the list
must contain two values, where the first value identifies poor condition,
and the second value identifies good condition.  This argument must be
named and must be the same length as argument <code>vars_stressor</code>.  Names
for this argument must match the values in the <code>vars_stressor</code>
argument. If this argument equals NULL, then a named list is created that
contains the values <code>"Poor"</code> and <code>"Good"</code> for the first and
second levels, respectively, of each element in the <code>vars_stressor</code>
argument and that uses values in the <code>vars_stressor</code> argument as names
for the list.  If <code>stressor_levels</code> is provided without names,
then the names of <code>stressor_levels</code> are set to <code>vars_stressor</code>. 
The default value is NULL.</p>
</td></tr>
<tr><td><code id="diffrisk_analysis_+3A_subpops">subpops</code></td>
<td>
<p>Vector composed of character values that identify the
names of subpopulation (domain) variables in <code>dframe</code>.
If a value is not provided, the value <code>"All_Sites"</code> is assigned to the
subpops argument and a factor variable named <code>"All_Sites"</code> that takes
the value <code>"All Sites"</code> is added to <code>dframe</code>.  The
default value is <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="diffrisk_analysis_+3A_siteid">siteID</code></td>
<td>
<p>Character value providing the name of the site ID variable in
<code>dframe</code>.  For a two-stage sample, the site ID variable
identifies stage two site IDs.  The default value is <code>NULL</code>, which
assumes that each row in <code>dframe</code> represents a unique site.</p>
</td></tr>
<tr><td><code id="diffrisk_analysis_+3A_weight">weight</code></td>
<td>
<p>Character value providing the name of the design weight
variable in <code>dframe</code>.  For a two-stage sample, the
weight variable identifies stage two weights.  The default value is
<code>"weight"</code>.</p>
</td></tr>
<tr><td><code id="diffrisk_analysis_+3A_xcoord">xcoord</code></td>
<td>
<p>Character value providing name of the x-coordinate variable in
<code>dframe</code>.  For a two-stage sample, the x-coordinate
variable identifies stage two x-coordinates.  Note that x-coordinates are
required for calculation of the local mean variance estimator.  If <code>dframe</code>
is an <code>sf</code> object, this argument is not required (as the geometry column
in <code>dframe</code> is used to find the x-coordinate). The default
value is <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="diffrisk_analysis_+3A_ycoord">ycoord</code></td>
<td>
<p>Character value providing name of the y-coordinate variable in
<code>dframe</code>.  For a two-stage sample, the y-coordinate
variable identifies stage two y-coordinates.  Note that y-coordinates are
required for calculation of the local mean variance estimator.  If <code>dframe</code>
is an <code>sf</code> object, this argument is not required (as the geometry column
in <code>dframe</code> is used to find the t-coordinate). The default
value is <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="diffrisk_analysis_+3A_stratumid">stratumID</code></td>
<td>
<p>Character value providing the name of the stratum ID
variable in <code>dframe</code>.  The default value is
<code>NULL</code>.</p>
</td></tr>
<tr><td><code id="diffrisk_analysis_+3A_clusterid">clusterID</code></td>
<td>
<p>Character value providing the name of the cluster
(stage one) ID variable in <code>dframe</code>.  Note that cluster
IDs are required for a two-stage sample.  The default value is <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="diffrisk_analysis_+3A_weight1">weight1</code></td>
<td>
<p>Character value providing the name of the stage one weight
variable in <code>dframe</code>.  The default value is
<code>NULL</code>.</p>
</td></tr>
<tr><td><code id="diffrisk_analysis_+3A_xcoord1">xcoord1</code></td>
<td>
<p>Character value providing the name of the stage one
x-coordinate variable in <code>dframe</code>.  Note that x
coordinates are required for calculation of the local mean variance
estimator.  The default value is <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="diffrisk_analysis_+3A_ycoord1">ycoord1</code></td>
<td>
<p>Character value providing the name of the stage one
y-coordinate variable in <code>dframe</code>.  Note that
y-coordinates are required for calculation of the local mean variance
estimator.  The default value is <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="diffrisk_analysis_+3A_sizeweight">sizeweight</code></td>
<td>
<p>Logical value that indicates whether size weights should be
used during estimation, where <code>TRUE</code> uses size weights and
<code>FALSE</code> does not use size weights. To employ size weights for a
single-stage sample, a value must be supplied for argument weight.  To
employ size weights for a two-stage sample, values must be supplied for
arguments <code>weight</code> and <code>weight1</code>. The default value is
<code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="diffrisk_analysis_+3A_sweight">sweight</code></td>
<td>
<p>Character value providing the name of the size weight variable
in <code>dframe</code>.  For a two-stage sample, the size weight
variable identifies stage two size weights.  The default value is
<code>NULL</code>.</p>
</td></tr>
<tr><td><code id="diffrisk_analysis_+3A_sweight1">sweight1</code></td>
<td>
<p>Character value providing the name of the stage one size
weight variable in <code>dframe</code>.  The default value is
<code>NULL</code>.</p>
</td></tr>
<tr><td><code id="diffrisk_analysis_+3A_fpc">fpc</code></td>
<td>
<p>Object that specifies values required for calculation of the
finite population correction factor used during variance estimation. The
object must match the survey design in terms of stratification and whether
the design is single-stage or two-stage.  For an unstratified design, the
object is a vector.  The vector is composed of a single numeric value for a
single-stage design.  For a two-stage unstratified design, the object is a
named vector containing one more than the number of clusters in the sample,
where the first item in the vector specifies the number of clusters in the
population and each subsequent item specifies the number of stage two units
for the cluster.  The name for the first item in the vector is arbitrary.
Subsequent names in the vector identify clusters and must match the cluster
IDs.  For a stratified design, the object is a named list of vectors, where
names must match the strata IDs.  For each stratum, the format of the
vector is identical to the format described for unstratified single-stage
and two-stage designs.  Note that the finite population correction factor
is not used with the local mean variance estimator.
</p>
<p>Example fpc for a single-stage unstratified survey design:
</p>
<p><code style="white-space: pre;">&#8288;fpc &lt;- 15000&#8288;</code>
</p>
<p>Example fpc for a single-stage stratified survey design:
</p>
<p><code style="white-space: pre;">&#8288;fpc &lt;- list(
    Stratum_1 = 9000,
    Stratum_2 = 6000)
   &#8288;</code>
</p>
<p>Example fpc for a two-stage unstratified survey design:
</p>
<p><code style="white-space: pre;">&#8288;fpc &lt;- c(
    Ncluster = 150,
    Cluster_1 = 150,
    Cluster_2 = 75,
    Cluster_3 = 75,
    Cluster_4 = 125,
    Cluster_5 = 75)
  &#8288;</code>
</p>
<p>Example fpc for a two-stage stratified survey design:
</p>
<p><code style="white-space: pre;">&#8288;fpc &lt;- list(
    Stratum_1 = c(
      Ncluster_1 = 100,
      Cluster_1 = 125,
      Cluster_2 = 100,
      Cluster_3 = 100,
      Cluster_4 = 125,
      Cluster_5 = 50),
    Stratum_2 = c(
      Ncluster_2 = 50,
      Cluster_1 = 75,
      Cluster_2 = 150,
      Cluster_3 = 75,
      Cluster_4 = 75,
      Cluster_5 = 125))
  &#8288;</code></p>
</td></tr>
<tr><td><code id="diffrisk_analysis_+3A_popsize">popsize</code></td>
<td>
<p>Object that provides values for the population argument of the
<code>calibrate</code> or <code>postStratify</code> functions in the survey package. If
a value is provided for popsize, then either the <code>calibrate</code> or
<code>postStratify</code> function is used to modify the survey design object
that is required by functions in the survey package.  Whether to use the
<code>calibrate</code> or <code>postStratify</code> function is dictated by the format
of popsize, which is discussed below.  Post-stratification adjusts the
sampling and replicate weights so that the joint distribution of a set of
post-stratifying variables matches the known population joint distribution.
Calibration, generalized raking, or GREG estimators generalize
post-stratification and raking by calibrating a sample to the marginal
totals of variables in a linear regression model. For the <code>calibrate</code>
function, the object is a named list, where the names identify factor
variables in <code>dframe</code>.  Each element of the list is a
named vector containing the population total for each level of the
associated factor variable.  For the <code>postStratify</code> function, the
object is either a data frame, table, or xtabs object that provides the
population total for all combinations of selected factor variables in the
<code>dframe</code> data frame.  If a data frame is used for <code>popsize</code>, the
variable containing population totals must be the last variable in the data
frame.  If a table is used for <code>popsize</code>, the table must have named
<code>dimnames</code> where the names identify factor variables in the
<code>dframe</code> data frame.  If the popsize argument is equal to <code>NULL</code>,
then neither calibration nor post-stratification is performed.  The default
value is <code>NULL</code>.
</p>
<p>Example popsize for calibration:
</p>
<p><code style="white-space: pre;">&#8288;popsize &lt;- list(
    Ecoregion = c(
      East = 750,
      Central = 500,
      West = 250),
    Type = c(
      Streams = 1150,
      Rivers = 350))
  &#8288;</code>
</p>
<p>Example popsize for post-stratification using a data frame:
</p>
<p><code style="white-space: pre;">&#8288;popsize &lt;- data.frame(
    Ecoregion = rep(c("East", "Central", "West"),
      rep(2, 3)),
    Type = rep(c("Streams", "Rivers"), 3),
    Total = c(575, 175, 400, 100, 175, 75))
  &#8288;</code>
</p>
<p>Example popsize for post-stratification using a table:
</p>
<p><code style="white-space: pre;">&#8288;popsize &lt;- with(MySurveyFrame,
    table(Ecoregion, Type))&#8288;</code>
</p>
<p>Example popsize for post-stratification using an xtabs object:
</p>
<p><code style="white-space: pre;">&#8288;popsize &lt;- xtabs(~Ecoregion + Type,
    data = MySurveyFrame)&#8288;</code></p>
</td></tr>
<tr><td><code id="diffrisk_analysis_+3A_vartype">vartype</code></td>
<td>
<p>Character value providing the choice of the variance
estimator, where <code>"Local"</code> indicates the local mean estimator and <code>"SRS"</code> indicates the
simple random sampling estimator.  The default value is <code>"Local"</code>.</p>
</td></tr>
<tr><td><code id="diffrisk_analysis_+3A_conf">conf</code></td>
<td>
<p>Numeric value providing the Gaussian-based confidence level.  The default value
is <code>95</code>.</p>
</td></tr>
<tr><td><code id="diffrisk_analysis_+3A_all_sites">All_Sites</code></td>
<td>
<p>A logical variable used when <code>subpops</code> is not
<code>NULL</code>. If <code>All_Sites</code> is <code>TRUE</code>, then alongside the
subpopulation output, output for all sites (ignoring subpopulations) is
returned for each variable in <code>vars</code>. If <code>All_Sites</code> is
<code>FALSE</code>, then alongside the subpopulation output, output for all sites
(ignoring subpopulations) is not returned for each variable in <code>vars</code>.
The default is <code>FALSE</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The analysis results. A data frame of population estimates for all combinations of
subpopulations, categories within each subpopulation, response variables,
and categories within each response variable.  Estimates are provided for
proportion and size of the population plus standard error, margin of error,
and confidence interval estimates. The data frame contains the following
variables:
</p>

<dl>
<dt>Type</dt><dd><p>subpopulation (domain) name</p>
</dd>
<dt>Subpopulation</dt><dd><p>subpopulation name within a domain</p>
</dd>
<dt>Response</dt><dd><p>response variable</p>
</dd>
<dt>Stressor</dt><dd><p>stressor variable</p>
</dd>
<dt>nResp</dt><dd><p>sample size</p>
</dd>
<dt>Estimate</dt><dd><p>risk difference estimate</p>
</dd>
<dt>Estimate_StressPoor</dt><dd><p>risk estimate for poor condition stressor</p>
</dd>
<dt>Estimate_StressGood</dt><dd><p>risk estimate for good condition stressor</p>
</dd>
<dt>StdError</dt><dd><p>risk difference standard error</p>
</dd>
<dt>MarginofError</dt><dd><p>risk difference margin of error</p>
</dd>
<dt>LCBxxPct</dt><dd><p>xx% (default 95%) lower confidence bound</p>
</dd>
<dt>UCBxxPct</dt><dd><p>xx% (default 95%) upper confidence bound</p>
</dd>
<dt>WeightTotal</dt><dd><p>sum of design weights</p>
</dd>
<dt>Count_RespPoor_StressPoor</dt><dd><p>number of observations in the poor response and poor stressor group</p>
</dd>
<dt>Count_RespPoor_StressGood</dt><dd><p>number of observations in the poor response and good stressor group</p>
</dd>
<dt>Count_RespGood_StressPoor</dt><dd><p>number of observations in the good response and poor stressor group</p>
</dd>
<dt>Count_RespGood_StressGood</dt><dd><p>number of observations in the good response and good stressor group</p>
</dd>
<dt>Prop_RespPoor_StressPoor</dt><dd><p>weighted proportion of observations in the poor response and poor stressor group</p>
</dd>
<dt>Prop_RespPoor_StressGood</dt><dd><p>weighted proportion of observations in the poor response and good stressor group</p>
</dd>
<dt>Prop_RespGood_StressPoor</dt><dd><p>weighted proportion of observations in the good response and poor stressor group</p>
</dd>
<dt>Prop_RespGood_StressGood</dt><dd><p>weighted proportion of observations in the good response and good stressor group</p>
</dd>
</dl>



<h3>Details</h3>

<p>Risk difference measures the absolute strength of association between
conditional probabilities defined for a response variable and a stressor
variable, where the response and stressor variables are classified as either
good (i.e., reference condition) or poor (i.e., different from reference
condition). Risk difference is defined as the difference between two
conditional probabilities: the probability that the response variable is in
poor condition given that the stressor variable is in poor condition and the
probability that the response variable is in poor condition given that the
stressor variable is in good condition.  Risk difference values close to zero
indicate that the stressor variable has little or no impact on the
probability that the response variable is in poor condition.  Risk difference
values much greater than zero indicate that the stressor variable has a
significant impact on the probability that the response variable is in poor
condition.
</p>


<h3>Author(s)</h3>

<p>Tom Kincaid <a href="mailto:Kincaid.Tom@epa.gov">Kincaid.Tom@epa.gov</a>
</p>


<h3>See Also</h3>


<dl>
<dt><code><a href="#topic+attrisk_analysis">attrisk_analysis</a></code></dt><dd><p> for attributable risk analysis</p>
</dd>
<dt><code><a href="#topic+relrisk_analysis">relrisk_analysis</a></code></dt><dd><p> for relative risk analysis</p>
</dd>
</dl>



<h3>Examples</h3>

<pre><code class='language-R'>dframe &lt;- data.frame(
  siteID = paste0("Site", 1:100),
  wgt = runif(100, 10, 100),
  xcoord = runif(100),
  ycoord = runif(100),
  stratum = rep(c("Stratum1", "Stratum2"), 50),
  RespVar1 = sample(c("Poor", "Good"), 100, replace = TRUE),
  RespVar2 = sample(c("Poor", "Good"), 100, replace = TRUE),
  StressVar = sample(c("Poor", "Good"), 100, replace = TRUE),
  All_Sites = rep("All Sites", 100),
  Resource_Class = rep(c("Agr", "Forest"), c(55, 45))
)
myresponse &lt;- c("RespVar1", "RespVar2")
mystressor &lt;- c("StressVar")
mysubpops &lt;- c("All_Sites", "Resource_Class")
diffrisk_analysis(dframe,
  vars_response = myresponse,
  vars_stressor = mystressor, subpops = mysubpops, siteID = "siteID",
  weight = "wgt", xcoord = "xcoord", ycoord = "ycoord",
  stratumID = "stratum"
)
</code></pre>

<hr>
<h2 id='errorprnt'>Print errors from analysis functions</h2><span id='topic+errorprnt'></span>

<h3>Description</h3>

<p>This function prints the error messages vector in the analysis functions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>errorprnt(error_vec = get("error_vec", envir = .GlobalEnv))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="errorprnt_+3A_error_vec">error_vec</code></td>
<td>
<p>Data frame that contains error messages.  The default is
<code>"error_vec"</code>, which is the name given to the error messages vector created
by functions in the spsurvey package.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Printed errors.
</p>


<h3>Author(s)</h3>

<p>Tom Kincaid <a href="mailto:Kincaid.Tom@epa.gov">Kincaid.Tom@epa.gov</a>
</p>

<hr>
<h2 id='grts'>Select a generalized random tessellation stratified (GRTS) sample</h2><span id='topic+grts'></span>

<h3>Description</h3>

<p>Select a spatially balanced sample from a point (finite), linear / linestring (infinite),
or areal / polygon (infinite) sampling frame using the Generalized Random Tessellation
Stratified (GRTS) algorithm. The GRTS algorithm accommodates unstratified and
stratified sampling designs and allows for equal inclusion probabilities, unequal
inclusion probabilities according to a categorical variable, and inclusion
probabilities proportional to a positive auxiliary variable. Several additional
sampling options are included, such as including legacy (historical) sites,
requiring a minimum distance between sites, and selecting replacement sites.
For technical details, see Stevens and Olsen (2004).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>grts(
  sframe,
  n_base,
  stratum_var = NULL,
  seltype = NULL,
  caty_var = NULL,
  caty_n = NULL,
  aux_var = NULL,
  legacy_var = NULL,
  legacy_sites = NULL,
  legacy_stratum_var = NULL,
  legacy_caty_var = NULL,
  legacy_aux_var = NULL,
  mindis = NULL,
  maxtry = 10,
  n_over = NULL,
  n_near = NULL,
  wgt_units = NULL,
  pt_density = NULL,
  DesignID = "Site",
  SiteBegin = 1,
  sep = "-",
  projcrs_check = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="grts_+3A_sframe">sframe</code></td>
<td>
<p>A sampling frame as an <code>sf</code> object. The coordinate
system for <code>sframe</code> must projected (not geographic). If m or z values
are in <code>sframe</code>'s geometry, they are silently dropped (i.e., only x-coordinates
and y-coordinates are preserved).</p>
</td></tr>
<tr><td><code id="grts_+3A_n_base">n_base</code></td>
<td>
<p>The base sample size required. If the sampling design is unstratified,
this is a single numeric value. If the sampling design is stratified, this is a named
vector or list whose names represent each stratum and whose values represent each
stratum's sample size. These names must match the values of the stratification
variable represented by <code>stratum_var</code>. Legacy sites are considered part
of the base sample, so the value for <code>n_base</code> should be equal to the number
of legacy sites plus the number of desired non-legacy sites.</p>
</td></tr>
<tr><td><code id="grts_+3A_stratum_var">stratum_var</code></td>
<td>
<p>A character string containing the name of the column from
<code>sframe</code> that identifies stratum membership for each element in <code>sframe</code>.
If stratum equals <code>NULL</code>, the sampling design is unstratified and all elements in <code>sframe</code>
are eligible to be selected in the sample. The default is <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="grts_+3A_seltype">seltype</code></td>
<td>
<p>A character string or vector indicating the inclusion probability type,
which must be one of following: <code>"equal"</code> for equal inclusion probabilities;
<code>"unequal"</code> for unequal inclusion probabilities according to a categorical
variable specified by <code>caty_var</code>; and <code>"proportional"</code> for inclusion
probabilities proportional to a positive auxiliary variable specified by
<code>aux_var</code>. If the sampling design is unstratified, <code>seltype</code> is a single
character vector. If the sampling design is stratified, <code>seltype</code> is a named vector
whose names represent each stratum and whose values represent each stratum's
inclusion probability type. <code>seltype</code>'s default value tries to match the
intended inclusion probability type: If <code>caty_var</code> and <code>aux_var</code> are
not specified, <code>seltype</code> is <code>"equal"</code>; if <code>caty_var</code> is specified,
<code>seltype</code> is <code>"unequal"</code>; and if <code>aux_var</code> is specified, <code>seltype</code>
is <code>"proportional"</code>.</p>
</td></tr>
<tr><td><code id="grts_+3A_caty_var">caty_var</code></td>
<td>
<p>A character string containing the name of the column from
<code>sframe</code> that represents the unequal probability variable.</p>
</td></tr>
<tr><td><code id="grts_+3A_caty_n">caty_n</code></td>
<td>
<p>A character vector indicating the expected sample size for each
level of <code>caty_var</code>, the unequal probability variable. If the sampling design
is unstratified, <code>caty_n</code> is a named vector whose names represent each
level of <code>caty_var</code> and whose values represent each level's expected
sample size. The sum of <code>caty_n</code> must equal <code>n_base</code>. If the sampling design
is stratified and the expected sample sizes are the same among strata, <code>caty_n</code> is
a named vector whose names represent represent each
level of <code>caty_var</code> and whose values represent each level's expected
sample size &ndash; these expected sample sizes are applied to all strata. The sum of
<code>caty_n</code> must equal each stratum's value in <code>n_base</code>.
If the sampling design is stratified and the expected sample sizes differ among strata,
<code>caty_n</code> is a list where each element  is named as a stratum in <code>n_base</code>.
Each stratum's list element is a named vector whose
names represent each level of <code>caty_var</code> and whose values represent each
level's expected sample size (within the stratum). The sum of the values in each stratum's
list element must equal that stratum's value in <code>n_base</code>.</p>
</td></tr>
<tr><td><code id="grts_+3A_aux_var">aux_var</code></td>
<td>
<p>A character string containing the name of the column from
<code>sframe</code> that represents the proportional (to size) inclusion probability
variable (auxiliary variable). This auxiliary variable must be positive, and the resulting
inclusion probabilities are proportional to the values of the auxiliary variable.
Larger values of the auxiliary variable result in higher inclusion probabilities.</p>
</td></tr>
<tr><td><code id="grts_+3A_legacy_var">legacy_var</code></td>
<td>
<p>This argument can be used instead of <code>legacy_sites</code>
when <code>sframe</code> is a <code>POINT</code> or <code>MULTIPOINT</code>
geometry (i.e. a finite sampling frame),
When <code>legacy_var</code> is used, it is a character string containing the name of the column
from <code>sframe</code> that represents whether each site is a legacy site. For
legacy sites, the values of the <code>legacy_var</code> must contain character strings that
act as a legacy site identifier. For non-legacy sites, the values of the
<code>legacy_var</code> column must be <code>NA</code>. Using this approach,
<code>legacy_stratum_var</code>, <code>legacy_caty_var</code>, and <code>legacy_aux_var</code>
are not required and should not be used (because <code>legacy_var</code> represents a column
in <code>sframe</code>). <code>spsurvey</code> assumes that the legacy sites were selected from
a previous sampling design that incorporated randomness into site selection
and that the legacy sites are elements of the current sampling frame.</p>
</td></tr>
<tr><td><code id="grts_+3A_legacy_sites">legacy_sites</code></td>
<td>
<p>An sf object with a <code>POINT</code> or <code>MULTIPOINT</code>
geometry representing the legacy sites. spsurvey assumes that
the legacy sites were selected from a previous sampling design that
incorporated randomness into site selection and that the legacy sites
are elements of the current sampling frame. If <code>sframe</code> has a
<code>POINT</code> or <code>MULTIPOINT</code> geometry, the observations in <code>legacy_sites</code>
should not also be in <code>sframe</code> (i.e., duplicates are not removed). Thus, <code>sframe</code>
and <code>legacy_sites</code> together compose the current sampling frame. If m or z values
are in <code>legacy_sites</code>' geometry, they are silently dropped (i.e., only x-coordinates
and y-coordinates are preserved).</p>
</td></tr>
<tr><td><code id="grts_+3A_legacy_stratum_var">legacy_stratum_var</code></td>
<td>
<p>A character string containing the name of the column from
<code>legacy_sites</code> that identifies stratum membership for each element of <code>legacy_sites</code>.
This argument is required when the sampling design is stratified and its levels
must be contained in the levels of the <code>stratum_var</code> variable. The default value of <code>legacy_stratum_var</code>
is <code>stratum_var</code>, so <code>legacy_stratum_var</code> need only be specified explicitly when
the name of the stratification variable in <code>legacy_sites</code> differs from <code>stratum_var</code>.</p>
</td></tr>
<tr><td><code id="grts_+3A_legacy_caty_var">legacy_caty_var</code></td>
<td>
<p>A character string containing the name of the column from
<code>legacy_sites</code> that identifies the unequal probability variable for each element of <code>legacy_sites</code>.
This argument is required when the sampling design uses unequal selection probabilities and its categories
must be contained in the levels of the <code>caty_var</code> variable. The default value of <code>legacy_caty_var</code>
is <code>caty_var</code>, so <code>legacy_caty_var</code> need only be specified explicitly when
the name of the unequal probability variable in <code>legacy_sites</code> differs from <code>caty_var</code>.</p>
</td></tr>
<tr><td><code id="grts_+3A_legacy_aux_var">legacy_aux_var</code></td>
<td>
<p>A character string containing the name of the column from
<code>legacy_sites</code> that identifies the proportional probability variable for each element of <code>legacy_sites</code>.
This argument is required when the sampling design uses proportional selection probabilities and the values of the
<code>legacy_aux_var</code> variable must be positive. The
default value of <code>legacy_aux_var</code> is <code>aux_var</code>, so <code>legacy_aux_var</code> need only be specified explicitly
when the name of the proportional probability variable in <code>legacy_sites</code> differs from <code>aux_var</code>.</p>
</td></tr>
<tr><td><code id="grts_+3A_mindis">mindis</code></td>
<td>
<p>A numeric value indicating the desired minimum distance between sampled
sites. If the sampling design is stratified and <code>mindis</code> is an numeric value, the minimum
distance is applied to all strata. If the sampling design is stratified and different minimum distances
are desired among strata, then <code>mindis</code>
is a list whose names match the names of <code>n_base</code> and whose and values
are the minimum distance for the corresponding stratum.  If a minimum distance is not desired
for a particular stratum, then the corresponding value in <code>mindis</code> should be <code>0</code> or
<code>NULL</code> (which is equivalent to <code>0</code>).
The units of <code>mindis</code> must represent the units in <code>sframe</code>. A warning is returned if the
minimum distance could not be reached after <code>maxtry</code> attempts. If legacy sites are used, the minimum distance
requirement (and subsequent warning if <code>maxtry</code> attempts are reached) is enforced for all base sites
that are not legacy sites (i.e., the minimum distance is enforced for these sites
by comparing distances against all base sites (legacy and non-legacy)).</p>
</td></tr>
<tr><td><code id="grts_+3A_maxtry">maxtry</code></td>
<td>
<p>The number of maximum attempts to apply the minimum distance algorithm to obtain
the desired minimum distance between sites. Each iteration takes roughly as long as the
standard GRTS algorithm. Successive iterations will always contain at least as many
sites satisfying the minimum distance requirement as the previous iteration. The algorithm stops
when the minimum distance requirement is met or there are <code>maxtry</code> iterations.
The default number of maximum iterations is <code>10</code>.</p>
</td></tr>
<tr><td><code id="grts_+3A_n_over">n_over</code></td>
<td>
<p>The number of reverse hierarchically ordered (rho) replacement sites.
If the sampling design is unstratified, then
<code>n_over</code> is an integer specifying the number of rho replacement sites desired.
If the sampling design is stratified,
then <code>n_over</code> is a vector (or list) whose names match the names of <code>n_base</code> and
whose values indicate the number of rho replacement sites for each stratum.
If replacement sites are not desired for a particular stratum, then the corresponding
value in <code>n_over</code> should be <code>0</code> or <code>NULL</code> (which is equivalent to <code>0</code>).
If the sampling design is stratified but the number of <code>n_over</code> sites is the same in each
stratum, <code>n_over</code> can be a vector which is used for each stratum.
If <code>n_over</code> is an unnamed, length-one vector, it's value is recycled
and used for each stratum. Note that if the
sampling design has unequal selection probabilities (<code>seltype = "unequal"</code>), then <code>n_over</code> sites
are given the same proportion of <code>caty_n</code> values as <code>n_base</code>.</p>
</td></tr>
<tr><td><code id="grts_+3A_n_near">n_near</code></td>
<td>
<p>The number of nearest neighbor (nn) replacement sites.
If the sampling design is unstratified, <code>n_near</code> is integer from <code>1</code>
to <code>10</code> specifying the number of
nn replacement sites to be selected for each base site. If the sampling design
is stratified but the same number of nn replacement sites is desired
for each stratum,  <code>n_near</code> is integer from <code>1</code>
to <code>10</code> specifying the number of
nn replacement sites to be selected for each base site. If the sampling design is
unstratified and a different number of nn replacement sites is
desired for each stratum, <code>n_near</code> is a vector (or list) whose names represent strata and whose
values is integer from <code>1</code>
to <code>10</code> specifying the number of
nn replacement sites to be selected for each base site in the stratum. If replacement sites
are not desired for a particular stratum, then the corresponding value in <code>n_over</code>
should be <code>0</code> or <code>NULL</code> (which is equivalent to <code>0</code>). For
infinite sampling frames, the distance between a site and its nn
depends on <code>pt_density</code>. The larger <code>pt_density</code>, the closer the nn neighbors.</p>
</td></tr>
<tr><td><code id="grts_+3A_wgt_units">wgt_units</code></td>
<td>
<p>The units used to compute the design weights. These
units must be standard units as defined by the <code>set_units()</code> function in
the units package. The default units match the units of the sf object.</p>
</td></tr>
<tr><td><code id="grts_+3A_pt_density">pt_density</code></td>
<td>
<p>A positive integer controlling the density of the GRTS approximation
for infinite sampling frames. The GRTS approximation for infinite sample
frames vastly improves computational efficiency by generating many finite points and
selecting a sample from the points. <code>pt_density</code> represents the density
of finite points per unit to use in the approximation. More specifically,
for each stratum, the number of points used in the approximation equals
<code>pt_density * (n_base + n_over)</code>. A larger value of <code>pt_density</code>
means a closer approximation to the infinite sampling frame but less
computational efficiency. The default value of <code>pt_density</code> is <code>10</code>. Note that
when used with <code>caty_n</code>, the unequal inclusion probabilities generated from
this approach are also approximations.</p>
</td></tr>
<tr><td><code id="grts_+3A_designid">DesignID</code></td>
<td>
<p>A character string indicating the naming structure for each
site's identifier selected in the sample, which is matched with <code>SiteBegin</code> and
included as a variable in the
sf object in the function's output. Default is &quot;Site&quot;.</p>
</td></tr>
<tr><td><code id="grts_+3A_sitebegin">SiteBegin</code></td>
<td>
<p>A character string indicating the first number to use to match
with <code>DesignID</code> while creating each site's identifier selected in the sample.
Successive sites are given successive integers. The default starting number
is <code>1</code> and the number of digits is equal to number of digits in
<code>nbase + nover</code>.
For example, if <code>nbase</code> is 50 and <code>nover</code> is 0, then the default
site identifiers are <code>Site-01</code> to <code>Site-50</code></p>
</td></tr>
<tr><td><code id="grts_+3A_sep">sep</code></td>
<td>
<p>A character string that acts as a separator between
<code>DesignID</code> and <code>SiteBegin</code>. The default is <code>"-"</code>.</p>
</td></tr>
<tr><td><code id="grts_+3A_projcrs_check">projcrs_check</code></td>
<td>
<p>A check for whether the coordinates are projected. If <code>TRUE</code>,
an error is returned if coordinates are not projected  (i.e., they are geographic or NA). If <code>FALSE</code>, the
check is not performed, which means that the crs in <code>sframe</code> (and <code>legacy_sites</code> if provided) can be projected, geographic, or NA.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>n_base</code> is the number of sites used to calculate
the design weights, which is typically the number of sites used in an analysis. When a panel sampling design is implemented, <code>n_base</code> is typically the
number of sites in all panels that will be sampled in the same temporal period &ndash;
<code>n_base</code> is not the total number of sites in all panels. The sum of <code>n_base</code> and
<code>n_over</code> is equal to the total number of sites to be visited for all panels plus
any replacement sites that may be required.
</p>


<h3>Value</h3>

<p>The sampling design sites and additional information about the sampling design. More specifically, it is, a list with five elements:
</p>

<ul>
<li> <p><code>sites_legacy</code> An sf object containing legacy sites. This is
<code>NULL</code> if legacy sites were not included in the sample.
</p>
</li>
<li> <p><code>sites_base</code> An sf object containing the base sites. This is <code>NULL</code>
if <code>n_base</code> equals the number of legacy sites.
</p>
</li>
<li> <p><code>sites_over</code> An sf object containing the reverse hierarchically
ordered replacement sites. This is <code>NULL</code> if no reverse hierarchically
ordered replacement sites were included in the sample.
</p>
</li>
<li> <p><code>sites_near</code> An sf object containing the nearest neighbor
replacement sites. This is <code>NULL</code> if no nearest neighbor replacement
sites were included in the sample.
</p>
</li>
<li> <p><code>design</code> A list documenting the specifications of this sampling design.
This can be checked to verify your sampling design ran as intended.
</p>

<ul>
<li> <p><code>call</code> The original function call.
</p>
</li>
<li> <p><code>stratum_var</code> The name of the stratification variable in <code>sframe</code>.
This equals <code>NULL</code> if no stratification is used.
</p>
</li>
<li> <p><code>stratum</code> The unique strata. This equals <code>"None"</code> if
the sampling design is unstratified.
</p>
</li>
<li> <p><code>n_base</code> The base sample size per stratum.
</p>
</li>
<li> <p><code>seltype</code> The selection type per stratum.
</p>
</li>
<li> <p><code>caty_var</code> The name of the unequal probability variable in <code>sframe</code>.
This equals <code>NULL</code> if no unequal probability variable is used.
</p>
</li>
<li> <p><code>caty_n</code> The expected sample sizes for each level of the
unequal probability grouping variable per stratum. This equals
<code>NULL</code> when <code>seltype</code> is not <code>"unequal"</code>.
</p>
</li>
<li> <p><code>aux_var</code> The name of the proportional probability (auxiliary) variable in <code>sframe</code>.
This equals <code>NULL</code> if no proportional probability variable is used.
</p>
</li>
<li> <p><code>legacy</code> A logical variable indicating whether legacy sites
were included in the sample.
</p>
</li>
<li> <p><code>legacy_stratum_var</code> The name of the stratification variable in <code>legacy_sites</code>.
Omitted if legacy sites are not used. This equals <code>NULL</code> if legacy sites were used but
no stratification variable is used.
</p>
</li>
<li> <p><code>legacy_caty_var</code> The name of the unequal probability variable in <code>legacy_sites</code>.
Omitted if legacy sites are not used. This equals <code>NULL</code> if legacy sites were used but
no unequal probability variable is used.
</p>
</li>
<li> <p><code>legacy_aux_var</code> The name of the proportional probability (auxiliary)
variable in <code>legacy_sites</code>.
Omitted if legacy sites are not used. This equals <code>NULL</code> if legacy sites
were used but no proportional probability variable is used.
</p>
</li>
<li> <p><code>mindis</code> The minimum distance requirement desired. This
is <code>NULL</code> when no minimum distance requirement was applied.
</p>
</li>
<li> <p><code>n_over</code> The reverse hierarchically ordered replacement
site sample sizes per stratum. If <code>seltype</code> is <code>unequal</code>,
this represents the expected sample sizes. This is <code>NULL</code>
when no reverse hierarchically ordered replacement sites were selected.
</p>
</li>
<li> <p><code>n_near</code> The number of nearest neighbor replacement sites
desired. This is <code>NULL</code> when no nearest neighbor replacement
sites were selected.
</p>
</li></ul>

</li></ul>

<p>When non-<code>NULL</code>, the <code>sites_legacy</code>, <code>sites_base</code>,
<code>sites_over</code>, and <code>sites_near</code> objects contain the original columns
in <code>sframe</code> and include a few additional columns. These additional columns
are
</p>

<ul>
<li> <p><code>siteID</code> A site identifier (as named using the <code>DesignID</code>
and <code>SiteBegin</code> arguments to <code>grts()</code>).
</p>
</li>
<li> <p><code>siteuse</code> Whether the site is a legacy site (<code>Legacy</code>), base
site (<code>Base</code>), reverse hierarchically ordered replacement site
(<code>Over</code>), or nearest neighbor replacement site (<code>Near</code>).
</p>
</li>
<li> <p><code>replsite</code> The replacement site ordering. <code>replsite</code> is
<code>None</code> if the site is not a replacement site, <code>Next</code> if it is
the next reverse hierarchically ordered replacement site to use, or
<code>Near_</code>, where the word following <code>_</code> indicates the ordering of sites closest to
the originally sampled site.
</p>
</li>
<li> <p><code>lon_WGS84</code> Longitude coordinates using the WGS84 coordinate
system (EPSG:4326). Only given if coordinates are projected.
</p>
</li>
<li> <p><code>lat_WGS84</code> Latitude coordinates using the WGS84 coordinate
system (EPSG:4326). Only given if coordinates are projected.
</p>
</li>
<li> <p><code>X</code> Longitude coordinates using the provided coordinate
system. Only given if coordinates are not projected (i.e., they are geographic or NA).
</p>
</li>
<li> <p><code>Y</code> Latitude coordinates using the provided coordinate
system. Only given if coordinates are not projected (i.e., they are geographic or NA).
</p>
</li>
<li> <p><code>stratum</code> A stratum indicator. <code>stratum</code> is <code>None</code>
if the sampling design was unstratified. If the sampling design was <code>stratified</code>,
<code>stratum</code> indicates the stratum.
</p>
</li>
<li> <p><code>wgt</code> The design weight.
</p>
</li>
<li> <p><code>ip</code> The site's original inclusion probability (the reciprocal)
of (<code>wgt</code>).
</p>
</li>
<li> <p><code>caty</code> An unequal probability grouping indicator. <code>caty</code>
is <code>None</code> if the sampling design did not use unequal inclusion probabilities.
If the sampling design did use unequal inclusion probabilities, <code>caty</code>
indicates the unequal probability level.
</p>
</li>
<li> <p><code>aux</code> The auxiliary proportional probability variable. This
column is only returned if <code>seltype</code> was <code>proportional</code> in the
original sampling design.
</p>
</li></ul>

<p>If any columns in <code>sframe</code> contain these names, those columns
from <code>sframe</code> will be automatically prefixed with <code>sframe_</code>
in the <code>sites</code> object. When output is printed, a summary of site counts by
the levels in <code>stratum_var</code> and <code>caty_var</code> is shown.
</p>


<h3>Author(s)</h3>

<p>Tony Olsen <a href="mailto:olsen.tony@epa.gov">olsen.tony@epa.gov</a>
</p>


<h3>References</h3>

<p>Stevens Jr., Don L. and Olsen, Anthony R. (2004). Spatially balanced sampling
of natural resources. <em>Journal of the American Statistical Association</em>, 99(465), 262-278.
</p>


<h3>See Also</h3>


<dl>
<dt><code><a href="#topic+irs">irs</a></code></dt><dd><p> to select a sample that is not spatially balanced</p>
</dd>
</dl>



<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
samp &lt;- grts(NE_Lakes, n_base = 100)
print(samp)
strata_n &lt;- c(low = 25, high = 30)
samp_strat &lt;- grts(NE_Lakes, n_base = strata_n, stratum_var = "ELEV_CAT")
print(samp_strat)
samp_over &lt;- grts(NE_Lakes, n_base = 30, n_over = 5)
print(samp_over)

## End(Not run)
</code></pre>

<hr>
<h2 id='Illinois_River'>Illinois River data</h2><span id='topic+Illinois_River'></span>

<h3>Description</h3>

<p>An (<code>sf</code>) MULTILINESTRING object of 244 segments of the
Illinois River in Arkansas and Oklahoma.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Illinois_River
</code></pre>


<h3>Format</h3>

<p>244 rows and 2 variables:
</p>

<dl>
<dt><code>STATE_NAME</code></dt><dd><p> State name.</p>
</dd>
<dt><code>geometry</code></dt><dd><p> MULTILINESTRING geometry using the NAD83 / Conus Albers
coordinate reference system (EPSG: 5070).</p>
</dd>
</dl>


<hr>
<h2 id='Illinois_River_Legacy'>Illinois River legacy data</h2><span id='topic+Illinois_River_Legacy'></span>

<h3>Description</h3>

<p>An (<code>sf</code>) POINT object of legacy sites for the Illinois
River data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Illinois_River_Legacy
</code></pre>


<h3>Format</h3>

<p>5 rows and 2 variables:
</p>

<dl>
<dt><code>STATE_NAME</code></dt><dd><p> State name.</p>
</dd>
<dt><code>geometry</code></dt><dd><p> POINT geometry using the NAD83 / Conus Albers
coordinate reference system (EPSG: 5070).</p>
</dd>
</dl>


<hr>
<h2 id='irs'>Select an independent random sample (IRS)</h2><span id='topic+irs'></span>

<h3>Description</h3>

<p>Select a sample that is not spatially balanced from a point (finite), linear / linestring (infinite),
or areal / polygon (infinite) sampling frame using the Independent Random Sampling (IRS) algorithm.
The IRS algorithm accommodates unstratified and
stratified sampling designs and allows for equal inclusion probabilities, unequal
inclusion probabilities according to a categorical variable, and inclusion
probabilities proportional to a positive auxiliary variable. Several additional
sampling options are included, such as including legacy (historical) sites,
requiring a minimum distance between sites, and selecting replacement sites.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>irs(
  sframe,
  n_base,
  stratum_var = NULL,
  seltype = NULL,
  caty_var = NULL,
  caty_n = NULL,
  aux_var = NULL,
  legacy_var = NULL,
  legacy_sites = NULL,
  legacy_stratum_var = NULL,
  legacy_caty_var = NULL,
  legacy_aux_var = NULL,
  mindis = NULL,
  maxtry = 10,
  n_over = NULL,
  n_near = NULL,
  wgt_units = NULL,
  pt_density = NULL,
  DesignID = "Site",
  SiteBegin = 1,
  sep = "-",
  projcrs_check = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="irs_+3A_sframe">sframe</code></td>
<td>
<p>A sampling frame as an <code>sf</code> object. The coordinate
system for <code>sframe</code> must projected (not geographic). If m or z values
are in <code>sframe</code>'s geometry, they are silently dropped (i.e., only x-coordinates
and y-coordinates are preserved).</p>
</td></tr>
<tr><td><code id="irs_+3A_n_base">n_base</code></td>
<td>
<p>The base sample size required. If the sampling design is unstratified,
this is a single numeric value. If the sampling design is stratified, this is a named
vector or list whose names represent each stratum and whose values represent each
stratum's sample size. These names must match the values of the stratification
variable represented by <code>stratum_var</code>. Legacy sites are considered part
of the base sample, so the value for <code>n_base</code> should be equal to the number
of legacy sites plus the number of desired non-legacy sites.</p>
</td></tr>
<tr><td><code id="irs_+3A_stratum_var">stratum_var</code></td>
<td>
<p>A character string containing the name of the column from
<code>sframe</code> that identifies stratum membership for each element in <code>sframe</code>.
If stratum equals <code>NULL</code>, the sampling design is unstratified and all elements in <code>sframe</code>
are eligible to be selected in the sample. The default is <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="irs_+3A_seltype">seltype</code></td>
<td>
<p>A character string or vector indicating the inclusion probability type,
which must be one of following: <code>"equal"</code> for equal inclusion probabilities;
<code>"unequal"</code> for unequal inclusion probabilities according to a categorical
variable specified by <code>caty_var</code>; and <code>"proportional"</code> for inclusion
probabilities proportional to a positive auxiliary variable specified by
<code>aux_var</code>. If the sampling design is unstratified, <code>seltype</code> is a single
character vector. If the sampling design is stratified, <code>seltype</code> is a named vector
whose names represent each stratum and whose values represent each stratum's
inclusion probability type. <code>seltype</code>'s default value tries to match the
intended inclusion probability type: If <code>caty_var</code> and <code>aux_var</code> are
not specified, <code>seltype</code> is <code>"equal"</code>; if <code>caty_var</code> is specified,
<code>seltype</code> is <code>"unequal"</code>; and if <code>aux_var</code> is specified, <code>seltype</code>
is <code>"proportional"</code>.</p>
</td></tr>
<tr><td><code id="irs_+3A_caty_var">caty_var</code></td>
<td>
<p>A character string containing the name of the column from
<code>sframe</code> that represents the unequal probability variable.</p>
</td></tr>
<tr><td><code id="irs_+3A_caty_n">caty_n</code></td>
<td>
<p>A character vector indicating the expected sample size for each
level of <code>caty_var</code>, the unequal probability variable. If the sampling design
is unstratified, <code>caty_n</code> is a named vector whose names represent each
level of <code>caty_var</code> and whose values represent each level's expected
sample size. The sum of <code>caty_n</code> must equal <code>n_base</code>. If the sampling design
is stratified and the expected sample sizes are the same among strata, <code>caty_n</code> is
a named vector whose names represent represent each
level of <code>caty_var</code> and whose values represent each level's expected
sample size &ndash; these expected sample sizes are applied to all strata. The sum of
<code>caty_n</code> must equal each stratum's value in <code>n_base</code>.
If the sampling design is stratified and the expected sample sizes differ among strata,
<code>caty_n</code> is a list where each element  is named as a stratum in <code>n_base</code>.
Each stratum's list element is a named vector whose
names represent each level of <code>caty_var</code> and whose values represent each
level's expected sample size (within the stratum). The sum of the values in each stratum's
list element must equal that stratum's value in <code>n_base</code>.</p>
</td></tr>
<tr><td><code id="irs_+3A_aux_var">aux_var</code></td>
<td>
<p>A character string containing the name of the column from
<code>sframe</code> that represents the proportional (to size) inclusion probability
variable (auxiliary variable). This auxiliary variable must be positive, and the resulting
inclusion probabilities are proportional to the values of the auxiliary variable.
Larger values of the auxiliary variable result in higher inclusion probabilities.</p>
</td></tr>
<tr><td><code id="irs_+3A_legacy_var">legacy_var</code></td>
<td>
<p>This argument can be used instead of <code>legacy_sites</code>
when <code>sframe</code> is a <code>POINT</code> or <code>MULTIPOINT</code>
geometry (i.e. a finite sampling frame),
When <code>legacy_var</code> is used, it is a character string containing the name of the column
from <code>sframe</code> that represents whether each site is a legacy site. For
legacy sites, the values of the <code>legacy_var</code> must contain character strings that
act as a legacy site identifier. For non-legacy sites, the values of the
<code>legacy_var</code> column must be <code>NA</code>. Using this approach,
<code>legacy_stratum_var</code>, <code>legacy_caty_var</code>, and <code>legacy_aux_var</code>
are not required and should not be used (because <code>legacy_var</code> represents a column
in <code>sframe</code>). <code>spsurvey</code> assumes that the legacy sites were selected from
a previous sampling design that incorporated randomness into site selection
and that the legacy sites are elements of the current sampling frame.</p>
</td></tr>
<tr><td><code id="irs_+3A_legacy_sites">legacy_sites</code></td>
<td>
<p>An sf object with a <code>POINT</code> or <code>MULTIPOINT</code>
geometry representing the legacy sites. spsurvey assumes that
the legacy sites were selected from a previous sampling design that
incorporated randomness into site selection and that the legacy sites
are elements of the current sampling frame. If <code>sframe</code> has a
<code>POINT</code> or <code>MULTIPOINT</code> geometry, the observations in <code>legacy_sites</code>
should not also be in <code>sframe</code> (i.e., duplicates are not removed). Thus, <code>sframe</code>
and <code>legacy_sites</code> together compose the current sampling frame. If m or z values
are in <code>legacy_sites</code>' geometry, they are silently dropped (i.e., only x-coordinates
and y-coordinates are preserved).</p>
</td></tr>
<tr><td><code id="irs_+3A_legacy_stratum_var">legacy_stratum_var</code></td>
<td>
<p>A character string containing the name of the column from
<code>legacy_sites</code> that identifies stratum membership for each element of <code>legacy_sites</code>.
This argument is required when the sampling design is stratified and its levels
must be contained in the levels of the <code>stratum_var</code> variable. The default value of <code>legacy_stratum_var</code>
is <code>stratum_var</code>, so <code>legacy_stratum_var</code> need only be specified explicitly when
the name of the stratification variable in <code>legacy_sites</code> differs from <code>stratum_var</code>.</p>
</td></tr>
<tr><td><code id="irs_+3A_legacy_caty_var">legacy_caty_var</code></td>
<td>
<p>A character string containing the name of the column from
<code>legacy_sites</code> that identifies the unequal probability variable for each element of <code>legacy_sites</code>.
This argument is required when the sampling design uses unequal selection probabilities and its categories
must be contained in the levels of the <code>caty_var</code> variable. The default value of <code>legacy_caty_var</code>
is <code>caty_var</code>, so <code>legacy_caty_var</code> need only be specified explicitly when
the name of the unequal probability variable in <code>legacy_sites</code> differs from <code>caty_var</code>.</p>
</td></tr>
<tr><td><code id="irs_+3A_legacy_aux_var">legacy_aux_var</code></td>
<td>
<p>A character string containing the name of the column from
<code>legacy_sites</code> that identifies the proportional probability variable for each element of <code>legacy_sites</code>.
This argument is required when the sampling design uses proportional selection probabilities and the values of the
<code>legacy_aux_var</code> variable must be positive. The
default value of <code>legacy_aux_var</code> is <code>aux_var</code>, so <code>legacy_aux_var</code> need only be specified explicitly
when the name of the proportional probability variable in <code>legacy_sites</code> differs from <code>aux_var</code>.</p>
</td></tr>
<tr><td><code id="irs_+3A_mindis">mindis</code></td>
<td>
<p>A numeric value indicating the desired minimum distance between sampled
sites. If the sampling design is stratified and <code>mindis</code> is an numeric value, the minimum
distance is applied to all strata. If the sampling design is stratified and different minimum distances
are desired among strata, then <code>mindis</code>
is a list whose names match the names of <code>n_base</code> and whose and values
are the minimum distance for the corresponding stratum.  If a minimum distance is not desired
for a particular stratum, then the corresponding value in <code>mindis</code> should be <code>0</code> or
<code>NULL</code> (which is equivalent to <code>0</code>).
The units of <code>mindis</code> must represent the units in <code>sframe</code>. A warning is returned if the
minimum distance could not be reached after <code>maxtry</code> attempts. If legacy sites are used, the minimum distance
requirement (and subsequent warning if <code>maxtry</code> attempts are reached) is enforced for all base sites
that are not legacy sites (i.e., the minimum distance is enforced for these sites
by comparing distances against all base sites (legacy and non-legacy)).</p>
</td></tr>
<tr><td><code id="irs_+3A_maxtry">maxtry</code></td>
<td>
<p>The number of maximum attempts to apply the minimum distance algorithm to obtain
the desired minimum distance between sites. Each iteration takes roughly as long as the
standard GRTS algorithm. Successive iterations will always contain at least as many
sites satisfying the minimum distance requirement as the previous iteration. The algorithm stops
when the minimum distance requirement is met or there are <code>maxtry</code> iterations.
The default number of maximum iterations is <code>10</code>.</p>
</td></tr>
<tr><td><code id="irs_+3A_n_over">n_over</code></td>
<td>
<p>The number of reverse hierarchically ordered (rho) replacement sites.
If the sampling design is unstratified, then
<code>n_over</code> is an integer specifying the number of rho replacement sites desired.
If the sampling design is stratified,
then <code>n_over</code> is a vector (or list) whose names match the names of <code>n_base</code> and
whose values indicate the number of rho replacement sites for each stratum.
If replacement sites are not desired for a particular stratum, then the corresponding
value in <code>n_over</code> should be <code>0</code> or <code>NULL</code> (which is equivalent to <code>0</code>).
If the sampling design is stratified but the number of <code>n_over</code> sites is the same in each
stratum, <code>n_over</code> can be a vector which is used for each stratum.
If <code>n_over</code> is an unnamed, length-one vector, it's value is recycled
and used for each stratum. Note that if the
sampling design has unequal selection probabilities (<code>seltype = "unequal"</code>), then <code>n_over</code> sites
are given the same proportion of <code>caty_n</code> values as <code>n_base</code>.</p>
</td></tr>
<tr><td><code id="irs_+3A_n_near">n_near</code></td>
<td>
<p>The number of nearest neighbor (nn) replacement sites.
If the sampling design is unstratified, <code>n_near</code> is integer from <code>1</code>
to <code>10</code> specifying the number of
nn replacement sites to be selected for each base site. If the sampling design
is stratified but the same number of nn replacement sites is desired
for each stratum,  <code>n_near</code> is integer from <code>1</code>
to <code>10</code> specifying the number of
nn replacement sites to be selected for each base site. If the sampling design is
unstratified and a different number of nn replacement sites is
desired for each stratum, <code>n_near</code> is a vector (or list) whose names represent strata and whose
values is integer from <code>1</code>
to <code>10</code> specifying the number of
nn replacement sites to be selected for each base site in the stratum. If replacement sites
are not desired for a particular stratum, then the corresponding value in <code>n_over</code>
should be <code>0</code> or <code>NULL</code> (which is equivalent to <code>0</code>). For
infinite sampling frames, the distance between a site and its nn
depends on <code>pt_density</code>. The larger <code>pt_density</code>, the closer the nn neighbors.</p>
</td></tr>
<tr><td><code id="irs_+3A_wgt_units">wgt_units</code></td>
<td>
<p>The units used to compute the design weights. These
units must be standard units as defined by the <code>set_units()</code> function in
the units package. The default units match the units of the sf object.</p>
</td></tr>
<tr><td><code id="irs_+3A_pt_density">pt_density</code></td>
<td>
<p>A positive integer controlling the density of the GRTS approximation
for infinite sampling frames. The GRTS approximation for infinite sample
frames vastly improves computational efficiency by generating many finite points and
selecting a sample from the points. <code>pt_density</code> represents the density
of finite points per unit to use in the approximation. More specifically,
for each stratum, the number of points used in the approximation equals
<code>pt_density * (n_base + n_over)</code>. A larger value of <code>pt_density</code>
means a closer approximation to the infinite sampling frame but less
computational efficiency. The default value of <code>pt_density</code> is <code>10</code>. Note that
when used with <code>caty_n</code>, the unequal inclusion probabilities generated from
this approach are also approximations.</p>
</td></tr>
<tr><td><code id="irs_+3A_designid">DesignID</code></td>
<td>
<p>A character string indicating the naming structure for each
site's identifier selected in the sample, which is matched with <code>SiteBegin</code> and
included as a variable in the
sf object in the function's output. Default is &quot;Site&quot;.</p>
</td></tr>
<tr><td><code id="irs_+3A_sitebegin">SiteBegin</code></td>
<td>
<p>A character string indicating the first number to use to match
with <code>DesignID</code> while creating each site's identifier selected in the sample.
Successive sites are given successive integers. The default starting number
is <code>1</code> and the number of digits is equal to number of digits in
<code>nbase + nover</code>.
For example, if <code>nbase</code> is 50 and <code>nover</code> is 0, then the default
site identifiers are <code>Site-01</code> to <code>Site-50</code></p>
</td></tr>
<tr><td><code id="irs_+3A_sep">sep</code></td>
<td>
<p>A character string that acts as a separator between
<code>DesignID</code> and <code>SiteBegin</code>. The default is <code>"-"</code>.</p>
</td></tr>
<tr><td><code id="irs_+3A_projcrs_check">projcrs_check</code></td>
<td>
<p>A check for whether the coordinates are projected. If <code>TRUE</code>,
an error is returned if coordinates are not projected  (i.e., they are geographic or NA). If <code>FALSE</code>, the
check is not performed, which means that the crs in <code>sframe</code> (and <code>legacy_sites</code> if provided) can be projected, geographic, or NA.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>n_base</code> is the number of sites used to calculate
the design weights, which is typically the number of sites used in an analysis. When a panel sampling design is implemented, <code>n_base</code> is typically the
number of sites in all panels that will be sampled in the same temporal period &ndash;
<code>n_base</code> is not the total number of sites in all panels. The sum of <code>n_base</code> and
<code>n_over</code> is equal to the total number of sites to be visited for all panels plus
any replacement sites that may be required.
</p>


<h3>Value</h3>

<p>The sampling design sites and additional information about the sampling design. More specifically, it is, a list with five elements:
</p>

<ul>
<li> <p><code>sites_legacy</code> An sf object containing legacy sites. This is
<code>NULL</code> if legacy sites were not included in the sample.
</p>
</li>
<li> <p><code>sites_base</code> An sf object containing the base sites. This is <code>NULL</code>
if <code>n_base</code> equals the number of legacy sites.
</p>
</li>
<li> <p><code>sites_over</code> An sf object containing the reverse hierarchically
ordered replacement sites. This is <code>NULL</code> if no reverse hierarchically
ordered replacement sites were included in the sample.
</p>
</li>
<li> <p><code>sites_near</code> An sf object containing the nearest neighbor
replacement sites. This is <code>NULL</code> if no nearest neighbor replacement
sites were included in the sample.
</p>
</li>
<li> <p><code>design</code> A list documenting the specifications of this sampling design.
This can be checked to verify your sampling design ran as intended.
</p>

<ul>
<li> <p><code>call</code> The original function call.
</p>
</li>
<li> <p><code>stratum_var</code> The name of the stratification variable in <code>sframe</code>.
This equals <code>NULL</code> if no stratification is used.
</p>
</li>
<li> <p><code>stratum</code> The unique strata. This equals <code>"None"</code> if
the sampling design is unstratified.
</p>
</li>
<li> <p><code>n_base</code> The base sample size per stratum.
</p>
</li>
<li> <p><code>seltype</code> The selection type per stratum.
</p>
</li>
<li> <p><code>caty_var</code> The name of the unequal probability variable in <code>sframe</code>.
This equals <code>NULL</code> if no unequal probability variable is used.
</p>
</li>
<li> <p><code>caty_n</code> The expected sample sizes for each level of the
unequal probability grouping variable per stratum. This equals
<code>NULL</code> when <code>seltype</code> is not <code>"unequal"</code>.
</p>
</li>
<li> <p><code>aux_var</code> The name of the proportional probability (auxiliary) variable in <code>sframe</code>.
This equals <code>NULL</code> if no proportional probability variable is used.
</p>
</li>
<li> <p><code>legacy</code> A logical variable indicating whether legacy sites
were included in the sample.
</p>
</li>
<li> <p><code>legacy_stratum_var</code> The name of the stratification variable in <code>legacy_sites</code>.
Omitted if legacy sites are not used. This equals <code>NULL</code> if legacy sites were used but
no stratification variable is used.
</p>
</li>
<li> <p><code>legacy_caty_var</code> The name of the unequal probability variable in <code>legacy_sites</code>.
Omitted if legacy sites are not used. This equals <code>NULL</code> if legacy sites were used but
no unequal probability variable is used.
</p>
</li>
<li> <p><code>legacy_aux_var</code> The name of the proportional probability (auxiliary)
variable in <code>legacy_sites</code>.
Omitted if legacy sites are not used. This equals <code>NULL</code> if legacy sites
were used but no proportional probability variable is used.
</p>
</li>
<li> <p><code>mindis</code> The minimum distance requirement desired. This
is <code>NULL</code> when no minimum distance requirement was applied.
</p>
</li>
<li> <p><code>n_over</code> The reverse hierarchically ordered replacement
site sample sizes per stratum. If <code>seltype</code> is <code>unequal</code>,
this represents the expected sample sizes. This is <code>NULL</code>
when no reverse hierarchically ordered replacement sites were selected.
</p>
</li>
<li> <p><code>n_near</code> The number of nearest neighbor replacement sites
desired. This is <code>NULL</code> when no nearest neighbor replacement
sites were selected.
</p>
</li></ul>

</li></ul>

<p>When non-<code>NULL</code>, the <code>sites_legacy</code>, <code>sites_base</code>,
<code>sites_over</code>, and <code>sites_near</code> objects contain the original columns
in <code>sframe</code> and include a few additional columns. These additional columns
are
</p>

<ul>
<li> <p><code>siteID</code> A site identifier (as named using the <code>DesignID</code>
and <code>SiteBegin</code> arguments to <code>grts()</code>).
</p>
</li>
<li> <p><code>siteuse</code> Whether the site is a legacy site (<code>Legacy</code>), base
site (<code>Base</code>), reverse hierarchically ordered replacement site
(<code>Over</code>), or nearest neighbor replacement site (<code>Near</code>).
</p>
</li>
<li> <p><code>replsite</code> The replacement site ordering. <code>replsite</code> is
<code>None</code> if the site is not a replacement site, <code>Next</code> if it is
the next reverse hierarchically ordered replacement site to use, or
<code>Near_</code>, where the word following <code>_</code> indicates the ordering of sites closest to
the originally sampled site.
</p>
</li>
<li> <p><code>lon_WGS84</code> Longitude coordinates using the WGS84 coordinate
system (EPSG:4326). Only given if coordinates are projected.
</p>
</li>
<li> <p><code>lat_WGS84</code> Latitude coordinates using the WGS84 coordinate
system (EPSG:4326). Only given if coordinates are projected.
</p>
</li>
<li> <p><code>X</code> Longitude coordinates using the provided coordinate
system. Only given if coordinates are not projected (i.e., they are geographic or NA).
</p>
</li>
<li> <p><code>Y</code> Latitude coordinates using the provided coordinate
system. Only given if coordinates are not projected (i.e., they are geographic or NA).
</p>
</li>
<li> <p><code>stratum</code> A stratum indicator. <code>stratum</code> is <code>None</code>
if the sampling design was unstratified. If the sampling design was <code>stratified</code>,
<code>stratum</code> indicates the stratum.
</p>
</li>
<li> <p><code>wgt</code> The design weight.
</p>
</li>
<li> <p><code>ip</code> The site's original inclusion probability (the reciprocal)
of (<code>wgt</code>).
</p>
</li>
<li> <p><code>caty</code> An unequal probability grouping indicator. <code>caty</code>
is <code>None</code> if the sampling design did not use unequal inclusion probabilities.
If the sampling design did use unequal inclusion probabilities, <code>caty</code>
indicates the unequal probability level.
</p>
</li>
<li> <p><code>aux</code> The auxiliary proportional probability variable. This
column is only returned if <code>seltype</code> was <code>proportional</code> in the
original sampling design.
</p>
</li></ul>

<p>If any columns in <code>sframe</code> contain these names, those columns
from <code>sframe</code> will be automatically prefixed with <code>sframe_</code>
in the <code>sites</code> object. When output is printed, a summary of site counts by
the levels in <code>stratum_var</code> and <code>caty_var</code> is shown.
</p>


<h3>Author(s)</h3>

<p>Tony Olsen <a href="mailto:olsen.tony@epa.gov">olsen.tony@epa.gov</a>
</p>


<h3>See Also</h3>


<dl>
<dt><code><a href="#topic+grts">grts</a></code></dt><dd><p> to select a sample that is spatially balanced</p>
</dd>
</dl>



<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
samp &lt;- irs(NE_Lakes, n_base = 100)
print(samp)
strata_n &lt;- c(low = 25, high = 30)
samp_strat &lt;- irs(NE_Lakes, n_base = strata_n, stratum_var = "ELEV_CAT")
print(samp_strat)
samp_over &lt;- irs(NE_Lakes, n_base = 30, n_over = 5)
print(samp_over)

## End(Not run)
</code></pre>

<hr>
<h2 id='Lake_Ontario'>Lake Ontario data</h2><span id='topic+Lake_Ontario'></span>

<h3>Description</h3>

<p>An <code>sf</code> MULTIPOLYGON object of 187 polygons consisting
of shore segments in Lake Ontario.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Lake_Ontario
</code></pre>


<h3>Format</h3>

<p>187 rows and 5 variables:
</p>

<dl>
<dt><code>COUNTRY</code></dt><dd><p> Country.</p>
</dd>
<dt><code>RSRC_CLASS</code></dt><dd><p> Bay class.</p>
</dd>
<dt><code>PSTL_CODE</code></dt><dd><p> Postal code.</p>
</dd>
<dt><code>AREA_SQKM</code></dt><dd><p> Area in square kilometers</p>
</dd>
<dt><code>geometry</code></dt><dd><p> MULTIPOLYGON geometry using the NAD83 / Conus Albers
coordinate reference system (EPSG: 5070).</p>
</dd>
</dl>


<hr>
<h2 id='localmean_cov'>Internal Function: Variance-Covariance Matrix Based on Local Mean Estimator</h2><span id='topic+localmean_cov'></span>

<h3>Description</h3>

<p>This function calculates the variance-covariance matrix using the local mean
estimator.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>localmean_cov(zmat, weight_1st)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="localmean_cov_+3A_zmat">zmat</code></td>
<td>
<p>Matrix of weighted response values or weighted residual values
for the sample points.</p>
</td></tr>
<tr><td><code id="localmean_cov_+3A_weight_1st">weight_1st</code></td>
<td>
<p>List from the local mean weight function containing two
elements: a matrix named <code>ij</code> composed of the index values of neighboring
points and a vector named <code>gwt</code> composed of weights.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The local mean estimator of the variance-covariance matrix.
</p>


<h3>Author(s)</h3>

<p>Tom Kincaid <a href="mailto:Kincaid.Tom@epa.gov">Kincaid.Tom@epa.gov</a>
</p>

<hr>
<h2 id='localmean_var'>Internal Function: Local Mean Variance Estimator</h2><span id='topic+localmean_var'></span>

<h3>Description</h3>

<p>This function calculates the local mean variance estimator.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>localmean_var(z, weight_1st)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="localmean_var_+3A_z">z</code></td>
<td>
<p>Vector of weighted response values or weighted residual values for
the sample points.</p>
</td></tr>
<tr><td><code id="localmean_var_+3A_weight_1st">weight_1st</code></td>
<td>
<p>List from the local mean weight function containing two
elements: a matrix named <code>ij</code> composed of the index values of neighboring
points and a vector named <code>gwt</code> composed of weights.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The local mean estimator of the variance.
</p>


<h3>Author(s)</h3>

<p>Tom Kincaid <a href="mailto:Kincaid.Tom@epa.gov">Kincaid.Tom@epa.gov</a>
</p>

<hr>
<h2 id='localmean_weight'>Internal Function: Local Mean Variance Neighbors and Weights</h2><span id='topic+localmean_weight'></span>

<h3>Description</h3>

<p>This function calculates the index values of neighboring points and
associated weights required by the local mean variance estimator.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>localmean_weight(x, y, prb, nbh = 4)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="localmean_weight_+3A_x">x</code></td>
<td>
<p>Vector of x-coordinates for location of the sample points.</p>
</td></tr>
<tr><td><code id="localmean_weight_+3A_y">y</code></td>
<td>
<p>Vector of y-coordinates for location of the sample points.</p>
</td></tr>
<tr><td><code id="localmean_weight_+3A_prb">prb</code></td>
<td>
<p>Vector of inclusion probabilities for the sample points.</p>
</td></tr>
<tr><td><code id="localmean_weight_+3A_nbh">nbh</code></td>
<td>
<p>Number of neighboring points to use in the calculations.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>If ginv fails to return valid output, a NULL object.  Otherwise, a
list containing two elements: a matrix named <code>ij</code> composed of the
index values of neighboring points and a vector named <code>gwt</code>
composed of weights.
</p>


<h3>Author(s)</h3>

<p>Tom Kincaid <a href="mailto:Kincaid.Tom@epa.gov">Kincaid.Tom@epa.gov</a>
</p>

<hr>
<h2 id='NE_Lakes'>New England Lakes data</h2><span id='topic+NE_Lakes'></span>

<h3>Description</h3>

<p>An <code>sf</code> POINT object of 195 lakes in the Northeastern
United States.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>NE_Lakes
</code></pre>


<h3>Format</h3>

<p>195 rows and 5 variables:
</p>

<dl>
<dt><code>AREA</code></dt><dd><p> Lake area in hectares.</p>
</dd>
<dt><code>AREA_CAT</code></dt><dd><p> Lake area categories based on a hectare cutoff.</p>
</dd>
<dt><code>ELEV</code></dt><dd><p> Elevation in meters.</p>
</dd>
<dt><code>ELEV_CAT</code></dt><dd><p> Elevation categories based on a meter cutoff.</p>
</dd>
<dt><code>geometry</code></dt><dd><p> POINT geometry using the NAD83 / Conus Albers
coordinate reference system (EPSG: 5070).</p>
</dd>
</dl>


<hr>
<h2 id='NE_Lakes_df'>New England Lakes data (as a data frame)</h2><span id='topic+NE_Lakes_df'></span>

<h3>Description</h3>

<p>An data frame of 195 lakes in the Northeastern
United States.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>NE_Lakes_df
</code></pre>


<h3>Format</h3>

<p>195 rows and 6 variables:
</p>

<dl>
<dt><code>AREA</code></dt><dd><p> Lake area in hectares.</p>
</dd>
<dt><code>AREA_CAT</code></dt><dd><p> Lake area categories based on a hectare cutoff.</p>
</dd>
<dt><code>ELEV</code></dt><dd><p> Elevation in meters.</p>
</dd>
<dt><code>ELEV_CAT</code></dt><dd><p> Elevation categories based on a meter cutoff.</p>
</dd>
<dt><code>XCOORD</code></dt><dd><p> x-coordinate using the WGS 84 coordinate reference system
(EPSG: 4326)</p>
</dd>
<dt><code>YCOORD</code></dt><dd><p> y-coordinate using WGS 84 coordinate reference system
(EPSG: 4326)</p>
</dd>
</dl>


<hr>
<h2 id='NE_Lakes_Legacy'>New England Lakes legacy data</h2><span id='topic+NE_Lakes_Legacy'></span>

<h3>Description</h3>

<p>An <code>sf</code> POINT object of 5 legacy sites for the NE Lakes data
</p>


<h3>Usage</h3>

<pre><code class='language-R'>NE_Lakes_Legacy
</code></pre>


<h3>Format</h3>

<p>5 rows and 5 variables:
</p>

<dl>
<dt><code>AREA</code></dt><dd><p> Lake area in hectares.</p>
</dd>
<dt><code>AREA_CAT</code></dt><dd><p> Lake area categories based on a hectare cutoff.</p>
</dd>
<dt><code>ELEV</code></dt><dd><p> Elevation in meters.</p>
</dd>
<dt><code>ELEV_CAT</code></dt><dd><p> Elevation categories based on a meter cutoff.</p>
</dd>
<dt><code>geometry</code></dt><dd><p> POINT geometry using the NAD83 / Conus Albers
coordinate reference system (EPSG: 5070).</p>
</dd>
</dl>


<hr>
<h2 id='NLA_PNW'>NLA PNW data</h2><span id='topic+NLA_PNW'></span>

<h3>Description</h3>

<p>An <code>sf</code> POINT object of 96 lakes in the Pacific Northwest Region of the United
States during the year 2017, from a subset of the Environmental
Protection Agency's &quot;National Lakes Assessment.&quot;
</p>


<h3>Usage</h3>

<pre><code class='language-R'>NLA_PNW
</code></pre>


<h3>Format</h3>

<p>96 rows and 9 variables:
</p>

<dl>
<dt><code>SITE_ID</code></dt><dd><p> A unique lake identifier.</p>
</dd>
<dt><code>WEIGHT</code></dt><dd><p> The sampling design weight.</p>
</dd>
<dt><code>URBAN</code></dt><dd><p> Urban category.</p>
</dd>
<dt><code>STATE</code></dt><dd><p> State name.</p>
</dd>
<dt><code>BMMI</code></dt><dd><p> Benthic MMI value.</p>
</dd>
<dt><code>BMMI_COND</code></dt><dd><p> Benthic MMI condition categories.</p>
</dd>
<dt><code>PHOS_COND</code></dt><dd><p> Phosphorus condition categories.</p>
</dd>
<dt><code>NITR_COND</code></dt><dd><p> Nitrogen condition categories.</p>
</dd>
<dt><code>geometry</code></dt><dd><p> POINT geometry using the NAD83 / Conus Albers
coordinate reference system (EPSG: 5070).</p>
</dd>
</dl>


<hr>
<h2 id='NRSA_EPA7'>NRSA EPA7 data</h2><span id='topic+NRSA_EPA7'></span>

<h3>Description</h3>

<p>An <code>sf</code> POINT object of 353 stream segments in the Central
United States during the years 2008 and 2013, from a subset of the Environmental
Protection Agency's &quot;National Rivers and Streams Assessment.&quot;
</p>


<h3>Usage</h3>

<pre><code class='language-R'>NRSA_EPA7
</code></pre>


<h3>Format</h3>

<p>353 rows and 10 variables:
</p>

<dl>
<dt><code>SITE_ID</code></dt><dd><p> A unique site identifier.</p>
</dd>
<dt><code>YEAR</code></dt><dd><p> Year of design cycle.</p>
</dd>
<dt><code>WEIGHT</code></dt><dd><p> Sampling design weights.</p>
</dd>
<dt><code>ECOREGION</code></dt><dd><p> Ecoregion.</p>
</dd>
<dt><code>STATE</code></dt><dd><p> State name.</p>
</dd>
<dt><code>BMMI</code></dt><dd><p> Benthic MMI value.</p>
</dd>
<dt><code>BMMI_COND</code></dt><dd><p> Benthic MMI categories.</p>
</dd>
<dt><code>PHOS_COND</code></dt><dd><p> Phosphorus condition categories.</p>
</dd>
<dt><code>NITR_COND</code></dt><dd><p> Nitrogen condition categories.</p>
</dd>
<dt><code>geometry</code></dt><dd><p> POINT geometry using the NAD83 / Conus Albers
coordinate reference system (EPSG: 5070).</p>
</dd>
</dl>


<hr>
<h2 id='pd_summary'>Summary characteristics of a panel revisit design</h2><span id='topic+pd_summary'></span>

<h3>Description</h3>

<p>Panel revisit design characteristics are summarized: number of panels, number
of time periods, total number of sample events for the revisit design, total
number of sample events for each panel, total number of sample events for
each time period and cumulative number of unique units sampled by time
periods.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pd_summary(object, visitdsgn = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pd_summary_+3A_object">object</code></td>
<td>
<p>Two-dimensional array from <code>panel_design</code> and dimnames specifying revisit
panel design. Typically, array is output from <code>revisit_dsgn</code>, <code>revisit_bibd</code> or
<code>revisit_rand</code> functions.</p>
</td></tr>
<tr><td><code id="pd_summary_+3A_visitdsgn">visitdsgn</code></td>
<td>
<p>Two-dimensional array with same dimensions as <code>paneldsgn</code>
specifying the number of times a sample unit is sampled at each time
period. Default is <code>visitdsgn=NULL</code>, where default assumes that a sample unit
will be sampled only once at each time period.</p>
</td></tr>
<tr><td><code id="pd_summary_+3A_...">...</code></td>
<td>
<p>Additional arguments (S3 consistency)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The revisit panel design and the visit design (if present) are
summarized. Summaries can be useful to know the effort required to complete
the survey design. See the values returned for the summaries that are
produced.
</p>


<h3>Value</h3>

<p>List of six elements.
</p>

<dl>
<dt><code>n_panel</code></dt><dd><p> number of panels in revisit design</p>
</dd>
<dt><code>n_period</code></dt><dd><p> number of time periods in revisit design</p>
</dd>
<dt><code>n_total</code></dt><dd><p> total number of sample events across all panels and all
time periods, accounting for <code>visitdsgn</code>, that will be sampled in the revisit
design</p>
</dd>
<dt><code>n_periodunit</code></dt><dd><p> vector of the number of time periods a unit will be
sampled in each panel</p>
</dd>
<dt><code>n_unitpnl</code></dt><dd><p> vector of the number of sample units, accounting for
<code>visitdsgn</code>, that will be sampled in each panel</p>
</dd>
<dt><code>n_unitperiod</code></dt><dd><p> vector of the number of sample units, accounting for
<code>visitdsgn</code>, that will be sampled during each time period</p>
</dd>
<dt><code>ncum_unit</code></dt><dd><p> vector of the cumulative number of unique units that will
be sampled in time periods up to and including the current time period.</p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>Tony Olsen <a href="mailto:Olsen.Tony@epa.gov">Olsen.Tony@epa.gov</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Serially alternating panel revisit design summary
sa_dsgn &lt;- revisit_dsgn(20, panels = list(SA60N = list(
  n = 60, pnl_dsgn = c(1, 4),
  pnl_n = NA, start_option = "None"
)), begin = 1)
pd_summary(sa_dsgn)
# Add visit design where first panel is sampled twice at every time period
sa_visit &lt;- sa_dsgn
sa_visit[sa_visit &gt; 0] &lt;- 1
sa_visit[1, sa_visit[1, ] &gt; 0] &lt;- 2
pd_summary(sa_dsgn, sa_visit)
</code></pre>

<hr>
<h2 id='plot'>Plot sampling frames, design sites, and analysis data.</h2><span id='topic+plot'></span><span id='topic+plot.sp_frame'></span><span id='topic+plot.sp_design'></span>

<h3>Description</h3>

<p>This function plots sampling frames, design sites, and analysis data.
If the left-hand side of the formula is empty, plots
are of the distributions of the right-hand side variables. If the left-hand side
of the variable contains a variable, plots are of the left-hand size variable
for each level of each right-hand side variable.
This function is largely built on <code>plot.sf()</code>, and all spsurvey plotting
methods can supply additional arguments to <code>plot.sf()</code>. For more information on
plotting in <code>sf</code>, run <code>?sf::plot.sf()</code>. Equivalent to <code>sp_plot()</code>; both
are currently maintained for backwards compatibility.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'sp_frame'
plot(
  x,
  formula = ~1,
  xcoord,
  ycoord,
  crs,
  var_args = NULL,
  varlevel_args = NULL,
  geom = FALSE,
  onlyshow = NULL,
  fix_bbox = TRUE,
  ...
)

## S3 method for class 'sp_design'
plot(
  x,
  sframe = NULL,
  formula = ~siteuse,
  siteuse = NULL,
  var_args = NULL,
  varlevel_args = NULL,
  geom = FALSE,
  onlyshow = NULL,
  fix_bbox = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot_+3A_x">x</code></td>
<td>
<p>An object to plot. When plotting sampling frames an <code>sf</code> object
given the appropriate class using <code>sp_frame</code>.
When plotting design sites, an object created by <code>grts()</code> or
<code>irs()</code> (which has class <code>sp_design</code>). When plotting analysis data, a data frame
or an <code>sf</code> object given the appropriate class using <code>sp_frame</code>.</p>
</td></tr>
<tr><td><code id="plot_+3A_formula">formula</code></td>
<td>
<p>A formula. One-sided formulas are used to summarize the
distribution of numeric or categorical variables. For one-sided formulas,
variable names are placed to the right of <code>~</code> (a right-hand side variable).
Two sided formulas are
used to summarize the distribution of a left-hand side variable
for each level of each right-hand side categorical variable in the formula.
Note that only for two-sided formulas are numeric right-hand side variables
coerced to a categorical variables. If an intercept
is included as a right-hand side variable (whether the formula is one-sided or
two-sided), the total will also be summarized. When plotting sampling frames
or analysis data, the default formula is <code>~ 1</code>. When plotting design sites,
<code>siteuse</code> should be used in the formula, and the default formula is
<code>~ siteuse</code>.</p>
</td></tr>
<tr><td><code id="plot_+3A_xcoord">xcoord</code></td>
<td>
<p>Name of the x-coordinate (east-west) in <code>object</code> (only required if
<code>object</code> is not an <code>sf</code> object).</p>
</td></tr>
<tr><td><code id="plot_+3A_ycoord">ycoord</code></td>
<td>
<p>Name of y (north-south)-coordinate in <code>object</code> (only required if
<code>object</code> is not an <code>sf</code> object).</p>
</td></tr>
<tr><td><code id="plot_+3A_crs">crs</code></td>
<td>
<p>Projection code for <code>xcoord</code> and <code>ycoord</code> (only
required if <code>object</code> is not an <code>sf</code> object).</p>
</td></tr>
<tr><td><code id="plot_+3A_var_args">var_args</code></td>
<td>
<p>A named list. The name of each list element corresponds to a
right-hand side variable in <code>formula</code>. Values in the list are composed of
graphical arguments that are to be passed to <strong>every</strong> level of the
variable. To see all graphical arguments available, run <code>?plot.sf</code>.</p>
</td></tr>
<tr><td><code id="plot_+3A_varlevel_args">varlevel_args</code></td>
<td>
<p>A named list. The name of each list element corresponds to a
right-hand side variable in <code>formula</code>. The first element in this list
should be <code>"levels"</code> and contain all levels of the particular right-hand side variable. Subsequent
names correspond to graphical arguments that are to be passed to
the specified levels (in order) of the right-hand side variable. Values for each
graphical argument must be specified for each level of the right-hand side variable,
but applicable sf defaults will be matched by inputting the value <code>NA</code>.
To see all graphical arguments available, run <code>?plot.sf</code></p>
</td></tr>
<tr><td><code id="plot_+3A_geom">geom</code></td>
<td>
<p>Should separate geometries for each level of the right-hand
side <code>formula</code> variables be plotted? Defaults to <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="plot_+3A_onlyshow">onlyshow</code></td>
<td>
<p>A string indicating the single level of the single right-hand side
variable for which a summary is requested. This argument is only used when
a single right-hand side variable is provided.</p>
</td></tr>
<tr><td><code id="plot_+3A_fix_bbox">fix_bbox</code></td>
<td>
<p>Should the geometry bounding box be fixed across plots?
If a length-four vector with names &quot;xmin&quot;, &quot;ymin&quot;, &quot;xmax&quot;, and &quot;ymax&quot; and values
indicating bounding box edges, the bounding box will be fixed as <code>fix_bbox</code>
across plots. If <code>TRUE</code>, the bounding box will be fixed across plots as the
bounding box of <code>object</code>. If <code>FALSE</code>, the bounding box will vary across
plots according to the unique geometry for each plot. Defaults to <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="plot_+3A_...">...</code></td>
<td>
<p>Additional arguments to pass to <code>plot.sf()</code>.</p>
</td></tr>
<tr><td><code id="plot_+3A_sframe">sframe</code></td>
<td>
<p>The sampling frame (an <code>sf</code> object) to plot alongside design
sites. This argument is only used when <code>object</code> corresponds to the design sites.</p>
</td></tr>
<tr><td><code id="plot_+3A_siteuse">siteuse</code></td>
<td>
<p>A character vector of site types to include when plotting design sites.
It can only take on values <code>"sframe"</code> (sampling frame),
<code>"Legacy"</code> (for legacy sites), <code>"Base"</code> (for base sites),
<code>"Over"</code> (for <code>n_over</code> replacement sites), and <code>"Near"</code>
(for <code>n_near</code> replacement sites). The order of sites represents the
layering in the plot (e.g. <code>siteuse = c("Base", "Legacy")</code> will plot
legacy sites on top of base sites. Defaults to all non-<code>NULL</code> elements
in <code>x</code> and <code>y</code> with plot order <code>"sframe"</code>, <code>"Legacy"</code>,
<code>"Base"</code>, <code>"Over"</code>, <code>"Near"</code>.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Michael Dumelle <a href="mailto:Dumelle.Michael@epa.gov">Dumelle.Michael@epa.gov</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
data("NE_Lakes")
NE_Lakes &lt;- sp_frame(NE_Lakes)
plot(NE_Lakes, formula = ~ELEV_CAT)
sample &lt;- grts(NE_Lakes, 30)
plot(sample, NE_Lakes)

## End(Not run)
</code></pre>

<hr>
<h2 id='plot.sp_CDF'>Plot a cumulative distribution function (CDF)</h2><span id='topic+plot.sp_CDF'></span>

<h3>Description</h3>

<p>This function creates a CDF plot.  Input data for the plots is provided by a
data frame from the &quot;CDF&quot; output given by  <code>cont_analysis</code>.
Confidence limits for the CDF also are plotted. Equivalent to <code>cdf_plot()</code>; 
both are currently maintained for backwards compatibility.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'sp_CDF'
plot(
  x,
  var = NULL,
  subpop = NULL,
  subpop_level = NULL,
  units_cdf = "Percent",
  type_cdf = "Continuous",
  log = "",
  xlab = NULL,
  ylab = NULL,
  ylab_r = NULL,
  main = NULL,
  legloc = NULL,
  confcut = 0,
  conflev = 95,
  cex.main = 1.2,
  cex.legend = 1,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.sp_CDF_+3A_x">x</code></td>
<td>
<p>Data frame from the &quot;CDF&quot; output given by
<code>cont_analysis</code>.</p>
</td></tr>
<tr><td><code id="plot.sp_CDF_+3A_var">var</code></td>
<td>
<p>If <code>cdfest</code> has multiple variables in the &quot;Indicator&quot; column,
then <code>var</code> is the single variable to be plotted. The default is
<code>NULL</code>, which assumes that only one variable is in the &quot;Indicator&quot;
column of <code>cdfest</code>.</p>
</td></tr>
<tr><td><code id="plot.sp_CDF_+3A_subpop">subpop</code></td>
<td>
<p>If <code>cdfest</code> has multiple variables in the &quot;Type&quot; column,
then <code>subpop</code> is the single variable to be plotted. The default is
<code>NULL</code>, which assumes that only one variable is in the &quot;Type&quot;
column of <code>cdfest</code>.</p>
</td></tr>
<tr><td><code id="plot.sp_CDF_+3A_subpop_level">subpop_level</code></td>
<td>
<p>If <code>cdfest</code> has multiple levels of <code>subpop</code>
in the &quot;Subpopulation&quot; column,
then <code>subpop_level</code> is the single level to be plotted. The default is
<code>NULL</code>, which assumes that only one level is in the &quot;Subpopulation&quot;
column of <code>cdfest</code>.</p>
</td></tr>
<tr><td><code id="plot.sp_CDF_+3A_units_cdf">units_cdf</code></td>
<td>
<p>Indicator for the label utilized for the left side y-axis
and the values used for the left side y-axis tick marks, where &quot;Percent&quot;
means the label and values are in terms of percent of the population, and
&quot;Units&quot; means the label and values are in terms of units (count, length,
or area) of the population.  The default is &quot;Percent&quot;.</p>
</td></tr>
<tr><td><code id="plot.sp_CDF_+3A_type_cdf">type_cdf</code></td>
<td>
<p>Character string consisting of the value &quot;Continuous&quot; or
&quot;Ordinal&quot; that controls the type of CDF plot.  The default is &quot;Continuous&quot;.</p>
</td></tr>
<tr><td><code id="plot.sp_CDF_+3A_log">log</code></td>
<td>
<p>Character string consisting of the value &quot;&quot; or &quot;x&quot; that
controls whether the x axis uses the original scale (&quot;&quot;) or the base 10
logarithmic scale (&quot;x&quot;).  The default is &quot;&quot;.</p>
</td></tr>
<tr><td><code id="plot.sp_CDF_+3A_xlab">xlab</code></td>
<td>
<p>Character string providing the x-axis label.  If this argument
equals NULL, then the indicator name is used as the label.  The default is
NULL.</p>
</td></tr>
<tr><td><code id="plot.sp_CDF_+3A_ylab">ylab</code></td>
<td>
<p>Character string providing the left side y-axis label.  If
argument units_cdf equals &quot;Units&quot;, a value should be provided for this
argument.  Otherwise, the label will be &quot;Percent&quot;.  The default is
&quot;Percent&quot;.</p>
</td></tr>
<tr><td><code id="plot.sp_CDF_+3A_ylab_r">ylab_r</code></td>
<td>
<p>Character string providing the label for the right side y-axis
(and, hence, determining the values used for the right side y-axis tick
marks), where NULL means a right side y-axis is not created.  If this
argument equals &quot;Same&quot;, the right side y-axis will have the same label and
tick mark values as the left side y-axis.  If this argument equals a
character string other than &quot;Same&quot;, the right side y-axis label will be the
value provided for argument ylab_r, and the right side y-axis tick mark
values will be determined by the choice not utilized for argument
units_cdf, which means that the default value of argument units_cdf (i.e.,
&quot;Percent&quot;) will result in the right side y-axis tick mark values being
expressed  in terms of units of the population (i.e., count, length, or
area).  The default is NULL.</p>
</td></tr>
<tr><td><code id="plot.sp_CDF_+3A_main">main</code></td>
<td>
<p>Character string providing the plot title.  The default is
NULL.</p>
</td></tr>
<tr><td><code id="plot.sp_CDF_+3A_legloc">legloc</code></td>
<td>
<p>Indicator for location of the plot legend, where &quot;BR&quot; means
bottom right, &quot;BL&quot; means bottom left, &quot;TR&quot; means top right, &quot;TL&quot; means
top left, and NULL means no legend.  The default is NULL.</p>
</td></tr>
<tr><td><code id="plot.sp_CDF_+3A_confcut">confcut</code></td>
<td>
<p>Numeric value that controls plotting confidence limits at
the CDF extremes.  Confidence limits for CDF values (percent scale) less
than confcut or greater than 100 minus confcut are not plotted.  A value of
zero means confidence limits are plotted for the complete range of the CDF.
The default is 0.</p>
</td></tr>
<tr><td><code id="plot.sp_CDF_+3A_conflev">conflev</code></td>
<td>
<p>Numeric value of the confidence level used for confidence
limits. The default is 95.</p>
</td></tr>
<tr><td><code id="plot.sp_CDF_+3A_cex.main">cex.main</code></td>
<td>
<p>Expansion factor for the plot title.  The default is 1.2.</p>
</td></tr>
<tr><td><code id="plot.sp_CDF_+3A_cex.legend">cex.legend</code></td>
<td>
<p>Expansion factor for the legend title. The default is 1.</p>
</td></tr>
<tr><td><code id="plot.sp_CDF_+3A_...">...</code></td>
<td>
<p>Additional arguments passed to the <code>plot.default</code> function
(aside from those already used and <code>ylim</code>).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A plot of a variable's CDF estimates associated confidence limits.
</p>


<h3>Author(s)</h3>

<p>Tom Kincaid <a href="mailto:Kincaid.Tom@epa.gov">Kincaid.Tom@epa.gov</a>
</p>


<h3>See Also</h3>


<dl>
<dt><code><a href="#topic+cont_cdfplot">cont_cdfplot</a></code></dt><dd><p>for creating a PDF file containing CDF
plots</p>
</dd>
<dt><code><a href="#topic+cont_cdftest">cont_cdftest</a></code></dt><dd><p>for CDF hypothesis testing</p>
</dd>
</dl>



<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
dframe &lt;- data.frame(
  siteID = paste0("Site", 1:100),
  wgt = runif(100, 10, 100),
  xcoord = runif(100),
  ycoord = runif(100),
  stratum = rep(c("Stratum1", "Stratum2"), 50),
  ContVar = rnorm(100, 10, 1),
  All_Sites = rep("All Sites", 100),
  Resource_Class = rep(c("Good", "Poor"), c(55, 45))
)
myvars &lt;- c("ContVar")
mysubpops &lt;- c("All_Sites", "Resource_Class")
mypopsize &lt;- data.frame(
  Resource_Class = c("Good", "Poor"),
  Total = c(4000, 1500)
)
myanalysis &lt;- cont_analysis(dframe,
  vars = myvars, subpops = mysubpops,
  siteID = "siteID", weight = "wgt", xcoord = "xcoord", ycoord = "ycoord",
  stratumID = "stratum", popsize = mypopsize
)
keep &lt;- with(myanalysis$CDF, Type == "Resource_Class" &amp;
  Subpopulation == "Good")
par(mfrow = c(2, 1))
plot(myanalysis$CDF[keep, ],
  xlab = "ContVar",
  ylab = "Percent of Stream Length", ylab_r = "Stream Length (km)",
  main = "Estimates for Resource Class: Good"
)
plot(myanalysis$CDF[keep, ],
  xlab = "ContVar",
  ylab = "Percent of Stream Length", ylab_r = "Same",
  main = "Estimates for Resource Class: Good"
)

## End(Not run)
</code></pre>

<hr>
<h2 id='power_dsgn'>Power calculation for multiple panel designs</h2><span id='topic+power_dsgn'></span>

<h3>Description</h3>

<p>Calculates the power for trend detection for one or more variables, for one
or more panel designs, for one or more linear trends, and for one or more
significance levels.  The panel designs create a covariance model where the
model includes variance components for units, periods, the interaction of
units and periods, and the residual (or index) variance.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>power_dsgn(
  ind_names,
  ind_values,
  unit_var,
  period_var,
  unitperiod_var,
  index_var,
  unit_rho = 1,
  period_rho = 0,
  paneldsgn,
  nrepeats = NULL,
  trend_type = "mean",
  ind_pct = NULL,
  ind_tail = NULL,
  trend = 2,
  alpha = 0.05
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="power_dsgn_+3A_ind_names">ind_names</code></td>
<td>
<p>Vector of indicator names</p>
</td></tr>
<tr><td><code id="power_dsgn_+3A_ind_values">ind_values</code></td>
<td>
<p>Vector of indicator mean values</p>
</td></tr>
<tr><td><code id="power_dsgn_+3A_unit_var">unit_var</code></td>
<td>
<p>Vector of variance component estimates for unit variability
for the indicators</p>
</td></tr>
<tr><td><code id="power_dsgn_+3A_period_var">period_var</code></td>
<td>
<p>Vector of variance component estimates for period
variability for the indicators</p>
</td></tr>
<tr><td><code id="power_dsgn_+3A_unitperiod_var">unitperiod_var</code></td>
<td>
<p>Vector of variance component estimates for unit by
period interaction variability for the indicators</p>
</td></tr>
<tr><td><code id="power_dsgn_+3A_index_var">index_var</code></td>
<td>
<p>Vector of variance component estimates for index (residual)
error for the indicators</p>
</td></tr>
<tr><td><code id="power_dsgn_+3A_unit_rho">unit_rho</code></td>
<td>
<p>Correlation across units. Default is <code>1</code>.</p>
</td></tr>
<tr><td><code id="power_dsgn_+3A_period_rho">period_rho</code></td>
<td>
<p>Correlation across periods. Default is <code>0</code>.</p>
</td></tr>
<tr><td><code id="power_dsgn_+3A_paneldsgn">paneldsgn</code></td>
<td>
<p>A list of panel designs each as a matrix.  Each element of
the list is a matrix with <code>dimnames</code> (dimensions: number of panels (rows) by
number of periods (columns)) containing the number of units visited for
each combination of panel and period.  Dimnames for columns must be
able to be coerced into an integer (e.g., 2016).  All designs must span the same
number of periods.  Typically, the panel designs are the output of the
function <code>revisit_dsgn</code>.</p>
</td></tr>
<tr><td><code id="power_dsgn_+3A_nrepeats">nrepeats</code></td>
<td>
<p>Either <code>NULL</code> or a list of matrices the same length as
<code>paneldsgn</code> specifying the number of revisits made to units in a panel in the
same period for each design.  Specifying <code>NULL</code> indicates that number of
revisits to units is the same for all panels and for all periods and for
all panel designs. The default is <code>NULL</code>, a single visit. Names must match
list names in <code>paneldsgn</code>.</p>
</td></tr>
<tr><td><code id="power_dsgn_+3A_trend_type">trend_type</code></td>
<td>
<p>Trend type is either <code>"mean"</code> where trend is applied as
percent trend in the indicator mean or <code>"percent"</code> where the trend is applied
as percent trend in the proportion (percent) of the distribution that is
below or above a fixed value. Default is <code>trend_type="mean"</code></p>
</td></tr>
<tr><td><code id="power_dsgn_+3A_ind_pct">ind_pct</code></td>
<td>
<p>When <code>trend_type</code> is equal to <code>"percent"</code>, a vector of the
values of the indicator fixed value that defines the percent.  Default is
NULL</p>
</td></tr>
<tr><td><code id="power_dsgn_+3A_ind_tail">ind_tail</code></td>
<td>
<p>When trend_type is equal to <code>"percent"</code>, a character vector
with values of either <code>"lower"</code> or <code>"upper"</code> for each indicator.  <code>"lower"</code>
states that the percent is associated with the lower tail of the
distribution and <code>"upper"</code> states that the percent is associated with the
upper tail of the distribution. Default is <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="power_dsgn_+3A_trend">trend</code></td>
<td>
<p>Single value or vector of assumed percent change from
initial value in the indicator for each period. Assumes the trend is
expressed as percent per period. Note that the trend may be either positive
or negative. The default is <code>2</code>.</p>
</td></tr>
<tr><td><code id="power_dsgn_+3A_alpha">alpha</code></td>
<td>
<p>Single value or vector of significance level for linear
trend test, alpha, Type I error, level.  The default is <code>0.05</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Calculates the power for detecting a change in the mean for
different panel design structures. The model incorporates unit, period,
unit by period, and index variance components as well as correlation across
units and across periods.  See references for methods.
</p>


<h3>Value</h3>

<p>A list with components <code>trend_type</code>, <code>ind_pct</code>, <code>ind_tail</code>, trend values
across periods, periods (all periods included in one or more panel
designs), significance levels, a five-dimensional array of power
calculations (dimensions: panel, design names, periods, indicator names,
trend names, <code>alpha_names</code>), an array of indicator mean values for each trend
and the function call.
</p>


<h3>Author(s)</h3>

<p>Tony Olsen <a href="mailto:Olsen.Tony@epa.gov">Olsen.Tony@epa.gov</a>
</p>


<h3>References</h3>

<p>Urquhart, N. S., W. S. Overton, et al. (1993) Comparing sampling designs
for monitoring ecological status and trends: impact of temporal patterns.
In: <em>Statistics for the Environment.</em> V. Barnett and K. F. Turkman.
John Wiley &amp; Sons, New York, pp. 71-86.
</p>
<p>Urquhart, N. S. and T. M. Kincaid (1999). Designs for detecting trends
from repeated surveys of ecological resources. <em>Journal of
Agricultural, Biological, and Environmental Statistics</em>, <b>4(4)</b>,
404-414.
</p>
<p>Urquhart, N. S. (2012). The role of monitoring design in detecting trend in
long-term ecological monitoring studies. In: <em>Design and Analysis of
Long-term Ecological Monitoring Studies.</em> R. A. Gitzen, J. J. Millspaugh,
A. B. Cooper, and D. S. Licht (eds.). Cambridge University Press, New York,
pp. 151-173.
</p>


<h3>See Also</h3>


<dl>
<dt><code><a href="#topic+ppd_plot">ppd_plot</a></code></dt><dd><p> to plot power curves for
panel designs</p>
</dd>
</dl>



<h3>Examples</h3>

<pre><code class='language-R'># Power for rotating panel with sample size 60
power_dsgn("Variable_Name",
  ind_values = 43, unit_var = 280, period_var = 4,
  unitperiod_var = 40, index_var = 90, unit_rho = 1, period_rho = 0,
  paneldsgn = list(NoR60 = revisit_dsgn(20,
    panels = list(NoR60 = list(
      n = 60, pnl_dsgn = c(1, NA),
      pnl_n = NA, start_option = "None"
    )), begin = 1
  )),
  nrepeats = NULL, trend_type = "mean", trend = 1.0, alpha = 0.05
)
</code></pre>

<hr>
<h2 id='ppd_plot'>Plot power curves for panel designs</h2><span id='topic+ppd_plot'></span>

<h3>Description</h3>

<p>Plot power curves and relative power curves for trend detection for set of
panel designs, time periods, indicators, significance levels and trend.  Trend
may be based on percent change per period in mean or percent change in
proportion of cumulative distribution function above or below a fixed cut
point. Types of plots are combinations of standard/relative, mean/percent,
period/change and design/indicator.  Input must be be of class
powerpaneldesign and is normally the output of function power_dsgn.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ppd_plot(
  object,
  plot_type = "standard",
  trend_type = "mean",
  xaxis_type = "period",
  comp_type = "design",
  dsgns = NULL,
  indicator = NULL,
  trend = NULL,
  period = NULL,
  alpha = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ppd_plot_+3A_object">object</code></td>
<td>
<p>List object of class <code>powerpaneldesign</code>. Object provides
power calculated for a set of panel designs, set of indicators, set of
trend values, and set of alpha values. Expect input as list as output from
function <code>power_dsgn</code>.</p>
</td></tr>
<tr><td><code id="ppd_plot_+3A_plot_type">plot_type</code></td>
<td>
<p>Default is <code>"standard"</code> which plots standard power curve. If
equal to <code>"relative"</code>, then plot power of one panel design compared to one or
more other panel designs.</p>
</td></tr>
<tr><td><code id="ppd_plot_+3A_trend_type">trend_type</code></td>
<td>
<p>Character value for trend in mean (<code>"mean"</code>) or or percent
change in proportion (<code>"percent"</code>) of cumulative distribution function above
or below a fixed cut point.  Default is <code>"mean"</code>.</p>
</td></tr>
<tr><td><code id="ppd_plot_+3A_xaxis_type">xaxis_type</code></td>
<td>
<p>Character value equal to <code>"period"</code> or <code>"change"</code> which
designates the type of x-axis for power plot where power is plotted on
y-axis.  For <code>xaxis_type = "period"</code>, x-axis is periods in <code>dsgnpower</code>. If
<code>xaxis_type = "change"</code>, then x-axis is percent per period with secondary
x-axes for total percent per period and associated change in mean.
Default is <code>"period"</code>.  Note that <code>xaxis_type</code> controls how the input for
<code>"period"</code> and <code>"trend"</code> parameters is used.</p>
</td></tr>
<tr><td><code id="ppd_plot_+3A_comp_type">comp_type</code></td>
<td>
<p>Character value equal to <code>"design"</code> or <code>"indicator"</code> which
designates the type of power curve comparison that will occur on a single
plot.  If <code>comp_type = "design"</code>, then on a single plot of power curves all
panel designs specified in <code>"dsgns"</code> are plotted for a single indicator,
single trend value and single alpha.  If <code>comp_type = "indicator"</code>, then on a
single plot of power curves all indicators specified in <code>"indicator"</code> are
plotted for a single panel design, single trend value and single alpha.
Default is <code>"design"</code>.</p>
</td></tr>
<tr><td><code id="ppd_plot_+3A_dsgns">dsgns</code></td>
<td>
<p>Vector of names of panel designs that are to be plotted.  Names
must be all, or a subset of, names of designs in <code>dsgnpower</code>. Default is <code>NULL</code>
which results in only the first panel design in <code>dsgnpower</code> being used.</p>
</td></tr>
<tr><td><code id="ppd_plot_+3A_indicator">indicator</code></td>
<td>
<p>Vector of indicator names contained in <code>dsgnpower</code> that are
to be plotted.  Indicator names must be all, or a subset of, indicator
names in <code>dsgnpower</code>. Default is <code>NULL</code> which results in only the first
indicator in <code>dsgnpower</code> being used.</p>
</td></tr>
<tr><td><code id="ppd_plot_+3A_trend">trend</code></td>
<td>
<p><code>NULL</code>. A single value or vector of values contained in <code>dsgnpower</code>
that will be plotted. Values must be all, or a subset of, trend values in
<code>dsgnpower</code>. If <code>xaxis_type</code> is equal to <code>"period"</code>, then <code>NULL</code> results in maximum
trend value being used and a single value or vector of values results in a
separate plot for each value specified.  If <code>xaxis_type</code> is equal to
<code>"change"</code>, then <code>NULL</code> results in all trend values in <code>dsgnpower</code> being plotted
on x-axis and a vector of values results in all trend values in <code>dsgnpower</code>
from minimum value to maximum value specified being plotted on x-axis.</p>
</td></tr>
<tr><td><code id="ppd_plot_+3A_period">period</code></td>
<td>
<p><code>NULL</code>, a single value or vector of values contained in <code>dsgnpower</code>
that will be plotted. Values must be all, or a subset of, period values in
<code>dsgnpower</code>. If <code>xaxis_type</code> is equal to <code>"period"</code>, then <code>NULL</code> results in all
time periods in <code>dsgnpower</code> being plotted on x-axis and a vector of values
results in all period values in <code>dsgnpower</code> from minimum value to maximum
value specified being plotted on x-axis. If <code>xaxis_type</code> is equal to
<code>"change"</code>, then <code>NULL</code> results in all time periods in <code>dsgnpower</code> being plotted
in separate plots and a vector of values results in time periods specified
being plotted in separate plots.</p>
</td></tr>
<tr><td><code id="ppd_plot_+3A_alpha">alpha</code></td>
<td>
<p>A single value or vector of significance levels (as proportion,
e.g. <code>0.05</code>) contained in <code>dsgnpower</code> to used for power plots. Specifying more
than a single value results in multiple plots. Default is <code>NULL</code> which
results in the minimum significance level in <code>dsgnpower</code> being used.</p>
</td></tr>
<tr><td><code id="ppd_plot_+3A_...">...</code></td>
<td>
<p>Additional arguments (S3 consistency)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>By default the plot function produces a standard power curve at end
of each time period on the x-axis with y-axis as power. When more than one
panel design is in <code>dsgnpower</code>, the first panel design is used. When more than
one indicator is in <code>dsgnpower</code>, the first indicator is used.  When more than
one trend value is in <code>dsgnpower</code>, the maximum trend value is used. When more
than one significance level, <code>alpha</code>, is in <code>dsgnpower</code>, the minimum
significance level is used.
</p>
<p>Control of the type of plot produced is governed by <code>plot_type</code>, <code>trend_type</code>,
<code>xaxis_type</code> and <code>comp_type</code>. The number of plots produced is governed by the
number of panel designs (<code>dsgn</code>) specified, the number of indicators
(<code>indicator</code>) specified, the number of time periods (<code>period</code>) specifies, the
number of trend values (trend) specified and the number of significance
levels (<code>alpha</code>) specified.
</p>
<p>When the comparison type (<code>"comp_type"</code>) is equal to <code>"design"</code>, all power
curves specified by dsgn are plotted on the same plot.  When <code>comp_type</code> is
equal to <code>"indicator"</code>, all power curves specified by <code>"indicator"</code> are plotted
on the same plot.  Typically, no more than 4-5 power curves should be
plotted on same plot.
</p>


<h3>Value</h3>

<p>One or more power curve plots are created and plotted.  User must
specify output graphical device if more than one plot is created.  See
Devices for graphical output options.
</p>


<h3>Author(s)</h3>

<p>Tony Olsen <a href="mailto:Olsen.Tony@epa.gov">Olsen.Tony@epa.gov</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# Construct a rotating panel design with sample size of 60
R60N &lt;- revisit_dsgn(20, panels = list(R60N = list(
  n = 60, pnl_dsgn = c(1, NA),
  pnl_n = NA, start_option = "None"
)), begin = 1)

# Construct a fixed panel design with sample size of 60
F60 &lt;- revisit_dsgn(20, panels = list(F60 = list(
  n = 60, pnl_dsgn = c(1, 0),
  pnl_n = NA, start_option = "None"
)), begin = 1)

# Power for rotating panel with sample size 60
Power_tst &lt;- power_dsgn("Variable_Name",
  ind_values = 43, unit_var = 280,
  period_var = 4, unitperiod_var = 40, index_var = 90,
  unit_rho = 1, period_rho = 0, paneldsgn = list(
    R60N = R60N, F60 = F60
  ), nrepeats = NULL,
  trend_type = "mean", trend = c(1.0, 2.0), alpha = 0.05
)
ppd_plot(Power_tst)
ppd_plot(Power_tst, dsgns = c("F60", "R60N"))
ppd_plot(Power_tst, dsgns = c("F60", "R60N"), trend = 1.0)
ppd_plot(Power_tst,
  plot_type = "relative", comp_type = "design",
  trend_type = "mean", trend = c(1, 2), dsgns = c("R60N", "F60"),
  indicator = "Variable_Name"
)

## End(Not run)
</code></pre>

<hr>
<h2 id='relrisk_analysis'>Relative risk analysis</h2><span id='topic+relrisk_analysis'></span>

<h3>Description</h3>

<p>This function organizes input and output for relative risk analysis (of
categorical variables).  The analysis data,
<code>dframe</code>, can be either a data frame or a simple features (<code>sf</code>) object.  If an
<code>sf</code> object is used, coordinates are extracted from the geometry column in the
object, arguments <code>xcoord</code> and <code>ycoord</code> are assigned values
<code>"xcoord"</code> and <code>"ycoord"</code>, respectively, and the geometry column is
dropped from the object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>relrisk_analysis(
  dframe,
  vars_response,
  vars_stressor,
  response_levels = NULL,
  stressor_levels = NULL,
  subpops = NULL,
  siteID = NULL,
  weight = "weight",
  xcoord = NULL,
  ycoord = NULL,
  stratumID = NULL,
  clusterID = NULL,
  weight1 = NULL,
  xcoord1 = NULL,
  ycoord1 = NULL,
  sizeweight = FALSE,
  sweight = NULL,
  sweight1 = NULL,
  fpc = NULL,
  popsize = NULL,
  vartype = "Local",
  conf = 95,
  All_Sites = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="relrisk_analysis_+3A_dframe">dframe</code></td>
<td>
<p>Data to be analyzed (analysis data). A data frame or
<code>sf</code> object containing survey design
variables, response variables, stressor variables, and subpopulation
(domain) variables.</p>
</td></tr>
<tr><td><code id="relrisk_analysis_+3A_vars_response">vars_response</code></td>
<td>
<p>Vector composed of character values that identify the
names of response variables in <code>dframe</code>. Each response
variable must have two category values (levels), where one level is
associated with poor condition and the other level is associated with good
condition.</p>
</td></tr>
<tr><td><code id="relrisk_analysis_+3A_vars_stressor">vars_stressor</code></td>
<td>
<p>Vector composed of character values that identify the
names of stressor variables in <code>dframe</code>. Each stressor
variable must have two category values (levels), where one level is
associated with poor condition and the other level is associated with good
condition.</p>
</td></tr>
<tr><td><code id="relrisk_analysis_+3A_response_levels">response_levels</code></td>
<td>
<p>List providing the category values (levels) for each
element in the <code>vars_response</code> argument.  Each element in the list
must contain two values, where the first value identifies poor condition,
and the second value identifies good condition.  This argument must be
named and must be the same length as argument <code>vars_response</code>.  Names
for this argument must match the values in the <code>vars_response</code>
argument. If this argument equals NULL, then a named list is created that
contains the values <code>"Poor"</code> and <code>"Good"</code> for the first and
second levels, respectively, of each element in the <code>vars_response</code>
argument and that uses values in the <code>vars_response</code> argument as names
for the list.  If <code>response_levels</code> is provided without names,
then the names of <code>response_levels</code> are set to <code>vars_response</code>.
The default value is NULL.</p>
</td></tr>
<tr><td><code id="relrisk_analysis_+3A_stressor_levels">stressor_levels</code></td>
<td>
<p>List providing the category values (levels) for each
element in the <code>vars_stressor</code> argument.  Each element in the list
must contain two values, where the first value identifies poor condition,
and the second value identifies good condition.  This argument must be
named and must be the same length as argument <code>vars_stressor</code>.  Names
for this argument must match the values in the <code>vars_stressor</code>
argument. If this argument equals NULL, then a named list is created that
contains the values <code>"Poor"</code> and <code>"Good"</code> for the first and
second levels, respectively, of each element in the <code>vars_stressor</code>
argument and that uses values in the <code>vars_stressor</code> argument as names
for the list.  If <code>stressor_levels</code> is provided without names,
then the names of <code>stressor_levels</code> are set to <code>vars_stressor</code>. 
The default value is NULL.</p>
</td></tr>
<tr><td><code id="relrisk_analysis_+3A_subpops">subpops</code></td>
<td>
<p>Vector composed of character values that identify the
names of subpopulation (domain) variables in <code>dframe</code>.
If a value is not provided, the value <code>"All_Sites"</code> is assigned to the
subpops argument and a factor variable named <code>"All_Sites"</code> that takes
the value <code>"All Sites"</code> is added to <code>dframe</code>.  The
default value is <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="relrisk_analysis_+3A_siteid">siteID</code></td>
<td>
<p>Character value providing the name of the site ID variable in
<code>dframe</code>.  For a two-stage sample, the site ID variable
identifies stage two site IDs.  The default value is <code>NULL</code>, which
assumes that each row in <code>dframe</code> represents a unique site.</p>
</td></tr>
<tr><td><code id="relrisk_analysis_+3A_weight">weight</code></td>
<td>
<p>Character value providing the name of the design weight
variable in <code>dframe</code>.  For a two-stage sample, the
weight variable identifies stage two weights.  The default value is
<code>"weight"</code>.</p>
</td></tr>
<tr><td><code id="relrisk_analysis_+3A_xcoord">xcoord</code></td>
<td>
<p>Character value providing name of the x-coordinate variable in
<code>dframe</code>.  For a two-stage sample, the x-coordinate
variable identifies stage two x-coordinates.  Note that x-coordinates are
required for calculation of the local mean variance estimator.  If <code>dframe</code>
is an <code>sf</code> object, this argument is not required (as the geometry column
in <code>dframe</code> is used to find the x-coordinate). The default
value is <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="relrisk_analysis_+3A_ycoord">ycoord</code></td>
<td>
<p>Character value providing name of the y-coordinate variable in
<code>dframe</code>.  For a two-stage sample, the y-coordinate
variable identifies stage two y-coordinates.  Note that y-coordinates are
required for calculation of the local mean variance estimator.  If <code>dframe</code>
is an <code>sf</code> object, this argument is not required (as the geometry column
in <code>dframe</code> is used to find the t-coordinate). The default
value is <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="relrisk_analysis_+3A_stratumid">stratumID</code></td>
<td>
<p>Character value providing the name of the stratum ID
variable in <code>dframe</code>.  The default value is
<code>NULL</code>.</p>
</td></tr>
<tr><td><code id="relrisk_analysis_+3A_clusterid">clusterID</code></td>
<td>
<p>Character value providing the name of the cluster
(stage one) ID variable in <code>dframe</code>.  Note that cluster
IDs are required for a two-stage sample.  The default value is <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="relrisk_analysis_+3A_weight1">weight1</code></td>
<td>
<p>Character value providing the name of the stage one weight
variable in <code>dframe</code>.  The default value is
<code>NULL</code>.</p>
</td></tr>
<tr><td><code id="relrisk_analysis_+3A_xcoord1">xcoord1</code></td>
<td>
<p>Character value providing the name of the stage one
x-coordinate variable in <code>dframe</code>.  Note that x
coordinates are required for calculation of the local mean variance
estimator.  The default value is <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="relrisk_analysis_+3A_ycoord1">ycoord1</code></td>
<td>
<p>Character value providing the name of the stage one
y-coordinate variable in <code>dframe</code>.  Note that
y-coordinates are required for calculation of the local mean variance
estimator.  The default value is <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="relrisk_analysis_+3A_sizeweight">sizeweight</code></td>
<td>
<p>Logical value that indicates whether size weights should be
used during estimation, where <code>TRUE</code> uses size weights and
<code>FALSE</code> does not use size weights. To employ size weights for a
single-stage sample, a value must be supplied for argument weight.  To
employ size weights for a two-stage sample, values must be supplied for
arguments <code>weight</code> and <code>weight1</code>. The default value is
<code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="relrisk_analysis_+3A_sweight">sweight</code></td>
<td>
<p>Character value providing the name of the size weight variable
in <code>dframe</code>.  For a two-stage sample, the size weight
variable identifies stage two size weights.  The default value is
<code>NULL</code>.</p>
</td></tr>
<tr><td><code id="relrisk_analysis_+3A_sweight1">sweight1</code></td>
<td>
<p>Character value providing the name of the stage one size
weight variable in <code>dframe</code>.  The default value is
<code>NULL</code>.</p>
</td></tr>
<tr><td><code id="relrisk_analysis_+3A_fpc">fpc</code></td>
<td>
<p>Object that specifies values required for calculation of the
finite population correction factor used during variance estimation. The
object must match the survey design in terms of stratification and whether
the design is single-stage or two-stage.  For an unstratified design, the
object is a vector.  The vector is composed of a single numeric value for a
single-stage design.  For a two-stage unstratified design, the object is a
named vector containing one more than the number of clusters in the sample,
where the first item in the vector specifies the number of clusters in the
population and each subsequent item specifies the number of stage two units
for the cluster.  The name for the first item in the vector is arbitrary.
Subsequent names in the vector identify clusters and must match the cluster
IDs.  For a stratified design, the object is a named list of vectors, where
names must match the strata IDs.  For each stratum, the format of the
vector is identical to the format described for unstratified single-stage
and two-stage designs.  Note that the finite population correction factor
is not used with the local mean variance estimator.
</p>
<p>Example fpc for a single-stage unstratified survey design:
</p>
<p><code style="white-space: pre;">&#8288;fpc &lt;- 15000&#8288;</code>
</p>
<p>Example fpc for a single-stage stratified survey design:
</p>
<p><code style="white-space: pre;">&#8288;fpc &lt;- list(
    Stratum_1 = 9000,
    Stratum_2 = 6000)
   &#8288;</code>
</p>
<p>Example fpc for a two-stage unstratified survey design:
</p>
<p><code style="white-space: pre;">&#8288;fpc &lt;- c(
    Ncluster = 150,
    Cluster_1 = 150,
    Cluster_2 = 75,
    Cluster_3 = 75,
    Cluster_4 = 125,
    Cluster_5 = 75)
  &#8288;</code>
</p>
<p>Example fpc for a two-stage stratified survey design:
</p>
<p><code style="white-space: pre;">&#8288;fpc &lt;- list(
    Stratum_1 = c(
      Ncluster_1 = 100,
      Cluster_1 = 125,
      Cluster_2 = 100,
      Cluster_3 = 100,
      Cluster_4 = 125,
      Cluster_5 = 50),
    Stratum_2 = c(
      Ncluster_2 = 50,
      Cluster_1 = 75,
      Cluster_2 = 150,
      Cluster_3 = 75,
      Cluster_4 = 75,
      Cluster_5 = 125))
  &#8288;</code></p>
</td></tr>
<tr><td><code id="relrisk_analysis_+3A_popsize">popsize</code></td>
<td>
<p>Object that provides values for the population argument of the
<code>calibrate</code> or <code>postStratify</code> functions in the survey package. If
a value is provided for popsize, then either the <code>calibrate</code> or
<code>postStratify</code> function is used to modify the survey design object
that is required by functions in the survey package.  Whether to use the
<code>calibrate</code> or <code>postStratify</code> function is dictated by the format
of popsize, which is discussed below.  Post-stratification adjusts the
sampling and replicate weights so that the joint distribution of a set of
post-stratifying variables matches the known population joint distribution.
Calibration, generalized raking, or GREG estimators generalize
post-stratification and raking by calibrating a sample to the marginal
totals of variables in a linear regression model. For the <code>calibrate</code>
function, the object is a named list, where the names identify factor
variables in <code>dframe</code>.  Each element of the list is a
named vector containing the population total for each level of the
associated factor variable.  For the <code>postStratify</code> function, the
object is either a data frame, table, or xtabs object that provides the
population total for all combinations of selected factor variables in the
<code>dframe</code> data frame.  If a data frame is used for <code>popsize</code>, the
variable containing population totals must be the last variable in the data
frame.  If a table is used for <code>popsize</code>, the table must have named
<code>dimnames</code> where the names identify factor variables in the
<code>dframe</code> data frame.  If the popsize argument is equal to <code>NULL</code>,
then neither calibration nor post-stratification is performed.  The default
value is <code>NULL</code>.
</p>
<p>Example popsize for calibration:
</p>
<p><code style="white-space: pre;">&#8288;popsize &lt;- list(
    Ecoregion = c(
      East = 750,
      Central = 500,
      West = 250),
    Type = c(
      Streams = 1150,
      Rivers = 350))
  &#8288;</code>
</p>
<p>Example popsize for post-stratification using a data frame:
</p>
<p><code style="white-space: pre;">&#8288;popsize &lt;- data.frame(
    Ecoregion = rep(c("East", "Central", "West"),
      rep(2, 3)),
    Type = rep(c("Streams", "Rivers"), 3),
    Total = c(575, 175, 400, 100, 175, 75))
  &#8288;</code>
</p>
<p>Example popsize for post-stratification using a table:
</p>
<p><code style="white-space: pre;">&#8288;popsize &lt;- with(MySurveyFrame,
    table(Ecoregion, Type))&#8288;</code>
</p>
<p>Example popsize for post-stratification using an xtabs object:
</p>
<p><code style="white-space: pre;">&#8288;popsize &lt;- xtabs(~Ecoregion + Type,
    data = MySurveyFrame)&#8288;</code></p>
</td></tr>
<tr><td><code id="relrisk_analysis_+3A_vartype">vartype</code></td>
<td>
<p>Character value providing the choice of the variance
estimator, where <code>"Local"</code> indicates the local mean estimator and <code>"SRS"</code> indicates the
simple random sampling estimator.  The default value is <code>"Local"</code>.</p>
</td></tr>
<tr><td><code id="relrisk_analysis_+3A_conf">conf</code></td>
<td>
<p>Numeric value providing the Gaussian-based confidence level.  The default value
is <code>95</code>.</p>
</td></tr>
<tr><td><code id="relrisk_analysis_+3A_all_sites">All_Sites</code></td>
<td>
<p>A logical variable used when <code>subpops</code> is not
<code>NULL</code>. If <code>All_Sites</code> is <code>TRUE</code>, then alongside the
subpopulation output, output for all sites (ignoring subpopulations) is
returned for each variable in <code>vars</code>. If <code>All_Sites</code> is
<code>FALSE</code>, then alongside the subpopulation output, output for all sites
(ignoring subpopulations) is not returned for each variable in <code>vars</code>.
The default is <code>FALSE</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The analysis results. A data frame of population estimates for all combinations of
subpopulations, categories within each subpopulation, response variables,
and categories within each response variable.  Estimates are provided for
proportion and size of the population plus standard error, margin of error,
and confidence interval estimates. The data frame contains the following
variables:
</p>

<dl>
<dt>Type</dt><dd><p>subpopulation (domain) name</p>
</dd>
<dt>Subpopulation</dt><dd><p>subpopulation name within a domain</p>
</dd>
<dt>Response</dt><dd><p>response variable</p>
</dd>
<dt>Stressor</dt><dd><p>stressor variable</p>
</dd>
<dt>nResp</dt><dd><p>sample size</p>
</dd>
<dt>Estimate</dt><dd><p>relative risk estimate</p>
</dd>
<dt>Estimate_num</dt><dd><p>relative risk numerator estimate</p>
</dd>
<dt>Estimate_denom</dt><dd><p>relative risk denominator estimate</p>
</dd>
<dt>StdError</dt><dd><p>relative risk standard error</p>
</dd>
<dt>MarginofError</dt><dd><p>relative risk margin of error</p>
</dd>
<dt>LCBxxPct</dt><dd><p>xx% (default 95%) lower confidence bound</p>
</dd>
<dt>UCBxxPct</dt><dd><p>xx% (default 95%) upper confidence bound</p>
</dd>
<dt>WeightTotal</dt><dd><p>sum of design weights</p>
</dd>
<dt>Count_RespPoor_StressPoor</dt><dd><p>number of observations in the poor response and poor stressor group</p>
</dd>
<dt>Count_RespPoor_StressGood</dt><dd><p>number of observations in the poor response and good stressor group</p>
</dd>
<dt>Count_RespGood_StressPoor</dt><dd><p>number of observations in the good response and poor stressor group</p>
</dd>
<dt>Count_RespGood_StressGood</dt><dd><p>number of observations in the good response and good stressor group</p>
</dd>
<dt>Prop_RespPoor_StressPoor</dt><dd><p>weighted proportion of observations in the poor response and poor stressor group</p>
</dd>
<dt>Prop_RespPoor_StressGood</dt><dd><p>weighted proportion of observations in the poor response and good stressor group</p>
</dd>
<dt>Prop_RespGood_StressPoor</dt><dd><p>weighted proportion of observations in the good response and poor stressor group</p>
</dd>
<dt>Prop_RespGood_StressGood</dt><dd><p>weighted proportion of observations in the good response and good stressor group</p>
</dd>
</dl>



<h3>Details</h3>

<p>Relative risk measures the relative strength of association between
conditional probabilities defined for a response variable and a stressor
variable, where the response and stressor variables are classified as either
good (i.e., reference condition) or poor (i.e., different from reference
condition). Relative risk is defined as the ratio of two conditional
probabilities.  The numerator of the ratio is the probability that the
response variable is in poor condition given that the stressor variable is in
poor condition.   The denominator of the ratio is the probability that the
response variable is in poor condition given that the stressor variable is in
good condition. A relative risk value equal to one indicates that the
response variable is independent of the stressor variable.  Relative risk
values greater than one measure the extent to which poor condition of the
stressor variable is associated with poor condition of the response variable.
</p>


<h3>Author(s)</h3>

<p>Tom Kincaid <a href="mailto:Kincaid.Tom@epa.gov">Kincaid.Tom@epa.gov</a>
</p>


<h3>See Also</h3>


<dl>
<dt><code><a href="#topic+attrisk_analysis">attrisk_analysis</a></code></dt><dd><p> for attributable risk analysis</p>
</dd>
<dt><code><a href="#topic+diffrisk_analysis">diffrisk_analysis</a></code></dt><dd><p> for risk difference analysis</p>
</dd>
</dl>



<h3>Examples</h3>

<pre><code class='language-R'>dframe &lt;- data.frame(
  siteID = paste0("Site", 1:100),
  wgt = runif(100, 10, 100),
  xcoord = runif(100),
  ycoord = runif(100),
  stratum = rep(c("Stratum1", "Stratum2"), 50),
  RespVar1 = sample(c("Poor", "Good"), 100, replace = TRUE),
  RespVar2 = sample(c("Poor", "Good"), 100, replace = TRUE),
  StressVar = sample(c("Poor", "Good"), 100, replace = TRUE),
  All_Sites = rep("All Sites", 100),
  Resource_Class = rep(c("Agr", "Forest"), c(55, 45))
)
myresponse &lt;- c("RespVar1", "RespVar2")
mystressor &lt;- c("StressVar")
mysubpops &lt;- c("All_Sites", "Resource_Class")
relrisk_analysis(dframe,
  vars_response = myresponse,
  vars_stressor = mystressor, subpops = mysubpops, siteID = "siteID",
  weight = "wgt", xcoord = "xcoord", ycoord = "ycoord",
  stratumID = "stratum"
)
</code></pre>

<hr>
<h2 id='revisit_bibd'>Create a balanced incomplete block panel revisit design</h2><span id='topic+revisit_bibd'></span>

<h3>Description</h3>

<p>Create a revisit design for panels in a survey that specifies the time
periods for the units of each panel to be sampled based on searching for a
D-optimal block design that is a member of the class of generalized Youden
designs.  The resulting design need not be a balanced incomplete block
design.  Based on algorithmic idea by Cook and Nachtsheim (1989) and
implemented by Robert Wheeler.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>revisit_bibd(
  n_period,
  n_pnl,
  n_visit,
  nsamp,
  panel_name = "BIB",
  begin = 1,
  skip = 1,
  iter = 30
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="revisit_bibd_+3A_n_period">n_period</code></td>
<td>
<p>Number of time periods for the survey design. Typically,
number of periods if sampling occurs once per period or number of months if
sampling occurs once per month. (v, number of varieties/treatments in BIBD
terms)</p>
</td></tr>
<tr><td><code id="revisit_bibd_+3A_n_pnl">n_pnl</code></td>
<td>
<p>Number of panels (b, number of blocks in BIBD terms)</p>
</td></tr>
<tr><td><code id="revisit_bibd_+3A_n_visit">n_visit</code></td>
<td>
<p>Number of time periods to be visited in a panel (k, block
size in BIBD terms)</p>
</td></tr>
<tr><td><code id="revisit_bibd_+3A_nsamp">nsamp</code></td>
<td>
<p>Number of samples in each panel.</p>
</td></tr>
<tr><td><code id="revisit_bibd_+3A_panel_name">panel_name</code></td>
<td>
<p>Prefix for name of each panel</p>
</td></tr>
<tr><td><code id="revisit_bibd_+3A_begin">begin</code></td>
<td>
<p>Numeric name of first sampling occasion, e.g. a specific
period.</p>
</td></tr>
<tr><td><code id="revisit_bibd_+3A_skip">skip</code></td>
<td>
<p>Number of sampling occasions to skip between planned sampling
periods, e.g., sampling will occur only every 5 periods if <code>skip = 5</code>.</p>
</td></tr>
<tr><td><code id="revisit_bibd_+3A_iter">iter</code></td>
<td>
<p>Maximum number of iterations in search for D-optimal
Generalized Youden Design.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function uses <code>find.BIB</code> function from crossdes package to
search for a D-optimal block design.  crossdes uses package AlgDesign
to search balanced incomplete block designs.
</p>


<h3>Value</h3>

<p>A two-dimensional array of sample sizes to be sampled for each panel
and each sampling occasion.
</p>


<h3>Author(s)</h3>

<p>Tony Olsen <a href="mailto:Olsen.Tony@epa.gov">Olsen.Tony@epa.gov</a>
</p>


<h3>References</h3>

<p>Cook R. D.  and C. Nachtsheim. (1989). Computer-aided blocking of factorial
and response-surface designs. <em>Technometrics</em> <b>31(3)</b>, 339-346.
</p>


<h3>See Also</h3>


<dl>
<dt><code><a href="#topic+revisit_dsgn">revisit_dsgn</a></code></dt><dd><p>to create a panel revisit design</p>
</dd>
<dt><code><a href="#topic+revisit_rand">revisit_rand</a></code></dt><dd><p>to create a panel revisit design with random
assignment to panels and time periods</p>
</dd>
<dt><code><a href="#topic+pd_summary">pd_summary</a></code></dt><dd><p> to summarize characteristics of a
panel revisit design</p>
</dd>
</dl>



<h3>Examples</h3>

<pre><code class='language-R'># Balanced incomplete block design with 20 sample occasions, 20 panels,
# 3 visits to each unit, and 20 units in each panel.
revisit_bibd(n_period = 20, n_pnl = 20, n_visit = 3, nsamp = 20)
</code></pre>

<hr>
<h2 id='revisit_dsgn'>Create a panel revisit design</h2><span id='topic+revisit_dsgn'></span>

<h3>Description</h3>

<p>Create a revisit design for panels in a survey that specifies the time
periods that members of each panel will be sampled. Three basic panel design
structures may be created: always revisit panel, serially alternating panels,
or rotating panels.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>revisit_dsgn(n_period, panels, begin = 1, skip = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="revisit_dsgn_+3A_n_period">n_period</code></td>
<td>
<p>Number of time periods for the panel design. For example,
number of periods if sampling occurs once per period or number of months if
sampling occurs once per month.</p>
</td></tr>
<tr><td><code id="revisit_dsgn_+3A_panels">panels</code></td>
<td>
<p>List of lists where each list specifies a revisit panel
structure. Each sublist consists of four components: <code>n</code> - sample size for
each panel in the sublist, <code>pnl_dsgn</code> - a vector with an even number of
elements specifying the panel revisit schedule in terms of the number of
consecutive time periods sample units will be sampled, followed by number
of consecutive time periods skipped, and then repeated as necessary. <code>pnl_n</code>
- number of panels in the sublist, and <code>start_option</code> - option for starting
the <code>revisit_dsgn</code> (<code>None</code>, <code>Partial_Begin</code>, or <code>Partial_End</code>)
which must be the same a <code>pnl_dsgn</code>. Three basic panel
structures are possible: a) if <code>pnl_dsgn</code> ends in <code>0</code>, then the sample units
are visited on all subsequent time periods, b) if <code>pnl_dsgn</code> ends in <code>NA</code>, then
panel follows a rotating panel structure, and c) if <code>pnl_dsgn</code> ends in any
number &gt; <code>0</code>, then panel follows a serially alternating panel structure. See
details for further information.</p>
</td></tr>
<tr><td><code id="revisit_dsgn_+3A_begin">begin</code></td>
<td>
<p>Numeric name of first sampling occasion, e.g. a specific
period.</p>
</td></tr>
<tr><td><code id="revisit_dsgn_+3A_skip">skip</code></td>
<td>
<p>Number of time periods to skip between planned sampling
periods, e.g., sampling will occur only every 5 periods if <code>skip = 5</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function creates revisit designs using the concepts in McDonald
(2003) to specify the revisit pattern across time periods for each panel.
The panel revisit schedule is specified by a vector. Odd positions in
vector specify the number of consecutive time periods when panel units are
sampled. Even positions in vector specify the number of consecutive time
periods when panel units are not sampled.
</p>
<p>If last even position is a <code>"0"</code>, then a single panel follows an always
revisit panel structure.  After satisfying the initial revisit schedule
specified prior to the <code>"0"</code>, units in a panel are always visited for rest of
the time periods. The simplest always revisit panel design is to revisit
every sample unit on every time period, specified as <code>pnl_dsgn = c(1,0)</code> or
using McDonald's notation [1-0].
</p>
<p>If the last even position is <code>NA</code>, the panels follow a rotating panel
structure. For example, <code>pnl_dsgn = c(1, NA)</code> designates that sample units in
a panel will be visited once and then never again, [1-n] in McDonald's
notation. <code>pnl_dsgn =c(1, 4, 1, NA)</code> designates that sample units in a panel
will be visited once, then not sampled on next four time periods, then
sampled again once at the next time period and then never sampled again,
[1-4-1-n] in McDonald/s notation.
</p>
<p>If the last even position is &gt; <code>0</code>, the panels follow a serially alternating
panel structure. For example, <code>pnl_dsgn = c(1, 4)</code> designates that sample
units in a panel will be visited once, then not sampled during the next
four time periods, then sampled once and not sampled for next four time
periods, and that cycle repeated until end of the number of time periods,
[1-4] in McDonald's notation. <code>pnl_dsgn = c(2, 3, 1, 4)</code> designates that the
cycle has sample units in a panel being visited during two consecutive time
periods, not sampled for three consecutive time periods, sampled for one time
period and then not sampled on next four time periods, and the cycle is
repeated until end of the number of time periods, [2-3-1-4] in McDonald's
notation.
</p>
<p>The number of panels in a single panel design is specified by <code>pnl_n</code>.  For
an always revisit panel structure, a single panel is created and <code>pnl_n</code> is
ignored. For a rotating panel structure, when <code>pnl_n = NA</code>, the number of
panels is equal to n_period. Note that this should only be used when the
rotating panel structure is the only panel design, i.e., no split panel
design (see below for split panel details). If <code>pnl_n = m</code> is specified for a
rotating panel design, then then number of panels will be <code>m</code>.  For example,
<code>pnl_dsgn = c( 1, 4, 1, NA)</code> and and <code>pnl_n = 5</code> means that only 5 panels will
be constructed and the last time period to be sampled will be time period
10. In McDonald's notation the panel design structure is [(1-4-1-n)^5].  If
the number of time periods, <code>n_period</code>, is 20 and no other panel design
structure is specified, then the last 10 time periods will not be sampled.
For serially alternating panels, when <code>pnl_n = NA</code>, the number of panels will
be the sum of the elements in pan_dsgn (ignoring <code>NA</code>). If <code>pnl_n</code> is specified
as <code>m</code>, then <code>m</code> panels will be created.  For example, <code>pnl_dsgn = c(1, 4, 1, 4)</code>
and <code>pnl_n = 3</code>, [(1-4-1-4)^3] in McDonald's notation, will create first three
panels of the 510 serially alternating panels specified by <code>pnl_dsgn</code>.
</p>
<p>A serially alternating or rotating panel revisit design may not result in
the same number of units being sampled during each time period,
particularly during the initial start up period.  The default is to not
specify a startup option (<code>"None"</code>).  Start up option <code>"Partial_Begin"</code>
initiates the revisit design at the last time period scheduled for sampling
in the first panel. For example, a [2-3-1-4] design starts at time period 6
instead of time period 1 under the Partial_Begin option. For a serially
alternating panel structure, start up option <code>"Partial_End"</code> initiates the
revisit design at the time period that begins the second serially
alternating pattern. For example, a [2-3-1-4] design starts at time period
11 instead of time period 1. For a rotating panel structure design, use of
Partial_End makes the assumption that the number of panels equals the
number of time periods and adds units to the last &quot;m&quot; panels for time
periods <code>1</code> to <code>"m"</code> as if number of time periods was extended by <code>"m"</code> where <code>"m"</code>
is one less than then the sum of the panel design.  For example, a
[1-4-1-4-1-n] design would result in <code>m = 10</code>.  Note that some designs with
<code>pnl_n</code> not equal to the number of sample occasions can produce unexpected
panel designs.  See examples.
</p>
<p>Different types of panel structures can be combined, these are termed split
panels by many authors, by specifying more than one list for the panels
parameter.  The total number of panels is the sum of the number of panels
in each of the panel structures specified by the split panel design.
</p>


<h3>Value</h3>

<p>A two-dimensional array of sample sizes to be sampled at each
combination of panel and time period.
</p>


<h3>Author(s)</h3>

<p>Tony Olsen <a href="mailto:Olsen.Tony@epa.gov">Olsen.Tony@epa.gov</a>
</p>


<h3>References</h3>

<p>McDonald, T. (2003). Review of environmental monitoring methods: survey
designs. <em>Environmental Monitoring and Assessment</em> <b>85</b>,
277-292.
</p>


<h3>See Also</h3>


<dl>
<dt><code><a href="#topic+revisit_bibd">revisit_bibd</a></code></dt><dd><p>to create a balanced incomplete block
panel revisit design</p>
</dd>
<dt><code><a href="#topic+revisit_rand">revisit_rand</a></code></dt><dd><p>to create a revisit design with random
assignment to panels and time periods</p>
</dd>
<dt><code><a href="#topic+pd_summary">pd_summary</a></code></dt><dd><p> to summarize characteristics of a
panel revisit design</p>
</dd>
</dl>



<h3>Examples</h3>

<pre><code class='language-R'># One panel of  60 sample units sampled at every time period: [1-0]
revisit_dsgn(20, panels = list(
  Annual = list(
    n = 60, pnl_dsgn = c(1, 0), pnl.n = NA,
    start_option = "None"
  )
), begin = 1)

# Rotating panels of 60 units sampled once and never again: [1-n].  Number
# of panels equal n_period.
revisit_dsgn(20,
  panels = list(
    R60N = list(n = 60, pnl_dsgn = c(1, NA), pnl_n = NA, start_option = "None")
  ),
  begin = 1
)

# Serially alternating panel with three visits to sample unit then skip
# next two time periods: [3-2]
revisit_dsgn(20, panels = list(
  SA60PE = list(
    n = 20, pnl_dsgn = c(3, 2), pnl_n = NA,
    start_option = "Partial_End"
  )
), begin = 1)

# Split panel of sample units combining above two panel designs: [1-0, 1-n]
revisit_dsgn(n_period = 20, begin = 2017, panels = list(
  Annual = list(
    n = 60, pnl_dsgn = c(1, 0), pnl.n = NA,
    start_option = "None"
  ),
  R60N = list(n = 60, pnl_dsgn = c(1, NA), pnl_n = NA, start_option = "None")
))
</code></pre>

<hr>
<h2 id='revisit_rand'>Create a revisit design with random assignment to panels and time periods</h2><span id='topic+revisit_rand'></span>

<h3>Description</h3>

<p>Create a revisit design for a survey that specifies the panels and time
periods that will be sampled by random selection of panels and time periods.
Three options for random assignments are <code>"period"</code> where the number of time
periods to be sampled in a panel is fixed, <code>"panel"</code> where the number panels to
be sampled in a time period is fixed, and <code>"none"</code> where the number of
panel-period combinations is fixed.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>revisit_rand(
  n_period,
  n_pnl,
  rand_control = "period",
  n_visit,
  nsamp,
  panel_name = "Random",
  begin = 1,
  skip = 1
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="revisit_rand_+3A_n_period">n_period</code></td>
<td>
<p>Number of time periods for the survey design. Typically,
number of periods if sampling occurs once per period or number of months if
sampling occurs once per month. (v, number of varieties (or treatments) in
BIBD terms)</p>
</td></tr>
<tr><td><code id="revisit_rand_+3A_n_pnl">n_pnl</code></td>
<td>
<p>Number of panels</p>
</td></tr>
<tr><td><code id="revisit_rand_+3A_rand_control">rand_control</code></td>
<td>
<p>Character value must be <code>"none"</code>, <code>"panel"</code>, or <code>"period"</code>.
Specifies whether the number of sample events will be fixed for each panel
(<code>"panel"</code>), for each sample occasion (<code>"occasion"</code>), or for total panel-period
combinations (<code>"none"</code>).  Default is <code>"panel"</code>.</p>
</td></tr>
<tr><td><code id="revisit_rand_+3A_n_visit">n_visit</code></td>
<td>
<p>If <code>rand_control</code> is <code>"panel"</code>, this is the number of panels that
will be sampled in each time period. If rand_control is <code>"period"</code>, this is
the number of time periods to be sampled in each panel. If <code>rand_control</code> is
<code>"none"</code>, this is the total number of panel-period combinations that will
have units sampled in the revisit design.</p>
</td></tr>
<tr><td><code id="revisit_rand_+3A_nsamp">nsamp</code></td>
<td>
<p>Number of samples in each panel.</p>
</td></tr>
<tr><td><code id="revisit_rand_+3A_panel_name">panel_name</code></td>
<td>
<p>Prefix for name of each panel</p>
</td></tr>
<tr><td><code id="revisit_rand_+3A_begin">begin</code></td>
<td>
<p>Numeric name of first sampling occasion, e.g. a specific period.</p>
</td></tr>
<tr><td><code id="revisit_rand_+3A_skip">skip</code></td>
<td>
<p>Number of sampling occasions to skip between planned sampling
periods, e.g., sampling will occur only every 5 periods if <code>skip = 5</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The revisit design for a survey is created by random selection of
panels and time periods that will have sample events.  The number of sample
occasions that will be visited by a panel is random.
</p>


<h3>Value</h3>

<p>A two-dimensional array of sample sizes to be sampled for each panel
and each time period.
</p>


<h3>Author(s)</h3>

<p>Tony Olsen <a href="mailto:Olsen.Tony@epa.gov">Olsen.Tony@epa.gov</a>
</p>


<h3>See Also</h3>


<dl>
<dt><code><a href="#topic+revisit_bibd">revisit_bibd</a></code></dt><dd><p>create a balanced incomplete block
panel revisit design</p>
</dd>
<dt><code><a href="#topic+revisit_dsgn">revisit_dsgn</a></code></dt><dd><p>create a panel revisit design</p>
</dd>
<dt><code><a href="#topic+pd_summary">pd_summary</a></code></dt><dd><p> to summarize characteristics of a
panel revisit design</p>
</dd>
</dl>



<h3>Examples</h3>

<pre><code class='language-R'>revisit_rand(
  n_period = 20, n_pnl = 10, rand_control = "none", n_visit = 50,
  nsamp = 20
)
revisit_rand(
  n_period = 20, n_pnl = 10, rand_control = "panel", n_visit = 5,
  nsamp = 10
)
revisit_rand(
  n_period = 20, n_pnl = 10, rand_control = "period",
  n_visit = 5, nsamp = 10
)
</code></pre>

<hr>
<h2 id='sp_balance'>Calculate spatial balance metrics</h2><span id='topic+sp_balance'></span>

<h3>Description</h3>

<p>This function measures the spatial balance (with respect to the
sampling frame) of design sites using
Voronoi polygons (Dirichlet tessellations).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sp_balance(
  object,
  sframe,
  stratum_var = NULL,
  ip = NULL,
  metrics = "pielou",
  extents = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sp_balance_+3A_object">object</code></td>
<td>
<p>An <code>sf</code> object containing some design sites.</p>
</td></tr>
<tr><td><code id="sp_balance_+3A_sframe">sframe</code></td>
<td>
<p>The sampling frame as an <code>sf</code> object. The coordinate
system for <code>sframe</code> must be one where distance for coordinates is meaningful.</p>
</td></tr>
<tr><td><code id="sp_balance_+3A_stratum_var">stratum_var</code></td>
<td>
<p>The name of the stratum variable in <code>object</code>
and <code>sframe</code>. If <code>NULL</code> (the default), no strata is assumed.
If a single character vector is provided, it is assumed this is the
name of the stratum variable in <code>object</code> and <code>sframe</code>. If
a two-dimensional character vector is provided, one element must be
named &quot;object&quot; and corresponds to the name of the stratum variable
in <code>object</code>, while the other element must be named &quot;sframe&quot; and
corresponds to the name of the stratum variable in <code>sframe</code>.</p>
</td></tr>
<tr><td><code id="sp_balance_+3A_ip">ip</code></td>
<td>
<p>Inclusion probabilities associated with each row of <code>sframe</code>.
If these are not provided, an equal probability design is assumed (within
strata).</p>
</td></tr>
<tr><td><code id="sp_balance_+3A_metrics">metrics</code></td>
<td>
<p>A character vector of spatial balance metrics:
</p>

<dl>
<dt><code>pielou</code></dt><dd><p> Pielou's Evenness Index (the default). This statistic
can take on a value between zero and one.</p>
</dd>
<dt><code>simpsons</code></dt><dd><p> Simpsons Evenness Index. This statistic
can take on a value between zero and logarithm of the sample size.</p>
</dd>
<dt><code>rmse</code></dt><dd><p> Root-Mean-Squared Error. This statistic
can take on a value between zero and infinity.</p>
</dd>
<dt><code>mse</code></dt><dd><p> Mean-Squared Error. This statistic
can take on a value between zero and infinity.</p>
</dd>
<dt><code>mae</code></dt><dd><p> Median-Absolute Error. This statistic
can take on a value between zero and infinity.</p>
</dd>
<dt><code>medae</code></dt><dd><p> Mean-Absolute Error. This statistic
can take on a value between zero and infinity.</p>
</dd>
<dt><code>chisq</code></dt><dd><p> Chi-Squared Loss. This statistic
can take on a value between zero and infinity.</p>
</dd>
</dl>

<p>All spatial balance metrics have a lower bound of zero, which indicates perfect
spatial balance. As the metric value increases, the spatial balance decreases.</p>
</td></tr>
<tr><td><code id="sp_balance_+3A_extents">extents</code></td>
<td>
<p>Should the extent (total units) within each Voronoi polygon
be returned? Defaults to <code>FALSE</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data frame with columns providing the stratum (<code>stratum</code>),
spatial balance metric (<code>metric</code>), and spatial balance (<code>value</code>).
</p>


<h3>Author(s)</h3>

<p>Michael Dumelle <a href="mailto:Dumelle.Michael@epa.gov">Dumelle.Michael@epa.gov</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
sample &lt;- grts(NE_Lakes, 30)
sp_balance(sample$sites_base, NE_Lakes)
strata_n &lt;- c(low = 25, high = 30)
sample_strat &lt;- grts(NE_Lakes, n_base = strata_n, stratum_var = "ELEV_CAT")
sp_balance(sample_strat$sites_base, NE_Lakes, stratum_var = "ELEV_CAT", metric = "rmse")

## End(Not run)
</code></pre>

<hr>
<h2 id='sp_frame'><code>sp_frame</code> objects</h2><span id='topic+sp_frame'></span><span id='topic+sp_unframe'></span>

<h3>Description</h3>

<p>Turn sampling frames or analysis data into an <code>sp_frame</code> object
or transform <code>sp_frame</code> objects back into their original object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sp_frame(frame)

sp_unframe(sp_frame)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sp_frame_+3A_frame">frame</code></td>
<td>
<p>A sampling frame or analysis data</p>
</td></tr>
<tr><td><code id="sp_frame_+3A_sp_frame">sp_frame</code></td>
<td>
<p>An <code>sp_frame</code> object.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>sp_frame()</code> function assigns <code>frame</code> class <code>sp_frame</code>
to be used by <code>summary()</code> and <code>plot()</code>. <code>sp_frame()</code> objects
can sometimes clash with other sf and tidyverse generics, so <code>un_spframe()</code> removes
class <code>sp_frame()</code>, leaving the original classes of <code>frame</code> intact.
</p>


<h3>Value</h3>

<p>An <code>sp_frame</code> object.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>NE_Lakes &lt;- sp_frame(NE_Lakes)
class(NE_Lakes)
NE_Lakes &lt;- sp_unframe(NE_Lakes)
class(NE_Lakes)
</code></pre>

<hr>
<h2 id='sp_plot'>Plot sampling frames, design sites, and analysis data.</h2><span id='topic+sp_plot'></span><span id='topic+sp_plot.default'></span><span id='topic+sp_plot.sp_design'></span>

<h3>Description</h3>

<p>This function plots sampling frames, design sites, and analysis data.
If the left-hand side of the formula is empty, plots
are of the distributions of the right-hand side variables. If the left-hand side
of the variable contains a variable, plots are of the left-hand size variable
for each level of each right-hand side variable.
This function is largely built on <code>plot.sf()</code>, and all spsurvey plotting
methods can supply additional arguments to <code>plot.sf()</code>. For more information on
plotting in <code>sf</code>, run <code>?sf::plot.sf()</code>. Equivalent to <code>spsurvey::plot()</code>; both
are currently maintained for backwards compatibility.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sp_plot(object, ...)

## Default S3 method:
sp_plot(
  object,
  formula = ~1,
  xcoord,
  ycoord,
  crs,
  var_args = NULL,
  varlevel_args = NULL,
  geom = FALSE,
  onlyshow = NULL,
  fix_bbox = TRUE,
  ...
)

## S3 method for class 'sp_design'
sp_plot(
  object,
  sframe = NULL,
  formula = ~siteuse,
  siteuse = NULL,
  var_args = NULL,
  varlevel_args = NULL,
  geom = FALSE,
  onlyshow = NULL,
  fix_bbox = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sp_plot_+3A_object">object</code></td>
<td>
<p>An object to plot. When plotting sampling frames or analysis data,
a data frame or <code>sf</code> object. When plotting design sites, an object created by <code>grts()</code> or
<code>irs()</code> (which has class <code>sp_design</code>).</p>
</td></tr>
<tr><td><code id="sp_plot_+3A_...">...</code></td>
<td>
<p>Additional arguments to pass to <code>plot.sf()</code>.</p>
</td></tr>
<tr><td><code id="sp_plot_+3A_formula">formula</code></td>
<td>
<p>A formula. One-sided formulas are used to summarize the
distribution of numeric or categorical variables. For one-sided formulas,
variable names are placed to the right of <code>~</code> (a right-hand side variable).
Two sided formulas are
used to summarize the distribution of a left-hand side variable
for each level of each right-hand side categorical variable in the formula.
Note that only for two-sided formulas are numeric right-hand side variables
coerced to a categorical variables. If an intercept
is included as a right-hand side variable (whether the formula is one-sided or
two-sided), the total will also be summarized. When plotting sampling frames
or analysis data, the default formula is <code>~ 1</code>. When plotting design sites,
<code>siteuse</code> should be used in the formula, and the default formula is
<code>~ siteuse</code>.</p>
</td></tr>
<tr><td><code id="sp_plot_+3A_xcoord">xcoord</code></td>
<td>
<p>Name of the x-coordinate (east-west) in <code>object</code> (only required if
<code>object</code> is not an <code>sf</code> object).</p>
</td></tr>
<tr><td><code id="sp_plot_+3A_ycoord">ycoord</code></td>
<td>
<p>Name of y (north-south)-coordinate in <code>object</code> (only required if
<code>object</code> is not an <code>sf</code> object).</p>
</td></tr>
<tr><td><code id="sp_plot_+3A_crs">crs</code></td>
<td>
<p>Projection code for <code>xcoord</code> and <code>ycoord</code> (only
required if <code>object</code> is not an <code>sf</code> object).</p>
</td></tr>
<tr><td><code id="sp_plot_+3A_var_args">var_args</code></td>
<td>
<p>A named list. The name of each list element corresponds to a
right-hand side variable in <code>formula</code>. Values in the list are composed of
graphical arguments that are to be passed to <strong>every</strong> level of the
variable. To see all graphical arguments available, run <code>?plot.sf</code>.</p>
</td></tr>
<tr><td><code id="sp_plot_+3A_varlevel_args">varlevel_args</code></td>
<td>
<p>A named list. The name of each list element corresponds to a
right-hand side variable in <code>formula</code>. The first element in this list
should be <code>"levels"</code> and contain all levels of the particular right-hand side variable. Subsequent
names correspond to graphical arguments that are to be passed to
the specified levels (in order) of the right-hand side variable. Values for each
graphical argument must be specified for each level of the right-hand side variable,
but applicable sf defaults will be matched by inputting the value <code>NA</code>.
To see all graphical arguments available, run <code>?plot.sf</code></p>
</td></tr>
<tr><td><code id="sp_plot_+3A_geom">geom</code></td>
<td>
<p>Should separate geometries for each level of the right-hand
side <code>formula</code> variables be plotted? Defaults to <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="sp_plot_+3A_onlyshow">onlyshow</code></td>
<td>
<p>A string indicating the single level of the single right-hand side
variable for which a summary is requested. This argument is only used when
a single right-hand side variable is provided.</p>
</td></tr>
<tr><td><code id="sp_plot_+3A_fix_bbox">fix_bbox</code></td>
<td>
<p>Should the geometry bounding box be fixed across plots?
If a length-four vector with names &quot;xmin&quot;, &quot;ymin&quot;, &quot;xmax&quot;, and &quot;ymax&quot; and values
indicating bounding box edges, the bounding box will be fixed as <code>fix_bbox</code>
across plots. If <code>TRUE</code>, the bounding box will be fixed across plots as the
bounding box of <code>object</code>. If <code>FALSE</code>, the bounding box will vary across
plots according to the unique geometry for each plot. Defaults to <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="sp_plot_+3A_sframe">sframe</code></td>
<td>
<p>The sampling frame (an <code>sf</code> object) to plot alongside design
sites. This argument is only used when <code>object</code> corresponds to the design sites.</p>
</td></tr>
<tr><td><code id="sp_plot_+3A_siteuse">siteuse</code></td>
<td>
<p>A character vector of site types to include when plotting design sites.
It can only take on values <code>"sframe"</code> (sampling frame),
<code>"Legacy"</code> (for legacy sites), <code>"Base"</code> (for base sites),
<code>"Over"</code> (for <code>n_over</code> replacement sites), and <code>"Near"</code>
(for <code>n_near</code> replacement sites). The order of sites represents the
layering in the plot (e.g. <code>siteuse = c("Base", "Legacy")</code> will plot
legacy sites on top of base sites. Defaults to all non-<code>NULL</code> elements
in <code>x</code> and <code>y</code> with plot order <code>"sframe"</code>, <code>"Legacy"</code>,
<code>"Base"</code>, <code>"Over"</code>, <code>"Near"</code>.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Michael Dumelle <a href="mailto:Dumelle.Michael@epa.gov">Dumelle.Michael@epa.gov</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
data("NE_Lakes")
sp_plot(NE_Lakes, formula = ~ELEV_CAT)
sample &lt;- grts(NE_Lakes, 30)
sp_plot(sample, NE_Lakes)
data("NLA_PNW")
sp_plot(NLA_PNW, formula = ~BMMI)

## End(Not run)
</code></pre>

<hr>
<h2 id='sp_rbind'>Combine rows from GRTS or IRS samples.</h2><span id='topic+sp_rbind'></span>

<h3>Description</h3>

<p>This function row binds the <code>sites_legacy</code>, <code>sites_base</code>,
<code>sites_over</code>, and <code>sites_near</code> objects from a GRTS or IRS sample
into a single <code>sf</code> object. This function is most useful when a single
<code>sf</code> object that contains all design sites is desired
(e.g. writing out a single shapefile using <code>sf::write_sf()</code>).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sp_rbind(object, siteuse = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sp_rbind_+3A_object">object</code></td>
<td>
<p>The design sites (output from <code>grts()</code> or <code>irs()</code>).</p>
</td></tr>
<tr><td><code id="sp_rbind_+3A_siteuse">siteuse</code></td>
<td>
<p>A character vector of site types to return. Can contain
<code>"Legacy"</code> (for legacy sites), <code>"Base"</code> (for base sites),
<code>"Over"</code> (for <code>n_over</code> replacement sites), and <code>"Near"</code>
(for <code>n_near</code> replacement sites). The default is <code>NULL</code>, which
returns all non-<code>NULL</code> output from <code>object$sites_legacy</code>,
<code>object$sites_base</code>, <code>object$sites_over</code>, and <code>object$sites_near</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A single <code>sf</code> object containing all requested design sites.
</p>


<h3>Author(s)</h3>

<p>Michael Dumelle <a href="mailto:Dumelle.Michael@epa.gov">Dumelle.Michael@epa.gov</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
sample &lt;- grts(NE_Lakes, 50, n_over = 10)
sample &lt;- sp_rbind(sample)
write_sf(sample, "mypath/sample.shp")

## End(Not run)
</code></pre>

<hr>
<h2 id='sp_summary'>Summarize sampling frames, design sites, and analysis data.</h2><span id='topic+sp_summary'></span><span id='topic+sp_summary.default'></span><span id='topic+sp_summary.sp_design'></span>

<h3>Description</h3>

<p><code>sp_summary()</code> summarizes sampling frames, design sites, and analysis data. The right-hand of the
formula specifies the variables (or factors) to
summarize by. If the left-hand side of the formula is empty, the
summary will be of the distributions of the right-hand side variables. If the left-hand side
of the formula contains a variable, the summary will be of the left-hand size variable
for each level of each right-hand side variable. Equivalent to <code>spsurvey::summary()</code>; both
are currently maintained for backwards compatibility.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sp_summary(object, ...)

## Default S3 method:
sp_summary(object, formula = ~1, onlyshow = NULL, ...)

## S3 method for class 'sp_design'
sp_summary(object, formula = ~siteuse, siteuse = NULL, onlyshow = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sp_summary_+3A_object">object</code></td>
<td>
<p>An object to summarize. When summarizing sampling frames,
an <code>sf</code>
object. When summarizing design sites, an object created by <code>grts()</code> or
<code>irs()</code> (which has class <code>sp_design</code>). When summarizing analysis data,
a data frame or an <code>sf</code> object.</p>
</td></tr>
<tr><td><code id="sp_summary_+3A_...">...</code></td>
<td>
<p>Additional arguments to pass to <code>sp_summary()</code>. If the left-hand
side of the formula is empty, the appropriate generic arguments are passed
to <code>summary.data.frame</code>. If the left-hand side of the formula is provided,
the appropriate generic arguments are passed to <code>summary.default</code>.</p>
</td></tr>
<tr><td><code id="sp_summary_+3A_formula">formula</code></td>
<td>
<p>A formula. One-sided formulas are used to summarize the
distribution of numeric or categorical variables. For one-sided formulas,
variable names are placed to the right of <code>~</code> (a right-hand side variable).
Two sided formulas are
used to summarize the distribution of a left-hand side variable
for each level of each right-hand side categorical variable in the formula.
Note that only for two-sided formulas are numeric right-hand side variables
coerced to a categorical variables. If an intercept
is included as a right-hand side variable (whether the formula is one-sided or
two-sided), the total will also be summarized. When summarizing sampling frames
or analysis data, the default formula is <code>~ 1</code>. When summarizing design sites,
<code>siteuse</code> should be used in the formula, and the default formula is
<code>~ siteuse</code>.</p>
</td></tr>
<tr><td><code id="sp_summary_+3A_onlyshow">onlyshow</code></td>
<td>
<p>A string indicating the single level of the single right-hand side
variable for which a summary is requested. This argument is only used when
a single right-hand side variable is provided.</p>
</td></tr>
<tr><td><code id="sp_summary_+3A_siteuse">siteuse</code></td>
<td>
<p>A character vector indicating the design sites
for which summaries are requested in <code>object</code>. Defaults to computing summaries for
each non-<code>NULL</code> <code>sites_*</code> list in <code>object</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>If the left-hand side of the formula is empty, a named list
containing summaries of the count distribution for each right-hand side
variable is returned. If the left-hand side of the formula contains a
variable, a named list containing five number
summaries (numeric left-hand side) or tables (categorical or factor left
hand side) is returned for each right-hand side variable.
</p>


<h3>Author(s)</h3>

<p>Michael Dumelle <a href="mailto:Dumelle.Michael@epa.gov">Dumelle.Michael@epa.gov</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
data("NE_Lakes")
sp_summary(NE_Lakes, ELEV ~ 1)
sp_summary(NE_Lakes, ~ ELEV_CAT * AREA_CAT)
sample &lt;- grts(NE_Lakes, 100)
sp_summary(sample, ~ ELEV_CAT * AREA_CAT)

## End(Not run)
</code></pre>

<hr>
<h2 id='spsurvey-package'>spsurvey: Spatial Sampling Design and Analysis</h2><span id='topic+spsurvey'></span><span id='topic+spsurvey-package'></span>

<h3>Description</h3>

<p>spsurvey implements a design-based approach to statistical inference,
with a focus on spatial data.
Spatially balanced samples are selected using the
Generalized Random Tessellation Stratified (GRTS) algorithm.
The GRTS algorithm can be applied to finite resources (point geometries) and
infinite resources (linear / linestring and areal / polygon geometries) and flexibly
accommodates a diverse set of sampling design features, including
stratification, unequal inclusion probabilities, proportional (to size)
inclusion probabilities, legacy (historical) sites, a minimum distance between
sites, and two options for replacement sites (reverse hierarchical order and
nearest neighbor). Data are analyzed using a wide
range of analysis functions that perform categorical variable analysis, continuous
variable analysis, attributable risk analysis, risk difference analysis, relative
risk analysis, change analysis, and trend analysis. spsurvey can also be used to
summarize objects, visualize objects, select samples that are not spatially balanced,
select panel samples, measure the amount of spatial balance in a sample,
adjust design weights, and more.
This R package has been reviewed in accordance
with U.S. Environmental Protection Agency policy and approved for publication.
Mention of trade names or commercial products does not constitute endorsement or
recommendation for use.
</p>


<h3>Author(s)</h3>

<p><strong>Maintainer</strong>: Michael Dumelle <a href="mailto:Dumelle.Michael@epa.gov">Dumelle.Michael@epa.gov</a> (<a href="https://orcid.org/0000-0002-3393-5529">ORCID</a>)
</p>
<p>Authors:
</p>

<ul>
<li><p> Tom Kincaid <a href="mailto:Kincaid.Tom@epa.gov">Kincaid.Tom@epa.gov</a>
</p>
</li>
<li><p> Tony Olsen <a href="mailto:Olsen.Tony@epa.gov">Olsen.Tony@epa.gov</a>
</p>
</li>
<li><p> Marc Weber <a href="mailto:Weber.Marc@epa.gov">Weber.Marc@epa.gov</a>
</p>
</li></ul>

<p>Other contributors:
</p>

<ul>
<li><p> Don Stevens [contributor]
</p>
</li>
<li><p> Denis White [contributor]
</p>
</li></ul>



<h3>See Also</h3>

<p>Useful links:
</p>

<ul>
<li> <p><a href="https://usepa.github.io/spsurvey/">https://usepa.github.io/spsurvey/</a>
</p>
</li>
<li> <p><a href="https://github.com/USEPA/spsurvey">https://github.com/USEPA/spsurvey</a>
</p>
</li>
<li><p> Report bugs at <a href="https://github.com/USEPA/spsurvey/issues">https://github.com/USEPA/spsurvey/issues</a>
</p>
</li></ul>


<hr>
<h2 id='stopprnt'>Print grts() and irs() errors.</h2><span id='topic+stopprnt'></span>

<h3>Description</h3>

<p>This function prints the error messages vector in the <code>grts</code>
and <code>irs</code> functions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>stopprnt(stop_df = get("stop_df", envir = .GlobalEnv), m = 1:nrow(stop_df))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="stopprnt_+3A_stop_df">stop_df</code></td>
<td>
<p>Data frame that contains stop messages.  The default is
<code>stop_df</code>, which is the name given to the stop data frame created by
functions in the spsurvey package.</p>
</td></tr>
<tr><td><code id="stopprnt_+3A_m">m</code></td>
<td>
<p>Vector of indices for stop messages that are to be printed. The
default is a vector containing the integers from 1 through the number of
rows in <code>stop_df</code>, which will print all stop messages in the data frame.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Printed errors
</p>


<h3>Author(s)</h3>

<p>Tony Olsen <a href="mailto:Olsen.Tony@epa.gov">Olsen.Tony@epa.gov</a>
</p>

<hr>
<h2 id='summary'>Summarize sampling frames, design sites, and analysis data.</h2><span id='topic+summary'></span><span id='topic+summary.sp_frame'></span><span id='topic+summary.sp_design'></span>

<h3>Description</h3>

<p><code>summary()</code> summarizes sampling frames, design sites, and analysis data. The right-hand of the
formula specifies the variables (or factors) to
summarize by. If the left-hand side of the formula is empty, the
summary will be of the distributions of the right-hand side variables. If the left-hand side
of the formula contains a variable, the summary will be of the left-hand size variable
for each level of each right-hand side variable. Equivalent to <code>sp_summary()</code>; both
are currently maintained for backwards compatibility.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'sp_frame'
summary(object, formula = ~1, onlyshow = NULL, ...)

## S3 method for class 'sp_design'
summary(object, formula = ~siteuse, siteuse = NULL, onlyshow = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary_+3A_object">object</code></td>
<td>
<p>An object to summarize. When summarizing sampling frames,
an <code>sf</code>
object given the appropriate class using <code>sp_frame</code>.
When summarizing design sites, an object created by <code>grts()</code> or
<code>irs()</code> (which has class <code>sp_design</code>). When summarizing analysis data,
a data frame or an <code>sf</code> object given the appropriate class using <code>sp_frame</code>.</p>
</td></tr>
<tr><td><code id="summary_+3A_formula">formula</code></td>
<td>
<p>A formula. One-sided formulas are used to summarize the
distribution of numeric or categorical variables. For one-sided formulas,
variable names are placed to the right of <code>~</code> (a right-hand side variable).
Two sided formulas are
used to summarize the distribution of a left-hand side variable
for each level of each right-hand side categorical variable in the formula.
Note that only for two-sided formulas are numeric right-hand side variables
coerced to a categorical variables. If an intercept
is included as a right-hand side variable (whether the formula is one-sided or
two-sided), the total will also be summarized. When summarizing sampling frames
or analysis data, the default formula is <code>~ 1</code>. When summarizing design sites,
<code>siteuse</code> should be used in the formula, and the default formula is
<code>~ siteuse</code>.</p>
</td></tr>
<tr><td><code id="summary_+3A_onlyshow">onlyshow</code></td>
<td>
<p>A string indicating the single level of the single right-hand side
variable for which a summary is requested. This argument is only used when
a single right-hand side variable is provided.</p>
</td></tr>
<tr><td><code id="summary_+3A_...">...</code></td>
<td>
<p>Additional arguments to pass to <code>sp_summary()</code>. If the left-hand
side of the formula is empty, the appropriate generic arguments are passed
to <code>summary.data.frame</code>. If the left-hand side of the formula is provided,
the appropriate generic arguments are passed to <code>summary.default</code>.</p>
</td></tr>
<tr><td><code id="summary_+3A_siteuse">siteuse</code></td>
<td>
<p>A character vector indicating the design sites
for which summaries are requested in <code>object</code>. Defaults to computing summaries for
each non-<code>NULL</code> <code>sites_*</code> list in <code>object</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>If the left-hand side of the formula is empty, a named list
containing summaries of the count distribution for each right-hand side
variable is returned. If the left-hand side of the formula contains a
variable, a named list containing five number
summaries (numeric left-hand side) or tables (categorical or factor left
hand side) is returned for each right-hand side variable.
</p>


<h3>Author(s)</h3>

<p>Michael Dumelle <a href="mailto:Dumelle.Michael@epa.gov">Dumelle.Michael@epa.gov</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
data("NE_Lakes")
summary(NE_Lakes, ELEV ~ 1)
summary(NE_Lakes, ~ ELEV_CAT * AREA_CAT)
sample &lt;- grts(NE_Lakes, 100)
summary(sample, ~ ELEV_CAT * AREA_CAT)

## End(Not run)
</code></pre>

<hr>
<h2 id='trend_analysis'>Trend analysis</h2><span id='topic+trend_analysis'></span>

<h3>Description</h3>

<p>This function organizes input and output for estimation of trend across time
for a series of samples (for categorical and continuous variables). Trend is estimated using the
analytical procedure identified by the model arguments.  For categorical
variables, the choices for the <code>model_cat</code> argument are: (1) simple linear
regression, (2) weighted linear regression, and (3) generalized linear
mixed-effects model. For continuous variables, the choices for the
<code>model_cont</code> argument are: (1) simple linear regression, (2) weighted
linear regression, and (3)  linear mixed-effects model.  The analysis data,
<code>dframe</code>, can be either a data frame or a simple features (<code>sf</code>) object.  If an
<code>sf</code> object is used, coordinates are extracted from the geometry column in the
object, arguments <code>xcoord</code> and <code>ycoord</code> are assigned values
<code>"xcoord"</code> and <code>"ycoord"</code>, respectively, and the geometry column is
dropped from the object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>trend_analysis(
  dframe,
  vars_cat = NULL,
  vars_cont = NULL,
  subpops = NULL,
  model_cat = "SLR",
  cat_rhs = NULL,
  model_cont = "LMM",
  cont_rhs = NULL,
  siteID = "siteID",
  yearID = "year",
  weight = "weight",
  xcoord = NULL,
  ycoord = NULL,
  stratumID = NULL,
  clusterID = NULL,
  weight1 = NULL,
  xcoord1 = NULL,
  ycoord1 = NULL,
  sizeweight = FALSE,
  sweight = NULL,
  sweight1 = NULL,
  fpc = NULL,
  popsize = NULL,
  invprboot = TRUE,
  nboot = 1000,
  vartype = "Local",
  jointprob = "overton",
  conf = 95,
  All_Sites = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="trend_analysis_+3A_dframe">dframe</code></td>
<td>
<p>Data to be analyzed (analysis data). A data frame or
<code>sf</code> object containing survey design variables, response
variables, and subpopulation (domain) variables.</p>
</td></tr>
<tr><td><code id="trend_analysis_+3A_vars_cat">vars_cat</code></td>
<td>
<p>Vector composed of character values that identify the names
of categorical response variables in <code>dframe</code>. If
argument <code>model_cat</code> equals &quot;GLMM&quot;, the categorical variables in the
<code>dframe</code> data frame must be factors each of which has two levels,
where the second level will be assumed to specify &quot;success&quot;.  The default
value is <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="trend_analysis_+3A_vars_cont">vars_cont</code></td>
<td>
<p>Vector composed of character values that identify the
names of continuous response variables in <code>dframe</code>.
The default value is <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="trend_analysis_+3A_subpops">subpops</code></td>
<td>
<p>Vector composed of character values that identify the
names of subpopulation (domain) variables in <code>dframe</code>.
If a value is not provided, the value <code>"All_Sites"</code> is assigned to the
subpops argument and a factor variable named <code>"All_Sites"</code> that takes
the value <code>"All Sites"</code> is added to <code>dframe</code>.  The
default value is <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="trend_analysis_+3A_model_cat">model_cat</code></td>
<td>
<p>Character value identifying the analytical procedure used
for trend estimation for categorical variables.  The choices are:
<code>"SLR"</code> (simple linear regression), <code>"WLR"</code> (weighted linear
regression), and <code>"GLMM"</code> (generalized linear mixed-effects model).
The default value is <code>"SLR"</code>.</p>
</td></tr>
<tr><td><code id="trend_analysis_+3A_cat_rhs">cat_rhs</code></td>
<td>
<p>Character value specifying the right hand side of the formula
for a generalized linear mixed-effects model.  If a value is not provided,
the argument is assigned a value that specifies the Piepho and Ogutu (2002)
model.  The default value is <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="trend_analysis_+3A_model_cont">model_cont</code></td>
<td>
<p>Character value identifying the analytical procedure used
for trend estimation for continuous variables.  The choices are:
<code>"SLR"</code> (simple linear regression), <code>"WLR"</code> (weighted linear
regression), and <code>"LMM"</code> (linear mixed-effects model).  The default
value is <code>"LMM"</code>.</p>
</td></tr>
<tr><td><code id="trend_analysis_+3A_cont_rhs">cont_rhs</code></td>
<td>
<p>Character value specifying the right hand side of the
formula for a linear mixed-effects model.  If a value is not provided, the
argument is assigned a value that specifies the Piepho and Ogutu (2002)
model.  The default value is <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="trend_analysis_+3A_siteid">siteID</code></td>
<td>
<p>Character value providing name of the site ID variable in
<code>dframe</code>.  If repeat visit sites are present, the site
ID value for each revisit site will be the same for each survey.  For a
two-stage sample, the site ID variable identifies stage two site IDs.  The
default value is <code>"siteID"</code>.</p>
</td></tr>
<tr><td><code id="trend_analysis_+3A_yearid">yearID</code></td>
<td>
<p>Character value providing name of the time period variable in
<code>dframe</code>, which must be numeric and will be forced to
numeric if it is not.  The default assumption is that the time period
variable is years.  The default value is <code>"year"</code>.</p>
</td></tr>
<tr><td><code id="trend_analysis_+3A_weight">weight</code></td>
<td>
<p>Character value providing name of the design weight
variable in <code>dframe</code>.  For a two-stage sample, the
weight variable identifies stage two weights.  The default value is
<code>"weight"</code>.</p>
</td></tr>
<tr><td><code id="trend_analysis_+3A_xcoord">xcoord</code></td>
<td>
<p>Character value providing name of the x-coordinate variable in
<code>dframe</code>.  For a two-stage sample, the x-coordinate
variable identifies stage two x-coordinates.  Note that x-coordinates are
required  for calculation of the local mean variance estimator.  If <code>dframe</code>
is an <code>sf</code> object, this argument is not required (as the geometry column
in <code>dframe</code> is used to find the x-coordinate). The
default value is <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="trend_analysis_+3A_ycoord">ycoord</code></td>
<td>
<p>Character value providing name of the y-coordinate variable in
<code>dframe</code>.  For a two-stage sample, the y-coordinate
variable identifies stage two y-coordinates.  Note that y-coordinates are
required for calculation of the local mean variance estimator.  If <code>dframe</code>
is an <code>sf</code> object, this argument is not required (as the geometry column
in <code>dframe</code> is used to find the y-coordinate). The default
value is <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="trend_analysis_+3A_stratumid">stratumID</code></td>
<td>
<p>Character value providing name of the stratum ID variable in
<code>dframe</code>.  The default value is <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="trend_analysis_+3A_clusterid">clusterID</code></td>
<td>
<p>Character value providing name of the cluster (stage one) ID
variable in <code>dframe</code>.  Note that cluster IDs are
required for a two-stage sample.  The default value is <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="trend_analysis_+3A_weight1">weight1</code></td>
<td>
<p>Character value providing name of the stage one weight
variable in <code>dframe</code>.  The default value is <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="trend_analysis_+3A_xcoord1">xcoord1</code></td>
<td>
<p>Character value providing name of the stage one x-coordinate
variable in <code>dframe</code>.  Note that x-coordinates are
required for calculation of the local mean variance estimator.  The default
value is <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="trend_analysis_+3A_ycoord1">ycoord1</code></td>
<td>
<p>Character value providing name of the stage one y-coordinate
variable in <code>dframe</code>.  Note that y-coordinates are
required for calculation of the local mean variance estimator.  The default
value is <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="trend_analysis_+3A_sizeweight">sizeweight</code></td>
<td>
<p>Logical value that indicates whether size weights should be
used during estimation, where <code>TRUE</code> = use size weights and
<code>FALSE</code> = do not use size weights. To employ size weights for a
single-stage sample, a value must be supplied for argument weight.  To
employ size weights for a two-stage sample, values must be supplied for
arguments <code>weight</code> and <code>weight1</code>. The default value is
<code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="trend_analysis_+3A_sweight">sweight</code></td>
<td>
<p>Character value providing name of the size weight variable in
<code>dframe</code>.  For a two-stage sample, the size weight
variable identifies stage two size weights.  The default value is
<code>NULL</code>.</p>
</td></tr>
<tr><td><code id="trend_analysis_+3A_sweight1">sweight1</code></td>
<td>
<p>Character value providing name of the stage one size weight
variable in <code>dframe</code>.  The default value is
<code>NULL</code>.</p>
</td></tr>
<tr><td><code id="trend_analysis_+3A_fpc">fpc</code></td>
<td>
<p>Object that specifies values required for calculation of the
finite population correction factor used during variance estimation. The
object must match the survey design in terms of stratification and whether
the design is single-stage or two-stage.  For an unstratified design, the
object is a vector.  The vector is composed of a single numeric value for a
single-stage design.  For a two-stage unstratified design, the object is a
named vector containing one more than the number of clusters in the sample,
where the first item in the vector specifies the number of clusters in the
population and each subsequent item specifies the number of stage two units
for the cluster.  The name for the first item in the vector is arbitrary.
Subsequent names in the vector identify clusters and must match the cluster
IDs.  For a stratified design, the object is a named list of vectors, where
names must match the strata IDs.  For each stratum, the format of the
vector is identical to the format described for unstratified single-stage
and two-stage designs.  Note that the finite population correction factor
is not used with the local mean variance estimator.
</p>
<p>Example fpc for a single-stage unstratified survey design:
</p>
<p><code style="white-space: pre;">&#8288;fpc &lt;- 15000&#8288;</code>
</p>
<p>Example fpc for a single-stage stratified survey design:
</p>
<p><code style="white-space: pre;">&#8288;fpc &lt;- list(
    Stratum_1 = 9000,
    Stratum_2 = 6000)
   &#8288;</code>
</p>
<p>Example fpc for a two-stage unstratified survey design:
</p>
<p><code style="white-space: pre;">&#8288;fpc &lt;- c(
    Ncluster = 150,
    Cluster_1 = 150,
    Cluster_2 = 75,
    Cluster_3 = 75,
    Cluster_4 = 125,
    Cluster_5 = 75)
  &#8288;</code>
</p>
<p>Example fpc for a two-stage stratified survey design:
</p>
<p><code style="white-space: pre;">&#8288;fpc &lt;- list(
    Stratum_1 = c(
      Ncluster_1 = 100,
      Cluster_1 = 125,
      Cluster_2 = 100,
      Cluster_3 = 100,
      Cluster_4 = 125,
      Cluster_5 = 50),
    Stratum_2 = c(
      Ncluster_2 = 50,
      Cluster_1 = 75,
      Cluster_2 = 150,
      Cluster_3 = 75,
      Cluster_4 = 75,
      Cluster_5 = 125))
  &#8288;</code></p>
</td></tr>
<tr><td><code id="trend_analysis_+3A_popsize">popsize</code></td>
<td>
<p>Object that provides values for the population argument of the
<code>calibrate</code> or <code>postStratify</code> functions in the survey package. If
a value is provided for popsize, then either the <code>calibrate</code> or
<code>postStratify</code> function is used to modify the survey design object
that is required by functions in the survey package.  Whether to use the
<code>calibrate</code> or <code>postStratify</code> function is dictated by the format
of popsize, which is discussed below.  Post-stratification adjusts the
sampling and replicate weights so that the joint distribution of a set of
post-stratifying variables matches the known population joint distribution.
Calibration, generalized raking, or GREG estimators generalize
post-stratification and raking by calibrating a sample to the marginal
totals of variables in a linear regression model. For the <code>calibrate</code>
function, the object is a named list, where the names identify factor
variables in <code>dframe</code>.  Each element of the list is a
named vector containing the population total for each level of the
associated factor variable.  For the <code>postStratify</code> function, the
object is either a data frame, table, or xtabs object that provides the
population total for all combinations of selected factor variables in the
<code>dframe</code> data frame.  If a data frame is used for <code>popsize</code>, the
variable containing population totals must be the last variable in the data
frame.  If a table is used for <code>popsize</code>, the table must have named
<code>dimnames</code> where the names identify factor variables in the
<code>dframe</code> data frame.  If the popsize argument is equal to <code>NULL</code>,
then neither calibration nor post-stratification is performed.  The default
value is <code>NULL</code>.
</p>
<p>Example popsize for calibration:
</p>
<p><code style="white-space: pre;">&#8288;popsize &lt;- list(
    Ecoregion = c(
      East = 750,
      Central = 500,
      West = 250),
    Type = c(
      Streams = 1150,
      Rivers = 350))
  &#8288;</code>
</p>
<p>Example popsize for post-stratification using a data frame:
</p>
<p><code style="white-space: pre;">&#8288;popsize &lt;- data.frame(
    Ecoregion = rep(c("East", "Central", "West"),
      rep(2, 3)),
    Type = rep(c("Streams", "Rivers"), 3),
    Total = c(575, 175, 400, 100, 175, 75))
  &#8288;</code>
</p>
<p>Example popsize for post-stratification using a table:
</p>
<p><code style="white-space: pre;">&#8288;popsize &lt;- with(MySurveyFrame,
    table(Ecoregion, Type))&#8288;</code>
</p>
<p>Example popsize for post-stratification using an xtabs object:
</p>
<p><code style="white-space: pre;">&#8288;popsize &lt;- xtabs(~Ecoregion + Type,
    data = MySurveyFrame)&#8288;</code></p>
</td></tr>
<tr><td><code id="trend_analysis_+3A_invprboot">invprboot</code></td>
<td>
<p>Logical value that indicates whether the inverse probability
bootstrap procedure is used to calculate trend parameter estimates.  This
bootstrap procedure is only available for the &quot;LMM&quot; option for continuous
variables.  Inverse probability references the design weights, which
are the inverse of the sample inclusion probabilities.  The default value
is <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="trend_analysis_+3A_nboot">nboot</code></td>
<td>
<p>Numeric value for the number of bootstrap iterations.  The
default is <code>1000</code>.</p>
</td></tr>
<tr><td><code id="trend_analysis_+3A_vartype">vartype</code></td>
<td>
<p>Character value providing choice of the variance estimator,
where <code>"Local"</code> = the local mean estimator, <code>"SRS"</code> = the simple
random sampling estimator, <code>"HT"</code> = the Horvitz-Thompson estimator,
and <code>"YG"</code> = the Yates-Grundy estimator.  The default value is
<code>"Local"</code>.</p>
</td></tr>
<tr><td><code id="trend_analysis_+3A_jointprob">jointprob</code></td>
<td>
<p>Character value providing choice of joint inclusion
probability approximation for use with Horvitz-Thompson and Yates-Grundy
variance estimators, where <code>"overton"</code> indicates the Overton
approximation, <code>"hr"</code> indicates the Hartley_Rao approximation, and
<code>"brewer"</code> equals the Brewer approximation.  The default value is
<code>"overton"</code>.</p>
</td></tr>
<tr><td><code id="trend_analysis_+3A_conf">conf</code></td>
<td>
<p>Numeric value for the Gaussian-based confidence level.  The default is
<code>95</code>.</p>
</td></tr>
<tr><td><code id="trend_analysis_+3A_all_sites">All_Sites</code></td>
<td>
<p>A logical variable used when <code>subpops</code> is not
<code>NULL</code>. If <code>All_Sites</code> is <code>TRUE</code>, then alongside the
subpopulation output, output for all sites (ignoring subpopulations) is
returned for each variable in <code>vars</code>. If <code>All_Sites</code> is
<code>FALSE</code>, then alongside the subpopulation output, output for all sites
(ignoring subpopulations) is not returned for each variable in <code>vars</code>.
The default is <code>FALSE</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The analysis results. A list composed of two data frames containing trend estimates for all
combinations of population Types, subpopulations within Types, and response
variables.  For categorical variables, trend estimates are calculated for
each category of the variable.  The two data frames in the output list are:
</p>

<dl>
<dt><code>catsum</code></dt><dd><p>data frame containing trend estimates for
categorical variables</p>
</dd>
<dt><code>contsum</code></dt><dd><p>data frame containing trend
estimates for continuous variables</p>
</dd>
</dl>

<p>For the SLR and WLR model options, the data frame contains the following
variables:
</p>

<dl>
<dt>Type</dt><dd><p>subpopulation (domain) name</p>
</dd>
<dt>Subpopulation</dt><dd><p>subpopulation name within a domain</p>
</dd>
<dt>Indicator</dt><dd><p>response variable</p>
</dd>
<dt>Trend_Estimate</dt><dd><p>trend estimate</p>
</dd>
<dt>Trend_Std_Error</dt><dd><p>trend standard error</p>
</dd>
<dt>Trend_LCBxxPct</dt><dd><p>trend xx% (default 95%) lower confidence bound</p>
</dd>
<dt>Trend_UCBxxPct</dt><dd><p>trend xx% (default 95%) upper confidence bound</p>
</dd>
<dt>Trend_p_Value</dt><dd><p>trend p-value</p>
</dd>
<dt>Intercept_Estimate</dt><dd><p>intercept estimate</p>
</dd>
<dt>Intercept_Std_Error</dt><dd><p>intercept standard error</p>
</dd>
<dt>Intercept_LCBxxPct</dt><dd><p>intercept xx% (default 95%) lower confidence
bound</p>
</dd>
<dt>Intercept_UCBxxPct</dt><dd><p>intercept xx% (default 95%) upper confidence
bound</p>
</dd>
<dt>Intercept_p_Value</dt><dd><p>intercept p-value</p>
</dd>
<dt>R_Squared</dt><dd><p>R-squared value</p>
</dd>
<dt>Adj_R_Squared</dt><dd><p>adjusted R-squared value</p>
</dd>
</dl>

<p>For the GLMM and LMM model options, contents of the data frames will vary
depending on the model specified by arguments <code>cat_rhs</code> and
<code>cont_rhs</code>.  For the default PO model, the data frame contains the
following variables:
</p>

<dl>
<dt>Type</dt><dd><p>subpopulation (domain) name</p>
</dd>
<dt>Subpopulation</dt><dd><p>subpopulation name within a domain</p>
</dd>
<dt>Indicator</dt><dd><p>response variable</p>
</dd>
<dt>Trend_Estimate</dt><dd><p>trend estimate</p>
</dd>
<dt>Trend_Std_Error</dt><dd><p>trend standard error</p>
</dd>
<dt>Trend_LCBxxPct</dt><dd><p>trend xx% (default 95%) lower confidence bound</p>
</dd>
<dt>Trend_UCBxxPct</dt><dd><p>trend xx% (default 95%) upper confidence bound</p>
</dd>
<dt>Trend_p_Value</dt><dd><p>trend p-value</p>
</dd>
<dt>Intercept_Estimate</dt><dd><p>intercept estimate</p>
</dd>
<dt>Intercept_Std_Error</dt><dd><p>intercept standard error</p>
</dd>
<dt>Intercept_LCBxxPct</dt><dd><p>intercept xx% (default 95%) lower confidence
bound</p>
</dd>
<dt>Intercept_UCBxxPct</dt><dd><p>intercept xx% (default 95%) upper confidence
bound</p>
</dd>
<dt>Intercept_p_Value</dt><dd><p>intercept p-value</p>
</dd>
<dt>Var_SiteInt</dt><dd><p>variance of the site intercepts</p>
</dd>
<dt>Var_SiteTrend</dt><dd><p>variance of the site trends</p>
</dd>
<dt>Corr_SiteIntSlope</dt><dd><p>correlation of site intercepts and site trends</p>
</dd>
<dt>Var_Year</dt><dd><p>year variance</p>
</dd>
<dt>Var_Residual</dt><dd><p>residual variance</p>
</dd>
<dt>AIC</dt><dd><p>generalized Akaike Information Criterion</p>
</dd>
</dl>



<h3>Details</h3>

<p>For the simple linear regression (SLR) model, a design-based estimate of the
category proportion (categorical variables) or the mean (continuous
variables) is calculated for each time period (year).  Four choices of
variance estimator are available for calculating variance of the design-based
estimates: (1) the local mean estimator, (2) the simple random sampling
estimator, (3) the Horvitz-Thompson estimator, and (4) the Yates-Grundy
estimator.  For the Horvitz-Thompson and Yates-Grundy estimators, there are
three choices for calculating joint inclusion probabilities: (1) the Overton
approximation, (2) the Hartley-Rao approximation, and (3) the Brewer
approximation.  The <code>lm</code> function in the stats package is used to fit a
linear model using a <code>formula</code> argument that specifies the proportion or
mean estimates as the response variable and years as the regressor variable.
For fitting the SLR model, the <code>yearID</code> variable from the <code>dframe</code>
argument is modified by subtracting the minimum value of years from all
values of the variable.  Parameter estimates are extracted from the object
returned by the <code>lm</code> function.  For the weighted linear regression (WLR)
model, the process is the same as the SLR model except that the inverse of
the variances of the proportion or mean estimates is used as the
<code>weights</code> argument in the call to the <code>lm</code> function.  For the LMM
option, the <code>lmer</code> function in the lme4 package is used to fit a linear
mixed-effects model for trend across years.  For both the GLMM and LMM
options, the default Piepho and Ogutu (PO) model includes fixed effects for
intercept and trend (slope) and random effects for intercept and trend for
individual sites, where the <code>siteID</code> variable from the <code>dframe</code>
argument identifies sites.  Correlation between the random effects for site
intercepts and site trends is included in the model. Finally, the PO model
contains random effects for year variance and residual variance. For the GLMM
and LMM options, arguments <code>cat_rhs</code> and <code>cont_rhs</code>, respectively,
can be used to specify the right hand side of the model formula. Internally,
a variable named <code>Wyear</code> is created that is useful for specifying the
<code>cat_rhs</code> and <code>cont_rhs</code> arguments.  The <code>Wyear</code> variable is
created by subtracting the minimum value of the <code>yearID</code> variable from
all values of the variable.  If argument <code>invprboot</code> is <code>FALSE</code>,
parameter estimates are extracted from the object returned by the <code>lmer</code>
function. If argument <code>invprboot</code> is <code>TRUE</code>, the <code>boot</code>
function in the boot package is used to generate bootstrap replicates using a
function named <code>bootfcn</code> as the <code>statistic</code> argument passed to the
<code>boot</code> function.  For each bootstrap replicate, <code>bootfcn</code> calls the
<code>glmer</code> or <code>lmer</code> function, as appropriate, using the specified
model.  design weights identified by the <code>weight</code> argument for
the <code>trend_analysis</code> function are passed as the <code>weights</code> argument
for the <code>boot</code> function, which specifies importance weights.  Using the
design weights as the <code>weights</code> argument ensures that bootstrap
replicates are representative of the survey population.  Parameter estimates
are calculated using the object returned by the <code>boot</code> function.
</p>


<h3>Author(s)</h3>

<p>Tom Kincaid <a href="mailto:Kincaid.Tom@epa.gov">Kincaid.Tom@epa.gov</a>
</p>


<h3>See Also</h3>


<dl>
<dt><code><a href="#topic+change_analysis">change_analysis</a></code></dt><dd><p>for change analysis</p>
</dd>
</dl>



<h3>Examples</h3>

<pre><code class='language-R'># Example using a categorical variable with three resource classes and a
# continuous variable
mydframe &lt;- data.frame(
  siteID = rep(paste0("Site", 1:40), rep(5, 40)),
  yearID = rep(seq(2000, 2020, by = 5), 40),
  wgt = rep(runif(40, 10, 100), rep(5, 40)),
  xcoord = rep(runif(40), rep(5, 40)),
  ycoord = rep(runif(40), rep(5, 40)),
  All_Sites = rep("All Sites", 200),
  Region = sample(c("North", "South"), 200, replace = TRUE),
  Resource_Class = sample(c("Good", "Fair", "Poor"), 200, replace = TRUE),
  ContVar = rnorm(200, 10, 1)
)
myvars_cat &lt;- c("Resource_Class")
myvars_cont &lt;- c("ContVar")
mysubpops &lt;- c("All_Sites", "Region")
trend_analysis(
  dframe = mydframe,
  vars_cat = myvars_cat,
  vars_cont = myvars_cont,
  subpops = mysubpops,
  model_cat = "WLR",
  model_cont = "SLR",
  siteID = "siteID",
  yearID = "yearID",
  weight = "wgt",
  xcoord = "xcoord",
  ycoord = "ycoord"
)
</code></pre>

<hr>
<h2 id='warnprnt'>Print grts(), irs()), and analysis function warnings</h2><span id='topic+warnprnt'></span>

<h3>Description</h3>

<p>This function prints the warnings messages from the <code>grts()</code>, <code>irs()</code>,
and analysis functions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>warnprnt(warn_df = get("warn_df", envir = .GlobalEnv), m = 1:nrow(warn_df))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="warnprnt_+3A_warn_df">warn_df</code></td>
<td>
<p>Data frame that contains warning messages.  The default is
<code>"warn_df"</code>, which is the name given to the warnings data frame created by
functions in the spsurvey package.</p>
</td></tr>
<tr><td><code id="warnprnt_+3A_m">m</code></td>
<td>
<p>Vector of indices for warning messages that are to be printed. The
default is a vector containing the integers from 1 through the number of
rows in <code>warn_df</code>, which will print all warning messages in the data frame.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Printed warnings.
</p>


<h3>Author(s)</h3>

<p>Tom Kincaid <a href="mailto:Kincaid.Tom@epa.gov">Kincaid.Tom@epa.gov</a>
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
