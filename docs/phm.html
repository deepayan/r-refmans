<!DOCTYPE html><html><head><title>Help for package phm</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {phm}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#phm-package'>
<p>Phrase Mining</p></a></li>
<li><a href='#as.matrix.phraseDoc'><p>Convert a phraseDoc Object to a Matrix</p></a></li>
<li><a href='#bestDocs'><p>Find Informative Documents in a Corpus</p></a></li>
<li><a href='#canberra'><p>Calculate Canberra Distance</p></a></li>
<li><a href='#DFSource'><p>Create a DFSource object from a data frame</p></a></li>
<li><a href='#distMatrix'><p>Calculate a Distance Matrix</p></a></li>
<li><a href='#freqPhrases'><p>Display Frequent Principal Phrases</p></a></li>
<li><a href='#getDocs'><p>Display Frequency Matrix for Phrases</p></a></li>
<li><a href='#getElem.DFSource'><p>Obtain the current row of the content of a DFSource</p></a></li>
<li><a href='#getPhrases'><p>Display Frequency Matrix for Documents</p></a></li>
<li><a href='#getPubMed'><p>Create a data table from a text file in PubMed format</p></a></li>
<li><a href='#phraseDoc'><p>phraseDoc Creation</p></a></li>
<li><a href='#print.phraseDoc'><p>Print a phraseDoc Object</p></a></li>
<li><a href='#print.textCluster'><p>Print a textCluster Object</p></a></li>
<li><a href='#readDF'><p>Create a PlainTextDocument from a row in a data frame</p></a></li>
<li><a href='#removePhrases'><p>Remove Phrases from phraseDoc Object</p></a></li>
<li><a href='#showCluster'><p>Show Cluster Contents</p></a></li>
<li><a href='#stopEndWords'><p>Words that Principal Phrases do not End with</p></a></li>
<li><a href='#stopPhrases'><p>Phrases that are not Principal Phrases</p></a></li>
<li><a href='#stopStartWords'><p>Words that Principal Phrases do not Start with</p></a></li>
<li><a href='#textCluster'><p>Cluster a Term-Document Matrix</p></a></li>
<li><a href='#textDist'><p>Calculate Text Distance</p></a></li>
<li><a href='#textDistMatrix'><p>Calculate a Text Distance Matrix</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Phrase Mining</td>
</tr>
<tr>
<td>Version:</td>
<td>1.1.2</td>
</tr>
<tr>
<td>Date:</td>
<td>2024-01-26</td>
</tr>
<tr>
<td>Description:</td>
<td>Functions to extract and handle commonly occurring principal phrases
    obtained from collections of texts.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>Imports:</td>
<td>data.table (&ge; 1.14.2), tm (&ge; 0.7-8), shiny (&ge; 1.7.1),
Matrix (&ge; 1.4-1), smallstuff (&ge; 1.0.1), NLP (&ge; 0.2-1)</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.3.1</td>
</tr>
<tr>
<td>Suggests:</td>
<td>knitr, rmarkdown</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-01-26 22:23:49 UTC; esmall1</td>
</tr>
<tr>
<td>Author:</td>
<td>Ellie Small <a href="https://orcid.org/0000-0003-1313-115X"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [aut,
    cre]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Ellie Small &lt;esmall1@drew.edu&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-01-27 00:00:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='phm-package'>
Phrase Mining
</h2><span id='topic+phm-package'></span><span id='topic+phm'></span>

<h3>Description</h3>

<p>Obtain all principal phrases from a corpus or a collection of texts and their 
frequencies in each of those texts. A principal phrase is a phrase that does 
not cross punctuation marks, does not start with a stop word, with the 
exception of the stop words &quot;not&quot; and &quot;no&quot;, does not end with a stop word, is 
frequent within those texts without being double counted, and is meaningful to
the user.
</p>


<h3>Details</h3>

<p>The function PhraseDoc will extract all principal phrases from a corpus with
documents or a character vector with texts and creates an object of class
phraseDoc. The method as.matrix on a phraseDoc object converts the phraseDoc
to a term-frequency matrix. The function freqPhrases displays the most 
frequent principal phrases in a phraseDoc object. The function getDocs will
create a frequency matrix with all documents/texts that contain certain 
phrases, while getPhrases will create a frequency matrix with all phrases
present in a specific collection of documents/texts.
</p>


<h3>Author(s)</h3>

<p>Ellie Small
</p>
<p>Maintainer: Ellie Small &lt;esmall1@drew.edu&gt;
</p>

<hr>
<h2 id='as.matrix.phraseDoc'>Convert a phraseDoc Object to a Matrix</h2><span id='topic+as.matrix.phraseDoc'></span>

<h3>Description</h3>

<p>Convert a phraseDoc Object to a Matrix
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'phraseDoc'
as.matrix(x, ids = TRUE, sparse = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="as.matrix.phraseDoc_+3A_x">x</code></td>
<td>
<p>A phraseDoc object.</p>
</td></tr>
<tr><td><code id="as.matrix.phraseDoc_+3A_ids">ids</code></td>
<td>
<p>A logical value with TRUE (default) to use ids (if available), 
FALSE to use indices</p>
</td></tr>
<tr><td><code id="as.matrix.phraseDoc_+3A_sparse">sparse</code></td>
<td>
<p>A logical value indicates whether a sparse matrix should be
returned (default FALSE)</p>
</td></tr>
<tr><td><code id="as.matrix.phraseDoc_+3A_...">...</code></td>
<td>
<p>Additional arguments</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix with phrases as rows, texts as columns, and elements
containing the number of times the phrase occurs in the text
</p>


<h3>Examples</h3>

<pre><code class='language-R'>tst=c("This is a test text",
      "This is a test text 2",
      "This is another test text",
      "This is another test text 2",
      "This girl will test text that man",
      "This boy will test text that man")
pd=phraseDoc(tst)
as.matrix(pd)
</code></pre>

<hr>
<h2 id='bestDocs'>Find Informative Documents in a Corpus</h2><span id='topic+bestDocs'></span>

<h3>Description</h3>

<p>Find the documents in a corpus that have the most high frequency
phrases and return a corpus with just those documents
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bestDocs(co, num = 3L, n = 10L, pd = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bestDocs_+3A_co">co</code></td>
<td>
<p>A corpus with documents</p>
</td></tr>
<tr><td><code id="bestDocs_+3A_num">num</code></td>
<td>
<p>Integer with the number of documents to return</p>
</td></tr>
<tr><td><code id="bestDocs_+3A_n">n</code></td>
<td>
<p>Integer with the number of high frequency phrases to use</p>
</td></tr>
<tr><td><code id="bestDocs_+3A_pd">pd</code></td>
<td>
<p>phraseDoc object for the corpus in <code>co</code>; if NULL, a
phraseDoc will be created for it.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A corpus with the <code>num</code> documents that have the most
high frequency phrases, in order of the number of high frequency
phrases. The corpus returned will have the meta field oldIdx set
to the index of the document in the original corpus, and the meta
field hfPhrases to the number of high frequency phrases it contains.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>v1=c("Here is some text to test phrase mining","phrase mining is fun",
  "Some text is better than no text","No text, no phrase mining")
co=tm::VCorpus(tm::VectorSource(v1))
pd=phraseDoc(co,min.freq=2)
bestDocs(co,2,2,pd)
</code></pre>

<hr>
<h2 id='canberra'>Calculate Canberra Distance</h2><span id='topic+canberra'></span>

<h3>Description</h3>

<p>When two vectors are given, this calculates the Canberra distance between
them; This is calculated as the sum of the absolute difference between 
corresponding elements divided by the sum of their absolute values, for 
elements that are not both zero only.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>canberra(x, y)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="canberra_+3A_x">x</code></td>
<td>
<p>A numeric vector</p>
</td></tr>
<tr><td><code id="canberra_+3A_y">y</code></td>
<td>
<p>A numeric vector of the same dimension as x</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The Canberra distance between x and y. For example, between vectors
(1,2,0) and (0,1,1), for position 1 we have (1-0)/1, for position 2 we have
(2-1)/3, and for position 3 we have abs(0-1)/1, added together this results
in 2 1/3, or 2.33. Note that a text distance of zero indicates that the
two vectors are equal, while a text distance of 1 indicates that they have
no terms in common.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>canberra(c(1,2,0),c(0,1,1))
</code></pre>

<hr>
<h2 id='DFSource'>Create a DFSource object from a data frame</h2><span id='topic+DFSource'></span>

<h3>Description</h3>

<p>This function will create a DFSource object from a data frame that contains
at least columns id and text, but may contain several more. VCorpus will
use this to read in each row from the data frame into a PlainTextDocument,
storing additional variables in its metadata. It will then combine all those 
PlainTextDocuments in a VCorpus object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>DFSource(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="DFSource_+3A_x">x</code></td>
<td>
<p>A dataframe with at a minimum a text and id column,
and a row for each document to be stored in a corpus.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A DFSource object containing the encoding set to &quot;&quot;, the number
of rows (length), the current position (position=0), the type of
reader to use (reader=readDF), and the content (<code>x</code>).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>(df=data.frame(id=1:3,text=c("First text","Second text","Third text"),
               title=c("N1","N2","N3")))
DFSource(df)
</code></pre>

<hr>
<h2 id='distMatrix'>Calculate a Distance Matrix</h2><span id='topic+distMatrix'></span>

<h3>Description</h3>

<p>Calculate a distance matrix for a numeric matrix, where a distance function
is used to calculate the distance between all combinations of the columns
of the matrix <code>M</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>distMatrix(M, fn = "textDist", ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="distMatrix_+3A_m">M</code></td>
<td>
<p>A numeric matrix</p>
</td></tr>
<tr><td><code id="distMatrix_+3A_fn">fn</code></td>
<td>
<p>The name of a distance function, default is &quot;textDist&quot;.</p>
</td></tr>
<tr><td><code id="distMatrix_+3A_...">...</code></td>
<td>
<p>Additional arguments to be passed to the distance function</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The distance matrix with the distance between all combinations
of the columns of <code>M</code> according to the distance function in <code>fn</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>M=matrix(c(0,1,0,2,0,10,0,14,12,0,8,0,1,0,1,0),4)
colnames(M)=1:4;rownames(M)=c("A","B","C","D")
M
#Text distance matrix
distMatrix(M)
#Canberra distance matrix
distMatrix(M,"canberra")
</code></pre>

<hr>
<h2 id='freqPhrases'>Display Frequent Principal Phrases</h2><span id='topic+freqPhrases'></span>

<h3>Description</h3>

<p>Display the most frequent principal phrases in a phraseDoc object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>freqPhrases(pd, n = 10)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="freqPhrases_+3A_pd">pd</code></td>
<td>
<p>A phraseDoc object.</p>
</td></tr>
<tr><td><code id="freqPhrases_+3A_n">n</code></td>
<td>
<p>Number of principal phrases to display.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector with the <code>n</code> most frequent principal phrases and their
frequencies.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>tst=c("This is a test text",
      "This is a test text 2",
      "This is another test text",
      "This is another test text 2",
      "This girl will test text that man",
      "This boy will test text that man")
pd=phraseDoc(tst)
freqPhrases(pd, 2)
</code></pre>

<hr>
<h2 id='getDocs'>Display Frequency Matrix for Phrases</h2><span id='topic+getDocs'></span>

<h3>Description</h3>

<p>Display a frequency matrix containing all the documents that contain any of
the phrases in phrs and the number of times they occur in that document.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getDocs(pd, phrs, ids = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getDocs_+3A_pd">pd</code></td>
<td>
<p>A phraseDoc object.</p>
</td></tr>
<tr><td><code id="getDocs_+3A_phrs">phrs</code></td>
<td>
<p>A set of phrases.</p>
</td></tr>
<tr><td><code id="getDocs_+3A_ids">ids</code></td>
<td>
<p>A logical value with TRUE (default) to return ids (if available), 
FALSE to return indices.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix with the documents and # of occurrences for the phrases in
phrs.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>tst=c("This is a test text",
      "This is a test text 2",
      "This is another test text",
      "This is another test text 2",
      "This girl will test text that man",
      "This boy will test text that man")
pd=phraseDoc(tst)
getDocs(pd, c("test text","another test text"))
</code></pre>

<hr>
<h2 id='getElem.DFSource'>Obtain the current row of the content of a DFSource</h2><span id='topic+getElem.DFSource'></span>

<h3>Description</h3>

<p>Using the position field of x to indicate the index of the current row, we
retrieve the current row of the content of a DFSource. This function is
mainly used by the VCorpus function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'DFSource'
getElem(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getElem.DFSource_+3A_x">x</code></td>
<td>
<p>A DFSource object</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with the current row in the content of a DFSource object.
The current row index is the position in the DFSource object.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(tm)
df=data.frame(id=1:3,text=c("First text","Second text","Third text"),
              title=c("N1","N2","N3"))
getElem(stepNext(DFSource(df)))
</code></pre>

<hr>
<h2 id='getPhrases'>Display Frequency Matrix for Documents</h2><span id='topic+getPhrases'></span>

<h3>Description</h3>

<p>Display a frequency matrix containing all the documents for which the indices
are given in docs with their principal phrases and the number of times they
occur in each document.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getPhrases(pd, doc, ids = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getPhrases_+3A_pd">pd</code></td>
<td>
<p>A phraseDoc object</p>
</td></tr>
<tr><td><code id="getPhrases_+3A_doc">doc</code></td>
<td>
<p>An integer vector containing indices of documents, or a character
vector containing the ids of documents (column names)</p>
</td></tr>
<tr><td><code id="getPhrases_+3A_ids">ids</code></td>
<td>
<p>A logical value with TRUE (default) to return ids (if available), 
FALSE to return indices</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix with the documents and # of occurrences of principal phrases
for the documents in <code>docs</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>tst=c("This is a test text",
      "This is a test text 2",
      "This is another test text",
      "This is another test text 2",
      "This girl will test text that man",
      "This boy will test text that man")
pd=phraseDoc(tst)
getPhrases(pd, c(1,3))
</code></pre>

<hr>
<h2 id='getPubMed'>Create a data table from a text file in PubMed format</h2><span id='topic+getPubMed'></span>

<h3>Description</h3>

<p>This function takes as input a file produced via PubMed in PubMed format
and outputs a data frame with the id equal to the PMID, text equal to the
abstract, date, title, and author for each publication in the file.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getPubMed(file)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getPubMed_+3A_file">file</code></td>
<td>
<p>path to the PubMed file</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data table with a row for each publication holding the id
equal to the PMID, text equal to the abstract, date, title, and author for
that publication.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#Go to Pubmed and enter search criteria, save the result to PubMed format.
#If the file is called pubmed_result.txt and located in the current
#directory:
#PM=getPubMed("pubmed_result.txt")
#Will load the data from the search into a data table called PM
</code></pre>

<hr>
<h2 id='phraseDoc'>phraseDoc Creation</h2><span id='topic+phraseDoc'></span>

<h3>Description</h3>

<p>Create an object of class phraseDoc. This will hold all principal phrases of
a collection of texts that occur a minimum number of times, plus the texts
they occur in and their position within those texts.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>phraseDoc(
  co,
  mn = 2,
  mx = 8,
  ssw = stopStartWords(),
  sew = stopEndWords(),
  sp = stopPhrases(),
  min.freq = 2,
  principal = function(phrase, freq) {
     freq &gt;= min.freq
 },
  max.phrases = 1500,
  shiny = FALSE,
  silent = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="phraseDoc_+3A_co">co</code></td>
<td>
<p>A corpus or a character vector with each element the text of a 
document.</p>
</td></tr>
<tr><td><code id="phraseDoc_+3A_mn">mn</code></td>
<td>
<p>Minimum number of words in a phrase.</p>
</td></tr>
<tr><td><code id="phraseDoc_+3A_mx">mx</code></td>
<td>
<p>Maximum number of words in a phrase.</p>
</td></tr>
<tr><td><code id="phraseDoc_+3A_ssw">ssw</code></td>
<td>
<p>A set of words no phrase should start with.</p>
</td></tr>
<tr><td><code id="phraseDoc_+3A_sew">sew</code></td>
<td>
<p>A set of words no phrase should end with.</p>
</td></tr>
<tr><td><code id="phraseDoc_+3A_sp">sp</code></td>
<td>
<p>A set of phrases to be excluded.</p>
</td></tr>
<tr><td><code id="phraseDoc_+3A_min.freq">min.freq</code></td>
<td>
<p>The minimum frequency of phrases to be included.</p>
</td></tr>
<tr><td><code id="phraseDoc_+3A_principal">principal</code></td>
<td>
<p>Function that determines if a phrase is a principal phrase. 
By default, FALSE is returned if the phrase occurs less often than the number
in <code>min.freq</code>.</p>
</td></tr>
<tr><td><code id="phraseDoc_+3A_max.phrases">max.phrases</code></td>
<td>
<p>Maximum number of phrases to be included.</p>
</td></tr>
<tr><td><code id="phraseDoc_+3A_shiny">shiny</code></td>
<td>
<p>TRUE if called from a shiny program. This will allow progress
to be recorded on a progress meter; the function uses about 100 progress
steps, so it should be created inside a withProgress function with the 
argument max set to at least 100.</p>
</td></tr>
<tr><td><code id="phraseDoc_+3A_silent">silent</code></td>
<td>
<p>TRUE if you do not want progress messages.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Object of class phraseDoc
</p>


<h3>Examples</h3>

<pre><code class='language-R'>tst=c("This is a test text",
      "This is a test text 2",
      "This is another test text",
      "This is another test text 2",
      "This girl will test text that man",
      "This boy will test text that man")
phraseDoc(tst)
</code></pre>

<hr>
<h2 id='print.phraseDoc'>Print a phraseDoc Object</h2><span id='topic+print.phraseDoc'></span>

<h3>Description</h3>

<p>Print a phraseDoc Object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'phraseDoc'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.phraseDoc_+3A_x">x</code></td>
<td>
<p>Object of type phraseDoc</p>
</td></tr>
<tr><td><code id="print.phraseDoc_+3A_...">...</code></td>
<td>
<p>Additional arguments</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>tst=c("This is a test text",
      "This is a test text 2",
      "This is another test text",
      "This is another test text 2",
      "This girl will test text that man",
      "This boy will test text that man")
(pd=phraseDoc(tst))
</code></pre>

<hr>
<h2 id='print.textCluster'>Print a textCluster Object</h2><span id='topic+print.textCluster'></span>

<h3>Description</h3>

<p>Print a textCluster Object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'textCluster'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.textCluster_+3A_x">x</code></td>
<td>
<p>Object of type textCluster</p>
</td></tr>
<tr><td><code id="print.textCluster_+3A_...">...</code></td>
<td>
<p>Additional arguments</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The total number of clusters and total number of documents are 
printed. There is no return value.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>M=matrix(c(0,1,0,2,0,10,0,14,12,0,8,0,1,0,1,0),4)
colnames(M)=1:4;rownames(M)=c("A","B","C","D")
tc=textCluster(M,2)
tc
</code></pre>

<hr>
<h2 id='readDF'>Create a PlainTextDocument from a row in a data frame</h2><span id='topic+readDF'></span>

<h3>Description</h3>

<p>Read a row of the content of a DFSource object into a PlainTextDocument.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>readDF(elem, language, id = "1")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="readDF_+3A_elem">elem</code></td>
<td>
<p>A list containing the field content containing one
row with data from a data frame containing at least the columns id and text,
but possibly more.</p>
</td></tr>
<tr><td><code id="readDF_+3A_language">language</code></td>
<td>
<p>abbreviation of the language used; &quot;en&quot; for English</p>
</td></tr>
<tr><td><code id="readDF_+3A_id">id</code></td>
<td>
<p>Not used, but needed for VCorpus</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A PlainTextDocument with content equal to the contents of the
text field, and meta data containing the information in the remaining
fields, including the id field
</p>


<h3>Examples</h3>

<pre><code class='language-R'>(df=data.frame(id=1:3,text=c("First text","Second text","Third text"),
               title=c("N1","N2","N3")))
readDF(list(content=df[1,]),"en")
</code></pre>

<hr>
<h2 id='removePhrases'>Remove Phrases from phraseDoc Object</h2><span id='topic+removePhrases'></span>

<h3>Description</h3>

<p>Remove a set of phrases from a phraseDoc object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>removePhrases(pd, phrs)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="removePhrases_+3A_pd">pd</code></td>
<td>
<p>A phraseDoc object.</p>
</td></tr>
<tr><td><code id="removePhrases_+3A_phrs">phrs</code></td>
<td>
<p>A set of phrases.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A phraseDoc object with the phrases in <code>phrs</code> removed.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>tst=c("This is a test text",
      "This is a test text 2",
      "This is another test text",
      "This is another test text 2",
      "This girl will test text that man",
      "This boy will test text that man")
pd=phraseDoc(tst)
removePhrases(pd, c("test text","another test text"))
</code></pre>

<hr>
<h2 id='showCluster'>Show Cluster Contents</h2><span id='topic+showCluster'></span>

<h3>Description</h3>

<p>Show all documents and their non-zero terms in a cluster, with the terms
first ordered by highest number of documents the term appears in, then total
frequency.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>showCluster(tdm, clust, cl, n = 10L)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="showCluster_+3A_tdm">tdm</code></td>
<td>
<p>A term frequency matrix.</p>
</td></tr>
<tr><td><code id="showCluster_+3A_clust">clust</code></td>
<td>
<p>A vector indicating for each column in <code>tdm</code> what cluster
they belong to</p>
</td></tr>
<tr><td><code id="showCluster_+3A_cl">cl</code></td>
<td>
<p>Cluster number</p>
</td></tr>
<tr><td><code id="showCluster_+3A_n">n</code></td>
<td>
<p>Integer showing the maximum number of terms to be returned (default 10)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix with document names of <code>tdm</code> on the columns and terms
on the rows for all columns in the cluster, where terms that appear in the
most documents (columns), and within that have the highest frequency in the
cluster, are shown first. Two columns are added at the end of the matrix
with the the number of documents each term appears in and its total frequency
in the cluster. The number of terms displayed equals the number in <code>n</code>, 
or less if there are less terms in the cluster.
If there are no terms at all in the cluster, a list is output with the items
docs and note, where docs is a vector with all document names of documents in 
the cluster, and the note stating that the cluster has no terms.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>M=matrix(c(0,1,0,2,0,10,0,14,12,0,8,0,1,0,1,0),4)
colnames(M)=1:4;rownames(M)=c("A","B","C","D")
tc=textCluster(M,2)
showCluster(M,tc$cluster,1)
</code></pre>

<hr>
<h2 id='stopEndWords'>Words that Principal Phrases do not End with</h2><span id='topic+stopEndWords'></span>

<h3>Description</h3>

<p>Create a vector with words that principal phrases should not end with.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>stopEndWords()
</code></pre>


<h3>Value</h3>

<p>vector with words
</p>


<h3>Examples</h3>

<pre><code class='language-R'>stopEndWords()
</code></pre>

<hr>
<h2 id='stopPhrases'>Phrases that are not Principal Phrases</h2><span id='topic+stopPhrases'></span>

<h3>Description</h3>

<p>Create a vector with phrases that are not principal phrases.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>stopPhrases()
</code></pre>


<h3>Value</h3>

<p>vector with phrases
</p>


<h3>Examples</h3>

<pre><code class='language-R'>stopPhrases()
</code></pre>

<hr>
<h2 id='stopStartWords'>Words that Principal Phrases do not Start with</h2><span id='topic+stopStartWords'></span>

<h3>Description</h3>

<p>Create a vector with words that principal phrases should not start with.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>stopStartWords()
</code></pre>


<h3>Value</h3>

<p>vector with words
</p>


<h3>Examples</h3>

<pre><code class='language-R'>stopStartWords()
</code></pre>

<hr>
<h2 id='textCluster'>Cluster a Term-Document Matrix</h2><span id='topic+textCluster'></span>

<h3>Description</h3>

<p>Combine documents (columns) into k clusters that have texts that are most
similar based on their text distance. Documents with no terms are assigned
to the last cluster.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>textCluster(tdm, k, mx = 100, md = 5 * k)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="textCluster_+3A_tdm">tdm</code></td>
<td>
<p>A term document matrix with terms on the rows and documents on 
the columns.</p>
</td></tr>
<tr><td><code id="textCluster_+3A_k">k</code></td>
<td>
<p>A positive integer with the number of clusters needed</p>
</td></tr>
<tr><td><code id="textCluster_+3A_mx">mx</code></td>
<td>
<p>Maximum number of times to iterate (default 100)</p>
</td></tr>
<tr><td><code id="textCluster_+3A_md">md</code></td>
<td>
<p>Maximum number of documents to use for the initial setup (default 
5*<code>k</code>).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A textcluster object with three items; cluster, centroids, and size,
where cluster contains a vector indicating for each column in <code>M</code> what
cluster they have been assigned to, centroids contains a matrix with each
column the centroid of a cluster, and size a named vector with the size of
each cluster.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>M=matrix(c(0,1,0,2,0,10,0,14,12,0,8,0,1,0,1,0),4)
colnames(M)=1:4;rownames(M)=c("A","B","C","D")
textCluster(M,2)
</code></pre>

<hr>
<h2 id='textDist'>Calculate Text Distance</h2><span id='topic+textDist'></span>

<h3>Description</h3>

<p>When two vectors are given, this calculates the text distance between them;
text distance is calculated as the proportion of unmatched frequencies, i.e.,
the number of unmatched frequencies divided by the total frequencies among
the two vectors. However, if neither vector has any values
at all, their distance equals the number provided in the zeroes argument,
which is .5 by default. When two matrices are given, the text distance
between corresponding columns is calculated.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>textDist(x, y, zeroes = 0.5)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="textDist_+3A_x">x</code></td>
<td>
<p>A numeric vector or matrix</p>
</td></tr>
<tr><td><code id="textDist_+3A_y">y</code></td>
<td>
<p>A numeric vector or matrix of the same dimension as x</p>
</td></tr>
<tr><td><code id="textDist_+3A_zeroes">zeroes</code></td>
<td>
<p>Text distance when both vectors are zero vectors; default is .5</p>
</td></tr>
</table>


<h3>Value</h3>

<p>When x and y are vectors, the text distance between them. For
example, between vectors (1,2,0) and (0,1,1), a total of 5 frequencies are 
present. However, position 1 matches nothing when it could have
matched 1 frequency, position 2 matches 1 frequency when it could have  
matched both positions, so 1 remains unmatched. Position 3 matches nothing  
when it could have matched 1. So we have 3 unmatched positions divided by 5 
frequencies, resulting in a text distance of 3/5=.6. If x and y are matrices, 
a vector with the text distance between corresponding columns is returned. So 
for two 4x2 matrices, a vector with two values is returned, one with the text 
distance between the first columns of the matrices, and the second one with 
the text distance between the second columns of the matrices. For large sets 
of data, it is recommended to use matrices as it is much more efficient than 
calculating column by column.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#text distance between two vectors
textDist(c(1,2,0),c(0,1,1))
(M1=matrix(c(0,1,0,2,0,10,0,14),4))
(M2=matrix(c(12,0,8,0,1,3,1,2),4))
#text distance between corresponding columns of M1 and M2
textDist(M1,M2)
</code></pre>

<hr>
<h2 id='textDistMatrix'>Calculate a Text Distance Matrix</h2><span id='topic+textDistMatrix'></span>

<h3>Description</h3>

<p>Calculate a distance matrix for a numeric matrix, using the textDist
function. It is used to calculate the text distance between all combinations 
of the columns of the matrix <code>M</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>textDistMatrix(M, zeroes = 0.5)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="textDistMatrix_+3A_m">M</code></td>
<td>
<p>A numeric matrix</p>
</td></tr>
<tr><td><code id="textDistMatrix_+3A_zeroes">zeroes</code></td>
<td>
<p>Text distance when both vectors are zero vectors; default is .5</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The text distance matrix with the text distance between all
combinations of the columns of <code>M</code>. This will give the same result as 
the function distMatrix when run with its default distance function 
&quot;textDist&quot;; however, for large matrices textDistMatrix is much more 
efficient. In addition, for very large matrices distMatrix may not run, 
while textDistMatrix will.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>M=matrix(c(0,1,0,2,0,10,0,14,12,0,8,0,1,0,1,0),4)
colnames(M)=1:4;rownames(M)=c("A","B","C","D")
M
#Text distance matrix
textDistMatrix(M)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
