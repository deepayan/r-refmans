<!DOCTYPE html><html><head><title>Help for package QCAcluster</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {QCAcluster}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#Grauvogel2014'><p>Original data used by Grauvogel/von Soest (2014)</p></a></li>
<li><a href='#partition_div'><p>Diversity of cases belonging to the same partition of the pooled data</p></a></li>
<li><a href='#partition_min'><p>Generation of conservative or parsimonious solution for individual</p>
partitions</a></li>
<li><a href='#partition_min_inter'><p>Generation of intermediate solutions for individual partitions of</p>
clustered set-relational data</a></li>
<li><a href='#Schwarz2016'><p>Original data used by Schwarz (2016)</p></a></li>
<li><a href='#Thiem2011'><p>Original data used by Thiem (2011)</p></a></li>
<li><a href='#upset_conditions'><p>Aggregation of individual conditions over partition-specific models</p></a></li>
<li><a href='#upset_configurations'><p>Aggregation of individual configurations over partition-specific models</p></a></li>
<li><a href='#wop'><p>Weight of partitions for pooled solution parameters</p>
for conservative or parsimonious solution</a></li>
<li><a href='#wop_inter'><p>Calculation of weight of partitions in pooled solution parameters</p>
for intermediate solution</a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Tools for the Analysis of Clustered Data in QCA</td>
</tr>
<tr>
<td>Version:</td>
<td>0.1.0</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 2.10)</td>
</tr>
<tr>
<td>Description:</td>
<td>Clustered set-relational data in Qualitative Comparative Analysis
    (QCA) can have a hierarchical structure, a panel structure or repeated cross
    sections. 'QCAcluster' allows QCA researchers to supplement the analysis
    of pooled the data with a disaggregated perspective focusing on selected 
    partitions of the data. The pooled data can be partitioned along the 
    dimensions of the clustered data (individual cross sections or time series) 
    to perform partition-specific truth table minimizations. Empirical 
    researchers can further calculate the weight that each partition has on the 
    parameters of the pooled solution and the diversity of the cases under 
    analysis within and across partitions 
    (see <a href="https://ingorohlfing.github.io/QCAcluster/">https://ingorohlfing.github.io/QCAcluster/</a>).</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>Imports:</td>
<td>data.table (&ge; 1.12.8), plyr (&ge; 1.8.5), QCA (&ge; 3.7), testit
(&ge; 0.11), purrr (&ge; 0.3.3), UpSetR (&ge; 1.4.0), magrittr,
stringi (&ge; 1.7.4), rlist(&ge; 0.4.6.1)</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.1.2</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/ingorohlfing/QCAcluster">https://github.com/ingorohlfing/QCAcluster</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/ingorohlfing/QCAcluster/issues">https://github.com/ingorohlfing/QCAcluster/issues</a></td>
</tr>
<tr>
<td>Suggests:</td>
<td>rmarkdown, knitr</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>Language:</td>
<td>en-US</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2021-10-26 09:10:01 UTC; wmc769</td>
</tr>
<tr>
<td>Author:</td>
<td>Ingo Rohlfing [aut, cre] (0000-0001-8715-4771),
  Ayjeren Bekmuratovna [aut],
  Jan Schwalbach [aut] (0000-0002-6990-8098)</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Ingo Rohlfing &lt;i.rohlfing@uni-koeln.de&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2021-10-26 15:00:01 UTC</td>
</tr>
</table>
<hr>
<h2 id='Grauvogel2014'>Original data used by Grauvogel/von Soest (2014)</h2><span id='topic+Grauvogel2014'></span>

<h3>Description</h3>

<p>A dataset containing the calibrated set values for the article:
Grauvogel, Julia and Christian von Soest (2014):  
Claims to Legitimacy Count: Why Sanctions Fail to Instigate 
Democratisation in Authoritarian Regimes.  
European Journal of Political Research 53 (4): 635-653.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Grauvogel2014
</code></pre>


<h3>Format</h3>

<p>A data frame with 120 rows and 10 variables:
</p>

<dl>
<dt>Code</dt><dd><p>Sender-target ID</p>
</dd>
<dt>Sender</dt><dd><p>Country or institution imposing sanctions</p>
</dd>
<dt>Target</dt><dd><p>Country that is target of sanctions</p>
</dd>
<dt>Timeframe</dt><dd><p>Considered years for each country case</p>
</dd>
<dt>Persistence</dt><dd><p>Degree of regime persistence after the intervention</p>
</dd>
<dt>Comprehensiveness</dt><dd><p>Scope of the imposed sanctions - comprehensive 
vs. targeted sanctions</p>
</dd>
<dt>Linkage</dt><dd><p>Economic and social, respectively communicative and 
geographic ties</p>
</dd>
<dt>Vulnerability</dt><dd><p>Military and economic vulnerability of the state to 
outside pressure</p>
</dd>
<dt>Repression</dt><dd><p>Degree of repression by the state</p>
</dd>
<dt>Claims</dt><dd><p>Variety and strength of claims to legitimacy</p>
</dd>
</dl>



<h3>Source</h3>

<p>Grauvogel (2014) &lt;doi:10.1111/1475-6765.12065&gt;
</p>

<hr>
<h2 id='partition_div'>Diversity of cases belonging to the same partition of the pooled data</h2><span id='topic+partition_div'></span>

<h3>Description</h3>

<p><code>partition_div</code> calculates the diversity of cases that belong to the same
partition of the clustered data (a time series; a cross section; etc.).
Diversity is measured by the number of truth table rows that the cases of
a partition cover. <code>partition_div</code> calculates the partition diversity
for all truth table rows and for the subsets of consistent and
inconsistent rows.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>partition_div(dataset, units, time, cond, out, n_cut, incl_cut)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="partition_div_+3A_dataset">dataset</code></td>
<td>
<p>Calibrated pooled dataset that is partitioned
and minimized for deriving the pooled solution.</p>
</td></tr>
<tr><td><code id="partition_div_+3A_units">units</code></td>
<td>
<p>Units defining the within-dimension of data (time series)</p>
</td></tr>
<tr><td><code id="partition_div_+3A_time">time</code></td>
<td>
<p>Periods defining the between-dimension of data (cross sections)</p>
</td></tr>
<tr><td><code id="partition_div_+3A_cond">cond</code></td>
<td>
<p>Conditions used for the pooled analysis</p>
</td></tr>
<tr><td><code id="partition_div_+3A_out">out</code></td>
<td>
<p>Outcome used for the pooled analysis</p>
</td></tr>
<tr><td><code id="partition_div_+3A_n_cut">n_cut</code></td>
<td>
<p>Frequency cut-off for designating truth table rows as
observed in the pooled data</p>
</td></tr>
<tr><td><code id="partition_div_+3A_incl_cut">incl_cut</code></td>
<td>
<p>Inclusion cut-off for designating truth table rows as
consistent in the pooled data</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A dataframe presenting the diversity of cases belonging to the
same partition with the following columns:
</p>

<ul>
<li> <p><code>type</code>: The type of the partition. <code>pooled</code> are
rows with information on the pooled data; <code>between</code> is for
cross-section partitions; <code>within</code> is for time-series partitions.
</p>
</li>
<li> <p><code>partition</code>: Specific dimension of the partition at hand. For
between-dimension, the unit identifiers are included here
(argument <code>units</code>). For the within-dimension, the time identifier
are listed (argument <code>time</code>). The entry is <code>-</code> for the
pooled data without partitions.
</p>
</li>
<li> <p><code>diversity</code>: Count of all truth table rows with at least one member
belonging to a partition.
</p>
</li>
<li> <p><code>diversity_1</code>: Count of consistent truth table rows with at least
one member belonging to a partition.
</p>
</li>
<li> <p><code>diversity_0</code>: Count of inconsistent truth table rows with at least
one member belonging to a partition.
</p>
</li>
<li> <p><code>diversity_per</code>: Ratio of the value for <code>diversity</code> and the
total number of truth table rows from pooled data
(<code>diversity</code> value for pooled data).
</p>
</li>
<li> <p><code>diversity_per_1</code>: Ratio of the value for <code>diversity_1</code> and the
total number of consistent truth table rows from pooled data
(<code>diversity_1</code> value for pooled data).
</p>
</li>
<li> <p><code>diversity_per_0</code>: Ratio of the value for <code>diversity_0</code> and the
total number of inconsistent truth table rows from pooled data
(<code>diversity_0</code> value for pooled data).
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>data(Schwarz2016)
Schwarz_diversity &lt;- partition_div(Schwarz2016, 
units = "country", time = "year", 
cond = c("poltrans", "ecotrans", "reform", "conflict", "attention"), 
out = "enlarge", 1, 0.8)

</code></pre>

<hr>
<h2 id='partition_min'>Generation of conservative or parsimonious solution for individual
partitions</h2><span id='topic+partition_min'></span>

<h3>Description</h3>

<p><code>partition_min</code> decomposes clustered data into individual
partitions. For panel data, for example, these can be cross sections,
time series or both. The function derives an individual solution for
each partition and the pooled data to assess the robustness of the
solutions in a comparative perspective.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>partition_min(
  dataset,
  units,
  time,
  cond,
  out,
  n_cut,
  incl_cut,
  solution,
  BE_cons,
  WI_cons,
  BE_ncut,
  WI_ncut
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="partition_min_+3A_dataset">dataset</code></td>
<td>
<p>Calibrated pooled dataset that is partitioned and minimized for
deriving the pooled solution.</p>
</td></tr>
<tr><td><code id="partition_min_+3A_units">units</code></td>
<td>
<p>Units defining the within-dimension of data (time series). If no
units are specified, the data is assumed to lack a dimension and be
hierarchical.</p>
</td></tr>
<tr><td><code id="partition_min_+3A_time">time</code></td>
<td>
<p>Periods defining the between-dimension of data (cross sections).
This should be specified because it does not make sense to partition a
time series into individual data points.</p>
</td></tr>
<tr><td><code id="partition_min_+3A_cond">cond</code></td>
<td>
<p>Conditions used for minimization</p>
</td></tr>
<tr><td><code id="partition_min_+3A_out">out</code></td>
<td>
<p>Outcome used for minimization</p>
</td></tr>
<tr><td><code id="partition_min_+3A_n_cut">n_cut</code></td>
<td>
<p>Frequency cut-off for designating truth table rows as observed
as opposed to designating them as remainders for the <em>pooled</em> data.</p>
</td></tr>
<tr><td><code id="partition_min_+3A_incl_cut">incl_cut</code></td>
<td>
<p>Inclusion (a.k.a. consistency) cut-off for designating
truth table rows as consistent for the <em>pooled</em> data.</p>
</td></tr>
<tr><td><code id="partition_min_+3A_solution">solution</code></td>
<td>
<p>A character specifying the type of solution that should
be derived. <code>C</code> produces the conservative (or complex) solution,
<code>P</code> for the parsimonious solution. See <code><a href="#topic+partition_min_inter">partition_min_inter</a></code>
for a separate function for the intermediate solution.</p>
</td></tr>
<tr><td><code id="partition_min_+3A_be_cons">BE_cons</code></td>
<td>
<p>Inclusion thresholds for creating an individual truth table
for each cross section.
They must be specified as a numeric vector. Its length should be
equal the number of cross sections. The order of thresholds corresponds
to the order of the cross sections in the data defined by the cross-section
ID in the dataset (such as years in ascending order).</p>
</td></tr>
<tr><td><code id="partition_min_+3A_wi_cons">WI_cons</code></td>
<td>
<p>Inclusion thresholds for creating an individual truth table
for each time series.
They must be specified as a numeric vector. Its length should be
equal the number of time series. The order of thresholds corresponds
to the order of the of the time-series (unit) ID
in the dataset (such as countries in alphabetical order).</p>
</td></tr>
<tr><td><code id="partition_min_+3A_be_ncut">BE_ncut</code></td>
<td>
<p>For <em>cross sections</em>, the minimum number of members needed
for declaring a truth table row
as relevant as opposed to designating it as a remainder.
Must be specified as a numeric vector. Its length should be
equal the number of cross sections. The order of thresholds corresponds
to the order of the cross sections in the data defined by the cross-section
ID in the dataset (such as years in ascending order).</p>
</td></tr>
<tr><td><code id="partition_min_+3A_wi_ncut">WI_ncut</code></td>
<td>
<p>For <em>time series</em>, the minimum number of members needed
for declaring a truth table row
as relevant as opposed to designating it as a remainder.
Must be specified as a numeric vector. Its length should be
equal the number of time series. The order of thresholds corresponds
to the order of the of the time-series (unit) ID
in the dataset (such as countries in alphabetical order).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A dataframe summarizing the partition-specific and pooled solutions
with the following columns:
</p>

<ul>
<li> <p><code>type</code>: The type of the partition. <code>pooled</code> are rows with information
on the pooled data; <code>between</code> is for cross-section partitions;
<code>within</code> is for time-series partitions.
</p>
</li>
<li> <p><code>partition</code>: Specific dimension of the partition at hand. For
between-dimension, the unit identifiers are included here  (argument <code>units</code>).
For the within-dimension, the time identifier are listed (argument <code>time</code>).
The entry is <code>-</code> for the pooled data without partitions.
</p>
</li>
<li> <p><code>solution</code>: The solution derived for the partition or the pooled data.
Absence of a condition is denoted by the <code>~</code> sign.
</p>
</li>
<li> <p><code>model</code>: Running ID for models. In the presence of model ambiguity, each
model has its own row with its individual solution and parameters. The rest of
the information in the row is duplicated, for example by having two rows for
the within-partition 1996. The column <code>model</code> highlights the presence of
model ambiguity by numbering all models belonging to the same solution. For
example, if three consecutive rows are numbered 1, 2 and 3, then these rows
belong to the same solution and represent model ambiguity. If a 1 in a row
is followed by another 1, then there is no model ambiguity.
</p>
</li>
<li> <p><code>consistency</code>: The consistency score (a.k.a. inclusion score)
for the partition of the data or the pooled data.
</p>
</li>
<li> <p><code>coverage</code>: The coverage score for the partition of the data
or the pooled data.
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'># loading data from Thiem (EPSR, 2011; see data documentation)
data(Thiem2011)

# running function for parsimonious solution
Thiem_pars &lt;- partition_min(
  dataset = Thiem2011,
  units = "country", time = "year",
  cond = c("fedismfs", "homogtyfs", "powdifffs", "comptvnsfs", "pubsupfs", "ecodpcefs"),
  out = "memberfs",
  n_cut = 1, incl_cut = 0.8,
  solution = "P",
  BE_cons = c(0.9, 0.8, 0.7, 0.8, 0.6, 0.8, 0.8, 0.8, 0.8, 0.8, 0.8),
  WI_cons = c(0.5, 0.8, 0.7, 0.8, 0.6, rep(0.8, 10)))

</code></pre>

<hr>
<h2 id='partition_min_inter'>Generation of intermediate solutions for individual partitions of
clustered set-relational data</h2><span id='topic+partition_min_inter'></span>

<h3>Description</h3>

<p><code>partition_min_inter</code> decomposes clustered data into individual
partitions such as cross-sections and time-series for panel
data. It derives an individual intermediate solution for each partition
and the pooled data to assess the robustness of the
solutions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>partition_min_inter(
  dataset,
  units,
  time,
  cond,
  out,
  n_cut,
  incl_cut,
  intermediate,
  BE_cons,
  WI_cons,
  BE_ncut,
  WI_ncut
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="partition_min_inter_+3A_dataset">dataset</code></td>
<td>
<p>Calibrated pooled dataset for partitioning and minimization</p>
</td></tr>
<tr><td><code id="partition_min_inter_+3A_units">units</code></td>
<td>
<p>Units defining the within-dimension of data (time series)</p>
</td></tr>
<tr><td><code id="partition_min_inter_+3A_time">time</code></td>
<td>
<p>Periods defining the between-dimension of data (cross sections)</p>
</td></tr>
<tr><td><code id="partition_min_inter_+3A_cond">cond</code></td>
<td>
<p>Conditions used for the pooled analysis</p>
</td></tr>
<tr><td><code id="partition_min_inter_+3A_out">out</code></td>
<td>
<p>Outcome used for the pooled analysis</p>
</td></tr>
<tr><td><code id="partition_min_inter_+3A_n_cut">n_cut</code></td>
<td>
<p>Frequency cut-off for designating truth table rows as observed</p>
</td></tr>
<tr><td><code id="partition_min_inter_+3A_incl_cut">incl_cut</code></td>
<td>
<p>Inclusion cut-off for designating truth table rows as
consistent</p>
</td></tr>
<tr><td><code id="partition_min_inter_+3A_intermediate">intermediate</code></td>
<td>
<p>A vector of directional expectations to derive intermediate solutions</p>
</td></tr>
<tr><td><code id="partition_min_inter_+3A_be_cons">BE_cons</code></td>
<td>
<p>Inclusion (or consistency) thresholds for cross sections.
Must be specified as a numeric vector with length equaling the number of
cross sections. Numbers correspond to the order of the cross section ID
in the data (such as years in ascending order).</p>
</td></tr>
<tr><td><code id="partition_min_inter_+3A_wi_cons">WI_cons</code></td>
<td>
<p>Inclusion (or consistency) thresholds for time series.
Must be specified as a numeric vector with length equaling the number of
time series. Numbers correspond to the order of the time series (unit) ID
in the data (such as countries in alphabetical order).</p>
</td></tr>
<tr><td><code id="partition_min_inter_+3A_be_ncut">BE_ncut</code></td>
<td>
<p>For <em>cross sections</em>, the minimum number of members needed
for declaring a truth table row
as relevant as opposed to designating it as a remainder.
Must be specified as a numeric vector. Its length should be
equal the number of cross sections. The order of thresholds corresponds
to the order of the cross sections in the data defined by the cross-section
ID in the dataset (such as years in ascending order).</p>
</td></tr>
<tr><td><code id="partition_min_inter_+3A_wi_ncut">WI_ncut</code></td>
<td>
<p>For <em>time series</em>, the minimum number of members needed
for declaring a truth table row
as relevant as opposed to designating it as a remainder.
Must be specified as a numeric vector. Its length should be
equal the number of time series. The order of thresholds corresponds
to the order of the of the time-series (unit) ID
in the dataset (such as countries in alphabetical order).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A dataframe summarizing the partition-specific and pooled solutions
with the following columns:
</p>

<ul>
<li> <p><code>type</code>: The type of the partition. <code>pooled</code> are rows with information
on the pooled data; <code>between</code> is for cross-section partitions;
<code>within</code> is for time-series partitions.
</p>
</li>
<li> <p><code>partition</code>: Specific dimension of the partition at hand. For
between-dimension, the unit identifiers are included here  (argument <code>units</code>).
For the within-dimension, the time identifier are listed (argument <code>time</code>).
The entry is <code>-</code> for the pooled data without partitions.
</p>
</li>
<li> <p><code>solution</code>: The solution derived for the partition or the pooled data.
Absence of a condition is denoted by the <code>~</code> sign.
</p>
</li>
<li> <p><code>model</code>: Running ID for models. In the presence of model ambiguity, each
model has its own row with its individual solution and parameters. The rest of
the information in the row is duplicated, for example by having two rows for
the within-partition 1996. The column <code>model</code> highlights the presence of
model ambiguity by numbering all models belonging to the same solution. For
example, if three consecutive rows are numbered 1, 2 and 3, then these rows
belong to the same solution and represent model ambiguity. If a 1 in a row
is followed by another 1, then there is no model ambiguity.
</p>
</li>
<li> <p><code>consistency</code>: The consistency score (a.k.a. inclusion score)
for the partition of the data or the pooled data.
</p>
</li>
<li> <p><code>coverage</code>: The coverage score for the partition of the data
or the pooled data.
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>data(Schwarz2016)
Schwarz_inter &lt;- partition_min_inter(
  Schwarz2016,
  units = "country", time = "year",
  cond = c("poltrans", "ecotrans", "reform", "conflict", "attention"),
  out = "enlarge",
  n_cut = 1, incl_cut = 0.8,
  intermediate = c("1", "1", "1", "1", "1"))

</code></pre>

<hr>
<h2 id='Schwarz2016'>Original data used by Schwarz (2016)</h2><span id='topic+Schwarz2016'></span>

<h3>Description</h3>

<p>A dataset containing the calibrated set values for the article:
Schwarz, Oliver (2016): Two Steps Forward One Step Back: 
What Shapes the Process of EU Enlargement in South-Eastern Europe? 
Journal of European Integration 38 (7): 757-773.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Schwarz2016
</code></pre>


<h3>Format</h3>

<p>A data frame with 74 rows and 9 variables:
</p>

<dl>
<dt>Case.ID</dt><dd><p>Country-year ID</p>
</dd>
<dt>enlarge</dt><dd><p>Progress in the EU accession process</p>
</dd>
<dt>poltrans</dt><dd><p>Democracy status of the country</p>
</dd>
<dt>ecotrans</dt><dd><p>Market economy status of the country</p>
</dd>
<dt>reform</dt><dd><p>State of reform policy</p>
</dd>
<dt>conflict</dt><dd><p>Mean conflict intensity in a country per year</p>
</dd>
<dt>attention</dt><dd><p>EU’s attention to the issue of enlargement</p>
</dd>
<dt>year</dt><dd><p>Year ID</p>
</dd>
<dt>country</dt><dd><p>Country ID</p>
</dd>
</dl>



<h3>Source</h3>

<p>Schwarz (2016) &lt;doi:10.1080/07036337.2016.1203309&gt;
</p>

<hr>
<h2 id='Thiem2011'>Original data used by Thiem (2011)</h2><span id='topic+Thiem2011'></span>

<h3>Description</h3>

<p>A dataset containing the calibrated set values for the article:
Thiem, Alrik (2011): 
Conditions of Intergovernmental Armaments Cooperation in Western Europe,
1996-2006. European Political Science Review 3 (1): 1-33.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Thiem2011
</code></pre>


<h3>Format</h3>

<p>A data frame with 165 rows and 10 variables:
</p>

<dl>
<dt>id</dt><dd><p>Country-year ID</p>
</dd>
<dt>year</dt><dd><p>Time ID</p>
</dd>
<dt>country</dt><dd><p>Country ID</p>
</dd>
<dt>memberfs</dt><dd><p>Monadic count of membership in formal intergovernmental 
agreements on armaments cooperation</p>
</dd>
<dt>fedismfs</dt><dd><p>Degree to which a country’s domestic constitutional setup 
is federalist in character</p>
</dd>
<dt>homogtyfs</dt><dd><p>Bilateral interaction scores based on all UN and NATO 
military missions conducted between 1996 and 2006</p>
</dd>
<dt>powdifffs</dt><dd><p>Score to measure a country's military power based on the 
CINC score</p>
</dd>
<dt>comptvnsfs</dt><dd><p>Competitiveness of a country’s domestic armaments 
industry</p>
</dd>
<dt>pubsupfs</dt><dd><p>Public support for cooperation in defence</p>
</dd>
<dt>ecodpcefs</dt><dd><p>Degree of economic dependence</p>
</dd>
</dl>



<h3>Source</h3>

<p>Thiem(2011) &lt;doi:10.1017/S1755773910000251&gt;
</p>

<hr>
<h2 id='upset_conditions'>Aggregation of individual conditions over partition-specific models</h2><span id='topic+upset_conditions'></span>

<h3>Description</h3>

<p>Models that have been derived for individual partitions are first
decomposed into conditions, that is single conditions or
conditions that are INUS (insufficient conditions that are necessary
parts of a conjunction that is unnecessary and sufficient). The individual
conditions are aggregated using UpSet plots to determine how frequent
they are individually and in combination.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>upset_conditions(df, nsets)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="upset_conditions_+3A_df">df</code></td>
<td>
<p>Dataframe created with <code><a href="#topic+partition_min">partition_min</a></code> or
<code><a href="#topic+partition_min_inter">partition_min_inter</a></code>.</p>
</td></tr>
<tr><td><code id="upset_conditions_+3A_nsets">nsets</code></td>
<td>
<p>Number of sets to include in plot (default is 5).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An UpSet plot produced with <code><a href="UpSetR.html#topic+upset">upset</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(Grauvogel2014)
GS_pars &lt;- partition_min(
 dataset = Grauvogel2014,
 units = "Sender",
 cond = c("Comprehensiveness", "Linkage", "Vulnerability",
          "Repression", "Claims"),
 out = "Persistence",
 n_cut = 1, incl_cut = 0.75,
 solution = "P",
 BE_cons = rep(0.75, 3),
 BE_ncut = rep(1, 3))
upset_conditions(GS_pars, nsets = 5)

</code></pre>

<hr>
<h2 id='upset_configurations'>Aggregation of individual configurations over partition-specific models</h2><span id='topic+upset_configurations'></span>

<h3>Description</h3>

<p>Models that have been derived for individual partitions are first
decomposed into sufficient terms, that is single sufficient conditions or
configurations. The individual terms are aggregated using UpSet plots to
determine how frequent they are individually and in combination.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>upset_configurations(df, nsets)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="upset_configurations_+3A_df">df</code></td>
<td>
<p>Dataframe created with <code><a href="#topic+partition_min">partition_min</a></code> or
<code><a href="#topic+partition_min_inter">partition_min_inter</a></code>.</p>
</td></tr>
<tr><td><code id="upset_configurations_+3A_nsets">nsets</code></td>
<td>
<p>Number of sets to include in plot (default is 5).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An UpSet plot produced with <code><a href="UpSetR.html#topic+upset">upset</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(Grauvogel2014)
GS_pars &lt;- partition_min(
 dataset = Grauvogel2014,
 units = "Sender",
 cond = c("Comprehensiveness", "Linkage", "Vulnerability",
          "Repression", "Claims"),
 out = "Persistence",
 n_cut = 1, incl_cut = 0.75,
 solution = "P",
 BE_cons = rep(0.75, 3),
 BE_ncut = rep(1, 3))
upset_configurations(GS_pars, nsets = 4)

</code></pre>

<hr>
<h2 id='wop'>Weight of partitions for pooled solution parameters
for conservative or parsimonious solution</h2><span id='topic+wop'></span>

<h3>Description</h3>

<p><code>wop</code> calculates the contribution or weight of partitions
for the pooled solution parameters of consistency and coverage
for the conservative or parsimonious solution.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>wop(dataset, units, time, cond, out, n_cut, incl_cut, solution, amb_selector)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="wop_+3A_dataset">dataset</code></td>
<td>
<p>Calibrated pooled dataset for partitioning and minimization
of pooled solution.</p>
</td></tr>
<tr><td><code id="wop_+3A_units">units</code></td>
<td>
<p>Units that define the within-dimension of data (time series).</p>
</td></tr>
<tr><td><code id="wop_+3A_time">time</code></td>
<td>
<p>Periods that define the between-dimension of data (cross sections).</p>
</td></tr>
<tr><td><code id="wop_+3A_cond">cond</code></td>
<td>
<p>Conditions used for the pooled analysis.</p>
</td></tr>
<tr><td><code id="wop_+3A_out">out</code></td>
<td>
<p>Outcome used for the pooled analysis.</p>
</td></tr>
<tr><td><code id="wop_+3A_n_cut">n_cut</code></td>
<td>
<p>Frequency cut-off for designating truth table rows as observed
in the pooled analysis.</p>
</td></tr>
<tr><td><code id="wop_+3A_incl_cut">incl_cut</code></td>
<td>
<p>Inclusion cut-off for designating truth table rows as
consistent in the pooled analysis.</p>
</td></tr>
<tr><td><code id="wop_+3A_solution">solution</code></td>
<td>
<p>A character specifying the type of solution that should
be derived. <code>C</code> produces the conservative (or complex) solution,
<code>P</code> the parsimonious solution. See <code><a href="#topic+wop_inter">wop_inter</a></code> for deriving
intermediate solution.</p>
</td></tr>
<tr><td><code id="wop_+3A_amb_selector">amb_selector</code></td>
<td>
<p>Numerical value for selecting a single model in the
presence of model ambiguity. Models are numbered according to their
order produced by <code><a href="QCA.html#topic+minimize">minimize</a></code> by the <code>QCA</code> package.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A dataframe with information about the weight of the partitions
with the following columns:
</p>

<ul>
<li> <p><code>type</code>: The type of the partition. <code>between</code> stands for
cross-sections; <code>within</code> stands for time series. <code>pooled</code> stands
information about the pooled data.
</p>
</li>
<li> <p><code>partition</code>: Type of partition. For
between-dimension, the unit identifiers are listed  (argument <code>units</code>).
For the within-dimension, the time identifiers are listed (argument <code>time</code>).
The entry is <code>-</code> for the pooled data.
</p>
</li>
<li> <p><code>denom_cons</code>: Denominator of the consistency formula. It is the sum
over the cases' membership in the solution.
</p>
</li>
<li> <p><code>num_cons</code>: Numerator of the consistency formula. It is the sum
over the minimum of the cases' membership in the solution and the outcome.
</p>
</li>
<li> <p><code>denom_cov</code>: Denominator of the coverage formula. It is the sum
over the cases' membership in the outcome.
</p>
</li>
<li> <p><code>num_cov</code>: Numerator of the coverage formula. It is the sum
over the minimum of the cases' membership in the solution and the outcome.
(identical to <code>num_cons</code>)
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>data(Thiem2011)
wop_pars &lt;- wop(
  dataset = Thiem2011,
  units = "country", time = "year",
  cond = c("fedismfs", "homogtyfs", "powdifffs", "comptvnsfs", "pubsupfs", "ecodpcefs"),
  out = "memberfs",
  n_cut = 6, incl_cut = 0.8,
  solution = "P",
  amb_selector = 1)
wop_pars
</code></pre>

<hr>
<h2 id='wop_inter'>Calculation of weight of partitions in pooled solution parameters
for intermediate solution</h2><span id='topic+wop_inter'></span>

<h3>Description</h3>

<p><code>wop_inter</code> calculates the weight of partitions in the pooled
solution parameters (consistency, coverage) for the intermediate solution.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>wop_inter(
  dataset,
  units,
  time,
  cond,
  out,
  n_cut,
  incl_cut,
  intermediate,
  amb_selector
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="wop_inter_+3A_dataset">dataset</code></td>
<td>
<p>Calibrated pooled dataset for partitioning and minimization</p>
</td></tr>
<tr><td><code id="wop_inter_+3A_units">units</code></td>
<td>
<p>Units defining the within-dimension of data (time series)</p>
</td></tr>
<tr><td><code id="wop_inter_+3A_time">time</code></td>
<td>
<p>Periods defining the between-dimension of data (cross sections)</p>
</td></tr>
<tr><td><code id="wop_inter_+3A_cond">cond</code></td>
<td>
<p>Conditions used for the pooled analysis</p>
</td></tr>
<tr><td><code id="wop_inter_+3A_out">out</code></td>
<td>
<p>Outcome used for the pooled analysis</p>
</td></tr>
<tr><td><code id="wop_inter_+3A_n_cut">n_cut</code></td>
<td>
<p>Frequency cut-off for designating truth table rows as observed</p>
</td></tr>
<tr><td><code id="wop_inter_+3A_incl_cut">incl_cut</code></td>
<td>
<p>Inclusion cut-off for designating truth table rows as
consistent</p>
</td></tr>
<tr><td><code id="wop_inter_+3A_intermediate">intermediate</code></td>
<td>
<p>A vector of directional expectations to derive the
intermediate solutions</p>
</td></tr>
<tr><td><code id="wop_inter_+3A_amb_selector">amb_selector</code></td>
<td>
<p>Numerical value for selecting a single model in the
presence of model ambiguity. Models are numbered according to their
order produced by <code><a href="QCA.html#topic+minimize">minimize</a></code> by the <code>QCA</code> package.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A dataframe with information about the weight of the partitions
for pooled consistency and coverage scores and the following columns:
</p>

<ul>
<li> <p><code>type</code>: The type of the partition. <code>between</code> stands for
cross-sections; <code>within</code> stands for time series. <code>pooled</code> stands
information about the pooled data.
</p>
</li>
<li> <p><code>partition</code>: Type of partition. For
between-dimension, the unit identifiers are listed  (argument <code>units</code>).
For the within-dimension, the time identifiers are listed (argument <code>time</code>).
The entry is <code>-</code> for the pooled data.
</p>
</li>
<li> <p><code>denom_cons</code>: Denominator of the consistency formula. It is the sum
over the cases' membership in the solution.
</p>
</li>
<li> <p><code>num_cons</code>: Numerator of the consistency formula. It is the sum
over the minimum of the cases' membership in the solution and the outcome.
</p>
</li>
<li> <p><code>denom_cov</code>: Denominator of the coverage formula. It is the sum
over the cases' membership in the outcome.
</p>
</li>
<li> <p><code>num_cov</code>: Numerator of the coverage formula. It is the sum
over the minimum of the cases' membership in the solution and the outcome.
(identical to <code>num_cons</code>)
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>data(Schwarz2016)

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
