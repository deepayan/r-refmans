<!DOCTYPE html><html lang="en-US"><head><title>Help for package mrgsolve</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {mrgsolve}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#mrgsolve-package'><p>mrgsolve: Simulate from ODE-Based Models</p></a></li>
<li><a href='#+25+26gt+3B+25'><p>Forward pipe</p></a></li>
<li><a href='#+24+2Cev-method'><p>Select columns from an ev object</p></a></li>
<li><a href='#+24+2Cmrgmod-method'><p>Select parameter values from a model object</p></a></li>
<li><a href='#aboutsolver'><p>About the lsoda differential equation solver used by mrgsolve</p></a></li>
<li><a href='#as_bmat'><p>Coerce R objects to block or diagonal matrices</p></a></li>
<li><a href='#as_data_set'><p>Create a simulation data set from ev objects or data frames</p></a></li>
<li><a href='#as_deslist'><p>Create a list of designs from a data frame</p></a></li>
<li><a href='#as.ev'><p>Coerce an object to class ev</p></a></li>
<li><a href='#as.list+2Cmrgmod-method'><p>Coerce a model object to list</p></a></li>
<li><a href='#as.list+2Cmrgsims-method'><p>Coerce an mrgsims object to list</p></a></li>
<li><a href='#BLOCK_PARSE'><p>Functions to parse code blocks</p></a></li>
<li><a href='#blocks'><p>Return the code blocks from a model specification file</p></a></li>
<li><a href='#c+2Cmatlist-method'><p>Operations with matlist objects</p></a></li>
<li><a href='#c+2Ctgrid-method'><p>Operations with tgrid objects</p></a></li>
<li><a href='#cama'><p>Run the model cama function</p></a></li>
<li><a href='#carry_out'><p>Select items to carry into simulated output</p></a></li>
<li><a href='#check_data_names'><p>Check input data set names against model parameters</p></a></li>
<li><a href='#cmt_list-class'><p>S4 cmt_list class</p></a></li>
<li><a href='#cmtn'><p>Get the compartment number from a compartment name</p></a></li>
<li><a href='#code'><p>Extract the code from a model</p></a></li>
<li><a href='#collapse_matrix'><p>Collapse the matrices of a matlist object</p></a></li>
<li><a href='#collapse_omega'><p>Collapse OMEGA or SIGMA matrix lists</p></a></li>
<li><a href='#cvec'><p>Create create character vectors</p></a></li>
<li><a href='#data_set'><p>Select and modify a data set for simulation</p></a></li>
<li><a href='#design'><p>Set observation designs for the simulation</p></a></li>
<li><a href='#details'><p>Extract model details</p></a></li>
<li><a href='#env_eval'><p>Re-evaluate the code in the ENV block</p></a></li>
<li><a href='#env_get'><p>Return model environment</p></a></li>
<li><a href='#env_ls'><p>List objects in the model environment</p></a></li>
<li><a href='#env_update'><p>Update objects in model environment</p></a></li>
<li><a href='#ev'><p>Event objects for simulating PK and other interventions</p></a></li>
<li><a href='#ev_assign'><p>Replicate a list of events into a data set</p></a></li>
<li><a href='#ev_days'><p>Schedule dosing events on days of the week</p></a></li>
<li><a href='#ev_methods'><p>Various methods for event objects</p></a></li>
<li><a href='#ev_ops'><p>Operations for ev objects</p></a></li>
<li><a href='#ev_rep'><p>Replicate an event object</p></a></li>
<li><a href='#ev_repeat'><p>Repeat a block of dosing events</p></a></li>
<li><a href='#ev_rx'><p>Create intervention objects from Rx input</p></a></li>
<li><a href='#ev_seq'><p>Schedule a series of event objects</p></a></li>
<li><a href='#ev-class'><p>S4 events class</p></a></li>
<li><a href='#evd'><p>Create an event object with data-like names</p></a></li>
<li><a href='#exdatasets'><p>Example input data sets</p></a></li>
<li><a href='#expand_observations'><p>Insert observations into a data set</p></a></li>
<li><a href='#expand.idata'><p>Create template data sets for simulation</p></a></li>
<li><a href='#file_show'><p>Show model specification and C++ files</p></a></li>
<li><a href='#house'><p>Return a pre-compiled, PK/PD model</p></a></li>
<li><a href='#idata_set'><p>Select and modify a idata set for simulation</p></a></li>
<li><a href='#init'><p>Methods for working with the model compartment list</p></a></li>
<li><a href='#inventory'><p>Check whether all required parameters needed in a model are present in an</p>
object</a></li>
<li><a href='#is.mrgmod'><p>Check if an object is a model object</p></a></li>
<li><a href='#is.mrgsims'><p>Check if an object is mrgsims output</p></a></li>
<li><a href='#knobs'><p>Run sensitivity analysis on model settings</p></a></li>
<li><a href='#lctran'><p>Change the case of nmtran-like data items</p></a></li>
<li><a href='#loadso'><p>Load the model shared object</p></a></li>
<li><a href='#lower2matrix'><p>Create a square numeric matrix from the lower-triangular elements</p></a></li>
<li><a href='#matlist'><p>Methods for working with matrix-list objects</p></a></li>
<li><a href='#matlist-class'><p>S4 class matlist</p></a></li>
<li><a href='#matrix_helpers'><p>Create matrices from vector input</p></a></li>
<li><a href='#mcode'><p>Write, compile, and load model code</p></a></li>
<li><a href='#mcRNG'><p>Set RNG to use L'Ecuyer-CMRG</p></a></li>
<li><a href='#merge.list'><p>Merge two lists</p></a></li>
<li><a href='#mod'><p>Return the model object</p></a></li>
<li><a href='#modelparse'><p>Parse model specification text</p></a></li>
<li><a href='#modlib'><p>Internal model library</p></a></li>
<li><a href='#modlib_details'><p>modlib: PK/PD Model parameters, compartments, and output variables</p></a></li>
<li><a href='#modlib_pk'><p>modlib: Pharmacokinetic models</p></a></li>
<li><a href='#modlib_pkpd'><p>modlib: Pharmacokinetic / pharmacodynamic models</p></a></li>
<li><a href='#modlib_tmdd'><p>modlib: Target mediated disposition model</p></a></li>
<li><a href='#modlib_viral'><p>modlib: HCV viral dynamics models</p></a></li>
<li><a href='#modMATRIX'><p>Create a matrix</p></a></li>
<li><a href='#mread'><p>Read a model specification file</p></a></li>
<li><a href='#mread_yaml'><p>Read a model from yaml format</p></a></li>
<li><a href='#mrgmod-class'><p>S4 class for mrgsolve model object</p></a></li>
<li><a href='#mrgsim'><p>Simulate from a model object</p></a></li>
<li><a href='#mrgsim_q'><p>Simulate from a model object with quicker turnaround</p></a></li>
<li><a href='#mrgsim_variants'><p>mrgsim variant functions</p></a></li>
<li><a href='#mrgsims'><p>Methods for working with <code>mrgsims</code> objects</p></a></li>
<li><a href='#mrgsims_dplyr'><p>Methods for handling output with dplyr verbs</p></a></li>
<li><a href='#mrgsims_modify'><p>Methods for modifying mrgsims objects</p></a></li>
<li><a href='#mrgsims-class'><p>S4 class for mrgsolve simulation output</p></a></li>
<li><a href='#mutate.ev'><p>dplyr verbs for event objects</p></a></li>
<li><a href='#mvgauss'><p>Simulate from a multivariate normal distribution with mean zero</p></a></li>
<li><a href='#mwrite_cpp'><p>Write a model to native mrgsolve format</p></a></li>
<li><a href='#mwrite_yaml'><p>Write model code to yaml  format</p></a></li>
<li><a href='#names+2Cmrgmod-method'><p>Get all names from a model object</p></a></li>
<li><a href='#nmext'><p>Import model estimates from a NONMEM ext file</p></a></li>
<li><a href='#nmxml'><p>Import model estimates from a NONMEM xml file</p></a></li>
<li><a href='#numeric2diag'><p>Create a diagonal numeric matrix from diagonal elements</p></a></li>
<li><a href='#numericlist'><p>Methods for numericlist</p></a></li>
<li><a href='#numericlist-class'><p>S4 class numeric list</p></a></li>
<li><a href='#numerics_only'><p>Prepare data.frame for input to mrgsim()</p></a></li>
<li><a href='#obsaug'><p>Augment observations in the simulated output</p></a></li>
<li><a href='#obsonly'><p>Collect only observation records in the simulated output</p></a></li>
<li><a href='#omega'><p>Manipulate OMEGA matrices</p></a></li>
<li><a href='#outvars'><p>Show names of current output variables</p></a></li>
<li><a href='#param'><p>Create and work with parameter objects</p></a></li>
<li><a href='#param_tags'><p>Return parameter tags</p></a></li>
<li><a href='#parameter_list-class'><p>S4 parameter_list class</p></a></li>
<li><a href='#PKMODEL'><p>Parse PKMODEL BLOCK data</p></a></li>
<li><a href='#plot_mrgsims'><p>Generate a quick plot of simulated data</p></a></li>
<li><a href='#plot_sims'><p>Plot data as an mrgsims object</p></a></li>
<li><a href='#plot+2Cbatch_mrgsims+2Cmissing-method'><p>Plot method for mrgsims objects</p></a></li>
<li><a href='#qsim'><p>Basic, simple simulation from model object</p></a></li>
<li><a href='#read_nmext'><p>Extract estimates from NONMEM ext file</p></a></li>
<li><a href='#realize_addl'><p>Make addl doses explicit in an event object or data set</p></a></li>
<li><a href='#reexports'><p>Objects exported from other packages</p></a></li>
<li><a href='#render'><p>Render a model to a document</p></a></li>
<li><a href='#Req'><p>Request simulated output</p></a></li>
<li><a href='#reserved'><p>Reserved words</p></a></li>
<li><a href='#revar'><p>Get model random effect variances and covariances</p></a></li>
<li><a href='#scrape_and_call'><p>Scrape options and pass to function</p></a></li>
<li><a href='#scrape_opts'><p>Scrape options from a code block</p></a></li>
<li><a href='#see'><p>Print model code to the console</p></a></li>
<li><a href='#show+2Ccmt_list-method'><p>Show the compartment list</p></a></li>
<li><a href='#show+2Cmrgmod-method'><p>Print model details</p></a></li>
<li><a href='#show+2Cparameter_list-method'><p>Show the parameter list</p></a></li>
<li><a href='#sigma'><p>Manipulate SIGMA matrices</p></a></li>
<li><a href='#simargs'><p>Access or clear arguments for calls to mrgsim()</p></a></li>
<li><a href='#soloc'><p>Return the location of the model shared object</p></a></li>
<li><a href='#solversettings'><p>Optional inputs for lsoda</p></a></li>
<li><a href='#stime'><p>Get the times at which the model will be evaluated</p></a></li>
<li><a href='#summary.mrgmod'><p>Print summary of a mrgmod object</p></a></li>
<li><a href='#tgrid'><p>Create a simtime object</p></a></li>
<li><a href='#touch_funs'><p>Get inits from compiled function</p></a></li>
<li><a href='#tscale'><p>Re-scale time in the simulated output</p></a></li>
<li><a href='#update'><p>Update the model object</p></a></li>
<li><a href='#valid_data_set'><p>Validate and prepare data sets for simulation</p></a></li>
<li><a href='#valid_idata_set'><p>Validate and prepare idata data sets for simulation</p></a></li>
<li><a href='#wf_sweep'><p>Simulate a sequence of parameters</p></a></li>
<li><a href='#within'><p>Update parameters, initials, and settings within a model object</p></a></li>
<li><a href='#zero_re'><p>Zero out random effects in a model object</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Simulate from ODE-Based Models</td>
</tr>
<tr>
<td>Version:</td>
<td>1.5.2</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Kyle T Baron &lt;kyleb@metrumrg.com&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Fast simulation from ordinary differential equation
    (ODE) based models typically employed in quantitative pharmacology and
    systems biology.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://mrgsolve.org/docs/">https://mrgsolve.org/docs/</a>,
<a href="https://github.com/metrumresearchgroup/mrgsolve">https://github.com/metrumresearchgroup/mrgsolve</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/metrumresearchgroup/mrgsolve/issues">https://github.com/metrumresearchgroup/mrgsolve/issues</a></td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.6.2), methods</td>
</tr>
<tr>
<td>Imports:</td>
<td>Rcpp (&ge; 1.0.7), dplyr (&ge; 1.0.8), magrittr (&ge; 2.0.1), tibble
(&ge; 3.1.6), rlang (&ge; 1.0.1), tidyselect (&ge; 1.1.1), lifecycle,
glue</td>
</tr>
<tr>
<td>Suggests:</td>
<td>lattice, testthat, xml2 (&ge; 1.3.2), rmarkdown, yaml, knitr,
data.table (&ge; 1.14.2), pmxTools</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>Rcpp (&ge; 1.0.7), RcppArmadillo (&ge; 0.10.7.3.0), BH (&ge;
1.75.0-0)</td>
</tr>
<tr>
<td>RdMacros:</td>
<td>lifecycle</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>Language:</td>
<td>en-US</td>
</tr>
<tr>
<td>LazyLoad:</td>
<td>yes</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.3.2</td>
</tr>
<tr>
<td>Collate:</td>
<td>'RcppExports.R' 'utils.R' 'package.R' 'generics.R'
'class_tgrid.R' 'class_numericlist.R' 'class_matlist.R'
'class_ev.R' 'class_derived.R' 'class_mrgmod.R'
'class_mrgsims.R' 'Aaaa.R' 'annot.R' 'chain.R' 'class_build.R'
'class_evd.R' 'events.R' 'class_rx.R' 'compile.R' 'data_set.R'
'datasets.R' 'env.R' 'funset.R' 'handle_spec_block.R'
'idata_set.R' 'init.R' 'inven.R' 'knobs.R' 'matlist.R'
'matrix.R' 'mcode.R' 'model_include.R' 'modlib.R' 'modspec.R'
'mread.R' 'mrgindata.R' 'mrgsim_q.R' 'mrgsims.R' 'mrgsolve.R'
'mwrite.R' 'nm-mode.R' 'nmxml.R' 'param.R' 'print.R'
'r_to_cpp.R' 'realize_addl.R' 'relabel.R' 'render.R' 'update.R'
'workflows.R'</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-10-18 12:42:49 UTC; kyleb</td>
</tr>
<tr>
<td>Author:</td>
<td>Kyle T Baron <a href="https://orcid.org/0000-0001-7252-5656"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cre],
  Bill Gillespie [ctb],
  Charles Margossian [ctb],
  Devin Pastoor [ctb],
  Bill Denney <a href="https://orcid.org/0000-0002-5759-428X"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [ctb],
  Dilawar Singh [ctb],
  Felicien Le Louedec
    <a href="https://orcid.org/0000-0003-3699-2729"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [ctb],
  Timothy Waterhouse
    <a href="https://orcid.org/0000-0002-0954-9660"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [ctb],
  Kyle Meyer [ctb],
  Metrum Research Group [cph]</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-10-18 13:20:05 UTC</td>
</tr>
</table>
<hr>
<h2 id='mrgsolve-package'>mrgsolve: Simulate from ODE-Based Models</h2><span id='topic+mrgsolve'></span><span id='topic+mrgsolve-package'></span>

<h3>Description</h3>

<p>mrgsolve is an R package maintained under the auspices of
Metrum Research Group that facilitates simulation from
models based on systems of ordinary differential equations (ODE)
that are typically employed for understanding pharmacokinetics,
pharmacodynamics, and systems biology and pharmacology. mrgsolve
consists of computer code written in the R and C++ languages,
providing an interface to a C++ translation of the lsoda differential
equation solver. See <a href="#topic+aboutsolver">aboutsolver</a> for more information.
</p>


<h3>Resources</h3>


<ul>
<li><p> Main mrgsolve resource page: <a href="https://mrgsolve.org">https://mrgsolve.org</a>
</p>
</li>
<li><p> User guide: <a href="https://mrgsolve.org/user_guide/">https://mrgsolve.org/user_guide/</a>
</p>
</li>
<li><p> Package documentation and vignettes: <a href="https://mrgsolve.org/docs/">https://mrgsolve.org/docs/</a>
</p>
</li></ul>



<h3>Package-wide options</h3>


<ul>
<li> <p><code>mrgolve.project</code>: sets the default project director (<code><a href="#topic+mread">mread()</a></code>)
</p>
</li>
<li> <p><code>mrgsolve.soloc</code>: sets the default package build directory (<code><a href="#topic+mread">mread()</a></code>)
</p>
</li>
<li> <p><code>mrgsolve_mread_quiet</code>: don't print messages during <code><a href="#topic+mread">mread()</a></code>
</p>
</li>
<li> <p><code>mrgsolve.update.strict</code>: this option has been deprecated; use the <code>strict</code>
argument to <code><a href="#topic+update">update()</a></code> instead
</p>
</li></ul>



<h3>Author(s)</h3>

<p><strong>Maintainer</strong>: Kyle T Baron <a href="mailto:kyleb@metrumrg.com">kyleb@metrumrg.com</a> (<a href="https://orcid.org/0000-0001-7252-5656">ORCID</a>)
</p>
<p>Other contributors:
</p>

<ul>
<li><p> Bill Gillespie [contributor]
</p>
</li>
<li><p> Charles Margossian [contributor]
</p>
</li>
<li><p> Devin Pastoor [contributor]
</p>
</li>
<li><p> Bill Denney (<a href="https://orcid.org/0000-0002-5759-428X">ORCID</a>) [contributor]
</p>
</li>
<li><p> Dilawar Singh [contributor]
</p>
</li>
<li><p> Felicien Le Louedec (<a href="https://orcid.org/0000-0003-3699-2729">ORCID</a>) [contributor]
</p>
</li>
<li><p> Timothy Waterhouse (<a href="https://orcid.org/0000-0002-0954-9660">ORCID</a>) [contributor]
</p>
</li>
<li><p> Kyle Meyer [contributor]
</p>
</li>
<li><p> Metrum Research Group [copyright holder]
</p>
</li></ul>



<h3>See Also</h3>

<p>Useful links:
</p>

<ul>
<li> <p><a href="https://mrgsolve.org/docs/">https://mrgsolve.org/docs/</a>
</p>
</li>
<li> <p><a href="https://github.com/metrumresearchgroup/mrgsolve">https://github.com/metrumresearchgroup/mrgsolve</a>
</p>
</li>
<li><p> Report bugs at <a href="https://github.com/metrumresearchgroup/mrgsolve/issues">https://github.com/metrumresearchgroup/mrgsolve/issues</a>
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>
## example("mrgsolve")

mod &lt;- mrgsolve::house(delta=0.1)  %&gt;% param(CL=0.5)

events &lt;-  ev(amt=1000, cmt=1, addl=5, ii=24)

events

mod

see(mod)

## Not run: 
stime(mod)

## End(Not run)
param(mod)

init(mod)

out &lt;- mod %&gt;% ev(events) %&gt;% mrgsim(end=168)

head(out)
tail(out)
dim(out)

plot(out, GUT+CP~.)

sims &lt;- as.data.frame(out)

t72 &lt;- dplyr::filter(sims, time==72)

str(t72)

idata &lt;- data.frame(ID=c(1,2,3), CL=c(0.5,1,2),VC=12)
out &lt;- mod %&gt;% ev(events) %&gt;% mrgsim(end=168, idata=idata, req="")
plot(out)

out &lt;- mod %&gt;% ev(events) %&gt;% mrgsim(carry_out="amt,evid,cmt,CL")
head(out)

ev1 &lt;- ev(amt=500, cmt=2,rate=10)
ev2 &lt;- ev(amt=100, cmt=1, time=54, ii=8, addl=10)
events &lt;- c(ev1+ev2)
events

out &lt;- mod %&gt;% ev(events) %&gt;% mrgsim(end=180, req="")
plot(out)


## "Condensed" data set
data(extran1)
extran1

out &lt;- mod %&gt;% data_set(extran1) %&gt;% mrgsim(end=200)

plot(out,CP~time|factor(ID))


## idata
data(exidata)

out &lt;- 
  mod %&gt;% 
  ev(amt=1000, cmt=1) %&gt;% 
  idata_set(exidata) %&gt;%  
  mrgsim(end=72)

plot(out, CP~., as="log10")


# Internal model library
## Not run: 
mod &lt;- mread("irm1", modlib())

mod

x &lt;- mod %&gt;% ev(amt=300, ii=12, addl=3) %&gt;% mrgsim


## End(Not run)

</code></pre>

<hr>
<h2 id='+25+26gt+3B+25'>Forward pipe</h2><span id='topic++25+3E+25'></span>

<h3>Description</h3>

<p>Forward pipe
</p>

<hr>
<h2 id='+24+2Cev-method'>Select columns from an ev object</h2><span id='topic++24+2Cev-method'></span><span id='topic++5B+5B+2Cev-method'></span>

<h3>Description</h3>

<p>Select columns from an ev object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'ev'
x$name

## S4 method for signature 'ev'
x[[i, exact = TRUE]]
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="+2B24+2B2Cev-method_+3A_x">x</code></td>
<td>
<p>ev object</p>
</td></tr>
<tr><td><code id="+2B24+2B2Cev-method_+3A_name">name</code></td>
<td>
<p>column to select</p>
</td></tr>
<tr><td><code id="+2B24+2B2Cev-method_+3A_i">i</code></td>
<td>
<p>an element to select</p>
</td></tr>
<tr><td><code id="+2B24+2B2Cev-method_+3A_exact">exact</code></td>
<td>
<p>not used</p>
</td></tr>
</table>

<hr>
<h2 id='+24+2Cmrgmod-method'>Select parameter values from a model object</h2><span id='topic++24+2Cmrgmod-method'></span><span id='topic++5B+5B+2Cmrgmod-method'></span><span id='topic++5B+2Cmrgmod-method'></span>

<h3>Description</h3>

<p>The <code>$</code> and <code>[[</code> operators get the value 
of a single parameter in the model.  The 
<code>[</code> gets several values, returning a 
named list.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'mrgmod'
x$name

## S4 method for signature 'mrgmod'
x[[i, exact = TRUE]]

## S4 method for signature 'mrgmod'
x[i]
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="+2B24+2B2Cmrgmod-method_+3A_x">x</code></td>
<td>
<p>mrgmod object</p>
</td></tr>
<tr><td><code id="+2B24+2B2Cmrgmod-method_+3A_name">name</code></td>
<td>
<p>parameter to take</p>
</td></tr>
<tr><td><code id="+2B24+2B2Cmrgmod-method_+3A_i">i</code></td>
<td>
<p>an element to select</p>
</td></tr>
<tr><td><code id="+2B24+2B2Cmrgmod-method_+3A_exact">exact</code></td>
<td>
<p>not used</p>
</td></tr>
</table>

<hr>
<h2 id='aboutsolver'>About the lsoda differential equation solver used by mrgsolve</h2><span id='topic+aboutsolver'></span>

<h3>Description</h3>

<p>The differential equation solver is a C++ translation of DLSODA from
ODEPACK.  The C++ translation was created by Dilawar Singh and hosted
here <a href="https://github.com/dilawar/libsoda-cxx/">https://github.com/dilawar/libsoda-cxx/</a>.
As we understand the history of the code, Heng Li was also involved in early
versions of the code written in C.  There was a potentially-related
project hosted here <a href="https://github.com/sdwfrost/liblsoda/">https://github.com/sdwfrost/liblsoda/</a>.
</p>


<h3>Details</h3>

<p>The C++ translation by Dilawar Singh contains functions that appear to be
based on BLAS and LAPACK routines.  These functions have been renamed to be
distinct from the respective BLAS and LAPACK function names.  References
are given in the section below.
</p>


<h3>History</h3>

<p>The following history was recorded in the source code published by
Dilawar Singh:
</p>
<pre>
/*
* HISTORY:
* This is a CPP version of the LSODA library for integration into MOOSE
somulator.
* The original was aquired from
* http://www.ccl.net/cca/software/SOURCES/C/kinetics2/index.shtml and modified
by
* Heng Li &lt;lh3lh3@gmail.com&gt;. Heng merged several C files into one and added a
* simpler interface. [Available
here](http://lh3lh3.users.sourceforge.net/download/lsoda.c)

* The original source code came with no license or copyright
* information. Heng Li released his modification under the MIT/X11 license. I
* maintain the same license. I have removed quite a lot of text/comments from
* this library. Please refer to the standard documentation.
*
* Contact: Dilawar Singh &lt;dilawars@ncbs.res.in&gt;
*/
</pre>


<h3>References</h3>


<ol>
<li><p> LAPACK: <a href="https://netlib.org/lapack/">https://netlib.org/lapack/</a>
</p>
</li>
<li><p> BLAS: <a href="https://netlib.org/blas/">https://netlib.org/blas/</a>
</p>
</li></ol>


<hr>
<h2 id='as_bmat'>Coerce R objects to block or diagonal matrices</h2><span id='topic+as_bmat'></span><span id='topic+as_bmat+2Clist-method'></span><span id='topic+as_bmat+2Cnumeric-method'></span><span id='topic+as_bmat+2Cdata.frame-method'></span><span id='topic+as_bmat+2CANY-method'></span><span id='topic+as_dmat'></span><span id='topic+as_dmat+2Clist-method'></span><span id='topic+as_dmat+2CANY-method'></span><span id='topic+as_dmat+2Cnumeric-method'></span><span id='topic+as_dmat+2Cdata.frame-method'></span><span id='topic+as_cmat'></span>

<h3>Description</h3>

<p>These are simple functions that may be helpful to create the matrix objects
that mrgsolve expects.  Functions are named based on whether they create a
diagonal matrix (<code>d</code>), a block matrix (<code>b</code>), or a a correlation
matrix (<code>c</code>).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>as_bmat(x, ...)

## S4 method for signature 'list'
as_bmat(x, ...)

## S4 method for signature 'numeric'
as_bmat(x, pat = "*", ...)

## S4 method for signature 'data.frame'
as_bmat(x, pat = "*", cols = NULL, ...)

## S4 method for signature 'ANY'
as_bmat(x, ...)

as_dmat(x, ...)

## S4 method for signature 'list'
as_dmat(x, ...)

## S4 method for signature 'ANY'
as_dmat(x, ...)

## S4 method for signature 'numeric'
as_dmat(x, pat = "*", ...)

## S4 method for signature 'data.frame'
as_dmat(x, pat = "*", cols = NULL, ...)

as_cmat(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="as_bmat_+3A_x">x</code></td>
<td>
<p>data frame or list.</p>
</td></tr>
<tr><td><code id="as_bmat_+3A_...">...</code></td>
<td>
<p>arguments passed to <code><a href="#topic+dmat">dmat()</a></code> or <code><a href="#topic+cmat">cmat()</a></code>.</p>
</td></tr>
<tr><td><code id="as_bmat_+3A_pat">pat</code></td>
<td>
<p>regular expression, character.</p>
</td></tr>
<tr><td><code id="as_bmat_+3A_cols">cols</code></td>
<td>
<p>column names to use instead of <code>pat</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Use <code>as_dmat()</code> to create a diagonal matrix, <code>as_bmat()</code>
to create a block matrix, and <code>as_cmat()</code> to create a block
matrix where off-diagonal elements are understood to be correlations
rather than covariances. <code>as_cmat()</code> uses <code>as_bmat()</code> to
form the matrix and then converts off-diagonal elements to
covariances before returning.
</p>
<p>The methods for <code>data.frame</code> will work down the rows
of the data frame and make the appropriate matrix from
the data in each row.  The result is a list of matrices.
</p>


<h3>Value</h3>

<p>A numeric matrix for list and numeric methods.  For data.frames,
a list of matrices are returned.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+bmat">bmat()</a></code>, <code><a href="#topic+dmat">dmat()</a></code>, <code><a href="#topic+cmat">cmat()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>df &lt;- data.frame(
  OMEGA1.1 = c(1,2),
  OMEGA2.1 = c(11,22),
  OMEGA2.2 = c(3,4),
  SIGMA1.1 = 1,
  FOO=-1
)

as_bmat(df, "OMEGA")
as_dmat(df,"SIGMA")
as_dmat(df[1,],"OMEGA")

</code></pre>

<hr>
<h2 id='as_data_set'>Create a simulation data set from ev objects or data frames</h2><span id='topic+as_data_set'></span><span id='topic+as_data_set+2Cev-method'></span><span id='topic+as_data_set+2Cdata.frame-method'></span>

<h3>Description</h3>

<p>The goal is to take a series of event objects or data frames and combine them
into a single data frame that can be passed to <code><a href="#topic+data_set">data_set()</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>as_data_set(x, ...)

## S4 method for signature 'ev'
as_data_set(x, ...)

## S4 method for signature 'data.frame'
as_data_set(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="as_data_set_+3A_x">x</code></td>
<td>
<p>an ev object or data frame.</p>
</td></tr>
<tr><td><code id="as_data_set_+3A_...">...</code></td>
<td>
<p>additional ev objects or data frames.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Each event object or data frame is added to the data frame as an <code>ID</code> or
set of <code>ID</code>s  that are distinct from the <code>ID</code>s in the other event objects.
Note that including <code>ID</code> argument to the <code><a href="#topic+ev">ev()</a></code> call where <code>length(ID)</code> is
greater than one will render that set of events for all of <code>ID</code>s that are
requested.
</p>
<p>When determining the case for output names, the <code>case</code> attribute for
the first <code>ev</code> object passed will be used to set the case for the output
data.frame. In the event <code>x</code> is a data frame, the case of special column
names (like <code>amt/AMT</code> or <code>cmt/CMT</code>) in the first data frame will be assessed
and the case in the output data frame will be determined based on the
relative numbers of lower or upper names.
</p>
<p>To get a data frame with one row (event) per <code>ID</code>, look at <code><a href="#topic+expand.ev">expand.ev()</a></code>.
</p>


<h3>Value</h3>

<p>A data frame suitable for passing into <code><a href="#topic+data_set">data_set()</a></code>. The columns will appear
in a standardized order.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+expand.ev">expand.ev()</a></code>, <code><a href="#topic+expand.evd">expand.evd()</a></code>, <code><a href="#topic+ev">ev()</a></code>, <code><a href="#topic+evd">evd()</a></code>, <code><a href="#topic+uctran">uctran()</a></code>,
<code><a href="#topic+lctran">lctran()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>a &lt;- ev(amt = c(100,200), cmt=1, ID = seq(3))
b &lt;- ev(amt = 300, time = 24, ID = seq(2))
c &lt;- ev(amt = 1000, ii = 8, addl = 10, ID = seq(3))

as_data_set(a, b, c)

d &lt;- evd(amt = 500)

as_data_set(d, a)

# Output will have upper case nmtran names
as_data_set(
  data.frame(AMT = 100, ID = 1:2), 
  data.frame(amt = 200, rate = 5, cmt = 2)
)

# Instead of this, use expand.ev
as_data_set(ev(amt = 100), ev(amt = 200), ev(amt = 300))

</code></pre>

<hr>
<h2 id='as_deslist'>Create a list of designs from a data frame</h2><span id='topic+as_deslist'></span>

<h3>Description</h3>

<p>Create a list of designs from a data frame
</p>


<h3>Usage</h3>

<pre><code class='language-R'>as_deslist(data, descol = "ID")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="as_deslist_+3A_data">data</code></td>
<td>
<p>input data set; see <strong>Details</strong>.</p>
</td></tr>
<tr><td><code id="as_deslist_+3A_descol">descol</code></td>
<td>
<p>character column name to be used for design groups.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The input data set must have a column with the same name as the value
of <code>descol</code>.  Other column names should be <code>start</code> (the time
of the first observation), <code>end</code> (the time of the last observation),
<code>delta</code> (the time steps to take between <code>start</code> and <code>end</code>),
and <code>add</code> (other, ad-hoc times).  Note that <code>add</code> might be
a <code>list-column</code> to get a vector of times for each time grid object.
</p>


<h3>Value</h3>

<p>The function returns a list of <code>tgrid</code> objects,
one for each unique value found in <code>descol</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>idata &lt;- tibble::tibble(ID=1:4, end=seq(24,96,24), delta=6,
add=list(c(122,124,135),c(111), c(99),c(88)))

idata &lt;- dplyr::mutate(idata, GRP = ID %%2)

idata

l &lt;- as_deslist(idata,"GRP")

l

lapply(l,stime)

lapply(as_deslist(idata, "ID"),stime)

</code></pre>

<hr>
<h2 id='as.ev'>Coerce an object to class ev</h2><span id='topic+as.ev'></span><span id='topic+as.ev+2Cdata.frame-method'></span><span id='topic+as.ev+2Cev-method'></span>

<h3>Description</h3>

<p>Use this function to convert a data frame to an event object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>as.ev(x, ...)

## S4 method for signature 'data.frame'
as.ev(x, keep_id = TRUE, clean = FALSE, ...)

## S4 method for signature 'ev'
as.ev(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="as.ev_+3A_x">x</code></td>
<td>
<p>an object to coerce.</p>
</td></tr>
<tr><td><code id="as.ev_+3A_...">...</code></td>
<td>
<p>not used.</p>
</td></tr>
<tr><td><code id="as.ev_+3A_keep_id">keep_id</code></td>
<td>
<p>if <code>TRUE</code>, ID column is retained if it exists.</p>
</td></tr>
<tr><td><code id="as.ev_+3A_clean">clean</code></td>
<td>
<p>if <code>TRUE</code>, only dosing or ID information is retained in
the result.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If <code>CMT</code> (or <code>cmt</code>) is missing from the input, it will be set to 1
in the event object.
</p>
<p>If <code>TIME</code> (or <code>time</code>) is missing from the input, it will be set to
0 in the event object.
</p>
<p>If <code>EVID</code> (or <code>evid</code>) is missing from the input, it will be set to
1 in the event object.
</p>


<h3>Value</h3>

<p>An object with class ev.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data &lt;- data.frame(AMT = 100) 

as.ev(data)

as.ev(data, clean = TRUE)

</code></pre>

<hr>
<h2 id='as.list+2Cmrgmod-method'>Coerce a model object to list</h2><span id='topic+as.list+2Cmrgmod-method'></span>

<h3>Description</h3>

<p>Coerce a model object to list
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'mrgmod'
as.list(x, deep = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="as.list+2B2Cmrgmod-method_+3A_x">x</code></td>
<td>
<p>a model object.</p>
</td></tr>
<tr><td><code id="as.list+2B2Cmrgmod-method_+3A_deep">deep</code></td>
<td>
<p>if <code>TRUE</code>, extra information is returned in the output list
(see <strong>Details</strong>).</p>
</td></tr>
<tr><td><code id="as.list+2B2Cmrgmod-method_+3A_...">...</code></td>
<td>
<p>not used.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If <code>deep</code> is <code>TRUE</code>, then the values for <code>trans</code>, <code>advan</code>, and <code>mindt</code> are
returned as well as a summary of internal model functions (with a call to
<code>mrgsolve:::funset()</code>).
</p>


<h3>Value</h3>

<p>A named list containing formatted contents from <code>x</code>.
</p>


<h3>Slots</h3>


<ul>
<li> <p><code>npar</code>: number of parameters
</p>
</li>
<li> <p><code>neq</code>: number of compartments or differential equations
</p>
</li>
<li> <p><code>pars</code>: names of model parameters
</p>
</li>
<li> <p><code>covariates</code>: names of parameters identified as covariates
</p>
</li>
<li> <p><code>cmt</code>: names of model compartments
</p>
</li>
<li> <p><code>param</code>: the parameter list
</p>
</li>
<li> <p><code>init</code>: initial condition list
</p>
</li>
<li> <p><code>omega</code>: <code style="white-space: pre;">&#8288;$OMEGA&#8288;</code> matrices, as a <code>matlist</code> object
</p>
</li>
<li> <p><code>sigma</code>: <code style="white-space: pre;">&#8288;$SIGMA&#8288;</code> matrices, as a <code>matlist</code> object
</p>
</li>
<li> <p><code>fixed</code>: named list of <code style="white-space: pre;">&#8288;$FIXED&#8288;</code> values
</p>
</li>
<li> <p><code>model</code>: model name
</p>
</li>
<li> <p><code>project</code>: model project directory
</p>
</li>
<li> <p><code>soloc</code>: directory where the model is being built
</p>
</li>
<li> <p><code>sodll</code>: complete path to the model shared object
</p>
</li>
<li> <p><code>cfile</code>: path for the model source code file
</p>
</li>
<li> <p><code>shlib</code>: list of compilation information
</p>
</li>
<li> <p><code>start</code>: simulation start time
</p>
</li>
<li> <p><code>end</code>: simulation end time
</p>
</li>
<li> <p><code>delta</code>: simulation time step
</p>
</li>
<li> <p><code>add</code>: additional simulation times
</p>
</li>
<li> <p><code>capture</code>: names of captured data items
</p>
</li>
<li> <p><code>request</code>: compartments requested upon simulation
</p>
</li>
<li> <p><code>cmti</code>: named indices for current output compartments
</p>
</li>
<li> <p><code>capturei</code>: named indices for current output capture
</p>
</li>
<li> <p><code>random</code>: names and labels of <code style="white-space: pre;">&#8288;$OMEGA&#8288;</code> and <code style="white-space: pre;">&#8288;$SIGMA&#8288;</code>
</p>
</li>
<li> <p><code>code</code>: model source code from <code>cfile</code>
</p>
</li>
<li> <p><code>details</code>: model details data frame
</p>
</li>
<li> <p><code>nm_import</code>: a character vector listing the names of nonmem output files
that were read to import estimates from a completed nonmem run
</p>
</li>
<li> <p><code>cpp_variables</code>: a data frame listing variables internal to the model
cpp file
</p>
</li>
<li> <p><code>atol</code>: see <a href="#topic+solversettings">solversettings</a>
</p>
</li>
<li> <p><code>rtol</code>: see <a href="#topic+solversettings">solversettings</a>
</p>
</li>
<li> <p><code>ss_atol</code>: absolute tolerance to use when advancing to PK steady state
</p>
</li>
<li> <p><code>ss_rtol</code>: relative tolerance to use when advancing to PK steady state
</p>
</li>
<li> <p><code>maxsteps</code>: see <a href="#topic+solversettings">solversettings</a>
</p>
</li>
<li> <p><code>hmin</code>: see <a href="#topic+solversettings">solversettings</a>
</p>
</li>
<li> <p><code>hmax</code>: see <a href="#topic+solversettings">solversettings</a>
</p>
</li>
<li> <p><code>envir</code>: the model environment
</p>
</li>
<li> <p><code>plugins</code>: plugins invoked in the model
</p>
</li>
<li> <p><code>digits</code>: number of digits to request in simulated data
</p>
</li>
<li> <p><code>tscale</code>: multiplicative scalar for time in results only
</p>
</li>
<li> <p><code>mindt</code>: simulation output time below which there model will assume to
have not advanced
</p>
</li>
<li> <p><code>preclean</code>: logical indicating to clean up compilation artifacts prior
to compiling
</p>
</li>
<li> <p><code>debug</code>: print debugging information during simulation run
</p>
</li>
<li> <p><code>verbose</code>: print extra information during setup for model run
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>mod &lt;- mrgsolve::house()
l &lt;- as.list(mod)

</code></pre>

<hr>
<h2 id='as.list+2Cmrgsims-method'>Coerce an mrgsims object to list</h2><span id='topic+as.list+2Cmrgsims-method'></span>

<h3>Description</h3>

<p>Coerce an mrgsims object to list
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'mrgsims'
as.list(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="as.list+2B2Cmrgsims-method_+3A_x">x</code></td>
<td>
<p>an mrgsims object.</p>
</td></tr>
<tr><td><code id="as.list+2B2Cmrgsims-method_+3A_...">...</code></td>
<td>
<p>not used.</p>
</td></tr>
</table>

<hr>
<h2 id='BLOCK_PARSE'>Functions to parse code blocks</h2><span id='topic+BLOCK_PARSE'></span><span id='topic+PARAM'></span><span id='topic+FIXED'></span><span id='topic+THETA'></span><span id='topic+INIT'></span><span id='topic+CMT'></span><span id='topic+CAPTURE'></span><span id='topic+HANDLEMATRIX'></span>

<h3>Description</h3>

<p>Most of the basic blocks are listed in this help topic.
But see also <code><a href="#topic+PKMODEL">PKMODEL()</a></code> which has more-involved
options and is documented separately.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>PARAM(
  x,
  env,
  pos = 1,
  annotated = FALSE,
  object = NULL,
  as_object = FALSE,
  covariates = FALSE,
  input = FALSE,
  tag = NULL,
  ...
)

FIXED(x, env, pos = 1, annotated = FALSE, ...)

THETA(
  x,
  env,
  pos = 1,
  annotated = FALSE,
  object = NULL,
  as_object = FALSE,
  name = "THETA",
  fill = NULL,
  ...
)

INIT(x, env, pos = 1, annotated = FALSE, object = NULL, as_object = FALSE, ...)

CMT(
  x,
  env,
  pos = 1,
  annotated = FALSE,
  object = NULL,
  as_object = FALSE,
  number = NULL,
  prefix = "A",
  ...
)

CAPTURE(x, env, pos = 1, annotated = FALSE, etas = NULL, ...)

HANDLEMATRIX(
  x,
  env,
  pos = 1,
  annotated = FALSE,
  object = NULL,
  as_object = FALSE,
  name = "...",
  type = NULL,
  oclass = "",
  prefix = "",
  labels = NULL,
  unlinked = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="BLOCK_PARSE_+3A_x">x</code></td>
<td>
<p>data</p>
</td></tr>
<tr><td><code id="BLOCK_PARSE_+3A_env">env</code></td>
<td>
<p>parse environment</p>
</td></tr>
<tr><td><code id="BLOCK_PARSE_+3A_pos">pos</code></td>
<td>
<p>block position</p>
</td></tr>
<tr><td><code id="BLOCK_PARSE_+3A_annotated">annotated</code></td>
<td>
<p>logical</p>
</td></tr>
<tr><td><code id="BLOCK_PARSE_+3A_object">object</code></td>
<td>
<p>the name of an object in <code>ENV</code></p>
</td></tr>
<tr><td><code id="BLOCK_PARSE_+3A_as_object">as_object</code></td>
<td>
<p>indicates that object code is being provided</p>
</td></tr>
<tr><td><code id="BLOCK_PARSE_+3A_covariates">covariates</code></td>
<td>
<p>logical; mark as covariates and potentially required
data input</p>
</td></tr>
<tr><td><code id="BLOCK_PARSE_+3A_input">input</code></td>
<td>
<p>logical; mark as potentially required data input</p>
</td></tr>
<tr><td><code id="BLOCK_PARSE_+3A_tag">tag</code></td>
<td>
<p>space or comma-separated user-defined tags for the parameter block</p>
</td></tr>
<tr><td><code id="BLOCK_PARSE_+3A_...">...</code></td>
<td>
<p>passed</p>
</td></tr>
<tr><td><code id="BLOCK_PARSE_+3A_name">name</code></td>
<td>
<p>block name</p>
</td></tr>
<tr><td><code id="BLOCK_PARSE_+3A_fill">fill</code></td>
<td>
<p>deprecated; not used</p>
</td></tr>
<tr><td><code id="BLOCK_PARSE_+3A_number">number</code></td>
<td>
<p>number of compartments to create</p>
</td></tr>
<tr><td><code id="BLOCK_PARSE_+3A_prefix">prefix</code></td>
<td>
<p>a prefix to add to the label</p>
</td></tr>
<tr><td><code id="BLOCK_PARSE_+3A_etas">etas</code></td>
<td>
<p>allows for block capture of ETAs in the simulated output;
this should be R code that will get parsed and evaluated; the result should 
be an integer-like vector which identifies which ETAs will be captured.</p>
</td></tr>
<tr><td><code id="BLOCK_PARSE_+3A_type">type</code></td>
<td>
<p>internal use</p>
</td></tr>
<tr><td><code id="BLOCK_PARSE_+3A_oclass">oclass</code></td>
<td>
<p>internal use</p>
</td></tr>
<tr><td><code id="BLOCK_PARSE_+3A_labels">labels</code></td>
<td>
<p>aliases to use for simulated ETA values</p>
</td></tr>
<tr><td><code id="BLOCK_PARSE_+3A_unlinked">unlinked</code></td>
<td>
<p>internal use</p>
</td></tr>
</table>


<h3>Details</h3>

<p>When using <code>object</code> or <code>as_object</code> populate the block contents, the following
types are required
</p>

<ul>
<li> <p><code>PARAM</code>: a named list
</p>
</li>
<li> <p><code>INIT</code> : a named list
</p>
</li>
<li> <p><code>THETA</code> : a numeric vector; names are ignored
</p>
</li>
<li> <p><code>CMT</code>: a character vector
</p>
</li>
<li> <p><code>OMEGA</code>: matrix; set rownames on the matrix to create ETA labels; setting
rownames is the only way to specify <code>labels</code> when working through the
<code>object</code> or <code>as_object</code> directives
</p>
</li>
<li> <p><code>SIGMA</code>: matrix; set rownames on the matrix to create EPS labels; setting
rownames is the only way to specify <code>labels</code> when working through the
<code>object</code> or <code>as_object</code> directives
</p>
</li></ul>



<h3>See Also</h3>

<p><code><a href="#topic+PKMODEL">PKMODEL()</a></code>
</p>

<hr>
<h2 id='blocks'>Return the code blocks from a model specification file</h2><span id='topic+blocks'></span><span id='topic+blocks+2Cmrgmod-method'></span><span id='topic+blocks+2Ccharacter-method'></span>

<h3>Description</h3>

<p>Return the code blocks from a model specification file
</p>


<h3>Usage</h3>

<pre><code class='language-R'>blocks(x, ...)

## S4 method for signature 'mrgmod'
blocks(x, ...)

## S4 method for signature 'character'
blocks(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="blocks_+3A_x">x</code></td>
<td>
<p>model object or path to model specification file</p>
</td></tr>
<tr><td><code id="blocks_+3A_...">...</code></td>
<td>
<p>passed along</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>mod &lt;- mrgsolve::house()
mod %&gt;% blocks
mod %&gt;% blocks(PARAM,TABLE)

</code></pre>

<hr>
<h2 id='c+2Cmatlist-method'>Operations with matlist objects</h2><span id='topic+c+2Cmatlist-method'></span>

<h3>Description</h3>

<p>Operations with matlist objects
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'matlist'
c(x, ..., recursive = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="c+2B2Cmatlist-method_+3A_x">x</code></td>
<td>
<p>a matlist object</p>
</td></tr>
<tr><td><code id="c+2B2Cmatlist-method_+3A_...">...</code></td>
<td>
<p>other matlist objects</p>
</td></tr>
<tr><td><code id="c+2B2Cmatlist-method_+3A_recursive">recursive</code></td>
<td>
<p>not used</p>
</td></tr>
</table>

<hr>
<h2 id='c+2Ctgrid-method'>Operations with tgrid objects</h2><span id='topic+c+2Ctgrid-method'></span><span id='topic+c+2Ctgrids-method'></span><span id='topic+tgrid_+2B_numeric'></span><span id='topic++2B+2Ctgrid+2Cnumeric-method'></span><span id='topic+tgrid_+2A_numeric'></span><span id='topic++2A+2Ctgrid+2Cnumeric-method'></span><span id='topic+tgrids_+2B_numeric'></span><span id='topic++2B+2Ctgrids+2Cnumeric-method'></span><span id='topic+tgrids_+2A_numeric'></span><span id='topic++2A+2Ctgrids+2Cnumeric-method'></span>

<h3>Description</h3>

<p>Operations with tgrid objects
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'tgrid'
c(x, ..., recursive = FALSE)

## S4 method for signature 'tgrids'
c(x, ..., recursive = FALSE)

## S4 method for signature 'tgrid,numeric'
e1 + e2

## S4 method for signature 'tgrid,numeric'
e1 * e2

## S4 method for signature 'tgrids,numeric'
e1 + e2

## S4 method for signature 'tgrids,numeric'
e1 * e2
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="c+2B2Ctgrid-method_+3A_x">x</code></td>
<td>
<p>a tgrid object.</p>
</td></tr>
<tr><td><code id="c+2B2Ctgrid-method_+3A_...">...</code></td>
<td>
<p>additional tgrid objects.</p>
</td></tr>
<tr><td><code id="c+2B2Ctgrid-method_+3A_recursive">recursive</code></td>
<td>
<p>not used.</p>
</td></tr>
<tr><td><code id="c+2B2Ctgrid-method_+3A_e1">e1</code></td>
<td>
<p>tgrid or tgrids object</p>
</td></tr>
<tr><td><code id="c+2B2Ctgrid-method_+3A_e2">e2</code></td>
<td>
<p>numeric value</p>
</td></tr>
</table>

<hr>
<h2 id='cama'>Run the model cama function</h2><span id='topic+cama'></span>

<h3>Description</h3>

<p>Run the model cama function
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cama(mod, fn = "cama", ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="cama_+3A_mod">mod</code></td>
<td>
<p>a model object.</p>
</td></tr>
<tr><td><code id="cama_+3A_fn">fn</code></td>
<td>
<p>function name.</p>
</td></tr>
<tr><td><code id="cama_+3A_...">...</code></td>
<td>
<p>passed to update.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>sah-mah</code>
</p>

<hr>
<h2 id='carry_out'>Select items to carry into simulated output</h2><span id='topic+carry_out'></span><span id='topic+carry.out'></span>

<h3>Description</h3>

<p>When items named in this function are found in the input data set (either
<code><a href="#topic+data_set">data_set()</a></code> or <code><a href="#topic+idata_set">idata_set()</a></code>), they are copied
into the simulated output.  Special items like <code>evid</code> or <code>amt</code> or
the like are not copied from the data set per se, but they are copied from
<code>datarecord</code> objects that are created during the simulation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>carry_out(x, ...)

carry.out(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="carry_out_+3A_x">x</code></td>
<td>
<p>model object.</p>
</td></tr>
<tr><td><code id="carry_out_+3A_...">...</code></td>
<td>
<p>unquoted names of data items to copy into the simulated output.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>There is also a <code>carry_out</code> argument to <code><a href="#topic+mrgsim">mrgsim()</a></code> that can be set to
accomplish the same thing as a call to <code>carry_out</code> in the pipeline.
</p>
<p><code>carry.out</code> and <code>carry_out</code> both do the same thing; using the underscore
version is now preferred.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>mod &lt;- mrgsolve::house()

e &lt;- ev(amt = 100, ii = 6, addl = 3, WT = 70, dose = amt)

out &lt;- mod %&gt;% ev(e) %&gt;% carry_out(amt, dose, WT) %&gt;% mrgsim()

head(out)

</code></pre>

<hr>
<h2 id='check_data_names'>Check input data set names against model parameters</h2><span id='topic+check_data_names'></span>

<h3>Description</h3>

<p>Use this function to check names of input data sets against parameters that
have been assigned different tags. Assignment is made in the model
specification file. This is useful to alert the user to misspelled or
otherwise misspecified parameter names in input data sets. See <code><a href="#topic+param_tags">param_tags()</a></code>
for information on associating tags with parameters.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>check_data_names(
  data,
  x,
  check_covariates = TRUE,
  check_inputs = TRUE,
  tags = NULL,
  mode = c("warn", "error", "inform"),
  silent = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="check_data_names_+3A_data">data</code></td>
<td>
<p>a data frame or other object with names to check.</p>
</td></tr>
<tr><td><code id="check_data_names_+3A_x">x</code></td>
<td>
<p>a model object.</p>
</td></tr>
<tr><td><code id="check_data_names_+3A_check_covariates">check_covariates</code></td>
<td>
<p>logical; if <code>TRUE</code>, check <code>data</code> for parameter names
carrying the <code>covariates</code> tag.</p>
</td></tr>
<tr><td><code id="check_data_names_+3A_check_inputs">check_inputs</code></td>
<td>
<p>logical; if <code>TRUE</code>, check <code>data</code> for parameter names
carrying the <code>input</code> tag.</p>
</td></tr>
<tr><td><code id="check_data_names_+3A_tags">tags</code></td>
<td>
<p>a character vector of user-defined parameter tags to require
in <code>data</code>; this may be a comma- or space-separated string (e.g.
<code>"tag1,tag2"</code>).</p>
</td></tr>
<tr><td><code id="check_data_names_+3A_mode">mode</code></td>
<td>
<p>the default is to <code>"warn"</code> the user when <code>data</code> is missing
some expected column names; alternatively, use <code>"error"</code> to issue an
error or <code>"inform"</code> to generate a message when <code>data</code> is missing some
expected column names.</p>
</td></tr>
<tr><td><code id="check_data_names_+3A_silent">silent</code></td>
<td>
<p>silences message on successful check.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>By default, <code>data</code> will be checked for parameters with the <code>covariates</code> or
<code>input</code> tags; these checks can be bypassed with the <code>check_covariates</code>
and <code>check_inputs</code> arguments. When a parameter name is missing from <code>data</code>
the user will be warned by default. Use <code>mode = "error"</code> to generate an
error instead of a warning and use <code>mode = "inform"</code> to simply be informed.
When the user has not tagged any parameters for checking, there will
either be a warning (default) or an error (when <code>mode = "error"</code>).
</p>
<p>It is an error to request a parameter tag via the <code>tags</code> argument when that
tag is not found in the model.
</p>
<p>It is an error to call <code>check_data_names</code> when no parameters have been tagged
in the model specification file (see <code><a href="#topic+param_tags">param_tags()</a></code>).
</p>


<h3>Value</h3>

<p>A logical value is returned; <code>TRUE</code> if all expected parameters were found
and <code>FALSE</code> otherwise.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+param_tags">param_tags()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
mod &lt;- mcode("ex-cdn", "$PARAM @input \n CL = 1, KA = 2", compile = FALSE)

param(mod)

# Coding mistake!
data &lt;- expand.evd(amt = 100, cl = 2, KA = 5)

check_data_names(data, mod)

try(check_data_names(data, mod, mode = "error"))

check_data_names(data, mod, mode = "inform")

</code></pre>

<hr>
<h2 id='cmt_list-class'>S4 cmt_list class</h2><span id='topic+cmt_list-class'></span>

<h3>Description</h3>

<p>S4 cmt_list class
</p>

<hr>
<h2 id='cmtn'>Get the compartment number from a compartment name</h2><span id='topic+cmtn'></span><span id='topic+cmtn+2Cmrgmod-method'></span>

<h3>Description</h3>

<p>Get the compartment number from a compartment name
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cmtn(x, ...)

## S4 method for signature 'mrgmod'
cmtn(x, tag, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="cmtn_+3A_x">x</code></td>
<td>
<p>model object.</p>
</td></tr>
<tr><td><code id="cmtn_+3A_...">...</code></td>
<td>
<p>not used.</p>
</td></tr>
<tr><td><code id="cmtn_+3A_tag">tag</code></td>
<td>
<p>compartment name.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>mod &lt;- mrgsolve::house()
cmtn(mod, "CENT")

</code></pre>

<hr>
<h2 id='code'>Extract the code from a model</h2><span id='topic+code'></span>

<h3>Description</h3>

<p>This function is currently not exported, so be sure to call it with
<code>mrgsolve:::code(...)</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>code(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="code_+3A_x">x</code></td>
<td>
<p>a model object.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A character vector of model code.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>mod &lt;- mrgsolve::house()
mrgsolve:::code(mod)

# Alternative
as.list(mod)$code

</code></pre>

<hr>
<h2 id='collapse_matrix'>Collapse the matrices of a matlist object</h2><span id='topic+collapse_matrix'></span>

<h3>Description</h3>

<p>This function is called by <code><a href="#topic+collapse_omega">collapse_omega()</a></code> and <code><a href="#topic+collapse_sigma">collapse_sigma()</a></code> to
convert multiple matrix blocks into a single matrix block. This &quot;collapsing&quot;
of the matrix list is irreversible.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>collapse_matrix(x, range = NULL, name = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="collapse_matrix_+3A_x">x</code></td>
<td>
<p>an object that inherits from <code>matlist</code>; this object is most
frequently extracted from a model object using <code><a href="#topic+omat">omat()</a></code> or <code><a href="#topic+smat">smat()</a></code> for
<code>OMEGA</code> and <code>SIGMA</code>, respectively.</p>
</td></tr>
<tr><td><code id="collapse_matrix_+3A_range">range</code></td>
<td>
<p>numeric vector of length 2 specifying the range of matrices
to collapse in case there are more than 2. The second element may be <code>NA</code>
to indicate the length of the list of matrices.</p>
</td></tr>
<tr><td><code id="collapse_matrix_+3A_name">name</code></td>
<td>
<p>a new name for the collapsed matrix; note that this is the
matrix name, not the labels which alias <code>ETA(n)</code> or <code>EPS(n)</code>; specifying a
name will only alter how this matrix is potentially updated in the future.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An update <code>matlist</code> object (either <code>omegalist</code> or <code>sigmalist</code>).
</p>


<h3>See Also</h3>

<p><code><a href="#topic+collapse_omega">collapse_omega()</a></code>, <code><a href="#topic+collapse_sigma">collapse_sigma()</a></code>, <code><a href="#topic+omat">omat()</a></code>, <code><a href="#topic+smat">smat()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>omega &lt;- omat(list(dmat(1, 2), dmat(3, 4, 5)))
omega
collapse_matrix(omega)

</code></pre>

<hr>
<h2 id='collapse_omega'>Collapse OMEGA or SIGMA matrix lists</h2><span id='topic+collapse_omega'></span><span id='topic+collapse_sigma'></span>

<h3>Description</h3>

<p>If multiple <code>OMEGA</code> (or <code>SIGMA</code>) blocks were written into the model,
these can be collapsed into a single matrix. This will not change the
functionality of the model, but will alter how <code>OMEGA</code> (or <code>SIGMA</code>) are
updated, usually making it easier. This &quot;collapsing&quot; of the matrix list
is irreversible.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>collapse_omega(x, range = NULL, name = NULL)

collapse_sigma(x, range = NULL, name = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="collapse_omega_+3A_x">x</code></td>
<td>
<p>a model object.</p>
</td></tr>
<tr><td><code id="collapse_omega_+3A_range">range</code></td>
<td>
<p>numeric vector of length 2 specifying the range of matrices
to collapse in case there are more than 2. The second element may be <code>NA</code>
to indicate the length of the list of matrices.</p>
</td></tr>
<tr><td><code id="collapse_omega_+3A_name">name</code></td>
<td>
<p>a new name for the collapsed matrix; note that this is the
matrix name, not the labels which alias <code>ETA(n)</code> or <code>EPS(n)</code>; specifying a
name will only alter how this matrix is potentially updated in the future.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A model object with updated <code>OMEGA</code> or <code>SIGMA</code> matrix lists.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+collapse_matrix">collapse_matrix()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>code &lt;- '
$OMEGA 1 2 3
$OMEGA 4 5
$OMEGA 6 7 8 9
'

mod &lt;- mcode("collapse-example", code, compile = FALSE)
revar(mod)
collapse_omega(mod) %&gt;% omat()
collapse_omega(mod, range = c(2,3), name = "new_matrix") %&gt;% omat()
collapse_omega(mod, range = c(2,NA), name = "new_matrix") %&gt;% omat()

</code></pre>

<hr>
<h2 id='cvec'>Create create character vectors</h2><span id='topic+cvec'></span><span id='topic+cvec.character'></span><span id='topic+s_'></span>

<h3>Description</h3>

<p>Create create character vectors
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cvec(x)

## S3 method for class 'character'
cvec(x)

s_(...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="cvec_+3A_x">x</code></td>
<td>
<p>comma-separated quoted string (for <code>cvec</code>)</p>
</td></tr>
<tr><td><code id="cvec_+3A_...">...</code></td>
<td>
<p>unquoted strings (for <code>ch</code>)</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>
cvec("A,B,C")
s_(A,B,C)
</code></pre>

<hr>
<h2 id='data_set'>Select and modify a data set for simulation</h2><span id='topic+data_set'></span><span id='topic+data_set+2Cmrgmod+2Cdata.frame-method'></span><span id='topic+data_set+2Cmrgmod+2CANY-method'></span><span id='topic+data_set+2Cmrgmod+2Cev-method'></span><span id='topic+data_set+2Cmrgmod+2Cmissing-method'></span>

<h3>Description</h3>

<p>The input data set (<code>data_set</code>) is a data frame that specifies
observations, model events, and / or parameter values for a population
of individuals.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data_set(x, data, ...)

## S4 method for signature 'mrgmod,data.frame'
data_set(
  x,
  data,
  .subset = TRUE,
  .select = TRUE,
  object = NULL,
  need = NULL,
  ...
)

## S4 method for signature 'mrgmod,ANY'
data_set(x, data, ...)

## S4 method for signature 'mrgmod,ev'
data_set(x, data, ...)

## S4 method for signature 'mrgmod,missing'
data_set(x, object, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="data_set_+3A_x">x</code></td>
<td>
<p>a model object.</p>
</td></tr>
<tr><td><code id="data_set_+3A_data">data</code></td>
<td>
<p>input data set as a data frame.</p>
</td></tr>
<tr><td><code id="data_set_+3A_...">...</code></td>
<td>
<p>other arguments passed along when <code>object</code> is a function.</p>
</td></tr>
<tr><td><code id="data_set_+3A_.subset">.subset</code></td>
<td>
<p>an unquoted expression passed to
<code><a href="dplyr.html#topic+filter">dplyr::filter()</a></code>; retain only certain rows in the data set</p>
</td></tr>
<tr><td><code id="data_set_+3A_.select">.select</code></td>
<td>
<p>passed to <code><a href="dplyr.html#topic+select">dplyr::select()</a></code>; retain only certain
columns in the data set; this should be the result of a call to
<code><a href="dplyr.html#topic+vars">dplyr::vars()</a></code>.</p>
</td></tr>
<tr><td><code id="data_set_+3A_object">object</code></td>
<td>
<p>character name of an object existing in <code style="white-space: pre;">&#8288;$ENV&#8288;</code>
to use for the data set.</p>
</td></tr>
<tr><td><code id="data_set_+3A_need">need</code></td>
<td>
<p>passed to <code><a href="#topic+inventory">inventory()</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Input data sets are <code>R</code> data frames that can include columns
with any valid name, however columns with selected names are
treated specially by mrgsolve and incorporated into the
simulation.
</p>
<p><code>ID</code> specifies the subject ID and is required for every
input data set.
</p>
<p>When columns have the same name as parameters (<code style="white-space: pre;">&#8288;$PARAM&#8288;</code> or <code style="white-space: pre;">&#8288;$INPUT&#8288;</code> in
the model specification file), the values in those columns will
be used to update the corresponding parameter as the simulation
progresses.
</p>
<p>Input data set may include the following columns related to
PK dosing events: <code>TIME</code>, <code>CMT</code>, <code>AMT</code>, <code>RATE</code>, <code>II</code>, <code>ADDL</code>, <code>SS</code>.
Both <code>ID</code> and <code>TIME</code> are required columns in the input data set unless
<code style="white-space: pre;">&#8288;$PRED&#8288;</code> is in use.  Lower case PK dosing column names including
<code>time</code>, <code>cmt</code>, <code>amt</code>, <code>rate</code>, <code>ii</code>, <code>addl</code>, <code>ss</code> are also recognized.
However, an error will be generated if a mix of both upper case and lower
case columns in this family are found. Use the functions <code><a href="#topic+lctran">lctran()</a></code> and
<code><a href="#topic+uctran">uctran()</a></code> to convert between upper and lower case naming for these
data items.
</p>
<p><code>TIME</code> is the observation or event time, <code>CMT</code> is the compartment number
(see <code><a href="#topic+init">init()</a></code>), <code>AMT</code> is the dosing amount, <code>RATE</code> is the infusion rate,
<code>II</code> is the dosing interval, <code>ADDL</code> specifies additional doses to
administer, and <code>ss</code> is a flag indicating that the system should be advanced
to a pharmacokinetic steady state prior to administering the dose.  These
column names operate similarly to other non-linear mixed effects modeling
software.
</p>
<p><code>EVID</code> is an integer value specifying the ID of an event record. Values
include:
</p>

<ul>
<li><p> 0: observation
</p>
</li>
<li><p> 1:  dose event, either bolus or infusion
</p>
</li>
<li><p> 2: other-type event; in mrgsolve, this functions like an observation
record, but a discontinuity is created in the simulation at the time of
the event (i.e., the ODE solver will stop and restart at the time of the
event)
</p>
</li>
<li><p> 3: reset the system
</p>
</li>
<li><p> 4: reset the system and dose
</p>
</li>
<li><p> 8: replace the amount in a compartment
</p>
</li></ul>

<p>For all <code>EVID</code> greater than <code>0</code>, a discontinuity is created in the
simulation, as described for <code style="white-space: pre;">&#8288;EVID 2&#8288;</code>.
</p>
<p>An error will be generated when mrgsolve detects that the data set
is not sorted by <code>time</code> within an individual. mrgsolve does <strong>not</strong> allow time
to be reset to zero on records where <code>EVID</code> is set to 4 (reset and dose).
</p>
<p>Only numeric data can be brought in to the problem. Any non-numeric data
columns will be dropped with warning. See <code><a href="#topic+numerics_only">numerics_only()</a></code>, which is used
to prepare the data set.
</p>
<p>An error will be generated if any parameter columns in the
input data set contain missing values (<code>NA</code>). Likewise, and error will
be generated if missing values are found in the following
columns: <code>ID</code>, <code>time</code>/<code>TIME</code>, <code>rate</code>/<code>RATE</code>.
</p>
<p>See <a href="#topic+exdatasets">exdatasets</a> for several example data sets that are provided by
mrgsolve.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+idata_set">idata_set()</a></code>, <code><a href="#topic+ev">ev()</a></code>, <code><a href="#topic+valid_data_set">valid_data_set()</a></code>, <code><a href="#topic+valid_idata_set">valid_idata_set()</a></code>,
<code><a href="#topic+lctran">lctran()</a></code>, <code><a href="#topic+uctran">uctran()</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
mod &lt;- mrgsolve::house()

data &lt;- expand.ev(ID = seq(3), amt = c(10, 20))

mod %&gt;% data_set(data, ID &gt; 1) %&gt;% mrgsim()

data(extran1)
head(extran1)

mod %&gt;% data_set(extran1) %&gt;% mrgsim()
mod %&gt;% mrgsim(data = extran1)

</code></pre>

<hr>
<h2 id='design'>Set observation designs for the simulation</h2><span id='topic+design'></span>

<h3>Description</h3>

<p>This function also allows you to assign different designs to different
groups or individuals in a population.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>design(x, deslist = list(), descol = character(0), ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="design_+3A_x">x</code></td>
<td>
<p>model object</p>
</td></tr>
<tr><td><code id="design_+3A_deslist">deslist</code></td>
<td>
<p>a list of <code>tgrid</code> or <code>tgrids</code> objects or 
<code>numeric</code> vector to be used in place of ...</p>
</td></tr>
<tr><td><code id="design_+3A_descol">descol</code></td>
<td>
<p>the <code>idata</code> column name (<code>character</code>) for design 
assignment</p>
</td></tr>
<tr><td><code id="design_+3A_...">...</code></td>
<td>
<p>not used</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This setup requires the use of an <code>idata_set</code>, with individual-level 
data passed in one <code>ID</code> per row.  For each <code>ID</code>, specify a 
grouping variable in <code>idata</code> (<code>descol</code>).  For each unique value 
of the grouping variable, make one <code><a href="#topic+tgrid">tgrid</a></code> object and pass them 
in order as <code>...</code> or form them into a list and pass as <code>deslist</code>.
</p>
<p>You must assign the <code>idata_set</code> before assigning the designs in the 
command chain (see the example below).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
peak &lt;- tgrid(0,6,0.1)
sparse &lt;- tgrid(0,24,6)

des1 &lt;- c(peak,sparse)
des2 &lt;- tgrid(0,72,4)


data &lt;- expand.ev(ID = 1:10, amt=c(100,300))
data$GRP &lt;- data$amt/100

idata &lt;- data[,c("ID", "amt")]

mod &lt;- mrgsolve::house()

mod %&gt;%
  omat(dmat(1,1,1,1)) %&gt;%
  carry_out(GRP) %&gt;%
  idata_set(idata) %&gt;%
  design(list(des1, des2),"amt") %&gt;%
  data_set(data) %&gt;%
  mrgsim() %&gt;% 
  plot(RESP~time|GRP)

</code></pre>

<hr>
<h2 id='details'>Extract model details</h2><span id='topic+details'></span>

<h3>Description</h3>

<p>Extract model details
</p>


<h3>Usage</h3>

<pre><code class='language-R'>details(x, complete = FALSE, values = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="details_+3A_x">x</code></td>
<td>
<p>a model object</p>
</td></tr>
<tr><td><code id="details_+3A_complete">complete</code></td>
<td>
<p>logical; if <code>TRUE</code>, un-annotated parameters and 
compartments will be added to the output</p>
</td></tr>
<tr><td><code id="details_+3A_values">values</code></td>
<td>
<p>logical; if <code>TRUE</code>, a values column will be added to 
the output</p>
</td></tr>
<tr><td><code id="details_+3A_...">...</code></td>
<td>
<p>not used</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is not exported.  You will have to call it 
with <code>mrgsolve:::details()</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>mod &lt;- mrgsolve::house()

mrgsolve:::details(mod)

</code></pre>

<hr>
<h2 id='env_eval'>Re-evaluate the code in the ENV block</h2><span id='topic+env_eval'></span>

<h3>Description</h3>

<p>The <code style="white-space: pre;">&#8288;$ENV&#8288;</code> block is a block of R code that can realize any sort of R object
that might be used in running a model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>env_eval(x, seed = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="env_eval_+3A_x">x</code></td>
<td>
<p>a model object.</p>
</td></tr>
<tr><td><code id="env_eval_+3A_seed">seed</code></td>
<td>
<p>passed to <code><a href="base.html#topic+set.seed">set.seed()</a></code> if a numeric value is supplied.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+env_get">env_get()</a></code>, <code><a href="#topic+env_ls">env_ls()</a></code>
</p>

<hr>
<h2 id='env_get'>Return model environment</h2><span id='topic+env_get'></span><span id='topic+env_get_env'></span>

<h3>Description</h3>

<p>Return model environment
</p>


<h3>Usage</h3>

<pre><code class='language-R'>env_get(x, tolist = TRUE)

env_get_env(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="env_get_+3A_x">x</code></td>
<td>
<p>a model object.</p>
</td></tr>
<tr><td><code id="env_get_+3A_tolist">tolist</code></td>
<td>
<p>should the environment be coerced to <code>list</code>?</p>
</td></tr>
</table>

<hr>
<h2 id='env_ls'>List objects in the model environment</h2><span id='topic+env_ls'></span>

<h3>Description</h3>

<p>Each model keeps an internal environment that allows the user
to carry any <code>R</code> object along.  Objects are coded in <code style="white-space: pre;">&#8288;$ENV&#8288;</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>env_ls(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="env_ls_+3A_x">x</code></td>
<td>
<p>a model object.</p>
</td></tr>
<tr><td><code id="env_ls_+3A_...">...</code></td>
<td>
<p>passed to <code><a href="base.html#topic+ls">ls()</a></code>.</p>
</td></tr>
</table>

<hr>
<h2 id='env_update'>Update objects in model environment</h2><span id='topic+env_update'></span>

<h3>Description</h3>

<p>Update objects in model environment
</p>


<h3>Usage</h3>

<pre><code class='language-R'>env_update(.x, ..., .dots = list())
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="env_update_+3A_.x">.x</code></td>
<td>
<p>a model object.</p>
</td></tr>
<tr><td><code id="env_update_+3A_...">...</code></td>
<td>
<p>objects to update.</p>
</td></tr>
<tr><td><code id="env_update_+3A_.dots">.dots</code></td>
<td>
<p>list of objects to updated.</p>
</td></tr>
</table>

<hr>
<h2 id='ev'>Event objects for simulating PK and other interventions</h2><span id='topic+ev'></span><span id='topic+ev+2Cmrgmod-method'></span><span id='topic+ev+2Cmissing-method'></span><span id='topic+ev+2Cev-method'></span>

<h3>Description</h3>

<p>An event object specifies dosing or other interventions that get implemented
during simulation. Event objects do similar things as <a href="#topic+data_set">data_set</a>,
but simpler and easier to create.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ev(x, ...)

## S4 method for signature 'mrgmod'
ev(x, object = NULL, ...)

## S4 method for signature 'missing'
ev(
  time = 0,
  amt = 0,
  evid = 1,
  cmt = 1,
  ID = numeric(0),
  replicate = TRUE,
  until = NULL,
  tinf = NULL,
  realize_addl = FALSE,
  ...
)

## S4 method for signature 'ev'
ev(x, realize_addl = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ev_+3A_x">x</code></td>
<td>
<p>a model object.</p>
</td></tr>
<tr><td><code id="ev_+3A_...">...</code></td>
<td>
<p>other items to be incorporated into the event object; see
<strong>Details</strong>.</p>
</td></tr>
<tr><td><code id="ev_+3A_object">object</code></td>
<td>
<p>an event object to be added to a model object.</p>
</td></tr>
<tr><td><code id="ev_+3A_time">time</code></td>
<td>
<p>event time.</p>
</td></tr>
<tr><td><code id="ev_+3A_amt">amt</code></td>
<td>
<p>dose amount.</p>
</td></tr>
<tr><td><code id="ev_+3A_evid">evid</code></td>
<td>
<p>event ID.</p>
</td></tr>
<tr><td><code id="ev_+3A_cmt">cmt</code></td>
<td>
<p>compartment number or name.</p>
</td></tr>
<tr><td><code id="ev_+3A_id">ID</code></td>
<td>
<p>subject ID.</p>
</td></tr>
<tr><td><code id="ev_+3A_replicate">replicate</code></td>
<td>
<p>logical; if <code>TRUE</code>, events will be replicated for
each individual in <code>ID</code>.</p>
</td></tr>
<tr><td><code id="ev_+3A_until">until</code></td>
<td>
<p>the expected maximum <strong>observation</strong> time for this regimen;
doses will be scheduled up to, but not including, the <code>until</code> time;
see <strong>Examples</strong>.</p>
</td></tr>
<tr><td><code id="ev_+3A_tinf">tinf</code></td>
<td>
<p>infusion time; if greater than zero, then the <code>rate</code> item
will be derived as <code>amt/tinf</code>.</p>
</td></tr>
<tr><td><code id="ev_+3A_realize_addl">realize_addl</code></td>
<td>
<p>if <code>FALSE</code> (default), no change to <code>addl</code>
doses.  If <code>TRUE</code>, <code>addl</code> doses are made explicit with <code><a href="#topic+realize_addl">realize_addl()</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>


<ul>
<li><p> Required items in events objects include
<code>time</code>, <code>amt</code>, <code>evid</code> and <code>cmt</code>.
</p>
</li>
<li><p> If not supplied, <code>evid</code> is assumed to be 1.
</p>
</li>
<li><p> If not supplied, <code>cmt</code>  is assumed to be 1.
</p>
</li>
<li><p> If not supplied, <code>time</code> is assumed to be 0.
</p>
</li>
<li><p> If <code>amt</code> is not supplied, an error will be generated.
</p>
</li>
<li><p> If <code>total</code> is supplied, then <code>addl</code> will be set to <code>total-1</code>.
</p>
</li>
<li><p> Other items can include <code>ii</code>, <code>ss</code>, and <code>addl</code>
(see <a href="#topic+data_set">data_set</a> for details on all of these items).
</p>
</li>
<li> <p><code>ID</code> may be specified as a vector.
</p>
</li>
<li><p> If replicate is <code>TRUE</code> (default), then the events
regimen is replicated for each <code>ID</code>; otherwise, the number of
event rows must match the number of <code>ID</code>s entered.
</p>
</li></ul>



<h3>Value</h3>

<p><code>ev()</code> returns an event object.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+evd">evd()</a></code>, <code><a href="#topic+ev_rep">ev_rep()</a></code>, <code><a href="#topic+ev_days">ev_days()</a></code>, <code><a href="#topic+ev_repeat">ev_repeat()</a></code>, <code><a href="#topic+ev_assign">ev_assign()</a></code>,
<code><a href="#topic+ev_seq">ev_seq()</a></code>, <code><a href="#topic+mutate.ev">mutate.ev()</a></code>, <code><a href="#topic+as.ev">as.ev()</a></code>, <code><a href="#topic+as.evd">as.evd()</a></code>, <a href="#topic+ev_methods">ev_methods</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>mod &lt;- mrgsolve::house()

mod &lt;- mod %&gt;% ev(amt = 1000, time = 0, cmt = 1)

loading &lt;- ev(time = 0, cmt = 1, amt = 1000)

maint &lt;- ev(time = 12, cmt = 1, amt = 500, ii = 12, addl = 10)

c(loading, maint)

reduced_load &lt;- dplyr::mutate(loading, amt = 750)

# Three additional doses in this case
e &lt;- ev(amt = 100, ii = 4*7, until = 16*7)
e
# Last dose is given at 84
realize_addl(e)

# Four additional doses with last at 112 in this case
e &lt;- ev(amt = 100, ii = 4*7, until = 16*7 + 0.001)
realize_addl(e)

</code></pre>

<hr>
<h2 id='ev_assign'>Replicate a list of events into a data set</h2><span id='topic+ev_assign'></span><span id='topic+assign_ev'></span>

<h3>Description</h3>

<p>Replicate a list of events into a data set
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ev_assign(l, idata, evgroup, join = FALSE)

assign_ev(...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ev_assign_+3A_l">l</code></td>
<td>
<p>list of event objects.</p>
</td></tr>
<tr><td><code id="ev_assign_+3A_idata">idata</code></td>
<td>
<p>an idata set (one ID per row).</p>
</td></tr>
<tr><td><code id="ev_assign_+3A_evgroup">evgroup</code></td>
<td>
<p>the character name of the column in <code>idata</code> that specifies
event object to implement.</p>
</td></tr>
<tr><td><code id="ev_assign_+3A_join">join</code></td>
<td>
<p>if <code>TRUE</code>, join <code>idata</code> to the data set before returning.</p>
</td></tr>
<tr><td><code id="ev_assign_+3A_...">...</code></td>
<td>
<p>used to pass arguments from <code>assign_ev()</code>.
to <code>ev_assign()</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>ev_assign()</code> connects events in a list passed in as the <code>l</code> argument to
values in the data set identified in the <code>evgroup</code> argument.  For making
assignments, the unique values in the <code>evgroup</code> column are first sorted so
that the first sorted unique value in <code>evgroup</code> is assigned to the first
event in <code>l</code>, the second sorted value in <code>evgroup</code> column is assigned to the
second event in <code>l</code>, and so on.  This is a change from previous behavior,
which did not sort the unique values in <code>evgroup</code> prior to making the
assignments.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>ev1 &lt;- ev(amt = 100)
ev2 &lt;- ev(amt = 300, rate = 100, ii = 12, addl = 10)

idata &lt;- data.frame(ID = seq(10)) 
idata$arm &lt;- 1+(idata$ID %%2)

ev_assign(list(ev1, ev2), idata, "arm", join = TRUE)

</code></pre>

<hr>
<h2 id='ev_days'>Schedule dosing events on days of the week</h2><span id='topic+ev_days'></span>

<h3>Description</h3>

<p>This function lets you schedule doses on specific
days of the week, allowing you to create dosing
regimens on Monday/Wednesday/Friday, or Tuesday/Thursday,
or every other day (however you want to define that) etc.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ev_days(
  ev = NULL,
  days = "",
  addl = 0,
  ii = 168,
  unit = c("hours", "days"),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ev_days_+3A_ev">ev</code></td>
<td>
<p>an event object.</p>
</td></tr>
<tr><td><code id="ev_days_+3A_days">days</code></td>
<td>
<p>comma- or space-separated character string of valid days of the
the week (see details).</p>
</td></tr>
<tr><td><code id="ev_days_+3A_addl">addl</code></td>
<td>
<p>additional doses to administer.</p>
</td></tr>
<tr><td><code id="ev_days_+3A_ii">ii</code></td>
<td>
<p>inter-dose interval; intended use is to keep this at the
default value.</p>
</td></tr>
<tr><td><code id="ev_days_+3A_unit">unit</code></td>
<td>
<p>time unit; the function can only currently handle hours or days.</p>
</td></tr>
<tr><td><code id="ev_days_+3A_...">...</code></td>
<td>
<p>event objects named by one of the valid days of the week
(see <strong>Details</strong>).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Valid names of the week are:
</p>

<ul>
<li> <p><code>m</code> for Monday
</p>
</li>
<li> <p><code>t</code> for Tuesday
</p>
</li>
<li> <p><code>w</code> for Wednesday
</p>
</li>
<li> <p><code>th</code> for Thursday
</p>
</li>
<li> <p><code>f</code> for Friday
</p>
</li>
<li> <p><code>sa</code> for Saturday
</p>
</li>
<li> <p><code>s</code> for Sunday
</p>
</li></ul>

<p>The whole purpose of this function is to schedule doses on specific
days of the week, in a repeating weekly schedule.  Please do use caution
when changing <code>ii</code> from its default value.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Monday, Wednesday, Friday x 4 weeks
e1 &lt;- ev(amt = 100)
ev_days(e1, days="m,w,f", addl = 3)

# 50 mg Tuesdays, 100 mg Thursdays x 6 months
e2 &lt;- ev(amt = 50)
ev_days(t = e2, th = e1, addl = 23)

</code></pre>

<hr>
<h2 id='ev_methods'>Various methods for event objects</h2><span id='topic+ev_methods'></span><span id='topic+names.ev'></span><span id='topic+dim.ev'></span><span id='topic+as.matrix.ev'></span><span id='topic+as.data.frame.ev'></span><span id='topic+show+2Cev-method'></span>

<h3>Description</h3>

<p>Various methods for event objects
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'ev'
names(x)

## S3 method for class 'ev'
dim(x)

## S3 method for class 'ev'
as.matrix(x, ...)

## S3 method for class 'ev'
as.data.frame(x, row.names = NULL, optional = FALSE, add_ID = NULL, ...)

## S4 method for signature 'ev'
show(object)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ev_methods_+3A_x">x</code></td>
<td>
<p>an events object</p>
</td></tr>
<tr><td><code id="ev_methods_+3A_...">...</code></td>
<td>
<p>passed to various methods</p>
</td></tr>
<tr><td><code id="ev_methods_+3A_row.names">row.names</code></td>
<td>
<p>passed to <code><a href="base.html#topic+as.data.frame">as.data.frame</a></code></p>
</td></tr>
<tr><td><code id="ev_methods_+3A_optional">optional</code></td>
<td>
<p>passed to <code><a href="base.html#topic+as.data.frame">as.data.frame</a></code></p>
</td></tr>
<tr><td><code id="ev_methods_+3A_add_id">add_ID</code></td>
<td>
<p>numeric ID of length 1 used to add <code>ID</code> column only if 
one doesn't already exist</p>
</td></tr>
<tr><td><code id="ev_methods_+3A_object">object</code></td>
<td>
<p>used for <code>show</code></p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>
e &lt;- ev(amt = 100)

names(e)

as.data.frame(e)

dim(e)

nrow(e)

</code></pre>

<hr>
<h2 id='ev_ops'>Operations for ev objects</h2><span id='topic+ev_ops'></span><span id='topic++2B+2Cev+2Cev-method'></span><span id='topic++25then+25'></span><span id='topic++25then+25+2Cev+2Cev-method'></span><span id='topic++2B+2Cev+2Cnumeric-method'></span><span id='topic+c+2Cev-method'></span>

<h3>Description</h3>

<p>Operations for ev objects
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'ev,ev'
e1 + e2

e1 %then% e2

## S4 method for signature 'ev,ev'
e1 %then% e2

## S4 method for signature 'ev,numeric'
e1 + e2

## S4 method for signature 'ev'
c(x, ..., recursive = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ev_ops_+3A_e1">e1</code></td>
<td>
<p>object on left hand side of operator (lhs)</p>
</td></tr>
<tr><td><code id="ev_ops_+3A_e2">e2</code></td>
<td>
<p>object on right hand side of operator (rhs)</p>
</td></tr>
<tr><td><code id="ev_ops_+3A_x">x</code></td>
<td>
<p>an ev object</p>
</td></tr>
<tr><td><code id="ev_ops_+3A_...">...</code></td>
<td>
<p>other ev objects to collect</p>
</td></tr>
<tr><td><code id="ev_ops_+3A_recursive">recursive</code></td>
<td>
<p>not used</p>
</td></tr>
</table>


<h3>Details</h3>

<p>All operations involving <code><a href="#topic+mrgmod-class">mrgmod</a></code> 
objects have been deprecated.
</p>

<hr>
<h2 id='ev_rep'>Replicate an event object</h2><span id='topic+ev_rep'></span>

<h3>Description</h3>

<p>An event sequence can be replicated a certain number of
times in a certain number of IDs.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ev_rep(x, ID = 1, n = NULL, wait = 0, as.ev = FALSE, id = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ev_rep_+3A_x">x</code></td>
<td>
<p>event object.</p>
</td></tr>
<tr><td><code id="ev_rep_+3A_id">ID</code></td>
<td>
<p>numeric vector if IDs.</p>
</td></tr>
<tr><td><code id="ev_rep_+3A_n">n</code></td>
<td>
<p>passed to <code><a href="#topic+ev_repeat">ev_repeat()</a></code>.</p>
</td></tr>
<tr><td><code id="ev_rep_+3A_wait">wait</code></td>
<td>
<p>passed to <code><a href="#topic+ev_repeat">ev_repeat()</a></code>.</p>
</td></tr>
<tr><td><code id="ev_rep_+3A_as.ev">as.ev</code></td>
<td>
<p>if <code>TRUE</code> an event object is returned.</p>
</td></tr>
<tr><td><code id="ev_rep_+3A_id">id</code></td>
<td>
<p>deprecated; use <code>ID</code> instead.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A single data.frame or event object as
determined by the value of <code><a href="#topic+as.ev">as.ev()</a></code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+ev_repeat">ev_repeat()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
e1 &lt;- c(ev(amt=100), ev(amt=200, ii=24, addl=2, time=72))

ev_rep(e1, 1:5)

</code></pre>

<hr>
<h2 id='ev_repeat'>Repeat a block of dosing events</h2><span id='topic+ev_repeat'></span>

<h3>Description</h3>

<p>Repeat a block of dosing events
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ev_repeat(x, n, wait = 0, as.ev = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ev_repeat_+3A_x">x</code></td>
<td>
<p>event object or dosing data frame.</p>
</td></tr>
<tr><td><code id="ev_repeat_+3A_n">n</code></td>
<td>
<p>number of times to repeat.</p>
</td></tr>
<tr><td><code id="ev_repeat_+3A_wait">wait</code></td>
<td>
<p>time to wait between repeats.</p>
</td></tr>
<tr><td><code id="ev_repeat_+3A_as.ev">as.ev</code></td>
<td>
<p>if <code>TRUE</code>, an event object is returned; otherwise a data.frame
is returned.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>See <code>as.ev</code> argument.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>e1 &lt;- ev(amt = 100, ii = 24, addl = 20)
e4 &lt;- ev_repeat(e1, n = 4, wait = 168)
mod &lt;- mrgsolve::house()
out &lt;- mrgsim(mod, events = e4, end = 3200)
plot(out, "CP")

</code></pre>

<hr>
<h2 id='ev_rx'>Create intervention objects from Rx input</h2><span id='topic+ev_rx'></span><span id='topic+ev_rx+2Cmrgmod+2Ccharacter-method'></span><span id='topic+ev_rx+2Ccharacter+2Cmissing-method'></span><span id='topic+parse_rx'></span>

<h3>Description</h3>

<p>See details below for Rx specification. Actual parsing is done
by <code><a href="#topic+parse_rx">parse_rx()</a></code>; this function can be used to debug Rx inputs.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ev_rx(x, y, ...)

## S4 method for signature 'mrgmod,character'
ev_rx(x, y, ...)

## S4 method for signature 'character,missing'
ev_rx(x, df = FALSE, ...)

parse_rx(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ev_rx_+3A_x">x</code></td>
<td>
<p>a model object or <code>character</code> Rx input.</p>
</td></tr>
<tr><td><code id="ev_rx_+3A_y">y</code></td>
<td>
<p><code>character</code> Rx input; see details.</p>
</td></tr>
<tr><td><code id="ev_rx_+3A_...">...</code></td>
<td>
<p>not used at this time.</p>
</td></tr>
<tr><td><code id="ev_rx_+3A_df">df</code></td>
<td>
<p>if <code>TRUE</code> then a data frame is returned.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The method dispatched on model object (<code>mrgmod</code>) returns another
model object.  The <code>character</code> method returns an event object.  The
<code>parse_rx</code> function return a list named with arguments for the event
object constructor <code><a href="#topic+ev">ev()</a></code>.
</p>


<h3>Rx specification</h3>


<ul>
<li><p> The dose is found at the start of the string by sequential digits; this
may be integer, decimal, or specified in scientific notation
</p>
</li>
<li><p> Use <code style="white-space: pre;">&#8288;in&#8288;</code> to identify the dosing compartment number; must be integer
</p>
</li>
<li><p> Use <code>q</code> to identify the dosing interval; must be integer or
decimal number (but not scientific notation)
</p>
</li>
<li><p> Use <code>over</code> to indicate an infusion and its duration; integer or
decimal number
</p>
</li>
<li><p> Use <code>x</code> to indicate total number of doses; must be integer
</p>
</li>
<li><p> Use <code>then</code> or <code style="white-space: pre;">&#8288;,&#8288;</code> to separate dosing periods
</p>
</li>
<li><p> Use <code>after</code> to insert a lag in the start of a period; integer or
decimal number (but not scientific notation)
</p>
</li>
<li><p> Use <code>&amp;</code> to implement multiple doses at the same time
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'># example("ev_rx")

ev_rx("100")

ev_rx("100 in 2")

ev_rx("100 q12 x 3")

ev_rx("100 over 2")

ev_rx("100 q 24 x 3 then 50 q12 x 2")

ev_rx("100 then 50 q 24 after 12")

ev_rx("100.2E-2 q4")

ev_rx("100 over 2.23")

ev_rx("100 q 12 x 3")

ev_rx("100 in 1 &amp; 200 in 2") 

parse_rx("100 mg q 24 then 200 mg q12")

</code></pre>

<hr>
<h2 id='ev_seq'>Schedule a series of event objects</h2><span id='topic+ev_seq'></span><span id='topic+seq.ev'></span>

<h3>Description</h3>

<p>Use this function when you want to schedule two or more event objects in time
according the dosing interval (<code>ii</code>) and additional doses (<code>addl</code>).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ev_seq(..., ID = NULL, .dots = NULL, id = NULL)

## S3 method for class 'ev'
seq(...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ev_seq_+3A_...">...</code></td>
<td>
<p>event objects or numeric arguments named <code>wait</code> or <code>ii</code> to
implement a period of no-dosing activity in the sequence (see <strong>Details</strong>).</p>
</td></tr>
<tr><td><code id="ev_seq_+3A_id">ID</code></td>
<td>
<p>numeric vector of subject IDs.</p>
</td></tr>
<tr><td><code id="ev_seq_+3A_.dots">.dots</code></td>
<td>
<p>a list of event objects that replaces <code>...</code>.</p>
</td></tr>
<tr><td><code id="ev_seq_+3A_id">id</code></td>
<td>
<p>deprecated; use <code>ID</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Use the generic <code><a href="base.html#topic+seq">seq()</a></code> when the first argument is an event object.  If a
waiting period (<code>wait</code> or <code>ii</code>) is the first event, you will need to use
<code><a href="#topic+ev_seq">ev_seq()</a></code>.  When an event object has multiple rows, the end time for that
sequence is taken to be one dosing interval after the event that takes place
on the last row of the event object.
</p>
<p>The doses for the next event line start after all of the doses from the
previous event line plus one dosing interval from the previous event line
(see <strong>Examples</strong>).
</p>
<p>When numerics named <code>wait</code> or <code>ii</code> are mixed in with the event objects,
a period with no dosing activity is incorporated into the sequence,
between the adjacent dosing event objects. <code>wait</code> and <code>ii</code> accomplish a
similar result, but differ by the starting point for the inactive period.
</p>

<ul>
<li><p> Use <code>wait</code> to schedule the next dose relative to the end of the dosing
interval for the previous dose.
</p>
</li>
<li><p> Use <code>ii</code> to schedule the next dose relative to the time of the the previous
dose.
</p>
</li></ul>

<p>So <code>wait</code> acts like similar to an event object, by starting the waiting
period from one dosing interval after the last dose while <code>ii</code> starts the
waiting period from the time of the last dose itself. Both <code>wait</code> and <code>ii</code>
can accomplish identical behavior depending on whether the last dosing
interval is included (or not) in the value. Values for <code>wait</code> or <code>ii</code> can
be negative.
</p>
<p><strong>NOTE</strong>: <code>.ii</code> had been available historically as an undocumented feature.
Starting with mrgsolve version <code style="white-space: pre;">&#8288;0.11.3&#8288;</code>, the argument will be called <code>ii</code>.
For now, both <code>ii</code> and <code>.ii</code> will be accepted but you will get a deprecation
warning if you use <code>.ii</code>. Please use <code>ii</code> instead.
</p>
<p>Values for <code>time</code> in any event object act like a prefix time spacer wherever
that event occurs in the event sequence (see <strong>Examples</strong>).
</p>


<h3>Value</h3>

<p>A single event object sorted by <code>time</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>e1 &lt;- ev(amt = 100, ii = 12, addl = 1)

e2 &lt;- ev(amt = 200)

seq(e1, e2)

seq(e1, ii = 8, e2)

seq(e1, wait = 8, e2)

seq(e1, ii = 8, e2, ID = seq(10))

ev_seq(ii = 12, e1, ii = 120, e2, ii = 120, e1)

seq(ev(amt = 100, ii = 12), ev(time = 8, amt = 200))


</code></pre>

<hr>
<h2 id='ev-class'>S4 events class</h2><span id='topic+ev-class'></span>

<h3>Description</h3>

<p>S4 events class
</p>


<h3>Slots</h3>


<dl>
<dt><code>data</code></dt><dd><p>a data frame of events</p>
</dd>
<dt><code>case</code></dt><dd><p>indicates how to handle column naming upon coerce to data.frame</p>
</dd>
</dl>

<hr>
<h2 id='evd'>Create an event object with data-like names</h2><span id='topic+evd'></span><span id='topic+evd+2Cmrgmod-method'></span><span id='topic+evd+2Cmissing-method'></span><span id='topic+evd+2Cev-method'></span><span id='topic+as.evd'></span>

<h3>Description</h3>

<p>This function calls <code><a href="#topic+ev">ev()</a></code> to create an event object and then sets the
case attribute so that it renders nmtran data names in upper case. An
object created with <code><a href="#topic+evd">evd()</a></code> can be used in the same way as an object
created with <code><a href="#topic+ev">ev()</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>evd(x, ...)

## S4 method for signature 'mrgmod'
evd(x, ...)

## S4 method for signature 'missing'
evd(x, ...)

## S4 method for signature 'ev'
evd(x, ...)

as.evd(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="evd_+3A_x">x</code></td>
<td>
<p>an event object.</p>
</td></tr>
<tr><td><code id="evd_+3A_...">...</code></td>
<td>
<p>arguments passed to <code><a href="#topic+ev">ev()</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Note that <code>evd</code> isn't a separate class; it is just an <code>ev</code> object with
a specific <code>case</code> attribute. See examples which illustrate the difference.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+ev">ev()</a></code>, <code><a href="#topic+lctran">lctran()</a></code>, <code><a href="#topic+uctran">uctran()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>a &lt;- evd(amt = 100)
b &lt;- ev(amt = 300)
a
as.data.frame(a)
as_data_set(a, b)
as_data_set(b, a)
as.data.frame(seq(a, b))

</code></pre>

<hr>
<h2 id='exdatasets'>Example input data sets</h2><span id='topic+exdatasets'></span><span id='topic+exidata'></span><span id='topic+extran1'></span><span id='topic+extran2'></span><span id='topic+extran3'></span><span id='topic+exTheoph'></span><span id='topic+exBoot'></span>

<h3>Description</h3>

<p>Example input data sets
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(exidata)

data(extran1)

data(extran2)

data(extran3)

data(exTheoph)

data(exBoot)
</code></pre>


<h3>Details</h3>


<ul>
<li> <p><code>exidata</code> holds individual-level parameters and other data items, one per row
</p>
</li>
<li> <p><code>extran1</code> is a &quot;condensed&quot; data set
</p>
</li>
<li> <p><code>extran2</code> is a full dataset
</p>
</li>
<li> <p><code>extran3</code> is a full dataset with parameters
</p>
</li>
<li> <p><code>exTheoph</code> is the theophylline data set, ready for input into <code>mrgsolve</code>
</p>
</li>
<li> <p><code>exBoot</code> a set of bootstrap parameter estimates
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>
mod &lt;- mrgsolve::house() %&gt;% update(end=240) %&gt;% Req(CP)

## Full data set
data(exTheoph)
out &lt;- mod %&gt;% data_set(exTheoph) %&gt;% mrgsim
out
plot(out)

## Condensed: mrgsolve fills in the observations
data(extran1)
out &lt;- mod %&gt;% data_set(extran1) %&gt;% mrgsim
out
plot(out)

## Add a parameter to the data set
stopifnot(require(dplyr))
data &lt;- extran1 %&gt;% distinct(ID) %&gt;% select(ID) %&gt;%
  mutate(CL=exp(log(1.5) + rnorm(nrow(.), 0,sqrt(0.1)))) %&gt;%
  left_join(extran1,.)
  
data

out &lt;- mod %&gt;% data_set(data) %&gt;% carry_out(CL) %&gt;%  mrgsim
out
plot(out)

## idata
data(exidata)
out &lt;- mod %&gt;% idata_set(exidata) %&gt;% ev(amt=100,ii=24,addl=10) %&gt;% mrgsim
plot(out, CP~time|ID)
</code></pre>

<hr>
<h2 id='expand_observations'>Insert observations into a data set</h2><span id='topic+expand_observations'></span>

<h3>Description</h3>

<p>Insert observations into a data set
</p>


<h3>Usage</h3>

<pre><code class='language-R'>expand_observations(data, times, unique = FALSE, obs_pos = -1L)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="expand_observations_+3A_data">data</code></td>
<td>
<p>a data set or event object.</p>
</td></tr>
<tr><td><code id="expand_observations_+3A_times">times</code></td>
<td>
<p>a vector of observation times.</p>
</td></tr>
<tr><td><code id="expand_observations_+3A_unique">unique</code></td>
<td>
<p><code>logical</code>; if <code>TRUE</code> then values for <code>time</code> are
dropped if they are found anywhere in <code>data</code>.</p>
</td></tr>
<tr><td><code id="expand_observations_+3A_obs_pos">obs_pos</code></td>
<td>
<p>determines sorting order for observations; use <code>-1</code> (default)
to put observations first; otherwise, use large integer to ensure
observations are placed after doses.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Non-numeric columns will be dropped with a warning.
</p>


<h3>Value</h3>

<p>A data frame with additional rows for added observation records.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data &lt;- expand.ev(amt = c(100, 200, 300))

expand_observations(data, times = seq(0, 48, 2))

</code></pre>

<hr>
<h2 id='expand.idata'>Create template data sets for simulation</h2><span id='topic+expand.idata'></span><span id='topic+expand.ev'></span><span id='topic+expand.evd'></span><span id='topic+ev_expand'></span><span id='topic+evd_expand'></span>

<h3>Description</h3>

<p>These functions expand all combinations of arguments using
<code><a href="base.html#topic+expand.grid">expand.grid()</a></code>. <code>expand.idata()</code> generates an <code>idata</code> set; the others
generate a full data set. The result always has only one row for one
individual. Use <code>expand.evd()</code> or <code>evd_expand()</code> to render NMTRAN names
(e.g. <code>AMT</code> or <code>CMT</code>) in upper case.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>expand.idata(...)

expand.ev(...)

expand.evd(...)

ev_expand(...)

evd_expand(...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="expand.idata_+3A_...">...</code></td>
<td>
<p>passed to <code><a href="base.html#topic+expand.grid">expand.grid()</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>An ID column is added as if not supplied by the user. In the output data
frame, ID is always re-written as the row number.
</p>
<p>For <code>expand.ev()</code>, defaults also added include <code>cmt = 1</code>, <code>time = 0</code>,
<code>evid = 1</code>. If <code>total</code> is included, then <code>addl</code> is derived as <code>total-1</code>.
If <code>tinf</code> is included, then an infusion rate is derived for row where
<code>tinf</code> is greater than zero.
</p>
<p><code>ev_expand()</code> is a synonym for <code>expand.ev()</code> and <code>evd_expand()</code> is a
synonym for <code>expand.evd()</code>.
</p>


<h3>Value</h3>

<p>A data frame containing one row for each combination of the items
passed in <code>...</code>. The result always has ID set to the row number.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>idata &lt;- expand.idata(CL = c(1,2,3), VC = c(10,20,30))

doses &lt;- expand.ev(amt = c(300,100), ii = c(12,24), cmt = 1)

infusion &lt;- expand.ev(amt = 100, tinf = 2)

</code></pre>

<hr>
<h2 id='file_show'>Show model specification and C++ files</h2><span id='topic+file_show'></span>

<h3>Description</h3>

<p>Show model specification and C++ files
</p>


<h3>Usage</h3>

<pre><code class='language-R'>file_show(x, spec = TRUE, source = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="file_show_+3A_x">x</code></td>
<td>
<p>model object</p>
</td></tr>
<tr><td><code id="file_show_+3A_spec">spec</code></td>
<td>
<p>logical; show the model specification file</p>
</td></tr>
<tr><td><code id="file_show_+3A_source">source</code></td>
<td>
<p>logical; show the C++ file that is actually compiled</p>
</td></tr>
<tr><td><code id="file_show_+3A_...">...</code></td>
<td>
<p>not used</p>
</td></tr>
</table>

<hr>
<h2 id='house'>Return a pre-compiled, PK/PD model</h2><span id='topic+house'></span>

<h3>Description</h3>

<p>This model is used in a lot of package tests, but it can be useful to
support user experimentation as well.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>house(...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="house_+3A_...">...</code></td>
<td>
<p>passed to <code><a href="#topic+update">update()</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>packmod</code> object, ready to simulate.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
mod &lt;- mrgsolve::house()

see(mod)

mod %&gt;% ev(amt = 100) %&gt;% mrgsim() %&gt;% plot()

</code></pre>

<hr>
<h2 id='idata_set'>Select and modify a idata set for simulation</h2><span id='topic+idata_set'></span><span id='topic+idata_set+2Cmrgmod+2Cdata.frame-method'></span><span id='topic+idata_set+2Cmrgmod+2CANY-method'></span><span id='topic+idata_set+2Cmrgmod+2Cmissing-method'></span>

<h3>Description</h3>

<p>The individual data set (<code>idata_set</code>) is a data frame with one
row for each individual in a population, specifying parameters and
other individual-level data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>idata_set(x, data, ...)

## S4 method for signature 'mrgmod,data.frame'
idata_set(
  x,
  data,
  .subset = TRUE,
  .select = TRUE,
  object = NULL,
  need = NULL,
  ...
)

## S4 method for signature 'mrgmod,ANY'
idata_set(x, data, ...)

## S4 method for signature 'mrgmod,missing'
idata_set(x, object, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="idata_set_+3A_x">x</code></td>
<td>
<p>model object.</p>
</td></tr>
<tr><td><code id="idata_set_+3A_data">data</code></td>
<td>
<p>a data set that can be coerced to data.frame.</p>
</td></tr>
<tr><td><code id="idata_set_+3A_...">...</code></td>
<td>
<p>other arguments passed along when <code>object</code> is a function.</p>
</td></tr>
<tr><td><code id="idata_set_+3A_.subset">.subset</code></td>
<td>
<p>an unquoted expression passed to <code><a href="dplyr.html#topic+filter">dplyr::filter()</a></code>; retain
only certain rows in the data set.</p>
</td></tr>
<tr><td><code id="idata_set_+3A_.select">.select</code></td>
<td>
<p>passed to <code><a href="dplyr.html#topic+select">dplyr::select()</a></code>; retain only certain columns in
the data set; this should be the result of a call to <code><a href="dplyr.html#topic+vars">dplyr::vars()</a></code>.</p>
</td></tr>
<tr><td><code id="idata_set_+3A_object">object</code></td>
<td>
<p>character name of an object existing in <code style="white-space: pre;">&#8288;$ENV&#8288;</code>
to use for the data set.</p>
</td></tr>
<tr><td><code id="idata_set_+3A_need">need</code></td>
<td>
<p>passed to <code><a href="#topic+inventory">inventory()</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>idata_set</code> is a data frame that specifies individual-level
data for the problem. An <code>ID</code> column is required and there
can be no more than one row in the data frame for each individual.
</p>
<p>In most cases, the columns in the <code>idata_set</code> have the same names
as parameters in the <code><a href="#topic+param">param()</a></code> list.  When this is the case,
the parameter set is updated as the simulation proceeds once at the
start of each individual.  The <code>idata_set</code> can also be used to
set initial conditions for each individual: for a compartment called
<code>CMT</code>, make a column in <code>idata_set</code> called <code>CMT_0</code> and
make the value the desired initial value for that compartment.  Note that
this initial condition will be overridden if you also set the <code>CMT_0</code>
in <code style="white-space: pre;">&#8288;$MAIN&#8288;</code> (<code style="white-space: pre;">&#8288;$PK&#8288;</code>).
</p>
<p>The most common application of <code>idata_set</code> is to specify a population
or batch of simulations to do.  We commonly use <code>idata_set</code> with an
event object (see <code><a href="#topic+ev">ev()</a></code>).  In that case, the event gets applied
to each individual in the <code>idata_set</code>.
</p>
<p>It is also possible to provide both a <code>data_set</code> and a <code>idata_set</code>.
In this case, the <code>idata_set</code> is used as a parameter lookup for <code>IDs</code>
found in the <code>data_set</code>.  Remember in this case, it is the <code>data_set</code>
(not the <code>idata_set</code>) that determines the number of individuals in the
simulation.
</p>
<p>An error will be generated if any parameter columns in the
input idata set contain <code>NA</code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+data_set">data_set()</a></code>, <code><a href="#topic+ev">ev()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>mod &lt;- mrgsolve::house()

data(exidata)

exidata

mod %&gt;% 
  idata_set(exidata, ID &lt;= 2) %&gt;% 
  ev(amt = 100) %&gt;%
  mrgsim() %&gt;% 
  plot()

mod %&gt;% 
  idata_set(exidata) %&gt;% 
  ev(amt = 100) %&gt;%
  mrgsim()

mod %&gt;% ev(amt = 100) %&gt;% mrgsim(idata=exidata) 

</code></pre>

<hr>
<h2 id='init'>Methods for working with the model compartment list</h2><span id='topic+init'></span><span id='topic+init+2Cmrgmod-method'></span><span id='topic+init+2Cmrgsims-method'></span><span id='topic+init+2Cmissing-method'></span><span id='topic+init+2Clist-method'></span><span id='topic+init+2CANY-method'></span>

<h3>Description</h3>

<p>Calling <code>init()</code> with the model object as the first argument
will return the model initial conditions as a <a href="#topic+numericlist">numericlist</a>
object. See <a href="#topic+numericlist">numericlist</a> for methods to  deal with
<code>cmt_list</code> objects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>init(.x, ...)

## S4 method for signature 'mrgmod'
init(.x, .y = list(), ..., .pat = "*")

## S4 method for signature 'mrgsims'
init(.x, ...)

## S4 method for signature 'missing'
init(.x, ...)

## S4 method for signature 'list'
init(.x, ...)

## S4 method for signature 'ANY'
init(.x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="init_+3A_.x">.x</code></td>
<td>
<p>the model object.</p>
</td></tr>
<tr><td><code id="init_+3A_...">...</code></td>
<td>
<p><code>name = value</code> assignments to update the initial conditions list.</p>
</td></tr>
<tr><td><code id="init_+3A_.y">.y</code></td>
<td>
<p>list to be merged into parameter list.</p>
</td></tr>
<tr><td><code id="init_+3A_.pat">.pat</code></td>
<td>
<p>a regular expression (character) to be applied as
a filter when printing compartments to the screen.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Can be used to either get a compartment list object from a
<code>mrgmod</code> model object or to update the compartment initial
conditions in a model object.  For both uses, the return value
is a <code>cmt_list</code> object. For the former use, <code>init()</code>
is usually called to print the compartment initial conditions
to the screen, but the <code>cmt_list</code> object can also be coerced
to a list or numeric R object.
</p>


<h3>Value</h3>

<p>An object of class <code>cmt_list</code> (see <a href="#topic+numericlist">numericlist</a>).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## example("init")
mod &lt;- mrgsolve::house()

init(mod)

init(mod, .pat="^C") ## may be useful for large models

class(init(mod))

init(mod)$CENT

as.list(init(mod))

as.data.frame(init(mod))


</code></pre>

<hr>
<h2 id='inventory'>Check whether all required parameters needed in a model are present in an
object</h2><span id='topic+inventory'></span>

<h3>Description</h3>

<p>This function has largely been superseded by <code><a href="#topic+check_data_names">check_data_names()</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>inventory(x, obj, ..., .strict = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="inventory_+3A_x">x</code></td>
<td>
<p>model object.</p>
</td></tr>
<tr><td><code id="inventory_+3A_obj">obj</code></td>
<td>
<p>data.frame to pass to <code><a href="#topic+idata_set">idata_set()</a></code> or <code><a href="#topic+data_set">data_set()</a></code>.</p>
</td></tr>
<tr><td><code id="inventory_+3A_...">...</code></td>
<td>
<p>capture dplyr-style parameter requirements.</p>
</td></tr>
<tr><td><code id="inventory_+3A_.strict">.strict</code></td>
<td>
<p>whether to stop execution if all requirements are present
(<code>TRUE</code>) or just warn (<code>FALSE</code>); see <strong>Details</strong>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If parameter requirements are not explicitly stated, the requirement defaults to
all parameter names in <code>x</code>.  Note that, by default,
the inventory is not <code>.strict</code> unless the user explicitly
states the parameter requirement. That is, if parameter requirements are explicitly
stated, <code>.strict</code> will be set to <code>TRUE</code> if a value <code>.strict</code> was not
passed in the call.
</p>


<h3>Value</h3>

<p><code>x</code> is returned invisibly.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+check_data_names">check_data_names()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
  inventory(mod, idata, CL:V) # parameters defined, inclusively, CL through Volume 
  inventory(mod, idata, everything()) # all parameters
  inventory(mod, idata, contains("OCC")) # all parameters containing OCC
  inventory(mod, idata, -F) # all parameters except F

## End(Not run)

</code></pre>

<hr>
<h2 id='is.mrgmod'>Check if an object is a model object</h2><span id='topic+is.mrgmod'></span>

<h3>Description</h3>

<p>The function checks to see if the object is either
<code>mrgmod</code> or <code>packmod</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is.mrgmod(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="is.mrgmod_+3A_x">x</code></td>
<td>
<p>any object</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>TRUE</code> if the object inherits from either <code>mrgmod</code> or <code>packmod</code> class.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>mod &lt;- mrgsolve::house()
is.mrgmod(mod)

</code></pre>

<hr>
<h2 id='is.mrgsims'>Check if an object is mrgsims output</h2><span id='topic+is.mrgsims'></span>

<h3>Description</h3>

<p>Check if an object is mrgsims output
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is.mrgsims(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="is.mrgsims_+3A_x">x</code></td>
<td>
<p>any object.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>TRUE</code> if <code>x</code> inherits <code>mrgsims</code>.
</p>

<hr>
<h2 id='knobs'>Run sensitivity analysis on model settings</h2><span id='topic+knobs'></span><span id='topic+knobs+2Cmrgmod+2Cmissing-method'></span><span id='topic+knobs+2Cmrgmod+2Cbatch_mrgsims-method'></span><span id='topic+as.data.frame+2Cbatch_mrgsims-method'></span><span id='topic+knobs+2Cbatch_mrgsims+2CANY-method'></span><span id='topic+show+2Cbatch_mrgsims-method'></span>

<h3>Description</h3>

<p>Knobs can be parameter values or PK dosing items (e.g. amt).  
By design, all combinations of specified knob/values are simulated.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>knobs(x, y, ...)

## S4 method for signature 'mrgmod,missing'
knobs(x, y, ...)

## S4 method for signature 'mrgmod,batch_mrgsims'
knobs(x, y, ...)

## S4 method for signature 'batch_mrgsims'
as.data.frame(x, row.names = NULL, optional = FALSE, ...)

## S4 method for signature 'batch_mrgsims,ANY'
knobs(x, y, ...)

## S4 method for signature 'batch_mrgsims'
show(object)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="knobs_+3A_x">x</code></td>
<td>
<p>the model object</p>
</td></tr>
<tr><td><code id="knobs_+3A_y">y</code></td>
<td>
<p>a <code>batch_mrgsims</code> object</p>
</td></tr>
<tr><td><code id="knobs_+3A_...">...</code></td>
<td>
<p>knobs: named numeric vectors that identify knob names and knob 
values for a
batch run.  See details.</p>
</td></tr>
<tr><td><code id="knobs_+3A_row.names">row.names</code></td>
<td>
<p>passed to <code>as.data.frame.data.frame</code></p>
</td></tr>
<tr><td><code id="knobs_+3A_optional">optional</code></td>
<td>
<p>passed to <code>as.data.frame.data.frame</code></p>
</td></tr>
<tr><td><code id="knobs_+3A_object">object</code></td>
<td>
<p>the object to show</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Valid knob names include: any parameter name (in <code>param(mod)</code>), 
time variables (<code>start</code>, <code>end</code>, <code>delta</code>), PK dosing items 
(<code>amt</code>, <code>ii</code>, <code>rate</code>, and others ...), and solver settings 
(<code>atol</code>, <code>hmax</code>, etc...).
</p>


<h3>Value</h3>

<p>An object of class <code>batch_mrgsims</code>.  Most methods for 
<code>mrgsims</code> objects also work on <code>batch_mrgsims</code> object.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## example("knobs")

mod &lt;- mrgsolve::house(end=72)

events &lt;- ev(amt=1000, cmt=1, addl=3, ii=12)

out &lt;- mod %&gt;% ev(events) %&gt;% knobs(CL=c(1,2,3))
plot(out)

out

out &lt;- mod %&gt;% ev(events) %&gt;% knobs(CL=c(1,2,3), VC=c(5,20,50))
plot(out)
plot(out,CP~.)
plot(out, CP~time|VC, groups=CL, lty=2)

out &lt;- knobs(mod, amt=c(100,300,500), cmt=1)
plot(out)

out &lt;- mod %&gt;% knobs(amt=c(100,300), CL=c(1,3), VC=c(5,20), cmt=1)
plot(out)
plot(out, CP~.)

out &lt;- knobs(mod, CL=c(1,2,3))
out

out &lt;- knobs(mod, CL=c(1,2,3))
out
</code></pre>

<hr>
<h2 id='lctran'>Change the case of nmtran-like data items</h2><span id='topic+lctran'></span><span id='topic+lctran.data.frame'></span><span id='topic+lctran.ev'></span><span id='topic+uctran'></span><span id='topic+uctran.data.frame'></span><span id='topic+uctran.ev'></span>

<h3>Description</h3>

<p>Previous data set requirements included lower case names for data items
like <code>AMT</code> and <code>EVID</code>. Lower case is no longer required. However, it is still
a requirement that nmtran like data column names are either all lower case
or all upper case.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lctran(data, ...)

## S3 method for class 'data.frame'
lctran(data, warn = TRUE, ...)

## S3 method for class 'ev'
lctran(data, ...)

uctran(data, ...)

## S3 method for class 'data.frame'
uctran(data, warn = TRUE, ...)

## S3 method for class 'ev'
uctran(data, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="lctran_+3A_data">data</code></td>
<td>
<p>a data set with nmtran-like format or an event object.</p>
</td></tr>
<tr><td><code id="lctran_+3A_...">...</code></td>
<td>
<p>for potential future use.</p>
</td></tr>
<tr><td><code id="lctran_+3A_warn">warn</code></td>
<td>
<p>if <code>TRUE</code>, a warning will be issued when there are both upper
and lower case versions of any nmtran-like column in the data frame.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Columns that will be renamed with lower or upper case versions:
</p>

<ul>
<li> <p><code>AMT  / amt</code>
</p>
</li>
<li> <p><code>II   / ii</code>
</p>
</li>
<li> <p><code>SS   / ss</code>
</p>
</li>
<li> <p><code>CMT  / cmt</code>
</p>
</li>
<li> <p><code>ADDL / addl</code>
</p>
</li>
<li> <p><code>RATE / rate</code>
</p>
</li>
<li> <p><code>EVID / evid</code>
</p>
</li>
<li> <p><code>TIME / time</code>
</p>
</li></ul>

<p>If both lower and upper case versions of the name are present in the data
frame, no changes will be made.
</p>


<h3>Value</h3>

<p>A data frame or event object, with column names possibly converted to upper
or lower case.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data &lt;- data.frame(TIME = 0, AMT = 5, II = 24, addl = 2, WT = 80)
lctran(data)

data &lt;- data.frame(TIME = 0, AMT = 5, II = 24, addl = 2, wt = 80)
uctran(data)

ev &lt;- evd(amt = 100, evid = 3)
uctran(ev)

# warning
data &lt;- data.frame(TIME = 1, time = 2, CMT = 5)
lctran(data)

</code></pre>

<hr>
<h2 id='loadso'>Load the model shared object</h2><span id='topic+loadso'></span><span id='topic+loadso.mrgmod'></span>

<h3>Description</h3>

<p>Once the model is compiled, the model object can be used to re-load
the model shared object (the compiled code underlying the mode) when
the simulation is to be done in a different R process.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>loadso(x, ...)

## S3 method for class 'mrgmod'
loadso(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="loadso_+3A_x">x</code></td>
<td>
<p>a model object.</p>
</td></tr>
<tr><td><code id="loadso_+3A_...">...</code></td>
<td>
<p>not used.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>loadso</code> function most frequently needs to be used when parallelizing
simulations across worker nodes.  The model can be run after calling
<code>loadso</code>, without requiring that it is re-compiled on worker nodes. It is
likely required that the model is built (and the shared object stored) in
a local directory off of the working R directory (see the second example).
</p>


<h3>Value</h3>

<p>The model object (invisibly).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run:  
  mod &lt;- mread("pk1", modlib())
  loadso(mod)
  
  mod2 &lt;- mread("pk2", modlib(), soloc = "build")
  loadso(mod2)

## End(Not run)

</code></pre>

<hr>
<h2 id='lower2matrix'>Create a square numeric matrix from the lower-triangular elements</h2><span id='topic+lower2matrix'></span>

<h3>Description</h3>

<p>Create a square numeric matrix from the lower-triangular elements
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lower2matrix(x, context = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="lower2matrix_+3A_x">x</code></td>
<td>
<p>numeric data</p>
</td></tr>
<tr><td><code id="lower2matrix_+3A_context">context</code></td>
<td>
<p>the working context</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a square symmetric numeric matrix with column names
</p>

<hr>
<h2 id='matlist'>Methods for working with matrix-list objects</h2><span id='topic+matlist'></span><span id='topic+as.list+2Cmatlist-method'></span><span id='topic+as.matrix+2Cmatlist-method'></span><span id='topic+names.matlist'></span><span id='topic+length.matlist'></span><span id='topic+labels+2Cmatlist-method'></span><span id='topic+dim+2Cmatlist-method'></span><span id='topic+nrow+2Cmatlist-method'></span><span id='topic+show+2Cmatlist-method'></span>

<h3>Description</h3>

<p>Methods for working with matrix-list objects
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'matlist'
as.list(x, detailed = FALSE, ...)

## S4 method for signature 'matlist'
as.matrix(x, ...)

## S3 method for class 'matlist'
names(x)

## S3 method for class 'matlist'
length(x)

## S4 method for signature 'matlist'
labels(object, ...)

## S4 method for signature 'matlist'
dim(x)

## S4 method for signature 'matlist'
nrow(x)

## S4 method for signature 'matlist'
show(object)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="matlist_+3A_x">x</code></td>
<td>
<p>a matlist object.</p>
</td></tr>
<tr><td><code id="matlist_+3A_detailed">detailed</code></td>
<td>
<p>if <code>TRUE</code>, then a simple list of matrices is returned;
otherwise, then entire <code>matlist</code> object data is returned along with the
name of the <code>class</code> (e.g. either <code>omegalist</code> or <code>sigmalist</code>) as well
as the <code>names</code> of the matrices.</p>
</td></tr>
<tr><td><code id="matlist_+3A_...">...</code></td>
<td>
<p>passed through to other methods.</p>
</td></tr>
<tr><td><code id="matlist_+3A_object">object</code></td>
<td>
<p>passed to showmatlist</p>
</td></tr>
</table>

<hr>
<h2 id='matlist-class'>S4 class matlist</h2><span id='topic+matlist-class'></span><span id='topic+omegalist-class'></span><span id='topic+sigmalist-class'></span>

<h3>Description</h3>

<p>S4 class matlist
</p>

<hr>
<h2 id='matrix_helpers'>Create matrices from vector input</h2><span id='topic+matrix_helpers'></span><span id='topic+bmat'></span><span id='topic+cmat'></span><span id='topic+dmat'></span>

<h3>Description</h3>

<p>These functions are simple utilities for creating diagonal, block or
correlation matrices.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bmat(..., correlation = FALSE, digits = -1)

cmat(..., digits = -1)

dmat(...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="matrix_helpers_+3A_...">...</code></td>
<td>
<p>matrix data.</p>
</td></tr>
<tr><td><code id="matrix_helpers_+3A_correlation">correlation</code></td>
<td>
<p>logical; if <code>TRUE</code>, off-diagonal elements are assumed
to be correlations and converted to covariances.</p>
</td></tr>
<tr><td><code id="matrix_helpers_+3A_digits">digits</code></td>
<td>
<p>if greater than zero, matrix is passed to <code><a href="base.html#topic+signif">signif()</a></code> (along
with digits) prior to returning.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>bmat()</code> makes a block matrix. <code>cmat()</code> makes a correlation matrix.
<code>dmat()</code> makes a diagonal matrix.
</p>


<h3>Value</h3>

<p>A matrix.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+as_bmat">as_bmat()</a></code>, <code><a href="#topic+as_dmat">as_dmat()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
dmat(1,2,3)/10

bmat(0.5,0.01,0.2)

cmat(0.5, 0.87,0.2)

</code></pre>

<hr>
<h2 id='mcode'>Write, compile, and load model code</h2><span id='topic+mcode'></span><span id='topic+mcode_cache'></span>

<h3>Description</h3>

<p>This is a convenience function that ultimately calls <code><a href="#topic+mread">mread()</a></code>.
Model code is written to a file and read back in using <code><a href="#topic+mread">mread()</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mcode(model, code, project = getOption("mrgsolve.project", tempdir()), ...)

mcode_cache(
  model,
  code,
  project = getOption("mrgsolve.project", tempdir()),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="mcode_+3A_model">model</code></td>
<td>
<p>model name.</p>
</td></tr>
<tr><td><code id="mcode_+3A_code">code</code></td>
<td>
<p>character string specifying a <code>mrgsolve</code> model.</p>
</td></tr>
<tr><td><code id="mcode_+3A_project">project</code></td>
<td>
<p>project directory for the model.</p>
</td></tr>
<tr><td><code id="mcode_+3A_...">...</code></td>
<td>
<p>passed to <code><a href="#topic+mread">mread()</a></code>; see that help topic for other arguments
that can be set.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Note that the arguments are in slightly different order than
<code><a href="#topic+mread">mread()</a></code>.  The default <code>project</code> is <code><a href="base.html#topic+tempdir">tempdir()</a></code>.
</p>
<p>See the <code><a href="#topic+mread">mread()</a></code> help topic for discussion about caching
compilation results with <code><a href="#topic+mcode_cache">mcode_cache()</a></code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+mread">mread()</a></code>, <code><a href="#topic+mread_cache">mread_cache()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run:  
code &lt;- '
$CMT DEPOT CENT
$PKMODEL ncmt=1, depot=TRUE
$MAIN
double CL = 1;
double V = 20;
double KA = 1;
'

mod &lt;- mcode("example", code, compile = FALSE)

## End(Not run)

</code></pre>

<hr>
<h2 id='mcRNG'>Set RNG to use L'Ecuyer-CMRG</h2><span id='topic+mcRNG'></span>

<h3>Description</h3>

<p>Set RNG to use L'Ecuyer-CMRG
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mcRNG()
</code></pre>

<hr>
<h2 id='merge.list'>Merge two lists</h2><span id='topic+merge.list'></span>

<h3>Description</h3>

<p>Merge two lists
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'list'
merge(x, y, ..., open = FALSE, warn = TRUE, context = "object", wild = "...")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="merge.list_+3A_x">x</code></td>
<td>
<p>the original list</p>
</td></tr>
<tr><td><code id="merge.list_+3A_y">y</code></td>
<td>
<p>the new list for merging</p>
</td></tr>
<tr><td><code id="merge.list_+3A_...">...</code></td>
<td>
<p>not used</p>
</td></tr>
<tr><td><code id="merge.list_+3A_open">open</code></td>
<td>
<p>logical indicating whether or not new items should 
be allowed in the list upon merging</p>
</td></tr>
<tr><td><code id="merge.list_+3A_warn">warn</code></td>
<td>
<p>issue warning if nothing found to update</p>
</td></tr>
<tr><td><code id="merge.list_+3A_context">context</code></td>
<td>
<p>description of usage context</p>
</td></tr>
<tr><td><code id="merge.list_+3A_wild">wild</code></td>
<td>
<p>wild-card name; see details</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Wild-card names (<code>wild</code>) are always retained in <code>x</code> and
are brought along from <code>y</code> only when <code>open</code>.
</p>

<hr>
<h2 id='mod'>Return the model object</h2><span id='topic+mod'></span><span id='topic+mod+2Cmrgsims-method'></span>

<h3>Description</h3>

<p>Return the model object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mod(x, ...)

## S4 method for signature 'mrgsims'
mod(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="mod_+3A_x">x</code></td>
<td>
<p>mrgsims object</p>
</td></tr>
<tr><td><code id="mod_+3A_...">...</code></td>
<td>
<p>passed along</p>
</td></tr>
</table>

<hr>
<h2 id='modelparse'>Parse model specification text</h2><span id='topic+modelparse'></span><span id='topic+modelparse_rmd'></span>

<h3>Description</h3>

<p>Parse model specification text
</p>


<h3>Usage</h3>

<pre><code class='language-R'>modelparse(txt, split = FALSE, drop_blank = TRUE, comment_re = c("//", "##"))

modelparse_rmd(txt, split = FALSE, drop_blank = TRUE, comment_re = "//")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="modelparse_+3A_txt">txt</code></td>
<td>
<p>model specification text</p>
</td></tr>
<tr><td><code id="modelparse_+3A_split">split</code></td>
<td>
<p>logical</p>
</td></tr>
<tr><td><code id="modelparse_+3A_drop_blank">drop_blank</code></td>
<td>
<p>logical; <code>TRUE</code> if blank lines are to be dropped</p>
</td></tr>
<tr><td><code id="modelparse_+3A_comment_re">comment_re</code></td>
<td>
<p>regular expression for comments</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>file &lt;- file.path(modlib(), "pk1.cpp")

modelparse(readLines(file))

</code></pre>

<hr>
<h2 id='modlib'>Internal model library</h2><span id='topic+modlib'></span>

<h3>Description</h3>

<p>Pre-coded models are included in the mrgsolve installation; these can be
compiled and loaded with <code>modlib()</code>. These models are usually most useful
for exploratory simulation or learning mrgsolve. Production simulation work
is typically accomplished by a custom-coded model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>modlib(model = NULL, ..., list = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="modlib_+3A_model">model</code></td>
<td>
<p><code>character</code> name of a model in the library.</p>
</td></tr>
<tr><td><code id="modlib_+3A_...">...</code></td>
<td>
<p>passed to <code><a href="#topic+mread_cache">mread_cache()</a></code>.</p>
</td></tr>
<tr><td><code id="modlib_+3A_list">list</code></td>
<td>
<p>logical; if <code>TRUE</code>, a list of available models is returned.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>See <a href="#topic+modlib_details">modlib_details</a>, <a href="#topic+modlib_pk">modlib_pk</a>, <a href="#topic+modlib_pkpd">modlib_pkpd</a>, <a href="#topic+modlib_tmdd">modlib_tmdd</a>,
<a href="#topic+modlib_viral">modlib_viral</a> for details.
</p>
<p>Call <code>modlib("&lt;modelname&gt;")</code> to compile and load a mode from the
library.
</p>
<p>Call <code>modlib(list=TRUE)</code> to list available models.  Once the model
is loaded (see examples below), call <code>as.list(mod)$code</code> to extract
model code and equations.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
mod &lt;- mread("pk1cmt", modlib())
mod &lt;- mread("pk2cmt", modlib()) 
mod &lt;- mread("pk3cmt", modlib()) 
mod &lt;- mread("pk1",    modlib())
mod &lt;- mread("pk2",    modlib())
mod &lt;- mread("popex",  modlib())
mod &lt;- mread("irm1",   modlib()) 
mod &lt;- mread("irm2",   modlib()) 
mod &lt;- mread("irm3",   modlib()) 
mod &lt;- mread("irm4",   modlib())
mod &lt;- mread("emax",   modlib())
mod &lt;- mread("effect", modlib())
mod &lt;- mread("tmdd",   modlib())
mod &lt;- mread("viral1", modlib())
mod &lt;- mread("viral2", modlib())
mod &lt;- mread("pred1",  modlib())
mod &lt;- mread("pbpk",   modlib())
mod &lt;- mread("1005",   modlib())  # embedded NONMEM result
mod &lt;- mread("nm-like", modlib()) # model with nonmem-like syntax
mod &lt;- mread("evtools", modlib())

as.list(mod)$code

## End(Not run)
</code></pre>

<hr>
<h2 id='modlib_details'>modlib: PK/PD Model parameters, compartments, and output variables</h2><span id='topic+modlib_details'></span>

<h3>Description</h3>

<p>modlib: PK/PD Model parameters, compartments, and output variables
</p>


<h3>Compartments</h3>


<ul>
<li><p><code>EV1</code>, <code>EV2</code>: extravascular dosing compartments
</p>
</li>
<li><p><code>CENT</code>: central PK compartment
</p>
</li>
<li><p><code>PERIPH</code>: peripheral PK compartment
</p>
</li>
<li><p><code>PERIPH2</code>: peripheral PK compartment 2
</p>
</li>
<li><p><code>RESP</code>: response PD compartment (irm models)
</p>
</li></ul>



<h3>Output variables</h3>


<ul>
<li><p><code>CP</code>: concentration in the central compartment (<code>CENT/VC</code>)
</p>
</li>
<li><p><code>RESP</code>: response (emax model)
</p>
</li></ul>



<h3>PK parameters</h3>


<ul>
<li><p><code>KA1</code>, <code>KA2</code>:  first order absorption rate constants 
from first and second extravascular compartment (1/time)
</p>
</li>
<li><p><code>CL</code>: clearance (volume/time)
</p>
</li>
<li><p><code>VC</code>: volume of distribution, central compartment (volume)
</p>
</li>
<li><p><code>VP</code>:  volume of distribution, peripheral compartment 
(volume)
</p>
</li>
<li><p><code>VP2</code>: volume of distribution, peripheral compartment 2 
(volume)
</p>
</li>
<li><p><code>Q</code>: intercompartmental clearance (volume/time)
</p>
</li>
<li><p><code>Q2</code>: intercompartmental clearance 2 (volume/time)
</p>
</li>
<li><p><code>VMAX</code>:  maximum rate, nonlinear process (mass/time)
</p>
</li>
<li><p><code>KM</code>: Michaelis constant (mass/volume)
</p>
</li>
<li><p><code>K10</code>: elimination rate constant (1/time); <code>CL/VC</code>
</p>
</li>
<li><p><code>K12</code>: rate constant for transfer to peripheral compartment 
from central (1/time); <code>Q/VC</code>
</p>
</li>
<li><p><code>K21</code>: rate constant for transfer to central compartment from
peripheral (1/time); <code>Q/VP</code>
</p>
</li></ul>



<h3>PD parameters</h3>


<ul>
<li><p><code>E0</code>: baseline effect (emax model)
</p>
</li>
<li><p><code>EMAX</code>, <code>IMAX</code>: maximum effect (response)
</p>
</li>
<li><p><code>EC50</code>, <code>IC50</code>: concentration producing 50 percent of 
effect (mass/volume)
</p>
</li>
<li><p><code>KIN</code>: zero-order response production rate (irm models) 
(response/time)
</p>
</li>
<li><p><code>KOUT</code>: first-order response elimination rate (irm models)
(1/time)
</p>
</li>
<li><p><code>n</code>: sigmoidicity factor
</p>
</li>
<li><p><code>KEO</code>: rate constant for transfer to effect compartment 
(1/time)
</p>
</li></ul>


<hr>
<h2 id='modlib_pk'>modlib: Pharmacokinetic models</h2><span id='topic+modlib_pk'></span>

<h3>Description</h3>

<p>modlib: Pharmacokinetic models
</p>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="modlib_pk_+3A_...">...</code></td>
<td>
<p>passed to update</p>
</td></tr>
</table>


<h3>Details</h3>

<p>See <code><a href="#topic+modlib_details">modlib_details</a></code> for more detailed descriptions of 
parameters and compartments.
</p>
<p>The <code>pk1cmt</code> model is parameterized in terms of <code>CL</code>, <code>VC</code>, 
<code>KA1</code> and <code>KA2</code> and uses compartments <code>EV1</code>,
<code>EV2</code>, and <code>CENT</code>.  The <code>pk2cmt</code> model adds a <code>PERIPH</code> 
compartment and parameters <code>Q</code> and <code>VP</code> to that of the
one-compartment model.  Likewise, the three-compartment model (<code>pk3cmt</code>) 
adds <code>PERIPH2</code> and parameters <code>Q2</code> and <code>VP2</code> to
that of the two-compartment models.  All pk models also have parameters 
<code>VMAX</code> (defaulting to zero, no non-linear clearance) and <code>KM</code>.
</p>


<h3>Value</h3>

<p>an object of class <code>packmod</code>
</p>


<h3>Model description</h3>

<p>All pk models have two extravascular dosing compartments and potential 
for linear and nonlinear clearance.
</p>

<ul>
<li><p><code>pk1cmt</code>: one compartment pk model using ODEs
</p>
</li>
<li><p><code>pk2cmt</code>: two compartment pk  model using ODEs
</p>
</li>
<li><p><code>pk3cmt</code>: three compartment pk model using ODEs
</p>
</li>
<li><p><code>pk1</code>: one compartment pk model in closed-form
</p>
</li>
<li><p><code>pk2</code>: two compartment pk model in closed-form
</p>
</li>
<li><p><code>popex</code>: a simple population pk model
</p>
</li></ul>


<hr>
<h2 id='modlib_pkpd'>modlib: Pharmacokinetic / pharmacodynamic models</h2><span id='topic+modlib_pkpd'></span>

<h3>Description</h3>

<p>modlib: Pharmacokinetic / pharmacodynamic models
</p>


<h3>Details</h3>

<p>See <code><a href="#topic+modlib_details">modlib_details</a></code> for more detailed descriptions of 
parameters and compartments.
</p>
<p>All PK/PD models include 2-compartment PK model with absorption from 
2 extravascular compartments and linear + nonlinear clearance.  The 
PK models are parameterized with <code>CL</code>, <code>VC</code>, <code>Q</code>, 
<code>VMAX</code>, <code>KM</code>, <code>KA1</code> and <code>KA2</code> and implement 
compartments <code>EV1</code>, <code>EV2</code>, <code>CENT</code>, <code>PERIPH</code> .  
The indirect response models have compartment <code>RESP</code> and the emax 
model has output variable <code>RESP</code>.  PD parameters include <code>KIN</code>, 
<code>KOUT</code>, <code>IC50</code>, <code>EC50</code>, <code>IMAX</code>, <code>EMAX</code>, <code>E0</code>, 
and <code>n</code>.
</p>
<p>Also, once the model is loaded, use <code><a href="#topic+see">see</a></code> method for 
<code>mrgmod</code> to view the model code.
</p>


<h3>Model description</h3>


<ul>
<li><p><code>irm1</code> inhibition of response production
</p>
</li>
<li><p><code>irm2</code> inhibition of response loss
</p>
</li>
<li><p><code>irm3</code> stimulation of response production
</p>
</li>
<li><p><code>irm4</code> stimulation of response loss
</p>
</li>
<li><p><code>pd_effect</code> effect compartment model
</p>
</li>
<li><p><code>emax</code> sigmoid emax model
</p>
</li></ul>


<hr>
<h2 id='modlib_tmdd'>modlib: Target mediated disposition model</h2><span id='topic+modlib_tmdd'></span>

<h3>Description</h3>

<p>modlib: Target mediated disposition model
</p>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="modlib_tmdd_+3A_...">...</code></td>
<td>
<p>passed to update</p>
</td></tr>
</table>


<h3>Parameters</h3>


<ul>
<li><p><code>KEL</code>: elimination rate constant
</p>
</li>
<li><p><code>KTP</code>: tissue to plasma rate constant
</p>
</li>
<li><p><code>KPT</code>: plasma to tissue rate constant
</p>
</li>
<li><p><code>VC</code>: volume of distribution
</p>
</li>
<li><p><code>KA1</code>, <code>KA2</code>: absorption rate constants
</p>
</li>
<li><p><code>KINT</code>: internalization rate constant
</p>
</li>
<li><p><code>KON</code>: association rate constant
</p>
</li>
<li><p><code>KOFF</code>: dissociation rate constant
</p>
</li>
<li><p><code>KSYN</code>: target synthesis rate
</p>
</li>
<li><p><code>KDEG</code>: target degredation rate constant
</p>
</li></ul>



<h3>Compartments</h3>


<ul>
<li><p><code>CENT</code>: unbound drug in central compartment
</p>
</li>
<li><p><code>TISS</code>: unbound drug in tissue compartment
</p>
</li>
<li><p><code>REC</code>: concentration of target
</p>
</li>
<li><p><code>RC</code>: concentration of drug-target complex
</p>
</li>
<li><p><code>EV1</code>, <code>EV2</code>: extravascular dosing compartments
</p>
</li></ul>



<h3>Output variables</h3>


<ul>
<li><p><code>CP</code>: unbound drug in the central compartment
</p>
</li>
<li><p><code>TOTAL</code>: total concentration of target (complexed and uncomplexed)
</p>
</li></ul>


<hr>
<h2 id='modlib_viral'>modlib: HCV viral dynamics models</h2><span id='topic+modlib_viral'></span>

<h3>Description</h3>

<p>modlib: HCV viral dynamics models
</p>


<h3>Models</h3>


<ul>
<li><p><code>viral1</code>: viral dynamics model with single HCV species
</p>
</li>
<li><p><code>viral2</code>: viral dynamics model with wild-type and mutant 
HCV species
</p>
</li></ul>



<h3>Parameters</h3>


<ul>
<li><p><code>s</code>: new hepatocyte synthesis rate (cells/ml/day)
</p>
</li>
<li><p><code>d</code>: hepatocyte death rate constant (1/day)
</p>
</li>
<li><p><code>p</code>: viral production rate constant (copies/cell/day)
</p>
</li>
<li><p><code>beta</code>: new infection rate constant (ml/copy/day)
</p>
</li>
<li><p><code>delta</code>: infected cell death rate constant (1/day)
</p>
</li>
<li><p><code>c</code>: viral clearance rate constant (1/day)
</p>
</li>
<li><p><code>fit</code>: mutant virus fitness
</p>
</li>
<li><p><code>N</code>: non-target hepatocytes
</p>
</li>
<li><p><code>mu</code>: forward mutation rate
</p>
</li>
<li><p><code>Tmax</code>: maximum number of target hepatocytes (cells/ml)
</p>
</li>
<li><p><code>rho</code>: maximum hepatocyte regeneration rate (1/day)
</p>
</li></ul>



<h3>Compartments</h3>


<ul>
<li><p><code>T</code>: uninfected target hepatocytes (cells/ml)
</p>
</li>
<li><p><code>I</code>: productively infected hepatocytes (cells/ml)
</p>
</li>
<li><p><code>V</code>: hepatitis C virus (copies/ml)
</p>
</li>
<li><p><code>IM</code>: mutant infected hepatocytes (cells/ml)
</p>
</li>
<li><p><code>VM</code>: mutant hepatitis C virus (copies/ml)
</p>
</li>
<li><p><code>expos</code>: exposure metric to drive pharmacodynamic model
</p>
</li></ul>


<hr>
<h2 id='modMATRIX'>Create a matrix</h2><span id='topic+modMATRIX'></span>

<h3>Description</h3>

<p>Create a matrix
</p>


<h3>Usage</h3>

<pre><code class='language-R'>modMATRIX(
  x,
  use = TRUE,
  block = FALSE,
  correlation = FALSE,
  digits = -1,
  context = "matlist",
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="modMATRIX_+3A_x">x</code></td>
<td>
<p>data for building the matrix.  Data in <code>x</code> are assumed to be
on-diagonal elements if <code>block</code> is <code>FALSE</code> and lower-triangular
elements if <code>block</code> is <code>TRUE</code></p>
</td></tr>
<tr><td><code id="modMATRIX_+3A_use">use</code></td>
<td>
<p>logical; if FALSE, all matrix elements are set to 0</p>
</td></tr>
<tr><td><code id="modMATRIX_+3A_block">block</code></td>
<td>
<p>logical; if TRUE, try to make a block matrix; diagonal
otherwise</p>
</td></tr>
<tr><td><code id="modMATRIX_+3A_correlation">correlation</code></td>
<td>
<p>logical; if TRUE, off diagonal elements are assumed to 
be correlations and converted to covariances; if correlation is TRUE, then
block is set to TRUE</p>
</td></tr>
<tr><td><code id="modMATRIX_+3A_digits">digits</code></td>
<td>
<p>if value of this argument is greater than zero, the matrix 
is passed to signif (along with digits) prior to returning</p>
</td></tr>
<tr><td><code id="modMATRIX_+3A_context">context</code></td>
<td>
<p>the working context</p>
</td></tr>
<tr><td><code id="modMATRIX_+3A_...">...</code></td>
<td>
<p>passed along</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>modMATRIX("1 2.2 333")
modMATRIX("1 1.1 2.2", block=TRUE)
modMATRIX("23 234 234 5234", use=FALSE)

ans &lt;- modMATRIX("1.1 0.657 2.2", correlation=TRUE, block=TRUE)
ans
cov2cor(ans)

</code></pre>

<hr>
<h2 id='mread'>Read a model specification file</h2><span id='topic+mread'></span><span id='topic+mread_cache'></span><span id='topic+mread_file'></span>

<h3>Description</h3>

<p><code>mread()</code> reads and parses the mrgsolve model specification file,
builds the model, and returns a model object for simulation.
<code>mread_cache()</code> does the same, but caches the compilation result for
later use. <code>mread_file()</code> can be used for convenience, taking the model
file name as the first argument.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mread(
  model,
  project = getOption("mrgsolve.project", getwd()),
  code = NULL,
  file = NULL,
  udll = TRUE,
  ignore.stdout = TRUE,
  raw = FALSE,
  compile = TRUE,
  audit = TRUE,
  quiet = getOption("mrgsolve_mread_quiet", FALSE),
  check.bounds = FALSE,
  warn = TRUE,
  soloc = getOption("mrgsolve.soloc", tempdir()),
  capture = NULL,
  preclean = FALSE,
  recover = FALSE,
  ...
)

mread_cache(
  model = NULL,
  project = getOption("mrgsolve.project", getwd()),
  file = paste0(model, ".cpp"),
  code = NULL,
  soloc = getOption("mrgsolve.soloc", tempdir()),
  quiet = FALSE,
  preclean = FALSE,
  capture = NULL,
  ...
)

mread_file(file, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="mread_+3A_model">model</code></td>
<td>
<p>model name.</p>
</td></tr>
<tr><td><code id="mread_+3A_project">project</code></td>
<td>
<p>location of the model specification file an any
headers to be included; see also the discussion about model; this argument
can be set via <code><a href="base.html#topic+options">options()</a></code>.
library under details as well as the <code><a href="#topic+modlib">modlib()</a></code> help topic.</p>
</td></tr>
<tr><td><code id="mread_+3A_code">code</code></td>
<td>
<p>a character string with model specification code to be
used instead of a model file.</p>
</td></tr>
<tr><td><code id="mread_+3A_file">file</code></td>
<td>
<p>the full file name (with extension, but without path)
where the model is specified.</p>
</td></tr>
<tr><td><code id="mread_+3A_udll">udll</code></td>
<td>
<p>use unique name for shared object.</p>
</td></tr>
<tr><td><code id="mread_+3A_ignore.stdout">ignore.stdout</code></td>
<td>
<p>passed to system call when compiling the model; set this
to <code>FALSE</code> to print output to the R console.</p>
</td></tr>
<tr><td><code id="mread_+3A_raw">raw</code></td>
<td>
<p>if <code>TRUE</code>, return model content as a list, bypassing the compile
step; this argument is typically used for debugging problems with the
model build.</p>
</td></tr>
<tr><td><code id="mread_+3A_compile">compile</code></td>
<td>
<p>logical; if <code>TRUE</code>, the model will be built.</p>
</td></tr>
<tr><td><code id="mread_+3A_audit">audit</code></td>
<td>
<p>check the model specification file for errors.</p>
</td></tr>
<tr><td><code id="mread_+3A_quiet">quiet</code></td>
<td>
<p>don't print messages from mrgsolve when compiling.</p>
</td></tr>
<tr><td><code id="mread_+3A_check.bounds">check.bounds</code></td>
<td>
<p>check boundaries of parameter list.</p>
</td></tr>
<tr><td><code id="mread_+3A_warn">warn</code></td>
<td>
<p>logical; if <code>TRUE</code>, print warning messages that may arise while
building the model.</p>
</td></tr>
<tr><td><code id="mread_+3A_soloc">soloc</code></td>
<td>
<p>the directory location where the model shared object is built
and stored; see details; this argument can be set via <code><a href="base.html#topic+options">options()</a></code>;
if the directory does not exist, <code>mread()</code> will attempt to create it.</p>
</td></tr>
<tr><td><code id="mread_+3A_capture">capture</code></td>
<td>
<p>a character vector or comma-separated string of additional
model variables to capture; these variables will be added to the capture
list for the current call to <code>mread()</code> only.</p>
</td></tr>
<tr><td><code id="mread_+3A_preclean">preclean</code></td>
<td>
<p>logical; if <code>TRUE</code>, compilation artifacts are
cleaned up first.</p>
</td></tr>
<tr><td><code id="mread_+3A_recover">recover</code></td>
<td>
<p>if <code>TRUE</code>, a list of build will be returned in case
the model shared object fails to compile; use this option to and
the returned object to collect information assist in debugging.</p>
</td></tr>
<tr><td><code id="mread_+3A_...">...</code></td>
<td>
<p>passed to <code><a href="#topic+update">update()</a></code>; also arguments passed
to <code>mread()</code> from <code>mread_cache()</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>model</code> argument is required.  For typical use,
the <code>file</code> argument is omitted and the value
for <code>file</code> is generated from the value for <code>model</code>.
To determine the source file name, mrgsolve will look for
a file extension in <code>model</code>.  A file extension is
assumed when it finds a period followed by one to three alpha-numeric
characters at the end of the string (e.g. <code>mymodel.txt</code> but not
<code>my.model</code>).  If no file extension is found, the extension <code>.cpp</code>
is assumed (e.g. <code>file</code> is <code style="white-space: pre;">&#8288;&lt;model-name&gt;.cpp&#8288;</code>).  If a file
extension is found, <code>file</code> is <code style="white-space: pre;">&#8288;&lt;model-name&gt;&#8288;</code>.
</p>
<p>Best practice is to avoid using <code>.</code> in <code>model</code> unless
you are using <code>model</code> to point to the model specification
file name. Otherwise, use <code>mread_file()</code>.
</p>
<p>Use the <code>soloc</code> argument to specify a directory location for building
the model.  This is the location where the model shared object will be
stored on disk.  The default is a temporary directory, so compilation
artifacts are lost when R restarts when the default is used.  Changing
<code>soloc</code> to a persistent directory location will preserve those
artifacts across R restarts. Also, if simulation from a single model is
being done in separate processes on separate compute nodes, it might be
necessary to store these compilation artifacts in a local directory
to make them accessible to the different nodes. If the <code>soloc</code>
directory does not exist, <code>mread()</code> will attempt to create it.
</p>
<p>Similarly, using <code>mread_cache()</code> will cache results in the temporary
directory and the cache cannot be accessed after the R process is
restarted.
</p>


<h3>Model Library</h3>

<p>mrgsolve comes bundled with several pre-coded PK, PK/PD, and
other systems models that are accessible via the <code>mread()</code> interface.
</p>
<p>Models available in the library include:
</p>

<ul>
<li><p> PK models: <code>pk1cmt</code>, <code>pk2cmt</code>, <code>pk3cmt</code>, <code>pk1</code>, <code>pk2</code>, <code>popex</code>, <code>tmdd</code>
</p>
</li>
<li><p> PKPD models: <code>irm1</code>, <code>irm2</code>, <code>irm3</code>, <code>irm4</code>, <code>emax</code>, <code>effect</code>
</p>
</li>
<li><p> Other models: <code>viral1</code>, <code>viral2</code>
</p>
</li></ul>

<p>When the library model is accessed, mrgsolve will compile and load
the model as you would for any other model.  It is only necessary to
reference the correct model name and point the <code>project</code> argument
to the mrgsolve model library location via <code><a href="#topic+modlib">modlib()</a></code>.
</p>
<p>For more details, see <a href="#topic+modlib_pk">modlib_pk</a>, <a href="#topic+modlib_pkpd">modlib_pkpd</a>, <a href="#topic+modlib_tmdd">modlib_tmdd</a>,
<a href="#topic+modlib_viral">modlib_viral</a>, and <a href="#topic+modlib_details">modlib_details</a> for more information about the state
variables and parameters in each model.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+mcode">mcode()</a></code>, <code><a href="#topic+mcode_cache">mcode_cache()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Not run: 
code &lt;- '
$PARAM CL = 1, VC = 5
$CMT CENT
$ODE dxdt_CENT = -(CL/VC)*CENT;
'

mod &lt;- mcode("ex_mread", code)
mod

mod %&gt;% init(CENT=1000) %&gt;% mrgsim() %&gt;% plot()

mod &lt;- mread("irm3", modlib())

# if the model is in the file mymodel.cpp
mod &lt;- mread("mymodel")

# if the model is in the file mymodel.txt
mod &lt;- mread(file = "mymodel.txt")

or

mod &lt;- mread_file("mymodel.txt")

## End(Not run)

</code></pre>

<hr>
<h2 id='mread_yaml'>Read a model from yaml format</h2><span id='topic+mread_yaml'></span><span id='topic+yaml_to_cpp'></span>

<h3>Description</h3>

<p>Read back models written to file using <code><a href="#topic+mwrite_yaml">mwrite_yaml()</a></code>. Function
<code>yaml_to_cpp()</code> is also provided to convert the yaml file to mrgsolve cpp
file format.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mread_yaml(
  file,
  model = basename(file),
  project = tempdir(),
  update = FALSE,
  ...
)

yaml_to_cpp(file, model = basename(file), project = getwd(), update = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="mread_yaml_+3A_file">file</code></td>
<td>
<p>the yaml file name.</p>
</td></tr>
<tr><td><code id="mread_yaml_+3A_model">model</code></td>
<td>
<p>a new model name to use when calling <code>mread_yaml()</code>.</p>
</td></tr>
<tr><td><code id="mread_yaml_+3A_project">project</code></td>
<td>
<p>the directory where the model should be built.</p>
</td></tr>
<tr><td><code id="mread_yaml_+3A_update">update</code></td>
<td>
<p><code>TRUE</code> if model settings should be written into the cpp file in
a <code style="white-space: pre;">&#8288;$SET&#8288;</code> block.</p>
</td></tr>
<tr><td><code id="mread_yaml_+3A_...">...</code></td>
<td>
<p>passed to <code><a href="#topic+mread">mread()</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Note that <code>yaml_to_cpp()</code> by default writes model settings into the cpp
file. <code>mread_yaml()</code> does not write model settings into the file but rather
update the model object directly with data read back from the <code>yaml</code> file.
</p>


<h3>Value</h3>

<p>A model object.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+mwrite_yaml">mwrite_yaml()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>mod &lt;- house()

temp &lt;- tempfile(fileext = ".yaml")

mwrite_yaml(mod, file = temp)

# Note: this model is not compiled
mod &lt;- mread_yaml(temp, model = "new-house", compile = FALSE)
mod

cppfile &lt;- yaml_to_cpp(temp, project = tempdir())

readLines(cppfile)

</code></pre>

<hr>
<h2 id='mrgmod-class'>S4 class for mrgsolve model object</h2><span id='topic+mrgmod-class'></span>

<h3>Description</h3>

<p>S4 class for mrgsolve model object
</p>


<h3>Slots</h3>


<dl>
<dt><code>model</code></dt><dd><p>model name <code>&lt;character&gt;</code></p>
</dd>
<dt><code>modfile</code></dt><dd><p>source model specification file name <code>&lt;character&gt;</code></p>
</dd>
<dt><code>package</code></dt><dd><p>the shared object file name <code>character&gt;</code></p>
</dd>
<dt><code>project</code></dt><dd><p>working directory; must be writeable with no spaces 
<code>&lt;character&gt;</code></p>
</dd>
<dt><code>start</code></dt><dd><p>simulation start time <code>&lt;numeric&gt;</code></p>
</dd>
<dt><code>end</code></dt><dd><p>simulation end time <code>&lt;numeric&gt;</code></p>
</dd>
<dt><code>delta</code></dt><dd><p>simulation time interval <code>&lt;numeric&gt;</code></p>
</dd>
<dt><code>add</code></dt><dd><p>additional simulation times <code>&lt;numeric-vector&gt;</code></p>
</dd>
<dt><code>param</code></dt><dd><p><code>&lt;parameter_list&gt;</code></p>
</dd>
<dt><code>fixed</code></dt><dd><p>a <code>&lt;parameter_list&gt;</code> of fixed value parameters; 
these are not updatable from <code>R</code></p>
</dd>
<dt><code>init</code></dt><dd><p><code>&lt;cmt_list&gt;</code></p>
</dd>
<dt><code>digits</code></dt><dd><p>significant digits in simulated output; negative integer means 
ignore <code>&lt;numeric&gt;</code></p>
</dd>
<dt><code>hmin</code></dt><dd><p>passed to <code><a href="#topic+solversettings">dlsoda</a></code>  <code>&lt;numeric&gt;</code></p>
</dd>
<dt><code>hmax</code></dt><dd><p>passed to <code><a href="#topic+solversettings">dlsoda</a></code> <code>&lt;numeric&gt;</code></p>
</dd>
<dt><code>mxhnil</code></dt><dd><p>passed to <code><a href="#topic+solversettings">dlsoda</a></code> 
<code>&lt;numeric&gt;</code></p>
</dd>
<dt><code>ixpr</code></dt><dd><p>passed to <code><a href="#topic+solversettings">dlsoda</a></code> <code>&lt;numeric&gt;</code></p>
</dd>
<dt><code>atol</code></dt><dd><p>passed to <code><a href="#topic+solversettings">dlsoda</a></code> <code>&lt;numeric&gt;</code></p>
</dd>
<dt><code>rtol</code></dt><dd><p>passed to <code><a href="#topic+solversettings">dlsoda</a></code> <code>&lt;numeric&gt;</code></p>
</dd>
<dt><code>ss_rtol</code></dt><dd><p>relative tolerance to use when finding PK steady state <code>&lt;numeric&gt;</code></p>
</dd>
<dt><code>ss_atol</code></dt><dd><p>absolute tolerance to use when finding PK steady state <code>&lt;numeric&gt;</code></p>
</dd>
<dt><code>maxsteps</code></dt><dd><p>passed to <code><a href="#topic+solversettings">dlsoda</a></code> <code>&lt;numeric&gt;</code></p>
</dd>
<dt><code>preclean</code></dt><dd><p>passed to R CMD SHLIB during compilation <code>&lt;logical&gt;</code></p>
</dd>
<dt><code>verbose</code></dt><dd><p>print run information to screen <code>&lt;logical&gt;</code></p>
</dd>
<dt><code>quiet</code></dt><dd><p>print various information to screen <code>&lt;logical&gt;</code></p>
</dd>
<dt><code>debug</code></dt><dd><p>not used</p>
</dd>
<dt><code>tscale</code></dt><dd><p>used to scale time in simulated output <code>&lt;numeric&gt;</code></p>
</dd>
<dt><code>omega</code></dt><dd><p><code><a href="#topic+matlist">matlist</a></code> for simulating individual-level random 
effects</p>
</dd>
<dt><code>sigma</code></dt><dd><p><code><a href="#topic+matlist">matlist</a></code> for simulating residual error variates</p>
</dd>
<dt><code>args</code></dt><dd><p><code>&lt;list&gt;</code> of arguments to be passed to <code><a href="#topic+mrgsim">mrgsim</a></code></p>
</dd>
<dt><code>advan</code></dt><dd><p>either 2, 4, or 13 <code>&lt;numeric&gt;</code></p>
</dd>
<dt><code>trans</code></dt><dd><p>either 1, 2, 4, or 11 <code>&lt;numeric&gt;</code></p>
</dd>
<dt><code>request</code></dt><dd><p>vector of compartments to request <code>&lt;character&gt;</code></p>
</dd>
<dt><code>soloc</code></dt><dd><p>directory path for storing the model shared object 
<code>&lt;character&gt;</code></p>
</dd>
<dt><code>code</code></dt><dd><p>a character vector of the model code</p>
</dd>
<dt><code>capture</code></dt><dd><p>a character vector of variables that are captured from 
the simulation <code>&lt;character&gt;</code></p>
</dd>
<dt><code>mindt</code></dt><dd><p>minimum time between simulation records <code>&lt;numeric&gt;</code></p>
</dd>
<dt><code>envir</code></dt><dd><p>internal model environment <code>&lt;environment&gt;</code></p>
</dd>
<dt><code>shlib</code></dt><dd><p>a list of data related to build outcome <code>&lt;list&gt;</code></p>
</dd>
<dt><code>funs</code></dt><dd><p>symbol names for model functions in the shared object</p>
</dd>
<dt><code>annot</code></dt><dd><p>model annotations <code>&lt;list&gt;</code></p>
</dd>
<dt><code>plugin</code></dt><dd><p>model plugins <code>&lt;character&gt;</code></p>
</dd>
<dt><code>Icap</code></dt><dd><p>capture indices to recover in the simulation <code>&lt;integer&gt;</code></p>
</dd>
<dt><code>capL</code></dt><dd><p>labels for <code>Icap</code>;  <code>&lt;character&gt;</code></p>
</dd>
<dt><code>Icmt</code></dt><dd><p>compartment indices to recover in the simulation <code>&lt;integer&gt;</code></p>
</dd>
<dt><code>cmtL</code></dt><dd><p>labels for <code>Icmt</code>; <code>&lt;character&gt;</code></p>
</dd>
<dt><code>ss_cmt</code></dt><dd><p>compartments numbers to be considered when advancing the system
to steady state <code>&lt;integer&gt;</code></p>
</dd>
</dl>


<h3>Notes</h3>


<ul>
<li><p> Spaces in paths (<code>project</code> and <code>soloc</code>) are prohibited.
</p>
</li></ul>



<h3>See Also</h3>

<p><code><a href="#topic+update">update</a></code>, <code><a href="#topic+solversettings">solversettings</a></code>
</p>

<hr>
<h2 id='mrgsim'>Simulate from a model object</h2><span id='topic+mrgsim'></span><span id='topic+mrgsim_df'></span><span id='topic+do_mrgsim'></span>

<h3>Description</h3>

<p>This function sets up the simulation run from data stored in the model
object as well as arguments passed in.  Use <code><a href="#topic+mrgsim_q">mrgsim_q()</a></code> instead
to benchmark mrgsolve or to do repeated quick simulation for tasks like
parameter optimization, sensitivity analyses, or optimal design.  See
<a href="#topic+mrgsim_variants">mrgsim_variants</a> for other mrgsim-like functions that have more focused
inputs. <code>mrgsim_df</code> coerces output to data.frame prior to returning.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mrgsim(x, data = NULL, idata = NULL, events = NULL, nid = NULL, ...)

mrgsim_df(..., output = "df")

do_mrgsim(
  x,
  data,
  idata = no_idata_set(),
  carry_out = carry.out,
  carry.out = character(0),
  recover = character(0),
  seed = as.integer(NA),
  Request = character(0),
  output = NULL,
  capture = NULL,
  obsonly = FALSE,
  obsaug = FALSE,
  tgrid = NULL,
  etasrc = "omega",
  recsort = 1,
  deslist = list(),
  descol = character(0),
  filbak = TRUE,
  tad = FALSE,
  nocb = TRUE,
  skip_init_calc = FALSE,
  ss_n = 500,
  ss_fixed = FALSE,
  interrupt = 256,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="mrgsim_+3A_x">x</code></td>
<td>
<p>the model object.</p>
</td></tr>
<tr><td><code id="mrgsim_+3A_data">data</code></td>
<td>
<p>NMTRAN-like data set (see <code><a href="#topic+data_set">data_set()</a></code>).</p>
</td></tr>
<tr><td><code id="mrgsim_+3A_idata">idata</code></td>
<td>
<p>a matrix or data frame of model parameters,
one parameter per row (see <code><a href="#topic+idata_set">idata_set()</a></code>).</p>
</td></tr>
<tr><td><code id="mrgsim_+3A_events">events</code></td>
<td>
<p>an event object.</p>
</td></tr>
<tr><td><code id="mrgsim_+3A_nid">nid</code></td>
<td>
<p>integer number of individuals to simulate; only used if
idata and data are missing.</p>
</td></tr>
<tr><td><code id="mrgsim_+3A_...">...</code></td>
<td>
<p>passed to <code><a href="#topic+update">update()</a></code> and
<code><a href="#topic+do_mrgsim">do_mrgsim()</a></code>.</p>
</td></tr>
<tr><td><code id="mrgsim_+3A_output">output</code></td>
<td>
<p>if <code>NULL</code> (the default) a mrgsims object is returned;
otherwise, pass <code>df</code> to return a data.frame or <code>matrix</code> to
return a matrix.</p>
</td></tr>
<tr><td><code id="mrgsim_+3A_carry_out">carry_out</code></td>
<td>
<p>numeric data items to copy into the output.</p>
</td></tr>
<tr><td><code id="mrgsim_+3A_carry.out">carry.out</code></td>
<td>
<p>soon to be deprecated; use <code>carry_out</code> instead.</p>
</td></tr>
<tr><td><code id="mrgsim_+3A_recover">recover</code></td>
<td>
<p>character column names in either <code>data</code> or <code>idata</code>
to join back (recover) to simulated data; may be any class (e.g. numeric,
character, factor, etc).</p>
</td></tr>
<tr><td><code id="mrgsim_+3A_seed">seed</code></td>
<td>
<p>deprecated.</p>
</td></tr>
<tr><td><code id="mrgsim_+3A_request">Request</code></td>
<td>
<p>compartments or captured variables to retain
in the simulated output; this is different than the <code>request</code>
slot in the model object, which refers only to model compartments.</p>
</td></tr>
<tr><td><code id="mrgsim_+3A_capture">capture</code></td>
<td>
<p>character file name used for debugging (not related
to <code style="white-space: pre;">&#8288;$CAPTURE&#8288;</code>).</p>
</td></tr>
<tr><td><code id="mrgsim_+3A_obsonly">obsonly</code></td>
<td>
<p>if <code>TRUE</code>, dosing records are not included
in the output.</p>
</td></tr>
<tr><td><code id="mrgsim_+3A_obsaug">obsaug</code></td>
<td>
<p>augment the data set with time grid observations; when
<code>TRUE</code> and a full data set is used, the simulated output is augmented
with an observation at each time in <code><a href="#topic+stime">stime()</a></code>.  When using
<code>obsaug</code>, a flag indicating augmented observations can be requested by
including <code>a.u.g</code> in  <code>carry_out</code>.</p>
</td></tr>
<tr><td><code id="mrgsim_+3A_tgrid">tgrid</code></td>
<td>
<p>a tgrid object; or a numeric vector of simulation times
or another object with an <code>stime</code> method.</p>
</td></tr>
<tr><td><code id="mrgsim_+3A_etasrc">etasrc</code></td>
<td>
<p>source for <code>ETA()</code> values in the model; values can include:
<code>"omega"</code>, <code>"data"</code>, <code>"data.all"</code>, <code>"idata"</code>, or <code>"idata.all"</code>; see
'Details'.</p>
</td></tr>
<tr><td><code id="mrgsim_+3A_recsort">recsort</code></td>
<td>
<p>record sorting flag.  Default value is 1.  Possible values
are 1,2,3,4: 1 and 2 put doses in a data set after padded observations at
the same time; 3 and 4 put those doses before padded observations at the
same time.  2 and 4 will put doses scheduled through <code>addl</code> after
observations at the same time; 1 and 3 put doses scheduled through
<code>addl</code> before observations at the same time. <code>recsort</code> will
not change the order of your input data set if both doses and observations
are given.</p>
</td></tr>
<tr><td><code id="mrgsim_+3A_deslist">deslist</code></td>
<td>
<p>a list of tgrid objects.</p>
</td></tr>
<tr><td><code id="mrgsim_+3A_descol">descol</code></td>
<td>
<p>the name of a column for assigning designs.</p>
</td></tr>
<tr><td><code id="mrgsim_+3A_filbak">filbak</code></td>
<td>
<p>carry data items backward when the first
data set row has time greater than zero.</p>
</td></tr>
<tr><td><code id="mrgsim_+3A_tad">tad</code></td>
<td>
<p>when <code>TRUE</code> a column is added to simulated
output is added showing the time since the last dose.  Only data records
with <code>evid == 1</code> will be considered doses for the purposes of <code>tad</code>
calculation. The <code>tad</code> can be properly calculated with a dosing lag time in
the model as long as the dosing lag time (specified in <code style="white-space: pre;">&#8288;$MAIN&#8288;</code>)  is always
appropriate for any subsequent doses scheduled through <code>addl</code>.  This will
always be true if the lag time doesn't change over time.  But it might
(possibly) not hold if the lag time changes prior to the last dose in the
<code>addl</code> sequence.  This known limitation shouldn't affect <code>tad</code> calculation
in most common dosing lag time implementations.</p>
</td></tr>
<tr><td><code id="mrgsim_+3A_nocb">nocb</code></td>
<td>
<p>if <code>TRUE</code>, use next observation carry backward method;
otherwise, use <code>locf</code>.</p>
</td></tr>
<tr><td><code id="mrgsim_+3A_skip_init_calc">skip_init_calc</code></td>
<td>
<p>don't use <code style="white-space: pre;">&#8288;$MAIN&#8288;</code> to calculate initial conditions.</p>
</td></tr>
<tr><td><code id="mrgsim_+3A_ss_n">ss_n</code></td>
<td>
<p>maximum number of iterations for determining steady state for
the PK system; a warning will be issued if steady state is not achieved
within <code>ss_n</code> iterations when <code>ss_fixed</code> is <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="mrgsim_+3A_ss_fixed">ss_fixed</code></td>
<td>
<p>if <code>FALSE</code> (the default), then a warning will be issued
if the system does not reach steady state within <code>ss_n</code> iterations
given the model tolerances <code>rtol</code> and <code>atol</code>; if <code>TRUE</code>,
the number of iterations for determining steady state are capped at
<code>ss_n</code> and no warning will be issued if steady state
has not been reached within <code>ss_n</code> dosing iterations.
To silence warnings related to steady state, set <code>ss_fixed</code> to <code>TRUE</code> and
set <code>ss_n</code> as the maximum number of iterations to try when advancing the
system for steady state determination.</p>
</td></tr>
<tr><td><code id="mrgsim_+3A_interrupt">interrupt</code></td>
<td>
<p>integer check user interrupt interval; when <code>interrupt</code> is a
positive integer, the simulation will check for the user interrupt signal
every <code>interrupt</code> simulation records; pass a negative number to never check
for the user interrupt interval.</p>
</td></tr>
</table>


<h3>Details</h3>


<ul>
<li><p> Use <code><a href="#topic+mrgsim_df">mrgsim_df()</a></code> to return a data frame rather than
<code>mrgsims</code> object.
</p>
</li>
<li><p> Both <code>data</code> and <code>idata</code> will be coerced to numeric matrix
</p>
</li>
<li> <p><code>carry_out</code> can be used to insert data columns into the output
data set. This is partially dependent on the nature of the data brought
into the problem.
</p>
</li>
<li><p> When using <code>data</code> and <code>idata</code> together, an error is
generated if an  ID occurs in <code>data</code> but not <code>idata</code>.
Also, when looking up data in <code>idata</code>, ID in <code>idata</code> is
assumed to be uniquely keyed to ID in <code>data</code>.  No error is
generated if ID is duplicated in <code>data</code>; parameters will be used
from the first occurrence found in <code>idata</code>.
</p>
</li>
<li> <p><code>carry_out</code>: <code>idata</code> is assumed to be individual-level and variables that
are carried from <code>idata</code> are repeated throughout the individual's simulated
data.  Variables carried from <code>data</code> are carried via last-observation carry
forward.  <code>NA</code> is returned from observations that are inserted into
simulated output that occur prior to the first record in <code>data</code>.
</p>
</li>
<li> <p><code>recover</code>: this is similar to <code>carry_out</code> with respect to
end result, but it uses a different process.  Columns to be recovered are
cached prior to running the simulation, and then joined back on to the
simulated data.  So, whereas <code>carry_out</code> will only accept numeric
data items, <code>recover</code> can handle data frame columns of any type.  There
is a small decrease in performance with <code>recover</code> compared to
<code>carry_out</code>, but it is likely that the performance difference is
difficult to perceive (when the simulation runs very fast) or only a small
fractional increase in run time when the simulation is very large.  And any
performance hit is likely to be well worth it in light of the convenience
gain.  Just think carefully about using this feature when every millisecond
counts.
</p>
</li>
<li> <p><code>etasrc</code>: this argument lets you control where <code>ETA(n)</code> come from in the
model. When <code>etasrc</code> is set to <code>"omega"</code> (the default), <code>ETAs</code> will be
simulated from a multivariate normal distribution defined by the <code style="white-space: pre;">&#8288;$OMEGA&#8288;</code>
blocks in the model. Alternatively, input <code>data</code> or <code>idata</code> sets can be used
to pass in fixed <code>ETA(n)</code> by setting <code>etasrc</code> to <code>"data"</code>, <code>"idata"</code>,
<code>"data.all"</code> or <code>"idata.all"</code>. When <code>etasrc</code> is set to <code>"data"</code> or <code>"data.all"</code>,
the input data set will be scanned for columns called <code>ETA1</code>, <code>ETA2</code>, ...,
<code>ETAn</code> and those values will be copied into the appropriate slot in the
<code>ETA()</code> vector. Only the first record for each individual will be copied into
<code>ETA()</code>; all records after the first will be ignored. When there are more
than <code>9</code> <code>ETAs</code> in a model, NONMEM will start naming the outputs <code>ET10</code>,
<code>ET11</code> etc rather than <code>ETA10</code> and <code>ETA11</code>. When mrgsolve is looking for
these columns, it will first search, for example, <code>ET10</code> and use that value
if it is found. If <code>ET10</code> isn't found and there are more than <code>9</code> <code>ETAs</code>,
then it will <em>also</em> search for <code>ETA10</code>. An error will be generated in case
mrgsolve finds both the <code>ETA</code> and <code>ET</code> name variant for the tenth and higher
<code>ETA</code> (e.g. it is an error to have both <code>ETA10</code> and <code>ET10</code> in the data set).
When mrgsolve is searching for <code>ETA</code> columns in the data set, it will
<em>only</em> look for <code>ETAn</code> up to the number of rows (or columns) in all the
model <code style="white-space: pre;">&#8288;$OMEGA&#8288;</code> blocks. For example, if <code style="white-space: pre;">&#8288;$OMEGA&#8288;</code> is 5x5, only <code>ETA1</code> through
<code>ETA5</code> will be searched. An error will be generated in case mrgsolve finds
<em>no</em> columns with <code>ETAn</code> names and something other than <code>etasrc = "omega"</code>
was passed. When <code>etasrc = "data"</code> and an <code>ETAn</code> column is missing from the
data set, the missing <code>ETA()</code> will be set to <code>0</code>.  Alternatively, the user
can pass <code>etasrc = "data.all"</code> which causes an error to be generated if any
<code>ETAn</code> is missing from the data set. Use this option when you intend to have
<em>all</em> <code>ETAs</code> attached to the data set and want an error generated if mrgsolve
finds one or more of them is missing. Using <code>etasrc ="idata"</code> or
<code>"idata.all"</code>, the behavior is identical to <code>"data"</code> (or <code>"data.all"</code>),
except mrgsolve will look at the idata set rather than data set.
</p>
</li></ul>



<h3>Value</h3>

<p>An object of class <a href="#topic+mrgsims">mrgsims</a>.
</p>


<h3>See Also</h3>

<p><a href="#topic+mrgsim_variants">mrgsim_variants</a>, <code><a href="#topic+mrgsim_q">mrgsim_q()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## example("mrgsim")

e &lt;- ev(amt = 1000)

mod &lt;- mrgsolve::house() 

out &lt;- mod %&gt;% ev(e) %&gt;% mrgsim()

plot(out)

out &lt;- mod %&gt;% ev(e) %&gt;% mrgsim(end=22)

out

data(exTheoph)

out &lt;- mod %&gt;% data_set(exTheoph) %&gt;% mrgsim()

out

out &lt;- mod %&gt;% mrgsim(data=exTheoph)

out &lt;- mrgsim(mod, data=exTheoph, obsonly=TRUE)

out

out &lt;- mod %&gt;% mrgsim(data=exTheoph, obsaug=TRUE, carry_out="a.u.g")

out

out &lt;- mod %&gt;% ev(e) %&gt;% mrgsim(outvars="CP,RESP")

out

a &lt;- ev(amt = 1000, group = 'a')
b &lt;- ev(amt = 750, group = 'b')
data &lt;- as_data_set(a,b)

out &lt;- mrgsim_d(mod, data, recover="group")

out
</code></pre>

<hr>
<h2 id='mrgsim_q'>Simulate from a model object with quicker turnaround</h2><span id='topic+mrgsim_q'></span>

<h3>Description</h3>

<p>Use the function when you would usually use <code><a href="#topic+mrgsim_d">mrgsim_d()</a></code>,
but you need a quicker turnaround time.  The timing differences
might be difficult to detect for a single simulation run
but could become appreciable with repeated simulation.  See
<strong>Details</strong> for important differences in how <code>mrgsim_q()</code>
is invoked compared to <code><a href="#topic+mrgsim">mrgsim()</a></code> and <code><a href="#topic+mrgsim_d">mrgsim_d()</a></code>.
This function should always be used for benchmarking simulation time with
mrgsolve.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mrgsim_q(
  x,
  data,
  recsort = 1,
  stime = numeric(0),
  output = "mrgsims",
  skip_init_calc = FALSE,
  simcall = 0,
  etasrc = "omega"
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="mrgsim_q_+3A_x">x</code></td>
<td>
<p>a model object.</p>
</td></tr>
<tr><td><code id="mrgsim_q_+3A_data">data</code></td>
<td>
<p>a simulation data set.</p>
</td></tr>
<tr><td><code id="mrgsim_q_+3A_recsort">recsort</code></td>
<td>
<p>record sorting flag.</p>
</td></tr>
<tr><td><code id="mrgsim_q_+3A_stime">stime</code></td>
<td>
<p>a numeric vector of observation times; these observation
times will only be added to the output if there are no observation
records in <code>data</code>.</p>
</td></tr>
<tr><td><code id="mrgsim_q_+3A_output">output</code></td>
<td>
<p>output data type; if <code style="white-space: pre;">&#8288;"mrgsims", then the default output object is returned; if &#8288;</code>&quot;df&quot;' then a data frame is returned.</p>
</td></tr>
<tr><td><code id="mrgsim_q_+3A_skip_init_calc">skip_init_calc</code></td>
<td>
<p>don't use <code style="white-space: pre;">&#8288;$MAIN&#8288;</code> to calculate initial conditions.</p>
</td></tr>
<tr><td><code id="mrgsim_q_+3A_simcall">simcall</code></td>
<td>
<p>not used; only the default value of 0 is allowed.</p>
</td></tr>
<tr><td><code id="mrgsim_q_+3A_etasrc">etasrc</code></td>
<td>
<p>source for ETA() values in the model; values can include:
&quot;omega&quot;, <code>"data"</code>, <code>"data.all"</code>, <code>"idata"</code>, or <code>"idata.all"</code>; see
'Details' in <code><a href="#topic+mrgsim">mrgsim()</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>mrgsim_q()</code> mainly cuts some of the overhead from the simulation. So, the
primary efficiency gain from using <code>mrgsim_q()</code> comes when the simulation
executes very quickly. It is unlikely you will see a big performance
difference between <code>mrgsim_q()</code> and <code><a href="#topic+mrgsim">mrgsim()</a></code> when the model is difficult to
solve or if there is a large input data set.
</p>
<p>This function does not support the piped simulation workflow.  All
arguments must be passed into the function except for <code>x</code>.
</p>
<p>A data set is required for this simulation workflow.  The
data set can have only dosing records or doses with observations.
When the data set only includes doses, a single numeric vector of
observation times should be passed in.
</p>
<p>This simulation workflow does not support <code>Req</code> (request)
functionality.  All compartments and captured variables will
always be returned in the simulation output.
</p>
<p>This simulation workflow does not support carry-out functionality.
</p>
<p>This simulation workflow does not accept arguments to be passed
to <code><a href="#topic+update">update()</a></code>. This must be done by a separate
call to <code><a href="#topic+update">update()</a></code>.
</p>
<p>This simulation workflow does not support use of event objects.  If
an event object is needed, it should be converted to a data set
prior to the simulation run (see <code><a href="#topic+as_data_set">as_data_set()</a></code> or
<code><a href="base.html#topic+as.data.frame">as.data.frame()</a></code>).
</p>
<p>This simulation workflow does not support idata sets or any
feature enabled by <code>idata</code> set use.  Individual level parameters
should be joined onto the data set prior to simulation.  Otherwise
<code><a href="#topic+mrgsim_i">mrgsim_i()</a></code> or <code><a href="#topic+mrgsim_ei">mrgsim_ei()</a></code> should be used.
</p>
<p>By default, a mrgsims object is returned (as with <code><a href="#topic+mrgsim">mrgsim()</a></code>).
Use the <code>output = "df"</code> argument to request a plain
data.frame of simulated data on return.
</p>


<h3>Value</h3>

<p>By default, an object of class <code>mrgsims</code>. Use <code>output = "df"</code> to return
a data frame.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+mrgsim">mrgsim()</a></code>, <a href="#topic+mrgsim_variants">mrgsim_variants</a>, <code><a href="#topic+qsim">qsim()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>mod &lt;- mrgsolve::house()

data &lt;- expand.ev(amt = c(100, 300, 1000))

out &lt;- mrgsim_q(mod, data)

out

</code></pre>

<hr>
<h2 id='mrgsim_variants'>mrgsim variant functions</h2><span id='topic+mrgsim_variants'></span><span id='topic+mrgsim_e'></span><span id='topic+mrgsim_d'></span><span id='topic+mrgsim_ei'></span><span id='topic+mrgsim_di'></span><span id='topic+mrgsim_i'></span><span id='topic+mrgsim_0'></span>

<h3>Description</h3>

<p>These functions are called by <code><a href="#topic+mrgsim">mrgsim()</a></code> and have
explicit input requirements written into the function name.  The motivation
behind these variants is to give the user a clear workflow with specific,
required inputs as indicated by the function name. Use
<code><a href="#topic+mrgsim_q">mrgsim_q()</a></code> instead to benchmark mrgsolve or to do repeated quick
simulation for tasks like parameter optimization,  sensitivity analyses,
or optimal design.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mrgsim_e(x, events, idata = NULL, data = NULL, ...)

mrgsim_d(x, data, idata = NULL, events = NULL, ...)

mrgsim_ei(x, events, idata, data = NULL, ...)

mrgsim_di(x, data, idata, events = NULL, ...)

mrgsim_i(x, idata, data = NULL, events = NULL, ...)

mrgsim_0(x, idata = NULL, data = NULL, events = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="mrgsim_variants_+3A_x">x</code></td>
<td>
<p>the model object.</p>
</td></tr>
<tr><td><code id="mrgsim_variants_+3A_events">events</code></td>
<td>
<p>an event object.</p>
</td></tr>
<tr><td><code id="mrgsim_variants_+3A_idata">idata</code></td>
<td>
<p>a matrix or data frame of model parameters,
one parameter per row (see <code><a href="#topic+idata_set">idata_set()</a></code>).</p>
</td></tr>
<tr><td><code id="mrgsim_variants_+3A_data">data</code></td>
<td>
<p>NMTRAN-like data set (see <code><a href="#topic+data_set">data_set()</a></code>).</p>
</td></tr>
<tr><td><code id="mrgsim_variants_+3A_...">...</code></td>
<td>
<p>passed to <code><a href="#topic+update">update()</a></code> and
<code><a href="#topic+do_mrgsim">do_mrgsim()</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><strong>Important</strong>: all of these functions require that
<code>data</code>, <code>idata</code>, and/or <code>events</code> be pass directly to the functions.  They
will not recognize these inputs from a pipeline.
</p>

<ul>
<li> <p><code>mrgsim_e</code> simulate using an event object
</p>
</li>
<li> <p><code>mrgsim_ei</code> simulate using an event object and <code>idata_set</code>
</p>
</li>
<li> <p><code>mrgsim_d</code> simulate using a <code>data_set</code>
</p>
</li>
<li> <p><code>mrgsim_di</code> simulate using a <code>data_set</code> and  <code>idata_set</code>
</p>
</li>
<li> <p><code>mrgsim_i</code> simulate using a <code>idata_set</code>
</p>
</li>
<li> <p><code>mrgsim_0</code> simulate using just the model
</p>
</li>
<li> <p><code>mrgsim_q</code> simulate from a data set with quicker turnaround (see
<code><a href="#topic+mrgsim_q">mrgsim_q()</a></code>)
</p>
</li></ul>



<h3>See Also</h3>

<p><code><a href="#topic+mrgsim">mrgsim()</a></code>, <code><a href="#topic+mrgsim_q">mrgsim_q()</a></code>, <code><a href="#topic+qsim">qsim()</a></code>
</p>

<hr>
<h2 id='mrgsims'>Methods for working with <code>mrgsims</code> objects</h2><span id='topic+mrgsims'></span><span id='topic++24+2Cmrgsims-method'></span><span id='topic+tail+2Cmrgsims-method'></span><span id='topic+head+2Cmrgsims-method'></span><span id='topic+dim+2Cmrgsims-method'></span><span id='topic+names+2Cmrgsims-method'></span><span id='topic+as.data.frame+2Cmrgsims-method'></span><span id='topic+as.matrix+2Cmrgsims-method'></span><span id='topic+summary.mrgsims'></span><span id='topic+show+2Cmrgsims-method'></span>

<h3>Description</h3>

<p>These methods help the user view simulation output and extract
simulated data to work with further.  The methods listed here
for the most part have generics defined by R or other R packages.
See the <strong>See Also</strong> section for other methods defined
by mrgsolve that have their own documentation pages.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'mrgsims'
x$name

## S4 method for signature 'mrgsims'
tail(x, ...)

## S4 method for signature 'mrgsims'
head(x, ...)

## S4 method for signature 'mrgsims'
dim(x)

## S4 method for signature 'mrgsims'
names(x)

## S4 method for signature 'mrgsims'
as.data.frame(x, row.names = NULL, optional = FALSE, ...)

## S4 method for signature 'mrgsims'
as.matrix(x, ...)

## S3 method for class 'mrgsims'
summary(object, ...)

## S4 method for signature 'mrgsims'
show(object)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="mrgsims_+3A_x">x</code></td>
<td>
<p>mrgsims object.</p>
</td></tr>
<tr><td><code id="mrgsims_+3A_name">name</code></td>
<td>
<p>name of column of simulated output to retain</p>
</td></tr>
<tr><td><code id="mrgsims_+3A_...">...</code></td>
<td>
<p>passed to other functions.</p>
</td></tr>
<tr><td><code id="mrgsims_+3A_row.names">row.names</code></td>
<td>
<p>passed to <code><a href="base.html#topic+as.data.frame">as.data.frame()</a></code>.</p>
</td></tr>
<tr><td><code id="mrgsims_+3A_optional">optional</code></td>
<td>
<p>passed to <code><a href="base.html#topic+as.data.frame">as.data.frame()</a></code>.</p>
</td></tr>
<tr><td><code id="mrgsims_+3A_object">object</code></td>
<td>
<p>passed to show.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Most methods should behave as expected according to other method
commonly used in R (e.g. head, tail, as.data.frame, etc ...)
</p>

<ul>
<li> <p><code>$</code> selects a column in the simulated data and
returns numeric
</p>
</li>
<li> <p><code>head()</code> see <code><a href="utils.html#topic+head.matrix">head.matrix()</a></code>; returns simulated data
</p>
</li>
<li> <p><code>tail()</code> see <code><a href="utils.html#topic+tail.matrix">tail.matrix()</a></code>; returns simulated data
</p>
</li>
<li> <p><code>dim()</code>, <code>nrow()</code>, <code>ncol()</code> returns dimensions,
number of rows, and number of columns in simulated data
</p>
</li>
<li> <p><code>as.data.frame()</code> coerces simulated data to data.frame
</p>
</li>
<li> <p><code>as.matrix()</code> returns matrix of simulated data
</p>
</li>
<li> <p><code>summary()</code> coerces simulated data to data.frame and passes to
<code><a href="base.html#topic+summary.data.frame">summary.data.frame()</a></code>
</p>
</li>
<li> <p><code><a href="base.html#topic+plot">plot()</a></code> plots simulated data; see <a href="#topic+plot_mrgsims">plot_mrgsims</a>
</p>
</li></ul>



<h3>See Also</h3>

<p><code><a href="#topic+stime">stime()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## example("mrgsims")

mod &lt;- mrgsolve::house() %&gt;% init(GUT=100)

out &lt;- mrgsim(mod)

class(out)

## Not run: 
out

## End(Not run)
head(out)
tail(out)


dim(out)
names(out)

mat &lt;- as.matrix(out)
df &lt;- as.data.frame(out)

## Not run: 
out$CP

## End(Not run)

plot(out)

## Not run: 
plot(out, CP~.)
plot(out, CP+RESP~time, scales="same", xlab="Time", main="Model sims")

## End(Not run)
</code></pre>

<hr>
<h2 id='mrgsims_dplyr'>Methods for handling output with dplyr verbs</h2><span id='topic+mrgsims_dplyr'></span><span id='topic+pull.mrgsims'></span><span id='topic+filter.mrgsims'></span><span id='topic+group_by.mrgsims'></span><span id='topic+distinct.mrgsims'></span><span id='topic+mutate.mrgsims'></span><span id='topic+summarise.each'></span><span id='topic+summarise.mrgsims'></span><span id='topic+do.mrgsims'></span><span id='topic+select.mrgsims'></span><span id='topic+slice.mrgsims'></span><span id='topic+as_data_frame.mrgsims'></span><span id='topic+as_tibble.mrgsims'></span><span id='topic+as.tbl.mrgsims'></span>

<h3>Description</h3>

<p>These methods modify the data in a mrgsims object and return a data frame.
Contrast with the functions in <a href="#topic+mrgsims_modify">mrgsims_modify</a>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'mrgsims'
pull(.data, ...)

## S3 method for class 'mrgsims'
filter(.data, ...)

## S3 method for class 'mrgsims'
group_by(.data, ..., add = FALSE, .add = FALSE)

## S3 method for class 'mrgsims'
distinct(.data, ..., .keep_all = FALSE)

## S3 method for class 'mrgsims'
mutate(.data, ...)

## S3 method for class 'each'
summarise(.data, funs, ...)

## S3 method for class 'mrgsims'
summarise(.data, ...)

## S3 method for class 'mrgsims'
do(.data, ..., .dots)

## S3 method for class 'mrgsims'
select(.data, ...)

## S3 method for class 'mrgsims'
slice(.data, ...)

as_data_frame.mrgsims(x, ...)

## S3 method for class 'mrgsims'
as_tibble(x, ...)

as.tbl.mrgsims(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="mrgsims_dplyr_+3A_.data">.data</code></td>
<td>
<p>an mrgsims object; passed to various <code>dplyr</code> functions</p>
</td></tr>
<tr><td><code id="mrgsims_dplyr_+3A_...">...</code></td>
<td>
<p>passed to other methods</p>
</td></tr>
<tr><td><code id="mrgsims_dplyr_+3A_add">add</code></td>
<td>
<p>passed to <a href="dplyr.html#topic+group_by">dplyr::group_by</a> (for dplyr &lt; <code style="white-space: pre;">&#8288;1.0.0&#8288;</code>)</p>
</td></tr>
<tr><td><code id="mrgsims_dplyr_+3A_.add">.add</code></td>
<td>
<p>passed to <a href="dplyr.html#topic+group_by">dplyr::group_by</a> (for dplyr &gt;= <code style="white-space: pre;">&#8288;1.0.0&#8288;</code>)</p>
</td></tr>
<tr><td><code id="mrgsims_dplyr_+3A_.keep_all">.keep_all</code></td>
<td>
<p>passed to <a href="dplyr.html#topic+distinct">dplyr::distinct</a></p>
</td></tr>
<tr><td><code id="mrgsims_dplyr_+3A_funs">funs</code></td>
<td>
<p>passed to <a href="dplyr.html#topic+summarise_each">dplyr::summarise_each</a></p>
</td></tr>
<tr><td><code id="mrgsims_dplyr_+3A_.dots">.dots</code></td>
<td>
<p>passed to various <code>dplyr</code> functions</p>
</td></tr>
<tr><td><code id="mrgsims_dplyr_+3A_x">x</code></td>
<td>
<p>mrgsims object.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For the <code>select_sims</code> function, the dots <code>...</code> must be either
compartment names or variables in <code style="white-space: pre;">&#8288;$CAPTURE&#8288;</code>.  An error will be
generated if no valid names are selected or the names for selection are
not found in the simulated output.
</p>


<h3>See Also</h3>

<p><a href="#topic+mrgsims_modify">mrgsims_modify</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
out &lt;- mrgsim(house(), events = ev(amt = 100), end = 5, delta=1)

dplyr::filter(out, time==2)

dplyr::mutate(out, label = "abc")

dplyr::select(out, time, RESP, CP)

</code></pre>

<hr>
<h2 id='mrgsims_modify'>Methods for modifying mrgsims objects</h2><span id='topic+mrgsims_modify'></span><span id='topic+mutate_sims'></span><span id='topic+select_sims'></span><span id='topic+filter_sims'></span>

<h3>Description</h3>

<p>These functions modify the simulated data in an mrgsims object and return
the modified object.  Contrast with the functions in <a href="#topic+mrgsims_dplyr">mrgsims_dplyr</a>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mutate_sims(.data, ...)

select_sims(.data, ...)

filter_sims(.data, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="mrgsims_modify_+3A_.data">.data</code></td>
<td>
<p>a mrgsims object.</p>
</td></tr>
<tr><td><code id="mrgsims_modify_+3A_...">...</code></td>
<td>
<p>other arguments passed to the <code>dplyr</code> functions.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><a href="#topic+mrgsims_dplyr">mrgsims_dplyr</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
out &lt;- mrgsim(house(), events = ev(amt = 100))

filter_sims(out, time &gt; 2)

mutate_sims(out, label = "abc")

select_sims(out, RESP, CP)

</code></pre>

<hr>
<h2 id='mrgsims-class'>S4 class for mrgsolve simulation output</h2><span id='topic+mrgsims-class'></span>

<h3>Description</h3>

<p>S4 class for mrgsolve simulation output
</p>


<h3>Slots</h3>


<dl>
<dt><code>request</code></dt><dd><p>character vector of compartments requested in simulated 
output</p>
</dd>
<dt><code>outnames</code></dt><dd><p>character vector of column names in simulated output 
coming from table step</p>
</dd>
<dt><code>data</code></dt><dd><p>data.frame of simulated data</p>
</dd>
<dt><code>mod</code></dt><dd><p>the mrgmod model object</p>
</dd>
</dl>

<hr>
<h2 id='mutate.ev'>dplyr verbs for event objects</h2><span id='topic+mutate.ev'></span><span id='topic+select.ev'></span><span id='topic+filter.ev'></span>

<h3>Description</h3>

<p>dplyr verbs for event objects
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'ev'
mutate(.data, ...)

## S3 method for class 'ev'
select(.data, ...)

## S3 method for class 'ev'
filter(.data, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="mutate.ev_+3A_.data">.data</code></td>
<td>
<p>the event object.</p>
</td></tr>
<tr><td><code id="mutate.ev_+3A_...">...</code></td>
<td>
<p>passed to the <code>dplyr</code> function.</p>
</td></tr>
</table>

<hr>
<h2 id='mvgauss'>Simulate from a multivariate normal distribution with mean zero</h2><span id='topic+mvgauss'></span>

<h3>Description</h3>

<p>Simulate from a multivariate normal distribution with mean zero
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mvgauss(mat, n = 10, seed = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="mvgauss_+3A_mat">mat</code></td>
<td>
<p>a positive-definite matrix</p>
</td></tr>
<tr><td><code id="mvgauss_+3A_n">n</code></td>
<td>
<p>number of variates to simulate</p>
</td></tr>
<tr><td><code id="mvgauss_+3A_seed">seed</code></td>
<td>
<p>if not null, passed to set.seed</p>
</td></tr>
</table>

<hr>
<h2 id='mwrite_cpp'>Write a model to native mrgsolve format</h2><span id='topic+mwrite_cpp'></span>

<h3>Description</h3>

<p>Model code is written to a file in native mrgsolve format. This
can be useful for (1) breaking connection to NONMEM modeling outputs that
are imported by <code style="white-space: pre;">&#8288;$NMXML&#8288;</code> or <code style="white-space: pre;">&#8288;$NMEXT&#8288;</code> and (2) saving model updates (e.g.,
an updated parameter list). Models can be read back using <code><a href="#topic+mread">mread()</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mwrite_cpp(x, file, update = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="mwrite_cpp_+3A_x">x</code></td>
<td>
<p>a model object.</p>
</td></tr>
<tr><td><code id="mwrite_cpp_+3A_file">file</code></td>
<td>
<p>output file name; if non-character (e.g., <code>NULL</code>), no output
will be written to file.</p>
</td></tr>
<tr><td><code id="mwrite_cpp_+3A_update">update</code></td>
<td>
<p><code>TRUE</code> if model settings should be written into the cpp file in
a <code style="white-space: pre;">&#8288;$SET&#8288;</code> block.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>See important details in <code><a href="#topic+mwrite_yaml">mwrite_yaml()</a></code>.
</p>


<h3>Value</h3>

<p>A list containing data that was written out to the cpp file, with added
item <code>file</code>, is returned invisibly.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+mwrite_yaml">mwrite_yaml()</a></code>, <code><a href="#topic+yaml_to_cpp">yaml_to_cpp()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>temp &lt;- tempfile(fileext = ".mod")

mod &lt;- modlib("pk1", compile = FALSE)

x &lt;- mwrite_cpp(mod, file = temp)

mod &lt;- mread(x$file, compile = FALSE)

mod

</code></pre>

<hr>
<h2 id='mwrite_yaml'>Write model code to yaml  format</h2><span id='topic+mwrite_yaml'></span>

<h3>Description</h3>

<p>Model code is written to a readable, transport format. This transport format
can be useful for (1) breaking connection to NONMEM modeling outputs that
are imported by <code style="white-space: pre;">&#8288;$NMXML&#8288;</code> or <code style="white-space: pre;">&#8288;$NMEXT&#8288;</code> and (2) saving model updates (e.g.,
an updated parameter list). Models can be read back using <code><a href="#topic+mread_yaml">mread_yaml()</a></code> or
converted to mrgsolve cpp format with <code><a href="#topic+yaml_to_cpp">yaml_to_cpp()</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mwrite_yaml(x, file, digits = 8)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="mwrite_yaml_+3A_x">x</code></td>
<td>
<p>a model object.</p>
</td></tr>
<tr><td><code id="mwrite_yaml_+3A_file">file</code></td>
<td>
<p>output file name; if non-character (e.g., <code>NULL</code>), no output
will be written to file.</p>
</td></tr>
<tr><td><code id="mwrite_yaml_+3A_digits">digits</code></td>
<td>
<p>precision to use when writing outputs.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Parameters and omega and sigma matrices that were imported via <code style="white-space: pre;">&#8288;$NMXML&#8288;</code>
or <code style="white-space: pre;">&#8288;$NMEXT&#8288;</code> will be written into the yaml file and the NONMEM import blocks
will be dropped. This allows the user to load a model based on a NONMEM run
without having a connection to that output (e.g., <code>root.xml</code> or <code>root.ext</code>).
Given that the connection to the NONMEM modeling outputs is broken when
writing to yaml, any update to the NONMEM run will only be propagated to
the yaml file when <code>mwrite_yaml()</code> is run again.
</p>
<p>The yaml file does not currently have the ability to track
other external dependencies, such as user-defined header files or other
code that might be sourced in by the user when the model is loaded via
<code><a href="#topic+mread">mread()</a></code>. NONMEM xml and ext files imported by <code style="white-space: pre;">&#8288;$NMXML&#8288;</code> or <code style="white-space: pre;">&#8288;$NMEXT&#8288;</code> are
the <em>only</em> external dependencies that are accounted for in the yaml
transport file.
</p>


<h3>Value</h3>

<p>A list containing data that was written out to the yaml file, with added
item <code>file</code>, is returned invisibly.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+mread_yaml">mread_yaml()</a></code>, <code><a href="#topic+yaml_to_cpp">yaml_to_cpp()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>mod &lt;- house()

temp1 &lt;- tempfile(fileext = ".yaml")

x &lt;- mwrite_yaml(mod, temp1)

readLines(temp1)

</code></pre>

<hr>
<h2 id='names+2Cmrgmod-method'>Get all names from a model object</h2><span id='topic+names+2Cmrgmod-method'></span>

<h3>Description</h3>

<p>Get all names from a model object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'mrgmod'
names(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="names+2B2Cmrgmod-method_+3A_x">x</code></td>
<td>
<p>the model object</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>mod &lt;- mrgsolve::house()
names(mod)

</code></pre>

<hr>
<h2 id='nmext'>Import model estimates from a NONMEM ext file</h2><span id='topic+nmext'></span>

<h3>Description</h3>

<p>Import model estimates from a NONMEM ext file
</p>


<h3>Usage</h3>

<pre><code class='language-R'>nmext(
  run = NA_real_,
  project = getwd(),
  file = paste0(run, ".ext"),
  path = NULL,
  root = c("working", "cppfile"),
  index = "last",
  theta = TRUE,
  omega = TRUE,
  sigma = TRUE,
  olabels = NULL,
  slabels = NULL,
  oprefix = "",
  sprefix = "",
  tname = "THETA",
  oname = "...",
  sname = "...",
  read_fun = "data.table",
  env = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="nmext_+3A_run">run</code></td>
<td>
<p>run number.</p>
</td></tr>
<tr><td><code id="nmext_+3A_project">project</code></td>
<td>
<p>project directory.</p>
</td></tr>
<tr><td><code id="nmext_+3A_file">file</code></td>
<td>
<p>deprecated; use <code>path</code> instead.</p>
</td></tr>
<tr><td><code id="nmext_+3A_path">path</code></td>
<td>
<p>full path to NONMEM <code>ext</code> file.</p>
</td></tr>
<tr><td><code id="nmext_+3A_root">root</code></td>
<td>
<p>the directory that <code>path</code> and <code>project</code> are relative to; this is
currently limited to the <code>working</code> directory or <code>cppdir</code>, the directory
where the model file is located.</p>
</td></tr>
<tr><td><code id="nmext_+3A_index">index</code></td>
<td>
<p>the estimation number to return;  &quot;last&quot; will return the
last estimation results; otherwise, pass an integer indicating which
estimation results to return.</p>
</td></tr>
<tr><td><code id="nmext_+3A_theta">theta</code></td>
<td>
<p>logical; if TRUE, the <code style="white-space: pre;">&#8288;$THETA&#8288;</code> vector is returned.</p>
</td></tr>
<tr><td><code id="nmext_+3A_omega">omega</code></td>
<td>
<p>logical; if TRUE, the <code style="white-space: pre;">&#8288;$OMEGA&#8288;</code> matrix is returned.</p>
</td></tr>
<tr><td><code id="nmext_+3A_sigma">sigma</code></td>
<td>
<p>logical; if TRUE, the <code style="white-space: pre;">&#8288;$SIGMA&#8288;</code> matrix is returned.</p>
</td></tr>
<tr><td><code id="nmext_+3A_olabels">olabels</code></td>
<td>
<p>labels for <code style="white-space: pre;">&#8288;$OMEGA&#8288;</code>.</p>
</td></tr>
<tr><td><code id="nmext_+3A_slabels">slabels</code></td>
<td>
<p>labels for <code style="white-space: pre;">&#8288;$SIGMA&#8288;</code>.</p>
</td></tr>
<tr><td><code id="nmext_+3A_oprefix">oprefix</code></td>
<td>
<p>prefix for <code style="white-space: pre;">&#8288;$OMEGA&#8288;</code> labels.</p>
</td></tr>
<tr><td><code id="nmext_+3A_sprefix">sprefix</code></td>
<td>
<p>prefix for <code style="white-space: pre;">&#8288;$SIGMA&#8288;</code> labels.</p>
</td></tr>
<tr><td><code id="nmext_+3A_tname">tname</code></td>
<td>
<p>name for <code style="white-space: pre;">&#8288;$THETA&#8288;</code>.</p>
</td></tr>
<tr><td><code id="nmext_+3A_oname">oname</code></td>
<td>
<p>name for <code style="white-space: pre;">&#8288;$OMEGA&#8288;</code>.</p>
</td></tr>
<tr><td><code id="nmext_+3A_sname">sname</code></td>
<td>
<p>name for <code style="white-space: pre;">&#8288;$SIGMA&#8288;</code>.</p>
</td></tr>
<tr><td><code id="nmext_+3A_read_fun">read_fun</code></td>
<td>
<p>function to use when reading the <code>ext</code> file.</p>
</td></tr>
<tr><td><code id="nmext_+3A_env">env</code></td>
<td>
<p>internal use only.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+nmxml">nmxml()</a></code>, <code><a href="#topic+read_nmext">read_nmext()</a></code>
</p>

<hr>
<h2 id='nmxml'>Import model estimates from a NONMEM xml file</h2><span id='topic+nmxml'></span><span id='topic+NMXML'></span>

<h3>Description</h3>

<p>Import model estimates from a NONMEM xml file
</p>


<h3>Usage</h3>

<pre><code class='language-R'>nmxml(
  run = numeric(0),
  project = character(0),
  file = character(0),
  path = character(0),
  root = c("working", "cppfile"),
  theta = TRUE,
  omega = TRUE,
  sigma = TRUE,
  olabels = NULL,
  slabels = NULL,
  oprefix = "",
  sprefix = "",
  tname = "THETA",
  oname = "...",
  sname = "...",
  index = "last",
  xpath = ".//nm:estimation",
  env = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="nmxml_+3A_run">run</code></td>
<td>
<p>run number.</p>
</td></tr>
<tr><td><code id="nmxml_+3A_project">project</code></td>
<td>
<p>project directory.</p>
</td></tr>
<tr><td><code id="nmxml_+3A_file">file</code></td>
<td>
<p>deprecated; use <code>path</code> instead.</p>
</td></tr>
<tr><td><code id="nmxml_+3A_path">path</code></td>
<td>
<p>the complete path to the <code>run.xml</code> file.</p>
</td></tr>
<tr><td><code id="nmxml_+3A_root">root</code></td>
<td>
<p>the directory that <code>path</code> and <code>project</code> are relative to; this is
currently limited to the <code>working</code> directory or <code>cppdir</code>, the directory
where the model file is located.</p>
</td></tr>
<tr><td><code id="nmxml_+3A_theta">theta</code></td>
<td>
<p>logical; if TRUE, the <code style="white-space: pre;">&#8288;$THETA&#8288;</code> vector is returned.</p>
</td></tr>
<tr><td><code id="nmxml_+3A_omega">omega</code></td>
<td>
<p>logical; if TRUE, the <code style="white-space: pre;">&#8288;$OMEGA&#8288;</code> matrix is returned.</p>
</td></tr>
<tr><td><code id="nmxml_+3A_sigma">sigma</code></td>
<td>
<p>logical; if TRUE, the <code style="white-space: pre;">&#8288;$SIGMA&#8288;</code> matrix is returned.</p>
</td></tr>
<tr><td><code id="nmxml_+3A_olabels">olabels</code></td>
<td>
<p>labels for <code style="white-space: pre;">&#8288;$OMEGA&#8288;</code>.</p>
</td></tr>
<tr><td><code id="nmxml_+3A_slabels">slabels</code></td>
<td>
<p>labels for <code style="white-space: pre;">&#8288;$SIGMA&#8288;</code>.</p>
</td></tr>
<tr><td><code id="nmxml_+3A_oprefix">oprefix</code></td>
<td>
<p>prefix for <code style="white-space: pre;">&#8288;$OMEGA&#8288;</code> labels.</p>
</td></tr>
<tr><td><code id="nmxml_+3A_sprefix">sprefix</code></td>
<td>
<p>prefix for <code style="white-space: pre;">&#8288;$SIGMA&#8288;</code> labels.</p>
</td></tr>
<tr><td><code id="nmxml_+3A_tname">tname</code></td>
<td>
<p>name for <code style="white-space: pre;">&#8288;$THETA&#8288;</code>.</p>
</td></tr>
<tr><td><code id="nmxml_+3A_oname">oname</code></td>
<td>
<p>name for <code style="white-space: pre;">&#8288;$OMEGA&#8288;</code>.</p>
</td></tr>
<tr><td><code id="nmxml_+3A_sname">sname</code></td>
<td>
<p>name for <code style="white-space: pre;">&#8288;$SIGMA&#8288;</code>.</p>
</td></tr>
<tr><td><code id="nmxml_+3A_index">index</code></td>
<td>
<p>the estimation number to return;  &quot;last&quot; will return the
last estimation results; otherwise, pass an integer indicating which
estimation results to return.</p>
</td></tr>
<tr><td><code id="nmxml_+3A_xpath">xpath</code></td>
<td>
<p>xml path containing run results; if the default doesn't work,
consider using <code style="white-space: pre;">&#8288;.//estimation&#8288;</code> as an alternative; see details.</p>
</td></tr>
<tr><td><code id="nmxml_+3A_env">env</code></td>
<td>
<p>internal use only.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If <code>run</code> and <code>project</code> are supplied, the <code>.xml</code> file is
assumed to be located in <code>run.xml</code>, in directory <code>run</code>
off the <code>project</code> directory.  If <code>file</code> is supplied,
<code>run</code> and <code>project</code> arguments are ignored.
</p>
<p>This function requires that the xml2 package
be installed and loadable.  If <code>requireNamespace("xml2")</code>
fails, an error will be generated.
</p>
<p><code>nmxml</code> usually expects to find run results in the xpath called
<code style="white-space: pre;">&#8288;.//nm:estimation&#8288;</code>.  Occasionally, the run results are not stored in
this namespace but no namespaces are found in the xml file.  In this case,
the user can specify the xpath containing run results.  Consider trying
<code style="white-space: pre;">&#8288;.//estimation&#8288;</code> as an alternative if the default fails.
</p>


<h3>Value</h3>

<p>A list with theta, omega and sigma elements, depending on what was
requested.
</p>


<h3>See Also</h3>

<p>nmext
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
if(requireNamespace("xml2")) {
  proj &lt;- system.file("nonmem", package = "mrgsolve")
  mrgsolve:::nmxml(run = 1005, project = proj)
}
</code></pre>

<hr>
<h2 id='numeric2diag'>Create a diagonal numeric matrix from diagonal elements</h2><span id='topic+numeric2diag'></span>

<h3>Description</h3>

<p>Create a diagonal numeric matrix from diagonal elements
</p>


<h3>Usage</h3>

<pre><code class='language-R'>numeric2diag(x, context = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="numeric2diag_+3A_x">x</code></td>
<td>
<p>numeric data</p>
</td></tr>
<tr><td><code id="numeric2diag_+3A_context">context</code></td>
<td>
<p>used to generate column names</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a numeric diagonal matrix
</p>

<hr>
<h2 id='numericlist'>Methods for numericlist</h2><span id='topic+numericlist'></span><span id='topic+as.list+2Cnumericlist-method'></span><span id='topic+as.numeric+2Cnumericlist-method'></span><span id='topic+as.data.frame+2Cnumericlist-method'></span><span id='topic+length+2Cnumericlist-method'></span><span id='topic+names+2Cnumericlist-method'></span><span id='topic++24+2Cnumericlist-method'></span><span id='topic++5B+5B+2Cnumericlist-method'></span><span id='topic++5B+2Cnumericlist-method'></span>

<h3>Description</h3>

<p>These methods can be used to coerce <code>param</code> and 
<code>init</code> objects into common <code>R</code> data structures,
extract elements from <code>numericlist</code>s, or get attributes 
from <code>numericlist</code>s.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'numericlist'
as.list(x, ...)

## S4 method for signature 'numericlist'
as.numeric(x)

## S4 method for signature 'numericlist'
as.data.frame(x, row.names = NULL, optional = FALSE, ...)

## S4 method for signature 'numericlist'
length(x)

## S4 method for signature 'numericlist'
names(x)

## S4 method for signature 'numericlist'
x$name

## S4 method for signature 'numericlist'
x[[i, ..., exact = TRUE]]

## S4 method for signature 'numericlist'
x[i, j, ..., drop = TRUE]
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="numericlist_+3A_x">x</code></td>
<td>
<p>object</p>
</td></tr>
<tr><td><code id="numericlist_+3A_...">...</code></td>
<td>
<p>passed along to other methods</p>
</td></tr>
<tr><td><code id="numericlist_+3A_row.names">row.names</code></td>
<td>
<p>passed to <code><a href="base.html#topic+as.data.frame">as.data.frame</a></code></p>
</td></tr>
<tr><td><code id="numericlist_+3A_optional">optional</code></td>
<td>
<p>passed to <code><a href="base.html#topic+as.data.frame">as.data.frame</a></code></p>
</td></tr>
<tr><td><code id="numericlist_+3A_name">name</code></td>
<td>
<p>column to take</p>
</td></tr>
<tr><td><code id="numericlist_+3A_i">i</code></td>
<td>
<p>elements to keep</p>
</td></tr>
<tr><td><code id="numericlist_+3A_exact">exact</code></td>
<td>
<p>not used</p>
</td></tr>
<tr><td><code id="numericlist_+3A_j">j</code></td>
<td>
<p>not used</p>
</td></tr>
<tr><td><code id="numericlist_+3A_drop">drop</code></td>
<td>
<p>not used</p>
</td></tr>
</table>

<hr>
<h2 id='numericlist-class'>S4 class numeric list</h2><span id='topic+numericlist-class'></span>

<h3>Description</h3>

<p>S4 class numeric list
</p>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="numericlist-class_+3A_data">data</code></td>
<td>
<p>list of data</p>
</td></tr>
<tr><td><code id="numericlist-class_+3A_pattern">pattern</code></td>
<td>
<p>character of length 1 containing regular 
expression to be used as a filter when printing data to the 
console</p>
</td></tr>
</table>

<hr>
<h2 id='numerics_only'>Prepare data.frame for input to mrgsim()</h2><span id='topic+numerics_only'></span>

<h3>Description</h3>

<p>Prepare data.frame for input to mrgsim()
</p>


<h3>Usage</h3>

<pre><code class='language-R'>numerics_only(x, quiet = FALSE, convert_lgl = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="numerics_only_+3A_x">x</code></td>
<td>
<p>a input data set.</p>
</td></tr>
<tr><td><code id="numerics_only_+3A_quiet">quiet</code></td>
<td>
<p>logical indicating whether or not warnings
should be printed.</p>
</td></tr>
<tr><td><code id="numerics_only_+3A_convert_lgl">convert_lgl</code></td>
<td>
<p>if <code>TRUE</code>, convert logical
columns with <code><a href="base.html#topic+as.integer">as.integer()</a></code>.</p>
</td></tr>
</table>

<hr>
<h2 id='obsaug'>Augment observations in the simulated output</h2><span id='topic+obsaug'></span>

<h3>Description</h3>

<p>Augment observations in the simulated output
</p>


<h3>Usage</h3>

<pre><code class='language-R'>obsaug(x, value = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="obsaug_+3A_x">x</code></td>
<td>
<p>model object</p>
</td></tr>
<tr><td><code id="obsaug_+3A_value">value</code></td>
<td>
<p>the value for <code>obsaug</code></p>
</td></tr>
<tr><td><code id="obsaug_+3A_...">...</code></td>
<td>
<p>passed along
There is also a <code>obsaug</code> argument to <code><a href="#topic+mrgsim">mrgsim</a></code> that can 
be set to accomplish the same thing as a call to <code>obsaug</code> in 
the pipeline.</p>
</td></tr>
</table>

<hr>
<h2 id='obsonly'>Collect only observation records in the simulated output</h2><span id='topic+obsonly'></span>

<h3>Description</h3>

<p>Collect only observation records in the simulated output
</p>


<h3>Usage</h3>

<pre><code class='language-R'>obsonly(x, value = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="obsonly_+3A_x">x</code></td>
<td>
<p>model object.</p>
</td></tr>
<tr><td><code id="obsonly_+3A_value">value</code></td>
<td>
<p>use 'TRUE' to collect and return observation records only.</p>
</td></tr>
<tr><td><code id="obsonly_+3A_...">...</code></td>
<td>
<p>not used.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>There is also an 'obsonly' argument to [mrgsim()] that can 
be set to accomplish the same thing as a call to 'obsonly()' in 
the pipeline.
</p>

<hr>
<h2 id='omega'>Manipulate OMEGA matrices</h2><span id='topic+omega'></span><span id='topic+omat'></span><span id='topic+OMEGA'></span><span id='topic+omat+2Cmissing-method'></span><span id='topic+omat+2Cmatrix-method'></span><span id='topic+omat+2CNULL-method'></span><span id='topic+omat+2Clist-method'></span><span id='topic+omat+2Comegalist-method'></span><span id='topic+omat+2Cmrgmod-method'></span><span id='topic+omat+2Cmrgsims-method'></span>

<h3>Description</h3>

<p>The primary function is <code>omat()</code> that can be used to both get the
<code style="white-space: pre;">&#8288;$OMEGA&#8288;</code> matrices out of a model object and to update <code style="white-space: pre;">&#8288;$OMEGA&#8288;</code>
matrices in a model object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>omat(.x, ...)

## S4 method for signature 'missing'
omat(.x, ...)

## S4 method for signature 'matrix'
omat(.x, ..., labels = list())

## S4 method for signature 'NULL'
omat(.x, ...)

## S4 method for signature 'list'
omat(.x, ...)

## S4 method for signature 'omegalist'
omat(.x, ...)

## S4 method for signature 'mrgmod'
omat(.x, ..., make = FALSE, open = FALSE)

## S4 method for signature 'mrgsims'
omat(.x, make = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="omega_+3A_.x">.x</code></td>
<td>
<p>a matrix, list of matrices or <code>matlist</code> object.</p>
</td></tr>
<tr><td><code id="omega_+3A_...">...</code></td>
<td>
<p>passed to other functions, including <code><a href="#topic+modMATRIX">modMATRIX()</a></code>.</p>
</td></tr>
<tr><td><code id="omega_+3A_labels">labels</code></td>
<td>
<p>character vector of names for <code style="white-space: pre;">&#8288;$OMEGA&#8288;</code> elements; must
be equal to number of rows/columns in the matrix.</p>
</td></tr>
<tr><td><code id="omega_+3A_make">make</code></td>
<td>
<p>logical; if <code>TRUE</code>, matrix list is rendered into a single matrix.</p>
</td></tr>
<tr><td><code id="omega_+3A_open">open</code></td>
<td>
<p>passed to <code><a href="#topic+merge.list">merge.list()</a></code>.</p>
</td></tr>
<tr><td><code id="omega_+3A_x">x</code></td>
<td>
<p><code>matlist</code> object.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+smat">smat()</a></code>, <code><a href="#topic+dmat">dmat()</a></code>, <code><a href="#topic+bmat">bmat()</a></code>, <code><a href="#topic+cmat">cmat()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># example("omega")
mat1 &lt;- matrix(1)
mat2 &lt;- diag(c(1,2,3))
mat3 &lt;- matrix(c(0.1, 0.002, 0.002, 0.5), 2,2)
mat4 &lt;- dmat(0.1, 0.2, 0.3, 0.4)

omat(mat1)
omat(mat1, mat2, mat3)
omat(A = mat1, B = mat2, C = mat3)

mod &lt;- mrgsolve::house() %&gt;% omat(mat4)

omat(mod)
omat(mod, make = TRUE)
as.matrix(omat(mod))

</code></pre>

<hr>
<h2 id='outvars'>Show names of current output variables</h2><span id='topic+outvars'></span>

<h3>Description</h3>

<p>Outputs can include model compartments or variables defined in the model
that have been marked to <code>capture</code> in simulated output.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>outvars(x, unlist = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="outvars_+3A_x">x</code></td>
<td>
<p>model object.</p>
</td></tr>
<tr><td><code id="outvars_+3A_unlist">unlist</code></td>
<td>
<p>if <code>TRUE</code> then a character vector (rather than list) is
returned.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>When <code>unlist</code> is <code>FALSE</code> (default) : a named list, with <code>cmt</code> showing names
of output compartments and <code>capture</code> giving names of output variables in
capture.  When <code>unlist</code> is <code>TRUE</code>, then a single, unnamed character vector
of outvar names is returned.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>mod &lt;- mrgsolve::house()
outvars(mod)

</code></pre>

<hr>
<h2 id='param'>Create and work with parameter objects</h2><span id='topic+param'></span><span id='topic+param+2Cmrgmod-method'></span><span id='topic+param+2Cmrgsims-method'></span><span id='topic+param+2Cmissing-method'></span><span id='topic+param+2Clist-method'></span><span id='topic+param+2CANY-method'></span><span id='topic+allparam'></span>

<h3>Description</h3>

<p>See <a href="#topic+numericlist">numericlist</a> for methods to deal with <code>parameter_list</code> objects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>param(.x, ...)

## S4 method for signature 'mrgmod'
param(.x, .y = NULL, ..., .pat = "*", .strict = FALSE)

## S4 method for signature 'mrgsims'
param(.x, ...)

## S4 method for signature 'missing'
param(..., .strict = TRUE)

## S4 method for signature 'list'
param(.x, ...)

## S4 method for signature 'ANY'
param(.x, ...)

allparam(.x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="param_+3A_.x">.x</code></td>
<td>
<p>the model object.</p>
</td></tr>
<tr><td><code id="param_+3A_...">...</code></td>
<td>
<p>passed along or name/value pairs to update the parameters
in a model object; when passing new values this way, all values
must be numeric and all all names must exist in the parameter list
for <code>.x</code>.</p>
</td></tr>
<tr><td><code id="param_+3A_.y">.y</code></td>
<td>
<p>an object to be merged into parameter list; non-<code>NULL</code> values
must be named <code>list</code>, <code>data.frame</code>, <code>numeric</code> vector, or <code>parameter_list</code>
object; named items that do not exist in the parameter list are allowed and
will be silently ignored; use the <code>.strict</code> argument to require that all
names in <code>.y</code> exist already in the parameter list.</p>
</td></tr>
<tr><td><code id="param_+3A_.pat">.pat</code></td>
<td>
<p>a regular expression (character) to be applied as a filter
for which parameters to show when printing.</p>
</td></tr>
<tr><td><code id="param_+3A_.strict">.strict</code></td>
<td>
<p>if <code>TRUE</code>, all names to be updated must be found
in the parameter list.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Can be used to either get a parameter list object from a <code>mrgmod</code>
model object or to update the parameters in a model object.
For both uses, the return value is a <code>parameter_list</code> object. For the
former use, <code>param()</code> is usually called to print the parameters to the
screen, but the <code>parameter_list</code> object can also be coerced to a list
or numeric R object.
</p>
<p>Use <code>allparam()</code> to get a <code>parameter_list</code> object including
both model parameters and data items listed in <code style="white-space: pre;">&#8288;$FIXED&#8288;</code>.
</p>
<p>The update to parameters can be permissive (candidates with names that don't
exist in the parameter list are silently ignored) or strict (all candidates
must already exist in the parameter list). When passing candidate values
via <code>...</code>, the update is strict and an error is generated if you pass a
name that isn't found in the parameter list. When candidate values
are passed as a named object via <code>.y</code>, then the update is permissive. Any
permissive update can be made strict (error if foreign names are found in
the candidates) by passing <code>.strict = TRUE</code>.
</p>
<p>An alternative is to assess the incoming names using <code><a href="#topic+inventory">inventory()</a></code>.
</p>


<h3>Value</h3>

<p>An object of class <code>parameter_list</code> (see <a href="#topic+numericlist">numericlist</a>).
</p>


<h3>See Also</h3>

<p><code><a href="#topic+inventory">inventory()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## example("param")

mod &lt;- house()

param(mod)

param(mod, .pat="^(C|F)") ## may be useful when large number of parameters

class(param(mod))

param(mod)$KA

param(mod)[["KA"]]

as.list(param(mod))

as.data.frame(param(mod))

mod &lt;- param(mod, CL = 1.2)

new_values &lt;- list(CL = 1.3, VC = 20.5)

mod &lt;- param(mod, new_values)


</code></pre>

<hr>
<h2 id='param_tags'>Return parameter tags</h2><span id='topic+param_tags'></span>

<h3>Description</h3>

<p>Use this function if you added the <code style="white-space: pre;">&#8288;@covariates&#8288;</code> or <code style="white-space: pre;">&#8288;@input&#8288;</code> attributes or
specified a user-defined tag (via <code style="white-space: pre;">&#8288;@tag&#8288;</code>) in one or more parameter blocks
and need to extract that information. Also, using the <code style="white-space: pre;">&#8288;$INPUT&#8288;</code> block to
declare parameters will automatically add the <code>input</code> tag (via <code style="white-space: pre;">&#8288;@input&#8288;</code>).
Once these attributes / tags are added, you can use <code><a href="#topic+check_data_names">check_data_names()</a></code> to
reconcile names of input data sets against tagged model parameters.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>param_tags(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="param_tags_+3A_x">x</code></td>
<td>
<p>mrgsolve model object.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data frame listing parameter names and their tags.
</p>


<h3>Model specification</h3>

<p>Note: it is good practice to tag parameters where appropriate with <code>input</code>
or <code>covariates</code> as these will automatically be expected on input data when
you call <code><a href="#topic+check_data_names">check_data_names()</a></code>. User-defined tags are also possible, but you
will need to alert <code><a href="#topic+check_data_names">check_data_names()</a></code> to look for them.
</p>
<p><strong>Model Specification Examples</strong>
</p>
<p>You can use the <code style="white-space: pre;">&#8288;$INPUT&#8288;</code> block to add the <code>input</code> tag on these parameters
</p>
<div class="sourceCode"><pre>$INPUT 
STUDY = 101, WT = 70, DVID = 1
</pre></div>
<p>Tag some covariates in the model
</p>
<div class="sourceCode"><pre>$PARAM @covariates
WT = 70, SEX = 1, EGFR = 110
</pre></div>
<p>A user-defined tag
</p>
<div class="sourceCode"><pre>$PARAM @tag flags
FFLAG = 1, DFLAG = 0
</pre></div>


<h3>See Also</h3>

<p><code><a href="#topic+check_data_names">check_data_names()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>mod &lt;- mrgsolve::house()

param_tags(mod)

</code></pre>

<hr>
<h2 id='parameter_list-class'>S4 parameter_list class</h2><span id='topic+parameter_list-class'></span>

<h3>Description</h3>

<p>S4 parameter_list class
</p>

<hr>
<h2 id='PKMODEL'>Parse PKMODEL BLOCK data</h2><span id='topic+PKMODEL'></span>

<h3>Description</h3>

<p>Parse PKMODEL BLOCK data
</p>


<h3>Usage</h3>

<pre><code class='language-R'>PKMODEL(
  ncmt = 1,
  depot = FALSE,
  cmt = NULL,
  trans = pick_trans(ncmt, depot),
  env = list(),
  pos = 1,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="PKMODEL_+3A_ncmt">ncmt</code></td>
<td>
<p>number of compartments; must be 1 (one-compartment, 
not including a depot dosing compartment) or 2 (two-compartment model, 
not including a depot dosing compartment)</p>
</td></tr>
<tr><td><code id="PKMODEL_+3A_depot">depot</code></td>
<td>
<p>logical indicating whether to add depot compartment</p>
</td></tr>
<tr><td><code id="PKMODEL_+3A_cmt">cmt</code></td>
<td>
<p>compartment names as comma-delimited character</p>
</td></tr>
<tr><td><code id="PKMODEL_+3A_trans">trans</code></td>
<td>
<p>the parameterization for the PK model; must be 1, 2, 4, or 11</p>
</td></tr>
<tr><td><code id="PKMODEL_+3A_env">env</code></td>
<td>
<p>parse environment</p>
</td></tr>
<tr><td><code id="PKMODEL_+3A_pos">pos</code></td>
<td>
<p>block position number</p>
</td></tr>
<tr><td><code id="PKMODEL_+3A_...">...</code></td>
<td>
<p>not used</p>
</td></tr>
</table>


<h3>Details</h3>

<p>When using <code>$PKMODEL</code>, certain symbols must be defined in the 
model specification depending on the value of <code>ncmt</code>, <code>depot</code> 
and <code>trans</code>.
</p>

<ul>
<li> <p><code>ncmt</code> 1, <code>depot FALSE</code>, trans 2: <code>CL</code>, <code>V</code>
</p>
</li>
<li> <p><code>ncmt</code> 1, <code>depot TRUE</code> , trans 2: <code>CL</code>, <code>V</code>,  
<code>KA</code>
</p>
</li>
<li> <p><code>ncmt</code> 2, <code>depot FALSE</code>, trans 4: <code>CL</code>, <code>V1</code>, 
<code>Q</code>, <code>V2</code>
</p>
</li>
<li> <p><code>ncmt</code> 2, <code>depot TRUE</code> , trans 4: <code>CL</code>, <code>V2</code>, 
<code>Q</code>, <code>V3</code>, <code>KA</code>
</p>
</li></ul>

<p>If <code>trans=11</code> is specified, use the symbols listed above for the 
<code>ncmt</code> / <code>depot</code> combination, but append <code>i</code> at the end 
(e.g. <code>CLi</code> or <code>Qi</code> or <code>KAi</code>).
</p>
<p>If <code>trans=1</code>, the user must utilize the following symbols:
</p>

<ul>
<li> <p><code>pred_CL</code> for clearance
</p>
</li>
<li> <p><code>pred_V</code>  or <code>pred_V2</code> for central compartment volume of 
distribution
</p>
</li>
<li> <p><code>pred_Q</code>  for intercompartmental clearance
</p>
</li>
<li> <p><code>pred_V3</code> for for peripheral compartment volume of distribution
</p>
</li>
<li> <p><code>pred_KA</code> for absorption rate constant
</p>
</li></ul>



<h3>See Also</h3>

<p><code><a href="#topic+BLOCK_PARSE">BLOCK_PARSE</a></code>
</p>

<hr>
<h2 id='plot_mrgsims'>Generate a quick plot of simulated data</h2><span id='topic+plot_mrgsims'></span><span id='topic+plot+2Cmrgsims+2Cmissing-method'></span><span id='topic+plot+2Cmrgsims+2Cformula-method'></span><span id='topic+plot+2Cmrgsims+2Ccharacter-method'></span>

<h3>Description</h3>

<p>Generate a quick plot of simulated data
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'mrgsims,missing'
plot(x, limit = 16, ...)

## S4 method for signature 'mrgsims,formula'
plot(
  x,
  y,
  limit = 16,
  show.grid = TRUE,
  outer = TRUE,
  type = "l",
  lwd = 2,
  ylab = "value",
  groups = ID,
  scales = list(y = list(relation = "free")),
  logy = FALSE,
  logbr = 1,
  ...
)

## S4 method for signature 'mrgsims,character'
plot(x, y, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot_mrgsims_+3A_x">x</code></td>
<td>
<p>mrgsims object</p>
</td></tr>
<tr><td><code id="plot_mrgsims_+3A_limit">limit</code></td>
<td>
<p>limit the the number of panels to create</p>
</td></tr>
<tr><td><code id="plot_mrgsims_+3A_...">...</code></td>
<td>
<p>other arguments passed to xyplot</p>
</td></tr>
<tr><td><code id="plot_mrgsims_+3A_y">y</code></td>
<td>
<p>formula used for plotting</p>
</td></tr>
<tr><td><code id="plot_mrgsims_+3A_show.grid">show.grid</code></td>
<td>
<p>logical indicating whether or not to draw panel.grid</p>
</td></tr>
<tr><td><code id="plot_mrgsims_+3A_outer">outer</code></td>
<td>
<p>passed to xyplot</p>
</td></tr>
<tr><td><code id="plot_mrgsims_+3A_type">type</code></td>
<td>
<p>passed to xyplot</p>
</td></tr>
<tr><td><code id="plot_mrgsims_+3A_lwd">lwd</code></td>
<td>
<p>passed to xyplot</p>
</td></tr>
<tr><td><code id="plot_mrgsims_+3A_ylab">ylab</code></td>
<td>
<p>passed to xyplot</p>
</td></tr>
<tr><td><code id="plot_mrgsims_+3A_groups">groups</code></td>
<td>
<p>passed to xyplot</p>
</td></tr>
<tr><td><code id="plot_mrgsims_+3A_scales">scales</code></td>
<td>
<p>passed to xyplot</p>
</td></tr>
<tr><td><code id="plot_mrgsims_+3A_logy">logy</code></td>
<td>
<p>plot the y variables on log scale</p>
</td></tr>
<tr><td><code id="plot_mrgsims_+3A_logbr">logbr</code></td>
<td>
<p>log scale breaks indicator; use <code>1</code> for breaks every log
unit; use <code>3</code> for breaks every half log unit; use <code>0</code> for default
breaks</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>
mod &lt;- mrgsolve::house(end=48, delta=0.2) %&gt;% init(GUT=1000)

out &lt;- mrgsim(mod)

plot(out)

plot(out, subset=time &lt;=24)

plot(out, GUT+CP~.)

plot(out, CP+RESP~time, col="black", scales="same", lty=2)

## Not run: 
plot(out, "CP RESP, GUT")

## End(Not run)

</code></pre>

<hr>
<h2 id='plot_sims'>Plot data as an mrgsims object</h2><span id='topic+plot_sims'></span>

<h3>Description</h3>

<p>Plot data as an mrgsims object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot_sims(.data, ..., .f = NULL, .dots = list())
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot_sims_+3A_.data">.data</code></td>
<td>
<p>a data frame</p>
</td></tr>
<tr><td><code id="plot_sims_+3A_...">...</code></td>
<td>
<p>unquoted column names to plot on y-axis</p>
</td></tr>
<tr><td><code id="plot_sims_+3A_.f">.f</code></td>
<td>
<p>a formula to plot</p>
</td></tr>
<tr><td><code id="plot_sims_+3A_.dots">.dots</code></td>
<td>
<p>extra arguments passed to <code>lattice::xyplot</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is only intended for use with data frames that 
were created by modifying an <code>mrgsims</code> object.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
mod &lt;- mrgsolve::house() %&gt;% ev(amt = 100)

out &lt;- mrgsim(mod) 
out_df &lt;- dplyr::mutate(out, time &lt;= 72)

plot(out)
plot_sims(out, CP, RESP)

## Not run: 
plot_sims(out, .f = ~ CP + RESP)
plot_sims(out, .f = CP + RESP ~ time)

## End(Not run)

</code></pre>

<hr>
<h2 id='plot+2Cbatch_mrgsims+2Cmissing-method'>Plot method for mrgsims objects</h2><span id='topic+plot+2Cbatch_mrgsims+2Cmissing-method'></span><span id='topic+plot+2Cbatch_mrgsims+2Cformula-method'></span>

<h3>Description</h3>

<p>Plot method for mrgsims objects
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'batch_mrgsims,missing'
plot(x, yval = variables(x), auto.key = list(), mincol = 3, ...)

## S4 method for signature 'batch_mrgsims,formula'
plot(
  x,
  y,
  show.grid = TRUE,
  lwd = 2,
  type = "l",
  yval = variables(x),
  auto.key = list(columns = 1),
  scales = list(y = list(relation = "free")),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot+2B2Cbatch_mrgsims+2B2Cmissing-method_+3A_x">x</code></td>
<td>
<p>mrgsims object</p>
</td></tr>
<tr><td><code id="plot+2B2Cbatch_mrgsims+2B2Cmissing-method_+3A_yval">yval</code></td>
<td>
<p>y variables to plot</p>
</td></tr>
<tr><td><code id="plot+2B2Cbatch_mrgsims+2B2Cmissing-method_+3A_auto.key">auto.key</code></td>
<td>
<p>passed to xyplot</p>
</td></tr>
<tr><td><code id="plot+2B2Cbatch_mrgsims+2B2Cmissing-method_+3A_mincol">mincol</code></td>
<td>
<p>minimum number of columns in key</p>
</td></tr>
<tr><td><code id="plot+2B2Cbatch_mrgsims+2B2Cmissing-method_+3A_...">...</code></td>
<td>
<p>arguments passed to xyplot</p>
</td></tr>
<tr><td><code id="plot+2B2Cbatch_mrgsims+2B2Cmissing-method_+3A_y">y</code></td>
<td>
<p>a formula passed to xyplot</p>
</td></tr>
<tr><td><code id="plot+2B2Cbatch_mrgsims+2B2Cmissing-method_+3A_show.grid">show.grid</code></td>
<td>
<p>print grid in the plot</p>
</td></tr>
<tr><td><code id="plot+2B2Cbatch_mrgsims+2B2Cmissing-method_+3A_lwd">lwd</code></td>
<td>
<p>passed to xyplot</p>
</td></tr>
<tr><td><code id="plot+2B2Cbatch_mrgsims+2B2Cmissing-method_+3A_type">type</code></td>
<td>
<p>passed to xyplot</p>
</td></tr>
<tr><td><code id="plot+2B2Cbatch_mrgsims+2B2Cmissing-method_+3A_scales">scales</code></td>
<td>
<p>passed to xyplot</p>
</td></tr>
</table>

<hr>
<h2 id='qsim'>Basic, simple simulation from model object</h2><span id='topic+qsim'></span>

<h3>Description</h3>

<p>This is just a lighter version of <code><a href="#topic+mrgsim">mrgsim()</a></code>, with fewer options but with
better efficiency in certain cases.  See <strong>Details</strong>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>qsim(
  x,
  data,
  idata = no_idata_set(),
  obsonly = FALSE,
  tgrid = NULL,
  recsort = 1,
  tad = FALSE,
  Req = NULL,
  outvars = Req,
  skip_init_calc = FALSE,
  output = "mrgsims"
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="qsim_+3A_x">x</code></td>
<td>
<p>the model object.</p>
</td></tr>
<tr><td><code id="qsim_+3A_data">data</code></td>
<td>
<p>can be either event object or data set.</p>
</td></tr>
<tr><td><code id="qsim_+3A_idata">idata</code></td>
<td>
<p>a matrix or data frame of model parameters,
one parameter per row (see <code><a href="#topic+idata_set">idata_set()</a></code>).</p>
</td></tr>
<tr><td><code id="qsim_+3A_obsonly">obsonly</code></td>
<td>
<p>if <code>TRUE</code>, dosing records are not included
in the output.</p>
</td></tr>
<tr><td><code id="qsim_+3A_tgrid">tgrid</code></td>
<td>
<p>a tgrid object; or a numeric vector of simulation times
or another object with an <code>stime</code> method.</p>
</td></tr>
<tr><td><code id="qsim_+3A_recsort">recsort</code></td>
<td>
<p>record sorting flag.  Default value is 1.  Possible values
are 1,2,3,4: 1 and 2 put doses in a data set after padded observations at
the same time; 3 and 4 put those doses before padded observations at the
same time.  2 and 4 will put doses scheduled through <code>addl</code> after
observations at the same time; 1 and 3 put doses scheduled through
<code>addl</code> before observations at the same time. <code>recsort</code> will
not change the order of your input data set if both doses and observations
are given.</p>
</td></tr>
<tr><td><code id="qsim_+3A_tad">tad</code></td>
<td>
<p>when <code>TRUE</code> a column is added to simulated
output is added showing the time since the last dose.  Only data records
with <code>evid == 1</code> will be considered doses for the purposes of <code>tad</code>
calculation. The <code>tad</code> can be properly calculated with a dosing lag time in
the model as long as the dosing lag time (specified in <code style="white-space: pre;">&#8288;$MAIN&#8288;</code>)  is always
appropriate for any subsequent doses scheduled through <code>addl</code>.  This will
always be true if the lag time doesn't change over time.  But it might
(possibly) not hold if the lag time changes prior to the last dose in the
<code>addl</code> sequence.  This known limitation shouldn't affect <code>tad</code> calculation
in most common dosing lag time implementations.</p>
</td></tr>
<tr><td><code id="qsim_+3A_req">Req</code></td>
<td>
<p>synonym for <code>outvars</code>.</p>
</td></tr>
<tr><td><code id="qsim_+3A_outvars">outvars</code></td>
<td>
<p>output items to request; if missing, then only captured items
will be returned in the output.</p>
</td></tr>
<tr><td><code id="qsim_+3A_skip_init_calc">skip_init_calc</code></td>
<td>
<p>don't use <code style="white-space: pre;">&#8288;$MAIN&#8288;</code> to calculate initial conditions.</p>
</td></tr>
<tr><td><code id="qsim_+3A_output">output</code></td>
<td>
<p>output data type; the default is <code>mrgsims</code>, which returns the
default output object; other options include <code>df</code> (for data.frame) or
<code>matrix</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>qsim()</code> mainly cuts some of the overhead from the simulation. So, the
primary efficiency gain from using <code>qsim()</code> comes when the simulation
executes very quickly. It is unlikely you will see a big performance
difference between <code>qsim()</code> and <code><a href="#topic+mrgsim">mrgsim()</a></code> when the model is difficult to
solve or if there is a large input data set.
</p>
<p>There is no pipeline interface for this function; all configuration options
(see <strong>Arguments</strong>) must be passed as formal arguments to the function.
You can't <code>carry_out</code>, <code>Request</code> specific columns, or pass items in for update.
Some other limitations, but only convenience-related.  See <strong>Arguments</strong> for
available options.  Specifically, there is no <code>...</code> argument for this function.
Use the <code><a href="#topic+update">update()</a></code> method to update the model object.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+mrgsim_q">mrgsim_q()</a></code>, <code><a href="#topic+mrgsim">mrgsim()</a></code>, <a href="#topic+mrgsim_variants">mrgsim_variants</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
mod &lt;- mrgsolve::house()

dose &lt;- ev(amt = 100)

out &lt;- qsim(mod,dose)

</code></pre>

<hr>
<h2 id='read_nmext'>Extract estimates from NONMEM ext file</h2><span id='topic+read_nmext'></span>

<h3>Description</h3>

<p>This function retrieves NONMEM estimates for use in the mrgsolve model when
<code style="white-space: pre;">&#8288;$NMEXT&#8288;</code> is invoked. See <code><a href="#topic+nmext">nmext()</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>read_nmext(
  run = NA_real_,
  project = getwd(),
  file = paste0(run, ".ext"),
  path = NULL,
  read_fun = c("data.table", "read.table"),
  index = "last"
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="read_nmext_+3A_run">run</code></td>
<td>
<p>a run number or run identifier.</p>
</td></tr>
<tr><td><code id="read_nmext_+3A_project">project</code></td>
<td>
<p>the NONMEM project directory.</p>
</td></tr>
<tr><td><code id="read_nmext_+3A_file">file</code></td>
<td>
<p>the <code>ext</code> file name.</p>
</td></tr>
<tr><td><code id="read_nmext_+3A_path">path</code></td>
<td>
<p>full path and file name for <code>ext</code> file.</p>
</td></tr>
<tr><td><code id="read_nmext_+3A_read_fun">read_fun</code></td>
<td>
<p>function to read the <code>ext</code> file; <code><a href="data.table.html#topic+fread">data.table::fread()</a></code> will
be used if available; otherwise <code><a href="utils.html#topic+read.table">utils::read.table()</a></code> is used.</p>
</td></tr>
<tr><td><code id="read_nmext_+3A_index">index</code></td>
<td>
<p>selects the table number whose results will be returned;
use value &quot;last&quot; to select the last table in the <code>.ext</code> file; or pass an
integer specifying the table number; in case there is exactly
one table in the <code>.ext</code> file, pass the value &quot;single&quot; to bypass parsing
the file to look for sub tables (this might be useful when BAYES analysis
was performed as the only estimation method and there are 10000s of
posterior samples in the file).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with param, omega, and sigma in a format ready to be used to
update a model object.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>project &lt;- system.file("nonmem", package = "mrgsolve")

est &lt;- read_nmext(1005, project = project)

est$param

est$omega

est$sigma

est &lt;- read_nmext(2005, project = project, index = 3)

</code></pre>

<hr>
<h2 id='realize_addl'>Make addl doses explicit in an event object or data set</h2><span id='topic+realize_addl'></span><span id='topic+realize_addl.data.frame'></span><span id='topic+realize_addl.ev'></span>

<h3>Description</h3>

<p>When doses are scheduled with <code>ii</code> and <code>addl</code>, the object is expanded to
include one record for every dose. In the result, no record with have
<code>ii</code> or <code>addl</code> set to non-zero value.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>realize_addl(x, ...)

## S3 method for class 'data.frame'
realize_addl(
  x,
  warn = FALSE,
  mark_new = FALSE,
  fill = c("inherit", "na", "locf"),
  ...
)

## S3 method for class 'ev'
realize_addl(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="realize_addl_+3A_x">x</code></td>
<td>
<p>a <code>data_set</code> data frame or an event object (see <strong>Details</strong>).</p>
</td></tr>
<tr><td><code id="realize_addl_+3A_...">...</code></td>
<td>
<p>not used.</p>
</td></tr>
<tr><td><code id="realize_addl_+3A_warn">warn</code></td>
<td>
<p>if <code>TRUE</code> a warning is issued if no <code>ADDL</code> or
<code>addl</code> column is found.</p>
</td></tr>
<tr><td><code id="realize_addl_+3A_mark_new">mark_new</code></td>
<td>
<p>if <code>TRUE</code>, a flag is added to indicate new columns.</p>
</td></tr>
<tr><td><code id="realize_addl_+3A_fill">fill</code></td>
<td>
<p>specifies how to handle non-dose related data columns
in new data set records; this option is critical when handling
data sets with time-varying, non-dose-related data items; see <strong>Details</strong>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If no <code>addl</code> column is found the data frame is returned and
a warning is issued if <code>warn</code> is true. If <code>ii</code>,
<code>time</code>, or <code>evid</code> are missing, an error is generated.
</p>
<p>If a grouped data.frame (via <code><a href="dplyr.html#topic+group_by">dplyr::group_by()</a></code>) is passed, it will be
ungrouped.
</p>
<p>Use caution when passing in data that has non-dose-related data
columns that vary within a subject and pay special attention
to the <code>fill</code> argument. By definition, <code>realize_addl()</code>
will add new rows to your data frame and it is not obvious
how the non-dose-related data should be handled in these new
rows.  When <code>inherit</code> is chosen, the new records have
non-dose-related data that is identical to the originating
dose record. This should be fine when these data items are not
varying with time, but will present a problem when the data
are varying with time.  When <code>locf</code> is chosen,
the missing data are filled in with <code>NA</code> and an
last observation carry forward operation is applied to
<strong>every</strong> column in the data set.  This may not be what
you want if you already had missing values in the input
data set and want to preserve that missingness. When <code>na</code>
is chosen, the missing data are filled in with <code>NA</code> and
no <code>locf</code> operation is applied.  But note that these
missing values may be problematic for a mrgsolve simulation
run. If you have any time-varying columns or missing data
in your data set, be sure to check that the output from
this function is what you were expecting.
</p>


<h3>Value</h3>

<p>A data.frame or event object, consistent with the type of <code>x</code>.
The <code>ii</code> and <code>addl</code> columns will all be set to zero. The result is always
ungrouped.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>e &lt;- ev(amt = 100, ii = 12, addl = 3)

realize_addl(e)

a &lt;- ev(amt = 100, ii = 12, addl = 2, WT = 69)
b &lt;- ev(amt = 200, ii = 24, addl = 2, WT = 70)
c &lt;- ev(amt =  50, ii =  6, addl = 2, WT = 71) 

e &lt;- ev_seq(a,b,c)
realize_addl(e, mark_new = TRUE)

</code></pre>

<hr>
<h2 id='reexports'>Objects exported from other packages</h2><span id='topic+reexports'></span><span id='topic+filter'></span>

<h3>Description</h3>

<p>These objects are imported from other packages. Follow the links
below to see their documentation.
</p>

<dl>
<dt>dplyr</dt><dd><p><code><a href="dplyr.html#topic+filter">filter</a></code></p>
</dd>
</dl>

<hr>
<h2 id='render'>Render a model to a document</h2><span id='topic+render'></span><span id='topic+render+2Ccharacter-method'></span><span id='topic+render+2Cmrgmod-method'></span><span id='topic+dorender'></span>

<h3>Description</h3>

<p>Render a model to a document
</p>


<h3>Usage</h3>

<pre><code class='language-R'>render(x, ...)

## S4 method for signature 'character'
render(x, project = NULL, ...)

## S4 method for signature 'mrgmod'
render(x, ...)

dorender(model, project, template = NULL, compile = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="render_+3A_x">x</code></td>
<td>
<p>model object or the model name</p>
</td></tr>
<tr><td><code id="render_+3A_...">...</code></td>
<td>
<p>passed to <code>rmarkdown::render</code></p>
</td></tr>
<tr><td><code id="render_+3A_project">project</code></td>
<td>
<p>the directory containing the <code>.cpp</code> model file</p>
</td></tr>
<tr><td><code id="render_+3A_model">model</code></td>
<td>
<p>model name</p>
</td></tr>
<tr><td><code id="render_+3A_template">template</code></td>
<td>
<p>template document</p>
</td></tr>
<tr><td><code id="render_+3A_compile">compile</code></td>
<td>
<p>logical; if true, the model will be compiled to run</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
mod &lt;- mrgsolve::house()
mrgsolve:::render(mod)
mrgsolve:::render("irm2", modlib())

## End(Not run)

</code></pre>

<hr>
<h2 id='Req'>Request simulated output</h2><span id='topic+Req'></span><span id='topic+req'></span><span id='topic+req.mrgmod'></span>

<h3>Description</h3>

<p>Use this function to select, by name, either compartments or derived
variables that have been captured (see <a href="#topic+CAPTURE">CAPTURE</a>) into
the simulated output.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Req(x, ...)

req(x, ...)

## S3 method for class 'mrgmod'
req(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="Req_+3A_x">x</code></td>
<td>
<p>model object.</p>
</td></tr>
<tr><td><code id="Req_+3A_...">...</code></td>
<td>
<p>unquoted names of compartments or tabled items.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>There is also a <code>Req</code> argument to <code><a href="#topic+mrgsim">mrgsim()</a></code> that can
be set to accomplish the same thing as a call to <code>Req</code> in
the pipeline.
</p>
<p>Note the difference between <code>req</code> and <code>Req</code>: the former only
selects compartments to appear in output while the latter selects both
compartments and captured items.  Also, when there are items explicitly
listed in <code>Req</code>, all other compartments or captured items not listed
there are ignored.  But when compartments are selected with <code>req</code>
all of the captured items are returned.  Remember that <code>req</code> is
strictly for compartments.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>mod &lt;- mrgsolve::house()

mod %&gt;% Req(CP,RESP) %&gt;% ev(amt=1000) %&gt;%  mrgsim()

</code></pre>

<hr>
<h2 id='reserved'>Reserved words</h2><span id='topic+reserved'></span>

<h3>Description</h3>

<p>Reserved words
</p>


<h3>Usage</h3>

<pre><code class='language-R'>reserved()
</code></pre>


<h3>Details</h3>

<p>Note: this function is not exported; you must go into the 
<code>mrgsolve</code> namespace by using the <code>mrgsolve:::</code> prefix.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>mrgsolve:::reserved()

</code></pre>

<hr>
<h2 id='revar'>Get model random effect variances and covariances</h2><span id='topic+revar'></span><span id='topic+revar+2Cmrgmod-method'></span>

<h3>Description</h3>

<p>Use this function to extract both OMEGA and SIGMA matrices from a
model object. Typical use is for display on the R console.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>revar(x, ...)

## S4 method for signature 'mrgmod'
revar(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="revar_+3A_x">x</code></td>
<td>
<p>model object.</p>
</td></tr>
<tr><td><code id="revar_+3A_...">...</code></td>
<td>
<p>passed along.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A named list containing <code>omega</code> and <code>sigma</code> matrices.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>mod &lt;- mrgsolve::house()
revar(mod)

</code></pre>

<hr>
<h2 id='scrape_and_call'>Scrape options and pass to function</h2><span id='topic+scrape_and_call'></span>

<h3>Description</h3>

<p>Scrape options and pass to function
</p>


<h3>Usage</h3>

<pre><code class='language-R'>scrape_and_call(x, env, pass, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="scrape_and_call_+3A_x">x</code></td>
<td>
<p>data</p>
</td></tr>
<tr><td><code id="scrape_and_call_+3A_env">env</code></td>
<td>
<p>parse environment</p>
</td></tr>
<tr><td><code id="scrape_and_call_+3A_pass">pass</code></td>
<td>
<p>function to call</p>
</td></tr>
<tr><td><code id="scrape_and_call_+3A_...">...</code></td>
<td>
<p>arguments passed to <code><a href="#topic+scrape_opts">scrape_opts</a></code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>Attributes of <code>x</code> are also scraped and merged with options.
</p>

<hr>
<h2 id='scrape_opts'>Scrape options from a code block</h2><span id='topic+scrape_opts'></span>

<h3>Description</h3>

<p>Scrape options from a code block
</p>


<h3>Usage</h3>

<pre><code class='language-R'>scrape_opts(
  x,
  envir = list(),
  def = list(),
  all = TRUE,
  marker = "=",
  allow_multiple = FALSE,
  narrow = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="scrape_opts_+3A_x">x</code></td>
<td>
<p>data</p>
</td></tr>
<tr><td><code id="scrape_opts_+3A_envir">envir</code></td>
<td>
<p>environment from <code>$ENV</code></p>
</td></tr>
<tr><td><code id="scrape_opts_+3A_def">def</code></td>
<td>
<p>default values</p>
</td></tr>
<tr><td><code id="scrape_opts_+3A_all">all</code></td>
<td>
<p>return all options, even those that are not in <code>def</code></p>
</td></tr>
<tr><td><code id="scrape_opts_+3A_marker">marker</code></td>
<td>
<p>assignment operator; used to locate lines with options</p>
</td></tr>
<tr><td><code id="scrape_opts_+3A_allow_multiple">allow_multiple</code></td>
<td>
<p>if <code>TRUE</code>, the list with replicate names
will be reduced</p>
</td></tr>
<tr><td><code id="scrape_opts_+3A_narrow">narrow</code></td>
<td>
<p>logical; if <code>TRUE</code>, only get options on lines starting 
with <code>&gt;&gt;</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>list with elements <code>x</code> (the data without options) and named 
options  as specified in the block.
</p>

<hr>
<h2 id='see'>Print model code to the console</h2><span id='topic+see'></span><span id='topic+see+2Cmrgmod-method'></span>

<h3>Description</h3>

<p>This is a simple way to display the model code on the R console using
the model object. The <code>raw</code> argument will return the model code as a
character vector.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>see(x, ...)

## S4 method for signature 'mrgmod'
see(x, raw = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="see_+3A_x">x</code></td>
<td>
<p>model object.</p>
</td></tr>
<tr><td><code id="see_+3A_...">...</code></td>
<td>
<p>not used.</p>
</td></tr>
<tr><td><code id="see_+3A_raw">raw</code></td>
<td>
<p>return the raw code.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>NULL</code> is returned invisibly when <code>raw</code> is <code>FALSE</code>; when <code>raw</code> is
set to <code>TRUE</code>, the model code is returned as a character vector.
</p>

<hr>
<h2 id='show+2Ccmt_list-method'>Show the compartment list</h2><span id='topic+show+2Ccmt_list-method'></span>

<h3>Description</h3>

<p>Show the compartment list
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'cmt_list'
show(object)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="show+2B2Ccmt_list-method_+3A_object">object</code></td>
<td>
<p>the object to show</p>
</td></tr>
</table>

<hr>
<h2 id='show+2Cmrgmod-method'>Print model details</h2><span id='topic+show+2Cmrgmod-method'></span>

<h3>Description</h3>

<p>Print model details
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'mrgmod'
show(object)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="show+2B2Cmrgmod-method_+3A_object">object</code></td>
<td>
<p>the model object</p>
</td></tr>
</table>

<hr>
<h2 id='show+2Cparameter_list-method'>Show the parameter list</h2><span id='topic+show+2Cparameter_list-method'></span>

<h3>Description</h3>

<p>Show the parameter list
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'parameter_list'
show(object)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="show+2B2Cparameter_list-method_+3A_object">object</code></td>
<td>
<p>the object to show</p>
</td></tr>
</table>

<hr>
<h2 id='sigma'>Manipulate SIGMA matrices</h2><span id='topic+sigma'></span><span id='topic+smat'></span><span id='topic+SIGMA'></span><span id='topic+smat+2Cmissing-method'></span><span id='topic+smat+2Cmatrix-method'></span><span id='topic+smat+2Clist-method'></span><span id='topic+smat+2Csigmalist-method'></span><span id='topic+smat+2Cmrgmod-method'></span><span id='topic+smat+2CNULL-method'></span><span id='topic+smat+2Cmrgsims-method'></span>

<h3>Description</h3>

<p>The primary function is <code>smat()</code> which can be used to both get the
<code style="white-space: pre;">&#8288;$SIGMA&#8288;</code> matrices out of a model object and to update <code style="white-space: pre;">&#8288;$SIGMA&#8288;</code>
matrices in a model object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>smat(.x, ...)

## S4 method for signature 'missing'
smat(.x, ...)

## S4 method for signature 'matrix'
smat(.x, ..., labels = list())

## S4 method for signature 'list'
smat(.x, ...)

## S4 method for signature 'sigmalist'
smat(.x, ...)

## S4 method for signature 'mrgmod'
smat(.x, ..., make = FALSE, open = FALSE)

## S4 method for signature 'NULL'
smat(.x, ...)

## S4 method for signature 'mrgsims'
smat(.x, make = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="sigma_+3A_.x">.x</code></td>
<td>
<p>a matrix, list of matrices or <code>matlist</code> object.</p>
</td></tr>
<tr><td><code id="sigma_+3A_...">...</code></td>
<td>
<p>passed to other functions, including <code><a href="#topic+modMATRIX">modMATRIX()</a></code>.</p>
</td></tr>
<tr><td><code id="sigma_+3A_labels">labels</code></td>
<td>
<p>character vector of names for <code style="white-space: pre;">&#8288;$SIGMA&#8288;</code> elements; must be
equal to number of rows/columns in the matrix.</p>
</td></tr>
<tr><td><code id="sigma_+3A_make">make</code></td>
<td>
<p>logical; if <code>TRUE</code>, matrix list is rendered into a single matrix.</p>
</td></tr>
<tr><td><code id="sigma_+3A_open">open</code></td>
<td>
<p>passed to <code><a href="#topic+merge.list">merge.list()</a></code>.</p>
</td></tr>
<tr><td><code id="sigma_+3A_x">x</code></td>
<td>
<p><code>matlist</code> object.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+dmat">dmat()</a></code>, <code><a href="#topic+bmat">bmat()</a></code>, <code><a href="#topic+cmat">cmat()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## example("sigma")
mat1 &lt;- matrix(1)
mat2 &lt;- diag(c(1,2))
mat3 &lt;- matrix(c(0.1, 0.002, 0.002, 0.5), 2,2)
mat4 &lt;- dmat(0.1, 0.2, 0.3, 0.4)

smat(mat1)
smat(mat1, mat2, mat3)
smat(A=mat1, B=mat2, C=mat3)

mod &lt;- mrgsolve::house() %&gt;% smat(mat1)

smat(mod)
smat(mod, make=TRUE)

</code></pre>

<hr>
<h2 id='simargs'>Access or clear arguments for calls to mrgsim()</h2><span id='topic+simargs'></span>

<h3>Description</h3>

<p>As a model object navigates a pipeline prior to simulation, arguments are
collected to eventually be passed to <code><a href="#topic+mrgsim">mrgsim()</a></code>. <code>simargs()</code> lets you
intercept and possibly clear those arguments.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>simargs(x, which = NULL, clear = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="simargs_+3A_x">x</code></td>
<td>
<p>model object.</p>
</td></tr>
<tr><td><code id="simargs_+3A_which">which</code></td>
<td>
<p>character with length 1 naming a single arg to get.</p>
</td></tr>
<tr><td><code id="simargs_+3A_clear">clear</code></td>
<td>
<p>logical indicating whether or not to clear <code>args</code> from
the model object.</p>
</td></tr>
<tr><td><code id="simargs_+3A_...">...</code></td>
<td>
<p>not used.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>If <code>clear</code> is <code>TRUE</code>, the argument list is
cleared and the model object is returned.  Otherwise, the argument
list is returned.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>mod &lt;- mrgsolve::house()
mod %&gt;% Req(CP, RESP) %&gt;% carry_out(evid, WT, FLAG) %&gt;% simargs()

</code></pre>

<hr>
<h2 id='soloc'>Return the location of the model shared object</h2><span id='topic+soloc'></span>

<h3>Description</h3>

<p>This is also the directory where the model is built, which could be the
value of <code><a href="base.html#topic+tempdir">tempdir()</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>soloc(x, short = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="soloc_+3A_x">x</code></td>
<td>
<p>model object.</p>
</td></tr>
<tr><td><code id="soloc_+3A_short">short</code></td>
<td>
<p>logical; if <code>TRUE</code>, <code>soloc</code>s will be rendered  with a short
path name.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A string containing the full path to the model shared object.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>mod &lt;- mrgsolve::house()
soloc(mod)

</code></pre>

<hr>
<h2 id='solversettings'>Optional inputs for lsoda</h2><span id='topic+solversettings'></span>

<h3>Description</h3>

<p>These are settings for the differential equation 
solver (<code>lsoda</code>) that can be accessed via
the R interface.  The code listing below is taken directly
from the <code>lsoda</code> source code.
</p>


<h3>Details</h3>

<p>The following items can be set
</p>

<ul>
<li> <p><code>hmax</code> (<code>HMAX</code> below); decrease <code>hmax</code> when 
you want to limit how big of a step the solver can take when 
integrating from one time to the next time. However be aware
that smaller <code>hmax</code> will result in longer run times.
</p>
</li>
<li> <p><code>hmin</code> (<code>HMIN</code> below); don't fiddle with this
unless you know what you're doing.  
</p>
</li>
<li> <p><code>ixpr</code> (<code>IXPR</code> below)
</p>
</li>
<li> <p><code>maxsteps</code> (<code>MXSTEP</code> below); increase this 
number when the solver has a long interval between 
two integration times (e.g. when observation records are 
far apart). 
</p>
</li>
<li> <p><code>mxhnil</code> (<code>MXHNIL below</code>); don't usually 
modify this one
</p>
</li>
<li> <p><code>atol</code> - the absolute solver tolerance; decrease
this number (e.g. to 1E-10 or 1E-20 or 1E-50) when the 
value in a compartment can get extremely small; without this 
extra (lower) tolerance, the value can get so low that the number
can randomly become negative.  However be aware that more precision
here will result in longer run times. 
</p>
</li>
<li> <p><code>rtol</code> - the relative solver tolerances; decrease this 
number when you want a more precise solution.  However be aware 
that more precision here will result in longer run times.
</p>
</li></ul>



<h3>See Also</h3>

<p><code><a href="#topic+aboutsolver">aboutsolver</a></code>, <code><a href="#topic+update">update</a></code>
</p>

<hr>
<h2 id='stime'>Get the times at which the model will be evaluated</h2><span id='topic+stime'></span><span id='topic+tgrid-class'></span><span id='topic+tgrids-class'></span>

<h3>Description</h3>

<p>Get the times at which the model will be evaluated
</p>


<h3>Usage</h3>

<pre><code class='language-R'>stime(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="stime_+3A_x">x</code></td>
<td>
<p>a model object or a mrgsims object.</p>
</td></tr>
<tr><td><code id="stime_+3A_...">...</code></td>
<td>
<p>not used.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Simulation times include the sequence of times created from
<code>start</code>, <code>end</code>, and <code>delta</code> and the vector of times found in <code>add</code>.
</p>
<p>Making <code>end</code> negative (e.g. -1) will omit the <code>start-end-delta</code>
sequence.  Negative values are discarded from the result.
</p>


<h3>Value</h3>

<p>A sorted vector of unique simulation times from the time grid in
the model object.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## example("stime", package="mrgsolve")

mod &lt;- mrgsolve::house(end = 12, delta = 2, add = c(11,13,15))

stime(mod)

update(mod, end = -1) %&gt;% stime()

</code></pre>

<hr>
<h2 id='summary.mrgmod'>Print summary of a mrgmod object</h2><span id='topic+summary.mrgmod'></span>

<h3>Description</h3>

<p>Print summary of a mrgmod object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'mrgmod'
summary(object, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="summary.mrgmod_+3A_object">object</code></td>
<td>
<p>a mrgmod object</p>
</td></tr>
<tr><td><code id="summary.mrgmod_+3A_...">...</code></td>
<td>
<p>not used</p>
</td></tr>
</table>

<hr>
<h2 id='tgrid'>Create a simtime object</h2><span id='topic+tgrid'></span><span id='topic+stime+2Ctgrid-method'></span><span id='topic+stime+2Ctgrids-method'></span><span id='topic+stime+2Cnumeric-method'></span><span id='topic+show+2Ctgrid-method'></span><span id='topic+show+2Ctgrids-method'></span><span id='topic+stime+2Cmrgmod-method'></span>

<h3>Description</h3>

<p>simtime objects allow the user to specify simulation start and end times,
along with the simulation time step.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tgrid(
  start = 0,
  end = 24,
  delta = 1,
  add = numeric(0),
  .offset = 0,
  .scale = 1,
  ...
)

## S4 method for signature 'tgrid'
stime(x, ...)

## S4 method for signature 'tgrids'
stime(x, ...)

## S4 method for signature 'numeric'
stime(x, ...)

## S4 method for signature 'tgrid'
show(object)

## S4 method for signature 'tgrids'
show(object)

## S4 method for signature 'mrgmod'
stime(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="tgrid_+3A_start">start</code></td>
<td>
<p>simulation start time.</p>
</td></tr>
<tr><td><code id="tgrid_+3A_end">end</code></td>
<td>
<p>simulation end time.</p>
</td></tr>
<tr><td><code id="tgrid_+3A_delta">delta</code></td>
<td>
<p>simulation time step.</p>
</td></tr>
<tr><td><code id="tgrid_+3A_add">add</code></td>
<td>
<p>addition simulation times.</p>
</td></tr>
<tr><td><code id="tgrid_+3A_.offset">.offset</code></td>
<td>
<p>the resulting set of times will be adjusted by this amount.</p>
</td></tr>
<tr><td><code id="tgrid_+3A_.scale">.scale</code></td>
<td>
<p>the resulting set of times will be scaled by this factor.</p>
</td></tr>
<tr><td><code id="tgrid_+3A_...">...</code></td>
<td>
<p>not used.</p>
</td></tr>
<tr><td><code id="tgrid_+3A_x">x</code></td>
<td>
<p>tgrid object.</p>
</td></tr>
<tr><td><code id="tgrid_+3A_object">object</code></td>
<td>
<p>passed to show</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>peak &lt;- tgrid(0, 6, 0.2)
sparse &lt;- tgrid(0, 24, 4)

day1 &lt;- c(peak, sparse)

design &lt;- c(day1, day1+72, day1+240)

## Not run: 
mod &lt;- mrgsolve::house()

out &lt;- mod %&gt;% ev(amt=1000, ii=24, addl=10) %&gt;% mrgsim(tgrid=design)

plot(out, CP ~ time, type = 'b')

## End(Not run)
</code></pre>

<hr>
<h2 id='touch_funs'>Get inits from compiled function</h2><span id='topic+touch_funs'></span>

<h3>Description</h3>

<p>This function is usually for internal use.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>touch_funs(x, keep_pointers = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="touch_funs_+3A_x">x</code></td>
<td>
<p>mrgmod model object</p>
</td></tr>
<tr><td><code id="touch_funs_+3A_keep_pointers">keep_pointers</code></td>
<td>
<p>should function pointers be returned?</p>
</td></tr>
</table>

<hr>
<h2 id='tscale'>Re-scale time in the simulated output</h2><span id='topic+tscale'></span>

<h3>Description</h3>

<p>Re-scale time in the simulated output
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tscale(x, value = 1, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="tscale_+3A_x">x</code></td>
<td>
<p>model object.</p>
</td></tr>
<tr><td><code id="tscale_+3A_value">value</code></td>
<td>
<p>value by which time will be scaled.</p>
</td></tr>
<tr><td><code id="tscale_+3A_...">...</code></td>
<td>
<p>not used.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>There is also a <code>tscale</code> argument to <code><a href="#topic+mrgsim">mrgsim()</a></code> that can
be set to accomplish the same thing as a call to <code>tscale</code> in
the pipeline.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># The model is in hours:
mod &lt;- mrgsolve::house()

# The output is in days:
mod %&gt;% tscale(1/24) %&gt;% mrgsim()

</code></pre>

<hr>
<h2 id='update'>Update the model object</h2><span id='topic+update'></span><span id='topic+update+2Cmrgmod-method'></span><span id='topic+update+2Comegalist-method'></span><span id='topic+update+2Csigmalist-method'></span><span id='topic+update+2Cparameter_list-method'></span>

<h3>Description</h3>

<p>After the model object is created, update various attributes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'mrgmod'
update(object, ..., merge = TRUE, open = FALSE, data = NULL, strict = TRUE)

## S4 method for signature 'omegalist'
update(object, y, ...)

## S4 method for signature 'sigmalist'
update(object, y, ...)

## S4 method for signature 'parameter_list'
update(object, .y, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="update_+3A_object">object</code></td>
<td>
<p>a model object.</p>
</td></tr>
<tr><td><code id="update_+3A_...">...</code></td>
<td>
<p>named items to update.</p>
</td></tr>
<tr><td><code id="update_+3A_merge">merge</code></td>
<td>
<p>logical indicating to merge (rather than replace) 
new and existing attributes.</p>
</td></tr>
<tr><td><code id="update_+3A_open">open</code></td>
<td>
<p>logical; used only when merge is <code>TRUE</code> and 
parameter list or initial conditions
list is being updated; if <code>FALSE</code>, no new items will be 
added; if <code>TRUE</code>, the parameter list may expand.</p>
</td></tr>
<tr><td><code id="update_+3A_data">data</code></td>
<td>
<p>a list of items to update; this list is combined 
with any items passed in via <code>...</code>.</p>
</td></tr>
<tr><td><code id="update_+3A_strict">strict</code></td>
<td>
<p>if <code>TRUE</code>, a warning will be issued when there is an
attempt to update a non-existent item.</p>
</td></tr>
<tr><td><code id="update_+3A_y">y</code></td>
<td>
<p>another object involved in update</p>
</td></tr>
<tr><td><code id="update_+3A_.y">.y</code></td>
<td>
<p>data to update</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Slots that can be updated: 
</p>

<ul>
<li><p> verbose
</p>
</li>
<li><p> debug
</p>
</li>
<li><p> preclean
</p>
</li>
<li><p> mindt
</p>
</li>
<li><p> digits
</p>
</li>
<li><p> atol - absolute solver tolerance; see <code><a href="#topic+solversettings">solversettings</a></code>
</p>
</li>
<li><p> rtol - relative solver tolerance; see <code><a href="#topic+solversettings">solversettings</a></code>
</p>
</li>
<li><p> ss_rtol - relative tolerance when finding steady state
</p>
</li>
<li><p> ss_atol - absolute tolerance when finding steady state
</p>
</li>
<li><p> ixpr - see <code>IXPR</code> in <code><a href="#topic+solversettings">solversettings</a></code>
</p>
</li>
<li><p> mxhnil - see <code>MXHNIL</code> in <code><a href="#topic+solversettings">solversettings</a></code>
</p>
</li>
<li><p> hmin - see <code>HMIN</code> in <code><a href="#topic+solversettings">solversettings</a></code>
</p>
</li>
<li><p> hmax - see <code>HMAX</code> in <code><a href="#topic+solversettings">solversettings</a></code>
</p>
</li>
<li><p> maxsteps - see <code>MXSTEP</code> in <code><a href="#topic+solversettings">solversettings</a></code>
</p>
</li>
<li><p> start, end, delta, add
</p>
</li>
<li><p> tscale
</p>
</li>
<li><p> request
</p>
</li>
<li><p> param
</p>
</li>
<li><p> init
</p>
</li>
<li><p> omega
</p>
</li>
<li><p> sigma
</p>
</li>
<li><p> outvars
</p>
</li></ul>



<h3>Value</h3>

<p>The updated model object is returned.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+update">update</a></code>, <code><a href="#topic+mrgmod-class">mrgmod-class</a></code>, 
<code><a href="#topic+within">within</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
 mod &lt;- house()

 mod &lt;- update(mod, end = 120, delta = 4, param = list(CL = 19.1))

## End(Not run)
 
</code></pre>

<hr>
<h2 id='valid_data_set'>Validate and prepare data sets for simulation</h2><span id='topic+valid_data_set'></span><span id='topic+valid_data_set.matrix'></span>

<h3>Description</h3>

<p>This function is called by <code><a href="#topic+mrgsim">mrgsim()</a></code> and friends to check and prepare
input data sets for simulation.  Users may also call this function to
pre-validate data when the same data set is used for repeated simulation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>valid_data_set(x, m = NULL, verbose = FALSE, quiet = FALSE)

valid_data_set.matrix(x, verbose = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="valid_data_set_+3A_x">x</code></td>
<td>
<p>data.frame or matrix.</p>
</td></tr>
<tr><td><code id="valid_data_set_+3A_m">m</code></td>
<td>
<p>a model object.</p>
</td></tr>
<tr><td><code id="valid_data_set_+3A_verbose">verbose</code></td>
<td>
<p>logical.</p>
</td></tr>
<tr><td><code id="valid_data_set_+3A_quiet">quiet</code></td>
<td>
<p>if <code>TRUE</code>, messages will be suppressed.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>An error will be issued when
</p>

<ul>
<li><p> non-numeric data is found in columns sharing names with model parameters
</p>
</li>
<li><p> non-numeric data is found in reserved data items related to dosing
(see <code>mrgsolve:::GLOBALS$CARRY_TRAN</code>)
</p>
</li>
<li><p> a column is found that is &quot;internally classed&quot;, including columns that
inherit from <code>integer64</code> (see <code><a href="base.html#topic+is.object">is.object()</a></code>)
</p>
</li></ul>



<h3>Value</h3>

<p>A matrix with non-numeric columns dropped; if x is a
data.frame with character <code>cmt</code> column comprised of valid
compartment names and <code>m</code> is a model object,
the <code>cmt</code> column will be converted to the corresponding
compartment number.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+valid_idata_set">valid_idata_set()</a></code>, <code><a href="#topic+idata_set">idata_set()</a></code>, <code><a href="#topic+data_set">data_set()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
mod &lt;- mrgsolve::house()

data(exTheoph)

d &lt;- valid_data_set(exTheoph, mod)

</code></pre>

<hr>
<h2 id='valid_idata_set'>Validate and prepare idata data sets for simulation</h2><span id='topic+valid_idata_set'></span>

<h3>Description</h3>

<p>This function is called by <code><a href="#topic+mrgsim">mrgsim()</a></code> and friends to check and prepare
input data sets for simulation.  Users may also call this function to
pre-validate data when the same data set is used for repeated simulation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>valid_idata_set(x, m, verbose = FALSE, quiet = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="valid_idata_set_+3A_x">x</code></td>
<td>
<p>data.frame or matrix.</p>
</td></tr>
<tr><td><code id="valid_idata_set_+3A_m">m</code></td>
<td>
<p>a model object.</p>
</td></tr>
<tr><td><code id="valid_idata_set_+3A_verbose">verbose</code></td>
<td>
<p>logical.</p>
</td></tr>
<tr><td><code id="valid_idata_set_+3A_quiet">quiet</code></td>
<td>
<p>if <code>TRUE</code>, messages will be suppressed.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>An error will be issued when
</p>

<ul>
<li><p> non-numeric data is found in columns sharing names with model parameters
</p>
</li>
<li><p> a column is found that is internally classed, including columns that
inherit from <code>integer64</code> (see <code><a href="base.html#topic+is.object">is.object()</a></code>)
</p>
</li></ul>



<h3>Value</h3>

<p>A numeric matrix with class <code>valid_idata_set</code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+valid_data_set">valid_data_set()</a></code>, <code><a href="#topic+idata_set">idata_set()</a></code>, <code><a href="#topic+data_set">data_set()</a></code>
</p>

<hr>
<h2 id='wf_sweep'>Simulate a sequence of parameters</h2><span id='topic+wf_sweep'></span>

<h3>Description</h3>

<p>This function is experimental and may change or go away at any time without
notice.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>wf_sweep(mod, ..., n = 10, cv = 30, nsd = 2)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="wf_sweep_+3A_mod">mod</code></td>
<td>
<p>a model object</p>
</td></tr>
<tr><td><code id="wf_sweep_+3A_...">...</code></td>
<td>
<p>unquoted parameter names</p>
</td></tr>
<tr><td><code id="wf_sweep_+3A_n">n</code></td>
<td>
<p>number of values to simulate</p>
</td></tr>
<tr><td><code id="wf_sweep_+3A_cv">cv</code></td>
<td>
<p>coefficient of variation; used to determine the minimum and
maximum values for the sweep</p>
</td></tr>
<tr><td><code id="wf_sweep_+3A_nsd">nsd</code></td>
<td>
<p>the number of standard deviations over which to sweep</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A mrgsims object with a character columns named <code>.name</code>
indicating the parameter name and <code>.value</code> indicating the sweep
value.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>mod &lt;- mrgsolve::house() %&gt;% zero_re()

mod %&gt;% 
  ev(amt = 100) %&gt;% 
  wf_sweep(CL, VC) %&gt;% 
  plot(CP~time|.name)

</code></pre>

<hr>
<h2 id='within'>Update parameters, initials, and settings within a model object</h2><span id='topic+within'></span><span id='topic+within.mrgmod'></span><span id='topic+within+2Cmrgmod-method'></span>

<h3>Description</h3>

<p>The main use case for using <a href="#topic+within">within</a> rather than <a href="#topic+update">update</a> or <a href="#topic+param">param</a> or
<a href="#topic+init">init</a> is when you want to update to a new value that is calculated from
the existing value.  See the example in details
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'mrgmod'
within(data, expr, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="within_+3A_data">data</code></td>
<td>
<p>an object with class mrgmod</p>
</td></tr>
<tr><td><code id="within_+3A_expr">expr</code></td>
<td>
<p>expressions evaluated in an environment containing various model
object components, including parameters, initial conditions, and others
(see details)</p>
</td></tr>
<tr><td><code id="within_+3A_...">...</code></td>
<td>
<p>not used</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Other model object slots that can be updated: <code>start</code>, <code>end</code>, <code>delta</code>,
<code>add</code>, <code>rtol</code>, <code>atol</code>, <code>hmax</code>, <code>maxsteps</code>.  These are include for convenience,
but we expect that most of the time these will get updated through the
update method.
</p>


<h3>See Also</h3>

<p><a href="#topic+update">update</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>mod &lt;- mrgsolve::house()

mod2 &lt;- within(mod, {CL &lt;- CL * 1.5})

mod$CL
mod2$CL

</code></pre>

<hr>
<h2 id='zero_re'>Zero out random effects in a model object</h2><span id='topic+zero_re'></span><span id='topic+zero_re+2Cmrgmod-method'></span>

<h3>Description</h3>

<p>Sets all elements of the OMEGA or SIGMA matrix to zero.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>zero_re(.x, ...)

## S4 method for signature 'mrgmod'
zero_re(.x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="zero_re_+3A_.x">.x</code></td>
<td>
<p>a model object.</p>
</td></tr>
<tr><td><code id="zero_re_+3A_...">...</code></td>
<td>
<p>which matrix to zero out; pass <code>omega</code> to just zero out <code>omega</code>,
<code>sigma</code> to just zero out <code>sigma</code>; passing nothing will zero out both.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An updated object with elements of OMEGA and/or SIGMA set to zero.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>mod &lt;- house()
revar(mod)
mod &lt;- zero_re(mod)
revar(mod)

## Not run: 
mod &lt;- modlib("popex", compile = FALSE)
mod &lt;- zero_re(mod, omega)
revar(mod)

## End(Not run)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
