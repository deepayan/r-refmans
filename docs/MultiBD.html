<!DOCTYPE html><html><head><title>Help for package MultiBD</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {MultiBD}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#MultiBD'><p>Multivariate birth-death processes</p></a></li>
<li><a href='#bbd_prob'><p>Transition probabilities of a birth/birth-death process</p></a></li>
<li><a href='#dbd_prob'><p>Transition probabilities of a death/birth-death process</p></a></li>
<li><a href='#Eyam'><p>Eyam plague.</p></a></li>
<li><a href='#SIR_prob'><p>Transition probabilities of an SIR process</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Multivariate Birth-Death Processes</td>
</tr>
<tr>
<td>Version:</td>
<td>0.2.0</td>
</tr>
<tr>
<td>Date:</td>
<td>2016-07-19</td>
</tr>
<tr>
<td>Author:</td>
<td>Lam S.T. Ho [aut, cre],
    Marc A. Suchard [aut],
    Forrest W. Crawford [aut],
    Jason Xu [ctb],
    Vladimir N. Minin [ctb]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Marc A. Suchard &lt;msuchard@ucla.edu&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Computationally efficient functions to provide direct likelihood-based
    inference for partially-observed multivariate birth-death processes.  Such processes
    range from a simple Yule model to the complex susceptible-infectious-removed model
    in disease dynamics.  Efficient likelihood evaluation facilitates maximum likelihood
    estimation and Bayesian inference.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.apache.org/licenses/LICENSE-2.0">Apache License 2.0</a></td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.1.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>Rcpp (&ge; 0.11.2), RcppParallel</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>Rcpp, BH, RcppParallel</td>
</tr>
<tr>
<td>Suggests:</td>
<td>testthat, knitr, rmarkdown, MCMCpack, ggplot2, matrixStats,
plotrix</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>5.0.1</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2016-12-05 14:41:14 UTC; hornik</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2016-12-05 18:28:46</td>
</tr>
</table>
<hr>
<h2 id='MultiBD'>Multivariate birth-death processes</h2><span id='topic+MultiBD'></span><span id='topic+MultiBD-package'></span>

<h3>Description</h3>

<p>The MultiBD package computes the transition probabilities
of several multivariate birth-death processes.
</p>


<h3>References</h3>

<p>Ho LST et al. 2016. &quot;Birth(death)/birth-death processes and their computable transition probabilities with statistical applications&quot;. In review.
</p>

<hr>
<h2 id='bbd_prob'>Transition probabilities of a birth/birth-death process</h2><span id='topic+bbd_prob'></span>

<h3>Description</h3>

<p>Computes the transition pobabilities of a birth/birth-death process 
using the continued fraction representation of its Laplace transform
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bbd_prob(t, a0, b0, lambda1, lambda2, mu2, gamma, A, B, nblocks = 256,
  tol = 1e-12, computeMode = 0, nThreads = 4, maxdepth = 400)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bbd_prob_+3A_t">t</code></td>
<td>
<p>time</p>
</td></tr>
<tr><td><code id="bbd_prob_+3A_a0">a0</code></td>
<td>
<p>total number of type 1 particles at <code>t = 0</code></p>
</td></tr>
<tr><td><code id="bbd_prob_+3A_b0">b0</code></td>
<td>
<p>total number of type 2 particles at <code>t = 0</code></p>
</td></tr>
<tr><td><code id="bbd_prob_+3A_lambda1">lambda1</code></td>
<td>
<p>birth rate of type 1 particles (a two variables function)</p>
</td></tr>
<tr><td><code id="bbd_prob_+3A_lambda2">lambda2</code></td>
<td>
<p>birth rate of type 2 particles (a two variables function)</p>
</td></tr>
<tr><td><code id="bbd_prob_+3A_mu2">mu2</code></td>
<td>
<p>death rate function of type 2 particles (a two variables function)</p>
</td></tr>
<tr><td><code id="bbd_prob_+3A_gamma">gamma</code></td>
<td>
<p>transition rate from type 2 particles to type 1 particles (a two variables function)</p>
</td></tr>
<tr><td><code id="bbd_prob_+3A_a">A</code></td>
<td>
<p>upper bound for the total number of type 1 particles</p>
</td></tr>
<tr><td><code id="bbd_prob_+3A_b">B</code></td>
<td>
<p>upper bound for the total number of type 2 particles</p>
</td></tr>
<tr><td><code id="bbd_prob_+3A_nblocks">nblocks</code></td>
<td>
<p>number of blocks</p>
</td></tr>
<tr><td><code id="bbd_prob_+3A_tol">tol</code></td>
<td>
<p>tolerance</p>
</td></tr>
<tr><td><code id="bbd_prob_+3A_computemode">computeMode</code></td>
<td>
<p>computation mode</p>
</td></tr>
<tr><td><code id="bbd_prob_+3A_nthreads">nThreads</code></td>
<td>
<p>number of threads</p>
</td></tr>
<tr><td><code id="bbd_prob_+3A_maxdepth">maxdepth</code></td>
<td>
<p>maximum number of iterations for Lentz algorithm</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a matrix of the transition probabilities
</p>


<h3>References</h3>

<p>Ho LST et al. 2015. &quot;Birth(death)/birth-death processes and their computable transition probabilities with statistical applications&quot;. In review.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
data(Eyam)

# (R, I) in the SIR model forms a birth/birth-death process

loglik_sir &lt;- function(param, data) {
  alpha &lt;- exp(param[1]) # Rates must be non-negative
  beta  &lt;- exp(param[2])
  N &lt;- data$S[1] + data$I[1] + data$R[1]
  
  # Set-up SIR model with (R, I)
  
  brates1 &lt;- function(a, b) { 0 }
  brates2 &lt;- function(a, b) { beta  * max(N - a - b, 0)  * b }
  drates2 &lt;- function(a, b) { 0 }
  trans21 &lt;- function(a, b) { alpha * b }
  
  sum(sapply(1:(nrow(data) - 1), # Sum across all time steps k
             function(k) {
               log(
                 bbd_prob( # Compute the transition probability matrix
                   t  = data$time[k + 1] - data$time[k], # Time increment
                   a0 = data$R[k], b0 = data$I[k],       # From: R(t_k), I(t_k)
                   brates1, brates2, drates2, trans21,
                   A = data$R[k + 1], B = data$R[k + 1] + data$I[k] - data$R[k],
                   computeMode = 4, nblocks = 80         # Compute using 4 threads
                 )[data$R[k + 1] - data$R[k] + 1, 
                   data$I[k + 1] + 1]                    # To: R(t_(k+1)), I(t_(k+1))
               )
             }))
}

loglik_sir(log(c(3.204, 0.019)), Eyam) # Evaluate at mode

## End(Not run)
</code></pre>

<hr>
<h2 id='dbd_prob'>Transition probabilities of a death/birth-death process</h2><span id='topic+dbd_prob'></span>

<h3>Description</h3>

<p>Computes the transition pobabilities of a death/birth-death process
using the continued fraction representation of its Laplace transform
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dbd_prob(t, a0, b0, mu1, lambda2, mu2, gamma, a = 0, B, nblocks = 256,
  tol = 1e-12, computeMode = 0, nThreads = 4, maxdepth = 400)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dbd_prob_+3A_t">t</code></td>
<td>
<p>time</p>
</td></tr>
<tr><td><code id="dbd_prob_+3A_a0">a0</code></td>
<td>
<p>total number of type 1 particles at <code>t = 0</code></p>
</td></tr>
<tr><td><code id="dbd_prob_+3A_b0">b0</code></td>
<td>
<p>total number of type 2 particles at <code>t = 0</code></p>
</td></tr>
<tr><td><code id="dbd_prob_+3A_mu1">mu1</code></td>
<td>
<p>death rate of type 1 particles (a two variables function)</p>
</td></tr>
<tr><td><code id="dbd_prob_+3A_lambda2">lambda2</code></td>
<td>
<p>birth rate of type 2 particles (a two variables function)</p>
</td></tr>
<tr><td><code id="dbd_prob_+3A_mu2">mu2</code></td>
<td>
<p>death rate function of type 2 particles (a two variables function)</p>
</td></tr>
<tr><td><code id="dbd_prob_+3A_gamma">gamma</code></td>
<td>
<p>transition rate from type 2 particles to type 1 particles (a two variables function)</p>
</td></tr>
<tr><td><code id="dbd_prob_+3A_a">a</code></td>
<td>
<p>lower bound for the total number of type 1 particles (default <code>a = 0</code>)</p>
</td></tr>
<tr><td><code id="dbd_prob_+3A_b">B</code></td>
<td>
<p>upper bound for the total number of type 2 particles</p>
</td></tr>
<tr><td><code id="dbd_prob_+3A_nblocks">nblocks</code></td>
<td>
<p>number of blocks</p>
</td></tr>
<tr><td><code id="dbd_prob_+3A_tol">tol</code></td>
<td>
<p>tolerance</p>
</td></tr>
<tr><td><code id="dbd_prob_+3A_computemode">computeMode</code></td>
<td>
<p>computation mode</p>
</td></tr>
<tr><td><code id="dbd_prob_+3A_nthreads">nThreads</code></td>
<td>
<p>number of threads</p>
</td></tr>
<tr><td><code id="dbd_prob_+3A_maxdepth">maxdepth</code></td>
<td>
<p>maximum number of iterations for Lentz algorithm</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a matrix of the transition probabilities
</p>


<h3>References</h3>

<p>Ho LST et al. 2016. &quot;Birth(death)/birth-death processes and their computable transition probabilities with statistical applications&quot;. In review.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
data(Eyam)

loglik_sir &lt;- function(param, data) {
  alpha &lt;- exp(param[1]) # Rates must be non-negative
  beta  &lt;- exp(param[2])

  # Set-up SIR model
  drates1 &lt;- function(a, b) { 0 }
  brates2 &lt;- function(a, b) { 0 }
  drates2 &lt;- function(a, b) { alpha * b     }
  trans12 &lt;- function(a, b) { beta  * a * b }

  sum(sapply(1:(nrow(data) - 1), # Sum across all time steps k
             function(k) {
               log(
                 dbd_prob(  # Compute the transition probability matrix
                   t  = data$time[k + 1] - data$time[k], # Time increment
                   a0 = data$S[k], b0 = data$I[k],       # From: S(t_k), I(t_k)
                   drates1, brates2, drates2, trans12,
                   a = data$S[k + 1], B = data$S[k] + data$I[k] - data$S[k + 1],
                   computeMode = 4, nblocks = 80         # Compute using 4 threads
                 )[1, data$I[k + 1] + 1]                 # To: S(t_(k+1)), I(t_(k+1))
               )
             }))
  }

  loglik_sir(log(c(3.204, 0.019)), Eyam) # Evaluate at mode

## End(Not run)

# Birth-death-shift model for transposable elements

lam = 0.0188; mu = 0.0147; v = 0.00268; # birth, death, shift rates

drates1 &lt;- function(a, b) { mu * a }
brates2 &lt;- function(a, b) { lam * (a + b) }
drates2 &lt;- function(a, b) { mu * b }
trans12 &lt;- function(a, b) { v * a }

# Get transition probabilities
p &lt;- dbd_prob(t = 1, a0 = 10, b0 = 0,
              drates1, brates2, drates2, trans12,
              a = 0, B = 50)

</code></pre>

<hr>
<h2 id='Eyam'>Eyam plague.</h2><span id='topic+Eyam'></span>

<h3>Description</h3>

<p>A dataset containing the number of susceptible, infectious and removed
individuals during the Eyam plague from June 18 to October 20, 1666.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(Eyam)
</code></pre>


<h3>Format</h3>

<p>A data frame with 8 rows and 4 variables:
</p>

<dl>
<dt>time</dt><dd><p>Months past June 18 1666</p>
</dd>
<dt>S</dt><dd><p>Susceptible</p>
</dd>
<dt>I</dt><dd><p>Infectious</p>
</dd>
<dt>R</dt><dd><p>Removed</p>
</dd> 
</dl>


<h3>References</h3>

<p>Ragget G (1982). A stochastic model of the Eyam plague. Journal of Applied Statistics 9, 212-226.
</p>

<hr>
<h2 id='SIR_prob'>Transition probabilities of an SIR process</h2><span id='topic+SIR_prob'></span>

<h3>Description</h3>

<p>Computes the transition pobabilities of an SIR process 
using the bivariate birth process representation
</p>


<h3>Usage</h3>

<pre><code class='language-R'>SIR_prob(t, alpha, beta, S0, I0, nSI, nIR, direction = c("Forward",
  "Backward"), nblocks = 20, tol = 1e-12, computeMode = 0, nThreads = 4)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="SIR_prob_+3A_t">t</code></td>
<td>
<p>time</p>
</td></tr>
<tr><td><code id="SIR_prob_+3A_alpha">alpha</code></td>
<td>
<p>removal rate</p>
</td></tr>
<tr><td><code id="SIR_prob_+3A_beta">beta</code></td>
<td>
<p>infection rate</p>
</td></tr>
<tr><td><code id="SIR_prob_+3A_s0">S0</code></td>
<td>
<p>initial susceptible population</p>
</td></tr>
<tr><td><code id="SIR_prob_+3A_i0">I0</code></td>
<td>
<p>initial infectious population</p>
</td></tr>
<tr><td><code id="SIR_prob_+3A_nsi">nSI</code></td>
<td>
<p>number of infection events</p>
</td></tr>
<tr><td><code id="SIR_prob_+3A_nir">nIR</code></td>
<td>
<p>number of removal events</p>
</td></tr>
<tr><td><code id="SIR_prob_+3A_direction">direction</code></td>
<td>
<p>direction of the transition probabilities (either <code>Forward</code> or <code>Backward</code>)</p>
</td></tr>
<tr><td><code id="SIR_prob_+3A_nblocks">nblocks</code></td>
<td>
<p>number of blocks</p>
</td></tr>
<tr><td><code id="SIR_prob_+3A_tol">tol</code></td>
<td>
<p>tolerance</p>
</td></tr>
<tr><td><code id="SIR_prob_+3A_computemode">computeMode</code></td>
<td>
<p>computation mode</p>
</td></tr>
<tr><td><code id="SIR_prob_+3A_nthreads">nThreads</code></td>
<td>
<p>number of threads</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a matrix of the transition probabilities
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(Eyam)

loglik_sir &lt;- function(param, data) {
  alpha &lt;- exp(param[1]) # Rates must be non-negative
  beta  &lt;- exp(param[2])
  
  if(length(unique(rowSums(data[, c("S", "I", "R")]))) &gt; 1) {
    stop ("Please make sure the data conform with a closed population")
  }
  
  sum(sapply(1:(nrow(data) - 1), # Sum across all time steps k
             function(k) {
               log(
                 SIR_prob(  # Compute the forward transition probability matrix
                   t  = data$time[k + 1] - data$time[k], # Time increment
                   alpha = alpha, beta = beta, 
                   S0 = data$S[k], I0 = data$I[k],       # From: R(t_k), I(t_k)
                   nSI = data$S[k] - data$S[k + 1], nIR = data$R[k + 1] - data$R[k],
                   computeMode = 4, nblocks = 80         # Compute using 4 threads
                 )[data$S[k] - data$S[k + 1] + 1, 
                   data$R[k + 1] - data$R[k] + 1]        # To: R(t_(k+1)), I(t_(k+1))
               )
             }))
}

loglik_sir(log(c(3.204, 0.019)), Eyam) # Evaluate at mode
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
