<!DOCTYPE html><html><head><title>Help for package mccca</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {mccca}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#create.MCCCAdata'><p>this function creates a list (class: mcccadata) to be applied to MCCCA.</p></a></li>
<li><a href='#create.prop'><p>Creates a list length J of category proportion for each cluster.</p></a></li>
<li><a href='#generate.cate.list'><p>Generate (NxJ) categorical data matrix.</p></a></li>
<li><a href='#generate.catecls'><p>Generate (NxJ) clustered categorical data matrix.</p></a></li>
<li><a href='#generate.ext'><p>generates an artificial (NxH) external variable matrix.</p></a></li>
<li><a href='#generate.onedata'><p>Generate (NxJ) categorical data matrix.</p></a></li>
<li><a href='#MCCCA'><p>apply MCCCA for dataset.</p></a></li>
<li><a href='#plot.mccca'><p>plot <code>mccca</code> object.</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Visualizing Class Specific Heterogeneous Tendencies in
Categorical Data</td>
</tr>
<tr>
<td>Version:</td>
<td>1.1.0.1</td>
</tr>
<tr>
<td>Author:</td>
<td>Mariko Takagishi [aut, cre]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Mariko Takagishi &lt;m.takagishi0728@gmail.com&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Performing multiple-class cluster correspondence analysis(MCCCA). The main functions are create.MCCCAdata() to create a list to be applied to MCCCA, MCCCA() to apply MCCCA, and plot.mccca() for visualizing MCCCA result. Methods used in the 
  package refers to Mariko Takagishi and Michel van de Velden (2022)&lt;<a href="https://doi.org/10.1080%2F10618600.2022.2035737">doi:10.1080/10618600.2022.2035737</a>&gt;.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 4.1.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>magic, stringr, ggplot2, wordcloud, RColorBrewer, stats,
utils, grDevices, Rcpp (&ge; 1.0.9)</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.1</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>Rcpp, RcppArmadillo</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-01-24 14:29:05 UTC; hornik</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-01-24 14:39:05 UTC</td>
</tr>
</table>
<hr>
<h2 id='create.MCCCAdata'>this function creates a list (class: mcccadata) to be applied to MCCCA.</h2><span id='topic+create.MCCCAdata'></span>

<h3>Description</h3>

<p>Creates a list (named <code>mcccadata.list</code>) applied to MCCCA.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>create.MCCCAdata(dat,ext.mat=ext.mat,clstr0.vec=NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="create.MCCCAdata_+3A_dat">dat</code></td>
<td>
<p>An (NxJ) matrix of categorical data (N:the number of observations, J:the number of variables). If <code>rownames(dat)</code> is <code>NULL</code>, <code>c(obj1,..,objN)</code> are defined as <code>rownames(dat)</code>.</p>
</td></tr>
<tr><td><code id="create.MCCCAdata_+3A_ext.mat">ext.mat</code></td>
<td>
<p>An (NxH) external variable matrix (H:the number of external variable).</p>
</td></tr>
<tr><td><code id="create.MCCCAdata_+3A_clstr0.vec">clstr0.vec</code></td>
<td>
<p>An integer vector of length N giving each observation's true cluster.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a list with the following elements.
</p>
<table>
<tr><td><code>data.mat</code></td>
<td>
<p>data matrix same as <code>dat</code>.</p>
</td></tr>
<tr><td><code>data.list</code></td>
<td>
<p>A list of C (NxJ) categorical data matrices for each class (C:the number of classes).</p>
</td></tr>
<tr><td><code>clstr0.list</code></td>
<td>
<p>A list of C vectors where each vector indicates the true cluster (given in <code>clstr0.vec</code>) to which each class of observations belongs (NULL if <code>clstr0.vec</code> is NULL).</p>
</td></tr>
<tr><td><code>N.vec</code></td>
<td>
<p>A vector of length C giving the number of observations in each class.</p>
</td></tr>
<tr><td><code>Ktrue.vec</code></td>
<td>
<p>A vector of length C giving the true number of clusters in each class  (NULL if <code>clstr0.vec</code> is NULL).</p>
</td></tr>
<tr><td><code>q.vec</code></td>
<td>
<p>A vector of length J giving the number of categories in each of J categorical variables.</p>
</td></tr>
<tr><td><code>class.n.vec</code></td>
<td>
<p>An integer (from 1:C) vector of length N giving the class index of each observation. <code>names(class.n.vec)=rownames(dat)</code>.</p>
</td></tr>
<tr><td><code>classname.n.vec</code></td>
<td>
<p>A characteristic vector of length N giving the class label each observation belongs to. <code>names(classname.n.vec)=rownames(dat)</code>.</p>
</td></tr>
<tr><td><code>classlabel</code></td>
<td>
<p>A characteristic vector of length C giving the classlabel for each class.</p>
</td></tr>
<tr><td><code>classlab.mat</code></td>
<td>
<p>(Cx(H+1)) table, showing which combinations of categories of external variables each class index and class name corresponds to. The first H columns indicate the categories for each of the H external variables, and the last H+1th column indicates the corresponding class label (same as <code>classlabel</code>).</p>
</td></tr>
<tr><td><code>oriindex.list</code></td>
<td>
<p>A list of length C, where each list element corresponds to a row (observation) in data.list, indicating which row of observations (in <code>data.mat</code>) each observation (in <code>oriindex.list</code>) corresponds to.</p>
</td></tr>
</table>


<h3>References</h3>

<p>Takagishi &amp; Michel van de Velden (2022): Visualizing Class Specific
Heterogeneous Tendencies in Categorical Data, Journal of Computational and Graphical Statistics,
DOI: 10.1080/10618600.2022.2035737
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#setting
N &lt;- 100 ; J &lt;- 5 ; Ktrue &lt;- 2 ; q.vec &lt;- rep(5,J) ; noise.prop &lt;- 0.2
extcate.vec=c(2,3)#the number of categories for each external variable

#generate categorical variable data
catedata.list &lt;- generate.onedata(N=N,J=J,Ktrue=Ktrue,q.vec=q.vec,noise.prop = noise.prop)
data.cate=catedata.list$data.mat
clstr0.vec=catedata.list$clstr0.vec

#generate external variable data
data.ext=generate.ext(N,extcate.vec=extcate.vec)

#create mccca.list to be applied to MCCCA function
mccca.data=create.MCCCAdata(data.cate,ext.mat=data.ext,clstr0.vec =clstr0.vec)

#check which class each observation belongs to. (given by class name)
mccca.data$classname.n.vec

#A table showing that which combinations of categories of external variables
# each class index and class name corresponds to.
mccca.data$classlab.mat
</code></pre>

<hr>
<h2 id='create.prop'>Creates a list length J of category proportion for each cluster.</h2><span id='topic+create.prop'></span>

<h3>Description</h3>

<p>Creates a list length J of category proportion for each cluster.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>create.prop(
  J = J,
  q.vec = q.vec,
  Ktrue = Ktrue,
  strongprop = 0.8,
  which.noise = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="create.prop_+3A_j">J</code></td>
<td>
<p>The number of active variable.!!!</p>
</td></tr>
<tr><td><code id="create.prop_+3A_q.vec">q.vec</code></td>
<td>
<p>A vector of length J giving the number of categories for each active variable.</p>
</td></tr>
<tr><td><code id="create.prop_+3A_ktrue">Ktrue</code></td>
<td>
<p>The number of clusters in J active variables.</p>
</td></tr>
<tr><td><code id="create.prop_+3A_strongprop">strongprop</code></td>
<td>
<p>A numeric value giving the strongest proportion of categories (common for all J active variables).</p>
</td></tr>
<tr><td><code id="create.prop_+3A_which.noise">which.noise</code></td>
<td>
<p>A vector of length (&lt;= J) giving the index of noise variables in J active variables. NULL indicating all variable is non-noise.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a list length J, each of which is a (Ktrue x qj) matrix giving the proportion for each qj category in each Ktrue cluster.
</p>

<hr>
<h2 id='generate.cate.list'>Generate (NxJ) categorical data matrix.</h2><span id='topic+generate.cate.list'></span>

<h3>Description</h3>

<p>Generate an (NxJ) categorical data matrix given by prop.J.list and true cluster allocation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>generate.cate.list(N = N, prop.list = prop.list)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="generate.cate.list_+3A_n">N</code></td>
<td>
<p>The number of observations.</p>
</td></tr>
<tr><td><code id="generate.cate.list_+3A_prop.list">prop.list</code></td>
<td>
<p>a list length J, each of which is a vector of length qj giving the proportion for each categories.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an (NxJ) categorical data matrix.
</p>

<hr>
<h2 id='generate.catecls'>Generate (NxJ) clustered categorical data matrix.</h2><span id='topic+generate.catecls'></span>

<h3>Description</h3>

<p>Generate an (NxJ) clustered categorical data matrix given by prop.J.list and true cluster allocation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>generate.catecls(
  N = N,
  J = J,
  q.vec = q.vec,
  Ktrue = Ktrue,
  prop.J.list = prop.J.list,
  clstr.vec = clstr.vec
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="generate.catecls_+3A_n">N</code></td>
<td>
<p>The number of observations.</p>
</td></tr>
<tr><td><code id="generate.catecls_+3A_j">J</code></td>
<td>
<p>The number of active variables.</p>
</td></tr>
<tr><td><code id="generate.catecls_+3A_q.vec">q.vec</code></td>
<td>
<p>A vector of length J giving the number of categories for each active variable.</p>
</td></tr>
<tr><td><code id="generate.catecls_+3A_ktrue">Ktrue</code></td>
<td>
<p>An integer indicating the number of content-based clusters used for CCRS estimation.</p>
</td></tr>
<tr><td><code id="generate.catecls_+3A_prop.j.list">prop.J.list</code></td>
<td>
<p>a list of length J, where each list is a (Ktrue x qj) matrix giving the proportion for each qj category in each of the <code>Ktrue</code> cluster.</p>
</td></tr>
<tr><td><code id="generate.catecls_+3A_clstr.vec">clstr.vec</code></td>
<td>
<p>A vector of length N giving true clusters for each observations.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an (NxJ) clustered categorical data matrix.
</p>

<hr>
<h2 id='generate.ext'>generates an artificial (NxH) external variable matrix.</h2><span id='topic+generate.ext'></span>

<h3>Description</h3>

<p>Generates an artificial (NxH) external variable matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>generate.ext(N,extcate.vec=extcate.vec,unbala.cate=FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="generate.ext_+3A_n">N</code></td>
<td>
<p>The number of observation.</p>
</td></tr>
<tr><td><code id="generate.ext_+3A_extcate.vec">extcate.vec</code></td>
<td>
<p>A vector of length H, each element indicates the number of category for each H external variables.</p>
</td></tr>
<tr><td><code id="generate.ext_+3A_unbala.cate">unbala.cate</code></td>
<td>
<p>logical value. If TRUE, the proportion of categories in the external variable is unbalanced. The default is FALSE.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An (NxH) external variable matrix.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+generate.catecls">generate.catecls</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>###data setting
N &lt;- 30 ; extcate.vec=c(2,3)
ext.mat=generate.ext(N,extcate.vec=extcate.vec)
</code></pre>

<hr>
<h2 id='generate.onedata'>Generate (NxJ) categorical data matrix.</h2><span id='topic+generate.onedata'></span>

<h3>Description</h3>

<p>Generate (NxJ) categorical data matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>generate.onedata(N=100,J=5,Ktrue=3,q.vec=rep(3,5),noise.prop=0.3)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="generate.onedata_+3A_n">N</code></td>
<td>
<p>The number of observations. Default is 100.</p>
</td></tr>
<tr><td><code id="generate.onedata_+3A_j">J</code></td>
<td>
<p>The number of active variables. Default is 5.</p>
</td></tr>
<tr><td><code id="generate.onedata_+3A_ktrue">Ktrue</code></td>
<td>
<p>The number of true clusters. Default is 3.</p>
</td></tr>
<tr><td><code id="generate.onedata_+3A_q.vec">q.vec</code></td>
<td>
<p>A vector of length J giving the number of categories for each active variable. Default is rep(3,5).</p>
</td></tr>
<tr><td><code id="generate.onedata_+3A_noise.prop">noise.prop</code></td>
<td>
<p>A numeric value between 0 and 1 indicating the proportion of noise variables among J variables. Default is 0.3.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a list with the following elements.
</p>
<table>
<tr><td><code>data.mat</code></td>
<td>
<p>A (NxJ) data frame of categorical data.</p>
</td></tr>
<tr><td><code>clstr0.vec</code></td>
<td>
<p>A vector of integers (from 1:Ktrue) length N giving the cluster to which each observation is allocated.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+create.prop">create.prop</a></code>, <code><a href="#topic+generate.catecls">generate.catecls</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>###data setting
N &lt;- 30 ; J &lt;- 10 ; Ktrue &lt;- 2 ; q.vec &lt;- rep(5,J) ; noise.prop &lt;- 0.3
datagene &lt;- generate.onedata(N=N,J=J,Ktrue=Ktrue,q.vec=q.vec,noise.prop = noise.prop)
</code></pre>

<hr>
<h2 id='MCCCA'>apply MCCCA for dataset.</h2><span id='topic+MCCCA'></span>

<h3>Description</h3>

<p>Applies MCCCA to <code>mcccadata.list</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>MCCCA(
  mccca.data,
  K.vec = K.vec,
  known.vec = NULL,
  knowncluster.list = NULL,
  nstart = 3,
  maxit = 50,
  p = 2,
  tol = 1e-08,
  verbose = TRUE,
  remove.miss = TRUE,
  kmeans.initial = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="MCCCA_+3A_mccca.data">mccca.data</code></td>
<td>
<p>A list created in <code><a href="#topic+create.MCCCAdata">create.MCCCAdata</a></code>.</p>
</td></tr>
<tr><td><code id="MCCCA_+3A_k.vec">K.vec</code></td>
<td>
<p>An integer vector of length C (the number of classes). Each element corresponds to the number of clusters in each class specified for estimation.</p>
</td></tr>
<tr><td><code id="MCCCA_+3A_known.vec">known.vec</code></td>
<td>
<p>A vector of length C giving logical values indicating whether a cluster allocation in each class is known or not. The default is all <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="MCCCA_+3A_knowncluster.list">knowncluster.list</code></td>
<td>
<p>A vector of length C giving logical values indicating whether a cluster allocation in each class is known or not. The default is all <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="MCCCA_+3A_nstart">nstart</code></td>
<td>
<p>An integer indicating the number of random initial values.</p>
</td></tr>
<tr><td><code id="MCCCA_+3A_maxit">maxit</code></td>
<td>
<p>An integer indicating the maximum number of iterations.</p>
</td></tr>
<tr><td><code id="MCCCA_+3A_p">p</code></td>
<td>
<p>An integer indicating the dimension of quantification.The default is 2.</p>
</td></tr>
<tr><td><code id="MCCCA_+3A_tol">tol</code></td>
<td>
<p>A numeric value indicating the absolute convergence tolerance.</p>
</td></tr>
<tr><td><code id="MCCCA_+3A_verbose">verbose</code></td>
<td>
<p>A logical value indicating. If <code>TRUE</code>, tracing information on the progress of the optimization is produced.</p>
</td></tr>
<tr><td><code id="MCCCA_+3A_remove.miss">remove.miss</code></td>
<td>
<p>A logical value indicating whether categories nobody choose are removed nor not. The default is <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="MCCCA_+3A_kmeans.initial">kmeans.initial</code></td>
<td>
<p>A logical value indicating whether the 1st initial value for indicator matrix is generated by kmeans or not. The default is <code>TRUE</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>Bg</code>,<code>Gg</code> and <code>Qg</code> are scaled <code>B</code>,<code>G</code> and <code>Q</code> respectively, such that the average squared deviation from the origin of the row and column points is the same (See section 2.3 in the paper).
</p>
<p>If you want to specify the cluster allocation for some or all classes, prepare the following two.
</p>
<p>-<code>knowncluster.list</code>: A list of C vectors. The length of each vector in the list should be the same as the number of rows in each matrix in the <code>data.list</code>
(ex. <code>length(knowncluster.list[[c]])=nrow(data.list[[c]])</code>, (c=1,..,C)).
For example, suppose that <code>data.list</code> is a list of 4 matrices (meaning C=4),
and the cluster assignment is known only for the second class,
and the assignments in other classes are estimated. In this case,
the second vector of <code>knowncluster.list</code> should be specified as the vector of cluster indexes
to which the observations in each row of <code>data.list[[2]]</code> belong, with length <code>nrow(data.list[[2]])</code>,
and the other vectors (1, 3, and 4) in the list can be specified as <code>NA</code>. For each vector in the <code>knowncluster.list</code>,
the specified cluster index should start from 1, and there should not be any skipping numbers.
</p>
<p>-<code>known.vec</code>: A vector of logical values of length C. For example,
if C=4 and you want to know the cluster assignment of only the second class, it should be <code>known.vec=c(FALSE,TRUE,FALSE,FALSE)</code>.
</p>


<h3>Value</h3>

<p>Returns a list with the following elements.
</p>
<table>
<tr><td><code>G</code></td>
<td>
<p>A (Kxp) quantification matrix for all clusters (K=<code>sum(K.vec)</code>).</p>
</td></tr>
<tr><td><code>Gg</code></td>
<td>
<p>Scaled <code>G</code>. See details.</p>
</td></tr>
<tr><td><code>B</code></td>
<td>
<p>A (Qxp) quantification matrix for all categories (Q=<code>sum(q.vec)</code>, and <code>q.vec</code> is given in <code>create.MCCCAdata</code>).</p>
</td></tr>
<tr><td><code>Bg</code></td>
<td>
<p>Scaled <code>B</code>.</p>
</td></tr>
<tr><td><code>Q</code></td>
<td>
<p>A (Nxp) quantification matrix for all observations.</p>
</td></tr>
<tr><td><code>Qg</code></td>
<td>
<p>Scaled <code>Q</code>.</p>
</td></tr>
<tr><td><code>clses.list</code></td>
<td>
<p>A list of C vectors, giving the estimated cluster index for each observation in each class.</p>
</td></tr>
<tr><td><code>clses.vec</code></td>
<td>
<p>A vector of length N, where each element represents the cluster index to which the observations in the rows of <code>data.mat</code> (given in <code>mccca.data</code>) belong.</p>
</td></tr>
<tr><td><code>optval</code></td>
<td>
<p>A numeric value giving the optimized value of the objective function that is the smallest among all initial values.</p>
</td></tr>
<tr><td><code>optval.vec</code></td>
<td>
<p>A numeric vector of length <code>nstart</code> giving the optimized values of the objective function for each initial value.</p>
</td></tr>
<tr><td><code>stepconv</code></td>
<td>
<p>An integer giving the number of iterations until convergence at the initial value where the objective function was the smallest.</p>
</td></tr>
<tr><td><code>stepconv.vec</code></td>
<td>
<p>An integer vector of length <code>nstart</code> giving the number of iterations until convergence for each initial value.</p>
</td></tr>
<tr><td><code>catename.vec</code></td>
<td>
<p>A characteristic vector of length <code>Q</code> that combines the category names of each categorical variable into a single vector.</p>
</td></tr>
<tr><td><code>catename.vari.vec</code></td>
<td>
<p>A characteristic vector of length <code>Q</code> with <code>catename.vec</code> plus the name of categorical variable (by default, this is used as the column name of <code>B</code> and <code>Bg</code>).</p>
</td></tr>
<tr><td><code>cate.removed</code></td>
<td>
<p>If there is a category that no one chooses and <code>remove.miss</code>=TRUE, <code>cate.removed</code> gives which category was removed (given by the index of column in dummy matrix). Otherwise, return <code>NULL</code>.</p>
</td></tr>
<tr><td><code>cluster.vec</code></td>
<td>
<p>An integer vector of length K, where each index in the <code>clses.list</code> and <code>clses.vec</code> indicates which class it corresponds to.</p>
</td></tr>
<tr><td><code>q.vec</code></td>
<td>
<p>A vector of length J, same as the one given in <code>mccca.data</code>.</p>
</td></tr>
<tr><td><code>K.vec</code></td>
<td>
<p>A vector of length C, which is used as an input in this <code>MCCCA</code> function.</p>
</td></tr>
<tr><td><code>classlabel</code></td>
<td>
<p>A characteristic vector of length C, same as the one given in <code>mccca.data</code>.</p>
</td></tr>
</table>


<h3>References</h3>

<p>Takagishi &amp; Michel van de Velden (2022): Visualizing Class Specific
Heterogeneous Tendencies in Categorical Data, Journal of Computational and Graphical Statistics,
DOI: 10.1080/10618600.2022.2035737
</p>


<h3>See Also</h3>

<p><code><a href="#topic+create.MCCCAdata">create.MCCCAdata</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#setting
N &lt;- 100 ; J &lt;- 5 ; Ktrue &lt;- 2 ; q.vec &lt;- rep(5,J) ; noise.prop &lt;- 0.2
extcate.vec=c(2,3)#the number of categories for each external variable

#generate categorical variable data
catedata.list &lt;- generate.onedata(N=N,J=J,Ktrue=Ktrue,q.vec=q.vec,noise.prop = noise.prop)
data.cate=catedata.list$data.mat
clstr0.vec=catedata.list$clstr0.vec

#generate external variable data
data.ext=generate.ext(N,extcate.vec=extcate.vec)

#create mccca.list to be applied to MCCCA function
mccca.data=create.MCCCAdata(data.cate,ext.mat=data.ext,clstr0.vec =clstr0.vec)

#specify the number of cluster for each of C classes
C=length(mccca.data$data.list)
K.vec=rep(2,C)

#apply MCCCA
mccca.res=MCCCA(mccca.data,K.vec=K.vec)

#plot MCCCA result
plot(mccca.res)

#if you want to specify cluster allocation in the 2nd class:
knowncluster.list=rep(list(NA),C)
#specify cluster index for the 2nd class
N2=nrow(mccca.data$data.list[[2]])
knowncluster.list[[2]]=rep(c(1,2),times=c(2,N2-2))
known.vec=c(FALSE,TRUE,FALSE,FALSE,FALSE,FALSE)
mccca.res=MCCCA(mccca.data,K.vec=K.vec,known.vec=known.vec,knowncluster.list = knowncluster.list)
</code></pre>

<hr>
<h2 id='plot.mccca'>plot <code>mccca</code> object.</h2><span id='topic+plot.mccca'></span>

<h3>Description</h3>

<p>plot <code>mccca</code> object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'mccca'
plot(
  x,
  main = "MCCCA result",
  catelabel = NULL,
  classlabel = NULL,
  classlabel.legend = NULL,
  xlim = NULL,
  ylim = NULL,
  sort.clssize = TRUE,
  break.size = NULL,
  output.coord = FALSE,
  connect.cord = TRUE,
  include.variname = TRUE,
  scale.gamma = TRUE,
  scatter.level = 2,
  plot.setting = list(alp.point = 0.3, alp.seg = 0.8, txtsize = 3, txtsize.legend = 10),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.mccca_+3A_x">x</code></td>
<td>
<p>An object of class <code>mccca</code>, a list of <code>MCCCA</code> outputs.</p>
</td></tr>
<tr><td><code id="plot.mccca_+3A_main">main</code></td>
<td>
<p>A character giving the title of biplot.</p>
</td></tr>
<tr><td><code id="plot.mccca_+3A_catelabel">catelabel</code></td>
<td>
<p>A characteristic vector of length Q giving labels for all categories to be displayed on the biplot (Q=<code>sum(q.vec)</code>). If <code>NULL</code>, <code>rownames(B)</code> are used.</p>
</td></tr>
<tr><td><code id="plot.mccca_+3A_classlabel">classlabel</code></td>
<td>
<p>A characteristic vector of length C (C:the number of class) giving labels for all classes to be displayed on the biplot. If <code>NULL</code>, labels specified in <code>create.MCCCAdata</code> are used.</p>
</td></tr>
<tr><td><code id="plot.mccca_+3A_classlabel.legend">classlabel.legend</code></td>
<td>
<p>A characteristic vector of length C giving labels for all classes to be used on the legend (this can be longer). If <code>NULL</code>, <code>classlabel</code> is used.</p>
</td></tr>
<tr><td><code id="plot.mccca_+3A_xlim">xlim</code></td>
<td>
<p>A numeric vector of length 2 giving the range of plot on the x (horizontal) axis. If NULL, the range is automatically determined.</p>
</td></tr>
<tr><td><code id="plot.mccca_+3A_ylim">ylim</code></td>
<td>
<p>A numeric vector of length 2 for the y (vertical) axis (same role as <code>xlim</code>).</p>
</td></tr>
<tr><td><code id="plot.mccca_+3A_sort.clssize">sort.clssize</code></td>
<td>
<p>If <code>TRUE</code>, the class-specific cluster numbers are sorted in the order of cluster size. The default is <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="plot.mccca_+3A_break.size">break.size</code></td>
<td>
<p>An integer vector that adjusts the size of bubble displayed on the legend.</p>
</td></tr>
<tr><td><code id="plot.mccca_+3A_output.coord">output.coord</code></td>
<td>
<p>If <code>TRUE</code>, the output will be <code>Cocls.mat</code> and <code>Cocate.mat</code>. See value.</p>
</td></tr>
<tr><td><code id="plot.mccca_+3A_connect.cord">connect.cord</code></td>
<td>
<p>If <code>TRUE</code>, lines are drawn between original (estimated by MCCCA) coordinates and coordinates moved to avoid overlap.</p>
</td></tr>
<tr><td><code id="plot.mccca_+3A_include.variname">include.variname</code></td>
<td>
<p>If <code>TRUE</code>, variable name is included in category labels in the biplot (ex.a point of category &quot;male&quot; in &quot;v1&quot;(the name of 1st variable) is displayed as &quot;v1:male&quot; on the biplot).</p>
</td></tr>
<tr><td><code id="plot.mccca_+3A_scale.gamma">scale.gamma</code></td>
<td>
<p>If <code>TRUE</code>, quantifications are scaled such that the average squared deviation from the origin of the row and column points is the same (See section 2.3 in the paper).</p>
</td></tr>
<tr><td><code id="plot.mccca_+3A_scatter.level">scatter.level</code></td>
<td>
<p>A numeric value that adjusts the scatter of points in the biplot. The higher the value, the more scattered the points are. The default is 2.</p>
</td></tr>
<tr><td><code id="plot.mccca_+3A_plot.setting">plot.setting</code></td>
<td>
<p>A list of biplot settings. See details.</p>
</td></tr>
<tr><td><code id="plot.mccca_+3A_...">...</code></td>
<td>
<p>Additional arguments passed to <code><a href="base.html#topic+print">print</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Parameters in <code>plot.setting</code> are as follows:
</p>
<p>-<code>alp.point</code>:A numeric value from 0 to 1 which adjusts the transparency of the bubble point. The default is 0.3.
</p>
<p>-<code>alp.seg</code>:A numeric value from 0 to 1 which adjusts the transparency of the segments between texts and points. The default is 0.8.
</p>
<p>-<code>txtsize</code>:A numeric value which adjusts the textsize on the biplot. The default is 3.
</p>
<p>-<code>txtsize.legend</code>:A numeric value which adjusts the textsize of the legend on the biplot. The default is 10.
</p>


<h3>Value</h3>

<p>If <code>output.coord</code> is <code>TRUE</code>, returns a list with the following elements.
</p>
<table>
<tr><td><code>Cocls.mat</code></td>
<td>
<p>A (Kx4) coordinate matrix of clusters, where the last two columns are the coordinates estimated by MCCCA, and the first two columns are the coordinates moved from the estimated coordinates to prevent overlap.</p>
</td></tr>
<tr><td><code>Cocate.mat</code></td>
<td>
<p>A (Kx4) coordinate matrix of categories (each column plays the same role as <code>Cocls.mat</code>) </p>
</td></tr>
</table>


<h3>References</h3>

<p>Takagishi &amp; Michel van de Velden (2022): Visualizing Class Specific
Heterogeneous Tendencies in Categorical Data, Journal of Computational and Graphical Statistics,
DOI: 10.1080/10618600.2022.2035737
</p>


<h3>See Also</h3>

<p><code><a href="#topic+MCCCA">MCCCA</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#setting
N &lt;- 100 ; J &lt;- 5 ; Ktrue &lt;- 2 ; q.vec &lt;- rep(5,J) ; noise.prop &lt;- 0.2
extcate.vec=c(2,3)#the number of categories for each external variable

#generate categorical variable data
catedata.list &lt;- generate.onedata(N=N,J=J,Ktrue=Ktrue,q.vec=q.vec,noise.prop = noise.prop)
data.cate=catedata.list$data.mat
clstr0.vec=catedata.list$clstr0.vec
#generate external variable data
data.ext=generate.ext(N,extcate.vec=extcate.vec)

#create mccca.list to be applied to MCCCA function
mccca.data=create.MCCCAdata(data.cate,ext.mat=data.ext,clstr0.vec =clstr0.vec)

#specify the number of cluster for each of C classes
C=length(mccca.data$data.list)
K.vec=rep(2,C)
#apply MCCCA
mccca.res=MCCCA(mccca.data,K.vec=K.vec)

#plot MCCCA result
plot(mccca.res)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
