<!DOCTYPE html><html><head><title>Help for package GLDEX</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {GLDEX}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='# Fitting functions '><p> This is a collection of functions designed to implement the fitting</p>
algorithms for all the methods covered
in this package.</a></li>
<li><a href='# FMKL fitting and basic functions '><p> This is a collection of functions designed to find the initial values</p>
under the method of moments for FMKL
generalised lambda distribution. It also includes basic FMKL GLD functions.</a></li>
<li><a href='# Hidden basic functions '><p> This is a collection of functions designed to implement the basic GLD</p>
functions.</a></li>
<li><a href='# RS fitting and basic functions '><p> This is a collection of functions designed to find the initial values of</p>
method of moments for RS
generalised lambda distribution. It also includes basic RS GLD functions.</a></li>
<li><a href='#digitsBase'><p>Digit/Bit Representation of Integers in any Base</p></a></li>
<li><a href='#fun.auto.bimodal.ml'><p> Fitting mixture of generalied lambda distribtions to data using maximum</p>
likelihood estimation via the EM algorithm</a></li>
<li><a href='#fun.auto.bimodal.pml'><p> Fitting mixture of generalied lambda distribtions to data using</p>
parition maximum likelihood estimation</a></li>
<li><a href='#fun.auto.bimodal.qs'><p> Fitting mixtures of generalied lambda distribtions to data using</p>
quantile matching method</a></li>
<li><a href='#fun.beta'><p> This is a collection of functions used in the calculation of the beta</p>
function.</a></li>
<li><a href='#fun.bimodal.fit.ml'><p> Finds the final fits using the maximum likelihood estimation for the</p>
bimodal dataset.</a></li>
<li><a href='#fun.bimodal.fit.pml'><p> Finds the final fits using partition maximum likelihood estimation for</p>
the bimodal dataset.</a></li>
<li><a href='#fun.bimodal.init'><p> Finds the initial values for optimisation in fitting the bimodal</p>
generalised lambda distribution.</a></li>
<li><a href='#fun.check.gld'>
<p>Check whether the RS or FMKL/FKML GLD is a valid GLD for single values of L1,</p>
L2, L3 and L4</a></li>
<li><a href='#fun.check.gld.multi'>
<p>Check whether the RS or FMKL/FKML GLD is a valid GLD for vectors of L1, L2, L3</p>
and L4</a></li>
<li><a href='#fun.class.regime.bi'><p> Classifies data into two groups using a clustering regime.</p></a></li>
<li><a href='#fun.comp.moments.ml'><p> Compare the moments of the data and the fitted univariate generalised</p>
lambda distribution.</a></li>
<li><a href='#fun.comp.moments.ml.2'><p> Compare the moments of the data and the fitted univariate generalised</p>
lambda distribution. Specialised funtion designed for RMFMKL.ML and STAR
methods.</a></li>
<li><a href='#fun.data.fit.hs'><p> Fit RS and FMKL generalised distributions to data using discretised</p>
approach with weights.</a></li>
<li><a href='#fun.data.fit.hs.nw'><p> Fit RS and FMKL generalised distributions to data using discretised</p>
approach without weights.</a></li>
<li><a href='#fun.data.fit.lm'><p> Fit data using L moment matching estimation for RS and FMKL GLD</p></a></li>
<li><a href='#fun.data.fit.ml'><p> Fit data using RS, FMKL maximum likelihood estimation and the FMKL</p>
starship method.</a></li>
<li><a href='#fun.data.fit.mm'><p> Fit data using moment matching estimation for RS and FMKL GLD</p></a></li>
<li><a href='#fun.data.fit.qs'><p> Fit data using quantile matching estimation for RS and FMKL GLD</p></a></li>
<li><a href='#fun.diag.ks.g'><p> Compute the simulated Kolmogorov-Smirnov tests for the unimodal</p>
dataset</a></li>
<li><a href='#fun.diag.ks.g.bimodal'><p> Compute the simulated Kolmogorov-Smirnov tests for the bimodal dataset</p></a></li>
<li><a href='#fun.diag1'><p> Diagnostic function for theoretical distribution fits through the</p>
resample Kolmogorov-Smirnoff tests</a></li>
<li><a href='#fun.diag2'><p> Diagnostic function for empirical data distribution fits through the</p>
resample Kolmogorov-Smirnoff tests</a></li>
<li><a href='#fun.disc.estimation'><p> Estimates the mean and variance after cutting up a vector of variable</p>
into evenly spaced categories.</a></li>
<li><a href='#fun.gen.qrn'><p> Finds the low discrepancy quasi random numbers</p></a></li>
<li><a href='#fun.lm.theo.gld'><p> Find the theoretical first four L moments of the generalised lambda</p>
distribution.</a></li>
<li><a href='#fun.mApply'><p> Applying functions based on an index for a matrix.</p></a></li>
<li><a href='#fun.minmax.check.gld'>
<p>Check whether the specified GLDs cover the minimum and the maximum values in a</p>
dataset</a></li>
<li><a href='#fun.moments.bimodal'><p> Finds the moments of fitted mixture of</p>
generalised lambda distribution by simulation.</a></li>
<li><a href='#fun.moments.r'><p> Calculate mean, variance, skewness and kurtosis of a numerical vector</p></a></li>
<li><a href='#fun.nclass.e'><p> Estimates the number of classes or bins to smooth over in the</p>
discretised method of fitting generalised lambda distribution to data.</a></li>
<li><a href='#fun.plot.fit'><p> Plotting the univariate generalised lambda distribution fits on the data</p>
set.</a></li>
<li><a href='#fun.plot.fit.bm'><p> Plotting mixture of two generalised lambda distributions on the</p>
data set.</a></li>
<li><a href='#fun.plot.many.gld'><p> Plotting many univariate generalised lambda distributions on one page.</p></a></li>
<li><a href='#fun.rawmoments'><p> Computes the raw moments of the generalised lambda distribution up to</p>
4th order.</a></li>
<li><a href='#fun.RMFMKL.hs'><p> Fit FMKL generalised distribution to data using discretised approach</p>
with weights.</a></li>
<li><a href='#fun.RMFMKL.hs.nw'><p> Fit FMKL generalised distribution to data using discretised approach</p>
without weights.</a></li>
<li><a href='#fun.RMFMKL.lm'><p> Fit FMKL generalised lambda distribution to data set using L moment</p>
matching</a></li>
<li><a href='#fun.RMFMKL.ml'><p> Fit FMKL generalised lambda distribution to data set using maximum</p>
likelihood estimation</a></li>
<li><a href='#fun.RMFMKL.ml.m'>
<p>Fit RS generalised lambda distribution to data set using maximum</p>
likelihood estimation</a></li>
<li><a href='#fun.RMFMKL.mm'><p> Fit FMKL generalised lambda distribution to data set using moment</p>
matching</a></li>
<li><a href='#fun.RMFMKL.qs'><p> Fit FMKL generalised lambda distribution to data set using quantile</p>
matching</a></li>
<li><a href='#fun.RPRS.hs'><p> Fit RS generalised distribution to data using discretised approach with</p>
weights.</a></li>
<li><a href='#fun.RPRS.hs.nw'><p> Fit RS generalised distribution to data using discretised approach</p>
without weights.</a></li>
<li><a href='#fun.RPRS.lm'><p> Fit RS generalised lambda distribution to data set using L moment</p>
matching</a></li>
<li><a href='#fun.RPRS.ml'><p> Fit RS generalised lambda distribution to data set using maximum</p>
likelihood estimation</a></li>
<li><a href='#fun.RPRS.ml.m'>
<p>Fit RS generalised lambda distribution to data set using maximum</p>
likelihood estimation</a></li>
<li><a href='#fun.RPRS.mm'><p> Fit RS generalised lambda distribution to data set using moment</p>
matching</a></li>
<li><a href='#fun.RPRS.qs'><p> Fit RS generalised lambda distribution to data set using quantile</p>
matching</a></li>
<li><a href='#fun.simu.bimodal'><p> Simulate a mixture of two generalised lambda distributions.</p></a></li>
<li><a href='#fun.theo.bi.mv.gld'><p> Calculates the theoretical mean, variance, skewness and kurtosis for</p>
mixture of two generalised lambda distributions.</a></li>
<li><a href='#fun.theo.mv.gld'><p> Find the theoretical first four moments of the generalised lambda</p>
distribution.</a></li>
<li><a href='#fun.which.zero'><p> Determine which values are zero.</p></a></li>
<li><a href='#fun.zero.omit'><p> Returns a vector after removing all the zeros.</p></a></li>
<li><a href='#gl.check.lambda.alt'><p> Checks whether the parameters provided constitute a valid generalised</p>
lambda distribution.</a></li>
<li><a href='#gl.check.lambda.alt1'><p> Checks whether the parameters provided constitute a valid generalised</p>
lambda distribution.</a></li>
<li><a href='#GLD functions'><p> The Generalised Lambda Distribution Family</p></a></li>
<li><a href='#GLDEX-package'>
<p>This package fits RS and FMKL generalised lambda distributions using</p>
various methods. It also provides functions for fitting bimodal
distributions using mixtures of generalised lambda distributions.</a></li>
<li><a href='#histsu'><p> Histogram with exact number of bins specified by the user</p></a></li>
<li><a href='#is.inf'><p> Returns a logical vecto, TRUE if the value is Inf or -Inf.</p></a></li>
<li><a href='#is.notinf'><p> Returns a logical vector TRUE, if the value is not Inf or -Inf.</p></a></li>
<li><a href='#ks.gof'><p> Kolmogorov-Smirnov test</p></a></li>
<li><a href='#Lmoments'><p>L-moments</p></a></li>
<li><a href='#Optimisation functions'><p> This is a collection of functions used in the optimisation processes for</p>
all the fitting
methods covered in this package.</a></li>
<li><a href='#pretty.su'><p> An alternative to the normal pretty function in R.</p></a></li>
<li><a href='#qqplot.gld'><p> Do a quantile plot on the univariate distribution fits.</p></a></li>
<li><a href='#qqplot.gld.bi'><p> Do a quantile plot on the bimodal distribution fits.</p></a></li>
<li><a href='#QUnif'><p>Quasi Randum Numbers via Halton Sequences</p></a></li>
<li><a href='#skewness and kurtosis'><p> Compute skewness and kurtosis statistics</p></a></li>
<li><a href='#starship'><p>Carry out the &ldquo;starship&rdquo; estimation method for the generalised</p>
lambda distribution</a></li>
<li><a href='#starship.adaptivegrid'><p>Carry out the &ldquo;starship&rdquo; estimation method for the generalised</p>
lambda distribution using a grid-based search</a></li>
<li><a href='#starship.obj'><p>Objective function that is minimised in starship estimation method</p></a></li>
<li><a href='#t1lmoments'><p>Trimmed L-moments</p></a></li>
<li><a href='#which.na'><p> Determine Missing Values</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Version:</td>
<td>2.0.0.9.3</td>
</tr>
<tr>
<td>Date:</td>
<td>2023-08-21</td>
</tr>
<tr>
<td>Title:</td>
<td>Fitting Single and Mixture of Generalised Lambda Distributions</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Steve Su &lt;allegro.su@gmail.com&gt;</td>
</tr>
<tr>
<td>Depends:</td>
<td>cluster, grDevices, graphics, stats, spacefillr</td>
</tr>
<tr>
<td>Description:</td>
<td>The fitting algorithms considered in this package have two major objectives. One is to provide a smoothing device to fit distributions to data using the weight and unweighted discretised approach based on the bin width of the histogram. The other is to provide a definitive fit to the data set using the maximum likelihood and quantile matching estimation. Other methods such as moment matching, starship method, L moment matching are also provided. Diagnostics on goodness of fit can be done via qqplots, KS-resample tests and comparing mean, variance, skewness and kurtosis of the data with the fitted distribution. References include the following: Karvanen and Nuutinen (2008) "Characterizing the generalized lambda distribution by L-moments" &lt;<a href="https://doi.org/10.1016%2Fj.csda.2007.06.021">doi:10.1016/j.csda.2007.06.021</a>&gt;, King and MacGillivray (1999) "A starship method for fitting the generalised lambda distributions" &lt;<a href="https://doi.org/10.1111%2F1467-842X.00089">doi:10.1111/1467-842X.00089</a>&gt;, Su (2005) "A Discretized Approach to Flexibly Fit Generalized Lambda Distributions to Data" &lt;<a href="https://doi.org/10.22237%2Fjmasm%2F1130803560">doi:10.22237/jmasm/1130803560</a>&gt;, Su (2007) "Nmerical Maximum Log Likelihood Estimation for Generalized Lambda Distributions" &lt;<a href="https://doi.org/10.1016%2Fj.csda.2006.06.008">doi:10.1016/j.csda.2006.06.008</a>&gt;, Su (2007) "Fitting Single and Mixture of Generalized Lambda Distributions to Data via Discretized and Maximum Likelihood Methods: GLDEX in R" &lt;<a href="https://doi.org/10.18637%2Fjss.v021.i09">doi:10.18637/jss.v021.i09</a>&gt;, Su (2009) "Confidence Intervals for Quantiles Using Generalized Lambda Distributions" &lt;<a href="https://doi.org/10.1016%2Fj.csda.2009.02.014">doi:10.1016/j.csda.2009.02.014</a>&gt;, Su (2010) "Chapter 14: Fitting GLDs and Mixture of GLDs to Data using Quantile Matching Method" &lt;<a href="https://doi.org/10.1201%2Fb10159">doi:10.1201/b10159</a>&gt;, Su (2010) "Chapter 15: Fitting GLD to data using GLDEX 1.0.4 in R" &lt;<a href="https://doi.org/10.1201%2Fb10159">doi:10.1201/b10159</a>&gt;, Su (2015)   "Flexible Parametric Quantile Regression Model" &lt;<a href="https://doi.org/10.1007%2Fs11222-014-9457-1">doi:10.1007/s11222-014-9457-1</a>&gt;, Su (2021) "Flexible parametric accelerated failure time model"&lt;<a href="https://doi.org/10.1080%2F10543406.2021.1934854">doi:10.1080/10543406.2021.1934854</a>&gt;.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL (&ge; 3)</a></td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-08-20 23:06:07 UTC; allegro</td>
</tr>
<tr>
<td>Author:</td>
<td>Steve Su <a href="https://orcid.org/0000-0002-3368-4926"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [aut,
    cre, cph],
  Martin Maechler [aut],
  Juha Karvanen [aut],
  Robert King [aut],
  Benjamin Dean [ctb],
  R Core Team [aut]</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-08-21 04:02:41 UTC</td>
</tr>
</table>
<hr>
<h2 id='+20Fitting+20functions+20'> This is a collection of functions designed to implement the fitting 
algorithms for all the methods covered
in this package. </h2><span id='topic+fun.fit.gl.v2a.nw'></span><span id='topic+fun.fit.gl.v2a'></span><span id='topic+fun.fit.gl.v2b.nw'></span><span id='topic+fun.fit.gl.v2b'></span><span id='topic+fun.fit.gl.v3'></span><span id='topic+fun.fit.gl.v3a'></span><span id='topic+fun.fit.gl.v3m'></span><span id='topic+fun.fit.gl.v4'></span><span id='topic+fun.fit.gl.v4a'></span><span id='topic+fun.fit.gl.v6'></span><span id='topic+fun.fit.gl.v6a'></span><span id='topic+fun.fit.gl.v.lm'></span><span id='topic+fun.fit.gl.v.lma'></span>

<h3>Description</h3>

<p>These functions are for maintainers only and it is not designed for the users 
of this package.
</p>


<h3>Value</h3>

<p> List of unique optimisation parameters and objective values under different fitting methods, not intended to be used directly by users of this package </p>


<h3>Note</h3>

<p> Please contact the author directly if you find a bug! </p>


<h3>Author(s)</h3>

<p> Steve Su </p>

<hr>
<h2 id='+20FMKL+20fitting+20and+20basic+20functions+20'> This is a collection of functions designed to find the initial values 
under the method of moments for FMKL
generalised lambda distribution. It also includes basic FMKL GLD functions. </h2><span id='topic+fun.auto.mm.fmkl'></span><span id='topic+fun.fmkl.mm.min'></span><span id='topic+fun.fmkl.mm.sol.alt'></span><span id='topic+fun.fmkl.mm.sol'></span><span id='topic+fun.fmkl.sol'></span><span id='topic+fun.fmkl.nr'></span><span id='topic+fun.fmkl'></span><span id='topic+fun.fmkla'></span><span id='topic+fun.fmklb'></span><span id='topic+fun.fmkl0'></span><span id='topic+fun.fmkl.L30'></span><span id='topic+fun.fmkl.L40'></span><span id='topic+fun.Lm.gt.2.fmkl'></span><span id='topic+fun.moments'></span>

<h3>Description</h3>

<p>These functions are for maintainers only and it is not designed for the users 
of this package.
</p>


<h3>Value</h3>

<p> List of computation results for various fitting algorithms, not intended to be used by users of this package </p>


<h3>Note</h3>

<p> Please contact the author directly if you find a bug! </p>


<h3>Author(s)</h3>

<p> Steve Su </p>

<hr>
<h2 id='+20Hidden+20basic+20functions+20'> This is a collection of functions designed to implement the basic GLD 
functions. </h2><span id='topic+.gl.parameter.tidy'></span><span id='topic+.qdgl.fmkl'></span><span id='topic+.qdgl.rs'></span><span id='topic+.qgl.rs'></span><span id='topic+.qgl.fmkl'></span><span id='topic+.qgl.fmkl'></span><span id='topic+C_check_gld'></span><span id='topic+C_dgl'></span><span id='topic+C_mult_check_gld'></span><span id='topic+C_optim_fun3'></span><span id='topic+C_optim_fun3_v'></span><span id='topic+C_pgl'></span><span id='topic+C_q_fmkl_gld_minmax_check'></span><span id='topic+C_q_rs_gld_minmax_check'></span>

<h3>Description</h3>

<p>These functions are for maintainers only and it is not designed for the users of 
this package.
</p>


<h3>Value</h3>

<p> Various basic calculations for generalised lambda distributions, not intended to be used by users of this package </p>


<h3>Note</h3>

<p> Please contact the author directly if you find a bug! </p>


<h3>Author(s)</h3>

<p> Steve Su </p>

<hr>
<h2 id='+20RS+20fitting+20and+20basic+20functions+20'> This is a collection of functions designed to find the initial values of 
method of moments for RS
generalised lambda distribution. It also includes basic RS GLD functions. </h2><span id='topic+fun.auto.perc.rs'></span><span id='topic+fun.lambda.percentile'></span><span id='topic+fun.percentile'></span><span id='topic+fun.rs.nr'></span><span id='topic+fun.rs.perc.gradient'></span><span id='topic+fun.rs.perc.min'></span><span id='topic+fun.rs.perc.sol.alt'></span><span id='topic+fun.rs.perc.sol'></span><span id='topic+fun.rsb'></span><span id='topic+fun.Lm.gt.2.rs'></span>

<h3>Description</h3>

<p>These functions are for maintainers only and it is not designed for the users of 
this package.
</p>


<h3>Value</h3>

<p> List of computation results for various fitting algorithms, not intended to be used by users of this package </p>


<h3>Note</h3>

<p> Please contact the author directly if you find a bug! </p>


<h3>Author(s)</h3>

<p> Steve Su </p>

<hr>
<h2 id='digitsBase'>Digit/Bit Representation of Integers in any Base</h2><span id='topic+digitsBase'></span>

<h3>Description</h3>

<p>Integer number representations in other Bases.
</p>
<p>Formally, for every element <code class="reqn">N =</code><code>x[i]</code>, compute the (vector
of) &ldquo;digits&rdquo; <code class="reqn">A</code> of the <code>base</code> <code class="reqn">b</code>
representation of the number <code class="reqn">N</code>, <code class="reqn">N = \sum_{k=0}^M  A_{M-k} b ^ k</code>.<br />
Revert such a representation to integers.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>digitsBase(x, base = 2, ndigits = 1 + floor(log(max(x), base)))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="digitsBase_+3A_x">x</code></td>
<td>
<p>For <code>digitsBase()</code>: non-negative integer (vector) whose
base <code>base</code> digits are wanted.
</p>
<p>For <code>as.intBase()</code>: <br /> a list of numeric vectors, a character
vector, or an integer matrix as returned by <code>digitsBase()</code>,
representing digits in base <code>base</code>.
</p>
</td></tr>
<tr><td><code id="digitsBase_+3A_base">base</code></td>
<td>
<p>integer, at least 2 specifying the base for representation.</p>
</td></tr>
<tr><td><code id="digitsBase_+3A_ndigits">ndigits</code></td>
<td>
<p>number of bits/digits to use.</p>
</td></tr> 
</table>


<h3>Value</h3>

<p>For <code>digitsBase()</code>, an object, say <code>m</code>, of class
<code>"basedInt"</code> which is basically a (<code>ndigits</code> x <code>n</code>)
<code><a href="base.html#topic+matrix">matrix</a></code> where <code>m[,i]</code> corresponds to <code>x[i]</code>,
<code>n &lt;- length(x)</code> and <code>attr(m,"base")</code> is the input
<code>base</code>.
</p>
<p><code>as.intBase()</code> and the <code><a href="base.html#topic+as.integer">as.integer</a></code> method for
<code>basedInt</code> objects return an <code><a href="base.html#topic+integer">integer</a></code> vector.
</p>


<h3>Note</h3>

<p><code>digits</code> and <code>digits.v</code> are now deprecated and will be
removed from the <span class="pkg">sfsmisc</span> package.
</p>


<h3>Author(s)</h3>

<p>Martin Maechler, Dec 4, 1991 (for S-plus; then called <code>digits.v</code>).</p>


<h3>Examples</h3>

<pre><code class='language-R'>digitsBase(0:12, 8) #-- octal representation

## This may be handy for just one number (and default decimal):
digits &lt;- function(n, base = 10) as.vector(digitsBase(n, base = base))
digits(128, base = 8) # 2 0 0

## one way of pretty printing (base &lt;= 10!)
b2ch &lt;- function(db)
        noquote(gsub("^0+(.{1,})$"," \1", apply(db, 2, paste, collapse = "")))
b2ch(digitsBase(0:33, 2))  #-&gt;  0 1 10 11 100 101 ... 100001
b2ch(digitsBase(0:33, 4))  #-&gt;  0 1 2 3 10 11 12 13 20 ... 200 201

## Hexadecimal:
i &lt;- c(1:20, 100:106)
M &lt;- digitsBase(i, 16)
hexdig &lt;- c(0:9, LETTERS[1:6])
cM &lt;- hexdig[1 + M]; dim(cM) &lt;- dim(M)
b2ch(cM) #-&gt;  1  2  3  4  5  6  7  8  9  A  B  C  D  E  F 10 11 ... 6A

</code></pre>

<hr>
<h2 id='fun.auto.bimodal.ml'> Fitting mixture of generalied lambda distribtions to data using maximum 
likelihood estimation via the EM algorithm </h2><span id='topic+fun.auto.bimodal.ml'></span>

<h3>Description</h3>

<p>This function will fit mixture of generalised lambda distributions to dataset. 
It is restricted to two generalised lambda distributions. The method of fitting 
is maximum likelihood via EM algorithm. It is a two step optimization procedure, 
each unimodal part of the bimodal distribution is modelled using the maximum 
likelihood method or the starship method (FMKL GLD only), these initial values 
are the used to maximise the likelihood  for the entire bimodal distribution 
using the EM algorithm. It fits mixture of the form p*(f1)+(1-p)*(f2) where f1 
and f2 are pdfs of the generalised lambda distributions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fun.auto.bimodal.ml(data, per.of.mix = 0.01, clustering.m = clara, 
init1.sel = "rprs", init2.sel = "rprs", init1=c(-1.5, 1.5), init2=c(-1.5, 1.5), 
leap1=3, leap2=3,fun1="runif.sobol",fun2="runif.sobol",no=10000, max.it=5000,
optim.further="Y") 
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fun.auto.bimodal.ml_+3A_data">data</code></td>
<td>
<p> A numerical vector representing the dataset. </p>
</td></tr>
<tr><td><code id="fun.auto.bimodal.ml_+3A_per.of.mix">per.of.mix</code></td>
<td>
<p> Level of mix between two parts of the distribution, 
usually 1-2% of cross mix is sufficient. </p>
</td></tr>
<tr><td><code id="fun.auto.bimodal.ml_+3A_clustering.m">clustering.m</code></td>
<td>
<p> Clustering method used in classifying the dataset into 
two parts. Valid arguments include clara, fanny and pam from the cluster 
library. Default is clara. Or a logical vector specifying how data should
be split. </p>
</td></tr>
<tr><td><code id="fun.auto.bimodal.ml_+3A_init1.sel">init1.sel</code></td>
<td>
<p> This can be <code>"rprs"</code>, <code>"rmfmkl"</code> or <code>"star"</code>, 
the initial method used to fit the first distribution. </p>
</td></tr>
<tr><td><code id="fun.auto.bimodal.ml_+3A_init2.sel">init2.sel</code></td>
<td>
<p> This can be <code>"rprs"</code>, <code>"rmfmkl"</code> or <code>"star"</code>, 
the initial method used to fit the second distribution. </p>
</td></tr>
<tr><td><code id="fun.auto.bimodal.ml_+3A_init1">init1</code></td>
<td>
<p> Inititial values lambda3 and lambda4 for the first generalised 
lambda distribution. </p>
</td></tr>
<tr><td><code id="fun.auto.bimodal.ml_+3A_init2">init2</code></td>
<td>
<p> Inititial values lambda3 and lambda4 for the second generalised 
lambda distribution. </p>
</td></tr>
<tr><td><code id="fun.auto.bimodal.ml_+3A_leap1">leap1</code></td>
<td>
<p> See scrambling argument in <code><a href="#topic+fun.gen.qrn">fun.gen.qrn</a></code>. </p>
</td></tr>
<tr><td><code id="fun.auto.bimodal.ml_+3A_fun1">fun1</code></td>
<td>
<p> A character string of either  <code>"runif.sobol"</code> (default), <code>"runif.sobol.owen"</code>, 
<code>"runif.halton"</code> or <code>"QUnif"</code>. </p>
</td></tr>
<tr><td><code id="fun.auto.bimodal.ml_+3A_leap2">leap2</code></td>
<td>
<p> See scrambling argument in <code><a href="#topic+fun.gen.qrn">fun.gen.qrn</a></code>. </p>
</td></tr>
<tr><td><code id="fun.auto.bimodal.ml_+3A_fun2">fun2</code></td>
<td>
<p> A character string of either  <code>"runif.sobol"</code> (default), <code>"runif.sobol.owen"</code>, 
<code>"runif.halton"</code> or <code>"QUnif"</code>. </p>
</td></tr>
<tr><td><code id="fun.auto.bimodal.ml_+3A_no">no</code></td>
<td>
<p> Number of initial random values to find the best initial values 
for optimisation. </p>
</td></tr>
<tr><td><code id="fun.auto.bimodal.ml_+3A_max.it">max.it</code></td>
<td>
<p> Maximum number of iterations for numerical optimisation. </p>
</td></tr>
<tr><td><code id="fun.auto.bimodal.ml_+3A_optim.further">optim.further</code></td>
<td>
<p>Whether to optimise the function further using full 
maximum likelihood method, recommended setting is &quot;Y&quot;</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The initial values that work well for RPRS are <code>c(-1.5,1.5)</code> and for RMFMKL 
are <code>c(-0.25,1.5)</code>. For scrambling, if <code>1</code>, <code>2</code> or <code>3</code> the 
sequence is scrambled otherwise not. If <code>1</code>, Owen type type of scrambling 
is applied, if <code>2</code>, Faure-Tezuka type of scrambling, is applied, and if 
<code>3</code>, both Owen+Faure-Tezuka type of scrambling is applied. The <code>star</code> 
method uses the same initial values as <code>rmfmkl</code> since it uses the FMKL 
generalised lambda distribution. Nelder-Simplex algorithm is used in the 
numerical optimization. <code>rprs</code> stands for revised percentile method for 
RS generalised lambda distribution and &quot;rmfmkl&quot; stands for revised method of 
moment for FMKL generalised lambda distribution. These acronyms represents the 
initial optimization algorithm used to get a reasonable set of initial values 
for the subsequent optimization procedues.
This function is an improvement from Su (2007) in Journal of Statistical 
Software.
</p>


<h3>Value</h3>

<table>
<tr><td><code>par</code></td>
<td>
<p> The best set of parameters found, the first four corresponds to the 
first distribution fit, the second four corresponds to the second distribution 
fit, the last value correspond to p for the first distribution fit. </p>
</td></tr>
<tr><td><code>value</code></td>
<td>
<p> The value of -ML for the paramters obtained. </p>
</td></tr>
<tr><td><code>counts</code></td>
<td>
<p> A two-element integer vector giving the number of calls to 
<code>fn</code> and <code>gr</code> respectively. This excludes those calls needed to 
compute the Hessian, if requested, and any calls to <code>fn</code> to compute a 
finite-difference approximation to the gradient. </p>
</td></tr>
<tr><td><code>convergence</code></td>
<td>
 <p><code>0</code> indicates successful convergence, <code>1</code> 
indicates the iteration limit <code>maxit</code> had been reached, <code>10</code> indicates 
degeneracy of the Nelder-Mead simplex. </p>
</td></tr>
<tr><td><code>message</code></td>
<td>
<p> A character string giving any additional information returned by 
the optimizer, or <code>NULL</code>. </p>
</td></tr>
</table>


<h3>Note</h3>

<p> If the number of observations is small, 
<code>rprs</code> can sometimes fail as the percentiles may not exist for this data. 
Also, if the initial values do not span a valid generalised lambda distribution, 
try another set of initial values. </p>


<h3>Author(s)</h3>

<p> Steve Su </p>


<h3>References</h3>

 
<p>Bratley P. and Fox B.L. (1988) Algorithm 659: Implementing Sobol's quasi random 
sequence generator, ACM Transactions on Mathematical Software 14, 88-100.
</p>
<p>Joe S. and Kuo F.Y. (1998) Remark on Algorithm 659: Implementing Sobol's quasi 
random Sequence Generator.
</p>
<p>Nelder, J. A. and Mead, R. (1965) A simplex algorithm for function minimization. 
Computer Journal *7*, 308-313.
</p>
<p>Su (2007). Fitting Single and Mixture of Generalized Lambda Distributions to 
Data via Discretized and Maximum Likelihood Methods: GLDEX in R. 
Journal of Statistical Software: *21* 9.
</p>


<h3>See Also</h3>

 <p><code><a href="#topic+fun.auto.bimodal.pml">fun.auto.bimodal.pml</a></code>, <code><a href="#topic+fun.plot.fit.bm">fun.plot.fit.bm</a></code>, 
<code><a href="#topic+fun.diag.ks.g.bimodal">fun.diag.ks.g.bimodal</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>

# Fitting faithful data from the dataset library, with the clara clustering 
# regime. The first distribution is RS and the second distribution is fmkl. 
# The percentage of data mix is 1%.

fun.auto.bimodal.ml(faithful[,1],per.of.mix=0.01,clustering.m=clara,
init1.sel="rprs",init2.sel="rmfmkl",init1=c(-1.5,1,5),init2=c(-0.25,1.5),
leap1=3,leap2=3)


</code></pre>

<hr>
<h2 id='fun.auto.bimodal.pml'> Fitting mixture of generalied lambda distribtions to data using 
parition maximum likelihood estimation </h2><span id='topic+fun.auto.bimodal.pml'></span>

<h3>Description</h3>

<p>This function will fit mixture of generalised lambda distributions to dataset. 
It is restricted to two generalised lambda distributions. The method of fitting 
is parition maximum likelihood. It is a two step optimization procedure, each 
unimodal part of the bimodal distribution is modelled using the maximum 
likelihood method or the starship method (FMKL GLD only). These initial values 
the used to &quot;maximise&quot; the complete log likelihood for the entire bimodal 
distribution. It fits mixture of the form p*(f1)+(1-p)*(f2) where f1 and f2 are 
pdfs of the generalised lambda distributions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fun.auto.bimodal.pml(data, clustering.m = clara, init1.sel = "rprs", 
init2.sel = "rprs", init1=c(-1.5, 1.5), init2=c(-1.5, 1.5), leap1=3, leap2=3,
fun1="runif.sobol", fun2="runif.sobol",no=10000,max.it=5000, optim.further="Y")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fun.auto.bimodal.pml_+3A_data">data</code></td>
<td>
<p> A numerical vector representing the dataset. </p>
</td></tr>
<tr><td><code id="fun.auto.bimodal.pml_+3A_clustering.m">clustering.m</code></td>
<td>
<p> Clustering method used in classifying the dataset into 
two parts. Valid arguments include clara, fanny and pam from the cluster 
library. Default is clara. Or a logical vector specifying how data should
be split. </p>
</td></tr>
<tr><td><code id="fun.auto.bimodal.pml_+3A_init1.sel">init1.sel</code></td>
<td>
<p> This can be <code>"rprs"</code>, <code>"rmfmkl"</code> or <code>"star"</code>, 
the initial method used to fit the first distribution. </p>
</td></tr>
<tr><td><code id="fun.auto.bimodal.pml_+3A_init2.sel">init2.sel</code></td>
<td>
<p> This can be <code>"rprs"</code>, <code>"rmfmkl"</code> or <code>"star"</code>, 
the initial method used to fit the second distribution. </p>
</td></tr>
<tr><td><code id="fun.auto.bimodal.pml_+3A_init1">init1</code></td>
<td>
<p> Inititial values lambda3 and lambda4 for the first generalised 
lambda distribution. </p>
</td></tr>
<tr><td><code id="fun.auto.bimodal.pml_+3A_init2">init2</code></td>
<td>
<p> Inititial values lambda3 and lambda4 for the second generalised 
lambda distribution. </p>
</td></tr>
<tr><td><code id="fun.auto.bimodal.pml_+3A_leap1">leap1</code></td>
<td>
<p> See scrambling argument in <code><a href="#topic+fun.gen.qrn">fun.gen.qrn</a></code>. </p>
</td></tr>
<tr><td><code id="fun.auto.bimodal.pml_+3A_fun1">fun1</code></td>
<td>
<p> A character string of either  <code>"runif.sobol"</code> (default), <code>"runif.sobol.owen"</code>, 
<code>"runif.halton"</code> or <code>"QUnif"</code>. </p>
</td></tr>
<tr><td><code id="fun.auto.bimodal.pml_+3A_leap2">leap2</code></td>
<td>
<p> See scrambling argument in <code><a href="#topic+fun.gen.qrn">fun.gen.qrn</a></code>. </p>
</td></tr>
<tr><td><code id="fun.auto.bimodal.pml_+3A_fun2">fun2</code></td>
<td>
<p> A character string of either  <code>"runif.sobol"</code> (default), <code>"runif.sobol.owen"</code>, 
<code>"runif.halton"</code> or <code>"QUnif"</code>. </p>
</td></tr>
<tr><td><code id="fun.auto.bimodal.pml_+3A_no">no</code></td>
<td>
<p> Number of initial random values to find the best initial values for 
optimisation. </p>
</td></tr>   
<tr><td><code id="fun.auto.bimodal.pml_+3A_max.it">max.it</code></td>
<td>
<p> Maximum number of iterations for numerical optimisation. </p>
</td></tr>
<tr><td><code id="fun.auto.bimodal.pml_+3A_optim.further">optim.further</code></td>
<td>
<p>Whether to optimise the function further using full 
maximum likelihood method, recommended setting is &quot;Y&quot;</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The initial values that work well for RPRS are <code>c(-1.5,1.5)</code> and for RMFMKL 
are <code>c(-0.25,1.5)</code>. For scrambling, if <code>1</code>, <code>2</code> or <code>3</code> the 
sequence is scrambled otherwise not. If <code>1</code>, Owen type type of scrambling 
is applied, if <code>2</code>, Faure-Tezuka type of scrambling, is applied, and if 
<code>3</code>, both Owen+Faure-Tezuka type of scrambling is applied. The <code>star</code> 
method uses the same initial values as <code>rmfmkl</code> since it uses the FMKL 
generalised lambda distribution. Nelder-Simplex algorithm is used in the 
numerical optimization. <code>rprs</code> stands for revised percentile method for RS 
generalised lambda distribution and &quot;rmfmkl&quot; stands for revised method of moment 
for FMKL generalised lambda distribution. These acronyms represents the initial 
optimization algorithm used to get a reasonable set of initial values for the 
subsequent optimization procedues. This function is an improvement from Su 
(2007) in Journal of Statistical Software.
</p>


<h3>Value</h3>

<table>
<tr><td><code>par</code></td>
<td>
<p> The best set of parameters found, the first four corresponds to the 
first distribution fit, the second four corresponds to the second distribution 
fit, the last value correspond to p for the first distribution fit. </p>
</td></tr>
<tr><td><code>value</code></td>
<td>
<p> The value of -PML for the paramters obtained. </p>
</td></tr>
<tr><td><code>counts</code></td>
<td>
<p> A two-element integer vector giving the number of calls to &quot;fn&quot; 
and &quot;gr&quot; respectively. This excludes those calls needed to compute the Hessian, 
if requested, and any calls to 'fn' to compute a finite-difference approximation 
to the gradient. </p>
</td></tr>
<tr><td><code>convergence</code></td>
<td>
 <p><code>0</code> indicates successful convergence, <code>1</code> 
indicates the iteration limit <code>maxit</code> had been reached, <code>10</code> indicates 
degeneracy of the Nelder-Mead simplex. </p>
</td></tr>
<tr><td><code>message</code></td>
<td>
<p> A character string giving any additional information returned by 
the optimizer, or <code>NULL</code>. </p>
</td></tr>
</table>


<h3>Note</h3>

<p> If the number of observations is small, <code>rprs</code> can sometimes fail as 
the percentiles may not exist for this data. Also, if the initial values do not 
result in a valid generalised lambda distribution, try another set of initial 
values.
</p>


<h3>References</h3>

 
<p>Bratley P. and Fox B.L. (1988) Algorithm 659: Implementing Sobol's quasi random 
sequence generator, ACM Transactions on Mathematical Software 14, 88-100.
</p>
<p>Joe S. and Kuo F.Y. (1998) Remark on Algorithm 659: Implementing Sobol's quasi 
random Sequence Generator.
</p>
<p>Nelder, J. A. and Mead, R. (1965) A simplex algorithm for function minimization. 
Computer Journal *7*, 308-313.
</p>
<p>Su (2007). Fitting Single and Mixture of Generalized Lambda Distributions to 
Data via Discretized and Maximum Likelihood Methods: GLDEX in R. Journal of 
Statistical Software: *21* 9.
</p>


<h3>See Also</h3>

 <p><code><a href="#topic+fun.auto.bimodal.ml">fun.auto.bimodal.ml</a></code>,<code><a href="#topic+fun.plot.fit.bm">fun.plot.fit.bm</a></code>,
<code><a href="#topic+fun.diag.ks.g.bimodal">fun.diag.ks.g.bimodal</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Fitting faithful data from the dataset library, with the clara clustering 
# regime. The first distribution is RS and the second distribution is fmkl. 

fun.auto.bimodal.pml(faithful[,1],clustering.m=clara,init1.sel="rprs",
init2.sel="rmfmkl",init1=c(-1.5,1,5),init2=c(-0.25,1.5),leap1=3,leap2=3)

</code></pre>

<hr>
<h2 id='fun.auto.bimodal.qs'> Fitting mixtures of generalied lambda distribtions to data using 
quantile matching method </h2><span id='topic+fun.auto.bimodal.qs'></span>

<h3>Description</h3>

<p>This function will fit mixture of generalised lambda distributions to dataset. 
It is restricted to two generalised lambda distributions. The method of fitting 
is quantile matching method. It is a two step optimization procedure, 
each unimodal part of the bimodal distribution is modelled using quantile 
matching method. The initial values obtained are then used to maximise the 
theoretical and empirical quantile match for the entire bimodal distribution. 
It fits mixture of the form p*(f1)+(1-p)*(f2) where f1 and f2 are pdfs of the 
generalised lambda distributions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fun.auto.bimodal.qs(data, per.of.mix = 0.01, clustering.m = clara, 
init1.sel = "rprs", init2.sel = "rprs", init1=c(-1.5, 1.5), init2=c(-1.5, 1.5), 
leap1=3, leap2=3, fun1 = "runif.sobol", fun2 = "runif.sobol", trial.n = 100, 
len = 1000, type = 7, no = 10000, maxit = 5000)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fun.auto.bimodal.qs_+3A_data">data</code></td>
<td>
<p> A numerical vector representing the dataset. </p>
</td></tr>
<tr><td><code id="fun.auto.bimodal.qs_+3A_per.of.mix">per.of.mix</code></td>
<td>
<p> Level of mix between two parts of the distribution, 
usually 1-2% of cross mix is sufficient. </p>
</td></tr>
<tr><td><code id="fun.auto.bimodal.qs_+3A_clustering.m">clustering.m</code></td>
<td>
<p> Clustering method used in classifying the dataset into 
two parts. Valid arguments include clara, fanny and pam from the cluster 
library. Default is clara. Or a logical vector specifying how data should
be split. </p>
</td></tr>
<tr><td><code id="fun.auto.bimodal.qs_+3A_init1.sel">init1.sel</code></td>
<td>
<p> This can be <code>"rprs"</code> or <code>"rmfmkl"</code>, 
representing the choice (RS or FMKL) of the first distribution </p>
</td></tr>
<tr><td><code id="fun.auto.bimodal.qs_+3A_init2.sel">init2.sel</code></td>
<td>
<p> This can be <code>"rprs"</code> or <code>"rmfmkl"</code>,  
representing the choice (RS or FMKL) of the second distribution </p>
</td></tr>
<tr><td><code id="fun.auto.bimodal.qs_+3A_init1">init1</code></td>
<td>
<p> Inititial values lambda3 and lambda4 for the first generalised 
lambda distribution. </p>
</td></tr>
<tr><td><code id="fun.auto.bimodal.qs_+3A_init2">init2</code></td>
<td>
<p> Inititial values lambda3 and lambda4 for the second generalised 
lambda distribution. </p>
</td></tr>
<tr><td><code id="fun.auto.bimodal.qs_+3A_leap1">leap1</code></td>
<td>
<p> See scrambling argument in <code><a href="#topic+fun.gen.qrn">fun.gen.qrn</a></code>. </p>
</td></tr>
<tr><td><code id="fun.auto.bimodal.qs_+3A_fun1">fun1</code></td>
<td>
<p> A character string of either  <code>"runif.sobol"</code> (default), <code>"runif.sobol.owen"</code>, 
<code>"runif.halton"</code> or <code>"QUnif"</code>. </p>
</td></tr>
<tr><td><code id="fun.auto.bimodal.qs_+3A_leap2">leap2</code></td>
<td>
<p> See scrambling argument in <code><a href="#topic+fun.gen.qrn">fun.gen.qrn</a></code>. </p>
</td></tr>
<tr><td><code id="fun.auto.bimodal.qs_+3A_fun2">fun2</code></td>
<td>
<p> A character string of either  <code>"runif.sobol"</code> (default), <code>"runif.sobol.owen"</code>, 
<code>"runif.halton"</code> or <code>"QUnif"</code>. </p>
</td></tr>
<tr><td><code id="fun.auto.bimodal.qs_+3A_trial.n">trial.n</code></td>
<td>
<p> Number of evenly spaced quantile ranging from 0 to 1 to be
used in the checking phase, to find the best set of initial values for 
optimisation, this is intended to be lower than <code>len</code> to speed up the 
fitting algorithm. Default is 100. </p>
</td></tr>
<tr><td><code id="fun.auto.bimodal.qs_+3A_len">len</code></td>
<td>
<p> Number of evenly spaced quantile ranging from 0 to 1 to be used,
default is 1000 </p>
</td></tr>
<tr><td><code id="fun.auto.bimodal.qs_+3A_type">type</code></td>
<td>
<p> Type of quantile to be used, default is 7, see <code>quantile</code> </p>
</td></tr>
<tr><td><code id="fun.auto.bimodal.qs_+3A_no">no</code></td>
<td>
<p> Number of initial random values to find the best initial values 
for optimisation. </p>
</td></tr>
<tr><td><code id="fun.auto.bimodal.qs_+3A_maxit">maxit</code></td>
<td>
<p> Maximum number of iterations for numerical optimisation. Default
is 5000. </p>
</td></tr>
</table>


<h3>Details</h3>

<p>The initial values that work well for RPRS are <code>c(-1.5,1.5)</code> and for RMFMKL 
are <code>c(-0.25,1.5)</code>. For scrambling, if <code>1</code>, <code>2</code> or <code>3</code> the 
sequence is scrambled otherwise not. If <code>1</code>, Owen type type of scrambling 
is applied, if <code>2</code>, Faure-Tezuka type of scrambling, is applied, and if 
<code>3</code>, both Owen+Faure-Tezuka type of scrambling is applied. The <code>star</code> 
method uses the same initial values as <code>rmfmkl</code> since it uses the FMKL 
generalised lambda distribution. Nelder-Simplex algorithm is used in the 
numerical optimization. <code>rprs</code> stands for revised percentile method for 
RS generalised lambda distribution and &quot;rmfmkl&quot; stands for revised method of 
moment for FMKL generalised lambda distribution. These acronyms represents the 
initial optimization algorithm used to get a reasonable set of initial values 
for the subsequent optimization procedues.
</p>


<h3>Value</h3>

<table>
<tr><td><code>par</code></td>
<td>
<p> The best set of parameters found, the first four corresponds to the 
first distribution fit, the second four corresponds to the second distribution 
fit, the last value correspond to p for the first distribution fit. </p>
</td></tr>
<tr><td><code>value</code></td>
<td>
<p> The value of -ML for the paramters obtained. </p>
</td></tr>
<tr><td><code>counts</code></td>
<td>
<p> A two-element integer vector giving the number of calls to 
<code>fn</code> and <code>gr</code> respectively. This excludes those calls needed to 
compute the Hessian, if requested, and any calls to <code>fn</code> to compute a 
finite-difference approximation to the gradient. </p>
</td></tr>
<tr><td><code>convergence</code></td>
<td>
 <p><code>0</code> indicates successful convergence, <code>1</code> 
indicates the iteration limit <code>maxit</code> had been reached, <code>10</code> indicates 
degeneracy of the Nelder-Mead simplex. </p>
</td></tr>
<tr><td><code>message</code></td>
<td>
<p> A character string giving any additional information returned by 
the optimizer, or <code>NULL</code>. </p>
</td></tr>
</table>


<h3>Note</h3>

<p> If the number of observations is small, 
<code>rprs</code> can sometimes fail as the percentiles may not exist for this data. 
Also, if the initial values do not span a valid generalised lambda distribution, 
try another set of initial values. </p>


<h3>Author(s)</h3>

<p> Steve Su </p>


<h3>References</h3>

 
<p>Bratley P. and Fox B.L. (1988) Algorithm 659: Implementing Sobol's quasi random 
sequence generator, ACM Transactions on Mathematical Software 14, 88-100.
</p>
<p>Joe S. and Kuo F.Y. (1998) Remark on Algorithm 659: Implementing Sobol's quasi 
random Sequence Generator.
</p>
<p>Nelder, J. A. and Mead, R. (1965) A simplex algorithm for function minimization. 
Computer Journal *7*, 308-313.
</p>
<p>Su (2008). Fitting GLD to data via quantile matching method. (Book chapter to
appear)
</p>


<h3>See Also</h3>

 <p><code><a href="#topic+fun.auto.bimodal.pml">fun.auto.bimodal.pml</a></code>, <code><a href="#topic+fun.auto.bimodal.ml">fun.auto.bimodal.ml</a></code>,
<code><a href="#topic+fun.plot.fit.bm">fun.plot.fit.bm</a></code>, 
<code><a href="#topic+fun.diag.ks.g.bimodal">fun.diag.ks.g.bimodal</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>

# Fitting faithful data from the dataset library, with the clara clustering 
# regime. The first distribution is RS and the second distribution is fmkl. 
# The percentage of data mix is 1%.

fun.auto.bimodal.qs(faithful[,1],per.of.mix=0.01,clustering.m=clara,
init1.sel="rprs",init2.sel="rmfmkl",init1=c(-1.5,1,5),init2=c(-0.25,1.5),
leap1=3,leap2=3)

</code></pre>

<hr>
<h2 id='fun.beta'> This is a collection of functions used in the calculation of the beta 
function. </h2><span id='topic+fun.beta'></span><span id='topic+fun.beta1'></span>

<h3>Description</h3>

<p>These functions are for maintainers only and it is not designed for the users of 
this package.
</p>


<h3>Value</h3>

<p> Numerical result for beta function </p>


<h3>Note</h3>

<p> Please contact the author directly if you find a bug! </p>


<h3>Author(s)</h3>

<p> Steve Su </p>

<hr>
<h2 id='fun.bimodal.fit.ml'> Finds the final fits using the maximum likelihood estimation for the 
bimodal dataset. </h2><span id='topic+fun.bimodal.fit.ml'></span>

<h3>Description</h3>

<p>This is the secondary optimization procedure to evaluate the final bimodal 
distribution fits using the maximum likelihood. It usually relies on initial 
values found by <code>fun.bimodal.init</code> function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fun.bimodal.fit.ml(data, first.fit, second.fit, prop, param1, param2, selc1, 
selc2)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fun.bimodal.fit.ml_+3A_data">data</code></td>
<td>
<p> Dataset to be fitted.</p>
</td></tr>
<tr><td><code id="fun.bimodal.fit.ml_+3A_first.fit">first.fit</code></td>
<td>
<p> The distribution parameters or the initial values of the 
first distribution fit. </p>
</td></tr>
<tr><td><code id="fun.bimodal.fit.ml_+3A_second.fit">second.fit</code></td>
<td>
<p> The distribution parameters or the initial values of the 
second distribution fit. </p>
</td></tr>
<tr><td><code id="fun.bimodal.fit.ml_+3A_prop">prop</code></td>
<td>
<p> The proportion of the data set, usually obtained from 
<code><a href="#topic+fun.bimodal.init">fun.bimodal.init</a></code>. </p>
</td></tr>
<tr><td><code id="fun.bimodal.fit.ml_+3A_param1">param1</code></td>
<td>
<p> Can be either <code>"rs"</code> or <code>"fmkl"</code>, depending on the 
type of first distribution used. </p>
</td></tr>
<tr><td><code id="fun.bimodal.fit.ml_+3A_param2">param2</code></td>
<td>
<p> Can be either <code>"rs"</code> or <code>"fmkl"</code>, depending on the 
type of second distribution used. </p>
</td></tr>
<tr><td><code id="fun.bimodal.fit.ml_+3A_selc1">selc1</code></td>
<td>
<p> Selection of initial values for the first distribution, can be 
either <code>"rs"</code>, <code>"fmkl"</code> or <code>"star"</code>. Choose initial values from 
RPRS (ML), RMFMKL (ML) or STAR method. </p>
</td></tr>
<tr><td><code id="fun.bimodal.fit.ml_+3A_selc2">selc2</code></td>
<td>
<p> Selection of initial values for the second distribution, can be 
either <code>"rs"</code>, <code>"fmkl"</code> or <code>"star"</code>. Choose initial values from 
RPRS (ML), RMFMKL (ML) or STAR method. </p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function should be used in tandem with <code><a href="#topic+fun.bimodal.init">fun.bimodal.init</a></code>.
</p>


<h3>Value</h3>

<table>
<tr><td><code>par</code></td>
<td>
<p> The first four numbers are the parameters of the first generalised 
lambda distribution, the second four numbers are the parameters of the second 
generalised lambda distribution and the last value is the proportion of the 
first generalised lambda distribution.</p>
</td></tr>
<tr><td><code>value</code></td>
<td>
<p> The objective value of negative likelihood obtained using the 
par above. </p>
</td></tr>
<tr><td><code>counts</code></td>
<td>
<p> A two-element integer vector giving the number of calls to 
functions. Gradient is not used in this case. </p>
</td></tr>
<tr><td><code>convergence</code></td>
<td>
<p> An integer code. <code>0</code> indicates successful convergence. 
Error codes are:
</p>
<p><code>1</code> indicates that the iteration limit 'maxit' had been
reached.
</p>
<p><code>10</code> indicates degeneracy of the Nelder-Mead simplex. </p>
</td></tr>
<tr><td><code>message</code></td>
<td>
<p> A character string giving any additional information returned 
by the optimizer, or <code>NULL</code>. </p>
</td></tr>
</table>


<h3>Note</h3>

<p> There is currently no guarantee of a global convergence. </p>


<h3>Author(s)</h3>

<p> Steve Su </p>


<h3>References</h3>

<p> Su (2007). Fitting Single and Mixture of Generalized Lambda 
Distributions to Data via Discretized and Maximum Likelihood Methods: GLDEX in 
R. Journal of Statistical Software: *21* 9. </p>


<h3>See Also</h3>

 <p><code>link{fun.bimodal.fit.pml}</code>, <code><a href="#topic+fun.bimodal.init">fun.bimodal.init</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>
 # Extract faithful[,2] into faithful2
 faithful2&lt;-faithful[,2]

 # Uses clara clustering method
 clara.faithful2&lt;-fun.class.regime.bi(faithful2, 0.01, clara)

 # Save into two different objects
 qqqq1.faithful2.cc&lt;-clara.faithful2$data.a
 qqqq2.faithful2.cc&lt;-clara.faithful2$data.b

 # Find the initial values
 result.faithful2.init&lt;-fun.bimodal.init(data1=qqqq1.faithful2.cc,
 data2=qqqq2.faithful2.cc, rs.leap1=3,fmkl.leap1=3,rs.init1 = c(-1.5, 1.5), 
 fmkl.init1 = c(-0.25, 1.5), rs.leap2=3,fmkl.leap2=3,rs.init2 = c(-1.5, 1.5), 
 fmkl.init2 = c(-0.25, 1.5))

 # Find the final fits
 result.faithful2.rsrs&lt;-fun.bimodal.fit.ml(data=faithful2,
 result.faithful2.init[[2]],result.faithful2.init[[3]],
 result.faithful2.init[[1]], param1="rs",param2="rs",selc1="rs",selc2="rs")

 # Output
 result.faithful2.rsrs

</code></pre>

<hr>
<h2 id='fun.bimodal.fit.pml'> Finds the final fits using partition maximum likelihood estimation for 
the bimodal dataset. </h2><span id='topic+fun.bimodal.fit.pml'></span>

<h3>Description</h3>

<p>This is the secondary optimization procedure to evaluate the final bimodal 
distribution fits using the partition
maximum likelihood. It usually relies on initial values found by 
<code>fun.bimodal.init</code> function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fun.bimodal.fit.pml(data1, data2, first.fit, second.fit, prop, param1, param2, 
selc1, selc2)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fun.bimodal.fit.pml_+3A_data1">data1</code></td>
<td>
<p> First data set, usually obtained by 
<code><a href="#topic+fun.class.regime.bi">fun.class.regime.bi</a></code>. </p>
</td></tr>
<tr><td><code id="fun.bimodal.fit.pml_+3A_data2">data2</code></td>
<td>
<p> Second data set, usually obtained by 
<code><a href="#topic+fun.class.regime.bi">fun.class.regime.bi</a></code>. </p>
</td></tr>
<tr><td><code id="fun.bimodal.fit.pml_+3A_first.fit">first.fit</code></td>
<td>
<p> The distribution parameters or the initial values of the 
first distribution fit. </p>
</td></tr>
<tr><td><code id="fun.bimodal.fit.pml_+3A_second.fit">second.fit</code></td>
<td>
<p> The distribution parameters or the initial values of the 
second distribution fit. </p>
</td></tr>
<tr><td><code id="fun.bimodal.fit.pml_+3A_prop">prop</code></td>
<td>
<p> The proportion of the data set, usually obtained from 
<code>fun.bimodal.init</code>. </p>
</td></tr>
<tr><td><code id="fun.bimodal.fit.pml_+3A_param1">param1</code></td>
<td>
<p> Can be either <code>rs</code> or <code>fmkl</code>, depending on the type 
of first distribution used. </p>
</td></tr>
<tr><td><code id="fun.bimodal.fit.pml_+3A_param2">param2</code></td>
<td>
<p> Can be either <code>rs</code> or <code>fmkl</code>, depending on the type 
of second distribution used. </p>
</td></tr>
<tr><td><code id="fun.bimodal.fit.pml_+3A_selc1">selc1</code></td>
<td>
<p> Selection of initial values for the first distribution, can be 
either <code>"rs"</code>, <code>"fmkl"</code> or <code>"star"</code>. Choose initial values from 
RPRS (ML), RMFMKL (ML) or STAR method. </p>
</td></tr>
<tr><td><code id="fun.bimodal.fit.pml_+3A_selc2">selc2</code></td>
<td>
<p> Selection of initial values for the second distribution, can be 
either <code>"rs"</code>, <code>"fmkl"</code> or <code>"star"</code>. Choose initial values from 
RPRS (ML), RMFMKL (ML) or STAR method. </p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function should be used in tandem with <code><a href="#topic+fun.bimodal.init">fun.bimodal.init</a></code> 
function.
</p>


<h3>Value</h3>

<table>
<tr><td><code>par</code></td>
<td>
<p> The first four numbers are the parameters of the first generalised 
lambda distribution, the second four numbers are the parameters of the second 
generalised lambda distribution and the last value is the proportion of the 
first generalised lambda distribution.</p>
</td></tr>
<tr><td><code>value</code></td>
<td>
<p> The objective value of negative likelihood obtained. </p>
</td></tr>
<tr><td><code>counts</code></td>
<td>
<p> A two-element integer vector giving the number of calls to 
functions. Gradient is not used in this case. </p>
</td></tr>
<tr><td><code>convergence</code></td>
<td>
<p> An integer code. <code>0</code> indicates successful 
convergence. Error codes are:
</p>
<p><code>1</code> indicates that the iteration limit 'maxit' had been
reached.
</p>
<p><code>10</code> indicates degeneracy of the Nelder-Mead simplex.</p>
</td></tr>
<tr><td><code>message</code></td>
<td>
<p> A character string giving any additional information returned 
by the optimizer, or <code>NULL</code>. </p>
</td></tr>
</table>


<h3>Note</h3>

<p> There is currently no guarantee of a global convergence. </p>


<h3>Author(s)</h3>

<p> Steve Su </p>


<h3>References</h3>

<p> Su (2007). Fitting Single and Mixture of Generalized Lambda 
Distributions to Data via Discretized and Maximum Likelihood Methods: 
GLDEX in R. Journal of Statistical Software: *21* 9.
</p>


<h3>See Also</h3>

 <p><code><a href="#topic+fun.bimodal.fit.ml">fun.bimodal.fit.ml</a></code>, <code><a href="#topic+fun.bimodal.init">fun.bimodal.init</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>
 # Extract faithful[,2] into faithful2
 faithful2&lt;-faithful[,2]

 # Uses clara clustering method
 clara.faithful2&lt;-clara(faithful2,2)$clustering

 # Save into two different objects
 qqqq1.faithful2.cc&lt;-faithful2[clara.faithful2==1]
 qqqq2.faithful2.cc&lt;-faithful2[clara.faithful2==2]

 # Find the initial values
 result.faithful2.init&lt;-fun.bimodal.init(data1=qqqq1.faithful2.cc,
 data2=qqqq2.faithful2.cc, rs.leap1=3,fmkl.leap1=3,rs.init1 = c(-1.5, 1.5), 
 fmkl.init1 = c(-0.25, 1.5), rs.leap2=3,fmkl.leap2=3,rs.init2 = c(-1.5, 1.5), 
 fmkl.init2 = c(-0.25, 1.5))

 # Find the final fits
 result.faithful2.rsrs&lt;-fun.bimodal.fit.pml(data1=qqqq1.faithful2.cc,
 data2=qqqq2.faithful2.cc, result.faithful2.init[[2]],
 result.faithful2.init[[3]], result.faithful2.init[[1]],param1="rs",
 param2="rs",selc1="rs",selc2="rs")

 # Output
 result.faithful2.rsrs
</code></pre>

<hr>
<h2 id='fun.bimodal.init'> Finds the initial values for optimisation in fitting the bimodal 
generalised lambda distribution. </h2><span id='topic+fun.bimodal.init'></span>

<h3>Description</h3>

<p>After classifying the data using <code><a href="#topic+fun.class.regime.bi">fun.class.regime.bi</a></code>, this 
function evaluates the temporary or initial solutions
by estimating each part of the bimodal distribution using the maximum likelihood 
estimation and starship method.
These initial solutions are then passed onto <code><a href="#topic+fun.bimodal.fit.ml">fun.bimodal.fit.ml</a></code> or 
<code><a href="#topic+fun.bimodal.fit.pml">fun.bimodal.fit.pml</a></code> to obtain the final fits.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fun.bimodal.init(data1, data2, rs.leap1, fmkl.leap1, rs.init1, fmkl.init1, 
rs.leap2, fmkl.leap2, rs.init2, fmkl.init2,fun1="runif.sobol",
fun2="runif.sobol",no=10000)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fun.bimodal.init_+3A_data1">data1</code></td>
<td>
<p> The first data obtained by the clustering algorithm. </p>
</td></tr>
<tr><td><code id="fun.bimodal.init_+3A_data2">data2</code></td>
<td>
<p> The second data obtained by the clustering algorithm. </p>
</td></tr>
<tr><td><code id="fun.bimodal.init_+3A_rs.leap1">rs.leap1</code></td>
<td>
<p> See scrambling argument in <code><a href="#topic+fun.gen.qrn">fun.gen.qrn</a></code>. </p>
</td></tr>
<tr><td><code id="fun.bimodal.init_+3A_fmkl.leap1">fmkl.leap1</code></td>
<td>
<p> See scrambling argument in <code><a href="#topic+fun.gen.qrn">fun.gen.qrn</a></code>. </p>
</td></tr>
<tr><td><code id="fun.bimodal.init_+3A_rs.init1">rs.init1</code></td>
<td>
<p> Inititial values (lambda3 and lambda4) for the first RS 
generalised lambda distribution. <code>c(-1.5,1.5)</code> tends to work well. </p>
</td></tr>
<tr><td><code id="fun.bimodal.init_+3A_fmkl.init1">fmkl.init1</code></td>
<td>
<p> Inititial values (lambda3 and lambda4) for the first FMKL 
generalised lambda distribution. <code>c(-0.25,1.5)</code> tends to work well </p>
</td></tr>
<tr><td><code id="fun.bimodal.init_+3A_rs.leap2">rs.leap2</code></td>
<td>
<p> See scrambling argument in <code><a href="#topic+fun.gen.qrn">fun.gen.qrn</a></code>. </p>
</td></tr>
<tr><td><code id="fun.bimodal.init_+3A_fmkl.leap2">fmkl.leap2</code></td>
<td>
<p> See scrambling argument in <code><a href="#topic+fun.gen.qrn">fun.gen.qrn</a></code>.  </p>
</td></tr>
<tr><td><code id="fun.bimodal.init_+3A_rs.init2">rs.init2</code></td>
<td>
<p> Inititial values (lambda3 and lambda4) for the second RS 
generalised lambda distribution. <code>c(-1.5,1.5)</code> tends to work well. </p>
</td></tr>
<tr><td><code id="fun.bimodal.init_+3A_fmkl.init2">fmkl.init2</code></td>
<td>
<p> Inititial values (lambda3 and lambda4) for the second FMKL 
generalised lambda distribution. <code>c(-0.25,1.5)</code> tends to work well </p>
</td></tr>
<tr><td><code id="fun.bimodal.init_+3A_fun1">fun1</code></td>
<td>
<p> A character string of either  <code>"runif.sobol"</code> (default), <code>"runif.sobol.owen"</code>, 
<code>"runif.halton"</code> or <code>"QUnif"</code>.</p>
</td></tr>
<tr><td><code id="fun.bimodal.init_+3A_fun2">fun2</code></td>
<td>
<p> A character string of either  <code>"runif.sobol"</code> (default), <code>"runif.sobol.owen"</code>, 
<code>"runif.halton"</code> or <code>"QUnif"</code>. </p>
</td></tr>
<tr><td><code id="fun.bimodal.init_+3A_no">no</code></td>
<td>
<p> Number of initial random values to find the best initial values 
for optimisation. </p>
</td></tr>
</table>


<h3>Details</h3>

<p>All three methods of fitting (RPRS, RMFMKL and STAR) will be given for each 
part of the bimodal distribution.
</p>


<h3>Value</h3>

<table>
<tr><td><code>prop</code></td>
<td>
<p> Proportion of the number of observations in the first data in 
relation to the entire data. </p>
</td></tr>
<tr><td><code>first.fit</code></td>
<td>
<p> A matrix comprising the parameters of GLD obtained from 
RPRS, RMFMKL and STAR for the first dataset. </p>
</td></tr>
<tr><td><code>second.fit</code></td>
<td>
<p> A matrix comprising the parameters of GLD obtained from 
RPRS, RMFMKL and STAR for the second dataset. </p>
</td></tr>
</table>


<h3>Note</h3>

<p> This is not designed to be called by the end user explicitly, 
the difficulties with RPRS parameterisation should be
noted by the users. 
</p>


<h3>Author(s)</h3>

<p> Steve Su </p>


<h3>References</h3>

<p> Su (2007). Fitting Single and Mixture of Generalized Lambda 
Distributions to Data via Discretized and Maximum Likelihood Methods: 
GLDEX in R. Journal of Statistical Software: *21* 9.
</p>


<h3>See Also</h3>

 <p><code><a href="#topic+fun.class.regime.bi">fun.class.regime.bi</a></code>,<code><a href="#topic+fun.bimodal.fit.pml">fun.bimodal.fit.pml</a></code>,
<code><a href="#topic+fun.bimodal.fit.ml">fun.bimodal.fit.ml</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>
 # Split the first column of the faithful data into two using 

 fun.class.regime.bi
 faithful1.mod&lt;-fun.class.regime.bi(faithful[,1], 0.1, clara)

 # Save the datasets
 qqqq1.faithful1.cc1&lt;-faithful1.mod$data.a
 qqqq2.faithful1.cc1&lt;-faithful1.mod$data.b

 # Find the initial values for secondary optimisation.
 
 result.faithful1.init1&lt;-fun.bimodal.init(data1=qqqq1.faithful1.cc1,
 data2=qqqq2.faithful1.cc1, rs.leap1=3,fmkl.leap1=3,rs.init1 = c(-1.5, 1.5), 
 fmkl.init1 = c(-0.25, 1.5), rs.leap2=3,fmkl.leap2=3,rs.init2 = c(-1.5, 1.5), 
 fmkl.init2 = c(-0.25, 1.5))

 # These initial values are then passed onto fun,bimodal.fit.ml to obtain the 
 # final fits.
</code></pre>

<hr>
<h2 id='fun.check.gld'>
Check whether the RS or FMKL/FKML GLD is a valid GLD for single values of L1, 
L2, L3 and L4
</h2><span id='topic+fun.check.gld'></span>

<h3>Description</h3>

<p>This function will return a single logical value showing whether a combination 
of
L1, L2, L3 and L4 is a valid GLD.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fun.check.gld(lambda1, lambda2, lambda3, lambda4, param)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fun.check.gld_+3A_lambda1">lambda1</code></td>
<td>

<p>A numerical vector for L1 of GLD
</p>
</td></tr>
<tr><td><code id="fun.check.gld_+3A_lambda2">lambda2</code></td>
<td>

<p>A numerical vector for L2 of GLD
</p>
</td></tr>
<tr><td><code id="fun.check.gld_+3A_lambda3">lambda3</code></td>
<td>

<p>A numerical vector for L3 of GLD
</p>
</td></tr>
<tr><td><code id="fun.check.gld_+3A_lambda4">lambda4</code></td>
<td>

<p>A numerical vector for L4 of GLD
</p>
</td></tr>
<tr><td><code id="fun.check.gld_+3A_param">param</code></td>
<td>

<p>Can be &quot;rs&quot;, &quot;fmkl&quot;, or &quot;fkml&quot;
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A single logical value indicating whether the specified GLD is a valid 
probability density function
</p>


<h3>Author(s)</h3>

<p>Steve Su
</p>


<h3>See Also</h3>

<p><code><a href="#topic+fun.check.gld.multi">fun.check.gld.multi</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
fun.check.gld(1,4,3,2,"rs")

fun.check.gld(1,4,3,2,"fkml")

fun.check.gld(1,4,3,-2,"rs")
</code></pre>

<hr>
<h2 id='fun.check.gld.multi'>
Check whether the RS or FMKL/FKML GLD is a valid GLD for vectors of L1, L2, L3 
and L4
</h2><span id='topic+fun.check.gld.multi'></span>

<h3>Description</h3>

<p>This function will return a logical vector showing whether vector combinations 
of L1, L2, L3 and L4 are valid GLDs.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fun.check.gld.multi(l1, l2, l3, l4, param)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fun.check.gld.multi_+3A_l1">l1</code></td>
<td>

<p>A numerical vector for L1 of GLD
</p>
</td></tr>
<tr><td><code id="fun.check.gld.multi_+3A_l2">l2</code></td>
<td>

<p>A numerical vector for L2 of GLD
</p>
</td></tr>
<tr><td><code id="fun.check.gld.multi_+3A_l3">l3</code></td>
<td>

<p>A numerical vector for L3 of GLD
</p>
</td></tr>
<tr><td><code id="fun.check.gld.multi_+3A_l4">l4</code></td>
<td>

<p>A numerical vector for L4 of GLD
</p>
</td></tr>
<tr><td><code id="fun.check.gld.multi_+3A_param">param</code></td>
<td>

<p>Can be &quot;rs&quot;, &quot;fmkl&quot;, or &quot;fkml&quot;
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This is an extension to <code><a href="#topic+fun.check.gld">fun.check.gld</a></code>
</p>


<h3>Value</h3>

<p>A logical vector indicating whether the specified parameters are valid GLDs
</p>


<h3>Author(s)</h3>

<p>Steve Su
</p>


<h3>See Also</h3>

<p><code><a href="#topic+fun.check.gld">fun.check.gld</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>
fun.check.gld.multi(c(1,2,3),c(4,5,6),c(7,8,9),c(10,11,12),param="rs")

fun.check.gld.multi(c(1,2,3),c(4,5,6),c(7,8,9),c(10,11,-12),param="rs")

</code></pre>

<hr>
<h2 id='fun.class.regime.bi'> Classifies data into two groups using a clustering regime. </h2><span id='topic+fun.class.regime.bi'></span>

<h3>Description</h3>

<p>This function is primarily designed to split a bimodal data vector into two 
groups to allow the fitting of mixture generalised lambda distributions. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fun.class.regime.bi(data, perc.cross, fun.cross)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fun.class.regime.bi_+3A_data">data</code></td>
<td>
<p> Data to be classified into two groups. </p>
</td></tr>
<tr><td><code id="fun.class.regime.bi_+3A_perc.cross">perc.cross</code></td>
<td>
<p> Percentage of cross over from one data to the other, 
usually set at 1% </p>
</td></tr>
<tr><td><code id="fun.class.regime.bi_+3A_fun.cross">fun.cross</code></td>
<td>
<p> Any clustering function such as <code>link{clara}</code>, 
<code><a href="cluster.html#topic+pam">pam</a></code>, <code><a href="cluster.html#topic+fanny">fanny</a></code> can be used here. Or a logical 
vector indicating how data should be split. </p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is part of the routine mixture fitting procedure provided in this 
package. The <code>perc.cross</code> argument or percentage of cross over is designed 
to allow the use of maximum likelihood estimation via EM algorithm for fitting 
bimodal data. When this is invoked, it will ensure both part of the data will 
contain both the minmum and maximum of the data set as well as a proportion (
specified in perc.cross argument) of observations from each other. If 1% is 
required, then data.a will contains 1% of the data.b and vice versa after the 
full data set has been classified into <code>data.a</code> and <code>data.b</code> by the 
<code>fun.cross</code> classification regime.
</p>


<h3>Value</h3>

<table>
<tr><td><code>data.a</code></td>
<td>
<p> First group of data obtained by the classification algorithm. </p>
</td></tr>
<tr><td><code>data.b</code></td>
<td>
<p> Second group of data obtained by the classification algorithm. 
</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p> Steve Su </p>


<h3>References</h3>

 
<p>Kaufman, L. and Rousseeuw, P. J. (1990). Finding Groups in Data: An Introduction 
to Cluster Analysis. Wiley, New York.
</p>
<p>Su (2006) Maximum Log Likelihood Estimation using EM Algorithm and Partition 
Maximum Log Likelihood Estimation for Mixtures of Generalized Lambda 
Distributions. Working Paper. </p>


<h3>See Also</h3>

 <p><code>link{clara}</code>, <code><a href="cluster.html#topic+pam">pam</a></code>, <code><a href="cluster.html#topic+fanny">fanny</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Classify the faithful[,1] data into two categories with 10% cross over mix.
 fun.class.regime.bi(faithful[,1],0.1,clara)

# Classify the faithful[,1] data into two categories with no mixing:
 fun.class.regime.bi(faithful[,1],0,clara)
</code></pre>

<hr>
<h2 id='fun.comp.moments.ml'> Compare the moments of the data and the fitted univariate generalised 
lambda distribution. </h2><span id='topic+fun.comp.moments.ml'></span>

<h3>Description</h3>

<p>After fitting the distribution, it is often desirable to see whether the 
moments of the data matches with the fitted distribution. This function computes 
the theoretical and actual moments especially for <code>fun.data.fit.ml</code> 
function output.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fun.comp.moments.ml(theo.obj, data, name = "ML")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fun.comp.moments.ml_+3A_theo.obj">theo.obj</code></td>
<td>
<p> Fitted distribution parameters, usually output from 
<code><a href="#topic+fun.data.fit.ml">fun.data.fit.ml</a></code> </p>
</td></tr>
<tr><td><code id="fun.comp.moments.ml_+3A_data">data</code></td>
<td>
<p> Data set used </p>
</td></tr>
<tr><td><code id="fun.comp.moments.ml_+3A_name">name</code></td>
<td>
<p> Naming the method used in fitting the distribution, by default 
this is &quot;ML&quot;. </p>
</td></tr>
</table>


<h3>Value</h3>

<table>
<tr><td><code>r.mat</code></td>
<td>
<p> A matrix showing the mean, variance, skewness and kurtosis of the 
fitted distribution in comparison to the data set. </p>
</td></tr>
<tr><td><code>eval.mat</code></td>
<td>
<p> Absolute difference in each of the four moments from the data 
under each of the distibutional fits. </p>
</td></tr>
</table>


<h3>Note</h3>

<p> Sometimes it is difficult to find RPRS type of fits to data set, so 
instead <code><a href="#topic+fun.comp.moments.ml.2">fun.comp.moments.ml.2</a></code> is used to compare the theoretical 
moments of RMFMKL.ML and STAR methods
with respect to the dataset fitted.
</p>


<h3>Author(s)</h3>

<p> Steve Su </p>


<h3>See Also</h3>

 <p><code><a href="#topic+fun.comp.moments.ml.2">fun.comp.moments.ml.2</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Generate random normally distributed observations.
 junk&lt;-rnorm(1000,3,2)

# Fit the dataset using fun.data.ml
 fit&lt;-fun.data.fit.ml(junk)

# Compare the resulting fits. It is usually the case the maximum likelihood 
# provides better estimation of the moments than the starship method.
 fun.comp.moments.ml(fit,junk)

</code></pre>

<hr>
<h2 id='fun.comp.moments.ml.2'> Compare the moments of the data and the fitted univariate generalised 
lambda distribution. Specialised funtion designed for RMFMKL.ML and STAR 
methods. </h2><span id='topic+fun.comp.moments.ml.2'></span>

<h3>Description</h3>

<p>After fitting the distribution, it is often desirable to see whether the 
moments of the data matches with the fitted distribution. This function computes 
the theoretical and actual moments for the FMKL GLD maximum likelihood 
estimation and starship method.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fun.comp.moments.ml.2(theo.obj, data, name = "ML")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fun.comp.moments.ml.2_+3A_theo.obj">theo.obj</code></td>
<td>
<p> Fitted distribution parameters, there should be two sets, 
both FMKL GLD. </p>
</td></tr>
<tr><td><code id="fun.comp.moments.ml.2_+3A_data">data</code></td>
<td>
<p> Data set used </p>
</td></tr>
<tr><td><code id="fun.comp.moments.ml.2_+3A_name">name</code></td>
<td>
<p> Naming the method used in fitting the distribution, by default 
this is &quot;ML&quot;. </p>
</td></tr>
</table>


<h3>Value</h3>

<table>
<tr><td><code>r.mat</code></td>
<td>
<p> A matrix showing the mean, variance, skewness and kurtosis of the 
fitted distribution in comparison to the data set. </p>
</td></tr>
<tr><td><code>eval.mat</code></td>
<td>
<p> Absolute difference in each of the four moments from the data 
under each of the distibutional fits. </p>
</td></tr>
</table>


<h3>Note</h3>

<p> To compare all three fits under <code><a href="#topic+fun.data.fit.ml">fun.data.fit.ml</a></code> see 
<code><a href="#topic+fun.comp.moments.ml">fun.comp.moments.ml</a></code> function.
</p>


<h3>Author(s)</h3>

<p> Steve Su </p>


<h3>See Also</h3>

 <p><code><a href="#topic+fun.comp.moments.ml">fun.comp.moments.ml</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Generate random normally distributed observations.
 junk&lt;-rnorm(1000,3,2)

## Fit the dataset using fun.data.ml
 fit&lt;-cbind(fun.RMFMKL.ml(junk),starship(junk)$lambda)

## Compare the resulting fits. It is usually the case the maximum likelihood 
## provides better estimation of the moments than the starship method.
 fun.comp.moments.ml.2(fit,junk)
</code></pre>

<hr>
<h2 id='fun.data.fit.hs'> Fit RS and FMKL generalised distributions to data using discretised 
approach with weights. </h2><span id='topic+fun.data.fit.hs'></span>

<h3>Description</h3>

<p>This function fits RS and FMKL generalised distribution to data using 
discretised approach with weights. It is designed to act as a smoother device 
rather than a definitive fit. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fun.data.fit.hs(data, rs.default = "Y", fmkl.default = "Y", rs.leap = 3, 
fmkl.leap = 3, rs.init = c(-1.5, 1.5), fmkl.init = c(-0.25, 1.5), no.c.rs = 50, 
no.c.fmkl = 50,FUN="runif.sobol", no=10000)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fun.data.fit.hs_+3A_data">data</code></td>
<td>
<p> Dataset to be fitted </p>
</td></tr>
<tr><td><code id="fun.data.fit.hs_+3A_rs.default">rs.default</code></td>
<td>
<p> If yes, this function uses the default method 
<code><a href="#topic+fun.nclass.e">fun.nclass.e</a></code> to calculate number of classes required for the RS 
distribution fits. </p>
</td></tr>
<tr><td><code id="fun.data.fit.hs_+3A_fmkl.default">fmkl.default</code></td>
<td>
<p> If yes, this function uses the default method 
<code><a href="#topic+fun.nclass.e">fun.nclass.e</a></code> to calculate number of classes required for the 
FMKL distribution fits. </p>
</td></tr>
<tr><td><code id="fun.data.fit.hs_+3A_rs.leap">rs.leap</code></td>
<td>
<p> See scrambling argument in <code><a href="#topic+fun.gen.qrn">fun.gen.qrn</a></code>. </p>
</td></tr>
<tr><td><code id="fun.data.fit.hs_+3A_fmkl.leap">fmkl.leap</code></td>
<td>
<p> See scrambling argument in <code><a href="#topic+fun.gen.qrn">fun.gen.qrn</a></code>. </p>
</td></tr>
<tr><td><code id="fun.data.fit.hs_+3A_rs.init">rs.init</code></td>
<td>
<p> Initial values for RS distribution optimization, 
<code>c(-1.5,1.5)</code> tends to work well. </p>
</td></tr>
<tr><td><code id="fun.data.fit.hs_+3A_fmkl.init">fmkl.init</code></td>
<td>
<p> Initial values for FMKL distribution optimization,
<code>c(-0.25,1.5)</code> tends to work well. </p>
</td></tr>
<tr><td><code id="fun.data.fit.hs_+3A_no.c.rs">no.c.rs</code></td>
<td>
<p> Number of classes or bins of histogram to be optimized over 
for the RS GLD. This argument is ineffective if <code>default="Y"</code>. </p>
</td></tr>
<tr><td><code id="fun.data.fit.hs_+3A_no.c.fmkl">no.c.fmkl</code></td>
<td>
<p> Number of classes or bins of histogram to be optimized over 
for the FMKL GLD. This argument is ineffective if <code>default="Y"</code>. </p>
</td></tr>
<tr><td><code id="fun.data.fit.hs_+3A_fun">FUN</code></td>
<td>
<p> A character string of either  <code>"runif.sobol"</code> (default), <code>"runif.sobol.owen"</code>, 
<code>"runif.halton"</code> or <code>"QUnif"</code>. </p>
</td></tr>
<tr><td><code id="fun.data.fit.hs_+3A_no">no</code></td>
<td>
<p> Number of initial random values to find the best initial values for 
optimisation. </p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function optimises the deviations of frequency of the bins to that of the 
theoretical so it has the effect of &quot;fitting clothes&quot; onto the data set. The 
user can decide the frequency of the bins they want the distribution to smooth 
over. The resulting fit may or may not be an adequate fit from a formal 
statistical point of view such as satisfying the goodness of fit for example, 
but it can be useful to suggest the range of different distributions exhibited 
by the data set. The default number of classes calculates the mean and 
variance after categorising the data into different bins and uses the number 
of classes that best matches the mean and variance of the original, ungrouped 
data.The weighting is designed to accentuate the peak or the dense part of the 
distribution and suppress the tails. 
</p>


<h3>Value</h3>

<p>A matrix showing the four parameters of the RS and FMKL distribution fit.
</p>


<h3>Note</h3>

<p> In some cases, the resulting fit may not converge, there are currently no 
checking mechanism in place to ensure global convergence.
The RPRS method can sometimes fail if there are no valid percentiles in the data 
set or if initial values do not give a valid distribution.
</p>


<h3>Author(s)</h3>

<p> Steve Su </p>


<h3>References</h3>

<p> Su, S. (2005). A Discretized Approach to Flexibly Fit Generalized 
Lambda Distributions to Data. Journal of Modern Applied Statistical 
Methods (November): 408-424. 
</p>
<p>Su (2007). Fitting Single and Mixture of Generalized Lambda Distributions to 
Data via Discretized and Maximum Likelihood Methods: GLDEX in R. 
Journal of Statistical Software: *21* 9. </p>


<h3>See Also</h3>

 <p><code><a href="#topic+fun.RPRS.hs.nw">fun.RPRS.hs.nw</a></code>, <code><a href="#topic+fun.RMFMKL.hs.nw">fun.RMFMKL.hs.nw</a></code>, 
<code><a href="#topic+fun.RMFMKL.hs">fun.RMFMKL.hs</a></code>, <code><a href="#topic+fun.RPRS.hs">fun.RPRS.hs</a></code>, 
<code><a href="#topic+fun.data.fit.hs.nw">fun.data.fit.hs.nw</a></code>, <code><a href="#topic+fun.data.fit.ml">fun.data.fit.ml</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Fitting normal(3,2) distriution using the default setting
 junk&lt;-rnorm(1000,3,2)
 fun.data.fit.hs(junk)
</code></pre>

<hr>
<h2 id='fun.data.fit.hs.nw'> Fit RS and FMKL generalised distributions to data using discretised 
approach without weights. </h2><span id='topic+fun.data.fit.hs.nw'></span>

<h3>Description</h3>

<p>This function fits RS and FMKL generalised distribution to data using 
discretised approach without weights. It is designed to act as a smoother device 
rather than a definitive fit. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fun.data.fit.hs.nw(data, rs.default = "Y", fmkl.default = "Y", rs.leap = 3, 
fmkl.leap = 3, rs.init = c(-1.5, 1.5), fmkl.init = c(-0.25, 1.5), no.c.rs = 50, 
no.c.fmkl = 50,FUN="runif.sobol",no=10000)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fun.data.fit.hs.nw_+3A_data">data</code></td>
<td>
<p> Dataset to be fitted </p>
</td></tr>
<tr><td><code id="fun.data.fit.hs.nw_+3A_rs.default">rs.default</code></td>
<td>
<p> If yes, this function uses the default method 
<code><a href="#topic+fun.nclass.e">fun.nclass.e</a></code> to calculate number of classes required for the RS 
distribution fits. </p>
</td></tr>
<tr><td><code id="fun.data.fit.hs.nw_+3A_fmkl.default">fmkl.default</code></td>
<td>
<p> If yes, this function uses the default method 
<code><a href="#topic+fun.nclass.e">fun.nclass.e</a></code> to calculate number of classes required for the 
FMKL distribution fits. </p>
</td></tr>
<tr><td><code id="fun.data.fit.hs.nw_+3A_rs.leap">rs.leap</code></td>
<td>
<p> See scrambling argument in <code><a href="#topic+fun.gen.qrn">fun.gen.qrn</a></code>. </p>
</td></tr>
<tr><td><code id="fun.data.fit.hs.nw_+3A_fmkl.leap">fmkl.leap</code></td>
<td>
<p> See scrambling argument in <code><a href="#topic+fun.gen.qrn">fun.gen.qrn</a></code>. </p>
</td></tr>
<tr><td><code id="fun.data.fit.hs.nw_+3A_rs.init">rs.init</code></td>
<td>
<p> Initial values for RS distribution optimization, 
<code>c(-1.5,1.5)</code> tends to work well. </p>
</td></tr>
<tr><td><code id="fun.data.fit.hs.nw_+3A_fmkl.init">fmkl.init</code></td>
<td>
<p> Initial values for FMKL distribution optimization, 
<code>c(-0.25,1.5)</code> tends to work well. </p>
</td></tr>
<tr><td><code id="fun.data.fit.hs.nw_+3A_no.c.rs">no.c.rs</code></td>
<td>
<p> Number of classes or bins of histogram to be optimized over 
for the RS GLD. This argument is ineffective if <code>default="Y"</code>. </p>
</td></tr>
<tr><td><code id="fun.data.fit.hs.nw_+3A_no.c.fmkl">no.c.fmkl</code></td>
<td>
<p> Number of classes or bins of histogram to be optimized over 
for the FMKL GLD. This argument is ineffective if <code>default="Y"</code>. </p>
</td></tr>
<tr><td><code id="fun.data.fit.hs.nw_+3A_fun">FUN</code></td>
<td>
<p> A character string of either  <code>"runif.sobol"</code> (default), <code>"runif.sobol.owen"</code>, 
<code>"runif.halton"</code> or <code>"QUnif"</code>. </p>
</td></tr>
<tr><td><code id="fun.data.fit.hs.nw_+3A_no">no</code></td>
<td>
<p> Number of initial random values to find the best initial values 
for optimisation. </p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function optimises the deviations of frequency of the bins to that of the 
theoretical so it has the effect of &quot;fitting clothes&quot; onto the data set. The 
user can decide the frequency of the bins they want the distribution to smooth 
over. The resulting fit may or may not be an adequate fit from a formal 
statistical point of view such as satisfying the goodness of fit for example, 
but it can be useful to suggest the range of different distributions exhibited 
by the data set. The default number of classes calculates the mean and variance 
after categorising the data into different bins and uses the number of classes 
that best matches the mean and variance of the original, ungrouped data. 
</p>


<h3>Value</h3>

<p>A matrix showing the four parameters of the RS and FMKL distribution fit.
</p>


<h3>Note</h3>

<p> In some cases, the resulting fit may not converge, there are currently no 
checking mechanism in place to ensure global convergence.
The RPRS method can sometimes fail if there are no valid percentiles in the data 
set or if initial values do not give a valid distribution.
</p>


<h3>Author(s)</h3>

<p> Steve Su </p>


<h3>References</h3>

<p> Su, S. (2005). A Discretized Approach to Flexibly Fit Generalized 
Lambda Distributions to Data. Journal of Modern Applied Statistical 
Methods (November): 408-424.
</p>
<p>Su (2007). Fitting Single and Mixture of Generalized Lambda Distributions to 
Data via Discretized and Maximum Likelihood Methods: GLDEX in R. 
Journal of Statistical Software: *21* 9. </p>


<h3>See Also</h3>

 <p><code><a href="#topic+fun.RPRS.hs">fun.RPRS.hs</a></code>, <code><a href="#topic+fun.RMFMKL.hs">fun.RMFMKL.hs</a></code>, 
<code><a href="#topic+fun.RMFMKL.hs.nw">fun.RMFMKL.hs.nw</a></code>, <code><a href="#topic+fun.RPRS.hs.nw">fun.RPRS.hs.nw</a></code>, 
<code><a href="#topic+fun.data.fit.hs">fun.data.fit.hs</a></code>, <code><a href="#topic+fun.data.fit.ml">fun.data.fit.ml</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Fitting normal(3,2) distriution using the default setting
 junk&lt;-rnorm(1000,3,2)
 fun.data.fit.hs.nw(junk)
</code></pre>

<hr>
<h2 id='fun.data.fit.lm'> Fit data using L moment matching estimation for RS and FMKL GLD </h2><span id='topic+fun.data.fit.lm'></span>

<h3>Description</h3>

<p>This function fits generalised lambda distributions to data using L moment
matching method
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fun.data.fit.lm(data, rs.leap = 3, fmkl.leap = 3, rs.init = c(-1.5, 1.5), 
fmkl.init = c(-0.25, 1.5), FUN = "runif.sobol", no = 10000)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fun.data.fit.lm_+3A_data">data</code></td>
<td>
<p> Dataset to be fitted. </p>
</td></tr>
<tr><td><code id="fun.data.fit.lm_+3A_rs.leap">rs.leap</code></td>
<td>
<p> See scrambling argument in <code><a href="#topic+fun.gen.qrn">fun.gen.qrn</a></code>. </p>
</td></tr>
<tr><td><code id="fun.data.fit.lm_+3A_fmkl.leap">fmkl.leap</code></td>
<td>
<p> See scrambling argument in <code><a href="#topic+fun.gen.qrn">fun.gen.qrn</a></code>. </p>
</td></tr>
<tr><td><code id="fun.data.fit.lm_+3A_rs.init">rs.init</code></td>
<td>
<p> Inititial values (lambda3 and lambda4) for the RS generalised 
lambda distribution. </p>
</td></tr>
<tr><td><code id="fun.data.fit.lm_+3A_fmkl.init">fmkl.init</code></td>
<td>
<p> Inititial values (lambda3 and lambda4) for the FMKL 
generalised lambda distribution. </p>
</td></tr>
<tr><td><code id="fun.data.fit.lm_+3A_fun">FUN</code></td>
<td>
<p> A character string of either  <code>"runif.sobol"</code> (default), <code>"runif.sobol.owen"</code>, 
<code>"runif.halton"</code> or <code>"QUnif"</code>. </p>
</td></tr>
<tr><td><code id="fun.data.fit.lm_+3A_no">no</code></td>
<td>
<p> Number of initial random values to find the best initial values for 
optimisation. </p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function consolidates <code><a href="#topic+fun.RPRS.lm">fun.RPRS.lm</a></code> and  
<code><a href="#topic+fun.RMFMKL.lm">fun.RMFMKL.lm</a></code> and gives all the fits in 
one output.
</p>


<h3>Value</h3>

<p>A matrix showing the parameters of RS and FMKL generalised lambda distributions.
</p>


<h3>Author(s)</h3>

<p> Steve Su </p>


<h3>References</h3>

<p>Asquith, W. (2007). 
&quot;L-moments and TL-moments of the generalized lambda distribution.&quot; 
Computational Statistics and Data Analysis 51(9): 4484-4496.
</p>
<p>Karvanen, J. and A. Nuutinen (2008). 
&quot;Characterizing the generalized lambda distribution by L-moments.&quot; 
Computational Statistics and Data Analysis 52(4): 1971-1983. </p>


<h3>See Also</h3>

 <p><code><a href="#topic+fun.RPRS.qs">fun.RPRS.qs</a></code>, <code><a href="#topic+fun.RMFMKL.qs">fun.RMFMKL.qs</a></code>, 
<code><a href="#topic+fun.data.fit.ml">fun.data.fit.ml</a></code>, <code><a href="#topic+fun.data.fit.hs">fun.data.fit.hs</a></code>, 
<code><a href="#topic+fun.data.fit.hs.nw">fun.data.fit.hs.nw</a></code> , <code><a href="#topic+fun.data.fit.qs">fun.data.fit.qs</a></code>, 
<code><a href="#topic+fun.data.fit.mm">fun.data.fit.mm</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Fitting normal(3,2) distriution using the default setting
 junk&lt;-rnorm(50,3,2)
 fun.data.fit.lm(junk)
</code></pre>

<hr>
<h2 id='fun.data.fit.ml'> Fit data using RS, FMKL maximum likelihood estimation and the FMKL 
starship method. </h2><span id='topic+fun.data.fit.ml'></span>

<h3>Description</h3>

<p>This function fits generalised lambda distributions to data using RPRS, RMFMKL 
and starship methods.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fun.data.fit.ml(data, rs.leap = 3, fmkl.leap = 3, rs.init = c(-1.5, 1.5), 
fmkl.init = c(-0.25, 1.5),FUN="runif.sobol",no=10000)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fun.data.fit.ml_+3A_data">data</code></td>
<td>
<p> Dataset to be fitted. </p>
</td></tr>
<tr><td><code id="fun.data.fit.ml_+3A_rs.leap">rs.leap</code></td>
<td>
<p> See scrambling argument in <code><a href="#topic+fun.gen.qrn">fun.gen.qrn</a></code>. </p>
</td></tr>
<tr><td><code id="fun.data.fit.ml_+3A_fmkl.leap">fmkl.leap</code></td>
<td>
<p> See scrambling argument in <code><a href="#topic+fun.gen.qrn">fun.gen.qrn</a></code>. </p>
</td></tr>
<tr><td><code id="fun.data.fit.ml_+3A_rs.init">rs.init</code></td>
<td>
<p> Inititial values (lambda3 and lambda4) for the RS generalised 
lambda distribution. </p>
</td></tr>
<tr><td><code id="fun.data.fit.ml_+3A_fmkl.init">fmkl.init</code></td>
<td>
<p> Inititial values (lambda3 and lambda4) for the FMKL 
generalised lambda distribution. </p>
</td></tr>
<tr><td><code id="fun.data.fit.ml_+3A_fun">FUN</code></td>
<td>
<p> A character string of either  <code>"runif.sobol"</code> (default), <code>"runif.sobol.owen"</code>, 
<code>"runif.halton"</code> or <code>"QUnif"</code>. </p>
</td></tr>
<tr><td><code id="fun.data.fit.ml_+3A_no">no</code></td>
<td>
<p> Number of initial random values to find the best initial values for 
optimisation. </p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function consolidates <code><a href="#topic+fun.RPRS.ml">fun.RPRS.ml</a></code>, 
<code><a href="#topic+fun.RMFMKL.ml">fun.RMFMKL.ml</a></code> and <code><a href="#topic+starship">starship</a></code> and gives all the fits in 
one output.
</p>


<h3>Value</h3>

<p>A matrix showing the parameters of generalised lambda distribution for RPRS, 
FMFKL and STAR methods.
</p>


<h3>Note</h3>

<p> RPRS can sometimes fail if it is not possible to calculate the 
percentiles of the data set. This usually happens
when the number of data point is small. </p>


<h3>Author(s)</h3>

<p> Steve Su </p>


<h3>References</h3>

  
<p>King, R.A.R. &amp; MacGillivray, H. L. (1999), A starship method for fitting the 
generalised lambda distributions, Australian and New
Zealand Journal of Statistics, 41, 353-374
</p>
<p>Su, S. (2007). Numerical Maximum Log Likelihood Estimation for Generalized 
Lambda Distributions. Computational statistics and data analysis 51(8) 
3983-3998. 
</p>
<p>Su (2007). Fitting Single and Mixture of Generalized Lambda Distributions to 
Data via Discretized and Maximum Likelihood Methods: GLDEX in R. 
Journal of Statistical Software: *21* 9.
</p>


<h3>See Also</h3>

 <p><code><a href="#topic+fun.RPRS.ml">fun.RPRS.ml</a></code>, <code><a href="#topic+fun.RMFMKL.ml">fun.RMFMKL.ml</a></code>, 
<code><a href="#topic+starship">starship</a></code>, <code><a href="#topic+fun.data.fit.hs">fun.data.fit.hs</a></code>, 
<code><a href="#topic+fun.data.fit.hs.nw">fun.data.fit.hs.nw</a></code> ,
<code><a href="#topic+fun.data.fit.qs">fun.data.fit.qs</a></code> ,
<code><a href="#topic+fun.data.fit.mm">fun.data.fit.mm</a></code> ,
<code><a href="#topic+fun.data.fit.lm">fun.data.fit.lm</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Fitting normal(3,2) distriution using the default setting
 junk&lt;-rnorm(50,3,2)
 fun.data.fit.ml(junk)
</code></pre>

<hr>
<h2 id='fun.data.fit.mm'> Fit data using moment matching estimation for RS and FMKL GLD </h2><span id='topic+fun.data.fit.mm'></span>

<h3>Description</h3>

<p>This function fits generalised lambda distributions to data using moment
matching method
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fun.data.fit.mm(data, rs.leap = 3, fmkl.leap = 3, rs.init = c(-1.5, 1.5), 
fmkl.init = c(-0.25, 1.5), FUN = "runif.sobol", no = 10000)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fun.data.fit.mm_+3A_data">data</code></td>
<td>
<p> Dataset to be fitted. </p>
</td></tr>
<tr><td><code id="fun.data.fit.mm_+3A_rs.leap">rs.leap</code></td>
<td>
<p> See scrambling argument in <code><a href="#topic+fun.gen.qrn">fun.gen.qrn</a></code>. </p>
</td></tr>
<tr><td><code id="fun.data.fit.mm_+3A_fmkl.leap">fmkl.leap</code></td>
<td>
<p> See scrambling argument in <code><a href="#topic+fun.gen.qrn">fun.gen.qrn</a></code>. </p>
</td></tr>
<tr><td><code id="fun.data.fit.mm_+3A_rs.init">rs.init</code></td>
<td>
<p> Inititial values (lambda3 and lambda4) for the RS generalised 
lambda distribution. </p>
</td></tr>
<tr><td><code id="fun.data.fit.mm_+3A_fmkl.init">fmkl.init</code></td>
<td>
<p> Inititial values (lambda3 and lambda4) for the FMKL 
generalised lambda distribution. </p>
</td></tr>
<tr><td><code id="fun.data.fit.mm_+3A_fun">FUN</code></td>
<td>
<p> A character string of either  <code>"runif.sobol"</code> (default), <code>"runif.sobol.owen"</code>, 
<code>"runif.halton"</code> or <code>"QUnif"</code>. </p>
</td></tr>
<tr><td><code id="fun.data.fit.mm_+3A_no">no</code></td>
<td>
<p> Number of initial random values to find the best initial values for 
optimisation. </p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function consolidates <code><a href="#topic+fun.RPRS.mm">fun.RPRS.mm</a></code> and  
<code><a href="#topic+fun.RMFMKL.mm">fun.RMFMKL.mm</a></code> and gives all the fits in 
one output.
</p>


<h3>Value</h3>

<p>A matrix showing the parameters of RS and FMKL generalised lambda distributions.
</p>


<h3>Note</h3>

<p> RPRS can sometimes fail if it is not possible to calculate the 
percentiles of the data set. This usually happens
when the number of data point is small. </p>


<h3>References</h3>

<p> Karian, Z. and E. Dudewicz (2000). Fitting Statistical 
Distributions: The Generalized Lambda Distribution and Generalised Bootstrap 
Methods. New York, Chapman and Hall. </p>


<h3>See Also</h3>

 <p><code><a href="#topic+fun.RPRS.qs">fun.RPRS.qs</a></code>, <code><a href="#topic+fun.RMFMKL.qs">fun.RMFMKL.qs</a></code>, 
<code><a href="#topic+fun.data.fit.ml">fun.data.fit.ml</a></code>, <code><a href="#topic+fun.data.fit.hs">fun.data.fit.hs</a></code>, 
<code><a href="#topic+fun.data.fit.hs.nw">fun.data.fit.hs.nw</a></code> , <code><a href="#topic+fun.data.fit.qs">fun.data.fit.qs</a></code>, 
<code><a href="#topic+fun.data.fit.lm">fun.data.fit.lm</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Fitting normal(3,2) distriution using the default setting
 junk&lt;-rnorm(50,3,2)
 fun.data.fit.mm(junk)
  </code></pre>

<hr>
<h2 id='fun.data.fit.qs'> Fit data using quantile matching estimation for RS and FMKL GLD </h2><span id='topic+fun.data.fit.qs'></span>

<h3>Description</h3>

<p>This function fits generalised lambda distributions to data using quantile
matching method
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fun.data.fit.qs(data, rs.leap = 3, fmkl.leap = 3, rs.init = c(-1.5, 1.5), 
fmkl.init = c(-0.25, 1.5), FUN = "runif.sobol", trial.n = 100, len = 1000, 
type = 7, no = 10000)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fun.data.fit.qs_+3A_data">data</code></td>
<td>
<p> Dataset to be fitted. </p>
</td></tr>
<tr><td><code id="fun.data.fit.qs_+3A_rs.leap">rs.leap</code></td>
<td>
<p> See scrambling argument in <code><a href="#topic+fun.gen.qrn">fun.gen.qrn</a></code>. </p>
</td></tr>
<tr><td><code id="fun.data.fit.qs_+3A_fmkl.leap">fmkl.leap</code></td>
<td>
<p> See scrambling argument in <code><a href="#topic+fun.gen.qrn">fun.gen.qrn</a></code>. </p>
</td></tr>
<tr><td><code id="fun.data.fit.qs_+3A_rs.init">rs.init</code></td>
<td>
<p> Inititial values (lambda3 and lambda4) for the RS generalised 
lambda distribution. </p>
</td></tr>
<tr><td><code id="fun.data.fit.qs_+3A_fmkl.init">fmkl.init</code></td>
<td>
<p> Inititial values (lambda3 and lambda4) for the FMKL 
generalised lambda distribution. </p>
</td></tr>
<tr><td><code id="fun.data.fit.qs_+3A_fun">FUN</code></td>
<td>
<p> A character string of either  <code>"runif.sobol"</code> (default), <code>"runif.sobol.owen"</code>, 
<code>"runif.halton"</code> or <code>"QUnif"</code>. </p>
</td></tr>
<tr><td><code id="fun.data.fit.qs_+3A_trial.n">trial.n</code></td>
<td>
<p> Number of evenly spaced quantile ranging from 0 to 1 to be
used in the checking phase, to find the best set of initial values for 
optimisation, this is intended to be lower than <code>len</code> to speed up the 
fitting algorithm. Default is 100. </p>
</td></tr>
<tr><td><code id="fun.data.fit.qs_+3A_len">len</code></td>
<td>
<p> Number of evenly spaced quantile ranging from 0 to 1 to be used,
default is 1000 </p>
</td></tr>
<tr><td><code id="fun.data.fit.qs_+3A_type">type</code></td>
<td>
<p> Type of quantile to be used, default is 7, see <code>quantile</code> </p>
</td></tr>
<tr><td><code id="fun.data.fit.qs_+3A_no">no</code></td>
<td>
<p> Number of initial random values to find the best initial values for 
optimisation. </p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function consolidates <code><a href="#topic+fun.RPRS.qs">fun.RPRS.qs</a></code> and  
<code><a href="#topic+fun.RMFMKL.qs">fun.RMFMKL.qs</a></code> and gives all the fits in 
one output.
</p>


<h3>Value</h3>

<p>A matrix showing the parameters of RS and FMKL generalised lambda distributions.
</p>


<h3>Note</h3>

<p> RPRS can sometimes fail if it is not possible to calculate the 
percentiles of the data set. This usually happens
when the number of data point is small. </p>


<h3>Author(s)</h3>

<p> Steve Su </p>


<h3>References</h3>

<p> Su (2008). Fitting GLD to data via quantile matching method. 
(Book chapter to appear) </p>


<h3>See Also</h3>

 <p><code><a href="#topic+fun.RPRS.qs">fun.RPRS.qs</a></code>, <code><a href="#topic+fun.RMFMKL.qs">fun.RMFMKL.qs</a></code>, 
<code><a href="#topic+fun.data.fit.ml">fun.data.fit.ml</a></code>, <code><a href="#topic+fun.data.fit.hs">fun.data.fit.hs</a></code>, 
<code><a href="#topic+fun.data.fit.hs.nw">fun.data.fit.hs.nw</a></code> , <code><a href="#topic+fun.data.fit.mm">fun.data.fit.mm</a></code>, 
<code><a href="#topic+fun.data.fit.lm">fun.data.fit.lm</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Fitting normal(3,2) distriution using the default setting
 junk&lt;-rnorm(50,3,2)
 fun.data.fit.qs(junk)
</code></pre>

<hr>
<h2 id='fun.diag.ks.g'> Compute the simulated Kolmogorov-Smirnov tests for the unimodal 
dataset </h2><span id='topic+fun.diag.ks.g'></span>

<h3>Description</h3>

<p>This function counts the number of times the p-value exceed 0.05 for the null 
hypothesis that the observations simulated from the fitted distribution is the same 
as the observations simulated from the unimodal data set. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fun.diag.ks.g(result, data, no.test = 1000, len = floor(0.9 * length(data)), 
param, alpha = 0.05)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fun.diag.ks.g_+3A_result">result</code></td>
<td>
<p> A vector representing the four parameters of the generalised 
lambda distribution.  </p>
</td></tr>
<tr><td><code id="fun.diag.ks.g_+3A_data">data</code></td>
<td>
<p> The unimodal dataset. </p>
</td></tr>
<tr><td><code id="fun.diag.ks.g_+3A_no.test">no.test</code></td>
<td>
<p> Total number of tests required. </p>
</td></tr>
<tr><td><code id="fun.diag.ks.g_+3A_len">len</code></td>
<td>
<p> Number of data to sample. </p>
</td></tr>
<tr><td><code id="fun.diag.ks.g_+3A_param">param</code></td>
<td>
<p> Type of the generalised lambda distribution, <code>"rs"</code> or 
<code>"fmkl"</code>. </p>
</td></tr>
<tr><td><code id="fun.diag.ks.g_+3A_alpha">alpha</code></td>
<td>
<p> Significance level of KS test. </p>
</td></tr>
</table>


<h3>Value</h3>

<p>A numerical value representing number of times the p-value exceeds alpha.
</p>


<h3>Note</h3>

<p>If there are ties, jittering is used in <code><a href="#topic+ks.gof">ks.gof</a></code>.
</p>


<h3>Author(s)</h3>

<p> Steve Su </p>


<h3>References</h3>

<p> Stephens, M. A. (1986). Tests based on EDF statistics. 
In Goodness-of-Fit Techniques. D'Agostino, R. B. and Stevens, M. A., eds. 
New York: Marcel Dekker.
</p>
<p>Su, S. (2005). A Discretized Approach to Flexibly Fit Generalized Lambda 
Distributions to Data. Journal of Modern Applied Statistical Methods (November): 
408-424.
</p>
<p>Su (2007). Nmerical Maximum Log Likelihood Estimation for Generalized Lambda 
Distributions.  Computational Statistics and Data Analysis: *51*, 8, 3983-3998.
</p>
<p>Su (2007). Fitting Single and Mixture of Generalized Lambda Distributions to 
Data via Discretized and Maximum Likelihood Methods: GLDEX in R. 
Journal of Statistical Software: *21* 9.
</p>


<h3>See Also</h3>

 <p><code><a href="#topic+fun.diag.ks.g.bimodal">fun.diag.ks.g.bimodal</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Generate 1000 random observations from Normal distribution with mean=100, 
# standard deviation=10. Save this as junk
 junk&lt;-rnorm(1000,100,10)

# Fit junk using RPRS method via the maxmum likelihood.
 fit1&lt;-fun.RPRS.ml(junk, c(-1.5, 1.5), leap = 3)

# Calculate the simulated KS test result:
 fun.diag.ks.g(fit1,junk,param="rs")
</code></pre>

<hr>
<h2 id='fun.diag.ks.g.bimodal'> Compute the simulated Kolmogorov-Smirnov tests for the bimodal dataset </h2><span id='topic+fun.diag.ks.g.bimodal'></span>

<h3>Description</h3>

<p>This function counts the number of times the p-value exceed 0.05 for the null 
hypothesis that the observations simulated from the fitted distribution is the same 
as the observations simulated from the bimodal data set. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fun.diag.ks.g.bimodal(result1, result2, prop1, prop2, data, no.test = 1000, 
len = floor(0.9 * length(data)), param1, param2, alpha = 0.05)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fun.diag.ks.g.bimodal_+3A_result1">result1</code></td>
<td>
<p> A vector representing the four parameters of the first 
generalised lambda distribution. </p>
</td></tr>
<tr><td><code id="fun.diag.ks.g.bimodal_+3A_result2">result2</code></td>
<td>
<p> A vector representing the four parameters of the second 
generalised lambda distribution. </p>
</td></tr>
<tr><td><code id="fun.diag.ks.g.bimodal_+3A_prop1">prop1</code></td>
<td>
<p> Proportion of the first distribution fitted to the bimodal 
dataset. </p>
</td></tr>
<tr><td><code id="fun.diag.ks.g.bimodal_+3A_prop2">prop2</code></td>
<td>
<p> Proportion of the second distribution fitted to the bimodal 
dataset. </p>
</td></tr>
<tr><td><code id="fun.diag.ks.g.bimodal_+3A_data">data</code></td>
<td>
<p> The bimodal dataset. </p>
</td></tr>
<tr><td><code id="fun.diag.ks.g.bimodal_+3A_no.test">no.test</code></td>
<td>
<p> Total number of tests required. </p>
</td></tr>
<tr><td><code id="fun.diag.ks.g.bimodal_+3A_len">len</code></td>
<td>
<p> Number of data to sample. </p>
</td></tr>
<tr><td><code id="fun.diag.ks.g.bimodal_+3A_param1">param1</code></td>
<td>
<p> Type of first generalised lambda distribution, can be 
<code>"rs"</code> or <code>"fmkl"</code>. </p>
</td></tr>
<tr><td><code id="fun.diag.ks.g.bimodal_+3A_param2">param2</code></td>
<td>
<p> Type of second generalised lambda distribution, can be 
<code>"rs"</code> or <code>"fmkl"</code>. </p>
</td></tr>
<tr><td><code id="fun.diag.ks.g.bimodal_+3A_alpha">alpha</code></td>
<td>
<p> Significance level of KS test. </p>
</td></tr>
</table>


<h3>Value</h3>

<p>A numerical value representing number of times the p-value exceeds alpha.
</p>


<h3>Note</h3>

<p>If there are ties, jittering is used in <code><a href="#topic+ks.gof">ks.gof</a></code>.
</p>


<h3>Author(s)</h3>

<p> Steve Su </p>


<h3>References</h3>

<p> Stephens, M. A. (1986). Tests based on EDF statistics. In Goodness-
of-Fit Techniques. D'Agostino, R. B. and Stevens, M. A., eds. New York: Marcel 
Dekker.
</p>
<p>Su, S. (2005). A Discretized Approach to Flexibly Fit Generalized Lambda 
Distributions to Data. Journal of Modern Applied Statistical Methods (November): 
408-424.
</p>
<p>Su (2007). Nmerical Maximum Log Likelihood Estimation for Generalized Lambda 
Distributions.  Computational Statistics and Data Analysis: *51*, 8, 3983-3998.
</p>
<p>Su (2007). Fitting Single and Mixture of Generalized Lambda Distributions to 
Data via Discretized and Maximum Likelihood Methods: GLDEX in R. 
Journal of Statistical Software: *21* 9.
</p>


<h3>See Also</h3>

 <p><code><a href="#topic+fun.diag.ks.g">fun.diag.ks.g</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Fit the faithful[,1] data from the MASS library
 fit1&lt;-fun.auto.bimodal.ml(faithful[,1],init1.sel="rprs",init2.sel="rmfmkl",
 init1=c(-1.5,1,5),init2=c(-0.25,1.5),leap1=3,leap2=3)
# Run diagnostic KS tests
 fun.diag.ks.g.bimodal(fit1$par[1:4],fit1$par[5:8],prop1=fit1$par[9],
 data=faithful[,1],param1="rs",param2="fmkl")
</code></pre>

<hr>
<h2 id='fun.diag1'> Diagnostic function for theoretical distribution fits through the 
resample Kolmogorov-Smirnoff tests </h2><span id='topic+fun.diag1'></span>

<h3>Description</h3>

<p>This function is primarily designed to be used for testing the fitted 
distribution with reference to a theoretical distribution. It is also
tailored for output obtained from the <code><a href="#topic+fun.data.fit.ml">fun.data.fit.ml</a></code> function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fun.diag1(result, test, no.test = 1000, alpha = 0.05)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fun.diag1_+3A_result">result</code></td>
<td>
<p> Output from <code><a href="#topic+fun.data.fit.ml">fun.data.fit.ml</a></code> function. </p>
</td></tr>
<tr><td><code id="fun.diag1_+3A_test">test</code></td>
<td>
<p> Simulated observations from theoretical distribution, the length 
should be no.test<code class="reqn">\mbox{\textasciitilde}</code>2. </p>
</td></tr>
<tr><td><code id="fun.diag1_+3A_no.test">no.test</code></td>
<td>
<p> Number of times to do the KS tests. </p>
</td></tr>
<tr><td><code id="fun.diag1_+3A_alpha">alpha</code></td>
<td>
<p> Significance level of KS test. </p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector showing the number of times the KS p-value is greater than alpha for 
each of the distribution fit strategy.
</p>


<h3>Note</h3>

<p> If there are ties, jittering is used in <code><a href="#topic+ks.gof">ks.gof</a></code>.
</p>


<h3>Author(s)</h3>

<p> Steve Su </p>


<h3>References</h3>

<p> Su, S. (2005). A Discretized Approach to Flexibly Fit Generalized 
Lambda Distributions to Data. Journal of Modern Applied Statistical 
Methods (November): 408-424. 
</p>
<p>Su, S. (2007). Numerical Maximum Log Likelihood Estimation for Generalized 
Lambda Distributions. Journal of Computational statistics and data analysis 
51(8) 3983-3998. 
</p>
<p>Su (2007). Fitting Single and Mixture of Generalized Lambda Distributions to 
Data via Discretized and Maximum Likelihood Methods: GLDEX in R. 
Journal of Statistical Software: *21* 9. </p>


<h3>See Also</h3>

 <p><code><a href="#topic+fun.diag2">fun.diag2</a></code>, <code><a href="#topic+fun.diag.ks.g">fun.diag.ks.g</a></code>, 
<code><a href="#topic+fun.diag.ks.g.bimodal">fun.diag.ks.g.bimodal</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Fits a Weibull 5,2 distribution:
 weibull.approx.ml&lt;-fun.data.fit.ml(rweibull(1000,5,2))

# Compute the resample K-S test results.
 fun.diag1(weibull.approx.ml, rweibull(100000, 5, 2))

</code></pre>

<hr>
<h2 id='fun.diag2'> Diagnostic function for empirical data distribution fits through the 
resample Kolmogorov-Smirnoff tests </h2><span id='topic+fun.diag2'></span>

<h3>Description</h3>

<p>This function is primarily designed to be used for testing the fitted 
distribution with reference to an empirical data. It is also
tailored for output obtained from the <code><a href="#topic+fun.data.fit.ml">fun.data.fit.ml</a></code> function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fun.diag2(result, data, no.test = 1000, len=100, alpha = 0.05)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fun.diag2_+3A_result">result</code></td>
<td>
<p> Output from <code><a href="#topic+fun.data.fit.ml">fun.data.fit.ml</a></code> function. </p>
</td></tr>
<tr><td><code id="fun.diag2_+3A_data">data</code></td>
<td>
<p> Observations in which the distribution was fitted upon. </p>
</td></tr>
<tr><td><code id="fun.diag2_+3A_no.test">no.test</code></td>
<td>
<p> Number of times to do the KS tests. </p>
</td></tr>
<tr><td><code id="fun.diag2_+3A_len">len</code></td>
<td>
<p> Number of observations to sample from the data. This is also the 
number of observations sampled from the fitted distribution in each KS test. </p>
</td></tr>
<tr><td><code id="fun.diag2_+3A_alpha">alpha</code></td>
<td>
<p> Significance level of KS test. </p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector showing the number of times the KS p-value is greater than alpha for 
each of the distribution fit strategy.
</p>


<h3>Note</h3>

<p> If there are ties, jittering is used in <code><a href="#topic+ks.gof">ks.gof</a></code>.
</p>


<h3>Author(s)</h3>

<p> Steve Su </p>


<h3>References</h3>

<p> Su, S. (2005). A Discretized Approach to Flexibly Fit Generalized 
Lambda Distributions to Data. Journal of Modern Applied Statistical 
Methods (November): 408-424. 
</p>
<p>Su, S. (2007). Numerical Maximum Log Likelihood Estimation for Generalized 
Lambda Distributions. Journal of Computational statistics and data analysis 
51(8) 3983-3998. 
</p>
<p>Su (2007). Fitting Single and Mixture of Generalized Lambda Distributions to 
Data via Discretized and Maximum Likelihood Methods: GLDEX in R. 
Journal of Statistical Software: *21* 9. </p>


<h3>See Also</h3>

 <p><code><a href="#topic+fun.diag1">fun.diag1</a></code>, <code><a href="#topic+fun.diag.ks.g">fun.diag.ks.g</a></code>, 
<code><a href="#topic+fun.diag.ks.g.bimodal">fun.diag.ks.g.bimodal</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Fits a Normal 3,2 distribution:
 junk&lt;-rnorm(1000,3,2)
 fit&lt;-fun.data.fit.ml(junk)

# Compute the resample K-S test results.
 fun.diag2(fit,junk)
</code></pre>

<hr>
<h2 id='fun.disc.estimation'> Estimates the mean and variance after cutting up a vector of variable 
into evenly spaced categories. </h2><span id='topic+fun.disc.estimation'></span>

<h3>Description</h3>

<p>This function supplements <code><a href="#topic+fun.nclass.e">fun.nclass.e</a></code> and it is not intended to 
be used by the users directly.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fun.disc.estimation(x, nint)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fun.disc.estimation_+3A_x">x</code></td>
<td>
<p> A vector of observations. </p>
</td></tr>
<tr><td><code id="fun.disc.estimation_+3A_nint">nint</code></td>
<td>
<p> Number of intervals to cut the vectors into.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function cuts the vector into evenly spaced categories and estimate 
the mean and variance of
the actual data based on the categorisation.
</p>


<h3>Value</h3>

<p>Two numerical values, the first being the mean and the second being the 
variance.
</p>


<h3>Author(s)</h3>

<p> Steve Su </p>


<h3>See Also</h3>

 <p><code><a href="#topic+fun.nclass.e">fun.nclass.e</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Cut up a randomly normally distributed observations into 5 evenly spaced 
## categories and estimate the mean and variance based on this cateogorisation.
junk&lt;-rnorm(1000,3,2)
fun.disc.estimation(junk,5)
</code></pre>

<hr>
<h2 id='fun.gen.qrn'> Finds the low discrepancy quasi random numbers </h2><span id='topic+fun.gen.qrn'></span>

<h3>Description</h3>

<p>This function calls the <code>runif.sobol</code>, <code>runif.sobol.owen</code> and 
<code>runif.halton</code> essentially from the <span class="pkg">spacefillr</span> package.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fun.gen.qrn(n, dimension, scrambling, FUN = "runif.sobol")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fun.gen.qrn_+3A_n">n</code></td>
<td>
<p> Number to generate. </p>
</td></tr>
<tr><td><code id="fun.gen.qrn_+3A_dimension">dimension</code></td>
<td>
<p> Number of dimensions. </p>
</td></tr>
<tr><td><code id="fun.gen.qrn_+3A_scrambling">scrambling</code></td>
<td>
<p> seed used, or leap as in the case of 
<code><a href="#topic+QUnif">QUnif</a></code>. </p>
</td></tr>
<tr><td><code id="fun.gen.qrn_+3A_fun">FUN</code></td>
<td>
<p> This can be <code>"runif.sobol"</code> (default), <code>"runif.sobol.owen"</code>, <code>"runif.halton"</code> 
or <code>"QUnif"</code>. </p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector of values if dimension=1, otherwise a matrix of values between 0 
and 1.
</p>


<h3>Author(s)</h3>

<p> Steve Su </p>


<h3>Examples</h3>

<pre><code class='language-R'>fun.gen.qrn(1000,5,3,"runif.sobol")

fun.gen.qrn(1000,5,409,"QUnif")
</code></pre>

<hr>
<h2 id='fun.lm.theo.gld'> Find the theoretical first four L moments of the generalised lambda 
distribution. </h2><span id='topic+fun.lm.theo.gld'></span>

<h3>Description</h3>

<p>This function computes the first four L moments for both RS and FMKL  
generalised lambda distributions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fun.lm.theo.gld(L1, L2, L3, L4, param)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fun.lm.theo.gld_+3A_l1">L1</code></td>
<td>
<p> Lambda 1. Or c(Lambda 1,Lambda 2,Lambda 3,Lambda 4). </p>
</td></tr>
<tr><td><code id="fun.lm.theo.gld_+3A_l2">L2</code></td>
<td>
<p> Lambda 2. </p>
</td></tr>
<tr><td><code id="fun.lm.theo.gld_+3A_l3">L3</code></td>
<td>
<p> Lambda 3. </p>
</td></tr>
<tr><td><code id="fun.lm.theo.gld_+3A_l4">L4</code></td>
<td>
<p> Lambda 4. </p>
</td></tr>
<tr><td><code id="fun.lm.theo.gld_+3A_param">param</code></td>
<td>
<p> &quot;rs&quot; or &quot;fmkl&quot; or &quot;fkml&quot; </p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector listing the first four L moments
</p>


<h3>Note</h3>

<p> Sometimes the theoretical moments may not exist, in those cases, 
<code>NA</code> is returned.
</p>


<h3>Author(s)</h3>

<p> Steve Su </p>


<h3>References</h3>

<p> Asquith, W. (2007). 
&quot;L-moments and TL-moments of the generalized lambda distribution.&quot; 
Computational Statistics and Data Analysis 51(9): 4484-4496.
</p>
<p>Karvanen, J. and A. Nuutinen (2008). 
&quot;Characterizing the generalized lambda distribution by L-moments.&quot; 
Computational Statistics and Data Analysis 52(4): 1971-1983. </p>


<h3>See Also</h3>

 <p><code><a href="#topic+fun.theo.mv.gld">fun.theo.mv.gld</a></code>  </p>


<h3>Examples</h3>

<pre><code class='language-R'>fun.lm.theo.gld(1, 2, 3, 4, "rs")
fun.lm.theo.gld(1, 2, 3, 4, "fmkl")
</code></pre>

<hr>
<h2 id='fun.mApply'> Applying functions based on an index for a matrix. </h2><span id='topic+fun.mApply'></span>

<h3>Description</h3>

<p>This is a generic function that can be used to find mean, variance, sum or 
other operations according to some
index imposed on the matrix or vector.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fun.mApply(X, INDEX, FUN = NULL, ..., simplify = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fun.mApply_+3A_x">X</code></td>
<td>
<p> Matrix with n rows. </p>
</td></tr>
<tr><td><code id="fun.mApply_+3A_index">INDEX</code></td>
<td>
<p> Vector or list of vectors of length n. </p>
</td></tr>
<tr><td><code id="fun.mApply_+3A_fun">FUN</code></td>
<td>
<p> Function to operate on submatrices of <code>X</code> by <code>INDEX</code></p>
</td></tr>
<tr><td><code id="fun.mApply_+3A_...">...</code></td>
<td>
<p> Arguments to function. </p>
</td></tr>
<tr><td><code id="fun.mApply_+3A_simplify">simplify</code></td>
<td>
<p> Set as <code>TRUE</code> by default, see <code><a href="base.html#topic+sapply">sapply</a></code> fo 
details. </p>
</td></tr>
</table>


<h3>Value</h3>

<p>If <code>FUN</code> returns more than one number, <code>fun.mApply</code> returns a matrix 
with rows corresponding to unique values of <code>INDEX</code>.
</p>


<h3>Author(s)</h3>

<p> Tony Plate </p>


<h3>Examples</h3>

<pre><code class='language-R'> 
# Finding the row medians of a matrix (matrix(1:20,nrow=5))
fun.mApply(matrix(1:20,nrow=5),list(1:5),median)
</code></pre>

<hr>
<h2 id='fun.minmax.check.gld'>
Check whether the specified GLDs cover the minimum and the maximum values in a 
dataset
</h2><span id='topic+fun.minmax.check.gld'></span>

<h3>Description</h3>

<p>This function checks the lowest and highest quantiles of the specified GLDs 
against the 
specified dataset
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fun.minmax.check.gld(data, lambdas, param, lessequalmin = 1, 
greaterequalmax = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fun.minmax.check.gld_+3A_data">data</code></td>
<td>

<p>A vector of numerical dataset
</p>
</td></tr>
<tr><td><code id="fun.minmax.check.gld_+3A_lambdas">lambdas</code></td>
<td>

<p>A matrix of four columns representing lambda 1 to lambda 4 of the GLD
</p>
</td></tr>
<tr><td><code id="fun.minmax.check.gld_+3A_param">param</code></td>
<td>

<p>Can be &quot;rs&quot;, &quot;fkml&quot; or &quot;fmkl&quot;
</p>
</td></tr>
<tr><td><code id="fun.minmax.check.gld_+3A_lessequalmin">lessequalmin</code></td>
<td>

<p>Can be 0 or 1
</p>
</td></tr>
<tr><td><code id="fun.minmax.check.gld_+3A_greaterequalmax">greaterequalmax</code></td>
<td>

<p>Can be 0 or 1
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>lessequalmin==1 means the lowest value of GLD &lt;= minimum value of data
lessequalmin==0 means the lowest value of GLD &lt; minimum value of data
greaterequalmin==1 means the highest value of GLD &gt;= maximum value of data
greaterequalmin==0 means the highest value of GLD &gt; maximum value of data
</p>


<h3>Value</h3>

<p>A vector of logical values indicating whether the specified data 
the specified GLDs cover the minimum and the maximum values in a dataset
</p>


<h3>Author(s)</h3>

<p>Steve Su
</p>


<h3>Examples</h3>

<pre><code class='language-R'>fun.minmax.check.gld(runif(100,.9,1),matrix(1:12,ncol=4),param="rs",0,0)
fun.minmax.check.gld(runif(100,.98,1),matrix(1:12,ncol=4),param="fkml",1,1)
</code></pre>

<hr>
<h2 id='fun.moments.bimodal'> Finds the moments of fitted mixture of 
generalised lambda distribution by simulation. </h2><span id='topic+fun.moments.bimodal'></span>

<h3>Description</h3>

<p>This functions compute the mean, variance, skewness and kurtosis of the fitted 
generalised lambda distribution mixtures using Monte
Carlo simulation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fun.moments.bimodal(result1, result2, prop1, prop2, len = 1000, 
no.test = 1000, param1, param2)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fun.moments.bimodal_+3A_result1">result1</code></td>
<td>
<p> A vector comprising four values for the first generalised 
lambda distribution. </p>
</td></tr>
<tr><td><code id="fun.moments.bimodal_+3A_result2">result2</code></td>
<td>
<p> A vector comprising four values for the second generalised 
lambda distribution. </p>
</td></tr>
<tr><td><code id="fun.moments.bimodal_+3A_prop1">prop1</code></td>
<td>
<p> Proportion of the first generalised lambda distribution </p>
</td></tr>
<tr><td><code id="fun.moments.bimodal_+3A_prop2">prop2</code></td>
<td>
<p> 1-prop1, this can be left unspecified. </p>
</td></tr>
<tr><td><code id="fun.moments.bimodal_+3A_len">len</code></td>
<td>
<p> Length of object for each simulation run. </p>
</td></tr>
<tr><td><code id="fun.moments.bimodal_+3A_no.test">no.test</code></td>
<td>
<p> Number of simulation run. </p>
</td></tr>
<tr><td><code id="fun.moments.bimodal_+3A_param1">param1</code></td>
<td>
<p> This can be <code>"rs"</code> or <code>"fmkl"</code>, specifying the type 
of the first generalised lambda distribution. </p>
</td></tr>
<tr><td><code id="fun.moments.bimodal_+3A_param2">param2</code></td>
<td>
<p> This can be <code>"rs"</code> or <code>"fmkl"</code>, specifying the type 
of the second generalised lambda distribution. </p>
</td></tr>
</table>


<h3>Details</h3>

<p>There is also a theoretical computation of the moments in 
<code><a href="#topic+fun.theo.bi.mv.gld">fun.theo.bi.mv.gld</a></code>, it should be noted
that the theoretical moments may not exist. The length of object in <code>len</code> 
means how many observations should
be generated in each simulation run, with the number of simulation runs governed 
by <code>no.test</code>.
</p>


<h3>Value</h3>

<p>A matrix with four columns showing the mean, variance, skewness and kurtosis 
of the fitted generalised lambda distribution mixtures using Monte
Carlo simulation. Each row represents a simulation run.
</p>


<h3>Author(s)</h3>

<p> Steve Su </p>


<h3>See Also</h3>

 <p><code><a href="#topic+fun.theo.bi.mv.gld">fun.theo.bi.mv.gld</a></code>, <code><a href="#topic+fun.simu.bimodal">fun.simu.bimodal</a></code>,
<code><a href="#topic+fun.rawmoments">fun.rawmoments</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Fitting the first column of the Old Faithful Geyser data
 fit1&lt;-fun.auto.bimodal.ml(faithful[,1],init1.sel="rmfmkl",init2.sel="rmfmkl",
 init1=c(-0.25,1.5),init2=c(-0.25,1.5),leap1=3,leap2=3)

# After fitting compute the monte carlo moments using fun.moments.bimodal
 fun.moments.bimodal(fit1$par[1:4],fit1$par[5:8],prop1=fit1$par[9],
 param1="fmkl",param2="fmkl")

# It is also possible to compare this with the moments of the original dataset:
 fun.moments(faithful[,1])

</code></pre>

<hr>
<h2 id='fun.moments.r'> Calculate mean, variance, skewness and kurtosis of a numerical vector </h2><span id='topic+fun.moments.r'></span>

<h3>Description</h3>

<p>This function evaluates the mean, variance, skewness and kurtosis of a 
numerical vector. Missing values are automatically removed.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fun.moments.r(x, normalise = "N")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fun.moments.r_+3A_x">x</code></td>
<td>
<p> A numeric vector </p>
</td></tr>
<tr><td><code id="fun.moments.r_+3A_normalise">normalise</code></td>
<td>
<p> &quot;Y&quot; if you want kurtosis to be calculated with reference
to kurtosis = 0 under Normal distribution. Default is &quot;N&quot;.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector of mean, variance, skewness and kurtosis.
</p>


<h3>Note</h3>

<p> Please contact the author directly if you find a bug! </p>


<h3>Author(s)</h3>

<p> Steve Su </p>


<h3>See Also</h3>

 <p><code><a href="#topic+fun.theo.mv.gld">fun.theo.mv.gld</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>
fun.moments.r(rnorm(1000))
fun.moments.r(rnorm(1000),normalise="Y")

</code></pre>

<hr>
<h2 id='fun.nclass.e'> Estimates the number of classes or bins to smooth over in the 
discretised method of fitting generalised lambda distribution to data. </h2><span id='topic+fun.nclass.e'></span>

<h3>Description</h3>

<p>Support function for discretised method of fitting distribution to data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fun.nclass.e(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fun.nclass.e_+3A_x">x</code></td>
<td>
<p> Vector of data. </p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function calculates the mean and variance of the discretised data from 1 
to the very last observation and chooses the best number
of categories that represent the mean and variance of the actual data set 
through the criterion of squared deviations.
</p>


<h3>Value</h3>

<p>A numerical value suggesting the best number of class that can be used to 
represent the mean and variane of the original data set.
</p>


<h3>Note</h3>

<p> This is not designed to be called directly by end user.
</p>


<h3>Author(s)</h3>

<p> Steve Su </p>


<h3>See Also</h3>

 <p><code><a href="#topic+fun.disc.estimation">fun.disc.estimation</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>fun.nclass.e(rnorm(100,3,2))
</code></pre>

<hr>
<h2 id='fun.plot.fit'> Plotting the univariate generalised lambda distribution fits on the data 
set. </h2><span id='topic+fun.plot.fit'></span>

<h3>Description</h3>

<p> This function is designed for univariate generalised lambda 
distribution fits only.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fun.plot.fit(fit.obj, data, nclass = 50, xlab = "", name = "", param.vec,
ylab="Density", main="")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fun.plot.fit_+3A_fit.obj">fit.obj</code></td>
<td>
<p> Fitted object from <code><a href="#topic+fun.data.fit.ml">fun.data.fit.ml</a></code>, 
<code><a href="#topic+fun.data.fit.hs">fun.data.fit.hs</a></code>, <code><a href="#topic+fun.data.fit.hs.nw">fun.data.fit.hs.nw</a></code>, 
<code><a href="#topic+fun.RPRS.ml">fun.RPRS.ml</a></code>, <code><a href="#topic+fun.RMFMKL.ml">fun.RMFMKL.ml</a></code>, 
<code><a href="#topic+fun.RPRS.hs">fun.RPRS.hs</a></code>, <code><a href="#topic+fun.RMFMKL.hs">fun.RMFMKL.hs</a></code>, 
<code><a href="#topic+fun.RPRS.hs.nw">fun.RPRS.hs.nw</a></code>, <code><a href="#topic+fun.RMFMKL.hs.nw">fun.RMFMKL.hs.nw</a></code> </p>
</td></tr>
<tr><td><code id="fun.plot.fit_+3A_data">data</code></td>
<td>
<p> Dataset to be plotted. </p>
</td></tr>
<tr><td><code id="fun.plot.fit_+3A_nclass">nclass</code></td>
<td>
<p> Number of class of histogram, the default is 50. </p>
</td></tr>
<tr><td><code id="fun.plot.fit_+3A_xlab">xlab</code></td>
<td>
<p> Label on the x axis. </p>
</td></tr>
<tr><td><code id="fun.plot.fit_+3A_name">name</code></td>
<td>
<p> Naming the type of distribution fits. </p>
</td></tr>
<tr><td><code id="fun.plot.fit_+3A_param.vec">param.vec</code></td>
<td>
<p> A vector describing the type of generalised lambda 
distribution used in the <code>fit.obj</code>. </p>
</td></tr>
<tr><td><code id="fun.plot.fit_+3A_ylab">ylab</code></td>
<td>
<p> Label on the y axis. </p>
</td></tr>
<tr><td><code id="fun.plot.fit_+3A_main">main</code></td>
<td>
<p> Title of the graph. </p>
</td></tr>
</table>


<h3>Value</h3>

<p>A graphical output showing the data and the resulting distributional fits.
</p>


<h3>Note</h3>

<p> If the distribution fits over fits the peak of the distribution, it can 
be difficult to see the actual data set.
</p>


<h3>Author(s)</h3>

<p> Steve Su </p>


<h3>See Also</h3>

 <p><code><a href="#topic+fun.plot.fit.bm">fun.plot.fit.bm</a></code>, <code><a href="#topic+fun.data.fit.ml">fun.data.fit.ml</a></code>, 
<code><a href="#topic+fun.data.fit.hs">fun.data.fit.hs</a></code>, <code><a href="#topic+fun.data.fit.hs.nw">fun.data.fit.hs.nw</a></code>, 
<code><a href="#topic+fun.RPRS.ml">fun.RPRS.ml</a></code>, <code><a href="#topic+fun.RMFMKL.ml">fun.RMFMKL.ml</a></code>, 
<code><a href="#topic+fun.RPRS.hs">fun.RPRS.hs</a></code>, <code><a href="#topic+fun.RMFMKL.hs">fun.RMFMKL.hs</a></code>, 
<code><a href="#topic+fun.RPRS.hs.nw">fun.RPRS.hs.nw</a></code>, <code><a href="#topic+fun.RMFMKL.hs.nw">fun.RMFMKL.hs.nw</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Generate Normally distribute random numbers as dataset
 junk&lt;-rnorm(1000,3,2)

# Fit the data set using fun.data.fit.ml. 
# Also, fun.data.fit.hs or fun.data.fit.hs.nw can be used.
 obj.fit&lt;-fun.data.fit.ml(junk)

# Plot the resulting fits
 fun.plot.fit(obj.fit,junk,xlab="x",name=".ML",param.vec=c("rs","fmkl","fmkl"))

# This function also works for singular fits such as those by fun.RPRS.ml,
# fun.RMFMKL.ml, fun.RPRS.hs, fun.RMFMKL.hs, fun.RPRS.hs.nw, fun.RMFMKL.hs.nw
 junk&lt;-rnorm(1000,3,2)
 obj.fit&lt;-fun.RPRS.ml(junk)
 fun.plot.fit(obj.fit,junk,xlab="x",name="RPRS.ML",param.vec=c("rs"))
</code></pre>

<hr>
<h2 id='fun.plot.fit.bm'> Plotting mixture of two generalised lambda distributions on the 
data set. </h2><span id='topic+fun.plot.fit.bm'></span>

<h3>Description</h3>

<p>This function is designed for mixture of two generalised lambda distributions
only.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fun.plot.fit.bm(fit.obj, data, nclass = 50, xlab = "", name = "", main="", 
param.vec, ylab="Density")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fun.plot.fit.bm_+3A_fit.obj">fit.obj</code></td>
<td>
<p> Fitted object from <code><a href="#topic+fun.auto.bimodal.ml">fun.auto.bimodal.ml</a></code>, 
<code><a href="#topic+fun.auto.bimodal.pml">fun.auto.bimodal.pml</a></code> </p>
</td></tr>
<tr><td><code id="fun.plot.fit.bm_+3A_data">data</code></td>
<td>
<p> Dataset to be plotted. </p>
</td></tr>
<tr><td><code id="fun.plot.fit.bm_+3A_nclass">nclass</code></td>
<td>
<p> Number of class of histogram, the default is 50. </p>
</td></tr>
<tr><td><code id="fun.plot.fit.bm_+3A_xlab">xlab</code></td>
<td>
<p> Label on the x axis. </p>
</td></tr>
<tr><td><code id="fun.plot.fit.bm_+3A_name">name</code></td>
<td>
<p> Legend, usually used to identify type of GLD used if <code>main</code>
is provided. If <code>main</code> is not provided, then this is used in the title. </p>
</td></tr>
<tr><td><code id="fun.plot.fit.bm_+3A_main">main</code></td>
<td>
<p> Title of the graph. </p>
</td></tr>
<tr><td><code id="fun.plot.fit.bm_+3A_param.vec">param.vec</code></td>
<td>
<p> A vector describing the type of generalised lambda 
distribution used in the <code>fit.obj</code>. </p>
</td></tr> 
<tr><td><code id="fun.plot.fit.bm_+3A_ylab">ylab</code></td>
<td>
<p> Label on the y axis. </p>
</td></tr>
</table>


<h3>Value</h3>

<p>A graphical output showing the data and the resulting distributional fits.
</p>


<h3>Note</h3>

<p> If the distribution fits over fits the peak of the distribution, it can 
be difficult to see the actual data set.
</p>


<h3>Author(s)</h3>

<p> Steve Su </p>


<h3>See Also</h3>

 <p><code><a href="#topic+fun.auto.bimodal.ml">fun.auto.bimodal.ml</a></code>, <code><a href="#topic+fun.auto.bimodal.pml">fun.auto.bimodal.pml</a></code>, 
<code><a href="#topic+fun.plot.fit">fun.plot.fit</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>

 opar &lt;- par() 
 par(mfrow=c(2,1))

# Fitting mixture of generalised lambda distributions on the data set using 
# both the maximum likelihood and partition maximum likelihood and plot 
# the resulting fits

 junk&lt;-fun.auto.bimodal.ml(faithful[,1],per.of.mix=0.1,clustering.m=clara,
 init1.sel="rprs",init2.sel="rmfmkl",init1=c(-1.5,1,5),init2=c(-0.25,1.5),
 leap1=3,leap2=3)
 fun.plot.fit.bm(nclass=50,fit.obj=junk,data=faithful[,1],
 name="Maximum likelihood using",xlab="faithful1",param.vec=c("rs","fmkl"))

 junk&lt;-fun.auto.bimodal.pml(faithful[,1],clustering.m=clara,init1.sel="rprs",
 init2.sel="rmfmkl",init1=c(-1.5,1,5),init2=c(-0.25,1.5),leap1=3,leap2=3)
 fun.plot.fit.bm(nclass=50,fit.obj=junk,data=faithful[,1],
 name="Partition maximum likelihood using",xlab="faithful1",
 param.vec=c("rs","fmkl"))

 junk&lt;-fun.auto.bimodal.ml(faithful[,1],per.of.mix=0.1,clustering.m=clara,
 init1.sel="rprs",init2.sel="rmfmkl",init1=c(-1.5,1,5),init2=c(-0.25,1.5),
 leap1=3,leap2=3)
 fun.plot.fit.bm(nclass=50,fit.obj=junk,data=faithful[,1],
 main="Mixture distribution fit",
 name="RS and FMKL GLD",xlab="faithful1",param.vec=c("rs","fmkl"))

 par(opar)

</code></pre>

<hr>
<h2 id='fun.plot.many.gld'> Plotting many univariate generalised lambda distributions on one page. </h2><span id='topic+fun.plot.many.gld'></span>

<h3>Description</h3>

<p>This is a variant of the <code><a href="#topic+fun.plot.fit">fun.plot.fit</a></code> function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fun.plot.many.gld(fit.obj, data, xlab="", ylab="Density", main="", legd="",
param.vec)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fun.plot.many.gld_+3A_fit.obj">fit.obj</code></td>
<td>
<p> A matrix of generalised lambda distibutions parameters 
from <code><a href="#topic+fun.data.fit.ml">fun.data.fit.ml</a></code>, <code><a href="#topic+fun.data.fit.hs">fun.data.fit.hs</a></code>, 
<code><a href="#topic+fun.data.fit.hs.nw">fun.data.fit.hs.nw</a></code>, <code><a href="#topic+fun.RPRS.ml">fun.RPRS.ml</a></code>, 
<code><a href="#topic+fun.RMFMKL.ml">fun.RMFMKL.ml</a></code>, <code><a href="#topic+fun.RPRS.hs">fun.RPRS.hs</a></code>, 
<code><a href="#topic+fun.RMFMKL.hs">fun.RMFMKL.hs</a></code>, <code><a href="#topic+fun.RPRS.hs.nw">fun.RPRS.hs.nw</a></code>, 
<code><a href="#topic+fun.RMFMKL.hs.nw">fun.RMFMKL.hs.nw</a></code> functions. Or a matrix of generalised lambda
distribution parameters. </p>
</td></tr>
<tr><td><code id="fun.plot.many.gld_+3A_data">data</code></td>
<td>
<p> Dataset to be plotted or two values showing the ranges of value 
to be compared. </p>
</td></tr>
<tr><td><code id="fun.plot.many.gld_+3A_xlab">xlab</code></td>
<td>
<p> X-axis labels. </p>
</td></tr>
<tr><td><code id="fun.plot.many.gld_+3A_ylab">ylab</code></td>
<td>
<p> Y-axis labels. </p>
</td></tr>
<tr><td><code id="fun.plot.many.gld_+3A_main">main</code></td>
<td>
<p> Title for the plot. </p>
</td></tr>
<tr><td><code id="fun.plot.many.gld_+3A_legd">legd</code></td>
<td>
<p> Legend for the plot. </p>
</td></tr>
<tr><td><code id="fun.plot.many.gld_+3A_param.vec">param.vec</code></td>
<td>
<p> A vector showing the types of generalised lambda 
distributions. This can be &quot;rs&quot; or &quot;fmkl&quot;, only needed if you want to put your 
own parameters for generalised lambda distributions which are not generated 
from a fitting algorithm in this package. </p>
</td></tr>
</table>


<h3>Value</h3>

<p>A graph showing the different distributions on the same page.
</p>


<h3>Note</h3>

<p> The data part of the function is not plotted, to see the dataset use the 
<code><a href="#topic+fun.plot.fit">fun.plot.fit</a></code> function.
</p>


<h3>Author(s)</h3>

<p> Steve Su </p>


<h3>See Also</h3>

 <p><code><a href="#topic+fun.plot.fit">fun.plot.fit</a></code>, <code><a href="#topic+fun.plot.fit.bm">fun.plot.fit.bm</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>

# Fit the dataset
 junk&lt;-rnorm(1000,3,2)
 result.hs&lt;-fun.data.fit.hs(junk,rs.default = "Y", fmkl.default = "Y", 
 rs.leap=3, fmkl.leap=3,rs.init = c(-1.5, 1.5), fmkl.init = c(-0.25, 1.5),
 no.c.rs=50,no.c.fmkl=50)

 opar &lt;- par() 
 par(mfrow=c(2,2))

# Plot the entire data range
 fun.plot.many.gld(result.hs,junk,"x","density","",
 legd=c("RPRS.hs", "RMFMKL.hs"))

# Plot and compare parts of the distributions
 fun.plot.many.gld(result.hs,c(1,2),"x","density","",legd=c("RPRS.hs", 
"RMFMKL.hs"))
 fun.plot.many.gld(result.hs,c(0.1,0,2),"x","density","",legd=c("RPRS.hs", 
"RMFMKL.hs"))
 fun.plot.many.gld(result.hs,c(3,4),"x","density","",legd=c("RPRS.hs", 
"RMFMKL.hs"))

 par(opar)


</code></pre>

<hr>
<h2 id='fun.rawmoments'> Computes the raw moments of the generalised lambda distribution up to 
4th order. </h2><span id='topic+fun.rawmoments'></span>

<h3>Description</h3>

<p> This function is of theoretical interest only.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fun.rawmoments(L1, L2, L3, L4, param = "fmkl")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fun.rawmoments_+3A_l1">L1</code></td>
<td>
<p> Location parameter of the generalised lambda distribution. </p>
</td></tr>
<tr><td><code id="fun.rawmoments_+3A_l2">L2</code></td>
<td>
<p> Scale parameter of the generalised lambda distribution. </p>
</td></tr>
<tr><td><code id="fun.rawmoments_+3A_l3">L3</code></td>
<td>
<p> First shape parameter of the generalised lambda distribution. </p>
</td></tr>
<tr><td><code id="fun.rawmoments_+3A_l4">L4</code></td>
<td>
<p> Second shape parameter of the generalised lambda distribution. </p>
</td></tr>
<tr><td><code id="fun.rawmoments_+3A_param">param</code></td>
<td>
 <p><code>"rs"</code> or <code>"fmkl"</code> specifying the type of 
the generalised lambda distribution. </p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is the building block for <code><a href="#topic+fun.theo.bi.mv.gld">fun.theo.bi.mv.gld</a></code>.
</p>


<h3>Value</h3>

<p>A vector showing the raw moments of the specified generalised lambda 
distribution up to the fourth order.
</p>


<h3>Author(s)</h3>

<p> Steve Su </p>


<h3>References</h3>

<p>  Freimer, M., Mudholkar, G. S., Kollia, G. &amp; Lin, C. T. (1988), A
study of the generalized tukey lambda family, Communications in
Statistics - Theory and Methods *17*, 3547-3567.
</p>
<p>Karian, Zaven A. and Dudewicz, Edward J. (2000), Fitting
statistical distributions: the Generalized Lambda Distribution and
Generalized Bootstrap methods, Chapman &amp; Hall
</p>
<p>Ramberg, J. S. &amp; Schmeiser, B. W. (1974), An approximate method
for generating asymmetric random variables, Communications of the
ACM *17*, 78-82. </p>


<h3>See Also</h3>

<p> ~~objects to See Also as <code><a href="utils.html#topic+help">help</a></code>, ~~~ </p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Generate some random numbers using FMKL and RS generalised lambda 
## distributions and then compute the empirical and theoretical 
## E(X), E(X^2), E(X^3), E(X^4) 

junk&lt;-rgl(100000,1,2,3,4)
mean(junk)
mean(junk^2)
mean(junk^3)
mean(junk^4)

junk&lt;-rgl(100000,1,2,3,4,"rs")
mean(junk)
mean(junk^2)
mean(junk^3)
mean(junk^4)

fun.rawmoments(1,2,3,4)
fun.rawmoments(1,2,3,4,"rs")
</code></pre>

<hr>
<h2 id='fun.RMFMKL.hs'> Fit FMKL generalised distribution to data using discretised approach 
with weights. </h2><span id='topic+fun.RMFMKL.hs'></span>

<h3>Description</h3>

<p>This function fits FMKL generalised distribution to data using discretised 
approach with weights. It is designed to act as a smoother device rather than 
as a definitive fit. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fun.RMFMKL.hs(data, default = "Y", fmkl.init = c(-0.25, 1.5), no.c.fmkl = 50, 
leap = 3,FUN="runif.sobol",no=10000)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fun.RMFMKL.hs_+3A_data">data</code></td>
<td>
<p> Dataset to be fitted </p>
</td></tr>
<tr><td><code id="fun.RMFMKL.hs_+3A_default">default</code></td>
<td>
<p> If yes, this function uses the default method 
<code><a href="#topic+fun.nclass.e">fun.nclass.e</a></code> to calculate number of classes required. </p>
</td></tr>
<tr><td><code id="fun.RMFMKL.hs_+3A_fmkl.init">fmkl.init</code></td>
<td>
<p> Initial values for FMKL distribution optimization, 
<code>c(-0.25,1.5)</code> tends to work well. </p>
</td></tr>
<tr><td><code id="fun.RMFMKL.hs_+3A_no.c.fmkl">no.c.fmkl</code></td>
<td>
<p> Number of classes or bins of histogram to be optimized over. 
This argument is ineffective if <code>default="Y"</code>. </p>
</td></tr>
<tr><td><code id="fun.RMFMKL.hs_+3A_leap">leap</code></td>
<td>
<p> See scrambling argument in <code><a href="#topic+fun.gen.qrn">fun.gen.qrn</a></code>. </p>
</td></tr>
<tr><td><code id="fun.RMFMKL.hs_+3A_fun">FUN</code></td>
<td>
<p> A character string of either  <code>"runif.sobol"</code> (default), <code>"runif.sobol.owen"</code>, 
<code>"runif.halton"</code> or <code>"QUnif"</code>. </p>
</td></tr>
<tr><td><code id="fun.RMFMKL.hs_+3A_no">no</code></td>
<td>
<p> Number of initial random values to find the best initial values for 
optimisation. </p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function optimises the deviations of frequency of the bins to that of the 
theoretical so it has the effect of &quot;fitting clothes&quot; onto the data set. The 
user can decide the frequency of the bins they want the distribution to smooth 
over. The resulting fit may or may not be an adequate fit from a formal 
statistical point of view such as satisfying the goodness of fit for example, 
but it can be useful to suggest the range of different distributions exhibited 
by the data set. The default number of classes calculates the mean and variance 
after categorising the data into different bins and uses the number of classes 
that best matches the mean and variance of the original, ungrouped data. The 
weighting is designed to accentuate the peak or the dense part of the 
distribution and suppress the tails. 
</p>


<h3>Value</h3>

<p>A vector representing four parametefmkl of the FMKL generalised lambda 
distribution.
</p>


<h3>Note</h3>

<p> In some cases, the resulting fit may not converge, there are currently no 
checking mechanism in place to ensure global convergence.
</p>


<h3>Author(s)</h3>

<p> Steve Su </p>


<h3>References</h3>

<p> Su, S. (2005). A Discretized Approach to Flexibly Fit Generalized 
Lambda Distributions to Data. Journal of Modern Applied Statistical Methods 
(November): 408-424. 
</p>
<p>Su (2007). Fitting Single and Mixture of Generalized Lambda Distributions to 
Data via Discretized and Maximum Likelihood Methods: GLDEX in R. 
Journal of Statistical Software: *21* 9.
</p>


<h3>See Also</h3>

 <p><code><a href="#topic+fun.RMFMKL.hs.nw">fun.RMFMKL.hs.nw</a></code>, <code><a href="#topic+fun.RPRS.hs.nw">fun.RPRS.hs.nw</a></code>, 
<code><a href="#topic+fun.RPRS.hs">fun.RPRS.hs</a></code>, <code><a href="#topic+fun.data.fit.hs">fun.data.fit.hs</a></code>, 
<code><a href="#topic+fun.data.fit.hs.nw">fun.data.fit.hs.nw</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Using the default number of classes
 fun.RMFMKL.hs(data=rnorm(1000,3,2),default="Y",fmkl.init=c(-0.25,1.5),leap=3)
# Using 20 classes
 fun.RMFMKL.hs(data=rnorm(1000,3,2),default="N",fmkl.init=c(-0.25,1.5),
 no.c.fmkl=20,leap=3)
</code></pre>

<hr>
<h2 id='fun.RMFMKL.hs.nw'> Fit FMKL generalised distribution to data using discretised approach 
without weights. </h2><span id='topic+fun.RMFMKL.hs.nw'></span>

<h3>Description</h3>

<p>This function fits FMKL generalised distribution to data using discretised 
approach without weights. It is designed to act as a smoother device rather 
than as a definitive fit.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fun.RMFMKL.hs.nw(data, default = "Y", fmkl.init = c(-0.25, 1.5), 
no.c.fmkl = 50, leap = 3,FUN="runif.sobol",no=10000)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fun.RMFMKL.hs.nw_+3A_data">data</code></td>
<td>
<p> Dataset to be fitted  </p>
</td></tr>
<tr><td><code id="fun.RMFMKL.hs.nw_+3A_default">default</code></td>
<td>
<p> If yes, this function uses the default method 
<code><a href="#topic+fun.nclass.e">fun.nclass.e</a></code> to calculate number of classes required. </p>
</td></tr>
<tr><td><code id="fun.RMFMKL.hs.nw_+3A_fmkl.init">fmkl.init</code></td>
<td>
<p> Initial values for FMKL distribution optimization, 
<code>c(-0.25,1.5)</code> tends to work well. </p>
</td></tr>
<tr><td><code id="fun.RMFMKL.hs.nw_+3A_no.c.fmkl">no.c.fmkl</code></td>
<td>
<p> Number of classes or bins of histogram to be optimized over. 
This argument is ineffective if <code>default="Y"</code>. </p>
</td></tr>
<tr><td><code id="fun.RMFMKL.hs.nw_+3A_leap">leap</code></td>
<td>
<p> See scrambling argument in <code><a href="#topic+fun.gen.qrn">fun.gen.qrn</a></code>. </p>
</td></tr>
<tr><td><code id="fun.RMFMKL.hs.nw_+3A_fun">FUN</code></td>
<td>
<p> A character string of either  <code>"runif.sobol"</code> (default), <code>"runif.sobol.owen"</code>, 
<code>"runif.halton"</code> or <code>"QUnif"</code>. </p>
</td></tr>
<tr><td><code id="fun.RMFMKL.hs.nw_+3A_no">no</code></td>
<td>
<p> Number of initial random values to find the best initial values for 
optimisation. </p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function optimises the deviations of frequency of the bins to that of the 
theoretical so it has the effect of &quot;fitting clothes&quot; onto the data set. The 
user can decide the frequency of the bins they want the distribution to smooth 
over. The resulting fit may or may not be an adequate fit from a formal 
statistical point of view such as satisfying the goodness of fit for example, 
but it can be useful to suggest the range of different distributions exhibited 
by the data set. The default number of classes calculates the mean and 
variance after categorising the data into different bins and uses the number 
of classes that best matches the mean and variance of the original, ungrouped 
data. 
</p>


<h3>Value</h3>

<p>A vector representing four parameters of the FMKL generalised lambda 
distribution.
</p>


<h3>Note</h3>

<p> In some cases, the resulting fit may not converge, there are currently no 
checking mechanism in place to ensure global convergence. 
</p>


<h3>Author(s)</h3>

<p> Steve Su </p>


<h3>References</h3>

<p> Su, S. (2005). A Discretized Approach to Flexibly Fit Generalized 
Lambda Distributions to Data. Journal of Modern Applied Statistical Methods 
(November): 408-424. 
</p>
<p>Su (2007). Fitting Single and Mixture of Generalized Lambda Distributions to 
Data via Discretized and Maximum Likelihood Methods: GLDEX in R. 
Journal of Statistical Software: *21* 9.
</p>


<h3>See Also</h3>

 <p><code><a href="#topic+fun.RPRS.hs.nw">fun.RPRS.hs.nw</a></code>, <code><a href="#topic+fun.RMFMKL.hs">fun.RMFMKL.hs</a></code>, 
<code><a href="#topic+fun.RPRS.hs">fun.RPRS.hs</a></code>, <code><a href="#topic+fun.data.fit.hs">fun.data.fit.hs</a></code>, 
<code><a href="#topic+fun.data.fit.hs.nw">fun.data.fit.hs.nw</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Using the default number of classes
 fun.RMFMKL.hs.nw(data=rnorm(1000,3,2),default="Y",
 fmkl.init=c(-0.25,1.5),leap=3)
# Using 20 classes
 fun.RMFMKL.hs.nw(data=rnorm(1000,6,5),default="N",fmkl.init=c(-0.25,1.5),
 no.c.fmkl=20,leap=3)

</code></pre>

<hr>
<h2 id='fun.RMFMKL.lm'> Fit FMKL generalised lambda distribution to data set using L moment 
matching </h2><span id='topic+fun.RMFMKL.lm'></span>

<h3>Description</h3>

<p>This function fits FMKL generalised lambda distribution to data set 
using L moment matching
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fun.RMFMKL.lm(data, fmkl.init = c(-0.25, 1.5), leap = 3, FUN = "runif.sobol", 
no = 10000)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fun.RMFMKL.lm_+3A_data">data</code></td>
<td>
<p> Dataset to be fitted </p>
</td></tr>
<tr><td><code id="fun.RMFMKL.lm_+3A_fmkl.init">fmkl.init</code></td>
<td>
<p> Initial values for FMKL distribution optimization, 
<code>c(-0.25,1.5)</code> tends to work well. </p>
</td></tr>
<tr><td><code id="fun.RMFMKL.lm_+3A_leap">leap</code></td>
<td>
<p> See scrambling argument in <code><a href="#topic+fun.gen.qrn">fun.gen.qrn</a></code>. </p>
</td></tr>
<tr><td><code id="fun.RMFMKL.lm_+3A_fun">FUN</code></td>
<td>
<p> A character string of either  <code>"runif.sobol"</code> (default), <code>"runif.sobol.owen"</code>, 
<code>"runif.halton"</code> or <code>"QUnif"</code>. </p>
</td></tr>
<tr><td><code id="fun.RMFMKL.lm_+3A_no">no</code></td>
<td>
<p> Number of initial random values to find the best initial values for 
optimisation. </p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function provides method of L moment fitting scheme for FMKL GLD. Note this 
function can fail if there are no defined percentiles from the data set or if 
the initial values do not lead to a valid FMKL generalised lambda distribution.
</p>
<p>This function is based on scheme detailed in the literature below but it has
been modified by the author (Steve Su).
</p>


<h3>Value</h3>

<p>A vector representing four parametefmkl of the FMKL generalised lambda 
distribution.
</p>


<h3>Author(s)</h3>

<p> Steve Su </p>


<h3>References</h3>

<p>Asquith, W. (2007). 
&quot;L-moments and TL-moments of the generalized lambda distribution.&quot; 
Computational Statistics and Data Analysis 51(9): 4484-4496.
</p>
<p>Karvanen, J. and A. Nuutinen (2008). 
&quot;Characterizing the generalized lambda distribution by L-moments.&quot; 
Computational Statistics and Data Analysis 52(4): 1971-1983. </p>


<h3>See Also</h3>

 <p><code><a href="#topic+fun.RMFMKL.ml">fun.RMFMKL.ml</a></code>, <code><a href="#topic+fun.RMFMKL.mm">fun.RMFMKL.mm</a></code>, 
<code><a href="#topic+fun.RMFMKL.qs">fun.RMFMKL.qs</a></code>, <code><a href="#topic+fun.data.fit.ml">fun.data.fit.ml</a></code> 
<code><a href="#topic+fun.data.fit.lm">fun.data.fit.lm</a></code>, <code><a href="#topic+fun.data.fit.qs">fun.data.fit.qs</a></code>,  
<code><a href="#topic+fun.data.fit.mm">fun.data.fit.mm</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Fitting the normal distribution
 fun.RMFMKL.lm(data=rnorm(1000,2,3),fmkl.init=c(-0.25,1.5),leap=3)
</code></pre>

<hr>
<h2 id='fun.RMFMKL.ml'> Fit FMKL generalised lambda distribution to data set using maximum 
likelihood estimation </h2><span id='topic+fun.RMFMKL.ml'></span>

<h3>Description</h3>

<p>This function fits FMKL generalised lambda distribution to data set using 
maximum likelihood estimation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fun.RMFMKL.ml(data, fmkl.init = c(-0.25, 1.5), leap = 3,FUN="runif.sobol",
no=10000)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fun.RMFMKL.ml_+3A_data">data</code></td>
<td>
<p> Dataset to be fitted </p>
</td></tr>
<tr><td><code id="fun.RMFMKL.ml_+3A_fmkl.init">fmkl.init</code></td>
<td>
<p> Initial values for FMKL distribution optimization, 
<code>c(-0.25,1.5)</code> tends to work well. </p>
</td></tr>
<tr><td><code id="fun.RMFMKL.ml_+3A_leap">leap</code></td>
<td>
<p> See scrambling argument in <code><a href="#topic+fun.gen.qrn">fun.gen.qrn</a></code>. </p>
</td></tr>
<tr><td><code id="fun.RMFMKL.ml_+3A_fun">FUN</code></td>
<td>
<p> A character string of either  <code>"runif.sobol"</code> (default), <code>"runif.sobol.owen"</code>, 
<code>"runif.halton"</code> or <code>"QUnif"</code>. </p>
</td></tr>
<tr><td><code id="fun.RMFMKL.ml_+3A_no">no</code></td>
<td>
<p> Number of initial random values to find the best initial values for 
optimisation. </p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function provides one of the definitive fit to data set using generalised 
lambda distributions.
</p>


<h3>Value</h3>

<p>A vector representing four parameters of the FMKL generalised lambda 
distribution.
</p>


<h3>Author(s)</h3>

<p> Steve Su </p>


<h3>References</h3>

<p> Su, S. (2007). Numerical Maximum Log Likelihood Estimation for 
Generalized Lambda Distributions. Journal of Computational statistics and 
data analysis 51(8) 3983-3998. 
</p>
<p>Su (2007). Fitting Single and Mixture of Generalized Lambda Distributions to 
Data via Discretized and Maximum Likelihood Methods: GLDEX in R. 
Journal of Statistical Software: *21* 9.
</p>


<h3>See Also</h3>

 <p><code><a href="#topic+fun.RPRS.ml">fun.RPRS.ml</a></code>, <code><a href="#topic+fun.data.fit.ml">fun.data.fit.ml</a></code>,
<code><a href="#topic+fun.data.fit.qs">fun.data.fit.qs</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Fitting the normal distribution
 fun.RMFMKL.ml(data=rnorm(1000,2,3),fmkl.init=c(-0.25,1.5),leap=3)
</code></pre>

<hr>
<h2 id='fun.RMFMKL.ml.m'>
Fit RS generalised lambda distribution to data set using maximum 
likelihood estimation
</h2><span id='topic+fun.RMFMKL.ml.m'></span>

<h3>Description</h3>

<p>This function fits FMKL generalised lambda distribution to data set using 
maximum likelihood estimation using faster implementation through C programming
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fun.RMFMKL.ml.m(data, fmkl.init = c(-0.25, 1.5), leap = 3, FUN = "runif.sobol", 
no = 10000)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fun.RMFMKL.ml.m_+3A_data">data</code></td>
<td>
<p> Dataset to be fitted </p>
</td></tr>
<tr><td><code id="fun.RMFMKL.ml.m_+3A_fmkl.init">fmkl.init</code></td>
<td>
<p> Initial values for FMKL distribution optimization, 
<code>c(-0.25,1.5)</code> tends to work well. </p>
</td></tr>
<tr><td><code id="fun.RMFMKL.ml.m_+3A_leap">leap</code></td>
<td>
<p> See scrambling argument in <code><a href="#topic+fun.gen.qrn">fun.gen.qrn</a></code>. </p>
</td></tr>
<tr><td><code id="fun.RMFMKL.ml.m_+3A_fun">FUN</code></td>
<td>
<p> A character string of either  <code>"runif.sobol"</code> (default), <code>"runif.sobol.owen"</code>, 
<code>"runif.halton"</code> or <code>"QUnif"</code>. </p>
</td></tr>
<tr><td><code id="fun.RMFMKL.ml.m_+3A_no">no</code></td>
<td>
<p> Number of initial random values to find the best initial values for 
optimisation. </p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function provides one of the definitive fit to data set using generalised 
lambda distributions.
</p>


<h3>Value</h3>

<p>A vector representing four parameters of the FMKL generalised lambda 
distribution.
</p>


<h3>Author(s)</h3>

<p> Steve Su </p>


<h3>References</h3>

<p> Su, S. (2007). Numerical Maximum Log Likelihood Estimation for 
Generalized Lambda Distributions. Journal of Computational statistics and 
data analysis 51(8) 3983-3998. 
</p>
<p>Su (2007). Fitting Single and Mixture of Generalized Lambda Distributions to 
Data via Discretized and Maximum Likelihood Methods: GLDEX in R. 
Journal of Statistical Software: *21* 9.
</p>


<h3>See Also</h3>

 <p><code><a href="#topic+fun.RMFMKL.ml">fun.RMFMKL.ml</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Fitting the normal distribution
 fun.RMFMKL.ml.m(data=rnorm(1000,2,3),fmkl.init=c(-0.25,1.5),leap=3)
</code></pre>

<hr>
<h2 id='fun.RMFMKL.mm'> Fit FMKL generalised lambda distribution to data set using moment 
matching </h2><span id='topic+fun.RMFMKL.mm'></span>

<h3>Description</h3>

<p>This function fits FMKL generalised lambda distribution to data set 
using moment matching
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fun.RMFMKL.mm(data, fmkl.init = c(-0.25, 1.5), leap = 3, FUN = "runif.sobol", 
no = 10000)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fun.RMFMKL.mm_+3A_data">data</code></td>
<td>
<p> Dataset to be fitted </p>
</td></tr>
<tr><td><code id="fun.RMFMKL.mm_+3A_fmkl.init">fmkl.init</code></td>
<td>
<p> Initial values for FMKL distribution optimization, 
<code>c(-0.25,1.5)</code> tends to work well. </p>
</td></tr>
<tr><td><code id="fun.RMFMKL.mm_+3A_leap">leap</code></td>
<td>
<p> See scrambling argument in <code><a href="#topic+fun.gen.qrn">fun.gen.qrn</a></code>. </p>
</td></tr>
<tr><td><code id="fun.RMFMKL.mm_+3A_fun">FUN</code></td>
<td>
<p> A character string of either  <code>"runif.sobol"</code> (default), <code>"runif.sobol.owen"</code>, 
<code>"runif.halton"</code> or <code>"QUnif"</code>. </p>
</td></tr>
<tr><td><code id="fun.RMFMKL.mm_+3A_no">no</code></td>
<td>
<p> Number of initial random values to find the best initial values for 
optimisation. </p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function provides method of moment fitting scheme for FMKL GLD. Note this 
function can fail if there are no defined percentiles from the data set or if 
the initial values do not lead to a valid FMKL generalised lambda distribution.
</p>
<p>This function is based on scheme detailed in the literature below but it has
been modified by the author (Steve Su).
</p>


<h3>Value</h3>

<p>A vector representing four parametefmkl of the FMKL generalised lambda 
distribution.
</p>


<h3>Author(s)</h3>

<p> Steve Su </p>


<h3>References</h3>

<p> Karian, Z. and E. Dudewicz (2000). Fitting Statistical 
Distributions: The Generalized Lambda Distribution and Generalised Bootstrap 
Methods. New York, Chapman and Hall. </p>


<h3>See Also</h3>

 <p><code><a href="#topic+fun.RMFMKL.ml">fun.RMFMKL.ml</a></code>, <code><a href="#topic+fun.RMFMKL.lm">fun.RMFMKL.lm</a></code>, 
<code><a href="#topic+fun.RMFMKL.qs">fun.RMFMKL.qs</a></code>, <code><a href="#topic+fun.data.fit.ml">fun.data.fit.ml</a></code> 
<code><a href="#topic+fun.data.fit.lm">fun.data.fit.lm</a></code>, <code><a href="#topic+fun.data.fit.qs">fun.data.fit.qs</a></code>,  
<code><a href="#topic+fun.data.fit.mm">fun.data.fit.mm</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Fitting the normal distribution
 fun.RMFMKL.mm(data=rnorm(1000,2,3),fmkl.init=c(-0.25,1.5),leap=3)
</code></pre>

<hr>
<h2 id='fun.RMFMKL.qs'> Fit FMKL generalised lambda distribution to data set using quantile 
matching </h2><span id='topic+fun.RMFMKL.qs'></span>

<h3>Description</h3>

<p>This function fits FMKL generalised lambda distribution to data set 
using quantile matching
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fun.RMFMKL.qs(data, fmkl.init = c(-0.25, 1.5), leap = 3, FUN = "runif.sobol", 
trial.n = 100, len = 1000, type = 7, no = 10000)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fun.RMFMKL.qs_+3A_data">data</code></td>
<td>
<p> Dataset to be fitted </p>
</td></tr>
<tr><td><code id="fun.RMFMKL.qs_+3A_fmkl.init">fmkl.init</code></td>
<td>
<p> Initial values for FMKL distribution optimization, 
<code>c(-0.25,1.5)</code> tends to work well. </p>
</td></tr>
<tr><td><code id="fun.RMFMKL.qs_+3A_leap">leap</code></td>
<td>
<p> See scrambling argument in <code><a href="#topic+fun.gen.qrn">fun.gen.qrn</a></code>. </p>
</td></tr>
<tr><td><code id="fun.RMFMKL.qs_+3A_fun">FUN</code></td>
<td>
<p> A character string of either  <code>"runif.sobol"</code> (default), <code>"runif.sobol.owen"</code>, 
<code>"runif.halton"</code> or <code>"QUnif"</code>. </p>
</td></tr>
<tr><td><code id="fun.RMFMKL.qs_+3A_trial.n">trial.n</code></td>
<td>
<p> Number of evenly spaced quantile ranging from 0 to 1 to be
used in the checking phase, to find the best set of initial values for 
optimisation, this is intended to be lower than <code>len</code> to speed up the 
fitting algorithm. Default is 100. </p>
</td></tr>
<tr><td><code id="fun.RMFMKL.qs_+3A_len">len</code></td>
<td>
<p> Number of evenly spaced quantile ranging from 0 to 1 to be used,
default is 1000 </p>
</td></tr>
<tr><td><code id="fun.RMFMKL.qs_+3A_type">type</code></td>
<td>
<p> Type of quantile to be used, default is 7, see <code>quantile</code> </p>
</td></tr>
<tr><td><code id="fun.RMFMKL.qs_+3A_no">no</code></td>
<td>
<p> Number of initial random values to find the best initial values for 
optimisation. </p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function provides quantile matching fitting scheme for FMKL GLD. Note this 
function can fail if there are no defined percentiles from the data set or if 
the initial values do not lead to a valid FMKL generalised lambda distribution.
</p>


<h3>Value</h3>

<p>A vector representing four parametefmkl of the FMKL generalised lambda 
distribution.
</p>


<h3>Author(s)</h3>

<p> Steve Su </p>


<h3>References</h3>

 
<p>Su (2008). Fitting GLD to data via quantile matching method. (Book chapter to
appear) </p>


<h3>See Also</h3>

 <p><code><a href="#topic+fun.RMFMKL.ml">fun.RMFMKL.ml</a></code>, <code><a href="#topic+fun.RMFMKL.lm">fun.RMFMKL.lm</a></code>, 
<code><a href="#topic+fun.RMFMKL.mm">fun.RMFMKL.mm</a></code>, <code><a href="#topic+fun.data.fit.ml">fun.data.fit.ml</a></code> 
<code><a href="#topic+fun.data.fit.lm">fun.data.fit.lm</a></code>, <code><a href="#topic+fun.data.fit.qs">fun.data.fit.qs</a></code>,  
<code><a href="#topic+fun.data.fit.mm">fun.data.fit.mm</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Fitting the normal distribution
 fun.RMFMKL.qs(data=rnorm(1000,2,3),fmkl.init=c(-0.25,1.5),leap=3)
</code></pre>

<hr>
<h2 id='fun.RPRS.hs'> Fit RS generalised distribution to data using discretised approach with 
weights. </h2><span id='topic+fun.RPRS.hs'></span>

<h3>Description</h3>

<p>This function fits RS generalised distribution to data using discretised 
approach with weights. It is designed to act as a smoother device rather than 
as a definitive fit. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fun.RPRS.hs(data, default = "Y", rs.init = c(-1.5, 1.5), no.c.rs = 50, 
leap = 3,FUN="runif.sobol",no=10000)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fun.RPRS.hs_+3A_data">data</code></td>
<td>
<p> Dataset to be fitted </p>
</td></tr>
<tr><td><code id="fun.RPRS.hs_+3A_default">default</code></td>
<td>
<p> If yes, this function uses the default method 
<code><a href="#topic+fun.nclass.e">fun.nclass.e</a></code> to calculate number of classes required. </p>
</td></tr>
<tr><td><code id="fun.RPRS.hs_+3A_rs.init">rs.init</code></td>
<td>
<p> Initial values for RS distribution optimization, 
<code>c(-1.5,1.5)</code> tends to work well. </p>
</td></tr>
<tr><td><code id="fun.RPRS.hs_+3A_no.c.rs">no.c.rs</code></td>
<td>
<p> Number of classes or bins of histogram to be optimized over. 
This argument is ineffective if <code>default="Y"</code>. </p>
</td></tr>
<tr><td><code id="fun.RPRS.hs_+3A_leap">leap</code></td>
<td>
<p> See scrambling argument in <code><a href="#topic+fun.gen.qrn">fun.gen.qrn</a></code>. </p>
</td></tr>
<tr><td><code id="fun.RPRS.hs_+3A_fun">FUN</code></td>
<td>
<p> A character string of either  <code>"runif.sobol"</code> (default), <code>"runif.sobol.owen"</code>, 
<code>"runif.halton"</code> or <code>"QUnif"</code>. </p>
</td></tr>
<tr><td><code id="fun.RPRS.hs_+3A_no">no</code></td>
<td>
<p> Number of initial random values to find the best initial values for 
optimisation. </p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function optimises the deviations of frequency of the bins to that of the 
theoretical so it has the effect of &quot;fitting clothes&quot; onto the data set. The 
user can decide the frequency of the bins they want the distribution to smooth 
over. The resulting fit may or may not be an adequate fit from a formal 
statistical point of view such as satisfying the goodness of fit for example, 
but it can be useful to suggest the range of different distributions exhibited 
by the data set. The default number of classes calculates the mean and variance 
after categorising the data into different bins and uses the number of classes 
that best matches the mean and variance of the original, ungrouped data. The 
weighting is designed to accentuate the peak or the dense part of the 
distribution and suppress the tails. 
</p>


<h3>Value</h3>

<p>A vector representing four parameters of the RS generalised lambda distribution.
</p>


<h3>Note</h3>

<p> In some cases, the resulting fit may not converge, there are currently no 
checking mechanism in place to ensure global convergence.
The RPRS method can sometimes fail if there are no valid percentiles in the data 
set or if initial values do not give a valid distribution. </p>


<h3>Author(s)</h3>

<p> Steve Su </p>


<h3>References</h3>

<p> Su, S. (2005). A Discretized Approach to Flexibly Fit Generalized 
Lambda Distributions to Data. Journal of Modern Applied Statistical Methods 
(November): 408-424. 
</p>
<p>Su (2007). Fitting Single and Mixture of Generalized Lambda Distributions to 
Data via Discretized and Maximum Likelihood Methods: GLDEX in R. 
Journal of Statistical Software: *21* 9.
</p>


<h3>See Also</h3>

 <p><code><a href="#topic+fun.RPRS.hs.nw">fun.RPRS.hs.nw</a></code>, <code><a href="#topic+fun.RMFMKL.hs.nw">fun.RMFMKL.hs.nw</a></code>, 
<code><a href="#topic+fun.RMFMKL.hs">fun.RMFMKL.hs</a></code>, <code><a href="#topic+fun.data.fit.hs">fun.data.fit.hs</a></code>, 
<code><a href="#topic+fun.data.fit.hs.nw">fun.data.fit.hs.nw</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Using the default number of classes
 fun.RPRS.hs(data=rnorm(1000,2,3),default="Y",rs.init=c(-1.5,1.5),leap=3)
# Using 20 classes
 fun.RPRS.hs(data=rnorm(1000,2,3),default="N",rs.init=c(-1.5,1.5),
 no.c.rs=20,leap=3)
</code></pre>

<hr>
<h2 id='fun.RPRS.hs.nw'> Fit RS generalised distribution to data using discretised approach 
without weights. </h2><span id='topic+fun.RPRS.hs.nw'></span>

<h3>Description</h3>

<p>This function fits RS generalised distribution to data using discretised 
approach without weights. It is designed to act as a smoother device rather 
than as a definitive fit.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fun.RPRS.hs.nw(data, default = "Y", rs.init = c(-1.5, 1.5), no.c.rs = 50, 
leap = 3,FUN="runif.sobol",no=10000)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fun.RPRS.hs.nw_+3A_data">data</code></td>
<td>
<p> Dataset to be fitted  </p>
</td></tr>
<tr><td><code id="fun.RPRS.hs.nw_+3A_default">default</code></td>
<td>
<p> If yes, this function uses the default method 
<code><a href="#topic+fun.nclass.e">fun.nclass.e</a></code> to calculate number of classes required. </p>
</td></tr>
<tr><td><code id="fun.RPRS.hs.nw_+3A_rs.init">rs.init</code></td>
<td>
<p> Initial values for RS distribution optimization, 
<code>c(-1.5,1.5)</code> tends to work well. </p>
</td></tr>
<tr><td><code id="fun.RPRS.hs.nw_+3A_no.c.rs">no.c.rs</code></td>
<td>
<p> Number of classes or bins of histogram to be optimized over. 
This argument is ineffective if <code>default="Y"</code>. </p>
</td></tr>
<tr><td><code id="fun.RPRS.hs.nw_+3A_leap">leap</code></td>
<td>
<p> See scrambling argument in <code><a href="#topic+fun.gen.qrn">fun.gen.qrn</a></code>. </p>
</td></tr>
<tr><td><code id="fun.RPRS.hs.nw_+3A_fun">FUN</code></td>
<td>
<p> A character string of either  <code>"runif.sobol"</code> (default), <code>"runif.sobol.owen"</code>, 
<code>"runif.halton"</code> or <code>"QUnif"</code>. </p>
</td></tr>
<tr><td><code id="fun.RPRS.hs.nw_+3A_no">no</code></td>
<td>
<p> Number of initial random values to find the best initial values for 
optimisation. </p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function optimises the deviations of frequency of the bins to that of the 
theoretical so it has the effect of &quot;fitting clothes&quot; onto the data set. The 
user can decide the frequency of the bins they want the distribution to smooth 
over. The resulting fit may or may not be an adequate fit from a formal 
statistical point of view such as satisfying the goodness of fit for example, 
but it can be useful to suggest the range of different distributions exhibited 
by the data set. The default number of classes calculates the mean and 
variance after categorising the data into different bins and uses the number 
of classes that best matches the mean and variance of the original, ungrouped 
data. 
</p>


<h3>Value</h3>

<p>A vector representing four parameters of the RS generalised lambda 
distribution.
</p>


<h3>Note</h3>

<p> In some cases, the resulting fit may not converge, there are currently no 
checking mechanism in place to ensure global convergence. The RPRS method can 
sometimes fail if there are no valid percentiles in the data 
set or if initial values do not give a valid distribution. </p>


<h3>Author(s)</h3>

<p> Steve Su </p>


<h3>References</h3>

<p> Su, S. (2005). A Discretized Approach to Flexibly Fit Generalized 
Lambda Distributions to Data. Journal of Modern Applied Statistical Methods 
(November): 408-424.
</p>
<p>Su (2007). Fitting Single and Mixture of Generalized Lambda Distributions to 
Data via Discretized and Maximum Likelihood Methods: GLDEX in R. 
Journal of Statistical Software: *21* 9.
</p>


<h3>See Also</h3>

 <p><code><a href="#topic+fun.RPRS.hs.nw">fun.RPRS.hs.nw</a></code>, <code><a href="#topic+fun.RPRS.hs">fun.RPRS.hs</a></code>, 
<code><a href="#topic+fun.RMFMKL.hs">fun.RMFMKL.hs</a></code>, <code><a href="#topic+fun.data.fit.hs">fun.data.fit.hs</a></code>, 
<code><a href="#topic+fun.data.fit.hs.nw">fun.data.fit.hs.nw</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Using the default number of classes
 fun.RPRS.hs.nw(data=rnorm(1000,3,2),default="Y",rs.init=c(-1.5,1.5),leap=3)
# Using 20 classes
 fun.RPRS.hs.nw(data=rnorm(1000,3,2),default="N",rs.init=c(-1.5,1.5),
 no.c.rs=20,leap=3)
</code></pre>

<hr>
<h2 id='fun.RPRS.lm'> Fit RS generalised lambda distribution to data set using L moment 
matching </h2><span id='topic+fun.RPRS.lm'></span>

<h3>Description</h3>

<p>This function fits RS generalised lambda distribution to data set 
using L moment matching
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fun.RPRS.lm(data, rs.init = c(-1.5, 1.5), leap = 3, FUN = "runif.sobol", 
no = 10000)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fun.RPRS.lm_+3A_data">data</code></td>
<td>
<p> Dataset to be fitted </p>
</td></tr>
<tr><td><code id="fun.RPRS.lm_+3A_rs.init">rs.init</code></td>
<td>
<p> Initial values for RS distribution optimization, 
<code>c(-1.5,1.5)</code> tends to work well. </p>
</td></tr>
<tr><td><code id="fun.RPRS.lm_+3A_leap">leap</code></td>
<td>
<p> See scrambling argument in <code><a href="#topic+fun.gen.qrn">fun.gen.qrn</a></code>. </p>
</td></tr>
<tr><td><code id="fun.RPRS.lm_+3A_fun">FUN</code></td>
<td>
<p> A character string of either  <code>"runif.sobol"</code> (default), <code>"runif.sobol.owen"</code>, 
<code>"runif.halton"</code> or <code>"QUnif"</code>. </p>
</td></tr>
<tr><td><code id="fun.RPRS.lm_+3A_no">no</code></td>
<td>
<p> Number of initial random values to find the best initial values for 
optimisation. </p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function provides method of L moment fitting scheme for RS GLD. Note this 
function can fail if there are no defined percentiles from the data set or if 
the initial values do not lead to a valid RS generalised lambda distribution.
</p>
<p>This function is based on scheme detailed in the literature below but it has
been modified by the author (Steve Su).
</p>


<h3>Value</h3>

<p>A vector representing four parameters of the RS generalised lambda distribution.
</p>


<h3>Author(s)</h3>

<p> Steve Su </p>


<h3>References</h3>

<p>Asquith, W. (2007). 
&quot;L-moments and TL-moments of the generalized lambda distribution.&quot; 
Computational Statistics and Data Analysis 51(9): 4484-4496.
</p>
<p>Karvanen, J. and A. Nuutinen (2008). 
&quot;Characterizing the generalized lambda distribution by L-moments.&quot; 
Computational Statistics and Data Analysis 52(4): 1971-1983. </p>


<h3>See Also</h3>

 <p><code><a href="#topic+fun.RPRS.ml">fun.RPRS.ml</a></code>, <code><a href="#topic+fun.RPRS.mm">fun.RPRS.mm</a></code>, 
<code><a href="#topic+fun.RPRS.qs">fun.RPRS.qs</a></code>, <code><a href="#topic+fun.data.fit.ml">fun.data.fit.ml</a></code> 
<code><a href="#topic+fun.data.fit.lm">fun.data.fit.lm</a></code>, <code><a href="#topic+fun.data.fit.qs">fun.data.fit.qs</a></code>,  
<code><a href="#topic+fun.data.fit.mm">fun.data.fit.mm</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Fitting the normal distribution
 fun.RPRS.lm(data=rnorm(1000,2,3),rs.init=c(-1.5,1.5),leap=3)
</code></pre>

<hr>
<h2 id='fun.RPRS.ml'> Fit RS generalised lambda distribution to data set using maximum 
likelihood estimation </h2><span id='topic+fun.RPRS.ml'></span>

<h3>Description</h3>

<p>This function fits RS generalised lambda distribution to data set using 
maximum likelihood estimation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fun.RPRS.ml(data, rs.init = c(-1.5, 1.5), leap = 3,FUN="runif.sobol",no=10000)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fun.RPRS.ml_+3A_data">data</code></td>
<td>
<p> Dataset to be fitted </p>
</td></tr>
<tr><td><code id="fun.RPRS.ml_+3A_rs.init">rs.init</code></td>
<td>
<p> Initial values for RS distribution optimization, 
<code>c(-1.5,1.5)</code> tends to work well. </p>
</td></tr>
<tr><td><code id="fun.RPRS.ml_+3A_leap">leap</code></td>
<td>
<p> See scrambling argument in <code><a href="#topic+fun.gen.qrn">fun.gen.qrn</a></code>. </p>
</td></tr>
<tr><td><code id="fun.RPRS.ml_+3A_fun">FUN</code></td>
<td>
<p> A character string of either  <code>"runif.sobol"</code> (default), <code>"runif.sobol.owen"</code>, 
<code>"runif.halton"</code> or <code>"QUnif"</code>. </p>
</td></tr>
<tr><td><code id="fun.RPRS.ml_+3A_no">no</code></td>
<td>
<p> Number of initial random values to find the best initial values for 
optimisation. </p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function provides one of the definitive fit to data set using generalised 
lambda distributions. Note this function can fail if there are no defined 
percentiles from the data set or if the initial values do not lead to a valid RS 
generalised lambda distribution.
</p>


<h3>Value</h3>

<p>A vector representing four parameters of the RS generalised lambda distribution.
</p>


<h3>Author(s)</h3>

<p> Steve Su </p>


<h3>References</h3>

<p> Su, S. (2007). Numerical Maximum Log Likelihood Estimation for 
Generalized Lambda Distributions. Computational statistics and data analysis 
51(8) 3983-3998. 
</p>
<p>Su (2007). Fitting Single and Mixture of Generalized Lambda Distributions to 
Data via Discretized and Maximum Likelihood Methods: GLDEX in R. 
Journal of Statistical Software: *21* 9.
</p>


<h3>See Also</h3>

 <p><code><a href="#topic+fun.RMFMKL.ml">fun.RMFMKL.ml</a></code>, <code><a href="#topic+fun.data.fit.ml">fun.data.fit.ml</a></code>,
<code><a href="#topic+fun.data.fit.qs">fun.data.fit.qs</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Fitting the normal distribution
 fun.RPRS.ml(data=rnorm(1000,2,3),rs.init=c(-1.5,1.5),leap=3)
</code></pre>

<hr>
<h2 id='fun.RPRS.ml.m'>
Fit RS generalised lambda distribution to data set using maximum 
likelihood estimation 
</h2><span id='topic+fun.RPRS.ml.m'></span>

<h3>Description</h3>

<p>This function fits RS generalised lambda distribution to data set using 
maximum likelihood estimation using faster implementation through C programming
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fun.RPRS.ml.m(data, rs.init = c(-1.5, 1.5), leap = 3, FUN = "runif.sobol", 
no = 10000)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fun.RPRS.ml.m_+3A_data">data</code></td>
<td>
<p> Dataset to be fitted </p>
</td></tr>
<tr><td><code id="fun.RPRS.ml.m_+3A_rs.init">rs.init</code></td>
<td>
<p> Initial values for RS distribution optimization, 
<code>c(-1.5,1.5)</code> tends to work well. </p>
</td></tr>
<tr><td><code id="fun.RPRS.ml.m_+3A_leap">leap</code></td>
<td>
<p> See scrambling argument in <code><a href="#topic+fun.gen.qrn">fun.gen.qrn</a></code>. </p>
</td></tr>
<tr><td><code id="fun.RPRS.ml.m_+3A_fun">FUN</code></td>
<td>
<p> A character string of either  <code>"runif.sobol"</code> (default), <code>"runif.sobol.owen"</code>, 
<code>"runif.halton"</code> or <code>"QUnif"</code>. </p>
</td></tr>
<tr><td><code id="fun.RPRS.ml.m_+3A_no">no</code></td>
<td>
<p> Number of initial random values to find the best initial values for 
optimisation. </p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function provides one of the definitive fit to data set using generalised 
lambda distributions. Note this function can fail if there are no defined 
percentiles from the data set or if the initial values do not lead to a valid RS 
generalised lambda distribution.
</p>


<h3>Value</h3>

<p>A vector representing four parameters of the RS generalised lambda distribution.
</p>


<h3>Author(s)</h3>

<p> Steve Su </p>


<h3>References</h3>

<p> Su, S. (2007). Numerical Maximum Log Likelihood Estimation for 
Generalized Lambda Distributions. Computational statistics and data analysis 
51(8) 3983-3998. 
</p>
<p>Su (2007). Fitting Single and Mixture of Generalized Lambda Distributions to 
Data via Discretized and Maximum Likelihood Methods: GLDEX in R. 
Journal of Statistical Software: *21* 9.
</p>


<h3>See Also</h3>

 <p><code><a href="#topic+fun.RPRS.ml">fun.RPRS.ml</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Fitting the normal distribution
 fun.RPRS.ml.m(data=rnorm(1000,2,3),rs.init=c(-1.5,1.5),leap=3)
</code></pre>

<hr>
<h2 id='fun.RPRS.mm'> Fit RS generalised lambda distribution to data set using moment 
matching </h2><span id='topic+fun.RPRS.mm'></span>

<h3>Description</h3>

<p>This function fits RS generalised lambda distribution to data set 
using moment matching
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fun.RPRS.mm(data, rs.init = c(-1.5, 1.5), leap = 3, FUN = "runif.sobol", 
no = 10000)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fun.RPRS.mm_+3A_data">data</code></td>
<td>
<p> Dataset to be fitted </p>
</td></tr>
<tr><td><code id="fun.RPRS.mm_+3A_rs.init">rs.init</code></td>
<td>
<p> Initial values for RS distribution optimization, 
<code>c(-1.5,1.5)</code> tends to work well. </p>
</td></tr>
<tr><td><code id="fun.RPRS.mm_+3A_leap">leap</code></td>
<td>
<p> See scrambling argument in <code><a href="#topic+fun.gen.qrn">fun.gen.qrn</a></code>. </p>
</td></tr>
<tr><td><code id="fun.RPRS.mm_+3A_fun">FUN</code></td>
<td>
<p> A character string of either  <code>"runif.sobol"</code> (default), <code>"runif.sobol.owen"</code>, 
<code>"runif.halton"</code> or <code>"QUnif"</code>. </p>
</td></tr>
<tr><td><code id="fun.RPRS.mm_+3A_no">no</code></td>
<td>
<p> Number of initial random values to find the best initial values for 
optimisation. </p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function provides method of moment fitting scheme for RS GLD. Note this 
function can fail if there are no defined percentiles from the data set or if 
the initial values do not lead to a valid RS generalised lambda distribution.
</p>
<p>This function is based on scheme detailed in the literature below but it has
been modified by the author (Steve Su).
</p>


<h3>Value</h3>

<p>A vector representing four parameters of the RS generalised lambda distribution.
</p>


<h3>Author(s)</h3>

<p> Steve Su </p>


<h3>References</h3>

<p> Karian, Z. and E. Dudewicz (2000). Fitting Statistical 
Distributions: The Generalized Lambda Distribution and Generalised Bootstrap 
Methods. New York, Chapman and Hall. </p>


<h3>See Also</h3>

 <p><code><a href="#topic+fun.RPRS.ml">fun.RPRS.ml</a></code>, <code><a href="#topic+fun.RPRS.lm">fun.RPRS.lm</a></code>, 
<code><a href="#topic+fun.RPRS.qs">fun.RPRS.qs</a></code>, <code><a href="#topic+fun.data.fit.ml">fun.data.fit.ml</a></code> 
<code><a href="#topic+fun.data.fit.lm">fun.data.fit.lm</a></code>, <code><a href="#topic+fun.data.fit.qs">fun.data.fit.qs</a></code>,  
<code><a href="#topic+fun.data.fit.mm">fun.data.fit.mm</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Fitting the normal distribution
 fun.RPRS.mm(data=rnorm(1000,2,3),rs.init=c(-1.5,1.5),leap=3)
</code></pre>

<hr>
<h2 id='fun.RPRS.qs'> Fit RS generalised lambda distribution to data set using quantile 
matching </h2><span id='topic+fun.RPRS.qs'></span>

<h3>Description</h3>

<p>This function fits RS generalised lambda distribution to data set 
using quantile matching
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fun.RPRS.qs(data, rs.init = c(-1.5, 1.5), leap = 3, FUN = "runif.sobol", 
trial.n = 100, len = 1000, type = 7, no = 10000)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fun.RPRS.qs_+3A_data">data</code></td>
<td>
<p> Dataset to be fitted </p>
</td></tr>
<tr><td><code id="fun.RPRS.qs_+3A_rs.init">rs.init</code></td>
<td>
<p> Initial values for RS distribution optimization, 
<code>c(-1.5,1.5)</code> tends to work well. </p>
</td></tr>
<tr><td><code id="fun.RPRS.qs_+3A_leap">leap</code></td>
<td>
<p> See scrambling argument in <code><a href="#topic+fun.gen.qrn">fun.gen.qrn</a></code>. </p>
</td></tr>
<tr><td><code id="fun.RPRS.qs_+3A_fun">FUN</code></td>
<td>
<p> A character string of either  <code>"runif.sobol"</code> (default), <code>"runif.sobol.owen"</code>, 
<code>"runif.halton"</code> or <code>"QUnif"</code>. </p>
</td></tr>
<tr><td><code id="fun.RPRS.qs_+3A_trial.n">trial.n</code></td>
<td>
<p> Number of evenly spaced quantile ranging from 0 to 1 to be
used in the checking phase, to find the best set of initial values for 
optimisation, this is intended to be lower than <code>len</code> to speed up the 
fitting algorithm. Default is 100. </p>
</td></tr>
<tr><td><code id="fun.RPRS.qs_+3A_len">len</code></td>
<td>
<p> Number of evenly spaced quantile ranging from 0 to 1 to be used,
default is 1000 </p>
</td></tr>
<tr><td><code id="fun.RPRS.qs_+3A_type">type</code></td>
<td>
<p> Type of quantile to be used, default is 7, see <code>quantile</code> </p>
</td></tr>
<tr><td><code id="fun.RPRS.qs_+3A_no">no</code></td>
<td>
<p> Number of initial random values to find the best initial values for 
optimisation. </p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function provides quantile matching fitting scheme for RS GLD. Note this 
function can fail if there are no defined percentiles from the data set or if 
the initial values do not lead to a valid RS generalised lambda distribution.
</p>


<h3>Value</h3>

<p>A vector representing four parameters of the RS generalised lambda distribution.
</p>


<h3>Author(s)</h3>

<p> Steve Su </p>


<h3>References</h3>

 
<p>Su (2008). Fitting GLD to data via quantile matching method. (Book chapter to
appear) </p>


<h3>See Also</h3>

 <p><code><a href="#topic+fun.RPRS.ml">fun.RPRS.ml</a></code>, <code><a href="#topic+fun.RPRS.lm">fun.RPRS.lm</a></code>, 
<code><a href="#topic+fun.RPRS.mm">fun.RPRS.mm</a></code>, <code><a href="#topic+fun.data.fit.ml">fun.data.fit.ml</a></code> 
<code><a href="#topic+fun.data.fit.lm">fun.data.fit.lm</a></code>, <code><a href="#topic+fun.data.fit.qs">fun.data.fit.qs</a></code>,  
<code><a href="#topic+fun.data.fit.mm">fun.data.fit.mm</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Fitting the normal distribution
 fun.RPRS.qs(data=rnorm(1000,2,3),rs.init=c(-1.5,1.5),leap=3)
</code></pre>

<hr>
<h2 id='fun.simu.bimodal'> Simulate a mixture of two generalised lambda distributions. </h2><span id='topic+fun.simu.bimodal'></span>

<h3>Description</h3>

<p>This function allows the user to simulate observations from a mixture of two 
generalised lambda distributions. It 
can be very useful for sensitivity analysis.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fun.simu.bimodal(result1, result2, prop1, prop2, len = 1000, 
no.test = 1000, param1, param2)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fun.simu.bimodal_+3A_result1">result1</code></td>
<td>
<p> A vector comprising four values for the first generalised 
lambda distribution. </p>
</td></tr>
<tr><td><code id="fun.simu.bimodal_+3A_result2">result2</code></td>
<td>
<p> A vector comprising four values for the second generalised 
lambda distribution. </p>
</td></tr>
<tr><td><code id="fun.simu.bimodal_+3A_prop1">prop1</code></td>
<td>
<p> Proportion of the first generalised lambda distribution </p>
</td></tr>
<tr><td><code id="fun.simu.bimodal_+3A_prop2">prop2</code></td>
<td>
<p> 1-prop1, this can be left unspecified. </p>
</td></tr>
<tr><td><code id="fun.simu.bimodal_+3A_len">len</code></td>
<td>
<p> Length of object for each simulation run. </p>
</td></tr>
<tr><td><code id="fun.simu.bimodal_+3A_no.test">no.test</code></td>
<td>
<p> Number of simulation run. </p>
</td></tr>
<tr><td><code id="fun.simu.bimodal_+3A_param1">param1</code></td>
<td>
<p> This can be <code>"rs"</code> or <code>"fmkl"</code>, specifying the type 
of the first generalised lambda distribution. </p>
</td></tr>
<tr><td><code id="fun.simu.bimodal_+3A_param2">param2</code></td>
<td>
<p> This can be <code>"rs"</code> or <code>"fmkl"</code>, specifying the type 
of the second generalised lambda distribution. </p>
</td></tr>
</table>


<h3>Details</h3>

<p>The length of object in <code>len</code> means how many observations should
be generated in each simulation run, with the number of simulation runs governed 
by <code>no.test</code>.
</p>


<h3>Value</h3>

<p>A list with length equal to the number of simulation runs. Each subset of the 
list has random observations equal to the the number specified in
<code>len</code>.
</p>


<h3>Author(s)</h3>

<p> Steve Su </p>


<h3>See Also</h3>

 <p><code><a href="#topic+fun.theo.bi.mv.gld">fun.theo.bi.mv.gld</a></code>, <code><a href="#topic+fun.moments.bimodal">fun.moments.bimodal</a></code>, 
<code><a href="#topic+fun.rawmoments">fun.rawmoments</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'># Generate random observations from FMKL generalised lambda distributions with 
# parameters (1,2,3,4) and (4,3,2,1) with 50% of data from each distribution.
junk&lt;-fun.simu.bimodal(c(1,2,3,4),c(4,3,2,1),prop1=0.5,param1="fmkl",
param2="fmkl")

# Calculate the maximum number from each simulation run
sapply(junk,max)

# Calculate the median from each simulation run
sapply(junk,median)
</code></pre>

<hr>
<h2 id='fun.theo.bi.mv.gld'> Calculates the theoretical mean, variance, skewness and kurtosis for  
mixture of two generalised lambda distributions. </h2><span id='topic+fun.theo.bi.mv.gld'></span>

<h3>Description</h3>

<p>This is the bimodal counterpart for <code><a href="#topic+fun.comp.moments.ml.2">fun.comp.moments.ml.2</a></code> and 
<code><a href="#topic+fun.comp.moments.ml">fun.comp.moments.ml</a></code>. </p>


<h3>Usage</h3>

<pre><code class='language-R'>fun.theo.bi.mv.gld(L1, L2, L3, L4, param1, M1, M2, M3, M4, param2, p1,
normalise="N")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fun.theo.bi.mv.gld_+3A_l1">L1</code></td>
<td>
<p> Location parameter of the first generalised lambda distribution. 
Or all the parameters of mixture distribution in the form of
c(L1,L2,L3,L4,M1,M2,M3,M4,p), you still must specify param1 and param2. </p>
</td></tr>
<tr><td><code id="fun.theo.bi.mv.gld_+3A_l2">L2</code></td>
<td>
<p> Scale parameter of the first generalised lambda distribution. </p>
</td></tr>
<tr><td><code id="fun.theo.bi.mv.gld_+3A_l3">L3</code></td>
<td>
<p> First shape parameter of the first generalised lambda 
distribution. </p>
</td></tr>
<tr><td><code id="fun.theo.bi.mv.gld_+3A_l4">L4</code></td>
<td>
<p> Second shape parameter of the first generalised lambda 
distribution. </p>
</td></tr>
<tr><td><code id="fun.theo.bi.mv.gld_+3A_param1">param1</code></td>
<td>
 <p><code>"rs"</code> or <code>"fmkl"</code> specifying the type of the first 
generalised lambda distribution. </p>
</td></tr>
<tr><td><code id="fun.theo.bi.mv.gld_+3A_m1">M1</code></td>
<td>
<p> Location parameter of the second generalised lambda distribution </p>
</td></tr>
<tr><td><code id="fun.theo.bi.mv.gld_+3A_m2">M2</code></td>
<td>
<p> Scale parameter of the second generalised lambda distribution. </p>
</td></tr>
<tr><td><code id="fun.theo.bi.mv.gld_+3A_m3">M3</code></td>
<td>
<p> First shape parameter of the second generalised lambda 
distribution. </p>
</td></tr>
<tr><td><code id="fun.theo.bi.mv.gld_+3A_m4">M4</code></td>
<td>
<p> Second shape parameter of the second generalised lambda 
distribution. </p>
</td></tr>
<tr><td><code id="fun.theo.bi.mv.gld_+3A_param2">param2</code></td>
<td>
 <p><code>"rs"</code> or <code>"fmkl"</code> specifying the type of the 
second generalised lambda distribution. </p>
</td></tr>
<tr><td><code id="fun.theo.bi.mv.gld_+3A_p1">p1</code></td>
<td>
<p> Proportion of the first generalisd lambda distribution. </p>
</td></tr>
<tr><td><code id="fun.theo.bi.mv.gld_+3A_normalise">normalise</code></td>
<td>
<p> &quot;Y&quot; if you want kurtosis to be calculated with reference
to kurtosis = 0 under Normal distribution. </p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector showing the theoretical mean, variance, skewness and kurtosis for
mixture of two generalised lambda distributions. </p>


<h3>Note</h3>

<p> The theoretical moments may not always exist for generalised lambda 
distributions. </p>


<h3>Author(s)</h3>

<p> Steve Su </p>


<h3>References</h3>

<p>  Freimer, M., Mudholkar, G. S., Kollia, G. &amp; Lin, C. T. (1988), A
study of the generalized tukey lambda family, Communications in
Statistics - Theory and Methods *17*, 3547-3567.
</p>
<p>Karian, Zaven A. and Dudewicz, Edward J. (2000), Fitting
statistical distributions: the Generalized Lambda Distribution and
Generalized Bootstrap methods, Chapman &amp; Hall
</p>
<p>Ramberg, J. S. &amp; Schmeiser, B. W. (1974), An approximate method
for generating asymmetric random variables, Communications of the
ACM *17*, 78-82. </p>


<h3>See Also</h3>

 <p><code><a href="#topic+fun.moments.bimodal">fun.moments.bimodal</a></code>, <code><a href="#topic+fun.simu.bimodal">fun.simu.bimodal</a></code>, 
<code><a href="#topic+fun.rawmoments">fun.rawmoments</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Fits the Old Faithful geyser data (first column) using the maximum 
# likelihood.
 fit1&lt;-fun.auto.bimodal.ml(faithful[,1],init1.sel="rmfmkl",init2.sel="rmfmkl",
 init1=c(-0.25,1.5),init2=c(-0.25,1.5),leap1=3,leap2=3)

# Find the theoretical moments of the fit
 fun.theo.bi.mv.gld(fit1$par[1],fit1$par[2],fit1$par[3],fit1$par[4],"fmkl",
 fit1$par[5],fit1$par[6],fit1$par[7],fit1$par[8],"fmkl",fit1$par[9])

# Compare this with the empirical moments from the data set.
 fun.moments(faithful[,1])
</code></pre>

<hr>
<h2 id='fun.theo.mv.gld'> Find the theoretical first four moments of the generalised lambda 
distribution. </h2><span id='topic+fun.theo.mv.gld'></span>

<h3>Description</h3>

<p>Computes the &quot;mean&quot;,&quot;variance&quot;,&quot;skewness&quot;,&quot;kurtosis&quot; statistics from a 
given generalised lambda distribution.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fun.theo.mv.gld(L1, L2, L3, L4, param, normalise="N")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fun.theo.mv.gld_+3A_l1">L1</code></td>
<td>
<p> Lambda 1. Or c(Lambda 1,Lambda 2,Lambda 3,Lambda 4). </p>
</td></tr>
<tr><td><code id="fun.theo.mv.gld_+3A_l2">L2</code></td>
<td>
<p> Lambda 2. </p>
</td></tr>
<tr><td><code id="fun.theo.mv.gld_+3A_l3">L3</code></td>
<td>
<p> Lambda 3. </p>
</td></tr>
<tr><td><code id="fun.theo.mv.gld_+3A_l4">L4</code></td>
<td>
<p> Lambda 4. </p>
</td></tr>
<tr><td><code id="fun.theo.mv.gld_+3A_param">param</code></td>
<td>
<p> &quot;rs&quot; or &quot;fmkl&quot; or &quot;fkml&quot; </p>
</td></tr>
<tr><td><code id="fun.theo.mv.gld_+3A_normalise">normalise</code></td>
<td>
<p> &quot;Y&quot; if you want kurtosis to be calculated with reference
to kurtosis = 0 under Normal distribution.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector listing the values of mean, variance, skewness and kurtosis.
</p>


<h3>Note</h3>

<p> Sometimes the theoretical moments may not exist, in those cases, 
<code>NA</code> is returned.
</p>


<h3>Author(s)</h3>

<p> Steve Su </p>


<h3>References</h3>

<p> Freimer, M., Mudholkar, G. S., Kollia, G. &amp; Lin, C. T. (1988),  A
study of the generalized tukey lambda family, Communications  in
Statistics - Theory and Methods *17*, 3547-3567.
</p>
<p>Gilchrist, Warren G. (2000), Statistical Modelling with Quantile
Functions, Chapman &amp; Hall
</p>
<p>Karian, Z.A., Dudewicz, E.J., and McDonald, P. (1996), The
extended  generalized lambda distribution system for fitting
distributions to data:  history, completion of theory, tables,
applications, the &ldquo;Final Word&rdquo;  on Moment fits, Communications
in Statistics - Simulation and Computation  *25*, 611-642.
</p>
<p>Karian,  Zaven A. and Dudewicz, Edward J. (2000), Fitting
statistical distributions: the Generalized Lambda Distribution and
Generalized Bootstrap methods, Chapman &amp; Hall
</p>


<h3>See Also</h3>

 <p><code><a href="#topic+fun.comp.moments.ml">fun.comp.moments.ml</a></code>, 
<code><a href="#topic+fun.comp.moments.ml.2">fun.comp.moments.ml.2</a></code>, <code><a href="#topic+fun.lm.theo.gld">fun.lm.theo.gld</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>fun.theo.mv.gld(1, 2, 3, 4, "rs")
fun.theo.mv.gld(1, 2, 3, 4, "fmkl")
</code></pre>

<hr>
<h2 id='fun.which.zero'> Determine which values are zero. </h2><span id='topic+fun.which.zero'></span>

<h3>Description</h3>

<p>Returns an integer vector showing the position of zero values in the data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fun.which.zero(data)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fun.which.zero_+3A_data">data</code></td>
<td>
<p> A vector of data. </p>
</td></tr>
</table>


<h3>Value</h3>

<p>An integer vector showing the position of zero values in the data.
</p>


<h3>Note</h3>

<p> Any missing values will be returned as missing. </p>


<h3>Author(s)</h3>

<p> Steve Su </p>


<h3>See Also</h3>

 <p><code><a href="#topic+fun.zero.omit">fun.zero.omit</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'># Finding where the zeros are in this vector: c(0,1,2,3,4,0,2)
fun.which.zero(c(0,1,2,3,4,0,2))
# Finding where the zeros are in this vector: c(0,1,2,3,NA,0,2)
fun.which.zero(c(0,1,2,3,NA,0,2))
</code></pre>

<hr>
<h2 id='fun.zero.omit'> Returns a vector after removing all the zeros. </h2><span id='topic+fun.zero.omit'></span>

<h3>Description</h3>

<p>This function returns a vector after removing all the zeros.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fun.zero.omit(object)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fun.zero.omit_+3A_object">object</code></td>
<td>
<p> A vector of data. </p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a vector after removing zeros and also give information on the number 
of zeros in the data removed.
</p>


<h3>Note</h3>

<p> Missing value and Inf values are not removed in this zero removing 
process.
</p>


<h3>Author(s)</h3>

<p> Steve Su </p>


<h3>See Also</h3>

 <p><code><a href="#topic+fun.which.zero">fun.which.zero</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'># Removing zero entries from the vector c(0,1,2,3,4,0,2)
fun.zero.omit(c(0,1,2,3,4,0,2))
</code></pre>

<hr>
<h2 id='gl.check.lambda.alt'> Checks whether the parameters provided constitute a valid generalised 
lambda distribution. </h2><span id='topic+gl.check.lambda.alt'></span>

<h3>Description</h3>

<p>An alternative to the <code>gl.check.lambda</code> function in <span class="pkg">gld</span> package.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gl.check.lambda.alt(l1, l2, l3, l4, param = "fmkl")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gl.check.lambda.alt_+3A_l1">l1</code></td>
<td>
<p> Lambda 1. </p>
</td></tr>
<tr><td><code id="gl.check.lambda.alt_+3A_l2">l2</code></td>
<td>
<p> Lambda 2. </p>
</td></tr>
<tr><td><code id="gl.check.lambda.alt_+3A_l3">l3</code></td>
<td>
<p> Lambda 3. </p>
</td></tr>
<tr><td><code id="gl.check.lambda.alt_+3A_l4">l4</code></td>
<td>
<p> Lambda 4. </p>
</td></tr>
<tr><td><code id="gl.check.lambda.alt_+3A_param">param</code></td>
<td>
 <p><code>"rs"</code> or <code>"fmkl"</code> generalised lambda distribution. </p>
</td></tr>
</table>


<h3>Details</h3>

<p>This version differs from <code>gl.check.lambda</code> in <span class="pkg">gld</span> library.
</p>


<h3>Value</h3>

<p>A logical value, <code>TRUE</code> or <code>FALSE</code>. <code>TRUE</code> indicates the 
parameters given is a valid probability distribution.
</p>


<h3>Author(s)</h3>

<p> Steve Su </p>


<h3>References</h3>

<p>  Freimer, M., Mudholkar, G. S., Kollia, G. &amp; Lin, C. T. (1988), A
study of the generalized tukey lambda family, Communications in
Statistics - Theory and Methods *17*, 3547-3567.
</p>
<p>Karian, Z.E., Dudewicz, E.J., and McDonald, P. (1996), The
extended  generalized lambda distribution system for fitting
distributions to data: history, completion of theory, tables,
applications, the &ldquo;Final Word&rdquo;  on Moment fits, Communications
in Statistics - Simulation and Computation  *25*, 611-642.
</p>
<p>Ramberg, J. S. &amp; Schmeiser, B. W. (1974), An approximate method
for generating asymmetric random variables, Communications of the
ACM *17*, 78-82.
</p>


<h3>See Also</h3>

 <p><code><a href="#topic+gl.check.lambda.alt1">gl.check.lambda.alt1</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>gl.check.lambda.alt(0,1,.23,4.5,param="fmkl") ## TRUE
gl.check.lambda.alt(0,-1,.23,4.5,param="fmkl") ## FALSE 
gl.check.lambda.alt(0,1,0.5,-0.5,param="rs") ## FALSE
</code></pre>

<hr>
<h2 id='gl.check.lambda.alt1'> Checks whether the parameters provided constitute a valid generalised 
lambda distribution. </h2><span id='topic+gl.check.lambda.alt1'></span>

<h3>Description</h3>

<p>A replacement to the gl.check.lambda function in <span class="pkg">gld</span> package.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gl.check.lambda.alt1(l1, l2 = NULL, l3 = NULL, l4 = NULL, 
param = "fmkl", vect = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gl.check.lambda.alt1_+3A_l1">l1</code></td>
<td>
<p> Lambda 1. </p>
</td></tr>
<tr><td><code id="gl.check.lambda.alt1_+3A_l2">l2</code></td>
<td>
<p> Lambda 2. </p>
</td></tr>
<tr><td><code id="gl.check.lambda.alt1_+3A_l3">l3</code></td>
<td>
<p> Lambda 3. </p>
</td></tr>
<tr><td><code id="gl.check.lambda.alt1_+3A_l4">l4</code></td>
<td>
<p> Lambda 4. </p>
</td></tr>
<tr><td><code id="gl.check.lambda.alt1_+3A_param">param</code></td>
<td>
 <p><code>"rs"</code> or <code>"fmkl"</code> generalised lambda distribution. </p>
</td></tr>
<tr><td><code id="gl.check.lambda.alt1_+3A_vect">vect</code></td>
<td>
<p> A logical, set this to <code>TRUE</code> if the parameters are given in 
the vector form (it turns off checking of the format of 'lambdas' and the 
other lambda arguments
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This is a modified <code>gl.check.lambda</code> function in replace of <span class="pkg">gld</span> 
library's <code>gl.check.lambda</code> function to allow for 5 parameters FMKL 
distributions and vector input of parameter values into this function.
</p>


<h3>Value</h3>

<p>A logical value, <code>TRUE</code> or <code>FALSE</code>. <code>TRUE</code> indicates the 
parameters given is a valid probability distribution.
</p>


<h3>Author(s)</h3>

<p> Steve Su </p>


<h3>References</h3>

<p>  Freimer, M., Mudholkar, G. S., Kollia, G. &amp; Lin, C. T. (1988), A
study of the generalized tukey lambda family, Communications in
Statistics - Theory and Methods *17*, 3547-3567.
</p>
<p>Karian, Z.E., Dudewicz, E.J., and McDonald, P. (1996), The
extended  generalized lambda distribution system for fitting
distributions to data: history, completion of theory, tables,
applications, the &ldquo;Final Word&rdquo;  on Moment fits, Communications
in Statistics - Simulation and Computation  *25*, 611-642.
</p>
<p>Ramberg, J. S. &amp; Schmeiser, B. W. (1974), An approximate method
for generating asymmetric random variables, Communications of the
ACM *17*, 78-82.
</p>


<h3>See Also</h3>

 <p><code><a href="#topic+gl.check.lambda.alt">gl.check.lambda.alt</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>gl.check.lambda.alt1(c(0,1,.23,4.5),param="fmkl",vect=TRUE) 
## TRUE, Using vector input of parameter values.
gl.check.lambda.alt1(0,-1,.23,4.5,param="fmkl") ## FALSE 
gl.check.lambda.alt1(0,1,0.5,-0.5,param="rs") ## FALSE
</code></pre>

<hr>
<h2 id='GLD+20functions'> The Generalised Lambda Distribution Family </h2><span id='topic+dgl'></span><span id='topic+pgl'></span><span id='topic+qdgl'></span><span id='topic+qgl'></span><span id='topic+rgl'></span>

<h3>Description</h3>

<p>Density, quantile density, distribution function, quantile 
function and random generation for the generalised lambda
distribution  (also known as the asymmetric lambda, or Tukey
lambda).  Works for  both the <code>"fmkl"</code> and <code>"rs"</code>
parameterisations. These functions originate from the <span class="pkg">gld</span> 
library by Robert King and they are modified in this package
to allow greater functionality and adaptability to new fitting
methods. It does not give an error message for invalid distributions
but will return NAs instead. To allow comparability with the pkg(gld) 
package, this package uses the same notation and description as those 
written by Robert King.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>     dgl(x, lambda1 = 0, lambda2 = NULL, lambda3 = NULL, lambda4 = NULL, 
       param = "fmkl", inverse.eps = 1e-08, 
       max.iterations = 500)
     pgl(q, lambda1 = 0, lambda2 = NULL, lambda3 = NULL, lambda4 = NULL, 
       param = "fmkl",  inverse.eps = 1e-08, 
       max.iterations = 500)
     qgl(p, lambda1, lambda2 = NULL, lambda3 = NULL, lambda4 = NULL,
       param = "fmkl")
     rgl(n, lambda1=0, lambda2 = NULL, lambda3 = NULL, lambda4 = NULL,
       param = "fmkl")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="GLD+2B20functions_+3A_x">x</code></td>
<td>
<p> Vector of actual values for <code>dgl</code> </p>
</td></tr>
<tr><td><code id="GLD+2B20functions_+3A_p">p</code></td>
<td>
<p> Vector of probabilities for <code>qgl</code> or <code>qdgl</code> </p>
</td></tr> 
<tr><td><code id="GLD+2B20functions_+3A_q">q</code></td>
<td>
<p> Vector of quantiles for <code>pgl</code> </p>
</td></tr> 
<tr><td><code id="GLD+2B20functions_+3A_n">n</code></td>
<td>
<p> Number of observations to be generated for <code>rgl</code> </p>
</td></tr>
<tr><td><code id="GLD+2B20functions_+3A_lambda1">lambda1</code></td>
<td>
<p> This can be either a single numeric value or a vector. If it 
is a vector, it must be of length 4 for parameterisations  <code>"fmkl"</code> or 
<code>"rs"</code> and of length 5 for parameterisation <code>"fm5"</code> and the other 
'lambda' arguments must be left as <code>NULL</code>. The numbering of the lambda 
parameters for the <code>"fmkl"</code> parameterisation is different to that used by 
Freimer, Mudholkar, Kollia and Lin (1988).
</p>
</td></tr>
<tr><td><code id="GLD+2B20functions_+3A_lambda2">lambda2</code></td>
<td>
<p> Scale parameter </p>
</td></tr>
<tr><td><code id="GLD+2B20functions_+3A_lambda3">lambda3</code></td>
<td>
<p> First shape parameter </p>
</td></tr>
<tr><td><code id="GLD+2B20functions_+3A_lambda4">lambda4</code></td>
<td>
<p> Second shape parameter </p>
</td></tr>
<tr><td><code id="GLD+2B20functions_+3A_param">param</code></td>
<td>
 <p><code>"fmkl"</code> or <code>"fkml"</code> uses Freimer, Kollia, Mudholkar,
and Lin (1988) and it is the default setting. <code>"rs"</code> uses 
Ramberg and Schmeiser (1974) </p>
</td></tr>
<tr><td><code id="GLD+2B20functions_+3A_inverse.eps">inverse.eps</code></td>
<td>
<p> Accuracy of calculation for the numerical determination of
F(x), defaults to 1e-8 </p>
</td></tr>
<tr><td><code id="GLD+2B20functions_+3A_max.iterations">max.iterations</code></td>
<td>
<p> Maximum number of iterations in the numerical 
determination of F(x), defaults to 500 </p>
</td></tr>
</table>


<h3>Details</h3>

<p>The generalised lambda distribution, also known as the asymmetric
lambda,  or Tukey lambda distribution, is a distribution with a
wide range of shapes.   The distribution is defined by its
quantile function, the inverse of the distribution function.  The
'gld' package implements three parameterisations of the
distribution.   The default parameterisation (the FMKL) is that
due to Freimer  Mudholkar, Kollia and Lin (1988) (see references
below), with a quantile  function:
</p>
<p style="text-align: center;"><code class="reqn">F^{-1}(u)= \lambda_1 + { { \frac{u^{\lambda_3}-1}{\lambda_3} -    
     \frac{(1-u)^{\lambda_4}-1}{\lambda_4} } \over \lambda_2 }</code>
</p>

<p>for <code class="reqn">\lambda_2 &gt; 0</code>.
</p>
<p>A second parameterisation, the RS, chosen by setting <code>param="rs"</code> is 
that due to Ramberg and Schmeiser (1974), with the quantile function:
</p>
<p style="text-align: center;"><code class="reqn">F^{-1}(u)= \lambda_1 + \frac{u^{\lambda_3} - (1-u)^{\lambda_4}}   
     {\lambda_2} </code>
</p>

<p>This parameterisation has a complex series of rules determining
which values  of the parameters produce valid statistical
distributions. See <code>gl.check.lambda</code> for details.</p>


<h3>Value</h3>

<table>
<tr><td><code>dgl</code></td>
<td>
<p> gives the density (based on the quantile density and a 
numerical solution to <code class="reqn">F^{-1}(u)=x</code>, </p>
</td></tr>
<tr><td><code>qdgl</code></td>
<td>
<p> gives the quantile density, </p>
</td></tr>
<tr><td><code>pgl</code></td>
<td>
<p> gives the distribution function (based on a numerical
solution to <code class="reqn">F^{-1}(u)=x</code>, </p>
</td></tr>
<tr><td><code>qgl</code></td>
<td>
<p> gives the quantile function, and </p>
</td></tr>
<tr><td><code>rgl</code></td>
<td>
<p> generates random observations. </p>
</td></tr>
</table>


<h3>References</h3>

<p>Freimer, M., Kollia, G., Mudholkar, G. S. &amp; Lin, C. T. (1988),  A
study of the generalized tukey lambda family, Communications  in
Statistics - Theory and Methods *17*, 3547-3567.
</p>
<p>Gilchrist, Warren G. (2000), Statistical Modelling with Quantile
Functions, Chapman &amp; Hall
</p>
<p>Karian, Z.A., Dudewicz, E.J., and McDonald, P. (1996), The
extended  generalized lambda distribution system for fitting
distributions to data:  history, completion of theory, tables,
applications, the &ldquo;Final Word&rdquo;  on Moment fits, Communications
in Statistics - Simulation and Computation  *25*, 611-642.
</p>
<p>Karian,  Zaven A. and Dudewicz, Edward J. (2000), Fitting
statistical distributions: the Generalized Lambda Distribution and
Generalized Bootstrap methods, Chapman &amp; Hall
</p>
<p>Ramberg, J. S. &amp; Schmeiser, B. W. (1974), An approximate method
for generating asymmetric random variables, Communications of the
ACM *17*,  78-82. </p>


<h3>Examples</h3>

<pre><code class='language-R'> qgl(seq(0,1,0.02),0,1,0.123,-4.3)
 pgl(seq(-2,2,0.2),0,1,-.1,-.2,param="fmkl",inverse.eps=.Machine$double.eps)
</code></pre>

<hr>
<h2 id='GLDEX-package'>
This package fits RS and FMKL generalised lambda distributions using 
various methods. It also provides functions for fitting bimodal 
distributions using mixtures of generalised lambda distributions.
</h2><span id='topic+GLDEX-package'></span><span id='topic+GLDEX'></span>

<h3>Description</h3>

<p>The fitting algorithms considered in this package have two major objectives. One 
is to provide a smoothing device to fit distributions to data using the weight 
and unweighted discretised approach based on the bin width of the histogram. The 
other is to provide a definitive fit to the data set using the maximum 
likelihood estimation.
</p>
<p>Copyright Information: To ensure the stability of this package, this package 
ports other functions from other open sourced packages directly so that any 
changes in other packages will not cause this package to malfunction.
</p>
<p>All functions obtained from other sources have been acknowledged by the author 
in the authorship or the description sections of the help files and they are 
freely available online for all to use. Please contact the author 
for any copyright issues.
</p>
<p>Specifically the following functions have been modified from R:
</p>
<p>hist.su, ks.gof, pretty.su 
</p>
<p>The following functions are taken from other open source packages in R:
</p>
<p>runif.pseudo, rnorm.pseudo, runif.halton, rnorm.halton, runif.sobol, rnorm.sobol 
by Diethelm Wuertz distributed under GPL.
</p>
<p>digitsBase, QUnif and sHalton written by Martin Maechler distributed under GPL.
</p>
<p>dgl, pgl, rgl, qgl, starship.adpativegrid, starship.obj and starship written by 
Robert King and some functions modified by Steve Su distributed under GPL.
</p>
<p>Lmoments and t1lmoments written by Juha Karvanen distributed under GPL.
</p>


<h3>Details</h3>

<p>This package allows a direct fitting method onto the data set using 
<code><a href="#topic+fun.RMFMKL.ml">fun.RMFMKL.ml</a></code>, <code><a href="#topic+fun.RMFMKL.ml.m">fun.RMFMKL.ml.m</a></code>, <code><a href="#topic+fun.RMFMKL.hs">fun.RMFMKL.hs</a></code>, 
<code><a href="#topic+fun.RMFMKL.hs.nw">fun.RMFMKL.hs.nw</a></code>, <code><a href="#topic+fun.RPRS.ml">fun.RPRS.ml</a></code>, <code><a href="#topic+fun.RPRS.ml.m">fun.RPRS.ml.m</a></code>,
<code><a href="#topic+fun.RPRS.hs">fun.RPRS.hs</a></code>, <code><a href="#topic+fun.RPRS.hs.nw">fun.RPRS.hs.nw</a></code>,
<code><a href="#topic+fun.RMFMKL.qs">fun.RMFMKL.qs</a></code>, <code><a href="#topic+fun.RPRS.qs">fun.RPRS.qs</a></code>, 
<code><a href="#topic+fun.RMFMKL.mm">fun.RMFMKL.mm</a></code>, <code><a href="#topic+fun.RPRS.mm">fun.RPRS.mm</a></code>, 
<code><a href="#topic+fun.RMFMKL.lm">fun.RMFMKL.lm</a></code>, <code><a href="#topic+fun.RPRS.lm">fun.RPRS.lm</a></code> and in the case of 
bimodal data set: <code><a href="#topic+fun.auto.bimodal.qs">fun.auto.bimodal.qs</a></code>,
<code><a href="#topic+fun.auto.bimodal.ml">fun.auto.bimodal.ml</a></code>, 
<code><a href="#topic+fun.auto.bimodal.pml">fun.auto.bimodal.pml</a></code> functions.
The resulting fits can be graphically gauged by <code><a href="#topic+fun.plot.fit">fun.plot.fit</a></code> or 
<code><a href="#topic+fun.plot.fit.bm">fun.plot.fit.bm</a></code> (for bimodal data), or examined by numbers
using the Kolmogorov-Smirnoff resample tests (<code><a href="#topic+fun.diag.ks.g">fun.diag.ks.g</a></code>) and 
<code><a href="#topic+fun.diag.ks.g.bimodal">fun.diag.ks.g.bimodal</a></code>). For unimodal data fits, it is also
possible to compare the mean, variance, skewness and kurtosis of the fitted 
distribution with the data set using <code><a href="#topic+fun.comp.moments.ml">fun.comp.moments.ml</a></code> and 
<code><a href="#topic+fun.comp.moments.ml.2">fun.comp.moments.ml.2</a></code> functions. Similarly, for bimodal data fits,
this is done via <code><a href="#topic+fun.theo.bi.mv.gld">fun.theo.bi.mv.gld</a></code> and <code><a href="#topic+fun.moments.r">fun.moments.r</a></code>. 
Additionally, L moments for single generalised lambda distribution can be 
obtained using <code><a href="#topic+fun.lm.theo.gld">fun.lm.theo.gld</a></code>. For graphical display of 
goodness of fit, quantile plots can be used, these can be done using
<code><a href="#topic+qqplot.gld">qqplot.gld</a></code> and <code><a href="#topic+qqplot.gld.bi">qqplot.gld.bi</a></code> for univariate 
and bimodal generalised lambda distribution fits respectively.
</p>


<h3>Author(s)</h3>

<p>Steve Su &lt;allegro.su@gmail.com&gt;
</p>


<h3>References</h3>

<p>Asquith, W. (2007), L-moments and TL-moments of the generalized lambda 
distribution, Computational Statistics and Data Analysis 51(9): 4484-4496. 
</p>
<p>Freimer, M., Mudholkar, G. S., Kollia, G. &amp; Lin, C. T. (1988), A study of the 
generalized tukey lambda family, Communications in Statistics - Theory and 
Methods *17*, 3547-3567. 
</p>
<p>Gilchrist, Warren G. (2000), Statistical Modelling with Quantile Functions, 
Chapman &amp; Hall 
</p>
<p>Karian, Z.A., Dudewicz, E.J., and McDonald, P. (1996), The extended generalized 
lambda distribution system for fitting distributions to data: history, 
completion of theory, tables, applications, the &ldquo;Final Word&rdquo; on Moment fits, 
Communications in Statistics - Simulation and Computation *25*, 611-642. 
</p>
<p>Karian, Zaven A. and Dudewicz, Edward J. (2000), Fitting statistical 
distributions: the Generalized Lambda Distribution and Generalized Bootstrap 
methods, Chapman &amp; Hall 
</p>
<p>Karvanen, J. and A. Nuutinen (2008), 
Characterizing the generalized lambda distribution by L-moments, 
Computational Statistics and Data Analysis 52(4): 1971-1983. 
doi:10.1016/j.csda.2007.06.021
</p>
<p>King, R.A.R. &amp; MacGillivray, H. L. (1999), A starship method for fitting the 
generalised lambda distributions, Australian and New Zealand Journal of 
Statistics, 41, 353-374 
doi:10.1111/1467-842X.00089
</p>
<p>Ramberg, J. S. &amp; Schmeiser, B. W. (1974), An approximate method for generating 
asymmetric random variables, Communications of the ACM *17*, 78-82. 
</p>
<p>Su, S. (2005). A Discretized Approach to Flexibly Fit Generalized Lambda 
Distributions to Data. Journal of Modern Applied Statistical Methods (November): 
408-424. doi:10.22237/jmasm/1130803560
</p>
<p>Su, S. (2007). Nmerical Maximum Log Likelihood Estimation for Generalized Lambda 
Distributions.  Computational Statistics and Data Analysis: *51*, 8, 3983-3998.
doi:10.1016/j.csda.2006.06.008
</p>
<p>Su, S. (2007). Fitting Single and Mixture of Generalized Lambda Distributions to 
Data via Discretized and Maximum Likelihood Methods: GLDEX in R. Journal of 
Statistical Software: *21* 9. doi:10.18637/jss.v021.i09
</p>
<p>Su, S. (2009). Confidence Intervals for Quantiles Using Generalized Lambda 
Distributions. Computational Statistics and Data Analysis *53*, 9, 3324-3333.
doi:10.1016/j.csda.2009.02.014
</p>
<p>Su, S. (2010). Chapter 14: Fitting GLDs and Mixture of GLDs to Data using 
Quantile Matching Method. Handbook of Distribution Fitting Methods with R. 
(Karian and Dudewicz) 557-583. doi:10.1201/b10159-3
</p>
<p>Su, S. (2010). Chapter 15: Fitting GLD to data using GLDEX 1.0.4 in R. Handbook 
of Distribution Fitting Methods with R. (Karian and Dudewicz) 585-608. 
doi:10.1201/b10159-3
</p>
<p>Su, S. (2015) &quot;Flexible Parametric Quantile Regression Model&quot; Statistics &amp;
Computing 25 (3). 635-650. doi:10.1007/s11222-014-9457-1   
</p>
<p>Su S. (2021) &quot;Flexible parametric accelerated failure time model&quot; J Biopharm Stat. 
2021 Sep 31(5):650-667. doi:10.1080/10543406.2021.1934854
</p>


<h3>See Also</h3>

<p><span class="pkg">GLDreg</span> package in R for GLD regression models.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
###Univariate distributions example:

set.seed(1000)

junk&lt;-rweibull(300,3,2)

##A faster ML estimtion 

junk.fit1&lt;-fun.RMFMKL.ml.m(junk)
junk.fit2&lt;-fun.RPRS.ml.m(junk)

qqplot.gld(junk.fit1,data=junk,param="fmkl")
qqplot.gld(junk.fit2,data=junk,param="rs")

##Using discretised approach, with 50 classes

#Using discretised method with weights
obj.fit1.hs&lt;-fun.data.fit.hs(junk)

#Plot the resulting fit. The fun.plot.fit function also works for singular fits 
#such as those by fun.plot.fit(obj.fit1.ml,junk,nclass=50,
#param=c("rs","fmkl","fmkl"),xlab="x")

fun.plot.fit(obj.fit1.hs,junk,nclass=50,param=c("rs","fmkl"),xlab="x")

#Compare the mean, variance, skewness and kurtosis of the fitted distribution 
#with actual data

fun.theo.mv.gld(obj.fit1.hs[1,1],obj.fit1.hs[2,1],obj.fit1.hs[3,1],
obj.fit1.hs[4,1],param="rs")
fun.theo.mv.gld(obj.fit1.hs[1,2],obj.fit1.hs[2,2],obj.fit1.hs[3,2],
obj.fit1.hs[4,2],param="fmkl")
fun.moments.r(junk)

#Conduct resample KS tests
fun.diag.ks.g(obj.fit1.hs[,1],junk,param="rs")
fun.diag.ks.g(obj.fit1.hs[,2],junk,param="fmkl")

##Try another fit, say 15 classes

obj.fit2.hs&lt;-fun.data.fit.hs(junk,rs.default="N",fmkl.default="N",no.c.rs = 15, 
no.c.fmkl = 15)

fun.plot.fit(obj.fit2.hs,junk,nclass=50,param=c("rs","fmkl"),xlab="x")

fun.theo.mv.gld(obj.fit2.hs[1,1],obj.fit2.hs[2,1],obj.fit2.hs[3,1],
obj.fit2.hs[4,1],param="rs")
fun.theo.mv.gld(obj.fit2.hs[1,2],obj.fit2.hs[2,2],obj.fit2.hs[3,2],
obj.fit2.hs[4,2],param="fmkl")
fun.moments.r(junk)

fun.diag.ks.g(obj.fit2.hs[,1],junk,param="rs")
fun.diag.ks.g(obj.fit2.hs[,2],junk,param="fmkl")

##Uses the maximum likelihood estimation method

#Fit the function using fun.data.fit.ml
obj.fit1.ml&lt;-fun.data.fit.ml(junk)

#Plot the resulting fit
fun.plot.fit(obj.fit1.ml,junk,nclass=50,param=c("rs","fmkl","fmkl"),xlab="x",
name=".ML")

#Compare the mean, variance, skewness and kurtosis of the fitted distribution 
#with actual data
fun.comp.moments.ml(obj.fit1.ml,junk)

#Do a quantile plot

qqplot.gld(junk,obj.fit1.ml[,1],param="rs",name="RS ML fit")

#Run a KS resample test on the resulting fit

fun.diag2(obj.fit1.ml,junk,1000)

#It is possible to use say fun.data.fit.ml(junk,rs.leap=409,fmkl.leap=409,
#FUN="QUnif") to find solution under a different set of low discrepancy number 
#generators.

###Bimodal distributions example:

#Fitting mixture of generalised lambda distributions on the data set using both 
#the maximum likelihood and partition maximum likelihood and plot the resulting 
#fits

opar &lt;- par() 
par(mfrow=c(2,1))

junk&lt;-fun.auto.bimodal.ml(faithful[,1],per.of.mix=0.01,clustering.m=clara,
init1.sel="rprs",init2.sel="rmfmkl",init1=c(-1.5,1.5),init2=c(-0.25,1.5),
leap1=3,leap2=3)
fun.plot.fit.bm(nclass=50,fit.obj=junk,data=faithful[,1],
name="Maximum likelihood using",xlab="faithful1",param.vec=c("rs","fmkl"))

#Do a quantile plot

qqplot.gld.bi(faithful[,1],junk$par,param1="rs",param2="fmkl",
name="RS FMKL ML fit",range=c(0.001,0.999))

par(opar)

junk&lt;-fun.auto.bimodal.pml(faithful[,1],clustering.m=clara,init1.sel="rprs",
init2.sel="rmfmkl",init1=c(-1.5,1.5),init2=c(-0.25,1.5),leap1=3,leap2=3)
fun.plot.fit.bm(nclass=50,fit.obj=junk,data=faithful[,1],
name="Partition maximum likelihood using",xlab="faithful1",
param.vec=c("rs","fmkl"))

#Fit the faithful[,1] data from the dataset library using sobol sequence 
#generator for the first distribution fit and halton sequence for the second 
#distribution fit.

fit1&lt;-fun.auto.bimodal.ml(faithful[,1],init1.sel="rmfmkl",init2.sel="rmfmkl",
init1=c(-0.25,1.5),init2=c(-0.25,1.5),leap1=3,leap2=3,fun1="runif.sobol",
fun2="runif.halton")

#Run diagnostic KS tests

fun.diag.ks.g.bimodal(fit1$par[1:4],fit1$par[5:8],prop1=fit1$par[9],
data=faithful[,1],param1="fmkl",param2="fmkl")

#Find the theoretical moments of the fit

fun.theo.bi.mv.gld(fit1$par[1],fit1$par[2],fit1$par[3],fit1$par[4],"fmkl",
fit1$par[5],fit1$par[6],fit1$par[7],fit1$par[8],"fmkl",fit1$par[9])

#Compare this with the empirical moments from the data set.

fun.moments.r(faithful[,1])

#Do a quantile plot

qqplot.gld.bi(faithful[,1],fit1$par,param1="fmkl",param2="fmkl",
name="FMKL FMKL ML fit")

#Quantile matching method

#Fitting faithful data from the dataset library, with the clara clustering 
#regime. The first distribution is RS and the second distribution is fmkl. 
#The percentage of data mix is 1%.

#Fitting normal(3,2) distriution using the default setting
junk&lt;-rnorm(50,3,2)
fun.data.fit.qs(junk)

fun.auto.bimodal.qs(faithful[,1],per.of.mix=0.01,clustering.m=clara,
init1.sel="rprs",init2.sel="rmfmkl",init1=c(-1.5,1,5),init2=c(-0.25,1.5),
leap1=3,leap2=3)

#L Moment matching

#Fitting normal(3,2) distriution using the default setting
junk&lt;-rnorm(50,3,2)
fun.data.fit.lm(junk)

# Moment matching method

#Fitting normal(3,2) distriution using the default setting
junk&lt;-rnorm(50,3,2)
fun.data.fit.mm(junk)

# Example on fitting mixture of normal distributions

data1&lt;-c(rnorm(1500,-1,2/3),rnorm(1500,1,2/3))

junk&lt;-fun.auto.bimodal.ml(data1,per.of.mix=0.01,clustering.m=data1&gt;0,
init1.sel="rprs",init2.sel="rmfmkl",init1=c(-1.5,1.5),init2=c(-0.25,1.5),
leap1=3,leap2=3)

fun.plot.fit.bm(nclass=50,fit.obj=junk,data=data1,
name="Maximum likelihood using",xlab="faithful1",param.vec=c("rs","fmkl"))

qqplot.gld.bi(data1,junk$par,param1="rs",param2="fmkl",
name="RS FMKL ML fit",range=c(0.001,0.999))

# Generate random observations from FMKL generalised lambda distributions with 
# parameters (1,2,3,4) and (4,3,2,1) with 50% of data from each distribution.
fun.simu.bimodal(c(1,2,3,4),c(4,3,2,1),prop1=0.5,param1="fmkl",param2="fmkl")
</code></pre>

<hr>
<h2 id='histsu'> Histogram with exact number of bins specified by the user </h2><span id='topic+histsu'></span>

<h3>Description</h3>

<p>The generic function histsu computes a histogram of the given data values.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>histsu(x, breaks = "Sturges", freq = NULL, probability = !freq, 
include.lowest = TRUE, right = TRUE, density = NULL, angle = 45, col = NULL, 
border = NULL, main = paste("Histogram of", xname), xlim = range(breaks), 
ylim = NULL, xlab = xname, ylab, axes = TRUE, plot = TRUE, labels = FALSE, 
nclass = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="histsu_+3A_x">x</code></td>
<td>
<p> A vector of values for which the histogram is desired. </p>
</td></tr>
<tr><td><code id="histsu_+3A_breaks">breaks</code></td>
<td>
<p> Either: 1) A vector giving the breakpoints between histogram 
cells, OR 2) A single number giving the number of cells for the
histogram, OR 3) A character string naming an algorithm to compute the number 
of cells (see Details), OR 4) A function to compute the number of cells. </p>
</td></tr>
<tr><td><code id="histsu_+3A_freq">freq</code></td>
<td>
<p> logical; if <code>TRUE</code>, the histogram graphic is a 
representation of frequencies, the <code>counts</code> component of the result; 
if <code>FALSE</code>, probability densities, component 'density', are plotted (so 
that the histogram has a total area of one). 
Defaults to <code>TRUE</code> iff 'breaks' are equidistant (and 'probability' is not 
specified). </p>
</td></tr>
<tr><td><code id="histsu_+3A_probability">probability</code></td>
<td>
<p> A logical value, <code>TRUE</code> means it is not a frequency 
graph. </p>
</td></tr>
<tr><td><code id="histsu_+3A_include.lowest">include.lowest</code></td>
<td>
<p> If <code>TRUE</code>, an <code>x[i]</code> equal to the 'breaks' 
value will be included in the first (or last, for <code>right=FALSE</code>) bar.  
This will be ignored (with a warning) unless 'breaks' is a vector. </p>
</td></tr>
<tr><td><code id="histsu_+3A_right">right</code></td>
<td>
<p> If <code>TRUE</code>, the histograms cells are right-closed 
(left open) intervals. </p>
</td></tr>
<tr><td><code id="histsu_+3A_density">density</code></td>
<td>
<p> The density of shading lines, in lines per inch. The default 
value of <code>NULL</code> means that no shading lines are drawn.
Non-positive values of 'density' also inhibit the drawing of shading lines. </p>
</td></tr>
<tr><td><code id="histsu_+3A_angle">angle</code></td>
<td>
<p> The slope of shading lines, given as an angle in degrees 
(counter-clockwise). </p>
</td></tr>
<tr><td><code id="histsu_+3A_col">col</code></td>
<td>
<p> A colour to be used to fill the bars. The default of <code>NULL</code> 
yields unfilled bars. </p>
</td></tr>
<tr><td><code id="histsu_+3A_border">border</code></td>
<td>
<p> The color of the border around the bars.  The default is to use 
the standard foreground color. </p>
</td></tr>
<tr><td><code id="histsu_+3A_main">main</code></td>
<td>
<p> Title of the graph. </p>
</td></tr>
<tr><td><code id="histsu_+3A_xlim">xlim</code></td>
<td>
<p> A two valued vector specifying the lower and upper limits of the 
x axis. </p>
</td></tr>
<tr><td><code id="histsu_+3A_ylim">ylim</code></td>
<td>
<p> A two valued vector specifying the lower and upper limits of the 
y axis. </p>
</td></tr>
<tr><td><code id="histsu_+3A_xlab">xlab</code></td>
<td>
<p> X axis labels. </p>
</td></tr>
<tr><td><code id="histsu_+3A_ylab">ylab</code></td>
<td>
<p> Y axis labels. </p>
</td></tr>
<tr><td><code id="histsu_+3A_axes">axes</code></td>
<td>
<p> Logical value, if <code>TRUE</code>, axis will be drawn. </p>
</td></tr>
<tr><td><code id="histsu_+3A_plot">plot</code></td>
<td>
<p> Logical value, if <code>TRUE</code>, plot will be drawn. </p>
</td></tr>
<tr><td><code id="histsu_+3A_labels">labels</code></td>
<td>
<p> Logical or character.  Additionally draw labels on top of bars, 
if not <code>FALSE</code>; see <code><a href="graphics.html#topic+plot.histogram">plot.histogram</a></code>. </p>
</td></tr>
<tr><td><code id="histsu_+3A_nclass">nclass</code></td>
<td>
<p> Number of bins of the histogram. </p>
</td></tr>
<tr><td><code id="histsu_+3A_...">...</code></td>
<td>
<p> Other graphical parameters, see par for details. </p>
</td></tr>
</table>


<h3>Details</h3>

<p>See <code><a href="graphics.html#topic+hist">hist</a></code> help file. This function forces the number of class of 
histogram to that as specified by the user.
</p>


<h3>Value</h3>

<p>An object of class <code>"histogram"</code> which is a list with components:
</p>
<table>
<tr><td><code>breaks</code></td>
<td>
<p> The n+1 cell boundaries (=<code>breaks</code> if that was a vector). 
</p>
</td></tr>
<tr><td><code>counts</code></td>
<td>
<p> N integers; for each cell, the number of <code>x[]</code> inside. </p>
</td></tr>
<tr><td><code>density</code></td>
<td>
<p> Values as estimated density values. If <code>all(diff(breaks) 
  == 1)</code>, they are the relative frequencies counts/n. </p>
</td></tr> 
<tr><td><code>intensities</code></td>
<td>
<p> Same as density, deprecated. </p>
</td></tr>
<tr><td><code>mids</code></td>
<td>
<p> The n cell midpoints. </p>
</td></tr>
<tr><td><code>xname</code></td>
<td>
<p> A character string with the actual <code>x</code> argument name. </p>
</td></tr>
<tr><td><code>equidist</code></td>
<td>
<p> Logical, indicating if the distances between <code>breaks</code> 
are all the same.</p>
</td></tr>
</table>


<h3>Note</h3>

<p> Please see <code>hist</code> help file.
</p>


<h3>Author(s)</h3>

<p> R development team with modifications by Steve Su </p>


<h3>References</h3>

<p> Venables, W. N. and Ripley. B. D. (2002) Modern Applied Statistics 
with S.  Springer.
</p>


<h3>See Also</h3>

 <p><code><a href="graphics.html#topic+hist">hist</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'># See hist for extended example:
junk&lt;-rgamma(1000,5)
# Forcing the number of bins to be 10:
histsu(junk,nclass=10)
</code></pre>

<hr>
<h2 id='is.inf'> Returns a logical vecto, TRUE if the value is Inf or -Inf. </h2><span id='topic+is.inf'></span>

<h3>Description</h3>

<p>This function works in similar fashion as in <code><a href="Matrix.html#topic+is.na">is.na</a></code> and 
<code><a href="#topic+is.notinf">is.notinf</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is.inf(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="is.inf_+3A_x">x</code></td>
<td>
<p> A numerical value or a vector of data. </p>
</td></tr>
</table>


<h3>Value</h3>

<p>A logical vector, <code>T</code> if the value is Inf or -Inf.
</p>


<h3>Note</h3>

<p> In the presence of missing value, the function will return a missing 
value.
</p>


<h3>Author(s)</h3>

<p> Steve Su </p>


<h3>See Also</h3>

 <p><code><a href="Matrix.html#topic+is.na">is.na</a></code>,<code><a href="#topic+is.notinf">is.notinf</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>is.inf(c(Inf,2,2,1,-Inf))
</code></pre>

<hr>
<h2 id='is.notinf'> Returns a logical vector TRUE, if the value is not Inf or -Inf. </h2><span id='topic+is.notinf'></span>

<h3>Description</h3>

<p>This function works in similar fashion as in <code><a href="Matrix.html#topic+is.na">is.na</a></code> 
and <code><a href="#topic+is.inf">is.inf</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is.notinf(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="is.notinf_+3A_x">x</code></td>
<td>
<p> A numerical value or a vector of data. </p>
</td></tr>
</table>


<h3>Value</h3>

<p>A logical vector, <code>T</code> if the value is not Inf or -Inf.
</p>


<h3>Note</h3>

<p> In the presence of missing value, the function will return a missing 
value.
</p>


<h3>Author(s)</h3>

<p> Steve Su </p>


<h3>See Also</h3>

 <p><code><a href="Matrix.html#topic+is.na">is.na</a></code>,<code><a href="#topic+is.inf">is.inf</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>is.notinf(c(Inf,2,2,1,-Inf))
</code></pre>

<hr>
<h2 id='ks.gof'> Kolmogorov-Smirnov test </h2><span id='topic+ks.gof'></span>

<h3>Description</h3>

<p>Performs one or two sample Kolmogorov-Smirnov tests.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ks.gof(x, y, ..., alternative = c("two.sided", "less", "greater"), 
exact = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ks.gof_+3A_x">x</code></td>
<td>
<p> A numeric vector of data values. </p>
</td></tr>
<tr><td><code id="ks.gof_+3A_y">y</code></td>
<td>
<p> Either a numeric vector of data values, or a character string naming 
a distribution function. </p>
</td></tr>
<tr><td><code id="ks.gof_+3A_...">...</code></td>
<td>
<p> Parameters of the distribution specified (as a character string) 
by 'y'. </p>
</td></tr>
<tr><td><code id="ks.gof_+3A_alternative">alternative</code></td>
<td>
<p> Indicates the alternative hypothesis and must be one of 
<code>"two.sided"</code> (default),<code>"less"</code>, or <code>"greater"</code>.  
You can specify just the initial letter. </p>
</td></tr>
<tr><td><code id="ks.gof_+3A_exact">exact</code></td>
<td>
 <p><code>NULL</code> or a logical indicating whether an exact p-value 
should be computed.  See Details for the meaning of <code>NULL</code>. 
Not used for the one-sided two-sample case. </p>
</td></tr>
</table>


<h3>Details</h3>

<p>If <code>y</code> is numeric, a two-sample test of the null hypothesis that
<code>x</code> and <code>y</code> were drawn from the same continuous distribution is
performed.
</p>
<p>Alternatively, <code>y</code> can be a character string naming a continuous
distribution function.  In this case, a one-sample test is carried
out of the null that the distribution function which generated <code>x</code>
is distribution <code>y</code> with parameters specified by &quot;...&quot;.
</p>
<p>The possible values <code>"two.sided"</code> (default),<code>"less"</code>
and <code>"greater"</code> of <code>alternative</code> specify the null hypothesis that the 
true distribution function of <code>x</code> is equal to, not less than or not
greater than the hypothesized distribution function (one-sample case) or the 
distribution function of <code>y</code> (two-sample case),
respectively.
</p>
<p>Exact p-values are not available for the one-sided two-sample case, or in the 
case of ties.  <code>exact = NULL</code> (the default), an exact p-value is computed 
if the sample size if less than 100 in the one-sample case, and if the product 
of the sample sizes is less than 10000 in the two-sample case.  Otherwise, 
asymptotic distributions are used whose approximations may be inaccurate in
small samples.  In the one-sample two-sided case, exact p-values are obtained as 
described in Marsaglia, Tsang &amp; Wang (2003).  The formula of Birnbaum &amp; Tingey 
(1951) is used for the one-sample one-sided case.
</p>
<p>If a single-sample test is used, the parameters specified in &quot;...&quot; must be 
pre-specified and not estimated from the data. There is some more refined 
distribution theory for the KS test with estimated parameters 
(see Durbin, 1973), but that is not implemented in <code>ks.gof</code>.
</p>


<h3>Value</h3>

<p>A list with class <code>"htest"</code> containing the following components: 
</p>
<table>
<tr><td><code>statistic</code></td>
<td>
<p> Value of test statistics. </p>
</td></tr>
<tr><td><code>p.value</code></td>
<td>
<p> P-value. </p>
</td></tr>
<tr><td><code>alternative</code></td>
<td>
<p>Character string describing the alternative hypothesis. </p>
</td></tr>
<tr><td><code>method</code></td>
<td>
<p> Character string indicating what type of test was performed. </p>
</td></tr>  
<tr><td><code>data.name</code></td>
<td>
<p> Character string giving the name(s) of the data. </p>
</td></tr>
</table>


<h3>Note</h3>

<p> This function handle ties by jittering, adding a very small uniform 
random number generated from the minimal value of the data set divided by 1e+08 
to minimal value divided by 1e+07.
</p>


<h3>Author(s)</h3>

<p> R </p>


<h3>References</h3>

 
<p>Z. W. Birnbaum &amp; Fred H. Tingey (1951), One-sided confidence
contours for probability distribution functions. The Annals of
Mathematical Statistics, *22*/4, 592-596.
</p>
<p>William J. Conover (1971), Practical nonparametric statistics.
New York: John Wiley &amp; Sons. Pages 295-301 (one-sample
&quot;Kolmogorov&quot; test), 309-314 (two-sample &quot;Smirnov&quot; test).
</p>
<p>Durbin, J. (1973) Distribution theory for tests based on the
sample distribution function.  SIAM.
</p>
<p>George Marsaglia, Wai Wan Tsang &amp; Jingbo Wang (2003), Evaluating
Kolmogorov's distribution. Journal of Statistical Software,
*8*/18. &lt;URL: http://www.jstatsoft.org/v08/i18/&gt;.
</p>


<h3>See Also</h3>

 <p><code><a href="stats.html#topic+ks.test">ks.test</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- rnorm(50)
y &lt;- runif(30)
# Do x and y come from the same distribution?
ks.gof(x, y)
# Does x come from a shifted gamma distribution with shape 3 and rate 2?
ks.gof(x+2, "pgamma", 3, 2) # two-sided, exact
ks.gof(x+2, "pgamma", 3, 2, exact = FALSE)
ks.gof(x+2, "pgamma", 3, 2, alternative = "gr")
</code></pre>

<hr>
<h2 id='Lmoments'>L-moments</h2><span id='topic+Lmoments'></span><span id='topic+Lcoefs'></span><span id='topic+Lmomcov'></span><span id='topic+Lmoments_calc'></span><span id='topic+Lmomcov_calc'></span>

<h3>Description</h3>

<p>Calculates sample L-moments, L-coefficients and covariance matrix of L-moments. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Lmoments(data,rmax=4,na.rm=FALSE,returnobject=FALSE,trim=c(0,0))
Lcoefs(data,rmax=4,na.rm=FALSE,trim=c(0,0))
Lmomcov(data,rmax=4,na.rm=FALSE)
Lmoments_calc(data,rmax=4)
Lmomcov_calc(data,rmax=4)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Lmoments_+3A_data">data</code></td>
<td>
<p>matrix or data frame.</p>
</td></tr>
<tr><td><code id="Lmoments_+3A_rmax">rmax</code></td>
<td>
<p>maximum order of L-moments.</p>
</td></tr>
<tr><td><code id="Lmoments_+3A_na.rm">na.rm</code></td>
<td>
<p>a logical value indicating whether 'NA' values should be
removed before the computation proceeds.</p>
</td></tr>
<tr><td><code id="Lmoments_+3A_returnobject">returnobject</code></td>
<td>
<p>a logical value indicating whether a list object should be 
returned instead of an array of L-moments.</p>
</td></tr>
<tr><td><code id="Lmoments_+3A_trim">trim</code></td>
<td>
<p>c(0,0) for ordinary L-moments and c(1,1) for trimmed (t=1) 
L-moments</p>
</td></tr>
</table>


<h3>Value</h3>

<table>
<tr><td><code>Lmoments</code></td>
<td>
<p> returns an array of L-moments containing a row for each 
variable in data, or if returnobject=TRUE, a list containing the following: </p>
</td></tr>
<tr><td><code>lambdas</code></td>
<td>
<p>an array of L-moments</p>
</td></tr> 
<tr><td><code>ratios</code></td>
<td>
<p>an array of mean, L-scale and L-moment ratios</p>
</td></tr>
<tr><td><code>trim</code></td>
<td>
<p>the value of the parameter 'trim'</p>
</td></tr>
<tr><td><code>source</code></td>
<td>
<p>a string with value &quot;Lmoments&quot; or &quot;t1lmoments&quot;</p>
</td></tr>
<tr><td><code>Lcoefs</code></td>
<td>
<p>returns an array of L-coefficients (mean, L-scale, L-skewness, 
L-kurtosis, ...)</p>
</td></tr> 
<tr><td><code>Lmomcov</code></td>
<td>
<p>returns the covariance matrix of L-moments or a list of 
covariance matrices if the input has multiple columns.</p>
</td></tr>
<tr><td><code>Lmoments_calc</code></td>
<td>
<p>is internal function.</p>
</td></tr>
<tr><td><code>Lmomcov_calc</code></td>
<td>
<p>is internal function.</p>
</td></tr></table>


<h3>Note</h3>

<p>Functions <code>Lmoments</code> and <code>Lcoefs</code> calculate trimmed L-moments 
if you specify <code>trim=c(1,1)</code>.</p>


<h3>Author(s)</h3>

<p>Juha Karvanen &lt;<a href="mailto:juha.karvanen@ktl.fi">juha.karvanen@ktl.fi</a>&gt;</p>


<h3>References</h3>

<p>Karvanen, J. and A. Nuutinen (2008). 
&quot;Characterizing the generalized lambda distribution by L-moments.&quot; 
Computational Statistics and Data Analysis 52(4): 1971-1983.
</p>
<p>Asquith, W. (2007). 
&quot;L-moments and TL-moments of the generalized lambda distribution.&quot; 
Computational Statistics and Data Analysis 51(9): 4484-4496.
</p>
<p>Elamir, E. A., Seheult, A. H. 2004. 
&quot;Exact variance structure of sample L-moments&quot; 
Journal of Statistical Planning and Inference 124 (2) 337-359.
</p>
<p>Hosking, J. 1990. &quot;L-moments: Analysis and estimation distributions using linear 
combinations of order statistics&quot;, 
Journal of Royal Statistical Society B 52, 105-124.
</p>


<h3>See Also</h3>

 <p><code><a href="#topic+t1lmoments">t1lmoments</a></code> for trimmed L-moments </p>


<h3>Examples</h3>

<pre><code class='language-R'>
x&lt;-rnorm(500)
Lmoments(x)

</code></pre>

<hr>
<h2 id='Optimisation+20functions'> This is a collection of functions used in the optimisation processes for 
all the fitting
methods covered in this package. </h2><span id='topic+optim.fun2.nw'></span><span id='topic+optim.fun2'></span><span id='topic+optim.fun3'></span><span id='topic+optim.fun3.C'></span><span id='topic+optim.fun3.C.m'></span><span id='topic+optim.fun4'></span><span id='topic+optim.fun5'></span><span id='topic+optim.fun6'></span><span id='topic+optim.fun7'></span><span id='topic+optim.fun.lm'></span><span id='topic+optim.fun.qs'></span><span id='topic+optim.fun.bi.final'></span>

<h3>Description</h3>

<p>These functions are for maintainers only and it is not designed for the users of 
this package.
</p>


<h3>Value</h3>

<p> Optimisation value under different fitting schemes, not intended to be used by users of this package </p>


<h3>Note</h3>

<p> Please contact the author directly if you find a bug! </p>


<h3>Author(s)</h3>

<p> Steve Su </p>

<hr>
<h2 id='pretty.su'> An alternative to the normal pretty function in R. </h2><span id='topic+pretty.su'></span>

<h3>Description</h3>

<p>Divide a range of values into equally spaced divisions. End points are given as 
output.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pretty.su(x, nint = 5)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pretty.su_+3A_x">x</code></td>
<td>
<p> A vector of values. </p>
</td></tr>
<tr><td><code id="pretty.su_+3A_nint">nint</code></td>
<td>
<p> Number of intervals required. </p>
</td></tr>
</table>


<h3>Details</h3>

<p>This is also used for the plotting of histogram in the <code><a href="#topic+histsu">histsu</a></code> 
function.
</p>


<h3>Value</h3>

<p>A vector of endpoints dividing the data into equally spaced regions.
</p>


<h3>Author(s)</h3>

<p> Steve Su </p>


<h3>See Also</h3>

 <p><code><a href="base.html#topic+pretty">pretty</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'># Generate random numbers from normal distribution:
junk&lt;-rnorm(1000,2,3)

# Cut them into 7 regions, 8 endpoints.
pretty.su(junk,7)

</code></pre>

<hr>
<h2 id='qqplot.gld'> Do a quantile plot on the univariate distribution fits. </h2><span id='topic+qqplot.gld'></span>

<h3>Description</h3>

<p>This plots the theoretical and actual data quantiles to allow the user to 
examine the adequacy of a single gld distribution fit.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>qqplot.gld(data, fit, param, len = 10000, name = "", 
corner = "topleft",type="",range=c(0,1),xlab="",main="")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="qqplot.gld_+3A_data">data</code></td>
<td>
<p> Data fitted. </p>
</td></tr>
<tr><td><code id="qqplot.gld_+3A_fit">fit</code></td>
<td>
<p> Parameters of distribution fit. </p>
</td></tr>
<tr><td><code id="qqplot.gld_+3A_param">param</code></td>
<td>
<p> Can be either <code>"rs"</code> or <code>"fmkl"</code>. </p>
</td></tr>
<tr><td><code id="qqplot.gld_+3A_len">len</code></td>
<td>
<p> Precision of the quantile calculatons. Default is 10000. This 
means 10000 points are taken from 0 to 1.</p>
</td></tr>
<tr><td><code id="qqplot.gld_+3A_name">name</code></td>
<td>
<p> Name of the data set, added to the title of plot if <code>main</code>
is missing. </p>
</td></tr>
<tr><td><code id="qqplot.gld_+3A_corner">corner</code></td>
<td>
<p> Can be <code>"bottomright"</code>, <code>"bottom"</code>, 
<code>"bottomleft"</code>, <code>"left"</code>, <code>"topleft"</code>, <code>"top"</code>,
<code>"topright"</code>, <code>"right"</code>, <code>"center"</code> as in 
<code><a href="graphics.html#topic+legend">legend</a></code>. </p>
</td></tr>
<tr><td><code id="qqplot.gld_+3A_type">type</code></td>
<td>
<p> This can be &quot;&quot; or &quot;str.qqplot&quot;, the first produces the raw 
quantiles and the second plot them on a straight line. Default is &quot;&quot;.</p>
</td></tr>
<tr><td><code id="qqplot.gld_+3A_range">range</code></td>
<td>
<p> This is the range for which the quantiles are to be plotted. 
Default is <code>c(0,1)</code>. </p>
</td></tr>
<tr><td><code id="qqplot.gld_+3A_xlab">xlab</code></td>
<td>
<p> x axis label, if left blank, then default is &quot;Data&quot;. </p>
</td></tr>
<tr><td><code id="qqplot.gld_+3A_main">main</code></td>
<td>
<p> Title of the plot, if left blank, a default title will 
be added. </p>
</td></tr>
</table>


<h3>Value</h3>

<p>A plot is given.
</p>


<h3>Author(s)</h3>

<p> Steve Su </p>


<h3>See Also</h3>

 <p><code><a href="#topic+qqplot.gld.bi">qqplot.gld.bi</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>
 set.seed(1000)

 junk&lt;-rweibull(300,3,2)

# Fit the function using fun.data.fit.ml
 obj.fit1.ml&lt;-fun.data.fit.ml(junk)

# Do a quantile plot on the raw quantiles
 qqplot.gld(junk,obj.fit1.ml[,1],param="rs",name="RS ML fit")

# Or a qq plot to examine deviation from straight line
 qqplot.gld(junk,obj.fit1.ml[,1],param="rs",name="RS ML fit",type="str.qqplot")
</code></pre>

<hr>
<h2 id='qqplot.gld.bi'> Do a quantile plot on the bimodal distribution fits. </h2><span id='topic+qqplot.gld.bi'></span>

<h3>Description</h3>

<p>This plots the theoretical and actual data quantiles to allow the user to 
examine the adequacy of two gld distributions mixture fit.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>qqplot.gld.bi(data, fit, param1, param2, len = 10000, name = "", 
corner = "topleft",type="",range=c(0,1),xlab="",main="")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="qqplot.gld.bi_+3A_data">data</code></td>
<td>
<p> Data fitted. </p>
</td></tr>
<tr><td><code id="qqplot.gld.bi_+3A_fit">fit</code></td>
<td>
<p> Parameters of distribution fit. </p>
</td></tr>
<tr><td><code id="qqplot.gld.bi_+3A_param1">param1</code></td>
<td>
<p> Can be either <code>"rs"</code> or <code>"fmkl"</code>. </p>
</td></tr>
<tr><td><code id="qqplot.gld.bi_+3A_param2">param2</code></td>
<td>
<p> Can be either <code>"rs"</code> or <code>"fmkl"</code>. </p>
</td></tr>
<tr><td><code id="qqplot.gld.bi_+3A_len">len</code></td>
<td>
<p> Precision of the quantile calculatons. Default is 10000. This 
means 10000 points are taken from 0 to 1.</p>
</td></tr>
<tr><td><code id="qqplot.gld.bi_+3A_name">name</code></td>
<td>
<p> Name of the data set, added to the title of plot if <code>main</code>
is missing. </p>
</td></tr>
<tr><td><code id="qqplot.gld.bi_+3A_corner">corner</code></td>
<td>
<p> Can be <code>"bottomright"</code>, <code>"bottom"</code>, 
<code>"bottomleft"</code>, <code>"left"</code>, <code>"topleft"</code>, <code>"top"</code>, 
<code>"topright"</code>, <code>"right"</code>, <code>"center"</code> as in 
<code><a href="graphics.html#topic+legend">legend</a></code>. </p>
</td></tr>
<tr><td><code id="qqplot.gld.bi_+3A_type">type</code></td>
<td>
<p> This can be &quot;&quot; or &quot;str.qqplot&quot;, the first produces the raw 
quantiles and the second plot them on a straight line. Default is &quot;&quot;.</p>
</td></tr>
<tr><td><code id="qqplot.gld.bi_+3A_range">range</code></td>
<td>
<p> This is the range for which the quantiles are to be plotted. 
Default is <code>c(0,1)</code>. </p>
</td></tr>
<tr><td><code id="qqplot.gld.bi_+3A_xlab">xlab</code></td>
<td>
<p> x axis label, if left blank, then default is &quot;Data&quot; </p>
</td></tr>
<tr><td><code id="qqplot.gld.bi_+3A_main">main</code></td>
<td>
<p> Title of the plot, if left blank, a default title will 
be added. </p>
</td></tr>
</table>


<h3>Value</h3>

<p>A plot is given.
</p>


<h3>Author(s)</h3>

<p> Steve Su </p>


<h3>See Also</h3>

 <p><code><a href="#topic+qqplot.gld">qqplot.gld</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>
 set.seed(1000)

 junk&lt;-rweibull(300,3,2)

## Fitting mixture of generalised lambda distributions on the data set using 
## both the maximum likelihood and partition maximum likelihood and plot the 
## resulting fits
 junk&lt;-fun.auto.bimodal.ml(faithful[,1],per.of.mix=0.1,clustering.m=clara,
 init1.sel="rprs",init2.sel="rmfmkl",init1=c(-1.5,1.5),init2=c(-0.25,1.5),
 leap1=3,leap2=3)
 fun.plot.fit.bm(nclass=50,fit.obj=junk,data=faithful[,1],
 name="Maximum likelihood using",xlab="faithful1",param.vec=c("rs","fmkl"))

## Do a quantile plot on the raw quantiles
 qqplot.gld.bi(faithful[,1],junk$par,param1="rs",param2="fmkl",
 name="RS FMKL ML fit")

## Or a qq plot to examine deviation from straight line
 qqplot.gld.bi(faithful[,1],junk$par,param1="rs",param2="fmkl",
 name="RS FMKL ML fit",type="str.qqplot")
</code></pre>

<hr>
<h2 id='QUnif'>Quasi Randum Numbers via Halton Sequences</h2><span id='topic+QUnif'></span><span id='topic+sHalton'></span>

<h3>Description</h3>

<p>These functions provide quasi random numbers or <em>space filling</em> or
<em>low discrepancy</em> sequences in the <code class="reqn">p</code>-dimensional unit cube.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sHalton(n.max, n.min = 1, base = 2, leap = 1)
 QUnif (n, min = 0, max = 1, n.min = 1, p, leap = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="QUnif_+3A_n.max">n.max</code></td>
<td>
<p>maximal (sequence) number.</p>
</td></tr>
<tr><td><code id="QUnif_+3A_n.min">n.min</code></td>
<td>
<p>minimal sequence number.</p>
</td></tr>
<tr><td><code id="QUnif_+3A_n">n</code></td>
<td>
<p>number of <code class="reqn">p</code>-dimensional points generated in
<code>QUnif</code>.  By default, <code>n.min = 1, leap = 1</code> and
the maximal sequence number is <code>n.max = n.min + (n-1)*leap</code>.</p>
</td></tr>
<tr><td><code id="QUnif_+3A_base">base</code></td>
<td>
<p>integer <code class="reqn">\ge 2</code>: The base with respect to which
the Halton sequence is built.</p>
</td></tr>
<tr><td><code id="QUnif_+3A_min">min</code>, <code id="QUnif_+3A_max">max</code></td>
<td>
<p>lower and upper limits of the univariate intervals.
Must be of length 1 or <code>p</code>.</p>
</td></tr>
<tr><td><code id="QUnif_+3A_p">p</code></td>
<td>
<p>dimensionality of space (the unit cube) in which points are
generated.</p>
</td></tr>
<tr><td><code id="QUnif_+3A_leap">leap</code></td>
<td>
<p>integer indicating (if <code class="reqn">&gt; 1</code>) if the series should be
leaped, i.e., only every <code>leap</code>th entry should be taken.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>sHalton(n,m)</code> returns a numeric vector of length <code>n-m+1</code> of
values in <code class="reqn">[0,1]</code>.
</p>
<p><code>QUnif(n, min, max, n.min, p=p)</code> generates <code>n-n.min+1</code>
p-dimensional points in <code class="reqn">[min,max]^p</code> returning a numeric matrix
with p columns.
</p>


<h3>Note</h3>

<p>For <code>leap</code> Kocis and Whiten recommend values of
<code class="reqn">L=31,61,149,409</code>, and particularly the <code class="reqn">L=409</code> for dimensions
up to 400.
</p>


<h3>Author(s)</h3>

<p>Martin Maechler</p>


<h3>References</h3>

<p>James Gentle (1998)
<em>Random Number Generation and Monte Carlo Simulation</em>; sec.\ 6.3.
Springer.
</p>
<p>Kocis, L. and Whiten, W.J. (1997)
Computationsl Investigations of Low-Discrepancy Sequences.
<em>ACM Transactions of Mathematical Software</em> <b>23</b>, 2, 266&ndash;294.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>32*sHalton(20, base=2)
QUnif(n=10,p=2,leap=409)
</code></pre>

<hr>
<h2 id='skewness+20and+20kurtosis'> Compute skewness and kurtosis statistics </h2><span id='topic+skewness'></span><span id='topic+kurtosis'></span>

<h3>Description</h3>

<p> This uses the S+ version directly. </p>


<h3>Usage</h3>

<pre><code class='language-R'>skewness(x, na.rm = FALSE, method = "fisher")
kurtosis(x, na.rm = FALSE, method = "fisher")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="skewness+2B20and+2B20kurtosis_+3A_x">x</code></td>
<td>
<p> Any numerical object. Missing values <code>NA</code> are allowed. </p>
</td></tr>
<tr><td><code id="skewness+2B20and+2B20kurtosis_+3A_na.rm">na.rm</code></td>
<td>
<p> Logical flag: if na.rm=TRUE, missing values are removed from x 
before doing the computations. If <code>na.rm=FALSE</code> and <code>x</code> contains 
missing values, then the return value is NA. </p>
</td></tr>
<tr><td><code id="skewness+2B20and+2B20kurtosis_+3A_method">method</code></td>
<td>
<p> Character string specifying the computation method. The two 
possible values are <code>fisher</code> for Fisher's g1 (skewness) and g2 (kurtosis) 
versions, and <code>moment</code> for the functional forms of the statistics. Only 
the first character of the string needs to be supplied. 
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>moment</code> forms are based on the definitions of skewness and kurtosis 
for distributions; these forms should be used when resampling (bootstrap or 
jackknife). The &quot;fisher&quot; forms correspond to the usual &quot;unbiased&quot; definition of 
sample variance, though in the case of skewness and kurtosis exact unbiasedness 
is not possible. 
</p>


<h3>Value</h3>

<p>A single value of skewness or kurtotis. 
</p>
<p>If y = x - mean(x), then the &quot;moment&quot; method computes the skewness value as 
mean(y<code class="reqn">\mbox{\textasciitilde}</code>3)/mean(y<code class="reqn">\mbox{\textasciitilde}</code>2)
<code class="reqn">\mbox{\textasciitilde}</code>1.5 
and the kurtosis value as mean(y<code class="reqn">\mbox{\textasciitilde}</code>4)/mean(y
<code class="reqn">\mbox{\textasciitilde}</code>2)<code class="reqn">\mbox{\textasciitilde}</code>2 - 3. 
To see the &quot;fisher&quot; calculations, print out the functions. 
</p>


<h3>Author(s)</h3>

<p> Splus </p>


<h3>See Also</h3>

 <p><code>var</code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- runif(30) 
skewness(x) 
skewness(x, method="moment") 
kurtosis(x) 
kurtosis(x, method="moment") 
</code></pre>

<hr>
<h2 id='starship'>Carry out the &ldquo;starship&rdquo; estimation method for the generalised
lambda distribution</h2><span id='topic+starship'></span>

<h3>Description</h3>

<p>Calculates estimates for the FMKL parameterisation of the generalised lambda
distribution on the basis of data, using the starship method.
The starship method is built on the fact that the 
generalised lambda distribution 
is a transformation of the uniform distribution.  This method finds the 
parameters that transform the data closest to the uniform distribution.
This function uses a grid-based search to find a suitable starting point (using
<code><a href="#topic+starship.adaptivegrid">starship.adaptivegrid</a></code>) then uses <code><a href="stats.html#topic+optim">optim</a></code> to find
the parameters that do this.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>starship(data, optim.method = "Nelder-Mead", initgrid = NULL, param="FMKL",
optim.control=NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="starship_+3A_data">data</code></td>
<td>
<p>Data to be fitted, as a vector</p>
</td></tr>
<tr><td><code id="starship_+3A_optim.method">optim.method</code></td>
<td>
<p>Optimisation method for <code><a href="stats.html#topic+optim">optim</a></code> to use, 
defaults to Nelder-Mead</p>
</td></tr>
<tr><td><code id="starship_+3A_initgrid">initgrid</code></td>
<td>
<p>Grid of values of <code class="reqn">\lambda_3</code> and
<code class="reqn">\lambda_4</code>
to try, in <code><a href="#topic+starship.adaptivegrid">starship.adaptivegrid</a></code>.  This should be a list with
elements, 
<code>lcvect</code>, a vector of values for <code class="reqn">\lambda_3</code>,
<code>ldvect</code>, a vector of values for <code class="reqn">\lambda_4</code> and
<code>levect</code>, a vector of values for <code class="reqn">\lambda_5</code> 
(<code>levect</code> is only required if <code>param</code> is <code>fm5</code>).
</p>
<p>If it is left as NULL, the default grid depends on the parameterisation.
For <code>fmkl</code>, both lcvect and ldvect default to:
</p>

<table>
<tr>
 <td style="text-align: center;">-1.5</td><td style="text-align: center;"> -1</td><td style="text-align: center;"> -.5</td><td style="text-align: center;"> -.1</td><td style="text-align: center;"> 0</td><td style="text-align: center;"> .1</td><td style="text-align: center;"> .2</td><td style="text-align: center;"> .4</td><td style="text-align: center;"> 
.8</td><td style="text-align: center;"> 1</td><td style="text-align: center;"> 1.5</td>
</tr>

</table>

<p>(<code>levect</code> is NULL).
</p>
<p>For <code>rs</code>, both lcvect and ldvect default to:
</p>

<table>
<tr>
 <td style="text-align: center;">.1</td><td style="text-align: center;"> .2</td><td style="text-align: center;"> .4</td><td style="text-align: center;"> .8</td><td style="text-align: center;"> 1</td><td style="text-align: center;"> 1.5</td>
</tr>

</table>

<p>(<code>levect</code> is NULL).
</p>
<p>For <code>fm5</code>, both lcvect and ldvect default to:
</p>

<table>
<tr>
 <td style="text-align: center;">-1.5</td><td style="text-align: center;"> -1</td><td style="text-align: center;"> -.5</td><td style="text-align: center;"> -.1</td><td style="text-align: center;"> 0</td><td style="text-align: center;"> .1</td><td style="text-align: center;"> .2</td><td style="text-align: center;"> .4</td><td style="text-align: center;"> 
.8</td><td style="text-align: center;"> 1</td><td style="text-align: center;"> 1.5</td>
</tr>

</table>

<p>and <code>levect</code> defaults to:
</p>

<table>
<tr>
 <td style="text-align: center;">-0.5</td><td style="text-align: center;"> 0.25</td><td style="text-align: center;"> 0</td><td style="text-align: center;"> 0.25</td><td style="text-align: center;"> 0.5</td>
</tr>

</table>

</td></tr>
<tr><td><code id="starship_+3A_param">param</code></td>
<td>
<p>choose parameterisation: 
<code>fmkl</code> uses <em>Freimer, Mudholkar, Kollia and Lin (1988)</em> (default).
<code>rs</code> uses <em>Ramberg and Schmeiser (1974)</em>
<code>fm5</code> uses the 5 parameter version of the FMKL parameterisation 
(paper to appear)</p>
</td></tr>
<tr><td><code id="starship_+3A_optim.control">optim.control</code></td>
<td>
<p>List of options for the optimisation step.  See
<code><a href="stats.html#topic+optim">optim</a></code> for details.  If left as NULL, the parscale 
control is set to scale <code class="reqn">\lambda_1</code>
and <code class="reqn">\lambda_2</code> by the absolute value of their starting points.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The starship method is described in King and MacGillivray, 1999 (see
references). It is built on the fact that the 
generalised lambda distribution 
is a transformation of the uniform distribution.  Thus the inverse of this
transformation is the distribution function for the gld.  The starship method
applies different values of the parameters of the distribution to the
distribution function, calculates the depths <em>q</em> corresponding to the data
and chooses the parameters that make the depths closest to a uniform
distribution.
</p>
<p>The closeness to the uniform is assessed by calculating the Anderson-Darling
goodness-of-fit test on the transformed data against the uniform, for a
sample of size <code>length(data)</code>.
</p>
<p>This is implemented in 2 stages in this function.  First a grid search is
carried out, over a small number of possible parameter values
(see <code><a href="#topic+starship.adaptivegrid">starship.adaptivegrid</a></code> for details).  Then the minimum from
this search is given as a starting point for an optimisation of the 
Anderson-Darling value using optim, with method given by <code>optim.method</code>
</p>
<p>See references for details on 
parameterisations.
</p>


<h3>Value</h3>

<p>Returns a list, with 
</p>
<table>
<tr><td><code>lambda</code></td>
<td>
<p>A vector of length 4, giving 
the estimated parameters, in order,
<code class="reqn">\lambda_1</code> - location parameter
<code class="reqn">\lambda_2</code> - scale parameter
<code class="reqn">\lambda_3</code> - first shape parameter
<code class="reqn">\lambda_4</code> - second shape parameter </p>
</td></tr>
<tr><td><code>grid.results</code></td>
<td>
<p>output from the grid search - see
<code><a href="#topic+starship.adaptivegrid">starship.adaptivegrid</a></code> for details</p>
</td></tr>
<tr><td><code>optim</code></td>
<td>
<p>output from the optim search -
<code><a href="stats.html#topic+optim">optim</a></code> for details</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Robert King, Darren Wraith</p>


<h3>References</h3>

<p> Freimer, M., Mudholkar, G. S., Kollia, G. &amp; Lin, C. T. (1988), 
<em>A study of the generalized tukey lambda family</em>, Communications 
in Statistics - Theory and Methods <b>17</b>, 3547&ndash;3567.
</p>
<p>Ramberg, J. S. &amp; Schmeiser, B. W. (1974), <em>An approximate method for
generating asymmetric random variables</em>, Communications of the ACM <b>17</b>, 
78&ndash;82.
</p>
<p>King, R.A.R. &amp; MacGillivray, H. L. (1999), <em>A starship method for
fitting the generalised <code class="reqn">\lambda</code> distributions</em>,
Australian and New Zealand Journal of
Statistics <b>41</b>, 353&ndash;374
</p>
<p>Owen, D. B. (1988), <em>The starship</em>, Communications in Statistics - 
Computation and Simulation <b>17</b>, 315&ndash;323.
</p>


<h3>See Also</h3>

 
<p><code><a href="#topic+starship.adaptivegrid">starship.adaptivegrid</a></code>, 
<code><a href="#topic+starship.obj">starship.obj</a></code> 
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
 data &lt;- rgl(100,0,1,.2,.2)
 starship(data,optim.method="Nelder-Mead",initgrid=list(lcvect=(0:4)/10,
 ldvect=(0:4)/10))
</code></pre>

<hr>
<h2 id='starship.adaptivegrid'>Carry out the &ldquo;starship&rdquo; estimation method for the generalised
lambda distribution using a grid-based search</h2><span id='topic+starship.adaptivegrid'></span>

<h3>Description</h3>

<p>Calculates estimates for the generalised lambda
distribution on the basis of data, using the starship method.
The starship method is built on the fact that the 
generalised lambda distribution 
is a transformation of the uniform distribution.  This method finds the 
parameters that transform the data closest to the uniform distribution.
This function uses a grid-based search.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>starship.adaptivegrid(data, initgrid=list(
lcvect = c(-1.5, -1, -0.5, -0.1, 0, 0.1, 0.2, 0.4, 0.8, 1, 1.5), 
ldvect = c(-1.5, -1, -0.5, -0.1, 0, 0.1, 0.2, 0.4, 0.8, 1, 1.5),
levect = c(-0.5,-0.25,0,0.25,0.5)),param="FMKL")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="starship.adaptivegrid_+3A_data">data</code></td>
<td>
<p>Data to be fitted, as a vector</p>
</td></tr>
<tr><td><code id="starship.adaptivegrid_+3A_initgrid">initgrid</code></td>
<td>
<p>A list with elements, 
<code>lcvect</code>, a vector of values for <code class="reqn">\lambda_3</code>,
<code>ldvect</code>, a vector of values for <code class="reqn">\lambda_4</code> and
<code>levect</code>, a vector of values for <code class="reqn">\lambda_5</code> 
(<code>levect</code> is only required if <code>param</code> is <code>fm5</code>).
</p>
<p><em>Note:</em> if <code>param=rs</code>, the non-positive values are dropped from 
<code>lcvect</code> and <code>ldvect</code>.
</p>
</td></tr>
<tr><td><code id="starship.adaptivegrid_+3A_param">param</code></td>
<td>
<p>choose parameterisation: 
<code>fmkl</code> uses <em>Freimer, Mudholkar, Kollia and Lin (1988)</em> (default).
<code>rs</code> uses <em>Ramberg and Schmeiser (1974)</em>
<code>fm5</code> uses the 5 parameter version of the FMKL parameterisation 
(paper to appear)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The starship method is described in King and MacGillivray, 1999 (see
references). It is built on the fact that the 
generalised lambda distribution 
is a transformation of the uniform distribution.  Thus the inverse of this
transformation is the distribution function for the gld.  The starship method
applies different values of the parameters of the distribution to the
distribution function, calculates the depths <em>q</em> corresponding to the data
and chooses the parameters that make the depths closest to a uniform
distribution.
</p>
<p>The closeness to the uniform is assessed by calculating the Anderson-Darling
goodness-of-fit test on the transformed data against the uniform, for a
sample of size <code>length(data)</code>.
</p>
<p>This function carries out a grid-based search.  This was the original method
of King and MacGillivray, 1999, but you are advised to instead use 
<code><a href="#topic+starship">starship</a></code> which uses a grid-based search together with an
optimisation based search.
</p>
<p>See references for details on
parameterisations.
</p>


<h3>Value</h3>

<table>
<tr><td><code>response</code></td>
<td>
<p>The minimum &ldquo;response value&rdquo; &mdash; the result of the
internal goodness-of-fit measure.  This is the return value of starship.obj.
See King and MacGillivray, 1999 for more details</p>
</td></tr>
<tr><td><code>lambda</code></td>
<td>
<p>A vector of length 4 giving the values of
<code class="reqn">\lambda_1</code> to <code class="reqn">\lambda_4</code> that produce this
minimum response, i.e. the estimates</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Robert King, Darren Wraith</p>


<h3>References</h3>

<p> Freimer, M., Mudholkar, G. S., Kollia, G. &amp; Lin, C. T. (1988), 
<em>A study of the generalized tukey lambda family</em>, Communications 
in Statistics - Theory and Methods <b>17</b>, 3547&ndash;3567.
</p>
<p>Ramberg, J. S. &amp; Schmeiser, B. W. (1974), <em>An approximate method for
generating asymmetric random variables</em>, Communications of the ACM <b>17</b>, 
78&ndash;82.
</p>
<p>King, R.A.R. &amp; MacGillivray, H. L. (1999), <em>A starship method for
fitting the generalised <code class="reqn">\lambda</code> distributions</em>,
Australian and New Zealand Journal of
Statistics <b>41</b>, 353&ndash;374
</p>
<p>Owen, D. B. (1988), <em>The starship</em>, Communications in Statistics - 
Computation and Simulation <b>17</b>, 315&ndash;323.
</p>


<h3>See Also</h3>

 
<p><code><a href="#topic+starship">starship</a></code>, 
<code><a href="#topic+starship.obj">starship.obj</a></code> 
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
 data &lt;- rgl(100,0,1,.2,.2)
 starship.adaptivegrid(data,list(lcvect=(0:4)/10,ldvect=(0:4)/10))
 </code></pre>

<hr>
<h2 id='starship.obj'>Objective function that is minimised in starship estimation method</h2><span id='topic+starship.obj'></span>

<h3>Description</h3>

<p>The starship is a method for fitting the generalised lambda distribution.
See <code><a href="#topic+starship">starship</a></code> for more details.
</p>
<p>This function is the objective funciton minimised in the methods.  It is a
goodness of fit measure carried out on the depths of the data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>starship.obj(par, data, param = "fmkl")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="starship.obj_+3A_par">par</code></td>
<td>
<p>parameters of the generalised lambda distribution, a vector of
length 4, giving <code class="reqn">\lambda_1</code> to <code class="reqn">\lambda_4</code>.
See references or <code>qgl</code> for details on the
definitions of these parameters</p>
</td></tr>
<tr><td><code id="starship.obj_+3A_data">data</code></td>
<td>
<p>Data &mdash; a vector</p>
</td></tr>
<tr><td><code id="starship.obj_+3A_param">param</code></td>
<td>
<p>choose parameterisation: 
<code>fmkl</code> uses <em>Freimer, Mudholkar, Kollia and Lin (1988)</em> (default).
<code>rs</code> uses <em>Ramberg and Schmeiser (1974)</em></p>
</td></tr>
</table>


<h3>Details</h3>

<p>The starship method is described in King and MacGillivray, 1999 (see
references). It is built on the fact that the 
generalised lambda distribution 
is a transformation of the uniform distribution.  Thus the inverse of this
transformation is the distribution function for the gld.  The starship method
applies different values of the parameters of the distribution to the
distribution function, calculates the depths <em>q</em> corresponding to the data
and chooses the parameters that make the depths closest to a uniform
distribution.
</p>
<p>The closeness to the uniform is assessed by calculating the Anderson-Darling
goodness-of-fit test on the transformed data against the uniform, for a
sample of size <code>length(data)</code>.
</p>
<p>This function returns that objective function.  It is provided as a seperate
function to allow users to carry out minimisations using <code><a href="stats.html#topic+optim">optim</a></code>
or other methods.  The recommended method is to use the <code>link{starship}</code>
function.
</p>


<h3>Value</h3>

<p>The Anderson-Darling goodness of fit measure, computed on the transformed
data, compared to a uniform distribution.  <em>Note that this is NOT the
goodness-of-fit measure of the generalised lambda distribution
with the given parameter values to the data.</em>
</p>


<h3>Author(s)</h3>

<p>Robert King, Darren Wraith</p>


<h3>References</h3>

<p> Freimer, M., Mudholkar, G. S., Kollia, G. &amp; Lin, C. T. (1988), 
<em>A study of the generalized tukey lambda family</em>, Communications 
in Statistics - Theory and Methods <b>17</b>, 3547&ndash;3567.
</p>
<p>Ramberg, J. S. &amp; Schmeiser, B. W. (1974), <em>An approximate method for
generating asymmetric random variables</em>, Communications of the ACM <b>17</b>, 
78&ndash;82.
</p>
<p>King, R.A.R. &amp; MacGillivray, H. L. (1999), <em>A starship method for
fitting the generalised <code class="reqn">\lambda</code> distributions</em>,
Australian and New Zealand Journal of
Statistics <b>41</b>, 353&ndash;374
</p>
<p>Owen, D. B. (1988), <em>The starship</em>, Communications in Statistics - 
Computation and Simulation <b>17</b>, 315&ndash;323.
</p>


<h3>See Also</h3>

 
<p><code><a href="#topic+starship">starship</a></code> 
<code><a href="#topic+starship.adaptivegrid">starship.adaptivegrid</a></code>, 
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
 data &lt;- rgl(100,0,1,.2,.2)
 starship.obj(c(0,1,.2,.2),data,"fmkl")
</code></pre>

<hr>
<h2 id='t1lmoments'>Trimmed L-moments</h2><span id='topic+t1lmoments'></span>

<h3>Description</h3>

<p>Calculates sample trimmed L-moments with trimming parameter 1. </p>


<h3>Usage</h3>

<pre><code class='language-R'>t1lmoments(data,rmax=4)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="t1lmoments_+3A_data">data</code></td>
<td>
<p>matrix or data frame.</p>
</td></tr>
<tr><td><code id="t1lmoments_+3A_rmax">rmax</code></td>
<td>
<p>maximum order of trimmed L-moments.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>array of trimmed L-moments (trimming parameter = 1) up to order 4 
containing a row for each variable in data.</p>


<h3>Note</h3>

<p>Functions <code>link{Lmoments}</code> and <code>link{Lcoefs}</code> calculate 
trimmed L-moments if you specify <code>trim=c(1,1)</code>.</p>


<h3>Author(s)</h3>

<p>Juha Karvanen <a href="mailto:juha.karvanen@ktl.fi">juha.karvanen@ktl.fi</a></p>


<h3>References</h3>

<p>Karvanen, J. and A. Nuutinen (2008). 
&quot;Characterizing the generalized lambda distribution by L-moments.&quot; 
Computational Statistics and Data Analysis 52(4): 1971-1983.
</p>
<p>Asquith, W. (2007). 
&quot;L-moments and TL-moments of the generalized lambda distribution.&quot; 
Computational Statistics and Data Analysis 51(9): 4484-4496.
</p>
<p>Elamir, E. A., Seheult, A. H. 2004. 
&quot;Exact variance structure of sample L-moments&quot; 
Journal of Statistical Planning and Inference 124 (2) 337-359.
</p>
<p>Hosking, J. 1990. &quot;L-moments: Analysis and estimation distributions using linear 
combinations of order statistics&quot;, 
Journal of Royal Statistical Society B 52, 105-124.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+Lmoments">Lmoments</a></code> for L-moments </p>


<h3>Examples</h3>

<pre><code class='language-R'>
x&lt;-rnorm(500)
t1lmoments(x)

</code></pre>

<hr>
<h2 id='which.na'> Determine Missing Values </h2><span id='topic+which.na'></span>

<h3>Description</h3>

<p>Returns a vector showing the position of 
missing values in a vector.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>which.na(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="which.na_+3A_x">x</code></td>
<td>
<p> An object which should be of <code>logical</code>, <code>numeric</code>, 
or <code>complex</code> </p>
</td></tr>
</table>


<h3>Value</h3>

<p>This returns the indices of values in <code>x</code> which are missing or 
&quot;Not a Number&quot;. 
</p>


<h3>Examples</h3>

<pre><code class='language-R'># A non-zero number divided by zero creates infinity,
# zero over zero creates a NaN 
weird.values &lt;- c(1/0, -2.9/0, 0/0, NA) 
which.na(weird.values) 
# Produces:
#  [1] 3 4 
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
