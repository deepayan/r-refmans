<!DOCTYPE html><html><head><title>Help for package StratigrapheR</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {StratigrapheR}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#as.lim'><p>Create / Check / Manipulate lim objects</p></a></li>
<li><a href='#bedtext'><p>Writes the names of the beds in a litholog</p></a></li>
<li><a href='#blackSet'><p>Sets the plot environment to draw a long vertical data set</p></a></li>
<li><a href='#casing'><p>Finds values in a vector directly above and below a number</p></a></li>
<li><a href='#centresvg'><p>Draws a pointsvg object around a given point</p></a></li>
<li><a href='#changejoint'><p>Change the dimensions of bedding joints</p></a></li>
<li><a href='#changesvg'><p>Changes a pointsvg object</p></a></li>
<li><a href='#clipsvg'><p>Clips a standardised pointsvg object into a given frame</p></a></li>
<li><a href='#collection'><p>Create a list of symbols</p></a></li>
<li><a href='#collections'><p>Collections of symbols</p></a></li>
<li><a href='#convert'><p>Converts x values having an index into n values defined by the same</p>
y index</a></li>
<li><a href='#convertAxis'><p>Converts the axis following a given formula</p></a></li>
<li><a href='#dipfix'><p>Fix Dip</p></a></li>
<li><a href='#divisor'><p>Greatest Common Rational Divisor</p></a></li>
<li><a href='#earinc'><p>Recalculates inclination in equal area projection</p></a></li>
<li><a href='#earnet'><p>Draws an equal area stereonet</p></a></li>
<li><a href='#earplanes'><p>Draws planes on an equal area stereonet</p></a></li>
<li><a href='#earpoints'><p>Draws points on an equal area stereonet</p></a></li>
<li><a href='#encase'><p>Encases two numbers between multiples of a given number</p></a></li>
<li><a href='#encircle'><p>Draws circles</p></a></li>
<li><a href='#enlarge'><p>Expands the TRUE values of a T/F vector to their nth neighbours</p></a></li>
<li><a href='#every_nth'><p>Suppresses every n th element of a vector</p></a></li>
<li><a href='#flip.lim'><p>Inverts the intervals</p></a></li>
<li><a href='#fmean'><p>Fischer mean</p></a></li>
<li><a href='#fmod'><p>Universal remainder function</p></a></li>
<li><a href='#folder'><p>Creates a new folder where wanted if it does not exist yet</p></a></li>
<li><a href='#formFunction'><p>Converts a formula into a function</p></a></li>
<li><a href='#framesvg'><p>Draws a standardised pointsvg object into a given frame</p></a></li>
<li><a href='#greySet'><p>Sets the plot environment to draw a long vertical data set</p></a></li>
<li><a href='#homogenise'><p>Homogenise a list</p></a></li>
<li><a href='#ignore'><p>Ignores useless objects</p></a></li>
<li><a href='#in.lim'><p>Finds the intervals encompassing values</p></a></li>
<li><a href='#in.window'><p>Irregular windowing</p></a></li>
<li><a href='#incfix'><p>Fix Inclination</p></a></li>
<li><a href='#infobar'><p>Draws rectangles with text in them</p></a></li>
<li><a href='#is.clockwise'><p>Identify whether the points of a polygon are ordered clockwise</p></a></li>
<li><a href='#is.joint'><p>Check (bedding) joint objects</p></a></li>
<li><a href='#leftlog'><p>Finds bed intervals in a &quot;litholog()&quot;-like data frame</p></a></li>
<li><a href='#litholog'><p>Create/check lithologs</p></a></li>
<li><a href='#memento'><p>Remembers and outputs the result of a slow function</p></a></li>
<li><a href='#merge_list'><p>Method for merging lists by name</p></a></li>
<li><a href='#mid.lim'><p>Provides mid-points intervals in an ordered vector</p></a></li>
<li><a href='#minorAxis'><p>Adds an axis with minor ticks to a plot</p></a></li>
<li><a href='#minorAxisTicks'><p>Compute Pretty Minor Axis Tick Scales</p></a></li>
<li><a href='#multigons'><p>Draws several polygons</p></a></li>
<li><a href='#multilines'><p>Draws several lines</p></a></li>
<li><a href='#neatPick'><p>Interactive user modification of the arguments of a repeated function</p></a></li>
<li><a href='#neatPicked'><p>Runs neatPick without user input</p></a></li>
<li><a href='#nlegend'><p>New legend element</p></a></li>
<li><a href='#nset'><p>Find indexes for n identical elements</p></a></li>
<li><a href='#octapos'><p>Identify points in a polygon in reference to an octagon</p></a></li>
<li><a href='#octashift'><p>Shifts the order of polygon points</p></a></li>
<li><a href='#outliner'><p>Find the points of a litholog that are along a given vertical line</p></a></li>
<li><a href='#pdfDisplay'><p>Generates PDF and SVG figures</p></a></li>
<li><a href='#pkgfind'><p>Find a specific pattern in the code of functions in a package</p></a></li>
<li><a href='#placesvg'><p>Draws a pointsvg object</p></a></li>
<li><a href='#planepoints'><p>Describes planes by points</p></a></li>
<li><a href='#pointsvg'><p>Converts line, rect, polygon and polyline class SVG objects into</p>
data frames</a></li>
<li><a href='#profiler'><p>Extract the profile of a litholog</p></a></li>
<li><a href='#rebound'><p>Simplifies boundary indicators for lim objects</p></a></li>
<li><a href='#repitch'><p>Converts pitch into declination and inclination</p></a></li>
<li><a href='#reposition'><p>Core correction</p></a></li>
<li><a href='#restore'><p>Plane correction</p></a></li>
<li><a href='#rmatrix'><p>Rotation matrix</p></a></li>
<li><a href='#rotate'><p>Spherical rotation around fixed axes</p></a></li>
<li><a href='#seq_log'><p>Gives the repartition of values for a log 10 scale between a given interval</p></a></li>
<li><a href='#seq_mult'><p>Sequence ordered by multiple</p></a></li>
<li><a href='#shift'><p>Circular shift</p></a></li>
<li><a href='#simp.lim'><p>Joins and orders adjacent or overlapping lim objects of same ID</p></a></li>
<li><a href='#sinpoint'><p>Gives a table of equally sampled points following a sinusoidal function</p></a></li>
<li><a href='#strat.mean'><p>Extrapolate and intrapolate tie points</p></a></li>
<li><a href='#strat.repair'><p>Remove instantaneous deposits and add thickness in hiatuses</p></a></li>
<li><a href='#strat.var'><p>Compute the realtive thickness variations of sections</p></a></li>
<li><a href='#StratigrapheR'><p>StratigrapheR: integrated stratigraphy for R</p></a></li>
<li><a href='#StratigrapheR.examples'><p>Data for examples</p></a></li>
<li><a href='#symbology'><p>Draws the symbols of a collection</p></a></li>
<li><a href='#tie.lim'><p>Discretises lim objects</p></a></li>
<li><a href='#trace.lim'><p>Visualize lim objects</p></a></li>
<li><a href='#transphere'><p>Convertion between declinaison/inclination/intensity and cartesian</p>
coordinates</a></li>
<li><a href='#weld'><p>Combines segments with &quot;litholog()&quot;-like data frame</p></a></li>
<li><a href='#weldjoint'><p>Changes boundaries segments in basic lithologs</p></a></li>
<li><a href='#weldlog'><p>Changes boundaries segments in basic lithologs</p></a></li>
<li><a href='#weldprofile'><p>Changes profiles in basic lithologs</p></a></li>
<li><a href='#whiteSet'><p>Sets the plot environment to draw a long data set</p></a></li>
<li><a href='#ylink'><p>Draws connection lines to connect two points in y</p></a></li>
<li><a href='#zijderveld'><p>Draws a Zijderveld plot</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Integrated Stratigraphy</td>
</tr>
<tr>
<td>Version:</td>
<td>1.3.1</td>
</tr>
<tr>
<td>Date:</td>
<td>2023-07-04</td>
</tr>
<tr>
<td>Author:</td>
<td>Sebastien Wouters [aut, cre], Adam D. Smith [ctb]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Sebastien Wouters &lt;wouterseb@gmail.com&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Includes bases for litholog generation: graphical functions
    based on R base graphics, interval management functions and svg importation 
    functions among others. Also include stereographic projection functions, 
    and other functions made to deal with large datasets while keeping options
    to get into the details of the data.
    When using for publication please cite 
    Sebastien Wouters, Anne-Christine Da Silva, Frederic Boulvain and 
    Xavier Devleeschouwer, 2021. The R Journal 13:2, 153-178.
    The palaeomagnetism functions are based on:
    Tauxe, L., 2010. Essentials of Paleomagnetism. University of California 
    Press. <a href="https://earthref.org/MagIC/books/Tauxe/Essentials/">https://earthref.org/MagIC/books/Tauxe/Essentials/</a>;
    Allmendinger, R. W., Cardozo, N. C., and Fisher, D., 2013, Structural 
    Geology Algorithms: Vectors &amp; Tensors: Cambridge, England, Cambridge
    University Press, 289 pp.;
    Cardozo, N., and Allmendinger, R. W., 2013, Spherical projections
    with OSXStereonet: Computers &amp; Geosciences, v. 51, no. 0, p. 193 - 205,
    &lt;<a href="https://doi.org/10.1016%2Fj.cageo.2012.07.021">doi:10.1016/j.cageo.2012.07.021</a>&gt;.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 4.0.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>graphics, grDevices, XML, stats, utils, dplyr (&ge; 1.0.0),
stringr, shiny, diagram, reshape</td>
</tr>
<tr>
<td>Suggests:</td>
<td>astrochron, RFOC, plyr</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-07-04 12:38:03 UTC; User</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-07-06 00:14:06 UTC</td>
</tr>
</table>
<hr>
<h2 id='as.lim'>Create / Check / Manipulate lim objects</h2><span id='topic+as.lim'></span><span id='topic+is.lim'></span><span id='topic+are.lim.nonunique'></span><span id='topic+are.lim.nonadjacent'></span><span id='topic+are.lim.distinct'></span><span id='topic+are.lim.ordered'></span><span id='topic+order.lim'></span>

<h3>Description</h3>

<p>Functions to create and check limits of intervals (what
we define here as a 'lim' object), with control of specified properties.
Basically we define an interval by its left and right boundaries, by an id
and by a rule of boundary inclusion.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>as.lim(lim = NULL, l = NULL, r = NULL, id = 1L, b = "[]")

is.lim(lim = NULL, l = NULL, r = NULL, id = 1L, b = "[]")

are.lim.nonunique(lim = NULL, l = NULL, r = NULL, check.lim = TRUE)

are.lim.nonadjacent(lim = NULL, l = NULL, r = NULL, b = "[]", check.lim = TRUE)

are.lim.distinct(lim = NULL, l = NULL, r = NULL, check.lim = TRUE)

are.lim.ordered(
  lim = NULL,
  l = NULL,
  r = NULL,
  id = 1L,
  decreasingly = FALSE,
  dependently = FALSE,
  check.lim = TRUE
)

order.lim(
  lim = NULL,
  l = NULL,
  r = NULL,
  id = 1L,
  b = "[]",
  decreasingly = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="as.lim_+3A_lim">lim</code></td>
<td>
<p>a list of n left (1st element) and n right (2ndt element)
interval limits, of n interval IDs, and of n interval boundary rules (e.g.
&quot;[]&quot;).</p>
</td></tr>
<tr><td><code id="as.lim_+3A_l">l</code></td>
<td>
<p>the left interval limits (numerical vector of length n).</p>
</td></tr>
<tr><td><code id="as.lim_+3A_r">r</code></td>
<td>
<p>the right interval limits (numerical vector of length n).</p>
</td></tr>
<tr><td><code id="as.lim_+3A_id">id</code></td>
<td>
<p>the interval IDs (numerical or character vector of length n,
the default is 1 for each interval). They can be similar for different
intervals.</p>
</td></tr>
<tr><td><code id="as.lim_+3A_b">b</code></td>
<td>
<p>the interval boundaries rules: &quot;[]&quot;
(or &quot;closed&quot;) to include both boundaries points, &quot;][&quot; (or &quot;()&quot; and &quot;open&quot;) to
exclude both boundary points, &quot;[[&quot; (or &quot;[)&quot;,&quot;right-open&quot; and&quot;left-closed&quot;) to
include only the left boundary point, and &quot;]]&quot; (or &quot;(]&quot;, &quot;left-open&quot;,
&quot;right-closed&quot;) to include only the right boundary point. The notation is
simplified to &quot;[]&quot;, &quot;[[&quot;, &quot;]]&quot; and &quot;][&quot; only.</p>
</td></tr>
<tr><td><code id="as.lim_+3A_check.lim">check.lim</code></td>
<td>
<p>whether to check if the object is a lim object.</p>
</td></tr>
<tr><td><code id="as.lim_+3A_decreasingly">decreasingly</code></td>
<td>
<p>whether the order to check for or to set is decreasing.</p>
</td></tr>
<tr><td><code id="as.lim_+3A_dependently">dependently</code></td>
<td>
<p>whether the intervals themselves should be ordered
relatively to the other.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>as.lim</code>: creates a lim object
</p>
<p><code>is.lim</code>: checks if arguments qualify as a lim object
</p>
<p><code>are.lim.nonunique</code>: checks if there are no intervals of identical l and
r
</p>
<p><code>are.lim.nonadjacent</code>: checks if there are no pairs of intervals having
at least one similar boundary
</p>
<p><code>are.lim.distinct</code>: checks if the intervals are not overlapping
</p>
<p><code>are.lim.ordered</code>: checks if the intervals are ordered (in l and r, and
if dependently is TRUE, relative to the other intervals of same id)
</p>
<p><code>order.lim</code>: orders l and r parts of the intervals (use <code>simp.lim</code>
for more advanced ordering)
</p>


<h3>See Also</h3>

<p>To find which values are in which interval: <code><a href="#topic+in.lim">in.lim</a></code>
</p>
<p>To simplify intervals by merging overlapping parts: <code><a href="#topic+simp.lim">simp.lim</a></code>
</p>
<p>To extract the part outside of intervals: <code><a href="#topic+flip.lim">flip.lim</a></code>
</p>
<p>To make intervals with boundaries in between given values:
<code><a href="#topic+mid.lim">mid.lim</a></code>
</p>
<p>To discretise intervals: <code><a href="#topic+tie.lim">tie.lim</a></code>
</p>
<p>To simplify boundary rules into &quot;[]&quot;, &quot;[[&quot;, &quot;]]&quot; and &quot;][&quot;:
<code><a href="#topic+rebound">rebound</a></code>
</p>
<p>To plot interval data as lines: <code><a href="#topic+trace.lim">trace.lim</a></code> and
<code><a href="#topic+plot_lim">plot_lim</a></code>
</p>
<p>To plot interval data as rectangles: <code><a href="#topic+infobar">infobar</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>example &lt;- as.lim(l = c(0,1,2), r = c(0.5,2.1,2.5), id = "I")

is.lim(lim = example)

are.lim.nonunique(l = c(0,1,2),r = c(0.5,1.5,2.5))

are.lim.nonunique(l = c(0,1,2),r = c(0.5,1.5,2))

are.lim.nonadjacent(l = c(0,1,2),r = c(0.5,1.5,2.5))

are.lim.nonadjacent(l = c(0,1,1.5),r = c(0.5,1.5,2))

are.lim.ordered(l = c(0,1,2),r = c(0.5,1.5,2.5))

are.lim.ordered(l = c(0,1,2.5),r = c(0.5,1.5,2))

are.lim.ordered(l = c(0,1,2),r = c(0.5,1.5,2.5),dependently = TRUE)

are.lim.ordered(l = c(0,2,1),r = c(0.5,2.5,1.5),dependently = TRUE)

are.lim.distinct(l = c(0,1,2),r = c(0.5,1.5,2.5))

are.lim.distinct(l = c(0,1,2),r = c(0.5,3.5,2.5))

order.lim(l = c(0,6,4,6,50), r = c(1,5,6,9,8),
          b = c("[[", "]]", "[[", "]]", "[["))

</code></pre>

<hr>
<h2 id='bedtext'>Writes the names of the beds in a litholog</h2><span id='topic+bedtext'></span>

<h3>Description</h3>

<p>Writes the names of the beds in a litholog. You can either place
them at the centre of the beds or in their upper and lower part. You can
also define a thickness below which the name won't be written, to avoid
excessive text crowding the plot.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bedtext(
  labels,
  l,
  r,
  x = 0.2,
  arg = list(cex = 1),
  adj = c(0.5, 0.5),
  ymin = NA,
  edge = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bedtext_+3A_labels">labels</code></td>
<td>
<p>the name of each bed</p>
</td></tr>
<tr><td><code id="bedtext_+3A_l">l</code></td>
<td>
<p>a vector of n left y (or dt, i.e. depth or time) interval
limits for each bed</p>
</td></tr>
<tr><td><code id="bedtext_+3A_r">r</code></td>
<td>
<p>a vector of n right y (or dt, i.e. depth or time) interval
limits for each bed</p>
</td></tr>
<tr><td><code id="bedtext_+3A_x">x</code></td>
<td>
<p>the position where to write the text (0.2 by default)</p>
</td></tr>
<tr><td><code id="bedtext_+3A_arg">arg</code></td>
<td>
<p>a list of arguments to feed text(). Go see ?text to know
which arguments can be provided. See ?merge.list for further information.</p>
</td></tr>
<tr><td><code id="bedtext_+3A_adj">adj</code></td>
<td>
<p>one or two values in [0, 1] which specify the x (and
optionally y) adjustment of the labels. c(0.5,0.5) is the default.</p>
</td></tr>
<tr><td><code id="bedtext_+3A_ymin">ymin</code></td>
<td>
<p>minimum thickness of the bed to write its name (if NA,
a default value is calculated, but user input is best)</p>
</td></tr>
<tr><td><code id="bedtext_+3A_edge">edge</code></td>
<td>
<p>whether to put the bed name at the edge of the beds (T)
or in the center of the beds (F, is the default)</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+litholog">litholog</a></code> obvisously
</p>
<p>if your boundaries have to be recalculated: <code><a href="#topic+leftlog">leftlog</a></code>
</p>
<p>other functions complementing litholog: <code><a href="#topic+infobar">infobar</a></code> and
<code><a href="#topic+ylink">ylink</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>l  &lt;- c(0,4,5,8)
r  &lt;- c(4,5,8,16)

x   &lt;- c(4,5,3,4)
i &lt;- c("B1","B2","B3","B4")

test &lt;- litholog(l, r, x, i)

whiteSet(xlim = c(0,6), ylim = c(-10,30))

multigons(test$i, test$xy, test$dt, col = c(NA, "black", "grey","NA"))

bedtext(labels = i, r = r, l = l, edge = TRUE, x = 0.5,
        arg = list(col = c("black", "white", "white", "red")))

</code></pre>

<hr>
<h2 id='blackSet'>Sets the plot environment to draw a long vertical data set</h2><span id='topic+blackSet'></span>

<h3>Description</h3>

<p>Sets the plot environment to draw a long dataset. It provides
lines as supplementary scale, and axes with major and minor ticks.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>blackSet(
  xlim,
  ylim,
  xtick = NA,
  ytick = NA,
  nx = 1,
  ny = 1,
  xaxs = "i",
  yaxs = "i",
  xarg = list(tick.ratio = 0.5),
  yarg = list(tick.ratio = 0.5, las = 1),
  v = T,
  abbr = "",
  skip = 0,
  targ = list(col = "black", lwd = 2),
  sarg = list(lty = 2, col = "black")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="blackSet_+3A_xlim">xlim</code>, <code id="blackSet_+3A_ylim">ylim</code></td>
<td>
<p>the x and y limits (e.g. xlim = c(-1,1))</p>
</td></tr>
<tr><td><code id="blackSet_+3A_xtick">xtick</code>, <code id="blackSet_+3A_ytick">ytick</code></td>
<td>
<p>the interval between each major ticks for x and y</p>
</td></tr>
<tr><td><code id="blackSet_+3A_nx">nx</code>, <code id="blackSet_+3A_ny">ny</code></td>
<td>
<p>the number of intervals between major ticks to be
divided by minor ticks in the x and y axes</p>
</td></tr>
<tr><td><code id="blackSet_+3A_xaxs">xaxs</code>, <code id="blackSet_+3A_yaxs">yaxs</code></td>
<td>
<p>The style of axis interval calculation to be used
for the x and y axes. By default it is &quot;i&quot; (internal): it just finds an axis
with pretty labels that fits within the original data range. You can also set
it to &quot;r&quot; (regular): it first extends the data range by 4 percent at each end
and then finds an axis with pretty labels that fits within the extended
range. See ?par for further explanation</p>
</td></tr>
<tr><td><code id="blackSet_+3A_xarg">xarg</code>, <code id="blackSet_+3A_yarg">yarg</code></td>
<td>
<p>a list of arguments to feed to minorAxis() for the
x and y axes. See the ?minorAxis help page for the possible arguments. See
?merge_list for further information.</p>
</td></tr>
<tr><td><code id="blackSet_+3A_v">v</code></td>
<td>
<p>whether the lines are vertical</p>
</td></tr>
<tr><td><code id="blackSet_+3A_abbr">abbr</code></td>
<td>
<p>text to be repeated on the lines at each major tick</p>
</td></tr>
<tr><td><code id="blackSet_+3A_skip">skip</code></td>
<td>
<p>number of text redundancies to be skipped</p>
</td></tr>
<tr><td><code id="blackSet_+3A_targ">targ</code>, <code id="blackSet_+3A_sarg">sarg</code></td>
<td>
<p>a list of arguments to feed to text() and segments()
respectively. If set to NULL, does not add the corresponding element.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A plotting environment to draw a long data set
</p>


<h3>See Also</h3>

<p>Similar functions: <code><a href="#topic+whiteSet">whiteSet</a></code> and <code><a href="#topic+greySet">greySet</a></code>
</p>
<p>To create axes with major and minor ticks: <code><a href="#topic+minorAxis">minorAxis</a></code>
</p>
<p>To print a plot in pdf: <code><a href="#topic+pdfDisplay">pdfDisplay</a></code>
</p>
<p>To automatically determine pretty interval limits: <code><a href="#topic+encase">encase</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>y &lt;- c(0,11,19,33)
x &lt;- c(1,2,2.5,4)

a &lt;- min(y)
b &lt;- max(y)

f&lt;- encase(a-1,b,5)

blackSet(c(0,4),f, ytick = 10, ny = 10, skip = 1)

points(x, y, pch=19)
</code></pre>

<hr>
<h2 id='casing'>Finds values in a vector directly above and below a number</h2><span id='topic+casing'></span>

<h3>Description</h3>

<p>Finds values in a vector directly above and below a number
</p>


<h3>Usage</h3>

<pre><code class='language-R'>casing(x, into)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="casing_+3A_x">x</code></td>
<td>
<p>a number</p>
</td></tr>
<tr><td><code id="casing_+3A_into">into</code></td>
<td>
<p>a vector where to find the values directly above and
below x</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a vector of the values of &quot;into&quot; vector directly above and below x
respectively
</p>


<h3>See Also</h3>

<p>Similar function : <code><a href="#topic+encase">encase</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>casing(0.21,c(0.3,0.4,0.1,0.2))

</code></pre>

<hr>
<h2 id='centresvg'>Draws a pointsvg object around a given point</h2><span id='topic+centresvg'></span><span id='topic+centersvg'></span>

<h3>Description</h3>

<p>Draws a svg object imported as data frame using
<code><a href="#topic+pointsvg">pointsvg</a></code> around a given point.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>centresvg(
  object,
  x,
  y,
  xfac = 1,
  yfac = 1,
  xadj = 0,
  yadj = 0,
  forget = NULL,
  front = NULL,
  back = NULL,
  standard = FALSE,
  keep.ratio = FALSE,
  col = NA,
  border = "black",
  density = NA,
  angle = 45,
  lty = par("lty"),
  lwd = par("lwd"),
  scol = border,
  slty = lty,
  slwd = lwd,
  plot = TRUE,
  output = FALSE
)

centersvg(
  object,
  x,
  y,
  xfac = 1,
  yfac = 1,
  xadj = 0,
  yadj = 0,
  forget = NULL,
  front = NULL,
  back = NULL,
  standard = FALSE,
  keep.ratio = FALSE,
  col = NA,
  border = "black",
  density = NA,
  angle = 45,
  lty = par("lty"),
  lwd = par("lwd"),
  scol = border,
  slty = lty,
  slwd = lwd,
  plot = TRUE,
  output = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="centresvg_+3A_object">object</code></td>
<td>
<p>a pointsvg object (svg object imported as data frame
using <code><a href="#topic+pointsvg">pointsvg</a></code>).</p>
</td></tr>
<tr><td><code id="centresvg_+3A_x">x</code>, <code id="centresvg_+3A_y">y</code></td>
<td>
<p>numeric vectors of coordinates where the object should be
drawn.</p>
</td></tr>
<tr><td><code id="centresvg_+3A_xfac">xfac</code></td>
<td>
<p>the x size factor.</p>
</td></tr>
<tr><td><code id="centresvg_+3A_yfac">yfac</code></td>
<td>
<p>the y size factor.</p>
</td></tr>
<tr><td><code id="centresvg_+3A_xadj">xadj</code></td>
<td>
<p>value specifying the x adjustment of the drawing.</p>
</td></tr>
<tr><td><code id="centresvg_+3A_yadj">yadj</code></td>
<td>
<p>value specifying the y adjustment of the drawing.</p>
</td></tr>
<tr><td><code id="centresvg_+3A_forget">forget</code></td>
<td>
<p>the elements that should be discarded, by their id
or index (i.e. name or number of appearance).</p>
</td></tr>
<tr><td><code id="centresvg_+3A_front">front</code>, <code id="centresvg_+3A_back">back</code></td>
<td>
<p>the elements to be put in front and back position,
by their id or index (i.e. name or number of appearance). By default the
order is the one of the original .svg file.</p>
</td></tr>
<tr><td><code id="centresvg_+3A_standard">standard</code></td>
<td>
<p>whether to standardise (centre to (0,0), rescale so
that extreme points are at -1 and 1) or not (T or F)</p>
</td></tr>
<tr><td><code id="centresvg_+3A_keep.ratio">keep.ratio</code></td>
<td>
<p>if the object is to be  standardised, whether to
keep the x/y ratio (T or F)</p>
</td></tr>
<tr><td><code id="centresvg_+3A_col">col</code></td>
<td>
<p>the polygones background color. If density is specified with
a positive value this gives the color of the shading lines.</p>
</td></tr>
<tr><td><code id="centresvg_+3A_border">border</code></td>
<td>
<p>the lines color.</p>
</td></tr>
<tr><td><code id="centresvg_+3A_density">density</code></td>
<td>
<p>the density of shading lines, in lines per inch. The
default value of NULL means that no shading lines are drawn.</p>
</td></tr>
<tr><td><code id="centresvg_+3A_angle">angle</code></td>
<td>
<p>the slope of shading lines, given as an angle in degrees
(counter-clockwise)</p>
</td></tr>
<tr><td><code id="centresvg_+3A_lty">lty</code>, <code id="centresvg_+3A_lwd">lwd</code></td>
<td>
<p>the border line type and width, see ?par for details.</p>
</td></tr>
<tr><td><code id="centresvg_+3A_scol">scol</code>, <code id="centresvg_+3A_slty">slty</code>, <code id="centresvg_+3A_slwd">slwd</code></td>
<td>
<p>the colour, type and width of the shading lines.</p>
</td></tr>
<tr><td><code id="centresvg_+3A_plot">plot</code></td>
<td>
<p>whether to add to a plot</p>
</td></tr>
<tr><td><code id="centresvg_+3A_output">output</code></td>
<td>
<p>whether to output the new object coordinates</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code><a href="#topic+centresvg">centresvg</a></code> and
<code><a href="#topic+framesvg">framesvg</a></code> have a lot of similarities with the
<code><a href="#topic+multigons">multigons</a></code> function: the graphical parameters are mostly
identical. However there is a strong distinction between the -svg functions
and multigons: when providing several graphical arguments, multigons will
attribute them to each polygon, whereas the .svg functions will use them for
each repetition of the .svg object. Using the latter, the graphical
parameters will be applied to all the elements of a drawing. If you want
a finer personalisation you have to use multigons and multilines (or an
hybrid of the two, yet to be coded).
</p>


<h3>See Also</h3>

<p>Similar functions: <code><a href="#topic+framesvg">framesvg</a></code> and <code><a href="#topic+placesvg">placesvg</a></code>
</p>
<p>Change the drawing: <code><a href="#topic+changesvg">changesvg</a></code> and <code><a href="#topic+clipsvg">clipsvg</a></code>
</p>
<p>Uses <code><a href="#topic+ignore">ignore</a></code> to avoid drawing unnecessary objects
</p>


<h3>Examples</h3>

<pre><code class='language-R'>object &lt;- example.ammonite

plot(c(-10,10), c(-10,10), type = "n")

centresvg(object, 5, 5, xfac = 2, yfac = 2,lty = 1,density = 20, angle = 45)

points(5,5,pch = 19, col = "blue")

</code></pre>

<hr>
<h2 id='changejoint'>Change the dimensions of bedding joints</h2><span id='topic+changejoint'></span>

<h3>Description</h3>

<p>Change the dimensions of bedding joints
</p>


<h3>Usage</h3>

<pre><code class='language-R'>changejoint(
  joint,
  yinv = F,
  xinv = F,
  yleft = NA,
  yright = NA,
  ymin = NA,
  ymax = NA,
  xmin = NA,
  xmax = NA
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="changejoint_+3A_joint">joint</code></td>
<td>
<p>the bedding joint to be modified</p>
</td></tr>
<tr><td><code id="changejoint_+3A_yinv">yinv</code>, <code id="changejoint_+3A_xinv">xinv</code></td>
<td>
<p>whether to inverse the plotting for x and y values (T or F)</p>
</td></tr>
<tr><td><code id="changejoint_+3A_yleft">yleft</code>, <code id="changejoint_+3A_yright">yright</code></td>
<td>
<p>the depth/height/time value for the extreme point at the
right or left of the joint (yleft overruns yright, which overruns ymin and
ymax)</p>
</td></tr>
<tr><td><code id="changejoint_+3A_ymin">ymin</code>, <code id="changejoint_+3A_ymax">ymax</code></td>
<td>
<p>the extreme values for the y axis (in case of conflict with
yleft and/or yright, defaults to the smallest exaggeration)</p>
</td></tr>
<tr><td><code id="changejoint_+3A_xmin">xmin</code>, <code id="changejoint_+3A_xmax">xmax</code></td>
<td>
<p>the extreme values for the x axis</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'># Create an initial litholog ----

l &lt;- c(-2,-1,0,1,2)
r &lt;- c(-1,0,1,2,3)
h   &lt;- c(4,3,4,3,4)
i &lt;- c("B1","B2","B3","B4","B5")
log  &lt;- litholog(l, r, h, i)

# Get a custom bedding joint to specific dimensions using changejoint() ----

liq &lt;- changejoint(oufti99$liquefaction,
                   yleft = 0, ymax = 0.3,
                   xmin = 1, xmax = 2)

nlog &lt;- weldlog(log, dt = 0, seg = list(liq = liq), j = c("liq"))

# Plots for visualisation ----

plot.new()
plot.window(xlim = c(0,5), ylim = c(-2,3))

axis(1)
axis(2)

multigons(nlog$i, nlog$xy, nlog$dt)

</code></pre>

<hr>
<h2 id='changesvg'>Changes a pointsvg object</h2><span id='topic+changesvg'></span>

<h3>Description</h3>

<p>Changes a svg object imported as data frame using
<code><a href="#topic+pointsvg">pointsvg</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>changesvg(
  object,
  forget = NULL,
  front = NULL,
  back = NULL,
  standard = FALSE,
  keep.ratio = F,
  round = FALSE,
  xdigits = 4,
  ydigits = 4,
  xinverse = FALSE,
  yinverse = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="changesvg_+3A_object">object</code></td>
<td>
<p>a pointsvg object (svg object imported as data frame
using <code><a href="#topic+pointsvg">pointsvg</a></code>).</p>
</td></tr>
<tr><td><code id="changesvg_+3A_forget">forget</code></td>
<td>
<p>the elements that should be discarded, by their id
or index (i.e. name or number of appearance).</p>
</td></tr>
<tr><td><code id="changesvg_+3A_front">front</code>, <code id="changesvg_+3A_back">back</code></td>
<td>
<p>the elements to be put in front and back position,
by their id or index (i.e. name or number of appearance). By default the
order is the one of the original .svg file.</p>
</td></tr>
<tr><td><code id="changesvg_+3A_standard">standard</code></td>
<td>
<p>whether to standardise (centre to (0,0), rescale so
that extreme points are at -1 and 1) or not (T or F)</p>
</td></tr>
<tr><td><code id="changesvg_+3A_keep.ratio">keep.ratio</code></td>
<td>
<p>if the object is to be  standardised, whether to
keep the x/y ratio (T or F)</p>
</td></tr>
<tr><td><code id="changesvg_+3A_round">round</code></td>
<td>
<p>whether to round the coordinates or not (T or F)</p>
</td></tr>
<tr><td><code id="changesvg_+3A_xdigits">xdigits</code></td>
<td>
<p>the number of digits after the decimal to round to for
x values</p>
</td></tr>
<tr><td><code id="changesvg_+3A_ydigits">ydigits</code></td>
<td>
<p>the number of digits after the decimal to round to for
y values</p>
</td></tr>
<tr><td><code id="changesvg_+3A_xinverse">xinverse</code></td>
<td>
<p>whether to inverse the plotting for x values (T or F)</p>
</td></tr>
<tr><td><code id="changesvg_+3A_yinverse">yinverse</code></td>
<td>
<p>whether to inverse the plotting for y values (T or F)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data.frame with x and y coordinates, ids for each object, and a
type, either line (L) or polygon (P)
</p>


<h3>See Also</h3>

<p>Importing .svg objects: <code><a href="#topic+pointsvg">pointsvg</a></code>
</p>
<p>Plot the drawing and change the coordinates :<code><a href="#topic+placesvg">placesvg</a></code>,
<code><a href="#topic+centresvg">centresvg</a></code> and <code><a href="#topic+framesvg">framesvg</a></code>
</p>
<p>Clip the drawing: <code><a href="#topic+clipsvg">clipsvg</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>object1 &lt;- example.lense

opar &lt;- par("mfrow")
par(mfrow = c(1,3))

plot(c(-1,1), c(-1,1), type = "n")
placesvg(object1)

plot(c(-1,1), c(-1,1), type = "n")
object2 &lt;- changesvg(object1, forget = 1)
placesvg(object2)

plot(c(-1,1), c(-1,1), type = "n")
object3 &lt;- changesvg(object1, forget = "P1", standard = TRUE)
placesvg(object3)

par(mfrow = opar)

</code></pre>

<hr>
<h2 id='clipsvg'>Clips a standardised pointsvg object into a given frame</h2><span id='topic+clipsvg'></span>

<h3>Description</h3>

<p>Clips a svg object imported as data frame using
<code><a href="#topic+pointsvg">pointsvg</a></code> if outside of a given frame. In other words it removes
the elements of the svg that are entirely outside a given area.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>clipsvg(
  object,
  xmin = -Inf,
  xmax = +Inf,
  ymin = -Inf,
  ymax = +Inf,
  by.entity = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="clipsvg_+3A_object">object</code></td>
<td>
<p>a pointsvg object (svg object imported as data frame
using <code><a href="#topic+pointsvg">pointsvg</a></code>).</p>
</td></tr>
<tr><td><code id="clipsvg_+3A_xmin">xmin</code>, <code id="clipsvg_+3A_xmax">xmax</code>, <code id="clipsvg_+3A_ymin">ymin</code>, <code id="clipsvg_+3A_ymax">ymax</code></td>
<td>
<p>clipping coordinates, default to +-Inf (no
clipping)</p>
</td></tr>
<tr><td><code id="clipsvg_+3A_by.entity">by.entity</code></td>
<td>
<p>whether to remove all entities having points out of
the clipping zone (TRUE; default) or to only remove the points out it (FALSE,
and to use on lines for better result)</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+centresvg">centresvg</a></code>, <code><a href="#topic+changesvg">changesvg</a></code>,
<code><a href="#topic+framesvg">framesvg</a></code> and <code><a href="#topic+pointsvg">pointsvg</a></code>
</p>
<p>If you want to also keep the elements that are only partly inside the
clipping region: <code><a href="#topic+ignore">ignore</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Simple use

object &lt;- example.ammonite

plot(c(-1,1), c(-1,1), type = "n", ylab = "y", xlab = "x")

res.object &lt;- clipsvg(object, xmax = 0.5)

abline(v = 0.5)

centresvg(object, 0, 0, lty = 2)
centresvg(res.object, 0, 0, col = "red", lwd = 2)

# Advanced used

object2 &lt;- example.breccia

plot(c(-1,3), c(-1,11), type = "n", ylab = "y", xlab = "x")

object2replicated &lt;- framesvg(object2, 0,2,c(0,4,8), c(2,6,10),
                              output = TRUE)

object2clipped    &lt;- clipsvg(object2replicated, 0, 1.7, 1, 9)

rect(0, 1, 1.7, 9, border = "red")

placesvg(object2clipped, border = "red", lwd = 2)

</code></pre>

<hr>
<h2 id='collection'>Create a list of symbols</h2><span id='topic+collection'></span><span id='topic+is.collection'></span><span id='topic+plot_collection'></span>

<h3>Description</h3>

<p>From a file containing SVG files, extracts all the SVGs into
a list of symbols that can be used in lithologs.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>collection(dir = getwd())

is.collection(collection)

plot_collection(
  collection,
  col = "grey90",
  cex = 2,
  as.pdf = T,
  name = "symbols",
  ext = ".pdf",
  dir = tempdir(),
  width = 7,
  height = 0.8 * width/5.6,
  track = T,
  openfile = T
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="collection_+3A_dir">dir</code></td>
<td>
<p>the file where the document will be saved (by default a temporary
directory, tempdir())</p>
</td></tr>
<tr><td><code id="collection_+3A_collection">collection</code></td>
<td>
<p>an object similar to the output of collection()</p>
</td></tr>
<tr><td><code id="collection_+3A_col">col</code></td>
<td>
<p>the background colour of the symbols</p>
</td></tr>
<tr><td><code id="collection_+3A_cex">cex</code></td>
<td>
<p>the size of the text in the plot</p>
</td></tr>
<tr><td><code id="collection_+3A_as.pdf">as.pdf</code></td>
<td>
<p>whether to output the plot as a pdf</p>
</td></tr>
<tr><td><code id="collection_+3A_name">name</code></td>
<td>
<p>the name of the pdf document to plot the symbols of a collection</p>
</td></tr>
<tr><td><code id="collection_+3A_ext">ext</code></td>
<td>
<p>the extension of the document: &quot;.pdf&quot; by default, but
&quot;.svg&quot; works also.</p>
</td></tr>
<tr><td><code id="collection_+3A_width">width</code></td>
<td>
<p>the width of the drawing area (in inches)</p>
</td></tr>
<tr><td><code id="collection_+3A_height">height</code></td>
<td>
<p>the height of the drawing area (in inches)</p>
</td></tr>
<tr><td><code id="collection_+3A_track">track</code></td>
<td>
<p>whether to generate different files for each rerun of pdfDisplay
with identical 'name'. The name will be followed by '_(i)' where i is the
version number. With this you avoid closing your pdf file at each rerun if
your pdf reader is not able to deal with (to my knowledge only SumatraPDF is
able)</p>
</td></tr>
<tr><td><code id="collection_+3A_openfile">openfile</code></td>
<td>
<p>should the pdf file be opened (for the moment works
only in Windows). Use SumatraPDF as default pdf reader to be able to write
over current file</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a collection is a list of pointsvg-objects
(see <code><a href="#topic+pointsvg">pointsvg</a></code>)
</p>


<h3>Examples</h3>

<pre><code class='language-R'># To show you how to import, we first have to have a svg file to import. The
# following lines of code will create a svg in a temporary files:

# 1. Create temporary file
svg.file.directory &lt;- tempfile(pattern = "ammonite",
                               fileext = ".svg")
# 2. Write the svg in the file
writeLines(example.ammonite.svg, svg.file.directory)

print(paste("An example .svg file was created at ", svg.file.directory,
            sep = ""))

coll &lt;- collection(dirname(svg.file.directory))

is.collection(coll)

## Not run: 
plot_collection(coll, cex = 1.5)

plot_collection(oufti99, name = "Oufti99")
## End(Not run)

</code></pre>

<hr>
<h2 id='collections'>Collections of symbols</h2><span id='topic+collections'></span><span id='topic+oufti99'></span>

<h3>Description</h3>


<dl>
<dt><strong>oufti99</strong></dt><dd><p>First experimental symbol dataset, developed in
Liege University by Anne-Christine Da Silva, Michiel Arts and Sébastien
Wouters</p>
</dd>
</dl>



<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
plot_collection(oufti99, name = "Oufti99")
## End(Not run)

</code></pre>

<hr>
<h2 id='convert'>Converts x values having an index into n values defined by the same
y index</h2><span id='topic+convert'></span>

<h3>Description</h3>

<p>Converts x values having an index (of y values for instance)
into n values defined by the same index (but having possibly more values)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>convert(x, xindex, n, nindex)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="convert_+3A_x">x</code></td>
<td>
<p>a vector</p>
</td></tr>
<tr><td><code id="convert_+3A_xindex">xindex</code></td>
<td>
<p>the index for each x value (vector of same length
than x)</p>
</td></tr>
<tr><td><code id="convert_+3A_n">n</code></td>
<td>
<p>a vector of the values into which to convert the x values</p>
</td></tr>
<tr><td><code id="convert_+3A_nindex">nindex</code></td>
<td>
<p>the index for each n value (vector of same length
than n)</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>x      &lt;- c(10,20)
xindex &lt;- c(1,2)

n      &lt;- seq(0.1,1,by = 0.1)
nindex &lt;- 1:length(n)

convert(x,xindex,n,nindex)

</code></pre>

<hr>
<h2 id='convertAxis'>Converts the axis following a given formula</h2><span id='topic+convertAxis'></span>

<h3>Description</h3>

<p>Converts the axis following a given formula, and places ticks in
the new axis value
</p>


<h3>Usage</h3>

<pre><code class='language-R'>convertAxis(
  side,
  formula,
  at.maj,
  at.min = NULL,
  labels = at.maj,
  tick.ratio = 0.75,
  line = NA,
  pos = NA,
  font = NA,
  lty = "solid",
  lwd = 1,
  lwd.ticks = lwd,
  col = NULL,
  col.ticks = NULL,
  hadj = NA,
  padj = NA,
  tcl = NA,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="convertAxis_+3A_side">side</code></td>
<td>
<p>an integer specifying which side of the plot the axis is
to be drawn on. The axis is placed as follows: 1=below, 2=left, 3=above and
4=right.</p>
</td></tr>
<tr><td><code id="convertAxis_+3A_formula">formula</code></td>
<td>
<p>the formula to be converted. Should be of the form y ~ f(x)</p>
</td></tr>
<tr><td><code id="convertAxis_+3A_at.maj">at.maj</code></td>
<td>
<p>a vector of the position and labels of the major ticks</p>
</td></tr>
<tr><td><code id="convertAxis_+3A_at.min">at.min</code></td>
<td>
<p>a vector of the position of minor ticks</p>
</td></tr>
<tr><td><code id="convertAxis_+3A_labels">labels</code></td>
<td>
<p>his can either be a logical value specifying whether
(numerical) annotations are to be made at the major tickmarks, or a character
or expression vector of labels to be placed at the major tickpoints.</p>
</td></tr>
<tr><td><code id="convertAxis_+3A_tick.ratio">tick.ratio</code></td>
<td>
<p>the ratio of minor to major tick size</p>
</td></tr>
<tr><td><code id="convertAxis_+3A_line">line</code>, <code id="convertAxis_+3A_pos">pos</code>, <code id="convertAxis_+3A_font">font</code>, <code id="convertAxis_+3A_lty">lty</code>, <code id="convertAxis_+3A_lwd">lwd</code>, <code id="convertAxis_+3A_lwd.ticks">lwd.ticks</code>, <code id="convertAxis_+3A_col">col</code>, <code id="convertAxis_+3A_col.ticks">col.ticks</code>, <code id="convertAxis_+3A_hadj">hadj</code>, <code id="convertAxis_+3A_padj">padj</code>, <code id="convertAxis_+3A_tcl">tcl</code>, <code id="convertAxis_+3A_...">...</code></td>
<td>
<p>see
?axis function help page for these parameters</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+minorAxis">minorAxis</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>plot(1,1,type = "n", xlim = c(0,12), axes = FALSE ,xlab = "", ylab = "")

axis(3)

l &lt;- seq_log(10^0,10^12,divide = TRUE)

convertAxis(1,y ~ log10(x),l[[1]],l[[2]])

</code></pre>

<hr>
<h2 id='dipfix'>Fix Dip</h2><span id='topic+dipfix'></span>

<h3>Description</h3>

<p>Fix dip and strike of planes so that they fall in the correct
quadrant. The provided quadrant is the determining factor. If unavailable or
not helpful, the sign of the dip is used as determining factor.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dipfix(strike, dip, quadrant = NA, inverted = NA)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dipfix_+3A_strike">strike</code></td>
<td>
<p>strike of the data; it is the angle from the north of
the horizontal line of the plane. Corrected, its range goes from 0° to 360°.</p>
</td></tr>
<tr><td><code id="dipfix_+3A_dip">dip</code></td>
<td>
<p>dip of the data; it is the angle from the horizontal taken
on the line of the plane perpendicular to the one of the strike. In other
words it is the plane's maximum angular deviation from the horizontal.
It is positive downward, and ranges from +90° for straight down to -90° for
straight up. Dip values in [-180,-90] or/and ]90,180] indicate inversion of
the plane.</p>
</td></tr>
<tr><td><code id="dipfix_+3A_quadrant">quadrant</code></td>
<td>
<p>the quadrant where the plane dips downward. Accepted
values are NA, 'N', 'S', 'W' or 'E' (lower- or uppercase alike). Is
independant of inversion</p>
</td></tr>
<tr><td><code id="dipfix_+3A_inverted">inverted</code></td>
<td>
<p>whether the plane is upside down.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>the strike will be corrected as the orientation of the dip (i.e.
downward) minus 90°; it ranges from 0 to 360°. It is determined firstly from
the quadrant. If the quadrant is missing or not helpful (e.g. 'N' or 'S' for
a strike of 0° or 180°, 'E' or 'W' for a strike of 90° or 270°), it is
determined using the sign of the dip. Inversion will be indicated if the dip
values are in [-180,-90] or/and ]90,180], or simply if inverted = T. The
inversion does not influence the calculation of the strike, dip and quadrant:
whether the plane is upside down does not change these parameters output.
</p>


<h3>Value</h3>

<p>a list of the corrected strike, dip and quadrant
</p>


<h3>See Also</h3>

<p><code><a href="#topic+fmod">fmod</a></code>, <code><a href="#topic+incfix">incfix</a></code> and
<code><a href="#topic+transphere">transphere</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>strike   &lt;- c(-60, 180,20,0,20)
dip      &lt;- c(-60,20,-45,110,-90)
quadrant &lt;- c("N",NA,NA,NA,"E")
inverted &lt;- c(FALSE,TRUE,FALSE,TRUE,FALSE)

dipfix(strike,dip,quadrant,inverted)

dipfix(strike,dip,quadrant)

</code></pre>

<hr>
<h2 id='divisor'>Greatest Common Rational Divisor</h2><span id='topic+divisor'></span><span id='topic+is.divisor'></span>

<h3>Description</h3>

<p>Compute the Greatest Common Rational Divisor or test whether
a value is a common rational divisor of a suite of number
</p>


<h3>Usage</h3>

<pre><code class='language-R'>divisor(x, tolerance = 8, relative = T, tries = 4, speak = T)

is.divisor(x, y, tolerance = 8, relative = T, use.names = T)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="divisor_+3A_x">x</code></td>
<td>
<p>a numeric or integer vector</p>
</td></tr>
<tr><td><code id="divisor_+3A_tolerance">tolerance</code></td>
<td>
<p>the order of tolerance for errors, i.e. the number of
decimals considered as being meaningful</p>
</td></tr>
<tr><td><code id="divisor_+3A_relative">relative</code></td>
<td>
<p>whether to apply the tolerance to the x values divided by
the smallest x value (TRUE, is the default), or to the x values themselves</p>
</td></tr>
<tr><td><code id="divisor_+3A_tries">tries</code></td>
<td>
<p>the amount of iterations: each iteration tests 10^n+1 more
possibilities than the previous one. This is to optimise computation while
allowing all possibilities to be explored. Each try takes exponentialy more
time than the previous one</p>
</td></tr>
<tr><td><code id="divisor_+3A_speak">speak</code></td>
<td>
<p>whether to print a sentence at each try</p>
</td></tr>
<tr><td><code id="divisor_+3A_y">y</code></td>
<td>
<p>a numeric or integer vector of vales to be tested as divisors of x</p>
</td></tr>
<tr><td><code id="divisor_+3A_use.names">use.names</code></td>
<td>
<p>whether to use y values as names for the output</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>divisor(x = c(0.03,0.75,0.3,2,100, 0.03, 100, 0), speak = FALSE)

divisor(x = c(0.02,0.75,0.3,2,100.000002, 0.03, 100, 0), speak = FALSE)

divisor(x = c(0.02,0.75,0.3,2,100.000002, 0.03, 100, 0) * 10^-10,
        speak = FALSE)


a &lt;- c(0.02,0.75,0.3,2,100.000000002, 0.03, 100, 0)

divisor(x = a)

is.divisor(x = a, y = c(1, 0.01, 2*10^-9))

divisor(x = a, tolerance = 7, speak = FALSE)

divisor(x = a, relative = FALSE, speak = FALSE)

</code></pre>

<hr>
<h2 id='earinc'>Recalculates inclination in equal area projection</h2><span id='topic+earinc'></span>

<h3>Description</h3>

<p>Recalculates the inclination in equal area projection
</p>


<h3>Usage</h3>

<pre><code class='language-R'>earinc(inc)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="earinc_+3A_inc">inc</code></td>
<td>
<p>inclination of the data; it is the angle from the
horizontal, is positive downward, and ranges from +90° for straight down to
-90° for straight up (Tauxe, 2010).</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>earinc(20)

</code></pre>

<hr>
<h2 id='earnet'>Draws an equal area stereonet</h2><span id='topic+earnet'></span>

<h3>Description</h3>

<p>Draws Equal Area Stereo-Net. Lambert azimuthal Equal-Area
(Schmidt) from Snyder p. 185-186 (modified from RFOC package)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>earnet(
  xlim = c(-1.1, 1.1),
  ylim = c(-1.1, 1.1),
  ndiv = 10,
  col = gray(0.7),
  border = "black",
  lwd = 1,
  orientation = TRUE,
  xh = "WE",
  add = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="earnet_+3A_xlim">xlim</code>, <code id="earnet_+3A_ylim">ylim</code></td>
<td>
<p>the x and y minimal limits. The actual limits can
change to keep a x/y ratio of 1</p>
</td></tr>
<tr><td><code id="earnet_+3A_ndiv">ndiv</code></td>
<td>
<p>the number of intervals between each line crossing</p>
</td></tr>
<tr><td><code id="earnet_+3A_col">col</code></td>
<td>
<p>the colour of the net</p>
</td></tr>
<tr><td><code id="earnet_+3A_border">border</code></td>
<td>
<p>the colour of the border and crosshair</p>
</td></tr>
<tr><td><code id="earnet_+3A_lwd">lwd</code></td>
<td>
<p>the line width</p>
</td></tr>
<tr><td><code id="earnet_+3A_orientation">orientation</code></td>
<td>
<p>logical, whether to add captions indicating the
orientation of the plot.</p>
</td></tr>
<tr><td><code id="earnet_+3A_xh">xh</code></td>
<td>
<p>orientation of the x axis: can be 'WE' or 'SN'. Has to be
provided to earplanes and earpoints</p>
</td></tr>
<tr><td><code id="earnet_+3A_add">add</code></td>
<td>
<p>logical, whether to add the circle to an existing plot</p>
</td></tr>
</table>


<h3>References</h3>

<p>Snyder, John P., 1987, Map Projections-a working manual,
USGS-Professional Paper, 383p. pages 185-186, RFOC package
</p>


<h3>See Also</h3>

<p><code><a href="#topic+earinc">earinc</a></code>, <code><a href="#topic+earplanes">earplanes</a></code>,
<code><a href="#topic+earpoints">earpoints</a></code> and <code><a href="#topic+zijderveld">zijderveld</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>par(mfrow = c(1,2))
earnet()
earnet(xh  = "SN")
par(mfrow = c(1,1))
</code></pre>

<hr>
<h2 id='earplanes'>Draws planes on an equal area stereonet</h2><span id='topic+earplanes'></span>

<h3>Description</h3>

<p>Draws planes on an equal area stereonet (modified from RFOC
package)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>earplanes(
  strike,
  dip,
  quadrant = NA,
  hsphere = "l",
  ndiv = 10,
  a = list(col = "black", lwd = 1),
  l = list(lty = 1),
  u = list(lty = 3),
  output = FALSE,
  plot = TRUE,
  xh = "WE",
  unique = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="earplanes_+3A_strike">strike</code></td>
<td>
<p>strike of the data; it is the angle from the north of
the horizontal line of the plane. It is corrected by the <code><a href="#topic+dipfix">dipfix</a></code>
function.</p>
</td></tr>
<tr><td><code id="earplanes_+3A_dip">dip</code></td>
<td>
<p>dip of the data; it is the angle from the horizontal taken
on the line of the plane perpendicular to the one of the strike. It is
corrected by the <code><a href="#topic+dipfix">dipfix</a></code> function.</p>
</td></tr>
<tr><td><code id="earplanes_+3A_quadrant">quadrant</code></td>
<td>
<p>the quadrant were the plane dips downward. Accepted
values are NA, 'N', 'S', 'W' or 'E' (lower- or uppercase alike) for
correction by the <code><a href="#topic+dipfix">dipfix</a></code> function.</p>
</td></tr>
<tr><td><code id="earplanes_+3A_hsphere">hsphere</code></td>
<td>
<p>the hemisphere onto which to project the data. Either
&quot;b&quot; for both, &quot;l&quot; for lower, and u&quot; for upper.</p>
</td></tr>
<tr><td><code id="earplanes_+3A_ndiv">ndiv</code></td>
<td>
<p>the number of intervals between each 10° (in declination)</p>
</td></tr>
<tr><td><code id="earplanes_+3A_a">a</code>, <code id="earplanes_+3A_l">l</code>, <code id="earplanes_+3A_u">u</code></td>
<td>
<p>list of graphical parameters to feed lines() for the all
lines, or for the lines of the upper (u) and lower (l) hemisphere (the two
latter override a). See ?lines help page for the possible arguments. See
?merge_list for further information.</p>
</td></tr>
<tr><td><code id="earplanes_+3A_output">output</code></td>
<td>
<p>whether to return an output (position of the points
making the lines in the stereographic projection)</p>
</td></tr>
<tr><td><code id="earplanes_+3A_plot">plot</code></td>
<td>
<p>whether to plot</p>
</td></tr>
<tr><td><code id="earplanes_+3A_xh">xh</code></td>
<td>
<p>orientation of the x axis: can be 'WE' or 'SN'.</p>
</td></tr>
<tr><td><code id="earplanes_+3A_unique">unique</code></td>
<td>
<p>whether to only plot each similar plan once.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the x,y coordinates of each projected plane
</p>


<h3>References</h3>

<p>RFOC package
</p>


<h3>See Also</h3>

<p><code><a href="#topic+earnet">earnet</a></code>, <code><a href="#topic+earpoints">earpoints</a></code> and
<code><a href="#topic+dipfix">dipfix</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>strike   &lt;- c(45,  0)
dip      &lt;- c(20, 65)

earnet()
earplanes(strike,dip,hsphere = "b")

encircle(earinc(dip))

</code></pre>

<hr>
<h2 id='earpoints'>Draws points on an equal area stereonet</h2><span id='topic+earpoints'></span>

<h3>Description</h3>

<p>Draws points on an equal area stereonet (modified from RFOC
package)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>earpoints(
  dec,
  inc,
  hsphere = "b",
  double = FALSE,
  a = list(pch = 21, col = "black"),
  l = list(bg = "black"),
  h = list(bg = "grey"),
  u = list(bg = "white"),
  labels = NA,
  pos = 4,
  output = FALSE,
  plot = TRUE,
  xh = "WE"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="earpoints_+3A_dec">dec</code></td>
<td>
<p>declination of the data; it is the angle from the north
taken on an horizontal plane. It is measured clockwise from North and ranges
from 0 to 360° (Tauxe 2010). Values outside this range are corrected by the
<code><a href="#topic+incfix">incfix</a></code> function.</p>
</td></tr>
<tr><td><code id="earpoints_+3A_inc">inc</code></td>
<td>
<p>inclination of the data; it is the angle from the
horizontal, is positive downward, and ranges from +90° for straight down to
-90° for straight up (Tauxe, 2010). Values outside this range are corrected
by the <code><a href="#topic+incfix">incfix</a></code> function.</p>
</td></tr>
<tr><td><code id="earpoints_+3A_hsphere">hsphere</code></td>
<td>
<p>the hemisphere onto which to project the data. The
default is &quot;b&quot; for both: this useful in the case of oriented vectors rather
than lines like for paleomagnetism. Other choices are &quot;l&quot; and &quot;u&quot; for lower
and upper hemisphere.</p>
</td></tr>
<tr><td><code id="earpoints_+3A_double">double</code></td>
<td>
<p>whether to plot the equivalent point to one having an
inclination of 0°(with dec = dec +180)</p>
</td></tr>
<tr><td><code id="earpoints_+3A_a">a</code>, <code id="earpoints_+3A_l">l</code>, <code id="earpoints_+3A_h">h</code>, <code id="earpoints_+3A_u">u</code></td>
<td>
<p>list of graphical parameters to feed points() for all
points, or for the points of the upper (u) and lower (l) hemisphere, and of
the samples having an inclination of 0° (h) (the three latter override a).
See ?points help page for the possible arguments. See the example for
illustration, and ?merge_list for further information.</p>
</td></tr>
<tr><td><code id="earpoints_+3A_labels">labels</code></td>
<td>
<p>labels to each point</p>
</td></tr>
<tr><td><code id="earpoints_+3A_pos">pos</code></td>
<td>
<p>position of each label (see text() help page)</p>
</td></tr>
<tr><td><code id="earpoints_+3A_output">output</code></td>
<td>
<p>whether to return an output (position of the points in
the stereographic projection)</p>
</td></tr>
<tr><td><code id="earpoints_+3A_plot">plot</code></td>
<td>
<p>whether to plot</p>
</td></tr>
<tr><td><code id="earpoints_+3A_xh">xh</code></td>
<td>
<p>orientation of the x axis: can be 'WE' or 'SN'.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the x,y coordinates of each point in the projection
</p>


<h3>References</h3>

<p>Snyder, John P., 1987, Map Projections-a working manual,
USGS-Professional Paper, 383p. pages 185-186, RFOC package
</p>


<h3>See Also</h3>

<p><code><a href="#topic+earnet">earnet</a></code>, <code><a href="#topic+earplanes">earplanes</a></code> and
<code><a href="#topic+incfix">incfix</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>earnet()

h &lt;- 17
m &lt;- 11

if(m &lt; 10) a &lt;- "0" else a &lt;- ""

title(paste("Il est ", h, "h",a,m, sep = ""))

i1 &lt;- seq(40, 100, by = 10)
i2 &lt;- seq(0, -100, by = -10)
d1 &lt;- rep(h * 30 + m * 0.5, length(i1))
d2 &lt;- rep(m*6, length(i2))

inc &lt;- c(i1,i2)
dec &lt;- c(d1,d2)

earpoints(dec,inc)

</code></pre>

<hr>
<h2 id='encase'>Encases two numbers between multiples of a given number</h2><span id='topic+encase'></span>

<h3>Description</h3>

<p>Encases two numbers between multiples of a given number
</p>


<h3>Usage</h3>

<pre><code class='language-R'>encase(x1, x2, n)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="encase_+3A_x1">x1</code></td>
<td>
<p>the first value of the interval</p>
</td></tr>
<tr><td><code id="encase_+3A_x2">x2</code></td>
<td>
<p>the second value of the interval (can be higher or lower,
but never equal to x1)</p>
</td></tr>
<tr><td><code id="encase_+3A_n">n</code></td>
<td>
<p>the number to find the multiples from</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the multiples of n directly encompassing x1 and x2
</p>


<h3>See Also</h3>

<p>Similar function : <code><a href="#topic+casing">casing</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>encase(5,1,5)

</code></pre>

<hr>
<h2 id='encircle'>Draws circles</h2><span id='topic+encircle'></span>

<h3>Description</h3>

<p>Draws circles
</p>


<h3>Usage</h3>

<pre><code class='language-R'>encircle(
  r = 1,
  x = 0,
  y = 0,
  ndiv = 360,
  plot = TRUE,
  add = TRUE,
  output = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="encircle_+3A_r">r</code></td>
<td>
<p>the radius of the circles (of length 1 or n)</p>
</td></tr>
<tr><td><code id="encircle_+3A_x">x</code></td>
<td>
<p>the x value of the centre of the circles (of length 1 or n)</p>
</td></tr>
<tr><td><code id="encircle_+3A_y">y</code></td>
<td>
<p>the y value of the centre of the circles (of length 1 or n)</p>
</td></tr>
<tr><td><code id="encircle_+3A_ndiv">ndiv</code></td>
<td>
<p>the number of segments making the circles</p>
</td></tr>
<tr><td><code id="encircle_+3A_plot">plot</code></td>
<td>
<p>whether to plot the circles</p>
</td></tr>
<tr><td><code id="encircle_+3A_add">add</code></td>
<td>
<p>whether to add to an existing plot</p>
</td></tr>
<tr><td><code id="encircle_+3A_output">output</code></td>
<td>
<p>whether to return an output</p>
</td></tr>
<tr><td><code id="encircle_+3A_...">...</code></td>
<td>
<p>graphical parameters to feed to lines</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list of x and y matrices having n rows, one for each circle
</p>


<h3>Examples</h3>

<pre><code class='language-R'>plot(0, 0, xlim = c(-1,1), ylim = c(-1,1), asp = 1)

encircle(lwd = 2)
encircle(r = seq(0.1,0.9,0.1))

</code></pre>

<hr>
<h2 id='enlarge'>Expands the TRUE values of a T/F vector to their nth neighbours</h2><span id='topic+enlarge'></span>

<h3>Description</h3>

<p>Expands the TRUE values of a T/F vector to their nth neighbours
</p>


<h3>Usage</h3>

<pre><code class='language-R'>enlarge(x, n)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="enlarge_+3A_x">x</code></td>
<td>
<p>a TRUE/FALSE vector (e.g. c(T,T,F,F,T,T))</p>
</td></tr>
<tr><td><code id="enlarge_+3A_n">n</code></td>
<td>
<p>the proximity order of the FALSE values neighbouring the
TRUE values to be converted into TRUE (can be negative, should be convertible into an
integer). For instance 1 means that the F values dirctly next to a T will be
converted into T. 2 will apply that to the neighbours neigbhours, etc...</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a vector of T/F values, with  the TRUE values expanded to their nth
neighbours
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Creating a test dataset ----

y &lt;- c(rep(c(0,1,0,-1),8),rep(-1,3),-1.5,
           rep(-1,2),rep(c(0,1,0,-1),8))
x &lt;- 1:length(y)

df &lt;- data.frame(x,y)

xclip &lt;- c(20,48.5)
yclip &lt;- c(-0.5,1.5)

conditions &lt;- df$y &gt; yclip[1] &amp; df$y &lt; yclip[2] &amp;
              df$x &gt; xclip[1] &amp; df$x &lt; xclip[2]

normt &lt;- df[conditions,]

# Plotting supporting data ----

plot(df$x, df$y, type = "l", lty = 2, ylim = c(-2,2))

rect(xclip[1], yclip[1], xclip[2], yclip[2])

# See how the function reacts ----

embiggened &lt;- enlarge(conditions,1)

test  &lt;- df[embiggened,]

lines(test$x,test$y, lwd = 2, col = "blue")

points(normt$x,normt$y, type = "o", pch = 19,
       lty = 2, lwd= 2, col = "red")


legend(10, -1.6,
       legend = c(paste("Points initally isolated: they were chosen",
                        "to be the ones inside the rectangle"),
                  paste("Extension of the points: the first neighbours",
                        "of the points were added")),
       col = c("red", "blue"), pch = 19, lty = c(2,1), lwd = 2)

</code></pre>

<hr>
<h2 id='every_nth'>Suppresses every n th element of a vector</h2><span id='topic+every_nth'></span>

<h3>Description</h3>

<p>Suppresses every n th element of a vector
</p>


<h3>Usage</h3>

<pre><code class='language-R'>every_nth(x, nth, empty = TRUE, inverse = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="every_nth_+3A_x">x</code></td>
<td>
<p>a vector (numbers, integers, characters, you name it)</p>
</td></tr>
<tr><td><code id="every_nth_+3A_nth">nth</code></td>
<td>
<p>the multiple of position where the elements will be
suppressed (nth + 1 actually) or kept (if inverse = T)</p>
</td></tr>
<tr><td><code id="every_nth_+3A_empty">empty</code></td>
<td>
<p>whether the suppressed element should be replaced by &quot;&quot;</p>
</td></tr>
<tr><td><code id="every_nth_+3A_inverse">inverse</code></td>
<td>
<p>opposite reaction: n th elements only will be kept</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a vector with the remaining values
</p>


<h3>Author(s)</h3>

<p>Adam D. Smith
</p>


<h3>See Also</h3>

<p>practical usage of this function for axes: <code><a href="#topic+minorAxis">minorAxis</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>numvec &lt;- 0:20

every_nth(numvec, 3)

every_nth(numvec, 3, empty = FALSE)

every_nth(numvec, 3, inverse = TRUE)

every_nth(numvec, 3, empty = FALSE, inverse = TRUE)

</code></pre>

<hr>
<h2 id='flip.lim'>Inverts the intervals</h2><span id='topic+flip.lim'></span>

<h3>Description</h3>

<p>Gives a negative of the intervals of a lim object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>flip.lim(lim = NULL, l = NULL, r = NULL, b = "[]", xlim = NA)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="flip.lim_+3A_lim">lim</code></td>
<td>
<p>an object convertible into a lim object: either a vector
of length 2 or a list of n left (1st element) and n right (2ndt element)
interval limits</p>
</td></tr>
<tr><td><code id="flip.lim_+3A_l">l</code></td>
<td>
<p>a vector of n left interval limits</p>
</td></tr>
<tr><td><code id="flip.lim_+3A_r">r</code></td>
<td>
<p>a vector of n right interval limits</p>
</td></tr>
<tr><td><code id="flip.lim_+3A_b">b</code></td>
<td>
<p>a character vector for the interval boundaries rules: &quot;[]&quot;
(or &quot;closed&quot;) to include both boundaries points, &quot;][&quot; (or &quot;()&quot; and &quot;open&quot;) to
exclude both boundary points, &quot;[[&quot; (or &quot;[)&quot;,&quot;right-open&quot; and&quot;left-closed&quot;) to
include only the left boundary point, and &quot;]]&quot; (or &quot;(]&quot;, &quot;left-open&quot;,
&quot;right-closed&quot;) to include only the right boundary point. The notation is
simplified to &quot;[]&quot;, &quot;[[&quot;, &quot;]]&quot; and &quot;][&quot; only.</p>
</td></tr>
<tr><td><code id="flip.lim_+3A_xlim">xlim</code></td>
<td>
<p>the minimum and maximum of the new lim object (minimum and
maximum of the old one if NA; is the default)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a lim object of intervals in between the provided intervals
</p>


<h3>See Also</h3>

<p><code><a href="#topic+as.lim">as.lim</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>l   &lt;- c(1,3,5,7,9,10)
r   &lt;- c(3,4,7,8,9,11)
b   &lt;- "]["

xlim &lt;- c(-1,15)

res &lt;- flip.lim(l = l, r = r, b = b, xlim = xlim)

plot(1,1,type = "n", xlim = c(-4, 20), ylim = c(0.3, 1.8))
rect(l, 1.1, r, 1.4, col = "green", border = "darkgreen", lwd = 3)
rect(res$l, 1, res$r, 0.7, col = "red", border = "darkred", lwd = 3)
abline(v = xlim)

</code></pre>

<hr>
<h2 id='fmean'>Fischer mean</h2><span id='topic+fmean'></span>

<h3>Description</h3>

<p>Fischer mean
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fmean(dec = NA, inc = NA, int = 1, x = NA, y = NA, z = NA, id = NULL, cart = F)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fmean_+3A_dec">dec</code></td>
<td>
<p>declination of the data; it is the angle from the north
taken on an horizontal plane. It is measured clockwise from North and ranges
from 0 to 360° (Tauxe 2010). Values outside this range are corrected by
incfix().</p>
</td></tr>
<tr><td><code id="fmean_+3A_inc">inc</code></td>
<td>
<p>inclination of the data; it is the angle from the
horizontal, is positive downward, and ranges from +90° for straight down to
-90° for straight up (Tauxe, 2010). Values outside this range are corrected
by incfix().</p>
</td></tr>
<tr><td><code id="fmean_+3A_int">int</code></td>
<td>
<p>intensity of the data. Defaults to one (unit sphere).</p>
</td></tr>
<tr><td><code id="fmean_+3A_x">x</code>, <code id="fmean_+3A_y">y</code>, <code id="fmean_+3A_z">z</code></td>
<td>
<p>cartesian coordinates. x is the North, y the East, and z
straight down. If dec and inc are not provided they are used to be converted
back in dec, inc and int data. Output is corrected by incfix().</p>
</td></tr>
<tr><td><code id="fmean_+3A_id">id</code></td>
<td>
<p>a name for each point, identifying each group of points you would
like to treat separately</p>
</td></tr>
<tr><td><code id="fmean_+3A_cart">cart</code></td>
<td>
<p>whether to output as cartesian coordinates, defaults to F</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list of coordinates for the fischer mean, in cartesian form or dec,
inc, int form
</p>


<h3>See Also</h3>

<p><code><a href="#topic+fmod">fmod</a></code>, <code><a href="#topic+dipfix">dipfix</a></code> and <code><a href="#topic+incfix">incfix</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>dec &lt;- c(rnorm(10, mean = 45, sd = 5), rnorm(10, mean = 20, sd = 5))
inc &lt;- c(rnorm(10, mean = 45, sd = 5), rnorm(10, mean = 20, sd = 5))
id  &lt;- c(rep(1, 10), rep(2, 10))

earnet()
earpoints(dec, inc)

fm &lt;- fmean(dec, inc, id = id)

earpoints(fm $dec, fm$inc, l = list(bg = "red"))

</code></pre>

<hr>
<h2 id='fmod'>Universal remainder function</h2><span id='topic+fmod'></span>

<h3>Description</h3>

<p>Given a [xmin,xmax[ or ]xmin,xmax] interval, this function
determines the remainder of each numeric relative to this interval. In other
words if the interval was repeated over the whole numeric domain, this
function determines where each value would be positioned in a given
repetition.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fmod(x, xmax, xmin = 0, bounds = "[[")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fmod_+3A_x">x</code></td>
<td>
<p>vector of floating point numbers</p>
</td></tr>
<tr><td><code id="fmod_+3A_xmax">xmax</code>, <code id="fmod_+3A_xmin">xmin</code></td>
<td>
<p>the limits of the interval</p>
</td></tr>
<tr><td><code id="fmod_+3A_bounds">bounds</code></td>
<td>
<p>how to deal with boundaries (right- or left-open; '[['
or ']]')</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+incfix">incfix</a></code>, <code><a href="#topic+dipfix">dipfix</a></code> and <code><a href="#topic+transphere">transphere</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>fmod(c(1260.23,360),360)

fmod(c(1260.23,360),360,bounds = "]]")

fmod(c(1260.23,360),360 + 180, 180)

</code></pre>

<hr>
<h2 id='folder'>Creates a new folder where wanted if it does not exist yet</h2><span id='topic+folder'></span>

<h3>Description</h3>

<p>Creates a new folder where wanted if it does not exist yet
</p>


<h3>Usage</h3>

<pre><code class='language-R'>folder(dir, name)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="folder_+3A_dir">dir</code></td>
<td>
<p>directory containing the folder</p>
</td></tr>
<tr><td><code id="folder_+3A_name">name</code></td>
<td>
<p>name of the folder</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the directory of the folder itself
</p>


<h3>Examples</h3>

<pre><code class='language-R'>folder(tempdir(),"test")

</code></pre>

<hr>
<h2 id='formFunction'>Converts a formula into a function</h2><span id='topic+formFunction'></span>

<h3>Description</h3>

<p>Converts a formula into a function
</p>


<h3>Usage</h3>

<pre><code class='language-R'>formFunction(formula)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="formFunction_+3A_formula">formula</code></td>
<td>
<p>the formula to be converted. Should be of the form y ~ f(x)</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>f &lt;- formFunction(y ~ log10(x))

f(x=1:10)
</code></pre>

<hr>
<h2 id='framesvg'>Draws a standardised pointsvg object into a given frame</h2><span id='topic+framesvg'></span>

<h3>Description</h3>

<p>Draws a svg object imported as data frame using
<code><a href="#topic+pointsvg">pointsvg</a></code> into a given frame.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>framesvg(
  object,
  xmin,
  xmax,
  ymin,
  ymax,
  forget = NULL,
  front = NULL,
  back = NULL,
  standard = FALSE,
  keep.ratio = FALSE,
  col = NA,
  border = "black",
  density = NA,
  angle = 45,
  lwd = par("lwd"),
  lty = par("lty"),
  scol = border,
  slty = lty,
  slwd = lwd,
  plot = TRUE,
  output = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="framesvg_+3A_object">object</code></td>
<td>
<p>a pointsvg object (svg object imported as data frame
using <code><a href="#topic+pointsvg">pointsvg</a></code>).</p>
</td></tr>
<tr><td><code id="framesvg_+3A_xmin">xmin</code>, <code id="framesvg_+3A_xmax">xmax</code></td>
<td>
<p>the x value for the left and right side of the symbol</p>
</td></tr>
<tr><td><code id="framesvg_+3A_ymin">ymin</code>, <code id="framesvg_+3A_ymax">ymax</code></td>
<td>
<p>the y value for the low and high side of the symbol</p>
</td></tr>
<tr><td><code id="framesvg_+3A_forget">forget</code></td>
<td>
<p>the elements that should be discarded, by their id
or index (i.e. name or number of appearance).</p>
</td></tr>
<tr><td><code id="framesvg_+3A_front">front</code>, <code id="framesvg_+3A_back">back</code></td>
<td>
<p>the elements to be put in front and back position,
by their id or index (i.e. name or number of appearance). By default the
order is the one of the original .svg file.</p>
</td></tr>
<tr><td><code id="framesvg_+3A_standard">standard</code></td>
<td>
<p>whether to standardise (centre to (0,0), rescale so
that extreme points are at -1 and 1) or not (T or F)</p>
</td></tr>
<tr><td><code id="framesvg_+3A_keep.ratio">keep.ratio</code></td>
<td>
<p>if the object is to be  standardised, whether to
keep the x/y ratio (T or F)</p>
</td></tr>
<tr><td><code id="framesvg_+3A_col">col</code></td>
<td>
<p>the polygones background color. If density is specified with
a positive value this gives the color of the shading lines.</p>
</td></tr>
<tr><td><code id="framesvg_+3A_border">border</code></td>
<td>
<p>the lines color.</p>
</td></tr>
<tr><td><code id="framesvg_+3A_density">density</code></td>
<td>
<p>the density of shading lines, in lines per inch. The
default value of NULL means that no shading lines are drawn.</p>
</td></tr>
<tr><td><code id="framesvg_+3A_angle">angle</code></td>
<td>
<p>the slope of shading lines, given as an angle in degrees
(counter-clockwise)</p>
</td></tr>
<tr><td><code id="framesvg_+3A_lty">lty</code>, <code id="framesvg_+3A_lwd">lwd</code></td>
<td>
<p>the border line type and width, see ?par for details.</p>
</td></tr>
<tr><td><code id="framesvg_+3A_scol">scol</code>, <code id="framesvg_+3A_slty">slty</code>, <code id="framesvg_+3A_slwd">slwd</code></td>
<td>
<p>the colour, type and width of the shading lines.</p>
</td></tr>
<tr><td><code id="framesvg_+3A_plot">plot</code></td>
<td>
<p>whether to add to a plot</p>
</td></tr>
<tr><td><code id="framesvg_+3A_output">output</code></td>
<td>
<p>whether to output the new object coordinates</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code><a href="#topic+centresvg">centresvg</a></code> and
<code><a href="#topic+framesvg">framesvg</a></code> have a lot of similarities with the
<code><a href="#topic+multigons">multigons</a></code> function: the graphical parameters are mostly
identical. However there is a strong distinction between the -svg functions
and multigons: when providing several graphical arguments, multigons will
attribute them to each polygon, whereas the .svg functions will use them for
each repetition of the .svg object. Using the latter, the graphical
parameters will be applied to all the elements of a drawing. If you want
a finer personalisation you have to use multigons and multilines (or an
hybrid of the two, yet to be coded).
</p>


<h3>See Also</h3>

<p>Similar functions: <code><a href="#topic+centresvg">centresvg</a></code> and
<code><a href="#topic+placesvg">placesvg</a></code>
</p>
<p>Change the drawing: <code><a href="#topic+changesvg">changesvg</a></code> and <code><a href="#topic+clipsvg">clipsvg</a></code>
</p>
<p>Uses <code><a href="#topic+ignore">ignore</a></code> to avoid drawing unnecessary objects
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Simple use

object &lt;- example.ammonite

xmin &lt;- c(8,7)
xmax &lt;- c(10,9)
ymin &lt;- c(7,6)
ymax &lt;- c(9,8)

plot(c(-10,10), c(-10,10), type = "n")

abline(v = unique(c(xmax, xmin)))
abline(h = unique(c(ymax, ymin)))

framesvg(object, xmin, xmax, ymin, ymax, col = c("white", "grey80"))

# Precision positioning

l &lt;- c(1,2,3)
r &lt;- c(0,1,2)
h  &lt;- c(4,3,4)
i   &lt;- c("B1","B2","B3")

basic.litholog &lt;- litholog(l,r,h,i)

whiteSet(xlim = c(0,4), ylim = c(0,3), ytick = 1, ny = 10)

framesvg(example.lense, 0,3,1,2, forget = "P1", border = "red", lwd = 3)

multigons(basic.litholog$i, basic.litholog$xy, basic.litholog$dt)

</code></pre>

<hr>
<h2 id='greySet'>Sets the plot environment to draw a long vertical data set</h2><span id='topic+greySet'></span>

<h3>Description</h3>

<p>Sets the plot environment to draw a long dataset. It provides
grey bands as supplementary scale, and axes with major and minor ticks.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>greySet(
  xlim,
  ylim,
  xtick = NA,
  ytick = NA,
  nx = 1,
  ny = 1,
  xaxs = "i",
  yaxs = "i",
  xarg = list(tick.ratio = 0.5),
  yarg = list(tick.ratio = 0.5, las = 1),
  v = T,
  inverse = F,
  abbr = "",
  skip = 0,
  targ = list(col = "white", lwd = 2),
  rarg = list(border = NA, col = "grey85")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="greySet_+3A_xlim">xlim</code>, <code id="greySet_+3A_ylim">ylim</code></td>
<td>
<p>the x and y limits (e.g. xlim = c(-1,1))</p>
</td></tr>
<tr><td><code id="greySet_+3A_xtick">xtick</code>, <code id="greySet_+3A_ytick">ytick</code></td>
<td>
<p>the interval between each major ticks for x and y</p>
</td></tr>
<tr><td><code id="greySet_+3A_nx">nx</code>, <code id="greySet_+3A_ny">ny</code></td>
<td>
<p>the number of intervals between major ticks to be
divided by minor ticks in the x and y axes</p>
</td></tr>
<tr><td><code id="greySet_+3A_xaxs">xaxs</code>, <code id="greySet_+3A_yaxs">yaxs</code></td>
<td>
<p>The style of axis interval calculation to be used
for the x and y axes. By default it is &quot;i&quot; (internal): it just finds an axis
with pretty labels that fits within the original data range. You can also set
it to &quot;r&quot; (regular): it first extends the data range by 4 percent at each end
and then finds an axis with pretty labels that fits within the extended
range. See ?par for further explanation</p>
</td></tr>
<tr><td><code id="greySet_+3A_xarg">xarg</code>, <code id="greySet_+3A_yarg">yarg</code></td>
<td>
<p>a list of arguments to feed to minorAxis() for the
x and y axes. See the ?minorAxis help page for the possible arguments. See
?merge_list for further information.</p>
</td></tr>
<tr><td><code id="greySet_+3A_v">v</code></td>
<td>
<p>whether the grey bands are vertical</p>
</td></tr>
<tr><td><code id="greySet_+3A_inverse">inverse</code></td>
<td>
<p>inverse the bands position</p>
</td></tr>
<tr><td><code id="greySet_+3A_abbr">abbr</code></td>
<td>
<p>text to be repeated in the grey bands each major tick</p>
</td></tr>
<tr><td><code id="greySet_+3A_skip">skip</code></td>
<td>
<p>number of text redundancies to be skipped</p>
</td></tr>
<tr><td><code id="greySet_+3A_targ">targ</code>, <code id="greySet_+3A_rarg">rarg</code></td>
<td>
<p>a list of arguments to feed to text() and rect()
respectively. If set to NULL, does not add the corresponding element.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A plotting environment to draw a long data set
</p>


<h3>See Also</h3>

<p>Similar functions: <code><a href="#topic+whiteSet">whiteSet</a></code> and <code><a href="#topic+greySet">greySet</a></code>
</p>
<p>To create axes with major and minor ticks: <code><a href="#topic+minorAxis">minorAxis</a></code>
</p>
<p>To print a plot in pdf: <code><a href="#topic+pdfDisplay">pdfDisplay</a></code>
</p>
<p>To automatically determine pretty interval limits: <code><a href="#topic+encase">encase</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>y &lt;- c(0,11,19,33)
x &lt;- c(1,2,2.5,4)

a &lt;- min(y)
b &lt;- max(y)

f&lt;- encase(a-1,b,5)

greySet(c(0,4),f,abbr="abbr", ytick = 10, ny = 10)

points(x, y, pch=19)
</code></pre>

<hr>
<h2 id='homogenise'>Homogenise a list</h2><span id='topic+homogenise'></span><span id='topic+homogenize'></span>

<h3>Description</h3>

<p>Takes each element of a list and repeats each one so they
have the same length. This function is designed to be
integrated in another function and clean its arguments.
<strong>IF YOU RECEIVED A WARNING FROM THIS FUNCTION IN ANOTHER FUNCTION:</strong>
Check that the length of the arguments indicated by the warning are correct.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>homogenise(i = NULL, n = NULL, l = list(), cycle = TRUE)

homogenize(i = NULL, n = NULL, l = list(), cycle = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="homogenise_+3A_i">i</code></td>
<td>
<p>reference object of length n</p>
</td></tr>
<tr><td><code id="homogenise_+3A_n">n</code></td>
<td>
<p>length to reach (is overriden by i)</p>
</td></tr>
<tr><td><code id="homogenise_+3A_l">l</code></td>
<td>
<p>list for each element to be repeated to have a length n. These
elements have to be integers, numerics or characters.</p>
</td></tr>
<tr><td><code id="homogenise_+3A_cycle">cycle</code></td>
<td>
<p>whether to recycle the elements or to only allow elements of
length 1 or n</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list identical to the one initially provided, with elements length
homogenized to i
</p>


<h3>See Also</h3>

<p><code><a href="#topic+merge_list">merge_list</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>i     &lt;- rep(1:4, 2)

l &lt;- list(a = c(1,2,3),
          b = "R",
          d = 1:100,
          e = c("a", "b"),
          f = FALSE
          )

homogenise(i = i, l = l)

homogenise(n = 10, l = l)

</code></pre>

<hr>
<h2 id='ignore'>Ignores useless objects</h2><span id='topic+ignore'></span>

<h3>Description</h3>

<p>Ignores useless objects: this function will discard the polygons
or polylines outside a certain range. This allows to avoid unnecessary work
for multigons(), multilines(), centresvg() and framesvg().
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ignore(
  i,
  x,
  y = NA,
  d = list(),
  j = unique(i),
  arg = list(),
  xlim = par("usr")[c(1, 2)],
  ylim = par("usr")[c(3, 4)],
  xlog = par("xlog"),
  ylog = par("ylog")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ignore_+3A_i">i</code></td>
<td>
<p>a polygon id for each x and y coordinate. If n objects are
provided there should be n unique ids describing them, and the
graphical parameters should be of length 1 or n.</p>
</td></tr>
<tr><td><code id="ignore_+3A_x">x</code>, <code id="ignore_+3A_y">y</code></td>
<td>
<p>numeric vectors of coordinates.</p>
</td></tr>
<tr><td><code id="ignore_+3A_d">d</code></td>
<td>
<p>a list of named vectors going with i, x and y</p>
</td></tr>
<tr><td><code id="ignore_+3A_j">j</code></td>
<td>
<p>a list of the ids in the order used for the <code>arg</code>
arguments. By default they are in their order of appearance in <code>i</code></p>
</td></tr>
<tr><td><code id="ignore_+3A_arg">arg</code></td>
<td>
<p>a list of arguments f length 1 or n.</p>
</td></tr>
<tr><td><code id="ignore_+3A_xlim">xlim</code>, <code id="ignore_+3A_ylim">ylim</code></td>
<td>
<p>the limits in x and y; if any object has all his
points past one of these limits, it will be removed.</p>
</td></tr>
<tr><td><code id="ignore_+3A_xlog">xlog</code>, <code id="ignore_+3A_ylog">ylog</code></td>
<td>
<p>whether the axes have logarithmic scale</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list of i, x, y, d, j and arguments.
</p>


<h3>See Also</h3>

<p>Tributary functions: <code><a href="#topic+multigons">multigons</a></code>,
<code><a href="#topic+multilines">multilines</a></code>, <code><a href="#topic+centresvg">centresvg</a></code> and <code><a href="#topic+framesvg">framesvg</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>i &lt;- c(rep("A1",6), rep("A2",6), rep("A3",6))
x &lt;- c(1,2,3,3,2,1,4,5,6,6,5,4,7,8,9,9,8,7)
y &lt;- c(1,2,3,4,5,6,1,2,3,4,5,6,1,2,3,4,5,6)

xlim &lt;- c(2,5)
ylim &lt;- c(0,1.5)

plot(c(0,10),c(0,10),type = "n")
rect(xlim[1], ylim[1], xlim[2], ylim[2])

multilines(i, x, y, lty = 3, col = "grey80")

res &lt;- ignore(i, x, y, arg = list(lty =  1, lwd = 3,
              col = c("orange", "green", "red")),
              xlim = xlim, ylim = ylim)

do.call(multilines, res)

</code></pre>

<hr>
<h2 id='in.lim'>Finds the intervals encompassing values</h2><span id='topic+in.lim'></span>

<h3>Description</h3>

<p>This function returns the intervals encompassing x values. This
works only if the intervals (as lim objects) are non overlapping and
non-adjacent (if certain boundaries are neighbouring, the boundary rule
should exclude all, or all but one)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>in.lim(x, lim = NULL, l = NULL, r = NULL, id = 1L, b = "][", index = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="in.lim_+3A_x">x</code></td>
<td>
<p>a vector values</p>
</td></tr>
<tr><td><code id="in.lim_+3A_lim">lim</code></td>
<td>
<p>an object convertible into a lim object: either a vector
of length 2 or a list of n left (1st element) and n right (2ndt element)
interval limits. The intervals should be non-overlapping and non-adjacent.</p>
</td></tr>
<tr><td><code id="in.lim_+3A_l">l</code></td>
<td>
<p>a vector of n left interval limits</p>
</td></tr>
<tr><td><code id="in.lim_+3A_r">r</code></td>
<td>
<p>a vector of n right interval limits</p>
</td></tr>
<tr><td><code id="in.lim_+3A_id">id</code></td>
<td>
<p>a vector of n interval IDs (default is 1 for each interval)</p>
</td></tr>
<tr><td><code id="in.lim_+3A_b">b</code></td>
<td>
<p>a character vector for the interval boundaries rules: &quot;[]&quot;
(or &quot;closed&quot;) to include both boundaries points, &quot;][&quot; (or &quot;()&quot; and &quot;open&quot;) to
exclude both boundary points, &quot;[[&quot; (or &quot;[)&quot;,&quot;right-open&quot; and&quot;left-closed&quot;) to
include only the left boundary point, and &quot;]]&quot; (or &quot;(]&quot;, &quot;left-open&quot;,
&quot;right-closed&quot;) to include only the right boundary point.</p>
</td></tr>
<tr><td><code id="in.lim_+3A_index">index</code></td>
<td>
<p>whether the output should be a list of the initial vector
and of the corresponding intervals in which they lay (index = FALSE, is the
default), or simply the index of the intervals in the initial lim object
(index = TRUE)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list of the intervals where the x values lay or a vector of their
index
</p>


<h3>See Also</h3>

<p><code><a href="#topic+as.lim">as.lim</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x   &lt;- c(99,1,3,5,2,4,5,6,9,4,8,20,26,52,42,24,25,12,40,10,16,17)

lim &lt;- as.lim(l = c(100,10,20,27), r = c(99,12,27,42), b = "]]")

in.lim(x, lim = lim)

in.lim(x, lim = lim, index = TRUE)

# Applications to Stratigraphy

proxy &lt;- proxy.example # This is a data.frame with (fake) magnetic
                       # susceptibility (ms) and depth (dt)

# Each sample was taken in a specific bed (not at the boundary between two,
# to make things easier). We will invoke the data of the beds (bed.example)
# and identify the lithology of each sample

res &lt;- in.lim(proxy.example$dt,  # Position of each sample
              l = bed.example$l, # Left boundary of the beds
              r = bed.example$r, # Right boundary of the beds
              id = bed.example$litho) # Lithology of each bed (if you wanted
                                      # to know the name of the bed each
                                      # sample is in you would have put
                                      # bed.example$id)

proxy$litho &lt;- res$id # The result provides the id (here the lithology) of
                      # each interval encompassing the measurement (x, here
                      # proxy.example$dt)

plot(proxy$ms, proxy$dt, type = "l", xlim = c(-2*10^-8, 8*10^-8))

shale &lt;- subset(proxy, proxy$litho == "S")
points(shale$ms, shale$dt, pch = 4)

limestone &lt;- subset(proxy, proxy$litho == "L")
points(limestone$ms, limestone$dt, pch = 19)

chert &lt;- subset(proxy, proxy$litho == "C")
points(chert$ms, chert$dt, pch = 21, bg = "white")

legend(6.2*10^-8, 25, legend = c("Shale", "Limestone", "Chert"),
       pch = c(4,19,21), bg = c(NA, NA, "white"))

</code></pre>

<hr>
<h2 id='in.window'>Irregular windowing</h2><span id='topic+in.window'></span>

<h3>Description</h3>

<p>Find the index of points in time-series that fall into a
specific window, even with irregular sampling rate. The iterations needed
in this function are equal to the maximum amount of points found in the
windows, therefore it should be reasonably efficient for short windows at
least.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>in.window(x, w, xout = unique(x), b = "[]", warn = 100, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="in.window_+3A_x">x</code></td>
<td>
<p>the position values to be regrouped in windows</p>
</td></tr>
<tr><td><code id="in.window_+3A_w">w</code></td>
<td>
<p>the window length (top to bottom)</p>
</td></tr>
<tr><td><code id="in.window_+3A_xout">xout</code></td>
<td>
<p>the center of each window, defaults to x</p>
</td></tr>
<tr><td><code id="in.window_+3A_b">b</code></td>
<td>
<p>the boundary rule at the top and bottom of the window: &quot;][&quot; means
that neither the top nor bottom are taken in, &quot;[]&quot; means that top and bottom
are taken in, &quot;]]&quot; and &quot;[[&quot; mean that only the top or the bottom are taken
in, respectively. Also accepts: &quot;[)&quot;, &quot;(]&quot;, &quot;()&quot;, &quot;open&quot;, &quot;closed&quot;,
&quot;left-open&quot;, &quot;right-open&quot;, &quot;left-closed&quot; and &quot;right-closed&quot;: see
<code><a href="#topic+rebound">rebound</a></code> for more information</p>
</td></tr>
<tr><td><code id="in.window_+3A_warn">warn</code></td>
<td>
<p>an integer of the amount of iterations after which a warning is
issued: this could mean that there are too many data points in a window, and
that the computation will become very inefficient. This is up to the user to
see. If you want to remove the warning, set this parameter to Inf</p>
</td></tr>
<tr><td><code id="in.window_+3A_...">...</code></td>
<td>
<p>intensity values corresponding to each x position, making
time-series. They will be provided window by window in the output.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list made of the center values of the windows ($xout), a matrix of
the index of the original x values in each corresponding window ($x.index;
the rows correspond to each $xout value), a matrix of the x values in
each corresponding window ($x; the rows correspond to each $xout value),
the amount of points in each window ($n.size), and additional matrices of
additional intensity values provided in <code>...</code> (names correspond to the
names provided in <code>...</code>; the rows correspond to each $xout value)
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Visual example ----

set.seed(42)

n &lt;- 600
t &lt;- seq_len(n)

p1 &lt;- 30
p2 &lt;- 240

xy &lt;- (1 + 0.6 * sin(t*2*pi/p2)) * sin(t*2*pi/p1)  + 2 * sin(t*2*pi/p2) +
  rnorm(n, sd = 0.5) + t * 0.01

inter_dt &lt;- round(runif(length(xy), min = 0.5, max = 1.5),1)

dt &lt;- cumsum(inter_dt)

keep &lt;- runif(length(dt)) &lt; 0.5

xy &lt;- xy[keep]
dt &lt;- dt[keep]

window &lt;- in.window(dt, w = 30, 1:590, xy = xy)

par(mfrow = c(1,2))

plot(xy, dt, type = "o", pch = 19,
     ylim = c(0,600), main = "Moving Average")

lines(rowMeans(window$xy, na.rm = TRUE), window$xout,
      col = "red", lwd = 2)

plot(window$n.size, window$xout,  pch = 19,
     ylim = c(0,600), xlim = c(0,20), ylab = "dt",
     main = "Amount of Points in Average")

# Test the boundary rule ----

x &lt;- c(1,1,2,3,4,6,8,10,15,16)
xout &lt;- -6:22

output &lt;- in.window(x = x, w = 10, xout = xout, b = "]]")

test &lt;- output$x - output$xout
see  &lt;- cbind(output$xout, output$x)

colnames(see) &lt;- c("xout", paste0("x", seq_len(ncol(see)-1)))

test # difference between x and xout: it is contained in ]-5,5]
see

</code></pre>

<hr>
<h2 id='incfix'>Fix Inclination</h2><span id='topic+incfix'></span>

<h3>Description</h3>

<p>Fix inclination and declination so that they fall in the correct
quadrant and hemisphere (modified from RFOC package)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>incfix(dec, inc, hsphere = "b")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="incfix_+3A_dec">dec</code></td>
<td>
<p>declination of the data; it is the angle from the north
taken on an horizontal plane. It is measured clockwise from North and ranges
from 0 to 360° (Tauxe 2010). Values outside this range are corrected by this
function.</p>
</td></tr>
<tr><td><code id="incfix_+3A_inc">inc</code></td>
<td>
<p>inclination of the data; it is the angle from the
horizontal, is positive downward, and ranges from +90° for straight down to
-90° for straight up (Tauxe, 2010). Values outside this range are corrected
by this function.</p>
</td></tr>
<tr><td><code id="incfix_+3A_hsphere">hsphere</code></td>
<td>
<p>the hemisphere onto which to project the data. Either
&quot;b&quot; for both. This is the default and useful for paleomagnetism. In this
case positive and negative values of inc are permitted. Or &quot;l&quot; for lower, and
&quot;u&quot; for upper, allowing only negative or positive inc values respectively.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Quadrants are determined by the sine and cosine of the dip angle:
co = cos(dip), si = sin(dip),
quad[co&gt;=0 &amp; si&gt;=0] = 1, quad[co&lt;0 &amp; si&gt;=0] = 2,
quad[co&lt;0 &amp; si&lt;0] = 3 and quad[co&gt;=0 &amp; si&lt;0] = 4.
Samples at inc == 0° and inc == 90° are taken as exceptions (cf. code).
Be cautions with the floating point error however, round if needed.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+fmod">fmod</a></code>, <code><a href="#topic+dipfix">dipfix</a></code> and
<code><a href="#topic+transphere">transphere</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>incfix(591,-425,"b")
incfix(591,-425,"u")
incfix(591,-425,"l")

</code></pre>

<hr>
<h2 id='infobar'>Draws rectangles with text in them</h2><span id='topic+infobar'></span>

<h3>Description</h3>

<p>Draws rectangles with text in them, typically to delimit
(stratigraphical) intervals (e.g. magnotochrons, but also
lithostratigraphy,...)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>infobar(
  xmin,
  xmax,
  ymax,
  ymin,
  labels = NA,
  m = list(),
  t = list(),
  srt = 90,
  family = par("family"),
  xpd = par("xpd")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="infobar_+3A_xmin">xmin</code>, <code id="infobar_+3A_xmax">xmax</code>, <code id="infobar_+3A_ymin">ymin</code>, <code id="infobar_+3A_ymax">ymax</code></td>
<td>
<p>x and y limits for the rectangles. You can
either provide 1 or n of each (if you want to have always the same x limits
but multiple and different y ones it is possible)</p>
</td></tr>
<tr><td><code id="infobar_+3A_labels">labels</code></td>
<td>
<p>a 1 or n character vector (i.e. text) specifying the
text to be written in the rectangle. You can write &quot;&quot; for no text.</p>
</td></tr>
<tr><td><code id="infobar_+3A_m">m</code>, <code id="infobar_+3A_t">t</code></td>
<td>
<p>a list graphical parameters (of length 1 or n) to feed
multigons() for m and to text() for t. See respective help pages ?multigons
and ?text for the possible arguments. See the example for illustration, and
?merge_list for further information.</p>
</td></tr>
<tr><td><code id="infobar_+3A_srt">srt</code>, <code id="infobar_+3A_family">family</code>, <code id="infobar_+3A_xpd">xpd</code></td>
<td>
<p>further graphical parameters, see ?par for information</p>
</td></tr>
</table>


<h3>See Also</h3>

<p>Similar functions: <code><a href="#topic+multigons">multigons</a></code>, <code><a href="#topic+bedtext">bedtext</a></code>,
<code><a href="#topic+nlegend">nlegend</a></code> and <code><a href="#topic+ylink">ylink</a></code>
</p>
<p>To deal with intervals: <code><a href="#topic+as.lim">as.lim</a></code> and related functions
</p>


<h3>Examples</h3>

<pre><code class='language-R'>labels &lt;- c("High 5", "Low 5", "5")
ymin &lt;- c(10,-10,2.5)
ymax &lt;- c(20,0, 7.5)

plot(c(0,6),c(-20,20), type = "n")

infobar(xmin = 0, xmax = 1, ymin = ymin, ymax = ymax, labels,
        m = list(col = c("grey","grey", "red"),
                 border = "black", density = 10),
        t = list(cex = 1.5, col = "white"))

</code></pre>

<hr>
<h2 id='is.clockwise'>Identify whether the points of a polygon are ordered clockwise</h2><span id='topic+is.clockwise'></span>

<h3>Description</h3>

<p>Identify whether the points of a polygon are ordered clockwise
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is.clockwise(x, y, i = rep("A1", length(x)), get.pos = F)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="is.clockwise_+3A_x">x</code>, <code id="is.clockwise_+3A_y">y</code></td>
<td>
<p>the coordinates of the polygons</p>
</td></tr>
<tr><td><code id="is.clockwise_+3A_i">i</code></td>
<td>
<p>the identification of the polygons if there are multiple ones</p>
</td></tr>
<tr><td><code id="is.clockwise_+3A_get.pos">get.pos</code></td>
<td>
<p>get the output as a list of the result and of the output of
octapos()</p>
</td></tr>
</table>


<h3>Value</h3>

<p>logical values for each polygon: TRUE for clockwise, FALSE for
counterclockwise, NA for ambiguous order, typically in lines or the polygons
whose lines cross each other (although sometimes such polygons are still
giving T or F values, as this function only consider certain reference
points, for more details see <code><a href="#topic+octapos">octapos</a></code>).
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Generate some polygons ----

x1 &lt;- c(0,1,0.5)
y1 &lt;- c(3,3,4)
i1 &lt;- rep("P1", 3)
s1 &lt;- 1:3

x2 &lt;- c(3,3.5,4)
y2 &lt;- c(3,4,3)
i2 &lt;- rep("P2", 3)
s2 &lt;- 1:3

x3 &lt;- c(0,0.5,1)
y3 &lt;- c(1, 1.5,2)
i3 &lt;- rep("P3", 3)
s3 &lt;- 1:3

x4 &lt;- c(3,4,4,3)
y4 &lt;- c(1,2,1,2)
i4 &lt;- rep("P4", 4)
s4 &lt;- 1:4

x5 &lt;- c(1,2,3,3,2,1)
y5 &lt;- c(-0.5,0.4,-0.5,0.5,-0.4,0.5)
i5 &lt;- rep("P5", 6)
s5 &lt;- 1:6

x6 &lt;- c(1,2,3,3,2,1)
y6 &lt;- c(-2,-1,-2,-1,-2.5,-1)
i6 &lt;- rep("P6", 6)
s6 &lt;- 1:6

x &lt;- c(x1, x2, x3, x4, x5, x6)
y &lt;- c(y1, y2, y3, y4, y5, y6)
i &lt;- c(i1, i2, i3, i4, i5, i6)
s &lt;- c(s1, s2, s3, s4, s5, s6)

# Test whether they are clockwise or not ----

is.clockwise(x = x, y = y, i = i)

# Visualise the result ----

plot.new()
plot.window(xlim = c(-0.5,5.5), ylim = c(-2.5,4.5))

axis(1)
axis(2)

multigons(i = i, x = x, y = y)

center.x   &lt;- c(0.5, 3.5, 0.5, 3.5, 2, 2)
center.y   &lt;- c(3.4, 3.4, 2, 1.5, 0, -1.5)
center.lab &lt;- c("P1", "P2", "P3", "P4", "P5", "P6")

text(x = center.x, y = center.y, labels = center.lab)

text(x = x, y = y, labels = s)

</code></pre>

<hr>
<h2 id='is.joint'>Check (bedding) joint objects</h2><span id='topic+is.joint'></span>

<h3>Description</h3>

<p>Check whether a data.frame complies with the criteria to be a
valid bedding joint to be integrated in a litholog.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is.joint(joint, warn = F)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="is.joint_+3A_joint">joint</code></td>
<td>
<p>the data.frame to test</p>
</td></tr>
<tr><td><code id="is.joint_+3A_warn">warn</code></td>
<td>
<p>whether to have a warning explaining why the candidate joint
is invalid</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'># Plots for visualisation ----

opar &lt;- par("mfrow")
par(mfrow = c(2,1))

plot.new()
plot.window(xlim = range(oufti99$'1sin'$x),
            ylim = range(oufti99$'1sin'$y))
title("oufti99$'1sin'")
placesvg(oufti99$'1sin')

plot.new()
plot.window(xlim = range(oufti99$ammonite$x),
            ylim = range(oufti99$ammonite$y), asp = 1)
title("oufti99$ammonite")
placesvg(oufti99$ammonite)

par(mfrow = opar)

# Exemplification of is.joint ----

is.joint(oufti99$'1sin')

is.joint(oufti99$ammonite)

</code></pre>

<hr>
<h2 id='leftlog'>Finds bed intervals in a &quot;litholog()&quot;-like data frame</h2><span id='topic+leftlog'></span>

<h3>Description</h3>

<p>Determines the interval of bed boundaries at the far left of a
litholog. This is used when the welding of varying bed boundaries changes
these intervals, and that you want to use bedtext() to print the name of the
beds on the log.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>leftlog(i, dt, xy, warn = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="leftlog_+3A_i">i</code></td>
<td>
<p>the id of the polygons in the &quot;litholog()&quot;-like data frame</p>
</td></tr>
<tr><td><code id="leftlog_+3A_dt">dt</code></td>
<td>
<p>the depth of the polygons in the &quot;litholog()&quot;-like data frame</p>
</td></tr>
<tr><td><code id="leftlog_+3A_xy">xy</code></td>
<td>
<p>the x values (i.e. hardness) of the polygons in the
&quot;litholog()&quot;-like data frame</p>
</td></tr>
<tr><td><code id="leftlog_+3A_warn">warn</code></td>
<td>
<p>whether you want to be annoyed</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list of minima (l) and maxima (r) of boundaries corresponding to
each bed (id)
</p>


<h3>See Also</h3>

<p><code><a href="#topic+litholog">litholog</a></code>, <code><a href="#topic+weldlog">weldlog</a></code> and
<code><a href="#topic+bedtext">bedtext</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>l &lt;- c(0,1,2,3,4)
r &lt;- c(1,2,3,4,5)
h   &lt;- c(4,3,4,3,4)
i &lt;- c("B1","B2","B3","B4","B5")
log  &lt;- litholog(l, r, h, i)

whiteSet(xlim = c(-1,5), ylim = c(-1,6))

title("leftlog() gets the bed names in the right position")

multigons(log$i, log$xy, log$dt, lty = 3)

seg1 &lt;- sinpoint(4, 0, 0.25, pos = 1, phase=0)
seg2 &lt;- sinpoint(4, 0, 0.25, pos = 1, phase=1)

welded &lt;- weldlog(log, dt = c(2,3), seg = list(seg1, seg2), add.dt = 0.5)

multigons(welded$i, welded$xy, welded$dt, lwd = 3, lty = 2, border = "red")

old.log.interval &lt;- leftlog(log$i, log$dt, log$xy)
new.log.interval &lt;- leftlog(welded$i, welded$dt, welded$xy)

bedtext(labels = new.log.interval$id,
        l= new.log.interval$l,
        r= new.log.interval$r,
        arg = list(col = "red"))

</code></pre>

<hr>
<h2 id='litholog'>Create/check lithologs</h2><span id='topic+litholog'></span><span id='topic+is.litholog'></span>

<h3>Description</h3>

<p>Creates and checks basic coordinates of polygons to draw a
simple litholog with rectangles
</p>


<h3>Usage</h3>

<pre><code class='language-R'>litholog(l, r, h, i)

is.litholog(object)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="litholog_+3A_l">l</code>, <code id="litholog_+3A_r">r</code></td>
<td>
<p>the height of each delimitation (upper and lower; l and r
stand for left and right boundaries of the interval, their order does not
matter)</p>
</td></tr>
<tr><td><code id="litholog_+3A_h">h</code></td>
<td>
<p>the hardness of each bed</p>
</td></tr>
<tr><td><code id="litholog_+3A_i">i</code></td>
<td>
<p>the id of each bed: it should be different for each bed</p>
</td></tr>
<tr><td><code id="litholog_+3A_object">object</code></td>
<td>
<p>an R object to test whether it is a litholog, as outputted by
the <code>litholog</code> function</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A table of ids (i), depth (dt) and xy value (i.e. hardness, or simply
the x position if your litholog is vertical) of rectangles for each bed. This
order of column variable (i, dt, xy) is checked by is.litholog
</p>


<h3>See Also</h3>

<p>For a more detailed explanation of how to make a litholog:
<code><a href="#topic+StratigrapheR">StratigrapheR</a></code>
</p>
<p>How to prepare the plot background for the litholog: <code><a href="#topic+whiteSet">whiteSet</a></code>
</p>
<p>How to draw the litholog: <code><a href="#topic+multigons">multigons</a></code>
</p>
<p>How to add the names of the beds in the litholog: <code><a href="#topic+bedtext">bedtext</a></code>
</p>
<p>How to plot in pdf: <code><a href="#topic+pdfDisplay">pdfDisplay</a></code>
</p>
<p>To add personalised boundaries between beds: <code><a href="#topic+weldlog">weldlog</a></code>
</p>
<p>To have open beds at the extremities of the log. More generaly to transform a
polygon into a polyline and control the part that is not drawn:
<code><a href="#topic+multilines">multilines</a></code> and <code><a href="#topic+shift">shift</a></code>
</p>
<p>To add details and drawings: <code><a href="#topic+centresvg">centresvg</a></code> and
<code><a href="#topic+framesvg">framesvg</a></code>
</p>
<p>Go further with interval data (between two boundaries, as there often is
in stratigraphy): <code><a href="#topic+as.lim">as.lim</a></code> and related functions.
</p>
<p>Complementary functions: <code><a href="#topic+infobar">infobar</a></code> and <code><a href="#topic+ylink">ylink</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>l &lt;- c(1,2,3)  # left boundary of the bed interval (upper or lower)
r &lt;- c(0,1,2)  # right boundary of the bed interval (upper or lower)
h  &lt;- c(4,3,4) # hardness (arbitrary)
i   &lt;- c("B1","B2","B3") # Bed name

basic.litholog &lt;- litholog(l,r,h,i) # Generate data frame of the polygons
                                    # making the litholog

is.litholog(basic.litholog)

whiteSet(xlim = c(0,4), ylim = c(0,3), ytick = 1, ny = 10) # Plot background
multigons(basic.litholog$i, basic.litholog$xy, basic.litholog$dt) # Draw log

</code></pre>

<hr>
<h2 id='memento'>Remembers and outputs the result of a slow function</h2><span id='topic+memento'></span>

<h3>Description</h3>

<p>Memento mori; you do not have time to lose on unnecessary
calculations. This function remembers the output of a slow function, for
given arguments and, if asked politely, given files and a given random seed.
If they match the previous arguments, files and seeds, the output is provided
without delay, otherwise the function runs, and all the parameters are saved
for next time. The trade-off is to assign a folder to store the data (see
also details). The function can also be forced to rerun.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>memento(
  what,
  args,
  name,
  dir = getwd(),
  subdir = "memento",
  rerun = F,
  check.files = list(),
  files.dir = getwd(),
  check.seed = F,
  speak = T
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="memento_+3A_what">what</code></td>
<td>
<p>a (slow) function</p>
</td></tr>
<tr><td><code id="memento_+3A_args">args</code></td>
<td>
<p>a list of the the arguments to give to the function. If they
differ from saved values, the function will run again.</p>
</td></tr>
<tr><td><code id="memento_+3A_name">name</code></td>
<td>
<p>the name of the folder where to store the info. THIS NEEDS TO BE
DIFFERENT FOR EACH IMPLEMENTATION OF THE FUNCTION IN IDENTICAL DIRECTORIES.</p>
</td></tr>
<tr><td><code id="memento_+3A_dir">dir</code></td>
<td>
<p>the directory. You can set it as the working directory via
<code><a href="base.html#topic+getwd">getwd</a></code>.</p>
</td></tr>
<tr><td><code id="memento_+3A_subdir">subdir</code></td>
<td>
<p>a name for a subdirectory (useful when the function is used
several time in a script)</p>
</td></tr>
<tr><td><code id="memento_+3A_rerun">rerun</code></td>
<td>
<p>if TRUE, the function is rerun no matter what. This is useful
to update information that is not present in the R environment, for instance
if you load data from external files that have been updated.</p>
</td></tr>
<tr><td><code id="memento_+3A_check.files">check.files</code></td>
<td>
<p>a list of files to check changes in (see details). If the
list is of length 0, no file is checked.</p>
</td></tr>
<tr><td><code id="memento_+3A_files.dir">files.dir</code></td>
<td>
<p>directory for teh files to be checked.</p>
</td></tr>
<tr><td><code id="memento_+3A_check.seed">check.seed</code></td>
<td>
<p>if TRUE, the value of the random seed in effect will be
taken into account; if it changes, the function will run again.</p>
</td></tr>
<tr><td><code id="memento_+3A_speak">speak</code></td>
<td>
<p>whether to signify when the (slow) function is running</p>
</td></tr>
</table>


<h3>Details</h3>

<p>file data is summarized using MD5sum, which can have limitations in
data size (2^64 bits) and in cryptographic purposes.
</p>


<h3>Value</h3>

<p>the output of the function
</p>


<h3>Examples</h3>

<pre><code class='language-R'>tf &lt;- tempdir()
if(exists("run.number")) run.number &lt;- run.number + 1 else run.number &lt;-  1
name &lt;- paste("T",run.number)

testfun &lt;- function(a = 1, time = 3){

  Sys.sleep(time)

  return(a  + 0.1 * abs(rnorm(1)))

}

# First time running; the function takes some time, memento needs the
# output to be generated, and will remember for later.
set.seed(43)
memento(testfun,  args = list(a = 7), name = name, dir = tf)

set.seed(43)
testfun(7, time = 0)

# Second time running: memento directly outputs the remembered results.
# In this case, the seed is ignored, so the result is different from what
# would be obtained with a different seed
set.seed(45)
memento(testfun,  args = list(a = 7), name = name, dir = tf)

set.seed(45)
testfun(7, time = 0)

# First time running while taking into account the random seed;
# the function takes some time to generate the result
set.seed(42)
memento(testfun,  args = list(a = 7), name = name, dir = tf, check.seed = TRUE)

# Second time running with an identical random seed;
# memento directly outputs the results
set.seed(42)
memento(testfun,  args = list(a = 7), name = name, dir = tf, check.seed = TRUE)

# The seed is changed: the result is computed anew
set.seed(47)
memento(testfun,  args = list(a = 7), name = name, dir = tf, check.seed = TRUE)

</code></pre>

<hr>
<h2 id='merge_list'>Method for merging lists by name</h2><span id='topic+merge_list'></span>

<h3>Description</h3>

<p>This is a method that merges the contents of lists based on the
name of the elements. In the case of identical names, the order of the lists
determines which element is kept.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>merge_list(l1, l2, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="merge_list_+3A_l1">l1</code></td>
<td>
<p>the first list.</p>
</td></tr>
<tr><td><code id="merge_list_+3A_l2">l2</code></td>
<td>
<p>the list which will supply additional elements to l1 that
are not already there by name.</p>
</td></tr>
<tr><td><code id="merge_list_+3A_...">...</code></td>
<td>
<p>additionnal lists, that bring elements if they are not
existing by name in the ones before.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>if a name appears more than once in a list, only the first one will
be kept. This is particularly useful if you want to still be able to provide
whichever argument you want to a function inside another function. See the
advanced use in the examples to see how to do it.
</p>


<h3>Value</h3>

<p>A merged list of all lists provided, each element (determined by its
name) appearing only once.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+homogenise">homogenise</a></code> provides a general way of dealing with
function arguments.
</p>
<p>To get a better understanding of how to deal with function arguements, go see
?do.call and ?list
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Simple use

a &lt;- list(lty = c(2,4), mar = 4, plot = TRUE)
b &lt;- list(mar = "hype",lty = "hype",  pink = TRUE)
d &lt;- list(lty = FALSE, pink = "Yikes", mar = "ldkfj", test = "Successful")

merge_list(a,b,d)

# Advanced use

# We will plot points with different parameters for each lithology (see also
# the example in ?in.lim)

advanced.ex &lt;- function(line.args = list(lty = 3, col = "grey"),
                        all = list(pch = 21, cex = 2),
                        chert = list(bg = "white"),
                        limestone = list(bg = "black"),
                        shale = list(bg = "red"),
                        main = "")
{

  # Preparation of plot and necessary data frames

  plot(proxy.example.litho$ms, proxy.example.litho$dt, type = "n",
       xlim = c(-2*10^-8, 8*10^-8), main = main)

  shale.df &lt;- subset(proxy.example.litho, proxy.example.litho$litho == "S")
  limestone.df &lt;- subset(proxy.example.litho, proxy.example.litho$litho == "L")
  chert.df &lt;- subset(proxy.example.litho, proxy.example.litho$litho == "C")

  # Important part:

  # We use the do.call function, which calls a given function and provides
  # its arguments via a list. It is that list that is created by merge list.
  # for the lines function, we provide x and y coordinates, a personalised
  # list of arguments (line), and the default parameters. In this order the
  # personalised arguments override the default ones, but the latter are used
  # in the absence of personalised arguments

  line.args &lt;- merge_list(list(x = proxy.example.litho$ms,
                               y = proxy.example.litho$dt),
                          line.args, # personalised list of arguments
                          list(lty = 3, col = "grey") # default parameters
  )

  do.call(lines, args = line.args)

  # Same procedure for the points of each lithology, but we add an 'all'
  # argument that applies for each point

  chert.args &lt;- merge_list(list(x = chert.df$ms,
                                y = chert.df$dt), # Coordinates
                           chert, # Personalised arguments for cherts
                           all,   # Personalised arguments for all points
                           list(bg = "red"),       # Default arguments
                           list(pch = 21, cex = 2) # Default arguments
  )

  limestone.args &lt;- merge_list(list(x = limestone.df$ms,
                                    y = limestone.df$dt),
                               limestone, all,
                               list(bg = "red"), list(pch = 21, cex = 2))

  shale.args &lt;- merge_list(list(x = shale.df$ms, y = shale.df$dt),
                           shale, all,
                           list(bg = "red"), list(pch = 21, cex = 2))

  do.call(points, args = chert.args)
  do.call(points, args = limestone.args)
  do.call(points, args = shale.args)

}

omfrow &lt;- par()$mfrow

par(mfrow = c(1,3))

advanced.ex(main = "Default")

advanced.ex(main = "Change line and all",
            line.args = list(lty = 1),
            all = list(pch = 22))

advanced.ex(main = "Personalise more",
           line.args = list(lty = 1, col = "black"),
            all = list(pch = 22),
            shale = list(pch = 4))

par(mfrow = omfrow)

</code></pre>

<hr>
<h2 id='mid.lim'>Provides mid-points intervals in an ordered vector</h2><span id='topic+mid.lim'></span>

<h3>Description</h3>

<p>Provides mid-points intervals in an ordered vector
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mid.lim(x, id = 1L, b = "[]")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mid.lim_+3A_x">x</code></td>
<td>
<p>an ordered vector</p>
</td></tr>
<tr><td><code id="mid.lim_+3A_id">id</code></td>
<td>
<p>a vector of n interval IDs (default is 1 for each interval)</p>
</td></tr>
<tr><td><code id="mid.lim_+3A_b">b</code></td>
<td>
<p>a character vector for the interval boundaries rules, see
<code>as.lim</code> help page for details</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a lim object of intervals with boundaries at midway between the x
values
</p>


<h3>See Also</h3>

<p><code><a href="#topic+as.lim">as.lim</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>mid.lim(c(1,3,7,20,45,63))

</code></pre>

<hr>
<h2 id='minorAxis'>Adds an axis with minor ticks to a plot</h2><span id='topic+minorAxis'></span>

<h3>Description</h3>

<p>Adds an axis with minor ticks to a plot, but with the
possibility to have no superposition of minor ticks on major ticks, allowing
to export a clean plot in vector format. It is based on the
minor.tick function in the Hmisc package.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>minorAxis(
  side,
  n = NULL,
  at.maj = NULL,
  at.min = NULL,
  range = NULL,
  tick.ratio = 0.5,
  labels.maj = TRUE,
  line = NA,
  pos = NA,
  outer = FALSE,
  font = NA,
  lty = "solid",
  lwd = 1,
  lwd.ticks = lwd,
  col = NULL,
  col.ticks = NULL,
  hadj = NA,
  padj = NA,
  extend = FALSE,
  tcl = NA,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="minorAxis_+3A_side">side</code></td>
<td>
<p>an integer (here 1,2,3 or 4) specifying which side of the
plot the axis is to be drawn on. The axis is placed as follows: 1=below,
2=left, 3=above and, 4=right.</p>
</td></tr>
<tr><td><code id="minorAxis_+3A_n">n</code></td>
<td>
<p>the number of intervals defined by the minor ticks</p>
</td></tr>
<tr><td><code id="minorAxis_+3A_at.maj">at.maj</code></td>
<td>
<p>the positions at which major tick-marks are to be drawn.
By default (when NULL) tickmark locations are computed, see the &quot;Details&quot;
part in the ?axis help page.</p>
</td></tr>
<tr><td><code id="minorAxis_+3A_at.min">at.min</code></td>
<td>
<p>the positions at which minor tick-marks are to be drawn.
This parameter overrides n.</p>
</td></tr>
<tr><td><code id="minorAxis_+3A_range">range</code></td>
<td>
<p>the range of the axis</p>
</td></tr>
<tr><td><code id="minorAxis_+3A_tick.ratio">tick.ratio</code></td>
<td>
<p>ratio of lengths of minor tick marks to major tick
marks. The length of major tick marks is retrieved from par(&quot;tcl&quot;) unless
specified otherwise.</p>
</td></tr>
<tr><td><code id="minorAxis_+3A_labels.maj">labels.maj</code></td>
<td>
<p>this can either be a logical value specifying
whether (numerical) annotations are to be made at the major tickmarks, or a
character or expression vector of labels to be placed at the major
tickpoints.</p>
</td></tr>
<tr><td><code id="minorAxis_+3A_line">line</code>, <code id="minorAxis_+3A_pos">pos</code>, <code id="minorAxis_+3A_outer">outer</code>, <code id="minorAxis_+3A_font">font</code>, <code id="minorAxis_+3A_lty">lty</code>, <code id="minorAxis_+3A_lwd">lwd</code>, <code id="minorAxis_+3A_lwd.ticks">lwd.ticks</code>, <code id="minorAxis_+3A_col">col</code>, <code id="minorAxis_+3A_col.ticks">col.ticks</code>, <code id="minorAxis_+3A_hadj">hadj</code>, <code id="minorAxis_+3A_padj">padj</code>, <code id="minorAxis_+3A_tcl">tcl</code>, <code id="minorAxis_+3A_...">...</code></td>
<td>
<p>see the ?axis function help page for the other parameters</p>
</td></tr>
<tr><td><code id="minorAxis_+3A_extend">extend</code></td>
<td>
<p>whether to add minor ticks even outside the major ticks
(T) or not (F)</p>
</td></tr>
</table>


<h3>See Also</h3>

<p>Set a plot environment with minorAxis: <code><a href="#topic+whiteSet">whiteSet</a></code>,
<code><a href="#topic+blackSet">blackSet</a></code> and <code><a href="#topic+greySet">greySet</a></code>
</p>
<p>The ticks repartition is computed using <code><a href="#topic+minorAxisTicks">minorAxisTicks</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>plot.new()
plot.window(xlim = c(0,1), ylim = c(0,1))

minorAxis(1, n = 10, range = c(0.12,0.61))

minorAxis(3, n = 10, extend=FALSE)
</code></pre>

<hr>
<h2 id='minorAxisTicks'>Compute Pretty Minor Axis Tick Scales</h2><span id='topic+minorAxisTicks'></span>

<h3>Description</h3>

<p>Compute pretty mark locations for minor ticks, based on the way
that traditional R graphics do it.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>minorAxisTicks(usr, n = NULL, at.maj = NULL, extend = T)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="minorAxisTicks_+3A_usr">usr</code></td>
<td>
<p>the user coordinates of the minimum and maximum limits of the axis</p>
</td></tr>
<tr><td><code id="minorAxisTicks_+3A_n">n</code></td>
<td>
<p>the number of intervals defined by the minor ticks</p>
</td></tr>
<tr><td><code id="minorAxisTicks_+3A_at.maj">at.maj</code></td>
<td>
<p>the positions at which major tick-marks are to be drawn.
By default (when NULL) tickmark locations are computed buy the axisTicks
function</p>
</td></tr>
<tr><td><code id="minorAxisTicks_+3A_extend">extend</code></td>
<td>
<p>whether to add minor ticks even outside the major ticks
(T) or not (F)</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+minorAxis">minorAxis</a></code>, <code><a href="#topic+seq_log">seq_log</a></code>
</p>
<p>This function is based on <code><a href="#topic+every_nth">every_nth</a></code>, which suppresses values
every multiple of a given number.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>minorAxisTicks(usr = c(-20, 620), n = 10)

</code></pre>

<hr>
<h2 id='multigons'>Draws several polygons</h2><span id='topic+multigons'></span>

<h3>Description</h3>

<p>Draws several polygons. This function expands on the polygon()
function from base R graphics. The difference is that several polygons can
be drawn in one line by providing a polygon id: i. To each polygon you can
provide different graphical parameters (i.e. colour, shading, etc). On the
contrary of the polygon() function the graphical parameters of the shading
lines can be independent of the border lines.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>multigons(
  i,
  x,
  y,
  j = unique(i),
  forget = NULL,
  front = NULL,
  back = NULL,
  density = 0,
  angle = 45,
  border = "black",
  col = NA,
  lty = par("lty"),
  lwd = par("lwd"),
  scol = border,
  slty = lty,
  slwd = lwd,
  lend = 0,
  ljoin = 0,
  lmitre = 10
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="multigons_+3A_i">i</code></td>
<td>
<p>a polygon id for each x and y coordinate, i.e. the name of
each polygon. If you want to give each polygon a different aspect you should
provide a vector of n elements (if you have three polygons &quot;A1&quot;, &quot;A2&quot; and
&quot;A3&quot; with &quot;A2&quot; that should be blue you should provide the colours of all
three: e.g. <code>col = c("white", "blue", "white")</code>)</p>
</td></tr>
<tr><td><code id="multigons_+3A_x">x</code>, <code id="multigons_+3A_y">y</code></td>
<td>
<p>numeric vectors of x and y coordinates</p>
</td></tr>
<tr><td><code id="multigons_+3A_j">j</code></td>
<td>
<p>a list of the ids (names) in the order used for the
graphical parameters (e.g. colour, shading, etc...). By default they are in
their order of appearance in <code>i</code></p>
</td></tr>
<tr><td><code id="multigons_+3A_forget">forget</code></td>
<td>
<p>the polygons that should not be drawn, by their id or
index (i.e. name or number of appearance).</p>
</td></tr>
<tr><td><code id="multigons_+3A_front">front</code>, <code id="multigons_+3A_back">back</code></td>
<td>
<p>the polygons to be put in front and back position,
by their id or index (i.e. name or number of appearance). By default the
order is the one defined by <code>j</code>, and if <code>j</code> is absent by the order
in <code>i</code>.</p>
</td></tr>
<tr><td><code id="multigons_+3A_density">density</code></td>
<td>
<p>the density of shading lines, in lines per inch. The
default value of 0 means that no shading lines are drawn.</p>
</td></tr>
<tr><td><code id="multigons_+3A_angle">angle</code></td>
<td>
<p>the slope of shading lines, given as an angle in degrees
(counter-clockwise).</p>
</td></tr>
<tr><td><code id="multigons_+3A_border">border</code></td>
<td>
<p>the colour to draw the border. The default is black. Use
border = NA to omit borders.</p>
</td></tr>
<tr><td><code id="multigons_+3A_col">col</code></td>
<td>
<p>the colour for filling the polygon. The default, NA, is to
leave polygons unfilled.</p>
</td></tr>
<tr><td><code id="multigons_+3A_lty">lty</code>, <code id="multigons_+3A_lwd">lwd</code></td>
<td>
<p>the border line type and width, see ?par for details.</p>
</td></tr>
<tr><td><code id="multigons_+3A_scol">scol</code>, <code id="multigons_+3A_slty">slty</code>, <code id="multigons_+3A_slwd">slwd</code></td>
<td>
<p>the colour, type and width of the shading lines.</p>
</td></tr>
<tr><td><code id="multigons_+3A_lend">lend</code>, <code id="multigons_+3A_ljoin">ljoin</code>, <code id="multigons_+3A_lmitre">lmitre</code></td>
<td>
<p>additional graphical parameters, see ?par
for details.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>In the case you want shading this function will draw three
overlapping polygons: one for the background, one for the shading lines and
one for the border. <code>multigons</code> shares similarities with
<code><a href="#topic+centresvg">centresvg</a></code> and <code><a href="#topic+framesvg">framesvg</a></code>, but allows more advanced
control of each element.
</p>


<h3>See Also</h3>

<p>Similar functions: <code><a href="#topic+multilines">multilines</a></code>, <code><a href="#topic+infobar">infobar</a></code>
</p>
<p>Complementary function: <code><a href="#topic+shift">shift</a></code>
</p>
<p>Uses <code><a href="#topic+ignore">ignore</a></code> to avoid drawing unnecessary objects
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Simple use:

i &lt;- c(rep("A1",6), rep("A2",6), rep("A3",6)) # Polygon ids
x &lt;- c(1,2,3,3,2,1,2,3,4,4,3,2,3,4,5,5,4,3)   # x coordinates
y &lt;- c(1,2,3,4,5,6,1,2,3,4,5,6,1,2,3,4,5,6)   # y coordinates

plot(c(-1,7), c(-2,9), type = "n", xlab = "", ylab = "", main = "Simple use")

multigons(i, x, y,
          front = "A2", # This gets the polygon A2 in front of all others
          density = c(NA, 5, 10),  # Different shading density
          scol = "darkred", # Same shading colour
          col = c("black", "grey", "white"), # Different background colour
          lwd = 2, # Width of border lines for all polygons
          slty = 2, # Shading lines type, same for all polygons
          slwd = 1) # Shading lines width, same for all polygons

# Advanced use:
# Lets first create more polygons

i2 &lt;- c(i, rep("A4",6), rep("A5",6), rep("A6",6))
x2 &lt;- rep(x,2)
y2 &lt;- c(y, y - 4)

# Then lets attribute a group to each of them: lets say blue and red polygons

groups &lt;- data.frame(j = c("A1", "A2", "A3", "A4", "A5","A6"),
                      group = c("blue", "red", "blue", "red", "red", "blue"),
                      stringsAsFactors = FALSE)

# Then lets attribute different graphical parameters for each group

legend &lt;- data.frame(group = c("red", "blue"),
                     col = c("red", "blue"),
                     density = c(10,20),
                     scol = c("darkred", "darkblue"),
                      stringsAsFactors = FALSE)

 # Now that you have a data frame saying which polygon is in which group,
 # and one providing distinct graphical parameters for each group, you can
 # join the two with help of the dplyr package:

 library(dplyr)

 parameters &lt;- left_join(groups, legend, by = "group")

 # Then simply apply them to multigons:

 plot(c(0,12), c(-3,7), type = "n", xlab = "", ylab = "",
      main = "Advanced use")

 multigons(i2,x2,y2,
           forget = c("A1"),     # If you want to avoid drawing one polygon
           front = c("A2","A3"), # Puts A2 in front and A3 right behind
           col = parameters$col,
           density = parameters$density,
           scol = parameters$scol,
           lwd = 2)

# Another way (more advanced, but with interesting programming applications)
# to code this:

all.parameters &lt;- merge_list(list(i = i2, x = x2 + 6, y = y2),
                             as.list(parameters),
                             list(lwd = 3, slwd = 2, slty = 2))

all.parameters &lt;- all.parameters[!names(all.parameters) == "group"]

do.call(multigons, all.parameters)

</code></pre>

<hr>
<h2 id='multilines'>Draws several lines</h2><span id='topic+multilines'></span>

<h3>Description</h3>

<p>Draws several polylines or group of points. This function
expands on the lines() and points functions from base R graphics. The
difference is that several lines and group of points can
be drawn in one line by providing an id: i. To each line and group of point
you can provide different graphical parameters (i.e. colour, type, etc).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>multilines(
  i,
  x,
  y,
  j = unique(i),
  forget = NULL,
  front = NULL,
  back = NULL,
  type = "l",
  col = "black",
  bg = NA,
  pch = 19,
  lty = par("lty"),
  lwd = par("lwd"),
  cex = par("cex"),
  lend = 0,
  ljoin = 0,
  lmitre = 10
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="multilines_+3A_i">i</code></td>
<td>
<p>a  line id for each x and y coordinate, i.e. the name of
each polyline. If you want to give each line a different aspect you should
provide a vector of n elements (if you have three lines &quot;A1&quot;, &quot;A2&quot; and
&quot;A3&quot; with &quot;A2&quot; that should be blue you should provide the colours of all
three: e.g. <code>col = c("white", "blue", "white")</code>)</p>
</td></tr>
<tr><td><code id="multilines_+3A_x">x</code>, <code id="multilines_+3A_y">y</code></td>
<td>
<p>numeric vectors of x and y coordinates</p>
</td></tr>
<tr><td><code id="multilines_+3A_j">j</code></td>
<td>
<p>a list of the ids (names) in the order used for the
graphical parameters (e.g. colour, shading, etc...). By default they are in
their order of appearance in <code>i</code></p>
</td></tr>
<tr><td><code id="multilines_+3A_forget">forget</code></td>
<td>
<p>the lines that should not be drawn, by their id or
index (i.e. name or number of appearance).</p>
</td></tr>
<tr><td><code id="multilines_+3A_front">front</code>, <code id="multilines_+3A_back">back</code></td>
<td>
<p>the lines to be put in front and back position,
by their id or index (i.e. name or number of appearance). By default the
order is the one defined by <code>j</code>, and if <code>j</code> is absent by the order
in <code>i</code>.</p>
</td></tr>
<tr><td><code id="multilines_+3A_type">type</code></td>
<td>
<p>character indicating the type of plotting. For this
function it is limited to &quot;l&quot; (lines, is the default), &quot;p&quot; (points) and &quot;o&quot;
(points overplotting lines).</p>
</td></tr>
<tr><td><code id="multilines_+3A_col">col</code></td>
<td>
<p>the color to draw the line. The default is black.</p>
</td></tr>
<tr><td><code id="multilines_+3A_bg">bg</code></td>
<td>
<p>background (fill) color for the open plot symbols given by
pch = 21:25.</p>
</td></tr>
<tr><td><code id="multilines_+3A_pch">pch</code></td>
<td>
<p>plotting 'character', i.e., symbol to use. See ?points for
further details</p>
</td></tr>
<tr><td><code id="multilines_+3A_lty">lty</code>, <code id="multilines_+3A_lwd">lwd</code></td>
<td>
<p>the line type and width, see ?par for details.</p>
</td></tr>
<tr><td><code id="multilines_+3A_cex">cex</code></td>
<td>
<p>haracter (or symbol) expansion: a numerical vector. This
works as a multiple of par(&quot;cex&quot;)</p>
</td></tr>
<tr><td><code id="multilines_+3A_lend">lend</code>, <code id="multilines_+3A_ljoin">ljoin</code>, <code id="multilines_+3A_lmitre">lmitre</code></td>
<td>
<p>additional graphical parameters, see ?par
for details.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+multigons">multigons</a></code>
</p>
<p>Complementary function: <code><a href="#topic+shift">shift</a></code>
</p>
<p>Uses <code><a href="#topic+ignore">ignore</a></code> to avoid drawing unnecessary objects
</p>


<h3>Examples</h3>

<pre><code class='language-R'>i &lt;- c(rep("A1",6), rep("A2",6), rep("A3",6))
x &lt;- c(1,2,3,3,2,1,4,5,6,6,5,4,7,8,9,9,8,7)
y &lt;- c(1,2,3,4,5,6,1,2,3,4,5,6,1,2,3,4,5,6)

plot(c(0,10),c(0,7),type = "n")

multilines(i, x, y, j = c("A3", "A1", "A2"), lty =  c(1,2,3), lwd = 2,
           type = c("l", "o", "o"), pch = c(NA,21,24), cex = 2)

</code></pre>

<hr>
<h2 id='neatPick'>Interactive user modification of the arguments of a repeated function</h2><span id='topic+neatPick'></span>

<h3>Description</h3>

<p>This opens a shiny app that will allow to manipulate the
arguments of a function interactively, with different conditions that the
user can provide a priori and modify at will
</p>


<h3>Usage</h3>

<pre><code class='language-R'>neatPick(
  fun,
  n,
  args = list(),
  class.args = list(),
  pick = NA,
  fix = NA,
  buttonswidth = 2,
  text = "output",
  textwidth = 4,
  plotwidth = 800,
  plotheight = 600,
  args.only = F,
  width = 10,
  height = 10,
  name = "fig",
  dir = tempdir(),
  gfile = "onePDF",
  openfile = TRUE,
  folder = "Rfig",
  gfun = "jpeg",
  ext = ".jpeg",
  gargs = list(units = "in", res = 300),
  pargs = list(ps = 12, cex = 1.5)
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="neatPick_+3A_fun">fun</code></td>
<td>
<p>the function to be applied n times.</p>
</td></tr>
<tr><td><code id="neatPick_+3A_n">n</code></td>
<td>
<p>number of runs.</p>
</td></tr>
<tr><td><code id="neatPick_+3A_args">args</code></td>
<td>
<p>the arguments to be supplied to fun. Should be a list of
each argument to be supplied to fun, having n elements stored
indiscriminately in list or in vector form.</p>
</td></tr>
<tr><td><code id="neatPick_+3A_class.args">class.args</code></td>
<td>
<p>the class of the arguments, in a list. This is
useful when the starting arguments are NA</p>
</td></tr>
<tr><td><code id="neatPick_+3A_pick">pick</code></td>
<td>
<p>which arguments to be able to adapt interactively</p>
</td></tr>
<tr><td><code id="neatPick_+3A_fix">fix</code></td>
<td>
<p>which arguments that cannot be chosen interactively (if
pick is NA)</p>
</td></tr>
<tr><td><code id="neatPick_+3A_buttonswidth">buttonswidth</code></td>
<td>
<p>the width of the buttons panel (integer from 1 to
12)</p>
</td></tr>
<tr><td><code id="neatPick_+3A_text">text</code></td>
<td>
<p>which information to send to the text panel. The default
is the output of the current element (ni); &quot;output&quot;. Can be the whole dataset
of arguments; &quot;all&quot;. Otherwise the panel does not show.</p>
</td></tr>
<tr><td><code id="neatPick_+3A_textwidth">textwidth</code></td>
<td>
<p>the width of the text panel (integer from 1 to 12)</p>
</td></tr>
<tr><td><code id="neatPick_+3A_plotwidth">plotwidth</code></td>
<td>
<p>the width of the plot panel (arbitrary units)</p>
</td></tr>
<tr><td><code id="neatPick_+3A_plotheight">plotheight</code></td>
<td>
<p>the height of the plot panel (arbitrary units)</p>
</td></tr>
<tr><td><code id="neatPick_+3A_args.only">args.only</code></td>
<td>
<p>whether to be only allowed to download and return
the arguments (this simplifies things and makes the workflow more efficient)</p>
</td></tr>
<tr><td><code id="neatPick_+3A_width">width</code>, <code id="neatPick_+3A_height">height</code>, <code id="neatPick_+3A_name">name</code>, <code id="neatPick_+3A_dir">dir</code>, <code id="neatPick_+3A_gfile">gfile</code>, <code id="neatPick_+3A_openfile">openfile</code>, <code id="neatPick_+3A_folder">folder</code>, <code id="neatPick_+3A_gfun">gfun</code>, <code id="neatPick_+3A_ext">ext</code>, <code id="neatPick_+3A_gargs">gargs</code></td>
<td>
<p>arguments to be supplied to neatPicked, the equivalent
of neatPick without interactivity: it runs the function for each ni and
saves the output (normal and graphical). In neatPick this happens when the
button 'Run and Download Output' is clicked. See ?neatPicked function help
page for details.</p>
</td></tr>
<tr><td><code id="neatPick_+3A_pargs">pargs</code></td>
<td>
<p>the arguments to transmit to par(), in neatPick and
neatPicked</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This is a complicated function. A few basics:
</p>
<p>neatPick works using the formals() function. It evaluates the arguments
and their default values of any function that you provide without
parentheses, like this for instance: <code>formals(multigons)</code>.
</p>
<p>neatPick is capable of providing interaction with arguments of class integer
or numeric (e.g. 10, or 13,58745),  character (e.g. &quot;BlipBlapBLoup&quot;) and
logical (T or F), as long as for each iteration (n) the length of the
argument is one (you cannot use arguments like xlim = c(0,1), however you can
use xmin = 0 and xmax = 1 for instance). But you can provide a different
value for each iteration n (if n = 3, you can provide col = c(&quot;red&quot;, &quot;blue&quot;,
&quot;green&quot;) in the args list of arguments)
</p>
<p>You can chose which arguments are interactive or not using the 'pick' and
'fix' arguments.
</p>
<p>To return the arguments or the output, you have to click on 'End &amp; Return
Arguments' or 'End &amp; Return Output', respectively.
</p>
<p>You can also save the obtained output and arguments via the download buttons:
you geta .RData file were the arguments are in the object saved.arguments and
the output is in the saved.output object. The arguments can also be found at
saved.output$args. The arguments can be provided to the args argument of the
same neatPick function to rework the changes you made.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# You create a simple function. The one below creates sinusoidal waves between
# x0 = 0 and x1 = 1. You want to personalise the amplitude (delta), the y
# offset (pos, see ?sinpoint for more details), the phase (phase, expressed
# in multiples of pi), the number of waves between x0 and x1, and the number
# of intervals between each discrete point (nint).
# So you set all these as arguments of the function. This function can also
# have a graphical output of one plot (which can be subdivided if necessary
# using par(mfrow)). And the function can return output.

fun &lt;- function(delta = 1, pos = 1, phase = 1.5, nwave = 1, nint = 50)
{

  res &lt;- sinpoint(1, 0, delta = delta, pos = pos, phase = phase,
                  nwave = nwave, nint = nint)

  plot(res$x,res$y)

  return(res)

}

# Once this simple function is coded, it can be integrated to neatPick(). The
# argument n defines to number of different realisations of the function.

# WHEN YOU ARE HAPPY WITH THE OUTPUTS, click on 'END &amp; RETURN ARGUMENTS'

a &lt;- neatPick(fun, n = 10, args.only = TRUE)

# If you have clicked right (on the 'END &amp; RETURN ARGUMENTS' button), the
# arguments will be returned and stored in a;

a

# These arguments can then serve for a more efficient function:

seg &lt;- sinpoint(1, 0, delta = a$delta, pos = a$pos, phase = a$phase,
                nwave = a$nwave, nint = a$nint)

# Basically neatPick applies a for loop to fun, but if you work on a large
# dataset, you can also create a function that can handle the arguments more
# efficiently. This is what sinpoint does here

# Now you can see the results imported in R and do whatever you want with:

plot(seg$x, seg$y, type = "n")

multilines(seg$i, seg$x, seg$y)

# You can even rework your initial changes:

b &lt;- neatPick(fun, n = 10, args.only = TRUE, args = a)
## End(Not run)

</code></pre>

<hr>
<h2 id='neatPicked'>Runs neatPick without user input</h2><span id='topic+neatPicked'></span>

<h3>Description</h3>

<p>Is the user input free version of neatPick. Runs a function n
times, with its arguments n times different. The graphical output is stored
into a n pages pdf or a n files folder. The output of the function is
accumulated in a list.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>neatPicked(
  fun,
  n,
  args = NA,
  width = 10,
  height = 10,
  output = "all",
  name = "Fig",
  dir = tempdir(),
  gfile = "onePDF",
  openfile = TRUE,
  track = TRUE,
  folder = "My file",
  gfun = "jpeg",
  ext = ".jpeg",
  gargs = list(units = "in", res = 300),
  pargs = list()
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="neatPicked_+3A_fun">fun</code></td>
<td>
<p>the function to be applied n times.</p>
</td></tr>
<tr><td><code id="neatPicked_+3A_n">n</code></td>
<td>
<p>number of runs.</p>
</td></tr>
<tr><td><code id="neatPicked_+3A_args">args</code></td>
<td>
<p>the arguments to be supplied to fun. Should be a list of
each argument to be supplied to fun, having n elements stored
indiscriminately in list or in vector form.</p>
</td></tr>
<tr><td><code id="neatPicked_+3A_width">width</code>, <code id="neatPicked_+3A_height">height</code></td>
<td>
<p>the width and height of the graphics region. In
inches by default, can be adapted if onePDFfile = FALSE</p>
</td></tr>
<tr><td><code id="neatPicked_+3A_output">output</code></td>
<td>
<p>the kind of output : &quot;function&quot; for the accumulated
outputs of the function (list of n elements), &quot;all&quot; to add args, and
everything else to output nothing</p>
</td></tr>
<tr><td><code id="neatPicked_+3A_name">name</code></td>
<td>
<p>the names of the graphic file(s)</p>
</td></tr>
<tr><td><code id="neatPicked_+3A_dir">dir</code></td>
<td>
<p>the directory of the file or of the folder of files, by default a
temporary file</p>
</td></tr>
<tr><td><code id="neatPicked_+3A_gfile">gfile</code></td>
<td>
<p>whether to create a single pdf with n pages
(&quot;onePDF&quot;; default) or a folder of n graphical files (&quot;gfun&quot;). If anything
else is given (&quot;none for instance&quot;), it won't produce graphical files. This
reduces computation speed by a little more than 15 percents (one try of 1000
samples with simple graphs).</p>
</td></tr>
<tr><td><code id="neatPicked_+3A_openfile">openfile</code>, <code id="neatPicked_+3A_track">track</code></td>
<td>
<p>parameters for pdfDisplay()</p>
</td></tr>
<tr><td><code id="neatPicked_+3A_folder">folder</code></td>
<td>
<p>the name of the folder containing the n graphical files</p>
</td></tr>
<tr><td><code id="neatPicked_+3A_gfun">gfun</code></td>
<td>
<p>a non-empty character string naming the graphical
function to be called to create the n graphical files</p>
</td></tr>
<tr><td><code id="neatPicked_+3A_ext">ext</code></td>
<td>
<p>the extension of the n graphical files</p>
</td></tr>
<tr><td><code id="neatPicked_+3A_gargs">gargs</code></td>
<td>
<p>list of arguments transmitted to the graphical function</p>
</td></tr>
<tr><td><code id="neatPicked_+3A_pargs">pargs</code></td>
<td>
<p>list of arguments transmitted to the par() function</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the accumulated outputs of fun (and arguments if asked) if asked
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
fun &lt;- function(x, y, xlim = c(-1,1),...)
{
  plot(x, y, xlim = xlim,...)

  return(paste(x, y, paste(xlim, collapse = "; "), sep = "; "))
}

args &lt;- list(x = list(-0.5, 1) , y = c(0.8, 0.8), pch = c(2,4),
             xlim = list(c(-1,1), c(-20,20)))

temp &lt;- tempfile()
dir.create(temp)

neatPicked(fun, 2, args = args, width = 5, height = 5, dir = temp)
## End(Not run)

</code></pre>

<hr>
<h2 id='nlegend'>New legend element</h2><span id='topic+nlegend'></span>

<h3>Description</h3>

<p>Prepares a plotting environment for a new element of a
multifigure legend
</p>


<h3>Usage</h3>

<pre><code class='language-R'>nlegend(
  t = "Text",
  xt = 1.3,
  xmax = 5,
  xmin = -1.2,
  ymax = 1.5,
  ymin = -ymax,
  asp = NA,
  temp = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="nlegend_+3A_t">t</code></td>
<td>
<p>text to provide the legend</p>
</td></tr>
<tr><td><code id="nlegend_+3A_xt">xt</code></td>
<td>
<p>the x position of the text</p>
</td></tr>
<tr><td><code id="nlegend_+3A_xmin">xmin</code>, <code id="nlegend_+3A_xmax">xmax</code>, <code id="nlegend_+3A_ymin">ymin</code>, <code id="nlegend_+3A_ymax">ymax</code></td>
<td>
<p>the x and y limits for the plotting area</p>
</td></tr>
<tr><td><code id="nlegend_+3A_asp">asp</code></td>
<td>
<p>numeric, giving the aspect ratio y/x, see ‘Details’ of
<code><a href="graphics.html#topic+plot.window">plot.window</a></code>.</p>
</td></tr>
<tr><td><code id="nlegend_+3A_temp">temp</code></td>
<td>
<p>whether to plot a template for visualisation</p>
</td></tr>
<tr><td><code id="nlegend_+3A_...">...</code></td>
<td>
<p>parameters to be fed to the <code>text</code> function, such as
<code>cex</code> for the size of the text</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+multigons">multigons</a></code>, <code><a href="#topic+bedtext">bedtext</a></code>,
<code><a href="#topic+infobar">infobar</a></code> and <code><a href="#topic+ylink">ylink</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>opar &lt;- par("mar")

par(mar = c(0,0,0,0))

layout(matrix(1:6, 6, 1, byrow = TRUE))

nlegend(t = paste("Shaded stuff. By the way you can\nwrite",
                  "text in several lines if needed"), cex = 1.2)

rect(-1,-1,1,1, density = 10)

nlegend(t = paste0("Text: left side at x = 1.3 (default xt value)",
                   ";\nsize adapted with cex argument"),
                    temp = TRUE, cex = 1.4)

par(mar = opar)

</code></pre>

<hr>
<h2 id='nset'>Find indexes for n identical elements</h2><span id='topic+nset'></span>

<h3>Description</h3>

<p>For a given vector, this function gives the indexes of identical
sets for a given number of repetitions
</p>


<h3>Usage</h3>

<pre><code class='language-R'>nset(x, n, first = T, warn = T)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="nset_+3A_x">x</code></td>
<td>
<p>a vector, normally with repeated values</p>
</td></tr>
<tr><td><code id="nset_+3A_n">n</code></td>
<td>
<p>the amount of repetitions that needs to be identified</p>
</td></tr>
<tr><td><code id="nset_+3A_first">first</code></td>
<td>
<p>whether to take the first repetitions (T; is the default), or
the last ones (F)</p>
</td></tr>
<tr><td><code id="nset_+3A_warn">warn</code></td>
<td>
<p>whether to warn if NA values are generated due to the lack of
right amount of repetitions</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>ids &lt;- c(rep("A", 4), rep("B", 6), rep("C", 2))

val &lt;- paste(ids, c(1:4, 1:6, 1:2), sep = "")

nset(ids, 3, warn = FALSE)

matrix(val[nset(ids, 3, warn = FALSE)], ncol = 3)

matrix(val[nset(ids, 3, first = FALSE, warn = FALSE)], ncol = 3)

</code></pre>

<hr>
<h2 id='octapos'>Identify points in a polygon in reference to an octagon</h2><span id='topic+octapos'></span>

<h3>Description</h3>

<p>Identify points in a polygon as if they were constituting a
reference octagon, having two sides horizontal and two sides vertical: there
are eight points, starting from the right side of the upper horizontal side,
and following each other in a clockwise order.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>octapos(x, y, i = "I1", pos = 1:8)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="octapos_+3A_x">x</code>, <code id="octapos_+3A_y">y</code></td>
<td>
<p>the coordinates of the polygons</p>
</td></tr>
<tr><td><code id="octapos_+3A_i">i</code></td>
<td>
<p>the identification of the polygons if there are multiple ones</p>
</td></tr>
<tr><td><code id="octapos_+3A_pos">pos</code></td>
<td>
<p>which reference points to compute</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a data frame with as much columns as positions, labelled from pos1 to
pos8, or a vector if only one position is required
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Define polygons (in this case, two octagons) ----

dt1 &lt;- c(0,0,0.33,0.67,1,1,0.67,0.33) - 0.5
xy1 &lt;- c(0.33,0.67,1,1,0.67,0.33,0,0) - 0.5

dt2 &lt;- rev(0.5 * (c(0,0,0.33,0.67,1,1,0.67,0.33) - 0.5))
xy2 &lt;- rev(0.5 * (c(0.33,0.67,1,1,0.67,0.33,0,0) -0.5))

dt &lt;- c(dt1, dt2)
xy &lt;- c(xy1, xy2)
gr &lt;- rep(c("B2","A3"), each = 8)

# Compute the position to the octagon reference ----

octa &lt;- octapos(x = xy, y = dt, i = gr)

# Plot base----

plot.new()
plot.window(xlim = c(-0.5,0.5), ylim = c(-0.5,0.5))
axis(1)
axis(2, las = 1)
title(xlab = "x", ylab = "y")
polygon(x = xy1, y = dt1)
points(x = xy1, y = dt1, pch = 19)
polygon(x = xy2, y = dt2)
points(x = xy2, y = dt2, pch = 19)

# Plot the positions ----

one &lt;- rep(NA, nrow(octa))

one[octa$pos1] &lt;- 1
one[octa$pos2] &lt;- 2
one[octa$pos3] &lt;- 3
one[octa$pos4] &lt;- 4
one[octa$pos5] &lt;- 5
one[octa$pos6] &lt;- 6
one[octa$pos7] &lt;- 7
one[octa$pos8] &lt;- 8

text(0.8 * xy, 0.8 * dt, one)

</code></pre>

<hr>
<h2 id='octashift'>Shifts the order of polygon points</h2><span id='topic+octashift'></span>

<h3>Description</h3>

<p>Shifts the order of polygon points based on octagon-like
reference
</p>


<h3>Usage</h3>

<pre><code class='language-R'>octashift(x, y, i, pos, clockwise = NA)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="octashift_+3A_x">x</code>, <code id="octashift_+3A_y">y</code></td>
<td>
<p>the coordinates of the polygons</p>
</td></tr>
<tr><td><code id="octashift_+3A_i">i</code></td>
<td>
<p>the identification of the polygons if there are multiple ones</p>
</td></tr>
<tr><td><code id="octashift_+3A_pos">pos</code></td>
<td>
<p>an integer from 1 to 8 identifying a points, based on the
formalism of the <code><a href="#topic+octapos">octapos</a></code> function</p>
</td></tr>
<tr><td><code id="octashift_+3A_clockwise">clockwise</code></td>
<td>
<p>whether to have the points in the polygon be ordered
clockwise (T), counterclockwise (F). If NA (which is the default), this will
not be addressed</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a data frame with $x, $y and $i of the polygons as columns
</p>


<h3>Examples</h3>

<pre><code class='language-R'>xy &lt;- c(-3,-4,-3,0,-1,-2,-1,0,1,2,1,3,4,5,4,3)
dt &lt;- c(1,1.5,2,1,1,1.5,2,2,1,1.5,2,1,1,1.5,2,2)
id &lt;- c(rep("B1",3), rep("B2",5), rep("B3",3), rep("B4",5))

out &lt;- octashift(xy, dt, id, pos = 3, clockwise = TRUE)

par(mfrow = c(2,1))

plot.new()
plot.window(xlim = range(xy) + c(-1, 1), ylim = range(dt) + 0.5 * c(-1, 1))

axis(1)
axis(2)

multilines(i = id, x = xy, y = dt)

plot.new()
plot.window(xlim = range(xy) + c(-1, 1), ylim = range(dt) + 0.5 * c(-1, 1))

axis(1)
axis(2)

multilines(i = out$i, x = out$x, y = out$y)

</code></pre>

<hr>
<h2 id='outliner'>Find the points of a litholog that are along a given vertical line</h2><span id='topic+outliner'></span>

<h3>Description</h3>

<p>Through interpolation, this function identifies all the points
of a litholog that are at a given intensity value, along a vertical line.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>outliner(log, xy, add = F)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="outliner_+3A_log">log</code></td>
<td>
<p>a &quot;litholog()&quot;-like data frame</p>
</td></tr>
<tr><td><code id="outliner_+3A_xy">xy</code></td>
<td>
<p>the intensity value for the vertical line</p>
</td></tr>
<tr><td><code id="outliner_+3A_add">add</code></td>
<td>
<p>whether to have the interpolated points added to the litholog</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a data frame of the extracted vertical line or the litholog with
points along this line wherever the log intersects the vertical line, with
its i (bed identification), dt (depth/time), and xy (intensity).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>l &lt;- c(1,2,3,4,5)  # left boundary of the bed interval (upper or lower)
r &lt;- c(0,1,2,3,4)  # right boundary of the bed interval (upper or lower)
h &lt;- c(4,3,5,3,4) # hardness (arbitrary)
i &lt;- c("B1","B2","B3","B4","B5") # Bed name

olog &lt;- litholog(l,r,h,i) # Generate data frame of the polygons
                          # making the litholog

log &lt;- weldjoint(olog, c(1 ,4, 5), oufti99,
                 sym = c("1sin", "liquefaction", "1sin"),
                 ymax  = c(NA, 0.2, 0.2),
                 xmin  = c(0, 1, 0),
                 xmax  = c(4, 1.5, 3))

log_line &lt;- outliner(log, 2)

plot.new()
plot.window(xlim = c(0,5), ylim = c(0,5))

axis(1)
axis(2)

multigons(log$i, log$xy, log$d)

points(log_line$xy, log_line$dt, pch = 19, col = "red")

</code></pre>

<hr>
<h2 id='pdfDisplay'>Generates PDF and SVG figures</h2><span id='topic+pdfDisplay'></span>

<h3>Description</h3>

<p>Takes an ensemble of figures, represented by a function g(), and
generates a PDF (or SVG if specified). The PDF can be visualised immediatly
on the default PDF reader.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pdfDisplay(
  g,
  name,
  ext = ".pdf",
  dir = tempdir(),
  width = 10,
  height = 10,
  parg = list(),
  track = T,
  openfile = T,
  output = F,
  warn = F
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pdfDisplay_+3A_g">g</code></td>
<td>
<p>the plot function to be exported and looked at</p>
</td></tr>
<tr><td><code id="pdfDisplay_+3A_name">name</code></td>
<td>
<p>the name of the document</p>
</td></tr>
<tr><td><code id="pdfDisplay_+3A_ext">ext</code></td>
<td>
<p>the extension of the document: &quot;.pdf&quot; by default, but
&quot;.svg&quot; works also.</p>
</td></tr>
<tr><td><code id="pdfDisplay_+3A_dir">dir</code></td>
<td>
<p>the file where the document will be saved (by default a temporary
directory, tempdir())</p>
</td></tr>
<tr><td><code id="pdfDisplay_+3A_width">width</code></td>
<td>
<p>the width of the drawing area (in inches)</p>
</td></tr>
<tr><td><code id="pdfDisplay_+3A_height">height</code></td>
<td>
<p>the height of the drawing area (in inches)</p>
</td></tr>
<tr><td><code id="pdfDisplay_+3A_parg">parg</code></td>
<td>
<p>list of arguments transmitted to the par() function</p>
</td></tr>
<tr><td><code id="pdfDisplay_+3A_track">track</code></td>
<td>
<p>whether to generate different files for each rerun of pdfDisplay
with identical 'name'. The name will be followed by '_(i)' where i is the
version number. With this you avoid closing your pdf file at each rerun if
your pdf reader is not able to deal with (to my knowledge only SumatraPDF is
able)</p>
</td></tr>
<tr><td><code id="pdfDisplay_+3A_openfile">openfile</code></td>
<td>
<p>should the pdf file be opened (for the moment works
only in Windows). Use SumatraPDF as default pdf reader to be able to write
over current file</p>
</td></tr>
<tr><td><code id="pdfDisplay_+3A_output">output</code></td>
<td>
<p>whether to output the output of g() or not</p>
</td></tr>
<tr><td><code id="pdfDisplay_+3A_warn">warn</code></td>
<td>
<p>useless vestigial parameter, kept for compatibility with
StratigrapheR 0.0.1</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The width and height you provide will not exactly be respected.
I could not find a pdf printing function that respects dimensions
scrupulously for R base graphics.
</p>


<h3>Value</h3>

<p>the output of the g() function if output = TRUE
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
temp &lt;- tempfile()
dir.create(temp)

g1   &lt;- function() plot(1,1)

pdfDisplay(g1(),"TestGraph", dir = temp,
           parg = list(mar = c(6,6,6,6), ps = 24,lwd = 4))

g1   &lt;- function() plot(1,1, col = "red")

pdfDisplay(g1(), "TestGraph", dir = temp,
           parg = list(mar = c(6,6,6,6), ps = 24,lwd = 4))
## End(Not run)

</code></pre>

<hr>
<h2 id='pkgfind'>Find a specific pattern in the code of functions in a package</h2><span id='topic+pkgfind'></span>

<h3>Description</h3>

<p>This function names all the functions in a package that contain
a specific character pattern, typically the name of a function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pkgfind(pkg, pattern)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pkgfind_+3A_pkg">pkg</code></td>
<td>
<p>a character string of the package to search in</p>
</td></tr>
<tr><td><code id="pkgfind_+3A_pattern">pattern</code></td>
<td>
<p>the pattern to search in the codes of the functions in the
package</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a vector of the names of the functions in which the
pattern is identified
</p>


<h3>Examples</h3>

<pre><code class='language-R'>pkgfind("StratigrapheR", "every_nth")

</code></pre>

<hr>
<h2 id='placesvg'>Draws a pointsvg object</h2><span id='topic+placesvg'></span>

<h3>Description</h3>

<p>Draws a svg object imported as data frame using
<code><a href="#topic+pointsvg">pointsvg</a></code>, with its importation coordinates (or with
standardisation).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>placesvg(
  object,
  forget = NULL,
  front = NULL,
  back = NULL,
  standard = FALSE,
  keep.ratio = FALSE,
  col = NA,
  border = "black",
  density = NULL,
  angle = 45,
  lwd = par("lwd"),
  lty = par("lty"),
  scol = border,
  slty = lty,
  slwd = lwd
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="placesvg_+3A_object">object</code></td>
<td>
<p>a pointsvg object (svg object imported as data frame
using <code><a href="#topic+pointsvg">pointsvg</a></code>).</p>
</td></tr>
<tr><td><code id="placesvg_+3A_forget">forget</code></td>
<td>
<p>the elements that should be discarded, by their id
or index (i.e. name or number of appearance).</p>
</td></tr>
<tr><td><code id="placesvg_+3A_front">front</code>, <code id="placesvg_+3A_back">back</code></td>
<td>
<p>the elements to be put in front and back position,
by their id or index (i.e. name or number of appearance). By default the
order is the one of the original .svg file.</p>
</td></tr>
<tr><td><code id="placesvg_+3A_standard">standard</code></td>
<td>
<p>whether to standardise (centre to (0,0), rescale so
that extreme points are at -1 and 1) or not (T or F)</p>
</td></tr>
<tr><td><code id="placesvg_+3A_keep.ratio">keep.ratio</code></td>
<td>
<p>if the object is to be  standardised, whether to
keep the x/y ratio (T or F)</p>
</td></tr>
<tr><td><code id="placesvg_+3A_col">col</code></td>
<td>
<p>the polygones background color. If density is specified with
a positive value this gives the color of the shading lines.</p>
</td></tr>
<tr><td><code id="placesvg_+3A_border">border</code></td>
<td>
<p>the lines color.</p>
</td></tr>
<tr><td><code id="placesvg_+3A_density">density</code></td>
<td>
<p>the density of shading lines, in lines per inch. The
default value of NULL means that no shading lines are drawn.</p>
</td></tr>
<tr><td><code id="placesvg_+3A_angle">angle</code></td>
<td>
<p>the slope of shading lines, given as an angle in degrees
(counter-clockwise)</p>
</td></tr>
<tr><td><code id="placesvg_+3A_lty">lty</code>, <code id="placesvg_+3A_lwd">lwd</code></td>
<td>
<p>the border line type and width, see ?par for details.</p>
</td></tr>
<tr><td><code id="placesvg_+3A_scol">scol</code>, <code id="placesvg_+3A_slty">slty</code>, <code id="placesvg_+3A_slwd">slwd</code></td>
<td>
<p>the colour, type and width of the shading lines.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+centresvg">centresvg</a></code> and <code><a href="#topic+framesvg">framesvg</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>object &lt;- example.ammonite

plot(c(-2,2), c(-2,2), type = "n")

placesvg(object, lty = 1,density = 20, angle = 45)

</code></pre>

<hr>
<h2 id='planepoints'>Describes planes by points</h2><span id='topic+planepoints'></span>

<h3>Description</h3>

<p>Gives the coordinates (dec and inc) of three perpendicular
directions to describe planes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>planepoints(strike, dip, quadrant = NA, inverted = NA)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="planepoints_+3A_strike">strike</code></td>
<td>
<p>strike of the data; it is the angle from the north of
the horizontal line of the plane. It is corrected by dipfix().</p>
</td></tr>
<tr><td><code id="planepoints_+3A_dip">dip</code></td>
<td>
<p>dip of the data; it is the angle from the horizontal taken
on the line of the plane perpendicular to the one of the strike. It is
corrected by dipfix().</p>
</td></tr>
<tr><td><code id="planepoints_+3A_quadrant">quadrant</code></td>
<td>
<p>the quadrant where the plane dips downward. Accepted
values are NA, 'N', 'S', 'W' or 'E' (lower- or uppercase alike) for
correction by dipfix().</p>
</td></tr>
<tr><td><code id="planepoints_+3A_inverted">inverted</code></td>
<td>
<p>whether the plane is inverted or not. The default is
NA, it assumes that no bed is inverted.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The directions are x for dip-direction line (direction of maximum
downward dip), y for the horizontal line, z for the upper pole; additionally
a magnitude is given to use y as a rotation axis to get the plane back at the
horizontal. If the plane is inverted, y, z and mag will be changed,
accordingly, with a rotation of 180° around x for y and z.
</p>


<h3>Value</h3>

<p>a list of x, y and z declinations and inclinations (dec and inc), and
a rotation magnitude
</p>


<h3>Examples</h3>

<pre><code class='language-R'>strike   &lt;- c(-60, 180,20)
dip      &lt;- c(-60,20,-45)
quadrant &lt;- c("N","W",NA)
inverted &lt;- c(FALSE,FALSE,TRUE)

res &lt;- planepoints(strike,dip,quadrant,inverted)

deci &lt;- c(res$x$dec, res$y$dec, res$z$dec)
inci &lt;- c(res$x$inc, res$y$inc, res$z$inc)

earnet()

earplanes(strike,dip,quadrant,hsphere = "l")
earpoints(deci,inci)

</code></pre>

<hr>
<h2 id='pointsvg'>Converts line, rect, polygon and polyline class SVG objects into
data frames</h2><span id='topic+pointsvg'></span><span id='topic+is.pointsvg'></span>

<h3>Description</h3>

<p>Converts 'line', 'rect', 'polygon' and 'polyline' class SVG
objects into data frames. <strong>ONLY THESE CLASSES OF OBJECTS CAN BE
IMPORTED.</strong> If you have bezier or spline curves, they will be stored as 'path'
class objects that cannot be imported here. The same goes for 'rect' objects
that are transformed (rotation, etc...).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pointsvg(
  file,
  standard = TRUE,
  keep.ratio = FALSE,
  round = TRUE,
  xdigits = 4,
  ydigits = 4,
  xinverse = FALSE,
  yinverse = TRUE,
  warn = T
)

is.pointsvg(object)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pointsvg_+3A_file">file</code></td>
<td>
<p>a .svg file</p>
</td></tr>
<tr><td><code id="pointsvg_+3A_standard">standard</code></td>
<td>
<p>whether to standardise (centre to (0,0), rescale so
that extreme points are at -1 and 1) (T or F)</p>
</td></tr>
<tr><td><code id="pointsvg_+3A_keep.ratio">keep.ratio</code></td>
<td>
<p>if the object is to be  standardised, whether to
keep the x/y ratio (T or F)</p>
</td></tr>
<tr><td><code id="pointsvg_+3A_round">round</code></td>
<td>
<p>whether to round the coordinates (T or F)</p>
</td></tr>
<tr><td><code id="pointsvg_+3A_xdigits">xdigits</code></td>
<td>
<p>the number of digits after the decimal to round to for
x values</p>
</td></tr>
<tr><td><code id="pointsvg_+3A_ydigits">ydigits</code></td>
<td>
<p>the number of digits after the decimal to round to for
y values</p>
</td></tr>
<tr><td><code id="pointsvg_+3A_xinverse">xinverse</code></td>
<td>
<p>whether to inverse the plotting for x values (T or F)</p>
</td></tr>
<tr><td><code id="pointsvg_+3A_yinverse">yinverse</code></td>
<td>
<p>whether to inverse the plotting for y values (T or F)</p>
</td></tr>
<tr><td><code id="pointsvg_+3A_warn">warn</code></td>
<td>
<p>whether you want to be annoyed</p>
</td></tr>
<tr><td><code id="pointsvg_+3A_object">object</code></td>
<td>
<p>for is.pointsvg, the R object to be checked if it can be
considered similarly to a svg outputted by pointsvg</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is quite empirical. There is no guarantee it is bug
free. If you have .svg files that should work but do not, you can email me:
<a href="mailto:wouterseb@gmail.com">wouterseb@gmail.com</a>
</p>


<h3>Value</h3>

<p>A data.frame with x and y coordinates, ids for each object, and a
type, either line (L) or polygon (P)
</p>


<h3>See Also</h3>

<p>Plot the drawing: <code><a href="#topic+placesvg">placesvg</a></code>,
</p>
<p>Plot the drawing and change the coordinates :<code><a href="#topic+centresvg">centresvg</a></code> and
<code><a href="#topic+framesvg">framesvg</a></code>
</p>
<p>Change the drawing: <code><a href="#topic+changesvg">changesvg</a></code> and <code><a href="#topic+clipsvg">clipsvg</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># To show you how to import, we first have to have a svg file to import. The
#following lines of code will create a svg in a temporary files:

svg.file.directory &lt;- tempfile(fileext = ".svg") # Creates temporary file
writeLines(example.ammonite.svg, svg.file.directory) # Writes svg in the file

print(paste("An example .svg file was created at ", svg.file.directory,
            sep = ""))

# The pointsvg function allows to import simple svg drawings into R

ammonite.drawing &lt;- pointsvg(file = svg.file.directory) # Provide file

is.pointsvg(ammonite.drawing)

plot(c(-2,2), c(-2,2), type = "n")

placesvg(ammonite.drawing)

# If you want to import your own .svg file uncomment the following line:

# pointsvg(file.choose())

</code></pre>

<hr>
<h2 id='profiler'>Extract the profile of a litholog</h2><span id='topic+profiler'></span>

<h3>Description</h3>

<p>Extract the induration, grain-size, lithology, facies, or any
other information coded in the profile variations of a litholog.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>profiler(log, gap, ext = Inf, down.xy = NA, up.xy = NA, warn = F)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="profiler_+3A_log">log</code></td>
<td>
<p>a &quot;litholog()&quot;-like data frame</p>
</td></tr>
<tr><td><code id="profiler_+3A_gap">gap</code></td>
<td>
<p>the most inward values of the profile, i.e. the minimum values
expected in the signal</p>
</td></tr>
<tr><td><code id="profiler_+3A_ext">ext</code></td>
<td>
<p>the most outward values of the profile; defaults to infinity Inf,
for &quot;left-side&quot; profiles, set to -Inf</p>
</td></tr>
<tr><td><code id="profiler_+3A_down.xy">down.xy</code>, <code id="profiler_+3A_up.xy">up.xy</code></td>
<td>
<p>the xy values to give the the lower and upper parts of
the signal.</p>
</td></tr>
<tr><td><code id="profiler_+3A_warn">warn</code></td>
<td>
<p>whether to have a detailed explanation of problems with the
extraction of a profile. This is useful to diagnose strange outputs.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a data frame of the extracted profile, with its i (bed
identification), dt (depth/time), and xy (intensity).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>l &lt;- c(1,2,3,4,5)  # left boundary of the bed interval (upper or lower)
r &lt;- c(0,1,2,3,4)  # right boundary of the bed interval (upper or lower)
h &lt;- c(4,3,4,2,3) # hardness (arbitrary)
i &lt;- c("B1","B2","B3","B4","B5") # Bed name

log &lt;- litholog(l,r,h,i) # Generate data frame of the polygons
                         # making the litholog

# Extract the profile of the litholog, with the upper and lower values set
# at a value of 2 ----

pro &lt;- profiler(log, gap = 2, up.xy = 2, down.xy = 2)

opar &lt;- par()$mfrow

par(mfrow = c(1,2))

# Draw the litholog ----

plot.new()
plot.window(xlim = c(0,4), ylim = c(0,5))

axis(1)
axis(2)

multigons(log$i, log$xy, log$dt,
          col = c("grey80","grey20","grey80","grey20","grey80")) # Draw log

# Draw the profile ----

plot(pro$xy, pro$dt, type = "l", xlab = "hardness", ylab = "", axes = FALSE)

axis(1)

par(mfrow = opar)

</code></pre>

<hr>
<h2 id='rebound'>Simplifies boundary indicators for lim objects</h2><span id='topic+rebound'></span>

<h3>Description</h3>

<p>Simplifies boundary indicators for lim objects: from the wide
range supported by R (&quot;[]&quot;, &quot;[)&quot;, &quot;(]&quot;, &quot;()&quot;, &quot;[[&quot;, &quot;]]&quot;, &quot;][&quot;, &quot;open&quot;,
&quot;closed&quot;, &quot;left-open&quot;, &quot;right-open&quot;, &quot;left-closed&quot;, &quot;right-closed&quot;) to &quot;[]&quot;,
&quot;[[&quot;, &quot;]]&quot; and &quot;][&quot; only
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rebound(b, na.errors = F)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rebound_+3A_b">b</code></td>
<td>
<p>a vector of boundary indicators</p>
</td></tr>
<tr><td><code id="rebound_+3A_na.errors">na.errors</code></td>
<td>
<p>whether to replace all other values by NA (rather
than simply stopping the function)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a simplified vector of boundary indicators (<code>"[]"</code>, <code>"[["</code>,
<code>"]]"</code> and <code>"]["</code> only)
</p>


<h3>See Also</h3>

<p><code><a href="#topic+as.lim">as.lim</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>bounds &lt;- c("[]", "[)", "(]", "()",
            "[[", "]]", "][",
            "open", "closed",
            "left-open", "right-open",
            "left-closed", "right-closed")

rebound(bounds)

</code></pre>

<hr>
<h2 id='repitch'>Converts pitch into declination and inclination</h2><span id='topic+repitch'></span>

<h3>Description</h3>

<p>Finds the declination and inclination of a line defined by a
pitch on a plane
</p>


<h3>Usage</h3>

<pre><code class='language-R'>repitch(pitch, strike, dip, quadrant = NA)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="repitch_+3A_pitch">pitch</code></td>
<td>
<p>pitch (or rake) of the data; it is the angle between the
strike of the plane and a line. It is taken from the left side going downward
along the dip, and is positive downward.</p>
</td></tr>
<tr><td><code id="repitch_+3A_strike">strike</code></td>
<td>
<p>strike of the data; it is the angle from the north of
the horizontal line of the plane. It is corrected by the <code><a href="#topic+dipfix">dipfix</a></code>
function.</p>
</td></tr>
<tr><td><code id="repitch_+3A_dip">dip</code></td>
<td>
<p>dip of the data; it is the angle from the horizontal taken
on the line of the plane perpendicular to the one of the strike. It is
corrected by the <code><a href="#topic+dipfix">dipfix</a></code> function.</p>
</td></tr>
<tr><td><code id="repitch_+3A_quadrant">quadrant</code></td>
<td>
<p>the quadrant were the plane dips downward. Accepted
values are NA, 'N', 'S', 'W' or 'E' (lower- or uppercase alike) for
correction by the <code><a href="#topic+dipfix">dipfix</a></code> function.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list of declination and inclination of the defined lines
</p>


<h3>References</h3>

<p>Eric Carlson of the Colorado School of Mines is acknowledged for
his rake to plunge calculator on which this function is based.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+dipfix">dipfix</a></code>, <code><a href="#topic+incfix">incfix</a></code> and
<code><a href="#topic+transphere">transphere</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>strike &lt;- c(90, 135, 135, 135)
dip    &lt;- c(0,  65,  65,  65)
pitch  &lt;- c(40, 40,  140, -40)

earnet()
earplanes(strike,dip,hsphere = "b", a = list(col = "red", lwd = 2))

res &lt;- repitch(pitch = pitch, strike = strike, dip = dip)

earpoints(dec = res$dec, inc = res$inc)

</code></pre>

<hr>
<h2 id='reposition'>Core correction</h2><span id='topic+reposition'></span>

<h3>Description</h3>

<p>Core correction : declination and inclination are corrected for
cores of given declination, inclination and rotation
</p>


<h3>Usage</h3>

<pre><code class='language-R'>reposition(dec, inc, cdec = 0, cinc = 90, crot = 0)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="reposition_+3A_dec">dec</code></td>
<td>
<p>declination of the data; it is the angle from the north
taken on an horizontal plane. It is measured clockwise from North and ranges
from 0 to 360° (Tauxe 2010).</p>
</td></tr>
<tr><td><code id="reposition_+3A_inc">inc</code></td>
<td>
<p>inclination of the data; it is the angle from the
horizontal, is positive downward, and ranges from +90° for straight down to
-90° for straight up (Tauxe, 2010).</p>
</td></tr>
<tr><td><code id="reposition_+3A_cdec">cdec</code></td>
<td>
<p>declination of the core.</p>
</td></tr>
<tr><td><code id="reposition_+3A_cinc">cinc</code></td>
<td>
<p>inclination of the core.</p>
</td></tr>
<tr><td><code id="reposition_+3A_crot">crot</code></td>
<td>
<p>rotation of the core; it is the angle of rotation around
the core direction clockwise between the measurement and the actual core
orientation. In others words it is the magnitude of the rotation to apply
clockwise to the measured data using the core direction as an axis.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+rotate">rotate</a></code> and <code><a href="#topic+restore">restore</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># ----

d &lt;- zeq_example

dec &lt;- d$Dec
inc &lt;- d$Inc

cdec &lt;- 75
cinc &lt;- 45
crot &lt;- 90

par(mfrow = c(2,2))

earnet()
earpoints(dec,inc)
earpoints(0, 90, l = list(cex = 2))
earpoints(0, 90, l = list(col = "red", bg = "red"))
title("1. Laboratory projection,
      axis for rotating the specimen")

# Roll ----

roll &lt;- reposition(dec, inc, crot = 90)

earnet()
earpoints(roll$dec,roll$inc)
earpoints(0, 90, l = list(cex = 2))
earpoints(90, 0, h = list(col = "red", bg = "pink"), double = TRUE)
title("2. Correction of the specimen rotation,
      in red the axis for tilting the specimen")

# Tilt ---

tilt &lt;- reposition(dec, inc, cinc = cinc ,crot = crot)

earnet()
earpoints(0, cinc, l = list(cex = 2))
earpoints(tilt$dec, tilt$inc)
earpoints(0,90, l = list(col = "red", bg = "red"))
title("3. Correction of the specimen inclination,
      in red the axis for rotating the tilted specimen")

# Orient ---

orient &lt;- reposition(dec, inc, cdec = cdec, cinc = cinc ,crot = crot)

earnet()
earpoints(cdec, cinc, l = list(cex = 2))
earpoints(orient$dec, orient$inc)
title("4. Full geographical repositioning,
      the big dot is the core orientation")

par(mfrow = c(1,1))

# ----

</code></pre>

<hr>
<h2 id='restore'>Plane correction</h2><span id='topic+restore'></span>

<h3>Description</h3>

<p>Plane correction : declination and inclination are corrected for
planes of given strike, dip, quadrant and inversion
</p>


<h3>Usage</h3>

<pre><code class='language-R'>restore(dec, inc, strike, dip, quadrant = NA, inverted = NA, percent = 100)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="restore_+3A_dec">dec</code></td>
<td>
<p>declination of the data; it is the angle from the north
taken on an horizontal plane. It is measured clockwise from North and ranges
from 0 to 360° (Tauxe 2010).</p>
</td></tr>
<tr><td><code id="restore_+3A_inc">inc</code></td>
<td>
<p>inclination of the data; it is the angle from the
horizontal, is positive downward, and ranges from +90° for straight down to
-90° for straight up (Tauxe, 2010).</p>
</td></tr>
<tr><td><code id="restore_+3A_strike">strike</code></td>
<td>
<p>strike of the plane used for correction; it is the angle
from the north of the horizontal line of the plane. It is corrected by
dipfix().</p>
</td></tr>
<tr><td><code id="restore_+3A_dip">dip</code></td>
<td>
<p>dip of the plane used for correction; it is the angle from
the horizontal taken on the line of the plane perpendicular to the one of
the strike. It is corrected by dipfix().</p>
</td></tr>
<tr><td><code id="restore_+3A_quadrant">quadrant</code></td>
<td>
<p>the quadrant were the plane dips downward. Accepted
values are NA, 'N', 'S', 'W' or 'E' (lower- or uppercase alike) for
correction by dipfix().</p>
</td></tr>
<tr><td><code id="restore_+3A_inverted">inverted</code></td>
<td>
<p>whether the plane is inverted or not. The default is
NA, it assumes that no bed is inverted.</p>
</td></tr>
<tr><td><code id="restore_+3A_percent">percent</code></td>
<td>
<p>the percentage of correction (can be of length &gt;= 1),
by default it is 100 (%), bringing the plane to the horizontal.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+rotate">rotate</a></code> and <code><a href="#topic+reposition">reposition</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>dec &lt;- c(90,210)
inc &lt;- c(20,60)

strike &lt;- c(0,120)
dip    &lt;- c(20,60)
inverted &lt;- c(FALSE,TRUE)

res &lt;- restore(dec = dec, inc = inc, strike = strike, dip = dip,
               quadrant = NA, inverted = inverted,
               percent = seq(20,100, by = 20))

earnet()
earplanes(strike, dip)
earpoints(dec,inc)
earpoints(round(res$dec,2), round(res$inc,2), a = list(pch = 22))

</code></pre>

<hr>
<h2 id='rmatrix'>Rotation matrix</h2><span id='topic+rmatrix'></span>

<h3>Description</h3>

<p>Computes a rotation matrix for a given rotation axis and angle
based on Tauxe et al. (2010).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rmatrix(dec, inc, mag, as.data.frame = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rmatrix_+3A_dec">dec</code></td>
<td>
<p>declination of the rotation axis; it is the angle from the
north taken on an horizontal plane. It is measured clockwise from North and
ranges from 0 to 360° (Tauxe 2010).</p>
</td></tr>
<tr><td><code id="rmatrix_+3A_inc">inc</code></td>
<td>
<p>inclination of the rotation axis; it is the angle from the
horizontal, is positive downward, and ranges from +90° for straight down to
-90° for straight up (Tauxe, 2010).</p>
</td></tr>
<tr><td><code id="rmatrix_+3A_mag">mag</code></td>
<td>
<p>magnitude of rotation (following the notation of the
Stereonet software) a positive rotation is clockwise looking in the direction
of the given declination and inclination)</p>
</td></tr>
<tr><td><code id="rmatrix_+3A_as.data.frame">as.data.frame</code></td>
<td>
<p>logical, whether to output the matrix as a data
frame. This is used when multiple arguments are provided to simplify and
boost calculations.</p>
</td></tr>
</table>


<h3>References</h3>


<ul>
<li><p> Tauxe, L., 2010. Essentials of Paleomagnetism. University of
California Press.
</p>
</li>
<li><p> Allmendinger, R. W., Cardozo, N. C., and Fisher, D., 2013, Structural
Geology Algorithms: Vectors &amp; Tensors: Cambridge, England, Cambridge
University Press, 289 pp.
</p>
</li>
<li><p> Cardozo, N., and Allmendinger, R. W., 2013, Spherical projections
with OSXStereonet: Computers &amp; Geosciences, v. 51, no. 0, p. 193 - 205,
doi: 10.1016/j.cageo.2012.07.021
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>rmatrix(135,20,60)

rmatrix(c(135,0),c(20,90),c(60,90), as.data.frame = TRUE)

</code></pre>

<hr>
<h2 id='rotate'>Spherical rotation around fixed axes</h2><span id='topic+rotate'></span>

<h3>Description</h3>

<p>Spherical rotation around given rotation axes
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rotate(dec, inc, rdec, rinc, rmag)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rotate_+3A_dec">dec</code></td>
<td>
<p>declination of the data; it is the angle from the north
taken on an horizontal plane. It is measured clockwise from North and ranges
from 0 to 360° (Tauxe 2010).</p>
</td></tr>
<tr><td><code id="rotate_+3A_inc">inc</code></td>
<td>
<p>inclination of the data; it is the angle from the
horizontal, is positive downward, and ranges from +90° for straight down to
-90° for straight up (Tauxe, 2010).</p>
</td></tr>
<tr><td><code id="rotate_+3A_rdec">rdec</code></td>
<td>
<p>declination of the rotation axes (of length 1 or n).</p>
</td></tr>
<tr><td><code id="rotate_+3A_rinc">rinc</code></td>
<td>
<p>inclination of the rotation axes (of length 1 or n).</p>
</td></tr>
<tr><td><code id="rotate_+3A_rmag">rmag</code></td>
<td>
<p>magnitude of rotation (following the notation of the
Stereonet software): a positive rotation is clockwise looking in the
direction of the given declination and inclination; of length 1 or n).</p>
</td></tr>
</table>


<h3>References</h3>


<ul>
<li><p> Tauxe, L., 2010. Essentials of Paleomagnetism. University of
California Press.
</p>
</li>
<li><p> Allmendinger, R. W., Cardozo, N. C., and Fisher, D., 2013, Structural
Geology Algorithms: Vectors &amp; Tensors: Cambridge, England, Cambridge
University Press, 289 pp.
</p>
</li>
<li><p> Cardozo, N., and Allmendinger, R. W., 2013, Spherical projections
with OSXStereonet: Computers &amp; Geosciences, v. 51, no. 0, p. 193 - 205,
doi: 10.1016/j.cageo.2012.07.021
</p>
</li></ul>



<h3>See Also</h3>

<p><code><a href="#topic+rmatrix">rmatrix</a></code>, <code><a href="#topic+restore">restore</a></code> and
<code><a href="#topic+reposition">reposition</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>earnet()

inc &lt;- seq(0,85,5)
dec &lt;- rep(0,length(inc))

earpoints(dec,inc)

rdec &lt;- rep(0, length(inc))
rinc &lt;- rep(90, length(inc))

mag &lt;- 90
rmag  &lt;- seq(mag, 0, by = -mag/(length(inc)-1))

rot &lt;- rotate(dec,inc,rdec,rinc,rmag)

earpoints(dec = round(rot$dec,digits = 2), inc = round(rot$inc,digits = 2),
          l = list(bg = "green"),
          u = list(bg = "blue"),
          h = list(bg = "yellow"))

earpoints(dec = 0, inc = 90, l = list(bg = "red"))

</code></pre>

<hr>
<h2 id='seq_log'>Gives the repartition of values for a log 10 scale between a given interval</h2><span id='topic+seq_log'></span>

<h3>Description</h3>

<p>Gives the repartition of values for a log 10 scale between a given interval
</p>


<h3>Usage</h3>

<pre><code class='language-R'>seq_log(x1, x2, divide = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="seq_log_+3A_x1">x1</code></td>
<td>
<p>the first value of the interval</p>
</td></tr>
<tr><td><code id="seq_log_+3A_x2">x2</code></td>
<td>
<p>the second value of the interval (can be higher or lower,
but never equal to x1)</p>
</td></tr>
<tr><td><code id="seq_log_+3A_divide">divide</code></td>
<td>
<p>whether to divide the result for major values (1,10,100)
and minor values (2,3,...,20,30,...)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the repartition of values for a log 10 scale between x1 and x2
</p>


<h3>See Also</h3>

<p><code><a href="#topic+convertAxis">convertAxis</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x1 &lt;- 101
x2 &lt;- 0.29

seq_log(x1, x2)
seq_log(x1, x2, divide = TRUE)

</code></pre>

<hr>
<h2 id='seq_mult'>Sequence ordered by multiple</h2><span id='topic+seq_mult'></span>

<h3>Description</h3>

<p>Sequence ordered by multiple
</p>


<h3>Usage</h3>

<pre><code class='language-R'>seq_mult(l, mult, inv = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="seq_mult_+3A_l">l</code></td>
<td>
<p>the length of the sequence, or an object convertile into a vector
from which to determine the length from</p>
</td></tr>
<tr><td><code id="seq_mult_+3A_mult">mult</code></td>
<td>
<p>the multiple to order by</p>
</td></tr>
<tr><td><code id="seq_mult_+3A_inv">inv</code></td>
<td>
<p>whether to change mult into l/mult</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>seq_mult(10, 2)

seq_mult(15,3)

seq_mult(24,8)

seq_mult(seq(0.5,12,0.5),8)

seq_mult(10,2)[seq_mult(10,5)]

seq_mult(10,2)[seq_mult(10,2, inv = TRUE)]

</code></pre>

<hr>
<h2 id='shift'>Circular shift</h2><span id='topic+shift'></span>

<h3>Description</h3>

<p>Circular shift; the order of points will be lagged as if the
beginning is preceded by the end.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>shift(x, n = 1L, p = -n + 1L, i = NA, names = T)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="shift_+3A_x">x</code></td>
<td>
<p>a vector (characters, numerics, integers,...), data.frame or list</p>
</td></tr>
<tr><td><code id="shift_+3A_n">n</code></td>
<td>
<p>a positive integer of length 1, giving the number of
positions to shift by (positive values generate lag)</p>
</td></tr>
<tr><td><code id="shift_+3A_p">p</code></td>
<td>
<p>the index position or row that will become the first one
(overrides n)</p>
</td></tr>
<tr><td><code id="shift_+3A_i">i</code></td>
<td>
<p>a vector of ids to divide x in various groups; the shift will occur
on the subgroups defined by identical i ids.</p>
</td></tr>
<tr><td><code id="shift_+3A_names">names</code></td>
<td>
<p>whether the names of the elements or rows should also shift</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the same object than the input, but with a shifted order
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Simple use ----------------------------------------------------------------

shift(x = c(6,8,10,12,2,4), n = 2)

#&gt; [1]  2  4  6  8 10 12

vector        &lt;- rep(1:4, 3)
names(vector) &lt;- rep(c("P1", "P2", "P3"), each = 4)
split(vector, f = names(vector))

#&gt; $P1
#&gt; P1 P1 P1 P1
#&gt;  1  2  3  4
#&gt;
#&gt; $P2
#&gt; P2 P2 P2 P2
#&gt;  1  2  3  4
#&gt;
#&gt; $P3
#&gt; P3 P3 P3 P3
#&gt;  1  2  3  4

sh &lt;- shift(x = vector, i = names(vector), p = c(1,2,3))
split(sh, f = names(sh))

#&gt; $P1
#&gt; P1 P1 P1 P1
#&gt;  1  2  3  4
#&gt;
#&gt; $P2
#&gt; P2 P2 P2 P2
#&gt;  2  3  4  1
#&gt;
#&gt; $P3
#&gt; P3 P3 P3 P3
#&gt;  3  4  1  2

# Applications to litholog generation ---------------------------------------

l &lt;- c(1,2,3)
r &lt;- c(0,1,2)
h  &lt;- c(4,3,4)
i   &lt;- c("B1","B2","B3")

basic.litholog &lt;- litholog(l,r,h,i)

whiteSet(xlim = c(0,4), ylim = c(0,3),
         xaxs = "r", yaxs = "r",   # This gives a little room to the graph
         ytick = 1, ny = 10)

multigons(basic.litholog$i, basic.litholog$xy, basic.litholog$dt,
          forget = "B1", lwd = 2)

openbed &lt;- subset(basic.litholog, basic.litholog == "B1")

openbed &lt;- shift(openbed, -1)

lines(openbed$xy, openbed$dt, lwd = 2)

</code></pre>

<hr>
<h2 id='simp.lim'>Joins and orders adjacent or overlapping lim objects of same ID</h2><span id='topic+simp.lim'></span>

<h3>Description</h3>

<p>Joins and orders adjacent or overlapping lim objects of same ID
</p>


<h3>Usage</h3>

<pre><code class='language-R'>simp.lim(lim = NULL, l = NULL, r = NULL, id = 1L, b = "[]")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="simp.lim_+3A_lim">lim</code></td>
<td>
<p>an object convertible into a lim object: either a vector
of length 2 or a list of n left (1st element) and n right (2ndt element)
interval limits</p>
</td></tr>
<tr><td><code id="simp.lim_+3A_l">l</code></td>
<td>
<p>a vector of n left interval limits</p>
</td></tr>
<tr><td><code id="simp.lim_+3A_r">r</code></td>
<td>
<p>a vector of n right interval limits</p>
</td></tr>
<tr><td><code id="simp.lim_+3A_id">id</code></td>
<td>
<p>a vector of n interval IDs (default is 1 for each interval)</p>
</td></tr>
<tr><td><code id="simp.lim_+3A_b">b</code></td>
<td>
<p>a character vector for the interval boundaries rules: &quot;[]&quot;
(or &quot;closed&quot;) to include both boundaries points, &quot;][&quot; (or &quot;()&quot; and &quot;open&quot;) to
exclude both boundary points, &quot;[[&quot; (or &quot;[)&quot;,&quot;right-open&quot; and&quot;left-closed&quot;) to
include only the left boundary point, and &quot;]]&quot; (or &quot;(]&quot;, &quot;left-open&quot;,
&quot;right-closed&quot;) to include only the right boundary point. The notation is
simplified to &quot;[]&quot;, &quot;[[&quot;, &quot;]]&quot; and &quot;][&quot; only.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a lim object of the joined intervals
</p>


<h3>See Also</h3>

<p><code><a href="#topic+as.lim">as.lim</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>l   &lt;- c(50,2,4,6,50,8,50,51,50,80)
r   &lt;- c(50,5,6,9,8,2,51,51,50,80)
id  &lt;- c("i1", "i1", "i1", "i1", "i2","i2","i2","i2","i2","i2")
b   &lt;- c("[]", "][", "][", "]]", "][","[[","][","][","][","][")

simp.lim(l = l, r = r, id = id, b = b)

</code></pre>

<hr>
<h2 id='sinpoint'>Gives a table of equally sampled points following a sinusoidal function</h2><span id='topic+sinpoint'></span>

<h3>Description</h3>

<p>Gives a table of equally sampled points following a sinusoidal function
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sinpoint(x, y, delta, x0 = 0, pos = 1, phase = 1.5, nwave = 1, nint = 50)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sinpoint_+3A_x">x</code></td>
<td>
<p>the x value of the end of the interval</p>
</td></tr>
<tr><td><code id="sinpoint_+3A_y">y</code></td>
<td>
<p>the y offset (see next parameter)</p>
</td></tr>
<tr><td><code id="sinpoint_+3A_delta">delta</code></td>
<td>
<p>the difference between the min- and maxima in y</p>
</td></tr>
<tr><td><code id="sinpoint_+3A_x0">x0</code></td>
<td>
<p>the x value of the beginning of the interval (0 as default)</p>
</td></tr>
<tr><td><code id="sinpoint_+3A_pos">pos</code></td>
<td>
<p>an integer specifying the kind of vertical offset; should
the sinusoidal function be shifted so that y is the first value (pos = 1, is
the default), the last value (2),the minimum (3) or the maximum (4) of the
function</p>
</td></tr>
<tr><td><code id="sinpoint_+3A_phase">phase</code></td>
<td>
<p>the phase of the function at x0 in multiples of pi (1.5
as default; begins at its lowest)</p>
</td></tr>
<tr><td><code id="sinpoint_+3A_nwave">nwave</code></td>
<td>
<p>number of complete sinuses waves (1 as default)</p>
</td></tr>
<tr><td><code id="sinpoint_+3A_nint">nint</code></td>
<td>
<p>number of intervals for the sampling (50 as default)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a table of points following a sinusoidal function
</p>


<h3>Examples</h3>

<pre><code class='language-R'>res &lt;- sinpoint(c(4,5), 5, 1, x0 = c(0,1), pos = 3)

plot(res$x, res$y)

multilines(res$i, res$x, res$y, col = c("black" ,"red"), type = "o")

</code></pre>

<hr>
<h2 id='strat.mean'>Extrapolate and intrapolate tie points</h2><span id='topic+strat.mean'></span>

<h3>Description</h3>

<p>Extrapolate and intrapolate of stratigraphical tie points or
events, based on their position in different sections
</p>


<h3>Usage</h3>

<pre><code class='language-R'>strat.mean(dt, events = NULL, sections = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="strat.mean_+3A_dt">dt</code></td>
<td>
<p>a matrix of depth (or time) of the different tie points. Columns
are for the sections, rows for each tie point</p>
</td></tr>
<tr><td><code id="strat.mean_+3A_events">events</code></td>
<td>
<p>the name of the tie points</p>
</td></tr>
<tr><td><code id="strat.mean_+3A_sections">sections</code></td>
<td>
<p>the name of the sections</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>dt     &lt;- tie.points.example[,2:6]
events &lt;- tie.points.example[,1]

strat.mean(dt = dt, events = events)

</code></pre>

<hr>
<h2 id='strat.repair'>Remove instantaneous deposits and add thickness in hiatuses</h2><span id='topic+strat.repair'></span>

<h3>Description</h3>

<p>Remove instantaneous deposits, or 'fills', (e.g. turbidites) and
add thickness estimated to be lost, or gaps' (i.e. hiatuses).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>strat.repair(
  dt,
  gap = list(),
  fill = list(),
  clean = F,
  left.side = T,
  left.norm = T
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="strat.repair_+3A_dt">dt</code></td>
<td>
<p>depth or time</p>
</td></tr>
<tr><td><code id="strat.repair_+3A_gap">gap</code></td>
<td>
<p>list</p>
</td></tr>
<tr><td><code id="strat.repair_+3A_fill">fill</code></td>
<td>
<p>list</p>
</td></tr>
<tr><td><code id="strat.repair_+3A_clean">clean</code></td>
<td>
<p>whether to set the points in fills as NA</p>
</td></tr>
<tr><td><code id="strat.repair_+3A_left.side">left.side</code></td>
<td>
<p>l</p>
</td></tr>
<tr><td><code id="strat.repair_+3A_left.norm">left.norm</code></td>
<td>
<p>l</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>dt &lt;- as.list(tie.points.example[,2:6])

gap  &lt;- list()
fill &lt;- list()

gap$Charce    &lt;- data.frame(dt = c(370,400), span = c(50,10))
gap$El.Porton &lt;- data.frame(dt = -400, span = 30)

fill$Charce     &lt;- data.frame(l = 63, r = 65)
fill$El.Porton  &lt;- data.frame(l = c(-530), r = c(-630))
fill$Frielingen &lt;- data.frame(l = 20, r = 30)

strat.repair(dt, gap, fill)

</code></pre>

<hr>
<h2 id='strat.var'>Compute the realtive thickness variations of sections</h2><span id='topic+strat.var'></span>

<h3>Description</h3>

<p>Based on tie-points, this function computes the relative
thickness variations of different sections compared to a reference section or
composite sections
</p>


<h3>Usage</h3>

<pre><code class='language-R'>strat.var(dt, initial = NULL, ref = 1, events = NULL, sections = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="strat.var_+3A_dt">dt</code></td>
<td>
<p>a matrix of depth (or time) of the different tie points. Columns
are for the sections, rows for each tie point. No NA values are accepted,
if necessary, tie-points have to be estimated, using for instance the
<code><a href="#topic+strat.mean">strat.mean</a></code> function</p>
</td></tr>
<tr><td><code id="strat.var_+3A_initial">initial</code></td>
<td>
<p>which tie-points are originally present in the sections (if
NULL, by default all the values are considered as originally present)</p>
</td></tr>
<tr><td><code id="strat.var_+3A_ref">ref</code></td>
<td>
<p>the column index for the section which acts as a reference (by
default, it is set to 1, for the first columns)</p>
</td></tr>
<tr><td><code id="strat.var_+3A_events">events</code></td>
<td>
<p>the name of the tie points</p>
</td></tr>
<tr><td><code id="strat.var_+3A_sections">sections</code></td>
<td>
<p>the name of the sections</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>dt     &lt;- tie.points.example[,2:6]
events &lt;- tie.points.example[,1]

extended &lt;- strat.mean(dt = dt, events = events)

strat.var(extended$dt, extended$initial)

</code></pre>

<hr>
<h2 id='StratigrapheR'>StratigrapheR: integrated stratigraphy for R</h2><span id='topic+StratigrapheR'></span>

<h3>Description</h3>

<p>This package includes bases for litholog generation:
graphical functions based on R base graphics (e.g. multigons()), interval
gestion functions (with the as.lim() function, and other related .lim
functions) and simple svg importation functions (e.g. pointsvg()) among
others. It also includes stereographic projection functions (e.g. the
earnet(), earpoints() and earplanes() functions; ear standing for equal
area), and other functions made
to deal with large datasets while keeping options to get into the details of
the data. <strong>IF YOU WANT TO START LEARNING HOW TO CREATE LITHOLOGS WITH
STRATIGRAPHER GO SEE THE EXAMPLE BELOW.</strong>
</p>
<p>A StratigrapheR() function is provided: it generates organisational charts
for common use of the functions in the package
</p>


<h3>Usage</h3>

<pre><code class='language-R'>StratigrapheR(i = 1:3)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="StratigrapheR_+3A_i">i</code></td>
<td>
<p>the index(es) of the organisational charts of the functions
in the StratigrapheR package</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Package: StratigrapheR
</p>
<p>Type: R package
</p>
<p>Version: 1.3.1 (Summer 2023)
</p>
<p>License: GPL-3
</p>


<h3>Note</h3>

<p>If you want to use this package for publication or research
purposes, please cite
Wouters, S., Da Silva, A.-C., Boulvain, F., and Devleeschouwer, X.. 2021.
StratigrapheR: Concepts for Litholog Generation in R. The R Journal.
<a href="https://journal.r-project.org/archive/2021/RJ-2021-039/index.html">https://journal.r-project.org/archive/2021/RJ-2021-039/index.html</a>.
</p>


<h3>Author(s)</h3>

<p>Sebastien Wouters
</p>
<p>Maintainer: Sebastien Wouters <a href="mailto:sebastien.wouters@doct.uliege.be">sebastien.wouters@doct.uliege.be</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># This is an example of litholog generation script, along with some
# explanations: if you want to start somewhere, start here. You may run the
# whole thing and follow the explanations.

library(StratigrapheR)
library(dplyr) # very useful package, used here for joining data frames

# You may want to change your working directory for this, the example will
# generate .pdf and .txt files;
# setwd()

# If you want to have an organisational chart of the functions:
## Not run: 
pdfDisplay(StratigrapheR(), "Organisational Chart StratigrapheR",
           width = 9, height = 7.5, track = FALSE)
## End(Not run)

# Bed dataset ----

bed.example

# this dataset should include the description of each bed with :
# - l - the position of the base of each bed (in cm or m) - l stands for the
#   left side or boundary of an interval-
# - r - the position of the top of each bed (in cm or m) - r stands for the
#   right side or boundary of an interval-
# - litho - the lithology, basics are for instance C for chert, S for shale, L
#   for limestone... but you can include anything you want in any way you want
# - h - relief or hardness of each bed
# - id - is the bed identification, number (e.g. B1, B2, ...)
#   you can also include other columns with anything else you find useful for
#   each bed such as color or lithofacies



# Ponctual elements datasets ----

fossil.example
boundary.example
chron.example

# These dataset(s) should include any ponctual information you want in the log,
# such as the position of particular fossils, bioturbations, minerals, tectonic
# features, etc...

# We will also see how to add proxy information with:

proxy.example



# Work the datasets ----

# Basic litholog (rectangles) --
# it will take the basic data (l, r, h, id)

basic.log &lt;- litholog(l = bed.example$l, r = bed.example$r,
                      h = bed.example$h, i = bed.example$id)

# Define the legend for each lithology ----
# for each lithology you can provide a color (col), a density of shading
# (density) and orientation for the lines (angle)

legend &lt;- data.frame(litho = c("S", "L", "C"),
                     col = c("grey30", "grey90", "white"),
                     density = c(30, 0,10),
                     angle = c(180, 0, 45), stringsAsFactors = FALSE)

bed.legend &lt;- left_join(bed.example,legend, by = "litho")



# Plot a basic litholog ----

# Be warned that the most efficient way to generate a litholog is to put it
# in a function. We will see this lower in the exaplanation. The three first
# lithologs generated in the R plot window are simply an example to help you
# understand the functions in StratigrapheR

# First prepare the plot using whiteSet(): this provides a clean drawing area

whiteSet(xlim = c(0,10), ylim = c(-1,77), ytick = 5, ny = 5) # Prepare plot
title("Using litholog() and bedtext()")

# Then add the polygons making the litholog. This is done with a single function
# identifying each polygon by the id of points. The graphical parameters of the
# polygons can be adapted to fit the legend, polygon by polygon.

multigons(basic.log$i, x = basic.log$xy, y = basic.log$dt,
          col = bed.legend$col,
          density = bed.legend$density,
          angle = bed.legend$angle)

# You can further add the name of each bed on each corresponding polygon

bedtext(labels = bed.example$id, l = bed.example$l, r = bed.example$r,
        x = 0.5,  # x position where to centre the text
        ymin = 3) # ymin defines the minimum thickness for the beds where text
# will be added, making for a clean litholog



# Vectorised drawing: example of importation ----

# This creates a svg in one of your temporary files, to show how to import svg
# files
svg.file.directory &lt;- tempfile(fileext = ".svg")
writeLines(example.ammonite.svg, svg.file.directory)
print(paste("An example .svg file was created at ", svg.file.directory,
            sep = ""))

# The pointsvg function allows to import simple svg drawings into R
ammonite.drawing &lt;- pointsvg(file = svg.file.directory)

# If you want to import your own .svg file uncomment the following line:
# pointsvg(file.choose())

# Other data frames of vectorised drawings are imbedded into the
# StratigrapheR package for this example : example.ammonite.svg (to see how to
# use pointsvg), example.ammonite, example.belemnite and example.liquefaction

# Now that ammonite.drawing is available, lets see what it looks like

whiteSet(ylim = c(-1,1), xlim = c(-1,1)) # Plot
box()

title("ammonite.drawing")

placesvg(ammonite.drawing)

# The placesvg() function plots any pointsvg-like dataset, which is a data frame
# with a column x, y, id (for each polygon or polyline) and type (polygone or
# line). Note that only polygons and polylines drawings can be imported by
# pointsvg()

# You can see that the ammonite drawing is centred on 0,0, and has its maxima
# and minima at 1 and -1 respectively, for x and y alike. To plot a drawing
# at the right position and ratio, you can use the centresvg and framesvg
# functions

# For that you have to provide information about the position, for instance:

y.ammonite &lt;- fossil.example$dt[fossil.example$type == "ammonite"]
y.ammonite

# y.ammonite is the y position (or depth) where each ammonite should be drawn.
# It is provided via a vector of any length (i.e. you can have any number of y
# positions and of corresponding ammonites), as long as all the other parameters
# are of length 1 or of same length (i.e. you could provide two values for x if
# you want the two ammonite drawings to have a different x position)

# First build the log

whiteSet(xlim = c(0,10), ylim = c(-1,77), ytick = 5, ny = 5)
title("Using pointsvg() and centresvg()")

multigons(basic.log$i, x = basic.log$xy, y = basic.log$dt,
          col = bed.legend$col,
          density = bed.legend$density,
          angle = bed.legend$angle)

bedtext(labels = bed.example$id, l = bed.example$l, r = bed.example$r,
        x = 0.5,  ymin = 3)

# Then add the drawings

centresvg(ammonite.drawing,
          x = 7, # this is an arbitrary x position for each ammonite drawing
          y = y.ammonite,
          xfac = 0.75,   # Correction factor for the ratio in x
          yfac = c(3,5)) # Correction factor for the ratio in y. As the other
# parameters it can be adapted for each drawing
# individually

# The centresvg() function will take a data frame outputted by pointsvg() - or
# from changesvg(), and even centresvg() and framesvg() if the output is TRUE as
# these two functions can output drawings with modified coordinates -.



# Dealing with bed thickness changes ----

# You can also weld changes of bed thickness at bed boundaries to the basic log

# For instance we can define here two types of sinuosidal boundaries. If you
# want you can even design a different type of 'wiggle' for each boundary.

s1 &lt;- sinpoint(5,0,0.5,nwave = 1.5)
s2 &lt;- sinpoint(5,0,1,nwave = 3, phase = 0)

# You can also weld lines you have drawn in svg and imported with pointsvg().
# However there are a few rules to use them as boundaries in StratigrapheR:
# you have to think about their coordinates. The function welding the 'wiggles'
# of the boundaries to the rectangles of the log, weldlog(), will require to set
# what you consider to be the beginning of the wiggle (at the left of the
# litholog) at 0,0 (if you run with the default parameters of weldlog, which is
# advised if you start), and define their coordinates to suit the scale of the
# litholog

# You can use centresvg() or framesvg() to change the coordinates, setting the
# output argument to TRUE (and the plot argument to FALSE if you don't want to
# plot)

s3 &lt;- framesvg(example.liquefaction, 1, 4, 0, 2, plot = FALSE, output = TRUE)

# In framesvg(), rather than providing the point to center the drawing on, and
# correction in x and y (as centresvg does), you provide the maxima and minima
# in x and y

# With the function wedlog, we combine the lithological log we created
# (basic.log) with the wavy bed boundaries we created. We provide the log
# -parameter log-, the position of the joints we would lie to change -dt-, the
# segments that are going to be welded to the basic log -seg, as a list of
# data frames, by default having the first column for the xy coordinates and
# second for dt coordinates- and j making the link between the boundaries
# position -dt- and the segments -seg-.

# For each j corresponds a respective dt of same index (for each dt corresponds
# a j at the same position), and each j refers to the index or the name of a
# segment in the list of segments.

# with the function wedlog, we combine the lithological log we created
# (basic.log) with the wavy bed boundaries we created. So you can use any
# wiggle you define on your own and weld it to the log

final.log &lt;- weldlog(log = basic.log, dt = boundary.example$dt,
                     seg = list(s1 = s1, s2 = s2, s3 = s3),
                     j = c("s1","s1","s1","s3","s2","s2","s1"))

# Lets see the result of the welding

whiteSet(xlim = c(-3,8), ylim = c(-1,77), ytick = 5, ny = 5) # Prepare plot

# This plot is going to serve to explain other functions;
title("Using weldlog(), infobar(), simp.lim() and minorAxis()")


multigons(final.log$i, x = final.log$xy, y = final.log$dt,
          col = bed.legend$col,
          density = bed.legend$density,
          angle = bed.legend$angle)

bedtext(labels = bed.example$id, l = bed.example$l, r = bed.example$r,
        x = 0.5, ymin = 3)



# Defining and drawing specific intervals  ----

# Lets say we would like to plot the position of magnetochrons. For that we
# firstly define a legend for each type of interval, here for normal and reverse
# polarity

legend.chron &lt;- data.frame(polarity = c("N", "R"),
                           bg.col = c("black", "white"),
                           text.col = c("white", "black"),
                           stringsAsFactors = FALSE)

# Then we set the legend for each chron
chron.legend &lt;- left_join(chron.example,legend.chron, by = "polarity")

# There are three chrons, but what we did can be applied to any number of them,
# as long as they are identified by a column (or more, left_join can merge using
# more than one column)

# Using this legend we can draw rectangles with text in it using the infobar()
# function. In this function we define the coordinates of each rectangle
# (linked to dt for y, and different for each rectangle, but constant in x)
# the text to be in the rectangles with the labels parameter, and graphical
# parameters to be used by the multigons() and text() functions embedded in the
# infobar() function. The number of rectangles is n, and the length of the y, x,
# and labels elements can be 1 or n (i.e. the same n for each parameter).

# You can provide a list of graphical parameters such as the colour for the
# rectangles and the text, as long as the length of each parameter
# in that list is 1 or n.

# Notice that this function shares has a lot in common with litholog() and
# multigons() in functionality and arguments. Note that you could obtain a
# similar result using litholog(), multigons() and bedtext(). You would simply
# need to code more :-)

infobar(-2.5, -2, chron.legend$l, chron.legend$r,
        labels = chron.legend$polarity,
        m = list(col = chron.legend$bg.col),
        t = list(col = chron.legend$text.col),
        srt = 0)



# Treat data sets made of intervals (as happens a lot in geology) ----

# As you have seen with litholog, intervals are dealt with by defining lim
# objects having a left and right boundary (l and r), an id and a boundary rule.
# Whichever of l and r is the maxima or minima usually does not
# matter. StratigrapheR offers a few functions to treat lim objectss. Here
#  we will see the simp.lim() function, but if you want more info go see the
# ?as.lim help page, and the functions in its See Also part.

# simp.lim: this functions merges intervals of same id (if adjacent or
# overlapping)

# Basically, the lim objects are boundaries, for instance in the form [0,1[
# which would indicate an interval going from 0 to 1, zero included but 1 not.
# simp.lim takes the left and right boundaries, assumes that each boundary
# is included in the interval (by default b = "[]"), and simplifies the interval
# by merging them by id, which gives the litholical information in merged
# rectangles (with S, C and L indicating shales, cherts and limestones in this
# case).

litho.intervals &lt;- simp.lim(l = bed.legend$l, r = bed.legend$r,
                            id = bed.legend$litho)

# The resulting list needs to be transformed into a data frame to merge with the
# legend.

litho.intervals &lt;- data.frame(litho.intervals, stringsAsFactors = FALSE)

# Note the parameter stringsAsFactors that is set to FALSE, which is usually
# required when you create data frames to avoid problems, for instance using
# left_join()

colnames(litho.intervals)[3] &lt;- "litho" # Change a column name to be able to merge
# legend and data

litho.intervals.legend &lt;- left_join(litho.intervals,legend, by = "litho")

infobar(-1.25, -0.75, litho.intervals.legend$l, litho.intervals.legend$r,
        m = list(col = litho.intervals.legend$col,
                 density = litho.intervals.legend$density,
                 angle = litho.intervals.legend$angle))

# As you can see if you look closely at the "Using weldlog(), infobar() and
# simp.lim()" plot, the subdivisions between beds of same lithology is gone.
# This is the result of the simp.lim() function by interval manipulation



# Add sample position with axis ----

# If you want you can also show where every sample is using the minorAxis()
# function, which allows distinction between major and minor ticks

at.min &lt;- every_nth(proxy.example$dt, 5, empty = FALSE)
at.maj &lt;- every_nth(proxy.example$dt, 5, inverse = TRUE, empty = FALSE)
labels.maj &lt;- every_nth(proxy.example$name, 5, inverse = TRUE, empty = FALSE)

# The every_nth function allows here to skip samples regularly (to avoid having
# too much text)

minorAxis(side = 4,                # Right-sided axis
          at.min = at.min,         # dt/y position of minor ticks
          at.maj = at.maj,         # dt/y position of major ticks
          labels.maj = labels.maj, # Text to add at major ticks
          tick.ratio = 0.5,        # Length ratio between minor and major ticks
          pos = 6,                 # x position
          las = 1,                 # Orientation of text
          lwd = 0 ,                # Width of axis line to 0 removes the line
          lwd.ticks = 1)           # Width of axis ticks to 1 to keep the ticks




# Final litholog generation: getting it in a convenient function ----

# Once the final design for the lithology is established, it can be integrated
# into a graphical function which will draw every component of the final
# litholog with each desired feature.

# The most efficient way to generate the litholog is to directly put it in a
# reusable function so that you do not do all the work twice. However you need
# some of the data sets we've prepared, in this case bed.example,
# fossil.example, boundary.example, chron.example (that are already imbedded
# in StratigrapheR), final.log, bed.legend, chron.legend and litholeg (that
# are created in this script)

# If you do not want to run all unnecessary functions whenever you want to draw
# your log, a good trick is to save all the necessary data.frames needed in
# the litholog drawing function (here one.log) and load them in it. You just
# need to have the saving file (here one.log.txt) in a file (here a temporary
# file, see ?setwd and ?getwd help pages to manage files in your working
# directory)

file &lt;- paste(tempdir(), "one.log.txt", sep = "/")

save(final.log, bed.legend, chron.legend, litho.intervals.legend, file = file)

one.log &lt;- function(xlim = c(-2.5,7), ylim = c(-1,77),
                    xarg = NULL,  # this is transmitted to whiteSet: if set to
                    # NULL its allows to avoid drawing the x axis
                    yarg = list(tick.ratio = 0.5, las = 1),
                    main = "Final litholog")
{
  load(file) # Load the saved data frames

  whiteSet(xlim = xlim, ylim = ylim, ytick = 5, ny = 5,
           xarg = xarg, yarg = yarg)

  title(main = main)

  multigons(final.log$i, x = final.log$xy, y = final.log$dt,
            col = bed.legend$col,
            density = bed.legend$density,
            angle = bed.legend$angle)

  bedtext(labels = bed.example$id, l = bed.example$l, r = bed.example$r,
          x = 0.5, edge = TRUE)

  centresvg(example.ammonite, 6,
            fossil.example$dt[fossil.example$type == "ammonite"],
            xfac = 0.5)

  centresvg(example.belemnite, 6,
            fossil.example$dt[fossil.example$type == "belemnite"],
            xfac = 0.5)

  infobar(-2, -1.5, chron.legend$l, chron.legend$r,
          labels = chron.legend$id,
          m = list(col = chron.legend$bg.col),
          t = list(col = chron.legend$text.col))

  infobar(-1, -0.5, litho.intervals.legend$l, litho.intervals.legend$r,
          labels = litho.intervals.legend$litho, srt = 0)
}

# This graphical function can then be used as a standalone function, or
# integrated in a for loop to draw the entirety in a succesion of panels
# (typically in pdf form)

# Indeed, if you go back to the definition of the one.log() function, you can
# see that we gave it a parameter, ylim. That parameter defines the range of dt
# that is covered in the plot. So you can plot a smaller part of the log:

one.log(ylim = c(18,53), main = "Final litholog from dt 18 to 53")

# Or you can create a second function that creates a loop of the log if you want
# to generate an ensemble of sheets that placed end to end would create a
# complete litholog

# Basically can want to set up the scale (i.e. the y -or dt- interval of the
# litholog seen for each plot -or pdf page-: if you want to see each time an
# interval of 30 y-units of the litholog on each plot/pdf page, can set the
# parameter 'interval' of the following function to 30)

repeated.log &lt;- function(start = 0, interval = 20)
{
  omar &lt;- par("mar")

  par(mar = c(1,4,3,2)) # This allows to define the margins as you wish

  l1 &lt;- seq(start,max(final.log$dt),interval)
  l2 &lt;- seq(start,max(final.log$dt),interval) + interval

  for(i in length(l1):1)
  {
    one.log(ylim = c(l1[i],l2[i]),
            main = paste("Repeated litholog, part from dt", l1[i], "to", l2[i]))
  }

  par(mar = omar)

}

repeated.log()

# Printing and seeing you litholog in pdf ----

# The next function, pdfDisplay, generates a pdf of a graphical function.
# Any function producing plots such as repeated.log() can be inserted into it to
# generate plots. These plots will all be of the same size. I believe this
# function might not work on every computer. And its openfile argument, which
# causes the pdf to open, only works in Windows. If You are working with
# Windows, I recommend using SumatraPDF as your default pdf reader: this will
# allow pdfs to be changed while they are being visualised.
## Not run: 
pdfDisplay(repeated.log(), width = 10, height = 15,
          name = "StratigrapheR_Example_a", track = FALSE)
## End(Not run)



# Plotting data -e.g. time-series data of a proxy - along the litholog ----

# Now lets say you want to plot information along the litholog. For that we will
# work in a graphical function that we will provide to pdfDisplay. Note that
# it is not possible to base yourself on the repeated.log() function, because
# it will print all the plots succesively without allowing modification or
# addition

# One way of working is to create two plots next to each other and provide
# identical y axis parameters

graphical.function.1 &lt;- function()
{

  opar &lt;- par("mar","mfrow")

  par(mar = c(3,4,3,2),
      mfrow = c(1,2)) # This creates two windows where to plot sucessively

  # Plot the litholog on the left

  one.log(main = "")

  # Plot the other data on the right

  blackSet(xlim = c(-2*10^-8,8*10^-8),
           ylim =  c(-1,77), # It is important to define identical y limits
           # between the litholog and the proxy
           ytick = 5, ny = 1,
           targ = NULL)

  lines(proxy.example$ms, proxy.example$dt, type = "o", pch = 19)

  par(mar = opar$mar, mfrow = opar$mfrow)

}
## Not run: 
pdfDisplay(graphical.function.1(), width = 10, height = 15,
           name = "StratigrapheR_Example_b", track = FALSE)
## End(Not run)

# If you want to put that repeated litholog in A4 format, the best way is to
# use LaTeX. The following lines of code will create a TeX file that would
# do that, test it if you want (the file will be in a temporary directory,
# but you can change tempdir(), to getwd() for instance):
## Not run: 
writeLines(log.loop.tex, paste(tempdir(),"log.loop.tex", sep = "/"))
## End(Not run)

# Another way to work this out is to create more space than needed on the
# litholog plot and to add elements

graphical.function.2 &lt;- function()
{
  omar &lt;- par("mar")

  par(mar = c(3,4,3,2))

  # Plot the litholog with room for the rest

  one.log(main = "", xlim = c(-3,16), xarg = list())

  par(fig = c(0.5,1, 0, 1),  # 'fig' defines the overlapping plotting window
      # dimensions x1, x2, y1 and y2
      new = TRUE)               # 'new' allows addition to a preexisting plot

  # The graphical parameter 'fig' that you can set using the par() function
  # allows you to define a new plotting region overlapping the original one.
  # This allows you to redefine x axes values. But again using this you have to
  # be careful to provide the right y limits between the litholog and the proxy.
  # Be aware that the functions white-, black- and greySet() set the xaxis and
  # yaxis to "i", which means that the limits you provide in x and y are the
  # actual limits of the plot (while the default setting of xaxis and yaxis are
  # "r", which extends the data range by 4 percent at each end)

  blackSet(xlim = c(-2*10^-8,8*10^-8),
           ylim =  c(-1,77),
           ytick = 5, ny = 1,
           targ = NULL,
           xarg = list(side = 3))

  lines(proxy.example$ms, proxy.example$dt, type = "o", pch = 19)

  par(mar = omar)

}
## Not run: 
pdfDisplay(graphical.function.2(), width = 8, height = 15,
           name = "StratigrapheR_Example_c", track = FALSE)
## End(Not run)

</code></pre>

<hr>
<h2 id='StratigrapheR.examples'>Data for examples</h2><span id='topic+StratigrapheR.examples'></span><span id='topic+tie.points.example'></span><span id='topic+bed.example'></span><span id='topic+boundary.example'></span><span id='topic+chron.example'></span><span id='topic+example.ammonite'></span><span id='topic+example.ammonite.svg'></span><span id='topic+example.belemnite'></span><span id='topic+example.breccia'></span><span id='topic+example.HB2000.svg'></span><span id='topic+example.lense'></span><span id='topic+example.liquefaction'></span><span id='topic+irreg.example'></span><span id='topic+fossil.example'></span><span id='topic+log.loop.tex'></span><span id='topic+noise_emd'></span><span id='topic+proxy.example'></span><span id='topic+proxy.example.litho'></span><span id='topic+zeq_example'></span>

<h3>Description</h3>

<p>Supporting data sets to use in the examples. Some will be used in the
examples. example.ammonite.svg and log.loop.tex are meant to generate their
respective .svg and .tex files. Others are used in the article (to be
published soon).
</p>


<h3>Details</h3>


<dl>
<dt><strong>Litholog drawing data</strong></dt><dd><p>bed.example, boundary.example,
example.ammonite, example.ammonite.svg, example.belemnite, example.breccia,
example.HB2000.svg, example.lense, example.liquefaction, fossil.example,
proxy.example, proxy.example.litho</p>
</dd>
<dt><strong>Time-Series</strong></dt><dd><p>irreg.example</p>
</dd>
<dt><strong>Magnetostratigraphical data</strong></dt><dd><p>chron.example</p>
</dd>
<dt><strong>Litholog exportation script</strong></dt><dd><p>log.loop.tex</p>
</dd>
<dt><strong>Oriented data</strong></dt><dd><p>zeq_example</p>
</dd>
<dt><strong>Stratigraphical tie points</strong></dt><dd><p>tie.points.example</p>
</dd>
</dl>


<hr>
<h2 id='symbology'>Draws the symbols of a collection</h2><span id='topic+symbology'></span>

<h3>Description</h3>

<p>Draws all the required symbols from a collection of them
</p>


<h3>Usage</h3>

<pre><code class='language-R'>symbology(
  collection,
  sym,
  x,
  y,
  xfac = 1,
  yfac = 1,
  xadj = 0,
  yadj = 0,
  col = NA,
  border = "black",
  density = NA,
  angle = 45,
  lty = par("lty"),
  lwd = par("lwd"),
  scol = border,
  slty = lty,
  slwd = lwd
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="symbology_+3A_collection">collection</code></td>
<td>
<p>a collection object (e.g. oufti)</p>
</td></tr>
<tr><td><code id="symbology_+3A_sym">sym</code></td>
<td>
<p>the name of the symbols in the collection</p>
</td></tr>
<tr><td><code id="symbology_+3A_x">x</code>, <code id="symbology_+3A_y">y</code></td>
<td>
<p>numeric vectors of coordinates where the object should be
drawn.</p>
</td></tr>
<tr><td><code id="symbology_+3A_xfac">xfac</code></td>
<td>
<p>the x size factor.</p>
</td></tr>
<tr><td><code id="symbology_+3A_yfac">yfac</code></td>
<td>
<p>the y size factor.</p>
</td></tr>
<tr><td><code id="symbology_+3A_xadj">xadj</code></td>
<td>
<p>value specifying the x adjustment of the drawing.</p>
</td></tr>
<tr><td><code id="symbology_+3A_yadj">yadj</code></td>
<td>
<p>value specifying the y adjustment of the drawing.</p>
</td></tr>
<tr><td><code id="symbology_+3A_col">col</code></td>
<td>
<p>the polygons background color. If density is specified with
a positive value this gives the color of the shading lines.</p>
</td></tr>
<tr><td><code id="symbology_+3A_border">border</code></td>
<td>
<p>the lines color.</p>
</td></tr>
<tr><td><code id="symbology_+3A_density">density</code></td>
<td>
<p>the density of shading lines, in lines per inch. The
default value of NULL means that no shading lines are drawn.</p>
</td></tr>
<tr><td><code id="symbology_+3A_angle">angle</code></td>
<td>
<p>the slope of shading lines, given as an angle in degrees
(counter-clockwise)</p>
</td></tr>
<tr><td><code id="symbology_+3A_lty">lty</code>, <code id="symbology_+3A_lwd">lwd</code></td>
<td>
<p>the border line type and width, see ?par for details.</p>
</td></tr>
<tr><td><code id="symbology_+3A_scol">scol</code>, <code id="symbology_+3A_slty">slty</code>, <code id="symbology_+3A_slwd">slwd</code></td>
<td>
<p>the colour, type and width of the shading lines.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p>Similar functions: <code><a href="#topic+centresvg">centresvg</a></code>, <code><a href="#topic+framesvg">framesvg</a></code>
and <code><a href="#topic+placesvg">placesvg</a></code>
</p>
<p>Collections available in StratigrapheR: <code><a href="#topic+oufti99">oufti99</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Create a data frame for all the required information ----

a &lt;- data.frame(name = c("ammonite", "marcassite",
                         "nodule.point", "ammonite"),
                x = c(1,3,5,1),
                y = c(1,3,5,5),
                col = c(NA, "grey90",
                        "grey50", "grey90"))

# Draw them all in a single line of code ----

plot.new()
plot.window(xlim = c(0,6), ylim = c(0, 6))

axis(1)
axis(2, las = 1)

symbology(oufti99, a$name, a$x, a$y, col = a$col)

</code></pre>

<hr>
<h2 id='tie.lim'>Discretises lim objects</h2><span id='topic+tie.lim'></span>

<h3>Description</h3>

<p>Discretises continuous lim objects by constant interpolation
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tie.lim(
  lim = NULL,
  l = NULL,
  r = NULL,
  y = NULL,
  xout = NULL,
  id = 1L,
  to.lower = T,
  warn = T
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tie.lim_+3A_lim">lim</code></td>
<td>
<p>an object convertible into a lim object: either a vector
of length 2 or a list of n left (1st element) and n right (2ndt element)
interval limits, and of n interval IDs. In this case the lim objects have to
be ordered, by ids, dependently to each other, and from left to right. For
each id the lim objects have to cover the entire interval from the lowest
to the highest value, without overlap.</p>
</td></tr>
<tr><td><code id="tie.lim_+3A_l">l</code></td>
<td>
<p>a vector of n left interval limits</p>
</td></tr>
<tr><td><code id="tie.lim_+3A_r">r</code></td>
<td>
<p>a vector of n right interval limits</p>
</td></tr>
<tr><td><code id="tie.lim_+3A_y">y</code></td>
<td>
<p>a vector of n values to discretise</p>
</td></tr>
<tr><td><code id="tie.lim_+3A_xout">xout</code></td>
<td>
<p>a vector of numeric values specifying where interpolation
is to take place. It will be identical for each id. If NULL the result will
be continuous (points of a continous line).</p>
</td></tr>
<tr><td><code id="tie.lim_+3A_id">id</code></td>
<td>
<p>a vector of n interval IDs (default is 1 for each interval)</p>
</td></tr>
<tr><td><code id="tie.lim_+3A_to.lower">to.lower</code></td>
<td>
<p>whether to take the left (lower) or right point for
interpolation at adjacent points</p>
</td></tr>
<tr><td><code id="tie.lim_+3A_warn">warn</code></td>
<td>
<p>whether to warn if the sampling interval is prone to
miss the smallest intervals.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+as.lim">as.lim</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>l  &lt;- matrix(1:30, ncol = 3, byrow = FALSE)
r  &lt;- matrix(2:31, ncol = 3, byrow = FALSE)
id &lt;- matrix(rep(c("C1", "C2", "C3"),10), ncol = 3, byrow = TRUE)
y  &lt;- matrix(rep(1:10,3), ncol = 3, byrow = FALSE)
xout &lt;- seq(-2,32,0.5)

res  &lt;- tie.lim(l = l, r = r,  y = y, xout = xout, id = id)

cont &lt;- tie.lim(l = l, r = r,  y = y, id = id)

plot(res$x, res$y, pch = 19, col = "red")

lines(cont$x[,1], cont$y[,1])
lines(cont$x[,2], cont$y[,2])
lines(cont$x[,3], cont$y[,3])

</code></pre>

<hr>
<h2 id='trace.lim'>Visualize lim objects</h2><span id='topic+trace.lim'></span><span id='topic+plot_lim'></span>

<h3>Description</h3>

<p>Visualize lim objects as lines for each interval. The lines are
time series with the dt (depth/time) being the boundaries of the interval,
and an xy intensity is defined as values attributed to the interval.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>trace.lim(
  lim = NULL,
  l = NULL,
  r = NULL,
  id = 1L,
  b = "[]",
  xy = 0,
  order = F,
  decreasingly = F,
  output = T,
  plot = T,
  link = F,
  point = T,
  style = list(),
  close = list(pch = 19),
  open = list(pch = 21, bg = "white"),
  add = F,
  gen = list(xlab = "dt", ylab = "xy")
)

plot_lim(
  dt,
  xy,
  int,
  include,
  link = F,
  point = T,
  style = list(),
  close = list(pch = 19),
  open = list(pch = 21, bg = "white"),
  add = F,
  hz = T,
  gen = list(xlab = "dt", ylab = "xy")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="trace.lim_+3A_lim">lim</code></td>
<td>
<p>a list of n left (1st element) and n right (2ndt element)
interval limits, of n interval IDs, and of n interval boundary rules (e.g.
&quot;[]&quot;).</p>
</td></tr>
<tr><td><code id="trace.lim_+3A_l">l</code></td>
<td>
<p>the left interval limits (numerical vector of length n).</p>
</td></tr>
<tr><td><code id="trace.lim_+3A_r">r</code></td>
<td>
<p>the right interval limits (numerical vector of length n).</p>
</td></tr>
<tr><td><code id="trace.lim_+3A_id">id</code></td>
<td>
<p>the interval IDs (numerical or character vector of length n,
the default is 1 for each interval). They can be similar for different
intervals.</p>
</td></tr>
<tr><td><code id="trace.lim_+3A_b">b</code></td>
<td>
<p>the interval boundaries rules: &quot;[]&quot;
(or &quot;closed&quot;) to include both boundaries points, &quot;][&quot; (or &quot;()&quot; and &quot;open&quot;) to
exclude both boundary points, &quot;[[&quot; (or &quot;[)&quot;,&quot;right-open&quot; and&quot;left-closed&quot;) to
include only the left boundary point, and &quot;]]&quot; (or &quot;(]&quot;, &quot;left-open&quot;,
&quot;right-closed&quot;) to include only the right boundary point. The notation is
simplified to &quot;[]&quot;, &quot;[[&quot;, &quot;]]&quot; and &quot;][&quot; only.</p>
</td></tr>
<tr><td><code id="trace.lim_+3A_xy">xy</code></td>
<td>
<p>the intensity attributed to each interval.</p>
</td></tr>
<tr><td><code id="trace.lim_+3A_order">order</code></td>
<td>
<p>whether to order the intervals.</p>
</td></tr>
<tr><td><code id="trace.lim_+3A_decreasingly">decreasingly</code></td>
<td>
<p>whether the order to set is decreasing.</p>
</td></tr>
<tr><td><code id="trace.lim_+3A_output">output</code></td>
<td>
<p>whether to output the results.</p>
</td></tr>
<tr><td><code id="trace.lim_+3A_plot">plot</code></td>
<td>
<p>whether to plot the results.</p>
</td></tr>
<tr><td><code id="trace.lim_+3A_link">link</code></td>
<td>
<p>whether to link all the intervals into one line.</p>
</td></tr>
<tr><td><code id="trace.lim_+3A_point">point</code></td>
<td>
<p>whether to add points to the boundaries of each interval.</p>
</td></tr>
<tr><td><code id="trace.lim_+3A_style">style</code></td>
<td>
<p>the style of the lines.</p>
</td></tr>
<tr><td><code id="trace.lim_+3A_close">close</code></td>
<td>
<p>the style of the points for closed boundaries.</p>
</td></tr>
<tr><td><code id="trace.lim_+3A_open">open</code></td>
<td>
<p>the style of the points for open boundaries.</p>
</td></tr>
<tr><td><code id="trace.lim_+3A_add">add</code></td>
<td>
<p>whether to add the plot to an existing plot.</p>
</td></tr>
<tr><td><code id="trace.lim_+3A_gen">gen</code></td>
<td>
<p>general parameters for <code><a href="graphics.html#topic+plot">plot</a></code></p>
</td></tr>
<tr><td><code id="trace.lim_+3A_dt">dt</code></td>
<td>
<p>the boundaries of the intervals as provided by <code>trace.lim</code>.</p>
</td></tr>
<tr><td><code id="trace.lim_+3A_int">int</code></td>
<td>
<p>the id of each interval as provided by <code>trace.lim</code>.</p>
</td></tr>
<tr><td><code id="trace.lim_+3A_include">include</code></td>
<td>
<p>whether the boundaries of the intervals are included in them,
as provided by <code>trace.lim</code>.</p>
</td></tr>
<tr><td><code id="trace.lim_+3A_hz">hz</code></td>
<td>
<p>whether dt stands for the horizontal axis (the x axis, i.e., the
abscissa): in that case it is set a TRUE (this is the default value). Any
other value will associate dt with the vertical axis (y axis, i.e., the
ordinate)</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>trace.lim</code> returns a list of 'dt' values (dt stands for
depth/time, which corresponds to the boundaries of intervals), 'xy' values
(the &quot;intensity&quot; of each interval), 'int' which is an id for each interval,
id which is the ids defined in the lim objects (these ids can be similar for
different intervals, and therefore define groups of intervals), and 'include'
which are boolean (T/F) values whether a boundary of the interval is included
in the interval.
</p>


<h3>See Also</h3>

<p>generalities on lim data: <code><a href="#topic+as.lim">as.lim</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>lim &lt;- as.lim(l = c(0,6,4,6,50), r = c(1,5,6,9,8),
              b = c("[[", "]]", "[[", "]]", "[["))

xy &lt;- c(1,2,3,4,5)

trace &lt;- trace.lim(lim = lim, xy = xy, plot = FALSE)

trace

plot_lim(dt = trace$dt, xy = trace$xy,
         int = trace$int, include = trace$include)

</code></pre>

<hr>
<h2 id='transphere'>Convertion between declinaison/inclination/intensity and cartesian
coordinates</h2><span id='topic+transphere'></span>

<h3>Description</h3>

<p>Convertion between declinaison/inclination/intensity and cartesian
coordinates (modified from RFOC package)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>transphere(dec = NA, inc = NA, int = 1, x = NA, y = NA, z = NA, into = "other")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="transphere_+3A_dec">dec</code></td>
<td>
<p>declination of the data; it is the angle from the north
taken on an horizontal plane. It is measured clockwise from North and ranges
from 0 to 360° (Tauxe 2010). Values outside this range are corrected by
incfix().</p>
</td></tr>
<tr><td><code id="transphere_+3A_inc">inc</code></td>
<td>
<p>inclination of the data; it is the angle from the
horizontal, is positive downward, and ranges from +90° for straight down to
-90° for straight up (Tauxe, 2010). Values outside this range are corrected
by incfix().</p>
</td></tr>
<tr><td><code id="transphere_+3A_int">int</code></td>
<td>
<p>intensity of the data. Defaults to one (unit sphere).</p>
</td></tr>
<tr><td><code id="transphere_+3A_x">x</code>, <code id="transphere_+3A_y">y</code>, <code id="transphere_+3A_z">z</code></td>
<td>
<p>cartesian coordinates. x is the North, y the East, and z
straight down. If dec and inc are not provided they are used to be converted
back in dec, inc and int data. Output is corrected by incfix().</p>
</td></tr>
<tr><td><code id="transphere_+3A_into">into</code></td>
<td>
<p>overriding parameter for generalisation: if &quot;dii&quot; dec, inc and
int will remain as they are, and if &quot;xyz&quot; cartesian coordinates will remain
as they are</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list of coordinates, in cartesian form or dec, inc, int form
following the input
</p>


<h3>See Also</h3>

<p><code><a href="#topic+fmod">fmod</a></code>, <code><a href="#topic+dipfix">dipfix</a></code> and <code><a href="#topic+incfix">incfix</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>transphere(dec = c(65,135), inc = c(32,74))

l &lt;- transphere(dec = c(65,135), inc = c(32,74))
transphere(x = l$x, y = l$y, z = l$z)

</code></pre>

<hr>
<h2 id='weld'>Combines segments with &quot;litholog()&quot;-like data frame</h2><span id='topic+weld'></span>

<h3>Description</h3>

<p>Adds segments to the polygon forming the bed of a log in a
&quot;litholog()&quot;-like data frame.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>weld(log, dt, xy, begin, end, erase = "none", order = "current")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="weld_+3A_log">log</code></td>
<td>
<p>a &quot;litholog()&quot;-like data frame on which the new segment
needs to be welded.</p>
</td></tr>
<tr><td><code id="weld_+3A_dt">dt</code></td>
<td>
<p>the dt value for each point of the added segment.</p>
</td></tr>
<tr><td><code id="weld_+3A_xy">xy</code></td>
<td>
<p>the xy value for each point of the added segment.</p>
</td></tr>
<tr><td><code id="weld_+3A_begin">begin</code></td>
<td>
<p>the row of log after which the segment will be added.</p>
</td></tr>
<tr><td><code id="weld_+3A_end">end</code></td>
<td>
<p>the row of log before which the segment will be added
(end should be superior to begin).</p>
</td></tr>
<tr><td><code id="weld_+3A_erase">erase</code></td>
<td>
<p>erase the begin point ('begin'), end point ('end'), both
('both') or only the points in between ('none').</p>
</td></tr>
<tr><td><code id="weld_+3A_order">order</code></td>
<td>
<p>the order of the added points : can be the current order
('current'), the current order inversed ('inverse'), or ordered by xy ('xy'
or '-xy') or dt ('dt' or '-dt').</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a &quot;litholog()&quot;-like data frame with the bed
that comprises the begin
and end row having the segment welded to it.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+litholog">litholog</a></code> and <code><a href="#topic+weldlog">weldlog</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>l &lt;- c(1)
r &lt;- c(2)
h &lt;- c(4)
i &lt;- c("B1")
log &lt;- litholog(l, r, h, i)

seg &lt;- sinpoint(4, 1, 0.25, pos = 2, phase = 0.5)
welded &lt;- weld(log, seg$y, seg$x, 3, 4, order = "inverse", erase = "both")

plot(c(-1,5),c(0,3),type = "n")

multigons(log$i,log$xy,log$dt)
points(seg$x,seg$y)

multigons(welded$i, welded$xy, welded$dt, lty = 2, lwd = 3, border = "red")

</code></pre>

<hr>
<h2 id='weldjoint'>Changes boundaries segments in basic lithologs</h2><span id='topic+weldjoint'></span>

<h3>Description</h3>

<p>Adds personalised segments to bed boundaries of lithologs from
&quot;litholog()&quot;-like data frames
</p>


<h3>Usage</h3>

<pre><code class='language-R'>weldjoint(
  log,
  dt,
  collection,
  sym,
  yinv = F,
  xinv = F,
  yleft = 0,
  yright = NA,
  ymin = NA,
  ymax = NA,
  xmin = 0,
  xmax = max(log$xy),
  add.dt = 0,
  tolerance = 8
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="weldjoint_+3A_log">log</code></td>
<td>
<p>a &quot;litholog()&quot;-like data frame on which the new segments
need to be welded.</p>
</td></tr>
<tr><td><code id="weldjoint_+3A_dt">dt</code></td>
<td>
<p>the position of the n boundaries to change.</p>
</td></tr>
<tr><td><code id="weldjoint_+3A_collection">collection</code></td>
<td>
<p>a collection object (e.g. oufti)</p>
</td></tr>
<tr><td><code id="weldjoint_+3A_sym">sym</code></td>
<td>
<p>the name of the symbols in the collection. This should be a symbol
that can be considered as a bedding joint; see <code><a href="#topic+is.joint">is.joint</a></code>.</p>
</td></tr>
<tr><td><code id="weldjoint_+3A_yinv">yinv</code>, <code id="weldjoint_+3A_xinv">xinv</code></td>
<td>
<p>whether to inverse the plotting for x and y values (T or F)</p>
</td></tr>
<tr><td><code id="weldjoint_+3A_yleft">yleft</code>, <code id="weldjoint_+3A_yright">yright</code></td>
<td>
<p>the depth/height/time value for the extreme point at the
right or left of the joint (yleft overruns yright, which overruns ymin and
ymax)</p>
</td></tr>
<tr><td><code id="weldjoint_+3A_ymin">ymin</code>, <code id="weldjoint_+3A_ymax">ymax</code></td>
<td>
<p>the extreme values for the y axis (in case of conflict with
yleft and/or yright, defaults to the smallest exaggeration)</p>
</td></tr>
<tr><td><code id="weldjoint_+3A_xmin">xmin</code>, <code id="weldjoint_+3A_xmax">xmax</code></td>
<td>
<p>the extreme values for the x axis</p>
</td></tr>
<tr><td><code id="weldjoint_+3A_add.dt">add.dt</code></td>
<td>
<p>whether to automatically add the dt value to the dt of
the segments (with the add.dt value when it is not zero)</p>
</td></tr>
<tr><td><code id="weldjoint_+3A_tolerance">tolerance</code></td>
<td>
<p>the order of tolerance for errors, i.e. the number of
decimals considered as being meaningful for matching dt to log</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a &quot;litholog()&quot;-like data frame, with new bed boundaries
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Generate litholog ----

l &lt;- c(0,1,2,3,4)
r &lt;- c(1,2,3,4,5)
h   &lt;- c(4,3,4,3,4)
i &lt;- c("B1","B2","B3","B4","B5")
log  &lt;- litholog(l, r, h, i)

# Modify the boundaries of the litholog ----

nlog &lt;- weldjoint(log, c(1,2,3,4), oufti99,
                  sym = c("1sin", "stylolith", "3sin", "liquefaction"),
                  ymax  = c(NA, NA, NA, 0.2),
                  xmin  = c(0,0,0,1),
                  xmax  = c(4,4,4,1.5))

# Visualise

par(mfrow = c(1,2))

plot.new()
plot.window(xlim = c(0,5), ylim = c(0,5))

axis(1)
axis(2)

multigons(log$i, log$xy, log$dt)

plot.new()
plot.window(xlim = c(0,5), ylim = c(0,5))

axis(1)
axis(2)

multigons(nlog$i, nlog$xy, nlog$dt)

</code></pre>

<hr>
<h2 id='weldlog'>Changes boundaries segments in basic lithologs</h2><span id='topic+weldlog'></span>

<h3>Description</h3>

<p>Adds personalised segments to bed boundaries of lithologs from
&quot;litholog()&quot;-like data frames
</p>


<h3>Usage</h3>

<pre><code class='language-R'>weldlog(
  log,
  dt,
  seg,
  j = 1:length(dt),
  col.xy = 1,
  col.dt = 2,
  auto.dt = T,
  add.dt = 0,
  omit1 = NULL,
  omit2 = NULL,
  warn = T,
  tolerance = 8
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="weldlog_+3A_log">log</code></td>
<td>
<p>a &quot;litholog()&quot;-like data frame on which the new segments
need to be welded.</p>
</td></tr>
<tr><td><code id="weldlog_+3A_dt">dt</code></td>
<td>
<p>the position of the n boundaries to change.</p>
</td></tr>
<tr><td><code id="weldlog_+3A_seg">seg</code></td>
<td>
<p>a list of n dataframes having xy and dt coordinates for
the segments that are going to be welded to the log.</p>
</td></tr>
<tr><td><code id="weldlog_+3A_j">j</code></td>
<td>
<p>the indexes of the segments attributed to each boundary or
the names of these segments. Should be of same length than dt.</p>
</td></tr>
<tr><td><code id="weldlog_+3A_col.xy">col.xy</code></td>
<td>
<p>the number of the column for the xy coordinates in the
seg dataframes.</p>
</td></tr>
<tr><td><code id="weldlog_+3A_col.dt">col.dt</code></td>
<td>
<p>the number of the column for the dt coordinates in the
seg dataframes.</p>
</td></tr>
<tr><td><code id="weldlog_+3A_auto.dt">auto.dt</code></td>
<td>
<p>whether to automatically add the dt value to the dt of
the segments (with the add.dt value when it is not zero)</p>
</td></tr>
<tr><td><code id="weldlog_+3A_add.dt">add.dt</code></td>
<td>
<p>a value to add to the dt of the segments for each
boundary (in addition of the value of the <code>dt</code> parameter). Should be of
length 1 or of same length than dt.</p>
</td></tr>
<tr><td><code id="weldlog_+3A_omit1">omit1</code>, <code id="weldlog_+3A_omit2">omit2</code></td>
<td>
<p>the dt of the boundary for which either the upper
or lower bed should not be welded to (1 and 2 depending on the order of the
beds in the original log)</p>
</td></tr>
<tr><td><code id="weldlog_+3A_warn">warn</code></td>
<td>
<p>whether you want to be annoyed (beginners should find it
useful to be annoyed)</p>
</td></tr>
<tr><td><code id="weldlog_+3A_tolerance">tolerance</code></td>
<td>
<p>the order of tolerance for errors, i.e. the number of
decimals considered as being meaningful for matching dt to log</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a &quot;litholog()&quot;-like data frame, with new bed boundaries
</p>


<h3>See Also</h3>

<p>Complementary function<code><a href="#topic+litholog">litholog</a></code>
</p>
<p>Underlying function: <code><a href="#topic+weld">weld</a></code>
</p>
<p>To generate sinuoisidal segments: <code><a href="#topic+sinpoint">sinpoint</a></code>
To generate a lot of different sinuoisidal segments: see the example in
<code><a href="#topic+neatPick">neatPick</a></code>
</p>
<p>To import and adapt .svg files as segments: <code><a href="#topic+pointsvg">pointsvg</a></code>,
<code><a href="#topic+framesvg">framesvg</a></code>, <code><a href="#topic+centresvg">centresvg</a></code> and <code><a href="#topic+changesvg">changesvg</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>l &lt;- c(0,1,2,3,4)
r &lt;- c(1,2,3,4,5)
h   &lt;- c(4,3,4,3,4)
i &lt;- c("B1","B2","B3","B4","B5")
log  &lt;- litholog(l, r, h, i)

whiteSet(xlim = c(-1,5), ylim = c(-1,6))

multigons(log$i, log$xy, log$dt, lty = 3)

seg1 &lt;- sinpoint(4, 0, 0.25, phase=0.5)
seg2 &lt;- sinpoint(4, 0, 0.25, phase=1.5)

welded &lt;- weldlog(log, dt = c(2,3,4), seg = list(seg1 = seg1, seg2 = seg2),
                  j = c("seg1", "seg2", "seg2"))

multigons(welded$i, welded$xy, welded$dt, lwd = 3, lty = 2, border = "red")

</code></pre>

<hr>
<h2 id='weldprofile'>Changes profiles in basic lithologs</h2><span id='topic+weldprofile'></span>

<h3>Description</h3>

<p>Adds profiles (hardness, weathering, grain-size, facies, etc.)
to lithologs from &quot;litholog()&quot;-like data frames
</p>


<h3>Usage</h3>

<pre><code class='language-R'>weldprofile(log, gap, dt, xy, i = NA, ext = Inf, tolerance = 8, correct = T)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="weldprofile_+3A_log">log</code></td>
<td>
<p>a &quot;litholog()&quot;-like data frame on which the new profile needs to
be welded.</p>
</td></tr>
<tr><td><code id="weldprofile_+3A_gap">gap</code></td>
<td>
<p>The xy value delimiting the litholog in the parts that will
remain, and the parts that will be replaced by the profile. This should be
comparable to the most inward values of the profile. What side of the
litholog will remain depends on the ext parameter.</p>
</td></tr>
<tr><td><code id="weldprofile_+3A_dt">dt</code>, <code id="weldprofile_+3A_xy">xy</code></td>
<td>
<p>the depth and intensity values for the profile</p>
</td></tr>
<tr><td><code id="weldprofile_+3A_i">i</code></td>
<td>
<p>the beds ids for the points of the profile (is optional; this is
useful for complex profiles, which can go back and forth in depth).</p>
</td></tr>
<tr><td><code id="weldprofile_+3A_ext">ext</code></td>
<td>
<p>the most outward values of the profile; defaults to infinity Inf,
for &quot;left-side&quot; profiles, set to -Inf.</p>
</td></tr>
<tr><td><code id="weldprofile_+3A_tolerance">tolerance</code></td>
<td>
<p>the order of tolerance for errors, i.e. the number of
decimals considered as being meaningful for matching dt to log</p>
</td></tr>
<tr><td><code id="weldprofile_+3A_correct">correct</code></td>
<td>
<p>this parameter applies in a very specific case, when i is
provided, and when the order of points is not straightforward (going from low
to high values, or vice versa). If correct is TRUE, the ambiguous parts
(in ambiguous beds) of the profile will be reversed.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A litholog object, i.e., a table of bed id (i), depth (dt) and xy
values (the x position if your litholog is vertical).
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Make an initial log ----

r &lt;- c(1,2,3,4,5)  # left boundary of the bed interval (upper or lower)
l &lt;- c(0,1,2,3,4)  # right boundary of the bed interval (upper or lower)
h &lt;- c(4,3,5,3,4) # hardness (arbitrary)
i &lt;- c("B1","B2","B3","B4","B5") # Bed name

log &lt;- litholog(l,r,h,i) # Generate data frame of the polygons
# making the litholog

# Define the profile ----

# Depths (dt), intensity (xy), and ids (id) of profile points
dt &lt;- c(0,1,1,1,2,2,2,3,3,3,4,4,5)
xy &lt;- c(5,4,3,4,3,3,6,5,3,4,3,5,4)
id &lt;- c("B1","B1","B1","B2","B2","B3","B3","B3","B3","B4","B4","B5","B5")

# Weld profile to litholog ----

nlog &lt;- weldprofile(log = log, gap = 3, dt = dt, xy = xy, i = id, ext = Inf)

# Visualisation ----

opar &lt;- par()$mfrow
par(mfrow = c(1,3))

plot.new()
plot.window(xlim = c(0,6), ylim = c(0,5))

axis(1)
axis(2)

multigons(log$i, log$xy, log$dt)

plot.new()
plot.window(xlim = c(0,6), ylim = c(0,5))

axis(1)
axis(2)

lines(xy, dt, type = "o", pch = 19)

plot.new()
plot.window(xlim = c(0,6), ylim = c(0,5))

axis(1)
axis(2)

multigons(nlog$i, nlog$xy, nlog$dt)

par(mfrow = opar)

</code></pre>

<hr>
<h2 id='whiteSet'>Sets the plot environment to draw a long data set</h2><span id='topic+whiteSet'></span>

<h3>Description</h3>

<p>Sets the plot environment to draw a long dataset. It is without
background, and with only axes with major and minor ticks.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>whiteSet(
  xlim,
  ylim,
  xtick = NA,
  ytick = NA,
  nx = 1,
  ny = 1,
  xaxs = "i",
  yaxs = "i",
  xarg = list(tick.ratio = 0.5),
  yarg = list(tick.ratio = 0.5, las = 1),
  add = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="whiteSet_+3A_xlim">xlim</code>, <code id="whiteSet_+3A_ylim">ylim</code></td>
<td>
<p>the x and y limits (e.g. xlim = c(-1,1))</p>
</td></tr>
<tr><td><code id="whiteSet_+3A_xtick">xtick</code>, <code id="whiteSet_+3A_ytick">ytick</code></td>
<td>
<p>the interval between each major ticks for x and y</p>
</td></tr>
<tr><td><code id="whiteSet_+3A_nx">nx</code>, <code id="whiteSet_+3A_ny">ny</code></td>
<td>
<p>the number of intervals between major ticks to be
divided by minor ticks in the x and y axes</p>
</td></tr>
<tr><td><code id="whiteSet_+3A_xaxs">xaxs</code>, <code id="whiteSet_+3A_yaxs">yaxs</code></td>
<td>
<p>The style of axis interval calculation to be used
for the x and y axes. By default it is &quot;i&quot; (internal): it just finds an axis
with pretty labels that fits within the original data range. You can also set
it to &quot;r&quot; (regular): it first extends the data range by 4 percent at each end
and then finds an axis with pretty labels that fits within the extended
range. See ?par for further explanation</p>
</td></tr>
<tr><td><code id="whiteSet_+3A_xarg">xarg</code>, <code id="whiteSet_+3A_yarg">yarg</code></td>
<td>
<p>a list of arguments to feed to minorAxis() for the
x and y axes. See the ?minorAxis help page for the possible arguments. See
?merge_list for further information.</p>
</td></tr>
<tr><td><code id="whiteSet_+3A_add">add</code></td>
<td>
<p>whether to add to an existing plot</p>
</td></tr>
</table>


<h3>See Also</h3>

<p>Similar functions: <code><a href="#topic+greySet">greySet</a></code> and <code><a href="#topic+blackSet">blackSet</a></code>
</p>
<p>To create axes with major and minor ticks: <code><a href="#topic+minorAxis">minorAxis</a></code>
</p>
<p>To print a plot in pdf: <code><a href="#topic+pdfDisplay">pdfDisplay</a></code>
</p>
<p>To automatically determine pretty interval limits: <code><a href="#topic+encase">encase</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>y &lt;- c(0,11,19,33)
x &lt;- c(1,2,2.5,4)

a &lt;- min(y)
b &lt;- max(y)

f &lt;- encase(a-1,b,5)

whiteSet(c(0,4), f, ytick = 5, ny = 5, xaxs = "r")

points(x, y, pch=19)
</code></pre>

<hr>
<h2 id='ylink'>Draws connection lines to connect two points in y</h2><span id='topic+ylink'></span>

<h3>Description</h3>

<p>Draws connection lines to connect two points in y
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ylink(y1, y2, x1, x2, ratio = 0.1, xi1 = NA, xi2 = NA, l = list(lty = 3))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ylink_+3A_y1">y1</code>, <code id="ylink_+3A_y2">y2</code></td>
<td>
<p>y positions (you can provide several ones at once)</p>
</td></tr>
<tr><td><code id="ylink_+3A_x1">x1</code>, <code id="ylink_+3A_x2">x2</code></td>
<td>
<p>x positions (you can provide several ones at once)</p>
</td></tr>
<tr><td><code id="ylink_+3A_ratio">ratio</code></td>
<td>
<p>the ratio of the breaking points of the lines (from the
start or end to the centre)</p>
</td></tr>
<tr><td><code id="ylink_+3A_xi1">xi1</code>, <code id="ylink_+3A_xi2">xi2</code></td>
<td>
<p>x positions of the
breaking points of the lines.</p>
</td></tr>
<tr><td><code id="ylink_+3A_l">l</code></td>
<td>
<p>a list of arguments to feed lines(). Go see ?lines to know
which arguments can be provided. See ?merge.list for further information.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+multilines">multilines</a></code>, <code><a href="#topic+bedtext">bedtext</a></code>,
<code><a href="#topic+infobar">infobar</a></code> and <code><a href="#topic+nlegend">nlegend</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>plot(c(0,6),c(-20,20), type = "n")

infobar(ymin = c(-20,0), ymax = c(0,20), xmin = 1, xmax = 0,
        m = list(col = c("black", "white")))

infobar(ymin = c(-20,10), ymax = c(10,20), xmin = 5, xmax = 6,
        m = list(col = c("black", "white")))

ylink(c(0,12),c(10,20), x1 = 1, x2 = 5, ratio = 0.2,
      l = list(lty = c(1,3), lwd = 2))

</code></pre>

<hr>
<h2 id='zijderveld'>Draws a Zijderveld plot</h2><span id='topic+zijderveld'></span>

<h3>Description</h3>

<p>Draws a Zijderveld plot: it projects 3D points (having
declination, inclination and intensity) in 2D, horizontally and vertically.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>zijderveld(
  dec,
  inc,
  int,
  xh = "WE",
  xv = xh,
  centre = F,
  xlim = NA,
  ylim = NA,
  unit = NA,
  xlab = "",
  ylab = "",
  labels = NA,
  nlabels = 1,
  h = list(pch = 19),
  v = list(pch = 21, bg = "white"),
  f = list(pch = 21, bg = "white", cex = 1.5),
  t = list(pos = 3, offset = 0.5),
  l = list(),
  anchored = T,
  style = "branches",
  tcl = 0.2,
  orientation = TRUE,
  scientific = NA,
  decimals = 10,
  add = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="zijderveld_+3A_dec">dec</code></td>
<td>
<p>declination of the data; it is the angle from the north
taken on an horizontal plane. It is measured clockwise from North and ranges
from 0 to 360° (Tauxe 2010). Values outside this range are corrected
by incfix().</p>
</td></tr>
<tr><td><code id="zijderveld_+3A_inc">inc</code></td>
<td>
<p>inclination of the data; it is the angle from the
horizontal, is positive downward, and ranges from +90° for straight down to
-90° for straight up (Tauxe, 2010). Values outside this range are corrected
by incfix().</p>
</td></tr>
<tr><td><code id="zijderveld_+3A_int">int</code></td>
<td>
<p>intensity of the data.</p>
</td></tr>
<tr><td><code id="zijderveld_+3A_xh">xh</code></td>
<td>
<p>orientation of the x axis for the horizontal points: can be
'SN' or 'WE'.</p>
</td></tr>
<tr><td><code id="zijderveld_+3A_xv">xv</code></td>
<td>
<p>orientation of the x axis for the horizontal points: can be
'SN', 'WE' or 'modified' (for the latter the horizontal projection of the
vector given by the square root of the addition of the squared horizontal
components).</p>
</td></tr>
<tr><td><code id="zijderveld_+3A_centre">centre</code></td>
<td>
<p>logical, whether the [0,0] point should be in the centre
of the plot. Is ignored if xlim and/or ylim are defined.</p>
</td></tr>
<tr><td><code id="zijderveld_+3A_xlim">xlim</code>, <code id="zijderveld_+3A_ylim">ylim</code></td>
<td>
<p>the x and y minimal limits. The actual limits can
change to keep a x/y ratio of 1.</p>
</td></tr>
<tr><td><code id="zijderveld_+3A_unit">unit</code></td>
<td>
<p>the tick interval.</p>
</td></tr>
<tr><td><code id="zijderveld_+3A_xlab">xlab</code>, <code id="zijderveld_+3A_ylab">ylab</code></td>
<td>
<p>the titles for the axes.</p>
</td></tr>
<tr><td><code id="zijderveld_+3A_labels">labels</code></td>
<td>
<p>a character vector of labels to add to each point.</p>
</td></tr>
<tr><td><code id="zijderveld_+3A_nlabels">nlabels</code></td>
<td>
<p>the number of labels to skip (for clarity).</p>
</td></tr>
<tr><td><code id="zijderveld_+3A_h">h</code>, <code id="zijderveld_+3A_v">v</code>, <code id="zijderveld_+3A_f">f</code>, <code id="zijderveld_+3A_t">t</code>, <code id="zijderveld_+3A_l">l</code></td>
<td>
<p>list of graphical parameters to feed the graphical
functions: h, v and f are fed to points() for the horizontal, vertical and
first points respectively; t is fed to the text() for the labels and l is
fed to lines() for the lines joining each horizontal and vertical points. See
?points, ?text and ?lines help page for the possible arguments. See
?merge_list for further information.</p>
</td></tr>
<tr><td><code id="zijderveld_+3A_anchored">anchored</code></td>
<td>
<p>logical, whether the lines should be anchored to the
[0,0] point.</p>
</td></tr>
<tr><td><code id="zijderveld_+3A_style">style</code></td>
<td>
<p>the style of the plot: 'branches', 'box0', 'box1', or
'box2'. The boxes are advised when zooming using xlim and/or ylim.</p>
</td></tr>
<tr><td><code id="zijderveld_+3A_tcl">tcl</code></td>
<td>
<p>The length of tick marks (see par() help page).</p>
</td></tr>
<tr><td><code id="zijderveld_+3A_orientation">orientation</code></td>
<td>
<p>logical, whether to add captions indicating the
orientation of the plot.</p>
</td></tr>
<tr><td><code id="zijderveld_+3A_scientific">scientific</code></td>
<td>
<p>logical or NA, whether have scientific notation
(e.g. -1.0E-06) or not (e.g. 0.00015). If NA, R will be left only judge.</p>
</td></tr>
<tr><td><code id="zijderveld_+3A_decimals">decimals</code></td>
<td>
<p>the number of decimals if scientific is T or F. Having
not enough decimals can lead to override the unit parameter, but the tick
labels will be correctly aligned.</p>
</td></tr>
<tr><td><code id="zijderveld_+3A_add">add</code></td>
<td>
<p>logical, whether to add the plot to an existing plot.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>By default horizontal projection is made of black points, vertical
of white points.
</p>


<h3>References</h3>


<ul>
<li><p> Tauxe, L., 2010. Essentials of Paleomagnetism. University of
California Press.
</p>
</li></ul>



<h3>See Also</h3>

<p><code><a href="#topic+earnet">earnet</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>zd &lt;- zeq_example

ori &lt;- par()$mfrow

par(mfrow = c(1,2))

zijderveld(dec = zd$Dec, inc = zd$Inc, int = zd$Int,
           xh = "WE", unit = 10^-5)

zijderveld(dec = zd$Dec, inc = zd$Inc, int = zd$Int,
           style = "box1", scientific = FALSE, decimals = 5,
           labels = zd$Treat, nlabels = 2)

par(mfrow = ori)

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
