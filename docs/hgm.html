<!DOCTYPE html><html><head><title>Help for package hgm</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {hgm}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#hgm-package'>
<p>HGM</p></a></li>
<li><a href='#hgm.ncBingham'>
<p>The function hgm.ncBingham performs the holonomic gradient method (HGM)</p>
for Bingham distributions.</a></li>
<li><a href='#hgm.ncorthant'>
<p>The function hgm.ncorthant evaluates the orthant probability.</p></a></li>
<li><a href='#hgm.ncso3'>
<p>The function hgm.ncso3 evaluates the normalization constant for the Fisher</p>
distribution on SO(3).</a></li>
<li><a href='#hgm.p2wishart'>
<p>The function hgm.p2wishart evaluates the cumulative distribution function</p>
of the largest eigenvalues of W1*inverse(W2).</a></li>
<li><a href='#hgm.pwishart'>
<p>The function hgm.pwishart evaluates the cumulative distribution function</p>
of random wishart matrices.</a></li>
<li><a href='#hgm.Rhgm'>
<p>The function hgm.Rhgm performs the holonomic gradient method (HGM)</p>
for a given Pfaffian system and an initial value vector.</a></li>
<li><a href='#hgm.Rhgm.demo1'>
<p>The function hgm.Rhgm.demo1 performs a demonstration of the function</p>
hgm.Rhgm.</a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 2.6.0), deSolve</td>
</tr>
<tr>
<td>Title:</td>
<td>Holonomic Gradient Method and Gradient Descent</td>
</tr>
<tr>
<td>Version:</td>
<td>1.23</td>
</tr>
<tr>
<td>Date:</td>
<td>2023-01-21</td>
</tr>
<tr>
<td>Author:</td>
<td>Nobuki Takayama, Tamio Koyama, Tomonari Sei, Hiromasa Nakayama, Kenta Nishiyama </td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Nobuki Takayama &lt;takayama@math.kobe-u.ac.jp&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>The holonomic gradient method (HGM, hgm) gives a way to evaluate normalization
  constants of unnormalized probability distributions by utilizing holonomic 
  systems of differential or difference equations. The holonomic gradient descent (HGD, hgd) gives a method
  to find maximal likelihood estimates by utilizing the HGM.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a></td>
</tr>
<tr>
<td>LazyLoad:</td>
<td>yes</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="http://www.openxm.org">http://www.openxm.org</a></td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-01-31 17:55:25 UTC; nobuki</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-01-31 22:10:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='hgm-package'>
HGM
</h2><span id='topic+hgm-package'></span><span id='topic+HGM'></span><span id='topic+hgm'></span>

<h3>Description</h3>

<p>The holonomic gradient method (HGM, hgm) gives a way to evaluate normalizing
constants of unnormalized probability distributions by utilizing holonomic 
systems of differential or difference equations. 
The holonomic gradient descent (HGD, hgd) gives a method
to find maximal likelihood estimates by utilizing the HGM.
</p>


<h3>Details</h3>


<table>
<tr>
 <td style="text-align: left;">
Package: </td><td style="text-align: left;"> hgm</td>
</tr>
<tr>
 <td style="text-align: left;">
Type: </td><td style="text-align: left;"> Package</td>
</tr>
<tr>
 <td style="text-align: left;">
License: </td><td style="text-align: left;"> GPL-2</td>
</tr>
<tr>
 <td style="text-align: left;">
LazyLoad: </td><td style="text-align: left;"> yes</td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>

<p>The HGM and HGD are proposed in the paper below.
This method based on the fact that a broad class of normalizing constants
of unnormalized probability distributions belongs to the class of
holonomic functions, which are solutions of holonomic systems of linear
partial differential equations.
</p>


<h3>Note</h3>

<p>This package includes a small subset of the Gnu scientific library codes
(<a href="http://www.gnu.org/software/gsl/">http://www.gnu.org/software/gsl/</a>).
Then, it might cause a conflict with the package gsl.




</p>


<h3>References</h3>


<ul>
<li><p>  (N3OST2)  Hiromasa Nakayama, Kenta Nishiyama, Masayuki Noro, Katsuyoshi Ohara,
Tomonari Sei, Nobuki Takayama, Akimichi Takemura,
Holonomic Gradient Descent  and its Application to Fisher-Bingham Integral,
Advances in Applied Mathematics 47 (2011), 639&ndash;658, 
doi: <a href="https://doi.org/10.1016/j.aam.2011.03.001">10.1016/j.aam.2011.03.001</a>
</p>
</li>
<li><p> (dojo) Edited by T.Hibi,  Groebner Bases: Statistics and Software Systems, Springer, 2013,
doi: <a href="https://doi.org/10.1007/978-4-431-54574-3">10.1007/978-4-431-54574-3</a>
</p>
</li>
<li>  <p><a href="http://www.openxm.org">http://www.openxm.org</a>
</p>
</li></ul>



<h3>See Also</h3>

<p><code><a href="#topic+hgm.ncBingham">hgm.ncBingham</a></code>,
<code><a href="#topic+hgm.ncorthant">hgm.ncorthant</a></code>,
<code><a href="#topic+hgm.ncso3">hgm.ncso3</a></code>,
<code><a href="#topic+hgm.pwishart">hgm.pwishart</a></code>,
<code><a href="#topic+hgm.Rhgm">hgm.Rhgm</a></code>
<code><a href="#topic+hgm.p2wishart">hgm.p2wishart</a></code>,
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
example(hgm.ncBingham)
example(hgm.ncorthant)
example(hgm.ncso3)
example(hgm.pwishart)
example(hgm.Rhgm)
example(hgm.p2wishart)

## End(Not run)
</code></pre>

<hr>
<h2 id='hgm.ncBingham'>
The function hgm.ncBingham performs the holonomic gradient method (HGM)
for Bingham distributions.
</h2><span id='topic+hgm.ncBingham'></span>

<h3>Description</h3>

<p>The function hgm.ncBingham performs the holonomic gradient method (HGM)
for Bingham distributions with the deSolve package in R.
</p>


<h3>Usage</h3>

<pre><code class='language-R'> hgm.ncBingham(th, d=rep(1,length(th)+1), logarithm=FALSE,
               ini.method="power", times=NULL, withvol=FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="hgm.ncBingham_+3A_th">th</code></td>
<td>
<p> A (p-1)-dimensional vector which specifies the first (p-1) components of the parameter vector of the Bingham distribution on the (p-1)-dim sphere. The p-th parameter is assumed to be zero.</p>
</td></tr>
<tr><td><code id="hgm.ncBingham_+3A_d">d</code></td>
<td>

<p>A p-dimensional vector which specifies the multiplicity of the parameter. The default is all-one vector.
</p>
</td></tr>
<tr><td><code id="hgm.ncBingham_+3A_logarithm">logarithm</code></td>
<td>

<p>If 'logarithm' is TRUE, then the result is log of the normalizing constant.
</p>
</td></tr>
<tr><td><code id="hgm.ncBingham_+3A_ini.method">ini.method</code></td>
<td>

<p>The method for computing the initial value. Only &quot;power&quot; is implemented now.
</p>
</td></tr>
<tr><td><code id="hgm.ncBingham_+3A_times">times</code></td>
<td>

<p>a vector; times in [0,1] at which explicit estimates for G are desired.
If time = NULL, the set 0,1 is used, and only the final value is returned.
</p>
</td></tr>
<tr><td><code id="hgm.ncBingham_+3A_withvol">withvol</code></td>
<td>

<p>If 'withvol' is TRUE, then the normalizing constant with volume of sphere is returned.
Otherwise that without volume is returned.
Therefore, if 'withvol' is FALSE and the parameter is zero, then the normalizing constant becomes 1.
</p>
</td></tr>
<tr><td><code id="hgm.ncBingham_+3A_...">...</code></td>
<td>

<p>Additional parameters for computing initial values. Details are omitted.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function hgm.ncBingham computes the normalizing constant
of the Bingham distribution and its derivatives at any specified point.
The initial value is computed by the power series expansion.

</p>


<h3>Value</h3>

<p>The output is p-dimensional vector G.
The first element of G is the normalizing constant
and the following (p-1)-elements are partial derivative
of the normalizing constant with respect to the first
(p-1) components of the parameter 'th'.
</p>


<h3>Author(s)</h3>

<p>Tomonari Sei
</p>


<h3>References</h3>

<p><a href="http://www.math.kobe-u.ac.jp/OpenXM/Math/hgm/ref-hgm.html">http://www.math.kobe-u.ac.jp/OpenXM/Math/hgm/ref-hgm.html</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Example 1.
hgm.ncBingham(c(1,3,5))
</code></pre>

<hr>
<h2 id='hgm.ncorthant'>
The function hgm.ncorthant evaluates the orthant probability.
</h2><span id='topic+hgm.ncorthant'></span>

<h3>Description</h3>

<p>The function hgm.ncorthant evaluates the orthant probability,
which is the normalization constant of the multivariate normal distribution
restrcted to the first orthant.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>hgm.ncorthant(x,y,rk_step_size=1e-3)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="hgm.ncorthant_+3A_x">x</code></td>
<td>
<p>See the description of y.</p>
</td></tr>
<tr><td><code id="hgm.ncorthant_+3A_y">y</code></td>
<td>

<p>This function evaluates the orthant probability for the m dimensional 
multivariate
normal distribution whose m by m covariance matrix and the mean vector 
of size m are x and    y respectively. 
</p>
</td></tr>
<tr><td><code id="hgm.ncorthant_+3A_rk_step_size">rk_step_size</code></td>
<td>

<p>The step size for the Runge-Kutta method to apply the HGM.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function hgm.ncorthant evaluates the orthant probability,
which is the normalization constant of the m-dimensional 
multivariate normal distribution
restrcted to the first orthant.
It uses the holonomic gradient method (HGM) to evalute it.
The rank of the system of differential equations for the HGM is
2^m.

</p>


<h3>Value</h3>

<p>The output is the orthant probalibity.
</p>


<h3>Author(s)</h3>

<p>Tamio Koyama
</p>


<h3>References</h3>

<p>Tamio Koyama, Akimichi Takemura, 
Calculation of orthant probabilities
by the holonomic gradient method,
<a href="https://arxiv.org/abs/1211.6822">https://arxiv.org/abs/1211.6822</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## =====================================================
## Example 1. Computing the orthant probability
## =====================================================
x &lt;- matrix(c(15,26,23,19,
	      26,47,46,35,
	      23,46,65,38,
	      19,35,38,33), nrow =4) 
y &lt;- c(1,2,3,4)
hgm.ncorthant(x,y)
</code></pre>

<hr>
<h2 id='hgm.ncso3'>
The function hgm.ncso3 evaluates the normalization constant for the Fisher
distribution on SO(3).
</h2><span id='topic+hgm.ncso3'></span>

<h3>Description</h3>

<p>The function hgm.ncso3 evaluates the normalization constant for the Fisher
distribution on SO(3).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>hgm.ncso3(a,b,c,t0=0.0,q=1,deg=0,log=0)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="hgm.ncso3_+3A_a">a</code></td>
<td>
<p>See the description of c.</p>
</td></tr>
<tr><td><code id="hgm.ncso3_+3A_b">b</code></td>
<td>
<p>See the description of c.</p>
</td></tr>
<tr><td><code id="hgm.ncso3_+3A_c">c</code></td>
<td>

<p>This function evaluates the normalization constant for the parameter
Theta=diag(theta_ii) of the Fisher distribution on SO(3).
The variables a,b,c stand for the parameters
theta_11, theta_22, theta_33 respectively.
</p>
</td></tr>
<tr><td><code id="hgm.ncso3_+3A_t0">t0</code></td>
<td>

<p>It is the initial point to evaluate the series. If it is set to 0.0,
a default value is used.
</p>
</td></tr>
<tr><td><code id="hgm.ncso3_+3A_q">q</code></td>
<td>

<p>If it is 1, then the program works in a quiet mode.
</p>
</td></tr>
<tr><td><code id="hgm.ncso3_+3A_deg">deg</code></td>
<td>

<p>It gives the approximation degree of the power series approximation
of the normalization constant near the origin.
If it is 0, a default value is used.
</p>
</td></tr>
<tr><td><code id="hgm.ncso3_+3A_log">log</code></td>
<td>

<p>If it is 1, then the function returns the log of the normalizing constant.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The normalization constant c(Theta) 
of the Fisher distribution on SO(3) is defined  by
integral( exp(trace( transpose(Theta) X)) )
where X is the integration variable and runs over S0(3) and
Theta is a 3 x 3 matrix parameter.
A general HGM algorithm to evaluate the normalization constant 
is given in the reference below.
We use the Corollary 1 and the series expansion in 3.2 for the evaluation.

</p>


<h3>Value</h3>

<p>The output is an array of c(Theta) and its derivatives with respect to Theta_11,Theta_22,Theta_33. It is the vector C of the reference below. When log=1, the output is an array of log of them.
</p>


<h3>Author(s)</h3>

<p>Nobuki Takayama
</p>


<h3>References</h3>

<p>Tomonari Sei, Hiroki Shibata, Akimichi Takemura, Katsuyoshi Ohara, Nobuki Takayama,
Properties and applications of Fisher distribution on the rotation group,
Journal of Multivariate Analysis, 116 (2013), 440&ndash;455,
doi: <a href="https://doi.org/10.1016/j.jmva.2013.01.010">10.1016/j.jmva.2013.01.010</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## =====================================================
## Example 1. Computing normalization constant of the Fisher distribution on SO(3)
## =====================================================
hgm.ncso3(1,2,3)[1]

## =====================================================
## Example 2. Asteroid data in the paper
## =====================================================
hgm.ncso3(19.6,0.831,-0.671)[1]
</code></pre>

<hr>
<h2 id='hgm.p2wishart'>
The function hgm.p2wishart evaluates the cumulative distribution function
of the largest eigenvalues of W1*inverse(W2).
</h2><span id='topic+hgm.p2wishart'></span>

<h3>Description</h3>

<p>The function hgm.p2wishart evaluates the cumulative distribution function
of the largest eigenvalues of W1*inverse(W2) where W1 and W2 are Wishart
matrices of size m*m of the freedom n1 and n2 respectively.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>hgm.p2wishart(m,n1,n2,beta,q0,approxdeg,h,dp,q,mode,method,
            err,automatic,assigned_series_error,verbose,autoplot)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="hgm.p2wishart_+3A_m">m</code></td>
<td>
<p>The dimension of the Wishart matrix.</p>
</td></tr>
<tr><td><code id="hgm.p2wishart_+3A_n1">n1</code></td>
<td>
<p>The degree of freedome of the Wishart distribution S1</p>
</td></tr>
<tr><td><code id="hgm.p2wishart_+3A_n2">n2</code></td>
<td>
<p>The degree of freedome of the Wishart distribution S2</p>
</td></tr>
<tr><td><code id="hgm.p2wishart_+3A_beta">beta</code></td>
<td>
<p>The eigenvalues of inverse(S2)*S1 where S1 and S2 are 
covariant matrices of W1 and W2 respectively.
</p>
</td></tr>
<tr><td><code id="hgm.p2wishart_+3A_q0">q0</code></td>
<td>
<p>The point to evaluate the matrix hypergeometric series. q0&gt;0</p>
</td></tr>
<tr><td><code id="hgm.p2wishart_+3A_approxdeg">approxdeg</code></td>
<td>

<p>Zonal polynomials upto the approxdeg are calculated to evaluate
values near the origin. A zonal polynomial is determined by a given
partition (k1,...,km). We call the sum k1+...+km the degree.
</p>
</td></tr>
<tr><td><code id="hgm.p2wishart_+3A_h">h</code></td>
<td>

<p>A (small) step size for the Runge-Kutta method. h&gt;0.
</p>
</td></tr>
<tr><td><code id="hgm.p2wishart_+3A_dp">dp</code></td>
<td>

<p>Sampling interval of solutions by the Runge-Kutta method.
When autoplot=1 or dp is negative, it is automatically set.
if it is 0, no sample is stored.
</p>
</td></tr>
<tr><td><code id="hgm.p2wishart_+3A_q">q</code></td>
<td>

<p>The second value y[0] of this function is the Prob(L1 &lt; q)
where L1 is the first eigenvalue of the Wishart matrix.
</p>
</td></tr>
<tr><td><code id="hgm.p2wishart_+3A_mode">mode</code></td>
<td>

<p>When mode=c(1,0,0), it returns the evaluation 
of the matrix hypergeometric series and its derivatives at q0.
When mode=c(1,1,(2^m+1)*p), intermediate values of P(L1 &lt; x) with respect to
p-steps of x are also returned.  Sampling interval is controled by dp.
When autoplot=1, mode is automatically set.
</p>
</td></tr>
<tr><td><code id="hgm.p2wishart_+3A_method">method</code></td>
<td>

<p>a-rk4 is the default value. 
When method=&quot;a-rk4&quot;, the adaptive Runge-Kutta method is used.
Steps are automatically adjusted by err.
</p>
</td></tr>
<tr><td><code id="hgm.p2wishart_+3A_err">err</code></td>
<td>

<p>When err=c(e1,e2), e1 is the absolute error and e2 is the relative error.
This parameter controls the adative Runge-Kutta method.
If the output is absurd, you may get a correct answer by setting,  e.g.,
err=c(1e-(xy+5), 1e-10) or by increasing q0 when initial value at q0 is very small as 1e-xy. 
</p>
</td></tr>  
<tr><td><code id="hgm.p2wishart_+3A_automatic">automatic</code></td>
<td>

<p>automatic=1 is the default value.
If it is 1, the degree of the series approximation will be increased until 
|(F(i)-F(i-1))/F(i-1)| &lt; assigned_series_error where
F(i) is the degree i approximation of the hypergeometric series
with matrix argument.
Step sizes for the Runge-Kutta method are also set automatically from
the assigned_series_error if it is 1.
</p>
</td></tr>  
<tr><td><code id="hgm.p2wishart_+3A_assigned_series_error">assigned_series_error</code></td>
<td>

<p>assigned_series_error=0.00001 is the default value.
</p>
</td></tr>  
<tr><td><code id="hgm.p2wishart_+3A_verbose">verbose</code></td>
<td>

<p>verbose=0 is the default value.
If it is 1, then steps of automatic degree updates and several parameters
are output to stdout and stderr.
</p>
</td></tr>  
<tr><td><code id="hgm.p2wishart_+3A_autoplot">autoplot</code></td>
<td>

<p>autoplot=0 is the default value.
If it is 1, then this function outputs an input for plot
(which is equivalent to setting the 3rd argument of the mode parameter properly).
When ans is the output, ans[1,] is c(q,prob at q,...), ans[2,] is c(q0,prob at q0,...), and ans[3,] is c(q0+q/100,prob at q/100,...), ...
When the adaptive Runge-Kutta method is used, the step size h may change
automatically,
which  makes the sampling period change, in other words, the sampling points 
q0+q/100, q0+2*q/100, q0+3*q/100, ... may  change. 
In this case, the output matrix may contain zero rows in the tail or overfull. 
In case of the overful, use the mode option to get the all result.
</p>
</td></tr>  
</table>


<h3>Details</h3>

<p>It is evaluated by the Koev-Edelman algorithm when x is near the origin and
by the HGM when x is far from the origin.
We can obtain more accurate result when the variables h is smaller,
q0 is relevant value (not very big, not very small),
and the approxdeg is more larger.
A heuristic method to set parameters q0, h, approxdeg properly
is to make x larger and to check if the y[0] approaches to 1.

</p>


<h3>Value</h3>

<p>The output is x, y[0], ..., y[2^m] in the default mode,  
y[0] is the value of the cumulative distribution
function P(L1 &lt; x) at x.  y[1],...,y[2^m] are some derivatives.
See the reference below.
</p>


<h3>Note</h3>

<p>This function does not work well under the following cases:
1. The beta (the set of eigenvalues)
is degenerated or is almost degenerated.
2. The beta is very skew, in other words, there is a big eigenvalue
and there is also a small eigenvalue.
The error control is done by a heuristic method. 
The obtained value is not validated automatically.
</p>


<h3>Author(s)</h3>

<p>Nobuki Takayama
</p>


<h3>References</h3>

<p>H.Hashiguchi, N.Takayama, A.Takemura,
Distribution of ratio of two Wishart matrices and evaluation of cumulative probability by holonomic gradient method.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## =====================================================
## Example 1. 
## =====================================================
hgm.p2wishart(m=3,n1=5,n2=10,beta=c(1,2,4),q=4)
## =====================================================
## Example 2. 
## =====================================================
b&lt;-hgm.p2wishart(m=3,n1=5,n2=10,beta=c(1,2,4),q0=0.3,q=20,approxdeg=20,mode=c(1,1,(8+1)*1000));
c&lt;-matrix(b,ncol=8+1,byrow=1);
#plot(c)
## =====================================================
## Example 3. 
## =====================================================
c&lt;-hgm.p2wishart(m=3,n1=5,n2=10,beta=c(1,2,4),q0=0.3,q=20,approxdeg=20,autoplot=1);
#plot(c)
</code></pre>

<hr>
<h2 id='hgm.pwishart'>
The function hgm.pwishart evaluates the cumulative distribution function
of random wishart matrices.
</h2><span id='topic+hgm.pwishart'></span>

<h3>Description</h3>

<p>The function hgm.pwishart evaluates the cumulative distribution function
of random wishart matrices of size m times m.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>hgm.pwishart(m,n,beta,q0,approxdeg,h,dp,q,mode,method,
            err,automatic,assigned_series_error,verbose,autoplot)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="hgm.pwishart_+3A_m">m</code></td>
<td>
<p>The dimension of the Wishart matrix.</p>
</td></tr>
<tr><td><code id="hgm.pwishart_+3A_n">n</code></td>
<td>
<p>The degree of freedome (a parameter of the Wishart distribution)</p>
</td></tr>
<tr><td><code id="hgm.pwishart_+3A_beta">beta</code></td>
<td>
<p>The eigenvalues of the inverse of the covariant matrix /2
(a parameter of the Wishart distribution).
The beta is equal to inverse(sigma)/2.
</p>
</td></tr>
<tr><td><code id="hgm.pwishart_+3A_q0">q0</code></td>
<td>
<p>The point to evaluate the matrix hypergeometric series. q0&gt;0</p>
</td></tr>
<tr><td><code id="hgm.pwishart_+3A_approxdeg">approxdeg</code></td>
<td>

<p>Zonal polynomials upto the approxdeg are calculated to evaluate
values near the origin. A zonal polynomial is determined by a given
partition (k1,...,km). We call the sum k1+...+km the degree.
</p>
</td></tr>
<tr><td><code id="hgm.pwishart_+3A_h">h</code></td>
<td>

<p>A (small) step size for the Runge-Kutta method. h&gt;0.
</p>
</td></tr>
<tr><td><code id="hgm.pwishart_+3A_dp">dp</code></td>
<td>

<p>Sampling interval of solutions by the Runge-Kutta method.
When autoplot=1 or dp is negative, it is automatically set.
if it is 0, no sample is stored.
</p>
</td></tr>
<tr><td><code id="hgm.pwishart_+3A_q">q</code></td>
<td>

<p>The second value y[0] of this function is the Prob(L1 &lt; q)
where L1 is the first eigenvalue of the Wishart matrix.
</p>
</td></tr>
<tr><td><code id="hgm.pwishart_+3A_mode">mode</code></td>
<td>

<p>When mode=c(1,0,0), it returns the evaluation 
of the matrix hypergeometric series and its derivatives at q0.
When mode=c(1,1,(2^m+1)*p), intermediate values of P(L1 &lt; x) with respect to
p-steps of x are also returned.  Sampling interval is controled by dp.
When autoplot=1, it is automatically set.
</p>
</td></tr>
<tr><td><code id="hgm.pwishart_+3A_method">method</code></td>
<td>

<p>a-rk4 is the default value. 
When method=&quot;a-rk4&quot;, the adaptive Runge-Kutta method is used.
Steps are automatically adjusted by err.
</p>
</td></tr>
<tr><td><code id="hgm.pwishart_+3A_err">err</code></td>
<td>

<p>When err=c(e1,e2), e1 is the absolute error and e2 is the relative error.
This parameter controls the adative Runge-Kutta method.
If the output is absurd, you may get a correct answer by setting,  e.g.,
err=c(1e-(xy+5), 1e-10) or by increasing q0 when initial value at q0 is very small as 1e-xy. 
</p>
</td></tr>  
<tr><td><code id="hgm.pwishart_+3A_automatic">automatic</code></td>
<td>

<p>automatic=1 is the default value.
If it is 1, the degree of the series approximation will be increased until 
|(F(i)-F(i-1))/F(i-1)| &lt; assigned_series_error where
F(i) is the degree i approximation of the hypergeometric series
with matrix argument.
Step sizes for the Runge-Kutta method are also set automatically from
the assigned_series_error if it is 1.
</p>
</td></tr>  
<tr><td><code id="hgm.pwishart_+3A_assigned_series_error">assigned_series_error</code></td>
<td>

<p>assigned_series_error=0.00001 is the default value.
</p>
</td></tr>  
<tr><td><code id="hgm.pwishart_+3A_verbose">verbose</code></td>
<td>

<p>verbose=0 is the default value.
If it is 1, then steps of automatic degree updates and several parameters
are output to stdout and stderr.
</p>
</td></tr>  
<tr><td><code id="hgm.pwishart_+3A_autoplot">autoplot</code></td>
<td>

<p>autoplot=0 is the default value.
If it is 1, then this function outputs an input for plot
(which is equivalent to setting the 3rd argument of the mode parameter properly).
When ans is the output, ans[1,] is c(q,prob at q,...), ans[2,] is c(q0,prob at q0,...), and ans[3,] is c(q0+q/100,prob at q/100,...), ...
When the adaptive Runge-Kutta method is used, the step size h may change
automatically,
which  makes the sampling period change, in other words, the sampling points 
q0+q/100, q0+2*q/100, q0+3*q/100, ... may  change. 
In this case, the output matrix may contain zero rows in the tail or overfull. 
In case of the overful, use the mode option to get the all result.
</p>
</td></tr>  
</table>


<h3>Details</h3>

<p>It is evaluated by the Koev-Edelman algorithm when x is near the origin and
by the HGM when x is far from the origin.
We can obtain more accurate result when the variables h is smaller,
q0 is relevant value (not very big, not very small),
and the approxdeg is more larger.
A heuristic method to set parameters q0, h, approxdeg properly
is to make x larger and to check if the y[0] approaches to 1.

</p>


<h3>Value</h3>

<p>The output is x, y[0], ..., y[2^m] in the default mode,  
y[0] is the value of the cumulative distribution
function P(L1 &lt; x) at x.  y[1],...,y[2^m] are some derivatives.
See the reference below.
</p>


<h3>Note</h3>

<p>This function does not work well under the following cases:
1. The beta (the set of eigenvalues)
is degenerated or is almost degenerated.
2. The beta is very skew, in other words, there is a big eigenvalue
and there is also a small eigenvalue.
The error control is done by a heuristic method. 
The obtained value is not validated automatically.
</p>


<h3>Author(s)</h3>

<p>Nobuki Takayama
</p>


<h3>References</h3>

<p>H.Hashiguchi, Y.Numata, N.Takayama, A.Takemura,
Holonomic gradient method for the distribution function of the largest root of a Wishart matrix,
Journal of Multivariate Analysis, 117, (2013) 296-312, 
doi: <a href="https://doi.org/10.1016/j.jmva.2013.03.011">10.1016/j.jmva.2013.03.011</a>,
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## =====================================================
## Example 1. 
## =====================================================
hgm.pwishart(m=3,n=5,beta=c(1,2,3),q=10)
## =====================================================
## Example 2. 
## =====================================================
b&lt;-hgm.pwishart(m=4,n=10,beta=c(1,2,3,4),q0=1,q=10,approxdeg=20,mode=c(1,1,(16+1)*100));
c&lt;-matrix(b,ncol=16+1,byrow=1);
#plot(c)
## =====================================================
## Example 3. 
## =====================================================
c&lt;-hgm.pwishart(m=4,n=10,beta=c(1,2,3,4),q0=1,q=10,approxdeg=20,autoplot=1);
#plot(c)
</code></pre>

<hr>
<h2 id='hgm.Rhgm'>
The function hgm.Rhgm performs the holonomic gradient method (HGM)
for a given Pfaffian system and an initial value vector.
</h2><span id='topic+hgm.Rhgm'></span>

<h3>Description</h3>

<p>The function hgm.Rhgm performs the holonomic gradient method (HGM)
for a given Pfaffian system and an initial value vector
with the deSolve package in R.
</p>


<h3>Usage</h3>

<pre><code class='language-R'> hgm.Rhgm(th0, G0, th1, dG.fun, times=NULL, fn.params=NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="hgm.Rhgm_+3A_th0">th0</code></td>
<td>
<p> A d-dimensional vector which is an initial point of the parameter vector th (theta).</p>
</td></tr>
<tr><td><code id="hgm.Rhgm_+3A_g0">G0</code></td>
<td>

<p>A r-dimensional vector which is the initial value of the vector G
of the normalizing constant and its derivatives.
</p>
</td></tr>
<tr><td><code id="hgm.Rhgm_+3A_th1">th1</code></td>
<td>

<p>A d-dimensional vector which is the target point of th.
</p>
</td></tr>
<tr><td><code id="hgm.Rhgm_+3A_dg.fun">dG.fun</code></td>
<td>

<p>dG.fun is the &ldquo;right hand sides&rdquo; of the Pfaffian system. 
It is a d*r-dimensional array.
</p>
</td></tr>
<tr><td><code id="hgm.Rhgm_+3A_times">times</code></td>
<td>
<p>a vector; times in [0,1] at which explicit estimates for G are desired.
If time = NULL, the set 0,1 is used, and only the final value is returned.
</p>
</td></tr>
<tr><td><code id="hgm.Rhgm_+3A_fn.params">fn.params</code></td>
<td>

<p>fn.params: a list of parameters passed to the function dG.fun.
If fn.params = NULL, no parameter is passed to dG.fun.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function hgm.Rhgm computes the value of a holonomic function
at a given point, using HGM.
This is a &ldquo;Step 3&rdquo; function (see the reference below),
which can be used for an arbitrary input, in the HGM framework.
Efficient &ldquo;Step 3&rdquo; functions are given for some distributions
in this package.
</p>
<p>The Pfaffian system assumed is
d G_j / d th_i = (dG.fun(th, G))_i,j
</p>
<p>The inputs of hgm.Rhgm are the initial point th0, initial value G0, final point th1,
and Pfaffian system dG.fun. The output is the final value G1.
</p>
<p>If the argument &lsquo;times&rsquo; is specified, the function returns a matrix,
where the first column denotes time, the following d-vector denotes th,
and the remaining r-vector denotes G.

</p>


<h3>Value</h3>

<p>The output is the value of G at th1. The first element of G is the normalizing
constant.
</p>


<h3>Author(s)</h3>

<p>Tomonari Sei
</p>


<h3>References</h3>

<p><a href="http://www.math.kobe-u.ac.jp/OpenXM/Math/hgm/ref-hgm.html">http://www.math.kobe-u.ac.jp/OpenXM/Math/hgm/ref-hgm.html</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Example 1.
# A demo program; von Mises--Fisher on S^{3-1}

G.exact = function(th){  # exact value by built-in function
  c( sinh(th[1])/th[1], cosh(th[1])/th[1] - sinh(th[1])/th[1]^2 )
}

dG.fun = function(th, G, fn.params=NULL){  # Pfaffian
  dG = array(0, c(1, 2))
  sh = G[1] * th[1]
  ch = G[2] * th[1] + G[1]
  dG[1,1] = G[2] # Pfaffian eq's
  dG[1,2] = sh/th[1] - 2*ch/th[1]^2 + 2*sh/th[1]^3
  dG
}

th0 = 0.5
th1 = 15

G0 = G.exact(th0)
G0

G1 = hgm.Rhgm(th0, G0, th1, dG.fun)  # HGM
G1

G1.exact = G.exact(th1)
G1.exact

#
# Example 2.
#
hgm.Rhgm.demo1()

</code></pre>

<hr>
<h2 id='hgm.Rhgm.demo1'>
The function hgm.Rhgm.demo1 performs a demonstration of the function
hgm.Rhgm.
</h2><span id='topic+hgm.Rhgm.demo1'></span>

<h3>Description</h3>

<p>The function hgm.Rhgm.demo1 performs a demonstration of the function
hgm.Rhgm.
</p>


<h3>Usage</h3>

<pre><code class='language-R'> hgm.Rhgm.demo1()
</code></pre>


<h3>Details</h3>

<p>The function hgm.Rhgm.demo1 evaluates the normalizing constant
of the Von-Mises distribution by the HGM.
</p>


<h3>Value</h3>

<p>The returned value is a dataframe.
The column exact of the dataframe is the exact value of the normalizing
constant. The column byHGM is the value obtained by the HGM.
The column start is the initial value for the HGM.
</p>


<h3>Author(s)</h3>

<p>Tomonari Sei
</p>


<h3>See Also</h3>

<p><code><a href="#topic+hgm.Rhgm">hgm.Rhgm</a></code>
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
