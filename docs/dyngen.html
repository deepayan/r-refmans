<!DOCTYPE html><html><head><title>Help for package dyngen</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {dyngen}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#as_dyno'><p>Convert simulation output to different formats.</p></a></li>
<li><a href='#backbone'><p>Backbone of the simulation model</p></a></li>
<li><a href='#bblego'><p>Design your own custom backbone easily</p></a></li>
<li><a href='#combine_models'><p>Combine multiple dyngen models</p></a></li>
<li><a href='#dyngen'><p>dyngen: A multi-modal simulator for spearheading single-cell omics analyses</p></a></li>
<li><a href='#example_model'><p>A (very!) small toy dyngen model</p></a></li>
<li><a href='#generate_cells'><p>Simulate the cells</p></a></li>
<li><a href='#generate_dataset'><p>Generate a dataset</p></a></li>
<li><a href='#generate_experiment'><p>Sample cells from the simulations</p></a></li>
<li><a href='#generate_feature_network'><p>Generate a target network</p></a></li>
<li><a href='#generate_gold_standard'><p>Simulate the gold standard</p></a></li>
<li><a href='#generate_kinetics'><p>Determine the kinetics of the feature network</p></a></li>
<li><a href='#generate_tf_network'><p>Generate a transcription factor network from the backbone</p></a></li>
<li><a href='#get_timings'><p>Return the timings of each of the dyngen steps</p></a></li>
<li><a href='#initialise_model'><p>Initial settings for simulating a dyngen dataset</p></a></li>
<li><a href='#kinetics_noise_none'><p>Add small noise to the kinetics of each simulation</p></a></li>
<li><a href='#list_backbones'><p>List of all predefined backbone models</p></a></li>
<li><a href='#plot_backbone_modulenet'><p>Visualise the backbone of a model</p></a></li>
<li><a href='#plot_backbone_statenet'><p>Visualise the backbone state network of a model</p></a></li>
<li><a href='#plot_experiment_dimred'><p>Plot a dimensionality reduction of the final dataset</p></a></li>
<li><a href='#plot_feature_network'><p>Visualise the feature network of a model</p></a></li>
<li><a href='#plot_gold_expression'><p>Visualise the expression of the gold standard over simulation time</p></a></li>
<li><a href='#plot_gold_mappings'><p>Visualise the mapping of the simulations to the gold standard</p></a></li>
<li><a href='#plot_gold_simulations'><p>Visualise the simulations using the dimred</p></a></li>
<li><a href='#plot_simulation_expression'><p>Visualise the expression of the simulations over simulation time</p></a></li>
<li><a href='#plot_simulations'><p>Visualise the simulations using the dimred</p></a></li>
<li><a href='#plot_summary'><p>Plot a summary of all dyngen simulation steps.</p></a></li>
<li><a href='#realcounts'><p>A set of real single cell expression datasets</p></a></li>
<li><a href='#realnets'><p>A set of gold standard gene regulatory networks</p></a></li>
<li><a href='#reexports'><p>Objects exported from other packages</p></a></li>
<li><a href='#rnorm_bounded'><p>A bounded version of rnorm</p></a></li>
<li><a href='#runif_subrange'><p>A subrange version of runif</p></a></li>
<li><a href='#simtime_from_backbone'><p>Determine simulation time from backbone</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>A Multi-Modal Simulator for Spearheading Single-Cell Omics
Analyses</td>
</tr>
<tr>
<td>Version:</td>
<td>1.0.5</td>
</tr>
<tr>
<td>Description:</td>
<td>A novel, multi-modal simulation engine for
    studying dynamic cellular processes at single-cell resolution. 'dyngen'
    is more flexible than current single-cell simulation engines. It
    allows better method development and benchmarking, thereby stimulating
    development and testing of novel computational methods. Cannoodt et
    al. (2021) &lt;<a href="https://doi.org/10.1038%2Fs41467-021-24152-2">doi:10.1038/s41467-021-24152-2</a>&gt;.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://opensource.org/licenses/mit-license.php">MIT</a> + file LICENSE</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://dyngen.dynverse.org">https://dyngen.dynverse.org</a>, <a href="https://github.com/dynverse/dyngen">https://github.com/dynverse/dyngen</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/dynverse/dyngen/issues">https://github.com/dynverse/dyngen/issues</a></td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.5.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>assertthat, dplyr, dynutils (&ge; 1.0.10), ggplot2, ggraph (&ge;
2.0), ggrepel, GillespieSSA2 (&ge; 0.2.6), grDevices, grid,
igraph, lmds, Matrix, methods, patchwork, pbapply, purrr, rlang
(&ge; 0.4.1), stats, tibble, tidygraph, tidyr, utils, viridis</td>
</tr>
<tr>
<td>Suggests:</td>
<td>anndata, covr, dynwrap (&ge; 1.2.0), R.rsp, rmarkdown, Seurat,
SingleCellExperiment (&ge; 1.5.3), SummarizedExperiment, testthat</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>R.rsp</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LazyData:</td>
<td>TRUE</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.1</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2022-10-12 14:29:59 UTC; rcannood</td>
</tr>
<tr>
<td>Author:</td>
<td>Robrecht Cannoodt <a href="https://orcid.org/0000-0003-3641-729X"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cre, cph],
  Wouter Saelens <a href="https://orcid.org/0000-0002-7114-6248"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Robrecht Cannoodt &lt;rcannood@gmail.com&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2022-10-12 15:22:39 UTC</td>
</tr>
</table>
<hr>
<h2 id='as_dyno'>Convert simulation output to different formats.</h2><span id='topic+as_dyno'></span><span id='topic+as_anndata'></span><span id='topic+as_sce'></span><span id='topic+as_seurat'></span><span id='topic+as_list'></span><span id='topic+wrap_dataset'></span>

<h3>Description</h3>

<p>For use with other packages compatible with dyno, anndata, SingleCellExperiment, or Seurat.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>as_dyno(
  model,
  store_dimred = !is.null(model$simulations$dimred),
  store_cellwise_grn = !is.null(model$experiment$cellwise_grn),
  store_rna_velocity = !is.null(model$experiment$rna_velocity)
)

as_anndata(
  model,
  store_dimred = !is.null(model$simulations$dimred),
  store_cellwise_grn = !is.null(model$experiment$cellwise_grn),
  store_rna_velocity = !is.null(model$experiment$rna_velocity)
)

as_sce(
  model,
  store_dimred = !is.null(model$simulations$dimred),
  store_cellwise_grn = !is.null(model$experiment$cellwise_grn),
  store_rna_velocity = !is.null(model$experiment$rna_velocity)
)

as_seurat(
  model,
  store_dimred = !is.null(model$simulations$dimred),
  store_cellwise_grn = !is.null(model$experiment$cellwise_grn),
  store_rna_velocity = !is.null(model$experiment$rna_velocity)
)

as_list(
  model,
  store_dimred = !is.null(model$simulations$dimred),
  store_cellwise_grn = !is.null(model$experiment$cellwise_grn),
  store_rna_velocity = !is.null(model$experiment$rna_velocity)
)

wrap_dataset(
  model,
  format = c("list", "dyno", "sce", "seurat", "anndata", "none"),
  store_dimred = !is.null(model$simulations$dimred),
  store_cellwise_grn = !is.null(model$experiment$cellwise_grn),
  store_rna_velocity = !is.null(model$experiment$rna_velocity)
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="as_dyno_+3A_model">model</code></td>
<td>
<p>A dyngen output model for which the experiment has been emulated with <code><a href="#topic+generate_experiment">generate_experiment()</a></code>.</p>
</td></tr>
<tr><td><code id="as_dyno_+3A_store_dimred">store_dimred</code></td>
<td>
<p>Whether or not to store the dimensionality reduction constructed on the true counts.</p>
</td></tr>
<tr><td><code id="as_dyno_+3A_store_cellwise_grn">store_cellwise_grn</code></td>
<td>
<p>Whether or not to also store cellwise GRN information.</p>
</td></tr>
<tr><td><code id="as_dyno_+3A_store_rna_velocity">store_rna_velocity</code></td>
<td>
<p>WHether or not to store the log propensity ratios.</p>
</td></tr>
<tr><td><code id="as_dyno_+3A_format">format</code></td>
<td>
<p>Which output format to use, must be one of 'dyno' (requires <code>dynwrap</code>), 'sce' (requires <code>SingleCellExperiment</code>), 'seurat' (requires <code>Seurat</code>), 'anndata' (requires <code>anndata</code>), 'list' or 'none'.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A dataset object.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("example_model")
dataset &lt;- wrap_dataset(example_model, format = "list")

dataset &lt;- wrap_dataset(example_model, format = "dyno")
dataset &lt;- wrap_dataset(example_model, format = "sce")
dataset &lt;- wrap_dataset(example_model, format = "seurat")
dataset &lt;- wrap_dataset(example_model, format = "anndata")
dataset &lt;- wrap_dataset(example_model, format = "none")

</code></pre>

<hr>
<h2 id='backbone'>Backbone of the simulation model</h2><span id='topic+backbone'></span>

<h3>Description</h3>

<p>A module is a group of genes which, to some extent, shows the same
expression behaviour. Several modules are connected together such that
one or more genes from one module will regulate the expression of
another module. By creating chains of modules, a dynamic behaviour in gene
regulation can be created.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>backbone(module_info, module_network, expression_patterns)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="backbone_+3A_module_info">module_info</code></td>
<td>
<p>A tibble containing meta information on the modules themselves.
</p>

<ul>
<li><p> module_id (character): the name of the module
</p>
</li>
<li><p> basal (numeric): basal expression level of genes in this module, must be between [0, 1]
</p>
</li>
<li><p> burn (logical): whether or not outgoing edges of this module will
be active during the burn in phase
</p>
</li>
<li><p> independence (numeric): the independence factor between regulators of this module, must be between [0, 1]
</p>
</li></ul>
</td></tr>
<tr><td><code id="backbone_+3A_module_network">module_network</code></td>
<td>
<p>A tibble describing which modules regulate which other modules.
</p>

<ul>
<li><p> from (character): the regulating module
</p>
</li>
<li><p> to (character): the target module
</p>
</li>
<li><p> effect (integer): <code>1L</code> if the regulating module upregulates
the target module, <code>-1L</code> if it downregulates
</p>
</li>
<li><p> strength (numeric): the strength of the interaction
</p>
</li>
<li><p> hill (numeric): hill coefficient, larger than 1 for positive cooperativity,
between 0 and 1 for negative cooperativity
</p>
</li></ul>
</td></tr>
<tr><td><code id="backbone_+3A_expression_patterns">expression_patterns</code></td>
<td>
<p>A tibble describing the expected expression pattern
changes when a cell is simulated by dyngen. Each row represents one transition between
two cell states.
</p>

<ul>
<li><p> from (character): name of a cell state
</p>
</li>
<li><p> to (character): name of a cell state
</p>
</li>
<li><p> module_progression (character): differences in module expression between the two states.
Example: <code>"+4,-1|+9|-4"</code> means the expression of module 4 will go up at the same time as module 1 goes down;
afterwards module 9 expression will go up, and afterwards module 4 expression will go down again.
</p>
</li>
<li><p> start (logical): Whether or not this from cell state is the start of the trajectory
</p>
</li>
<li><p> burn (logical): Whether these cell states are part of the burn in phase. Cells will
not get sampled from these cell states.
</p>
</li>
<li><p> time (numeric): The duration of an transition.
</p>
</li></ul>
</td></tr>
</table>


<h3>Value</h3>

<p>A dyngen backbone.
</p>


<h3>See Also</h3>

<p><a href="#topic+dyngen">dyngen</a> on how to run a dyngen simulation
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(tibble)
backbone &lt;- backbone(
  module_info = tribble(
    ~module_id, ~basal, ~burn, ~independence,
    "M1",       1,      TRUE,  1,
    "M2",       0,      FALSE, 1,
    "M3",       0,      FALSE, 1
  ),
  module_network = tribble(
    ~from, ~to,  ~effect, ~strength, ~hill,
    "M1",  "M2", 1L,      1,         2,
    "M2",  "M3", 1L,      1,         2
  ), 
  expression_patterns = tribble(
    ~from, ~to,  ~module_progression, ~start, ~burn, ~time,
    "s0",  "s1", "+M1",               TRUE,   TRUE,  30,
    "s1",  "s2", "+M2,+M3",           FALSE,  FALSE, 80
  )
)
</code></pre>

<hr>
<h2 id='bblego'>Design your own custom backbone easily</h2><span id='topic+bblego'></span><span id='topic+bblego_linear'></span><span id='topic+bblego_branching'></span><span id='topic+bblego_start'></span><span id='topic+bblego_end'></span>

<h3>Description</h3>

<p>You can use the <code>bblego</code> functions in order to create
custom backbones using various components. Please note that the <code>bblego</code>
functions currently only allow you to create tree-like backbones.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bblego(..., .list = NULL)

bblego_linear(
  from,
  to,
  type = sample(c("simple", "doublerep1", "doublerep2"), 1),
  num_modules = sample(4:6, 1),
  burn = FALSE
)

bblego_branching(
  from,
  to,
  type = "simple",
  num_steps = 3,
  num_modules = 2 + length(to) * (3 + num_steps),
  burn = FALSE
)

bblego_start(
  to,
  type = sample(c("simple", "doublerep1", "doublerep2"), 1),
  num_modules = sample(4:6, 1)
)

bblego_end(
  from,
  type = sample(c("simple", "doublerep1", "doublerep2"), 1),
  num_modules = sample(4:6, 1)
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bblego_+3A_...">...</code>, <code id="bblego_+3A_.list">.list</code></td>
<td>
<p><code>bblego</code> components, either as separate args or as a list.</p>
</td></tr>
<tr><td><code id="bblego_+3A_from">from</code></td>
<td>
<p>The begin state of this component.</p>
</td></tr>
<tr><td><code id="bblego_+3A_to">to</code></td>
<td>
<p>The end state of this component.</p>
</td></tr>
<tr><td><code id="bblego_+3A_type">type</code></td>
<td>
<p>Some components have alternative module regulatory networks.
</p>
<p><code>bblego_start()</code>, <code>bblego_linear()</code>, <code>bblego_end()</code>:
</p>

<ul>
<li> <p><code>"simple"</code>: a sequence of modules in which every module upregulates the next module.
</p>
</li>
<li> <p><code>"doublerep1"</code>: a sequence of modules in which every module downregulates the next
module, and each module has positive basal expression.
</p>
</li>
<li> <p><code>"doublerep2"</code>: a sequence of modules in which every module upregulates the next
module, but downregulates the one after that.
</p>
</li>
<li> <p><code>"flipflop"</code>: a sequence of modules in which every module upregulates the next module.
In addition, the last module upregulates itself and strongly downregulates the first module.
</p>
</li></ul>

<p><code>bblego_branching()</code>:
</p>

<ul>
<li> <p><code>"simple"</code>: a set of <code>n</code> modules (with <code>n = length(to)</code>) which all downregulate
one another and upregulate themselves. This causes a branching to occur in the trajectory.
</p>
</li></ul>
</td></tr>
<tr><td><code id="bblego_+3A_num_modules">num_modules</code></td>
<td>
<p>The number of modules this component is allowed to use.
Various components might require a minimum number of components in order to work properly.</p>
</td></tr>
<tr><td><code id="bblego_+3A_burn">burn</code></td>
<td>
<p>Whether or not these components are part of the warm-up simulation.</p>
</td></tr>
<tr><td><code id="bblego_+3A_num_steps">num_steps</code></td>
<td>
<p>The number of branching steps to reduce the odds of double positive cells occurring.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A backbone always needs to start with a single <code>bblego_start()</code> state and
needs to end with one or more <code>bblego_end()</code> states.
The order of the mentioned states needs to be such that a state is never
specified in the first argument (except for <code>bblego_start()</code>) before
having been specified as the second argument.
</p>


<h3>Value</h3>

<p>A dyngen backbone.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>backbone &lt;- bblego(
  bblego_start("A", type = "simple", num_modules = 2),
  bblego_linear("A", "B", type = "simple", num_modules = 3),
  bblego_branching("B", c("C", "D"), type = "simple", num_steps = 3),
  bblego_end("C", type = "flipflop", num_modules = 4),
  bblego_end("D", type = "doublerep1", num_modules = 7)
)
</code></pre>

<hr>
<h2 id='combine_models'>Combine multiple dyngen models</h2><span id='topic+combine_models'></span>

<h3>Description</h3>

<p>Assume the given models have the exact same feature ids and ran up until the <code>generate_cells()</code> step.
In addition, the user is expected to run <code>generate_experiment()</code> on the combined models.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>combine_models(models, duplicate_gold_standard = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="combine_models_+3A_models">models</code></td>
<td>
<p>A named list of models. The names of the list will be used to
prefix the different cellular states in the combined model.</p>
</td></tr>
<tr><td><code id="combine_models_+3A_duplicate_gold_standard">duplicate_gold_standard</code></td>
<td>
<p>Whether or not the gold standards of the models are
different and should be duplicated and prefixed.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>See the <a href="https://dyngen.dynverse.org/articles/advanced_topics/simulating_knockouts.html">vignette on simulating batch effects</a> on how to use this function.
</p>


<h3>Value</h3>

<p>A combined dyngen model.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data("example_model")
model_ab &lt;- combine_models(list("left" = example_model, "right" = example_model))

# show a dimensionality reduction
plot_simulations(model_ab)
plot_gold_mappings(model_ab, do_facet = FALSE)

</code></pre>

<hr>
<h2 id='dyngen'>dyngen: A multi-modal simulator for spearheading single-cell omics analyses</h2><span id='topic+dyngen'></span>

<h3>Description</h3>

<p>A toolkit for generating synthetic single cell data.
</p>


<h3>Step 1, initialise dyngen model</h3>


<ul>
<li> <p><code><a href="#topic+initialise_model">initialise_model()</a></code>: Define and store settings for all following steps. See each of the sections below for more information.
</p>
</li>
<li><p> Use a predefined backbone:
</p>

<ul>
<li> <p><code><a href="#topic+list_backbones">list_backbones()</a></code>
</p>
</li>
<li> <p><code><a href="#topic+backbone_bifurcating">backbone_bifurcating()</a></code>
</p>
</li>
<li> <p><code><a href="#topic+backbone_bifurcating_converging">backbone_bifurcating_converging()</a></code>
</p>
</li>
<li> <p><code><a href="#topic+backbone_bifurcating_cycle">backbone_bifurcating_cycle()</a></code>
</p>
</li>
<li> <p><code><a href="#topic+backbone_bifurcating_loop">backbone_bifurcating_loop()</a></code>
</p>
</li>
<li> <p><code><a href="#topic+backbone_branching">backbone_branching()</a></code>
</p>
</li>
<li> <p><code><a href="#topic+backbone_binary_tree">backbone_binary_tree()</a></code>
</p>
</li>
<li> <p><code><a href="#topic+backbone_consecutive_bifurcating">backbone_consecutive_bifurcating()</a></code>
</p>
</li>
<li> <p><code><a href="#topic+backbone_trifurcating">backbone_trifurcating()</a></code>
</p>
</li>
<li> <p><code><a href="#topic+backbone_converging">backbone_converging()</a></code>
</p>
</li>
<li> <p><code><a href="#topic+backbone_cycle">backbone_cycle()</a></code>
</p>
</li>
<li> <p><code><a href="#topic+backbone_cycle_simple">backbone_cycle_simple()</a></code>
</p>
</li>
<li> <p><code><a href="#topic+backbone_linear">backbone_linear()</a></code>
</p>
</li>
<li> <p><code><a href="#topic+backbone_linear_simple">backbone_linear_simple()</a></code>
</p>
</li>
<li> <p><code><a href="#topic+backbone_disconnected">backbone_disconnected()</a></code>
</p>
</li></ul>

</li>
<li><p> Create a custom backbone:
</p>

<ul>
<li> <p><code><a href="#topic+backbone">backbone()</a></code>
</p>
</li>
<li> <p><code><a href="#topic+bblego">bblego()</a></code>
</p>
</li>
<li> <p><code><a href="#topic+bblego_linear">bblego_linear()</a></code>
</p>
</li>
<li> <p><code><a href="#topic+bblego_branching">bblego_branching()</a></code>
</p>
</li>
<li> <p><code><a href="#topic+bblego_start">bblego_start()</a></code>
</p>
</li>
<li> <p><code><a href="#topic+bblego_end">bblego_end()</a></code>
</p>
</li></ul>

</li>
<li><p> Visualise the backbone:
</p>

<ul>
<li> <p><code><a href="#topic+plot_backbone_modulenet">plot_backbone_modulenet()</a></code>
</p>
</li>
<li> <p><code><a href="#topic+plot_backbone_statenet">plot_backbone_statenet()</a></code>
</p>
</li></ul>

</li></ul>



<h3>Step 2, generate TF network</h3>


<ul>
<li> <p><code><a href="#topic+generate_tf_network">generate_tf_network()</a></code>: Generate a transcription factor network from the backbone
</p>
</li>
<li> <p><code><a href="#topic+tf_network_default">tf_network_default()</a></code>: Parameters for configuring this step
</p>
</li></ul>



<h3>Step 3, add more genes to the gene network</h3>


<ul>
<li> <p><code><a href="#topic+generate_feature_network">generate_feature_network()</a></code>: Generate a target network
</p>
</li>
<li> <p><code><a href="#topic+feature_network_default">feature_network_default()</a></code>: Parameters for configuring this step
</p>
</li>
<li> <p><code><a href="#topic+plot_feature_network">plot_feature_network()</a></code>: Visualise the gene network
</p>
</li></ul>



<h3>Step 4, generate gene kinetics</h3>


<ul>
<li> <p><code><a href="#topic+generate_kinetics">generate_kinetics()</a></code>: Generate the gene kinetics
</p>
</li>
<li> <p><code><a href="#topic+kinetics_default">kinetics_default()</a></code>, <code><a href="#topic+kinetics_random_distributions">kinetics_random_distributions()</a></code>: Parameters for configuring this step
</p>
</li></ul>



<h3>Step 5, simulate the gold standard</h3>


<ul>
<li> <p><code><a href="#topic+generate_gold_standard">generate_gold_standard()</a></code>: Simulate the gold standard backbone, used for mapping to cell states afterwards
</p>
</li>
<li> <p><code><a href="#topic+gold_standard_default">gold_standard_default()</a></code>: Parameters for configuring this step
</p>
</li>
<li> <p><code><a href="#topic+plot_gold_mappings">plot_gold_mappings()</a></code>: Visualise the mapping of the simulations to the gold standard
</p>
</li>
<li> <p><code><a href="#topic+plot_gold_simulations">plot_gold_simulations()</a></code>: Visualise the gold standard simulations using the dimred
</p>
</li>
<li> <p><code><a href="#topic+plot_gold_expression">plot_gold_expression()</a></code>: Visualise the expression of the gold standard over simulation time
</p>
</li></ul>



<h3>Step 6, simulate the cells</h3>


<ul>
<li> <p><code><a href="#topic+generate_cells">generate_cells()</a></code>: Simulate the cells based on its GRN
</p>
</li>
<li> <p><code><a href="#topic+simulation_default">simulation_default()</a></code>: Parameters for configuring this step
</p>
</li>
<li> <p><code><a href="#topic+simulation_type_wild_type">simulation_type_wild_type()</a></code>, <code><a href="#topic+simulation_type_knockdown">simulation_type_knockdown()</a></code>: Used for configuring the type of simulation
</p>
</li>
<li> <p><code><a href="#topic+kinetics_noise_none">kinetics_noise_none()</a></code>, <code><a href="#topic+kinetics_noise_simple">kinetics_noise_simple()</a></code>: Different kinetics randomisers to apply to each simulation
</p>
</li>
<li> <p><code><a href="#topic+plot_simulations">plot_simulations()</a></code>: Visualise the simulations using the dimred
</p>
</li>
<li> <p><code><a href="#topic+plot_simulation_expression">plot_simulation_expression()</a></code>: Visualise the expression of the simulations over simulation time
</p>
</li></ul>



<h3>Step 7, simulate cell and transcripting sampling</h3>


<ul>
<li> <p><code><a href="#topic+generate_experiment">generate_experiment()</a></code>: Sample cells and transcripts from experiment
</p>
</li>
<li> <p><code><a href="#topic+list_experiment_samplers">list_experiment_samplers()</a></code>, <code><a href="#topic+experiment_snapshot">experiment_snapshot()</a></code>, <code><a href="#topic+experiment_synchronised">experiment_synchronised()</a></code>: Parameters for configuring this step
</p>
</li>
<li> <p><code><a href="#topic+simtime_from_backbone">simtime_from_backbone()</a></code>: Determine the simulation time from the backbone
</p>
</li>
<li> <p><code><a href="#topic+plot_experiment_dimred">plot_experiment_dimred()</a></code>: Plot a dimensionality reduction of the final dataset
</p>
</li></ul>



<h3>Step 8, convert to dataset</h3>


<ul>
<li> <p><code><a href="#topic+as_dyno">as_dyno()</a></code>, <code><a href="#topic+wrap_dataset">wrap_dataset()</a></code>: Convert a dyngen model to a dyno dataset
</p>
</li>
<li> <p><code><a href="#topic+as_anndata">as_anndata()</a></code>: Convert a dyngen model to an anndata dataset
</p>
</li>
<li> <p><code><a href="#topic+as_sce">as_sce()</a></code>: Convert a dyngen model to a SingleCellExperiment dataset
</p>
</li>
<li> <p><code><a href="#topic+as_seurat">as_seurat()</a></code>: Convert a dyngen model to a Seurat dataset
</p>
</li></ul>



<h3>One-shot function</h3>


<ul>
<li> <p><code><a href="#topic+generate_dataset">generate_dataset()</a></code>: Run through steps 2 to 8 with a single function
</p>
</li>
<li> <p><code><a href="#topic+plot_summary">plot_summary()</a></code>: Plot a summary of all dyngen simulation steps
</p>
</li></ul>



<h3>Data objects</h3>


<ul>
<li> <p><a href="#topic+example_model">example_model</a>: A (very) small toy dyngen model, used for documentation and testing purposes
</p>
</li>
<li> <p><a href="#topic+realcounts">realcounts</a>: A set of real single-cell expression datasets, to be used as reference datasets
</p>
</li>
<li> <p><a href="#topic+realnets">realnets</a>: A set of real gene regulatory networks, to be sampled in step 3
</p>
</li></ul>



<h3>Varia functions</h3>


<ul>
<li> <p><a href="#topic+dyngen">dyngen</a>: This help page
</p>
</li>
<li> <p><code><a href="#topic+get_timings">get_timings()</a></code>: Extract execution timings for each of the dyngen steps
</p>
</li>
<li> <p><code><a href="#topic+combine_models">combine_models()</a></code>: Combine multiple dyngen models
</p>
</li>
<li> <p><code><a href="#topic+rnorm_bounded">rnorm_bounded()</a></code>: A bounded version of <code><a href="stats.html#topic+rnorm">rnorm()</a></code>
</p>
</li>
<li> <p><code><a href="#topic+runif_subrange">runif_subrange()</a></code>: A subrange version of <code><a href="stats.html#topic+runif">runif()</a></code>
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>model &lt;- initialise_model(
  backbone = backbone_bifurcating()
)


model &lt;- model %&gt;%
  generate_tf_network() %&gt;%
  generate_feature_network() %&gt;%
  generate_kinetics() %&gt;%
  generate_gold_standard() %&gt;%
  generate_cells() %&gt;%
  generate_experiment()
  
dataset &lt;- wrap_dataset(model, format = "dyno")
# format can also be set to "sce", "seurat", "anndata" or "list"

# library(dynplot)
# plot_dimred(dataset)


</code></pre>

<hr>
<h2 id='example_model'>A (very!) small toy dyngen model</h2><span id='topic+example_model'></span>

<h3>Description</h3>

<p>Used for showcasing examples of functions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>example_model
</code></pre>


<h3>Format</h3>

<p>An object of class <code>list</code> (inherits from <code>dyngen::init</code>) of length 19.
</p>

<hr>
<h2 id='generate_cells'>Simulate the cells</h2><span id='topic+generate_cells'></span><span id='topic+simulation_default'></span><span id='topic+simulation_type_wild_type'></span><span id='topic+simulation_type_knockdown'></span>

<h3>Description</h3>

<p><code><a href="#topic+generate_cells">generate_cells()</a></code> runs simulations in order to determine the gold standard
of the simulations.
<code><a href="#topic+simulation_default">simulation_default()</a></code> is used to configure parameters pertaining this process.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>generate_cells(model)

simulation_default(
  burn_time = NULL,
  total_time = NULL,
  ssa_algorithm = ssa_etl(tau = 30/3600),
  census_interval = 4,
  experiment_params = bind_rows(simulation_type_wild_type(num_simulations = 32),
    simulation_type_knockdown(num_simulations = 0)),
  store_reaction_firings = FALSE,
  store_reaction_propensities = FALSE,
  compute_cellwise_grn = FALSE,
  compute_dimred = TRUE,
  compute_rna_velocity = FALSE,
  kinetics_noise_function = kinetics_noise_simple(mean = 1, sd = 0.005)
)

simulation_type_wild_type(
  num_simulations,
  seed = sample.int(10 * num_simulations, num_simulations)
)

simulation_type_knockdown(
  num_simulations,
  timepoint = runif(num_simulations),
  genes = "*",
  num_genes = sample(1:5, num_simulations, replace = TRUE, prob = 0.25^(1:5)),
  multiplier = runif(num_simulations, 0, 1),
  seed = sample.int(10 * num_simulations, num_simulations)
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="generate_cells_+3A_model">model</code></td>
<td>
<p>A dyngen intermediary model for which the gold standard been generated with <code><a href="#topic+generate_gold_standard">generate_gold_standard()</a></code>.</p>
</td></tr>
<tr><td><code id="generate_cells_+3A_burn_time">burn_time</code></td>
<td>
<p>The burn in time of the system, used to determine an initial state vector. If <code>NULL</code>, the burn time will be inferred from the backbone.</p>
</td></tr>
<tr><td><code id="generate_cells_+3A_total_time">total_time</code></td>
<td>
<p>The total simulation time of the system. If <code>NULL</code>, the simulation time will be inferred from the backbone.</p>
</td></tr>
<tr><td><code id="generate_cells_+3A_ssa_algorithm">ssa_algorithm</code></td>
<td>
<p>Which SSA algorithm to use for simulating the cells with <code><a href="GillespieSSA2.html#topic+ssa">GillespieSSA2::ssa()</a></code></p>
</td></tr>
<tr><td><code id="generate_cells_+3A_census_interval">census_interval</code></td>
<td>
<p>A granularity parameter for the outputted simulation.</p>
</td></tr>
<tr><td><code id="generate_cells_+3A_experiment_params">experiment_params</code></td>
<td>
<p>A tibble generated by rbinding multiple calls of <code><a href="#topic+simulation_type_wild_type">simulation_type_wild_type()</a></code> and <code><a href="#topic+simulation_type_knockdown">simulation_type_knockdown()</a></code>.</p>
</td></tr>
<tr><td><code id="generate_cells_+3A_store_reaction_firings">store_reaction_firings</code></td>
<td>
<p>Whether or not to store the number of reaction firings.</p>
</td></tr>
<tr><td><code id="generate_cells_+3A_store_reaction_propensities">store_reaction_propensities</code></td>
<td>
<p>Whether or not to store the propensity values of the reactions.</p>
</td></tr>
<tr><td><code id="generate_cells_+3A_compute_cellwise_grn">compute_cellwise_grn</code></td>
<td>
<p>Whether or not to compute the cellwise GRN activation values.</p>
</td></tr>
<tr><td><code id="generate_cells_+3A_compute_dimred">compute_dimred</code></td>
<td>
<p>Whether to perform a dimensionality reduction after simulation.</p>
</td></tr>
<tr><td><code id="generate_cells_+3A_compute_rna_velocity">compute_rna_velocity</code></td>
<td>
<p>Whether or not to compute the propensity ratios after simulation.</p>
</td></tr>
<tr><td><code id="generate_cells_+3A_kinetics_noise_function">kinetics_noise_function</code></td>
<td>
<p>A function that will generate noise to the kinetics of each simulation.
It takes the <code>feature_info</code> and <code>feature_network</code> as input parameters,
modifies them, and returns them as a list. See <code><a href="#topic+kinetics_noise_none">kinetics_noise_none()</a></code> and <code><a href="#topic+kinetics_noise_simple">kinetics_noise_simple()</a></code>.</p>
</td></tr>
<tr><td><code id="generate_cells_+3A_num_simulations">num_simulations</code></td>
<td>
<p>The number of simulations to run.</p>
</td></tr>
<tr><td><code id="generate_cells_+3A_seed">seed</code></td>
<td>
<p>A set of seeds for each of the simulations.</p>
</td></tr>
<tr><td><code id="generate_cells_+3A_timepoint">timepoint</code></td>
<td>
<p>The relative time point of the knockdown</p>
</td></tr>
<tr><td><code id="generate_cells_+3A_genes">genes</code></td>
<td>
<p>Which genes to sample from. <code>"*"</code> for all genes.</p>
</td></tr>
<tr><td><code id="generate_cells_+3A_num_genes">num_genes</code></td>
<td>
<p>The number of genes to knockdown.</p>
</td></tr>
<tr><td><code id="generate_cells_+3A_multiplier">multiplier</code></td>
<td>
<p>The strength of the knockdown. Use 0 for a full knockout, 0&lt;x&lt;1 for a knockdown, and &gt;1 for an overexpression.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A dyngen model.
</p>


<h3>See Also</h3>

<p><a href="#topic+dyngen">dyngen</a> on how to run a complete dyngen simulation
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(dplyr)
model &lt;- 
  initialise_model(
    backbone = backbone_bifurcating(),
    simulation = simulation_default(
      ssa_algorithm = ssa_etl(tau = .1),
      experiment_params = bind_rows(
        simulation_type_wild_type(num_simulations = 4),
        simulation_type_knockdown(num_simulations = 4)
      )
    )
  )

data("example_model")
model &lt;- example_model %&gt;% generate_cells()
  
plot_simulations(model)
plot_gold_mappings(model)
plot_simulation_expression(model)

</code></pre>

<hr>
<h2 id='generate_dataset'>Generate a dataset</h2><span id='topic+generate_dataset'></span>

<h3>Description</h3>

<p>This function contains the complete pipeline for generating a dataset
with <span class="pkg">dyngen</span>. In order to have more control over how the dataset
is generated, run each of the steps in this function separately.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>generate_dataset(
  model,
  format = c("list", "dyno", "sce", "seurat", "anndata", "none"),
  output_dir = NULL,
  make_plots = FALSE,
  store_dimred = model$simulation_params$compute_dimred,
  store_cellwise_grn = model$simulation_params$compute_cellwise_grn,
  store_rna_velocity = model$simulation_params$compute_rna_velocity
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="generate_dataset_+3A_model">model</code></td>
<td>
<p>A dyngen initial model created with <code><a href="#topic+initialise_model">initialise_model()</a></code>.</p>
</td></tr>
<tr><td><code id="generate_dataset_+3A_format">format</code></td>
<td>
<p>Which output format to use, must be one of 'dyno' (requires <code>dynwrap</code>), 'sce' (requires <code>SingleCellExperiment</code>), 'seurat' (requires <code>Seurat</code>), 'anndata' (requires <code>anndata</code>), 'list' or 'none'.</p>
</td></tr>
<tr><td><code id="generate_dataset_+3A_output_dir">output_dir</code></td>
<td>
<p>If not <code>NULL</code>, then the generated model and dynwrap
dataset will be written to files in this directory.</p>
</td></tr>
<tr><td><code id="generate_dataset_+3A_make_plots">make_plots</code></td>
<td>
<p>Whether or not to generate an overview of the dataset.</p>
</td></tr>
<tr><td><code id="generate_dataset_+3A_store_dimred">store_dimred</code></td>
<td>
<p>Whether or not to store the dimensionality reduction constructed on the true counts.</p>
</td></tr>
<tr><td><code id="generate_dataset_+3A_store_cellwise_grn">store_cellwise_grn</code></td>
<td>
<p>Whether or not to also store cellwise GRN information.</p>
</td></tr>
<tr><td><code id="generate_dataset_+3A_store_rna_velocity">store_rna_velocity</code></td>
<td>
<p>WHether or not to store the log propensity ratios.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list containing a dyngen model (<code>li$model</code>) and a dynwrap dataset (<code>li$dataset</code>).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>model &lt;- 
  initialise_model(
    backbone = backbone_bifurcating()
  )


# generate dataset and output as a list format
# please note other output formats exist: "dyno", "sce", "seurat", "anndata"
out &lt;- generate_dataset(model, format = "list")

model &lt;- out$model
dataset &lt;- out$dataset

</code></pre>

<hr>
<h2 id='generate_experiment'>Sample cells from the simulations</h2><span id='topic+generate_experiment'></span><span id='topic+list_experiment_samplers'></span><span id='topic+experiment_snapshot'></span><span id='topic+experiment_synchronised'></span>

<h3>Description</h3>

<p><code><a href="#topic+generate_experiment">generate_experiment()</a></code> samples cells along the different simulations.
Two approaches are implemented: sampling from an unsynchronised population of single cells (snapshot) or
sampling at multiple time points in a synchronised population (time series).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>generate_experiment(model)

list_experiment_samplers()

experiment_snapshot(
  realcount = NULL,
  map_reference_cpm = TRUE,
  map_reference_ls = TRUE,
  weight_bw = 0.1
)

experiment_synchronised(
  realcount = NULL,
  map_reference_cpm = TRUE,
  map_reference_ls = TRUE,
  num_timepoints = 8,
  pct_between = 0.75
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="generate_experiment_+3A_model">model</code></td>
<td>
<p>A dyngen intermediary model for which the simulations have been run with <code><a href="#topic+generate_cells">generate_cells()</a></code>.</p>
</td></tr>
<tr><td><code id="generate_experiment_+3A_realcount">realcount</code></td>
<td>
<p>The name of a dataset in <a href="#topic+realcounts">realcounts</a>. If <code>NULL</code>, a random
dataset will be sampled from <a href="#topic+realcounts">realcounts</a>.</p>
</td></tr>
<tr><td><code id="generate_experiment_+3A_map_reference_cpm">map_reference_cpm</code></td>
<td>
<p>Whether or not to try to match the CPM distribution to that of a reference dataset.</p>
</td></tr>
<tr><td><code id="generate_experiment_+3A_map_reference_ls">map_reference_ls</code></td>
<td>
<p>Whether or not to try to match the distribution of the library sizes to that of the reference dataset.</p>
</td></tr>
<tr><td><code id="generate_experiment_+3A_weight_bw">weight_bw</code></td>
<td>
<p>[snapshot] A bandwidth parameter for determining the distribution of
cells along each edge in order to perform weighted sampling.</p>
</td></tr>
<tr><td><code id="generate_experiment_+3A_num_timepoints">num_timepoints</code></td>
<td>
<p>[synchronised] The number of time points used in the experiment.</p>
</td></tr>
<tr><td><code id="generate_experiment_+3A_pct_between">pct_between</code></td>
<td>
<p>[synchronised] The percentage of 'unused' simulation time.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code><a href="#topic+experiment_snapshot">experiment_snapshot()</a></code> samples the cells using the length of each edge in the milestone network as weights.
See Supplementary Figure 7A from the dyngen paper for an illustration of how these weights are computed.
</p>
<p><code><a href="#topic+experiment_synchronised">experiment_synchronised()</a></code> samples the cells along the simulation timeline by binning it into <code>num_timepoints</code>
groups separated by <code>num_timepoints-1</code> gaps.
See Supplementary Figure 7B from the dyngen paper for an illustration of how the timepoint groups are computed.
</p>


<h3>Value</h3>

<p>A dyngen model.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>names(list_experiment_samplers())

model &lt;- 
  initialise_model(
    backbone = backbone_bifurcating(),
    experiment = experiment_synchronised()
  )


data("example_model")
model &lt;- example_model %&gt;% generate_experiment() 

plot_experiment_dimred(model)

</code></pre>

<hr>
<h2 id='generate_feature_network'>Generate a target network</h2><span id='topic+generate_feature_network'></span><span id='topic+feature_network_default'></span>

<h3>Description</h3>

<p><code><a href="#topic+generate_feature_network">generate_feature_network()</a></code> generates a network of target genes that are regulated
by the previously generated TFs, and also a separate network of housekeeping genes (HKs).
<code><a href="#topic+feature_network_default">feature_network_default()</a></code> is used to configure parameters pertaining this process.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>generate_feature_network(model)

feature_network_default(
  realnet = NULL,
  damping = 0.01,
  target_resampling = Inf,
  max_in_degree = 5
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="generate_feature_network_+3A_model">model</code></td>
<td>
<p>A dyngen intermediary model for which the transcription network has been generated with <code><a href="#topic+generate_tf_network">generate_tf_network()</a></code>.</p>
</td></tr>
<tr><td><code id="generate_feature_network_+3A_realnet">realnet</code></td>
<td>
<p>The name of a gene regulatory network (GRN) in <a href="#topic+realnets">realnets</a>.
If <code>NULL</code>, a random network will be sampled from <a href="#topic+realnets">realnets</a>.
Alternatively, a custom GRN can be used by passing a weighted sparse matrix.</p>
</td></tr>
<tr><td><code id="generate_feature_network_+3A_damping">damping</code></td>
<td>
<p>A damping factor used for the page rank algorithm used to subsample the realnet.</p>
</td></tr>
<tr><td><code id="generate_feature_network_+3A_target_resampling">target_resampling</code></td>
<td>
<p>How many targets / HKs to sample from the realnet per iteration.</p>
</td></tr>
<tr><td><code id="generate_feature_network_+3A_max_in_degree">max_in_degree</code></td>
<td>
<p>The maximum in-degree of a target / HK.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A dyngen model.
</p>


<h3>See Also</h3>

<p><a href="#topic+dyngen">dyngen</a> on how to run a complete dyngen simulation
</p>


<h3>Examples</h3>

<pre><code class='language-R'>model &lt;- 
  initialise_model(
    backbone = backbone_bifurcating(),
    feature_network = feature_network_default(damping = 0.1)
  )
  

data("example_model")
model &lt;- example_model %&gt;%
  generate_tf_network() %&gt;% 
  generate_feature_network()

plot_feature_network(model)

</code></pre>

<hr>
<h2 id='generate_gold_standard'>Simulate the gold standard</h2><span id='topic+generate_gold_standard'></span><span id='topic+gold_standard_default'></span>

<h3>Description</h3>

<p><code><a href="#topic+generate_gold_standard">generate_gold_standard()</a></code> runs simulations in order to determine the gold standard
of the simulations.
<code><a href="#topic+gold_standard_default">gold_standard_default()</a></code> is used to configure parameters pertaining this process.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>generate_gold_standard(model)

gold_standard_default(
  tau = 30/3600,
  census_interval = 10/60,
  simulate_targets = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="generate_gold_standard_+3A_model">model</code></td>
<td>
<p>A dyngen intermediary model for which the kinetics of the feature network has been generated with <code><a href="#topic+generate_kinetics">generate_kinetics()</a></code>.</p>
</td></tr>
<tr><td><code id="generate_gold_standard_+3A_tau">tau</code></td>
<td>
<p>The time step of the ODE algorithm used to generate the gold standard.</p>
</td></tr>
<tr><td><code id="generate_gold_standard_+3A_census_interval">census_interval</code></td>
<td>
<p>A granularity parameter of the gold standard time steps. Should be larger than or equal to <code>tau</code>.</p>
</td></tr>
<tr><td><code id="generate_gold_standard_+3A_simulate_targets">simulate_targets</code></td>
<td>
<p>Also simulate the targets during the gold standard simulation</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A dyngen model.
</p>


<h3>See Also</h3>

<p><a href="#topic+dyngen">dyngen</a> on how to run a complete dyngen simulation
</p>


<h3>Examples</h3>

<pre><code class='language-R'>model &lt;- 
  initialise_model(
    backbone = backbone_bifurcating(),
    gold_standard = gold_standard_default(tau = .01, census_interval = 1)
  )


data("example_model")
model &lt;- example_model %&gt;% generate_gold_standard()
  
plot_gold_simulations(model)
plot_gold_mappings(model)
plot_gold_expression(model)

</code></pre>

<hr>
<h2 id='generate_kinetics'>Determine the kinetics of the feature network</h2><span id='topic+generate_kinetics'></span><span id='topic+kinetics_default'></span><span id='topic+kinetics_random_distributions'></span>

<h3>Description</h3>

<p><code><a href="#topic+generate_kinetics">generate_kinetics()</a></code> samples the kinetics of genes in the feature network for which
the kinetics have not yet been defined.
<code><a href="#topic+kinetics_default">kinetics_default()</a></code> is used to configure parameters pertaining this process.
<code><a href="#topic+kinetics_random_distributions">kinetics_random_distributions()</a></code> will do the same, but the distributions are also
randomised.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>generate_kinetics(model)

kinetics_default()

kinetics_random_distributions()
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="generate_kinetics_+3A_model">model</code></td>
<td>
<p>A dyngen intermediary model for which the feature network has been generated with <code><a href="#topic+generate_feature_network">generate_feature_network()</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>To write different kinetics settings, you need to write three functions
with interface <code style="white-space: pre;">&#8288;function(feature_info, feature_network, cache_dir, verbose)&#8288;</code>.
Described below are the default kinetics samplers.
</p>
<p><code>sampler_tfs()</code> mutates the <code>feature_info</code> data frame by adding the following columns:
</p>

<ul>
<li> <p><code>transcription_rate</code>: the rate at which pre-mRNAs are transcribed,
in pre-mRNA / hour. Default distribution: U(1, 2).
</p>
</li>
<li> <p><code>translation_rate</code>:  the rate at which mRNAs are translated into proteins,
in protein / mRNA / hour. Default distribution: U(100, 150).
</p>
</li>
<li> <p><code>mrna_halflife</code>: the half-life of (pre-)mRNA molecules, in hours.
Default distribution: U(2.5, 5).
</p>
</li>
<li> <p><code>protein_halflife</code>: the half-life of proteins, in hours.
Default distribution: U(5, 10).
</p>
</li>
<li> <p><code>splicing_rate</code>: the rate at which pre-mRNAs are spliced into mRNAs,
in reactions / hour. Default value: log(2) / (10/60), which corresponds to a half-life of 10 minutes.
</p>
</li>
<li> <p><code>independence</code>: the degree to which all regulators need to be bound for transcription to occur (0), or
whether transcription can occur if only one of the regulators is bound (1).
</p>
</li></ul>

<p><code>sampler_nontfs()</code> samples the <code>transcription_rate</code>, <code>translation_rate</code>,
<code>mrna_halflife</code> and <code>protein_halflife</code> from a supplementary file of Schwannhäusser et al.,
2011, doi.org/10.1038/nature10098. <code>splicing_rate</code> is by default the same as in <code>sampler_tfs()</code>.
<code>independence</code> is sampled from U(0, 1).
</p>
<p><code>sampler_interactions()</code> mutates the <code>feature_network</code> data frame by adding the following columns.
</p>

<ul>
<li> <p><code>effect</code>: the effect of the interaction; upregulating = +1, downregulating = -1.
By default, sampled from -1, 1 with probabilities .25, .75.
</p>
</li>
<li> <p><code>strength</code>: the strength of the interaction. Default distribution: 10^U(0, 2).
</p>
</li>
<li> <p><code>hill</code>: the hill coefficient. Default distribution: N(2, 2) with a minimum of 1 and a maximum of 10.
</p>
</li></ul>



<h3>Value</h3>

<p>A dyngen model.
</p>


<h3>See Also</h3>

<p><a href="#topic+dyngen">dyngen</a> on how to run a complete dyngen simulation
</p>


<h3>Examples</h3>

<pre><code class='language-R'>model &lt;- 
  initialise_model(
    backbone = backbone_bifurcating(),
    kinetics_params = kinetics_default()
  )


data("example_model")
model &lt;- example_model %&gt;%
  generate_kinetics()

</code></pre>

<hr>
<h2 id='generate_tf_network'>Generate a transcription factor network from the backbone</h2><span id='topic+generate_tf_network'></span><span id='topic+tf_network_default'></span>

<h3>Description</h3>

<p><code><a href="#topic+generate_tf_network">generate_tf_network()</a></code> generates the transcription factors (TFs) that
drive the dynamic process a cell undergoes.
<code><a href="#topic+tf_network_default">tf_network_default()</a></code> is used to configure parameters pertaining this process.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>generate_tf_network(model)

tf_network_default(
  min_tfs_per_module = 1L,
  sample_num_regulators = function() 2,
  weighted_sampling = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="generate_tf_network_+3A_model">model</code></td>
<td>
<p>A dyngen initial model created with <code><a href="#topic+initialise_model">initialise_model()</a></code>.</p>
</td></tr>
<tr><td><code id="generate_tf_network_+3A_min_tfs_per_module">min_tfs_per_module</code></td>
<td>
<p>The number of TFs to generate per module in the backbone.</p>
</td></tr>
<tr><td><code id="generate_tf_network_+3A_sample_num_regulators">sample_num_regulators</code></td>
<td>
<p>A function to generate the number of TFs per module each TF will be regulated by.</p>
</td></tr>
<tr><td><code id="generate_tf_network_+3A_weighted_sampling">weighted_sampling</code></td>
<td>
<p>When determining what TFs another TF is regulated by, whether to perform weighted
sampling (by rank) or not.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A dyngen model.
</p>


<h3>See Also</h3>

<p><a href="#topic+dyngen">dyngen</a> on how to run a complete dyngen simulation
</p>


<h3>Examples</h3>

<pre><code class='language-R'>model &lt;- 
  initialise_model(
    backbone = backbone_bifurcating()
  )
model &lt;- model %&gt;%
  generate_tf_network() 
  

plot_feature_network(model)

</code></pre>

<hr>
<h2 id='get_timings'>Return the timings of each of the dyngen steps</h2><span id='topic+get_timings'></span>

<h3>Description</h3>

<p>Return the timings of each of the dyngen steps
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_timings(model)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_timings_+3A_model">model</code></td>
<td>
<p>A dyngen object</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data frame with columns <code>"group"</code>, <code>"task"</code>, <code>"time_elapsed"</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("example_model")
timings &lt;- get_timings(example_model)
</code></pre>

<hr>
<h2 id='initialise_model'>Initial settings for simulating a dyngen dataset</h2><span id='topic+initialise_model'></span>

<h3>Description</h3>

<p>Initial settings for simulating a dyngen dataset
</p>


<h3>Usage</h3>

<pre><code class='language-R'>initialise_model(
  backbone,
  num_cells = 1000,
  num_tfs = nrow(backbone$module_info),
  num_targets = 100,
  num_hks = 50,
  distance_metric = c("pearson", "spearman", "cosine", "euclidean", "manhattan"),
  tf_network_params = tf_network_default(),
  feature_network_params = feature_network_default(),
  kinetics_params = kinetics_default(),
  gold_standard_params = gold_standard_default(),
  simulation_params = simulation_default(),
  experiment_params = experiment_snapshot(),
  verbose = TRUE,
  download_cache_dir = getOption("dyngen_download_cache_dir"),
  num_cores = getOption("Ncpus") %||% 1L,
  id = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="initialise_model_+3A_backbone">backbone</code></td>
<td>
<p>The gene module configuration that determines the type of dynamic
process being simulated. See <code><a href="#topic+list_backbones">list_backbones()</a></code> for a full list of different backbones
available in this package.</p>
</td></tr>
<tr><td><code id="initialise_model_+3A_num_cells">num_cells</code></td>
<td>
<p>The number of cells to sample.</p>
</td></tr>
<tr><td><code id="initialise_model_+3A_num_tfs">num_tfs</code></td>
<td>
<p>The number of transcription factors (TFs) to generate. TFs are the
main drivers of the changes that occur in a cell. TFs are regulated only by other
TFs.</p>
</td></tr>
<tr><td><code id="initialise_model_+3A_num_targets">num_targets</code></td>
<td>
<p>The number of target genes to generate. Target genes are
regulated by TFs and sometimes by other target genes.</p>
</td></tr>
<tr><td><code id="initialise_model_+3A_num_hks">num_hks</code></td>
<td>
<p>The number of housekeeping genes (HKs) to generate. HKs are
typically highly expressed, and are not regulated by the TFs or targets.</p>
</td></tr>
<tr><td><code id="initialise_model_+3A_distance_metric">distance_metric</code></td>
<td>
<p>The distance metric to be used to calculate the distance
between cells. See <code><a href="dynutils.html#topic+calculate_distance">dynutils::calculate_distance()</a></code> for a list of possible
distance metrics.</p>
</td></tr>
<tr><td><code id="initialise_model_+3A_tf_network_params">tf_network_params</code></td>
<td>
<p>Settings for generating the TF network with
<code><a href="#topic+generate_tf_network">generate_tf_network()</a></code>, see <code><a href="#topic+tf_network_default">tf_network_default()</a></code>.</p>
</td></tr>
<tr><td><code id="initialise_model_+3A_feature_network_params">feature_network_params</code></td>
<td>
<p>Settings for generating the feature network with
<code><a href="#topic+generate_feature_network">generate_feature_network()</a></code>, see <code><a href="#topic+feature_network_default">feature_network_default()</a></code>.</p>
</td></tr>
<tr><td><code id="initialise_model_+3A_kinetics_params">kinetics_params</code></td>
<td>
<p>Settings for determining the kinetics of the feature network
with <code><a href="#topic+generate_kinetics">generate_kinetics()</a></code>, see <code><a href="#topic+kinetics_default">kinetics_default()</a></code>.</p>
</td></tr>
<tr><td><code id="initialise_model_+3A_gold_standard_params">gold_standard_params</code></td>
<td>
<p>Settings pertaining simulating the gold standard with
<code><a href="#topic+generate_gold_standard">generate_gold_standard()</a></code>, see <code><a href="#topic+gold_standard_default">gold_standard_default()</a></code>.</p>
</td></tr>
<tr><td><code id="initialise_model_+3A_simulation_params">simulation_params</code></td>
<td>
<p>Settings pertaining the simulation itself with <code><a href="#topic+generate_cells">generate_cells()</a></code>,
see <code><a href="#topic+simulation_default">simulation_default()</a></code>.</p>
</td></tr>
<tr><td><code id="initialise_model_+3A_experiment_params">experiment_params</code></td>
<td>
<p>Settings related to how the experiment is simulated with
<code><a href="#topic+generate_experiment">generate_experiment()</a></code>, see <code><a href="#topic+experiment_snapshot">experiment_snapshot()</a></code> or <code><a href="#topic+experiment_synchronised">experiment_synchronised()</a></code>.</p>
</td></tr>
<tr><td><code id="initialise_model_+3A_verbose">verbose</code></td>
<td>
<p>Whether or not to print messages during the simulation.</p>
</td></tr>
<tr><td><code id="initialise_model_+3A_download_cache_dir">download_cache_dir</code></td>
<td>
<p>If not <code>NULL</code>, temporary downloaded files will be
cached in this directory.</p>
</td></tr>
<tr><td><code id="initialise_model_+3A_num_cores">num_cores</code></td>
<td>
<p>Parallellisation parameter for various steps in the pipeline.</p>
</td></tr>
<tr><td><code id="initialise_model_+3A_id">id</code></td>
<td>
<p>An identifier for the model.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A dyngen model.
</p>


<h3>See Also</h3>

<p><a href="#topic+dyngen">dyngen</a> on how to run a complete dyngen simulation
</p>


<h3>Examples</h3>

<pre><code class='language-R'>model &lt;- initialise_model(
  backbone = backbone_bifurcating(),
  num_cells = 555,
  verbose = FALSE,
  download_cache_dir = "~/.cache/dyngen"
)
</code></pre>

<hr>
<h2 id='kinetics_noise_none'>Add small noise to the kinetics of each simulation</h2><span id='topic+kinetics_noise_none'></span><span id='topic+kinetics_noise_simple'></span>

<h3>Description</h3>

<p>Add small noise to the kinetics of each simulation
</p>


<h3>Usage</h3>

<pre><code class='language-R'>kinetics_noise_none()

kinetics_noise_simple(mean = 1, sd = 0.005)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="kinetics_noise_none_+3A_mean">mean</code></td>
<td>
<p>The mean level of noise (should be 1)</p>
</td></tr>
<tr><td><code id="kinetics_noise_none_+3A_sd">sd</code></td>
<td>
<p>The sd of the noise (should be a relatively small value)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of noise generators for the kinetics.
</p>

<hr>
<h2 id='list_backbones'>List of all predefined backbone models</h2><span id='topic+list_backbones'></span><span id='topic+backbone_bifurcating'></span><span id='topic+backbone_bifurcating_converging'></span><span id='topic+backbone_bifurcating_cycle'></span><span id='topic+backbone_bifurcating_loop'></span><span id='topic+backbone_branching'></span><span id='topic+backbone_binary_tree'></span><span id='topic+backbone_consecutive_bifurcating'></span><span id='topic+backbone_trifurcating'></span><span id='topic+backbone_converging'></span><span id='topic+backbone_cycle'></span><span id='topic+backbone_cycle_simple'></span><span id='topic+backbone_linear'></span><span id='topic+backbone_linear_simple'></span><span id='topic+backbone_disconnected'></span>

<h3>Description</h3>

<p>A module is a group of genes which, to some extent, shows the same
expression behaviour. Several modules are connected together such that
one or more genes from one module will regulate the expression of
another module. By creating chains of modules, a dynamic behaviour in gene
regulation can be created.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>list_backbones()

backbone_bifurcating()

backbone_bifurcating_converging()

backbone_bifurcating_cycle()

backbone_bifurcating_loop()

backbone_branching(
  num_modifications = rbinom(1, size = 6, 0.25) + 1,
  min_degree = 3,
  max_degree = sample(min_degree:5, 1)
)

backbone_binary_tree(num_modifications = rbinom(1, size = 6, 0.25) + 1)

backbone_consecutive_bifurcating()

backbone_trifurcating()

backbone_converging()

backbone_cycle()

backbone_cycle_simple()

backbone_linear()

backbone_linear_simple()

backbone_disconnected(
  left_backbone = list_backbones() %&gt;% keep(., names(.) != "disconnected") %&gt;%
    sample(1) %&gt;% first(),
  right_backbone = list_backbones() %&gt;% keep(., names(.) != "disconnected") %&gt;%
    sample(1) %&gt;% first(),
  num_common_modules = 10
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="list_backbones_+3A_num_modifications">num_modifications</code></td>
<td>
<p>The number of branch points in the generated backbone.</p>
</td></tr>
<tr><td><code id="list_backbones_+3A_min_degree">min_degree</code></td>
<td>
<p>The minimum degree of each node in the backbone.</p>
</td></tr>
<tr><td><code id="list_backbones_+3A_max_degree">max_degree</code></td>
<td>
<p>The maximum degree of each node in the backbone.</p>
</td></tr>
<tr><td><code id="list_backbones_+3A_left_backbone">left_backbone</code></td>
<td>
<p>A backbone (other than a disconnected backbone), see <code><a href="#topic+list_backbones">list_backbones()</a></code>.</p>
</td></tr>
<tr><td><code id="list_backbones_+3A_right_backbone">right_backbone</code></td>
<td>
<p>A backbone (other than a disconnected backbone), see <code><a href="#topic+list_backbones">list_backbones()</a></code>.</p>
</td></tr>
<tr><td><code id="list_backbones_+3A_num_common_modules">num_common_modules</code></td>
<td>
<p>The number of modules which are regulated by either backbone.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of all the available backbone generators.
</p>


<h3>See Also</h3>

<p><a href="#topic+dyngen">dyngen</a> on how to run a dyngen simulation
</p>


<h3>Examples</h3>

<pre><code class='language-R'>names(list_backbones())

bb &lt;- backbone_bifurcating()
bb &lt;- backbone_bifurcating_converging()
bb &lt;- backbone_bifurcating_cycle()
bb &lt;- backbone_bifurcating_loop()
bb &lt;- backbone_binary_tree()
bb &lt;- backbone_branching()
bb &lt;- backbone_consecutive_bifurcating()
bb &lt;- backbone_converging()
bb &lt;- backbone_cycle()
bb &lt;- backbone_cycle_simple()
bb &lt;- backbone_disconnected()
bb &lt;- backbone_linear()
bb &lt;- backbone_linear_simple()
bb &lt;- backbone_trifurcating()

model &lt;- initialise_model(
  backbone = bb
)
</code></pre>

<hr>
<h2 id='plot_backbone_modulenet'>Visualise the backbone of a model</h2><span id='topic+plot_backbone_modulenet'></span>

<h3>Description</h3>

<p>Visualise the backbone of a model
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot_backbone_modulenet(model)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot_backbone_modulenet_+3A_model">model</code></td>
<td>
<p>A dyngen initial model created with <code><a href="#topic+initialise_model">initialise_model()</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A ggplot2 object.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data("example_model")
plot_backbone_modulenet(example_model)

</code></pre>

<hr>
<h2 id='plot_backbone_statenet'>Visualise the backbone state network of a model</h2><span id='topic+plot_backbone_statenet'></span>

<h3>Description</h3>

<p>Visualise the backbone state network of a model
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot_backbone_statenet(model, detailed = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot_backbone_statenet_+3A_model">model</code></td>
<td>
<p>A dyngen initial model created with <code><a href="#topic+initialise_model">initialise_model()</a></code>.</p>
</td></tr>
<tr><td><code id="plot_backbone_statenet_+3A_detailed">detailed</code></td>
<td>
<p>Whether or not to also plot the substates of transitions.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A ggplot2 object.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data("example_model")
plot_backbone_statenet(example_model)

</code></pre>

<hr>
<h2 id='plot_experiment_dimred'>Plot a dimensionality reduction of the final dataset</h2><span id='topic+plot_experiment_dimred'></span>

<h3>Description</h3>

<p>Plot a dimensionality reduction of the final dataset
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot_experiment_dimred(model, mapping = aes_string("comp_1", "comp_2"))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot_experiment_dimred_+3A_model">model</code></td>
<td>
<p>A dyngen intermediary model for which the simulations have been run with <code><a href="#topic+generate_experiment">generate_experiment()</a></code>.</p>
</td></tr>
<tr><td><code id="plot_experiment_dimred_+3A_mapping">mapping</code></td>
<td>
<p>Which components to plot.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A ggplot2 object.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data("example_model")
plot_experiment_dimred(example_model)

</code></pre>

<hr>
<h2 id='plot_feature_network'>Visualise the feature network of a model</h2><span id='topic+plot_feature_network'></span>

<h3>Description</h3>

<p>Visualise the feature network of a model
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot_feature_network(
  model,
  show_tfs = TRUE,
  show_targets = TRUE,
  show_hks = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot_feature_network_+3A_model">model</code></td>
<td>
<p>A dyngen intermediary model for which the feature network has been generated with <code><a href="#topic+generate_feature_network">generate_feature_network()</a></code>.</p>
</td></tr>
<tr><td><code id="plot_feature_network_+3A_show_tfs">show_tfs</code></td>
<td>
<p>Whether or not to show the transcription factors.</p>
</td></tr>
<tr><td><code id="plot_feature_network_+3A_show_targets">show_targets</code></td>
<td>
<p>Whether or not to show the targets.</p>
</td></tr>
<tr><td><code id="plot_feature_network_+3A_show_hks">show_hks</code></td>
<td>
<p>Whether or not to show the housekeeping genes.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A ggplot2 object.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data("example_model")
plot_feature_network(example_model)

</code></pre>

<hr>
<h2 id='plot_gold_expression'>Visualise the expression of the gold standard over simulation time</h2><span id='topic+plot_gold_expression'></span>

<h3>Description</h3>

<p>Visualise the expression of the gold standard over simulation time
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot_gold_expression(
  model,
  what = c("mol_premrna", "mol_mrna", "mol_protein"),
  label_changing = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot_gold_expression_+3A_model">model</code></td>
<td>
<p>A dyngen intermediary model for which the simulations have been run with <code><a href="#topic+generate_gold_standard">generate_gold_standard()</a></code>.</p>
</td></tr>
<tr><td><code id="plot_gold_expression_+3A_what">what</code></td>
<td>
<p>Which molecule types to visualise.</p>
</td></tr>
<tr><td><code id="plot_gold_expression_+3A_label_changing">label_changing</code></td>
<td>
<p>Whether or not to add a label next to changing molecules.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A ggplot2 object.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("example_model")
plot_gold_expression(example_model, what = "mol_mrna", label_changing = FALSE)
</code></pre>

<hr>
<h2 id='plot_gold_mappings'>Visualise the mapping of the simulations to the gold standard</h2><span id='topic+plot_gold_mappings'></span>

<h3>Description</h3>

<p>Visualise the mapping of the simulations to the gold standard
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot_gold_mappings(
  model,
  selected_simulations = NULL,
  do_facet = TRUE,
  mapping = aes_string("comp_1", "comp_2")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot_gold_mappings_+3A_model">model</code></td>
<td>
<p>A dyngen intermediary model for which the simulations have been run with <code><a href="#topic+generate_cells">generate_cells()</a></code>.</p>
</td></tr>
<tr><td><code id="plot_gold_mappings_+3A_selected_simulations">selected_simulations</code></td>
<td>
<p>Which simulation indices to visualise.</p>
</td></tr>
<tr><td><code id="plot_gold_mappings_+3A_do_facet">do_facet</code></td>
<td>
<p>Whether or not to facet according to simulation index.</p>
</td></tr>
<tr><td><code id="plot_gold_mappings_+3A_mapping">mapping</code></td>
<td>
<p>Which components to plot.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A ggplot2 object.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data("example_model")
plot_gold_mappings(example_model)

</code></pre>

<hr>
<h2 id='plot_gold_simulations'>Visualise the simulations using the dimred</h2><span id='topic+plot_gold_simulations'></span>

<h3>Description</h3>

<p>Visualise the simulations using the dimred
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot_gold_simulations(
  model,
  detailed = FALSE,
  mapping = aes_string("comp_1", "comp_2"),
  highlight = 0
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot_gold_simulations_+3A_model">model</code></td>
<td>
<p>A dyngen intermediary model for which the simulations have been run with <code><a href="#topic+generate_cells">generate_cells()</a></code>.</p>
</td></tr>
<tr><td><code id="plot_gold_simulations_+3A_detailed">detailed</code></td>
<td>
<p>Whether or not to colour according to each separate sub-edge in the gold standard.</p>
</td></tr>
<tr><td><code id="plot_gold_simulations_+3A_mapping">mapping</code></td>
<td>
<p>Which components to plot.</p>
</td></tr>
<tr><td><code id="plot_gold_simulations_+3A_highlight">highlight</code></td>
<td>
<p>Which simulation to highlight. If highlight == 0 then the gold simulation will be highlighted.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A ggplot2 object.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("example_model")
plot_gold_simulations(example_model)
</code></pre>

<hr>
<h2 id='plot_simulation_expression'>Visualise the expression of the simulations over simulation time</h2><span id='topic+plot_simulation_expression'></span>

<h3>Description</h3>

<p>Visualise the expression of the simulations over simulation time
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot_simulation_expression(
  model,
  simulation_i = 1:4,
  what = c("mol_premrna", "mol_mrna", "mol_protein"),
  facet = c("simulation", "module_group", "module_id", "none"),
  label_nonzero = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot_simulation_expression_+3A_model">model</code></td>
<td>
<p>A dyngen intermediary model for which the simulations have been run with <code><a href="#topic+generate_cells">generate_cells()</a></code>.</p>
</td></tr>
<tr><td><code id="plot_simulation_expression_+3A_simulation_i">simulation_i</code></td>
<td>
<p>Which simulation to visualise.</p>
</td></tr>
<tr><td><code id="plot_simulation_expression_+3A_what">what</code></td>
<td>
<p>Which molecule types to visualise.</p>
</td></tr>
<tr><td><code id="plot_simulation_expression_+3A_facet">facet</code></td>
<td>
<p>What to facet on.</p>
</td></tr>
<tr><td><code id="plot_simulation_expression_+3A_label_nonzero">label_nonzero</code></td>
<td>
<p>Plot labels for non-zero molecules.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A ggplot2 object.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data("example_model")
plot_simulation_expression(example_model)

</code></pre>

<hr>
<h2 id='plot_simulations'>Visualise the simulations using the dimred</h2><span id='topic+plot_simulations'></span>

<h3>Description</h3>

<p>Visualise the simulations using the dimred
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot_simulations(model, mapping = aes_string("comp_1", "comp_2"))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot_simulations_+3A_model">model</code></td>
<td>
<p>A dyngen intermediary model for which the simulations have been run with <code><a href="#topic+generate_cells">generate_cells()</a></code>.</p>
</td></tr>
<tr><td><code id="plot_simulations_+3A_mapping">mapping</code></td>
<td>
<p>Which components to plot.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A ggplot2 object.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data("example_model")
plot_simulations(example_model)

</code></pre>

<hr>
<h2 id='plot_summary'>Plot a summary of all dyngen simulation steps.</h2><span id='topic+plot_summary'></span>

<h3>Description</h3>

<p>Plot a summary of all dyngen simulation steps.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot_summary(model)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot_summary_+3A_model">model</code></td>
<td>
<p>A dyngen intermediary model for which the simulations have been run with <code><a href="#topic+generate_experiment">generate_experiment()</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A ggplot2 object.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data("example_model")
plot_summary(example_model)

</code></pre>

<hr>
<h2 id='realcounts'>A set of real single cell expression datasets</h2><span id='topic+realcounts'></span>

<h3>Description</h3>

<p>Statistics are derived from these datasets in order to simulate single cell experiments.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>realcounts
</code></pre>


<h3>Format</h3>

<p>An object of class <code>tbl_df</code> (inherits from <code>tbl</code>, <code>data.frame</code>) with 111 rows and 9 columns.
</p>

<hr>
<h2 id='realnets'>A set of gold standard gene regulatory networks</h2><span id='topic+realnets'></span>

<h3>Description</h3>

<p>These networks are subsampled in order to generate realistic feature and housekeeping networks.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>realnets
</code></pre>


<h3>Format</h3>

<p>An object of class <code>tbl_df</code> (inherits from <code>tbl</code>, <code>data.frame</code>) with 32 rows and 2 columns.
</p>

<hr>
<h2 id='reexports'>Objects exported from other packages</h2><span id='topic+reexports'></span><span id='topic+ssa_etl'></span><span id='topic+ssa_exact'></span><span id='topic+ode_em'></span><span id='topic++25+3E+25'></span>

<h3>Description</h3>

<p>These objects are imported from other packages. Follow the links
below to see their documentation.
</p>

<dl>
<dt>GillespieSSA2</dt><dd><p><code><a href="GillespieSSA2.html#topic+ode_em">ode_em</a></code>, <code><a href="GillespieSSA2.html#topic+ssa_etl">ssa_etl</a></code>, <code><a href="GillespieSSA2.html#topic+ssa_exact">ssa_exact</a></code></p>
</dd>
<dt>purrr</dt><dd><p><code><a href="purrr.html#topic+pipe">%&gt;%</a></code></p>
</dd>
</dl>

<hr>
<h2 id='rnorm_bounded'>A bounded version of rnorm</h2><span id='topic+rnorm_bounded'></span>

<h3>Description</h3>

<p>A bounded version of rnorm
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rnorm_bounded(n, mean = 0, sd = 1, min = -Inf, max = Inf)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rnorm_bounded_+3A_n">n</code></td>
<td>
<p>number of observations. If <code>length(n) &gt; 1</code>, the length
is taken to be the number required.</p>
</td></tr>
<tr><td><code id="rnorm_bounded_+3A_mean">mean</code></td>
<td>
<p>vector of means.</p>
</td></tr>
<tr><td><code id="rnorm_bounded_+3A_sd">sd</code></td>
<td>
<p>vector of standard deviations.</p>
</td></tr>
<tr><td><code id="rnorm_bounded_+3A_min">min</code></td>
<td>
<p>lower limits of the distribution.</p>
</td></tr>
<tr><td><code id="rnorm_bounded_+3A_max">max</code></td>
<td>
<p>upper limits of the distribution.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Generates values with rnorm, bounded by [min, max]
</p>


<h3>Examples</h3>

<pre><code class='language-R'>rnorm_bounded(10)
</code></pre>

<hr>
<h2 id='runif_subrange'>A subrange version of runif</h2><span id='topic+runif_subrange'></span>

<h3>Description</h3>

<p>Will generate numbers from a random subrange within the given range.
For example, if [min, max]<code style="white-space: pre;">&#8288;is set to \[0, 10\], this function could decide to generate&#8288;</code>n' numbers between 2 and 6.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>runif_subrange(n, min, max)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="runif_subrange_+3A_n">n</code></td>
<td>
<p>Number of observations</p>
</td></tr>
<tr><td><code id="runif_subrange_+3A_min">min</code></td>
<td>
<p>Lower limits of the distribution.</p>
</td></tr>
<tr><td><code id="runif_subrange_+3A_max">max</code></td>
<td>
<p>Upper limits of the distribution.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Generates values with runif, bounded by a range drawn from <code>sort(runif(2, min, max))</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>runif_subrange(20, 0, 10)
</code></pre>

<hr>
<h2 id='simtime_from_backbone'>Determine simulation time from backbone</h2><span id='topic+simtime_from_backbone'></span>

<h3>Description</h3>

<p>Determine simulation time from backbone
</p>


<h3>Usage</h3>

<pre><code class='language-R'>simtime_from_backbone(backbone, burn = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="simtime_from_backbone_+3A_backbone">backbone</code></td>
<td>
<p>A valid dyngen backbone object</p>
</td></tr>
<tr><td><code id="simtime_from_backbone_+3A_burn">burn</code></td>
<td>
<p>Whether or not to compute the simtime for only the burn phase</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An estimation of the required simulation time
</p>


<h3>Examples</h3>

<pre><code class='language-R'>backbone &lt;- backbone_linear()

simtime_from_backbone(backbone)

model &lt;- initialise_model(
  backbone = backbone,
  simulation_params = simulation_default(
    burn_time = simtime_from_backbone(backbone, burn = TRUE),
    total_time = simtime_from_backbone(backbone, burn = FALSE)
  )
)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
