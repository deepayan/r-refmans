<!DOCTYPE html><html lang="en"><head><title>Help for package SSsimple</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {SSsimple}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#SSsimple-package'>
<p>Simple State Space Models</p></a></li>
<li><a href='#H.omega.cos.2D'>
<p>Bases Transformation</p></a></li>
<li><a href='#H.omega.sincos'>
<p>Bases Transformation</p></a></li>
<li><a href='#SS_O3'>
<p>California Ozone</p></a></li>
<li><a href='#SS.ID'>
<p>System Identification</p></a></li>
<li><a href='#SS.sim'>
<p>Simulation</p></a></li>
<li><a href='#SS.sim.chol'>
<p>Simulation</p></a></li>
<li><a href='#SS.sim.tv'>
<p>Simulation</p></a></li>
<li><a href='#SS.solve'>
<p>Optimal Estimation</p></a></li>
<li><a href='#SS.solve.SMW'>
<p>Optimal Estimation</p></a></li>
<li><a href='#SS.solve.tv'>
<p>Optimal Estimation</p></a></li>
<li><a href='#SS.stst'>
<p>Steady State</p></a></li>
<li><a href='#SS.stst.SMW'>
<p>Steady State using the Woodbury matrix identity</p></a></li>
<li><a href='#SS.stst.tv'>
<p>Steady State</p></a></li>
<li><a href='#SSsimple-internal'><p>Internal SSsimple objects</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>State Space Models</td>
</tr>
<tr>
<td>Version:</td>
<td>0.6.6</td>
</tr>
<tr>
<td>Date:</td>
<td>2019-12-06</td>
</tr>
<tr>
<td>Author:</td>
<td>Dave Zes</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Dave Zes &lt;zesdave@gmail.com&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Simulate, solve state space models.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>Depends:</td>
<td>mvtnorm</td>
</tr>
<tr>
<td>Suggests:</td>
<td>maps</td>
</tr>
<tr>
<td>Imports:</td>
<td>methods</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2019-12-06 20:48:47 UTC; dzes</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2019-12-07 01:10:10 UTC</td>
</tr>
</table>
<hr>
<h2 id='SSsimple-package'>
Simple State Space Models
</h2><span id='topic+SSsimple-package'></span><span id='topic+SSsimple'></span>

<h3>Description</h3>

<p>Simulate, solve (estimate), fit state space models
</p>


<h3>Details</h3>


<table>
<tr>
 <td style="text-align: left;">
Package: </td><td style="text-align: left;"> SSsimple</td>
</tr>
<tr>
 <td style="text-align: left;">
Type: </td><td style="text-align: left;"> Package</td>
</tr>
<tr>
 <td style="text-align: left;">
Version: </td><td style="text-align: left;"> 0.6.6 </td>
</tr>
<tr>
 <td style="text-align: left;">
Date: </td><td style="text-align: left;"> 2019-12-06</td>
</tr>
<tr>
 <td style="text-align: left;">
License: </td><td style="text-align: left;"> GPL (&gt;= 2) </td>
</tr>
<tr>
 <td style="text-align: left;">
LazyLoad: </td><td style="text-align: left;"> yes</td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>

<p>If you wish to parameterize a state space model given only data, <code>Z</code>, use the function <code><a href="#topic+SS.ID">SS.ID</a></code>.  If you wish to simulate data, use <code><a href="#topic+SS.sim">SS.sim</a></code> or <code><a href="#topic+SS.sim.tv">SS.sim.tv</a></code>.  If you have data, know the model parameters, and wish to solve the lowest L2 estimate, use <code><a href="#topic+SS.solve">SS.solve</a></code> or <code><a href="#topic+SS.solve.tv">SS.solve.tv</a></code>.
</p>
<p>The two functions, <code><a href="#topic+H.omega.sincos">H.omega.sincos</a></code> and <code><a href="#topic+H.omega.cos.2D">H.omega.cos.2D</a></code>, provide a means of introducing response curvature over a domain (probably space) through the common sine bases expansion.
</p>
<p>Finally, <code><a href="#topic+SS.stst">SS.stst</a></code> and <code><a href="#topic+SS.stst.tv">SS.stst.tv</a></code>, attempt to find the time at which a system acheives a &ldquo;steady-state.&rdquo;
</p>
<p>The system of interest is defined as
</p>
<p><b>b</b>(t) = <b>F</b> <b>b</b>(t-1) + <b>n</b>(t) ,    <b>n</b>(t) ~ <em>N</em>[<b>0</b>, <b>Q</b>]
</p>
<p><b>z</b>'(t) = <b>H</b> <b>b</b>(t) + <b>e</b>(t) ,    <b>e</b>(t) ~ <em>N</em>[<b>0</b>, <b>R</b>]
</p>
<p>Functions whose names end in &ldquo;.tv&rdquo; provide for the usage of time-varying <code>F</code>, <code>H</code>, <code>Q</code>, <code>R</code>.
</p>


<h3>Author(s)</h3>

<p>Dave Zes
</p>
<p>Maintainer: Dave Zes &lt;zesdave@gmail.com&gt;
</p>

<hr>
<h2 id='H.omega.cos.2D'>
Bases Transformation
</h2><span id='topic+H.omega.cos.2D'></span>

<h3>Description</h3>

<p>Create H as cosine bases expansion over R^2
</p>


<h3>Usage</h3>

<pre><code class='language-R'>H.omega.cos.2D(x, y, u.x, u.y, phs.x, phs.y)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="H.omega.cos.2D_+3A_x">x</code></td>
<td>

<p>A vector of locations on <em>x</em> of length <em>n</em>.
</p>
</td></tr>
<tr><td><code id="H.omega.cos.2D_+3A_y">y</code></td>
<td>

<p>A vector of locations on <em>y</em> of length <em>n</em>.
</p>
</td></tr>
<tr><td><code id="H.omega.cos.2D_+3A_u.x">u.x</code></td>
<td>

<p>A vector of frequencies on <em>x</em>.
</p>
</td></tr>
<tr><td><code id="H.omega.cos.2D_+3A_u.y">u.y</code></td>
<td>

<p>A vector of frequencies on <em>y</em>.
</p>
</td></tr>
<tr><td><code id="H.omega.cos.2D_+3A_phs.x">phs.x</code></td>
<td>

<p>A vector of phase shifts on <em>x</em>.  Should be same length as <code>u.x</code>.
</p>
</td></tr>
<tr><td><code id="H.omega.cos.2D_+3A_phs.y">phs.y</code></td>
<td>

<p>A vector of phase shifts on <em>y</em>.  Should be same length as <code>u.y</code>.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An <em>n</em> x <em>d</em> matrix, with <em>d</em> = <code>length(u.x) * length(u.y)</code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+H.omega.sincos">H.omega.sincos</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- rep( I(0:10) / 10,   11 )
y &lt;- rep( I(0:10) / 10,   each=11 )
u.x &lt;- I(1:2) * pi
u.y &lt;- I(1:2) * pi
H &lt;- H.omega.cos.2D(x, y, u.x, u.y, c(0,0), c(0,0))

b &lt;- rep(1, ncol(H))

z &lt;- H %*% b

plot(x, y, cex=z-min(z))

</code></pre>

<hr>
<h2 id='H.omega.sincos'>
Bases Transformation
</h2><span id='topic+H.omega.sincos'></span>

<h3>Description</h3>

<p>Create H as sine-cosine bases expansion over R^1
</p>


<h3>Usage</h3>

<pre><code class='language-R'>H.omega.sincos(x, u)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="H.omega.sincos_+3A_x">x</code></td>
<td>

<p>A vector of locations of length <em>n</em>.
</p>
</td></tr>
<tr><td><code id="H.omega.sincos_+3A_u">u</code></td>
<td>

<p>A vector of frequencies of length <em>d</em>/2.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An <em>n</em> x <em>d</em> matrix.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+H.omega.cos.2D">H.omega.cos.2D</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- I(0:10) / 10
u &lt;- I(1:4) * pi
H.omega.sincos(x, u)
</code></pre>

<hr>
<h2 id='SS_O3'>
California Ozone
</h2><span id='topic+SS_O3'></span>

<h3>Description</h3>

<p>Daily airborne Ozone concentrations (ppb) over California, 68 fixed sensors, 2005-2006
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(SS_O3)</code></pre>


<h3>Format</h3>

<p>The format is:
</p>
<p>List of 2
</p>
<p><code>$Z</code>      :'data.frame': 730 obs. of  68 variables: Ozone ppb for 68 sensors.
</p>
<p><code>$locs</code>   :'data.frame': 68 obs. of  2 variables: longitude, latitude for 68 sites.
</p>


<h3>Source</h3>

<p>The Ozone data originates from the California Air Resources Board (CARB).  The interpolation grid elevations originate from the Google Elevation API.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(SS_O3)
</code></pre>

<hr>
<h2 id='SS.ID'>
System Identification
</h2><span id='topic+SS.ID'></span>

<h3>Description</h3>

<p>Perform non-iterative, subspace grey-box system identification
</p>


<h3>Usage</h3>

<pre><code class='language-R'>SS.ID(Z, d, rsN = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="SS.ID_+3A_z">Z</code></td>
<td>

<p>A <em>T</em> x <em>n</em> data matrix 
</p>
</td></tr>
<tr><td><code id="SS.ID_+3A_d">d</code></td>
<td>

<p>A scalar integer.  The system &ldquo;order.&rdquo;
</p>
</td></tr>
<tr><td><code id="SS.ID_+3A_rsn">rsN</code></td>
<td>

<p>A 3-element integer vector, containing <em>r</em>, <em>s</em>, <em>N</em> as described by Ljung.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Only works when <em>T</em> &gt;&gt; <em>n</em> (one resolved to using <code>SS.ID</code> when this is not true is free to pluck columns from Z until it is).
</p>
<p>Complaints issued from this function to the effect that a matrix that is some function of &ldquo;PP&rdquo; cannot be inverted might be remedied by turning <em>r</em> and <em>s</em> down (the first two elements of the <code>rsN</code> argument), or perhaps by adding a small amount of noise to Z.
</p>
<p>This is subspace estimation.  <code>SS.ID</code> estimates system hyperparameters from data.  One can usually henceforth solve (using <code><a href="#topic+SS.solve">SS.solve</a></code>) for good quality observation-space estimates, but should not assume the resulting state estimates are anywhere near truth.  One may wish to use estimates generated with this function as initial values for iterative estimation techniques, e.g., package <code>Stem</code>.
</p>


<h3>Value</h3>

<p>A named list.
</p>
<table role = "presentation">
<tr><td><code>F.hat</code></td>
<td>
<p>A <em>d</em> x <em>d</em> matrix.</p>
</td></tr>
<tr><td><code>H.hat</code></td>
<td>
<p>An <em>n</em> x <em>d</em> matrix.</p>
</td></tr>
<tr><td><code>Q.hat</code></td>
<td>
<p>A <em>d</em> x <em>d</em> matrix.</p>
</td></tr>
<tr><td><code>R.hat</code></td>
<td>
<p>An <em>n</em> x <em>n</em> matrix.</p>
</td></tr>
</table>


<h3>References</h3>

<p>Lennart Ljung.  <em>System Identification, Theory for the User</em>.  Prentice Hall, 1999.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>Q &lt;- diag(1/10, 2)
R &lt;- diag(2, 3)
H &lt;- matrix(1, 3, 2)
F &lt;- diag(0.99, 2)

set.seed(9999)
xs &lt;- SS.sim(F, H, Q, R, 2000, rep(0, 2))

## notice that while the parameter estimates appear somewhat inaccurate ...
ssid &lt;- SS.ID( xs$Z , 2,  c(3, 6, 900) ) ; ssid

## the observation estimate:
sss &lt;- SS.solve( xs$Z, ssid$F.hat, ssid$H.hat, ssid$Q.hat, ssid$R.hat, nrow(xs$Z), 10^5, c(0,0)) 
Z.hat &lt;- t( ssid$H.hat %*% t( sss$B.apri ) )
sqrt( mean( (xs$Z - Z.hat)^2 ) )

## is nontheless very close to that using true hyperparameter values:
sss.true &lt;- SS.solve( xs$Z, F, H, Q, R, nrow(xs$Z), 10^5, c(0,0)) 
Z.hat &lt;- t( H %*% t( sss.true$B.apri ) )
sqrt( mean( (xs$Z - Z.hat)^2 ) )
</code></pre>

<hr>
<h2 id='SS.sim'>
Simulation
</h2><span id='topic+SS.sim'></span>

<h3>Description</h3>

<p>Simulate a state space system
</p>


<h3>Usage</h3>

<pre><code class='language-R'>SS.sim(F, H, Q, R, length.out, beta0=0)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="SS.sim_+3A_f">F</code></td>
<td>

<p>The state matrix.  A scalar, or vector of length <em>d</em>, or a <em>d</em> x <em>d</em> matrix.  When scalar, <code>F</code> is constant diagonal.  When a vector, <code>F</code> is diagonal.
</p>
</td></tr>
<tr><td><code id="SS.sim_+3A_h">H</code></td>
<td>

<p>The measurement matrix.  Must be <em>n</em> x <em>d</em>.
</p>
</td></tr>
<tr><td><code id="SS.sim_+3A_q">Q</code></td>
<td>

<p>The state variance.  A scalar, or vector of length <em>d</em>, or a <em>d</em> x <em>d</em> matrix.  When scalar, <code>Q</code> is constant diagonal.  When a vector, <code>Q</code> is diagonal.
</p>
</td></tr>
<tr><td><code id="SS.sim_+3A_r">R</code></td>
<td>

<p>The measurement variance.  A scalar, or vector of length <em>n</em>, or an <em>n</em> x <em>n</em> matrix.  When scalar, <code>R</code> is constant diagonal.  When a vector, <code>R</code> is diagonal.
</p>
</td></tr>
<tr><td><code id="SS.sim_+3A_length.out">length.out</code></td>
<td>

<p>Scalar integer.
</p>
</td></tr>
<tr><td><code id="SS.sim_+3A_beta0">beta0</code></td>
<td>

<p>Initial state value.  A scalar, or a vector of length <em>d</em>.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>H</code> is the master argument from which system dimensionality is determined.
</p>


<h3>Value</h3>

<p>A named list.
</p>
<table role = "presentation">
<tr><td><code>Beta</code></td>
<td>
<p>A <em>T</em> x <em>d</em> matrix, the <em>i</em>th row of which is the state at time <em>i</em>.</p>
</td></tr>
<tr><td><code>Y</code></td>
<td>
<p>A <em>T</em> x <em>n</em> matrix, the <em>i</em>th row of which is the noiseless observation at time <em>i</em>.</p>
</td></tr>
<tr><td><code>Z</code></td>
<td>
<p>A <em>T</em> x <em>n</em> matrix, the <em>i</em>th row of which is the observation at time <em>i</em>.</p>
</td></tr>
</table>


<h3>Note</h3>

<p>For a definition of the system of interest, please see <code><a href="#topic+SSsimple">SSsimple</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>tau &lt;- 30	
	
x &lt;- I( 0:10 / 10 )

H &lt;- H.omega.sincos( x, c( 1*pi, 4*pi ) )

xs &lt;- SS.sim( 0.99, H, 1, 2, tau, rep(0, ncol(H)) )

## Not run: 
for(i in 1:nrow(xs$Z)) {
	plot(x, xs$Z[ i, ], ylim=range(xs$Z), main=i)
	Sys.sleep(1/10)
}

## End(Not run)
</code></pre>

<hr>
<h2 id='SS.sim.chol'>
Simulation
</h2><span id='topic+SS.sim.chol'></span>

<h3>Description</h3>

<p>Simulate a state space system by supplying measurement variance Cholesky decomposition
</p>


<h3>Usage</h3>

<pre><code class='language-R'>SS.sim.chol(F, H, Q, R.chol, length.out, beta0=0)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="SS.sim.chol_+3A_f">F</code></td>
<td>

<p>The state matrix.  A scalar, or vector of length <em>d</em>, or a <em>d</em> x <em>d</em> matrix.  When scalar, <code>F</code> is constant diagonal.  When a vector, <code>F</code> is diagonal.
</p>
</td></tr>
<tr><td><code id="SS.sim.chol_+3A_h">H</code></td>
<td>

<p>The measurement matrix.  Must be <em>n</em> x <em>d</em>.
</p>
</td></tr>
<tr><td><code id="SS.sim.chol_+3A_q">Q</code></td>
<td>

<p>The state variance.  A scalar, or vector of length <em>d</em>, or a <em>d</em> x <em>d</em> matrix.  When scalar, <code>Q</code> is constant diagonal.  When a vector, <code>Q</code> is diagonal.
</p>
</td></tr>
<tr><td><code id="SS.sim.chol_+3A_r.chol">R.chol</code></td>
<td>

<p>The Cholesky decomposition of the measurement variance (must possess pivot), must be <em>n</em> x <em>n</em>.
</p>
</td></tr>
<tr><td><code id="SS.sim.chol_+3A_length.out">length.out</code></td>
<td>

<p>Scalar integer.
</p>
</td></tr>
<tr><td><code id="SS.sim.chol_+3A_beta0">beta0</code></td>
<td>

<p>Initial state value.  A scalar, or a vector of length <em>d</em>.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>H</code> is the master argument from which system dimensionality is determined.
Spiritually identical to <code><a href="#topic+SS.sim">SS.sim</a></code>.  This method can be used to speed up simulating multiple systems with the same parameterization.
</p>


<h3>Value</h3>

<p>A named list.
</p>
<table role = "presentation">
<tr><td><code>Beta</code></td>
<td>
<p>A <em>T</em> x <em>d</em> matrix, the <em>i</em>th row of which is the state at time <em>i</em>.</p>
</td></tr>
<tr><td><code>Y</code></td>
<td>
<p>A <em>T</em> x <em>n</em> matrix, the <em>i</em>th row of which is the noiseless observation at time <em>i</em>.</p>
</td></tr>
<tr><td><code>Z</code></td>
<td>
<p>A <em>T</em> x <em>n</em> matrix, the <em>i</em>th row of which is the observation at time <em>i</em>.</p>
</td></tr>
</table>


<h3>Note</h3>

<p>For a definition of the system of interest, please see <code><a href="#topic+SSsimple">SSsimple</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>tau &lt;- 30	
	
x &lt;- I( 0:10 / 10 )

H &lt;- H.omega.sincos( x, c( 1*pi, 4*pi ) )

R &lt;- diag(7, length(x))
R.chol &lt;- chol(R, pivot=TRUE)

xs &lt;- SS.sim.chol( 0.99, H, 1, R.chol, tau, rep(0, ncol(H)) )

## Not run: 
for(i in 1:nrow(xs$Z)) {
	plot(x, xs$Z[ i, ], ylim=range(xs$Z), main=i)
	Sys.sleep(1/10)
}

## End(Not run)

</code></pre>

<hr>
<h2 id='SS.sim.tv'>
Simulation
</h2><span id='topic+SS.sim.tv'></span>

<h3>Description</h3>

<p>Simulate a time-varying state space system
</p>


<h3>Usage</h3>

<pre><code class='language-R'>SS.sim.tv(F, H, Q, R, length.out, beta0=0)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="SS.sim.tv_+3A_f">F</code></td>
<td>

<p>A list of <em>d</em> x <em>d</em> matrices.
</p>
</td></tr>
<tr><td><code id="SS.sim.tv_+3A_h">H</code></td>
<td>

<p>A list of <em>n</em> x <em>d</em> matrices.
</p>
</td></tr>
<tr><td><code id="SS.sim.tv_+3A_q">Q</code></td>
<td>

<p>A list of <em>d</em> x <em>d</em> matrices.
</p>
</td></tr>
<tr><td><code id="SS.sim.tv_+3A_r">R</code></td>
<td>

<p>A list of <em>n</em> x <em>n</em> matrices.
</p>
</td></tr>
<tr><td><code id="SS.sim.tv_+3A_length.out">length.out</code></td>
<td>

<p>A scalar integer.
</p>
</td></tr>
<tr><td><code id="SS.sim.tv_+3A_beta0">beta0</code></td>
<td>

<p>Initial state value.  A scalar, or a vector of length <em>d</em>.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is a more general, and slower, implementation of <code>SS.sim</code>.  This function can also accept arguments in non-time-varying fashion (<em>a la</em> <code><a href="#topic+SS.sim">SS.sim</a></code>).
</p>


<h3>Value</h3>

<p>A named list.
</p>
<table role = "presentation">
<tr><td><code>Beta</code></td>
<td>
<p>A <em>T</em> x <em>d</em> matrix, the <em>i</em>th row of which is the state at time <em>i</em>.</p>
</td></tr>
<tr><td><code>Y</code></td>
<td>
<p>A <em>T</em> x <em>n</em> matrix, the <em>i</em>th row of which is noiseless observation at time <em>i</em>.</p>
</td></tr>
<tr><td><code>Z</code></td>
<td>
<p>A <em>T</em> x <em>n</em> matrix, the <em>i</em>th row of which is observation at time <em>i</em>.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(9999)

H.tv &lt;- list()
for(i in 1:200) {
	H.tv[[i]] &lt;- matrix( c( sin(i * 0.05), cos(i * 0.05) ), 1, 2 )
}

ssx &lt;- SS.sim.tv( 0.99, H.tv, 0.001, 1, 200, c(4,4) )

plot(ssx$Z[ ,1], type="l")
</code></pre>

<hr>
<h2 id='SS.solve'>
Optimal Estimation
</h2><span id='topic+SS.solve'></span>

<h3>Description</h3>

<p>Solve a state space system using the Kalman Filter
</p>


<h3>Usage</h3>

<pre><code class='language-R'>SS.solve(Z, F, H, Q, R, length.out, P0, beta0=0)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="SS.solve_+3A_z">Z</code></td>
<td>

<p>A <em>T</em> x <em>n</em> data matrix. 
</p>
</td></tr>
<tr><td><code id="SS.solve_+3A_f">F</code></td>
<td>

<p>The state matrix.  A scalar, or vector of length <em>d</em>, or a <em>d</em> x <em>d</em> matrix.  When scalar, <code>F</code> is constant diagonal.  When a vector, <code>F</code> is diagonal.  
</p>
</td></tr>
<tr><td><code id="SS.solve_+3A_h">H</code></td>
<td>

<p>The measurement matrix.  Must be <em>n</em> x <em>d</em>. 
</p>
</td></tr>
<tr><td><code id="SS.solve_+3A_q">Q</code></td>
<td>

<p>The state variance.  A scalar, or vector of length <em>d</em>, or a <em>d</em> x <em>d</em> matrix.  When scalar, <code>Q</code> is constant diagonal.  When a vector, <code>Q</code> is diagonal.
</p>
</td></tr>
<tr><td><code id="SS.solve_+3A_r">R</code></td>
<td>

<p>The measurement variance.  A scalar, or vector of length <em>n</em>, or an <em>n</em> x <em>n</em> matrix.  When scalar, <code>R</code> is constant diagonal.  When a vector, <code>R</code> is diagonal.
</p>
</td></tr>
<tr><td><code id="SS.solve_+3A_length.out">length.out</code></td>
<td>

<p>Scalar integer.
</p>
</td></tr>
<tr><td><code id="SS.solve_+3A_p0">P0</code></td>
<td>

<p>Initial <em>a priori</em> prediction error.
</p>
</td></tr>
<tr><td><code id="SS.solve_+3A_beta0">beta0</code></td>
<td>

<p>Initial state value.  A scalar, or a vector of length <em>d</em>.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>H</code> is the master argument from which system dimensionality is determined.
</p>


<h3>Value</h3>

<p>A named list.
</p>
<table role = "presentation">
<tr><td><code>B.apri</code></td>
<td>
<p>A <em>T</em> x <em>d</em> matrix, the <em>i</em>th row of which is the best state estimate prior to observing data at time <em>i</em>.</p>
</td></tr>
<tr><td><code>B.apos</code></td>
<td>
<p>A <em>T</em> x <em>d</em> matrix, the <em>i</em>th row of which is the best state estimate given the observation at time <em>i</em>.</p>
</td></tr>
</table>


<h3>Note</h3>

<p>For a definition of the system of interest, please see <code><a href="#topic+SSsimple">SSsimple</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(999)
H &lt;- matrix(1)
x &lt;- SS.sim( 1, H, 1, 1, 100, 0 )
y &lt;- SS.solve( x$Z, 1, H, 1, 1, 100, 10^5, 0 )

z.hat &lt;- t( H %*% t( y$B.apri ) )

plot( x$Z, type="l", col="blue" )
points( z.hat[ ,1], type="l", col="red" )
</code></pre>

<hr>
<h2 id='SS.solve.SMW'>
Optimal Estimation
</h2><span id='topic+SS.solve.SMW'></span>

<h3>Description</h3>

<p>Solve a state space system using the Kalman Filter.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>SS.solve.SMW(Z, F, H, Q, inv.R, length.out, P0, beta0=0)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="SS.solve.SMW_+3A_z">Z</code></td>
<td>

<p>A <em>T</em> x <em>n</em> data matrix. 
</p>
</td></tr>
<tr><td><code id="SS.solve.SMW_+3A_f">F</code></td>
<td>

<p>The state matrix.  A scalar, or vector of length <em>d</em>, or a <em>d</em> x <em>d</em> matrix.  When scalar, <code>F</code> is constant diagonal.  When a vector, <code>F</code> is diagonal.  
</p>
</td></tr>
<tr><td><code id="SS.solve.SMW_+3A_h">H</code></td>
<td>

<p>The measurement matrix.  Must be <em>n</em> x <em>d</em>. 
</p>
</td></tr>
<tr><td><code id="SS.solve.SMW_+3A_q">Q</code></td>
<td>

<p>The state variance.  A scalar, or vector of length <em>d</em>, or a <em>d</em> x <em>d</em> matrix.  When scalar, <code>Q</code> is constant diagonal.  When a vector, <code>Q</code> is diagonal.
</p>
</td></tr>
<tr><td><code id="SS.solve.SMW_+3A_inv.r">inv.R</code></td>
<td>

<p>The inverse of the measurement variance.  A scalar, or vector of length <em>n</em>, or a <em>n</em> x <em>n</em> matrix.  When scalar, <code>inv.R</code> is constant diagonal.  When a vector, <code>inv.R</code> is diagonal.
</p>
</td></tr>
<tr><td><code id="SS.solve.SMW_+3A_length.out">length.out</code></td>
<td>

<p>Scalar integer.
</p>
</td></tr>
<tr><td><code id="SS.solve.SMW_+3A_p0">P0</code></td>
<td>

<p>Initial <em>a priori</em> prediction error.
</p>
</td></tr>
<tr><td><code id="SS.solve.SMW_+3A_beta0">beta0</code></td>
<td>

<p>Initial state value.  A scalar, or a vector of length <em>d</em>.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>H</code> is the master argument from which system dimensionality is determined.  Otherwise identical to <code><a href="#topic+SS.solve">SS.solve</a></code>, except that the Woodbury identity is used for inversion.  This method offers a computationally reduced means of solving the system realization of interest; however, this method must be supplied with the inverse of the measurement variance matrix, R &ndash; not R.
</p>


<h3>Value</h3>

<p>A named list.
</p>
<table role = "presentation">
<tr><td><code>B.apri</code></td>
<td>
<p>A <em>T</em> x <em>d</em> matrix, the <em>i</em>th row of which is the best state estimate prior to observing data at time <em>i</em>.</p>
</td></tr>
<tr><td><code>B.apos</code></td>
<td>
<p>A <em>T</em> x <em>d</em> matrix, the <em>i</em>th row of which is the best state estimate given the observation at time <em>i</em>.</p>
</td></tr>
</table>


<h3>Note</h3>

<p>For a definition of the system of interest, please see <code><a href="#topic+SSsimple">SSsimple</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(999)
H &lt;- matrix(1)
R &lt;- 7
inv.R &lt;- 1 / R
x &lt;- SS.sim( 1, H, 1, R, 100, 0 )
y &lt;- SS.solve.SMW( x$Z, 1, H, 1, inv.R, 100, 10^5, 0 )

z.hat &lt;- t( H %*% t( y$B.apri ) )

plot( x$Z, type="l", col="blue" )
points( z.hat[ ,1], type="l", col="red" )
</code></pre>

<hr>
<h2 id='SS.solve.tv'>
Optimal Estimation
</h2><span id='topic+SS.solve.tv'></span>

<h3>Description</h3>

<p>Solve a time-varying state space system using the Kalman Filter
</p>


<h3>Usage</h3>

<pre><code class='language-R'>SS.solve.tv(Z, F, H, Q, R, length.out, P0, beta0)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="SS.solve.tv_+3A_z">Z</code></td>
<td>

<p>A <em>T</em> x <em>n</em> data matrix 
</p>
</td></tr>
<tr><td><code id="SS.solve.tv_+3A_f">F</code></td>
<td>

<p>A list of <em>d</em> x <em>d</em> matrices.
</p>
</td></tr>
<tr><td><code id="SS.solve.tv_+3A_h">H</code></td>
<td>

<p>A list of <em>n</em> x <em>d</em> matrices.
</p>
</td></tr>
<tr><td><code id="SS.solve.tv_+3A_q">Q</code></td>
<td>

<p>A list of <em>d</em> x <em>d</em> matrices.
</p>
</td></tr>
<tr><td><code id="SS.solve.tv_+3A_r">R</code></td>
<td>

<p>A list of <em>n</em> x <em>n</em> matrices.
</p>
</td></tr>
<tr><td><code id="SS.solve.tv_+3A_length.out">length.out</code></td>
<td>

<p>A scalar integer.
</p>
</td></tr>
<tr><td><code id="SS.solve.tv_+3A_p0">P0</code></td>
<td>

<p>Initial <em>a priori</em> prediction error.
</p>
</td></tr>
<tr><td><code id="SS.solve.tv_+3A_beta0">beta0</code></td>
<td>

<p>Initial state value.  A scalar, or a vector of length <em>d</em>.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is a more general, and slower, implementation of <code>SS.solve</code>.  This function can also accept arguments in non-time-varying fashion (<em>a la</em> <code><a href="#topic+SS.solve">SS.solve</a></code>).
</p>


<h3>Value</h3>

<p>A named list.
</p>
<table role = "presentation">
<tr><td><code>B.apri</code></td>
<td>
<p>A <em>T</em> x <em>d</em> matrix, the <em>i</em>th row of which is the best state estimate prior to observing data at time <em>i</em>.</p>
</td></tr>
<tr><td><code>B.apos</code></td>
<td>
<p>A <em>T</em> x <em>d</em> matrix, the <em>i</em>th row of which is the best state estimate given the observation at time <em>i</em>.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+SS.solve">SS.solve</a></code>
</p>

<hr>
<h2 id='SS.stst'>
Steady State
</h2><span id='topic+SS.stst'></span>

<h3>Description</h3>

<p>Find steady state of system, i.e., locate when Kalman gain converges
</p>


<h3>Usage</h3>

<pre><code class='language-R'>SS.stst(F, H, Q, R, P0, epsilon, verbosity=0)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="SS.stst_+3A_f">F</code></td>
<td>

<p>The state matrix.  A scalar, or vector of length <em>d</em>, or a <em>d</em> x <em>d</em> matrix.  When scalar, <code>F</code> is constant diagonal.  When a vector, <code>F</code> is diagonal.
</p>
</td></tr>
<tr><td><code id="SS.stst_+3A_h">H</code></td>
<td>

<p>The measurement matrix.  Must be <em>n</em> x <em>d</em>.
</p>
</td></tr>
<tr><td><code id="SS.stst_+3A_q">Q</code></td>
<td>

<p>The state variance.  A scalar, or vector of length <em>d</em>, or a <em>d</em> x <em>d</em> matrix.  When scalar, <code>Q</code> is constant diagonal.  When a vector, <code>Q</code> is diagonal.
</p>
</td></tr>
<tr><td><code id="SS.stst_+3A_r">R</code></td>
<td>

<p>The measurement variance.  A scalar, or vector of length <em>n</em>, or a <em>n</em> x <em>n</em> matrix.  When scalar, <code>R</code> is constant diagonal.  When a vector, <code>R</code> is diagonal.
</p>
</td></tr>
<tr><td><code id="SS.stst_+3A_p0">P0</code></td>
<td>

<p>Initial <em>a priori</em> prediction error.
</p>
</td></tr>
<tr><td><code id="SS.stst_+3A_epsilon">epsilon</code></td>
<td>

<p>A small scalar number.
</p>
</td></tr>
<tr><td><code id="SS.stst_+3A_verbosity">verbosity</code></td>
<td>

<p>0, 1 or 2.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Note:  The test for convergence has been (very, very slightly) modified since v0.5.1.  The current test has been implemented for rigor.  Users who have results based on earlier releases may observe infinitesimal differences in the resulting prediction error.
</p>


<h3>Value</h3>

<p>A named list.
</p>
<table role = "presentation">
<tr><td><code>P.apri</code></td>
<td>
<p>A <em>d</em> x <em>d</em> matrix giving <em>a priori</em> prediction variance.</p>
</td></tr>
<tr><td><code>P.apos</code></td>
<td>
<p>A <em>d</em> x <em>d</em> matrix giving <em>a posteriori</em> prediction variance.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>H &lt;- matrix(1)

SS.stst(1, H, 1, 1, P0=10^5, epsilon=10^(-14), verbosity=1)
</code></pre>

<hr>
<h2 id='SS.stst.SMW'>
Steady State using the Woodbury matrix identity
</h2><span id='topic+SS.stst.SMW'></span>

<h3>Description</h3>

<p>Find steady state of system, i.e., locate when Kalman gain converges
</p>


<h3>Usage</h3>

<pre><code class='language-R'>SS.stst.SMW(F, H, Q, inv.R, P0, epsilon, verbosity=0)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="SS.stst.SMW_+3A_f">F</code></td>
<td>

<p>The state matrix.  A scalar, or vector of length <em>d</em>, or a <em>d</em> x <em>d</em> matrix.  When scalar, <code>F</code> is constant diagonal.  When a vector, <code>F</code> is diagonal.
</p>
</td></tr>
<tr><td><code id="SS.stst.SMW_+3A_h">H</code></td>
<td>

<p>The measurement matrix.  Must be <em>n</em> x <em>d</em>.
</p>
</td></tr>
<tr><td><code id="SS.stst.SMW_+3A_q">Q</code></td>
<td>

<p>The state variance.  A scalar, or vector of length <em>d</em>, or a <em>d</em> x <em>d</em> matrix.  When scalar, <code>Q</code> is constant diagonal.  When a vector, <code>Q</code> is diagonal.
</p>
</td></tr>
<tr><td><code id="SS.stst.SMW_+3A_inv.r">inv.R</code></td>
<td>

<p>The inverse of the measurement variance.  A scalar, or vector of length <em>n</em>, or a <em>n</em> x <em>n</em> matrix.  When scalar, <code>inv.R</code> is constant diagonal.  When a vector, <code>inv.R</code> is diagonal.
</p>
</td></tr>
<tr><td><code id="SS.stst.SMW_+3A_p0">P0</code></td>
<td>

<p>Initial <em>a priori</em> prediction error.
</p>
</td></tr>
<tr><td><code id="SS.stst.SMW_+3A_epsilon">epsilon</code></td>
<td>

<p>A small scalar number.
</p>
</td></tr>
<tr><td><code id="SS.stst.SMW_+3A_verbosity">verbosity</code></td>
<td>

<p>0, 1 or 2.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Spiritually identical to <code><a href="#topic+SS.stst">SS.stst</a></code>, except that the Woodbury identity is used for inversion.  This method offers a computationally reduced means of finding the system steady state; however, this method must be supplied with the inverse of the measurement variance matrix, R &ndash; not R.  Try comparing the example below with the evivalent example offered for <code><a href="#topic+SS.stst">SS.stst</a></code>.
</p>


<h3>Value</h3>

<p>A named list.
</p>
<table role = "presentation">
<tr><td><code>P.apri</code></td>
<td>
<p>A <em>d</em> x <em>d</em> matrix giving <em>a priori</em> prediction variance.</p>
</td></tr>
<tr><td><code>P.apos</code></td>
<td>
<p>A <em>d</em> x <em>d</em> matrix giving <em>a posteriori</em> prediction variance.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>H &lt;- matrix(1)

SS.stst.SMW(1, H, 1, 1, P0=10^5, epsilon=10^(-14), verbosity=1)
</code></pre>

<hr>
<h2 id='SS.stst.tv'>
Steady State
</h2><span id='topic+SS.stst.tv'></span>

<h3>Description</h3>

<p>Find steady state of time-varying system, i.e., locate when Kalman gain converges
</p>


<h3>Usage</h3>

<pre><code class='language-R'>SS.stst.tv(F, H, Q, R, P0, epsilon, verbosity=0)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="SS.stst.tv_+3A_f">F</code></td>
<td>

<p>A list of <em>d</em> x <em>d</em> matrices.
</p>
</td></tr>
<tr><td><code id="SS.stst.tv_+3A_h">H</code></td>
<td>

<p>A list of <em>n</em> x <em>d</em> matrices.
</p>
</td></tr>
<tr><td><code id="SS.stst.tv_+3A_q">Q</code></td>
<td>

<p>A list of <em>d</em> x <em>d</em> matrices.
</p>
</td></tr>
<tr><td><code id="SS.stst.tv_+3A_r">R</code></td>
<td>

<p>A list of <em>n</em> x <em>n</em> matrices.
</p>
</td></tr>
<tr><td><code id="SS.stst.tv_+3A_p0">P0</code></td>
<td>

<p>Initial <em>a priori</em> prediction error.
</p>
</td></tr>
<tr><td><code id="SS.stst.tv_+3A_epsilon">epsilon</code></td>
<td>

<p>A small scalar number.
</p>
</td></tr>
<tr><td><code id="SS.stst.tv_+3A_verbosity">verbosity</code></td>
<td>

<p>0, 1 or 2.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Note:  The test for convergence has been (very, very slightly) modified since v0.5.1.  The current test has been implemented for rigor.  Users who have results based on earlier releases may observe infinitesimal differences in the resulting prediction error.
</p>


<h3>Value</h3>

<p>A named list.
</p>
<table role = "presentation">
<tr><td><code>P.apri</code></td>
<td>
<p>A <em>d</em> x <em>d</em> matrix giving <em>a priori</em> prediction variance.</p>
</td></tr>
<tr><td><code>P.apos</code></td>
<td>
<p>A <em>d</em> x <em>d</em> matrix giving <em>a posteriori</em> prediction variance.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>F.tv &lt;- list()
for(i in 1:10000) {
	F.tv[[i]] &lt;- diag( c(1/(i+10), 1/(i+10)) )
}

H &lt;- matrix(1, 2, 2)

SS.stst.tv(F.tv, H, 1, 1, 10^5, 10^(-10), verbosity=2)
</code></pre>

<hr>
<h2 id='SSsimple-internal'>Internal SSsimple objects</h2><span id='topic+internal.chk.mod.params'></span><span id='topic+internal.chk.mod.params.short'></span>

<h3>Description</h3>

<p>Internal SSsimple objects.</p>


<h3>Details</h3>

<p>These are not to be called by the user.</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
