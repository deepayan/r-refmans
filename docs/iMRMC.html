<!DOCTYPE html><html lang="en"><head><title>Help for package iMRMC</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {iMRMC}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#convertDFtoDesignMatrix'><p>Convert an MRMC data frame to a design matrix</p></a></li>
<li><a href='#convertDFtoScoreMatrix'><p>Convert an MRMC data frame to a score matrix</p></a></li>
<li><a href='#createGroups'><p>Assign a group label to items in a vector</p></a></li>
<li><a href='#createIMRMCdf'><p>Convert a data frame with all needed factors to doIMRMC formatted data frame</p></a></li>
<li><a href='#deleteCol'><p>Delete a data frame column</p></a></li>
<li><a href='#dfMRMC_example'><p>Example of iMRMC formatted data frame</p></a></li>
<li><a href='#doAUCmrmc'><p>MRMC analysis for arbitrary design dataset</p></a></li>
<li><a href='#doIMRMC'><p>MRMC analysis for arbitrary design dataset</p></a></li>
<li><a href='#doIMRMC_java'><p>MRMC analysis of the area under the ROC curve</p></a></li>
<li><a href='#doROCavg'><p>Empirically average over multiple empirical ROC curves</p></a></li>
<li><a href='#doROCcurveMRMC'><p>Create a standard set of ROC curves from an MRMC data frame</p></a></li>
<li><a href='#doROCxy'><p>Create empirical ROC curve</p></a></li>
<li><a href='#doROCxyMRMC'><p>Create empirical ROC curve from an MRMC formatted data frame</p></a></li>
<li><a href='#extractPairedComparisonsBRBM'><p>Extract between-reader between-modality pairs of scores</p></a></li>
<li><a href='#extractPairedComparisonsWRBM'><p>Extract within-reader between-modality pairs of scores</p></a></li>
<li><a href='#getBRBM'><p>Get between-reader, between-modality paired data from an MRMC data frame</p></a></li>
<li><a href='#getMRMCdataset'><p>Import MRMC dataset from the web (https://github.com/DIDSR/iMRMC/wiki/iMRMC-Datasets)</p></a></li>
<li><a href='#getMRMCscore'><p>Get a score from an MRMC data frame</p></a></li>
<li><a href='#getWRBM'><p>Get within-reader, between-modality paired data from an MRMC data frame</p></a></li>
<li><a href='#init.lecuyerRNG'><p>Initialize the l'Ecuyer random number generator</p></a></li>
<li><a href='#limitsOfAgreement'><p>MRMC Analysis of Limits of Agreement using ANOVA</p></a></li>
<li><a href='#renameCol'><p>Rename a data frame column name or a list object name</p></a></li>
<li><a href='#roc2binary'><p>Convert ROC data formatted for doIMRMC to TPF and FPF data formatted for doIMRMC</p></a></li>
<li><a href='#roeMetzConfigs'><p>roeMetzConfigs</p></a></li>
<li><a href='#sim.gRoeMetz'><p>Simulate an MRMC data set of an ROC experiment comparing two modalities</p></a></li>
<li><a href='#sim.gRoeMetz.config'><p>Create a configuration object for the sim.gRoeMetz program</p></a></li>
<li><a href='#sim.NormalIG.Hierarchical'><p>Simulate an MRMC data set comparing two modalities by a hierarchical model</p></a></li>
<li><a href='#sim.NormalIG.Hierarchical.config'><p>Create a configuration object for the sim.NormalIG.Hierarchical function</p></a></li>
<li><a href='#simMRMC'><p>Simulate an MRMC data set</p></a></li>
<li><a href='#simRoeMetz.example'><p>Simulates a sample MRMC ROC experiment</p></a></li>
<li><a href='#successDFtoROCdf'><p>Convert an MRMC data frame of successes to one formatted for doIMRMC</p></a></li>
<li><a href='#undoIMRMCdf'><p>Convert a doIMRMC formatted data frame to a standard data frame</p>
with all factors.</a></li>
<li><a href='#uStat11'><p>Analysis of U-statistics degree 1,1</p></a></li>
<li><a href='#uStat11.diff'><p>Create the kernel and design matrices for uStat11</p></a></li>
<li><a href='#uStat11.identity'><p>Create the kernel and design matrices for uStat11</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Multi-Reader, Multi-Case Analysis Methods (ROC, Agreement, and
Other Metrics)</td>
</tr>
<tr>
<td>Version:</td>
<td>2.1.0</td>
</tr>
<tr>
<td>Description:</td>
<td>This software does Multi-Reader, Multi-Case (MRMC) analyses of data from imaging studies where clinicians (readers) evaluate patient images (cases). What does this mean? ... Many imaging studies are designed so that every reader reads every case in all modalities, a fully-crossed study. In this case, the data is cross-correlated, and we consider the readers and cases to be cross-correlated random effects. An MRMC analysis accounts for the variability and correlations from the readers and cases when estimating variances, confidence intervals, and p-values. The functions in this package can treat arbitrary study designs and studies with missing data, not just fully-crossed study designs. An overview of this software, including references presenting details on the methods, can be found here: <a href="https://www.fda.gov/medical-devices/science-and-research-medical-devices/imrmc-software-do-multi-reader-multi-case-statistical-analysis-reader-studies">https://www.fda.gov/medical-devices/science-and-research-medical-devices/imrmc-software-do-multi-reader-multi-case-statistical-analysis-reader-studies</a>.</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/DIDSR/iMRMC">https://github.com/DIDSR/iMRMC</a>,
<a href="https://CRAN.R-project.org/package=iMRMC">https://CRAN.R-project.org/package=iMRMC</a></td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://creativecommons.org/publicdomain/zero/1.0/legalcode">CC0</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.5.0)</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.3.2</td>
</tr>
<tr>
<td>Imports:</td>
<td>parallel, Matrix, stats, utils</td>
</tr>
<tr>
<td>Suggests:</td>
<td>testthat</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-09-02 14:42:26 UTC; BDG</td>
</tr>
<tr>
<td>Author:</td>
<td>Brandon Gallas [aut, cre]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Brandon Gallas &lt;Brandon.Gallas@fda.hhs.gov&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-09-02 15:10:01 UTC</td>
</tr>
</table>
<hr>
<h2 id='convertDFtoDesignMatrix'>Convert an MRMC data frame to a design matrix</h2><span id='topic+convertDFtoDesignMatrix'></span>

<h3>Description</h3>

<p>Convert an MRMC data frame to a design matrix, dropping readers or cases with no observations
</p>


<h3>Usage</h3>

<pre><code class='language-R'>convertDFtoDesignMatrix(dfMRMC, modality = NULL, dropFlag = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="convertDFtoDesignMatrix_+3A_dfmrmc">dfMRMC</code></td>
<td>
<p>An MRMC data frame</p>
</td></tr>
<tr><td><code id="convertDFtoDesignMatrix_+3A_modality">modality</code></td>
<td>
<p>The score matrix depends on the modality.
If more than one modality exists in the data frame,
you must specify which modality to subset.</p>
</td></tr>
<tr><td><code id="convertDFtoDesignMatrix_+3A_dropflag">dropFlag</code></td>
<td>
<p>[logical] The default setting (TRUE) removes readers and cases
that have no observations. Dropping them by default will speed up analyses.
Leaving the levels (dropFlag = FALSE) is useful if you need the entire score
or design matrix when comparing or doing analyses with two modalities.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix that is <em>nCases</em> by <em>nReaders</em> indicating which scores were reported for each reader and case
</p>

<hr>
<h2 id='convertDFtoScoreMatrix'>Convert an MRMC data frame to a score matrix</h2><span id='topic+convertDFtoScoreMatrix'></span>

<h3>Description</h3>

<p>Convert an MRMC data frame to a score matrix, dropping readers or cases with no observations
</p>


<h3>Usage</h3>

<pre><code class='language-R'>convertDFtoScoreMatrix(dfMRMC, modality = NULL, dropFlag = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="convertDFtoScoreMatrix_+3A_dfmrmc">dfMRMC</code></td>
<td>
<p>An MRMC data frame</p>
</td></tr>
<tr><td><code id="convertDFtoScoreMatrix_+3A_modality">modality</code></td>
<td>
<p>The score matrix depends on the modality.
If more than one modality exists in the data frame,
you must specify which modality to subset.</p>
</td></tr>
<tr><td><code id="convertDFtoScoreMatrix_+3A_dropflag">dropFlag</code></td>
<td>
<p>[logical] The default setting (TRUE) removes readers and cases
that have no observations. Dropping them by default will speed up analyses.
Leaving the levels (dropFlag = FALSE) is useful if you need the entire score
or design matrix when comparing or doing analyses with two modalities.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix that is <em>nCases</em> by <em>nReaders</em> of the scores each reader reported for each case
</p>

<hr>
<h2 id='createGroups'>Assign a group label to items in a vector</h2><span id='topic+createGroups'></span>

<h3>Description</h3>

<p>Assign a group label to items in a vector
</p>


<h3>Usage</h3>

<pre><code class='language-R'>createGroups(items, nG)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="createGroups_+3A_items">items</code></td>
<td>
<p>A vector of items</p>
</td></tr>
<tr><td><code id="createGroups_+3A_ng">nG</code></td>
<td>
<p>The number of groups</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data frame containing the items and their group labels
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- paste("item", 1:10, sep = "")
df &lt;- createGroups(x, 3)
print(df)

</code></pre>

<hr>
<h2 id='createIMRMCdf'>Convert a data frame with all needed factors to doIMRMC formatted data frame</h2><span id='topic+createIMRMCdf'></span>

<h3>Description</h3>

<p>Convert a data frame with all needed factors to doIMRMC formatted data frame
</p>


<h3>Usage</h3>

<pre><code class='language-R'>createIMRMCdf(
  dFrame,
  keyColumns = list(readerID = "readerID", caseID = "caseID", modalityID = "modalityID",
    score = "score", truth = "truth"),
  truePositiveFactor = "cancer"
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="createIMRMCdf_+3A_dframe">dFrame</code></td>
<td>
<p>This data frame includes columns for readerID, caseID, modalityID, score, and truth.
These columns are not expected to be named as such and other columns may exist.</p>
</td></tr>
<tr><td><code id="createIMRMCdf_+3A_keycolumns">keyColumns</code></td>
<td>
<p>This list identifies the column names of the data frame to be used for the analysis.
list(readerID = &quot;***&quot;, caseID = &quot;***&quot;, modalityID = &quot;***&quot;, score = &quot;***&quot;, truth=&quot;***&quot;)</p>
</td></tr>
<tr><td><code id="createIMRMCdf_+3A_truepositivefactor">truePositiveFactor</code></td>
<td>
<p>The true positive label, such as &quot;cancer&quot; or &quot;1&quot;</p>
</td></tr>
</table>


<h3>Value</h3>

<p>output a doIMRMC formatted data frame: rows for truth and rows for data.
The results will be an iMRMC formatted data frame, see <a href="#topic+dfMRMC_example">dfMRMC_example</a>
</p>

<hr>
<h2 id='deleteCol'>Delete a data frame column</h2><span id='topic+deleteCol'></span>

<h3>Description</h3>

<p>Delete a data frame column
</p>


<h3>Usage</h3>

<pre><code class='language-R'>deleteCol(df, colName)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="deleteCol_+3A_df">df</code></td>
<td>
<p>A data frame</p>
</td></tr>
<tr><td><code id="deleteCol_+3A_colname">colName</code></td>
<td>
<p>Column name or list of column names to be deleted</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The data frame without the deleted column or columns
</p>

<hr>
<h2 id='dfMRMC_example'>Example of iMRMC formatted data frame</h2><span id='topic+dfMRMC_example'></span>

<h3>Description</h3>

<p>An example data frame formatted for 'doIMRMC' and other iMRMC functions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dfMRMC_example
</code></pre>


<h3>Format</h3>

<p>A data frame with 880 rows and 4 columns:
</p>

<dl>
<dt>readerID</dt><dd><p>Factor with 5 levels like &quot;reader1&quot;, &quot;reader2&quot;, ...
As well as the special reader &quot;truth&quot;
</p>
</dd>
<dt>caseID</dt><dd><p>Factor with 80 levels like &quot;case1&quot;, &quot;case2&quot;, ...</p>
</dd>
<dt>modalityID</dt><dd><p>Factor with 2 levels like &quot;modality1&quot;, &quot;modality2&quot;, ...
As well as the special modality &quot;truth&quot;
</p>
</dd>
<dt>score</dt><dd><p>Numeric reader score</p>
</dd>
</dl>

<p>Each row of this data frame corresponds to an observation. For every caseID, 
there must be a row corresponding to the truth observation. The readerID for 
a truth observation is &quot;truth&quot;. The modalityID for a truth observation is 
&quot;truth&quot;. The score for a truth observation must be either 0 (signal-absent) 
or 1 (signal-present).
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Create a sample configuration file
config &lt;- sim.gRoeMetz.config()
# Simulate an MRMC ROC data set
dfMRMC_example &lt;- sim.gRoeMetz(config)
# Analyze the MRMC ROC data
result &lt;- doIMRMC(dfMRMC_example)

</code></pre>

<hr>
<h2 id='doAUCmrmc'>MRMC analysis for arbitrary design dataset</h2><span id='topic+doAUCmrmc'></span>

<h3>Description</h3>

<p>Execute a Multi-Reader, Multi-Case (MRMC) analysis
of ROC data from imaging studies where clinicians (readers) evaluate patient
images (cases). An overview of this software, including references presenting
details on the methods, can be found <a href="https://zenodo.org/record/8383591">HERE</a>
or as an entry in the FDA/CDRH Regulatory Science Tool Catalog
<a href="https://www.fda.gov/medical-devices/science-and-research-medical-devices/imrmc-software-do-multi-reader-multi-case-statistical-analysis-reader-studies">HERE</a>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>doAUCmrmc(data, flagROC = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="doAUCmrmc_+3A_data">data</code></td>
<td>
<p>an iMRMC formatted data frame, see <a href="#topic+dfMRMC_example">dfMRMC_example</a></p>
</td></tr>
<tr><td><code id="doAUCmrmc_+3A_flagroc">flagROC</code></td>
<td>
<p>boolean indicating if ROC results should be computed.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The MRMC analysis results as a list, below is a quick summary:
</p>

<ul>
<li> <p><code>summaryMRMC, list</code>
a list of summary study design information.
</p>

<ul>
<li> <p><code>nM, num</code> number of modalities
</p>
</li>
<li> <p><code>nR, num</code> number of readers
</p>
</li>
<li> <p><code>nC.neg, num</code> number of signal-present caeses
</p>
</li>
<li> <p><code>nC.pos, num</code> number of signal-absent cases
</p>
</li>
<li> <p><code>modalites, char</code> names of modalities
</p>
</li>
<li> <p><code>readers, char</code> names of modalities
</p>
</li>
<li> <p><code>cases.neg, char</code> names of modalities
</p>
</li>
<li> <p><code>cases.pos, char</code> names of modalities
</p>
</li></ul>


</li>
<li> <p><code>perReader.full, data.frame</code>
this data frame contains the performance results for each reader and modality comparison.
The analysis returns the final AUC results and the moments, coefficients of those moments. 
Key variables of this data frame are AUC.1 (where '.1' indicates the row's reader and 
modality '.1' pair), AUC.2 ('.2' indicates the '.2' reader and modality pair), and covAUC.
</p>
</li>
<li> <p><code>Ustat.full, data.frame</code>
this data frame contains the reader-average AUC performance results.
The analysis results are based on U-statistics.
Key variables of this data frame are AUC.1, AUC.2, AUC1minusAUC2 and the corresponding
variances, confidence intervals, degrees of freedom and p-values.
</p>
</li>
<li> <p><code>ROC, list</code>
each object of this list is an object containing an ROC curve.
There is an ROC curve for every combination of reader and modality.
For every modality, there are also four average ROC curves. These are discussed in
Chen2014_Br-J-Radiol_v87p20140016.
The diagonal average averages the reader-specific ROC curves along y = -x + b for b in (0,1).
The horizontal average averages the reader specific ROC curves along y = b for b in (0,1).
The vertical average averages the reader specific ROC curves along x = b for b in (0,1).
The pooled average ignores readerID and pools all the scores together to create one ROC curve.

</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'># Create a sample configuration file
config &lt;- sim.gRoeMetz.config()
# Simulate an MRMC ROC data set
dFrame.imrmc &lt;- sim.gRoeMetz(config)
# Analyze the MRMC ROC data and compute ROC curves
aucResult &lt;- doAUCmrmc(dFrame.imrmc, flagROC = TRUE)


</code></pre>

<hr>
<h2 id='doIMRMC'>MRMC analysis for arbitrary design dataset</h2><span id='topic+doIMRMC'></span>

<h3>Description</h3>

<p>Execute a Multi-Reader, Multi-Case (MRMC) analysis
of ROC data from imaging studies where clinicians (readers) evaluate patient
images (cases). This function is a wrapper that executes 
<code><a href="#topic+doAUCmrmc">doAUCmrmc</a></code> and formats the output to generally match the output of 
<code>doIMRMC</code> version 1.2.5.
An overview of this software, including references presenting
details on the methods, can be found <a href="https://zenodo.org/record/8383591">HERE</a>
or as an entry in the FDA/CDRH Regulatory Science Tool Catalog
<a href="https://www.fda.gov/medical-devices/science-and-research-medical-devices/imrmc-software-do-multi-reader-multi-case-statistical-analysis-reader-studies">HERE</a>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>doIMRMC(data)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="doIMRMC_+3A_data">data</code></td>
<td>
<p>an iMRMC formatted data frame, see <a href="#topic+dfMRMC_example">dfMRMC_example</a></p>
</td></tr>
</table>


<h3>Details</h3>

<p>Unlike the legacy <code><a href="#topic+doIMRMC_java">doIMRMC_java</a></code>, the 'varDecomp' results no 
longer scale the covariance by a factor of 2. This scaling is needed when 
calculating the total variance of the difference in modalities. The user 
must scale this covariance by 2 manually now to achieve the total variance
of the difference in modalities result.
</p>


<h3>Value</h3>

<p>The MRMC analysis results, below is a quick summary:
</p>

<ul>
<li> <p><code>perReader, data.frame</code> 
The performance results for each combination of reader and pair of modalities.
Key variables of this data frame are AUCA, AUCB, AUCAminusAUCB
and the corresponding variances.
When the modalities differ, the variance is understood to be the covariance between the modalities.

</p>
</li>
<li> <p><code>Ustat, data.frame</code>
Reader-averaged performance results for each pair of modalities.
The analysis results are based on U-statistics.
Key variables of this data frame are AUCA, AUCB, 
AUCAminusAUCB and the corresponding variances, 
confidence intervals, degrees of freedom, and p-values.
When the modalities differ, the variance is understood to be the covariance between the modalities.

</p>
</li>
<li> <p><code>MLEstat, data.frame</code>
Reader-average performance results for each pair of modalities.
The analysis results are based on V-statistics, which 
approximates the true distribution with
the empirical distribution. The empirical distribution equals 
the nonparametric MLE
estimate of the true distribution, which is also equivalent 
to the ideal bootstrap estimate.
Key variables of this data frame are AUCA, AUCB, 
AUCAminusAUCB and the corresponding
variances, confidence intervals, degrees of freedom, and p-values.
When the modalities differ, the variance is understood to be the covariance between the modalities.

</p>
</li>
<li> <p><code>varDecomp, list</code>
list of data frames of the coefficient and components of 
variance. The analysis includes variance decomposition based off both the 
BDG and BCK MRMC methods, and Ustat and MLE statistical methods. 
Each MRMC and statistical method combination is contained within this 
list of lists. 

</p>
</li>
<li> <p><code>ROC, list</code>
each object of this list is an object containing an ROC curve.
There is an ROC curve for every combination of reader and modality.
For every modality, there are also four average ROC curves. 
These are discussed in Chen2014_Br-J-Radiol_v87p20140016.
The diagonal average averages the reader-specific ROC curves 
along y = -x + b for b in (0,1).
The horizontal average averages the reader specific ROC curves 
along y = b for b in (0,1).
The vertical average averages the reader specific ROC curves 
along x = b for b in (0,1).
The pooled average ignores readerID and pools all the scores 
together to create one ROC curve.
</p>
</li>
<li> <p><code>full, list</code>
This returns the same result as <code><a href="#topic+doAUCmrmc">doAUCmrmc</a></code>.

</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'># Create a sample configuration file
config &lt;- sim.gRoeMetz.config()
# Simulate an MRMC ROC data set
dFrame.imrmc &lt;- sim.gRoeMetz(config)
# Analyze the MRMC ROC data
result &lt;- doIMRMC(dFrame.imrmc)

</code></pre>

<hr>
<h2 id='doIMRMC_java'>MRMC analysis of the area under the ROC curve</h2><span id='topic+doIMRMC_java'></span>

<h3>Description</h3>

<p>doIMRMC_java takes ROC data as a data frame and runs a multi-reader multi-case analysis
based on U-statistics as described in the following papers
Gallas2006_Acad-Radiol_v13p353 (single-modality),
Gallas2008_Neural-Networks_v21p387 (multiple modalities, arbitrary study designs),
Gallas2009_Commun-Stat-A-Theor_v38p2586 (framework paper). This function is deprecated, please use <code><a href="#topic+doIMRMC">doIMRMC</a></code> instead.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>doIMRMC_java(
  data = NULL,
  fileName = NULL,
  workDir = NULL,
  iMRMCjarFullPath = NULL,
  stripDatesForTests = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="doIMRMC_java_+3A_data">data</code></td>
<td>
<p>an iMRMC formatted data frame, see <a href="#topic+dfMRMC_example">dfMRMC_example</a></p>
</td></tr>
<tr><td><code id="doIMRMC_java_+3A_filename">fileName</code></td>
<td>
<p>This character string identifies the location of an iMRMC input file.
The input file is identical to data except there is a free text section to start,
then a line with &quot;BEGIN DATA:&quot;, then the data frame info.</p>
</td></tr>
<tr><td><code id="doIMRMC_java_+3A_workdir">workDir</code></td>
<td>
<p>This character string determines the directory where intermediate results
are written. If this parameter is not set, the program writes the intermediate
results to the directory specified by tempdir() and then deletes them.</p>
</td></tr>
<tr><td><code id="doIMRMC_java_+3A_imrmcjarfullpath">iMRMCjarFullPath</code></td>
<td>
<p>This character string identifies the location of the iMRMC.jar file
this jar file can be downloaded from https://github.com/DIDSR/iMRMC/releases
this R program supports version iMRMC-v3p2.jar</p>
</td></tr>
<tr><td><code id="doIMRMC_java_+3A_stripdatesfortests">stripDatesForTests</code></td>
<td>
<p>Since results include a date and time stamp, these need to be
stripped out when doing the package tests. This parameter flags whether or not
the dates should be stripped out.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>In detail, this procedure reads the name of an input file from the local file system,
or takes a data frame and writes it to the local file system formatted
for the iMRMC program (found at https://github.com/DIDSR/iMRMC/releases), it executes a java app,
the iMRMC engine, which writes the results to the local files system, it reads the analysis results from
the local file system, packs the analysis results into a list object, deletes the data and analysis results
from the local file system, and returns the list object.
</p>
<p>This software requires Java(&gt;=8).
</p>
<p>The examples took too long for CRAN to accept. So here is an example: 
</p>
<pre>
# Create a sample configuration file
config &lt;- sim.gRoeMetz.config()
# Simulate an MRMC ROC data set
dFrame.imrmc &lt;- sim.gRoeMetz(config)
# Analyze the MRMC ROC data
result &lt;- doIMRMC_java(dFrame.imrmc)
</pre>


<h3>Value</h3>

<p>[list] 
iMRMC outputs. The objects of this list are described in detail in the iMRMC documentation
which can be found at &lt;http://didsr.github.io/iMRMC/000_iMRMC/userManualHTML/index.htm&gt;
</p>
<p>Here is a quick summary:
</p>

<ul>
<li> <p><code>perReader</code> 
data.frame containing the performance results for each reader.
Key variables of this data frame are AUCA, AUCB, AUCAminusAUCB and the corresponding
variances, confidence intervals, degrees of freedom and p-values.
</p>
</li>
<li> <p><code>Ustat</code>
data.frame containing the reader-average performance results.
The analysis results are based on U-statistics and the papers listed above.
Key variables of this data frame are AUCA, AUCB, AUCAminusAUCB and the corresponding
variances, confidence intervals, degrees of freedom and p-values.
</p>
</li>
<li> <p><code>MLEstat</code>
data.frame containing the reader-average performance results.
The analysis results are based on V-statistics, which approximates the true distribution with
the empirical distribution. The empirical distribution equals the nonparametric MLE
estimate of the true distribution, which is also equivalent to the ideal bootstrap estimate.
Please refer to the papers listed above.
Key variables of this data frame are AUCA, AUCB, AUCAminusAUCB and the corresponding
variances, confidence intervals, degrees of freedom and p-values.

</p>
</li>
<li> <p><code>ROC</code>
list containing ROC curves
There is an ROC curve for every combination of reader and modality.
For every modality, there are also four average ROC curves. These are discussed in
Chen2014_Br-J-Radiol_v87p20140016.
The diagonal average averages the reader-specific ROC curves along y = -x + b for b in (0,1).
The horizontal average averages the reader specific ROC curves along y = b for b in (0,1).
The vertical average averages the reader specific ROC curves along x = b for b in (0,1).
The pooled average ignores readerID and pools all the scores together to create one ROC curve.
</p>
</li>
<li> <p><code>varDecomp</code>
list containing different decompositions of the total variance.
Please refer to Gallas2009_Commun-Stat-A-Theor_v38p2586 (framework paper).
The different decompositions are BCK, BDG, DBM, MS, OR.

</p>
</li></ul>


<hr>
<h2 id='doROCavg'>Empirically average over multiple empirical ROC curves</h2><span id='topic+doROCavg'></span>

<h3>Description</h3>

<p>Empirically average over multiple empirical ROC curves
</p>


<h3>Usage</h3>

<pre><code class='language-R'>doROCavg(ROC, direction = "SeSp")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="doROCavg_+3A_roc">ROC</code></td>
<td>
<p>list of ROC curves. Each element of the list
is a data frame with pairs of (fpf, tpf) operating points.</p>
</td></tr>
<tr><td><code id="doROCavg_+3A_direction">direction</code></td>
<td>
<p>the direction over which to average
</p>

<ul>
<li><p><code>SeSp</code> (default) The ROC curves are averaged diagonally.
Average Se+Sp of all the input ROC curves
for every possible Se-Sp.
</p>
</li>
<li><p><code>Se</code> The ROC curves are averaged vertically.
Average the sensitivity of all the input ROC curves
for every possible specificity.
</p>
</li>
<li><p><code>Sp</code> The ROC curves are averaged horizontally.
Average the specificity of all the input ROC curves
for every possible specificity.
</p>
</li></ul>
</td></tr>
</table>


<h3>Value</h3>

<p>data frame of an ROC curve
</p>

<ul>
<li><p><code>fpf</code> False-positive fractions (1-specificity)
</p>
</li>
<li><p><code>tpf</code> True-positive fractions (sensitivity)
</p>
</li></ul>


<hr>
<h2 id='doROCcurveMRMC'>Create a standard set of ROC curves from an MRMC data frame</h2><span id='topic+doROCcurveMRMC'></span>

<h3>Description</h3>

<p>Create a standard set of ROC curves from an MRMC data frame
</p>


<h3>Usage</h3>

<pre><code class='language-R'>doROCcurveMRMC(mrmcAlternate)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="doROCcurveMRMC_+3A_mrmcalternate">mrmcAlternate</code></td>
<td>
<p>data frame
</p>

<ul>
<li><p><code>readerID</code>
</p>
</li>
<li><p><code>caseID</code>
</p>
</li>
<li><p><code>modalityID</code>
</p>
</li>
<li><p><code>score</code>
</p>
</li>
<li><p><code>truthLabel</code>
</p>
</li></ul>
</td></tr>
</table>


<h3>Value</h3>

<p>list of ROC curves corresponding to
all reader x modality combinations,
all modalities with the reader scores pooled,
all modalities with the per-reader ROC curves, horizontally, diagonally, 
and vertically averaged.
</p>

<hr>
<h2 id='doROCxy'>Create empirical ROC curve</h2><span id='topic+doROCxy'></span>

<h3>Description</h3>

<p>Create empirical ROC curve
</p>


<h3>Usage</h3>

<pre><code class='language-R'>doROCxy(sa, sp)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="doROCxy_+3A_sa">sa</code></td>
<td>
<p>signal-absent scores</p>
</td></tr>
<tr><td><code id="doROCxy_+3A_sp">sp</code></td>
<td>
<p>signal-present scores</p>
</td></tr>
</table>


<h3>Value</h3>

<p>data frame of an ROC curve
</p>

<ul>
<li><p><code>fpf</code> False-positive fractions (1-specificity)
</p>
</li>
<li><p><code>tpf</code> True-positive fractions (sensitivity)
</p>
</li>
<li><p><code>threshold</code> Threshold corresponding to each fpf, tpf
operating point
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'># Create a sample configuration file
config &lt;- sim.gRoeMetz.config()
# Simulate an MRMC ROC data set
dFrame.imrmc &lt;- sim.gRoeMetz(config)
# Isolate signal absent scores
indexSA &lt;- grep("negCase", dFrame.imrmc$caseID)
sa &lt;- dFrame.imrmc[indexSA, ]$score
# Isolate signal present scores
indexSP &lt;- grep("posCase", dFrame.imrmc$caseID)
sp &lt;- dFrame.imrmc[indexSP, ]$score
# Compute empirical ROC curve
result &lt;- doROCxy(sa, sp)
</code></pre>

<hr>
<h2 id='doROCxyMRMC'>Create empirical ROC curve from an MRMC formatted data frame</h2><span id='topic+doROCxyMRMC'></span>

<h3>Description</h3>

<p>Create empirical ROC curve from an MRMC formatted data frame
</p>


<h3>Usage</h3>

<pre><code class='language-R'>doROCxyMRMC(mrmcAlternate)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="doROCxyMRMC_+3A_mrmcalternate">mrmcAlternate</code></td>
<td>
<p>data frame
</p>

<ul>
<li><p><code>readerID</code>
</p>
</li>
<li><p><code>caseID</code>
</p>
</li>
<li><p><code>modalityID</code>
</p>
</li>
<li><p><code>score</code>
</p>
</li>
<li><p><code>truthLabel</code>
</p>
</li></ul>
</td></tr>
</table>


<h3>Value</h3>

<p>data frame of an ROC curve
</p>

<ul>
<li><p><code>modalityID</code>
</p>
</li>
<li><p><code>readerID</code>
</p>
</li>
<li><p><code>fpf</code> False-positive fractions (1-specificity)
</p>
</li>
<li><p><code>tpf</code> True-positive fractions (sensitivity)
</p>
</li>
<li><p><code>threshold</code> Threshold corresponding to each fpf, tpf
</p>
</li></ul>


<hr>
<h2 id='extractPairedComparisonsBRBM'>Extract between-reader between-modality pairs of scores</h2><span id='topic+extractPairedComparisonsBRBM'></span>

<h3>Description</h3>

<p>Extract between-reader between-modality pairs of scores
</p>


<h3>Usage</h3>

<pre><code class='language-R'>extractPairedComparisonsBRBM(
  data0,
  modalities = c("testA", "testB"),
  keyColumns = list(readerID = "readerID", caseID = "caseID", modalityID = "modalityID",
    score = "score")
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="extractPairedComparisonsBRBM_+3A_data0">data0</code></td>
<td>
<p>This data frame includes columns for readerID, caseID, modalityID, score.</p>
</td></tr>
<tr><td><code id="extractPairedComparisonsBRBM_+3A_modalities">modalities</code></td>
<td>
<p>The modalities (testA, testB) for the scores to be paired</p>
</td></tr>
<tr><td><code id="extractPairedComparisonsBRBM_+3A_keycolumns">keyColumns</code></td>
<td>
<p>This list identifies the column names
of the data frame to be used for the analysis.
list(readerID = &quot;***&quot;, caseID = &quot;***&quot;,
modalityID = &quot;***&quot;, score = &quot;***&quot;, truth=&quot;***&quot;)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data frame of all paired observations.
Each observation comes from a pair of readers evaluating a case in two modalities.
The first column corresponds to one reader evaluating the case in testA.
The second column corresonds to the other reader evaluating the case in testB.
</p>

<hr>
<h2 id='extractPairedComparisonsWRBM'>Extract within-reader between-modality pairs of scores</h2><span id='topic+extractPairedComparisonsWRBM'></span>

<h3>Description</h3>

<p>Extract within-reader between-modality pairs of scores
</p>


<h3>Usage</h3>

<pre><code class='language-R'>extractPairedComparisonsWRBM(
  data0,
  modalities = "testA",
  keyColumns = list(readerID = "readerID", caseID = "caseID", modalityID = "modalityID",
    score = "score")
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="extractPairedComparisonsWRBM_+3A_data0">data0</code></td>
<td>
<p>This data frame includes columns for readerID, caseID, modalityID, score.</p>
</td></tr>
<tr><td><code id="extractPairedComparisonsWRBM_+3A_modalities">modalities</code></td>
<td>
<p>The modalities (testA, testB) for the scores to be paired</p>
</td></tr>
<tr><td><code id="extractPairedComparisonsWRBM_+3A_keycolumns">keyColumns</code></td>
<td>
<p>This list identifies the column names
of the data frame to be used for the analysis.
list(readerID = &quot;***&quot;, caseID = &quot;***&quot;,
modalityID = &quot;***&quot;, score = &quot;***&quot;, truth=&quot;***&quot;)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data frame of all paired observations.
Each observation comes from a one reader evaluating a case in two modalities
The first column corresponds to one reader evaluating the case in &quot;testA&quot;.
The second column corresonds to the same reader evaluating the case in &quot;testB&quot;.
</p>

<hr>
<h2 id='getBRBM'>Get between-reader, between-modality paired data from an MRMC data frame</h2><span id='topic+getBRBM'></span>

<h3>Description</h3>

<p>Get between-reader, between-modality paired data from an MRMC data frame
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getBRBM(mcsData, modality.X, modality.Y)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="getBRBM_+3A_mcsdata">mcsData</code></td>
<td>
<p>A data frame with the following columns: readerID, caseID, modalityID, score</p>
</td></tr>
<tr><td><code id="getBRBM_+3A_modality.x">modality.X</code></td>
<td>
<p>The name of one modality</p>
</td></tr>
<tr><td><code id="getBRBM_+3A_modality.y">modality.Y</code></td>
<td>
<p>The name of one modality.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If modality.Y = modality.X, then the data would be between-reader, within-modality (BRWM).
</p>


<h3>Value</h3>

<p>The result of merging the modality.X and modality.Y subsets of mcsData by caseID
for every pair of readers
</p>

<hr>
<h2 id='getMRMCdataset'>Import MRMC dataset from the web (https://github.com/DIDSR/iMRMC/wiki/iMRMC-Datasets)</h2><span id='topic+getMRMCdataset'></span>

<h3>Description</h3>

<p>Import MRMC dataset from the web (https://github.com/DIDSR/iMRMC/wiki/iMRMC-Datasets)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getMRMCdataset(dataset = "viperObs")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="getMRMCdataset_+3A_dataset">dataset</code></td>
<td>
<p>Possible dataset options available:
</p>

<ul>
<li> <p><strong>pilotHTT</strong>: Breast cancer annotation data that is the aggregate of all clean data from the HTT project pilot study. https://github.com/DIDSR/HTT
</p>
</li>
<li> <p><strong>viperObs</strong>: Individual observations of each reader reading each case from the FDA Validation of Imaging Premarket Evaluation and Regulation (VIPER) Study. https://github.com/DIDSR/viperData
</p>
</li>
<li> <p><strong>viperObs365</strong>: Individual observations of each reader reading each case from the FDA Validation of Imaging Premarket Evaluation and Regulation (VIPER) Study, truth is based on cancer status at 365 days. https://github.com/DIDSR/viperData
</p>
</li>
<li> <p><strong>viperObs455</strong>: Individual observations of each reader reading each case from the FDA Validation of Imaging Premarket Evaluation and Regulation (VIPER) Study, truth is based on cancer status at 455 days. https://github.com/DIDSR/viperData
</p>
</li>
<li> <p><strong>MFcounts_dfClassify</strong>: A data frame comparing mitotic figure counting performance based on whole slide images (WSI images) from four scanners to the counts from a microscope, data is per  candidate mitotic figure and modality. https://github.com/DIDSR/mitoticFigureCounts/tree/master
</p>
</li>
<li> <p><strong>MFcounts_dfCountROI</strong>: A data frame comparing mitotic figure counting performance based on whole slide images (WSI images) from four scanners to the counts from a microscope, data is per ROI and modality. https://github.com/DIDSR/mitoticFigureCounts/tree/master
</p>
</li>
<li> <p><strong>MFcounts_dfCountWSI</strong>: A data frame comparing mitotic figure counting performance based on whole slide images (WSI images) from four scanners to the counts from a microscope, data is per WSI and modality. https://github.com/DIDSR/mitoticFigureCounts/tree/master
</p>
</li>
<li> <p><strong>cardioStudyTruth</strong>: Cardio CT data comparing display color scale effects on diagnostic performance and reader agreement, ground truth data. https://github.com/DIDSR/colorScaleStudyData
</p>
</li>
<li> <p><strong>cardioStudyRawData</strong>: Cardio CT data comparing display color scale effects on diagnostic performance and reader agreement, reader data. https://github.com/DIDSR/colorScaleStudyData
</p>
</li>
<li> <p><strong>prostateTruth</strong>: Prostate MRI data comparing display color scale effects on diagnostic performance and reader agreement, ground truth data. https://github.com/DIDSR/colorScaleStudyData
</p>
</li>
<li> <p><strong>prostateRawData</strong>: Prostate MRI data comparing display color scale effects on diagnostic performance and reader agreement, reader data. https://github.com/DIDSR/colorScaleStudyData
</p>
</li></ul>
</td></tr>
</table>


<h3>Value</h3>

<p>desired dataset downloaded from the web as a csv
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Save Prostate MRI ground truth and reader data
truthData &lt;- getMRMCdataset("prostateTruth")
rawData &lt;- getMRMCdataset("prostateRawData")
</code></pre>

<hr>
<h2 id='getMRMCscore'>Get a score from an MRMC data frame</h2><span id='topic+getMRMCscore'></span>

<h3>Description</h3>

<p>Get a score from an MRMC data frame
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getMRMCscore(df, iR, iC, modality)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="getMRMCscore_+3A_df">df</code></td>
<td>
<p>An MRMC data frame</p>
</td></tr>
<tr><td><code id="getMRMCscore_+3A_ir">iR</code></td>
<td>
<p>The numeric index of the readerID</p>
</td></tr>
<tr><td><code id="getMRMCscore_+3A_ic">iC</code></td>
<td>
<p>The numeric index of the caseID</p>
</td></tr>
<tr><td><code id="getMRMCscore_+3A_modality">modality</code></td>
<td>
<p>The character description of the modalityID</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The score
</p>

<hr>
<h2 id='getWRBM'>Get within-reader, between-modality paired data from an MRMC data frame</h2><span id='topic+getWRBM'></span>

<h3>Description</h3>

<p>Get within-reader, between-modality paired data from an MRMC data frame
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getWRBM(mrmcDF, modality.X, modality.Y)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="getWRBM_+3A_mrmcdf">mrmcDF</code></td>
<td>
<p>A data frame with the following columns: readerID, caseID, modalityID, score</p>
</td></tr>
<tr><td><code id="getWRBM_+3A_modality.x">modality.X</code></td>
<td>
<p>The name of one modality</p>
</td></tr>
<tr><td><code id="getWRBM_+3A_modality.y">modality.Y</code></td>
<td>
<p>The name of one modality. This should be different from modality.X</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The result of merging the modality.X and modality.Y subsets of mrmcDF by readerID and caseID
</p>

<hr>
<h2 id='init.lecuyerRNG'>Initialize the l'Ecuyer random number generator</h2><span id='topic+init.lecuyerRNG'></span>

<h3>Description</h3>

<p>See the documentation for the <code>parallel package</code>.
If you require backwards compatibility, please run <code>RNGversion("3.5.0")</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>init.lecuyerRNG(seed = 1, stream = 2)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="init.lecuyerRNG_+3A_seed">seed</code></td>
<td>
<p>This determines the position in each stream</p>
</td></tr>
<tr><td><code id="init.lecuyerRNG_+3A_stream">stream</code></td>
<td>
<p>This determines the stream</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Nothing
</p>

<hr>
<h2 id='limitsOfAgreement'>MRMC Analysis of Limits of Agreement using ANOVA</h2><span id='topic+limitsOfAgreement'></span><span id='topic+laWRBM'></span><span id='topic+laBRWM'></span><span id='topic+laWRWM'></span><span id='topic+laBRBM'></span>

<h3>Description</h3>

<p>These four functions calculate four types of Limits of Agreement using ANOVA: 
Within-Reader Within-Modality(WRWM), Between-Reader Within-Modality(BRWM),
Within-Reader Between-Modality(WRBM), and Between-Reader Between-Modality(BRBM). 
The 95% confidence interval of the mean difference is also provided. If the study is fully crossed, the ANOVA 
methods are realized either by applying <code>stats::aov</code> or by matrix multiplication. Otherwise, the SS in ANOVA are
computed as residual sums of squares of linear models. See details below about the model structure
and these references.
</p>

<ul>
<li><p> S. Wen and B. D. Gallas,
“Three-Way Mixed Effect ANOVA to Estimate MRMC Limits of Agreement,”
<em>Statistics in Biopharmaceutical Research</em>, <strong>14</strong>, pp. 532–541, 2022,
<a href="https://doi.org/10.1080/19466315.2022.2063169">doi:10.1080/19466315.2022.2063169</a>.
</p>
</li>
<li><p> S. Wen and B. D. Gallas,
“Expanding to Arbitrary Study Designs: ANOVA to Estimate Limits of Agreement for MRMC Studies,”
<em>arXiv</em>, 2023, <a href="https://doi.org/10.48550/ARXIV.2312.16097">doi:10.48550/ARXIV.2312.16097</a>.
</p>
</li></ul>



<h3>Usage</h3>

<pre><code class='language-R'>laWRBM(
  df,
  modalitiesToCompare = c("testA", "testB"),
  keyColumns = c("readerID", "caseID", "modalityID", "score"),
  if.aov = TRUE,
  type = 1,
  reader.first = TRUE
)

laBRWM(
  df,
  modality = c("testA"),
  keyColumns = c("readerID", "caseID", "modalityID", "score"),
  if.aov = TRUE,
  type = 1,
  reader.first = TRUE
)

laWRWM(
  df,
  replicatesToCompare = c("testA", "testB"),
  keyColumns = c("readerID", "caseID", "modalityID", "score"),
  if.aov = TRUE,
  type = 1,
  reader.first = TRUE
)

laBRBM(
  df,
  modalitiesToCompare = c("testA", "testB"),
  keyColumns = c("readerID", "caseID", "modalityID", "score"),
  if.aov = TRUE,
  type = 1,
  reader.first = TRUE,
  is.sparseQR = T
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="limitsOfAgreement_+3A_df">df</code></td>
<td>
<p>Data frame of observations, one per row. Columns identify random effects, fixed effects,
and the observation. Namely,
</p>

<dl>
<dt>readerID</dt><dd><p>The factor corresponding to the different readers in the study.
The readerID is treated as a random effect.</p>
</dd>
<dt>caseID</dt><dd><p>The factor corresponding to the different cases in the study.
The caseID is treated as a random effect.</p>
</dd>
<dt>modalityID</dt><dd><p>The factor corresponding to the different modalities in the study.
The modalityID is treated as a fixed effect.</p>
</dd>
<dt>score</dt><dd><p>The number (observation) given by the reader to the case for the modality indicated.</p>
</dd>
</dl>
</td></tr>
<tr><td><code id="limitsOfAgreement_+3A_modalitiestocompare">modalitiesToCompare</code></td>
<td>
<p>The factors identifying the modalities to compare. It should be length 2.
Default = <code>c("testA","testB")</code></p>
</td></tr>
<tr><td><code id="limitsOfAgreement_+3A_keycolumns">keyColumns</code></td>
<td>
<p>Identify the factors corresponding to the readerID (random effect), caseID (random effect),
modalityID (fixed effect), and score (observation).
Default = <code>c("readerID", "caseID", "modalityID", "score")</code></p>
</td></tr>
<tr><td><code id="limitsOfAgreement_+3A_if.aov">if.aov</code></td>
<td>
<p>Boolean value to determine whether to use the 'stats::aov' function or to
calculate the ANOVA statistics explicitly. 'stats::aov' is only appropriate
for fully-crossed study only. This flag permits head-to-head comparisons of
the output from 'stats::aov' and the explicit calculations.
Default = <code>TRUE</code></p>
</td></tr>
<tr><td><code id="limitsOfAgreement_+3A_type">type</code></td>
<td>
<p>Identify how SS are computed in ANOVA for unbalanced study designs.
The possible values are c(1,2,3), corresponding to the approaches
introduced in the SAS package(Langsrud2003_Stat-Comput_v13p163).
</p>
<p>Default <code>type= 1</code></p>
</td></tr>
<tr><td><code id="limitsOfAgreement_+3A_reader.first">reader.first</code></td>
<td>
<p>Boolean value to determine whether reader effect is added to the model before the case effect. 
Default <code>reader.first = TRUE</code></p>
</td></tr>
<tr><td><code id="limitsOfAgreement_+3A_modality">modality</code></td>
<td>
<p>The factor identifying the modality for laBRWM. It should be length 1.
Default = <code>modality = c("testA")</code></p>
</td></tr>
<tr><td><code id="limitsOfAgreement_+3A_replicatestocompare">replicatesToCompare</code></td>
<td>
<p>The factors identifying the replicates to compare for <code>laWRWM</code>. It should be length 2.
Default = <code>c("testA","testB")</code></p>
</td></tr>
<tr><td><code id="limitsOfAgreement_+3A_is.sparseqr">is.sparseQR</code></td>
<td>
<p>Boolean value to determine whether the 'base::qr' function assumes the input
data is sparse or not. 
Default = <code>TRUE</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>Suppose the score from a reader j for case k under modality <code class="reqn">i</code> is<code class="reqn">X_{ijk}</code>, then the difference score from the
same reader for the same case under two different modalities is <code class="reqn">Y_{jk} = X_{1jk} - X_{2jk}</code>.
</p>

<ul>
<li><p><code>laWRBM</code> use two-way random effect ANOVA to analyze the difference scores <code class="reqn">Y_{jk}</code>. The model
is <code class="reqn">Y_{jk}=\mu + R_j + C_k + \epsilon_{jk}</code>, where <code class="reqn">R_j</code> and <code class="reqn">C_k</code> are random effects for readers
and cases. The variances of mean and individual observations are expressed as linear combinations of the MS
given by ANOVA.
</p>
</li>
<li><p><code>laBRWM</code> use two-way random effect ANOVA to analyze the scores <code class="reqn">X_{jk}</code> for a single modality. 
The model is <code class="reqn">X_{jk}=\mu + R_j + C_k + \epsilon_{jk}</code>, where <code class="reqn">R_j</code> and <code class="reqn">C_k</code> are random effects 
for readers and cases. The variances of mean and individual observations are expressed as linear combinations 
of the MS given by ANOVA.
</p>
</li>
<li><p><code>laWRWM</code> use two-way random effect ANOVA to analyze the difference scores <code class="reqn">Y_{jk}</code> from the same 
reader for the same cases under the same modality with different replicates <code class="reqn">Y_{jk} = X_{jk1} - X_{jk2}</code>. 
The model is <code class="reqn">Y_{jk}=\mu + R_j + C_k + \epsilon_{jk}</code>, where <code class="reqn">R_j</code> and <code class="reqn">C_k</code> are random effects for 
readers and cases. The variances of mean and individual observations are expressed as  linear combinations of 
the MS given by ANOVA.
</p>
</li>
<li><p><code>laBRBM</code> use three-way mixed effect ANOVA to analyze the scores <code class="reqn">X_{ijk}</code>. The model is given by
<code class="reqn">X_{ijk}=\mu + R_j + C_k + m_i + RC_{jk} + mR_{ij} + mC_{ik} + \epsilon_{ijk}</code>, where <code class="reqn">R_j</code> and
<code class="reqn">C_k</code> are random effects for readers and cases, <code class="reqn">m_i</code> is a fixed effect for modality, and the other terms
are interaction terms. The variances of mean and individual observations are expressed as linear combinations
of the MS given by ANOVA.
</p>
</li></ul>



<h3>Value</h3>

<p>A list of two dataframes.
</p>
<p>The first dataframe is <code>limits.of.agreement</code>. It has one row. Each column is as follows:
</p>

<dl>
<dt>meanDiff</dt><dd><p>The mean difference score.</p>
</dd>
<dt>var.MeanDiff</dt><dd><p>The variance of the mean difference score.</p>
</dd>
<dt>var.1obs</dt><dd><p>The variance of the difference score.</p>
</dd>
<dt>ci95meanDiff.bot</dt><dd><p>Lower bound of 95% CI for the mean difference score. <code>meanDiff+
  1.96*sqrt(var.MeanDiff)</code></p>
</dd>
<dt>ci95meanDiff.top</dt><dd><p>Upper bound of 95% CI for the mean difference score. <code>meanDiff-
  1.96*sqrt(var.MeanDiff)</code></p>
</dd>
<dt>la.bot</dt><dd><p>Lower Limit of Agreement for the difference score. <code>meanDiff+1.96*sqrt(var.1obs)</code></p>
</dd>
<dt>la.top</dt><dd><p>Upper Limit of Agreement for the difference score. <code>meanDiff-1.96*sqrt(var.1obs)</code></p>
</dd>
</dl>

<p>The second dataframe is <code>two.way.ANOVA</code> or <code>three.way.ANOVA</code> shows the degrees of freedom, 
sums of squares, and estimates of variance components for each source of variation
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Initialize the simulation configuration parameters
config &lt;- sim.NormalIG.Hierarchical.config(modalityID = c("testA", "testB"))

# Initizlize the seed and stream of the random number generator
init.lecuyerRNG()

# Simulate an MRMC ROC data set
dFrame &lt;- sim.NormalIG.Hierarchical(config)

# Compute Limits of Agreement
laWRBM_result &lt;- laWRBM(dFrame)
print(laWRBM_result)
laBRBM_result &lt;- laBRBM(dFrame)
print(laBRBM_result)

</code></pre>

<hr>
<h2 id='renameCol'>Rename a data frame column name or a list object name</h2><span id='topic+renameCol'></span>

<h3>Description</h3>

<p>Rename a data frame column name or a list object name
</p>


<h3>Usage</h3>

<pre><code class='language-R'>renameCol(df, oldColName, newColName)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="renameCol_+3A_df">df</code></td>
<td>
<p>A data frame</p>
</td></tr>
<tr><td><code id="renameCol_+3A_oldcolname">oldColName</code></td>
<td>
<p>Old column name</p>
</td></tr>
<tr><td><code id="renameCol_+3A_newcolname">newColName</code></td>
<td>
<p>New column name</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the data frame with the updated column name
</p>

<hr>
<h2 id='roc2binary'>Convert ROC data formatted for doIMRMC to TPF and FPF data formatted for doIMRMC</h2><span id='topic+roc2binary'></span>

<h3>Description</h3>

<p>Convert ROC data formatted for doIMRMC to TPF and FPF data formatted for doIMRMC
</p>


<h3>Usage</h3>

<pre><code class='language-R'>roc2binary(df.auc, threshold)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="roc2binary_+3A_df.auc">df.auc</code></td>
<td>
<p>data frame of roc scores formatted for doIMRMC</p>
</td></tr>
<tr><td><code id="roc2binary_+3A_threshold">threshold</code></td>
<td>
<p>The threshold for determining binary decisions</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list of two data frames (df.tpf and df.fpf) both formatted for doIMRMC
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Create a sample configuration file
config &lt;- sim.gRoeMetz.config()
# Simulate an MRMC ROC data set
dFrame.imrmc &lt;- sim.gRoeMetz(config)
# Convert ROC MRMC data to TPF and FPF data frames
result &lt;- roc2binary(dFrame.imrmc, threshold = 0.9)
# Analyze TPF data using doIMRMC
tpf_result &lt;- doIMRMC(result$df.tpf)
# View(tpf_result$perReader)
</code></pre>

<hr>
<h2 id='roeMetzConfigs'>roeMetzConfigs</h2><span id='topic+roeMetzConfigs'></span>

<h3>Description</h3>

<p>This is a data frame containing the configuration parameters 
used in Roe1997_Acad-Radiol_v4p298. Each row corresponds to one of the twelve configurations
appearing in Table 1 of that paper in a format that can be the input to <code>sim.gRoeMetz</code>.
</p>


<h3>Details</h3>

<p>The columns of this data frame are as follows
</p>

<ul>
<li><p> Experiment labels and size
</p>

<ul>
<li><p> modalityID.A: [character] label modality A
</p>
</li>
<li><p> modalityID.B: [character] label modality B
</p>
</li>
<li><p> nR: [numeric] number of readers
</p>
</li>
<li><p> nC.neg: [numeric] number of signal-absent cases
</p>
</li>
<li><p> nC.pos: [numeric] number of signal-present cases
</p>
</li></ul>

</li>
<li><p> There are six fixed effects:
</p>

<ul>
<li><p> mu.neg: [numeric] signal-absent (neg, global mean)
</p>
</li>
<li><p> mu.pos: [numeric] signal-present (pos, global mean)
</p>
</li>
<li><p> mu.Aneg: [numeric] modality A signal-absent (Aneg, modality effect)
</p>
</li>
<li><p> mu.Bneg: [numeric] modality B signal-absent (Bneg, modality effect)
</p>
</li>
<li><p> mu.Apos: [numeric] modality A signal-present (Apos, modality effect)
</p>
</li>
<li><p> mu.Bpos: [numeric] modality B signal-present (Bpos, modality effect)
</p>
</li></ul>

</li>
<li><p> There are six random effects that are independent of modality
</p>

<ul>
<li><p> var_r.neg: [numeric] variance of random reader effect
</p>
</li>
<li><p> var_c.neg: [numeric] variance of random case effect
</p>
</li>
<li><p> var_rc.neg: [numeric] variance of random reader by case effect
</p>
</li>
<li><p> var_r.pos: [numeric] variance of random reader effect
</p>
</li>
<li><p> var_c.pos: [numeric] variance of random case effect
</p>
</li>
<li><p> var_rc.pos: [numeric] variance of random reader by case effect
</p>
</li></ul>

</li>
<li><p> There are six random effects that are specific to modality A
</p>

<ul>
<li><p> var_r.Aneg: [numeric] variance of random reader effect
</p>
</li>
<li><p> var_c.Aneg: [numeric] variance of random case effect
</p>
</li>
<li><p> var_rc.Aneg: [numeric] variance of random reader by case effect
</p>
</li>
<li><p> var_r.Apos: [numeric] variance of random reader effect
</p>
</li>
<li><p> var_c.Apos: [numeric] variance of random case effect
</p>
</li>
<li><p> var_rc.Apos: [numeric] variance of randome reader by case effect
</p>
</li></ul>

</li>
<li><p> There are six random effects that are specific to modality B
</p>

<ul>
<li><p> var_r.Bneg: [numeric] variance of random reader effect
</p>
</li>
<li><p> var_c.Bneg: [numeric] variance of random case effect
</p>
</li>
<li><p> var_rc.Bneg: [numeric] variance of random reader by case effect
</p>
</li>
<li><p> var_r.Bpos: [numeric] variance of random reader effect
</p>
</li>
<li><p> var_c.Bpos: [numeric] variance of random case effect
</p>
</li>
<li><p> var_rc.Bpos: [numeric] variance of randome reader by case effect
</p>
</li></ul>

</li></ul>


<hr>
<h2 id='sim.gRoeMetz'>Simulate an MRMC data set of an ROC experiment comparing two modalities</h2><span id='topic+sim.gRoeMetz'></span>

<h3>Description</h3>

<p>This procedure simulates an MRMC data set of an ROC experiment comparing two modalities.
It is based on Gallas2014_J-Med-Img_v1p031006, which generalizes of the model in
Roe1997_Acad-Radiol_v4p298 and Roe1997_Acad-Radiol_v4p587. Specifically, it allows
the variance components to depend on the truth and the modality. For the simpler
Roe and Metz model, you can enter the smaller set of parameters into
sim.gRoeMetz.config and it will return a larger set of parameters that can be used with this function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sim.gRoeMetz(config)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="sim.gRoeMetz_+3A_config">config</code></td>
<td>
<p>[list] of simulation parameters:
</p>

<ul>
<li><p> Experiment labels and size
</p>

<ul>
<li><p> modalityID.A: [character] label modality A
</p>
</li>
<li><p> modalityID.B: [character] label modality B
</p>
</li>
<li><p> nR: [numeric] number of readers
</p>
</li>
<li><p> nC.neg: [numeric] number of signal-absent cases
</p>
</li>
<li><p> nC.pos: [numeric] number of signal-present cases
</p>
</li></ul>

</li>
<li><p> There are six fixed effects:
</p>

<ul>
<li><p> mu.neg: [numeric] signal-absent (neg, global mean)
</p>
</li>
<li><p> mu.pos: [numeric] signal-present (pos, global mean)
</p>
</li>
<li><p> mu.Aneg: [numeric] modality A signal-absent (Aneg, modality effect)
</p>
</li>
<li><p> mu.Bneg: [numeric] modality B signal-absent (Bneg, modality effect)
</p>
</li>
<li><p> mu.Apos: [numeric] modality A signal-present (Apos, modality effect)
</p>
</li>
<li><p> mu.Bpos: [numeric] modality B signal-present (Bpos, modality effect)
</p>
</li></ul>

</li>
<li><p> There are six random effects that are independent of modality
</p>

<ul>
<li><p> var_r.neg: [numeric] variance of random reader effect
</p>
</li>
<li><p> var_c.neg: [numeric] variance of random case effect
</p>
</li>
<li><p> var_rc.neg: [numeric] variance of random reader by case effect
</p>
</li>
<li><p> var_r.pos: [numeric] variance of random reader effect
</p>
</li>
<li><p> var_c.pos: [numeric] variance of random case effect
</p>
</li>
<li><p> var_rc.pos: [numeric] variance of random reader by case effect
</p>
</li></ul>

</li>
<li><p> There are six random effects that are specific to modality A
</p>

<ul>
<li><p> var_r.Aneg: [numeric] variance of random reader effect
</p>
</li>
<li><p> var_c.Aneg: [numeric] variance of random case effect
</p>
</li>
<li><p> var_rc.Aneg: [numeric] variance of random reader by case effect
</p>
</li>
<li><p> var_r.Apos: [numeric] variance of random reader effect
</p>
</li>
<li><p> var_c.Apos: [numeric] variance of random case effect
</p>
</li>
<li><p> var_rc.Apos: [numeric] variance of randome reader by case effect
</p>
</li></ul>

</li>
<li><p> There are six random effects that are specific to modality B
</p>

<ul>
<li><p> var_r.Bneg: [numeric] variance of random reader effect
</p>
</li>
<li><p> var_c.Bneg: [numeric] variance of random case effect
</p>
</li>
<li><p> var_rc.Bneg: [numeric] variance of random reader by case effect
</p>
</li>
<li><p> var_r.Bpos: [numeric] variance of random reader effect
</p>
</li>
<li><p> var_c.Bpos: [numeric] variance of random case effect
</p>
</li>
<li><p> var_rc.Bpos: [numeric] variance of randome reader by case effect
</p>
</li></ul>

</li></ul>
</td></tr>
</table>


<h3>Details</h3>

<p>The simulation is a linear model with six fixed effects related to
modality and truth and 18 normally distributed independent random effects
for readers, cases, and the interaction between the two. Here is the linear model:
</p>
<p>L.mrct = mu.t + mu.mt <br />
+ reader.rt + case.ct + readerXcase.rct <br />
+ modalityXreader.mrt + modalityXcase.mct + modalityXreaderXcase.mrct <br />
</p>

<ul>
<li><p> m=modality (levels: A and b)
</p>
</li>
<li><p> t=truth (levels: neg and Pos)
</p>
</li>
<li><p> mu.t is the global mean for t=neg and t=pos cases
</p>
</li>
<li><p> mu.mt is the modality specific fixed effects for t=neg and t=pos cases
</p>
</li>
<li><p> the remaining terms are the random effects: all independent normal random variables
</p>
</li></ul>



<h3>Value</h3>

<p>dFrame.imrmc   [data.frame] with (nC.neg + nC.pos)*(nR+1) rows including
</p>

<ul>
<li><p> readerID: [factor] w/ nR levels &quot;reader1&quot;, &quot;reader2&quot;, ...
</p>
</li>
<li><p> caseID: [factor] w/ nC levels &quot;case1&quot;, &quot;case2&quot;, ...
</p>
</li>
<li><p> modalityID: [factor] w/ 1 level config$modalityID
</p>
</li>
<li><p> score: [numeric] reader score
</p>
</li></ul>

<p>Note that the first nC.neg + nC.pos rows specify the truth labels for each case.
For these rows, the readerID must be &quot;truth&quot;
and the score must be 0 for negative cases and 1 for positive cases.
</p>

<hr>
<h2 id='sim.gRoeMetz.config'>Create a configuration object for the sim.gRoeMetz program</h2><span id='topic+sim.gRoeMetz.config'></span>

<h3>Description</h3>

<p>This function creates a configuration object for the Roe &amp; Metz
simulation model to be used as input for the sim.gRoeMetz program.
The default model returned when there are no arguments given to the function is
the &quot;HH&quot; model from Roe1987_Acad-Radiol_v4p298. Following that paper,
The user can specify three parameters related to experiment size (nR, nC.neg, nC.pos)
and five parameters parameters specifying a linear model that does not
depend on modality or truth (mu.neg, mu.pos, var_r, var_c, var_rc).
The mu.pos is set to 1.0, which yields a reader averaged AUC of
approximately 0.765.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sim.gRoeMetz.config(
  nR = 5,
  nC.neg = 40,
  nC.pos = 40,
  mu.neg = 0,
  mu.pos = 1,
  var_r = 0.03,
  var_c = 0.3,
  var_rc = 0.2
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="sim.gRoeMetz.config_+3A_nr">nR</code></td>
<td>
<p>Number of readers (default = 5)</p>
</td></tr>
<tr><td><code id="sim.gRoeMetz.config_+3A_nc.neg">nC.neg</code></td>
<td>
<p>Number of signal-absent cases (default = 25)</p>
</td></tr>
<tr><td><code id="sim.gRoeMetz.config_+3A_nc.pos">nC.pos</code></td>
<td>
<p>Number of signal-present cases (default = 25)</p>
</td></tr>
<tr><td><code id="sim.gRoeMetz.config_+3A_mu.neg">mu.neg</code></td>
<td>
<p>Mean fixed effect of signal-absent distribution (default = 0.0) <br />
Modality specific parameters are set to zero: mu.Aneg = mu.Bneg = 0</p>
</td></tr>
<tr><td><code id="sim.gRoeMetz.config_+3A_mu.pos">mu.pos</code></td>
<td>
<p>Mean fixed effect of signal-present distribution (default = 1.0) <br />
Modality specific parameters are set to zero: mu.Apos = mu.Bpos = 0</p>
</td></tr>
<tr><td><code id="sim.gRoeMetz.config_+3A_var_r">var_r</code></td>
<td>
<p>Variance of reader random effect (default = 0.03) <br />
var_r.neg = var_r.pos = var_r.Aneg = var_r.Apos = var_r.Bneg = var_r.Bpos = var_r <br /></p>
</td></tr>
<tr><td><code id="sim.gRoeMetz.config_+3A_var_c">var_c</code></td>
<td>
<p>Variance of case random effect (default = 0.30) <br />
var_c.neg = var_c.pos = var_c.Aneg = var_c.Apos = var_c.Bneg = var_c.Bpos = var_c <br /></p>
</td></tr>
<tr><td><code id="sim.gRoeMetz.config_+3A_var_rc">var_rc</code></td>
<td>
<p>Variance of reader.by.case random effect (default = 0.20) <br />
var_rc.neg = var_rc.pos = var_rc.Aneg = var_rc.Apos = var_rc.Bneg = var_rc.Bpos = var_rc <br /></p>
</td></tr>
</table>


<h3>Details</h3>

<p>If no arguments, this function returns a default simulation
configuration for sim.gRoeMetz
</p>


<h3>Value</h3>

<p>config [list] Refer to the sim.gRoeMetz input variable
</p>

<hr>
<h2 id='sim.NormalIG.Hierarchical'>Simulate an MRMC data set comparing two modalities by a hierarchical model</h2><span id='topic+sim.NormalIG.Hierarchical'></span>

<h3>Description</h3>

<p>This procedure simulates an MRMC data set for an MRMC agreement study comparing two 
modalities. It is a hierarchical model that consists of two interaction terms: reader-case
interaction and modality-reader-case-replicate interaction. Both interaction
terms are conditionally normally distributed, with the case(-related) factor contributing 
to the conditional mean and the reader(-related) factor contributing to the conditional 
variance. The case effect is normally distributed, while the reader effect is
an inverse-gamma.
</p>
<p>The Hierarchical Inverse-Gamma model is described in this paper:
</p>

<ul>
<li><p> S. Wen and B. D. Gallas,
“Three-Way Mixed Effect ANOVA to Estimate MRMC Limits of Agreement,”
<em>Statistics in Biopharmaceutical Research</em>, <strong>14</strong>, pp. 532–541, 2022,
<a href="https://doi.org/10.1080/19466315.2022.2063169">doi:10.1080/19466315.2022.2063169</a>
</p>
</li></ul>



<h3>Usage</h3>

<pre><code class='language-R'>sim.NormalIG.Hierarchical(
  config,
  R = NULL,
  AR = NULL,
  BR = NULL,
  is.within = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="sim.NormalIG.Hierarchical_+3A_config">config</code></td>
<td>
<p>[list] of simulation parameters:
</p>

<ul>
<li><p> Experiment labels and size
</p>

<ul>
<li> <p><code>modalityID</code>: [vector] label modality A and B.
</p>
</li>
<li> <p><code>nR</code>: [num] number of readers
</p>
</li>
<li> <p><code>nC</code>: [num] number of cases
</p>
</li>
<li> <p><code>C_dist</code>: [chr] distribution of the case. Default <code>C_dist="normal"</code>
</p>
</li></ul>

</li>
<li><p> Mean and fixed effects:
</p>

<ul>
<li> <p><code>mu</code>: [num] grand mean
</p>
</li>
<li> <p><code>tau_A</code>: [num] modality A
</p>
</li>
<li> <p><code>tau_B</code>: [num] modality B
</p>
</li></ul>

</li>
<li><p> Reader-case interaction term
</p>

<ul>
<li> <p><code>sigma_C</code>: [num] std of case factor (if <code>C_dist="normal"</code>)
</p>
</li>
<li> <p><code>a_C</code>:     [num] alpha for distribution of case (if <code>C_dist="beta"</code>)
</p>
</li>
<li> <p><code>b_C</code>:     [num] beta for distribution of case (if <code>C_dist="beta"</code>)
</p>
</li>
<li> <p><code>alpha_R</code>: [num] shape parameter for reader
</p>
</li>
<li> <p><code>beta_R</code>:  [num] scale parameter for reader
</p>
</li></ul>

</li>
<li><p> Modality-reader-case-replicate interaction term for modality A
</p>

<ul>
<li> <p><code>sigma_C.A</code>: [num] std of case factor (if <code>C_dist="normal"</code>)
</p>
</li>
<li> <p><code>a_C.A</code>:     [num] alpha for distribution of case (if <code>C_dist="beta"</code>)
</p>
</li>
<li> <p><code>b_C.A</code>:     [num] beta for distribution of case (if <code>C_dist="beta"</code>)
</p>
</li>
<li> <p><code>alpha_R.A</code>: [num] shape parameter for reader
</p>
</li>
<li> <p><code>beta_R.A</code>:  [num] scale parameter for reader
</p>
</li></ul>

</li>
<li><p> Modality-reader-case-replicate interaction term for modality B
</p>

<ul>
<li> <p><code>sigma_C.B</code>: [num] std of case factor (if <code>C_dist="normal"</code>)
</p>
</li>
<li> <p><code>a_C.B</code>:     [num] alpha for distribution of case (if <code>C_dist="beta"</code>)
</p>
</li>
<li> <p><code>b_C.B</code>:     [num] beta for distribution of case (if <code>C_dist="beta"</code>)
</p>
</li>
<li> <p><code>alpha_R.B</code>: [num] shape parameter for reader
</p>
</li>
<li> <p><code>beta_R.B</code>:  [num] scale parameter for reader
</p>
</li></ul>

</li>
<li><p> Scales for the case related terms and interaction terms
</p>

<ul>
<li> <p><code>C_scale</code>:      [num] weight for the case factor
</p>
</li>
<li> <p><code>RC_scale</code>:     [num] weight for the reader-case interaction term
</p>
</li>
<li> <p><code>tauC_scale</code>:   [num] weight for the modality-case term
</p>
</li>
<li> <p><code>tauRCE_scale</code>: [num] weight for the modality-reader-case-replicate interaction term
</p>
</li></ul>

</li></ul>
</td></tr>
<tr><td><code id="sim.NormalIG.Hierarchical_+3A_r">R</code></td>
<td>
<p>[vector] of size <code>nR</code> of reader factors pre-generated from
a gamma(<code>alpha_R</code>, <code>beta_R</code>) distribution 
to allow the reader factor to be fixed across multiple simulations.
Default <code>= NULL</code></p>
</td></tr>
<tr><td><code id="sim.NormalIG.Hierarchical_+3A_ar">AR</code></td>
<td>
<p>[vector] of size <code>nR</code> of modality-reader interaction terms
pre-generated from a gamma(<code>alpha_R.A</code>, <code>beta_R.A</code>) distribution 
to allow the modality-reader interaction terms to be
fixed across multiple simulations the modality-reader interaction.
Default <code>= NULL</code></p>
</td></tr>
<tr><td><code id="sim.NormalIG.Hierarchical_+3A_br">BR</code></td>
<td>
<p>[vector] of size <code>nR</code> of modality-reader interaction terms
pre-generated from a gamma(<code>alpha_R.B</code>, <code>beta_R.B</code>) distribution 
to allow the modality-reader interaction terms to be
fixed across multiple simulations the modality-reader interaction.
Default <code>= NULL</code></p>
</td></tr>
<tr><td><code id="sim.NormalIG.Hierarchical_+3A_is.within">is.within</code></td>
<td>
<p>[bol] whether the data are within-modality (A==B).
In this case the modality-reader and modality-case interaction terms 
will be the same.
Default <code>= FALSE</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>The model has the following structure:
X.ijkl = mu + m.i + RC.jk + mRCE.ijkl
</p>

<ul>
<li><p> mu = grand mean
</p>
</li>
<li><p> m.i = modalities (levels: A and B)
</p>
</li>
<li><p> RC.jk given R.j,C.k ~ N(C.k, R.j) reader-case interaction term
</p>
</li>
<li><p> mRCE.ijkl given mR.ij,mC.ik ~ N(mC.ik, mR.ij) modality-reader-case-replicate term
</p>
</li>
<li><p> C.k and mC.ik are Normal/beta distributed
</p>
</li>
<li><p> R.j and mR.ij are Inverse-Gamma distributed
</p>
</li></ul>



<h3>Value</h3>

<p>df   [data.frame] with nR x nC x 2 rows including
</p>

<ul>
<li><p> readerID: [Factor] w/ nR levels &quot;reader1&quot;, &quot;reader2&quot;, ...
</p>
</li>
<li><p> caseID: [Factor] w/ nC levels &quot;case1&quot;, &quot;case2&quot;, ...
</p>
</li>
<li><p> modalityID: [Factor] w/ 2 levels &quot;testA&quot; and &quot;testB&quot;
</p>
</li>
<li><p> score: [num] reader score
</p>
</li></ul>


<hr>
<h2 id='sim.NormalIG.Hierarchical.config'>Create a configuration object for the sim.NormalIG.Hierarchical function</h2><span id='topic+sim.NormalIG.Hierarchical.config'></span>

<h3>Description</h3>

<p>This function creates a configuration object that sets the parameters
for the Hierarchical Inverse-Gamma simulation model. The configuration
object is an to the <code><a href="#topic+sim.NormalIG.Hierarchical">sim.NormalIG.Hierarchical</a></code> function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sim.NormalIG.Hierarchical.config(
  nR = 5,
  nC = 100,
  modalityID = c("testA", "testA*"),
  C_dist = "normal",
  mu = 0,
  tau_A = 0,
  tau_B = 0,
  alpha_R = 10,
  beta_R = 1,
  sigma_C = 1,
  a_C = 0.8,
  b_C = 3,
  sigma_tauC = 1,
  alpha_tauR = 10,
  beta_tauR = 1,
  C_scale = 1,
  RC_scale = 1,
  tauC_scale = 1,
  tauRCE_scale = 1
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="sim.NormalIG.Hierarchical.config_+3A_nr">nR</code></td>
<td>
<p>[num] Number of readers. Default <code>nR = 5</code></p>
</td></tr>
<tr><td><code id="sim.NormalIG.Hierarchical.config_+3A_nc">nC</code></td>
<td>
<p>[num] Number of cases. Default <code>nC = 100</code></p>
</td></tr>
<tr><td><code id="sim.NormalIG.Hierarchical.config_+3A_modalityid">modalityID</code></td>
<td>
<p>[vector] List of modalityID. Default <code>modalityID = c("testA", "testA*")</code></p>
</td></tr>
<tr><td><code id="sim.NormalIG.Hierarchical.config_+3A_c_dist">C_dist</code></td>
<td>
<p>[chr] Distribution of the case. Default <code>C_dist="normal"</code></p>
</td></tr>
<tr><td><code id="sim.NormalIG.Hierarchical.config_+3A_mu">mu</code></td>
<td>
<p>[num] grand mean. Default <code>mu = 0</code></p>
</td></tr>
<tr><td><code id="sim.NormalIG.Hierarchical.config_+3A_tau_a">tau_A</code></td>
<td>
<p>[num] modality A effect. Default <code>tau_A = 0</code></p>
</td></tr>
<tr><td><code id="sim.NormalIG.Hierarchical.config_+3A_tau_b">tau_B</code></td>
<td>
<p>[num] modality B effect. Default <code>tau_B = 0</code></p>
</td></tr>
<tr><td><code id="sim.NormalIG.Hierarchical.config_+3A_alpha_r">alpha_R</code></td>
<td>
<p>[num] shape parameter for reader. Default <code>alpha_R = 10</code></p>
</td></tr>
<tr><td><code id="sim.NormalIG.Hierarchical.config_+3A_beta_r">beta_R</code></td>
<td>
<p>[num] scale parameter for reader. Default <code>beta = 1</code></p>
</td></tr>
<tr><td><code id="sim.NormalIG.Hierarchical.config_+3A_sigma_c">sigma_C</code></td>
<td>
<p>[num] std of case factor (if <code>C_dist="normal"</code>). Default <code>sigma_C = 1</code></p>
</td></tr>
<tr><td><code id="sim.NormalIG.Hierarchical.config_+3A_a_c">a_C</code></td>
<td>
<p>[num] alpha for distribution of case (if <code>C_dist="beta"</code>). Default <code>a_C = 0.8</code></p>
</td></tr>
<tr><td><code id="sim.NormalIG.Hierarchical.config_+3A_b_c">b_C</code></td>
<td>
<p>[num] beta for distribution of case (if <code>C_dist="beta"</code>). Default <code>b_C = 3</code></p>
</td></tr>
<tr><td><code id="sim.NormalIG.Hierarchical.config_+3A_sigma_tauc">sigma_tauC</code></td>
<td>
<p>[num] std of modality-case (if <code>C_dist="normal"</code>). Default <code>sigma_tauC = 1</code></p>
</td></tr>
<tr><td><code id="sim.NormalIG.Hierarchical.config_+3A_alpha_taur">alpha_tauR</code></td>
<td>
<p>[num] shape parameter for modality-reader. Default <code>alpha_tauR = 10</code></p>
</td></tr>
<tr><td><code id="sim.NormalIG.Hierarchical.config_+3A_beta_taur">beta_tauR</code></td>
<td>
<p>[num] scale parameter for modality-reader. Default <code>beta_tauR = 1</code></p>
</td></tr>
<tr><td><code id="sim.NormalIG.Hierarchical.config_+3A_c_scale">C_scale</code></td>
<td>
<p>[num] weight for the case factor. Default <code>C_scale = 1</code></p>
</td></tr>
<tr><td><code id="sim.NormalIG.Hierarchical.config_+3A_rc_scale">RC_scale</code></td>
<td>
<p>[num] weight for the reader-case interaction term. Default <code>RC_scale = 1</code></p>
</td></tr>
<tr><td><code id="sim.NormalIG.Hierarchical.config_+3A_tauc_scale">tauC_scale</code></td>
<td>
<p>[num] weight for the modality-case term. Default <code>tauC_scale = 1</code></p>
</td></tr>
<tr><td><code id="sim.NormalIG.Hierarchical.config_+3A_taurce_scale">tauRCE_scale</code></td>
<td>
<p>[num] weight for the modality-reader-case-replicate interaction term. Default <code>tauRCE_scale = 1</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>If no arguments, this function returns a default simulation
configuration for the <code><a href="#topic+sim.NormalIG.Hierarchical">sim.NormalIG.Hierarchical</a></code> function.
</p>


<h3>Value</h3>

<p>config [list] of input parameters for <code><a href="#topic+sim.NormalIG.Hierarchical">sim.NormalIG.Hierarchical</a></code>.
</p>

<hr>
<h2 id='simMRMC'>Simulate an MRMC data set</h2><span id='topic+simMRMC'></span>

<h3>Description</h3>

<p>This program simulates observations from one set of readers scoring one set of cases.
It produces one modality and one truth state
of ROC data following Roe1997_Acad-Radiol_v4p298 and Roe1997_Acad-Radiol_v4p587.
In order to produce an entire ROC data set, please use sim.gRoeMetz.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>simMRMC(simMRMC.config)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="simMRMC_+3A_simmrmc.config">simMRMC.config</code></td>
<td>
<p>[list] of simulation parameters:
</p>

<ul>
<li><p> modalityID [character] label modalityID
</p>
</li>
<li><p> readerIDs  [factor] the ID of each reader
</p>
</li>
<li><p> caseIDs    [factor] the ID of each case
</p>
</li>
<li><p> mu         [numeric] mean
</p>
</li>
<li><p> var_r      [numeric] variance of random reader effect
</p>
</li>
<li><p> var_c      [numeric] variance of random case effect
</p>
</li>
<li><p> var_rc     [numeric] variance of random reader by case effect
</p>
</li></ul>
</td></tr>
</table>


<h3>Details</h3>

<p>The simulation is a linear model with one fixed effect and three
normally distributed independent random effects corresponding to readers,
cases, and an interaction between the two.
</p>
<p>L.rc = mu + readerEffect.r + caseEffect.c + readerXcaseEffect.rc
</p>


<h3>Value</h3>

<p>L [data.frame] with nC*nR rows of 4 variables
</p>

<ul>
<li><p> L$modalityID   [factor] determined by input modalityID
</p>
</li>
<li><p> L$readerID     [factor] determined by input readerIDs
</p>
</li>
<li><p> L$caseID       [factor] determined by input caseIDs
</p>
</li>
<li><p> L$score        [numeric]  R.r + C.c + RC.rc
</p>

<ul>
<li><p> r = 1,2,...,nR
</p>
</li>
<li><p> c = 1,2,...,nC
</p>
</li>
<li><p> R.r ~ N(0,var_r)
</p>
</li>
<li><p> C.c ~ N(0,var_c)
</p>
</li>
<li><p> RC.rc ~ N(0,var_rc)
</p>
</li></ul>

</li></ul>


<hr>
<h2 id='simRoeMetz.example'>Simulates a sample MRMC ROC experiment</h2><span id='topic+simRoeMetz.example'></span>

<h3>Description</h3>

<p>Simulates a sample MRMC ROC experiment
</p>


<h3>Usage</h3>

<pre><code class='language-R'>simRoeMetz.example()
</code></pre>


<h3>Value</h3>

<p>dFrame.imrmc [data.frame] Please refer to the description of the <code><a href="#topic+sim.gRoeMetz">sim.gRoeMetz</a></code> return variable
</p>

<hr>
<h2 id='successDFtoROCdf'>Convert an MRMC data frame of successes to one formatted for doIMRMC</h2><span id='topic+successDFtoROCdf'></span>

<h3>Description</h3>

<p>Convert an MRMC data frame of successes to one formatted for doIMRMC
</p>


<h3>Usage</h3>

<pre><code class='language-R'>successDFtoROCdf(df)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="successDFtoROCdf_+3A_df">df</code></td>
<td>
<p>Each row contains a success observation for one reader evaluating one case</p>
</td></tr>
</table>


<h3>Value</h3>

<p>data frame ready for doIMRMC
</p>

<hr>
<h2 id='undoIMRMCdf'>Convert a doIMRMC formatted data frame to a standard data frame
with all factors.</h2><span id='topic+undoIMRMCdf'></span>

<h3>Description</h3>

<p>Convert a doIMRMC formatted data frame to a standard data frame
with all factors.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>undoIMRMCdf(df.MRMC)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="undoIMRMCdf_+3A_df.mrmc">df.MRMC</code></td>
<td>
<p>This data frame includes columns for readerID, caseID, modalityID, score.
Each row is a reader x case x modality observation from the study
In addition to observations from the study,
this data frame requires rows specifying the truth for each caseID.
For truth specifications, the readerID needs to equal &quot;truth&quot; or &quot;-1&quot;,
modalityID can be anything (&quot;truth&quot; is a good choice),
and score should be 0 for signal-absent normal case, 1 for signal-present disease case.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Delete rows specifying truth and put the truth information on every row.
</p>


<h3>Value</h3>

<p>output a data frame with columns readerID, caseID, modalityID, score, truth
</p>

<hr>
<h2 id='uStat11'>Analysis of U-statistics degree 1,1</h2><span id='topic+uStat11'></span><span id='topic+uStat11.jointD'></span><span id='topic+uStat11.conditionalD'></span>

<h3>Description</h3>

<p>These two functions calculate the mean and variance of a user-specified U-statistic kernel,
which is a function of cross-correlated scores.
</p>
<p>The motivation for this analysis is data collected in imaging studies
where multiple readers read multiple cases in different modes or modalities.
The goal is to evaluate the variance of a reader- and case-averaged endpoint,
accounting for cross-correlated data arising from two random effects:
the random reader skill and the random case difficulty.
This analysis is sometimes referred to as an MRMC analysis.
Of course, the random effects can be from sources other than readers and cases.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>uStat11.jointD(
  df.input,
  modalitiesToCompare,
  kernelFlag = 1,
  keyColumns = c("readerID", "caseID", "modalityID", "score")
)

uStat11.conditionalD(
  df.input,
  modalitiesToCompare,
  kernelFlag = 1,
  keyColumns = c("readerID", "caseID", "modalityID", "score")
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="uStat11_+3A_df.input">df.input</code></td>
<td>
<p>an iMRMC formatted data frame, see <a href="#topic+dfMRMC_example">dfMRMC_example</a></p>
</td></tr>
<tr><td><code id="uStat11_+3A_modalitiestocompare">modalitiesToCompare</code></td>
<td>
<p>The factors identifying the modalities to compare.</p>
</td></tr>
<tr><td><code id="uStat11_+3A_kernelflag">kernelFlag</code></td>
<td>
<p>This determines the kernel function
</p>

<ul>
<li><p><code>kernelFlag</code> = 1 == identity kernel: requires two modalities: A,B.
</p>
</li>
<li><p><code>kernelFlag</code> = 2 == kernel of the difference in modalities: requires four modalities: A,B,C,D.
</p>
</li></ul>
</td></tr>
<tr><td><code id="uStat11_+3A_keycolumns">keyColumns</code></td>
<td>
<p>Identify the factors corresponding to the readerID, caseID, modalityID, and score
(or alternative random and fixed effects).</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>uStat11.conditionalD</code> is identical to <code>uStat11.jointD</code> when the study is fully-crossed:
when every reader readers all the cases in both modalities. For arbitrary study designs
the two functions differ according to how the components of variance are estimated.
</p>

<ul>
<li><p><code>uStat11.conditionalD</code> follows Gallas2007_J-Opt-Soc-Am-A_v24pB70
&lt;doi:10.1364/JOSAA.24.000B70&gt; and estimates the components of variance
(which isolate combinations of different random effects) with nested conditional means.
</p>
</li>
<li><p><code>uStat11.jointD</code> is analogous to the method in Gallas2008_Neural-Networks_v21p387
&lt;doi:10.1016/j.neunet.2007.12.013&gt; and estimates the components of variance
(which isolate combinations of different random effects) with a joint distribution over all
the observations giving equal weight to each one.
</p>
</li></ul>

<p>Both functions yield unbiased variance estimates.
Our simulations find that <code>uStat11.conditionalD</code> is statistically more efficient than
<code>uStat11.jointD</code> (its variance estimate is more precise), but it is slower.
</p>
<p>Please refer to the tests/testthat folder of the package for examples using these functions.
</p>


<h3>Value</h3>

<p>This function calculates the mean and variance of the indicated U-statistic kernel,
which is a function of the scores. For the identity kernel, we simply return the mean
and variance of the scores.
</p>
<p>The function returns a list of outputs. Many of these outputs have three elements.
</p>

<ul>
<li><p> If <code>kernelFlag</code> = 1 == identity kernel, the first element corresponds to the mean score of
modality A, the second corresponds to mean score of modality B,
and the third corresponds to the mean of the difference in scores from modality A and B.
</p>
</li>
<li><p>  If <code>kernelFlag</code> = 2 == difference kernel, the first element corresponds to the
mean difference in scores from modalities A and B, the second element corresponds to
the mean difference in scores from modalities C and D, and the third elements corresponds
to the difference of the just-mentioned differences.
</p>
</li></ul>

<p>There are 16 outputs:
</p>

<ul>
<li><p><code>mean:</code> See description above.
</p>
</li>
<li><p><code>var:</code> The variance of the mean.
</p>
</li>
<li><p><code>var.1obs:</code> The variance of one reader-case-modality observation.
</p>
</li>
<li><p><code>meanPerR</code> The reader-specific means.
</p>
</li>
<li><p><code>nR</code> The number of readers in the study.
</p>
</li>
<li><p><code>nC</code> The number of cases in the study.
</p>
</li>
<li><p><code>nCperR</code> The number of cases evaluated by each reader for each modality.
</p>
</li>
<li><p><code>moments</code> The second order moments of the problem.
</p>
</li>
<li><p><code>coeff</code> The coefficients corresponding to the second-order moments such that
the scalar product between the moments and coefficients yields the variance.
</p>
</li>
<li><p><code>kernel.A</code> A matrix showing the kernel evaluated for each combination
of each reader and case for modality A (or AB).
</p>
</li>
<li><p><code>design.A</code> A matrix showing the what data exists for each combination
of each reader and case for modality A (or AB).
</p>
</li>
<li><p><code>kernel.B</code> A matrix showing the kernel evaluated for each combination
of each reader and case for modality B (or CD).
</p>
</li>
<li><p><code>design.B</code> A matrix showing the what data exists for each combination
of each reader and case for modality B (or CD).
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'># Create an MRMC data frame
# Refer to Gallas2014_J-Med-Img_v1p031006
simRoeMetz.config &lt;- sim.gRoeMetz.config()

# Simulate data
df.MRMC &lt;- sim.gRoeMetz(simRoeMetz.config)

# Reformat data
df &lt;- undoIMRMCdf(df.MRMC)

# Grab part of the data
df &lt;- droplevels(df[grepl("pos", df$caseID), ])

#### uStat11.jointD.identity ####
# Calculate the reader- and case-averaged difference in scores from testA and testB
# (kernelFlag = 1 specifies the U-statistics kernel to be the identity)
result.jointD.identity &lt;- uStat11.jointD(
  df,
  kernelFlag = 1,
  keyColumns = c("readerID", "caseID", "modalityID", "score"),
  modalitiesToCompare = c("testA", "testB"))

cat("\n")
cat("uStat11.jointD.identity \n")
print(result.jointD.identity[1:2])
</code></pre>

<hr>
<h2 id='uStat11.diff'>Create the kernel and design matrices for uStat11</h2><span id='topic+uStat11.diff'></span>

<h3>Description</h3>

<p>The kernel is the difference kernel
</p>


<h3>Usage</h3>

<pre><code class='language-R'>uStat11.diff(
  df.input,
  modalitiesToCompare,
  keyColumns = c("readerID", "caseID", "modalityID", "score")
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="uStat11.diff_+3A_df.input">df.input</code></td>
<td>
<p>Data frame of observations, one per row. Columns also identify random and fixed effects.</p>
</td></tr>
<tr><td><code id="uStat11.diff_+3A_modalitiestocompare">modalitiesToCompare</code></td>
<td>
<p>The factors identifying the modalities to compare</p>
</td></tr>
<tr><td><code id="uStat11.diff_+3A_keycolumns">keyColumns</code></td>
<td>
<p>The required columns</p>
</td></tr>
</table>

<hr>
<h2 id='uStat11.identity'>Create the kernel and design matrices for uStat11</h2><span id='topic+uStat11.identity'></span>

<h3>Description</h3>

<p>The kernel is the identity kernel
</p>


<h3>Usage</h3>

<pre><code class='language-R'>uStat11.identity(
  df.input,
  modalitiesToCompare,
  keyColumns = c("readerID", "caseID", "modalityID", "score")
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="uStat11.identity_+3A_df.input">df.input</code></td>
<td>
<p>Data frame of observations, one per row. Columns also identify random and fixed effects.</p>
</td></tr>
<tr><td><code id="uStat11.identity_+3A_modalitiestocompare">modalitiesToCompare</code></td>
<td>
<p>The factors identifying the modalities to compare</p>
</td></tr>
<tr><td><code id="uStat11.identity_+3A_keycolumns">keyColumns</code></td>
<td>
<p>The required columns</p>
</td></tr>
</table>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
