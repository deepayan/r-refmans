<!DOCTYPE html><html><head><title>Help for package bigmatch</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {bigmatch}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#check'><p>Check SMDs of the matched data set.</p></a></li>
<li><a href='#edgenum'><p>Computes the number of edges in the reduced bipartite.</p></a></li>
<li><a href='#findexact'><p>Build an exact match variable given a matrix of covariates ordered by the user according to their importance.</p></a></li>
<li><a href='#glover'><p>Maximum matching in a convex bipartite graph.</p></a></li>
<li><a href='#nearfine'><p>Minimum-distance near-fine matching.</p></a></li>
<li><a href='#netfine'><p>Optimal near-fine match from a distance matrix.</p></a></li>
<li><a href='#nfmatch'><p>Minimum-distance near-fine matching.</p></a></li>
<li><a href='#nh0506'>
<p>Smoking and homocysteine levels in NHANES 2005-2006.</p></a></li>
<li><a href='#optcal'><p>Finds the optimal caliper width.</p></a></li>
<li><a href='#optconstant'><p>Finds the optimal constant.</p></a></li>
<li><a href='#smahal'><p>Creates a robust Mahalanobis distance for matching.</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Making Optimal Matching Size-Scalable Using Optimal Calipers</td>
</tr>
<tr>
<td>Version:</td>
<td>0.6.4</td>
</tr>
<tr>
<td>Author:</td>
<td>Ruoqi Yu</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Ruoqi Yu &lt;ruoqiyu125@gmail.com&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Implements optimal matching with near-fine balance in large observational studies with the use of optimal calipers to get a sparse network. The caliper is optimal in the sense that it is as small as possible such that a matching exists. The main functions in the 'bigmatch' package are optcal() to find the optimal caliper, optconstant() to find the optimal number of nearest neighbors, and nfmatch() to find a near-fine balance match with a caliper and a restriction on the number of nearest neighbors. 
    Yu, R., Silber, J. H., and Rosenbaum, P. R. (2020). &lt;<a href="https://doi.org/10.1214%2F19-sts699">doi:10.1214/19-sts699</a>&gt;. </td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://opensource.org/licenses/mit-license.php">MIT</a> + file LICENSE</td>
</tr>
<tr>
<td>Additional_repositories:</td>
<td><a href="https://errickson.net/rrelaxiv/">https://errickson.net/rrelaxiv/</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>Imports:</td>
<td>rcbalance, stats, liqueueR, plyr, mvnfast, methods</td>
</tr>
<tr>
<td>Suggests:</td>
<td>optmatch, rrelaxiv</td>
</tr>
<tr>
<td>Note:</td>
<td>The optmatch package, which is useful for running many of the
provided functions, may be downloaded from Github at
&lt;https://github.com/markmfredrickson/optmatch&gt; if not available
on CRAN. The rrelaxiv package, which provides an alternative
solver for the underlying network flow problems, carries an
academic license and is not available on CRAN, but may be
downloaded from Github at
&lt;https://github.com/josherrickson/rrelaxiv/&gt;.</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2022-07-26 05:08:43 UTC; ruoqiyu</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2022-08-11 07:40:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='check'>Check SMDs of the matched data set.</h2><span id='topic+check'></span>

<h3>Description</h3>

<p>The function is used to create a table of mean and SMDs to check the balance before and after matching.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>check(fdata, mdata, fz, mz)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="check_+3A_fdata">fdata</code></td>
<td>
<p> A full data frame with length(fz) rows and columns being variables that need to check SMDs. fdata and mdata must have the same variables with same column names in the same order.</p>
</td></tr>
<tr><td><code id="check_+3A_mdata">mdata</code></td>
<td>
<p> A matched data frame with length(mz) rows and columns being variables that need to check SMDs. fdata and mdata must have the same variables with same column names in the same order.</p>
</td></tr>
<tr><td><code id="check_+3A_fz">fz</code></td>
<td>
<p> A vector whose ith coordinate is 1 for a treated unit and is 0 for a control for subjects in the full data set.</p>
</td></tr>
<tr><td><code id="check_+3A_mz">mz</code></td>
<td>
<p> A vector whose ith coordinate is 1 for a treated unit and is 0 for a control for subjects in the matched data set.</p>
</td></tr>
</table>


<h3>Value</h3>

<p> A matrix with a row for each variable and five columns being the mean of treated group, mean of matched control group, mean of full control group, SMD of matched control group and SMD of full control group.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># To run this example, you must load the optmatch package.

# Caliper of .2 on the propensity score, near fine balance of
# education, a robust Mahalanobis distrance for X.
data(nh0506)
attach(nh0506)
X&lt;-cbind(female,age,black,hispanic,education,povertyr,bmi)
m&lt;-nfmatch(z=z,p=propens,fine=education,X=X,caliper=.2,dat=nh0506,rank=FALSE)
matcheddata&lt;-m$data
Xm&lt;-subset(matcheddata, select=c('female','age','black','hispanic','education','povertyr','bmi'))
check(X,Xm,z,matcheddata$z)
detach(nh0506)
</code></pre>

<hr>
<h2 id='edgenum'>Computes the number of edges in the reduced bipartite.</h2><span id='topic+edgenum'></span>

<h3>Description</h3>

<p>Computes the number of edges in the reduced bipartite graph after applying the caliper and number of nearest neighbors (constant).
</p>
<p>This function can provide users some idea of the required computation time. Smaller caliper and constant removes more edges, hence accelarates computation, but risks infeasibility.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>edgenum(z, p, caliper, constant=NULL, exact=NULL,
ties.all=TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="edgenum_+3A_z">z</code></td>
<td>
<p> A vector whose ith coordinate is 1 for a treated unit and is 0 for a control. </p>
</td></tr>
<tr><td><code id="edgenum_+3A_p">p</code></td>
<td>
<p> A vector of length(z)=length(p) giving the variable used to define the caliper.  Typically, p is the propensity score or its rank.</p>
</td></tr>
<tr><td><code id="edgenum_+3A_caliper">caliper</code></td>
<td>
<p> If two individuals differ on p by more than caliper, we will not calculate the distance for this pair.</p>
</td></tr>
<tr><td><code id="edgenum_+3A_constant">constant</code></td>
<td>
<p> If the number of pairs within a caliper is greater than constant, we will select the constant closest ones.</p>
</td></tr>
<tr><td><code id="edgenum_+3A_exact">exact</code></td>
<td>
<p> If not NULL, then a vector of length(z)=length(p) giving variable that need to be exactly matched. </p>
</td></tr>
<tr><td><code id="edgenum_+3A_ties.all">ties.all</code></td>
<td>
<p> If ties.all is True, include all ties while choosing nearest neighbors. In this case, some treated may have more than constant controls. Otherwise, randomly select one or several controls to make sure there are not more than constant controls for each treated.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A given choice of caliper and number of nearest neighbors (constant) removes candidate pairs, so there exists a corresponding reduced bipartite graph.
</p>
<p>Smaller caliper and constant removes more edges from the original dense graph, hence the computation is faster. However, this risks infeasibility. A smallest caliper that permits a feasible match and its corresponding smallest number of nearest neighbors can be computed by functions optcal() and optconstant().
</p>


<h3>Value</h3>

<p>Number of edges in the reduced bipartite graph with the constraints on caliper and number of nearest neighbors (constant).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(nh0506)
attach(nh0506)
edgenum(z,propens,0.2)

edgenum(z,propens,0.2,10,exact=female)

detach(nh0506)
</code></pre>

<hr>
<h2 id='findexact'>Build an exact match variable given a matrix of covariates ordered by the user according to their importance.</h2><span id='topic+findexact'></span>

<h3>Description</h3>

<p>The function is used to build an exact match variable given a matrix of covariates ordered by the user according to their importance. It will select as many important covariates as possible.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>findexact(z, E, ncontrol=1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="findexact_+3A_z">z</code></td>
<td>
<p> A vector whose ith coordinate is 1 for a treated unit and is 0 for a control.</p>
</td></tr>
<tr><td><code id="findexact_+3A_e">E</code></td>
<td>
<p> A matrix or a vector with length(z) rows giving the covariates that need to be exactly matched.</p>
</td></tr>
<tr><td><code id="findexact_+3A_ncontrol">ncontrol</code></td>
<td>
<p> The number of controls to be matched to each treated individual.</p>
</td></tr>
</table>


<h3>Value</h3>

<table>
<tr><td><code>miss</code></td>
<td>
<p> The covariates that cannot be exactly matched.</p>
</td></tr>
<tr><td><code>variables</code></td>
<td>
<p> The covariates that can be exactly matched.</p>
</td></tr>
<tr><td><code>NewExact</code></td>
<td>
<p> The constructed exact match variable.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>data(nh0506)
attach(nh0506)
# The following example uses all of the variables in the propensity score,propens
ex&lt;-findexact(z,cbind(female,age,education,black,hispanic,povertyr))
head(ex$miss)
head(ex$variables)
table(z,ex$NewExact)

# In order to exact match on age as well
# one option is to divide age into several levels
age_quantile&lt;-as.integer(cut(age,quantile(age,c(0,0.25,0.5,0.75,1))))
ex2&lt;-findexact(z,cbind(female,age_quantile,education,black,hispanic,povertyr,bmi))
head(ex2$miss)
head(ex2$variables)
table(z,ex2$NewExact)
detach(nh0506)
</code></pre>

<hr>
<h2 id='glover'>Maximum matching in a convex bipartite graph.</h2><span id='topic+glover'></span>

<h3>Description</h3>

<p>Uses Glover's (1967) algorithm to find a maximum matching in a doubly convex bipartite graph. The implementation uses a priority queue, not used by Glover, as in Lipski and Preparata (1981).
Of limited interest to most users; function glover() would typically be called by other functions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>glover(left, right)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="glover_+3A_left">left</code></td>
<td>
<p> Treated person i may be matched to controls j with left[i] &lt;= j &lt;= right[i]. There are length(left) treated individuals and length(left)=length(right). Must have left[i]&lt;=right[i] for every i.  Define maxc = max(right).  Then there are maxc potential control, labeled 1, 2,..., maxc.  The values in left and right are these labels for controls.</p>
</td></tr>
<tr><td><code id="glover_+3A_right">right</code></td>
<td>
<p> See left.  </p>
</td></tr>
</table>


<h3>Details</h3>

<p>The match produced by glover is rarely useful in observational studies, because it finds a match, not the closest match, not the minimum distance match.
</p>
<p>The glover algorithm may be used to find the smallest feasible caliper on a certain criterion.  Each caliper on the criterion creates a different convex bipartite graph. Use glover to check whether a particular caliper is feasible. Use bisection search to find the smallest caliper that permits a match. There are many variations on this theme.
</p>
<p>The glover algorithm is much faster than optimal matching.  Iterative use of glover's algorithm is often faster than a single minimum distance match.
</p>


<h3>Value</h3>

<p> The maximum matching ratio. A perfect matching has every treated individual i matched to a different control j with left[i] &lt;= j &lt;= right[i].  A perfect matching may not exist. A number smaller than 1 is returned if no perfect matching exists.  Otherwise, 1 is returned.</p>


<h3>References</h3>

<p>Glover, F. (1967). Maximum Matching In Convex Bipartite Graphs.  Naval Research Logistics Quarterly, 14, pp 313-316.
</p>
<p>Lipski, W., Jr, and Preparata, F. P. (1981). Efficient Algorithms For Finding Maximum Matchings In Convex Bipartite Graphs And Related Problems.  Journal Acta Informatica, 15, 4, pp 329-346.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># A perfect matching exists, and glover produces one.
left&lt;-c(2,1,1,4,5)
right&lt;-c(4,3,1,5,5)
glover(left,right)

# No perfect matching exists, and glover returns maximum matching ratio.
# Treated 4 and treated 5 can only be matched to control 5.

left&lt;-c(2,1,1,5,5)
right&lt;-c(4,3,1,5,5)
glover(left,right)
</code></pre>

<hr>
<h2 id='nearfine'>Minimum-distance near-fine matching.</h2><span id='topic+nearfine'></span>

<h3>Description</h3>

<p>The program finds an optimal near-fine match given a distance structure with from node (treated), to node (control), and distance between each pair.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>nearfine(z, fine, dist, dat, ncontrol=1, penalty=1000, max.cost=penalty/10,
nearexPenalty=max.cost, subX=NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="nearfine_+3A_z">z</code></td>
<td>
<p> A vector whose ith coordinate is 1 for a treated unit and is 0 for a control. Must have treated subjects (z=1) before controls (z=0).</p>
</td></tr>
<tr><td><code id="nearfine_+3A_fine">fine</code></td>
<td>
<p> A vector of with length(z)=length(fine) giving the nominal levels
that are to be nearly-finely balanced.</p>
</td></tr>
<tr><td><code id="nearfine_+3A_dist">dist</code></td>
<td>
<p> A distance list with the starting node (treated subjec), ending
node (control), the distance between them and whether nearexact is needed for each pair.</p>
</td></tr>
<tr><td><code id="nearfine_+3A_dat">dat</code></td>
<td>
<p> A data frame with length(z) rows.  One output of the program is
a data frame with some of the rows of dat for the matched sample, together
with additional columns describing the match.</p>
</td></tr>
<tr><td><code id="nearfine_+3A_ncontrol">ncontrol</code></td>
<td>
<p> A positive integer giving the number of controls to be
matched to each treated subject.</p>
</td></tr>
<tr><td><code id="nearfine_+3A_penalty">penalty</code></td>
<td>
<p> A numeric penalty imposed for each violation of fine balance.</p>
</td></tr>
<tr><td><code id="nearfine_+3A_max.cost">max.cost</code></td>
<td>
<p> The maximum cost for the each pair of treated and control
while rounding the cost. 2 times it is the cost for nearexact matching</p>
</td></tr>
<tr><td><code id="nearfine_+3A_nearexpenalty">nearexPenalty</code></td>
<td>
<p> The penalty for a mismatch on nearexact. If it is a number, then use the same penalty for all nearexact variables. Otherwise, it should be a vector of length the same as number of nearexact variables, indicating the penalty for mismatch on each nearexact variable. The larger nearexPenalty is, the more priorty the variable get in near-exact match.</p>
</td></tr>
<tr><td><code id="nearfine_+3A_subx">subX</code></td>
<td>
<p> If a subset matching is required, the variable that the subset matching is based on. That is, for each level of subX, extra treated will be discarded in order to have the number of matched treated subjects being the minimum size of treated and control groups. If exact matching on a variable x is desired and discarding extra treated is fine if there are more treated than controls for a certain level k, set exact=x, subX=x.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The match minimizes the total distance between treated subjects and their matched controls subject to a near-fine balance constraint imposed as a penalty on imbalances.
</p>
<p>The distance list only includes pairs closed based on the caliper, i.e. some edges are removed from the network. Because of this, the match may be infeasible. This is reported in feasible.
</p>
<p>For discussion of networks for fine-balance, see Rosenbaum (1989, Section 3) and Rosenbaum (2010).
</p>
<p>For near-fine balannce balance, see Yang et al. (2012).
</p>
<p>You MUST install and load the optmatch package to use nearfine().
</p>


<h3>Value</h3>

<table>
<tr><td><code>feasible</code></td>
<td>
<p> feasible=1 if the match is feasible or feasible=0 if the match
is infeasible.</p>
</td></tr>
<tr><td><code>timeinrelax</code></td>
<td>
<p> Time in RELAX IV spent computing the minimum cost flow.</p>
</td></tr>
<tr><td><code>timeinnet</code></td>
<td>
<p> Time in constructing the network.</p>
</td></tr>
<tr><td><code>timeinmatch</code></td>
<td>
<p> Time in constructing the matched dataset.</p>
</td></tr>
<tr><td><code>d</code></td>
<td>
<p> The matched sample. Selected rows of dat. The first column indicates which matched set the subject belongs to.</p>
</td></tr>
<tr><td><code>number</code></td>
<td>
<p> Number of edges between the treated subjects and controls in the reduced network.</p>
</td></tr>
</table>


<h3>References</h3>

<p>Bertsekas, D. P. and Tseng, P. (1988) The relax codes for linear minimum cost
network flow problems. Annals of Operations Research, 13, 125-190.  Fortran
and C code: http://www.mit.edu/~dimitrib/home.html.  Available in R via the
optmatch package.
</p>
<p>Rosenbaum, P.R. (1989) Optimal matching in observational studies. Journal of
the American Statistical Association, 84, 1024-1032.
</p>
<p>Rosenbaum, P. R. (2010) Design of Observational Studies.  New York: Springer.
</p>
<p>Yang, D., Small, D. S., Silber, J. H., and Rosenbaum, P. R. (2012) Optimal
matching with minimal deviation from fine balance in a study of obesity and
surgical outcomes.  Biometrics, 68, 628-636.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# To run this example, you must load the optmatch package.
data(nh0506)
attach(nh0506)
X&lt;-cbind(female,age,black,hispanic,education,povertyr)
dist&lt;-smahal(z,propens,X,0.2)
fine&lt;-education
m&lt;-nearfine(z,fine,dist,nh0506)
head(m$d)
detach(nh0506)

## End(Not run)
</code></pre>

<hr>
<h2 id='netfine'>Optimal near-fine match from a distance matrix.</h2><span id='topic+netfine'></span>

<h3>Description</h3>

<p>The function creates the network for optimal near-fine matching to be passed via callrelax to the Fortran code for Bertsekas and Tseng's (1988) Relax IV.
</p>
<p>Of limited interest to most users; function netfine() would typically be called by some other functions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>netfine(z, fine, dist, ncontrol=1, penalty=1000, max.cost=penalty/10,
nearexPenalty=max.cost, subX=NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="netfine_+3A_z">z</code></td>
<td>
<p> A vector whose ith coordinate is 1 for a treated unit and is 0 for
a control. </p>
</td></tr>
<tr><td><code id="netfine_+3A_fine">fine</code></td>
<td>
<p> A vector of with length(z)=length(fine) giving the nominal levels
that are to be nearly-finely balanced.</p>
</td></tr>
<tr><td><code id="netfine_+3A_dist">dist</code></td>
<td>
<p> A distance list with the starting node (treated subjec), ending
node (control), the distance between them and whether nearexact is needed for each pair.</p>
</td></tr>
<tr><td><code id="netfine_+3A_ncontrol">ncontrol</code></td>
<td>
<p> A positive integer giving the number of controls to be
matched to each treated subject.</p>
</td></tr>
<tr><td><code id="netfine_+3A_penalty">penalty</code></td>
<td>
<p> A numeric penalty imposed for each violation of fine balance.</p>
</td></tr>
<tr><td><code id="netfine_+3A_max.cost">max.cost</code></td>
<td>
<p> The maximum cost for the each pair of treated and control
while rounding the cost. </p>
</td></tr>
<tr><td><code id="netfine_+3A_nearexpenalty">nearexPenalty</code></td>
<td>
<p> The penalty for a mismatch on nearexact. If it is a number, then use the same penalty for all nearexact variables. Otherwise, it should be a vector of length the same as number of nearexact variables, indicating the penalty for mismatch on each nearexact variable. The larger nearexPenalty is, the more priorty the variable get in near-exact match.</p>
</td></tr>
<tr><td><code id="netfine_+3A_subx">subX</code></td>
<td>
<p> If a subset matching is required, the variable that the subset matching is based on. That is, for each level of subX, extra treated will be discarded in order to have the number of matched treated subjects being the minimum size of treated and control groups. If exact matching on a variable x is desired and discarding extra treated is fine if there are more treated than controls for a certain level k, set exact=x, subX=x.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The network contains a bipartite graph for treated and control subjects plus
additional nodes for fine balance categories, plus additional nodes accept
needed deviations from fine balance yielding near-fine balance.
</p>
<p>For discussion of fine-balance, see Rosenbaum (1989, Section 3) and Rosenbaum (2010).
For near-fine balance balance, see Yang et al. (2012).
</p>


<h3>Value</h3>

<p> A network for optimal near-fine matching.</p>


<h3>References</h3>

<p>Bertsekas, D. P. and Tseng, P. (1988) The relax codes for linear minimum cost
network flow problems. Annals of Operations Research, 13, 125-190.  Fortran
and C code: http://www.mit.edu/~dimitrib/home.html.  Available in R via the
optmatch package.
</p>
<p>Rosenbaum, P.R. (1989) Optimal matching in observational studies. Journal of
the American Statistical Association, 84, 1024-1032.
</p>
<p>Rosenbaum, P. R. (2010) Design of Observational Studies.  New York: Springer.
</p>
<p>Yang, D., Small, D. S., Silber, J. H., and Rosenbaum, P. R. (2012) Optimal
matching with minimal deviation from fine balance in a study of obesity and
surgical outcomes.  Biometrics, 68, 628-636.
</p>

<hr>
<h2 id='nfmatch'>Minimum-distance near-fine matching.</h2><span id='topic+nfmatch'></span>

<h3>Description</h3>

<p>The program finds an optimal near-fine match with a given caliper on p or rank of p.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>nfmatch(z, p, fine=rep(1,length(z)), X, dat, caliper, constant=NULL, ncontrol=1,
rank=TRUE, exact=NULL, penalty=1000, max.cost=penalty/10, nearexact=NULL,
nearexPenalty=max.cost, Xextra=NULL, weight=NULL, subX=NULL, ties.all=TRUE, seed=1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="nfmatch_+3A_z">z</code></td>
<td>
<p> A vector whose ith coordinate is 1 for a treated unit and is 0 for a control.</p>
</td></tr>
<tr><td><code id="nfmatch_+3A_p">p</code></td>
<td>
<p> A vector of with length(z)=length(p) giving the numeric values of the variable to be matched with a caliper.  Typically, p is the propensity score.  If p takes a few levels, exact matching for p is attempted if caliper=0. If no caliper is intended to apply, set p=rep(1,length(z)) and caliper=1.</p>
</td></tr>
<tr><td><code id="nfmatch_+3A_fine">fine</code></td>
<td>
<p> A vector of with length(z)=length(fine) giving the nominal levels that are to be nearly-finely balanced.</p>
</td></tr>
<tr><td><code id="nfmatch_+3A_x">X</code></td>
<td>
<p> A matrix of covariates used to create a robust Mahalanobis distance.  X must have length(z) rows.</p>
</td></tr>
<tr><td><code id="nfmatch_+3A_dat">dat</code></td>
<td>
<p> A data frame with length(z) rows.  If the match is feasible, the matched portion of dat is returned with additional columns that define the match.</p>
</td></tr>
<tr><td><code id="nfmatch_+3A_caliper">caliper</code></td>
<td>
<p> If two individuals differ on p by more than caliper, we will not calculate the distance for this pair.  If caliper is too small, the match may be infeasible. If no caliper is intended to apply, set p=rep(1,length(z)) and caliper=1.</p>
</td></tr>
<tr><td><code id="nfmatch_+3A_constant">constant</code></td>
<td>
<p> If there are more than constant controls for a treated differ on p within caliper, we select the constant closest controls.</p>
</td></tr>
<tr><td><code id="nfmatch_+3A_ncontrol">ncontrol</code></td>
<td>
<p> A positive integer giving the number of controls to be matched to each treated subject.  If ncontrol is too large, the match will be infeasible.</p>
</td></tr>
<tr><td><code id="nfmatch_+3A_rank">rank</code></td>
<td>
<p> An indicator of whether we want a caliper on rank of p or p.</p>
</td></tr>
<tr><td><code id="nfmatch_+3A_exact">exact</code></td>
<td>
<p> If not NULL, then a vector of length(z)=length(p) giving variable that need to be exactly matched. </p>
</td></tr>
<tr><td><code id="nfmatch_+3A_penalty">penalty</code></td>
<td>
<p> A numeric penalty imposed for each violation of fine balance.</p>
</td></tr>
<tr><td><code id="nfmatch_+3A_max.cost">max.cost</code></td>
<td>
<p> The maximum cost for the each pair of treated and control while rounding the cost.</p>
</td></tr>
<tr><td><code id="nfmatch_+3A_nearexact">nearexact</code></td>
<td>
<p> If not NULL, then a vector of length length(z) or matrix with length(z) rows giving variables that need to be exactly matched. If it is not possible to exactly match all variables, we will exactly match as many variables as we can.</p>
</td></tr>
<tr><td><code id="nfmatch_+3A_nearexpenalty">nearexPenalty</code></td>
<td>
<p> The penalty for a mismatch on nearexact. If it is a number, then use the same penalty for all nearexact variables. Otherwise, it should be a vector of length the same as number of nearexact variables, indicating the penalty for mismatch on each nearexact variable. The larger nearexPenalty is, the more priorty the variable get in near-exact match.</p>
</td></tr>
<tr><td><code id="nfmatch_+3A_xextra">Xextra</code></td>
<td>
<p> If not NULL, another robust Mahalanobis distance based on Xextra  is calculated. The distance between treated-control pair is a weighted sum of the two distances.</p>
</td></tr>
<tr><td><code id="nfmatch_+3A_weight">weight</code></td>
<td>
<p> The weight for Mahalanobis distance of Xextra.</p>
</td></tr>
<tr><td><code id="nfmatch_+3A_subx">subX</code></td>
<td>
<p> If a subset matching is required, the variable that the subset matching is based on. That is, for each level of subX, extra treated will be discarded in order to have the number of matched treated subjects being the minimum size of treated and control groups. If exact matching on a variable x is desired and discarding extra treated is fine if there are more treated than controls for a certain level k, set exact=x, subX=x.</p>
</td></tr>
<tr><td><code id="nfmatch_+3A_ties.all">ties.all</code></td>
<td>
<p> If ties.all is True, include all ties while choosing nearest neighbors. In this case, some treated may have more than constant controls. Otherwise, randomly select one or several controls to make sure there are not more than constant controls for each treated.</p>
</td></tr>
<tr><td><code id="nfmatch_+3A_seed">seed</code></td>
<td>
<p> When ties.all is False, seed for randomly select one or several controls when there are ties.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The match minimizes the total distance between treated subjects and their matched controls
subject to a near-fine balance constraint imposed as a penalty on imbalances.
</p>
<p>For discussion of networks for fine-balance, see Rosenbaum (1989, Section 3) and Rosenbaum (2010).
For near-fine balannce balance, see Yang et al. (2012).
</p>
<p>You MUST install and load the optmatch package to use nearfine.
</p>


<h3>Value</h3>

<p>If the match is infeasible, a warning is issued.  Otherwise, a list of results is returned.
</p>
<p>A match may be infeasible if the caliper is too small, or ncontrol is too large, or if exact matching for exact is impossible.
</p>
<table>
<tr><td><code>data</code></td>
<td>
<p>The matched sample.  Selected rows of dat.</p>
</td></tr>
<tr><td><code>timeinrelax</code></td>
<td>
<p>Time in RELAX IV spent computing the minimum cost flow.</p>
</td></tr>
<tr><td><code>edgenum</code></td>
<td>
<p> Number of edges between the treated subjects and controls in
the reduced network.</p>
</td></tr>
<tr><td><code>timeind</code></td>
<td>
<p>Time in calculating robust Mahalanobis distance between connected pairs.</p>
</td></tr>
<tr><td><code>timeinnet</code></td>
<td>
<p>Time in constructing the network.</p>
</td></tr>
<tr><td><code>timeinmatch</code></td>
<td>
<p>Time in constructing the matched dataset.</p>
</td></tr>
</table>


<h3>References</h3>

<p>Bertsekas, D. P. and Tseng, P. (1988) The relax codes for linear minimum cost network flow problems. Annals of Operations Research, 13, 125-190.  Fortran and C code: http://www.mit.edu/~dimitrib/home.html.  Available in R via the optmatch package.
</p>
<p>Rosenbaum, P.R. (1989) Optimal matching in observational studies. Journal of the American Statistical Association, 84, 1024-1032.
</p>
<p>Rosenbaum, P. R. (2010) Design of Observational Studies.  New York: Springer.
</p>
<p>Yang, D., Small, D. S., Silber, J. H., and Rosenbaum, P. R. (2012) Optimal matching with minimal deviation from fine balance in a study of obesity and surgical outcomes.  Biometrics, 68, 628-636.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># To run this example, you must load the optmatch package.

# Caliper of .3 on the propensity score, near fine balance of
# education, a robust Mahalanobis distrance for X.
data(nh0506)
attach(nh0506)
X&lt;-cbind(female,age,black,hispanic,education,povertyr,bmi)
m&lt;-nfmatch(z=z,p=propens,fine=education,X=X,caliper=.3,dat=nh0506,rank=FALSE)
matcheddata=m$data
table(matcheddata$z,matcheddata$education)
head(matcheddata)
detach(nh0506)

  #finds the optimal caliper for the propensity score while exact matching on female
  #near fine balance for education and hispanic jointly.
  data(nh0506)
  attach(nh0506)
  X&lt;-cbind(female,age,black,hispanic,education,povertyr,bmi)

  oc&lt;-optcal(z,propens,exact=female,tol=0.1,rank=FALSE)
  oc
  oco&lt;-optconstant(z,propens,oc$caliper,exact=female,rank=FALSE)
  oco
  m2&lt;-nfmatch(z,propens,factor(hispanic):factor(education),X,nh0506,oc$caliper,oco$constant,
              exact=female,rank=FALSE)

  matcheddata2=m2$data
  table(matcheddata2$z,matcheddata2$female)
  table(matcheddata2$z,matcheddata2$education)
  table(matcheddata2$z,matcheddata2$education,matcheddata2$hispanic)

  #finds the optimal caliper for the propensity score while exact matching on female
  #nearexact on quantiles of povertyr and bmi
  #near fine balance for education and hispanic jointly.
  pq=cut(povertyr,c(-0.1,1,2,3,4,5))
  bq=cut(bmi,(0:7)*20)
  #first assume povertyr and bmi are of the same importance
  m3&lt;-nfmatch(z,propens,factor(hispanic):factor(education),X,nh0506,oc$caliper,oco$constant,
              exact=female,nearexact=cbind(pq,bq),rank=FALSE)
  matcheddata3=m3$data
  head(matcheddata3)

  #then assume povertyr is more important than bmi
  m4&lt;-nfmatch(z,propens,factor(hispanic):factor(education),X,nh0506,oc$caliper,oco$constant,
              exact=female,nearexact=cbind(pq,bq),nearexPenalty=c(100,50),rank=FALSE)
  matcheddata4=m4$data
  head(matcheddata4)
  detach(nh0506)

</code></pre>

<hr>
<h2 id='nh0506'>
Smoking and homocysteine levels in NHANES 2005-2006.
</h2><span id='topic+nh0506'></span>

<h3>Description</h3>

<p>Bazzano et al. (2003) noted higher homocysteine levels in smokers than in nonsmokers.  See also Pimentel et al. (2016) for a related analysis.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data("nh0506")</code></pre>


<h3>Format</h3>

<p>A data frame with 2475 observations on the following 32 variables.
</p>

<dl>
<dt><code>Row</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>SEQN</code></dt><dd><p>NHANES id number</p>
</dd>
<dt><code>female</code></dt><dd><p>1 if female, 0 if male</p>
</dd>
<dt><code>age</code></dt><dd><p>age in years, &gt;=20</p>
</dd>
<dt><code>black</code></dt><dd><p>1 if black, 0 otherwise</p>
</dd>
<dt><code>hispanic</code></dt><dd><p>1 if hispanic, 0 otherwise</p>
</dd>
<dt><code>education</code></dt><dd><p>Education</p>
</dd>
<dt><code>povertyr</code></dt><dd><p>Ratio of family income to the poverty level, capped at 5x</p>
</dd>
<dt><code>creactiveprotein</code></dt><dd><p>creactive protein</p>
</dd>
<dt><code>homocysteine</code></dt><dd><p>homocysteine</p>
</dd>
<dt><code>cotinine</code></dt><dd><p>cotinine in blood</p>
</dd>
<dt><code>cadmium</code></dt><dd><p>cadmium in blood</p>
</dd>
<dt><code>lead</code></dt><dd><p>lead in blood</p>
</dd>
<dt><code>bmi</code></dt><dd><p>Body mass index</p>
</dd>
<dt><code>cigs100life</code></dt><dd><p>1 if smoked more than 100 cigarettes in lifetime, 0 otherwise</p>
</dd>
<dt><code>smokenow</code></dt><dd><p>1 if smokes now, 0 otherwise</p>
</dd>
<dt><code>cigsdays30</code></dt><dd><p>Days smoked in last 30 days: 0 if never smoker, 30 if daily smoker</p>
</dd>
<dt><code>cigsperday30</code></dt><dd><p>Cigarettes smoked per day in last 30 days</p>
</dd>
<dt><code>tobacco5days</code></dt><dd><p>1 =  used tobacco in the last 30 days, 0 otherwise</p>
</dd>
<dt><code>dailysmoker</code></dt><dd><p>1 = daily smoker, 0 = never smoker</p>
</dd>
<dt><code>neversmoker</code></dt><dd><p>1 = never smoker, 0 = daily smoker</p>
</dd>
<dt><code>z</code></dt><dd><p>1 if daily smoker, 0 if never smoker</p>
</dd>
<dt><code>propens</code></dt><dd><p>Estimated propensity score.  The score was formed
by logit regression of z on female, age, education, black, hispanic, povertyr, and bmi.</p>
</dd>
<dt><code>pstrat</code></dt><dd><p>Propensity score strata: <code>(0,0.0733]</code> <code>(0.0733,0.131]</code> <code>(0.131,0.204]</code> <code>(0.204,0.33]</code> <code>(0.33,1]</code></p>
</dd>
<dt><code>age3</code></dt><dd><p>Age in 3 categories</p>
</dd>
<dt><code>ed3</code></dt><dd><p>Education in 3 categories</p>
</dd>
<dt><code>bmi3</code></dt><dd><p>BMI in 3 categories</p>
</dd>
<dt><code>pov2</code></dt><dd><p>Income above 2 times poverty, TRUE or FALSE</p>
</dd>
<dt><code>stf</code></dt><dd><p>A factor defining strata using female, age3, ed3, bmi3 pov2. </p>
</dd>
<dt><code>st</code></dt><dd><p>A numeric version of stf</p>
</dd>
<dt><code>stfp</code></dt><dd><p>A factor defining strata using stf and pstrat</p>
</dd>
<dt><code>stp</code></dt><dd><p>A numeric version of stp</p>
</dd>
</dl>



<h3>Details</h3>

<p>Data from NHANES 2005-2006 concerning homocysteine levels in daily smokers (z=1) and never smokers (z=0), aged 20 and older.  Daily smokers smoked every day for the last 30 days, smoking an average of at least 10 cigarettes per day.  Never smokers smoked fewer than 100 cigarettes in their lives, do not smoke now, and had no tobacco use in the previous 5 days.
</p>


<h3>Source</h3>

<p>NHANES, the US National Health and Nutrition Examination Survey, 2005-2006.
</p>


<h3>References</h3>

<p>Bazzano, L. A., He, J., Muntner, P., Vupputuri, S. and Whelton, P. K. (2003) Relationship between cigarette smoking and novel risk factors for cardiovascular disease in the United States.  Annals of Internal Medicine, 138, 891-897.
</p>
<p>Pimentel, S. D., Small, D. S. and Rosenbaum, P. R. (2016) Constructed second control groups and attenuation of unmeasured biases.  Journal of the American Statistical Association, 111, 1157-1167.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(nh0506)
</code></pre>

<hr>
<h2 id='optcal'>Finds the optimal caliper width.</h2><span id='topic+optcal'></span>

<h3>Description</h3>

<p>Finds the smallest caliper on variable p or rank of p such that a treated-control matching with that caliper exists.  If exact is not NULL, then finds the smallest caliper on p or rank of p such that a treated-control matching with that caliper exists while also matching exactly for the variable exact.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>optcal(z, p, exact=NULL, ncontrol=1, tol=NULL, rank=TRUE, subX=NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="optcal_+3A_z">z</code></td>
<td>
<p> A vector whose ith coordinate is 1 for a treated unit and is 0 for a control.</p>
</td></tr>
<tr><td><code id="optcal_+3A_p">p</code></td>
<td>
<p> A vector with the same length as z. The best caliper for p is found. Often p is the propensity score.</p>
</td></tr>
<tr><td><code id="optcal_+3A_exact">exact</code></td>
<td>
<p> If exact is NULL, then there is no exact matching, and the caliper refers to p alone.  Otherwise, exact is a vector of the same length as z for exact matching, such that two individuals, i and j, can be matched only if they have the same value of exact, exact[i]=exact[j].  In this case, the caliper is best among calipers that permit exact matching for exact.  Typically, exact has a moderate number of possible values, far fewer than length(z).</p>
</td></tr>
<tr><td><code id="optcal_+3A_ncontrol">ncontrol</code></td>
<td>
<p> A positive integer giving the number of controls to be matched to each treated subject.  If ncontrol is too large, the match will be infeasible.</p>
</td></tr>
<tr><td><code id="optcal_+3A_tol">tol</code></td>
<td>
<p> The tolerance.  The optimal caliper is determined with an error of at most tol.  tol=0.01 might be used for the propensity score, as it takes values between 0 and 1, whereas tol=1/2 for p=age would mean that the caliper for age errs by at most half a year.</p>
</td></tr>
<tr><td><code id="optcal_+3A_rank">rank</code></td>
<td>
<p> An indicator of whether we want a caliper on rank of p or p.</p>
</td></tr>
<tr><td><code id="optcal_+3A_subx">subX</code></td>
<td>
<p> If a subset matching is required, the variable that the subset matching is based on. That is, for each level of subX, extra treated will be discarded in order to have the number of matched treated subjects being the minimum size of treated and control groups. If exact matching on a variable x is desired and discarding extra treated is fine if there are more treated than controls for a certain level k, set exact=x, subX=x.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The method uses binary search to find the optimal caliper.  At each step in the search, it applies Glover's algorithm to determine whether a proposed caliper is feasible.
</p>
<p>Often, we need a small and feasible caliper, but we do not need to determine the optimal caliper very precisely.  Making tol larger will reduce the number of steps in the binary search.
</p>


<h3>Value</h3>

<table>
<tr><td><code>caliper</code></td>
<td>
<p>The optimal caliper, with an error of at most tol.  This caliper is a little too large, at most tol too large, but because its error is on the high side, a match with this caliper does exist.</p>
</td></tr>
<tr><td><code>interval</code></td>
<td>
<p>An interval that contains the best caliper. The upper bound of the interval was returned as caliper above.</p>
</td></tr>
<tr><td><code>interval.length</code></td>
<td>
<p>The length of interval. By definition, length.interval&lt;=tol.</p>
</td></tr>
</table>


<h3>References</h3>

<p>Glover, F. (1967). Maximum Matching In Convex Bipartite Graphs.  Naval Research Logistics Quarterly, 14, pp 313-316.
</p>
<p>Lipski, W., Jr, and Preparata, F. P. (1981). Efficient Algorithms For Finding Maximum Matchings In Convex Bipartite Graphs And Related Problems.  Journal Acta Informatica, 15, 4, pp 329-346.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(nh0506)
attach(nh0506)

#optimal caliper using the propensity score alone
optcal(z,propens,tol=0.1,rank=FALSE)

#optimal caliper using the rank of propensity score
#and match each treated subject with two controls

optcal(z,propens,ncontrol=2,rank=TRUE)


#optimal caliper for the propensity score while requiring
#an exact match for female
optcal(z,propens,exact=female,tol=0.1,rank=FALSE)

detach(nh0506)

</code></pre>

<hr>
<h2 id='optconstant'>Finds the optimal constant.</h2><span id='topic+optconstant'></span>

<h3>Description</h3>

<p>Finds the smallest constant k on variable p or rank of p such that a treated-control matching with that constant exists. If exact is not NULL, then finds the smallest constant on p or rank of p such that a treated-control matching with that constant exists while also matching exact for the variable exact. If caliper is NULL, we only consider match treated i to k controls with smallest difference of p or rank of p. If caliper is not NULL and there are more than k controls within that caliper for treated i, then we only consider match it to k controls with smallest difference of p or rank of p.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>optconstant(z, p, caliper=NULL, exact=NULL, ncontrol=1, tol=1, rank=TRUE,
subX=NULL, ties.all=TRUE, seed=1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="optconstant_+3A_z">z</code></td>
<td>
<p> A vector whose ith coordinate is 1 for a treated unit and is 0 for a control. </p>
</td></tr>
<tr><td><code id="optconstant_+3A_p">p</code></td>
<td>
<p> A vector with the same length as z.  The best constant for p is found. Often p is the propensity score.</p>
</td></tr>
<tr><td><code id="optconstant_+3A_caliper">caliper</code></td>
<td>
<p> If two individuals differ on p by more than caliper, there is no edge between this pair.  If caliper is too small, the match may be infeasible.</p>
</td></tr>
<tr><td><code id="optconstant_+3A_exact">exact</code></td>
<td>
<p> If exact is NULL, then there is no exact matching, and the constant refers to p alone.  Otherwise, exact is a vector of the same length as z for exact matching, such that two individuals, i and j, can be matched only if they have the same value of exact, exact[i]=exact[j].  In this case, the constant is best among calipers that permit exact matching for exact.  Typically, exact has a moderate number of possible values, far fewer than length(z).</p>
</td></tr>
<tr><td><code id="optconstant_+3A_ncontrol">ncontrol</code></td>
<td>
<p> A positive integer giving the number of controls to be matched to each treated subject.  If ncontrol is too large, the match will be infeasible.</p>
</td></tr>
<tr><td><code id="optconstant_+3A_tol">tol</code></td>
<td>
<p> The tolerance.  The optimal constant is determined with an error of at most tol.</p>
</td></tr>
<tr><td><code id="optconstant_+3A_rank">rank</code></td>
<td>
<p> An indicator of whether we want a constant on rank of p or p.</p>
</td></tr>
<tr><td><code id="optconstant_+3A_subx">subX</code></td>
<td>
<p> If a subset matching is required, the variable that the subset matching is based on. That is, for each level of subX, extra treated will be discarded in order to have the number of matched treated subjects being the minimum size of treated and control groups. If exact matching on a variable x is desired and discarding extra treated is fine if there are more treated than controls for a certain level k, set exact=x, subX=x.</p>
</td></tr>
<tr><td><code id="optconstant_+3A_ties.all">ties.all</code></td>
<td>
<p> If ties.all is True, include all ties while choosing nearest neighbors. In this case, some treated may have more than constant controls. Otherwise, randomly select one or several controls to make sure there are not more than constant controls for each treated.</p>
</td></tr>
<tr><td><code id="optconstant_+3A_seed">seed</code></td>
<td>
<p> When ties.all is False, seed for randomly select one or several controls when there are ties.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The method uses binary search to find the optimal constant.  At each step in the search, it applies Glover's algorithm to determine whether a proposed constant is feasible.
</p>
<p>Often, we need a small and feasible constant, but we do not need to determine the optimal constant very precisely.  Making tol larger will reduce the number of steps in the binary search.
</p>


<h3>Value</h3>

<table>
<tr><td><code>constant</code></td>
<td>
<p>The optimal constant, with an error of at most tol.  This constant is a little too large, at most tol too large, but because its error is on the high side, a match with this constant does exist.</p>
</td></tr>
<tr><td><code>interval</code></td>
<td>
<p>An interval that contains the best constant.  The upper bound of the interval was returned as constant above.</p>
</td></tr>
<tr><td><code>interval.length</code></td>
<td>
<p>The length of interval.  By definition, length.interval&lt;=tol.</p>
</td></tr>
</table>


<h3>References</h3>

<p>Glover, F. (1967). Maximum Matching In Convex Bipartite Graphs.  Naval Research Logistics Quarterly, 14, pp 313-316.
</p>
<p>Lipski, W., Jr, and Preparata, F. P. (1981). Efficient Algorithms For Finding Maximum Matchings In Convex Bipartite Graphs And Related Problems.  Journal Acta Informatica, 15, 4, pp 329-346.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(nh0506)
attach(nh0506)

#optimal constant using the propensity score alone
optconstant(z,propens,rank=FALSE)

#optimal constant for the propensity score while requiring
#an exact match for female
optconstant(z,propens,exact=female,rank=FALSE)

#optimal constant for the propensity score given a caliper
oc=optcal(z,propens,tol=0.1,rank=FALSE)
optconstant(z,propens,caliper=oc$caliper,rank=FALSE)
detach(nh0506)

</code></pre>

<hr>
<h2 id='smahal'>Creates a robust Mahalanobis distance for matching.</h2><span id='topic+smahal'></span>

<h3>Description</h3>

<p>Computes a robust Mahalanobis distance list for use in matching.
</p>
<p>This function and its use are discussed in Rosenbaum (2010).  The robust
Mahalanobis distance in described in Chapter 8 of Rosenbaum (2010).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>smahal(z, p, X, caliper, constant=NULL, ncontrol=1, exact=NULL,
nearexact=NULL, nearexPenalty=100, Xextra=NULL, weight=NULL, subX=NULL, ties.all=TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="smahal_+3A_z">z</code></td>
<td>
<p> A vector whose ith coordinate is 1 for a treated unit and is 0 for a control. </p>
</td></tr>
<tr><td><code id="smahal_+3A_p">p</code></td>
<td>
<p> A vector of length(z)=length(p) giving the variable used to define the caliper.  Typically, p is the propensity score or its rank.</p>
</td></tr>
<tr><td><code id="smahal_+3A_x">X</code></td>
<td>
<p> A matrix with length(z) rows giving the covariates.  X should be of full column rank.</p>
</td></tr>
<tr><td><code id="smahal_+3A_caliper">caliper</code></td>
<td>
<p> If two individuals differ on p by more than caliper, we will not calculate the distance for this pair.</p>
</td></tr>
<tr><td><code id="smahal_+3A_constant">constant</code></td>
<td>
<p> If the number of pairs within a caliper is greater than constant, we will select the constant closest ones.</p>
</td></tr>
<tr><td><code id="smahal_+3A_ncontrol">ncontrol</code></td>
<td>
<p> A positive integer giving the number of controls to be matched to each treated subject.  If ncontrol is too large, the match will be infeasible.</p>
</td></tr>
<tr><td><code id="smahal_+3A_exact">exact</code></td>
<td>
<p> If not NULL, then a vector of length(z)=length(p) giving variable that need to be exactly matched. </p>
</td></tr>
<tr><td><code id="smahal_+3A_nearexact">nearexact</code></td>
<td>
<p> If not NULL, then a vector of length length(z) or matrix with length(z) rows giving variables that need to be exactly matched. If it is not possible to exactly match all variables, we will exactly match as many variables as we can.</p>
</td></tr>
<tr><td><code id="smahal_+3A_nearexpenalty">nearexPenalty</code></td>
<td>
<p> Penalty for mismatch on nearexact if nearexact is not NULL.</p>
</td></tr>
<tr><td><code id="smahal_+3A_xextra">Xextra</code></td>
<td>
<p> If not NULL, another robust Mahalanobis distance based on Xextra is calculated. The distance between treated-control pair is a weighted sum of the two distances.</p>
</td></tr>
<tr><td><code id="smahal_+3A_weight">weight</code></td>
<td>
<p> The weight for Mahalanobis distance of Xextra.</p>
</td></tr>
<tr><td><code id="smahal_+3A_subx">subX</code></td>
<td>
<p> If a subset matching is required, the variable that the subset matching is based on. That is, for each level of subX, extra treated will be discarded in order to have the number of matched treated subjects being the minimum size of treated and control groups. If exact matching on a variable x is desired and discarding extra treated is fine if there are more treated than controls for a certain level k, set exact=x, subX=x.</p>
</td></tr>
<tr><td><code id="smahal_+3A_ties.all">ties.all</code></td>
<td>
<p> If ties.all is True, include all ties while choosing nearest neighbors. In this case, some treated may have more than constant controls. Otherwise, randomly select one or several controls to make sure there are not more than constant controls for each treated.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The usual Mahalanobis distance works well for multivariate Normal covariates, but can exhibit odd behavior with typical covariates. Long tails or an outlier in a covariate can yield a large estimated
variance, so the usual Mahalanobis distance pays little attention to large differences in this covariate. Rare binary covariates have a small variance, so a mismatch on a rare binary covariate is
viewed by the usual Mahalanobis distance as extremely important. If you were matching for binary covariates indicating US state of residence, the usual Mahalanobis distance would regard a
mismatch for Wyoming as much worse than a mismatch for California.
</p>
<p>The robust Mahalanobis distance uses ranks of covariates rather than the covariates themselves, but the variances of the ranks are not adjusted for ties, so ties do not make a variable more important. Binary covariates are, of course, heavily tied.
</p>


<h3>Value</h3>

<table>
<tr><td><code>d</code></td>
<td>
<p> A distance list for each pair within the caliper distance and constant constraint.</p>
</td></tr>
<tr><td><code>start</code></td>
<td>
<p> The treated subject for each distance.</p>
</td></tr>
<tr><td><code>end</code></td>
<td>
<p> The control subject for each distance.</p>
</td></tr>
<tr><td><code>nearex</code></td>
<td>
<p> A vector or matrix with the same dimesion as nearexact. Its entry is TRUE for a connected pair whose nearexact variable values are different and is FALSE otherwise. </p>
</td></tr>
</table>


<h3>References</h3>

<p>Rosenbaum, P. R. (2010) Design of Observational Studies.  New York: Springer.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(nh0506)
attach(nh0506)
X&lt;-cbind(female,age,black,hispanic,education,povertyr)
dist&lt;-smahal(z,propens,X,0.2)
dist$d[1:10]

dist2&lt;-smahal(z,propens,X,0.2,exact=female,Xextra=hispanic,nearexact=bmi)
dist2$nearex[1:10]

detach(nh0506)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
