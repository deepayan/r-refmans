<!DOCTYPE html><html><head><title>Help for package gestalt</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {gestalt}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#compose'><p>Compose Functions</p></a></li>
<li><a href='#constant'><p>Values as Functions</p></a></li>
<li><a href='#context'><p>Run an Action in an Ordered Context</p></a></li>
<li><a href='#fn'><p>Function Declarations with Quasiquotation</p></a></li>
<li><a href='#gestalt-package'><p>gestalt: Tools for Making and Combining Functions</p></a></li>
<li><a href='#partial'><p>Fix a Number of Arguments to a Function</p></a></li>
<li><a href='#posure'><p>Variable Composite Functions</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Title:</td>
<td>Tools for Making and Combining Functions</td>
</tr>
<tr>
<td>Version:</td>
<td>0.2.0</td>
</tr>
<tr>
<td>Description:</td>
<td>Provides a suite of function-building tools centered around a
  (forward) composition operator, %&gt;&gt;&gt;%, which extends the semantics of the
  'magrittr' %&gt;% operator and supports 'Tidyverse' quasiquotation. It enables
  you to construct composite functions that can be inspected and transformed as
  list-like objects. In conjunction with %&gt;&gt;&gt;%, a compact function constructor,
  fn(), and a partial-application constructor, partial(), are also provided;
  both support quasiquotation.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://opensource.org/licenses/mit-license.php">MIT</a> + file LICENSE</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/egnha/gestalt">https://github.com/egnha/gestalt</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/egnha/gestalt/issues">https://github.com/egnha/gestalt/issues</a></td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.3.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>rlang (&ge; 1.0.0), utils</td>
</tr>
<tr>
<td>Suggests:</td>
<td>magrittr (&ge; 1.5), testthat (&ge; 3.0.0), knitr, rmarkdown</td>
</tr>
<tr>
<td>Collate:</td>
<td>'gestalt.R' 'utils.R' 'closure.R' 'compose.R' 'constant.R'
'partial.R' 'fn.R' 'context.R' 'posure.R'</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.0</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>ByteCompile:</td>
<td>true</td>
</tr>
<tr>
<td>Config/testthat/edition:</td>
<td>3</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2022-08-22 14:22:53 UTC; eha</td>
</tr>
<tr>
<td>Author:</td>
<td>Eugene Ha [aut, cre]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Eugene Ha &lt;eha@posteo.de&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2022-08-22 15:00:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='compose'>Compose Functions</h2><span id='topic+compose'></span><span id='topic++25+3E+3E+3E+25'></span>

<h3>Description</h3>

<p>To compose functions,
</p>

<ul>
<li><p> Use <code>compose()</code>:
</p>
<div class="sourceCode"><pre>  compose(f, g, h, ...)
</pre></div>
<p>This makes the function that applies <code>f</code>, then <code>g</code>, then <code>h</code>, etc.
It has the <a href="base.html#topic+formals">formals</a> of the first function applied (namely
<code>f</code>). For example, if
</p>
<div class="sourceCode"><pre>  fun &lt;- compose(paste, toupper)
</pre></div>
<p>then the function <code>fun()</code> has the same signature as <code>paste()</code>, and the call
</p>
<div class="sourceCode"><pre>  fun(letters, collapse = ",")
</pre></div>
<p>is equivalent to the composite call
</p>
<div class="sourceCode"><pre>  toupper(paste(letters, collapse = ","))
</pre></div>
</li>
<li><p> Use <code>`%&gt;&gt;&gt;%`</code>:
</p>
<div class="sourceCode"><pre>  f %&gt;&gt;&gt;% g %&gt;&gt;&gt;% h %&gt;&gt;&gt;% ...
</pre></div>
<p>It comprehends both the semantics of the
<a href="https://cran.r-project.org/package=magrittr"><span class="pkg">magrittr</span></a> <code>`%&gt;%`</code>
operator and <a href="rlang.html#topic+topic-inject">quasiquotation</a>. For example, if
</p>
<div class="sourceCode"><pre>  sep &lt;- ""
  fun &lt;- sample %&gt;&gt;&gt;% paste(collapse = !!sep)
</pre></div>
<p>then the function <code>fun()</code> has the same signature as <code>sample()</code>, and the
call
</p>
<div class="sourceCode"><pre>  fun(x, size, replace, prob)
</pre></div>
<p>is equivalent to the composite call
</p>
<div class="sourceCode"><pre>  paste(sample(x, size, replace, prob), collapse = "")
</pre></div>
</li></ul>

<p>Use <code><a href="base.html#topic+as.list">as.list()</a></code> to recover the list of composite functions. For example, both
</p>
<div class="sourceCode"><pre>  as.list(compose(paste, capitalize = toupper))

  as.list(paste %&gt;&gt;&gt;% capitalize: toupper)
</pre></div>
<p>return the (named) list of functions <code>list(paste, capitalize = toupper)</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>compose(...)

fst %&gt;&gt;&gt;% snd
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="compose_+3A_...">...</code></td>
<td>
<p>Functions or lists thereof to compose, in order of application.
Lists of functions are automatically spliced in.
<a href="rlang.html#topic+topic-inject">Unquoting</a> of names, via <code style="white-space: pre;">&#8288;!!&#8288;</code> on the left-hand side
of <code style="white-space: pre;">&#8288;:=&#8288;</code>, and <a href="rlang.html#topic+topic-inject">splicing</a>, via <code style="white-space: pre;">&#8288;!!!&#8288;</code>, are supported.</p>
</td></tr>
<tr><td><code id="compose_+3A_fst">fst</code>, <code id="compose_+3A_snd">snd</code></td>
<td>
<p>Functions. These may be optionally named using a colon (<code>:</code>),
e.g., <code>f %&gt;&gt;&gt;% nm: g</code> names the <code>g</code>-component <code>"nm"</code> (see
&lsquo;Exceptions to the Interpretation of Calls as Functions&rsquo;).
<a href="rlang.html#topic+topic-inject">Quasiquotation</a> and the
<a href="https://cran.r-project.org/package=magrittr"><span class="pkg">magrittr</span></a> <code>`%&gt;%`</code>
semantics are supported (see &lsquo;Semantics of the Composition
Operator&rsquo;, &lsquo;Quasiquotation&rsquo; and &lsquo;Examples&rsquo;).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Function of class <code>CompositeFunction</code>, whose
<a href="base.html#topic+formals">formals</a> are those of the first function applied (as a
closure).
</p>


<h3>Semantics of the Composition Operator</h3>

<p>The <code>`%&gt;&gt;&gt;%`</code> operator adopts the semantics of the
<a href="https://cran.r-project.org/package=magrittr"><span class="pkg">magrittr</span></a> <code>`%&gt;%`</code>
operator:
</p>

<ol>
<li> <p><strong>Bare names are matched to functions</strong>: For example, in a composition
like
</p>
<div class="sourceCode"><pre>  ... %&gt;&gt;&gt;% foo %&gt;&gt;&gt;% ...
</pre></div>
<p>the &lsquo;<code>foo</code>&rsquo; is matched to the function of that name.
</p>
</li>
<li> <p><strong>Function calls are interpreted as a unary function of a point (<code>.</code>)</strong>:
A <em>call</em> is interpreted as a <em>function</em> (of a point) in one of two ways:
</p>

<ul>
<li><p> If the point matches an argument value, the call is literally
interpreted as the body of the function. For example, in the
compositions
</p>
<div class="sourceCode"><pre>  ... %&gt;&gt;&gt;% foo(x, .) %&gt;&gt;&gt;% ...

  ... %&gt;&gt;&gt;% foo(x, y = .) %&gt;&gt;&gt;% ...
</pre></div>
<p>the &lsquo;<code>foo(x, .)</code>&rsquo;, resp. &lsquo;<code>foo(x, y = .)</code>&rsquo;, is
interpreted as the function <code>function(..., . = ..1) foo(x, .)</code>, resp.
<code>function(..., . = ..1) foo(x, y = .)</code>.
</p>
</li>
<li><p> Otherwise, the call is regarded as implicitly having the point as its
first argument before being interpreted as the body of the function.
For example, in the compositions
</p>
<div class="sourceCode"><pre>  ... %&gt;&gt;&gt;% foo(x) %&gt;&gt;&gt;% ...

  ... %&gt;&gt;&gt;% foo(x, y(.)) %&gt;&gt;&gt;% ...
</pre></div>
<p>the &lsquo;<code>foo(x)</code>&rsquo;, resp. &lsquo;<code>foo(x, y(.))</code>&rsquo;, is interpreted
as the function <code>function(..., . = ..1) foo(., x)</code>, resp.
<code>function(..., . = ..1) foo(., x, y(.))</code>.
</p>
</li></ul>

</li>
<li> <p><strong>Expressions <code>{...}</code> are interpreted as a function of a point (<code>.</code>)</strong>:
For example, in a composition
</p>
<div class="sourceCode"><pre>  ... %&gt;&gt;&gt;% {
    foo(.)
    bar(.)
  } %&gt;&gt;&gt;% ...
</pre></div>
<p>the &lsquo;<code>{foo(.); bar(.)}</code>&rsquo; is interpreted as the function
<code>function(..., . = ..1) {foo(.); bar(.)}</code>.
</p>
<p>Curly braces are useful when you need to circumvent <code>`%&gt;&gt;&gt;%`</code>'s
usual interpretation of function calls. For example, in a composition
</p>
<div class="sourceCode"><pre>  ... %&gt;&gt;&gt;% {foo(x, y(.))} %&gt;&gt;&gt;% ...
</pre></div>
<p>the &lsquo;<code>{foo(x, y(.))}</code>&rsquo; is interpreted as the function
<code>function(..., . = ..1) foo(x, y(.))</code>. There is no point as first
argument to <code>foo</code>.
</p>
</li></ol>



<h4>Exceptions to the Interpretation of Calls as Functions</h4>

<p>As a matter of convenience, some exceptions are made to the above
interpretation of calls as functions:
</p>

<ul>
<li> <p><strong>Parenthesis</strong> (<code>(</code>) applies grouping. (In R, <code>`(`</code> is indeed a
function.) In particular, expressions within parentheses are literally
interpreted.
</p>
</li>
<li> <p><strong>Colon</strong> (<code>:</code>) applies <em>naming</em>, according to the syntax
&lsquo;<code style="white-space: pre;">&#8288;&lt;name&gt;: &lt;function&gt;&#8288;</code>&rsquo;, where &lsquo;<code style="white-space: pre;">&#8288;&lt;function&gt;&#8288;</code>&rsquo; is interpreted
according to the semantics of <code>`%&gt;&gt;&gt;%`</code>. For example, in
</p>
<div class="sourceCode"><pre>  ... %&gt;&gt;&gt;% aName: foo %&gt;&gt;&gt;% ...
</pre></div>
<p>the function <code>foo</code> is named <code>"aName"</code>.
</p>
</li>
<li> <p><strong><code><a href="#topic+fn">fn()</a></code></strong>, namespace operators (<code>`::` </code>,
<code>`:::`</code>) and <strong><a href="base.html#topic+Extract">extractors</a></strong> (<code>`$`</code>, <code>`[[`</code>,
<code>`[`</code>) are literally interpreted. This allows for list extractors to
be applied to composite functions appearing in a <code>`%&gt;&gt;&gt;%`</code> call (see
'Operate on Composite Functions as List-Like Objects'). For example, the
compositions
</p>
<div class="sourceCode"><pre>  paste %&gt;&gt;&gt;% tolower

  paste %&gt;&gt;&gt;% base::tolower

  (paste %&gt;&gt;&gt;% toupper)[[1]] %&gt;&gt;&gt;% tolower
</pre></div>
<p>are equivalent functions.
</p>
</li></ul>




<h3>Quasiquotation</h3>

<p>The <code>`%&gt;&gt;&gt;%`</code> operator supports Tidyverse
<a href="rlang.html#topic+topic-inject">unquoting</a> (via <code style="white-space: pre;">&#8288;!!&#8288;</code>). Use it to:
</p>

<ul>
<li> <p><strong>Enforce immutability</strong>: For example, by unquoting <code>res</code> in
</p>
<div class="sourceCode"><pre>  res &lt;- "result"
  get_result &lt;- identity %&gt;&gt;&gt;% lapply(`[[`, !!res)
</pre></div>
<p>you ensure that the function <code>get_result()</code> always extracts the component
named <code>"result"</code>, even if the binding <code>res</code> changes its value or is
removed altogether.
</p>
</li>
<li> <p><strong>Interpret the point (<code>.</code>) in the lexical scope</strong>: Even though
<code>`%&gt;&gt;&gt;%`</code> interprets &lsquo;<code>.</code>&rsquo; as a function argument, you can
still reference an object of that name via unquoting. For example,
</p>
<div class="sourceCode"><pre>  . &lt;- "point"
  is_point &lt;- identity %&gt;&gt;&gt;% {. == !!.}
</pre></div>
<p>determines a function that checks for equality with the string <code>"point"</code>.
</p>
</li>
<li> <p><strong>Name composite functions, programmatically</strong>: For example, unquoting
<code>nm</code> in
</p>
<div class="sourceCode"><pre>  nm &lt;- "aName"
  ... %&gt;&gt;&gt;% !!nm: foo %&gt;&gt;&gt;% ...
</pre></div>
<p>names the &lsquo;<code>foo</code>&rsquo;-component of the resulting composite function
<code>"aName"</code>.
</p>
</li>
<li> <p><strong>Accelerate functions by fixing constant dependencies</strong>: For example,
presuming the value of the call <code>f()</code> is <em>constant</em> and that <code>g</code> is a
<em>pure</em> function (meaning that its return value depends only on its
input), both
</p>
<div class="sourceCode"><pre>  ... %&gt;&gt;&gt;% g(f()) %&gt;&gt;&gt;% ...

  ... %&gt;&gt;&gt;% g(!!f()) %&gt;&gt;&gt;% ...
</pre></div>
<p>would be functions yielding the same values. But the first would compute
<code>f()</code> anew with each call, whereas the second would simply depend on a
fixed, pre-computed value of <code>f()</code>.
</p>
</li></ul>



<h3>Operate on Composite Functions as List-Like Objects</h3>

<p>You can think of a composite function as embodying the (possibly nested)
structure of its list of constituent functions. In fact, you can apply
familiar index and assignment operations to a composite function, as if it
were this list, getting a function in return. This enables you to leverage
composite functions as <em>structured computations</em>.
</p>


<h4>Indexing</h4>

<p>For instance, the &lsquo;<code>sum</code>&rsquo; in the following composite function
</p>
<div class="sourceCode"><pre>  f &lt;- abs %&gt;&gt;&gt;% out: (log %&gt;&gt;&gt;% agg: sum)
</pre></div>
<p>can be <a href="base.html#topic+Extract">extracted</a> in the usual ways:
</p>
<div class="sourceCode"><pre>  f[[2]][[2]]
  f[[c(2, 2)]]

  f$out$agg
  f[["out"]][["agg"]]
  f[["out"]]$agg

  f$out[[2]]
  f[[list("out", 2)]]
</pre></div>
<p>The last form of indexing with a mixed list is handy when you need to
create an index programmatically.
</p>
<p>Additionally, you can excise sub-composite functions with
<code><a href="base.html#topic+Extract">[</a></code>, <code><a href="utils.html#topic+head">head()</a></code>, <code><a href="utils.html#topic+tail">tail()</a></code>. For example:
</p>

<ul>
<li><p> Both <code>f[1]</code> and <code>head(f, 1)</code> get the &lsquo;<code>abs</code>&rsquo; as a composite
function, namely <code>compose(abs)</code>
</p>
</li>
<li> <p><code>f[2:1]</code> reverses the order of the top-level functions to yield
</p>
<div class="sourceCode"><pre>  out: (log %&gt;&gt;&gt;% agg: sum) %&gt;&gt;&gt;% abs
</pre></div>
</li>
<li> <p><code>f$out[c(FALSE, TRUE)]</code> gets the &lsquo;<code>sum</code>&rsquo; as a (named) composite
function
</p>
</li></ul>




<h4>Subset Assignment</h4>

<p>Similarily, subset assignment works as it does for lists. For instance, you
can replace the &lsquo;<code>sum</code>&rsquo; with the identity function:
</p>
<div class="sourceCode"><pre>  f[[2]][[2]] &lt;- identity

  f$out$agg &lt;- identity
  f[["out"]][["agg"]] &lt;- identity

  f$out[[2]] &lt;- identity
  f[[list("out", 2)]] &lt;- identity
</pre></div>
<p>Multiple constituent functions can be reassigned using
<code><a href="base.html#topic+Extract">[&lt;-</a></code>. For example
</p>
<div class="sourceCode"><pre>  f[2] &lt;- list(log)

  f["out"] &lt;- list(log)

  f[c(FALSE, TRUE)] &lt;- list(log)
</pre></div>
<p>all replace the second constituent function with <code>log</code>, so that <code>f</code> becomes
<code>abs %&gt;&gt;&gt;% log</code>.
</p>



<h4>Other List Methods</h4>

<p>The generic methods <code><a href="base.html#topic+unlist">unlist()</a></code>, <code><a href="base.html#topic+length">length()</a></code>, <code><a href="base.html#topic+names">names()</a></code> also apply to
composite functions. In conjunction with <code>compose()</code>, you can use
<code>unlist()</code> to &ldquo;flatten&rdquo; compositions. For example
</p>
<div class="sourceCode"><pre>  compose(unlist(f, use.names = FALSE))
</pre></div>
<p>gives a function that is identical to
</p>
<div class="sourceCode"><pre>  abs %&gt;&gt;&gt;% log %&gt;&gt;&gt;% sum
</pre></div>



<h3>Composite Functions Balance Speed and Complexity</h3>

<p>The speed of a composite function made by <code>compose()</code> or <code>`%&gt;&gt;&gt;%`</code>
(regardless of its nested depth) is on par with a manually constructed
<em>serial</em> composition. This is because <code>compose()</code> and <code>`%&gt;&gt;&gt;%`</code> are
<strong>associative</strong>, semantically and operationally. For instance, triple
compositions,
</p>
<div class="sourceCode"><pre>  compose(f, g, h)
  f %&gt;&gt;&gt;% g %&gt;&gt;&gt;% h

  compose(f, compose(g, h))
  f %&gt;&gt;&gt;% (g %&gt;&gt;&gt;% h)

  compose(compose(f, g), h)
  (f %&gt;&gt;&gt;% g) %&gt;&gt;&gt;% h
</pre></div>
<p>are all implemented as the <em>same function</em>. Lists of functions are
automatically &ldquo;flattened&rdquo; when composed.
</p>
<p>Nevertheless, the original nested structure of constituent functions is
faithfully recovered by <code><a href="base.html#topic+as.list">as.list()</a></code>. In particular, <code>as.list()</code> and
<code>compose()</code> are <strong>mutually invertible</strong>: <code>as.list(compose(fs))</code> is the same
as <code>fs</code>, when <code>fs</code> is a (nested) list of functions. (But note that the
names of the list of composite functions is always a character vector; it
is never <code>NULL</code>.)
</p>


<h3>See Also</h3>

<p><code><a href="#topic+constant">constant()</a></code>; combined with <code>`%&gt;&gt;&gt;%`</code>, this provides a lazy,
structured alternative to the
<a href="https://cran.r-project.org/package=magrittr"><span class="pkg">magrittr</span></a> <code>`%&gt;%`</code>
operator.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Functions are applied in the order in which they are listed
inv &lt;- partial(`/`, 1)  # reciprocal
f0 &lt;- compose(abs, log, inv)
stopifnot(all.equal(f0(-2), 1 / log(abs(-2))))

# Alternatively, compose using the `%&gt;&gt;&gt;%` operator
f1 &lt;- abs %&gt;&gt;&gt;% log %&gt;&gt;&gt;% {1 / .}
stopifnot(all.equal(f1(-2), f0(-2)))

## Not run: 
# Transform a function to a JSON function
library(jsonlite)

# By composing higher-order functions:
jsonify &lt;- {fromJSON %&gt;&gt;&gt;% .} %&gt;&gt;&gt;% {. %&gt;&gt;&gt;% toJSON}

# By directly composing with input/output transformers:
jsonify &lt;- fn(f ~ fromJSON %&gt;&gt;&gt;% f %&gt;&gt;&gt;% toJSON)
## End(Not run)

# Formals of initial function are preserved
add &lt;- function(a, b = 0) a + b
stopifnot(identical(formals(compose(add, inv)), formals(add)))

# Compositions can be provided by lists, in several equivalent ways
f2 &lt;- compose(list(abs, log, inv))
f3 &lt;- compose(!!! list(abs, log, inv))
f4 &lt;- compose(abs, list(log, inv))
f5 &lt;- compose(abs, !!! list(log, inv))
stopifnot(
  all.equal(f2, f0), all.equal(f2(-2), f0(-2)),
  all.equal(f3, f0), all.equal(f3(-2), f0(-2)),
  all.equal(f4, f0), all.equal(f4(-2), f0(-2)),
  all.equal(f5, f0), all.equal(f5(-2), f0(-2))
)

# compose() and as.list() are mutally invertible
f6 &lt;- compose(abs, as.list(compose(log, inv)))
stopifnot(
  all.equal(f6, f0), all.equal(f6(-2), f0(-2))
)
fs &lt;- list(abs, log, inv)
stopifnot(all.equal(check.attributes = FALSE,
  as.list(compose(fs)), fs,
))

# `%&gt;&gt;&gt;%` supports names, magrittr `%&gt;%` semantics, and quasiquotation
sep &lt;- ""
scramble &lt;- shuffle: sample %&gt;&gt;&gt;% paste(collapse = !!sep)
nonsense &lt;- scramble(letters)
stopifnot(
  nchar(nonsense) == 26L,
  identical(letters, sort(strsplit(nonsense, sep)[[1]])),
  identical(scramble$shuffle, sample)
)

</code></pre>

<hr>
<h2 id='constant'>Values as Functions</h2><span id='topic+constant'></span><span id='topic+variable'></span>

<h3>Description</h3>

<p>A <strong>constant</strong> is a fixed value that incorporates its very computation. This
is none other than a <em>function</em> that computes a fixed value when called
without arguments. <code>constant()</code> declares such a function as a bona fide
constant by transforming it to a function that caches the value of its void
call (i.e., <code>constant()</code>
<a href="https://en.wikipedia.org/wiki/Memoization">memoizes</a> void functions).
</p>
<p>Combine <code><a href="#topic+compose">%&gt;&gt;&gt;%</a></code> with <code>constant()</code> for a <em>lazy</em>, <em>structured</em>
alternative to the
<a href="https://cran.r-project.org/package=magrittr"><span class="pkg">magrittr</span></a> <code>`%&gt;%`</code>
operator (see &lsquo;Examples&rsquo;).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>constant(f)

variable(f)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="constant_+3A_f">f</code></td>
<td>
<p>Function, or symbol or name (string) thereof, that can be called
without arguments. (NB: <code>constant()</code> itself does not check whether <code>f()</code> is
indeed a valid call.)</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>constant()</code> yields a function without formal arguments that returns
the (cached, visibility-preserving) value of the void call <code>f()</code>.
</p>
<p><code>variable()</code> is the inverse transformation of <code>constant()</code>: it
recovers the underlying (uncached) function of a constant function.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+compose">%&gt;&gt;&gt;%</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Function with a constant return value
val &lt;- {message("Computing from scratch"); mtcars} %&gt;&gt;&gt;%
  split(.$cyl) %&gt;&gt;&gt;%
  lapply(function(data) lm(mpg ~ wt, data)) %&gt;&gt;&gt;%
  lapply(summary) %&gt;&gt;&gt;%
  sapply(`[[`, "r.squared")

# With every invocation, `val()` is computed anew:
val()
val()

# Declaring `val` as a constant ensures that its value is computed only once.
# On subsequent calls, the computed value is simply fetched:
const &lt;- constant(val)
const()
const()

# As values, `val()` and `const()` are identical. But `const()`, moreover,
# has structure, namely the function `const`:
const

# For instance, you can inspect the intermediate summaries:
head(const, -1)()

# Which can itself be a constant:
summ &lt;- constant(head(const, -1))
summ()
summ()

## Not run: 
# Think of `%&gt;&gt;&gt;%` combined with `constant()` as a lazy, structured
# alternative to the magrittr `%&gt;%` operator.
library(magrittr)

val2 &lt;- mtcars %&gt;%
  split(.$cyl) %&gt;%
  lapply(function(data) lm(mpg ~ wt, data)) %&gt;%
  lapply(summary) %&gt;%
  sapply(`[[`, "r.squared")

# `val2` and `const()` are identical values. But whereas `val2` is computed
# immediately and carries no structure, `const` embodies the process that
# produces its value, and allows you to defer its realization to the
# invocation `const()`.
stopifnot(identical(val2, const()))
## End(Not run)

# Use `variable()` to recover the original (\dQuote{variable}) function
val_var &lt;- variable(const)
stopifnot(identical(val_var, val))
val_var()
val_var()

</code></pre>

<hr>
<h2 id='context'>Run an Action in an Ordered Context</h2><span id='topic+context'></span><span id='topic+let'></span><span id='topic+run'></span>

<h3>Description</h3>

<p>Programming in R typically involves:
</p>

<ol>
<li><p> Making a context: assigning values to names.
</p>
</li>
<li><p> Performing an action: evaluating an expression relative to a context.
</p>
</li></ol>

<p><code>let()</code> and <code>run()</code> enable you to treat these procedures as reusable,
<em>composable</em> components.
</p>

<ul>
<li> <p><code>let()</code> makes a <strong>context</strong>: it <em>lazily</em> binds a sequence of ordered
named expressions to a child of a given environment (by default, the
current one).
</p>
<p>For instance, in an environment <code>env</code> where <code>z</code> is in scope,
</p>
<div class="sourceCode"><pre>  let(env, x = 1, y = x + 2, z = x * y * z)
</pre></div>
<p>is equivalent to calling
</p>
<div class="sourceCode"><pre>  local({
    x &lt;- 1
    y &lt;- x + 2
    z &lt;- x * y * z
    environment()
  })
</pre></div>
<p>except <code>let()</code> binds the named expressions lazily (as
<a href="base.html#topic+delayedAssign">promises</a>) and comprehends tidyverse
<a href="rlang.html#topic+topic-inject">quasiquotation</a>.
</p>
</li>
<li> <p><code>run()</code> performs an <strong>action</strong>: it evaluates an expression relative to an
environment (by default, the current one) and, optionally, a sequence of
<em>lazily evaluated</em> ordered named expressions.
</p>
<p>For instance, in an environment <code>env</code> where <code>x</code> is in scope,
</p>
<div class="sourceCode"><pre>  run(env, x + y + z, y = x + 2, z = x * y * z)
</pre></div>
<p>is equivalent to calling
</p>
<div class="sourceCode"><pre>  local({
    y &lt;- x + 2
    z &lt;- x * y * z
    x + y + z
  })
</pre></div>
<p>except <code>run()</code>, like <code>let()</code>, binds <code>y</code> and <code>z</code> lazily and comprehends
quasiquotation.
</p>
</li></ul>



<h3>Usage</h3>

<pre><code class='language-R'>let(`_data` = parent.frame(), ...)

run(`_data` = parent.frame(), `_expr`, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="context_+3A__data">_data</code></td>
<td>
<p>Context of named values, namely an environment, list or data
frame; if a list or data frame, it is interpreted as an environment (like
the <code>envir</code> argument of <code><a href="base.html#topic+eval">eval()</a></code>).</p>
</td></tr>
<tr><td><code id="context_+3A_...">...</code></td>
<td>
<p>Named expressions. An expression looks up values to the left of
it, and takes precedence over those in <code>`_data`</code>.
<a href="rlang.html#topic+topic-inject">Quasiquotation</a> of names and expressions is
supported (see &lsquo;Examples&rsquo;).</p>
</td></tr>
<tr><td><code id="context_+3A_+60_expr+60">`_expr`</code></td>
<td>
<p>Expression to evaluate (&ldquo;run&rdquo;). Quasiquotation is
supported.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>run()</code> returns the evaluation of <code>`_expr`</code> in the combined
environment of <code>`_data`</code> and <code>...</code>.
</p>
<p><code>let()</code> returns an environment where the bindings in <code>...</code> are in scope, as
<a href="base.html#topic+delayedAssign">promises</a>, as if they were assigned from left to right in
a child of the environment defined by <code>`_data`</code>.
</p>


<h3>Composing Contexts</h3>

<p><strong>Contexts</strong>, as made by <code>let()</code>, have an advantage over ordinary local
assignments because contexts are both lazy and composable. Like
assignments, the order of named expressions in a context is significant.
</p>
<p>For example, you can string together contexts to make larger ones:
</p>
<div class="sourceCode"><pre>  foo &lt;-
    let(a = ., b = a + 2) %&gt;&gt;&gt;%
    let(c = a + b) %&gt;&gt;&gt;%
    run(a + b + c)

  foo(1)
  #&gt; [1] 8
</pre></div>
<p>Earlier bindings can be overriden by later ones:
</p>
<div class="sourceCode"><pre>  bar &lt;-
    foo[1:2] %&gt;&gt;&gt;%        # Collect the contexts of 'foo()'
    let(c = c - 1) %&gt;&gt;&gt;%  # Override 'c'
    run(a + b + c)

  bar(1)
  #&gt; [1] 7
</pre></div>
<p>Bindings are <a href="base.html#topic+delayedAssign">promises</a>; they are only evaluated on
demand:
</p>
<div class="sourceCode"><pre>  run(let(x = a_big_expense(), y = "avoid a big expense"), y)
  #&gt; [1] "avoid a big expense"
</pre></div>


<h3>Remark</h3>

<p>&ldquo;Contexts&rdquo; as described here should not be confused with
&ldquo;contexts&rdquo; in
<a href="https://cran.r-project.org/doc/manuals/r-release/R-ints.html#Contexts">R's internal mechanism</a>.
</p>


<h3>See Also</h3>

<p><code><a href="base.html#topic+with">with()</a></code> is like <code>run()</code>, but more limited because it doesn't
support quasiquotation or provide a means to override local bindings.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Miles-per-gallon of big cars
mtcars$mpg[mtcars$cyl == 8 &amp; mtcars$disp &gt; 350]
run(mtcars, mpg[cyl == 8 &amp; disp &gt; 350])
run(mtcars, mpg[big_cars], big_cars = cyl == 8 &amp; disp &gt; 350)

# 'let()' makes a reusable local context for big cars
cars &lt;- let(mtcars, big = cyl == 8 &amp; disp &gt; 350)

eval(quote(mpg[big]), cars)  # Quoting restricts name lookup to 'cars'
run(cars, mpg[big])          # The same, but shorter and more transparent

run(cars, wt[big])
mtcars$wt[mtcars$cyl == 8 &amp; mtcars$disp &gt; 350]

# Precedence of names is from right to left ("bottom-up"):
a &lt;- 1000
run(`_expr` = a + b, a = 1, b = a + 2)    # 4: all references are local
run(list(a = 1), a + b, b = a + 2)        # 4: 'b' references local 'a'
run(let(a = 1, b = a + 2), a + b)         # 4: 'b' references local 'a'
run(let(a = 1, b = a + 2), a + b, a = 0)  # 3: latter 'a' takes precedence
run(list(a = 1, b = a + 2), a + b)        # 1003: 'b' references global 'a'

# Bound expressions are lazily evaluated: no error unless 'x' is referenced
run(`_expr` = "S'all good, man.", x = stop("!"))
run(let(x = stop("!")), "S'all good, man.")
let(x = stop("!"))    # Environment binding 'x'
try(let(x = stop("!"))$x)  # Error: !

# Quasiquotation is supported
a &lt;- 1
run(let(a = 2), a + !!a)               #&gt; [1] 3
run(let(a = 1 + !!a, b = a), c(a, b))  #&gt; [1] 2 2

</code></pre>

<hr>
<h2 id='fn'>Function Declarations with Quasiquotation</h2><span id='topic+fn'></span><span id='topic+fn_'></span>

<h3>Description</h3>

<p><code>fn()</code> enables you to create (anonymous) functions, of arbitrary call
signature. Use it in place of the usual <code><a href="base.html#topic+function">function()</a></code> invocation whenever you
want to:
</p>

<ul>
<li> <p><strong>Be concise</strong>: The function declarations
</p>
<div class="sourceCode"><pre>  fn(x, y = 1 ~ x + y)

  function(x, y = 1) x + y
</pre></div>
<p>are equivalent.
</p>
</li>
<li> <p><strong>Enforce immutability</strong>: By enabling Tidyverse
<a href="rlang.html#topic+topic-inject">quasiquotation</a>, <code>fn()</code> allows you to &ldquo;burn
in&rdquo; values at the point of function creation. This guards against changes
in a function's enclosing environment. (See &lsquo;Use Unquoting to Make
Robust Functions&rsquo;.)
</p>
</li></ul>

<p><code>fn_()</code> is a variant of <code>fn()</code> that does <em>not</em> comprehend quasiquotation. It
is useful when you want unquoting (<code>`!!`</code>) or splicing (<code>`!!!`</code>)
operators in the function body to be literally interpreted, rather than
immediately invoked. (See &lsquo;Quasiquotation&rsquo; for a complementary way to
literally interpret unquoting and splicing operators in <code>fn()</code>.)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fn(..., ..env = parent.frame())

fn_(..., ..env = parent.frame())
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fn_+3A_...">...</code></td>
<td>
<p>Function declaration, which supports
<a href="rlang.html#topic+topic-inject">quasiquotation</a>.</p>
</td></tr>
<tr><td><code id="fn_+3A_..env">..env</code></td>
<td>
<p>Environment in which to create the function (i.e., the
function's <a href="base.html#topic+environment">enclosing environment</a>).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A function whose enclosing environment is <code>..env</code>.
</p>


<h3>Function Declarations</h3>

<p>A <strong>function declaration</strong> is an expression
that specifies a function's arguments and body, as a comma-separated
expression of the form
</p>
<div class="sourceCode"><pre>  arg1, arg2, ..., argN ~ body
</pre></div>
<p>or
</p>
<div class="sourceCode"><pre>  arg1, arg2, ..., argN, ~body
</pre></div>
<p>(Note in the second form that the body is a one-sided formula. This
distinction is relevant for argument <a href="rlang.html#topic+topic-inject">splicing</a>, see
&lsquo;Quasiquotation&rsquo;.)
</p>

<ul>
<li><p> To the left of <code>~</code>, you write a conventional function-argument
declaration, just as in <code style="white-space: pre;">&#8288;function(&lt;arguments&gt;)&#8288;</code>: each of <code>arg1</code>, <code>arg2</code>,
..., <code>argN</code> is either a bare argument (e.g., <code>x</code> or <code>...</code>) or an
argument with default value (e.g., <code>x = 1</code>).
</p>
</li>
<li><p> To the right of <code>~</code>, you write the function body, i.e., an expression of
the arguments.
</p>
</li></ul>



<h3>Quasiquotation</h3>

<p>All parts of a function declaration support Tidyverse
<a href="rlang.html#topic+topic-inject">quasiquotation</a>:
</p>

<ul>
<li><p> To unquote values (of arguments or parts of the body), use <code style="white-space: pre;">&#8288;!!&#8288;</code>:
</p>
<div class="sourceCode"><pre>  z &lt;- 0
  fn(x, y = !!z ~ x + y)
  fn(x ~ x &gt; !!z)
</pre></div>
</li>
<li><p> To unquote argument names (with default value), use <code style="white-space: pre;">&#8288;:=&#8288;</code> (definition
operator):
</p>
<div class="sourceCode"><pre>  arg &lt;- "y"
  fn(x, !!arg := 0 ~ x + !!as.name(arg))
</pre></div>
</li>
<li><p> To splice in a (formal) list of arguments, use <code style="white-space: pre;">&#8288;!!!&#8288;</code>:
</p>
<div class="sourceCode"><pre>  # NB: Body is a one-sided formula
  fn(!!!alist(x, y = 0), ~ x + y)
</pre></div>
<p>Splicing allows you to treat a complete function declaration as a unit:
</p>
<div class="sourceCode"><pre>  soma &lt;- alist(x, y = 0, ~ x + y)
  fn(!!!soma)
</pre></div>
</li>
<li><p> To write literal unquoting operators, use <code>QUQ()</code>, <code>QUQS()</code>, which read
as &ldquo;quoted unquoting,&rdquo; &ldquo;quoted unquote-splicing,&rdquo; resp. (cf.
<code>fn_()</code>):
</p>
<div class="sourceCode"><pre>  library(dplyr)

  my_summarise &lt;- fn(df, ... ~ {
    groups &lt;- quos(...)
    df %&gt;%
      group_by(QUQS(groups)) %&gt;%
      summarise(a = mean(a))
  })
</pre></div>
<p>(Source: <a href="https://dplyr.tidyverse.org/articles/programming.html">Programming with dplyr</a>)
</p>
</li></ul>



<h3>Use Unquoting to Make Robust Functions</h3>

<p>Functions in R are generally
<a href="https://en.wikipedia.org/wiki/Pure_function">impure</a>, i.e., the return
value of a function will <em>not</em> in general be determined by the value of its
inputs alone. This is because, by design, a function may depend on objects
in its
<a href="https://adv-r.hadley.nz/functions.html#lexical-scoping">lexical scope</a>, and
these objects may mutate between function calls. Normally this isn't a
hazard.
</p>
<p>However, if you are working interactively and sourcing files into the
global environment, or using a notebook interface like
<a href="https://jupyter.org">Jupyter</a> or
<a href="https://bookdown.org/yihui/rmarkdown/notebook.html">R Notebook</a>, it can be
tricky to ensure that you haven't unwittingly mutated an object that an
earlier function depends upon.
</p>
<p>You can use unquoting to guard against such mutations.
</p>


<h4>Example</h4>

<p>Consider the following function:
</p>
<div class="sourceCode"><pre>  a &lt;- 1
  foo &lt;- function(x) x + a
</pre></div>
<p>What is the value of <code>foo(1)</code>? It is not necessarily <code>2</code>, because the value
of <code>a</code> may have changed between the <em>creation</em> of <code>foo()</code> and the <em>calling</em>
of <code>foo(1)</code>:
</p>
<div class="sourceCode"><pre>  foo(1)  #&gt; [1] 2

  a &lt;- 0

  foo(1)  #&gt; [1] 1
</pre></div>
<p>In other words, <code>foo()</code> is impure because the value of <code>foo(x)</code> depends not
only on the value of <code>x</code> but also on the <em>externally mutable</em> value of <code>a</code>.
</p>
<p>With <code>fn()</code>, you can unquote <code>a</code> to &ldquo;burn in&rdquo; its value at the point
of creation:
</p>
<div class="sourceCode"><pre>  a &lt;- 1
  foo &lt;- fn(x ~ x + !!a)
</pre></div>
<p>Now <code>foo()</code> is a pure function, unaffected by changes to <code>a</code> in the lexical
scope:
</p>
<div class="sourceCode"><pre>  foo(1)  #&gt; [1] 2

  a &lt;- 0

  foo(1)  #&gt; [1] 2
</pre></div>



<h3>Examples</h3>

<pre><code class='language-R'>fn(x ~ x + 1)
fn(x, y ~ x + y)
fn(x, y = 2 ~ x + y)
fn(x, y = 1, ... ~ log(x + y, ...))

# to specify '...' in the middle, write '... = '
fn(x, ... = , y ~ log(x + y, ...))

# use one-sided formula for constant functions or commands
fn(~ NA)
fn(~ message("!"))

# unquoting is supported (using `!!` from rlang)
zero &lt;- 0
fn(x = !!zero ~ x &gt; !!zero)

# formals and function bodies can also be spliced in
f &lt;- function(x, y) x + y
g &lt;- function(y, x, ...) x - y
frankenstein &lt;- fn(!!!formals(f), ~ !!body(g))
stopifnot(identical(frankenstein, function(x, y) x - y))

# mixing unquoting and literal unquoting is possible
# (Assume dplyr is available, which provides group_by() and `%&gt;%`.)
summariser &lt;- quote(mean)
my_summarise &lt;- fn(df, ... ~ {
  groups &lt;- quos(...)
  df %&gt;%
    group_by(QUQS(groups)) %&gt;%          # literal unquote-splice
    summarise(a = `!!`(summariser)(a))  # substitute `mean`
})
my_summarise

# Use fn_() with fn() as a concise way to force ("pin down") bindings
# For example, the 'x' is immutable in the function produced by call_upon():
call_upon &lt;- fn_(x ~ fn(f ~ f(!!x)))
sapply(list(sin, cos), call_upon(0))  # [1] 0 1

# Return-value checking, as a functional transformation
enforce &lt;- fn_(condition ~
  fn(x ~ {
    stopifnot(!!substitute(condition))
    x
  })
)
no_nan &lt;- enforce(!is.nan(x))
log_strict &lt;- fn(x ~ no_nan(log(x)))
log_strict(2)        # [1] 0.6931472
try(log_strict(-1))  # Error: !is.nan(x) is not TRUE

</code></pre>

<hr>
<h2 id='gestalt-package'>gestalt: Tools for Making and Combining Functions</h2><span id='topic+gestalt'></span><span id='topic+gestalt-package'></span>

<h3>Description</h3>

<p>Provides a suite of function-building tools centered around a (forward) composition operator, 
</p>


<h3>Author(s)</h3>

<p><strong>Maintainer</strong>: Eugene Ha <a href="mailto:eha@posteo.de">eha@posteo.de</a>
</p>


<h3>See Also</h3>

<p>Useful links:
</p>

<ul>
<li> <p><a href="https://github.com/egnha/gestalt">https://github.com/egnha/gestalt</a>
</p>
</li>
<li><p> Report bugs at <a href="https://github.com/egnha/gestalt/issues">https://github.com/egnha/gestalt/issues</a>
</p>
</li></ul>


<hr>
<h2 id='partial'>Fix a Number of Arguments to a Function</h2><span id='topic+partial'></span><span id='topic+departial'></span>

<h3>Description</h3>

<p><code>partial()</code> enables
<a href="https://en.wikipedia.org/wiki/Partial_application">partial application</a>:
given a function, it fixes the value of selected arguments to produce a
function of the remaining arguments.
</p>
<p><code>departial()</code> undoes the application of <code>partial()</code> by returning the original
function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>partial(..f, ...)

departial(..f)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="partial_+3A_..f">..f</code></td>
<td>
<p>Function.</p>
</td></tr>
<tr><td><code id="partial_+3A_...">...</code></td>
<td>
<p>Argument values of <code>..f</code> to fix, specified by name or position.
Captured as <a href="rlang.html#topic+topic-defuse">quosures</a>.
<a href="rlang.html#topic+topic-inject">Unquoting</a> and <a href="rlang.html#topic+topic-inject">splicing</a>
are supported (see &lsquo;Examples&rsquo;). Argument values may match the <code>...</code>
argument of <code>..f</code> (if present), but only when specified by name.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Even while <code>partial()</code> truncates formals, it remains compatible with
functions that use <code><a href="base.html#topic+missing">missing()</a></code> to test whether a
specified argument was supplied in a call. For example,
<code>draw3 &lt;- partial(sample, size = 3)</code> works as a function that randomly
draws three elements, even though <code>sample()</code> invokes <code>missing(size)</code> and
<code>draw3()</code> has the form <code>function(x, replace, prob) {...}</code>.
</p>
<p>Because partially applied functions call the original function in an ad hoc
environment, impure functions that depend on the calling context as a
<em>value</em>, rather than as a lexical scope, may not be amenable to
<code>partial()</code>. For example, <code>partial(ls, all.names = TRUE)()</code> is not
equivalent to <code>ls(all.names = TRUE)</code>, because <code>ls()</code> inspects the calling
environment to produce its value, whereas <code>partial(ls, all.names = TRUE)()</code>
calls <code>ls(all.names = TRUE)</code> from an (ephemeral) evaluation environment.
</p>


<h3>Value</h3>

<p><code>partial()</code> returns a function whose <a href="base.html#topic+formals">formals</a> are a
truncation of the formals of <code>..f</code> (as a closure) by the fixed arguments.
NB the original default values do not appear in the formals of a
partialized function, but are nonetheless applied when the function is
called.
</p>
<p>The function <code>partial(..f)</code> is identical to <code>..f</code>.
</p>
<p>In conformance with R's calling convention, fixed argument values are lazy
<a href="base.html#topic+delayedAssign">promises</a>. Moreover, when forced, they are <a href="rlang.html#topic+eval_tidy">tidily evaluated</a>. Lazy evaluation of fixed arguments can be
overridden via unquoting, see &lsquo;Examples&rsquo;.
</p>
<p>When <code>..f</code> is a partially applied function, <code>departial(..f)</code> is the
(closure of) the underlying function. For ordinary (non-partially applied)
functions, <code>departial(..f)</code> is identical to <code>..f</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Arguments can be fixed by name
draw3 &lt;- partial(sample, size = 3)
draw3(letters)

# Arguments can be fixed by position
draw3 &lt;- partial(sample, , 3)
draw3(letters)

# Use departial() to recover the original function
stopifnot(identical(departial(draw3), sample))

# Lazily evaluate argument values by default
# The value of 'n' is evaluated whenever rnd() is called.
rnd &lt;- partial(runif, n = rpois(1, 5))
replicate(4, rnd(), simplify = FALSE)   # variable length

# Eagerly evaluate argument values with unquoting (`!!`)
# The value of 'n' is fixed when 'rnd_eager' is created.
rnd_eager &lt;- partial(runif, n = !!rpois(1, 5))
len &lt;- length(rnd_eager())
reps &lt;- replicate(4, rnd_eager(), simplify = FALSE)   # constant length
stopifnot(all(vapply(reps, length, integer(1)) == len))

# Mix evaluation schemes by combining lazy evaluation with unquoting (`!!`)
# Here 'n' is lazily evaluated, while 'max' is eagerly evaluated.
rnd_mixed &lt;- partial(runif, n = rpois(1, 5), max = !!sample(10, 1))
replicate(4, rnd_mixed(), simplify = FALSE)

# Arguments to fix can be spliced
args_eager &lt;- list(n = rpois(1, 5), max = sample(10, 1))
rnd_eager2 &lt;- partial(runif, !!!args_eager)
replicate(4, rnd_eager2(), simplify = FALSE)

# Use rlang::exprs() to selectively evaluate arguments to fix
args_mixed &lt;- rlang::exprs(n = rpois(1, 5), max = !!sample(10, 1))
rnd_mixed2 &lt;- partial(runif, !!!args_mixed)
replicate(4, rnd_mixed2(), simplify = FALSE)

# partial() truncates formals by the fixed arguments, omits default values
foo &lt;- function(x, y = x, ..., z = "z") NULL
stopifnot(
  identical(formals(partial(foo)),
            formals(foo)),
  identical(formals(partial(foo, x = 1)),
            formals(function(y, ..., z) NULL)),
  identical(formals(partial(foo, x = 1, y = 2)),
            formals(function(..., z) NULL)),
  identical(formals(partial(foo, x = 1, y = 2, z = 3)),
            formals(function(...) NULL))
)

# Nevertheless, partial() remembers default argument values when called
f &lt;- function(x, y = x) c(x, y)
p &lt;- partial(f, x = 1)
stopifnot(identical(p(), c(1, 1)))

</code></pre>

<hr>
<h2 id='posure'>Variable Composite Functions</h2><span id='topic+posure'></span>

<h3>Description</h3>

<p><code>posure()</code> enables you to create <em>efficient</em> variable (i.e., parameterized)
<a href="#topic+compose">composite functions</a>.
</p>
<p>For instance, say you have a composite function such as
</p>
<div class="sourceCode"><pre>  function(..., b = 2, n) {
    (sample %&gt;&gt;&gt;% log(base = b) %&gt;&gt;&gt;% rep(n))(...)
  }

  # Alternatively, expressed with the magrittr %&gt;%:
  function(..., b = 2, n) {
    sample(...) %&gt;% log(base = b) %&gt;% rep(n)
  }
</pre></div>
<p>which varies according to the values of <code>b</code> and <code>n</code>.  You can express this
more succinctly with <code>posure()</code>, by dropping the placeholder argument
(&lsquo;<code>...</code>&rsquo;):
</p>
<div class="sourceCode"><pre>  posure(b = 2, n ~ {
    sample %&gt;&gt;&gt;% log(base = b) %&gt;&gt;&gt;% rep(n)
  })
</pre></div>
<p>This creates a function with same <a href="base.html#topic+formals">formals</a> and return values.
</p>
<p>But the <code>posure()</code> version is more efficient because it creates the composite
function just <em>once</em>, rather than anew with each function call. Morever, it
is robuster than the functionally equivalent construction with the
<a href="https://cran.r-project.org/package=magrittr"><span class="pkg">magrittr</span></a> <code>`%&gt;%`</code>
because <code>posure()</code> validates the constituent functions (see
&lsquo;Examples&rsquo;).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>posure(..., ..env = parent.frame())
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="posure_+3A_...">...</code></td>
<td>
<p>Function declaration whose body must be a function composition
expressed using <code><a href="#topic++25+3E+3E+3E+25">%&gt;&gt;&gt;%</a></code>. <a href="rlang.html#topic+topic-inject">Quasiquotation</a> is
supported. The syntax is that of <code><a href="#topic+fn">fn()</a></code> (see &lsquo;Function
Declarations&rsquo;) except that declaring &lsquo;<code>...</code>&rsquo; among <code>...</code> is
ambiguous.</p>
</td></tr>
<tr><td><code id="posure_+3A_..env">..env</code></td>
<td>
<p>Environment in which to create the function. (You should rarely
need to set this.)</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>posure()</code> <a href="https://en.wikipedia.org/wiki/Currying">curries</a> composite
functions. However, the main significance of <code>posure()</code> is its efficiency,
which is achieved via non-standard scoping semantics (transparent to the
caller). <code>posure()</code> creates the given composite function once. When the
resulting variable composite function is called, its dependencies are
dynamically bound to its localized <em>lexical</em> scope, for fast lookup, then
removed when the function exits. Thus a <strong>posure</strong> is a (parameterized)
<a href="base.html#topic+function">closure</a> that is <em>partially dynamically scoped</em>. (This
portmanteau is due to <a href="https://github.com/henryaj">Henry Stanley</a>.)
</p>


<h3>Value</h3>

<p>Function with <a href="base.html#topic+formals">formals</a>
<code style="white-space: pre;">&#8288;function (..., &lt;composite_function_dependencies&gt;)&#8288;</code>, where
<code style="white-space: pre;">&#8288;&lt;composite_function_dependencies&gt;&#8288;</code> stands for the formals captured by the
dots of <code>posure()</code>. In particular, a call of the form
</p>
<div class="sourceCode"><pre>  posure(a, b = value ~ f(a, b) %&gt;&gt;&gt;% g(a, b))
</pre></div>
<p>produces a function with the same formals and return values as
</p>
<div class="sourceCode"><pre>  function(..., a, b = value) {
    (f(a, b) %&gt;&gt;&gt;% g(a, b))(...)
  }
</pre></div>


<h3>See Also</h3>

<p><code><a href="#topic++25+3E+3E+3E+25">%&gt;&gt;&gt;%</a></code>, <code><a href="#topic+fn">fn()</a></code>, <code><a href="#topic+partial">partial()</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>foo &lt;- posure(b = 2, n ~ {
  sample %&gt;&gt;&gt;% log(base = b) %&gt;&gt;&gt;% rep(n)
})

# A posure is a composite function with dependencies:
foo

set.seed(1)
foo(2^(1:10), size = 2, n = 3)
#&gt; [1] 3 4 3 4 3 4

set.seed(1)
rep(log(sample(2^(1:10), size = 2), base = 2), 3)
#&gt; [1] 3 4 3 4 3 4

# However, a 'posure()' does the composition upfront, so it is faster
# than the equivalent function defined using the magrittr pipe:

library(magrittr)  # Provides the pipe %&gt;%

foo_pipe &lt;- function(..., b = 2, n) {
  sample(...) %&gt;% log(base = b) %&gt;% rep(n)
}

set.seed(1)
foo_pipe(2^(1:10), size = 2, n = 3)
#&gt; [1] 3 4 3 4 3 4

# Moreover, posures are safer than functions defined using the pipe,
# because '%&gt;&gt;&gt;%' validates constituent functions:
try(posure(b = 2, n ~ log(Base = b) %&gt;&gt;&gt;% rep(n)))
# Error: unused argument (Base = b)

try(posure(b = 2 ~ my_sample %&gt;&gt;&gt;% log(base = b)))
# Error: object 'my_sample' not found

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
