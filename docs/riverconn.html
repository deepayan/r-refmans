<!DOCTYPE html><html><head><title>Help for package riverconn</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {riverconn}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#%&gt;%'><p>Pipe operator</p></a></li>
<li><a href='#B_ij_fun'><p>Calculates B_ij: the functional contribution to dispersal probability I_ij</p></a></li>
<li><a href='#c_ij_fun'><p>Calculates c_ij: the structural contribution to the dispersal probability I_ij</p></a></li>
<li><a href='#d_index_calculation'><p>Calculate Reach- and Catchment-scale index improvement for scenarios of barriers removal</p></a></li>
<li><a href='#index_calculation'><p>Reach- and Catchment-scale indices of connectivity</p></a></li>
<li><a href='#inner_d_index_calculation'><p>Calculate index improvement for scenarios of barriers removal - function not for export</p></a></li>
<li><a href='#inner_t_index_calculation'><p>Calculates time-dependent index when nodes weights or barriers passability are changing - not for exporting</p></a></li>
<li><a href='#set_B_directionality'><p>Calculates average upstream/downstream or combined distance between each couple of reaches</p></a></li>
<li><a href='#set_c_directionality'><p>Calculates equivalent passability based on graph directionality and directionality type</p></a></li>
<li><a href='#set_graph_directionality'><p>Create directed river graph based on outlet flag</p></a></li>
<li><a href='#t_index_calculation'><p>Calculates time-dependent index when nodes weights or barriers passability are changing</p></a></li>
<li><a href='#t_passability_sequencer'><p>Create the time-dependent metadata for barriers</p></a></li>
<li><a href='#t_weights_sequencer'><p>Create the time-dependent weights data</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Fragmentation and Connectivity Indices for Riverscapes</td>
</tr>
<tr>
<td>Version:</td>
<td>0.3.31</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Damiano Baldan &lt;damiano.baldan91@gmail.com&gt;</td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/damianobaldan/riverconn/issues">https://github.com/damianobaldan/riverconn/issues</a></td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/damianobaldan/riverconn">https://github.com/damianobaldan/riverconn</a></td>
</tr>
<tr>
<td>Description:</td>
<td>Indices for assessing riverscape fragmentation, including the Dendritic Connectivity Index, the Population Connectivity Index, the River Fragmentation Index, the Probability of Connectivity, and the Integral Index of connectivity. For a review, see Jumani et al. (2020) &lt;<a href="https://doi.org/10.1088%2F1748-9326%2Fabcb37">doi:10.1088/1748-9326/abcb37</a>&gt; and Baldan et al. (2022) &lt;<a href="https://doi.org/10.1016%2Fj.envsoft.2022.105470">doi:10.1016/j.envsoft.2022.105470</a>&gt; Functions to calculate temporal indices improvement when fragmentation due to barriers is reduced are also included.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://opensource.org/licenses/mit-license.php">MIT</a> + file LICENSE</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>Imports:</td>
<td>doParallel, dplyr, foreach, igraph, magrittr, parallel, rlang,
stats, tidyr, tidyselect, dodgr, reshape2</td>
</tr>
<tr>
<td>Suggests:</td>
<td>knitr, ggplot2, viridis, rmarkdown</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-01-23 10:11:46 UTC; dbaldan</td>
</tr>
<tr>
<td>Author:</td>
<td>Damiano Baldan <a href="https://orcid.org/0000-0001-9237-4883"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cre],
  David Cunillera-Montcusi
    <a href="https://orcid.org/0000-0001-8666-346X"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [ctb],
  Andrea Funk <a href="https://orcid.org/0000-0002-0568-1234"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [ctb]</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-01-23 10:30:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='+25+26gt+3B+25'>Pipe operator</h2><span id='topic++25+3E+25'></span>

<h3>Description</h3>

<p>See <code>magrittr::<a href="magrittr.html#topic+pipe">%&gt;%</a></code> for details.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lhs %&gt;% rhs
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="+2B25+2B26gt+2B3B+2B25_+3A_lhs">lhs</code></td>
<td>
<p>A value or the magrittr placeholder.</p>
</td></tr>
<tr><td><code id="+2B25+2B26gt+2B3B+2B25_+3A_rhs">rhs</code></td>
<td>
<p>A function call using the magrittr semantics.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The result of calling 'rhs(lhs)'.
</p>

<hr>
<h2 id='B_ij_fun'>Calculates B_ij: the functional contribution to dispersal probability I_ij</h2><span id='topic+B_ij_fun'></span>

<h3>Description</h3>

<p>Calculates B_ij: the functional contribution to dispersal probability I_ij
</p>


<h3>Usage</h3>

<pre><code class='language-R'>B_ij_fun(
  graph,
  field_B = "length",
  dir_distance_type = "symmetric",
  disp_type = "exponential",
  param_u,
  param_d,
  param,
  param_l
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="B_ij_fun_+3A_graph">graph</code></td>
<td>
<p>an object of class igraph. Can be both directed or undirected.</p>
</td></tr>
<tr><td><code id="B_ij_fun_+3A_field_b">field_B</code></td>
<td>
<p>the 'graph' edge attribute to be used to calculate the distance. Default is <code>"length"</code>.</p>
</td></tr>
<tr><td><code id="B_ij_fun_+3A_dir_distance_type">dir_distance_type</code></td>
<td>
<p>how directionality in B_ij calculations is dealt with:
<code>"symmetric"</code> (i.e. undirected graph) or <code>"asymmetric"</code> (i.e. directed graph). See details.</p>
</td></tr>
<tr><td><code id="B_ij_fun_+3A_disp_type">disp_type</code></td>
<td>
<p>the formula used to calculate the probabilities in the B_ij matrix.
Use <code>"exponential"</code> for exponential decay, <code>"threshold"</code> for setting a distance threshold,
or <code>"leptokurtic"</code> for leptokurtic dispersal.</p>
</td></tr>
<tr><td><code id="B_ij_fun_+3A_param_u">param_u</code></td>
<td>
<p>the upstream dispersal parameter. Must be a numeric value. Only used if <code>dir_distance_type = "asymmetric"</code>. See details.</p>
</td></tr>
<tr><td><code id="B_ij_fun_+3A_param_d">param_d</code></td>
<td>
<p>the downstream dispersal parameter. Must be a numeric value. Only used if <code>dir_distance_type = "asymmetric"</code>. See details.</p>
</td></tr>
<tr><td><code id="B_ij_fun_+3A_param">param</code></td>
<td>
<p>the dispersal parameter. Must be a numeric value. Only used if <code>dir_distance_type = "symmetric"</code>. See details.</p>
</td></tr>
<tr><td><code id="B_ij_fun_+3A_param_l">param_l</code></td>
<td>
<p>the parameters for the leptokurtic dispersal mode. Must be a numeric vector of the
type <code>c(sigma_stat, sigma_mob, p)</code>. See details below.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>dir_distance_type = "symmetric"</code> is to be used when the directionality of the river network is not relevant.
The distance between reaches midpoints is calculated for each couple of reaches.
<code>dir_distance_type = "asymmetric"</code> is to be used when the directionality is relevant.
The distance between reaches midpoints is calculated for each couple of reaches and splitted
between 'upstream travelled' distance and 'downstream travelled' distance.
When <code>disp_type ="leptokurtic"</code> is selected, symmetric dispersal is assumed.
</p>
<p>The 'param_u', 'param_d', and 'param' values are interpreted differently based on the formula used to relate distance (d_ij) and probability (B_ij).
When <code>disp_type ="exponential"</code>, those values are used as the base of the exponential dispersal kernel: B_ij = param^d_ij.
When <code>disp_type ="threshold"</code>, those values are used to define the maximum dispersal length: B_ij = ifelse(d_ij &lt; param, 1, 0).
</p>
<p>When <code>disp_type ="leptokurtic"</code> is selected, a leptokurtic dispersal kernel is used to calculate B_ij.
A leptokurtic dispersal kernel is a mixture of two zero-centered gaussian distributions with standard deviations
<code>sigma_stat</code> (static part of the population), and <code>sigma_mob</code> (mobile part of the population).
The probability of dispersal is calculated as: B_ij = p F(0, sigma_stat, d_ij) + (1-p) F(0, sigma_mob, d_ij)
where F is the upper tail of the gaussian cumulative density function.
</p>


<h3>Value</h3>

<p>a square matrix of size length(V(graph)) containing B_ij values.
The matrix is organized with &quot;from&quot; nodes on the columns and &quot;to&quot; nodes on the rows
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(igraph)
g &lt;- igraph::graph_from_literal(1-+2, 2-+5, 3-+4, 4-+5, 6-+7, 7-+10, 8-+9, 9-+10,
5-+11, 11-+12, 10-+13, 13-+12, 12-+14, 14-+15, 15-+16)
E(g)$id_dam &lt;- c("1", NA, "2", "3", NA, "4", NA, "5", "6", NA,  NA, NA, NA, "7", NA)
E(g)$type &lt;- ifelse(is.na(E(g)$id_dam), "joint", "dam")
V(g)$length &lt;- c(1, 1, 2, 3, 4, 1, 5, 1, 7, 7, 3, 2, 4, 5, 6, 9)
V(g)$HSI &lt;- c(0.2, 0.1, 0.3, 0.4, 0.5, 0.5, 0.5, 0.6, 0.7, 0.8, 0.8, 0.8, 0.8, 0.8, 0.8, 0.8)
V(g)$Id &lt;- V(g)$name
E(g)$pass_u &lt;- E(g)$pass_d &lt;- ifelse(!is.na(E(g)$id_dam),0.1,NA)
dist_mat &lt;- B_ij_fun(g, param = 0.9)

</code></pre>

<hr>
<h2 id='c_ij_fun'>Calculates c_ij: the structural contribution to the dispersal probability I_ij</h2><span id='topic+c_ij_fun'></span>

<h3>Description</h3>

<p>Calculates c_ij: the structural contribution to the dispersal probability I_ij
</p>


<h3>Usage</h3>

<pre><code class='language-R'>c_ij_fun(
  graph,
  dir_fragmentation_type = "symmetric",
  pass_confluence = 1,
  pass_u = "pass_u",
  pass_d = "pass_d"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="c_ij_fun_+3A_graph">graph</code></td>
<td>
<p>an object of class igraph. Can be both directed or undirected.</p>
</td></tr>
<tr><td><code id="c_ij_fun_+3A_dir_fragmentation_type">dir_fragmentation_type</code></td>
<td>
<p>how directionality in c_ij calculations is dealt with:
<code>"symmetric"</code> (i.e. undirected graph) or <code>"asymmetric"</code> (i.e. directed graph). See details.</p>
</td></tr>
<tr><td><code id="c_ij_fun_+3A_pass_confluence">pass_confluence</code></td>
<td>
<p>a value in the range [0,1] that defines the passability of confluences (default is 1).</p>
</td></tr>
<tr><td><code id="c_ij_fun_+3A_pass_u">pass_u</code></td>
<td>
<p>the 'graph' edge attribute to be used as upstream passability. Default is &quot;pass_u&quot;.</p>
</td></tr>
<tr><td><code id="c_ij_fun_+3A_pass_d">pass_d</code></td>
<td>
<p>the 'graph' edge attribute to be used as downstream passability. Default is &quot;pass_d&quot;.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>dir_fragmentation_type = "symmetric"</code> is to be used when the directionality of the river network is not relevant.
The equivalent passability for each barrier is calculated as the product of upstream and downstream passabilities.
<code>dir_fragmentation_type = "asymmetric"</code> is to be used when the directionality is relevant.
The equivalent passability of each barrier is calculated as a function of the path connecting each couple of reaches
and depends on the direction of the path. Check the package vignette for more details.
</p>


<h3>Value</h3>

<p>a square matrix of size length(V(graph)) containing c_ij values.
The matrix is organized with &quot;from&quot; nodes on the columns and &quot;to&quot; nodes on the rows
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(igraph)
g &lt;- igraph::graph_from_literal(1-+2, 2-+5, 3-+4, 4-+5, 6-+7, 7-+10,
8-+9, 9-+10, 5-+11, 11-+12, 10-+13, 13-+12, 12-+14, 14-+15, 15-+16)
E(g)$id_dam &lt;- c("1", NA, "2", "3", NA, "4", NA, "5", "6", NA,  NA, NA, NA, "7", NA)
E(g)$type &lt;- ifelse(is.na(E(g)$id_dam), "joint", "dam")
V(g)$length &lt;- c(1, 1, 2, 3, 4, 1, 5, 1, 7, 7, 3, 2, 4, 5, 6, 9)
V(g)$HSI &lt;- c(0.2, 0.1, 0.3, 0.4, 0.5, 0.5, 0.5, 0.6, 0.7, 0.8, 0.8, 0.8, 0.8, 0.8, 0.8, 0.8)
V(g)$Id &lt;- V(g)$name
E(g)$pass_u &lt;- E(g)$pass_d &lt;- ifelse(!is.na(E(g)$id_dam),0.1,NA)
dist_mat &lt;- c_ij_fun(g)

</code></pre>

<hr>
<h2 id='d_index_calculation'>Calculate Reach- and Catchment-scale index improvement for scenarios of barriers removal</h2><span id='topic+d_index_calculation'></span>

<h3>Description</h3>

<p>Calculate Reach- and Catchment-scale index improvement for scenarios of barriers removal
</p>


<h3>Usage</h3>

<pre><code class='language-R'>d_index_calculation(
  graph,
  ...,
  barriers_metadata,
  id_barrier = "id_barrier",
  pass_u_updated = "pass_u_updated",
  pass_d_updated = "pass_d_updated",
  mode = "leave_one_out",
  parallel = TRUE,
  ncores
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="d_index_calculation_+3A_graph">graph</code></td>
<td>
<p>an object of class 'igraph'. Can be both directed or undirected.</p>
</td></tr>
<tr><td><code id="d_index_calculation_+3A_...">...</code></td>
<td>
<p>other arguments passed to the function 'index_calculation'</p>
</td></tr>
<tr><td><code id="d_index_calculation_+3A_barriers_metadata">barriers_metadata</code></td>
<td>
<p>data.frame that must contain a column having the same name as the 'id_barrier' attribute of the graph,
and two columns with the corresponding upstream and downstream improved passabilities
(see 'pass_u_updated' and 'pass_d_updated' parameters).</p>
</td></tr>
<tr><td><code id="d_index_calculation_+3A_id_barrier">id_barrier</code></td>
<td>
<p>graph edges attribute used to label barriers. Default is <code>"id_barrier"</code>. Must be of type charachter.</p>
</td></tr>
<tr><td><code id="d_index_calculation_+3A_pass_u_updated">pass_u_updated</code></td>
<td>
<p>field in barrier_metadata where updated value for upstream passability is stored
(recommended values higher than the original passability).</p>
</td></tr>
<tr><td><code id="d_index_calculation_+3A_pass_d_updated">pass_d_updated</code></td>
<td>
<p>field in barrier_metadata where updated value for downstream passability is stored
(recommended values higher than the original passability).</p>
</td></tr>
<tr><td><code id="d_index_calculation_+3A_mode">mode</code></td>
<td>
<p>currentlym only <code>"leave_one_out"</code> is implemented.</p>
</td></tr>
<tr><td><code id="d_index_calculation_+3A_parallel">parallel</code></td>
<td>
<p>logical value to flag if parallel option is to be used.</p>
</td></tr>
<tr><td><code id="d_index_calculation_+3A_ncores">ncores</code></td>
<td>
<p>define how many cores are used in parallel processing. Active only when <code>parallel = TRUE</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>Setting <code>c_ij_flag = FALSE</code> (see index_calculation arguments) removes from the calculations the effect of barriers, i.e. the c_ij contribution
is not used in the calculation of the index.
Setting <code>B_ij_flag = FALSE</code> (see index_calculation arguments) removes from the calculations the effect of movement/dispersal,
i.e. the B_ij contribution is not used in the calculation of the index.
Note that it is not possible to set both <code>c_ij_flag = FALSE</code> and <code>B_ij_flag = FALSE</code>.
</p>
<p>The setting <code>dir_distance_type = "symmetric"</code> (see index_calculation arguments) is to be used when the directionality of the river network is not relevant.
The distance between reaches midpoints is calculated for each couple of reaches.
The setting <code>dir_distance_type = "asymmetric"</code> (see index_calculation arguments) is to be used when the directionality is relevant.
The distance between reaches midpoints is calculated for each couple of reaches and splitted
between 'upstream travelled' distance and 'downstream travelled' distance
</p>
<p>The 'param_u', 'param_d', and 'param' values are interpreted differently based on the formula used to relate distance and probability.
When <code>disp_type ="exponential"</code> (see index_calculation arguments), those values are used as the base of the exponential dispersal kernel: B_ij = param^d_ij.
When <code>disp_type ="threshold"</code> (see index_calculation arguments), those values are used to define the maximum dispersal length: B_ij = ifelse(d_ij &lt; param, 1, 0).
</p>


<h3>Value</h3>

<p>returns a data.frame containing the percent improvement of the index for
each barrier present in the 'barriers_metadata' variable.
If <code>index_type = "full"</code> (see index_calculation arguments), the data.frame is organized by 'id_barrier'.
If <code>index_type = "reach"</code> (see index_calculation arguments), the data.frame is organized by 'id_barrier' and 'name'.
In both cases, both numerator and denominator used in the index calculations are reported in the columns 'num' and 'den'.
The column 'd_index' contains the relative index improvement when each barrier is removed.
</p>


<h3>References</h3>

<p>Baldan, D., Cunillera-Montcusí, D., Funk, A., &amp; Hein, T. (2022). Introducing ‘riverconn’: an R package to assess river connectivity indices. Environmental Modelling &amp; Software, 156, 105470.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(igraph)
library(igraph)
g &lt;- igraph::graph_from_literal(1-+2, 2-+4, 3-+2, 4-+6, 6-+7, 5-+6, 7-+8, 9-+5, 10-+5 )
E(g)$id_dam &lt;- c(NA, NA, "1", NA, NA, "2", NA, NA, NA)
E(g)$type &lt;- ifelse(is.na(E(g)$id_dam), "joint", "dam")
V(g)$length &lt;- c(1, 1, 2, 3, 4, 1, 5, 1, 2, 1)
V(g)$Id &lt;- V(g)$name
E(g)$pass_u &lt;- E(g)$pass_d &lt;- ifelse(!is.na(E(g)$id_dam),0.1,NA)
dams_metadata &lt;- data.frame("id_dam" =  c("1", "2"),
"pass_u_updated" = c(1, 1), "pass_d_updated" = c(1, 1))
d_index &lt;- d_index_calculation(g, barriers_metadata = dams_metadata,
id_barrier = "id_dam", parallel = FALSE, param = 0.6)


</code></pre>

<hr>
<h2 id='index_calculation'>Reach- and Catchment-scale indices of connectivity</h2><span id='topic+index_calculation'></span>

<h3>Description</h3>

<p>Reach- and Catchment-scale indices of connectivity
</p>


<h3>Usage</h3>

<pre><code class='language-R'>index_calculation(
  graph,
  weight = "length",
  nodes_id = "name",
  index_type = "full",
  index_mode = "to",
  c_ij_flag = TRUE,
  B_ij_flag = TRUE,
  dir_fragmentation_type = "symmetric",
  pass_confluence = 1,
  pass_u = "pass_u",
  pass_d = "pass_d",
  field_B = "length",
  dir_distance_type = "symmetric",
  disp_type = "exponential",
  param_u,
  param_d,
  param,
  param_l
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="index_calculation_+3A_graph">graph</code></td>
<td>
<p>an object of class igraph. Can be both directed or undirected.</p>
</td></tr>
<tr><td><code id="index_calculation_+3A_weight">weight</code></td>
<td>
<p>graph vertex attribute used to assign weights to the reaches (nodes/vertices). Should not be also an edge attribute.
Default is <code>"length"</code>.</p>
</td></tr>
<tr><td><code id="index_calculation_+3A_nodes_id">nodes_id</code></td>
<td>
<p>graph vertex attribute used to univoquely label reaches (nodes/vertices). Should not be also an edge attribute.
Default is <code>"name"</code>. The graph attribute must be a character vector.
Used to label the results when <code>index_type = "reach"</code></p>
</td></tr>
<tr><td><code id="index_calculation_+3A_index_type">index_type</code></td>
<td>
<p>indicates if the index should be calculated for the whole catchment (<code>index_type = "full"</code>),
for each reach (<code>index_type = "reach"</code>), or for each barrier (<code>index_type = "sum"</code>)</p>
</td></tr>
<tr><td><code id="index_calculation_+3A_index_mode">index_mode</code></td>
<td>
<p>indicates if reach index should be calculated based on inbound links (&quot;to&quot;) or outbound links (&quot;from&quot;).
Only active when <code>index_type = "reach"</code>.</p>
</td></tr>
<tr><td><code id="index_calculation_+3A_c_ij_flag">c_ij_flag</code></td>
<td>
<p>include the presence of barriers in the calculations (c_ij term).</p>
</td></tr>
<tr><td><code id="index_calculation_+3A_b_ij_flag">B_ij_flag</code></td>
<td>
<p>include dispersal/movement among reaches in the calculations (B_ij term).</p>
</td></tr>
<tr><td><code id="index_calculation_+3A_dir_fragmentation_type">dir_fragmentation_type</code></td>
<td>
<p>how directionality in c_ij calculations is dealt with:
<code>"symmetric"</code> (i.e. undirected graph) or <code>"asymmetric"</code> (i.e. directed graph). See details below.</p>
</td></tr>
<tr><td><code id="index_calculation_+3A_pass_confluence">pass_confluence</code></td>
<td>
<p>a value in the range [0,1] that defines the passability of confluences (default is 1).</p>
</td></tr>
<tr><td><code id="index_calculation_+3A_pass_u">pass_u</code></td>
<td>
<p>the 'graph' edge attribute to be used as upstream passability. Default is &quot;pass_u&quot;.</p>
</td></tr>
<tr><td><code id="index_calculation_+3A_pass_d">pass_d</code></td>
<td>
<p>the 'graph' edge attribute to be used as downstream passability. Default is &quot;pass_d&quot;.</p>
</td></tr>
<tr><td><code id="index_calculation_+3A_field_b">field_B</code></td>
<td>
<p>the 'graph' vertex attribute to be used to calculate the distance. Should not be also an edge attribute.
Default is <code>"length"</code>.</p>
</td></tr>
<tr><td><code id="index_calculation_+3A_dir_distance_type">dir_distance_type</code></td>
<td>
<p>how directionality in B_ij calculations is dealt with:
<code>"symmetric"</code> (i.e. undirected graph) or <code>"asymmetric"</code> (i.e. directed graph). See details.</p>
</td></tr>
<tr><td><code id="index_calculation_+3A_disp_type">disp_type</code></td>
<td>
<p>the formula used to calculate the probabilities in the B_ij matrix.
Use <code>"exponential"</code> for exponential decay, <code>"threshold"</code> for setting a distance threshold,
or <code>"leptokurtic"</code> for leptokurtic dispersal.</p>
</td></tr>
<tr><td><code id="index_calculation_+3A_param_u">param_u</code></td>
<td>
<p>upstream dispersal parameter. Must be a numeric value.
Only used if <code>dir_distance_type = "asymmetric"</code>. See details below.</p>
</td></tr>
<tr><td><code id="index_calculation_+3A_param_d">param_d</code></td>
<td>
<p>downstream dispersal parameter.
Must be a numeric value. Only used if <code>dir_distance_type = "asymmetric"</code>. See below for details.</p>
</td></tr>
<tr><td><code id="index_calculation_+3A_param">param</code></td>
<td>
<p>dispersal parameter. Must be a numeric value.
Only used if <code>dir_distance_type = "symmetric"</code>. See details below.</p>
</td></tr>
<tr><td><code id="index_calculation_+3A_param_l">param_l</code></td>
<td>
<p>the parameters for the leptokurtic dispersal mode. Must be a numeric vector of the
type <code>c(sigma_stat, sigma_mob, p)</code>. See details below.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Setting <code>c_ij_flag = FALSE</code> removes from the calculations the effect of barriers, i.e. the c_ij contribution
is not used in the calculation of the index.
Setting <code>B_ij_flag = FALSE</code> removes from the calculations the effect of movement/dispersal,
i.e. the B_ij contribution is not used in the calculation of the index.
Note that it is not possible to set both <code>c_ij_flag = FALSE</code> and <code>B_ij_flag = FALSE</code>.
</p>
<p>The setting <code>dir_distance_type = "symmetric"</code> is to be used when the directionality of the river network is not relevant.
The distance between reaches midpoints is calculated for each couple of reaches.
The setting <code>dir_distance_type = "asymmetric"</code> is to be used when the directionality is relevant.
The distance between reaches midpoints is calculated for each couple of reaches and splitted
between 'upstream travelled' distance and 'downstream travelled' distance.
When <code>disp_type ="leptokurtic"</code> is selected, symmetric dispersal is assumed.
</p>
<p>The 'param_u', 'param_d', and 'param' values are interpreted differently based on the formula used to relate distance (d_ij) and probability (B_ij).
When <code>disp_type ="exponential"</code>, those values are used as the base of the exponential dispersal kernel: B_ij = param^d_ij.
When <code>disp_type ="threshold"</code>, those values are used to define the maximum dispersal length: B_ij = ifelse(d_ij &lt; param, 1, 0).
</p>
<p>When <code>disp_type ="leptokurtic"</code> is selected, a leptokurtic dispersal kernel is used to calculate B_ij.
A leptokurtic dispersal kernel is a mixture of two zero-centered gaussian distributions with standard deviations
<code>sigma_stat</code> (static part of the population), and <code>sigma_mob</code> (mobile part of the population).
The probability of dispersal is calculated as: B_ij = p F(0, sigma_stat, d_ij) + (1-p) F(0, sigma_mob, d_ij)
where F is the upper tail of the gaussian cumulative density function.
</p>


<h3>Value</h3>

<p>If <code>index_type = "full"</code>, returns a numeric value with the index value (column 'index').
if <code>index_type = c("reach", "sum")</code>, returns a data frame with the index value (column 'index') for each reach
(the field specified in 'nodes_id' is used for reach identification in the data frame).
In both cases, both numerator and denominator used in the index calculations are reported in the columns 'num' and 'den'.
</p>


<h3>References</h3>

<p>Baldan, D., Cunillera-Montcusí, D., Funk, A., &amp; Hein, T. (2022). Introducing ‘riverconn’: an R package to assess river connectivity indices. Environmental Modelling &amp; Software, 156, 105470.
</p>
<p>Jumani, S., Deitch, M. J., Kaplan, D., Anderson, E. P., Krishnaswamy, J., Lecours, V., &amp; Whiles, M. R. (2020). River fragmentation and flow alteration metrics: a review of methods and directions for future research. Environmental Research Letters, 15(12), 123009.
</p>
<p>Radinger, J., &amp; Wolter, C. (2014). Patterns and predictors of fish dispersal in rivers. Fish and fisheries, 15(3), 456-473.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(igraph)
g &lt;- igraph::graph_from_literal(1-+2, 2-+5, 3-+4, 4-+5, 6-+7,
7-+10, 8-+9, 9-+10, 5-+11, 11-+12, 10-+13, 13-+12, 12-+14, 14-+15, 15-+16)
E(g)$id_dam &lt;- c("1", NA, "2", "3", NA, "4", NA, "5", "6", NA,  NA, NA, NA, "7", NA)
E(g)$type &lt;- ifelse(is.na(E(g)$id_dam), "joint", "dam")
V(g)$length &lt;- c(1, 1, 2, 3, 4, 1, 5, 1, 7, 7, 3, 2, 4, 5, 6, 9)
V(g)$HSI &lt;- c(0.2, 0.1, 0.3, 0.4, 0.5, 0.5, 0.5, 0.6, 0.7, 0.8, 0.8, 0.8, 0.8, 0.8, 0.8, 0.8)
V(g)$Id &lt;- V(g)$name
E(g)$pass_u &lt;- E(g)$pass_d &lt;- ifelse(!is.na(E(g)$id_dam),0.1,NA)
index &lt;- index_calculation(g, param = 0.9)


</code></pre>

<hr>
<h2 id='inner_d_index_calculation'>Calculate index improvement for scenarios of barriers removal - function not for export</h2><span id='topic+inner_d_index_calculation'></span>

<h3>Description</h3>

<p>Calculate index improvement for scenarios of barriers removal - function not for export
</p>


<h3>Usage</h3>

<pre><code class='language-R'>inner_d_index_calculation(
  graph,
  barriers_metadata,
  id_barrier,
  pass_u_updated,
  pass_d_updated,
  mode = "leave_one_out",
  parallel,
  ncores,
  weight,
  nodes_id,
  index_type,
  index_mode,
  c_ij_flag,
  B_ij_flag,
  dir_fragmentation_type,
  pass_confluence,
  pass_u,
  pass_d,
  field_B,
  dir_distance_type,
  disp_type,
  param_u,
  param_d,
  param,
  param_l
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="inner_d_index_calculation_+3A_graph">graph</code></td>
<td>
<p>an object of class igraph. Can be both directed or undirected.</p>
</td></tr>
<tr><td><code id="inner_d_index_calculation_+3A_barriers_metadata">barriers_metadata</code></td>
<td>
<p>data.frame that must contain a column having the same name as the 'id_barrier' attribute of the graph,
and two columns with the corresponding upstream and downstream improved passabilities (see pass_u_updated and pass_d_updated).</p>
</td></tr>
<tr><td><code id="inner_d_index_calculation_+3A_id_barrier">id_barrier</code></td>
<td>
<p>graph edges attribute used to label barriers. Default is <code>"id_barrier"</code>.</p>
</td></tr>
<tr><td><code id="inner_d_index_calculation_+3A_pass_u_updated">pass_u_updated</code></td>
<td>
<p>field in barrier_metadata where updated value for upstream passability is stored
(recommended values higher than the original passability).</p>
</td></tr>
<tr><td><code id="inner_d_index_calculation_+3A_pass_d_updated">pass_d_updated</code></td>
<td>
<p>field in barrier_metadata where updated value for downstream passability is stored
(recommended values higher than the original passability).</p>
</td></tr>
<tr><td><code id="inner_d_index_calculation_+3A_mode">mode</code></td>
<td>
<p>currentlym only <code>"leave_one_out"</code> is implemented.</p>
</td></tr>
<tr><td><code id="inner_d_index_calculation_+3A_parallel">parallel</code></td>
<td>
<p>logical value to flag if parallel option is to be used.</p>
</td></tr>
<tr><td><code id="inner_d_index_calculation_+3A_ncores">ncores</code></td>
<td>
<p>define how many cores are used in parallel processing. Active only when <code>parallel = TRUE</code></p>
</td></tr>
<tr><td><code id="inner_d_index_calculation_+3A_weight">weight</code></td>
<td>
<p>check index_calculation function.</p>
</td></tr>
<tr><td><code id="inner_d_index_calculation_+3A_nodes_id">nodes_id</code></td>
<td>
<p>check index_calculation function.</p>
</td></tr>
<tr><td><code id="inner_d_index_calculation_+3A_index_type">index_type</code></td>
<td>
<p>check index_calculation function.</p>
</td></tr>
<tr><td><code id="inner_d_index_calculation_+3A_index_mode">index_mode</code></td>
<td>
<p>check index_calculation function.</p>
</td></tr>
<tr><td><code id="inner_d_index_calculation_+3A_c_ij_flag">c_ij_flag</code></td>
<td>
<p>check index_calculation function.</p>
</td></tr>
<tr><td><code id="inner_d_index_calculation_+3A_b_ij_flag">B_ij_flag</code></td>
<td>
<p>check index_calculation function.</p>
</td></tr>
<tr><td><code id="inner_d_index_calculation_+3A_dir_fragmentation_type">dir_fragmentation_type</code></td>
<td>
<p>check index_calculation function.</p>
</td></tr>
<tr><td><code id="inner_d_index_calculation_+3A_pass_confluence">pass_confluence</code></td>
<td>
<p>check index_calculation function.</p>
</td></tr>
<tr><td><code id="inner_d_index_calculation_+3A_pass_u">pass_u</code></td>
<td>
<p>check index_calculation function.</p>
</td></tr>
<tr><td><code id="inner_d_index_calculation_+3A_pass_d">pass_d</code></td>
<td>
<p>check index_calculation function.</p>
</td></tr>
<tr><td><code id="inner_d_index_calculation_+3A_field_b">field_B</code></td>
<td>
<p>check index_calculation function.</p>
</td></tr>
<tr><td><code id="inner_d_index_calculation_+3A_dir_distance_type">dir_distance_type</code></td>
<td>
<p>check index_calculation function.</p>
</td></tr>
<tr><td><code id="inner_d_index_calculation_+3A_disp_type">disp_type</code></td>
<td>
<p>check index_calculation function.</p>
</td></tr>
<tr><td><code id="inner_d_index_calculation_+3A_param_u">param_u</code></td>
<td>
<p>check index_calculation function.</p>
</td></tr>
<tr><td><code id="inner_d_index_calculation_+3A_param_d">param_d</code></td>
<td>
<p>check index_calculation function.</p>
</td></tr>
<tr><td><code id="inner_d_index_calculation_+3A_param">param</code></td>
<td>
<p>check index_calculation function.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Setting <code>c_ij_flag = FALSE</code> removes from the calculations the effect of barriers, i.e. the c_ij contribution
is not used in the calculation of the index.
Setting <code>B_ij_flag = FALSE</code> removes from the calculations the effect of movement/dispersal,
i.e. the B_ij contribution is not used in the calculation of the index.
Note that it is not possible to set both <code>c_ij_flag = FALSE</code> and <code>B_ij_flag = FALSE</code>.
</p>
<p>The setting <code>dir_distance_type = "symmetric"</code> is to be used when the directionality of the river network is not relevant.
The distance between reaches midpoints is calculated for each couple of reaches.
The setting <code>dir_distance_type = "asymmetric"</code> is to be used when the directionality is relevant.
The distance between reaches midpoints is calculated for each couple of reaches and splitted
between 'upstream travelled' distance and 'downstream travelled' distance
</p>
<p>The 'param_u', 'param_d', and 'param' values are interpreted differently based on the formula used to relate distance and probability.
When <code>disp_type ="exponential"</code>, those values are used as the base of the exponential dispersal kernel: B_ij = param^d_ij.
When <code>disp_type ="threshold"</code>, those values are used to define the maximum dispersal length: B_ij = ifelse(d_ij &lt; param, 1, 0).
</p>


<h3>Value</h3>

<p>returns a data.frame containing the percent improvement of the index for
each barrier present in the 'barriers_metadata' variable.
If <code>index_type = "full"</code>, the data.frame is organized by 'id_barrier'.
If <code>index_type = "reach"</code>, the data.frame is organized by 'id_barrier' and 'name'.
In both cases, both numerator and denominator used in the index calculations are reported in the columns 'num' and 'den'.
The column 'd_index' contains the relative index improvement when each barrier is removed.
</p>

<hr>
<h2 id='inner_t_index_calculation'>Calculates time-dependent index when nodes weights or barriers passability are changing - not for exporting</h2><span id='topic+inner_t_index_calculation'></span>

<h3>Description</h3>

<p>Calculates time-dependent index when nodes weights or barriers passability are changing - not for exporting
</p>


<h3>Usage</h3>

<pre><code class='language-R'>inner_t_index_calculation(
  graph,
  barriers_metadata,
  id_barrier,
  year,
  pass_u,
  pass_d,
  weights_metadata,
  weight,
  nodes_id,
  parallel,
  ncores,
  index_type,
  index_mode,
  c_ij_flag,
  B_ij_flag,
  dir_fragmentation_type,
  pass_confluence,
  field_B,
  dir_distance_type,
  disp_type,
  param_u,
  param_d,
  param,
  param_l
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="inner_t_index_calculation_+3A_graph">graph</code></td>
<td>
<p>an object of class igraph. Can be both directed or undirected.</p>
</td></tr>
<tr><td><code id="inner_t_index_calculation_+3A_barriers_metadata">barriers_metadata</code></td>
<td>
<p>data.frame that must contain a column having the same name as the 'id_barrier' attribute of the graph,
and two columns with the corresponding upstream and downstream improved passabilities (see pass_u and pass_d), and a column with the year
passability was changed. This data frame can be obtained from easily-formatted data with the function <code>t_passability_sequencer</code>.</p>
</td></tr>
<tr><td><code id="inner_t_index_calculation_+3A_id_barrier">id_barrier</code></td>
<td>
<p>graph edges numeric attribute used to label barriers. Default is <code>"id_barrier"</code>. It should be present in the 'barriers metadata' input as well.</p>
</td></tr>
<tr><td><code id="inner_t_index_calculation_+3A_year">year</code></td>
<td>
<p>field of the 'barriers metadata' where temporal information on the changes in passabiity is stored.</p>
</td></tr>
<tr><td><code id="inner_t_index_calculation_+3A_pass_u">pass_u</code></td>
<td>
<p>check index_calculation function.</p>
</td></tr>
<tr><td><code id="inner_t_index_calculation_+3A_pass_d">pass_d</code></td>
<td>
<p>check index_calculation function.</p>
</td></tr>
<tr><td><code id="inner_t_index_calculation_+3A_weights_metadata">weights_metadata</code></td>
<td>
<p>data.frame that must contain a column having the same name as the 'nodes_id' attribute of the graph,
a column with he corresponding weight information (see 'weight' parameter), and a column with the year
weight was changed. This data frame can be obtained from easily-formatted data with the function <code>t_weight_sequencer</code>.</p>
</td></tr>
<tr><td><code id="inner_t_index_calculation_+3A_weight">weight</code></td>
<td>
<p>param weight graph vertex attribute used to assign weights to the reaches (nodes). Default is <code>"length"</code>.</p>
</td></tr>
<tr><td><code id="inner_t_index_calculation_+3A_nodes_id">nodes_id</code></td>
<td>
<p>graph vertex attribute used to univoquely label reaches (nodes). Default is <code>"name"</code>.</p>
</td></tr>
<tr><td><code id="inner_t_index_calculation_+3A_parallel">parallel</code></td>
<td>
<p>logical value to flag if parallel option is to be used.</p>
</td></tr>
<tr><td><code id="inner_t_index_calculation_+3A_ncores">ncores</code></td>
<td>
<p>define how many cores are used in parallel processing. Active only when <code>parallel = TRUE</code></p>
</td></tr>
<tr><td><code id="inner_t_index_calculation_+3A_index_type">index_type</code></td>
<td>
<p>check index_calculation function.</p>
</td></tr>
<tr><td><code id="inner_t_index_calculation_+3A_index_mode">index_mode</code></td>
<td>
<p>check index_calculation function.</p>
</td></tr>
<tr><td><code id="inner_t_index_calculation_+3A_c_ij_flag">c_ij_flag</code></td>
<td>
<p>check index_calculation function.</p>
</td></tr>
<tr><td><code id="inner_t_index_calculation_+3A_b_ij_flag">B_ij_flag</code></td>
<td>
<p>check index_calculation function.</p>
</td></tr>
<tr><td><code id="inner_t_index_calculation_+3A_dir_fragmentation_type">dir_fragmentation_type</code></td>
<td>
<p>check index_calculation function.</p>
</td></tr>
<tr><td><code id="inner_t_index_calculation_+3A_pass_confluence">pass_confluence</code></td>
<td>
<p>check index_calculation function.</p>
</td></tr>
<tr><td><code id="inner_t_index_calculation_+3A_field_b">field_B</code></td>
<td>
<p>check index_calculation function.</p>
</td></tr>
<tr><td><code id="inner_t_index_calculation_+3A_dir_distance_type">dir_distance_type</code></td>
<td>
<p>check index_calculation function.</p>
</td></tr>
<tr><td><code id="inner_t_index_calculation_+3A_disp_type">disp_type</code></td>
<td>
<p>check index_calculation function.</p>
</td></tr>
<tr><td><code id="inner_t_index_calculation_+3A_param_u">param_u</code></td>
<td>
<p>check index_calculation function.</p>
</td></tr>
<tr><td><code id="inner_t_index_calculation_+3A_param_d">param_d</code></td>
<td>
<p>check index_calculation function.</p>
</td></tr>
<tr><td><code id="inner_t_index_calculation_+3A_param">param</code></td>
<td>
<p>check index_calculation function.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a data.frame with a 'year' field and related connectity index.
If <code>index_type = "reach"</code>, the data.frame is organized by 'year' and 'name'.
</p>

<hr>
<h2 id='set_B_directionality'>Calculates average upstream/downstream or combined distance between each couple of reaches</h2><span id='topic+set_B_directionality'></span>

<h3>Description</h3>

<p>Calculates average upstream/downstream or combined distance between each couple of reaches
</p>


<h3>Usage</h3>

<pre><code class='language-R'>set_B_directionality(
  graph,
  dir_distance_type = "symmetric",
  field_B = "length"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="set_B_directionality_+3A_graph">graph</code></td>
<td>
<p>an object of class igraph. Can be both directed or undirected.</p>
</td></tr>
<tr><td><code id="set_B_directionality_+3A_dir_distance_type">dir_distance_type</code></td>
<td>
<p>how directionality in B_ij calculations is dealt with:
<code>"symmetric"</code> (i.e. undirected graph) or <code>"asymmetric"</code> (i.e. directed graph). See details.</p>
</td></tr>
<tr><td><code id="set_B_directionality_+3A_field_b">field_B</code></td>
<td>
<p>the 'graph' edge attribute to be used to calculate the distance. Default is <code>"length"</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an object of class 'igraph' with the upstream/downstream/total distances stored as edges attributes.
</p>

<hr>
<h2 id='set_c_directionality'>Calculates equivalent passability based on graph directionality and directionality type</h2><span id='topic+set_c_directionality'></span>

<h3>Description</h3>

<p>Calculates equivalent passability based on graph directionality and directionality type
</p>


<h3>Usage</h3>

<pre><code class='language-R'>set_c_directionality(
  graph,
  dir_fragmentation_type = "symmetric",
  pass_confluence = 1,
  pass_u = "pass_u",
  pass_d = "pass_d"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="set_c_directionality_+3A_graph">graph</code></td>
<td>
<p>an object of class igraph. Can be both directed or undirected.</p>
</td></tr>
<tr><td><code id="set_c_directionality_+3A_dir_fragmentation_type">dir_fragmentation_type</code></td>
<td>
<p>how directionality in c_ij calculations is dealt with:
<code>"symmetric"</code> (i.e. undirected graph) or <code>"asymmetric"</code> (i.e. directed graph)</p>
</td></tr>
<tr><td><code id="set_c_directionality_+3A_pass_confluence">pass_confluence</code></td>
<td>
<p>a value in the range [0,1] that defines the passability of confluences (default is 1).</p>
</td></tr>
<tr><td><code id="set_c_directionality_+3A_pass_u">pass_u</code></td>
<td>
<p>the 'graph' edge attribute to be used as upstream passability. Default is &quot;pass_u&quot;.</p>
</td></tr>
<tr><td><code id="set_c_directionality_+3A_pass_d">pass_d</code></td>
<td>
<p>the 'graph' edge attribute to be used as downstream passability. Default is &quot;pass_d&quot;.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an object of class 'igraph' with the equivalent passability stored in the edge attribute 'pass_eq'
</p>

<hr>
<h2 id='set_graph_directionality'>Create directed river graph based on outlet flag</h2><span id='topic+set_graph_directionality'></span>

<h3>Description</h3>

<p>The input graph can be either directed or undirected. If directed, then it is made undirected before directionality is assigned.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>set_graph_directionality(graph, field_name = "name", outlet_name)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="set_graph_directionality_+3A_graph">graph</code></td>
<td>
<p>an 'igraph' object representing a river structure where reaches are nodes and confluences (or fragmentation items) are links.</p>
</td></tr>
<tr><td><code id="set_graph_directionality_+3A_field_name">field_name</code></td>
<td>
<p>a character value that flags the vertices attribute used to designate the outlet.
Each vertex must have an unique value for this field.</p>
</td></tr>
<tr><td><code id="set_graph_directionality_+3A_outlet_name">outlet_name</code></td>
<td>
<p>a character value corresponding to the 'field_name' attribute</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an object of class 'igraph' containing a directed graph.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(igraph)
g &lt;- igraph::graph_from_literal(1-2, 2-4, 3-2, 4-6, 6-7, 5-6, 7-8, 9-5, 10-5 )
g1 &lt;- set_graph_directionality(g, field_name = "name", "8")

</code></pre>

<hr>
<h2 id='t_index_calculation'>Calculates time-dependent index when nodes weights or barriers passability are changing</h2><span id='topic+t_index_calculation'></span>

<h3>Description</h3>

<p>Calculates time-dependent index when nodes weights or barriers passability are changing
</p>


<h3>Usage</h3>

<pre><code class='language-R'>t_index_calculation(
  graph = graph,
  ...,
  barriers_metadata,
  id_barrier = "id_barrier",
  year = "year",
  pass_u = "pass_u",
  pass_d = "pass_d",
  weights_metadata,
  weight = "length",
  nodes_id = "name",
  parallel = TRUE,
  ncores
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="t_index_calculation_+3A_graph">graph</code></td>
<td>
<p>an object of class igraph. Can be both directed or undirected.</p>
</td></tr>
<tr><td><code id="t_index_calculation_+3A_...">...</code></td>
<td>
<p>other arguments passed to the function index_calculation</p>
</td></tr>
<tr><td><code id="t_index_calculation_+3A_barriers_metadata">barriers_metadata</code></td>
<td>
<p>data.frame that must contain a column having the same name as the 'id_barrier' attribute of the graph,
and two columns with the corresponding upstream and downstream improved passabilities (see pass_u and pass_d), and a column with the year
passability was changed. This data frame can be obtained from easily-formatted data with the function <code>t_passability_sequencer</code>.</p>
</td></tr>
<tr><td><code id="t_index_calculation_+3A_id_barrier">id_barrier</code></td>
<td>
<p>graph edges attribute used to label barriers. Default is <code>"id_barrier"</code>. It should be present in the 'barriers metadata' input as well.</p>
</td></tr>
<tr><td><code id="t_index_calculation_+3A_year">year</code></td>
<td>
<p>field of the 'barriers metadata' where temporal information on the changes in passability is stored.</p>
</td></tr>
<tr><td><code id="t_index_calculation_+3A_pass_u">pass_u</code></td>
<td>
<p>field of the 'barriers metadata' where temporal-dependent upstream passability is stored.</p>
</td></tr>
<tr><td><code id="t_index_calculation_+3A_pass_d">pass_d</code></td>
<td>
<p>field of the 'barriers metadata' where temporal-dependent downstream passability is stored.</p>
</td></tr>
<tr><td><code id="t_index_calculation_+3A_weights_metadata">weights_metadata</code></td>
<td>
<p>data.frame that must contain a column having the same name as the 'nodes_id' attribute of the graph,
a column with he corresponding weight information (see 'weight' parameter), and a column with the year
weight was changed. This data frame can be obtained from easily-formatted data with the function <code>t_weight_sequencer</code>.</p>
</td></tr>
<tr><td><code id="t_index_calculation_+3A_weight">weight</code></td>
<td>
<p>param weight graph vertex attribute used to assign weights to the reaches (nodes). Default is <code>"length"</code>.</p>
</td></tr>
<tr><td><code id="t_index_calculation_+3A_nodes_id">nodes_id</code></td>
<td>
<p>graph vertex attribute used to uniquely label reaches (nodes). Default is <code>"name"</code>.</p>
</td></tr>
<tr><td><code id="t_index_calculation_+3A_parallel">parallel</code></td>
<td>
<p>logical value to flag if parallel option is to be used.</p>
</td></tr>
<tr><td><code id="t_index_calculation_+3A_ncores">ncores</code></td>
<td>
<p>define how many cores are used in parallel processing. Active only when <code>parallel = TRUE</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>a data.frame with a 'year' field and related connectivity index.
If <code>index_type = "reach"</code>, the data.frame is organized by 'year' and 'name'.
</p>


<h3>References</h3>

<p>Baldan, D., Cunillera-Montcusí, D., Funk, A., &amp; Hein, T. (2022). Introducing ‘riverconn’: an R package to assess river connectivity indices. Environmental Modelling &amp; Software, 156, 105470.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(igraph)
g &lt;- igraph::graph_from_literal(1-+2, 2-+4, 3-+2, 4-+6, 6-+5)
E(g)$id_barrier &lt;- c(NA, NA, "1", NA, NA)
E(g)$type &lt;- ifelse(is.na(E(g)$id_barrier), "joint", "dam")
V(g)$length &lt;- c(1, 1, 2, 3, 4,5)
V(g)$Id &lt;- V(g)$name
E(g)$pass_u &lt;- E(g)$pass_d &lt;- ifelse(!is.na(E(g)$id_barrier),0.1,NA)
barriers_data &lt;- data.frame("id_barrier" = c("1"),
   "year_c" = 2000, "pass_c_u" = 0.1, "pass_c_d" = 0.4)
seq_ops &lt;- c("c")
barriers_metadata &lt;- t_passability_sequencer(barriers_data, seq_ops)
weights_dataframe &lt;- data.frame("name" = seq(1,6) %&gt;% as.character,
    "length_1999" = c(1, 1, 2, 3, 4,5))
weights_metadata &lt;- t_weights_sequencer(weights_dataframe, weight = "length")
t_index &lt;- t_index_calculation(g, barriers_metadata = barriers_metadata,
 weights_metadata = weights_metadata, weight = "length", parallel = FALSE, B_ij_flag = FALSE)




</code></pre>

<hr>
<h2 id='t_passability_sequencer'>Create the time-dependent metadata for barriers</h2><span id='topic+t_passability_sequencer'></span>

<h3>Description</h3>

<p>Create the time-dependent metadata for barriers
</p>


<h3>Usage</h3>

<pre><code class='language-R'>t_passability_sequencer(passability_information, seq_ops)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="t_passability_sequencer_+3A_passability_information">passability_information</code></td>
<td>
<p>a data frame in wide format. Must contain an 'id_barrier' column. Each change
in passability is listed in a group of 3 columns: 'year_op', 'pass_op_u', and 'pass_op_d', listing the year the operation (op) took place, and
the related upstream and downstream passabilities. In case the passability did not change, a NA value should be used. See details.</p>
</td></tr>
<tr><td><code id="t_passability_sequencer_+3A_seq_ops">seq_ops</code></td>
<td>
<p>A charachter vector with the temporal sequence of operations. It should contain all the operation strings
in the 'passability_information' data frame.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is meant to help processing data the way they can be obtained from a database, or the way they are stored in a spreadsheet.
The substring 'op' in the fields 'year_op', 'pass_op_u', and 'pass_op_d' is used to identify each operation and to relate it to the
relative passability parameters. For example, c can be used for construction, and fp for the implementation of a fish pass.
In this case, <code>passability_information</code> will have the fields 'year_c', 'pass_c_u', and 'pass_c_d', 'year_fp', 'pass_fp_u', and 'pass_fp_d'.
Then, the input <code>seq_ops = c("c", "fp")</code>, meaning that first the operation named 'c' occurred, and then the operation named 'fp' occurred.
</p>


<h3>Value</h3>

<p>a dataframe in a long format that can be used as input to the tDCI function.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>barriers_data &lt;- data.frame("id_barrier" = c("1", "2"),
"year_c" = c(1950, 1990), "pass_c_u" = c(0.1, 0.1), "pass_c_d" = c(0.4, 0.4),
"year_fp" = c(2000, 2010), "pass_fp_u" = c(0.5, 0.5), "pass_fp_d" = c(0.8, 0.8))
seq_ops &lt;- c("c", "fp")
t_metadata &lt;- t_passability_sequencer(barriers_data, seq_ops)

</code></pre>

<hr>
<h2 id='t_weights_sequencer'>Create the time-dependent weights data</h2><span id='topic+t_weights_sequencer'></span>

<h3>Description</h3>

<p>Create the time-dependent weights data
</p>


<h3>Usage</h3>

<pre><code class='language-R'>t_weights_sequencer(weights_information, weight = "length", nodes_id = "name")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="t_weights_sequencer_+3A_weights_information">weights_information</code></td>
<td>
<p>a data.frame that must contain a 'nodes_id' column and several 'weight' columns.
Weight columns are named with the string contained in the 'weight' input and the relative year (4 digits format),
separated by an underscore (e.g. when <code>weight = "length"</code>, the names of the 'weight' columns will be:
'weight_1990', 'weight_2000', 'weight_2020', etc.).</p>
</td></tr>
<tr><td><code id="t_weights_sequencer_+3A_weight">weight</code></td>
<td>
<p>a character object containing the label of the columns whose weight change with time</p>
</td></tr>
<tr><td><code id="t_weights_sequencer_+3A_nodes_id">nodes_id</code></td>
<td>
<p>a character object containing the label of the columns that uniquely identify reaches.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a data frame with columns 'name', 'year', and 'weight' to be used in the function <code>t_index_calculation</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>weights_dataframe &lt;- data.frame("id" = c("1", "2", "3", "4", "5"),
"weight_1900" = c(10, 15, 100, 50, 40),
"weight_1950"= c(11, 16, 90, 55, 45),
"weight_2000"= c(13, 19, 80, 49, 44))
weights_metadata &lt;- t_weights_sequencer(weights_dataframe, weight = "weight", nodes_id = "id")

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
