<!DOCTYPE html><html><head><title>Help for package SpatialGraph</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {SpatialGraph}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#SpatialGraph-package'>
<p>The SpatialGraph Class and Utilities</p></a></li>
<li><a href='#attSGe'><p>Add or Modify attributes in SpatialGraph edges</p></a></li>
<li><a href='#distSG'><p>Calculate across-network distance for a set of sparse points</p></a></li>
<li><a href='#distSGv'><p>Calculate the distance slot in a SpatialGraph</p></a></li>
<li><a href='#explodeSLDF'><p>Explode Lines in a SpatialLinesDataFrame</p></a></li>
<li><a href='#pointLineD'><p>Euclidean distance from a set of points to a line segment</p></a></li>
<li><a href='#pointOnLine'><p>Snap a points to a line</p></a></li>
<li><a href='#pointOnSegment'><p>Snap a points to a segment</p></a></li>
<li><a href='#pointsPolylineD'><p>closest points in a polyline to a set of points</p></a></li>
<li><a href='#pointsSLDFchain'><p>Obtain chainage from sparse points along a SpatialLinesDataFrame</p></a></li>
<li><a href='#pointsToLines'><p>Snap a set of points to a set of lines</p></a></li>
<li><a href='#polylineChainage'><p>Obtain the chainage of nodes along a polyline</p></a></li>
<li><a href='#polylineLength'><p>Obtain the length of a polyline</p></a></li>
<li><a href='#revSGe'><p>Reverse Lines in a SpatialGraph</p></a></li>
<li><a href='#rotation'><p>Rotate 2D points</p></a></li>
<li><a href='#routeSDG'><p>Accumulate sources/sinks along a directed SpatialGraph</p></a></li>
<li><a href='#sg2igraph'><p>Map a SpatialGraph into an igraph</p></a></li>
<li><a href='#sgChVIDs'><p>Change vertex IDs in a SpatialGraph</p></a></li>
<li><a href='#sl2sg'><p>Map a SpatialLinesDataFrame into a SpatialGraph</p></a></li>
<li><a href='#SpatialGraph'><p>Create a SpatialGraph object</p></a></li>
<li><a href='#SpatialGraph-class'><p>Class &quot;SpatialGraph&quot;</p></a></li>
<li><a href='#splitPolyline'><p>Split a polyline into a number of transects</p></a></li>
<li><a href='#splitSLDF'><p>Split 1-Line Lines in a SpatialLines or a SpatialLinesDataFrame by intersection</p>
with a point dataset</a></li>
<li><a href='#textSGe'><p>Label edges in a SpatialGraph plot</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Version:</td>
<td>1.0-4</td>
</tr>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>The SpatialGraph Class and Utilities</td>
</tr>
<tr>
<td>Date:</td>
<td>2023-09-26</td>
</tr>
<tr>
<td>Imports:</td>
<td>igraph, methods, pracma, sf, shape, sp, splancs</td>
</tr>
<tr>
<td>Author:</td>
<td>Javier Garcia-Pintado</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Javier Garcia-Pintado &lt;jgarciapintado@marum.de&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Provision of the S4 SpatialGraph class built on top of objects provided by 'igraph' and 'sp' packages, and associated utilities. See the documentation of the SpatialGraph-class within this package for further description. An example of how from a few points one can arrive to a SpatialGraph is provided in the function sl2sg().  </td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/garciapintado/SpatialGraph">https://github.com/garciapintado/SpatialGraph</a></td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-09-28 13:26:51 UTC; jgp</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-09-28 13:50:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='SpatialGraph-package'>
The SpatialGraph Class and Utilities
</h2><span id='topic+SpatialGraph-package'></span><span id='topic+SpatialGraph-package'></span>

<h3>Description</h3>

<p>Provision of the S4 SpatialGraph class built on top of objects provided by 'igraph' and 'sp' packages, and associated utilities. See the documentation of the SpatialGraph-class within this package for further description. An example of how from a few points one can arrive to a SpatialGraph is provided in the function sl2sg().  
</p>


<h3>Details</h3>

<p>The DESCRIPTION file:
</p>

<table>
<tr>
 <td style="text-align: left;">
Package: </td><td style="text-align: left;"> SpatialGraph</td>
</tr>
<tr>
 <td style="text-align: left;">
Version: </td><td style="text-align: left;"> 1.0-4</td>
</tr>
<tr>
 <td style="text-align: left;">
Type: </td><td style="text-align: left;"> Package</td>
</tr>
<tr>
 <td style="text-align: left;">
Title: </td><td style="text-align: left;"> The SpatialGraph Class and Utilities</td>
</tr>
<tr>
 <td style="text-align: left;">
Date: </td><td style="text-align: left;"> 2023-09-26</td>
</tr>
<tr>
 <td style="text-align: left;">
Imports: </td><td style="text-align: left;"> igraph, methods, pracma, sf, shape, sp, splancs</td>
</tr>
<tr>
 <td style="text-align: left;">
Author: </td><td style="text-align: left;"> Javier Garcia-Pintado</td>
</tr>
<tr>
 <td style="text-align: left;">
Maintainer: </td><td style="text-align: left;"> Javier Garcia-Pintado &lt;jgarciapintado@marum.de&gt;</td>
</tr>
<tr>
 <td style="text-align: left;">
Description: </td><td style="text-align: left;"> Provision of the S4 SpatialGraph class built on top of objects provided by 'igraph' and 'sp' packages, and associated utilities. See the documentation of the SpatialGraph-class within this package for further description. An example of how from a few points one can arrive to a SpatialGraph is provided in the function sl2sg().  </td>
</tr>
<tr>
 <td style="text-align: left;">
License: </td><td style="text-align: left;"> GPL (&gt;=2)</td>
</tr>
<tr>
 <td style="text-align: left;">
URL: </td><td style="text-align: left;"> https://github.com/garciapintado/SpatialGraph</td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>


<p>Index of help topics:
</p>
<pre>
SpatialGraph            Create a SpatialGraph object
SpatialGraph-class      Class "SpatialGraph"
SpatialGraph-package    The SpatialGraph Class and Utilities
attSGe                  Add or Modify attributes in SpatialGraph edges
distSG                  Calculate across-network distance for a set of
                        sparse points
distSGv                 Calculate the distance slot in a SpatialGraph
explodeSLDF             Explode Lines in a SpatialLinesDataFrame
pointLineD              Euclidean distance from a set of points to a
                        line segment
pointOnLine             Snap a points to a line
pointOnSegment          Snap a points to a segment
pointsPolylineD         closest points in a polyline to a set of points
pointsSLDFchain         Obtain chainage from sparse points along a
                        SpatialLinesDataFrame
pointsToLines           Snap a set of points to a set of lines
polylineChainage        Obtain the chainage of nodes along a polyline
polylineLength          Obtain the length of a polyline
revSGe                  Reverse Lines in a SpatialGraph
rotation                Rotate 2D points
routeSDG                Accumulate sources/sinks along a directed
                        SpatialGraph
sg2igraph               Map a SpatialGraph into an igraph
sgChVIDs                Change vertex IDs in a SpatialGraph
sl2sg                   Map a SpatialLinesDataFrame into a SpatialGraph
splitPolyline           Split a polyline into a number of transects
splitSLDF               Split 1-Line Lines in a SpatialLines or a
                        SpatialLinesDataFrame by intersection with a
                        point dataset
textSGe                 Label edges in a SpatialGraph plot
</pre>
<p>see the documentation of the function sl2sg in this package to get a
start. A case study making use if this package is Garcia-Pintado et al (2015)
</p>


<h3>Author(s)</h3>

<p>Javier Garcia-Pintado
</p>
<p>Maintainer: Javier Garcia-Pintado &lt;jgarciapintado@marum.de&gt;
</p>


<h3>References</h3>

<p>The first published application of this package is
Garcia-Pintado, J. et al. (2015). Satellite-supported flood forecasting in
river networks: a real case study. J. Hydrol. 523, 705-724.
</p>

<hr>
<h2 id='attSGe'>Add or Modify attributes in SpatialGraph edges</h2><span id='topic+attSGe'></span>

<h3>Description</h3>

<p>Add or Modify attributes in SpatialGraph edges
</p>


<h3>Usage</h3>

<pre><code class='language-R'>attSGe(SG, att, eID, val, default)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="attSGe_+3A_sg">SG</code></td>
<td>
<p><a href="#topic+SpatialGraph">SpatialGraph</a></p>
</td></tr>
<tr><td><code id="attSGe_+3A_att">att</code></td>
<td>
<p>name of the field [column] in the edge dataframe to be added/modified</p>
</td></tr>
<tr><td><code id="attSGe_+3A_eid">eID</code></td>
<td>
<p>edge identifiers [row.names of the edge data.frame]</p>
</td></tr>
<tr><td><code id="attSGe_+3A_val">val</code></td>
<td>
<p>values corresponding the <code>eID</code> above</p>
</td></tr>
<tr><td><code id="attSGe_+3A_default">default</code></td>
<td>
<p>default values for edges not considered in <code>eID</code> above</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <a href="#topic+SpatialGraph">SpatialGraph</a>
</p>

<hr>
<h2 id='distSG'>Calculate across-network distance for a set of sparse points</h2><span id='topic+distSG'></span>

<h3>Description</h3>

<p>This function obtains the across-network distance for a set
of sparse points, by using the distance slot in a <a href="#topic+SpatialGraph">SpatialGraph</a>. The
calculation is supported by a previously calculated between vertex
distance matrix
[via a call to the library <code>igraph</code> by the function <a href="#topic+distSGv">distSGv</a>].
The SpatialGraph is considered as undirected for distance
calculation.
If <code>euc=TRUE</code> [default], the distance between two points is defined within this function
as the maximum of both the minimum along-network distance and the Euclidean
distance. The distance itself between the points
in x,y and the network is neglected in the function for the
along-network distance.
Both, <code>x</code> and <code>y</code>, are <code>SpatialPointsDataFrame</code>
objects, which must contain at least the fields
<code>eID</code> and <code>chain</code>, which describe their relationship with
the <code>SpatialGraph</code> object defined by <code>SG</code>. These can be
obtained with either the function <code><a href="#topic+pointsSLDFchain">pointsSLDFchain</a></code> or
<a href="#topic+pointsToLines">pointsToLines</a> (the latter is faster, but depends on GEOS)
</p>


<h3>Usage</h3>

<pre><code class='language-R'> distSG(SG, x, y = NULL, euc = TRUE, wei = NULL, getpath = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="distSG_+3A_sg">SG</code></td>
<td>
<p><a href="#topic+SpatialGraph">SpatialGraph</a></p>
</td></tr>
<tr><td><code id="distSG_+3A_x">x</code></td>
<td>
<p><code>SpatialPointsDataFrame</code></p>
</td></tr>
<tr><td><code id="distSG_+3A_y">y</code></td>
<td>
<p><code>SpatialPointsDataFrame</code></p>
</td></tr>
<tr><td><code id="distSG_+3A_euc">euc</code></td>
<td>
<p>boolean scalar, whether to use Euclidean distance as
minimum threshold for resulting distances</p>
</td></tr>
<tr><td><code id="distSG_+3A_wei">wei</code></td>
<td>
<p>if not null, field in <code>SG@e</code> with a variable to obtain
a state-related weight. See details below.</p>
</td></tr>
<tr><td><code id="distSG_+3A_getpath">getpath</code></td>
<td>
<p>if TRUE (and wei != NULL), <code>eID</code> identifiers for
each path from <code>x</code> to <code>y</code> elements is returned</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The application of state-related weights in this version is a simple
state-dependent weight matrix related to some field in <code>SG@e</code> [i.e. the
edges in the input <code>SpatialGraph</code>]. The only current calculation
evaluates the path between queried points (x,y), and along the path, for
every junction and jump into a new edge, the ratio for the evaluated state variable (taken as
the highest value divided by the lowest value) between the two edges at
the junction is obtained. Currently a
maximum ratio equal to 10.0 is hard-coded. The product
of ratios along the path gives the weight.
</p>


<h3>Value</h3>

<p>If <code>wei=NULL</code>, a matrix of distances between <code>x</code> and
<code>y</code>. If <code>wei</code> is not <code>NULL</code>, a list with a distance
matrix and weight matrix (plus a matrix with eID identifiers
for the path, if <code>getpath=TRUE</code>) is returned.
</p>


<h3>Author(s)</h3>

<p>Javier Garcia-Pintado, e-mail: <a href="mailto:jgarciapintado@marum.de">jgarciapintado@marum.de</a></p>


<h3>Examples</h3>

<pre><code class='language-R'>  if (1 &gt; 2) { # not run
    dem &lt;- readGDAL(file.path(system.file('external',package='hydrosim'),
                    'watershed1','IDRISI_maps','dem','dem.rst'))   # SpatialGridDataFrame
    plotGmeta(layer=dem, xlim=662500 + 2500 * c(-1,+1),
              ylim=4227500 + 2500 * c(-1,1), zlim='strloc', as.na=0)

    # generate some crossing lines
    zz &lt;- list()
    zz[[1]] &lt;- digitGmeta(layer=dem, type='Lines', ID=1)
    zz[[2]] &lt;- digitGmeta(layer=dem, type='Lines', ID=2)
    zz[[3]] &lt;- digitGmeta(layer=dem, type='Lines', ID=3)
    SL &lt;- SpatialLines(zz)
    SG &lt;- sl2sg(SL, getpath=TRUE)
    points(SG@v, cex=2)                    # plot SpatialGraph vertices

    apath &lt;- SG@path[[1,2]]                # iteratively plot a path as an example
    for (iv in 1:length(apath$v)) {
      points(SG@v[apath$v[iv],], cex=2,pch=2)
      if (iv == length(apath$v))
        break
      lines(SG@e[apath$e[iv],],col='blue',lwd=2,lty=2)
      Sys.sleep(1)
    }

    # sample a few points [as a matrix] close to some edges
    xy    &lt;- digit()                    # sample locations
    xych  &lt;- pointsToLines(xy, SG@e)    # SpatialPointsDataFrame mapping
    points(xy, col='blue', pch=3)
    points(xych, col='darkgreen', pch=19)

    # along-network distance
    xyndis &lt;- distSG(SG, xych)

    # state-dependent weighted along-network distance
    SG@e@data$wxs &lt;- 3+round(runif(nrow(SG@e@data)),2)         # [m2] foo wetted cross-section areas
    SG@e@data

    xywdis &lt;- distSG(SG, xych, wei='wxs')
    xywdis &lt;- xywdis$dis * xywdis$wei       # Schur weight application into distance estimation
  }
</code></pre>

<hr>
<h2 id='distSGv'>Calculate the distance slot in a SpatialGraph</h2><span id='topic+distSGv'></span>

<h3>Description</h3>

<p>Calculate the distance slot in a <a href="#topic+SpatialGraph">SpatialGraph</a>. This
is done via a call to the library <code>igraph</code>, which does the
calculation. Distances are undirected.</p>


<h3>Usage</h3>

<pre><code class='language-R'> distSGv(SG, getpath = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="distSGv_+3A_sg">SG</code></td>
<td>
<p><a href="#topic+SpatialGraph">SpatialGraph</a></p>
</td></tr>
<tr><td><code id="distSGv_+3A_getpath">getpath</code></td>
<td>
<p>boolean. Whether to calculate the <code>SG@path</code> slot</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <a href="#topic+SpatialGraph">SpatialGraph</a> with the slot <code>dist</code> (and
<code>path</code> if requested) recalculated
</p>

<hr>
<h2 id='explodeSLDF'>Explode Lines in a SpatialLinesDataFrame</h2><span id='topic+explodeSLDF'></span>

<h3>Description</h3>

<p>explode Lines in a SpatialLinesDataFrame, so that each
single Line, within each Lines slot, is upgraded as a new 1-Line Lines slot
</p>


<h3>Usage</h3>

<pre><code class='language-R'>explodeSLDF(SLDF, FID)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="explodeSLDF_+3A_sldf">SLDF</code></td>
<td>
<p>a SpatialLinesDataFrame</p>
</td></tr>
<tr><td><code id="explodeSLDF_+3A_fid">FID</code></td>
<td>
<p>if not NULL, field name, within the attribute table considered as additional unique identifier, so that incremental numeric values will added to this field to avoid duplicate values</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a SpatialLinesDataFrame
</p>

<hr>
<h2 id='pointLineD'>Euclidean distance from a set of points to a line segment</h2><span id='topic+pointLineD'></span>

<h3>Description</h3>

<p><code>pointLineD</code> returns a list with a number of components from a points to line segment analysis</p>


<h3>Usage</h3>

<pre><code class='language-R'>pointLineD(xy, xyp)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pointLineD_+3A_xy">xy</code></td>
<td>
<p>2 x 2 [x,y] matrix defining the start and end of the segment</p>
</td></tr>
<tr><td><code id="pointLineD_+3A_xyp">xyp</code></td>
<td>
<p>p x 2 [x,y] matrix with a point set</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>pointLineD</code> conduct a detailed points to segment distance analysis, returned as a list
</p>


<h3>Value</h3>

<p>A list with the input components <code>xy</code> and <code>xyp</code>, and the aditional components: <code>d</code>, point-line distance (distance between the points in <code>xyp</code> and their perpendicular projections of the line); <code>dc</code>,  diferential chainage over [x0,y0] (&gt; 0 if the projection goes in the segment direction); <code>cross</code>, boolean vector indicating whether the perpendicular projection of the points crosses the segment, or not
</p>


<h3>See Also</h3>

<p><code><a href="sp.html#topic+Spatial-class">Spatial-class</a></code></p>

<hr>
<h2 id='pointOnLine'>Snap a points to a line</h2><span id='topic+pointOnLine'></span>

<h3>Description</h3>

<p>This function snaps a point to a line based on the
minimum distance between the point and the line</p>


<h3>Usage</h3>

<pre><code class='language-R'>pointOnLine(cool, coop)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pointOnLine_+3A_cool">cool</code></td>
<td>
<p>2-col matrix giving the coordinates of the line</p>
</td></tr>
<tr><td><code id="pointOnLine_+3A_coop">coop</code></td>
<td>
<p>2-length vector repsenting the point</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A 4-length vector, with 'x','y' [coordinates of the point snapped to
the line], 'd' [distance from the input point to the new snapped
point], and 'chain' [accumulated along-line distance from the starting
of the line to the snapped point]
</p>


<h3>Author(s)</h3>

<p>Javier Garcia-Pintado</p>


<h3>See Also</h3>

<p><code><a href="sp.html#topic+Spatial-class">Spatial-class</a></code></p>

<hr>
<h2 id='pointOnSegment'>Snap a points to a segment</h2><span id='topic+pointOnSegment'></span>

<h3>Description</h3>

<p>This function snaps a point to a segment based on the
minimum distance between the point and the segment</p>


<h3>Usage</h3>

<pre><code class='language-R'>pointOnSegment(s, p)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pointOnSegment_+3A_s">s</code></td>
<td>
<p>[2,2] matrix giving the coordinates of the line, one point
per row</p>
</td></tr>
<tr><td><code id="pointOnSegment_+3A_p">p</code></td>
<td>
<p>2-length vector repsenting the point</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A 4-length vector, with 'x','y' [coordinates of the point snapped to
the segment], 'd' [distance from the input point to the new snapped
point], and 'chain' [distance from the starting
of the segment to the snapped point]
</p>


<h3>Author(s)</h3>

<p>Javier Garcia-Pintado</p>


<h3>See Also</h3>

<p><code><a href="sp.html#topic+Spatial-class">Spatial-class</a></code></p>

<hr>
<h2 id='pointsPolylineD'>closest points in a polyline to a set of points</h2><span id='topic+pointsPolylineD'></span>

<h3>Description</h3>

<p><code>pointsPolylineD</code> returns a list with a number of components from a points to polyline analysis</p>


<h3>Usage</h3>

<pre><code class='language-R'>pointsPolylineD(xy, xyp)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pointsPolylineD_+3A_xy">xy</code></td>
<td>
<p>n x 2 [x,y] matrix defining the polyline</p>
</td></tr>
<tr><td><code id="pointsPolylineD_+3A_xyp">xyp</code></td>
<td>
<p>p x 2 [x,y] matrix with a point set</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>pointsPolylineD</code> conducts a detailed points to polyline distance analysis. First the distance from the set of points to the lines defined by every single segment in the polyline is obtained by succesive calls to <code>pointLineD</code>, then the distance to every single node in the polyline are also obtained. The lower distance is chosen.
</p>


<h3>Value</h3>

<p>A <code>data.frame</code> with the columns: <code>inode</code> is the index of the first node in the closest segment to each point, <code>x0</code> and <code>y0</code> are the corresponding coordinates of those nodes, <code>xc</code> and <code>yc</code> are the coordinates of the point in the polyline closest to each point in <code>xyp</code>, these may be but are not necessarily one the polyline nodes, <code>dis</code> it the distance from each point tho the polyline, <code>chain0</code> is the chainage of <code>x0,y0</code> with the polyline, and <code>dc</code> is the differential chainage from <code>xc,yc</code> to <code>x0,y0</code>
</p>


<h3>See Also</h3>

<p><code><a href="sp.html#topic+Spatial-class">Spatial-class</a></code></p>

<hr>
<h2 id='pointsSLDFchain'>Obtain chainage from sparse points along a SpatialLinesDataFrame</h2><span id='topic+pointsSLDFchain'></span>

<h3>Description</h3>

<p>For a set of points, obtains the closest Line object in a
SpatialLinesDataFrame. The function assumes that each Feature (entry
in the DataFrame part of the SpatialLinesDataFrame) just contains one
<code>Line</code> (i.e. one polyline). The within-polyine chainage (that is,
distance from the initial point of the poyline to the mapping of the
point into the polyline) is also returned. If mask is NULL, each point
in the set is assigned a line in SLDF by Euclidean distance. If mask
is provided, the match between <code>mask</code> and the <code>SLmsk</code>
field in <code>SLDF</code> is used instead for polyline assignation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'> pointsSLDFchain(SLDF, xy, SLmsk='FEAT_ID', mask=NULL,  type='SpatialPointsDataFrame')
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pointsSLDFchain_+3A_sldf">SLDF</code></td>
<td>
<p><code>SpatialLinesDataFrame</code></p>
</td></tr>
<tr><td><code id="pointsSLDFchain_+3A_xy">xy</code></td>
<td>
<p>REAL [n,2] matrix of points, or a <code>SpatialPointsDataFrame</code></p>
</td></tr>
<tr><td><code id="pointsSLDFchain_+3A_slmsk">SLmsk</code></td>
<td>
<p>is !is.null(mask) this is the field in the SLDF data.frame matching the values in mask</p>
</td></tr>
<tr><td><code id="pointsSLDFchain_+3A_mask">mask</code></td>
<td>
<p>REAL, OPT, [n] a vector indicating to which line in SLDF is
related each point</p>
</td></tr>
<tr><td><code id="pointsSLDFchain_+3A_type">type</code></td>
<td>
<p>character. Either 'SpatialPointsDataFrame' or
'mapping'. In the latter case, just the chainage in line feature
identifiers are returned</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data.frame with two columns, 'chai', and 'eIDs', where 'eIDs' are
the row names of the data.frame component of the input SpatialLinesDataFrame
</p>


<h3>Author(s)</h3>

<p>Javier Garcia-Pintado, e-mail: <a href="mailto:jgarciapintado@marum.de">jgarciapintado@marum.de</a></p>

<hr>
<h2 id='pointsToLines'>Snap a set of points to a set of lines</h2><span id='topic+pointsToLines'></span>

<h3>Description</h3>

<p>This function snaps a set of points to a set of lines based on the
minimum distance of each point to any of the lines</p>


<h3>Usage</h3>

<pre><code class='language-R'>pointsToLines(points, lines, withAttrs = TRUE, withDis = TRUE, withChain = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pointsToLines_+3A_points">points</code></td>
<td>
<p>An object of the class SpatialPoints or
SpatialPointsDataFrame, or a 2-col matrix of [x,y] coordinates</p>
</td></tr>
<tr><td><code id="pointsToLines_+3A_lines">lines</code></td>
<td>
<p>An object of the class SpatialLines or
SpatialLinesDataFrame</p>
</td></tr>
<tr><td><code id="pointsToLines_+3A_withattrs">withAttrs</code></td>
<td>
<p>Boolean value for preserving (TRUE) or getting rid
(FALSE) of the original point attributes. Default: TRUE. This
parameter is optional</p>
</td></tr>
<tr><td><code id="pointsToLines_+3A_withdis">withDis</code></td>
<td>
<p>Boolean value for including distance from source points
to snapped-to-lines points</p>
</td></tr>
<tr><td><code id="pointsToLines_+3A_withchain">withChain</code></td>
<td>
<p>Boolean value for including the chainage of the
snapped points in their corresponding lines</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A SpatialPointsDataFrame object as defined by the R package 'sp'. This
object contains the snapped points, therefore all of them lie on the
lines. The returned object contains the fields 'lid', 'eID', and
'chain', providing information about the relationship between the
source data points, the snapped data points, and its location within
the network: 'lid', and 'eID' are the line index and line ID,
respectively, of the lines in which the new snapped points lie; 'dis'
is the distance between the input points and the snapped points, and 'chain'
is the chainage of the snapped point within the corresponding line
</p>


<h3>Author(s)</h3>

<p>Javier Garcia-Pintado</p>


<h3>See Also</h3>

<p><code><a href="sp.html#topic+Spatial-class">Spatial-class</a></code></p>

<hr>
<h2 id='polylineChainage'>Obtain the chainage of nodes along a polyline</h2><span id='topic+polylineChainage'></span>

<h3>Description</h3>

<p>Obtain the chainage of nodes along a polyline [2-col matrix]
</p>


<h3>Usage</h3>

<pre><code class='language-R'>polylineChainage(xy)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="polylineChainage_+3A_xy">xy</code></td>
<td>
<p>a 2-column matrix representing the polyline nodes</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>polylineChainage</code> calculates a vector of chainage values
[along-polyline distances] from each node in a polyline to the initial node 
</p>


<h3>Value</h3>

<p>A vector
</p>


<h3>See Also</h3>

<p><code><a href="#topic+polylineLength">polylineLength</a></code></p>

<hr>
<h2 id='polylineLength'>Obtain the length of a polyline</h2><span id='topic+polylineLength'></span>

<h3>Description</h3>

<p>Obtain the length a polyline [2-col matrix]
</p>


<h3>Usage</h3>

<pre><code class='language-R'>polylineLength(xy)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="polylineLength_+3A_xy">xy</code></td>
<td>
<p>a 2-column matrix representing the polyline nodes</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>polylineLength</code> calculates the
[along-polyline] length of the polyline
</p>


<h3>Value</h3>

<p>A scalar
</p>


<h3>See Also</h3>

<p><code><a href="#topic+polylineChainage">polylineChainage</a></code></p>

<hr>
<h2 id='revSGe'>Reverse Lines in a SpatialGraph</h2><span id='topic+revSGe'></span>

<h3>Description</h3>

<p>A <a href="#topic+SpatialGraph">SpatialGraph</a> contains a <code>SpatialLinesDataFrame</code>,
describing the network topology. The input <code>eID</code> indicates the
identifiers of a set of lines (edges) in the network to be reversed. Note
<code>eID</code> does not refer to the line index within <code>SG@e</code>, but to
the Feature Identifiers, as extracted from <code>row.names(SG@e@data)</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>revSGe(SG, eID)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="revSGe_+3A_sg">SG</code></td>
<td>
<p><code>SpatialGraph</code></p>
</td></tr>
<tr><td><code id="revSGe_+3A_eid">eID</code></td>
<td>
<p>vector of Feature Identifiers for lines to be reversed</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Note <code>eID</code> does not refer to the line index within <code>SG@e</code>, but to
the Feature Identifiers, as extracted from
<code>row.names(SG@e@data)</code>. Accordingly to the reversed coordiantes,
the corresponding fields [&quot;v0&quot;,&quot;v1&quot;], are interchanged.
</p>


<h3>Value</h3>

<p>A <a href="#topic+SpatialGraph">SpatialGraph</a>
</p>

<hr>
<h2 id='rotation'>Rotate 2D points</h2><span id='topic+rotation'></span>

<h3>Description</h3>

<p>rotate points, counterclockwise for positive angles, and clockwise for negative ones
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rotation(coords, radian)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rotation_+3A_coords">coords</code></td>
<td>
<p>2-col matrix of [x,y] coordinates</p>
</td></tr>
<tr><td><code id="rotation_+3A_radian">radian</code></td>
<td>
<p>rotation angle</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a 2-col matrix with the points rotated around [0,0]
</p>

<hr>
<h2 id='routeSDG'>Accumulate sources/sinks along a directed SpatialGraph</h2><span id='topic+routeSDG'></span>

<h3>Description</h3>

<p>Assume a SpatialGraph is directed and conduct an accumulation of
source/sink values at nodes across the network. The accumulation
assumes no delay in transmission 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>routeSDG(SDG, FUN='cumsum', ifld='inflow')
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="routeSDG_+3A_sdg">SDG</code></td>
<td>
<p><code>SpatialGraph</code>, assumed as directed</p>
</td></tr>
<tr><td><code id="routeSDG_+3A_fun">FUN</code></td>
<td>
<p>name of a function to be applied for the routing</p>
</td></tr>
<tr><td><code id="routeSDG_+3A_ifld">ifld</code></td>
<td>
<p>name on the field in the <code>SpatialPointDataFrame</code> vertex slot to be used used as source/sink</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>SpatialGraph</code>, used as input, must have the <code>ifld</code> field
to be used as input, in the vertices slot <code>v</code> (a SpatialPointsDataFrame). The accumulated output is provided
as the new field <code>ofld</code> in <code>v</code>. The edges slot <code>e</code>
serves to route the input across the network
</p>


<h3>Value</h3>

<p>A <code>SpatialGraph</code> with the added <code>ofld</code> field in the vertex slot
</p>

<hr>
<h2 id='sg2igraph'>Map a SpatialGraph into an igraph</h2><span id='topic+sg2igraph'></span>

<h3>Description</h3>

<p>The vertex and edge information in  a <code>SpatialGraph</code> is
mapped into an <code>igraph</code> object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sg2igraph(sg, directed=FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sg2igraph_+3A_sg">sg</code></td>
<td>
<p><code>SpatialGraph</code></p>
</td></tr>
<tr><td><code id="sg2igraph_+3A_directed">directed</code></td>
<td>
<p>whether the resulting <code>igraph</code> is directed</p>
</td></tr>
</table>


<h3>Details</h3>

<p>It is assumed that the <code>SpatialGraph</code>, used as input, is correct
(i.e.g all records in <code>sg@e@data</code> have the two first field correctly
identifying the field 'ID' in <code>sg@v</code>. It is also assumed that the
<code>sg@e@data</code> data.frame has the fields <code>div</code> and
<code>len</code>. These two are highly useful to conduct network operations
on the resulting <code>igraph</code>
</p>


<h3>Value</h3>

<p>An <code>igraph</code>
</p>

<hr>
<h2 id='sgChVIDs'>Change vertex IDs in a SpatialGraph</h2><span id='topic+sgChVIDs'></span>

<h3>Description</h3>

<p>Change the field &quot;ID&quot; in the vertex slot, <code>v</code>, of a
<a href="#topic+SpatialGraph">SpatialGraph</a>. The fields <code>v0</code> and <code>v1</code> of the edge
slot, <code>e</code>, are accordingly updated
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  sgChVIDs(obj, IDa, IDp = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sgChVIDs_+3A_obj">obj</code></td>
<td>
<p>A <a href="#topic+SpatialGraph">SpatialGraph</a> object</p>
</td></tr>
<tr><td><code id="sgChVIDs_+3A_ida">IDa</code></td>
<td>
<p>A vector indicating the updated vertex IDs</p>
</td></tr>
<tr><td><code id="sgChVIDs_+3A_idp">IDp</code></td>
<td>
<p>A vector indicating the prior vertex IDs</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If <code>IDp</code> is not provided, it is assumed that the vector of
updated indexes is sorted equally to the order in which the vertices
are stored in the slot <code>v</code> of the <a href="#topic+SpatialGraph">SpatialGraph</a>. If
<code>IDp</code> is provided, the mapping IDp -&gt; IDa is used
for reclassifying the vertices.
</p>


<h3>Value</h3>

<p>A <a href="#topic+SpatialGraph">SpatialGraph</a> object
</p>

<hr>
<h2 id='sl2sg'>Map a SpatialLinesDataFrame into a SpatialGraph</h2><span id='topic+sl2sg'></span>

<h3>Description</h3>

<p>This function is the major workhorse to map an input
<code>SpatialLinesDataFrame</code>, as defined in the package sp, into a
<code>SpatialGraph</code> by using the spatial connectivity. Input is first
exploded by using <code><a href="#topic+explodeSLDF">explodeSLDF</a></code>, and then all vertices in the
<code>SpatialGraph</code> are automatically generated according to crossings
in the input polylines.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sl2sg(SL, clipd = NULL, getdist = TRUE, getpath = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sl2sg_+3A_sl">SL</code></td>
<td>
<p><code>SpatialLinesDataFrame</code> as defined in package sp</p>
</td></tr>
<tr><td><code id="sl2sg_+3A_clipd">clipd</code></td>
<td>
<p>distance threshold for clipping features, If NULL, a
value of 1.0E-04 of the domain side size is used</p>
</td></tr>
<tr><td><code id="sl2sg_+3A_getdist">getdist</code></td>
<td>
<p>calculate the <code>dist</code> slot in the returned
<code>SpatialGraph</code></p>
</td></tr>
<tr><td><code id="sl2sg_+3A_getpath">getpath</code></td>
<td>
<p>calculate the <code>path</code> slot in the returned
<code>SpatialGraph</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>A <code>SpatialGraph</code> is generated
</p>


<h3>Value</h3>

<p>A <code>SpatialGraph</code>
</p>


<h3>Author(s)</h3>

<p>Javier Garcia-Pintado, e-mail:
<a href="mailto:j.garcia-pintado@marum.de">j.garcia-pintado@marum.de</a></p>


<h3>Examples</h3>

<pre><code class='language-R'>  #  x   y
  # create list of Line objects
 if (1 &gt; 2) {
  library(sp)
  library(SpatialGraph)
  zz &lt;- list()
  zz[[1]] &lt;- Line(matrix(
   c(661750, 4229150,
     662650, 4229450,
     663550, 4227650,
     663550, 4226850), ncol=2, byrow=TRUE))
  zz[[2]] &lt;- Line(matrix(
   c(660250, 4229650,
     661050, 4226450,
     662550, 4225350,
     664850, 4225850,
     664650, 4229150,
     662350, 4228850), ncol=2, byrow=TRUE))
  # upgrade Line as Lines
  for (i in 1:length(zz)) {
    zz[[i]] &lt;- Lines(list(zz[[i]]), ID=i)
  }
  # as SpatialLines
  SL &lt;- sp::SpatialLines(zz)
  # as SpatialGraph including path calculation
  SG &lt;- sl2sg(SL, getpath=TRUE) 

  plot(SL, axes=TRUE)  
  points(SG@v, cex=2)
  lines(SG@e, lwd=2)
  points(SG@v, cex=2, col='grey', pch=19)
  text(SG@v, labels=SG@v$ID)
  # label edges and directions
  textSGe(SG)
  # show a distance matrix between nodes
  SG@dist
  # show path from node 1 to 3
  SG@path[1,3]
 }
</code></pre>

<hr>
<h2 id='SpatialGraph'>Create a SpatialGraph object</h2><span id='topic+SpatialGraph'></span>

<h3>Description</h3>

<p>A <code>SpatialGraph</code> object is created
</p>


<h3>Usage</h3>

<pre><code class='language-R'>SpatialGraph(v, e, dist = NULL, path = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="SpatialGraph_+3A_v">v</code></td>
<td>
<p><code>SpatialPointsDataFrame</code></p>
</td></tr>
<tr><td><code id="SpatialGraph_+3A_e">e</code></td>
<td>
<p><code>SpatialLinesDataFrame</code></p>
</td></tr>
<tr><td><code id="SpatialGraph_+3A_dist">dist</code></td>
<td>
<p>along-network (symmetric) distance matrix</p>
</td></tr>
<tr><td><code id="SpatialGraph_+3A_path">path</code></td>
<td>
<p>matrix of lists with paths corresponding to
<code>dist</code>. While distances between
vertex couples are symmetric, the path matrix is not symmetric as
individual path to from source vertex to destination vertex. Each list in the matrix has two S3
components (v,e) describing vertices (including bounds) and edges
along the path. Thus it is always one less edge than then number of
vertices in the path</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>SpatialGraph</code> returns an object of class <a href="#topic+SpatialGraph-class">SpatialGraph-class</a>
</p>

<hr>
<h2 id='SpatialGraph-class'>Class &quot;SpatialGraph&quot;</h2><span id='topic+SpatialGraph-class'></span>

<h3>Description</h3>

<p>Class for spatial networks
</p>


<h3>Objects from the Class</h3>

<p>Objects can be created by calls to the function <a href="#topic+SpatialGraph">SpatialGraph</a>
</p>


<h3>Slots</h3>


<dl>
<dt><code>v</code>:</dt><dd><p>Object of class <code>"SpatialPointsDataFrame"</code>,
whose data.frame must contain the &quot;ID&quot; field as unique identifier</p>
</dd>
<dt><code>e</code>:</dt><dd><p>Object of class <code>"SpatialLinesDataFrame"</code>,
whose data.frame must contain the fields <code>v0</code> and <code>v1</code>
matching the unique identifiers &quot;ID&quot; in the slot <code>v</code> data.frame</p>
</dd>
<dt><code>dist</code>:</dt><dd><p>Matrix, representing the undirected along-graph distance
between all vertices in the network</p>
</dd>
<dt><code>path</code>:</dt><dd><p>list with variable length arrays describing the
minimum distance path between vertices</p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>Javier Garcia-Pintado, e-mail:
<a href="mailto:j.garcia-pintado@reading.ac.uk">j.garcia-pintado@reading.ac.uk</a></p>

<hr>
<h2 id='splitPolyline'>Split a polyline into a number of transects</h2><span id='topic+splitPolyline'></span>

<h3>Description</h3>

<p><code>splitPolyline</code> returns a list with a number of transects along a
polyline</p>


<h3>Usage</h3>

<pre><code class='language-R'>splitPolyline(xy, xyp, dmax)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="splitPolyline_+3A_xy">xy</code></td>
<td>
<p>2-column [x,y] matrix defining the polyline nodes</p>
</td></tr>
<tr><td><code id="splitPolyline_+3A_xyp">xyp</code></td>
<td>
<p>2-column [x,y] matrix with a point set</p>
</td></tr>
<tr><td><code id="splitPolyline_+3A_dmax">dmax</code></td>
<td>
<p>maximum distance between points in <code>xy</code> and the
polyline, for these to be considered for poyline splitting</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>splitPolyline</code> obtain the closest points in a polyline to a
given input set of points. Those closest points are used to divide the
polyline in a number of transects. The indivudual transects are
clipped to the input point dataset, so the different transects are
continuous in space. Note that if the input points is quite appart
from the polyline, the output seqence of transect may substantially
differ form the input polyline at rupture zones
</p>


<h3>Value</h3>

<p>A list in which each element is a matrix representing an individual polyline
</p>


<h3>See Also</h3>

<p><code><a href="sp.html#topic+Spatial-class">Spatial-class</a></code></p>

<hr>
<h2 id='splitSLDF'>Split 1-Line Lines in a SpatialLines or a SpatialLinesDataFrame by intersection
with a point dataset</h2><span id='topic+splitSLDF'></span>

<h3>Description</h3>

<p><code>splitSLDF</code> divides the 1-Line Lines in the <code>SpatialLines</code> or the
<code>SpatialLinesDataFrame</code> at intersections with the input point dataset
</p>


<h3>Usage</h3>

<pre><code class='language-R'>splitSLDF(SLDF, SPDF, dmax=NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="splitSLDF_+3A_sldf">SLDF</code></td>
<td>
<p>length-1 SpatialLinesDataFrame or SpatialLines object</p>
</td></tr>
<tr><td><code id="splitSLDF_+3A_spdf">SPDF</code></td>
<td>
<p>SpatialPointsDataFrame</p>
</td></tr>
<tr><td><code id="splitSLDF_+3A_dmax">dmax</code></td>
<td>
<p>maximum distance between points in <code>SPDF</code> and the
polylines in <code>SLDF</code>, for these to be considered for poyline splitting</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>splitPolyline</code> obtain the closest points in the SpatialLinesDataFrame to a
given input set of points. Those closest points are used to divide the
polylines in a number of transects. The individual transects are
clipped to the input point dataset, so the different transects are
continuous in space. Note that if the input points is quite appart
from the polyline, the output sequence of transects may substantially
differ form the input polyline at rupture zones. The input parameter
<code>dmax</code> is provided as a mean to avoid too strange splitting
results. Setting dmax to a ver low value will reduce the spureous
results, but also the input points need to be closer to the lines for
the adequate recognition of splitting points
</p>


<h3>Value</h3>

<p>A SpatialLinesDataFrame or a SpatialLines, according to the input
</p>


<h3>See Also</h3>

<p><code><a href="sp.html#topic+Spatial-class">Spatial-class</a></code></p>

<hr>
<h2 id='textSGe'>Label edges in a SpatialGraph plot</h2><span id='topic+textSGe'></span>

<h3>Description</h3>

<p>A <a href="#topic+SpatialGraph">SpatialGraph</a> contains a <code>SpatialLinesDataFrame</code>,
describing the network topology. This function adds line <code>IDs</code>
and direction arrows to an existing plot of a <a href="#topic+SpatialGraph">SpatialGraph</a>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>textSGe(SG, acol='wheat', tcol='navyblue', arr.length=0.4)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="textSGe_+3A_sg">SG</code></td>
<td>
<p><code>SpatialGraph</code></p>
</td></tr>
<tr><td><code id="textSGe_+3A_acol">acol</code></td>
<td>
<p>color of the graph direction arrows</p>
</td></tr>  
<tr><td><code id="textSGe_+3A_tcol">tcol</code></td>
<td>
<p>color of the text for graph edge IDs</p>
</td></tr>
<tr><td><code id="textSGe_+3A_arr.length">arr.length</code></td>
<td>
<p>length of the direction arrows</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Arrows and edge <code>IDs</code> added to a <a href="#topic+SpatialGraph">SpatialGraph</a> plot
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
