<!DOCTYPE html><html><head><title>Help for package WorldFlora</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {WorldFlora}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#new.backbone'><p>Develop a User-created Taxonomic Backbone data set</p></a></li>
<li><a href='#vascular.families'><p>Orders and Higher Level Classifications of Vascular Plants</p></a></li>
<li><a href='#WFO.acceptable.match'><p>Check for fuzzy matches that can be acceptable based on gender notations</p></a></li>
<li><a href='#WFO.example'><p>World Flora Online (WFO) taxonomic backbone example data set</p></a></li>
<li><a href='#WFO.match'><p>Standardize plant names according to World Flora Online taxonomic backbone</p></a></li>
<li><a href='#WFO.match.fuzzyjoin'><p>Standardize plant names according to World Flora Online taxonomic backbone</p></a></li>
<li><a href='#WFO.prepare'><p>Prepare a data set for analysis with WFO.match</p></a></li>
<li><a href='#WFO.remember'><p>Remember the location of the Taxonomic Backbone data set</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Standardize Plant Names According to World Flora Online
Taxonomic Backbone</td>
</tr>
<tr>
<td>Version:</td>
<td>1.14-3</td>
</tr>
<tr>
<td>Date:</td>
<td>2024-5-17</td>
</tr>
<tr>
<td>Author:</td>
<td>Roeland Kindt <a href="https://orcid.org/0000-0002-7672-0712"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [cre, aut]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Roeland Kindt &lt;RoelandCEKindt@gmail.com&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>World Flora Online is an online flora of all known plants, available from <a href="https://www.worldfloraonline.org/">https://www.worldfloraonline.org/</a>. Methods are provided of matching a list of plant names (scientific names, taxonomic names, botanical names) against a static copy of the World Flora Online Taxonomic Backbone data that can be downloaded from the World Flora Online website. The World Flora Online Taxonomic Backbone is an updated version of The Plant List (<a href="http://www.theplantlist.org/">http://www.theplantlist.org/</a>), a working list of plant names that has become static since 2013.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.5.0)</td>
</tr>
<tr>
<td>Suggests:</td>
<td>data.table, utils, stringr, dplyr, fuzzyjoin, stringdist</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-05-17 06:04:24 UTC; RKINDT</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-05-18 13:40:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='new.backbone'>Develop a User-created Taxonomic Backbone data set</h2><span id='topic+new.backbone'></span>

<h3>Description</h3>

<p>Instead of using the taxonomic backbone data set from World Flora Online, it is possible to use matching functions of WorldFlora with alternative taxonomic backbone. The function creates new variables that correspond to key variables in the World Flora Online backbone so that matching functions WFO.match and WFO.one can be applied.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>
new.backbone(x,
    taxonID = "taxonID", scientificName = "scientificName",
    scientificNameAuthorship = "scientificNameAuthorship",
    acceptedNameUsageID = NULL, taxonomicStatus = NULL
)

</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="new.backbone_+3A_x">x</code></td>
<td>
<p> data.frame with the variables. </p>
</td></tr>
<tr><td><code id="new.backbone_+3A_taxonid">taxonID</code></td>
<td>
<p> name of the variable with the identification </p>
</td></tr>
<tr><td><code id="new.backbone_+3A_scientificname">scientificName</code></td>
<td>
<p> name of the variable with the full taxon name </p>
</td></tr>
<tr><td><code id="new.backbone_+3A_scientificnameauthorship">scientificNameAuthorship</code></td>
<td>
<p> name of the variable with the naming authors </p>
</td></tr>
<tr><td><code id="new.backbone_+3A_acceptednameusageid">acceptedNameUsageID</code></td>
<td>
<p> ID of the record with the current (accepted) name. Should respond to an ID in the 'taxonID' column. In case the taxonomic name is current, then this field should be left blank. This field is used by function WFO.match to find the accepted name of a species.</p>
</td></tr>
<tr><td><code id="new.backbone_+3A_taxonomicstatus">taxonomicStatus</code></td>
<td>
<p> Variable that indicates whether the record is for a current name or a synonym. This variable is used by function WFO.one to discriminate situations where best matches include matches with current names and synonyms. </p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function allows a user to create a new taxonomic backbone data set that is understood by WFO.match and WFO.one.
</p>
<p>Alternative examples with the Mammal Diversity Database (<a href="https://www.mammaldiversity.org/">https://www.mammaldiversity.org/</a>) and the World Checlist of Vascular Plants (<a href="https://powo.science.kew.org/about-wcvp">https://powo.science.kew.org/about-wcvp</a>) are provided in the Kindt 2021a,b RPubs.
</p>


<h3>Value</h3>

<p>The function returns a data.table that can be understood by WFO.match and WFO.one for standardizing taxonomic names.
</p>


<h3>Author(s)</h3>

<p>Roeland Kindt (World Agroforestry)</p>


<h3>References</h3>

<p>Kindt, R. 2021a. Standardizing mammal species names with the Mammal Species Database
via exact and fuzzy matching functions from the WorldFlora package.
<a href="https://rpubs.com/Roeland-KINDT">https://rpubs.com/Roeland-KINDT</a>
</p>
<p>Kindt, R. 2021b. Standardizing GlobalTreeSearch tree species names with
World Flora Online and the World Checklist of Vascular Plants
<a href="https://rpubs.com/Roeland-KINDT">https://rpubs.com/Roeland-KINDT</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+WFO.match">WFO.match</a></code>, <code><a href="#topic+WFO.one">WFO.one</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Not run: 

# load the World Flora Online taxonomic backbone
WFO.remember()

# get a list of Sapotaceae species
Sapotaceae &lt;- WFO.data[WFO.data$family == "Sapotaceae",]
Sapotaceae &lt;- Sapotaceae[Sapotaceae$taxonRank == "SPECIES", ]
Sapotaceae &lt;- Sapotaceae[Sapotaceae$taxonomicStatus == "Accepted", ]
Sapotaceae &lt;- Sapotaceae[, c("scientificName", "scientificNameAuthorship")]
Sapotaceae &lt;- data.frame(ID = c(1:nrow(Sapotaceae)), Sapotaceae)
names(Sapotaceae)[2:3] &lt;- c("species.name", "author")
head(Sapotaceae)

# create a new backbone from the GlobalTreeSearch database,
# after copying locally from https://tools.bgci.org/global_tree_search.php
GTS.dir &lt;- "E://Roeland//R///World Flora Online//2021"
GTS &lt;- read.csv(paste0(GTS.dir, "//global_tree_search.csv"))
GTS &lt;- GTS[, 1:2]
GTS &lt;- data.frame(GTS.ID = paste0("GTS-", c(1:nrow(GTS))), GTS)
nrow(GTS)

# create the new backbone
GTS.data &lt;- new.backbone(GTS,
                         taxonID="GTS.ID",
                         scientificName="TaxonName",
                         scientificNameAuthorship="Author")
head(GTS.data)

# Check and standardize Sapotaceae
Sapotaceae.match &lt;- WFO.one(WFO.match(Sapotaceae,
                                      WFO.data = GTS.data,
                                      spec.name = "species.name",
                                      Authorship = "author"))

nrow(Sapotaceae.match[Sapotaceae.match$Fuzzy == FALSE, ] )
nrow(Sapotaceae.match[Sapotaceae.match$Fuzzy == TRUE &amp;
        Sapotaceae.match$Fuzzy.dist &lt; 4, ] )
Sapotaceae.match[Sapotaceae.match$Fuzzy == TRUE &amp;
        Sapotaceae.match$Fuzzy.dist &lt; 4,
        c("ID", "species.name", "Fuzzy.dist", "scientificName")]


## End(Not run)

</code></pre>

<hr>
<h2 id='vascular.families'>Orders and Higher Level Classifications of Vascular Plants</h2><span id='topic+vascular.families'></span>

<h3>Description</h3>

<p>This data set lists orders for families of vascular plants (angiosperms, gymnosperms and pteridophytes). For angiosperms, information from orders and higher levels of classification correspond to the fourth update of the Angiosperm Phylogeny Group (APG IV, <a href="https://doi.org/10.1111/boj.12385">doi:10.1111/boj.12385</a>). Higher levels of classification correspond to names of nodes of the consensus tree (Figure 1 in <a href="https://doi.org/10.1111/boj.12385">doi:10.1111/boj.12385</a>). Orders for gymnosperms and pteridophytes were obtained from the website of Missouri Botanical Garden.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(vascular.families)</code></pre>


<h3>Format</h3>

<p>A data frame with 476 observations on the following 10 variables.
</p>

<dl>
<dt><code>Group</code></dt><dd><p>Group.</p>
</dd>
<dt><code>Family.ID</code></dt><dd><p>Unique ID for each family. For angiosperms, these correspond to APG IV.</p>
</dd>
<dt><code>Family</code></dt><dd><p>Name of the plant family.</p>
</dd>
<dt><code>Family.taxonID</code></dt><dd><p>taxonID retrieved from World Flora Online.</p>
</dd>
<dt><code>Order</code></dt><dd><p>Name of the plant order.</p>
</dd>
<dt><code>Order.taxonID</code></dt><dd><p>taxonID retrieved from World Flora Online.</p>
</dd>
<dt><code>Node.1</code></dt><dd><p>Name of the node in the consensus tree.</p>
</dd>
<dt><code>Node.2</code></dt><dd><p>Name of the node in the consensus tree, with Node.2 nested within Node.1.</p>
</dd>
<dt><code>Node.3</code></dt><dd><p>Name of the node in the consensus tree, with Node.3 nested within Node.2.</p>
</dd>
<dt><code>Node.4</code></dt><dd><p>Name of the node in the consensus tree, with Node.4 nested within Node.3.</p>
</dd>
</dl>



<h3>References</h3>

<p>The Angiosperm Phylogeny Group, M. W. Chase, M. J. M. Christenhusz, M. F. Fay, J. W. Byng, W. S. Judd, D. E. Soltis, D. J. Mabberley, A. N. Sennikov, P. S. Soltis, P. F. Stevens, An update of the Angiosperm Phylogeny Group classification for the orders and families of flowering plants: APG IV, Botanical Journal of the Linnean Society 181: 1-20. <a href="https://doi.org/10.1111/boj.12385">doi:10.1111/boj.12385</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(vascular.families)
</code></pre>

<hr>
<h2 id='WFO.acceptable.match'>Check for fuzzy matches that can be acceptable based on gender notations</h2><span id='topic+WFO.acceptable.match'></span>

<h3>Description</h3>

<p>The function checks whether submitted and match names only differ by ending by -um, -us or -a. An extra check is done to accept differences that result from having 'ii' instead of 'i' in the submitted and matched name. An optional check ignores differences in vowels.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>
    WFO.acceptable.match(x, spec.name="spec.name",
      no.vowels=FALSE)

</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="WFO.acceptable.match_+3A_x">x</code></td>
<td>
<p> Output for <code>WFO.match</code>, <code>WFO.match.fuzzyjoin</code> or <code>WFO.match.one</code>. </p>
</td></tr>
<tr><td><code id="WFO.acceptable.match_+3A_spec.name">spec.name</code></td>
<td>
<p> Name of taxon submitted for matching.</p>
</td></tr>
<tr><td><code id="WFO.acceptable.match_+3A_no.vowels">no.vowels</code></td>
<td>
<p> Accept results if only vowels differ between submitted and matched name. </p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function was initially developed to check for changes in gender notations.
</p>
<p>In new versions, also the following differences in species names are judged to be acceptable:
</p>
<p>- hybrid and non-hybrid names (eg, Sorbus avonensis - Sorbus xavonensis)
</p>
<p>- i vs. j (eg, Syzygium naiadum - Syzygium najadum)
</p>
<p>- tt vs. t (eg, Ficus scott-elliottii - Ficus scott-elliotii)
</p>
<p>- ll vs. l (eg, Garcinia moseleyana - Garcinia moselleyana)
</p>
<p>- rr vs. r (eg, Hymenodictyon perrieri - Hymenodictyon perieri)
</p>
<p>- mm vs. m (eg, Monteverdia schummaniana - Monteverdia schumanniana)
</p>
<p>- nn vs. n (eg, Pyrus tamamschiannae - Pyrus tamamschianae)
</p>
<p>- ff vs. f (eg, Dendropanax langsdorfii - Dendropanax langsdorffii)
</p>
<p>- hh vs. h (eg, Gmelina leichardtii - Gmelina leichhardtii)
</p>
<p>- dd vs. d (eg, Miconia buddlejoides - Miconia budlejoides)
</p>
<p>- is vs. e (eg, Decarydendron ranomafanensis - Decarydendron ranomafanense)
</p>
<p>- dt vs. d (eg, Stadtmannia acuminata - Stadmania acuminata)
</p>


<h3>Value</h3>

<p>The function returns a logical vector that indicates whether names could be acceptable.
</p>


<h3>Author(s)</h3>

<p>Roeland Kindt (World Agroforestry)</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Not run: 

data(WFO.example)

spec.test &lt;- data.frame(spec.name=c("Faidherbia albida", "Acacia albida",
  "Faidherbia albidum", "Faidherbia albidus",
  "Faidherbia albiida",
  "Prunus africanus", "Prunos africanea",
  "Prunus afrocaneus", "Prunus afrocaneos"))

match1 &lt;- WFO.match.fuzzyjoin(spec.data=spec.test, WFO.data=WFO.example,
  fuzzydist.max = 6)
match1[, c("spec.name", "scientificName")]

# check for gender differences (and ii - i)
WFO.acceptable.match(match1)

# ignore differences in vowels
WFO.acceptable.match(match1, no.vowels=TRUE)

accepted.cases &lt;- WFO.acceptable.match(match1, no.vowels=TRUE)
match1.accepted &lt;- match1[accepted.cases == TRUE, ]
match1.notaccepted &lt;- match1[accepted.cases == FALSE, ]

## End(Not run)

</code></pre>

<hr>
<h2 id='WFO.example'>World Flora Online (WFO) taxonomic backbone example data set</h2><span id='topic+WFO.example'></span>

<h3>Description</h3>

<p>This data set is a subset of the World Flora Online taxonomic backbone that allows running the first set of examples. In practical applications, users should first download a static copy of the Taxonomic Backbone data from <a href="https://www.worldfloraonline.org">https://www.worldfloraonline.org</a> or <a href="https://zenodo.org/doi/10.5281/zenodo.7460141">https://zenodo.org/doi/10.5281/zenodo.7460141</a> (_DwC_backbone_R.zip).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(WFO.example)</code></pre>


<h3>Source</h3>

<p>World Flora Online. An Online Flora of All Known Plants.
<a href="https://www.worldfloraonline.org">https://www.worldfloraonline.org</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(WFO.example)
</code></pre>

<hr>
<h2 id='WFO.match'>Standardize plant names according to World Flora Online taxonomic backbone</h2><span id='topic+WFO.match'></span><span id='topic+WFO.url'></span><span id='topic+WFO.one'></span><span id='topic+WFO.browse'></span><span id='topic+WFO.synonyms'></span><span id='topic+WFO.family'></span>

<h3>Description</h3>

<p>This package checks a list of taxa (typically species) against the World Flora Online (WFO) taxonomic backbone. The user needs to first download a static copy of the Taxonomic Backbone data from <a href="https://www.worldfloraonline.org">https://www.worldfloraonline.org</a> or <a href="https://zenodo.org/doi/10.5281/zenodo.7460141">https://zenodo.org/doi/10.5281/zenodo.7460141</a>  (_DwC_backbone_R.zip).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>    WFO.match(spec.data = NULL, WFO.file = NULL, WFO.data = NULL,
        no.dates = TRUE,
        spec.name = "spec.name", Genus = "Genus", Species = "Species",
        Infraspecific.rank = "Infraspecific.rank", Infraspecific = "Infraspecific",
        Authorship = "Authorship", First.dist = FALSE,
        acceptedNameUsageID.match = TRUE,
        Fuzzy = 0.1, Fuzzy.force = FALSE, Fuzzy.max = 250, Fuzzy.min = TRUE,
        Fuzzy.shortest = FALSE, Fuzzy.within = FALSE,
        Fuzzy.two = TRUE, Fuzzy.one = TRUE,
        squish = TRUE,
        spec.name.tolower = FALSE, spec.name.nonumber = TRUE, spec.name.nobrackets = TRUE,
        exclude.infraspecific = FALSE,
        infraspecific.excluded = c("cultivar.", "f.", "sect.", "subf.", "subg.",
            "subsp.", "subvar.", "var", "var.", "[infraspec.]", "fo.", "forma",
            "nothosubsp.", "nothovar.", "sect."),
        spec.name.sub = TRUE,
        sub.pattern=c(" sp[.] A", " sp[.] B", " sp[.] C", " sp[.]", " spp[.]", " pl[.]",
            " indet[.]", " ind[.]", " gen[.]", " g[.]", " fam[.]", " nov[.]", " prox[.]",
            " cf[.]", " aff[.]", " s[.]s[.]", " s[.]l[.]",
            " p[.]p[.]", " p[.] p[.]", "[?]", " inc[.]", " stet[.]", "Ca[.]",
            "nom[.] cons[.]", "nom[.] dub[.]", " nom[.] err[.]", " nom[.] illeg[.]",
            " nom[.] inval[.]", " nom[.] nov[.]", " nom[.] nud[.]", " nom[.] obl[.]",
            " nom[.] prot[.]", " nom[.] rej[.]", " nom[.] supp[.]", " sensu auct[.]"),
        verbose = TRUE, counter = 1000)

    WFO.url(WFO.result = NULL, browse = FALSE, browse.rows = c(1:1), ...)

    WFO.one(WFO.result = NULL, priority = "Accepted",
        spec.name = NULL, Auth.dist = NULL, First.dist = NULL,
        verbose = TRUE, counter = 1000)

    WFO.browse(taxon, WFO.file = NULL, WFO.data = NULL,
        accepted.only = FALSE, acceptedNameUsageID.match = TRUE, ...)

    WFO.synonyms(taxon, WFO.file = NULL, WFO.data = NULL, ...)

    WFO.family(taxon, WFO.file = NULL, WFO.data = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="WFO.match_+3A_spec.data">spec.data</code></td>
<td>
<p> A data.frame containing variables with species names. In case that a character vector is provided, then this vector will be converted to a data.frame </p>
</td></tr>
<tr><td><code id="WFO.match_+3A_wfo.file">WFO.file</code></td>
<td>
<p> File name of the static copy of the Taxonomic Backbone. If not <code>NULL</code>, then data will be reloaded from this file.</p>
</td></tr>
<tr><td><code id="WFO.match_+3A_wfo.data">WFO.data</code></td>
<td>
<p> Data set with the static copy of the Taxonomic Backbone. Ignored if <code>WFO.file</code> is not <code>NULL</code>. </p>
</td></tr>
<tr><td><code id="WFO.match_+3A_no.dates">no.dates</code></td>
<td>
<p> Speeding up the loading of the WFO.data by not loading fields of 'created' and 'modified'. </p>
</td></tr>
<tr><td><code id="WFO.match_+3A_spec.name">spec.name</code></td>
<td>
<p> Name of the column with taxonomic names. In case that a <code>spec.name</code> is provided, then separate genus and species names will be ignored. For function <code>WFO.one</code>, giving the name for this columns results in copying a submitted but unmatched plant name into the <code>scientificName</code> of the results.</p>
</td></tr>
<tr><td><code id="WFO.match_+3A_genus">Genus</code></td>
<td>
<p> Name of the column with the genus names. </p>
</td></tr>
<tr><td><code id="WFO.match_+3A_species">Species</code></td>
<td>
<p> Name of the column with the species names. </p>
</td></tr>
<tr><td><code id="WFO.match_+3A_infraspecific.rank">Infraspecific.rank</code></td>
<td>
<p> Name of the column with the infraspecific rank (such as &quot;subsp.&quot;, &quot;var.&quot; or &quot;cultivar.&quot;). </p>
</td></tr>
<tr><td><code id="WFO.match_+3A_infraspecific">Infraspecific</code></td>
<td>
<p> Name of the column with the infraspecific names. </p>
</td></tr>
<tr><td><code id="WFO.match_+3A_authorship">Authorship</code></td>
<td>
<p> Name of the column with the naming authorities. </p>
</td></tr>
<tr><td><code id="WFO.match_+3A_first.dist">First.dist</code></td>
<td>
<p> If <code>TRUE</code>, then calculate the fuzzy distance between the first words of the submitted and matched names (these are typically the genus names) . </p>
</td></tr>
<tr><td><code id="WFO.match_+3A_acceptednameusageid.match">acceptedNameUsageID.match</code></td>
<td>
<p> If <code>TRUE</code>, obtain the accepted name and others details from the earlier acceptedNameUsageID. </p>
</td></tr>
<tr><td><code id="WFO.match_+3A_fuzzy">Fuzzy</code></td>
<td>
<p> If larger than 0, then attempt fuzzy matching in case an identifical taxonomic name is not found in the World Flora Online. This argument will be used as argument <code>max.distance</code> in the internally called <code><a href="base.html#topic+agrep">agrep</a></code>. Note that fuzzy matching is only possible for the <code>spec.name</code>.  </p>
</td></tr>
<tr><td><code id="WFO.match_+3A_fuzzy.force">Fuzzy.force</code></td>
<td>
<p> If <code>TRUE</code>, always use the fuzzy matching algorithm, even when the <code>spec.name</code> was matched exactly. </p>
</td></tr>
<tr><td><code id="WFO.match_+3A_fuzzy.max">Fuzzy.max</code></td>
<td>
<p> Maximum number of fuzzy matches. </p>
</td></tr>
<tr><td><code id="WFO.match_+3A_fuzzy.min">Fuzzy.min</code></td>
<td>
<p> If <code>TRUE</code>, limit the matching of names to those with the smallest Levenshtein distance, calculated via <a href="utils.html#topic+adist">adist</a>. </p>
</td></tr>
<tr><td><code id="WFO.match_+3A_fuzzy.shortest">Fuzzy.shortest</code></td>
<td>
<p> If <code>TRUE</code>, limit the matching of names to those with the most similar length of characters (this feature is expected to eliminate matches at infraspecific levels, see examples). </p>
</td></tr>
<tr><td><code id="WFO.match_+3A_fuzzy.within">Fuzzy.within</code></td>
<td>
<p> If <code>TRUE</code>, limit the matching of names to those that contain exactly the submitted plant name (this feature is expected to be useful when submitting plant names that only contain a subset of the first characters of the species name, in order to check for best matches manually afterwards). </p>
</td></tr>
<tr><td><code id="WFO.match_+3A_fuzzy.two">Fuzzy.two</code></td>
<td>
<p> If <code>TRUE</code>, in case that there were no fuzzy matches, limit the terms to be matched to the first two (these are expected to be genus and species names). </p>
</td></tr>
<tr><td><code id="WFO.match_+3A_fuzzy.one">Fuzzy.one</code></td>
<td>
<p> If <code>TRUE</code>, in case that there were no fuzzy matches, limit the terms to be matched to the first one (expected to be the genus name). </p>
</td></tr>
<tr><td><code id="WFO.match_+3A_squish">squish</code></td>
<td>
<p> If <code>TRUE</code>, remove repeated whitespace and white space from the start and end of the submitted full name via <a href="stringr.html#topic+str_squish">str_squish</a>. </p>
</td></tr>
<tr><td><code id="WFO.match_+3A_spec.name.tolower">spec.name.tolower</code></td>
<td>
<p> If <code>TRUE</code>, then convert all characters of the <code>spec.name</code> to lower case via <a href="base.html#topic+tolower">tolower</a>. </p>
</td></tr>
<tr><td><code id="WFO.match_+3A_spec.name.nonumber">spec.name.nonumber</code></td>
<td>
<p> If <code>TRUE</code>, then submitted <code>spec.name</code> that contain numbers will be interpreted as genera, only matching the first word. </p>
</td></tr>
<tr><td><code id="WFO.match_+3A_spec.name.nobrackets">spec.name.nobrackets</code></td>
<td>
<p> If <code>TRUE</code>, then submitted <code>spec.name</code> then sections of the submitted name after '(' will be removed. Note that this will also remove sections after ')', such as authorities for plant names that are in a separate column of WFO.  </p>
</td></tr>
<tr><td><code id="WFO.match_+3A_exclude.infraspecific">exclude.infraspecific</code></td>
<td>
<p> If <code>TRUE</code>, then exclude records that contain the infraspecific levels defined by <code>infraspecific.excluded</code>. </p>
</td></tr>
<tr><td><code id="WFO.match_+3A_infraspecific.excluded">infraspecific.excluded</code></td>
<td>
<p> Infraspecific levels (available from column 'verbatimTaxonRank') excluded in the results. Note that levels are excluded both in direct matches and matches with the accepted name. </p>
</td></tr>
<tr><td><code id="WFO.match_+3A_spec.name.sub">spec.name.sub</code></td>
<td>
<p> If <code>TRUE</code>, then delete sections of the <code>spec.name</code> that match the <code>sub.pattern</code>. </p>
</td></tr>
<tr><td><code id="WFO.match_+3A_sub.pattern">sub.pattern</code></td>
<td>
<p> Sections of the <code>spec.name</code> to be deleted </p>
</td></tr>
<tr><td><code id="WFO.match_+3A_verbose">verbose</code></td>
<td>
<p> Give details on the fuzzy matching process. </p>
</td></tr>
<tr><td><code id="WFO.match_+3A_counter">counter</code></td>
<td>
<p> Progress on the matching process is reported by multiples of this counter. </p>
</td></tr>
<tr><td><code id="WFO.match_+3A_wfo.result">WFO.result</code></td>
<td>
<p> Result obtained via <a href="#topic+WFO.match">WFO.match</a>. </p>
</td></tr>
<tr><td><code id="WFO.match_+3A_browse">browse</code></td>
<td>
<p> If <code>TRUE</code>, then browse urls specified by <code>browse.rows</code>. </p>
</td></tr>
<tr><td><code id="WFO.match_+3A_browse.rows">browse.rows</code></td>
<td>
<p> Indices of row with the urls to be browsed. </p>
</td></tr>
<tr><td><code id="WFO.match_+3A_priority">priority</code></td>
<td>
<p> Method of selecting the 1-to-1 matches. Option <code>Accepted</code> first limits candidates to accepted names, with a possible second step of eliminating accepted names that are synonyms. Option <code>Synonym</code> first limits candidates to those that are not synonyms, with a possible second step of eliminating names that are not accepted. When the number of matches is larger than one after these steps, a third algorithm picks the candidate with the smallest <code>taxonID</code>. </p>
</td></tr>
<tr><td><code id="WFO.match_+3A_auth.dist">Auth.dist</code></td>
<td>
<p> In case that the name of the variable with the Levenshtein distance between the authorship names is provided, then the algorithm first prioritizes records with the best match between the submitted and matched author names. </p>
</td></tr>
<tr><td><code id="WFO.match_+3A_taxon">taxon</code></td>
<td>
<p> Character string with the name of the taxon for which information will be given (for families, different genera; for genera, different specieds; for species, infraspecific levels). </p>
</td></tr>
<tr><td><code id="WFO.match_+3A_accepted.only">accepted.only</code></td>
<td>
<p> If <code>TRUE</code>, then only provide taxa with accepted names. </p>
</td></tr>
<tr><td><code id="WFO.match_+3A_...">...</code></td>
<td>
<p> Other arguments for <a href="utils.html#topic+browseURL">browseURL</a> (<code>WFO.url</code>) or <code>WFO.match</code> (<code>WFO.browse</code>). </p>
</td></tr>
</table>


<h3>Details</h3>

<p>The principal function (<code>WFO.match</code>) matches plant names. Columns retrieved from the World Flora Online are added to the provided input data.frame. In case that there are multiple matches, then rows from the input data.frame are repeated.
</p>
<p>Column 'Unique' shows whether there was a unique match (or not match) in the WFO.
</p>
<p>Column 'Matched' shows whether there was a match in the WFO.
</p>
<p>Column 'Fuzzy' shows whether matching was done by the fuzzy method.
</p>
<p>Column 'Fuzzy.dist' gives the Levenshtein distance calculated between submitted and matched plant names <a href="utils.html#topic+adist">adist</a>.
</p>
<p>Column 'Auth.dist' gives the Levenshtein distance calculated between submitted and matched authorship names, if the former were provided <a href="utils.html#topic+adist">adist</a>.
</p>
<p>Column 'Subseq' gives different numbers for different matches for the same plant name.
</p>
<p>Column 'Hybrid' shows whether there was a hybrid character in the scientificName.
</p>
<p>Column 'New.accepted' shows whether the species details correspond to the current accepted name.
</p>
<p>Column 'Old.status' gives the taxonomic status of the first match with the non-blank acceptedNameUsageID.
</p>
<p>Column 'Old.ID' gives the ID of the first match with the non-blank acceptedNameUsageID.
</p>
<p>Column 'Old.name' gives the name of the first match with the non-blank acceptedNameUsageID.
</p>
<p>The function was inspired on the <code>Taxonstand</code> package that matches plant names against The Plant List. Note that The Plant List has been static since 2013, but was used as the starting point for the Taxonomic Backbone of the World Flora Online.
</p>
<p>Function <code>WFO.one</code> finds one unique matching name for each submitted name. Via <code>priority = "Accepted"</code>, it first limits candidates to accepted names, with a possible second step of eliminating accepted names that are synonyms. Via <code>priority = "Synonym"</code>, it first limits candidates to those that are not synonyms, with a possible second step of eliminating names that are not accepted. When the number of matches is larger than one after these steps, a third algorithm picks the candidate with the smallest <code>taxonID</code>. When a <code>spec.name</code> is given to <code>WFO.one</code>, the original submitted name is inserted for the <code>scientificName</code>.
</p>
<p>When the user specifies the column with the <code>Auth.dist</code>, documenting the Levenshtein
distance between the submitted and matched authorities, then <code>WFO.one</code> first prioritizes records with best match between Authorities.
</p>
<p>Function <code>WFO.browse</code> lists all the genera for a family, all species for a genus or all infraspecific levels for a species.
</p>
<p>Function <code>WFO.synonyms</code> gives all records with the acceptedNameUsageID equal to the matched accepted species shown in the first row.
</p>
<p>Function <code>WFO.family</code> provides information on the order of vascular plants, based on information available from <a href="#topic+vascular.families">vascular.families</a>. Based on an internal list of bryophyte families, when the submitted plant name is a bryophyte, the function returns 'bryophyte' instead.
</p>


<h3>Value</h3>

<p>The main function returns a data.set with the matched species details from the WFO.
</p>


<h3>Author(s)</h3>

<p>Roeland Kindt (World Agroforestry, CIFOR-ICRAF)</p>


<h3>References</h3>

<p>World Flora Online. An Online Flora of All Known Plants.
<a href="https://www.worldfloraonline.org">https://www.worldfloraonline.org</a>
</p>
<p>Sigovini M, Keppel E, Tagliapietra. 2016. Open Nomenclature in the biodiversity era.
Methods in Ecology and Evolution 7: 1217-1225.
</p>
<p>Kindt, R. 2020. WorldFlora: An R package for exact and fuzzy matching of plant names against
the World Flora Online taxonomic backbone data.
Applications in Plant Sciences 8(9): e11388
</p>


<h3>See Also</h3>

<p><code><a href="#topic+WFO.match.fuzzyjoin">WFO.match.fuzzyjoin</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(WFO.example)

spec.test &lt;- data.frame(spec.name=c("Faidherbia albida", "Acacia albida",
    "Omalanthus populneus", "Pygeum afric"))

WFO.match(spec.data=spec.test, WFO.data=WFO.example, counter=1, verbose=TRUE)

# Also calculate the Levenshtein distance for the genus
WFO.match(spec.data=spec.test, WFO.data=WFO.example, First.dist=TRUE,
    counter=1, verbose=TRUE)

# Show all the fuzzy matches, which included those at infraspecifc level
e1 &lt;- WFO.match(spec.data=spec.test, WFO.data=WFO.example, counter=1,
    Fuzzy.min=FALSE, Fuzzy.shortest=FALSE, verbose=TRUE)
e1

# Use function WFO.one for a 1-to-1 match between submitted and matched names
WFO.one(e1)

# Hybrid species
WFO.match("Arabis divaricarpa", WFO.data=WFO.example)
WFO.match("Arabis x divaricarpa", WFO.data=WFO.example)

# Convert capitals to lower case
WFO.match("FAIDHERBIA ALBIDA", WFO.data=WFO.example, spec.name.tolower=TRUE)

# Remove sections of plant names that are equal to ' sp.' or ' indet. '
WFO.match("Prunus sp.", WFO.data=WFO.example, spec.name.sub=TRUE)

# Get urls, but do not open any
e2 &lt;- WFO.match(spec.data=spec.test, WFO.data=WFO.example, counter=1, verbose=TRUE)
WFO.url(e2, browse=FALSE, browse.rows=c(1:nrow(e2)))

# Include input species names where no matches were found
# This happens when the name with original species names is provided to WFO.one
x1 &lt;- WFO.match("World agroforestry", WFO.data=WFO.example)
WFO.one(x1, spec.name="spec.name")

## Not run: 

# Cross-check with Taxonstand results
library(Taxonstand)
data(bryophytes)

# Give the file with the static copy of the Taxonomic Backbone data ('classification.txt')
# that was downloaded from \url{https://www.worldfloraonline.org/downloadData}.
# Possibly first use unzip(file.choose()) for the downloaded WFO_Backbone.zip
WFO.file.RK &lt;- file.choose()

# check species name
w1 &lt;- WFO.match(bryophytes[1:20, ], WFO.file=WFO.file.RK, spec.name="Full.name", counter=1)
w1


# check species name from list of names
w1 &lt;- WFO.match(bryophytes$Full.name[1:20], WFO.file=WFO.file.RK, counter=1)

# re-check species names obtained via Taxonstand
# note that Taxonstand did not match some infraspecific names ('Higher.level')
r1 &lt;- Taxonstand::TPL(bryophytes$Full.name[1:20], corr = TRUE)
w2 &lt;- WFO.match(r1, WFO.file=WFO.file.RK, Genus="New.Genus", Species="New.Species",
          Infraspecific.rank="New.Infraspecific.rank", Infraspecific="New.Infraspecific", counter=1)
w2

# only check genus and species
# specify different names for infraspecific columns as default to Taxonstand
w3 &lt;- WFO.match(r1, WFO.file=WFO.file.RK, Genus="New.Genus", Species="New.Species",
          Infraspecific.rank="none", Infraspecific="none", counter=1)

# note that the method above also retrieved infraspecific levels
# to only retrieve at the species level, match infraspecific levels with an empty column
r1$empty &lt;- rep("", nrow(r1))
w4 &lt;- WFO.match(r1, WFO.file=WFO.file.RK, Genus="New.Genus", Species="New.Species",
          Infraspecific.rank="empty", Infraspecific="empty", counter=1)

# as an alternative to the method above, exclude all documented infraspecific levels
# from the results
w5 &lt;- WFO.match(r1, WFO.file=WFO.file.RK, Genus="New.Genus", Species="New.Species",
          exclude.infraspecific=TRUE, counter=1)

# save results to file
# utils::write.table(w4, quote=F, sep="\t", row.names=F, append=FALSE)

# limit the fuzzy matches to those that contain a shortened version of a species name
w6 &lt;- WFO.match("Acacia caes", WFO.file=WFO.file.RK, Fuzzy=0.01, Fuzzy.within=TRUE, verbose=TRUE)

# show all the matches for a genus
spec.test1 &lt;- data.frame(Genus=c("Casimiroa"))
w8 &lt;- WFO.match(spec.test1, WFO.file=WFO.file.RK, exclude.infraspecific=TRUE, verbose=TRUE)

# show all listings at a next hierarchical level
WFO.data1 &lt;- data.table::fread(WFO.file.RK, encoding="UTF-8")

WFO.browse("Pinaceae", WFO.data=WFO.data1)
WFO.browse("Pinaceae", WFO.data=WFO.data1, accepted.only=T)

WFO.browse("Tsuga", WFO.data=WFO.data1)
WFO.browse("Tsuga", WFO.data=WFO.data1, accepted.only=T)

WFO.browse("Olea europaea", WFO.data=WFO.data1)
WFO.browse("Olea europaea", WFO.data=WFO.data1, accepted.only=T)

# browsing only works at family, genus and species levels
# for orders, however, information is given from vascular.families
WFO.browse("Polypodiales", WFO.data=WFO.data1)

# submitting no name results in a list of all families
WFO.browse(, WFO.data=WFO.data1)

# give synonyms
WFO.synonyms("Olea europaea", WFO.data=WFO.data1)

# give order and other higher levels from family
WFO.family("Olea europaea", WFO.data=WFO.data1)

## End(Not run)
</code></pre>

<hr>
<h2 id='WFO.match.fuzzyjoin'>Standardize plant names according to World Flora Online taxonomic backbone</h2><span id='topic+WFO.match.fuzzyjoin'></span>

<h3>Description</h3>

<p>An alternative and typically faster method of matching records than <a href="#topic+WFO.match">WFO.match</a> that allows for different methods of calculating the fuzzy distance via <a href="stringdist.html#topic+stringdist">stringdist</a>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>    WFO.match.fuzzyjoin(spec.data = NULL, WFO.file = NULL, WFO.data = NULL,
        no.dates = TRUE,
        spec.name = "spec.name",
        Authorship = "Authorship",
        stringdist.method = "lv", fuzzydist.max = 4,
        Fuzzy.min = TRUE,
        acceptedNameUsageID.match = TRUE,
        squish = TRUE,
        spec.name.tolower = FALSE, spec.name.nonumber = TRUE, spec.name.nobrackets = TRUE,
        spec.name.sub = TRUE,
        sub.pattern=c(" sp[.] A", " sp[.] B", " sp[.] C", " sp[.]", " spp[.]", " pl[.]",
            " indet[.]", " ind[.]", " gen[.]", " g[.]", " fam[.]", " nov[.]", " prox[.]",
            " cf[.]", " aff[.]", " s[.]s[.]", " s[.]l[.]",
            " p[.]p[.]", " p[.] p[.]", "[?]", " inc[.]", " stet[.]", "Ca[.]",
            "nom[.] cons[.]", "nom[.] dub[.]", " nom[.] err[.]", " nom[.] illeg[.]",
            " nom[.] inval[.]", " nom[.] nov[.]", " nom[.] nud[.]", " nom[.] obl[.]",
            " nom[.] prot[.]", " nom[.] rej[.]", " nom[.] supp[.]", " sensu auct[.]"))

</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="WFO.match.fuzzyjoin_+3A_spec.data">spec.data</code></td>
<td>
<p> A data.frame containing variables with species names. In case that a character vector is provided, then this vector will be converted to a data.frame </p>
</td></tr>
<tr><td><code id="WFO.match.fuzzyjoin_+3A_wfo.file">WFO.file</code></td>
<td>
<p> File name of the static copy of the Taxonomic Backbone. If not <code>NULL</code>, then data will be reloaded from this file.</p>
</td></tr>
<tr><td><code id="WFO.match.fuzzyjoin_+3A_wfo.data">WFO.data</code></td>
<td>
<p> Data set with the static copy of the Taxonomic Backbone. Ignored if <code>WFO.file</code> is not <code>NULL</code>. </p>
</td></tr>
<tr><td><code id="WFO.match.fuzzyjoin_+3A_no.dates">no.dates</code></td>
<td>
<p> Speeding up the loading of the WFO.data by not loading fields of 'created' and 'modified'. </p>
</td></tr>
<tr><td><code id="WFO.match.fuzzyjoin_+3A_spec.name">spec.name</code></td>
<td>
<p> Name of the column with taxonomic names. </p>
</td></tr>
<tr><td><code id="WFO.match.fuzzyjoin_+3A_authorship">Authorship</code></td>
<td>
<p> Name of the column with the naming authorities. </p>
</td></tr>
<tr><td><code id="WFO.match.fuzzyjoin_+3A_stringdist.method">stringdist.method</code></td>
<td>
<p> Method used to calculate the fuzzy distance as used by in the internally called <code><a href="stringdist.html#topic+stringdist">stringdist</a></code>.   </p>
</td></tr>
<tr><td><code id="WFO.match.fuzzyjoin_+3A_fuzzydist.max">fuzzydist.max</code></td>
<td>
<p> Maximum distance used for joining as in <code><a href="fuzzyjoin.html#topic+stringdist_join">stringdist_join</a></code>.  </p>
</td></tr>
<tr><td><code id="WFO.match.fuzzyjoin_+3A_fuzzy.min">Fuzzy.min</code></td>
<td>
<p> Limit the results of fuzzy matching to those with the smallest distance. </p>
</td></tr>
<tr><td><code id="WFO.match.fuzzyjoin_+3A_acceptednameusageid.match">acceptedNameUsageID.match</code></td>
<td>
<p> If <code>TRUE</code>, obtain the accepted name and others details from the earlier acceptedNameUsageID. </p>
</td></tr>
<tr><td><code id="WFO.match.fuzzyjoin_+3A_squish">squish</code></td>
<td>
<p> If <code>TRUE</code>, remove repeated whitespace and white space from the start and end of the submitted full name via <a href="stringr.html#topic+str_squish">str_squish</a>. </p>
</td></tr>
<tr><td><code id="WFO.match.fuzzyjoin_+3A_spec.name.tolower">spec.name.tolower</code></td>
<td>
<p> If <code>TRUE</code>, then convert all characters of the <code>spec.name</code> to lower case via <a href="base.html#topic+tolower">tolower</a>. </p>
</td></tr>
<tr><td><code id="WFO.match.fuzzyjoin_+3A_spec.name.nonumber">spec.name.nonumber</code></td>
<td>
<p> If <code>TRUE</code>, then submitted <code>spec.name</code> that contain numbers will be interpreted as genera, only matching the first word. </p>
</td></tr>
<tr><td><code id="WFO.match.fuzzyjoin_+3A_spec.name.nobrackets">spec.name.nobrackets</code></td>
<td>
<p> If <code>TRUE</code>, then submitted <code>spec.name</code> then sections of the submitted name after '(' will be removed. Note that this will also remove sections after ')', such as authorities for plant names that are in a separate column of WFO.  </p>
</td></tr>
<tr><td><code id="WFO.match.fuzzyjoin_+3A_spec.name.sub">spec.name.sub</code></td>
<td>
<p> If <code>TRUE</code>, then delete sections of the <code>spec.name</code> that match the <code>sub.pattern</code>. </p>
</td></tr>
<tr><td><code id="WFO.match.fuzzyjoin_+3A_sub.pattern">sub.pattern</code></td>
<td>
<p> Sections of the <code>spec.name</code> to be deleted </p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function matches plant names by using the <code><a href="fuzzyjoin.html#topic+stringdist_left_join">stringdist_left_join</a></code> function internally. The results are provided in a similar formatto those from <code><a href="#topic+WFO.match">WFO.match</a></code>; therefore the <code><a href="#topic+WFO.one">WFO.one</a></code> function can be used in a next step of the analysis.
</p>
<p>For large data sets the function may fail due to memory limits. A solution is to analyse
different subsets of large data, as for example shown by Kindt (2023).
</p>
<p>Column 'Unique' shows whether there was a unique match (or not match) in the WFO.
</p>
<p>Column 'Matched' shows whether there was a match in the WFO.
</p>
<p>Column 'Fuzzy' shows whether matching was done by the fuzzy method.
</p>
<p>Column 'Fuzzy.dist' gives the fuzzy distance calculated between submitted and matched plant names, calculated internally with <a href="fuzzyjoin.html#topic+stringdist_left_join">stringdist_left_join</a>.
</p>
<p>Column 'Auth.dist' gives the Levenshtein distance calculated between submitted and matched authorship names, if the former were provided. This distance is calculated in the same way as for the <a href="#topic+WFO.match">WFO.match</a> function via <a href="utils.html#topic+adist">adist</a>.
</p>
<p>Column 'Subseq' gives different numbers for different matches for the same plant name.
</p>
<p>Column 'Hybrid' shows whether there was a hybrid character in the scientificName.
</p>
<p>Column 'New.accepted' shows whether the species details correspond to the current accepted name.
</p>
<p>Column 'Old.status' gives the taxonomic status of the first match with the non-blank acceptedNameUsageID.
</p>
<p>Column 'Old.ID' gives the ID of the first match with the non-blank acceptedNameUsageID.
</p>
<p>Column 'Old.name' gives the name of the first match with the non-blank acceptedNameUsageID.
</p>


<h3>Value</h3>

<p>The main function returns a data.set with the matched species details from the WFO.
</p>


<h3>Author(s)</h3>

<p>Roeland Kindt (World Agroforestry, CIFOR-ICRAF)</p>


<h3>References</h3>

<p>World Flora Online. An Online Flora of All Known Plants.
<a href="https://www.worldfloraonline.org">https://www.worldfloraonline.org</a>
</p>
<p>Sigovini M, Keppel E, Tagliapietra. 2016. Open Nomenclature in the biodiversity era.
Methods in Ecology and Evolution 7: 1217-1225.
</p>
<p>Kindt, R. 2020. WorldFlora: An R package for exact and fuzzy matching of plant names against
the World Flora Online taxonomic backbone data.
Applications in Plant Sciences 8(9): e11388
</p>
<p>Kindt, R. 2023. Standardizing tree species names of GlobalTreeSearch with WorldFlora while
testing the faster matching function of WFO.match.fuzzyjoin.
<a href="https://rpubs.com/Roeland-KINDT/996500">https://rpubs.com/Roeland-KINDT/996500</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+WFO.match">WFO.match</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Not run: 
data(WFO.example)

library(fuzzyjoin)

spec.test &lt;- data.frame(spec.name=c("Faidherbia albida", "Acacia albida",
    "Faidherbia albiad",
    "Omalanthus populneus", "Pygeum afric"))

WFO.match.fuzzyjoin(spec.data=spec.test, WFO.data=WFO.example)

# Using the Damerau-Levenshtein distance
WFO.match.fuzzyjoin(spec.data=spec.test, WFO.data=WFO.example,
    stringdist.method="dl")

## End(Not run)
</code></pre>

<hr>
<h2 id='WFO.prepare'>Prepare a data set for analysis with WFO.match</h2><span id='topic+WFO.prepare'></span><span id='topic+WFO.preprepare'></span>

<h3>Description</h3>

<p>The main function of <code>WFO.prepare</code> attempts to split a list of species names with naming authorities in different fields of botanical names and authorities.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>WFO.prepare(spec.data = NULL, spec.full="spec.full",
    squish = TRUE, spec.name.nonumber = TRUE,
        spec.name.sub = TRUE, 
        sub.pattern = c(" sp[.] A", " sp[.] B", " sp[.] C", " sp[.]", " spp[.]", " pl[.]",
            " indet[.]", " ind[.]", " gen[.]", " g[.]", " fam[.]", " nov[.]", " prox[.]", 
            " cf[.]", " aff[.]", " s[.]s[.]", " s[.]l[.]", 
            " p[.]p[.]", " p[.] p[.]", "[?]", " inc[.]", " stet[.]", "Ca[.]", 
            "nom[.] cons[.]", "nom[.] dub[.]", " nom[.] err[.]", " nom[.] illeg[.]", 
            " nom[.] inval[.]", " nom[.] nov[.]", " nom[.] nud[.]", " nom[.] obl[.]", 
            " nom[.] prot[.]", " nom[.] rej[.]", " nom[.] supp[.]", " sensu auct[.]"),  
    genus.2.flag = TRUE, species.2.flag = TRUE, 
    punctuation.flag = TRUE, pointless.flag = TRUE,
    trinomial = c("cultivar.", "f.", "sect.", "subf.", "subg.", 
        "subsp.", "subvar.", "var.",
        "CULTIVAR.",  "SECT.", "SUBF.", "SUBG.", "SUBSP.", "SUBVAR.", "VAR."),
    authors.ending.f=c("Aiton f.", "Baker f.", "Bak. f.", "Burm. f.", 
                       "Cheng f.", "Chrtek f.", 
                       "De Marco f.", "Fang f.", "Ferry f.", "Forsyth f.", 
                       "Forster f.", "Fraser f.", "G.Don f.", "Haller f.",
                       "Hallier f.", "Hook. f.", "Hooker f.", "Hsueh f.", 
                       "J.Kickx f.", "J. Kickx f.", "Keng f.", 
                       "Kickx f.", "Klokov f.", "Koster f.",
                       "Liou f.", "L. f.", "Ma f.", "Mikan f.",
                       "Occhioni f.", "Rchb. f.", 
                       "Schultes f.", "Schult. f.", "Stapf f."),
    verbose = TRUE, counter = 1000)
    
WFO.preprepare(spec.data=NULL, spec.full="spec.full",
    trinomial.first="subsp.", trinomial.second="var.")     
    
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="WFO.prepare_+3A_spec.data">spec.data</code></td>
<td>
<p> A data.frame containing variables with species names. In case that a character vector is provided, then this vector will be converted to a data.frame </p>
</td></tr>
<tr><td><code id="WFO.prepare_+3A_spec.full">spec.full</code></td>
<td>
<p> Name of the column with full taxonomic names.</p>
</td></tr>
<tr><td><code id="WFO.prepare_+3A_squish">squish</code></td>
<td>
<p> If <code>TRUE</code>, remove repeated whitespace and white space from the start and end of the submitted full name via <a href="stringr.html#topic+str_squish">str_squish</a>. </p>
</td></tr>
<tr><td><code id="WFO.prepare_+3A_spec.name.nonumber">spec.name.nonumber</code></td>
<td>
<p> If <code>TRUE</code>, then submitted <code>spec.full</code> that contain numbers will be interpreted as genera, only matching the first word. </p>
</td></tr>
<tr><td><code id="WFO.prepare_+3A_spec.name.sub">spec.name.sub</code></td>
<td>
<p> If <code>TRUE</code>, then delete sections of the <code>spec.full</code> that match the <code>sub.pattern</code>. </p>
</td></tr>
<tr><td><code id="WFO.prepare_+3A_sub.pattern">sub.pattern</code></td>
<td>
<p> Sections of the <code>spec.full</code> to be deleted </p>
</td></tr>
<tr><td><code id="WFO.prepare_+3A_genus.2.flag">genus.2.flag</code></td>
<td>
<p> Flag first part of the names with only 2 characters. </p>
</td></tr>  
<tr><td><code id="WFO.prepare_+3A_species.2.flag">species.2.flag</code></td>
<td>
<p> Flag second part of the names with only 2 characters. </p>
</td></tr>  
<tr><td><code id="WFO.prepare_+3A_punctuation.flag">punctuation.flag</code></td>
<td>
<p> Flag if the retained plant name has punctuation characters. </p>
</td></tr>  
<tr><td><code id="WFO.prepare_+3A_pointless.flag">pointless.flag</code></td>
<td>
<p> Flag if the retained plant name has sub.pattern without the point. </p>
</td></tr>  
<tr><td><code id="WFO.prepare_+3A_trinomial">trinomial</code></td>
<td>
<p> Descriptors for trinomial names. In case a trinomial name is expected, the species name will be obtained from the first two words and the two words starting with the trinomial descriptor. </p>
</td></tr>
<tr><td><code id="WFO.prepare_+3A_authors.ending.f">authors.ending.f</code></td>
<td>
<p> Author names that end with ' f.', not confuse the function about trinomials with 'f.', indicating 'filius' ('son of'). </p>
</td></tr>  
<tr><td><code id="WFO.prepare_+3A_verbose">verbose</code></td>
<td>
<p> Give details on the process. </p>
</td></tr>  
<tr><td><code id="WFO.prepare_+3A_counter">counter</code></td>
<td>
<p> Progress on the process is reported by multiples of this counter. </p>
</td></tr>
<tr><td><code id="WFO.prepare_+3A_trinomial.first">trinomial.first</code></td>
<td>
<p> Pattern to split species name in different columns. </p>
</td></tr>
<tr><td><code id="WFO.prepare_+3A_trinomial.second">trinomial.second</code></td>
<td>
<p> Second pattern to split species name in different columns. </p>
</td></tr>
</table>


<h3>Details</h3>

<p>Function <code>WFO.prepare</code> splits submitted names into the botanical name ('spec.name') and the naming authority ('Authorship'). When the submitted name contains section between brackets that are not at the beginning of the naming authority, these sections will be removed. Function <code>WFO.preprepare</code> was designed to deal with situations where author names are given at species and infra-specific levels (see examples).
</p>


<h3>Value</h3>

<p>The function splits names in the botanical name and the naming authority.
</p>


<h3>Author(s)</h3>

<p>Roeland Kindt (World Agroforestry)</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Not run: 
WFO.prepare("Terminalia superba Engl. &amp; Diels (**) (In review)")
WFO.prepare("Sorbus aucuparia subsp. praemorsa (Guss.) Nyman")
WFO.prepare("Ormosia aff. coarctata Jackson")
WFO.prepare("Ormosia aff coarctata Jackson")
WFO.prepare("Ormosia /coarctata Jackson")
WFO.prepare("Qualea TMG 148 Aubl.")
# Note that the sub.pattern is ' cf.'
WFO.prepare("cf Myrcia M1")
# Dealing with author names that end with ' f.' ('filius')
WFO.prepare("Malveopsis scabrosum Stapf f.")

# Using preprepare to deal with authorities at multiple levels
WFO.preprepare("Agave deserti Engelm. subsp. simplex Gentry")
WFO.preprepare("Zoysia matrella (L.) Merr. var. pacifica Goudsw.")

test.name &lt;- paste0("Agastache pallidiflora (A. Heller) Rydb.",
  " subsp. neomexicana (Briq.) Lint &amp; Epling",
  " var. havardii (A. Gray) R.W. Sanders")
WFO.preprepare(test.name)

## End(Not run)

</code></pre>

<hr>
<h2 id='WFO.remember'>Remember the location of the Taxonomic Backbone data set</h2><span id='topic+WFO.remember'></span><span id='topic+WFO.download'></span>

<h3>Description</h3>

<p>The function remembers where the Taxonomic Backbone data was downloaded to. In case that no arguments are specified, then data.frame <code>WFO.data</code> will contain the previously specified Taxonomic Backbone data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>    WFO.download(WFO.url =
      paste0("https://files.worldfloraonline.org/files/WFO_Backbone/",
             "_WFOCompleteBackbone/WFO_Backbone.zip"),
    save.dir = getwd(), WFO.remember = TRUE,
    timeout = 500, ...)

    WFO.remember(WFO.file = NULL, WFO.data = "WFO.data", WFO.pos = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="WFO.remember_+3A_wfo.url">WFO.url</code></td>
<td>
<p> Hyperlink to the download from the World Flora Online. </p>
</td></tr>
<tr><td><code id="WFO.remember_+3A_save.dir">save.dir</code></td>
<td>
<p> Directory where the file will be downloaded and unzipped.</p>
</td></tr>
<tr><td><code id="WFO.remember_+3A_wfo.remember">WFO.remember</code></td>
<td>
<p> Remember the location of the file for <code>WFO.remember</code>. </p>
</td></tr>
<tr><td><code id="WFO.remember_+3A_timeout">timeout</code></td>
<td>
<p> Timeout in seconds for some internet operations, to be modified among Options Settings. </p>
</td></tr>
<tr><td><code id="WFO.remember_+3A_...">...</code></td>
<td>
<p> Other arguments for <a href="utils.html#topic+download.file">download.file</a>. </p>
</td></tr>
<tr><td><code id="WFO.remember_+3A_wfo.file">WFO.file</code></td>
<td>
<p> File path to the Taxonomic Backbone data ('classification.txt'). </p>
</td></tr>
<tr><td><code id="WFO.remember_+3A_wfo.data">WFO.data</code></td>
<td>
<p> Name of data set to be used by other WorldFlora functions.</p>
</td></tr>
<tr><td><code id="WFO.remember_+3A_wfo.pos">WFO.pos</code></td>
<td>
<p> Argument pos as in <a href="base.html#topic+assign">assign</a>. </p>
</td></tr>
</table>


<h3>Details</h3>

<p>These functions avoid that a user needs to reload and re-specify the location of the Taxonomic Backbone data that was previously downloaded from the World Flora Online website. The location is saved in a text file in the 'etc' directory of the WorldFlora directory.
</p>


<h3>Value</h3>

<p>The function remembers the local location of the Taxonomic Backbone data.
</p>


<h3>Author(s)</h3>

<p>Roeland Kindt (World Agroforestry)</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Not run: 

# change the working directory
setwd(choose.dir())

# download the Taxonomic Backbone data
WFO.download()

# remember the previous download and avail the data as 'WFO.data'
WFO.remember()

# check
WFO.match("Faidherbia albida", WFO.data=WFO.data)

## End(Not run)

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
