<!DOCTYPE html><html lang="en"><head><title>Help for package polyapost</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {polyapost}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#constrppmn'><p>Estimating a Population Mean Using the Constrained Polya Posterior.</p></a></li>
<li><a href='#constrppprob'><p>Dependent Sampling from the Uniform Distribution on a Polytope.</p></a></li>
<li><a href='#feasible'><p>Feasible Solution for a Probability Distribution which must</p>
Satisfy a System of Linear Equality and Inequality Constraints.</a></li>
<li><a href='#hitrun'><p>Hit and Run Algorithm for Constrained Dirichlet Distribution</p></a></li>
<li><a href='#polyap'><p>Polya Sampling from an Urn</p></a></li>
<li><a href='#wtpolyap'><p>Polya Sampling from an Urn with Possibly Unequal Weights</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Version:</td>
<td>1.7-1</td>
</tr>
<tr>
<td>Date:</td>
<td>2024-09-17</td>
</tr>
<tr>
<td>Imports:</td>
<td>boot, stats</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.6.2), rcdd (&ge; 1.2)</td>
</tr>
<tr>
<td>Title:</td>
<td>Simulating from the Polya Posterior</td>
</tr>
<tr>
<td>ByteCompile:</td>
<td>TRUE</td>
</tr>
<tr>
<td>Description:</td>
<td>Simulate via Markov chain Monte Carlo (hit-and-run algorithm)
    a Dirichlet distribution conditioned to satisfy a finite set of linear
    equality and inequality constraints (hence to lie in a convex polytope
    that is a subset of the unit simplex).</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-09-17 22:29:47 UTC; geyer</td>
</tr>
<tr>
<td>Author:</td>
<td>Glen Meeden [aut, cre],
  Radu Lazar [aut],
  Charles J. Geyer [aut]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Glen Meeden &lt;gmeeden@umn.edu&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-09-25 23:20:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='constrppmn'>Estimating a Population Mean Using the Constrained Polya Posterior.</h2><span id='topic+constrppmn'></span>

<h3>Description</h3>

<p>Let <code class="reqn">p=(p_1,\ldots,p_n)</code>
be a probability distribution defined on
<code class="reqn">y_{\rm samp}</code>, the set of observed values, in a sample of
size <code class="reqn">n</code>
from some population. <code class="reqn">p</code> is assumed to belong to
a polytope which is a lower dimensional subset of the <code class="reqn">n</code>-dimensional
simplex.  The polytope is defined by a collection of linear
equality and inequality constraints.  A dependent sequence of values
for <code class="reqn">p</code> are generated by a Markov chain using the Metropolis-Hastings
algorithm whose stationary distribution is the uniform distribution
over the polytope.  For each generated value of <code class="reqn">p</code> the corresponding
mean, <code class="reqn">\sum_i p_i y_i</code>  is found.</p>


<h3>Usage</h3>

<pre><code class='language-R'>constrppmn(A1,A2,A3,b1,b2,b3,initsol,reps,ysamp,burnin)</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="constrppmn_+3A_a1">A1</code></td>
<td>
<p>The matrix for the equality constraints.This must always
contain the constraint <code>sum(p) == 1</code>.</p>
</td></tr>
<tr><td><code id="constrppmn_+3A_a2">A2</code></td>
<td>
<p>The matrix for the <code>&lt;=</code> inequality constraints.  This must always
contain the constraints <code>-p &lt;= 0</code>.</p>
</td></tr>
<tr><td><code id="constrppmn_+3A_a3">A3</code></td>
<td>
<p>The matrix for the <code>&gt;=</code> inequality constraints.  If there are no
such constraints <code>A3</code> must be set equal to NULL.</p>
</td></tr>
<tr><td><code id="constrppmn_+3A_b1">b1</code></td>
<td>
<p>The rhs vector for <code>A1</code>, each component must be nonnegative.</p>
</td></tr>
<tr><td><code id="constrppmn_+3A_b2">b2</code></td>
<td>
<p>The rhs vector for <code>A2</code>, each component must be nonnegative.</p>
</td></tr>
<tr><td><code id="constrppmn_+3A_b3">b3</code></td>
<td>
<p>The rhs vector for <code>A3</code>, each component must be nonnegative.
If <code>A3</code> is <code>NULL</code> then <code>b3</code> must be NULL.</p>
</td></tr>
<tr><td><code id="constrppmn_+3A_initsol">initsol</code></td>
<td>
<p>A vector which lies in the interior of the polytope.</p>
</td></tr>
<tr><td><code id="constrppmn_+3A_reps">reps</code></td>
<td>
<p>The total length of the chain that is generated.</p>
</td></tr>
<tr><td><code id="constrppmn_+3A_ysamp">ysamp</code></td>
<td>
<p>The observed sample from the population of interest.</p>
</td></tr>
<tr><td><code id="constrppmn_+3A_burnin">burnin</code></td>
<td>
<p>The point in the chain at which the set of computed means
begins.</p>
</td></tr></table>


<h3>Value</h3>

<p>The returned value is a list whose first component is the chain
of the means of length <code>reps - burnin -1</code>, whose second component
is the mean  of the first component (i.e. the Polya estimate of the
population mean) and whose third component is the 2.5th and 97.5th
quantiles of the first component (i.e. an approximate 95 percent
confidence interval of the population mean).</p>


<h3>Examples</h3>

<pre><code class='language-R'>A1&lt;-rbind(rep(1,6),1:6)
A2&lt;-rbind(c(2,5,7,1,10,8),diag(-1,6))
b1&lt;-c(1,3.5)
b2&lt;-c(6,rep(0,6))
initsol&lt;-rep(1/6,6)
rep&lt;-1006
burnin&lt;-1000
ysamp&lt;-c(1,2.5,3.5,7,4.5,6)
out&lt;-constrppmn(A1,A2,NULL,b1,b2,NULL,initsol,rep,ysamp,burnin)
out[[1]] # the Markov chain of the means.
out[[2]] # the average of out[[1]]
out[[3]] # the 2.5th and 97.5th quantiles of out[[1]]
</code></pre>

<hr>
<h2 id='constrppprob'>Dependent Sampling from the Uniform Distribution on a Polytope.</h2><span id='topic+constrppprob'></span>

<h3>Description</h3>

<p>Let <code class="reqn">p=(p_1,\ldots,p_n)</code>
be a probability distribution
which belongs to a lower dimensional polytope of the <code class="reqn">n</code>-dimensional
simplex.  The polytope is defined by a collection of linear
equality and inequality constraints.  A dependent sequence of the 
<code class="reqn">p</code>'s are generated by a Markov chain using the Metropolis-Hastings
algorithm whose stationary distribution is the uniform distribution
over the polytope.  This is done by generating <code class="reqn">k</code> blocks
of size <code>step</code>
where the last member of each is returned.</p>


<h3>Usage</h3>

<pre><code class='language-R'>constrppprob(A1,A2,A3,b1,b2,b3,initsol,step,k)</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="constrppprob_+3A_a1">A1</code></td>
<td>
<p>The matrix for the equality constraints.This must always
contain the constraint <code>sum(p) == 1</code>.</p>
</td></tr>
<tr><td><code id="constrppprob_+3A_a2">A2</code></td>
<td>
<p>The matrix for the <code>&lt;=</code> inequality constraints.  This must always
contain the constraints <code>-p &lt;= 0</code>.</p>
</td></tr>
<tr><td><code id="constrppprob_+3A_a3">A3</code></td>
<td>
<p>The matrix for the <code>&gt;=</code> inequality constraints.  If there are no
such constraints <code>A3</code> must be set equal to <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="constrppprob_+3A_b1">b1</code></td>
<td>
<p>The rhs vector for <code>A1</code>, each component must be nonnegative.</p>
</td></tr>
<tr><td><code id="constrppprob_+3A_b2">b2</code></td>
<td>
<p>The rhs vector for <code>A2</code>, each component must be nonnegative.</p>
</td></tr>
<tr><td><code id="constrppprob_+3A_b3">b3</code></td>
<td>
<p>The rhs vector for <code>A3</code>, each component must be nonnegative.
If <code>A3</code> is <code>NULL</code> then <code>b3</code> must be NULL.</p>
</td></tr>
<tr><td><code id="constrppprob_+3A_initsol">initsol</code></td>
<td>
<p>A vector which lies in the interior of the polytope.</p>
</td></tr>
<tr><td><code id="constrppprob_+3A_step">step</code></td>
<td>
<p>The number of <code>p</code>'s generated in a block before the
last member of a block is returned.</p>
</td></tr>
<tr><td><code id="constrppprob_+3A_k">k</code></td>
<td>
<p>The total number of blocks generated and hence the number
of <code>p</code>'s returned.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The returned value is a <code class="reqn">k</code> by <code class="reqn">n</code> matrix of probability vectors.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>A1&lt;-rbind(rep(1,6),1:6)
A2&lt;-rbind(c(2,5,7,1,10,8),diag(-1,6))
A3&lt;-matrix(c(1,1,1,0,0,0),1,6)
b1&lt;-c(1,3.5)
b2&lt;-c(6,rep(0,6))
b3&lt;-0.45
initsol&lt;-rep(1/6,6)
constrppprob(A1,A2,A3,b1,b2,b3,initsol,2000,5)
</code></pre>

<hr>
<h2 id='feasible'>Feasible Solution for a Probability Distribution which must
Satisfy a System of Linear Equality and Inequality Constraints.</h2><span id='topic+feasible'></span>

<h3>Description</h3>

<p>This function finds a feasible solution,
<code class="reqn">p=(p_1,\ldots,p_n)</code>, in the <code class="reqn">n</code>-dimensional simplex of
probability distributions which must satisfy
<code class="reqn">A_1 p = b_1</code>,
<code class="reqn">A_2 p = b_2</code>, and
<code class="reqn">A_3 p = b_3</code>,
All the components of the <code class="reqn">b_i</code> must be nonnegative
In addition  each probability in the solution must
be at least as big as <code>eps</code>, a small positive number.</p>


<h3>Usage</h3>

<pre><code class='language-R'>feasible(A1,A2,A3,b1,b2,b3,eps)</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="feasible_+3A_a1">A1</code></td>
<td>
<p>The matrix for the equality constraints.This must always
contain the constraint <code>sum(p) == 1</code>.</p>
</td></tr>
<tr><td><code id="feasible_+3A_a2">A2</code></td>
<td>
<p>The matrix for the <code>&lt;=</code> inequality constraints.  This must always
contain the constraints <code>-p &lt;= 0</code>.</p>
</td></tr>
<tr><td><code id="feasible_+3A_a3">A3</code></td>
<td>
<p>The matrix for the <code>&gt;=</code> inequality constraints.  If there are no
such constraints <code>A3</code> must be set equal to <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="feasible_+3A_b1">b1</code></td>
<td>
<p>The rhs vector for <code>A1</code>, each component must be nonnegative.</p>
</td></tr>
<tr><td><code id="feasible_+3A_b2">b2</code></td>
<td>
<p>The rhs vector for <code>A2</code>, each component must be nonnegative.</p>
</td></tr>
<tr><td><code id="feasible_+3A_b3">b3</code></td>
<td>
<p>The rhs vector for <code>A3</code>, each component must be nonnegative.
If <code>A3</code> is <code>NULL</code> then <code>b3</code> must be <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="feasible_+3A_eps">eps</code></td>
<td>
<p>A small positive number.  Each member of the solution must
be at least as large as <code>eps</code>.  Care must be taken not to choose a value
of <code>eps</code> which is too large.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The function returns a vector.  If the components of the vector
are positive then the feasible solution is the vector returned,
otherwise there is no feasible solution.</p>


<h3>Examples</h3>

<pre><code class='language-R'>A1&lt;-rbind(rep(1,7),1:7)
b1&lt;-c(1,4)
A2&lt;-rbind(c(1,1,1,1,0,0,0),c(.2,.4,.6,.8,1,1.2,1.4))
b2&lt;-c(1,2)
A3&lt;-rbind(c(1,3,5,7,9,10,11),c(1,1,1,0,0,0,1))
b3&lt;-c(5,.5)
eps&lt;-1/100
feasible(A1,A2,A3,b1,b2,b3,eps)
</code></pre>

<hr>
<h2 id='hitrun'>Hit and Run Algorithm for Constrained Dirichlet Distribution</h2><span id='topic+hitrun'></span><span id='topic+hitrun.default'></span><span id='topic+hitrun.hitrun'></span>

<h3>Description</h3>

<p>Markov chain Monte Carlo for equality and inequality constrained
Dirichlet distribution using a hit and run algorithm.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>hitrun(alpha, ...)

## Default S3 method:
hitrun(alpha, a1 = NULL, b1 = NULL, a2 = NULL, b2 = NULL,
     nbatch = 1, blen = 1, nspac = 1, outmat = NULL, debug = FALSE,
     stop.if.implied.equalities = FALSE, ...)

## S3 method for class 'hitrun'
hitrun(alpha, nbatch, blen, nspac, outmat, debug, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="hitrun_+3A_alpha">alpha</code></td>
<td>
<p>parameter vector for Dirichlet distribution.  Alternatively,
an object of class <code>"hitrun"</code> that is the result of a previous
invocation of this function, in which case this run continues where
the other left off.</p>
</td></tr>
<tr><td><code id="hitrun_+3A_nbatch">nbatch</code></td>
<td>
<p>the number of batches.</p>
</td></tr>
<tr><td><code id="hitrun_+3A_blen">blen</code></td>
<td>
<p>the length of batches.</p>
</td></tr>
<tr><td><code id="hitrun_+3A_nspac">nspac</code></td>
<td>
<p>the spacing of iterations that contribute to batches.</p>
</td></tr>
<tr><td><code id="hitrun_+3A_a1">a1</code></td>
<td>
<p>a numeric or character matrix or <code>NULL</code>.  See details.</p>
</td></tr>
<tr><td><code id="hitrun_+3A_b1">b1</code></td>
<td>
<p>a numeric or character vector or <code>NULL</code>.  See details.</p>
</td></tr>
<tr><td><code id="hitrun_+3A_a2">a2</code></td>
<td>
<p>a numeric or character matrix or <code>NULL</code>.  See details.</p>
</td></tr>
<tr><td><code id="hitrun_+3A_b2">b2</code></td>
<td>
<p>a numeric or character vector or <code>NULL</code>.  See details.</p>
</td></tr>
<tr><td><code id="hitrun_+3A_outmat">outmat</code></td>
<td>
<p>a numeric matrix, which controls the output.  If <code>p</code>
is the constrained Dirichlet random vector being simulated, then
<code>outmat %*% p</code> is the functional of the state that is averaged.
May be <code>NULL</code>, in which case the identity matrix is used.</p>
</td></tr>
<tr><td><code id="hitrun_+3A_debug">debug</code></td>
<td>
<p>if <code>TRUE</code>, then additional output useful for debugging
is produced.</p>
</td></tr>
<tr><td><code id="hitrun_+3A_stop.if.implied.equalities">stop.if.implied.equalities</code></td>
<td>
<p>If <code>TRUE</code> stop if there
are any implied equalities.</p>
</td></tr>
<tr><td><code id="hitrun_+3A_...">...</code></td>
<td>
<p>ignored arguments.  Allows the two methods to have different
arguments.  You cannot change the Dirichlet parameter or the constraints
(hence cannot change the target distribution) when using the method
for class <code>"hitrun"</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Runs a hit and run algorithm (for which see the references)
producing a Markov chain with equilibrium distribution having a Dirichlet
distribution with parameter vector <code>alpha</code> constrained to lie in the
subset of the unit simplex consisting of <code>x</code> satisfying
</p>
<pre>
    a1 %*% x &lt;= b1
    a2 %*% x == b2
</pre>
<p>Hence if <code>a1</code> is <code>NULL</code> then so must be <code>b1</code>, and vice versa,
and similarly for <code>a2</code> and <code>b2</code>.
</p>
<p>If any of <code>a1</code>, <code>b1</code>, <code>a2</code>, <code>b2</code> are of type
<code>"character"</code>, then they must be valid GMP (GNU multiple precision)
rational, that is, if run through <code><a href="rcdd.html#topic+q2q">q2q</a></code>, they do not
give an error.  This allows constraints to be represented exactly
(using infinite precision rational arithmetic) if so desired.
See also the section on this subject below.
</p>


<h3>Value</h3>

<p>an object of class <code>"hitrun"</code>,
which is a list containing at least the following components:
</p>
<table role = "presentation">
<tr><td><code>batch</code></td>
<td>
<p><code>nbatch</code> by <code>p</code> matrix, the batch means, where
<code>p</code> is the row dimension of <code>outmat</code>.</p>
</td></tr>
<tr><td><code>initial</code></td>
<td>
<p>initial state of Markov chain.</p>
</td></tr>
<tr><td><code>final</code></td>
<td>
<p>final state of Markov chain.</p>
</td></tr>
<tr><td><code>initial.seed</code></td>
<td>
<p>value of <code>.Random.seed</code> before the run.</p>
</td></tr>
<tr><td><code>final.seed</code></td>
<td>
<p>value of <code>.Random.seed</code> after the run.</p>
</td></tr>
<tr><td><code>time</code></td>
<td>
<p>running time from <code>system.time()</code>.</p>
</td></tr>
<tr><td><code>alpha</code></td>
<td>
<p>the Dirichlet parameter vector.</p>
</td></tr>
<tr><td><code>nbatch</code></td>
<td>
<p>the argument <code>nbatch</code> or <code>obj$nbatch</code>.</p>
</td></tr>
<tr><td><code>blen</code></td>
<td>
<p>the argument <code>blen</code> or <code>obj$blen</code>.</p>
</td></tr>
<tr><td><code>nspac</code></td>
<td>
<p>the argument <code>nspac</code> or <code>obj$nspac</code>.</p>
</td></tr>
<tr><td><code>outmat</code></td>
<td>
<p>the argument <code>outmat</code> or <code>obj$outmat</code>.</p>
</td></tr>
</table>


<h3>GMP Rational Arithmetic</h3>

<p>The arguments <code>a1</code>, <code>b1</code>, <code>a2</code>, and <code>b2</code> can and should be
given as GMP (GNU multiple precision) rational values.  This allows the
computational geometry calculations for the constraint set to be done exactly,
without error.  For example, if <code>a1</code> has elements that have been rounded
to two decimal places one should do
</p>
<pre>
a1 &lt;- z2q(round(100 * a1), rep(100, length(a1)))
</pre>
<p>and similarly for <code>b1</code>, <code>a2</code>, and <code>b2</code> to make them exact.
For all the conversion functions between ordinary computer numbers and
GMP rational numbers see <a href="rcdd.html#topic+ConvertGMP">ConvertGMP</a>.  For all the functions that
do arithmetic on GMP rational numbers, see <a href="rcdd.html#topic+ArithmeticGMP">ArithmeticGMP</a>.
</p>


<h3>Warning About Implied Equality Constraints</h3>

<p>If any constraints supplied as inequality constraints (specified by rows
of <code>a1</code> and the corresponding components of <code>b1</code>) actually hold
with equality for all points in the constraint set, this is called an
implied equality constraint.  The program must establish that none of these
exist (which is a fast operation) or, otherwise, find out which constraints
supplied as inequality constraints are actually implied equality constraints,
and this operation is very slow when the state is high dimensional.  One
example with 1000 variables took 3 days of computing time when there were
implied equality constraints in the specification.  The same example takes
9 minutes when the same constraint set is specified in a different way so
that there are no  implied equality constraints.
</p>
<p>This issue is not a big deal if there are only in the low hundreds of
variables, because the algorithm to find implied equality constraints is not
that slow.  The same example that takes 3 days of computing time with 1000
variables takes only 15 seconds with 100 variables, 3 and 1/2 minutes with 200
variables, and 23 minutes with 300 variables.  As one can see, this issue
does become a big deal as the number of variables increases.  Thus users
should avoid implied inequality constraints, if possible,
when there are many variables.  Admittedly, there
is no sure way users can identify and eliminate implied equality constraints.
(The sure way to do that is precisely the time consuming step we are trying
to avoid.)  The argument <code>stop.if.implied.equalities</code> can be used to
quickly test for the presence of implied equalities.
</p>


<h3>Philosophy of MCMC</h3>

<p>This function follows the philosophy of MCMC used in the CRAN package
<code>mcmc</code> and the introductory chapter of the
<em>Handbook of Markov Chain Monte Carlo</em> (Geyer, 2011).
</p>
<p>The <code>hitrun</code> function automatically does batch means in order to reduce
the size of output and to enable easy calculation of Monte Carlo standard
errors (MCSE), which measure error due to the Monte Carlo sampling (not
error due to statistical sampling &mdash; MCSE gets smaller when you run the
computer longer, but statistical sampling variability only gets smaller
when you get a larger data set).  All of this is explained in the package
vignette for the <code>mcmc</code> package (<code>vignette("demo", "mcmc")</code>)
and in Section 1.10 of Geyer (2011).
</p>
<p>The <code>hitrun</code> function does not apparently
do &ldquo;burn-in&rdquo; because this concept does not actually help with MCMC
(Geyer, 2011, Section 1.11.4) but the re-entrant property of the hitrun
function does allow one to do &ldquo;burn-in&rdquo; if one wants.
Assuming <code>alpha</code>, <code>a1</code>, <code>b1</code>, <code>a2</code>, and <code>b2</code>
have been already defined
</p>
<pre>
out &lt;- hitrun(alpha, a1, b1, a2, b2, nbatch = 1, blen = 1e5)
out &lt;- hitrun(out, nbatch = 100, blen = 1000)
</pre>
<p>throws away a run of 100 thousand iterations before doing another run of
100 thousand iterations that is actually useful for analysis, for example,
</p>
<pre>
apply(out$batch, 2, mean)
apply(out$batch, 2, sd)
</pre>
<p>gives estimates of posterior means and their MCSE assuming the batch length
(here 1000) was long enough to contain almost all of the signifcant
autocorrelation (see Geyer, 2011, Section 1.10, for more on MCSE).
The re-entrant property of the <code>hitrun</code> function (the second run starts
where the first one stops) assures that this is really &ldquo;burn-in&rdquo;.
</p>
<p>The re-entrant property allows one to do very long runs without having to
do them in one invocation of the <code>hitrun</code> function.
</p>
<pre>
out2 &lt;- hitrun(out)
out3 &lt;- hitrun(out2)
batch &lt;- rbind(out$batch, out2$batch, out3$batch)
</pre>
<p>produces a result as if the first run had been three times as long.
</p>


<h3>References</h3>

<p>Belisle, C. J. P., Romeijn, H. E. and Smith, R. L. (1993)
Hit-and-run algorithms for generating multivariate distributions.
<em>Mathematics of Operations Research</em>, <b>18</b>, 255&ndash;266.
<a href="https://doi.org/10.1287/moor.18.2.255">doi:10.1287/moor.18.2.255</a>.
</p>
<p>Chen, M. H. and Schmeiser, B. (1993)
Performance of the Gibbs, hit-and-run, and Metropolis samplers.
<em>Journal of Computational and Graphical Statistics</em>, <b>2</b>, 251&ndash;272.
</p>
<p>Geyer, C. J. (2011)
Introduction to MCMC.
In <em>Handbook of Markov Chain Monte Carlo</em>. Edited by S. P. Brooks,
A. E. Gelman, G. L. Jones, and X. L. Meng.
Chapman &amp; Hall/CRC, Boca Raton, FL, pp. 3&ndash;48.
</p>


<h3>See Also</h3>

<p><code><a href="rcdd.html#topic+ConvertGMP">ConvertGMP</a></code> and <code><a href="rcdd.html#topic+ArithmeticGMP">ArithmeticGMP</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'># Bayesian inference for discrete probability distribution on {1, ..., d}
# state is probability vector p of length d
d &lt;- 10
x &lt;- 1:d
# equality constraints
#     mean equal to (d + 1) / 2, that is, sum(x * p) = (d + 1) / 2
# inequality constraints
#     median less than or equal to (d + 1) / 2, that is,
#         sum(p[x &lt;= (d + 1) / 2]) &lt;= 1 / 2
a2 &lt;- rbind(x)
b2 &lt;- (d + 1) / 2
a1 &lt;- rbind(as.numeric(x &lt;= (d + 1) / 2))
b1 &lt;- 1 / 2
# simulate prior, which Dirichlet(alpha)
# posterior would be another Dirichlet with n + alpha - 1,
#    where n is count of IID data for each value
alpha &lt;- rep(2.3, d)
out &lt;- hitrun(alpha, nbatch = 30, blen = 250,
    a1 = a1, b1 = b1, a2 = a2, b2 = b2)
# prior means
round(colMeans(out$batch), 3)
# Monte Carlo standard errors
round(apply(out$batch, 2, sd) / sqrt(out$nbatch), 3)
</code></pre>

<hr>
<h2 id='polyap'>Polya Sampling from an Urn</h2><span id='topic+polyap'></span>

<h3>Description</h3>

<p>Consider an urn containing a finite set of values.
An item is selected at random from the urn.  Then it is returned
to the urn along with another item with the same value.  Next
a value is selected at random from the reconstituted urn
and it and a copy our returned to the urn.  This process is
repeated until <code class="reqn">k</code> additional items have been added to the
original urn.  The original composition of the urn along with the selected
values, in order, are returned.</p>


<h3>Usage</h3>

<pre><code class='language-R'>polyap(ysamp, k)</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="polyap_+3A_ysamp">ysamp</code></td>
<td>
<p>A vector of real numbers which make up the urn.</p>
</td></tr>
<tr><td><code id="polyap_+3A_k">k</code></td>
<td>
<p>A positive integer which specifies the number of items
added to the original composition of the urn.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The returned value is a vector of length equal to the length of
<code>ysamp</code> plus <code>k</code>.</p>


<h3>Examples</h3>

<pre><code class='language-R'>polyap(c(0,1),20)
</code></pre>

<hr>
<h2 id='wtpolyap'>Polya Sampling from an Urn with Possibly Unequal Weights</h2><span id='topic+wtpolyap'></span>

<h3>Description</h3>

<p>Consider an urn containing
a finite set of values along with their respective positive weights.
An item is selected at random from the urn with probability
proportional to its weight.  Then it is returned to the urn and its
weight is increased by one.  The process is repeated on the
adjusted urn.  We continue until the total weight in the urn has
been increased by <code class="reqn">k</code>.
The original composition of the urn along with the k selected
values, in order, are returned.</p>


<h3>Usage</h3>

<pre><code class='language-R'>wtpolyap(ysamp, wts, k)</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="wtpolyap_+3A_ysamp">ysamp</code></td>
<td>
<p>A vector of real numbers which make up the urn.</p>
</td></tr>
<tr><td><code id="wtpolyap_+3A_wts">wts</code></td>
<td>
<p>A vector of positive weights which defines the initial
probability of selection.</p>
</td></tr>
<tr><td><code id="wtpolyap_+3A_k">k</code></td>
<td>
<p>A positive integer which specifies the number of Polya
samples taken from the urn where after each draw the weight of the selected
item is increased by one.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The returned value is a vector of length equal to the length of
the sample plus <code class="reqn">k</code>.</p>


<h3>Examples</h3>

<pre><code class='language-R'>wtpolyap(c(0,1,2),c(0.5,1,1.5),22)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
