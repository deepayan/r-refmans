<!DOCTYPE html><html><head><title>Help for package psp</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {psp}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#psp_control'><p>Control the behaviour of the psp_global implementation</p></a></li>
<li><a href='#psp_global'><p>Parameter Space Partitioning</p></a></li>
<li><a href='#psp-package'>
<p>Parameter Space Partitioning MCMC for Global Model Evaluation</p>
</p></a></li>
<li><a href='#pspGlobal'><p>Parameter Space Partitioning</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Title:</td>
<td>Parameter Space Partitioning MCMC for Global Model Evaluation</td>
</tr>
<tr>
<td>Version:</td>
<td>1.0.0</td>
</tr>
<tr>
<td>Date:</td>
<td>2023-08-16</td>
</tr>
<tr>
<td>Description:</td>
<td>Implements an n-dimensional parameter space partitioning algorithm for evaluating the global behaviour of formal computational models as described by Pitt, Kim, Navarro and Myung (2006) &lt;<a href="https://doi.org/10.1037%2F0033-295X.113.1.57">doi:10.1037/0033-295X.113.1.57</a>&gt;.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL (&ge; 3)</a></td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/lenarddome/psp">https://github.com/lenarddome/psp</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/lenarddome/psp/issues">https://github.com/lenarddome/psp/issues</a></td>
</tr>
<tr>
<td>Imports:</td>
<td>Rcpp (&ge; 1.0.8.3), parallel, data.table, methods</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>Rcpp, RcppArmadillo</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>Suggests:</td>
<td>testthat (&ge; 3.0.0)</td>
</tr>
<tr>
<td>Config/testthat/edition:</td>
<td>3</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-08-16 15:57:04 UTC; lenard</td>
</tr>
<tr>
<td>Author:</td>
<td>Lenard Dome [aut, cre],
  Andy Wills [aut]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Lenard Dome &lt;lenarddome@gmail.com&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-08-16 16:42:05 UTC</td>
</tr>
</table>
<hr>
<h2 id='psp_control'>Control the behaviour of the psp_global implementation</h2><span id='topic+psp_control'></span>

<h3>Description</h3>

<p><code>psp_control</code> allows users to define characteristics of the
parameter space partitioning MCMC algorithm as implemented in
<code>psp_global</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>psp_control(radius = 0.1, init, lower, upper,
           pop = 400, cl = NULL,
           param_names = NULL,
           parallel = FALSE,
           cluster_names = NULL,
           export_objects = NULL,
           export_libs = NULL,
           iterations = 1000)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="psp_control_+3A_radius">radius</code></td>
<td>
<p>The radius of the hypershere with n-dimensions to sample from.
Must be a double or a numeric vector, where elements correspond to
parameters in 'init, lower, upper'. Default is 0.1.</p>
</td></tr>
<tr><td><code id="psp_control_+3A_init">init</code></td>
<td>
<p>A vector of parameters to use as the first jumping
distribution.</p>
</td></tr>
<tr><td><code id="psp_control_+3A_lower">lower</code>, <code id="psp_control_+3A_upper">upper</code></td>
<td>
<p>Vectors specifiying the lower and upper boundaries of
the parameter space for each parameter. The i-th element of lower and
upper bounds applies to the i-th parameter.</p>
</td></tr>
<tr><td><code id="psp_control_+3A_pop">pop</code></td>
<td>
<p>The minimum population psp_global aims to find for each ordinal
pattern discovered. This can stop the parameter search early in case
the population of all ordinal pattern are equal to or larger than
<code>pop</code>. If you do not want to use this option, set it to <code>NULL</code>
or <code>Inf</code>. Default is <code>400</code>.</p>
</td></tr>
<tr><td><code id="psp_control_+3A_parallel">parallel</code></td>
<td>
<p>If TRUE, uses the parallel package to run evaluations of
jumping distributions for each chain parallel. Default value is
<code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="psp_control_+3A_cl">cl</code></td>
<td>
<p>If parallel is TRUE, the number of cores to use for
<code>makeCluster</code> from the <span class="pkg">parallel</span> package. If null
(default), use all cores.</p>
</td></tr>
<tr><td><code id="psp_control_+3A_param_names">param_names</code></td>
<td>
<p>A character vector that includes the names of each
parameter. If <code>NULL</code> (default), a character vector is generated with
parameter_1, parameter_2, parameter_3, ...</p>
</td></tr>
<tr><td><code id="psp_control_+3A_cluster_names">cluster_names</code></td>
<td>
<p>Maintained for backwards-compatibility. See
<code>export_objects</code> below.</p>
</td></tr>
<tr><td><code id="psp_control_+3A_export_objects">export_objects</code></td>
<td>
<p>A character vector that includes all of the objects
to be loaded into each cluster. It is handled by
<code>parallel::clusterExports</code>. Default is <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="psp_control_+3A_export_libs">export_libs</code></td>
<td>
<p>A character vector that includes all the packages to
be loaded into each cluster. It is handled by
<code>parallel::clusterExports</code>. Default is <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="psp_control_+3A_iterations">iterations</code></td>
<td>
<p>The number of global iterations for psp_global. Default is
1000.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a control list suitable for <code>psp_global</code> with the above
elements.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># two parameter model
psp_control(lower = rep(0, 2), upper = rep(1, 2), init = rep(0.5, 2),
           radius = rep(0.25, 2), cluster_names = NULL,
           parallel = FALSE, iterations = 500)
</code></pre>

<hr>
<h2 id='psp_global'>Parameter Space Partitioning</h2><span id='topic+psp_global'></span>

<h3>Description</h3>

<p>An all-purpose implementation of the Parameter Space Partitioning MCMC
Algorithm described by Pitt, Kim, Navarro, Myung (2006).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>psp_global(fn, control = psp_control(), ..., quiet = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="psp_global_+3A_fn">fn</code></td>
<td>
<p>The ordinal function. It should take a numeric vector (parameter set)
as its argument, and return an ordinal response pattern as character (e.g.
&quot;A &gt; B&quot;). NA values are not currently allowed.</p>
</td></tr>
<tr><td><code id="psp_global_+3A_control">control</code></td>
<td>
<p>a list of control parameters, see <code>psp_control</code></p>
</td></tr>
<tr><td><code id="psp_global_+3A_...">...</code></td>
<td>
<p>Additional arguments passed to <code>fn</code>.</p>
</td></tr>
<tr><td><code id="psp_global_+3A_quiet">quiet</code></td>
<td>
<p>If <code>FALSE</code> (default), print the total number of patterns
found up to the current iteration. If <code>TRUE</code>, do not print anything.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function implements the Parameter Space Partitioning algorithm
desribed by Pitt et al. (2006). The algorithm is as follows:
</p>
<p>0. Initialize parameter space.
</p>
<p>0. Select first set of parameters, and evaluate the model on this set. Its
ordinal output will become the first ordinal pattern and the first region
in the parameter space.
</p>
<p>1. Pick a random jumping distribution from for each ordinal pattern from the
sampling region defined by a hypershere with a center of the last recorded
parameter set for a given pattern.
</p>
<p>2. Evaluate model on all new parameter sets.
</p>
<p>3. Record new patterns and their corresponding parameter sets. If the
parameter sets returns an already discovered pattern, add parameter set
to their records. Return to Step 1.
</p>
<p>This process runs can run in parallel for each discovered pattern.
</p>


<h3>Value</h3>

<p>The output of function <code>psp</code> is a member of the <code>S3</code> class
of <code>PSP</code>. A <code>PSP</code> object is a list with the following items:
</p>
<table>
<tr><td><code>ps_partitions</code></td>
<td>
<p>A <code>data.table</code> containing coordinates from the
parameter space and their corresponding ordinal response pattern output by
<code>fn</code>. Columns include (in this order): parameter coordinates,
their ordinal pattern output by <code>fn</code>, the global iteration of the
MCMC. Each row corresponds with the evaluation of a single set of
parameters.</p>
</td></tr>
<tr><td><code>ps_patterns</code></td>
<td>
<p>A table with the ordinal patterns discovered and the
population of their corresponding region - the number of parameter sets
discovered to produce the ordinal pattern.</p>
</td></tr>
<tr><td><code>ps_ordinal</code></td>
<td>
<p>A list (if ordinal patterns are multidimensional objects)
or character vector (if ordinal patterns are strings or other single values)
with the ordinal patterns found. The place of the ordinal pattern
corresponds to the names in ps_patterns.</p>
</td></tr>
</table>


<h3>References</h3>

<p>Pitt, M. A., Kim, W., Navarro, D. J., &amp; Myung, J. I. (2006). Global model analysis by parameter space partitioning. Psychological Review, 113(1), 57.
</p>
<p>Weisstein, Eric W. &quot;Hypersphere Point Picking.&quot; From MathWorld&ndash;A Wolfram Web Resource. https://mathworld.wolfram.com/HyperspherePointPicking.html
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
library(psp)

#' euclidean distance
#'
#' @param a vector coordinate 1
#' @param b vector coordinate 2
#' @return euclidean distance between coordinates
euclidean &lt;- function(a, b) sqrt(sum((a - b)^2))

# define center points for the 10 regions in a two-dimensional space
positions &lt;- NULL
for (i in seq_len(2)) positions &lt;- cbind(positions, sample(500, 10))

#' dummy hypercube model to test the PSP function
#' The model takes in a set of coordinates, calculates its distance from all
#' all of available coordinates, then return closest region number.
#' This model generalizes to n-dimensions
#'
#' @param x a vector of coordinates
#' @return The number of the region as character
#' @examples
#' model(runif(5))
model &lt;- function(par) {
    areas &lt;- NULL
    for (i in seq_along(par)) {
        range &lt;- c(1, 0)
        if (i %% 2 == 0) {
            range &lt;- c(0, 1)
        }
        areas &lt;- cbind(areas,
                       seq(range[1], range[2], length.out = 500)[positions[,i]])
    }
    dist &lt;- apply(areas, 1, function(x) euclidean(par, x))
    return(as.character(which.min(dist)))
}

# run Parameter Space Partitioning with some default settings
# Here we run the MCMC for 400 iterations, but the partitioning
# will stop if the population of all regions reach 200.
# Note that we have to load our utility function into
# the clusters, because PSPglobal is currently parallelized.
out &lt;- psp_global(model, psp_control(lower = rep(0, 2),
                                   upper = rep(1, 2),
                                   init = rep(0.5, 2),
                                   radius = rep(0.25, 2),
                                   pop = 100,
                                   parallel = FALSE,
                                   iterations = 100))

print(out)

</code></pre>

<hr>
<h2 id='psp-package'>
Parameter Space Partitioning MCMC for Global Model Evaluation
</h2><span id='topic+psp'></span>

<h3>Description</h3>

<p>Implements an n-dimensional parameter space partitioning algorithm for evaluating
the global behaviour of formal computational models as described by Pitt, Kim,
Navarro and Myung (2006) &lt;doi:10.1037/0033-295X.113.1.57&gt;.
</p>
<p>Please cite the package in publications. Use <code>citation("psp")</code>.
</p>


<h3>Author(s)</h3>

<p>Lenard Dome
</p>
<p>Maintainer: Lenard Dome <a href="mailto:lenarddome@gmail.com">lenarddome@gmail.com</a>
</p>


<h3>References</h3>

<p>Pitt, M. A., Kim, W., Navarro, D. J., &amp; Myung, J. I. (2006). Global model analysis by parameter space partitioning. Psychological Review, 113(1), 57.
</p>

<hr>
<h2 id='pspGlobal'>Parameter Space Partitioning</h2><span id='topic+pspGlobal'></span>

<h3>Description</h3>

<p>An all-purpose C++ implementation of the Parameter Space Partitioning MCMC
Algorithm described by Pitt, Kim, Navarro, Myung (2006).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pspGlobal(model, discretize, control, save = FALSE, path = ".",
          extension = ".csv", quiet = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pspGlobal_+3A_model">model</code></td>
<td>
<p> It should take a numeric vector (parameter set)
as its argument, and return a numeric vector of continuous variables.</p>
</td></tr>
<tr><td><code id="pspGlobal_+3A_discretize">discretize</code></td>
<td>
<p>The inequality matrix constructor. It should take a numberic
vector of probabilities. It must return a matrix in a <code>matrix</code> format
with 'type=double'. NA values are note allowed, see Note 1.</p>
</td></tr>
<tr><td><code id="pspGlobal_+3A_control">control</code></td>
<td>
<p>A <code>list()</code> of control arguments that tunes the behaviour
of the parameter space partitioning routine. See Details for more information
on what to include.</p>
</td></tr>
<tr><td><code id="pspGlobal_+3A_save">save</code></td>
<td>
<p>if <code>save = TRUE</code>, all evaluated parameters will be saved to
disk. The deafult is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="pspGlobal_+3A_path">path</code></td>
<td>
<p>If 'save = TRUE', the path to the file that will store all
evaluated parameters and continuous model outputs. The default path is the
current working directory. Evaluated parameters and continuous model outputs
are save separately, see Details.</p>
</td></tr>
<tr><td><code id="pspGlobal_+3A_extension">extension</code></td>
<td>
<p>If 'save = TRUE', the extension of the file that will store
all evaluated parameters and continuous model outputs. The default extension
is <code>.csv</code>.</p>
</td></tr>
<tr><td><code id="pspGlobal_+3A_quiet">quiet</code></td>
<td>
<p>If <code>FALSE</code> (default), print the number of the current
iteration. If <code>TRUE</code>, do not print anything.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><b>Overview:</b>
</p>
<p>This function implements the Parameter Space Partitioning algorithm
desribed by Pitt et al. (2006). The brief overview of the algorithm is as follows:
</p>
<p>0. Initialize parameter space.
</p>
<p>0. Select first set of parameters, and evaluate the model on this set. Its
ordinal output will become the first ordinal pattern and the first region
in the parameter space.
</p>
<p>1. Pick a random jumping distribution from for each ordinal pattern from the
sampling region defined by a hypershere with a center of the last recorded
parameter set for a given pattern. Clamp parameter values with their
respective lower and upper bounds.
</p>
<p>2. Evaluate model on all new parameter sets.
</p>
<p>3. Record new patterns and their corresponding parameter sets. If the
parameter sets returns an already discovered pattern, add parameter set
to their records. Return to Step 1.
</p>
<p><b>Tuning the behaviour of the algorithm via <code>control</code>:</b>
</p>
<p>This behaviour is further tuned by 'control', which needs to contain a list of the following values:
</p>
<p><code>population</code>The number of parameter sets in each ordinal region,
which serves as a threshold above which pspGlobal will not generate
a new jumping distribution for a given ordinal pattern.
<code>iterations</code>The number of global iterations. It has to be an integer. If emphpopulation is not set or the regions have population less then the upper bound on their size, the function will stop after the set number of <em>iterations</em>.
<code>lower, upper</code>Vectors specifiying the lower and upper boundaries of
the parameter space for each parameter. The i-th element of lower and
upper bounds applies to the i-th parameter.
<code>init</code>A marix of parameters to use as the first jumping distribution. 
Each row contains the parameter set, whereas columns correspond to 
freely varying paarameters of the model.
<code>radius</code>The radius of the hypershere with n-dimensions to sample from.
Must be of type double. If you are unsure what to set here, set it to 1.
<code>parameter_names</code>A character vector that includes the names of each parameter.
The order of elements should correspond to the order of parameter columns in
init.
<code>dimensionality</code>A single integer that specifies the number of
dimensions for the inequality matrix. The inequality matrix is a strict
upper triangular matrix. The number of rows and columns is equal to each
other.
<code>responses</code>It is an integer that specifies the number of continuous
variables the model output before the ordinal function is applied. See Note 2.
</p>
<p><strong>Saving files to disk:</strong>
</p>
<p>The evaluated parameter sets and their corresponding continuous model outputs
are saved to disk if <code>save = TRUE</code>. The evaluated parameter sets are saved in
a file with the name <code>path_parameters</code> and the extension specified,
whereas continuous model outputs are saved in a file with the name <code>path_continuous</code>
and the extension specified.
</p>


<h3>Value</h3>

<p>The output is a list with the following items:
</p>
<table>
<tr><td><code>ordinal_patterns</code></td>
<td>
<p>A 3D array with the ordinal patterns found.
The place of the ordinal pattern corresponds to ordinal_counts.</p>
</td></tr>
<tr><td><code>ordinal_counts</code></td>
<td>
<p>A table with the ordinal patterns discovered and the
population of their corresponding region - the number of parameter sets
discovered to produce the ordinal pattern.</p>
</td></tr>
<tr><td><code>iterations</code></td>
<td>
<p>Number of iterations completed before reaching set
threshold.</p>
</td></tr>
</table>


<h3>Note</h3>

<p>1. NA values are usually a result of some parameter combination falling outside of what the model implementation can handle. It is best handled outside of the PSP routine, e.g. during the inequality matrix construction. For example, if NA is detected in the matrix, change all values to 99 before returning the output.
2. Ideally, responses and dimensionality should be the same, but we can imagine a scenario where the dimensionality of the inequality matrix will be smaller than the number of responses. For example, when continuous variables compressed into a more compact format via clustering. 
</p>


<h3>References</h3>

<p>Dome, L. (n.d.) psp: an n-dimensional parameter space partitioning tool to explore model behaviour. <em>Manuscript in preparation</em>.
</p>
<p>Dome, L., Wills, A. J. (n.d.) g-distance: Prediction, accommodation, and <em>a priori</em> likelihood in formal psychological theorizing. <em>Manuscript in preparation</em>.
</p>
<p>Pitt, M. A., Kim, W., Navarro, D. J., &amp; Myung, J. I. (2006). Global model analysis by parameter space partitioning. Psychological Review, 113(1), 57.
</p>
<p>Weisstein, Eric W. &quot;Hypersphere Point Picking.&quot; From MathWorld&ndash;A Wolfram Web Resource. https://mathworld.wolfram.com/HyperspherePointPicking.html
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
