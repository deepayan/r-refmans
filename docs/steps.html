<!DOCTYPE html><html><head><title>Help for package steps</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {steps}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#ceiling_density'><p>Ceiling-based density dependence</p></a></li>
<li><a href='#cellular_automata_dispersal'><p>Cellular automata dispersal</p></a></li>
<li><a href='#compare_emp'><p>Compare minimum expected populations</p></a></li>
<li><a href='#competition_density'><p>Competition density function</p></a></li>
<li><a href='#density_dependence_dispersing'><p>Density-dependent proportions of populations dispersing</p></a></li>
<li><a href='#dispersal_kernel'><p>Create a dispersal function</p></a></li>
<li><a href='#dispersal_proportion_function'><p>Create a proportion dispersing function</p></a></li>
<li><a href='#disturbance'><p>Disturbance</p></a></li>
<li><a href='#egk'><p>Eastern Grey Kangaroo example data</p></a></li>
<li><a href='#exponential_dispersal_kernel'><p>Negative exponential dispersal kernel</p></a></li>
<li><a href='#extract_spatial'><p>Extract spatial object from a 'simulation_results' object</p></a></li>
<li><a href='#fast_dispersal'><p>Fast diffusion-based dispersal</p></a></li>
<li><a href='#fire_effects'><p>Fire effects with regeneration</p></a></li>
<li><a href='#growth'><p>Population growth</p></a></li>
<li><a href='#habitat_dynamics_functions'><p>Functions to modify the habitat in a landscape object.</p></a></li>
<li><a href='#kernel_dispersal'><p>Kernel-based dispersal</p></a></li>
<li><a href='#landscape'><p>Create a landscape object.</p></a></li>
<li><a href='#modified_transition'><p>Spatially-explicit transition function</p></a></li>
<li><a href='#mortality'><p>Directly affect populations</p></a></li>
<li><a href='#plot_hab_spatial'><p>Plot habitat suitability spatial information</p></a></li>
<li><a href='#plot_k_spatial'><p>Plot carrying capacity spatial information</p></a></li>
<li><a href='#plot_k_trend'><p>Plot carrying capacity (k) trend</p></a></li>
<li><a href='#plot_pop_spatial'><p>Plot population spatial information</p></a></li>
<li><a href='#plot_pop_trend'><p>Plot population trend</p></a></li>
<li><a href='#plot.simulation_results'><p>Plot the results of a simulation</p></a></li>
<li><a href='#population_change_functions'><p>How the population changes in a landscape.</p></a></li>
<li><a href='#population_density_dependence_functions'><p>How the population responds to density dependence in a landscape.</p></a></li>
<li><a href='#population_dispersal_functions'><p>How the population disperses in a landscape.</p></a></li>
<li><a href='#population_dynamics'><p>Define population dynamics.</p></a></li>
<li><a href='#population_modification_functions'><p>How the population is modified in a landscape.</p></a></li>
<li><a href='#set_proportion_dispersing'><p>Set proportions of populations dispersing</p></a></li>
<li><a href='#simulation'><p>Run a simulation</p></a></li>
<li><a href='#steps'><p>Simulate population trajectories over space and time with dynamic functions.</p></a></li>
<li><a href='#transition_function'><p>Create a growth transition function</p></a></li>
<li><a href='#translocation'><p>Translocate populations</p></a></li>
<li><a href='#visualisation'><p>Visualise the results of a *steps* simulation</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Spatially- and Temporally-Explicit Population Simulator</td>
</tr>
<tr>
<td>Version:</td>
<td>1.3.0</td>
</tr>
<tr>
<td>Date:</td>
<td>2022-10-03</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Casey Visintin &lt;casey.visintin@unimelb.edu.au&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Software to simulate population change across space and time. Visintin et al. (2020) &lt;<a href="https://doi.org/10.1111%2F2041-210X.13354">doi:10.1111/2041-210X.13354</a>&gt;.</td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/steps-dev/steps/issues">https://github.com/steps-dev/steps/issues</a></td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/steps-dev/steps">https://github.com/steps-dev/steps</a></td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.4.0)</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>Imports:</td>
<td>Rcpp, raster, future, future.apply, rasterVis, viridisLite,
memuse</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>Rcpp</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.1</td>
</tr>
<tr>
<td>Suggests:</td>
<td>testthat, fields, knitr, rmarkdown, foreach</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr, rmarkdown</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2022-10-04 21:50:04 UTC; casey</td>
</tr>
<tr>
<td>Author:</td>
<td>Casey Visintin <a href="https://orcid.org/0000-0003-2245-8998"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cre],
  Nick Golding [ctb],
  Skipton Woolley [ctb]</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2022-10-04 23:30:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='ceiling_density'>Ceiling-based density dependence</h2><span id='topic+ceiling_density'></span>

<h3>Description</h3>

<p>In-built density dependence function that constrains the number of individuals in a cell
based on the carrying capacity of that cell in a timestep. Note, carrying_capacity must
be provided in the landscape object to use this function (see <a href="#topic+landscape">landscape</a>).
Only specified stages that contribute to density dependence are considered in the
calculations and excess individuals are removed from only the contributing stages. This
type of density dependence only affects the population once it reaches the carrying
capacity. While population size is below carrying capacity, the population grows according
to the transition matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ceiling_density(stages = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ceiling_density_+3A_stages">stages</code></td>
<td>
<p>which life-stages contribute to density dependence and are removed in a timestep
- default is all</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>
# Cap the population at carrying capacity with only the second and third
# life stage used in calculations to determine density dependence. 

## Not run: 
cap_population &lt;- ceiling_density(stages = c(2, 3))

ls &lt;- landscape(population = egk_pop, suitability = egk_hab, carrying_capacity = egk_k)

pd &lt;- population_dynamics(change = growth(egk_mat), density_dependence = cap_population)

simulation(landscape = ls, population_dynamics = pd, habitat_dynamics = NULL, timesteps = 20)

## End(Not run)
</code></pre>

<hr>
<h2 id='cellular_automata_dispersal'>Cellular automata dispersal</h2><span id='topic+cellular_automata_dispersal'></span>

<h3>Description</h3>

<p>The cellular_automata_dispersal function simulates movements of
individuals using rule-based cell movements. In each cell that has
population, every individual up to a specified proportion of the
total population attempts to move. For each step from a specified minimum up
to a specified maximum number of movements, a weighted draw of four
directions, based on habitat suitability, is made and then the destination
cell is checked for available carrying capacity. If there is carrying capacity
available, the individual moves to the cell, if not, it remains in its current
cell. This is repeated until the maximum number of cell movements is reached.
If no cell is found with available carrying capacity, the individual remains
in the source cell.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cellular_automata_dispersal(
  max_cells = Inf,
  min_cells = max_cells,
  dispersal_proportion = set_proportion_dispersing(),
  barriers = NULL,
  use_suitability = TRUE,
  carrying_capacity = "carrying_capacity"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cellular_automata_dispersal_+3A_max_cells">max_cells</code></td>
<td>
<p>the maximum number of cell movements that each individual in
each life stage can disperse in whole integers.</p>
</td></tr>
<tr><td><code id="cellular_automata_dispersal_+3A_min_cells">min_cells</code></td>
<td>
<p>the minimum number of cell movements that each individual in
each life stage will disperse in whole integers.</p>
</td></tr>
<tr><td><code id="cellular_automata_dispersal_+3A_dispersal_proportion">dispersal_proportion</code></td>
<td>
<p>a built-in or custom function defining the proportions
of individuals that can disperse in each life stage.</p>
</td></tr>
<tr><td><code id="cellular_automata_dispersal_+3A_barriers">barriers</code></td>
<td>
<p>the name of a spatial layer in the landscape object that
contains cell values between 0 (no barrier) and 1 (full barrier) Any
values between 0 and 1 indicate the permeability of the barrier.</p>
</td></tr>
<tr><td><code id="cellular_automata_dispersal_+3A_use_suitability">use_suitability</code></td>
<td>
<p>should habitat suitability be used to control the
likelihood of individuals dispersing into cells? The default is TRUE. Note,
if a barrier map is also provided, the suitability map is multiplied with
the barrier map to generate a permeability map of the landscape.</p>
</td></tr>
<tr><td><code id="cellular_automata_dispersal_+3A_carrying_capacity">carrying_capacity</code></td>
<td>
<p>the name of a spatial layer in the landscape object
that specifies the carrying capacity in each cell.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function allows the use of barriers in the landscape to influence
dispersal. The function is computationally efficient, however, because
as individuals are dispersed, performance scales with the population sizes
in each cell across a landscape and the maximum number of cell movements.
</p>
<p>The maximum number of cell movements in cellular automata dispersal does not
correspond exactly to the distance decay of a dispersal kernel, since cellular
automata dispersal depends on the permeability of the landscape, and is
interrupted on reaching a cell with available capacity (above the minimum
specified number of cell movements). A heuristic that can be used to determine
a reasonable number of steps from a mean dispersal distance 'd' and cell
resolution 'res' is: 'max_cells = round(2 * (d / (res * 1.25)) ^ 2)'. This
corresponds approximately to the number of cell-steps in an infinite,
homogenous landscape with no early stopping, for which d is the mean
end-to-end dispersal distance of all individuals.
</p>
<p>Rather than relying on this value, we recommend that the user experiment with
the <code>max_cells</code> and <code>min_cells</code> parameters to find a value such that
the the mean dispersal distance in a reasonably realistic simulation
corresponds with field estimates of mean dispersal distances.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Example of cellular automata dispersal where the 2nd and 3rd life stages
# disperse up to a maximum of 100 cells but dispersal is affected by
# barriers (in this case roads). The road rasters have values of 0 for
# large roads (no dispersal across barrier) and 0.5 for smaller roads
# (reduced dispersal across barrier).

## Not run: 
ca_dispersal &lt;- cellular_automata_dispersal(max_cells = c(0, 100, 100), barriers = "roads")

ls &lt;- landscape(population = egk_pop,
                suitability = egk_hab,
                carrying_capacity = egk_k,
                "roads" = egk_road)

pd &lt;- population_dynamics(change = growth(egk_mat),
                          dispersal = ca_dispersal,
                          density_dependence = ceiling_density())

simulation(landscape = ls, population_dynamics = pd, habitat_dynamics = NULL, timesteps = 20)

## End(Not run)
</code></pre>

<hr>
<h2 id='compare_emp'>Compare minimum expected populations</h2><span id='topic+compare_emp'></span>

<h3>Description</h3>

<p>Compare minimum expected populations from two or more 'simulation_results' objects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>compare_emp(
  x,
  ...,
  show_interval = TRUE,
  interval = 95,
  all_points = FALSE,
  simulation_names = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="compare_emp_+3A_x">x</code></td>
<td>
<p>a simulation_results object</p>
</td></tr>
<tr><td><code id="compare_emp_+3A_...">...</code></td>
<td>
<p>additional simulation results objects</p>
</td></tr>
<tr><td><code id="compare_emp_+3A_show_interval">show_interval</code></td>
<td>
<p>should the interval bars be shown on the plot? Default is TRUE.</p>
</td></tr>
<tr><td><code id="compare_emp_+3A_interval">interval</code></td>
<td>
<p>the desired confidence interval representing the uncertainty around
the expected minimum population estimates from simulation comparisons; expressed as 
a whole integer between 0 and 100 (default value is 95).</p>
</td></tr>
<tr><td><code id="compare_emp_+3A_all_points">all_points</code></td>
<td>
<p>should the expected minimum populations from all simulation
replicates be shown on the plot? Default is FALSE.</p>
</td></tr>
<tr><td><code id="compare_emp_+3A_simulation_names">simulation_names</code></td>
<td>
<p>an optional character vector of simulation names to override
the defaults</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>
## Not run: 
ls &lt;- landscape(population = egk_pop, suitability = egk_hab, carrying_capacity = egk_k)

# Create populations dynamics with and without ceiling density dependence
pd1 &lt;- population_dynamics(change = growth(egk_mat),
                           dispersal = kernel_dispersal(max_distance = 1000,
                           dispersal_kernel = exponential_dispersal_kernel(distance_decay = 500)),
                           density_dependence = ceiling_density())
pd2 &lt;- population_dynamics(change = growth(egk_mat),
                           dispersal = kernel_dispersal(max_distance = 3000,
                           dispersal_kernel = exponential_dispersal_kernel(distance_decay = 1500)))

# Run first simulation with ceiling density dependence and three replicates
sim1 &lt;- simulation(landscape = ls,
                   population_dynamics = pd1,
                   habitat_dynamics = NULL,
                   timesteps = 20,
                   replicates = 3)
                   
# Run second simulation without ceiling density dependence and three replicates
sim2 &lt;- simulation(landscape = ls,
                   population_dynamics = pd2,
                   habitat_dynamics = NULL,
                   timesteps = 20,
                   replicates = 3)

compare_emp(sim1, sim2)

## End(Not run)
</code></pre>

<hr>
<h2 id='competition_density'>Competition density function</h2><span id='topic+competition_density'></span>

<h3>Description</h3>

<p>Adjusts the life-stage transition matrix in each cell based on the carrying capacity in the cell and
a density dependence function - default is Beverton-Holt. The user may specify which life-stages are 
affected by density dependence. If <code>R_max</code> is not provided this is calculated from the local cell-based
transition matrices internally. By providing initial stable age distribution values, performance can be
increased as the function internally calculates these values through optimisation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>competition_density(
  stages = NULL,
  mask = NULL,
  R_max = NULL,
  stable_age = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="competition_density_+3A_stages">stages</code></td>
<td>
<p>which life-stages contribute to density dependence - default is all</p>
</td></tr>
<tr><td><code id="competition_density_+3A_mask">mask</code></td>
<td>
<p>a matrix of boolean values (TRUE/FALSE), equal in dimensions to the life-stage transition matrix
and specifying which vital rates (i.e. survival and fecundity) are to be modified by the function</p>
</td></tr>
<tr><td><code id="competition_density_+3A_r_max">R_max</code></td>
<td>
<p>optional value of maximum growth rate (lambda) if known</p>
</td></tr>
<tr><td><code id="competition_density_+3A_stable_age">stable_age</code></td>
<td>
<p>optional vector of stable age distributions if known</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>
# Vital rates (survival and fecundity) modified based on approach to carrying capacity
# by the 2nd and 3rd life stages.

## Not run: 
mod_fun &lt;- competition_density(stages = c(2, 3))

ls &lt;- landscape(population = egk_pop, suitability = NULL, carrying_capacity = egk_k)

pd &lt;- population_dynamics(change = growth(egk_mat, transition_function = mod_fun))

simulation(landscape = ls, population_dynamics = pd, habitat_dynamics = NULL, timesteps = 20)

## End(Not run)
</code></pre>

<hr>
<h2 id='density_dependence_dispersing'>Density-dependent proportions of populations dispersing</h2><span id='topic+density_dependence_dispersing'></span>

<h3>Description</h3>

<p>The proportion of populations dispersing will be density dependent in a simulation. Proportions
of populations in each life stage dispersing is adjusted based on available carrying capacity.
If life-stages are set by the <a href="#topic+population_density_dependence_functions">population_density_dependence_functions</a>, these
will be used to determine how close the population is to carrying capacity. If no
life-stages are set or density dependence is set to NULL in <a href="#topic+population_dynamics">population_dynamics</a>,
the function will consider all life-stages in the calculation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>density_dependence_dispersing(maximum_proportions = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="density_dependence_dispersing_+3A_maximum_proportions">maximum_proportions</code></td>
<td>
<p>A single value or vector of the maximum proportions (between zero
and one) of individuals in each life stage that disperse - default is 1. If maximum
proportions are specified as a single number, then all life-stages use that value, however,
a vector of maximum proportions (equal in length to the number of life-stages) can also be
specified. Maximum proportions are multiplied by the calculated proportions based on carrying
capacity so to prevent stages from dispersing, set corresponding values to zero.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <code>dispersal_proportion_function</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Example of a proportion function that disperses all populations based on their approach
# to carrying capacity

## Not run: 
prop_dispersal &lt;- density_dependence_dispersing()

kb_dispersal &lt;- kernel_dispersal(dispersal_proportion = prop_dispersal,
                      max_distance = 2000,
                      dispersal_kernel = exponential_dispersal_kernel(distance_decay = 1000))

ls &lt;- landscape(population = egk_pop, suitability = egk_hab, carrying_capacity = egk_k)

pd &lt;- population_dynamics(change = growth(egk_mat), dispersal = kb_dispersal)

simulation(landscape = ls, population_dynamics = pd, habitat_dynamics = NULL, timesteps = 20)

## End(Not run)
</code></pre>

<hr>
<h2 id='dispersal_kernel'>Create a dispersal function</h2><span id='topic+dispersal_kernel'></span>

<h3>Description</h3>

<p>A dispersal kernel function is a mathematical representation of how species redistribute
across the landscape.
</p>
<p>A common dispersal kernel is provided in the software for the user to select, however,
a user may also provide a custom written dispersal kernel.
</p>


<h3>See Also</h3>


<ul>
<li><p><a href="#topic+exponential_dispersal_kernel">exponential_dispersal_kernel</a>) for a (negative) exponential dispersal
kernel
</p>
</li></ul>


<hr>
<h2 id='dispersal_proportion_function'>Create a proportion dispersing function</h2><span id='topic+dispersal_proportion_function'></span>

<h3>Description</h3>

<p>A proportion dispersing function generates the proportions of species
that disperse from cells based on landscape features.
</p>


<h3>Details</h3>

<p>The default <code>set_proportion_dispersing</code> function and parameters returns
full dispersal for all life stages. Additional proportion dispersing functions
are provided in the software for the user to select, however, a user may also
provide a custom written proportion dispersing function. Please see the tutorial
vignette titled &quot;Creating custom *steps* functions&quot; for information on how to
write custom functions for use in simulations.
</p>


<h3>See Also</h3>


<ul>
<li><p><a href="#topic+set_proportion_dispersing">set_proportion_dispersing</a> controls the proportions of each life-stage that disperse
</p>
</li>
<li><p><a href="#topic+density_dependence_dispersing">density_dependence_dispersing</a> proportions of dispersing populations are controlled by
approach to carrying capacity
</p>
</li></ul>


<hr>
<h2 id='disturbance'>Disturbance</h2><span id='topic+disturbance'></span>

<h3>Description</h3>

<p>Modifies the landscape by multiplying habitat suitability values by a sum of previous
disturbances. Since disturbances can act in a single timestep, or have lasting effects,
the user can specify an 'effect time' of disturbances.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>disturbance(disturbance_layers, effect_time = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="disturbance_+3A_disturbance_layers">disturbance_layers</code></td>
<td>
<p>the name of spatial layer(s) in the landscape object with disturbances used
to alter the habitat object for each timestep (number of layers must match the intended timesteps)</p>
</td></tr>
<tr><td><code id="disturbance_+3A_effect_time">effect_time</code></td>
<td>
<p>the number of timesteps that the disturbance layer will act on the habitat object
(e.g. '3' will combine the effects of previous two timesteps to increase the overall effect) - the
default is 1.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>
# Road building (stored in the landscape object and called "roads") acts on the landscape
# each year.

## Not run: 
road_effect &lt;- disturbance(disturbance_layers = "roads", effect_time = 1)

ls &lt;- landscape(population = egk_pop, suitability = egk_hab, "roads" = egk_road)

pd &lt;- population_dynamics(change = growth(egk_mat))

sim &lt;- simulation(landscape = ls,
           population_dynamics = pd,
           habitat_dynamics = list(road_effect),
           timesteps = 20)
           
plot(sim, object = "suitability", type = "raster", timesteps = 1:9)

## End(Not run)
</code></pre>

<hr>
<h2 id='egk'>Eastern Grey Kangaroo example data</h2><span id='topic+egk'></span><span id='topic+egk_hab'></span><span id='topic+egk_pop'></span><span id='topic+egk_k'></span><span id='topic+egk_mat'></span><span id='topic+egk_mat_stoch'></span><span id='topic+egk_sf'></span><span id='topic+egk_fire'></span><span id='topic+egk_origins'></span><span id='topic+egk_destinations'></span><span id='topic+egk_road'></span>

<h3>Description</h3>

<p>Example data for simulating spatial population dynamics of Eastern Grey
Kangaroos in a hypothetical landscape.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>egk_hab

egk_pop

egk_k

egk_mat

egk_mat_stoch

egk_sf

egk_fire

egk_origins

egk_destinations

egk_road
</code></pre>


<h3>Format</h3>

<p>Misc data
</p>
<p>An object of class <code>RasterStack</code> of dimension 35 x 36 x 3.
</p>
<p>An object of class <code>RasterLayer</code> of dimension 35 x 36 x 1.
</p>
<p>An object of class <code>matrix</code> (inherits from <code>array</code>) with 3 rows and 3 columns.
</p>
<p>An object of class <code>matrix</code> (inherits from <code>array</code>) with 3 rows and 3 columns.
</p>
<p>An object of class <code>RasterStack</code> of dimension 35 x 36 x 120.
</p>
<p>An object of class <code>RasterBrick</code> of dimension 35 x 36 x 20.
</p>
<p>An object of class <code>RasterLayer</code> of dimension 35 x 36 x 1.
</p>
<p>An object of class <code>RasterLayer</code> of dimension 35 x 36 x 1.
</p>
<p>An object of class <code>RasterBrick</code> of dimension 35 x 36 x 20.
</p>


<h3>Details</h3>


<dl>
<dt>egk_hab</dt><dd><p>A raster layer containing the predicted relative habitat
suitability for the Eastern Grey Kangaroo.</p>
</dd>
<dt>egk_pop</dt><dd><p>A raster stack containing initial populations for each
life-stage of the Eastern Grey Kangaroo.</p>
</dd>
<dt>egk_k</dt><dd><p>A raster layer containing the total number of Eastern Grey
Kangaroos each grid cell can support.</p>
</dd>
<dt>egk_mat</dt><dd><p>A matrix containing the survival and fecundity of Eastern
Grey Kangaroos at each of three life-stages - juvenile, subadult, and adult.</p>
</dd>
<dt>egk_mat_stoch</dt><dd><p>A matrix containing the uncertainty around survival
and fecundity of Eastern Grey Kangaroos at each of three life-stages -
juvenile, subadult, and adult.</p>
</dd>
<dt>egk_sf</dt><dd><p>A raster stack containing values for modifying survival and
fecundities - each is raster is named according to the timestep and position
of the life-stage matrix to be modified.</p>
</dd>
<dt>egk_fire</dt><dd><p>A raster stack containing values for modifying the habitat
- in this case the proportion of landscape remaining after fire.</p>
</dd>
<dt>egk_origins</dt><dd><p>A raster stack containing locations and counts of where
to move individual kangaroos from.</p>
</dd>
<dt>egk_destinations</dt><dd><p>A raster stack containing locations and counts of where to
move individual kangaroos to.</p>
</dd>
<dt>egk_road</dt><dd><p>A raster stack containing values for modifying the habitat
- in this case the proportion of habitat remaining after the construction of a road.</p>
</dd>
</dl>


<hr>
<h2 id='exponential_dispersal_kernel'>Negative exponential dispersal kernel</h2><span id='topic+exponential_dispersal_kernel'></span>

<h3>Description</h3>

<p>This function determines the proportion of redistribution based on distance.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>exponential_dispersal_kernel(distance_decay = 0.5, normalize = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="exponential_dispersal_kernel_+3A_distance_decay">distance_decay</code></td>
<td>
<p>(exponential dispersal parameter) controls the rate at which the population disperses with distance</p>
</td></tr>
<tr><td><code id="exponential_dispersal_kernel_+3A_normalize">normalize</code></td>
<td>
<p>(exponential dispersal parameter) should the normalising constant be used - default is FALSE.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <code>dispersal_function</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Not run: 
dists &lt;- seq(0, 100, 1)

exp_dispersal_fun &lt;- exponential_dispersal_kernel(distance_decay = 50)

plot(dists, exp_dispersal_fun(dists), type = 'l')

## End(Not run)
</code></pre>

<hr>
<h2 id='extract_spatial'>Extract spatial object from a 'simulation_results' object</h2><span id='topic+extract_spatial'></span>

<h3>Description</h3>

<p>The simulation results object is a list of lists containing spatial (and other) objects and
is organised by the following tree diagram:
</p>

<ul>
<li><p>Replicate
</p>

<ul>
<li><p>Timestep
</p>

<ul>
<li><p>Population Raster Stack
</p>

<ul>
<li><p>Life-Stage Raster
</p>
</li></ul>

</li>
<li><p>Habitat Suitability Raster (or Stack)
</p>

<ul>
<li><p>Habitat Raster (if stack is used)
</p>
</li></ul>

</li>
<li><p>Carrying Capacity Raster
</p>
</li>
<li><p>Other Raster Stack
</p>

<ul>
<li><p>Raster
</p>
</li></ul>

</li>
<li><p>...
</p>
</li></ul>

</li></ul>

</li></ul>



<h3>Usage</h3>

<pre><code class='language-R'>extract_spatial(
  x,
  replicate = 1,
  timestep = 1,
  landscape_object = "population",
  stage = 1,
  misc = 1
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="extract_spatial_+3A_x">x</code></td>
<td>
<p>a simulation_results object</p>
</td></tr>
<tr><td><code id="extract_spatial_+3A_replicate">replicate</code></td>
<td>
<p>which replicate to extract from a <code>simulation_results</code>
object</p>
</td></tr>
<tr><td><code id="extract_spatial_+3A_timestep">timestep</code></td>
<td>
<p>which timestep to extract from a <code>simulation_results</code></p>
</td></tr>
<tr><td><code id="extract_spatial_+3A_landscape_object">landscape_object</code></td>
<td>
<p>which landscape object to extract from a
<code>simulation_results</code> object - can be specified by name
(e.g. &quot;suitability&quot;) or index number</p>
</td></tr>
<tr><td><code id="extract_spatial_+3A_stage">stage</code></td>
<td>
<p>which life-stage to extract from a <code>simulation_results</code>
object - only used for 'population' components of the landscape object</p>
</td></tr>
<tr><td><code id="extract_spatial_+3A_misc">misc</code></td>
<td>
<p>which misc object to extract from a <code>simulation_results</code>
object - only used for additional spatial objects added to a landscape
(e.g. disturbance layers)</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>
## Not run: 
ls &lt;- landscape(population = egk_pop, suitability = egk_hab, carrying_capacity = egk_k)

pd &lt;- population_dynamics(change = growth(egk_mat),
                          dispersal = kernel_dispersal(max_distance = 2000,
                                        dispersal_kernel = exponential_dispersal_kernel(
                                          distance_decay = 1000)),
                          density_dependence = ceiling_density())

sim &lt;- simulation(landscape = ls,
                  population_dynamics = pd,
                  habitat_dynamics = NULL,
                  timesteps = 20)

# Extract the population raster for the second life-stage in the first
# replicate and ninth timestep
extract_spatial(sim, replicate = 1, timestep = 9, stage = 2)

## End(Not run)
</code></pre>

<hr>
<h2 id='fast_dispersal'>Fast diffusion-based dispersal</h2><span id='topic+fast_dispersal'></span>

<h3>Description</h3>

<p>The fast_dispersal function uses kernel-based dispersal
to modify the population with a user-defined diffusion distribution
and a fast-fourier transformation (FFT) computational algorithm. It
is computationally efficient and very fast, however, only useful for
situations where dispersal barriers or arrival based on habitat or
carrying capacity are not required (e.g. a homogeneous landscape or
where diffusion alone is sufficient to explain dispersal patterns).
Dispersal is not constrained to suitable habitat or available carrying
capacity.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fast_dispersal(
  dispersal_kernel = exponential_dispersal_kernel(distance_decay = 0.1),
  dispersal_proportion = set_proportion_dispersing()
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fast_dispersal_+3A_dispersal_kernel">dispersal_kernel</code></td>
<td>
<p>a single built-in or user-defined distance dispersal
kernel function.</p>
</td></tr>
<tr><td><code id="fast_dispersal_+3A_dispersal_proportion">dispersal_proportion</code></td>
<td>
<p>a built-in or custom function defining the proportions
of individuals that can disperse in each life stage.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>
# Example of fast kernel-based dispersal where all life stages disperse.
# The default dispersal kernel uses a decay parameter to control how far
# populations disperse. Note proportions of populations to disperse are
# controlled by approach to carrying capacity.

## Not run: 
fft_dispersal &lt;- fast_dispersal(dispersal_proportion = density_dependence_dispersing(),
                     dispersal_kernel = exponential_dispersal_kernel(distance_decay = 1000))

ls &lt;- landscape(population = egk_pop, suitability = egk_hab, carrying_capacity = egk_k)

pd &lt;- population_dynamics(change = growth(egk_mat),
                          dispersal = fft_dispersal,
                          density_dependence = ceiling_density())

simulation(landscape = ls, population_dynamics = pd, habitat_dynamics = NULL, timesteps = 20)

## End(Not run)
</code></pre>

<hr>
<h2 id='fire_effects'>Fire effects with regeneration</h2><span id='topic+fire_effects'></span>

<h3>Description</h3>

<p>Modifies the landscape by multiplying habitat suitability values by a weighted sum of previous
fire intensities based on a user specified regeneration function. By default, the regenerative
function is an inverse linear relationship to time, however, this function can be replaced with a response
that takes into account other factors of habitat restoration (e.g. growth/re-growth curves of vegetation).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fire_effects(
  fire_layers,
  effect_time = 3,
  regeneration_function = function(time) {
     -time
 }
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fire_effects_+3A_fire_layers">fire_layers</code></td>
<td>
<p>the name(s) of spatial layer(s) in the landscape object with fire disturbances used
to alter the habitat object for each timestep (number of layers must match the intended timesteps)</p>
</td></tr>
<tr><td><code id="fire_effects_+3A_effect_time">effect_time</code></td>
<td>
<p>the number of timesteps that the fire layer will act on the habitat object</p>
</td></tr>
<tr><td><code id="fire_effects_+3A_regeneration_function">regeneration_function</code></td>
<td>
<p>a function that determines how fast the landscape will regenerate after a
fire event</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>
# Fire (stored in the landscape object and called "fires") acts on the landscape for
#five years with an exponentially decaying intensity.

## Not run: 
regen &lt;- function (time) {-exp(time)}

plot(1:5, regen(1:5), type = "l")

fire &lt;- fire_effects(fire_layers = "fires", effect_time = 5, regeneration_function = regen)

ls &lt;- landscape(population = egk_pop, suitability = egk_hab, "fires" = egk_fire)

pd &lt;- population_dynamics(change = growth(egk_mat))

sim &lt;- simulation(landscape = ls,
           population_dynamics = pd,
           habitat_dynamics = list(fire),
           timesteps = 20)
           
plot(sim, object = "suitability", type = "raster", timesteps = 1:9)

## End(Not run)
</code></pre>

<hr>
<h2 id='growth'>Population growth</h2><span id='topic+growth'></span>

<h3>Description</h3>

<p>This function applies negative or positive growth to the population using matrix
multiplication. Stochasticity can be added to cell-based transition matrices or globally.
Users can also specify a built-in or custom function to modify the transition matrices
throughout a simulation. Please see the tutorial vignette titled &quot;Creating custom
*steps* functions&quot; for information on how to write custom functions for use in simulations.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>growth(
  transition_matrix,
  global_stochasticity = 0,
  local_stochasticity = 0,
  transition_function = NULL,
  transition_order = c("fecundity", "survival"),
  two_sex = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="growth_+3A_transition_matrix">transition_matrix</code></td>
<td>
<p>A symmetrical age-based (Leslie) or stage-based (Lefkovitch)
population structure matrix.</p>
</td></tr>
<tr><td><code id="growth_+3A_global_stochasticity">global_stochasticity</code>, <code id="growth_+3A_local_stochasticity">local_stochasticity</code></td>
<td>
<p>Either scalar values or
matrices (with the same dimension as <code>transition_matrix</code>) specifying
the variability in the transition matrix either for populations in all grid
cells (<code>global_stochasticity</code>) or for each grid cell population
separately (<code>local_stochasticity</code>). Values supplied here are the
standard deviation of a truncated normal distribution where the mean is the
value supplied in the transition matrix.</p>
</td></tr>
<tr><td><code id="growth_+3A_transition_function">transition_function</code></td>
<td>
<p>A function to specify or modify life-stage transitions
at each timestep. See <a href="#topic+transition_function">transition_function</a>.</p>
</td></tr>
<tr><td><code id="growth_+3A_transition_order">transition_order</code></td>
<td>
<p>Order of transitions performed in growth function. This behaviour
is only applied when demographic stochasticity is set to &quot;full&quot; (default) and transitions
are applied sequentially. By default &quot;fecundity&quot; is performed first (calculating the
number of new individuals to be added to the populations), then &quot;survival&quot; is applied.
The final population is the sum of these. Users should be cautious of specifying
&quot;survival&quot; to be performed first as typically survival of reproductive stages will already
be accounted for in the fecundity values of the transition matrix.</p>
</td></tr>
<tr><td><code id="growth_+3A_two_sex">two_sex</code></td>
<td>
<p>Does the transition matrix include life stages for two sexes (i.e. male and
female)? Default is FALSE which assumes a single sex matrix (e.g. females only).</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>
# Example of a growth function that changes the populations based on a transition matrix that
# is subject to global stochasticity. 

## Not run: 
stoch_growth &lt;- growth(transition_matrix = egk_mat, global_stochasticity = egk_mat_stoch)

ls &lt;- landscape(population = egk_pop, suitability = NULL, carrying_capacity = NULL)

pd &lt;- population_dynamics(change = stoch_growth)

simulation(landscape = ls, population_dynamics = pd, habitat_dynamics = NULL, timesteps = 20)

## End(Not run)
</code></pre>

<hr>
<h2 id='habitat_dynamics_functions'>Functions to modify the habitat in a landscape object.</h2><span id='topic+habitat_dynamics_functions'></span>

<h3>Description</h3>

<p>Pre-defined functions to operate on habitat suitability (and carrying capacity if a function
is used) during a simulation.
</p>


<h3>See Also</h3>


<ul>
<li><p><a href="#topic+disturbance">disturbance</a> to modify the suitability of a landscape with user provided
spatially-explicit layers
</p>
</li>
<li><p><a href="#topic+fire_effects">fire_effects</a>
</p>
</li></ul>


<hr>
<h2 id='kernel_dispersal'>Kernel-based dispersal</h2><span id='topic+kernel_dispersal'></span>

<h3>Description</h3>

<p>The kernel_dispersal function employs a probabilistic
kernel-based dispersal algorithm to modify the population
using a user-defined diffusion distribution (see
<a href="#topic+dispersal_kernel">dispersal_kernel</a>), arrival probability layers
(e.g. habitat suitability), and growth limiting layers (e.g.
carrying capacity). This function is much slower than the
<a href="#topic+fast_dispersal">fast_dispersal</a>, however, respects dispersal
limitations which may be more ecologically appropriate. Further, 
the kernel-based dispersal function utilises a mechanism to
optimise computational performance in which it switches between
pre-allocating cell movements based on the available memory of
the host computer (faster but more memory intensive) or executing
cell movements in sequence (slower but less memory intensive).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>kernel_dispersal(
  dispersal_kernel = exponential_dispersal_kernel(distance_decay = 1),
  max_distance = NULL,
  arrival_probability = c("both", "suitability", "carrying_capacity", "none"),
  dispersal_proportion = set_proportion_dispersing()
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="kernel_dispersal_+3A_dispersal_kernel">dispersal_kernel</code></td>
<td>
<p>a single built-in or user-defined distance dispersal
kernel function.</p>
</td></tr>
<tr><td><code id="kernel_dispersal_+3A_max_distance">max_distance</code></td>
<td>
<p>the maximum distance that each life stage can
disperse in spatial units of the landscape (in kernel-based dispersal
this truncates the dispersal curve). Setting a reasonable number will
increase the performance of a simulation by reducing the number of cells
that need to be calculated in distance matrices.</p>
</td></tr>
<tr><td><code id="kernel_dispersal_+3A_arrival_probability">arrival_probability</code></td>
<td>
<p>the name of a spatial layer in the landscape object
that controls where individuals can disperse to (e.g. &quot;suitability&quot;) or
&quot;none&quot; to allow individuals to disperse to all non-NA cells. The default is
to use both the habitat suitability and carrying capacity layers. When this
option is selected, the arrival probability in each cell is calculated by
multiplying the habitat suitability by one minus the proportion of space taken
up in the cell (total population of life stages contributing to density
dependence divided by the carrying capacity).</p>
</td></tr>
<tr><td><code id="kernel_dispersal_+3A_dispersal_proportion">dispersal_proportion</code></td>
<td>
<p>a built-in or custom function defining the proportions
of individuals that can disperse in each life stage.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>
# Example of kernel-based dispersal where only the 3rd life stage
# disperses up to a maximum distance of 2000 meters. Dispersal is affected
# by both habitat suitability and carrying capacity (default). The default
# dispersal kernel uses a decay parameter to control how far populations disperse. 

## Not run: 
kb_dispersal &lt;- kernel_dispersal(max_distance = 2000,
                      dispersal_kernel = exponential_dispersal_kernel(distance_decay = 1000))

ls &lt;- landscape(population = egk_pop, suitability = egk_hab, carrying_capacity = egk_k)

pd &lt;- population_dynamics(change = growth(egk_mat),
                          dispersal = kb_dispersal,
                          density_dependence = ceiling_density())

simulation(landscape = ls, population_dynamics = pd, habitat_dynamics = NULL, timesteps = 20)

## End(Not run)
</code></pre>

<hr>
<h2 id='landscape'>Create a landscape object.</h2><span id='topic+landscape'></span>

<h3>Description</h3>

<p>A landscape object is used to store spatially-explicit information on population,
habitat suitability, carrying_capacity and miscellaneous landscape information.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>landscape(population, suitability = NULL, carrying_capacity = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="landscape_+3A_population">population</code></td>
<td>
<p>a raster stack (grid cell-based) with one layer for each life
stage.</p>
</td></tr>
<tr><td><code id="landscape_+3A_suitability">suitability</code></td>
<td>
<p>an optional raster layer or stack (multiple layers) containing
habitat suitability values for all cells in a landscape. Note, using a raster
stack assumes that the user has provided a layer for each intended timestep
in a simulation.</p>
</td></tr>
<tr><td><code id="landscape_+3A_carrying_capacity">carrying_capacity</code></td>
<td>
<p>an optional raster layer specifying carrying capacity
values for all cells in a landscape or a function defining how carrying capacity
is determined by habitat suitability.</p>
</td></tr>
<tr><td><code id="landscape_+3A_...">...</code></td>
<td>
<p>named raster objects representing different aspects of the landscape
used to modify the landscape object in a simulation. Note, this is intended to
store objects that are accessed by dynamic functions and used to modify the
landscape in a simulation. Also, further arguments passed to or from other methods.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A landscape object is modified in each timestep of a simulation. During a simulation,
population, habitat suitability or carrying capacity in a landscape object are changed 
based on dynamic functions selected or created by the user.
</p>


<h3>Value</h3>

<p>An object of class <code>landscape</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Example of setting up a landscape object.

## Not run: 
ls &lt;- landscape(population = egk_pop, suitability = egk_hab, carrying_capacity = egk_k)

pd &lt;- population_dynamics(change = growth(egk_mat))

simulation(landscape = ls, population_dynamics = pd, habitat_dynamics = NULL, timesteps = 20)

## End(Not run)
</code></pre>

<hr>
<h2 id='modified_transition'>Spatially-explicit transition function</h2><span id='topic+modified_transition'></span>

<h3>Description</h3>

<p>In the built-in <code>modified_transition function</code>, the values of fecundity and survival
in local cell-based transition matrices are multiplied by values in the named spatial objects
for each cell. The spatial objects can be rasters that are stored in the landscape object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>modified_transition(survival_layer = NULL, fecundity_layer = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="modified_transition_+3A_survival_layer">survival_layer</code></td>
<td>
<p>the name of a spatial layer in the landscape object used to modify survival values (i.e. non-zero values in rows other than the first).</p>
</td></tr>
<tr><td><code id="modified_transition_+3A_fecundity_layer">fecundity_layer</code></td>
<td>
<p>the name of a spatial layer in the landscape object used to modify fecundity values (i.e. non-zero values in the first row).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The behaviour of the function is to modify any non-zero values in the first row by
the &quot;fecundity_layer&quot; and non-zero values in rows other than the first by the &quot;survival_layer&quot;.
This is irrespective of the type of matrix or any assumptions made by the user in creating
the transition matrix. For example, if the transition matrix values include both the
probabilities of surviving AND growing into the next stage, these can NOT be modified
individually. This operation would require the use of a custom function - see the &quot;Creating
custom *steps* functions&quot; vignette for more information.
</p>
<p>Note, this function will not work if two-sex transition matrices are specified in a simulation.
This function can be modified, however, to accommodate two-sex models - review the
population_change function and see the &quot;Creating custom *steps* functions&quot; vignette for more
information.
</p>


<h3>Value</h3>

<p>An object of class <code>transition_function</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Vital rates (survival and fecundity) modified based on habitat suitability.

## Not run: 
mod_fun &lt;- modified_transition(survival_layer = "suitability", fecundity_layer = "suitability")

ls &lt;- landscape(population = egk_pop, suitability = egk_hab, carrying_capacity = NULL)

pd &lt;- population_dynamics(change = growth(egk_mat, transition_function = mod_fun))

simulation(landscape = ls, population_dynamics = pd, habitat_dynamics = NULL, timesteps = 20)

## End(Not run)
</code></pre>

<hr>
<h2 id='mortality'>Directly affect populations</h2><span id='topic+mortality'></span>

<h3>Description</h3>

<p>This function modifies a population by a mortality spatial layer included in a
steps landscape object. The mortality layer consists of values from 0???1 and
modifies the population by multiplying the population of a cell by the value of
the corresponding cell in a mortality layer. For example, a cell with ten
individuals before the mortality function is applied, and corresponding mortality
layer cell with a value of 0.2, would have two individuals remaining after
modification. Note, rounding also occurs after modification using a ceiling method
(i.e the largest whole integer is retained).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mortality(mortality_layer, stages = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mortality_+3A_mortality_layer">mortality_layer</code></td>
<td>
<p>the name of spatial layer(s) in the landscape object with
mortality proportions used to alter the populations for each timestep. If
a stack of rasters is used then the number of layers must match the intended
number of timesteps in the simulation.</p>
</td></tr>
<tr><td><code id="mortality_+3A_stages">stages</code></td>
<td>
<p>which life-stages are modified - default is all</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'># Modify populations in all life-stages with fire intensity.

## Not run: 
fire_mortal &lt;- mortality(mortality_layer = "fire", stages = NULL)

ls &lt;- landscape(population = egk_pop,
                suitability = egk_hab,
                carrying_capacity = egk_k,
                "fire" = egk_fire)

pd &lt;- population_dynamics(change = growth(egk_mat), modification = fire_mortal)

simulation(landscape = ls, population_dynamics = pd, habitat_dynamics = NULL, timesteps = 20)

## End(Not run)
</code></pre>

<hr>
<h2 id='plot_hab_spatial'>Plot habitat suitability spatial information</h2><span id='topic+plot_hab_spatial'></span>

<h3>Description</h3>

<p>Plot spatial grids to illustrate habitat suitability changes through time.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot_hab_spatial(x, replicate = 1, timesteps = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot_hab_spatial_+3A_x">x</code></td>
<td>
<p>a simulation_results object.</p>
</td></tr>
<tr><td><code id="plot_hab_spatial_+3A_replicate">replicate</code></td>
<td>
<p>replicate to plot - note, only one replicate can be plotted
at a time. The default is to plot the first replicate</p>
</td></tr>
<tr><td><code id="plot_hab_spatial_+3A_timesteps">timesteps</code></td>
<td>
<p>timesteps to plot</p>
</td></tr>
<tr><td><code id="plot_hab_spatial_+3A_...">...</code></td>
<td>
<p>further arguments passed to/from other methods</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>
## Not run: 
ls &lt;- landscape(population = egk_pop, suitability = egk_hab, carrying_capacity = egk_k)

pd &lt;- population_dynamics(change = growth(egk_mat),
                          dispersal = kernel_dispersal(max_distance = 2000,
                                        dispersal_kernel = exponential_dispersal_kernel(
                                          distance_decay = 1000)),
                          density_dependence = ceiling_density())

sim &lt;- simulation(landscape = ls,
                  population_dynamics = pd,
                  habitat_dynamics = NULL,
                  timesteps = 20)

# Plot the population trajectories by life-stage
plot_hab_spatial(sim)

## End(Not run)
</code></pre>

<hr>
<h2 id='plot_k_spatial'>Plot carrying capacity spatial information</h2><span id='topic+plot_k_spatial'></span>

<h3>Description</h3>

<p>Plot spatial grids to illustrate carrying capacity changes through time.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot_k_spatial(x, replicate = 1, timesteps = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot_k_spatial_+3A_x">x</code></td>
<td>
<p>a simulation_results object.</p>
</td></tr>
<tr><td><code id="plot_k_spatial_+3A_replicate">replicate</code></td>
<td>
<p>replicate to plot - note, only one replicate can be plotted
at a time. The default is to plot the first replicate</p>
</td></tr>
<tr><td><code id="plot_k_spatial_+3A_timesteps">timesteps</code></td>
<td>
<p>timesteps to plot</p>
</td></tr>
<tr><td><code id="plot_k_spatial_+3A_...">...</code></td>
<td>
<p>further arguments passed to/from other methods</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>
## Not run: 
ls &lt;- landscape(population = egk_pop, suitability = egk_hab, carrying_capacity = egk_k)

pd &lt;- population_dynamics(change = growth(egk_mat),
                          dispersal = kernel_dispersal(max_distance = 2000,
                                        dispersal_kernel = exponential_dispersal_kernel(
                                          distance_decay = 1000)),
                          density_dependence = ceiling_density())

sim &lt;- simulation(landscape = ls,
                  population_dynamics = pd,
                  habitat_dynamics = NULL,
                  timesteps = 20)

# Plot the population trajectories by life-stage
plot_k_spatial(sim)

## End(Not run)
</code></pre>

<hr>
<h2 id='plot_k_trend'>Plot carrying capacity (k) trend</h2><span id='topic+plot_k_trend'></span>

<h3>Description</h3>

<p>Plot linear graphs to illustrate carrying capacity changes through time.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot_k_trend(x, summary_stat = "mean", return_data = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot_k_trend_+3A_x">x</code></td>
<td>
<p>a simulation_results object</p>
</td></tr>
<tr><td><code id="plot_k_trend_+3A_summary_stat">summary_stat</code></td>
<td>
<p>how to summarize the values across the landscape - &quot;mean&quot; (default)
or &quot;sum&quot;</p>
</td></tr>
<tr><td><code id="plot_k_trend_+3A_return_data">return_data</code></td>
<td>
<p>(TRUE/FALSE) should the data used to create the plots be returned?</p>
</td></tr>
<tr><td><code id="plot_k_trend_+3A_...">...</code></td>
<td>
<p>further arguments passed to/from other methods</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>
## Not run: 
ls &lt;- landscape(population = egk_pop, suitability = egk_hab, carrying_capacity = egk_k)

pd &lt;- population_dynamics(change = growth(egk_mat),
                          dispersal = kernel_dispersal(max_distance = 2000,
                                        dispersal_kernel = exponential_dispersal_kernel(
                                          distance_decay = 1000)),
                          density_dependence = ceiling_density())

sim &lt;- simulation(landscape = ls,
                  population_dynamics = pd,
                  habitat_dynamics = NULL,
                  timesteps = 20)

# Plot the carrying capacity trajectories
plot_k_trend(sim)

## End(Not run)
</code></pre>

<hr>
<h2 id='plot_pop_spatial'>Plot population spatial information</h2><span id='topic+plot_pop_spatial'></span>

<h3>Description</h3>

<p>Plot spatial grids to illustrate population changes through time.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot_pop_spatial(x, stage = 0, replicate = 1, timesteps = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot_pop_spatial_+3A_x">x</code></td>
<td>
<p>a simulation_results object</p>
</td></tr>
<tr><td><code id="plot_pop_spatial_+3A_stage">stage</code></td>
<td>
<p>life-stage to plot - defaults to totals of all life stages. 
Set to zero for totals (i.e. sum of all life-stages).</p>
</td></tr>
<tr><td><code id="plot_pop_spatial_+3A_replicate">replicate</code></td>
<td>
<p>replicate to plot - note, only one replicate can be plotted
at a time. The default is to plot the first replicate</p>
</td></tr>
<tr><td><code id="plot_pop_spatial_+3A_timesteps">timesteps</code></td>
<td>
<p>timesteps to plot</p>
</td></tr>
<tr><td><code id="plot_pop_spatial_+3A_...">...</code></td>
<td>
<p>further arguments passed to/from other methods</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>
## Not run: 
ls &lt;- landscape(population = egk_pop, suitability = egk_hab, carrying_capacity = egk_k)

pd &lt;- population_dynamics(change = growth(egk_mat),
                          dispersal = kernel_dispersal(max_distance = 2000,
                                        dispersal_kernel = exponential_dispersal_kernel(
                                          distance_decay = 1000)),
                          density_dependence = ceiling_density())

sim &lt;- simulation(landscape = ls,
                  population_dynamics = pd,
                  habitat_dynamics = NULL,
                  timesteps = 20)

# Plot the population trajectories by life-stage
plot_pop_spatial(sim)

## End(Not run)
</code></pre>

<hr>
<h2 id='plot_pop_trend'>Plot population trend</h2><span id='topic+plot_pop_trend'></span>

<h3>Description</h3>

<p>Plot linear graphs to illustrate population changes through time.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot_pop_trend(x, stages = NULL, emp = FALSE, return_data = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot_pop_trend_+3A_x">x</code></td>
<td>
<p>a simulation_results object</p>
</td></tr>
<tr><td><code id="plot_pop_trend_+3A_stages">stages</code></td>
<td>
<p>life-stages to plot - by default all life-stages will be shown. 
Set to zero for totals (i.e. sums of all life-stages).</p>
</td></tr>
<tr><td><code id="plot_pop_trend_+3A_emp">emp</code></td>
<td>
<p>(TRUE/FALSE) add a dashed line indicating the expected minimum
population of the simulation (for multiple replicates only)</p>
</td></tr>
<tr><td><code id="plot_pop_trend_+3A_return_data">return_data</code></td>
<td>
<p>(TRUE/FALSE) should the data used to create the plots be returned?</p>
</td></tr>
<tr><td><code id="plot_pop_trend_+3A_...">...</code></td>
<td>
<p>further arguments passed to/from other methods</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>
## Not run: 
ls &lt;- landscape(population = egk_pop, suitability = egk_hab, carrying_capacity = egk_k)

pd &lt;- population_dynamics(change = growth(egk_mat),
                          dispersal = kernel_dispersal(max_distance = 2000,
                                        dispersal_kernel = exponential_dispersal_kernel(
                                          distance_decay = 1000)),
                          density_dependence = ceiling_density())

sim &lt;- simulation(landscape = ls,
                  population_dynamics = pd,
                  habitat_dynamics = NULL,
                  timesteps = 20)

# Plot the population trajectories by life-stage
plot_pop_trend(sim)

# Plot the total population trajectory
plot_pop_trend(sim, stages = 0) 

## End(Not run)
</code></pre>

<hr>
<h2 id='plot.simulation_results'>Plot the results of a simulation</h2><span id='topic+plot.simulation_results'></span>

<h3>Description</h3>

<p>Methods to visually inspect the results of a simulation. Both linear graphs
and spatial-explicit grids are generated for all timesteps to illustrate
population changes through time and space. Note, this function can be wrapped
in a *png()* call to write several images to disk for creating animations.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'simulation_results'
plot(x, replicates = 1, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.simulation_results_+3A_x">x</code></td>
<td>
<p>a simulation_results object</p>
</td></tr>
<tr><td><code id="plot.simulation_results_+3A_replicates">replicates</code></td>
<td>
<p>which replicates to plot (default is one, or the first)</p>
</td></tr>
<tr><td><code id="plot.simulation_results_+3A_...">...</code></td>
<td>
<p>further arguments passed to/from other methods</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>
## Not run: 
ls &lt;- landscape(population = egk_pop, suitability = egk_hab, carrying_capacity = egk_k)

pd &lt;- population_dynamics(change = growth(egk_mat),
                          dispersal = kernel_dispersal(max_distance = 2000,
                                        dispersal_kernel = exponential_dispersal_kernel(
                                          distance_decay = 1000)),
                          density_dependence = ceiling_density())

sim &lt;- simulation(landscape = ls,
                  population_dynamics = pd,
                  habitat_dynamics = NULL,
                  timesteps = 20)

# Plot the spatial distributions of total cell populations
plot(sim) 

## End(Not run)
</code></pre>

<hr>
<h2 id='population_change_functions'>How the population changes in a landscape.</h2><span id='topic+population_change_functions'></span>

<h3>Description</h3>

<p>Pre-defined or custom functions to define population change during a simulation.
Please see the tutorial vignette titled &quot;Creating custom *steps* functions&quot;
for information on how to write custom functions for use in simulations.
</p>


<h3>See Also</h3>


<ul>
<li><p><a href="#topic+growth">growth</a> is a default function for changing populations based on
transition matrices and functions
</p>
</li></ul>


<hr>
<h2 id='population_density_dependence_functions'>How the population responds to density dependence in a landscape.</h2><span id='topic+population_density_dependence_functions'></span>

<h3>Description</h3>

<p>Pre-defined or custom functions to define population density dependence (e.g. ceiling)
during a simulation. Please see the tutorial vignette titled &quot;Creating custom *steps*
functions&quot; for information on how to write custom functions for use in simulations.
</p>


<h3>See Also</h3>


<ul>
<li><p><a href="#topic+ceiling_density">ceiling_density</a> to cap populations at carrying capacities
</p>
</li></ul>


<hr>
<h2 id='population_dispersal_functions'>How the population disperses in a landscape.</h2><span id='topic+population_dispersal_functions'></span>

<h3>Description</h3>

<p>Pre-defined or custom functions to define population dispersal during a
simulation. Each dispersal method uses different computing resources
and may be applicable to different simulation scenarios. Please see the
tutorial vignette titled &quot;Creating custom *steps* functions&quot; for
information on how to write custom functions for use in simulations.
</p>


<h3>See Also</h3>


<ul>
<li><p><a href="#topic+kernel_dispersal">kernel_dispersal</a> for kernel-based diffusion dispersal using
habitat suitability and/or carrying capacity to influence movements
</p>
</li>
<li><p><a href="#topic+cellular_automata_dispersal">cellular_automata_dispersal</a> for individual-based movements using
rule-sets
</p>
</li>
<li><p><a href="#topic+fast_dispersal">fast_dispersal</a> for quick kernel-based diffusion
dispersal without accounting for spatial heterogeneity
</p>
</li></ul>


<hr>
<h2 id='population_dynamics'>Define population dynamics.</h2><span id='topic+population_dynamics'></span>

<h3>Description</h3>

<p>A <code>population_dynamics</code> object is used to describe how populations
change in space and time.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>population_dynamics(
  change = NULL,
  dispersal = NULL,
  modification = NULL,
  density_dependence = NULL,
  dynamics_order = c("change", "dispersal", "modification", "density_dependence")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="population_dynamics_+3A_change">change</code></td>
<td>
<p><a href="#topic+population_change_functions">population_change_functions</a> to define how population
growth occurs at each timestep</p>
</td></tr>
<tr><td><code id="population_dynamics_+3A_dispersal">dispersal</code></td>
<td>
<p><a href="#topic+population_dispersal_functions">population_dispersal_functions</a> to define how the
population disperses at each timestep</p>
</td></tr>
<tr><td><code id="population_dynamics_+3A_modification">modification</code></td>
<td>
<p><a href="#topic+population_modification_functions">population_modification_functions</a> to define any
deterministic changes to the population - such as translocations or population
control - at each timestep</p>
</td></tr>
<tr><td><code id="population_dynamics_+3A_density_dependence">density_dependence</code></td>
<td>
<p><a href="#topic+population_density_dependence_functions">population_density_dependence_functions</a>
to control density dependence effects on the population at each timestep</p>
</td></tr>
<tr><td><code id="population_dynamics_+3A_dynamics_order">dynamics_order</code></td>
<td>
<p>the order in which the population dynamics should be executed
on the landscape object - default is &quot;change&quot; -&gt; &quot;dispersal&quot; -&gt; &quot;modification&quot; -&gt; &quot;density_dependence&quot;. 
Note, if population dynamics are reordered, all dynamics must be listed in <code>dynamics_order</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A population_dynamics object is passed to <a href="#topic+simulation">simulation</a>
and defines how populations change between timesteps. Note, some dynamics
functions can be executed at non-regular intervals (i.e. only timesteps
explicitly defined by the user). The <code>population_dynamics</code> function is
used to construct an object with several population dynamics functions and
their associated parameters. These functions specify how the population in
the landscape object will be modified throughout a simulation. The dynamics
can be executed in any order that is specified by the user. It is cautioned
that the order of dynamics will have implications depending on whether the
user has assumed a post-breeding or pre-breeding census in the transition
matrix. For more information on this, please refer to Kendall et al, (2019)
<em>Ecological Applications</em>.
</p>


<h3>Value</h3>

<p>An object of class <code>population_dynamics</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Example of setting up population dynamics to only use a population change function.

## Not run: 
ls &lt;- landscape(population = egk_pop, suitability = NULL, carrying_capacity = NULL)

pd &lt;- population_dynamics(change = growth(egk_mat))

simulation(landscape = ls, population_dynamics = pd, habitat_dynamics = NULL, timesteps = 20)

## End(Not run)
</code></pre>

<hr>
<h2 id='population_modification_functions'>How the population is modified in a landscape.</h2><span id='topic+population_modification_functions'></span>

<h3>Description</h3>

<p>Pre-defined functions to define population modification (e.g. translocation) during a simulation.
</p>


<h3>See Also</h3>


<ul>
<li><p><a href="#topic+translocation">translocation</a> for specifying explicit spatial and temporal movements
of populations
</p>
</li>
<li><p><a href="#topic+mortality">mortality</a> for specifying explicit spatial and temporal changes to populations
</p>
</li></ul>


<hr>
<h2 id='set_proportion_dispersing'>Set proportions of populations dispersing</h2><span id='topic+set_proportion_dispersing'></span>

<h3>Description</h3>

<p>This function allows a user to specify what proportions of populations in each life-stage disperse.
It operates similarly on all cells and in all timesteps throughout a simulation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>set_proportion_dispersing(proportions = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="set_proportion_dispersing_+3A_proportions">proportions</code></td>
<td>
<p>A single value or vector of proportions (between zero and one) of
individuals in each life stage that disperse - default is 1. If proportions are specified
as a single number, then all life-stages disperse with that proportion, however, a vector
of proportions (equal in length to the number of life-stages) can also be specified. To
prevent stages from dispersing, set corresponding values to zero.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <code>dispersal_proportion_function</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Example of a proportion function that disperses no population in the first life stage,
# 50% of the second, and 90% of the 3rd. 

## Not run: 
prop_dispersal &lt;- set_proportion_dispersing(proportions = c(0, 0.5, 0.9))

kb_dispersal &lt;- kernel_dispersal(dispersal_proportion = prop_dispersal,
                      max_distance = 2000,
                      dispersal_kernel = exponential_dispersal_kernel(distance_decay = 1000))

ls &lt;- landscape(population = egk_pop, suitability = egk_hab, carrying_capacity = egk_k)

pd &lt;- population_dynamics(change = growth(egk_mat), dispersal = kb_dispersal)

simulation(landscape = ls, population_dynamics = pd, habitat_dynamics = NULL, timesteps = 20)

## End(Not run)
</code></pre>

<hr>
<h2 id='simulation'>Run a simulation</h2><span id='topic+simulation'></span>

<h3>Description</h3>

<p>A simulation changes landscape objects based on selected dynamics over a
specified number of timesteps.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>simulation(
  landscape,
  population_dynamics,
  habitat_dynamics = list(),
  demo_stochasticity = c("full", "none"),
  timesteps = 3,
  replicates = 1,
  verbose = TRUE,
  future.globals = list()
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="simulation_+3A_landscape">landscape</code></td>
<td>
<p>a <a href="#topic+landscape">landscape</a> object representing the initial habitat and
population</p>
</td></tr>
<tr><td><code id="simulation_+3A_population_dynamics">population_dynamics</code></td>
<td>
<p>a <a href="#topic+population_dynamics">population_dynamics</a> object describing how
population changes over time</p>
</td></tr>
<tr><td><code id="simulation_+3A_habitat_dynamics">habitat_dynamics</code></td>
<td>
<p>optional list of functions to modify the landscape at
each timestep - see <a href="#topic+habitat_dynamics_functions">habitat_dynamics_functions</a></p>
</td></tr>
<tr><td><code id="simulation_+3A_demo_stochasticity">demo_stochasticity</code></td>
<td>
<p>how should population rounding occur, if at all -
&quot;full&quot; uses a multinomial draw to return rounded cell populations (default)
whilst &quot;none&quot; returns non-integer cell populations (no rounding). Note, this
parameter specification is used consistently throughout all functions in a
simulation.</p>
</td></tr>
<tr><td><code id="simulation_+3A_timesteps">timesteps</code></td>
<td>
<p>number of timesteps used in one simulation</p>
</td></tr>
<tr><td><code id="simulation_+3A_replicates">replicates</code></td>
<td>
<p>number of simulations to perform</p>
</td></tr>
<tr><td><code id="simulation_+3A_verbose">verbose</code></td>
<td>
<p>print messages and progress to console? (default is TRUE)</p>
</td></tr>
<tr><td><code id="simulation_+3A_future.globals">future.globals</code></td>
<td>
<p>a list of custom functions, and objects called by the functions,
that a user has created in the global environment for use in a simulation. Note this
is only required when running simulations in parallel (e.g. plan(multisession)).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <code>simulation_results</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Not run: 
ls &lt;- landscape(population = egk_pop, suitability = egk_hab, carrying_capacity = egk_k)

pd &lt;- population_dynamics(change = growth(egk_mat),
                          dispersal = kernel_dispersal(max_distance = 2000,
                                        dispersal_kernel = exponential_dispersal_kernel(
                                          distance_decay = 1000)),
                          density_dependence = ceiling_density())

# Run a simulation with full demographic stochasticity and without any habitat
# dynamics for tewnty timesteps.
sim &lt;- simulation(landscape = ls,
                  population_dynamics = pd,
                  habitat_dynamics = NULL,
                  timesteps = 20)

## End(Not run)
</code></pre>

<hr>
<h2 id='steps'>Simulate population trajectories over space and time with dynamic functions.</h2><span id='topic+steps'></span>

<h3>Description</h3>

<p>Simulating shifts in species populations is an important
part of ecological management. Species respond to spatial and temporal
changes in the landscape resulting from environmental phenomena, managerial
actions or anthropogenic activities. This data is crucial for modelling,
however, current software that incorporates this information has limited
flexibility, transparency, and availability. <code>steps</code> extends the features
found in existing software and accepts common spatial inputs that are derived
from many other existing software packages.
</p>
<p>A <a href="#topic+simulation">simulation</a> is run on a <a href="#topic+landscape">landscape</a> using population
dynamics functions contained in a <a href="#topic+population_dynamics">population_dynamics</a> object.
<a href="#topic+habitat_dynamics_functions">habitat_dynamics_functions</a> can also be added to the simulation to
modify the habitat during a simulation.
</p>

<hr>
<h2 id='transition_function'>Create a growth transition function</h2><span id='topic+transition_function'></span>

<h3>Description</h3>

<p>A growth transition function defines how spatial objects or custom functions influence
survival and fecundity. Two built-in functions are provided for the user to select, however,
a user may also provide custom written functions to modify survival and fecundity throughout
a simulation. Please see the tutorial vignette titled &quot;Creating custom *steps* functions&quot;
for information on how to write custom functions for use in simulations.
</p>


<h3>See Also</h3>


<ul>
<li><p><a href="#topic+modified_transition">modified_transition</a> to use rasters to modify survival and fecundity
</p>
</li>
<li><p><a href="#topic+competition_density">competition_density</a> to use relationship to carrying capacity to modify
survival and fecundity
</p>
</li></ul>


<hr>
<h2 id='translocation'>Translocate populations</h2><span id='topic+translocation'></span>

<h3>Description</h3>

<p>This function is used to move or introduce populations throughout a simulation. A user can
specify which life-stages will be affected (default is all) and in which timesteps the
translocations will take place. A warning will be generated if populations are not available
where specified to translocate from.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>translocation(
  origins_layer,
  destinations_layer,
  stages = NULL,
  effect_timesteps = 1
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="translocation_+3A_origins_layer">origins_layer</code></td>
<td>
<p>the name of a spatial layer in the landscape object with the locations
and number of individuals to translocate from. Note, this layer will have only zero
values if individuals are being introduced from outside the study area</p>
</td></tr>
<tr><td><code id="translocation_+3A_destinations_layer">destinations_layer</code></td>
<td>
<p>the name of a spatial layer in the landscape object with the locations
and number of individuals to translocate to. Note, this layer will have only zero
values if individuals are being controlled (e.g. culling)</p>
</td></tr>
<tr><td><code id="translocation_+3A_stages">stages</code></td>
<td>
<p>which life-stages are modified - default is all</p>
</td></tr>
<tr><td><code id="translocation_+3A_effect_timesteps">effect_timesteps</code></td>
<td>
<p>which timesteps in a single simulation do the translocations
take place</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>
# Modify populations in all life-stages using explicit layers of origin and destination populations
# in timesteps 5, 10, and 15.

## Not run: 
trans_pop &lt;- translocation(origins_layer = "origins",
                           destinations_layer = "destinations",
                           stages = NULL,
                           effect_timesteps = c(5, 10, 15))

ls &lt;- landscape(population = egk_pop,
                suitability = NULL,
                carrying_capacity = NULL,
                "origins" = egk_origins,
                "destinations" = egk_destinations)

pd &lt;- population_dynamics(change = growth(egk_mat), modification = trans_pop)

simulation(landscape = ls, population_dynamics = pd, habitat_dynamics = NULL, timesteps = 20)

## End(Not run)
</code></pre>

<hr>
<h2 id='visualisation'>Visualise the results of a *steps* simulation</h2><span id='topic+visualisation'></span>

<h3>Description</h3>

<p>Visualising the results of a simulation is important to verify parameter assumptions
and quantitative model behaviour. Both linear graphs indicating trends and
spatial-explicit grids containing spatial arrangement of information can be generated
to illustrate changes through time and space for populations, carrying capacity,
and habitat suitability. The expected minimum populations (EMP) can also be compared
for several different simulations.
</p>


<h3>Details</h3>

<p>For plotting trends, see:
</p>

<ul>
<li><p><code><a href="#topic+plot_pop_trend">plot_pop_trend</a></code> to examine population changes
</p>
</li>
<li><p><code><a href="#topic+plot_k_trend">plot_k_trend</a></code> to examine carrying capacity changes
</p>
</li></ul>

<p>For plotting spatial information, see:
</p>

<ul>
<li><p><code><a href="#topic+plot_pop_spatial">plot_pop_spatial</a></code> to examine population changes
</p>
</li>
<li><p><code><a href="#topic+plot_k_spatial">plot_k_spatial</a></code> to examine carrying capacity changes
</p>
</li>
<li><p><code><a href="#topic+plot_hab_spatial">plot_hab_spatial</a></code> to examine habitat suitability changes
</p>
</li></ul>

<p>For plotting and comparing expected minimum populations, see:
</p>

<ul>
<li><p><code><a href="#topic+compare_emp">compare_emp</a></code> to examine how different simulations compare
</p>
</li></ul>


</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
