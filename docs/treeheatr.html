<!DOCTYPE html><html lang="en"><head><title>Help for package treeheatr</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {treeheatr}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#align_plots'><p>Align decision tree and heatmap:</p></a></li>
<li><a href='#clust_feat_func'><p>Performs clustering or features.</p></a></li>
<li><a href='#clust_samp_func'><p>Performs clustering of samples.</p></a></li>
<li><a href='#compute_tree'><p>Compute decision tree from data set</p></a></li>
<li><a href='#diabetes'><p>Diabetes patient records.</p></a></li>
<li><a href='#draw_heat'><p>Draws the heatmap.</p></a></li>
<li><a href='#draw_tree'><p>Draws the conditional decision tree.</p></a></li>
<li><a href='#eval_tree'><p>Print decision tree performance according to different metrics.</p></a></li>
<li><a href='#galaxy'><p>Galaxy dataset for regression.</p></a></li>
<li><a href='#get_cols'><p>Get color functions from character vectors</p></a></li>
<li><a href='#get_disp_feats'><p>Select the important features to be displayed.</p></a></li>
<li><a href='#get_fit'><p>&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;</p>
Get the fitted tree depending on the input 'x'.</a></li>
<li><a href='#heat_tree'><p>Draws and aligns decision tree and heatmap.</p></a></li>
<li><a href='#penguins'><p>Data of three different species of penguins.</p></a></li>
<li><a href='#position_nodes'><p>Creates smart node layout.</p></a></li>
<li><a href='#prediction_df'><p>Apply the predicted tree on either new test data or training data.</p></a></li>
<li><a href='#prep_data'><p>&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;</p>
Prepare dataset</a></li>
<li><a href='#prepare_feats'><p>Prepares the feature dataframes for tiles.</p></a></li>
<li><a href='#print.ggHeatTree'><p>Print a ggHeatTree object.</p>
Adopted from
https://github.com/daattali/ggExtra/blob/master/R/ggMarginal.R#L207-L244.</a></li>
<li><a href='#scale_norm'><p>Performs transformation on continuous variables.</p></a></li>
<li><a href='#term_node_pos'><p>Determines terminal node position.</p></a></li>
<li><a href='#test_covid'><p>External test dataset.</p>
Medical information of Wuhan patients collected between
2020-01-10 and 2020-02-18.</a></li>
<li><a href='#train_covid'><p>Training dataset.</p>
Medical information of Wuhan patients collected between
2020-01-10 and 2020-02-18.
Containing NAs.</a></li>
<li><a href='#wine'><p>Results of a chemical analysis of wines grown in a specific area of Italy.</p></a></li>
<li><a href='#wine_quality_red'><p>Red variant of the Portuguese &quot;Vinho Verde&quot; wine.</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Heatmap-Integrated Decision Tree Visualizations</td>
</tr>
<tr>
<td>Version:</td>
<td>0.2.1</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Trang Le &lt;grixor@gmail.com&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Creates interpretable decision tree visualizations 
    with the data represented as a heatmap at the tree's leaf nodes.
    'treeheatr' utilizes the customizable 'ggparty' package for 
    drawing decision trees.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://opensource.org/licenses/mit-license.php">MIT</a> + file LICENSE</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.1.1</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.5.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>ggparty, ggplot2, partykit, dplyr, ggnewscale, gtable, stats,
tidyr, cluster, grid, yardstick, seriation</td>
</tr>
<tr>
<td>Suggests:</td>
<td>forcats, knitr, rmarkdown, rpart, testthat</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://trang1618.github.io/treeheatr/index.html">https://trang1618.github.io/treeheatr/index.html</a>,
<a href="https://trang1618.github.io/treeheatr-manuscript/">https://trang1618.github.io/treeheatr-manuscript/</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/trang1618/treeheatr/issues">https://github.com/trang1618/treeheatr/issues</a></td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2020-11-19 20:45:18 UTC; ttle</td>
</tr>
<tr>
<td>Author:</td>
<td>Trang Le [aut, cre] (https://trang.page/),
  Jason Moore [aut] (http://www.epistasisblog.org/),
  University of Pennsylvania [cph]</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2020-11-19 21:00:03 UTC</td>
</tr>
</table>
<hr>
<h2 id='align_plots'>Align decision tree and heatmap:</h2><span id='topic+align_plots'></span>

<h3>Description</h3>

<p>Align decision tree and heatmap:
</p>


<h3>Usage</h3>

<pre><code class='language-R'>align_plots(
  dheat,
  dtree,
  heat_rel_height,
  show = c("heat-tree", "heat-only", "tree-only")
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="align_plots_+3A_dheat">dheat</code></td>
<td>
<p>ggplot2 grob object of the heatmap.</p>
</td></tr>
<tr><td><code id="align_plots_+3A_dtree">dtree</code></td>
<td>
<p>ggplot2 grob object of the decision tree</p>
</td></tr>
<tr><td><code id="align_plots_+3A_heat_rel_height">heat_rel_height</code></td>
<td>
<p>Relative height of heatmap compared to whole figure (with tree).</p>
</td></tr>
<tr><td><code id="align_plots_+3A_show">show</code></td>
<td>
<p>Character string indicating which components of the decision tree-heatmap
should be drawn. Can be 'heat-tree', 'heat-only' or 'tree-only'.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A gtable/grob object of the decision tree (top) and heatmap (bottom).
</p>

<hr>
<h2 id='clust_feat_func'>Performs clustering or features.</h2><span id='topic+clust_feat_func'></span>

<h3>Description</h3>

<p>Performs clustering or features.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>clust_feat_func(dat, clust_vec, clust_feats = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="clust_feat_func_+3A_dat">dat</code></td>
<td>
<p>Dataframe of the original dataset. Samples may be reordered.</p>
</td></tr>
<tr><td><code id="clust_feat_func_+3A_clust_vec">clust_vec</code></td>
<td>
<p>Character vector of variable names to be applied clustering on.
Can include class labels.</p>
</td></tr>
<tr><td><code id="clust_feat_func_+3A_clust_feats">clust_feats</code></td>
<td>
<p>if TRUE clusters displayed features (passed through 'clust_vec')
using the the Gower metric based on the values of all samples
and returns the ordered features.
When 'clust_samps = FALSE' and 'clust_feats = FALSE', no clustering is performed.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Character vector of reordered features when 'clust_feats == TRUE'.
</p>

<hr>
<h2 id='clust_samp_func'>Performs clustering of samples.</h2><span id='topic+clust_samp_func'></span>

<h3>Description</h3>

<p>Performs clustering of samples.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>clust_samp_func(leaf_node = NULL, dat, clust_vec, clust_samps = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="clust_samp_func_+3A_leaf_node">leaf_node</code></td>
<td>
<p>Integer value indicating terminal node id.</p>
</td></tr>
<tr><td><code id="clust_samp_func_+3A_dat">dat</code></td>
<td>
<p>Dataframe of the original dataset. Samples may be reordered.</p>
</td></tr>
<tr><td><code id="clust_samp_func_+3A_clust_vec">clust_vec</code></td>
<td>
<p>Character vector of variable names to be applied clustering on.
Can include class labels.</p>
</td></tr>
<tr><td><code id="clust_samp_func_+3A_clust_samps">clust_samps</code></td>
<td>
<p>Logical. If TRUE, hierarchical clustering would be performed
among samples within each leaf node.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Dataframe of reordered original dataset when clust_samps == TRUE.
</p>

<hr>
<h2 id='compute_tree'>Compute decision tree from data set</h2><span id='topic+compute_tree'></span>

<h3>Description</h3>

<p>Compute decision tree from data set
</p>


<h3>Usage</h3>

<pre><code class='language-R'>compute_tree(
  x,
  data_test = NULL,
  target_lab = NULL,
  task = c("classification", "regression"),
  feat_types = NULL,
  label_map = NULL,
  clust_samps = TRUE,
  clust_target = TRUE,
  custom_layout = NULL,
  lev_fac = 1.3,
  panel_space = 0.001
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="compute_tree_+3A_x">x</code></td>
<td>
<p>Dataframe or a 'party' or 'partynode' object representing a custom tree.
If a dataframe is supplied, conditional inference tree is computed.
If a custom tree is supplied, it must follow the partykit syntax:
https://cran.r-project.org/web/packages/partykit/vignettes/partykit.pdf</p>
</td></tr>
<tr><td><code id="compute_tree_+3A_data_test">data_test</code></td>
<td>
<p>Tidy test dataset. Required if 'x' is a 'partynode' object.
If NULL, heatmap displays (training) data 'x'.</p>
</td></tr>
<tr><td><code id="compute_tree_+3A_target_lab">target_lab</code></td>
<td>
<p>Name of the column in data that contains target/label information.</p>
</td></tr>
<tr><td><code id="compute_tree_+3A_task">task</code></td>
<td>
<p>Character string indicating the type of problem,
either 'classification' (categorical outcome) or 'regression' (continuous outcome).</p>
</td></tr>
<tr><td><code id="compute_tree_+3A_feat_types">feat_types</code></td>
<td>
<p>Named vector indicating the type of each features,
e.g., c(sex = 'factor', age = 'numeric').
If feature types are not supplied, infer from column type.</p>
</td></tr>
<tr><td><code id="compute_tree_+3A_label_map">label_map</code></td>
<td>
<p>Named vector of the meaning of the target values,
e.g., c(&lsquo;0' = &rsquo;Edible', &lsquo;1' = &rsquo;Poisonous').</p>
</td></tr>
<tr><td><code id="compute_tree_+3A_clust_samps">clust_samps</code></td>
<td>
<p>Logical. If TRUE, hierarchical clustering would be performed
among samples within each leaf node.</p>
</td></tr>
<tr><td><code id="compute_tree_+3A_clust_target">clust_target</code></td>
<td>
<p>Logical. If TRUE, target/label is included in hierarchical clustering
of samples within each leaf node and might yield a more interpretable heatmap.</p>
</td></tr>
<tr><td><code id="compute_tree_+3A_custom_layout">custom_layout</code></td>
<td>
<p>Dataframe with 3 columns: id, x and y
for manually input custom layout.</p>
</td></tr>
<tr><td><code id="compute_tree_+3A_lev_fac">lev_fac</code></td>
<td>
<p>Relative weight of child node positions
according to their levels, commonly ranges from 1 to 1.5.
1 for parent node perfectly in the middle of child nodes.</p>
</td></tr>
<tr><td><code id="compute_tree_+3A_panel_space">panel_space</code></td>
<td>
<p>Spacing between facets relative to viewport,
recommended to range from 0.001 to 0.01.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of results from 'partykit::ctree' or provided custom tree, including
fit, estimates, smart layout and terminal data.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>fit_tree &lt;- compute_tree(penguins, target_lab = 'species')
fit_tree$fit
fit_tree$layout
dplyr::select(fit_tree$term_dat, - contains('nodedata'))

</code></pre>

<hr>
<h2 id='diabetes'>Diabetes patient records.</h2><span id='topic+diabetes'></span>

<h3>Description</h3>

<p>http://archive.ics.uci.edu/ml/datasets/diabetes
https://www.kaggle.com/uciml/pima-indians-diabetes-database
</p>


<h3>Usage</h3>

<pre><code class='language-R'>diabetes
</code></pre>


<h3>Format</h3>

<p>A data frame with 768 observations and 9 variables:
<code>Pregnancies</code>, <code>Glucose</code>, <code>BloodPressure</code>, <code>SkinThickness</code>, <code>Insulin</code>,
<code>BMI</code>, <code>DiabetesPedigreeFunction</code>, <code>Age</code> and <code>Outcome</code>.
</p>

<hr>
<h2 id='draw_heat'>Draws the heatmap.</h2><span id='topic+draw_heat'></span>

<h3>Description</h3>

<p>Draws the heatmap to be placed below the decision tree.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>draw_heat(
  dat,
  fit,
  feat_types = NULL,
  target_cols = NULL,
  target_lab_disp = fit$target_lab,
  trans_type = c("percentize", "normalize", "scale", "none"),
  clust_feats = TRUE,
  feats = NULL,
  show_all_feats = FALSE,
  p_thres = 0.05,
  cont_legend = FALSE,
  cate_legend = FALSE,
  cont_cols = ggplot2::scale_fill_viridis_c,
  cate_cols = ggplot2::scale_fill_viridis_d,
  panel_space = 0.001,
  target_space = 0.05,
  target_pos = "top"
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="draw_heat_+3A_dat">dat</code></td>
<td>
<p>Dataframe with samples from original dataset ordered according to
the clustering within each leaf node.</p>
</td></tr>
<tr><td><code id="draw_heat_+3A_fit">fit</code></td>
<td>
<p>party object, e.g., as output from partykit::ctree()</p>
</td></tr>
<tr><td><code id="draw_heat_+3A_feat_types">feat_types</code></td>
<td>
<p>Named vector indicating the type of each features,
e.g., c(sex = 'factor', age = 'numeric').
If feature types are not supplied, infer from column type.</p>
</td></tr>
<tr><td><code id="draw_heat_+3A_target_cols">target_cols</code></td>
<td>
<p>Character vectors representing the hex values of different
level colors for targets, defaults to viridis option B.</p>
</td></tr>
<tr><td><code id="draw_heat_+3A_target_lab_disp">target_lab_disp</code></td>
<td>
<p>Character string for displaying the label of target label.
If not provided, use 'target_lab'.</p>
</td></tr>
<tr><td><code id="draw_heat_+3A_trans_type">trans_type</code></td>
<td>
<p>Character string of 'normalize', 'scale' or 'none'.
If 'scale', subtract the mean and divide by the standard deviation.
If 'normalize', i.e., max-min normalize, subtract the min and divide by the max.
If 'none', no transformation is applied.
More information on what transformation to choose can be acquired here:
https://cran.rstudio.com/package=heatmaply/vignettes/heatmaply.html#data-transformation-scaling-normalize-and-percentize</p>
</td></tr>
<tr><td><code id="draw_heat_+3A_clust_feats">clust_feats</code></td>
<td>
<p>Logical. If TRUE, performs cluster on the features.</p>
</td></tr>
<tr><td><code id="draw_heat_+3A_feats">feats</code></td>
<td>
<p>Character vector of feature names to be displayed in the heatmap.
If NULL, display features of which P values are less than 'p_thres'.</p>
</td></tr>
<tr><td><code id="draw_heat_+3A_show_all_feats">show_all_feats</code></td>
<td>
<p>Logical. If TRUE, show all features regardless of 'p_thres'.</p>
</td></tr>
<tr><td><code id="draw_heat_+3A_p_thres">p_thres</code></td>
<td>
<p>Numeric value indicating the p-value threshold of feature importance.
Feature with p-values computed from the decision tree below this value
will be displayed on the heatmap.</p>
</td></tr>
<tr><td><code id="draw_heat_+3A_cont_legend">cont_legend</code></td>
<td>
<p>Function determining the options for legend of continuous variables,
defaults to FALSE. If TRUE, use 'guide_colorbar(barwidth = 10, barheight = 0.5, title = NULL)'.
Any other ['guides()'](https://ggplot2.tidyverse.org/reference/guides.html) functions
would also work.</p>
</td></tr>
<tr><td><code id="draw_heat_+3A_cate_legend">cate_legend</code></td>
<td>
<p>Function determining the options for legend of categorical variables,
defaults to FALSE. If TRUE, use 'guide_legend(title = NULL)'.
Any other ['guides()'](https://ggplot2.tidyverse.org/reference/guides.html) functions
would also work.</p>
</td></tr>
<tr><td><code id="draw_heat_+3A_cont_cols">cont_cols</code></td>
<td>
<p>Function determining color scale for continuous variable,
defaults to 'scale_fill_viridis_c(guide = cont_legend)'.</p>
</td></tr>
<tr><td><code id="draw_heat_+3A_cate_cols">cate_cols</code></td>
<td>
<p>Function determining color scale for nominal categorical variable,
defaults to 'scale_fill_viridis_d(begin = 0.3, end = 0.9)'.</p>
</td></tr>
<tr><td><code id="draw_heat_+3A_panel_space">panel_space</code></td>
<td>
<p>Spacing between facets relative to viewport,
recommended to range from 0.001 to 0.01.</p>
</td></tr>
<tr><td><code id="draw_heat_+3A_target_space">target_space</code></td>
<td>
<p>Numeric value indicating spacing between
the target label and the rest of the features</p>
</td></tr>
<tr><td><code id="draw_heat_+3A_target_pos">target_pos</code></td>
<td>
<p>Character string specifying the position of the target label
on heatmap, can be 'top', 'bottom' or 'none'.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A ggplot2 grob object of the heatmap.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- compute_tree(penguins, target_lab = 'species')
draw_heat(x$dat, x$fit)


</code></pre>

<hr>
<h2 id='draw_tree'>Draws the conditional decision tree.</h2><span id='topic+draw_tree'></span>

<h3>Description</h3>

<p>Draws the conditional decision tree output from partykit::ctree(),
utilizing ggparty geoms: geom_edge, geom_edge_label, geom_node_label.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>draw_tree(
  dat,
  fit,
  term_dat,
  layout,
  target_cols = NULL,
  title = NULL,
  tree_space_top = 0.05,
  tree_space_bottom = 0.05,
  print_eval = FALSE,
  metrics = NULL,
  x_eval = 0,
  y_eval = 0.9,
  task = c("classification", "regression"),
  par_node_vars = list(label.size = 0, label.padding = unit(0.15, "lines"), line_list =
    list(aes(label = splitvar)), line_gpar = list(list(size = 9)), ids = "inner"),
  terminal_vars = list(label.padding = unit(0.25, "lines"), size = 3, col = "white"),
  edge_vars = list(color = "grey70", size = 0.5),
  edge_text_vars = list(color = "grey30", size = 3, mapping = aes(label =
    paste(breaks_label, "*NA")))
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="draw_tree_+3A_dat">dat</code></td>
<td>
<p>Dataframe with samples from original dataset ordered according to
the clustering within each leaf node.</p>
</td></tr>
<tr><td><code id="draw_tree_+3A_fit">fit</code></td>
<td>
<p>party object, e.g., as output from partykit::ctree()</p>
</td></tr>
<tr><td><code id="draw_tree_+3A_term_dat">term_dat</code></td>
<td>
<p>Dataframe for terminal nodes, must include these columns:
id, x, y and y_hat.</p>
</td></tr>
<tr><td><code id="draw_tree_+3A_layout">layout</code></td>
<td>
<p>Dataframe of layout of all nodes, must include these columns:
id, x, y and y_hat.</p>
</td></tr>
<tr><td><code id="draw_tree_+3A_target_cols">target_cols</code></td>
<td>
<p>Character vectors representing the hex values of different
level colors for targets, defaults to viridis option B.</p>
</td></tr>
<tr><td><code id="draw_tree_+3A_title">title</code></td>
<td>
<p>Character string for plot title.</p>
</td></tr>
<tr><td><code id="draw_tree_+3A_tree_space_top">tree_space_top</code></td>
<td>
<p>Numeric value to pass to expand for top margin of tree.</p>
</td></tr>
<tr><td><code id="draw_tree_+3A_tree_space_bottom">tree_space_bottom</code></td>
<td>
<p>Numeric value to pass to expand for bottom margin of tree.</p>
</td></tr>
<tr><td><code id="draw_tree_+3A_print_eval">print_eval</code></td>
<td>
<p>Logical. If TRUE, print evaluation of the tree performance.</p>
</td></tr>
<tr><td><code id="draw_tree_+3A_metrics">metrics</code></td>
<td>
<p>A set of metric functions to evaluate decision tree,
defaults to common metrics for classification/regression problems.
Can be defined with 'yardstick::metric_set'.</p>
</td></tr>
<tr><td><code id="draw_tree_+3A_x_eval">x_eval</code></td>
<td>
<p>Numeric value indicating x position to print performance statistics.</p>
</td></tr>
<tr><td><code id="draw_tree_+3A_y_eval">y_eval</code></td>
<td>
<p>Numeric value indicating y position to print performance statistics.</p>
</td></tr>
<tr><td><code id="draw_tree_+3A_task">task</code></td>
<td>
<p>Character string indicating the type of problem,
either 'classification' (categorical outcome) or 'regression' (continuous outcome).</p>
</td></tr>
<tr><td><code id="draw_tree_+3A_par_node_vars">par_node_vars</code></td>
<td>
<p>Named list containing arguments to be passed to the
'geom_node_label()' call for non-terminal nodes.</p>
</td></tr>
<tr><td><code id="draw_tree_+3A_terminal_vars">terminal_vars</code></td>
<td>
<p>Named list containing arguments to be passed to the
'geom_node_label()' call for terminal nodes.</p>
</td></tr>
<tr><td><code id="draw_tree_+3A_edge_vars">edge_vars</code></td>
<td>
<p>Named list containing arguments to be passed to the
'geom_edge()' call for tree edges.</p>
</td></tr>
<tr><td><code id="draw_tree_+3A_edge_text_vars">edge_text_vars</code></td>
<td>
<p>Named list containing arguments to be passed to the
'geom_edge_label()' call for tree edge annotations.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A ggplot2 grob object of the decision tree.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- compute_tree(penguins, target_lab = 'species')
draw_tree(x$dat, x$fit, x$term_dat, x$layout)

</code></pre>

<hr>
<h2 id='eval_tree'>Print decision tree performance according to different metrics.</h2><span id='topic+eval_tree'></span>

<h3>Description</h3>

<p>Print decision tree performance according to different metrics.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>eval_tree(
  dat,
  target_lab = colnames(dat)[1],
  task = c("classification", "regression"),
  metrics = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="eval_tree_+3A_dat">dat</code></td>
<td>
<p>Dataframe with truths (column 'target_lab') and estimates (column 'y_hat')
of samples from original dataset.</p>
</td></tr>
<tr><td><code id="eval_tree_+3A_target_lab">target_lab</code></td>
<td>
<p>Name of the column in data that contains target/label information.</p>
</td></tr>
<tr><td><code id="eval_tree_+3A_task">task</code></td>
<td>
<p>Character string indicating the type of problem,
either 'classification' (categorical outcome) or 'regression' (continuous outcome).</p>
</td></tr>
<tr><td><code id="eval_tree_+3A_metrics">metrics</code></td>
<td>
<p>A set of metric functions to evaluate decision tree,
defaults to common metrics for classification/regression problems.
Can be defined with 'yardstick::metric_set'.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Character string of the decision tree evaluation.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>eval_tree(compute_tree(penguins, target_lab = 'species')$dat)

</code></pre>

<hr>
<h2 id='galaxy'>Galaxy dataset for regression.</h2><span id='topic+galaxy'></span>

<h3>Description</h3>

<p>Fetched from PMLB.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>galaxy
</code></pre>


<h3>Format</h3>

<p>An object of class <code>data.frame</code> with 323 rows and 5 columns.
</p>


<h3>Details</h3>

<p>#' @format A data frame with 323 observations and 5 variables:
<code>eastwest</code>, <code>northsouth</code>, <code>angle</code>, <code>radialposition</code>
and <code>target</code> (velocity).
</p>
<p>https://www.openml.org/d/690
</p>

<hr>
<h2 id='get_cols'>Get color functions from character vectors</h2><span id='topic+get_cols'></span>

<h3>Description</h3>

<p>Get color functions from character vectors
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_cols(my_cols, task, guide = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="get_cols_+3A_my_cols">my_cols</code></td>
<td>
<p>Character vectors of different hex values</p>
</td></tr>
<tr><td><code id="get_cols_+3A_task">task</code></td>
<td>
<p>Character string indicating the type of problem,
either 'classification' (categorical outcome) or 'regression' (continuous outcome).</p>
</td></tr>
<tr><td><code id="get_cols_+3A_guide">guide</code></td>
<td>
<p>A function used to create a guide or its name.
Inherit from ['ggplot2::guides()'](https://ggplot2.tidyverse.org/reference/guides.html).</p>
</td></tr>
</table>

<hr>
<h2 id='get_disp_feats'>Select the important features to be displayed.</h2><span id='topic+get_disp_feats'></span>

<h3>Description</h3>

<p>Select features with p-value (computed from decision tree) &lt; 'p_thres'
or all features if 'show_all_feats == TRUE'.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_disp_feats(fit, feat_names, show_all_feats, p_thres)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="get_disp_feats_+3A_fit">fit</code></td>
<td>
<p>constparty object of the decision tree.</p>
</td></tr>
<tr><td><code id="get_disp_feats_+3A_feat_names">feat_names</code></td>
<td>
<p>Character vector specifying the feature names in dat.</p>
</td></tr>
<tr><td><code id="get_disp_feats_+3A_show_all_feats">show_all_feats</code></td>
<td>
<p>Logical. If TRUE, show all features regardless of 'p_thres'.</p>
</td></tr>
<tr><td><code id="get_disp_feats_+3A_p_thres">p_thres</code></td>
<td>
<p>Numeric value indicating the p-value threshold of feature importance.
Feature with p-values computed from the decision tree below this value
will be displayed on the heatmap.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A character vector of feature names.
</p>

<hr>
<h2 id='get_fit'>&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;
Get the fitted tree depending on the input 'x'.</h2><span id='topic+get_fit'></span><span id='topic+get_fit.default'></span><span id='topic+get_fit.partynode'></span><span id='topic+get_fit.party'></span><span id='topic+get_fit.data.frame'></span>

<h3>Description</h3>

<p>If 'x' is a data.frame object, computes conditional tree from partkit::ctree().
If 'x' is a partynode object specifying the customized tree, fit 'x' on 'data_test'.
If 'x' is a party (or constparty) object specifying the precomputed tree, simply coerce
'x' to have class constparty.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_fit(x, ...)

## Default S3 method:
get_fit(x, ...)

## S3 method for class 'partynode'
get_fit(x, data_test, target_lab, ...)

## S3 method for class 'party'
get_fit(x, data_test, target_lab, task, ...)

## S3 method for class 'data.frame'
get_fit(x, data_test, target_lab, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="get_fit_+3A_x">x</code></td>
<td>
<p>Dataframe or a 'party' or 'partynode' object representing a custom tree.
If a dataframe is supplied, conditional inference tree is computed.
If a custom tree is supplied, it must follow the partykit syntax:
https://cran.r-project.org/web/packages/partykit/vignettes/partykit.pdf</p>
</td></tr>
<tr><td><code id="get_fit_+3A_...">...</code></td>
<td>
<p>Further arguments passed to each method.</p>
</td></tr>
<tr><td><code id="get_fit_+3A_data_test">data_test</code></td>
<td>
<p>Tidy test dataset. Required if 'x' is a 'partynode' object.
If NULL, heatmap displays (training) data 'x'.</p>
</td></tr>
<tr><td><code id="get_fit_+3A_target_lab">target_lab</code></td>
<td>
<p>Name of the column in data that contains target/label information.</p>
</td></tr>
<tr><td><code id="get_fit_+3A_task">task</code></td>
<td>
<p>Character string indicating the type of problem,
either 'classification' (categorical outcome) or 'regression' (continuous outcome).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Fitted object as a list with prepped 'data_test' if available.
</p>

<hr>
<h2 id='heat_tree'>Draws and aligns decision tree and heatmap.</h2><span id='topic+heat_tree'></span><span id='topic+treeheatr'></span>

<h3>Description</h3>

<p>heat_tree() alias.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>heat_tree(
  x,
  target_lab = NULL,
  data_test = NULL,
  task = c("classification", "regression"),
  feat_types = NULL,
  label_map = NULL,
  target_cols = NULL,
  target_legend = FALSE,
  clust_samps = TRUE,
  clust_target = TRUE,
  custom_layout = NULL,
  show = "heat-tree",
  heat_rel_height = 0.2,
  lev_fac = 1.3,
  panel_space = 0.001,
  print_eval = (!is.null(data_test)),
  ...
)

treeheatr(
  x,
  target_lab = NULL,
  data_test = NULL,
  task = c("classification", "regression"),
  feat_types = NULL,
  label_map = NULL,
  target_cols = NULL,
  target_legend = FALSE,
  clust_samps = TRUE,
  clust_target = TRUE,
  custom_layout = NULL,
  show = "heat-tree",
  heat_rel_height = 0.2,
  lev_fac = 1.3,
  panel_space = 0.001,
  print_eval = (!is.null(data_test)),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="heat_tree_+3A_x">x</code></td>
<td>
<p>Dataframe or a 'party' or 'partynode' object representing a custom tree.
If a dataframe is supplied, conditional inference tree is computed.
If a custom tree is supplied, it must follow the partykit syntax:
https://cran.r-project.org/web/packages/partykit/vignettes/partykit.pdf</p>
</td></tr>
<tr><td><code id="heat_tree_+3A_target_lab">target_lab</code></td>
<td>
<p>Name of the column in data that contains target/label information.</p>
</td></tr>
<tr><td><code id="heat_tree_+3A_data_test">data_test</code></td>
<td>
<p>Tidy test dataset. Required if 'x' is a 'partynode' object.
If NULL, heatmap displays (training) data 'x'.</p>
</td></tr>
<tr><td><code id="heat_tree_+3A_task">task</code></td>
<td>
<p>Character string indicating the type of problem,
either 'classification' (categorical outcome) or 'regression' (continuous outcome).</p>
</td></tr>
<tr><td><code id="heat_tree_+3A_feat_types">feat_types</code></td>
<td>
<p>Named vector indicating the type of each features,
e.g., c(sex = 'factor', age = 'numeric').
If feature types are not supplied, infer from column type.</p>
</td></tr>
<tr><td><code id="heat_tree_+3A_label_map">label_map</code></td>
<td>
<p>Named vector of the meaning of the target values,
e.g., c(&lsquo;0' = &rsquo;Edible', &lsquo;1' = &rsquo;Poisonous').</p>
</td></tr>
<tr><td><code id="heat_tree_+3A_target_cols">target_cols</code></td>
<td>
<p>Character vectors representing the hex values of different
level colors for targets, defaults to viridis option B.</p>
</td></tr>
<tr><td><code id="heat_tree_+3A_target_legend">target_legend</code></td>
<td>
<p>Logical. If TRUE, target legend is drawn.</p>
</td></tr>
<tr><td><code id="heat_tree_+3A_clust_samps">clust_samps</code></td>
<td>
<p>Logical. If TRUE, hierarchical clustering would be performed
among samples within each leaf node.</p>
</td></tr>
<tr><td><code id="heat_tree_+3A_clust_target">clust_target</code></td>
<td>
<p>Logical. If TRUE, target/label is included in hierarchical clustering
of samples within each leaf node and might yield a more interpretable heatmap.</p>
</td></tr>
<tr><td><code id="heat_tree_+3A_custom_layout">custom_layout</code></td>
<td>
<p>Dataframe with 3 columns: id, x and y
for manually input custom layout.</p>
</td></tr>
<tr><td><code id="heat_tree_+3A_show">show</code></td>
<td>
<p>Character string indicating which components of the decision tree-heatmap
should be drawn. Can be 'heat-tree', 'heat-only' or 'tree-only'.</p>
</td></tr>
<tr><td><code id="heat_tree_+3A_heat_rel_height">heat_rel_height</code></td>
<td>
<p>Relative height of heatmap compared to whole figure (with tree).</p>
</td></tr>
<tr><td><code id="heat_tree_+3A_lev_fac">lev_fac</code></td>
<td>
<p>Relative weight of child node positions
according to their levels, commonly ranges from 1 to 1.5.
1 for parent node perfectly in the middle of child nodes.</p>
</td></tr>
<tr><td><code id="heat_tree_+3A_panel_space">panel_space</code></td>
<td>
<p>Spacing between facets relative to viewport,
recommended to range from 0.001 to 0.01.</p>
</td></tr>
<tr><td><code id="heat_tree_+3A_print_eval">print_eval</code></td>
<td>
<p>Logical. If TRUE, print evaluation of the tree performance.
Defaults to TRUE when 'data_test' is supplied.</p>
</td></tr>
<tr><td><code id="heat_tree_+3A_...">...</code></td>
<td>
<p>Further arguments passed to 'draw_tree()' and/or 'draw_heat()'.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A gtable/grob object of the decision tree (top) and heatmap (bottom).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>heat_tree(penguins, target_lab = 'species')


heat_tree(
  x = galaxy[1:100, ],
  target_lab = 'target',
  task = 'regression',
  terminal_vars = NULL,
  tree_space_bottom = 0)

treeheatr(penguins, target_lab = 'species')

treeheatr(
  x = galaxy[1:100, ],
  target_lab = 'target',
  task = 'regression',
  terminal_vars = NULL,
  tree_space_bottom = 0)
</code></pre>

<hr>
<h2 id='penguins'>Data of three different species of penguins.</h2><span id='topic+penguins'></span>

<h3>Description</h3>

<p>Collected and made available by Dr. Kristen Gorman and the Palmer Station,
Antarctica LTER, a member of the Long Term Ecological Research Network.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>penguins
</code></pre>


<h3>Format</h3>

<p>A data frame with 344 observations and 7 variables:
<code>species</code>, <code>island</code>, <code>culmen_length_mm</code>, <code>culmen_depth_mm</code>,
<code>flipper_length_mm</code>, <code>body_mass_g</code> and <code>sex</code>.
</p>
<p>Gorman KB, Williams TD, Fraser WR (2014).
Ecological Sexual Dimorphism and Environmental Variability within a
Community of Antarctic Penguins (Genus Pygoscelis).
PLoS ONE 9(3): e90081. doi:10.1371/journal.pone.0090081
</p>


<h3>Details</h3>

<p>Fetched from https://github.com/allisonhorst/penguins.
</p>

<hr>
<h2 id='position_nodes'>Creates smart node layout.</h2><span id='topic+position_nodes'></span>

<h3>Description</h3>

<p>Create node layout using a bottom-up approach (literally) and
overwrites ggparty-precomputed positions in plot_data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>position_nodes(plot_data, terminal_data, custom_layout, lev_fac, panel_space)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="position_nodes_+3A_plot_data">plot_data</code></td>
<td>
<p>Dataframe output of 'ggparty:::get_plot_data()'.</p>
</td></tr>
<tr><td><code id="position_nodes_+3A_terminal_data">terminal_data</code></td>
<td>
<p>Dataframe of terminal node information including id
and raw terminal node size.</p>
</td></tr>
<tr><td><code id="position_nodes_+3A_custom_layout">custom_layout</code></td>
<td>
<p>Dataframe with 3 columns: id, x and y
for manually input custom layout.</p>
</td></tr>
<tr><td><code id="position_nodes_+3A_lev_fac">lev_fac</code></td>
<td>
<p>Relative weight of child node positions
according to their levels, commonly ranges from 1 to 1.5.
1 for parent node perfectly in the middle of child nodes.</p>
</td></tr>
<tr><td><code id="position_nodes_+3A_panel_space">panel_space</code></td>
<td>
<p>Spacing between facets relative to viewport,
recommended to range from 0.001 to 0.01.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Dataframe with 3 columns: id, x and y of smart layout
combined with custom_layout.
</p>

<hr>
<h2 id='prediction_df'>Apply the predicted tree on either new test data or training data.</h2><span id='topic+prediction_df'></span>

<h3>Description</h3>

<p>Select features with p-value (computed from decision tree) &lt; 'p_thres'
or all features if 'show_all_feats == TRUE'.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>prediction_df(fit, task, clust_samps, clust_target)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="prediction_df_+3A_fit">fit</code></td>
<td>
<p>constparty object of the decision tree.</p>
</td></tr>
<tr><td><code id="prediction_df_+3A_task">task</code></td>
<td>
<p>Character string indicating the type of problem,
either 'classification' (categorical outcome) or 'regression' (continuous outcome).</p>
</td></tr>
<tr><td><code id="prediction_df_+3A_clust_samps">clust_samps</code></td>
<td>
<p>Logical. If TRUE, hierarchical clustering would be performed
among samples within each leaf node.</p>
</td></tr>
<tr><td><code id="prediction_df_+3A_clust_target">clust_target</code></td>
<td>
<p>Logical. If TRUE, target/label is included in hierarchical clustering
of samples within each leaf node and might yield a more interpretable heatmap.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A dataframe of prediction values with scaled columns
and clustered samples.
</p>

<hr>
<h2 id='prep_data'>&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;
Prepare dataset</h2><span id='topic+prep_data'></span>

<h3>Description</h3>

<p>&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;
Prepare dataset
</p>


<h3>Usage</h3>

<pre><code class='language-R'>prep_data(data, target_lab, task, feat_types = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="prep_data_+3A_data">data</code></td>
<td>
<p>Original data frame with features to be converted to correct types.</p>
</td></tr>
<tr><td><code id="prep_data_+3A_target_lab">target_lab</code></td>
<td>
<p>Name of the column in data that contains target/label information.</p>
</td></tr>
<tr><td><code id="prep_data_+3A_task">task</code></td>
<td>
<p>Character string indicating the type of problem,
either 'classification' (categorical outcome) or 'regression' (continuous outcome).</p>
</td></tr>
<tr><td><code id="prep_data_+3A_feat_types">feat_types</code></td>
<td>
<p>Named vector indicating the type of each features,
e.g., c(sex = 'factor', age = 'numeric').
If feature types are not supplied, infer from column type.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>List of dataframes (training + test) with proper feature types and target name.
</p>

<hr>
<h2 id='prepare_feats'>Prepares the feature dataframes for tiles.</h2><span id='topic+prepare_feats'></span>

<h3>Description</h3>

<p>If R does not recognize a categorical feature (input from user) as factor,
converts to factor.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>prepare_feats(dat, disp_feats, feat_types, clust_feats, trans_type)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="prepare_feats_+3A_dat">dat</code></td>
<td>
<p>Dataframe with samples from original dataset ordered according to
the clustering within each leaf node.</p>
</td></tr>
<tr><td><code id="prepare_feats_+3A_disp_feats">disp_feats</code></td>
<td>
<p>Character vector specifying features to be displayed.</p>
</td></tr>
<tr><td><code id="prepare_feats_+3A_feat_types">feat_types</code></td>
<td>
<p>Named vector indicating the type of each features,
e.g., c(sex = 'factor', age = 'numeric').
If feature types are not supplied, infer from column type.</p>
</td></tr>
<tr><td><code id="prepare_feats_+3A_clust_feats">clust_feats</code></td>
<td>
<p>Logical. If TRUE, performs cluster on the features.</p>
</td></tr>
<tr><td><code id="prepare_feats_+3A_trans_type">trans_type</code></td>
<td>
<p>Character string of 'normalize', 'scale' or 'none'.
If 'scale', subtract the mean and divide by the standard deviation.
If 'normalize', i.e., max-min normalize, subtract the min and divide by the max.
If 'none', no transformation is applied.
More information on what transformation to choose can be acquired here:
https://cran.rstudio.com/package=heatmaply/vignettes/heatmaply.html#data-transformation-scaling-normalize-and-percentize</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of two dataframes (continuous and categorical)
from the original dataset.
</p>

<hr>
<h2 id='print.ggHeatTree'>Print a ggHeatTree object.
Adopted from
https://github.com/daattali/ggExtra/blob/master/R/ggMarginal.R#L207-L244.</h2><span id='topic+print.ggHeatTree'></span>

<h3>Description</h3>

<p><code>ggHeatTree</code> objects are created from <code>heat_tree()</code>. This is the S3
generic print method to print the result of the scatterplot with its marginal
plots.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'ggHeatTree'
print(x, newpage = is.null(vp), vp = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="print.ggHeatTree_+3A_x">x</code></td>
<td>
<p>ggHeatTree (gtable grob) object.</p>
</td></tr>
<tr><td><code id="print.ggHeatTree_+3A_newpage">newpage</code></td>
<td>
<p>Should a new page (i.e., an empty page) be drawn before the
ggHeatTree is drawn?</p>
</td></tr>
<tr><td><code id="print.ggHeatTree_+3A_vp">vp</code></td>
<td>
<p>viewpoint</p>
</td></tr>
<tr><td><code id="print.ggHeatTree_+3A_...">...</code></td>
<td>
<p>ignored</p>
</td></tr>
</table>

<hr>
<h2 id='scale_norm'>Performs transformation on continuous variables.</h2><span id='topic+scale_norm'></span>

<h3>Description</h3>

<p>Performs transformation on continuous variables for the heatmap color scales.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>scale_norm(x, trans_type = c("percentize", "normalize", "scale", "none"))
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="scale_norm_+3A_x">x</code></td>
<td>
<p>Numeric vector.</p>
</td></tr>
<tr><td><code id="scale_norm_+3A_trans_type">trans_type</code></td>
<td>
<p>Character string of 'normalize', 'scale' or 'none'.
If 'scale', subtract the mean and divide by the standard deviation.
If 'normalize', i.e., max-min normalize, subtract the min and divide by the max.
If 'none', no transformation is applied.
More information on what transformation to choose can be acquired here:
https://cran.rstudio.com/package=heatmaply/vignettes/heatmaply.html#data-transformation-scaling-normalize-and-percentize</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Numeric vector of the transformed 'x'.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>scale_norm(1:5)
scale_norm(1:5, 'normalize')

</code></pre>

<hr>
<h2 id='term_node_pos'>Determines terminal node position.</h2><span id='topic+term_node_pos'></span>

<h3>Description</h3>

<p>Create node layout using a bottom-up approach (literally) and
overwrites ggparty-precomputed positions in plot_data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>term_node_pos(plot_data, dat)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="term_node_pos_+3A_plot_data">plot_data</code></td>
<td>
<p>Dataframe output of 'ggparty:::get_plot_data()'.</p>
</td></tr>
<tr><td><code id="term_node_pos_+3A_dat">dat</code></td>
<td>
<p>Dataframe of prediction values with scaled columns
and clustered samples.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Dataframe with terminal node information.
</p>

<hr>
<h2 id='test_covid'>External test dataset.
Medical information of Wuhan patients collected between
2020-01-10 and 2020-02-18.</h2><span id='topic+test_covid'></span>

<h3>Description</h3>

<p>External test dataset.
Medical information of Wuhan patients collected between
2020-01-10 and 2020-02-18.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>test_covid
</code></pre>


<h3>Format</h3>

<p>A data frame with 110 observations and 7 XGBoost-selected variables:
<code>PATIENT_ID</code>, <code>Lactate dehydrogenase</code>,
<code>High sensitivity C-reactive protein</code>, <code>(%)lymphocyte</code>,
<code>Admission time</code>, <code>Discharge time</code> and <code>outcome</code>.
</p>
<p>An interpretable mortality prediction model for COVID-19 patients.
Yan et al.
https://doi.org/10.1038/s42256-020-0180-7
https://github.com/HAIRLAB/Pre_Surv_COVID_19
</p>

<hr>
<h2 id='train_covid'>Training dataset.
Medical information of Wuhan patients collected between
2020-01-10 and 2020-02-18.
Containing NAs.</h2><span id='topic+train_covid'></span>

<h3>Description</h3>

<p>Training dataset.
Medical information of Wuhan patients collected between
2020-01-10 and 2020-02-18.
Containing NAs.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>train_covid
</code></pre>


<h3>Format</h3>

<p>A data frame with 375 observations and 77 variables.
</p>
<p>An interpretable mortality prediction model for COVID-19 patients.
Yan et al.
https://doi.org/10.1038/s42256-020-0180-7
https://github.com/HAIRLAB/Pre_Surv_COVID_19
</p>

<hr>
<h2 id='wine'>Results of a chemical analysis of wines grown in a specific area of Italy.</h2><span id='topic+wine'></span>

<h3>Description</h3>

<p>Three types of wine are represented in the 178 samples,
with the results of 13 chemical analyses recorded for each sample.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>wine
</code></pre>


<h3>Format</h3>

<p>A data frame with 178 observations and 14 variables:
<code>Alcohol</code>, <code>Malic</code>, <code>Ash</code>, <code>Alcalinity</code>,
<code>Magnesium</code>, <code>Phenols</code>, <code>Flavanoids</code>, <code>Nonflavanoids</code>,
<code>Proanthocyanins</code>, <code>Color</code>, <code>Hue</code>, <code>Dilution</code>, <code>Proline</code>
and <code>Type</code> (target).
</p>


<h3>Details</h3>

<p>Import with data(wine, package = 'rattle'). Dependent variable: Type.
https://rdrr.io/cran/rattle.data/man/wine.html
http://archive.ics.uci.edu/ml/datasets/wine
</p>

<hr>
<h2 id='wine_quality_red'>Red variant of the Portuguese &quot;Vinho Verde&quot; wine.</h2><span id='topic+wine_quality_red'></span>

<h3>Description</h3>

<p>Fetched from PMLB.
Physicochemical and quality of wine.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>wine_quality_red
</code></pre>


<h3>Format</h3>

<p>A data frame with 1599 observations and 12 variables:
<code>fixed.acidity</code>, <code>volatile.acidity</code>,
<code>citric.acid</code>, <code>residual.sugar</code>, <code>chlorides</code>, <code>free.sulfur.dioxide</code>,
<code>total.sulfur.dioxide</code>, <code>density</code>, <code>pH</code>, <code>sulphates</code>,
<code>alcohol</code> and <code>target</code> (quality).
</p>
<p>http://archive.ics.uci.edu/ml/datasets/Wine+Quality
</p>
<p>P. Cortez, A. Cerdeira, F. Almeida, T. Matos and J. Reis.
Modeling wine preferences by data mining from physicochemical properties.
In Decision Support Systems, Elsevier, 47(4):547-553, 2009.
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
