<!DOCTYPE html><html><head><title>Help for package funreg</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {funreg}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#coef.funreg'><p>coef method for funreg object</p></a></li>
<li><a href='#fitted.funeigen'><p>fitted method for funeigen object</p></a></li>
<li><a href='#fitted.funreg'><p>fitted method for funreg object</p></a></li>
<li><a href='#funeigen'><p>Perform eigenfunction decomposition on functional covariate</p></a></li>
<li><a href='#funreg'><p>Perform penalized functional regression</p></a></li>
<li><a href='#funreg.permutation'><p>Do a permutation test for functional regression</p></a></li>
<li><a href='#generate.data.for.demonstration'><p>Generate data for some demonstration examples</p></a></li>
<li><a href='#make.funreg.basis'><p>Make basis for functional regression (for internal use by other package functions)</p></a></li>
<li><a href='#marginal.cor'><p>Calculate marginal correlations with response</p></a></li>
<li><a href='#marginal.cor.funeigen'><p>Calculate marginal correlations with response,</p>
from a funeigen object</a></li>
<li><a href='#num.functional.covs.in.model'><p>Count the functional covariates in a model (for internal use by other package functions)</p></a></li>
<li><a href='#plot.funeigen'><p>plot method for funeigen object</p></a></li>
<li><a href='#plot.funreg'><p>plot method for funreg object</p></a></li>
<li><a href='#print.funreg'><p>print method for funreg object</p></a></li>
<li><a href='#redo.funreg'><p>Redo a funreg with different data (for internal use by permutation test)</p></a></li>
<li><a href='#SampleFunregData'><p>Sample dataset for funreg</p></a></li>
<li><a href='#summary.funreg'><p>summary method for funreg object</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Functional Regression for Irregularly Timed Data</td>
</tr>
<tr>
<td>Version:</td>
<td>1.2.2</td>
</tr>
<tr>
<td>Date:</td>
<td>2021-10-01</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 2.15.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>MASS, mgcv, mvtnorm, splines</td>
</tr>
<tr>
<td>Copyright:</td>
<td>The Pennsylvania State University and Northeastern
University</td>
</tr>
<tr>
<td>Description:</td>
<td>Performs functional regression, and some related
    approaches, for intensive longitudinal data (see the book by Walls &amp; Schafer, 
    2006, Models for Intensive Longitudinal Data, Oxford) when such data is not
    necessarily observed on an equally spaced grid of times.  The
    approach generally follows the ideas of Goldsmith, Bobb, Crainiceanu,
    Caffo, and Reich (2011)&lt;<a href="https://doi.org/10.1198%2Fjcgs.2010.10007">doi:10.1198/jcgs.2010.10007</a>&gt; and the approach taken in their sample code, but
    with some modifications to make it more feasible to use with long rather
    than wide, non-rectangular longitudinal datasets with unequal and
    potentially random measurement times.  It also allows easy plotting of the
    correlation between the smoothed covariate and the outcome as a function of
    time, which can add additional insights on how to interpret a functional
    regression.  Additionally, it also provides several permutation tests for
    the significance of the functional predictor.  The heuristic interpretation
    of &ldquo;time&rdquo; is used to describe the index of the functional predictor, but
    the same methods can equally be used for another unidimensional continuous
    index, such as space along a north-south axis.  Note that most of the functionality
	of this package has been superseded by added features after 2016 in the 'pfr' function by
    Jonathan Gellar, Mathew W. McLean, Jeff Goldsmith, and Fabian Scheipl, in the 
	'refund' package built by Jeff Goldsmith and co-authors and maintained by Julia Wrobel.
	The development of the funreg package in 2015 and 2016 was part of a research 
	project supported by Award R03 CA171809-01 from the National Cancer Institute and Award P50 
	DA010075 from the National Institute on Drug Abuse. The content is solely the responsibility of the
    authors and does not necessarily represent the official views of the
    National Institute on Drug Abuse, the National Cancer Institute, or the
    National Institutes of Health.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>John Dziak &lt;dziakj1@gmail.com&gt;</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.1.1</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2021-10-02 01:37:25 UTC; JJD</td>
</tr>
<tr>
<td>Author:</td>
<td>John Dziak <a href="https://orcid.org/0000-0003-0762-5495"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [aut,
    cre],
  Mariya Shiyko [aut]</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2021-10-04 09:30:05 UTC</td>
</tr>
</table>
<hr>
<h2 id='coef.funreg'>coef method for funreg object</h2><span id='topic+coef.funreg'></span>

<h3>Description</h3>

<p>Returns coefficient information on a <code>funreg</code> object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'funreg'
coef(object, digits = 4, silent = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="coef.funreg_+3A_object">object</code></td>
<td>
<p>An object of class <code>funreg</code></p>
</td></tr>
<tr><td><code id="coef.funreg_+3A_digits">digits</code></td>
<td>
<p>The number of digits past the decimal place to use when printing numbers</p>
</td></tr>
<tr><td><code id="coef.funreg_+3A_silent">silent</code></td>
<td>
<p>If <code>TRUE</code>, indicates that the summary should be returned
as a list object but not printed to the screen.</p>
</td></tr>
<tr><td><code id="coef.funreg_+3A_...">...</code></td>
<td>
<p>Other arguments that may be passed from another method.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>At least for now, this is identical to the <code>summary.funreg</code>
function.
</p>

<hr>
<h2 id='fitted.funeigen'>fitted method for funeigen object</h2><span id='topic+fitted.funeigen'></span>

<h3>Description</h3>

<p>Returns fitted values for a <code>funeigen</code> object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'funeigen'
fitted(object, type = "functions", ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fitted.funeigen_+3A_object">object</code></td>
<td>
<p>A  <code>funeigen</code> object.</p>
</td></tr>
<tr><td><code id="fitted.funeigen_+3A_type">type</code></td>
<td>
<p>A character string, one of the following: <code>functions</code>,
<code>eigenfunctions</code>, <code>loadings</code>, <code>eigenvalues</code>, <code>mean</code>,
<code>centered</code>, <code>covariance</code>, <code>noise.variance</code>, 
<code>midpoints</code>. These are the constructs for which fitted values can be returned.</p>
</td></tr>
<tr><td><code id="fitted.funeigen_+3A_...">...</code></td>
<td>
<p>Other optional arguments which may be passed from 
other methods but ignored by this one.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A <code>funeigen</code> object represents a principal component analysis
of irregular longitudinal data, following the method used by Goldsmith et al. (2011).
</p>


<h3>Value</h3>

<p>A matrix or vector containing the appropriate fitted values.  What is 
returned depends on the <code>type</code> parameter.  <code>functions</code> gives the fitted 
values of the smooth latent x(t) functions at a grid of time points.  
<code>eigenfunctions</code> gives the estimated eigenfunctions at each time point.  
<code>loadings</code> gives the loading of each subject on each estimated eigenfunction. 
<code>mean</code> gives the mean value for the smooth latent x(t) functions.  
<code>centered</code> gives the centered x(t) functions (the estimated function 
subtracting the mean function) .  <code>covariance</code> gives the estimated 
covariance matrix of x(s) and x(t) on a grid of time points s and t.
<code>noise.variance</code> gives the estimated measurement error variance on 
the x(t) functions.  <code>midpoints</code> gives the time points for the grid, on
which <code>functions</code>, <code>mean</code>, <code>centered</code>, and <code>covariance</code>
are defined; they are viewed as midpoints of bins of observation times (see 
Goldsmith et al., 2011).
</p>


<h3>References</h3>

<p>Goldsmith, J., Bobb, J., Crainiceanu, C. M., Caffo, B., and Reich, D.
(2011). Penalized functional regression. Journal of Computational
and Graphical Statistics, 20(4), 830-851. DOI: 10.1198/jcgs.2010.10007.
</p>

<hr>
<h2 id='fitted.funreg'>fitted method for funreg object</h2><span id='topic+fitted.funreg'></span>

<h3>Description</h3>

<p>Returns fitted values for a <code>funreg</code> object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'funreg'
fitted(object, type = "response", which.coef = 1, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fitted.funreg_+3A_object">object</code></td>
<td>
<p>A <code>funreg</code> object</p>
</td></tr>
<tr><td><code id="fitted.funreg_+3A_type">type</code></td>
<td>
<p>Either <code>response</code> or <code>correlation</code>.
If <code>response</code>, fitted values for the scalar response
variable are returned.  If <code>correlation</code>, estimated 
individual-level correlation coefficients of the smoothed value of the functional covariate
at various time points with the scalar response variable are returned.</p>
</td></tr>
<tr><td><code id="fitted.funreg_+3A_which.coef">which.coef</code></td>
<td>
<p>Only required if <code>type</code> is <code>correlation</code> 
and there is more than one functional covariate.  This specifies
which functional covariate is of interest.</p>
</td></tr>
<tr><td><code id="fitted.funreg_+3A_...">...</code></td>
<td>
<p>Other optional arguments which may be passed from other methods but ignored by this one.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns the fitted values for the responses if <code>type</code> is <code>response</code>, 
or the fitted values for the correlations of the 
<code>which.coef</code>th functional covariate with the
response, if <code>type</code> is <code>correlation</code>.
</p>

<hr>
<h2 id='funeigen'>Perform eigenfunction decomposition on functional covariate</h2><span id='topic+funeigen'></span>

<h3>Description</h3>

<p>A function to do the eigenfunction decomposition
as part of a penalized functional regression as in Goldsmith et al. (2011)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>funeigen(id, time, x, num.bins = 35, preferred.num.eigenfunctions = 30)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="funeigen_+3A_id">id</code></td>
<td>
<p>A vector of subject ID's.</p>
</td></tr>
<tr><td><code id="funeigen_+3A_time">time</code></td>
<td>
<p>A vector of measurement times.</p>
</td></tr>
<tr><td><code id="funeigen_+3A_x">x</code></td>
<td>
<p>A single functional predictor represented as a vector or a one-column matrix.</p>
</td></tr>
<tr><td><code id="funeigen_+3A_num.bins">num.bins</code></td>
<td>
<p>The number of knots used in the spline basis for the
beta function. The default is based on the  Goldsmith et al. (2011) 
sample code.</p>
</td></tr>
<tr><td><code id="funeigen_+3A_preferred.num.eigenfunctions">preferred.num.eigenfunctions</code></td>
<td>
<p>The number of eigenfunctions to use in approximating the 
covariance function of x (see Goldsmith et al., 2011)</p>
</td></tr>
</table>


<h3>Note</h3>

<p>The algorithm for this function follows that of &quot;sparse_simulation.R&quot;, which was
written on Nov. 13, 2009, by Jeff Goldsmith; Goldsmith noted that he used some code from Chongzhi Di for the part about
handling sparsity.  &quot;sparse_simulation.R&quot; was part of the supplementary material for
Goldsmith, Bobb, Crainiceanu, Caffo, and Reich (2011).
The <code>num.bins</code> parameter corresponds to  <code>N.fit</code> in Goldsmith et al, <code>sparse_simulation.R</code> and 
<code>preferred.num.eigenfunctions</code> corresponds to <code>Kz</code> in Goldsmith et al.
</p>


<h3>References</h3>

<p>Goldsmith, J., Bobb, J., Crainiceanu, C. M., Caffo, B., and Reich, D.
(2011). Penalized functional regression. Journal of Computational
and Graphical Statistics, 20(4), 830-851. DOI: 10.1198/jcgs.2010.10007.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+fitted.funeigen">fitted.funeigen</a></code>, <code>link{plot.funeigen}</code>
</p>

<hr>
<h2 id='funreg'>Perform penalized functional regression</h2><span id='topic+funreg'></span>

<h3>Description</h3>

<p>Performs a penalized functional regression as in Goldsmith et al. (2012)
on irregularly measured data such as that found in ecological momentary
assessment (see Walls &amp; Schafer, 2006;  Shiffman, Stone, &amp; Hufford, 2008).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>funreg(
  id,
  response,
  time,
  x,
  basis.method = 1,
  deg = 2,
  deg.penalty = 2,
  family = gaussian,
  other.covariates = NULL,
  num.bins = 35,
  preferred.num.eigenfunctions = 30,
  preferred.num.knots.for.beta = 35,
  se.method = 1,
  smoothing.method = 1,
  times.for.fit.grid = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="funreg_+3A_id">id</code></td>
<td>
<p>An integer or string uniquely identifying the
subject to which each observation belongs</p>
</td></tr>
<tr><td><code id="funreg_+3A_response">response</code></td>
<td>
<p>The response, as a vector, one for each subject</p>
</td></tr>
<tr><td><code id="funreg_+3A_time">time</code></td>
<td>
<p>The time of observation, as a vector,
one for each observation (i.e., each
assessment on each person)</p>
</td></tr>
<tr><td><code id="funreg_+3A_x">x</code></td>
<td>
<p>The functional predictor(s), as a matrix,
one row for each observation (i.e., for each
assessment on each person)</p>
</td></tr>
<tr><td><code id="funreg_+3A_basis.method">basis.method</code></td>
<td>
<p>An integer, either 1 or 2, describing how
the beta function should be internally
modeled. A value of 1 indicates that a
truncated power spline basis should be used,
and a value of 2 indicates that a B-spline
basis should be used.</p>
</td></tr>
<tr><td><code id="funreg_+3A_deg">deg</code></td>
<td>
<p>An integer, either 1, 2, or 3, describing how 
complicated the behavior of the beta function between knots 
may be.  1, 2, or 3 represent linear, quadratic or cubic 
function between knots.</p>
</td></tr>
<tr><td><code id="funreg_+3A_deg.penalty">deg.penalty</code></td>
<td>
<p>Only relevant for B-splines.  The
difference order used to weight the smoothing
penalty (see Eilers and Marx, 1996)</p>
</td></tr>
<tr><td><code id="funreg_+3A_family">family</code></td>
<td>
<p>The response distribution.  For example,
this is  <code>family=gaussian</code> for normal linear
models, <code>family=binomial</code> for logistic regression models,
or <code>family=poisson</code> for count models.  See the <code>gam</code>
documentation in the <code>mgcv</code> package, or use <code>help(family)</code>
for details on <code>family</code> objects.</p>
</td></tr>
<tr><td><code id="funreg_+3A_other.covariates">other.covariates</code></td>
<td>
<p>Subject-level (time-invariant) covariates, 
if any, as a matrix, one column per covariate. The default, 
<code>NULL</code>, means that no subject-level covariates will be included 
in the model.</p>
</td></tr>
<tr><td><code id="funreg_+3A_num.bins">num.bins</code></td>
<td>
<p>The number of knots used in the spline basis for the
beta function. The default is based on the  Goldsmith et al. (2011) 
sample code.</p>
</td></tr>
<tr><td><code id="funreg_+3A_preferred.num.eigenfunctions">preferred.num.eigenfunctions</code></td>
<td>
<p>The number of eigenfunctions to use in approximating the covariance function of x (see Goldsmith et al., 2011)</p>
</td></tr>
<tr><td><code id="funreg_+3A_preferred.num.knots.for.beta">preferred.num.knots.for.beta</code></td>
<td>
<p>number of knots to use in the spline
estimation.  The default, is based on the Goldsmith et al (2011) sample code.</p>
</td></tr>
<tr><td><code id="funreg_+3A_se.method">se.method</code></td>
<td>
<p>An integer, either 1 or 2, describing how
the standard errors should be calculated. A value
of 1 means that the uncertainty related to
selecting the smoothing parameter is ignored.
Option 2 means that a Bayesian approach is used
to try to take this uncertainty into account
(see the documentation for Wood's <code>mgcv</code> package).</p>
</td></tr>
<tr><td><code id="funreg_+3A_smoothing.method">smoothing.method</code></td>
<td>
<p>An integer, either 1 or 2, describing
how the weight of the smoothing penalty should be
determined.  Option 1 means that the smoothing
weight should be estimated using an approach
similar to restricted maximum likelihood, and
Option 2 means an approach similar to generalized
cross-validation.  Option 1 is strongly
recommended (based both on our experience and on
remarks in the documentation for the gam function
in the mgcv package).</p>
</td></tr>
<tr><td><code id="funreg_+3A_times.for.fit.grid">times.for.fit.grid</code></td>
<td>
<p>Points at which to calculate
the estimated beta function.  The default, NULL, means that the
code will choose these times automatically.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of type <code>funreg</code>.  This object 
can be examined using <code>summary</code>, <code>print</code>,
or <code>fitted</code>.
</p>


<h3>Note</h3>

<p>This function mostly follows code by Jeff Goldsmith and co-workers:
the sample code from Goldsmith et al (2011), and the &quot;pfr&quot; function in
the &quot;refund&quot; R package.  However, this code is adapted here to allow
idiosyncratic measurement times and unequal numbers of observations
per subject to be handled easily, and also allows the use of a different
estimation method.  Also follows some sample code for penalized
B-splines from Eilers and Marx (1996) in implementing B-splines.
As the pfr function in refund also does, the function calls
the gam function in the mgcv package (Wood 2011) to do much of the
internal calculations. This function may be somewhat obselete, because
a more flexible function is available in the new version of pfr in
the refund package (see <a href="http://jeffgoldsmith.com/software.html">http://jeffgoldsmith.com/software.html</a>).
</p>
<p>In the example below, to fit a more complicated model, replace
<code>x=SampleFunregData$x1</code> with <code>x=cbind(SampleFunregData$x1,
  SampleFunregData$x2),other.covariates=cbind(SampleFunregData$s1,
  SampleFunregData$s2, SampleFunregData$s3, SampleFunregData$s4)</code>.  This 
model will take longer to run, perhaps 10 or 20 seconds.  Then try
<code>plot(complex.model)</code>.
</p>


<h3>References</h3>

<p>Crainiceanu, C., Reiss, P., Goldsmith, J., Huang, L., Huo, L.,
Scheipl, F. (2012). refund: Regression with Functional Data
(version 0.1-6). R package Available online at cran.r-project.org.
</p>
<p>Eilers, P. H. C., and Marx, B. D. (1996). Flexible smoothing with
B-splines and penalties. Statistical Science, 11, 89-121. DOI:10.1.1.47.4521.
</p>
<p>Goldsmith, J., Bobb, J., Crainiceanu, C. M., Caffo, B., and Reich, D.
(2011). Penalized functional regression. Journal of Computational
and Graphical Statistics, 20(4), 830-851. DOI: 10.1198/jcgs.2010.10007.
For writing parts of this function I especially followed &quot;PFR_Example.R&quot;,
in the supplemental materials for this paper, written on Jan. 15 2010, by Jeff Goldsmith.
</p>
<p>Ruppert, D., Wand, M., and Carroll, R. (2003). Semiparametric regression.
Cambridge, UK: Cambridge University Press.
</p>
<p>Shiffman, S., Stone, A. A., and Hufford, M. R. (2008). Ecological
momentary assessment. Annual Review of Clinical Psychology, 4, 1-32. DOI:10.1146/annurev.clinpsy.3.022806.091415.
</p>
<p>Walls, T. A., &amp; Schafer, J. L. (2006) Models for intensive longitudinal data. New York: Oxford.
</p>
<p>Wood, S.N. (2006) Generalized Additive Models: An Introduction with
R. Chapman and Hall/CRC.
</p>
<p>Wood, S.N. (2011) Fast stable restricted maximum likelihood and
marginal likelihood estimation of semiparametric generalized linear
models. Journal of the Royal Statistical Society (B) 73(1):3-36. DOI:10.1111/j.1467-9868.2010.00749.x
</p>


<h3>See Also</h3>

<p><code><a href="#topic+fitted.funreg">fitted.funreg</a></code>, <code>link{plot.funreg}</code>,
<code><a href="#topic+print.funreg">print.funreg</a></code>, <code>link{summary.funreg}</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>simple.model &lt;- funreg(id=SampleFunregData$id,
                       response=SampleFunregData$y,
                       time=SampleFunregData$time,
                       x=SampleFunregData$x1,
                       family=binomial);
print(simple.model);                 
par(mfrow=c(2,2));                          
plot(x=simple.model$model.for.x[[1]]$bin.midpoints,
     y=simple.model$model.for.x[[1]]$mu.x.by.bin,
     xlab="Time t",ylab="X(t)",main="Smoothed mean x values"); 
# The smoothed average value of the predictor function x(t) at different times t. 
# The ``[[1]]'' after model.for.x is there because model.for.x is a list with one entry.
# This is because more than one functional covariate is allowed.
plot(simple.model,type="correlations");
# The marginal correlation of x(t) with y at different times t.
# It appears that earlier time points are more strongly related to y.
plot(simple.model,type="coefficients");
# The functional regression coefficient of y on x(t).  
# It also appears that earlier time points are more strongly related to y.
plot(simple.model$subject.info$response,
     simple.model$subject.info$fitted,
     main="Predictive Performance",
     xlab="True Y",
     ylab="Fitted Y");  
</code></pre>

<hr>
<h2 id='funreg.permutation'>Do a permutation test for functional regression</h2><span id='topic+funreg.permutation'></span>

<h3>Description</h3>

<p>Performs a permutation F test (Ramsay, Hooker, and Graves, 2009, p. 145)
for the significance of a functional covariate, and a permutation
likelihood ratio test.  The permutation test function currently doesn't allow models
with multiple functional covariates, but 
subject-level covariates are allowed.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>funreg.permutation(object, num.permute = 500, seed = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="funreg.permutation_+3A_object">object</code></td>
<td>
<p>An object of class funreg</p>
</td></tr>
<tr><td><code id="funreg.permutation_+3A_num.permute">num.permute</code></td>
<td>
<p>The number of permutations to use.  Ramsay, Hooker and Graves (2009) 
recommended &ldquo;several hundred&rdquo; (p. 145), but for a quicker initial look
it might suffice to use 100.</p>
</td></tr>
<tr><td><code id="funreg.permutation_+3A_seed">seed</code></td>
<td>
<p>An optional random number seed.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a list with several components. First, 
<code>pvalue.F</code> is the p-value for the F test.  Second, <code>conf.int.for.pvalue.F</code> is
the confidence interval for estimating the p-value that would
be obtained from the dataset as <code>num.permute</code> approached infinity. 
The idea of a confidence interval for a p-value is explained further by 
Sen (2013), with a STATA example. 
Third, <code>orig.F</code> is the F statistic calculated on the original
dataset. Last, <code>permuted.F</code> is the vector of F statistics calculated
on each of the random permuted datasets.  Also included are <code>pvalue.LR</code>,
<code>conf.int.for.pvalue.LR</code>,  <code>orig.LR</code>, <code>permuted.LR</code> for
the permutation test with a likelihood ratio statistic.
A more conservative alternative formula for the p-value is used in 
<code>pvalue.F.better</code> and <code>pvalue.LR.better</code>.  
It is not obvious whether to define the p-value as the 
proportion of permuted datasets with statistics less than or equal to
the original, or simply less than the original.  This should usually not 
matter, as a tie is not likely.  We made the arbitrary decision to use 
the former here because it was presented in this way in the 
Wikipedia article for permutation tests.                                     
The conservative alternative formula is 
the number of less extreme permuted datasets plus one,
over the total number of datasets plus one.  Adding one to the numerator
and denominator is suggested by some authors, partly  in order to prevent
a nonsensical zero p-value (Onghena &amp; May, 1995; Phipson, Belinda &amp; Smyth, 2010).
</p>


<h3>References</h3>

<p>Onghena, P., &amp; May, R. B. (1995). Pitfalls in computing and interpreting
randomization test p values: A commentary on Chen and Dunlap.
Behavior Research Methods, Instruments, &amp; Computers, 27(3), 408-411. DOI: 10.3758/BF03200438.
</p>
<p>Phipson, Belinda and Smyth, Gordon K. (2010) Permutation P-values 
Should Never Be Zero:  Calculating Exact P-values When Permutations
Are Randomly Drawn.  Statistical Applications
in Genetics and Molecular Biology: Vol. 9: Iss. 1, Article 39. DOI: 10.2202/1544-6115.1585.    
</p>
<p>Ramsay, J. O., Hooker, G., &amp; Graves, S. (2009). Functional
data analysis with R and MATLAB. NY: Springer.
</p>
<p>Sen, S. (2014) Permutation Tests.
</p>

<hr>
<h2 id='generate.data.for.demonstration'>Generate data for some demonstration examples</h2><span id='topic+generate.data.for.demonstration'></span>

<h3>Description</h3>

<p>Simulates a dataset with two functional covariates, four 
subject-level scalar covariates, and a binary outcome.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>generate.data.for.demonstration(
  nsub = 400,
  b0.true = -5,
  b1.true = 0,
  b2.true = +1,
  b3.true = -1,
  b4.true = +1,
  nobs = 500,
  observe.rate = 0.1
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="generate.data.for.demonstration_+3A_nsub">nsub</code></td>
<td>
<p>The number of subjects in the simulated dataset.</p>
</td></tr>
<tr><td><code id="generate.data.for.demonstration_+3A_b0.true">b0.true</code></td>
<td>
<p>The true value of the intercept.</p>
</td></tr>
<tr><td><code id="generate.data.for.demonstration_+3A_b1.true">b1.true</code></td>
<td>
<p>The true value of the first covariate.</p>
</td></tr>
<tr><td><code id="generate.data.for.demonstration_+3A_b2.true">b2.true</code></td>
<td>
<p>The true value of the second covariate.</p>
</td></tr>
<tr><td><code id="generate.data.for.demonstration_+3A_b3.true">b3.true</code></td>
<td>
<p>The true value of the third covariate.</p>
</td></tr>
<tr><td><code id="generate.data.for.demonstration_+3A_b4.true">b4.true</code></td>
<td>
<p>The true value of the fourth covariate.</p>
</td></tr>
<tr><td><code id="generate.data.for.demonstration_+3A_nobs">nobs</code></td>
<td>
<p>The total number of possible observation times.</p>
</td></tr>
<tr><td><code id="generate.data.for.demonstration_+3A_observe.rate">observe.rate</code></td>
<td>
<p>The average proportion of those possible
times at which any given subject is observed.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a <code>data.frame</code> representing <code>nobs</code>
measurements for each subject. The rows of this <code>data.frame</code>
tell the values of two time-varying covariates on a dense grid
of <code>nobs</code> observation times. It also contains an
<code>id</code> variable, four subject-level covariates
(<code>s1</code>, ..., <code>s4</code>) and one subject-level
response (<code>y</code>), which are replicated for each observation.
For each observation, there is also its observation 
time <code>time</code>, there are both the smooth latent value of the covariates 
(<code>true.x1</code> and <code>true.x2</code>) and 
versions observed with error (<code>x1</code> and <code>x2</code>), and there are 
also the local values of the functional regression coefficients 
(<code>true.betafn1</code> and <code>true.betafn2</code>).  Lastly, 
each row has a random value for <code>include.in.subsample</code>,
telling whether it should be considered as an observed data
point (versus an unobserved moment in the simulated subject's life).
<code>include.in.subsample</code> is simply generated as a Bernoulli random variable with 
success probability <code>observe.rate</code>.
</p>


<h3>Note</h3>

<p><code>nobs</code> is the number of simulated data rows per
simulated subject.  It  
should be selected to be large because <code>x</code> covariates are conceptually
supposed to be smooth functions of time. However, in the
simulated data analyses we actually only use a small random
subset of the generated time points, because this is more
realistic for many behavioral and medical science datasets.
Thus, the number of possible observation times per subject
is <code>nobs</code>, and the mean number of actual observation
times per subject is <code>nobs</code> times <code>observe.rate</code>. 
This smaller 'observed' dataset can be obtained by 
deleting from the dataset those observations having 
<code>include.in.subsample==FALSE</code>.
</p>

<hr>
<h2 id='make.funreg.basis'>Make basis for functional regression (for internal use by other package functions)</h2><span id='topic+make.funreg.basis'></span>

<h3>Description</h3>

<p>This is a function for internal use (i.e., a user will not need 
to call it directly for usual data analysis tasks).  Recall that
functional coefficients are estimated as a linear combination of 
basis functions, thus changing a nonparametric into a parametric
estimation problem.  This function constructs the matrix of basis 
function values for doing a functional regression.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>make.funreg.basis(basis.type, deg, num.knots, times)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="make.funreg.basis_+3A_basis.type">basis.type</code></td>
<td>
<p>is a character string, either <code>TruncatedPower</code>
or <code>BSpline</code>. This tells whether the basis functions should be
calculated as B-splines (see Eilers and Marx, 1996) or 
as truncated power splines (see Ruppert, Wand, and Carroll, 2003).</p>
</td></tr>
<tr><td><code id="make.funreg.basis_+3A_deg">deg</code></td>
<td>
<p>is the degree of the basis functions (roughly, their amount 
of complexity) and should generally be 1, 2, or 3.</p>
</td></tr>
<tr><td><code id="make.funreg.basis_+3A_num.knots">num.knots</code></td>
<td>
<p>is the number of knots in the basis; the higher 
this is, the more flexible the estimated function will be.  
If it is too low, the estimated function may be too simple
(i.e.,biased towards being too smooth).  If it is
too high, the function may be hard to interpret.</p>
</td></tr>
<tr><td><code id="make.funreg.basis_+3A_times">times</code></td>
<td>
<p>is the vector of measurement times (more technically, 
real-valued index values for the functional covariate) at which
the basis functions should be evaluated.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a list with two components.  The first,
<code>interior.knot.locations</code>, tells the selected locations on the time
axis for each interior knot. The second, <code>basis.for.betafn</code>,
is a matrix with one row for each time value in the input vector
<code>times</code> and one column for each basis function. It represents
the values of the basis functions themselves.
</p>


<h3>References</h3>

<p>Eilers, P. H. C., and Marx, B. D. (1996). 
Flexible smoothing with B-splines and penalties (with
comments and rejoinder). Statistical Science, 11, 89-121.
</p>
<p>Ruppert, D., Wand, M. P., and Carroll,
R. J. (2003) Semiparametric regression. Cambridge: Cambridge.
</p>

<hr>
<h2 id='marginal.cor'>Calculate marginal correlations with response</h2><span id='topic+marginal.cor'></span>

<h3>Description</h3>

<p>Calculates marginal correlations between a functional covariate and a scalar response.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>marginal.cor(object, id = NULL, response = NULL, alpha = 0.05)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="marginal.cor_+3A_object">object</code></td>
<td>
<p>An object of type <code>funeigen</code> or <code>funreg</code>.  One or the other of these is 
needed in order to provide a smoothed reconstructed curves for the functional covariate
for each subject.</p>
</td></tr>
<tr><td><code id="marginal.cor_+3A_id">id</code></td>
<td>
<p>The vector of subject id's. These tell which responses in <code>response</code> 
correspond to which curves in <code>object</code>.</p>
</td></tr>
<tr><td><code id="marginal.cor_+3A_response">response</code></td>
<td>
<p>The vector of responses</p>
</td></tr>
<tr><td><code id="marginal.cor_+3A_alpha">alpha</code></td>
<td>
<p>The alpha level for confidence intervals (one minus the two-sided coverage)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a list with one component for each functional 
covariate. Each such component contains the between-subjects correlations
between the fitted smoothed latent values of the functional covariate,
and the response variable. We call this a marginal correlation because
it simply ignores the other functional covariates (rather than trying to
adjust or control for them).  Both the functional regression coefficient
and the marginal correlation can be useful, although they have different
substantive interpretations.
</p>

<hr>
<h2 id='marginal.cor.funeigen'>Calculate marginal correlations with response, 
from a funeigen object</h2><span id='topic+marginal.cor.funeigen'></span>

<h3>Description</h3>

<p>A function for internal use.  Its main job is to be called by <code>MarginalCor</code>,
and do the technical work for calculating estimated marginal correlations. It 
uses R. A. Fisher's classic r-to-z transform to create confidence
intervals for the correlations.  This process is explained
in easy-to-follow detail by David Shen and Zaizai Lu in a technical report.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>marginal.cor.funeigen(object, id, response, alpha = 0.05)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="marginal.cor.funeigen_+3A_object">object</code></td>
<td>
<p>An object of type <code>funeigen</code>.</p>
</td></tr>
<tr><td><code id="marginal.cor.funeigen_+3A_id">id</code></td>
<td>
<p>The vector of subject id's. These tell which responses in <code>response</code> 
correspond to which curves in <code>object</code>.</p>
</td></tr>
<tr><td><code id="marginal.cor.funeigen_+3A_response">response</code></td>
<td>
<p>The vector of responses</p>
</td></tr>
<tr><td><code id="marginal.cor.funeigen_+3A_alpha">alpha</code></td>
<td>
<p>The alpha level for confidence intervals (one minus the two-sided coverage)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a <code>data.frame</code> with four columns. 
The first, <code>time</code>, is the time index of the rows.  
That is, it is a grid of points t along the time axis and
these points correspond to the rows.  The next three are the 
lower bound, best estimate, and upper bound, of the 
correlation between the smoothed value of the covariate x(t)
and the response y at each of the time points t. 
We refer to the correlation function estimated here as marginal because
it ignores any other functional covariates (rather than 
trying to adjust or control for them).
</p>


<h3>Note</h3>

<p>The confidence intervals are simply based on Fisher's
r-to-z transform and do not 
take into account the uncertainty in estimating the 
smoothed value of x(t).
</p>


<h3>References</h3>

<p>Shen, D., and Lu, Z. (2006). Computation of correlation coefficient
and its confidence interval in SAS (r). SUGI 31 (March 26-29, 2006), paper 170-31. Available online at 
<a href="https://support.sas.com/resources/papers/proceedings/proceedings/sugi31/170-31.pdf">https://support.sas.com/resources/papers/proceedings/proceedings/sugi31/170-31.pdf</a>.
</p>

<hr>
<h2 id='num.functional.covs.in.model'>Count the functional covariates in a model (for internal use by other package functions)</h2><span id='topic+num.functional.covs.in.model'></span>

<h3>Description</h3>

<p>A very simple function, mainly for internal use by
package code, to count the number of functional 
covariates in an object of class <code>funreg</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>num.functional.covs.in.model(object)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="num.functional.covs.in.model_+3A_object">object</code></td>
<td>
<p>An object of class <code>funreg</code>, representing 
a fitted penalized functional regression with one or more
functional covariates.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The number of functional covariates as an integer.
</p>

<hr>
<h2 id='plot.funeigen'>plot method for funeigen object</h2><span id='topic+plot.funeigen'></span>

<h3>Description</h3>

<p>Creates a visual representation of some of the 
information in an object of class <code>funeigen</code> 
(i.e., in an eigenfunction decomposition of a 
functional variable).  Several kinds of plots are 
available.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'funeigen'
plot(x, type = "correlation", how.many = NULL, xlab = "", ylab = "", ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.funeigen_+3A_x">x</code></td>
<td>
<p>An object of class <code>funeigen</code></p>
</td></tr>
<tr><td><code id="plot.funeigen_+3A_type">type</code></td>
<td>
<p>A character string telling the kind 
of information to include in the plot.  It may be <code>functions</code>,
<code>eigenfunctions</code>, <code>eigenvalues</code>, <code>mean</code>, <code>covariance</code>, or <code>correlation</code>.</p>
</td></tr>
<tr><td><code id="plot.funeigen_+3A_how.many">how.many</code></td>
<td>
<p>How many fitted curves to show (in a plot of 
fitted curves; the default is all of them), or how many estimated 
eigenfunctions to show (in a plot of eigenfunctions; the default is
all of them)</p>
</td></tr>
<tr><td><code id="plot.funeigen_+3A_xlab">xlab</code></td>
<td>
<p>Label for the x axis of the plot.</p>
</td></tr>
<tr><td><code id="plot.funeigen_+3A_ylab">ylab</code></td>
<td>
<p>Label for the y axis of the plot.</p>
</td></tr>
<tr><td><code id="plot.funeigen_+3A_...">...</code></td>
<td>
<p>Other optional arguments to be passed on to the plot function.</p>
</td></tr>
</table>

<hr>
<h2 id='plot.funreg'>plot method for funreg object</h2><span id='topic+plot.funreg'></span>

<h3>Description</h3>

<p>Plots information from an object of class <code>funreg</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'funreg'
plot(x, frames = FALSE, type = "coefficients", ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.funreg_+3A_x">x</code></td>
<td>
<p>An object of class <code>funreg</code>, representing 
a fitted functional regression model.</p>
</td></tr>
<tr><td><code id="plot.funreg_+3A_frames">frames</code></td>
<td>
<p>If there are multiple functional covariates, this 
tells whether or not the plot for each covariate should all be drawn together as different 
panels on the same figure.</p>
</td></tr>
<tr><td><code id="plot.funreg_+3A_type">type</code></td>
<td>
<p>A string telling what kind of plot to produce.
One can specify <code>coefficients</code>, which means that the 
functional coefficient for each functional covariate will be 
plotted as a function of time; or one can specify</p>
</td></tr>
<tr><td><code id="plot.funreg_+3A_...">...</code></td>
<td>
<p>Other optional arguments to be passed on to the plot function.
<code>correlations</code>, which means that the correlation
of the covariate (at each given time), with
the scalar outcome (presumably taken at a single
time) will be plotted instead.</p>
</td></tr>
</table>

<hr>
<h2 id='print.funreg'>print method for funreg object</h2><span id='topic+print.funreg'></span>

<h3>Description</h3>

<p>Prints information from an object of class <code>funreg</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'funreg'
print(x, digits = 4, show.fits = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.funreg_+3A_x">x</code></td>
<td>
<p>Object of class <code>funreg</code>.</p>
</td></tr>
<tr><td><code id="print.funreg_+3A_digits">digits</code></td>
<td>
<p>Number of digits past the decimal place 
to show when printing quantities.</p>
</td></tr>
<tr><td><code id="print.funreg_+3A_show.fits">show.fits</code></td>
<td>
<p>Whether to also print a table of fitted values for
the functional coefficients along a grid of times.</p>
</td></tr>
<tr><td><code id="print.funreg_+3A_...">...</code></td>
<td>
<p>Any other optional arguments to be passed to the default print
function.</p>
</td></tr>
</table>

<hr>
<h2 id='redo.funreg'>Redo a funreg with different data (for internal use by permutation test)</h2><span id='topic+redo.funreg'></span>

<h3>Description</h3>

<p>For internal use by package functions.  Not
intended to be directly called by the data analyst. 
This function repeats the analysis for an object
of class <code>funreg</code>, with the same settings 
but with possibly different data.  This is 
convenient in doing resampling techniques like
bootstrapping or permutation testing.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>redo.funreg(object, id, response, time, other.covariates, x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="redo.funreg_+3A_object">object</code></td>
<td>
<p>A <code>funreg</code> object.</p>
</td></tr>
<tr><td><code id="redo.funreg_+3A_id">id</code></td>
<td>
<p>The new values for id (see the <code>funreg</code> 
function documentation)</p>
</td></tr>
<tr><td><code id="redo.funreg_+3A_response">response</code></td>
<td>
<p>The new values for response</p>
</td></tr>
<tr><td><code id="redo.funreg_+3A_time">time</code></td>
<td>
<p>The new values for time</p>
</td></tr>
<tr><td><code id="redo.funreg_+3A_other.covariates">other.covariates</code></td>
<td>
<p>The new values for other.covariates (which may be NULL)</p>
</td></tr>
<tr><td><code id="redo.funreg_+3A_x">x</code></td>
<td>
<p>The new values for the functional covariate.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The <code>funreg</code> object for the new fitted model.
</p>

<hr>
<h2 id='SampleFunregData'>Sample dataset for funreg</h2><span id='topic+SampleFunregData'></span>

<h3>Description</h3>

<p>A data frame generated using the following code:
<code>set.seed(123);
       SampleFunregData &lt;- generate.data.for.demonstration(nsub = 200,  
                                                           b0.true = -5,
                                                           b1.true = 0, 
                                                           b2.true = +1,
                                                           b3.true = -1,
                                                           b4.true = +1,
                                                           nobs = 400, 
                                                           observe.rate = 0.1);</code>
</p>


<h3>Format</h3>

<p>A data frame for a simulated longitudinal study, 
in &quot;tall&quot; rather than &quot;wide&quot; format (multiple rows per
individual, one for each measurement time)
with 8109 rows and 13 columns.
</p>

<dl>
<dt>id</dt><dd><p>Integer uniquely identifying the subject to whom this data row pertains.</p>
</dd>
<dt>s1,s2,s3,s4</dt><dd><p>Four subject-level (time-invariant) covariates.</p>
</dd>
<dt>y</dt><dd><p>A response, coded as 0 or 1, which is to be modeled 
using a functional regression.  It is also subject-level (i.e., 
either time-invariant or measured only once).  However, 
like <code>s1</code> through <code>s4</code>, its value is repeated for each 
row of data for a subject.</p>
</dd>
<dt>time</dt><dd><p>The time variable, arbitrarily chosen to range
from a low of 0 to a high of 10, which identifies when this row's 
observations are taken.</p>
</dd>
<dt>true.x1,true.x2</dt><dd><p>The unknown smooth expected values of two
time-varying variables which can be treated as functional covariates. They
vary by subject and time and are therefore different in each row.</p>
</dd>
<dt>true.betafn1,true.betafn2</dt><dd><p>The unknown true functional
regression coefficient function used to generate <code>y</code> from the two time-varying 
predictors.  The latter is always zero because x2 is unrelated to y.</p>
</dd>
<dt>x1,x2</dt><dd><p>The observed values of the two functional regression
predictors, as measured for a given time on a given subject.</p>
</dd>
</dl>


<hr>
<h2 id='summary.funreg'>summary method for funreg object</h2><span id='topic+summary.funreg'></span>

<h3>Description</h3>

<p>Returns summary information on a <code>funreg</code> object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'funreg'
summary(object, digits = 4, silent = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary.funreg_+3A_object">object</code></td>
<td>
<p>An object of class <code>funreg</code></p>
</td></tr>
<tr><td><code id="summary.funreg_+3A_digits">digits</code></td>
<td>
<p>The number of digits past the decimal place to use when printing numbers</p>
</td></tr>
<tr><td><code id="summary.funreg_+3A_silent">silent</code></td>
<td>
<p>If <code>TRUE</code>, indicates that the summary should be returned
as a list object but not printed to the screen.</p>
</td></tr>
<tr><td><code id="summary.funreg_+3A_...">...</code></td>
<td>
<p>Any other optional arguments that may be passed 
from other methods (but currently ignored by this one).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a list with four components.  First, <code>call.info</code> summarizes the 
inputs that were sent into the <code>funreg</code> function.  Second, 
<code>intercept.estimate.uncentered</code> gives the estimated functional 
coefficient for the intercept in the functional regression model.  Third, 
<code>functional.covariates.table</code> provides estimated values for the 
functional coefficients at each of a grid of time points.  Fourth, 
<code>subject.level.covariates.table</code> provides estimated values for 
subject-level covariates if any are in the model.
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
