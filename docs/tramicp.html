<!DOCTYPE html><html lang="en"><head><title>Help for package tramicp</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {tramicp}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#bootstrap_stability'><p>Bootstrap stability for TRAMICP</p></a></li>
<li><a href='#dgp_dicp'><p>Simple data-generating process for illustrating tramicp</p></a></li>
<li><a href='#dicp'><p>Model-based causal feature selection for general response types</p></a></li>
<li><a href='#dicp_controls'><p>TRAMICP Controls</p></a></li>
<li><a href='#implemented_model_classes'><p>Aliases for implemented model classes</p></a></li>
<li><a href='#invariant_sets'><p>Return invariant sets</p></a></li>
<li><a href='#pvalues'><p>Extract set and predictor p-values from tramicp outputs</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Model-Based Causal Feature Selection for General Response Types</td>
</tr>
<tr>
<td>Version:</td>
<td>0.1-0</td>
</tr>
<tr>
<td>Description:</td>
<td>Extends invariant causal prediction (Peters et al., 2016, 
    &lt;<a href="https://doi.org/10.1111%2Frssb.12167">doi:10.1111/rssb.12167</a>&gt;) to generalized linear and transformation models 
    (Hothorn et al., 2018, &lt;<a href="https://doi.org/10.1111%2Fsjos.12291">doi:10.1111/sjos.12291</a>&gt;).
    The methodology is described in Kook et al. (2023,
    &lt;<a href="https://doi.org/10.1080%2F01621459.2024.2395588">doi:10.1080/01621459.2024.2395588</a>&gt;).</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.3.1</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 4.1.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>tram, mlt, coin, multcomp, survival, variables, basefun, MASS,
cotram, dHSIC, ranger, sandwich</td>
</tr>
<tr>
<td>Suggests:</td>
<td>testthat (&ge; 3.0.0)</td>
</tr>
<tr>
<td>Config/testthat/edition:</td>
<td>3</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/LucasKook/tramicp">https://github.com/LucasKook/tramicp</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/LucasKook/tramicp/issues">https://github.com/LucasKook/tramicp/issues</a></td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2025-01-31 09:28:33 UTC; lkook</td>
</tr>
<tr>
<td>Author:</td>
<td>Lucas Kook <a href="https://orcid.org/0000-0002-7546-7356"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [aut,
    cre],
  Sorawit Saengkyongam [ctb],
  Anton Rask Lundborg [ctb],
  Torsten Hothorn [ctb],
  Jonas Peters [ctb]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Lucas Kook &lt;lucasheinrich.kook@gmail.com&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2025-01-31 09:50:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='bootstrap_stability'>Bootstrap stability for TRAMICP</h2><span id='topic+bootstrap_stability'></span>

<h3>Description</h3>

<p>Bootstrap stability for TRAMICP
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bootstrap_stability(
  object,
  B = 100,
  size = NULL,
  verbose = FALSE,
  return_all = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="bootstrap_stability_+3A_object">object</code></td>
<td>
<p>Object of class <code>"dICP"</code></p>
</td></tr>
<tr><td><code id="bootstrap_stability_+3A_b">B</code></td>
<td>
<p>Numeric; number of bootstrap iterations</p>
</td></tr>
<tr><td><code id="bootstrap_stability_+3A_size">size</code></td>
<td>
<p>Numeric; size of bootstrap samples</p>
</td></tr>
<tr><td><code id="bootstrap_stability_+3A_verbose">verbose</code></td>
<td>
<p>Logical; print a progress bar (default: <code>FALSE</code>)</p>
</td></tr>
<tr><td><code id="bootstrap_stability_+3A_return_all">return_all</code></td>
<td>
<p>Logical; return all <code>"dICP"</code> objects (default:
<code>FALSE</code>)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Table of output sets of candidate causal predictors
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(12)
d &lt;- dgp_dicp(n = 1e3, mod = "binary")
res &lt;- glmICP(Y ~ X1 + X2 + X3, data = d, env = ~ E,
    family = "binomial", test = "cor.test")
bootstrap_stability(res, B = 2)

</code></pre>

<hr>
<h2 id='dgp_dicp'>Simple data-generating process for illustrating tramicp</h2><span id='topic+dgp_dicp'></span>

<h3>Description</h3>

<p>Simple data-generating process for illustrating tramicp
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dgp_dicp(
  n = 1000,
  K = 6,
  nenv = 2,
  bx3 = stats::rnorm(1),
  ge = stats::rnorm(nenv),
  ae = stats::rnorm(nenv),
  mod = "polr",
  interacting = FALSE,
  rm_censoring = TRUE,
  cfb = c(-3, 1.35),
  cfx = stats::rnorm(2),
  bx2x1 = stats::rnorm(1)
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="dgp_dicp_+3A_n">n</code></td>
<td>
<p>Sample size</p>
</td></tr>
<tr><td><code id="dgp_dicp_+3A_k">K</code></td>
<td>
<p>Number of outcome classes or order of Bernstein polynomial</p>
</td></tr>
<tr><td><code id="dgp_dicp_+3A_nenv">nenv</code></td>
<td>
<p>Number of environments</p>
</td></tr>
<tr><td><code id="dgp_dicp_+3A_bx3">bx3</code></td>
<td>
<p>Effect of Y on X3</p>
</td></tr>
<tr><td><code id="dgp_dicp_+3A_ge">ge</code></td>
<td>
<p>Environment specific effect</p>
</td></tr>
<tr><td><code id="dgp_dicp_+3A_ae">ae</code></td>
<td>
<p>Environment specific effect</p>
</td></tr>
<tr><td><code id="dgp_dicp_+3A_mod">mod</code></td>
<td>
<p>Type of model</p>
</td></tr>
<tr><td><code id="dgp_dicp_+3A_interacting">interacting</code></td>
<td>
<p>Toggle baseline interaction with env</p>
</td></tr>
<tr><td><code id="dgp_dicp_+3A_rm_censoring">rm_censoring</code></td>
<td>
<p>Remove censoring from simulated responses</p>
</td></tr>
<tr><td><code id="dgp_dicp_+3A_cfb">cfb</code></td>
<td>
<p>Baseline coefs</p>
</td></tr>
<tr><td><code id="dgp_dicp_+3A_cfx">cfx</code></td>
<td>
<p>Shift coefs</p>
</td></tr>
<tr><td><code id="dgp_dicp_+3A_bx2x1">bx2x1</code></td>
<td>
<p>coef from x2 to x1</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Simulates from X2 -&gt; X1 -&gt; Y -&gt; X3, with E affecting X1, X2, X3, but
not Y.
</p>


<h3>Value</h3>

<p><code>data.frame</code> with simulated data
</p>

<hr>
<h2 id='dicp'>Model-based causal feature selection for general response types</h2><span id='topic+dicp'></span>

<h3>Description</h3>

<p>Function 'dicp()' implements invariant causal prediction (ICP) for
transformation and generalized linear models, including binary logistic
regression, Weibull regression, the Cox model, linear regression and many
others. The aim of ICP is to discover the direct causes of a response given
data from heterogeneous experimental settings and a potentially large pool of
candidate predictors.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dicp(
  formula,
  data,
  env,
  modFUN,
  verbose = TRUE,
  type = c("residual", "wald", "partial"),
  test = "gcm.test",
  controls = NULL,
  alpha = 0.05,
  baseline_fixed = TRUE,
  greedy = FALSE,
  max_size = NULL,
  mandatory = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="dicp_+3A_formula">formula</code></td>
<td>
<p>A <code>formula</code> including response and covariate terms.</p>
</td></tr>
<tr><td><code id="dicp_+3A_data">data</code></td>
<td>
<p>A <code>data.frame</code> containing response and explanatory variables.</p>
</td></tr>
<tr><td><code id="dicp_+3A_env">env</code></td>
<td>
<p>A <code>formula</code> specifying the environment variables (see details).</p>
</td></tr>
<tr><td><code id="dicp_+3A_modfun">modFUN</code></td>
<td>
<p>Model function from 'tram' (or other packages), e.g.,
<code><a href="tram.html#topic+BoxCox">BoxCox</a></code>, <code><a href="tram.html#topic+Colr">Colr</a></code>,
<code><a href="tram.html#topic+Polr">Polr</a></code>, <code><a href="tram.html#topic+Lm">Lm</a></code>,
<code><a href="tram.html#topic+Coxph">Coxph</a></code>, <code><a href="tram.html#topic+Survreg">Survreg</a></code>,
<code><a href="tram.html#topic+Lehmann">Lehmann</a></code>. Standard implementations
<code><a href="stats.html#topic+lm">lm</a></code>, <code><a href="stats.html#topic+glm">glm</a></code>,
<code><a href="survival.html#topic+survreg">survreg</a></code>, <code><a href="survival.html#topic+coxph">coxph</a></code>,
and <code><a href="MASS.html#topic+polr">polr</a></code> are also supported. See the corresponding
alias <code>&lt;model_name&gt;ICP</code>, e.g., <code><a href="#topic+PolrICP">PolrICP</a></code> or
<code>?implemented_model_classes</code>. Models from 'lme4', 'tramME',
'glmnet' and 'mgcv' are also supported.</p>
</td></tr>
<tr><td><code id="dicp_+3A_verbose">verbose</code></td>
<td>
<p>Logical, whether output should be verbose (default <code>TRUE</code>).</p>
</td></tr>
<tr><td><code id="dicp_+3A_type">type</code></td>
<td>
<p>Character, type of invariance (<code>"residual"</code> or <code>"wald"</code>);
see <code>Details</code>.</p>
</td></tr>
<tr><td><code id="dicp_+3A_test">test</code></td>
<td>
<p>Character, specifies the invariance test to be used when
<code>type = "residual"</code>. The default is <code>"gcm.test"</code>. Other
implemented tests are <code>"HSIC"</code>, <code>"t.test"</code>, <code>"var.test"</code>,
and <code>"combined"</code>. Alternatively, a custom function for testing
invariance of the form <code>\(r, e, controls) {...}</code> can be supplied,
which outputs a list with entry <code>"p.value"</code>.</p>
</td></tr>
<tr><td><code id="dicp_+3A_controls">controls</code></td>
<td>
<p>Controls for the used tests and the overall procedure,
see <code><a href="#topic+dicp_controls">dicp_controls</a></code>.</p>
</td></tr>
<tr><td><code id="dicp_+3A_alpha">alpha</code></td>
<td>
<p>Level of invariance test, default <code>0.05</code>.</p>
</td></tr>
<tr><td><code id="dicp_+3A_baseline_fixed">baseline_fixed</code></td>
<td>
<p>Fixed baseline transformation, see
<code><a href="#topic+dicp_controls">dicp_controls</a></code>.</p>
</td></tr>
<tr><td><code id="dicp_+3A_greedy">greedy</code></td>
<td>
<p>Logical, whether to perform a greedy version of ICP (default is
<code>FALSE</code>).</p>
</td></tr>
<tr><td><code id="dicp_+3A_max_size">max_size</code></td>
<td>
<p>Numeric; maximum support size.</p>
</td></tr>
<tr><td><code id="dicp_+3A_mandatory">mandatory</code></td>
<td>
<p>A <code>formula</code> containing mandatory covariates, i.e.,
covariates which by domain knowledge are believed to be parents
of the response or are in another way required for the environment or
model to be valid (for instance, conditionally valid environments or
random effects in a mixed model).</p>
</td></tr>
<tr><td><code id="dicp_+3A_...">...</code></td>
<td>
<p>Further arguments passed to <code>modFUN</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>TRAMICP iterates over all subsets of covariates provided in <code>formula</code>
and performs an invariance test based on the conditional covariance between
score residuals and environments in <code>env</code> (<code>type = "residual"</code>) or
the Wald statistic testing for the presence of main and interaction effects
of the environments (<code>type = "wald"</code>). The algorithm outputs the
intersection over all non-rejected sets as an estimate of the causal parents.
</p>


<h3>Value</h3>

<p>Object of class <code>"dICP"</code>, containing
</p>

<ul>
<li><p><code>candidate_causal_predictors</code>: Character; intersection of all
non-rejected sets,
</p>
</li>
<li><p><code>set_pvals</code>: Numeric vector; set-specific p-values of the invariance
test,
</p>
</li>
<li><p><code>predictor_pvals</code>: Numeric vector; predictor-specific p-values,
</p>
</li>
<li><p><code>tests</code>: List of invariance tests.
</p>
</li></ul>



<h3>References</h3>

<p>Kook, L., Saengkyongam, S., Lundborg, A. R., Hothorn, T., &amp; Peters, J. (2023).
Model-based causal feature selection for general response types. arXiv
preprint. <a href="https://doi.org/10.48550/arXiv.2309.12833">doi:10.48550/arXiv.2309.12833</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(12)
d &lt;- dgp_dicp(n = 1e3, mod = "binary")
dicp(Y ~ X1 + X2 + X3, data = d, env = ~ E, modFUN = "glm",
     family = "binomial", type = "wald")

</code></pre>

<hr>
<h2 id='dicp_controls'>TRAMICP Controls</h2><span id='topic+dicp_controls'></span>

<h3>Description</h3>

<p>TRAMICP Controls
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dicp_controls(
  type = "residual",
  test = "gcm.test",
  baseline_fixed = TRUE,
  alpha = 0.05,
  method = "gamma",
  kernel = c("gaussian", "discrete"),
  B = 499,
  vcov = "vcov",
  teststat = "maximum",
  distribution = "asymptotic",
  xtrafo = coin::trafo,
  ytrafo = coin::trafo,
  residuals = "residuals",
  crossfit = getOption("crossfit", default = FALSE),
  stop_if_empty_set_invariant = getOption("stop_if_empty_set_invariant", default = FALSE),
  wald_test_interactions = getOption("wald_test_interactions", default = TRUE)
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="dicp_controls_+3A_type">type</code></td>
<td>
<p>Character, type of invariance (<code>"residual"</code> or <code>"wald"</code>);
see <code>Details</code>.</p>
</td></tr>
<tr><td><code id="dicp_controls_+3A_test">test</code></td>
<td>
<p>Character, specifies the invariance test to be used when
<code>type = "residual"</code>. The default is <code>"gcm.test"</code>. Other
implemented tests are <code>"HSIC"</code>, <code>"t.test"</code>, <code>"var.test"</code>,
and <code>"combined"</code>. Alternatively, a custom function for testing
invariance of the form <code>\(r, e, controls) {...}</code> can be supplied,
which outputs a list with entry <code>"p.value"</code>.</p>
</td></tr>
<tr><td><code id="dicp_controls_+3A_baseline_fixed">baseline_fixed</code></td>
<td>
<p>Logical; whether or not the baseline transformation
is allowed to vary with the environments. Only takes effect when
<code>type</code> is <code>"wald"</code>.</p>
</td></tr>
<tr><td><code id="dicp_controls_+3A_alpha">alpha</code></td>
<td>
<p>Level of invariance test, default <code>0.05</code>.</p>
</td></tr>
<tr><td><code id="dicp_controls_+3A_method">method</code></td>
<td>
<p>Only applies if <code>test = "HSIC"</code>. See
<code><a href="dHSIC.html#topic+dhsic.test">dhsic.test</a></code>.</p>
</td></tr>
<tr><td><code id="dicp_controls_+3A_kernel">kernel</code></td>
<td>
<p>Only applies if <code>test = "HSIC"</code>. See <code><a href="dHSIC.html#topic+dhsic.test">dhsic.test</a></code>.</p>
</td></tr>
<tr><td><code id="dicp_controls_+3A_b">B</code></td>
<td>
<p>For <code>test = "HSIC"</code>, see <code><a href="dHSIC.html#topic+dhsic.test">dhsic.test</a></code>.</p>
</td></tr>
<tr><td><code id="dicp_controls_+3A_vcov">vcov</code></td>
<td>
<p>(Name of) function for computing the variance-covariance matrix of a model.</p>
</td></tr>
<tr><td><code id="dicp_controls_+3A_teststat">teststat</code></td>
<td>
<p>Only applies if <code>test = "independence"</code>.
See <code><a href="coin.html#topic+independence_test">independence_test</a></code>.</p>
</td></tr>
<tr><td><code id="dicp_controls_+3A_distribution">distribution</code></td>
<td>
<p>Only applies if <code>test = "independence"</code>.
See <code><a href="coin.html#topic+independence_test">independence_test</a></code>.</p>
</td></tr>
<tr><td><code id="dicp_controls_+3A_xtrafo">xtrafo</code></td>
<td>
<p>Only applies if <code>test = "independence"</code>.
See <code><a href="coin.html#topic+independence_test">independence_test</a></code>.</p>
</td></tr>
<tr><td><code id="dicp_controls_+3A_ytrafo">ytrafo</code></td>
<td>
<p>Only applies if <code>test = "independence"</code>.
See <code><a href="coin.html#topic+independence_test">independence_test</a></code>.</p>
</td></tr>
<tr><td><code id="dicp_controls_+3A_residuals">residuals</code></td>
<td>
<p>Character or function; (Name of) function for computing
model residuals. The default is <code>stats::residuals</code> with methods
dispatch.</p>
</td></tr>
<tr><td><code id="dicp_controls_+3A_crossfit">crossfit</code></td>
<td>
<p>Logical; toggle for cross fitting when <code>type = "residual"</code>.</p>
</td></tr>
<tr><td><code id="dicp_controls_+3A_stop_if_empty_set_invariant">stop_if_empty_set_invariant</code></td>
<td>
<p>Logical; <code>dicp</code> halts if the empty
set is not rejected (the resulting intersection will always be empty).
Default is <code>FALSE</code> and can be over-written by setting
<code>options(stop_if_empty_set_invariant = TRUE)</code>.</p>
</td></tr>
<tr><td><code id="dicp_controls_+3A_wald_test_interactions">wald_test_interactions</code></td>
<td>
<p>Logical; whether to test for interactions between
residuals and environments when using <code>type = "wald"</code>
(<code>wald_test_interactions = TRUE</code>, the default) or main effects only
(<code>wald_test_interactions = FALSE</code>).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>List of dicp controls containing the evaluated arguments from above.
</p>

<hr>
<h2 id='implemented_model_classes'>Aliases for implemented model classes</h2><span id='topic+implemented_model_classes'></span><span id='topic+BoxCoxICP'></span><span id='topic+SurvregICP'></span><span id='topic+survregICP'></span><span id='topic+coxphICP'></span><span id='topic+ColrICP'></span><span id='topic+CoxphICP'></span><span id='topic+LehmannICP'></span><span id='topic+LmICP'></span><span id='topic+lmICP'></span><span id='topic+PolrICP'></span><span id='topic+polrICP'></span><span id='topic+glmICP'></span><span id='topic+cotramICP'></span><span id='topic+rangerICP'></span><span id='topic+survforestICP'></span><span id='topic+qrfICP'></span>

<h3>Description</h3>

<p>ICP for Box-Cox-type transformed normal regression, parametric
and semiparametric survival models, continuous outcome logistic
regression, linear regression, cumulative ordered regression, generalized
linear models; and nonparametric ICP via ranger. While TRAMICP based on
quantile and survival random forests is also supported, for these methods
it comes without theoretical guarantees as of yet.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>BoxCoxICP(
  formula,
  data,
  env,
  verbose = TRUE,
  type = "residual",
  test = "gcm.test",
  controls = NULL,
  alpha = 0.05,
  baseline_fixed = TRUE,
  greedy = FALSE,
  max_size = NULL,
  mandatory = NULL,
  ...
)

SurvregICP(
  formula,
  data,
  env,
  verbose = TRUE,
  type = "residual",
  test = "gcm.test",
  controls = NULL,
  alpha = 0.05,
  baseline_fixed = TRUE,
  greedy = FALSE,
  max_size = NULL,
  mandatory = NULL,
  ...
)

survregICP(
  formula,
  data,
  env,
  verbose = TRUE,
  type = "residual",
  test = "gcm.test",
  controls = NULL,
  alpha = 0.05,
  baseline_fixed = TRUE,
  greedy = FALSE,
  max_size = NULL,
  mandatory = NULL,
  ...
)

coxphICP(
  formula,
  data,
  env,
  verbose = TRUE,
  type = "residual",
  test = "gcm.test",
  controls = NULL,
  alpha = 0.05,
  baseline_fixed = TRUE,
  greedy = FALSE,
  max_size = NULL,
  mandatory = NULL,
  ...
)

ColrICP(
  formula,
  data,
  env,
  verbose = TRUE,
  type = "residual",
  test = "gcm.test",
  controls = NULL,
  alpha = 0.05,
  baseline_fixed = TRUE,
  greedy = FALSE,
  max_size = NULL,
  mandatory = NULL,
  ...
)

CoxphICP(
  formula,
  data,
  env,
  verbose = TRUE,
  type = "residual",
  test = "gcm.test",
  controls = NULL,
  alpha = 0.05,
  baseline_fixed = TRUE,
  greedy = FALSE,
  max_size = NULL,
  mandatory = NULL,
  ...
)

LehmannICP(
  formula,
  data,
  env,
  verbose = TRUE,
  type = "residual",
  test = "gcm.test",
  controls = NULL,
  alpha = 0.05,
  baseline_fixed = TRUE,
  greedy = FALSE,
  max_size = NULL,
  mandatory = NULL,
  ...
)

LmICP(
  formula,
  data,
  env,
  verbose = TRUE,
  type = "residual",
  test = "gcm.test",
  controls = NULL,
  alpha = 0.05,
  baseline_fixed = TRUE,
  greedy = FALSE,
  max_size = NULL,
  mandatory = NULL,
  ...
)

lmICP(
  formula,
  data,
  env,
  verbose = TRUE,
  type = "residual",
  test = "gcm.test",
  controls = NULL,
  alpha = 0.05,
  baseline_fixed = TRUE,
  greedy = FALSE,
  max_size = NULL,
  mandatory = NULL,
  ...
)

PolrICP(
  formula,
  data,
  env,
  verbose = TRUE,
  type = "residual",
  test = "gcm.test",
  controls = NULL,
  alpha = 0.05,
  baseline_fixed = TRUE,
  greedy = FALSE,
  max_size = NULL,
  mandatory = NULL,
  ...
)

polrICP(
  formula,
  data,
  env,
  verbose = TRUE,
  type = "residual",
  test = "gcm.test",
  controls = NULL,
  alpha = 0.05,
  baseline_fixed = TRUE,
  greedy = FALSE,
  max_size = NULL,
  mandatory = NULL,
  ...
)

glmICP(
  formula,
  data,
  env,
  verbose = TRUE,
  type = "residual",
  test = "gcm.test",
  controls = NULL,
  alpha = 0.05,
  baseline_fixed = TRUE,
  greedy = FALSE,
  max_size = NULL,
  mandatory = NULL,
  ...
)

cotramICP(
  formula,
  data,
  env,
  verbose = TRUE,
  type = "residual",
  test = "gcm.test",
  controls = NULL,
  alpha = 0.05,
  baseline_fixed = TRUE,
  greedy = FALSE,
  max_size = NULL,
  mandatory = NULL,
  ...
)

rangerICP(
  formula,
  data,
  env,
  verbose = TRUE,
  type = "residual",
  test = "gcm.test",
  controls = NULL,
  alpha = 0.05,
  baseline_fixed = TRUE,
  greedy = FALSE,
  max_size = NULL,
  mandatory = NULL,
  ...
)

survforestICP(
  formula,
  data,
  env,
  verbose = TRUE,
  type = "residual",
  test = "gcm.test",
  controls = NULL,
  alpha = 0.05,
  baseline_fixed = TRUE,
  greedy = FALSE,
  max_size = NULL,
  mandatory = NULL,
  ...
)

qrfICP(
  formula,
  data,
  env,
  verbose = TRUE,
  type = "residual",
  test = "gcm.test",
  controls = NULL,
  alpha = 0.05,
  baseline_fixed = TRUE,
  greedy = FALSE,
  max_size = NULL,
  mandatory = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="implemented_model_classes_+3A_formula">formula</code></td>
<td>
<p>A <code>formula</code> including response and covariate terms.</p>
</td></tr>
<tr><td><code id="implemented_model_classes_+3A_data">data</code></td>
<td>
<p>A <code>data.frame</code> containing response and explanatory variables.</p>
</td></tr>
<tr><td><code id="implemented_model_classes_+3A_env">env</code></td>
<td>
<p>A <code>formula</code> specifying the environment variables (see details).</p>
</td></tr>
<tr><td><code id="implemented_model_classes_+3A_verbose">verbose</code></td>
<td>
<p>Logical, whether output should be verbose (default <code>TRUE</code>).</p>
</td></tr>
<tr><td><code id="implemented_model_classes_+3A_type">type</code></td>
<td>
<p>Character, type of invariance (<code>"residual"</code> or <code>"wald"</code>);
see <code>Details</code>.</p>
</td></tr>
<tr><td><code id="implemented_model_classes_+3A_test">test</code></td>
<td>
<p>Character, specifies the invariance test to be used when
<code>type = "residual"</code>. The default is <code>"gcm.test"</code>. Other
implemented tests are <code>"HSIC"</code>, <code>"t.test"</code>, <code>"var.test"</code>,
and <code>"combined"</code>. Alternatively, a custom function for testing
invariance of the form <code>\(r, e, controls) {...}</code> can be supplied,
which outputs a list with entry <code>"p.value"</code>.</p>
</td></tr>
<tr><td><code id="implemented_model_classes_+3A_controls">controls</code></td>
<td>
<p>Controls for the used tests and the overall procedure,
see <code><a href="#topic+dicp_controls">dicp_controls</a></code>.</p>
</td></tr>
<tr><td><code id="implemented_model_classes_+3A_alpha">alpha</code></td>
<td>
<p>Level of invariance test, default <code>0.05</code>.</p>
</td></tr>
<tr><td><code id="implemented_model_classes_+3A_baseline_fixed">baseline_fixed</code></td>
<td>
<p>Fixed baseline transformation, see
<code><a href="#topic+dicp_controls">dicp_controls</a></code>.</p>
</td></tr>
<tr><td><code id="implemented_model_classes_+3A_greedy">greedy</code></td>
<td>
<p>Logical, whether to perform a greedy version of ICP (default is
<code>FALSE</code>).</p>
</td></tr>
<tr><td><code id="implemented_model_classes_+3A_max_size">max_size</code></td>
<td>
<p>Numeric; maximum support size.</p>
</td></tr>
<tr><td><code id="implemented_model_classes_+3A_mandatory">mandatory</code></td>
<td>
<p>A <code>formula</code> containing mandatory covariates, i.e.,
covariates which by domain knowledge are believed to be parents
of the response or are in another way required for the environment or
model to be valid (for instance, conditionally valid environments or
random effects in a mixed model).</p>
</td></tr>
<tr><td><code id="implemented_model_classes_+3A_...">...</code></td>
<td>
<p>Further arguments passed to <code>modFUN</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Object of type <code>"dICP"</code>. See <code><a href="#topic+dicp">dicp</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(123)
d &lt;- dgp_dicp(mod = "boxcox", n = 300)
BoxCoxICP(Y ~ X2, data = d, env = ~ E, type = "wald")


set.seed(123)
d &lt;- dgp_dicp(mod = "weibull", n = 300)
SurvregICP(Y ~ X1 + X2 + X3, data = d, env = ~ E)
### or
library("survival")
d$Y &lt;- Surv(d$Y)
survregICP(Y ~ X1 + X2 + X3, data = d, env = ~ E)
CoxphICP(Y ~ X2, data = d, env = ~ E)
coxphICP(Y ~ X2, data = d, env = ~ E)



set.seed(123)
d &lt;- dgp_dicp(mod = "colr", n = 300)
ColrICP(Y ~ X1 + X2 + X3, data = d, env = ~ E)



set.seed(123)
d &lt;- dgp_dicp(mod = "coxph", n = 300)
LehmannICP(Y ~ X2, data = d, env = ~ E)



set.seed(123)
d &lt;- dgp_dicp(mod = "lm", n = 300)
LmICP(Y ~ X1 + X2 + X3, data = d, env = ~ E)
### or
lmICP(Y ~ X1 + X2 + X3, data = d, env = ~ E)



set.seed(123)
d &lt;- dgp_dicp(mod = "polr", n = 300)
PolrICP(Y ~ X1 + X2 + X3, data = d, env = ~ E)
### or
PolrICP(Y ~ X1 + X2 + X3, data = d, env = ~ E)



set.seed(123)
d &lt;- dgp_dicp(mod = "binary", n = 300)
glmICP(Y ~ X1 + X2 + X3, data = d, env = ~ E, family = "binomial")



set.seed(123)
d &lt;- dgp_dicp(mod = "cotram", n = 300)
cotramICP(Y ~ X2, data = d, env = ~ E)



set.seed(123)
d &lt;- dgp_dicp(mod = "binary", n = 300)
rangerICP(Y ~ X1 + X2 + X3, data = d, env = ~ E)



set.seed(12)
d &lt;- dgp_dicp(mod = "coxph", n = 3e2)
d$Y &lt;- survival::Surv(d$Y, sample(0:1, 3e2, TRUE, prob = c(0.1, 0.9)))
survforestICP(Y ~ X1 + X2 + X3, data = d, env = ~ E)



set.seed(12)
d &lt;- dgp_dicp(mod = "boxcox", n = 3e2)
qrfICP(Y ~ X1 + X2 + X3, data = d, env = ~ E)


</code></pre>

<hr>
<h2 id='invariant_sets'>Return invariant sets</h2><span id='topic+invariant_sets'></span>

<h3>Description</h3>

<p>Return invariant sets
</p>


<h3>Usage</h3>

<pre><code class='language-R'>invariant_sets(object, with_pvalues = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="invariant_sets_+3A_object">object</code></td>
<td>
<p>Object of class <code>"dICP"</code>.</p>
</td></tr>
<tr><td><code id="invariant_sets_+3A_with_pvalues">with_pvalues</code></td>
<td>
<p>Logical; whether to also return p-values of invariance
tests for the non-rejected sets.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns vector of all non-rejected sets. With
<code>with_pvalues = TRUE</code>, a named vector of p-values is returned.
Returns <code>named numeric(0)</code> if there are no invariant sets.
</p>

<hr>
<h2 id='pvalues'>Extract set and predictor p-values from tramicp outputs</h2><span id='topic+pvalues'></span>

<h3>Description</h3>

<p>Extract set and predictor p-values from tramicp outputs
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pvalues(object, which = c("predictor", "set", "all"))
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="pvalues_+3A_object">object</code></td>
<td>
<p>Object of class <code>'dicp'</code></p>
</td></tr>
<tr><td><code id="pvalues_+3A_which">which</code></td>
<td>
<p>Which p-values to return, <code>"predictor"</code> returns p-values
for individual predictors, <code>"set"</code> for each subset of the predictors,
<code>"all"</code> returns a list of both</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Predictor p-values are computed from the set p-values as follows:
For each predictor j as the largest p-value of all sets not containing j.
</p>


<h3>Value</h3>

<p>Numeric vector (or list in case <code>which = "all"</code>) of p-values
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(123)
d &lt;- dgp_dicp(n = 1e3, mod = "polr")
res &lt;- polrICP(Y ~ X1 + X2 + X3, data = d, env = ~ E, type = "wald")
pvalues(res, which = "predictor")
pvalues(res, which = "set")
pvalues(res, which = "all")

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
