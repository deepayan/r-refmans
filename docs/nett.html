<!DOCTYPE html><html><head><title>Help for package nett</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {nett}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#+25+26gt+3B+25'><p>Pipe operator</p></a></li>
<li><a href='#adj_spec_test'><p>Adjusted spectral test</p></a></li>
<li><a href='#bethe_hessian_select'><p>Beth-Hessian model selection</p></a></li>
<li><a href='#compute_block_sums'><p>Block sum of an adjacency matrix</p></a></li>
<li><a href='#compute_confusion_matrix'><p>Compute confusion matrix</p></a></li>
<li><a href='#compute_mutual_info'><p>Compute normalized mutual information (NMI)</p></a></li>
<li><a href='#estim_dcsbm'><p>Estimate model parameters of a DCSBM</p></a></li>
<li><a href='#eval_dcsbm_bic'><p>Compute BIC score</p></a></li>
<li><a href='#eval_dcsbm_like'><p>Log likelihood of a DCSBM (fast with poi = TRUE)</p></a></li>
<li><a href='#eval_dcsbm_loglr'><p>Log-likelihood ratio of two DCSBMs (fast with poi = TRUE)</p></a></li>
<li><a href='#extract_largest_cc'><p>Extract largest component</p></a></li>
<li><a href='#extract_low_deg_comp'><p>Extract low-degree component</p></a></li>
<li><a href='#fast_cpl'><p>CPL algorithm for community detection (fast)</p></a></li>
<li><a href='#fast_sbm'><p>Sample from a SBM (fast)</p></a></li>
<li><a href='#gen_rand_conn'><p>Generate randomly permuted connectivity matrix</p></a></li>
<li><a href='#get_dcsbm_exav_deg'><p>Calculate the expected average degree of a DCSBM</p></a></li>
<li><a href='#label_mat2vec'><p>Convert label matrix to vector</p></a></li>
<li><a href='#label_vec2mat'><p>Convert label vector to matrix</p></a></li>
<li><a href='#nac_test'><p>NAC test</p></a></li>
<li><a href='#plot_deg_dist'><p>Plot degree distribution</p></a></li>
<li><a href='#plot_net'><p>Plot a network</p></a></li>
<li><a href='#plot_roc'><p>Plot ROC curves</p></a></li>
<li><a href='#plot_smooth_profile'><p>Plot community profiles</p></a></li>
<li><a href='#polblogs'><p>Political blogs network</p></a></li>
<li><a href='#pp_conn'><p>Generate planted partition (PP) connectivity matrix</p></a></li>
<li><a href='#printf'><p>The usual &quot;printf&quot; function</p></a></li>
<li><a href='#rsymperm'><p>Generate random symmetric permutation matrix</p></a></li>
<li><a href='#sample_dcer'><p>Sample from a DCER</p></a></li>
<li><a href='#sample_dclvm'><p>Sample from a DCLVM</p></a></li>
<li><a href='#sample_dcpp'><p>Sample from a DCPP</p></a></li>
<li><a href='#sample_dcsbm'><p>Sample from a DCSBM</p></a></li>
<li><a href='#sample_tdcsbm'><p>Sample truncated DCSBM (fast)</p></a></li>
<li><a href='#simulate_roc'><p>Simulate data to estimate ROC curves</p></a></li>
<li><a href='#sinkhorn_knopp'><p>Sinkhorn&ndash;Knopp matrix scaling</p></a></li>
<li><a href='#snac_resample'><p>Resampled SNAC+</p></a></li>
<li><a href='#snac_select'><p>Estimate community number with SNAC+</p></a></li>
<li><a href='#snac_test'><p>SNAC test</p></a></li>
<li><a href='#spec_clust'><p>Spectral clustering (fast)</p></a></li>
<li><a href='#spec_repr'><p>Spectral Representation</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Title:</td>
<td>Network Analysis and Community Detection</td>
</tr>
<tr>
<td>Version:</td>
<td>1.0.0</td>
</tr>
<tr>
<td>Description:</td>
<td>Features tools for the network data analysis and community detection. 
    Provides multiple methods for fitting, model selection and goodness-of-fit testing in degree-corrected stochastic blocks models. 
    Most of the computations are fast and scalable for sparse networks, esp. for Poisson versions of the models.
    Implements the following: 
    Amini, Chen, Bickel and Levina (2013) &lt;<a href="https://doi.org/10.1214%2F13-AOS1138">doi:10.1214/13-AOS1138</a>&gt;
    Bickel and Sarkar (2015) &lt;<a href="https://doi.org/10.1111%2Frssb.12117">doi:10.1111/rssb.12117</a>&gt;
    Lei (2016) &lt;<a href="https://doi.org/10.1214%2F15-AOS1370">doi:10.1214/15-AOS1370</a>&gt;
    Wang and Bickel (2017) &lt;<a href="https://doi.org/10.1214%2F16-AOS1457">doi:10.1214/16-AOS1457</a>&gt;
    Zhang and Amini (2020) &lt;<a href="https://doi.org/10.48550/arXiv.2012.15047">doi:10.48550/arXiv.2012.15047</a>&gt;
    Le and Levina (2022) &lt;<a href="https://doi.org/10.1214%2F21-EJS1971">doi:10.1214/21-EJS1971</a>&gt;.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://opensource.org/licenses/mit-license.php">MIT</a> + file LICENSE</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.1</td>
</tr>
<tr>
<td>Suggests:</td>
<td>testthat, knitr, rmarkdown, igraph, ggplot2, dplyr, tidyr,
tibble, mixtools, EnvStats, purrr, RSpectra</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 2.10)</td>
</tr>
<tr>
<td>Imports:</td>
<td>magrittr, Rcpp, Matrix, foreach, methods, stats, grDevices,
graphics</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>Rcpp, RcppArmadillo</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/aaamini/nett">https://github.com/aaamini/nett</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/aaamini/nett/issues">https://github.com/aaamini/nett/issues</a></td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2022-11-08 04:01:28 UTC; linfanzhang</td>
</tr>
<tr>
<td>Author:</td>
<td>Arash A. Amini <a href="https://orcid.org/0000-0002-2808-8310"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cre],
  Linfan Zhang [aut]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Arash A. Amini &lt;aaamini@ucla.edu&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2022-11-09 10:50:05 UTC</td>
</tr>
</table>
<hr>
<h2 id='+25+26gt+3B+25'>Pipe operator</h2><span id='topic++25+3E+25'></span>

<h3>Description</h3>

<p>See <code>magrittr::<a href="magrittr.html#topic+pipe">%&gt;%</a></code> for details.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lhs %&gt;% rhs
</code></pre>


<h3>Value</h3>

<p>See <code>magrittr::<a href="magrittr.html#topic+pipe">%&gt;%</a></code>
</p>

<hr>
<h2 id='adj_spec_test'>Adjusted spectral test</h2><span id='topic+adj_spec_test'></span>

<h3>Description</h3>

<p>The adjusted spectral goodness-of-fit test based on Poisson DCSBM.
</p>
<p>The test is a natural extension on Lei's work of testing goodness-of-fit
for SBM. The residual matrix <code class="reqn">\tilde{A}</code> is computed from the DCSBM estimation
expectation of <code>A</code>. To speed up computation, the residual matrix uses Poisson variance instead.
Specifically,
</p>
<p style="text-align: center;"><code class="reqn">
 	\tilde{A}_{ij} = (A_{ij} - \hat P_{ij}) / ( n \hat P_{ij})^{1/2}, \quad
 	\hat P_{ij} = \hat \theta_i \hat \theta_j \hat B_{\hat{z}_i, \hat{z}_j} \cdot 1\{i \neq j\}
</code>
</p>

<p>where <code class="reqn">\hat{\theta}</code> and <code class="reqn">\hat{B}</code> are computed using <a href="#topic+estim_dcsbm">estim_dcsbm</a> if not provided.
</p>
<p>Adjusted spectral test
</p>


<h3>Usage</h3>

<pre><code class='language-R'>adj_spec_test(
  A,
  K,
  z = NULL,
  DC = TRUE,
  theta = NULL,
  B = NULL,
  cluster_fct = spec_clust,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="adj_spec_test_+3A_a">A</code></td>
<td>
<p>adjacency matrix.</p>
</td></tr>
<tr><td><code id="adj_spec_test_+3A_k">K</code></td>
<td>
<p>number of communities.</p>
</td></tr>
<tr><td><code id="adj_spec_test_+3A_z">z</code></td>
<td>
<p>label vector for rows of adjacency matrix. If not given, will be calculated by
the spectral clustering.</p>
</td></tr>
<tr><td><code id="adj_spec_test_+3A_dc">DC</code></td>
<td>
<p>whether or not include degree correction in the parameter estimation.</p>
</td></tr>
<tr><td><code id="adj_spec_test_+3A_theta">theta</code></td>
<td>
<p>give the propensity parameter directly.</p>
</td></tr>
<tr><td><code id="adj_spec_test_+3A_b">B</code></td>
<td>
<p>give the connectivity matrix directly.</p>
</td></tr>
<tr><td><code id="adj_spec_test_+3A_cluster_fct">cluster_fct</code></td>
<td>
<p>community detection function to get <code>z</code> , by default using <a href="#topic+spec_clust">spec_clust</a>.</p>
</td></tr>
<tr><td><code id="adj_spec_test_+3A_...">...</code></td>
<td>
<p>additional arguments for <code>cluster_fct</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Adjusted spectral test statistics.
</p>


<h3>References</h3>

<p>Details of modification can be seen at <a href="https://arxiv.org/abs/2012.15047">Adjusted chi-square test for degree-corrected block models</a>,
Linfan Zhang, Arash A. Amini, arXiv preprint arXiv:2012.15047, 2020.
</p>
<p>The original spectral test is from <a href="https://projecteuclid.org/euclid.aos/1452004791">A goodness-of-fit test for stochastic block models</a>
Lei, Jing, Ann. Statist. 44 (2016), no. 1, 401&ndash;424. doi:10.1214/15-AOS1370.
</p>

<hr>
<h2 id='bethe_hessian_select'>Beth-Hessian model selection</h2><span id='topic+bethe_hessian_select'></span>

<h3>Description</h3>

<p>Estimate the number of communities under block models by using the spectral
properties of network Beth-Hessian matrix with moment correction.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bethe_hessian_select(A, Kmax)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bethe_hessian_select_+3A_a">A</code></td>
<td>
<p>adjacency matrix.</p>
</td></tr>
<tr><td><code id="bethe_hessian_select_+3A_kmax">Kmax</code></td>
<td>
<p>the maximum number of communities to check.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of result
</p>
<table>
<tr><td><code>K</code></td>
<td>
<p>estimated the number of communities</p>
</td></tr>
<tr><td><code>rho</code></td>
<td>
<p>eigenvalues of the Beth-Hessian matrix</p>
</td></tr>
</table>


<h3>References</h3>

<p><a href="https://arxiv.org/abs/1507.00827">Estimating the number of communities in networks by spectral methods</a>,
Can M. Le, Elizaveta Levina, arXiv preprint arXiv:1507.00827, 2015
</p>

<hr>
<h2 id='compute_block_sums'>Block sum of an adjacency matrix</h2><span id='topic+compute_block_sums'></span>

<h3>Description</h3>

<p>Compute the block sum of an adjacency matrix given a label vector.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>compute_block_sums(A, z)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="compute_block_sums_+3A_a">A</code></td>
<td>
<p>adjacency matrix.</p>
</td></tr>
<tr><td><code id="compute_block_sums_+3A_z">z</code></td>
<td>
<p>label vector.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A K x L matrix with (k,l)-th element as <code class="reqn">sum_{i,j} A_{i,j} 1{z_i = k, z_j = l}</code>
</p>

<hr>
<h2 id='compute_confusion_matrix'>Compute confusion matrix</h2><span id='topic+compute_confusion_matrix'></span>

<h3>Description</h3>

<p>Compute confusion matrix
</p>


<h3>Usage</h3>

<pre><code class='language-R'>compute_confusion_matrix(z, y, K = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="compute_confusion_matrix_+3A_z">z</code></td>
<td>
<p>a label vector</p>
</td></tr>
<tr><td><code id="compute_confusion_matrix_+3A_y">y</code></td>
<td>
<p>a label vector</p>
</td></tr>
<tr><td><code id="compute_confusion_matrix_+3A_k">K</code></td>
<td>
<p>number of labels in both <code>z</code> and <code>y</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>K</code>x<code>K</code> confusion matrix between <code>z</code> and <code>y</code>
</p>

<hr>
<h2 id='compute_mutual_info'>Compute normalized mutual information (NMI)</h2><span id='topic+compute_mutual_info'></span>

<h3>Description</h3>

<p>Compute the NMI between two label vectors with the same cluster number
</p>


<h3>Usage</h3>

<pre><code class='language-R'>compute_mutual_info(z, y)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="compute_mutual_info_+3A_z">z</code></td>
<td>
<p>a label vector</p>
</td></tr>
<tr><td><code id="compute_mutual_info_+3A_y">y</code></td>
<td>
<p>a label vector</p>
</td></tr>
</table>


<h3>Value</h3>

<p>NMI between <code>z</code> and <code>y</code>
</p>

<hr>
<h2 id='estim_dcsbm'>Estimate model parameters of a DCSBM</h2><span id='topic+estim_dcsbm'></span>

<h3>Description</h3>

<p>Compute the block sum of an adjacency matrix given a label vector.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>estim_dcsbm(A, z)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="estim_dcsbm_+3A_a">A</code></td>
<td>
<p>adjacency matrix.</p>
</td></tr>
<tr><td><code id="estim_dcsbm_+3A_z">z</code></td>
<td>
<p>label vector.</p>
</td></tr>
</table>


<h3>Details</h3>

<p style="text-align: center;"><code class="reqn">\hat B_{k\ell} = \frac{N_{k\ell}(\hat z)}{m_{k\ell} (\hat z)}, \quad \hat \theta_i =  \frac{n_{\hat z_i}(\hat z) d_i}{\sum_{j : \hat z_j = \hat z_i} d_i}</code>
</p>

<p>where <code class="reqn">N_{k\ell}(\hat{z})</code> is the sum of the elements of <code>A</code> in block <code class="reqn">(k,\ell)</code>
specified by labels <code class="reqn">\hat z</code>, <code class="reqn">n_k(\hat z)</code> is the number of nodes in community <code class="reqn">k</code>
according to <code class="reqn">\hat z</code> and <code class="reqn">m_{k\ell}(\hat z) = n_k(\hat z) (n_\ell(\hat z) - 1\{k = \ell\})</code>
</p>


<h3>Value</h3>

<p>A list of result
</p>
<table>
<tr><td><code>B</code></td>
<td>
<p>estimated connectivity matrix.</p>
</td></tr>
<tr><td><code>theta</code></td>
<td>
<p>estimated node propensity parameter.</p>
</td></tr>
</table>

<hr>
<h2 id='eval_dcsbm_bic'>Compute BIC score</h2><span id='topic+eval_dcsbm_bic'></span>

<h3>Description</h3>

<p>compute BIC score when fitting a DCSBM to network data
</p>


<h3>Usage</h3>

<pre><code class='language-R'>eval_dcsbm_bic(A, z, K, poi)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="eval_dcsbm_bic_+3A_a">A</code></td>
<td>
<p>adjacency matrix</p>
</td></tr>
<tr><td><code id="eval_dcsbm_bic_+3A_z">z</code></td>
<td>
<p>label vector</p>
</td></tr>
<tr><td><code id="eval_dcsbm_bic_+3A_k">K</code></td>
<td>
<p>number of community in <code>z</code></p>
</td></tr>
<tr><td><code id="eval_dcsbm_bic_+3A_poi">poi</code></td>
<td>
<p>whether to use Poisson version of likelihood</p>
</td></tr>
</table>


<h3>Details</h3>

<p>the BIC score is calculated by -2*log likelihood minus <code class="reqn">K\times(K + 1)\times log(n)</code>
</p>


<h3>Value</h3>

<p>BIC score
</p>


<h3>References</h3>

<p>BIC score is originally proposed in
<a href="https://projecteuclid.org/euclid.aos/1494921948">Likelihood-based model selection for stochastic block models</a>
Wang, YX Rachel, Peter J. Bickel, The Annals of Statistics 45, no. 2 (2017): 500-528.
</p>
<p>The details of modified implementation can be found in
<a href="https://arxiv.org/abs/2012.15047">Adjusted chi-square test for degree-corrected block models</a>,
Linfan Zhang, Arash A. Amini, arXiv preprint arXiv:2012.15047, 2020.
</p>


<h3>See Also</h3>

<p><a href="#topic+eval_dcsbm_like">eval_dcsbm_like</a>, <a href="#topic+eval_dcsbm_loglr">eval_dcsbm_loglr</a>
</p>

<hr>
<h2 id='eval_dcsbm_like'>Log likelihood of a DCSBM (fast with poi = TRUE)</h2><span id='topic+eval_dcsbm_like'></span>

<h3>Description</h3>

<p>Compute the log likelihood of a DCSBM, using estimated parameters
B, theta based on the given label vector
</p>


<h3>Usage</h3>

<pre><code class='language-R'>eval_dcsbm_like(A, z, poi = TRUE, eps = 1e-06)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="eval_dcsbm_like_+3A_a">A</code></td>
<td>
<p>adjacency matrix</p>
</td></tr>
<tr><td><code id="eval_dcsbm_like_+3A_z">z</code></td>
<td>
<p>label vector</p>
</td></tr>
<tr><td><code id="eval_dcsbm_like_+3A_poi">poi</code></td>
<td>
<p>whether to use Poisson version of likelihood</p>
</td></tr>
<tr><td><code id="eval_dcsbm_like_+3A_eps">eps</code></td>
<td>
<p>truncation threshold for the Bernoulli likelihood,
used when parameter phat is close to 1 or 0.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The log likelihood is calculated by
</p>
<p style="text-align: center;"><code class="reqn">\ell(\hat B,\hat \theta, \hat \pi, \hat z \mid A) =
\sum_i \log \hat \pi_{z_i} + \sum_{i &lt; j} \phi(A_{ij};\hat \theta_i \hat \theta_j \hat B_{\hat{z}_i \hat{z}_j} )</code>
</p>

<p>where <code class="reqn">\hat B</code>, <code class="reqn">\hat \theta</code> is calculated by <a href="#topic+estim_dcsbm">estim_dcsbm</a>,
<code class="reqn">\hat{\pi}_k</code> is the proportion of nodes in community k.
</p>


<h3>Value</h3>

<p>log likelihood of a DCSBM
</p>


<h3>See Also</h3>

<p><a href="#topic+eval_dcsbm_loglr">eval_dcsbm_loglr</a>, <a href="#topic+eval_dcsbm_bic">eval_dcsbm_bic</a>
</p>

<hr>
<h2 id='eval_dcsbm_loglr'>Log-likelihood ratio of two DCSBMs (fast with poi = TRUE)</h2><span id='topic+eval_dcsbm_loglr'></span>

<h3>Description</h3>

<p>Computes the log-likelihood ratio of one DCSBM relative to another, using
estimated parameters <code>B</code> and <code>theta</code> based on the given label vectors.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>eval_dcsbm_loglr(A, labels, poi = TRUE, eps = 1e-06)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="eval_dcsbm_loglr_+3A_a">A</code></td>
<td>
<p>adjacency matrix</p>
</td></tr>
<tr><td><code id="eval_dcsbm_loglr_+3A_labels">labels</code></td>
<td>
<p>a matrix with two columns representing two different label
vectors</p>
</td></tr>
<tr><td><code id="eval_dcsbm_loglr_+3A_poi">poi</code></td>
<td>
<p>whether to use Poisson version of likelihood (instead of Bernoulli)</p>
</td></tr>
<tr><td><code id="eval_dcsbm_loglr_+3A_eps">eps</code></td>
<td>
<p>truncation threshold for the Bernoulli likelihood, used when
parameter phat is close to 1 or 0.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The log-likehood ratio is computed between two DCSBMs specified by the columns
of <code>labels</code>. The function computes the log-likelihood ratio of the model with
<code>labels[ , 2]</code> w.r.t. the model with <code>labels[ , 1]</code>. This is often used with two
label vectors fitted using different number of communities (say <code>K</code> and <code>K+1</code>).
</p>
<p>When <code>poi</code> is set to <code>TRUE</code>, the function uses fast sparse matrix computations
and is scalable to large sparse networks.
</p>


<h3>Value</h3>

<p>log-likelihood ratio
</p>


<h3>See Also</h3>

<p><a href="#topic+eval_dcsbm_like">eval_dcsbm_like</a>, <a href="#topic+eval_dcsbm_bic">eval_dcsbm_bic</a>
</p>

<hr>
<h2 id='extract_largest_cc'>Extract largest component</h2><span id='topic+extract_largest_cc'></span>

<h3>Description</h3>

<p>Extract the largest connected component of a network
</p>


<h3>Usage</h3>

<pre><code class='language-R'>extract_largest_cc(gr, mode = "weak")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="extract_largest_cc_+3A_gr">gr</code></td>
<td>
<p>The network as an igraph object</p>
</td></tr>
<tr><td><code id="extract_largest_cc_+3A_mode">mode</code></td>
<td>
<p>Type of connected component (&quot;weak&quot;|&quot;strong&quot;)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An igraph object
</p>

<hr>
<h2 id='extract_low_deg_comp'>Extract low-degree component</h2><span id='topic+extract_low_deg_comp'></span>

<h3>Description</h3>

<p>Extract a low-degree connected component of a network
</p>


<h3>Usage</h3>

<pre><code class='language-R'>extract_low_deg_comp(g, deg_prec = 0.75, verb = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="extract_low_deg_comp_+3A_g">g</code></td>
<td>
<p>The network as an igraph object</p>
</td></tr>
<tr><td><code id="extract_low_deg_comp_+3A_deg_prec">deg_prec</code></td>
<td>
<p>The cut-off degree percentile</p>
</td></tr>
<tr><td><code id="extract_low_deg_comp_+3A_verb">verb</code></td>
<td>
<p>Whether to be verbose (TRUE|FALSE)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An igraph object
</p>

<hr>
<h2 id='fast_cpl'>CPL algorithm for community detection (fast)</h2><span id='topic+fast_cpl'></span>

<h3>Description</h3>

<p>The Conditional Pseudo-Likelihood (CPL) algorithm for fitting
degree-corrected block models
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fast_cpl(Amat, K, ilabels = NULL, niter = 10)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fast_cpl_+3A_amat">Amat</code></td>
<td>
<p>adjacency matrix of the network</p>
</td></tr>
<tr><td><code id="fast_cpl_+3A_k">K</code></td>
<td>
<p>desired number of communities</p>
</td></tr>
<tr><td><code id="fast_cpl_+3A_ilabels">ilabels</code></td>
<td>
<p>initial label vector (if not provided, initial labels are
estimated using <a href="#topic+spec_clust">spec_clust</a>)</p>
</td></tr>
<tr><td><code id="fast_cpl_+3A_niter">niter</code></td>
<td>
<p>number of iterations</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function implements the CPL algorithm as described in the paper below. It
relies on the <code>mixtools</code> package for fitting a mixture of multinomials to a
block compression of the adjacency matrix based on the estimated labels and
then reiterates.
</p>
<p>Technically, <code>fast_cpl</code> fits a stochastic block model (SBM) conditional on
the observed node degrees,to account for the degree heterogeneity within
communities that is not modeled well in SBM. CPL can also be used to
effectively estimate the parameters of the degree-corrected block model
(DCSBM).
</p>
<p>The code is an adaptation of the original R code by Aiyou Chen with slight
simplifications.
</p>


<h3>Value</h3>

<p>Estimated community label vector.
</p>


<h3>References</h3>

<p>For more details, see <a href="https://projecteuclid.org/euclid.aos/1382547514">Pseudo-likelihood methods for community detection in large sparse networks</a>, A. A. Amini, A.
Chen, P. J. Bickel, E. Levina, Annals of Statistics 2013, Vol. 41 (4),
2097—2122.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>head(fast_cpl(igraph::as_adj(polblogs), 2), 50)
</code></pre>

<hr>
<h2 id='fast_sbm'>Sample from a SBM (fast)</h2><span id='topic+fast_sbm'></span>

<h3>Description</h3>

<p>Samples an adjacency matrix from a stochastic block model (SBM)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fast_sbm(z, B)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fast_sbm_+3A_z">z</code></td>
<td>
<p>Node labels (<code class="reqn">n * 1</code>)</p>
</td></tr>
<tr><td><code id="fast_sbm_+3A_b">B</code></td>
<td>
<p>Connectivity matrix (<code class="reqn">K * K</code>)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function implements a fast algorithm for sampling sparse SBMs, by only
sampling the necessary nonzero entries. This function is adapted almost
verbatim from the original code by Aiyou Chen.
</p>


<h3>Value</h3>

<p>An adjacency matrix following SBM
</p>


<h3>Examples</h3>

<pre><code class='language-R'>B = pp_conn(n = 10^4, oir = 0.1, lambda = 7, pri = rep(1,3))$B
head(fast_sbm(sample(1:3, 10^4, replace = TRUE), B))

</code></pre>

<hr>
<h2 id='gen_rand_conn'>Generate randomly permuted connectivity matrix</h2><span id='topic+gen_rand_conn'></span>

<h3>Description</h3>

<p>Creates a randomly permuted DCPP connectivity matrix with a given average
expected degree
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gen_rand_conn(n, K, lambda, gamma = 0.3, pri = rep(1, K)/K, theta = rep(1, n))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gen_rand_conn_+3A_n">n</code></td>
<td>
<p>number of nodes</p>
</td></tr>
<tr><td><code id="gen_rand_conn_+3A_k">K</code></td>
<td>
<p>number of communities</p>
</td></tr>
<tr><td><code id="gen_rand_conn_+3A_lambda">lambda</code></td>
<td>
<p>expected average degree</p>
</td></tr>
<tr><td><code id="gen_rand_conn_+3A_gamma">gamma</code></td>
<td>
<p>a measure of out-in-ratio (convex combination parameter)</p>
</td></tr>
<tr><td><code id="gen_rand_conn_+3A_pri">pri</code></td>
<td>
<p>the prior on community labels</p>
</td></tr>
<tr><td><code id="gen_rand_conn_+3A_theta">theta</code></td>
<td>
<p>node connection propensity parameter of DCSBM, by default
E(theta) = 1</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The connectivity matrix is a convex combination of a random symmetric
permutation matrix and the matrix of all ones, with weights gamm and 1-gamma.
</p>


<h3>Value</h3>

<p>connectivity matrix B of the desired DCSBM.
</p>

<hr>
<h2 id='get_dcsbm_exav_deg'>Calculate the expected average degree of a DCSBM</h2><span id='topic+get_dcsbm_exav_deg'></span>

<h3>Description</h3>

<p>Calculate the expected average degree of a DCSBM
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_dcsbm_exav_deg(n, pri, B, ex_theta = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_dcsbm_exav_deg_+3A_n">n</code></td>
<td>
<p>number of nodes</p>
</td></tr>
<tr><td><code id="get_dcsbm_exav_deg_+3A_pri">pri</code></td>
<td>
<p>distribution of node labels (K x 1)</p>
</td></tr>
<tr><td><code id="get_dcsbm_exav_deg_+3A_b">B</code></td>
<td>
<p>connectivity matrix (K x K)</p>
</td></tr>
<tr><td><code id="get_dcsbm_exav_deg_+3A_ex_theta">ex_theta</code></td>
<td>
<p>expected value of theta</p>
</td></tr>
</table>


<h3>Value</h3>

<p>expected average degree of a DCSBM
</p>

<hr>
<h2 id='label_mat2vec'>Convert label matrix to vector</h2><span id='topic+label_mat2vec'></span>

<h3>Description</h3>

<p>Convert label matrix to vector
</p>


<h3>Usage</h3>

<pre><code class='language-R'>label_mat2vec(Z)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="label_mat2vec_+3A_z">Z</code></td>
<td>
<p>a cluster assignment matrix</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A label vector that follows the assignment matrix
</p>

<hr>
<h2 id='label_vec2mat'>Convert label vector to matrix</h2><span id='topic+label_vec2mat'></span>

<h3>Description</h3>

<p>Convert label vector to matrix
</p>


<h3>Usage</h3>

<pre><code class='language-R'>label_vec2mat(z, K = NULL, sparse = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="label_vec2mat_+3A_z">z</code></td>
<td>
<p>a label vector</p>
</td></tr>
<tr><td><code id="label_vec2mat_+3A_k">K</code></td>
<td>
<p>number of labels in <code>z</code></p>
</td></tr>
<tr><td><code id="label_vec2mat_+3A_sparse">sparse</code></td>
<td>
<p>whether the output should be sparse matrix</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A cluster assignment matrix that follows from the label vector <code>z</code>
</p>

<hr>
<h2 id='nac_test'>NAC test</h2><span id='topic+nac_test'></span>

<h3>Description</h3>

<p>The NAC test to measure the goodness-of-fit of the DCSBM to network data.
</p>
<p>The function computes the NAC+ or NAC statistics in the paper below. Label vectors, if
not provided, are estimated using <a href="#topic+spec_clust">spec_clust</a> by default but one can also use any other
community detection algorithms through <code>cluster_fct</code>. Note that the function has to have
<code>A</code> and <code>K</code> as its first two arguments, and additional arguments could be provided through
<code>...</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>nac_test(A, K, z = NULL, y = NULL, plus = TRUE, cluster_fct = spec_clust, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="nac_test_+3A_a">A</code></td>
<td>
<p>adjacency matrix.</p>
</td></tr>
<tr><td><code id="nac_test_+3A_k">K</code></td>
<td>
<p>number of communities.</p>
</td></tr>
<tr><td><code id="nac_test_+3A_z">z</code></td>
<td>
<p>label vector for rows of <code>A</code>. If not provided, will be estimated from <code>cluster_fct</code>.</p>
</td></tr>
<tr><td><code id="nac_test_+3A_y">y</code></td>
<td>
<p>label vector for columns of <code>A</code>. If not provided, will be estimated from <code>cluster_fct</code>.</p>
</td></tr>
<tr><td><code id="nac_test_+3A_plus">plus</code></td>
<td>
<p>whether or not use column label vector with (<code>K</code>+1) communities, default is TRUE.</p>
</td></tr>
<tr><td><code id="nac_test_+3A_cluster_fct">cluster_fct</code></td>
<td>
<p>community detection function to get <code>z</code> and <code>y</code>, by default using <a href="#topic+spec_clust">spec_clust</a>.
The first two arguments have to be <code>A</code> and <code>K</code>.</p>
</td></tr>
<tr><td><code id="nac_test_+3A_...">...</code></td>
<td>
<p>additional arguments for <code>cluster_fct</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of result
</p>
<table>
<tr><td><code>stat</code></td>
<td>
<p>NAC or NAC+ test statistic.</p>
</td></tr>
<tr><td><code>z</code></td>
<td>
<p>row label vector.</p>
</td></tr>
<tr><td><code>y</code></td>
<td>
<p>column label vector.</p>
</td></tr>
</table>


<h3>References</h3>

<p><a href="https://arxiv.org/abs/2012.15047">Adjusted chi-square test for degree-corrected block models</a>,
Linfan Zhang, Arash A. Amini, arXiv preprint arXiv:2012.15047, 2020.
</p>


<h3>See Also</h3>

<p><a href="#topic+snac_test">snac_test</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>A &lt;- sample_dcpp(500, 10, 4, 0.1)$adj
nac_test(A, K = 4)$stat
nac_test(A, K = 4, cluster_fct = fast_cpl)$stat
</code></pre>

<hr>
<h2 id='plot_deg_dist'>Plot degree distribution</h2><span id='topic+plot_deg_dist'></span>

<h3>Description</h3>

<p>Plot the degree distribution of a network on log scale
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot_deg_dist(gr, logx = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot_deg_dist_+3A_gr">gr</code></td>
<td>
<p>the network as an igraph object</p>
</td></tr>
<tr><td><code id="plot_deg_dist_+3A_logx">logx</code></td>
<td>
<p>whether the degree is in log scale.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Histogram of the degree of 'gr'.
</p>

<hr>
<h2 id='plot_net'>Plot a network</h2><span id='topic+plot_net'></span>

<h3>Description</h3>

<p>Plot a network using degree-modulated node sizes, community colors and other enhancements
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot_net(
  gr,
  community = NULL,
  color_map = NULL,
  extract_lcc = TRUE,
  heavy_edge_deg_perc = 0.97,
  coord = NULL,
  vsize_func = function(deg) log(deg + 3) * 1,
  vertex_border = FALSE,
  niter = 1000,
  vertex_alpha = 0.4,
  remove_loops = TRUE,
  make_simple = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot_net_+3A_gr">gr</code></td>
<td>
<p>the network as an igraph object</p>
</td></tr>
<tr><td><code id="plot_net_+3A_community">community</code></td>
<td>
<p>community assignment; vector of node labels</p>
</td></tr>
<tr><td><code id="plot_net_+3A_color_map">color_map</code></td>
<td>
<p>color palette for clusters in 'gr'</p>
</td></tr>
<tr><td><code id="plot_net_+3A_extract_lcc">extract_lcc</code></td>
<td>
<p>Extract largest connected component or not</p>
</td></tr>
<tr><td><code id="plot_net_+3A_heavy_edge_deg_perc">heavy_edge_deg_perc</code></td>
<td>
<p>Degree percentile threshold for determining heavy edges</p>
</td></tr>
<tr><td><code id="plot_net_+3A_coord">coord</code></td>
<td>
<p>Optional starting positions for the vertices.
If this argument is not NULL then it should be an appropriate matrix of starting coordinates.</p>
</td></tr>
<tr><td><code id="plot_net_+3A_vsize_func">vsize_func</code></td>
<td>
<p>function to determine the size of node size</p>
</td></tr>
<tr><td><code id="plot_net_+3A_vertex_border">vertex_border</code></td>
<td>
<p>whether to show the border of vertex or not</p>
</td></tr>
<tr><td><code id="plot_net_+3A_niter">niter</code></td>
<td>
<p>number of iteration for FR layout computation</p>
</td></tr>
<tr><td><code id="plot_net_+3A_vertex_alpha">vertex_alpha</code></td>
<td>
<p>factor modifying the opacity alpha of vertex; typically in [0,1]</p>
</td></tr>
<tr><td><code id="plot_net_+3A_remove_loops">remove_loops</code></td>
<td>
<p>whether to remove loops in the network</p>
</td></tr>
<tr><td><code id="plot_net_+3A_make_simple">make_simple</code></td>
<td>
<p>whether to simplify edge weight calculation</p>
</td></tr>
<tr><td><code id="plot_net_+3A_...">...</code></td>
<td>
<p>other settings</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A network plot
</p>

<hr>
<h2 id='plot_roc'>Plot ROC curves</h2><span id='topic+plot_roc'></span>

<h3>Description</h3>

<p>Plot ROC curves given results from <a href="#topic+simulate_roc">simulate_roc</a>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot_roc(roc_results, method_names = NULL, font_size = 16)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot_roc_+3A_roc_results">roc_results</code></td>
<td>
<p>data frame <code>roc</code> from the output list of <a href="#topic+simulate_roc">simulate_roc</a></p>
</td></tr>
<tr><td><code id="plot_roc_+3A_method_names">method_names</code></td>
<td>
<p>a list of method names</p>
</td></tr>
<tr><td><code id="plot_roc_+3A_font_size">font_size</code></td>
<td>
<p>font size of the plot</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Roc plot based on results from <a href="#topic+simulate_roc">simulate_roc</a>
</p>

<hr>
<h2 id='plot_smooth_profile'>Plot community profiles</h2><span id='topic+plot_smooth_profile'></span>

<h3>Description</h3>

<p>Plot the smooth community profiles based on a resampled statistic
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot_smooth_profile(
  tstat,
  net_name = "",
  trunc_type = "none",
  spar = 0.3,
  plot_null_spar = TRUE,
  alpha = 0.3,
  base_font_size = 12
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot_smooth_profile_+3A_tstat">tstat</code></td>
<td>
<p>dataframe that has a column 'value' as statistic in the plot
and a column 'K' as its corresponding community number</p>
</td></tr>
<tr><td><code id="plot_smooth_profile_+3A_net_name">net_name</code></td>
<td>
<p>name of network</p>
</td></tr>
<tr><td><code id="plot_smooth_profile_+3A_trunc_type">trunc_type</code></td>
<td>
<p>method to round the dip/elbow point as the estimated
community number</p>
</td></tr>
<tr><td><code id="plot_smooth_profile_+3A_spar">spar</code></td>
<td>
<p>the sparsity level of fitting spline to the value of <code>tstat</code></p>
</td></tr>
<tr><td><code id="plot_smooth_profile_+3A_plot_null_spar">plot_null_spar</code></td>
<td>
<p>whether to plot the spline with zero sparsity</p>
</td></tr>
<tr><td><code id="plot_smooth_profile_+3A_alpha">alpha</code></td>
<td>
<p>transparency of the points in the plot</p>
</td></tr>
<tr><td><code id="plot_smooth_profile_+3A_base_font_size">base_font_size</code></td>
<td>
<p>font size of the plot</p>
</td></tr>
</table>


<h3>Value</h3>

<p>smooth profile plot of a network
</p>

<hr>
<h2 id='polblogs'>Political blogs network</h2><span id='topic+polblogs'></span>

<h3>Description</h3>

<p>This is a directed network of hyperlinks between political blogs about politics
in the United States of America.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(polblogs)
</code></pre>


<h3>Format</h3>

<p>An igraph data with 1490 nodes and 19090 edges
</p>


<h3>References</h3>

<p><a href="http://konect.cc/networks/dimacs10-polblogs/">Data source</a>.
Original paper:<a href="https://dl.acm.org/doi/10.1145/1134271.1134277">The political blogosphere and the 2004 US election: divided they blog</a>,
Adamic, Lada A., and Natalie Glance. &quot;.&quot; Proceedings of the 3rd international workshop on Link discovery. 2005.
</p>

<hr>
<h2 id='pp_conn'>Generate planted partition (PP) connectivity matrix</h2><span id='topic+pp_conn'></span>

<h3>Description</h3>

<p>Create a degree-corrected planted partition connectivity matrix with a given
average expected degree.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pp_conn(
  n,
  oir,
  lambda,
  pri,
  theta = rep(1, n),
  normalize_theta = FALSE,
  d = rep(1, length(pri))
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pp_conn_+3A_n">n</code></td>
<td>
<p>the number of nodes</p>
</td></tr>
<tr><td><code id="pp_conn_+3A_oir">oir</code></td>
<td>
<p>out-in-ratio</p>
</td></tr>
<tr><td><code id="pp_conn_+3A_lambda">lambda</code></td>
<td>
<p>the expected average degree</p>
</td></tr>
<tr><td><code id="pp_conn_+3A_pri">pri</code></td>
<td>
<p>the prior on community labels</p>
</td></tr>
<tr><td><code id="pp_conn_+3A_theta">theta</code></td>
<td>
<p>node connection propensity parameter of DCSBM</p>
</td></tr>
<tr><td><code id="pp_conn_+3A_normalize_theta">normalize_theta</code></td>
<td>
<p>whether to normalize theta so that max(theta) == 1</p>
</td></tr>
<tr><td><code id="pp_conn_+3A_d">d</code></td>
<td>
<p>diagonal of the connectivity matrix. An all-one vector by default.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The connectivity matrix B of the desired DCSBM.
</p>

<hr>
<h2 id='printf'>The usual &quot;printf&quot; function</h2><span id='topic+printf'></span>

<h3>Description</h3>

<p>The usual &quot;printf&quot; function
</p>


<h3>Usage</h3>

<pre><code class='language-R'>printf(...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="printf_+3A_...">...</code></td>
<td>
<p>printing object</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the value of the printing object
</p>

<hr>
<h2 id='rsymperm'>Generate random symmetric permutation matrix</h2><span id='topic+rsymperm'></span>

<h3>Description</h3>

<p>Generate a random symmetric permutation matrix (recursively)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rsymperm(K)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rsymperm_+3A_k">K</code></td>
<td>
<p>size of the matrix</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A random <code>K</code> x <code>K</code> symmetric permutation matrix
</p>

<hr>
<h2 id='sample_dcer'>Sample from a DCER</h2><span id='topic+sample_dcer'></span>

<h3>Description</h3>

<p>Sample an adjacency matrix from a degree-corrected Erdős–Rényi model (DCER).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sample_dcer(theta)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sample_dcer_+3A_theta">theta</code></td>
<td>
<p>Node connectivity propensity vector (<code class="reqn">n * 1</code>)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An adjacency matrix following DCSBM
</p>

<hr>
<h2 id='sample_dclvm'>Sample from a DCLVM</h2><span id='topic+sample_dclvm'></span>

<h3>Description</h3>

<p>A DCLVM with <code class="reqn">K</code> clusters has edges generated as
</p>
<p style="text-align: center;"><code class="reqn">
 	 E[\,A_{ij} \mid x, \theta\,] \;\propto\; \theta_i \theta_j e^{- \|x_i - x_j\|^2}
</code>
</p>

<p>where <code class="reqn">x_i = 2 e_{z_i} + w_i</code>, <code class="reqn">e_k</code> is the <code class="reqn">k</code>th basis vector of <code class="reqn">R^d</code>, <code class="reqn">w_i \sim N(0, I_d)</code>,
and <code class="reqn">\{z_i\} \subset [K]^n</code>. The proportionality constant is chosen such
that the overall network has expected average degree <code class="reqn">\lambda</code>.
To calculate the scaling constant, we approximate <code class="reqn">E[e^{- \|x_i - x_j\|^2}]</code>
for <code class="reqn">i \neq j</code> by generating random <code>npairs</code> <code class="reqn">\{z_i, z_j\}</code> and average over them.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sample_dclvm(z, lambda, theta, npairs = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sample_dclvm_+3A_z">z</code></td>
<td>
<p>a vector of cluster labels</p>
</td></tr>
<tr><td><code id="sample_dclvm_+3A_lambda">lambda</code></td>
<td>
<p>desired average degree of the network</p>
</td></tr>
<tr><td><code id="sample_dclvm_+3A_theta">theta</code></td>
<td>
<p>degree parameter</p>
</td></tr>
<tr><td><code id="sample_dclvm_+3A_npairs">npairs</code></td>
<td>
<p>number of pairs of <code class="reqn">\{z_i, z_j\}</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>Sample form a degree-corrected latent variable model with Gaussian kernel
</p>


<h3>Value</h3>

<p>Adjacency matrix of DCLVM
</p>

<hr>
<h2 id='sample_dcpp'>Sample from a DCPP</h2><span id='topic+sample_dcpp'></span>

<h3>Description</h3>

<p>Sample from a degree-corrected planted partition model
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sample_dcpp(
  n,
  lambda,
  K,
  oir,
  theta = NULL,
  pri = rep(1, K)/K,
  normalize_theta = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sample_dcpp_+3A_n">n</code></td>
<td>
<p>number of nodes</p>
</td></tr>
<tr><td><code id="sample_dcpp_+3A_lambda">lambda</code></td>
<td>
<p>average degree</p>
</td></tr>
<tr><td><code id="sample_dcpp_+3A_k">K</code></td>
<td>
<p>number of communities</p>
</td></tr>
<tr><td><code id="sample_dcpp_+3A_oir">oir</code></td>
<td>
<p>out-in ratio</p>
</td></tr>
<tr><td><code id="sample_dcpp_+3A_theta">theta</code></td>
<td>
<p>propensity parameter, if not given will be samples from a Pareto
distribution with scale parameter 2/3 and shape parameter 3</p>
</td></tr>
<tr><td><code id="sample_dcpp_+3A_pri">pri</code></td>
<td>
<p>prior distribution of node labels</p>
</td></tr>
<tr><td><code id="sample_dcpp_+3A_normalize_theta">normalize_theta</code></td>
<td>
<p>whether to normalize theta so that max(theta) == 1</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an adjacency matrix following a degree-corrected planted parition model
</p>


<h3>See Also</h3>

<p><a href="#topic+sample_dcsbm">sample_dcsbm</a>, <a href="#topic+sample_tdcsbm">sample_tdcsbm</a>
</p>

<hr>
<h2 id='sample_dcsbm'>Sample from a DCSBM</h2><span id='topic+sample_dcsbm'></span>

<h3>Description</h3>

<p>Sample an adjacency matrix from a degree-corrected block model (DCSBM)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sample_dcsbm(z, B, theta = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sample_dcsbm_+3A_z">z</code></td>
<td>
<p>Node labels (<code class="reqn">n * 1</code>)</p>
</td></tr>
<tr><td><code id="sample_dcsbm_+3A_b">B</code></td>
<td>
<p>Connectivity matrix (<code class="reqn">K * K</code>)</p>
</td></tr>
<tr><td><code id="sample_dcsbm_+3A_theta">theta</code></td>
<td>
<p>Node connectivity propensity vector (<code class="reqn">n * 1</code>)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An adjacency matrix following DCSBM
</p>


<h3>See Also</h3>

<p><a href="#topic+sample_dcpp">sample_dcpp</a>, <a href="#topic+fast_sbm">fast_sbm</a>, <a href="#topic+sample_tdcsbm">sample_tdcsbm</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>B = pp_conn(n = 10^3, oir = 0.1, lambda = 7, pri = rep(1,3))$B
head(sample_dcsbm(sample(1:3, 10^3, replace = TRUE), B, theta = rexp(10^3)))
</code></pre>

<hr>
<h2 id='sample_tdcsbm'>Sample truncated DCSBM (fast)</h2><span id='topic+sample_tdcsbm'></span>

<h3>Description</h3>

<p>Sample an adjacency matrix from a truncated degree-corrected block model
(DCSBM) using a fast algorithm.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sample_tdcsbm(z, B, theta = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sample_tdcsbm_+3A_z">z</code></td>
<td>
<p>Node labels (<code class="reqn">n * 1</code>)</p>
</td></tr>
<tr><td><code id="sample_tdcsbm_+3A_b">B</code></td>
<td>
<p>Connectivity matrix (<code class="reqn">K * K</code>)</p>
</td></tr>
<tr><td><code id="sample_tdcsbm_+3A_theta">theta</code></td>
<td>
<p>Node connectivity propensity vector (<code class="reqn">n * 1</code>)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function  samples an adjacency matrix from a truncated DCSBM, with
entries having Bernoulli distributions with mean </p>
<p style="text-align: center;"><code class="reqn"> E[A_{ij} | z] =
B_{z_i, z_j} \min(1, \theta_i \theta_j).</code>
</p>
<p> The approach uses the masking idea
of Aiyou Chen, leading to fast sampling for sparse networks. The masking,
however, truncates <code class="reqn">\theta_i \theta_j</code> to at most 1, hence
we refer to it as the truncated DCSBM.
</p>


<h3>Value</h3>

<p>An adjacency matrix following DCSBM
</p>


<h3>Examples</h3>

<pre><code class='language-R'>B = pp_conn(n = 10^4, oir = 0.1, lambda = 7, pri = rep(1,3))$B
head(sample_tdcsbm(sample(1:3, 10^4, replace = TRUE), B, theta = rexp(10^4)))
</code></pre>

<hr>
<h2 id='simulate_roc'>Simulate data to estimate ROC curves</h2><span id='topic+simulate_roc'></span>

<h3>Description</h3>

<p>Simulate data from the null and alternative distributions to estimate ROC
curves for a collection of methods.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>simulate_roc(
  apply_methods,
  gen_null_data,
  gen_alt_data,
  nruns = 100,
  core_count = parallel::detectCores() - 1,
  seed = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="simulate_roc_+3A_apply_methods">apply_methods</code></td>
<td>
<p>a function that returns a data.frame with columns
&quot;method&quot;, &quot;tstat&quot; and &quot;twosided&quot;</p>
</td></tr>
<tr><td><code id="simulate_roc_+3A_gen_null_data">gen_null_data</code></td>
<td>
<p>a function that generate data under the null model</p>
</td></tr>
<tr><td><code id="simulate_roc_+3A_gen_alt_data">gen_alt_data</code></td>
<td>
<p>a function that generate data under the alternative model</p>
</td></tr>
<tr><td><code id="simulate_roc_+3A_nruns">nruns</code></td>
<td>
<p>number of simulated data from the null/alternative model</p>
</td></tr>
<tr><td><code id="simulate_roc_+3A_core_count">core_count</code></td>
<td>
<p>number of cores used in parallel computing</p>
</td></tr>
<tr><td><code id="simulate_roc_+3A_seed">seed</code></td>
<td>
<p>seed for random simulation</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list of result </p>
<table>
<tr><td><code>roc</code></td>
<td>
<p>A data frame used to plot ROC curves with
columns: method, whether a two sided test, false positive rate (FPR), and
true positive rate (TPR)</p>
</td></tr> <tr><td><code>raw</code></td>
<td>
<p>A data frame containing raw output
from null and alternative models with columns: method, statistics value,
whether a two sided test, and the type of hypothesis</p>
</td></tr>
<tr><td><code>elapsed_time</code></td>
<td>
<p>symstem elapsed time for generating ROC data</p>
</td></tr>
</table>

<hr>
<h2 id='sinkhorn_knopp'>Sinkhorn&ndash;Knopp matrix scaling</h2><span id='topic+sinkhorn_knopp'></span>

<h3>Description</h3>

<p>Implements the Sinkhorn&ndash;Knopp algorithm for transforming a square matrix
with positive entries to a stochastic matrix with given common row and column
sums (e.g., a doubly stochastic matrix).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sinkhorn_knopp(
  A,
  sums = rep(1, nrow(A)),
  niter = 100,
  tol = 1e-08,
  sym = FALSE,
  verb = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sinkhorn_knopp_+3A_a">A</code></td>
<td>
<p>input matrix</p>
</td></tr>
<tr><td><code id="sinkhorn_knopp_+3A_sums">sums</code></td>
<td>
<p>desired row/column sums</p>
</td></tr>
<tr><td><code id="sinkhorn_knopp_+3A_niter">niter</code></td>
<td>
<p>number of iterations</p>
</td></tr>
<tr><td><code id="sinkhorn_knopp_+3A_tol">tol</code></td>
<td>
<p>convergence tolerance</p>
</td></tr>
<tr><td><code id="sinkhorn_knopp_+3A_sym">sym</code></td>
<td>
<p>whether to compute symmetric scaling D A D</p>
</td></tr>
<tr><td><code id="sinkhorn_knopp_+3A_verb">verb</code></td>
<td>
<p>whether to print the current change</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Computes diagonal matrices D1 and D2 to make D1<em>A</em>D2 into a matrix with
given row/column sums. For a symmetric matrix <code>A</code>, one can set <code>sym = TRUE</code> to
compute a symmetric scaling D<em>A</em>D.
</p>


<h3>Value</h3>

<p>Diagonal matrices D1 and D2 to make D1<em>A</em>D2 into a matrix with
given row/column sums.
</p>

<hr>
<h2 id='snac_resample'>Resampled SNAC+</h2><span id='topic+snac_resample'></span>

<h3>Description</h3>

<p>Compute SNAC+ with resampling
</p>


<h3>Usage</h3>

<pre><code class='language-R'>snac_resample(
  A,
  nrep = 20,
  Kmin = 1,
  Kmax = 13,
  ncores = parallel::detectCores() - 1,
  seed = 1234
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="snac_resample_+3A_a">A</code></td>
<td>
<p>adjacency matrix</p>
</td></tr>
<tr><td><code id="snac_resample_+3A_nrep">nrep</code></td>
<td>
<p>number of times SNAC+ is computed</p>
</td></tr>
<tr><td><code id="snac_resample_+3A_kmin">Kmin</code></td>
<td>
<p>minimum community number to use in SNAC+</p>
</td></tr>
<tr><td><code id="snac_resample_+3A_kmax">Kmax</code></td>
<td>
<p>maximum community number to use in SNAC+</p>
</td></tr>
<tr><td><code id="snac_resample_+3A_ncores">ncores</code></td>
<td>
<p>number of cores to use in the parallel computing</p>
</td></tr>
<tr><td><code id="snac_resample_+3A_seed">seed</code></td>
<td>
<p>seed for random sampling</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data frame with columns specifying repetition cycles,
number of community numbers and the value of SNAC+ statistics
</p>

<hr>
<h2 id='snac_select'>Estimate community number with SNAC+</h2><span id='topic+snac_select'></span>

<h3>Description</h3>

<p>Applying SNAC+ test sequentially to estimate community number of a network
fit to DCSBM
</p>


<h3>Usage</h3>

<pre><code class='language-R'>snac_select(
  A,
  Kmin = 1,
  Kmax,
  alpha = 1e-05,
  labels = NULL,
  cluster_fct = spec_clust,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="snac_select_+3A_a">A</code></td>
<td>
<p>adjacency matrix.</p>
</td></tr>
<tr><td><code id="snac_select_+3A_kmin">Kmin</code></td>
<td>
<p>minimum candidate community number.</p>
</td></tr>
<tr><td><code id="snac_select_+3A_kmax">Kmax</code></td>
<td>
<p>maximum candidate community number.</p>
</td></tr>
<tr><td><code id="snac_select_+3A_alpha">alpha</code></td>
<td>
<p>significance level for rejecting the null hypothesis.</p>
</td></tr>
<tr><td><code id="snac_select_+3A_labels">labels</code></td>
<td>
<p>a matrix with each column being a row label vector for a
candidate community number. If not provided, will be computed by <code>cluster_fct</code>.</p>
</td></tr>
<tr><td><code id="snac_select_+3A_cluster_fct">cluster_fct</code></td>
<td>
<p>community detection function to get label vectors to compute SNAC+ statistics
(in <a href="#topic+snac_test">snac_test</a>), by default using <a href="#topic+spec_clust">spec_clust</a>.</p>
</td></tr>
<tr><td><code id="snac_select_+3A_...">...</code></td>
<td>
<p>additional arguments for <code>cluster_fct</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>estimated community number.
</p>


<h3>See Also</h3>

<p><a href="#topic+snac_test">snac_test</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>A &lt;- sample_dcpp(500, 10, 3, 0.1)$adj
snac_select(A, Kmax = 6)
</code></pre>

<hr>
<h2 id='snac_test'>SNAC test</h2><span id='topic+snac_test'></span>

<h3>Description</h3>

<p>The SNAC test to measure the goodness-of-fit of the DCSBM to network data.
</p>
<p>The function computes the SNAC+ or SNAC statistics in the paper below.
The row label vector of the adjacency matrix could be given through <code>z</code> otherwise will
be estimated by <code>cluster_fct</code>. One can specify the ratio of nodes used to estimate column
label vector. If <code>plus = TRUE</code>, the column labels will be estimated by <a href="#topic+spec_clust">spec_clust</a> with
(<code>K</code>+1) clusters, i.e. performing SNAC+ test, otherwise with <code>K</code> clusters SNAC test.
One can also get multiple test statistics with repeated random subsampling on nodes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>snac_test(
  A,
  K,
  z = NULL,
  ratio = 0.5,
  fromEachCommunity = TRUE,
  plus = TRUE,
  cluster_fct = spec_clust,
  nrep = 1,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="snac_test_+3A_a">A</code></td>
<td>
<p>adjacency matrix.</p>
</td></tr>
<tr><td><code id="snac_test_+3A_k">K</code></td>
<td>
<p>desired number of communities.</p>
</td></tr>
<tr><td><code id="snac_test_+3A_z">z</code></td>
<td>
<p>label vector for rows of adjacency matrix. If not provided, will be estimated by
<code>cluster_fct</code></p>
</td></tr>
<tr><td><code id="snac_test_+3A_ratio">ratio</code></td>
<td>
<p>ratio of subsampled nodes from the network.</p>
</td></tr>
<tr><td><code id="snac_test_+3A_fromeachcommunity">fromEachCommunity</code></td>
<td>
<p>whether subsample from each estimated community or the full network,
default is TRUE</p>
</td></tr>
<tr><td><code id="snac_test_+3A_plus">plus</code></td>
<td>
<p>whether or not use column label vector with (<code>K</code>+1) communities to compute the statistics, default is TRUE.</p>
</td></tr>
<tr><td><code id="snac_test_+3A_cluster_fct">cluster_fct</code></td>
<td>
<p>community detection function to estimate label vectors, by default using <a href="#topic+spec_clust">spec_clust</a>.
The first two arguments have to be <code>A</code> and <code>K</code>.</p>
</td></tr>
<tr><td><code id="snac_test_+3A_nrep">nrep</code></td>
<td>
<p>number of times the statistics are computed.</p>
</td></tr>
<tr><td><code id="snac_test_+3A_...">...</code></td>
<td>
<p>additional arguments for <code>cluster_fct</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of result
</p>
<table>
<tr><td><code>stat</code></td>
<td>
<p>SNAC or SNAC+ test statistic.</p>
</td></tr>
<tr><td><code>z</code></td>
<td>
<p>row label vector.</p>
</td></tr>
</table>


<h3>References</h3>

<p><a href="https://arxiv.org/abs/2012.15047">Adjusted chi-square test for degree-corrected block models</a>,
Linfan Zhang, Arash A. Amini, arXiv preprint arXiv:2012.15047, 2020.
</p>


<h3>See Also</h3>

<p><a href="#topic+nac_test">nac_test</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>A &lt;- sample_dcpp(500, 10, 4, 0.1)$adj
snac_test(A, K = 4, niter = 3)$stat
</code></pre>

<hr>
<h2 id='spec_clust'>Spectral clustering (fast)</h2><span id='topic+spec_clust'></span>

<h3>Description</h3>

<p>Perform spectral clustering (with regularization) to estimate communities
</p>


<h3>Usage</h3>

<pre><code class='language-R'>spec_clust(
  A,
  K,
  type = "lap",
  tau = 0.25,
  nstart = 20,
  niter = 10,
  ignore_first_col = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="spec_clust_+3A_a">A</code></td>
<td>
<p>Adjacency matrix (n x n)</p>
</td></tr>
<tr><td><code id="spec_clust_+3A_k">K</code></td>
<td>
<p>Number of communities</p>
</td></tr>
<tr><td><code id="spec_clust_+3A_type">type</code></td>
<td>
<p>(&quot;lap&quot; | &quot;adj&quot; | &quot;adj2&quot;) Whether to use Laplacian or adjacency-based spectral clustering</p>
</td></tr>
<tr><td><code id="spec_clust_+3A_tau">tau</code></td>
<td>
<p>Regularization parameter for the Laplacian</p>
</td></tr>
<tr><td><code id="spec_clust_+3A_nstart">nstart</code></td>
<td>
<p>argument from function 'kmeans'</p>
</td></tr>
<tr><td><code id="spec_clust_+3A_niter">niter</code></td>
<td>
<p>argument from function 'kmeans'</p>
</td></tr>
<tr><td><code id="spec_clust_+3A_ignore_first_col">ignore_first_col</code></td>
<td>
<p>whether to ignore the first eigen vector when doing spectral clustering</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A label vector of size n x 1 with elements in 1,2,...,K
</p>

<hr>
<h2 id='spec_repr'>Spectral Representation</h2><span id='topic+spec_repr'></span>

<h3>Description</h3>

<p>Provides a spectral representation of the network (with regularization)
based on the adjacency or Laplacian matrices
</p>


<h3>Usage</h3>

<pre><code class='language-R'>spec_repr(A, K, type = "lap", tau = 0.25, ignore_first_col = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="spec_repr_+3A_a">A</code></td>
<td>
<p>Adjacency matrix (n x n)</p>
</td></tr>
<tr><td><code id="spec_repr_+3A_k">K</code></td>
<td>
<p>Number of communities</p>
</td></tr>
<tr><td><code id="spec_repr_+3A_type">type</code></td>
<td>
<p>(&quot;lap&quot; | &quot;adj&quot; | &quot;adj2&quot;) Whether to use Laplacian or
adjacency-based spectral clustering</p>
</td></tr>
<tr><td><code id="spec_repr_+3A_tau">tau</code></td>
<td>
<p>Regularization parameter for the Laplacian</p>
</td></tr>
<tr><td><code id="spec_repr_+3A_ignore_first_col">ignore_first_col</code></td>
<td>
<p>whether to ignore the first eigen vector</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The n x K matrix resulting from a spectral embedding of the network into
R^K
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
