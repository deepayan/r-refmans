<!DOCTYPE html><html><head><title>Help for package FuzzyResampling</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {FuzzyResampling}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#FuzzyResampling-package'><p>FuzzyResampling: Resampling Methods for Triangular and Trapezoidal Fuzzy Numbers</p></a></li>
<li><a href='#BertoluzzaDistance'><p>Calculate Bertoluzza's (mid/spread) distance for triangular and trapezoidal fuzzy numbers</p></a></li>
<li><a href='#CalculateAmbiguity'><p>Calculation of the ambiguity for triangular and trapezoidal fuzzy numbers</p></a></li>
<li><a href='#CalculateAmbiguityL'><p>Calculation of the left-hand ambiguity for triangular and trapezoidal fuzzy numbers</p></a></li>
<li><a href='#CalculateAmbiguityR'><p>Calculation of the right-hand ambiguity for triangular and trapezoidal fuzzy numbers</p></a></li>
<li><a href='#CalculateExpValue'><p>Calculation of the expected value for triangular and trapezoidal fuzzy numbers</p></a></li>
<li><a href='#CalculateFuzziness'><p>Calculation of the fuzziness for triangular and trapezoidal fuzzy numbers</p></a></li>
<li><a href='#CalculateValue'><p>Calculation of the value for triangular and trapezoidal fuzzy numbers</p></a></li>
<li><a href='#CalculateWidth'><p>Calculation of the width for triangular and trapezoidal fuzzy numbers</p></a></li>
<li><a href='#ClassicalBootstrap'><p>Classical bootstrap procedure for triangular and trapezoidal fuzzy numbers</p></a></li>
<li><a href='#ComparePowerOneSampleCTest'><p>Comparison of the resampling approaches based on the power for the one-sample test for the mean.</p></a></li>
<li><a href='#ComparisonOneSampleCTest'><p>Comparison of the resampling approaches based on the power for the one-sample test for the mean.</p></a></li>
<li><a href='#ComparisonSEMean'><p>Comparison of the resampling approaches based on the SE/MSE for the mean.</p></a></li>
<li><a href='#DMethod'><p>d method for resampling triangular and trapezoidal fuzzy numbers</p></a></li>
<li><a href='#EWMethod'><p>E(xpected value)W(idth) resampling method for triangular and trapezoidal fuzzy numbers</p></a></li>
<li><a href='#GeneratorFuzzyNumbers'><p>Generate initial sample using various random distributions.</p></a></li>
<li><a href='#GeneratorNExpUU'><p>Generate initial sample using the normal and uniform distributions.</p></a></li>
<li><a href='#GeneratorNU'><p>Generate initial sample using the normal and uniform distributions.</p></a></li>
<li><a href='#OneSampleCTest'><p>Calculate p-value of the one-sample test for the mean</p></a></li>
<li><a href='#resamplingMethods'><p>A vector containing names of all resampling methods.</p></a></li>
<li><a href='#samplingGenerators'><p>A vector containing names of all sampling generators</p></a></li>
<li><a href='#SEResamplingMean'><p>Calculate SE/MSE for the mean of the bootstrapped samples.</p></a></li>
<li><a href='#TwoSampleCTest'><p>Calculate p-value of the two-sample test for the mean</p></a></li>
<li><a href='#VAAMethod'><p>V(alue)A(mbiguity, left-hand)A(mbiguity, right-hand) resampling method for triangular and trapezoidal fuzzy numbers</p></a></li>
<li><a href='#VAFMethod'><p>V(alue)A(mbiguity)F(uzziness) resampling method for triangular and trapezoidal fuzzy numbers</p></a></li>
<li><a href='#VAMethod'><p>V(alue)A(mbiguity) resampling method for triangular and trapezoidal fuzzy numbers</p></a></li>
<li><a href='#WMethod'><p>w method for resampling triangular and trapezoidal fuzzy numbers</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Resampling Methods for Triangular and Trapezoidal Fuzzy Numbers</td>
</tr>
<tr>
<td>Version:</td>
<td>0.6.3</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Maciej Romaniuk &lt;mroman@ibspan.waw.pl&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>The classical (i.e. Efron's, see Efron and Tibshirani (1994, ISBN:978-0412042317)  "An Introduction to the Bootstrap") bootstrap is widely used for both the real (i.e. "crisp") and fuzzy data.
 The main aim of the algorithms implemented in this package  is to overcome a problem with repetition of a few distinct values and to create fuzzy numbers, which are "similar" (but not the same) to values from the initial sample.
 To do this, different characteristics of triangular/trapezoidal numbers are kept (like the value, the ambiguity, etc., see Grzegorzewski et al. &lt;<a href="https://doi.org/10.2991%2Feusflat-19.2019.68">doi:10.2991/eusflat-19.2019.68</a>&gt;, Grzegorzewski et al. (2020) &lt;<a href="https://doi.org/10.2991%2Fijcis.d.201012.003">doi:10.2991/ijcis.d.201012.003</a>&gt;, Grzegorzewski et al. (2020) &lt;<a href="https://doi.org/10.34768%2Famcs-2020-0022">doi:10.34768/amcs-2020-0022</a>&gt;, Grzegorzewski and Romaniuk (2022) &lt;<a href="https://doi.org/10.1007%2F978-3-030-95929-6_3">doi:10.1007/978-3-030-95929-6_3</a>&gt;,  Romaniuk and Hryniewicz (2019) &lt;<a href="https://doi.org/10.1007%2Fs00500-018-3251-5">doi:10.1007/s00500-018-3251-5</a>&gt;).
 Some additional procedures related to these resampling methods are also provided,
 like calculation of the Bertoluzza et al.'s distance (aka the mid/spread distance, see Bertoluzza et al. (1995) "On a new class of distances between fuzzy numbers")
 and estimation of the p-value of the one- and two- sample bootstrapped test for the mean (see Lubiano et al. (2016, &lt;<a href="https://doi.org/10.1016%2Fj.ejor.2015.11.016">doi:10.1016/j.ejor.2015.11.016</a>&gt;)).
 Additionally, there are procedures which randomly generate trapezoidal fuzzy numbers using some well-known statistical distributions.</td>
</tr>
<tr>
<td>Imports:</td>
<td>stats, utils</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/mroman-ibs/FuzzyResampling">https://github.com/mroman-ibs/FuzzyResampling</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/mroman-ibs/FuzzyResampling/issues">https://github.com/mroman-ibs/FuzzyResampling/issues</a></td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>Suggests:</td>
<td>testthat (&ge; 3.0.0)</td>
</tr>
<tr>
<td>Config/testthat/edition:</td>
<td>3</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-11-22 10:41:49 UTC; mroman</td>
</tr>
<tr>
<td>Author:</td>
<td>Maciej Romaniuk [aut, cre],
  Przemyslaw Grzegorzewski [aut],
  Olgierd Hryniewicz [aut]</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-11-22 11:20:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='FuzzyResampling-package'>FuzzyResampling: Resampling Methods for Triangular and Trapezoidal Fuzzy Numbers</h2><span id='topic+FuzzyResampling'></span><span id='topic+FuzzyResampling-package'></span>

<h3>Description</h3>

<p>The classical (i.e. Efron's, see Efron and Tibshirani (1994, ISBN:978-0412042317) &quot;An Introduction to the Bootstrap&quot;) bootstrap is widely used for both the real (i.e. &quot;crisp&quot;) and fuzzy data. The main aim of the algorithms implemented in this package is to overcome a problem with repetition of a few distinct values and to create fuzzy numbers, which are &quot;similar&quot; (but not the same) to values from the initial sample. To do this, different characteristics of triangular/trapezoidal numbers are kept (like the value, the ambiguity, etc., see Grzegorzewski et al. <a href="https://doi.org/10.2991/eusflat-19.2019.68">doi:10.2991/eusflat-19.2019.68</a>, Grzegorzewski et al. (2020) <a href="https://doi.org/10.2991/ijcis.d.201012.003">doi:10.2991/ijcis.d.201012.003</a>, Grzegorzewski et al. (2020) <a href="https://doi.org/10.34768/amcs-2020-0022">doi:10.34768/amcs-2020-0022</a>, Grzegorzewski and Romaniuk (2022) <a href="https://doi.org/10.1007/978-3-030-95929-6_3">doi:10.1007/978-3-030-95929-6_3</a>, Romaniuk and Hryniewicz (2019) <a href="https://doi.org/10.1007/s00500-018-3251-5">doi:10.1007/s00500-018-3251-5</a>). Some additional procedures related to these resampling methods are also provided, like calculation of the Bertoluzza et al.'s distance (aka the mid/spread distance, see Bertoluzza et al. (1995) &quot;On a new class of distances between fuzzy numbers&quot;) and estimation of the p-value of the one- and two- sample bootstrapped test for the mean (see Lubiano et al. (2016, <a href="https://doi.org/10.1016/j.ejor.2015.11.016">doi:10.1016/j.ejor.2015.11.016</a>)). Additionally, there are procedures which randomly generate trapezoidal fuzzy numbers using some well-known statistical distributions.
</p>


<h3>The following procedures are available in the library</h3>


<ul>
<li> <p><em>ClassicalBootstrap</em> - classical approach based on Efron's method,
</p>
</li>
<li> <p><em>VAMethod</em> - resampling method which preserves the value and ambiguity,
</p>
</li>
<li> <p><em>EWMethod</em> - resampling method which preserves the expected value and width,
</p>
</li>
<li> <p><em>VAAMethod</em> - resampling method which preserves the value, left-hand and right-hand ambiguities,
</p>
</li>
<li> <p><em>VAFMethod</em> - resampling method which preserves the value, ambiguity and fuzziness,
</p>
</li>
<li> <p><em>DMethod</em> - resampling method which preserves the left end of the cores and increments,
</p>
</li>
<li> <p><em>WMethod</em> - resampling method which uses the special <em>w density</em> to &quot;smooth&quot; the output fuzzy value,
</p>
</li>
<li> <p><em>GeneratorNU</em> - generation of the initial sample using the normal and uniform distributions,
</p>
</li>
<li> <p><em>GeneratorNExpUU</em> - generation of the initial sample using the normal, exponential and uniform distributions,
</p>
</li>
<li> <p><em>GeneratorFuzzyNumbers</em> - generation of the initial sample using various random distributions,
</p>
</li>
<li> <p><em>OneSampleCTest</em> - estimation of the p-value of the one-sample test for the mean,
</p>
</li>
<li> <p><em>TwoSampleCTest</em> - estimation of the p-value of the two-sample test for the mean,
</p>
</li>
<li> <p><em>SEResamplingMean</em> - estimation of the standard error or the mean-squared error for the mean,
</p>
</li>
<li> <p><em>BertoluzzaDistance</em> - calculation of the Bertoluzza et al.'s distance (aka the mid/spread distance),
</p>
</li>
<li> <p><em>ComparisonOneSampleCTest</em> - comparison of resampling methods based on percentage of rejections for the one-sample C-test,
</p>
</li>
<li> <p><em>ComparisonSEMean</em> - comparison of resampling methods based on the SE/MSE for the mean,
</p>
</li>
<li> <p><em>ComparePowerOneSampleCTest</em> - comparison of resampling methods based on percentage of rejections for the one-sample C-test,
</p>
</li></ul>



<h3>Author(s)</h3>

<p><strong>Maintainer</strong>: Maciej Romaniuk <a href="mailto:mroman@ibspan.waw.pl">mroman@ibspan.waw.pl</a>
</p>
<p>Authors:
</p>

<ul>
<li><p> Przemyslaw Grzegorzewski <a href="mailto:przemyslaw.grzegorzewski@ibspan.waw.pl">przemyslaw.grzegorzewski@ibspan.waw.pl</a>
</p>
</li>
<li><p> Olgierd Hryniewicz <a href="mailto:hryniewi@ibspan.waw.pl">hryniewi@ibspan.waw.pl</a>
</p>
</li></ul>



<h3>See Also</h3>

<p>Useful links:
</p>

<ul>
<li> <p><a href="https://github.com/mroman-ibs/FuzzyResampling">https://github.com/mroman-ibs/FuzzyResampling</a>
</p>
</li>
<li><p> Report bugs at <a href="https://github.com/mroman-ibs/FuzzyResampling/issues">https://github.com/mroman-ibs/FuzzyResampling/issues</a>
</p>
</li></ul>


<hr>
<h2 id='BertoluzzaDistance'>Calculate Bertoluzza's (mid/spread) distance for triangular and trapezoidal fuzzy numbers</h2><span id='topic+BertoluzzaDistance'></span>

<h3>Description</h3>

<p><code>BertoluzzaDistance</code> returns the Bertoulzza et al.'s (aka mid/spread) distance with the given weight <code>theta</code>
between two triangular or trapezoidal fuzzy numbers.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>BertoluzzaDistance(fuzzyNumber1, fuzzyNumber2, theta = 1/3, increases = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="BertoluzzaDistance_+3A_fuzzynumber1">fuzzyNumber1</code></td>
<td>
<p>The first triangular or trapezoidal fuzzy number.
More than one value can be given in the form of matrix.</p>
</td></tr>
<tr><td><code id="BertoluzzaDistance_+3A_fuzzynumber2">fuzzyNumber2</code></td>
<td>
<p>The second triangular or trapezoidal fuzzy number.
More than one value can be given in the form of matrix.</p>
</td></tr>
<tr><td><code id="BertoluzzaDistance_+3A_theta">theta</code></td>
<td>
<p>The weighting parameter for the mid/spread distance.</p>
</td></tr>
<tr><td><code id="BertoluzzaDistance_+3A_increases">increases</code></td>
<td>
<p>If <code>TRUE</code> is used, then the fuzzy numbers should be given in the form:
left increment of the support, left end of the core, right end of the core,
right increment of the support. Otherwise, the default value <code>FALSE</code> is used and the fuzzy numbers should be given in the form:
left end of the support, left end of the core, right end of the core,
right end of the support.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The input fuzzy values should be triangular or trapezoidal fuzzy numbers, given as a single vector or a whole matrix.
In each row, there should be a single fuzzy number in one of the forms:
</p>

<ol>
<li><p> left end of the support, left end of the core, right end of the core, right end of the support, or
</p>
</li>
<li><p> left increment of the support, left end of the core, right end of the core, right increment of the support.
</p>
</li></ol>

<p>In this second case, the parameter <code>increases=TRUE</code> has to be used.
</p>
<p>The procedure calculates the mid/spread distance between two fuzzy values based on the weight <code>theta</code>,
usually we have <code>theta = 1/3</code> or <code>theta = 1</code>.
The output is given as vector of distances.
</p>


<h3>Value</h3>

<p>This function returns vector of doubles related to the calculated distances.
</p>


<h3>References</h3>

<p>Bertoluzza, C., Corral, N., Salas, A. (1995)
On a new class of distances between fuzzy numbers
Mathware and Soft Computing, 2 (2), pp. 71-84
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# prepare some fuzzy numbers (first type of the initial sample)

fuzzyValues &lt;- matrix(c(0.25,0.5,1,1.25,0.75,1,1.5,2.2,-1,0,0,2),ncol = 4,byrow = TRUE)

# calculate the mid/spread distance between the first value
# (from the first row) and the second one (from the second row)

BertoluzzaDistance(fuzzyValues[1,],fuzzyValues[2,])

# calculate the mid/spread distance between the first value
# (from the first row) and all of the values (from the first to the third row)

BertoluzzaDistance(fuzzyValues[1,],fuzzyValues)


</code></pre>

<hr>
<h2 id='CalculateAmbiguity'>Calculation of the ambiguity for triangular and trapezoidal fuzzy numbers</h2><span id='topic+CalculateAmbiguity'></span>

<h3>Description</h3>

<p><code>CalculateAmbiguity</code> returns the ambiguity of the triangular or trapezoidal fuzzy number (see, e.g., (Ban et al., 2015),
(Grzegorzewski and Romaniuk, 2022)).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>CalculateAmbiguity(fuzzyNumber, increases = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="CalculateAmbiguity_+3A_fuzzynumber">fuzzyNumber</code></td>
<td>
<p>Input data consist of triangular or trapezoidal fuzzy numbers.</p>
</td></tr>
<tr><td><code id="CalculateAmbiguity_+3A_increases">increases</code></td>
<td>
<p>If <code>TRUE</code> is used, then the initial data should consist of the fuzzy numbers in the form:
left increment of the support, left end of the core, right end of the core,
right increment of the support. Otherwise, the default value <code>FALSE</code> is used and the fuzzy numbers should be given in the form:
left end of the support, left end of the core, right end of the core,
right end of the support.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The input data should consist of triangular or trapezoidal fuzzy numbers, given as a single vector or a whole matrix.
In each row, there should be a single fuzzy number in one of the forms:
</p>

<ol>
<li><p> left end of the support, left end of the core, right end of the core, right end of the support, or
</p>
</li>
<li><p> left increment of the support, left end of the core, right end of the core, right increment of the support.
</p>
</li></ol>

<p>In this second case, the parameter <code>increases=TRUE</code> has to be used.
</p>
<p>Then for each fuzzy number, its characteristics, known as the ambiguity of fuzzy number, is calculated.
For the respective formulas, see, e.g., (Ban et al., 2015), (Grzegorzewski and Romaniuk, 2022).
</p>


<h3>Value</h3>

<p>This function returns vector of double values.
Each output value is equal to the ambiguity of the respective fuzzy number.
</p>


<h3>References</h3>

<p>Ban, A.I., Coroianu, L., Grzegorzewski, P. (2015)
Fuzzy Numbers: Approximations, Ranking and Applications
Institute of Computer Sciences, Polish Academy of Sciences
</p>
<p>Grzegorzewski, P., Romaniuk, M. (2022)
Bootstrap methods for fuzzy data
Uncertainty and Imprecision in Decision Making and Decision Support: New Advances, Challenges, and Perspectives, pp. 28-47
Springer
</p>


<h3>See Also</h3>

<p><code><a href="#topic+CalculateFuzziness">CalculateFuzziness</a></code> for calculation of the fuzziness,
<code><a href="#topic+CalculateValue">CalculateValue</a></code> for calculation of the value,
<code><a href="#topic+CalculateAmbiguityR">CalculateAmbiguityR</a></code> for calculation of the right-hand ambiguity,
<code><a href="#topic+CalculateAmbiguityL">CalculateAmbiguityL</a></code> for calculation of the left-hand ambiguity,
<code><a href="#topic+CalculateExpValue">CalculateExpValue</a></code> for calculation of the expected value,
<code><a href="#topic+CalculateWidth">CalculateWidth</a></code> for calculation of the width
</p>
<p>Other characteristics of fuzzy numbers functions: 
<code><a href="#topic+CalculateAmbiguityL">CalculateAmbiguityL</a>()</code>,
<code><a href="#topic+CalculateAmbiguityR">CalculateAmbiguityR</a>()</code>,
<code><a href="#topic+CalculateExpValue">CalculateExpValue</a>()</code>,
<code><a href="#topic+CalculateFuzziness">CalculateFuzziness</a>()</code>,
<code><a href="#topic+CalculateValue">CalculateValue</a>()</code>,
<code><a href="#topic+CalculateWidth">CalculateWidth</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# prepare some fuzzy numbers (first type of the initial sample)

fuzzyValues &lt;- matrix(c(0.25,0.5,1,1.25,0.75,1,1.5,2.2,-1,0,0,2),
ncol = 4,byrow = TRUE)

# calculate the ambiguity of the first fuzzy number

CalculateAmbiguity(fuzzyValues[1,])

# calculate the ambiguity for the whole matrix

CalculateAmbiguity(fuzzyValues)

# prepare some fuzzy numbers (second type of the initial sample)

fuzzyValuesInc &lt;- matrix(c(0.25,0.5,1,0.25,0.25,1,1.5,0.7,1,0,0,2),
ncol = 4,byrow = TRUE)

# calculate the ambiguity of the first fuzzy number

CalculateAmbiguity(fuzzyValuesInc[1,], increases = TRUE)


</code></pre>

<hr>
<h2 id='CalculateAmbiguityL'>Calculation of the left-hand ambiguity for triangular and trapezoidal fuzzy numbers</h2><span id='topic+CalculateAmbiguityL'></span>

<h3>Description</h3>

<p><code>CalculateAmbiguityL</code> returns the left-hand ambiguity of the triangular or trapezoidal fuzzy number (see, e.g., (Ban et al., 2015),
(Grzegorzewski and Romaniuk, 2022)).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>CalculateAmbiguityL(fuzzyNumber, increases = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="CalculateAmbiguityL_+3A_fuzzynumber">fuzzyNumber</code></td>
<td>
<p>Input data consist of triangular or trapezoidal fuzzy numbers.</p>
</td></tr>
<tr><td><code id="CalculateAmbiguityL_+3A_increases">increases</code></td>
<td>
<p>If <code>TRUE</code> is used, then the initial data should consist of the fuzzy numbers in the form:
left increment of the support, left end of the core, right end of the core,
right increment of the support. Otherwise, the default value <code>FALSE</code> is used and the fuzzy numbers should be given in the form:
left end of the support, left end of the core, right end of the core,
right end of the support.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The input data should consist of triangular or trapezoidal fuzzy numbers, given as a single vector or a whole matrix.
In each row, there should be a single fuzzy number in one of the forms:
</p>

<ol>
<li><p> left end of the support, left end of the core, right end of the core, right end of the support, or
</p>
</li>
<li><p> left increment of the support, left end of the core, right end of the core, right increment of the support.
</p>
</li></ol>

<p>In this second case, the parameter <code>increases=TRUE</code> has to be used.
</p>
<p>Then for each fuzzy number, its characteristics, known as the left-hand ambiguity of fuzzy number, is calculated.
For the respective formulas, see, e.g., (Ban et al., 2015), (Grzegorzewski and Romaniuk, 2022).
</p>


<h3>Value</h3>

<p>This function returns vector of double values.
Each output value is equal to the left-hand ambiguity of the respective fuzzy number.
</p>


<h3>References</h3>

<p>Ban, A.I., Coroianu, L., Grzegorzewski, P. (2015)
Fuzzy Numbers: Approximations, Ranking and Applications
Institute of Computer Sciences, Polish Academy of Sciences
</p>
<p>Grzegorzewski, P., Romaniuk, M. (2022)
Bootstrap methods for fuzzy data
Uncertainty and Imprecision in Decision Making and Decision Support: New Advances, Challenges, and Perspectives, pp. 28-47
Springer
</p>


<h3>See Also</h3>

<p><code><a href="#topic+CalculateFuzziness">CalculateFuzziness</a></code> for calculation of the fuzziness,
<code><a href="#topic+CalculateValue">CalculateValue</a></code> for calculation of the value,
<code><a href="#topic+CalculateAmbiguityR">CalculateAmbiguityR</a></code> for calculation of the right-hand ambiguity,
<code><a href="#topic+CalculateAmbiguity">CalculateAmbiguity</a></code> for calculation of the ambiguity,
<code><a href="#topic+CalculateExpValue">CalculateExpValue</a></code> for calculation of the expected value,
<code><a href="#topic+CalculateWidth">CalculateWidth</a></code> for calculation of the width
</p>
<p>Other characteristics of fuzzy numbers functions: 
<code><a href="#topic+CalculateAmbiguityR">CalculateAmbiguityR</a>()</code>,
<code><a href="#topic+CalculateAmbiguity">CalculateAmbiguity</a>()</code>,
<code><a href="#topic+CalculateExpValue">CalculateExpValue</a>()</code>,
<code><a href="#topic+CalculateFuzziness">CalculateFuzziness</a>()</code>,
<code><a href="#topic+CalculateValue">CalculateValue</a>()</code>,
<code><a href="#topic+CalculateWidth">CalculateWidth</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# prepare some fuzzy numbers (first type of the initial sample)

fuzzyValues &lt;- matrix(c(0.25,0.5,1,1.25,0.75,1,1.5,2.2,-1,0,0,2),
ncol = 4,byrow = TRUE)

# calculate the left-hand ambiguity of the first fuzzy number

CalculateAmbiguityL(fuzzyValues[1,])

# calculate the left-hand ambiguity for the whole matrix

CalculateAmbiguityL(fuzzyValues)

# prepare some fuzzy numbers (second type of the initial sample)

fuzzyValuesInc &lt;- matrix(c(0.25,0.5,1,0.25,0.25,1,1.5,0.7,1,0,0,2),
ncol = 4,byrow = TRUE)

# calculate the left-hand ambiguity of the first fuzzy number

CalculateAmbiguityL(fuzzyValuesInc[1,], increases = TRUE)


</code></pre>

<hr>
<h2 id='CalculateAmbiguityR'>Calculation of the right-hand ambiguity for triangular and trapezoidal fuzzy numbers</h2><span id='topic+CalculateAmbiguityR'></span>

<h3>Description</h3>

<p><code>CalculateAmbiguityR</code> returns the right-hand ambiguity of the triangular or trapezoidal fuzzy number (see, e.g., (Ban et al., 2015),
(Grzegorzewski and Romaniuk, 2022)).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>CalculateAmbiguityR(fuzzyNumber, increases = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="CalculateAmbiguityR_+3A_fuzzynumber">fuzzyNumber</code></td>
<td>
<p>Input data consist of triangular or trapezoidal fuzzy numbers.</p>
</td></tr>
<tr><td><code id="CalculateAmbiguityR_+3A_increases">increases</code></td>
<td>
<p>If <code>TRUE</code> is used, then the initial data should consist of the fuzzy numbers in the form:
left increment of the support, left end of the core, right end of the core,
right increment of the support. Otherwise, the default value <code>FALSE</code> is used and the fuzzy numbers should be given in the form:
left end of the support, left end of the core, right end of the core,
right end of the support.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The input data should consist of triangular or trapezoidal fuzzy numbers, given as a single vector or a whole matrix.
In each row, there should be a single fuzzy number in one of the forms:
</p>

<ol>
<li><p> left end of the support, left end of the core, right end of the core, right end of the support, or
</p>
</li>
<li><p> left increment of the support, left end of the core, right end of the core, right increment of the support.
</p>
</li></ol>

<p>In this second case, the parameter <code>increases=TRUE</code> has to be used.
</p>
<p>Then for each fuzzy number, its characteristics, known as the right-hand ambiguity of fuzzy number, is calculated.
For the respective formulas, see, e.g., (Ban et al., 2015), (Grzegorzewski and Romaniuk, 2022).
</p>


<h3>Value</h3>

<p>This function returns vector of double values.
Each output value is equal to the right-hand ambiguity of the respective fuzzy number.
</p>


<h3>References</h3>

<p>Ban, A.I., Coroianu, L., Grzegorzewski, P. (2015)
Fuzy Numbers: Approximations, Ranking and Applications
Institute of Computer Sciences, Polish Academy of Sciences
</p>
<p>Grzegorzewski, P., Romaniuk, M. (2022)
Bootstrap methods for fuzzy data
Uncertainty and Imprecision in Decision Making and Decision Support: New Advances, Challenges, and Perspectives, pp. 28-47
Springer
</p>


<h3>See Also</h3>

<p><code><a href="#topic+CalculateFuzziness">CalculateFuzziness</a></code> for calculation of the fuzziness,
<code><a href="#topic+CalculateValue">CalculateValue</a></code> for calculation of the value,
<code><a href="#topic+CalculateAmbiguityL">CalculateAmbiguityL</a></code> for calculation of the left-hand ambiguity,
<code><a href="#topic+CalculateAmbiguity">CalculateAmbiguity</a></code> for calculation of the ambiguity,
<code><a href="#topic+CalculateExpValue">CalculateExpValue</a></code> for calculation of the expected value,
<code><a href="#topic+CalculateWidth">CalculateWidth</a></code> for calculation of the width
</p>
<p>Other characteristics of fuzzy numbers functions: 
<code><a href="#topic+CalculateAmbiguityL">CalculateAmbiguityL</a>()</code>,
<code><a href="#topic+CalculateAmbiguity">CalculateAmbiguity</a>()</code>,
<code><a href="#topic+CalculateExpValue">CalculateExpValue</a>()</code>,
<code><a href="#topic+CalculateFuzziness">CalculateFuzziness</a>()</code>,
<code><a href="#topic+CalculateValue">CalculateValue</a>()</code>,
<code><a href="#topic+CalculateWidth">CalculateWidth</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# prepare some fuzzy numbers (first type of the initial sample)

fuzzyValues &lt;- matrix(c(0.25,0.5,1,1.25,0.75,1,1.5,2.2,-1,0,0,2),
ncol = 4,byrow = TRUE)

# calculate the right-hand ambiguity of the first fuzzy number

CalculateAmbiguityR(fuzzyValues[1,])

# calculate the right-hand ambiguity for the whole matrix

CalculateAmbiguityR(fuzzyValues)

# prepare some fuzzy numbers (second type of the initial sample)

fuzzyValuesInc &lt;- matrix(c(0.25,0.5,1,0.25,0.25,1,1.5,0.7,1,0,0,2),
ncol = 4,byrow = TRUE)

# calculate the right-hand ambiguity of the first fuzzy number

CalculateAmbiguityR(fuzzyValuesInc[1,], increases = TRUE)


</code></pre>

<hr>
<h2 id='CalculateExpValue'>Calculation of the expected value for triangular and trapezoidal fuzzy numbers</h2><span id='topic+CalculateExpValue'></span>

<h3>Description</h3>

<p><code>CalculateExpValue</code> returns the expected value of the triangular or trapezoidal fuzzy number (see, e.g., (Ban et al., 2015),
(Grzegorzewski and Romaniuk, 2022)).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>CalculateExpValue(fuzzyNumber, increases = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="CalculateExpValue_+3A_fuzzynumber">fuzzyNumber</code></td>
<td>
<p>Input data consist of triangular or trapezoidal fuzzy numbers.</p>
</td></tr>
<tr><td><code id="CalculateExpValue_+3A_increases">increases</code></td>
<td>
<p>If <code>TRUE</code> is used, then the initial data should consist of the fuzzy numbers in the form:
left increment of the support, left end of the core, right end of the core,
right increment of the support. Otherwise, the default value <code>FALSE</code> is used and the fuzzy numbers should be given in the form:
left end of the support, left end of the core, right end of the core,
right end of the support.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The input data should consist of triangular or trapezoidal fuzzy numbers, given as a single vector or a whole matrix.
In each row, there should be a single fuzzy number in one of the forms:
</p>

<ol>
<li><p> left end of the support, left end of the core, right end of the core, right end of the support, or
</p>
</li>
<li><p> left increment of the support, left end of the core, right end of the core, right increment of the support.
</p>
</li></ol>

<p>In this second case, the parameter <code>increases=TRUE</code> has to be used.
</p>
<p>Then for each fuzzy number, its characteristics, known as the expected value of fuzzy number, is calculated.
For the respective formulas, see, e.g., (Ban et al., 2015), (Grzegorzewski and Romaniuk, 2022).
</p>


<h3>Value</h3>

<p>This function returns vector of double values.
Each output value is equal to the expected value of the respective fuzzy number.
</p>


<h3>References</h3>

<p>Ban, A.I., Coroianu, L., Grzegorzewski, P. (2015)
Fuzzy Numbers: Approximations, Ranking and Applications
Institute of Computer Sciences, Polish Academy of Sciences
</p>
<p>Grzegorzewski, P., Romaniuk, M. (2022)
Bootstrap methods for fuzzy data
Uncertainty and Imprecision in Decision Making and Decision Support: New Advances, Challenges, and Perspectives, pp. 28-47
Springer
</p>


<h3>See Also</h3>

<p><code><a href="#topic+CalculateFuzziness">CalculateFuzziness</a></code> for calculation of the fuzziness,
<code><a href="#topic+CalculateAmbiguityL">CalculateAmbiguityL</a></code> for calculation of the left-hand ambiguity,
<code><a href="#topic+CalculateAmbiguityR">CalculateAmbiguityR</a></code> for calculation of the right-hand ambiguity,
<code><a href="#topic+CalculateAmbiguity">CalculateAmbiguity</a></code> for calculation of the ambiguity,
<code><a href="#topic+CalculateWidth">CalculateWidth</a></code> for calculation of the width,
<code><a href="#topic+CalculateValue">CalculateValue</a></code> for calculation of the value
</p>
<p>Other characteristics of fuzzy numbers functions: 
<code><a href="#topic+CalculateAmbiguityL">CalculateAmbiguityL</a>()</code>,
<code><a href="#topic+CalculateAmbiguityR">CalculateAmbiguityR</a>()</code>,
<code><a href="#topic+CalculateAmbiguity">CalculateAmbiguity</a>()</code>,
<code><a href="#topic+CalculateFuzziness">CalculateFuzziness</a>()</code>,
<code><a href="#topic+CalculateValue">CalculateValue</a>()</code>,
<code><a href="#topic+CalculateWidth">CalculateWidth</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# prepare some fuzzy numbers (first type of the initial sample)

fuzzyValues &lt;- matrix(c(0.25,0.5,1,1.25,0.75,1,1.5,2.2,-1,0,0,2),
ncol = 4,byrow = TRUE)

# calculate the expected value of the first fuzzy number

CalculateExpValue(fuzzyValues[1,])

# calculate the expected value for the whole matrix

CalculateExpValue(fuzzyValues)

# prepare some fuzzy numbers (second type of the initial sample)

fuzzyValuesInc &lt;- matrix(c(0.25,0.5,1,0.25,0.25,1,1.5,0.7,1,0,0,2),
ncol = 4,byrow = TRUE)

# calculate the expected value of the first fuzzy number

CalculateExpValue(fuzzyValuesInc[1,], increases = TRUE)


</code></pre>

<hr>
<h2 id='CalculateFuzziness'>Calculation of the fuzziness for triangular and trapezoidal fuzzy numbers</h2><span id='topic+CalculateFuzziness'></span>

<h3>Description</h3>

<p><code>CalculateFuzziness</code> returns the fuzziness of the triangular or trapezoidal fuzzy number (see, e.g., (Ban et al., 2015),
(Grzegorzewski et al., 2020)).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>CalculateFuzziness(fuzzyNumber, increases = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="CalculateFuzziness_+3A_fuzzynumber">fuzzyNumber</code></td>
<td>
<p>Input data consist of triangular or trapezoidal fuzzy numbers.</p>
</td></tr>
<tr><td><code id="CalculateFuzziness_+3A_increases">increases</code></td>
<td>
<p>If <code>TRUE</code> is used, then the initial data should consist of the fuzzy numbers in the form:
left increment of the support, left end of the core, right end of the core,
right increment of the support. Otherwise, the default value <code>FALSE</code> is used and the fuzzy numbers should be given in the form:
left end of the support, left end of the core, right end of the core,
right end of the support.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The input data should consist of triangular or trapezoidal fuzzy numbers, given as a single vector or a whole matrix.
In each row, there should be a single fuzzy number in one of the forms:
</p>

<ol>
<li><p> left end of the support, left end of the core, right end of the core, right end of the support, or
</p>
</li>
<li><p> left increment of the support, left end of the core, right end of the core, right increment of the support.
</p>
</li></ol>

<p>In this second case, the parameter <code>increases=TRUE</code> has to be used.
</p>
<p>Then for each fuzzy number, its characteristics, known as the fuzziness of fuzzy number, is calculated.
For the respective formulas, see, e.g., (Ban et al., 2015), (Grzegorzewski et al., 2020)).
</p>


<h3>Value</h3>

<p>This function returns vector of double values.
Each output value is equal to the fuzziness of the respective fuzzy number.
</p>


<h3>References</h3>

<p>Ban, A.I., Coroianu, L., Grzegorzewski, P. (2015)
Fuzy Numbers: Approximations, Ranking and Applications
Institute of Computer Sciences, Polish Academy of Sciences
</p>
<p>Grzegorzewski, P., Hryniewicz, O., Romaniuk, M. (2020)
Flexible resampling for fuzzy data based on the canonical representation
International Journal of Computational Intelligence Systems, 13 (1), pp. 1650-1662
</p>


<h3>See Also</h3>

<p><code><a href="#topic+CalculateValue">CalculateValue</a></code> for calculation of the value,
<code><a href="#topic+CalculateAmbiguityL">CalculateAmbiguityL</a></code> for calculation of the left-hand ambiguity,
<code><a href="#topic+CalculateAmbiguityR">CalculateAmbiguityR</a></code> for calculation of the right-hand ambiguity,
<code><a href="#topic+CalculateAmbiguity">CalculateAmbiguity</a></code> for calculation of the ambiguity,
<code><a href="#topic+CalculateExpValue">CalculateExpValue</a></code> for calculation of the expected value,
<code><a href="#topic+CalculateWidth">CalculateWidth</a></code> for calculation of the width
</p>
<p>Other characteristics of fuzzy numbers functions: 
<code><a href="#topic+CalculateAmbiguityL">CalculateAmbiguityL</a>()</code>,
<code><a href="#topic+CalculateAmbiguityR">CalculateAmbiguityR</a>()</code>,
<code><a href="#topic+CalculateAmbiguity">CalculateAmbiguity</a>()</code>,
<code><a href="#topic+CalculateExpValue">CalculateExpValue</a>()</code>,
<code><a href="#topic+CalculateValue">CalculateValue</a>()</code>,
<code><a href="#topic+CalculateWidth">CalculateWidth</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# prepare some fuzzy numbers (first type of the initial sample)

fuzzyValues &lt;- matrix(c(0.25,0.5,1,1.25,0.75,1,1.5,2.2,-1,0,0,2),
ncol = 4,byrow = TRUE)

# calculate the fuzziness of the first fuzzy number

CalculateFuzziness(fuzzyValues[1,])

# calculate the fuzziness for the whole matrix

CalculateFuzziness(fuzzyValues)

# prepare some fuzzy numbers (second type of the initial sample)

fuzzyValuesInc &lt;- matrix(c(0.25,0.5,1,0.25,0.25,1,1.5,0.7,1,0,0,2),
ncol = 4,byrow = TRUE)

# calculate the fuzziness of the first fuzzy number

CalculateFuzziness(fuzzyValuesInc[1,], increases = TRUE)


</code></pre>

<hr>
<h2 id='CalculateValue'>Calculation of the value for triangular and trapezoidal fuzzy numbers</h2><span id='topic+CalculateValue'></span>

<h3>Description</h3>

<p><code>CalculateValue</code> returns the value of the triangular or trapezoidal fuzzy number (see, e.g., (Ban et al., 2015),
(Grzegorzewski and Romaniuk, 2022)).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>CalculateValue(fuzzyNumber, increases = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="CalculateValue_+3A_fuzzynumber">fuzzyNumber</code></td>
<td>
<p>Input data consist of triangular or trapezoidal fuzzy numbers.</p>
</td></tr>
<tr><td><code id="CalculateValue_+3A_increases">increases</code></td>
<td>
<p>If <code>TRUE</code> is used, then the initial data should consist of the fuzzy numbers in the form:
left increment of the support, left end of the core, right end of the core,
right increment of the support. Otherwise, the default value <code>FALSE</code> is used and the fuzzy numbers should be given in the form:
left end of the support, left end of the core, right end of the core,
right end of the support.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The input data should consist of triangular or trapezoidal fuzzy numbers, given as a single vector or a whole matrix.
In each row, there should be a single fuzzy number in one of the forms:
</p>

<ol>
<li><p> left end of the support, left end of the core, right end of the core, right end of the support, or
</p>
</li>
<li><p> left increment of the support, left end of the core, right end of the core, right increment of the support.
</p>
</li></ol>

<p>In this second case, the parameter <code>increases=TRUE</code> has to be used.
</p>
<p>Then for each fuzzy number, its characteristics, known as the value of fuzzy number, is calculated.
For the respective formulas, see, e.g., (Ban et al., 2015), (Grzegorzewski and Romaniuk, 2022).
</p>


<h3>Value</h3>

<p>This function returns vector of double values.
Each output value is equal to the value of the respective fuzzy number.
</p>


<h3>References</h3>

<p>Ban, A.I., Coroianu, L., Grzegorzewski, P. (2015)
Fuzzy Numbers: Approximations, Ranking and Applications
Institute of Computer Sciences, Polish Academy of Sciences
</p>
<p>Grzegorzewski, P., Romaniuk, M. (2022)
Bootstrap methods for fuzzy data
Uncertainty and Imprecision in Decision Making and Decision Support: New Advances, Challenges, and Perspectives, pp. 28-47
Springer
</p>


<h3>See Also</h3>

<p><code><a href="#topic+CalculateFuzziness">CalculateFuzziness</a></code> for calculation of the fuzziness,
<code><a href="#topic+CalculateAmbiguityL">CalculateAmbiguityL</a></code> for calculation of the left-hand ambiguity,
<code><a href="#topic+CalculateAmbiguityR">CalculateAmbiguityR</a></code> for calculation of the right-hand ambiguity,
<code><a href="#topic+CalculateAmbiguity">CalculateAmbiguity</a></code> for calculation of the ambiguity,
<code><a href="#topic+CalculateExpValue">CalculateExpValue</a></code> for calculation of the expected value,
<code><a href="#topic+CalculateWidth">CalculateWidth</a></code> for calculation of the width
</p>
<p>Other characteristics of fuzzy numbers functions: 
<code><a href="#topic+CalculateAmbiguityL">CalculateAmbiguityL</a>()</code>,
<code><a href="#topic+CalculateAmbiguityR">CalculateAmbiguityR</a>()</code>,
<code><a href="#topic+CalculateAmbiguity">CalculateAmbiguity</a>()</code>,
<code><a href="#topic+CalculateExpValue">CalculateExpValue</a>()</code>,
<code><a href="#topic+CalculateFuzziness">CalculateFuzziness</a>()</code>,
<code><a href="#topic+CalculateWidth">CalculateWidth</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# prepare some fuzzy numbers (first type of the initial sample)

fuzzyValues &lt;- matrix(c(0.25,0.5,1,1.25,0.75,1,1.5,2.2,-1,0,0,2),
ncol = 4,byrow = TRUE)

# calculate the value of the first fuzzy number

CalculateValue(fuzzyValues[1,])

# calculate the values for the whole matrix

CalculateValue(fuzzyValues)

# prepare some fuzzy numbers (second type of the initial sample)

fuzzyValuesInc &lt;- matrix(c(0.25,0.5,1,0.25,0.25,1,1.5,0.7,1,0,0,2),
ncol = 4,byrow = TRUE)

# calculate the value of the first fuzzy number

CalculateValue(fuzzyValuesInc[1,], increases = TRUE)


</code></pre>

<hr>
<h2 id='CalculateWidth'>Calculation of the width for triangular and trapezoidal fuzzy numbers</h2><span id='topic+CalculateWidth'></span>

<h3>Description</h3>

<p><code>CalculateWidth</code> returns the width of the triangular or trapezoidal fuzzy number (see, e.g., (Ban et al., 2015),
(Grzegorzewski and Romaniuk, 2022)).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>CalculateWidth(fuzzyNumber, increases = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="CalculateWidth_+3A_fuzzynumber">fuzzyNumber</code></td>
<td>
<p>Input data consist of triangular or trapezoidal fuzzy numbers.</p>
</td></tr>
<tr><td><code id="CalculateWidth_+3A_increases">increases</code></td>
<td>
<p>If <code>TRUE</code> is used, then the initial data should consist of the fuzzy numbers in the form:
left increment of the support, left end of the core, right end of the core,
right increment of the support. Otherwise, the default value <code>FALSE</code> is used and the fuzzy numbers should be given in the form:
left end of the support, left end of the core, right end of the core,
right end of the support.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The input data should consist of triangular or trapezoidal fuzzy numbers, given as a single vector or a whole matrix.
In each row, there should be a single fuzzy number in one of the forms:
</p>

<ol>
<li><p> left end of the support, left end of the core, right end of the core, right end of the support, or
</p>
</li>
<li><p> left increment of the support, left end of the core, right end of the core, right increment of the support.
</p>
</li></ol>

<p>In this second case, the parameter <code>increases=TRUE</code> has to be used.
</p>
<p>Then for each fuzzy number, its characteristics, known as the width of fuzzy number, is calculated.
For the respective formulas, see, e.g., (Ban et al., 2015), (Grzegorzewski and Romaniuk, 2022).
</p>


<h3>Value</h3>

<p>This function returns vector of double values.
Each output value is equal to the width of the respective fuzzy number.
</p>


<h3>References</h3>

<p>Ban, A.I., Coroianu, L., Grzegorzewski, P. (2015)
Fuzzy Numbers: Approximations, Ranking and Applications
Institute of Computer Sciences, Polish Academy of Sciences
</p>
<p>Grzegorzewski, P., Romaniuk, M. (2022)
Bootstrap methods for fuzzy data
Uncertainty and Imprecision in Decision Making and Decision Support: New Advances, Challenges, and Perspectives, pp. 28-47
Springer
</p>


<h3>See Also</h3>

<p><code><a href="#topic+CalculateFuzziness">CalculateFuzziness</a></code> for calculation of the fuzziness,
<code><a href="#topic+CalculateAmbiguityL">CalculateAmbiguityL</a></code> for calculation of the left-hand ambiguity,
<code><a href="#topic+CalculateAmbiguityR">CalculateAmbiguityR</a></code> for calculation of the right-hand ambiguity,
<code><a href="#topic+CalculateAmbiguity">CalculateAmbiguity</a></code> for calculation of the ambiguity,
<code><a href="#topic+CalculateExpValue">CalculateExpValue</a></code> for calculation of the expected value,
<code><a href="#topic+CalculateValue">CalculateValue</a></code> for calculation of the value
</p>
<p>Other characteristics of fuzzy numbers functions: 
<code><a href="#topic+CalculateAmbiguityL">CalculateAmbiguityL</a>()</code>,
<code><a href="#topic+CalculateAmbiguityR">CalculateAmbiguityR</a>()</code>,
<code><a href="#topic+CalculateAmbiguity">CalculateAmbiguity</a>()</code>,
<code><a href="#topic+CalculateExpValue">CalculateExpValue</a>()</code>,
<code><a href="#topic+CalculateFuzziness">CalculateFuzziness</a>()</code>,
<code><a href="#topic+CalculateValue">CalculateValue</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# prepare some fuzzy numbers (first type of the initial sample)

fuzzyValues &lt;- matrix(c(0.25,0.5,1,1.25,0.75,1,1.5,2.2,-1,0,0,2),
ncol = 4,byrow = TRUE)

# calculate the width of the first fuzzy number

CalculateWidth(fuzzyValues[1,])

# calculate the width for the whole matrix

CalculateWidth(fuzzyValues)

# prepare some fuzzy numbers (second type of the initial sample)

fuzzyValuesInc &lt;- matrix(c(0.25,0.5,1,0.25,0.25,1,1.5,0.7,1,0,0,2),
ncol = 4,byrow = TRUE)

# calculate the width of the first fuzzy number

CalculateWidth(fuzzyValuesInc[1,], increases = TRUE)


</code></pre>

<hr>
<h2 id='ClassicalBootstrap'>Classical bootstrap procedure for triangular and trapezoidal fuzzy numbers</h2><span id='topic+ClassicalBootstrap'></span>

<h3>Description</h3>

<p><code>ClassicalBootstrap</code> returns the bootstrapped (secondary) sample based on the initial sample and uses the Efron's (i.e. classical) resampling
scheme (see (Efron, 1994)).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ClassicalBootstrap(initialSample, b = n, increases = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ClassicalBootstrap_+3A_initialsample">initialSample</code></td>
<td>
<p>Initial sample of triangular or trapezoidal fuzzy numbers.</p>
</td></tr>
<tr><td><code id="ClassicalBootstrap_+3A_b">b</code></td>
<td>
<p>The number of fuzzy values in the resampled (secondary) sample.
If this parameter is not specified, the number of values in the initial sample is used.
The parameter should be integer value more than 0.</p>
</td></tr>
<tr><td><code id="ClassicalBootstrap_+3A_increases">increases</code></td>
<td>
<p>If <code>TRUE</code> is used, then the initial sample should consist of the fuzzy numbers in the form:
left increment of the support, left end of the core, right end of the core,
right increment of the support. Otherwise, the default value <code>FALSE</code> is used and the fuzzy numbers should be given in the form:
left end of the support, left end of the core, right end of the core,
right end of the support.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The initial sample should consist of triangular or trapezoidal fuzzy numbers, given as a single vector or a whole matrix.
In each row, there should be a single fuzzy number in one of the forms:
</p>

<ol>
<li><p> left end of the support, left end of the core, right end of the core, right end of the support, or
</p>
</li>
<li><p> left increment of the support, left end of the core, right end of the core, right increment of the support.
</p>
</li></ol>

<p>In this second case, the parameter <code>increases=TRUE</code> has to be used.
</p>
<p>The resampling procedure produces <code>b</code> fuzzy values, which are randomly chosen (with repetition) from the initial sample
(without any alternations).
If the parameter <code>b</code> is not specified, it is equal to the length of the initial sample.
The output is given in the same form as the initial sample.
</p>


<h3>Value</h3>

<p>This function returns matrix with <code>b</code> rows of double values.
In each row, there is a single resampled fuzzy number.
These fuzzy numbers have the same form as the values from the initial sample depending on the provided parameter <code>increases</code>.
</p>


<h3>References</h3>

<p>Efron, B. (1994). An Introduction to the Bootstrap.
CRC Press
</p>


<h3>See Also</h3>

<p><code><a href="#topic+VAMethod">VAMethod</a></code> for the VA method,
<code><a href="#topic+EWMethod">EWMethod</a></code> for the EW method, <code><a href="#topic+VAFMethod">VAFMethod</a></code> for the VAF method,
<code><a href="#topic+VAAMethod">VAAMethod</a></code> for the VAA method, <code><a href="#topic+DMethod">DMethod</a></code> for the d method, <code><a href="#topic+WMethod">WMethod</a></code> for the w method
</p>
<p>Other resampling functions: 
<code><a href="#topic+DMethod">DMethod</a>()</code>,
<code><a href="#topic+EWMethod">EWMethod</a>()</code>,
<code><a href="#topic+VAAMethod">VAAMethod</a>()</code>,
<code><a href="#topic+VAFMethod">VAFMethod</a>()</code>,
<code><a href="#topic+VAMethod">VAMethod</a>()</code>,
<code><a href="#topic+WMethod">WMethod</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# prepare some fuzzy numbers (first type of the initial sample)

fuzzyValues &lt;- matrix(c(0.25,0.5,1,1.25,0.75,1,1.5,2.2,-1,0,0,2),
ncol = 4,byrow = TRUE)

# generate bootstrap sample

set.seed(12345)

ClassicalBootstrap(fuzzyValues)

ClassicalBootstrap(fuzzyValues,b=4)

# prepare some fuzzy numbers (second type of the initial sample)

fuzzyValuesInc &lt;- matrix(c(0.25,0.5,1,0.25,0.25,1,1.5,0.7,1,0,0,2),
ncol = 4,byrow = TRUE)

# generate bootstrap sample

ClassicalBootstrap(fuzzyValuesInc,increases = TRUE)

ClassicalBootstrap(fuzzyValuesInc,b=4,increases = TRUE)

</code></pre>

<hr>
<h2 id='ComparePowerOneSampleCTest'>Comparison of the resampling approaches based on the power for the one-sample test for the mean.</h2><span id='topic+ComparePowerOneSampleCTest'></span>

<h3>Description</h3>

<p><code>ComparePowerOneSampleCTest</code> returns the percentage of rejections for the one-sample C-test when different resampling methods
are used.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ComparePowerOneSampleCTest(
  generator,
  mu_0,
  shiftVector,
  sampleSize = 10,
  numberOfSamples = 10,
  initialSamples = 100,
  theta = 1/3,
  significance = 0.05,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ComparePowerOneSampleCTest_+3A_generator">generator</code></td>
<td>
<p>Name of the generator for sampling initial samples.
For the possible names check the values of <code>samplingGenerators</code> vector.</p>
</td></tr>
<tr><td><code id="ComparePowerOneSampleCTest_+3A_mu_0">mu_0</code></td>
<td>
<p>Triangular or trapezoidal fuzzy number which is used for the null hypothesis of the C-test.</p>
</td></tr>
<tr><td><code id="ComparePowerOneSampleCTest_+3A_shiftvector">shiftVector</code></td>
<td>
<p>Deterministic vector of shifts that are sequentially added to all initial samples.</p>
</td></tr>
<tr><td><code id="ComparePowerOneSampleCTest_+3A_samplesize">sampleSize</code></td>
<td>
<p>Size of the single initial sample.</p>
</td></tr>
<tr><td><code id="ComparePowerOneSampleCTest_+3A_numberofsamples">numberOfSamples</code></td>
<td>
<p>Number of the bootstrapped samples used to estimate the p-value.</p>
</td></tr>
<tr><td><code id="ComparePowerOneSampleCTest_+3A_initialsamples">initialSamples</code></td>
<td>
<p>Number of the generated initial samples.
More than one value can be given in the form of matrix.</p>
</td></tr>
<tr><td><code id="ComparePowerOneSampleCTest_+3A_theta">theta</code></td>
<td>
<p>The weighting parameter for the mid/spread distance applied in the C-test.</p>
</td></tr>
<tr><td><code id="ComparePowerOneSampleCTest_+3A_significance">significance</code></td>
<td>
<p>The significance value used to accept/reject the hypothesis for the one-sample C-test.</p>
</td></tr>
<tr><td><code id="ComparePowerOneSampleCTest_+3A_...">...</code></td>
<td>
<p>Parameters which are passed to <code>OneSampleCTest</code> or the respective <code>generator</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function generates a sequence of initial samples (their number is given in <code>initialSamples</code>,
the size is determined by <code>sampleSize</code>) for fuzzy numbers of the type specified by <code>generator</code>.
Then a sequence of deterministic shifts described by vector <code>shiftVector</code> is added to
each fuzzy observation in these samples.
Next, function <code>OneSampleCTest</code> is executed to calculate the p-value for each combination of the initial sample and
resampling method. Then, by comparing the p-value with the assumed significance level
<code>significance</code> we make a decision whether to reject the null hypothesis for the one-sample C-test for the mean
(see Lubiano et al. (2016))  or not.
The output of this procedure is the percentage of rejections as a function of values from <code>shiftVector</code>.
</p>


<h3>Value</h3>

<p>This function returns a matrix of percentage of rejections for the one-sample C-test for the mean.
Rows in this matrix
are related to the values from <code>shiftVector</code>, and the columns - to all resampling methods.
</p>


<h3>References</h3>

<p>Lubiano, M.A., Montenegro M., Sinova, B., de Saa, S.R., Gil, M.A. (2016)
Hypothesis testing for means in connection with fuzzy rating scale-based data: algorithms and applications
European Journal of Operational Research, 251, pp. 918-929
</p>


<h3>See Also</h3>

<p><code><a href="#topic+ComparisonSEMean">ComparisonSEMean</a></code> for the comparison of resampling methods based on SE/MSE for the mean,
<code><a href="#topic+ComparisonOneSampleCTest">ComparisonOneSampleCTest</a></code> for the comparison of resampling methods based on power for the one-sample C-test
for the mean.
</p>
<p>Other comparison of resampling methods: 
<code><a href="#topic+ComparisonOneSampleCTest">ComparisonOneSampleCTest</a>()</code>,
<code><a href="#topic+ComparisonSEMean">ComparisonSEMean</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Not run: 

# seed PRNG

set.seed(1234)

# compare the resampling methods for the synthetic data generated using GeneratorNU function
# and two values of the shifts

ComparePowerOneSampleCTest("GeneratorNU",mu_0 = c(-0.4,-0.1,0.1,0.4), shiftVector = c(0,0.5),
mu = 0, sigma = 1, a = 0.2, b = 0.6)
## End(Not run)




</code></pre>

<hr>
<h2 id='ComparisonOneSampleCTest'>Comparison of the resampling approaches based on the power for the one-sample test for the mean.</h2><span id='topic+ComparisonOneSampleCTest'></span>

<h3>Description</h3>

<p><code>ComparisonOneSampleCTest</code> returns the percentage of rejections for the one-sample C-test when different resampling methods
are used.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ComparisonOneSampleCTest(
  generator,
  mu_0,
  shift = 0,
  sampleSize = 10,
  numberOfSamples = 10,
  initialSamples = 100,
  theta = 1/3,
  significance = 0.05,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ComparisonOneSampleCTest_+3A_generator">generator</code></td>
<td>
<p>Name of the generator for sampling initial samples.
For the possible names check the values of <code>samplingGenerators</code> vector.</p>
</td></tr>
<tr><td><code id="ComparisonOneSampleCTest_+3A_mu_0">mu_0</code></td>
<td>
<p>Triangular or trapezoidal fuzzy number which is used for the null hypothesis of the C-test.</p>
</td></tr>
<tr><td><code id="ComparisonOneSampleCTest_+3A_shift">shift</code></td>
<td>
<p>Deterministic shift added to all initial samples.</p>
</td></tr>
<tr><td><code id="ComparisonOneSampleCTest_+3A_samplesize">sampleSize</code></td>
<td>
<p>Size of the single initial sample.</p>
</td></tr>
<tr><td><code id="ComparisonOneSampleCTest_+3A_numberofsamples">numberOfSamples</code></td>
<td>
<p>Number of the bootstrapped samples used to estimate the p-value.</p>
</td></tr>
<tr><td><code id="ComparisonOneSampleCTest_+3A_initialsamples">initialSamples</code></td>
<td>
<p>Number of the generated initial samples.
More than one value can be given in the form of matrix.</p>
</td></tr>
<tr><td><code id="ComparisonOneSampleCTest_+3A_theta">theta</code></td>
<td>
<p>The weighting parameter for the mid/spread distance applied in the C-test.</p>
</td></tr>
<tr><td><code id="ComparisonOneSampleCTest_+3A_significance">significance</code></td>
<td>
<p>The significance value used to accept/reject the hypothesis for the one-sample C-test.</p>
</td></tr>
<tr><td><code id="ComparisonOneSampleCTest_+3A_...">...</code></td>
<td>
<p>Parameters which are passed to <code>OneSampleCTest</code> or the respective <code>generator</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function generates a sequence of initial samples (their number is given in <code>initialSamples</code>,
the size is determined by <code>sampleSize</code>) for fuzzy numbers of the type specified by <code>generator</code>.
Then some deterministic shift of the size <code>shift</code> is added to each fuzzy observation in these samples.
Next, function <code>OneSampleCTest</code> is executed to calculate the p-value for each combination of the initial sample and
resampling method. Then, by comparing the p-value with the assumed significance level
<code>significance</code> we make a decision whether to reject the null hypothesis for the one-sample C-test for the mean
(see Lubiano et al. (2016))  or not.
The output of this procedure is the percentage of rejections in the sequence of experiments.
</p>


<h3>Value</h3>

<p>This function returns a vector of percentage of rejections for the one-sample C-test for the mean.
</p>


<h3>References</h3>

<p>Lubiano, M.A., Montenegro M., Sinova, B., de Saa, S.R., Gil, M.A. (2016)
Hypothesis testing for means in connection with fuzzy rating scale-based data: algorithms and applications
European Journal of Operational Research, 251, pp. 918-929
</p>


<h3>See Also</h3>

<p><code><a href="#topic+ComparisonSEMean">ComparisonSEMean</a></code> for the comparison of resampling methods based on SE/MSE for the mean,
<code><a href="#topic+ComparePowerOneSampleCTest">ComparePowerOneSampleCTest</a></code> for the comparison of resampling methods based on power for the one-sample C-test
for the mean.
</p>
<p>Other comparison of resampling methods: 
<code><a href="#topic+ComparePowerOneSampleCTest">ComparePowerOneSampleCTest</a>()</code>,
<code><a href="#topic+ComparisonSEMean">ComparisonSEMean</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Not run: 

# seed PRNG

set.seed(1234)

# compare the resampling methods for the synthetic data generated using GeneratorNU function

ComparisonOneSampleCTest(generator="GeneratorNU",mu_0 = c(-0.4,-0.1,0.1,0.4),
 sampleSize = 10,numberOfSamples = 100, initialSamples = 100,mu = 0, sigma = 1,a = 0.2,b = 0.6)
## End(Not run)




</code></pre>

<hr>
<h2 id='ComparisonSEMean'>Comparison of the resampling approaches based on the SE/MSE for the mean.</h2><span id='topic+ComparisonSEMean'></span>

<h3>Description</h3>

<p><code>ComparisonSEMean</code> estimates the standard error (SE) or the mean-squared error (MSE) for the mean for
all resampling approaches.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ComparisonSEMean(
  generator,
  sampleSize = 10,
  numberOfSamples = 100,
  repetitions = 100,
  trueMean = NA,
  theta = 1/3,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ComparisonSEMean_+3A_generator">generator</code></td>
<td>
<p>Name of the generator for sampling initial samples.
For the possible names check the values of <code>samplingGenerators</code> vector.</p>
</td></tr>
<tr><td><code id="ComparisonSEMean_+3A_samplesize">sampleSize</code></td>
<td>
<p>Size of the single initial sample.</p>
</td></tr>
<tr><td><code id="ComparisonSEMean_+3A_numberofsamples">numberOfSamples</code></td>
<td>
<p>Number of the initial samples.</p>
</td></tr>
<tr><td><code id="ComparisonSEMean_+3A_repetitions">repetitions</code></td>
<td>
<p>Number of the secondary samples which are created using the selected resampling method.</p>
</td></tr>
<tr><td><code id="ComparisonSEMean_+3A_truemean">trueMean</code></td>
<td>
<p>If the value is given, then the mean-squared error (MSE) is calculated for this value and the means of the bootstrapped
samples. Otherwise, the standard error (SE) is calculated based on the overall mean of the secondary samples.</p>
</td></tr>
<tr><td><code id="ComparisonSEMean_+3A_theta">theta</code></td>
<td>
<p>The weighting parameter for the mid/spread distance applied in the C-test.</p>
</td></tr>
<tr><td><code id="ComparisonSEMean_+3A_...">...</code></td>
<td>
<p>Parameters which are passed to <code>SEResamplingMean</code> or the respective <code>generator</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function generates a sequence of initial samples (their number is given in <code>initialSamples</code>,
the size is determined by <code>sampleSize</code>) for fuzzy numbers of the type specified by <code>generator</code>.
Then the SE/MSE is calculated for each combination of the initial sample and
resampling method using <code>SEResamplingMean</code>. The output values are the SE/MSE averaged by <code>initialSamples</code>.
</p>


<h3>Value</h3>

<p>This function returns a vector of the averaged SE/MSE for the mean.
</p>


<h3>References</h3>

<p>Bertoluzza, C., Corral, N., Salas, A. (1995)
On a new class of distances between fuzzy numbers
Mathware and Soft Computing, 2 (2), pp. 71-84
</p>
<p>Grzegorzewski, P., Romaniuk, M. (2022)
Bootstrap methods for fuzzy data
Uncertainty and Imprecision in Decision Making and Decision Support: New Advances, Challenges, and Perspectives, pp. 28-47
Springer
</p>


<h3>See Also</h3>

<p><code><a href="#topic+ComparisonOneSampleCTest">ComparisonOneSampleCTest</a></code> for the comparison of resampling methods based on power for the one-sample C-test
for the mean,
<code><a href="#topic+ComparePowerOneSampleCTest">ComparePowerOneSampleCTest</a></code> for the comparison of resampling methods based on power for the one-sample C-test
for the mean.
</p>
<p>Other comparison of resampling methods: 
<code><a href="#topic+ComparePowerOneSampleCTest">ComparePowerOneSampleCTest</a>()</code>,
<code><a href="#topic+ComparisonOneSampleCTest">ComparisonOneSampleCTest</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Not run: 

# seed PRNG

set.seed(1234)

# calculate the SE of the mean for the synthetic data generated using GeneratorNU function

ComparisonSEMean(generator = "GeneratorNU",sampleSize = 10,
 numberOfSamples = 100, repetitions = 10,mu = 0, sigma = 1,a = 0.5, b = 1)
## End(Not run)


</code></pre>

<hr>
<h2 id='DMethod'>d method for resampling triangular and trapezoidal fuzzy numbers</h2><span id='topic+DMethod'></span>

<h3>Description</h3>

<p><code>DMethod</code> returns the secondary (bootstrapped) sample and uses the resampling
scheme which does not change the left end of the cores and increments (i.e. length of the core,
left and right increment of the support) of the fuzzy variables from
the initial sample (the d method, see (Romaniuk and Hryniewicz, 2019)).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>DMethod(initialSample, b = n, increases = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="DMethod_+3A_initialsample">initialSample</code></td>
<td>
<p>Initial sample of triangular or trapezoidal fuzzy numbers.</p>
</td></tr>
<tr><td><code id="DMethod_+3A_b">b</code></td>
<td>
<p>The number of fuzzy values in the resampled (secondary) sample.
If this parameter is not specified, the number of values in the initial sample is used.
The parameter should be integer value more than 0.</p>
</td></tr>
<tr><td><code id="DMethod_+3A_increases">increases</code></td>
<td>
<p>If <code>TRUE</code> is used, then the initial sample should consist of the fuzzy numbers in the form:
left increment of the support, left end of the core, right end of the core,
right increment of the support. Otherwise, the default value <code>FALSE</code> is used and the fuzzy numbers should be given in the form:
left end of the support, left end of the core, right end of the core,
right end of the support.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The initial sample should consist of triangular or trapezoidal fuzzy numbers, given as a single vector or a whole matrix.
In each row, there should be a single fuzzy number in one of the forms:
</p>

<ol>
<li><p> left end of the support, left end of the core, right end of the core, right end of the support, or
</p>
</li>
<li><p> left increment of the support, left end of the core, right end of the core, right increment of the support.
</p>
</li></ol>

<p>In this second case, the parameter <code>increases=TRUE</code> has to be used.
</p>
<p>The resampling procedure produces <code>b</code> fuzzy values.
During the first step, the four values are randomly chosen based on the whole initial sample:
left end of the core, length of the core, left and right increment of the support (with equal probabilities
for each fuzzy variable).
Then the new fuzzy variable, which preserves these characteristics, is created.
If the parameter <code>b</code> is not specified, it is equal to the length of the initial sample.
The output is given in the same form as the initial sample.
</p>


<h3>Value</h3>

<p>This function returns matrix with <code>b</code> rows of double values.
In each row, there is a single resampled fuzzy number.
These fuzzy numbers have the same form as the values from the initial sample depending on the provided parameter <code>increases</code>.
</p>


<h3>References</h3>

<p>Romaniuk, M., Hryniewicz, O. (2019)
Interval-based, nonparametric approach for resampling of fuzzy numbers
Soft Computing, 23 (14), pp. 5883-5903
</p>


<h3>See Also</h3>

<p><code><a href="#topic+ClassicalBootstrap">ClassicalBootstrap</a></code>,
<code><a href="#topic+EWMethod">EWMethod</a></code> for the EW method, <code><a href="#topic+VAFMethod">VAFMethod</a></code> for the VAF method,
<code><a href="#topic+VAAMethod">VAAMethod</a></code> for the VAA method, <code><a href="#topic+WMethod">WMethod</a></code> for the w method
</p>
<p>Other resampling functions: 
<code><a href="#topic+ClassicalBootstrap">ClassicalBootstrap</a>()</code>,
<code><a href="#topic+EWMethod">EWMethod</a>()</code>,
<code><a href="#topic+VAAMethod">VAAMethod</a>()</code>,
<code><a href="#topic+VAFMethod">VAFMethod</a>()</code>,
<code><a href="#topic+VAMethod">VAMethod</a>()</code>,
<code><a href="#topic+WMethod">WMethod</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# prepare some fuzzy numbers (first type of the initial sample)

fuzzyValues &lt;- matrix(c(0.25,0.5,1,1.25,0.75,1,1.5,2.2,-1,0,0,2),
ncol = 4,byrow = TRUE)

# generate the secondary sample using the d method

set.seed(12345)

DMethod(fuzzyValues)

DMethod(fuzzyValues,b=4)

# prepare some fuzzy numbers (second type of the initial sample)

fuzzyValuesInc &lt;- matrix(c(0.25,0.5,1,0.25,0.25,1,1.5,0.7,1,0,0,2),
ncol = 4,byrow = TRUE)

# generate the secondary sample using the d method

DMethod(fuzzyValuesInc,increases = TRUE)

DMethod(fuzzyValuesInc,b=4,increases = TRUE)

</code></pre>

<hr>
<h2 id='EWMethod'>E(xpected value)W(idth) resampling method for triangular and trapezoidal fuzzy numbers</h2><span id='topic+EWMethod'></span>

<h3>Description</h3>

<p><code>EWMethod</code> returns the secondary (bootstrapped) sample and uses the resampling
scheme which does not change the expected values and widths of the fuzzy variables from
the initial sample (the EW method, see (Grzegorzewski et al, 2020)).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>EWMethod(initialSample, b = n, increases = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="EWMethod_+3A_initialsample">initialSample</code></td>
<td>
<p>Initial sample of triangular or trapezoidal fuzzy numbers.</p>
</td></tr>
<tr><td><code id="EWMethod_+3A_b">b</code></td>
<td>
<p>The number of fuzzy values in the resampled (secondary) sample.
If this parameter is not specified, the number of values in the initial sample is used.
The parameter should be integer value more than 0.</p>
</td></tr>
<tr><td><code id="EWMethod_+3A_increases">increases</code></td>
<td>
<p>If <code>TRUE</code> is used, then the initial sample should consist of the fuzzy numbers in the form:
left increment of the support, left end of the core, right end of the core,
right increment of the support. Otherwise, the default value <code>FALSE</code> is used and the fuzzy numbers should be given in the form:
left end of the support, left end of the core, right end of the core,
right end of the support.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The initial sample should consist of triangular or trapezoidal fuzzy numbers, given as a single vector or a whole matrix.
In each row, there should be a single fuzzy number in one of the forms:
</p>

<ol>
<li><p> left end of the support, left end of the core, right end of the core, right end of the support, or
</p>
</li>
<li><p> left increment of the support, left end of the core, right end of the core, right increment of the support.
</p>
</li></ol>

<p>In this second case, the parameter <code>increases=TRUE</code> has to be used.
</p>
<p>The resampling procedure produces <code>b</code> fuzzy values.
During the first step, the fuzzy value from the initial sample is randomly chosen (with repetition).
Then the new fuzzy variable, which preserves the expected value and width of the old one, is randomly created.
If the parameter <code>b</code> is not specified, it is equal to the length of the initial sample.
The output is given in the same form as the initial sample.
</p>


<h3>Value</h3>

<p>This function returns matrix with <code>b</code> rows of double values.
In each row, there is a single resampled fuzzy number.
These fuzzy numbers have the same form as the values from the initial sample depending on the provided parameter <code>increases</code>.
</p>


<h3>References</h3>

<p>Grzegorzewski, P., Hryniewicz, O., Romaniuk, M. (2020)
Flexible resampling for fuzzy data
International Journal of Applied Mathematics and Computer Science, 30 (2), pp. 281-297
</p>


<h3>See Also</h3>

<p><code><a href="#topic+ClassicalBootstrap">ClassicalBootstrap</a></code>, <code><a href="#topic+VAMethod">VAMethod</a></code> for the VA method,
<code><a href="#topic+VAFMethod">VAFMethod</a></code> for the VAF method, <code><a href="#topic+VAAMethod">VAAMethod</a></code> for the VAA method,
<code><a href="#topic+DMethod">DMethod</a></code> for the d method, <code><a href="#topic+WMethod">WMethod</a></code> for the w method
</p>
<p>Other resampling functions: 
<code><a href="#topic+ClassicalBootstrap">ClassicalBootstrap</a>()</code>,
<code><a href="#topic+DMethod">DMethod</a>()</code>,
<code><a href="#topic+VAAMethod">VAAMethod</a>()</code>,
<code><a href="#topic+VAFMethod">VAFMethod</a>()</code>,
<code><a href="#topic+VAMethod">VAMethod</a>()</code>,
<code><a href="#topic+WMethod">WMethod</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# prepare some fuzzy numbers (first type of the initial sample)

fuzzyValues &lt;- matrix(c(0.25,0.5,1,1.25,0.75,1,1.5,2.2,-1,0,0,2),
ncol = 4,byrow = TRUE)

# generate the secondary sample using the EW method

set.seed(12345)

EWMethod(fuzzyValues)

EWMethod(fuzzyValues,b=4)

# prepare some fuzzy numbers (second type of the initial sample)

fuzzyValuesInc &lt;- matrix(c(0.25,0.5,1,0.25,0.25,1,1.5,0.7,1,0,0,2),
ncol = 4,byrow = TRUE)

# generate the secondary sample using the EW method

EWMethod(fuzzyValuesInc,increases = TRUE)

EWMethod(fuzzyValuesInc,b=4,increases = TRUE)

</code></pre>

<hr>
<h2 id='GeneratorFuzzyNumbers'>Generate initial sample using various random distributions.</h2><span id='topic+GeneratorFuzzyNumbers'></span>

<h3>Description</h3>

<p><code>GeneratorFuzzyNumbers</code> generates the random sample of trapezoidal fuzzy numbers using the
various random distributions, using the functions from the <code>stats</code> package.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>GeneratorFuzzyNumbers(
  n,
  originalRandomDist,
  parametersOriginalRD,
  increasesRandomDist,
  parametersIncreasesRD,
  supportLeftRandomDist,
  parametersSupportLeftRD,
  supportRightRandomDist,
  parametersSupportRightRD,
  increases = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="GeneratorFuzzyNumbers_+3A_n">n</code></td>
<td>
<p>Number of fuzzy trapezoidal numbers in the created sample.</p>
</td></tr>
<tr><td><code id="GeneratorFuzzyNumbers_+3A_originalrandomdist">originalRandomDist</code></td>
<td>
<p>Name of the random generator used to create the &quot;true origin&quot; of fuzzy trapezoidal number (as
defined in <code>stats</code> package).</p>
</td></tr>
<tr><td><code id="GeneratorFuzzyNumbers_+3A_parametersoriginalrd">parametersOriginalRD</code></td>
<td>
<p>List of parameters required by the random generator used
to create the &quot;true origin&quot; of fuzzy trapezoidal number.</p>
</td></tr>
<tr><td><code id="GeneratorFuzzyNumbers_+3A_increasesrandomdist">increasesRandomDist</code></td>
<td>
<p>Name of the random generator used to create the increases of the core of fuzzy
trapezoidal number (as defined in <code>stats</code> package).</p>
</td></tr>
<tr><td><code id="GeneratorFuzzyNumbers_+3A_parametersincreasesrd">parametersIncreasesRD</code></td>
<td>
<p>List of parameters required by the random generator used
to create the increases of the core of fuzzy trapezoidal number.</p>
</td></tr>
<tr><td><code id="GeneratorFuzzyNumbers_+3A_supportleftrandomdist">supportLeftRandomDist</code></td>
<td>
<p>Name of the random generator used to create the increases of the left support of fuzzy
trapezoidal number (as defined in <code>stats</code> package).</p>
</td></tr>
<tr><td><code id="GeneratorFuzzyNumbers_+3A_parameterssupportleftrd">parametersSupportLeftRD</code></td>
<td>
<p>List of parameters required by the random generator used
to create the increases of the left support of fuzzy trapezoidal number.</p>
</td></tr>
<tr><td><code id="GeneratorFuzzyNumbers_+3A_supportrightrandomdist">supportRightRandomDist</code></td>
<td>
<p>Name of the random generator used to create the increases of the right support of fuzzy
trapezoidal number (as defined in <code>stats</code> package).</p>
</td></tr>
<tr><td><code id="GeneratorFuzzyNumbers_+3A_parameterssupportrightrd">parametersSupportRightRD</code></td>
<td>
<p>List of parameters required by the random generator used
to create the increases of the right support of fuzzy trapezoidal number.</p>
</td></tr>
<tr><td><code id="GeneratorFuzzyNumbers_+3A_increases">increases</code></td>
<td>
<p>If <code>TRUE</code> is used, then the output fuzzy numbers are given in the form:
left increment of the support, left end of the core, right end of the core,
right increment of the support. Otherwise, the default value <code>FALSE</code> is used and the fuzzy numbers are given in the form:
left end of the support, left end of the core, right end of the core,
right end of the support.</p>
</td></tr>
<tr><td><code id="GeneratorFuzzyNumbers_+3A_...">...</code></td>
<td>
<p>Some additional parameters to pass to other functions.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The procedure simulates the initial sample which consists of <code>n</code> trapezoidal fuzzy numbers.
The &quot;true origin&quot; of each fuzzy number is independently drawn from the random distribution using
<code>originalRandomDist</code> function from the <code>stats</code> package with the parameters defined by
<code>parametersOriginalRD</code>.
The same applies to the increases of the core (the function <code>increasesRandomDist</code> with the parameters
<code>parametersIncreasesRD</code> is then used), the left increase of the support (the function <code>supportLeftRandomDist</code>
with the parameters <code>parametersSupportLeftRD</code>, respectively), and the right increase of the support
(the function <code>supportRightRandomDist</code>
with the parameters <code>parametersSupportRightRD</code>, respectively).
</p>
<p>Names of these generators for random probabilities and their respective parameters should be in the form
required by <code>stats</code> package.
</p>
<p>The output is given as a matrix.
In each row, there is a single fuzzy number in one of the forms:
</p>

<ol>
<li><p> left end of the support, left end of the core, right end of the core, right end of the support, or
</p>
</li>
<li><p> left increment of the support, left end of the core, right end of the core, right increment of the support.
</p>
</li></ol>

<p>To obtain this second form, the parameter <code>increases=TRUE</code> has to be used.
</p>


<h3>Value</h3>

<p>This function returns matrix which consists of <code>n</code> trapezoidal fuzzy numbers.
Each fuzzy number (four values) ia given as one row in this matrix.
</p>


<h3>References</h3>

<p>Grzegorzewski, P., Hryniewicz, O., Romaniuk, M. (2020)
Flexible resampling for fuzzy data based on the canonical representation
International Journal of Computational Intelligence Systems, 13 (1), pp. 1650-1662
</p>
<p>Grzegorzewski, P., Romaniuk, M. (2022)
Bootstrapped Kolmogorov-Smirnov Test for Epistemic Fuzzy Data
Information Processing and Management of Uncertainty in Knowledge-Based Systems
Springer
</p>


<h3>See Also</h3>

<p><code><a href="#topic+GeneratorNExpUU">GeneratorNExpUU</a></code>
</p>
<p>Other sampling functions: 
<code><a href="#topic+GeneratorNExpUU">GeneratorNExpUU</a>()</code>,
<code><a href="#topic+GeneratorNU">GeneratorNU</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# seed PRNG

set.seed(1234)

# generate 10 trapezoidal fuzzy numbers (the normal distribution for the "true origin",
# the exponential distribution for the increases of the core, and two different uniform
# distribution for the increases of the support)

GeneratorFuzzyNumbers(10,"rnorm",list(mean=0,sd=1),"rexp",list(rate=2),"runif",
                     list(min=0,max=0.6),"runif",list(min=0,max=1))



</code></pre>

<hr>
<h2 id='GeneratorNExpUU'>Generate initial sample using the normal and uniform distributions.</h2><span id='topic+GeneratorNExpUU'></span>

<h3>Description</h3>

<p><code>GeneratorNExpUU</code> generates the random sample of trapezoidal fuzzy numbers using the normal, exponential and uniform distributions (for
the &quot;true&quot; origin of each fuzzy number, and its increases, respectively).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>GeneratorNExpUU(n, mu, sigma, lambda, b, c, increases = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="GeneratorNExpUU_+3A_n">n</code></td>
<td>
<p>Number of fuzzy trapezoidal numbers in the created sample.</p>
</td></tr>
<tr><td><code id="GeneratorNExpUU_+3A_mu">mu</code></td>
<td>
<p>The expected value of the normal distribution which is used to create the &quot;true origin&quot; of fuzzy trapezoidal number.</p>
</td></tr>
<tr><td><code id="GeneratorNExpUU_+3A_sigma">sigma</code></td>
<td>
<p>The standard deviation of the normal distribution which is used to create the &quot;true origin&quot; of fuzzy trapezoidal number.</p>
</td></tr>
<tr><td><code id="GeneratorNExpUU_+3A_lambda">lambda</code></td>
<td>
<p>The parameter of the exponential distributions which are used to create the left and right
increases of the core.</p>
</td></tr>
<tr><td><code id="GeneratorNExpUU_+3A_b">b</code></td>
<td>
<p>The right end of the interval of the independent uniform distribution which is used to create the left
increase of the support.</p>
</td></tr>
<tr><td><code id="GeneratorNExpUU_+3A_c">c</code></td>
<td>
<p>The right end of the interval of the independent uniform distribution which is used to create the right
increase of the support.</p>
</td></tr>
<tr><td><code id="GeneratorNExpUU_+3A_increases">increases</code></td>
<td>
<p>If <code>TRUE</code> is used, then the output fuzzy numbers are given in the form:
left increment of the support, left end of the core, right end of the core,
right increment of the support. Otherwise, the default value <code>FALSE</code> is used and the fuzzy numbers are given in the form:
left end of the support, left end of the core, right end of the core,
right end of the support.</p>
</td></tr>
<tr><td><code id="GeneratorNExpUU_+3A_...">...</code></td>
<td>
<p>Some additional parameters to pass to other functions.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The procedure simulates the initial sample which consists of <code>n</code> trapezoidal fuzzy numbers.
The &quot;true origin&quot; of each fuzzy number is independently drawn from the normal distribution <code>N (mu, sigma)</code>.
Then increases of its core are independently generated from the exponential distributions <code>Exp (lambda)</code>.
The increases of its support are independently drawn from the uniform distributions
<code>U [0,b]</code> (the left-hand increase) and <code>U [0,c]</code> (its right-hand counterpart) (see Grzegorzewski et al. (2020)).
</p>
<p>The output is given as a matrix.
In each row, there is a single fuzzy number in one of the forms:
</p>

<ol>
<li><p> left end of the support, left end of the core, right end of the core, right end of the support, or
</p>
</li>
<li><p> left increment of the support, left end of the core, right end of the core, right increment of the support.
</p>
</li></ol>

<p>To obtain this second form, the parameter <code>increases=TRUE</code> has to be used.
</p>


<h3>Value</h3>

<p>This function returns matrix which consists of <code>n</code> trapezoidal fuzzy numbers.
Each fuzzy number (four values) ia given as one row in this matrix.
</p>


<h3>References</h3>

<p>Grzegorzewski, P., Hryniewicz, O., Romaniuk, M. (2020)
Flexible resampling for fuzzy data based on the canonical representation
International Journal of Computational Intelligence Systems, 13 (1), pp. 1650-1662
</p>


<h3>See Also</h3>

<p><code><a href="#topic+GeneratorNU">GeneratorNU</a></code>, <code><a href="#topic+GeneratorFuzzyNumbers">GeneratorFuzzyNumbers</a></code>
</p>
<p>Other sampling functions: 
<code><a href="#topic+GeneratorFuzzyNumbers">GeneratorFuzzyNumbers</a>()</code>,
<code><a href="#topic+GeneratorNU">GeneratorNU</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# seed PRNG

set.seed(1234)

# generate 10 trapezoidal fuzzy numbers

GeneratorNExpUU(10, 0,1,1,1,2)



</code></pre>

<hr>
<h2 id='GeneratorNU'>Generate initial sample using the normal and uniform distributions.</h2><span id='topic+GeneratorNU'></span>

<h3>Description</h3>

<p><code>GeneratorNU</code> generates the random sample of trapezoidal fuzzy numbers using the normal and uniform distributions (for
the &quot;true&quot; origin of each fuzzy number, and its increases, respectively).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>GeneratorNU(n, mu, sigma, a, b, increases = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="GeneratorNU_+3A_n">n</code></td>
<td>
<p>Number of fuzzy trapezoidal numbers in the created sample.</p>
</td></tr>
<tr><td><code id="GeneratorNU_+3A_mu">mu</code></td>
<td>
<p>The expected value of the normal distribution which is used to create the &quot;true origin&quot; of fuzzy trapezoidal number.</p>
</td></tr>
<tr><td><code id="GeneratorNU_+3A_sigma">sigma</code></td>
<td>
<p>The standard deviation of the normal distribution which is used to create the &quot;true origin&quot; of fuzzy trapezoidal number.</p>
</td></tr>
<tr><td><code id="GeneratorNU_+3A_a">a</code></td>
<td>
<p>The right end of the interval of the independent uniform distributions which are used to create the left and right
increases of the core.</p>
</td></tr>
<tr><td><code id="GeneratorNU_+3A_b">b</code></td>
<td>
<p>The right end of the interval of the independent uniform distributions which are used to create the left and right
increases of the support.</p>
</td></tr>
<tr><td><code id="GeneratorNU_+3A_increases">increases</code></td>
<td>
<p>If <code>TRUE</code> is used, then the output fuzzy numbers are given in the form:
left increment of the support, left end of the core, right end of the core,
right increment of the support. Otherwise, the default value <code>FALSE</code> is used and the fuzzy numbers are given in the form:
left end of the support, left end of the core, right end of the core,
right end of the support.</p>
</td></tr>
<tr><td><code id="GeneratorNU_+3A_...">...</code></td>
<td>
<p>Some additional parameters to pass to other functions.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The procedure simulates the initial sample which consists of <code>n</code> trapezoidal fuzzy numbers.
The &quot;true origin&quot; of each fuzzy number is independently drawn from the normal distribution <code>N (mu, sigma)</code>.
Then increases of its core and support are independently generated from the uniform distributions
<code>U [0,a]</code> and <code>U [0,b]</code> (see Grzegorzewski et al. (2020)).
</p>
<p>The output is given as a matrix.
In each row, there is a single fuzzy number in one of the forms:
</p>

<ol>
<li><p> left end of the support, left end of the core, right end of the core, right end of the support, or
</p>
</li>
<li><p> left increment of the support, left end of the core, right end of the core, right increment of the support.
</p>
</li></ol>

<p>To obtain this second form, the parameter <code>increases=TRUE</code> has to be used.
</p>


<h3>Value</h3>

<p>This function returns matrix which consists of <code>n</code> trapezoidal fuzzy numbers.
Each fuzzy number (four values) ia given as one row in this matrix.
</p>


<h3>References</h3>

<p>Grzegorzewski, P., Hryniewicz, O., Romaniuk, M. (2020)
Flexible resampling for fuzzy data based on the canonical representation
International Journal of Computational Intelligence Systems, 13 (1), pp. 1650-1662
</p>


<h3>See Also</h3>

<p><code><a href="#topic+GeneratorNExpUU">GeneratorNExpUU</a></code>, <code><a href="#topic+GeneratorFuzzyNumbers">GeneratorFuzzyNumbers</a></code>
</p>
<p>Other sampling functions: 
<code><a href="#topic+GeneratorFuzzyNumbers">GeneratorFuzzyNumbers</a>()</code>,
<code><a href="#topic+GeneratorNExpUU">GeneratorNExpUU</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# seed PRNG

set.seed(1234)

# generate 10 trapezoidal fuzzy numbers

GeneratorNU(10, 0,1,1,2)



</code></pre>

<hr>
<h2 id='OneSampleCTest'>Calculate p-value of the one-sample test for the mean</h2><span id='topic+OneSampleCTest'></span>

<h3>Description</h3>

<p><code>OneSampleCTest</code> returns the p-value of the one-sample test for the mean using the resampling method.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>OneSampleCTest(
  initialSample,
  mu_0,
  numberOfSamples = 100,
  theta = 1/3,
  resamplingMethod = "ClassicalBootstrap",
  increases = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="OneSampleCTest_+3A_initialsample">initialSample</code></td>
<td>
<p>The initial sample which consists of triangular or trapezoidal fuzzy numbers.
More than one value can be given in the form of matrix.</p>
</td></tr>
<tr><td><code id="OneSampleCTest_+3A_mu_0">mu_0</code></td>
<td>
<p>Triangular or trapezoidal fuzzy number which is used for the null hypothesis of the C-test.</p>
</td></tr>
<tr><td><code id="OneSampleCTest_+3A_numberofsamples">numberOfSamples</code></td>
<td>
<p>Number of the bootstrapped samples used to estimate the p-value.</p>
</td></tr>
<tr><td><code id="OneSampleCTest_+3A_theta">theta</code></td>
<td>
<p>The weighting parameter for the mid/spread distance applied in the C-test.</p>
</td></tr>
<tr><td><code id="OneSampleCTest_+3A_resamplingmethod">resamplingMethod</code></td>
<td>
<p>Name of the resampling method, which is used to generate the bootstrapped samples.
For the possible names check the values of <code>resamplingMethods</code> vector.</p>
</td></tr>
<tr><td><code id="OneSampleCTest_+3A_increases">increases</code></td>
<td>
<p>If <code>TRUE</code> is used, then the fuzzy numbers should be given in the form:
left increment of the support, left end of the core, right end of the core,
right increment of the support. Otherwise, the default value <code>FALSE</code> is used and the fuzzy numbers should be given in the form:
left end of the support, left end of the core, right end of the core,
right end of the support.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The input fuzzy values should be triangular or trapezoidal fuzzy numbers, given as a single vector or a whole matrix.
In each row, there should be a single fuzzy number in one of the forms:
</p>

<ol>
<li><p> left end of the support, left end of the core, right end of the core, right end of the support, or
</p>
</li>
<li><p> left increment of the support, left end of the core, right end of the core, right increment of the support.
</p>
</li></ol>

<p>In this second case, the parameter <code>increases=TRUE</code> has to be used.
</p>
<p>The procedure uses the resampling method given in the <code>resamplingMethod</code> parameter to estimate the p-value of the one-sample
test for the mean (denoted further as the one-sample C-test, see Lubiano et al. (2016)).
This test checks the null hypothesis that the Aumann-type mean of the fuzzy numbers is equal to a given fuzzy number <code>mu_0</code>.
</p>


<h3>Value</h3>

<p>This function returns double value which is equal to the p-value of the one-sample C-test.
</p>


<h3>References</h3>

<p>Lubiano, M.A., Montenegro M., Sinova, B., de Saa, S.R., Gil, M.A. (2016)
Hypothesis testing for means in connection with fuzzy rating scale-based data: algorithms and applications
European Journal of Operational Research, 251, pp. 918-929
</p>


<h3>See Also</h3>

<p><code><a href="#topic+TwoSampleCTest">TwoSampleCTest</a></code> for the two-sample C-test
</p>
<p>Other bootstrapped version of test: 
<code><a href="#topic+TwoSampleCTest">TwoSampleCTest</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# prepare some fuzzy numbers (first type of the initial sample)

fuzzyValues &lt;- matrix(c(0.25,0.5,1,1.25,0.75,1,1.5,2.2,-1,0,0,2),ncol = 4,byrow = TRUE)

# seed PRNG

set.seed(1234)

# calculate the p-value using the classical (i.e. Efron's) bootstrap

OneSampleCTest(fuzzyValues, mu_0 = c(0,0.5,1,1.5))

# calculate the p-value using the VA resampling method

OneSampleCTest(fuzzyValues, mu_0 = c(0,0.5,1,1.5),resamplingMethod = "VAMethod")


</code></pre>

<hr>
<h2 id='resamplingMethods'>A vector containing names of all resampling methods.</h2><span id='topic+resamplingMethods'></span>

<h3>Description</h3>

<p><code>resamplingMethods</code> is a vector containing names of all resampling methods.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>resamplingMethods
</code></pre>


<h3>Format</h3>

<p>An object of class <code>character</code> of length 7.
</p>


<h3>Value</h3>

<p>This function returns a vector of strings.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# check the names of the available resampling methods

resamplingMethods

</code></pre>

<hr>
<h2 id='samplingGenerators'>A vector containing names of all sampling generators</h2><span id='topic+samplingGenerators'></span>

<h3>Description</h3>

<p><code>samplingGenerators</code> is a vector containing names of all generators which can be used to sample synthetic
fuzzy numbers (trapezoidal or triangular).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>samplingGenerators
</code></pre>


<h3>Format</h3>

<p>An object of class <code>character</code> of length 3.
</p>


<h3>Value</h3>

<p>This function returns a vector of strings.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# check the names of the available sampling generators

samplingGenerators

</code></pre>

<hr>
<h2 id='SEResamplingMean'>Calculate SE/MSE for the mean of the bootstrapped samples.</h2><span id='topic+SEResamplingMean'></span>

<h3>Description</h3>

<p><code>SEResamplingMean</code> estimates the standard error (SE) or the mean-squared error (MSE) for the mean while the sample is bootstrapped using
one of the applied resampling methods.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>SEResamplingMean(
  initialSample,
  resamplingMethod = "ClassicalBootstrap",
  repetitions = 100,
  trueMean = NA,
  theta = 1/3,
  increases = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="SEResamplingMean_+3A_initialsample">initialSample</code></td>
<td>
<p>The initial sample which consists of triangular or trapezoidal fuzzy numbers.
More than one value can be given in the form of matrix.</p>
</td></tr>
<tr><td><code id="SEResamplingMean_+3A_resamplingmethod">resamplingMethod</code></td>
<td>
<p>Name of the resampling method, which is used to generate the bootstrapped samples.
For the possible names check the values of <code>resamplingMethods</code> vector.</p>
</td></tr>
<tr><td><code id="SEResamplingMean_+3A_repetitions">repetitions</code></td>
<td>
<p>Number of the secondary samples which are created using the selected resampling method.</p>
</td></tr>
<tr><td><code id="SEResamplingMean_+3A_truemean">trueMean</code></td>
<td>
<p>If the value is given, then the mean-squared error (MSE) is calculated for this value and the means of the bootstrapped
samples. Otherwise, the standard error (SE) is calculated based on the overall mean of the secondary samples.</p>
</td></tr>
<tr><td><code id="SEResamplingMean_+3A_theta">theta</code></td>
<td>
<p>The weighting parameter for the mid/spread distance applied to calculate the SE/MSE.</p>
</td></tr>
<tr><td><code id="SEResamplingMean_+3A_increases">increases</code></td>
<td>
<p>If <code>TRUE</code> is used, then the fuzzy numbers should be given in the form:
left increment of the support, left end of the core, right end of the core,
right increment of the support. Otherwise, the default value <code>FALSE</code> is used and the fuzzy numbers should be given in the form:
left end of the support, left end of the core, right end of the core,
right end of the support.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The input fuzzy values should be triangular or trapezoidal fuzzy numbers, given as a single vector or a whole matrix.
In each row, there should be a single fuzzy number in one of the forms:
</p>

<ol>
<li><p> left end of the support, left end of the core, right end of the core, right end of the support, or
</p>
</li>
<li><p> left increment of the support, left end of the core, right end of the core, right increment of the support.
</p>
</li></ol>

<p>In this second case, the parameter <code>increases=TRUE</code> has to be used.
</p>
<p>The procedure uses the resampling method given in <code>resamplingMethod</code> parameter to create the secondary (bootstrapped)
samples.
Then the mean (in the form of trapezoidal fuzzy number) is calculated for each new sample.
If the parameter <code>trueMean</code> is set, then the mean-squared error (MSE) between this true value and each of the sample means
is estimated using the Bertoulzza et al.'s (aka mid/spread) distance (with the given weight <code>theta</code>,
see Bertoluzza et al. (1995)).
Otherwise, the overall mean is calculated, and the standard error (SE) is estimated based on the overall mean
and each of the sample means.
In this case the Bertoulzza et al.'s distance (see Grzegorzewski, Romaniuk (2021)) is also applied.
</p>


<h3>Value</h3>

<p>This function returns list of two double values:
</p>

<ol>
<li> <p><code>mean</code> which is equal to the overall mean (if the SE is calculated) or
<code>trueMean</code> parameter (if the MSE is calculated),
</p>
</li>
<li> <p><code>SE</code> which is equal to the estimated SE/MSE of the mean.
</p>
</li></ol>

<p>The output <code>mean</code> consists of four values which create the trapezoidal fuzzy number.
</p>


<h3>References</h3>

<p>Bertoluzza, C., Corral, N., Salas, A. (1995)
On a new class of distances between fuzzy numbers
Mathware and Soft Computing, 2 (2), pp. 71-84
</p>
<p>Grzegorzewski, P., Romaniuk, M. (2022)
Bootstrap methods for fuzzy data
Uncertainty and Imprecision in Decision Making and Decision Support: New Advances, Challenges, and Perspectives, pp. 28-47
Springer
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# prepare some fuzzy numbers (first type of the initial sample)

fuzzyValues &lt;- matrix(c(0.25,0.5,1,1.25,0.75,1,1.5,2.2,-1,0,0,2),ncol = 4,byrow = TRUE)

# seed PRNG

set.seed(1234)

# calculate the SE of the mean using the classical (i.e. Efron's) bootstrap

SEResamplingMean(fuzzyValues)

# calculate the SE of the mean using the VA resampling method

SEResamplingMean(fuzzyValues, resamplingMethod = "VAMethod")

# calculate the MSE of the given mean using the classical (i.e. Efron's) bootstrap

SEResamplingMean(fuzzyValues, trueMean = c(0,0.5,1,2))

# calculate the MSE of the given mean using the VA resampling method

SEResamplingMean(fuzzyValues, resamplingMethod = "VAMethod", trueMean = c(0,0.5,1,2))


</code></pre>

<hr>
<h2 id='TwoSampleCTest'>Calculate p-value of the two-sample test for the mean</h2><span id='topic+TwoSampleCTest'></span>

<h3>Description</h3>

<p><code>TwoSampleCTest</code> returns the p-value of the two-sample test for the mean using the resampling method.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>TwoSampleCTest(
  initialSample1,
  initialSample2,
  numberOfSamples = 100,
  theta = 1/3,
  resamplingMethod = "ClassicalBootstrap",
  increases = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="TwoSampleCTest_+3A_initialsample1">initialSample1</code></td>
<td>
<p>The first initial sample which consists of triangular or trapezoidal fuzzy numbers.
More than one value can be given in the form of matrix.</p>
</td></tr>
<tr><td><code id="TwoSampleCTest_+3A_initialsample2">initialSample2</code></td>
<td>
<p>The second initial sample which consists of triangular or trapezoidal fuzzy numbers.
More than one value can be given in the form of matrix.</p>
</td></tr>
<tr><td><code id="TwoSampleCTest_+3A_numberofsamples">numberOfSamples</code></td>
<td>
<p>Number of the bootstrapped samples used to estimate the p-value.</p>
</td></tr>
<tr><td><code id="TwoSampleCTest_+3A_theta">theta</code></td>
<td>
<p>The weighting parameter for the mid/spread distance applied in the C-test.</p>
</td></tr>
<tr><td><code id="TwoSampleCTest_+3A_resamplingmethod">resamplingMethod</code></td>
<td>
<p>Name of the resampling method, which is used to generate the bootstrapped samples.
For the possible names check the values of <code>resamplingMethods</code> vector.</p>
</td></tr>
<tr><td><code id="TwoSampleCTest_+3A_increases">increases</code></td>
<td>
<p>If <code>TRUE</code> is used, then the fuzzy numbers should be given in the form:
left increment of the support, left end of the core, right end of the core,
right increment of the support. Otherwise, the default value <code>FALSE</code> is used and the fuzzy numbers should be given in the form:
left end of the support, left end of the core, right end of the core,
right end of the support.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The input fuzzy values should be triangular or trapezoidal fuzzy numbers, given as a single vector or a whole matrix.
In each row, there should be a single fuzzy number in one of the forms:
</p>

<ol>
<li><p> left end of the support, left end of the core, right end of the core, right end of the support, or
</p>
</li>
<li><p> left increment of the support, left end of the core, right end of the core, right increment of the support.
</p>
</li></ol>

<p>In this second case, the parameter <code>increases=TRUE</code> has to be used.
</p>
<p>The procedure uses the resampling method given in the <code>resamplingMethod</code> parameter to estimate the p-value of the two-sample
test for the mean (denoted further as the two-sample C-test, see Lubiano et al. (2016)).
This test checks the null hypothesis that the Aumann-type means of two fuzzy samples are equal.
</p>


<h3>Value</h3>

<p>This function returns double value which is equal to the p-value of the two-sample C-test.
</p>


<h3>References</h3>

<p>Lubiano, M.A., Montenegro M., Sinova, B., de Saa, S.R., Gil, M.A. (2016)
Hypothesis testing for means in connection with fuzzy rating scale-based data: algorithms and applications
European Journal of Operational Research, 251, pp. 918-929
</p>


<h3>See Also</h3>

<p><code><a href="#topic+OneSampleCTest">OneSampleCTest</a></code> for the one-sample C-test
</p>
<p>Other bootstrapped version of test: 
<code><a href="#topic+OneSampleCTest">OneSampleCTest</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# prepare some fuzzy numbers (first type of the initial sample)

fuzzyValues &lt;- matrix(c(0.25,0.5,1,1.25,0.75,1,1.5,2.2,-1,0,0,2),ncol = 4,byrow = TRUE)

# prepare the slightly shifted second sample

fuzzyValuesShift &lt;- fuzzyValues + 0.5

# seed PRNG

set.seed(1234)

# calculate the p-value using the classical (i.e. Efron's) bootstrap

TwoSampleCTest(fuzzyValues, fuzzyValuesShift)

# calculate the p-value using the VA resampling method

TwoSampleCTest(fuzzyValues, fuzzyValuesShift, resamplingMethod = "VAMethod")


</code></pre>

<hr>
<h2 id='VAAMethod'>V(alue)A(mbiguity, left-hand)A(mbiguity, right-hand) resampling method for triangular and trapezoidal fuzzy numbers</h2><span id='topic+VAAMethod'></span>

<h3>Description</h3>

<p><code>VAAMethod</code> returns the secondary (bootstrapped) sample and uses the resampling
scheme which does not change the values, left-hand and right-hand ambiguities of the fuzzy variables from
the initial sample (the VAA method, see (Grzegorzewski and Romaniuk, 2022)).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>VAAMethod(initialSample, b = n, increases = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="VAAMethod_+3A_initialsample">initialSample</code></td>
<td>
<p>Initial sample of triangular or trapezoidal fuzzy numbers.</p>
</td></tr>
<tr><td><code id="VAAMethod_+3A_b">b</code></td>
<td>
<p>The number of fuzzy values in the resampled (secondary) sample.
If this parameter is not specified, the number of values in the initial sample is used.
The parameter should be integer value more than 0.</p>
</td></tr>
<tr><td><code id="VAAMethod_+3A_increases">increases</code></td>
<td>
<p>If <code>TRUE</code> is used, then the initial sample should consist of the fuzzy numbers in the form:
left increment of the support, left end of the core, right end of the core,
right increment of the support. Otherwise, the default value <code>FALSE</code> is used and the fuzzy numbers should be given in the form:
left end of the support, left end of the core, right end of the core,
right end of the support.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The initial sample should consist of triangular or trapezoidal fuzzy numbers, given as a single vector or a whole matrix.
In each row, there should be a single fuzzy number in one of the forms:
</p>

<ol>
<li><p> left end of the support, left end of the core, right end of the core, right end of the support, or
</p>
</li>
<li><p> left increment of the support, left end of the core, right end of the core, right increment of the support.
</p>
</li></ol>

<p>In this second case, the parameter <code>increases=TRUE</code> has to be used.
</p>
<p>The resampling procedure produces <code>b</code> fuzzy values.
During the first step, the fuzzy value from the initial sample is randomly chosen (with repetition).
Then the new fuzzy variable, which preserves the value, left- and right-hand ambiguities of the old one, is randomly created.
If the parameter <code>b</code> is not specified, it is equal to the length of the initial sample.
The output is given in the same form as the initial sample.
</p>


<h3>Value</h3>

<p>This function returns matrix with <code>b</code> rows of double values.
In each row, there is a single resampled fuzzy number.
These fuzzy numbers have the same form as the values from the initial sample depending on the provided parameter <code>increases</code>.
</p>


<h3>References</h3>

<p>Grzegorzewski, P., Romaniuk, M. (2022)
Bootstrap methods for fuzzy data
Uncertainty and Imprecision in Decision Making and Decision Support: New Advances, Challenges, and Perspectives, pp. 28-47
Springer
</p>


<h3>See Also</h3>

<p><code><a href="#topic+ClassicalBootstrap">ClassicalBootstrap</a></code>,
<code><a href="#topic+EWMethod">EWMethod</a></code> for the EW method, <code><a href="#topic+VAFMethod">VAFMethod</a></code> for the VAF method,
<code><a href="#topic+DMethod">DMethod</a></code> for the d method, <code><a href="#topic+WMethod">WMethod</a></code> for the w method
</p>
<p>Other resampling functions: 
<code><a href="#topic+ClassicalBootstrap">ClassicalBootstrap</a>()</code>,
<code><a href="#topic+DMethod">DMethod</a>()</code>,
<code><a href="#topic+EWMethod">EWMethod</a>()</code>,
<code><a href="#topic+VAFMethod">VAFMethod</a>()</code>,
<code><a href="#topic+VAMethod">VAMethod</a>()</code>,
<code><a href="#topic+WMethod">WMethod</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# prepare some fuzzy numbers (first type of the initial sample)

fuzzyValues &lt;- matrix(c(0.25,0.5,1,1.25,0.75,1,1.5,2.2,-1,0,0,2),
ncol = 4,byrow = TRUE)

# generate the secondary sample using the VAA method

set.seed(12345)

VAAMethod(fuzzyValues)

VAAMethod(fuzzyValues,b=4)

# prepare some fuzzy numbers (second type of the initial sample)

fuzzyValuesInc &lt;- matrix(c(0.25,0.5,1,0.25,0.25,1,1.5,0.7,1,0,0,2),
ncol = 4,byrow = TRUE)

# generate the secondary sample using the VAA method

VAAMethod(fuzzyValuesInc,increases = TRUE)

VAAMethod(fuzzyValuesInc,b=4,increases = TRUE)

</code></pre>

<hr>
<h2 id='VAFMethod'>V(alue)A(mbiguity)F(uzziness) resampling method for triangular and trapezoidal fuzzy numbers</h2><span id='topic+VAFMethod'></span>

<h3>Description</h3>

<p><code>VAFMethod</code> returns the secondary (bootstrapped) sample and uses the resampling
scheme which does not change the values, ambiguities and fuzziness of the fuzzy variables from
the initial sample (the VAF method, see (Grzegorzewski et al., 2020)).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>VAFMethod(initialSample, b = n, increases = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="VAFMethod_+3A_initialsample">initialSample</code></td>
<td>
<p>Initial sample of triangular or trapezoidal fuzzy numbers.</p>
</td></tr>
<tr><td><code id="VAFMethod_+3A_b">b</code></td>
<td>
<p>The number of fuzzy values in the resampled (secondary) sample.
If this parameter is not specified, the number of values in the initial sample is used.
The parameter should be integer value more than 0.</p>
</td></tr>
<tr><td><code id="VAFMethod_+3A_increases">increases</code></td>
<td>
<p>If <code>TRUE</code> is used, then the initial sample should consist of the fuzzy numbers in the form:
left increment of the support, left end of the core, right end of the core,
right increment of the support. Otherwise, the default value <code>FALSE</code> is used and the fuzzy numbers should be given in the form:
left end of the support, left end of the core, right end of the core,
right end of the support.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The initial sample should consist of triangular or trapezoidal fuzzy numbers, given as a single vector or a whole matrix.
In each row, there should be a single fuzzy number in one of the forms:
</p>

<ol>
<li><p> left end of the support, left end of the core, right end of the core, right end of the support, or
</p>
</li>
<li><p> left increment of the support, left end of the core, right end of the core, right increment of the support.
</p>
</li></ol>

<p>In this second case, the parameter <code>increases=TRUE</code> has to be used.
</p>
<p>The resampling procedure produces <code>b</code> fuzzy values.
During the first step, the fuzzy value from the initial sample is randomly chosen (with repetition).
Then the new fuzzy variable, which preserves the value,  ambiguity and fuzziness of the old one, is randomly created.
If the parameter <code>b</code> is not specified, it is equal to the length of the initial sample.
The output is given in the same form as the initial sample.
</p>


<h3>Value</h3>

<p>This function returns matrix with <code>b</code> rows of double values.
In each row, there is a single resampled fuzzy number.
These fuzzy numbers have the same form as the values from the initial sample depending on the provided parameter <code>increases</code>.
</p>


<h3>References</h3>

<p>Grzegorzewski, P., Hryniewicz, O., Romaniuk, M. (2020)
Flexible resampling for fuzzy data based on the canonical representation
International Journal of Computational Intelligence Systems, 13 (1), pp. 1650-1662
</p>


<h3>See Also</h3>

<p><code><a href="#topic+ClassicalBootstrap">ClassicalBootstrap</a></code>,
<code><a href="#topic+EWMethod">EWMethod</a></code> for the EW method, <code><a href="#topic+VAFMethod">VAFMethod</a></code> for the VAF method,
<code><a href="#topic+VAAMethod">VAAMethod</a></code> for the VAA method, <code><a href="#topic+DMethod">DMethod</a></code> for the d method, <code><a href="#topic+WMethod">WMethod</a></code> for the w method
</p>
<p>Other resampling functions: 
<code><a href="#topic+ClassicalBootstrap">ClassicalBootstrap</a>()</code>,
<code><a href="#topic+DMethod">DMethod</a>()</code>,
<code><a href="#topic+EWMethod">EWMethod</a>()</code>,
<code><a href="#topic+VAAMethod">VAAMethod</a>()</code>,
<code><a href="#topic+VAMethod">VAMethod</a>()</code>,
<code><a href="#topic+WMethod">WMethod</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# prepare some fuzzy numbers (first type of the initial sample)

fuzzyValues &lt;- matrix(c(0.25,0.5,1,1.25,0.75,1,1.5,2.2,-1,0,0,2),
ncol = 4,byrow = TRUE)

# generate the secondary sample using the VAF method

set.seed(12345)

VAFMethod(fuzzyValues)

VAFMethod(fuzzyValues,b=4)

# prepare some fuzzy numbers (second type of the initial sample)

fuzzyValuesInc &lt;- matrix(c(0.25,0.5,1,0.25,0.25,1,1.5,0.7,1,0,0,2),
ncol = 4,byrow = TRUE)

# generate the secondary sample using the VAF method

VAFMethod(fuzzyValuesInc,increases = TRUE)

VAFMethod(fuzzyValuesInc,b=4,increases = TRUE)

</code></pre>

<hr>
<h2 id='VAMethod'>V(alue)A(mbiguity) resampling method for triangular and trapezoidal fuzzy numbers</h2><span id='topic+VAMethod'></span>

<h3>Description</h3>

<p><code>VAMethod</code> returns the secondary (bootstrapped) sample and uses the resampling
scheme which does not change the values and ambiguities of the fuzzy variables from
the initial sample (the VA method, see (Grzegorzewski et al, 2020)).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>VAMethod(initialSample, b = n, increases = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="VAMethod_+3A_initialsample">initialSample</code></td>
<td>
<p>Initial sample of triangular or trapezoidal fuzzy numbers.</p>
</td></tr>
<tr><td><code id="VAMethod_+3A_b">b</code></td>
<td>
<p>The number of fuzzy values in the resampled (secondary) sample.
If this parameter is not specified, the number of values in the initial sample is used.
The parameter should be integer value more than 0.</p>
</td></tr>
<tr><td><code id="VAMethod_+3A_increases">increases</code></td>
<td>
<p>If <code>TRUE</code> is used, then the initial sample should consist of the fuzzy numbers in the form:
left increment of the support, left end of the core, right end of the core,
right increment of the support. Otherwise, the default value <code>FALSE</code> is used and the fuzzy numbers should be given in the form:
left end of the support, left end of the core, right end of the core,
right end of the support.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The initial sample should consist of triangular or trapezoidal fuzzy numbers, given as a single vector or a whole matrix.
In each row, there should be a single fuzzy number in one of the forms:
</p>

<ol>
<li><p> left end of the support, left end of the core, right end of the core, right end of the support, or
</p>
</li>
<li><p> left increment of the support, left end of the core, right end of the core, right increment of the support.
</p>
</li></ol>

<p>In this second case, the parameter <code>increases=TRUE</code> has to be used.
</p>
<p>The resampling procedure produces <code>b</code> fuzzy values.
During the first step, the fuzzy value from the initial sample is randomly chosen (with repetition).
Then the new fuzzy variable, which preserves the value and ambiguity of the old one, is randomly created.
If the parameter <code>b</code> is not specified, it is equal to the length of the initial sample.
The output is given in the same form as the initial sample.
</p>


<h3>Value</h3>

<p>This function returns matrix with <code>b</code> rows of double values.
In each row, there is a single resampled fuzzy number.
These fuzzy numbers have the same form as the values from the initial sample depending on the provided parameter <code>increases</code>.
</p>


<h3>References</h3>

<p>Grzegorzewski, P., Hryniewicz, O., Romaniuk, M. (2020)
Flexible resampling for fuzzy data based on the canonical representation
International Journal of Computational Intelligence Systems, 13 (1), pp. 1650-1662
</p>


<h3>See Also</h3>

<p><code><a href="#topic+ClassicalBootstrap">ClassicalBootstrap</a></code>,
<code><a href="#topic+EWMethod">EWMethod</a></code> for the EW method, <code><a href="#topic+VAFMethod">VAFMethod</a></code> for the VAF method,
<code><a href="#topic+VAAMethod">VAAMethod</a></code> for the VAA method, <code><a href="#topic+DMethod">DMethod</a></code> for the d method, <code><a href="#topic+WMethod">WMethod</a></code> for the w method
</p>
<p>Other resampling functions: 
<code><a href="#topic+ClassicalBootstrap">ClassicalBootstrap</a>()</code>,
<code><a href="#topic+DMethod">DMethod</a>()</code>,
<code><a href="#topic+EWMethod">EWMethod</a>()</code>,
<code><a href="#topic+VAAMethod">VAAMethod</a>()</code>,
<code><a href="#topic+VAFMethod">VAFMethod</a>()</code>,
<code><a href="#topic+WMethod">WMethod</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# prepare some fuzzy numbers (first type of the initial sample)

fuzzyValues &lt;- matrix(c(0.25,0.5,1,1.25,0.75,1,1.5,2.2,-1,0,0,2),
ncol = 4,byrow = TRUE)

# generate the secondary sample using the VA method

set.seed(12345)

VAMethod(fuzzyValues)

VAMethod(fuzzyValues,b=4)

# prepare some fuzzy numbers (second type of the initial sample)

fuzzyValuesInc &lt;- matrix(c(0.25,0.5,1,0.25,0.25,1,1.5,0.7,1,0,0,2),
ncol = 4,byrow = TRUE)

# generate the secondary sample using the VA method

VAMethod(fuzzyValuesInc,increases = TRUE)

VAMethod(fuzzyValuesInc,b=4,increases = TRUE)

</code></pre>

<hr>
<h2 id='WMethod'>w method for resampling triangular and trapezoidal fuzzy numbers</h2><span id='topic+WMethod'></span>

<h3>Description</h3>

<p><code>WMethod</code> returns the secondary (bootstrapped) sample and uses the resampling
scheme based on the special <em>w density</em> which is related to the left ends of the cores and increments
(i.e. length of the core,
left and right increment of the support) of the fuzzy variables from
the initial sample (the d method, see (Romaniuk and Hryniewicz, 2019)).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>WMethod(initialSample, b = n, increases = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="WMethod_+3A_initialsample">initialSample</code></td>
<td>
<p>Initial sample of triangular or trapezoidal fuzzy numbers.</p>
</td></tr>
<tr><td><code id="WMethod_+3A_b">b</code></td>
<td>
<p>The number of fuzzy values in the resampled (secondary) sample.
If this parameter is not specified, the number of values in the initial sample is used.
The parameter should be integer value more than 0.</p>
</td></tr>
<tr><td><code id="WMethod_+3A_increases">increases</code></td>
<td>
<p>If <code>TRUE</code> is used, then the initial sample should consist of the fuzzy numbers in the form:
left increment of the support, left end of the core, right end of the core,
right increment of the support. Otherwise, the default value <code>FALSE</code> is used and the fuzzy numbers should be given in the form:
left end of the support, left end of the core, right end of the core,
right end of the support.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The initial sample should consist of triangular or trapezoidal fuzzy numbers, given as a single vector or a whole matrix.
In each row, there should be a single fuzzy number in one of the forms:
</p>

<ol>
<li><p> left end of the support, left end of the core, right end of the core, right end of the support, or
</p>
</li>
<li><p> left increment of the support, left end of the core, right end of the core, right increment of the support.
</p>
</li></ol>

<p>In this second case, the parameter <code>increases=TRUE</code> has to be used.
</p>
<p>The resampling procedure produces <code>b</code> fuzzy values.
During the first step, the four values are randomly generated using the special <em>w density</em>:
left end of the core, length of the core, left and right increment of the support.
This <em>w density</em> is calculated based on the whole fuzzy sample.
Then the new fuzzy variable, which preserves the above-mentioned characteristics, is created.
If the parameter <code>b</code> is not specified, it is equal to the length of the initial sample.
The output is given in the same form as the initial sample.
</p>


<h3>Value</h3>

<p>This function returns matrix with <code>b</code> rows of double values.
In each row, there is a single resampled fuzzy number.
These fuzzy numbers have the same form as the values from the initial sample depending on the provided parameter <code>increases</code>.
</p>


<h3>References</h3>

<p>Romaniuk, M., Hryniewicz, O. (2019)
Interval-based, nonparametric approach for resampling of fuzzy numbers
Soft Computing, 23 (14), pp. 5883-5903
</p>


<h3>See Also</h3>

<p><code><a href="#topic+ClassicalBootstrap">ClassicalBootstrap</a></code>,
<code><a href="#topic+EWMethod">EWMethod</a></code> for the EW method, <code><a href="#topic+VAFMethod">VAFMethod</a></code> for the VAF method,
<code><a href="#topic+VAAMethod">VAAMethod</a></code> for the VAA method
</p>
<p>Other resampling functions: 
<code><a href="#topic+ClassicalBootstrap">ClassicalBootstrap</a>()</code>,
<code><a href="#topic+DMethod">DMethod</a>()</code>,
<code><a href="#topic+EWMethod">EWMethod</a>()</code>,
<code><a href="#topic+VAAMethod">VAAMethod</a>()</code>,
<code><a href="#topic+VAFMethod">VAFMethod</a>()</code>,
<code><a href="#topic+VAMethod">VAMethod</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# prepare some fuzzy numbers (first type of the initial sample)

fuzzyValues &lt;- matrix(c(0.25,0.5,1,1.25,0.75,1,1.5,2.2,-1,0,0,2),
ncol = 4,byrow = TRUE)

# generate the secondary sample using the w method

set.seed(12345)

WMethod(fuzzyValues)

WMethod(fuzzyValues,b=4)

# prepare some fuzzy numbers (second type of the initial sample)

fuzzyValuesInc &lt;- matrix(c(0.25,0.5,1,0.25,0.25,1,1.5,0.7,1,0,0,2),
ncol = 4,byrow = TRUE)

# generate the secondary sample using the w method

WMethod(fuzzyValuesInc,increases = TRUE)

WMethod(fuzzyValuesInc,b=4,increases = TRUE)

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
