<!DOCTYPE html><html lang="en"><head><title>Help for package garma</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {garma}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#garma'><p>garma: A package for estimating and foreasting Gegenbauer time series models.</p></a></li>
<li><a href='#AIC.garma_model'><p>AIC for model</p></a></li>
<li><a href='#autoplot.garma_model'><p>ggplot of the Forecasts of the model.</p></a></li>
<li><a href='#coef.garma_model'><p>Model Coefficients</p></a></li>
<li><a href='#extract_arma'><p>Extract underlying ARMA process.</p></a></li>
<li><a href='#fitted.garma_model'><p>Extract fitted values</p></a></li>
<li><a href='#forecast.garma_model'><p>Forecast future values.</p></a></li>
<li><a href='#garma_ggtsdisplay'><p>ggtsdisplay of underlying ARMA process.</p></a></li>
<li><a href='#gg_raw_pgram'><p>Display raw periodogram</p></a></li>
<li><a href='#ggbr_semipara'><p>Extract semiparametric estimates of the Gegenbauer factors.</p></a></li>
<li><a href='#gof'><p>Goodness-of-Fit test for a garma_model.</p></a></li>
<li><a href='#logLik.garma_model'><p>Log Likelihood</p></a></li>
<li><a href='#plot.garma_model'><p>Plot Forecasts from model.</p></a></li>
<li><a href='#predict.garma_model'><p>Predict future values.</p></a></li>
<li><a href='#print.garma_model'><p>print a garma_model object.</p></a></li>
<li><a href='#print.ggbr_factors'><p>Print a 'ggbr_factors' object.</p></a></li>
<li><a href='#residuals.garma_model'><p>Residuals</p></a></li>
<li><a href='#summary.garma_model'><p>summarise a garma_model object.</p></a></li>
<li><a href='#tsdiag.garma_model'><p>Diagnostic fit of a garma_model.</p></a></li>
<li><a href='#vcov.garma_model'><p>Covariance matrix</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Fitting and Forecasting Gegenbauer ARMA Time Series Models</td>
</tr>
<tr>
<td>Version:</td>
<td>0.9.24</td>
</tr>
<tr>
<td>Date:</td>
<td>2025-03-16</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Richard Hunt &lt;maint@huntemail.id.au&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Methods for estimating univariate long memory-seasonal/cyclical
             Gegenbauer time series processes. See for example (2022) &lt;<a href="https://doi.org/10.1007%2Fs00362-022-01290-3">doi:10.1007/s00362-022-01290-3</a>&gt;.
             Refer to the vignette for details of fitting these processes.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/rlph50/garma">https://github.com/rlph50/garma</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>Depends:</td>
<td>forecast, ggplot2</td>
</tr>
<tr>
<td>Imports:</td>
<td>Rsolnp, nloptr, pracma, signal, zoo, lubridate, rlang, crayon,
utils</td>
</tr>
<tr>
<td>Suggests:</td>
<td>longmemo, yardstick, testthat (&ge; 3.0.0), knitr, rmarkdown</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.3.2</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>Config/testthat/edition:</td>
<td>3</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2025-03-16 04:40:12 UTC; rlph5</td>
</tr>
<tr>
<td>Author:</td>
<td>Richard Hunt [aut, cre]</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2025-03-16 05:00:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='garma'>garma: A package for estimating and foreasting Gegenbauer time series models.</h2><span id='topic+garma'></span><span id='topic+garma-package'></span>

<h3>Description</h3>

<p>The GARMA package provides the main function &quot;garma&quot; as well as print, summary,
predict, forecast and plot/ggplot options.
</p>
<p>The garma function is the main function for the garma package. Depending on the parameters it will
calculate the parameter estimates for the GARMA process, and if available the standard errors (se's)
for those parameters.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>garma(
  x,
  order = c(0L, 0L, 0L),
  periods = NULL,
  k = 1,
  include.mean = (order[2] == 0L),
  include.drift = FALSE,
  xreg = NULL,
  method = "Whittle",
  d_lim = c(0, 0.5),
  opt_method = c("cobyla", "solnp"),
  control = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="garma_+3A_x">x</code></td>
<td>
<p>(num) This should be a numeric vector representing the process to estimate. A minimum length of 96 is required.</p>
</td></tr>
<tr><td><code id="garma_+3A_order">order</code></td>
<td>
<p>(numeric vector) This should be a vector (similar to the stats::arima order parameter) which will give the order
of the process to fit. The format should be list(p,d,q) where p, d, and q are all positive integers. p represents the degree
of the autoregressive process to fit, q represents the order of the moving average process to fit and d is the (integer)
differencing to apply prior to any fitting. WARNING: Currently only d==0 or d==1 are allowed.</p>
</td></tr>
<tr><td><code id="garma_+3A_periods">periods</code></td>
<td>
<p>(num) This parameter can be used to specify a fixed period or set of periods for the
Gegenbauer periodicity. For instance if you have monthly data, then it might be sensible (after an examination of the
periodogram) to set periods = 12. The default value is NULL. Either 'periods' or 'k' parameters must be specified
but not both - 'periods' implies fixed period(s) are to be used and 'k' implies that the periods should
be estimated.</p>
</td></tr>
<tr><td><code id="garma_+3A_k">k</code></td>
<td>
<p>(int) This parameter indicates that the algorithm should estimate the 'k' frequencies as a part of the model.
An alternative is the 'periods' parameter which can be used to specify exactly which periods should be used by
the model.
</p>
<p>This parameter can also be interpreted as specifying the number of (multiplicative) Gegenbauer terms to fit in the model.</p>
</td></tr>
<tr><td><code id="garma_+3A_include.mean">include.mean</code></td>
<td>
<p>(bool) A boolean value indicating whether a mean should be fit.
Note that no mean term is fit if the series is integer differenced.</p>
</td></tr>
<tr><td><code id="garma_+3A_include.drift">include.drift</code></td>
<td>
<p>(bool) A boolean value indicating whether a 'drift' term should be fit to the predictions.
The default is to fit a drift term to the predictions if the process is integer-differenced.</p>
</td></tr>
<tr><td><code id="garma_+3A_xreg">xreg</code></td>
<td>
<p>(numeric matrix) A numerical vector or matrix of external regressors, which must have the same number of rows as x.
It should not have any NA values. It should not be a data frame. The default value is NULL.
</p>
<p>Note that the algorithm used here is that if any 'xreg' is supplied, then a linear regression model is fit first, and the
GARMA model is then based on the residuals from that regression model.</p>
</td></tr>
<tr><td><code id="garma_+3A_method">method</code></td>
<td>
<p>(character) This defines the estimation method for the routine. The valid values are 'CSS', 'Whittle', and
'WLL'. The default ('Whittle') method will generally return very accurate estimates quite quickly, provided the assumption
of a Gaussian distribution is even approximately correct, and is probably the method of choice for most users. For the
theory behind this, refer Giraitis et. al. (2001).
</p>
<p>The 'CSS' method is a conditional 'sum-of-squares' technique and can be quite slow.
Reference: Robinson (2006), Chung (1996). Note that the paper of Chung (1996) was partially critisised by Giraitis et.
al. (2001), however still contains useful results.
</p>
<p>'WLL' is a new technique, originally developed by the author of this package and which appears to work well even if the
<code class="reqn">\epsilon_{t}</code> are highly skewed and/or have heavy tails (skewed and/or lepto-kurtic). However the
asymptotic theory for the WLL method is not complete and so standard errors are not available for most parameters.
Refer Hunt et. al. (2021).</p>
</td></tr>
<tr><td><code id="garma_+3A_d_lim">d_lim</code></td>
<td>
<p>(list) the limits for the d parameter. The default is 'c(0,0.5)', which restricts the model to be stationary.
However sometimes it is desirable to understand what the unrestricted value might be.</p>
</td></tr>
<tr><td><code id="garma_+3A_opt_method">opt_method</code></td>
<td>
<p>(character) This names the optimisation method used to find the parameter estimates.
This may be a list of methods, in which case the methods are applied in turn,
each using the results of the previous one as the starting point for the next. The default is to use c('solnp', 'cobyla').
For some data or some models, however, other methods may work well.
</p>
<p>Supported algorithms include:
</p>

<ul>
<li><p> 'cobyla' algorithm in package nloptr
</p>
</li>
<li><p> 'directL' algorithm in package nloptr
</p>
</li>
<li><p> 'solnp' from Rsolnp package
</p>
</li>
<li><p> 'gosolnp' from Rsolnp package.
</p>
</li></ul>

<p>Note that the algorithms are selected to be those which do not require derivatives, even numerically calculated
derivatives. The function being optimised by 'garma()' has a point of discontinuity at the minimum value - the point
we are trying to find. This means that standard algorithms like BFGS et al. perform very poorly here.
</p>
<p>Note further that if you specify a value of 'k' &gt; 1, then inequality constraints are required, and this will further limit
the list of supported routines.</p>
</td></tr>
<tr><td><code id="garma_+3A_control">control</code></td>
<td>
<p>(list) list of optimisation routine specific values.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The GARMA model is specified as
</p>
<p style="text-align: center;"><code class="reqn">\displaystyle{\phi(B)\prod_{i=1}^{k}(1-2u_{i}B+B^{2})^{d_{i}}(1-B)^{id} (X_{t}-\mu)= \theta(B) \epsilon _{t}}</code>
</p>

<p>where
</p>

<ul>
<li> <p><code class="reqn">\phi(B)</code> represents the short-memory Autoregressive component of order p,
</p>
</li>
<li> <p><code class="reqn">\theta(B)</code> represents the short-memory Moving Average component of order q,
</p>
</li>
<li> <p><code class="reqn">(1-2u_{i}B+B^{2})^{d_{i}}</code> represents the long-memory Gegenbauer component (there may in
general be k of these),
</p>
</li>
<li> <p><code class="reqn">id</code> represents the degree of integer differencing, where as <code class="reqn">d_i</code> represents the degree of fractional
differencing. Note that <code class="reqn">id</code> is a value supplied by the user (the second number on the 'order=' parameter - similarly
to the way that the base R 'arima' function works) whereas <code class="reqn">d_i</code> is estimated by this function.
</p>
</li>
<li> <p><code class="reqn">X_{t}</code> represents the observed process,
</p>
</li>
<li> <p><code class="reqn">\epsilon_{t}</code> represents the random component of the model - these are assumed to be uncorrelated but
identically distributed variates. Generally the routines in this package will work best if these have an approximate
Gaussian distribution.
</p>
</li>
<li> <p><code class="reqn">B</code> represents the Backshift operator, defined by <code class="reqn">B X_{t}=X_{t-1}</code>.
</p>
</li></ul>

<p>when k=0, then this is just a short memory model as fit by the stats &quot;arima&quot; function.
</p>


<h3>Value</h3>

<p>An S3 object of class &quot;garma_model&quot;.
</p>


<h3>Author(s)</h3>

<p>Richard Hunt
</p>


<h3>References</h3>

<p>C Chung. A generalized fractionally integrated autoregressive moving-average process.
Journal of Time Series Analysis, 17(2):111-140, 1996. DOI: https://doi.org/10.1111/j.1467-9892.1996.tb00268.x
</p>
<p>L Giraitis, J Hidalgo, and P Robinson. Gaussian estimation of parametric spectral density with unknown pole.
The Annals of Statistics, 29(4):987–1023, 2001. DOI: https://doi.org/10.1214/AOS/1013699989
</p>
<p>R Hunt, S Peiris, N Webe. A General Frequency Domain Estimation Method for Gegenbauer Processes.
Journal of Time Series Econometrics, 13(2):119-144, 2021. DOI: https://doi.org/10.1515/jtse-2019-0031
</p>
<p>R Hunt, S Peiris, N Weber. Estimation methods for stationary Gegenbauer processes.
Statistical Papers 63:1707-1741, 2022. DOI: https://doi.org/10.1007/s00362-022-01290-3
</p>
<p>P. Robinson. Conditional-sum-of-squares estimation of models for stationary time series with long memory.
IMS Lecture Notes Monograph Series, Time Series and Related Topics, 52:130-137, 2006.
DOI: https://doi.org/10.1214/074921706000000996.
</p>


<h3>See Also</h3>

<p>Useful links:
</p>

<ul>
<li> <p><a href="https://github.com/rlph50/garma">https://github.com/rlph50/garma</a>
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>data(AirPassengers)
ap &lt;- as.numeric(diff(AirPassengers, 12))
print(garma(ap, order = c(9, 1, 0), k = 0, method = "CSS", include.mean = FALSE))
# Compare with the built-in arima function
print(arima(ap, order = c(9, 1, 0), include.mean = FALSE))
</code></pre>

<hr>
<h2 id='AIC.garma_model'>AIC for model</h2><span id='topic+AIC.garma_model'></span>

<h3>Description</h3>

<p>Approximate AIC for model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'garma_model'
AIC(object, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="AIC.garma_model_+3A_object">object</code></td>
<td>
<p>The garma_model object</p>
</td></tr>
<tr><td><code id="AIC.garma_model_+3A_...">...</code></td>
<td>
<p>Other parameters. Ignored.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>(double) Approximate AIC - uses approximation of whichever methoid is used to find model params.
</p>

<hr>
<h2 id='autoplot.garma_model'>ggplot of the Forecasts of the model.</h2><span id='topic+autoplot.garma_model'></span>

<h3>Description</h3>

<p>The ggplot function generates a ggplot of actuals and predicted values for a &quot;garma_model&quot; object.
This adds in sensible titles etc as best it can determine.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'garma_model'
autoplot(object, h = 24, include_fitted = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="autoplot.garma_model_+3A_object">object</code></td>
<td>
<p>(garma_model) The garma_model from which to ggplot the values.</p>
</td></tr>
<tr><td><code id="autoplot.garma_model_+3A_h">h</code></td>
<td>
<p>(int) The number of time periods to predict ahead. Default: 24</p>
</td></tr>
<tr><td><code id="autoplot.garma_model_+3A_include_fitted">include_fitted</code></td>
<td>
<p>(bool) whether to include the 1-step ahead 'fitted' values in the plot. Default: FALSE</p>
</td></tr>
<tr><td><code id="autoplot.garma_model_+3A_...">...</code></td>
<td>
<p>other parameters passed to ggplot.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A ggplot2 &quot;ggplot&quot; object. Note that the standard ggplot2 &quot;+&quot; notation can be used to enhance the default output.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(ggplot2)

data(AirPassengers)
ap &lt;- as.numeric(diff(AirPassengers, 12))
mdl &lt;- garma(ap, order = c(9, 1, 0), k = 0, method = "CSS", include.mean = FALSE)
autoplot(mdl)
</code></pre>

<hr>
<h2 id='coef.garma_model'>Model Coefficients</h2><span id='topic+coef.garma_model'></span>

<h3>Description</h3>

<p>Model Coefficients/parameters.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'garma_model'
coef(object, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="coef.garma_model_+3A_object">object</code></td>
<td>
<p>The garma_model object</p>
</td></tr>
<tr><td><code id="coef.garma_model_+3A_...">...</code></td>
<td>
<p>Other parameters. Ignored.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>(double) array of parameter value estimates from the fitted model.
</p>

<hr>
<h2 id='extract_arma'>Extract underlying ARMA process.</h2><span id='topic+extract_arma'></span>

<h3>Description</h3>

<p>For a Gegenbauer process, transform to remove Gegenbauer long memory component to get a short memory (ARMA) process.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>extract_arma(x, ggbr_factors)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="extract_arma_+3A_x">x</code></td>
<td>
<p>(num) This should be a numeric vector representing the Gegenbauer process.</p>
</td></tr>
<tr><td><code id="extract_arma_+3A_ggbr_factors">ggbr_factors</code></td>
<td>
<p>(class) Each element of the list represents a Gegenbauer factor and includes f, u and fd elements.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of same class as x. Any time series attributes of x are copied to the returned object.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(AirPassengers)
ap &lt;- as.numeric(diff(AirPassengers, 12))
# find semiparametric estimates of the Gegenbauer parameters.
sp &lt;- ggbr_semipara(ap)
# extract the underlying short-memory ARMA process
ap_arma &lt;- extract_arma(ap, sp)
summary(arima(ap_arma, order = c(1, 0, 0)))
</code></pre>

<hr>
<h2 id='fitted.garma_model'>Extract fitted values</h2><span id='topic+fitted.garma_model'></span>

<h3>Description</h3>

<p>Fitted values are 1-step ahead predictions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'garma_model'
fitted(object, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="fitted.garma_model_+3A_object">object</code></td>
<td>
<p>The garma_model object</p>
</td></tr>
<tr><td><code id="fitted.garma_model_+3A_...">...</code></td>
<td>
<p>Other parameters. Ignored.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>(double) array of 1-step ahead fitted values for the model.
</p>

<hr>
<h2 id='forecast.garma_model'>Forecast future values.</h2><span id='topic+forecast.garma_model'></span>

<h3>Description</h3>

<p>The forecast function predicts future values of a &quot;garma_model&quot; object, and is exactly the same as the &quot;predict&quot; function with slightly different parameter values.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'garma_model'
forecast(object, h = 1, newdata = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="forecast.garma_model_+3A_object">object</code></td>
<td>
<p>(garma_model) The garma_model from which to forecast the values.</p>
</td></tr>
<tr><td><code id="forecast.garma_model_+3A_h">h</code></td>
<td>
<p>(int) The number of time periods to predict ahead. Default: 1</p>
</td></tr>
<tr><td><code id="forecast.garma_model_+3A_newdata">newdata</code></td>
<td>
<p>(real vector or matrix) If the original model was fitted with the 'xreg=' option then this will provide the xreg
values for predictions. If this is a vector then its length should be 'h'; if it is a matrix then it should have 'h' rows.
</p>
<p>It should have columns with the same names as the original xreg matrix.</p>
</td></tr>
<tr><td><code id="forecast.garma_model_+3A_...">...</code></td>
<td>
<p>Other parameters passed to the forecast function. For &quot;garma_model&quot; objects, these are ignored.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>- a &quot;ts&quot; object containing the requested forecasts.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(forecast)

data(AirPassengers)
ap &lt;- as.numeric(diff(AirPassengers, 12))
mdl &lt;- garma(ap, order = c(9, 1, 0), k = 0, method = "CSS", include.mean = FALSE)
forecast(mdl, h = 12)
</code></pre>

<hr>
<h2 id='garma_ggtsdisplay'>ggtsdisplay of underlying ARMA process.</h2><span id='topic+garma_ggtsdisplay'></span>

<h3>Description</h3>

<p>For a Gegenbauer process, use semi-parametric methods to obtain short memory version of the process, then run a ggtsdisplay().
</p>


<h3>Usage</h3>

<pre><code class='language-R'>garma_ggtsdisplay(x, k = 1, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="garma_ggtsdisplay_+3A_x">x</code></td>
<td>
<p>(num) This should be a numeric vector representing the process to estimate.</p>
</td></tr>
<tr><td><code id="garma_ggtsdisplay_+3A_k">k</code></td>
<td>
<p>(int) The number of Gegenbauer factors</p>
</td></tr>
<tr><td><code id="garma_ggtsdisplay_+3A_...">...</code></td>
<td>
<p>additional parameters to pass to ggtsdisplay</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The purpose of this function is to ease the process of identifying the underlying short memory process.
</p>


<h3>Value</h3>

<p>A ggplot object.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(AirPassengers)
ap &lt;- as.numeric(diff(AirPassengers, 12))
garma_ggtsdisplay(ap)
</code></pre>

<hr>
<h2 id='gg_raw_pgram'>Display raw periodogram</h2><span id='topic+gg_raw_pgram'></span>

<h3>Description</h3>

<p>Display the raw periodogram for a time series, and not on a log scale.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gg_raw_pgram(x, k = 1)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="gg_raw_pgram_+3A_x">x</code></td>
<td>
<p>(num) This should be a numeric vector representing the process to estimate.</p>
</td></tr>
<tr><td><code id="gg_raw_pgram_+3A_k">k</code></td>
<td>
<p>(int) The number of Gegenbauer factors</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The standard &quot;R&quot; functions display periodograms on a log scale which can make it more difficult to locate high peaks in the
spectrum at differing frequencies. This routine will display the peaks on a raw scale.
</p>


<h3>Value</h3>

<p>A ggplot object representing the raw periodogram
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(AirPassengers)
ap &lt;- as.numeric(diff(AirPassengers, 12))
sp &lt;- ggbr_semipara(ap)
print(sp)
</code></pre>

<hr>
<h2 id='ggbr_semipara'>Extract semiparametric estimates of the Gegenbauer factors.</h2><span id='topic+ggbr_semipara'></span>

<h3>Description</h3>

<p>For a Gegenbauer process, use semi-parametric methods to estimate the Gegenbauer frequency and fractional differencing.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ggbr_semipara(x, periods = NULL, k = 1, alpha = 0.8, method = "gsp")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ggbr_semipara_+3A_x">x</code></td>
<td>
<p>(num) This should be a numeric vector representing the process to estimate.</p>
</td></tr>
<tr><td><code id="ggbr_semipara_+3A_periods">periods</code></td>
<td>
<p>(num) This parameter can be used to specify a fixed period or set of periods for the
Gegenbauer periodicity. For instance if you have monthly data, then it might be sensible (after an examination of the
periodogram) to set 'periods = 12'. The default value is NULL. Either 'periods' or 'k' parameters must be specified
but not both - 'periods' implies fixed period(s) are to be used and 'k' implies that the periods should
be estimated.</p>
</td></tr>
<tr><td><code id="ggbr_semipara_+3A_k">k</code></td>
<td>
<p>(int) This parameter indicates that the algorithm should estimate the 'k' frequencies semi-parametrically,
before estimating the degree of fractional differencing at each period.
</p>
<p>An alternative is the 'periods' parameter which can be used to specify exactly which periods should be used by
the model.</p>
</td></tr>
<tr><td><code id="ggbr_semipara_+3A_alpha">alpha</code></td>
<td>
<p>(num) Default = 0.8 - This is the bandwidth for the semiparametric estimate, and should be between 0 and 1.
Robinson (1994) indicated optimality for a (scaled) version of 'alpha' = 0.8, at least for the &quot;lpr&quot; 'method'.</p>
</td></tr>
<tr><td><code id="ggbr_semipara_+3A_method">method</code></td>
<td>
<p>(char) One of &quot;gsp&quot; or &quot;lpr&quot; - lpr is the log-periodogram-regression technique, &quot;gsp&quot; is the Gaussian
semi-parametric technique. &quot;gsp&quot; is the default. Refer Arteche &amp; Robinson (1998).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class &quot;garma_semipara&quot;.
</p>


<h3>References</h3>

<p>J Arteche and P Robinson. Semiparametric inference in seasonal and cyclical long memory processes. Journal of Time Series
Analysis, 21(1):1–25, 2000. DOI: https://doi.org/10.1111/1467-9892.00170
</p>
<p>P Robinson. Rates of convergence and optimal spectral bandwidth for long range dependence. Probability Theory and Related
Fields, 99:443–473, 1994. DOI: https://doi.org/10.1007/BF01199901.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(AirPassengers)
ap &lt;- as.numeric(diff(AirPassengers, 12))
sp &lt;- ggbr_semipara(ap)
print(sp)
</code></pre>

<hr>
<h2 id='gof'>Goodness-of-Fit test for a garma_model.</h2><span id='topic+gof'></span>

<h3>Description</h3>

<p>Provides a goodness-of-fit test for a GARMA Model, using Bartletts Tp test.
This has been justified for long memory and for GARMA models by Delgado, Hidalgo and Velasco (2005).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gof(object)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="gof_+3A_object">object</code></td>
<td>
<p>(garma_model) The garma_model to test.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Invisibly returns the array of p-values from the test.
</p>


<h3>References</h3>

<p>M Delgado, J Hidalgo, and C Velasco. Distribution free goodness-of-fit tests for linear processes.
The Annals of Statistics, 33(6):2568–2609, 2005. DOI: https://doi.org/10.1214/009053605000000606.
</p>

<hr>
<h2 id='logLik.garma_model'>Log Likelihood</h2><span id='topic+logLik.garma_model'></span>

<h3>Description</h3>

<p>The approximate likelihood for the model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'garma_model'
logLik(object, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="logLik.garma_model_+3A_object">object</code></td>
<td>
<p>The garma_model object</p>
</td></tr>
<tr><td><code id="logLik.garma_model_+3A_...">...</code></td>
<td>
<p>Other parameters. Ignored.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Object of class &quot;logLik&quot; with values for the (approx) log-likelihood for the model
</p>

<hr>
<h2 id='plot.garma_model'>Plot Forecasts from model.</h2><span id='topic+plot.garma_model'></span>

<h3>Description</h3>

<p>The plot function generates a plot of actuals and predicted values for a &quot;garma_model&quot; object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'garma_model'
plot(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot.garma_model_+3A_x">x</code></td>
<td>
<p>(garma_model) The garma_model from which to plot the values.</p>
</td></tr>
<tr><td><code id="plot.garma_model_+3A_...">...</code></td>
<td>
<p>other arguments to be passed to the &quot;plot&quot; function, including h (int) - the number of periods ahead to forecast.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An R &quot;plot&quot; object.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(AirPassengers)
ap &lt;- as.numeric(diff(AirPassengers, 12))
mdl &lt;- garma(ap, order = c(9, 1, 0), k = 0, method = "CSS", include.mean = FALSE)
plot(mdl)
</code></pre>

<hr>
<h2 id='predict.garma_model'>Predict future values.</h2><span id='topic+predict.garma_model'></span>

<h3>Description</h3>

<p>Predict ahead using algorithm of Godet (2009).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'garma_model'
predict(object, n.ahead = 1, newdata = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="predict.garma_model_+3A_object">object</code></td>
<td>
<p>(garma_model) The garma_model from which to predict the values. This should have been generated by the [garma()]
function.</p>
</td></tr>
<tr><td><code id="predict.garma_model_+3A_n.ahead">n.ahead</code></td>
<td>
<p>(int) The number of time periods to predict ahead. Default: 1</p>
</td></tr>
<tr><td><code id="predict.garma_model_+3A_newdata">newdata</code></td>
<td>
<p>(real vector or matrix) If the original model was fitted with the 'xreg=' option then this will provide the xreg
values for predictions. If this is a vector then its length should be 'n.ahead'; if it is a matrix then it should have
'n.ahead' rows.
</p>
<p>It should have columns with the same names as the original xreg matrix.</p>
</td></tr>
<tr><td><code id="predict.garma_model_+3A_...">...</code></td>
<td>
<p>Other parameters. Ignored.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A &quot;ts&quot; object containing the requested forecasts.
</p>


<h3>References</h3>

<p>Godet, F. Linear prediction of long-range dependent time series, ESAIM: PS (2009) 13 115-134.
DOI: https://doi.org/10.1051/ps:2008015
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(AirPassengers)
ap &lt;- as.numeric(diff(AirPassengers, 12))
mdl &lt;- garma(ap, order = c(9, 1, 0), k = 0, method = "CSS", include.mean = FALSE)
predict(mdl, n.ahead = 12)
</code></pre>

<hr>
<h2 id='print.garma_model'>print a garma_model object.</h2><span id='topic+print.garma_model'></span>

<h3>Description</h3>

<p>The print function prints a summary of a &quot;garma_model&quot; object, printed to the output.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'garma_model'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="print.garma_model_+3A_x">x</code></td>
<td>
<p>(garma_model) The garma_model from which to print the values.</p>
</td></tr>
<tr><td><code id="print.garma_model_+3A_...">...</code></td>
<td>
<p>Other arguments. Ignored.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>(null)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(AirPassengers)
ap &lt;- as.numeric(diff(AirPassengers, 12))
mdl &lt;- garma(ap, order = c(9, 1, 0), k = 0, method = "CSS", include.mean = FALSE)
print(mdl)
</code></pre>

<hr>
<h2 id='print.ggbr_factors'>Print a 'ggbr_factors' object.</h2><span id='topic+print.ggbr_factors'></span>

<h3>Description</h3>

<p>Print a 'ggbr_factors' object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'ggbr_factors'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="print.ggbr_factors_+3A_x">x</code></td>
<td>
<p>An object of class ggbr_factors</p>
</td></tr>
<tr><td><code id="print.ggbr_factors_+3A_...">...</code></td>
<td>
<p>further parameters for print function</p>
</td></tr>
</table>


<h3>Value</h3>

<p>null
</p>

<hr>
<h2 id='residuals.garma_model'>Residuals</h2><span id='topic+residuals.garma_model'></span>

<h3>Description</h3>

<p>Response Residuals from the model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'garma_model'
residuals(object, type = "response", h = 1, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="residuals.garma_model_+3A_object">object</code></td>
<td>
<p>The garma_model object</p>
</td></tr>
<tr><td><code id="residuals.garma_model_+3A_type">type</code></td>
<td>
<p>(chr) The type of residuals. Must be 'response'.</p>
</td></tr>
<tr><td><code id="residuals.garma_model_+3A_h">h</code></td>
<td>
<p>(int) The number of periods ahead for the residuals. Must be 1.</p>
</td></tr>
<tr><td><code id="residuals.garma_model_+3A_...">...</code></td>
<td>
<p>Other parameters. Ignored.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>(double) array of resideuals from the model.
</p>

<hr>
<h2 id='summary.garma_model'>summarise a garma_model object.</h2><span id='topic+summary.garma_model'></span>

<h3>Description</h3>

<p>The summary function provides a summary of a &quot;garma_model&quot; object, printed to the output.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'garma_model'
summary(object, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="summary.garma_model_+3A_object">object</code></td>
<td>
<p>(garma_model) The garma_model from which to print the values.</p>
</td></tr>
<tr><td><code id="summary.garma_model_+3A_...">...</code></td>
<td>
<p>Other arguments. Ignored.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>(null)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(AirPassengers)
ap &lt;- as.numeric(diff(AirPassengers, 12))
mdl &lt;- garma(ap, order = c(9, 1, 0), k = 0, method = "CSS", include.mean = FALSE)
summary(mdl)
</code></pre>

<hr>
<h2 id='tsdiag.garma_model'>Diagnostic fit of a garma_model.</h2><span id='topic+tsdiag.garma_model'></span>

<h3>Description</h3>

<p>Produces diagnostic plots of the model fit.
This function is copied from stats::tsdiag but modifies the fit_df for the Ljung-Box test for use with garma models.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'garma_model'
tsdiag(object, gof.lag = 10, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="tsdiag.garma_model_+3A_object">object</code></td>
<td>
<p>(garma_model) The garma_model to produce the diagnostic plots for.</p>
</td></tr>
<tr><td><code id="tsdiag.garma_model_+3A_gof.lag">gof.lag</code></td>
<td>
<p>(int) The number of lags to examine for the Ljung-Box white noise test.</p>
</td></tr>
<tr><td><code id="tsdiag.garma_model_+3A_...">...</code></td>
<td>
<p>further arguments to be passed to particular methods.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>None. Diagnostics are generated.
</p>


<h3>See Also</h3>

<p>The stats package tsdiag function: <a href="https://stat.ethz.ch/R-manual/R-patched/library/stats/html/tsdiag.html">https://stat.ethz.ch/R-manual/R-patched/library/stats/html/tsdiag.html</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(AirPassengers)
ap &lt;- as.numeric(diff(AirPassengers, 12))
mdl &lt;- garma(ap, order = c(9, 1, 0), k = 0, method = "CSS", include.mean = FALSE)
tsdiag(mdl)
</code></pre>

<hr>
<h2 id='vcov.garma_model'>Covariance matrix</h2><span id='topic+vcov.garma_model'></span>

<h3>Description</h3>

<p>Covariance matrix of parameters if available
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'garma_model'
vcov(object, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="vcov.garma_model_+3A_object">object</code></td>
<td>
<p>The garma_model object</p>
</td></tr>
<tr><td><code id="vcov.garma_model_+3A_...">...</code></td>
<td>
<p>Other parameters. Ignored.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>(double) estimated variance-covariance matrix of the parameter estimates
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
