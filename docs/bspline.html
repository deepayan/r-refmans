<!DOCTYPE html><html><head><title>Help for package bspline</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {bspline}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#bspline'><p>bspline: build and use B-splines for interpolation and regression.</p></a></li>
<li><a href='#bcurve'><p>nD B-curve governed by (x,y,...) control points.</p></a></li>
<li><a href='#bsc'><p>Basis matrix and knot Jacobian for B-spline of order 0 (step function) and higher</p></a></li>
<li><a href='#bsp'><p>Calculate B-spline values from their coefficients qw and knots xk</p></a></li>
<li><a href='#bsppar'><p>Retrieve parameters of B-splines</p></a></li>
<li><a href='#dbsp'><p>Derivative of B-spline</p></a></li>
<li><a href='#diffn'><p>Finite differences</p></a></li>
<li><a href='#dmat'><p>Differentiation matrix</p></a></li>
<li><a href='#ibsp'><p>Indefinite integral of B-spline</p></a></li>
<li><a href='#iknots'><p>Estimate internal knot positions equalizing jumps in n-th derivative</p></a></li>
<li><a href='#ipk'><p>Intervals of points in knot intervals</p></a></li>
<li><a href='#jacw'><p>Knot Jacobian of B-spline with weights</p></a></li>
<li><a href='#par2bsp'><p>Convert parameters to B-spline function</p></a></li>
<li><a href='#parr'><p>Polynomial formulation of B-spline</p></a></li>
<li><a href='#pbsc'><p>Polynomial B-spline Calculation of Basis Matrix</p></a></li>
<li><a href='#smbsp'><p>Smoothing B-spline of order n &gt;= 0</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>B-Spline Interpolation and Regression</td>
</tr>
<tr>
<td>Version:</td>
<td>2.2.2</td>
</tr>
<tr>
<td>Author:</td>
<td>Serguei Sokol &lt;sokol@insa-toulouse.fr&gt;</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Serguei Sokol &lt;sokol@insa-toulouse.fr&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Build and use B-splines for interpolation and regression.
  In case of regression, equality constraints as well as monotonicity
  and/or positivity of B-spline weights can be imposed. Moreover, 
  knot positions (not only spline weights) can be part of 
  optimized parameters too. For this end, 'bspline' is able to calculate
  Jacobian of basis vectors as function of knot positions. User is provided with 
  functions calculating spline values at arbitrary points. These 
  functions can be differentiated and integrated to obtain B-splines calculating 
  derivatives/integrals at any point. B-splines of this package can 
  simultaneously operate on a series of curves sharing the same set of 
  knots. 'bspline' is written with concern about computing 
  performance that's why the basis and Jacobian calculation is implemented in C++.
  The rest is implemented in R but without notable impact on computing speed.</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/MathsCell/bspline">https://github.com/MathsCell/bspline</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/MathsCell/bspline/issues">https://github.com/MathsCell/bspline/issues</a></td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>Imports:</td>
<td>Rcpp (&ge; 1.0.7), nlsic (&ge; 1.0.2), arrApply</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>Rcpp, RcppArmadillo</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.3.1</td>
</tr>
<tr>
<td>Suggests:</td>
<td>RUnit</td>
</tr>
<tr>
<td>Copyright:</td>
<td>INRAE/INSA/CNRS</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-07-02 13:38:22 UTC; sokol</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-07-02 15:00:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='bspline'>bspline: build and use B-splines for interpolation and regression.</h2><span id='topic+bspline-package'></span><span id='topic+bspline'></span>

<h3>Description</h3>

<p>Build and use B-splines for interpolation and regression.
In case of regression, equality constraints as well as monotonicity
requirement can be imposed. Moreover, 
knot positions (not only spline coefficients) can be part of 
optimized parameters too. User is provided with 
functions calculating spline values at arbitrary points. This 
functions can be differentiated to obtain B-splines calculating 
derivatives at any point. B-splines of this package can 
simultaneously operate on a series of curves sharing the same set of 
knots. 'bspline' is written with concern about computing 
performance that's why the basis calculation is implemented in C++.
The rest is implemented in R but without notable impact on computing speed.
</p>


<h3>bspline functions</h3>


<dl>
<dt>&quot;<code>bsc</code>:&quot;</dt><dd><p> basis matrix (implemented in C++)</p>
</dd>
<dt>&quot;<code>bsp</code>:&quot;</dt><dd><p> values of B-spline from its coefficients</p>
</dd>
<dt>&quot;<code>dbsp</code>:&quot;</dt><dd><p> derivative of B-spline</p>
</dd>
<dt>&quot;<code>par2bsp</code>:&quot;</dt><dd><p> build B-spline function from parameters </p>
</dd>
<dt>&quot;<code>bsppar</code>:&quot;</dt><dd><p> retrieve B-spline parameters from its function</p>
</dd>
<dt>&quot;<code>smbsp</code>:&quot;</dt><dd><p> build smoothing B-spline</p>
</dd>
<dt>&quot;<code>fitsmbsp</code>:&quot;</dt><dd><p> build smoothing B-spline with optimized knot positions</p>
</dd>
<dt>&quot;<code>diffn</code>:&quot;</dt><dd><p> finite differences</p>
</dd>
</dl>



<h3>See Also</h3>

<p>Useful links:
</p>

<ul>
<li> <p><a href="https://github.com/MathsCell/bspline">https://github.com/MathsCell/bspline</a>
</p>
</li>
<li><p> Report bugs at <a href="https://github.com/MathsCell/bspline/issues">https://github.com/MathsCell/bspline/issues</a>
</p>
</li></ul>


<hr>
<h2 id='bcurve'>nD B-curve governed by (x,y,...) control points.</h2><span id='topic+bcurve'></span>

<h3>Description</h3>

<p>nD B-curve governed by (x,y,...) control points.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bcurve(xy, n = 3)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bcurve_+3A_xy">xy</code></td>
<td>
<p>Real matrix of (x,y,...) coordinates, one control point per row.</p>
</td></tr>
<tr><td><code id="bcurve_+3A_n">n</code></td>
<td>
<p>Integer scalar, polynomial order of B-spline (3 by default)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The curve will pass by the first and the last points in 'xy'. The tangents at the
first and last points will coincide with the first and last segments of
control points. Example of signature is inspired from this <a href="https://www.r-bloggers.com/2023/03/little-useless-useful-r-functions-using-xspline-to-create-wacky-signatures/">blog</a>.
</p>


<h3>Value</h3>

<p>Function of one argument calculating B-curve. The argument is supposed
to be in [0, 1] interval.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  # simulate doctor's signature ;)
  set.seed(71);
  xy=matrix(rnorm(16), ncol=2)
  tp=seq(0,1,len=301)
  doc_signtr=bcurve(xy)
  plot(doc_signtr(tp), t="l", xaxt='n',  yaxt='n', ann=FALSE, frame.plot=FALSE,
      xlim=range(xy[,1]), ylim=range(xy[,2]))
  # see where control points are
  text(xy, labels=seq(nrow(xy)), col=rgb(0, 0, 0, 0.25))
  # join them by segments
  lines(bcurve(xy, n=1)(tp), col=rgb(0, 0, 1, 0.25))
  
  # randomly curved wire in 3D space
## Not run: 
  if (requireNamespace("rgl", quietly=TRUE)) {
     xyz=matrix(rnorm(24),ncol=3)
     tp=seq(0,1,len=201)
     curv3d=bcurve(xyz)
     rgl::plot3d(curv3d(tp), t="l", decorate=FALSE)
  }

## End(Not run)
</code></pre>

<hr>
<h2 id='bsc'>Basis matrix and knot Jacobian for B-spline of order 0 (step function) and higher</h2><span id='topic+bsc'></span>

<h3>Description</h3>

<p>This function is analogous but not equivalent to <code>splines:bs()</code> and <code>splines2::bSpline()</code>.
It is also several times faster.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bsc(x, xk, n = 3L, cjac = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bsc_+3A_x">x</code></td>
<td>
<p>Numeric vector, abscissa points</p>
</td></tr>
<tr><td><code id="bsc_+3A_xk">xk</code></td>
<td>
<p>Numeric vector, knots</p>
</td></tr>
<tr><td><code id="bsc_+3A_n">n</code></td>
<td>
<p>Integer scalar, polynomial order (3 by default)</p>
</td></tr>
<tr><td><code id="bsc_+3A_cjac">cjac</code></td>
<td>
<p>Logical scalar, if <code>TRUE</code> makes to calculate Jacobian of basis
vectors as function of knot positions (FALSE by default)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For n==0, step function is defined as constant on each interval
<code>[xk[i]; xk[i+1][</code>, i.e. closed on the left and open on the right
except for the last interval which is closed on the right too. The
Jacobian for step function is considered 0 in every x point even if
in points where x=xk, the derivative is not defined.<br />
For n==1, Jacobian is discontinuous in such points so for
these points we take the derivative from the right.
</p>


<h3>Value</h3>

<p>Numeric matrix (for cjac=FALSE), each column correspond to a
B-spline calculated on x; or List (for cjac=TRUE) with components </p>

<dl>
<dt>mat</dt><dd><p>basis matrix of dimension <code>nx x nw</code>, where nx is the length
of x and <code>nw=nk-n-1</code> is the number of basis vectors</p>
</dd>
<dt>jac</dt><dd><p>array of dimension <code>nx x (n+2) x nw</code> where n+2
is the number of support knots for each basis vector
</p>
</dd>
</dl>



<h3>See Also</h3>

<p>[splines::bs()], [splines2::bSpline()]
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  x=seq(0, 5, length.out=101)
  # cubic basis matrix
  n=3
  m=bsc(x, xk=c(rep(0, n+1), 1:4, rep(5, n+1)), n=n)
  matplot(x, m, t="l")
  stopifnot(all.equal.numeric(c(m), c(splines::bs(x, knots = 1:4, degree = n, intercept = TRUE))))
</code></pre>

<hr>
<h2 id='bsp'>Calculate B-spline values from their coefficients qw and knots xk</h2><span id='topic+bsp'></span>

<h3>Description</h3>

<p>Calculate B-spline values from their coefficients qw and knots xk
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bsp(x, xk, qw, n = 3L)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bsp_+3A_x">x</code></td>
<td>
<p>Numeric vector, abscissa points at which B-splines should be calculated.
They are supposed to be non decreasing.</p>
</td></tr>
<tr><td><code id="bsp_+3A_xk">xk</code></td>
<td>
<p>Numeric vector, knots of the B-splines. They are supposed to be non decreasing.</p>
</td></tr>
<tr><td><code id="bsp_+3A_qw">qw</code></td>
<td>
<p>Numeric vector or matrix, coefficients of B-splines. <code>NROW(qw)</code>
must be equal to <code>length(xk)-n-1</code> where <code>n</code> is the next parameter</p>
</td></tr>
<tr><td><code id="bsp_+3A_n">n</code></td>
<td>
<p>Integer scalar, polynomial order of B-splines, by default cubic splines
are calculated.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function does nothing else than calculate a dot-product between
a B-spline basis matrix calculated by <code>bsc()</code> and coefficients <code>qw</code>.
If qw is a matrix, each
column corresponds to a separate set of coefficients.
For x values falling outside of xk range, the B-splines values are set to 0.
To get a function calculating spline values at arbitrary points from <code>xk</code>
and <code>qw</code>, cf. <code>par2bsp()</code>.
</p>


<h3>Value</h3>

<p>Numeric matrix (column number depends on qw dimensions), B-spline values on x.
</p>


<h3>See Also</h3>

<p>[bsc], [par2bsp]
</p>

<hr>
<h2 id='bsppar'>Retrieve parameters of B-splines</h2><span id='topic+bsppar'></span>

<h3>Description</h3>

<p>Retrieve parameters of B-splines
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bsppar(f)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bsppar_+3A_f">f</code></td>
<td>
<p>Function, B-splines such that returned by par3bsp(), smbsp(), ...</p>
</td></tr>
</table>


<h3>Value</h3>

<p>List having components: n - polynomial order, qw - coefficients, xk -
knots
</p>

<hr>
<h2 id='dbsp'>Derivative of B-spline</h2><span id='topic+dbsp'></span>

<h3>Description</h3>

<p>Derivative of B-spline
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dbsp(f, nderiv = 1L, same_xk = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dbsp_+3A_f">f</code></td>
<td>
<p>Function, B-spline such as returned by <code>smbsp()</code> or <code>par2bsp()</code></p>
</td></tr>
<tr><td><code id="dbsp_+3A_nderiv">nderiv</code></td>
<td>
<p>Integer scalar &gt;= 0, order of derivative to calculate (1 by default)</p>
</td></tr>
<tr><td><code id="dbsp_+3A_same_xk">same_xk</code></td>
<td>
<p>Logical scalar, if TRUE, indicates to calculate derivative
on the same knot grid as original function. In this case, coefficient number
will be incremented by 2. Otherwise, extreme knots are
removed on each side of the grid and coefficient number is maintained (FALSE by default).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Function calculating requested derivative
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  x=seq(0., 1., length.out=11L)
  y=sin(2*pi*x)
  f=smbsp(x, y, nki=2L)
  d_f=dbsp(f)
  xf=seq(0., 1., length.out=101) # fine grid for plotting
  plot(xf, d_f(xf)) # derivative estimated by B-splines
  lines(xf, 2.*pi*cos(2*pi*xf), col="blue") # true derivative
  xk=bsppar(d_f)$xk
  points(xk, d_f(xk), pch="x", col="red") # knot positions
</code></pre>

<hr>
<h2 id='diffn'>Finite differences</h2><span id='topic+diffn'></span>

<h3>Description</h3>

<p>Calculate dy/dx where x,y are first and the rest of columns in the entry matrix 'm'
</p>


<h3>Usage</h3>

<pre><code class='language-R'>diffn(m, ndiff = 1L)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="diffn_+3A_m">m</code></td>
<td>
<p>2- or more-column numeric matrix</p>
</td></tr>
<tr><td><code id="diffn_+3A_ndiff">ndiff</code></td>
<td>
<p>Integer scalar, order of finite difference (1 by default)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Numeric matrix, first column is midpoints of x, the second
and following are dy/dx
</p>

<hr>
<h2 id='dmat'>Differentiation matrix</h2><span id='topic+dmat'></span>

<h3>Description</h3>

<p>Calculate matrix for obtaining coefficients of first-derivative B-spline.
They can be calculated as <code>dqw=Md %*% qw</code>. Here, dqw are coefficients
of the first derivative,
Md is the matrix returned by this function, and qw are the coefficients
of differentiated B-spline.<br />
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dmat(nqw = NULL, xk = NULL, n = NULL, f = NULL, same_xk = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dmat_+3A_nqw">nqw</code></td>
<td>
<p>Integer scalar, row number of qw matrix (i.e. degree of freedom of a B-spline)</p>
</td></tr>
<tr><td><code id="dmat_+3A_xk">xk</code></td>
<td>
<p>Numeric vector, knot positions</p>
</td></tr>
<tr><td><code id="dmat_+3A_n">n</code></td>
<td>
<p>Integer scalar, B-spline polynomial order</p>
</td></tr>
<tr><td><code id="dmat_+3A_f">f</code></td>
<td>
<p>Function from which previous parameters can be retrieved.
If both f and any of previous parameters are given then explicitly
set parameters take precedence over those retrieved from f.</p>
</td></tr>
<tr><td><code id="dmat_+3A_same_xk">same_xk</code></td>
<td>
<p>Logical scalar, the same meaning as in <code><a href="#topic+dbsp">dbsp</a></code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>Numeric matrix of size <code>nqw-1 x nqw</code>
</p>

<hr>
<h2 id='ibsp'>Indefinite integral of B-spline</h2><span id='topic+ibsp'></span>

<h3>Description</h3>

<p>Indefinite integral of B-spline
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ibsp(f, const = 0, nint = 1L)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ibsp_+3A_f">f</code></td>
<td>
<p>Function, B-spline such as returned by <code>smbsp()</code> or <code>par2bsp()</code></p>
</td></tr>
<tr><td><code id="ibsp_+3A_const">const</code></td>
<td>
<p>Numeric scalar or vector of length <code>ncol(qw)</code> where
qw is weight matrix of f. Defines starting value of weights for indefinite
integral (0 by default).</p>
</td></tr>
<tr><td><code id="ibsp_+3A_nint">nint</code></td>
<td>
<p>Integer scalar &gt;= 0, defines how many times to take integral (1 by default)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If f is B-spline, then following identity is held: Dbsp(ibsp(f)) is identical to f.
Generally, it does not work in the other sens: ibsp(Dbsp(f)) is not f
but not very far. If we can get an appropriate constant C=f(min(x)) then
we can assert that ibsp(Dbsp(f), const=C) is the same as f.
</p>


<h3>Value</h3>

<p>Function calculating requested integral
</p>

<hr>
<h2 id='iknots'>Estimate internal knot positions equalizing jumps in n-th derivative</h2><span id='topic+iknots'></span>

<h3>Description</h3>

<p>Normalized total variation of n-th finite differences is calculated for each column in
<code>y</code> then averaged. These averaged values are fitted by a linear spline to
find knot positions that equalize the jumps of n-th derivative.<br />
NB. This function is used internally in <code>(fit)smbsp()</code> and a priori
has no interest to be called directly by user.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>iknots(x, y, nki = 1L, n = 3L)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="iknots_+3A_x">x</code></td>
<td>
<p>Numeric vector</p>
</td></tr>
<tr><td><code id="iknots_+3A_y">y</code></td>
<td>
<p>Numeric vector or matrix</p>
</td></tr>
<tr><td><code id="iknots_+3A_nki">nki</code></td>
<td>
<p>Integer scalar, number of internal knots to estimate (1 by default)</p>
</td></tr>
<tr><td><code id="iknots_+3A_n">n</code></td>
<td>
<p>Integer scalar, polynomial order of B-spline (3 by default)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Numeric vector, estimated knot positions
</p>

<hr>
<h2 id='ipk'>Intervals of points in knot intervals</h2><span id='topic+ipk'></span>

<h3>Description</h3>

<p>Find first and last+1 indexes iip s.t. x[iip] belongs to interval starting at xk[iik]
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ipk(x, xk)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ipk_+3A_x">x</code></td>
<td>
<p>Numeric vector, abscissa points (must be non decreasing)</p>
</td></tr>
<tr><td><code id="ipk_+3A_xk">xk</code></td>
<td>
<p>Numeric vector, knots (must be non decreasing)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Integer matrix of size <code>(2 x length(xk)-1)</code>. Indexes are 0-based
</p>

<hr>
<h2 id='jacw'>Knot Jacobian of B-spline with weights</h2><span id='topic+jacw'></span>

<h3>Description</h3>

<p>Knot Jacobian of B-spline with weights
</p>


<h3>Usage</h3>

<pre><code class='language-R'>jacw(jac, qws)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="jacw_+3A_jac">jac</code></td>
<td>
<p>Numeric array, such as returned by <code>bsc(..., cjac=TRUE)</code></p>
</td></tr>
<tr><td><code id="jacw_+3A_qws">qws</code></td>
<td>
<p>Numeric matrix, each column is a set of weights forming a
B-spline. If qws is a vector, it is coerced to 1-column matrix.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Numeric array of size <code>nx x ncol(qw) x nk</code>, where <code>nx=dim(jac)[1]</code>
and nk is the number of knots <code>dim(jac)[3]+n+1</code> (n being polynomial order).
</p>

<hr>
<h2 id='par2bsp'>Convert parameters to B-spline function</h2><span id='topic+par2bsp'></span>

<h3>Description</h3>

<p>Convert parameters to B-spline function
</p>


<h3>Usage</h3>

<pre><code class='language-R'>par2bsp(n, qw, xk, covqw = NULL, sdy = NULL, sdqw = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="par2bsp_+3A_n">n</code></td>
<td>
<p>Integer scalar, polynomial order of B-splines</p>
</td></tr>
<tr><td><code id="par2bsp_+3A_qw">qw</code></td>
<td>
<p>Numeric vector or matrix, coefficients of B-splines, one set per
column in case of matrix</p>
</td></tr>
<tr><td><code id="par2bsp_+3A_xk">xk</code></td>
<td>
<p>Numeric vector, knots</p>
</td></tr>
<tr><td><code id="par2bsp_+3A_covqw">covqw</code></td>
<td>
<p>Numeric Matrix, covariance matrix of qw (can be estimated in <code><a href="#topic+smbsp">smbsp</a></code>).</p>
</td></tr>
<tr><td><code id="par2bsp_+3A_sdy">sdy</code></td>
<td>
<p>Numeric vector, SD of each y column (can be estimated in <code><a href="#topic+smbsp">smbsp</a></code>).</p>
</td></tr>
<tr><td><code id="par2bsp_+3A_sdqw">sdqw</code></td>
<td>
<p>Numeric Matrix, SD of qw thus having the same dimension
as qw (can be estimated in <code><a href="#topic+smbsp">smbsp</a></code>).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Function, calculating B-splines at arbitrary points and having
interface <code>f(x, select)</code> where <code>x</code> is a vector of abscissa points.
Parameter <code>select</code> is passed to
<code>qw[, select, drop=FALSE]</code> and can be missing. This function will return
a matrix of size <code>length(x) x ncol(qw)</code> if <code>select</code> is missing. Elsewhere,
a number of column will depend on <code>select</code> parameter. Column names in
the result matrix will be inherited from <code>qw</code>.
</p>

<hr>
<h2 id='parr'>Polynomial formulation of B-spline</h2><span id='topic+parr'></span>

<h3>Description</h3>

<p>Polynomial formulation of B-spline
</p>


<h3>Usage</h3>

<pre><code class='language-R'>parr(xk, n = 3L)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="parr_+3A_xk">xk</code></td>
<td>
<p>Numeric vector, knots</p>
</td></tr>
<tr><td><code id="parr_+3A_n">n</code></td>
<td>
<p>Integer scalar, polynomial order (3 by default)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Numeric 3D array, the first index runs through n+1 polynomial coefficients;
the second &ndash; through n+1 supporting intervals; and the last one through nk-n-1
B-splines (here nk=length(xk)). Knot interval of length 0 will have corresponding
coefficients set to 0.
</p>

<hr>
<h2 id='pbsc'>Polynomial B-spline Calculation of Basis Matrix</h2><span id='topic+pbsc'></span>

<h3>Description</h3>

<p>Polynomial B-spline Calculation of Basis Matrix
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pbsc(x, xk, coeffs)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pbsc_+3A_x">x</code></td>
<td>
<p>Numeric,vector, abscissa points</p>
</td></tr>
<tr><td><code id="pbsc_+3A_xk">xk</code></td>
<td>
<p>Numeric vector, knots</p>
</td></tr>
<tr><td><code id="pbsc_+3A_coeffs">coeffs</code></td>
<td>
<p>Numeric 3D array, polynomial coefficients such as calculated by <code><a href="#topic+parr">parr</a></code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>Polynomials are calculated recursively by Cox-de Boor formula. However, it is not applied to
final values but to polynomial coefficients. Multiplication by a linear functions gives
a raise of polynomial degree by 1.<br />
Polynomial coefficients stored in the first dimension of <code>coeffs</code> are used as in
the following formula <code>p[1]*x^n + p[1]*x^(n-1) + ... + p[n+1]</code>. <br />
Resulting matrix is the same as returned by <code>bsc(x, xk, n=dim(coeffs)[1]-1)</code>
</p>


<h3>Value</h3>

<p>Numeric matrix, basis vectors, one per column. Row number is <code>length(x)</code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+bsc">bsc</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  n=3
  x=seq(0, 5, length.out=101)
  xk=c(rep(0, n+1), 1:4, rep(5, n+1))
  # cubic polynomial coefficients
  coeffs=parr(xk)
  # basis matrix
  m=pbsc(x, xk, coeffs)
  matplot(x, m, t="l")
  stopifnot(all.equal.numeric(c(m), c(bsc(x, xk))))
</code></pre>

<hr>
<h2 id='smbsp'>Smoothing B-spline of order n &gt;= 0</h2><span id='topic+smbsp'></span><span id='topic+fitsmbsp'></span>

<h3>Description</h3>

<p>Optimize smoothing B-spline coefficients (smbsp) and knot positions (fitsmbsp)
such that residual squared sum is minimized for all y columns.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>smbsp(
  x,
  y,
  n = 3L,
  xki = NULL,
  nki = 1L,
  lieq = NULL,
  monotone = 0,
  positive = 0,
  mat = NULL,
  estSD = FALSE,
  tol = 1e-10
)

fitsmbsp(
  x,
  y,
  n = 3L,
  xki = NULL,
  nki = 1L,
  lieq = NULL,
  monotone = 0,
  positive = 0,
  control = list(),
  estSD = FALSE,
  tol = 1e-10
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="smbsp_+3A_x">x</code></td>
<td>
<p>Numeric vector, abscissa points</p>
</td></tr>
<tr><td><code id="smbsp_+3A_y">y</code></td>
<td>
<p>Numeric vector or matrix or data.frame, ordinate values to be smoothed
(one set per column in case of matrix or data.frame)</p>
</td></tr>
<tr><td><code id="smbsp_+3A_n">n</code></td>
<td>
<p>Integer scalar, polynomial order of B-splines (3 by default)</p>
</td></tr>
<tr><td><code id="smbsp_+3A_xki">xki</code></td>
<td>
<p>Numeric vector, strictly internal B-spline knots, i.e. lying strictly
inside of <code>x</code> bounds. If NULL (by default), they are
estimated with the help of <code>iknots()</code>. This vector is used as initial approximation
during optimization process. Must be non decreasing if not NULL.</p>
</td></tr>
<tr><td><code id="smbsp_+3A_nki">nki</code></td>
<td>
<p>Integer scalar, internal knot number (1 by default). When
nki==0, it corresponds to polynomial regression. If <code>xki</code>
is not NULL, this parameter is ignored.</p>
</td></tr>
<tr><td><code id="smbsp_+3A_lieq">lieq</code></td>
<td>
<p>List, equality constraints to respect by the smoothing spline,
one list item per y column. By default (NULL), no constraint is imposed.
Constraints are given as a 2-column matrix <code>(xe, ye)</code> where
for each xe, an ye value is imposed. If a list item is NULL, no constraint
is imposed on corresponding y column.</p>
</td></tr>
<tr><td><code id="smbsp_+3A_monotone">monotone</code></td>
<td>
<p>Numeric scalar or vector, if <code>monotone &gt; 0</code>, resulting B-spline
weights must be increasing;
if <code>monotone &lt; 0</code>, B-spline weights must be decreasing; if <code>monotone == 0</code> (default), no
constraint on monotonicity is imposed. If 'monotone' is a vector it
must be of length <code>ncol(y)</code>, in which case each component indicates
the constraint for corresponding column of y.</p>
</td></tr>
<tr><td><code id="smbsp_+3A_positive">positive</code></td>
<td>
<p>Numeric scalar, if <code>positive &gt; 0</code>, resulting B-spline weights
must be &gt;= 0;
if <code>positive &lt; 0</code>, B-spline weights must be decreasing; if <code>positive == 0</code> (default), no
constraint on positivity is imposed. If 'positive' is a vector it
must be of length <code>ncol(y)</code>, in which case each component indicates
the constraint for corresponding column of y.</p>
</td></tr>
<tr><td><code id="smbsp_+3A_mat">mat</code></td>
<td>
<p>Numeric matrix of basis vectors, if NULL it is recalculated
by <code>bsc()</code>. If provided, it is the responsibility of the user
to ensure that this matrix be adequate to xki vector.</p>
</td></tr>
<tr><td><code id="smbsp_+3A_estsd">estSD</code></td>
<td>
<p>Logical scalar, if TRUE, indicates to calculate: SD of each y column, covariance
matrix and SD of spline coefficients. All these values can be retrieved
with bsppar() call (FALSE by default). These estimations are made under assumption
that all y points have uncorrelated noise. Optional constraints are not taken
into account of SD.</p>
</td></tr>
<tr><td><code id="smbsp_+3A_tol">tol</code></td>
<td>
<p>Numerical scalar, relative tolerance for small singular values
that should be considered as 0 if <code>s[i] &lt;= tol*s[1]</code>. This parameter
is ignored if estSD=FALSE (1.e-10 by default).</p>
</td></tr>
<tr><td><code id="smbsp_+3A_control">control</code></td>
<td>
<p>List, passed through to <code>nlsic()</code> call</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If constraints are set, we use <code>nlsic::lsie_ln()</code> to solve a
least squares
problem with equality constraints in least norm sens for each y column.
Otherwise, <code>nlsic::ls_ln_svd()</code> is used for the whole y matrix.
The solution of least squares problem is a vector of B-splines coefficients <code>qw</code>,
one vector per <code>y</code> column. These vectors are used to define B-spline function
which is returned as the result.<br /><br />
NB. When <code>nki &gt;= length(x)-n-1</code> (be it from direct setting or calculated
from <code>length(xki)</code>), it corresponds
to spline interpolation, i.e. the resulting spline will pass
exactly by (x,y) points (well, up to numerical precision).
</p>
<p>Border and external knots are fixed, only strictly internal knots can move
during optimization. The optimization process is constrained to respect a minimal
distance between knots as well as to bound them to x range.
This is done to avoid knots getting unsorted during iterations and/or going
outside of a meaningful range.
</p>


<h3>Value</h3>

<p>Function, smoothing B-splines
respecting optional constraints (generated by <code>par2bsp()</code>).
</p>


<h3>See Also</h3>

<p><code>bsppar</code> for retrieving parameters of B-spline functions; <code>par2bsp</code>
for generating B-spline function; <code>iknots</code> for estimation of knot positions
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  x=seq(0, 1, length.out=11)
  y=sin(pi*x)+rnorm(x, sd=0.1)
  # constraint B-spline to be 0 at the interval ends
  fsm=smbsp(x, y, nki=1, lieq=list(rbind(c(0, 0), c(1, 0))))
  # check parameters of found B-splines
  bsppar(fsm)
  plot(x, y) # original "measurements"
  # fine grained x
  xfine=seq(0, 1, length.out=101)
  lines(xfine, fsm(xfine)) # fitted B-splines
  lines(xfine, sin(pi*xfine), col="blue") # original function
  # visualize knot positions
  xk=bsppar(fsm)$xk
  points(xk, fsm(xk), pch="x", col="red")
 # fit broken line with linear B-splines
 x1=seq(0, 1, length.out=11)
 x2=seq(1, 3, length.out=21)
 x3=seq(3, 4, length.out=11)
 y1=x1+rnorm(x1, sd=0.1)
 y2=-2+3*x2+rnorm(x2, sd=0.1)
 y3=4+x3+rnorm(x3, sd=0.1)
 x=c(x1, x2, x3)
 y=c(y1, y2, y3)
 plot(x, y)
 f=fitsmbsp(x, y, n=1, nki=2)
 lines(x, f(x))
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
