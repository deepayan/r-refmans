<!DOCTYPE html><html lang="en"><head><title>Help for package sdsfun</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {sdsfun}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#+25+26gt+3B+25'><p>Pipe operator</p></a></li>
<li><a href='#check_tbl_na'><p>check for NA values in a tibble</p></a></li>
<li><a href='#discretize_vector'><p>discretization</p></a></li>
<li><a href='#dummy_tbl'><p>transforming a category tibble into the corresponding dummy variable tibble</p></a></li>
<li><a href='#dummy_vec'><p>transforming a categorical variable into dummy variables</p></a></li>
<li><a href='#formula_varname'><p>get variable names in a formula and data</p></a></li>
<li><a href='#fuzzyoverlay'><p>spatial fuzzy overlay</p></a></li>
<li><a href='#generate_subsets'><p>generate subsets of a set</p></a></li>
<li><a href='#geodetector_q'><p>only geodetector q-value</p></a></li>
<li><a href='#hclustgeo_disc'><p>hierarchical clustering with spatial soft constraints</p></a></li>
<li><a href='#inverse_distance_swm'><p>construct inverse distance weight</p></a></li>
<li><a href='#loess_optnum'><p>determine optimal spatial data discretization for individual variables</p></a></li>
<li><a href='#moran_test'><p>test global spatial autocorrelation</p></a></li>
<li><a href='#normalize_vector'><p>normalization</p></a></li>
<li><a href='#rm_lineartrend'><p>remove variable linear trend based on covariate</p></a></li>
<li><a href='#sf_coordinates'><p>extract locations</p></a></li>
<li><a href='#sf_distance_matrix'><p>generates distance matrix</p></a></li>
<li><a href='#sf_geometry_name'><p>sf object geometry column name</p></a></li>
<li><a href='#sf_geometry_type'><p>sf object geometry type</p></a></li>
<li><a href='#sf_gk_proj_cgcs2000'><p>generates cgcs2000 Gauss-Kruger projection epsg coding character</p></a></li>
<li><a href='#sf_utm_proj_wgs84'><p>generates wgs84 utm projection epsg coding character</p></a></li>
<li><a href='#sf_voronoi_diagram'><p>generates voronoi diagram</p></a></li>
<li><a href='#spade_psd'><p>only spade power of spatial determinant</p></a></li>
<li><a href='#spdep_contiguity_swm'><p>constructs spatial weight matrices based on contiguity</p></a></li>
<li><a href='#spdep_distance_swm'><p>constructs spatial weight matrices based on distance</p></a></li>
<li><a href='#spdep_lmtest'><p>spatial linear models selection</p></a></li>
<li><a href='#spdep_nb'><p>construct neighbours list</p></a></li>
<li><a href='#spdep_skater'><p>spatial c(k)luster analysis by tree edge removal</p></a></li>
<li><a href='#spvar'><p>spatial variance</p></a></li>
<li><a href='#ssh_test'><p>test explanatory power of spatial stratified heterogeneity</p></a></li>
<li><a href='#standardize_vector'><p>standardization</p></a></li>
<li><a href='#tbl_all2int'><p>convert discrete variables in a tibble to integers</p></a></li>
<li><a href='#tbl_xyz2mat'><p>convert xyz tbl to matrix</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Title:</td>
<td>Spatial Data Science Complementary Features</td>
</tr>
<tr>
<td>Version:</td>
<td>0.7.0</td>
</tr>
<tr>
<td>Description:</td>
<td>Wrapping and supplementing commonly used functions in the R ecosystem related to spatial data science, 
             while serving as a basis for other packages maintained by Wenbo Lv.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://stscl.github.io/sdsfun/">https://stscl.github.io/sdsfun/</a>, <a href="https://github.com/stscl/sdsfun">https://github.com/stscl/sdsfun</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/stscl/sdsfun/issues">https://github.com/stscl/sdsfun/issues</a></td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.3.2</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 4.1.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>dplyr, geosphere, magrittr, pander, purrr, sf, spdep, stats,
tibble, utils</td>
</tr>
<tr>
<td>Suggests:</td>
<td>ggplot2, Rcpp, RcppArmadillo, testthat (&ge; 3.0.0)</td>
</tr>
<tr>
<td>Config/testthat/edition:</td>
<td>3</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>Rcpp, RcppArmadillo</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2025-01-13 14:32:58 UTC; dell</td>
</tr>
<tr>
<td>Author:</td>
<td>Wenbo Lv <a href="https://orcid.org/0009-0002-6003-3800"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [aut,
    cre, cph]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Wenbo Lv &lt;lyu.geosocial@gmail.com&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2025-01-13 15:10:01 UTC</td>
</tr>
</table>
<hr>
<h2 id='+25+26gt+3B+25'>Pipe operator</h2><span id='topic++25+3E+25'></span>

<h3>Description</h3>

<p>See <code>magrittr::<a href="magrittr.html#topic+pipe">%&gt;%</a></code> for details.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lhs %&gt;% rhs
</code></pre>


<h3>Value</h3>

<p><code>NULL</code> (this is the magrittr pipe operator)
</p>

<hr>
<h2 id='check_tbl_na'>check for NA values in a tibble</h2><span id='topic+check_tbl_na'></span>

<h3>Description</h3>

<p>check for NA values in a tibble
</p>


<h3>Usage</h3>

<pre><code class='language-R'>check_tbl_na(tbl)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="check_tbl_na_+3A_tbl">tbl</code></td>
<td>
<p>A <code>tibble</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>A logical value.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>demotbl = tibble::tibble(x = c(1,2,3,NA,1),
                         y = c(NA,NA,1:3),
                         z = 1:5)
demotbl
check_tbl_na(demotbl)

</code></pre>

<hr>
<h2 id='discretize_vector'>discretization</h2><span id='topic+discretize_vector'></span>

<h3>Description</h3>

<p>discretization
</p>


<h3>Usage</h3>

<pre><code class='language-R'>discretize_vector(
  x,
  n,
  method = "natural",
  breakpoint = NULL,
  sampleprob = 0.15,
  seed = 123456789
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="discretize_vector_+3A_x">x</code></td>
<td>
<p>A continuous numeric vector.</p>
</td></tr>
<tr><td><code id="discretize_vector_+3A_n">n</code></td>
<td>
<p>(optional) The number of discretized classes.</p>
</td></tr>
<tr><td><code id="discretize_vector_+3A_method">method</code></td>
<td>
<p>(optional) The method of discretization, default is <code>natural</code>.</p>
</td></tr>
<tr><td><code id="discretize_vector_+3A_breakpoint">breakpoint</code></td>
<td>
<p>(optional) Break points for manually splitting data. When
<code>method</code> is <code>manual</code>, <code>breakpoint</code> is required.</p>
</td></tr>
<tr><td><code id="discretize_vector_+3A_sampleprob">sampleprob</code></td>
<td>
<p>(optional) When the data size exceeds <code>3000</code>, perform sampling
for discretization, applicable only to natural breaks. Default is <code>0.15</code>.</p>
</td></tr>
<tr><td><code id="discretize_vector_+3A_seed">seed</code></td>
<td>
<p>(optional) Random seed number, default is <code>123456789</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A discretized integer vector
</p>


<h3>Examples</h3>

<pre><code class='language-R'>xvar = c(22361, 9573, 4836, 5309, 10384, 4359, 11016, 4414, 3327, 3408,
         17816, 6909, 6936, 7990, 3758, 3569, 21965, 3605, 2181, 1892,
         2459, 2934, 6399, 8578, 8537, 4840, 12132, 3734, 4372, 9073,
         7508, 5203)
discretize_vector(xvar, n = 5, method = 'natural')

</code></pre>

<hr>
<h2 id='dummy_tbl'>transforming a category tibble into the corresponding dummy variable tibble</h2><span id='topic+dummy_tbl'></span>

<h3>Description</h3>

<p>transforming a category tibble into the corresponding dummy variable tibble
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dummy_tbl(tbl)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="dummy_tbl_+3A_tbl">tbl</code></td>
<td>
<p>A <code>tibble</code> or <code>data.frame</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>tibble</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>a = tibble::tibble(x = 1:3,y = 4:6)
dummy_tbl(a)

</code></pre>

<hr>
<h2 id='dummy_vec'>transforming a categorical variable into dummy variables</h2><span id='topic+dummy_vec'></span>

<h3>Description</h3>

<p>transforming a categorical variable into dummy variables
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dummy_vec(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="dummy_vec_+3A_x">x</code></td>
<td>
<p>An integer vector or can be converted into an integer vector.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>dummy_vec(c(1,1,3,2,4,6))

</code></pre>

<hr>
<h2 id='formula_varname'>get variable names in a formula and data</h2><span id='topic+formula_varname'></span>

<h3>Description</h3>

<p>get variable names in a formula and data
</p>


<h3>Usage</h3>

<pre><code class='language-R'>formula_varname(formula, data)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="formula_varname_+3A_formula">formula</code></td>
<td>
<p>A formula.</p>
</td></tr>
<tr><td><code id="formula_varname_+3A_data">data</code></td>
<td>
<p>A <code>data.frame</code>, <code>tibble</code> or <code>sf</code> object of observation data.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list.
</p>

<dl>
<dt><code>yname</code></dt><dd><p>Independent variable name</p>
</dd>
<dt><code>xname</code></dt><dd><p>Dependent variable names</p>
</dd>
</dl>



<h3>Examples</h3>

<pre><code class='language-R'>gzma = sf::read_sf(system.file('extdata/gzma.gpkg',package = 'sdsfun'))
formula_varname(PS_Score ~ EL_Score + OH_Score, gzma)
formula_varname(PS_Score ~ ., gzma)

</code></pre>

<hr>
<h2 id='fuzzyoverlay'>spatial fuzzy overlay</h2><span id='topic+fuzzyoverlay'></span>

<h3>Description</h3>

<p>spatial fuzzy overlay
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fuzzyoverlay(formula, data, method = "and")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="fuzzyoverlay_+3A_formula">formula</code></td>
<td>
<p>A formula of spatial fuzzy overlay.</p>
</td></tr>
<tr><td><code id="fuzzyoverlay_+3A_data">data</code></td>
<td>
<p>A data.frame or tibble of discretized data.</p>
</td></tr>
<tr><td><code id="fuzzyoverlay_+3A_method">method</code></td>
<td>
<p>(optional) Overlay methods. When <code>method</code> is <code>and</code>, use <code>min</code> to do
fuzzy overlay; and when <code>method</code> is <code>or</code>,use <code>max</code> to do fuzzy overlay. Default is <code>and</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A numeric vector.
</p>


<h3>Note</h3>

<p>Independent variables in the <code>data</code> provided to <code>fuzzyoverlay()</code> must be discretized
variables, and dependent variable are continuous variable.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(42)
sim = tibble::tibble(y = stats::runif(7,0,10),
                     x1 = c(1,rep(2,3),rep(3,3)),
                     x2 = c(rep(1,2),rep(2,2),rep(3,3)))
fo1 = fuzzyoverlay(y~x1+x2,data = sim, method = 'and')
fo1
fo2 = fuzzyoverlay(y~x1+x2,data = sim, method = 'or')
fo2

</code></pre>

<hr>
<h2 id='generate_subsets'>generate subsets of a set</h2><span id='topic+generate_subsets'></span>

<h3>Description</h3>

<p>generate subsets of a set
</p>


<h3>Usage</h3>

<pre><code class='language-R'>generate_subsets(set, empty = TRUE, self = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="generate_subsets_+3A_set">set</code></td>
<td>
<p>A vector.</p>
</td></tr>
<tr><td><code id="generate_subsets_+3A_empty">empty</code></td>
<td>
<p>(optional) When <code>empty</code> is <code>TRUE</code>, the generated subset includes the empty set,
otherwise the empty set is removed. Default is <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="generate_subsets_+3A_self">self</code></td>
<td>
<p>(optional) When <code>self</code> is <code>TRUE</code>, the resulting subset includes the set itself,
otherwise the set itself is removed. Default is <code>TRUE</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>generate_subsets(letters[1:3])
generate_subsets(letters[1:3],empty = FALSE)
generate_subsets(letters[1:3],self = FALSE)
generate_subsets(letters[1:3],empty = FALSE,self = FALSE)

</code></pre>

<hr>
<h2 id='geodetector_q'>only geodetector q-value</h2><span id='topic+geodetector_q'></span>

<h3>Description</h3>

<p>only geodetector q-value
</p>


<h3>Usage</h3>

<pre><code class='language-R'>geodetector_q(y, hs)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="geodetector_q_+3A_y">y</code></td>
<td>
<p>Dependent variable</p>
</td></tr>
<tr><td><code id="geodetector_q_+3A_hs">hs</code></td>
<td>
<p>Independent variable</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A numeric value
</p>


<h3>Examples</h3>

<pre><code class='language-R'>geodetector_q(y = 1:7, hs = c('x',rep('y',3),rep('z',3)))

</code></pre>

<hr>
<h2 id='hclustgeo_disc'>hierarchical clustering with spatial soft constraints</h2><span id='topic+hclustgeo_disc'></span>

<h3>Description</h3>

<p>hierarchical clustering with spatial soft constraints
</p>


<h3>Usage</h3>

<pre><code class='language-R'>hclustgeo_disc(
  data,
  n,
  alpha = 0.5,
  D1 = NULL,
  hclustm = "ward.D2",
  scale = TRUE,
  wt = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="hclustgeo_disc_+3A_data">data</code></td>
<td>
<p>An <code>sf</code> object, <code>tibble</code>, <code>data.frame</code>, <code>matrix</code> or <code>vector</code> of observations data.</p>
</td></tr>
<tr><td><code id="hclustgeo_disc_+3A_n">n</code></td>
<td>
<p>The number of hierarchical clustering classes, which can be a numeric value or vector.</p>
</td></tr>
<tr><td><code id="hclustgeo_disc_+3A_alpha">alpha</code></td>
<td>
<p>(optional) A positive value between <code>0</code> and <code>1</code>. This mixing parameter gives the
relative importance of &quot;feature&quot; space and &quot;constraint&quot; space. Default is <code>0.5</code>.</p>
</td></tr>
<tr><td><code id="hclustgeo_disc_+3A_d1">D1</code></td>
<td>
<p>(optional) A <code>matrix</code> with other dissimilarities between the same observations data. if <code>data</code>
is an <code>sf</code> object and alpha is not <code>0</code>, the <code>D1</code> will be generated by <code>sdsfun::sf_distance_matrix()</code>,
others will use a <code>matrix</code> with all elements equal to <code>0</code>.</p>
</td></tr>
<tr><td><code id="hclustgeo_disc_+3A_hclustm">hclustm</code></td>
<td>
<p>(optional) The agglomeration method to be used, default is <code>ward.D2</code>. For more details,
please see <code>stats::hclust()</code>.</p>
</td></tr>
<tr><td><code id="hclustgeo_disc_+3A_scale">scale</code></td>
<td>
<p>(optional) Whether to scaled the dissimilarities matrix, default is <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="hclustgeo_disc_+3A_wt">wt</code></td>
<td>
<p>(optional) Vector with the weights of the observations. By default, <code>wt</code> is <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="hclustgeo_disc_+3A_...">...</code></td>
<td>
<p>(optional) Other arguments passed to <code>stats::dist()</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The grouped membership: a <code>vector</code> if <code>n</code> is a scalar, a <code>matrix</code> (columns correspond to elements
of <code>n</code>) if not.
</p>


<h3>Note</h3>

<p>This is a <code style="white-space: pre;">&#8288;C++&#8288;</code> enhanced implementation of the <code>hclustgeo</code> function in <code>ClustGeo</code> package.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>gzma = sf::read_sf(system.file('extdata/gzma.gpkg',package = 'sdsfun'))
gzma$group = hclustgeo_disc(gzma,5,alpha = 0.75)
plot(gzma["group"])

</code></pre>

<hr>
<h2 id='inverse_distance_swm'>construct inverse distance weight</h2><span id='topic+inverse_distance_swm'></span>

<h3>Description</h3>

<p>Function for constructing inverse distance weight.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>inverse_distance_swm(sfj, power = 1, bandwidth = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="inverse_distance_swm_+3A_sfj">sfj</code></td>
<td>
<p>Vector object that can be converted to <code>sf</code> by <code>sf::st_as_sf()</code>.</p>
</td></tr>
<tr><td><code id="inverse_distance_swm_+3A_power">power</code></td>
<td>
<p>(optional) Default is 1. Set to 2 for gravity weights.</p>
</td></tr>
<tr><td><code id="inverse_distance_swm_+3A_bandwidth">bandwidth</code></td>
<td>
<p>(optional) When the distance is bigger than bandwidth, the
corresponding part of the weight matrix is set to 0. Default is <code>NULL</code>, which
means not use the bandwidth.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The inverse distance weight formula is
<code class="reqn">w_{ij} = 1 / d_{ij}^\alpha</code>
</p>


<h3>Value</h3>

<p>A inverse distance weight matrices with class of <code>matrix</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(sf)
pts = read_sf(system.file('extdata/pts.gpkg',package = 'sdsfun'))
wt = inverse_distance_swm(pts)
wt[1:5,1:5]

</code></pre>

<hr>
<h2 id='loess_optnum'>determine optimal spatial data discretization for individual variables</h2><span id='topic+loess_optnum'></span>

<h3>Description</h3>

<p>Function for determining optimal spatial data discretization for individual variables
based on locally estimated scatterplot smoothing (LOESS) model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>loess_optnum(qvec, discnumvec, increase_rate = 0.05)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="loess_optnum_+3A_qvec">qvec</code></td>
<td>
<p>A numeric vector of q statistics.</p>
</td></tr>
<tr><td><code id="loess_optnum_+3A_discnumvec">discnumvec</code></td>
<td>
<p>A numeric vector of break numbers corresponding to <code>qvec</code>.</p>
</td></tr>
<tr><td><code id="loess_optnum_+3A_increase_rate">increase_rate</code></td>
<td>
<p>(optional) The critical increase rate of the number of discretization.
Default is <code>0.05</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A two element numeric vector.
</p>

<dl>
<dt><code>discnum</code></dt><dd><p>optimal number of spatial data discretization</p>
</dd>
<dt><code>increase_rate</code></dt><dd><p>the critical increase rate of the number of discretization</p>
</dd>
</dl>



<h3>Note</h3>

<p>When <code>increase_rate</code> is not satisfied by the calculation, the discrete number corresponding
to the highest <code style="white-space: pre;">&#8288;q statistic&#8288;</code> is selected as a return.
</p>
<p>Note that <code>sdsfun</code> sorts <code>discnumvec</code> from smallest to largest and keeps <code>qvec</code> in
one-to-one correspondence with <code>discnumvec</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>qv = c(0.26045642,0.64120405,0.43938704,0.95165535,0.46347836,
       0.25385338,0.78778726,0.95938330,0.83247885,0.09285196)
loess_optnum(qv,3:12)

</code></pre>

<hr>
<h2 id='moran_test'>test global spatial autocorrelation</h2><span id='topic+moran_test'></span>

<h3>Description</h3>

<p>Spatial autocorrelation test based on global moran index.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>moran_test(sfj, wt = NULL, alternative = "greater", symmetrize = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="moran_test_+3A_sfj">sfj</code></td>
<td>
<p>An <code>sf</code> object or can be converted to <code>sf</code> by <code>sf::st_as_sf()</code>.</p>
</td></tr>
<tr><td><code id="moran_test_+3A_wt">wt</code></td>
<td>
<p>(optional) Spatial weight matrix. Must be a <code>matrix</code> class. If <code>wt</code> is not
provided, <code>sdsfun</code> will use a first-order queen adjacency binary matrix.</p>
</td></tr>
<tr><td><code id="moran_test_+3A_alternative">alternative</code></td>
<td>
<p>(optional) Specification of alternative hypothesis as <code>greater</code> (default),
<code>lower</code>, or <code>two.sided</code>.</p>
</td></tr>
<tr><td><code id="moran_test_+3A_symmetrize">symmetrize</code></td>
<td>
<p>(optional) Whether or not to symmetrize the asymmetrical spatial weight matrix
<em><strong>wt</strong></em> by: 1/2 * (<em><strong>wt</strong></em> + <em><strong>wt</strong></em>'). Default is <code>FALSE</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with <code>moran_test</code> class and result stored on the <code>result</code> tibble.
Which contains the following information for each variable:
</p>

<dl>
<dt><code>MoranI</code></dt><dd><p>observed value of the Moran coefficient</p>
</dd>
<dt><code>EI</code></dt><dd><p>expected value of Moran's I</p>
</dd>
<dt><code>VarI</code></dt><dd><p>variance of Moran's I (under normality)</p>
</dd>
<dt><code>ZI</code></dt><dd><p>standardized Moran coefficient</p>
</dd>
<dt><code>PI</code></dt><dd><p><em>p</em>-value of the test statistic</p>
</dd>
</dl>



<h3>Note</h3>

<p>This is a <code style="white-space: pre;">&#8288;C++&#8288;</code> implementation of the <code>MI.vec</code> function in <code>spfilteR</code> package,
and embellishes the console output.
</p>
<p>The return result of this function is actually a <code>list</code>, please access the result
tibble using <code style="white-space: pre;">&#8288;$result&#8288;</code>.
</p>
<p>The non-numeric columns of the attribute columns in <code>sfj</code> are ignored.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>gzma = sf::read_sf(system.file('extdata/gzma.gpkg',package = 'sdsfun'))
moran_test(gzma)

</code></pre>

<hr>
<h2 id='normalize_vector'>normalization</h2><span id='topic+normalize_vector'></span>

<h3>Description</h3>

<p>normalization
</p>


<h3>Usage</h3>

<pre><code class='language-R'>normalize_vector(x, to_left = 0, to_right = 1)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="normalize_vector_+3A_x">x</code></td>
<td>
<p>A continuous numeric vector.</p>
</td></tr>
<tr><td><code id="normalize_vector_+3A_to_left">to_left</code></td>
<td>
<p>(optional) Specified minimum. Default is <code>0</code>.</p>
</td></tr>
<tr><td><code id="normalize_vector_+3A_to_right">to_right</code></td>
<td>
<p>(optional) Specified maximum. Default is <code>1</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A continuous vector which has normalized.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>normalize_vector(c(-5,1,5,0.01,0.99))

</code></pre>

<hr>
<h2 id='rm_lineartrend'>remove variable linear trend based on covariate</h2><span id='topic+rm_lineartrend'></span>

<h3>Description</h3>

<p>remove variable linear trend based on covariate
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rm_lineartrend(formula, data, method = c("cpp", "r"))
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="rm_lineartrend_+3A_formula">formula</code></td>
<td>
<p>A formula.</p>
</td></tr>
<tr><td><code id="rm_lineartrend_+3A_data">data</code></td>
<td>
<p>The observation data.</p>
</td></tr>
<tr><td><code id="rm_lineartrend_+3A_method">method</code></td>
<td>
<p>(optional) The method for using, which can be chosen as either <code>cpp</code>
or <code>r</code>. Default is <code>cpp</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A numeric vector.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>gzma = sf::read_sf(system.file('extdata/gzma.gpkg',package = 'sdsfun'))
rm_lineartrend(PS_Score ~ ., gzma)
rm_lineartrend(PS_Score ~ ., gzma, method = "r")

</code></pre>

<hr>
<h2 id='sf_coordinates'>extract locations</h2><span id='topic+sf_coordinates'></span>

<h3>Description</h3>

<p>Extract locations of sf objects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sf_coordinates(sfj)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="sf_coordinates_+3A_sfj">sfj</code></td>
<td>
<p>An <code>sf</code> object or can be converted to <code>sf</code> by <code>sf::st_as_sf()</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>pts = sf::read_sf(system.file('extdata/pts.gpkg',package = 'sdsfun'))
sf_coordinates(pts)

</code></pre>

<hr>
<h2 id='sf_distance_matrix'>generates distance matrix</h2><span id='topic+sf_distance_matrix'></span>

<h3>Description</h3>

<p>Generates distance matrix for sf object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sf_distance_matrix(sfj)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="sf_distance_matrix_+3A_sfj">sfj</code></td>
<td>
<p>An <code>sf</code> object or can be converted to <code>sf</code> by <code>sf::st_as_sf()</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>pts = sf::read_sf(system.file('extdata/pts.gpkg',package = 'sdsfun'))
pts_distm = sf_distance_matrix(pts)
pts_distm[1:5,1:5]

</code></pre>

<hr>
<h2 id='sf_geometry_name'>sf object geometry column name</h2><span id='topic+sf_geometry_name'></span>

<h3>Description</h3>

<p>Get the geometry column name of an sf object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sf_geometry_name(sfj)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="sf_geometry_name_+3A_sfj">sfj</code></td>
<td>
<p>An <code>sf</code> object.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A character.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>gzma = sf::read_sf(system.file('extdata/gzma.gpkg',package = 'sdsfun'))
sf_geometry_name(gzma)

</code></pre>

<hr>
<h2 id='sf_geometry_type'>sf object geometry type</h2><span id='topic+sf_geometry_type'></span>

<h3>Description</h3>

<p>Get the geometry type of an sf object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sf_geometry_type(sfj)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="sf_geometry_type_+3A_sfj">sfj</code></td>
<td>
<p>An <code>sf</code> object.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A lowercase character vector
</p>


<h3>Examples</h3>

<pre><code class='language-R'>gzma = sf::read_sf(system.file('extdata/gzma.gpkg',package = 'sdsfun'))
sf_geometry_type(gzma)

</code></pre>

<hr>
<h2 id='sf_gk_proj_cgcs2000'>generates cgcs2000 Gauss-Kruger projection epsg coding character</h2><span id='topic+sf_gk_proj_cgcs2000'></span>

<h3>Description</h3>

<p>Generates a Gauss-Kruger projection epsg coding character corresponding to an <code>sfj</code> object
under the CGCS2000 spatial reference.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sf_gk_proj_cgcs2000(sfj, degree = 6L)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="sf_gk_proj_cgcs2000_+3A_sfj">sfj</code></td>
<td>
<p>An <code>sf</code> object or can be converted to <code>sf</code> by <code>sf::st_as_sf()</code>.</p>
</td></tr>
<tr><td><code id="sf_gk_proj_cgcs2000_+3A_degree">degree</code></td>
<td>
<p>(optional) <code>3</code>-degree or <code>6</code>-degree zonal projection, default is <code>6L</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A character.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>gzma = sf::read_sf(system.file('extdata/gzma.gpkg',package = 'sdsfun')) |&gt;
  sf::st_transform(4490)
sf_gk_proj_cgcs2000(gzma,3)
sf_gk_proj_cgcs2000(gzma,6)

</code></pre>

<hr>
<h2 id='sf_utm_proj_wgs84'>generates wgs84 utm projection epsg coding character</h2><span id='topic+sf_utm_proj_wgs84'></span>

<h3>Description</h3>

<p>Generates a utm projection epsg coding character corresponding to an <code>sfj</code> object
under the WGS84 spatial reference.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sf_utm_proj_wgs84(sfj)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="sf_utm_proj_wgs84_+3A_sfj">sfj</code></td>
<td>
<p>An <code>sf</code> object or can be converted to <code>sf</code> by <code>sf::st_as_sf()</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A character.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>gzma = sf::read_sf(system.file('extdata/gzma.gpkg',package = 'sdsfun'))
sf_utm_proj_wgs84(gzma)

</code></pre>

<hr>
<h2 id='sf_voronoi_diagram'>generates voronoi diagram</h2><span id='topic+sf_voronoi_diagram'></span>

<h3>Description</h3>

<p>Generates Voronoi diagram (Thiessen polygons) for sf object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sf_voronoi_diagram(sfj)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="sf_voronoi_diagram_+3A_sfj">sfj</code></td>
<td>
<p>An <code>sf</code> object.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An <code>sf</code> object of polygon geometry type or can be converted to this by <code>sf::st_as_sf()</code>.
</p>


<h3>Note</h3>

<p>Only sf objects of (multi-)point type are supported to generate voronoi diagram
and the returned result includes only the geometry column.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>pts = sf::read_sf(system.file('extdata/pts.gpkg',package = 'sdsfun'))
pts_v = sf_voronoi_diagram(pts)

library(ggplot2)
ggplot() +
  geom_sf(data = pts_v, color = 'red',
          fill = 'transparent') +
  geom_sf(data = pts, color = 'blue', size = 1.25) +
  theme_void()

</code></pre>

<hr>
<h2 id='spade_psd'>only spade power of spatial determinant</h2><span id='topic+spade_psd'></span>

<h3>Description</h3>

<p>only spade power of spatial determinant
</p>


<h3>Usage</h3>

<pre><code class='language-R'>spade_psd(y, hs, wt)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="spade_psd_+3A_y">y</code></td>
<td>
<p>Dependent variable</p>
</td></tr>
<tr><td><code id="spade_psd_+3A_hs">hs</code></td>
<td>
<p>Independent variable</p>
</td></tr>
<tr><td><code id="spade_psd_+3A_wt">wt</code></td>
<td>
<p>Spatial weight matrix</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A numeric value
</p>


<h3>Examples</h3>

<pre><code class='language-R'>gzma = sf::read_sf(system.file('extdata/gzma.gpkg',package = 'sdsfun'))
wt1 = inverse_distance_swm(gzma)
spade_psd(y = gzma$PS_Score,
          hs = discretize_vector(gzma$PS_Score,5),
          wt = wt1)

</code></pre>

<hr>
<h2 id='spdep_contiguity_swm'>constructs spatial weight matrices based on contiguity</h2><span id='topic+spdep_contiguity_swm'></span>

<h3>Description</h3>

<p>Constructs spatial weight matrices based on contiguity via <code>spdep</code> package.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>spdep_contiguity_swm(
  sfj,
  queen = TRUE,
  k = NULL,
  order = 1L,
  cumulate = TRUE,
  style = "W",
  zero.policy = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="spdep_contiguity_swm_+3A_sfj">sfj</code></td>
<td>
<p>An <code>sf</code> object or can be converted to <code>sf</code> by <code>sf::st_as_sf()</code>.</p>
</td></tr>
<tr><td><code id="spdep_contiguity_swm_+3A_queen">queen</code></td>
<td>
<p>(optional) if <code>TRUE</code>, using queen contiguity, otherwise rook contiguity.
Default is <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="spdep_contiguity_swm_+3A_k">k</code></td>
<td>
<p>(optional) The number of nearest neighbours. Ignore this parameter when not
using distance based neighbours to construct spatial weight matrices.</p>
</td></tr>
<tr><td><code id="spdep_contiguity_swm_+3A_order">order</code></td>
<td>
<p>(optional) The order of the adjacency object. Default is <code>1</code>.</p>
</td></tr>
<tr><td><code id="spdep_contiguity_swm_+3A_cumulate">cumulate</code></td>
<td>
<p>(optional) Whether to accumulate adjacency objects. Default is <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="spdep_contiguity_swm_+3A_style">style</code></td>
<td>
<p>(optional) <code>style</code> can take values <code>W</code>, <code>B</code>, <code>C</code>, and <code>S</code>. More to see
<code>spdep::nb2mat()</code>. Default is <code>W</code>.</p>
</td></tr>
<tr><td><code id="spdep_contiguity_swm_+3A_zero.policy">zero.policy</code></td>
<td>
<p>(optional)  if <code>FALSE</code> stop with error for any empty neighbour sets,
if <code>TRUE</code> permit the weights list to be formed with zero-length weights vectors. Default
is <code>TRUE</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix
</p>


<h3>Note</h3>

<p>When <code>k</code> is set to a positive value, using K-Nearest Neighbor Weights.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>gzma = sf::read_sf(system.file('extdata/gzma.gpkg',package = 'sdsfun'))
wt1 = spdep_contiguity_swm(gzma, k = 6, style = 'B')
wt2 = spdep_contiguity_swm(gzma, queen = TRUE, style = 'B')
wt3 = spdep_contiguity_swm(gzma, queen = FALSE, order = 2, style = 'B')

</code></pre>

<hr>
<h2 id='spdep_distance_swm'>constructs spatial weight matrices based on distance</h2><span id='topic+spdep_distance_swm'></span>

<h3>Description</h3>

<p>Constructs spatial weight matrices based on distance via <code>spdep</code> package.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>spdep_distance_swm(
  sfj,
  kernel = NULL,
  k = NULL,
  bandwidth = NULL,
  power = 1,
  style = "W",
  zero.policy = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="spdep_distance_swm_+3A_sfj">sfj</code></td>
<td>
<p>An <code>sf</code> object or can be converted to <code>sf</code> by <code>sf::st_as_sf()</code>.</p>
</td></tr>
<tr><td><code id="spdep_distance_swm_+3A_kernel">kernel</code></td>
<td>
<p>(optional) The kernel function, can be one of <code>uniform</code>,
<code>triangular</code>,<code>quadratic</code>(<code>epanechnikov</code>),<code>quartic</code> and <code>gaussian</code>. Default is <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="spdep_distance_swm_+3A_k">k</code></td>
<td>
<p>(optional) The number of nearest neighbours. Default is <code>NULL</code>. Only useful
when <code>kernel</code> is provided.</p>
</td></tr>
<tr><td><code id="spdep_distance_swm_+3A_bandwidth">bandwidth</code></td>
<td>
<p>(optional) The bandwidth, default is <code>NULL</code>. When the spatial reference
of sf object is the geographical coordinate system, the unit of <code>bandwidth</code> is <code>km</code>. The
unit used in the projection coordinate system are consistent with those used in the sf
object coordinate system.</p>
</td></tr>
<tr><td><code id="spdep_distance_swm_+3A_power">power</code></td>
<td>
<p>(optional) Default is <code>1</code>. Useful when <code>kernel</code> is not provided.</p>
</td></tr>
<tr><td><code id="spdep_distance_swm_+3A_style">style</code></td>
<td>
<p>(optional) <code>style</code> can take values <code>W</code>, <code>B</code>, <code>C</code>, and <code>S</code>. More to see
<code>spdep::nb2mat()</code>. Default is <code>W</code>. For spatial weights based on distance functions,
a style of <code>B</code> means using the original value of the calculated distance function.</p>
</td></tr>
<tr><td><code id="spdep_distance_swm_+3A_zero.policy">zero.policy</code></td>
<td>
<p>(optional)  if <code>FALSE</code> stop with error for any empty neighbour sets,
if <code>TRUE</code> permit the weights list to be formed with zero-length weights vectors. Default
is <code>TRUE</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>five different kernel weight functions:
</p>

<ul>
<li><p> uniform:
<code class="reqn">K_{(z)} = 1/2</code>,for <code class="reqn">\lvert z \rvert &lt; 1</code>
</p>
</li>
<li><p> triangular
<code class="reqn">K_{(z)} = 1 - \lvert z \rvert</code>,for <code class="reqn">\lvert z \rvert &lt; 1</code>
</p>
</li>
<li><p> quadratic (epanechnikov)
<code class="reqn">K_{(z)} = \frac{3}{4} \left( 1 - z^2 \right)</code>,for <code class="reqn">\lvert z \rvert &lt; 1</code>
</p>
</li>
<li><p> quartic
<code class="reqn">K_{(z)} = \frac{15}{16} {\left( 1 - z^2 \right)}^2</code>,for <code class="reqn">\lvert z \rvert &lt; 1</code>
</p>
</li>
<li><p> gaussian
<code class="reqn">K_{(z)} = \frac{1}{\sqrt{2 \pi}} e^{- \frac{z^2}{2}}</code>
</p>
</li></ul>

<p>For the equation above, <code class="reqn">z = d_{ij} / h_i</code>
where <code class="reqn">h_i</code> is the bandwidth
</p>


<h3>Value</h3>

<p>A matrix
</p>


<h3>Note</h3>

<p>When <code>kernel</code> is setting, using distance weight based on kernel function, Otherwise
the inverse distance weight will be used.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>pts = sf::read_sf(system.file('extdata/pts.gpkg',package = 'sdsfun'))
wt1 = spdep_distance_swm(pts, style = 'B')
wt2 = spdep_distance_swm(pts, kernel = 'gaussian')
wt3 = spdep_distance_swm(pts, k = 3, kernel = 'gaussian')
wt4 = spdep_distance_swm(pts, k = 3, kernel = 'gaussian', bandwidth = 10000)

</code></pre>

<hr>
<h2 id='spdep_lmtest'>spatial linear models selection</h2><span id='topic+spdep_lmtest'></span>

<h3>Description</h3>

<p>spatial linear models selection
</p>


<h3>Usage</h3>

<pre><code class='language-R'>spdep_lmtest(formula, data, listw = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="spdep_lmtest_+3A_formula">formula</code></td>
<td>
<p>A formula for linear regression model.</p>
</td></tr>
<tr><td><code id="spdep_lmtest_+3A_data">data</code></td>
<td>
<p>An <code>sf</code> object of observation data.</p>
</td></tr>
<tr><td><code id="spdep_lmtest_+3A_listw">listw</code></td>
<td>
<p>(optional) A listw. See <code>spdep::mat2listw()</code> and <code>spdep::nb2listw()</code>
for details.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list
</p>


<h3>Examples</h3>

<pre><code class='language-R'>gzma = sf::read_sf(system.file('extdata/gzma.gpkg',package = 'sdsfun'))
spdep_lmtest(PS_Score ~ ., gzma)

</code></pre>

<hr>
<h2 id='spdep_nb'>construct neighbours list</h2><span id='topic+spdep_nb'></span>

<h3>Description</h3>

<p>construct neighbours list
</p>


<h3>Usage</h3>

<pre><code class='language-R'>spdep_nb(sfj, queen = TRUE, k = NULL, order = 1L, cumulate = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="spdep_nb_+3A_sfj">sfj</code></td>
<td>
<p>An <code>sf</code> object or can be converted to <code>sf</code> by <code>sf::st_as_sf()</code>.</p>
</td></tr>
<tr><td><code id="spdep_nb_+3A_queen">queen</code></td>
<td>
<p>(optional) if <code>TRUE</code>, using queen contiguity, otherwise rook contiguity.
Default is <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="spdep_nb_+3A_k">k</code></td>
<td>
<p>(optional) The number of nearest neighbours. Ignore this parameter when not
using distance based neighbours.</p>
</td></tr>
<tr><td><code id="spdep_nb_+3A_order">order</code></td>
<td>
<p>(optional) The order of the adjacency object. Default is <code>1</code>.</p>
</td></tr>
<tr><td><code id="spdep_nb_+3A_cumulate">cumulate</code></td>
<td>
<p>(optional) Whether to accumulate adjacency objects. Default is <code>TRUE</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A neighbours list with class <code>nb</code>
</p>


<h3>Note</h3>

<p>When <code>k</code> is set to a positive value, using K-Nearest Neighbor
</p>


<h3>Examples</h3>

<pre><code class='language-R'>pts = sf::read_sf(system.file('extdata/pts.gpkg',package = 'sdsfun'))
nb1 = spdep_nb(pts, k = 6)
nb2 = spdep_nb(pts, queen = TRUE)
nb3 = spdep_nb(pts, queen = FALSE, order = 2)

</code></pre>

<hr>
<h2 id='spdep_skater'>spatial c(k)luster analysis by tree edge removal</h2><span id='topic+spdep_skater'></span>

<h3>Description</h3>

<p>SKATER forms clusters by spatially partitioning data that has similar values for features of interest.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>spdep_skater(sfj, k = 6, nb = NULL, ini = 5, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="spdep_skater_+3A_sfj">sfj</code></td>
<td>
<p>An <code>sf</code> object of observation data. Please ensure that the attribute columns are included
in the SKATER analysis.</p>
</td></tr>
<tr><td><code id="spdep_skater_+3A_k">k</code></td>
<td>
<p>(optional) The number of clusters. Default is <code>6</code>.</p>
</td></tr>
<tr><td><code id="spdep_skater_+3A_nb">nb</code></td>
<td>
<p>(optional) A neighbours list with class nb. If the input <code>nb</code> is NULL, it will be constructed
automatically using <code>spdep_nb()</code>.</p>
</td></tr>
<tr><td><code id="spdep_skater_+3A_ini">ini</code></td>
<td>
<p>(optional) The initial node in the minimal spanning tree. Defaul is <code>5</code>.</p>
</td></tr>
<tr><td><code id="spdep_skater_+3A_...">...</code></td>
<td>
<p>(optional) Other parameters passed to spdep::skater().</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A numeric vector of clusters.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>gzma = sf::read_sf(system.file('extdata/gzma.gpkg',package = 'sdsfun'))
gzma_c = spdep_skater(gzma,8)
gzma$group = gzma_c
plot(gzma["group"])

</code></pre>

<hr>
<h2 id='spvar'>spatial variance</h2><span id='topic+spvar'></span>

<h3>Description</h3>

<p>spatial variance
</p>


<h3>Usage</h3>

<pre><code class='language-R'>spvar(x, wt, method = c("cpp", "r"))
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="spvar_+3A_x">x</code></td>
<td>
<p>A numerical vector .</p>
</td></tr>
<tr><td><code id="spvar_+3A_wt">wt</code></td>
<td>
<p>The spatial weight matrix.</p>
</td></tr>
<tr><td><code id="spvar_+3A_method">method</code></td>
<td>
<p>(optional) The method for calculating spatial variance, which can be chosen as
either <code>cpp</code> or <code>r</code>. Default is <code>cpp</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The spatial variance formula is
<code class="reqn">\Gamma = \frac{\sum_i \sum_{j \neq i} \omega_{ij}\frac{(y_i-y_j)^2}{2}}{\sum_i \sum_{j \neq i} \omega_{ij}}</code>
</p>


<h3>Value</h3>

<p>A numerical value.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>gzma = sf::read_sf(system.file('extdata/gzma.gpkg',package = 'sdsfun'))
wt1 = inverse_distance_swm(gzma)
spvar(gzma$PS_Score,wt1)

</code></pre>

<hr>
<h2 id='ssh_test'>test explanatory power of spatial stratified heterogeneity</h2><span id='topic+ssh_test'></span>

<h3>Description</h3>

<p>Spatial stratified heterogeneity test based on geographical detector q value.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ssh_test(y, hs)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ssh_test_+3A_y">y</code></td>
<td>
<p>Variable Y, continuous numeric vector.</p>
</td></tr>
<tr><td><code id="ssh_test_+3A_hs">hs</code></td>
<td>
<p>Spatial stratification or classification of each explanatory variable.
<code>factor</code>, <code>character</code>, <code>integer</code> or <code>data.frame</code>, <code>tibble</code> and <code>sf</code> object.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>tibble</code>
</p>


<h3>Note</h3>

<p>This is a <code style="white-space: pre;">&#8288;C++&#8288;</code> implementation of the <code>factor_detector</code> function in <code>gdverse</code> package.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>ssh_test(y = 1:7, hs = c('x',rep('y',3),rep('z',3)))

</code></pre>

<hr>
<h2 id='standardize_vector'>standardization</h2><span id='topic+standardize_vector'></span>

<h3>Description</h3>

<p>To calculate the Z-score using variance normalization, the formula is as follows:
</p>
<p><code class="reqn">Z = \frac{(x - mean(x))}{sd(x)}</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>standardize_vector(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="standardize_vector_+3A_x">x</code></td>
<td>
<p>A numeric vector</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A standardized numeric vector
</p>


<h3>Examples</h3>

<pre><code class='language-R'>standardize_vector(1:10)

</code></pre>

<hr>
<h2 id='tbl_all2int'>convert discrete variables in a tibble to integers</h2><span id='topic+tbl_all2int'></span>

<h3>Description</h3>

<p>convert discrete variables in a tibble to integers
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tbl_all2int(tbl)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="tbl_all2int_+3A_tbl">tbl</code></td>
<td>
<p>A <code>tibble</code>,<code>data.frame</code> or <code>sf</code> object.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A converted <code>tibble</code>,<code>data.frame</code> or <code>sf</code> object.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>demotbl = tibble::tibble(x = c(1,2,3,3,1),
                         y = letters[1:5],
                         z = c(1L,1L,2L,2L,3L),
                         m = factor(letters[1:5],levels = letters[5:1]))
tbl_all2int(demotbl)

</code></pre>

<hr>
<h2 id='tbl_xyz2mat'>convert xyz tbl to matrix</h2><span id='topic+tbl_xyz2mat'></span>

<h3>Description</h3>

<p>convert xyz tbl to matrix
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tbl_xyz2mat(tbl, x = 1, y = 2, z = 3)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="tbl_xyz2mat_+3A_tbl">tbl</code></td>
<td>
<p>A <code>tibble</code>,<code>data.frame</code> or <code>sf</code> object.</p>
</td></tr>
<tr><td><code id="tbl_xyz2mat_+3A_x">x</code></td>
<td>
<p>(optional) The x-axis coordinates column number, default is <code>1</code>.</p>
</td></tr>
<tr><td><code id="tbl_xyz2mat_+3A_y">y</code></td>
<td>
<p>(optional) The y-axis coordinates column number, default is <code>2</code>.</p>
</td></tr>
<tr><td><code id="tbl_xyz2mat_+3A_z">z</code></td>
<td>
<p>(optional) The z (attribute) coordinates column number, default is <code>3</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>list</code>.
</p>

<dl>
<dt>z_attrs_matrix</dt><dd><p>A matrix with attribute information.</p>
</dd>
<dt>x_coords_matrix</dt><dd><p>A matrix with the x-axis coordinates.</p>
</dd>
<dt>y_coords_matrix</dt><dd><p>A matrix with the y-axis coordinates.</p>
</dd>
</dl>



<h3>Examples</h3>

<pre><code class='language-R'>set.seed(42)
lon = rep(1:3,each = 3)
lat = rep(1:3,times = 3)
zattr = rnorm(9, mean = 10, sd = 1)
demodf = data.frame(x = lon, y = lat, z = zattr)
demodf
tbl_xyz2mat(demodf)

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
