<!DOCTYPE html><html><head><title>Help for package Rfssa</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {Rfssa}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#-.funts'><p>Subtract 'funts' Objects or a 'funts' Object and a Scalar</p></a></li>
<li><a href='#[.funts'><p>Indexing into Functional Time Series</p></a></li>
<li><a href='#*.funts'><p>Scalar Multiplication of Functional Time Series (funts)</p></a></li>
<li><a href='#+.funts'><p>Addition of Functional Time Series</p></a></li>
<li><a href='#as.funts'><p>Convert Object to a funts</p></a></li>
<li><a href='#Callcenter'><p>Callcenter Dataset: Number of Calls for a Bank</p></a></li>
<li><a href='#eval.funts'><p>Evaluate a Functional Time Series (funts) Object on a Given Grid</p></a></li>
<li><a href='#fforecast'><p>Functional Singular Spectrum Analysis Recurrent and Vector Forecasting</p></a></li>
<li><a href='#fpredinterval'><p>FSSA Forecasting Bootstrap Prediction Interval</p></a></li>
<li><a href='#freconstruct'><p>Reconstruction Stage of Functional Singular Spectrum Analysis</p></a></li>
<li><a href='#fssa'><p>Functional Singular Spectrum Analysis (FSSA)</p></a></li>
<li><a href='#funts'><p>Functional Time Series (funts) Class</p></a></li>
<li><a href='#is.funts'><p>Check if an object is of class 'funts'</p></a></li>
<li><a href='#launchApp'><p>Launch Shiny Application for FSSA Demonstration</p></a></li>
<li><a href='#length.funts'><p>Length of Functional Time Series</p></a></li>
<li><a href='#loadAustinData'><p>Load Austin Temperature Data from GitHub Repository</p></a></li>
<li><a href='#loadCallcenterData'><p>Load Callcenter Data from GitHub Repository</p></a></li>
<li><a href='#loadJambiData'><p>Load Jambi MODIS Data from GitHub Repository</p></a></li>
<li><a href='#loadMontanaData'><p>Load Montana Data from GitHub Repository</p></a></li>
<li><a href='#loadUtqiagvikData'><p>Load Utqiagvik Temperature Data from GitHub Repository</p></a></li>
<li><a href='#Montana'><p>Montana Intraday Temperature Curves and NDVI Images Data Set</p></a></li>
<li><a href='#plot.fforecast'><p>Plot Method for FSSA Forecast (fforecast) Class</p></a></li>
<li><a href='#plot.fssa'><p>Plot Functional Singular Spectrum Analysis Objects</p></a></li>
<li><a href='#plot.funts'><p>Plot Functional Time Series (funts) Data</p></a></li>
<li><a href='#plotly_funts'><p>Plot Functional Time Series (funts) with Plotly</p></a></li>
<li><a href='#print.fforecast'><p>Custom Print Method for FSSA Forecast (fforecast) class</p></a></li>
<li><a href='#print.funts'><p>Custom Print Method for Functional Time Series (funts) Objects</p></a></li>
<li><a href='#Rfssa-package'><p>Rfssa: A Package for Functional Singular Spectrum Analysis and Related Methods.</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Functional Singular Spectrum Analysis</td>
</tr>
<tr>
<td>Version:</td>
<td>3.1.0</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Hossein Haghbin &lt;haghbin@pgu.ac.ir&gt;</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/haghbinh/Rfssa">https://github.com/haghbinh/Rfssa</a></td>
</tr>
<tr>
<td>Description:</td>
<td>Methods and tools for implementing functional singular spectrum analysis and related techniques.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>LazyLoad:</td>
<td>true</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>Imports:</td>
<td>Rcpp, fda, lattice, plotly, shiny, Rssa, ggplot2, tibble,
RSpectra, rainbow, ftsa, dplyr, markdown</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>Rcpp, RcppArmadillo, RcppEigen,</td>
</tr>
<tr>
<td>Suggests:</td>
<td>knitr</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 4.0.0)</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-01-10 16:36:07 UTC; Hossein</td>
</tr>
<tr>
<td>Author:</td>
<td>Hossein Haghbin <a href="https://orcid.org/0000-0001-8416-2354"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cre],
  Jordan Trinka [aut],
  Seyed Morteza Najibi [aut],
  Mehdi Maadooliat <a href="https://orcid.org/0000-0002-5408-2676"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut]</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-01-10 17:13:12 UTC</td>
</tr>
</table>
<hr>
<h2 id='-.funts'>Subtract 'funts' Objects or a 'funts' Object and a Scalar</h2><span id='topic+-.funts'></span>

<h3>Description</h3>

<p>This function allows subtraction between two 'funts' (functional time series) objects or
between a 'funts' object and a scalar. It returns the resulting difference.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'funts'
obj1 - obj2 = NULL
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="-.funts_+3A_obj1">obj1</code></td>
<td>
<p>an object of class 'funts', representing the first 'funts' object.</p>
</td></tr>
<tr><td><code id="-.funts_+3A_obj2">obj2</code></td>
<td>
<p>an object of class 'funts' or a scalar.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+funts">funts</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
data("Callcenter")
y &lt;- Callcenter
print(1 - y)

## End(Not run)
</code></pre>

<hr>
<h2 id='+5B.funts'>Indexing into Functional Time Series</h2><span id='topic++5B.funts'></span>

<h3>Description</h3>

<p>An indexing method for functional time series (<code><a href="#topic+funts">funts</a></code>) objects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'funts'
obj[i = NULL, j = NULL]
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="+2B5B.funts_+3A_obj">obj</code></td>
<td>
<p>an object of class <code><a href="#topic+funts">funts</a></code>.</p>
</td></tr>
<tr><td><code id="+2B5B.funts_+3A_i">i</code></td>
<td>
<p>an index or indices specifying the subsets of times to extract.</p>
</td></tr>
<tr><td><code id="+2B5B.funts_+3A_j">j</code></td>
<td>
<p>an index or indices specifying the subsets of variables to extract.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function allows you to extract specific subsets of a functional time series
based on the provided indices. You can specify which subsets you want to extract
from the functional time series.
</p>


<h3>Value</h3>

<p>an 'funts' object containing the specified subsets
</p>


<h3>See Also</h3>

<p><code><a href="#topic+funts">funts</a></code>
</p>

<hr>
<h2 id='+2A.funts'>Scalar Multiplication of Functional Time Series (funts)</h2><span id='topic++2A.funts'></span>

<h3>Description</h3>

<p>Perform scalar multiplication of a Functional Time Series (funts) object by either another funts object or a scalar value.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'funts'
obj1 * obj2
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="+2B2A.funts_+3A_obj1">obj1</code></td>
<td>
<p>an object of class <code><a href="#topic+funts">funts</a></code> or a scalar value.</p>
</td></tr>
<tr><td><code id="+2B2A.funts_+3A_obj2">obj2</code></td>
<td>
<p>an object of class <code><a href="#topic+funts">funts</a></code> or a scalar value.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function allows element-wise multiplication of a Functional Time Series (funts) object by another funts object or scalar value.
</p>


<h3>Value</h3>

<p>An object of class <code><a href="#topic+funts">funts</a></code> representing the result of scalar multiplication.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+funts">funts</a></code>
</p>

<hr>
<h2 id='+2B.funts'>Addition of Functional Time Series</h2><span id='topic++2B.funts'></span>

<h3>Description</h3>

<p>A method for functional time series (<code><a href="#topic+funts">funts</a></code>) addition and funts-scalar addition.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'funts'
obj1 + obj2 = NULL
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="+2B2B.funts_+3A_obj1">obj1</code></td>
<td>
<p>an object of class <code><a href="#topic+funts">funts</a></code> or numeric.</p>
</td></tr>
<tr><td><code id="+2B2B.funts_+3A_obj2">obj2</code></td>
<td>
<p>an object of class <code><a href="#topic+funts">funts</a></code> or numeric.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an object of class <code><a href="#topic+funts">funts</a></code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+funts">funts</a></code>
</p>

<hr>
<h2 id='as.funts'>Convert Object to a funts</h2><span id='topic+as.funts'></span>

<h3>Description</h3>

<p>This function allows you to convert various types of objects into a functional time series (<code><a href="#topic+funts">funts</a></code>) object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>as.funts(obj, basis = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="as.funts_+3A_obj">obj</code></td>
<td>
<p>the object to be converted. It can be an object of class <code><a href="fda.html#topic+fd">fd</a></code> (functional data) of the package 'fda', <code><a href="rainbow.html#topic+fts">fts</a></code> (functional time series) of the package 'rainbow' types.</p>
</td></tr>
<tr><td><code id="as.funts_+3A_basis">basis</code></td>
<td>
<p>an optional argument specifying the basis to be used for the resulting <code><a href="#topic+funts">funts</a></code> object when converting from <code><a href="rainbow.html#topic+fts">fts</a></code> objects. If not provided, a B-spline basis will be created by default.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <code><a href="#topic+funts">funts</a></code>.
</p>


<h3>Note</h3>

<p>Only objects of class <code><a href="fda.html#topic+fd">fd</a></code> (functional data) and <code><a href="rainbow.html#topic+fts">fts</a></code> (functional time series) can be converted to a <code><a href="#topic+funts">funts</a></code> object. Other types will result in an error.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+funts">funts</a></code>, <code><a href="fda.html#topic+create.bspline.basis">create.bspline.basis</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>require(rainbow)
class(Australiasmoothfertility)
x_funts1 &lt;- as.funts(Australiasmoothfertility)
plot(x_funts1, main = "Australians Fertility")

require(fda)
bs &lt;- create.bspline.basis(rangeval = c(15, 49), nbasis = 13)
fd_obj &lt;- smooth.basis(argvals = Australiasmoothfertility$x, Australiasmoothfertility$y, bs)$fd

x_funts &lt;- as.funts(fd_obj)
plotly_funts(x_funts,
  main = "Australians Fertility",
  ylab = "Fertility rate",
  xlab = "Age"
)
</code></pre>

<hr>
<h2 id='Callcenter'>Callcenter Dataset: Number of Calls for a Bank</h2><span id='topic+Callcenter'></span>

<h3>Description</h3>

<p>This dataset represents a small call center for an anonymous bank (Brown et al., 2005).
It provides detailed information about the exact times of calls that were connected
to the center throughout the year 1999, from January 1 to December 31.
</p>


<h3>Format</h3>

<p>A functional time series object of class 'funts' with the following fields:
</p>

<dl>
<dt>time</dt><dd><p>the time index indicating when the calls occurred.</p>
</dd>
<dt>coefs</dt><dd><p>the coefficients corresponding to the B-spline basis functions.</p>
</dd>
<dt>basisobj</dt><dd><p>the basis functions used for the functional representation.</p>
</dd>
<dt>dimSupp</dt><dd><p>the dimension support of the functional data.</p>
</dd>
</dl>



<h3>Details</h3>

<p>The data have been converted into a functional time series using a B-spline basis
system with 22 basis functions. The resulting dataset is stored as a functional time
series object of class 'funts'. You can load the raw data using the function
<code><a href="#topic+loadCallcenterData">loadCallcenterData</a></code>. See <code><a href="#topic+funts">funts</a></code> for more details.
</p>


<h3>References</h3>


<ol>
<li>
<p>Brown, L., Gans, N., Mandelbaum, A., Sakov, A., Shen, H., Zeltyn, S., &amp; Zhao, L. (2005).
Statistical analysis of a telephone call center: A queueing-science perspective.
<em>Journal of the American Statistical Association</em>, <strong>100</strong>(469), 36-50.
</p>
</li></ol>



<h3>See Also</h3>

<p><code><a href="#topic+loadCallcenterData">loadCallcenterData</a></code>, <code><a href="#topic+funts">funts</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# Load the Callcenter dataset
data("Callcenter")

## End(Not run)
</code></pre>

<hr>
<h2 id='eval.funts'>Evaluate a Functional Time Series (funts) Object on a Given Grid</h2><span id='topic+eval.funts'></span>

<h3>Description</h3>

<p>This function allows you to evaluate a Functional Time Series (funts) object
on a specified grid of argument values. The result is a list of matrices, each
matrix corresponding to one dimension of the functional data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>eval.funts(argvals, obj)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="eval.funts_+3A_argvals">argvals</code></td>
<td>
<p>a list or numeric vector specifying the grid points at which
to evaluate the functional time series. For multivariate functional data,
provide a list of grids corresponding to each dimension.</p>
</td></tr>
<tr><td><code id="eval.funts_+3A_obj">obj</code></td>
<td>
<p>an object of class <code><a href="#topic+funts">funts</a></code> to be evaluated.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>argvals</code> argument can be a list of grids for multivariate functional data.
The function handles both functional basis and empirical basis cases for evaluation.
For empirical basis with irregular grids, a warning is issued as this feature
is under development.
</p>


<h3>Value</h3>

<p>A list of matrices, where each matrix represents the evaluated values
of the functional data on the specified grid.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+funts">funts</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("Montana")
y &lt;- Montana
u &lt;- seq(0, 23, len = 4)
v &lt;- seq(1, 33, len = 3)
grid &lt;- list(u, list(v, v))
eval.funts(grid, y)
</code></pre>

<hr>
<h2 id='fforecast'>Functional Singular Spectrum Analysis Recurrent and Vector Forecasting</h2><span id='topic+fforecast'></span>

<h3>Description</h3>

<p>Perform functional singular spectrum analysis (FSSA) recurrent forecasting
(FSSA R-forecasting) or vector forecasting (FSSA V-forecasting) on univariate
or multivariate functional time series (<code><a href="#topic+funts">funts</a></code>) observed over a
one-dimensional domain.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fforecast(
  U,
  groups = as.list(1L:10L),
  len = 1,
  method = "recurrent",
  only.new = TRUE,
  tol = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fforecast_+3A_u">U</code></td>
<td>
<p>an object of class <code><a href="#topic+fssa">fssa</a></code> holding the decomposition.</p>
</td></tr>
<tr><td><code id="fforecast_+3A_groups">groups</code></td>
<td>
<p>a list of numeric vectors where each vector includes indices
of elementary components of a group used for reconstruction and
forecasting.</p>
</td></tr>
<tr><td><code id="fforecast_+3A_len">len</code></td>
<td>
<p>integer, the desired length of the forecasted FTS.</p>
</td></tr>
<tr><td><code id="fforecast_+3A_method">method</code></td>
<td>
<p>a character string specifying the type of forecasting to perform:
- &quot;recurrent&quot; for FSSA R-forecasting.
- &quot;vector&quot; for FSSA V-forecasting.</p>
</td></tr>
<tr><td><code id="fforecast_+3A_only.new">only.new</code></td>
<td>
<p>logical, if 'TRUE' then only forecasted FTS are returned, whole FTS otherwise.</p>
</td></tr>
<tr><td><code id="fforecast_+3A_tol">tol</code></td>
<td>
<p>a double specifying the tolerated error in the approximation of
the matrix used in forecasting algorithms.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class 'fforecast' which is a list of objects of class
<code><a href="#topic+funts">funts</a></code>, where each one corresponds to a forecasted group.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
data("Callcenter")
U &lt;- fssa(Callcenter, L = 28)
groups &lt;- list(1, 1:7)

## Perform FSSA R-forecast
pr_R &lt;- fforecast(
  U = U, groups = groups, only.new = FALSE,
  len = 30, method = "recurrent"
)

plot(pr_R,  group_index = 1 )


plotly_funts(pr_R[[2]], main = "group = '1:7'")

## Perform FSSA V-forecast
pr_V &lt;- fforecast(U = U, groups = groups, len= 30, method = "vector")

plot(pr_V, group_index = 1)

plotly_funts(pr_V[[2]], type = "3Dline" , main = "group = '1:7'")

# Multivariate forecasting example:
data("Montana")
time &lt;- Montana$time
grid &lt;- list(0:23, list(1:33, 1:33))
montana &lt;- eval.funts(Montana, argvals = grid)
montana[[2]] &lt;- array(
  scale(montana[[2]][, , ],
    center = min(montana[[2]][, , ]),
    scale = max(montana[[2]][, , ]) - min(montana[[2]][, , ])
  ),
  dim = c(33, 33, 133)
)
## Kernel density estimation of pixel intensity
NDVI &lt;- matrix(NA, nrow = 512, ncol = 133)
for (i in 1:133) NDVI[, i] &lt;- (density(montana[[2]][, , i], from = 0, to = 1)$y)

## Define functional objects
bs1 &lt;- Montana$basis[[1]]

require(fda)
bs2 &lt;- create.bspline.basis(nbasis = 15)
Y &lt;- funts(X = list(montana[[1]], NDVI), basisobj = list(bs1, bs2),
            vnames = c("Temperature", "NDVI Density"),
            dnames = c("Time", "NDVI"),
            tname = "Date")

plotly_funts(Y,
  main = c("Temperature", "NDVI"),
  xticklocs = list(c(0, 6, 12, 18, 23), seq(1, 512, len = 9)),
  xticklabels = list(c(0, 6, 12, 18, 23), seq(0, 1, len = 9))
)

U &lt;- fssa(Y = Y, L = 45)
plotly_funts(U$Lsingf[[1]])
plot(U$Lsingf[[2]])

groups &lt;- list(1, 1:3)
pr_R &lt;- fforecast(U = U, groups = groups,
                   only.new = FALSE, len = 10, method = "recurrent")
plot(pr_R)
plotly_funts(pr_R[[2]], main = "Recurrent method, group = '1:3'")

pr_V &lt;- fforecast(U = U, groups = groups, len = 10, method = "vector")
plot(pr_V, group_index = 1)
plotly_funts(pr_V[[2]], main = "Vector method, group = '1:3'")

## End(Not run)

</code></pre>

<hr>
<h2 id='fpredinterval'>FSSA Forecasting Bootstrap Prediction Interval</h2><span id='topic+fpredinterval'></span>

<h3>Description</h3>

<p>Calculate the bootstrap prediction interval for functional singular
spectrum analysis (FSSA) forecasting predictions of univariate functional
time series (<code><a href="#topic+funts">funts</a></code>) observed over a one-dimensional domain.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fpredinterval(
  Y,
  O = floor(Y$N * 0.7),
  L = floor((Y$N * 0.7)/12),
  ntriples = 10,
  Bt = 100,
  h = 1,
  alpha = 0.05,
  method = "recurrent",
  tol = 10^-3
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fpredinterval_+3A_y">Y</code></td>
<td>
<p>an object of class <code><a href="#topic+funts">funts</a></code>.</p>
</td></tr>
<tr><td><code id="fpredinterval_+3A_o">O</code></td>
<td>
<p>a positive integer specifying the training set size.</p>
</td></tr>
<tr><td><code id="fpredinterval_+3A_l">L</code></td>
<td>
<p>a positive integer specifying the window length.</p>
</td></tr>
<tr><td><code id="fpredinterval_+3A_ntriples">ntriples</code></td>
<td>
<p>the number of eigentriples to use for forecasts.</p>
</td></tr>
<tr><td><code id="fpredinterval_+3A_bt">Bt</code></td>
<td>
<p>a positive integer specifying the number of bootstrap samples.</p>
</td></tr>
<tr><td><code id="fpredinterval_+3A_h">h</code></td>
<td>
<p>an integer specifying the forecast horizon.</p>
</td></tr>
<tr><td><code id="fpredinterval_+3A_alpha">alpha</code></td>
<td>
<p>a double (0 &lt; alpha &lt; 1) specifying the significance level.</p>
</td></tr>
<tr><td><code id="fpredinterval_+3A_method">method</code></td>
<td>
<p>a character string: &quot;recurrent&quot; or &quot;vector&quot; forecasting.</p>
</td></tr>
<tr><td><code id="fpredinterval_+3A_tol">tol</code></td>
<td>
<p>a double specifying tolerated error in the approximation.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list of numeric vectors: point forecast, lower, and upper bounds.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
data("Callcenter")
pred_interval &lt;- fpredinterval(
  Y = Callcenter, O = 310,
  L = 28, ntriples = 7, Bt = 10000, h = 3
)

# Plot the forecast and prediction interval using ggplot
df &lt;- data.frame(
  x = 1:240,
  y = pred_interval$forecast,
  lower = pred_interval$lower,
  upper = pred_interval$upper
)
require(ggplot2)
# Create the ggplot
ggplot(df, aes(x = x, y = y)) +
  geom_line(linewidth = 1.2) +
  scale_x_continuous(
    name = "Time",
    breaks = c(1, 60, 120, 180, 240),
    labels = c("00:00", "06:00", "12:00", "18:00", "24:00"),
  ) +
  scale_y_continuous(name = "Sqrt of Call Numbers") +
  ggtitle("Prediction Intervals for Jan. 3, 2000") +
  geom_ribbon(aes(ymin = lower, ymax = upper), fill = "darkolivegreen3", alpha = 0.3) +
  theme_minimal()

## End(Not run)

</code></pre>

<hr>
<h2 id='freconstruct'>Reconstruction Stage of Functional Singular Spectrum Analysis</h2><span id='topic+freconstruct'></span>

<h3>Description</h3>

<p>Reconstruct univariate or multivariate functional time series
(<code><a href="#topic+funts">funts</a></code>) objects from functional singular spectrum analysis
(<code><a href="#topic+fssa">fssa</a></code>) objects, including Grouping and Hankelization steps.
This function performs the reconstruction step for either univariate
functional singular spectrum analysis (ufssa) or multivariate
functional singular spectrum analysis (mfssa), depending on the input.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>freconstruct(U, groups = as.list(1L:10L))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="freconstruct_+3A_u">U</code></td>
<td>
<p>an object of class <code><a href="#topic+fssa">fssa</a></code>.</p>
</td></tr>
<tr><td><code id="freconstruct_+3A_groups">groups</code></td>
<td>
<p>a list of numeric vectors, each vector includes indices
of elementary components of a group used for reconstruction.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A named list of objects of class <code><a href="#topic+funts">funts</a></code> that are
reconstructed according to the specified groups and a numeric vector
of eigenvalues.
</p>


<h3>Note</h3>

<p>Refer to <code><a href="#topic+fssa">fssa</a></code> for an example on how to run this
function starting from <code><a href="#topic+fssa">fssa</a></code> objects.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+fssa">fssa</a></code>, <code><a href="#topic+funts">funts</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data("Callcenter")
L &lt;- 28
U &lt;- fssa(Callcenter, L)

# FSSA Reconstruction step:
gr &lt;- list(1, 2:3, 4:5, 6:7, 1:7)
Q &lt;- freconstruct(U, gr)
plot(Q[[1]],
  main = "Call Center Mean Component")
plot(Q[[2]],
  main = "Call Center First Periodic Component")

#--------------- Multivariate FSSA Example on bivariate -----------------------------
## temperature curves and smoothed images of vegetation
## Not run: 
data("Montana")
L &lt;- 45
U &lt;- fssa(Montana, L)

# MFSSA Reconstruction step:
Q &lt;- freconstruct(U = U, groups = list(1, 2, 3))
plotly_funts(Q[[1]],
  main = c("Temperature Curves Mean", "NDVI Images Mean"),
  color_palette = "RdYlGn",
  xticklabels = list(
    c("00:00", "06:00", "12:00", "18:00", "24:00"),
    c("113.40\u00B0 W", "113.30\u00B0 W")
  ),
  xticklocs = list(c(1, 6, 12, 18, 24), c(1, 33)),
  yticklabels = list(NA, c("48.70\u00B0 N", "48.77\u00B0 N")),
  yticklocs = list(NA, c(1, 33))
) # mean

plotly_funts(Q[[2]],
  main = c("Temperature Curves Periodic", "NDVI Images Periodic"),
  color_palette = "RdYlGn",
  xticklabels = list(
    c("00:00", "06:00", "12:00", "18:00", "24:00"),
    c("113.40\u00B0 W", "113.30\u00B0 W")
  ),
  xticklocs = list(c(1, 6, 12, 18, 24), c(1, 33)),
  yticklabels = list(NA, c("48.70\u00B0 N", "48.77\u00B0 N")),
  yticklocs = list(NA, c(1, 33))
) # periodic

plot(Q[[3]],
  obs = 3,
  main = c("Temperature Curves Trend", "NDVI Images Trend,")
) # trend

## End(Not run)

</code></pre>

<hr>
<h2 id='fssa'>Functional Singular Spectrum Analysis (FSSA)</h2><span id='topic+fssa'></span>

<h3>Description</h3>

<p>This function performs the decomposition (embedding and functional SVD steps)
for univariate (ufssa) or multivariate (mfssa) functional singular spectrum
analysis based on the input data type. The input can be a univariate or
multivariate functional time series (<code><a href="#topic+funts">funts</a></code>) object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fssa(Y, L = Y$N/2, ntriples = 20, type = "ufssa")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fssa_+3A_y">Y</code></td>
<td>
<p>an object of class <code><a href="#topic+funts">funts</a></code>.</p>
</td></tr>
<tr><td><code id="fssa_+3A_l">L</code></td>
<td>
<p>a positive integer, the window length, the default is half of FTS length.</p>
</td></tr>
<tr><td><code id="fssa_+3A_ntriples">ntriples</code></td>
<td>
<p>a positive integer, the number of eigentriples for the
decomposition.</p>
</td></tr>
<tr><td><code id="fssa_+3A_type">type</code></td>
<td>
<p>a string indicating the type of FSSA: &quot;ufssa&quot; (default for
univariate FTS) or &quot;mfssa&quot; (default for multivariate FTS).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <code>fssa</code>, containing functional objects,
eigenvalues, window length, and original data.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("Callcenter")

# FSSA Decomposition step:
L &lt;- 28
U &lt;- fssa(Callcenter, L)
plot(U, type = "values", d = 10)
plot(U, type = "vectors", d = 4)
plot(U, type = "paired", d = 6)
plot(U, type = "lcurves", d = 4, vars = 1)
plot(U, type = "lheats", d = 4)
plot(U, type = "wcor", d = 10)
plotly_funts(U$Lsingf[[1]])
plot(U$Lsingf[[2]])

## Not run: 
#--------------- Multivariate FSSA Example on bivariate -----------------------------
## temperature curves and smoothed images of vegetation
data("Montana")

# MFSSA Decomposition step:
L &lt;- 45
U &lt;- fssa(Montana, L)
plot(U, type = "values", d = 10)
plot(U, type = "vectors", d = 4)
plot(U, type = "lheats", d = 4)
plot(U, type = "lcurves", d = 4, vars = 1)
plot(U, type = "paired", d = 6)
plot(U, type = "periodogram", d = 4)
plot(U, type = "wcor", d = 10)
plotly_funts(U$Lsingf[[1]])
plot(U$Lsingf[[2]])


## End(Not run)
</code></pre>

<hr>
<h2 id='funts'>Functional Time Series (funts) Class</h2><span id='topic+funts'></span>

<h3>Description</h3>

<p>The 'funts' class is designed to encapsulate functional time series objects, including both univariate (FTS) and multivariate (MFTS) forms.
It provides a versatile framework for creating and manipulating 'funts' objects, accommodating various basis systems and dimensions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>funts(
  X,
  basisobj,
  argval = NULL,
  method = "data",
  start = 1,
  end = NULL,
  vnames = NULL,
  dnames = NULL,
  tname = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="funts_+3A_x">X</code></td>
<td>
<p>A matrix, three-dimensional array, or a list of matrix or array objects.
When 'method=&quot;data&quot;', it represents the observed curve values at discrete
sampling points or argument values. When 'method=&quot;coefs&quot;', 'X' specifies the coefficients
corresponding to the basis system defined in 'basisobj'. If 'X' is a list, it defines a multivariate FTS,
with each element being a matrix or three-dimensional array object. In matrix objects, rows correspond to argument values,
and columns correspond to the length of the FTS. In three-dimensional array objects, the first and second dimensions correspond
to argument values, and the third dimension to the length of the FTS.</p>
</td></tr>
<tr><td><code id="funts_+3A_basisobj">basisobj</code></td>
<td>
<p>An object of class 'basisfd', a matrix of empirical basis, or a list of 'basisfd' or empirical basis objects.
For empirical basis, rows correspond to basis functions, and columns correspond to grid points.</p>
</td></tr>
<tr><td><code id="funts_+3A_argval">argval</code></td>
<td>
<p>A vector list of length 'p' which is a set of argument values
corresponding to the observations in X. Each entry in this list should either
be a numeric value or a list of numeric elements, depending on the dimension of the domain
the variable is observed over. It can even vary from one variable to another,
If it be NULL, the default value for argval are the integers 1 to n, where n
is the size of the first dimension in argument X.?</p>
</td></tr>
<tr><td><code id="funts_+3A_method">method</code></td>
<td>
<p>Determines the type of the 'X' matrix: &quot;coefs&quot; or &quot;data.&quot;</p>
</td></tr>
<tr><td><code id="funts_+3A_start">start</code></td>
<td>
<p>The time of the first observation. It can be a single positive integer or an object of classes 'Date', 'POSIXct', or 'POSIXt',
specifying a natural time unit.</p>
</td></tr>
<tr><td><code id="funts_+3A_end">end</code></td>
<td>
<p>The time of the last observation, specified in the same way as 'start'.</p>
</td></tr>
<tr><td><code id="funts_+3A_vnames">vnames</code></td>
<td>
<p>a vector of strings specifies the variable names</p>
</td></tr>
<tr><td><code id="funts_+3A_dnames">dnames</code></td>
<td>
<p>list of vector of strings specifies the variable domain names</p>
</td></tr>
<tr><td><code id="funts_+3A_tname">tname</code></td>
<td>
<p>a string specifies the time index name</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An instance of the 'funts' class containing functional time series data.
</p>
<p>An instance of the 'funts' class containing functional time series data.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+fssa">fssa</a></code>
</p>

<hr>
<h2 id='is.funts'>Check if an object is of class 'funts'</h2><span id='topic+is.funts'></span>

<h3>Description</h3>

<p>Check if an object is of class 'funts'
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is.funts(obj)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="is.funts_+3A_obj">obj</code></td>
<td>
<p>The object to check.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>TRUE if the object is of class 'funts', FALSE otherwise.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("Callcenter")
is.funts(Callcenter)
</code></pre>

<hr>
<h2 id='launchApp'>Launch Shiny Application for FSSA Demonstration</h2><span id='topic+launchApp'></span>

<h3>Description</h3>

<p>This function launches a Shiny app to facilitate the understanding of univariate
or multivariate Functional Singular Spectrum Analysis (<code><a href="#topic+fssa">fssa</a></code>). The app
enables users to perform univariate or multivariate FSSA on various data types,
including simulated and real data provided by the server. Users can also upload
their own data. The app supports simultaneous comparisons of different methods,
such as multivariate vs. univariate FSSA, and allows users to select the number
and types of basis elements used for estimating Functional Time Series
(<code><a href="#topic+funts">funts</a></code>) objects. It offers plotting capabilities for both
<code><a href="#topic+funts">funts</a></code> and <code><a href="#topic+fssa">fssa</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>launchApp(type = "ufssa")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="launchApp_+3A_type">type</code></td>
<td>
<p>Type of FSSA with options of <code>type = "ufssa"</code> or <code>type = "mfssa"</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A shiny application object.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
launchApp()

## End(Not run)

</code></pre>

<hr>
<h2 id='length.funts'>Length of Functional Time Series</h2><span id='topic+length.funts'></span>

<h3>Description</h3>

<p>Returns the length of a &quot;funts&quot; object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'funts'
length(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="length.funts_+3A_x">x</code></td>
<td>
<p>an object of class &quot;funts&quot; .</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>data("Callcenter")
length(Callcenter)
</code></pre>

<hr>
<h2 id='loadAustinData'>Load Austin Temperature Data from GitHub Repository</h2><span id='topic+loadAustinData'></span>

<h3>Description</h3>

<p>This function retrieves the Austin Temperature dataset from a GitHub repository hosted at
https://github.com/haghbinh/dataset/Rfssa_dataset. Hosting datasets on GitHub
rather than including them in the Rfssa R package conserves storage space.
The Austin Temperature dataset contains intraday hourly temperature curves
measured in degrees Celsius from January 1973 to July 2023, recorded once per month.
The returned object is a raw dataset in 'list' format;
</p>


<h3>Usage</h3>

<pre><code class='language-R'>loadAustinData()
</code></pre>


<h3>Format</h3>

<p>Containing two matrix objects:
</p>

<dl>
<dt>Austin Temperature Data</dt><dd><p>A 24 by 607 matrix of discrete samplings of intraday hourly temperature curves, one day per month.</p>
</dd>
<dt>Utqiagvik Temperature Data</dt><dd><p>A 24 by 607 matrix of discrete samplings of intraday hourly temperature curves, one day per month.</p>
</dd>
</dl>



<h3>References</h3>

<p>Trinka, J., Haghbin, H., Shang, H., Maadooliat, M. (2023). Functional Time Series Forecasting: Functional Singular Spectrum Analysis Approaches. Stat, e621.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>Austin_raw &lt;- loadAustinData()
str(Austin_raw)


</code></pre>

<hr>
<h2 id='loadCallcenterData'>Load Callcenter Data from GitHub Repository</h2><span id='topic+loadCallcenterData'></span>

<h3>Description</h3>

<p>This function retrieves the Callcenter dataset from the Rfssa_dataset repository on GitHub
(https://github.com/haghbinh/dataset/Rfssa_dataset).
The Callcenter dataset represents a small call center for an anonymous bank.
It provides precise call timing data from January 1 to December 31, 1999.
The data is aggregated into 6-minute intervals on each day.
The returned object is a raw dataset in dataframe format;
it is not a 'funts' class object.
This raw data can then be further processed and converted into a 'funts' object named 'Callcenter'.
See <code><a href="#topic+funts">funts</a></code> for more details on
working with functional time series of class 'funts'.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>loadCallcenterData()
</code></pre>


<h3>Format</h3>

<p>a dataframe with 87,600 rows and 5 variables:
</p>

<dl>
<dt>calls</dt><dd><p>number of calls in a 6-minute aggregated interval.</p>
</dd>
<dt>u</dt><dd><p>numeric vector indicating the aggregated interval.</p>
</dd>
<dt>Date</dt><dd><p>date and time of call count recording.</p>
</dd>
<dt>Day</dt><dd><p>weekday associated with Date.</p>
</dd>
<dt>Month</dt><dd><p>month associated with Date.</p>
</dd>
</dl>



<h3>References</h3>


<ol>
<li>
<p>Brown, L., Gans, N., Mandelbaum, A., Sakov, A., Shen, H., Zeltyn, S., &amp; Zhao, L. (2005).
Statistical analysis of a telephone call center: A queueing-science perspective.
<em>Journal of the American Statistical Association</em>, <strong>100</strong>(469), 36-50.
</p>
</li>
<li>
<p>Shen, H., &amp; Huang, J. Z. (2005).
Analysis of call center arrival data using singular value decomposition.
<em>Applied Stochastic Models in Business and Industry</em>, <strong>21</strong>(3), 251-263.
</p>
</li>
<li>
<p>Huang, J. Z., Shen, H., &amp; Buja, A. (2008).
Functional principal components analysis via penalized rank one approximation.
<em>Electronic Journal of Statistics</em>, <strong>2</strong>, 678-695.
</p>
</li>
<li>
<p>Maadooliat, M., Huang, J. Z., &amp; Hu, J. (2015).
Integrating data transformation in principal components analysis.
<em>Journal of Computational and Graphical Statistics</em>, <strong>24</strong>(1), 84-103.
</p>
</li></ol>



<h3>See Also</h3>

<p><code><a href="#topic+funts">funts</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>require(fda)
# Load Callcenter data
Call_data &lt;- loadCallcenterData()
D &lt;- matrix(sqrt(Call_data$calls), nrow = 240)

# Define basis functions
bs1 &lt;- create.bspline.basis(c(0, 23), 22)

Y &lt;- funts(X = D, basisobj = bs1)

</code></pre>

<hr>
<h2 id='loadJambiData'>Load Jambi MODIS Data from GitHub Repository</h2><span id='topic+loadJambiData'></span>

<h3>Description</h3>

<p>This function retrieves the 'Jambi' dataset from a GitHub repository hosted at
https://github.com/haghbinh/dataset/Rfssa_dataset. The Jambi dataset contains normalized difference vegetation index (NDVI) and enhanced vegetation
index (EVI) image data from NASA’s MODerate-resolution Imaging Spectroradiometer (MODIS) with
global coverage at a 250 m^2 resolution. The dataset covers the Jambi Province, Indonesia,
known for various forested land uses, including natural forests and plantations.
Monitoring land cover changes is crucial, especially in the context of forest exploitation and
conservation efforts. Seasonal variations significantly impact long-term land cover changes.
Data collection began on February 18, 2000, and continued until July 28, 2019, with data recorded
every 16 days. This dataset is valuable for studying vegetative land cover changes in the region.
The returned object is a raw dataset in 'list' format;
</p>


<h3>Usage</h3>

<pre><code class='language-R'>loadJambiData()
</code></pre>


<h3>Format</h3>

<p>A list containing two arrays, each with dimensions 33 by 33 by 448. One array represents NDVI
image data, and the other represents EVI image data. The list also contains a date vector of length 448,
specifying the capture date for each 33 by 33 image.
</p>


<h3>Source</h3>

<p>[MODIS Product Information](https://lpdaac.usgs.gov/products/mod13q1v006/)
</p>


<h3>References</h3>


<ol>
<li><p> Lambin, E., Geist, H., Lepers, E. (1999).
Dynamics of Land-Use and Land-Cover Change in Tropical Regions.
<em>Annual Review of Environment and Resources</em>, 205-244.
</p>
</li></ol>



<h3>See Also</h3>

<p>- The dataset object loaded by this function.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>Jambi_raw &lt;- loadJambiData()
str(Jambi_raw)

</code></pre>

<hr>
<h2 id='loadMontanaData'>Load Montana Data from GitHub Repository</h2><span id='topic+loadMontanaData'></span>

<h3>Description</h3>

<p>This function retrieves the Montana dataset from a GitHub repository hosted at
https://github.com/haghbinh/dataset/Rfssa_dataset. Hosting datasets on GitHub
rather than including them in the Rfssa R package conserves storage space.
The Montana dataset contains intraday hourly temperature curves measured in degrees Celsius
and normalized difference vegetation index (NDVI) image data. Both types of data are recorded
near Saint Mary, Montana, USA. The NDVI images cover a region located between longitudes of
113.30 degrees West and 113.56 degrees West and latitudes of 48.71 degrees North and 48.78 degrees North.
For each recorded intraday temperature curve, an NDVI image was captured on the same day every
16 days, starting from January 1, 2008, and ending on September 30, 2013.
The dataset is valuable for environmental analysis, especially in the context of studying the impact
of temperature changes on vegetation. Combining both temperature and NDVI data can reveal more informative
patterns and insights.  The returned object is a raw dataset in 'list' format;
This raw data can then be further processed and converted into a 'funts' object named 'Montana'.
See <code><a href="#topic+funts">funts</a></code> for more details on  working with functional time series of class 'funts'.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>loadMontanaData()
</code></pre>


<h3>Format</h3>

<p>A list containing two components:
</p>

<dl>
<dt>Temperature Data</dt><dd><p>A 24 by 133 matrix of discrete samplings of intraday hourly temperature curves.</p>
</dd>
<dt>NDVI Images</dt><dd><p>An array with dimensions 33 by 33 by 133, where each 33 by 33 slice represents an NDVI image.</p>
</dd>
</dl>



<h3>References</h3>


<ol>
<li><p> Diamond, H. J., Karl, T., Palecki, M. A., Baker, C. B., Bell, J. E., Leeper, R. D.,
Easterling, D. R., Lawrimore, J. H., Meyers, T. P., Helfert, M. R., Goodge, G.,
and Thorne, P.W. (2013). U.S. climate reference network after one decade of operations:
status and assessment. [Read More](https://www.ncdc.noaa.gov/crn/qcdatasets.html).
Last accessed April 2020.
</p>
</li>
<li><p> Tuck, S. L., Phillips, H. R., Hintzen, R. E., Scharlemann, J. P., Purvis, A., and
Hudson, L. N. (2014). MODISTools – downloading and processing MODIS
remotely sensed data in R. Ecology and Evolution, 4(24):4658–4668.
</p>
</li></ol>



<h3>See Also</h3>

<p><code><a href="#topic+funts">funts</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>require(fda)
# Load Montana data
montana_data &lt;- loadMontanaData()

# Extract variables
Temp &lt;- montana_data$Temp
NDVI &lt;- montana_data$NDVI

# Create a list for Montana data
Montana_Data &lt;- list(Temp / sd(Temp), NDVI)

# Define basis functions
bs1 &lt;- create.bspline.basis(c(0, 23), 11)
bs2 &lt;- create.bspline.basis(c(1, 33), 13)
bs2d &lt;- list(bs2, bs2)
bsmv &lt;- list(bs1, bs2d)

# Convert to funts object
Y &lt;- funts(X = Montana_Data, basisobj = bsmv,
           start = as.Date("2008-01-01"),
           end = as.Date("2013-09-30"),
           vnames = c("Normalized Temperature (\u00B0C)" , "NDVI"),
           dnames = list("Time", c("Latitude", "Longitude")),
           tname = "Date"
)

</code></pre>

<hr>
<h2 id='loadUtqiagvikData'>Load Utqiagvik Temperature Data from GitHub Repository</h2><span id='topic+loadUtqiagvikData'></span>

<h3>Description</h3>

<p>This function retrieves the Utqiagvik Temperature dataset from a GitHub repository hosted at
https://github.com/haghbinh/dataset/Rfssa_dataset. Hosting datasets on GitHub
rather than including them in the Rfssa R package conserves storage space.
The Utqiagvik Temperature dataset contains intraday hourly temperature curves
measured in degrees Celsius from January 1973 to July 2023, recorded once per month.
The returned object is a raw dataset in 'list' format;
</p>


<h3>Usage</h3>

<pre><code class='language-R'>loadUtqiagvikData()
</code></pre>


<h3>Format</h3>

<p>Containing two matrix objects:
</p>

<dl>
<dt>Austin Temperature Data</dt><dd><p>A 24 by 607 matrix of discrete samplings of intraday hourly temperature curves, one day per month.</p>
</dd>
<dt>Utqiagvik Temperature Data</dt><dd><p>A 24 by 607 matrix of discrete samplings of intraday hourly temperature curves, one day per month.</p>
</dd>
</dl>



<h3>References</h3>

<p>Trinka, J., Haghbin, H., Shang, H., Maadooliat, M. (2023). Functional Time Series Forecasting: Functional Singular Spectrum Analysis Approaches. Stat, e621.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>Utqiagvik_raw &lt;- loadUtqiagvikData()
str(Utqiagvik_raw)

</code></pre>

<hr>
<h2 id='Montana'>Montana Intraday Temperature Curves and NDVI Images Data Set</h2><span id='topic+Montana'></span>

<h3>Description</h3>

<p>This dataset includes intraday hourly temperature curves measured in degrees Celsius and normalized difference vegetation index (NDVI) image data. The observations were recorded near Saint Mary, Montana, USA. The NDVI images cover a geographical region with longitudes ranging from 113.30 degrees West to 113.56 degrees West and latitudes from 48.71 degrees North to 48.78 degrees North.
The intraday temperature curves are sourced from Diamond et al. (2013), while the NDVI images were obtained from resources provided by Tuck et al. (2014).
For each recorded intraday temperature curve, an NDVI image was captured on the same day every 16 days. Data collection started on January 1, 2008, and concluded on September 30, 2013.
The primary goal of this dataset is to facilitate the analysis of temperature trends and investigate how temperature changes impact vegetation in the region. A multivariate analysis leveraging both temperature and NDVI variables can reveal more informative patterns and yield stronger signal extraction results.
The dataset is hosted on GitHub, and you can load it using the function <code><a href="#topic+loadMontanaData">loadMontanaData</a></code>.
The dataset has been converted into a multivariate functional time series using two B-spline basis function systems with 11 and 13 members, respectively. The resulting dataset is stored as a functional time series object of class 'funts'.
You can load the raw data using the function <code><a href="#topic+loadMontanaData">loadMontanaData</a></code>.
See <code><a href="#topic+funts">funts</a></code> for more details.
</p>


<h3>References</h3>


<ol>
<li><p> Diamond, H. J., Karl, T., Palecki, M. A., Baker, C. B., Bell, J. E., Leeper, R. D., Easterling, D. R., Lawrimore, J. H., Meyers, T. P., Helfert, M. R., Goodge, G., and Thorne, P.W. (2013). U.S. climate reference network after one decade of operations: status and assessment. [Link](https://www.ncdc.noaa.gov/crn/qcdatasets.html). Last accessed April 2020.
</p>
</li>
<li><p> Tuck, S. L., Phillips, H. R., Hintzen, R. E., Scharlemann, J. P., Purvis, A., and Hudson, L. N. (2014). MODISTools – downloading and processing MODIS remotely sensed data in R. Ecology and Evolution, 4(24), 4658–4668.
</p>
</li></ol>



<h3>See Also</h3>

<p><code><a href="#topic+loadMontanaData">loadMontanaData</a></code> - Function to load the Montana dataset.
</p>

<hr>
<h2 id='plot.fforecast'>Plot Method for FSSA Forecast (fforecast) Class</h2><span id='topic+plot.fforecast'></span>

<h3>Description</h3>

<p>Create visualizations of FSSA Forecast (fforecast) class. This function supports
plotting 'fforecast' data with one-dimensional or two-dimensional domains.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'fforecast'
plot(
  x,
  group_index = NULL,
  ask = TRUE,
  npts = 100,
  obs = 1,
  main = NULL,
  col = NULL,
  ori_col = NULL,
  type = "l",
  lty = 1,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.fforecast_+3A_x">x</code></td>
<td>
<p>an object of class <code>fforecast</code>.</p>
</td></tr>
<tr><td><code id="plot.fforecast_+3A_group_index">group_index</code></td>
<td>
<p>an integer specifying the group index for the plot.</p>
</td></tr>
<tr><td><code id="plot.fforecast_+3A_ask">ask</code></td>
<td>
<p>logical: If 'TRUE', and  'group_index' be 'NULL', after printing the first grouping graphic, it will pause when the user asks for the next group graphic and wait.</p>
</td></tr>
<tr><td><code id="plot.fforecast_+3A_npts">npts</code></td>
<td>
<p>number of grid points for the plots.</p>
</td></tr>
<tr><td><code id="plot.fforecast_+3A_obs">obs</code></td>
<td>
<p>observation number (for two-dimensional domains).</p>
</td></tr>
<tr><td><code id="plot.fforecast_+3A_main">main</code></td>
<td>
<p>main title for the plot.</p>
</td></tr>
<tr><td><code id="plot.fforecast_+3A_col">col</code></td>
<td>
<p>specify the predicted FTS color; if it is 'NULL', it will be set as the default.</p>
</td></tr>
<tr><td><code id="plot.fforecast_+3A_ori_col">ori_col</code></td>
<td>
<p>specify the original FTS color; if it is 'NULL', it will be set as the default.</p>
</td></tr>
<tr><td><code id="plot.fforecast_+3A_type">type</code></td>
<td>
<p>type of plot (&quot;l&quot; for line, &quot;p&quot; for points, etc.).</p>
</td></tr>
<tr><td><code id="plot.fforecast_+3A_lty">lty</code></td>
<td>
<p>line type (1 for solid, 2 for dashed, etc.).</p>
</td></tr>
<tr><td><code id="plot.fforecast_+3A_...">...</code></td>
<td>
<p>additional graphical parameters passed to plotting functions.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+fforecast">fforecast</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Example with one-dimensional domain
data("Callcenter")
# FSSA Decomposition step:
fssa_results &lt;- fssa(Callcenter, L = 28)

# Perform FSSA R-forecasting
pr_V &lt;- fforecast(U = fssa_results, groups = list(1,1:7),
                  len = 14, method = "vector", only.new = FALSE)

plot(pr_V)


</code></pre>

<hr>
<h2 id='plot.fssa'>Plot Functional Singular Spectrum Analysis Objects</h2><span id='topic+plot.fssa'></span>

<h3>Description</h3>

<p>This function is a plotting method for objects of class functional singular spectrum analysis (<code><a href="#topic+fssa">fssa</a></code>).
It aids users in making decisions during the grouping stage of univariate or multivariate functional singular spectrum analysis.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'fssa'
plot(
  x,
  d = length(x$values),
  idx = 1:d,
  idy = idx + 1,
  contrib = TRUE,
  groups = as.list(1:d),
  lwd = 2,
  type = "values",
  vars = NULL,
  ylab = NA,
  main = NA,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.fssa_+3A_x">x</code></td>
<td>
<p>An object of class <code><a href="#topic+fssa">fssa</a></code>.</p>
</td></tr>
<tr><td><code id="plot.fssa_+3A_d">d</code></td>
<td>
<p>An integer representing the number of elementary components to plot.</p>
</td></tr>
<tr><td><code id="plot.fssa_+3A_idx">idx</code></td>
<td>
<p>A vector of indices specifying which eigen elements to plot.</p>
</td></tr>
<tr><td><code id="plot.fssa_+3A_idy">idy</code></td>
<td>
<p>A second vector of indices of eigen elements to plot (for <code>type="paired"</code>).</p>
</td></tr>
<tr><td><code id="plot.fssa_+3A_contrib">contrib</code></td>
<td>
<p>A logical value. If <code>TRUE</code> (default), it displays the component's contribution to the total variance.</p>
</td></tr>
<tr><td><code id="plot.fssa_+3A_groups">groups</code></td>
<td>
<p>A list or vector of indices determining the grouping used for decomposition (for <code>type="wcor"</code>).</p>
</td></tr>
<tr><td><code id="plot.fssa_+3A_lwd">lwd</code></td>
<td>
<p>A vector of line widths.</p>
</td></tr>
<tr><td><code id="plot.fssa_+3A_type">type</code></td>
<td>
<p>The type of plot to be displayed. Possible types include:
</p>

<ul>
<li> <p><code>"values"</code> - Plot the square-root of eigen values (default).
</p>
</li>
<li> <p><code>"paired"</code> - Plot pairs of right singular function's coefficients (useful for detecting periodic components).
</p>
</li>
<li> <p><code>"wcor"</code> - Plot the W-correlation matrix for the reconstructed objects.
</p>
</li>
<li> <p><code>"vectors"</code> - Plot the right singular vectors (useful for detecting period length).
</p>
</li>
<li> <p><code>"lcurves"</code> - Plot left singular functions (useful for detecting period length).
</p>
</li>
<li> <p><code>"lheats"</code> - Heatmap plot of eigenfunctions, usable for <code><a href="#topic+funts">funts</a></code> variables observed over one or two-dimensional domains (useful for detecting meaningful patterns).
</p>
</li>
<li> <p><code>"periodogram"</code> - Periodogram plot right singular vectors (useful for detecting the frequencies of oscillations in functional data).
</p>
</li></ul>
</td></tr>
<tr><td><code id="plot.fssa_+3A_vars">vars</code></td>
<td>
<p>A numeric value specifying the variable number (used in plotting MFSSA <code>"lheats"</code> or <code>"lcurves"</code>).</p>
</td></tr>
<tr><td><code id="plot.fssa_+3A_ylab">ylab</code></td>
<td>
<p>A character vector representing the names of variables.</p>
</td></tr>
<tr><td><code id="plot.fssa_+3A_main">main</code></td>
<td>
<p>The main plot title.</p>
</td></tr>
<tr><td><code id="plot.fssa_+3A_...">...</code></td>
<td>
<p>Additional arguments to be passed to methods, such as graphical parameters.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+fssa">fssa</a></code>, <code><a href="#topic+plotly_funts">plotly_funts</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("Callcenter")
L &lt;- 28
U &lt;- fssa(Callcenter, L)
plot(U, type = "values", d = 10)
plot(U, type = "vectors", d = 4)
plot(U, type = "paired", d = 6)
plot(U, type = "lcurves", d = 4, vars = 1)
plot(U, type = "lheats", d = 4)
plot(U, type = "wcor", d = 10)


</code></pre>

<hr>
<h2 id='plot.funts'>Plot Functional Time Series (funts) Data</h2><span id='topic+plot.funts'></span>

<h3>Description</h3>

<p>Create visualizations of Functional Time Series (funts) data, supporting both one-dimensional and two-dimensional domains.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'funts'
plot(
  x,
  npts = 100,
  obs = 1,
  xlab = NULL,
  ylab = NULL,
  main = NULL,
  type = "l",
  lty = 1,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.funts_+3A_x">x</code></td>
<td>
<p>An object of class <code>funts</code>.</p>
</td></tr>
<tr><td><code id="plot.funts_+3A_npts">npts</code></td>
<td>
<p>Number of grid points for the plots.</p>
</td></tr>
<tr><td><code id="plot.funts_+3A_obs">obs</code></td>
<td>
<p>Observation number (for two-dimensional domains).</p>
</td></tr>
<tr><td><code id="plot.funts_+3A_xlab">xlab</code></td>
<td>
<p>X-axis label.</p>
</td></tr>
<tr><td><code id="plot.funts_+3A_ylab">ylab</code></td>
<td>
<p>Y-axis label.</p>
</td></tr>
<tr><td><code id="plot.funts_+3A_main">main</code></td>
<td>
<p>Main title for the plot.</p>
</td></tr>
<tr><td><code id="plot.funts_+3A_type">type</code></td>
<td>
<p>Type of plot (&quot;l&quot; for line, &quot;p&quot; for points, etc.).</p>
</td></tr>
<tr><td><code id="plot.funts_+3A_lty">lty</code></td>
<td>
<p>Line type (1 for solid, 2 for dashed, etc.).</p>
</td></tr>
<tr><td><code id="plot.funts_+3A_...">...</code></td>
<td>
<p>Additional graphical parameters passed to plotting functions.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function enables the creation of visualizations for Functional Time Series (funts) data. It supports both one-dimensional and two-dimensional domains.
</p>
<p>For one-dimensional domains, line plots are used, while for two-dimensional domains, image plots are employed.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+funts">funts</a></code>, <code><a href="#topic+Callcenter">Callcenter</a></code>, <code><a href="#topic+Montana">Montana</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Example with one-dimensional domain
data("Callcenter")
plot(Callcenter, lwd = 2, col = "deepskyblue4", main = "Call Center Data")

# Example with two-dimensional domain
data("Montana")
plot(Montana, obs = 2, main = c("Temperature Curves", "NDVI Images,"))

</code></pre>

<hr>
<h2 id='plotly_funts'>Plot Functional Time Series (funts) with Plotly</h2><span id='topic+plotly_funts'></span>

<h3>Description</h3>

<p>Visualize univariate or multivariate Functional Time Series (funts) using Plotly-based plots.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plotly_funts(
  x,
  vars = NULL,
  types = NULL,
  subplot = TRUE,
  main = NULL,
  ylab = NULL,
  xlab = NULL,
  tlab = NULL,
  zlab = NULL,
  xticklabels = NULL,
  xticklocs = NULL,
  yticklabels = NULL,
  yticklocs = NULL,
  color_palette = "RdYlBu",
  reverse_color_palette = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plotly_funts_+3A_x">x</code></td>
<td>
<p>an object of class <code><a href="#topic+funts">funts</a></code>.</p>
</td></tr>
<tr><td><code id="plotly_funts_+3A_vars">vars</code></td>
<td>
<p>numeric vector specifying which variables in the FTS to plot (default: all).</p>
</td></tr>
<tr><td><code id="plotly_funts_+3A_types">types</code></td>
<td>
<p>tuple of strings specifying plot types for each variable.</p>
</td></tr>
<tr><td><code id="plotly_funts_+3A_subplot">subplot</code></td>
<td>
<p>logical for subplotting line plots.</p>
</td></tr>
<tr><td><code id="plotly_funts_+3A_main">main</code></td>
<td>
<p>titles for each plot.</p>
</td></tr>
<tr><td><code id="plotly_funts_+3A_ylab">ylab</code></td>
<td>
<p>y-axis titles.</p>
</td></tr>
<tr><td><code id="plotly_funts_+3A_xlab">xlab</code></td>
<td>
<p>x-axis titles.</p>
</td></tr>
<tr><td><code id="plotly_funts_+3A_tlab">tlab</code></td>
<td>
<p>time-axis titles.</p>
</td></tr>
<tr><td><code id="plotly_funts_+3A_zlab">zlab</code></td>
<td>
<p>z-axis titles.</p>
</td></tr>
<tr><td><code id="plotly_funts_+3A_xticklabels">xticklabels</code></td>
<td>
<p>tick labels for the domain of the functions.</p>
</td></tr>
<tr><td><code id="plotly_funts_+3A_xticklocs">xticklocs</code></td>
<td>
<p>positions of tick labels for the domain of the functions.</p>
</td></tr>
<tr><td><code id="plotly_funts_+3A_yticklabels">yticklabels</code></td>
<td>
<p>tick labels for the domain of the functions.</p>
</td></tr>
<tr><td><code id="plotly_funts_+3A_yticklocs">yticklocs</code></td>
<td>
<p>positions of tick labels for the domain of the functions.</p>
</td></tr>
<tr><td><code id="plotly_funts_+3A_color_palette">color_palette</code></td>
<td>
<p>color palette for two-dimensional FTS plots.</p>
</td></tr>
<tr><td><code id="plotly_funts_+3A_reverse_color_palette">reverse_color_palette</code></td>
<td>
<p>reverse the color palette scale.</p>
</td></tr>
<tr><td><code id="plotly_funts_+3A_...">...</code></td>
<td>
<p>additional arguments to pass to Plotly methods.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Supported plot types for one-dimensional domain variables:
- &quot;line&quot;: line plots (default).
- &quot;heatmap&quot;: heatmaps.
- &quot;3Dsurface&quot;: 3D surface plots.
- &quot;3Dline&quot;: 3D line plots.
</p>
<p>Supported plot type for two-dimensional domain variables:
- &quot;heatmap&quot;
</p>
<p>Each variable can be plotted multiple times with different types.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+funts">funts</a></code>, <code><a href="#topic+Callcenter">Callcenter</a></code>, <code><a href="#topic+Montana">Montana</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
data("Callcenter") # Univariate FTS example

plotly_funts(Callcenter)

plotly_funts(Callcenter,
  main = "Call Center Data Line Plot",
  xticklabels = list(c("00:00", "06:00", "12:00", "18:00", "24:00")),
  xticklocs = list(c(1, 60, 120, 180, 240))
)

plotly_funts(Callcenter, type = "3Dline", main = "Callcenter Data")

plotly_funts(Callcenter, type = "3Dsurface", main = "Callcenter Data")

plotly_funts(Callcenter, type = "heatmap", main = "Callcenter Data")


data("Montana") # Multivariate FTS example
plotly_funts(Montana[1:100],
  main = c("Temperature Curves", "NDVI Images"),
  color_palette = "RdYlGn",
  xticklabels = list(
    c("00:00", "06:00", "12:00", "18:00", "24:00"),
    c("113.40\u00B0 W", "113.30\u00B0 W")
  ),
  xticklocs = list(c(1, 6, 12, 18, 24), c(1, 33)),
  yticklabels = list(NA, c("48.70\u00B0 N", "48.77\u00B0 N")),
  yticklocs = list(NA, c(1, 33))
)

## End(Not run)
</code></pre>

<hr>
<h2 id='print.fforecast'>Custom Print Method for FSSA Forecast (fforecast) class</h2><span id='topic+print.fforecast'></span>

<h3>Description</h3>

<p>This custom print method is designed for objects of the FSSA Forecast (fforecast) class.
It provides a summary of the fforecast object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'fforecast'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.fforecast_+3A_x">x</code></td>
<td>
<p>an object of class &quot;fforecast&quot; to be printed.</p>
</td></tr>
<tr><td><code id="print.fforecast_+3A_...">...</code></td>
<td>
<p>further arguments passed to or from other methods.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'># Example with one-dimensional domain
data("Callcenter")
# FSSA Decomposition step:
fssa_results &lt;- fssa(Callcenter, L = 28)

# Perform FSSA R-forecasting
pr_R &lt;- fforecast(U = fssa_results,
                  groups = c(1:3),
                  len = 14,
                  method = "recurrent")
print(pr_R)

</code></pre>

<hr>
<h2 id='print.funts'>Custom Print Method for Functional Time Series (funts) Objects</h2><span id='topic+print.funts'></span>

<h3>Description</h3>

<p>This custom print method is designed for objects of the Functional Time Series (funts) class.
It provides a summary of the funts object, including its length (N), the number of variables,
and its structure.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'funts'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.funts_+3A_x">x</code></td>
<td>
<p>an object of class &quot;funts&quot; to be printed.</p>
</td></tr>
<tr><td><code id="print.funts_+3A_...">...</code></td>
<td>
<p>further arguments passed to or from other methods.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
data("Callcenter")
print(Callcenter)

## End(Not run)
</code></pre>

<hr>
<h2 id='Rfssa-package'>Rfssa: A Package for Functional Singular Spectrum Analysis and Related Methods.</h2><span id='topic+Rfssa'></span><span id='topic+Rfssa-package'></span>

<h3>Description</h3>

<p>The Rfssa package provides essential functions for implementing functional singular spectrum analysis (FSSA) methods. It supports the analysis of univariate and multivariate functional time series (FTS). FSSA, both univariate and multivariate, is a non-parametric approach for decomposing and reconstructing FTS. This package allows you to work with FTS variables observed over one or two-dimensional domains.
</p>


<h3>Details</h3>

<p>To use this package, start by creating a <code><a href="#topic+funts">funts</a></code> object. You can
define it by providing raw data, basis specifications, and grid specifications.
The FTS object can be univariate or multivariate, and the variables can be observed
over one-dimensional curves or two-dimensional images. The package includes
input validity checks to guide you.
Use the <code><a href="graphics.html#topic+plot">plot</a></code> method to visualize the <code><a href="#topic+funts">funts</a></code> object.
It offers various plotting options for one-dimensional domain variables and
animations for two-dimensional domains.
Next, apply the FSSA routine (<code><a href="#topic+fssa">fssa</a></code>) to the <code><a href="#topic+funts">funts</a></code>
object with a chosen lag parameter to obtain the decomposition. The decomposition
function utilizes 'RSpectra' and 'RcppEigen' R packages, along with the 'Eigen' C++ package,
for efficient processing.
Visualize the decomposition results using the <code><a href="#topic+plot.fssa">plot.fssa</a></code> method to
help choose the grouping of eigentriples for reconstruction (<code><a href="#topic+freconstruct">freconstruct</a></code>)
or forecasting (<code><a href="#topic+fforecast">fforecast</a></code>). The <code><a href="#topic+freconstruct">freconstruct</a></code>
function reconstructs a list of <code><a href="#topic+funts">funts</a></code> objects specified by the
grouping, while <code><a href="#topic+fforecast">fforecast</a></code> provides predictions of the signals
specified by the grouping. Calculate bootstrapped prediction intervals for forecasts
using the <code><a href="#topic+fpredinterval">fpredinterval</a></code> function.
When performing forecasting, typically specify one group that captures the assumed
deterministic, extracted signal within the FTS, while excluding all other modes of variation.
Currently, forecasting supports FTS with one-dimensional domains, with two-dimensional
domain forecasting planned for future updates.
This version of the 'Rfssa' R package introduces the <code><a href="#topic+fpredinterval">fpredinterval</a></code> function,
which calculates prediction intervals for FSSA-based forecasts using a bootstrap
approach for the residuals.
</p>


<h3>Author(s)</h3>

<p><strong>Maintainer</strong>: Hossein Haghbin <a href="mailto:haghbin@pgu.ac.ir">haghbin@pgu.ac.ir</a> (<a href="https://orcid.org/0000-0001-8416-2354">ORCID</a>)
</p>
<p>Authors:
</p>

<ul>
<li><p> Jordan Trinka <a href="mailto:jordantrinka4@hotmail.com">jordantrinka4@hotmail.com</a>
</p>
</li>
<li><p> Seyed Morteza Najibi <a href="mailto:mor.najibi@gmail.com">mor.najibi@gmail.com</a>
</p>
</li>
<li><p> Mehdi Maadooliat <a href="mailto:mehdi.maadooliat@mu.edu">mehdi.maadooliat@mu.edu</a> (<a href="https://orcid.org/0000-0002-5408-2676">ORCID</a>)
</p>
</li></ul>



<h3>References</h3>

<p>Haghbin, H., Najibi, S. M., Mahmoudvand, R., Trinka, J., Maadooliat, M. (2021). Functional singular spectrum analysis. Stat, 10(1), e330.
</p>
<p>Trinka J. (2021) Functional Singular Spectrum Analysis: Nonparametric Decomposition and Forecasting Approaches for Functional Time Series [Doctoral dissertation, Marquette University]. ProQuest Dissertations Publishing.
</p>
<p>Trinka, J., Haghbin, H.,  Maadooliat, M. (2022). Multivariate Functional Singular Spectrum Analysis: A Nonparametric Approach for Analyzing Multivariate Functional Time Series. In Innovations in Multivariate Statistical Modeling: Navigating Theoretical and Multidisciplinary Domains (pp. 187-221). Cham: Springer International Publishing.
</p>
<p>Trinka, J., Haghbin, H., Shang, H., Maadooliat, M. (2023). Functional Time Series Forecasting: Functional Singular Spectrum Analysis Approaches. Stat, e621.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+fssa">fssa</a></code>, <code><a href="#topic+freconstruct">freconstruct</a></code>, <code><a href="#topic+fforecast">fforecast</a></code>
<code><a href="#topic+funts">funts</a></code>, <code><a href="#topic+launchApp">launchApp</a></code>
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
