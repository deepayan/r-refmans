<!DOCTYPE html><html><head><title>Help for package PPMiss</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {PPMiss}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#arfima.coefs'><p>Coefficients of an ARFIMA(p,d,q) model</p></a></li>
<li><a href='#d.fit'><p>Long memory parameter estimation</p></a></li>
<li><a href='#k1fun'><p>Constant K1</p></a></li>
<li><a href='#kdens'><p>Kernel density estimator</p></a></li>
<li><a href='#PPMiss.copulas'><p>Copula functions and the corresponding derivative limit.</p></a></li>
<li><a href='#PPMiss.Package'><p>PPMiss: Copula-Based Estimator for Long-Range Dependent Processes under Missing Data.</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Date:</td>
<td>2023-09-04</td>
</tr>
<tr>
<td>Title:</td>
<td>Copula-Based Estimator for Long-Range Dependent Processes under
Missing Data</td>
</tr>
<tr>
<td>Version:</td>
<td>0.1.1</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 4.0.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>copula, pracma, stats, zoo</td>
</tr>
<tr>
<td>Description:</td>
<td>Implements the copula-based estimator for univariate long-range dependent processes, introduced in Pumi et al. (2023) &lt;<a href="https://doi.org/10.1007%2Fs00362-023-01418-z">doi:10.1007/s00362-023-01418-z</a>&gt;. Notably, this estimator is capable of handling missing data and has been shown to perform exceptionally well, even when up to 70% of data is missing (as reported in &lt;<a href="https://doi.org/10.48550/arXiv.2303.04754">doi:10.48550/arXiv.2303.04754</a>&gt;) and has been found to outperform several other commonly applied estimators.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL (&ge; 3)</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-09-04 21:46:36 UTC; Taiane</td>
</tr>
<tr>
<td>Author:</td>
<td>Taiane Schaedler Prass
    <a href="https://orcid.org/0000-0003-3136-909X"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [aut, cre,
    com],
  Guilherme Pumi <a href="https://orcid.org/0000-0002-6256-3170"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, ctb]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Taiane Schaedler Prass &lt;taianeprass@gmail.com&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-09-04 22:20:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='arfima.coefs'>Coefficients of an ARFIMA(p,d,q) model</h2><span id='topic+arfima.coefs'></span>

<h3>Description</h3>

<p>This function calculates the coefficients <code class="reqn">c_k, k \geq 0</code> corresponding to
<code class="reqn">\theta(z)\phi^{-1}(z)(1-z)^{-d} = \sum_{k = 0}^{\infty}c_k z^k</code>,
up to a truncation point
</p>


<h3>Usage</h3>

<pre><code class='language-R'>arfima.coefs(ar = NULL, ma = NULL, d = 0, trunc = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="arfima.coefs_+3A_ar">ar</code></td>
<td>
<p>the coefficients of the autoregressive polinomial. Default is NULL</p>
</td></tr>
<tr><td><code id="arfima.coefs_+3A_ma">ma</code></td>
<td>
<p>the coefficients of the moving average polinomial. Default is null</p>
</td></tr>
<tr><td><code id="arfima.coefs_+3A_d">d</code></td>
<td>
<p>the long memory parameter. Default is 0.</p>
</td></tr>
<tr><td><code id="arfima.coefs_+3A_trunc">trunc</code></td>
<td>
<p>the truncation point. Default is 1.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The coefficients values up to order &lsquo;trunc&rsquo;.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>cks &lt;- arfima.coefs(d = 0.3, trunc = 5)
cks

cks &lt;- arfima.coefs(d = 0.1, trunc = 5, ar = 0.5, ma = 0.6)
cks

</code></pre>

<hr>
<h2 id='d.fit'>Long memory parameter estimation</h2><span id='topic+d.fit'></span>

<h3>Description</h3>

<p>Let <code class="reqn">\theta_h</code> be the copula parameter associated to
<code class="reqn">(X_t,X_{t+h})</code> and <code class="reqn">\hat\theta_h</code> be an estimate of <code class="reqn">\theta_h</code>
based on pseudo observations. The long memory parameter
<code class="reqn">d</code> is estimated by
</p>
<p style="text-align: center;"><code class="reqn">\hat d:=\mathrm{argmin}_{|d|&lt;0.5}\bigg\{\sum_{h=s}^m \bigg|{\hat K_1}(\hat\theta_h-a)-\frac{\Gamma(1-d)}{\Gamma(d)}h^{2d-1}\bigg|^r\bigg\}, \quad r &gt; 0</code>
</p>
<p>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>d.fit(xt, copula = gauss, dCdtheta = dCtheta_gauss, theta.lower = -1,
  theta.upper = 1, optim.method = "Brent", method = "mpl", s = 1,
  m = 24, theta.start = 0.1, empirical = TRUE, r = 2, a = 0,
  d.interval = c(-0.5, 0.5))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="d.fit_+3A_xt">xt</code></td>
<td>
<p>a vector with the observed time series. Missing observations are allowed.</p>
</td></tr>
<tr><td><code id="d.fit_+3A_copula">copula</code></td>
<td>
<p>an object of class &lsquo;copula&rsquo;. Readily available options
are <code>frank</code>, <code>amh</code>, <code>fgm</code> and  <code>gauss</code>. Other
copulas can be used but the user must provide the corresponding <code>dCdtheta</code>.
Default is <code>gauss</code>.</p>
</td></tr>
<tr><td><code id="d.fit_+3A_dcdtheta">dCdtheta</code></td>
<td>
<p>a two parameter function that returns the limit of the copula
derivative, with respect to <code class="reqn">\theta</code>, as <code class="reqn">\theta</code> goes to <code class="reqn">a</code>, where <code class="reqn">a</code> is
such that <code class="reqn">C_a(u,v)=uv</code>. Readily available
options are <code>dCtheta_frank</code>, <code>dCtheta_amh</code>, <code>dCtheta_fgm</code>
and  <code>dCtheta_gauss</code>. Default is  <code>dCtheta_gauss</code>.</p>
</td></tr>
<tr><td><code id="d.fit_+3A_theta.lower">theta.lower</code></td>
<td>
<p>the lower bound for <code class="reqn">\theta</code>. Default is -1.</p>
</td></tr>
<tr><td><code id="d.fit_+3A_theta.upper">theta.upper</code></td>
<td>
<p>the upper bound for <code class="reqn">\theta</code>. Default is 1.</p>
</td></tr>
<tr><td><code id="d.fit_+3A_optim.method">optim.method</code></td>
<td>
<p>a character string specifying the optimization method.
For all available options see <code><a href="stats.html#topic+optim">optim</a></code>.
Default is &lsquo;Brent&rsquo;. See <cite><a href="copula.html#topic+fitCopula">fitCopula</a></cite> for
more details.</p>
</td></tr>
<tr><td><code id="d.fit_+3A_method">method</code></td>
<td>
<p>a character string specifying the copula parameter
estimator used. This can be one of: &lsquo;mpl&rsquo;, &lsquo;itau&rsquo;, &lsquo;irho&rsquo;,
&lsquo;itau.mpl&rsquo; or &lsquo;ml&rsquo;. See <cite><a href="copula.html#topic+fitCopula">fitCopula</a></cite> for details.
Default is &lsquo;mpl&rsquo;.</p>
</td></tr>
<tr><td><code id="d.fit_+3A_s">s</code></td>
<td>
<p>integer. The smallest lag <code class="reqn">h</code> considered in the estimation. Default is 1.</p>
</td></tr>
<tr><td><code id="d.fit_+3A_m">m</code></td>
<td>
<p>integer. The  largest lag <code class="reqn">h</code> considered in the estimation. Default is 24.</p>
</td></tr>
<tr><td><code id="d.fit_+3A_theta.start">theta.start</code></td>
<td>
<p>starting value for the parameter optimization via <code><a href="stats.html#topic+optim">optim</a></code>.</p>
</td></tr>
<tr><td><code id="d.fit_+3A_empirical">empirical</code></td>
<td>
<p>logical. If <code>TRUE</code>, the sample estimators for the density
and quantile functions are considered. Otherwhise, the gaussian density and
quantile functions are used. Default is <code>TRUE</code></p>
</td></tr>
<tr><td><code id="d.fit_+3A_r">r</code></td>
<td>
<p>the exponent used in the Minkowski distance used to calculate <code class="reqn">\hat d</code>.
Default is 2, the Euclidean distance.</p>
</td></tr>
<tr><td><code id="d.fit_+3A_a">a</code></td>
<td>
<p>the value of <code class="reqn">\theta</code> such that <code class="reqn">\lim_{\theta \to a} C_\theta(u,v)=uv</code>,
is the product (or independence) copula. Default is 0, which is the common value for
the available copulas, namely, <code>frank</code>, <code>amh</code>, <code>fgm</code> and  <code>gauss</code>.</p>
</td></tr>
<tr><td><code id="d.fit_+3A_d.interval">d.interval</code></td>
<td>
<p>a vector of size 2 giving the lower and upper bound for the
long memory parameter <code class="reqn">d</code>. Default is <code>c(-0.5,0.5)</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code class="reqn">\hat d</code>, the estimated value of <code class="reqn">d</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
#-------------------------
# ARFIMA(0,d,0) process
#-------------------------
trunc &lt;- 50000
n = 1000
cks &lt;- arfima.coefs(d = 0.25, trunc = trunc)
eps &lt;- rnorm(trunc+n)
x &lt;- sapply(1:n, function(t) sum(cks*rev(eps[t:(t+trunc)])))

#----------------------
# Original time series
#-----------------------
# For Frank copula, -Inf &lt; theta &lt; Inf. However, "Brent" requires
# finite lower and upper bounds so we use c(-100, 100) here
d_frank &lt;- d.fit(xt = x, copula = frank, dCdtheta = dCtheta_frank,
                 theta.lower = -100, theta.upper = 100)
d_amh &lt;- d.fit(xt = x, copula = amh, dCdtheta = dCtheta_amh,
                 theta.lower = -1, theta.upper = 1)
d_fgm &lt;- d.fit(xt = x, copula = fgm, dCdtheta = dCtheta_fgm,
                 theta.lower = -1, theta.upper = 1)
d_gauss &lt;- d.fit(xt = x, copula = gauss, dCdtheta = dCtheta_gauss,
                 theta.lower = -1, theta.upper = 1)

c(FRANK = d_frank, AMH = d_amh, FGM = d_fgm, GAUSS = d_gauss)

#----------------------------
# Adding some missing values
#----------------------------
index &lt;- sample(1:n, size = round(0.2*n))
xt &lt;- x
xt[index] &lt;- NA

d_frank_m &lt;- d.fit(xt = xt, copula = frank,
                   dCdtheta = dCtheta_frank,
                   theta.lower = -100, theta.upper = 100)
d_amh_m &lt;- d.fit(xt = xt, copula = amh, dCdtheta = dCtheta_amh,
                 theta.lower = -1, theta.upper = 1)
d_fgm_m &lt;- d.fit(xt = xt, copula = fgm, dCdtheta = dCtheta_fgm,
                 theta.lower = -1, theta.upper = 1)
d_gauss_m &lt;- d.fit(xt = xt, copula = gauss,
                   dCdtheta = dCtheta_gauss,
                   theta.lower = -1, theta.upper = 1)

data.frame(
  series = c("Complete", "Missing"),
  FRANK = c(d_frank, d_frank_m),
  AMH = c(d_amh, d_amh_m),
  FGM = c(d_fgm, d_fgm_m),
  GAUSS = c(d_gauss, d_gauss_m))

#-------------------------
# ARFIMA(1,d,1) process
#-------------------------
# For a faster algorithm to generate ARFIMA processes,
# see the package "arfima"
trunc &lt;- 50000
cks &lt;- arfima.coefs(d = 0.35, trunc = trunc, ar = -0.2, ma = 0.4)
n = 1000
eps &lt;- rnorm(trunc+n)
x &lt;- sapply(1:n, function(t) sum(cks*rev(eps[t:(t+trunc)])))

#----------------------
# Original time series
#-----------------------
# For Frank copula, -Inf &lt; theta &lt; Inf. However, "Brent" requires
# finite lower and upper bounds so we use c(-100, 100) here
d_frank &lt;- d.fit(xt = x, copula = frank, dCdtheta = dCtheta_frank,
                 theta.lower = -100, theta.upper = 100)
d_amh &lt;- d.fit(xt = x, copula = amh, dCdtheta = dCtheta_amh,
                 theta.lower = -1, theta.upper = 1)
d_fgm &lt;- d.fit(xt = x, copula = fgm, dCdtheta = dCtheta_fgm,
                 theta.lower = -1, theta.upper = 1)
d_gauss &lt;- d.fit(xt = x, copula = gauss, dCdtheta = dCtheta_gauss,
                 theta.lower = -1, theta.upper = 1)

c(FRANK = d_frank, AMH = d_amh, FGM = d_fgm, GAUSS = d_gauss)

#----------------------------
# Adding some missing values
#----------------------------
n = 1000
index &lt;- sample(1:n, size = round(0.2*n))
xt &lt;- x
xt[index] &lt;- NA

d_frank_m &lt;- d.fit(xt = xt, copula = frank,
                   dCdtheta = dCtheta_frank,
                   theta.lower = -100, theta.upper = 100)
d_amh_m &lt;- d.fit(xt = xt, copula = amh, dCdtheta = dCtheta_amh,
                 theta.lower = -1, theta.upper = 1)
d_fgm_m &lt;- d.fit(xt = xt, copula = fgm, dCdtheta = dCtheta_fgm,
                 theta.lower = -1, theta.upper = 1)
d_gauss_m &lt;- d.fit(xt = xt, copula = gauss,
                   dCdtheta = dCtheta_gauss,
                   theta.lower = -1, theta.upper = 1)

data.frame(
  series = c("Complete", "Missing"),
  FRANK = c(d_frank, d_frank_m),
  AMH = c(d_amh, d_amh_m),
  FGM = c(d_fgm, d_fgm_m),
  GAUSS = c(d_gauss, d_gauss_m))


</code></pre>

<hr>
<h2 id='k1fun'>Constant K1</h2><span id='topic+k1fun'></span>

<h3>Description</h3>

<p>Calculates an estimate for the constant <code class="reqn">K_1</code> given by
</p>
<p style="text-align: center;"><code class="reqn">K_1 = \int_0^1\int_0^1\frac{1}{l_0(u)l_n(v)}\lim_{\theta\to a}\frac{\partial C_{\theta}(u,v)}{\partial\theta}\,dudv, </code>
</p>

<p>where <code class="reqn">l_m(x):= F_m'\big(F_m^{(-1)}(x)\big)</code>, <code class="reqn">a</code> is such that <code class="reqn">C_a(u,v)=uv</code> (the product copula), and
<code class="reqn">\{F_n\}_{n \geq 0}</code> is a sequence of absolutely continuous distribution
functions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>k1fun(dCdtheta, fun, data, empirical, mean = 0, sd = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="k1fun_+3A_dcdtheta">dCdtheta</code></td>
<td>
<p>a function providing the limit as <code class="reqn">\theta \to a</code> of the
copula derivative with respect to <code class="reqn">\theta</code>. For the readily available copulas, namely, <code>frank</code>, <code>amh</code>,
<code>fgm</code> and  <code>gauss</code>, <code class="reqn">a=0</code>.</p>
</td></tr>
<tr><td><code id="k1fun_+3A_fun">fun</code></td>
<td>
<p>optionally, a function providing an estimator for the probability density function.</p>
</td></tr>
<tr><td><code id="k1fun_+3A_data">data</code></td>
<td>
<p>the observed time series. Only used to obtain the quantile function
when <code>empirical = TRUE</code>.</p>
</td></tr>
<tr><td><code id="k1fun_+3A_empirical">empirical</code></td>
<td>
<p>logical. If <code>TRUE</code>, the sample estimators for the density
and quantile functions are considered. Otherwise, the gaussian density and
quantile functions are used instead.</p>
</td></tr>
<tr><td><code id="k1fun_+3A_mean">mean</code></td>
<td>
<p>the mean of the gaussian distribution.
Only used if <code>empirical = FALSE</code></p>
</td></tr>
<tr><td><code id="k1fun_+3A_sd">sd</code></td>
<td>
<p>the standard deviation of the gaussian distribution.
Only used if <code>empirical = FALSE</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>Here <code class="reqn">F'</code> and <code class="reqn">F^{(-1)}</code> are replaced by sample estimators for these
functions or the gaussian density and quantile functions are used, depending
on the context.
</p>
<p>The function <code><a href="#topic+kdens">kdens</a></code> is used as sample estimator of <code class="reqn">F'</code> and
<code><a href="stats.html#topic+quantile">quantile</a></code> is the sample estimator of <code class="reqn">F^{(-1)}</code>.
</p>


<h3>Value</h3>

<p>The value of <code class="reqn">K_1</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>trunc = 50000
cks &lt;- arfima.coefs(d = 0.25, trunc = trunc)
eps &lt;- rnorm(trunc+1000)
x &lt;- sapply(1:1000, function(t) sum(cks*rev(eps[t:(t+trunc)])))

# kernel density function
dfun &lt;- kdens(x)

# calculating K1 using four copulas and empirical estimates for F' and F^{(-1)}
K1_frank_e &lt;- k1fun(dCdtheta = dCtheta_frank, fun = dfun,
                 data = x, empirical = TRUE)
K1_amh_e &lt;- k1fun(dCdtheta = dCtheta_amh, fun = dfun,
                 data = x, empirical = TRUE)
K1_fgm_e &lt;- k1fun(dCdtheta = dCtheta_fgm, fun = dfun,
                 data = x, empirical = TRUE)
K1_gauss_e &lt;- k1fun(dCdtheta = dCtheta_gauss, fun = dfun,
                 data = x, empirical = TRUE)

# calculating K1 using four copulas and gaussian marginals
K1_frank_g &lt;- k1fun(dCdtheta = dCtheta_frank, fun = NULL, data = NULL,
                  empirical = FALSE, mean = mean(x), sd = sd(x))
K1_amh_g &lt;- k1fun(dCdtheta = dCtheta_amh, fun = NULL, data = NULL,
                  empirical = FALSE, mean = mean(x), sd = sd(x))
K1_fgm_g &lt;- k1fun(dCdtheta = dCtheta_fgm, fun = NULL, data = NULL,
                  empirical = FALSE, mean = mean(x), sd = sd(x))
K1_gauss_g &lt;- k1fun(dCdtheta = dCtheta_gauss, fun = NULL, data = NULL,
                  empirical = FALSE, mean = mean(x), sd = sd(x))

# comparing results
 data.frame(MARGINAL = c("Empirical", "Gaussian"),
            FRANK = c(K1_frank_e, K1_frank_g),
            AMH = c(K1_amh_e,  K1_amh_g),
            FGM = c(K1_fgm_e, K1_fgm_g),
            GAUSS = c(K1_gauss_e, K1_gauss_g))

</code></pre>

<hr>
<h2 id='kdens'>Kernel density estimator</h2><span id='topic+kdens'></span>

<h3>Description</h3>

<p>The probability density function <code class="reqn">F'</code> is estimated using a kernel density
approach. More specifically, first <code class="reqn">y_i = \hat{f}(x_i^\ast)</code>  is estimated
using <code class="reqn">T = 512</code> (default for the function <code><a href="stats.html#topic+density">density</a></code>)
equally spaced points <code class="reqn">x_i^\ast</code>, <code class="reqn">1 \leq i \leq T</code>, in the interval
<code class="reqn">[x_{(1)} - 3b, x_{(n)} + 3b]</code>, where <code class="reqn">b</code> is the bandwidth for
the Gaussian kernel density estimator, chosen by applying the Silverman's
rule of thumb (the default procedure in <code><a href="stats.html#topic+density">density</a></code>).
A cubic spline interpolation (the default method for <code><a href="stats.html#topic+spline">spline</a></code>)
is then applied to the pairs <code class="reqn">\{(x_i^\ast, y_i)\}_{i=1}^T</code> to obtain
<code class="reqn">\hat F_n'(x)</code> for all <code class="reqn">x \in [x_{(1)} - 3b, x_{(n)} + 3b]</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>kdens(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="kdens_+3A_x">x</code></td>
<td>
<p>the data from which the estimate is to be computed.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a function that approximates the probability density function.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># creating a time series
trunc = 50000
cks &lt;- arfima.coefs(d = 0.25, trunc = trunc)
eps &lt;- rnorm(trunc+1000)
x &lt;- sapply(1:1000, function(t) sum(cks*rev(eps[t:(t+trunc)])))

# kernel density function
dfun &lt;- kdens(x)

# plot
curve(dfun, from = min(x), to = max(x))

</code></pre>

<hr>
<h2 id='PPMiss.copulas'>Copula functions and the corresponding derivative limit.</h2><span id='topic+PPMiss.copulas'></span><span id='topic+frank'></span><span id='topic+dCtheta_frank'></span><span id='topic+amh'></span><span id='topic+dCtheta_amh'></span><span id='topic+fgm'></span><span id='topic+dCtheta_fgm'></span><span id='topic+gauss'></span><span id='topic+dCtheta_gauss'></span>

<h3>Description</h3>

<p>Implemented copulas and the corresponding derivative limit,
as <code class="reqn">\theta \to a</code>, where <code class="reqn">a</code> is such that <code class="reqn">C_a(u,v)=uv</code>.
An estimate for <code class="reqn">\theta</code> is obtained based on the copula function used.
and the derivatives are used to obtain an estimate for <code class="reqn">K_1</code>.
The functions &lsquo;frank&rsquo;, &lsquo;amh&rsquo;, &lsquo;fgm&rsquo; and &lsquo;gauss&rsquo;
are shortcuts for  <code><a href="copula.html#topic+frankCopula">copula::frankCopula()</a></code>,
<code><a href="copula.html#topic+amhCopula">copula::amhCopula()</a></code>, <code><a href="copula.html#topic+fgmCopula">copula::fgmCopula()</a></code> and
<code><a href="copula.html#topic+normalCopula">copula::normalCopula()</a></code> from package &lsquo;copula&rsquo;,
respectively.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>frank

dCtheta_frank(u, v)

amh

dCtheta_amh(u, v)

fgm

dCtheta_fgm(u, v)

gauss

dCtheta_gauss(u, v)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="PPMiss.copulas_+3A_u">u</code></td>
<td>
<p>a real number between 0 and 1.</p>
</td></tr>
<tr><td><code id="PPMiss.copulas_+3A_v">v</code></td>
<td>
<p>a real number between 0 and 1.</p>
</td></tr>
</table>


<h3>Format</h3>

<p>An object of class <code>frankCopula</code> of length 1.
</p>
<p>An object of class <code>amhCopula</code> of length 1.
</p>
<p>An object of class <code>fgmCopula</code> of length 1.
</p>
<p>An object of class <code>normalCopula</code> of length 1.
</p>


<h3>Details</h3>

<p>The constant <code class="reqn">K_1</code> is given by
</p>
<p style="text-align: center;"><code class="reqn">K_1 = \int_0^1\int_0^1\frac{1}{l_0(u)l_n(v)}\lim_{\theta\rightarrow a}\frac{\partial C_{\theta}(u,v)}{\partial\theta}\,dudv, </code>
</p>

<p>where <code class="reqn">I=[0,1]</code>, <code class="reqn">l_m(x):= F_m'\big(F_m^{(-1)}(x)\big)</code> and
<code class="reqn">\{F_n\}_{n \geq 0}</code> is a sequence of absolutely continuous distribution
functions
</p>


<h3>Value</h3>

<p>Archimedean copula objects of class &lsquo;frankCopula&rsquo;, &lsquo;amhCopula&rsquo; or a
Farlie-Gumbel-Morgenstern copula object of class &lsquo;fgmCopula&rsquo; or an elliptical
copula object of class &lsquo;normalCopula&rsquo;. For details, see
<code><a href="copula.html#topic+archmCopula">archmCopula</a></code>, <code><a href="copula.html#topic+fgmCopula">fgmCopula</a></code> and
<code><a href="copula.html#topic+ellipCopula">ellipCopula</a></code>.
</p>
<p>The derivative functions return the limit, as <code class="reqn">\theta \to 0</code>, of the
derivative with respect to <code class="reqn">\theta</code>, corresponding to the copula functions.
</p>

<hr>
<h2 id='PPMiss.Package'>PPMiss: Copula-Based Estimator for Long-Range Dependent Processes under Missing Data.</h2><span id='topic+PPMiss.Package'></span><span id='topic+_PACKAGE'></span><span id='topic+PPMis'></span>

<h3>Description</h3>

<p>The PPMiss package provides functions for parameter estimation of univariate
time series by means of a parametric copula approach. The methodology is based
on the relationship between the process' covariance decay and a parametric
bivariate copulas associated to lagged variables.
</p>


<h3>Author(s)</h3>

<p>Taiane Schaedler Prass <a href="mailto:taianeprass@gmail.com">taianeprass@gmail.com</a> and Guilherme Pumi <a href="mailto:guipumi@gmail.com">guipumi@gmail.com</a>
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
