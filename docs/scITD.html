<!DOCTYPE html><html><head><title>Help for package scITD</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {scITD}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#apply_combat'><p>Apply ComBat batch correction to pseudobulk matrices. Generally, this should be done through calling the</p>
form_tensor() wrapper function.</a></li>
<li><a href='#calculate_fiber_fstats'><p>Calculate F-Statistics for the association between donor scores for each factor</p>
donor values of shuffled gene_ctype fibers</a></li>
<li><a href='#check_rec_pres'><p>Helper function to check whether receptor is present in target cell type</p></a></li>
<li><a href='#clean_data'><p>Clean data to remove genes only expressed in a few cells and donors</p>
with very few cells. Generally, this should be done through calling the
form_tensor() wrapper function.</a></li>
<li><a href='#colMeanVars'><p>Calculates column mean and variance. Adapted from pagoda2.</p>
https://github.com/kharchenkolab/pagoda2/blob/main/src/misc2.cpp</a></li>
<li><a href='#compare_decompositions'><p>Plot a pairwise comparison of factors from two separate decompositions</p></a></li>
<li><a href='#compute_associations'><p>Compute associations between donor proportions and factor scores</p></a></li>
<li><a href='#compute_donor_props'><p>Get donor proportions of each cell type or subtype</p></a></li>
<li><a href='#compute_LR_interact'><p>Compute and plot the LR interactions for one factor</p></a></li>
<li><a href='#convert_gn'><p>Convert gene identifiers to gene symbols</p></a></li>
<li><a href='#count_word'><p>count_word. From older version of simplifyEnrichment package.</p></a></li>
<li><a href='#determine_ranks_tucker'><p>Run rank determination by svd on the tensor unfolded along each mode</p></a></li>
<li><a href='#form_tensor'><p>Form the pseudobulk tensor as preparation for running the tensor decomposition.</p></a></li>
<li><a href='#get_all_lds_factor_plots'><p>Generate loadings heatmaps for all factors</p></a></li>
<li><a href='#get_callouts_annot'><p>Get gene callout annotations for a loadings heatmap</p></a></li>
<li><a href='#get_ctype_exp_var'><p>Get explained variance of the reconstructed data using one cell type from one factor</p></a></li>
<li><a href='#get_ctype_prop_associations'><p>Compute and plot associations between donor factor scores and donor proportions of major cell types</p></a></li>
<li><a href='#get_ctype_subc_prop_associations'><p>Compute and plot associations between donor factor scores and donor proportions of cell subtypes</p></a></li>
<li><a href='#get_ctype_vargenes'><p>Partition main gene by cell matrix into per cell type matrices with significantly</p>
variable genes only. Generally, this should be done through calling the
form_tensor() wrapper function.</a></li>
<li><a href='#get_donor_meta'><p>Get metadata matrix of dimensions donors by variables (not per cell)</p></a></li>
<li><a href='#get_factor_exp_var'><p>Get the explained variance of the reconstructed data using one factor</p></a></li>
<li><a href='#get_fstats_pvals'><p>Calculate adjusted p-values for gene_celltype fiber-donor score associations</p></a></li>
<li><a href='#get_gene_modules'><p>Compute WGCNA gene modules for each cell type</p></a></li>
<li><a href='#get_gene_set_vectors'><p>Get logical vectors indicating which genes are in which pathways</p></a></li>
<li><a href='#get_indv_subtype_associations'><p>Compute subtype proportion-factor association p-values for all subclusters of</p>
a given major cell type</a></li>
<li><a href='#get_intersecting_pathways'><p>Extract the intersection of gene sets which are enriched in two or more cell types for a factor</p></a></li>
<li><a href='#get_leading_edge_genes'><p>Get the leading edge genes from GSEA results</p></a></li>
<li><a href='#get_lm_pvals'><p>Compute gene-factor associations using univariate linear models</p></a></li>
<li><a href='#get_max_correlations'><p>Computes the max correlation between each factor of the decomposition done using</p>
the whole dataset to each factor computed using the subsampled/bootstrapped dataset</a></li>
<li><a href='#get_meta_associations'><p>Get metadata associations with factor donor scores</p></a></li>
<li><a href='#get_min_sig_genes'><p>Evaluate the minimum number for significant genes in any factor for a given number of</p>
factors extracted by the decomposition</a></li>
<li><a href='#get_module_enr'><p>Identify gene sets that are enriched within specified gene co-regulatory modules.</p>
Uses a hypergeometric test for over-representation. Used in plot_multi_module_enr().</a></li>
<li><a href='#get_normalized_variance'><p>Get normalized variance for each gene, taking into account mean-variance trend</p></a></li>
<li><a href='#get_num_batch_ranks'><p>Plot factor-batch associations for increasing number of donor factors</p></a></li>
<li><a href='#get_one_factor'><p>Get the donor scores and loadings matrix for a single-factor</p></a></li>
<li><a href='#get_one_factor_gene_pvals'><p>Get significant genes for a factor</p></a></li>
<li><a href='#get_pseudobulk'><p>Collapse data from cell-level to donor-level via summing counts. Generally, this should be done through calling the</p>
form_tensor() wrapper function.</a></li>
<li><a href='#get_real_fstats'><p>Get F-Statistics for the real (non-shuffled) gene_ctype fibers</p></a></li>
<li><a href='#get_reconstruct_errors_svd'><p>Calculate reconstruction errors using svd approach</p></a></li>
<li><a href='#get_significance_vectors'><p>Get vectors indicating which genes are significant in which cell types</p>
for a factor of interest</a></li>
<li><a href='#get_subclust_de_hmaps'><p>Get list of cell subtype differential expression heatmaps</p></a></li>
<li><a href='#get_subclust_enr_dotplot'><p>Get scatter plot for association of a cell subtype proportion with scores for a factor</p></a></li>
<li><a href='#get_subclust_enr_fig'><p>Get a figure showing cell subtype proportion associations with each factor. Combines</p>
this plot with subtype UMAPs and differential expression heatmaps. Note that this
function runs better if the number of cores in the conos object in
container$embedding has n.cores set to a relatively small value &lt; 10.</a></li>
<li><a href='#get_subclust_enr_hmap'><p>Get heatmap of subtype proportion associations for each celltype/subtype and each factor</p></a></li>
<li><a href='#get_subclust_umap'><p>Get a figure to display subclusterings at multiple resolutions</p></a></li>
<li><a href='#get_subclusters'><p>Perform leiden subclustering to get cell subtypes</p></a></li>
<li><a href='#get_subtype_prop_associations'><p>Compute and plot associations between factor scores and cell subtype composition</p>
for various clustering resolution parameters</a></li>
<li><a href='#get_sums'><p>Calculates factor-stratified sums for each column. Adapted from pagoda2.</p>
https://github.com/kharchenkolab/pagoda2/blob/main/src/misc2.cpp</a></li>
<li><a href='#ht_clusters'><p>Visualize the similarity matrix and the clustering. Adapted from simplifyEnrichment package.</p>
https://github.com/jokergoo/simplifyEnrichment/blob/master/R/ht_clusters.R</a></li>
<li><a href='#identify_sex_metadata'><p>Extract metadata for sex information if not provided already</p></a></li>
<li><a href='#initialize_params'><p>Initialize parameters to be used throughout scITD in various functions</p></a></li>
<li><a href='#instantiate_scMinimal'><p>Create an scMinimal object. Generally, this should be done through calling the</p>
make_new_container() wrapper function.</a></li>
<li><a href='#is_GO_id'><p>Check if a character is a go ID</p></a></li>
<li><a href='#make_new_container'><p>Create a container to store all data and results for the project. You must</p>
provide a params list as generated by initialize_params(). You also need to
provide either a Seurat object or both a count_data matrix and a meta_data matrix.</a></li>
<li><a href='#merge_small_clusts'><p>Merge small subclusters into larger ones</p></a></li>
<li><a href='#nmf_unfolded'><p>Computes non-negative matrix factorization on the tensor unfolded along the donor dimension</p></a></li>
<li><a href='#norm_var_helper'><p>Calculates the normalized variance for each gene. This is adapted from pagoda2.</p>
https://github.com/kharchenkolab/pagoda2/blob/main/R/Pagoda2.R
Generally, this should be done through calling the
form_tensor() wrapper function.</a></li>
<li><a href='#normalize_counts'><p>Helper function to normalize and log-transform count data</p></a></li>
<li><a href='#normalize_pseudobulk'><p>Normalize the pseudobulked counts matrices. Generally, this should be done through calling the</p>
form_tensor() wrapper function.</a></li>
<li><a href='#parse_data_by_ctypes'><p>Parse main counts matrix into per-celltype-matrices. Generally, this should be done through calling the</p>
form_tensor() wrapper function.</a></li>
<li><a href='#pca_unfolded'><p>Computes singular-value decomposition on the tensor unfolded along the donor dimension</p></a></li>
<li><a href='#plot_donor_matrix'><p>Plot matrix of donor scores extracted from Tucker decomposition</p></a></li>
<li><a href='#plot_donor_props'><p>Plot donor celltype/subtype proportions against each factor</p></a></li>
<li><a href='#plot_donor_sig_genes'><p>Generate a gene by donor heatmap showing scaled expression of top loading genes</p>
for a given factor</a></li>
<li><a href='#plot_dscore_enr'><p>Compute enrichment of donor metadata categorical variables at high/low factor scores</p></a></li>
<li><a href='#plot_gsea_hmap'><p>Plot enriched gene sets from all cell types in a heatmap</p></a></li>
<li><a href='#plot_gsea_hmap_w_similarity'><p>Plot already computed enriched gene sets to show semantic similarity between sets</p></a></li>
<li><a href='#plot_gsea_sub'><p>Look at enriched gene sets from a cluster of semantically similar gene sets.</p>
Uses the results from previous run of plot_gsea_hmap_w_similarity()</a></li>
<li><a href='#plot_loadings_annot'><p>Plot the gene by celltype loadings for a factor</p></a></li>
<li><a href='#plot_mod_and_lig'><p>Plot trio of associations between ligand expression, module eigengenes, and</p>
factor scores</a></li>
<li><a href='#plot_multi_module_enr'><p>Generate gene set x ct_module heatmap showing co-expression module gene set enrichment results</p></a></li>
<li><a href='#plot_rec_errors_bar_svd'><p>Plot reconstruction errors as bar plot for svd method</p></a></li>
<li><a href='#plot_rec_errors_line_svd'><p>Plot reconstruction errors as line plot for svd method</p></a></li>
<li><a href='#plot_scores_by_meta'><p>Plot dotplots for each factor to compare donor scores between metadata groups</p></a></li>
<li><a href='#plot_select_sets'><p>Plot enrichment results for hand picked gene sets</p></a></li>
<li><a href='#plot_stability_results'><p>Generate a plot for either the donor scores or loadings stability test</p></a></li>
<li><a href='#plot_subclust_associations'><p>Plot association significances for varying clustering resolutions</p></a></li>
<li><a href='#plotDEheatmap_conos'><p>Plot a heatmap of differential genes. Code is adapted from Conos package.</p>
https://github.com/kharchenkolab/conos/blob/master/R/plot.R</a></li>
<li><a href='#prep_LR_interact'><p>Prepare data for LR analysis and get soft thresholds to use for gene modules</p></a></li>
<li><a href='#project_new_data'><p>Project multicellular patterns to get scores on new data</p></a></li>
<li><a href='#reduce_dimensions'><p>Gets a conos object of the data, aligning datasets across a specified variable such as</p>
batch or donors. This can be run independently or through get_subtype_prop_associations().</a></li>
<li><a href='#reduce_to_vargenes'><p>Reduce each cell type's expression matrix to just the significantly variable genes.</p>
Generally, this should be done through calling the form_tensor() wrapper function.</a></li>
<li><a href='#render_multi_plots'><p>Create a figure of all loadings plots arranged</p></a></li>
<li><a href='#reshape_loadings'><p>Reshape loadings for a factor from linearized to matrix form</p></a></li>
<li><a href='#run_fgsea'><p>Run fgsea for one cell type of one factor</p></a></li>
<li><a href='#run_gsea_one_factor'><p>Run gsea separately for all cell types of one specified factor and plot results</p></a></li>
<li><a href='#run_hypergeometric_gsea'><p>Compute enriched gene sets among significant genes in a cell type for</p>
a factor using hypergeometric test</a></li>
<li><a href='#run_jackstraw'><p>Run jackstraw to get genes that are significantly associated with donor scores</p>
for factors extracted by Tucker decomposition</a></li>
<li><a href='#run_stability_analysis'><p>Test stability of a decomposition by subsampling or bootstrapping donors. Note that</p>
running this function will replace the decomposition in the project container
with one resulting from the tucker parameters entered here.</a></li>
<li><a href='#run_tucker_ica'><p>Run the Tucker decomposition and rotate the factors</p></a></li>
<li><a href='#sample_fibers'><p>Get a list of tensor fibers to shuffle</p></a></li>
<li><a href='#scale_fontsize'><p>Scale font size. From simplifyEnrichment package.</p>
https://github.com/jokergoo/simplifyEnrichment/blob/master/R/ht_clusters.R</a></li>
<li><a href='#scale_variance'><p>Scale variance across donors for each gene within each cell type. Generally, this should be done through calling the</p>
form_tensor() wrapper function.</a></li>
<li><a href='#seurat_to_scMinimal'><p>Convert Seurat object to scMinimal object. Generally, this should be done through calling the</p>
make_new_container() wrapper function.</a></li>
<li><a href='#shuffle_fibers'><p>Shuffle elements within the selected fibers</p></a></li>
<li><a href='#stack_tensor'><p>Create the tensor object by stacking each pseudobulk cell type matrix.</p>
Generally, this should be done through calling the form_tensor() wrapper function.</a></li>
<li><a href='#stop_wrap'><p>Helper function from simplifyEnrichment package.</p>
https://github.com/jokergoo/simplifyEnrichment/blob/master/R/utils.R</a></li>
<li><a href='#subset_scMinimal'><p>Subset an scMinimal object by specified genes, donors, cells, or cell types</p></a></li>
<li><a href='#test_container'><p>Data container for testing tensor formation steps</p></a></li>
<li><a href='#tucker_ica_helper'><p>Helper function for running the decomposition. Use the run_tucker_ica()</p>
wrapper function instead.</a></li>
<li><a href='#update_params'><p>Update any of the experiment-wide parameters</p></a></li>
<li><a href='#vargenes_anova'><p>Compute significantly variable genes via anova. Generally, this should be done through calling the</p>
form_tensor() wrapper function.</a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Title:</td>
<td>Single-Cell Interpretable Tensor Decomposition</td>
</tr>
<tr>
<td>Version:</td>
<td>1.0.4</td>
</tr>
<tr>
<td>Date:</td>
<td>2023-09-06</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Jonathan Mitchel &lt;jonathan.mitchel3@gmail.com&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Single-cell Interpretable Tensor Decomposition (scITD) employs the 
    Tucker tensor decomposition to extract multicell-type gene expression patterns 
    that vary across donors/individuals. This tool is geared for use with single-cell
    RNA-sequencing datasets consisting of many source donors. The method has a wide
    range of potential applications, including the study of inter-individual variation
    at the population-level, patient sub-grouping/stratification, and the analysis
    of sample-level batch effects. Each "multicellular process" that is extracted 
    consists of (A) a multi cell type gene loadings matrix and (B) a
    corresponding donor scores vector indicating the level at which the corresponding
    loadings matrix is expressed in each donor. Additional methods are implemented
    to aid in selecting an appropriate number of factors and to evaluate stability
    of the decomposition. Additional tools are provided for downstream analysis,
    including integration of gene set enrichment analysis and ligand-receptor analysis. 
    Tucker, L.R. (1966) &lt;<a href="https://doi.org/10.1007%2FBF02289464">doi:10.1007/BF02289464</a>&gt;. Unkel, S., Hannachi, A., Trendafilov, N. T., &amp; Jolliffe, I. T. (2011) &lt;<a href="https://doi.org/10.1007%2Fs13253-011-0055-9">doi:10.1007/s13253-011-0055-9</a>&gt;. Zhou, G., &amp; Cichocki, A. (2012) &lt;<a href="https://doi.org/10.2478%2Fv10175-012-0051-4">doi:10.2478/v10175-012-0051-4</a>&gt;.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 4.0.0), Matrix</td>
</tr>
<tr>
<td>Imports:</td>
<td>rTensor, ica, fgsea, circlize, reshape2, parallel,
ComplexHeatmap, ggplot2, mgcv, utils, Rcpp, RColorBrewer,
dplyr, edgeR, sva, stats, Rmisc, ggpubr, msigdbr, sccore, NMF</td>
</tr>
<tr>
<td>Suggests:</td>
<td>methods, knitr, rmarkdown, testthat, coda.base, grid,
simplifyEnrichment, WGCNA, cowplot, matrixStats, stringr, zoo,
rlang, AnnotationDbi, GO.db, conos, pagoda2, betareg, slam, tm</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>Rcpp, RcppArmadillo, RcppProgress</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-09-08 15:38:51 UTC; jmitchel</td>
</tr>
<tr>
<td>Author:</td>
<td>Jonathan Mitchel [cre, aut],
  Evan Biederstedt [aut],
  Peter Kharchenko [aut]</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-09-08 16:00:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='apply_combat'>Apply ComBat batch correction to pseudobulk matrices. Generally, this should be done through calling the
form_tensor() wrapper function.</h2><span id='topic+apply_combat'></span>

<h3>Description</h3>

<p>Apply ComBat batch correction to pseudobulk matrices. Generally, this should be done through calling the
form_tensor() wrapper function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>apply_combat(container, batch_var)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="apply_combat_+3A_container">container</code></td>
<td>
<p>environment Project container that stores sub-containers
for each cell type as well as results and plots from all analyses</p>
</td></tr>
<tr><td><code id="apply_combat_+3A_batch_var">batch_var</code></td>
<td>
<p>character A batch variable from metadata to remove</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The project container with the batc corrected pseudobulked matrices.
</p>

<hr>
<h2 id='calculate_fiber_fstats'>Calculate F-Statistics for the association between donor scores for each factor
donor values of shuffled gene_ctype fibers</h2><span id='topic+calculate_fiber_fstats'></span>

<h3>Description</h3>

<p>Calculate F-Statistics for the association between donor scores for each factor
donor values of shuffled gene_ctype fibers
</p>


<h3>Usage</h3>

<pre><code class='language-R'>calculate_fiber_fstats(tensor_data, tucker_results, s_fibers)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="calculate_fiber_fstats_+3A_tensor_data">tensor_data</code></td>
<td>
<p>list The tensor data including donor, gene, and cell type labels
as well as the tensor array itself</p>
</td></tr>
<tr><td><code id="calculate_fiber_fstats_+3A_tucker_results">tucker_results</code></td>
<td>
<p>list The results from Tucker decomposition. Includes a scores
matrix as the first element and the loadings tensor unfolded as the second element.</p>
</td></tr>
<tr><td><code id="calculate_fiber_fstats_+3A_s_fibers">s_fibers</code></td>
<td>
<p>list Gene and cell type indices for the randomly selected fibers</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A numeric vector of F-statistics for associations between all shuffled fibers 
and donor scores.
</p>

<hr>
<h2 id='check_rec_pres'>Helper function to check whether receptor is present in target cell type</h2><span id='topic+check_rec_pres'></span>

<h3>Description</h3>

<p>Helper function to check whether receptor is present in target cell type
</p>


<h3>Usage</h3>

<pre><code class='language-R'>check_rec_pres(
  container,
  lig_ct_exp,
  rec_elements,
  target_ct,
  percentile_exp_rec
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="check_rec_pres_+3A_container">container</code></td>
<td>
<p>environment Project container that stores sub-containers
for each cell type as well as results and plots from all analyses</p>
</td></tr>
<tr><td><code id="check_rec_pres_+3A_lig_ct_exp">lig_ct_exp</code></td>
<td>
<p>numeric Scaled expression for a ligand in the source cell type</p>
</td></tr>
<tr><td><code id="check_rec_pres_+3A_rec_elements">rec_elements</code></td>
<td>
<p>character One or more components of a receptor complex</p>
</td></tr>
<tr><td><code id="check_rec_pres_+3A_target_ct">target_ct</code></td>
<td>
<p>character The name of the target cell type</p>
</td></tr>
<tr><td><code id="check_rec_pres_+3A_percentile_exp_rec">percentile_exp_rec</code></td>
<td>
<p>numeric The percentile of ligand expression above which
all donors need to have at least 5 cells expressing the receptor.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A logical indicating whether receptor is present or not.
</p>

<hr>
<h2 id='clean_data'>Clean data to remove genes only expressed in a few cells and donors
with very few cells. Generally, this should be done through calling the
form_tensor() wrapper function.</h2><span id='topic+clean_data'></span>

<h3>Description</h3>

<p>Clean data to remove genes only expressed in a few cells and donors
with very few cells. Generally, this should be done through calling the
form_tensor() wrapper function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>clean_data(container, donor_min_cells = 5)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="clean_data_+3A_container">container</code></td>
<td>
<p>environment Project container that stores sub-containers
for each cell type as well as results and plots from all analyses</p>
</td></tr>
<tr><td><code id="clean_data_+3A_donor_min_cells">donor_min_cells</code></td>
<td>
<p>numeric Minimum threshold for number of cells per
donor (default=5)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The project container with cleaned counts matrices in each 
container$scMinimal_ctype$&lt;ctype&gt;$count_data.
</p>

<hr>
<h2 id='colMeanVars'>Calculates column mean and variance. Adapted from pagoda2.
https://github.com/kharchenkolab/pagoda2/blob/main/src/misc2.cpp</h2><span id='topic+colMeanVars'></span>

<h3>Description</h3>

<p>Calculates column mean and variance. Adapted from pagoda2.
https://github.com/kharchenkolab/pagoda2/blob/main/src/misc2.cpp
</p>


<h3>Usage</h3>

<pre><code class='language-R'>colMeanVars(sY, rowSel, ncores = 1L)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="colMeanVars_+3A_sy">sY</code></td>
<td>
<p>sparse matrix Gene by cell matrix of counts</p>
</td></tr>
<tr><td><code id="colMeanVars_+3A_rowsel">rowSel</code></td>
<td>
<p>numeric The selected rows (genes)</p>
</td></tr>
<tr><td><code id="colMeanVars_+3A_ncores">ncores</code></td>
<td>
<p>numeric The number of cores</p>
</td></tr>
</table>


<h3>Value</h3>

<p>data.frame with columns of mean, variance, and number of observeatios 
for each gene across samples
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(Matrix)
donor_by_gene &lt;- rbind(c(9,2,1,5), c(3,3,1,2))
donor_by_gene &lt;- Matrix(donor_by_gene, sparse = TRUE)
result &lt;- colMeanVars(donor_by_gene, rowSel = NULL, ncores=1)
</code></pre>

<hr>
<h2 id='compare_decompositions'>Plot a pairwise comparison of factors from two separate decompositions</h2><span id='topic+compare_decompositions'></span>

<h3>Description</h3>

<p>Plot a pairwise comparison of factors from two separate decompositions
</p>


<h3>Usage</h3>

<pre><code class='language-R'>compare_decompositions(
  tucker_res1,
  tucker_res2,
  decomp_names,
  meta_anno1 = NULL,
  meta_anno2 = NULL,
  use_text = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="compare_decompositions_+3A_tucker_res1">tucker_res1</code></td>
<td>
<p>list The container$tucker_res from first decomposition</p>
</td></tr>
<tr><td><code id="compare_decompositions_+3A_tucker_res2">tucker_res2</code></td>
<td>
<p>list The container$tucker_res from first decomposition</p>
</td></tr>
<tr><td><code id="compare_decompositions_+3A_decomp_names">decomp_names</code></td>
<td>
<p>character Names of the two decompositions that will go
on the axes of the heatmap</p>
</td></tr>
<tr><td><code id="compare_decompositions_+3A_meta_anno1">meta_anno1</code></td>
<td>
<p>matrix The result of calling get_meta_associations()
corresponding to the first decomposition, which is stored in
container$meta_associations (default=NULL)</p>
</td></tr>
<tr><td><code id="compare_decompositions_+3A_meta_anno2">meta_anno2</code></td>
<td>
<p>matrix The result of calling get_meta_associations()
corresponding to the second decomposition, which is stored in
container$meta_associations (default=NULL)</p>
</td></tr>
<tr><td><code id="compare_decompositions_+3A_use_text">use_text</code></td>
<td>
<p>logical If TRUE, then displays correlation coefficients in cells
(default=TRUE)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>No return value, as the resulting plots are drawn.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>test_container &lt;- run_tucker_ica(test_container, ranks=c(2,4),
tucker_type='regular', rotation_type='hybrid')
tucker_res1 &lt;- test_container$tucker_results
test_container &lt;- run_tucker_ica(test_container, ranks=c(2,4),
tucker_type='regular', rotation_type='ica_dsc')
tucker_res2 &lt;- test_container$tucker_results
compare_decompositions(tucker_res1,tucker_res2,c('hybrid_method','ica_method'))
</code></pre>

<hr>
<h2 id='compute_associations'>Compute associations between donor proportions and factor scores</h2><span id='topic+compute_associations'></span>

<h3>Description</h3>

<p>Compute associations between donor proportions and factor scores
</p>


<h3>Usage</h3>

<pre><code class='language-R'>compute_associations(donor_balances, donor_scores, stat_type)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="compute_associations_+3A_donor_balances">donor_balances</code></td>
<td>
<p>matrx The balances computed from donor cell type proportions</p>
</td></tr>
<tr><td><code id="compute_associations_+3A_donor_scores">donor_scores</code></td>
<td>
<p>data.frame The donor scores matrix from tucker results</p>
</td></tr>
<tr><td><code id="compute_associations_+3A_stat_type">stat_type</code></td>
<td>
<p>character Either &quot;fstat&quot; to get F-Statistics, &quot;adj_rsq&quot; to get adjusted
R-squared values, or &quot;adj_pval&quot; to get adjusted pvalues.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A numeric vector of association statistics (one for each factor)
</p>

<hr>
<h2 id='compute_donor_props'>Get donor proportions of each cell type or subtype</h2><span id='topic+compute_donor_props'></span>

<h3>Description</h3>

<p>Get donor proportions of each cell type or subtype
</p>


<h3>Usage</h3>

<pre><code class='language-R'>compute_donor_props(clusts, metadata)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="compute_donor_props_+3A_clusts">clusts</code></td>
<td>
<p>integer Cluster assignments for each cell with names as cell barcodes</p>
</td></tr>
<tr><td><code id="compute_donor_props_+3A_metadata">metadata</code></td>
<td>
<p>data.frame The $metadata field for the given scMinimal</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data.frame of cluster proportions for each donor.
</p>

<hr>
<h2 id='compute_LR_interact'>Compute and plot the LR interactions for one factor</h2><span id='topic+compute_LR_interact'></span>

<h3>Description</h3>

<p>Compute and plot the LR interactions for one factor
</p>


<h3>Usage</h3>

<pre><code class='language-R'>compute_LR_interact(
  container,
  lr_pairs,
  sig_thresh = 0.05,
  percentile_exp_rec = 0.75,
  add_ld_fact_sig = TRUE,
  ncores = container$experiment_params$ncores
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="compute_LR_interact_+3A_container">container</code></td>
<td>
<p>environment Project container that stores sub-containers
for each cell type as well as results and plots from all analyses</p>
</td></tr>
<tr><td><code id="compute_LR_interact_+3A_lr_pairs">lr_pairs</code></td>
<td>
<p>data.frame Data of ligand-receptor pairs. First column should
be ligands and second column should be one or more receptors separated by an
underscore such as receptor1_receptor2 in the case that multiple receptors are
required for signaling.</p>
</td></tr>
<tr><td><code id="compute_LR_interact_+3A_sig_thresh">sig_thresh</code></td>
<td>
<p>numeric The p-value significance threshold to use for module-
factor associations and ligand-factor associations (default=0.05)</p>
</td></tr>
<tr><td><code id="compute_LR_interact_+3A_percentile_exp_rec">percentile_exp_rec</code></td>
<td>
<p>numeric The percentile above which the top donors expressing the
ligand all must be expressing the receptor (default=0.75)</p>
</td></tr>
<tr><td><code id="compute_LR_interact_+3A_add_ld_fact_sig">add_ld_fact_sig</code></td>
<td>
<p>logical Set to TRUE to append a heatmap showing significance
of associations between each ligand hit and each factor (default=TRUE)</p>
</td></tr>
<tr><td><code id="compute_LR_interact_+3A_ncores">ncores</code></td>
<td>
<p>numeric The number of cores to use (default=container$experiment_params$ncores)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The LR analysis results heatmap as ComplexHeatmap object. Adjusted p-values
for all results are placed in container$lr_res.
</p>

<hr>
<h2 id='convert_gn'>Convert gene identifiers to gene symbols</h2><span id='topic+convert_gn'></span>

<h3>Description</h3>

<p>Convert gene identifiers to gene symbols
</p>


<h3>Usage</h3>

<pre><code class='language-R'>convert_gn(container, genes)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="convert_gn_+3A_container">container</code></td>
<td>
<p>environment Project container that stores sub-containers
for each cell type as well as results and plots from all analyses</p>
</td></tr>
<tr><td><code id="convert_gn_+3A_genes">genes</code></td>
<td>
<p>character Vector of the gene identifiers to be converted to
gene symbols</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A character vector of gene symbols.
</p>

<hr>
<h2 id='count_word'>count_word. From older version of simplifyEnrichment package.</h2><span id='topic+count_word'></span>

<h3>Description</h3>

<p>count_word. From older version of simplifyEnrichment package.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>count_word(term, exclude_words = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="count_word_+3A_term">term</code></td>
<td>
<p>A vector of description texts.</p>
</td></tr>
<tr><td><code id="count_word_+3A_exclude_words">exclude_words</code></td>
<td>
<p>The words that should be excluded.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data frame with words and frequencies.
</p>

<hr>
<h2 id='determine_ranks_tucker'>Run rank determination by svd on the tensor unfolded along each mode</h2><span id='topic+determine_ranks_tucker'></span>

<h3>Description</h3>

<p>Run rank determination by svd on the tensor unfolded along each mode
</p>


<h3>Usage</h3>

<pre><code class='language-R'>determine_ranks_tucker(
  container,
  max_ranks_test,
  shuffle_level = "cells",
  shuffle_within = NULL,
  num_iter = 100,
  batch_var = NULL,
  norm_method = "trim",
  scale_factor = 10000,
  scale_var = TRUE,
  var_scale_power = 0.5,
  seed = container$experiment_params$rand_seed
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="determine_ranks_tucker_+3A_container">container</code></td>
<td>
<p>environment Project container that stores sub-containers
for each cell type as well as results and plots from all analyses</p>
</td></tr>
<tr><td><code id="determine_ranks_tucker_+3A_max_ranks_test">max_ranks_test</code></td>
<td>
<p>numeric Vector of length 2 specifying the maximum number of
donor and gene ranks to test</p>
</td></tr>
<tr><td><code id="determine_ranks_tucker_+3A_shuffle_level">shuffle_level</code></td>
<td>
<p>character Either &quot;cells&quot; to shuffle cell-donor linkages or
&quot;tensor&quot; to shuffle values within the tensor (default=&quot;cells&quot;)</p>
</td></tr>
<tr><td><code id="determine_ranks_tucker_+3A_shuffle_within">shuffle_within</code></td>
<td>
<p>character A metadata variable to shuffle cell-donor linkages
within (default=NULL)</p>
</td></tr>
<tr><td><code id="determine_ranks_tucker_+3A_num_iter">num_iter</code></td>
<td>
<p>numeric Number of null iterations (default=100)</p>
</td></tr>
<tr><td><code id="determine_ranks_tucker_+3A_batch_var">batch_var</code></td>
<td>
<p>character A batch variable from metadata to remove. No batch
correction applied if NULL. (default=NULL)</p>
</td></tr>
<tr><td><code id="determine_ranks_tucker_+3A_norm_method">norm_method</code></td>
<td>
<p>character The normalization method to use on the pseudobulked
count data. Set to 'regular' to do standard normalization of dividing by
library size. Set to 'trim' to use edgeR trim-mean normalization, whereby counts
are divided by library size times a normalization factor. (default='trim')</p>
</td></tr>
<tr><td><code id="determine_ranks_tucker_+3A_scale_factor">scale_factor</code></td>
<td>
<p>numeric The number that gets multiplied by fractional counts
during normalization of the pseudobulked data (default=10000)</p>
</td></tr>
<tr><td><code id="determine_ranks_tucker_+3A_scale_var">scale_var</code></td>
<td>
<p>logical TRUE to scale the gene expression variance across donors
for each cell type. If FALSE then all genes are scaled to unit variance across
donors for each cell type. (default=TRUE)</p>
</td></tr>
<tr><td><code id="determine_ranks_tucker_+3A_var_scale_power">var_scale_power</code></td>
<td>
<p>numeric Exponent of normalized variance that is
used for variance scaling. Variance for each gene
is initially set to unit variance across donors (for a given cell type).
Variance for each gene is then scaled by multiplying the unit scaled values
by each gene's normalized variance (where the effect of the mean-variance
dependence is taken into account) to the exponent specified here.
If NULL, uses var_scale_power from container$experiment_params. (default=.5)</p>
</td></tr>
<tr><td><code id="determine_ranks_tucker_+3A_seed">seed</code></td>
<td>
<p>numeric Seed passed to set.seed() (default=container$experiment_params$rand_seed)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The project container with a cowplot figure of rank determination plots in
container$plots$rank_determination_plot.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>test_container &lt;- determine_ranks_tucker(test_container, max_ranks_test=c(3,5),
shuffle_level='tensor', num_iter=4, norm_method='trim', scale_factor=10000,
scale_var=TRUE, var_scale_power=.5)
</code></pre>

<hr>
<h2 id='form_tensor'>Form the pseudobulk tensor as preparation for running the tensor decomposition.</h2><span id='topic+form_tensor'></span>

<h3>Description</h3>

<p>Form the pseudobulk tensor as preparation for running the tensor decomposition.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>form_tensor(
  container,
  donor_min_cells = 5,
  norm_method = "trim",
  scale_factor = 10000,
  vargenes_method = "norm_var",
  vargenes_thresh = 500,
  batch_var = NULL,
  scale_var = TRUE,
  var_scale_power = 0.5,
  custom_genes = NULL,
  verbose = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="form_tensor_+3A_container">container</code></td>
<td>
<p>environment Project container that stores sub-containers
for each cell type as well as results and plots from all analyses</p>
</td></tr>
<tr><td><code id="form_tensor_+3A_donor_min_cells">donor_min_cells</code></td>
<td>
<p>numeric Minimum threshold for number of cells per
donor (default=5)</p>
</td></tr>
<tr><td><code id="form_tensor_+3A_norm_method">norm_method</code></td>
<td>
<p>character The normalization method to use on the pseudobulked
count data. Set to 'regular' to do standard normalization of dividing by
library size. Set to 'trim' to use edgeR trim-mean normalization, whereby counts
are divided by library size times a normalization factor. (default='trim')</p>
</td></tr>
<tr><td><code id="form_tensor_+3A_scale_factor">scale_factor</code></td>
<td>
<p>numeric The number that gets multiplied by fractional counts
during normalization of the pseudobulked data (default=10000)</p>
</td></tr>
<tr><td><code id="form_tensor_+3A_vargenes_method">vargenes_method</code></td>
<td>
<p>character The method by which to select highly variable
genes from each cell type. Set to 'anova' to select genes by anova. Set to
'norm_var' to select the top genes by normalized variance or 'norm_var_pvals'
to select genes by significance of their overdispersion (default='norm_var')</p>
</td></tr>
<tr><td><code id="form_tensor_+3A_vargenes_thresh">vargenes_thresh</code></td>
<td>
<p>numeric The threshold to use in variable gene selection.
For 'anova' and 'norm_var_pvals' this should be a p-value threshold. For 'norm_var' this
should be the number of most variably expressed genes to select from each cell
type (default=500)</p>
</td></tr>
<tr><td><code id="form_tensor_+3A_batch_var">batch_var</code></td>
<td>
<p>character A batch variable from metadata to remove (default=NULL)</p>
</td></tr>
<tr><td><code id="form_tensor_+3A_scale_var">scale_var</code></td>
<td>
<p>logical TRUE to scale the gene expression variance across donors
for each cell type. If FALSE then all genes are scaled to unit variance across
donors for each cell type. (default=TRUE)</p>
</td></tr>
<tr><td><code id="form_tensor_+3A_var_scale_power">var_scale_power</code></td>
<td>
<p>numeric Exponent of normalized variance that is
used for variance scaling. Variance for each gene
is initially set to unit variance across donors (for a given cell type).
Variance for each gene is then scaled by multiplying the unit scaled values
by each gene's normalized variance (where the effect of the mean-variance
dependence is taken into account) to the exponent specified here.
If NULL, uses var_scale_power from container$experiment_params. (default=.5)</p>
</td></tr>
<tr><td><code id="form_tensor_+3A_custom_genes">custom_genes</code></td>
<td>
<p>character A vector of genes to include in the tensor.
Overrides the default gene selection if not NULL. (default=NULL)</p>
</td></tr>
<tr><td><code id="form_tensor_+3A_verbose">verbose</code></td>
<td>
<p>logical Set to TRUE to print out progress (default=TRUE)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The project container with a list of tensor data added in the
container$tensor_data slot.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>test_container &lt;- form_tensor(test_container, donor_min_cells=0,
norm_method='trim', scale_factor=10000, vargenes_method='norm_var', vargenes_thresh=500,
scale_var = TRUE, var_scale_power = 1.5)
</code></pre>

<hr>
<h2 id='get_all_lds_factor_plots'>Generate loadings heatmaps for all factors</h2><span id='topic+get_all_lds_factor_plots'></span>

<h3>Description</h3>

<p>Generate loadings heatmaps for all factors
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_all_lds_factor_plots(
  container,
  use_sig_only = FALSE,
  nonsig_to_zero = FALSE,
  annot = "none",
  pathways_list = NULL,
  sim_de_donor_group = NULL,
  sig_thresh = 0.05,
  display_genes = FALSE,
  gene_callouts = FALSE,
  callout_n_gene_per_ctype = 5,
  callout_ctypes = NULL,
  show_var_explained = TRUE,
  reset_other_factor_plots = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_all_lds_factor_plots_+3A_container">container</code></td>
<td>
<p>environment Project container that stores sub-containers
for each cell type as well as results and plots from all analyses</p>
</td></tr>
<tr><td><code id="get_all_lds_factor_plots_+3A_use_sig_only">use_sig_only</code></td>
<td>
<p>logical If TRUE, includes only significant genes
from jackstraw in the heatmap. If FALSE, includes all the variable genes.
(default = FALSE)</p>
</td></tr>
<tr><td><code id="get_all_lds_factor_plots_+3A_nonsig_to_zero">nonsig_to_zero</code></td>
<td>
<p>logical If TRUE, makes the loadings of all nonsignificant genes 0
(default=FALSE)</p>
</td></tr>
<tr><td><code id="get_all_lds_factor_plots_+3A_annot">annot</code></td>
<td>
<p>character If set to &quot;pathways&quot; then creates an adjacent heatmap
showing which genes are in which pathways. If set to &quot;sig_genes&quot; then creates
an adjacent heatmap showing which genes were significant from jackstraw. If
set to &quot;none&quot; no adjacent heatmap is plotted. (default=&quot;none&quot;)</p>
</td></tr>
<tr><td><code id="get_all_lds_factor_plots_+3A_pathways_list">pathways_list</code></td>
<td>
<p>list A list of sets of pathways for each factor. List index
should be the number corresponding to the factor. (default=NULL)</p>
</td></tr>
<tr><td><code id="get_all_lds_factor_plots_+3A_sim_de_donor_group">sim_de_donor_group</code></td>
<td>
<p>numeric To plot the ground truth significant genes from a
simulation next to the heatmap, put the number of the donor group that corresponds to
the factor being plotted. Here it should be a vector corresponding to the factors.
(default=NULL)</p>
</td></tr>
<tr><td><code id="get_all_lds_factor_plots_+3A_sig_thresh">sig_thresh</code></td>
<td>
<p>numeric Pvalue significance threshold to use. If use_sig_only is
TRUE the threshold is used as a cutoff for genes to include. If annot is &quot;sig_genes&quot;
this value is used in the gene significance colormap as a minimum threshold. (default=0.05)</p>
</td></tr>
<tr><td><code id="get_all_lds_factor_plots_+3A_display_genes">display_genes</code></td>
<td>
<p>logical If TRUE, displays the names of gene names (default=FALSE)</p>
</td></tr>
<tr><td><code id="get_all_lds_factor_plots_+3A_gene_callouts">gene_callouts</code></td>
<td>
<p>logical If TRUE, then adds gene callout annotations to the heatmap
(default=FALSE)</p>
</td></tr>
<tr><td><code id="get_all_lds_factor_plots_+3A_callout_n_gene_per_ctype">callout_n_gene_per_ctype</code></td>
<td>
<p>numeric To use if gene_callouts is TRUE. Sets the number
of largest magnitude significant genes from each cell type to include in gene callouts.
(default=5)</p>
</td></tr>
<tr><td><code id="get_all_lds_factor_plots_+3A_callout_ctypes">callout_ctypes</code></td>
<td>
<p>list To use if gene_callouts is TRUE. Specifies which cell types
to get gene callouts for. Each entry of the list should be a character vector of ctypes for
the respective factor. If NULL, then gets gene callouts for largest magnitude significant
genes for all cell types. (default=NULL)</p>
</td></tr>
<tr><td><code id="get_all_lds_factor_plots_+3A_show_var_explained">show_var_explained</code></td>
<td>
<p>logical If TRUE then shows an anottation with the explained variance
for each cell type (default=TRUE)</p>
</td></tr>
<tr><td><code id="get_all_lds_factor_plots_+3A_reset_other_factor_plots">reset_other_factor_plots</code></td>
<td>
<p>logical If TRUE then removes any existing loadings plots (default=TRUE)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The project container with the list of all loadings heatmap plots placed in 
container$plots$all_lds_plots.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>test_container &lt;- get_all_lds_factor_plots(test_container)
</code></pre>

<hr>
<h2 id='get_callouts_annot'>Get gene callout annotations for a loadings heatmap</h2><span id='topic+get_callouts_annot'></span>

<h3>Description</h3>

<p>Get gene callout annotations for a loadings heatmap
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_callouts_annot(
  container,
  tmp_casted_num,
  factor_select,
  sig_thresh,
  top_n_per_ctype = 5,
  ctypes = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_callouts_annot_+3A_container">container</code></td>
<td>
<p>environment Project container that stores sub-containers
for each cell type as well as results and plots from all analyses</p>
</td></tr>
<tr><td><code id="get_callouts_annot_+3A_tmp_casted_num">tmp_casted_num</code></td>
<td>
<p>matrix The gene by cell type loadings matrix</p>
</td></tr>
<tr><td><code id="get_callouts_annot_+3A_factor_select">factor_select</code></td>
<td>
<p>numeric The factor to investigate</p>
</td></tr>
<tr><td><code id="get_callouts_annot_+3A_sig_thresh">sig_thresh</code></td>
<td>
<p>numeric Pvalue cutoff for significant genes</p>
</td></tr>
<tr><td><code id="get_callouts_annot_+3A_top_n_per_ctype">top_n_per_ctype</code></td>
<td>
<p>numeric The number of significant, largest magnitude
genes from each cell type to generate callouts for (default=5)</p>
</td></tr>
<tr><td><code id="get_callouts_annot_+3A_ctypes">ctypes</code></td>
<td>
<p>character The cell types for which to get the top genes to make
callouts for. If NULL then uses all cell types. (default=NULL)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A HeatmapAnnotation object for the gene callouts.
</p>

<hr>
<h2 id='get_ctype_exp_var'>Get explained variance of the reconstructed data using one cell type from one factor</h2><span id='topic+get_ctype_exp_var'></span>

<h3>Description</h3>

<p>Get explained variance of the reconstructed data using one cell type from one factor
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_ctype_exp_var(container, factor_use, ctype)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_ctype_exp_var_+3A_container">container</code></td>
<td>
<p>environment Project container that stores sub-containers
for each cell type as well as results and plots from all analyses</p>
</td></tr>
<tr><td><code id="get_ctype_exp_var_+3A_factor_use">factor_use</code></td>
<td>
<p>numeric The factor to get variance explained for</p>
</td></tr>
<tr><td><code id="get_ctype_exp_var_+3A_ctype">ctype</code></td>
<td>
<p>character The cell type to get variance explained for</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The explained variance numeric value for one cell type of one factor.
</p>

<hr>
<h2 id='get_ctype_prop_associations'>Compute and plot associations between donor factor scores and donor proportions of major cell types</h2><span id='topic+get_ctype_prop_associations'></span>

<h3>Description</h3>

<p>Compute and plot associations between donor factor scores and donor proportions of major cell types
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_ctype_prop_associations(container, stat_type, n_col = 2)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_ctype_prop_associations_+3A_container">container</code></td>
<td>
<p>environment Project container that stores sub-containers
for each cell type as well as results and plots from all analyses</p>
</td></tr>
<tr><td><code id="get_ctype_prop_associations_+3A_stat_type">stat_type</code></td>
<td>
<p>character Either &quot;fstat&quot; to get F-Statistics, &quot;adj_rsq&quot; to get adjusted
R-squared values, or &quot;adj_pval&quot; to get adjusted pvalues.</p>
</td></tr>
<tr><td><code id="get_ctype_prop_associations_+3A_n_col">n_col</code></td>
<td>
<p>numeric The number of columns to organize the plots into (default=2)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The project container with a cowplot figure of results plots in 
container$plots$ctype_prop_factor_associations.
</p>

<hr>
<h2 id='get_ctype_subc_prop_associations'>Compute and plot associations between donor factor scores and donor proportions of cell subtypes</h2><span id='topic+get_ctype_subc_prop_associations'></span>

<h3>Description</h3>

<p>Compute and plot associations between donor factor scores and donor proportions of cell subtypes
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_ctype_subc_prop_associations(
  container,
  ctype,
  res,
  n_col = 2,
  alt_name = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_ctype_subc_prop_associations_+3A_container">container</code></td>
<td>
<p>environment Project container that stores sub-containers
for each cell type as well as results and plots from all analyses</p>
</td></tr>
<tr><td><code id="get_ctype_subc_prop_associations_+3A_ctype">ctype</code></td>
<td>
<p>character The cell type to get results for</p>
</td></tr>
<tr><td><code id="get_ctype_subc_prop_associations_+3A_res">res</code></td>
<td>
<p>numeric The clustering resolution to retrieve</p>
</td></tr>
<tr><td><code id="get_ctype_subc_prop_associations_+3A_n_col">n_col</code></td>
<td>
<p>numeric The number of columns to organize the plots into (default=2)</p>
</td></tr>
<tr><td><code id="get_ctype_subc_prop_associations_+3A_alt_name">alt_name</code></td>
<td>
<p>character Alternate name for the cell type used in clustering (default=NULL)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The project container with a cowplot figure of results plots in 
container$plots$ctype_prop_factor_associations.
</p>

<hr>
<h2 id='get_ctype_vargenes'>Partition main gene by cell matrix into per cell type matrices with significantly
variable genes only. Generally, this should be done through calling the
form_tensor() wrapper function.</h2><span id='topic+get_ctype_vargenes'></span>

<h3>Description</h3>

<p>Partition main gene by cell matrix into per cell type matrices with significantly
variable genes only. Generally, this should be done through calling the
form_tensor() wrapper function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_ctype_vargenes(
  container,
  method,
  thresh,
  ncores = container$experiment_params$ncores,
  seed = container$experiment_params$rand_seed
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_ctype_vargenes_+3A_container">container</code></td>
<td>
<p>environment Project container that stores sub-containers
for each cell type as well as results and plots from all analyses</p>
</td></tr>
<tr><td><code id="get_ctype_vargenes_+3A_method">method</code></td>
<td>
<p>character The method used to select significantly variable
genes across donors within a cell type. Can be either &quot;anova&quot; to use basic
anova with cells grouped by donor or &quot;norm_var&quot; to get the top overdispersed
genes by normalized variance. Set to &quot;norm_var_pvals&quot; to use normalized variance
p-values as calculated in pagoda2.</p>
</td></tr>
<tr><td><code id="get_ctype_vargenes_+3A_thresh">thresh</code></td>
<td>
<p>numeric A pvalue threshold to use for gene significance when
method is set to &quot;anova&quot; or &quot;empir&quot;. For the method &quot;norm_var&quot; thresh is the
number of top overdispersed genes from each cell type to include.</p>
</td></tr>
<tr><td><code id="get_ctype_vargenes_+3A_ncores">ncores</code></td>
<td>
<p>numeric The number of cores to use (default=container$experiment_params$ncores)</p>
</td></tr>
<tr><td><code id="get_ctype_vargenes_+3A_seed">seed</code></td>
<td>
<p>numeric Seed passed to set.seed() (default=container$experiment_params$rand_seed)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The project container with pseudobulk matrices limted to the selected 
most variable genes.
</p>

<hr>
<h2 id='get_donor_meta'>Get metadata matrix of dimensions donors by variables (not per cell)</h2><span id='topic+get_donor_meta'></span>

<h3>Description</h3>

<p>Get metadata matrix of dimensions donors by variables (not per cell)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_donor_meta(container, additional_meta = NULL, only_analyzed = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_donor_meta_+3A_container">container</code></td>
<td>
<p>environment Project container that stores sub-containers
for each cell type as well as results and plots from all analyses</p>
</td></tr>
<tr><td><code id="get_donor_meta_+3A_additional_meta">additional_meta</code></td>
<td>
<p>character A vector of other variables to include (default=NULL)</p>
</td></tr>
<tr><td><code id="get_donor_meta_+3A_only_analyzed">only_analyzed</code></td>
<td>
<p>logical Set to TRUE to only include donors that were included
in the formed tensor, otherwise set to FALSE (default=TRUE)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The project container with metadata per donor (not per cell) in container$donor_metadata.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>test_container &lt;- get_donor_meta(test_container, additional_meta='lanes')
</code></pre>

<hr>
<h2 id='get_factor_exp_var'>Get the explained variance of the reconstructed data using one factor</h2><span id='topic+get_factor_exp_var'></span>

<h3>Description</h3>

<p>Get the explained variance of the reconstructed data using one factor
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_factor_exp_var(container, factor_use)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_factor_exp_var_+3A_container">container</code></td>
<td>
<p>environment Project container that stores sub-containers
for each cell type as well as results and plots from all analyses</p>
</td></tr>
<tr><td><code id="get_factor_exp_var_+3A_factor_use">factor_use</code></td>
<td>
<p>numeric The factor to investigate</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The explained variance numeric value for one factor.
</p>

<hr>
<h2 id='get_fstats_pvals'>Calculate adjusted p-values for gene_celltype fiber-donor score associations</h2><span id='topic+get_fstats_pvals'></span>

<h3>Description</h3>

<p>Calculate adjusted p-values for gene_celltype fiber-donor score associations
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_fstats_pvals(fstats_real, fstats_shuffled)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_fstats_pvals_+3A_fstats_real">fstats_real</code></td>
<td>
<p>numeric A vector of F-Statistics for gene-cell type-factor combinations</p>
</td></tr>
<tr><td><code id="get_fstats_pvals_+3A_fstats_shuffled">fstats_shuffled</code></td>
<td>
<p>numeric A vector of null F-Statistics</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector of adjusted p-values for associations of the unshuffled fibers with
factor donor scores.
</p>

<hr>
<h2 id='get_gene_modules'>Compute WGCNA gene modules for each cell type</h2><span id='topic+get_gene_modules'></span>

<h3>Description</h3>

<p>Compute WGCNA gene modules for each cell type
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_gene_modules(container, sft_thresh)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_gene_modules_+3A_container">container</code></td>
<td>
<p>environment Project container that stores sub-containers
for each cell type as well as results and plots from all analyses</p>
</td></tr>
<tr><td><code id="get_gene_modules_+3A_sft_thresh">sft_thresh</code></td>
<td>
<p>numeric A vector indicating the soft threshold to use for
each cell type. Length should be the same as container$experiment_params$ctypes_use</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The project container with WGCNA gene co-expression modules added. The
module eigengenes for each cell type are in container$module_eigengenes, and the
module genes for each cell type are in container$module_genes.
</p>

<hr>
<h2 id='get_gene_set_vectors'>Get logical vectors indicating which genes are in which pathways</h2><span id='topic+get_gene_set_vectors'></span>

<h3>Description</h3>

<p>Get logical vectors indicating which genes are in which pathways
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_gene_set_vectors(container, gene_sets, tmp_casted_num)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_gene_set_vectors_+3A_container">container</code></td>
<td>
<p>environment Project container that stores sub-containers
for each cell type as well as results and plots from all analyses</p>
</td></tr>
<tr><td><code id="get_gene_set_vectors_+3A_gene_sets">gene_sets</code></td>
<td>
<p>character Vector of gene sets to extract genes for</p>
</td></tr>
<tr><td><code id="get_gene_set_vectors_+3A_tmp_casted_num">tmp_casted_num</code></td>
<td>
<p>matrix The gene by cell type loadings matrix</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of the logical vectors for each pathway.
</p>

<hr>
<h2 id='get_indv_subtype_associations'>Compute subtype proportion-factor association p-values for all subclusters of
a given major cell type</h2><span id='topic+get_indv_subtype_associations'></span>

<h3>Description</h3>

<p>Compute subtype proportion-factor association p-values for all subclusters of
a given major cell type
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_indv_subtype_associations(container, donor_props, factor_select)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_indv_subtype_associations_+3A_container">container</code></td>
<td>
<p>environment Project container that stores sub-containers
for each cell type as well as results and plots from all analyses</p>
</td></tr>
<tr><td><code id="get_indv_subtype_associations_+3A_donor_props">donor_props</code></td>
<td>
<p>matrix Donor proportions of subtypes</p>
</td></tr>
<tr><td><code id="get_indv_subtype_associations_+3A_factor_select">factor_select</code></td>
<td>
<p>numeric The factor to get associations for</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector of association statistics each cell subtype against a
selected factor.
</p>

<hr>
<h2 id='get_intersecting_pathways'>Extract the intersection of gene sets which are enriched in two or more cell types for a factor</h2><span id='topic+get_intersecting_pathways'></span>

<h3>Description</h3>

<p>Extract the intersection of gene sets which are enriched in two or more cell types for a factor
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_intersecting_pathways(
  container,
  factor_select,
  these_ctypes_only,
  up_down,
  thresh = 0.05
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_intersecting_pathways_+3A_container">container</code></td>
<td>
<p>environment Project container that stores sub-containers
for each cell type as well as results and plots from all analyses</p>
</td></tr>
<tr><td><code id="get_intersecting_pathways_+3A_factor_select">factor_select</code></td>
<td>
<p>numeric The factor to investigate</p>
</td></tr>
<tr><td><code id="get_intersecting_pathways_+3A_these_ctypes_only">these_ctypes_only</code></td>
<td>
<p>character A vector of cell types for which to get gene sets that are
enriched in all of these and not in any other cell types</p>
</td></tr>
<tr><td><code id="get_intersecting_pathways_+3A_up_down">up_down</code></td>
<td>
<p>character Set to &quot;up&quot; to get the gene sets for the positive loading genes. Set
to &quot;down&quot; to get the gene sets for the negative loadings genes.</p>
</td></tr>
<tr><td><code id="get_intersecting_pathways_+3A_thresh">thresh</code></td>
<td>
<p>numeric Pvalue significance threshold for selecting enriched sets (default=0.05)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector of the intersection of pathways that are significantly enriched in two
or more cell types for a factor.
</p>

<hr>
<h2 id='get_leading_edge_genes'>Get the leading edge genes from GSEA results</h2><span id='topic+get_leading_edge_genes'></span>

<h3>Description</h3>

<p>Get the leading edge genes from GSEA results
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_leading_edge_genes(container, factor_select, gsets, num_genes_per = 5)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_leading_edge_genes_+3A_container">container</code></td>
<td>
<p>environment Project container that stores sub-containers
for each cell type as well as results and plots from all analyses</p>
</td></tr>
<tr><td><code id="get_leading_edge_genes_+3A_factor_select">factor_select</code></td>
<td>
<p>numeric The factor to get results for</p>
</td></tr>
<tr><td><code id="get_leading_edge_genes_+3A_gsets">gsets</code></td>
<td>
<p>character A vector of gene set names to get leading edge genes for.</p>
</td></tr>
<tr><td><code id="get_leading_edge_genes_+3A_num_genes_per">num_genes_per</code></td>
<td>
<p>numeric The maximum number of leading edge genes to get for
each gene set (default=5)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A named character vector of gene sets, with leading edge genes as the names.
</p>

<hr>
<h2 id='get_lm_pvals'>Compute gene-factor associations using univariate linear models</h2><span id='topic+get_lm_pvals'></span>

<h3>Description</h3>

<p>Compute gene-factor associations using univariate linear models
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_lm_pvals(container, n.cores = container$experiment_params$ncores)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_lm_pvals_+3A_container">container</code></td>
<td>
<p>environment Project container that stores sub-containers
for each cell type as well as results and plots from all analyses</p>
</td></tr>
<tr><td><code id="get_lm_pvals_+3A_n.cores">n.cores</code></td>
<td>
<p>Number of cores to use (default = container$experiment_params$ncores)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The project container with a vector of adjusted p-values for the gene-factor
associations in container$gene_score_associations.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>test_container &lt;- get_lm_pvals(test_container, n.cores=1)
</code></pre>

<hr>
<h2 id='get_max_correlations'>Computes the max correlation between each factor of the decomposition done using
the whole dataset to each factor computed using the subsampled/bootstrapped dataset</h2><span id='topic+get_max_correlations'></span>

<h3>Description</h3>

<p>Computes the max correlation between each factor of the decomposition done using
the whole dataset to each factor computed using the subsampled/bootstrapped dataset
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_max_correlations(res_full, res_sub, res_use)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_max_correlations_+3A_res_full">res_full</code></td>
<td>
<p>matrix Either the donor scores or loadings matrix from the original
decomposition</p>
</td></tr>
<tr><td><code id="get_max_correlations_+3A_res_sub">res_sub</code></td>
<td>
<p>matrix Either the donor scores or loadings matrix from the new
decomposition</p>
</td></tr>
<tr><td><code id="get_max_correlations_+3A_res_use">res_use</code></td>
<td>
<p>character Can either be 'loadings' or 'dscores' and should correspond
with the data matrix used</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a vector of the max correlations for each original factor
</p>

<hr>
<h2 id='get_meta_associations'>Get metadata associations with factor donor scores</h2><span id='topic+get_meta_associations'></span>

<h3>Description</h3>

<p>Get metadata associations with factor donor scores
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_meta_associations(container, vars_test, stat_use = "rsq")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_meta_associations_+3A_container">container</code></td>
<td>
<p>environment Project container that stores sub-containers
for each cell type as well as results and plots from all analyses</p>
</td></tr>
<tr><td><code id="get_meta_associations_+3A_vars_test">vars_test</code></td>
<td>
<p>character The names of meta variables to get associations for</p>
</td></tr>
<tr><td><code id="get_meta_associations_+3A_stat_use">stat_use</code></td>
<td>
<p>character Set to either 'rsq' to get r-squared values or 'pval'
to get adjusted pvalues (default='rsq)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The project container with a matrix of metadata associations with each factor
in container$meta_associations.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>test_container &lt;- get_meta_associations(test_container, vars_test='lanes', stat_use='pval')
</code></pre>

<hr>
<h2 id='get_min_sig_genes'>Evaluate the minimum number for significant genes in any factor for a given number of
factors extracted by the decomposition</h2><span id='topic+get_min_sig_genes'></span>

<h3>Description</h3>

<p>Evaluate the minimum number for significant genes in any factor for a given number of
factors extracted by the decomposition
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_min_sig_genes(
  container,
  donor_rank_range,
  gene_ranks,
  use_lm = TRUE,
  tucker_type = "regular",
  rotation_type = "hybrid",
  n_fibers = 100,
  n_iter = 500,
  n.cores = container$experiment_params$ncores,
  thresh = 0.05
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_min_sig_genes_+3A_container">container</code></td>
<td>
<p>environment Project container that stores sub-containers
for each cell type as well as results and plots from all analyses. Should have</p>
</td></tr>
<tr><td><code id="get_min_sig_genes_+3A_donor_rank_range">donor_rank_range</code></td>
<td>
<p>numeric Range of possible number of donor factors to use.</p>
</td></tr>
<tr><td><code id="get_min_sig_genes_+3A_gene_ranks">gene_ranks</code></td>
<td>
<p>numeric The number of gene ranks to use in the decomposition</p>
</td></tr>
<tr><td><code id="get_min_sig_genes_+3A_use_lm">use_lm</code></td>
<td>
<p>logical Set to true to use get_lm_pvals otherwise uses jackstraw (default=TRUE)</p>
</td></tr>
<tr><td><code id="get_min_sig_genes_+3A_tucker_type">tucker_type</code></td>
<td>
<p>character Set to 'regular' to run regular tucker or to 'sparse' to run tucker
with sparsity constraints (default='regular')</p>
</td></tr>
<tr><td><code id="get_min_sig_genes_+3A_rotation_type">rotation_type</code></td>
<td>
<p>character Set to 'hybrid' to perform hybrid rotation on resulting donor factor
matrix and loadings. Otherwise set to 'ica_lds' to perform ica rotation on loadings or
ica_dsc to perform ica on donor scores. (default='hybrid')</p>
</td></tr>
<tr><td><code id="get_min_sig_genes_+3A_n_fibers">n_fibers</code></td>
<td>
<p>numeric The number of fibers the randomly shuffle in each jackstraw iteration
(default=100)</p>
</td></tr>
<tr><td><code id="get_min_sig_genes_+3A_n_iter">n_iter</code></td>
<td>
<p>numeric The number of jackstraw shuffling iterations to complete (default=500)</p>
</td></tr>
<tr><td><code id="get_min_sig_genes_+3A_n.cores">n.cores</code></td>
<td>
<p>Number of cores to use in get_lm_pvals() (default = container$experiment_params$ncores)</p>
</td></tr>
<tr><td><code id="get_min_sig_genes_+3A_thresh">thresh</code></td>
<td>
<p>numeric Pvalue threshold for significant genes in calculating the
number of significant genes identified per factor. (default=0.05)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The project container with a plot of the minimum significant genes for
each decomposition with varying number of donor factors located in
container$plots$min_sig_genes.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>test_container &lt;- get_min_sig_genes(test_container, donor_rank_range=c(2:4),
gene_ranks=4, tucker_type='regular', rotation_type='hybrid', n.cores=1)
</code></pre>

<hr>
<h2 id='get_module_enr'>Identify gene sets that are enriched within specified gene co-regulatory modules.
Uses a hypergeometric test for over-representation. Used in plot_multi_module_enr().</h2><span id='topic+get_module_enr'></span>

<h3>Description</h3>

<p>Identify gene sets that are enriched within specified gene co-regulatory modules.
Uses a hypergeometric test for over-representation. Used in plot_multi_module_enr().
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_module_enr(container, ctype, mod_select, db_use = "GO", adjust_pval = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_module_enr_+3A_container">container</code></td>
<td>
<p>environment Project container that stores sub-containers
for each cell type as well as results and plots from all analyses</p>
</td></tr>
<tr><td><code id="get_module_enr_+3A_ctype">ctype</code></td>
<td>
<p>character The name of cell type for the cell type module to test</p>
</td></tr>
<tr><td><code id="get_module_enr_+3A_mod_select">mod_select</code></td>
<td>
<p>numeric The module number for the cell type module to test</p>
</td></tr>
<tr><td><code id="get_module_enr_+3A_db_use">db_use</code></td>
<td>
<p>character The database of gene sets to use. Database
options include &quot;GO&quot;, &quot;Reactome&quot;, &quot;KEGG&quot;, &quot;BioCarta&quot;, &quot;Hallmark&quot;, &quot;TF&quot;, and
&quot;immuno&quot;. More than one database can be used. (default=&quot;GO&quot;)</p>
</td></tr>
<tr><td><code id="get_module_enr_+3A_adjust_pval">adjust_pval</code></td>
<td>
<p>logical Set to TRUE to apply FDR correction (default=TRUE)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector of p-values for the tested gene sets.
</p>

<hr>
<h2 id='get_normalized_variance'>Get normalized variance for each gene, taking into account mean-variance trend</h2><span id='topic+get_normalized_variance'></span>

<h3>Description</h3>

<p>Get normalized variance for each gene, taking into account mean-variance trend
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_normalized_variance(container)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_normalized_variance_+3A_container">container</code></td>
<td>
<p>environment Project container that stores sub-containers
for each cell type as well as results and plots from all analyses</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The project container with vectors of normalized variances values in scMinimal objects
for each cell type. Generally, this should be done through calling the
form_tensor() wrapper function.
</p>

<hr>
<h2 id='get_num_batch_ranks'>Plot factor-batch associations for increasing number of donor factors</h2><span id='topic+get_num_batch_ranks'></span>

<h3>Description</h3>

<p>Plot factor-batch associations for increasing number of donor factors
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_num_batch_ranks(
  container,
  donor_ranks_test,
  gene_ranks,
  batch_var,
  thresh = 0.5,
  tucker_type = "regular",
  rotation_type = "hybrid"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_num_batch_ranks_+3A_container">container</code></td>
<td>
<p>environment Project container that stores sub-containers
for each cell type as well as results and plots from all analyses</p>
</td></tr>
<tr><td><code id="get_num_batch_ranks_+3A_donor_ranks_test">donor_ranks_test</code></td>
<td>
<p>numeric The number of donor rank values to test</p>
</td></tr>
<tr><td><code id="get_num_batch_ranks_+3A_gene_ranks">gene_ranks</code></td>
<td>
<p>numeric The number of gene ranks to use throughout</p>
</td></tr>
<tr><td><code id="get_num_batch_ranks_+3A_batch_var">batch_var</code></td>
<td>
<p>character The name of the batch meta variable</p>
</td></tr>
<tr><td><code id="get_num_batch_ranks_+3A_thresh">thresh</code></td>
<td>
<p>numeric The threshold r-squared cutoff for considering a
factor to be a batch factor. Can be a vector of multiple values to get plots
at varying thresholds. (default=0.5)</p>
</td></tr>
<tr><td><code id="get_num_batch_ranks_+3A_tucker_type">tucker_type</code></td>
<td>
<p>character Set to 'regular' to run regular tucker or to 'sparse' to run tucker
with sparsity constraints (default='regular')</p>
</td></tr>
<tr><td><code id="get_num_batch_ranks_+3A_rotation_type">rotation_type</code></td>
<td>
<p>character Set to 'hybrid' to optimize loadings via our hybrid
method (see paper for details). Set to 'ica_dsc' to perform ICA rotation
on resulting donor factor matrix. Set to 'ica_lds' to optimize loadings by the
ICA rotation. (default='hybrid')</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A ggpubr figure of ggplot objects showing batch-factor associations and
placed in container$plots$num_batch_factors slot
</p>


<h3>Examples</h3>

<pre><code class='language-R'>test_container &lt;- get_num_batch_ranks(test_container, donor_ranks_test=c(2:4), 
gene_ranks=10, batch_var='lanes', thresh=0.5, tucker_type='regular', rotation_type='hybrid')
</code></pre>

<hr>
<h2 id='get_one_factor'>Get the donor scores and loadings matrix for a single-factor</h2><span id='topic+get_one_factor'></span>

<h3>Description</h3>

<p>Get the donor scores and loadings matrix for a single-factor
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_one_factor(container, factor_select)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_one_factor_+3A_container">container</code></td>
<td>
<p>environment Project container that stores sub-containers
for each cell type as well as results and plots from all analyses</p>
</td></tr>
<tr><td><code id="get_one_factor_+3A_factor_select">factor_select</code></td>
<td>
<p>numeric The number corresponding to the factor to extract</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with the first element as the donor scores and the second element
as the corresponding loadings matrix for one factor.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>f1_res &lt;- get_one_factor(test_container, factor_select=1)
</code></pre>

<hr>
<h2 id='get_one_factor_gene_pvals'>Get significant genes for a factor</h2><span id='topic+get_one_factor_gene_pvals'></span>

<h3>Description</h3>

<p>Get significant genes for a factor
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_one_factor_gene_pvals(container, factor_select)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_one_factor_gene_pvals_+3A_container">container</code></td>
<td>
<p>environment Project container that stores sub-containers
for each cell type as well as results and plots from all analyses</p>
</td></tr>
<tr><td><code id="get_one_factor_gene_pvals_+3A_factor_select">factor_select</code></td>
<td>
<p>numeric The number corresponding to the factor to extract</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A gene by cell type matrix of gene significance p-values for a factor
</p>

<hr>
<h2 id='get_pseudobulk'>Collapse data from cell-level to donor-level via summing counts. Generally, this should be done through calling the
form_tensor() wrapper function.</h2><span id='topic+get_pseudobulk'></span>

<h3>Description</h3>

<p>Collapse data from cell-level to donor-level via summing counts. Generally, this should be done through calling the
form_tensor() wrapper function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_pseudobulk(container, shuffle = FALSE, shuffle_within = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_pseudobulk_+3A_container">container</code></td>
<td>
<p>environment Project container that stores sub-containers
for each cell type as well as results and plots from all analyses</p>
</td></tr>
<tr><td><code id="get_pseudobulk_+3A_shuffle">shuffle</code></td>
<td>
<p>logical Set to TRUE to shuffle cell-donor linkages (default=FALSE)</p>
</td></tr>
<tr><td><code id="get_pseudobulk_+3A_shuffle_within">shuffle_within</code></td>
<td>
<p>character A metadata variable to shuffle cell-donor linkages
within (default=NULL)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The project container with pseudobulked count matrices in
container$scMinimal_ctype$&lt;ctype&gt;$pseudobulk slots for each cell type.
</p>

<hr>
<h2 id='get_real_fstats'>Get F-Statistics for the real (non-shuffled) gene_ctype fibers</h2><span id='topic+get_real_fstats'></span>

<h3>Description</h3>

<p>Get F-Statistics for the real (non-shuffled) gene_ctype fibers
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_real_fstats(container, ncores)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_real_fstats_+3A_container">container</code></td>
<td>
<p>environment Project container that stores sub-containers
for each cell type as well as results and plots from all analyses</p>
</td></tr>
<tr><td><code id="get_real_fstats_+3A_ncores">ncores</code></td>
<td>
<p>numeric The number of cores to use</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector F-statistics for each gene_celltype-factor association of the
unshuffled data.
</p>

<hr>
<h2 id='get_reconstruct_errors_svd'>Calculate reconstruction errors using svd approach</h2><span id='topic+get_reconstruct_errors_svd'></span>

<h3>Description</h3>

<p>Calculate reconstruction errors using svd approach
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_reconstruct_errors_svd(tnsr, max_ranks_test, shuffle_tensor)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_reconstruct_errors_svd_+3A_tnsr">tnsr</code></td>
<td>
<p>array A 3-dimensional array with dimensions of
donors, genes, and cell types in that order</p>
</td></tr>
<tr><td><code id="get_reconstruct_errors_svd_+3A_max_ranks_test">max_ranks_test</code></td>
<td>
<p>numeric Vector of length 3 with maximum number of
ranks to test for donor, gene, and cell type modes in that order</p>
</td></tr>
<tr><td><code id="get_reconstruct_errors_svd_+3A_shuffle_tensor">shuffle_tensor</code></td>
<td>
<p>logical Set to TRUE to shuffle values within the tensor</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of reconstruction errors for each mode of the tensor.
</p>

<hr>
<h2 id='get_significance_vectors'>Get vectors indicating which genes are significant in which cell types
for a factor of interest</h2><span id='topic+get_significance_vectors'></span>

<h3>Description</h3>

<p>Get vectors indicating which genes are significant in which cell types
for a factor of interest
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_significance_vectors(container, factor_select, ctypes)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_significance_vectors_+3A_container">container</code></td>
<td>
<p>environment Project container that stores sub-containers
for each cell type as well as results and plots from all analyses</p>
</td></tr>
<tr><td><code id="get_significance_vectors_+3A_factor_select">factor_select</code></td>
<td>
<p>numeric The factor to query</p>
</td></tr>
<tr><td><code id="get_significance_vectors_+3A_ctypes">ctypes</code></td>
<td>
<p>character The cell types used in all the analysis ordered
as they appear in the loadings matrix</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of the adjusted p-values for expression of each gene in each cell type in
association with a factor of interest.
</p>

<hr>
<h2 id='get_subclust_de_hmaps'>Get list of cell subtype differential expression heatmaps</h2><span id='topic+get_subclust_de_hmaps'></span>

<h3>Description</h3>

<p>Get list of cell subtype differential expression heatmaps
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_subclust_de_hmaps(container, all_ctypes, all_res)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_subclust_de_hmaps_+3A_container">container</code></td>
<td>
<p>environment Project container that stores sub-containers
for each cell type as well as results and plots from all analyses</p>
</td></tr>
<tr><td><code id="get_subclust_de_hmaps_+3A_all_ctypes">all_ctypes</code></td>
<td>
<p>character A vector of the cell types to include</p>
</td></tr>
<tr><td><code id="get_subclust_de_hmaps_+3A_all_res">all_res</code></td>
<td>
<p>numeric A vector of resolutions matching the all_ctypes parameter</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of cell subcluster DE marker gene heatmaps as grob objects.
</p>

<hr>
<h2 id='get_subclust_enr_dotplot'>Get scatter plot for association of a cell subtype proportion with scores for a factor</h2><span id='topic+get_subclust_enr_dotplot'></span>

<h3>Description</h3>

<p>Get scatter plot for association of a cell subtype proportion with scores for a factor
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_subclust_enr_dotplot(
  container,
  ctype,
  res,
  subtype,
  factor_use,
  ctype_cur = ctype
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_subclust_enr_dotplot_+3A_container">container</code></td>
<td>
<p>environment Project container that stores sub-containers
for each cell type as well as results and plots from all analyses</p>
</td></tr>
<tr><td><code id="get_subclust_enr_dotplot_+3A_ctype">ctype</code></td>
<td>
<p>character The cell type to plot</p>
</td></tr>
<tr><td><code id="get_subclust_enr_dotplot_+3A_res">res</code></td>
<td>
<p>numeric The subcluster resolution to use</p>
</td></tr>
<tr><td><code id="get_subclust_enr_dotplot_+3A_subtype">subtype</code></td>
<td>
<p>numeric The number corresponding with the subtype of the major
cell type to plot</p>
</td></tr>
<tr><td><code id="get_subclust_enr_dotplot_+3A_factor_use">factor_use</code></td>
<td>
<p>numeric The factor to plot</p>
</td></tr>
<tr><td><code id="get_subclust_enr_dotplot_+3A_ctype_cur">ctype_cur</code></td>
<td>
<p>character The name of the major cell type used in the main analysis</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A ggplot object of each donor's cell subcluster proportions against donor
scores for a selected factor.
</p>

<hr>
<h2 id='get_subclust_enr_fig'>Get a figure showing cell subtype proportion associations with each factor. Combines
this plot with subtype UMAPs and differential expression heatmaps. Note that this
function runs better if the number of cores in the conos object in
container$embedding has n.cores set to a relatively small value &lt; 10.</h2><span id='topic+get_subclust_enr_fig'></span>

<h3>Description</h3>

<p>Get a figure showing cell subtype proportion associations with each factor. Combines
this plot with subtype UMAPs and differential expression heatmaps. Note that this
function runs better if the number of cores in the conos object in
container$embedding has n.cores set to a relatively small value &lt; 10.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_subclust_enr_fig(container, all_ctypes, all_res)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_subclust_enr_fig_+3A_container">container</code></td>
<td>
<p>environment Project container that stores sub-containers
for each cell type as well as results and plots from all analyses</p>
</td></tr>
<tr><td><code id="get_subclust_enr_fig_+3A_all_ctypes">all_ctypes</code></td>
<td>
<p>character A vector of the cell types to include</p>
</td></tr>
<tr><td><code id="get_subclust_enr_fig_+3A_all_res">all_res</code></td>
<td>
<p>numeric A vector of resolutions matching the all_ctypes parameter</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A cowplot figure placed in the slot container$plots$subc_fig.
</p>

<hr>
<h2 id='get_subclust_enr_hmap'>Get heatmap of subtype proportion associations for each celltype/subtype and each factor</h2><span id='topic+get_subclust_enr_hmap'></span>

<h3>Description</h3>

<p>Get heatmap of subtype proportion associations for each celltype/subtype and each factor
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_subclust_enr_hmap(container, all_ctypes, all_res, all_factors)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_subclust_enr_hmap_+3A_container">container</code></td>
<td>
<p>environment Project container that stores sub-containers
for each cell type as well as results and plots from all analyses</p>
</td></tr>
<tr><td><code id="get_subclust_enr_hmap_+3A_all_ctypes">all_ctypes</code></td>
<td>
<p>character A vector of the cell types to include</p>
</td></tr>
<tr><td><code id="get_subclust_enr_hmap_+3A_all_res">all_res</code></td>
<td>
<p>numeric A vector of resolutions matching the all_ctypes parameter</p>
</td></tr>
<tr><td><code id="get_subclust_enr_hmap_+3A_all_factors">all_factors</code></td>
<td>
<p>numerc A vector of the factors to compute associations for</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A ComplexHeatmap object in container$plots$subc_enr_hmap showing the
univariate associations between cell subcluster proportions and each factor.
</p>

<hr>
<h2 id='get_subclust_umap'>Get a figure to display subclusterings at multiple resolutions</h2><span id='topic+get_subclust_umap'></span>

<h3>Description</h3>

<p>Get a figure to display subclusterings at multiple resolutions
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_subclust_umap(container, all_ctypes, all_res, n_col = 3)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_subclust_umap_+3A_container">container</code></td>
<td>
<p>environment Project container that stores sub-containers
for each cell type as well as results and plots from all analyses</p>
</td></tr>
<tr><td><code id="get_subclust_umap_+3A_all_ctypes">all_ctypes</code></td>
<td>
<p>character A vector of the cell types to include</p>
</td></tr>
<tr><td><code id="get_subclust_umap_+3A_all_res">all_res</code></td>
<td>
<p>numeric A vector of resolutions matching the all_ctypes parameter</p>
</td></tr>
<tr><td><code id="get_subclust_umap_+3A_n_col">n_col</code></td>
<td>
<p>numeric The number of columns to organize the figure into (default=3)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The project container with a cowplot figure of all UMAP plots in
container$plots$subc_umap_fig and the individual umap plots in container$plots$subc_umaps
</p>

<hr>
<h2 id='get_subclusters'>Perform leiden subclustering to get cell subtypes</h2><span id='topic+get_subclusters'></span>

<h3>Description</h3>

<p>Perform leiden subclustering to get cell subtypes
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_subclusters(
  container,
  ctype,
  resolution,
  min_cells_group = 50,
  small_clust_action = "merge"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_subclusters_+3A_container">container</code></td>
<td>
<p>environment Project container that stores sub-containers
for each cell type as well as results and plots from all analyses</p>
</td></tr>
<tr><td><code id="get_subclusters_+3A_ctype">ctype</code></td>
<td>
<p>character The cell type to do subclustering for</p>
</td></tr>
<tr><td><code id="get_subclusters_+3A_resolution">resolution</code></td>
<td>
<p>numeric The leiden resolution to use</p>
</td></tr>
<tr><td><code id="get_subclusters_+3A_min_cells_group">min_cells_group</code></td>
<td>
<p>numeric The minimum allowable cluster size (default=50)</p>
</td></tr>
<tr><td><code id="get_subclusters_+3A_small_clust_action">small_clust_action</code></td>
<td>
<p>character Either 'remove' to remove subclusters or
'merge' to merge clusters below min_cells_group threshold to the nearest cluster
above the size threshold (default='merge')</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector of cell subclusters.
</p>

<hr>
<h2 id='get_subtype_prop_associations'>Compute and plot associations between factor scores and cell subtype composition
for various clustering resolution parameters</h2><span id='topic+get_subtype_prop_associations'></span>

<h3>Description</h3>

<p>Compute and plot associations between factor scores and cell subtype composition
for various clustering resolution parameters
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_subtype_prop_associations(
  container,
  max_res,
  stat_type,
  integration_var = NULL,
  min_cells_group = 50,
  use_existing_subc = FALSE,
  alt_ct_names = NULL,
  n_col = 2
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_subtype_prop_associations_+3A_container">container</code></td>
<td>
<p>environment Project container that stores sub-containers
for each cell type as well as results and plots from all analyses</p>
</td></tr>
<tr><td><code id="get_subtype_prop_associations_+3A_max_res">max_res</code></td>
<td>
<p>numeric The maximum clustering resolution to use. Minimum is 0.5.</p>
</td></tr>
<tr><td><code id="get_subtype_prop_associations_+3A_stat_type">stat_type</code></td>
<td>
<p>character Either &quot;fstat&quot; to get F-Statistics, &quot;adj_rsq&quot; to get adjusted
R-squared values, or &quot;adj_pval&quot; to get adjusted pvalues.</p>
</td></tr>
<tr><td><code id="get_subtype_prop_associations_+3A_integration_var">integration_var</code></td>
<td>
<p>character The meta data variable to use for creating
the joint embedding with Conos if not already provided in container$embedding (default=NULL)</p>
</td></tr>
<tr><td><code id="get_subtype_prop_associations_+3A_min_cells_group">min_cells_group</code></td>
<td>
<p>numeric The minimum allowable size for cell subpopulations
(default=50)</p>
</td></tr>
<tr><td><code id="get_subtype_prop_associations_+3A_use_existing_subc">use_existing_subc</code></td>
<td>
<p>logical Set to TRUE to use existing subcluster annotations
(default=FALSE)</p>
</td></tr>
<tr><td><code id="get_subtype_prop_associations_+3A_alt_ct_names">alt_ct_names</code></td>
<td>
<p>character Cell type names used in clustering if different from those
used in the main analysis. Should match the order of container$experiment_params$ctypes_use.
(default=NULL)</p>
</td></tr>
<tr><td><code id="get_subtype_prop_associations_+3A_n_col">n_col</code></td>
<td>
<p>numeric The number of columns to organize the plots into (default=2)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The project container with a cowplot figure of cell subtype proportion-factor
association results plots in container$plots$subtype_prop_factor_associations.
</p>

<hr>
<h2 id='get_sums'>Calculates factor-stratified sums for each column. Adapted from pagoda2.
https://github.com/kharchenkolab/pagoda2/blob/main/src/misc2.cpp</h2><span id='topic+get_sums'></span>

<h3>Description</h3>

<p>Calculates factor-stratified sums for each column. Adapted from pagoda2.
https://github.com/kharchenkolab/pagoda2/blob/main/src/misc2.cpp
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_sums(sY, rowSel)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_sums_+3A_sy">sY</code></td>
<td>
<p>sparse matrix Gene by cell matrix of counts</p>
</td></tr>
<tr><td><code id="get_sums_+3A_rowsel">rowSel</code></td>
<td>
<p>factor The donor that each cell is from</p>
</td></tr>
</table>


<h3>Value</h3>

<p>matrix of summed counts per gene per sample
</p>

<hr>
<h2 id='ht_clusters'>Visualize the similarity matrix and the clustering. Adapted from simplifyEnrichment package.
https://github.com/jokergoo/simplifyEnrichment/blob/master/R/ht_clusters.R</h2><span id='topic+ht_clusters'></span>

<h3>Description</h3>

<p>Visualize the similarity matrix and the clustering. Adapted from simplifyEnrichment package.
https://github.com/jokergoo/simplifyEnrichment/blob/master/R/ht_clusters.R
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ht_clusters(
  mat,
  cl,
  dend = NULL,
  col = c("white", "red"),
  draw_word_cloud = is_GO_id(rownames(mat)[1]) || !is.null(term),
  term = NULL,
  min_term = 5,
  order_by_size = FALSE,
  exclude_words = character(0),
  max_words = 10,
  word_cloud_grob_param = list(),
  fontsize_range = c(4, 16),
  column_title = NULL,
  ht_list = NULL,
  use_raster = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ht_clusters_+3A_mat">mat</code></td>
<td>
<p>A similarity matrix.</p>
</td></tr>
<tr><td><code id="ht_clusters_+3A_cl">cl</code></td>
<td>
<p>Cluster labels inferred from the similarity matrix, e.g. from 'cluster_terms' or 'binary_cut'.</p>
</td></tr>
<tr><td><code id="ht_clusters_+3A_dend">dend</code></td>
<td>
<p>Used internally.</p>
</td></tr>
<tr><td><code id="ht_clusters_+3A_col">col</code></td>
<td>
<p>A vector of colors that map from 0 to the 95^th percentile of the similarity values.</p>
</td></tr>
<tr><td><code id="ht_clusters_+3A_draw_word_cloud">draw_word_cloud</code></td>
<td>
<p>Whether to draw the word clouds.</p>
</td></tr>
<tr><td><code id="ht_clusters_+3A_term">term</code></td>
<td>
<p>The full name or the description of the corresponding GO IDs.</p>
</td></tr>
<tr><td><code id="ht_clusters_+3A_min_term">min_term</code></td>
<td>
<p>Minimal number of functional terms in a cluster. All the clusters
with size less than &ldquo;min_term&ldquo; are all merged into one separated cluster in the heatmap.</p>
</td></tr>
<tr><td><code id="ht_clusters_+3A_order_by_size">order_by_size</code></td>
<td>
<p>Whether to reorder clusters by their sizes. The cluster
that is merged from small clusters (size &lt; &ldquo;min_term&ldquo;) is always put to the bottom of the heatmap.</p>
</td></tr>
<tr><td><code id="ht_clusters_+3A_exclude_words">exclude_words</code></td>
<td>
<p>Words that are excluded in the word cloud.</p>
</td></tr>
<tr><td><code id="ht_clusters_+3A_max_words">max_words</code></td>
<td>
<p>Maximal number of words visualized in the word cloud.</p>
</td></tr>
<tr><td><code id="ht_clusters_+3A_word_cloud_grob_param">word_cloud_grob_param</code></td>
<td>
<p>A list of graphic parameters passed to 'word_cloud_grob'.</p>
</td></tr>
<tr><td><code id="ht_clusters_+3A_fontsize_range">fontsize_range</code></td>
<td>
<p>The range of the font size. The value should be a numeric vector with length two.
The minimal font size is mapped to word frequency value of 1 and the maximal font size is mapped
to the maximal word frequency. The font size interlopation is linear.</p>
</td></tr>
<tr><td><code id="ht_clusters_+3A_column_title">column_title</code></td>
<td>
<p>Column title for the heatmap.</p>
</td></tr>
<tr><td><code id="ht_clusters_+3A_ht_list">ht_list</code></td>
<td>
<p>A list of additional heatmaps added to the left of the similarity heatmap.</p>
</td></tr>
<tr><td><code id="ht_clusters_+3A_use_raster">use_raster</code></td>
<td>
<p>Whether to write the heatmap as a raster image.</p>
</td></tr>
<tr><td><code id="ht_clusters_+3A_...">...</code></td>
<td>
<p>other parameters</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list containing a 'ComplexHeatmap::HeatmapList-class' object and GO term ordering.
</p>

<hr>
<h2 id='identify_sex_metadata'>Extract metadata for sex information if not provided already</h2><span id='topic+identify_sex_metadata'></span>

<h3>Description</h3>

<p>Extract metadata for sex information if not provided already
</p>


<h3>Usage</h3>

<pre><code class='language-R'>identify_sex_metadata(container, y_gene = "RPS4Y1", x_gene = "XIST")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="identify_sex_metadata_+3A_container">container</code></td>
<td>
<p>environment Project container that stores sub-containers
for each cell type as well as results and plots from all analyses</p>
</td></tr>
<tr><td><code id="identify_sex_metadata_+3A_y_gene">y_gene</code></td>
<td>
<p>character Gene name to use for identifying male donors (default='RPS4Y1')</p>
</td></tr>
<tr><td><code id="identify_sex_metadata_+3A_x_gene">x_gene</code></td>
<td>
<p>character Gene name to use for identifying female donors (default='XIST')</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The project container with sex metadata added to the metadata.
</p>

<hr>
<h2 id='initialize_params'>Initialize parameters to be used throughout scITD in various functions</h2><span id='topic+initialize_params'></span>

<h3>Description</h3>

<p>Initialize parameters to be used throughout scITD in various functions
</p>


<h3>Usage</h3>

<pre><code class='language-R'>initialize_params(ctypes_use, ncores = 4, rand_seed = 10)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="initialize_params_+3A_ctypes_use">ctypes_use</code></td>
<td>
<p>character Names of the cell types to use for the analysis
(default=NULL)</p>
</td></tr>
<tr><td><code id="initialize_params_+3A_ncores">ncores</code></td>
<td>
<p>numeric Number of cores to use (default=4)</p>
</td></tr>
<tr><td><code id="initialize_params_+3A_rand_seed">rand_seed</code></td>
<td>
<p>numeric Random seed to use (default=10)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of the experiment parameters to use.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>param_list &lt;- initialize_params(ctypes_use = c("CD4+ T", "CD8+ T"),
ncores = 1, rand_seed = 10)
</code></pre>

<hr>
<h2 id='instantiate_scMinimal'>Create an scMinimal object. Generally, this should be done through calling the
make_new_container() wrapper function.</h2><span id='topic+instantiate_scMinimal'></span>

<h3>Description</h3>

<p>Create an scMinimal object. Generally, this should be done through calling the
make_new_container() wrapper function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>instantiate_scMinimal(
  count_data,
  meta_data,
  metadata_cols = NULL,
  metadata_col_nm = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="instantiate_scMinimal_+3A_count_data">count_data</code></td>
<td>
<p>sparseMatrix Matrix of raw counts with genes as rows
and cells as columns</p>
</td></tr>
<tr><td><code id="instantiate_scMinimal_+3A_meta_data">meta_data</code></td>
<td>
<p>data.frame Metadata with cells as rows and variables
as columns. Number of rows in metadata should equal number of columns
in count matrix.</p>
</td></tr>
<tr><td><code id="instantiate_scMinimal_+3A_metadata_cols">metadata_cols</code></td>
<td>
<p>character The names of the metadata columns to use
(default=NULL)</p>
</td></tr>
<tr><td><code id="instantiate_scMinimal_+3A_metadata_col_nm">metadata_col_nm</code></td>
<td>
<p>character New names for the selected metadata columns
if wish to change their names. If NULL, then the preexisting column names are
used. (default=NULL)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An scMinimal object holding counts and metadata for a project.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>scMinimal &lt;- instantiate_scMinimal(count_data=test_container$scMinimal_full$count_data,
meta_data=test_container$scMinimal_full$metadata)
</code></pre>

<hr>
<h2 id='is_GO_id'>Check if a character is a go ID</h2><span id='topic+is_GO_id'></span>

<h3>Description</h3>

<p>Check if a character is a go ID
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is_GO_id(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="is_GO_id_+3A_x">x</code></td>
<td>
<p>A character</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A logical
</p>

<hr>
<h2 id='make_new_container'>Create a container to store all data and results for the project. You must
provide a params list as generated by initialize_params(). You also need to
provide either a Seurat object or both a count_data matrix and a meta_data matrix.</h2><span id='topic+make_new_container'></span>

<h3>Description</h3>

<p>Create a container to store all data and results for the project. You must
provide a params list as generated by initialize_params(). You also need to
provide either a Seurat object or both a count_data matrix and a meta_data matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>make_new_container(
  params,
  count_data = NULL,
  meta_data = NULL,
  seurat_obj = NULL,
  scMinimal = NULL,
  gn_convert = NULL,
  metadata_cols = NULL,
  metadata_col_nm = NULL,
  label_donor_sex = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="make_new_container_+3A_params">params</code></td>
<td>
<p>list A list of the experiment params to use as generated by
initialize_params()</p>
</td></tr>
<tr><td><code id="make_new_container_+3A_count_data">count_data</code></td>
<td>
<p>dgCMatrix Matrix of raw counts with genes as rows
and cells as columns (default=NULL)</p>
</td></tr>
<tr><td><code id="make_new_container_+3A_meta_data">meta_data</code></td>
<td>
<p>data.frame Metadata with cells as rows and variables
as columns. Number of rows in metadata should equal number of columns
in count matrix (default=NULL)</p>
</td></tr>
<tr><td><code id="make_new_container_+3A_seurat_obj">seurat_obj</code></td>
<td>
<p>Seurat object that has been cleaned and includes the normalized,
log-transformed counts. The meta.data should include a column with the header
'sex' and values of 'M' or 'F' if available. The metadata should
also have a column with the header 'ctypes' with the corresponding names of
the cell types as well as a column with header 'donors' that contains
identifiers for each donor. (default=NULL)</p>
</td></tr>
<tr><td><code id="make_new_container_+3A_scminimal">scMinimal</code></td>
<td>
<p>environment A sub-container for the project typically
consisting of gene expression data in its raw and processed forms as well
as metadata (default=NULL)</p>
</td></tr>
<tr><td><code id="make_new_container_+3A_gn_convert">gn_convert</code></td>
<td>
<p>data.frame Gene identifier -&gt; gene name conversions table.
Gene identifiers used in counts matrices should appear in the first column and
the corresponding gene symbols should appear in the second column. Can remain
NULL if the identifiers are already gene symbols. (default=NULL)</p>
</td></tr>
<tr><td><code id="make_new_container_+3A_metadata_cols">metadata_cols</code></td>
<td>
<p>character The names of the metadata columns to use
(default=NULL)</p>
</td></tr>
<tr><td><code id="make_new_container_+3A_metadata_col_nm">metadata_col_nm</code></td>
<td>
<p>character New names for the selected metadata columns
if wish to change their names. If NULL, then the preexisting column names are
used. (default=NULL)</p>
</td></tr>
<tr><td><code id="make_new_container_+3A_label_donor_sex">label_donor_sex</code></td>
<td>
<p>logical Set to TRUE to label donor sex in the meta data
by using expressing of sex-associated genes (default=FALSE)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A project container of class environment that stores sub-containers
for each cell type as well as results and plots from all analyses.
</p>

<hr>
<h2 id='merge_small_clusts'>Merge small subclusters into larger ones</h2><span id='topic+merge_small_clusts'></span>

<h3>Description</h3>

<p>Merge small subclusters into larger ones
</p>


<h3>Usage</h3>

<pre><code class='language-R'>merge_small_clusts(con, clusts, min_cells_group)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="merge_small_clusts_+3A_con">con</code></td>
<td>
<p>conos Object for the dataset with umap projection and groups as cell types</p>
</td></tr>
<tr><td><code id="merge_small_clusts_+3A_clusts">clusts</code></td>
<td>
<p>character The initially assigned subclusters by leiden clustering</p>
</td></tr>
<tr><td><code id="merge_small_clusts_+3A_min_cells_group">min_cells_group</code></td>
<td>
<p>numeric The minimum allowable cluster size</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The subcluster labels with small clusters below the size threshold merged into
the nearest larger cluster.
</p>

<hr>
<h2 id='nmf_unfolded'>Computes non-negative matrix factorization on the tensor unfolded along the donor dimension</h2><span id='topic+nmf_unfolded'></span>

<h3>Description</h3>

<p>Computes non-negative matrix factorization on the tensor unfolded along the donor dimension
</p>


<h3>Usage</h3>

<pre><code class='language-R'>nmf_unfolded(container, ranks)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="nmf_unfolded_+3A_container">container</code></td>
<td>
<p>environment Project container that stores sub-containers
for each cell type as well as results and plots from all analyses</p>
</td></tr>
<tr><td><code id="nmf_unfolded_+3A_ranks">ranks</code></td>
<td>
<p>numeric The number of factors to extract. Unlike with the Tucker
decomposition, this should be a single number.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The project container with results of the decomposition in container$tucker_results.
The results object is a list with the donor scores matrix in the first element and the unfolded
loadings matrix in the second element.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>test_container &lt;- nmf_unfolded(test_container, 2)
</code></pre>

<hr>
<h2 id='norm_var_helper'>Calculates the normalized variance for each gene. This is adapted from pagoda2.
https://github.com/kharchenkolab/pagoda2/blob/main/R/Pagoda2.R
Generally, this should be done through calling the
form_tensor() wrapper function.</h2><span id='topic+norm_var_helper'></span>

<h3>Description</h3>

<p>Calculates the normalized variance for each gene. This is adapted from pagoda2.
https://github.com/kharchenkolab/pagoda2/blob/main/R/Pagoda2.R
Generally, this should be done through calling the
form_tensor() wrapper function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>norm_var_helper(scMinimal)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="norm_var_helper_+3A_scminimal">scMinimal</code></td>
<td>
<p>environment A sub-container for the project typically
consisting of gene expression data in its raw and processed forms as well
as metadata</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with the first element containing a vector of the normalized
variance for each gene and the second element containing log-transformed adjusted
p-values for the overdispersion of each gene.
</p>

<hr>
<h2 id='normalize_counts'>Helper function to normalize and log-transform count data</h2><span id='topic+normalize_counts'></span>

<h3>Description</h3>

<p>Helper function to normalize and log-transform count data
</p>


<h3>Usage</h3>

<pre><code class='language-R'>normalize_counts(count_data, scale_factor = 10000)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="normalize_counts_+3A_count_data">count_data</code></td>
<td>
<p>matrix or sparse matrix Gene by cell matrix of counts</p>
</td></tr>
<tr><td><code id="normalize_counts_+3A_scale_factor">scale_factor</code></td>
<td>
<p>numeric The number that gets multiplied by fractional counts
during normalization of the pseudobulked data (default=10000)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The normalized, log-transformed matrix.
</p>

<hr>
<h2 id='normalize_pseudobulk'>Normalize the pseudobulked counts matrices. Generally, this should be done through calling the
form_tensor() wrapper function.</h2><span id='topic+normalize_pseudobulk'></span>

<h3>Description</h3>

<p>Normalize the pseudobulked counts matrices. Generally, this should be done through calling the
form_tensor() wrapper function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>normalize_pseudobulk(container, method = "trim", scale_factor = 10000)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="normalize_pseudobulk_+3A_container">container</code></td>
<td>
<p>environment Project container that stores sub-containers
for each cell type as well as results and plots from all analyses</p>
</td></tr>
<tr><td><code id="normalize_pseudobulk_+3A_method">method</code></td>
<td>
<p>character The normalization method to use on the pseudobulked
count data. Set to 'regular' to do standard normalization of dividing by
library size. Set to 'trim' to use edgeR trim-mean normalization, whereby counts
are divided by library size times a normalization factor. (default='trim')</p>
</td></tr>
<tr><td><code id="normalize_pseudobulk_+3A_scale_factor">scale_factor</code></td>
<td>
<p>numeric The number that gets multiplied by fractional counts
during normalization of the pseudobulked data (default=10000)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The project container with normalized pseudobulk matrices in 
container$scMinimal_ctype$&lt;ctype&gt;$pseudobulk slots.
</p>

<hr>
<h2 id='parse_data_by_ctypes'>Parse main counts matrix into per-celltype-matrices. Generally, this should be done through calling the
form_tensor() wrapper function.</h2><span id='topic+parse_data_by_ctypes'></span>

<h3>Description</h3>

<p>Parse main counts matrix into per-celltype-matrices. Generally, this should be done through calling the
form_tensor() wrapper function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>parse_data_by_ctypes(container)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="parse_data_by_ctypes_+3A_container">container</code></td>
<td>
<p>environment Project container that stores sub-containers
for each cell type as well as results and plots from all analyses</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The project container with separate scMinimal objects per cell type in
the container$scMinimal_ctype slot
</p>

<hr>
<h2 id='pca_unfolded'>Computes singular-value decomposition on the tensor unfolded along the donor dimension</h2><span id='topic+pca_unfolded'></span>

<h3>Description</h3>

<p>Computes singular-value decomposition on the tensor unfolded along the donor dimension
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pca_unfolded(container, ranks)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pca_unfolded_+3A_container">container</code></td>
<td>
<p>environment Project container that stores sub-containers
for each cell type as well as results and plots from all analyses</p>
</td></tr>
<tr><td><code id="pca_unfolded_+3A_ranks">ranks</code></td>
<td>
<p>numeric The number of factors to extract. Unlike with the Tucker
decomposition, this should be a single number.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The project container with results of the decomposition in container$tucker_results.
The results object is a list with the donor scores matrix in the first element and the unfolded
loadings matrix in the second element.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>test_container &lt;- pca_unfolded(test_container, 2)
</code></pre>

<hr>
<h2 id='plot_donor_matrix'>Plot matrix of donor scores extracted from Tucker decomposition</h2><span id='topic+plot_donor_matrix'></span>

<h3>Description</h3>

<p>Plot matrix of donor scores extracted from Tucker decomposition
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot_donor_matrix(
  container,
  meta_vars = NULL,
  cluster_by_meta = NULL,
  show_donor_ids = FALSE,
  add_meta_associations = NULL,
  show_var_explained = TRUE,
  donors_sel = NULL,
  h_w = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot_donor_matrix_+3A_container">container</code></td>
<td>
<p>environment Project container that stores sub-containers
for each cell type as well as results and plots from all analyses</p>
</td></tr>
<tr><td><code id="plot_donor_matrix_+3A_meta_vars">meta_vars</code></td>
<td>
<p>character Names of metadata variables to plot alongside
the donor scores. Can include more than one variable. (default=NULL)</p>
</td></tr>
<tr><td><code id="plot_donor_matrix_+3A_cluster_by_meta">cluster_by_meta</code></td>
<td>
<p>character One metadata variable to cluster the heatmap
by. If NULL, donor clustering is done using donor scores. (default=NULL)</p>
</td></tr>
<tr><td><code id="plot_donor_matrix_+3A_show_donor_ids">show_donor_ids</code></td>
<td>
<p>logical Set to TRUE to show donor id as row name on the
heamap (default=FALSE)</p>
</td></tr>
<tr><td><code id="plot_donor_matrix_+3A_add_meta_associations">add_meta_associations</code></td>
<td>
<p>character Adds meta data associations with each
factor as top annotation. These should be generated first with
plot_meta_associations(). Set to 'pval' if used 'pval' in plot_meta_associations(),
otherwise set to 'rsq'. If NULL, no annotation is added. (default=NULL)</p>
</td></tr>
<tr><td><code id="plot_donor_matrix_+3A_show_var_explained">show_var_explained</code></td>
<td>
<p>logical Set to TRUE to display the explained variance for
each factor (default=TRUE)</p>
</td></tr>
<tr><td><code id="plot_donor_matrix_+3A_donors_sel">donors_sel</code></td>
<td>
<p>character A vector of a subset of donors to include in the plot
(default=NULL)</p>
</td></tr>
<tr><td><code id="plot_donor_matrix_+3A_h_w">h_w</code></td>
<td>
<p>numeric Vector specifying height and width (defualt=NULL)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The project container with a heatmap plot of donor scores in container$plots$donor_matrix.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>test_container &lt;- plot_donor_matrix(test_container, show_donor_ids = TRUE)
</code></pre>

<hr>
<h2 id='plot_donor_props'>Plot donor celltype/subtype proportions against each factor</h2><span id='topic+plot_donor_props'></span>

<h3>Description</h3>

<p>Plot donor celltype/subtype proportions against each factor
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot_donor_props(
  donor_props,
  donor_scores,
  significance,
  ctype_mapping = NULL,
  stat_type = "adj_pval",
  n_col = 2
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot_donor_props_+3A_donor_props">donor_props</code></td>
<td>
<p>data.frame Donor proportions as output from compute_donor_props()</p>
</td></tr>
<tr><td><code id="plot_donor_props_+3A_donor_scores">donor_scores</code></td>
<td>
<p>data.frame Donor scores from tucker results</p>
</td></tr>
<tr><td><code id="plot_donor_props_+3A_significance">significance</code></td>
<td>
<p>numeric F-Statistics as output from compute_associations()</p>
</td></tr>
<tr><td><code id="plot_donor_props_+3A_ctype_mapping">ctype_mapping</code></td>
<td>
<p>character The cell types corresponding with columns of donor_props (default=NULL)</p>
</td></tr>
<tr><td><code id="plot_donor_props_+3A_stat_type">stat_type</code></td>
<td>
<p>character Either &quot;fstat&quot; to get F-Statistics, &quot;adj_rsq&quot; to get adjusted
R-squared values, or &quot;adj_pval&quot; to get adjusted pvalues (default='adj_pval')</p>
</td></tr>
<tr><td><code id="plot_donor_props_+3A_n_col">n_col</code></td>
<td>
<p>numeric The number of columns to organize the plots into (default=2)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A cowplot figure of ggplot objects for proportions of each cell type against
donor factor scores for each factor.
</p>

<hr>
<h2 id='plot_donor_sig_genes'>Generate a gene by donor heatmap showing scaled expression of top loading genes
for a given factor</h2><span id='topic+plot_donor_sig_genes'></span>

<h3>Description</h3>

<p>Generate a gene by donor heatmap showing scaled expression of top loading genes
for a given factor
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot_donor_sig_genes(
  container,
  factor_select,
  top_n_per_ctype,
  ctypes_use = NULL,
  show_donor_labels = FALSE,
  additional_meta = NULL,
  add_genes = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot_donor_sig_genes_+3A_container">container</code></td>
<td>
<p>environment Project container that stores sub-containers
for each cell type as well as results and plots from all analyses</p>
</td></tr>
<tr><td><code id="plot_donor_sig_genes_+3A_factor_select">factor_select</code></td>
<td>
<p>numeric The factor to query</p>
</td></tr>
<tr><td><code id="plot_donor_sig_genes_+3A_top_n_per_ctype">top_n_per_ctype</code></td>
<td>
<p>numeric Vector of the number of top genes from each cell type
to plot</p>
</td></tr>
<tr><td><code id="plot_donor_sig_genes_+3A_ctypes_use">ctypes_use</code></td>
<td>
<p>character The cell types for which to get the top genes to make
callouts for. If NULL then uses all cell types. (default=NULL)</p>
</td></tr>
<tr><td><code id="plot_donor_sig_genes_+3A_show_donor_labels">show_donor_labels</code></td>
<td>
<p>logical Set to TRUE to display donor labels (default=FALSE)</p>
</td></tr>
<tr><td><code id="plot_donor_sig_genes_+3A_additional_meta">additional_meta</code></td>
<td>
<p>character Another meta variable to plot (default=NULL)</p>
</td></tr>
<tr><td><code id="plot_donor_sig_genes_+3A_add_genes">add_genes</code></td>
<td>
<p>character Additional genes to plot for all ctypes (default=NULL)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The project container with a heatmap plot in the slot
container$plots$donor_sig_genes$&lt;Factor#&gt;. This heatmap shows scaled expression
of top loading genes in each cell type for a selected factor.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>test_container &lt;- plot_donor_sig_genes(test_container, factor_select=1,
top_n_per_ctype=2)
</code></pre>

<hr>
<h2 id='plot_dscore_enr'>Compute enrichment of donor metadata categorical variables at high/low factor scores</h2><span id='topic+plot_dscore_enr'></span>

<h3>Description</h3>

<p>Compute enrichment of donor metadata categorical variables at high/low factor scores
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot_dscore_enr(container, factor_use, meta_var)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot_dscore_enr_+3A_container">container</code></td>
<td>
<p>environment Project container that stores sub-containers
for each cell type as well as results and plots from all analyses</p>
</td></tr>
<tr><td><code id="plot_dscore_enr_+3A_factor_use">factor_use</code></td>
<td>
<p>numeric The factor to test</p>
</td></tr>
<tr><td><code id="plot_dscore_enr_+3A_meta_var">meta_var</code></td>
<td>
<p>character The name of the metadata variable to test</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A cowplot figure of enrichment plots.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>fig &lt;- plot_dscore_enr(test_container, factor_use=1, meta_var='lanes')
</code></pre>

<hr>
<h2 id='plot_gsea_hmap'>Plot enriched gene sets from all cell types in a heatmap</h2><span id='topic+plot_gsea_hmap'></span>

<h3>Description</h3>

<p>Plot enriched gene sets from all cell types in a heatmap
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot_gsea_hmap(container, factor_select, thresh)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot_gsea_hmap_+3A_container">container</code></td>
<td>
<p>environment Project container that stores sub-containers
for each cell type as well as results and plots from all analyses</p>
</td></tr>
<tr><td><code id="plot_gsea_hmap_+3A_factor_select">factor_select</code></td>
<td>
<p>numeric The factor to plot</p>
</td></tr>
<tr><td><code id="plot_gsea_hmap_+3A_thresh">thresh</code></td>
<td>
<p>numeric Pvalue threshold to use for including gene sets in the heatmap</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A stacked heatmap object from ComplexHeatmap.
</p>

<hr>
<h2 id='plot_gsea_hmap_w_similarity'>Plot already computed enriched gene sets to show semantic similarity between sets</h2><span id='topic+plot_gsea_hmap_w_similarity'></span>

<h3>Description</h3>

<p>Plot already computed enriched gene sets to show semantic similarity between sets
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot_gsea_hmap_w_similarity(
  container,
  factor_select,
  direc,
  thresh,
  exclude_words = character(0)
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot_gsea_hmap_w_similarity_+3A_container">container</code></td>
<td>
<p>environment Project container that stores sub-containers
for each cell type as well as results and plots from all analyses</p>
</td></tr>
<tr><td><code id="plot_gsea_hmap_w_similarity_+3A_factor_select">factor_select</code></td>
<td>
<p>numeric The factor to plot</p>
</td></tr>
<tr><td><code id="plot_gsea_hmap_w_similarity_+3A_direc">direc</code></td>
<td>
<p>character Set to either 'up' or 'down' to use the appropriate sets</p>
</td></tr>
<tr><td><code id="plot_gsea_hmap_w_similarity_+3A_thresh">thresh</code></td>
<td>
<p>numeric Pvalue threshold to use for including gene sets in the heatmap</p>
</td></tr>
<tr><td><code id="plot_gsea_hmap_w_similarity_+3A_exclude_words">exclude_words</code></td>
<td>
<p>character Vector of words to exclude from word cloud
(default=character(0))</p>
</td></tr>
</table>


<h3>Value</h3>

<p>No value is returned. A heatmap showing enriched gene sets clustered by
semantic similarity is drawn.
</p>

<hr>
<h2 id='plot_gsea_sub'>Look at enriched gene sets from a cluster of semantically similar gene sets.
Uses the results from previous run of plot_gsea_hmap_w_similarity()</h2><span id='topic+plot_gsea_sub'></span>

<h3>Description</h3>

<p>Look at enriched gene sets from a cluster of semantically similar gene sets.
Uses the results from previous run of plot_gsea_hmap_w_similarity()
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot_gsea_sub(container, clust_select, thresh = 0.05)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot_gsea_sub_+3A_container">container</code></td>
<td>
<p>environment Project container that stores sub-containers
for each cell type as well as results and plots from all analyses</p>
</td></tr>
<tr><td><code id="plot_gsea_sub_+3A_clust_select">clust_select</code></td>
<td>
<p>numeric The cluster to plot gene sets from. On the previous
semantic similarity plot, cluster numbering starts from the top as 1.</p>
</td></tr>
<tr><td><code id="plot_gsea_sub_+3A_thresh">thresh</code></td>
<td>
<p>numeric Color threshold to use for showing significance (default=0.05)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A heatmap plot from ComplexHeatmap showing one semantic similarity cluster
of enriched gene sets with adjusted p-values for each cell type.
</p>

<hr>
<h2 id='plot_loadings_annot'>Plot the gene by celltype loadings for a factor</h2><span id='topic+plot_loadings_annot'></span>

<h3>Description</h3>

<p>Plot the gene by celltype loadings for a factor
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot_loadings_annot(
  container,
  factor_select,
  use_sig_only = FALSE,
  nonsig_to_zero = FALSE,
  annot = "none",
  pathways = NULL,
  sim_de_donor_group = NULL,
  sig_thresh = 0.05,
  display_genes = FALSE,
  gene_callouts = FALSE,
  callout_n_gene_per_ctype = 5,
  callout_ctypes = NULL,
  specific_callouts = NULL,
  le_set_callouts = NULL,
  le_set_colormap = NULL,
  le_set_num_per = 5,
  show_le_legend = FALSE,
  show_xlab = TRUE,
  show_var_explained = TRUE,
  clust_method = "median",
  h_w = NULL,
  reset_other_factor_plots = FALSE,
  draw_plot = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot_loadings_annot_+3A_container">container</code></td>
<td>
<p>environment Project container that stores sub-containers
for each cell type as well as results and plots from all analyses</p>
</td></tr>
<tr><td><code id="plot_loadings_annot_+3A_factor_select">factor_select</code></td>
<td>
<p>numeric The factor to plot</p>
</td></tr>
<tr><td><code id="plot_loadings_annot_+3A_use_sig_only">use_sig_only</code></td>
<td>
<p>logical If TRUE, includes only significant genes
from jackstraw in the heatmap. If FALSE, includes all the variable genes.
(default = FALSE)</p>
</td></tr>
<tr><td><code id="plot_loadings_annot_+3A_nonsig_to_zero">nonsig_to_zero</code></td>
<td>
<p>logical If TRUE, makes the loadings of all nonsignificant genes 0
(default=FALSE)</p>
</td></tr>
<tr><td><code id="plot_loadings_annot_+3A_annot">annot</code></td>
<td>
<p>character If set to &quot;pathways&quot; then creates an adjacent heatmap
showing which genes are in which pathways. If set to &quot;sig_genes&quot; then creates
an adjacent heatmap showing which genes were significant from jackstraw. If
set to &quot;none&quot; no adjacent heatmap is plotted. (default=&quot;none&quot;)</p>
</td></tr>
<tr><td><code id="plot_loadings_annot_+3A_pathways">pathways</code></td>
<td>
<p>character Gene sets to plot if annot is set to &quot;pathways&quot;
(default=NULL)</p>
</td></tr>
<tr><td><code id="plot_loadings_annot_+3A_sim_de_donor_group">sim_de_donor_group</code></td>
<td>
<p>numeric To plot the ground truth significant genes from a
simulation next to the heatmap, put the number of the donor group that corresponds to
the factor being plotted (default=NULL)</p>
</td></tr>
<tr><td><code id="plot_loadings_annot_+3A_sig_thresh">sig_thresh</code></td>
<td>
<p>numeric Pvalue significance threshold to use. If use_sig_only is
TRUE the threshold is used as a cutoff for genes to include. If annot is &quot;sig_genes&quot;
this value is used in the gene significance colormap as a minimum threshold. (default=0.05)</p>
</td></tr>
<tr><td><code id="plot_loadings_annot_+3A_display_genes">display_genes</code></td>
<td>
<p>logical If TRUE, displays the names of gene names (default=FALSE)</p>
</td></tr>
<tr><td><code id="plot_loadings_annot_+3A_gene_callouts">gene_callouts</code></td>
<td>
<p>logical If TRUE, then adds gene callout annotations to the heatmap
(default=FALSE)</p>
</td></tr>
<tr><td><code id="plot_loadings_annot_+3A_callout_n_gene_per_ctype">callout_n_gene_per_ctype</code></td>
<td>
<p>numeric To use if gene_callouts is TRUE. Sets the number
of largest magnitude significant genes from each cell type to include in gene callouts.
(default=5)</p>
</td></tr>
<tr><td><code id="plot_loadings_annot_+3A_callout_ctypes">callout_ctypes</code></td>
<td>
<p>character To use if gene_callouts is TRUE. Specifies which cell types
to get gene callouts for. If NULL, then gets gene callouts for largest magnitude significant
genes for all cell types. (default=NULL)</p>
</td></tr>
<tr><td><code id="plot_loadings_annot_+3A_specific_callouts">specific_callouts</code></td>
<td>
<p>character A vector of gene names to show callouts for (default=NULL)</p>
</td></tr>
<tr><td><code id="plot_loadings_annot_+3A_le_set_callouts">le_set_callouts</code></td>
<td>
<p>character Pass a vector of gene set names to show leading edge genes
for a select set of gene sets (default=NULL)</p>
</td></tr>
<tr><td><code id="plot_loadings_annot_+3A_le_set_colormap">le_set_colormap</code></td>
<td>
<p>character A named vector with names as gene sets and values as colors.
If NULL, then selects first n colors of Set3 color palette. (default=NULL)</p>
</td></tr>
<tr><td><code id="plot_loadings_annot_+3A_le_set_num_per">le_set_num_per</code></td>
<td>
<p>numeric The number of leading edge genes to show for each gene set (default=5)</p>
</td></tr>
<tr><td><code id="plot_loadings_annot_+3A_show_le_legend">show_le_legend</code></td>
<td>
<p>logical Set to TRUE to show the color map legend for leading edge genes (default=FALSE)</p>
</td></tr>
<tr><td><code id="plot_loadings_annot_+3A_show_xlab">show_xlab</code></td>
<td>
<p>logical If TRUE, displays the xlabel 'genes' (default=TRUE)</p>
</td></tr>
<tr><td><code id="plot_loadings_annot_+3A_show_var_explained">show_var_explained</code></td>
<td>
<p>logical If TRUE then shows an anotation with the explained variance
for each cell type (default=TRUE)</p>
</td></tr>
<tr><td><code id="plot_loadings_annot_+3A_clust_method">clust_method</code></td>
<td>
<p>character The hclust method to use for clustering rows (default='median')</p>
</td></tr>
<tr><td><code id="plot_loadings_annot_+3A_h_w">h_w</code></td>
<td>
<p>numeric Vector specifying height and width (defualt=NULL)</p>
</td></tr>
<tr><td><code id="plot_loadings_annot_+3A_reset_other_factor_plots">reset_other_factor_plots</code></td>
<td>
<p>logical Set to TRUE to set all other loadings plots to NULL.
Useful if run get_all_lds_factor_plots but then only want to show one or two plots. (default=FALSE)</p>
</td></tr>
<tr><td><code id="plot_loadings_annot_+3A_draw_plot">draw_plot</code></td>
<td>
<p>logical Set to TRUE to show the plot. Plot is stored regardless. (default=TRUE)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The project container with a heatmap of loadings for one factor put in container$plots$all_lds_plots.
The legend for the heatmap is put in container$plots$all_legends. Use draw(&lt;hmap obj&gt;,annotation_legend_list = &lt;hmap legend obj&gt;)
to re-render the plot with legend.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>test_container &lt;- plot_loadings_annot(test_container, 1, display_genes=FALSE,
show_var_explained = TRUE)
</code></pre>

<hr>
<h2 id='plot_mod_and_lig'>Plot trio of associations between ligand expression, module eigengenes, and
factor scores</h2><span id='topic+plot_mod_and_lig'></span>

<h3>Description</h3>

<p>Plot trio of associations between ligand expression, module eigengenes, and
factor scores
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot_mod_and_lig(container, factor_select, mod_ct, mod, lig_ct, lig)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot_mod_and_lig_+3A_container">container</code></td>
<td>
<p>environment Project container that stores sub-containers
for each cell type as well as results and plots from all analyses</p>
</td></tr>
<tr><td><code id="plot_mod_and_lig_+3A_factor_select">factor_select</code></td>
<td>
<p>numeric The factor to use</p>
</td></tr>
<tr><td><code id="plot_mod_and_lig_+3A_mod_ct">mod_ct</code></td>
<td>
<p>character The name of the cell type for the corresponding module</p>
</td></tr>
<tr><td><code id="plot_mod_and_lig_+3A_mod">mod</code></td>
<td>
<p>numeric The number of the corresponding module</p>
</td></tr>
<tr><td><code id="plot_mod_and_lig_+3A_lig_ct">lig_ct</code></td>
<td>
<p>character The name of the cell type where the ligand is expressed</p>
</td></tr>
<tr><td><code id="plot_mod_and_lig_+3A_lig">lig</code></td>
<td>
<p>character The name of the ligand to use</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A cowplot figure of ggplot objects for the three associations scatter plots.
</p>

<hr>
<h2 id='plot_multi_module_enr'>Generate gene set x ct_module heatmap showing co-expression module gene set enrichment results</h2><span id='topic+plot_multi_module_enr'></span>

<h3>Description</h3>

<p>Generate gene set x ct_module heatmap showing co-expression module gene set enrichment results
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot_multi_module_enr(
  container,
  ctypes,
  modules,
  sig_thresh = 0.05,
  db_use = "TF",
  max_plt_pval = 0.1,
  h_w = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot_multi_module_enr_+3A_container">container</code></td>
<td>
<p>environment Project container that stores sub-containers
for each cell type as well as results and plots from all analyses</p>
</td></tr>
<tr><td><code id="plot_multi_module_enr_+3A_ctypes">ctypes</code></td>
<td>
<p>character A vector of cell type names corresponding to the module
numbers in mod_select, specifying the modules to compute enrichment for</p>
</td></tr>
<tr><td><code id="plot_multi_module_enr_+3A_modules">modules</code></td>
<td>
<p>numeric A vector of module numbers corresponding to the cell
types in ctype, specifying the modules to compute enrichment for</p>
</td></tr>
<tr><td><code id="plot_multi_module_enr_+3A_sig_thresh">sig_thresh</code></td>
<td>
<p>numeric P-value threshold for results to include. Only shows
a given gene set if at least one module has a result lower than the threshold.
(default=0.05)</p>
</td></tr>
<tr><td><code id="plot_multi_module_enr_+3A_db_use">db_use</code></td>
<td>
<p>character The database of gene sets to use. Database
options include &quot;GO&quot;, &quot;Reactome&quot;, &quot;KEGG&quot;, &quot;BioCarta&quot;, &quot;Hallmark&quot;, &quot;TF&quot;, and
&quot;immuno&quot;. More than one database can be used. (default=&quot;GO&quot;)</p>
</td></tr>
<tr><td><code id="plot_multi_module_enr_+3A_max_plt_pval">max_plt_pval</code></td>
<td>
<p>max pvalue shown on plot, but not used to remove rows like
sig_thresh (default=.1)</p>
</td></tr>
<tr><td><code id="plot_multi_module_enr_+3A_h_w">h_w</code></td>
<td>
<p>numeric Vector specifying height and width (defualt=NULL)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A ComplexHeatmap object of enrichment results.
</p>

<hr>
<h2 id='plot_rec_errors_bar_svd'>Plot reconstruction errors as bar plot for svd method</h2><span id='topic+plot_rec_errors_bar_svd'></span>

<h3>Description</h3>

<p>Plot reconstruction errors as bar plot for svd method
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot_rec_errors_bar_svd(real, shuffled, mode_to_show)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot_rec_errors_bar_svd_+3A_real">real</code></td>
<td>
<p>list The real reconstruction errors</p>
</td></tr>
<tr><td><code id="plot_rec_errors_bar_svd_+3A_shuffled">shuffled</code></td>
<td>
<p>list The reconstruction errors under null model</p>
</td></tr>
<tr><td><code id="plot_rec_errors_bar_svd_+3A_mode_to_show">mode_to_show</code></td>
<td>
<p>numeric The mode to plot the results for</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A ggplot object showing the difference in reconstruction errors for
successive factors.
</p>

<hr>
<h2 id='plot_rec_errors_line_svd'>Plot reconstruction errors as line plot for svd method</h2><span id='topic+plot_rec_errors_line_svd'></span>

<h3>Description</h3>

<p>Plot reconstruction errors as line plot for svd method
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot_rec_errors_line_svd(real, shuffled, mode_to_show)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot_rec_errors_line_svd_+3A_real">real</code></td>
<td>
<p>list The real reconstruction errors</p>
</td></tr>
<tr><td><code id="plot_rec_errors_line_svd_+3A_shuffled">shuffled</code></td>
<td>
<p>list The reconstruction errors under null model</p>
</td></tr>
<tr><td><code id="plot_rec_errors_line_svd_+3A_mode_to_show">mode_to_show</code></td>
<td>
<p>numeric The mode to plot the results for</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A ggplot object showing relative reconstruction errors.
</p>

<hr>
<h2 id='plot_scores_by_meta'>Plot dotplots for each factor to compare donor scores between metadata groups</h2><span id='topic+plot_scores_by_meta'></span>

<h3>Description</h3>

<p>Plot dotplots for each factor to compare donor scores between metadata groups
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot_scores_by_meta(container, meta_var)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot_scores_by_meta_+3A_container">container</code></td>
<td>
<p>environment Project container that stores sub-containers
for each cell type as well as results and plots from all analyses</p>
</td></tr>
<tr><td><code id="plot_scores_by_meta_+3A_meta_var">meta_var</code></td>
<td>
<p>character The meta data variable to compare groups for</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The project container with a figure of comparison plots (one for each factor)
placed in container$plots$indv_meta_scores_associations.
</p>

<hr>
<h2 id='plot_select_sets'>Plot enrichment results for hand picked gene sets</h2><span id='topic+plot_select_sets'></span>

<h3>Description</h3>

<p>Plot enrichment results for hand picked gene sets
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot_select_sets(
  container,
  factors_all,
  sets_plot,
  color_sets = NULL,
  cl_rows = FALSE,
  h_w = NULL,
  myfontsize = 8
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot_select_sets_+3A_container">container</code></td>
<td>
<p>environment Project container that stores sub-containers
for each cell type as well as results and plots from all analyses</p>
</td></tr>
<tr><td><code id="plot_select_sets_+3A_factors_all">factors_all</code></td>
<td>
<p>numeric Vector of one or more factor numbers to get plots for</p>
</td></tr>
<tr><td><code id="plot_select_sets_+3A_sets_plot">sets_plot</code></td>
<td>
<p>character Vector of gene set names to show enrichment values for</p>
</td></tr>
<tr><td><code id="plot_select_sets_+3A_color_sets">color_sets</code></td>
<td>
<p>named character Values are colors corresponding to each set,
with names as the gene set names (default=NULL)</p>
</td></tr>
<tr><td><code id="plot_select_sets_+3A_cl_rows">cl_rows</code></td>
<td>
<p>logical Set to TRUE to cluster gene set results (default=FALSE)</p>
</td></tr>
<tr><td><code id="plot_select_sets_+3A_h_w">h_w</code></td>
<td>
<p>numeric Vector specifying height and width (defualt=NULL)</p>
</td></tr>
<tr><td><code id="plot_select_sets_+3A_myfontsize">myfontsize</code></td>
<td>
<p>numeric Gene set label fontsize (default=8)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with a ComplexHeatmap object of select enriched gene sets as the first element
and with a legend object as the second element.
</p>

<hr>
<h2 id='plot_stability_results'>Generate a plot for either the donor scores or loadings stability test</h2><span id='topic+plot_stability_results'></span>

<h3>Description</h3>

<p>Generate a plot for either the donor scores or loadings stability test
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot_stability_results(container, plt_data)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot_stability_results_+3A_container">container</code></td>
<td>
<p>environment Project container that stores sub-containers
for each cell type as well as results and plots from all analyses</p>
</td></tr>
<tr><td><code id="plot_stability_results_+3A_plt_data">plt_data</code></td>
<td>
<p>character Either 'lds' or 'dsc' and indicates which plot to make</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the plot
</p>

<hr>
<h2 id='plot_subclust_associations'>Plot association significances for varying clustering resolutions</h2><span id='topic+plot_subclust_associations'></span>

<h3>Description</h3>

<p>Plot association significances for varying clustering resolutions
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot_subclust_associations(res, n_col = 2)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot_subclust_associations_+3A_res">res</code></td>
<td>
<p>data.frame Regression statistics for each subcluster analysis</p>
</td></tr>
<tr><td><code id="plot_subclust_associations_+3A_n_col">n_col</code></td>
<td>
<p>numeric The number of columns to organize the plots into (default=2)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A cowplot of ggplot objects showing statistics for regressions of proportions of
each cell subtype (at varying clustering resolutions) against each factor.
</p>

<hr>
<h2 id='plotDEheatmap_conos'>Plot a heatmap of differential genes. Code is adapted from Conos package.
https://github.com/kharchenkolab/conos/blob/master/R/plot.R</h2><span id='topic+plotDEheatmap_conos'></span>

<h3>Description</h3>

<p>Plot a heatmap of differential genes. Code is adapted from Conos package.
https://github.com/kharchenkolab/conos/blob/master/R/plot.R
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plotDEheatmap_conos(
  con,
  groups,
  container,
  de = NULL,
  min.auc = NULL,
  min.specificity = NULL,
  min.precision = NULL,
  n.genes.per.cluster = 10,
  additional.genes = NULL,
  exclude.genes = NULL,
  labeled.gene.subset = NULL,
  expression.quantile = 0.99,
  pal = (grDevices::colorRampPalette(c("dodgerblue1", "grey95", "indianred1")))(1024),
  ordering = "-AUC",
  column.metadata = NULL,
  show.gene.clusters = TRUE,
  remove.duplicates = TRUE,
  column.metadata.colors = NULL,
  show.cluster.legend = TRUE,
  show_heatmap_legend = FALSE,
  border = TRUE,
  return.details = FALSE,
  row.label.font.size = 10,
  order.clusters = FALSE,
  split = FALSE,
  split.gap = 0,
  cell.order = NULL,
  averaging.window = 0,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plotDEheatmap_conos_+3A_con">con</code></td>
<td>
<p>conos (or p2) object</p>
</td></tr>
<tr><td><code id="plotDEheatmap_conos_+3A_groups">groups</code></td>
<td>
<p>groups in which the DE genes were determined (so that the cells can be ordered correctly)</p>
</td></tr>
<tr><td><code id="plotDEheatmap_conos_+3A_container">container</code></td>
<td>
<p>environment Project container that stores sub-containers
for each cell type as well as results and plots from all analyses</p>
</td></tr>
<tr><td><code id="plotDEheatmap_conos_+3A_de">de</code></td>
<td>
<p>differential expression result (list of data frames)</p>
</td></tr>
<tr><td><code id="plotDEheatmap_conos_+3A_min.auc">min.auc</code></td>
<td>
<p>optional minimum AUC threshold</p>
</td></tr>
<tr><td><code id="plotDEheatmap_conos_+3A_min.specificity">min.specificity</code></td>
<td>
<p>optional minimum specificity threshold</p>
</td></tr>
<tr><td><code id="plotDEheatmap_conos_+3A_min.precision">min.precision</code></td>
<td>
<p>optional minimum precision threshold</p>
</td></tr>
<tr><td><code id="plotDEheatmap_conos_+3A_n.genes.per.cluster">n.genes.per.cluster</code></td>
<td>
<p>number of genes to show for each cluster</p>
</td></tr>
<tr><td><code id="plotDEheatmap_conos_+3A_additional.genes">additional.genes</code></td>
<td>
<p>optional additional genes to include (the genes will be assigned to the closest cluster)</p>
</td></tr>
<tr><td><code id="plotDEheatmap_conos_+3A_exclude.genes">exclude.genes</code></td>
<td>
<p>an optional list of genes to exclude from the heatmap</p>
</td></tr>
<tr><td><code id="plotDEheatmap_conos_+3A_labeled.gene.subset">labeled.gene.subset</code></td>
<td>
<p>a subset of gene names to show (instead of all genes). Can be a vector of gene names, or a number of top genes (in each cluster) to show the names for.</p>
</td></tr>
<tr><td><code id="plotDEheatmap_conos_+3A_expression.quantile">expression.quantile</code></td>
<td>
<p>expression quantile to show (0.98 by default)</p>
</td></tr>
<tr><td><code id="plotDEheatmap_conos_+3A_pal">pal</code></td>
<td>
<p>palette to use for the main heatmap</p>
</td></tr>
<tr><td><code id="plotDEheatmap_conos_+3A_ordering">ordering</code></td>
<td>
<p>order by which the top DE genes (to be shown) are determined (default &quot;-AUC&quot;)</p>
</td></tr>
<tr><td><code id="plotDEheatmap_conos_+3A_column.metadata">column.metadata</code></td>
<td>
<p>additional column metadata, passed either as a data.frame with rows named as cells, or as a list of named cell factors.</p>
</td></tr>
<tr><td><code id="plotDEheatmap_conos_+3A_show.gene.clusters">show.gene.clusters</code></td>
<td>
<p>whether to show gene cluster color codes</p>
</td></tr>
<tr><td><code id="plotDEheatmap_conos_+3A_remove.duplicates">remove.duplicates</code></td>
<td>
<p>remove duplicated genes (leaving them in just one of the clusters)</p>
</td></tr>
<tr><td><code id="plotDEheatmap_conos_+3A_column.metadata.colors">column.metadata.colors</code></td>
<td>
<p>a list of color specifications for additional column metadata, specified according to the HeatmapMetadata format. Use &quot;clusters&quot; slot to specify cluster colors.</p>
</td></tr>
<tr><td><code id="plotDEheatmap_conos_+3A_show.cluster.legend">show.cluster.legend</code></td>
<td>
<p>whether to show the cluster legend</p>
</td></tr>
<tr><td><code id="plotDEheatmap_conos_+3A_show_heatmap_legend">show_heatmap_legend</code></td>
<td>
<p>whether to show the expression heatmap legend</p>
</td></tr>
<tr><td><code id="plotDEheatmap_conos_+3A_border">border</code></td>
<td>
<p>show borders around the heatmap and annotations</p>
</td></tr>
<tr><td><code id="plotDEheatmap_conos_+3A_return.details">return.details</code></td>
<td>
<p>if TRUE will return a list containing the heatmap (ha), but also raw matrix (x), expression list (expl) and other info to produce the heatmap on your own.</p>
</td></tr>
<tr><td><code id="plotDEheatmap_conos_+3A_row.label.font.size">row.label.font.size</code></td>
<td>
<p>font size for the row labels</p>
</td></tr>
<tr><td><code id="plotDEheatmap_conos_+3A_order.clusters">order.clusters</code></td>
<td>
<p>whether to re-order the clusters according to the similarity of the expression patterns (of the genes being shown)</p>
</td></tr>
<tr><td><code id="plotDEheatmap_conos_+3A_split">split</code></td>
<td>
<p>logical If TRUE splits the heatmap by cell type (default=FALSE)</p>
</td></tr>
<tr><td><code id="plotDEheatmap_conos_+3A_split.gap">split.gap</code></td>
<td>
<p>numeric The distance to put in the gaps between split parts of the heatmap if split=TRUE (default=0)</p>
</td></tr>
<tr><td><code id="plotDEheatmap_conos_+3A_cell.order">cell.order</code></td>
<td>
<p>explicitly supply cell order</p>
</td></tr>
<tr><td><code id="plotDEheatmap_conos_+3A_averaging.window">averaging.window</code></td>
<td>
<p>optional window averaging between neighboring cells within each group (turned off by default) - useful when very large number of cells shown (requires zoo package)</p>
</td></tr>
<tr><td><code id="plotDEheatmap_conos_+3A_...">...</code></td>
<td>
<p>extra parameters are passed to pheatmap</p>
</td></tr>
</table>


<h3>Value</h3>

<p>ComplexHeatmap::Heatmap object (see return.details param for other output)
</p>

<hr>
<h2 id='prep_LR_interact'>Prepare data for LR analysis and get soft thresholds to use for gene modules</h2><span id='topic+prep_LR_interact'></span>

<h3>Description</h3>

<p>Prepare data for LR analysis and get soft thresholds to use for gene modules
</p>


<h3>Usage</h3>

<pre><code class='language-R'>prep_LR_interact(
  container,
  lr_pairs,
  norm_method = "trim",
  scale_factor = 10000,
  var_scale_power = 0.5,
  batch_var = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="prep_LR_interact_+3A_container">container</code></td>
<td>
<p>environment Project container that stores sub-containers
for each cell type as well as results and plots from all analyses</p>
</td></tr>
<tr><td><code id="prep_LR_interact_+3A_lr_pairs">lr_pairs</code></td>
<td>
<p>data.frame Data of ligand-receptor pairs. First column should
be ligands and second column should be one or more receptors separated by an
underscore such as receptor1_receptor2 in the case that multiple receptors are
required for signaling.</p>
</td></tr>
<tr><td><code id="prep_LR_interact_+3A_norm_method">norm_method</code></td>
<td>
<p>character The normalization method to use on the pseudobulked
count data. Set to 'regular' to do standard normalization of dividing by
library size. Set to 'trim' to use edgeR trim-mean normalization, whereby counts
are divided by library size times a normalization factor. (default='trim')</p>
</td></tr>
<tr><td><code id="prep_LR_interact_+3A_scale_factor">scale_factor</code></td>
<td>
<p>numeric The number that gets multiplied by fractional counts
during normalization of the pseudobulked data (default=10000)</p>
</td></tr>
<tr><td><code id="prep_LR_interact_+3A_var_scale_power">var_scale_power</code></td>
<td>
<p>numeric Exponent of normalized variance that is
used for variance scaling. Variance for each gene
is initially set to unit variance across donors (for a given cell type).
Variance for each gene is then scaled by multiplying the unit scaled values
by each gene's normalized variance (where the effect of the mean-variance
dependence is taken into account) to the exponent specified here.
If NULL, uses var_scale_power from container$experiment_params. (default=.5)</p>
</td></tr>
<tr><td><code id="prep_LR_interact_+3A_batch_var">batch_var</code></td>
<td>
<p>character A batch variable from metadata to remove (default=NULL)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The project container with added container$scale_pb_extra slot that contains
the tensor with additional ligands and receptors. Also has container$no_scale_pb_extra
slot with pseudobulked, normalized data that is not scaled.
</p>

<hr>
<h2 id='project_new_data'>Project multicellular patterns to get scores on new data</h2><span id='topic+project_new_data'></span>

<h3>Description</h3>

<p>Project multicellular patterns to get scores on new data
</p>


<h3>Usage</h3>

<pre><code class='language-R'>project_new_data(new_container, old_container)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="project_new_data_+3A_new_container">new_container</code></td>
<td>
<p>environment A project container with new data to project scores
for. The form_tensor() function should be run.</p>
</td></tr>
<tr><td><code id="project_new_data_+3A_old_container">old_container</code></td>
<td>
<p>environment The original project container that has the multicellular
gene expression patterns already extracted. These patterns will be projected onto the new data.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The new container environment object with projected scores in new_container$projected_scores.
The factors will be ordered the same as the factors in old_container.
</p>

<hr>
<h2 id='reduce_dimensions'>Gets a conos object of the data, aligning datasets across a specified variable such as
batch or donors. This can be run independently or through get_subtype_prop_associations().</h2><span id='topic+reduce_dimensions'></span>

<h3>Description</h3>

<p>Gets a conos object of the data, aligning datasets across a specified variable such as
batch or donors. This can be run independently or through get_subtype_prop_associations().
</p>


<h3>Usage</h3>

<pre><code class='language-R'>reduce_dimensions(
  container,
  integration_var,
  ncores = container$experiment_params$ncores
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="reduce_dimensions_+3A_container">container</code></td>
<td>
<p>environment Project container that stores sub-containers
for each cell type as well as results and plots from all analyses</p>
</td></tr>
<tr><td><code id="reduce_dimensions_+3A_integration_var">integration_var</code></td>
<td>
<p>character The meta data variable to use for creating
the joint embedding with Conos.</p>
</td></tr>
<tr><td><code id="reduce_dimensions_+3A_ncores">ncores</code></td>
<td>
<p>numeric The number of cores to use (default=container$experiment_params$ncores)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The project container with a conos object in container$embedding.
</p>

<hr>
<h2 id='reduce_to_vargenes'>Reduce each cell type's expression matrix to just the significantly variable genes. 
Generally, this should be done through calling the form_tensor() wrapper function.</h2><span id='topic+reduce_to_vargenes'></span>

<h3>Description</h3>

<p>Reduce each cell type's expression matrix to just the significantly variable genes. 
Generally, this should be done through calling the form_tensor() wrapper function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>reduce_to_vargenes(container)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="reduce_to_vargenes_+3A_container">container</code></td>
<td>
<p>environment Project container that stores sub-containers
for each cell type as well as results and plots from all analyses</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The project container with pseudobulked matrices reduced to only
the most variable genes.
</p>

<hr>
<h2 id='render_multi_plots'>Create a figure of all loadings plots arranged</h2><span id='topic+render_multi_plots'></span>

<h3>Description</h3>

<p>Create a figure of all loadings plots arranged
</p>


<h3>Usage</h3>

<pre><code class='language-R'>render_multi_plots(container, data_type, max_cols = 3)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="render_multi_plots_+3A_container">container</code></td>
<td>
<p>environment Project container that stores sub-containers
for each cell type as well as results and plots from all analyses</p>
</td></tr>
<tr><td><code id="render_multi_plots_+3A_data_type">data_type</code></td>
<td>
<p>character Can be either &quot;loadings&quot;, &quot;gsea&quot;, or &quot;dgenes&quot;. This
determines which list of heatmaps to organize into the figure.</p>
</td></tr>
<tr><td><code id="render_multi_plots_+3A_max_cols">max_cols</code></td>
<td>
<p>numeric The max number of columns to plot. Can only either be 2
or 3 since these are large plots. (default=3)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The multi-plot figure.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>test_container &lt;- get_all_lds_factor_plots(test_container)
fig &lt;- render_multi_plots(test_container, data_type='loadings')
</code></pre>

<hr>
<h2 id='reshape_loadings'>Reshape loadings for a factor from linearized to matrix form</h2><span id='topic+reshape_loadings'></span>

<h3>Description</h3>

<p>Reshape loadings for a factor from linearized to matrix form
</p>


<h3>Usage</h3>

<pre><code class='language-R'>reshape_loadings(ldngs_row, genes, ctypes)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="reshape_loadings_+3A_ldngs_row">ldngs_row</code></td>
<td>
<p>numeric A vector of loadings values for one factor</p>
</td></tr>
<tr><td><code id="reshape_loadings_+3A_genes">genes</code></td>
<td>
<p>character The gene identifiers corresponding to each loading</p>
</td></tr>
<tr><td><code id="reshape_loadings_+3A_ctypes">ctypes</code></td>
<td>
<p>character The cell type corresponding to each loading</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A loadings matrix with dimensions of genes by cell types.
</p>

<hr>
<h2 id='run_fgsea'>Run fgsea for one cell type of one factor</h2><span id='topic+run_fgsea'></span>

<h3>Description</h3>

<p>Run fgsea for one cell type of one factor
</p>


<h3>Usage</h3>

<pre><code class='language-R'>run_fgsea(
  container,
  factor_select,
  ctype,
  db_use = "GO",
  signed = TRUE,
  min_gs_size = 15,
  max_gs_size = 500,
  ncores = container$experiment_params$ncores
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="run_fgsea_+3A_container">container</code></td>
<td>
<p>environment Project container that stores sub-containers
for each cell type as well as results and plots from all analyses</p>
</td></tr>
<tr><td><code id="run_fgsea_+3A_factor_select">factor_select</code></td>
<td>
<p>numeric The factor of interest</p>
</td></tr>
<tr><td><code id="run_fgsea_+3A_ctype">ctype</code></td>
<td>
<p>character The cell type of interest</p>
</td></tr>
<tr><td><code id="run_fgsea_+3A_db_use">db_use</code></td>
<td>
<p>character The database of gene sets to use. Database
options include &quot;GO&quot;, &quot;Reactome&quot;, &quot;KEGG&quot;, &quot;BioCarta&quot;, and &quot;Hallmark&quot;. More than
one database can be used. (default=&quot;GO&quot;)</p>
</td></tr>
<tr><td><code id="run_fgsea_+3A_signed">signed</code></td>
<td>
<p>logical If TRUE, uses signed gsea. If FALSE, uses unsigned gsea.
Currently only works with fgsea method. (default=TRUE)</p>
</td></tr>
<tr><td><code id="run_fgsea_+3A_min_gs_size">min_gs_size</code></td>
<td>
<p>numeric Minimum gene set size (default=15)</p>
</td></tr>
<tr><td><code id="run_fgsea_+3A_max_gs_size">max_gs_size</code></td>
<td>
<p>numeric Maximum gene set size (default=500)</p>
</td></tr>
<tr><td><code id="run_fgsea_+3A_ncores">ncores</code></td>
<td>
<p>numeric The number of cores to use (default=container$experiment_params$ncores)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data.frame of the fgsea results for enrichment of gene sets in a given
cell type for a given factor. The results contain adjusted p-values, normalized
enrichment scores, leading edge genes, and other information output by fgsea.
</p>

<hr>
<h2 id='run_gsea_one_factor'>Run gsea separately for all cell types of one specified factor and plot results</h2><span id='topic+run_gsea_one_factor'></span>

<h3>Description</h3>

<p>Run gsea separately for all cell types of one specified factor and plot results
</p>


<h3>Usage</h3>

<pre><code class='language-R'>run_gsea_one_factor(
  container,
  factor_select,
  method = "fgsea",
  thresh = 0.05,
  db_use = "GO",
  signed = TRUE,
  min_gs_size = 15,
  max_gs_size = 500,
  reset_other_factor_plots = FALSE,
  draw_plot = TRUE,
  ncores = container$experiment_params$ncores
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="run_gsea_one_factor_+3A_container">container</code></td>
<td>
<p>environment Project container that stores sub-containers
for each cell type as well as results and plots from all analyses</p>
</td></tr>
<tr><td><code id="run_gsea_one_factor_+3A_factor_select">factor_select</code></td>
<td>
<p>numeric The factor of interest</p>
</td></tr>
<tr><td><code id="run_gsea_one_factor_+3A_method">method</code></td>
<td>
<p>character The method of gsea to use. Can either be &quot;fgsea&quot;,
&quot;fgsea_special or &quot;hypergeometric&quot;. (default=&quot;fgsea&quot;)</p>
</td></tr>
<tr><td><code id="run_gsea_one_factor_+3A_thresh">thresh</code></td>
<td>
<p>numeric Pvalue significance threshold to use. Will include gene sets in
resulting heatmap if pvalue is below this threshold for at least one cell type. (default=0.05)</p>
</td></tr>
<tr><td><code id="run_gsea_one_factor_+3A_db_use">db_use</code></td>
<td>
<p>character The database of gene sets to use. Database
options include &quot;GO&quot;, &quot;Reactome&quot;, &quot;KEGG&quot;, and &quot;BioCarta&quot;. More than
one database can be used. (default=&quot;GO&quot;)</p>
</td></tr>
<tr><td><code id="run_gsea_one_factor_+3A_signed">signed</code></td>
<td>
<p>logical If TRUE, uses signed gsea. If FALSE, uses unsigned gsea.
Currently only works with fgsea method (default=TRUE)</p>
</td></tr>
<tr><td><code id="run_gsea_one_factor_+3A_min_gs_size">min_gs_size</code></td>
<td>
<p>numeric Minimum gene set size (default=15)</p>
</td></tr>
<tr><td><code id="run_gsea_one_factor_+3A_max_gs_size">max_gs_size</code></td>
<td>
<p>numeric Maximum gene set size (default=500)</p>
</td></tr>
<tr><td><code id="run_gsea_one_factor_+3A_reset_other_factor_plots">reset_other_factor_plots</code></td>
<td>
<p>logical Set to TRUE to set all other gsea plots to NULL (default=FALSE)</p>
</td></tr>
<tr><td><code id="run_gsea_one_factor_+3A_draw_plot">draw_plot</code></td>
<td>
<p>logical Set to TRUE to show the plot. Plot is stored regardless. (default=TRUE)</p>
</td></tr>
<tr><td><code id="run_gsea_one_factor_+3A_ncores">ncores</code></td>
<td>
<p>numeric The number of cores to use (default=container$experiment_params$ncores)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A stacked heatmap plot of the gsea results in the slot
container$plots$gsea$&lt;Factor#&gt;. The heatmaps show adjusted p-values for the
enrichment of each gene set in each cell type for the selected factor. The top
heatmap shows enriched gene sets among the positive loading genes and the bottom
heatmap shows enriched gene sets among the negative loading genes for the factor.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>test_container &lt;- run_gsea_one_factor(test_container, factor_select=1,
method="fgsea", thresh=0.05, db_use="Hallmark", signed=TRUE)
</code></pre>

<hr>
<h2 id='run_hypergeometric_gsea'>Compute enriched gene sets among significant genes in a cell type for
a factor using hypergeometric test</h2><span id='topic+run_hypergeometric_gsea'></span>

<h3>Description</h3>

<p>Compute enriched gene sets among significant genes in a cell type for
a factor using hypergeometric test
</p>


<h3>Usage</h3>

<pre><code class='language-R'>run_hypergeometric_gsea(
  container,
  factor_select,
  ctype,
  up_down,
  thresh = 0.05,
  min_gs_size = 15,
  max_gs_size = 500,
  db_use = "GO"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="run_hypergeometric_gsea_+3A_container">container</code></td>
<td>
<p>environment Project container that stores sub-containers
for each cell type as well as results and plots from all analyses</p>
</td></tr>
<tr><td><code id="run_hypergeometric_gsea_+3A_factor_select">factor_select</code></td>
<td>
<p>numeric The factor of interest</p>
</td></tr>
<tr><td><code id="run_hypergeometric_gsea_+3A_ctype">ctype</code></td>
<td>
<p>character The cell type of interest</p>
</td></tr>
<tr><td><code id="run_hypergeometric_gsea_+3A_up_down">up_down</code></td>
<td>
<p>character Either &quot;up&quot; to compute enrichment among the significant
positive loading genes or &quot;down&quot; to compute enrichment among the significant
negative loading genes.</p>
</td></tr>
<tr><td><code id="run_hypergeometric_gsea_+3A_thresh">thresh</code></td>
<td>
<p>numeric Pvalue significance threshold. Used as cutoff for calling
genes as significant to use for enrichment tests. (default=0.05)</p>
</td></tr>
<tr><td><code id="run_hypergeometric_gsea_+3A_min_gs_size">min_gs_size</code></td>
<td>
<p>numeric Minimum gene set size (default=15)</p>
</td></tr>
<tr><td><code id="run_hypergeometric_gsea_+3A_max_gs_size">max_gs_size</code></td>
<td>
<p>numeric Maximum gene set size (default=500)</p>
</td></tr>
<tr><td><code id="run_hypergeometric_gsea_+3A_db_use">db_use</code></td>
<td>
<p>character The database of gene sets to use. Database
options include &quot;GO&quot;, &quot;Reactome&quot;, &quot;KEGG&quot;, and &quot;BioCarta&quot;. More than
one database can be used. (default=&quot;GO&quot;)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector of adjusted p-values for enrichment of gene sets in the 
significant genes of a given cell type in a given factor.
</p>

<hr>
<h2 id='run_jackstraw'>Run jackstraw to get genes that are significantly associated with donor scores
for factors extracted by Tucker decomposition</h2><span id='topic+run_jackstraw'></span>

<h3>Description</h3>

<p>Run jackstraw to get genes that are significantly associated with donor scores
for factors extracted by Tucker decomposition
</p>


<h3>Usage</h3>

<pre><code class='language-R'>run_jackstraw(
  container,
  ranks,
  n_fibers = 100,
  n_iter = 500,
  tucker_type = "regular",
  rotation_type = "hybrid",
  seed = container$experiment_params$rand_seed,
  ncores = container$experiment_params$ncores
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="run_jackstraw_+3A_container">container</code></td>
<td>
<p>environment Project container that stores sub-containers
for each cell type as well as results and plots from all analyses</p>
</td></tr>
<tr><td><code id="run_jackstraw_+3A_ranks">ranks</code></td>
<td>
<p>numeric The number of donor ranks and gene ranks to decompose to
using Tucker decomposition</p>
</td></tr>
<tr><td><code id="run_jackstraw_+3A_n_fibers">n_fibers</code></td>
<td>
<p>numeric The number of fibers the randomly shuffle in each iteration
(default=100)</p>
</td></tr>
<tr><td><code id="run_jackstraw_+3A_n_iter">n_iter</code></td>
<td>
<p>numeric The number of shuffling iterations to complete (default=500)</p>
</td></tr>
<tr><td><code id="run_jackstraw_+3A_tucker_type">tucker_type</code></td>
<td>
<p>character Set to 'regular' to run regular tucker or to 'sparse' to run tucker
with sparsity constraints (default='regular')</p>
</td></tr>
<tr><td><code id="run_jackstraw_+3A_rotation_type">rotation_type</code></td>
<td>
<p>character Set to 'hybrid' to perform hybrid rotation on resulting donor factor
matrix and loadings. Otherwise set to 'ica_lds' to perform ica rotation on loadings or
ica_dsc to perform ica on donor scores. (default='hybrid')</p>
</td></tr>
<tr><td><code id="run_jackstraw_+3A_seed">seed</code></td>
<td>
<p>numeric Seed passed to set.seed() (default=container$experiment_params$rand_seed)</p>
</td></tr>
<tr><td><code id="run_jackstraw_+3A_ncores">ncores</code></td>
<td>
<p>numeric The number of cores to use (default=container$experiment_params$ncores)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The project container with a vector of adjusted pvalues in container$gene_score_associations.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>test_container &lt;- run_jackstraw(test_container, ranks=c(2,4), n_fibers=2, n_iter=10,
tucker_type='regular', rotation_type='hybrid', ncores=1)
</code></pre>

<hr>
<h2 id='run_stability_analysis'>Test stability of a decomposition by subsampling or bootstrapping donors. Note that
running this function will replace the decomposition in the project container
with one resulting from the tucker parameters entered here.</h2><span id='topic+run_stability_analysis'></span>

<h3>Description</h3>

<p>Test stability of a decomposition by subsampling or bootstrapping donors. Note that
running this function will replace the decomposition in the project container
with one resulting from the tucker parameters entered here.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>run_stability_analysis(
  container,
  ranks,
  tucker_type = "regular",
  rotation_type = "hybrid",
  subset_type = "subset",
  sub_prop = 0.75,
  n_iterations = 100,
  ncores = container$experiment_params$ncores
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="run_stability_analysis_+3A_container">container</code></td>
<td>
<p>environment Project container that stores sub-containers
for each cell type as well as results and plots from all analyses</p>
</td></tr>
<tr><td><code id="run_stability_analysis_+3A_ranks">ranks</code></td>
<td>
<p>numeric The number of donor, gene, and cell type ranks, respectively,
to decompose to using Tucker decomposition.</p>
</td></tr>
<tr><td><code id="run_stability_analysis_+3A_tucker_type">tucker_type</code></td>
<td>
<p>character The 'regular' type is the only one implemented
with sparsity constraints (default='regular')</p>
</td></tr>
<tr><td><code id="run_stability_analysis_+3A_rotation_type">rotation_type</code></td>
<td>
<p>character Set to 'hybrid' to optimize loadings via our hybrid
method (see paper for details). Set to 'ica_dsc' to perform ICA rotation
on resulting donor factor matrix. Set to 'ica_lds' to optimize loadings by the
ICA rotation. (default='hybrid')</p>
</td></tr>
<tr><td><code id="run_stability_analysis_+3A_subset_type">subset_type</code></td>
<td>
<p>character Set to either 'subset' or 'bootstrap' (default='subset')</p>
</td></tr>
<tr><td><code id="run_stability_analysis_+3A_sub_prop">sub_prop</code></td>
<td>
<p>numeric The proportion of donors to keep when using subset_type='subset' (default=.75)</p>
</td></tr>
<tr><td><code id="run_stability_analysis_+3A_n_iterations">n_iterations</code></td>
<td>
<p>numeric The number of iterations to perform (default=100)</p>
</td></tr>
<tr><td><code id="run_stability_analysis_+3A_ncores">ncores</code></td>
<td>
<p>numeric The number of cores to use (default=container$experiment_params$ncores)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The project container with the donor scores stability plot in
container$plots$stability_plot_dsc and the loadings stability plot in
container$plots$stability_plot_lds
</p>


<h3>Examples</h3>

<pre><code class='language-R'>test_container &lt;- run_stability_analysis(test_container, ranks=c(2,4),
tucker_type='regular', rotation_type='hybrid', subset_type='subset', 
sub_prop=0.75, n_iterations=5, ncores=1)
</code></pre>

<hr>
<h2 id='run_tucker_ica'>Run the Tucker decomposition and rotate the factors</h2><span id='topic+run_tucker_ica'></span>

<h3>Description</h3>

<p>Run the Tucker decomposition and rotate the factors
</p>


<h3>Usage</h3>

<pre><code class='language-R'>run_tucker_ica(
  container,
  ranks,
  tucker_type = "regular",
  rotation_type = "hybrid"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="run_tucker_ica_+3A_container">container</code></td>
<td>
<p>environment Project container that stores sub-containers
for each cell type as well as results and plots from all analyses</p>
</td></tr>
<tr><td><code id="run_tucker_ica_+3A_ranks">ranks</code></td>
<td>
<p>numeric The number of donor factors and gene factors, respectively,
to decompose the data into. Since we rearrange the standard output of
the Tucker decomposition to be 'donor centric', the number of donor factors will
also be the total number of main factors that can be used for downstream analysis.
The number of gene factors will only impact the quality of the decomposition.</p>
</td></tr>
<tr><td><code id="run_tucker_ica_+3A_tucker_type">tucker_type</code></td>
<td>
<p>character The 'regular' type is the only one currently implemented</p>
</td></tr>
<tr><td><code id="run_tucker_ica_+3A_rotation_type">rotation_type</code></td>
<td>
<p>character Set to 'hybrid' to optimize loadings via our hybrid
method (see paper for details). Set to 'ica_dsc' to perform ICA rotation
on resulting donor factor matrix. Set to 'ica_lds' to optimize loadings by the
ICA rotation. (default='hybrid')</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The project container with results of the decomposition in container$tucker_results.
The results object is a list with the donor scores matrix in the first element and the unfolded
loadings matrix in the second element.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>test_container &lt;- run_tucker_ica(test_container,ranks=c(2,4))
</code></pre>

<hr>
<h2 id='sample_fibers'>Get a list of tensor fibers to shuffle</h2><span id='topic+sample_fibers'></span>

<h3>Description</h3>

<p>Get a list of tensor fibers to shuffle
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sample_fibers(tensor_data, n_fibers)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sample_fibers_+3A_tensor_data">tensor_data</code></td>
<td>
<p>list The tensor data including donor, gene, and cell type labels
as well as the tensor array itself</p>
</td></tr>
<tr><td><code id="sample_fibers_+3A_n_fibers">n_fibers</code></td>
<td>
<p>numeric The number of fibers to get</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of gene and cell type indices for the randomly selected fibers
</p>

<hr>
<h2 id='scale_fontsize'>Scale font size. From simplifyEnrichment package.
https://github.com/jokergoo/simplifyEnrichment/blob/master/R/ht_clusters.R</h2><span id='topic+scale_fontsize'></span>

<h3>Description</h3>

<p>Scale font size. From simplifyEnrichment package.
https://github.com/jokergoo/simplifyEnrichment/blob/master/R/ht_clusters.R
</p>


<h3>Usage</h3>

<pre><code class='language-R'>scale_fontsize(x, rg = c(1, 30), fs = c(4, 16))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="scale_fontsize_+3A_x">x</code></td>
<td>
<p>A numeric vector.</p>
</td></tr>
<tr><td><code id="scale_fontsize_+3A_rg">rg</code></td>
<td>
<p>The range.</p>
</td></tr>
<tr><td><code id="scale_fontsize_+3A_fs">fs</code></td>
<td>
<p>Range of the font size.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A numeric vector.
</p>

<hr>
<h2 id='scale_variance'>Scale variance across donors for each gene within each cell type. Generally, this should be done through calling the
form_tensor() wrapper function.</h2><span id='topic+scale_variance'></span>

<h3>Description</h3>

<p>Scale variance across donors for each gene within each cell type. Generally, this should be done through calling the
form_tensor() wrapper function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>scale_variance(container, var_scale_power)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="scale_variance_+3A_container">container</code></td>
<td>
<p>environment Project container that stores sub-containers
for each cell type as well as results and plots from all analyses</p>
</td></tr>
<tr><td><code id="scale_variance_+3A_var_scale_power">var_scale_power</code></td>
<td>
<p>numeric Exponent of normalized variance that is
used for variance scaling. Variance for each gene
is initially set to unit variance across donors (for a given cell type).
Variance for each gene is then scaled by multiplying the unit scaled values
by each gene's normalized variance (where the effect of the mean-variance
dependence is taken into account) to the exponent specified here.
If NULL, uses var_scale_power from container$experiment_params.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The project container with the variance altered for each gene within
the pseudobulked matrices for each cell type.
</p>

<hr>
<h2 id='seurat_to_scMinimal'>Convert Seurat object to scMinimal object. Generally, this should be done through calling the
make_new_container() wrapper function.</h2><span id='topic+seurat_to_scMinimal'></span>

<h3>Description</h3>

<p>Convert Seurat object to scMinimal object. Generally, this should be done through calling the
make_new_container() wrapper function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>seurat_to_scMinimal(seurat_obj, metadata_cols = NULL, metadata_col_nm = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="seurat_to_scMinimal_+3A_seurat_obj">seurat_obj</code></td>
<td>
<p>Seurat object that has been cleaned and includes the normalized,
log-transformed counts. The meta.data should include a column with the header
'sex' and values of 'M' or 'F' if available. The metadata should
also have a column with the header 'ctypes' with the corresponding names of
the cell types as well as a column with header 'donors' that contains
identifiers for each donor.</p>
</td></tr>
<tr><td><code id="seurat_to_scMinimal_+3A_metadata_cols">metadata_cols</code></td>
<td>
<p>character The names of the metadata columns to use
(default=NULL)</p>
</td></tr>
<tr><td><code id="seurat_to_scMinimal_+3A_metadata_col_nm">metadata_col_nm</code></td>
<td>
<p>character New names for the selected metadata columns
if wish to change their names. If NULL, then the preexisting column names are
used. (default=NULL)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An scMinimal object holding counts and metadata for a project.
</p>

<hr>
<h2 id='shuffle_fibers'>Shuffle elements within the selected fibers</h2><span id='topic+shuffle_fibers'></span>

<h3>Description</h3>

<p>Shuffle elements within the selected fibers
</p>


<h3>Usage</h3>

<pre><code class='language-R'>shuffle_fibers(tensor_data, s_fibers)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="shuffle_fibers_+3A_tensor_data">tensor_data</code></td>
<td>
<p>list The tensor data including donor, gene, and cell type labels
as well as the tensor array itself</p>
</td></tr>
<tr><td><code id="shuffle_fibers_+3A_s_fibers">s_fibers</code></td>
<td>
<p>list Gene and cell type indices for the randomly selected fibers</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The tensor_data object with the values for the selected fibers shuffled.
</p>

<hr>
<h2 id='stack_tensor'>Create the tensor object by stacking each pseudobulk cell type matrix. 
Generally, this should be done through calling the form_tensor() wrapper function.</h2><span id='topic+stack_tensor'></span>

<h3>Description</h3>

<p>Create the tensor object by stacking each pseudobulk cell type matrix. 
Generally, this should be done through calling the form_tensor() wrapper function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>stack_tensor(container)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="stack_tensor_+3A_container">container</code></td>
<td>
<p>environment Project container that stores sub-containers
for each cell type as well as results and plots from all analyses</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The project container with the list of tensor data in container$tensor_data.
</p>

<hr>
<h2 id='stop_wrap'>Helper function from simplifyEnrichment package.
https://github.com/jokergoo/simplifyEnrichment/blob/master/R/utils.R</h2><span id='topic+stop_wrap'></span>

<h3>Description</h3>

<p>Helper function from simplifyEnrichment package.
https://github.com/jokergoo/simplifyEnrichment/blob/master/R/utils.R
</p>


<h3>Usage</h3>

<pre><code class='language-R'>stop_wrap(...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="stop_wrap_+3A_...">...</code></td>
<td>
<p>other parameters</p>
</td></tr>
</table>


<h3>Value</h3>

<p>No value is returned.
</p>

<hr>
<h2 id='subset_scMinimal'>Subset an scMinimal object by specified genes, donors, cells, or cell types</h2><span id='topic+subset_scMinimal'></span>

<h3>Description</h3>

<p>Subset an scMinimal object by specified genes, donors, cells, or cell types
</p>


<h3>Usage</h3>

<pre><code class='language-R'>subset_scMinimal(
  scMinimal,
  ctypes_use = NULL,
  cells_use = NULL,
  donors_use = NULL,
  genes_use = NULL,
  in_place = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="subset_scMinimal_+3A_scminimal">scMinimal</code></td>
<td>
<p>environment A sub-container for the project typically
consisting of gene expression data in its raw and processed forms as well
as metadata</p>
</td></tr>
<tr><td><code id="subset_scMinimal_+3A_ctypes_use">ctypes_use</code></td>
<td>
<p>character The cell types to keep (default=NULL)</p>
</td></tr>
<tr><td><code id="subset_scMinimal_+3A_cells_use">cells_use</code></td>
<td>
<p>character Cell barcodes for the cells to keep (default=NULL)</p>
</td></tr>
<tr><td><code id="subset_scMinimal_+3A_donors_use">donors_use</code></td>
<td>
<p>character The donors to keep (default=NULL)</p>
</td></tr>
<tr><td><code id="subset_scMinimal_+3A_genes_use">genes_use</code></td>
<td>
<p>character The genes to keep (default=NULL)</p>
</td></tr>
<tr><td><code id="subset_scMinimal_+3A_in_place">in_place</code></td>
<td>
<p>logical If set to TRUE then replaces the input object with the
new subsetted object (default=TRUE)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A subsetted scMinimal object.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>cell_names &lt;- colnames(test_container$scMinimal_full$count_data)
cells_sub &lt;- sample(cell_names,40)
scMinimal &lt;- subset_scMinimal(test_container$scMinimal_full,
cells_use=cells_sub)
</code></pre>

<hr>
<h2 id='test_container'>Data container for testing tensor formation steps</h2><span id='topic+test_container'></span>

<h3>Description</h3>

<p>Data container for testing tensor formation steps
</p>


<h3>Usage</h3>

<pre><code class='language-R'>test_container
</code></pre>


<h3>Format</h3>

<p>An object of class <code>environment</code> of length 10.
</p>

<hr>
<h2 id='tucker_ica_helper'>Helper function for running the decomposition. Use the run_tucker_ica()
wrapper function instead.</h2><span id='topic+tucker_ica_helper'></span>

<h3>Description</h3>

<p>Helper function for running the decomposition. Use the run_tucker_ica()
wrapper function instead.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tucker_ica_helper(
  tensor_data,
  ranks,
  tucker_type,
  rotation_type,
  projection_container = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tucker_ica_helper_+3A_tensor_data">tensor_data</code></td>
<td>
<p>list The tensor data including donor, gene, and cell type labels
as well as the tensor array itself</p>
</td></tr>
<tr><td><code id="tucker_ica_helper_+3A_ranks">ranks</code></td>
<td>
<p>numeric The number of donor and gene factors respectively,
to decompose to using Tucker decomposition.</p>
</td></tr>
<tr><td><code id="tucker_ica_helper_+3A_tucker_type">tucker_type</code></td>
<td>
<p>character The 'regular' type is the only one currently implemented</p>
</td></tr>
<tr><td><code id="tucker_ica_helper_+3A_rotation_type">rotation_type</code></td>
<td>
<p>character Set to 'hybrid' to optimize loadings via our hybrid
method (see paper for details). Set to 'ica_dsc' to perform ICA rotation
on resulting donor factor matrix. Set to 'ica_lds' to optimize loadings by the
ICA rotation.</p>
</td></tr>
<tr><td><code id="tucker_ica_helper_+3A_projection_container">projection_container</code></td>
<td>
<p>environment A project container to store projection
data in. Currently only implemented for 'hybrid' and 'ica_dsc' rotations. (default=NULL)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The list of results for tucker decomposition with donor scores matrix in first
element and loadings matrix in second element.
</p>

<hr>
<h2 id='update_params'>Update any of the experiment-wide parameters</h2><span id='topic+update_params'></span>

<h3>Description</h3>

<p>Update any of the experiment-wide parameters
</p>


<h3>Usage</h3>

<pre><code class='language-R'>update_params(container, ctypes_use = NULL, ncores = NULL, rand_seed = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="update_params_+3A_container">container</code></td>
<td>
<p>environment Project container that stores sub-containers
for each cell type as well as results and plots from all analyses</p>
</td></tr>
<tr><td><code id="update_params_+3A_ctypes_use">ctypes_use</code></td>
<td>
<p>character Names of the cell types to use for the analysis
(default=NULL)</p>
</td></tr>
<tr><td><code id="update_params_+3A_ncores">ncores</code></td>
<td>
<p>numeric Number of cores to use (default=NULL)</p>
</td></tr>
<tr><td><code id="update_params_+3A_rand_seed">rand_seed</code></td>
<td>
<p>numeric Random seed to use (default=NULL)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The project container with updated experiment parameters in
container$experiment_params.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>test_container &lt;- update_params(test_container, ncores=1)
</code></pre>

<hr>
<h2 id='vargenes_anova'>Compute significantly variable genes via anova. Generally, this should be done through calling the
form_tensor() wrapper function.</h2><span id='topic+vargenes_anova'></span>

<h3>Description</h3>

<p>Compute significantly variable genes via anova. Generally, this should be done through calling the
form_tensor() wrapper function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>vargenes_anova(scMinimal, ncores)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="vargenes_anova_+3A_scminimal">scMinimal</code></td>
<td>
<p>environment A sub-container for the project typically
consisting of gene expression data in its raw and processed forms</p>
</td></tr>
<tr><td><code id="vargenes_anova_+3A_ncores">ncores</code></td>
<td>
<p>numeric Number of cores to use</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of raw p-values for each gene.
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
