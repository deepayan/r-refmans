<!DOCTYPE html><html><head><title>Help for package SBmedian</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {SBmedian}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#SBmedian'><p>Scalable Bayes with Median of Subset Posteriors</p></a></li>
<li><a href='#mpost.euc'><p>Median Posterior for Subset Posterior Samples in Euclidean Space</p></a></li>
<li><a href='#mpost.spd'><p>Median Posterior for Subset Posterior Samples in SPD manifold</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Scalable Bayes with Median of Subset Posteriors</td>
</tr>
<tr>
<td>Version:</td>
<td>0.1.1</td>
</tr>
<tr>
<td>Description:</td>
<td>Median-of-means is a generic yet powerful framework for scalable and robust estimation. A framework for Bayesian analysis is called M-posterior, which estimates a median of subset posterior measures. For general exposition to the topic, see the paper by Minsker (2015) &lt;<a href="https://doi.org/10.3150%2F14-BEJ645">doi:10.3150/14-BEJ645</a>&gt;.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://opensource.org/licenses/mit-license.php">MIT</a> + file LICENSE</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>Imports:</td>
<td>Rcpp, Rdpack, expm, stats, utils</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>Rcpp, RcppArmadillo</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.1.1</td>
</tr>
<tr>
<td>RdMacros:</td>
<td>Rdpack</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2021-08-14 03:21:31 UTC; kisung</td>
</tr>
<tr>
<td>Author:</td>
<td>Kisung You <a href="https://orcid.org/0000-0002-8584-459X"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [aut,
    cre]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Kisung You &lt;kisungyou@outlook.com&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2021-08-16 07:10:05 UTC</td>
</tr>
</table>
<hr>
<h2 id='SBmedian'>Scalable Bayes with Median of Subset Posteriors</h2><span id='topic+SBmedian'></span><span id='topic+SBmedian-package'></span>

<h3>Description</h3>

<p>Median-of-means is a generic yet powerful framework for scalable and robust estimation. 
A framework for Bayesian analysis is called M-posterior, which estimates a median of subset posterior measures.
</p>

<hr>
<h2 id='mpost.euc'>Median Posterior for Subset Posterior Samples in Euclidean Space</h2><span id='topic+mpost.euc'></span>

<h3>Description</h3>

<p><code>mpost.euc</code> is a general framework to <em>merge</em> multiple 
empirical measures <code class="reqn">Q_1,Q_2,\ldots,Q_M \subset R^p</code> from independent subset of data by finding a median 
</p>
<p style="text-align: center;"><code class="reqn">\hat{Q} = \textrm{argmin}_Q \sum_{m=1}^M d(Q,Q_m)</code>
</p>

<p>where <code class="reqn">Q</code> is a weighted combination and <code class="reqn">d(P_1,P_2)</code> is distance in RKHS between two empirical measures <code class="reqn">P_1</code> and <code class="reqn">P_2</code>. 
As in the references, we use RBF kernel with bandwidth parameter <code class="reqn">\sigma</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mpost.euc(
  splist,
  sigma = 0.1,
  maxiter = 121,
  abstol = 1e-06,
  show.progress = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mpost.euc_+3A_splist">splist</code></td>
<td>
<p>a list of length <code class="reqn">M</code> containing vectors or matrices of univariate or multivariate subset posterior samples respectively.</p>
</td></tr>
<tr><td><code id="mpost.euc_+3A_sigma">sigma</code></td>
<td>
<p>bandwidth parameter for RBF kernel.</p>
</td></tr>
<tr><td><code id="mpost.euc_+3A_maxiter">maxiter</code></td>
<td>
<p>maximum number of iterations for Weiszfeld algorithm.</p>
</td></tr>
<tr><td><code id="mpost.euc_+3A_abstol">abstol</code></td>
<td>
<p>stopping criterion for Weiszfeld algorithm.</p>
</td></tr>
<tr><td><code id="mpost.euc_+3A_show.progress">show.progress</code></td>
<td>
<p>a logical; <code>TRUE</code> to show iteration mark, <code>FALSE</code> otherwise.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a named list containing:
</p>

<dl>
<dt>med.atoms</dt><dd><p>a vector or matrix of all atoms aggregated.</p>
</dd>
<dt>med.weights</dt><dd><p>a weight vector that sums to 1 corresponding to <code>med.atoms</code>.</p>
</dd>
<dt>weiszfeld.weights</dt><dd><p>a weight for <code class="reqn">M</code> subset posteriors.</p>
</dd>
<dt>weiszfeld.history</dt><dd><p>updated parameter values. Each row is for iteration, while columns are weights corresponding to <code>weiszfeld.weights</code>.</p>
</dd>
</dl>



<h3>References</h3>

<p>Minsker S, Srivastava S, Lin L, Dunson DB (2014).
&ldquo;Scalable and Robust Bayesian Inference via the Median Posterior.&rdquo;
In <em>Proceedings of the 31st International Conference on International Conference on Machine Learning - Volume 32</em>,  ICMLâ€™14, II&ndash;1656&ndash;II&ndash;1664.
event-place: Beijing, China.
</p>
<p>Minsker S, Srivastava S, Lin L, Dunson DB (2017).
&ldquo;Robust and Scalable Bayes via a Median of Subset Posterior Measures.&rdquo;
<em>Journal of Machine Learning Research</em>, <b>18</b>(124), 1&ndash;40.
<a href="https://jmlr.org/papers/v18/16-655.html">https://jmlr.org/papers/v18/16-655.html</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Median Posteior from 2-D Gaussian Samples
#  Step 1. let's build a list of atoms whose numbers differ
set.seed(8128)                   # for reproducible results
mydata = list()
mydata[[1]] = cbind(rnorm(96, mean= 1), rnorm(96, mean= 1))
mydata[[2]] = cbind(rnorm(78, mean=-1), rnorm(78, mean= 0))
mydata[[3]] = cbind(rnorm(65, mean=-1), rnorm(65, mean= 1))
mydata[[4]] = cbind(rnorm(77, mean= 2), rnorm(77, mean=-1))

#  Step 2. Let's run the algorithm
myrun = mpost.euc(mydata, show.progress=TRUE)

#  Step 3. Visualize
#  3-1. show subset posterior samples
opar &lt;- par(no.readonly=TRUE)
par(mfrow=c(2,3), no.readonly=TRUE)
for (i in 1:4){
  plot(mydata[[i]], cex=0.5, col=(i+1), pch=19, xlab="", ylab="", 
       main=paste("subset",i), xlim=c(-4,4), ylim=c(-3,3))
}

#  3-2. 250 median posterior samples via importance sampling
id250 = base::sample(1:nrow(myrun$med.atoms), 250, prob=myrun$med.weights, replace=TRUE)
sp250 = myrun$med.atoms[id250,]
plot(sp250, cex=0.5, pch=19, xlab="", ylab="", 
     xlim=c(-4,4), ylim=c(-3,3), main="median samples")

#  3-3. convergence over iterations
matplot(myrun$weiszfeld.history, xlab="iteration", ylab="value",
        type="b", main="convergence of weights")
par(opar)
        
</code></pre>

<hr>
<h2 id='mpost.spd'>Median Posterior for Subset Posterior Samples in SPD manifold</h2><span id='topic+mpost.spd'></span>

<h3>Description</h3>

<p>SPD manifold is a collection of matrices that are symmetric and positive-definite and 
it is well known that using Euclidean geometry for data on the manifold is rather inaccurate. 
Here, we propose a function for dealing with SPD matrices specifically where valid examples include 
full-rank covariance and precision matrices. Note that <code class="reqn">N_M = \sum_{m=1}^M n_m</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mpost.spd(
  splist,
  sigma = 0.1,
  maxiter = 121,
  abstol = 1e-06,
  show.progress = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mpost.spd_+3A_splist">splist</code></td>
<td>
<p>a list of length <code class="reqn">M</code> containing <code class="reqn">(p\times p)</code> matrix or 3d array of size <code class="reqn">(p\times p\times n_m)</code> whose slices are SPD matrices from subset posterior samples respectively.</p>
</td></tr>
<tr><td><code id="mpost.spd_+3A_sigma">sigma</code></td>
<td>
<p>bandwidth parameter for RBF kernel.</p>
</td></tr>
<tr><td><code id="mpost.spd_+3A_maxiter">maxiter</code></td>
<td>
<p>maximum number of iterations for Weiszfeld algorithm.</p>
</td></tr>
<tr><td><code id="mpost.spd_+3A_abstol">abstol</code></td>
<td>
<p>stopping criterion for Weiszfeld algorithm.</p>
</td></tr>
<tr><td><code id="mpost.spd_+3A_show.progress">show.progress</code></td>
<td>
<p>a logical; <code>TRUE</code> to show iteration mark, <code>FALSE</code> otherwise.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a named list containing:
</p>

<dl>
<dt>med.atoms</dt><dd><p>a <code class="reqn">(p\times p\times N_M)</code> 3d array whose slices are atoms aggregated.</p>
</dd>
<dt>med.weights</dt><dd><p>a weight vector that sums to 1 corresponding to <code>med.atoms</code>.</p>
</dd>
<dt>weiszfeld.weights</dt><dd><p>a weight for <code class="reqn">M</code> subset posteriors.</p>
</dd>
<dt>weiszfeld.history</dt><dd><p>updated parameter values. Each row is for iteration, while columns are weights corresponding to <code>weiszfeld.weights</code>.</p>
</dd>
</dl>



<h3>Examples</h3>

<pre><code class='language-R'>## Median Posteior from 5-dimension Wishart distribution
## Visualization will be performed for distribution of larget eigenvalue
## where RED is for estimated density and BLUE is density from all samples.

#  Step 1. let's build a list of atoms whose numbers differ
set.seed(8128)                   # for reproducible results
mydata = list()
mydata[[1]] = stats::rWishart(96, df=10, Sigma=diag(5))
mydata[[2]] = stats::rWishart(78, df=10, Sigma=diag(5))
mydata[[3]] = stats::rWishart(65, df=10, Sigma=diag(5))
mydata[[4]] = stats::rWishart(77, df=10, Sigma=diag(5))

#  Step 2. Let's run the algorithm
myrun = mpost.spd(mydata, show.progress=TRUE)

#  Step 3. Compute largest eigenvalues for the samples
eig4 = list()
for (i in 1:4){
  spdmats = mydata[[i]]        # SPD atoms
  spdsize = dim(spdmats)[3]    # number of atoms
  eigvals = rep(0,spdsize)     # compute largest eigenvalues
  for (j in 1:spdsize){
    eigvals[j] = max(base::eigen(spdmats[,,j])$values)
  }
  eig4[[i]] = eigvals
}
eigA   = unlist(eig4)
eiglim = c(min(eigA), max(eigA))

#  Step 4. Visualize
#  4-1. show distribution of subset posterior samples' eigenvalues
opar &lt;- par(no.readonly=TRUE)
par(mfrow=c(2,3))
for (i in 1:4){
  hist(eig4[[i]], main=paste("subset", i), xlab="largest eigenvalues", 
       prob=TRUE, xlim=eiglim, ylim=c(0,0.1))
  lines(stats::density(eig4[[i]]), lwd=1, col="red")
  lines(stats::density(eigA),      lwd=1, col="blue")
}

#  4-2. 250 median posterior samples via importance sampling
id250 = base::sample(1:length(eigA), 250, prob=myrun$med.weights, replace=TRUE)
sp250 = eigA[id250]
hist(sp250, main="median samples", xlab="largest eigenvalues", 
     prob=TRUE, xlim=eiglim, ylim=c(0,0.1))
lines(stats::density(sp250), lwd=1, col="red")
lines(stats::density(eigA),  lwd=1, col="blue")

#  4-3. convergence over iterations
matplot(myrun$weiszfeld.history, xlab="iteration", ylab="value",
        type="b", main="convergence of weights")
par(opar)

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
