<!DOCTYPE html><html><head><title>Help for package nCopula</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {nCopula}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#AMH'><p>Construction of an Archimedean Copula Class Object.</p></a></li>
<li><a href='#amh-class'><p>AMH copula class</p></a></li>
<li><a href='#archm-class'><p>Archimedean copulas family</p></a></li>
<li><a href='#Child-class'><p>Child Class</p></a></li>
<li><a href='#Clayton'><p>Construction of an Archimedean Copula Class Object</p></a></li>
<li><a href='#clayton-class'><p>Clayton copula class</p></a></li>
<li><a href='#Frank'><p>Construction of an Archimedean Copula Class Object</p></a></li>
<li><a href='#frank-class'><p>Frank copula class</p></a></li>
<li><a href='#GAMMA'><p>Construction of a GAMMA Child Class Object</p></a></li>
<li><a href='#Gamma_Child-class'><p>Gamma-Child Class</p></a></li>
<li><a href='#GeneticCodes'><p>Obtain the Genetic Codes of a Structure</p></a></li>
<li><a href='#GEO'><p>Construction of a GEO Mother or Child Class Object</p></a></li>
<li><a href='#Geo_Child-class'><p>Geo-Child Class</p></a></li>
<li><a href='#Geo_Mother-class'><p>Geo-Mother Class</p></a></li>
<li><a href='#Gumbel'><p>Construction of an Archimedean Copula Class Object</p></a></li>
<li><a href='#gumbel-class'><p>Gumvel copula class</p></a></li>
<li><a href='#InvLap'><p>Inverse LST of a Node</p></a></li>
<li><a href='#Lap'><p>LST of a Node</p></a></li>
<li><a href='#LOG'><p>Construction of a LOG Mother or Child Class Object</p></a></li>
<li><a href='#Log_Child-class'><p>Log-Child Class</p></a></li>
<li><a href='#Log_Mother-class'><p>Log-Mother Class</p></a></li>
<li><a href='#Moth'><p>Show Method Function for Compounding</p></a></li>
<li><a href='#Mother-class'><p>Mother Class</p></a></li>
<li><a href='#Node'><p>Obtain a node in mother class object</p></a></li>
<li><a href='#pCompCop'><p>Distribution function of Mother class objects</p></a></li>
<li><a href='#pCop'><p>Distribution function of archm class objects</p></a></li>
<li><a href='#rCompCop'><p>Random number generator for Mother class objects</p></a></li>
<li><a href='#rCop'><p>Random number generator for Archimedean copula class objects</p></a></li>
<li><a href='#show,archm-method'><p>Show Method for Copulas</p></a></li>
<li><a href='#show,Child-method'><p>Show Method for Compounding Functions - Child Class</p></a></li>
<li><a href='#show,Mother-method'><p>Show Method for Compounding Functions - Mother Class</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Hierarchical Archimedean Copulas Constructed with Multivariate
Compound Distributions</td>
</tr>
<tr>
<td>Version:</td>
<td>0.1.1</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Simon-Pierre Gadoury &lt;spgadou@me.com&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Construct and manipulate hierarchical Archimedean copulas with multivariate compound distributions. The model used is the one of Cossette et al. (2017) &lt;<a href="https://doi.org/10.1016%2Fj.insmatheco.2017.06.001">doi:10.1016/j.insmatheco.2017.06.001</a>&gt;. </td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.4.0), copula</td>
</tr>
<tr>
<td>Imports:</td>
<td>Deriv, stringr, stringi, compiler, methods,</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>LazyData:</td>
<td>FALSE</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>6.0.1</td>
</tr>
<tr>
<td>Suggests:</td>
<td>knitr, rmarkdown</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2018-11-19 20:48:52 UTC; Simon-Pierre</td>
</tr>
<tr>
<td>Author:</td>
<td>Simon-Pierre Gadoury [cre, aut],
  David Beauchemin [ctb]</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2018-11-30 12:40:07 UTC</td>
</tr>
</table>
<hr>
<h2 id='AMH'>Construction of an Archimedean Copula Class Object.</h2><span id='topic+AMH'></span>

<h3>Description</h3>

<p>Constructs an AMH Archimedean copula object with
a given parameter and dimension.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>AMH(param, dim = 2L, density = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="AMH_+3A_param">param</code></td>
<td>
<p>parameter of the copula.</p>
</td></tr>
<tr><td><code id="AMH_+3A_dim">dim</code></td>
<td>
<p>dimension of the copula (&gt;= 2), which is, by default, 2.</p>
</td></tr>
<tr><td><code id="AMH_+3A_density">density</code></td>
<td>
<p>compute the expression of the density of the copulas.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Constructs an AMH Archimedean copula object with a given parameter and dimension.
</p>


<h3>Value</h3>

<p>An archm S4 class object.
</p>


<h3>Author(s)</h3>

<p>Simon-Pierre Gadoury
</p>

<hr>
<h2 id='amh-class'>AMH copula class</h2><span id='topic+amh-class'></span>

<h3>Description</h3>

<p>AMH copula
</p>

<hr>
<h2 id='archm-class'>Archimedean copulas family</h2><span id='topic+archm-class'></span>

<h3>Description</h3>

<p>Archimedean copulas
</p>

<hr>
<h2 id='Child-class'>Child Class</h2><span id='topic+Child-class'></span>

<h3>Description</h3>

<p>Child Class
</p>

<hr>
<h2 id='Clayton'>Construction of an Archimedean Copula Class Object</h2><span id='topic+Clayton'></span>

<h3>Description</h3>

<p>Constructs a Clayton Archimedean copula object with
a given parameter and dimension.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Clayton(param, dim = 2L, density = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Clayton_+3A_param">param</code></td>
<td>
<p>the parameter of the copula.</p>
</td></tr>
<tr><td><code id="Clayton_+3A_dim">dim</code></td>
<td>
<p>the dimension of the copula (&gt;= 2), which is, by default, 2.</p>
</td></tr>
<tr><td><code id="Clayton_+3A_density">density</code></td>
<td>
<p>logical. Should the expression of the density of the copula be computed?</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An archm S4 class object.
</p>


<h3>Author(s)</h3>

<p>Simon-Pierre Gadoury
</p>

<hr>
<h2 id='clayton-class'>Clayton copula class</h2><span id='topic+clayton-class'></span>

<h3>Description</h3>

<p>Clayton copula
</p>

<hr>
<h2 id='Frank'>Construction of an Archimedean Copula Class Object</h2><span id='topic+Frank'></span>

<h3>Description</h3>

<p>Constructs a Frank Archimedean copula object with
a given parameter and dimension.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Frank(param, dim = 2L, density = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Frank_+3A_param">param</code></td>
<td>
<p>parameter of the copula.</p>
</td></tr>
<tr><td><code id="Frank_+3A_dim">dim</code></td>
<td>
<p>dimension of the copula (&gt;= 2), which is, by default, 2.</p>
</td></tr>
<tr><td><code id="Frank_+3A_density">density</code></td>
<td>
<p>compute the expression of the density of the copulas.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An archm S4 class object.
</p>


<h3>Author(s)</h3>

<p>Simon-Pierre Gadoury
</p>

<hr>
<h2 id='frank-class'>Frank copula class</h2><span id='topic+frank-class'></span>

<h3>Description</h3>

<p>Frank copula
</p>

<hr>
<h2 id='GAMMA'>Construction of a GAMMA Child Class Object</h2><span id='topic+GAMMA'></span>

<h3>Description</h3>

<p>The function GAMMA constructs a gamma Child class object for
a given parameter and arguments.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>GAMMA(par, unif, structure = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="GAMMA_+3A_par">par</code></td>
<td>
<p>parameter of the distribution.</p>
</td></tr>
<tr><td><code id="GAMMA_+3A_unif">unif</code></td>
<td>
<p>uniform structure, a numeric vector of grouped
numbers, i.e. c(1,2,3) is translated as being c(u1, u2, u3).</p>
</td></tr>
<tr><td><code id="GAMMA_+3A_structure">structure</code></td>
<td>
<p>nesting structure of the form
</p>
<p>X(par1, c(i,...), list(Y(par2, c(j,...), NULL),
Z(par3, c(k,...), NULL))),
</p>
<p>where X, Y, and Z are compatible functions (see 'details').
It is to note that if structure is NULL, the function will automatically
be of class Child. For continuous distributions (i.e. GAMMA), structure is
always NULL.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Simon-Pierre Gadoury
</p>


<h3>See Also</h3>

<p>Other mother or child class objects.: <code><a href="#topic+GEO">GEO</a></code>,
<code><a href="#topic+LOG">LOG</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>GEO(0.5, NULL, list(GAMMA(1/30, c(5,6), NULL),
                    GEO(0.1, NULL, list(GAMMA(1/30, c(1,2), NULL),
                                        GAMMA(1/30, c(3,4), NULL)))))
</code></pre>

<hr>
<h2 id='Gamma_Child-class'>Gamma-Child Class</h2><span id='topic+Gamma_Child-class'></span>

<h3>Description</h3>

<p>CompCop structure
</p>

<hr>
<h2 id='GeneticCodes'>Obtain the Genetic Codes of a Structure</h2><span id='topic+GeneticCodes'></span>

<h3>Description</h3>

<p>Function to obtain the list of all genetic codes of a structure.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>GeneticCodes(structure)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="GeneticCodes_+3A_structure">structure</code></td>
<td>
<p>an object of class Mother (the structure)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of the structure's genetic codes.
</p>


<h3>Author(s)</h3>

<p>Simon-Pierre Gadoury
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Create the structure
structure &lt;- GEO(0.5, NULL, list(GAMMA(1/30, c(5,6), NULL),
                           GEO(0.1, NULL, list(GAMMA(1/30, c(1,2), NULL),
                                               GAMMA(1/30, c(3,4), NULL)))))
## Get the genetic codes
GeneticCodes(structure)

</code></pre>

<hr>
<h2 id='GEO'>Construction of a GEO Mother or Child Class Object</h2><span id='topic+GEO'></span>

<h3>Description</h3>

<p>Constructs either a GEO Mother or Child class object for
a given parameter, arguments, and nesting structure.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>GEO(par, unif, structure)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="GEO_+3A_par">par</code></td>
<td>
<p>parameter of the distribution.</p>
</td></tr>
<tr><td><code id="GEO_+3A_unif">unif</code></td>
<td>
<p>uniform structure, a numeric vector of grouped.
numbers, i.e. c(1,2,3) is translated as being c(u1, u2, u3).</p>
</td></tr>
<tr><td><code id="GEO_+3A_structure">structure</code></td>
<td>
<p>nesting structure of the form
</p>
<p>X(par1, c(i,...), list(Y(par2, c(j,...), NULL),
Z(par3, c(k,...), NULL))),
</p>
<p>where X, Y, and Z are compatible functions (see 'details').
It is to note that if structure is NULL, the function will automatically
be of class Child. For continuous distributions (i.e. GAMMA), structure is
always NULL.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Simon-Pierre Gadoury
</p>


<h3>See Also</h3>

<p>Other mother or child class objects.: <code><a href="#topic+GAMMA">GAMMA</a></code>,
<code><a href="#topic+LOG">LOG</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>GEO(0.5, NULL, list(GAMMA(1/30, c(5,6), NULL),
                    GEO(0.1, NULL, list(GAMMA(1/30, c(1,2), NULL),
                                        GAMMA(1/30, c(3,4), NULL)))))
</code></pre>

<hr>
<h2 id='Geo_Child-class'>Geo-Child Class</h2><span id='topic+Geo_Child-class'></span>

<h3>Description</h3>

<p>CompCop structure
</p>

<hr>
<h2 id='Geo_Mother-class'>Geo-Mother Class</h2><span id='topic+Geo_Mother-class'></span>

<h3>Description</h3>

<p>CompCop structure
</p>

<hr>
<h2 id='Gumbel'>Construction of an Archimedean Copula Class Object</h2><span id='topic+Gumbel'></span>

<h3>Description</h3>

<p>Constructs a Gumbel Archimedean copula object with
a given parameter and dimension.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Gumbel(param, dim = 2L)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Gumbel_+3A_param">param</code></td>
<td>
<p>parameter of the copula</p>
</td></tr>
<tr><td><code id="Gumbel_+3A_dim">dim</code></td>
<td>
<p>dimension of the copula (&gt;= 2), which is, by default, 2</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An archm S4 class object.
</p>


<h3>Author(s)</h3>

<p>Simon-Pierre Gadoury
</p>

<hr>
<h2 id='gumbel-class'>Gumvel copula class</h2><span id='topic+gumbel-class'></span>

<h3>Description</h3>

<p>Gumbel copula
</p>

<hr>
<h2 id='InvLap'>Inverse LST of a Node</h2><span id='topic+InvLap'></span>

<h3>Description</h3>

<p>With a specific path and a predefined structure
(S4 class of a type 'Mother'), returns the inverse Laplace-Stieltjes Transform expression of
the corresponding node with a specific variable.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>InvLap(code, structure, outVar = "z", par = "value")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="InvLap_+3A_code">code</code></td>
<td>
<p>the genetic code (numeric vector) of the node (can be a leaf i.e. end by 0).</p>
</td></tr>
<tr><td><code id="InvLap_+3A_structure">structure</code></td>
<td>
<p>an object of class Mother (the structure).</p>
</td></tr>
<tr><td><code id="InvLap_+3A_outvar">outVar</code></td>
<td>
<p>the output variable to be used ('z' by default).</p>
</td></tr>
<tr><td><code id="InvLap_+3A_par">par</code></td>
<td>
<p>logical. Should the parameters be values ('value') or variables ('variable') ?</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For mother nodes, parameters are always called 'gamma' and for child nodes, parameters are
always called 'alpha'. Furthermore, to recognize the parameters, the path is inserted at the end.
For exemple, a child node with path (0,2,1) will have the parameter 'alpha021'.
</p>


<h3>Value</h3>

<p>A character string giving the inverse LST of the specified node.
</p>


<h3>Author(s)</h3>

<p>Simon-Pierre Gadoury
</p>


<h3>See Also</h3>

<p><a href="#topic+Lap">Lap</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
structure &lt;- GEO(0.1, NULL, list(GAMMA(0.1, 1:2, NULL),
                           GAMMA(0.2, 3:4, NULL)))

InvLap(c(0,2), structure, outVar = 'z', par = 'value')

</code></pre>

<hr>
<h2 id='Lap'>LST of a Node</h2><span id='topic+Lap'></span>

<h3>Description</h3>

<p>With a specific path and a predefined structure
(S4 class of a type 'Mother'), returns the Laplace-Stieltjes Transform expression of
the corresponding node with a specific variable.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Lap(code, structure, outVar = "z", par = "value")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Lap_+3A_code">code</code></td>
<td>
<p>genetic code (numeric vector) of the node (can be a leaf i.e. end by 0).</p>
</td></tr>
<tr><td><code id="Lap_+3A_structure">structure</code></td>
<td>
<p>object of class Mother (the structure).</p>
</td></tr>
<tr><td><code id="Lap_+3A_outvar">outVar</code></td>
<td>
<p>output variable to be used ('z' by default).</p>
</td></tr>
<tr><td><code id="Lap_+3A_par">par</code></td>
<td>
<p>Should the parameters be values ('value') or variables ('variable') ?</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For mother nodes, parameters are always called 'gamma' and for child nodes, parameters are
always called 'alpha'. Furthermore, to recognize the parameters, the path is inserted at the end.
For exemple, a child node with path (0,2,1) will have the parameter 'alpha021'.
</p>


<h3>Value</h3>

<p>A character string giving the LST of the specified node.
</p>


<h3>Author(s)</h3>

<p>Simon-Pierre Gadoury
</p>


<h3>See Also</h3>

<p><a href="#topic+InvLap">InvLap</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
structure &lt;- GEO(0.1, NULL, list(GAMMA(0.1, 1:2, NULL),
                           GAMMA(0.2, 3:4, NULL)))

Lap(c(0,2), structure, outVar = 'z', par = 'value')

</code></pre>

<hr>
<h2 id='LOG'>Construction of a LOG Mother or Child Class Object</h2><span id='topic+LOG'></span>

<h3>Description</h3>

<p>Constructs either a LOG Mother or Child class object for
a given parameter, arguments, and nesting structure.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>LOG(par, unif, structure)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="LOG_+3A_par">par</code></td>
<td>
<p>parameter of the distribution.</p>
</td></tr>
<tr><td><code id="LOG_+3A_unif">unif</code></td>
<td>
<p>uniform structure, a numeric vector of grouped
numbers, i.e. c(1,2,3) is translated as being c(u1, u2, u3).</p>
</td></tr>
<tr><td><code id="LOG_+3A_structure">structure</code></td>
<td>
<p>nesting structure of the form
</p>
<p>X(par1, c(i,...), list(Y(par2, c(j,...), NULL),
Z(par3, c(k,...), NULL))),
</p>
<p>where X, Y, and Z are compatible functions (see 'details').
It is good to note that if structure is NULL, the function will automatically
be of class Child. For continuous distributions (i.e. GAMMA), structure is
always NULL.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Simon-Pierre Gadoury
</p>


<h3>See Also</h3>

<p>Other mother or child class objects.: <code><a href="#topic+GAMMA">GAMMA</a></code>,
<code><a href="#topic+GEO">GEO</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>LOG(0.5, NULL, list(GAMMA(1/30, c(5,6), NULL),
                    LOG(0.1, NULL, list(GAMMA(1/30, c(1.2), NULL),
                                        GAMMA(1/30, c(3,4), NULL)))))
</code></pre>

<hr>
<h2 id='Log_Child-class'>Log-Child Class</h2><span id='topic+Log_Child-class'></span>

<h3>Description</h3>

<p>Log-Child Class
</p>

<hr>
<h2 id='Log_Mother-class'>Log-Mother Class</h2><span id='topic+Log_Mother-class'></span>

<h3>Description</h3>

<p>Log-Mother Class
</p>

<hr>
<h2 id='Moth'>Show Method Function for Compounding</h2><span id='topic+Moth'></span><span id='topic+Moth2'></span><span id='topic+Chil'></span>

<h3>Description</h3>

<p>Show Method Function for Compounding
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Moth(object, indent = "", delta.indent = 3, label = NA)

Moth2(object, indent = "", delta.indent = 3, label = NA)

Chil(object, space = "")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Moth_+3A_object">object</code></td>
<td>
<p>S4 object</p>
</td></tr>
<tr><td><code id="Moth_+3A_indent">indent</code></td>
<td>
<p>Initial spacing for children</p>
</td></tr>
<tr><td><code id="Moth_+3A_label">label</code></td>
<td>
<p>Internal use (must not be changed)</p>
</td></tr>
<tr><td><code id="Moth_+3A_delta.ident">delta.ident</code></td>
<td>
<p>Added space for each iteration</p>
</td></tr>
</table>

<hr>
<h2 id='Mother-class'>Mother Class</h2><span id='topic+Mother-class'></span>

<h3>Description</h3>

<p>Mother Class
</p>

<hr>
<h2 id='Node'>Obtain a node in mother class object</h2><span id='topic+Node'></span>

<h3>Description</h3>

<p>Use a path (numeric vector) to obtain a subgroup of a structure (mother class object).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Node(path, structure)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Node_+3A_path">path</code></td>
<td>
<p>the path of the node (numeric vector).</p>
</td></tr>
<tr><td><code id="Node_+3A_structure">structure</code></td>
<td>
<p>a mother class object (S4).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Every node of a mother object (structure) can be identified with a numeric vector that indicates
the path used from the root to the node. The vector is the 'path' argument and is used to find specific
nodes of a given structure. For a complete explanation, we refer to Cossette et al. (2017).
</p>


<h3>Value</h3>

<p>Either a child or mother class object.
</p>


<h3>Author(s)</h3>

<p>Simon-Pierre Gadoury
</p>


<h3>Examples</h3>

<pre><code class='language-R'># We directly give the path of the desired node.
Node(c(0,2,2), LOG(0.5, NULL, list(GAMMA(1/30, c(5,6), NULL),
                              LOG(0.1, NULL, list(GAMMA(1/30, c(1,2), NULL),
                              GAMMA(1/30, c(3,4), NULL))))))

# Here we provide the path with the GeneticCodes function of this package.
structure &lt;- LOG(0.5, NULL, list(GAMMA(1/30, c(5,6), NULL),
                                     LOG(0.1, NULL, list(GAMMA(1/30, c(1,2), NULL),
                                     GAMMA(1/30, c(3,4), NULL)))))
Node(GeneticCodes(structure)[[3]], structure)

</code></pre>

<hr>
<h2 id='pCompCop'>Distribution function of Mother class objects</h2><span id='topic+pCompCop'></span>

<h3>Description</h3>

<p>Distribution function of a Mother class object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pCompCop(structure, vector = FALSE, express = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pCompCop_+3A_structure">structure</code></td>
<td>
<p>object of class Mother.</p>
</td></tr>
<tr><td><code id="pCompCop_+3A_vector">vector</code></td>
<td>
<p>logical. If false, returns a function or a character string with (u_1, u_2, ...) as arguments, else,
just (u).</p>
</td></tr>
<tr><td><code id="pCompCop_+3A_express">express</code></td>
<td>
<p>logical. If false, returns a function, else, a character string.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The distribution function in the form of either a function or a character string.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Create the structure
structure &lt;- LOG(0.5, NULL, list(GAMMA(1/30, c(5,6), NULL),
                              LOG(0.1, NULL, list(GAMMA(1/30, c(1,2), NULL),
                              GAMMA(1/30, c(3,4), NULL)))))

## Character string
pCompCop(structure, vector = TRUE, express = TRUE)
pCompCop(structure, vector = FALSE, express = TRUE)

## Function
pCompCop(structure, vector = TRUE, express = FALSE)
pCompCop(structure, vector = FALSE, express = FALSE)

</code></pre>

<hr>
<h2 id='pCop'>Distribution function of archm class objects</h2><span id='topic+pCop'></span>

<h3>Description</h3>

<p>Distribution function of an Archimedean copula (archm) class object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pCop(copula, vector = FALSE, express = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pCop_+3A_copula">copula</code></td>
<td>
<p>an Archimedean copula (archm) class object.</p>
</td></tr>
<tr><td><code id="pCop_+3A_vector">vector</code></td>
<td>
<p>logical. If false, returns a function or a character string with (u_1, u_2, ..., u_dim) as arguments, else,
just (u).</p>
</td></tr>
<tr><td><code id="pCop_+3A_express">express</code></td>
<td>
<p>logical. If false, returns a function, else, a character string.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The distribution function in the form of either a function or a character string.
</p>


<h3>Author(s)</h3>

<p>Simon-Pierre Gadoury
</p>


<h3>See Also</h3>

<p><a href="#topic+rCop">rCop</a>, <a href="#topic+Clayton">Clayton</a>, <a href="#topic+AMH">AMH</a>, <a href="#topic+Gumbel">Gumbel</a>, <a href="#topic+Frank">Frank</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>cop &lt;- Clayton(5, 2)
pCop(cop, vector = TRUE, express = TRUE)
pCop(cop, vector = FALSE, express = TRUE)

</code></pre>

<hr>
<h2 id='rCompCop'>Random number generator for Mother class objects</h2><span id='topic+rCompCop'></span>

<h3>Description</h3>

<p>Samples from a Mother class object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rCompCop(n, structure)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rCompCop_+3A_n">n</code></td>
<td>
<p>the number of realisations.</p>
</td></tr>
<tr><td><code id="rCompCop_+3A_structure">structure</code></td>
<td>
<p>an object of class Mother.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A numeric matrix of sampled data from the structure
</p>


<h3>Author(s)</h3>

<p>Simon-Pierre Gadoury
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Create the structure
structure &lt;- GEO(0.1, 1, list(GAMMA(0.2, 2:3, NULL),
                        GEO(0.3, 4:5, NULL)))

## Sample from the structure
rCompCop(1000, structure)

</code></pre>

<hr>
<h2 id='rCop'>Random number generator for Archimedean copula class objects</h2><span id='topic+rCop'></span>

<h3>Description</h3>

<p>Random number generator for archm class objects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rCop(n, copula)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rCop_+3A_n">n</code></td>
<td>
<p>number of realisations.</p>
</td></tr>
<tr><td><code id="rCop_+3A_copula">copula</code></td>
<td>
<p>an Archimedean copula (archm) class object.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For bivariate archm copula objects, the function uses the conditional approach.
As for dimensions higher than 2, the Marshall-Olkin (1988) approach is chosen instead.
</p>


<h3>Value</h3>

<p>A numeric matrix containing the samples.
</p>


<h3>Author(s)</h3>

<p>Simon-Pierre Gadoury
</p>


<h3>See Also</h3>

<p><a href="#topic+pCop">pCop</a>, <a href="#topic+Clayton">Clayton</a>, <a href="#topic+AMH">AMH</a>, <a href="#topic+Frank">Frank</a>, <a href="#topic+Gumbel">Gumbel</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Create the trivariate archm copula object
cop &lt;- Clayton(5, 3)

## Generate the samples
res &lt;- rCop(10000, cop)

## Plot the values
pairs(res, pch = 16, cex = 0.7)

</code></pre>

<hr>
<h2 id='show+2Carchm-method'>Show Method for Copulas</h2><span id='topic+show+2Carchm-method'></span>

<h3>Description</h3>

<p>Show Method for Copulas
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'archm'
show(object)
</code></pre>

<hr>
<h2 id='show+2CChild-method'>Show Method for Compounding Functions - Child Class</h2><span id='topic+show+2CChild-method'></span>

<h3>Description</h3>

<p>Show Method for Compounding Functions - Child Class
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'Child'
show(object)
</code></pre>

<hr>
<h2 id='show+2CMother-method'>Show Method for Compounding Functions - Mother Class</h2><span id='topic+show+2CMother-method'></span>

<h3>Description</h3>

<p>Show Method for Compounding Functions - Mother Class
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'Mother'
show(object)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
