<!DOCTYPE html><html><head><title>Help for package DJL</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {DJL}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#dataset.airplane.2017'><p>Dataset of commercial airplanes from 1965 to 2017.</p></a></li>
<li><a href='#dataset.engine.2015'><p>Dataset of auto engines from MY2005 to MY2015.</p></a></li>
<li><a href='#dataset.hev.2013'><p>Dataset of hybrid electric vehicles from MY1997 to MY2013.</p></a></li>
<li><a href='#dm.ddf'><p>Distance measure using DDF</p></a></li>
<li><a href='#dm.dea'><p>Distance measure using DEA</p></a></li>
<li><a href='#dm.dynamic.bc'><p>Dynamic DEA in the presence of intertemporal Budget Constraints</p></a></li>
<li><a href='#dm.hdf'><p>Distance measure using HDF</p></a></li>
<li><a href='#dm.mahalanobis'><p>Distance measure using Mahalanobis distance for outlier detection</p></a></li>
<li><a href='#dm.network.dea'><p>Distance measure using DEA on a two-stage network structure</p></a></li>
<li><a href='#dm.sbm'><p>Distance measure using SBM</p></a></li>
<li><a href='#dm.sf'><p>Distance measure using SF</p></a></li>
<li><a href='#ma.aps.reg'><p>Combinatorial search (all possible subset) for regression analysis</p></a></li>
<li><a href='#map.corr'><p>Correlation mapping for reliability test</p></a></li>
<li><a href='#map.soa.ddf'><p>SOA mapping using DDF</p></a></li>
<li><a href='#map.soa.dea'><p>SOA mapping using DEA</p></a></li>
<li><a href='#map.soa.hdf'><p>SOA mapping using HDF</p></a></li>
<li><a href='#map.soa.sbm'><p>SOA mapping using SBM</p></a></li>
<li><a href='#map.soa.sf'><p>SOA mapping using SF</p></a></li>
<li><a href='#plp'><p>Print LP object</p></a></li>
<li><a href='#roc.dea'><p>Rate of change (RoC) calculation using DEA</p></a></li>
<li><a href='#roc.hdf'><p>Rate of change (RoC) calculation using HDF</p></a></li>
<li><a href='#roc.malmquist'><p>Malmquist Index: time-series productivity analysis</p></a></li>
<li><a href='#roc.sf'><p>Rate of change (RoC) calculation using SF</p></a></li>
<li><a href='#target.arrival.dea'><p>Arrival target setting using DEA</p></a></li>
<li><a href='#target.arrival.hdf'><p>Arrival target setting using HDF</p></a></li>
<li><a href='#target.arrival.sf'><p>Arrival target setting using SF</p></a></li>
<li><a href='#target.spec.dea'><p>Spec target setting using DEA</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Distance Measure Based Judgment and Learning</td>
</tr>
<tr>
<td>Version:</td>
<td>3.9</td>
</tr>
<tr>
<td>Date:</td>
<td>2023-03-16</td>
</tr>
<tr>
<td>Author:</td>
<td>Dong-Joon Lim, Ph.D. &lt;technometrics.org&gt;</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.4.0), car, lpSolveAPI</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Dong-Joon Lim &lt;tgno3.com@gmail.com&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Implements various decision support tools related to the Econometrics &amp; Technometrics.
             Subroutines include correlation reliability test, Mahalanobis distance measure for outlier detection, combinatorial search (all possible subset regression), non-parametric efficiency analysis measures: DDF (directional distance function), DEA (data envelopment analysis), HDF (hyperbolic distance function), SBM (slack-based measure), and SF (shortage function), benchmarking, Malmquist productivity analysis, risk analysis, technology adoption model, new product target setting, network DEA, dynamic DEA, intertemporal budgeting, etc.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a></td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-03-16 14:11:21 UTC; Technometrics</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-03-16 15:10:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='dataset.airplane.2017'>Dataset of commercial airplanes from 1965 to 2017.</h2><span id='topic+dataset.airplane.2017'></span>

<h3>Description</h3>

<p>Commercial airplanes from 1965 to 2017.</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(dataset.airplane.2017)</code></pre>


<h3>Columns</h3>

<p><code>[,1] Name       </code>Airplane name <br />
<code>[,2] EIS        </code>Entry into service <br />
<code>[,3] Range      </code>Maximum range at full payload in 1,000km <br />
<code>[,4] P.cap      </code>Passenger capacity <br />
<code>[,5] PFE        </code>Passenger fuel efficiency in passengers*km/L (log scale) <br />
<code>[,6] C.spd      </code>Cruising speed in km/hr <br />
<code>[,7] M.spd      </code>Maximum speed in km/hr
</p>


<h3>Author(s)</h3>

<p>Dong-Joon Lim, PhD</p>


<h3>Source</h3>

<p>http://www.airbus.com/aircraftfamilies <br /> http://www.boeing.com/commercial</p>


<h3>References</h3>

<p>Lim, Dong-Joon, and Timothy R. Anderson. Time series benchmarking analysis for new product scheduling: who are the competitors and how fast are they moving forward?. <em>Advances in DEA Theory and Applications: with Examples in Forecasting Models</em>. (2017): 443-458.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Load dataset
  data(dataset.airplane.2017)
</code></pre>

<hr>
<h2 id='dataset.engine.2015'>Dataset of auto engines from MY2005 to MY2015.</h2><span id='topic+dataset.engine.2015'></span>

<h3>Description</h3>

<p>Auto engines from MY2005 to MY2015.</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(dataset.engine.2015)</code></pre>


<h3>Columns</h3>

<p><code>[,1] Name          </code>Vehicle name <br />
<code>[,2] MY            </code>Model year <br />
<code>[,3] Cylinder      </code>The number of cylinder <br />
<code>[,4] Displacement  </code>Displacement in liter <br />
<code>[,5] CO2           </code>CO2 emission in gram/mile <br />
<code>[,6] Power         </code>Engine power in HP <br />
<code>[,7] Torque        </code>Engine torque in lb.ft <br />
<code>[,8] Type          </code>Engine system and fuel type
</p>


<h3>Author(s)</h3>

<p>Dong-Joon Lim, PhD</p>


<h3>Source</h3>

<p>http://www.fueleconomy.gov <br /> http://www.autoevolution.com</p>


<h3>References</h3>

<p>D.-J. Lim,  Internal combustion engine race: naturally aspirated vs turbo/super-charged, <em>working paper</em> (2015).
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Load dataset
  data(dataset.engine.2015)
</code></pre>

<hr>
<h2 id='dataset.hev.2013'>Dataset of hybrid electric vehicles from MY1997 to MY2013.</h2><span id='topic+dataset.hev.2013'></span>

<h3>Description</h3>

<p>Hybrid electric vehicles from MY1997 to MY2013.</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(dataset.hev.2013)</code></pre>


<h3>Columns</h3>

<p><code>[,1] Name          </code>Vehicle name <br />
<code>[,2] MY            </code>Model year <br />
<code>[,3] MSRP.2013     </code>MSRP converted to 2013 value <br />
<code>[,4] Acc           </code>Acceleration (0-100km) in km/h/s <br />
<code>[,5] MPG           </code>MPG in mile/gallon <br />
<code>[,6] MPGe          </code>MPG equivalence for PHEV in mile/gallon
</p>


<h3>Author(s)</h3>

<p>Dong-Joon Lim, PhD</p>


<h3>Source</h3>

<p>http://www.fueleconomy.gov</p>


<h3>References</h3>

<p>Lim, Dong-Joon, et al. &quot;Comparing technological advancement of hybrid electric vehicles (HEV) in different market segments.&quot; <em>Technological Forecasting and Social Change</em> 97 (2015): 140~153.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Load dataset
  data(dataset.hev.2013)
</code></pre>

<hr>
<h2 id='dm.ddf'>Distance measure using DDF</h2><span id='topic+dm.ddf'></span>

<h3>Description</h3>

<p>Implements <em>Chambers</em>' directional distance function (non-radial &amp; non-oriented measure).</p>


<h3>Usage</h3>

<pre><code class='language-R'>dm.ddf(xdata, ydata, rts="crs", g=NULL, 
       wd=NULL, se=FALSE, sg="ssm", date=NULL, cv="convex", o=NULL)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dm.ddf_+3A_xdata">xdata</code></td>
<td>
<p>Input(s) vector (<em>n</em> by <em>m</em>)</p>
</td></tr>
<tr><td><code id="dm.ddf_+3A_ydata">ydata</code></td>
<td>
<p>Output(s) vector (<em>n</em> by <em>s</em>)</p>
</td></tr>
<tr><td><code id="dm.ddf_+3A_rts">rts</code></td>
<td>
<p>Returns to scale assumption <br />
<code>"crs"  </code>Constant RTS (default) <br />  
<code>"vrs"  </code>Variable RTS <br />
<code>"irs"  </code>Increasing RTS <br />
<code>"drs"  </code>Decreasing RTS
</p>
</td></tr>
<tr><td><code id="dm.ddf_+3A_g">g</code></td>
<td>
<p>Directional vector indicating a measurement direction (<em>n</em> by <em>(m+s)</em>)<br />
By default (<code>NULL</code>), <code>xdata</code> &amp; <code>ydata</code> will be used</p>
</td></tr>
<tr><td><code id="dm.ddf_+3A_wd">wd</code></td>
<td>
<p>Weak disposability vector indicating (an) undesirable output(s) (<em>1</em> by <em>s</em>)</p>
</td></tr>
<tr><td><code id="dm.ddf_+3A_se">se</code></td>
<td>
<p>Implements super-efficiency model alike <em>Anderson &amp; Peterson</em>'s model if <code>TRUE</code></p>
</td></tr>
<tr><td><code id="dm.ddf_+3A_sg">sg</code></td>
<td>
<p>Employs second-stage optimization <br />
<code>"ssm"  </code>Slack-sum maximization (default) <br />
<code>"max"  </code>Date-sum maximization (only if <code>date</code> is defined) <br />
<code>"min"  </code>Date-sum minimization (only if <code>date</code> is defined)
</p>
</td></tr>
<tr><td><code id="dm.ddf_+3A_date">date</code></td>
<td>
<p>Production date (<em>n</em> by <em>1</em>)</p>
</td></tr>
<tr><td><code id="dm.ddf_+3A_cv">cv</code></td>
<td>
<p>Convexity assumption <br />
<code>"convex" </code>Convexity holds (default) <br />
<code>"fdh"    </code>Free disposal hull (this will override <code>rts</code>)
</p>
</td></tr>
<tr><td><code id="dm.ddf_+3A_o">o</code></td>
<td>
<p>DMU index to calc. <code>NULL</code>(default) will calc for all</p>
</td></tr>
</table>


<h3>Value</h3>

<table>
<tr><td><code>$eff</code></td>
<td>
<p>Efficiency score</p>
</td></tr>
<tr><td><code>$lambda</code></td>
<td>
<p>Intensity vector</p>
</td></tr>
<tr><td><code>$mu</code></td>
<td>
<p>Secondary intensity vector for weak disposability under VRS</p>
</td></tr>
<tr><td><code>$beta</code></td>
<td>
<p>Input reduction factor</p>
</td></tr>
<tr><td><code>$gamma</code></td>
<td>
<p>Output augmentation factor</p>
</td></tr>
<tr><td><code>$xslack</code></td>
<td>
<p>Input slack</p>
</td></tr>
<tr><td><code>$yslack</code></td>
<td>
<p>Output slack</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Dong-Joon Lim, PhD</p>


<h3>References</h3>

<p>Chambers, Robert G., Yangho Chung, and Rolf Fare. &quot;Profit, directional distance functions, and Nerlovian efficiency.&quot; <em>Journal of optimization theory and applications</em> 98.2 (1998): 351~364.
</p>
<p>Fare, Rolf, and Shawna Grosskopf. &quot;Directional distance functions and slacks-based measures of efficiency.&quot; <em>European journal of operational research</em> 200.1 (2010): 320~322.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+dm.ddf">dm.ddf</a></code> Distance measure using DDF <br />
<code><a href="#topic+dm.dea">dm.dea</a></code> Distance measure using DEA <br />
<code><a href="#topic+dm.hdf">dm.hdf</a></code> Distance measure using HDF <br />
<code><a href="#topic+dm.sbm">dm.sbm</a></code> Distance measure using SBM <br />
<code><a href="#topic+dm.sf">dm.sf</a></code> Distance measure using SF
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Additive form directional distance function
  # ready
  x &lt;- matrix(c(5, 1, 4), ncol = 1)
  y &lt;- matrix(c(8, 3, 5, 6, 4, 1), ncol = 2)
  g &lt;- matrix(c(1), nrow = 3, ncol = 3) 
  w &lt;- matrix(c(1, 0), ncol = 2)
  # go
  dm.ddf(x, y, "crs", g, w)

# Multiplicative form directional distance function
  # ready
  g &lt;- cbind(x, y)
  # go
  dm.ddf(x, y, "crs", g, w)
</code></pre>

<hr>
<h2 id='dm.dea'>Distance measure using DEA</h2><span id='topic+dm.dea'></span>

<h3>Description</h3>

<p>Implements <em>Charnes &amp; Cooper</em>'s data envelopment analysis (radial &amp; oriented measure).</p>


<h3>Usage</h3>

<pre><code class='language-R'>dm.dea(xdata, ydata, rts="crs", orientation,
       se=FALSE, sg="ssm", date=NULL, ncv=NULL, env=NULL, cv="convex", o=NULL)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dm.dea_+3A_xdata">xdata</code></td>
<td>
<p>Input(s) vector (<em>n</em> by <em>m</em>)</p>
</td></tr>
<tr><td><code id="dm.dea_+3A_ydata">ydata</code></td>
<td>
<p>Output(s) vector (<em>n</em> by <em>s</em>)</p>
</td></tr>
<tr><td><code id="dm.dea_+3A_rts">rts</code></td>
<td>
<p>Returns to scale assumption <br />
<code>"crs"  </code>Constant RTS (default) <br />  
<code>"vrs"  </code>Variable RTS <br />
<code>"irs"  </code>Increasing RTS <br />
<code>"drs"  </code>Decreasing RTS
</p>
</td></tr>
<tr><td><code id="dm.dea_+3A_orientation">orientation</code></td>
<td>
<p>Orientation of the measurement <br />
<code>"i"  </code>Input-orientation <br />
<code>"o"  </code>Output-orientation
</p>
</td></tr>
<tr><td><code id="dm.dea_+3A_se">se</code></td>
<td>
<p>Implements <em>Andersen &amp; Petersen</em>'s super-efficiency model if <code>TRUE</code></p>
</td></tr>
<tr><td><code id="dm.dea_+3A_sg">sg</code></td>
<td>
<p>Employs second-stage optimization <br />
<code>"ssm"  </code>Slack-sum maximization (default) <br />
<code>"max"  </code>Date-sum maximization (only if <code>date</code> is defined) <br />
<code>"min"  </code>Date-sum minimization (only if <code>date</code> is defined)
</p>
</td></tr>
<tr><td><code id="dm.dea_+3A_date">date</code></td>
<td>
<p>Production date (<em>n</em> by <em>1</em>)</p>
</td></tr>
<tr><td><code id="dm.dea_+3A_ncv">ncv</code></td>
<td>
<p>Non-controllable variable index(binary) for internal NDF (<em>1</em> by <em>(m+s)</em>)</p>
</td></tr>
<tr><td><code id="dm.dea_+3A_env">env</code></td>
<td>
<p>Environment index for external NDF (<em>n</em> by <em>1</em>)</p>
</td></tr>
<tr><td><code id="dm.dea_+3A_cv">cv</code></td>
<td>
<p>Convexity assumption <br />
<code>"convex" </code>Convexity holds (default) <br />
<code>"fdh"    </code>Free disposal hull (this will override <code>rts</code>)
</p>
</td></tr>
<tr><td><code id="dm.dea_+3A_o">o</code></td>
<td>
<p>DMU index to calc. <code>NULL</code>(default) will calc for all</p>
</td></tr>
</table>


<h3>Value</h3>

<table>
<tr><td><code>$eff</code></td>
<td>
<p>Efficiency score</p>
</td></tr>
<tr><td><code>$lambda</code></td>
<td>
<p>Intensity vector</p>
</td></tr>
<tr><td><code>$xslack</code></td>
<td>
<p>Input slack</p>
</td></tr>
<tr><td><code>$yslack</code></td>
<td>
<p>Output slack</p>
</td></tr>
<tr><td><code>$vx</code></td>
<td>
<p>Input (dual) weight</p>
</td></tr>
<tr><td><code>$uy</code></td>
<td>
<p>Output (dual) weight</p>
</td></tr>
<tr><td><code>$w</code></td>
<td>
<p>Free (dual) variable</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Dong-Joon Lim, PhD</p>


<h3>References</h3>

<p>Charnes, Abraham, William W. Cooper, and Edwardo Rhodes. &quot;Measuring the efficiency of decision making units.&quot; <em>European journal of operational research</em> 2.6 (1978): 429~444.
</p>
<p>Charnes, Abraham, William W. Cooper, and Edwardo Rhodes. &quot;Evaluating program and managerial efficiency: an application of data envelopment analysis to program follow through.&quot; <em>Management science</em> 27.6 (1981): 668~697.
</p>
<p>Banker, Rajiv D., and Richard C. Morey. &quot;Efficiency analysis for exogenously fixed inputs and outputs.&quot; <em>Operations Research</em> 34.4 (1986): 513~521.
</p>
<p>Ruggiero, John. &quot;On the measurement of technical efficiency in the public sector.&quot; <em>European Journal of Operational Research</em> 90.3 (1996): 553~565.
</p>
<p>Fried, Harold O., CA Knox Lovell, and Shelton S. Schmidt, eds. The measurement of productive efficiency and productivity growth. <em>Oxford University Press</em>, 2008.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+dm.ddf">dm.ddf</a></code> Distance measure using DDF <br />
<code><a href="#topic+dm.dea">dm.dea</a></code> Distance measure using DEA <br />
<code><a href="#topic+dm.hdf">dm.hdf</a></code> Distance measure using HDF <br />
<code><a href="#topic+dm.sbm">dm.sbm</a></code> Distance measure using SBM <br />
<code><a href="#topic+dm.sf">dm.sf</a></code> Distance measure using SF
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Reproduce Table 3.9 (p.348) in Fried, H.O. et al.(2008)
  # ready
  X &lt;- data.frame(x1 = c(8, 6,   3,   10, 6,   8,   8, 4),
                  x2 = c(8, 4.6, 1.9, 9,  3.6, 3.6, 9, 1.9))
  Y &lt;- data.frame(y1 = c(8, 5,   2,   9,  4.5, 4.5, 7, 2))
  C &lt;- data.frame(x1 = 0, x2 = 1, y1 = 0)

  # go
  data.frame(ALL_CRS = dm.dea(X, Y, "crs", "i")$eff,
             ALL_VRS = dm.dea(X, Y, "vrs", "i")$eff,
             NDF_CRS = dm.dea(X, Y, "crs", "i", ncv = C)$eff,
             NDF_VRS = dm.dea(X, Y, "vrs", "i", ncv = C)$eff,
             row.names = LETTERS[1 : 8])
</code></pre>

<hr>
<h2 id='dm.dynamic.bc'>Dynamic DEA in the presence of intertemporal Budget Constraints</h2><span id='topic+dm.dynamic.bc'></span>

<h3>Description</h3>

<p>Employs the Farrell measure on carry-over budget as well as input or output</p>


<h3>Usage</h3>

<pre><code class='language-R'>dm.dynamic.bc(xdata, ydata, zdata, bdata, rts="crs", orientation="i", wv=NULL)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dm.dynamic.bc_+3A_xdata">xdata</code></td>
<td>
<p>Input array (<em>n</em> by <em>m</em> by <em>t</em>)</p>
</td></tr>
<tr><td><code id="dm.dynamic.bc_+3A_ydata">ydata</code></td>
<td>
<p>Output array (<em>n</em> by <em>s</em> by <em>t</em>)</p>
</td></tr>
<tr><td><code id="dm.dynamic.bc_+3A_zdata">zdata</code></td>
<td>
<p>Budget(spent) array (<em>n</em> by <em>b</em> by <em>t</em>)</p>
</td></tr>
<tr><td><code id="dm.dynamic.bc_+3A_bdata">bdata</code></td>
<td>
<p>Budget(secured) array (<em>n</em> by <em>b</em>)</p>
</td></tr>
<tr><td><code id="dm.dynamic.bc_+3A_rts">rts</code></td>
<td>
<p>Returns to scale assumption <br />
<code>"crs"  </code>Constant RTS (default) <br />  
<code>"vrs"  </code>Variable RTS <br />
<code>"irs"  </code>Increasing RTS <br />
<code>"drs"  </code>Decreasing RTS
</p>
</td></tr>
<tr><td><code id="dm.dynamic.bc_+3A_orientation">orientation</code></td>
<td>
<p>Orientation of the measurement <br />
<code>"i"  </code>Input-orientation (default) <br />
<code>"o"  </code>Output-orientation
</p>
</td></tr>
<tr><td><code id="dm.dynamic.bc_+3A_wv">wv</code></td>
<td>
<p>Weight vector for scalarization (<em>1</em> by <em>m</em> or <em>s</em>)</p>
</td></tr>
</table>


<h3>Value</h3>

<table>
<tr><td><code>$eff.s</code></td>
<td>
<p>System Efficiency</p>
</td></tr>
<tr><td><code>$eff.t</code></td>
<td>
<p>Period Efficiency</p>
</td></tr>
<tr><td><code>$lambda</code></td>
<td>
<p>Intensity vectors</p>
</td></tr>
<tr><td><code>$xslack</code></td>
<td>
<p>Input slack</p>
</td></tr>
<tr><td><code>$yslack</code></td>
<td>
<p>Output slack</p>
</td></tr>
<tr><td><code>$zslack</code></td>
<td>
<p>Budget(spent) slack</p>
</td></tr>
<tr><td><code>$aslack</code></td>
<td>
<p>Budget(available) slack</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Dong-Joon Lim, PhD</p>


<h3>References</h3>

<p>Lim, D.-J., M.-S., Kim, &amp; K.-W., Lee. (2020). &quot;A revised dynamic DEA model with budget constraints.&quot; <em>International Transactions in Operational Research (In press)</em>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+dm.dea">dm.dea</a></code> Distance measure using DEA
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Load data
  df.io &lt;- array(c(2, 4, 8, 4, 1, 2, 2, 2, 3, 6, 12, 6,
                   5, 4, 3, 8, 1, 1, 1, 1, 5, 4,  3, 8),
                 c(4, 3, 2), 
                 dimnames = list(LETTERS[1:4], c("X", "Y", "z"), c("t1", "t2")))
  df.Z.0 &lt;- array(c(9, 12, 18, 24), c(4, 1), dimnames = list(LETTERS[1:4], c("Z^0")))

# Run
  dm.dynamic.bc(df.io[,1,], df.io[,2,], df.io[,3,], df.Z.0)
</code></pre>

<hr>
<h2 id='dm.hdf'>Distance measure using HDF</h2><span id='topic+dm.hdf'></span>

<h3>Description</h3>

<p>Implements <em>Fare</em>'s hyperbolic distance function (semi-radial &amp; non-oriented measure).</p>


<h3>Usage</h3>

<pre><code class='language-R'>dm.hdf(xdata, ydata, rts="crs", 
       wd=NULL, se=FALSE, sg="ssm", date=NULL, cv="convex", o=NULL)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dm.hdf_+3A_xdata">xdata</code></td>
<td>
<p>Input(s) vector (<em>n</em> by <em>m</em>)</p>
</td></tr>
<tr><td><code id="dm.hdf_+3A_ydata">ydata</code></td>
<td>
<p>Output(s) vector (<em>n</em> by <em>s</em>)</p>
</td></tr>
<tr><td><code id="dm.hdf_+3A_rts">rts</code></td>
<td>
<p>Returns to scale assumption <br />
<code>"crs"  </code>Constant RTS (default) <br />  
<code>"vrs"  </code>Variable RTS <br />
<code>"irs"  </code>Increasing RTS <br />
<code>"drs"  </code>Decreasing RTS
</p>
</td></tr>
<tr><td><code id="dm.hdf_+3A_wd">wd</code></td>
<td>
<p>Weak disposability vector indicating (an) undesirable output(s) (<em>1</em> by <em>s</em>)</p>
</td></tr>
<tr><td><code id="dm.hdf_+3A_se">se</code></td>
<td>
<p>Implements super-efficiency model alike <em>Anderson &amp; Peterson</em>'s model if <code>TRUE</code></p>
</td></tr>
<tr><td><code id="dm.hdf_+3A_sg">sg</code></td>
<td>
<p>Employs second-stage optimization <br />
<code>"ssm"  </code>Slack-sum maximization (default) <br />
<code>"max"  </code>Date-sum maximization (only if <code>date</code> is defined) <br />
<code>"min"  </code>Date-sum minimization (only if <code>date</code> is defined)
</p>
</td></tr>
<tr><td><code id="dm.hdf_+3A_date">date</code></td>
<td>
<p>Production date (<em>n</em> by <em>1</em>)</p>
</td></tr>
<tr><td><code id="dm.hdf_+3A_cv">cv</code></td>
<td>
<p>Convexity assumption <br />
<code>"convex" </code>Convexity holds (default) <br />
<code>"fdh"    </code>Free disposal hull (this will override <code>rts</code>)
</p>
</td></tr>
<tr><td><code id="dm.hdf_+3A_o">o</code></td>
<td>
<p>DMU index to calc. <code>NULL</code>(default) will calc for all</p>
</td></tr>
</table>


<h3>Value</h3>

<table>
<tr><td><code>$eff</code></td>
<td>
<p>Efficiency score</p>
</td></tr>
<tr><td><code>$lambda</code></td>
<td>
<p>Intensity vector</p>
</td></tr>
<tr><td><code>$mu</code></td>
<td>
<p>Secondary intensity vector for weak disposability under VRS</p>
</td></tr>
<tr><td><code>$xslack</code></td>
<td>
<p>Input slack</p>
</td></tr>
<tr><td><code>$yslack</code></td>
<td>
<p>Output slack</p>
</td></tr>
<tr><td><code>$iteration</code></td>
<td>
<p>The number of iteration to obtain the hyperbolic efficiency score</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Dong-Joon Lim, PhD</p>


<h3>References</h3>

<p>Fare, R., Shawna Grosskopf, and CA Knox Lovell. The Measurement of Efficiency of Production. <em>Boston: Kulwer-Nijhoff</em> (1985).
</p>
<p>Fare, Rolf, et al. &quot;Estimating the hyperbolic distance function: A directional distance function approach.&quot; <em>European Journal of Operational Research</em> 254.1 (2016): 312~319.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+dm.ddf">dm.ddf</a></code> Distance measure using DDF <br />
<code><a href="#topic+dm.dea">dm.dea</a></code> Distance measure using DEA <br />
<code><a href="#topic+dm.hdf">dm.hdf</a></code> Distance measure using HDF <br />
<code><a href="#topic+dm.sbm">dm.sbm</a></code> Distance measure using SBM <br />
<code><a href="#topic+dm.sf">dm.sf</a></code> Distance measure using SF
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Reproduce Table 2 in Fare et al.(2016)
  # ready
  x &lt;- data.frame(x1 = c(2, 4, 9, 6.5, 10, 6, 9))
  y &lt;- data.frame(y1 = c(3, 7, 10, 8.5, 4, 2, 8))

  # go
  sf  &lt;- dm.sf (x, y, "vrs")$eff
  hdf &lt;- dm.hdf(x, y, "vrs")$eff
  matrix(t(cbind(sf, hdf)), 2, 7, 
         dimnames = list(c("SF", "HDF"), 
                         paste0("DMU_", c(letters[1:4], "o", "p", "q")))) 

</code></pre>

<hr>
<h2 id='dm.mahalanobis'>Distance measure using Mahalanobis distance for outlier detection</h2><span id='topic+dm.mahalanobis'></span>

<h3>Description</h3>

<p>Implements <em>Mahalanobis</em> distance measure for outlier detection. In addition to the basic distance measure, boxplots are provided with potential outlier(s) to give an insight into the early stage of data cleansing task.</p>


<h3>Usage</h3>

<pre><code class='language-R'>dm.mahalanobis(data, from="median", p=10, plot=FALSE, v.index=NULL, layout=NULL)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dm.mahalanobis_+3A_data">data</code></td>
<td>
<p>Dataframe</p>
</td></tr>
<tr><td><code id="dm.mahalanobis_+3A_from">from</code></td>
<td>
<p>Datum point from which the distance is measured <br />
<code>"mean"    </code>Mean of each column <br />  
<code>"median"  </code>Median of each column (default)
</p>
</td></tr>
<tr><td><code id="dm.mahalanobis_+3A_p">p</code></td>
<td>
<p>Percentage to which outlier point(s) is noted (default of 10)</p>
</td></tr>
<tr><td><code id="dm.mahalanobis_+3A_plot">plot</code></td>
<td>
<p>Switch for boxplot(s)</p>
</td></tr>
<tr><td><code id="dm.mahalanobis_+3A_v.index">v.index</code></td>
<td>
<p>Numeric vector indicating column(s) to be printed in the boxplot.
Default value of <code>NULL</code> will present all.</p>
</td></tr>
<tr><td><code id="dm.mahalanobis_+3A_layout">layout</code></td>
<td>
<p>Numeric vector indicating dimension of boxplots.
Default value of <code>NULL</code> will find an optimal layout.</p>
</td></tr>
</table>


<h3>Value</h3>

<table>
<tr><td><code>$dist</code></td>
<td>
<p><code>Mahalanobis</code> distance from <code>from</code></p>
</td></tr>
<tr><td><code>$excluded</code></td>
<td>
<p>Excluded row(s) in row number</p>
</td></tr>
<tr><td><code>$order</code></td>
<td>
<p>Distance order (decreasing) in row number</p>
</td></tr>
<tr><td><code>$suspect</code></td>
<td>
<p>Potential outlier(s) in row number</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Dong-Joon Lim, PhD</p>


<h3>References</h3>

<p>Hair, Joseph F., et al. Multivariate data analysis. Vol. 7. <em>Upper Saddle River</em>, NJ: Pearson Prentice Hall, 2006.</p>


<h3>Examples</h3>

<pre><code class='language-R'># Generate a sample dataframe
df &lt;- data.frame(replicate(6, sample(0 : 100, 50)))

# go
dm.mahalanobis(df, plot = TRUE)
</code></pre>

<hr>
<h2 id='dm.network.dea'>Distance measure using DEA on a two-stage network structure</h2><span id='topic+dm.network.dea'></span>

<h3>Description</h3>

<p>Implements <em>Charnes &amp; Cooper</em>'s data envelopment analysis (radial &amp; oriented measure) on a two-stage network structure.</p>


<h3>Usage</h3>

<pre><code class='language-R'>dm.network.dea(xdata.s1, ydata.s1=NULL, zdata, xdata.s2=NULL, ydata.s2,
               rts="crs", orientation="i", type="nc", leader="1st", ss=10^-4, o=NULL)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dm.network.dea_+3A_xdata.s1">xdata.s1</code></td>
<td>
<p>Input(s) vector in Stage 1 (<em>n</em> by <em>m.s1</em>)</p>
</td></tr>
<tr><td><code id="dm.network.dea_+3A_ydata.s1">ydata.s1</code></td>
<td>
<p>Output(s) vector in Stage 1 (<em>n</em> by <em>s.s1</em>)</p>
</td></tr>
<tr><td><code id="dm.network.dea_+3A_zdata">zdata</code></td>
<td>
<p>Intermediate product(s) vector between Stage 1 and Stage 2 (<em>n</em> by <em>p</em>)</p>
</td></tr>
<tr><td><code id="dm.network.dea_+3A_xdata.s2">xdata.s2</code></td>
<td>
<p>Input(s) vector in Stage 2 (<em>n</em> by <em>m.s2</em>)</p>
</td></tr>
<tr><td><code id="dm.network.dea_+3A_ydata.s2">ydata.s2</code></td>
<td>
<p>Output(s) vector in Stage 2 (<em>n</em> by <em>s.s2</em>)</p>
</td></tr>
<tr><td><code id="dm.network.dea_+3A_rts">rts</code></td>
<td>
<p>Returns to scale assumption <br />
<code>"crs"  </code>Constant RTS (default) <br />  
<code>"vrs"  </code>Variable RTS <br />
<code>"irs"  </code>Increasing RTS <br />
<code>"drs"  </code>Decreasing RTS
</p>
</td></tr>
<tr><td><code id="dm.network.dea_+3A_orientation">orientation</code></td>
<td>
<p>Orientation of the measurement <br />
<code>"i"  </code>Input-orientation (default) <br />
<code>"o"  </code>Output-orientation
</p>
</td></tr>
<tr><td><code id="dm.network.dea_+3A_type">type</code></td>
<td>
<p>Solution method <br />
<code>"nc"  </code>Decentralized model (Stackelberg game approach) (default) <br />
<code>"co"  </code>Centralized model (cooperative game approach)
</p>
</td></tr>
<tr><td><code id="dm.network.dea_+3A_leader">leader</code></td>
<td>
<p>Preemptive priority for Decentralized model <br />
<code>"1st" </code>1st stage as the leader (default) <br />
<code>"2nd" </code>2nd stage as the leader
</p>
</td></tr>
<tr><td><code id="dm.network.dea_+3A_ss">ss</code></td>
<td>
<p>Step size for heuristic search <code>10^-4</code> (default)</p>
</td></tr>
<tr><td><code id="dm.network.dea_+3A_o">o</code></td>
<td>
<p>DMU index to operate. <code>NULL</code> (default) will operate for all</p>
</td></tr>
</table>


<h3>Value</h3>

<table>
<tr><td><code>$eff.s1</code></td>
<td>
<p>Efficiency score of Stage 1</p>
</td></tr>
<tr><td><code>$eff.s2</code></td>
<td>
<p>Efficiency score of Stage 2</p>
</td></tr>
<tr><td><code>$v.s1</code></td>
<td>
<p>Weight attached to input in Stage 1</p>
</td></tr>
<tr><td><code>$u.s1</code></td>
<td>
<p>Weight attached to output in Stage 1</p>
</td></tr>
<tr><td><code>$p</code></td>
<td>
<p>Weight attached to intermediate product</p>
</td></tr>
<tr><td><code>$w.s1</code></td>
<td>
<p>Free variable for scaling in Stage 1</p>
</td></tr>
<tr><td><code>$v.s2</code></td>
<td>
<p>Weight attached to input in Stage 2</p>
</td></tr>
<tr><td><code>$u.s2</code></td>
<td>
<p>Weight attached to output in Stage 2</p>
</td></tr>
<tr><td><code>$w.s2</code></td>
<td>
<p>Free variable for scaling in Stage 2</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Dong-Joon Lim, Ph.D.</p>


<h3>References</h3>

<p>Kao, Chiang, and Shiuh-Nan Hwang. &quot;Efficiency decomposition in two-stage data envelopment analysis: An application to non-life insurance companies in Taiwan.&quot; <em>European journal of operational research</em> 185.1 (2008): 418-429.
</p>
<p>Cook, Wade D., Liang Liang, and Joe Zhu. &quot;Measuring performance of two-stage network structures by DEA: a review and future perspective.&quot; <em>Omega</em> 38.6 (2010): 423-430.
</p>
<p>Li, Yongjun, Yao Chen, Liang Liang, and Jianhui Xie. &quot;DEA models for extended two-stage network structures.&quot; <em>Omega</em> 40.5 (2012): 611-618.
</p>
<p>Lee, Hsuan-Shih. &quot;Efficiency decomposition of the network DEA in variable returns to scale: An additive dissection in losses.&quot; <em>Omega</em> 100 (2021): 102212.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+dm.dea">dm.dea</a></code> Distance measure using DEA <br />
<code><a href="#topic+dm.dynamic.bc">dm.dynamic.bc</a></code> Dynamic DEA for intertemporal budgeting
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Reproduce Table 2 in W.D. Cook et al.(2010)
  # ready
  X &lt;- data.frame(x1 = c(1178744,1381822,1177494,601320,6699063,2627707,1942833,3789001,
                         1567746,1303249,1962448,2592790,2609941,1396002,2184944,1211716,
                         1453797,757515,159422,145442,84171,15993,54693,163297,1544215),
                  x2 = c(673512,1352755,592790,594259,3531614,668363,1443100,1873530,
                         950432,1298470,672414,650952,1368802,988888,651063,415071,
                         1085019,547997,182338,53518,26224,10502,28408,235094,828963))
  Z &lt;- data.frame(z1 = c(7451757,10020274,4776548,3174851,37392862,9747908,10685457,17267266,
                         11473162,8210389,7222378,9434406,13921464,7396396,10422297,5606013,
                         7695461,3631484,1141950,316829,225888,52063,245910,476419,7832893),
                  z2 = c(856735,1812894,560244,371863,1753794,952326,643412,1134600,
                         546337,504528,643178,1118489,811343,465509,749893,402881,
                         342489,995620,483291,131920,40542,14574,49864,644816,667964))
  Y &lt;- data.frame(y1 = c(984143,1228502,293613,248709,7851229,1713598,2239593,3899530,
                         1043778,1697941,1486014,1574191,3609236,1401200,3355197,854054,
                         3144484,692731,519121,355624,51950,82141,0.1,142370,1602873),
                  y2 = c(681687,834754,658428,177331,3925272,415058,439039,622868,
                         264098,554806,18259,909295,223047,332283,555482,197947,
                         371984,163927,46857,26537,6491,4181,18980,16976,477733))
  
  # go
  res.co    &lt;- dm.network.dea(xdata.s1 = X, zdata = Z, ydata.s2 = Y, type = "co")
  res.nc.LF &lt;- dm.network.dea(xdata.s1 = X, zdata = Z, ydata.s2 = Y, type = "nc", leader = "1st")
  res.nc.FL &lt;- dm.network.dea(xdata.s1 = X, zdata = Z, ydata.s2 = Y, type = "nc", leader = "2nd")

  # print
  data.frame(CO.s1    = res.co$eff.s1,
             CO.s2    = res.co$eff.s2,
             NC.LF.s1 = res.nc.LF$eff.s1,
             NC.LF.s2 = res.nc.LF$eff.s2,
             NC.FL.s1 = res.nc.FL$eff.s1,
             NC.FL.s2 = res.nc.FL$eff.s2)
</code></pre>

<hr>
<h2 id='dm.sbm'>Distance measure using SBM</h2><span id='topic+dm.sbm'></span>

<h3>Description</h3>

<p>Implements <em>Tone</em>'s slack-based model (non-radial &amp; (non-)oriented measure).</p>


<h3>Usage</h3>

<pre><code class='language-R'>dm.sbm(xdata, ydata, rts="crs", 
       orientation="n", se=FALSE, sg="ssm", date=NULL, cv="convex", o=NULL)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dm.sbm_+3A_xdata">xdata</code></td>
<td>
<p>Input(s) vector (<em>n</em> by <em>m</em>)</p>
</td></tr>
<tr><td><code id="dm.sbm_+3A_ydata">ydata</code></td>
<td>
<p>Output(s) vector (<em>n</em> by <em>s</em>)</p>
</td></tr>
<tr><td><code id="dm.sbm_+3A_rts">rts</code></td>
<td>
<p>Returns to scale assumption <br />
<code>"crs"  </code>Constant RTS (default) <br />  
<code>"vrs"  </code>Variable RTS <br />
<code>"irs"  </code>Increasing RTS <br />
<code>"drs"  </code>Decreasing RTS
</p>
</td></tr>
<tr><td><code id="dm.sbm_+3A_orientation">orientation</code></td>
<td>
<p>Orientation of the measurement <br />
<code>"n"  </code>Non-orientation (default) <br />
<code>"i"  </code>Input-orientation <br />
<code>"o"  </code>Output-orientation
</p>
</td></tr>
<tr><td><code id="dm.sbm_+3A_se">se</code></td>
<td>
<p>Implements super-efficiency model alike <em>Anderson &amp; Peterson</em>'s model if <code>TRUE</code></p>
</td></tr>
<tr><td><code id="dm.sbm_+3A_sg">sg</code></td>
<td>
<p>Employs second-stage optimization <br />
<code>"ssm"  </code>Slack-sum maximization (default) <br />
<code>"max"  </code>Date-sum maximization (only if <code>date</code> is defined) <br />
<code>"min"  </code>Date-sum minimization (only if <code>date</code> is defined)
</p>
</td></tr>
<tr><td><code id="dm.sbm_+3A_date">date</code></td>
<td>
<p>Production date (<em>n</em> by <em>1</em>)</p>
</td></tr>
<tr><td><code id="dm.sbm_+3A_cv">cv</code></td>
<td>
<p>Convexity assumption <br />
<code>"convex" </code>Convexity holds (default) <br />
<code>"fdh"    </code>Free disposal hull (this will override <code>rts</code>)
</p>
</td></tr>
<tr><td><code id="dm.sbm_+3A_o">o</code></td>
<td>
<p>DMU index to calc. <code>NULL</code>(default) will calc for all</p>
</td></tr>
</table>


<h3>Value</h3>

<table>
<tr><td><code>$eff</code></td>
<td>
<p>Efficiency score</p>
</td></tr>
<tr><td><code>$lambda</code></td>
<td>
<p>Intensity vector</p>
</td></tr>
<tr><td><code>$xslack</code></td>
<td>
<p>Input slack</p>
</td></tr>
<tr><td><code>$yslack</code></td>
<td>
<p>Output slack</p>
</td></tr>
<tr><td><code>$xtarget</code></td>
<td>
<p>Input target</p>
</td></tr>
<tr><td><code>$ytarget</code></td>
<td>
<p>Output target</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Dong-Joon Lim, PhD</p>


<h3>References</h3>

<p>Tone, Kaoru. &quot;A slacks-based measure of efficiency in data envelopment analysis.&quot; <em>European journal of operational research</em> 130.3 (2001): 498~509.
</p>
<p>Tone, Kaoru. &quot;A slacks-based measure of super-efficiency in data envelopment analysis.&quot; <em>European journal of operational research</em> 143 (2002): 32~41.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+dm.ddf">dm.ddf</a></code> Distance measure using DDF <br />
<code><a href="#topic+dm.dea">dm.dea</a></code> Distance measure using DEA <br />
<code><a href="#topic+dm.hdf">dm.hdf</a></code> Distance measure using HDF <br />
<code><a href="#topic+dm.sbm">dm.sbm</a></code> Distance measure using SBM <br />
<code><a href="#topic+dm.sf">dm.sf</a></code> Distance measure using SF
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Reproduce Table 2 in Tone.(2001)
  # ready
  X &lt;- data.frame(x1 = c(4, 6, 8, 8, 2),
                  x2 = c(3, 3, 1, 1, 4))
  Y &lt;- data.frame(y1 = c(2, 2, 6, 6, 1),
                  y2 = c(3, 3, 2, 1, 4))
  # go
  dm.sbm(X, Y)

# Reproduce Table 1 in Tone.(2002)
  # Published input slacks are alternate optima (confirmed by Tone)
  # ready
  X &lt;- data.frame(x1 = c(4, 7, 8, 4, 2, 10, 12),
                  x2 = c(3, 3, 1, 2, 4, 1,  1))
  Y &lt;- data.frame(y1 = c(1, 1, 1, 1, 1, 1,  1))
  # go
  dm.sbm(X, Y, se = TRUE)

# Reproduce Table 4 in Tone.(2002)
  # ready
  X &lt;- data.frame(x1 = c(80,  65,  83,  40,   52,  94),
                  x2 = c(600, 200, 400, 1000, 600, 700),
                  x3 = c(54,  97,  72,  75,   20,  36),
                  x4 = c(8,   1,   4,   7,    3,   5))
  Y &lt;- data.frame(y1 = c(90,  58,  60,  80,   72,  96),
                  y2 = c(5,   1,   7,   10,   8,   6))
  # go
  dm.sbm(X, Y, "crs", "i", se = TRUE)
</code></pre>

<hr>
<h2 id='dm.sf'>Distance measure using SF</h2><span id='topic+dm.sf'></span>

<h3>Description</h3>

<p>Implements <em>Luenberger</em>'s shortage (benefit) function (radial &amp; non-oriented measure).</p>


<h3>Usage</h3>

<pre><code class='language-R'>dm.sf(xdata, ydata, rts="crs", g=NULL,
      wd=NULL, se=FALSE, sg="ssm", date=NULL, cv="convex", o=NULL)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dm.sf_+3A_xdata">xdata</code></td>
<td>
<p>Input(s) vector (<em>n</em> by <em>m</em>)</p>
</td></tr>
<tr><td><code id="dm.sf_+3A_ydata">ydata</code></td>
<td>
<p>Output(s) vector (<em>n</em> by <em>s</em>)</p>
</td></tr>
<tr><td><code id="dm.sf_+3A_rts">rts</code></td>
<td>
<p>Returns to scale assumption <br />
<code>"crs"  </code>Constant RTS (default) <br />  
<code>"vrs"  </code>Variable RTS <br />
<code>"irs"  </code>Increasing RTS <br />
<code>"drs"  </code>Decreasing RTS
</p>
</td></tr>
<tr><td><code id="dm.sf_+3A_g">g</code></td>
<td>
<p>Directional vector indicating a measurement direction (<em>n</em> by <em>(m+s)</em>)<br />
By default (<code>NULL</code>), <code>xdata</code> &amp; <code>ydata</code> will be used</p>
</td></tr>
<tr><td><code id="dm.sf_+3A_wd">wd</code></td>
<td>
<p>Weak disposability vector indicating (an) undesirable output(s) (<em>1</em> by <em>s</em>)</p>
</td></tr>
<tr><td><code id="dm.sf_+3A_se">se</code></td>
<td>
<p>Implements super-efficiency model alike <em>Anderson &amp; Peterson</em>'s model if <code>TRUE</code></p>
</td></tr>
<tr><td><code id="dm.sf_+3A_sg">sg</code></td>
<td>
<p>Employs second-stage optimization <br />
<code>"ssm"  </code>Slack-sum maximization (default) <br />
<code>"max"  </code>Date-sum maximization (only if <code>date</code> is defined) <br />
<code>"min"  </code>Date-sum minimization (only if <code>date</code> is defined)
</p>
</td></tr>
<tr><td><code id="dm.sf_+3A_date">date</code></td>
<td>
<p>Production date (<em>n</em> by <em>1</em>)</p>
</td></tr>
<tr><td><code id="dm.sf_+3A_cv">cv</code></td>
<td>
<p>Convexity assumption <br />
<code>"convex" </code>Convexity holds (default) <br />
<code>"fdh"    </code>Free disposal hull (this will override <code>rts</code>)
</p>
</td></tr>
<tr><td><code id="dm.sf_+3A_o">o</code></td>
<td>
<p>DMU index to calc. <code>NULL</code>(default) will calc for all</p>
</td></tr>
</table>


<h3>Value</h3>

<table>
<tr><td><code>$eff</code></td>
<td>
<p>Efficiency score</p>
</td></tr>
<tr><td><code>$lambda</code></td>
<td>
<p>Intensity vector</p>
</td></tr>
<tr><td><code>$mu</code></td>
<td>
<p>Secondary intensity vector for weak disposability under VRS</p>
</td></tr>
<tr><td><code>$xslack</code></td>
<td>
<p>Input slack</p>
</td></tr>
<tr><td><code>$yslack</code></td>
<td>
<p>Output slack</p>
</td></tr>
<tr><td><code>$w</code></td>
<td>
<p>Input (dual) weight</p>
</td></tr>
<tr><td><code>$p</code></td>
<td>
<p>Output (dual) weight</p>
</td></tr>
<tr><td><code>$u</code></td>
<td>
<p>Free (dual) variable</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Dong-Joon Lim, PhD</p>


<h3>References</h3>

<p>Luenberger, David G. &quot;Benefit functions and duality.&quot; <em>Journal of mathematical economics</em> 21.5 (1992): 461~481.
</p>
<p>Chambers, Robert G., Yangho Chung, and Rolf Fare. &quot;Profit, directional distance functions, and Nerlovian efficiency.&quot; <em>Journal of optimization theory and applications</em> 98.2 (1998): 351~364.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+dm.ddf">dm.ddf</a></code> Distance measure using DDF <br />
<code><a href="#topic+dm.dea">dm.dea</a></code> Distance measure using DEA <br />
<code><a href="#topic+dm.hdf">dm.hdf</a></code> Distance measure using HDF <br />
<code><a href="#topic+dm.sbm">dm.sbm</a></code> Distance measure using SBM <br />
<code><a href="#topic+dm.sf">dm.sf</a></code> Distance measure using SF
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Additive form shortage function
  # ready
  x &lt;- matrix(c(5, 1, 4), ncol = 1)
  y &lt;- matrix(c(8, 3, 5, 6, 4, 1), ncol = 2)
  g &lt;- matrix(c(1), nrow = 3, ncol = 3) 
  w &lt;- matrix(c(1, 0), ncol = 2)
  # go
  dm.sf(x, y, "crs", g, w)

# Multiplicative form shortage function
  # ready
  g &lt;- cbind(x, y)
  # go
  dm.sf(x, y, "crs", g, w)
</code></pre>

<hr>
<h2 id='ma.aps.reg'>Combinatorial search (all possible subset) for regression analysis</h2><span id='topic+ma.aps.reg'></span>

<h3>Description</h3>

<p>Implements combinatorial (exhaustive) search algorithm, aka all-possible-subsets regression. As opposed to the sequential approach (stepwise, forward addition, or backward elimination) that has a potential bias resulting from considering only one variable for selection at a time, all possible combinations of the independent variables are examined, and sets satisfying designated conditions are returned.</p>


<h3>Usage</h3>

<pre><code class='language-R'>ma.aps.reg(dv, iv, min=1, max, mad=FALSE, aic=FALSE, bic=FALSE,
           model.sig=TRUE, coeff.sig=TRUE, coeff.vif=TRUE, coeff.cor=FALSE)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ma.aps.reg_+3A_dv">dv</code></td>
<td>
<p>Dependent variable (<em>r</em> by <em>1</em>)</p>
</td></tr>
<tr><td><code id="ma.aps.reg_+3A_iv">iv</code></td>
<td>
<p>Independent variable(s) (<em>r</em> by <em>c</em>)</p>
</td></tr>
<tr><td><code id="ma.aps.reg_+3A_min">min</code></td>
<td>
<p>Minimum number of independent variable to explore (&gt;=<em>1</em>)</p>
</td></tr>
<tr><td><code id="ma.aps.reg_+3A_max">max</code></td>
<td>
<p>Maximum number of independent variable to explore (&lt;=<em>r</em>/10)</p>
</td></tr>
<tr><td><code id="ma.aps.reg_+3A_mad">mad</code></td>
<td>
<p>Returns mean absolute deviation when <code>TRUE</code></p>
</td></tr>
<tr><td><code id="ma.aps.reg_+3A_aic">aic</code></td>
<td>
<p>Returns Akaike's information criterion when <code>TRUE</code></p>
</td></tr>
<tr><td><code id="ma.aps.reg_+3A_bic">bic</code></td>
<td>
<p>Returns Bayesian information criterion when <code>TRUE</code></p>
</td></tr>
<tr><td><code id="ma.aps.reg_+3A_model.sig">model.sig</code></td>
<td>
<p>Returns models statistically significant only when <code>TRUE</code></p>
</td></tr>
<tr><td><code id="ma.aps.reg_+3A_coeff.sig">coeff.sig</code></td>
<td>
<p>Returns models with statistically significant coefficients only when <code>TRUE</code></p>
</td></tr>
<tr><td><code id="ma.aps.reg_+3A_coeff.vif">coeff.vif</code></td>
<td>
<p>Returns models with allowable level of multicollinearity only when <code>TRUE</code></p>
</td></tr>
<tr><td><code id="ma.aps.reg_+3A_coeff.cor">coeff.cor</code></td>
<td>
<p>Returns models without suppression effects only when <code>TRUE</code></p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Dong-Joon Lim, PhD</p>


<h3>References</h3>

<p>Hair, Joseph F., et al. Multivariate data analysis. Vol. 7. <em>Upper Saddle River</em>, NJ: Pearson Prentice Hall, 2006.</p>


<h3>Examples</h3>

<pre><code class='language-R'># Load airplane dataset
df &lt;- dataset.airplane.2017

# ready
dv &lt;- subset(df, select = 2)
iv &lt;- subset(df, select = 3 : 7)

# go
ma.aps.reg(dv, iv, 1, 3, mad = TRUE, coeff.cor = TRUE)
</code></pre>

<hr>
<h2 id='map.corr'>Correlation mapping for reliability test</h2><span id='topic+map.corr'></span>

<h3>Description</h3>

<p>Implements a series of correlation analysis by dropping extreme data points one by one using <em>Mahalanobis</em> distance measure. Correlation reliability can be investigated with identified anchoring point(s). Correlation map as well as summary table is provided.</p>


<h3>Usage</h3>

<pre><code class='language-R'>map.corr(data, from = "median", threshold = 0.3, r.name = FALSE)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="map.corr_+3A_data">data</code></td>
<td>
<p>Dataframe</p>
</td></tr>
<tr><td><code id="map.corr_+3A_from">from</code></td>
<td>
<p>Datum point from which the distance is measured <br />
<code>"mean"    </code>Mean of each column <br />  
<code>"median"  </code>Median of each column (default)
</p>
</td></tr>
<tr><td><code id="map.corr_+3A_threshold">threshold</code></td>
<td>
<p>Threshold of correlation change to be noted on the map</p>
</td></tr>
<tr><td><code id="map.corr_+3A_r.name">r.name</code></td>
<td>
<p>Dropped points are shown in row name when <code>TRUE</code></p>
</td></tr>
</table>


<h3>Value</h3>

<table>
<tr><td><code>$reliability</code></td>
<td>
<p>Summary table</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Dong-Joon Lim, PhD</p>


<h3>See Also</h3>

<p><code><a href="#topic+dm.mahalanobis">dm.mahalanobis</a></code> Distance measure using Mahalanobis distance
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Generate a sample dataframe
df &lt;- data.frame(replicate(2, sample(0 : 100, 50)))

# go
map.corr(df)
</code></pre>

<hr>
<h2 id='map.soa.ddf'>SOA mapping using DDF</h2><span id='topic+map.soa.ddf'></span>

<h3>Description</h3>

<p>Employs <code>dm.ddf</code> over time to generate a state-of-the-art map.</p>


<h3>Usage</h3>

<pre><code class='language-R'>map.soa.ddf(xdata, ydata, date, 
            rts="crs", g=NULL, wd=NULL, sg="ssm", cv="convex", mk="dmu")</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="map.soa.ddf_+3A_xdata">xdata</code></td>
<td>
<p>Input(s) vector (<em>n</em> by <em>m</em>)</p>
</td></tr>
<tr><td><code id="map.soa.ddf_+3A_ydata">ydata</code></td>
<td>
<p>Output(s) vector (<em>n</em> by <em>s</em>)</p>
</td></tr>
<tr><td><code id="map.soa.ddf_+3A_date">date</code></td>
<td>
<p>Production date (<em>n</em> by <em>1</em>)</p>
</td></tr>
<tr><td><code id="map.soa.ddf_+3A_rts">rts</code></td>
<td>
<p>Returns to scale assumption <br />
<code>"crs"  </code>Constant RTS (default) <br />  
<code>"vrs"  </code>Variable RTS <br />
<code>"irs"  </code>Increasing RTS <br />
<code>"drs"  </code>Decreasing RTS
</p>
</td></tr>
<tr><td><code id="map.soa.ddf_+3A_g">g</code></td>
<td>
<p>Directional vector indicating a measurement direction (<em>n</em> by <em>(m+s)</em>)<br />
By default (<code>NULL</code>), <code>xdata</code> &amp; <code>ydata</code> will be used</p>
</td></tr>
<tr><td><code id="map.soa.ddf_+3A_wd">wd</code></td>
<td>
<p>Weak disposability vector indicating (an) undesirable output(s) (<em>1</em> by <em>s</em>)</p>
</td></tr>
<tr><td><code id="map.soa.ddf_+3A_sg">sg</code></td>
<td>
<p>Employs second-stage optimization <br />
<code>"ssm"  </code>Slack-sum maximization (default) <br />
<code>"max"  </code>Date-sum maximization (only if <code>date</code> is defined) <br />
<code>"min"  </code>Date-sum minimization (only if <code>date</code> is defined)
</p>
</td></tr>
<tr><td><code id="map.soa.ddf_+3A_cv">cv</code></td>
<td>
<p>Convexity assumption <br />
<code>"convex" </code>Convexity holds (default) <br />
<code>"fdh"    </code>Free disposal hull (this will override <code>rts</code>)
</p>
</td></tr>
<tr><td><code id="map.soa.ddf_+3A_mk">mk</code></td>
<td>
<p>Marker on the map <br />
<code>"dmu"  </code>DMU index (default) <br />
<code>"eff"  </code>Efficiency score  
</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Dong-Joon Lim, PhD</p>


<h3>See Also</h3>

<p><code><a href="#topic+map.soa.ddf">map.soa.ddf</a></code> SOA mapping using DDF <br />
<code><a href="#topic+map.soa.dea">map.soa.dea</a></code> SOA mapping using DEA <br />
<code><a href="#topic+map.soa.hdf">map.soa.hdf</a></code> SOA mapping using HDF <br />
<code><a href="#topic+map.soa.sbm">map.soa.sbm</a></code> SOA mapping using SBM <br />
<code><a href="#topic+map.soa.sf">map.soa.sf</a></code> SOA mapping using SF
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Load engine dataset
  df &lt;- dataset.engine.2015

# Subset for forced induction systems
  fis &lt;- subset(df, grepl("^.C..", df[, 8]))

# Parameters
  x &lt;- subset(fis, select = 4)
  y &lt;- subset(fis, select = 6 : 7)
  d &lt;- subset(fis, select = 2)
  g &lt;- matrix(c(1), nrow = nrow(x), ncol = 3)

# Generate an SOA map
  map.soa.ddf(x, y, d, "crs", g)
</code></pre>

<hr>
<h2 id='map.soa.dea'>SOA mapping using DEA</h2><span id='topic+map.soa.dea'></span>

<h3>Description</h3>

<p>Employs <code>dm.dea</code> over time to generate a state-of-the-art map.</p>


<h3>Usage</h3>

<pre><code class='language-R'>map.soa.dea(xdata, ydata, date, rts="crs", orientation,
            sg="ssm", ncv=NULL, env=NULL, cv="convex", mk="dmu")</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="map.soa.dea_+3A_xdata">xdata</code></td>
<td>
<p>Input(s) vector (<em>n</em> by <em>m</em>)</p>
</td></tr>
<tr><td><code id="map.soa.dea_+3A_ydata">ydata</code></td>
<td>
<p>Output(s) vector (<em>n</em> by <em>s</em>)</p>
</td></tr>
<tr><td><code id="map.soa.dea_+3A_date">date</code></td>
<td>
<p>Production date (<em>n</em> by <em>1</em>)</p>
</td></tr>
<tr><td><code id="map.soa.dea_+3A_rts">rts</code></td>
<td>
<p>Returns to scale assumption <br />
<code>"crs"  </code>Constant RTS (default) <br />  
<code>"vrs"  </code>Variable RTS <br />
<code>"irs"  </code>Increasing RTS <br />
<code>"drs"  </code>Decreasing RTS
</p>
</td></tr>
<tr><td><code id="map.soa.dea_+3A_orientation">orientation</code></td>
<td>
<p>Orientation of the measurement <br />
<code>"i"  </code>Input-orientation <br />
<code>"o"  </code>Output-orientation
</p>
</td></tr>
<tr><td><code id="map.soa.dea_+3A_sg">sg</code></td>
<td>
<p>Employs second-stage optimization <br />
<code>"ssm"  </code>Slack-sum maximization (default) <br />
<code>"max"  </code>Date-sum maximization (only if <code>date</code> is defined) <br />
<code>"min"  </code>Date-sum minimization (only if <code>date</code> is defined)
</p>
</td></tr>
<tr><td><code id="map.soa.dea_+3A_ncv">ncv</code></td>
<td>
<p>Non-controllable variable index(binary) for internal NDF (<em>1</em> by <em>(m+s)</em>)</p>
</td></tr>
<tr><td><code id="map.soa.dea_+3A_env">env</code></td>
<td>
<p>Environment index for external NDF (<em>n</em> by <em>1</em>)</p>
</td></tr>
<tr><td><code id="map.soa.dea_+3A_cv">cv</code></td>
<td>
<p>Convexity assumption <br />
<code>"convex" </code>Convexity holds (default) <br />
<code>"fdh"    </code>Free disposal hull (this will override <code>rts</code>)
</p>
</td></tr>
<tr><td><code id="map.soa.dea_+3A_mk">mk</code></td>
<td>
<p>Marker on the map <br />
<code>"dmu"  </code>DMU index (default) <br />
<code>"eff"  </code>Efficiency score  
</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Dong-Joon Lim, PhD</p>


<h3>See Also</h3>

<p><code><a href="#topic+map.soa.ddf">map.soa.ddf</a></code> SOA mapping using DDF <br />
<code><a href="#topic+map.soa.dea">map.soa.dea</a></code> SOA mapping using DEA <br />
<code><a href="#topic+map.soa.hdf">map.soa.hdf</a></code> SOA mapping using HDF <br />
<code><a href="#topic+map.soa.sbm">map.soa.sbm</a></code> SOA mapping using SBM <br />
<code><a href="#topic+map.soa.sf">map.soa.sf</a></code> SOA mapping using SF
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Load engine dataset
  df &lt;- dataset.engine.2015

# Subset for forced induction systems
  fis &lt;- subset(df, grepl("^.C..", df[, 8]))

# Parameters
  x &lt;- subset(fis, select = 4)
  y &lt;- subset(fis, select = 6 : 7)
  d &lt;- subset(fis, select = 2)

# Generate an SOA map
  map.soa.dea(x, y, d, "crs", "o")
</code></pre>

<hr>
<h2 id='map.soa.hdf'>SOA mapping using HDF</h2><span id='topic+map.soa.hdf'></span>

<h3>Description</h3>

<p>Employs <code>dm.hdf</code> over time to generate a state-of-the-art map.</p>


<h3>Usage</h3>

<pre><code class='language-R'>map.soa.hdf(xdata, ydata, date,
            rts="crs", wd=NULL, sg="ssm", cv="convex", mk="dmu")</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="map.soa.hdf_+3A_xdata">xdata</code></td>
<td>
<p>Input(s) vector (<em>n</em> by <em>m</em>)</p>
</td></tr>
<tr><td><code id="map.soa.hdf_+3A_ydata">ydata</code></td>
<td>
<p>Output(s) vector (<em>n</em> by <em>s</em>)</p>
</td></tr>
<tr><td><code id="map.soa.hdf_+3A_date">date</code></td>
<td>
<p>Production date (<em>n</em> by <em>1</em>)</p>
</td></tr>
<tr><td><code id="map.soa.hdf_+3A_rts">rts</code></td>
<td>
<p>Returns to scale assumption <br />
<code>"crs"  </code>Constant RTS (default) <br />  
<code>"vrs"  </code>Variable RTS <br />
<code>"irs"  </code>Increasing RTS <br />
<code>"drs"  </code>Decreasing RTS
</p>
</td></tr>
<tr><td><code id="map.soa.hdf_+3A_wd">wd</code></td>
<td>
<p>Weak disposability vector indicating (an) undesirable output(s) (<em>1</em> by <em>s</em>)</p>
</td></tr>
<tr><td><code id="map.soa.hdf_+3A_sg">sg</code></td>
<td>
<p>Employs second-stage optimization <br />
<code>"ssm"  </code>Slack-sum maximization (default) <br />
<code>"max"  </code>Date-sum maximization (only if <code>date</code> is defined) <br />
<code>"min"  </code>Date-sum minimization (only if <code>date</code> is defined)
</p>
</td></tr>
<tr><td><code id="map.soa.hdf_+3A_cv">cv</code></td>
<td>
<p>Convexity assumption <br />
<code>"convex" </code>Convexity holds (default) <br />
<code>"fdh"    </code>Free disposal hull (this will override <code>rts</code>)
</p>
</td></tr>
<tr><td><code id="map.soa.hdf_+3A_mk">mk</code></td>
<td>
<p>Marker on the map <br />
<code>"dmu"  </code>DMU index (default) <br />
<code>"eff"  </code>Efficiency score  
</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Dong-Joon Lim, PhD</p>


<h3>References</h3>

<p>D.-J. Lim,  Internal combustion engine race: naturally aspirated vs turbo/super-charged, <em>working paper</em> (2015).
</p>


<h3>See Also</h3>

<p><code><a href="#topic+map.soa.ddf">map.soa.ddf</a></code> SOA mapping using DDF <br />
<code><a href="#topic+map.soa.dea">map.soa.dea</a></code> SOA mapping using DEA <br />
<code><a href="#topic+map.soa.hdf">map.soa.hdf</a></code> SOA mapping using HDF <br />
<code><a href="#topic+map.soa.sbm">map.soa.sbm</a></code> SOA mapping using SBM <br />
<code><a href="#topic+map.soa.sf">map.soa.sf</a></code> SOA mapping using SF
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Load engine dataset
  df &lt;- dataset.engine.2015

# Subset for SC/TC 8 cylinder engines
  stc.8 &lt;- subset(df, grepl("^.C..", df[, 8]) &amp; df[, 3] == 8)

# Parameters
  x &lt;- subset(stc.8, select = 4)
  y &lt;- subset(stc.8, select = 5:7)
  d &lt;- subset(stc.8, select = 2)

# Generate an SOA map
  map.soa.hdf(x, y, d, "vrs")
</code></pre>

<hr>
<h2 id='map.soa.sbm'>SOA mapping using SBM</h2><span id='topic+map.soa.sbm'></span>

<h3>Description</h3>

<p>Employs <code>dm.sbm</code> over time to generate a state-of-the-art map.</p>


<h3>Usage</h3>

<pre><code class='language-R'>map.soa.sbm(xdata, ydata, date, 
            rts="crs", orientation="n", sg="ssm", cv="convex", mk="dmu")</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="map.soa.sbm_+3A_xdata">xdata</code></td>
<td>
<p>Input(s) vector (<em>n</em> by <em>m</em>)</p>
</td></tr>
<tr><td><code id="map.soa.sbm_+3A_ydata">ydata</code></td>
<td>
<p>Output(s) vector (<em>n</em> by <em>s</em>)</p>
</td></tr>
<tr><td><code id="map.soa.sbm_+3A_date">date</code></td>
<td>
<p>Production date (<em>n</em> by <em>1</em>)</p>
</td></tr>
<tr><td><code id="map.soa.sbm_+3A_rts">rts</code></td>
<td>
<p>Returns to scale assumption <br />
<code>"crs"  </code>Constant RTS (default) <br />  
<code>"vrs"  </code>Variable RTS <br />
<code>"irs"  </code>Increasing RTS <br />
<code>"drs"  </code>Decreasing RTS
</p>
</td></tr>
<tr><td><code id="map.soa.sbm_+3A_orientation">orientation</code></td>
<td>
<p>Orientation of the measurement <br />
<code>"n"  </code>Non-orientation (default) <br />
<code>"i"  </code>Input-orientation <br />
<code>"o"  </code>Output-orientation
</p>
</td></tr>
<tr><td><code id="map.soa.sbm_+3A_sg">sg</code></td>
<td>
<p>Employs second-stage optimization <br />
<code>"ssm"  </code>Slack-sum maximization (default) <br />
<code>"max"  </code>Date-sum maximization (only if <code>date</code> is defined) <br />
<code>"min"  </code>Date-sum minimization (only if <code>date</code> is defined)
</p>
</td></tr>
<tr><td><code id="map.soa.sbm_+3A_cv">cv</code></td>
<td>
<p>Convexity assumption <br />
<code>"convex" </code>Convexity holds (default) <br />
<code>"fdh"    </code>Free disposal hull (this will override <code>rts</code>)
</p>
</td></tr>
<tr><td><code id="map.soa.sbm_+3A_mk">mk</code></td>
<td>
<p>Marker on the map <br />
<code>"dmu"  </code>DMU index (default) <br />
<code>"eff"  </code>Efficiency score  
</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Dong-Joon Lim, PhD</p>


<h3>See Also</h3>

<p><code><a href="#topic+map.soa.ddf">map.soa.ddf</a></code> SOA mapping using DDF <br />
<code><a href="#topic+map.soa.dea">map.soa.dea</a></code> SOA mapping using DEA <br />
<code><a href="#topic+map.soa.hdf">map.soa.hdf</a></code> SOA mapping using HDF <br />
<code><a href="#topic+map.soa.sbm">map.soa.sbm</a></code> SOA mapping using SBM <br />
<code><a href="#topic+map.soa.sf">map.soa.sf</a></code> SOA mapping using SF
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Load engine dataset
  df &lt;- dataset.engine.2015

# Subset for forced induction systems
  fis &lt;- subset(df, grepl("^.C..", df[, 8]))

# Parameters
  x &lt;- subset(fis, select = 4)
  y &lt;- subset(fis, select = 6 : 7)
  d &lt;- subset(fis, select = 2)

# Generate an SOA map
  map.soa.sbm(x, y, d)
</code></pre>

<hr>
<h2 id='map.soa.sf'>SOA mapping using SF</h2><span id='topic+map.soa.sf'></span>

<h3>Description</h3>

<p>Employs <code>dm.sf</code> over time to generate a state-of-the-art map.</p>


<h3>Usage</h3>

<pre><code class='language-R'>map.soa.sf(xdata, ydata, date, 
           rts="crs", g=NULL, wd=NULL, sg="ssm", cv="convex", mk="dmu")</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="map.soa.sf_+3A_xdata">xdata</code></td>
<td>
<p>Input(s) vector (<em>n</em> by <em>m</em>)</p>
</td></tr>
<tr><td><code id="map.soa.sf_+3A_ydata">ydata</code></td>
<td>
<p>Output(s) vector (<em>n</em> by <em>s</em>)</p>
</td></tr>
<tr><td><code id="map.soa.sf_+3A_date">date</code></td>
<td>
<p>Production date (<em>n</em> by <em>1</em>)</p>
</td></tr>
<tr><td><code id="map.soa.sf_+3A_rts">rts</code></td>
<td>
<p>Returns to scale assumption <br />
<code>"crs"  </code>Constant RTS (default) <br />  
<code>"vrs"  </code>Variable RTS <br />
<code>"irs"  </code>Increasing RTS <br />
<code>"drs"  </code>Decreasing RTS
</p>
</td></tr>
<tr><td><code id="map.soa.sf_+3A_g">g</code></td>
<td>
<p>Directional vector indicating a measurement direction (<em>n</em> by <em>(m+s)</em>)<br />
By default (<code>NULL</code>), <code>xdata</code> &amp; <code>ydata</code> will be used</p>
</td></tr>
<tr><td><code id="map.soa.sf_+3A_wd">wd</code></td>
<td>
<p>Weak disposability vector indicating (an) undesirable output(s) (<em>1</em> by <em>s</em>)</p>
</td></tr>
<tr><td><code id="map.soa.sf_+3A_sg">sg</code></td>
<td>
<p>Employs second-stage optimization <br />
<code>"ssm"  </code>Slack-sum maximization (default) <br />
<code>"max"  </code>Date-sum maximization (only if <code>date</code> is defined) <br />
<code>"min"  </code>Date-sum minimization (only if <code>date</code> is defined)
</p>
</td></tr>
<tr><td><code id="map.soa.sf_+3A_cv">cv</code></td>
<td>
<p>Convexity assumption <br />
<code>"convex" </code>Convexity holds (default) <br />
<code>"fdh"    </code>Free disposal hull (this will override <code>rts</code>)
</p>
</td></tr>
<tr><td><code id="map.soa.sf_+3A_mk">mk</code></td>
<td>
<p>Marker on the map <br />
<code>"dmu"  </code>DMU index (default) <br />
<code>"eff"  </code>Efficiency score  
</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Dong-Joon Lim, PhD</p>


<h3>References</h3>

<p>D.-J. Lim,  Internal combustion engine race: naturally aspirated vs turbo/super-charged, <em>working paper</em> (2015).
</p>


<h3>See Also</h3>

<p><code><a href="#topic+map.soa.ddf">map.soa.ddf</a></code> SOA mapping using DDF <br />
<code><a href="#topic+map.soa.dea">map.soa.dea</a></code> SOA mapping using DEA <br />
<code><a href="#topic+map.soa.hdf">map.soa.hdf</a></code> SOA mapping using HDF <br />
<code><a href="#topic+map.soa.sbm">map.soa.sbm</a></code> SOA mapping using SBM <br />
<code><a href="#topic+map.soa.sf">map.soa.sf</a></code> SOA mapping using SF
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Reproduce Table 2 in Lim, D-J. (2015)
  # Load engine dataset
    df &lt;- dataset.engine.2015
  
  # Subset for 4 cylinder engines
    fce &lt;- subset(df, df[, 3] == 4)

  # Parameters
    x &lt;- subset(fce, select = 4)
    y &lt;- subset(fce, select = 5 : 7)
    d &lt;- subset(fce, select = 2)
    g &lt;- data.frame(0, y)
    w &lt;- matrix(c(1, 0, 0), ncol = 3)

  # Generate an SOA map
    map.soa.sf(x, y, d, "crs", g, w, mk = "eff")
</code></pre>

<hr>
<h2 id='plp'>Print LP object</h2><span id='topic+plp'></span>

<h3>Description</h3>

<p>Print an LP object line by line.</p>


<h3>Usage</h3>

<pre><code class='language-R'>plp(x)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plp_+3A_x">x</code></td>
<td>
<p>LP object defined by make.lp function in lpSolve library</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Dong-Joon Lim, PhD</p>


<h3>References</h3>

<p>Berkelaar, Michel, Kjell Eikland, and Peter Notebaert. &quot;lpsolve: Open source (mixed-integer) linear programming system.&quot; <em>Eindhoven U. of Technology</em> 63 (2004).
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Declare an LP object
lp.temp &lt;- make.lp(0, 61)

# Print the LP
plp(lp.temp)
</code></pre>

<hr>
<h2 id='roc.dea'>Rate of change (RoC) calculation using DEA</h2><span id='topic+roc.dea'></span>

<h3>Description</h3>

<p>Employs <code>dm.dea</code> over time to calculate RoCs.</p>


<h3>Usage</h3>

<pre><code class='language-R'>roc.dea(xdata, ydata, date, t, rts="crs", orientation,
        sg="ssm", ftype="d", ncv=NULL, env=NULL, cv="convex")</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="roc.dea_+3A_xdata">xdata</code></td>
<td>
<p>Input(s) vector (<em>n</em> by <em>m</em>)</p>
</td></tr>
<tr><td><code id="roc.dea_+3A_ydata">ydata</code></td>
<td>
<p>Output(s) vector (<em>n</em> by <em>s</em>)</p>
</td></tr>
<tr><td><code id="roc.dea_+3A_date">date</code></td>
<td>
<p>Production date (<em>n</em> by <em>1</em>)</p>
</td></tr>
<tr><td><code id="roc.dea_+3A_t">t</code></td>
<td>
<p>A vantage point from which the RoC is captured</p>
</td></tr>
<tr><td><code id="roc.dea_+3A_rts">rts</code></td>
<td>
<p>Returns to scale assumption <br />
<code>"crs"  </code>Constant RTS (default) <br />  
<code>"vrs"  </code>Variable RTS <br />
<code>"irs"  </code>Increasing RTS <br />
<code>"drs"  </code>Decreasing RTS
</p>
</td></tr>
<tr><td><code id="roc.dea_+3A_orientation">orientation</code></td>
<td>
<p>Orientation of the measurement <br />
<code>"i"  </code>Input-orientation <br />
<code>"o"  </code>Output-orientation
</p>
</td></tr>
<tr><td><code id="roc.dea_+3A_sg">sg</code></td>
<td>
<p>Employs second-stage optimization <br />
<code>"ssm"  </code>Slack-sum maximization (default) <br />
<code>"max"  </code>Date-sum maximization <br />
<code>"min"  </code>Date-sum minimization
</p>
</td></tr>
<tr><td><code id="roc.dea_+3A_ftype">ftype</code></td>
<td>
<p>Frontier type <br />
<code>"d"  </code>Dynamic frontier (default) <br />  
<code>"s"  </code>Static frontier
</p>
</td></tr>
<tr><td><code id="roc.dea_+3A_ncv">ncv</code></td>
<td>
<p>Non-controllable variable index(binary) for internal NDF (<em>1</em> by <em>(m+s)</em>)</p>
</td></tr>
<tr><td><code id="roc.dea_+3A_env">env</code></td>
<td>
<p>Environment index for external NDF (<em>n</em> by <em>1</em>)</p>
</td></tr>
<tr><td><code id="roc.dea_+3A_cv">cv</code></td>
<td>
<p>Convexity assumption <br />
<code>"convex" </code>Convexity holds (default) <br />
<code>"fdh"    </code>Free disposal hull (this will override <code>rts</code>)
</p>
</td></tr>
</table>


<h3>Value</h3>

<table>
<tr><td><code>$eff_r</code></td>
<td>
<p>Efficiency at release (i.e., at each production date)</p>
</td></tr>
<tr><td><code>$eff_t</code></td>
<td>
<p>Efficiency at <code>t</code></p>
</td></tr>
<tr><td><code>$lambda_t</code></td>
<td>
<p>Intensity vector at <code>t</code></p>
</td></tr>
<tr><td><code>$eft_date</code></td>
<td>
<p>Effective date</p>
</td></tr>
<tr><td><code>$roc_past</code></td>
<td>
<p>RoC observed from the obsolete DMUs in the past</p>
</td></tr>
<tr><td><code>$roc_avg</code></td>
<td>
<p>Average RoC</p>
</td></tr>
<tr><td><code>$roc_local</code></td>
<td>
<p>Local RoC</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Dong-Joon Lim, PhD</p>


<h3>References</h3>

<p>Lim, Dong-Joon, Timothy R. Anderson, and Oliver Lane Inman. &quot;Choosing effective dates from multiple optima in Technology Forecasting using Data Envelopment Analysis (TFDEA).&quot; <em>Technological Forecasting and Social Change</em> 88 (2014): 91~97.
</p>
<p>Lim, Dong-Joon, et al. &quot;Comparing technological advancement of hybrid electric vehicles (HEV) in different market segments.&quot; <em>Technological Forecasting and Social Change</em> 97 (2015): 140~153.
</p>
<p>Lim, Dong-Joon, and Dong-Hyuk Yang. &quot;Assessment of Regulatory Requirements on Technological Changes: The Increasing Dominance of Downsized Turbo/Super-Charged Engines Over Naturally Aspirated Engines.&quot; <em>IEEE Access</em> 7 (2019): 84839-84848.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+dm.dea">dm.dea</a></code> Distance measure using DEA <br />
<code><a href="#topic+roc.dea">roc.dea</a></code> RoC calculation using DEA <br />
<code><a href="#topic+map.soa.dea">map.soa.dea</a></code> SOA mapping using DEA <br />
<code><a href="#topic+target.arrival.dea">target.arrival.dea</a></code> Arrival target setting using DEA <br />
<code><a href="#topic+target.spec.dea">target.spec.dea</a></code> Spec target setting using DEA
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Reproduce Table 3 in Lim, D-J. et al.(2014)
  # Load airplane dataset
  df &lt;- dataset.airplane.2017
  
  # ready
  x &lt;- data.frame(Flew = rep(1, 28))
  y &lt;- subset(df, select = 3 : 7)
  d &lt;- subset(df, select = 2)

  # go
  roc.dea(x, y, d, 2007, "vrs", "o", "min", "d")$roc_past

# Reproduce Table 3 in Lim, D-J. et al.(2015)
  # Load hev dataset
  df &lt;- dataset.hev.2013
  
  # ready
  x &lt;- subset(df, select = 3)
  y &lt;- subset(df, select = 4 : 6)
  d &lt;- subset(df, select = 2)
  c &lt;- subset(df, select = 7)

  # go
  results &lt;- roc.dea(x, y, d, 2013, "vrs", "o", "min", "d", env = c)
  hev &lt;- which(results$roc_local &gt; 0)
  data.frame(Class = c[hev, ], 
             SOA = hev,
             LocalRoC = results$roc_local[hev, ])[order(c[hev, ]), ]
  # NOTE: the published results include a typo on roc_local[82,]
  #       this has been corrected in Lim, D-J. et al. (2016).
</code></pre>

<hr>
<h2 id='roc.hdf'>Rate of change (RoC) calculation using HDF</h2><span id='topic+roc.hdf'></span>

<h3>Description</h3>

<p>Employs <code>dm.hdf</code> over time to calculate RoCs.</p>


<h3>Usage</h3>

<pre><code class='language-R'>roc.hdf(xdata, ydata, date, t,
        rts="crs", wd=NULL, sg="ssm", ftype="d", cv="convex")</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="roc.hdf_+3A_xdata">xdata</code></td>
<td>
<p>Input(s) vector (<em>n</em> by <em>m</em>)</p>
</td></tr>
<tr><td><code id="roc.hdf_+3A_ydata">ydata</code></td>
<td>
<p>Output(s) vector (<em>n</em> by <em>s</em>)</p>
</td></tr>
<tr><td><code id="roc.hdf_+3A_date">date</code></td>
<td>
<p>Production date (<em>n</em> by <em>1</em>)</p>
</td></tr>
<tr><td><code id="roc.hdf_+3A_t">t</code></td>
<td>
<p>A vantage point from which the RoC is captured</p>
</td></tr>
<tr><td><code id="roc.hdf_+3A_rts">rts</code></td>
<td>
<p>Returns to scale assumption <br />
<code>"crs"  </code>Constant RTS (default) <br />  
<code>"vrs"  </code>Variable RTS <br />
<code>"irs"  </code>Increasing RTS <br />
<code>"drs"  </code>Decreasing RTS
</p>
</td></tr>
<tr><td><code id="roc.hdf_+3A_wd">wd</code></td>
<td>
<p>Weak disposability vector indicating (an) undesirable output(s) (<em>1</em> by <em>s</em>)</p>
</td></tr> 
<tr><td><code id="roc.hdf_+3A_sg">sg</code></td>
<td>
<p>Employs second-stage optimization <br />
<code>"ssm"  </code>Slack-sum maximization (default) <br />
<code>"max"  </code>Date-sum maximization <br />
<code>"min"  </code>Date-sum minimization
</p>
</td></tr>
<tr><td><code id="roc.hdf_+3A_ftype">ftype</code></td>
<td>
<p>Frontier type <br />
<code>"d"  </code>Dynamic frontier (default) <br />  
<code>"s"  </code>Static frontier
</p>
</td></tr>
<tr><td><code id="roc.hdf_+3A_cv">cv</code></td>
<td>
<p>Convexity assumption <br />
<code>"convex" </code>Convexity holds (default) <br />
<code>"fdh"    </code>Free disposal hull (this will override <code>rts</code>)
</p>
</td></tr>
</table>


<h3>Value</h3>

<table>
<tr><td><code>$eff_r</code></td>
<td>
<p>Efficiency at release (i.e., at each production date)</p>
</td></tr>
<tr><td><code>$eff_t</code></td>
<td>
<p>Efficiency at <code>t</code></p>
</td></tr>
<tr><td><code>$lambda_t</code></td>
<td>
<p>Intensity vector at <code>t</code></p>
</td></tr>
<tr><td><code>$eft_date</code></td>
<td>
<p>Effective date</p>
</td></tr>
<tr><td><code>$roc_past</code></td>
<td>
<p>RoC observed from the obsolete DMUs in the past</p>
</td></tr>
<tr><td><code>$roc_avg</code></td>
<td>
<p>Average RoC</p>
</td></tr>
<tr><td><code>$roc_local</code></td>
<td>
<p>Local RoC</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Dong-Joon Lim, PhD</p>


<h3>References</h3>

<p>D.-J. Lim,  Internal combustion engine race: naturally aspirated vs turbo/super-charged, <em>working paper</em> (2015).
</p>


<h3>See Also</h3>

<p><code><a href="#topic+dm.hdf">dm.hdf</a></code> Distance measure using HDF <br />
<code><a href="#topic+roc.hdf">roc.hdf</a></code> RoC calculation using HDF <br />
<code><a href="#topic+map.soa.hdf">map.soa.hdf</a></code> SOA mapping using HDF <br />
<code><a href="#topic+target.arrival.hdf">target.arrival.hdf</a></code> Arrival target setting using HDF
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Load engine dataset
  df &lt;- dataset.engine.2015

# Subset for 8 cylinder TC-P engines
  et &lt;- subset(df, df[, 3] == 8 &amp; df[, 8] == "TC-P")
  
# Parameters
  x &lt;- subset(et, select = 4)
  y &lt;- subset(et, select = 5 : 7)
  d &lt;- subset(et, select = 2)
  w &lt;- matrix(c(1, 0, 0), ncol = 3)

# Calc local Roc
  roc.hdf(x, y, d, 2015, "vrs", w, "min")
</code></pre>

<hr>
<h2 id='roc.malmquist'>Malmquist Index: time-series productivity analysis</h2><span id='topic+roc.malmquist'></span>

<h3>Description</h3>

<p>Employs distance measure over time to calculate the productivity changes.</p>


<h3>Usage</h3>

<pre><code class='language-R'>roc.malmquist(xdata, ydata, tm=NULL, dm="dea", rts="crs", orientation,
              g=NULL, wd=NULL, ncv=NULL, env=NULL, cv="convex")</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="roc.malmquist_+3A_xdata">xdata</code></td>
<td>
<p>Input(s) array (<em>n</em> by <em>m</em> by <em>t</em>)</p>
</td></tr>
<tr><td><code id="roc.malmquist_+3A_ydata">ydata</code></td>
<td>
<p>Output(s) array (<em>n</em> by <em>s</em> by <em>t</em>)</p>
</td></tr>
<tr><td><code id="roc.malmquist_+3A_tm">tm</code></td>
<td>
<p>Tick mark of production dates (a vector length of <em>t</em>)</p>
</td></tr>
<tr><td><code id="roc.malmquist_+3A_dm">dm</code></td>
<td>
<p>Distance measure to calculate the productivity <br />
<code>"dea"  </code>Data Envelopment Analysis (default) <br />  
<code>"sbm"  </code>Slack Based Model <br />
<code>"ddf"  </code>Directional Distance Function <br />
<code>"hdf"  </code>Hyperbolic Distance Function <br />
<code>"sf"   </code>Shortage Function
</p>
</td></tr>
<tr><td><code id="roc.malmquist_+3A_rts">rts</code></td>
<td>
<p>Returns to scale assumption <br />
<code>"crs"  </code>Constant RTS (default) <br />  
<code>"vrs"  </code>Variable RTS <br />
<code>"irs"  </code>Increasing RTS <br />
<code>"drs"  </code>Decreasing RTS
</p>
</td></tr>
<tr><td><code id="roc.malmquist_+3A_orientation">orientation</code></td>
<td>
<p>Orientation of the measurement <br />
<code>"n"  </code>Non-orientation (default) <br />
<code>"i"  </code>Input-orientation <br />
<code>"o"  </code>Output-orientation
</p>
</td></tr>
<tr><td><code id="roc.malmquist_+3A_g">g</code></td>
<td>
<p>Directional vector indicating a measurement direction (<em>n</em> by <em>(m+s)</em>)<br />
By default (<code>NULL</code>), <code>xdata</code> &amp; <code>ydata</code> will be used</p>
</td></tr>
<tr><td><code id="roc.malmquist_+3A_wd">wd</code></td>
<td>
<p>Weak disposability vector indicating (an) undesirable output(s) (<em>1</em> by <em>s</em>)</p>
</td></tr>
<tr><td><code id="roc.malmquist_+3A_ncv">ncv</code></td>
<td>
<p>Non-controllable variable index(binary) for internal NDF (<em>1</em> by <em>(m+s)</em>)</p>
</td></tr>
<tr><td><code id="roc.malmquist_+3A_env">env</code></td>
<td>
<p>Environment index for external NDF (<em>n</em> by <em>1</em>)</p>
</td></tr>
<tr><td><code id="roc.malmquist_+3A_cv">cv</code></td>
<td>
<p>Convexity assumption <br />
<code>"convex" </code>Convexity holds (default) <br />
<code>"fdh"    </code>Free disposal hull (this will override <code>rts</code>)
</p>
</td></tr>
</table>


<h3>Value</h3>

<table>
<tr><td><code>$cu</code></td>
<td>
<p>Catching Up (aka technical efficiency change: TEC) index</p>
</td></tr>
<tr><td><code>$fs</code></td>
<td>
<p>Frontier Shift (FS) Index</p>
</td></tr>
<tr><td><code>$mi</code></td>
<td>
<p>Malmquist Index</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Dong-Joon Lim, PhD</p>


<h3>References</h3>

<p>R. Fare, S. Grosskopf, and C. A. K. Lovell, Production Frontiers. <em>Cambridge University Press</em>, 1994.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+dm.ddf">dm.ddf</a></code> Distance measure using DDF <br />
<code><a href="#topic+dm.dea">dm.dea</a></code> Distance measure using DEA <br />
<code><a href="#topic+dm.hdf">dm.hdf</a></code> Distance measure using HDF <br />
<code><a href="#topic+dm.sbm">dm.sbm</a></code> Distance measure using SBM <br />
<code><a href="#topic+dm.sf">dm.sf</a></code> Distance measure using SF
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Load data
  df &lt;- array(c(4,     3,   9,  10,  7, 4,  3, 5,
                5,    12,   3,   8,  1, 4, 14, 3,
                1,     1,   1,   1,  1, 1,  1, 1,
                3.4,   2,  10,   8, 10, 4,  1, 5,
                6,    10, 3.5,   7,  2, 4, 12, 3,
                1,     1,   1,   1,  1, 1,  1, 1,
                2.8, 1.8,   8,   7, 10, 3,  1, 5,
                5.7, 8.8, 2.8,   5,  2, 5,  9, 3,
                1,     1,   1,   1,  1, 1,  1, 1,
                2.2, 1.5,   8,   5,  8, 3,  1, 5,
                6,     8, 2.3, 3.5,  2, 5,  7, 3,
                1,     1,   1,   1,  1, 1,  1, 1),
              c(8, 3, 4))

# Run
  roc.malmquist(df[,1:2,], df[,3,], dm = "sbm", orientation = "n")
</code></pre>

<hr>
<h2 id='roc.sf'>Rate of change (RoC) calculation using SF</h2><span id='topic+roc.sf'></span>

<h3>Description</h3>

<p>Employs <code>dm.sf</code> over time to calculate RoCs. This function is valid only when multiplicative form of directional vector is used.</p>


<h3>Usage</h3>

<pre><code class='language-R'>roc.sf(xdata, ydata, date, t, 
       rts="crs", g=NULL, wd=NULL, sg="ssm", ftype="d", cv="convex")</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="roc.sf_+3A_xdata">xdata</code></td>
<td>
<p>Input(s) vector (<em>n</em> by <em>m</em>)</p>
</td></tr>
<tr><td><code id="roc.sf_+3A_ydata">ydata</code></td>
<td>
<p>Output(s) vector (<em>n</em> by <em>s</em>)</p>
</td></tr>
<tr><td><code id="roc.sf_+3A_date">date</code></td>
<td>
<p>Production date (<em>n</em> by <em>1</em>)</p>
</td></tr>
<tr><td><code id="roc.sf_+3A_t">t</code></td>
<td>
<p>A vantage point from which the RoC is captured</p>
</td></tr>
<tr><td><code id="roc.sf_+3A_rts">rts</code></td>
<td>
<p>Returns to scale assumption <br />
<code>"crs"  </code>Constant RTS (default) <br />  
<code>"vrs"  </code>Variable RTS <br />
<code>"irs"  </code>Increasing RTS <br />
<code>"drs"  </code>Decreasing RTS
</p>
</td></tr>
<tr><td><code id="roc.sf_+3A_g">g</code></td>
<td>
<p>Directional vector indicating a measurement direction (<em>n</em> by <em>(m+s)</em>)<br />
By default (<code>NULL</code>), <code>xdata</code> &amp; <code>ydata</code> will be used</p>
</td></tr>
<tr><td><code id="roc.sf_+3A_wd">wd</code></td>
<td>
<p>Weak disposability vector indicating (an) undesirable output(s) (<em>1</em> by <em>s</em>)</p>
</td></tr> 
<tr><td><code id="roc.sf_+3A_sg">sg</code></td>
<td>
<p>Employs second-stage optimization <br />
<code>"ssm"  </code>Slack-sum maximization (default) <br />
<code>"max"  </code>Date-sum maximization <br />
<code>"min"  </code>Date-sum minimization
</p>
</td></tr>
<tr><td><code id="roc.sf_+3A_ftype">ftype</code></td>
<td>
<p>Frontier type <br />
<code>"d"  </code>Dynamic frontier (default) <br />  
<code>"s"  </code>Static frontier
</p>
</td></tr>
<tr><td><code id="roc.sf_+3A_cv">cv</code></td>
<td>
<p>Convexity assumption <br />
<code>"convex" </code>Convexity holds (default) <br />
<code>"fdh"    </code>Free disposal hull (this will override <code>rts</code>)
</p>
</td></tr>
</table>


<h3>Value</h3>

<table>
<tr><td><code>$eff_r</code></td>
<td>
<p>Efficiency at release (i.e., at each production date)</p>
</td></tr>
<tr><td><code>$eff_t</code></td>
<td>
<p>Efficiency at <code>t</code></p>
</td></tr>
<tr><td><code>$lambda_t</code></td>
<td>
<p>Intensity vector at <code>t</code></p>
</td></tr>
<tr><td><code>$eft_date</code></td>
<td>
<p>Effective date</p>
</td></tr>
<tr><td><code>$roc_past</code></td>
<td>
<p>RoC observed from the obsolete DMUs in the past</p>
</td></tr>
<tr><td><code>$roc_avg</code></td>
<td>
<p>Average RoC</p>
</td></tr>
<tr><td><code>$roc_local</code></td>
<td>
<p>Local RoC</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Dong-Joon Lim, PhD</p>


<h3>References</h3>

<p>D.-J. Lim,  Internal combustion engine race: naturally aspirated vs turbo/super-charged, <em>working paper</em> (2015).
</p>


<h3>See Also</h3>

<p><code><a href="#topic+dm.sf">dm.sf</a></code> Distance measure using SF <br />
<code><a href="#topic+roc.sf">roc.sf</a></code> RoC calculation using SF <br />
<code><a href="#topic+map.soa.sf">map.soa.sf</a></code> SOA mapping using SF <br />
<code><a href="#topic+target.arrival.sf">target.arrival.sf</a></code> Arrival target setting using SF
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Reproduce Mercedes-Benz CLA45 AMG's local RoC in Table 5 in Lim, D-J. (2015)
  # Load engine dataset
    df &lt;- dataset.engine.2015
  
  # Subset for 4 cylinder engines
    fce &lt;- subset(df, df[, 3] == 4)
    
  # Parameters
    x &lt;- subset(fce, select = 4)
    y &lt;- subset(fce, select = 5 : 7)
    d &lt;- subset(fce, select = 2)
    g &lt;- as.matrix(data.frame(0, y))
    w &lt;- matrix(c(1, 0, 0), ncol = 3)

  # Calc local Roc
    roc.sf(x, y, d, 2014, "crs", g, w, "min")$roc_local[348, ]
</code></pre>

<hr>
<h2 id='target.arrival.dea'>Arrival target setting using DEA</h2><span id='topic+target.arrival.dea'></span>

<h3>Description</h3>

<p>Employs <code>dm.dea</code> over time to estimate the arrival of known specifications.</p>


<h3>Usage</h3>

<pre><code class='language-R'>target.arrival.dea(xdata, ydata, date, t, rts="crs", orientation, 
                   sg="ssm", ftype="d", ncv=NULL, env=NULL, cv="convex", anc=FALSE)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="target.arrival.dea_+3A_xdata">xdata</code></td>
<td>
<p>Input(s) vector (<em>n</em> by <em>m</em>)</p>
</td></tr>
<tr><td><code id="target.arrival.dea_+3A_ydata">ydata</code></td>
<td>
<p>Output(s) vector (<em>n</em> by <em>s</em>)</p>
</td></tr>
<tr><td><code id="target.arrival.dea_+3A_date">date</code></td>
<td>
<p>Production date (<em>n</em> by <em>1</em>)</p>
</td></tr>
<tr><td><code id="target.arrival.dea_+3A_t">t</code></td>
<td>
<p>A vantage point from which the RoC is captured</p>
</td></tr>
<tr><td><code id="target.arrival.dea_+3A_rts">rts</code></td>
<td>
<p>Returns to scale assumption <br />
<code>"crs"  </code>Constant RTS (default) <br />  
<code>"vrs"  </code>Variable RTS <br />
<code>"irs"  </code>Increasing RTS <br />
<code>"drs"  </code>Decreasing RTS
</p>
</td></tr>
<tr><td><code id="target.arrival.dea_+3A_orientation">orientation</code></td>
<td>
<p>Orientation of the measurement <br />
<code>"i"  </code>Input-orientation <br />
<code>"o"  </code>Output-orientation
</p>
</td></tr>
<tr><td><code id="target.arrival.dea_+3A_sg">sg</code></td>
<td>
<p>Employs second-stage optimization <br />
<code>"ssm"  </code>Slack-sum maximization (default) <br />
<code>"max"  </code>Date-sum maximization <br />
<code>"min"  </code>Date-sum minimization
</p>
</td></tr>
<tr><td><code id="target.arrival.dea_+3A_ftype">ftype</code></td>
<td>
<p>Frontier type <br />
<code>"d"  </code>Dynamic frontier (default) <br />  
<code>"s"  </code>Static frontier
</p>
</td></tr>
<tr><td><code id="target.arrival.dea_+3A_ncv">ncv</code></td>
<td>
<p>Non-controllable variable index(binary) for internal NDF (<em>1</em> by <em>(m+s)</em>)</p>
</td></tr>
<tr><td><code id="target.arrival.dea_+3A_env">env</code></td>
<td>
<p>Environment index for external NDF (<em>n</em> by <em>1</em>)</p>
</td></tr>
<tr><td><code id="target.arrival.dea_+3A_cv">cv</code></td>
<td>
<p>Convexity assumption <br />
<code>"convex" </code>Convexity holds (default) <br />
<code>"fdh"    </code>Free disposal hull (this will override <code>rts</code>)
</p>
</td></tr>
<tr><td><code id="target.arrival.dea_+3A_anc">anc</code></td>
<td>
<p>Implements a stepwise RoC computation if <code>TRUE</code></p>
</td></tr>
</table>


<h3>Value</h3>

<table>
<tr><td><code>$eff_t</code></td>
<td>
<p>Efficiency at <code>t</code></p>
</td></tr>
<tr><td><code>$lambda_t</code></td>
<td>
<p>Intensity vector at <code>t</code></p>
</td></tr>
<tr><td><code>$eft_date</code></td>
<td>
<p>Effective date</p>
</td></tr>
<tr><td><code>$roc_avg</code></td>
<td>
<p>Average RoC</p>
</td></tr>
<tr><td><code>$roc_anc</code></td>
<td>
<p>Local RoCs across the periods</p>
</td></tr>
<tr><td><code>$roc_local</code></td>
<td>
<p>Local RoC</p>
</td></tr>
<tr><td><code>$roc_ind</code></td>
<td>
<p>Individualized RoC</p>
</td></tr>
<tr><td><code>$arrival_avg</code></td>
<td>
<p>Estimated arrival using <code>roc_avg</code></p>
</td></tr>
<tr><td><code>$arrival_seg</code></td>
<td>
<p>Estimated arrival using <code>roc_ind</code></p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Dong-Joon Lim, PhD</p>


<h3>References</h3>

<p>Lim, Dong-Joon, Timothy R. Anderson, and Oliver Lane Inman. &quot;Choosing effective dates from multiple optima in Technology Forecasting using Data Envelopment Analysis (TFDEA).&quot; <em>Technological Forecasting and Social Change</em> 88 (2014): 91~97.
</p>
<p>Lim, Dong-Joon, and Timothy R. Anderson. Time series benchmarking analysis for new product scheduling: who are the competitors and how fast are they moving forward?. <em>Advances in DEA Theory and Applications: with Examples in Forecasting Models</em>. (2017): 443-458.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+dm.dea">dm.dea</a></code> Distance measure using DEA <br />
<code><a href="#topic+roc.dea">roc.dea</a></code> RoC calculation using DEA <br />
<code><a href="#topic+map.soa.dea">map.soa.dea</a></code> SOA mapping using DEA <br />
<code><a href="#topic+target.arrival.dea">target.arrival.dea</a></code> Arrival target setting using DEA <br />
<code><a href="#topic+target.spec.dea">target.spec.dea</a></code> Spec target setting using DEA
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Reproduce Table 4 in Lim, D-J., and Timothy R. Anderson.(2016)
  # Load airplane dataset
  df &lt;- dataset.airplane.2017
  
  # ready
  x &lt;- data.frame(Flew = rep(1, 28))
  y &lt;- subset(df, select = 3 : 7)
  d &lt;- subset(df, select = 2)

  # go
  target.arrival.dea(x, y, d, 2007, "vrs", "o", "min", "d")$arrival_seg
</code></pre>

<hr>
<h2 id='target.arrival.hdf'>Arrival target setting using HDF</h2><span id='topic+target.arrival.hdf'></span>

<h3>Description</h3>

<p>Employs <code>dm.hdf</code> over time to estimate the arrival of known specifications.</p>


<h3>Usage</h3>

<pre><code class='language-R'>target.arrival.hdf(xdata, ydata, date, t, rts="crs", 
                   wd=NULL, sg="ssm", ftype="d", cv="convex", anc=FALSE)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="target.arrival.hdf_+3A_xdata">xdata</code></td>
<td>
<p>Input(s) vector (<em>n</em> by <em>m</em>)</p>
</td></tr>
<tr><td><code id="target.arrival.hdf_+3A_ydata">ydata</code></td>
<td>
<p>Output(s) vector (<em>n</em> by <em>s</em>)</p>
</td></tr>
<tr><td><code id="target.arrival.hdf_+3A_date">date</code></td>
<td>
<p>Production date (<em>n</em> by <em>1</em>)</p>
</td></tr>
<tr><td><code id="target.arrival.hdf_+3A_t">t</code></td>
<td>
<p>A vantage point from which the RoC is captured</p>
</td></tr>
<tr><td><code id="target.arrival.hdf_+3A_rts">rts</code></td>
<td>
<p>Returns to scale assumption <br />
<code>"crs"  </code>Constant RTS (default) <br />  
<code>"vrs"  </code>Variable RTS <br />
<code>"irs"  </code>Increasing RTS <br />
<code>"drs"  </code>Decreasing RTS
</p>
</td></tr>
<tr><td><code id="target.arrival.hdf_+3A_wd">wd</code></td>
<td>
<p>Weak disposability vector indicating (an) undesirable output(s) (<em>1</em> by <em>s</em>)</p>
</td></tr> 
<tr><td><code id="target.arrival.hdf_+3A_sg">sg</code></td>
<td>
<p>Employs second-stage optimization <br />
<code>"ssm"  </code>Slack-sum maximization (default) <br />
<code>"max"  </code>Date-sum maximization <br />
<code>"min"  </code>Date-sum minimization
</p>
</td></tr>
<tr><td><code id="target.arrival.hdf_+3A_ftype">ftype</code></td>
<td>
<p>Frontier type <br />
<code>"d"  </code>Dynamic frontier (default) <br />  
<code>"s"  </code>Static frontier
</p>
</td></tr> 
<tr><td><code id="target.arrival.hdf_+3A_cv">cv</code></td>
<td>
<p>Convexity assumption <br />
<code>"convex" </code>Convexity holds (default) <br />
<code>"fdh"    </code>Free disposal hull (this will override <code>rts</code>)
</p>
</td></tr>
<tr><td><code id="target.arrival.hdf_+3A_anc">anc</code></td>
<td>
<p>Implements a stepwise RoC computation if <code>TRUE</code></p>
</td></tr>
</table>


<h3>Value</h3>

<table>
<tr><td><code>$eff_t</code></td>
<td>
<p>Efficiency at <code>t</code></p>
</td></tr>
<tr><td><code>$lambda_t</code></td>
<td>
<p>Intensity vector at <code>t</code></p>
</td></tr>
<tr><td><code>$eft_date</code></td>
<td>
<p>Effective date</p>
</td></tr>
<tr><td><code>$roc_avg</code></td>
<td>
<p>Average RoC</p>
</td></tr>
<tr><td><code>$roc_anc</code></td>
<td>
<p>Local RoCs across the periods</p>
</td></tr>
<tr><td><code>$roc_local</code></td>
<td>
<p>Local RoC</p>
</td></tr>
<tr><td><code>$roc_ind</code></td>
<td>
<p>Individualized RoC</p>
</td></tr>
<tr><td><code>$arrival_avg</code></td>
<td>
<p>Estimated arrival using <code>roc_avg</code></p>
</td></tr>
<tr><td><code>$arrival_seg</code></td>
<td>
<p>Estimated arrival using <code>roc_ind</code></p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Dong-Joon Lim, PhD</p>


<h3>References</h3>

<p>Lim, Dong-Joon, et al. &quot;Comparing technological advancement of hybrid electric vehicles (HEV) in different market segments.&quot; <em>Technological Forecasting and Social Change</em> 97 (2015): 140~153.
</p>
<p>Lim, Dong-Joon, and Timothy R. Anderson. Time series benchmarking analysis for new product scheduling: who are the competitors and how fast are they moving forward?. <em>Advances in DEA Theory and Applications: with Examples in Forecasting Models</em>. (2017): 443-458.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+dm.hdf">dm.hdf</a></code> Distance measure using HDF <br />
<code><a href="#topic+roc.hdf">roc.hdf</a></code> RoC calculation using HDF <br />
<code><a href="#topic+map.soa.hdf">map.soa.hdf</a></code> SOA mapping using HDF <br />
<code><a href="#topic+target.arrival.hdf">target.arrival.hdf</a></code> Arrival target setting using HDF
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Estimate arrivals of MY2015 SC/TC 8 cylinder engines
  # Load engine dataset
    df &lt;- dataset.engine.2015
  
  # Subset for SC/TC 8 cylinder engines
    stc.8 &lt;- subset(df, grepl("^.C..", df[, 8]) &amp; df[, 3] == 8)
  
  # Parameters
    x &lt;- subset(stc.8, select = 4)
    y &lt;- subset(stc.8, select = 5:7)
    d &lt;- subset(stc.8, select = 2)
  
  # Generate an SOA map
    target.arrival.hdf(x, y, d, 2014, "vrs")
</code></pre>

<hr>
<h2 id='target.arrival.sf'>Arrival target setting using SF</h2><span id='topic+target.arrival.sf'></span>

<h3>Description</h3>

<p>Employs <code>dm.sf</code> over time to estimate the arrival of known specifications. This function is valid only when multiplicative form of directional vector is used.</p>


<h3>Usage</h3>

<pre><code class='language-R'>target.arrival.sf(xdata, ydata, date, t, rts="crs", g=NULL, 
                  wd=NULL, sg="ssm", ftype="d", cv="convex", anc=FALSE)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="target.arrival.sf_+3A_xdata">xdata</code></td>
<td>
<p>Input(s) vector (<em>n</em> by <em>m</em>)</p>
</td></tr>
<tr><td><code id="target.arrival.sf_+3A_ydata">ydata</code></td>
<td>
<p>Output(s) vector (<em>n</em> by <em>s</em>)</p>
</td></tr>
<tr><td><code id="target.arrival.sf_+3A_date">date</code></td>
<td>
<p>Production date (<em>n</em> by <em>1</em>)</p>
</td></tr>
<tr><td><code id="target.arrival.sf_+3A_t">t</code></td>
<td>
<p>A vantage point from which the RoC is captured</p>
</td></tr>
<tr><td><code id="target.arrival.sf_+3A_rts">rts</code></td>
<td>
<p>Returns to scale assumption <br />
<code>"crs"  </code>Constant RTS (default) <br />  
<code>"vrs"  </code>Variable RTS <br />
<code>"irs"  </code>Increasing RTS <br />
<code>"drs"  </code>Decreasing RTS
</p>
</td></tr>
<tr><td><code id="target.arrival.sf_+3A_g">g</code></td>
<td>
<p>Directional vector indicating a measurement direction (<em>n</em> by <em>(m+s)</em>)<br />
By default (<code>NULL</code>), <code>xdata</code> &amp; <code>ydata</code> will be used</p>
</td></tr>
<tr><td><code id="target.arrival.sf_+3A_wd">wd</code></td>
<td>
<p>Weak disposability vector indicating (an) undesirable output(s) (<em>1</em> by <em>s</em>)</p>
</td></tr> 
<tr><td><code id="target.arrival.sf_+3A_sg">sg</code></td>
<td>
<p>Employs second-stage optimization <br />
<code>"ssm"  </code>Slack-sum maximization (default) <br />
<code>"max"  </code>Date-sum maximization <br />
<code>"min"  </code>Date-sum minimization
</p>
</td></tr>
<tr><td><code id="target.arrival.sf_+3A_ftype">ftype</code></td>
<td>
<p>Frontier type <br />
<code>"d"  </code>Dynamic frontier (default) <br />  
<code>"s"  </code>Static frontier
</p>
</td></tr> 
<tr><td><code id="target.arrival.sf_+3A_cv">cv</code></td>
<td>
<p>Convexity assumption <br />
<code>"convex" </code>Convexity holds (default) <br />
<code>"fdh"    </code>Free disposal hull (this will override <code>rts</code>)
</p>
</td></tr>
<tr><td><code id="target.arrival.sf_+3A_anc">anc</code></td>
<td>
<p>Implements a stepwise RoC computation if <code>TRUE</code></p>
</td></tr>
</table>


<h3>Value</h3>

<table>
<tr><td><code>$eff_t</code></td>
<td>
<p>Efficiency at <code>t</code></p>
</td></tr>
<tr><td><code>$lambda_t</code></td>
<td>
<p>Intensity vector at <code>t</code></p>
</td></tr>
<tr><td><code>$eft_date</code></td>
<td>
<p>Effective date</p>
</td></tr>
<tr><td><code>$roc_avg</code></td>
<td>
<p>Average RoC</p>
</td></tr>
<tr><td><code>$roc_anc</code></td>
<td>
<p>Local RoCs across the periods</p>
</td></tr>
<tr><td><code>$roc_local</code></td>
<td>
<p>Local RoC</p>
</td></tr>
<tr><td><code>$roc_ind</code></td>
<td>
<p>Individualized RoC</p>
</td></tr>
<tr><td><code>$arrival_avg</code></td>
<td>
<p>Estimated arrival using <code>roc_avg</code></p>
</td></tr>
<tr><td><code>$arrival_seg</code></td>
<td>
<p>Estimated arrival using <code>roc_ind</code></p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Dong-Joon Lim, PhD</p>


<h3>References</h3>

<p>Lim, Dong-Joon, et al. &quot;Comparing technological advancement of hybrid electric vehicles (HEV) in different market segments.&quot; <em>Technological Forecasting and Social Change</em> 97 (2015): 140~153.
</p>
<p>Lim, Dong-Joon, and Timothy R. Anderson. Time series benchmarking analysis for new product scheduling: who are the competitors and how fast are they moving forward?. <em>Advances in DEA Theory and Applications: with Examples in Forecasting Models</em>. (2017): 443-458.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+dm.sf">dm.sf</a></code> Distance measure using SF <br />
<code><a href="#topic+roc.sf">roc.sf</a></code> RoC calculation using SF <br />
<code><a href="#topic+map.soa.sf">map.soa.sf</a></code> SOA mapping using SF <br />
<code><a href="#topic+target.arrival.sf">target.arrival.sf</a></code> Arrival target setting using SF
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Estimate arrivals of MY2013 hev models
  # Load hev dataset
  df &lt;- dataset.hev.2013
  
  # ready
  x &lt;- subset(df, select = 3)
  y &lt;- subset(df, select = 4 : 6)
  d &lt;- subset(df, select = 2)
  g &lt;- data.frame(x, y)
  
  # go
  target.arrival.sf(x, y, d, 2012, "vrs", g)$arrival_seg
</code></pre>

<hr>
<h2 id='target.spec.dea'>Spec target setting using DEA</h2><span id='topic+target.spec.dea'></span>

<h3>Description</h3>

<p>Employs <code>inverse DEA</code> to estimate specifications(in/out-puts) to achieve a predetermined efficiency.</p>


<h3>Usage</h3>

<pre><code class='language-R'>target.spec.dea(xdata, ydata, date=NULL, t=NULL, dt=NULL, dmu, et="c",
                alpha=NULL, beta=NULL, wv=NULL, rts="crs", sg="ssm", ftype="d",
                ncv=NULL, env=NULL, cv="convex", bound=TRUE, pin=TRUE)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="target.spec.dea_+3A_xdata">xdata</code></td>
<td>
<p>Input(s) vector (<em>n</em> by <em>m</em>)</p>
</td></tr>
<tr><td><code id="target.spec.dea_+3A_ydata">ydata</code></td>
<td>
<p>Output(s) vector (<em>n</em> by <em>s</em>)</p>
</td></tr>
<tr><td><code id="target.spec.dea_+3A_date">date</code></td>
<td>
<p>Production date (<em>n</em> by <em>1</em>)</p>
</td></tr>
<tr><td><code id="target.spec.dea_+3A_t">t</code></td>
<td>
<p>A vantage point from which the RoC is captured</p>
</td></tr>
<tr><td><code id="target.spec.dea_+3A_dt">dt</code></td>
<td>
<p>Delta <em>t</em> i.e., specs are estimated within PPS at <em>t+dt</em></p>
</td></tr>
<tr><td><code id="target.spec.dea_+3A_dmu">dmu</code></td>
<td>
<p>DMU whose inputs(or outputs) are to be estimated</p>
</td></tr>
<tr><td><code id="target.spec.dea_+3A_et">et</code></td>
<td>
<p>Efficiency target; default value (&quot;c&quot;) retains the current efficiency</p>
</td></tr>
<tr><td><code id="target.spec.dea_+3A_alpha">alpha</code></td>
<td>
<p>Perturbed input(s) of designated DMU (<em>1</em> by <em>m</em>)</p>
</td></tr>
<tr><td><code id="target.spec.dea_+3A_beta">beta</code></td>
<td>
<p>Perturbed output(s) of designated DMU (<em>1</em> by <em>s</em>)</p>
</td></tr>
<tr><td><code id="target.spec.dea_+3A_wv">wv</code></td>
<td>
<p>Weight vector for scalarization (<em>1</em> by <em>m</em> or <em>s</em>)</p>
</td></tr>
<tr><td><code id="target.spec.dea_+3A_rts">rts</code></td>
<td>
<p>Returns to scale assumption <br />
<code>"crs"  </code>Constant RTS (default) <br />  
<code>"vrs"  </code>Variable RTS <br />
<code>"irs"  </code>Increasing RTS <br />
<code>"drs"  </code>Decreasing RTS
</p>
</td></tr>
<tr><td><code id="target.spec.dea_+3A_sg">sg</code></td>
<td>
<p>Employs second-stage optimization <br />
<code>"ssm"  </code>Slack-sum maximization (default) <br />
<code>"max"  </code>Date-sum maximization <br />
<code>"min"  </code>Date-sum minimization
</p>
</td></tr>
<tr><td><code id="target.spec.dea_+3A_ftype">ftype</code></td>
<td>
<p>Frontier type <br />
<code>"d"  </code>Dynamic frontier (default) <br />  
<code>"s"  </code>Static frontier
</p>
</td></tr>  
<tr><td><code id="target.spec.dea_+3A_ncv">ncv</code></td>
<td>
<p>Non-controllable variable index(binary) for internal NDF (<em>1</em> by <em>(m+s)</em>)</p>
</td></tr>
<tr><td><code id="target.spec.dea_+3A_env">env</code></td>
<td>
<p>Environment index for external NDF (<em>n</em> by <em>1</em>)</p>
</td></tr>
<tr><td><code id="target.spec.dea_+3A_cv">cv</code></td>
<td>
<p>Convexity assumption <br />
<code>"convex" </code>Convexity holds (default) <br />
<code>"fdh"    </code>Free disposal hull (this will override <code>rts</code>)
</p>
</td></tr>
<tr><td><code id="target.spec.dea_+3A_bound">bound</code></td>
<td>
<p>Puts upper/lower bounds on alpha/beta if <code>TRUE</code>(default)</p>
</td></tr>
<tr><td><code id="target.spec.dea_+3A_pin">pin</code></td>
<td>
<p>Includes the perturbed DMU in the PPS if <code>TRUE</code>(default)</p>
</td></tr>
</table>


<h3>Value</h3>

<table>
<tr><td><code>$alpha</code></td>
<td>
<p>Estimated input(s)</p>
</td></tr>
<tr><td><code>$beta</code></td>
<td>
<p>Estimated output(s)</p>
</td></tr>
<tr><td><code>$lambda</code></td>
<td>
<p>Intensity vector</p>
</td></tr>
<tr><td><code>$xslack</code></td>
<td>
<p>Input slack</p>
</td></tr>
<tr><td><code>$yslack</code></td>
<td>
<p>Output slack</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Dong-Joon Lim, PhD</p>


<h3>References</h3>

<p>Lim, Dong-Joon, &quot;Inverse DEA with frontier changes for new product target setting.&quot; 
<em>European Journal of Operational Research</em> 254.2 (2016): 510~516.
</p>
<p>Wei, Quanling, Jianzhong Zhang, and Xiangsun Zhang. &quot;An inverse DEA model for inputs/outputs estimate.&quot; <em>European Journal of Operational Research</em> 121.1 (2000): 151~163.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+dm.dea">dm.dea</a></code> Distance measure using DEA <br />
<code><a href="#topic+roc.dea">roc.dea</a></code> RoC calculation using DEA <br />
<code><a href="#topic+target.arrival.dea">target.arrival.dea</a></code> Arrival target setting using DEA
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Reproduce Example 2 in Wei, Q. et al.(2000)
  # ready
  x &lt;- matrix(c(1, 1, 1), 3)
  y &lt;- matrix(c(4, 8, 5, 8, 4, 5), 3)
  a &lt;- matrix(1.8, 1)
  w &lt;- matrix(c(0.5, 0.5), 1)
  
  # go
  target.spec.dea(x, y, dmu = 3, alpha = a, wv = w, rts = "crs")$beta

# Reproduce Table 4 in Lim, D-J. (2016)
  # Load engine dataset
    df &lt;- dataset.engine.2015
  
  # Subset for forced induction systems
    fis &lt;- subset(df, grepl("^.C..", df[, 8]))
  
  # ready
    # Suppose one wants to estimate Porsche 911 turbo s' engine specs
    # to retain its current competitiveness with downsized 3.5 litre engine in 2018.
    # What might be the minimum specs to achieve this goal
    # considering the technological changes we've seen so far?
    # Plus, the CEO wants to put more emphasis on the torque improvement over HP.
      d &lt;- subset(fis, select = 2)
      x &lt;- subset(fis, select = 4)
      y &lt;- subset(fis, select = 6 : 7)
      a &lt;- as.matrix(3.5)
      w &lt;- matrix(c(0.3, 0.7), 1)
    
  # go
    target.spec.dea(x, y, d, 2015, 3, 262, alpha = a, wv = w, rts = "vrs", sg = "min")$beta
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
